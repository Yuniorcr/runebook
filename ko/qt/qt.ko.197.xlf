<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="38aec792b4693e26e17a0ed3fd36cc9b20d06dd9" translate="yes" xml:space="preserve">
          <source>The model items contained in the selection range can be obtained using the &lt;a href=&quot;qitemselectionrange#indexes&quot;&gt;indexes&lt;/a&gt;() function. Use &lt;a href=&quot;qitemselectionmodel#selectedIndexes&quot;&gt;QItemSelectionModel::selectedIndexes&lt;/a&gt;() to get a list of all selected items for a view.</source>
          <target state="translated">선택 범위에 포함 된 모델 항목은 &lt;a href=&quot;qitemselectionrange#indexes&quot;&gt;색인&lt;/a&gt; () 기능을 사용하여 얻을 수 있습니다 . &lt;a href=&quot;qitemselectionmodel#selectedIndexes&quot;&gt;QItemSelectionModel :: selectedIndexes&lt;/a&gt; ()를 사용 하여 뷰에 대해 선택된 모든 항목의 목록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9d423cdf76d195345eb3b36194323c106de6577c" translate="yes" xml:space="preserve">
          <source>The model mapper ensures that all the bar box-and-whiskers items in the box plot series have equal sizes. Therefore, adding or removing a value from a box-and-whiskers item causes the same change to be made in all the box-and-whiskers items in the box plot series.</source>
          <target state="translated">모델 맵퍼는 상자 그림 시리즈의 모든 막대 상자 수염 항목이 동일한 크기를 갖도록합니다. 따라서 상자 수염 항목에서 값을 추가하거나 제거하면 상자 그림 시리즈의 모든 상자 수염 항목에서 동일한 변경 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc7dc0909408f70f46a22cf487b42c6733297892" translate="yes" xml:space="preserve">
          <source>The model mapper ensures that all the bar sets in the bar series have equal sizes. Therefore, adding or removing a value from a bar set causes the same change to be made in all the bar sets in the bar series.</source>
          <target state="translated">모델 매퍼는 막대 시리즈의 모든 막대 세트가 동일한 크기를 갖도록합니다. 따라서 막대 세트에서 값을 추가하거나 제거하면 막대 시리즈의 모든 막대 세트에서 동일한 변경이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="c752c3eb92bd1272be5409cf9ba200fbcdd3b374" translate="yes" xml:space="preserve">
          <source>The model mapper ensures that all the box-and-whiskers items in the box plot series have equal sizes. Therefore, adding or removing a value from a box-and-whiskers item causes the same change to be made in all the box-and-whiskers items in the box plot series.</source>
          <target state="translated">모델 매퍼는 상자 그림 시리즈의 모든 상자 및 수염 항목이 동일한 크기를 갖도록합니다. 따라서 상자 수염 항목에서 값을 추가하거나 제거하면 상자 그림 시리즈의 모든 상자 수염 항목에서 동일한 변경 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d0e853ff11d0967748a41797d03f3ad8d2a21dd8" translate="yes" xml:space="preserve">
          <source>The model mapper ensures that all the candlestick items in the candlestick series have equal sizes. Therefore, adding or removing a value from a candlestick item causes the same change to be made in all the candlestick items in the candlestick series.</source>
          <target state="translated">모델 매퍼는 촛대 시리즈의 모든 촛대 항목이 동일한 크기를 갖도록합니다. 따라서 촛대 항목에서 값을 추가하거나 제거하면 촛대 시리즈의 모든 촛대 항목에서 동일한 변경이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="34af41ec3b82ac0ebc5e7911eb152cd44e2848c1" translate="yes" xml:space="preserve">
          <source>The model may supply the value for rotation as either variant that is directly convertible to &lt;a href=&quot;qquaternion&quot;&gt;QQuaternion&lt;/a&gt;, or as one of the string representations: &lt;code&gt;&quot;scalar,x,y,z&quot;&lt;/code&gt; or &lt;code&gt;&quot;@angle,x,y,z&quot;&lt;/code&gt;. The first will construct the quaternion directly with given values, and the second one will construct the quaternion using &lt;a href=&quot;qquaternion#fromAxisAndAngle&quot;&gt;QQuaternion::fromAxisAndAngle&lt;/a&gt;() method.</source>
          <target state="translated">모델은 &lt;a href=&quot;qquaternion&quot;&gt;QQuaternion으로&lt;/a&gt; 직접 변환 가능한 변형 또는 문자열 표현 중 하나 인 &lt;code&gt;&quot;scalar,x,y,z&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;@angle,x,y,z&quot;&lt;/code&gt; 로 회전 값을 제공 할 수 있습니다 . 첫 번째는 주어진 값으로 쿼터니언을 직접 구성하고 두 번째는 &lt;a href=&quot;qquaternion#fromAxisAndAngle&quot;&gt;QQuaternion :: fromAxisAndAngle&lt;/a&gt; () 메소드를 사용하여 쿼터니언을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="3f1511c4cb37df03e226c0ff0daca04a98f513c6" translate="yes" xml:space="preserve">
          <source>The model must also provide code to encode data in the advertised format. This is achieved by reimplementing the &lt;a href=&quot;qabstractitemmodel#mimeData&quot;&gt;QAbstractItemModel::mimeData&lt;/a&gt;() function to provide a &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; object, just as in any other drag and drop operation.</source>
          <target state="translated">모델은 또한 광고 형식으로 데이터를 인코딩하기위한 코드를 제공해야합니다. &lt;a href=&quot;qabstractitemmodel#mimeData&quot;&gt;QMimeData&lt;/a&gt; 를 제공하기 위해 QAbstractItemModel :: mimeData () 함수를 다시 구현하면 &lt;a href=&quot;qmimedata&quot;&gt;됩니다.&lt;/a&gt; 다른 드래그 앤 드롭 작업과 마찬가지로 객체 .</target>
        </trans-unit>
        <trans-unit id="ec3202fe5591a60f8cea0bedc4c203d34ff75afd" translate="yes" xml:space="preserve">
          <source>The model name of the device.</source>
          <target state="translated">장치의 모델명.</target>
        </trans-unit>
        <trans-unit id="8b4304fdf3aad1c1b797e5a72209b76b81b56bf7" translate="yes" xml:space="preserve">
          <source>The model of the camera used to capture the media.</source>
          <target state="translated">미디어를 캡처하는 데 사용되는 카메라 모델입니다.</target>
        </trans-unit>
        <trans-unit id="6f402e0e35b923865d2edbb17a952c996f065963" translate="yes" xml:space="preserve">
          <source>The model of the screen.</source>
          <target state="translated">화면의 모델입니다.</target>
        </trans-unit>
        <trans-unit id="dc582ebf925eeb320635570823d50cdd8cef85b2" translate="yes" xml:space="preserve">
          <source>The model provides a set of data that is used to create the items for a view. For large or dynamic datasets the model is usually provided by a C++ model object. The C++ model object must be a &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass or a simple list.</source>
          <target state="translated">이 모델은보기 항목을 작성하는 데 사용되는 데이터 세트를 제공합니다. 크거나 동적 인 데이터 세트의 경우 모델은 일반적으로 C ++ 모델 객체에 의해 제공됩니다. C ++ 모델 오브젝트는 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 서브 클래스 또는 단순 목록 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="d0ebcd097c81dd05a9997c305f96405f5576736a" translate="yes" xml:space="preserve">
          <source>The model provides a set of data that is used to create the items for the view. For large or dynamic datasets the model is usually provided by a C++ model object. Models can also be created directly in QML, using the &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; type.</source>
          <target state="translated">이 모델은보기 항목을 작성하는 데 사용되는 데이터 세트를 제공합니다. 크거나 동적 인 데이터 세트의 경우 모델은 일반적으로 C ++ 모델 객체에 의해 제공됩니다. &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel을&lt;/a&gt; 사용하여 QML에서 직접 모델을 작성할 수도 있습니다. 유형을 .</target>
        </trans-unit>
        <trans-unit id="aadc44ddd98792a3a01e7ce5ab1213e4a59b1c25" translate="yes" xml:space="preserve">
          <source>The model provides all the standard functions of an editable model, representing the data in the string list as a model with one column and a number of rows equal to the number of items in the list.</source>
          <target state="translated">이 모델은 편집 가능한 모델의 모든 표준 기능을 제공하며, 문자열 목록의 데이터를 하나의 열과 목록의 항목 수와 동일한 행 수를 가진 모델로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="297be0a9abccce547c762fc5cd71e264d610353e" translate="yes" xml:space="preserve">
          <source>The model provides the set of data that is displayed by the view. The &lt;a href=&quot;qml-qtquick-controls-treeview&quot;&gt;TreeView&lt;/a&gt; accept models derived from the &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; class.</source>
          <target state="translated">모델은보기로 표시되는 데이터 세트를 제공합니다. &lt;a href=&quot;qml-qtquick-controls-treeview&quot;&gt;트 리뷰는&lt;/a&gt; 으로부터 파생 모델 동의 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel의&lt;/a&gt; 클래스를.</target>
        </trans-unit>
        <trans-unit id="7b0583a7a5fb4bca293b6f2543c55b297311d7ff" translate="yes" xml:space="preserve">
          <source>The model provides the set of data that is used to create the items in the view. Models can be created directly in QML using &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt; or &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-views-example.html#objectmodel&quot;&gt;ObjectModel&lt;/a&gt;, or provided by C++ model classes. If a C++ model class is used, it must be a subclass of &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; or a simple list.</source>
          <target state="translated">모델은보기에서 항목을 작성하는 데 사용되는 데이터 세트를 제공합니다. 모델 사용 QML에서 직접 만들어 질 수 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;의 ListModel&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt; 또는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-views-example.html#objectmodel&quot;&gt;objectModel를를&lt;/a&gt; 또는 C ++ 클래스 모델에 의해 제공. C ++ 모델 클래스가 사용되는 경우 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 의 서브 클래스 여야합니다. 이거나 간단한 목록 합니다.</target>
        </trans-unit>
        <trans-unit id="9e72eee64c93b0b7de836ed61542d99973158c0b" translate="yes" xml:space="preserve">
          <source>The model provides the set of data that is used to create the items in the view. Models can be created directly in QML using &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt; or &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-views-example.html#objectmodel&quot;&gt;ObjectModel&lt;/a&gt;, or provided by a custom C++ model class. If it is a C++ model, it must be a subclass of &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; or a simple list.</source>
          <target state="translated">모델은보기에서 항목을 작성하는 데 사용되는 데이터 세트를 제공합니다. 모델 사용 QML에서 직접 생성 할 수 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;의 ListModel&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt; 또는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-views-example.html#objectmodel&quot;&gt;objectModel를을&lt;/a&gt; , 또는 사용자 정의 C ++ 모델 클래스에서 제공. C ++ 모델 인 경우 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 의 서브 클래스 이거나 간단한 목록 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="34d465571c4c53fdbf72c4af02dd6efb75002bb4" translate="yes" xml:space="preserve">
          <source>The model provides the set of data that is used to create the items in the view. Models can be created directly in QML using &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt;, &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel&lt;/a&gt;, or &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-views-example.html#objectmodel&quot;&gt;ObjectModel&lt;/a&gt;, or provided by C++ model classes. If a C++ model class is used, it must be a subclass of &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; or a simple list.</source>
          <target state="translated">모델은보기에서 항목을 작성하는 데 사용되는 데이터 세트를 제공합니다. 모델 사용 QML에서 직접 만들어 질 수 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;의 ListModel&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel&quot;&gt;XmlListModel&lt;/a&gt; , &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel&lt;/a&gt; 또는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-views-example.html#objectmodel&quot;&gt;objectModel를를&lt;/a&gt; 또는 C ++ 클래스 모델에 의해 제공. C ++ 모델 클래스가 사용되는 경우 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 의 서브 클래스 여야합니다. 이거나 간단한 목록 합니다.</target>
        </trans-unit>
        <trans-unit id="9237759413ea11cf68c266f4f885d45ee50e3929" translate="yes" xml:space="preserve">
          <source>The model provides the set of data that is used to create the items in the view. Models can be created directly in QML using &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt;, XmlListModel or VisualItemModel, or provided by C++ model classes.</source>
          <target state="translated">모델은보기에서 항목을 작성하는 데 사용되는 데이터 세트를 제공합니다. 모델은 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt; , XmlListModel 또는 VisualItemModel을 사용하여 QML에서 직접 작성 하거나 C ++ 모델 클래스에서 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0b50ca12213c32ecc63c7fe68a6f19b4b554af0" translate="yes" xml:space="preserve">
          <source>The model providing data for the repeater.</source>
          <target state="translated">리피터에 대한 데이터를 제공하는 모델입니다.</target>
        </trans-unit>
        <trans-unit id="f2f0c110f48d902839c45eb4bc9eb2fbd4e70e11" translate="yes" xml:space="preserve">
          <source>The model returns data for the following roles:</source>
          <target state="translated">모델은 다음 역할에 대한 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3eb0a95a24c3de85047536337e667aecf13d09bd" translate="yes" xml:space="preserve">
          <source>The model role used for populating the &lt;a href=&quot;qml-qtquick-controls-combobox&quot;&gt;ComboBox&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-combobox&quot;&gt;ComboBox&lt;/a&gt; 를 채우는 데 사용되는 모델 역할 입니다.</target>
        </trans-unit>
        <trans-unit id="40db7d63c8b82bd61bb431a978e7a01f4fd58e37" translate="yes" xml:space="preserve">
          <source>The model roles</source>
          <target state="translated">모델 역할</target>
        </trans-unit>
        <trans-unit id="e28973ebd5a80df1e5e5fbec575f4ad2349f2d3f" translate="yes" xml:space="preserve">
          <source>The model roles provided by &lt;a href=&quot;qml-qtbluetooth-bluetoothdiscoverymodel&quot;&gt;BluetoothDiscoveryModel&lt;/a&gt; are &lt;code&gt;service&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;remoteAddress&lt;/code&gt; and &lt;code&gt;deviceName&lt;/code&gt;. The meaning of the roles changes based on the current &lt;a href=&quot;qml-qtbluetooth-bluetoothdiscoverymodel#discoveryMode-prop&quot;&gt;discoveryMode&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtbluetooth-bluetoothdiscoverymodel&quot;&gt;BluetoothDiscoveryModel에서&lt;/a&gt; 제공하는 모델 역할 은 &lt;code&gt;service&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;remoteAddress&lt;/code&gt; 및 &lt;code&gt;deviceName&lt;/code&gt; 입니다. 현재 &lt;a href=&quot;qml-qtbluetooth-bluetoothdiscoverymodel#discoveryMode-prop&quot;&gt;discoveryMode&lt;/a&gt; 에 따라 역할의 의미가 변경됩니다. 됩니다.</target>
        </trans-unit>
        <trans-unit id="be6176ea1f21b82c7ed425d8c8ba539548bfa69a" translate="yes" xml:space="preserve">
          <source>The model supports the following roles:</source>
          <target state="translated">이 모델은 다음 역할을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="16b024a8ea8d5cdeb6eba00afdb74c74394eb615" translate="yes" xml:space="preserve">
          <source>The model to populate the &lt;a href=&quot;qml-qtquick-controls-combobox&quot;&gt;ComboBox&lt;/a&gt; from.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-combobox&quot;&gt;ComboBox&lt;/a&gt; 를 채울 모델 입니다.</target>
        </trans-unit>
        <trans-unit id="70cb6fccdcd63c0527822267dcf8a1ed3d6d5010" translate="yes" xml:space="preserve">
          <source>The model/view architecture</source>
          <target state="translated">모델 / 뷰 아키텍처</target>
        </trans-unit>
        <trans-unit id="62a0f47dd83a7158c3d5d1f499a47880505a0601" translate="yes" xml:space="preserve">
          <source>The model/view architecture ensures that the contents of the tree view are updated as the model changes.</source>
          <target state="translated">모델 / 뷰 아키텍처는 모델이 변경 될 때 트리 뷰의 내용이 업데이트되도록합니다.</target>
        </trans-unit>
        <trans-unit id="c70b036c7a854467c85ffbbc2747471829c51972" translate="yes" xml:space="preserve">
          <source>The model/view classes support drag and drop operations, providing default behavior that is sufficient for many applications. However, it is also possible to customize the way items are encoded during drag and drop operations, whether they are copied or moved by default, and how they are inserted into existing models.</source>
          <target state="translated">모델 / 뷰 클래스는 드래그 앤 드롭 작업을 지원하여 많은 응용 프로그램에 충분한 기본 동작을 제공합니다. 그러나 끌어서 놓기 작업 중에 항목이 기본적으로 복사 또는 이동되는지 여부와 항목이 기존 모델에 삽입되는 방식에 따라 항목이 인코딩되는 방식을 사용자 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="50e26cf81aa5927dc4862f4625dae0208d751d43" translate="yes" xml:space="preserve">
          <source>The modified flag is never read by &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;; it has a default value of false and is changed to true whenever the user changes the line edit's contents.</source>
          <target state="translated">수정 된 플래그는 &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit에서&lt;/a&gt; 읽지 않습니다 . 기본값은 false이며 사용자가 행 편집의 내용을 변경할 때마다 true로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="5493947eaa76269a307233c0db43e6c1ca2ea3d8" translate="yes" xml:space="preserve">
          <source>The module also provides the framework for running QML applications. The QML framework allows QML code to contain JavaScript expressions and for the QML code to interact with C++ code.</source>
          <target state="translated">이 모듈은 또한 QML 애플리케이션을 실행하기위한 프레임 워크를 제공합니다. QML 프레임 워크를 통해 QML 코드는 JavaScript 표현식을 포함하고 QML 코드는 C ++ 코드와 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="917beaf604c5a16cf1487203bb394e8c30910958" translate="yes" xml:space="preserve">
          <source>The module consists of six classes</source>
          <target state="translated">이 모듈은 6 개의 클래스로 구성됩니다</target>
        </trans-unit>
        <trans-unit id="4d258b524a4d5af69764b8cf1e9db1754a56160a" translate="yes" xml:space="preserve">
          <source>The module depends on Speech Dispatcher (libspeechd) on the Linux platform. On other platforms, it uses the native APIs to access the platform-specific text-to-speech engines.</source>
          <target state="translated">이 모듈은 Linux 플랫폼의 Speech Dispatcher (libspeechd)에 의존합니다. 다른 플랫폼에서는 고유 API를 사용하여 플랫폼 별 텍스트 음성 변환 엔진에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="49f6ce41863bfa09f4652674b59ae76a5d954da6" translate="yes" xml:space="preserve">
          <source>The module enables a Qt application to support accessibility features such as text-to-speech, which is useful for end-users who are visually challenged or cannot access the application for whatever reason. The most common use case where text-to-speech comes in handy is when the end-user is driving and cannot attend the incoming messages on the phone. In such a scenario, the messaging application can read out the incoming message.</source>
          <target state="translated">이 모듈을 통해 Qt 애플리케이션은 텍스트 음성 변환과 같은 접근성 기능을 지원할 수 있으며, 이는 시각적으로 문제가 있거나 어떤 이유로 든 애플리케이션에 액세스 할 수없는 최종 사용자에게 유용합니다. TTS (텍스트 음성 변환)가 유용한 가장 일반적인 사용 사례는 최종 사용자가 운전 중이고 전화로 들어오는 메시지에 참석할 수없는 경우입니다. 이러한 시나리오에서 메시징 응용 프로그램은 들어오는 메시지를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6de61c3340c46ec86e251f313ffd5776859732be" translate="yes" xml:space="preserve">
          <source>The module is new in Qt 5.1 and requires &lt;a href=&quot;qtquick-index#&quot;&gt;Qt Quick&lt;/a&gt; 2.1.</source>
          <target state="translated">이 모듈은 Qt 5.1의 새로운 기능이며 &lt;a href=&quot;qtquick-index#&quot;&gt;Qt Quick&lt;/a&gt; 2.1이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="a54bd2f11634166e3df7c4ab847aef27d1d30756" translate="yes" xml:space="preserve">
          <source>The module provides a JavaScript library for seamless integration of C++ and QML applications with HTML/JavaScript and QML clients. The clients must use the JavaScript library to access the serialized QObjects published by the host applications.</source>
          <target state="translated">이 모듈은 C ++ 및 QML 애플리케이션과 HTML / JavaScript 및 QML 클라이언트와의 완벽한 통합을위한 JavaScript 라이브러리를 제공합니다. 클라이언트는 JavaScript 라이브러리를 사용하여 호스트 응용 프로그램이 게시 한 직렬화 된 QObject에 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="5d371e8b797731021770b40733784fdb00abc3ea" translate="yes" xml:space="preserve">
          <source>The module provides a single QML component for displaying web content in the application: &lt;a href=&quot;qml-qtwebview-webview&quot;&gt;WebView&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 애플리케이션에 웹 컨텐츠를 표시하기위한 단일 QML 구성 요소를 제공합니다 : &lt;a href=&quot;qml-qtwebview-webview&quot;&gt;WebView&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46f3e294357111e08c52d8cece6ee6b1cdd01d7d" translate="yes" xml:space="preserve">
          <source>The module provides the QML and C++ alternatives for maps and navigation. The C++ alternative provides utility classes to get geocoding (finding a geographic coordinate from a street address) and navigation (including driving and walking directions) information, whereas its QML counterpart provides UI components to render the information.</source>
          <target state="translated">이 모듈은지도 및 탐색을위한 QML 및 C ++ 대안을 제공합니다. C ++ 대안은 지오 코딩 (거리 주소에서 지리적 좌표 찾기) 및 탐색 (운전 및 도보 경로 포함) 정보를 가져 오는 유틸리티 클래스를 제공하는 반면 QML 파트는 정보를 렌더링하는 UI 구성 요소를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="72660e57600d1d85ddab9251aa5a2a89031e37c9" translate="yes" xml:space="preserve">
          <source>The module provides the following &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebsockets-examples.html&quot;&gt;Examples&lt;/a&gt; as a guide to using the API.</source>
          <target state="translated">이 모듈은 API 사용에 대한 안내서로 다음 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebsockets-examples.html&quot;&gt;예&lt;/a&gt; 를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="3e58dbd9dc2c2fff7b76c4097d14526163084211" translate="yes" xml:space="preserve">
          <source>The module was introduced in Qt 5.1.</source>
          <target state="translated">이 모듈은 Qt 5.1에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="b28b347c2b824f815d8969d2cd4711cf79f8e694" translate="yes" xml:space="preserve">
          <source>The module was introduced in Qt 5.5.</source>
          <target state="translated">이 모듈은 Qt 5.5에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="07d66bb5ba854a78169a507ba00574f07829273f" translate="yes" xml:space="preserve">
          <source>The module's documentation will likely contain HTML links to the documentation of one or more of the other Qt modules. For example, most Qt5 modules contain links to documentation in &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-module.html&quot;&gt;QtCore&lt;/a&gt;. When a Qt module contains links into the documentation of other Qt module's, that module is said to depend on those other Qt modules. Hence when QDoc runs the</source>
          <target state="translated">모듈의 문서에는 하나 이상의 다른 Qt 모듈의 문서에 대한 HTML 링크가 포함되어있을 것입니다. 예를 들어, 대부분의 Qt5 모듈에는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtcore-module.html&quot;&gt;QtCore의&lt;/a&gt; 문서에 대한 링크가 포함되어 있습니다 . Qt 모듈에 다른 Qt 모듈의 문서에 대한 링크가 포함 된 경우 해당 모듈은 다른 Qt 모듈에 의존한다고합니다. 따라서 QDoc이 실행될 때</target>
        </trans-unit>
        <trans-unit id="8a76bd8d890bd76ade398768bbe72c3716fb3e10" translate="yes" xml:space="preserve">
          <source>The month as a number with a leading zero (01 to 12)</source>
          <target state="translated">앞에 0이있는 숫자로 표시되는 월 (01-12)</target>
        </trans-unit>
        <trans-unit id="dd32c875b4eab5b826b21d0e23e146962b85613e" translate="yes" xml:space="preserve">
          <source>The month as a number without a leading zero (1 to 12)</source>
          <target state="translated">앞에 0이없는 숫자로 표시되는 월 (1-12)</target>
        </trans-unit>
        <trans-unit id="e2f4bab1eca02b78c9a805b490b8c2d46711feda" translate="yes" xml:space="preserve">
          <source>The month is from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;11&lt;/code&gt; to be consistent with the JavaScript Date object.</source>
          <target state="translated">JavaScript Date 객체와 일치 하는 달은 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;11&lt;/code&gt; 사이입니다.</target>
        </trans-unit>
        <trans-unit id="6ef021073bd7ebee52cec36d7b8531187f370eb2" translate="yes" xml:space="preserve">
          <source>The mood of the media.</source>
          <target state="translated">미디어의 분위기.</target>
        </trans-unit>
        <trans-unit id="077dd1b686b2885e09dff389e1899a9c1a9e370b" translate="yes" xml:space="preserve">
          <source>The most basic use case for a &lt;a href=&quot;qml-qtquick-dialogs-messagedialog&quot;&gt;MessageDialog&lt;/a&gt; is a popup alert. It also allows the user to respond in various ways depending on which buttons are enabled. The dialog is initially invisible. You need to set the properties as desired first, then set &lt;a href=&quot;qml-qtquick-dialogs-messagedialog#visible-prop&quot;&gt;visible&lt;/a&gt; to &lt;code&gt;true&lt;/code&gt; or call &lt;a href=&quot;qml-qtquick-dialogs-messagedialog#open-method&quot;&gt;open()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-dialogs-messagedialog&quot;&gt;MessageDialog&lt;/a&gt; 의 가장 기본적인 사용 사례 는 팝업 경고입니다. 또한 사용자가 활성화 된 버튼에 따라 다양한 방식으로 응답 할 수 있습니다. 대화 상자는 처음에는 보이지 않습니다. 먼저 원하는대로 속성을 설정 한 다음 &lt;a href=&quot;qml-qtquick-dialogs-messagedialog#visible-prop&quot;&gt;visible&lt;/a&gt; 을 &lt;code&gt;true&lt;/code&gt; 로 설정 하거나 &lt;a href=&quot;qml-qtquick-dialogs-messagedialog#open-method&quot;&gt;open ()을&lt;/a&gt; 호출 해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="8a63e14c4cba98494a9dcd62a1c22b5ce094d95b" translate="yes" xml:space="preserve">
          <source>The most common and best supported use case for a multi-screen setup is to open a dedicated &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; or &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; for each screen. With the default &lt;code&gt;threaded&lt;/code&gt; render loop of the Qt Quick scenegraph, each of these windows will get its own dedicated render thread. This is good because the threads can be throttled independently based on vsync, and will not interfere with each other. With the &lt;code&gt;basic&lt;/code&gt; loop this can get problematic and animations may degrade as a result.</source>
          <target state="translated">멀티 스크린 설정에서 가장 일반적으로 지원되는 유스 케이스 는 각 화면에 대해 전용 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 또는 &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; 를 여는 것입니다 . Qt Quick 장면 그래프 의 기본 &lt;code&gt;threaded&lt;/code&gt; 렌더링 루프를 사용하면 이러한 각 창마다 고유의 전용 렌더링 스레드가 제공됩니다. 스레드는 vsync를 기반으로 독립적으로 조절할 수 있으며 서로 방해하지 않기 때문에 좋습니다. &lt;code&gt;basic&lt;/code&gt; 루프를 사용하면 문제가 발생할 수 있으며 결과적으로 애니메이션이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f656449d0ed9f3552f33eaf84e576568f588422d" translate="yes" xml:space="preserve">
          <source>The most common cause of this bug is failure to declare one or more namespaces in your &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;. Consider the following query for selecting all the examples in an XHTML document:</source>
          <target state="translated">이 버그의 가장 일반적인 원인은 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 에서 하나 이상의 네임 스페이스를 선언하지 못했기 때문입니다 . XHTML 문서에서 모든 예제를 선택하려면 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="503116ce121862f819a10cd5285bfb76ee2e76e1" translate="yes" xml:space="preserve">
          <source>The most common kind of path step is called an</source>
          <target state="translated">가장 일반적인 종류의 경로 단계는</target>
        </trans-unit>
        <trans-unit id="4d77885bbfd5cd4c32570c4908fb5d6c19f66ce2" translate="yes" xml:space="preserve">
          <source>The most common setting is &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;Normal&lt;/a&gt;, in which the text entered by the user is displayed verbatim, but &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; also supports modes that allow the entered text to be suppressed or obscured: these include &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;NoEcho&lt;/a&gt;, &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;Password&lt;/a&gt; and &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;PasswordEchoOnEdit&lt;/a&gt;.</source>
          <target state="translated">가장 일반적인 설정은 &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;보통&lt;/a&gt; 이며 사용자가 입력 한 텍스트는 그대로 표시되지만 &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; 은 입력 한 텍스트를 표시하지 않거나 숨길 수있는 모드도 지원합니다 ( &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;NoEcho&lt;/a&gt; , &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;Password&lt;/a&gt; 및 &lt;a href=&quot;qlineedit#EchoMode-enum&quot;&gt;PasswordEchoOnEdit 포함)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc1164e6c9b01688e13a86107452cb802d3f75f6" translate="yes" xml:space="preserve">
          <source>The most common type is SourceOver (often referred to as just alpha blending) where the source pixel is blended on top of the destination pixel in such a way that the alpha component of the source defines the translucency of the pixel.</source>
          <target state="translated">가장 일반적인 유형은 소스의 알파 구성 요소가 픽셀의 반투명도를 정의하는 방식으로 소스 픽셀이 대상 픽셀 위에 블렌딩되는 SourceOver (종종 알파 블렌딩이라고 함)입니다.</target>
        </trans-unit>
        <trans-unit id="7ebe8712af9de8113597b89bbd1296a0e6f7eb1c" translate="yes" xml:space="preserve">
          <source>The most common type of import is a module import. Clients can import &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-identifiedmodules.html#&quot;&gt;QML modules&lt;/a&gt; which register QML object types and JavaScript resources into a given namespace.</source>
          <target state="translated">가장 일반적인 유형의 가져 오기는 모듈 가져 오기입니다. 클라이언트는 QML 객체 유형과 JavaScript 리소스를 지정된 네임 스페이스로 등록하는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-identifiedmodules.html#&quot;&gt;QML 모듈&lt;/a&gt; 을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19e8cc1e1548bf4247b9a91f81cd7e7c2ef02f82" translate="yes" xml:space="preserve">
          <source>The most common usage is to show a splash screen before the main widget is displayed on the screen. This is illustrated in the following code snippet in which a splash screen is displayed and some initialization tasks are performed before the application's main window is shown:</source>
          <target state="translated">가장 일반적인 사용법은 메인 위젯이 화면에 표시되기 전에 스플래시 화면을 표시하는 것입니다. 이는 스플래시 화면이 표시되고 응용 프로그램의 기본 창이 표시되기 전에 일부 초기화 작업이 수행되는 다음 코드 스 니펫에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe1babbc64ab8d5ff5a5c1ab2f52cc87b943cc26" translate="yes" xml:space="preserve">
          <source>The most common use of &lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt; is to: load a translation file, install it using &lt;a href=&quot;qcoreapplication#installTranslator&quot;&gt;QCoreApplication::installTranslator&lt;/a&gt;(), and use it via &lt;a href=&quot;qobject#tr&quot;&gt;QObject::tr&lt;/a&gt;(). Here's an example &lt;code&gt;main()&lt;/code&gt; function using the &lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt; 의 가장 일반적인 용도 는 다음과 같습니다. 번역 파일을로드하고 &lt;a href=&quot;qcoreapplication#installTranslator&quot;&gt;QCoreApplication :: installTranslator&lt;/a&gt; ()를 사용하여 설치 한 후 &lt;a href=&quot;qobject#tr&quot;&gt;QObject :: tr&lt;/a&gt; ()을 통해 사용합니다 . 다음 은 &lt;a href=&quot;qtranslator&quot;&gt;QTranslator를&lt;/a&gt; 사용하는 &lt;code&gt;main()&lt;/code&gt; 함수 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="0e625a517c3c200d2aff0b195a3b46e5f1b9a725" translate="yes" xml:space="preserve">
          <source>The most common use of the \inlineimage command is in lists and tables. Here is an example of including inline images in a list:</source>
          <target state="translated">\ inlineimage 명령의 가장 일반적인 사용은 목록과 테이블입니다. 다음은 목록에 인라인 이미지를 포함시키는 예입니다.</target>
        </trans-unit>
        <trans-unit id="d2ad20a71cc2cf5fbfc371656f6ffa0a688fc981" translate="yes" xml:space="preserve">
          <source>The most common uses of this class are to query the database for the list of font &lt;a href=&quot;qfontdatabase#families&quot;&gt;families&lt;/a&gt;() and for the &lt;a href=&quot;qfontdatabase#pointSizes&quot;&gt;pointSizes&lt;/a&gt;() and &lt;a href=&quot;qfontdatabase#styles&quot;&gt;styles&lt;/a&gt;() that are available for each family. An alternative to &lt;a href=&quot;qfontdatabase#pointSizes&quot;&gt;pointSizes&lt;/a&gt;() is &lt;a href=&quot;qfontdatabase#smoothSizes&quot;&gt;smoothSizes&lt;/a&gt;() which returns the sizes at which a given family and style will look attractive.</source>
          <target state="translated">이 클래스의 가장 일반적인 용도는 데이터베이스 에서 각 패밀리에 사용 가능한 글꼴 &lt;a href=&quot;qfontdatabase#families&quot;&gt;패밀리&lt;/a&gt; 목록 () 및 &lt;a href=&quot;qfontdatabase#pointSizes&quot;&gt;pointSizes&lt;/a&gt; () 및 &lt;a href=&quot;qfontdatabase#styles&quot;&gt;스타일&lt;/a&gt; () 을 쿼리하는 것 입니다. &lt;a href=&quot;qfontdatabase#pointSizes&quot;&gt;pointSizes&lt;/a&gt; () 의 대안 은 &lt;a href=&quot;qfontdatabase#smoothSizes&quot;&gt;smoothSizes&lt;/a&gt; ()로, 주어진 패밀리 및 스타일이 매력적으로 보일 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c610c345f72ac9e6305497271f5abef4737abaa4" translate="yes" xml:space="preserve">
          <source>The most common uses of this class are to register and unregister service names on the bus using the &lt;a href=&quot;qdbusconnectioninterface#registerService&quot;&gt;registerService&lt;/a&gt;() and &lt;a href=&quot;qdbusconnectioninterface#unregisterService&quot;&gt;unregisterService&lt;/a&gt;() functions, query about existing names using the &lt;a href=&quot;qdbusconnectioninterface#isServiceRegistered&quot;&gt;isServiceRegistered&lt;/a&gt;(), &lt;a href=&quot;qdbusconnectioninterface#registeredServiceNames-prop&quot;&gt;registeredServiceNames&lt;/a&gt;() and &lt;a href=&quot;qdbusconnectioninterface#serviceOwner&quot;&gt;serviceOwner&lt;/a&gt;() functions, and to receive notification that a client has registered or de-registered through the &lt;a href=&quot;qdbusconnectioninterface#serviceRegistered&quot;&gt;serviceRegistered&lt;/a&gt;(), &lt;a href=&quot;qdbusconnectioninterface#serviceUnregistered&quot;&gt;serviceUnregistered&lt;/a&gt;() and serviceOwnerChanged() signals.</source>
          <target state="translated">이 클래스의 가장 일반적인 용도는 &lt;a href=&quot;qdbusconnectioninterface#registerService&quot;&gt;registerService&lt;/a&gt; () 및 &lt;a href=&quot;qdbusconnectioninterface#unregisterService&quot;&gt;unregisterService&lt;/a&gt; () 함수를 사용하여 버스에서 서비스 이름을 등록 및 등록 취소 하고 , &lt;a href=&quot;qdbusconnectioninterface#isServiceRegistered&quot;&gt;isServiceRegistered&lt;/a&gt; (), &lt;a href=&quot;qdbusconnectioninterface#registeredServiceNames-prop&quot;&gt;registeredServiceNames&lt;/a&gt; () 및 &lt;a href=&quot;qdbusconnectioninterface#serviceOwner&quot;&gt;serviceOwner&lt;/a&gt; () 함수를 사용하여 기존 이름에 대해 조회 하고 수신하는 것입니다. &lt;a href=&quot;qdbusconnectioninterface#serviceRegistered&quot;&gt;serviceRegistered&lt;/a&gt; (), &lt;a href=&quot;qdbusconnectioninterface#serviceUnregistered&quot;&gt;serviceUnregistered&lt;/a&gt; () 및 serviceOwnerChanged () 신호를 통해 클라이언트가 등록 또는 등록 취소되었음을 알립니다.</target>
        </trans-unit>
        <trans-unit id="0e775dbbf7315f2563ebf1def4a0f29911f41cfa" translate="yes" xml:space="preserve">
          <source>The most common value. On platforms where such information is available this value indicates that the event was generated in response to a genuine mouse event in the system.</source>
          <target state="translated">가장 일반적인 가치. 이러한 정보를 사용할 수있는 플랫폼에서이 값은 시스템에서 실제 마우스 이벤트에 대한 응답으로 이벤트가 생성되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1fea0576104fe384670c4657cb0522b80219802a" translate="yes" xml:space="preserve">
          <source>The most common way of parsing a query string is to initialize it in the constructor by passing it the query string. Otherwise, the &lt;a href=&quot;qurlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;() method can be used to set the query to be parsed. That method can also be used to parse a query with non-standard delimiters, after having set them using the &lt;a href=&quot;qurlquery#setQueryDelimiters&quot;&gt;setQueryDelimiters&lt;/a&gt;() function.</source>
          <target state="translated">쿼리 문자열을 구문 분석하는 가장 일반적인 방법은 생성자에서 쿼리 문자열을 전달하여 쿼리 문자열을 초기화하는 것입니다. 그렇지 않으면 &lt;a href=&quot;qurlquery#setQuery&quot;&gt;setQuery&lt;/a&gt; () 메소드를 사용하여 구문 분석 할 쿼리를 설정할 수 있습니다. &lt;a href=&quot;qurlquery#setQueryDelimiters&quot;&gt;setQueryDelimiters&lt;/a&gt; () 함수를 사용하여 설정 한 후 비표준 구분 기호로 쿼리를 구문 분석하는 데이 메소드를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f4f2fc761576a80c8825d7f0de604599245d982" translate="yes" xml:space="preserve">
          <source>The most common way to construct a &lt;a href=&quot;qmdisubwindow&quot;&gt;QMdiSubWindow&lt;/a&gt; is to call &lt;a href=&quot;qmdiarea#addSubWindow&quot;&gt;QMdiArea::addSubWindow&lt;/a&gt;() with the internal widget as the argument. You can also create a subwindow yourself, and set an internal widget by calling &lt;a href=&quot;qmdisubwindow#setWidget&quot;&gt;setWidget&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qmdisubwindow&quot;&gt;QMdiSubWindow&lt;/a&gt; 를 구성하는 가장 일반적인 방법 은 내부 위젯을 인수로 사용하여 &lt;a href=&quot;qmdiarea#addSubWindow&quot;&gt;QMdiArea :: addSubWindow&lt;/a&gt; () 를 호출 하는 것 입니다 . 하위 창을 직접 만들고 &lt;a href=&quot;qmdisubwindow#setWidget&quot;&gt;setWidget&lt;/a&gt; () 을 호출하여 내부 위젯을 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4db904b38a94e7f55c718caafcf9a251ccb0d9bd" translate="yes" xml:space="preserve">
          <source>The most common way to display a modal dialog is to call its &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt;() function. When the user closes the dialog, &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt;() will provide a useful &lt;a href=&quot;qdialog#return&quot;&gt;return value&lt;/a&gt;. Typically, to get the dialog to close and return the appropriate value, we connect a default button, e.g. &lt;b&gt;OK&lt;/b&gt;, to the &lt;a href=&quot;qdialog#accept&quot;&gt;accept&lt;/a&gt;() slot and a &lt;b&gt;Cancel&lt;/b&gt; button to the &lt;a href=&quot;qdialog#reject&quot;&gt;reject&lt;/a&gt;() slot. Alternatively you can call the &lt;a href=&quot;qdialog#done&quot;&gt;done&lt;/a&gt;() slot with &lt;code&gt;Accepted&lt;/code&gt; or &lt;code&gt;Rejected&lt;/code&gt;.</source>
          <target state="translated">모달 대화 상자를 표시하는 가장 일반적인 방법은 &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt; () 함수 를 호출하는 것입니다. 사용자가 대화 상자를 닫으면 &lt;a href=&quot;qdialog#exec&quot;&gt;exec&lt;/a&gt; ()가 유용한 &lt;a href=&quot;qdialog#return&quot;&gt;반환 값을&lt;/a&gt; 제공 합니다 . 일반적으로 대화 상자를 닫고 적절한 값을 반환하기 위해 기본 버튼 (예 : &lt;b&gt;OK&lt;/b&gt; )을 &lt;a href=&quot;qdialog#accept&quot;&gt;수락&lt;/a&gt; () 슬롯에 연결하고 &lt;b&gt;취소&lt;/b&gt; 버튼을 &lt;a href=&quot;qdialog#reject&quot;&gt;거부&lt;/a&gt; () 슬롯에 연결합니다. 또는 &lt;code&gt;Accepted&lt;/code&gt; 또는 &lt;code&gt;Rejected&lt;/code&gt; 로&lt;a href=&quot;qdialog#done&quot;&gt;done&lt;/a&gt; () 슬롯을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ccd69948ac1c1cfd7c5d6e25649a074fade36ef" translate="yes" xml:space="preserve">
          <source>The most common way to implement an SSL server is to create a subclass of &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; and reimplement &lt;a href=&quot;qtcpserver#incomingConnection&quot;&gt;QTcpServer::incomingConnection&lt;/a&gt;(). The returned socket descriptor is then passed to &lt;a href=&quot;qsslsocket#setSocketDescriptor&quot;&gt;QSslSocket::setSocketDescriptor&lt;/a&gt;().</source>
          <target state="translated">SSL 서버를 구현하는 가장 일반적인 방법은 &lt;a href=&quot;qtcpserver&quot;&gt;QTcpServer&lt;/a&gt; 의 서브 클래스를 작성하고 &lt;a href=&quot;qtcpserver#incomingConnection&quot;&gt;QTcpServer :: incomingConnection&lt;/a&gt; ()을 다시 구현하는 것 입니다. 리턴 된 소켓 설명자는 &lt;a href=&quot;qsslsocket#setSocketDescriptor&quot;&gt;QSslSocket :: setSocketDescriptor&lt;/a&gt; () 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="715c6c9e75a92560d0e30865303d9847b23aae43" translate="yes" xml:space="preserve">
          <source>The most common way to read images is through &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; and &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt;'s constructors, or by calling &lt;a href=&quot;qimage#load&quot;&gt;QImage::load&lt;/a&gt;() and &lt;a href=&quot;qpixmap#load&quot;&gt;QPixmap::load&lt;/a&gt;(). &lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt; is a specialized class which gives you more control when reading images. For example, you can read an image into a specific size by calling &lt;a href=&quot;qimagereader#setScaledSize&quot;&gt;setScaledSize&lt;/a&gt;(), and you can select a clip rect, effectively loading only parts of an image, by calling &lt;a href=&quot;qimagereader#setClipRect&quot;&gt;setClipRect&lt;/a&gt;(). Depending on the underlying support in the image format, this can save memory and speed up loading of images.</source>
          <target state="translated">이미지를 읽는 가장 일반적인 방법은 &lt;a href=&quot;qimage&quot;&gt; QImage&lt;/a&gt; 및 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 의 생성자를 통하거나 &lt;a href=&quot;qimage#load&quot;&gt;QImage :: load&lt;/a&gt; () 및 &lt;a href=&quot;qpixmap#load&quot;&gt;QPixmap :: load&lt;/a&gt; () 를 호출하는 것 입니다. &lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt; 는 이미지를 읽을 때 더 많은 컨트롤을 제공하는 특수 클래스입니다. 예를 들어 &lt;a href=&quot;qimagereader#setScaledSize&quot;&gt;setScaledSize&lt;/a&gt; () 를 호출하여 이미지를 특정 크기로 읽을 수 있으며 &lt;a href=&quot;qimagereader#setClipRect&quot;&gt;setClipRect&lt;/a&gt; () 를 호출하여 클립 rect를 선택하여 이미지의 일부만 효과적으로로드 할 수 있습니다 . 이미지 형식의 기본 지원에 따라 메모리를 절약하고 이미지 로딩 속도를 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d729abd472431cdfa015363e3776a0ff7352c7c" translate="yes" xml:space="preserve">
          <source>The most common way to read images is through &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; and &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt;'s constructors, or by calling the &lt;a href=&quot;qimage#load&quot;&gt;QImage::load&lt;/a&gt;() and &lt;a href=&quot;qpixmap#load&quot;&gt;QPixmap::load&lt;/a&gt;() functions. In addition, Qt provides the &lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt; class which gives more control over the process. Depending on the underlying support in the image format, the functions provided by the class can save memory and speed up loading of images.</source>
          <target state="translated">이미지를 읽는 가장 일반적인 방법은 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 및 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 의 생성자를 통하거나 &lt;a href=&quot;qimage#load&quot;&gt;QImage :: load&lt;/a&gt; () 및 &lt;a href=&quot;qpixmap#load&quot;&gt;QPixmap :: load&lt;/a&gt; () 함수를 호출하는 것입니다. 또한 Qt는 프로세스를보다 &lt;a href=&quot;qimagereader&quot;&gt;효과적으로&lt;/a&gt; 제어 할 수 있는 QImageReader 클래스를 제공합니다. 이미지 형식의 기본 지원에 따라 클래스에서 제공하는 기능으로 메모리를 절약하고 이미지로드 속도를 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="101a019fa46095f6c75cd38237cdb1411ecafd6c" translate="yes" xml:space="preserve">
          <source>The most common way to use &lt;a href=&quot;qgraphicsgridlayout&quot;&gt;QGraphicsGridLayout&lt;/a&gt; is to construct an object on the heap with no parent, add widgets and layouts by calling &lt;a href=&quot;qgraphicsgridlayout#addItem&quot;&gt;addItem&lt;/a&gt;(), and finally assign the layout to a widget by calling &lt;a href=&quot;qgraphicswidget#setLayout&quot;&gt;QGraphicsWidget::setLayout&lt;/a&gt;(). &lt;a href=&quot;qgraphicsgridlayout&quot;&gt;QGraphicsGridLayout&lt;/a&gt; automatically computes the dimensions of the grid as you add items.</source>
          <target state="translated">&lt;a href=&quot;qgraphicsgridlayout&quot;&gt;QGraphicsGridLayout&lt;/a&gt; 을 사용하는 가장 일반적인 방법 은 부모가없는 힙에 오브젝트를 구성하고 &lt;a href=&quot;qgraphicsgridlayout#addItem&quot;&gt;addItem&lt;/a&gt; () 을 호출하여 위젯 및 레이아웃을 추가 한 다음 &lt;a href=&quot;qgraphicswidget#setLayout&quot;&gt;QGraphicsWidget :: setLayout&lt;/a&gt; () 을 호출하여 위젯에 레이아웃을 지정하는 것 입니다. &lt;a href=&quot;qgraphicsgridlayout&quot;&gt;QGraphicsGridLayout&lt;/a&gt; 은 항목을 추가 할 때 그리드의 크기를 자동으로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c141e7d739966d5c5ee7f9540a000b59a61fe21a" translate="yes" xml:space="preserve">
          <source>The most common way to use &lt;a href=&quot;qgraphicslinearlayout&quot;&gt;QGraphicsLinearLayout&lt;/a&gt; is to construct an object on the heap with no parent, add widgets and layouts by calling &lt;a href=&quot;qgraphicslinearlayout#addItem&quot;&gt;addItem&lt;/a&gt;(), and finally assign the layout to a widget by calling &lt;a href=&quot;qgraphicswidget#setLayout&quot;&gt;QGraphicsWidget::setLayout&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qgraphicslinearlayout&quot;&gt;QGraphicsLinearLayout&lt;/a&gt; 을 사용하는 가장 일반적인 방법 은 부모가없는 힙에 객체를 생성하고 &lt;a href=&quot;qgraphicslinearlayout#addItem&quot;&gt;addItem&lt;/a&gt; () 을 호출하여 위젯 및 레이아웃을 추가 한 다음 &lt;a href=&quot;qgraphicswidget#setLayout&quot;&gt;QGraphicsWidget :: setLayout&lt;/a&gt; () 을 호출하여 위젯에 레이아웃을 할당하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a2bf74e32885a141bd8a1e0688a065525463f9ef" translate="yes" xml:space="preserve">
          <source>The most common way to use &lt;a href=&quot;qsctpserver&quot;&gt;QSctpServer&lt;/a&gt; is to construct an object and set the maximum number of channels that the server is prepared to support, by calling &lt;a href=&quot;qsctpserver#setMaximumChannelCount&quot;&gt;setMaximumChannelCount&lt;/a&gt;(). You can set the TCP emulation mode by passing a negative argument in this call. Also, a special value of 0 (the default) indicates to use the peer's value as the actual number of channels. The new incoming connection inherits this number from the server socket descriptor and adjusts it according to the remote endpoint settings.</source>
          <target state="translated">&lt;a href=&quot;qsctpserver&quot;&gt;QSctpServer&lt;/a&gt; 를 사용하는 가장 일반적인 방법 은 &lt;a href=&quot;qsctpserver#setMaximumChannelCount&quot;&gt;setMaximumChannelCount&lt;/a&gt; () 를 호출하여 오브젝트를 구성하고 서버가 지원할 수있는 최대 채널 수를 설정하는 것 입니다. 이 호출에서 음수 인수를 전달하여 TCP 에뮬레이션 모드를 설정할 수 있습니다. 또한 특수 값 0 (기본값)은 피어의 값을 실제 채널 수로 사용함을 나타냅니다. 새 수신 연결은 서버 소켓 디스크립터에서이 번호를 상속하여 원격 엔드 포인트 설정에 따라 조정합니다.</target>
        </trans-unit>
        <trans-unit id="080a7df7369d9a041493304b79bf9386d8a53bc5" translate="yes" xml:space="preserve">
          <source>The most common way to use &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; is to construct an object and start a secure connection by calling &lt;a href=&quot;qsslsocket#connectToHostEncrypted&quot;&gt;connectToHostEncrypted&lt;/a&gt;(). This method starts an immediate SSL handshake once the connection has been established.</source>
          <target state="translated">&lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 을 사용하는 가장 일반적인 방법 은 &lt;a href=&quot;qsslsocket#connectToHostEncrypted&quot;&gt;connectToHostEncrypted&lt;/a&gt; () 를 호출하여 오브젝트를 구성하고 보안 연결을 시작하는 것 입니다. 이 방법은 연결이 설정되면 즉시 SSL 핸드 셰이크를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="145c07f52f7a1794fe66e7cb9f11ab1638511073" translate="yes" xml:space="preserve">
          <source>The most common way to use &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; is to initialize it via the constructor by passing a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;. Otherwise, &lt;a href=&quot;qurl#setUrl&quot;&gt;setUrl&lt;/a&gt;() can also be used.</source>
          <target state="translated">&lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 을 사용하는 가장 일반적인 방법 은 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 을 전달하여 생성자를 통해 초기화하는 것 입니다. 그렇지 않으면 &lt;a href=&quot;qurl#setUrl&quot;&gt;setUrl&lt;/a&gt; ()을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ef1f3c9d168542f53d1e3eb408ecbab6d6c9f1e" translate="yes" xml:space="preserve">
          <source>The most common way to use this class is to bind to an address and port using &lt;a href=&quot;qabstractsocket#bind&quot;&gt;bind&lt;/a&gt;(), then call &lt;a href=&quot;qudpsocket#writeDatagram&quot;&gt;writeDatagram&lt;/a&gt;() and &lt;a href=&quot;qudpsocket#readDatagram&quot;&gt;readDatagram&lt;/a&gt;() / &lt;a href=&quot;qudpsocket#receiveDatagram&quot;&gt;receiveDatagram&lt;/a&gt;() to transfer data. If you want to use the standard &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; functions &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt;(), &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt;(), &lt;a href=&quot;qiodevice#write&quot;&gt;write&lt;/a&gt;(), etc., you must first connect the socket directly to a peer by calling &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;connectToHost&lt;/a&gt;().</source>
          <target state="translated">이 클래스를 사용하는 가장 일반적인 방법은 &lt;a href=&quot;qabstractsocket#bind&quot;&gt;bind&lt;/a&gt; ()를 사용하여 주소와 포트에 바인딩 한 다음 &lt;a href=&quot;qudpsocket#writeDatagram&quot;&gt;writeDatagram&lt;/a&gt; () 및 &lt;a href=&quot;qudpsocket#readDatagram&quot;&gt;readDatagram&lt;/a&gt; () / &lt;a href=&quot;qudpsocket#receiveDatagram&quot;&gt;receiveDatagram&lt;/a&gt; ()을 호출 하여 데이터를 전송하는 것입니다. 표준 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 함수 &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt; (), &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt; (),&lt;a href=&quot;qiodevice#write&quot;&gt; write&lt;/a&gt; () 등을 사용하려면 먼저 &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;connectToHost&lt;/a&gt; () 를 호출하여 소켓을 피어에 직접 연결해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c3df83c8653c29a2f372ccd5a983b4c4726e64ec" translate="yes" xml:space="preserve">
          <source>The most commonly used modes are SingleSelection and ExtendedSelection.</source>
          <target state="translated">가장 일반적으로 사용되는 모드는 SingleSelection 및 ExtendedSelection입니다.</target>
        </trans-unit>
        <trans-unit id="ecd692877318fed8774ed47e8945e6e3d95baeba" translate="yes" xml:space="preserve">
          <source>The most commonly used properties are:</source>
          <target state="translated">가장 일반적으로 사용되는 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50cd774ed04629a78087b6bacea7a024ddc49e31" translate="yes" xml:space="preserve">
          <source>The most commonly used transformations are scaling, rotation, translation and shearing. Use the &lt;a href=&quot;qpainter#scale&quot;&gt;scale&lt;/a&gt;() function to scale the coordinate system by a given offset, the &lt;a href=&quot;qpainter#rotate&quot;&gt;rotate&lt;/a&gt;() function to rotate it clockwise and &lt;a href=&quot;qpainter#translate&quot;&gt;translate&lt;/a&gt;() to translate it (i.e. adding a given offset to the points). You can also twist the coordinate system around the origin using the &lt;a href=&quot;qpainter#shear&quot;&gt;shear&lt;/a&gt;() function. See the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwidgets-painting-affine-example.html&quot;&gt;Affine Transformations&lt;/a&gt; example for a visualization of a sheared coordinate system.</source>
          <target state="translated">가장 일반적으로 사용되는 변형은 스케일링, 회전, 평행 이동 및 전단입니다. 사용 &lt;a href=&quot;qpainter#scale&quot;&gt;규모&lt;/a&gt; 오프셋 주어진에 의해 좌표 시스템을 확장 () 함수를 &lt;a href=&quot;qpainter#rotate&quot;&gt;회전&lt;/a&gt; 시계 방향으로 회전 () 함수 &lt;a href=&quot;qpainter#translate&quot;&gt;변환&lt;/a&gt; (이) 그것을 번역하는 (즉, 추가, 포인트에 지정된 오프셋 (offset)). &lt;a href=&quot;qpainter#shear&quot;&gt;shear&lt;/a&gt; () 함수를 사용하여 원점을 중심으로 좌표계를 비틀 수도 있습니다. 전단 좌표계의 시각화는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwidgets-painting-affine-example.html&quot;&gt;변환 정의&lt;/a&gt; 예를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8aec22886ecded29c421e65588d616b64d41dc05" translate="yes" xml:space="preserve">
          <source>The most convenient way to handle the input is to read it in a single pass using the &lt;a href=&quot;qxmlsimplereader#parse&quot;&gt;parse&lt;/a&gt;() function with an argument that specifies the input source:</source>
          <target state="translated">입력을 처리하는 가장 편리한 방법 은 입력 소스를 지정하는 인수와 함께 &lt;a href=&quot;qxmlsimplereader#parse&quot;&gt;구문 분석&lt;/a&gt; () 함수를 사용하여 단일 패스로 입력을 읽는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="34e71e3463bf5736f59ee0738079d0f66a536785" translate="yes" xml:space="preserve">
          <source>The most efficient way to set this property is by using the registered component's UUID, e.g.</source>
          <target state="translated">이 속성을 설정하는 가장 효율적인 방법은 등록 된 구성 요소의 UUID를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fc8ed8ecee363f4eda84ea81735fde8b6a52e8a9" translate="yes" xml:space="preserve">
          <source>The most important classes in the Qt GUI module are &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; and &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt;. A Qt application that wants to show content on screen, will need to make use of these. &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; contains the main event loop, where all events from the window system and other sources are processed and dispatched. It also handles the application's initialization and finalization.</source>
          <target state="translated">Qt GUI 모듈에서 가장 중요한 클래스는 &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; 및 &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; 입니다. 화면에 콘텐츠를 표시하려는 Qt 응용 프로그램은 이러한 기능을 사용해야합니다. &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; 에는 윈도우 시스템 및 기타 소스의 모든 이벤트가 처리 및 발송되는 기본 이벤트 루프가 포함되어 있습니다. 또한 응용 프로그램의 초기화 및 마무리를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="ba0626a0be1eb4a5cd315b64ee8d66bfbecc3f05" translate="yes" xml:space="preserve">
          <source>The most important feature of &lt;a href=&quot;qdomdocumentfragment&quot;&gt;QDomDocumentFragment&lt;/a&gt; is that it is treated in a special way by &lt;a href=&quot;qdomnode#insertAfter&quot;&gt;QDomNode::insertAfter&lt;/a&gt;(), &lt;a href=&quot;qdomnode#insertBefore&quot;&gt;QDomNode::insertBefore&lt;/a&gt;(), &lt;a href=&quot;qdomnode#replaceChild&quot;&gt;QDomNode::replaceChild&lt;/a&gt;() and &lt;a href=&quot;qdomnode#appendChild&quot;&gt;QDomNode::appendChild&lt;/a&gt;(): instead of inserting the fragment itself, all the fragment's children are inserted.</source>
          <target state="translated">&lt;a href=&quot;qdomdocumentfragment&quot;&gt;QDomDocumentFragment&lt;/a&gt; 의 가장 중요한 기능은 QDomNode &lt;a href=&quot;qdomnode#insertAfter&quot;&gt;:: insertAfter&lt;/a&gt; (), &lt;a href=&quot;qdomnode#insertBefore&quot;&gt;QDomNode :: insertBefore&lt;/a&gt; (), &lt;a href=&quot;qdomnode#replaceChild&quot;&gt;QDomNode :: replaceChild&lt;/a&gt; () 및 &lt;a href=&quot;qdomnode#appendChild&quot;&gt;QDomNode :: appendChild에&lt;/a&gt; 의해 특별한 방식으로 처리된다는 것입니다. 조각 자체를 삽입하는 대신 ()에 . , 조각의 모든 자식이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="3895bf2c5a5d1e4e3c5fd9a6bba43c59be210d4b" translate="yes" xml:space="preserve">
          <source>The most important functions are &lt;a href=&quot;qlibrary#load&quot;&gt;load&lt;/a&gt;() to dynamically load the library file, &lt;a href=&quot;qlibrary#isLoaded&quot;&gt;isLoaded&lt;/a&gt;() to check whether loading was successful, and &lt;a href=&quot;qlibrary#resolve&quot;&gt;resolve&lt;/a&gt;() to resolve a symbol in the library. The &lt;a href=&quot;qlibrary#resolve&quot;&gt;resolve&lt;/a&gt;() function implicitly tries to load the library if it has not been loaded yet. Multiple instances of &lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; can be used to access the same physical library. Once loaded, libraries remain in memory until the application terminates. You can attempt to unload a library using &lt;a href=&quot;qlibrary#unload&quot;&gt;unload&lt;/a&gt;(), but if other instances of &lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; are using the same library, the call will fail, and unloading will only happen when every instance has called &lt;a href=&quot;qlibrary#unload&quot;&gt;unload&lt;/a&gt;().</source>
          <target state="translated">가장 중요한 함수는 라이브러리 파일을 동적으로로드하는 &lt;a href=&quot;qlibrary#load&quot;&gt;load&lt;/a&gt; (), 로드가 성공적인지 확인하는 &lt;a href=&quot;qlibrary#isLoaded&quot;&gt;isLoaded&lt;/a&gt; () 및 라이브러리의 심볼 을 확인하는 &lt;a href=&quot;qlibrary#resolve&quot;&gt;resolve&lt;/a&gt; ()입니다. &lt;a href=&quot;qlibrary#resolve&quot;&gt;해결&lt;/a&gt; () 함수는 암시가 아직로드되지 않은 경우 라이브러리를로드하려고합니다. &lt;a href=&quot;qlibrary&quot;&gt;QLibrary의&lt;/a&gt; 여러 인스턴스를 사용하여 동일한 실제 라이브러리에 액세스 할 수 있습니다. 라이브러리가로드되면 응용 프로그램이 종료 될 때까지 메모리에 남아 있습니다. &lt;a href=&quot;qlibrary#unload&quot;&gt;unload&lt;/a&gt; ()를 사용하여 라이브러리 언로드를 시도 할 수 있지만 &lt;a href=&quot;qlibrary&quot;&gt;QLibrary의&lt;/a&gt; 다른 인스턴스가 동일한 라이브러리를 사용하는 경우 호출이 실패하며 모든 인스턴스가 &lt;a href=&quot;qlibrary#unload&quot;&gt;unload&lt;/a&gt; ()를 호출 한 경우에만 언로드가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="f90807f717846cf773e37b42d91c6444f06fc3a6" translate="yes" xml:space="preserve">
          <source>The most important functions are &lt;a href=&quot;qpluginloader#load&quot;&gt;load&lt;/a&gt;() to dynamically load the plugin file, &lt;a href=&quot;qpluginloader#isLoaded&quot;&gt;isLoaded&lt;/a&gt;() to check whether loading was successful, and &lt;a href=&quot;qpluginloader#instance&quot;&gt;instance&lt;/a&gt;() to access the root component in the plugin. The &lt;a href=&quot;qpluginloader#instance&quot;&gt;instance&lt;/a&gt;() function implicitly tries to load the plugin if it has not been loaded yet. Multiple instances of &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; can be used to access the same physical plugin.</source>
          <target state="translated">가장 중요한 기능은 플러그인 파일을 동적으로로드하는 &lt;a href=&quot;qpluginloader#load&quot;&gt;load&lt;/a&gt; (), 로드가 성공했는지 확인하는 &lt;a href=&quot;qpluginloader#isLoaded&quot;&gt;isLoaded&lt;/a&gt; () 및 플러그인의 루트 구성 요소에 액세스하는 &lt;a href=&quot;qpluginloader#instance&quot;&gt;인스턴스&lt;/a&gt; ()입니다. &lt;a href=&quot;qpluginloader#instance&quot;&gt;예&lt;/a&gt; () 함수는 암시가 아직로드되지 않은 경우 플러그인을로드하려고합니다. &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader의&lt;/a&gt; 여러 인스턴스를 사용하여 동일한 물리적 플러그인에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84a7920f760a9ea577836c1378cbbb816b41e993" translate="yes" xml:space="preserve">
          <source>The most important modes or states are:</source>
          <target state="translated">가장 중요한 모드 또는 상태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ba1c0d24d5259fab8c98b33ad7f506aabad303a4" translate="yes" xml:space="preserve">
          <source>The most important node for users is the &lt;a href=&quot;qsggeometrynode&quot;&gt;QSGGeometryNode&lt;/a&gt;. It is used to define custom graphics by defining its geometry and material. The geometry is defined using &lt;a href=&quot;qsggeometry&quot;&gt;QSGGeometry&lt;/a&gt; and describes the shape or mesh of the graphical primitive. It can be a line, a rectangle, a polygon, many disconnected rectangles, or complex 3D mesh. The material defines how the pixels in this shape are filled.</source>
          <target state="translated">사용자에게 가장 중요한 노드는 &lt;a href=&quot;qsggeometrynode&quot;&gt;QSGGeometryNode&lt;/a&gt; 입니다. 지오메트리 및 재질을 정의하여 사용자 정의 그래픽을 정의하는 데 사용됩니다. 기하학은 &lt;a href=&quot;qsggeometry&quot;&gt;QSGGeometry를&lt;/a&gt; 사용하여 정의 되며 그래픽 기본 요소의 모양 또는 메시를 설명합니다. 선, 사각형, 다각형, 연결이 끊긴 사각형 또는 복잡한 3D 메쉬 일 수 있습니다. 재질은이 모양의 픽셀이 채워지는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ff58163c9bd5f70dda347b25fbb1f00a48df31d9" translate="yes" xml:space="preserve">
          <source>The most important parameters are &lt;code&gt;-device&lt;/code&gt; and &lt;code&gt;-sysroot&lt;/code&gt;. By specifying &lt;code&gt;-sysroot&lt;/code&gt;, the include files and libraries used by &lt;code&gt;configure&lt;/code&gt;'s feature detection tests, as well as Qt itself, are taken from the specified location, instead of the host PC's standard locations. Consequently, installing development packages on the host machine has no relevance. For example, to get &lt;code&gt;libinput&lt;/code&gt; support, it is not sufficient or necessary to have the &lt;code&gt;libinput&lt;/code&gt; development headers and libraries installed on the host environment. Instead, the headers and the libraries for the target architecture, such as ARM, must be present in the &lt;code&gt;sysroot&lt;/code&gt;.</source>
          <target state="translated">가장 중요한 매개 변수는 &lt;code&gt;-device&lt;/code&gt; 및 &lt;code&gt;-sysroot&lt;/code&gt; 입니다. &lt;code&gt;-sysroot&lt;/code&gt; 를 지정 하면 Qt 자체뿐만 아니라 &lt;code&gt;configure&lt;/code&gt; 의 기능 감지 테스트에 사용되는 포함 파일 및 라이브러리 가 호스트 PC의 표준 위치 대신 지정된 위치에서 가져옵니다. 결과적으로 호스트 시스템에 개발 패키지를 설치하는 것은 관련이 없습니다. 예를 들어, &lt;code&gt;libinput&lt;/code&gt; 지원 을 받으려면 호스트 환경에 &lt;code&gt;libinput&lt;/code&gt; 개발 헤더 및 라이브러리를 설치 하는 것만 으로는 충분하지 않습니다 . 대신 대상 아키텍처 (예 : ARM)의 헤더 및 라이브러리가 &lt;code&gt;sysroot&lt;/code&gt; 에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="db87671be54de68d316f00bfd770809b6606b886" translate="yes" xml:space="preserve">
          <source>The most important parameters are &lt;code&gt;-device&lt;/code&gt;, &lt;code&gt;-device-option&lt;/code&gt; CROSS_COMPILE=&amp;lt;arch&amp;gt;, &lt;code&gt;-sysroot&lt;/code&gt; and &lt;code&gt;-no-gcc-sysroot&lt;/code&gt;. By specifying &lt;code&gt;-sysroot&lt;/code&gt;, the include files and libraries used by &lt;code&gt;configure&lt;/code&gt;'s feature detection tests, as well as Qt itself, will be taken from the specified location, instead of the host PC's standard locations. This means that installing development packages on the host machine has no relevance. Instead, the headers and the libraries for the target architecture (e.g. ARM) have to be present in the sysroot.</source>
          <target state="translated">가장 중요한 매개 변수는 &lt;code&gt;-device&lt;/code&gt; , &lt;code&gt;-device-option&lt;/code&gt; CROSS_COMPILE = &amp;lt;arch&amp;gt;, &lt;code&gt;-sysroot&lt;/code&gt; 및 &lt;code&gt;-no-gcc-sysroot&lt;/code&gt; 입니다. &lt;code&gt;-sysroot&lt;/code&gt; 를 지정 하면 &lt;code&gt;configure&lt;/code&gt; 기능 검사 테스트에 사용 된 포함 파일 및 라이브러리 와 Qt 자체가 호스트 PC의 표준 위치 대신 지정된 위치에서 가져옵니다. 즉, 호스트 시스템에 개발 패키지를 설치하면 관련이 없습니다. 대신 대상 아키텍처 (예 : ARM)의 헤더 및 라이브러리가 sysroot에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ca622b5fddbc29c66b9d38eb754c2ee834b40271" translate="yes" xml:space="preserve">
          <source>The most important parameters are:</source>
          <target state="translated">가장 중요한 매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="11194d8293cc08a60b190404c9b817b2a22c92f7" translate="yes" xml:space="preserve">
          <source>The most important part of &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt;'s API is the &lt;a href=&quot;qtabbar#currentChanged&quot;&gt;currentChanged&lt;/a&gt;() signal. This is emitted whenever the current tab changes (even at startup, when the current tab changes from 'none'). There is also a slot, &lt;a href=&quot;qtabbar#currentIndex-prop&quot;&gt;setCurrentIndex&lt;/a&gt;(), which can be used to select a tab programmatically. The function &lt;a href=&quot;qtabbar#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt;() returns the index of the current tab, &lt;a href=&quot;qtabbar#count-prop&quot;&gt;count&lt;/a&gt; holds the number of tabs.</source>
          <target state="translated">&lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; API 의 가장 중요한 부분은 &lt;a href=&quot;qtabbar#currentChanged&quot;&gt;currentChanged&lt;/a&gt; () 신호입니다. 현재 탭이 변경 될 때마다 (시작시에도 현재 탭이 '없음'에서 변경 될 때) 방출됩니다. 프로그래밍 방식으로 탭을 선택하는 데 사용할 수 있는 슬롯 &lt;a href=&quot;qtabbar#currentIndex-prop&quot;&gt;setCurrentIndex&lt;/a&gt; ()도 있습니다. &lt;a href=&quot;qtabbar#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; () 함수 는 현재 탭의 인덱스를 반환하며 &lt;a href=&quot;qtabbar#count-prop&quot;&gt;count&lt;/a&gt; 는 탭 수를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="6e3c4cd02f92d0ca8be0de1a2b5ea89990122b97" translate="yes" xml:space="preserve">
          <source>The most important properties are &lt;a href=&quot;qml-qtquick-accessible#name-prop&quot;&gt;name&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-accessible#description-prop&quot;&gt;description&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-accessible#role-prop&quot;&gt;role&lt;/a&gt;.</source>
          <target state="translated">가장 중요한 속성은 &lt;a href=&quot;qml-qtquick-accessible#name-prop&quot;&gt;이름&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-accessible#description-prop&quot;&gt;설명&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-accessible#role-prop&quot;&gt;역할&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8d4b3eab8a2c0a58659ef573fd7ab3da932ebe04" translate="yes" xml:space="preserve">
          <source>The most important properties of frames are &lt;code&gt;frameShape&lt;/code&gt;, &lt;code&gt;frameShadow&lt;/code&gt;, &lt;code&gt;lineWidth&lt;/code&gt;, and &lt;code&gt;midLineWidth&lt;/code&gt;. These are described in more detail in the &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt; class description.</source>
          <target state="translated">프레임의 가장 중요한 속성은 &lt;code&gt;frameShape&lt;/code&gt; , &lt;code&gt;frameShadow&lt;/code&gt; , &lt;code&gt;lineWidth&lt;/code&gt; 및 &lt;code&gt;midLineWidth&lt;/code&gt; 입니다. 이것들은 &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt; 클래스 설명 에 더 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fb53c0d52741963a4203438d52e2bf7eae2174f" translate="yes" xml:space="preserve">
          <source>The most important tip is: use the QML profiler included with Qt Creator. Knowing where time is spent in an application will allow you to focus on problem areas which actually exist, rather than problem areas which potentially exist. See the Qt Creator manual for more information on how to use the QML profiling tool.</source>
          <target state="translated">가장 중요한 팁은 Qt Creator에 포함 된 QML 프로파일 러를 사용하는 것입니다. 응용 프로그램에서 시간이 소비되는 위치를 알면 잠재적으로 존재하는 문제 영역이 아니라 실제로 존재하는 문제 영역에 집중할 수 있습니다. QML 프로파일 링 도구 사용 방법에 대한 자세한 내용은 Qt Creator 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cf514f3fadcb63f428ee341023509db58307acaa" translate="yes" xml:space="preserve">
          <source>The most interesting information held in a &lt;a href=&quot;qml-qtlocation-routemaneuver&quot;&gt;RouteManeuver&lt;/a&gt; instance is normally the textual navigation to provide and the position at which to provide it, accessible by &lt;a href=&quot;qml-qtlocation-routemaneuver#instructionText-prop&quot;&gt;instructionText&lt;/a&gt; and &lt;a href=&quot;qml-qtlocation-routemaneuver#position-prop&quot;&gt;position&lt;/a&gt; respectively.</source>
          <target state="translated">&lt;a href=&quot;qml-qtlocation-routemaneuver&quot;&gt;RouteManeuver&lt;/a&gt; 인스턴스에 보유 된 가장 흥미로운 정보 는 일반적으로 제공 할 텍스트 탐색 및 제공 위치, &lt;a href=&quot;qml-qtlocation-routemaneuver#instructionText-prop&quot;&gt;instructionText&lt;/a&gt; 및 &lt;a href=&quot;qml-qtlocation-routemaneuver#position-prop&quot;&gt;위치에&lt;/a&gt; 의해 각각 액세스 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="9bba8a52a5116b760a5c50bf0c0410b2e4bbb4fd" translate="yes" xml:space="preserve">
          <source>The most interesting information help in a &lt;a href=&quot;qgeomaneuver&quot;&gt;QGeoManeuver&lt;/a&gt; instance is normally the textual navigation to provide and the position at which to provide it, accessible by &lt;a href=&quot;qgeomaneuver#instructionText&quot;&gt;instructionText&lt;/a&gt;() and &lt;a href=&quot;qgeomaneuver#position&quot;&gt;position&lt;/a&gt;() respectively.</source>
          <target state="translated">&lt;a href=&quot;qgeomaneuver&quot;&gt;QGeoManeuver&lt;/a&gt; 인스턴스 에서 가장 흥미로운 정보 도움말 은 일반적으로 제공 할 텍스트 탐색 및이를 제공 할 위치로, &lt;a href=&quot;qgeomaneuver#instructionText&quot;&gt;instructionText&lt;/a&gt; () 및 &lt;a href=&quot;qgeomaneuver#position&quot;&gt;position&lt;/a&gt; ()에 의해 각각 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03e5f595b706dd89beb005f0216e8602ad8f1055" translate="yes" xml:space="preserve">
          <source>The most straight-forward way to setup tool tips for controls is to specify &lt;a href=&quot;qml-qtquick-controls2-tooltip#text-attached-prop&quot;&gt;text&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-tooltip#visible-attached-prop&quot;&gt;visibility&lt;/a&gt; via attached properties. The following example illustrates this approach:</source>
          <target state="translated">컨트롤에 대한 도구 설명을 설정하는 가장 간단한 방법은 첨부 된 속성을 통해 &lt;a href=&quot;qml-qtquick-controls2-tooltip#text-attached-prop&quot;&gt;텍스트&lt;/a&gt; 와 &lt;a href=&quot;qml-qtquick-controls2-tooltip#visible-attached-prop&quot;&gt;가시성&lt;/a&gt; 을 지정하는 것 입니다. 다음 예제는이 접근법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a4d51d039fef172545b538c5020375d8f06650d1" translate="yes" xml:space="preserve">
          <source>The most straight-forward way to use &lt;a href=&quot;qml-qt-labs-platform-menuitemgroup&quot;&gt;MenuItemGroup&lt;/a&gt; is to assign a list of items.</source>
          <target state="translated">&lt;a href=&quot;qml-qt-labs-platform-menuitemgroup&quot;&gt;MenuItemGroup&lt;/a&gt; 을 사용하는 가장 간단한 방법 은 항목 목록을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="61b2fff50270b3a58495f59ce8c26aa34e491899" translate="yes" xml:space="preserve">
          <source>The most straight-forward way to use &lt;a href=&quot;qml-qtquick-controls2-actiongroup&quot;&gt;ActionGroup&lt;/a&gt; is to declare actions as children of the group.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-actiongroup&quot;&gt;ActionGroup&lt;/a&gt; 을 사용하는 가장 간단한 방법 은 조치를 그룹의 하위로 선언하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d5497b94c89793e9a2a385d877dc29d0014e9f97" translate="yes" xml:space="preserve">
          <source>The most straight-forward way to use &lt;a href=&quot;qml-qtquick-controls2-buttongroup&quot;&gt;ButtonGroup&lt;/a&gt; is to assign a list of buttons. For example, the list of children of a &lt;a href=&quot;qtquick-positioning-layouts&quot;&gt;positioner&lt;/a&gt; or a &lt;a href=&quot;qtquicklayouts-index&quot;&gt;layout&lt;/a&gt; that manages a group of mutually exclusive buttons.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-buttongroup&quot;&gt;ButtonGroup&lt;/a&gt; 을 사용하는 가장 간단한 방법 은 버튼 목록을 지정하는 것입니다. 예를 들어 &lt;a href=&quot;qtquick-positioning-layouts&quot;&gt;포지셔너&lt;/a&gt; 의 하위 목록 또는 상호 배타적 인 버튼 그룹을 관리하는 &lt;a href=&quot;qtquicklayouts-index&quot;&gt;레이아웃&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bf1e9f532a7d2a326bbb5e05543ea5c9c2135759" translate="yes" xml:space="preserve">
          <source>The mouse</source>
          <target state="translated">마우스</target>
        </trans-unit>
        <trans-unit id="a0a5e9a726ae51e9830836fa9f673ee593ef7b4e" translate="yes" xml:space="preserve">
          <source>The mouse and keyboard states are specified by</source>
          <target state="translated">마우스 및 키보드 상태는</target>
        </trans-unit>
        <trans-unit id="3e6f9e24674f941d97192b30da97f7e8d51ca4d8" translate="yes" xml:space="preserve">
          <source>The mouse and keyboard states at the time of the event are specified by</source>
          <target state="translated">이벤트 시점의 마우스 및 키보드 상태는</target>
        </trans-unit>
        <trans-unit id="0389dd7ddb098da576180d61b8fa9c82c12bf721" translate="yes" xml:space="preserve">
          <source>The mouse axis.</source>
          <target state="translated">마우스 축</target>
        </trans-unit>
        <trans-unit id="0976ac36f70286d38ade73236d0f61b57bd4d940" translate="yes" xml:space="preserve">
          <source>The mouse buttons which can activate this Pointer Handler.</source>
          <target state="translated">이 포인터 핸들러를 활성화 할 수있는 마우스 버튼.</target>
        </trans-unit>
        <trans-unit id="140403094cb3346f15ed78bbb8faa0f9934ac757" translate="yes" xml:space="preserve">
          <source>The mouse caused the event to be sent. Normally this means the right mouse button was clicked, but this is platform dependent.</source>
          <target state="translated">마우스로 인해 이벤트가 전송되었습니다. 일반적으로 마우스 오른쪽 버튼을 클릭했지만 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6cf56341d71cd346e5683a4bb68ad6c441d739c6" translate="yes" xml:space="preserve">
          <source>The mouse caused the event to be sent. On most platforms, this means the right mouse button was clicked.</source>
          <target state="translated">마우스로 인해 이벤트가 전송되었습니다. 대부분의 플랫폼에서 마우스 오른쪽 버튼을 클릭했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="479e3b71636578ab0546fcd0b09252d3f13bc2bb" translate="yes" xml:space="preserve">
          <source>The mouse cursor enters a hover item in a graphics scene (&lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt;).</source>
          <target state="translated">마우스 커서는 그래픽 장면 ( &lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt; ) 에서 호버 항목을 입력합니다 .</target>
        </trans-unit>
        <trans-unit id="7f69f1581a82dfdf00c9c85699c28e98d438eed7" translate="yes" xml:space="preserve">
          <source>The mouse cursor enters a hover widget (&lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt;).</source>
          <target state="translated">마우스 커서가 호버 위젯 ( &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; )으로 들어갑니다 .</target>
        </trans-unit>
        <trans-unit id="58182c627a7b38977f43547a48e621a8830cfd0f" translate="yes" xml:space="preserve">
          <source>The mouse cursor is used to change focus, it is displayed only on non touchscreen devices. The keypad is used to implement a virtual cursor, unless the device has an analog mouse type of input device (e.g. touchpad). This is the recommended setting for an application such as a web browser that needs pointer control on both touch and non-touch devices.</source>
          <target state="translated">마우스 커서는 초점을 변경하는 데 사용되며 터치 스크린이 아닌 장치에만 표시됩니다. 장치에 아날로그 마우스 유형의 입력 장치 (예 : 터치 패드)가없는 경우 키패드는 가상 커서를 구현하는 데 사용됩니다. 터치 및 비 터치 장치 모두에서 포인터를 제어해야하는 웹 브라우저와 같은 응용 프로그램에 권장되는 설정입니다.</target>
        </trans-unit>
        <trans-unit id="e44018d62fb4442702780f0c28cec38aff1be1ba" translate="yes" xml:space="preserve">
          <source>The mouse cursor is used to change focus, it is displayed regardless of device type. The keypad is used to implement a virtual cursor, unless the device has an analog mouse type of input device (e.g. touchpad)</source>
          <target state="translated">마우스 커서는 초점을 변경하는 데 사용되며 장치 유형에 관계없이 표시됩니다. 장치에 아날로그 마우스 유형의 입력 장치 (예 : 터치 패드)가없는 경우 키패드는 가상 커서를 구현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="813ebe6da355938f8cdbea6ff4078574af586789" translate="yes" xml:space="preserve">
          <source>The mouse cursor leaves a hover item in a graphics scene (&lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt;).</source>
          <target state="translated">마우스 커서는 그래픽 장면 ( &lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt; ) 에 호버 항목을 남깁니다 .</target>
        </trans-unit>
        <trans-unit id="9921a17d9b26e3aceb5ff0d5a4b3a81ca72bd2b4" translate="yes" xml:space="preserve">
          <source>The mouse cursor leaves a hover widget (&lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt;).</source>
          <target state="translated">마우스 커서는 호버 위젯 ( &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; )을 떠 납니다 .</target>
        </trans-unit>
        <trans-unit id="427ea11ac35e82b153aa7a41551f1d157631dea3" translate="yes" xml:space="preserve">
          <source>The mouse cursor moves inside a hover item in a graphics scene (&lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt;).</source>
          <target state="translated">마우스 커서는 그래픽 장면 ( &lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt; ) 에서 호버 항목 내부로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="dcaf274694a4dbde2f0cbf63cbdd7cd344504347" translate="yes" xml:space="preserve">
          <source>The mouse cursor moves inside a hover widget (&lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt;).</source>
          <target state="translated">마우스 커서가 호버 위젯 ( &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; ) 내에서 이동 합니다.</target>
        </trans-unit>
        <trans-unit id="65971bcca08552a0b82589b9e45b4d11b27a629d" translate="yes" xml:space="preserve">
          <source>The mouse cursor shows up whenever &lt;code&gt;QT_QPA_EGLFS_HIDECURSOR&lt;/code&gt; (for eglfs) or &lt;code&gt;QT_QPA_FB_HIDECURSOR&lt;/code&gt; (for linuxfb) is not set and Qt's libudev-based device discovery reports that at least one mouse is available. When &lt;code&gt;libudev&lt;/code&gt; support is not present, the mouse cursor always show up unless explicitly disabled via the environment variable.</source>
          <target state="translated">마우스 커서는 &lt;code&gt;QT_QPA_EGLFS_HIDECURSOR&lt;/code&gt; (eglfs) 또는 &lt;code&gt;QT_QPA_FB_HIDECURSOR&lt;/code&gt; (linuxfb)가 설정되어 있지 않고 Qt의 libudev 기반 장치 발견에서 최소한 하나의 마우스를 사용할 수 있다고보고합니다. 때 &lt;code&gt;libudev&lt;/code&gt; 의 지원이 존재하지 않는 명시 적으로 환경 변수를 통해 해제하지 않는 한, 마우스 커서가 항상 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a5f192e6b6baa262c4bb7c306a11d6042cacd095" translate="yes" xml:space="preserve">
          <source>The mouse cursor will assume this shape when it is over this item, unless an override cursor is set. See the &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;list of predefined cursor objects&lt;/a&gt; for a range of useful shapes.</source>
          <target state="translated">재정의 커서가 설정되어 있지 않으면 마우스 커서는이 항목 위에있을 때이 모양을 가정합니다. 유용한 모양의 범위는 &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;사전 정의 된 커서 객체 목록을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a7df2929dc948955f28195935209b2efcf68216" translate="yes" xml:space="preserve">
          <source>The mouse cursor will assume this shape when it's over this widget. See the &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;list of predefined cursor objects&lt;/a&gt; for a range of useful shapes.</source>
          <target state="translated">마우스 커서는이 위젯 위에있을 때이 모양을 가정합니다. 유용한 모양의 범위는 &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;사전 정의 된 커서 객체 목록을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="596ed169391f55d7813ef8d821177c51489a917c" translate="yes" xml:space="preserve">
          <source>The mouse cursor will show up whenever &lt;code&gt;QT_QPA_EGLFS_HIDECURSOR&lt;/code&gt; (for eglfs) or &lt;code&gt;QT_QPA_FB_HIDECURSOR&lt;/code&gt; (for vxworksfb) is not set, the mouse cursor will always show up unless explicitly disabled via the environment variable.</source>
          <target state="translated">마우스 커서는 &lt;code&gt;QT_QPA_EGLFS_HIDECURSOR&lt;/code&gt; (eglfs) 또는 &lt;code&gt;QT_QPA_FB_HIDECURSOR&lt;/code&gt; (vxworksfb)가 설정되지 않은 경우 환경 변수를 통해 명시 적으로 비활성화되지 않은 경우 항상 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0ae182011bb0516b2ef9a9ef751907cb0e92b16b" translate="yes" xml:space="preserve">
          <source>The mouse event flags provide additional information about a mouse event.</source>
          <target state="translated">마우스 이벤트 플래그는 마우스 이벤트에 대한 추가 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3c8f88e42dc86c0ea4ee0447bec8f164b4f25545" translate="yes" xml:space="preserve">
          <source>The mouse event source can be used to distinguish between genuine and artificial mouse events. The latter are events that are synthesized from touch events by the operating system or Qt itself.</source>
          <target state="translated">마우스 이벤트 소스를 사용하여 정품 마우스 이벤트와 인공 마우스 이벤트를 구별 할 수 있습니다. 후자는 운영 체제 또는 Qt 자체에 의해 터치 이벤트로부터 합성 된 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="1c253f4e022979d6f8284e09fa5d0f9f525d0fe0" translate="yes" xml:space="preserve">
          <source>The mouse event source can be used to distinguish between genuine and artificial mouse events. When using other pointing devices such as touchscreens and graphics tablets, if the application does not make use of the actual touch or tablet events, mouse events may be synthesized by the operating system or by Qt itself.</source>
          <target state="translated">마우스 이벤트 소스를 사용하여 정품 마우스 이벤트와 인공 마우스 이벤트를 구별 할 수 있습니다. 터치 스크린 및 그래픽 태블릿과 같은 다른 포인팅 장치를 사용할 때 응용 프로그램에서 실제 터치 또는 태블릿 이벤트를 사용하지 않는 경우 마우스 이벤트는 운영 체제 또는 Qt 자체에 의해 합성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7494386dc21af75815eee436e0f798a06959b6b0" translate="yes" xml:space="preserve">
          <source>The mouse is hovering over the item.</source>
          <target state="translated">마우스를 항목 위로 가져갑니다.</target>
        </trans-unit>
        <trans-unit id="28a2bd0e77f249a2271f79c2956cd468d3cba2b7" translate="yes" xml:space="preserve">
          <source>The mouse is over the action and the action is not a separator.</source>
          <target state="translated">마우스가 동작 위에 있고 동작이 구분자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e68032e20d74f3e8a68fc3b3e70da4c86c5501e0" translate="yes" xml:space="preserve">
          <source>The mouse is pressed down on the menu item.</source>
          <target state="translated">메뉴 항목에서 마우스를 눌렀습니다.</target>
        </trans-unit>
        <trans-unit id="ded3b87d2f4e4d7a9149dbd29e84d52a298fa171" translate="yes" xml:space="preserve">
          <source>The mouse pointer has moved.</source>
          <target state="translated">마우스 포인터가 움직였습니다.</target>
        </trans-unit>
        <trans-unit id="e0292a88f29c53989407c1d3afb3f0d654bf491f" translate="yes" xml:space="preserve">
          <source>The mouse press event decides which item should become the mouse grabber (see &lt;a href=&quot;qgraphicsscene#mouseGrabberItem&quot;&gt;QGraphicsScene::mouseGrabberItem&lt;/a&gt;()). If you do not reimplement this function, the press event will propagate to any topmost item beneath this item, and no other mouse events will be delivered to this item.</source>
          <target state="translated">마우스 프레스 이벤트는 마우스 그래버가 될 항목을 결정합니다 ( &lt;a href=&quot;qgraphicsscene#mouseGrabberItem&quot;&gt;QGraphicsScene :: mouseGrabberItem&lt;/a&gt; () 참조). 이 기능을 다시 구현하지 않으면 프레스 이벤트가이 항목 아래의 최상위 항목으로 전파되고 다른 마우스 이벤트는이 항목으로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6649d33deeab3440914c09d1a01b95b261ecbda8" translate="yes" xml:space="preserve">
          <source>The mouse tracking state has changed.</source>
          <target state="translated">마우스 추적 상태가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="387018774791ec6eb410da8b801bcb25e784b14e" translate="yes" xml:space="preserve">
          <source>The move velocity and duration properties are used to control movement due to index changes; for example, when &lt;a href=&quot;qml-qtquick-listview#incrementCurrentIndex-method&quot;&gt;incrementCurrentIndex()&lt;/a&gt; is called. When the user flicks a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;, the velocity from the flick is used to control the movement instead.</source>
          <target state="translated">이동 속도 및 지속 시간 속성은 인덱스 변경으로 인한 이동을 제어하는 ​​데 사용됩니다. 예를 들어 &lt;a href=&quot;qml-qtquick-listview#incrementCurrentIndex-method&quot;&gt;incrementCurrentIndex ()&lt;/a&gt; 가 호출 될 때 사용자가 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView를&lt;/a&gt; 튕기는 경우 긋기 속도가 대신 이동을 제어하는 ​​데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c519b2abd415be540972191a4e926fdc747e0400" translate="yes" xml:space="preserve">
          <source>The moved-from pen can only be assigned to, copied, or destroyed. Any other operation (prior to assignment) leads to undefined behavior.</source>
          <target state="translated">이동 한 펜은 할당, 복사 또는 파기 만 할 수 있습니다. 다른 작업 (할당 이전)은 정의되지 않은 동작으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="1958483ebe6252d065dcb4ffe52d80d5428df536" translate="yes" xml:space="preserve">
          <source>The movie is not running. This is &lt;a href=&quot;qmovie&quot;&gt;QMovie&lt;/a&gt;'s initial state, and the state it enters after &lt;a href=&quot;qmovie#stop&quot;&gt;stop&lt;/a&gt;() has been called or the movie is finished.</source>
          <target state="translated">영화가 작동하지 않습니다. 이것이 &lt;a href=&quot;qmovie&quot;&gt;QMovie&lt;/a&gt; 의 초기 상태이며 &lt;a href=&quot;qmovie#stop&quot;&gt;stop&lt;/a&gt; ()이 호출되거나 영화가 완료된 후에 들어가는 상태 입니다.</target>
        </trans-unit>
        <trans-unit id="a3d7ad4a1537000ce73b186c91921a8b85237403" translate="yes" xml:space="preserve">
          <source>The movie is paused, and &lt;a href=&quot;qmovie&quot;&gt;QMovie&lt;/a&gt; stops emitting &lt;a href=&quot;qmovie#updated&quot;&gt;updated&lt;/a&gt;() or &lt;a href=&quot;qmovie#resized&quot;&gt;resized&lt;/a&gt;(). This state is entered after calling pause() or &lt;a href=&quot;qmovie#setPaused&quot;&gt;setPaused&lt;/a&gt;(true). The current frame number it kept, and the movie will continue with the next frame when unpause() or &lt;a href=&quot;qmovie#setPaused&quot;&gt;setPaused&lt;/a&gt;(false) is called.</source>
          <target state="translated">동영상이 일시 정지되고 &lt;a href=&quot;qmovie&quot;&gt;QMovie&lt;/a&gt; 가 &lt;a href=&quot;qmovie#updated&quot;&gt;업데이트&lt;/a&gt; () 또는 &lt;a href=&quot;qmovie#resized&quot;&gt;크기 조정&lt;/a&gt; ()을 중지합니다 . 이 상태는 pause () 또는 &lt;a href=&quot;qmovie#setPaused&quot;&gt;setPaused&lt;/a&gt; (true)를 호출 한 후에 시작됩니다 . 현재 유지 한 프레임 번호이며, &lt;a href=&quot;qmovie#setPaused&quot;&gt;unpause&lt;/a&gt; ( ) 또는 setPaused (false)가 호출 되면 동영상은 다음 프레임으로 계속 진행됩니다 .</target>
        </trans-unit>
        <trans-unit id="096604b24a780e20864ac1dda490de5f7755909a" translate="yes" xml:space="preserve">
          <source>The movie is running.</source>
          <target state="translated">영화가 실행 중입니다.</target>
        </trans-unit>
        <trans-unit id="25d28c1809e05399df17b835331e9a7ba22b1642" translate="yes" xml:space="preserve">
          <source>The mutex is necessary because the results of two threads attempting to change the value of the same variable simultaneously are unpredictable.</source>
          <target state="translated">동일한 변수의 값을 동시에 변경하려는 두 스레드의 결과를 예측할 수 없기 때문에 뮤텍스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fd45e4a115221b68e9bd65770c7d2da61a0539b5" translate="yes" xml:space="preserve">
          <source>The name can be either short or long. If the name is one character in length, it is considered a short name. Option names must not be empty, must not start with a dash or a slash character, must not contain a &lt;code&gt;=&lt;/code&gt; and cannot be repeated.</source>
          <target state="translated">이름은 짧거나 길 수 있습니다. 이름이 한 문자 길이 인 경우 짧은 이름으로 간주됩니다. 옵션 이름은 비워 둘 수 없으며 대시 또는 슬래시 문자로 시작해서는 안되며 &lt;code&gt;=&lt;/code&gt; 를 포함해서는 안되며 반복 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="37f0e661c11ae4c3f573be4801e842e3703f05c3" translate="yes" xml:space="preserve">
          <source>The name can potentially be localized. The language is dependent on the entity that sets it, typically this is the &lt;a href=&quot;location-places-qml#plugin&quot;&gt;Plugin&lt;/a&gt;. The &lt;a href=&quot;qml-qtlocation-plugin#locales-prop&quot;&gt;Plugin::locales&lt;/a&gt; property defines what language is used.</source>
          <target state="translated">이름은 현지화 될 수 있습니다. 언어는 언어를 설정하는 엔티티에 따라 다르며 일반적으로 &lt;a href=&quot;location-places-qml#plugin&quot;&gt;Plugin&lt;/a&gt; 입니다. &lt;a href=&quot;qml-qtlocation-plugin#locales-prop&quot;&gt;플러그인 :: 로케일을&lt;/a&gt; 사용하는 어떤 언어 속성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="721521ac23b10ac561715a35ef28dfa8274f3d3f" translate="yes" xml:space="preserve">
          <source>The name can potentially be localized. The language is dependent on the entity that sets it, typically this is the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt;. The &lt;a href=&quot;qplacemanager#locales&quot;&gt;QPlaceManager::locales&lt;/a&gt;() field defines what language is used.</source>
          <target state="translated">이름은 현지화 될 수 있습니다. 언어는 언어를 설정하는 엔티티에 따라 다르며 일반적으로 &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; 입니다. &lt;a href=&quot;qplacemanager#locales&quot;&gt;QPlaceManager :: 로케일에&lt;/a&gt; 사용되는 어떤 언어 () 필드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="493c960272a1a862d5a54e161776877f7e832174" translate="yes" xml:space="preserve">
          <source>The name defaults to &lt;code&gt;Default&lt;/code&gt;, but qmake generates some of the images, so it is easier to use another name (for example LaunchImage as we did) to avoid clashes.</source>
          <target state="translated">이름의 기본값은 &lt;code&gt;Default&lt;/code&gt; 이지만 qmake는 일부 이미지를 생성하므로 충돌을 피하기 위해 다른 이름 (예 : LaunchImage)을 사용하는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="69941ca660818de7c2abb065f00977d1a8975f30" translate="yes" xml:space="preserve">
          <source>The name filter, file attribute filter, and sorting specification can be overridden using the</source>
          <target state="translated">이름 필터, 파일 속성 필터 및 정렬 사양은 다음을 사용하여 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="162278acabfc945b2763916765ec2e6f987b0b59" translate="yes" xml:space="preserve">
          <source>The name for the role. This name is used to access the model data for this role.</source>
          <target state="translated">역할의 이름입니다. 이 이름은이 역할의 모델 데이터에 액세스하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4c3d90a665e18979efd5f52473d8063e58bb83c1" translate="yes" xml:space="preserve">
          <source>The name is based on the characteristic's &lt;a href=&quot;qlowenergycharacteristic#uuid&quot;&gt;uuid&lt;/a&gt;() which must have been standardized. The complete list of characteristic types can be found under &lt;a href=&quot;https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicsHome.aspx&quot;&gt;Bluetooth.org Characteristics&lt;/a&gt;.</source>
          <target state="translated">이름은 표준화해야하는 특성의 &lt;a href=&quot;qlowenergycharacteristic#uuid&quot;&gt;uuid&lt;/a&gt; ()를 기반으로합니다 . 특성 유형의 전체 목록은 &lt;a href=&quot;https://developer.bluetooth.org/gatt/characteristics/Pages/CharacteristicsHome.aspx&quot;&gt;Bluetooth.org 특성&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae869c8c5af4faaa298203a3742cd4a205e1212c" translate="yes" xml:space="preserve">
          <source>The name is based on the descriptor's &lt;a href=&quot;qlowenergydescriptor#type&quot;&gt;type&lt;/a&gt;(). The complete list of descriptor types can be found under &lt;a href=&quot;https://developer.bluetooth.org/gatt/descriptors/Pages/DescriptorsHomePage.aspx&quot;&gt;Bluetooth.org Descriptors&lt;/a&gt;.</source>
          <target state="translated">이름은 설명자 &lt;a href=&quot;qlowenergydescriptor#type&quot;&gt;유형&lt;/a&gt; ()을 기반으로합니다 . 디스크립터 유형의 전체 목록은 &lt;a href=&quot;https://developer.bluetooth.org/gatt/descriptors/Pages/DescriptorsHomePage.aspx&quot;&gt;Bluetooth.org 디스크립터&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="792659accef8616599fa24407b72747526c2fa58" translate="yes" xml:space="preserve">
          <source>The name is displayed in the legend for the series and it supports HTML formatting.</source>
          <target state="translated">시리즈의 범례에 이름이 표시되며 HTML 형식을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="30c9a629f94402d8ef484acc44ce433cc337194d" translate="yes" xml:space="preserve">
          <source>The name may either be the name of the underlying access point or the name for service network that this configuration represents.</source>
          <target state="translated">이름은 기본 액세스 포인트의 이름이거나이 구성이 나타내는 서비스 네트워크의 이름 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5ea99c02aa46a63f6c21f07f4ed425ff6b91e02" translate="yes" xml:space="preserve">
          <source>The name of a directory is found using the &lt;a href=&quot;qdir#dirName&quot;&gt;dirName&lt;/a&gt;() function. This typically returns the last element in the absolute path that specifies the location of the directory. However, it can also return &quot;.&quot; if the &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; represents the current directory.</source>
          <target state="translated">디렉토리의 이름은 &lt;a href=&quot;qdir#dirName&quot;&gt;dirName&lt;/a&gt; () 함수를 사용하여 찾을 수 있습니다. 일반적으로 디렉토리의 위치를 ​​지정하는 절대 경로의 마지막 요소를 반환합니다. 그러나 &quot;.&quot;을 반환 할 수도 있습니다. &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; 이 현재 디렉토리를 나타내는 경우</target>
        </trans-unit>
        <trans-unit id="f598e9c2763e0d9ea73ad0ff5811b5393c82c9d3" translate="yes" xml:space="preserve">
          <source>The name of a directory. Both files and directories are displayed. However, the native Windows file dialog does not support displaying files in the directory chooser.</source>
          <target state="translated">디렉토리의 이름입니다. 파일과 디렉토리가 모두 표시됩니다. 그러나 기본 Windows 파일 대화 상자는 디렉토리 선택기에 파일 표시를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="470da9c91bae6694bd8760cd5001dddd4d4aa7be" translate="yes" xml:space="preserve">
          <source>The name of a file, whether it exists or not.</source>
          <target state="translated">파일의 존재 여부에 관계없이 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8c9c0b1af9db29e07dfb51532bbb784e1d613785" translate="yes" xml:space="preserve">
          <source>The name of a platform-compiler combination. In this case, qmake will search in the directory specified by the &lt;code&gt;mkspecs&lt;/code&gt; subdirectory of the data path specified when Qt was compiled (see &lt;a href=&quot;qlibraryinfo#LibraryLocation-enum&quot;&gt;QLibraryInfo::DataPath&lt;/a&gt;).</source>
          <target state="translated">플랫폼 컴파일러 조합의 이름입니다. 이 경우 qmake는 Qt가 컴파일 될 때 지정된 데이터 경로 의 &lt;code&gt;mkspecs&lt;/code&gt; 서브 디렉토리로 지정된 디렉토리에서 검색 합니다 ( &lt;a href=&quot;qlibraryinfo#LibraryLocation-enum&quot;&gt;QLibraryInfo :: DataPath&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="057c5952760f53903ecca8763e8070756d7a1f2a" translate="yes" xml:space="preserve">
          <source>The name of a single existing file.</source>
          <target state="translated">기존의 단일 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3b3b1fd5cbc50886ee9f5b177e0fbbac0dac1607" translate="yes" xml:space="preserve">
          <source>The name of an XML node has three components: The</source>
          <target state="translated">XML 노드의 이름에는 세 가지 구성 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f915b65243f55a415532880ee812220d2133fb57" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;qml-qtquick-sprite&quot;&gt;Sprite&lt;/a&gt; that is currently animating.</source>
          <target state="translated">현재 애니메이션중인 &lt;a href=&quot;qml-qtquick-sprite&quot;&gt;Sprite&lt;/a&gt; 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="7d20469eadfd0ae52232e634b83dd3deb5c7f819" translate="yes" xml:space="preserve">
          <source>The name of the &lt;a href=&quot;qml-qtquick-sprite&quot;&gt;Sprite&lt;/a&gt; that the animation should move to.</source>
          <target state="translated">애니메이션이 이동해야하는 &lt;a href=&quot;qml-qtquick-sprite&quot;&gt;Sprite&lt;/a&gt; 의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="e1456d1eb5ddae9f630d15fe63e210f076034f7f" translate="yes" xml:space="preserve">
          <source>The name of the GPS area.</source>
          <target state="translated">GPS 영역의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b2df46bf3b772eb8b849d2aaa7a1ba87009931bc" translate="yes" xml:space="preserve">
          <source>The name of the QDoc program is &lt;code&gt;qdoc&lt;/code&gt;. To run qdoc from the command line, give it the name of a configuration file:</source>
          <target state="translated">QDoc 프로그램의 이름은 &lt;code&gt;qdoc&lt;/code&gt; 입니다. 명령 행에서 qdoc를 실행하려면 구성 파일 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="9c7f460a9a99667f9248df242628813633e25728" translate="yes" xml:space="preserve">
          <source>The name of the Sprite which the affected particles should move to.</source>
          <target state="translated">영향을받는 파티클이 이동해야하는 Sprite의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="40d2e11235855fab2d67d717fdf33aaa4aa7634f" translate="yes" xml:space="preserve">
          <source>The name of the attribute</source>
          <target state="translated">속성의 이름</target>
        </trans-unit>
        <trans-unit id="0eaa90811c61c0f2648a3f87ef60fa4962992e36" translate="yes" xml:space="preserve">
          <source>The name of the class that provides the widget.</source>
          <target state="translated">위젯을 제공하는 클래스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d64bd76544b38e5759393eca105fc3f110d37a93" translate="yes" xml:space="preserve">
          <source>The name of the custom build target.</source>
          <target state="translated">사용자 정의 빌드 대상의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="774d31ec0c73f8fc89a6444111ca0a13ccbf6694" translate="yes" xml:space="preserve">
          <source>The name of the device offering the service.</source>
          <target state="translated">서비스를 제공하는 장치의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="bca35cad89c68fcbec020e7d730f807427e41034" translate="yes" xml:space="preserve">
          <source>The name of the device.</source>
          <target state="translated">장치의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b9696a9c5ef83a12e04b28d7411ded8437d4ec43" translate="yes" xml:space="preserve">
          <source>The name of the document type</source>
          <target state="translated">문서 유형의 이름</target>
        </trans-unit>
        <trans-unit id="f75476630adc7537ab0942d349040825c278cc3c" translate="yes" xml:space="preserve">
          <source>The name of the entity</source>
          <target state="translated">실체의 이름</target>
        </trans-unit>
        <trans-unit id="871b456901e6c0fc86df9d051e5822b4a47d265c" translate="yes" xml:space="preserve">
          <source>The name of the file used as a brush for the box-and-whiskers item.</source>
          <target state="translated">상자 및 수염 항목의 브러시로 사용되는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="24a73e4402ef805156d1d3cf96e422049c2f1a57" translate="yes" xml:space="preserve">
          <source>The name of the file used as a brush for the candlestick item.</source>
          <target state="translated">촛대 항목의 브러시로 사용되는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d8da36b45b78b80bb84c7d15798846aac21374e9" translate="yes" xml:space="preserve">
          <source>The name of the file used as a brush for the series.</source>
          <target state="translated">시리즈의 브러시로 사용되는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="bbac53a6680ec8419bc5c1d32a5670fd66c07377" translate="yes" xml:space="preserve">
          <source>The name of the file used as a brush for the set.</source>
          <target state="translated">세트의 브러시로 사용되는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="16df2457f406583a7d94da875a7df8507edaa862" translate="yes" xml:space="preserve">
          <source>The name of the file used as a brush for the slice.</source>
          <target state="translated">슬라이스의 브러시로 사용되는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="15abed02c964965cedb9796d716f7c78f6faf659" translate="yes" xml:space="preserve">
          <source>The name of the file used as a brush image for the series.</source>
          <target state="translated">시리즈의 브러시 이미지로 사용되는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="957ecb2da7bf7f947df59c83007e25fafede1cdc" translate="yes" xml:space="preserve">
          <source>The name of the group which the affected particles should move to.</source>
          <target state="translated">영향을받는 입자가 이동해야하는 그룹의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="eefd9f0021b48b7b51df8dc461928c9d84b99fd8" translate="yes" xml:space="preserve">
          <source>The name of the image. A handler that supports this option is expected to read the name from the image metadata and return this as a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, or when writing an image it is expected to store the name in the image metadata.</source>
          <target state="translated">이미지의 이름입니다. 이 옵션을 지원하는 핸들러는 이미지 메타 데이터에서 이름을 읽고이를 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 으로 리턴 하거나 이미지를 작성할 때 이미지 메타 데이터에 이름을 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="2002401ee533af92a6a3f7073075751dee8cd052" translate="yes" xml:space="preserve">
          <source>The name of the method used for location finding.</source>
          <target state="translated">위치 찾기에 사용 된 방법의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="53013d505236b97e5bf8ff25f307be740cbdf7db" translate="yes" xml:space="preserve">
          <source>The name of the notation</source>
          <target state="translated">표기법의 이름</target>
        </trans-unit>
        <trans-unit id="dc21017129d741fc7aa59d9f9dd7257f884d1f21" translate="yes" xml:space="preserve">
          <source>The name of the object. This can be used both as an identifier or a short description by accessible clients.</source>
          <target state="translated">객체의 이름입니다. 액세스 가능한 클라이언트는 식별자 또는 간단한 설명으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="253cd37ca9ec1e5a7913171ea3e0ad1708944fa9" translate="yes" xml:space="preserve">
          <source>The name of the option is set to</source>
          <target state="translated">옵션 이름이</target>
        </trans-unit>
        <trans-unit id="e05dc99e355e54f9724584c7f8ac352f6708368a" translate="yes" xml:space="preserve">
          <source>The name of the output header file. If none is specified, .cpp is added to the base name.</source>
          <target state="translated">출력 헤더 파일의 이름입니다. 아무것도 지정하지 않으면 .cpp가 기본 이름에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4856abd8556594c945211145b00af0013766b393" translate="yes" xml:space="preserve">
          <source>The name of the output header file. If none is specified, .h is added to the base name.</source>
          <target state="translated">출력 헤더 파일의 이름입니다. 아무것도 지정하지 않으면 .h가 기본 이름에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3b4d0278cfb52f1601579f9e0ab76c42b4fb0748" translate="yes" xml:space="preserve">
          <source>The name of the package as displayed to the user. Defaults to TARGET.</source>
          <target state="translated">사용자에게 표시되는 패키지 이름입니다. 기본값은 TARGET입니다.</target>
        </trans-unit>
        <trans-unit id="9f4441eea0dd7ac5a440dfbe4c68a5c449197d05" translate="yes" xml:space="preserve">
          <source>The name of the provider that a place is sourced from</source>
          <target state="translated">장소가 제공되는 제공 업체의 이름</target>
        </trans-unit>
        <trans-unit id="38fde4fe1ee2db50f1af5eba426a8ea74c239192" translate="yes" xml:space="preserve">
          <source>The name of the referenced entity</source>
          <target state="translated">참조 된 엔터티의 이름</target>
        </trans-unit>
        <trans-unit id="92a621f009bd38fc1dfa1047f1ed8b346452a146" translate="yes" xml:space="preserve">
          <source>The name of the screen.</source>
          <target state="translated">화면의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="037eef0b527e7175a45c4725b797bbe44c97ee7c" translate="yes" xml:space="preserve">
          <source>The name of the script. Can be useful to retrieve a particular script from &lt;a href=&quot;qml-qtwebengine-webengineview#userScripts-prop&quot;&gt;WebEngineView.userScripts&lt;/a&gt;.</source>
          <target state="translated">스크립트 이름 &lt;a href=&quot;qml-qtwebengine-webengineview#userScripts-prop&quot;&gt;WebEngineView.userScripts&lt;/a&gt; 에서 특정 스크립트를 검색하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c05f7b0b296e6a68807440901ed97741e050b829" translate="yes" xml:space="preserve">
          <source>The name of the serial port can be passed as either a short name or the long system location if necessary.</source>
          <target state="translated">직렬 포트의 이름은 필요한 경우 짧은 이름 또는 긴 시스템 위치로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53d74a69c982cc05432742beb5b3cdc8a1e09366" translate="yes" xml:space="preserve">
          <source>The name of the series. It is displayed in the legend for the series and it supports HTML formatting.</source>
          <target state="translated">시리즈의 이름입니다. 시리즈의 범례에 표시되며 HTML 형식을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="9306af8b2ed4da66efedb5ea1289d09910001efc" translate="yes" xml:space="preserve">
          <source>The name of the state machine as set by the</source>
          <target state="translated">에 의해 설정된 상태 머신의 이름</target>
        </trans-unit>
        <trans-unit id="75bbae2505d04e29e52c11eca71a81e34ae7b5c9" translate="yes" xml:space="preserve">
          <source>The name of the target (.exe). Defaults to TARGET.</source>
          <target state="translated">대상 이름 (.exe) 기본값은 TARGET입니다.</target>
        </trans-unit>
        <trans-unit id="ffd3fd6b623e3a355b5c556f52a0c6f4dc871035" translate="yes" xml:space="preserve">
          <source>The name of this server used during the http handshake phase.</source>
          <target state="translated">http 핸드 셰이크 단계에서 사용 된이 서버의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b28191a0c387b22dc248eba21b0b511634942d29" translate="yes" xml:space="preserve">
          <source>The name of this sprite, for use in the to property of other sprites.</source>
          <target state="translated">다른 스프라이트의 to 속성에 사용하기위한이 스프라이트의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3e1166b2185c61ef70ff20aeb8d8f167ff7b72aa" translate="yes" xml:space="preserve">
          <source>The name provided can be any long or short name of any option that was added with &lt;code&gt;addOption()&lt;/code&gt;. All the option names are treated as being equivalent. If the name is not recognized or that option was not present, an empty string is returned.</source>
          <target state="translated">제공된 이름은 &lt;code&gt;addOption()&lt;/code&gt; 으로 추가 된 옵션의 길거나 짧은 이름 일 수 있습니다 . 모든 옵션 이름은 동등한 것으로 취급됩니다. 이름이 인식되지 않거나 해당 옵션이 없으면 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="47de00fb621a2e3e07496846c18bbf9cd9e1dba6" translate="yes" xml:space="preserve">
          <source>The name provided can be any long or short name of any option that was added with &lt;code&gt;addOption()&lt;/code&gt;. All the options names are treated as being equivalent. If the name is not recognized or that option was not present, an empty list is returned.</source>
          <target state="translated">제공된 이름은 &lt;code&gt;addOption()&lt;/code&gt; 으로 추가 된 옵션의 길거나 짧은 이름 일 수 있습니다 . 모든 옵션 이름은 동등한 것으로 취급됩니다. 이름이 인식되지 않거나 해당 옵션이 없으면 빈 목록이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1c482b8badd934f5446ddcab8b100b312d8301b3" translate="yes" xml:space="preserve">
          <source>The name provided can be any long or short name of any option that was added with &lt;code&gt;addOption()&lt;/code&gt;. All the options names are treated as being equivalent. If the name is not recognized or that option was not present, false is returned.</source>
          <target state="translated">제공된 이름은 &lt;code&gt;addOption()&lt;/code&gt; 으로 추가 된 옵션의 길거나 짧은 이름 일 수 있습니다 . 모든 옵션 이름은 동등한 것으로 취급됩니다. 이름이 인식되지 않거나 해당 옵션이 없으면 false가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="97794e5e4f3df96f5e845f85d9345947fd9337a1" translate="yes" xml:space="preserve">
          <source>The name returned</source>
          <target state="translated">반환 된 이름</target>
        </trans-unit>
        <trans-unit id="d2aa9e2ab4024c1075faad98603929a4f8c8ca0e" translate="yes" xml:space="preserve">
          <source>The name should have a specific format; see the &lt;a href=&quot;qserialport#setPort&quot;&gt;setPort&lt;/a&gt;() method.</source>
          <target state="translated">이름은 특정 형식이어야합니다. &lt;a href=&quot;qserialport#setPort&quot;&gt;setPort&lt;/a&gt; () 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="92bda07ed1e30f0a636159beae4aa824f57960d0" translate="yes" xml:space="preserve">
          <source>The name tests are the &lt;a href=&quot;#node-tests&quot;&gt;Node Tests&lt;/a&gt; that have the &lt;code&gt;name&lt;/code&gt; parameter. A name test must match the node</source>
          <target state="translated">이름 테스트는 &lt;code&gt;name&lt;/code&gt; 매개 변수 가있는 &lt;a href=&quot;#node-tests&quot;&gt;노드 테스트&lt;/a&gt; 입니다 . 이름 테스트는 노드와 일치해야합니다</target>
        </trans-unit>
        <trans-unit id="98c081be5b5f55744b1af6faf82f9112e31fcd7c" translate="yes" xml:space="preserve">
          <source>The names can be either short or long. Any name in the list that is one character in length is a short name. Option names must not be empty, must not start with a dash or a slash character, must not contain a &lt;code&gt;=&lt;/code&gt; and cannot be repeated.</source>
          <target state="translated">이름은 짧거나 길 수 있습니다. 한 문자 길이 인 목록의 모든 이름은 짧은 이름입니다. 옵션 이름은 비워 둘 수 없으며 대시 또는 슬래시 문자로 시작해서는 안되며 &lt;code&gt;=&lt;/code&gt; 를 포함해서는 안되며 반복 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3f875220850d025c9b7939e92566533a7fb691b1" translate="yes" xml:space="preserve">
          <source>The names in this list do not include the preceding dash characters. Names may appear more than once in this list if they were encountered more than once by the parser.</source>
          <target state="translated">이 목록의 이름에는 앞의 대시 문자가 포함되지 않습니다. 구문 분석기가 두 번 이상 발견 한 경우이 목록에 이름이 두 번 이상 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dacf58225321ac9450f50648984b2e3b30c8aa37" translate="yes" xml:space="preserve">
          <source>The names of the option are set to</source>
          <target state="translated">옵션의 이름은</target>
        </trans-unit>
        <trans-unit id="5a0f0c8db1195536a121e6f7c2bb9b2108a3407d" translate="yes" xml:space="preserve">
          <source>The names of zero or more existing files.</source>
          <target state="translated">0 개 이상의 기존 파일 이름</target>
        </trans-unit>
        <trans-unit id="35813830616d61348f282c52b4c0f43692cc8d39" translate="yes" xml:space="preserve">
          <source>The names used for roles must begin with a lower-case letter and should be common to all elements in a given model. Values must be simple constants; either strings (quoted and optionally within a call to &lt;a href=&quot;#QT_TR_NOOP&quot;&gt;QT_TR_NOOP&lt;/a&gt;), boolean values (true, false), numbers, or enumeration values (such as AlignText.AlignHCenter).</source>
          <target state="translated">역할에 사용되는 이름은 소문자로 시작해야하며 주어진 모델의 모든 요소에 공통적이어야합니다. 값은 간단한 상수 여야합니다. 문자열 (따옴표가 있고 선택적으로 &lt;a href=&quot;#QT_TR_NOOP&quot;&gt;QT_TR_NOOP&lt;/a&gt; 호출 내 ), 부울 값 (true, false), 숫자 또는 열거 값 (예 : AlignText.AlignHCenter)</target>
        </trans-unit>
        <trans-unit id="0a26543a3e17cbc2f43ad389d2a0c455fbbd9412" translate="yes" xml:space="preserve">
          <source>The namespace declarations to be used in the XPath queries.</source>
          <target state="translated">XPath 쿼리에 사용될 네임 스페이스 선언</target>
        </trans-unit>
        <trans-unit id="4b098f5b94375d4757df529d3469244efc54ffa9" translate="yes" xml:space="preserve">
          <source>The namespace-processing flag of the stream reader</source>
          <target state="translated">스트림 리더의 네임 스페이스 처리 플래그</target>
        </trans-unit>
        <trans-unit id="f7c68f66e2ec9e38ff518a8e0152d65a3d42f59c" translate="yes" xml:space="preserve">
          <source>The namespaced import is useful if there is a requirement to use two QML types that have the same name but are located in different modules. In this case the two modules can be imported into different namespaces to ensure the code is referring to the correct type:</source>
          <target state="translated">네임 스페이스가있는 가져 오기는 이름은 같지만 다른 모듈에있는 두 개의 QML 유형을 사용해야하는 경우에 유용합니다. 이 경우 코드가 올바른 유형을 참조하도록하기 위해 두 개의 모듈을 다른 네임 스페이스로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="307c0ee2da33ecdca298e1dc7fc8bef9d1188f9f" translate="yes" xml:space="preserve">
          <source>The namespaces should be declared as in &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;. For example, if a requested document at http://mysite.com/feed.xml uses the namespace &quot;http://www.w3.org/2005/Atom&quot;, this can be declared as the default namespace:</source>
          <target state="translated">네임 스페이스는 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 와 같이 선언해야합니다 . 예를 들어 http://mysite.com/feed.xml의 요청 된 문서가 &quot;http://www.w3.org/2005/Atom&quot;네임 스페이스를 사용하는 경우 기본 네임 스페이스로 선언 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e145505b4d8fc1bdaea6df419694222d7877ed0" translate="yes" xml:space="preserve">
          <source>The native handle will be resolved in the &lt;a href=&quot;qoffscreensurface#create&quot;&gt;create&lt;/a&gt;() function. Calling this function after &lt;a href=&quot;qoffscreensurface#create&quot;&gt;create&lt;/a&gt;() will not re-create a native surface.</source>
          <target state="translated">기본 핸들은 &lt;a href=&quot;qoffscreensurface#create&quot;&gt;create&lt;/a&gt; () 함수 에서 해결됩니다 . &lt;a href=&quot;qoffscreensurface#create&quot;&gt;create&lt;/a&gt; () 후에이 함수를 호출하면 기본 표면이 다시 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7007978410088b73c55ac2ab53c4ddc5ce3104d3" translate="yes" xml:space="preserve">
          <source>The native orientation is a property of the hardware, and does not change.</source>
          <target state="translated">기본 방향은 하드웨어의 속성이며 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="852163f5a4b8fbdb460e4c2a3c12edcbf0a402d2" translate="yes" xml:space="preserve">
          <source>The native orientation of the screen is the orientation where the logo sticker of the device appears the right way up, or &lt;a href=&quot;qt#ScreenOrientation-enum&quot;&gt;Qt::PrimaryOrientation&lt;/a&gt; if the platform does not support this functionality.</source>
          <target state="translated">화면의 기본 방향은 장치의 로고 스티커가 올바른 방향으로 나타나는 방향이거나 플랫폼이이 기능을 지원하지 않는 경우 &lt;a href=&quot;qt#ScreenOrientation-enum&quot;&gt;Qt :: PrimaryOrientation&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ca561eefdec66edbf564f67352e8e73e9269228f" translate="yes" xml:space="preserve">
          <source>The native resolution is not always known and can be changed during playback.</source>
          <target state="translated">기본 해상도는 항상 알려진 것은 아니며 재생 중에 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db2d4d7b26e2187e398d2587859f879ccabebbc2" translate="yes" xml:space="preserve">
          <source>The native resolution of video surface. This is the resolution of video frames the surface can render with optimal quality and/or performance.</source>
          <target state="translated">비디오 표면의 기본 해상도. 표면이 최적의 품질 및 / 또는 성능으로 렌더링 할 수있는 비디오 프레임의 해상도입니다.</target>
        </trans-unit>
        <trans-unit id="e8e1f82b196ebece108f546c4fb827a2ba6b40da" translate="yes" xml:space="preserve">
          <source>The natural color system (NCS) blue theme.</source>
          <target state="translated">자연 색상 시스템 (NCS) 파란색 테마.</target>
        </trans-unit>
        <trans-unit id="53db99714ec2481588fb26487ee2dc2400b7a0d7" translate="yes" xml:space="preserve">
          <source>The navigation bar of the calendar.</source>
          <target state="translated">캘린더의 탐색 모음.</target>
        </trans-unit>
        <trans-unit id="d1a021f1fffdf97bb552e717a7106f11a3cff607" translate="yes" xml:space="preserve">
          <source>The navigation commands are for linking the pages of a document in a meaningful sequence. Below is a sequence of QDoc comments that shows a typical use of the navigation commands.</source>
          <target state="translated">탐색 명령은 문서의 페이지를 의미있는 순서로 연결하기위한 것입니다. 다음은 탐색 명령의 일반적인 사용법을 보여주는 일련의 QDoc 주석입니다.</target>
        </trans-unit>
        <trans-unit id="d896563239da0e253bc1a6f54077beeb40485c1b" translate="yes" xml:space="preserve">
          <source>The navigation history of the current view.</source>
          <target state="translated">현재보기의 탐색 기록.</target>
        </trans-unit>
        <trans-unit id="6aa419a1d999273f0b5d4e866bc00737f7ab11fe" translate="yes" xml:space="preserve">
          <source>The navigation information that joins segments.</source>
          <target state="translated">세그먼트를 결합하는 탐색 정보입니다.</target>
        </trans-unit>
        <trans-unit id="d323da35852bc78a1e7db8d678bdcbb8c70d395f" translate="yes" xml:space="preserve">
          <source>The navigation request resulted from a back or forward action.</source>
          <target state="translated">탐색 요청은 뒤로 또는 앞으로 조치로 인해 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="4670e4149a97c633e27bbc3892de517c5811847f" translate="yes" xml:space="preserve">
          <source>The navigation request resulted from a clicked link.</source>
          <target state="translated">탐색 요청이 클릭 된 링크에서 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="4bf31c6ccb7f629f7642d238a9079f1c86c7f75b" translate="yes" xml:space="preserve">
          <source>The navigation request resulted from a form submission.</source>
          <target state="translated">탐색 요청은 양식 제출로 인해 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="70ffdcab200cad9d1ce939572493e249949181e3" translate="yes" xml:space="preserve">
          <source>The navigation request resulted from a reload action.</source>
          <target state="translated">탐색 요청으로 인해 다시로드 조치가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="fa0be68820ede9b17ec6243e4a64a28a660f8445" translate="yes" xml:space="preserve">
          <source>The navigation request resulted from an explicitly loaded URL.</source>
          <target state="translated">탐색 요청은 명시 적으로로드 된 URL에서 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="859d80d63f960e1231e23a6aaba9a9dc1b346957" translate="yes" xml:space="preserve">
          <source>The navigation request was triggered by other means not covered by the above.</source>
          <target state="translated">위의 내용을 다루지 않은 다른 방법으로 탐색 요청이 트리거되었습니다.</target>
        </trans-unit>
        <trans-unit id="8e8036ca806d21c5343f5ff30003793df20be6f3" translate="yes" xml:space="preserve">
          <source>The needle that points to the gauge's current value.</source>
          <target state="translated">게이지의 현재 값을 가리키는 바늘.</target>
        </trans-unit>
        <trans-unit id="a95b09270a060f20a52c11fde9b0c86ac4ebe7ab" translate="yes" xml:space="preserve">
          <source>The netWorker class delegates calls from the .NET code to the native code. Although the transition between those two worlds implies a small performance hit for each function call, and for the type conversion, this should be negligible since we are anyway going to run within the CLR.</source>
          <target state="translated">netWorker 클래스는 .NET 코드에서 네이티브 코드로 호출을 위임합니다. 이 두 세계 사이의 전환은 각 함수 호출 및 유형 변환에 대해 약간의 성능 저하를 의미하지만 CLR 내에서 실행되기 때문에 무시할 만합니다.</target>
        </trans-unit>
        <trans-unit id="c1e23c7e2ae7f968a86a62c33f9ffc66804674da" translate="yes" xml:space="preserve">
          <source>The network accessibility cannot be determined.</source>
          <target state="translated">네트워크 접근성을 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f648778c9164b8523453a01cbd1d5d4a1f4c391" translate="yes" xml:space="preserve">
          <source>The network configuration is used to create and open a network session before any request that requires network access is process. If no network configuration is explicitly set via this function the network configuration returned by &lt;a href=&quot;qnetworkconfigurationmanager#defaultConfiguration&quot;&gt;QNetworkConfigurationManager::defaultConfiguration&lt;/a&gt;() will be used.</source>
          <target state="translated">네트워크 구성은 네트워크 액세스가 필요한 요청이 처리되기 전에 네트워크 세션을 작성하고 여는 데 사용됩니다. 이 기능을 통해 네트워크 구성을 명시 적으로 설정하지 않으면 &lt;a href=&quot;qnetworkconfigurationmanager#defaultConfiguration&quot;&gt;QNetworkConfigurationManager :: defaultConfiguration&lt;/a&gt; ()에서 반환 한 네트워크 구성 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c849b3f5ce1c393c26791ea146c8745524f0acf" translate="yes" xml:space="preserve">
          <source>The network configuration specifies which configuration to use, when bearer management is used. For example on a mobile phone the proxy settings are likely to be different for the cellular network vs WLAN.</source>
          <target state="translated">네트워크 구성은 베어러 관리가 사용될 때 사용할 구성을 지정합니다. 예를 들어 휴대 전화의 경우 셀룰러 네트워크와 WLAN의 프록시 설정이 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b8593ec77b0200567659c3e33b2c8dbbb995ad6" translate="yes" xml:space="preserve">
          <source>The network connection has been terminated.</source>
          <target state="translated">네트워크 연결이 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="2948422beac8ae290c317ef06848704c60999cb0" translate="yes" xml:space="preserve">
          <source>The network icon.</source>
          <target state="translated">네트워크 아이콘.</target>
        </trans-unit>
        <trans-unit id="8d91a5eafbfc719ff05e8aa37a61389cf8cd2f07" translate="yes" xml:space="preserve">
          <source>The network is accessible.</source>
          <target state="translated">네트워크에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25cc8b23da061766d4f2de8852d8f04b382b47eb" translate="yes" xml:space="preserve">
          <source>The network is not currently accessible, either because there is currently no network coverage or network access has been explicitly disabled by a call to &lt;a href=&quot;qnetworkaccessmanager#setNetworkAccessible&quot;&gt;setNetworkAccessible&lt;/a&gt;().</source>
          <target state="translated">현재 네트워크 범위가 없거나 &lt;a href=&quot;qnetworkaccessmanager#setNetworkAccessible&quot;&gt;setNetworkAccessible&lt;/a&gt; () 호출로 네트워크 액세스가 명시 적으로 비활성화되어있어 네트워크에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="042f3b1bddc3d3540c93a58d5e83f702b862563c" translate="yes" xml:space="preserve">
          <source>The network operation has timed out.</source>
          <target state="translated">네트워크 작동 시간이 초과되었습니다.</target>
        </trans-unit>
        <trans-unit id="d9cfee1e1cd3cd549154fd36b6b6b499e4fd875d" translate="yes" xml:space="preserve">
          <source>The network request was invalid (for example, the original or redirected URL is invalid, has an unsupported scheme, or is disallowed by policy).</source>
          <target state="translated">네트워크 요청이 잘못되었습니다 (예 : 원래 또는 리디렉션 된 URL이 잘못되었거나 지원되지 않는 체계가 있거나 정책에 의해 허용되지 않음).</target>
        </trans-unit>
        <trans-unit id="a1e5599472620628f8b4faf88e80efdf07aa9232" translate="yes" xml:space="preserve">
          <source>The network session is being established.</source>
          <target state="translated">네트워크 세션이 설정 중입니다.</target>
        </trans-unit>
        <trans-unit id="81481f4b25d45ba8197218f262db3a4909e5a21a" translate="yes" xml:space="preserve">
          <source>The network session is connected. If the current process wishes to use this session it has to register its interest by calling &lt;a href=&quot;qnetworksession#open&quot;&gt;open&lt;/a&gt;(). A network session is considered to be ready for socket operations if it &lt;a href=&quot;qnetworksession#isOpen&quot;&gt;isOpen&lt;/a&gt;() and connected.</source>
          <target state="translated">네트워크 세션이 연결되었습니다. 현재 프로세스가이 세션을 사용하려면 &lt;a href=&quot;qnetworksession#open&quot;&gt;open&lt;/a&gt; () 을 호출하여 관심을 등록해야 합니다. 소켓이 &lt;a href=&quot;qnetworksession#isOpen&quot;&gt;열려&lt;/a&gt; 있고 연결되어 있으면 네트워크 세션은 소켓 작동 준비가 된 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="7eb1e7478db6bb5ca883d0236ec54c8c8f42992b" translate="yes" xml:space="preserve">
          <source>The network session is in the process of being shut down.</source>
          <target state="translated">네트워크 세션이 종료되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2b9e593cabe241b4541f1a1f42d53c172a41fac" translate="yes" xml:space="preserve">
          <source>The network session is not connected. The associated &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration&lt;/a&gt; has the state &lt;a href=&quot;qnetworkconfiguration#StateFlag-enum&quot;&gt;QNetworkConfiguration::Discovered&lt;/a&gt;.</source>
          <target state="translated">네트워크 세션이 연결되어 있지 않습니다. 연관된 &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration&lt;/a&gt; 의 상태는 &lt;a href=&quot;qnetworkconfiguration#StateFlag-enum&quot;&gt;QNetworkConfiguration :: Discovered&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3b09d27d34d474e859e999abba7e56d70af68062" translate="yes" xml:space="preserve">
          <source>The network session is roaming from one access point to another access point.</source>
          <target state="translated">네트워크 세션이 한 액세스 지점에서 다른 액세스 지점으로 로밍 중입니다.</target>
        </trans-unit>
        <trans-unit id="3bc06e5f0a8359473c164b92a2906b37411b509f" translate="yes" xml:space="preserve">
          <source>The new</source>
          <target state="translated">새로운</target>
        </trans-unit>
        <trans-unit id="f30b45ed7bfe920ab4cb7e0dbb618d3b1fc693a6" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; can be found in the Qt Quick module.</source>
          <target state="translated">새로운 &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; 는 Qt Quick 모듈에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa4d732b8ea6e5635fc8614a3f1067693913a41a" translate="yes" xml:space="preserve">
          <source>The new access point is not suitable for the application. By calling this function the session returns to the previous access point/configuration. This action may invalidate any socket that has been created via the not desired access point.</source>
          <target state="translated">새로운 액세스 포인트가 응용 프로그램에 적합하지 않습니다. 이 기능을 호출하면 세션이 이전 액세스 포인트 / 구성으로 돌아갑니다. 이 조치는 원하지 않는 액세스 포인트를 통해 작성된 소켓을 무효화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40f74ea6322134c13f80f1c6249ec7ab91349e67" translate="yes" xml:space="preserve">
          <source>The new format is</source>
          <target state="translated">새로운 형식은</target>
        </trans-unit>
        <trans-unit id="fb1af2129332af898b4437051de95d5bcc8de7e1" translate="yes" xml:space="preserve">
          <source>The new parent to animate to.</source>
          <target state="translated">애니메이션 할 새 부모입니다.</target>
        </trans-unit>
        <trans-unit id="408e6a2d48e9c5d34ea489fcba4cfb056854d3b9" translate="yes" xml:space="preserve">
          <source>The new shape displays. The following shows how a clipping path can modify how an image displays:</source>
          <target state="translated">새로운 모양이 표시됩니다. 다음은 클리핑 경로가 이미지 표시 방법을 수정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5874121596e3ae5472b35339ec3769607fe4d3c3" translate="yes" xml:space="preserve">
          <source>The new thread is not started -- it must be started by an explicit call to &lt;a href=&quot;qthread#start&quot;&gt;start&lt;/a&gt;(). This allows you to connect to its signals, move QObjects to the thread, choose the new thread's priority and so on. The function</source>
          <target state="translated">새 스레드가 시작되지 않았습니다. 명시적인 &lt;a href=&quot;qthread#start&quot;&gt;start&lt;/a&gt; () 호출로 시작 해야합니다 . 이를 통해 신호에 연결하고 QObject를 스레드로 이동하고 새 스레드의 우선 순위 등을 선택할 수 있습니다. 함수</target>
        </trans-unit>
        <trans-unit id="f8425367069fe5701c0878b711b94f8d850698df" translate="yes" xml:space="preserve">
          <source>The new timeout value does not take effect until the device search is restarted. In addition the timeout does not affect the classic Bluetooth device search. Depending on the platform the classic search may add more time to the total discovery process beyond</source>
          <target state="translated">새 시간 초과 값은 장치 검색이 다시 시작될 때까지 적용되지 않습니다. 또한 시간 초과는 기존 Bluetooth 장치 검색에 영향을 미치지 않습니다. 플랫폼에 따라 클래식 검색은 전체 검색 프로세스에 더 많은 시간을 추가 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="57e04c618c6cf744e2b2c59da11320bda6b9110e" translate="yes" xml:space="preserve">
          <source>The new value is passed in</source>
          <target state="translated">새로운 가치가 전달됩니다</target>
        </trans-unit>
        <trans-unit id="234da685867a0dbb5ec03039c2ec00fcbe87c845" translate="yes" xml:space="preserve">
          <source>The newline character ('\n') is included in the buffer. If a newline is not encountered before maxSize - 1 bytes are read, a newline will not be inserted into the buffer. On windows newline characters are replaced with '\n'.</source>
          <target state="translated">개행 문자 ( '\ n')가 버퍼에 포함됩니다. maxSize-1 바이트를 읽기 전에 줄 바꿈이 발생하지 않으면 줄 바꿈이 버퍼에 삽입되지 않습니다. Windows에서 줄 바꿈 문자는 '\ n'으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="180c5b859beecd30804220ff7ba2a6b69693db8b" translate="yes" xml:space="preserve">
          <source>The newly added</source>
          <target state="translated">새로 추가 된</target>
        </trans-unit>
        <trans-unit id="ea124dd09b8ef16f5917522f38d0d590f6fa4256" translate="yes" xml:space="preserve">
          <source>The newly pushed group will inherit the same filtering settings of the group that was on the top of the stack; that is, the filtering will not be changed by pushing a new group.</source>
          <target state="translated">새로 푸시 된 그룹은 스택 맨 위에 있던 그룹의 동일한 필터링 설정을 상속합니다. 즉, 새 그룹을 푸시해도 필터링이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fecd28a78f78c05dfba34a4a0d5cd009a14bdfd0" translate="yes" xml:space="preserve">
          <source>The next call to &lt;a href=&quot;qimagereader#read&quot;&gt;read&lt;/a&gt;() will attempt to read this image.</source>
          <target state="translated">다음 번에 &lt;a href=&quot;qimagereader#read&quot;&gt;읽기&lt;/a&gt; ()를 호출하면 이 이미지를 읽으려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="cd09c6acf2727a710756ad4c06ad85412cfa18cd" translate="yes" xml:space="preserve">
          <source>The next child of the context node</source>
          <target state="translated">컨텍스트 노드의 다음 자식</target>
        </trans-unit>
        <trans-unit id="1d53a5ecd15dc0623346157b9af81e4bab200587" translate="yes" xml:space="preserve">
          <source>The next example shows how to derive from an existing style to customize the look of a graphical element:</source>
          <target state="translated">다음 예제는 기존 스타일에서 파생하여 그래픽 요소의 모양을 사용자 정의하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0ed7e001e3716975746d1659d2a6991bc3e84c00" translate="yes" xml:space="preserve">
          <source>The next example uses &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; to read a text file line by line:</source>
          <target state="translated">다음 예제는 &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; 을 사용 하여 텍스트 파일을 한 줄씩 읽습니다.</target>
        </trans-unit>
        <trans-unit id="63cfad7f04da72d044c14e611ec0a1127b5ba29e" translate="yes" xml:space="preserve">
          <source>The next item (in a list) is selected. For example, the selected tab of a &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; is next to this item.</source>
          <target state="translated">다음 항목 (목록에서)이 선택됩니다. 예를 들어, &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; 의 선택된 탭 이이 항목 옆에 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c709b70f6ef279f5e1695cdf659d3a4807de452" translate="yes" xml:space="preserve">
          <source>The next section is selected</source>
          <target state="translated">다음 섹션이 선택되었습니다</target>
        </trans-unit>
        <trans-unit id="5223163259f16945f949e9bfe24cfdfb8a1cbc2b" translate="yes" xml:space="preserve">
          <source>The next sections illustrate each layout.</source>
          <target state="translated">다음 섹션에서는 각 레이아웃에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="120aef0c983732dc94377e46d9152bc0aa489152" translate="yes" xml:space="preserve">
          <source>The next step is to combine all three layouts into one &lt;b&gt;main layout&lt;/b&gt;. The main layout is the top level widget's (in this case, the &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;) layout. It is important that your top level widget has a layout; otherwise, the widgets on your window will not resize when your window is resized. To set the layout, &lt;b&gt;Right click&lt;/b&gt; anywhere on your form, outside of the three separate layouts, and select &lt;b&gt;Lay Out Horizontally&lt;/b&gt;. Alternatively, you could also select &lt;b&gt;Lay Out in a Grid&lt;/b&gt; -- you will still see the same arrangement (shown below).</source>
          <target state="translated">다음 단계는 세 가지 레이아웃을 모두 하나의 &lt;b&gt;기본 레이아웃&lt;/b&gt; 으로 결합하는 것 입니다. 기본 레이아웃은 최상위 위젯 (이 경우 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; ) 레이아웃입니다. 최상위 위젯에는 레이아웃이 있어야합니다. 그렇지 않으면, 창의 크기를 조정할 때 창의 위젯 크기가 조정되지 않습니다. 레이아웃을 설정하려면 세 개의 개별 레이아웃 외부에서 양식의 아무 곳 이나 &lt;b&gt;마우스 오른쪽 단추로 클릭&lt;/b&gt; 하고 &lt;b&gt;가로&lt;/b&gt; 레이아웃을 선택하십시오 . 또는 &lt;b&gt;격자에서 배치&lt;/b&gt; 를 선택할 수도 있습니다. 여전히 같은 배열이 표시됩니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="87bebbcab0404856fc3e6acf0852fdf26d6b5fcf" translate="yes" xml:space="preserve">
          <source>The next step is to provide an implementation of &lt;a href=&quot;qcanbusdevice&quot;&gt;QCanBusDevice&lt;/a&gt;. At the very least, the following pure virtual functions must be implemented:</source>
          <target state="translated">다음 단계는 &lt;a href=&quot;qcanbusdevice&quot;&gt;QCanBusDevice&lt;/a&gt; 구현을 제공하는 것입니다 . 최소한 다음과 같은 순수한 가상 기능을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="83bd1df0161bd7f457eb7261cc71e5cc6df6c4fb" translate="yes" xml:space="preserve">
          <source>The next tab (typically the tab on the right) is selected.</source>
          <target state="translated">다음 탭 (일반적으로 오른쪽의 탭)이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="ca5492498925113c439977d17f8c560bdb9bc029" translate="yes" xml:space="preserve">
          <source>The next tab is selected.</source>
          <target state="translated">다음 탭이 선택되었습니다.</target>
        </trans-unit>
        <trans-unit id="d1d2100c26ca4513bcc47f5f5ea33877b1b919ca" translate="yes" xml:space="preserve">
          <source>The next() call in the loop is made every time. It jumps over the next item in the list. The &lt;a href=&quot;qmutablelistiterator#remove&quot;&gt;remove()&lt;/a&gt; function removes the last item that we jumped over from the list. The call to &lt;a href=&quot;qmutablelistiterator#remove&quot;&gt;remove()&lt;/a&gt; does not invalidate the iterator, so it is safe to continue using it. This works just as well when iterating backward:</source>
          <target state="translated">루프에서 next () 호출은 매번 수행됩니다. 목록에서 다음 항목으로 건너 뜁니다. &lt;a href=&quot;qmutablelistiterator#remove&quot;&gt;제거 ()&lt;/a&gt; 함수는 우리가 목록에서 이상 뛰어 것을 마지막 항목을 제거합니다. &lt;a href=&quot;qmutablelistiterator#remove&quot;&gt;remove ()를&lt;/a&gt; 호출 해도 반복자가 무효화되지 않으므로 계속 사용하는 것이 안전합니다. 이것은 거꾸로 반복 할 때에도 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cc27a83965d13061c10b3c456ea8e10bd3e74366" translate="yes" xml:space="preserve">
          <source>The nfc adapter is offline.</source>
          <target state="translated">NFC 어댑터가 오프라인 상태입니다.</target>
        </trans-unit>
        <trans-unit id="095753efcfbd86fa9bd561ca12b5539079a14054" translate="yes" xml:space="preserve">
          <source>The nfc adapter is online.</source>
          <target state="translated">NFC 어댑터가 온라인 상태입니다.</target>
        </trans-unit>
        <trans-unit id="e3d536b3b8eec50c6f8839017dfa7a09c7fd5522" translate="yes" xml:space="preserve">
          <source>The nfc adapter is turning off.</source>
          <target state="translated">NFC 어댑터가 꺼져 있습니다.</target>
        </trans-unit>
        <trans-unit id="811a5fab4b079f63c2d0bb380ecbd21149c01306" translate="yes" xml:space="preserve">
          <source>The nfc adapter is turning on.</source>
          <target state="translated">NFC 어댑터가 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="763b4d6f240049e999bf330266f5859bb1f1d255" translate="yes" xml:space="preserve">
          <source>The nlerp() function is typically faster than &lt;a href=&quot;qquaternion#slerp&quot;&gt;slerp&lt;/a&gt;() and will give approximate results to spherical interpolation that are good enough for some applications.</source>
          <target state="translated">nlerp () 함수는 일반적으로 &lt;a href=&quot;qquaternion#slerp&quot;&gt;slerp&lt;/a&gt; () 보다 빠르며 일부 응용 프로그램에 충분한 구형 보간에 대한 대략적인 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e7935820ff8df21731b10d72b1b07e2393fc1dd6" translate="yes" xml:space="preserve">
          <source>The node and vertex threshold for a transform node to become a batch root can be overridden using the environment variables &lt;code&gt;QSG_RENDERER_BATCH_NODE_THRESHOLD=[count]&lt;/code&gt; and &lt;code&gt;QSG_RENDERER_BATCH_VERTEX_THRESHOLD=[count]&lt;/code&gt;. Overriding these flags will be mostly useful for platform vendors.</source>
          <target state="translated">변환 노드가 배치 루트가되는 노드 및 정점 임계 값은 환경 변수 &lt;code&gt;QSG_RENDERER_BATCH_NODE_THRESHOLD=[count]&lt;/code&gt; 및 &lt;code&gt;QSG_RENDERER_BATCH_VERTEX_THRESHOLD=[count]&lt;/code&gt; 를 사용하여 무시할 수 있습니다 . 이 플래그를 재정의하면 플랫폼 공급 업체에 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="67268697060f412a1201c68674cd3080d62c015b" translate="yes" xml:space="preserve">
          <source>The node in the tree has a sibling (i.e., there is another node in the same column).</source>
          <target state="translated">트리의 노드에는 형제가 있습니다 (즉, 동일한 열에 다른 노드가 있습니다).</target>
        </trans-unit>
        <trans-unit id="45a01606c88802783d68e6fad6267f5918dc4fea" translate="yes" xml:space="preserve">
          <source>The node index returned will be the element node whose value is of type &lt;code&gt;ID&lt;/code&gt; and equals</source>
          <target state="translated">리턴 된 노드 인덱스는 값이 &lt;code&gt;ID&lt;/code&gt; 유형 이고 동일한 요소 노드입니다.</target>
        </trans-unit>
        <trans-unit id="19bb0523de44cfc56069dde60d3e382bf4656fbb" translate="yes" xml:space="preserve">
          <source>The node is owned by its parent and will be deleted when the parent is deleted.</source>
          <target state="translated">노드는 부모가 소유하며 부모가 삭제 될 때 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="ca0b88de427409a5fe31f0b0c90cab58229dc490" translate="yes" xml:space="preserve">
          <source>The node model represented by a subclass of &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt; is meant to be accessed by the Qt XML Patterns query engine. If the API seems a little strange in a few places, it is because the member functions are called by the query engine as it evaluates an &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;. They aren't meant to be used programatically.</source>
          <target state="translated">&lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt; 의 서브 클래스로 표시되는 노드 모델은 Qt XML 패턴 쿼리 엔진에 의해 액세스됩니다. API가 몇 군데에서 조금 이상해 보인다면 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery를&lt;/a&gt; 평가할 때 쿼리 엔진이 멤버 함수를 호출하기 때문 입니다. 그것들은 프로그래밍 방식으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a2dff030f13a48a9e490dacaae5f63101c137094" translate="yes" xml:space="preserve">
          <source>The node type of the node containing this character data is returned by &lt;a href=&quot;qdomcharacterdata#nodeType&quot;&gt;nodeType&lt;/a&gt;().</source>
          <target state="translated">이 문자 데이터를 포함하는 노드의 노드 유형은 &lt;a href=&quot;qdomcharacterdata#nodeType&quot;&gt;nodeType&lt;/a&gt; ()에 의해 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="84114eecbedca45b9fe469a65fae0a31515b6175" translate="yes" xml:space="preserve">
          <source>The node's name and value (the meaning of which varies depending on its type) is returned by &lt;a href=&quot;qdomnode#nodeName&quot;&gt;nodeName&lt;/a&gt;() and &lt;a href=&quot;qdomnode#nodeValue&quot;&gt;nodeValue&lt;/a&gt;() respectively. The node's type is returned by &lt;a href=&quot;qdomnode#nodeType&quot;&gt;nodeType&lt;/a&gt;(). The node's value can be set with &lt;a href=&quot;qdomnode#setNodeValue&quot;&gt;setNodeValue&lt;/a&gt;().</source>
          <target state="translated">노드 이름과 값 (유형에 따라 의미가 다름)은 각각 &lt;a href=&quot;qdomnode#nodeName&quot;&gt;nodeName&lt;/a&gt; () 및 &lt;a href=&quot;qdomnode#nodeValue&quot;&gt;nodeValue&lt;/a&gt; ()에 의해 반환됩니다 . 노드 유형은 &lt;a href=&quot;qdomnode#nodeType&quot;&gt;nodeType&lt;/a&gt; ()에 의해 리턴됩니다 . 노드의 값은 &lt;a href=&quot;qdomnode#setNodeValue&quot;&gt;setNodeValue&lt;/a&gt; () 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d6f1d59cfdb6259b7c53f4eb77f5e8f9af65a28" translate="yes" xml:space="preserve">
          <source>The node's virtual &lt;a href=&quot;qsgnode#preprocess&quot;&gt;preprocess&lt;/a&gt;() function will be called before rendering starts.</source>
          <target state="translated">렌더링을 시작하기 전에 노드의 가상 &lt;a href=&quot;qsgnode#preprocess&quot;&gt;사전 프로세스&lt;/a&gt; () 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="88486230cd76a912034951c993fc51b358d221d4" translate="yes" xml:space="preserve">
          <source>The nodes in the list are not copied; so changing the nodes in the list will also change the children of this node.</source>
          <target state="translated">목록의 노드는 복사되지 않습니다. 따라서 목록에서 노드를 변경하면이 노드의 자식도 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="78b07a01280dfbf202336d5ba331d16df7eee0e7" translate="yes" xml:space="preserve">
          <source>The non in-place modifying functions such as mapped() and filtered() makes a copy of the container when called. If you are using STL containers this copy operation might take some time, in this case we recommend specifying the begin and end iterators for the container instead.</source>
          <target state="translated">매핑 된 () 및 필터링 된 ()과 같은 비 위치 수정 함수는 호출 될 때 컨테이너의 사본을 만듭니다. STL 컨테이너를 사용하는 경우이 복사 작업에 다소 시간이 걸릴 수 있습니다.이 경우 컨테이너의 시작 및 종료 반복자를 대신 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="34820a7e9ab7a07c8527a8194d403444c6443832" translate="yes" xml:space="preserve">
          <source>The non-blocking alternative is to connect to the &lt;a href=&quot;qlocalserver#newConnection&quot;&gt;newConnection&lt;/a&gt;() signal.</source>
          <target state="translated">비 차단 대안은 &lt;a href=&quot;qlocalserver#newConnection&quot;&gt;newConnection&lt;/a&gt; () 신호 에 연결하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b0a0335fe95138ebab2e3eeeac12df8c9d41ae71" translate="yes" xml:space="preserve">
          <source>The non-blocking alternative is to connect to the &lt;a href=&quot;qtcpserver#newConnection&quot;&gt;newConnection&lt;/a&gt;() signal.</source>
          <target state="translated">비 차단 대안은 &lt;a href=&quot;qtcpserver#newConnection&quot;&gt;newConnection&lt;/a&gt; () 신호 에 연결하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3e33d9cc2bf2587f6197f53c79b827dca970a3ca" translate="yes" xml:space="preserve">
          <source>The non-named capturing groups do not capture substrings; named capturing groups still work as intended, as well as the implicit capturing group number 0 corresponding to the entire match. There is no equivalent for this option in Perl regular expressions.</source>
          <target state="translated">명명되지 않은 캡처 그룹은 하위 문자열을 캡처하지 않습니다. 명명 된 캡처 그룹은 의도 한대로 작동하며 전체 일치에 해당하는 암시 적 캡처 그룹 번호 0입니다. Perl 정규식에는이 옵션에 해당하는 것이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f74443bb7ede8384da348e785ca78f1e9861beb" translate="yes" xml:space="preserve">
          <source>The non-threaded render loop is currently used by default on Windows with ANGLE or a non-default opengl32 implementation, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, and Linux with Mesa drivers. For the latter this is mostly a precautionary measure, as not all combinations of OpenGL drivers and windowing systems have been tested. At the same time implementations like ANGLE or Mesa llvmpipe are not able to function properly with threaded rendering at all so not using threaded rendering is essential for these.</source>
          <target state="translated">스레드되지 않은 렌더 루프는 현재 ANGLE이있는 Windows 또는 기본이 아닌 opengl32 구현, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 및 Mesa 드라이버가있는 Linux에서 기본적으로 사용됩니다 . 후자의 경우 OpenGL 드라이버와 윈도우 시스템의 모든 조합이 테스트 된 것은 아니기 때문에 대부분 예방 조치입니다. 동시에 ANGLE 또는 Mesa llvmpipe와 같은 구현은 스레드 렌더링에서 제대로 작동하지 않으므로 스레드 렌더링을 사용하지 않는 것이 필수적입니다.</target>
        </trans-unit>
        <trans-unit id="f79d8c826fd17f79a4b4fbe50bcc0af4852f0af8" translate="yes" xml:space="preserve">
          <source>The normal Alt keys, but not keys like AltGr.</source>
          <target state="translated">일반적인 Alt 키는 AltGr과 같은 키는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8af927f1bb322ad2c28b5d6d1f474c95f91b2c5c" translate="yes" xml:space="preserve">
          <source>The normal and most flexible way to include a plugin with an application is to compile it into a dynamic library that is shipped separately, and detected and loaded at runtime.</source>
          <target state="translated">애플리케이션에 플러그인을 포함시키는 일반적이고 가장 유연한 방법은 플러그인을 별도로 제공하고 런타임에 감지하여로드하는 동적 라이브러리로 컴파일하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="12731fb0f05a3b761b8613ee0df999976abe74e9" translate="yes" xml:space="preserve">
          <source>The normal button for a MDI subwindow in the menu bar.</source>
          <target state="translated">메뉴 표시 줄에있는 MDI 하위 창의 일반 버튼입니다.</target>
        </trans-unit>
        <trans-unit id="9d3fb606a6d9c73bae0a81916cfbdfc820fbc7a0" translate="yes" xml:space="preserve">
          <source>The normal rounded look above the pages</source>
          <target state="translated">페이지 위의 일반적인 둥근 모양</target>
        </trans-unit>
        <trans-unit id="69f2d0c6965eb6af402c27d5924108e3151288ed" translate="yes" xml:space="preserve">
          <source>The normal rounded look below the pages</source>
          <target state="translated">페이지 아래의 일반적인 둥근 모양</target>
        </trans-unit>
        <trans-unit id="1fda4ae93b249fd27cab68c2cef5e07982f0292a" translate="yes" xml:space="preserve">
          <source>The normal rounded look on the left side of the pages</source>
          <target state="translated">페이지 왼쪽의 일반적인 둥근 모양</target>
        </trans-unit>
        <trans-unit id="f79c8458c0ced2bb31ccf972d16feb71b1850178" translate="yes" xml:space="preserve">
          <source>The normal rounded look on the right side the pages</source>
          <target state="translated">페이지 오른쪽의 일반적인 둥근 모양</target>
        </trans-unit>
        <trans-unit id="212aa34d02c2050cdb884184fc3b7b7095588aeb" translate="yes" xml:space="preserve">
          <source>The normal way for an event to be delivered is by calling a virtual function. For example, &lt;a href=&quot;qpaintevent&quot;&gt;QPaintEvent&lt;/a&gt; is delivered by calling &lt;a href=&quot;qwidget#paintEvent&quot;&gt;QWidget::paintEvent&lt;/a&gt;(). This virtual function is responsible for reacting appropriately, normally by repainting the widget. If you do not perform all the necessary work in your implementation of the virtual function, you may need to call the base class's implementation.</source>
          <target state="translated">이벤트가 전달되는 일반적인 방법은 가상 함수를 호출하는 것입니다. 예를 들어 &lt;a href=&quot;qpaintevent&quot;&gt;QPaintEvent&lt;/a&gt; 는 &lt;a href=&quot;qwidget#paintEvent&quot;&gt;QWidget :: paintEvent&lt;/a&gt; ()를 호출하여 전달됩니다 . 이 가상 기능은 일반적으로 위젯을 다시 페인트하여 적절하게 반응합니다. 가상 함수 구현에서 필요한 모든 작업을 수행하지 않으면 기본 클래스의 구현을 호출해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eff5ef7260be343d1828fd1fc09ea6b812a70fef" translate="yes" xml:space="preserve">
          <source>The normal way to use &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; is to do the following:</source>
          <target state="translated">&lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; 을 사용하는 일반적인 방법 은 다음을 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ce79893dfd7d722ed4d1a5016b44f6fc70996f52" translate="yes" xml:space="preserve">
          <source>The notation of the days can be altered to a single letter abbreviations (&quot;M&quot; for &quot;Monday&quot;) by setting the &lt;a href=&quot;qcalendarwidget#horizontalHeaderFormat-prop&quot;&gt;horizontalHeaderFormat&lt;/a&gt; property to &lt;a href=&quot;qcalendarwidget#HorizontalHeaderFormat-enum&quot;&gt;QCalendarWidget::SingleLetterDayNames&lt;/a&gt;. Setting the same property to &lt;a href=&quot;qcalendarwidget#HorizontalHeaderFormat-enum&quot;&gt;QCalendarWidget::LongDayNames&lt;/a&gt; makes the header display the complete day names. The week numbers can be removed by setting the &lt;a href=&quot;qcalendarwidget#verticalHeaderFormat-prop&quot;&gt;verticalHeaderFormat&lt;/a&gt; property to &lt;a href=&quot;qcalendarwidget#VerticalHeaderFormat-enum&quot;&gt;QCalendarWidget::NoVerticalHeader&lt;/a&gt;. The calendar grid can be turned on by setting the &lt;a href=&quot;qcalendarwidget#gridVisible-prop&quot;&gt;gridVisible&lt;/a&gt; property to true using the &lt;a href=&quot;qcalendarwidget#gridVisible-prop&quot;&gt;setGridVisible&lt;/a&gt;() function:</source>
          <target state="translated">&lt;a href=&quot;qcalendarwidget#horizontalHeaderFormat-prop&quot;&gt;horizontalHeaderFormat&lt;/a&gt; 속성을 &lt;a href=&quot;qcalendarwidget#HorizontalHeaderFormat-enum&quot;&gt;QCalendarWidget :: SingleLetterDayNames&lt;/a&gt; 로 설정하여 요일 표기를 단일 문자 약어 ( &quot;Monday&quot;의 경우 &quot;M&quot;)로 변경할 수 있습니다 . 동일한 특성을 &lt;a href=&quot;qcalendarwidget#HorizontalHeaderFormat-enum&quot;&gt;QCalendarWidget :: LongDayNames&lt;/a&gt; 로 설정하면 헤더에 완전한 요일 이름이 표시됩니다. &lt;a href=&quot;qcalendarwidget#verticalHeaderFormat-prop&quot;&gt;verticalHeaderFormat&lt;/a&gt; 속성을 &lt;a href=&quot;qcalendarwidget#VerticalHeaderFormat-enum&quot;&gt;QCalendarWidget :: NoVerticalHeader&lt;/a&gt; 로 설정하면 주 번호를 제거 할 수 있습니다 . &lt;a href=&quot;qcalendarwidget#gridVisible-prop&quot;&gt;setGridVisible&lt;/a&gt; () 함수를 사용하여 &lt;a href=&quot;qcalendarwidget#gridVisible-prop&quot;&gt;gridVisible&lt;/a&gt; 속성을 true 로 설정하면 캘린더 그리드를 켤 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efe36def12999e05d1a5465ff7ea01122e29b0d1" translate="yes" xml:space="preserve">
          <source>The notch size is in range control units, not pixels, and if possible it is a multiple of &lt;a href=&quot;qabstractslider#singleStep-prop&quot;&gt;singleStep&lt;/a&gt;() that results in an on-screen notch size near &lt;a href=&quot;qdial#notchTarget-prop&quot;&gt;notchTarget&lt;/a&gt;().</source>
          <target state="translated">노치 크기 범위 제어 유닛이 아닌 픽셀에, 가능한 경우는의 배수 &lt;a href=&quot;qabstractslider#singleStep-prop&quot;&gt;singleStep&lt;/a&gt; 그 근처 화면 노치 크기 결과 () &lt;a href=&quot;qdial#notchTarget-prop&quot;&gt;notchTarget&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="a5a5c0387f811179e1574c402b1f0c30661a916d" translate="yes" xml:space="preserve">
          <source>The notch target is the number of pixels &lt;a href=&quot;qdial&quot;&gt;QDial&lt;/a&gt; attempts to put between each notch.</source>
          <target state="translated">노치 대상은 &lt;a href=&quot;qdial&quot;&gt;QDial&lt;/a&gt; 이 각 노치 사이에 놓으 려는 픽셀 수입니다 .</target>
        </trans-unit>
        <trans-unit id="91bdcc27992d51ef56d1830d29b898258292d3bf" translate="yes" xml:space="preserve">
          <source>The notifiable properties are &lt;a href=&quot;qml-qtmultimedia-audio#position-prop&quot;&gt;position&lt;/a&gt; and &lt;a href=&quot;qml-qtmultimedia-audio#bufferProgress-prop&quot;&gt;bufferProgress&lt;/a&gt;.</source>
          <target state="translated">통지 가능한 프로퍼티는 &lt;a href=&quot;qml-qtmultimedia-audio#position-prop&quot;&gt;position&lt;/a&gt; 및 &lt;a href=&quot;qml-qtmultimedia-audio#bufferProgress-prop&quot;&gt;bufferProgress&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="464c974dde0d4913fcb9a01ad9005d20a42f3519" translate="yes" xml:space="preserve">
          <source>The notifiable properties are &lt;a href=&quot;qml-qtmultimedia-mediaplayer#position-prop&quot;&gt;position&lt;/a&gt; and &lt;a href=&quot;qml-qtmultimedia-mediaplayer#bufferProgress-prop&quot;&gt;bufferProgress&lt;/a&gt;.</source>
          <target state="translated">통지 가능한 프로퍼티는 &lt;a href=&quot;qml-qtmultimedia-mediaplayer#position-prop&quot;&gt;position&lt;/a&gt; 및 &lt;a href=&quot;qml-qtmultimedia-mediaplayer#bufferProgress-prop&quot;&gt;bufferProgress&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c27f6258b1f9c873a931075f103aaf6ade952e83" translate="yes" xml:space="preserve">
          <source>The notifiable properties are &lt;a href=&quot;qml-qtmultimedia-video#position-prop&quot;&gt;position&lt;/a&gt; and &lt;a href=&quot;qml-qtmultimedia-video#bufferProgress-prop&quot;&gt;bufferProgress&lt;/a&gt;.</source>
          <target state="translated">통지 가능한 프로퍼티는 &lt;a href=&quot;qml-qtmultimedia-video#position-prop&quot;&gt;position&lt;/a&gt; 및 &lt;a href=&quot;qml-qtmultimedia-video#bufferProgress-prop&quot;&gt;bufferProgress&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d5eeb529b6108251eada347ca92b14e153729655" translate="yes" xml:space="preserve">
          <source>The notification source is another connection</source>
          <target state="translated">알림 소스는 다른 연결입니다</target>
        </trans-unit>
        <trans-unit id="14b7d6ca415fdcad521c1d1f3a045057f41d34a4" translate="yes" xml:space="preserve">
          <source>The notification source is this connection</source>
          <target state="translated">알림 소스는이 연결입니다</target>
        </trans-unit>
        <trans-unit id="9e35631f144f66dfe38520320b09bf8c0e5ee073" translate="yes" xml:space="preserve">
          <source>The notification source is unknown</source>
          <target state="translated">알림 소스를 알 수 없습니다</target>
        </trans-unit>
        <trans-unit id="16431e607b888ee93039b1c0ac0abc8b4e33013a" translate="yes" xml:space="preserve">
          <source>The notifier is enabled by default, i.e. it emits the &lt;a href=&quot;qsocketnotifier#activated&quot;&gt;activated&lt;/a&gt;() signal whenever a socket event corresponding to its &lt;a href=&quot;qsocketnotifier#type&quot;&gt;type&lt;/a&gt; occurs. If it is disabled, it ignores socket events (the same effect as not creating the socket notifier).</source>
          <target state="translated">알리미는 기본적으로 활성화되어 있습니다. 즉, 해당 &lt;a href=&quot;qsocketnotifier#type&quot;&gt;유형에&lt;/a&gt; 해당하는 소켓 이벤트가 발생할 때마다 &lt;a href=&quot;qsocketnotifier#activated&quot;&gt;활성화 된&lt;/a&gt; () 신호를 방출 합니다. 비활성화 된 경우 소켓 이벤트를 무시합니다 (소켓 알리미를 작성하지 않는 것과 동일한 효과).</target>
        </trans-unit>
        <trans-unit id="358a58b400051a7bea47e1f56a23f8b50cb03431" translate="yes" xml:space="preserve">
          <source>The notifier is enabled by default, i.e. it emits the &lt;a href=&quot;qwineventnotifier#activated&quot;&gt;activated&lt;/a&gt;() signal whenever the corresponding event is signalled. However, it is generally advisable to explicitly enable or disable the event notifier.</source>
          <target state="translated">알리미는 기본적으로 활성화되어 있습니다. 즉 , 해당 이벤트가 시그널링 될 때마다 &lt;a href=&quot;qwineventnotifier#activated&quot;&gt;활성화 된&lt;/a&gt; () 신호를 방출합니다 . 그러나 일반적으로 이벤트 알리미를 명시 적으로 활성화 또는 비활성화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3d3dfbdf7e50b984830359c72e8ac1ffdf986ccc" translate="yes" xml:space="preserve">
          <source>The notifier signal was introduced in Qt 5.4.</source>
          <target state="translated">알리미 신호는 Qt 5.4에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="0ba11c57bc1dd984f553636ddd794a7e38f2cfb3" translate="yes" xml:space="preserve">
          <source>The null address object. Equivalent to &lt;a href=&quot;qhostaddress#QHostAddress&quot;&gt;QHostAddress&lt;/a&gt;(). See also &lt;a href=&quot;qhostaddress#isNull&quot;&gt;QHostAddress::isNull&lt;/a&gt;().</source>
          <target state="translated">널 주소 오브젝트 &lt;a href=&quot;qhostaddress#QHostAddress&quot;&gt;QHostAddress&lt;/a&gt; () 와 같습니다 . &lt;a href=&quot;qhostaddress#isNull&quot;&gt;QHostAddress :: isNull&lt;/a&gt; () 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e44bd7d96583f7ba5be76512c558b6c849d3b5f" translate="yes" xml:space="preserve">
          <source>The null device of the operating system.</source>
          <target state="translated">운영 체제의 널 디바이스입니다.</target>
        </trans-unit>
        <trans-unit id="e7e932e70622f346b2ae62e65d8fb3081929729e" translate="yes" xml:space="preserve">
          <source>The number</source>
          <target state="translated">수</target>
        </trans-unit>
        <trans-unit id="d5f7bb5cbab81190203970c5d80cc9b99971c863" translate="yes" xml:space="preserve">
          <source>The number by which to increase or decrease the slider's value (relative to the size of the slider and its value range) on page steps.</source>
          <target state="translated">페이지 단계에서 슬라이더의 값 (슬라이더 크기 및 값 범위에 상대적인 값)을 늘리거나 줄이는 수입니다.</target>
        </trans-unit>
        <trans-unit id="a9fbc4912bf693a305777da0684cd20edba104d1" translate="yes" xml:space="preserve">
          <source>The number by which to increase or decrease the slider's value on page steps.</source>
          <target state="translated">페이지 단계에서 슬라이더의 값을 늘리거나 줄이는 데 사용되는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="a7bd71b0b495400ca2f890a81d092cf4a5c3f080" translate="yes" xml:space="preserve">
          <source>The number by which to increase or decrease the slider's value on single (or line) steps.</source>
          <target state="translated">단일 (또는 라인) 단계에서 슬라이더 값을 늘리거나 줄이는 데 사용되는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="8535fba7bd050fac6b3d1dfa4a17b2072c4a2d35" translate="yes" xml:space="preserve">
          <source>The number is formatted according to the current locale.</source>
          <target state="translated">숫자는 현재 로케일에 따라 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="cfa7cf51c401677eaacdedc0c001c63245210aed" translate="yes" xml:space="preserve">
          <source>The number is not well formed</source>
          <target state="translated">숫자가 잘 형성되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="97ebcad80a9bd0d9b9c98aa1493421ec325e3bb1" translate="yes" xml:space="preserve">
          <source>The number of 1 bits in each character, including the parity bit, is always even.</source>
          <target state="translated">패리티 비트를 포함하여 각 문자에서 1 비트의 수는 항상 짝수입니다.</target>
        </trans-unit>
        <trans-unit id="f82cb6e9ead7b377f44bbf3dbfeb79e0c06b7a2d" translate="yes" xml:space="preserve">
          <source>The number of 1 bits in each character, including the parity bit, is always odd. It ensures that at least one state transition occurs in each character.</source>
          <target state="translated">패리티 비트를 포함하여 각 문자의 1 비트 수는 항상 홀수입니다. 각 문자에서 하나 이상의 상태 전이가 발생하도록합니다.</target>
        </trans-unit>
        <trans-unit id="8beac30bc5a7d0349d481b53a941a45bfa9cffb1" translate="yes" xml:space="preserve">
          <source>The number of Hertz for each step when tuning the radio manually. The value is for the current &lt;a href=&quot;qml-qtmultimedia-radio#band-prop&quot;&gt;band&lt;/a&gt;.</source>
          <target state="translated">라디오를 수동으로 튜닝 할 때 각 단계의 헤르츠 수입니다. 값은 현재 &lt;a href=&quot;qml-qtmultimedia-radio#band-prop&quot;&gt;밴드에 대한 것&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8d4789a93fe843bb219ee92995f092c143659b5b" translate="yes" xml:space="preserve">
          <source>The number of alternative routes</source>
          <target state="translated">대체 경로의 수</target>
        </trans-unit>
        <trans-unit id="8bb9e07804201955d85ce0c9ee7d0e2043d6c1f4" translate="yes" xml:space="preserve">
          <source>The number of alternative routes requested when requesting routes. The default value is 0.</source>
          <target state="translated">경로를 요청할 때 요청 된 대체 경로의 수입니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="a60afbf12fd18c1db545c03db6c03747ed9ceb1a" translate="yes" xml:space="preserve">
          <source>The number of anchors in a hypertext link has changed, perhaps because the display text has been split to provide more than one link.</source>
          <target state="translated">하이퍼 텍스트 링크의 앵커 수가 변경되었습니다. 표시 텍스트가 둘 이상의 링크를 제공하도록 분할 되었기 때문일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb8066ee47be987d2903a5fe5aed68cf5a264ce6" translate="yes" xml:space="preserve">
          <source>The number of arguments the reply is expected to have</source>
          <target state="translated">회신에 필요한 인수 수</target>
        </trans-unit>
        <trans-unit id="a510889c3c450433a7dc538aa63881835dc3477f" translate="yes" xml:space="preserve">
          <source>The number of audio channels (typically one for mono or two for stereo)</source>
          <target state="translated">오디오 채널 수 (일반적으로 모노 용 또는 스테레오 용 하나)</target>
        </trans-unit>
        <trans-unit id="c1cb3732a7cf30acb05c2d449d3f6ecb48b95a37" translate="yes" xml:space="preserve">
          <source>The number of bar sets in a bar series.</source>
          <target state="translated">바 시리즈의 바 세트 수입니다.</target>
        </trans-unit>
        <trans-unit id="5b643cca95a9c64650fff869ba8878c15d627fae" translate="yes" xml:space="preserve">
          <source>The number of bit planes is the number of bits of color and transparency information for each pixel. This is different from (i.e. smaller than) the depth when the image format contains unused bits.</source>
          <target state="translated">비트 평면의 수는 각 픽셀의 색상 및 투명도 정보의 비트 수입니다. 이는 이미지 형식에 사용되지 않은 비트가 포함되어있을 때의 깊이와 다릅니다 (즉, 깊이보다 작습니다).</target>
        </trans-unit>
        <trans-unit id="a0135833776677b53eaf9a5f3c5faeca32f7d6cf" translate="yes" xml:space="preserve">
          <source>The number of box-and-whiskers items in a box plot series.</source>
          <target state="translated">상자 그림 시리즈의 상자 및 수염 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="ed55a8255f6491d38d47f5ae46846d23b2969ad7" translate="yes" xml:space="preserve">
          <source>The number of candlestick items in a series.</source>
          <target state="translated">일련의 촛대 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="a1e3f5a2286ce6a1dcd63aee80f921e76ae4c755" translate="yes" xml:space="preserve">
          <source>The number of categories of an axis.</source>
          <target state="translated">축의 범주 수입니다.</target>
        </trans-unit>
        <trans-unit id="04bb844dcd0242be6b35d7a04d1e7623cc55a0cc" translate="yes" xml:space="preserve">
          <source>The number of categories.</source>
          <target state="translated">카테고리 수</target>
        </trans-unit>
        <trans-unit id="56ac7be00c5520fda55ea4637ca7de0b8fdca0ef" translate="yes" xml:space="preserve">
          <source>The number of channels in the media's audio stream.</source>
          <target state="translated">미디어 오디오 스트림의 채널 수입니다.</target>
        </trans-unit>
        <trans-unit id="a2eda2a6bba42d84d2454f0aba34f43dfdf947d9" translate="yes" xml:space="preserve">
          <source>The number of columns in the Tumbler.</source>
          <target state="translated">텀블러의 열 수입니다.</target>
        </trans-unit>
        <trans-unit id="e7e102774e82a71199fcbf583ddbe5846a966d25" translate="yes" xml:space="preserve">
          <source>The number of columns in the data array.</source>
          <target state="translated">데이터 배열의 열 수입니다.</target>
        </trans-unit>
        <trans-unit id="16392168c66e75fd8ccd486c0bf642fa8b459f22" translate="yes" xml:space="preserve">
          <source>The number of columns of the model that are mapped as the data for series. The default value is -1 (the number is limited by the number of columns in the model).</source>
          <target state="translated">계열의 데이터로 매핑 된 모델의 열 수입니다. 기본값은 -1입니다 (숫자는 모델의 열 수로 제한됨).</target>
        </trans-unit>
        <trans-unit id="e060d14673b6564f9d9f196c1f7e62cb69e29147" translate="yes" xml:space="preserve">
          <source>The number of columns of the model that are mapped as the data for the bar series. The default value is -1 (number limited to the number of columns in the model).</source>
          <target state="translated">막대 계열의 데이터로 매핑 된 모델의 열 수입니다. 기본값은 -1입니다 (숫자는 모델의 열 수로 제한됨).</target>
        </trans-unit>
        <trans-unit id="9352390684f5d0c1998e8f1f41711598daec74a5" translate="yes" xml:space="preserve">
          <source>The number of columns of the model that are mapped as the data for the box plot series. The minimum and default value is -1 (number limited to the number of columns in the model).</source>
          <target state="translated">상자 그림 계열의 데이터로 매핑 된 모델의 열 수입니다. 최소값과 기본값은 -1입니다 (숫자는 모델의 열 수로 제한됨).</target>
        </trans-unit>
        <trans-unit id="002c84b39bc8347850ed4d5cdce1cdafd6a7d26b" translate="yes" xml:space="preserve">
          <source>The number of columns of the model that are mapped as the data for the pie series. The default value is -1 (number limited by the number of columns in the model).</source>
          <target state="translated">파이 계열의 데이터로 매핑 된 모델의 열 수입니다. 기본값은 -1입니다 (숫자는 모델의 열 수로 제한됨).</target>
        </trans-unit>
        <trans-unit id="9aa96702133dda84380ccecd177ada93e5a98eae" translate="yes" xml:space="preserve">
          <source>The number of data bits in each character is 5. It is used for Baudot code. It generally only makes sense with older equipment such as teleprinters.</source>
          <target state="translated">각 문자의 데이터 비트 수는 5입니다. Baudot 코드에 사용됩니다. 일반적으로 텔레 프린터와 같은 구형 장비에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8f831043ba7a4b760fec8a249bb705944ceae40" translate="yes" xml:space="preserve">
          <source>The number of data bits in each character is 6. It is rarely used.</source>
          <target state="translated">각 문자의 데이터 비트 수는 6입니다. 거의 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86f4358c15362241dbcffa86b5cbac6283d93743" translate="yes" xml:space="preserve">
          <source>The number of data bits in each character is 7. It is used for true ASCII. It generally only makes sense with older equipment such as teleprinters.</source>
          <target state="translated">각 문자의 데이터 비트 수는 7입니다. 실제 ASCII에 사용됩니다. 일반적으로 텔레 프린터와 같은 구형 장비에서만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="26fa94e8f86ff6d43c1557473bd35c3920a5f60f" translate="yes" xml:space="preserve">
          <source>The number of data bits in each character is 8. It is used for most kinds of data, as this size matches the size of a byte. It is almost universally used in newer applications.</source>
          <target state="translated">각 문자의 데이터 비트 수는 8입니다.이 크기는 바이트 크기와 일치하므로 대부분의 종류의 데이터에 사용됩니다. 최신 응용 프로그램에서 거의 보편적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eecccec71a456acf84f3b5f880cdaf53d5e2ef81" translate="yes" xml:space="preserve">
          <source>The number of data entries in the model.</source>
          <target state="translated">모델의 데이터 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="cfe7093f06cd47d88caef2f807f2860660047847" translate="yes" xml:space="preserve">
          <source>The number of data points in the series.</source>
          <target state="translated">시리즈의 데이터 포인트 수입니다.</target>
        </trans-unit>
        <trans-unit id="a7b4b3b08cfb01f6989b45bd0792401d09b05b83" translate="yes" xml:space="preserve">
          <source>The number of different colors available for the paint device. See also &lt;a href=&quot;qpaintdevice#colorCount&quot;&gt;colorCount&lt;/a&gt;().</source>
          <target state="translated">페인트 장치에 사용할 수있는 다양한 색상 수입니다. &lt;a href=&quot;qpaintdevice#colorCount&quot;&gt;colorCount&lt;/a&gt; () 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="71e8d85d7c0fc98bf5fa9a5d8215984ccacfba28" translate="yes" xml:space="preserve">
          <source>The number of elements in the model can be obtained from its &lt;a href=&quot;qml-qtqml-models-listmodel#count-prop&quot;&gt;count&lt;/a&gt; property. A number of familiar methods are also provided to manipulate the contents of the model, including &lt;a href=&quot;qml-qtqml-models-listmodel#append-method&quot;&gt;append()&lt;/a&gt;, &lt;a href=&quot;qml-qtqml-models-listmodel#insert-method&quot;&gt;insert()&lt;/a&gt;, &lt;a href=&quot;qml-qtqml-models-listmodel#move-method&quot;&gt;move()&lt;/a&gt;, &lt;a href=&quot;qml-qtqml-models-listmodel#remove-method&quot;&gt;remove()&lt;/a&gt; and &lt;a href=&quot;qml-qtqml-models-listmodel#set-method&quot;&gt;set()&lt;/a&gt;. These methods accept dictionaries as their arguments; these are translated to &lt;a href=&quot;qml-qtqml-models-listelement&quot;&gt;ListElement&lt;/a&gt; objects by the model.</source>
          <target state="translated">모델의 요소 수는 &lt;a href=&quot;qml-qtqml-models-listmodel#count-prop&quot;&gt;count&lt;/a&gt; 속성 에서 얻을 수 있습니다. &lt;a href=&quot;qml-qtqml-models-listmodel#append-method&quot;&gt;append ()&lt;/a&gt; , &lt;a href=&quot;qml-qtqml-models-listmodel#insert-method&quot;&gt;insert ()&lt;/a&gt; , &lt;a href=&quot;qml-qtqml-models-listmodel#move-method&quot;&gt;move ()&lt;/a&gt; , &lt;a href=&quot;qml-qtqml-models-listmodel#remove-method&quot;&gt;remove ()&lt;/a&gt; 및 &lt;a href=&quot;qml-qtqml-models-listmodel#set-method&quot;&gt;set ()을&lt;/a&gt; 포함하여 모델의 내용을 조작하는 여러 가지 친숙한 방법도 제공됩니다 . 이 방법들은 사전을 인수로 받아들입니다. 이들은 모델에 의해 &lt;a href=&quot;qml-qtqml-models-listelement&quot;&gt;ListElement&lt;/a&gt; 객체로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="d713739e716ad1e21aefe0c120f013a9ebd34808" translate="yes" xml:space="preserve">
          <source>The number of frames per second is 0 if the current document is not animated.</source>
          <target state="translated">현재 문서에 애니메이션이 적용되지 않은 경우 초당 프레임 수는 0입니다.</target>
        </trans-unit>
        <trans-unit id="0450b49d5355e3104eafb20c359fcc410c02d66d" translate="yes" xml:space="preserve">
          <source>The number of frames prepared without blocking in range 1 - 4. The default value is 2. Present() starts blocking after queuing 3 frames (regardless of &lt;code&gt;QT_D3D_BUFFER_COUNT&lt;/code&gt;), unless the waitable object is in use. Every additional frame increases GPU resource usage since geometry and constant buffer data needs to be duplicated, and involves more bookkeeping on the CPU side.</source>
          <target state="translated">1-4 범위에서 차단하지 않고 준비된 프레임 수입니다. 기본값은 2입니다. Present ()는 대기 가능한 객체를 사용하지 않는 한 &lt;code&gt;QT_D3D_BUFFER_COUNT&lt;/code&gt; 에 관계없이 3 개의 프레임을 큐잉 한 후 차단을 시작 합니다. 지오메트리 및 상수 버퍼 데이터를 복제해야하고 CPU 측에 더 많은 부기를 포함하기 때문에 모든 추가 프레임은 GPU 리소스 사용량을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="639cca155f18d916d8a83f081a6ae45dd473083e" translate="yes" xml:space="preserve">
          <source>The number of items created by a Repeater is held by its &lt;a href=&quot;qml-qtquick-repeater#count-prop&quot;&gt;count&lt;/a&gt; property. It is not possible to set this property to determine the number of items to be created. Instead, as in the above example, we use an integer as the model.</source>
          <target state="translated">Repeater가 작성한 항목 수는 &lt;a href=&quot;qml-qtquick-repeater#count-prop&quot;&gt;count&lt;/a&gt; 특성에 의해 유지됩니다 . 작성할 항목 수를 판별하기 위해이 특성을 설정할 수 없습니다. 대신 위의 예와 같이 정수를 모델로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8dfcb42e5b8fa35b579d4ee32dcbf4c8ccc8e9f8" translate="yes" xml:space="preserve">
          <source>The number of items currently pushed onto the stack.</source>
          <target state="translated">스택에 현재 푸시 된 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="d4022de6c3cb01a1831af34a9d8b2d6735044d85" translate="yes" xml:space="preserve">
          <source>The number of items in a list is given by &lt;a href=&quot;qtextlist#count&quot;&gt;count&lt;/a&gt;(). Each item can be obtained by its index in the list with the &lt;a href=&quot;qtextlist#item&quot;&gt;item&lt;/a&gt;() function. Similarly, the index of a given item can be found with &lt;a href=&quot;qtextlist#itemNumber&quot;&gt;itemNumber&lt;/a&gt;(). The text of each item can be found with the &lt;a href=&quot;qtextlist#itemText&quot;&gt;itemText&lt;/a&gt;() function.</source>
          <target state="translated">목록의 항목 수는 &lt;a href=&quot;qtextlist#count&quot;&gt;개수&lt;/a&gt; ()로 제공됩니다. 각 항목은 &lt;a href=&quot;qtextlist#item&quot;&gt;item&lt;/a&gt; () 함수 를 사용하여 목록의 색인으로 얻을 수 있습니다 . 마찬가지로, 주어진 항목의 색인은 &lt;a href=&quot;qtextlist#itemNumber&quot;&gt;itemNumber&lt;/a&gt; () 로 찾을 수 있습니다 . 각 항목의 텍스트는 &lt;a href=&quot;qtextlist#itemText&quot;&gt;itemText&lt;/a&gt; () 함수 로 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3b0ec35c37c9bedffdb792ad75088830399024d2" translate="yes" xml:space="preserve">
          <source>The number of items in the array.</source>
          <target state="translated">배열의 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="092cefcce73e0324a4ecca8231916e0190c8849a" translate="yes" xml:space="preserve">
          <source>The number of items in the model. This property is readonly.</source>
          <target state="translated">모델의 항목 수입니다. 이 속성은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="3d1c8f5d364d44038430ab57ec1dc17d8c069a69" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to wait before opening a submenu (256 on Windows, 96 on Motif).</source>
          <target state="translated">하위 메뉴를 열기 전에 대기 할 시간 (밀리 초)입니다 (Windows의 경우 256, Motif의 경우 96).</target>
        </trans-unit>
        <trans-unit id="554d6ef9863a27e419d400ed7f76158bfa73f9f9" translate="yes" xml:space="preserve">
          <source>The number of milliseconds to wait before opening a submenu.</source>
          <target state="translated">하위 메뉴를 열기 전에 대기 할 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="1112f97c71c22d8337408ea4cf7182d5538c000e" translate="yes" xml:space="preserve">
          <source>The number of minor tick marks on the axis. This indicates how many grid lines are drawn between major ticks on the chart. Labels are not drawn for minor ticks. The default value is 0.</source>
          <target state="translated">축의 작은 눈금 표시 수입니다. 차트의 주요 눈금 사이에 몇 개의 눈금 선이 그려 졌는지를 나타냅니다. 작은 눈금에는 레이블이 그려지지 않습니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="19b4d35c613ce31fea917373cc3c9af1ce57887f" translate="yes" xml:space="preserve">
          <source>The number of minor tick marks on the axis. This indicates how many grid lines are drawn between major ticks on the chart. Labels are not drawn for minor ticks. The default value is 0. Set the value to -1 and the number of grid lines between major ticks will be calculated automatically.</source>
          <target state="translated">축의 작은 눈금 표시 수입니다. 차트의 주요 눈금 사이에 몇 개의 눈금 선이 그려 졌는지를 나타냅니다. 작은 눈금에는 레이블이 그려지지 않습니다. 기본값은 0입니다. 값을 -1로 설정하면 주요 눈금 사이의 그리드 선 수가 자동으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="ad784c55393b36ab6130bc69b11c4d382077c1e8" translate="yes" xml:space="preserve">
          <source>The number of objects and bindings in the delegate has a direct effect on the flicking performance of the view when &lt;a href=&quot;qml-qtquick-pathview#pathItemCount-prop&quot;&gt;pathItemCount&lt;/a&gt; is specified. If at all possible, place functionality that is not needed for the normal display of the delegate in a &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; which can load additional components when needed.</source>
          <target state="translated">대리자의 개체 및 바인딩 수는 &lt;a href=&quot;qml-qtquick-pathview#pathItemCount-prop&quot;&gt;pathItemCount&lt;/a&gt; 가 지정된 경우보기의 깜박임 성능에 직접적인 영향을 미칩니다 . 가능한 경우 &lt;a href=&quot;qml-qtquick-loader&quot;&gt;로더에&lt;/a&gt; 델리게이트를 정상적으로 표시하는 데 필요하지 않은 기능을 필요한 경우 추가 구성 요소를로드 할 수 있는 로더에 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="d35ab879dd0fc090c9fa1969d326da7fc6781555" translate="yes" xml:space="preserve">
          <source>The number of objects and bindings in the delegate has a direct effect on the flicking performance of the view. If at all possible, place functionality that is not needed for the normal display of the delegate in a &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; which can load additional components when needed.</source>
          <target state="translated">델리게이트의 객체 및 바인딩 수는 뷰의 깜박임 성능에 직접적인 영향을 미칩니다. 가능한 경우 &lt;a href=&quot;qml-qtquick-loader&quot;&gt;로더에&lt;/a&gt; 델리게이트를 정상적으로 표시하는 데 필요하지 않은 기능을 필요한 경우 추가 구성 요소를로드 할 수 있는 로더에 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="a6d78243d246f165b37b9b3d714b1d26e5b07a4c" translate="yes" xml:space="preserve">
          <source>The number of objects the Instantiator is currently managing.</source>
          <target state="translated">Instantiator가 현재 관리하고있는 개체 수입니다.</target>
        </trans-unit>
        <trans-unit id="7d0e7d6e5a68615009a45ed2865fad3f64da1aa8" translate="yes" xml:space="preserve">
          <source>The number of physical pixels per millimeter.</source>
          <target state="translated">밀리미터 당 실제 픽셀 수입니다.</target>
        </trans-unit>
        <trans-unit id="a58414bd22062ad73cef816bb23073db7f7af61b" translate="yes" xml:space="preserve">
          <source>The number of pixels between notches.</source>
          <target state="translated">노치 사이의 픽셀 수입니다.</target>
        </trans-unit>
        <trans-unit id="979f13e43d50059f96a7f0ec27f8b71d06fb4886" translate="yes" xml:space="preserve">
          <source>The number of rows in the array.</source>
          <target state="translated">배열의 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="e6a2eb65a4be0164e209ea432f686910e2b9a9b3" translate="yes" xml:space="preserve">
          <source>The number of rows in the data array.</source>
          <target state="translated">데이터 배열의 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="83b0be21c420d48be8d435df3193f2fd823436da" translate="yes" xml:space="preserve">
          <source>The number of rows in the table can be found with &lt;a href=&quot;qtablewidget#rowCount&quot;&gt;rowCount&lt;/a&gt;(), and the number of columns with &lt;a href=&quot;qtablewidget#columnCount&quot;&gt;columnCount&lt;/a&gt;(). The table can be cleared with the &lt;a href=&quot;qtablewidget#clear&quot;&gt;clear&lt;/a&gt;() function.</source>
          <target state="translated">테이블의 행 수는 &lt;a href=&quot;qtablewidget#rowCount&quot;&gt;rowCount&lt;/a&gt; ()로, 열 수는 &lt;a href=&quot;qtablewidget#columnCount&quot;&gt;columnCount&lt;/a&gt; () 로 찾을 수 있습니다 . &lt;a href=&quot;qtablewidget#clear&quot;&gt;clear&lt;/a&gt; () 함수를 사용하여 테이블을 지울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ba8cc0fdcf4b62f67bc9986111e4e5e6dc9285a" translate="yes" xml:space="preserve">
          <source>The number of rows of the model that are mapped as the data for a pie series. The default value is -1 (number limited by the number of rows in the model).</source>
          <target state="translated">파이 계열의 데이터로 매핑 된 모델의 행 수입니다. 기본값은 -1입니다 (숫자는 모델의 행 수로 제한됨).</target>
        </trans-unit>
        <trans-unit id="22890f980bc3bc92a0259a76aefffb041b570053" translate="yes" xml:space="preserve">
          <source>The number of rows of the model that are mapped as the data for series. The default value is -1 (the number is limited by the number of rows in the model).</source>
          <target state="translated">계열의 데이터로 매핑 된 모델의 행 수입니다. 기본값은 -1입니다 (숫자는 모델의 행 수에 의해 제한됨).</target>
        </trans-unit>
        <trans-unit id="8e8aa3777340acbfba96473f34679e60dae3da59" translate="yes" xml:space="preserve">
          <source>The number of rows of the model that are mapped as the data for the bar series. The default value is -1 (number limited to the number of rows in the model).</source>
          <target state="translated">막대 계열의 데이터로 맵핑 된 모델의 행 수입니다. 기본값은 -1입니다 (숫자는 모델의 행 수로 제한됨).</target>
        </trans-unit>
        <trans-unit id="c3f0e4116acc040e7b5a1a5ec8f58b73009a9de2" translate="yes" xml:space="preserve">
          <source>The number of rows of the model that are mapped as the data for the box plot series.</source>
          <target state="translated">상자 그림 시리즈의 데이터로 매핑 된 모델의 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="492b4be784ab19898e7d0e822492dddc55e09e16" translate="yes" xml:space="preserve">
          <source>The number of samples used in multisample antialiasing when &lt;a href=&quot;qml-qtdatavisualization-abstractgraph3d#renderingMode-prop&quot;&gt;renderingMode&lt;/a&gt; is &lt;code&gt;RenderIndirect&lt;/code&gt;. When &lt;a href=&quot;qml-qtdatavisualization-abstractgraph3d#renderingMode-prop&quot;&gt;renderingMode&lt;/a&gt; is &lt;code&gt;RenderDirectToBackground&lt;/code&gt; or &lt;code&gt;RenderDirectToBackground_NoClear&lt;/code&gt;, this property value is read-only and returns the number of samples specified by the window surface format. Defaults to &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtdatavisualization-abstractgraph3d#renderingMode-prop&quot;&gt;renderingMode&lt;/a&gt; 가 &lt;code&gt;RenderIndirect&lt;/code&gt; 일 때 멀티 샘플 앤티 앨리어싱에 사용되는 샘플 수입니다 . 때 &lt;a href=&quot;qml-qtdatavisualization-abstractgraph3d#renderingMode-prop&quot;&gt;의 renderingMode가&lt;/a&gt; 있다 &lt;code&gt;RenderDirectToBackground&lt;/code&gt; 또는 &lt;code&gt;RenderDirectToBackground_NoClear&lt;/code&gt; ,이 속성 값은 읽기 전용 창 표면 형식에 의해 지정된 샘플의 수를 반환합니다. 기본값은 &lt;code&gt;4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="431a4f8d0fafb285d04af42d7255e24445085489" translate="yes" xml:space="preserve">
          <source>The number of segments on the axis. This indicates how many labels are drawn. The number of grid lines to be drawn is calculated with the following formula: &lt;code&gt;segments * subsegments + 1&lt;/code&gt;. The preset default is &lt;code&gt;5&lt;/code&gt;. The value cannot be below &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">축의 세그먼트 수입니다. 이것은 얼마나 많은 레이블이 그려 졌는지를 나타냅니다. 그릴 그리드 선 수는 다음 공식으로 계산됩니다 : &lt;code&gt;segments * subsegments + 1&lt;/code&gt; . 사전 설정 기본값은 &lt;code&gt;5&lt;/code&gt; 입니다. 값은 &lt;code&gt;1&lt;/code&gt; 미만일 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a1d1b45f7abe9b3c448201786cba8e5c83851ecd" translate="yes" xml:space="preserve">
          <source>The number of series added to the chart.</source>
          <target state="translated">차트에 추가 된 계열 수입니다.</target>
        </trans-unit>
        <trans-unit id="8e7ae4053c38fe01536587e40714cbcefc47257b" translate="yes" xml:space="preserve">
          <source>The number of slices in the series.</source>
          <target state="translated">시리즈의 슬라이스 수입니다.</target>
        </trans-unit>
        <trans-unit id="f6d9ccda80ae83ae7eb133cd4778c84b8f55c42f" translate="yes" xml:space="preserve">
          <source>The number of subsegments inside each segment on the axis. Grid lines are drawn between each subsegment, in addition to each segment. The preset default is &lt;code&gt;1&lt;/code&gt;. The value cannot be below &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">축의 각 세그먼트 내 하위 세그먼트 수입니다. 각 세그먼트 외에 각 하위 세그먼트 사이에 그리드 선이 그려집니다. 사전 설정 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다. 값은 &lt;code&gt;1&lt;/code&gt; 미만일 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2ff514ba82af94bbf5563e4f55bf4273b96ccf63" translate="yes" xml:space="preserve">
          <source>The number of swap chain buffers in range 2 - 4. The default value is 3.</source>
          <target state="translated">범위 2-4의 스왑 체인 버퍼 수 기본값은 3입니다.</target>
        </trans-unit>
        <trans-unit id="f27dd98426f7a08fa1b5f305fd46844127d4d710" translate="yes" xml:space="preserve">
          <source>The number of taps which have occurred within the time and space constraints to be considered a single gesture. For example, to detect a triple-tap, you can write:</source>
          <target state="translated">시간 및 공간 제한 내에서 발생한 탭 수는 단일 동작으로 간주됩니다. 예를 들어 트리플 탭을 감지하려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b76127adbbf3e9cc455f122c2c698985609941f7" translate="yes" xml:space="preserve">
          <source>The number of the day</source>
          <target state="translated">일수</target>
        </trans-unit>
        <trans-unit id="8ff0be4f2d9794921821de17f01d21a87bf48f37" translate="yes" xml:space="preserve">
          <source>The number of the month</source>
          <target state="translated">월수</target>
        </trans-unit>
        <trans-unit id="b62517ec87d67a01a3e238738d057198e0aec6a4" translate="yes" xml:space="preserve">
          <source>The number of the week this delegate represents.</source>
          <target state="translated">이 대리인이 나타내는 주 수입니다.</target>
        </trans-unit>
        <trans-unit id="bafda84d524d8489a20ac2b57c9fbf2818cb88ce" translate="yes" xml:space="preserve">
          <source>The number of the year</source>
          <target state="translated">연도의 수</target>
        </trans-unit>
        <trans-unit id="aaeec13b0090e734bf3d565b093e88b0ec57bc50" translate="yes" xml:space="preserve">
          <source>The number of tick marks on the axis.</source>
          <target state="translated">축의 눈금 수입니다.</target>
        </trans-unit>
        <trans-unit id="c562891120ad536aa3bf840cd6a1e859dc0b3acc" translate="yes" xml:space="preserve">
          <source>The number of tick marks on the axis. This indicates how many grid lines are drawn on the chart. The default value is 5, and the number cannot be less than 2.</source>
          <target state="translated">축의 눈금 수입니다. 차트에 몇 개의 눈금 선이 그려져 있는지 나타냅니다. 기본값은 5이며 숫자는 2보다 작을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4e0f371c3be6e053377ad371db3f0451639b63e8" translate="yes" xml:space="preserve">
          <source>The number of tick marks on the axis. This indicates how many grid lines are drawn on the chart. This value is read-only.</source>
          <target state="translated">축의 눈금 수입니다. 차트에 몇 개의 눈금 선이 그려져 있는지 나타냅니다. 이 값은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="4f7b73df18263747b2134c682a804ddfde26e5a1" translate="yes" xml:space="preserve">
          <source>The number of tracks on the album containing the media.</source>
          <target state="translated">미디어가 포함 된 앨범의 트랙 수입니다.</target>
        </trans-unit>
        <trans-unit id="d7e9a40e1048ee1b89ae1545dcd5ceb5e654e746" translate="yes" xml:space="preserve">
          <source>The number of values in the bar set.</source>
          <target state="translated">막대 세트의 값 수입니다.</target>
        </trans-unit>
        <trans-unit id="a7e450e8ee331a4452d07c56caf922bd1715bb29" translate="yes" xml:space="preserve">
          <source>The number of values of the box-and-whiskers item.</source>
          <target state="translated">상자 및 수염 항목의 값 수입니다.</target>
        </trans-unit>
        <trans-unit id="e2a792101225a903928b7c268e69feb35adb0b4f" translate="yes" xml:space="preserve">
          <source>The numbers of &lt;a href=&quot;qsignalblocker#reblock&quot;&gt;reblock&lt;/a&gt;() and unblock() calls are not counted, so every unblock() undoes any number of &lt;a href=&quot;qsignalblocker#reblock&quot;&gt;reblock&lt;/a&gt;() calls.</source>
          <target state="translated">의 숫자 &lt;a href=&quot;qsignalblocker#reblock&quot;&gt;reblock&lt;/a&gt; ) (모든 차단 해제는 임의의 수의 실행 취소 있도록 () 및 차단 해제는 () 호출은 계산되지 않습니다 &lt;a href=&quot;qsignalblocker#reblock&quot;&gt;reblock를&lt;/a&gt; ()를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="1650fb5feef46643155e9035e23ad6cd562d7f76" translate="yes" xml:space="preserve">
          <source>The numbers of reblock() and &lt;a href=&quot;qsignalblocker#unblock&quot;&gt;unblock&lt;/a&gt;() calls are not counted, so every reblock() undoes any number of &lt;a href=&quot;qsignalblocker#unblock&quot;&gt;unblock&lt;/a&gt;() calls.</source>
          <target state="translated">reblock () 및 &lt;a href=&quot;qsignalblocker#unblock&quot;&gt;unblock&lt;/a&gt; () 호출 수는 계산되지 않으므로 모든 reblock ()은 임의의 수의 &lt;a href=&quot;qsignalblocker#unblock&quot;&gt;unblock&lt;/a&gt; () 호출을 취소 합니다.</target>
        </trans-unit>
        <trans-unit id="8d154d28cce241422d3b0306031f45ded38a66d5" translate="yes" xml:space="preserve">
          <source>The object allocate space for</source>
          <target state="translated">객체는 공간을 할당합니다</target>
        </trans-unit>
        <trans-unit id="08b12fe7677bd7a1cd61075f9cd376ecf32c47c5" translate="yes" xml:space="preserve">
          <source>The object also has one signal, aboutToQuit(), which is the same as &lt;a href=&quot;qcoreapplication#aboutToQuit&quot;&gt;QCoreApplication::aboutToQuit()&lt;/a&gt;.</source>
          <target state="translated">이 객체에는 aboutToQuit () 신호도 있는데 이는 &lt;a href=&quot;qcoreapplication#aboutToQuit&quot;&gt;QCoreApplication :: aboutToQuit ()&lt;/a&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f60341fd0842c1f035c24a1d38b7be9897966d93" translate="yes" xml:space="preserve">
          <source>The object blocks input from other objects.</source>
          <target state="translated">객체는 다른 객체의 입력을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="4881199919720b970441bd3f11390bc4c8e5f423" translate="yes" xml:space="preserve">
          <source>The object can be moved.</source>
          <target state="translated">개체를 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c914d58256abb5135c2101e70cc5a32b34c576f9" translate="yes" xml:space="preserve">
          <source>The object can be resized, e.g. top-level windows.</source>
          <target state="translated">최상위 창과 같은 개체의 크기를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6adcb24c5f3d433b7d462254a271f3c0fde9d690" translate="yes" xml:space="preserve">
          <source>The object can handle data and files of the format specified in the value. The value has the format mime:extension:description. Multiple formats are separated by a semicolon.</source>
          <target state="translated">오브젝트는 값에 지정된 형식의 데이터 및 파일을 처리 할 수 ​​있습니다. 값은 mime : extension : description 형식입니다. 여러 형식은 세미콜론으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="77fa9d5682507f1eeed3a50fcd85c458366cbbfd" translate="yes" xml:space="preserve">
          <source>The object can receive focus. Only objects in the active window can receive focus.</source>
          <target state="translated">초점을 맞출 수 있습니다. 활성 창의 개체 만 포커스를받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fc8b7ab14886cd1928f59c171dcbce8a624eff0" translate="yes" xml:space="preserve">
          <source>The object can usually be edited, but is explicitly set to read-only.</source>
          <target state="translated">일반적으로 개체를 편집 할 수 있지만 명시 적으로 읽기 전용으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdd1687cbdef9a6c6804461437e4cb943a47cb3e" translate="yes" xml:space="preserve">
          <source>The object cannot accept input at the moment.</source>
          <target state="translated">현재 개체가 입력을 받아 들일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0b397cfe20aabda8c737c01e402b8e116110ff28" translate="yes" xml:space="preserve">
          <source>The object changes frequently and needs to be refreshed when accessing it.</source>
          <target state="translated">개체는 자주 변경되므로 액세스 할 때 새로 고쳐야합니다.</target>
        </trans-unit>
        <trans-unit id="9833b90f07361b082a3174240aca12c113c7c23b" translate="yes" xml:space="preserve">
          <source>The object containing the menu item subcontrol components. These subcontrols are used for normal menu items only, i.e. not for separators or scroll indicators.</source>
          <target state="translated">메뉴 항목 하위 제어 구성 요소를 포함하는 오브젝트입니다. 이 하위 컨트롤은 일반 메뉴 항목에만 사용됩니다 (예 : 구분 기호 또는 스크롤 표시기는 사용하지 않음).</target>
        </trans-unit>
        <trans-unit id="e4362b0cf3fa4b1ae599a860a4e5d467193dc0ef" translate="yes" xml:space="preserve">
          <source>The object declaration in a QML document defines what will be displayed in the visual scene. &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; provides the basic building blocks for all user interfaces, such as the objects for displaying images and text and for handling user input.</source>
          <target state="translated">QML 문서의 객체 선언은 시각적 장면에 표시 될 내용을 정의합니다. &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; 은 이미지와 텍스트를 표시하고 사용자 입력을 처리하기위한 개체와 같은 모든 사용자 인터페이스를위한 기본 구성 요소를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="92b65e2ef6a06967fb42d70d396607c9917f5aec" translate="yes" xml:space="preserve">
          <source>The object describes itself through speech or sound.</source>
          <target state="translated">물체는 말이나 소리를 통해 자신을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8a0cf8e6ce2754b6cca7332889c1e1c0f1b46777" translate="yes" xml:space="preserve">
          <source>The object displays scrolling contents, e.g. a log view.</source>
          <target state="translated">객체는 스크롤 내용 (예 : 로그보기)을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ed5ed55f364b7c96af22bd4a5ca1ea2dd641016d" translate="yes" xml:space="preserve">
          <source>The object displays the progress of an operation in progress.</source>
          <target state="translated">객체는 진행중인 작업의 진행률을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="73b28ec2f16a4137b8c48eb24d8532f000c37f2d" translate="yes" xml:space="preserve">
          <source>The object formats a frame</source>
          <target state="translated">객체는 프레임을 포맷</target>
        </trans-unit>
        <trans-unit id="67781750f82a34bbf14e2a8dfe0921fef222710d" translate="yes" xml:space="preserve">
          <source>The object formats a list</source>
          <target state="translated">객체는 목록의 형식을 지정합니다</target>
        </trans-unit>
        <trans-unit id="5cbc64c12f12a77981a1a1a9056d3ac740dc3ae9" translate="yes" xml:space="preserve">
          <source>The object formats a single character</source>
          <target state="translated">객체는 단일 문자를 포맷</target>
        </trans-unit>
        <trans-unit id="e7953cf59993ac70dfe0b75fb18385f5a29ca57e" translate="yes" xml:space="preserve">
          <source>The object formats a text block</source>
          <target state="translated">객체는 텍스트 블록을 포맷</target>
        </trans-unit>
        <trans-unit id="0be1b58914c49d6a80ed9a2fbf6aadfe6cba2d86" translate="yes" xml:space="preserve">
          <source>The object has a text carret (and often implements the text interface).</source>
          <target state="translated">객체에는 텍스트 캐럿이 있으며 텍스트 인터페이스를 구현하는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="cb41a94ce183825fabfad03c26725e21410e1b45" translate="yes" xml:space="preserve">
          <source>The object has auto-completion, for example in line edits or combo boxes.</source>
          <target state="translated">개체에 자동 편집 기능이 있습니다 (예 : 줄 편집 또는 콤보 상자).</target>
        </trans-unit>
        <trans-unit id="7e2638e25adb7a3df106ef54ab03bfd07d498c77" translate="yes" xml:space="preserve">
          <source>The object has keyboard focus.</source>
          <target state="translated">객체에 키보드 포커스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f95fe8ecdf57f9f04226c5d081d4b8ada5a6ca77" translate="yes" xml:space="preserve">
          <source>The object has multiple lines of text (word wrap), as opposed to a single line.</source>
          <target state="translated">개체에는 한 줄이 아니라 여러 줄의 텍스트 (단어 줄 바꿈)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eec1d4b383cb61e23eb5d5bd7dd2c6750457d30" translate="yes" xml:space="preserve">
          <source>The object has no role. This usually indicates an invalid object.</source>
          <target state="translated">개체는 역할이 없습니다. 일반적으로 유효하지 않은 개체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3f2277f8930041609314b3af9c20ffd928c860ed" translate="yes" xml:space="preserve">
          <source>The object has text which can be selected. This is different from selectable which refers to the object's children.</source>
          <target state="translated">개체에는 선택할 수있는 텍스트가 있습니다. 이것은 객체의 자식을 나타내는 선택 가능과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3ff196c140e0459d370a8f8b78c9d2a9cdf61c82" translate="yes" xml:space="preserve">
          <source>The object hierarchy is created, and constant values are assigned.</source>
          <target state="translated">객체 계층이 생성되고 상수 값이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="8702044014de53e76ecc40149e9fb20f198ac40c" translate="yes" xml:space="preserve">
          <source>The object is a line edit that is the input for search queries.</source>
          <target state="translated">개체는 검색 쿼리에 대한 입력 인 줄 편집입니다.</target>
        </trans-unit>
        <trans-unit id="1e43afcb12e42ee4dd495a2e950b8d94e0d59528" translate="yes" xml:space="preserve">
          <source>The object is a password field, e.g. a line edit for entering a Password.</source>
          <target state="translated">객체는 비밀번호 필드입니다 (예 : 비밀번호 입력을위한 행 편집).</target>
        </trans-unit>
        <trans-unit id="334ce3a152fe10e5917713e50459b63558ef779c" translate="yes" xml:space="preserve">
          <source>The object is checkable.</source>
          <target state="translated">개체를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72da1947e21f5e916d924e32c8e3490db8f73cbc" translate="yes" xml:space="preserve">
          <source>The object is clipped by the visible area. Objects that are off screen are also invisible.</source>
          <target state="translated">보이는 영역에 의해 개체가 잘립니다. 화면 밖에있는 개체도 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a315f865b8947718ee97d27d6c5418907bdfb71" translate="yes" xml:space="preserve">
          <source>The object is collapsed, e.g. a closed listview item, or an iconified window.</source>
          <target state="translated">닫힌 목록보기 항목 또는 아이콘 화 된 창과 같이 개체가 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="4e17fb98e50677547cca9ce81d49950fd1d9bfde" translate="yes" xml:space="preserve">
          <source>The object is converted to a &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt;. Each property is converted to a &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;, recursively; cyclic references are not followed.</source>
          <target state="translated">오브젝트가 &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; 로 변환됩니다 . 각 속성은 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 로 재귀 적으로 변환됩니다 . 순환 참조는 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6732797a6aacd1c20a9b5e1e680ba505beb43b58" translate="yes" xml:space="preserve">
          <source>The object is expandable, mostly used for cells in a tree view.</source>
          <target state="translated">개체는 확장 가능하며 주로 트리 뷰의 셀에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f7e44f386163e5ae47dea9500052c82ea00fd28" translate="yes" xml:space="preserve">
          <source>The object is expanded, currently its children are visible.</source>
          <target state="translated">개체가 확장되어 현재 자식이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7ed4c0740a1146f99fb42b57cde0a6afd7554ea9" translate="yes" xml:space="preserve">
          <source>The object is fully created and can be accessed by calling &lt;a href=&quot;qqmlincubator#object&quot;&gt;object&lt;/a&gt;().</source>
          <target state="translated">객체는 완전히 생성되며 &lt;a href=&quot;qqmlincubator#object&quot;&gt;object&lt;/a&gt; () 를 호출하여 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72996d39ead105fcc0556570ad7a0a37c9222ed5" translate="yes" xml:space="preserve">
          <source>The object is in the process of being created.</source>
          <target state="translated">개체를 만드는 중입니다.</target>
        </trans-unit>
        <trans-unit id="5632603ecdcfa000659ee8b38cb3cc97d0d1eba3" translate="yes" xml:space="preserve">
          <source>The object is linked and has been visited.</source>
          <target state="translated">개체가 연결되어 방문했습니다.</target>
        </trans-unit>
        <trans-unit id="d7514ecb67352280f9223439a4419fdac0b3953b" translate="yes" xml:space="preserve">
          <source>The object is linked to another object, e.g. a hyperlink.</source>
          <target state="translated">객체는 다른 객체, 예를 들어 하이퍼 링크에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="a4822af6c160c99dc50d8f071afe338919843b33" translate="yes" xml:space="preserve">
          <source>The object is moved to another thread. This is the last event sent to this object in the previous thread. See &lt;a href=&quot;qobject#moveToThread&quot;&gt;QObject::moveToThread&lt;/a&gt;().</source>
          <target state="translated">개체가 다른 스레드로 이동되었습니다. 이전 스레드에서이 객체로 전송 된 마지막 이벤트입니다. &lt;a href=&quot;qobject#moveToThread&quot;&gt;QObject :: moveToThread&lt;/a&gt; ()를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="69567fa0b9a96c21de070fe7b7d849b7f552b63c" translate="yes" xml:space="preserve">
          <source>The object is no longer valid (because it has been deleted).</source>
          <target state="translated">개체가 삭제되었으므로 더 이상 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b0f9ac0c0ac59d5931c4b8aa5f6b2c44e89c52bf" translate="yes" xml:space="preserve">
          <source>The object is not visible to the user.</source>
          <target state="translated">개체가 사용자에게 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24a53f55bd98da338964e9775e3b25b72c9f9c34" translate="yes" xml:space="preserve">
          <source>The object is owned by C++ code and QML will never delete it. The JavaScript destroy() method cannot be used on these objects. This option is similar to &lt;a href=&quot;https://doc.qt.io/qt-5.13/qscriptengine.html#ValueOwnership-enum&quot;&gt;QScriptEngine::QtOwnership&lt;/a&gt;.</source>
          <target state="translated">오브젝트는 C ++ 코드가 소유하며 QML은이를 삭제하지 않습니다. 이러한 객체에는 JavaScript destroy () 메서드를 사용할 수 없습니다. 이 옵션은 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qscriptengine.html#ValueOwnership-enum&quot;&gt;QScriptEngine :: QtOwnership&lt;/a&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="cc86fa6f3c9d1cb2047fdca3f8a6491e727bd009" translate="yes" xml:space="preserve">
          <source>The object is owned by JavaScript. When the object is returned to QML as the return value of a method call, QML will track it and delete it if there are no remaining JavaScript references to it and it has no &lt;a href=&quot;qobject#parent&quot;&gt;QObject::parent&lt;/a&gt;(). An object tracked by one &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; will be deleted during that &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt;'s destructor. Thus, JavaScript references between objects with JavaScriptOwnership from two different engines will not be valid if one of these engines is deleted. This option is similar to &lt;a href=&quot;https://doc.qt.io/qt-5.13/qscriptengine.html#ValueOwnership-enum&quot;&gt;QScriptEngine::ScriptOwnership&lt;/a&gt;.</source>
          <target state="translated">객체는 JavaScript가 소유합니다. 메소드 호출의 리턴 값으로 오브젝트가 QML에 리턴 될 때, QML은 오브젝트에 대한 나머지 JavaScript 참조가없고 &lt;a href=&quot;qobject#parent&quot;&gt;QObject :: parent&lt;/a&gt; () 가없는 경우이를 추적하고 삭제합니다 . 하나의 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine에&lt;/a&gt; 의해 추적 된 오브젝트 는 해당 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt; 의 소멸자 중에 삭제됩니다 . 따라서 두 엔진 중 하나에서 JavaScriptOwnership이있는 객체 간의 JavaScript 참조는 이러한 엔진 중 하나가 삭제되면 유효하지 않습니다. 이 옵션은 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qscriptengine.html#ValueOwnership-enum&quot;&gt;QScriptEngine :: ScriptOwnership&lt;/a&gt; 과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="517d5f86f04dfcc83d7f9a31b88457a05e4f0b3a" translate="yes" xml:space="preserve">
          <source>The object is passed in the</source>
          <target state="translated">객체는</target>
        </trans-unit>
        <trans-unit id="f2af81a26ffd90e96852cf549aa10b742228ff1b" translate="yes" xml:space="preserve">
          <source>The object is pressed.</source>
          <target state="translated">개체가 눌 렸습니다.</target>
        </trans-unit>
        <trans-unit id="7ee37cb4994912cc6906dd5531d2a8c45a650f6d" translate="yes" xml:space="preserve">
          <source>The object is selectable.</source>
          <target state="translated">객체를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74e485ec7757cde78c6ba032571df9501b8a567e" translate="yes" xml:space="preserve">
          <source>The object is selected, this is independent of text selection.</source>
          <target state="translated">객체가 선택되며 텍스트 선택과 무관합니다.</target>
        </trans-unit>
        <trans-unit id="3517c3ceafc7031d57dc8acc9e29d1e2d9d49b5e" translate="yes" xml:space="preserve">
          <source>The object is the active window or the active sub-element in a container (that would get focus when focusing the container).</source>
          <target state="translated">객체는 컨테이너의 활성 창 또는 활성 하위 요소입니다 (컨테이너에 초점을 맞출 때 포커스가 있음).</target>
        </trans-unit>
        <trans-unit id="e52abd9ab7c4a87972ed8c9454c3c24be38d6ee3" translate="yes" xml:space="preserve">
          <source>The object is unavailable to the user, e.g. a disabled widget.</source>
          <target state="translated">비활성화 된 위젯과 같이 사용자가 오브젝트를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bb0f58686cf9c24bdcf8a9c65692f341c2c5e9bd" translate="yes" xml:space="preserve">
          <source>The object mesh set via the &lt;a href=&quot;qabstract3dseries#mesh-prop&quot;&gt;QAbstract3DSeries::mesh&lt;/a&gt; property defines the selection pointer shape in a surface series.</source>
          <target state="translated">&lt;a href=&quot;qabstract3dseries#mesh-prop&quot;&gt;QAbstract3DSeries :: mesh&lt;/a&gt; 속성을 통해 설정된 객체 메시 는 표면 시리즈에서 선택 포인터 모양을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="be2b7826cb0256c457f4458c7d6b49197bc293e3" translate="yes" xml:space="preserve">
          <source>The object needs to fill in its geometry information (&lt;a href=&quot;qscrollprepareevent&quot;&gt;QScrollPrepareEvent&lt;/a&gt;).</source>
          <target state="translated">오브젝트는 지오메트리 정보 ( &lt;a href=&quot;qscrollprepareevent&quot;&gt;QScrollPrepareEvent&lt;/a&gt; )를 채워야 합니다.</target>
        </trans-unit>
        <trans-unit id="2aa662de20cec92e87f61c5e558814589b56efcd" translate="yes" xml:space="preserve">
          <source>The object needs to scroll to the supplied position (&lt;a href=&quot;qscrollevent&quot;&gt;QScrollEvent&lt;/a&gt;).</source>
          <target state="translated">제공된 위치 ( &lt;a href=&quot;qscrollevent&quot;&gt;QScrollEvent&lt;/a&gt; )로 오브젝트를 스크롤해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5291d6aff00731ce983a25b6ac3d06c8b05dacd6" translate="yes" xml:space="preserve">
          <source>The object no longer exists.</source>
          <target state="translated">개체가 더 이상 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98e6a0e27062a5d1e8513f36e893eb90b7609560" translate="yes" xml:space="preserve">
          <source>The object opens a popup.</source>
          <target state="translated">객체가 팝업을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="68b9e1dec1cbea4da9901191bd37acedb73018cf" translate="yes" xml:space="preserve">
          <source>The object passed must implement the &lt;a href=&quot;qmediabindableinterface&quot;&gt;QMediaBindableInterface&lt;/a&gt; interface.</source>
          <target state="translated">전달 된 오브젝트는 &lt;a href=&quot;qmediabindableinterface&quot;&gt;QMediaBindableInterface&lt;/a&gt; 인터페이스를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2749ffb2b69f0b9f10c7f8e05006062aa03abf2c" translate="yes" xml:space="preserve">
          <source>The object path points to an object that does not exist (&lt;code&gt;org.freedesktop.DBus.Error.UnknownObject&lt;/code&gt;)</source>
          <target state="translated">오브젝트 경로가 존재하지 않는 오브젝트를 가리 킵니다 ( &lt;code&gt;org.freedesktop.DBus.Error.UnknownObject&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f484b2f8a8fb570a81b872e78168771dd99c1371" translate="yes" xml:space="preserve">
          <source>The object path provided is invalid.</source>
          <target state="translated">제공된 개체 경로가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8454e7b179f6d6dc298df097cf8318a8229a42f2" translate="yes" xml:space="preserve">
          <source>The object produces sound when interacted with.</source>
          <target state="translated">객체는 상호 작용할 때 소리를냅니다.</target>
        </trans-unit>
        <trans-unit id="519488efc9912d2311a452ad772d00b590248a70" translate="yes" xml:space="preserve">
          <source>The object represents an adjustable value, e.g. sliders.</source>
          <target state="translated">객체는 슬라이더와 같은 조정 가능한 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="68ff8eb427553aa50d311c3ce1d87cab5c801dd1" translate="yes" xml:space="preserve">
          <source>The object represents the default button in a dialog.</source>
          <target state="translated">객체는 대화 상자의 기본 버튼을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="553c776ec8a6f7eca809a003098ef0c082b21886" translate="yes" xml:space="preserve">
          <source>The object represents the desktop or workspace.</source>
          <target state="translated">객체는 데스크탑 또는 작업 공간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="857c20993ab089ce311718bcbf9d9703e30830de" translate="yes" xml:space="preserve">
          <source>The object returned by this function is thread-safe and may be used in any thread without locks. It may also be copied and the resulting &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; will also access the operating system facilities, but they will not generate the same sequence.</source>
          <target state="translated">이 함수가 반환 한 객체는 스레드로부터 안전하며 잠금이없는 모든 스레드에서 사용할 수 있습니다. 또한 복사 될 수 있으며 결과 &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; 도 운영 체제 기능에 액세스하지만 동일한 순서를 생성하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="486adff21dc6179e0bf2969351bdb66a2ef273e8" translate="yes" xml:space="preserve">
          <source>The object returned can be any descendant, including itself.</source>
          <target state="translated">반환 된 객체는 자신을 포함하여 모든 자손 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa94ee59cf3f5fe5c9c75b60363acc4d3d1d626a" translate="yes" xml:space="preserve">
          <source>The object should call &lt;a href=&quot;qinputmethodqueryevent#setValue&quot;&gt;setValue&lt;/a&gt;() on the event to fill in the requested data before calling &lt;a href=&quot;qevent#accept&quot;&gt;accept&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qevent#accept&quot;&gt;수락&lt;/a&gt; ()을 호출하기 전에 요청 된 데이터를 채우려면 이벤트에서 객체가 &lt;a href=&quot;qinputmethodqueryevent#setValue&quot;&gt;setValue&lt;/a&gt; ()를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a7d07650234b85fbec6754de329932a1b6719e2d" translate="yes" xml:space="preserve">
          <source>The object summarizes the state of the window and should be treated with priority.</source>
          <target state="translated">개체는 창의 상태를 요약하며 우선 순위로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="6f7cf78da336d44bf1f179c09c56aa609e376699" translate="yes" xml:space="preserve">
          <source>The object supports extended selection.</source>
          <target state="translated">객체는 확장 된 선택을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="24d7ed8fb5c892e6f5f6ec3e723ac7ee4844ce37" translate="yes" xml:space="preserve">
          <source>The object supports multiple selected items.</source>
          <target state="translated">객체는 선택된 여러 항목을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2d79f318cbb7dfccf8f51a52e51ea34e5bbaac5d" translate="yes" xml:space="preserve">
          <source>The object to be updated.</source>
          <target state="translated">업데이트 할 개체입니다.</target>
        </trans-unit>
        <trans-unit id="5e4b3837e89d938ea62f910ad0fa6dce294f1586" translate="yes" xml:space="preserve">
          <source>The object will be created asynchronously.</source>
          <target state="translated">객체가 비동기 적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="214ade03e503fae795b985259a1a9e9f1b6746c7" translate="yes" xml:space="preserve">
          <source>The object will be created in the same context as the one in which the component was created. This function will always return null when called on components which were not created in QML.</source>
          <target state="translated">객체는 구성 요소가 작성된 것과 동일한 컨텍스트에서 작성됩니다. 이 함수는 QML에서 작성되지 않은 컴포넌트에서 호출 될 때 항상 널을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8e8cfd3bacf00334856790abccd004a964bbdf96" translate="yes" xml:space="preserve">
          <source>The object will be created synchronously.</source>
          <target state="translated">객체가 동 기적으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5841d2552b2c9e5075851f19e00532d4090c30f9" translate="yes" xml:space="preserve">
          <source>The object will be deleted after it has cleaned up (&lt;a href=&quot;qdeferreddeleteevent&quot;&gt;QDeferredDeleteEvent&lt;/a&gt;)</source>
          <target state="translated">정리 후 오브젝트가 삭제됩니다 ( &lt;a href=&quot;qdeferreddeleteevent&quot;&gt;QDeferredDeleteEvent&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="80ad2da8a80c230a5078b784e88e13e4bdc7e38f" translate="yes" xml:space="preserve">
          <source>The object will be deleted when control returns to the event loop. If the event loop is not running when this function is called (e.g. deleteLater() is called on an object before &lt;a href=&quot;qcoreapplication#exec&quot;&gt;QCoreApplication::exec&lt;/a&gt;()), the object will be deleted once the event loop is started. If deleteLater() is called after the main event loop has stopped, the object will not be deleted. Since Qt 4.8, if deleteLater() is called on an object that lives in a thread with no running event loop, the object will be destroyed when the thread finishes.</source>
          <target state="translated">제어가 이벤트 루프로 돌아 오면 오브젝트가 삭제됩니다. 이 함수가 호출 될 때 이벤트 루프가 실행 중이 아닌 경우 (예 : &lt;a href=&quot;qcoreapplication#exec&quot;&gt;QCoreApplication :: exec&lt;/a&gt; () 이전에 오브젝트에서 deleteLater ()가 호출 됨), 이벤트 루프가 시작되면 오브젝트가 삭제됩니다. 기본 이벤트 루프가 중지 된 후 deleteLater ()가 호출되면 객체가 삭제되지 않습니다. Qt 4.8부터 실행중인 이벤트 루프가없는 스레드에있는 객체에서 deleteLater ()를 호출하면 스레드가 완료 될 때 객체가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6c7329b367145649e655b5eb8fa62276ab3459b1" translate="yes" xml:space="preserve">
          <source>The object will report no match through the &lt;a href=&quot;qregularexpressionmatch#hasMatch&quot;&gt;hasMatch&lt;/a&gt;() and the &lt;a href=&quot;qregularexpressionmatch#hasPartialMatch&quot;&gt;hasPartialMatch&lt;/a&gt;() member functions.</source>
          <target state="translated">객체는 &lt;a href=&quot;qregularexpressionmatch#hasMatch&quot;&gt;hasMatch&lt;/a&gt; () 및 &lt;a href=&quot;qregularexpressionmatch#hasPartialMatch&quot;&gt;hasPartialMatch&lt;/a&gt; () 멤버 함수를 통해 일치하는 사항을보고하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="49a69657c4c58f8cb8bb1c3db646347365611b8e" translate="yes" xml:space="preserve">
          <source>The object's &lt;a href=&quot;qaccessible#Text-enum&quot;&gt;QAccessible::Description&lt;/a&gt; changed.</source>
          <target state="translated">개체의 &lt;a href=&quot;qaccessible#Text-enum&quot;&gt;QAccessible :: Description이&lt;/a&gt; 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="a90f06fbfc54e1a4d8a2af2b20830fa529a28554" translate="yes" xml:space="preserve">
          <source>The object's appearance changes frequently.</source>
          <target state="translated">개체의 모양이 자주 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="a1cc14451669fe1340173ace9727d2be3488eeee" translate="yes" xml:space="preserve">
          <source>The object's appearance is sensitive to the mouse cursor position.</source>
          <target state="translated">객체의 모양은 마우스 커서 위치에 민감합니다.</target>
        </trans-unit>
        <trans-unit id="36306b0cf8d702ef140dc0a86c356f106fb41a18" translate="yes" xml:space="preserve">
          <source>The object's check box is checked.</source>
          <target state="translated">개체의 확인란이 선택되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="420c00df68b4a04b4493b625789dcdce84f8f5eb" translate="yes" xml:space="preserve">
          <source>The object's signals this signal blocker was blocking prior to being moved to, if any, are unblocked</source>
          <target state="translated">이 신호 차단기가 이동하기 전에 차단 한 물체의 신호는 차단되지 않습니다</target>
        </trans-unit>
        <trans-unit id="e13e558fc1f2c740aa3a44e51518d724808a5ef0" translate="yes" xml:space="preserve">
          <source>The objects must have the attached &lt;a href=&quot;qml-qtwebchannel-webchannel#id-attached-prop&quot;&gt;id&lt;/a&gt; property set to an identifier, under which the object is then known on the HTML side.</source>
          <target state="translated">객체에는 첨부 된 &lt;a href=&quot;qml-qtwebchannel-webchannel#id-attached-prop&quot;&gt;id&lt;/a&gt; 속성이 식별자로 설정 되어 있어야하며 , 그 아래에서 객체는 HTML 측에서 알려집니다.</target>
        </trans-unit>
        <trans-unit id="1b39e18c763310f5fdd2a5388ba219c03473c8fa" translate="yes" xml:space="preserve">
          <source>The offline installer is available &lt;a href=&quot;https://www.qt.io/offline-installer&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">오프라인 설치 프로그램은 &lt;a href=&quot;https://www.qt.io/offline-installer&quot;&gt;여기에서&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ea4409ed34537dee3beb60d93328c2446afadc8" translate="yes" xml:space="preserve">
          <source>The offscreen surface is valid if the platform resources have been successfuly allocated.</source>
          <target state="translated">플랫폼 자원이 성공적으로 할당 된 경우 오프 스크린 화면이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="3d710c9ed41b09587bca5ef22b8c3c3290293b11" translate="yes" xml:space="preserve">
          <source>The offset and size arguments are specified in device independent pixels. The returned pixmap may be larger than the requested size when grabbing from a high-DPI screen. Call &lt;a href=&quot;qpixmap#devicePixelRatio&quot;&gt;QPixmap::devicePixelRatio&lt;/a&gt;() to determine if this is the case.</source>
          <target state="translated">오프셋 및 크기 인수는 장치 독립적 픽셀로 지정됩니다. 높은 DPI 화면에서 캡처 할 때 반환 된 픽스맵이 요청 된 크기보다 클 수 있습니다. &lt;a href=&quot;qpixmap#devicePixelRatio&quot;&gt;QPixmap :: devicePixelRatio&lt;/a&gt; ()를 호출 하여이 경우인지 판별하십시오.</target>
        </trans-unit>
        <trans-unit id="70c3e20d9dc160641da53e9e4f8cb57e7a3b0eef" translate="yes" xml:space="preserve">
          <source>The offset between the tickmarks and the slider.</source>
          <target state="translated">눈금과 슬라이더 사이의 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="661a884d57e62052a9e8970fdb6f60e8c07a7d5f" translate="yes" xml:space="preserve">
          <source>The offset is given in device coordinates, which means it is unaffected by scale.</source>
          <target state="translated">오프셋은 장치 좌표로 제공되며 이는 스케일의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47b934d51dc6e8ffc126a6a48df273d8fc66ddcb" translate="yes" xml:space="preserve">
          <source>The offset is the sum of all the methods in the class's superclasses (which is always positive since &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; has the deleteLater() slot and a destroyed() signal).</source>
          <target state="translated">오프셋은 클래스의 슈퍼 클래스에있는 모든 메소드의 합입니다 ( &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 에 deleteLater () 슬롯과 destroyed () 신호가 있으므로 항상 양수입니다 ).</target>
        </trans-unit>
        <trans-unit id="e8c47dd654ff2895b141c35fb00255cf7ae38e8d" translate="yes" xml:space="preserve">
          <source>The offset is the sum of all the properties in the class's superclasses (which is always positive since &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; has the name() property).</source>
          <target state="translated">오프셋은 클래스의 슈퍼 클래스에있는 모든 속성의 합계입니다 ( &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 에 name () 속성이 있으므로 항상 양수 임).</target>
        </trans-unit>
        <trans-unit id="29e1db7f66dc9040990995b866b94d84975040f9" translate="yes" xml:space="preserve">
          <source>The offset measures the total change in position of the user's input covered by the gesture on the input device.</source>
          <target state="translated">오프셋은 입력 장치상의 제스처에 의해 커버되는 사용자 입력의 위치에서의 총 변화를 측정한다.</target>
        </trans-unit>
        <trans-unit id="044aff06a7eb66865f43840bdfd7dfb175868dd5" translate="yes" xml:space="preserve">
          <source>The offset specifies how far along the path the items are from their initial positions. This is a real number that ranges from 0.0 to the count of items in the model.</source>
          <target state="translated">오프셋은 항목이 초기 위치에서 얼마나 멀리 떨어져 있는지 지정합니다. 0.0에서 모델의 항목 수까지의 실수입니다.</target>
        </trans-unit>
        <trans-unit id="318eafc4cae0216b6f83b54dd9e4bb348cc809e7" translate="yes" xml:space="preserve">
          <source>The old access point may be closed in the process if there are no other network sessions for it. Therefore any open socket that still uses the old access point may become unusable and should be closed before completing the migration.</source>
          <target state="translated">다른 액세스 세션이없는 경우 프로세스에서 이전 액세스 포인트가 닫힐 수 있습니다. 따라서 여전히 기존 액세스 포인트를 사용하는 열린 소켓은 사용할 수 없게 될 수 있으므로 마이그레이션을 완료하기 전에 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="e773d61a89580dfd752f3a493bd535f0ee4dabd6" translate="yes" xml:space="preserve">
          <source>The old position is accessible through &lt;a href=&quot;qmoveevent#oldPos&quot;&gt;QMoveEvent::oldPos&lt;/a&gt;().</source>
          <target state="translated">이전 위치는 &lt;a href=&quot;qmoveevent#oldPos&quot;&gt;QMoveEvent :: oldPos&lt;/a&gt; ()를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5df7c78d0f1db3a033b0a91ca8960e55de84b141" translate="yes" xml:space="preserve">
          <source>The oldest pixmaps (least recently accessed in the cache) are deleted when more space is needed.</source>
          <target state="translated">더 많은 공간이 필요할 때 가장 오래된 픽스맵 (캐시에서 가장 최근에 액세스 한 것)이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="247b508919fb5f44113f696f7e8434f84af7ba43" translate="yes" xml:space="preserve">
          <source>The online installer is available from the Qt &lt;a href=&quot;http://qt.io/download#&quot;&gt;Downloads&lt;/a&gt; page.</source>
          <target state="translated">온라인 설치 프로그램은 Qt &lt;a href=&quot;http://qt.io/download#&quot;&gt;다운로드&lt;/a&gt; 페이지에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f8bfb3de0bbc77e4fd256fc7c6d1d76194e6784b" translate="yes" xml:space="preserve">
          <source>The online plugin uses the tiled map classes, which caches tile data in heap memory and texture memory.</source>
          <target state="translated">온라인 플러그인은 타일 맵 클래스를 사용하여 타일 데이터를 힙 메모리 및 텍스처 메모리에 캐시합니다.</target>
        </trans-unit>
        <trans-unit id="a8d9989f922f1a957e994a25a3a72e39d775f6f1" translate="yes" xml:space="preserve">
          <source>The only behavioral difference is that this class sets the type properly.</source>
          <target state="translated">동작상의 유일한 차이점은이 클래스가 유형을 올바르게 설정한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ff2576cba9b0a8e4ef2e74f37f4b63ba885ff13" translate="yes" xml:space="preserve">
          <source>The only behavioural difference is that this class sets the type properly.</source>
          <target state="translated">동작상의 유일한 차이점은이 클래스가 유형을 올바르게 설정한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9ec55d1ca759b9dc6d7ecd7a1ccb549b5714c3c7" translate="yes" xml:space="preserve">
          <source>The only behavioural difference is that this class sets the type properly.&lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject::invokeMethod&lt;/a&gt;(backend(), &quot;calibrate&quot;);</source>
          <target state="translated">동작상의 유일한 차이점은이 클래스가 유형을 올바르게 설정한다는 것입니다. &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject :: invokeMethod&lt;/a&gt; (backend (), &quot;calibrate&quot;);</target>
        </trans-unit>
        <trans-unit id="44e47eb73293b1cb787437f112b186a0ee30e89f" translate="yes" xml:space="preserve">
          <source>The only cases in which the port may not be straightforward is if the old code relied on template specializations of the qLess() and/or the qSwap() functions, which were used internally by the implementations of the Qt algorithmic functions, but are instead ignored by the STL ones.</source>
          <target state="translated">포트가 간단하지 않은 유일한 경우는 이전 코드가 qLess () 및 / 또는 qSwap () 함수의 템플릿 전문화에 의존하고 Qt 알고리즘 함수의 구현에 의해 내부적으로 사용되었지만 대신 STL에 의해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2b719162f9966209c1b2d384b92f42eaaa670353" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qaccelerometerfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qaccelerometerreading&quot;&gt;QAccelerometerReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qaccelerometerfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터 기능 &lt;a href=&quot;qaccelerometerreading&quot;&gt;QAccelerometerReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9daef753da659b876478bd690eb87f4297b7c7e4" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qaltimeterfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qaltimeterreading&quot;&gt;QAltimeterReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이점은 &lt;a href=&quot;qaltimeterfilter#filter&quot;&gt;filter&lt;/a&gt; () 메소드에 &lt;a href=&quot;qaltimeterreading&quot;&gt;QSensorReading&lt;/a&gt; 대신 QAltimeterReading에 대한 포인터가 있다는 &lt;a href=&quot;qsensorreading&quot;&gt;점&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="578332dd25747baae70bc590caa6bdbdafd588ff" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qambientlightfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qambientlightreading&quot;&gt;QAmbientLightReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qambientlightfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터 기능 &lt;a href=&quot;qambientlightreading&quot;&gt;QAmbientLightReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73c1e9c50a61616056cfee5149abcd1d5aa1fe0d" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qambienttemperaturefilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qambienttemperaturereading&quot;&gt;QAmbientTemperatureReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이점은 &lt;a href=&quot;qambienttemperaturefilter#filter&quot;&gt;filter&lt;/a&gt; () 메소드에 &lt;a href=&quot;qambienttemperaturereading&quot;&gt;QSensorReading&lt;/a&gt; 대신 QAmbientTemperatureReading에 대한 포인터가 있다는 &lt;a href=&quot;qsensorreading&quot;&gt;점&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f552dd1b9446d511d56a28deef52d43d0c6f18d0" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qcompassfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qcompassreading&quot;&gt;QCompassReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qcompassfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qcompassreading&quot;&gt;QCompassReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a32c79221d53476c252c13b7620a9270327fabc4" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qdistancefilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qdistancereading&quot;&gt;QDistanceReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qdistancefilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qdistancereading&quot;&gt;QDistanceReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f5a6edd191292cd1e31a394295a9562f7d54accb" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qgyroscopefilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qgyroscopereading&quot;&gt;QGyroscopeReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qgyroscopefilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qgyroscopereading&quot;&gt;QGyroscopeReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0ec88a68b1a982fc1a077c01bce8f71daebb40ff" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qholsterfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qholsterreading&quot;&gt;QHolsterReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qholsterfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qholsterreading&quot;&gt;QHolsterReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e45937b1411421456b76fcbbd3eb61a0035b922b" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qhumidityfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qhumidityreading&quot;&gt;QHumidityReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qhumidityfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qhumidityreading&quot;&gt;QHumidityReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1940669079dbb950c31660aae3c8038ab90c3b3c" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qirproximityfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qirproximityreading&quot;&gt;QIRProximityReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qirproximityfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터 기능 &lt;a href=&quot;qirproximityreading&quot;&gt;QIRProximityReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab912ebebcd26bdef233ed6145710b63f9ef6798" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qlidfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qlidreading&quot;&gt;QLidReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qlidfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터 기능 &lt;a href=&quot;qlidreading&quot;&gt;QLidReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="adcedeb1ceaed42f0cb8e68e463822104a8c8ed8" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qlightfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qlightreading&quot;&gt;QLightReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qlightfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터 기능 &lt;a href=&quot;qlightreading&quot;&gt;QLightReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b43dad7308c5a1474ebcae75930c5ff5b0852862" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qmagnetometerfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qmagnetometerreading&quot;&gt;QMagnetometerReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qmagnetometerfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qmagnetometerreading&quot;&gt;QMagnetometerReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1f4a6e4835939ebb3998398dd8c46489894c70c" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qorientationfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qorientationreading&quot;&gt;QOrientationReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qorientationfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qorientationreading&quot;&gt;QOrientationReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="896534475aa06c2f4c42b04f400815614cafc831" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qpressurefilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qpressurereading&quot;&gt;QPressureReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qpressurefilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qpressurereading&quot;&gt;QPressureReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d45afc9c60460512dd51d4c0d873365a002eefb2" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qproximityfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qproximityreading&quot;&gt;QProximityReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qproximityfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qproximityreading&quot;&gt;QProximityReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="519a7730838dc15fa99523c85b8ebca7d34b3af5" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qrotationfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qrotationreading&quot;&gt;QRotationReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qrotationfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터를 갖추고 &lt;a href=&quot;qrotationreading&quot;&gt;QRotationReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a38e1513a22a76e73379117107a542ade6faac10" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qtapfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qtapreading&quot;&gt;QTapReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qtapfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터 기능 &lt;a href=&quot;qtapreading&quot;&gt;QTapReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c17ea8e32c391c45ba9f702b8c3851b72d6804f2" translate="yes" xml:space="preserve">
          <source>The only difference is that the &lt;a href=&quot;qtiltfilter#filter&quot;&gt;filter&lt;/a&gt;() method features a pointer to &lt;a href=&quot;qtiltreading&quot;&gt;QTiltReading&lt;/a&gt; instead of &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt;.</source>
          <target state="translated">유일한 차이는이다 &lt;a href=&quot;qtiltfilter#filter&quot;&gt;필터&lt;/a&gt; () 메소드에 대한 포인터 기능 &lt;a href=&quot;qtiltreading&quot;&gt;QTiltReading&lt;/a&gt; 대신 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c162fbd7d5fb602e3b740d0bb1157f268e030d3" translate="yes" xml:space="preserve">
          <source>The only difference is that the message now is a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; instead of a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;.</source>
          <target state="translated">유일한 차이점은 메시지가 이제 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 대신 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray라는&lt;/a&gt; 것입니다 .</target>
        </trans-unit>
        <trans-unit id="eb05b7811641d6adb93c940be02c124888bec2d8" translate="yes" xml:space="preserve">
          <source>The only drawback of the flexibility provided by QNX Neutrino RTOS is a risk that the run environment is slightly different on your target than what is expected by Qt. This is a common reason why a Qt application on a new target fails to start. A few generic environment variables can help locate the root cause for problems:</source>
          <target state="translated">QNX Neutrino RTOS가 제공하는 유연성의 유일한 단점은 실행 환경이 Qt에 의해 예상되는 것과 약간 다릅니다. 이것이 새 대상의 Qt 애플리케이션이 시작되지 않는 일반적인 이유입니다. 몇 가지 일반적인 환경 변수는 문제의 근본 원인을 찾는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f630e06d3d18bacc44447e3d6369642553a096e" translate="yes" xml:space="preserve">
          <source>The only function that we need to implement is the constructor:</source>
          <target state="translated">구현해야하는 유일한 함수는 생성자입니다.</target>
        </trans-unit>
        <trans-unit id="8ffcf3549a8d6f8ee8496a3f08786efd70d007af" translate="yes" xml:space="preserve">
          <source>The only mandatory property of a &lt;a href=&quot;qmediaresource&quot;&gt;QMediaResource&lt;/a&gt; is the &lt;a href=&quot;qmediaresource#url&quot;&gt;url&lt;/a&gt;().</source>
          <target state="translated">a의 유일한 필수 특성 &lt;a href=&quot;qmediaresource&quot;&gt;QMediaResource이&lt;/a&gt; 는 IS &lt;a href=&quot;qmediaresource#url&quot;&gt;URL&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="7701e199c6ee5b615163c8b92be6672f0bf93ffc" translate="yes" xml:space="preserve">
          <source>The only modification is in &lt;code&gt;main.cpp&lt;/code&gt;: a &lt;a href=&quot;qtremoteobjects-registry#registry&quot;&gt;Registry&lt;/a&gt; node is created to acquire a &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt;:</source>
          <target state="translated">유일한 수정 사항은 &lt;code&gt;main.cpp&lt;/code&gt; 에 있습니다 . &lt;a href=&quot;qtremoteobjects-registry#registry&quot;&gt;레지스트리&lt;/a&gt; 노드는 &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;복제본&lt;/a&gt; 을 얻기 위해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d7425dda43ef81933ff0d31260e0256ff998636" translate="yes" xml:space="preserve">
          <source>The only notification currently supported is &lt;a href=&quot;qwebsocket#sslErrors&quot;&gt;sslErrors&lt;/a&gt;(). If set to PauseOnSslErrors, data transfer on the socket will be paused and needs to be enabled explicitly again by calling &lt;a href=&quot;qwebsocket#resume&quot;&gt;resume&lt;/a&gt;(). By default, this option is set to PauseNever. This option must be called before connecting to the server, otherwise it will result in undefined behavior.</source>
          <target state="translated">현재 지원되는 유일한 알림은 &lt;a href=&quot;qwebsocket#sslErrors&quot;&gt;sslErrors&lt;/a&gt; ()입니다. PauseOnSslErrors로 설정하면 소켓의 데이터 전송이 일시 정지되며 &lt;a href=&quot;qwebsocket#resume&quot;&gt;resume&lt;/a&gt; () 을 호출하여 명시 적으로 다시 활성화해야합니다 . 기본적으로이 옵션은 PauseNever로 설정되어 있습니다. 서버에 연결하기 전에이 옵션을 호출해야합니다. 그렇지 않으면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7fdde9ea3c94b2a5742f062dc46a37471dd486f9" translate="yes" xml:space="preserve">
          <source>The only purpose of this macro is to provide an anchor for attaching meta data like to &lt;a href=&quot;qtglobal#qtTrId&quot;&gt;qtTrId&lt;/a&gt;().</source>
          <target state="translated">이 매크로의 유일한 목적은 &lt;a href=&quot;qtglobal#qtTrId&quot;&gt;qtTrId&lt;/a&gt; () 와 같은 메타 데이터를 첨부하기위한 앵커를 제공하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e009d46caeed2faa5dfc9e9652f0f6735359ce64" translate="yes" xml:space="preserve">
          <source>The only recoverable error is &lt;a href=&quot;qcborerror#Code-enum&quot;&gt;QCborError::EndOfFile&lt;/a&gt;, which indicates that more data is required in order to complete the parsing. This situation is useful when data is being read from an asynchronous source, such as a pipe (&lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt;) or a socket (&lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;, &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt;, &lt;a href=&quot;qnetworkreply&quot;&gt;QNetworkReply&lt;/a&gt;, etc.). When more data arrives, the surrounding code needs to call either &lt;a href=&quot;qcborstreamreader#addData&quot;&gt;addData&lt;/a&gt;(), if parsing from a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, or &lt;a href=&quot;qcborstreamreader#reparse&quot;&gt;reparse&lt;/a&gt;(), if it is instead reading directly a the QIDOevice that now has more data available (see &lt;a href=&quot;qcborstreamreader#setDevice&quot;&gt;setDevice&lt;/a&gt;()).</source>
          <target state="translated">복구 가능한 유일한 오류는 &lt;a href=&quot;qcborerror#Code-enum&quot;&gt;QCborError :: EndOfFile입니다&lt;/a&gt; . 이는 구문 분석을 완료하기 위해 더 많은 데이터가 필요함을 나타냅니다. 이 상황은 파이프 ( &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; ) 또는 소켓 ( &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; , &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt; , &lt;a href=&quot;qnetworkreply&quot;&gt;QNetworkReply&lt;/a&gt; 등) 과 같은 비동기 소스에서 데이터를 읽을 때 유용합니다 . 더 많은 데이터가 도착하면, 주변의 코드 요구 호출 중 하나 &lt;a href=&quot;qcborstreamreader#addData&quot;&gt;는, addData&lt;/a&gt; (), A로부터 파싱 경우 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; , 또는 &lt;a href=&quot;qcborstreamreader#reparse&quot;&gt;재분석&lt;/a&gt; 대신 사용할 더 많은 데이터를 가지고 직접 상기 QIDOevice를 읽는 경우 (), (참조 &lt;a href=&quot;qcborstreamreader#setDevice&quot;&gt;setDevice을&lt;/a&gt; ()).</target>
        </trans-unit>
        <trans-unit id="d0bc947719de04f6ab7404fbcebf0c8fb5d9ad7a" translate="yes" xml:space="preserve">
          <source>The only scenario in which you need to call it directly is if you implement a custom layout that supports nested layouts.</source>
          <target state="translated">중첩 된 레이아웃을 지원하는 사용자 정의 레이아웃을 구현하는 경우 직접 호출해야하는 유일한 시나리오입니다.</target>
        </trans-unit>
        <trans-unit id="49c1d91767db913abd1f8a5851e6284a5f6ce06e" translate="yes" xml:space="preserve">
          <source>The only service that can be instantiated with &lt;code&gt;&amp;lt;invoke&amp;gt;&lt;/code&gt; is another SCXML state machine.</source>
          <target state="translated">&lt;code&gt;&amp;lt;invoke&amp;gt;&lt;/code&gt; 로 인스턴스화 할 수있는 유일한 서비스 는 다른 SCXML 상태 시스템입니다.</target>
        </trans-unit>
        <trans-unit id="79ae1ba2ce5a75c2c915b2de78116e5cddbac6e7" translate="yes" xml:space="preserve">
          <source>The only useful thing you can do with the return value of this macro is to pass it to &lt;a href=&quot;qstring#asprintf&quot;&gt;QString::asprintf&lt;/a&gt;() for use in a &lt;code&gt;%ls&lt;/code&gt; conversion. In particular, the return value is</source>
          <target state="translated">이 매크로의 반환 값으로 수행 할 수있는 유일한 유용한 방법 은 &lt;code&gt;%ls&lt;/code&gt; 변환 에 사용 하기 위해 &lt;a href=&quot;qstring#asprintf&quot;&gt;QString :: asprintf&lt;/a&gt; ()에 전달하는 것 입니다. 특히 반환 값은</target>
        </trans-unit>
        <trans-unit id="d358fa245abdd7d3853d2b4cc1d7dad847371a84" translate="yes" xml:space="preserve">
          <source>The only way to be sure that no errors are being returned from the OpenGL implementation is checking with &lt;code&gt;glGetError&lt;/code&gt; after each and every API call. Moreover, OpenGL errors stack up, therefore glGetError should always be used in a loop like this:</source>
          <target state="translated">OpenGL 구현에서 오류가 리턴되지 않도록하는 유일한 방법은 모든 API 호출 후 &lt;code&gt;glGetError&lt;/code&gt; 로 확인하는 것 입니다. 또한 OpenGL 오류는 누적되므로 glGetError는 항상 다음과 같은 루프에서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="93c227b696e5a88a63e904023f76f21d6444c434" translate="yes" xml:space="preserve">
          <source>The only way you can use a document type that was created this way, is in combination with the &lt;a href=&quot;qdomimplementation#createDocument&quot;&gt;createDocument&lt;/a&gt;() function to create a &lt;a href=&quot;qdomdocument&quot;&gt;QDomDocument&lt;/a&gt; with this document type.</source>
          <target state="translated">이 방법으로 작성된 문서 유형을 사용할 수있는 유일한 방법은 &lt;a href=&quot;qdomimplementation#createDocument&quot;&gt;createDocument&lt;/a&gt; () 함수 와 결합하여이 문서 유형으로 &lt;a href=&quot;qdomdocument&quot;&gt;QDomDocument&lt;/a&gt; 를 작성하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="52aecd0534ffe96c2de7c85a73e9d57839da2432" translate="yes" xml:space="preserve">
          <source>The opacity for a widget. Possible values are from 0 (transparent) to 255 (opaque). For the moment, this is only supported for &lt;a href=&quot;qtooltip&quot;&gt;tooltips&lt;/a&gt;.</source>
          <target state="translated">위젯의 불투명도입니다. 가능한 값은 0 (투명)에서 255 (불투명)입니다. 현재로서는 &lt;a href=&quot;qtooltip&quot;&gt;툴팁에&lt;/a&gt; 대해서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="f10c8f2de221d162391e13defe043ad01aa8e01f" translate="yes" xml:space="preserve">
          <source>The opacity of a &lt;a href=&quot;qsgopacitynode&quot;&gt;QSGOpacityNode&lt;/a&gt; has changed.</source>
          <target state="translated">&lt;a href=&quot;qsgopacitynode&quot;&gt;QSGOpacityNode&lt;/a&gt; 의 불투명도 가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="344a655f469ce4eea640b1509e892062175da0fd" translate="yes" xml:space="preserve">
          <source>The opacity of the series. By default, the opacity is 1.0. The valid values range from 0.0 (transparent) to 1.0 (opaque).</source>
          <target state="translated">시리즈의 불투명도 기본적으로 불투명도는 1.0입니다. 유효한 값의 범위는 0.0 (투명)에서 1.0 (불투명)입니다.</target>
        </trans-unit>
        <trans-unit id="413d0a064d28712d5237b7149defe1d720c46475" translate="yes" xml:space="preserve">
          <source>The opacity of the window.</source>
          <target state="translated">창의 불투명도입니다.</target>
        </trans-unit>
        <trans-unit id="38d2c212d7c7ad5d05ac90d07868ee2170703da0" translate="yes" xml:space="preserve">
          <source>The opacity property decides the state of the painter passed to the &lt;a href=&quot;qgraphicsitem#paint&quot;&gt;paint&lt;/a&gt;() function. If the item is cached, i.e., &lt;a href=&quot;qgraphicsitem#CacheMode-enum&quot;&gt;ItemCoordinateCache&lt;/a&gt; or &lt;a href=&quot;qgraphicsitem#CacheMode-enum&quot;&gt;DeviceCoordinateCache&lt;/a&gt;, the effective property will be applied to the item's cache as it is rendered.</source>
          <target state="translated">opacity 속성은 &lt;a href=&quot;qgraphicsitem#paint&quot;&gt;paint&lt;/a&gt; () 함수에 전달 된 페인터의 상태를 결정합니다 . 항목이 캐시되면 (예 : &lt;a href=&quot;qgraphicsitem#CacheMode-enum&quot;&gt;ItemCoordinateCache&lt;/a&gt; 또는 &lt;a href=&quot;qgraphicsitem#CacheMode-enum&quot;&gt;DeviceCoordinateCache&lt;/a&gt; ) 유효 속성은 렌더링 될 때 항목의 캐시에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2208122841bfcefe9dc8190d11717d5f0b89a0c2" translate="yes" xml:space="preserve">
          <source>The opaque key facility allows applications to add support for facilities such as PKCS#11 that Qt does not currently offer natively.</source>
          <target state="translated">불투명 키 기능을 통해 응용 프로그램은 Qt가 현재 기본적으로 제공하지 않는 PKCS # 11과 같은 기능에 대한 지원을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a691fea4b6fa1932e238001006a3e59717b73361" translate="yes" xml:space="preserve">
          <source>The opaque material will be preferred by the renderer over the default material, as returned by the &lt;a href=&quot;qsggeometrynode#material&quot;&gt;material&lt;/a&gt;() function, if it is not null and the geometry item has an inherited opacity of 1.</source>
          <target state="translated">렌더러는 &lt;a href=&quot;qsggeometrynode#material&quot;&gt;머티리얼&lt;/a&gt; () 함수가 null이 아니고 지오메트리 항목의 상속 된 불투명도가 1 인 경우 렌더러가 기본 머티리얼보다 기본 머티리얼을 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="6ab72afe8fcba5eb9053bab3e607f6492a75f3e4" translate="yes" xml:space="preserve">
          <source>The opaque textured material respects the current matrix and the alpha channel of the texture. It will disregard the accumulated opacity in the scenegraph.</source>
          <target state="translated">불투명 텍스처 된 재질은 현재 매트릭스와 텍스처의 알파 채널을 존중합니다. 장면 그래프에서 누적 된 불투명도를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="93a5448849861cefe9b78f926ebb736fd556858d" translate="yes" xml:space="preserve">
          <source>The opaque textured material will fill every pixel in a geometry with the supplied texture. The material does not respect the opacity of the &lt;a href=&quot;qsgmaterialshader-renderstate&quot;&gt;QSGMaterialShader::RenderState&lt;/a&gt;, so opacity nodes in the parent chain of nodes using this material, have no effect.</source>
          <target state="translated">불투명 텍스처 재질은 제공된 텍스처로 지오메트리의 모든 픽셀을 채 웁니다. 머티리얼은 &lt;a href=&quot;qsgmaterialshader-renderstate&quot;&gt;QSGMaterialShader :: RenderState&lt;/a&gt; 의 불투명도를 존중하지 않으므로이 머티리얼을 사용하는 상위 노드 체인의 불투명 노드는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf40cbb9fa314e5fed21a8bcca2d7cd97f3a42e7" translate="yes" xml:space="preserve">
          <source>The opaqueness refers to scene graph opacity, the material is still allowed to set &lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;QSGMaterial::Blending&lt;/a&gt; to true and draw transparent pixels.</source>
          <target state="translated">불투명도는 장면 그래프 불투명도를 나타내며, 재료는 여전히 &lt;a href=&quot;qsgmaterial#Flag-enum&quot;&gt;QSGMaterial :: Blending&lt;/a&gt; 을 true 로 설정 하고 투명한 픽셀을 그릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2986fd124a74f62ab8eeee183dca2ee97d10dbf1" translate="yes" xml:space="preserve">
          <source>The open directory icon.</source>
          <target state="translated">열린 디렉토리 아이콘.</target>
        </trans-unit>
        <trans-unit id="84601f8bc9335bb4d34c5aef79bf09b69e86a10f" translate="yes" xml:space="preserve">
          <source>The open value of the candlestick item.</source>
          <target state="translated">촛대 항목의 시가입니다.</target>
        </trans-unit>
        <trans-unit id="b938b8f601ba2bde60c6102ee3efc51ea0d8c18e" translate="yes" xml:space="preserve">
          <source>The opening brace</source>
          <target state="translated">오프닝 버팀대</target>
        </trans-unit>
        <trans-unit id="50f0af6f7a605dce3d3fb436073b0e6862a0c94f" translate="yes" xml:space="preserve">
          <source>The operating systems supported by Qt offer the following support for high DPI displays:</source>
          <target state="translated">Qt가 지원하는 운영 체제는 높은 DPI 디스플레이에 대해 다음과 같은 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c092106a825274dc045d1210ab136d11d2015430" translate="yes" xml:space="preserve">
          <source>The operation cannot currently be performed for the current configuration.</source>
          <target state="translated">현재 구성에 대한 작업을 현재 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a195d3a1b208ab78fcfce1dbd937e994e8c87353" translate="yes" xml:space="preserve">
          <source>The operation failed because a system semaphore with the specified key already existed.</source>
          <target state="translated">지정된 키를 가진 시스템 세마포어가 이미 존재하여 작업이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="93cdced949d194326a31bc95183da44ab4352579" translate="yes" xml:space="preserve">
          <source>The operation failed because a system semaphore with the specified key could not be found.</source>
          <target state="translated">지정된 키를 가진 시스템 세마포어를 찾을 수 없어서 조작에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="5037356c5c05dd053d9b26283e6985983751e290" translate="yes" xml:space="preserve">
          <source>The operation failed because of an invalid key.</source>
          <target state="translated">키가 잘못되어 작업이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="e6414c64f8eca79345c16ffe919476ff4f67cb3b" translate="yes" xml:space="preserve">
          <source>The operation failed because of insufficient permissions.</source>
          <target state="translated">권한이 부족하여 작업이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="159f752a1bd5639a408af6997d2182e6b3d15e01" translate="yes" xml:space="preserve">
          <source>The operation failed because the caller didn't have the required permissions.</source>
          <target state="translated">호출자에게 필요한 권한이 없기 때문에 작업이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="23e082e5ac8d088be8c65b1b7e508d6a1ae5f17a" translate="yes" xml:space="preserve">
          <source>The operation failed because there was not enough memory available to fill the request.</source>
          <target state="translated">요청을 채우는 데 사용 가능한 메모리가 부족하여 작업이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="7f72ea32a6f475e22f40b8aea8a04d666e1c2ec2" translate="yes" xml:space="preserve">
          <source>The operation is not supported for current configuration.</source>
          <target state="translated">현재 구성에서는 작업이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ce14c19abcf3183d9703b200ef0227aaa642018" translate="yes" xml:space="preserve">
          <source>The operation of adding and removing items preserves the items' scene-relative position and transformation, as opposed to calling &lt;a href=&quot;qgraphicsitem#setParentItem&quot;&gt;setParentItem&lt;/a&gt;(), where only the child item's parent-relative position and transformation are kept.</source>
          <target state="translated">항목을 추가하고 제거하는 작업은 하위 항목의 부모 기준 위치와 변환 만 유지되는 &lt;a href=&quot;qgraphicsitem#setParentItem&quot;&gt;setParentItem&lt;/a&gt; () 호출과 달리 항목의 장면 기준 위치와 변환을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="a98c038b83c8cd3430486f27f7fa237dac2c317e" translate="yes" xml:space="preserve">
          <source>The operation was aborted.</source>
          <target state="translated">작업이 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="49f5cc194e751beeec38ece70da1908e9a004e89" translate="yes" xml:space="preserve">
          <source>The operation was canceled.</source>
          <target state="translated">작업이 취소되었습니다.</target>
        </trans-unit>
        <trans-unit id="52c8d918f7103932d6fe19894fb46590e5801f0f" translate="yes" xml:space="preserve">
          <source>The operation was not supported by the service provider.</source>
          <target state="translated">서비스 제공자가 조작을 지원하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="fe5f5d3519c68333f8881a59fde8fab02ef4f0ab" translate="yes" xml:space="preserve">
          <source>The opposite of the accept(const &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;&amp;amp;) function. Moves within the</source>
          <target state="translated">accept (const &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; &amp;amp;) 기능 의 반대입니다 . 내에서 이동</target>
        </trans-unit>
        <trans-unit id="82c396815c9508c77b53a85b40cd95877c031fad" translate="yes" xml:space="preserve">
          <source>The optimization hint for rendering.</source>
          <target state="translated">렌더링을위한 최적화 힌트.</target>
        </trans-unit>
        <trans-unit id="00d061c2f717d644793ed7614d8f2f71c412bf7b" translate="yes" xml:space="preserve">
          <source>The option will always be understood as a short option, regardless of what was set by &lt;a href=&quot;qcommandlineparser#setSingleDashWordOptionMode&quot;&gt;QCommandLineParser::setSingleDashWordOptionMode&lt;/a&gt;. This allows flags such as &lt;code&gt;-DDEFINE=VALUE&lt;/code&gt; or &lt;code&gt;-I/include/path&lt;/code&gt; to be interpreted as short flags even when the parser is in &lt;a href=&quot;qcommandlineparser#SingleDashWordOptionMode-enum&quot;&gt;QCommandLineParser::ParseAsLongOptions&lt;/a&gt; mode.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;qcommandlineparser#setSingleDashWordOptionMode&quot;&gt;QCommandLineParser :: setSingleDashWordOptionMode에&lt;/a&gt; 의해 설정된 내용에 관계없이 항상 짧은 옵션으로 이해됩니다 . 이는 구문 분석기가 &lt;a href=&quot;qcommandlineparser#SingleDashWordOptionMode-enum&quot;&gt;QCommandLineParser :: ParseAsLongOptions&lt;/a&gt; 모드에 있는 경우에도 &lt;code&gt;-DDEFINE=VALUE&lt;/code&gt; 또는 &lt;code&gt;-I/include/path&lt;/code&gt; 와 같은 플래그를 짧은 플래그로 해석 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">옵션</target>
        </trans-unit>
        <trans-unit id="9b1b5c859cd0bd2a446d225f410e3233051dbced" translate="yes" xml:space="preserve">
          <source>The optional auto-generation of a suitably filled .rc file by qmake is triggered by setting at least one of the system variables &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt;. The generated .rc file is automatically compiled and linked. Elements that are added to the .rc file are defined by the system variables &lt;a href=&quot;qmake-variable-reference#qmake-target-company&quot;&gt;QMAKE_TARGET_COMPANY&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#qmake-target-description&quot;&gt;QMAKE_TARGET_DESCRIPTION&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#qmake-target-copyright&quot;&gt;QMAKE_TARGET_COPYRIGHT&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#qmake-target-product&quot;&gt;QMAKE_TARGET_PRODUCT&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#rc-codepage&quot;&gt;RC_CODEPAGE&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt;, &lt;a href=&quot;qmake-variable-reference#rc-lang&quot;&gt;RC_LANG&lt;/a&gt;,and &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt;.</source>
          <target state="translated">qmake에 의해 적절히 채워진 .rc 파일의 선택적 자동 생성은 시스템 변수 &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; 중 하나 이상을 설정하여 트리거됩니다 . 생성 된 .rc 파일은 자동으로 컴파일 및 링크됩니다. .rc 파일에 추가 된 요소는 시스템 변수 &lt;a href=&quot;qmake-variable-reference#qmake-target-company&quot;&gt;QMAKE_TARGET_COMPANY&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#qmake-target-description&quot;&gt;QMAKE_TARGET_DESCRIPTION&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#qmake-target-copyright&quot;&gt;QMAKE_TARGET_COPYRIGHT&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#qmake-target-product&quot;&gt;QMAKE_TARGET_PRODUCT&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#rc-codepage&quot;&gt;RC_CODEPAGE&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#rc-icons&quot;&gt;RC_ICONS&lt;/a&gt; , &lt;a href=&quot;qmake-variable-reference#rc-lang&quot;&gt;RC_LANG&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#version&quot;&gt;VERSION에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="6de11b1c20367813dc279fe6f70db20e1c61c2a3" translate="yes" xml:space="preserve">
          <source>The optional check box of a group box.</source>
          <target state="translated">그룹 상자의 선택적 확인란입니다.</target>
        </trans-unit>
        <trans-unit id="9c2ea53f9f5ca1598eeddae6cd754cedc0ea1d51" translate="yes" xml:space="preserve">
          <source>The optional column labels for the array. Indexes in this array match column indexes in rows. If the list is shorter than the longest row, all columns will not get labels.</source>
          <target state="translated">배열의 선택적 열 레이블입니다. 이 배열의 인덱스는 행의 열 인덱스와 일치합니다. 목록이 가장 긴 행보다 짧은 경우 모든 열에 레이블이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a284d0e801940972e80fcde3e193b00a4ff4bd36" translate="yes" xml:space="preserve">
          <source>The optional row labels for the array. Indexes in this array match the row indexes in the data array. If the list is shorter than the number of rows, all rows will not get labels.</source>
          <target state="translated">배열의 선택적 행 레이블. 이 배열의 인덱스는 데이터 배열의 행 인덱스와 일치합니다. 목록이 행 수보다 짧은 경우 모든 행에 레이블이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ebee28756dc591194532cc3e7139de85f3122e7a" translate="yes" xml:space="preserve">
          <source>The options currently supported are the following:</source>
          <target state="translated">현재 지원되는 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6fd531dd72c16da72cf2ec0eaaa9b173ee846b50" translate="yes" xml:space="preserve">
          <source>The options from &lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl::ComponentFormattingOptions&lt;/a&gt; are also possible.</source>
          <target state="translated">&lt;a href=&quot;qurl#ComponentFormattingOption-enum&quot;&gt;QUrl :: ComponentFormattingOptions&lt;/a&gt; 의 옵션 도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b599705693aff386f339e097a22afa2e356d42b0" translate="yes" xml:space="preserve">
          <source>The options marked &quot;(default)&quot; are set if no other values from the list are included (since the defaults are zero):</source>
          <target state="translated">&quot;(기본값)&quot;으로 표시된 옵션은 목록의 다른 값이 포함되지 않은 경우 설정됩니다 (기본값은 0이므로).</target>
        </trans-unit>
        <trans-unit id="a4bd6349a1596e35a193c9a1f09784768190662c" translate="yes" xml:space="preserve">
          <source>The order in which the three threads are woken up is undefined. Also, if some of the threads are still in &lt;code&gt;do_something()&lt;/code&gt; when the key is pressed, they won't be woken up (since they're not waiting on the condition variable) and so the task will not be performed for that key press. This issue can be solved using a counter and a &lt;a href=&quot;qmutex&quot;&gt;QMutex&lt;/a&gt; to guard it. For example, here's the new code for the worker threads:</source>
          <target state="translated">세 개의 스레드가 깨어 난 순서는 정의되어 있지 않습니다. 또한 키를 누를 때 일부 스레드가 여전히 &lt;code&gt;do_something()&lt;/code&gt; 있으면 스레드가 깨어나지 않으므로 (조건 변수를 기다리지 않기 때문에) 해당 키 누름에 대한 작업이 수행되지 않습니다. . 이 문제는 카운터와 &lt;a href=&quot;qmutex&quot;&gt;QMutex&lt;/a&gt; 를 사용하여 해결할 수 있습니다 . 예를 들어 작업자 스레드의 새 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0312a5ad292da8b9cd50e12fe74655eb122b8270" translate="yes" xml:space="preserve">
          <source>The order is as follows:</source>
          <target state="translated">순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b80f02ee270b8f51aafc4021e911ed0f89c29b8c" translate="yes" xml:space="preserve">
          <source>The order is guaranteed to be the same as that used by &lt;a href=&quot;qhash#keys&quot;&gt;keys&lt;/a&gt;().</source>
          <target state="translated">순서는 &lt;a href=&quot;qhash#keys&quot;&gt;키&lt;/a&gt; () 가 사용하는 순서와 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f594036127c47f9b2fbbeb407faf34c2cf24403e" translate="yes" xml:space="preserve">
          <source>The order is guaranteed to be the same as that used by &lt;a href=&quot;qhash#values&quot;&gt;values&lt;/a&gt;().</source>
          <target state="translated">순서는 &lt;a href=&quot;qhash#values&quot;&gt;값&lt;/a&gt; ()에서 사용 된 순서와 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fb65df26b27d4b6bfdda0e0f568d80c0a453f9e9" translate="yes" xml:space="preserve">
          <source>The order is guaranteed to be the same as that used by &lt;a href=&quot;qmap#values&quot;&gt;values&lt;/a&gt;().</source>
          <target state="translated">순서는 &lt;a href=&quot;qmap#values&quot;&gt;값&lt;/a&gt; ()에서 사용 된 순서와 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ee7d1e6803b691d6187a2a92328736d444fc57b3" translate="yes" xml:space="preserve">
          <source>The order of elements in the array is not relevant. Outputs with unspecified virtual indices will be placed after the others, with the original order in the DRM connector list preserved.</source>
          <target state="translated">배열의 요소 순서는 관련이 없습니다. 지정되지 않은 가상 인덱스가있는 출력은 DRM 커넥터 목록의 원래 순서가 유지 된 상태로 다른 인덱스 뒤에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="36c0783770d2606eadbcab10c23e2a554e28050f" translate="yes" xml:space="preserve">
          <source>The order of elements in the string list is as follows. The first element is the entire matching string. Each subsequent element corresponds to the next capturing open left parentheses. Thus capturedTexts()[1] is the text of the first capturing parentheses, capturedTexts()[2] is the text of the second and so on (corresponding to $1, $2, etc., in some other regexp languages).</source>
          <target state="translated">문자열리스트의 요소 순서는 다음과 같습니다. 첫 번째 요소는 전체 일치 문자열입니다. 각 후속 요소는 다음 캡처 된 열린 왼쪽 괄호에 해당합니다. 따라서 capturedTexts () [1]은 첫 번째 캡처 괄호의 텍스트이고 capturedTexts () [2]는 두 번째 등의 텍스트입니다 (일부 다른 정규식 언어의 경우 $ 1, $ 2 등에 해당).</target>
        </trans-unit>
        <trans-unit id="b3c6a6265e7bc2491361e04c6fed8fe2f7be8150" translate="yes" xml:space="preserve">
          <source>The order of elements matched by cap() is as follows. The first element, cap(0), is the entire matching string. Each subsequent element corresponds to the next capturing open left parentheses. Thus cap(1) is the text of the first capturing parentheses, cap(2) is the text of the second, and so on.</source>
          <target state="translated">cap ()과 일치하는 요소의 순서는 다음과 같습니다. 첫 번째 요소 인 cap (0)은 전체 일치 문자열입니다. 각 후속 요소는 다음 캡처 된 열린 왼쪽 괄호에 해당합니다. 따라서 cap (1)은 첫 번째 캡처 괄호의 텍스트이고, cap (2)는 두 번째 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="fa93e0ec1c268a32fe62720345e9be2ee8c9cf9b" translate="yes" xml:space="preserve">
          <source>The order of events in this interface is very important, and mirrors the order of information in the document itself. For example, all of an element's content (character data, processing instructions, and sub-elements) appears, in order, between the &lt;a href=&quot;qxmlcontenthandler#startElement&quot;&gt;startElement&lt;/a&gt;() event and the corresponding &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;endElement&lt;/a&gt;() event.</source>
          <target state="translated">이 인터페이스의 이벤트 순서는 매우 중요하며 문서 자체의 정보 순서를 반영합니다. 예를 들어 &lt;a href=&quot;qxmlcontenthandler#startElement&quot;&gt;startElement&lt;/a&gt; () 이벤트와 해당 &lt;a href=&quot;qxmlcontenthandler#endElement&quot;&gt;endElement&lt;/a&gt; () 이벤트 사이에 요소의 모든 내용 (문자 데이터, 처리 명령 및 하위 요소)이 순서대로 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="f4e0b3f6a8ac779350b2e32b538cd004f314ae75" translate="yes" xml:space="preserve">
          <source>The order of the aliases in the list is undefined.</source>
          <target state="translated">목록에서 별칭의 순서는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5761e91a48c25ce665a3165fba329cb492424df7" translate="yes" xml:space="preserve">
          <source>The order of the key-value pairs in the returned string is exactly the same as in the original query.</source>
          <target state="translated">반환 된 문자열에서 키-값 쌍의 순서는 원래 쿼리와 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b39cd913537aa8420dc48f04c8b4830a3fe07ece" translate="yes" xml:space="preserve">
          <source>The order of the positions within a line starts at the top of a vertical line, and from the left within a horizontal line. The order of the positions for the lines is always from the parent widget's boundary edges.</source>
          <target state="translated">라인 내 위치의 순서는 수직선의 상단에서 시작하여 수평선의 왼쪽에서 시작합니다. 선의 위치 순서는 항상 부모 위젯의 경계 가장자리에서 나옵니다.</target>
        </trans-unit>
        <trans-unit id="640f9f4b44e38703fa036394e287a4cd79beac98" translate="yes" xml:space="preserve">
          <source>The organization responsible for the parental rating of the media.</source>
          <target state="translated">미디어의 부모 등급을 담당하는 조직입니다.</target>
        </trans-unit>
        <trans-unit id="550a8358452ff77cca132f5f43f21b34d325239d" translate="yes" xml:space="preserve">
          <source>The orientation change will also affect the mapping of coordinates from source to viewport.</source>
          <target state="translated">방향 변경은 소스에서 뷰포트로의 좌표 매핑에도 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="483e501d1c57b65bc1c79b72475dc19ae2427a0b" translate="yes" xml:space="preserve">
          <source>The orientation determines how the split items are laid out:</source>
          <target state="translated">방향은 분할 항목을 배치하는 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="f829661de50b7dbf1216aecc9cf305a209f994d0" translate="yes" xml:space="preserve">
          <source>The orientation is mirrored, and rotated 180 degrees. *</source>
          <target state="translated">방향이 대칭되고 180도 회전합니다. *</target>
        </trans-unit>
        <trans-unit id="7d85c633c6477d41c4061af1b2d2e2b5e17de46c" translate="yes" xml:space="preserve">
          <source>The orientation is mirrored, and rotated 270 degrees. * *</source>
          <target state="translated">방향이 대칭되고 270도 회전합니다. * *</target>
        </trans-unit>
        <trans-unit id="ca5de3a9500b83a97c1a985762175b34ae622932" translate="yes" xml:space="preserve">
          <source>The orientation is mirrored, and rotated 90 degrees. *</source>
          <target state="translated">방향이 대칭되고 90도 회전합니다. *</target>
        </trans-unit>
        <trans-unit id="bb304c17acc555066fda750ed2aa71c061808e94" translate="yes" xml:space="preserve">
          <source>The orientation is mirrored. *</source>
          <target state="translated">방향이 미러링됩니다. *</target>
        </trans-unit>
        <trans-unit id="c2dee3f86a8c6b76765c0e9f72eafc4936b5605e" translate="yes" xml:space="preserve">
          <source>The orientation is normal. *</source>
          <target state="translated">방향이 정상입니다. *</target>
        </trans-unit>
        <trans-unit id="815104d1f948d82ec04b2ba54b5f8966564847fd" translate="yes" xml:space="preserve">
          <source>The orientation is rotated 180 degrees. *</source>
          <target state="translated">방향이 180도 회전합니다. *</target>
        </trans-unit>
        <trans-unit id="0ab2e060366e633486ebd85908f0e91845f1db92" translate="yes" xml:space="preserve">
          <source>The orientation is rotated 270 degrees. *</source>
          <target state="translated">방향이 270도 회전합니다. *</target>
        </trans-unit>
        <trans-unit id="85d787519322ec1221db321c389f7bee6046a7f5" translate="yes" xml:space="preserve">
          <source>The orientation is rotated 90 degrees. *</source>
          <target state="translated">방향이 90도 회전합니다. *</target>
        </trans-unit>
        <trans-unit id="c25b4814774f5f29e50624ceabb719d7b77729fd" translate="yes" xml:space="preserve">
          <source>The orientation is unknown.</source>
          <target state="translated">방향을 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e585b64b832dcc211c1dc19ec4d8e4ff5ed1dd7" translate="yes" xml:space="preserve">
          <source>The orientation must be &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt::Horizontal&lt;/a&gt; (the default) or &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt::Vertical&lt;/a&gt;.</source>
          <target state="translated">방향은 &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt :: Horizontal&lt;/a&gt; (기본값) 또는 &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt :: Vertical&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c010ed543937356233f98d7c731c765480465981" translate="yes" xml:space="preserve">
          <source>The orientation must be &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt::Vertical&lt;/a&gt; (the default) or &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt::Horizontal&lt;/a&gt;.</source>
          <target state="translated">방향은 &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt :: Vertical&lt;/a&gt; (기본값) 또는 &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt :: Horizontal&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e9eede37764cb066b5377856e87f241b03c46309" translate="yes" xml:space="preserve">
          <source>The orientation of the &lt;code&gt;Video&lt;/code&gt; in degrees. Only multiples of 90 degrees is supported, that is 0, 90, 180, 270, 360, etc.</source>
          <target state="translated">&lt;code&gt;Video&lt;/code&gt; 의 방향 ( 도)입니다. 90 도의 배수, 즉 0, 90, 180, 270, 360 등 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9030d6b86a75cda6510254ab4662e15f41392d25" translate="yes" xml:space="preserve">
          <source>The orientation of the axis object.</source>
          <target state="translated">축 객체의 방향입니다.</target>
        </trans-unit>
        <trans-unit id="3bc9410033f892506b697119437fd1e03b7efb62" translate="yes" xml:space="preserve">
          <source>The orientation of the axis.</source>
          <target state="translated">축의 방향입니다.</target>
        </trans-unit>
        <trans-unit id="99ac394ab65b5a7fd30b7cff7dbae89320a47f86" translate="yes" xml:space="preserve">
          <source>The orientation of the axis. Fixed to either &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt.Horizontal&lt;/a&gt; or &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt.Vertical&lt;/a&gt; when the axis is set to a series.</source>
          <target state="translated">축의 방향입니다. 축이 시리즈로 설정된 경우 &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt.Horizontal&lt;/a&gt; 또는 &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt.Vertical로&lt;/a&gt; 고정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d8f89e6ead264079497177470d9881ddd6e5acd8" translate="yes" xml:space="preserve">
          <source>The orientation sensor reports the orientation of the device. As it operates below the UI level it does not report on or even know how the UI is rotated. Most importantly this means that this sensor cannot be used to detect if a device is in portrait or landscape mode.</source>
          <target state="translated">방향 센서는 장치의 방향을보고합니다. UI 수준 아래에서 작동하므로 UI가 회전하는 방식을보고하거나 알지 못합니다. 가장 중요한 것은 장치가 세로 또는 가로 모드인지 여부를 감지하는 데이 센서를 사용할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8b94530b04cf01ec1b52299c9e982cffda4b2636" translate="yes" xml:space="preserve">
          <source>The orientation sensor returns the orientation of the device using the pre-defined values found in the &lt;a href=&quot;qorientationreading#Orientation-enum&quot;&gt;QOrientationReading::Orientation&lt;/a&gt; enum.</source>
          <target state="translated">방향 센서는 &lt;a href=&quot;qorientationreading#Orientation-enum&quot;&gt;QOrientationReading :: Orientation&lt;/a&gt; 열거 형 에있는 사전 정의 된 값을 사용하여 장치의 방향을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="350e595ee942f7a45758a4f3936251a64fdaf565" translate="yes" xml:space="preserve">
          <source>The orientation setting does not affect this rectangle.</source>
          <target state="translated">방향 설정은이 사각형에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58c8ad3268b8190b195a9cd43899b9fb7bbecc6b" translate="yes" xml:space="preserve">
          <source>The orientation values here are always of the screen orientation, not the device orientation. The screen orientation is the orientation of the GUI. For example when rotating a device by 90 degrees counter-clockwise, the screen orientation compensates for that by rotating 90 degrees clockwise, to the effect that the GUI is still facing upright after the device has been rotated. Note that applications can lock the screen orientation, for example to force portrait or landscape mode. For locked orientations, orientable sensors will not react with reading changes if the device orientation is changed, as orientable sensors react to screen orientation changes only. This makes sense, as the purpose of orientable sensors is to keep the sensor orientation in sync with the screen orientation.</source>
          <target state="translated">여기의 방향 값은 항상 장치 방향이 아니라 화면 방향입니다. 화면 방향은 GUI의 방향입니다. 예를 들어 장치를 시계 반대 방향으로 90도 회전 할 때 화면 방향은 장치를 회전 한 후 GUI가 여전히 똑바로 향하는 효과를 위해 시계 방향으로 90도 회전하여이를 보정합니다. 응용 프로그램은 화면 방향을 잠글 수 있습니다 (예 : 세로 또는 가로 모드). 방향이 잠겨있는 경우 방향 센서는 화면 방향 변경에만 반응하므로 장치 방향이 변경되면 방향 센서가 판독 변경에 반응하지 않습니다. 오리 엔터 블 센서의 목적은 센서 방향을 화면 방향과 동기화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a7b3beeafac2388893c9e8fd291c0535b08badc1" translate="yes" xml:space="preserve">
          <source>The orientation values range from 0 to 270 degrees. The orientation is applied in clockwise direction, e.g. an orientation value of 90 degrees means that the screen has been rotated 90 degress to the right from its origin position, to compensate a device rotation of 90 degrees to the left.</source>
          <target state="translated">방향 값의 범위는 0에서 270 도입니다. 방향은 시계 방향으로 적용됩니다. 예를 들어 90 도의 방향 값은 화면이 원래 위치에서 오른쪽으로 90도 회전하여 왼쪽으로 90도 회전하는 장치를 보정합니다.</target>
        </trans-unit>
        <trans-unit id="cbdda422aa28d1a169072a0cfac072df812ad68e" translate="yes" xml:space="preserve">
          <source>The orientations are shown here in order: TopUp, TopDown, LeftUp, RightUp, FaceUp, FaceDown.</source>
          <target state="translated">방향은 TopUp, TopDown, LeftUp, RightUp, FaceUp, FaceDown 순서로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="552762f271645b86100bff2fc673ee72a505b836" translate="yes" xml:space="preserve">
          <source>The origin is equivalent to the</source>
          <target state="translated">원점은</target>
        </trans-unit>
        <trans-unit id="e8ff3d7bb06d09c6ab66be19a03bf8f722db3900" translate="yes" xml:space="preserve">
          <source>The origin is the bottom left corner of the buffer.</source>
          <target state="translated">원점은 버퍼의 왼쪽 아래 모서리입니다.</target>
        </trans-unit>
        <trans-unit id="f28fc24938f47ea52e954ba4434519161c2c41bc" translate="yes" xml:space="preserve">
          <source>The origin is the point that the item is rotated around (i.e., it stays fixed relative to the parent as the rest of the item is rotated). By default the origin is &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;(0, 0).</source>
          <target state="translated">원점은 항목이 회전하는 지점입니다 (즉, 항목의 나머지 부분이 회전함에 따라 부모에 대해 고정 된 상태로 유지됨). 기본적으로 원점은 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; (0, 0)입니다.</target>
        </trans-unit>
        <trans-unit id="12177e2e37bc9ab6d9d19f6683a400890adad62f" translate="yes" xml:space="preserve">
          <source>The origin is the point that the item is scaled from (i.e., it stays fixed relative to the parent as the rest of the item grows). By default the origin is &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;(0, 0).</source>
          <target state="translated">원점은 항목의 크기가 조정되는 지점입니다 (즉, 항목의 나머지 부분이 커질 때 부모에 대해 고정 된 상태로 유지됨). 기본적으로 원점은 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; (0, 0)입니다.</target>
        </trans-unit>
        <trans-unit id="1cc4d612b237ee9db38cf57af035e9505666094f" translate="yes" xml:space="preserve">
          <source>The origin is the top left corner of the buffer.</source>
          <target state="translated">원점은 버퍼의 왼쪽 상단입니다.</target>
        </trans-unit>
        <trans-unit id="cc5eda91e7cff5355c7558f96a8c1b3889484e3d" translate="yes" xml:space="preserve">
          <source>The origin of the content of a plain text edit is always the top left corner of the first visible text block. The content offset is different from (0,0) when the text has been scrolled horizontally, or when the first visible block has been scrolled partially off the screen, i.e. the visible text does not start with the first line of the first visible block, or when the first visible block is the very first block and the editor displays a margin.</source>
          <target state="translated">일반 텍스트 편집 내용의 원점은 항상 첫 번째 보이는 텍스트 블록의 왼쪽 상단입니다. 텍스트가 가로로 스크롤되었거나 첫 번째 표시 블록이 화면에서 부분적으로 스크롤 된 경우 (즉, 표시 텍스트가 첫 번째 표시 블록의 첫 번째 줄로 시작하지 않는 경우) 컨텐츠 오프셋은 (0,0)과 다릅니다. 또는 첫 번째 보이는 블록이 첫 번째 블록 인 경우 편집기에 여백이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="79193ef789f1503c76389f0777dbb682938fdee0" translate="yes" xml:space="preserve">
          <source>The origin point of the rotation (i.e., the point that stays fixed relative to the parent as the rest of the item rotates). By default the origin is (0, 0).</source>
          <target state="translated">회전의 원점 (즉, 항목의 나머지 부분이 회전함에 따라 부모에 대해 고정 된 점) 기본적으로 원점은 (0, 0)입니다.</target>
        </trans-unit>
        <trans-unit id="31be72acad16867360baf78e0b008f39c853b62e" translate="yes" xml:space="preserve">
          <source>The origin rectangle of the subcontrol within the parent element.</source>
          <target state="translated">부모 요소 내 하위 컨트롤의 원점 사각형</target>
        </trans-unit>
        <trans-unit id="d4cf841e0eb0e78adf8a80af2a9157b0abfede68" translate="yes" xml:space="preserve">
          <source>The origin rectangle to be used can be changed using the &lt;a href=&quot;stylesheet-reference#subcontrol-origin-prop&quot;&gt;subcontrol-origin&lt;/a&gt; property. For example, if we want to place the drop-down in the margin rectangle of the &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; instead of the default Padding rectangle, we can specify:</source>
          <target state="translated">사용되는 원점 사각형은 &lt;a href=&quot;stylesheet-reference#subcontrol-origin-prop&quot;&gt;subcontrol-origin&lt;/a&gt; 속성을 사용하여 변경할 수 있습니다 . 예를 들어, 기본 패딩 사각형 대신 &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; 의 여백 사각형에 드롭 다운을 배치하려면 다음을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0df6a35f0f18c778205c627cabf329475bc150b" translate="yes" xml:space="preserve">
          <source>The origin type is equivalent to the</source>
          <target state="translated">원점 유형은</target>
        </trans-unit>
        <trans-unit id="85947cfc19b61a9c077c85fd29dd3e55e35b14fb" translate="yes" xml:space="preserve">
          <source>The original &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; is not changed.</source>
          <target state="translated">원본 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2bc46b8b81dd99883bccf8893caf750ce6a566a" translate="yes" xml:space="preserve">
          <source>The original size of an image. A handler that supports this option is expected to read the size of the image from the image metadata, and return this size from &lt;a href=&quot;qimageiohandler#option&quot;&gt;option&lt;/a&gt;() as a &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;.</source>
          <target state="translated">이미지의 원래 크기입니다. 이 옵션을 지원하는 핸들러는 이미지 메타 데이터에서 이미지의 크기를 읽고 &lt;a href=&quot;qimageiohandler#option&quot;&gt;option&lt;/a&gt; () 에서이 크기를 &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; 로 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f20cdda60b712b960bea57724a802695ec7a5e92" translate="yes" xml:space="preserve">
          <source>The other alternative is to create a &lt;a href=&quot;qquickframebufferobject&quot;&gt;QQuickFramebufferObject&lt;/a&gt;, render into it, and let it be displayed in the scene graph as a texture. The &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-scenegraph-textureinsgnode-example.html#&quot;&gt;Scene Graph - Rendering FBOs&lt;/a&gt; example shows how this can be done. It is also possible to combine multiple rendering contexts and multiple threads to create content to be displayed in the scene graph. The &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-scenegraph-textureinthread-example.html#&quot;&gt;Scene Graph - Rendering FBOs in a thread&lt;/a&gt; examples show how this can be done.</source>
          <target state="translated">다른 대안은 &lt;a href=&quot;qquickframebufferobject&quot;&gt;QQuickFramebufferObject&lt;/a&gt; 를 생성하여 렌더링 한 다음 장면 그래프에 텍스처로 표시하는 것입니다. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-scenegraph-textureinsgnode-example.html#&quot;&gt;장면 그래프 - 렌더링 식 코멘트에&lt;/a&gt; 이 작업을 수행 할 수있는 방법을 예를 보여줍니다. 장면 렌더링에 표시 할 내용을 만들기 위해 여러 렌더링 컨텍스트와 여러 스레드를 결합 할 수도 있습니다. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-scenegraph-textureinthread-example.html#&quot;&gt;스레드&lt;/a&gt; 예제 의 장면 그래프-렌더링 FBO는 이를 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e51f904cb00d38d7ea81d436a59469a0ca283810" translate="yes" xml:space="preserve">
          <source>The other attributes of the current text block, e.g. the font and background color, are reset to default values.</source>
          <target state="translated">현재 텍스트 블록의 다른 속성 (예 : 글꼴 및 배경색)이 기본값으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="65afb0f43133ad8ae530f99a0728fbf737687bfa" translate="yes" xml:space="preserve">
          <source>The other common members for widgets are:</source>
          <target state="translated">위젯의 다른 공통 멤버는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4cb226792a3f1ab071320212f0b10098ed3cd829" translate="yes" xml:space="preserve">
          <source>The other frequently used positional function is &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-last&quot;&gt;last()&lt;/a&gt;, which returns the numeric position of the last item in the focus set. Stated another way, &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-last&quot;&gt;last()&lt;/a&gt; returns the size of the focus set. This query returns the last recipe in the cookbook:</source>
          <target state="translated">자주 사용되는 다른 위치 함수는 &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-last&quot;&gt;last ()&lt;/a&gt; 이며 포커스 세트에서 마지막 항목의 숫자 위치를 반환합니다. 다른 방법으로 말하면 &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-last&quot;&gt;last ()&lt;/a&gt; 는 포커스 세트의 크기를 반환합니다. 이 쿼리는 요리 책의 마지막 레시피를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="61e01fcd154f1dd855b0124ae23a446d85079a6a" translate="yes" xml:space="preserve">
          <source>The other functions must be overridden by all plugins, other than sourcePriority() which defaults to returning 0. Higher values of priority will be preferred to lower ones.</source>
          <target state="translated">다른 함수는 기본적으로 0을 리턴하는 sourcePriority () 이외의 모든 플러그인으로 대체되어야합니다. 우선 순위가 높은 값은 낮은 값보다 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="2df90243d36f873303b0f6cd0f4b424c9fe222c6" translate="yes" xml:space="preserve">
          <source>The other functions should be overridden if the plugin supports the associated set of functionality.</source>
          <target state="translated">플러그인이 관련 기능 세트를 지원하는 경우 다른 기능을 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="7763b78d05d1eefcddd7f20efdd8133c69db51a4" translate="yes" xml:space="preserve">
          <source>The other kind of predicate evaluates to</source>
          <target state="translated">다른 종류의 술어는</target>
        </trans-unit>
        <trans-unit id="ac5268f7e556761426b7326dd26f79da30451f3d" translate="yes" xml:space="preserve">
          <source>The other major use of drag actions is when using a reference type such as text/uri-list, where the dragged data are actually references to files or objects.</source>
          <target state="translated">드래그 동작의 다른 주요 용도는 텍스트 / uri-list와 같은 참조 유형을 사용할 때입니다. 여기서 드래그 된 데이터는 실제로 파일이나 객체에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="e620a36a9b90671b0f29787721c5f62005d03f84" translate="yes" xml:space="preserve">
          <source>The other two examples from the &lt;a href=&quot;#wildcards-in-name-tests&quot;&gt;wildcard&lt;/a&gt; section can be rewritten the same way. Here is the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; that selects all the &lt;code&gt;name&lt;/code&gt; attributes, regardless of namespace:</source>
          <target state="translated">&lt;a href=&quot;#wildcards-in-name-tests&quot;&gt;와일드 카드&lt;/a&gt; 섹션 의 다른 두 예제 는 같은 방식으로 다시 작성할 수 있습니다. 네임 스페이스에 관계없이 모든 &lt;code&gt;name&lt;/code&gt; 속성 을 선택 하는 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6660fe3780c5ce7f8658ca3283dfd9a9f070275f" translate="yes" xml:space="preserve">
          <source>The other way to connect a signal to a slot is to use &lt;a href=&quot;qobject#connect&quot;&gt;QObject::connect&lt;/a&gt;() and the &lt;code&gt;SIGNAL&lt;/code&gt; and &lt;code&gt;SLOT&lt;/code&gt; macros. The rule about whether to include arguments or not in the &lt;code&gt;SIGNAL()&lt;/code&gt; and &lt;code&gt;SLOT()&lt;/code&gt; macros, if the arguments have default values, is that the signature passed to the &lt;code&gt;SIGNAL()&lt;/code&gt; macro must</source>
          <target state="translated">신호를 슬롯에 연결하는 다른 방법은 &lt;a href=&quot;qobject#connect&quot;&gt;QObject :: connect&lt;/a&gt; () 및 &lt;code&gt;SIGNAL&lt;/code&gt; 및 &lt;code&gt;SLOT&lt;/code&gt; 매크로를 사용하는 것입니다. 인수에 기본값이있는 경우 &lt;code&gt;SIGNAL()&lt;/code&gt; 및 &lt;code&gt;SLOT()&lt;/code&gt; 매크로에 인수를 포함할지 여부에 대한 규칙은 &lt;code&gt;SIGNAL()&lt;/code&gt; 매크로에 전달 된 서명이</target>
        </trans-unit>
        <trans-unit id="17024a0a556fab6f3b04fac32d97cb9a922a472b" translate="yes" xml:space="preserve">
          <source>The outer edges of the lines are extended to meet at an angle, and this area is filled.</source>
          <target state="translated">선의 바깥 쪽 가장자리가 비스듬히 연장되어이 영역이 채워집니다.</target>
        </trans-unit>
        <trans-unit id="c26e3e033748d0970d424f801a7c2aa2c33e844b" translate="yes" xml:space="preserve">
          <source>The outline drawn around the object's border.</source>
          <target state="translated">객체의 테두리 주위에 그려진 윤곽선.</target>
        </trans-unit>
        <trans-unit id="da857b01236c6d172c2f3a10c35f1a74e8478ca0" translate="yes" xml:space="preserve">
          <source>The outline of a shape can vary depending on the width and style of the pen used when drawing. If you want to include this outline in the item's shape, you can create a shape from the stroke using &lt;a href=&quot;qpainterpathstroker&quot;&gt;QPainterPathStroker&lt;/a&gt;.</source>
          <target state="translated">도형의 윤곽은 그릴 때 사용되는 펜의 너비와 스타일에 따라 달라질 수 있습니다. 이 윤곽선을 항목 모양에 포함하려면 &lt;a href=&quot;qpainterpathstroker&quot;&gt;QPainterPathStroker를&lt;/a&gt; 사용하여 획에서 모양을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9da77e9a4723ab4462ce113c38b60bf1ea24711" translate="yes" xml:space="preserve">
          <source>The outline's offset from the border of the widget.</source>
          <target state="translated">위젯 테두리에서 아웃 라인의 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="867629a898a798615a5d5835de5c8b8ec45ac6a5" translate="yes" xml:space="preserve">
          <source>The outlines generated by Qt's stroker are only an approximation when dealing with curved shapes. It is in most cases impossible to represent the outline of a bezier curve segment using another bezier curve segment, and so Qt approximates the curve outlines by using several smaller curves. For performance reasons there is a limit to how many curves Qt uses for these outlines, and thus when using large pen widths or scales the outline error increases. To generate outlines with smaller errors it is possible to use the &lt;a href=&quot;qpainterpathstroker&quot;&gt;QPainterPathStroker&lt;/a&gt; class, which has the setCurveThreshold member function which let's the user specify the error tolerance. Another workaround is to convert the paths to polygons first and then draw the polygons instead.</source>
          <target state="translated">Qt의 스트로크에 의해 생성 된 윤곽은 곡선 모양을 다룰 때의 근사치 일뿐입니다. 대부분의 경우 다른 베 지어 곡선 세그먼트를 사용하여 베 지어 곡선 세그먼트의 윤곽선을 나타내는 것은 불가능하므로 Qt는 여러 개의 작은 곡선을 사용하여 곡선 윤곽선에 근접합니다. 성능상의 이유로 Qt가 이러한 윤곽선에 사용하는 곡선 수에는 제한이 있으므로 큰 펜 너비 또는 축척을 사용할 때 윤곽선 오류가 증가합니다. 더 작은 오류가있는 아웃 라인을 생성하기 위해 사용자가 오류 허용 오차를 지정할 수있는 setCurveThreshold 멤버 함수가있는 &lt;a href=&quot;qpainterpathstroker&quot;&gt;QPainterPathStroker&lt;/a&gt; 클래스 를 사용할 수 있습니다 . 다른 해결 방법은 경로를 먼저 다각형으로 변환 한 다음 대신 다각형을 그리는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bfd7f227d024c4ca96574c2818716e9c5deea964" translate="yes" xml:space="preserve">
          <source>The output contains one &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element for each &lt;code&gt;xml:id&lt;/code&gt; attribute in the cookbook. Note that &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; puts each attribute in the right place in its &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element, despite the fact that in the</source>
          <target state="translated">출력 은 요리 책의 각 &lt;code&gt;xml:id&lt;/code&gt; 속성에 대해 하나의 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 요소를 포함 합니다. 참고 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery를가&lt;/a&gt; 그 적절한 장소에 각 속성을두고 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 사실에도 불구하고, 요소의 해당</target>
        </trans-unit>
        <trans-unit id="411ab6817bdffdc71ef78ed59f78d2bdf2c45353" translate="yes" xml:space="preserve">
          <source>The output contains the CAN identifier in hexadecimal format, right adjusted to 32 bit, followed by the data length in square brackets and the payload in hexadecimal format.</source>
          <target state="translated">출력은 16 비트 형식의 CAN 식별자를 포함하고 오른쪽으로 32 비트로 조정 한 다음 대괄호로 묶은 데이터 길이와 16 진수 형식으로 된 페이로드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="5f3292ce52901dd72bc842fbe3ca41e1d1588ed2" translate="yes" xml:space="preserve">
          <source>The output file name as a string. An empty file name indicates that the printer should not print to a file.</source>
          <target state="translated">출력 파일 이름을 문자열로 나타냅니다. 빈 파일 이름은 프린터가 파일로 인쇄하지 않아야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4d7cc3480d6a66ade4aa9aec728a051924b91606" translate="yes" xml:space="preserve">
          <source>The output from the .depend_command is interpreted to be one file per line. The default is to split on whitespace and is maintained only for backwards compatibility reasons.</source>
          <target state="translated">.depend_command의 출력은 한 줄에 하나의 파일로 해석됩니다. 기본값은 공백으로 분할되며 이전 버전과의 호환성을 위해서만 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b29a2bb64d04d9ffe98c2b44d5b074cdfc43df7a" translate="yes" xml:space="preserve">
          <source>The output from the &lt;a href=&quot;qml-qtquick-shadereffect#fragmentShader-prop&quot;&gt;fragmentShader&lt;/a&gt; should be premultiplied. If &lt;a href=&quot;qml-qtquick-shadereffect#blending-prop&quot;&gt;blending&lt;/a&gt; is enabled, source-over blending is used. However, additive blending can be achieved by outputting zero in the alpha channel.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-shadereffect#fragmentShader-prop&quot;&gt;fragmentShader&lt;/a&gt; 의 출력은 미리 곱해야합니다. 경우 &lt;a href=&quot;qml-qtquick-shadereffect#blending-prop&quot;&gt;혼합이&lt;/a&gt; 활성화되어, 소스를 통해 혼합이 사용됩니다. 그러나, 알파 채널에서 0을 출력함으로써 부가적인 혼합이 달성 될 수있다.</target>
        </trans-unit>
        <trans-unit id="77a2e2658403564c58301e3e7304fc897c318918" translate="yes" xml:space="preserve">
          <source>The output is generated using the &lt;a href=&quot;qloggingcategory#qCDebug&quot;&gt;qCDebug&lt;/a&gt;, &lt;a href=&quot;qloggingcategory#qCWarning&quot;&gt;qCWarning&lt;/a&gt;, or &lt;a href=&quot;qloggingcategory#qCCritical&quot;&gt;qCCritical&lt;/a&gt; methods in C++, with a category of &lt;code&gt;qml&lt;/code&gt; or &lt;code&gt;js&lt;/code&gt;, depending on the type of file doing the logging. See also &lt;a href=&quot;debug#&quot;&gt;Debugging Techniques&lt;/a&gt;.</source>
          <target state="translated">로깅을 수행하는 파일 유형에 따라 &lt;code&gt;qml&lt;/code&gt; 또는 &lt;code&gt;js&lt;/code&gt; 범주의 C ++에서 &lt;a href=&quot;qloggingcategory#qCDebug&quot;&gt;qCDebug&lt;/a&gt; , &lt;a href=&quot;qloggingcategory#qCWarning&quot;&gt;qCWarning&lt;/a&gt; 또는 &lt;a href=&quot;qloggingcategory#qCCritical&quot;&gt;qCCritical&lt;/a&gt; 메소드를 사용하여 출력이 생성됩니다 . &lt;a href=&quot;debug#&quot;&gt;디버깅 기법&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="99d3951b4bf562c80fd9e0568b5c99ef8d76c772" translate="yes" xml:space="preserve">
          <source>The output is the destination pixel. This means that the blending has no effect. This mode is the inverse of CompositionMode_Source.</source>
          <target state="translated">출력은 대상 픽셀입니다. 이는 혼합이 효과가 없음을 의미합니다. 이 모드는 CompositionMode_Source와 반대입니다.</target>
        </trans-unit>
        <trans-unit id="a1dd1c85f70b94dc23efb45e4a5c63bb04789991" translate="yes" xml:space="preserve">
          <source>The output is the destination, where the alpha is reduced by that of the source. This mode is the inverse of CompositionMode_SourceIn.</source>
          <target state="translated">출력은 대상이며, 소스의 알파만큼 알파가 줄어 듭니다. 이 모드는 CompositionMode_SourceIn의 반대입니다.</target>
        </trans-unit>
        <trans-unit id="8100ae818f81dcc890be4cd54fdaff0c65cb92ed" translate="yes" xml:space="preserve">
          <source>The output is the destination, where the alpha is reduced by the inverse of the source. This mode is the inverse of CompositionMode_SourceOut.</source>
          <target state="translated">출력은 대상이며, 소스의 역수에 따라 알파가 줄어 듭니다. 이 모드는 CompositionMode_SourceOut과 반대입니다.</target>
        </trans-unit>
        <trans-unit id="26fb05444884e172dff424fb76479fd651fa6735" translate="yes" xml:space="preserve">
          <source>The output is the source color multiplied by the destination. Multiplying a color with white leaves the color unchanged, while multiplying a color with black produces black.</source>
          <target state="translated">출력은 소스 색상에 대상을 곱한 것입니다. 색상에 흰색을 곱하면 색상이 변경되지 않고 색상에 검정색을 곱하면 검정색이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5f3d65818523e229e909fdfbc05d11514e547be4" translate="yes" xml:space="preserve">
          <source>The output is the source pixel. (This means a basic copy operation and is identical to SourceOver when the source pixel is opaque).</source>
          <target state="translated">출력은 소스 픽셀입니다. (이것은 기본 복사 작업을 의미하며 소스 픽셀이 불투명 한 경우 SourceOver와 동일합니다).</target>
        </trans-unit>
        <trans-unit id="a215ef12d0bb2eec025243b7191b6504ecd820bb" translate="yes" xml:space="preserve">
          <source>The output is the source, where the alpha is reduced by that of the destination.</source>
          <target state="translated">출력은 소스이며 알파는 대상의 알파만큼 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="4fad5f841deebaf789dadebb4b4e5716df4c0dc6" translate="yes" xml:space="preserve">
          <source>The output is the source, where the alpha is reduced by the inverse of destination.</source>
          <target state="translated">출력은 소스이며 대상의 역수에 따라 알파가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="7e4ecf7084818db5ab94d367b5e1b0fe8fb9961b" translate="yes" xml:space="preserve">
          <source>The output list contains both items whose &lt;a href=&quot;qgraphicsitem#boundingRect&quot;&gt;bounding rectangle&lt;/a&gt; is fully contained inside the selection area, and items that intersect with the area's outline. This method is commonly used for determining areas that need redrawing.</source>
          <target state="translated">출력 목록에는 선택 영역 안에 &lt;a href=&quot;qgraphicsitem#boundingRect&quot;&gt;경계 사각형&lt;/a&gt; 이 완전히 포함 된 항목과 영역 개요와 교차하는 항목이 모두 포함됩니다. 이 방법은 일반적으로 다시 그리기가 필요한 영역을 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1f0070f2a900424d1f96b5d5e0b8501124f6ecd2" translate="yes" xml:space="preserve">
          <source>The output list contains both items whose &lt;a href=&quot;qgraphicsitem#shape&quot;&gt;shape&lt;/a&gt; is fully contained inside the selection area, and items that intersect with the area's outline. This is a common mode for rubber band selection.</source>
          <target state="translated">출력 목록에는 &lt;a href=&quot;qgraphicsitem#shape&quot;&gt;모양&lt;/a&gt; 이 선택 영역 안에 완전히 포함 된 항목과 영역의 외곽선과 교차하는 항목이 모두 포함됩니다. 이것은 고무 밴드 선택을위한 공통 모드입니다.</target>
        </trans-unit>
        <trans-unit id="3d331e459020cfb9fc66478237b344bcebffe9ee" translate="yes" xml:space="preserve">
          <source>The output list contains only items whose &lt;a href=&quot;qgraphicsitem#boundingRect&quot;&gt;bounding rectangle&lt;/a&gt; is fully contained inside the selection area. Items that intersect with the area's outline are not included.</source>
          <target state="translated">출력 목록에는 선택 영역 안에 &lt;a href=&quot;qgraphicsitem#boundingRect&quot;&gt;경계 사각형&lt;/a&gt; 이 완전히 포함 된 항목 만 포함됩니다 . 영역의 개요와 교차하는 항목은 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04ed93c6f68ae01798fd7e29464bc10ccd7c5f39" translate="yes" xml:space="preserve">
          <source>The output list contains only items whose &lt;a href=&quot;qgraphicsitem#shape&quot;&gt;shape&lt;/a&gt; is fully contained inside the selection area. Items that intersect with the area's outline are not included.</source>
          <target state="translated">출력 목록에는 &lt;a href=&quot;qgraphicsitem#shape&quot;&gt;모양&lt;/a&gt; 이 선택 영역 안에 완전히 포함 된 항목 만 포함됩니다 . 영역의 개요와 교차하는 항목은 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b776eacfd02ec256d4debba369cdca20c12c7a3" translate="yes" xml:space="preserve">
          <source>The output prefix is applied to file names for documentation on QML and JS types.</source>
          <target state="translated">출력 접 두부는 QML 및 JS 유형에 대한 문서화를 위해 파일 이름에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6670e433d0d98333d102d91061e45a53981533a8" translate="yes" xml:space="preserve">
          <source>The output produced by &lt;code&gt;moc&lt;/code&gt; must be compiled and linked, just like the other C++ code in your program; otherwise, the build will fail in the final link phase. If you use &lt;code&gt;qmake&lt;/code&gt;, this is done automatically. Whenever &lt;code&gt;qmake&lt;/code&gt; is run, it parses the project's header files and generates make rules to invoke &lt;code&gt;moc&lt;/code&gt; for those files that contain a &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; macro.</source>
          <target state="translated">&lt;code&gt;moc&lt;/code&gt; 에 의해 생성 된 출력은 프로그램의 다른 C ++ 코드와 마찬가지로 컴파일 및 링크되어야합니다. 그렇지 않으면 최종 링크 단계에서 빌드가 실패합니다. &lt;code&gt;qmake&lt;/code&gt; 를 사용하면 자동으로 수행됩니다. &lt;code&gt;qmake&lt;/code&gt; 가 실행될 때마다 프로젝트의 헤더 파일을 구문 분석하고 &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; 매크로 가 포함 된 파일에 대해 &lt;code&gt;moc&lt;/code&gt; 를 호출하는 make 규칙을 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="4f15159db80897d53757992bd8e51c2586459ab5" translate="yes" xml:space="preserve">
          <source>The output sent to the debug stream can, of course, be made as simple or as complicated as you like. Note that the value returned by this function is the &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; object itself, though this is often obtained by calling the &lt;a href=&quot;qdebug#maybeSpace&quot;&gt;maybeSpace()&lt;/a&gt; member function of &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; that pads out the stream with space characters to make it more readable.</source>
          <target state="translated">물론 디버그 스트림으로 전송되는 출력은 원하는만큼 간단하거나 복잡하게 만들 수 있습니다. 이 함수가 리턴 한 값은 &lt;a href=&quot;qdebug&quot;&gt;QDebug&lt;/a&gt; 오브젝트 자체이지만 , 스트림 문자를보다 읽기 쉽게 만들기 위해 스트림 을 &lt;a href=&quot;qdebug&quot;&gt;채우는 QDebug&lt;/a&gt; 의 &lt;a href=&quot;qdebug#maybeSpace&quot;&gt;maybeSpace ()&lt;/a&gt; 멤버 함수를 호출하여 종종 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fcce5e4a04185e08d10f94c13c4594d1dcc39e2" translate="yes" xml:space="preserve">
          <source>The overall size of the splitter widget is not affected. Instead, any additional/missing space is distributed amongst the widgets according to the relative weight of the sizes.</source>
          <target state="translated">스플리터 위젯의 전체 크기는 영향을받지 않습니다. 대신, 크기의 상대적 무게에 따라 위젯에 추가 / 누락 공간이 분배됩니다.</target>
        </trans-unit>
        <trans-unit id="fcef4e78961275c869f5460513bb25f1b748d6d9" translate="yes" xml:space="preserve">
          <source>The overlay icon and a description of the overlay for accessibility purposes.</source>
          <target state="translated">접근성 목적으로 오버레이 아이콘 및 오버레이에 대한 설명.</target>
        </trans-unit>
        <trans-unit id="0209f45bdbd868beb0be9e45c712a728d7885b93" translate="yes" xml:space="preserve">
          <source>The overlay is an ordinary Item that covers the entire window. It can be used as a visual parent to position a popup in scene coordinates.</source>
          <target state="translated">오버레이는 전체 창을 덮는 일반 항목입니다. 팝업을 장면 좌표에 배치하기 위해 시각적 부모로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1ba447c44a32dec06ffb94ab6cf74010f4773a7" translate="yes" xml:space="preserve">
          <source>The overload of this function that accepts an argument is used to test for the presence of files and directories within a directory.</source>
          <target state="translated">인수를 허용하는이 함수의 과부하는 디렉토리 내에 파일 및 디렉토리가 있는지 테스트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b820b1f4d905e35cff7da1a7b643140a4df95a22" translate="yes" xml:space="preserve">
          <source>The owernship of &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; is determined by the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; parent/child relationship between nodes. By itself, a &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; has no visual appearance and no particular meaning, it is there as a way of building a node based tree structure.</source>
          <target state="translated">QNode의 &lt;a href=&quot;qt3dcore-qnode&quot;&gt;소유권&lt;/a&gt; 은 노드 간의 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 상위 / 하위 관계에 의해 결정됩니다 . &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; 자체 는 시각적 인 외관과 특별한 의미가 없으며, 노드 기반 트리 구조를 구축하는 방법으로 존재합니다.</target>
        </trans-unit>
        <trans-unit id="7b86c886e00dd8c181f2d24ed9d9d54fb81ef850" translate="yes" xml:space="preserve">
          <source>The owner element is set to 0 and the specified flag is set to true in the generated attribute. The whole subtree of</source>
          <target state="translated">소유자 요소는 0으로 설정되고 지정된 플래그는 생성 된 속성에서 true로 설정됩니다. 전체 하위 트리</target>
        </trans-unit>
        <trans-unit id="dfc16103a44fd4348bc49314e7234e04c7be2661" translate="yes" xml:space="preserve">
          <source>The ownership of</source>
          <target state="translated">의 소유권</target>
        </trans-unit>
        <trans-unit id="915ca6143be0f5c2d967d8019ec60ec2d57675aa" translate="yes" xml:space="preserve">
          <source>The ownership of the removed widget is passed to the caller.</source>
          <target state="translated">제거 된 위젯의 소유권은 호출자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8f98165e157901e57cce31c795497279a1288ac4" translate="yes" xml:space="preserve">
          <source>The ownership of the returned object instance is transferred to the caller.</source>
          <target state="translated">리턴 된 오브젝트 인스턴스의 소유권이 호출자에게 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="3c60aa5b0eecbb467101d8abb1892491a6814ed8" translate="yes" xml:space="preserve">
          <source>The ownership of the returned object is passed to the caller.</source>
          <target state="translated">반환 된 객체의 소유권은 호출자에게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6deb584b06771205152e92a514f797c827a055f5" translate="yes" xml:space="preserve">
          <source>The padding falls inside the border, between the border and the actual contents.</source>
          <target state="translated">패딩은 테두리와 실제 내용 사이의 테두리 안에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0555e0cd7611a281aabb191d7c690827e75e0ed" translate="yes" xml:space="preserve">
          <source>The padding properties are used to control the geometry of the &lt;a href=&quot;qml-qtquick-controls2-popup#contentItem-prop&quot;&gt;content item&lt;/a&gt;.</source>
          <target state="translated">패딩 속성은 &lt;a href=&quot;qml-qtquick-controls2-popup#contentItem-prop&quot;&gt;컨텐트 항목&lt;/a&gt; 의 형상을 제어하는 ​​데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="15756453c954fc25a5b79dd66e7fa0538ed2ed10" translate="yes" xml:space="preserve">
          <source>The padding properties of a table cell are controlled by &lt;a href=&quot;qtexttablecellformat#setLeftPadding&quot;&gt;setLeftPadding&lt;/a&gt;(), &lt;a href=&quot;qtexttablecellformat#setRightPadding&quot;&gt;setRightPadding&lt;/a&gt;(), &lt;a href=&quot;qtexttablecellformat#setTopPadding&quot;&gt;setTopPadding&lt;/a&gt;(), and &lt;a href=&quot;qtexttablecellformat#setBottomPadding&quot;&gt;setBottomPadding&lt;/a&gt;(). All the paddings can be set at once using &lt;a href=&quot;qtexttablecellformat#setPadding&quot;&gt;setPadding&lt;/a&gt;().</source>
          <target state="translated">테이블 셀의 패딩 속성은 &lt;a href=&quot;qtexttablecellformat#setLeftPadding&quot;&gt;setLeftPadding&lt;/a&gt; (), &lt;a href=&quot;qtexttablecellformat#setRightPadding&quot;&gt;setRightPadding&lt;/a&gt; (), &lt;a href=&quot;qtexttablecellformat#setTopPadding&quot;&gt;setTopPadding&lt;/a&gt; () 및 &lt;a href=&quot;qtexttablecellformat#setBottomPadding&quot;&gt;setBottomPadding&lt;/a&gt; ()에 의해 제어됩니다 . 모든 패딩은 &lt;a href=&quot;qtexttablecellformat#setPadding&quot;&gt;setPadding&lt;/a&gt; ()을 사용하여 한 번에 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df74cc074d510d45f9e1c2b555263ef8227ab629" translate="yes" xml:space="preserve">
          <source>The page below covers specific issues and recommendations for creating macOS applications.</source>
          <target state="translated">아래 페이지는 macOS 응용 프로그램을 만들기위한 특정 문제 및 권장 사항을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9b5093f3db5bc451c72959872bfb04c4a29b05c9" translate="yes" xml:space="preserve">
          <source>The page break is determined automatically depending on the available space on the current page</source>
          <target state="translated">페이지 나누기는 현재 페이지에서 사용 가능한 공간에 따라 자동으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="eda266ecfa89e828ef98dc69914bf210adbda05e" translate="yes" xml:space="preserve">
          <source>The page could not be loaded.</source>
          <target state="translated">페이지를로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="64204621edb7f31576bbe26715508d66e7923b60" translate="yes" xml:space="preserve">
          <source>The page does not take ownership of the pointer. This interceptor is called after any interceptors on the profile, and unlike profile interceptors, is run on the UI thread, making it thread-safer. Only URL requests from this page are intercepted.</source>
          <target state="translated">페이지가 포인터의 소유권을 갖지 않습니다. 이 인터셉터는 프로파일의 인터셉터가 호출 된 후 호출되며 프로파일 인터셉터와 달리 UI 스레드에서 실행되어 스레드를 스레드로 만듭니다. 이 페이지의 URL 요청 만 인터셉트됩니다.</target>
        </trans-unit>
        <trans-unit id="29c38f683dc2bfe87ea69b49b738a6151865430f" translate="yes" xml:space="preserve">
          <source>The page is always broken before the paragraph/table</source>
          <target state="translated">페이지는 항상 단락 / 테이블 앞에 나옵니다.</target>
        </trans-unit>
        <trans-unit id="88ed99f2efe483320c5a59d298c1e43f1a5cfca6" translate="yes" xml:space="preserve">
          <source>The page is currently loading.</source>
          <target state="translated">페이지가 현재로드 중입니다.</target>
        </trans-unit>
        <trans-unit id="f4978602e624e1b74e6bcc2a0e3023146eb38d54" translate="yes" xml:space="preserve">
          <source>The page is saved as a complete HTML page, for example a directory containing the single HTML page and the resources.</source>
          <target state="translated">페이지는 완전한 HTML 페이지 (예 : 단일 HTML 페이지와 리소스를 포함하는 디렉토리)로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="81ffe16fd35017568d391f4125f62dd12b1059e1" translate="yes" xml:space="preserve">
          <source>The page is saved as a complete web page in the MIME HTML format.</source>
          <target state="translated">페이지는 MIME HTML 형식의 완전한 웹 페이지로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="eefc877ff381a978db10529b95d5418ec751fbb1" translate="yes" xml:space="preserve">
          <source>The page is saved as a single HTML page. Resources such as images are not saved.</source>
          <target state="translated">페이지는 단일 HTML 페이지로 저장됩니다. 이미지와 같은 리소스는 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c0eddb08cdb3642cdd5fb4b873a9676877ec11d" translate="yes" xml:space="preserve">
          <source>The page itself (the &lt;a href=&quot;qwizardpage&quot;&gt;QWizardPage&lt;/a&gt; widget) occupies the area between the header, the watermark, and the button row. Typically, the page is a &lt;a href=&quot;qwizardpage&quot;&gt;QWizardPage&lt;/a&gt; on which a &lt;a href=&quot;qgridlayout&quot;&gt;QGridLayout&lt;/a&gt; is installed, with standard child widgets (&lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt;s, &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt;s, etc.).</source>
          <target state="translated">페이지 자체 ( &lt;a href=&quot;qwizardpage&quot;&gt;QWizardPage&lt;/a&gt; 위젯)는 헤더, 워터 마크 및 버튼 행 사이의 영역을 차지합니다. 일반적으로, 페이지가있다 &lt;a href=&quot;qwizardpage&quot;&gt;QWizardPage&lt;/a&gt; 되는 &lt;a href=&quot;qgridlayout&quot;&gt;QGridLayout은&lt;/a&gt; 표준 아이 위젯 (함께 설치되어 &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; S, &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; S 등).</target>
        </trans-unit>
        <trans-unit id="e7c8312bf3b9248866b642035b9d2f1253f6ac41" translate="yes" xml:space="preserve">
          <source>The page order can be &lt;a href=&quot;qprinter#PageOrder-enum&quot;&gt;QPrinter::FirstPageFirst&lt;/a&gt; or &lt;a href=&quot;qprinter#PageOrder-enum&quot;&gt;QPrinter::LastPageFirst&lt;/a&gt;. The application is responsible for reading the page order and printing accordingly.</source>
          <target state="translated">페이지 순서는 &lt;a href=&quot;qprinter#PageOrder-enum&quot;&gt;QPrinter :: FirstPageFirst&lt;/a&gt; 또는 &lt;a href=&quot;qprinter#PageOrder-enum&quot;&gt;QPrinter :: LastPageFirst&lt;/a&gt; 입니다. 응용 프로그램은 페이지 순서를 읽고 그에 따라 인쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="562c595d74cb00bc6a9591fa9e21819a0a18aed5" translate="yes" xml:space="preserve">
          <source>The page orientation is used to define the orientation of the page size when obtaining the page rect.</source>
          <target state="translated">페이지 방향은 페이지 rect를 얻을 때 페이지 크기의 방향을 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f82647c365557c247497bd6118dfab23ea9cb0ca" translate="yes" xml:space="preserve">
          <source>The page range selection option is enabled.</source>
          <target state="translated">페이지 범위 선택 옵션이 활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="68f9565a719f578f5234302eaa15f9f327fc35c7" translate="yes" xml:space="preserve">
          <source>The page rectangle takes into account the page size and page orientation, but not the page margins.</source>
          <target state="translated">페이지 사각형은 페이지 크기와 페이지 방향을 고려하지만 페이지 여백은 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="141a33f1c581a8cb8a505a6c10fe2ea30591b4c2" translate="yes" xml:space="preserve">
          <source>The page size is defined by the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; class which can be queried for page size attributes. Note that the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; itself is always defined in a Portrait orientation.</source>
          <target state="translated">페이지 크기는 &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; 클래스에 의해 정의되며 페이지 크기 속성에 대해 쿼리 할 수 ​​있습니다. 있습니다 &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; 자체가 항상 세로 방향으로 정의된다.</target>
        </trans-unit>
        <trans-unit id="612a2ce64b5ac0190f6c20baa0e9d73a931fb023" translate="yes" xml:space="preserve">
          <source>The page size is rotated through 90 degrees</source>
          <target state="translated">페이지 크기가 90도 회전</target>
        </trans-unit>
        <trans-unit id="b2a522e93343be3a92a368236b91047d18c4e3c9" translate="yes" xml:space="preserve">
          <source>The page size is used in its default orientation</source>
          <target state="translated">페이지 크기는 기본 방향으로 사용됩니다</target>
        </trans-unit>
        <trans-unit id="e1b961c6f1be4675b15067ca55e4f924fa2849e6" translate="yes" xml:space="preserve">
          <source>The page size may be invalid if created with an invalid &lt;a href=&quot;qpagesize#PageSizeId-enum&quot;&gt;PageSizeId&lt;/a&gt;, or a negative or invalid &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; or &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt;, or the null constructor.</source>
          <target state="translated">유효하지 않은 &lt;a href=&quot;qpagesize#PageSizeId-enum&quot;&gt;PageSizeId&lt;/a&gt; 또는 음수 또는 유효하지 않은 &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; 또는 &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; 또는 널 생성자로 작성된 경우 페이지 크기가 유효하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1c18999d468199fce0bd86cea4df459b45f0440" translate="yes" xml:space="preserve">
          <source>The page was loaded successfully.</source>
          <target state="translated">페이지가 성공적으로로드되었습니다.</target>
        </trans-unit>
        <trans-unit id="cfd2ecc91c3780155ba977d2c36348f401070717" translate="yes" xml:space="preserve">
          <source>The pages are independent of each other (i.e., they don't derive values from each other).</source>
          <target state="translated">페이지는 서로 독립적입니다 (즉, 서로 값을 파생하지 않음).</target>
        </trans-unit>
        <trans-unit id="863018a2ca4efde2aaebf324da6606d7931937c6" translate="yes" xml:space="preserve">
          <source>The pages are inserted using &lt;a href=&quot;qwizard#setPage&quot;&gt;setPage&lt;/a&gt;(), which takes an ID and an instance of &lt;a href=&quot;qwizardpage&quot;&gt;QWizardPage&lt;/a&gt; (or of a subclass):</source>
          <target state="translated">페이지는 &lt;a href=&quot;qwizard#setPage&quot;&gt;setPage&lt;/a&gt; ()를 사용하여 삽입 되며, ID와 &lt;a href=&quot;qwizardpage&quot;&gt;QWizardPage&lt;/a&gt; 인스턴스 (또는 서브 클래스)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="888c87a9e18107632e2e1cd7b6ec29c5887f7b87" translate="yes" xml:space="preserve">
          <source>The pages below covers specific issues and recommendations for creating Linux/X11 applications.</source>
          <target state="translated">아래 페이지는 Linux / X11 응용 프로그램 작성에 대한 특정 문제 및 권장 사항을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="552adb7722f0eb4e3a2bac3733b0f3573fe57ce4" translate="yes" xml:space="preserve">
          <source>The pages below covers specific issues and recommendations for creating Windows applications.</source>
          <target state="translated">아래 페이지는 Windows 응용 프로그램을 만들기위한 특정 문제 및 권장 사항을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="180353bf23f5714553635d368a2715196f1ae862" translate="yes" xml:space="preserve">
          <source>The paint system also provides the &lt;a href=&quot;qstylepainter&quot;&gt;QStylePainter&lt;/a&gt; class inheriting from &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;. &lt;a href=&quot;qstylepainter&quot;&gt;QStylePainter&lt;/a&gt; is a convenience class for drawing &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; elements inside a widget, and extends &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; with a set of high-level drawing functions implemented on top of &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;'s API. The advantage of using &lt;a href=&quot;qstylepainter&quot;&gt;QStylePainter&lt;/a&gt; is that the parameter lists get considerably shorter.</source>
          <target state="translated">페인트 시스템 은 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 로부터 상속되는 &lt;a href=&quot;qstylepainter&quot;&gt;QStylePainter&lt;/a&gt; 클래스 도 제공합니다 . &lt;a href=&quot;qstylepainter&quot;&gt;QStylePainter&lt;/a&gt; 는 위젯 내에서 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 요소 를 그리기위한 편리한 클래스 이며 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 의 API 위에 구현 된 일련의 고급 그리기 기능 으로 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 를 확장 합니다. &lt;a href=&quot;qstylepainter&quot;&gt;QStylePainter&lt;/a&gt; 를 사용 하면 매개 변수 목록이 상당히 짧아 진다 는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="443f0ade94bfb5304bcc72677fad825252c9c904" translate="yes" xml:space="preserve">
          <source>The paint system automatically uses the correct device metrics when painting text but, if you need to position text using information obtained from font metrics, you need to ensure that the print device is specified when you construct &lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt; and &lt;a href=&quot;qfontmetricsf&quot;&gt;QFontMetricsF&lt;/a&gt; objects, or ensure that each &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; used is constructed using the form of the constructor that accepts a &lt;a href=&quot;qpaintdevice&quot;&gt;QPaintDevice&lt;/a&gt; argument.</source>
          <target state="translated">페인트 시스템은 텍스트를 페인팅 할 때 자동으로 올바른 장치 메트릭을 사용하지만 글꼴 메트릭에서 얻은 정보를 사용하여 텍스트를 배치해야하는 경우 &lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt; 및 &lt;a href=&quot;qfontmetricsf&quot;&gt;QFontMetricsF&lt;/a&gt; 객체 를 생성 할 때 인쇄 장치를 지정 하거나 각 &lt;a href=&quot;qfont&quot;&gt;QFont를&lt;/a&gt; 확인해야합니다 used는 &lt;a href=&quot;qpaintdevice&quot;&gt;QPaintDevice&lt;/a&gt; 인수 를 허용하는 생성자의 형식을 사용하여 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="f001ef2e2f9a36349371e10410b4ac83d4da4b32" translate="yes" xml:space="preserve">
          <source>The paintable rectangle takes into account the page size, orientation and margins.</source>
          <target state="translated">페인트 가능한 사각형은 페이지 크기, 방향 및 여백을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="4123963d438c1cdc3e71f7749ada95f3b7c93e0c" translate="yes" xml:space="preserve">
          <source>The painter path generated by the &lt;a href=&quot;qpainterpathstroker#createStroke&quot;&gt;createStroke&lt;/a&gt;() function should only be used for outlining the given painter path. Otherwise it may cause unexpected behavior. Generated outlines also require the &lt;a href=&quot;qt#FillRule-enum&quot;&gt;Qt::WindingFill&lt;/a&gt; rule which is set by default.</source>
          <target state="translated">&lt;a href=&quot;qpainterpathstroker#createStroke&quot;&gt;createStroke&lt;/a&gt; () 함수에 의해 생성 된 페인터 경로는 주어진 페인터 경로를 나타내는 데만 사용해야합니다. 그렇지 않으면 예기치 않은 동작이 발생할 수 있습니다. 생성 된 아웃 라인에는 기본적으로 설정된 &lt;a href=&quot;qt#FillRule-enum&quot;&gt;Qt :: WindingFill&lt;/a&gt; 규칙 도 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="8d1d69c93bafeec830424ba8002f90bf9cb38951" translate="yes" xml:space="preserve">
          <source>The painter path is initially empty when constructed. We first add a rectangle, which is a closed subpath. Then we add two bezier curves which together form a closed subpath even though they are not closed individually. Finally we draw the entire path. The path is filled using the default fill rule, &lt;a href=&quot;qt#FillRule-enum&quot;&gt;Qt::OddEvenFill&lt;/a&gt;. Qt provides two methods for filling paths:</source>
          <target state="translated">페인터 경로는 처음에 비어 있습니다. 먼저 닫힌 서브 패스 인 사각형을 추가합니다. 그런 다음 개별적으로 닫히지 않더라도 닫힌 서브 패스를 형성하는 두 개의 베 지어 곡선을 추가합니다. 마지막으로 전체 경로를 그립니다. 경로는 기본 채우기 규칙 &lt;a href=&quot;qt#FillRule-enum&quot;&gt;Qt :: OddEvenFill을&lt;/a&gt; 사용하여 채워 집니다 . Qt는 경로를 채우는 두 가지 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3cbe73ebbfc0f2f93fbd3d527f7ceedf2e8201b6" translate="yes" xml:space="preserve">
          <source>The painter's brush defines how shapes are filled.</source>
          <target state="translated">화가의 붓은 도형이 채워지는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="21a1a172af2938ddc5f90c3c1f73624b9d557d92" translate="yes" xml:space="preserve">
          <source>The painter's pen is 0-width by default, and its pen is initialized to the &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette::Text&lt;/a&gt; brush from the paint device's palette. The brush is initialized to &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette::Window&lt;/a&gt;.</source>
          <target state="translated">페인터의 펜은 기본적으로 너비가 0이며 펜은 페인트 장치의 팔레트에서 &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette :: Text&lt;/a&gt; 브러시로 초기화됩니다 . 브러시는 &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette :: Window로&lt;/a&gt; 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="0106a6f0d3158fae33109041c59588aa489bccf3" translate="yes" xml:space="preserve">
          <source>The painting of check box indicators are performed by the current style. The style also specifies the size and the bounding rectangles in which to draw the data for the different data roles. The bounding rectangle of the item itself is also calculated by the style. When drawing already supported datatypes, it is therefore a good idea to ask the style for these bounding rectangles. The &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; class description describes this in more detail.</source>
          <target state="translated">확인란 표시기 그림은 현재 스타일에 따라 수행됩니다. 스타일은 또한 다른 데이터 역할에 대한 데이터를 그릴 크기와 경계 사각형을 지정합니다. 항목 자체의 경계 사각형도 스타일로 계산됩니다. 이미 지원되는 데이터 유형을 그릴 때 이러한 경계 사각형의 스타일을 요청하는 것이 좋습니다. &lt;a href=&quot;qstyle&quot;&gt;QStyle의&lt;/a&gt; 클래스 설명을 더 자세하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ddceefbb595f96897d0d773ae80e034a4001e747" translate="yes" xml:space="preserve">
          <source>The painting of items in views is performed by a delegate. Qt's default delegate, &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;, is also used for calculating bounding rectangles of items, and their sub-elements for the various kind of item &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;data roles&lt;/a&gt;&lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; supports. See the &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; class description to find out which datatypes and roles are supported. You can read more about item data roles in &lt;a href=&quot;model-view-programming#&quot;&gt;Model/View Programming&lt;/a&gt;.</source>
          <target state="translated">뷰의 항목 그림은 대리인이 수행합니다. Qt의 기본 대리자 인 &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; 는 항목의 경계 사각형 및 &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate가&lt;/a&gt; 지원 하는 다양한 종류의 항목 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;데이터 역할에&lt;/a&gt; 대한 하위 요소를 계산하는 데에도 사용됩니다 . 지원되는 데이터 유형 및 역할을 찾으 려면 &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; 클래스 설명을 참조하십시오 . &lt;a href=&quot;model-view-programming#&quot;&gt;모델 / 뷰 프로그래밍&lt;/a&gt; 에서 아이템 데이터 역할에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2578f1526d1d3bc4e7da302ac64f8208da590a60" translate="yes" xml:space="preserve">
          <source>The palette may be changed according to the current GUI style in &lt;a href=&quot;qstyle#polish&quot;&gt;QStyle::polish&lt;/a&gt;().</source>
          <target state="translated">팔레트는 &lt;a href=&quot;qstyle#polish&quot;&gt;QStyle :: polish&lt;/a&gt; () 의 현재 GUI 스타일에 따라 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="566bfb6d15bcaa55273b1d60a13fb33b21da202e" translate="yes" xml:space="preserve">
          <source>The pane (frame) of a &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt;.</source>
          <target state="translated">(A)의 창 (프레임) &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="42d5db4cda89bb4ff994f5b47830a116f33078d3" translate="yes" xml:space="preserve">
          <source>The panel and empty area are drawn after the menu items. The &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; that the &lt;a href=&quot;qmenubar&quot;&gt;QMenuBar&lt;/a&gt; sends to the style has the bounding rectangles of the items clipped out (i.e., clip region), so you don't need to worry about drawing over the items. The pixel metrics in &lt;a href=&quot;qmenubar&quot;&gt;QMenuBar&lt;/a&gt; are used when the bounding rectangles of the menu bar items are calculated.</source>
          <target state="translated">메뉴 항목 다음에 패널과 빈 영역이 그려집니다. &lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; 것을 &lt;a href=&quot;qmenubar&quot;&gt;QMenuBar는&lt;/a&gt; 당신이 항목을 통해 그림에 대해 걱정할 필요가 없습니다 스타일로 전송이 밖으로 잘린 항목 (즉, 클립 영역)의 경계 사각형을 가지고있다. &lt;a href=&quot;qmenubar&quot;&gt;QMenuBar&lt;/a&gt; 의 픽셀 메트릭 은 메뉴 막대 항목의 경계 사각형을 계산할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="45c448239a0b44a927bb9010cbceff67cff90f8f" translate="yes" xml:space="preserve">
          <source>The panel component for this style.</source>
          <target state="translated">이 스타일의 패널 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="72a22be1d2f81a89a5aeae9a573e69b63fa13743" translate="yes" xml:space="preserve">
          <source>The panel for a menu.</source>
          <target state="translated">메뉴의 패널입니다.</target>
        </trans-unit>
        <trans-unit id="88791e3f08e4bf476d1f4d95a3ded17aebc86be8" translate="yes" xml:space="preserve">
          <source>The panel for a status bar.</source>
          <target state="translated">상태 표시 줄의 패널입니다.</target>
        </trans-unit>
        <trans-unit id="e31287a67db81a5d9bba7da4605aa894db851a52" translate="yes" xml:space="preserve">
          <source>The panel for a tip label.</source>
          <target state="translated">팁 레이블의 패널입니다.</target>
        </trans-unit>
        <trans-unit id="92a48999619746b7ddc023b0d100a75e2fb3d8a2" translate="yes" xml:space="preserve">
          <source>The panel for a toolbar.</source>
          <target state="translated">툴바의 패널입니다.</target>
        </trans-unit>
        <trans-unit id="a96a55ff92d8936ba7df678fe54ad00d380ff7f9" translate="yes" xml:space="preserve">
          <source>The panel is modal to a single item hierarchy and blocks input to its parent pane, all grandparent panels, and all siblings of its parent and grandparent panels.</source>
          <target state="translated">이 패널은 단일 항목 계층 구조에 모달이며 상위 창, 모든 조부모 패널 및 상위 및 조부모 패널의 모든 형제에 대한 입력을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="3af1c22846e50bfcc558ce9e04c711e5ac9e5115" translate="yes" xml:space="preserve">
          <source>The panel is not modal and does not block input to other panels. This is the default value for panels.</source>
          <target state="translated">이 패널은 모달이 아니며 다른 패널에 대한 입력을 차단하지 않습니다. 이것이 패널의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="4b1bfd1216254568527a8ea615d71edeff564cc2" translate="yes" xml:space="preserve">
          <source>The panel is set into operation by setting the &lt;a href=&quot;qml-qtquick-virtualkeyboard-handwritinginputpanel#available-prop&quot;&gt;available&lt;/a&gt; property to &lt;code&gt;true&lt;/code&gt;. When the panel is in operation, the keyboard remains hidden when the input focus is set. When &lt;code&gt;available&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, handwriting input is activated by setting the &lt;a href=&quot;qml-qtquick-virtualkeyboard-handwritinginputpanel#active-prop&quot;&gt;active&lt;/a&gt; property to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-virtualkeyboard-handwritinginputpanel#available-prop&quot;&gt;available&lt;/a&gt; 속성을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 패널이 작동 합니다 . 패널이 작동 중일 때 입력 포커스가 설정되면 키보드가 숨겨져 있습니다. 되면 &lt;code&gt;available&lt;/code&gt; 하다 &lt;code&gt;true&lt;/code&gt; 필기 입력을 상기 설정에 의해 활성화되어 &lt;a href=&quot;qml-qtquick-virtualkeyboard-handwritinginputpanel#active-prop&quot;&gt;활성&lt;/a&gt; 에 속성 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="735dfe8f51791d3117d33ecc84c95f6803af8279" translate="yes" xml:space="preserve">
          <source>The parallelism in the State Machine framework follows an interleaved semantics. All parallel operations will be executed in a single, atomic step of the event processing, so no event can interrupt the parallel operations. However, events will still be processed sequentially, as the machine itself is single threaded. For example, consider the situation where there are two transitions that exit the same parallel state group, and their conditions become true simultaneously. In this case, the event that is processed last of the two will not have any effect.</source>
          <target state="translated">State Machine 프레임 워크의 병렬 처리는 인터리브 의미론을 따릅니다. 모든 병렬 작업은 이벤트 처리의 단일 원자 단계에서 실행되므로 이벤트가 병렬 작업을 중단 할 수 없습니다. 그러나 머신 자체는 단일 스레드이므로 이벤트는 계속 순차적으로 처리됩니다. 예를 들어, 동일한 병렬 상태 그룹을 종료하는 두 개의 전이가 있고 해당 조건이 동시에 참인 상황을 고려하십시오. 이 경우 두 가지 중 마지막으로 처리 된 이벤트는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9c765e4bac1fd37cd3da05bed1efe3ac75c24c8" translate="yes" xml:space="preserve">
          <source>The parallelism in the State Machine framework follows an interleaved semantics. All parallel operations will be executed in a single, atomic step of the event processing, so no event can interrupt the parallel operations. However, events will still be processed sequentially, since the machine itself is single threaded. As an example: Consider the situation where there are two transitions that exit the same parallel state group, and their conditions become true simultaneously. In this case, the event that is processed last of the two will not have any effect, since the first event will already have caused the machine to exit from the parallel state.</source>
          <target state="translated">State Machine 프레임 워크의 병렬 처리는 인터리브 의미론을 따릅니다. 모든 병렬 작업은 이벤트 처리의 단일 원자 단계에서 실행되므로 이벤트가 병렬 작업을 중단 할 수 없습니다. 그러나 머신 자체는 단일 스레드이므로 이벤트는 계속 순차적으로 처리됩니다. 예를 들어, 동일한 병렬 상태 그룹을 종료하는 두 개의 전이가 있고 해당 조건이 동시에 적용되는 상황을 고려하십시오. 이 경우 두 이벤트 중 마지막으로 처리 된 이벤트는 아무런 영향을 미치지 않습니다. 첫 번째 이벤트로 인해 머신이 병렬 상태에서 이미 종료 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="784cb28a84eb456a412592e7c8f03f7f73dee959" translate="yes" xml:space="preserve">
          <source>The parameter</source>
          <target state="translated">매개 변수</target>
        </trans-unit>
        <trans-unit id="7561eca069691e915947678d30e361f9de4f8013" translate="yes" xml:space="preserve">
          <source>The parameter given with the gestureStarted signal. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">gestureStarted 신호와 함께 제공된 매개 변수입니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2ba944785a9a2fc710a85c160ba5a41b3628825d" translate="yes" xml:space="preserve">
          <source>The parameter holds the</source>
          <target state="translated">매개 변수는</target>
        </trans-unit>
        <trans-unit id="2a5a3bd056afed08e5aced10965ea2ba16bedae8" translate="yes" xml:space="preserve">
          <source>The parameter to this function should be one of the types reported by the &lt;a href=&quot;qaudiodeviceinfo#supportedCodecs&quot;&gt;QAudioDeviceInfo::supportedCodecs&lt;/a&gt;() function for the audio device you are working with.</source>
          <target state="translated">이 함수의 매개 변수 는 작업중인 오디오 장치 에 대한 &lt;a href=&quot;qaudiodeviceinfo#supportedCodecs&quot;&gt;QAudioDeviceInfo :: supportedCodecs&lt;/a&gt; () 함수에 의해보고되는 유형 중 하나 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="6b1ad09038b422ea553ab204de402529e9b64c23" translate="yes" xml:space="preserve">
          <source>The parameter value to be used with this key is a &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;. An icon with this parameter set will always return the specified URL regardless of the requested size when &lt;a href=&quot;qplaceicon#url&quot;&gt;url&lt;/a&gt;() is called.</source>
          <target state="translated">이 키와 함께 사용되는 매개 변수 값은 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 입니다. 이 매개 변수가 설정된 아이콘은 &lt;a href=&quot;qplaceicon#url&quot;&gt;url&lt;/a&gt; ()이 호출 될 때 요청 된 크기에 관계없이 항상 지정된 URL을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7ddad8d495816a1c4029ec1a45ce8e83e779b86c" translate="yes" xml:space="preserve">
          <source>The parameters &lt;a href=&quot;qgraphicsscale#xScale-prop&quot;&gt;xScale&lt;/a&gt;, &lt;a href=&quot;qgraphicsscale#yScale-prop&quot;&gt;yScale&lt;/a&gt;, and &lt;a href=&quot;qgraphicsscale#zScale-prop&quot;&gt;zScale&lt;/a&gt; describe the scale factors to apply in horizontal, vertical, and depth directions. They can take on any value, including 0 (to collapse the item to a point) or negative value. A negative &lt;a href=&quot;qgraphicsscale#xScale-prop&quot;&gt;xScale&lt;/a&gt; value will mirror the item horizontally. A negative &lt;a href=&quot;qgraphicsscale#yScale-prop&quot;&gt;yScale&lt;/a&gt; value will flip the item vertically. A negative &lt;a href=&quot;qgraphicsscale#zScale-prop&quot;&gt;zScale&lt;/a&gt; will flip the item end for end.</source>
          <target state="translated">&lt;a href=&quot;qgraphicsscale#xScale-prop&quot;&gt;xScale&lt;/a&gt; , &lt;a href=&quot;qgraphicsscale#yScale-prop&quot;&gt;yScale&lt;/a&gt; 및 &lt;a href=&quot;qgraphicsscale#zScale-prop&quot;&gt;zScale&lt;/a&gt; 매개 변수 는 가로, 세로 및 깊이 방향으로 적용 할 배율을 설명합니다. 0 (항목을 포인트로 축소) 또는 음수 값을 포함한 모든 값을 사용할 수 있습니다. 음의 &lt;a href=&quot;qgraphicsscale#xScale-prop&quot;&gt;xScale&lt;/a&gt; 값은 항목을 가로로 미러링합니다. 음의 &lt;a href=&quot;qgraphicsscale#yScale-prop&quot;&gt;yScale&lt;/a&gt; 값은 항목을 세로로 뒤집습니다. 음수 &lt;a href=&quot;qgraphicsscale#zScale-prop&quot;&gt;zScale&lt;/a&gt; 은 항목 끝을 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="7d6911c8bd17ced8d3ead7cc73277a5e16d1836b" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;call&lt;/code&gt; are passed on to the remote function via D-Bus as input arguments. Output arguments are returned in the &lt;a href=&quot;qdbusmessage&quot;&gt;QDBusMessage&lt;/a&gt; reply. If the reply is an error reply, &lt;a href=&quot;qdbusabstractinterface#lastError&quot;&gt;lastError&lt;/a&gt;() will also be set to the contents of the error message.</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; 할 파라미터 는 입력 인수로 D-Bus를 통해 원격 기능에 전달됩니다. 출력 인수는 &lt;a href=&quot;qdbusmessage&quot;&gt;QDBusMessage&lt;/a&gt; 응답에 리턴됩니다 . 응답이 오류 응답 인 경우 &lt;a href=&quot;qdbusabstractinterface#lastError&quot;&gt;lastError&lt;/a&gt; ()도 오류 메시지의 내용으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d41d9c64f20cf3635daea3fca256790b4b9b9f93" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;call&lt;/code&gt; are passed on to the remote function via D-Bus as input arguments. The returned &lt;a href=&quot;qdbuspendingcall&quot;&gt;QDBusPendingCall&lt;/a&gt; object can be used to find out information about the reply.</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; 할 파라미터 는 입력 인수로 D-Bus를 통해 원격 기능에 전달됩니다. 리턴 된 &lt;a href=&quot;qdbuspendingcall&quot;&gt;QDBusPendingCall&lt;/a&gt; 오브젝트를 사용하여 응답에 대한 정보를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09c441c6459cf598b536986f53ef6daa3e551806" translate="yes" xml:space="preserve">
          <source>The parent &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; of the provided document remains the owner of the object. If the current document is a child of the text editor, then it is deleted.</source>
          <target state="translated">제공된 문서 의 상위 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 는 오브젝트 소유자로 유지됩니다. 현재 문서가 텍스트 편집기의 하위 인 경우 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="428a3d496895536d4313a14d74d47af36b632cb2" translate="yes" xml:space="preserve">
          <source>The parent &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; of the provided page remains the owner of the object. If the current page is a child of the web view, it will be deleted.</source>
          <target state="translated">제공된 페이지 의 상위 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 는 오브젝트의 소유자로 유지됩니다. 현재 페이지가 웹보기의 하위 인 경우 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="89ef80ca5aab15f94be8464d6b28a86241869e54" translate="yes" xml:space="preserve">
          <source>The parent in this case is usually an empty command, in that it doesn't provide its own implementation of &lt;a href=&quot;qundocommand#undo&quot;&gt;undo&lt;/a&gt;() and &lt;a href=&quot;qundocommand#redo&quot;&gt;redo&lt;/a&gt;(). Instead, it uses the base implementations of these functions, which simply call &lt;a href=&quot;qundocommand#undo&quot;&gt;undo&lt;/a&gt;() or &lt;a href=&quot;qundocommand#redo&quot;&gt;redo&lt;/a&gt;() on all its children. The parent should, however, have a meaningful &lt;a href=&quot;qundocommand#text&quot;&gt;text&lt;/a&gt;().</source>
          <target state="translated">이 경우 부모는 일반적으로 &lt;a href=&quot;qundocommand#undo&quot;&gt;실행 취소&lt;/a&gt; () 및 &lt;a href=&quot;qundocommand#redo&quot;&gt;다시 &lt;/a&gt;실행 () 의 자체 구현을 제공하지 않기 때문에 빈 명령 입니다. 대신이 함수의 기본 구현을 사용하며 모든 자식에 대해 단순히 &lt;a href=&quot;qundocommand#undo&quot;&gt;undo&lt;/a&gt; () 또는 &lt;a href=&quot;qundocommand#redo&quot;&gt;redo&lt;/a&gt; ()를 호출 합니다. 그러나 부모에게는 의미있는 &lt;a href=&quot;qundocommand#text&quot;&gt;텍스트&lt;/a&gt; () 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="4b1d3ca22b5d9e0a942f86877e5aab8d364696a8" translate="yes" xml:space="preserve">
          <source>The parent index is normally used to determine where in the model the rows should be added. In this case, we only have a single top-level list of strings, so we just insert empty strings into that list.</source>
          <target state="translated">부모 인덱스는 일반적으로 모델에서 행을 추가 할 위치를 결정하는 데 사용됩니다. 이 경우 단일 최상위 문자열 목록 만 있으므로 빈 문자열을 해당 목록에 삽입하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="a884c86adb626d4162142967a01eac98e2310e83" translate="yes" xml:space="preserve">
          <source>The parent of a &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; instance can only be another &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; 인스턴스 의 상위는 다른 &lt;a href=&quot;qt3dcore-qnode&quot;&gt;QNode&lt;/a&gt; 인스턴스 만 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fa1048ed9775ca0943118cf45d39348b23d2626" translate="yes" xml:space="preserve">
          <source>The parent of an object may be viewed as the object's owner. For instance, a &lt;a href=&quot;qdialog&quot;&gt;dialog box&lt;/a&gt; is the parent of the &lt;b&gt;OK&lt;/b&gt; and &lt;b&gt;Cancel&lt;/b&gt; buttons it contains.</source>
          <target state="translated">객체의 부모는 객체의 소유자로 볼 수 있습니다. 예를 들어, &lt;a href=&quot;qdialog&quot;&gt;대화 상자&lt;/a&gt; 는 포함 된 &lt;b&gt;확인&lt;/b&gt; 및 &lt;b&gt;취소&lt;/b&gt; 버튼 의 부모입니다 .</target>
        </trans-unit>
        <trans-unit id="5688fa831352bb78f6c78602223947cf71fd880b" translate="yes" xml:space="preserve">
          <source>The parent of the context node</source>
          <target state="translated">컨텍스트 노드의 부모</target>
        </trans-unit>
        <trans-unit id="e1cae10b811de36ada11d61050b3183d81720f4f" translate="yes" xml:space="preserve">
          <source>The parent of the model index passed to &lt;a href=&quot;qabstractitemmodel#checkIndex&quot;&gt;QAbstractItemModel::checkIndex&lt;/a&gt;() is checked to be an invalid model index. If both this option and DoNotUseParent are specified, then this option is ignored.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel#checkIndex&quot;&gt;QAbstractItemModel :: checkIndex&lt;/a&gt; ()에 전달 된 모델 색인의 상위가 유효하지 않은 모델 색인인지 확인합니다. 이 옵션과 DoNotUseParent가 모두 지정된 경우이 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0dff7fb5aaabe08b65ad1cfb3576c4981451b0d7" translate="yes" xml:space="preserve">
          <source>The parent state machine treats the child machine as an</source>
          <target state="translated">부모 상태 머신은 자식 머신을</target>
        </trans-unit>
        <trans-unit id="d3856d78dd1ad16d0b29b82acdf3ae6044d7590e" translate="yes" xml:space="preserve">
          <source>The parent's &lt;a href=&quot;qml-qtquick-item#children-prop&quot;&gt;children&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#childrenRect.x-prop&quot;&gt;childrenRect&lt;/a&gt; properties takes that child into account</source>
          <target state="translated">부모의 &lt;a href=&quot;qml-qtquick-item#children-prop&quot;&gt;children&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-item#childrenRect.x-prop&quot;&gt;childrenRect&lt;/a&gt; 속성은 해당 자식을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="4d1eeb99c65938013e508e170c1c60e284a4e99d" translate="yes" xml:space="preserve">
          <source>The parent, &lt;code&gt;window&lt;/code&gt;, and the child, &lt;code&gt;quit&lt;/code&gt;, are both &lt;a href=&quot;qobject&quot;&gt;QObjects&lt;/a&gt; because &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; inherits &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;, and &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; inherits &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;. This code is correct: the destructor of &lt;code&gt;quit&lt;/code&gt; is</source>
          <target state="translated">부모, &lt;code&gt;window&lt;/code&gt; , 그리고 아이는, &lt;code&gt;quit&lt;/code&gt; , 모두 &lt;a href=&quot;qobject&quot;&gt;QObjects&lt;/a&gt; 때문에 &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton을가&lt;/a&gt; 상속 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget을&lt;/a&gt; 하고 &lt;a href=&quot;qwidget&quot;&gt;는 QWidget&lt;/a&gt; 상속 &lt;a href=&quot;qobject&quot;&gt;QObject를&lt;/a&gt; . 이 코드는 정확합니다 : &lt;code&gt;quit&lt;/code&gt; 의 소멸자 는</target>
        </trans-unit>
        <trans-unit id="d558f902f9c96ec1568fc4e234bf4e7c4ac3d68f" translate="yes" xml:space="preserve">
          <source>The parental rating of the media.</source>
          <target state="translated">미디어의 보호자 등급입니다.</target>
        </trans-unit>
        <trans-unit id="60d88ba9be319f5f1d8aa1e88c099007a422284c" translate="yes" xml:space="preserve">
          <source>The parsed XML is represented internally by a tree of objects that can be accessed using the various QDom classes. All QDom classes only</source>
          <target state="translated">구문 분석 된 XML은 다양한 QDom 클래스를 사용하여 액세스 할 수있는 객체 트리로 내부적으로 표시됩니다. 모든 QDom 클래스 만</target>
        </trans-unit>
        <trans-unit id="04c28d15165bf347bec3a99485083d887a21e7b9" translate="yes" xml:space="preserve">
          <source>The parsed document contains additional garbage characters at the end</source>
          <target state="translated">파싱 ​​된 문서는 끝에 추가 가비지 문자를 포함합니다</target>
        </trans-unit>
        <trans-unit id="72399411668e43b93e124615dec9c44789d44e04" translate="yes" xml:space="preserve">
          <source>The parser does not automatically support negating or disabling long options by using the format &lt;code&gt;--disable-option&lt;/code&gt; or &lt;code&gt;--no-option&lt;/code&gt;. However, it is possible to handle this case explicitly by making an option with &lt;code&gt;no-option&lt;/code&gt; as one of its names, and handling the option explicitly.</source>
          <target state="translated">파서는 &lt;code&gt;--disable-option&lt;/code&gt; 또는 &lt;code&gt;--no-option&lt;/code&gt; 형식을 사용하여 긴 옵션 무시 또는 비활성화를 자동으로 지원하지 않습니다 . 그러나 &lt;code&gt;no-option&lt;/code&gt; 중 하나를 옵션 으로 사용 하지 않고 옵션을 명시 적으로 처리하여이 경우를 명시 적으로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="a7288b44e527d71bfe35e964c3448b28051469d7" translate="yes" xml:space="preserve">
          <source>The parser does not support optional values - if an option is set to require a value, one must be present. If such an option is placed last and has no value, the option will be treated as if it had not been specified.</source>
          <target state="translated">구문 분석기는 선택적 값을 지원하지 않습니다. 옵션이 값을 요구하도록 설정되어 있으면 옵션이 있어야합니다. 이러한 옵션이 마지막에 배치되고 값이 없으면 옵션이 지정되지 않은 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="dcb11afa0113e1364dd48addf04e1edfe61dd980" translate="yes" xml:space="preserve">
          <source>The parser encountered an element that was different to those it expected.</source>
          <target state="translated">구문 분석기가 예상 한 것과 다른 요소를 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="de35c21561438919be50c5a3319dfee8db036714" translate="yes" xml:space="preserve">
          <source>The parser handles short names, long names, more than one name for the same option, and option values.</source>
          <target state="translated">파서는 짧은 이름, 긴 이름, 동일한 옵션에 대한 둘 이상의 이름 및 옵션 값을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="7275885a4e9bd2128ef144ae4e2a18965cca2cbc" translate="yes" xml:space="preserve">
          <source>The parser internally raised an error due to the read XML not being well-formed.</source>
          <target state="translated">읽기 XML의 형식이 잘못되어 구문 분석기에서 내부적으로 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="75f0dfedc3a42760c71f4561f8b96097929e182d" translate="yes" xml:space="preserve">
          <source>The parser reads</source>
          <target state="translated">파서는 읽습니다</target>
        </trans-unit>
        <trans-unit id="d2f68186cb6ec81aa92a34769541e54738a3b85d" translate="yes" xml:space="preserve">
          <source>The parsing for the string is complete, with no error.</source>
          <target state="translated">문자열의 구문 분석이 완료되었으며 오류는 없습니다.</target>
        </trans-unit>
        <trans-unit id="de0c3489181c8d4d60078ceb5cf9d8bdfeb95792" translate="yes" xml:space="preserve">
          <source>The parsing mode controls the way &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; parses strings.</source>
          <target state="translated">구문 분석 모드는 &lt;a href=&quot;qurl&quot;&gt;QUrl이&lt;/a&gt; 문자열을 구문 분석 하는 방식을 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="b40b40683a10c35c397bc8b68e06b5ba2c4bf325" translate="yes" xml:space="preserve">
          <source>The part of this document that does not concern the styling of individual widgets is meant to be read sequentially because later sections tend to depend on earlier ones. The description of the widgets can be used for reference while implementing a style. However, you may need to consult the Qt source code in some cases. The sequence in the styling process should become clear after reading this document, which will aid you in locating relevant code.</source>
          <target state="translated">개별 위젯의 스타일과 관련이없는이 문서의 일부는 이후 섹션이 이전 위젯에 의존하는 경향이 있으므로 순차적으로 읽도록되어 있습니다. 위젯 설명은 스타일을 구현하는 동안 참조 용으로 사용할 수 있습니다. 그러나 경우에 따라 Qt 소스 코드를 참조해야 할 수도 있습니다. 이 문서를 읽은 후에는 스타일링 과정의 순서가 명확 해 지므로 관련 코드를 찾는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="b972776876c0b50de3e070a4f52846bd33ea971d" translate="yes" xml:space="preserve">
          <source>The partial file did not match the expected hash.</source>
          <target state="translated">부분 파일이 예상 된 해시와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b71bd4743b65c449af52f02f659464ce3bb5ac47" translate="yes" xml:space="preserve">
          <source>The partially checked state can be made available to the user by setting &lt;a href=&quot;qml-qtquick-controls-checkbox#partiallyCheckedEnabled-prop&quot;&gt;partiallyCheckedEnabled&lt;/a&gt; to &lt;code&gt;true&lt;/code&gt;, or set directly by setting &lt;a href=&quot;qml-qtquick-controls-checkbox#checkedState-prop&quot;&gt;checkedState&lt;/a&gt; to &lt;code&gt;Qt.PartiallyChecked&lt;/code&gt;. &lt;a href=&quot;qml-qtquick-controls-checkbox#checkedState-prop&quot;&gt;checkedState&lt;/a&gt; behaves identically to &lt;a href=&quot;qml-qtquick-controls-checkbox#checked-prop&quot;&gt;checked&lt;/a&gt; when &lt;a href=&quot;qml-qtquick-controls-checkbox#partiallyCheckedEnabled-prop&quot;&gt;partiallyCheckedEnabled&lt;/a&gt; is &lt;code&gt;false&lt;/code&gt;; setting one will appropriately set the other.</source>
          <target state="translated">부분적으로 선택 상태로 설정하여 사용자에게 제공 될 수 &lt;a href=&quot;qml-qtquick-controls-checkbox#partiallyCheckedEnabled-prop&quot;&gt;partiallyCheckedEnabled을&lt;/a&gt; 에 &lt;code&gt;true&lt;/code&gt; 또는 설정하여 설정 &lt;a href=&quot;qml-qtquick-controls-checkbox#checkedState-prop&quot;&gt;checkedState을&lt;/a&gt; 에 &lt;code&gt;Qt.PartiallyChecked&lt;/code&gt; . &lt;a href=&quot;qml-qtquick-controls-checkbox#checkedState-prop&quot;&gt;checkedState는&lt;/a&gt; 같은 동작을 &lt;a href=&quot;qml-qtquick-controls-checkbox#checked-prop&quot;&gt;확인할&lt;/a&gt; 때 &lt;a href=&quot;qml-qtquick-controls-checkbox#partiallyCheckedEnabled-prop&quot;&gt;partiallyCheckedEnabled이&lt;/a&gt; 있다 &lt;code&gt;false&lt;/code&gt; ; 하나를 설정하면 다른 하나가 적절하게 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="33540611ed5a6195ba73d97065f3e4cafec03dbc" translate="yes" xml:space="preserve">
          <source>The particle coordinates are not transformed.</source>
          <target state="translated">입자 좌표는 변환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="24ee4582a9fdebce90f1ab9fee343175c7b29bb0" translate="yes" xml:space="preserve">
          <source>The particle system contains several types which represent shapes. These types do not visualize shapes, and are used for the purpose of selecting a random point within the shape. If you want a specific point with no randomness, use a 0 width and 0 height shape (which is the default). Otherwise you can use the shape types to specify an area, so that the result can use a random point selected from that area.</source>
          <target state="translated">입자 시스템에는 모양을 나타내는 여러 유형이 있습니다. 이러한 유형은 모양을 시각화하지 않으며 모양 내에서 임의의 점을 선택하기 위해 사용됩니다. 임의의 점이없는 특정 점을 원하면 너비와 높이가 0 인 모양 (기본값)을 사용하십시오. 그렇지 않으면 모양 유형을 사용하여 영역을 지정하여 결과에서 해당 영역에서 선택한 임의의 점을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea5de140641ad1b4cdae8cf52e6b43d9fed96701" translate="yes" xml:space="preserve">
          <source>The passed local adapter address does not match the physical adapter address of any local Bluetooth device.</source>
          <target state="translated">전달 된 로컬 어댑터 주소가 로컬 Bluetooth 장치의 실제 어댑터 주소와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="592b60c5fb4d8ceb70ca51a41fedca953cdf8bbe" translate="yes" xml:space="preserve">
          <source>The passed local adapter address does not match the physical adapter address of any local Bluetooth device. This value was introduced by Qt 5.3.</source>
          <target state="translated">전달 된 로컬 어댑터 주소가 로컬 Bluetooth 장치의 실제 어댑터 주소와 일치하지 않습니다. 이 값은 Qt 5.3에 의해 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="415b720033afe3ee63e252f88b60463d0cabc25f" translate="yes" xml:space="preserve">
          <source>The password and fragment are removed from the url.</source>
          <target state="translated">비밀번호와 조각이 URL에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="10a5d7e2131394ef0c0794e80200477ab57e4f74" translate="yes" xml:space="preserve">
          <source>The password character can be styled using the &lt;a href=&quot;#lineedit-password-character-prop&quot;&gt;lineedit-password-character&lt;/a&gt; property.</source>
          <target state="translated">암호 문자는 &lt;a href=&quot;#lineedit-password-character-prop&quot;&gt;lineedit-password-character&lt;/a&gt; 속성을 사용하여 스타일을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68e81a5d440003bf217e4205aca07f8474c499ae" translate="yes" xml:space="preserve">
          <source>The password character that is displayed when echoMode on the &lt;a href=&quot;qml-qtquick-controls-textfield&quot;&gt;TextField&lt;/a&gt; is set to &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt;.Password or &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt;.PasswordEchoOnEdit.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-textfield&quot;&gt;TextField의&lt;/a&gt; echoMode 가 &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; .Password 또는 &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; .PasswordEchoOnEdit으로 설정된 경우 표시되는 비밀번호 문자입니다 .</target>
        </trans-unit>
        <trans-unit id="6ba4acfef81ff084422c8b1c839393952ce5c081" translate="yes" xml:space="preserve">
          <source>The password mask delay can be changed using the &lt;a href=&quot;#lineedit-password-mask-delay-prop&quot;&gt;lineedit-password-mask-delay&lt;/a&gt;</source>
          <target state="translated">암호 마스크 지연은 &lt;a href=&quot;#lineedit-password-mask-delay-prop&quot;&gt;lineedit-password-mask-delay를&lt;/a&gt; 사용하여 변경할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5c2507b525aa596c5e98e6aa53993003f68cb4be" translate="yes" xml:space="preserve">
          <source>The path can be either absolute or relative. Absolute paths begin with the directory separator &quot;/&quot; (optionally preceded by a drive specification under Windows). Relative file names begin with a directory name or a file name and specify a path relative to the current directory. An example of an absolute path is the string &quot;/tmp/quartz&quot;, a relative path might look like &quot;src/fatlib&quot;.</source>
          <target state="translated">경로는 절대적이거나 상대적 일 수 있습니다. 절대 경로는 디렉토리 구분 기호 &quot;/&quot;로 시작합니다 (선택적으로 Windows에서 드라이브 사양이 앞에옵니다). 상대 파일 이름은 디렉토리 이름 또는 파일 이름으로 시작하고 현재 디렉토리에 상대적인 경로를 지정합니다. 절대 경로의 예는 문자열 &quot;/ tmp / quartz&quot;이며 상대 경로는 &quot;src / fatlib&quot;와 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec324623732106835af9fd562caff276b0c413e9" translate="yes" xml:space="preserve">
          <source>The path for a directory can also be changed with the &lt;a href=&quot;qdir#cd&quot;&gt;cd&lt;/a&gt;() and &lt;a href=&quot;qdir#cdUp&quot;&gt;cdUp&lt;/a&gt;() functions, both of which operate like familiar shell commands. When &lt;a href=&quot;qdir#cd&quot;&gt;cd&lt;/a&gt;() is called with the name of an existing directory, the &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; object changes directory so that it represents that directory instead. The &lt;a href=&quot;qdir#cdUp&quot;&gt;cdUp&lt;/a&gt;() function changes the directory of the &lt;a href=&quot;qdir&quot;&gt;QDir&lt;/a&gt; object so that it refers to its parent directory; i.e. cd(&quot;..&quot;) is equivalent to &lt;a href=&quot;qdir#cdUp&quot;&gt;cdUp&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qdir#cd&quot;&gt;cd&lt;/a&gt; () 및 &lt;a href=&quot;qdir#cdUp&quot;&gt;cdUp&lt;/a&gt; () 함수 를 사용하여 디렉토리의 경로를 변경할 수도 있습니다 .이 두 가지 기능은 모두 친숙한 쉘 명령처럼 작동합니다. 때 &lt;a href=&quot;qdir#cd&quot;&gt;CD를&lt;/a&gt; () 기존 디렉토리의 이름으로 호출되면 &lt;a href=&quot;qdir&quot;&gt;QDir의&lt;/a&gt; 대신 그 디렉토리를 나타내도록 객체는 디렉토리를 변경합니다. &lt;a href=&quot;qdir#cdUp&quot;&gt;CDUP&lt;/a&gt; () 함수의 디렉터리 변경 &lt;a href=&quot;qdir&quot;&gt;QDir의&lt;/a&gt; 객체는 부모 디렉토리를 참조하는 단계; 즉, cd ( &quot;..&quot;)는 &lt;a href=&quot;qdir#cdUp&quot;&gt;cdUp&lt;/a&gt; () 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="95d95479c6bb8e3d6463a4bb2fc9fb4cc5d2be8c" translate="yes" xml:space="preserve">
          <source>The path formed by concatenating the &lt;code&gt;HOMEDRIVE&lt;/code&gt; and &lt;code&gt;HOMEPATH&lt;/code&gt; environment variables.</source>
          <target state="translated">&lt;code&gt;HOMEDRIVE&lt;/code&gt; 및 &lt;code&gt;HOMEPATH&lt;/code&gt; 환경 변수 를 연결하여 형성된 경로 입니다.</target>
        </trans-unit>
        <trans-unit id="e6a53af196e45156388fce789b1f8010db3e57bc" translate="yes" xml:space="preserve">
          <source>The path includes the file name. The default suggested path is the standard download location and file name is deduced not to overwrite already existing files.</source>
          <target state="translated">경로는 파일 이름을 포함합니다. 기본 제안 경로는 표준 다운로드 위치이며 파일 이름은 기존 파일을 덮어 쓰지 않는 것으로 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="4aaab7d961dbce3a548a6db0b2b4e156fc6e6ebc" translate="yes" xml:space="preserve">
          <source>The path is being processed.</source>
          <target state="translated">경로가 처리되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3737f142db0af5baf8255d102111da1f7e2d28e" translate="yes" xml:space="preserve">
          <source>The path is considered invalid if it is empty.</source>
          <target state="translated">경로가 비어 있으면 유효하지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="12fc4d8013303ff9a7b69a4978f385d18b3900d5" translate="yes" xml:space="preserve">
          <source>The path is defined by an ordered list of QGeoCoordinates.</source>
          <target state="translated">경로는 정렬 된 QGeoCoordinates 목록으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c20aaaf7681124fa4445293306b86efefdd7c883" translate="yes" xml:space="preserve">
          <source>The path of the Bodymovin asset that &lt;a href=&quot;qml-qt-labs-lottieqt-lottieanimation&quot;&gt;LottieAnimation&lt;/a&gt; plays.</source>
          <target state="translated">&lt;a href=&quot;qml-qt-labs-lottieqt-lottieanimation&quot;&gt;LottieAnimation이&lt;/a&gt; 재생 하는 Bodymovin 자산의 경로입니다 .</target>
        </trans-unit>
        <trans-unit id="58b1b623e9d1c1162d12acedf335e00d560485b4" translate="yes" xml:space="preserve">
          <source>The path of the file which was selected by the user.</source>
          <target state="translated">사용자가 선택한 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="9caa6a40a7e74b68c6f1109259733af852dbe967" translate="yes" xml:space="preserve">
          <source>The path returned by the &lt;a href=&quot;qdir#rootPath&quot;&gt;rootPath&lt;/a&gt;() function (which uses the &lt;code&gt;SystemDrive&lt;/code&gt; environment variable)</source>
          <target state="translated">&lt;a href=&quot;qdir#rootPath&quot;&gt;rootPath&lt;/a&gt; () 함수가 리턴 한 경로 ( &lt;code&gt;SystemDrive&lt;/code&gt; 환경 변수 를 사용함 )</target>
        </trans-unit>
        <trans-unit id="3aff8afc0317de76fcf11fd1c42f00f9a4b08e3f" translate="yes" xml:space="preserve">
          <source>The path specified by the &lt;code&gt;HOME&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;HOME&lt;/code&gt; 환경 변수 로 지정된 경로</target>
        </trans-unit>
        <trans-unit id="b44fe26548ecede4145ab0cf35a82d781fa5c47a" translate="yes" xml:space="preserve">
          <source>The path specified by the &lt;code&gt;USERPROFILE&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;USERPROFILE&lt;/code&gt; 환경 변수 로 지정된 경로 입니다.</target>
        </trans-unit>
        <trans-unit id="044b4bb8b27c1a02a072baf6ab30cd35e0cb0672" translate="yes" xml:space="preserve">
          <source>The path to a link icon.</source>
          <target state="translated">링크 아이콘의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="15b8c9d161f0cf96dc11d3ba34ebc964c0ff4c78" translate="yes" xml:space="preserve">
          <source>The path to an executable file.</source>
          <target state="translated">실행 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="2eb88f8b89a8226e50b47e5f6cce1257854bf281" translate="yes" xml:space="preserve">
          <source>The path to the currently selected folder. Setting this property before invoking &lt;a href=&quot;qml-qtquick-dialogs-filedialog#open-method&quot;&gt;open()&lt;/a&gt; will cause the file browser to be initially positioned on the specified folder.</source>
          <target state="translated">현재 선택된 폴더의 경로입니다. &lt;a href=&quot;qml-qtquick-dialogs-filedialog#open-method&quot;&gt;open ()&lt;/a&gt; 을 호출하기 전에이 속성을 설정 하면 파일 브라우저가 지정된 폴더에 처음 위치하게됩니다.</target>
        </trans-unit>
        <trans-unit id="a5d7f6c37fe93af27b88af304f713208b3e7e43a" translate="yes" xml:space="preserve">
          <source>The path to the file.</source>
          <target state="translated">파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="a24c9c2afb8dbedb5bebabf8a8aab2439ee5a456" translate="yes" xml:space="preserve">
          <source>The path to the location where the downloaded files are stored.</source>
          <target state="translated">다운로드 한 파일이 저장된 위치의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="0e207f00769452de8ebfa3fd1a004337bbb7fa62" translate="yes" xml:space="preserve">
          <source>The path to the location where the persistent data for the browser and web content are stored. Persistent data includes persistent cookies, HTML5 local storage, and visited links.</source>
          <target state="translated">브라우저 및 웹 컨텐츠의 지속적 데이터가 저장된 위치의 경로입니다. 영구 데이터에는 영구 쿠키, HTML5 로컬 스토리지 및 방문 링크가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="768ec7b9312a6e93bff3cf5d145c36b0687d2cb2" translate="yes" xml:space="preserve">
          <source>The path to the location where the profile's caches are stored, in particular the HTTP cache.</source>
          <target state="translated">프로필 캐시가 저장된 위치, 특히 HTTP 캐시의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="9cf32bb2479c3171f58e3f43a6cd4c564b1c2138" translate="yes" xml:space="preserve">
          <source>The path to the temporary directory can be found by calling &lt;a href=&quot;qtemporarydir#path&quot;&gt;path&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qtemporarydir#path&quot;&gt;경로&lt;/a&gt; () 를 호출하여 임시 디렉토리의 경로를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0078591e7291fe0dc6bf568625cd2a90fa119c0d" translate="yes" xml:space="preserve">
          <source>The path view itself is a focus scope (see &lt;a href=&quot;qtquick-input-focus#&quot;&gt;Keyboard Focus in Qt Quick&lt;/a&gt; for more details).</source>
          <target state="translated">경로보기 자체는 초점 범위입니다 ( 자세한 내용 &lt;a href=&quot;qtquick-input-focus#&quot;&gt;은 Qt Quick의 키보드 초점&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="6e3efffd588eb6bb4f8348a8111e9f5331d18701" translate="yes" xml:space="preserve">
          <source>The paths above should not be relied upon, as they may change according to OS configuration, locale, or they may change in future Qt versions.</source>
          <target state="translated">OS 구성, 로케일에 따라 변경되거나 향후 Qt 버전에서 변경 될 수 있으므로 위의 경로는 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b42345698acb5290123aee0dfa52250ffcc82df4" translate="yes" xml:space="preserve">
          <source>The paths containing header files can also be specified in a similar way using the &lt;a href=&quot;qmake-variable-reference#includepath&quot;&gt;INCLUDEPATH&lt;/a&gt; variable.</source>
          <target state="translated">&lt;a href=&quot;qmake-variable-reference#includepath&quot;&gt;INCLUDEPATH&lt;/a&gt; 변수를 사용하여 헤더 파일을 포함하는 경로를 유사한 방식으로 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17a50ab53062dc5f471683feb3f617efdb5f8283" translate="yes" xml:space="preserve">
          <source>The paths for the &lt;code&gt;.ini&lt;/code&gt; and &lt;code&gt;.conf&lt;/code&gt; files can be changed using &lt;a href=&quot;qsettings#setPath&quot;&gt;setPath&lt;/a&gt;(). On Unix, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, and iOS the user can override them by setting the &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variable; see &lt;a href=&quot;qsettings#setPath&quot;&gt;setPath&lt;/a&gt;() for details.</source>
          <target state="translated">&lt;code&gt;.ini&lt;/code&gt; 및 &lt;code&gt;.conf&lt;/code&gt; 파일 의 경로는 &lt;a href=&quot;qsettings#setPath&quot;&gt;setPath&lt;/a&gt; ()를 사용하여 변경할 수 있습니다 . Unix, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 및 iOS에서 사용자는 &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 환경 변수를 설정하여이를 무시할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;qsettings#setPath&quot;&gt;setPath&lt;/a&gt; ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a9f7f82dbcfa4c46e49261ad11e3b85dd8a774db" translate="yes" xml:space="preserve">
          <source>The paths that qmake searches for libraries and the specific libraries to link against can be added to the list of values in the &lt;a href=&quot;qmake-variable-reference#libs&quot;&gt;LIBS&lt;/a&gt; variable. You can specify the paths to the libraries or use the Unix-style notation for specifying libraries and paths.</source>
          <target state="translated">qmake가 라이브러리 및 링크 할 특정 라이브러리를 검색하는 경로를 &lt;a href=&quot;qmake-variable-reference#libs&quot;&gt;LIBS&lt;/a&gt; 변수 의 값 목록에 추가 할 수 있습니다 . 라이브러리에 대한 경로를 지정하거나 라이브러리 및 경로를 지정하기 위해 Unix 스타일 표기법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdaa6c9a2dfa80adc37231fa3690049e315e87d0" translate="yes" xml:space="preserve">
          <source>The pattern &lt;b&gt;[a-z&lt;/b&gt; is an example of an invalid pattern, since it lacks a closing square bracket.</source>
          <target state="translated">패턴 &lt;b&gt;[az&lt;/b&gt; 는 닫는 대괄호가 없기 때문에 유효하지 않은 패턴의 예입니다.</target>
        </trans-unit>
        <trans-unit id="09c14febb1830384d5cad99d66ca1bb86ed475d2" translate="yes" xml:space="preserve">
          <source>The pattern is a fixed string. This is equivalent to using the RegExp pattern on a string in which all metacharacters are escaped using &lt;a href=&quot;qregexp#escape&quot;&gt;escape&lt;/a&gt;().</source>
          <target state="translated">패턴은 고정 문자열입니다. 이는 모든 메타 문자가 &lt;a href=&quot;qregexp#escape&quot;&gt;이스케이프&lt;/a&gt; ()를 사용하여 이스케이프 되는 문자열에서 RegExp 패턴을 사용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9a8e18aa656e84fc0ac3675dc0513a3bd6cc2c3f" translate="yes" xml:space="preserve">
          <source>The pattern is a regular expression as defined by the W3C XML Schema 1.1 specification.</source>
          <target state="translated">패턴은 W3C XML Schema 1.1 사양에 정의 된 정규식입니다.</target>
        </trans-unit>
        <trans-unit id="e84e41c6078563f8f17f50ecf7d39c11f9957bad" translate="yes" xml:space="preserve">
          <source>The pattern must be specified as an even number of positive entries where the entries 1, 3, 5... are the dashes and 2, 4, 6... are the spaces. For example:</source>
          <target state="translated">패턴은 1, 3, 5 ... 항목은 대시이고 2, 4, 6 ...은 공백 인 짝수의 양수 항목으로 지정해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f4e76786a3813397344633a54468471bad61fdea" translate="yes" xml:space="preserve">
          <source>The pattern should match against the subject string in a case insensitive way. This option corresponds to the /i modifier in Perl regular expressions.</source>
          <target state="translated">패턴은 대소 문자를 구분하지 않고 주제 문자열과 일치해야합니다. 이 옵션은 Perl 정규식의 / i 수정 자에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="50789d27c88042f41e859828449f2dc092d4da5f" translate="yes" xml:space="preserve">
          <source>The pattern string is matched partially against the subject string. If a partial match is found, then it is recorded, and other matching alternatives are tried as usual. If a complete match is then found, then it's preferred to the partial match; in this case only the complete match is reported. If instead no complete match is found (but only the partial one), then the partial one is reported.</source>
          <target state="translated">패턴 문자열은 주제 문자열과 부분적으로 일치합니다. 부분 일치가 발견되면 기록되고 다른 일치하는 대안이 평소대로 시도됩니다. 완전한 일치가 발견되면 부분 일치보다 선호됩니다. 이 경우 전체 일치 만보고됩니다. 대신 완전 일치가 발견되지 않으면 (일부만 일치) 부분 일치가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="44700a1d0bd5c04a936c174da8773be96f849d83" translate="yes" xml:space="preserve">
          <source>The pattern string is matched partially against the subject string. If a partial match is found, then matching stops and the partial match is reported. In this case, other matching alternatives (potentially leading to a complete match) are not tried. Moreover, this match type assumes that the subject string only a substring of a larger text, and that (in this text) there are other characters beyond the end of the subject string. This can lead to surprising results; see the discussion in the &lt;a href=&quot;qregularexpression#partial-matching&quot;&gt;partial matching&lt;/a&gt; section for more details.</source>
          <target state="translated">패턴 문자열은 주제 문자열과 부분적으로 일치합니다. 부분 일치가 발견되면 일치가 중지되고 부분 일치가보고됩니다. 이 경우 다른 일치하는 대안 (잠재적으로 전체 일치로 이어짐)은 시도되지 않습니다. 또한,이 일치 유형은 제목 문자열이 더 큰 텍스트의 하위 문자열 일 뿐이며 (이 텍스트에서) 제목 문자열의 끝을 넘어 다른 문자가 있다고 가정합니다. 이것은 놀라운 결과로 이어질 수 있습니다. 자세한 내용 은 &lt;a href=&quot;qregularexpression#partial-matching&quot;&gt;부분 일치&lt;/a&gt; 섹션의 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b2975e7a434f5a3ca8496b613dc37b129c1f753a" translate="yes" xml:space="preserve">
          <source>The patternRecognitionModes method returns a list of pattern recognition modes, which are supported by the input method. A pattern recognition mode, such as &lt;a href=&quot;qvirtualkeyboardinputengine#PatternRecognitionMode-enum&quot;&gt; Handwriting &lt;/a&gt;, defines the method by which the input method processes the data.</source>
          <target state="translated">patternRecognitionModes 메소드는 입력 메소드가 지원하는 패턴 인식 모드 목록을 리턴합니다. &lt;a href=&quot;qvirtualkeyboardinputengine#PatternRecognitionMode-enum&quot;&gt;Handwriting&lt;/a&gt; 과 같은 패턴 인식 모드 는 입력 방법이 데이터를 처리하는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="39b152488215cf58e91af345b0fc56a23ac3f46d" translate="yes" xml:space="preserve">
          <source>The payload can be modified by using &lt;a href=&quot;qnetworkdatagram#setData&quot;&gt;setData&lt;/a&gt;() and the destination address can be set with &lt;a href=&quot;qnetworkdatagram#setDestination&quot;&gt;setDestination&lt;/a&gt;().</source>
          <target state="translated">페이로드는 &lt;a href=&quot;qnetworkdatagram#setData&quot;&gt;setData&lt;/a&gt; () 를 사용하여 수정 하고 대상 주소는 &lt;a href=&quot;qnetworkdatagram#setDestination&quot;&gt;setDestination&lt;/a&gt; ()을 사용하여 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7dee799e05752849e3da45857cc8277fe00e33a5" translate="yes" xml:space="preserve">
          <source>The peak volume of the media's audio stream.</source>
          <target state="translated">미디어 오디오 스트림의 최대 볼륨.</target>
        </trans-unit>
        <trans-unit id="9f9547a4fe688a39af6f6c84bab3a9acd637121a" translate="yes" xml:space="preserve">
          <source>The peer certificate is checked automatically during the handshake phase, so this function is normally used to fetch the certificate for display or for connection diagnostic purposes. It contains information about the peer, including its host name, the certificate issuer, and the peer's public key.</source>
          <target state="translated">핸드 셰이크 단계 중에 피어 인증서가 자동으로 확인되므로이 기능은 일반적으로 표시 또는 연결 진단 목적으로 인증서를 가져 오는 데 사용됩니다. 호스트 이름, 인증서 발급자 및 피어의 공개 키를 포함하여 피어에 대한 정보가 들어 있습니다.</target>
        </trans-unit>
        <trans-unit id="082b0169db88591d4c8b7fc7f708ef1fedcbbc7f" translate="yes" xml:space="preserve">
          <source>The peer certificates are set in &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; during the handshake phase, so it is safe to call this function from a slot connected to the &lt;a href=&quot;qsslsocket#sslErrors&quot;&gt;sslErrors&lt;/a&gt;() signal or the &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;encrypted&lt;/a&gt;() signal.</source>
          <target state="translated">핸드 셰이크 단계 중에 피어 인증서가 &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 에 설정 되므로 &lt;a href=&quot;qsslsocket#sslErrors&quot;&gt;sslErrors&lt;/a&gt; () 신호 또는 &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;암호화 된&lt;/a&gt; () 신호에 연결된 슬롯에서이 기능을 호출하는 것이 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="36cef44cacc3a95a5639c191f24795872b8a30ab" translate="yes" xml:space="preserve">
          <source>The peer host name can also be used to indicate the expected source address of an incoming connection in the case of &lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery::UdpSocket&lt;/a&gt; or &lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery::TcpServer&lt;/a&gt; query types.</source>
          <target state="translated">피어 호스트 이름을 사용하여 &lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery :: UdpSocket&lt;/a&gt; 또는 &lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery :: TcpServer&lt;/a&gt; 조회 유형 의 경우 수신 연결의 예상 소스 주소를 표시 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4fdad30cfbc354e26ba9606b56bda1bb52cf5ceb" translate="yes" xml:space="preserve">
          <source>The peer port number can also be used to indicate the expected port number of an incoming connection in the case of &lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery::UdpSocket&lt;/a&gt; or &lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery::TcpServer&lt;/a&gt; query types.</source>
          <target state="translated">피어 포트 번호는 &lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery :: UdpSocket&lt;/a&gt; 또는 &lt;a href=&quot;qnetworkproxyquery#QueryType-enum&quot;&gt;QNetworkProxyQuery :: TcpServer&lt;/a&gt; 조회 유형 의 경우 수신 연결의 예상 포트 번호를 표시하는 데 사용될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7cecb6ca1c11fe01ab1e36d3bed988688e76211e" translate="yes" xml:space="preserve">
          <source>The peer's certificate and its certificate chain will be known by the time &lt;a href=&quot;qnetworkreply#sslErrors&quot;&gt;sslErrors&lt;/a&gt;() is emitted, if it's emitted.</source>
          <target state="translated">피어의 인증서와 인증서 체인은 &lt;a href=&quot;qnetworkreply#sslErrors&quot;&gt;sslErrors&lt;/a&gt; ()가 생성 될 때 알려질 것 입니다.</target>
        </trans-unit>
        <trans-unit id="f60b741d14cf6e55a82aba161a5ec0388f866db2" translate="yes" xml:space="preserve">
          <source>The pen color is specified with</source>
          <target state="translated">펜 색상은</target>
        </trans-unit>
        <trans-unit id="db3a88dc2aec140fbc4d259eab76c0cc8a776f55" translate="yes" xml:space="preserve">
          <source>The pen is dirty and needs to be updated.</source>
          <target state="translated">펜이 지저분하고 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ab00ca52447fc6409e1ec4881c15d2d3ec12b22" translate="yes" xml:space="preserve">
          <source>The pen is used to draw the item's outline.</source>
          <target state="translated">펜은 항목의 윤곽을 그리는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f8cf17356aba3be5b5835f3f00badcd349968b8" translate="yes" xml:space="preserve">
          <source>The pen style defines the line type. The brush is used to fill strokes generated with the pen. Use the &lt;a href=&quot;qbrush&quot;&gt;QBrush&lt;/a&gt; class to specify fill styles. The cap style determines the line end caps that can be drawn using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, while the join style describes how joins between two lines are drawn. The pen width can be specified in both integer (&lt;a href=&quot;qpen#width&quot;&gt;width&lt;/a&gt;()) and floating point (&lt;a href=&quot;qpen#widthF&quot;&gt;widthF&lt;/a&gt;()) precision. A line width of zero indicates a cosmetic pen. This means that the pen width is always drawn one pixel wide, independent of the &lt;a href=&quot;qpainter#coordinate-transformations&quot;&gt;transformation&lt;/a&gt; set on the painter.</source>
          <target state="translated">펜 스타일은 선 종류를 정의합니다. 브러시는 펜으로 생성 된 스트로크를 채우는 데 사용됩니다. 채우기 스타일을 지정 하려면 &lt;a href=&quot;qbrush&quot;&gt;QBrush&lt;/a&gt; 클래스를 사용하십시오 . 캡 스타일은 &lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; 사용하여 그릴 수있는 선 끝 캡을 결정하는 반면, 결합 스타일은 두 선 간의 결합이 그려지는 방법을 설명합니다. 펜 너비는 정수 ( &lt;a href=&quot;qpen#width&quot;&gt;너비&lt;/a&gt; ()) 및 부동 소수점 ( &lt;a href=&quot;qpen#widthF&quot;&gt;너비&lt;/a&gt; ( F )) 정밀도 로 지정할 수 있습니다 . 선 너비가 0이면 화장 용 펜을 나타냅니다. 즉, 펜 너비는 페인터에 설정된 &lt;a href=&quot;qpainter#coordinate-transformations&quot;&gt;변환&lt;/a&gt; 과 상관없이 항상 1 픽셀 너비로 그려집니다 .</target>
        </trans-unit>
        <trans-unit id="5370d79b5d88a9b615017fffa4e26069dfd8076e" translate="yes" xml:space="preserve">
          <source>The pendent to &lt;a href=&quot;qxmlstreamreader&quot;&gt;QXmlStreamReader&lt;/a&gt; is &lt;a href=&quot;qxmlstreamwriter&quot;&gt;QXmlStreamWriter&lt;/a&gt;, which provides an XML writer with a simple streaming API. &lt;a href=&quot;qxmlstreamwriter&quot;&gt;QXmlStreamWriter&lt;/a&gt; operates on a &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; and has specialized functions for all XML tokens or events you want to write, such as &lt;a href=&quot;qxmlstreamwriter#writeDTD&quot;&gt;writeDTD()&lt;/a&gt;, &lt;a href=&quot;qxmlstreamwriter#writeCharacters&quot;&gt;writeCharacters()&lt;/a&gt;, &lt;a href=&quot;qxmlstreamwriter#writeComment&quot;&gt;writeComment()&lt;/a&gt; and so on.</source>
          <target state="translated">&lt;a href=&quot;qxmlstreamreader&quot;&gt;QXmlStreamReader&lt;/a&gt; 의 펜던트 는 &lt;a href=&quot;qxmlstreamwriter&quot;&gt;QXmlStreamWriter&lt;/a&gt; 이며, XML 스트리밍 프로그램에 간단한 스트리밍 API를 제공합니다. &lt;a href=&quot;qxmlstreamwriter&quot;&gt;QXmlStreamWriter&lt;/a&gt; 는 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 에서 작동 하며 &lt;a href=&quot;qxmlstreamwriter#writeDTD&quot;&gt;writeDTD ()&lt;/a&gt; , &lt;a href=&quot;qxmlstreamwriter#writeCharacters&quot;&gt;writeCharacters ()&lt;/a&gt; , &lt;a href=&quot;qxmlstreamwriter#writeComment&quot;&gt;writeComment ()&lt;/a&gt; 등과 같이 작성하려는 모든 XML 토큰 또는 이벤트에 대한 특수 기능을 가지고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0cd289478a3c5b5160c258aac0e329d231ff3895" translate="yes" xml:space="preserve">
          <source>The percentage of the slice compared to the sum of all slices in the series. The actual value ranges from 0.0 to 1.0. Updated automatically once the slice is added to the series.</source>
          <target state="translated">시리즈의 모든 슬라이스 합계와 비교 한 슬라이스 백분율입니다. 실제 값은 0.0에서 1.0 사이입니다. 슬라이스가 시리즈에 추가되면 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="9c42a6584603a30b5b2ea888f2e632b3feecbe82" translate="yes" xml:space="preserve">
          <source>The performance benefit is primarily seen when registering application specific types from within the application instead of through a plugin. Using qmlProtectModule allows the engine to skip checking for a plugin when that uri is imported, which can be noticeable with slow file systems.</source>
          <target state="translated">주로 플러그인 대신 애플리케이션 내에서 애플리케이션 특정 유형을 등록 할 때 성능 이점이 나타납니다. qmlProtectModule을 사용하면 해당 URI를 가져올 때 엔진이 플러그인 검사를 건너 뛸 수 있으며, 이는 느린 파일 시스템에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83b60850dfb58af46673c6be987d47a7a1af5aaa" translate="yes" xml:space="preserve">
          <source>The performance of the particle system scales with the number of particles it is maintaining. After prototyping the desired effect, performance can be improved by lowering the particle count. Conversely, if performance is well within the acceptable bounds, you can increase the number of particles until you hit that point (should that improve the effect).</source>
          <target state="translated">파티클 시스템의 성능은 유지중인 파티클 수에 따라 확장됩니다. 원하는 효과를 프로토 타이핑 한 후, 입자 수를 낮춤으로써 성능을 향상시킬 수 있습니다. 반대로, 성능이 허용 가능한 범위 내에 있으면 해당 지점에 도달 할 때까지 입자 수를 늘릴 수 있습니다 (효과를 향상시켜야 함).</target>
        </trans-unit>
        <trans-unit id="01e8ea2922cb96a16d0b42d15cfae5df3d5ed515" translate="yes" xml:space="preserve">
          <source>The permission was denied.</source>
          <target state="translated">권한이 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="a51d20c3f509934da7e02521928a6e015fa9d556" translate="yes" xml:space="preserve">
          <source>The permission was granted.</source>
          <target state="translated">권한이 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="0ac5bb070517f0f4b127ced80ff0a5521e343cfc" translate="yes" xml:space="preserve">
          <source>The phong lighting effect is based on the combination of 3 lighting components ambient, diffuse and specular. The relative strengths of these components are controlled by means of their reflectivity coefficients which are modelled as RGB triplets:</source>
          <target state="translated">퐁 조명 효과는 주변, 확산 및 반사의 3 가지 조명 구성 요소의 조합을 기반으로합니다. 이러한 구성 요소의 상대 강도는 RGB 삼중 항으로 모델링 된 반사 계수를 통해 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="4738dc5d3cb70ce63f1e57621ca10240f82c380f" translate="yes" xml:space="preserve">
          <source>The phrase may consist of several words. By default, the search engine returns the list of documents that contain all the specified words. The phrase may contain any combination of the logical operators AND, OR, and NOT. The operator must be written in all capital letters, otherwise it will be considered a part of the search phrase.</source>
          <target state="translated">문구는 여러 단어로 구성 될 수 있습니다. 기본적으로 검색 엔진은 지정된 모든 단어가 포함 된 문서 목록을 반환합니다. 문구에는 논리 연산자 AND, OR 및 NOT의 조합이 포함될 수 있습니다. 연산자는 모든 대문자로 작성해야합니다. 그렇지 않으면 검색 구의 일부로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a3e4ccad6ca2ab5abb2a59d6e6001680c064b286" translate="yes" xml:space="preserve">
          <source>The physical and functional description of the server. &lt;code&gt;QModbusDeviceIdentification&lt;/code&gt;</source>
          <target state="translated">서버의 물리적 및 기능적 설명. &lt;code&gt;QModbusDeviceIdentification&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f3a0659bfecf94d00ede7c00575458cfcdc49ab" translate="yes" xml:space="preserve">
          <source>The physical size represents the actual physical dimensions of the screen's display.</source>
          <target state="translated">물리적 크기는 화면 디스플레이의 실제 물리적 크기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f00bbd56e894f35d46ef2efb11cc1fdf915bc95a" translate="yes" xml:space="preserve">
          <source>The picked primitive was a line segment, and the first two vertices refer to the two points making up the line</source>
          <target state="translated">선택된 프리미티브는 선분이며 처음 두 정점은 선을 구성하는 두 점을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="91c7fa7762c1b85c60ff31295d4021f47f718725" translate="yes" xml:space="preserve">
          <source>The picked primitive was a single point; all 3 vertex indices will be undefined</source>
          <target state="translated">선택된 프리미티브는 단일 지점이었습니다. 3 개의 정점 인덱스는 모두 정의되지 않습니다</target>
        </trans-unit>
        <trans-unit id="500a56ce7729d327d6159b1999fa4cf84d173682" translate="yes" xml:space="preserve">
          <source>The picked primitive was a triangle and the vertex indices refer to the three points making up the triangle</source>
          <target state="translated">선택된 프리미티브는 삼각형이었고 정점 인덱스는 삼각형을 구성하는 세 점을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f4bcdb0b8bfbde65c9c1286f6adf5cc4131da6da" translate="yes" xml:space="preserve">
          <source>The picking settings determine how the entity picking is handled. For more details about entity picking, see &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; and &lt;a href=&quot;qt3drender-qraycaster&quot;&gt;QRayCaster&lt;/a&gt; component documentation.</source>
          <target state="translated">피킹 설정에 따라 엔터티 피킹 처리 방법이 결정됩니다. 엔티티 선택에 대한 자세한 내용은 &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; 및 &lt;a href=&quot;qt3drender-qraycaster&quot;&gt;QRayCaster&lt;/a&gt; 구성 요소 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6bc1a65cdac8391f3ff658fb49875a86370fc8a7" translate="yes" xml:space="preserve">
          <source>The picking settings determine how the entity picking is handled. For more details about entity picking, see Qt3D.Render::ObjectPicker or Qt3D.Render::RayCaster component documentation.</source>
          <target state="translated">피킹 설정에 따라 엔터티 피킹 처리 방법이 결정됩니다. 엔티티 선택에 대한 자세한 내용은 Qt3D.Render :: ObjectPicker 또는 Qt3D.Render :: RayCaster 구성 요소 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9830bd5787b3b38dff87202fa6bd5801ed56cfd3" translate="yes" xml:space="preserve">
          <source>The picture format plugin is a simple plugin interface that makes it easy to create custom picture formats that can be used transparently by applications.</source>
          <target state="translated">그림 형식 플러그인은 응용 프로그램에서 투명하게 사용할 수있는 사용자 지정 그림 형식을 쉽게 만들 수있는 간단한 플러그인 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="2d8a4adcca8135952a8037777a0b1399ea5c4c15" translate="yes" xml:space="preserve">
          <source>The picture will be written using the specified picture format.</source>
          <target state="translated">사진은 지정된 사진 형식으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="8f824fe4f3dcfa8f1d4085b230c361de1d418f36" translate="yes" xml:space="preserve">
          <source>The pie is filled with the current &lt;a href=&quot;qpainter#brush&quot;&gt;brush&lt;/a&gt;().</source>
          <target state="translated">파이는 현재 &lt;a href=&quot;qpainter#brush&quot;&gt;브러시&lt;/a&gt; ()로 채워져 있습니다.</target>
        </trans-unit>
        <trans-unit id="588c83ece3af6bed150289b31d746748eb315604" translate="yes" xml:space="preserve">
          <source>The pie series that is used by the mapper. If you define the mapper element as a child for a &lt;a href=&quot;qml-qtcharts-pieseries&quot;&gt;PieSeries&lt;/a&gt;, leave this property undefined. All the data in the series is discarded when it is set to the mapper. When new series is specified the old series is disconnected (but it preserves its data).</source>
          <target state="translated">매퍼가 사용하는 파이 시리즈입니다. 매퍼 요소를 &lt;a href=&quot;qml-qtcharts-pieseries&quot;&gt;PieSeries&lt;/a&gt; 의 하위로 정의하는 경우이 특성을 정의하지 마십시오 . 매퍼로 설정하면 계열의 모든 데이터가 삭제됩니다. 새 시리즈가 지정되면 이전 시리즈의 연결이 끊어 지지만 데이터는 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="aeb09b603f63994baa14837880615d9bc248f327" translate="yes" xml:space="preserve">
          <source>The pie size.</source>
          <target state="translated">파이 크기.</target>
        </trans-unit>
        <trans-unit id="75c006d51f1121309b63dce5aebc10788dfd60d2" translate="yes" xml:space="preserve">
          <source>The pinch begins when this number of fingers are pressed. Until then, &lt;a href=&quot;qml-qtquick-pinchhandler&quot;&gt;PinchHandler&lt;/a&gt; tracks the positions of any pressed fingers, but if it's an insufficient number, it does not scale or rotate its &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt;, and the &lt;a href=&quot;qml-qtquick-pinchhandler#active-prop&quot;&gt;active&lt;/a&gt; property will remain false.</source>
          <target state="translated">이 손가락을 누르면 핀치가 시작됩니다. 그때까지, &lt;a href=&quot;qml-qtquick-pinchhandler&quot;&gt;PinchHandler는&lt;/a&gt; 어떤 눌러 진 손가락의 위치를 추적하지만 불충분 한 수 있다면, 그것은 확장 또는 회전하지 않는 &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;대상을&lt;/a&gt; , 그리고 &lt;a href=&quot;qml-qtquick-pinchhandler#active-prop&quot;&gt;활동적인&lt;/a&gt; 속성이 false 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="6250f1cf0bed47688d4212dff4f8155d9e43730b" translate="yes" xml:space="preserve">
          <source>The pixel aspect ratio of an image or video.</source>
          <target state="translated">이미지 또는 비디오의 픽셀 종횡비.</target>
        </trans-unit>
        <trans-unit id="35a61d3fa0eccf5cc6a2b0c0348000c41c43c3a8" translate="yes" xml:space="preserve">
          <source>The pixel component value difference with reduced contrast between source and &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; is written.</source>
          <target state="translated">소스와 &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;포 그라운드&lt;/a&gt; 소스 간의 대비가 감소 된 픽셀 구성 요소 값 차이 가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="c85e18860f802f8ff1b4790987bd1e0af60ada7f" translate="yes" xml:space="preserve">
          <source>The pixel component values from &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; are written over source by using alpha blending.</source>
          <target state="translated">&lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; 의 픽셀 구성 요소 값은 알파 블렌딩을 사용하여 소스 위에 쓰여집니다.</target>
        </trans-unit>
        <trans-unit id="38d855ca97f137801eb8e63d5f0c9c85edc2fb60" translate="yes" xml:space="preserve">
          <source>The pixel component values from source and &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; are added together and written.</source>
          <target state="translated">source 및 &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; 의 픽셀 구성 요소 값 이 함께 추가되고 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="f480b77850806e19cc02f18e2b065b19157a7a72" translate="yes" xml:space="preserve">
          <source>The pixel component values from source and &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; are averaged and written.</source>
          <target state="translated">source 및 &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; 의 픽셀 구성 요소 값 은 평균화되고 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="9e260f83638eff34fe9ae5c8ef35c3c78d494568" translate="yes" xml:space="preserve">
          <source>The pixel component values from source and &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; are multiplied together and written.</source>
          <target state="translated">source 및 &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; 의 픽셀 구성 요소 값 이 함께 곱해지고 쓰여집니다.</target>
        </trans-unit>
        <trans-unit id="32de41301a971315d370da620db4d254e6134597" translate="yes" xml:space="preserve">
          <source>The pixel component values from source are lightened or darkened according to &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; values and written.</source>
          <target state="translated">소스의 픽셀 구성 요소 값은 &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; 값 에 따라 밝아 지거나 어두워 지고 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="ae1f597acf630ea066f4137274804ff7fde64807" translate="yes" xml:space="preserve">
          <source>The pixel component values from source are lightened or darkened slightly according to &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; values and written.</source>
          <target state="translated">소스의 픽셀 구성 요소 값은 &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; 값 에 따라 약간 밝아 지거나 어두워 집니다.</target>
        </trans-unit>
        <trans-unit id="c757abcc36e3ecc00815eb6031c11379236c836d" translate="yes" xml:space="preserve">
          <source>The pixel component values from source is divided by the value from &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; and written.</source>
          <target state="translated">소스의 픽셀 구성 요소 값은 &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; 의 값으로 나뉘어 쓰여집니다.</target>
        </trans-unit>
        <trans-unit id="c2ecb435ece1fbf6e7bc4fa8c65d5b34368f982d" translate="yes" xml:space="preserve">
          <source>The pixel contents of a video frame can be mapped to memory using the &lt;a href=&quot;qvideoframe#map&quot;&gt;map&lt;/a&gt;() function. While mapped, the video data can accessed using the &lt;a href=&quot;qvideoframe#bits&quot;&gt;bits&lt;/a&gt;() function, which returns a pointer to a buffer. The total size of this buffer is given by the &lt;a href=&quot;qvideoframe#mappedBytes&quot;&gt;mappedBytes&lt;/a&gt;() function, and the size of each line is given by &lt;a href=&quot;qvideoframe#bytesPerLine&quot;&gt;bytesPerLine&lt;/a&gt;(). The return value of the &lt;a href=&quot;qvideoframe#handle&quot;&gt;handle&lt;/a&gt;() function may also be used to access frame data using the internal buffer's native APIs (for example - an OpenGL texture handle).</source>
          <target state="translated">비디오 프레임의 픽셀 내용은 &lt;a href=&quot;qvideoframe#map&quot;&gt;map&lt;/a&gt; () 함수를 사용하여 메모리에 매핑 될 수 있습니다 . 매핑되는 동안 &lt;a href=&quot;qvideoframe#bits&quot;&gt;비트&lt;/a&gt; () 함수를 사용하여 비디오 데이터에 액세스 할 수 있습니다.이 함수는 버퍼에 대한 포인터를 반환합니다. 이 버퍼의 총 크기는 &lt;a href=&quot;qvideoframe#mappedBytes&quot;&gt;mappingBytes&lt;/a&gt; () 함수에 의해 제공되며 각 행의 크기는 &lt;a href=&quot;qvideoframe#bytesPerLine&quot;&gt;bytesPerLine&lt;/a&gt; ()에 의해 제공됩니다 . &lt;a href=&quot;qvideoframe#handle&quot;&gt;handle&lt;/a&gt; () 함수 의 반환 값은 내부 버퍼의 고유 API (예 : OpenGL 텍스처 핸들)를 사용하여 프레임 데이터에 액세스하는 데 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c99ce38ce7c22d606cffcfef93b77d65cf41c68c" translate="yes" xml:space="preserve">
          <source>The pixel formats returned for the &lt;a href=&quot;qabstractvideobuffer#HandleType-enum&quot;&gt;QAbstractVideoBuffer::NoHandle&lt;/a&gt; type are valid for any buffer that can be mapped in read-only mode.</source>
          <target state="translated">&lt;a href=&quot;qabstractvideobuffer#HandleType-enum&quot;&gt;QAbstractVideoBuffer :: NoHandle&lt;/a&gt; 유형에 대해 리턴 된 픽셀 형식 은 읽기 전용 모드로 맵핑 될 수있는 모든 버퍼에 유효합니다.</target>
        </trans-unit>
        <trans-unit id="60b87604e440e0b040426dd9fe7ab48e3082496c" translate="yes" xml:space="preserve">
          <source>The pixel size of the font info that has been resolved for the current font and &lt;a href=&quot;qml-qtquick-text#fontSizeMode-prop&quot;&gt;fontSizeMode&lt;/a&gt;.</source>
          <target state="translated">현재 글꼴 및 &lt;a href=&quot;qml-qtquick-text#fontSizeMode-prop&quot;&gt;fontSizeMode에&lt;/a&gt; 대해 해결 된 글꼴 정보의 픽셀 크기입니다 .</target>
        </trans-unit>
        <trans-unit id="725cce1dafb2dc7ae6946762262a0eac5641ba28" translate="yes" xml:space="preserve">
          <source>The pixel values from source and &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; are negated, then multiplied, negated again, and written.</source>
          <target state="translated">source 및 &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; 의 픽셀 값 은 부정 된 다음 곱한 후 다시 부정되고 쓰여집니다.</target>
        </trans-unit>
        <trans-unit id="aee6c1052b8f19c88dfd32d1972a2302298b0992" translate="yes" xml:space="preserve">
          <source>The pixels in the destination are cleared (set to 0) independent of the source.</source>
          <target state="translated">대상의 픽셀은 소스와 상관없이 지워집니다 (0으로 설정).</target>
        </trans-unit>
        <trans-unit id="ebf1d2d3f9986a7dcc2766f5ad5e1f3f2427bc78" translate="yes" xml:space="preserve">
          <source>The pixels in the destination are cleared (set to fully transparent) independent of the source.</source>
          <target state="translated">대상의 픽셀은 소스와 상관없이 지워집니다 (완전 투명으로 설정 됨).</target>
        </trans-unit>
        <trans-unit id="d403d739b41efbb642d5da92093403f6fb61d353" translate="yes" xml:space="preserve">
          <source>The pixels in the destination are set (set to 1) independent of the source.</source>
          <target state="translated">대상의 픽셀은 소스와 독립적으로 설정됩니다 (1로 설정).</target>
        </trans-unit>
        <trans-unit id="defd16838986e3d7a2bbdf602e7c8d4a6cd803ad" translate="yes" xml:space="preserve">
          <source>The pixmap becomes monochrome. If necessary, it is dithered using the chosen dithering algorithm.</source>
          <target state="translated">픽스맵은 단색이됩니다. 필요한 경우 선택한 디더링 알고리즘을 사용하여 디더링됩니다.</target>
        </trans-unit>
        <trans-unit id="5dc6347ac62b4b39644f6e9cd3b3fcba307754e9" translate="yes" xml:space="preserve">
          <source>The pixmap can be smaller than the requested size. If</source>
          <target state="translated">픽스맵은 요청 된 크기보다 작을 수 있습니다. 만약</target>
        </trans-unit>
        <trans-unit id="afcae9d8fbd03f0b89d27ca7af825914e6784806" translate="yes" xml:space="preserve">
          <source>The pixmap can be smaller than the requested size. The returned size is in device-independent pixels (This is relevant for high-dpi pixmaps.)</source>
          <target state="translated">픽스맵은 요청 된 크기보다 작을 수 있습니다. 반환 된 크기는 장치 독립적 픽셀입니다 (고 dpi 픽스맵과 관련이 있습니다).</target>
        </trans-unit>
        <trans-unit id="b29534311d6f48b567bd4f9894c32aae749742f0" translate="yes" xml:space="preserve">
          <source>The pixmap depth is also called bits per pixel (bpp) or bit planes of a pixmap. A null pixmap has depth 0.</source>
          <target state="translated">픽스맵 깊이는 픽셀 당 비트 수 (bpp) 또는 픽스맵의 비트 평면이라고도합니다. 널 픽스맵의 깊이는 0입니다.</target>
        </trans-unit>
        <trans-unit id="321db50429c6a12e397bbc190f67b723d22ea943" translate="yes" xml:space="preserve">
          <source>The pixmap for use as a live (peek) preview when tabbing into the application.</source>
          <target state="translated">응용 프로그램을 탭할 때 라이브 (엿보기) 미리보기로 사용하기위한 픽스맵입니다.</target>
        </trans-unit>
        <trans-unit id="45f50014c27fd8c76cf32dbad73df16fedd94933" translate="yes" xml:space="preserve">
          <source>The pixmap for use as a thumbnail representation</source>
          <target state="translated">축소판 그림으로 사용하기위한 픽스맵</target>
        </trans-unit>
        <trans-unit id="06e32a7b7ba47f5e73a20608105513ec15441d8f" translate="yes" xml:space="preserve">
          <source>The pixmap is dithered/converted to the &lt;a href=&quot;qpixmap#defaultDepth&quot;&gt;native display depth&lt;/a&gt;.</source>
          <target state="translated">픽스맵은 &lt;a href=&quot;qpixmap#defaultDepth&quot;&gt;기본 디스플레이 깊이&lt;/a&gt; 로 디더링 / 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8c8bccbb29f831b38eef96427fc863448d10c501" translate="yes" xml:space="preserve">
          <source>The pixmap is drawn at the item's (0, 0) coordinate, as returned by &lt;a href=&quot;qgraphicspixmapitem#offset&quot;&gt;offset&lt;/a&gt;(). You can change the drawing offset by calling &lt;a href=&quot;qgraphicspixmapitem#setOffset&quot;&gt;setOffset&lt;/a&gt;().</source>
          <target state="translated">픽스맵은 &lt;a href=&quot;qgraphicspixmapitem#offset&quot;&gt;오프셋&lt;/a&gt; ()에 의해 반환 된대로 항목의 (0, 0) 좌표에 그려집니다 . &lt;a href=&quot;qgraphicspixmapitem#setOffset&quot;&gt;setOffset&lt;/a&gt; () 을 호출하여 도면 오프셋을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6a064136f43e7b00f98e809c2f2109438acd550" translate="yes" xml:space="preserve">
          <source>The pixmap should be padded to ensure it has a completely transparent border.</source>
          <target state="translated">픽스맵은 완전히 투명한 테두리를 갖도록 채워 져야합니다.</target>
        </trans-unit>
        <trans-unit id="448b6b05fe698c5712c3926dd4800c19526805cb" translate="yes" xml:space="preserve">
          <source>The pixmap should be padded to match the effective bounding rectangle of the effect.</source>
          <target state="translated">픽스맵은 효과의 유효 경계 사각형과 일치하도록 채워 져야합니다.</target>
        </trans-unit>
        <trans-unit id="3e56eae666af0abee6fc82b27cc5cb0bf5de8fc9" translate="yes" xml:space="preserve">
          <source>The pixmap should not receive any additional padding.</source>
          <target state="translated">pixmap은 추가 패딩을받지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="645bfc1c2b19bd030c38d61ffc97948236d8e452" translate="yes" xml:space="preserve">
          <source>The pixmap that occupies the background of a &lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;MacStyle&lt;/a&gt; wizard</source>
          <target state="translated">&lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;MacStyle&lt;/a&gt; 마법사 의 배경을 차지하는 픽스맵</target>
        </trans-unit>
        <trans-unit id="6e223815457a9e4fd261e4d75e92953d6ab7dc38" translate="yes" xml:space="preserve">
          <source>The pixmap that occupies the background of a &lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;ModernStyle&lt;/a&gt; page header</source>
          <target state="translated">&lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;ModernStyle&lt;/a&gt; 의 배경을 차지하는 픽스맵 페이지 헤더</target>
        </trans-unit>
        <trans-unit id="ead005fba056498e508694862b774fe1507cadfd" translate="yes" xml:space="preserve">
          <source>The pixmap used to display the actual icon depends on the current &lt;a href=&quot;qwidget#style&quot;&gt;GUI style&lt;/a&gt;. You can also set a custom pixmap for the icon by setting the &lt;a href=&quot;qmessagebox#iconPixmap-prop&quot;&gt;icon pixmap&lt;/a&gt; property.</source>
          <target state="translated">실제 아이콘을 표시하는 데 사용되는 픽스맵은 현재 &lt;a href=&quot;qwidget#style&quot;&gt;GUI 스타일&lt;/a&gt; 에 따라 다릅니다 . &lt;a href=&quot;qmessagebox#iconPixmap-prop&quot;&gt;icon pixmap&lt;/a&gt; 속성 을 설정하여 아이콘 에 대한 사용자 정의 픽스맵을 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6de6a70344711a40f47f4dee3cf5cd3c8ac99370" translate="yes" xml:space="preserve">
          <source>The pixmaps are used by &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; when displaying a page. Which pixmaps are actually used depend on the &lt;a href=&quot;qwizard#wizard-look-and-feel&quot;&gt;wizard style&lt;/a&gt;.</source>
          <target state="translated">픽스맵은 페이지를 표시 할 때 &lt;a href=&quot;qwizard&quot;&gt;QWizard에서&lt;/a&gt; 사용 합니다. 실제로 사용되는 픽스맵은 &lt;a href=&quot;qwizard#wizard-look-and-feel&quot;&gt;마법사 스타일&lt;/a&gt; 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="ea0ebc1669363adabca176c689e2ce9d2cc65849" translate="yes" xml:space="preserve">
          <source>The place details are currently being fetched, no other operations may be performed until complete.</source>
          <target state="translated">장소 세부 정보를 현재 가져오고 있으며 완료 될 때까지 다른 작업을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7166ee174af5122d0d58cefd20dca6d4ede70e07" translate="yes" xml:space="preserve">
          <source>The place details consist of properties of the place, such as the name, location, contact information and so on. When a place is returned during a search, these details are filled in. Sometimes in order to save bandwidth, there are further details about the place that can be retrieved on an individual place by place basis, if the user is interested. The &lt;a href=&quot;qplace#detailsFetched&quot;&gt;QPlace::detailsFetched&lt;/a&gt;() function can be queried to see if all available details have been fetched, and if not, &lt;a href=&quot;qplacemanager#getPlaceDetails&quot;&gt;QPlaceManager::getPlaceDetails&lt;/a&gt;() can be used to retrieve them. Precisely which details are populated during a search and which need to be fetched individually may vary from provider to provider. See &lt;a href=&quot;qtlocation-index#plugin-references-and-parameters&quot;&gt;plugin documentation&lt;/a&gt; for more details.</source>
          <target state="translated">장소 세부 정보는 이름, 위치, 연락처 정보 등 장소의 속성으로 구성됩니다. 검색 중에 장소가 반환되면 이러한 세부 정보가 채워집니다. 때때로 대역폭을 절약하기 위해 사용자가 관심이있는 경우 장소별로 개별 장소에서 검색 할 수있는 장소에 대한 추가 정보가 있습니다. &lt;a href=&quot;qplace#detailsFetched&quot;&gt;QPlace :: detailsFetched&lt;/a&gt; () 함수는 사용 가능한 모든 세부 사항이 인출되었습니다 있는지 조회 할 수 있고,하지 않을 경우, &lt;a href=&quot;qplacemanager#getPlaceDetails&quot;&gt;QPlaceManager :: getPlaceDetails는&lt;/a&gt; ()를 검색 할 수 있습니다. 검색 중에 채워진 세부 정보와 개별적으로 가져와야하는 세부 정보는 공급자마다 다를 수 있습니다. &lt;a href=&quot;qtlocation-index#plugin-references-and-parameters&quot;&gt;플러그인 문서를&lt;/a&gt; 참조하십시오 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6b283ab35ebc2a3a2d28630a8e6c2e8ef4a07ac7" translate="yes" xml:space="preserve">
          <source>The place is currently being removed, no other operations can be performed until complete.</source>
          <target state="translated">작업 공간이 현재 제거되고 있으며 완료 될 때까지 다른 작업을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="20724bfc79e078d205e7d06315ecb967aba97b3c" translate="yes" xml:space="preserve">
          <source>The place is currently being saved, no other operation may be performed until complete.</source>
          <target state="translated">장소가 현재 저장되고 있으며 완료 될 때까지 다른 작업을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2872abbe8bd795afd45c85d18f2e96c9089f69b4" translate="yes" xml:space="preserve">
          <source>The place is limited to the current device. The place will not be transferred off of the device.</source>
          <target state="translated">장소는 현재 장치로 제한됩니다. 장소는 기기에서 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67d27412e8552d6d9294d098440931bab11b541a" translate="yes" xml:space="preserve">
          <source>The place is private to the current user. The place may be transferred to an online service but is only ever visible to the current user.</source>
          <target state="translated">장소는 현재 사용자에게 비공개입니다. 장소는 온라인 서비스로 이전 될 수 있지만 현재 사용자 만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57b789e44a7bcdfc529b4f26d8aa992513096864" translate="yes" xml:space="preserve">
          <source>The place is public.</source>
          <target state="translated">장소는 공개입니다.</target>
        </trans-unit>
        <trans-unit id="7aebba75f9367bfec89024945a2ed924836cc755" translate="yes" xml:space="preserve">
          <source>The placeholder text color, used when the text field is empty.</source>
          <target state="translated">텍스트 필드가 비어있을 때 사용되는 자리 표시 자 텍스트 색입니다.</target>
        </trans-unit>
        <trans-unit id="440bd4a9540a31bd1affc79191d619b4ca8a491f" translate="yes" xml:space="preserve">
          <source>The placement of the sorting indicator may appear in list or table headers. Possible values are &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt::Alignment&lt;/a&gt; values (that is, an OR combination of &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt::AlignmentFlag&lt;/a&gt; flags).</source>
          <target state="translated">정렬 표시기의 배치는 목록 또는 테이블 머리글에 나타날 수 있습니다. 가능한 값은 &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt :: Alignment&lt;/a&gt; 값 (즉, &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt :: AlignmentFlag&lt;/a&gt; 플래그 의 OR 조합 )입니다.</target>
        </trans-unit>
        <trans-unit id="4cac99526f3cb2e0e09891bbfb2aca74e3774ab3" translate="yes" xml:space="preserve">
          <source>The places to be added to the map are &lt;a href=&quot;location-maps-qml#putting-objects-on-a-map-map-overlay-objects&quot;&gt;MapItems&lt;/a&gt;. The item's position is defined by a &lt;a href=&quot;qml-coordinate&quot;&gt;coordinate&lt;/a&gt; which includes latitude, longitude and altitude. The item is then displayed automatically after it is added to the &lt;a href=&quot;qml-qtlocation-map&quot;&gt;Map&lt;/a&gt;.</source>
          <target state="translated">맵에 추가 할 장소는 &lt;a href=&quot;location-maps-qml#putting-objects-on-a-map-map-overlay-objects&quot;&gt;MapItems&lt;/a&gt; 입니다. 항목의 위치는 위도, 경도 및 고도를 포함 하는 &lt;a href=&quot;qml-coordinate&quot;&gt;좌표&lt;/a&gt; 로 정의됩니다 . 그런 다음 항목이 &lt;a href=&quot;qml-qtlocation-map&quot;&gt;맵에&lt;/a&gt; 추가 된 후 자동으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6534c5f7067ac7185b0c82d5ebf1bef6fabb2168" translate="yes" xml:space="preserve">
          <source>The plain text after the cursor. The widget can decide how much text to return, but &lt;b&gt;must&lt;/b&gt; not return an empty string unless the cursor is at the end of the document.</source>
          <target state="translated">커서 다음의 일반 텍스트 위젯은 반환하는 방법을 많은 텍스트를 결정할 수 있지만, &lt;b&gt;반드시&lt;/b&gt; 커서가 문서의 끝에 있지 않으면 빈 문자열을 반환 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0fad36e552fe0b698175aa068d63aea969bf597d" translate="yes" xml:space="preserve">
          <source>The plain text around the input area, for example the current paragraph.</source>
          <target state="translated">입력 영역 주변의 일반 텍스트 (예 : 현재 단락)</target>
        </trans-unit>
        <trans-unit id="7b5551e54182bae98464fd0445330278159fccd4" translate="yes" xml:space="preserve">
          <source>The plain text before the cursor. The widget can decide how much text to return, but &lt;b&gt;must&lt;/b&gt; not return an empty string unless the cursor is at the start of the document.</source>
          <target state="translated">커서 앞의 일반 텍스트 위젯은 반환하는 방법을 많은 텍스트를 결정할 수 있지만, &lt;b&gt;반드시&lt;/b&gt; 커서가 문서의 시작 부분에 있지 않으면 빈 문자열을 반환 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0f7015d163baa5cc4038ee6315c63d8b61e1c206" translate="yes" xml:space="preserve">
          <source>The playback volume is scaled linearly, ranging from &lt;code&gt;0&lt;/code&gt; (silence) to &lt;code&gt;100&lt;/code&gt; (full volume). Values outside this range will be clamped.</source>
          <target state="translated">재생 음량은 &lt;code&gt;0&lt;/code&gt; (무음)에서 &lt;code&gt;100&lt;/code&gt; 까지 선형으로 조정 됩니다. (풀 음량) 됩니다. 이 범위 밖의 값은 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="3f1d87e948dd678cdb0eba88d689c290289accf0" translate="yes" xml:space="preserve">
          <source>The player has fully buffered the current media. The player is in the &lt;a href=&quot;qmediaplayer#State-enum&quot;&gt;PlayingState&lt;/a&gt; or &lt;a href=&quot;qmediaplayer#State-enum&quot;&gt;PausedState&lt;/a&gt;.</source>
          <target state="translated">플레이어가 현재 미디어를 완전히 버퍼링했습니다. 플레이어가 &lt;a href=&quot;qmediaplayer#State-enum&quot;&gt;PlayingState&lt;/a&gt; 또는 &lt;a href=&quot;qmediaplayer#State-enum&quot;&gt;PausedState에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd6c29ed446d0ecf44e2d8438f65bd8bedba1a30" translate="yes" xml:space="preserve">
          <source>The player is buffering data but has enough data buffered for playback to continue for the immediate future. The player is in the &lt;a href=&quot;qmediaplayer#State-enum&quot;&gt;PlayingState&lt;/a&gt; or &lt;a href=&quot;qmediaplayer#State-enum&quot;&gt;PausedState&lt;/a&gt;.</source>
          <target state="translated">플레이어가 데이터를 버퍼링하고 있지만 앞으로 재생할 수 있도록 충분한 버퍼링 된 데이터가 재생됩니다. 플레이어가 &lt;a href=&quot;qmediaplayer#State-enum&quot;&gt;PlayingState&lt;/a&gt; 또는 &lt;a href=&quot;qmediaplayer#State-enum&quot;&gt;PausedState에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="f238f8df871feb882950a354f4914e209a2cbefa" translate="yes" xml:space="preserve">
          <source>The player is expected to be able to render to a &lt;a href=&quot;qabstractvideosurface&quot;&gt;QAbstractVideoSurface&lt;/a&gt;&lt;a href=&quot;qmediaplayer#setVideoOutput&quot;&gt;output&lt;/a&gt;.</source>
          <target state="translated">플레이어는 &lt;a href=&quot;qabstractvideosurface&quot;&gt;QAbstractVideoSurface &lt;/a&gt;&lt;a href=&quot;qmediaplayer#setVideoOutput&quot;&gt;출력&lt;/a&gt; 으로 렌더링 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="acdca59bb76ef3625f2ad291a29179aadc7e50f3" translate="yes" xml:space="preserve">
          <source>The player is expected to be used with simple audio formats, but playback should start without significant delay. Such playback service can be used for beeps, ringtones, etc.</source>
          <target state="translated">플레이어는 간단한 오디오 형식을 사용해야하지만 상당한 지연없이 재생을 시작해야합니다. 이러한 재생 서비스는 경고음, 벨소리 등을 위해 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bc6d1a974e98842a5a8a1f8dacd6727ffdafbd2" translate="yes" xml:space="preserve">
          <source>The player is expected to play &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; based streams. If passed to &lt;a href=&quot;qmediaplayer&quot;&gt;QMediaPlayer&lt;/a&gt; constructor, the service supporting streams playback will be chosen.</source>
          <target state="translated">플레이어는 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; 기반 스트림 을 재생할 것으로 예상됩니다 . &lt;a href=&quot;qmediaplayer&quot;&gt;QMediaPlayer로&lt;/a&gt; 전달 된 경우 생성자에 스트림 재생을 지원하는 서비스가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="c6ca3fa39a81668b72b9ceaf0b96bc36aafbb7c9" translate="yes" xml:space="preserve">
          <source>The player is loading a Bodymovin file</source>
          <target state="translated">플레이어가 Bodymovin 파일을로드 중입니다</target>
        </trans-unit>
        <trans-unit id="167e1af2dd1ea04ec47a912a1c8cb641b85752c1" translate="yes" xml:space="preserve">
          <source>The player object will use the &lt;a href=&quot;qmediacontent&quot;&gt;QMediaContent&lt;/a&gt; for selection of the content to be played.</source>
          <target state="translated">플레이어 객체는 재생할 콘텐츠를 선택 하기 위해 &lt;a href=&quot;qmediacontent&quot;&gt;QMediaContent&lt;/a&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b09bbd68938a7b96db140ab7291665f27bf798b0" translate="yes" xml:space="preserve">
          <source>The player object will use the current playlist item for selection of the content to be played.</source>
          <target state="translated">플레이어 객체는 재생할 콘텐츠를 선택하기 위해 현재 재생 목록 항목을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0e2c69e1b3d13b7156ba63b713e0907a3ce12126" translate="yes" xml:space="preserve">
          <source>The plot area does not include the area defined by margins. By default this will resize if inside a &lt;a href=&quot;qchartview&quot;&gt;QChartView&lt;/a&gt;. If an explicit size is set for the plot area then it will respect this, to revert back to the default behavior, then calling &lt;code&gt;setPlotArea(QRectF());&lt;/code&gt; will achieve this.</source>
          <target state="translated">플롯 영역에는 여백으로 정의 된 영역이 포함되지 않습니다. 기본적으로 &lt;a href=&quot;qchartview&quot;&gt;QChartView&lt;/a&gt; 안에 있으면 크기가 조정됩니다 . 플롯 영역에 대해 명시적인 크기가 설정된 경우이를 존중하여 기본 동작으로 &lt;code&gt;setPlotArea(QRectF());&lt;/code&gt; 이것을 달성 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="f39631c342d2f476c400999bbda7219bd0927364" translate="yes" xml:space="preserve">
          <source>The plot area does not include the area defined by margins. By default this will resize if inside a &lt;a href=&quot;qml-qtcharts-chartview&quot;&gt;ChartView&lt;/a&gt;. If an explicit rectangle is set for the plot area then it will respect this, to revert back to the default behavior, then setting it to &lt;code&gt;Qt.rect(0, 0, 0, 0)&lt;/code&gt; will achieve this.</source>
          <target state="translated">플롯 영역에는 여백으로 정의 된 영역이 포함되지 않습니다. 기본적으로 &lt;a href=&quot;qml-qtcharts-chartview&quot;&gt;ChartView&lt;/a&gt; 안에 있으면 크기가 조정됩니다 . 플롯 영역에 명시 적 사각형이 설정되어 있으면이를 존중하고 기본 동작으로 되 돌린 다음 &lt;code&gt;Qt.rect(0, 0, 0, 0)&lt;/code&gt; 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="4ec19221185ba500c0658c9035be21955dc38aed" translate="yes" xml:space="preserve">
          <source>The plugin can add keyboard layouts for the virtual keyboard by including the layout files in the Qt resources of the plugin binary.</source>
          <target state="translated">플러그인은 플러그인 바이너리의 Qt 리소스에 레이아웃 파일을 포함시켜 가상 키보드의 키보드 레이아웃을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48f089b76a6a8a3c9ecb0d779ed548acf9c5da89" translate="yes" xml:space="preserve">
          <source>The plugin can read images incrementally.</source>
          <target state="translated">플러그인은 이미지를 점차적으로 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb2cdd4122558a82ffdc05fc7a8d25fd96e0428d" translate="yes" xml:space="preserve">
          <source>The plugin can read images.</source>
          <target state="translated">플러그인은 이미지를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9db49bda8ba951712f17d40b0a31aa282ef3258" translate="yes" xml:space="preserve">
          <source>The plugin can register an input method that other keyboard layouts can use by default (such as &lt;code&gt;DefaultInputMethod&lt;/code&gt;) or an input method that is used privately in the plugin.</source>
          <target state="translated">플러그인은 다른 키보드 레이아웃이 기본적으로 사용할 수있는 입력 방법 (예 : &lt;code&gt;DefaultInputMethod&lt;/code&gt; ) 또는 플러그인에서 개인적으로 사용되는 입력 방법을 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78d51a86cf6a023eec0ba16e9355c36356f48536" translate="yes" xml:space="preserve">
          <source>The plugin can write images.</source>
          <target state="translated">플러그인은 이미지를 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4489702548b9776bc715f6f0c66a0f45ea13c0c" translate="yes" xml:space="preserve">
          <source>The plugin could not connect to its backend service or database.</source>
          <target state="translated">플러그인이 백엔드 서비스 또는 데이터베이스에 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="416b6c4e9223e05993b757fa612f71162233c0cd" translate="yes" xml:space="preserve">
          <source>The plugin did not find one of the parameters it was expecting.</source>
          <target state="translated">플러그인이 예상 한 매개 변수 중 하나를 찾지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="bf460e09ee5cebeb84c55af9107d92b6da67a1df" translate="yes" xml:space="preserve">
          <source>The plugin did not recognize one of the parameters it was given.</source>
          <target state="translated">플러그인이 제공된 매개 변수 중 하나를 인식하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="5073aaf2acf2517dc5cdaf7c455407371ce95231" translate="yes" xml:space="preserve">
          <source>The plugin does not necessarily require hardware acceleration. You can also use WARP, the Direct3D software rasterizer. By default, the first adapter providing hardware acceleration is chosen. To override this and use another graphics adapter or to force the use of the software rasterizer, set the &lt;code&gt;QT_D3D_ADAPTER_INDEX&lt;/code&gt; environment variable to the index of the adapter. The adapters discovered are printed at startup when &lt;code&gt;QSG_INFO&lt;/code&gt; or the &lt;code&gt;qt.scenegraph.general&lt;/code&gt; logging category is enabled.</source>
          <target state="translated">플러그인에는 반드시 하드웨어 가속이 필요하지 않습니다. Direct3D 소프트웨어 래스터 라이저 인 WARP를 사용할 수도 있습니다. 기본적으로 하드웨어 가속을 제공하는 첫 번째 어댑터가 선택됩니다. 이를 무시하고 다른 그래픽 어댑터를 사용하거나 소프트웨어 래스터 라이저를 강제로 사용하려면 &lt;code&gt;QT_D3D_ADAPTER_INDEX&lt;/code&gt; 환경 변수를 어댑터의 색인으로 설정하십시오. 발견 된 어댑터는 &lt;code&gt;QSG_INFO&lt;/code&gt; 또는 &lt;code&gt;qt.scenegraph.general&lt;/code&gt; 로깅 범주가 사용 가능한 경우 시작시 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="b5cba09927d53667ea8e7dd7bef4ea55ee35000a" translate="yes" xml:space="preserve">
          <source>The plugin does not support this functionality.</source>
          <target state="translated">플러그인은이 기능을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a80f76651540bf2141da5e2cc48b12df578aaff6" translate="yes" xml:space="preserve">
          <source>The plugin failed to load.</source>
          <target state="translated">플러그인을로드하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="81aaddfc9ab0b98195722100a285ecbc536a22e3" translate="yes" xml:space="preserve">
          <source>The plugin has to be a Qt plugin which implements the &lt;a href=&quot;qqmlextensionplugin&quot;&gt;QQmlExtensionPlugin&lt;/a&gt; interface.</source>
          <target state="translated">플러그인은 &lt;a href=&quot;qqmlextensionplugin&quot;&gt;QQmlExtensionPlugin&lt;/a&gt; 을 구현하는 Qt 플러그인 이어야합니다. 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="13686c19bcf5d60b18256a128dde2707ea41845a" translate="yes" xml:space="preserve">
          <source>The plugin itself provides an input framework supporting multiple input methods as well as a QML UI for the virtual keyboard. The input framework is extensible through a plugin interface, which allows third-party input methods and keyboard layouts to be loaded at runtime.</source>
          <target state="translated">플러그인 자체는 가상 키보드의 QML UI뿐만 아니라 여러 입력 방법을 지원하는 입력 프레임 워크를 제공합니다. 입력 프레임 워크는 플러그인 인터페이스를 통해 확장 가능하므로 런타임시 타사 입력 방법 및 키보드 레이아웃을로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="962ad81359cdf23b596cef98e88b1657dc6d6157" translate="yes" xml:space="preserve">
          <source>The plugin priority. If multiple plugins have the same provider name, the plugin with the higest priority will be used.</source>
          <target state="translated">플러그인 우선 순위. 여러 플러그인이 동일한 제공자 이름을 갖는 경우, 가장 우선 순위가 가장 높은 플러그인이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="97f947a5b5f6c3091d22007158bceb996c8f37d7" translate="yes" xml:space="preserve">
          <source>The plugin provides the virtual keyboard with the necessary metadata, which allows it to sort and load the plugins.</source>
          <target state="translated">플러그인은 가상 키보드에 필요한 메타 데이터를 제공하여 플러그인을 정렬하고로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f98f8d9460a95eae6e82895e16830c7c8fcb9887" translate="yes" xml:space="preserve">
          <source>The plugin version. If multiple plugins have the same provider name, the plugin with the higest version will be used.</source>
          <target state="translated">플러그인 버전. 여러 플러그인이 동일한 제공자 이름을 갖는 경우, 가장 최신 버전의 플러그인이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4c1c703b94bda4d160059fe5568ec24dd4c8e719" translate="yes" xml:space="preserve">
          <source>The point</source>
          <target state="translated">요점</target>
        </trans-unit>
        <trans-unit id="34017f6886cfce4e73d7253d31967121f1afea65" translate="yes" xml:space="preserve">
          <source>The point (x, y) is the original point, and (x', y') is the transformed point.</source>
          <target state="translated">점 (x, y)는 원래 점이고 (x ', y')는 변형 된 점입니다.</target>
        </trans-unit>
        <trans-unit id="2fe392a9792db145fd8b50af6032123c2d15a869" translate="yes" xml:space="preserve">
          <source>The point at which input occurred can lie close to input-sensitive parts of the document.</source>
          <target state="translated">입력이 발생한 지점은 문서의 입력에 민감한 부분에 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="72c65ddafc6903cd440a6b717b406520663bc267" translate="yes" xml:space="preserve">
          <source>The point at which input occurred must coincide exactly with input-sensitive parts of the document.</source>
          <target state="translated">입력이 발생한 지점은 문서의 입력에 민감한 부분과 정확하게 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="c5392466fea2b7830ae6454ee7100059d08baf58" translate="yes" xml:space="preserve">
          <source>The point in the loading process at which the script will be executed.</source>
          <target state="translated">로드 프로세스에서 스크립트가 실행될 지점.</target>
        </trans-unit>
        <trans-unit id="c903cc12c4897dd15c35be203817260d2dfb0652" translate="yes" xml:space="preserve">
          <source>The point in the loading process at which the script will be executed. The default value is &lt;code&gt;Deferred&lt;/code&gt;.</source>
          <target state="translated">로드 프로세스에서 스크립트가 실행될 지점. 기본값은 &lt;code&gt;Deferred&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dc5633d40994340efcd221b6868ac86eb61508a6" translate="yes" xml:space="preserve">
          <source>The point is kept up-to-date when the &lt;a href=&quot;qml-qtquick-draghandler&quot;&gt;DragHandler&lt;/a&gt; is actively responding to an &lt;a href=&quot;qml-qtquick-eventpoint&quot;&gt;EventPoint&lt;/a&gt;; but when the point is released, or the current point is being handled by a different handler, &lt;code&gt;position.x&lt;/code&gt; and &lt;code&gt;position.y&lt;/code&gt; are 0.</source>
          <target state="translated">요점은 최신 상태로 유지하는 &lt;a href=&quot;qml-qtquick-draghandler&quot;&gt;DragHandler가&lt;/a&gt; 적극적으로 대응하고 &lt;a href=&quot;qml-qtquick-eventpoint&quot;&gt;EventPoint&lt;/a&gt; ; 그러나 점이 해제되거나 현재 점이 다른 핸들러에 의해 처리되는 경우 &lt;code&gt;position.x&lt;/code&gt; 및 &lt;code&gt;position.y&lt;/code&gt; 는 0입니다.</target>
        </trans-unit>
        <trans-unit id="aa661b251346dc07a71fe42ba2a1bec0b53cc786" translate="yes" xml:space="preserve">
          <source>The point size is by the &lt;a href=&quot;qt3drender-qpointsize#value-prop&quot;&gt;QPointSize::value&lt;/a&gt;.</source>
          <target state="translated">포인트 크기는 &lt;a href=&quot;qt3drender-qpointsize#value-prop&quot;&gt;QPointSize :: value&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="88058a26a1e1bb8dfe6dcedac53327479fa2595a" translate="yes" xml:space="preserve">
          <source>The point size is defined to match if it is within 20% of the requested point size. When several fonts match and are only distinguished by point size, the font with the closest point size to the one requested will be chosen.</source>
          <target state="translated">포인트 크기는 요청 된 포인트 크기의 20 % 내에있는 경우 일치하도록 정의됩니다. 여러 글꼴이 일치하고 포인트 크기로만 구분되는 경우 요청 된 글꼴과 가장 가까운 글꼴 크기가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="78e25db71adf6040c596c426012d695e7d3491cb" translate="yes" xml:space="preserve">
          <source>The point size value must be set in shader</source>
          <target state="translated">포인트 크기 값은 셰이더로 설정해야합니다</target>
        </trans-unit>
        <trans-unit id="0113d25f690d9408947da8809f0dacede472c85c" translate="yes" xml:space="preserve">
          <source>The point under the mouse is used as the anchor.</source>
          <target state="translated">마우스 아래의 점이 앵커로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8c550b1b0eb72892b8f022a2845f78ef6af5c01e" translate="yes" xml:space="preserve">
          <source>The pointSize of the font info that has been resolved for the current font and &lt;a href=&quot;qml-qtquick-text#fontSizeMode-prop&quot;&gt;fontSizeMode&lt;/a&gt;.</source>
          <target state="translated">현재 글꼴 및 &lt;a href=&quot;qml-qtquick-text#fontSizeMode-prop&quot;&gt;fontSizeMode에&lt;/a&gt; 대해 해결 된 글꼴 정보의 pointSize .</target>
        </trans-unit>
        <trans-unit id="0b4bb95d6a8d2b3e99a53954eaab5d58c7eb10b4" translate="yes" xml:space="preserve">
          <source>The pointer</source>
          <target state="translated">포인터</target>
        </trans-unit>
        <trans-unit id="1288e6ad1cc83051db36e89cd46736907dabd620" translate="yes" xml:space="preserve">
          <source>The pointer cannot be referenced after this call.</source>
          <target state="translated">이 호출 후에 포인터를 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="767dcc72c7390e07359bafa0477b9a220472991d" translate="yes" xml:space="preserve">
          <source>The pointer remains valid as long as the array isn't reallocated.</source>
          <target state="translated">배열이 재 할당되지 않는 한 포인터는 유효합니다.</target>
        </trans-unit>
        <trans-unit id="ac8888a455b92b3e816acf956d950f33170c8f19" translate="yes" xml:space="preserve">
          <source>The pointer remains valid as long as the byte array isn't reallocated or destroyed. For read-only access, &lt;a href=&quot;qbytearray#constData&quot;&gt;constData&lt;/a&gt;() is faster because it never causes a &lt;a href=&quot;implicit-sharing#deep-copy&quot;&gt;deep copy&lt;/a&gt; to occur.</source>
          <target state="translated">바이트 배열이 재 할당되거나 소멸되지 않는 한 포인터는 유효합니다. 읽기 전용 액세스의 경우 &lt;a href=&quot;qbytearray#constData&quot;&gt;constData&lt;/a&gt; ()는 &lt;a href=&quot;implicit-sharing#deep-copy&quot;&gt;깊은 복사를&lt;/a&gt; 일으키지 않기 때문에 더 빠릅니다. 가 발생 .</target>
        </trans-unit>
        <trans-unit id="753b11a127f9923383e692af0f6aed456671daba" translate="yes" xml:space="preserve">
          <source>The pointer remains valid as long as the vector isn't reallocated.</source>
          <target state="translated">벡터가 재 할당되지 않는 한 포인터는 계속 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d6bda9d6c7bfa3d471ab377b79fdf282cb52545b" translate="yes" xml:space="preserve">
          <source>The pointer returned by this function becomes invalid if the sender is destroyed, or if the slot is disconnected from the sender's signal.</source>
          <target state="translated">이 기능에 의해 반환 된 포인터는 발신자가 파괴되거나 슬롯이 발신자의 신호에서 분리 된 경우 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56d15fc2af64f6348be3442f312789079103e06d" translate="yes" xml:space="preserve">
          <source>The pointer to</source>
          <target state="translated">에 대한 포인터</target>
        </trans-unit>
        <trans-unit id="5d3af745ec1a77cb5a5a5632b435baf83a9d6c49" translate="yes" xml:space="preserve">
          <source>The points</source>
          <target state="translated">포인트</target>
        </trans-unit>
        <trans-unit id="94f9c0bfda11fe54f5196ac8132df6ea2717f15b" translate="yes" xml:space="preserve">
          <source>The points are given as a sequence of integers, starting with</source>
          <target state="translated">점은 다음과 같이 시작하는 정수 시퀀스로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="56d42cc9295866877b2489173f9387745c7d3968" translate="yes" xml:space="preserve">
          <source>The policies can be altered using the &lt;a href=&quot;qsizepolicy#setHorizontalPolicy&quot;&gt;setHorizontalPolicy&lt;/a&gt;() and &lt;a href=&quot;qsizepolicy#setVerticalPolicy&quot;&gt;setVerticalPolicy&lt;/a&gt;() functions. Use the &lt;a href=&quot;qsizepolicy#setHeightForWidth&quot;&gt;setHeightForWidth&lt;/a&gt;() function if the preferred height of the widget is dependent on the width of the widget (for example, a &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; with line wrapping).</source>
          <target state="translated">&lt;a href=&quot;qsizepolicy#setHorizontalPolicy&quot;&gt;setHorizontalPolicy&lt;/a&gt; () 및 &lt;a href=&quot;qsizepolicy#setVerticalPolicy&quot;&gt;setVerticalPolicy&lt;/a&gt; () 함수를 사용하여 정책을 변경할 수 있습니다 . 위젯의 선호 높이가 위젯의 너비 (예 : 줄 바꿈이 있는 &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; )에 종속되는 경우 &lt;a href=&quot;qsizepolicy#setHeightForWidth&quot;&gt;setHeightForWidth&lt;/a&gt; () 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9a9928d4f1bfdb0b60244de3f3512f9a5c68f7e" translate="yes" xml:space="preserve">
          <source>The policy is &lt;a href=&quot;qt#FocusPolicy-enum&quot;&gt;Qt::TabFocus&lt;/a&gt; if the widget accepts keyboard focus by tabbing, &lt;a href=&quot;qt#FocusPolicy-enum&quot;&gt;Qt::ClickFocus&lt;/a&gt; if the widget accepts focus by clicking, &lt;a href=&quot;qt#FocusPolicy-enum&quot;&gt;Qt::StrongFocus&lt;/a&gt; if it accepts both, and &lt;a href=&quot;qt#FocusPolicy-enum&quot;&gt;Qt::NoFocus&lt;/a&gt; (the default) if it does not accept focus at all.</source>
          <target state="translated">정책은 &lt;a href=&quot;qt#FocusPolicy-enum&quot;&gt;Qt는 :: TabFocus&lt;/a&gt; 위젯 탭 이동하여 키보드 포커스를 받아들이는 경우, &lt;a href=&quot;qt#FocusPolicy-enum&quot;&gt;Qt는 :: ClickFocus이&lt;/a&gt; 위젯을 클릭하여 초점을 받아들이는 경우, &lt;a href=&quot;qt#FocusPolicy-enum&quot;&gt;Qt는 :: StrongFocus는&lt;/a&gt; 그것을 모두 받아들이고, 경우 &lt;a href=&quot;qt#FocusPolicy-enum&quot;&gt;Qt는 :: NoFocus을&lt;/a&gt; (기본값)은하지 않는 경우 초점을 전혀받지 마십시오.</target>
        </trans-unit>
        <trans-unit id="beb1624447390a4c9b111817cdd6ee5ff3c4bf36" translate="yes" xml:space="preserve">
          <source>The polygon contains the four vertices of the rectangle in clockwise order starting and ending with the top-left vertex.</source>
          <target state="translated">다각형에는 왼쪽 위 꼭지점으로 시작하고 끝나는 시계 방향으로 사각형의 4 개의 꼭지점이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="44ff01dc99c6b94f01b6abb896a224dcce18ad90" translate="yes" xml:space="preserve">
          <source>The polygon is a convex polygon and can be drawn using specialized algorithms where available.</source>
          <target state="translated">다각형은 볼록한 다각형이며 가능한 경우 특수 알고리즘을 사용하여 그릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d75078c15625bdca6937ee04f8b41512ae9a525b" translate="yes" xml:space="preserve">
          <source>The polygon is considered invalid if its path holds less than three coordinates.</source>
          <target state="translated">경로에 좌표가 3 개 미만인 다각형은 유효하지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="590ccfddd573a89cb276623ef2b83a2b72cbfc73" translate="yes" xml:space="preserve">
          <source>The polygon is created by first converting all subpaths to polygons, then using a rewinding technique to make sure that overlapping subpaths can be filled using the correct fill rule.</source>
          <target state="translated">다각형은 먼저 모든 하위 경로를 다각형으로 변환 한 다음 되감기 기술을 사용하여 올바른 채우기 규칙을 사용하여 겹치는 하위 경로를 채울 수 있도록 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="8a4547a6f77bac2ae5ec1f901bd9e10bbe965e9c" translate="yes" xml:space="preserve">
          <source>The polygon is defined by an ordered list of QGeoCoordinates representing its perimeter.</source>
          <target state="translated">다각형은 경계를 나타내는 QGeoCoordinates의 정렬 된 목록으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="46220702ed829a6110de000fa76d7b50f19eb56f" translate="yes" xml:space="preserve">
          <source>The polygon is specified as an array of alternating</source>
          <target state="translated">다각형은 교번 배열로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="3aa6cb814cd9fa2ba623bfb4fb2e6fcfbbfc7a46" translate="yes" xml:space="preserve">
          <source>The polygon should be drawn using OddEven fill rule.</source>
          <target state="translated">다각형은 홀수 채우기 규칙을 사용하여 그려야합니다.</target>
        </trans-unit>
        <trans-unit id="495106cc67f680c0c720af78ce0c406f83545a5c" translate="yes" xml:space="preserve">
          <source>The polygon should be drawn using Winding fill rule.</source>
          <target state="translated">권선 채우기 규칙을 사용하여 다각형을 그려야합니다.</target>
        </trans-unit>
        <trans-unit id="106922973fd6cf6510123587cd5d9e2a65d6c101" translate="yes" xml:space="preserve">
          <source>The popup can be opened or closed manually, if necessary:</source>
          <target state="translated">필요한 경우 팝업을 수동으로 열거 나 닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b80ca9834568fc796ea7a48bdcec18ce971b4500" translate="yes" xml:space="preserve">
          <source>The popup mode is enabled by the &lt;a href=&quot;qml-qtquick-virtualkeyboard-styles-keyboardstyle#languagePopupListEnabled-prop&quot;&gt;KeyboardStyle::languagePopupListEnabled&lt;/a&gt; property. If enabled, a key press will open a popup list with available languages. Otherwise it will cycle to the next available input language.</source>
          <target state="translated">팝업 모드는 &lt;a href=&quot;qml-qtquick-virtualkeyboard-styles-keyboardstyle#languagePopupListEnabled-prop&quot;&gt;KeyboardStyle :: languagePopupListEnabled&lt;/a&gt; 속성으로 활성화됩니다 . 활성화 된 경우 키를 누르면 사용 가능한 언어가 포함 된 팝업 목록이 열립니다. 그렇지 않으면 사용 가능한 다음 입력 언어로 순환합니다.</target>
        </trans-unit>
        <trans-unit id="018a65feabbe3180242b5002a2c403df41576647" translate="yes" xml:space="preserve">
          <source>The popup will close when the escape key is pressed while the popup has active focus.</source>
          <target state="translated">팝업에 포커스가있는 동안 Esc 키를 누르면 팝업이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="c553e5e6d8226b26593a7b6e004d6145da5a71f8" translate="yes" xml:space="preserve">
          <source>The popup will close when the mouse is pressed outside of it.</source>
          <target state="translated">마우스를 마우스 밖으로 누르면 팝업이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="14dcb1ebb961c59750c2a927305898b3ba03a504" translate="yes" xml:space="preserve">
          <source>The popup will close when the mouse is pressed outside of its parent.</source>
          <target state="translated">마우스를 부모 외부에서 누르면 팝업이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="05ae2d20ee8337367d09eca1de2bde9a8427859f" translate="yes" xml:space="preserve">
          <source>The popup will close when the mouse is released outside of it.</source>
          <target state="translated">마우스를 마우스 밖으로 놓으면 팝업이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="d2334cb91649f6d32c9a158a84b3eb7078bca249" translate="yes" xml:space="preserve">
          <source>The popup will close when the mouse is released outside of its parent.</source>
          <target state="translated">마우스가 부모 외부에서 해제되면 팝업이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="317a8a44b7f9649d5b46178d882cdb13b803ecbb" translate="yes" xml:space="preserve">
          <source>The popup will only close when manually instructed to do so.</source>
          <target state="translated">팝업은 수동으로 지시 한 경우에만 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="df4860791a5c0f85a236b38887965263d2130784" translate="yes" xml:space="preserve">
          <source>The port and address of the connected peer is fetched by calling &lt;a href=&quot;qabstractsocket#peerPort&quot;&gt;peerPort&lt;/a&gt;() and &lt;a href=&quot;qabstractsocket#peerAddress&quot;&gt;peerAddress&lt;/a&gt;(). &lt;a href=&quot;qabstractsocket#peerName&quot;&gt;peerName&lt;/a&gt;() returns the host name of the peer, as passed to &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;connectToHost&lt;/a&gt;(). &lt;a href=&quot;qabstractsocket#localPort&quot;&gt;localPort&lt;/a&gt;() and &lt;a href=&quot;qabstractsocket#localAddress&quot;&gt;localAddress&lt;/a&gt;() return the port and address of the local socket.</source>
          <target state="translated">&lt;a href=&quot;qabstractsocket#peerPort&quot;&gt;peerPort&lt;/a&gt; () 및 &lt;a href=&quot;qabstractsocket#peerAddress&quot;&gt;peerAddress&lt;/a&gt; () 를 호출하여 연결된 피어의 포트와 주소를 가져옵니다 . &lt;a href=&quot;qabstractsocket#peerName&quot;&gt;peerName&lt;/a&gt; ()은 &lt;a href=&quot;qabstractsocket#connectToHost&quot;&gt;connectToHost&lt;/a&gt; ()에 전달 된 피어의 호스트 이름을 반환합니다 . &lt;a href=&quot;qabstractsocket#localPort&quot;&gt;localPort&lt;/a&gt; () 및 &lt;a href=&quot;qabstractsocket#localAddress&quot;&gt;localAddress&lt;/a&gt; ()는 로컬 소켓의 포트와 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3462b90e948688f80bd3bff16cc31ad3f03e050e" translate="yes" xml:space="preserve">
          <source>The port number</source>
          <target state="translated">포트 번호</target>
        </trans-unit>
        <trans-unit id="3006510e4617c5c78a768a936b22845057978af6" translate="yes" xml:space="preserve">
          <source>The port this server is listening on. The value must be in the range 0-65535.</source>
          <target state="translated">이 서버가 수신하는 포트입니다. 값은 0-65535 범위에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="dade22179ed59dcfbad33f06553c3e366962e9c8" translate="yes" xml:space="preserve">
          <source>The position</source>
          <target state="translated">위치</target>
        </trans-unit>
        <trans-unit id="af2a4116e881634d0c3e5fc998823a9726045845" translate="yes" xml:space="preserve">
          <source>The position and color properties describe the color used at a given position in a gradient, as represented by a gradient stop.</source>
          <target state="translated">위치 및 색상 속성은 그라디언트 정지 점으로 표시되는 그라디언트의 지정된 위치에서 사용되는 색상을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e062064975027c5d27d749f71045b5f02545b015" translate="yes" xml:space="preserve">
          <source>The position and height of a custom &lt;a href=&quot;qml-qtquick-textedit#cursorDelegate-prop&quot;&gt;cursorDelegate&lt;/a&gt; are updated to follow the cursorRectangle automatically when it changes. The width of the delegate is unaffected by changes in the cursor rectangle.</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;qml-qtquick-textedit#cursorDelegate-prop&quot;&gt;cursorDelegate&lt;/a&gt; 의 위치와 높이는 변경 될 때 cursorRectangle을 자동으로 따르도록 업데이트됩니다. 델리게이트의 너비는 커서 사각형의 변경에 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca1c2afa8e4a6f1076af0760364110fe8aece9ee" translate="yes" xml:space="preserve">
          <source>The position and height of a custom &lt;a href=&quot;qml-qtquick-textinput#cursorDelegate-prop&quot;&gt;cursorDelegate&lt;/a&gt; are updated to follow the cursorRectangle automatically when it changes. The width of the delegate is unaffected by changes in the cursor rectangle.</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;qml-qtquick-textinput#cursorDelegate-prop&quot;&gt;cursorDelegate&lt;/a&gt; 의 위치와 높이는 변경 될 때 cursorRectangle을 자동으로 따르도록 업데이트됩니다. 델리게이트의 너비는 커서 사각형의 변경에 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="238f948fbd9ed045475f17f0bd117aedd58453a1" translate="yes" xml:space="preserve">
          <source>The position can be one of the following:</source>
          <target state="translated">위치는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7ad91e571b42f49d52d8272c34c27e43e8e5824" translate="yes" xml:space="preserve">
          <source>The position given by</source>
          <target state="translated">에 의해 주어진 위치</target>
        </trans-unit>
        <trans-unit id="1a08b7ffeeebc7520f63461845623fd8f8da7fbb" translate="yes" xml:space="preserve">
          <source>The position in the file could not be changed.</source>
          <target state="translated">파일의 위치를 ​​변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a6a381934e6ace359e19cac5f5cd6eb624414bf2" translate="yes" xml:space="preserve">
          <source>The position is expressed as a fraction of the control's angle range (the range within which the handle can be moved) in the range &lt;code&gt;0.0 - 1.0&lt;/code&gt;.</source>
          <target state="translated">위치는 제어 범위의 각도 범위 (핸들이 이동할 수있는 범위 내)의 분수로 표현된다 &lt;code&gt;0.0 - 1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e09737e0d586df6b7fbcf57aa37b8b7de50a74c0" translate="yes" xml:space="preserve">
          <source>The position is expressed as a fraction of the control's size, in the range &lt;code&gt;0.0 - 1.0&lt;/code&gt;. For visualizing a slider, the right-to-left aware &lt;a href=&quot;qml-qtquick-controls2-rangeslider#first.visualPosition-prop&quot;&gt;visualPosition&lt;/a&gt; should be used instead.</source>
          <target state="translated">위치는 범위에서 컨트롤의 크기의 분수로 표현된다 &lt;code&gt;0.0 - 1.0&lt;/code&gt; . 슬라이더를 시각화하려면 오른쪽에서 왼쪽으로 인식하는 &lt;a href=&quot;qml-qtquick-controls2-rangeslider#first.visualPosition-prop&quot;&gt;visualPosition&lt;/a&gt; 을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e0d6a59487ea53c8d16aef5c0ff58430469b8bff" translate="yes" xml:space="preserve">
          <source>The position is expressed as a fraction of the control's size, in the range &lt;code&gt;0.0 - 1.0&lt;/code&gt;. For visualizing a slider, the right-to-left aware &lt;a href=&quot;qml-qtquick-controls2-rangeslider#second.visualPosition-prop&quot;&gt;visualPosition&lt;/a&gt; should be used instead.</source>
          <target state="translated">위치는 범위에서 컨트롤의 크기의 분수로 표현된다 &lt;code&gt;0.0 - 1.0&lt;/code&gt; . 슬라이더를 시각화하려면 오른쪽에서 왼쪽으로 인식하는 &lt;a href=&quot;qml-qtquick-controls2-rangeslider#second.visualPosition-prop&quot;&gt;visualPosition&lt;/a&gt; 을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="181eeca3591fc1df4f9f453565c863b34a1f0465" translate="yes" xml:space="preserve">
          <source>The position is expressed as a fraction of the control's size, in the range &lt;code&gt;0.0 - 1.0&lt;/code&gt;. For visualizing a slider, the right-to-left aware &lt;a href=&quot;qml-qtquick-controls2-slider#visualPosition-prop&quot;&gt;visualPosition&lt;/a&gt; should be used instead.</source>
          <target state="translated">위치는 범위에서 컨트롤의 크기의 분수로 표현된다 &lt;code&gt;0.0 - 1.0&lt;/code&gt; . 슬라이더를 시각화하려면 오른쪽에서 왼쪽으로 인식하는 &lt;a href=&quot;qml-qtquick-controls2-slider#visualPosition-prop&quot;&gt;visualPosition&lt;/a&gt; 을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7102816be614f47fa89302e7a2f9dd2d7aad8e6b" translate="yes" xml:space="preserve">
          <source>The position is expressed as a fraction of the control's size, in the range &lt;code&gt;0.0 - 1.0&lt;/code&gt;. When the control is &lt;a href=&quot;qml-qtquick-controls2-control#mirrored-prop&quot;&gt;mirrored&lt;/a&gt;, the value is equal to &lt;code&gt;1.0 - position&lt;/code&gt;. This makes the value suitable for visualizing the slider, taking right-to-left support into account.</source>
          <target state="translated">위치는 범위에서 컨트롤의 크기의 분수로 표현된다 &lt;code&gt;0.0 - 1.0&lt;/code&gt; . 컨트롤이 &lt;a href=&quot;qml-qtquick-controls2-control#mirrored-prop&quot;&gt;미러링&lt;/a&gt; 되면 값은 &lt;code&gt;1.0 - position&lt;/code&gt; . 이 값은 오른쪽에서 왼쪽으로 지원되는 것을 고려하여 슬라이더를 시각화하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="2291db8cc87da0bfdc356e499c01e141bebf50a2" translate="yes" xml:space="preserve">
          <source>The position is expressed as a fraction of the indicator's size, in the range &lt;code&gt;0.0&lt;/code&gt; - &lt;code&gt;1.0&lt;/code&gt;. The position can be used for example to determine whether the thumb has been dragged past the halfway point. For visualizing a thumb indicator, the right-to-left aware &lt;a href=&quot;qml-qtquick-controls2-switch#visualPosition-prop&quot;&gt;visualPosition&lt;/a&gt; should be used instead.</source>
          <target state="translated">위치는 범위에서는, 표시 사이즈의 분수로 표현된다 &lt;code&gt;0.0&lt;/code&gt; - &lt;code&gt;1.0&lt;/code&gt; . 예를 들어 엄지 손가락이 중간 지점을 지나서 드래그되었는지 여부를 판별하는 데 위치를 사용할 수 있습니다. 엄지 표시기를 시각화하려면 오른쪽에서 왼쪽으로 인식하는 &lt;a href=&quot;qml-qtquick-controls2-switch#visualPosition-prop&quot;&gt;visualPosition&lt;/a&gt; 을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="51bbe856f32634f2e29e23ce596dc71cac81a4e8" translate="yes" xml:space="preserve">
          <source>The position is expressed as a fraction of the indicator's size, in the range &lt;code&gt;0.0&lt;/code&gt; - &lt;code&gt;1.0&lt;/code&gt;. The position can be used for example to determine whether the thumb has been dragged past the halfway point. For visualizing a thumb indicator, the right-to-left aware &lt;a href=&quot;qml-qtquick-controls2-switchdelegate#visualPosition-prop&quot;&gt;visualPosition&lt;/a&gt; should be used instead.</source>
          <target state="translated">위치는 범위에서는, 표시 사이즈의 분수로 표현된다 &lt;code&gt;0.0&lt;/code&gt; - &lt;code&gt;1.0&lt;/code&gt; . 예를 들어 엄지 손가락이 중간 지점을 지나서 드래그되었는지 여부를 판별하는 데 위치를 사용할 수 있습니다. 엄지 표시기를 시각화하려면 오른쪽에서 왼쪽으로 인식하는 &lt;a href=&quot;qml-qtquick-controls2-switchdelegate#visualPosition-prop&quot;&gt;visualPosition&lt;/a&gt; 을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7726e69bc660c9e29bf2e1aa312445753110551a" translate="yes" xml:space="preserve">
          <source>The position is expressed as a fraction of the indicator's size, in the range &lt;code&gt;0.0&lt;/code&gt; - &lt;code&gt;1.0&lt;/code&gt;. When the control is &lt;a href=&quot;qml-qtquick-controls2-control#mirrored-prop&quot;&gt;mirrored&lt;/a&gt;, the value is equal to &lt;code&gt;1.0 - position&lt;/code&gt;. This makes the value suitable for visualizing the thumb indicator taking right-to-left support into account. In order to for example determine whether the thumb has been dragged past the halfway point, the logical &lt;a href=&quot;qml-qtquick-controls2-switch#position-prop&quot;&gt;position&lt;/a&gt; should be used instead.</source>
          <target state="translated">위치는 범위에서는, 표시 사이즈의 분수로 표현된다 &lt;code&gt;0.0&lt;/code&gt; - &lt;code&gt;1.0&lt;/code&gt; . 컨트롤이 &lt;a href=&quot;qml-qtquick-controls2-control#mirrored-prop&quot;&gt;미러링&lt;/a&gt; 되면 값은 &lt;code&gt;1.0 - position&lt;/code&gt; . 이 값은 오른쪽에서 왼쪽으로 지원되는 것을 고려하여 엄지 표시기를 시각화하는 데 적합합니다. 예를 들어 엄지 손가락이 중간 지점을 지나서 끌 렸는지 확인하려면 논리적 &lt;a href=&quot;qml-qtquick-controls2-switch#position-prop&quot;&gt;위치&lt;/a&gt; 를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e53f2a20d433a34d72e02dac2f31c35af50d1381" translate="yes" xml:space="preserve">
          <source>The position is expressed as a fraction of the indicator's size, in the range &lt;code&gt;0.0&lt;/code&gt; - &lt;code&gt;1.0&lt;/code&gt;. When the control is &lt;a href=&quot;qml-qtquick-controls2-control#mirrored-prop&quot;&gt;mirrored&lt;/a&gt;, the value is equal to &lt;code&gt;1.0 - position&lt;/code&gt;. This makes the value suitable for visualizing the thumb indicator taking right-to-left support into account. In order to for example determine whether the thumb has been dragged past the halfway point, the logical &lt;a href=&quot;qml-qtquick-controls2-switchdelegate#position-prop&quot;&gt;position&lt;/a&gt; should be used instead.</source>
          <target state="translated">위치는 범위에서는, 표시 사이즈의 분수로 표현된다 &lt;code&gt;0.0&lt;/code&gt; - &lt;code&gt;1.0&lt;/code&gt; . 컨트롤이 &lt;a href=&quot;qml-qtquick-controls2-control#mirrored-prop&quot;&gt;미러링&lt;/a&gt; 되면 값은 &lt;code&gt;1.0 - position&lt;/code&gt; . 이 값은 오른쪽에서 왼쪽으로 지원되는 것을 고려하여 엄지 표시기를 시각화하는 데 적합합니다. 예를 들어 엄지 손가락이 중간 지점을 지나서 끌 렸는지 확인하려면 논리적 &lt;a href=&quot;qml-qtquick-controls2-switchdelegate#position-prop&quot;&gt;위치&lt;/a&gt; 를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8798ba2e37b5dfd14bbed869ecab9a2c2f3ff8d5" translate="yes" xml:space="preserve">
          <source>The position is expressed as a fraction of the value, in the range &lt;code&gt;0.0 - 1.0&lt;/code&gt;. For visualizing the progress, the right-to-left aware &lt;a href=&quot;qml-qtquick-controls2-progressbar#visualPosition-prop&quot;&gt;visualPosition&lt;/a&gt; should be used instead.</source>
          <target state="translated">위치는 범위 값의 분수로 표현된다 &lt;code&gt;0.0 - 1.0&lt;/code&gt; . 진행 상황을 시각화하려면 오른쪽에서 왼쪽으로 인식하는 &lt;a href=&quot;qml-qtquick-controls2-progressbar#visualPosition-prop&quot;&gt;visualPosition&lt;/a&gt; 을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="149123cba1f9ba7ab25ca2c89152e3d844960ca5" translate="yes" xml:space="preserve">
          <source>The position is expressed as a fraction of the value, in the range &lt;code&gt;0.0 - 1.0&lt;/code&gt;. When the control is &lt;a href=&quot;qml-qtquick-controls2-control#mirrored-prop&quot;&gt;mirrored&lt;/a&gt;, &lt;code&gt;visuaPosition&lt;/code&gt; is equal to &lt;code&gt;1.0 - position&lt;/code&gt;. This makes &lt;code&gt;visualPosition&lt;/code&gt; suitable for visualizing the progress, taking right-to-left support into account.</source>
          <target state="translated">위치는 범위 값의 분수로 표현된다 &lt;code&gt;0.0 - 1.0&lt;/code&gt; . 컨트롤이 &lt;a href=&quot;qml-qtquick-controls2-control#mirrored-prop&quot;&gt;미러링&lt;/a&gt; 되면 &lt;code&gt;visuaPosition&lt;/code&gt; 은 &lt;code&gt;1.0 - position&lt;/code&gt; . 이로 인해 &lt;code&gt;visualPosition&lt;/code&gt; 은 오른쪽에서 왼쪽으로 지원을 고려하여 진행 상황을 시각화하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="174a3845d592ffd366a062f2cd5feccff300b53d" translate="yes" xml:space="preserve">
          <source>The position is in relation to the virtualGeometry() of its screen.</source>
          <target state="translated">위치는 화면의 virtualGeometry ()와 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="659c58c7b076cdfd9d3afa151be9ef4c3f8a66ec" translate="yes" xml:space="preserve">
          <source>The position of the alpha channel is described with a separate enum. This is to make it possible to describe &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; formats like ARGB32, and also describe typical OpenGL formats like RBGA8888.</source>
          <target state="translated">알파 채널의 위치는 별도의 열거 형으로 설명됩니다. 이를 통해 ARGB32와 같은 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 형식 을 설명 하고 RBGA8888과 같은 일반적인 OpenGL 형식 을 설명 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b495b50f92e0006e74f14382b19711ba024fd99" translate="yes" xml:space="preserve">
          <source>The position of the button, as given by &lt;a href=&quot;qwidget#pos-prop&quot;&gt;QWidget::pos&lt;/a&gt;()</source>
          <target state="translated">&lt;a href=&quot;qwidget#pos-prop&quot;&gt;QWidget :: pos&lt;/a&gt; ()에 의해 주어진 버튼의 위치</target>
        </trans-unit>
        <trans-unit id="0f8b2b8b498fde9eefcbfd905a279d10588d1a77" translate="yes" xml:space="preserve">
          <source>The position of the category labels. The labels in the beginning and in the end of the axes may overlap other axes' labels when positioned on value.</source>
          <target state="translated">카테고리 레이블의 위치입니다. 축의 시작과 끝에있는 레이블이 값에있을 때 다른 축의 레이블과 겹칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1a6088f1bb180ddd40f5ca25d10cbd6456eef06" translate="yes" xml:space="preserve">
          <source>The position of the click is defined by</source>
          <target state="translated">클릭의 위치는</target>
        </trans-unit>
        <trans-unit id="2d2c6d13b7ddc44b7f3d33584fd8da187adcb12b" translate="yes" xml:space="preserve">
          <source>The position of the cursor in the &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt; 에서 커서의 위치입니다 .</target>
        </trans-unit>
        <trans-unit id="ac9f65ce5d0a5decd7528ac1b4fabd42f11565e2" translate="yes" xml:space="preserve">
          <source>The position of the cursor in the &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; 에서 커서의 위치입니다 .</target>
        </trans-unit>
        <trans-unit id="1b921a78febf8ef113f16902c3c7056dbcb97ca7" translate="yes" xml:space="preserve">
          <source>The position of the cursor in the &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; 에서 커서의 위치입니다 .</target>
        </trans-unit>
        <trans-unit id="20978a602e3baf95295bf7d226bb1cc4a370a100" translate="yes" xml:space="preserve">
          <source>The position of the data value labels:</source>
          <target state="translated">데이터 값 레이블의 위치 :</target>
        </trans-unit>
        <trans-unit id="f696a63bba90f00b6c65a84e640aefd9dc34bb01" translate="yes" xml:space="preserve">
          <source>The position of the drag event can be obtained from the &lt;a href=&quot;qml-qtquick-dragevent#x-prop&quot;&gt;x&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-dragevent#y-prop&quot;&gt;y&lt;/a&gt; properties, and the &lt;a href=&quot;qml-qtquick-dragevent#keys-prop&quot;&gt;keys&lt;/a&gt; property identifies the drag keys of the event &lt;a href=&quot;qml-qtquick-dragevent#drag.source-prop&quot;&gt;source&lt;/a&gt;.</source>
          <target state="translated">드래그 이벤트의 위치는 &lt;a href=&quot;qml-qtquick-dragevent#x-prop&quot;&gt;x&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-dragevent#y-prop&quot;&gt;y&lt;/a&gt; 속성 에서 얻을 수 있으며 &lt;a href=&quot;qml-qtquick-dragevent#keys-prop&quot;&gt;keys&lt;/a&gt; 속성은 이벤트 &lt;a href=&quot;qml-qtquick-dragevent#drag.source-prop&quot;&gt;소스&lt;/a&gt; 의 드래그 키를 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="319a7676702650bf9e81bead07f3c402de8921fd" translate="yes" xml:space="preserve">
          <source>The position of the inline object within the text layout.</source>
          <target state="translated">텍스트 레이아웃 내에서 인라인 객체의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="e2a5a3fd3d950812b38b6229a42d4736597fb0a8" translate="yes" xml:space="preserve">
          <source>The position of the item describes its origin (local coordinate (0, 0)) in parent coordinates.</source>
          <target state="translated">항목의 위치는 부모 좌표에서 원점 (로컬 좌표 (0, 0))을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d50b0db77185afbf1e2b57dc4a8c74d6d7b112eb" translate="yes" xml:space="preserve">
          <source>The position of the item describes its origin (local coordinate (0, 0)) in parent coordinates; this function returns the same as &lt;a href=&quot;qgraphicsitem#mapToParent&quot;&gt;mapToParent&lt;/a&gt;(0, 0).</source>
          <target state="translated">항목의 위치는 부모 좌표에서 원점 (로컬 좌표 (0, 0))을 나타냅니다. 이 함수는 &lt;a href=&quot;qgraphicsitem#mapToParent&quot;&gt;mapToParent&lt;/a&gt; (0, 0) 와 동일을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="e221168339e94c53c91080e3e182bd170997cab5" translate="yes" xml:space="preserve">
          <source>The position of the mouse can be found via the &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#y-prop&quot;&gt;y&lt;/a&gt; properties.</source>
          <target state="translated">마우스의 위치는 &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-item#y-prop&quot;&gt;y&lt;/a&gt; 속성을 통해 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a57c7bc5377e49e3b2c6389f00a8b3b356fe539" translate="yes" xml:space="preserve">
          <source>The position of the mouse can be found via the &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#y-prop&quot;&gt;y&lt;/a&gt; properties. The button that caused the event is available via the &lt;a href=&quot;qml-qtquick-mouseevent#button-prop&quot;&gt;button&lt;/a&gt; property.</source>
          <target state="translated">마우스의 위치는 &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-item#y-prop&quot;&gt;y&lt;/a&gt; 속성을 통해 찾을 수 있습니다 . 이벤트를 일으킨 버튼은 &lt;a href=&quot;qml-qtquick-mouseevent#button-prop&quot;&gt;button&lt;/a&gt; 속성을 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef6a46f52bb6eadf331ae41b634ebbdb8428edb7" translate="yes" xml:space="preserve">
          <source>The position of the selected bar is specified as a row and column in the data array of the series.</source>
          <target state="translated">선택한 막대의 위치는 계열의 데이터 배열에서 행과 열로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="5790eace9f276a3000568cdb5c3483312bfd7491" translate="yes" xml:space="preserve">
          <source>The position of the selection anchor. This may be less or greater than &lt;code&gt;ImCursorPosition&lt;/code&gt;, depending on which side of selection the cursor is. If there is no selection, it returns the same as &lt;code&gt;ImCursorPosition&lt;/code&gt;.</source>
          <target state="translated">선택 앵커의 위치입니다. 커서의 선택 &lt;code&gt;ImCursorPosition&lt;/code&gt; 에 따라 ImCursorPosition 보다 작거나 클 수 있습니다 . 선택이 없으면 &lt;code&gt;ImCursorPosition&lt;/code&gt; 과 동일하게 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="acca35b6b4886e411f91fd0d209cb8447754efa1" translate="yes" xml:space="preserve">
          <source>The position of the slider given as a slider value. This will be equal to the &lt;code&gt;sliderValue&lt;/code&gt; if the slider is &lt;a href=&quot;qabstractslider#tracking-prop&quot;&gt;tracking&lt;/a&gt;; if not, the slider's value will not change until the handle is released with the mouse.</source>
          <target state="translated">슬라이더 값으로 제공된 슬라이더의 위치입니다. 이것은 동일 할 것이다 &lt;code&gt;sliderValue&lt;/code&gt; 슬라이더 경우 &lt;a href=&quot;qabstractslider#tracking-prop&quot;&gt;추적&lt;/a&gt; ; 그렇지 않으면 마우스로 핸들을 놓을 때까지 슬라이더 값이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2696b19c7e1da6000149ca782a6273b9c195185f" translate="yes" xml:space="preserve">
          <source>The position of the slider handle. This is the same as &lt;code&gt;sliderValue&lt;/code&gt; if the scroll bar is &lt;a href=&quot;qabstractslider#tracking-prop&quot;&gt;QAbstractSlider::tracking&lt;/a&gt;. If not, the scroll bar does not update its value before the mouse releases the handle.</source>
          <target state="translated">슬라이더 핸들의 위치입니다. 스크롤 막대가 &lt;a href=&quot;qabstractslider#tracking-prop&quot;&gt;QAbstractSlider :: tracking 인&lt;/a&gt; 경우 이는 &lt;code&gt;sliderValue&lt;/code&gt; 값과 동일 합니다. 그렇지 않은 경우, 스크롤 막대는 마우스가 핸들을 놓기 전에 값을 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21f38d008bca496d02500019f416937dbd820dce" translate="yes" xml:space="preserve">
          <source>The position of the surface relative to the parent window geometry if the surface is not constrained. I.e. when not moved to fit inside the screen or similar.</source>
          <target state="translated">곡면이 구속되어 있지 않은 경우 부모 창 형상을 기준으로 곡면의 위치입니다. 즉, 화면 내부에 맞게 이동하지 않은 경우</target>
        </trans-unit>
        <trans-unit id="9dec3531ebebe8d8d05878d4528558be75e658ba" translate="yes" xml:space="preserve">
          <source>The position of the tabs is defined by &lt;a href=&quot;qtabwidget#tabPosition-prop&quot;&gt;tabPosition&lt;/a&gt;, their shape by &lt;a href=&quot;qtabwidget#tabShape-prop&quot;&gt;tabShape&lt;/a&gt;.</source>
          <target state="translated">탭의 위치는 &lt;a href=&quot;qtabwidget#tabPosition-prop&quot;&gt;tabPosition&lt;/a&gt; 에 의해 정의되며 탭 모양은 &lt;a href=&quot;qtabwidget#tabShape-prop&quot;&gt;tabShape에&lt;/a&gt; 의해 결정 됩니다.</target>
        </trans-unit>
        <trans-unit id="3fce1cb7f144df984f42f8fb544edc1a6d8969ac" translate="yes" xml:space="preserve">
          <source>The position of the tickmarks and labels</source>
          <target state="translated">눈금 및 레이블의 위치</target>
        </trans-unit>
        <trans-unit id="37aeccae7787b15b4130061090e758f02613aa2b" translate="yes" xml:space="preserve">
          <source>The position of the toolbar line within the toolbar area to which it belongs.</source>
          <target state="translated">해당 도구 모음 영역 내 도구 모음 선의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="0597278ab9b3084d0fb38fd6f0d342a6a748dd9c" translate="yes" xml:space="preserve">
          <source>The position of the toolbar within the toolbar line.</source>
          <target state="translated">툴바 라인 내 툴바의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="2824f8f5ca3dc4a9195ed89264e716b06a967586" translate="yes" xml:space="preserve">
          <source>The position property describes the position of this gradient stop.</source>
          <target state="translated">position 속성은이 그래디언트 정지 점의 위치를 ​​설명합니다.</target>
        </trans-unit>
        <trans-unit id="cd51c73a95e2598b0d3ea42030a1564299be02ed" translate="yes" xml:space="preserve">
          <source>The position relative to the position of the anchor on the anchor rectangle and the anchor on the surface.</source>
          <target state="translated">앵커 사각형의 앵커 위치와 표면의 앵커 위치를 기준으로 한 위치입니다.</target>
        </trans-unit>
        <trans-unit id="4610bea8d1caab97a0839263437d81dd9aef88ae" translate="yes" xml:space="preserve">
          <source>The position that &quot;Item 0&quot; is moving to</source>
          <target state="translated">&quot;항목 0&quot;이 이동하는 위치</target>
        </trans-unit>
        <trans-unit id="65448a63b6a6b6d2ae5d1bfa6e0b16f5eb387d88" translate="yes" xml:space="preserve">
          <source>The position values are taken from the first item in the item model that matches each row/column combination.</source>
          <target state="translated">위치 값은 각 행 / 열 조합과 일치하는 항목 모델의 첫 번째 항목에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0c2e80f7354e67b48605c7071c02c7a2e87a33ef" translate="yes" xml:space="preserve">
          <source>The position values are taken from the last item in the item model that matches each row/column combination.</source>
          <target state="translated">위치 값은 각 행 / 열 조합과 일치하는 항목 모델의 마지막 항목에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bf420653a4eb9e3dea211ef7ac8e400bd3893f34" translate="yes" xml:space="preserve">
          <source>The position values from all items matching each row/column combination are averaged together and the averages are used as the surface point position.</source>
          <target state="translated">각 행 / 열 조합과 일치하는 모든 항목의 위치 값이 함께 평균화되고 평균이 표면 점 위치로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="744a68421e58a45174a7059d77d3de66653cd04b" translate="yes" xml:space="preserve">
          <source>The position within the &lt;code&gt;parent&lt;/code&gt; Item</source>
          <target state="translated">&lt;code&gt;parent&lt;/code&gt; 항목 내 위치</target>
        </trans-unit>
        <trans-unit id="fffd1f4dd69c135d8a924ec76b2c99fd008cfb95" translate="yes" xml:space="preserve">
          <source>The position within the scene</source>
          <target state="translated">장면 내 위치</target>
        </trans-unit>
        <trans-unit id="9681e3a1b66d2238377cee9fde4d28ceb86c99df" translate="yes" xml:space="preserve">
          <source>The positioning and the screen Z-order of windows belonging to GUI applications started with &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; are controlled by the underlying windowing system. For Qt 5 applications, the positioning can be specified using the &lt;code&gt;-qwindowgeometry&lt;/code&gt; command line option; X11 applications generally accept a &lt;code&gt;-geometry&lt;/code&gt; command line option.</source>
          <target state="translated">&lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; 로 시작된 GUI 응용 프로그램에 속하는 창의 위치 및 화면 Z 순서 는 기본 창 시스템에 의해 제어됩니다. Qt 5 애플리케이션의 경우 &lt;code&gt;-qwindowgeometry&lt;/code&gt; 명령 행 옵션을 사용하여 위치를 지정할 수 있습니다 . X11 응용 프로그램은 일반적으로 &lt;code&gt;-geometry&lt;/code&gt; 명령 행 옵션을 승인합니다 .</target>
        </trans-unit>
        <trans-unit id="aedbe4c3eeedb559bbad3b323837adaa44ae951e" translate="yes" xml:space="preserve">
          <source>The positioning method of tick and labels.</source>
          <target state="translated">눈금 및 라벨의 위치 결정 방법.</target>
        </trans-unit>
        <trans-unit id="25b97338975160e05a4636cf0dd009857d823ab4" translate="yes" xml:space="preserve">
          <source>The positioning of the &lt;a href=&quot;qml-qtlocation-mapquickitem&quot;&gt;MapQuickItem&lt;/a&gt; on the Map is controlled by two properties: &lt;a href=&quot;qml-qtlocation-mapquickitem#coordinate-prop&quot;&gt;coordinate&lt;/a&gt; and &lt;a href=&quot;qml-qtlocation-mapquickitem#anchorPoint-prop&quot;&gt;anchorPoint&lt;/a&gt;. If only &lt;a href=&quot;qml-qtlocation-mapquickitem#coordinate-prop&quot;&gt;coordinate&lt;/a&gt; is set, it specifies a longitude/latitude coordinate for the item to be placed at. The set coordinate will line up with the top-left corner of the contained item when shown on the screen.</source>
          <target state="translated">지도 에서 &lt;a href=&quot;qml-qtlocation-mapquickitem&quot;&gt;MapQuickItem&lt;/a&gt; 의 위치는 두 가지 속성 인 &lt;a href=&quot;qml-qtlocation-mapquickitem#coordinate-prop&quot;&gt;coordinate&lt;/a&gt; 및 &lt;a href=&quot;qml-qtlocation-mapquickitem#anchorPoint-prop&quot;&gt;anchorPoint에&lt;/a&gt; 의해 제어됩니다 . &lt;a href=&quot;qml-qtlocation-mapquickitem#coordinate-prop&quot;&gt;좌표&lt;/a&gt; 만 설정하면 항목을 배치 할 경도 / 위도 좌표를 지정합니다. 설정된 좌표는 화면에 표시 될 때 포함 된 항목의 왼쪽 상단에 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="7ae30af3e2bccc30646825b2236b73d4cb969c12" translate="yes" xml:space="preserve">
          <source>The positioning of the content within the &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; widget area can be tuned with &lt;a href=&quot;qlabel#alignment-prop&quot;&gt;setAlignment&lt;/a&gt;() and &lt;a href=&quot;qlabel#indent-prop&quot;&gt;setIndent&lt;/a&gt;(). Text content can also wrap lines along word boundaries with &lt;a href=&quot;qlabel#wordWrap-prop&quot;&gt;setWordWrap&lt;/a&gt;(). For example, this code sets up a sunken panel with a two-line text in the bottom right corner (both lines being flush with the right side of the label):</source>
          <target state="translated">&lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; 위젯 영역 내에서 컨텐츠의 위치는 &lt;a href=&quot;qlabel#alignment-prop&quot;&gt;setAlignment&lt;/a&gt; () 및 &lt;a href=&quot;qlabel#indent-prop&quot;&gt;setIndent&lt;/a&gt; () 로 조정할 수 있습니다 . 텍스트 내용은 &lt;a href=&quot;qlabel#wordWrap-prop&quot;&gt;setWordWrap&lt;/a&gt; ()을 사용 하여 단어 경계를 따라 줄을 감쌀 수도 있습니다 . 예를 들어,이 코드는 오른쪽 아래 모서리에 두 줄로 된 텍스트가있는 가려진 패널을 설정합니다 (두 줄은 레이블의 오른쪽과 같은 높이입니다).</target>
        </trans-unit>
        <trans-unit id="a909689d14abfcb7b1d04aa80bb12ce179815e09" translate="yes" xml:space="preserve">
          <source>The positions of the line's start and end points can be retrieved using the &lt;a href=&quot;qline#p1&quot;&gt;p1&lt;/a&gt;(), &lt;a href=&quot;qline#x1&quot;&gt;x1&lt;/a&gt;(), &lt;a href=&quot;qline#y1&quot;&gt;y1&lt;/a&gt;(), &lt;a href=&quot;qline#p2&quot;&gt;p2&lt;/a&gt;(), &lt;a href=&quot;qline#x2&quot;&gt;x2&lt;/a&gt;(), and &lt;a href=&quot;qline#y2&quot;&gt;y2&lt;/a&gt;() functions. The &lt;a href=&quot;qline#dx&quot;&gt;dx&lt;/a&gt;() and &lt;a href=&quot;qline#dy&quot;&gt;dy&lt;/a&gt;() functions return the horizontal and vertical components of the line. Use &lt;a href=&quot;qline#isNull&quot;&gt;isNull&lt;/a&gt;() to determine whether the &lt;a href=&quot;qline&quot;&gt;QLine&lt;/a&gt; represents a valid line or a null line.</source>
          <target state="translated">선의 시작점과 끝점의 위치는 &lt;a href=&quot;qline#p1&quot;&gt;p1&lt;/a&gt; (), &lt;a href=&quot;qline#x1&quot;&gt;x1&lt;/a&gt; (), &lt;a href=&quot;qline#y1&quot;&gt;y1&lt;/a&gt; (), &lt;a href=&quot;qline#p2&quot;&gt;p2&lt;/a&gt; (), &lt;a href=&quot;qline#x2&quot;&gt;x2&lt;/a&gt; () 및 &lt;a href=&quot;qline#y2&quot;&gt;y2&lt;/a&gt; () 함수를 사용하여 검색 할 수 있습니다 . &lt;a href=&quot;qline#dx&quot;&gt;DX&lt;/a&gt; () 및 &lt;a href=&quot;qline#dy&quot;&gt;(DY)는&lt;/a&gt; () 함수는 라인의 수평 &amp;middot; 수직 성분을 반환한다. 사용 &lt;a href=&quot;qline#isNull&quot;&gt;isNull에은&lt;/a&gt; ()를 여부를 확인하는 &lt;a href=&quot;qline&quot;&gt;QLine가&lt;/a&gt; 유효한 행 또는 널 라인을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f15445a3df28a6a686127b79528902897c100897" translate="yes" xml:space="preserve">
          <source>The positions of the line's start and end points can be retrieved using the &lt;a href=&quot;qlinef#p1&quot;&gt;p1&lt;/a&gt;(), &lt;a href=&quot;qlinef#x1&quot;&gt;x1&lt;/a&gt;(), &lt;a href=&quot;qlinef#y1&quot;&gt;y1&lt;/a&gt;(), &lt;a href=&quot;qlinef#p2&quot;&gt;p2&lt;/a&gt;(), &lt;a href=&quot;qlinef#x2&quot;&gt;x2&lt;/a&gt;(), and &lt;a href=&quot;qlinef#y2&quot;&gt;y2&lt;/a&gt;() functions. The &lt;a href=&quot;qlinef#dx&quot;&gt;dx&lt;/a&gt;() and &lt;a href=&quot;qlinef#dy&quot;&gt;dy&lt;/a&gt;() functions return the horizontal and vertical components of the line, respectively.</source>
          <target state="translated">선의 시작점과 끝점의 위치는 &lt;a href=&quot;qlinef#p1&quot;&gt;p1&lt;/a&gt; (), &lt;a href=&quot;qlinef#x1&quot;&gt;x1&lt;/a&gt; (), &lt;a href=&quot;qlinef#y1&quot;&gt;y1&lt;/a&gt; (), &lt;a href=&quot;qlinef#p2&quot;&gt;p2&lt;/a&gt; (), &lt;a href=&quot;qlinef#x2&quot;&gt;x2&lt;/a&gt; () 및 &lt;a href=&quot;qlinef#y2&quot;&gt;y2&lt;/a&gt; () 함수를 사용하여 검색 할 수 있습니다 . &lt;a href=&quot;qlinef#dx&quot;&gt;DX&lt;/a&gt; () 및 &lt;a href=&quot;qlinef#dy&quot;&gt;(DY)는&lt;/a&gt; () 함수는 각각 행의 수평 및 수직 성분을 반환한다.</target>
        </trans-unit>
        <trans-unit id="3d3607de2a3f65e5a4b3769de732cdf2795ad8ff" translate="yes" xml:space="preserve">
          <source>The possibility to register widgets without having to subclass QItemEditorCreatorBase</source>
          <target state="translated">QItemEditorCreatorBase를 서브 클래스 화하지 않고도 위젯을 등록 할 수있는 가능성</target>
        </trans-unit>
        <trans-unit id="8deb5e2ba019883c107b7366db208b92fab8c8c1" translate="yes" xml:space="preserve">
          <source>The possible &lt;code&gt;int&lt;/code&gt; values range from around -2000000000 to around 2000000000, although most types will only accept a reduced range (which they mention in their documentation).</source>
          <target state="translated">가능한 &lt;code&gt;int&lt;/code&gt; 값의 범위는 약 -2000000000에서 약 2000000000 사이이지만 대부분의 유형은 축소 된 범위 만 허용합니다 (문서에서 언급).</target>
        </trans-unit>
        <trans-unit id="5f334a920c21bd4ffde33be56bbd0d4b09ef6aa1" translate="yes" xml:space="preserve">
          <source>The possible alignment values are:</source>
          <target state="translated">가능한 정렬 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c805c21a76bee164d72faee5bc40e6842ee5745" translate="yes" xml:space="preserve">
          <source>The possible line join styles are:</source>
          <target state="translated">가능한 라인 결합 스타일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ae2f0d9fa420b47e9298c4ff41d8ed5712a33ba3" translate="yes" xml:space="preserve">
          <source>The possible message types:</source>
          <target state="translated">가능한 메시지 유형 :</target>
        </trans-unit>
        <trans-unit id="d42943ad7ba11323fd003c54229604322b66e860" translate="yes" xml:space="preserve">
          <source>The possible modes are:</source>
          <target state="translated">가능한 모드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56bdf3d046669785e2b8881e141c02e191da694e" translate="yes" xml:space="preserve">
          <source>The possible return values from &lt;a href=&quot;qdbusconnectioninterface#registerService&quot;&gt;registerService&lt;/a&gt;():</source>
          <target state="translated">&lt;a href=&quot;qdbusconnectioninterface#registerService&quot;&gt;registerService&lt;/a&gt; () 에서 가능한 반환 값 :</target>
        </trans-unit>
        <trans-unit id="5db1cb2f96f8e457c216a520b4f81146af2fe62f" translate="yes" xml:space="preserve">
          <source>The possible values are:</source>
          <target state="translated">가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="58390083d949f525d00f34f2aaec04d83deec694" translate="yes" xml:space="preserve">
          <source>The possible values can be either &lt;code&gt;UpDownArrows&lt;/code&gt; or &lt;code&gt;PlusMinus&lt;/code&gt;. The default is &lt;code&gt;UpDownArrows&lt;/code&gt;.</source>
          <target state="translated">가능한 값은 &lt;code&gt;UpDownArrows&lt;/code&gt; 또는 &lt;code&gt;PlusMinus&lt;/code&gt; 일 수 있습니다 . 기본값은 &lt;code&gt;UpDownArrows&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e553f28f0317d0f2e65279d80c066c891b93c20b" translate="yes" xml:space="preserve">
          <source>The possible values for the text case are:</source>
          <target state="translated">텍스트 케이스에 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c88909a77945c5a19902a1a3f4047415a7c9e64" translate="yes" xml:space="preserve">
          <source>The possible values for this property are:</source>
          <target state="translated">이 특성의 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c074e397955eae48d87d4f21527e035baf28ffc9" translate="yes" xml:space="preserve">
          <source>The postfix ++ operator (&lt;code&gt;i++&lt;/code&gt;) advances the iterator to the next item in the container and returns the iterator's prior value.</source>
          <target state="translated">접미사 ++ 연산자 ( &lt;code&gt;i++&lt;/code&gt; )는 반복자를 컨테이너의 다음 항목으로 진행시키고 반복자의 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d50ae5e6ccc4b2c86bf4dd0c97707e6dc8d0c34d" translate="yes" xml:space="preserve">
          <source>The postfix ++ operator (&lt;code&gt;i++&lt;/code&gt;) advances the iterator to the next item in the hash and returns an iterator to the previous item.</source>
          <target state="translated">postfix ++ 연산자 ( &lt;code&gt;i++&lt;/code&gt; )는 반복자를 해시의 다음 항목으로 진행시키고 반복자를 이전 항목으로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="99262e43551afaac1824e0ae8542b0fbfc773f36" translate="yes" xml:space="preserve">
          <source>The postfix ++ operator (&lt;code&gt;i++&lt;/code&gt;) advances the iterator to the next item in the hash and returns an iterator to the previously current item.</source>
          <target state="translated">postfix ++ 연산자 ( &lt;code&gt;i++&lt;/code&gt; )는 반복자를 해시의 다음 항목으로 진행시키고 이전 항목으로 반복자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1e2aae0caa451c31f04ca5b67afb80d0e693928b" translate="yes" xml:space="preserve">
          <source>The postfix ++ operator (&lt;code&gt;i++&lt;/code&gt;) advances the iterator to the next item in the map and returns an iterator to the previously current item.</source>
          <target state="translated">postfix ++ 연산자 ( &lt;code&gt;i++&lt;/code&gt; )는 반복자를 맵의 다음 항목으로 진행시키고 이전 항목으로 반복자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9e7989a5169022e18ba856d0ae2b0897fdcedcac" translate="yes" xml:space="preserve">
          <source>The postfix ++ operator (&lt;code&gt;i++&lt;/code&gt;) advances the iterator to the next item in the text block and returns an iterator to the old current item.</source>
          <target state="translated">접미사 ++ 연산자 ( &lt;code&gt;i++&lt;/code&gt; )는 반복자를 텍스트 블록의 다음 항목으로 진행시키고 반복자를 이전 현재 항목으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94da34da04b695cfd78ea68de10e6213eb3da51b" translate="yes" xml:space="preserve">
          <source>The postfix ++ operator (&lt;code&gt;i++&lt;/code&gt;) advances the iterator to the next item in the text frame, and returns an iterator to the old item.</source>
          <target state="translated">접미사 ++ 연산자 ( &lt;code&gt;i++&lt;/code&gt; )는 반복자를 텍스트 프레임의 다음 항목으로 진행시키고 반복자를 이전 항목으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="15c59accd4473e2ffaf7c76e136b950b968002fb" translate="yes" xml:space="preserve">
          <source>The postfix ++ operator (&lt;code&gt;it++&lt;/code&gt;) advances the iterator to the next item in the container and returns an iterator to the previously current item.</source>
          <target state="translated">postfix ++ 연산자 ( &lt;code&gt;it++&lt;/code&gt; )는 반복자를 컨테이너의 다음 항목으로 진행시키고 이전 항목으로 반복자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7d1ff83435ff39fa61396e7e8fda54fca877cb0b" translate="yes" xml:space="preserve">
          <source>The postfix ++ operator (&lt;code&gt;it++&lt;/code&gt;) advances the iterator to the next item in the list and returns an iterator to the previously current item.</source>
          <target state="translated">postfix ++ 연산자 ( &lt;code&gt;it++&lt;/code&gt; )는 반복자를 목록의 다음 항목으로 진행시키고 이전 항목으로 반복자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b43de47d8355448fa354c4085e69df4d4e2b3e5e" translate="yes" xml:space="preserve">
          <source>The postfix ++ operator (&lt;code&gt;it++&lt;/code&gt;) advances the iterator to the next item in the set and returns an iterator to the previously current item.</source>
          <target state="translated">접미사 ++ 연산자 ( &lt;code&gt;it++&lt;/code&gt; )는 반복자를 세트의 다음 항목으로 진행시키고 이전의 현재 항목으로 반복자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dccedce43d12f64c9fe681774ce91f099ec6bc5b" translate="yes" xml:space="preserve">
          <source>The postfix ++ operator (&lt;code&gt;it++&lt;/code&gt;) advances the iterator to the next result in the future and returns an iterator to the previously current result.</source>
          <target state="translated">postfix ++ 연산자 ( &lt;code&gt;it++&lt;/code&gt; )는 반복자를 앞으로 다음 결과로 진행시키고 이전의 현재 결과로 반복자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="205b3c846fac764abef6ec829baf2d9b398e3be1" translate="yes" xml:space="preserve">
          <source>The postfix ++ operator (it++) advances the iterator to the next matching item and returns an iterator to the previously current item.</source>
          <target state="translated">접미사 ++ 연산자 (it ++)는 반복자를 다음 일치하는 항목으로 진행시키고 반복자를 이전의 현재 항목으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6fdab47586bfc4a08e8fffee5b60a1f87bb1c4ff" translate="yes" xml:space="preserve">
          <source>The postfix ++ operator, &lt;code&gt;i++&lt;/code&gt;, advances the iterator to the next item in the map and returns an iterator to the previously current item.</source>
          <target state="translated">접미사 ++ 연산자 &lt;code&gt;i++&lt;/code&gt; 는 반복자를 맵의 다음 항목으로 진행시키고 이전 항목으로 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ec2bad27a79a85a53e3b6ffb4393546f9c25b0ed" translate="yes" xml:space="preserve">
          <source>The postfix ++ operator, &lt;code&gt;i++&lt;/code&gt;, advances the iterator to the next item in the object and returns an iterator to the previously current item.</source>
          <target state="translated">접미사 ++ 연산자 인 &lt;code&gt;i++&lt;/code&gt; 는 반복자를 객체의 다음 항목으로 진행시키고 이전 항목으로 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd3945c77a8b78c7020a8483f7f36e25133e1825" translate="yes" xml:space="preserve">
          <source>The postfix ++ operator, &lt;code&gt;it++&lt;/code&gt;, advances the iterator to the next item in the array and returns an iterator to the previously current item.</source>
          <target state="translated">접미사 ++ 연산자 &lt;code&gt;it++&lt;/code&gt; 는 반복자를 배열의 다음 항목으로 진행시키고 이전 항목으로 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a7a62e345125510fec24ab409be072f82757690a" translate="yes" xml:space="preserve">
          <source>The postfix -- operator (&lt;code&gt;i--&lt;/code&gt;) backs the iterator up to the previous item in the container and returns the iterator's prior value.</source>
          <target state="translated">&lt;code&gt;i--&lt;/code&gt; 연산자 ( i-- )는 반복자를 컨테이너의 이전 항목으로 백업하고 반복자의 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ce7e03bc4a4d9d8f30841ad5538b383a2a3ef7b3" translate="yes" xml:space="preserve">
          <source>The postfix -- operator (&lt;code&gt;i--&lt;/code&gt;) makes the preceding item current and returns an iterator pointing to the previous item.</source>
          <target state="translated">접미사-연산자 ( &lt;code&gt;i--&lt;/code&gt; )는 이전 항목을 현재로 만들고 이전 항목을 가리키는 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d18632194c8ada5984aed5a5ce547a1a3fffb91" translate="yes" xml:space="preserve">
          <source>The postfix -- operator (&lt;code&gt;i--&lt;/code&gt;) makes the preceding item current and returns an iterator pointing to the previously current item.</source>
          <target state="translated">&lt;code&gt;i--&lt;/code&gt; 연산자 ( i-- )는 이전 항목을 현재로 만들고 이전 항목을 가리키는 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="330cb6d9f2ff539e075d46017f39409d6f5b10ba" translate="yes" xml:space="preserve">
          <source>The postfix -- operator (&lt;code&gt;i--&lt;/code&gt;) makes the preceding item current and returns an iterator to the old current item.</source>
          <target state="translated">접미사-연산자 ( &lt;code&gt;i--&lt;/code&gt; )는 이전 항목을 현재로 만들고 반복자를 이전 현재 항목으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="68428646829a8d32a7d4544f6388e8d851c4fd7a" translate="yes" xml:space="preserve">
          <source>The postfix -- operator (&lt;code&gt;i--&lt;/code&gt;) makes the preceding item in the current frame, and returns an iterator to the old item.</source>
          <target state="translated">접미사-연산자 ( &lt;code&gt;i--&lt;/code&gt; )는 현재 프레임에서 선행 항목을 만들고 이전 항목으로 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7df44a66bfaa208e535da6b5a0633bf7894de18f" translate="yes" xml:space="preserve">
          <source>The postfix -- operator (&lt;code&gt;it--&lt;/code&gt;) makes the preceding item current and returns an iterator to the previously current item.</source>
          <target state="translated">&lt;code&gt;it--&lt;/code&gt; 연산자 ( it-- )는 이전 항목을 현재로 만들고 이전 항목으로 반복자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7b988e70a06f70aaa93ea260d56cdd6b0a41aeb3" translate="yes" xml:space="preserve">
          <source>The postfix -- operator (&lt;code&gt;it--&lt;/code&gt;) makes the preceding result current and returns an iterator to the previously current result.</source>
          <target state="translated">&lt;code&gt;it--&lt;/code&gt; 연산자 ( it-- )는 선행 결과를 현재로 만들고 반복자를 이전 현재 결과로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="07181a735197c55fb7918001ac7cdcc47133d0e8" translate="yes" xml:space="preserve">
          <source>The postfix -- operator (it--) makes the preceding matching item current and returns an iterator to the previously current item.</source>
          <target state="translated">postfix-연산자 (it--)는 앞의 일치하는 항목을 현재로 만들고 반복자를 이전의 현재 항목으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca3b4651505fb1570b853c5d9e5fb865a1df038e" translate="yes" xml:space="preserve">
          <source>The postfix -- operator, &lt;code&gt;i--&lt;/code&gt;, makes the preceding item current and returns an iterator pointing to the previously current item.</source>
          <target state="translated">접미사-연산자 &lt;code&gt;i--&lt;/code&gt; 는 이전 항목을 현재로 만들고 이전 항목을 가리키는 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="96bda4eae3684651672f4beff75b8c225e98f014" translate="yes" xml:space="preserve">
          <source>The postfix -- operator, &lt;code&gt;it--&lt;/code&gt;, makes the preceding item current and returns an iterator to the previously current item.</source>
          <target state="translated">접미사-연산자 &lt;code&gt;it--&lt;/code&gt; 은 이전 항목을 현재로 만들고 이전 항목으로 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="42a93f6a7d55247f64fc74c527b20d71c12c01e4" translate="yes" xml:space="preserve">
          <source>The pragma declaration must appear before any JavaScript code excluding comments.</source>
          <target state="translated">pragma 선언은 주석을 제외한 JavaScript 코드 앞에 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="60dff934ddbd14a9975f32a60c6aa3e97e6164e0" translate="yes" xml:space="preserve">
          <source>The precision cannot be a negative value. The default value is 6.</source>
          <target state="translated">정밀도는 음수 값이 될 수 없습니다. 기본값은 6입니다.</target>
        </trans-unit>
        <trans-unit id="0ea411373aaeb64172e611c69a484978c2cac362" translate="yes" xml:space="preserve">
          <source>The precision of floating point numbers used for reading/writing the data. This will only have an effect if the version of the data stream is &lt;a href=&quot;qdatastream#Version-enum&quot;&gt;Qt_4_6&lt;/a&gt; or higher.</source>
          <target state="translated">데이터 읽기 / 쓰기에 사용되는 부동 소수점 숫자의 정밀도 이것은 데이터 스트림의 버전이 &lt;a href=&quot;qdatastream#Version-enum&quot;&gt;Qt_4_6&lt;/a&gt; 이상인 경우에만 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c35efbc9cbb7fc9af456f1636c8c83caae0f2046" translate="yes" xml:space="preserve">
          <source>The precompiled header must contain code which is</source>
          <target state="translated">미리 컴파일 된 헤더에는 다음과 같은 코드가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c19bfbcd594e83cb51752f1e1d0e931960186516" translate="yes" xml:space="preserve">
          <source>The predefined input modes are:</source>
          <target state="translated">사전 정의 된 입력 모드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f348a012d9c7575bec751967d5394eb7dd8b474c" translate="yes" xml:space="preserve">
          <source>The predefined pattern recognition modes are:</source>
          <target state="translated">사전 정의 된 패턴 인식 모드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cb7a8beb84e3624c396d8d205ffbc23c8e138ec9" translate="yes" xml:space="preserve">
          <source>The predicate uses the &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-string-length&quot;&gt;string-length()&lt;/a&gt; function to test the length of each &lt;code&gt;&amp;lt;method&amp;gt;&lt;/code&gt; element in each &lt;code&gt;&amp;lt;recipe&amp;gt;&lt;/code&gt; element found by the node test. If a &lt;code&gt;&amp;lt;method&amp;gt;&lt;/code&gt; contains no text, the predicate evaluates to &lt;code&gt;true&lt;/code&gt; and the &lt;code&gt;&amp;lt;recipe&amp;gt;&lt;/code&gt; element is selected. If the method contains some text, the predicate evaluates to &lt;code&gt;false&lt;/code&gt;, and the &lt;code&gt;&amp;lt;recipe&amp;gt;&lt;/code&gt; element is discarded. The output is the entire recipe that has no instructions for preparation:</source>
          <target state="translated">술어는 &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-string-length&quot;&gt;string-length ()&lt;/a&gt; 함수를 사용 하여 노드 테스트에서 찾은 각 &lt;code&gt;&amp;lt;recipe&amp;gt;&lt;/code&gt; 요소 에서 각 &amp;lt; &lt;code&gt;&amp;lt;method&amp;gt;&lt;/code&gt; 요소 의 길이를 테스트합니다. 경우 &lt;code&gt;&amp;lt;method&amp;gt;&lt;/code&gt; 에 텍스트를 포함하지 않는, 술어에 평가하여 &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;&amp;lt;recipe&amp;gt;&lt;/code&gt; 요소가 선택된다. 상기 방법은 텍스트에 술어 평가하여 포함한다면 &lt;code&gt;false&lt;/code&gt; 및 &lt;code&gt;&amp;lt;recipe&amp;gt;&lt;/code&gt; 요소는 삭제된다. 결과는 준비 지침이없는 전체 레시피입니다.</target>
        </trans-unit>
        <trans-unit id="02e480a55bdbc6e832a099f0dec12d2cff4243cd" translate="yes" xml:space="preserve">
          <source>The preferred hardware layer integration may be overridden by setting the QT_WAYLAND_HARDWARE_LAYER_INTEGRATION environment variable.</source>
          <target state="translated">QT_WAYLAND_HARDWARE_LAYER_INTEGRATION 환경 변수를 설정하여 기본 하드웨어 계층 통합을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="060dc3eec95a6792d81dfdc450624e2223d5422c" translate="yes" xml:space="preserve">
          <source>The preferred input language.</source>
          <target state="translated">선호하는 입력 언어입니다.</target>
        </trans-unit>
        <trans-unit id="383ef9dc6ee184ce410f602a841fb5fbbf1331a5" translate="yes" xml:space="preserve">
          <source>The preferred size of items in a &lt;a href=&quot;qml-qtquick-controls2-splitview&quot;&gt;SplitView&lt;/a&gt; can be specified via &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#implicitHeight-prop&quot;&gt;implicitHeight&lt;/a&gt; or &lt;code&gt;SplitView.preferredWidth&lt;/code&gt; and &lt;code&gt;SplitView.preferredHeight&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-splitview&quot;&gt;SplitView&lt;/a&gt; 에서 선호하는 항목 크기는 &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-item#implicitHeight-prop&quot;&gt;implicitHeight&lt;/a&gt; 또는 &lt;code&gt;SplitView.preferredWidth&lt;/code&gt; 및 &lt;code&gt;SplitView.preferredHeight&lt;/code&gt; 를 통해 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b6b8c5707ff0686af0310d6a9fe86dec6f2b66d" translate="yes" xml:space="preserve">
          <source>The preferred way of adding custom widgets to &lt;a href=&quot;quiloader&quot;&gt;QUiLoader&lt;/a&gt; is to subclass it reimplementing &lt;a href=&quot;quiloader#createWidget&quot;&gt;QUiLoader::createWidget&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;quiloader&quot;&gt;QUiLoader에&lt;/a&gt; 사용자 정의 위젯을 추가하는 기본 방법은 &lt;a href=&quot;quiloader#createWidget&quot;&gt;QUiLoader :: createWidget&lt;/a&gt; ()을 다시 구현하는 하위 클래스 화 입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
