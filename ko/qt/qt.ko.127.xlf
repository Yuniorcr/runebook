<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="9377b94c81bd5e9e0c2b348faf1c52cd5b327c7b" translate="yes" xml:space="preserve">
          <source>Note that, since the &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt; type is not a visual type, the properties of its children need to be exposed to the parent item of the &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt;. Layouts and positioning types will use these visual and styling properties to create the layout. In our example, the &lt;code&gt;Column&lt;/code&gt; type cannot display the two widgets properly because the &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt; lacks visual properties of its own. The MyWidget component directly binds to the &lt;code&gt;rectangle&lt;/code&gt; properties to allow the &lt;code&gt;Column&lt;/code&gt; type to create the layout containing the children of the &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt;.</source>
          <target state="translated">때문에,주의 &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope의&lt;/a&gt; 유형은 시각적 유형이 아닌, 아이의 특성이의 부모 항목에 노출 될 필요가 &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt; . 레이아웃 및 위치 지정 유형은 이러한 시각적 및 스타일 속성을 사용하여 레이아웃을 만듭니다. 이 예 에서 &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt; 에는 자체 시각적 속성이 없기 때문에 &lt;code&gt;Column&lt;/code&gt; 유형이 두 위젯을 올바르게 표시 할 수 없습니다 . MyWidget 구성 요소는 &lt;code&gt;rectangle&lt;/code&gt; 속성에 직접 바인딩되어 &lt;code&gt;Column&lt;/code&gt; 형식이 &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt; 의 자식을 포함하는 레이아웃을 만들 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="a839f37eab469e5c9d8d8739e4c38563d6ee4933" translate="yes" xml:space="preserve">
          <source>Note that, since the key sequences used for the standard shortcuts differ between platforms, you still need to test your shortcuts on each platform to ensure that you do not unintentionally assign the same key sequence to many actions.</source>
          <target state="translated">표준 바로 가기에 사용되는 키 시퀀스는 플랫폼마다 다르기 때문에 실수로 동일한 키 시퀀스를 여러 작업에 할당하지 않도록 각 플랫폼에서 바로 가기를 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="9bd7a320ce92353b5113f62cc37ecce8ac345b0e" translate="yes" xml:space="preserve">
          <source>Note the &quot;File|Open&quot; translator comment. It is by no means necessary, but it provides some context for the human translator.</source>
          <target state="translated">&quot;File | Open&quot;번역기 주석을 참고하십시오. 꼭 필요한 것은 아니지만 인간 번역가에게 어떤 맥락을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0522066d7f03424028785446ce22d3cdef7a0ca4" translate="yes" xml:space="preserve">
          <source>Note the &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; basic type is a generic placeholder type that can hold any type of value, including lists and objects:</source>
          <target state="translated">메모 &lt;a href=&quot;qml-var&quot;&gt;VAR&lt;/a&gt; 기본 유형의 목록과 객체를 포함하여 모든 유형의 값을 보유 할 수있는 일반적인 자리 표시 자 유형입니다 :</target>
        </trans-unit>
        <trans-unit id="0f17514825465d5f3f0a627fbf90f410ab85e603" translate="yes" xml:space="preserve">
          <source>Note the QML engine may create QNetworkAccessManager instances from multiple threads. Because of this, the implementation of the &lt;a href=&quot;qqmlnetworkaccessmanagerfactory#create&quot;&gt;create&lt;/a&gt;() method must be &lt;a href=&quot;qrandomgenerator#reentrancy-and-thread-safety&quot;&gt;reentrant&lt;/a&gt;. In addition, the developer should be careful if the signals of the object to be returned from &lt;a href=&quot;qqmlnetworkaccessmanagerfactory#create&quot;&gt;create&lt;/a&gt;() are connected to the slots of an object that may be created in a different thread:</source>
          <target state="translated">QML 엔진은 여러 스레드에서 QNetworkAccessManager 인스턴스를 작성할 수 있습니다. 이 때문에 &lt;a href=&quot;qqmlnetworkaccessmanagerfactory#create&quot;&gt;create&lt;/a&gt; () 메소드 의 구현은 &lt;a href=&quot;qrandomgenerator#reentrancy-and-thread-safety&quot;&gt;재진입&lt;/a&gt; 해야 합니다 . 또한 &lt;a href=&quot;qqmlnetworkaccessmanagerfactory#create&quot;&gt;create&lt;/a&gt; () 에서 반환 할 객체의 신호가 다른 스레드에서 생성 될 수있는 객체의 슬롯에 연결되어 있으면 개발자는주의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="457645881dd7a7d5647156a25ba16527f591f1e4" translate="yes" xml:space="preserve">
          <source>Note the call to &lt;a href=&quot;qml-qtqml-models-listmodel#sync-method&quot;&gt;sync()&lt;/a&gt; from the external thread. You must call &lt;a href=&quot;qml-qtqml-models-listmodel#sync-method&quot;&gt;sync()&lt;/a&gt; or else the changes made to the list from that thread will not be reflected in the list model in the main thread.</source>
          <target state="translated">외부 스레드에서 &lt;a href=&quot;qml-qtqml-models-listmodel#sync-method&quot;&gt;sync ()&lt;/a&gt; 를 호출하십시오 . &lt;a href=&quot;qml-qtqml-models-listmodel#sync-method&quot;&gt;sync ()&lt;/a&gt; 를 호출해야합니다. 그렇지 않으면 해당 스레드의 목록에 대한 변경 사항이 기본 스레드의 목록 모델에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97a1a170d3e29cfdeb313260e434c32b8faf73b2" translate="yes" xml:space="preserve">
          <source>Note the current brush color will</source>
          <target state="translated">현재 브러시 색상은</target>
        </trans-unit>
        <trans-unit id="0490e9fa13b04981f734ba9d05c2fd1eb2ef9b45" translate="yes" xml:space="preserve">
          <source>Note the difference between Point and DevicePixel. The Point unit is defined to be 1/72th of an inch, while the DevicePixel unit is resolution dependant and is based on the actual pixels, or dots, on the printer.</source>
          <target state="translated">Point와 DevicePixel의 차이점에 유의하십시오. Point 단위는 1/72 인치로 정의되는 반면 DevicePixel 단위는 해상도에 따라 달라지며 프린터의 실제 픽셀 또는 도트를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="ea2735b34bd29497a534f65b6c25bab42fad9abb" translate="yes" xml:space="preserve">
          <source>Note the difference between creating a connection and opening it. Creating a connection involves creating an instance of class &lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase&lt;/a&gt;. The connection is not usable until it is opened. The following snippet shows how to create a</source>
          <target state="translated">연결 작성과 열기의 차이점에 유의하십시오. 연결을 작성하려면 &lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase&lt;/a&gt; 클래스의 인스턴스를 작성해야합니다 . 연결을 열 때까지 사용할 수 없습니다. 다음 스 니펫은</target>
        </trans-unit>
        <trans-unit id="da9f3bac3ce742ff213021cd0efab04299c2552c" translate="yes" xml:space="preserve">
          <source>Note the that the current index changes independently from the selection. Also note that this signal will not be emitted when the item model is reset.</source>
          <target state="translated">현재 색인은 선택 항목과 독립적으로 변경됩니다. 또한이 신호는 아이템 모델이 재설정 될 때 방출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0f5735466600bd8235811043a155da60eb0311d" translate="yes" xml:space="preserve">
          <source>Note the usage of the non-capturing group in order to preserve the meaning of the branch operator inside the pattern.</source>
          <target state="translated">패턴 내에서 분기 연산자의 의미를 유지하기 위해 캡처하지 않은 그룹의 사용법에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="2aa94b2a2b33d9741c313fc11c4d1be8ccce509e" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;a href=&quot;qdbuspendingreply&quot;&gt;QDBusPendingReply&lt;/a&gt; to validate the argument types in the reply. If the reply did not contain exactly two arguments (one string and one &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;), &lt;a href=&quot;qdbuspendingreply#isError&quot;&gt;QDBusPendingReply::isError&lt;/a&gt;() will return true.</source>
          <target state="translated">응답에서 인수 유형의 유효성을 검증하기 위해 &lt;a href=&quot;qdbuspendingreply&quot;&gt;QDBusPendingReply&lt;/a&gt; 를 사용 하십시오. 응답에 정확히 두 개의 인수 (하나의 문자열과 하나의 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; )가 포함되어 있지 않으면 &lt;a href=&quot;qdbuspendingreply#isError&quot;&gt;QDBusPendingReply :: isError&lt;/a&gt; ()가 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fb3aff543cc3e94b5a9c2307b45b8fb60e8e8a15" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;a href=&quot;qlibraryinfo#location&quot;&gt;QLibraryInfo::location&lt;/a&gt;() to locate the Qt translations. Developers should request the path to the translations at run-time by passing &lt;a href=&quot;qlibraryinfo#LibraryLocation-enum&quot;&gt;QLibraryInfo::TranslationsPath&lt;/a&gt; to this function instead of using the &lt;code&gt;QTDIR&lt;/code&gt; environment variable in their applications.</source>
          <target state="translated">의 사용을 참고 &lt;a href=&quot;qlibraryinfo#location&quot;&gt;QLibraryInfo :: 위치를&lt;/a&gt; Qt의 번역을 찾습니다 (). 개발자는 애플리케이션에서 &lt;code&gt;QTDIR&lt;/code&gt; 환경 변수 를 사용하는 대신 &lt;a href=&quot;qlibraryinfo#LibraryLocation-enum&quot;&gt;QLibraryInfo :: TranslationsPath&lt;/a&gt; 를이 함수 에 전달하여 런타임시 변환 경로를 요청해야 합니다.</target>
        </trans-unit>
        <trans-unit id="3e10129aa30a305341640458143cf780001e0cea" translate="yes" xml:space="preserve">
          <source>Note the use of &lt;code&gt;color&lt;/code&gt; property with qualifier. The properties of the object are not replicated in the &lt;code&gt;model&lt;/code&gt; object, as they are easily available via the &lt;code&gt;modelData&lt;/code&gt; object.</source>
          <target state="translated">한정자와 함께 &lt;code&gt;color&lt;/code&gt; 속성을 사용하십시오 . &lt;code&gt;modelData&lt;/code&gt; 객체 를 통해 쉽게 사용할 수 있으므로 객체의 속성이 &lt;code&gt;model&lt;/code&gt; 객체에 복제되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f2685686550ede11896f818d026b3d2e975d41ed" translate="yes" xml:space="preserve">
          <source>Note this automatically binds &lt;code&gt;rect.height&lt;/code&gt; to &lt;code&gt;container.height&lt;/code&gt; in the</source>
          <target state="translated">이것은 &lt;code&gt;rect.height&lt;/code&gt; 를 &lt;code&gt;container.height&lt;/code&gt; 에 자동으로 바인딩 합니다.</target>
        </trans-unit>
        <trans-unit id="7018b656be5605f0ddd3254949f47568a2e66ed0" translate="yes" xml:space="preserve">
          <source>Note this property is not updated when the action is disabled.</source>
          <target state="translated">조치가 사용 불가능하면이 특성이 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0256e529e1940145606192ebb2fa70115940cdaa" translate="yes" xml:space="preserve">
          <source>Note too that the abbreviation is not guaranteed to be a unique value, i.e. different time zones may have the same abbreviation.</source>
          <target state="translated">약어가 고유 한 값으로 보장되지는 않습니다. 즉, 다른 시간대는 동일한 약어를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e38c4da838574c6cd034f77421795ed1c17d896" translate="yes" xml:space="preserve">
          <source>Note you have to set the cache directory before it will work.</source>
          <target state="translated">캐시 디렉토리가 작동하기 전에 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9aa7e3e5f6fa53a2d7fce7c8b8387be69c4d1f27" translate="yes" xml:space="preserve">
          <source>Note, due to limitations of the &lt;a href=&quot;qqmlpropertymap&quot;&gt;QQmlPropertyMap&lt;/a&gt;, it is not possible to declaratively specify the attributes in QML, assignment of attributes keys and values can only be accomplished by JavaScript.</source>
          <target state="translated">&lt;a href=&quot;qqmlpropertymap&quot;&gt;QQmlPropertyMap의&lt;/a&gt; 한계로 인해 QML에서 속성을 선언적으로 지정할 수 없으며 속성 키 및 값 지정은 JavaScript를 통해서만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3fddddb658aece21f52afd821c4c0e915aff84e" translate="yes" xml:space="preserve">
          <source>Note, due to limitations of the &lt;a href=&quot;qqmlpropertymap&quot;&gt;QQmlPropertyMap&lt;/a&gt;, it is not possible to declaratively specify the contact details in QML, it can only be accomplished via JavaScript.</source>
          <target state="translated">&lt;a href=&quot;qqmlpropertymap&quot;&gt;QQmlPropertyMap의&lt;/a&gt; 제한으로 인해 QML에서 연락처 세부 사항을 선언적으로 지정할 수 없으며 JavaScript를 통해서만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49a37c77c162052dc566987d9605d8eb850d7e55" translate="yes" xml:space="preserve">
          <source>Note, due to limitations of the &lt;a href=&quot;qqmlpropertymap&quot;&gt;QQmlPropertyMap&lt;/a&gt;, it is not possible to declaratively specify the parameters in QML, assignment of parameters keys and values can only be accomplished by JavaScript.</source>
          <target state="translated">&lt;a href=&quot;qqmlpropertymap&quot;&gt;QQmlPropertyMap의&lt;/a&gt; 한계로 인해 QML에서 매개 변수를 선언적으로 지정할 수 없으며 매개 변수 키 및 값 지정은 JavaScript를 통해서만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4ad8ae6f2d0015b04551a085b8f299dba5d0c38" translate="yes" xml:space="preserve">
          <source>Note, however, if this object was registered with the &lt;a href=&quot;qdbusconnection#RegisterOption-enum&quot;&gt;ExportChildObjects&lt;/a&gt; option, UnregisterNode will unregister the child objects too.</source>
          <target state="translated">그러나이 객체가 &lt;a href=&quot;qdbusconnection#RegisterOption-enum&quot;&gt;ExportChildObjects&lt;/a&gt; 옵션으로 등록 된 경우 UnregisterNode는 하위 객체도 등록 취소합니다.</target>
        </trans-unit>
        <trans-unit id="48ba44dd910ef14bd3b6e50fccfce5e590e68682" translate="yes" xml:space="preserve">
          <source>Note, however, that it is almost always preferable to define a small struct to hold the result of a function with multiple return values. A struct trivially generalizes to more than two values, and allows more descriptive member names than &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;:</source>
          <target state="translated">그러나 여러 반환 값을 가진 함수의 결과를 보유하도록 작은 구조체를 정의하는 것이 거의 항상 바람직합니다. 구조체는 두 개 이상의 값으로 일반화하고 &lt;code&gt;first&lt;/code&gt; 와 &lt;code&gt;second&lt;/code&gt; 보다 더 설명적인 멤버 이름을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="e035614c6a973e0e3191c7be5d90bcbac8ae2201" translate="yes" xml:space="preserve">
          <source>Note, however, that the pointer tracking feature has limitations on multiple- or virtual-inheritance (that is, in cases where two different pointer addresses can refer to the same object). In that case, if a pointer is cast to a different type and its value changes, &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt;'s pointer tracking mechanism may fail to detect that the object being tracked is the same.</source>
          <target state="translated">그러나 포인터 추적 기능에는 다중 상속 또는 가상 상속 (즉, 두 개의 서로 다른 포인터 주소가 동일한 객체를 참조 할 수있는 경우)에 제한이 있습니다. 이 경우 포인터가 다른 유형으로 캐스트되고 해당 값이 변경되면 &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; 의 포인터 추적 메커니즘이 추적중인 오브젝트가 동일한 지를 감지하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cabb9c1b9ab246b52d786de4347c7aa3d923fca" translate="yes" xml:space="preserve">
          <source>Note, however, that this is a parent-child relationship in the context of the QML object tree, not in the context of the visual scene. The concept of a parent-child relationship in a visual scene is provided by the &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; type from the &lt;code&gt;QtQuick&lt;/code&gt; module, which is the base type for most QML types, as most QML objects are intended to be visually rendered. For example, &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; are both &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt;-based types, and below, a &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; object has been declared as a visual child of a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; object:</source>
          <target state="translated">그러나 이는 시각적 장면의 컨텍스트가 아닌 QML 오브젝트 트리의 컨텍스트에서 상위-하위 관계입니다. 시각적 장면에서 부모-자식 관계의 개념은 대부분의 QML 개체가 시각적으로 렌더링되기 때문에 대부분의 QML 유형의 기본 유형 인 &lt;code&gt;QtQuick&lt;/code&gt; 모듈 의 &lt;a href=&quot;qml-qtquick-item&quot;&gt;항목&lt;/a&gt; 유형에 의해 제공 됩니다. 예를 들어 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; 는 모두 &lt;a href=&quot;qml-qtquick-item&quot;&gt;항목&lt;/a&gt; 기반 유형이며 아래에서 &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; 객체는 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; 객체 의 시각적 자식으로 선언되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c1b7fc3b5df1a065d4d3e96ea28ce4b24d2ddfd0" translate="yes" xml:space="preserve">
          <source>Note, however, that when the conditions specified above are not met, each append or insert of a new item requires allocating the new item on the heap, and this per item allocation will make &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; a better choice for use cases that do a lot of appending or inserting, because &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; can allocate memory for many items in a single heap allocation.</source>
          <target state="translated">그러나 위에서 지정한 조건이 충족되지 않으면 새 항목을 추가하거나 삽입 할 때마다 새 항목을 힙에 할당해야 &lt;a href=&quot;qvector&quot;&gt;하므로이&lt;/a&gt; 항목 당 할당은 QVector 가 많은 작업을 수행하는 사용 사례에 더 적합한 선택입니다. &lt;a href=&quot;qvector&quot;&gt;QVector&lt;/a&gt; 는 단일 힙 할당에서 많은 항목에 메모리를 할당 할 수 있기 때문에 추가 또는 삽입 .</target>
        </trans-unit>
        <trans-unit id="770b60a6a88ffbbcfc132d6a8676ec57063b0975" translate="yes" xml:space="preserve">
          <source>Note, on X11 this will return the true available geometry only on systems with one monitor and if window manager has set _NET_WORKAREA atom. In all other cases this is equal to &lt;a href=&quot;qscreen#geometry-prop&quot;&gt;geometry&lt;/a&gt;(). This is a limitation in X11 window manager specification.</source>
          <target state="translated">X11에서는 모니터가 하나이고 창 관리자가 _NET_WORKAREA 아톰을 설정 한 경우에만 사용 가능한 실제 형상을 리턴합니다. 다른 모든 경우에는 &lt;a href=&quot;qscreen#geometry-prop&quot;&gt;지오메트리&lt;/a&gt; ()와 같습니다. 이것은 X11 창 관리자 사양의 제한 사항입니다.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="d3f2036bea85d88641d598cd424fd745e5e38f71" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; is an &lt;a href=&quot;implicit-sharing#&quot;&gt;implicitly shared&lt;/a&gt; class. Consequently, if you append to an empty byte array, then the byte array will just share the data held in</source>
          <target state="translated">참고 : &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 는 &lt;a href=&quot;implicit-sharing#&quot;&gt;암시 적으로 공유 된&lt;/a&gt; 클래스입니다. 결과적으로 빈 바이트 배열에 추가하면 바이트 배열에 저장된 데이터 만 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="0714b456fa13e559c341b9b3f0f15039d75a5e39" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; is an &lt;a href=&quot;implicit-sharing#&quot;&gt;implicitly shared&lt;/a&gt; class. Consequently, if you prepend to an empty byte array, then the byte array will just share the data held in</source>
          <target state="translated">참고 : &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 는 &lt;a href=&quot;implicit-sharing#&quot;&gt;암시 적으로 공유 된&lt;/a&gt; 클래스입니다. 따라서 빈 바이트 배열을 앞에 추가하면 바이트 배열에 저장된 데이터 만 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="59ba4433b3639dcf072786ab193aaf31b9209727" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qdbusmessage&quot;&gt;QDBusMessage&lt;/a&gt; objects are shared. Modifications made to the copy will affect the original one as well. See &lt;a href=&quot;qdbusmessage#setDelayedReply&quot;&gt;setDelayedReply&lt;/a&gt;() for more information.</source>
          <target state="translated">참고 : &lt;a href=&quot;qdbusmessage&quot;&gt;QDBusMessage&lt;/a&gt; 오브젝트는 공유됩니다. 사본을 수정하면 원본에도 영향을 미칩니다. 자세한 내용은 &lt;a href=&quot;qdbusmessage#setDelayedReply&quot;&gt;setDelayedReply&lt;/a&gt; ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c0f7347d06c5e67ee13d15459d29a91851a85a7a" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt; does not call this function for &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt;() and that neither &lt;a href=&quot;qdoublespinbox#prefix-prop&quot;&gt;prefix&lt;/a&gt;() nor &lt;a href=&quot;qdoublespinbox#suffix-prop&quot;&gt;suffix&lt;/a&gt;() should be included in the return value.</source>
          <target state="translated">참고 : &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt; 는 &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt; () 에 대해이 함수를 호출하지 않으며 &lt;a href=&quot;qdoublespinbox#prefix-prop&quot;&gt;접두사&lt;/a&gt; () 또는 &lt;a href=&quot;qdoublespinbox#suffix-prop&quot;&gt;접미사&lt;/a&gt; ()를 반환 값에 포함 하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="68578566da4f2e7968adb08a5d6446e309ee8755" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt; handles &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt;() separately; this function is only concerned with the other values.</source>
          <target state="translated">참고 : &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt; 는 &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt; ()를 개별적으로 처리합니다 . 이 기능은 다른 값에만 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="804dca480fe7343afdc7f41ed3b4c1ea7e159fd8" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt; will round numbers so they can be displayed with the current precision. In a &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt; with decimals set to 2, calling &lt;a href=&quot;qdoublespinbox#value-prop&quot;&gt;setValue&lt;/a&gt;(2.555) will cause &lt;a href=&quot;qdoublespinbox#value-prop&quot;&gt;value&lt;/a&gt;() to return 2.56.</source>
          <target state="translated">참고 : &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt; 는 숫자를 반올림하여 현재 정밀도로 표시 할 수 있습니다. A의 &lt;a href=&quot;qdoublespinbox&quot;&gt;QDoubleSpinBox&lt;/a&gt; 호출 2로 설정 소수와 &lt;a href=&quot;qdoublespinbox#value-prop&quot;&gt;의 setValue&lt;/a&gt; (2.555)를 야기한다 &lt;a href=&quot;qdoublespinbox#value-prop&quot;&gt;값&lt;/a&gt; 2.56을 반환을 ().</target>
        </trans-unit>
        <trans-unit id="3ddd3d1f86fbc11aee9f6d9f1f7bb1133700df6a" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qimage#pixel&quot;&gt;QImage::pixel&lt;/a&gt;() returns the color of the pixel at the given coordinates while QColor::pixel() returns the pixel value of the underlying window system (essentially an index value), so normally you will want to use &lt;a href=&quot;qimage#pixel&quot;&gt;QImage::pixel&lt;/a&gt;() to use a color from an existing image or &lt;a href=&quot;qcolor#rgb&quot;&gt;QColor::rgb&lt;/a&gt;() to use a specific color.</source>
          <target state="translated">참고 : &lt;a href=&quot;qimage#pixel&quot;&gt;QImage :: pixel&lt;/a&gt; ()은 주어진 좌표에서 픽셀의 색상을 반환하는 반면 QColor :: pixel ()는 기본 윈도우 시스템의 픽셀 값 (실제로는 인덱스 값)을 반환하므로 일반적으로 &lt;a href=&quot;qimage#pixel&quot;&gt;QImage&lt;/a&gt; 를 사용하려고합니다 . : pixel () 기존 이미지의 색상을 사용하거나 &lt;a href=&quot;qcolor#rgb&quot;&gt;QColor :: rgb&lt;/a&gt; ()를 사용하여 특정 색상을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e0b0e12917c710964c3fbeb2647c74aa49de6eb3" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; takes ownership of the</source>
          <target state="translated">참고 : &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; 는</target>
        </trans-unit>
        <trans-unit id="52b9a6116ba142df7c20b2be74fc4ade8a27806b" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qmodbusclient&quot;&gt;QModbusClient&lt;/a&gt; queues the requests it receives. The number of requests executed in parallel is dependent on the protocol. For example, the HTTP protocol on desktop platforms issues 6 requests in parallel for one host/port combination.</source>
          <target state="translated">참고 : &lt;a href=&quot;qmodbusclient&quot;&gt;QModbusClient&lt;/a&gt; 는 수신 한 요청을 대기열에 넣 습니다. 병렬로 실행되는 요청 수는 프로토콜에 따라 다릅니다. 예를 들어, 데스크탑 플랫폼의 HTTP 프로토콜은 하나의 호스트 / 포트 조합에 대해 6 개의 요청을 병렬로 발행합니다.</target>
        </trans-unit>
        <trans-unit id="3b8f20a9b8aa76e53a9dc43cc79dc44045d9cf36" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt; does not implement copy-on-write semantics, so</source>
          <target state="translated">참고 : &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt; 는 기록 중 복사 시맨틱을 구현하지 않으므로</target>
        </trans-unit>
        <trans-unit id="b152a796ad90a95cfb1c48fd622b4be38e87963d" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qremoteobjecthostbase#proxy&quot;&gt;proxy&lt;/a&gt;() needs to be called before reverseProxy(), and a</source>
          <target state="translated">참고 : &lt;a href=&quot;qremoteobjecthostbase#proxy&quot;&gt;proxy&lt;/a&gt; ()를 reverseProxy () 전에 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="317d73c8dc5f15815accced3d65ff2fccfc8c61d" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; does not call this function for &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt;() and that neither &lt;a href=&quot;qspinbox#prefix-prop&quot;&gt;prefix&lt;/a&gt;() nor &lt;a href=&quot;qspinbox#suffix-prop&quot;&gt;suffix&lt;/a&gt;() should be included in the return value.</source>
          <target state="translated">참고 : &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; 는 &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt; () 에 대해이 함수를 호출하지 않으며 &lt;a href=&quot;qspinbox#prefix-prop&quot;&gt;접두사&lt;/a&gt; () 또는 &lt;a href=&quot;qspinbox#suffix-prop&quot;&gt;접미사&lt;/a&gt; ()를 반환 값에 포함 하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="e58f8733e51032c9b285e7bea1e6f72ad4bfa47c" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; handles &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt;() separately; this function is only concerned with the other values.</source>
          <target state="translated">참고 : &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; 는 &lt;a href=&quot;qabstractspinbox#specialValueText-prop&quot;&gt;specialValueText&lt;/a&gt; ()를 개별적으로 처리합니다 . 이 기능은 다른 값에만 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="0b6cd466d32b185eef4ae40ca60e0cd9a9855804" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;AeroStyle&lt;/a&gt; has effect only on a Windows Vista system with alpha compositing enabled. &lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;ModernStyle&lt;/a&gt; is used as a fallback when this condition is not met.</source>
          <target state="translated">참고 : &lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;AeroStyle&lt;/a&gt; 은 알파 합성이 활성화 된 Windows Vista 시스템에서만 적용됩니다. 이 조건이 충족되지 않으면 &lt;a href=&quot;qwizard#WizardStyle-enum&quot;&gt;ModernStyle&lt;/a&gt; 이 대체로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8c87eb400f2a7e6c4810cfcf04ff4d9053b7d08b" translate="yes" xml:space="preserve">
          <source>Note: A &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; can store any byte values including '\0's, but most functions that take &lt;code&gt;char *&lt;/code&gt; arguments assume that the data ends at the first '\0' they encounter.</source>
          <target state="translated">참고 : &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 는 '\ 0'을 포함한 모든 바이트 값을 저장할 수 있지만 &lt;code&gt;char *&lt;/code&gt; 인수를 사용 하는 대부분의 함수 는 데이터가 처음 '\ 0'에서 끝나는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="86f09090a72d1292ad2e5847809cc44e6dd6d5b9" translate="yes" xml:space="preserve">
          <source>Note: A widget receives spontaneous show and hide events when its mapping status is changed by the window system, e.g. a spontaneous hide event when the user minimizes the window, and a spontaneous show event when the window is restored again. After receiving a spontaneous hide event, a widget is still considered visible in the sense of &lt;a href=&quot;qwidget#visible-prop&quot;&gt;isVisible&lt;/a&gt;().</source>
          <target state="translated">참고 : 위젯은 맵핑 상태가 창 시스템에 의해 변경 될 때 자발적 표시 및 숨기기 이벤트를 수신합니다 (예 : 사용자가 창을 최소화 할 때의 자발적 숨기기 이벤트 및 창이 다시 복원 될 때의 자발적 표시 이벤트). 자발적인 숨기기 이벤트를 수신 한 후에도 위젯은 여전히 &lt;a href=&quot;qwidget#visible-prop&quot;&gt;isVisible&lt;/a&gt; () 의 의미로 볼 수있는 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="021bb30ea7e63b156244933c7c6b2f3738726df6" translate="yes" xml:space="preserve">
          <source>Note: Adjustments to the volume will change the volume of this audio stream, not the global volume.</source>
          <target state="translated">참고 : 볼륨을 조정하면 글로벌 볼륨이 아닌이 오디오 스트림의 볼륨이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="fb652f7988687ef6963c0c8424de9c5a2cb70e0e" translate="yes" xml:space="preserve">
          <source>Note: As the resource initializers generated by rcc are declared in the global namespace, your calls to &lt;a href=&quot;qdir#Q_INIT_RESOURCE&quot;&gt;Q_INIT_RESOURCE&lt;/a&gt;() also need to be done outside of any namespace.</source>
          <target state="translated">참고 : rcc에 의해 생성 된 리소스 이니셜 라이저가 전역 네임 스페이스에서 선언 &lt;a href=&quot;qdir#Q_INIT_RESOURCE&quot;&gt;되므로 Q_INIT_RESOURCE&lt;/a&gt; ()에 대한 호출 도 네임 스페이스 외부에서 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="86be476e1e41f3c33fa39129c864914babee6f38" translate="yes" xml:space="preserve">
          <source>Note: Be careful with calling functions on the &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; itself inside &lt;a href=&quot;qgraphicsitem#itemChange&quot;&gt;itemChange&lt;/a&gt;(), as certain function calls can lead to unwanted recursion. For example, you cannot call &lt;a href=&quot;qgraphicsitem#setPos&quot;&gt;setPos&lt;/a&gt;() in &lt;a href=&quot;qgraphicsitem#itemChange&quot;&gt;itemChange&lt;/a&gt;() on an ItemPositionChange notification, as the &lt;a href=&quot;qgraphicsitem#setPos&quot;&gt;setPos&lt;/a&gt;() function will again call &lt;a href=&quot;qgraphicsitem#itemChange&quot;&gt;itemChange&lt;/a&gt;(ItemPositionChange). Instead, you can return the new, adjusted position from &lt;a href=&quot;qgraphicsitem#itemChange&quot;&gt;itemChange&lt;/a&gt;().</source>
          <target state="translated">참고 : 특정 함수 호출로 인해 원하지 않는 재귀가 발생할 수 있으므로 &lt;a href=&quot;qgraphicsitem#itemChange&quot;&gt;itemChange&lt;/a&gt; () 내 에서 &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 자체의 함수 호출에주의하십시오 . 예를 들어, &lt;a href=&quot;qgraphicsitem#setPos&quot;&gt;setPos&lt;/a&gt; () 함수가 다시 &lt;a href=&quot;qgraphicsitem#itemChange&quot;&gt;itemChange&lt;/a&gt; (ItemPositionChange)를 호출 하므로 ItemPositionChange 알림의 &lt;a href=&quot;qgraphicsitem#setPos&quot;&gt;itemChange&lt;/a&gt; ()에서 &lt;a href=&quot;qgraphicsitem#itemChange&quot;&gt;setPos&lt;/a&gt; ()를 호출 할 수 없습니다 . 대신 &lt;a href=&quot;qgraphicsitem#itemChange&quot;&gt;itemChange&lt;/a&gt; () 에서 조정 된 새 위치를 반환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf3120fe5e3f07fd563d16a77f0ddc4e0d695732" translate="yes" xml:space="preserve">
          <source>Note: Certain &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; functions cannot be called in a reimplementation of this function; see the &lt;a href=&quot;qgraphicsitem#GraphicsItemChange-enum&quot;&gt;GraphicsItemChange&lt;/a&gt; documentation for details.</source>
          <target state="translated">참고 : 특정 &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 함수는이 함수를 다시 구현하여 호출 할 수 없습니다. 자세한 내용은 &lt;a href=&quot;qgraphicsitem#GraphicsItemChange-enum&quot;&gt;GraphicsItemChange&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5758b05de346a1a4ebb5a86db1a4cc1008102f59" translate="yes" xml:space="preserve">
          <source>Note: Corner widgets are designed for &lt;a href=&quot;qtabwidget#TabPosition-enum&quot;&gt;North&lt;/a&gt; and &lt;a href=&quot;qtabwidget#TabPosition-enum&quot;&gt;South&lt;/a&gt; tab positions; other orientations are known to not work properly.</source>
          <target state="translated">참고 : 코너 위젯은 &lt;a href=&quot;qtabwidget#TabPosition-enum&quot;&gt;북쪽&lt;/a&gt; 및 &lt;a href=&quot;qtabwidget#TabPosition-enum&quot;&gt;남쪽&lt;/a&gt; 탭 위치를 위해 설계되었습니다 . 다른 방향은 제대로 작동하지 않는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="d67b1cd3532b5f1abe1363bda15af7287527982e" translate="yes" xml:space="preserve">
          <source>Note: Despite the different actual character heights, the heights of the bounding rectangles of &quot;Yes&quot; and &quot;yes&quot; are the same.</source>
          <target state="translated">참고 : 실제 문자 높이가 다르더라도 &quot;예&quot;와 &quot;예&quot;의 경계 사각형의 높이는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="be7a4b307e37e09bcf5d6c5635cf5c25f0771c2e" translate="yes" xml:space="preserve">
          <source>Note: Do not delete this reply object in the slot connected to this signal. Use &lt;a href=&quot;qobject#deleteLater&quot;&gt;deleteLater&lt;/a&gt;() instead.</source>
          <target state="translated">참고 :이 신호에 연결된 슬롯에서이 응답 객체를 삭제하지 마십시오. 대신 &lt;a href=&quot;qobject#deleteLater&quot;&gt;deleteLater&lt;/a&gt; ()를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f2592308a859edb45d114d9672a367ebfdd77f8" translate="yes" xml:space="preserve">
          <source>Note: Drivers that don't support fetching numerical values with low precision will ignore the precision policy. You can use &lt;a href=&quot;qsqldriver#hasFeature&quot;&gt;QSqlDriver::hasFeature&lt;/a&gt;() to find out whether a driver supports this feature.</source>
          <target state="translated">참고 : 정밀도가 낮은 숫자 값 가져 오기를 지원하지 않는 드라이버는 정밀도 정책을 무시합니다. &lt;a href=&quot;qsqldriver#hasFeature&quot;&gt;QSqlDriver :: hasFeature&lt;/a&gt; ()를 사용 하여 드라이버가이 기능을 지원하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7b7d1f0f18fd210ecc37af6c13bd4fd680bc8e9" translate="yes" xml:space="preserve">
          <source>Note: Even a non-null icon might not be able to create valid pixmaps, eg. if the file does not exist or cannot be read.</source>
          <target state="translated">참고 : null이 아닌 아이콘이라도 유효한 픽스맵을 생성하지 못할 수 있습니다. 파일이 없거나 읽을 수없는 경우</target>
        </trans-unit>
        <trans-unit id="49a04c87ce30ac189aa7c5f0ae4c848ea287741b" translate="yes" xml:space="preserve">
          <source>Note: Even though &lt;a href=&quot;qlocalserver&quot;&gt;QLocalServer&lt;/a&gt; will stop accepting new connections after it has reached its maximum number of pending connections, the operating system may still keep them in queue which will result in clients signaling that it is connected.</source>
          <target state="translated">참고 : &lt;a href=&quot;qlocalserver&quot;&gt;QLocalServer&lt;/a&gt; 가 보류중인 최대 연결 수에 도달 한 후 새 연결 수락을 중지 하더라도 운영 체제는 여전히 연결을 대기열에 유지하여 클라이언트가 연결되었음을 알리는 결과를 낳을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bedc7da9e37ada9827eb25ca35673c9a483cdd56" translate="yes" xml:space="preserve">
          <source>Note: Even though this type contains a very limited API, the properties and signals of the implementations are named consistently. For example, if you're only using desktop shell extensions in your compositor, it's safe to access properties such as title, maximized, etc. directly on the &lt;a href=&quot;qml-qtwayland-compositor-shellsurface&quot;&gt;ShellSurface&lt;/a&gt;. See the various implementations for additional properties and signals.</source>
          <target state="translated">참고 :이 유형에는 매우 제한된 API가 포함되어 있지만 구현의 특성 및 신호는 일관되게 이름이 지정됩니다. 예를 들어, 컴포 지터에서 데스크톱 셸 확장 만 사용하는 경우 &lt;a href=&quot;qml-qtwayland-compositor-shellsurface&quot;&gt;ShellSurface에서&lt;/a&gt; 직접 제목, 최대화 등의 속성에 액세스하는 것이 안전합니다 . 추가 속성 및 신호에 대해서는 다양한 구현을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="354c3d7dddac02b5c014fa08fc1313ff0935ccc0" translate="yes" xml:space="preserve">
          <source>Note: For database models, &lt;a href=&quot;qsqlquerymodel#lastError&quot;&gt;QSqlQueryModel::lastError&lt;/a&gt;() can be used to retrieve the last error.</source>
          <target state="translated">참고 : 데이터베이스 모델의 경우 &lt;a href=&quot;qsqlquerymodel#lastError&quot;&gt;QSqlQueryModel :: lastError&lt;/a&gt; ()를 사용하여 마지막 오류를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da661695fa14edbafa0519f745e3586128d02492" translate="yes" xml:space="preserve">
          <source>Note: For shapes that paint an outline / stroke, it is important to include half the pen width in the bounding rect. It is not necessary to compensate for antialiasing, though.</source>
          <target state="translated">참고 : 윤곽선 / 획을 그리는 모양의 경우 경계 사각형에 펜 너비의 절반을 포함시키는 것이 중요합니다. 그러나 앤티 앨리어싱을 보상 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1fc0472e9b41c40838b64ee4d0ba870488a5ca38" translate="yes" xml:space="preserve">
          <source>Note: If a button is pressed down by a shortcut key, then auto-repeat is enabled and timed by the system and not by this class. The &lt;a href=&quot;qabstractbutton#pressed&quot;&gt;pressed&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#released&quot;&gt;released&lt;/a&gt;(), and &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;clicked&lt;/a&gt;() signals will be emitted like in the normal case.</source>
          <target state="translated">참고 : 바로 가기 키로 버튼을 누르면이 클래스가 아닌 시스템에서 자동 반복이 활성화되고 시간이 설정됩니다. &lt;a href=&quot;qabstractbutton#pressed&quot;&gt;가압&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#released&quot;&gt;릴리스&lt;/a&gt; () 및 &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;클릭&lt;/a&gt; () 신호가 정상적인 경우와 같이 방출된다.</target>
        </trans-unit>
        <trans-unit id="2c18738c3b39ef8cd6ea1c3ce351d9c380c6102b" translate="yes" xml:space="preserve">
          <source>Note: If the directory is a symbolic link to the root directory this function returns &lt;code&gt;false&lt;/code&gt;. If you want to test for this use &lt;a href=&quot;qdir#canonicalPath&quot;&gt;canonicalPath&lt;/a&gt;(), e.g.</source>
          <target state="translated">참고 : 디렉토리가 루트 디렉토리에 대한 심볼릭 링크 인 경우이 함수는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 이 사용을 테스트하려면 &lt;a href=&quot;qdir#canonicalPath&quot;&gt;canonicalPath&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9c2f7cdfa370d2b0180cab8886c990fdc7cccff4" translate="yes" xml:space="preserve">
          <source>Note: If the valid range consists of just positive doubles (e.g. 0.0 to 100.0) and</source>
          <target state="translated">참고 : 유효한 범위가 양의 이중으로 구성되어있는 경우 (예 : 0.0 ~ 100.0)</target>
        </trans-unit>
        <trans-unit id="0ac47e48621687308848d598eae2e23e4886403c" translate="yes" xml:space="preserve">
          <source>Note: If the valid range consists of just positive doubles (e.g. 0.0 to 100.0) and input is a negative double then it is rejected. If &lt;a href=&quot;qml-qtquick-doublevalidator#notation-prop&quot;&gt;notation&lt;/a&gt; is set to &lt;a href=&quot;qml-qtquick-doublevalidator&quot;&gt;DoubleValidator&lt;/a&gt;.StandardNotation, and the input contains more digits before the decimal point than a double in the valid range may have, it is also rejected. If &lt;a href=&quot;qml-qtquick-doublevalidator#notation-prop&quot;&gt;notation&lt;/a&gt; is &lt;a href=&quot;qml-qtquick-doublevalidator&quot;&gt;DoubleValidator&lt;/a&gt;.ScientificNotation, and the input is not in the valid range, it is accecpted but invalid. The value may yet become valid by changing the exponent.</source>
          <target state="translated">참고 : 유효 범위가 포지티브 더블 (예 : 0.0 ~ 100.0)로 구성되고 입력이 네거티브 더블 인 경우 거부됩니다. 경우 &lt;a href=&quot;qml-qtquick-doublevalidator#notation-prop&quot;&gt;표기&lt;/a&gt; 로 설정 &lt;a href=&quot;qml-qtquick-doublevalidator&quot;&gt;DoubleValidator&lt;/a&gt; .StandardNotation, 입력이 가질 수있는 유효 범위의 두 배 이상 소수점 자리수 전에 더 포함 또한 거절된다. 경우 &lt;a href=&quot;qml-qtquick-doublevalidator#notation-prop&quot;&gt;표기법&lt;/a&gt; 입니다 &lt;a href=&quot;qml-qtquick-doublevalidator&quot;&gt;DoubleValidator&lt;/a&gt; .ScientificNotation, 입력이 유효한 범위에 있지, 그것은 accecpted하지만 잘못되었습니다. 지수를 변경하여 값이 아직 유효해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b48d6af8a062a0a6bb0e228959da3c163cf1ae0" translate="yes" xml:space="preserve">
          <source>Note: If you have set an external model on the combobox this model will still be cleared when calling this function.</source>
          <target state="translated">참고 : 콤보 박스에서 외부 모델을 설정 한 경우이 함수를 호출하면이 모델이 여전히 지워집니다.</target>
        </trans-unit>
        <trans-unit id="171e440d6d7d2bf25433698cfbf1fc1850eaeb98" translate="yes" xml:space="preserve">
          <source>Note: If you want to use the convenience views (like &lt;a href=&quot;qlistwidget&quot;&gt;QListWidget&lt;/a&gt;, &lt;a href=&quot;qtablewidget&quot;&gt;QTableWidget&lt;/a&gt; or &lt;a href=&quot;qtreewidget&quot;&gt;QTreeWidget&lt;/a&gt;), make sure to call &lt;a href=&quot;qcombobox#setModel&quot;&gt;setModel&lt;/a&gt;() on the combobox with the convenience widgets model before calling this function.</source>
          <target state="translated">참고 : 편의 뷰 ( &lt;a href=&quot;qlistwidget&quot;&gt;QListWidget&lt;/a&gt; , &lt;a href=&quot;qtablewidget&quot;&gt;QTableWidget&lt;/a&gt; 또는 &lt;a href=&quot;qtreewidget&quot;&gt;QTreeWidget 등&lt;/a&gt; )를 사용하려면 이 함수를 호출하기 전에 편의 위젯 모델을 사용하여 콤보 박스에서 &lt;a href=&quot;qcombobox#setModel&quot;&gt;setModel&lt;/a&gt; ()을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="2a445b8d9c852701207c6aa90e3c66647928b41b" translate="yes" xml:space="preserve">
          <source>Note: In &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit&lt;/a&gt; mode, already submitted changes won't be cleared from the cache when submitAll() fails. This allows transactions to be rolled back and resubmitted without losing data.</source>
          <target state="translated">참고 : &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit&lt;/a&gt; 모드 에서는 submitAll ()이 실패 할 때 이미 제출 된 변경 사항이 캐시에서 지워지지 않습니다. 이를 통해 데이터를 유실하지 않고 트랜잭션을 롤백하고 다시 제출할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1d9426751fbfe5cc063fa7e344f672a149716d7" translate="yes" xml:space="preserve">
          <source>Note: In other regexp documentation, sets of characters are often called &quot;character classes&quot;.</source>
          <target state="translated">참고 : 다른 regexp 문서에서 문자 세트를 종종 &quot;문자 클래스&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="5b754118d68f31118db820e9fad445f7dbe26f9d" translate="yes" xml:space="preserve">
          <source>Note: In this case, the &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; does not own the given</source>
          <target state="translated">참고 :이 경우 &lt;a href=&quot;qquickview&quot;&gt;QQuickView&lt;/a&gt; 는 지정된 것을 소유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f719ef71adc5a6d4d2d725af34752053d631f69b" translate="yes" xml:space="preserve">
          <source>Note: In this case, the &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; does not own the given</source>
          <target state="translated">참고 :이 경우 &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; 은 지정된 것을 소유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="148179dae7b711996dbc95957d0bd0794372aacc" translate="yes" xml:space="preserve">
          <source>Note: It can be useful to map the whole rectangle covered by the pixel at</source>
          <target state="translated">참고 : 픽셀로 덮여있는 전체 사각형을 매핑하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39e2aefa92fb04934c477094cea5764f2bd342dc" translate="yes" xml:space="preserve">
          <source>Note: On Mac OS/X, this function is not useful, because there is no way to get the scan code from Carbon or Cocoa. The function always returns 1 (or 0 in the case explained above).</source>
          <target state="translated">참고 : Mac OS / X에서는 Carbon 또는 Cocoa에서 스캔 코드를 가져올 방법이 없으므로이 기능은 유용하지 않습니다. 이 함수는 항상 1 (또는 위에서 설명한 경우 0)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d6bdf9dd483e6270c3661ed3603ded8ec6b55dfd" translate="yes" xml:space="preserve">
          <source>Note: On Windows, all '\n' characters are written as '\r\n' if &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt;'s device or string is opened using the &lt;a href=&quot;qiodevice#OpenModeFlag-enum&quot;&gt;QIODevice::Text&lt;/a&gt; flag.</source>
          <target state="translated">참고 : Windows에서 &lt;a href=&quot;qtextstream&quot;&gt;QIOStream &lt;/a&gt;&lt;a href=&quot;qiodevice#OpenModeFlag-enum&quot;&gt;:: Text&lt;/a&gt; 플래그를 사용하여 QTextStream 의 장치 또는 문자열을 열면 모든 '\ n'문자가 '\ r \ n'으로 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="73a102cf7f7ba7056ecc1316b29d20bf2980ab62" translate="yes" xml:space="preserve">
          <source>Note: Only loaded images can be painted on the Canvas item.</source>
          <target state="translated">참고 : 불러 온 이미지 만 캔버스 항목에 페인트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c26301c43160d0fc9db88954e0a281cf19a21bb" translate="yes" xml:space="preserve">
          <source>Note: Passing a</source>
          <target state="translated">참고 : 전달</target>
        </trans-unit>
        <trans-unit id="14552beb959cb14fb3667b85e1a0975fdd96f2d1" translate="yes" xml:space="preserve">
          <source>Note: Passing a negative duration as the</source>
          <target state="translated">참고 : 음수 지속 시간을</target>
        </trans-unit>
        <trans-unit id="aeb65c5d8f8f6d1a30b2c6404b995a75b9eee981" translate="yes" xml:space="preserve">
          <source>Note: Passing a negative number as the</source>
          <target state="translated">참고 : 음수를</target>
        </trans-unit>
        <trans-unit id="630014acec0bf249856e001f98d4a55129a5e774" translate="yes" xml:space="preserve">
          <source>Note: Quantifiers are normally &quot;greedy&quot;. They always match as much text as they can. For example, &lt;b&gt;0+&lt;/b&gt; matches the first zero it finds and all the consecutive zeros after the first zero. Applied to '20005', it matches '2&lt;u&gt;000&lt;/u&gt;5'. Quantifiers can be made non-greedy, see &lt;a href=&quot;qregexp#setMinimal&quot;&gt;setMinimal&lt;/a&gt;().</source>
          <target state="translated">참고 : 수량자는 일반적으로 &quot;욕심&quot;입니다. 그들은 항상 가능한 많은 텍스트를 찾습니다. 예를 들어, &lt;b&gt;0+&lt;/b&gt; 는 찾은 첫 번째 0과 첫 번째 0 이후의 모든 연속 0과 일치합니다. 응용은 '20005', 그것은 '2 일치 &lt;u&gt;000&lt;/u&gt; 5'. 정량 &lt;a href=&quot;qregexp#setMinimal&quot;&gt;자는&lt;/a&gt; 탐욕 스럽지 않게 만들 수 있습니다 . setMinimal ()을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b95774b08b2388e43f509b1489213d5f71a64e22" translate="yes" xml:space="preserve">
          <source>Note: See &lt;a href=&quot;qgraphicsscene#items&quot;&gt;items&lt;/a&gt;() for a definition of which items are considered visible by this function.</source>
          <target state="translated">참고 : 이 기능으로 볼 수있는 항목에 대한 정의는 &lt;a href=&quot;qgraphicsscene#items&quot;&gt;항목&lt;/a&gt; ()을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="95e2ccf507b324f5a38e492c35e67dba46ecc818" translate="yes" xml:space="preserve">
          <source>Note: Setting the default precision policy to</source>
          <target state="translated">참고 : 기본 정밀 정책을</target>
        </trans-unit>
        <trans-unit id="5114530e8b439a53c215fe396d4c6b06cfc2864c" translate="yes" xml:space="preserve">
          <source>Note: Setting the precision policy doesn't affect the currently active query. Call &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec&lt;/a&gt;(&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;) or &lt;a href=&quot;qsqlquery#prepare&quot;&gt;prepare&lt;/a&gt;() in order to activate the policy.</source>
          <target state="translated">참고 : 정밀 정책을 설정해도 현재 활성 쿼리에는 영향을 미치지 않습니다. 정책을 활성화하려면 &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec&lt;/a&gt; ( &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; )를 호출 하거나 &lt;a href=&quot;qsqlquery#prepare&quot;&gt;준비&lt;/a&gt; ()하십시오.</target>
        </trans-unit>
        <trans-unit id="c1bbfd21dce8ec6d77caaaefd84531fe0278c8ea" translate="yes" xml:space="preserve">
          <source>Note: Since Qt 4.2 the item delegates query the user property of widgets, and only call this function if the widget has no user property. You can override this behavior by reimplementing &lt;a href=&quot;qabstractitemdelegate#setModelData&quot;&gt;QAbstractItemDelegate::setModelData&lt;/a&gt;() and &lt;a href=&quot;qabstractitemdelegate#setEditorData&quot;&gt;QAbstractItemDelegate::setEditorData&lt;/a&gt;().</source>
          <target state="translated">참고 : Qt 4.2부터 항목 대리자는 위젯의 사용자 속성을 쿼리하고 위젯에 사용자 속성이없는 경우에만이 함수를 호출합니다. &lt;a href=&quot;qabstractitemdelegate#setModelData&quot;&gt;QAbstractItemDelegate :: setModelData&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemdelegate#setEditorData&quot;&gt;QAbstractItemDelegate :: setEditorData&lt;/a&gt; () 를 다시 구현하여이 동작을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad761a3041aed8940086c6a8f3c0154c3ae461f7" translate="yes" xml:space="preserve">
          <source>Note: Subclass implementations must call the base implementation of setUpdateInterval() so that updateInterval() returns the correct value.</source>
          <target state="translated">참고 : 서브 클래스 구현은 updateInterval ()이 올바른 값을 리턴하도록 setUpdateInterval ()의 기본 구현을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c3f9f99be97c24caab457ae61a468f4db1eaa08" translate="yes" xml:space="preserve">
          <source>Note: The</source>
          <target state="translated">참고 :</target>
        </trans-unit>
        <trans-unit id="a1516348cc8bab6b2fec5c09367d23c61b7664df" translate="yes" xml:space="preserve">
          <source>Note: The &lt;a href=&quot;qandroidjniobject&quot;&gt;QAndroidJniObject&lt;/a&gt; will create a new reference to the class</source>
          <target state="translated">참고 : &lt;a href=&quot;qandroidjniobject&quot;&gt;QAndroidJniObject&lt;/a&gt; 는 클래스에 대한 새로운 참조를 생성합니다</target>
        </trans-unit>
        <trans-unit id="79beb4ca2e5542606e776eb5cb0910209462770f" translate="yes" xml:space="preserve">
          <source>Note: The &lt;a href=&quot;qandroidjniobject&quot;&gt;QAndroidJniObject&lt;/a&gt; will hold a reference to the Java object</source>
          <target state="translated">참고 : &lt;a href=&quot;qandroidjniobject&quot;&gt;QAndroidJniObject&lt;/a&gt; 는 Java 객체에 대한 참조를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="4696b1155f2e2108a6249aea1f606afc48e15b2b" translate="yes" xml:space="preserve">
          <source>Note: The Places API considers content objects to be 'retrieve-only' objects. Submission of content to a provider is not a supported use case.</source>
          <target state="translated">참고 : Places API는 콘텐츠 개체를 '검색 전용'개체로 간주합니다. 공급자에게 콘텐츠를 제출하는 것은 지원되는 사용 사례가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6bcd7d2ca2dca375444d31cb042e9dbf50248762" translate="yes" xml:space="preserve">
          <source>Note: The Places API only supports editorials as 'retrieve-only' objects. Submitting editorials to a provider is not a supported use case.</source>
          <target state="translated">참고 : Places API는 '검색 전용'객체로 편집 만 지원합니다. 공급자에게 편집물을 제출하는 것은 지원되는 사용 사례가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="65b915fd425ca56977f3dcc5c34b98baa57fbac3" translate="yes" xml:space="preserve">
          <source>Note: The Places API only supports images as 'retrieve-only' objects. Submitting images to a provider is not a supported use case.</source>
          <target state="translated">참고 : Places API는 이미지를 '검색 전용'객체로만 지원합니다. 공급자에게 이미지를 제출하는 것은 지원되는 사용 사례가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9c8f14ae62dfa91b985ab5123e37f47f043c93d4" translate="yes" xml:space="preserve">
          <source>Note: The Places API only supports reviews as 'retrieve-only' objects. Submitting reviews to a provider is not a supported use case.</source>
          <target state="translated">참고 : Places API는 '검색 전용'개체로만 검토를 지원합니다. 공급자에게 리뷰를 제출하는 것은 지원되는 사용 사례가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9b56cb308cc2c0e4d0ea0bd30709ac127a822518" translate="yes" xml:space="preserve">
          <source>Note: The Places API only supports suppliers as 'retrieve-only' objects. Submitting suppliers to a provider is not a supported use case.</source>
          <target state="translated">참고 : Places API는 공급 업체 만 '검색 전용'객체로 지원합니다. 공급 업체에 공급 업체를 제출하는 것은 지원되는 사용 사례가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e86db8b9ac04af938f965ba16f93089f22762f61" translate="yes" xml:space="preserve">
          <source>Note: The actual behaviour if an overflow occurs is driver specific. The Oracle database just returns an error in this case.</source>
          <target state="translated">참고 : 오버플로가 발생할 경우 실제 동작은 드라이버마다 다릅니다. 이 경우 Oracle 데이터베이스는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0ab7b79e1f9a2ddec2fdb06eaa3b14f7b4328a47" translate="yes" xml:space="preserve">
          <source>Note: The empty (default) prefix is never included in this list; to check for the presence of a default namespace, call &lt;a href=&quot;qxmlnamespacesupport#uri&quot;&gt;uri&lt;/a&gt;() with &quot;&quot; as the argument.</source>
          <target state="translated">참고 : 비어있는 (기본) 접두사는이 목록에 포함되지 않습니다. 기본 네임 스페이스가 있는지 확인하려면 &quot;&quot;를 인수로 사용하여 &lt;a href=&quot;qxmlnamespacesupport#uri&quot;&gt;uri&lt;/a&gt; ()를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="8e227f0adddcc229f5176586bedcb57ada68d250" translate="yes" xml:space="preserve">
          <source>Note: The maximum and minimum values will be rounded to match the decimals property.</source>
          <target state="translated">참고 : 최대 값과 최소값은 소수 속성과 일치하도록 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="47301e6c49ee57a0fee090e4d52e916169d7707c" translate="yes" xml:space="preserve">
          <source>Note: The maximum value will be rounded to match the decimals property.</source>
          <target state="translated">참고 : 최대 값은 소수 속성과 일치하도록 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="5e7268ef6a20efb90b09064ed3f374023645a3f6" translate="yes" xml:space="preserve">
          <source>Note: The maximum, minimum and value might change as a result of changing this property.</source>
          <target state="translated">참고 :이 속성을 변경하면 최대 값, 최소값 및 값이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd4afcb854f418a9b88e824e9a6e9efb1fe757cb" translate="yes" xml:space="preserve">
          <source>Note: The minimum value will be rounded to match the decimals property.</source>
          <target state="translated">참고 : 최소값은 소수 속성과 일치하도록 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="1a1f5acb014e678d493d35fc841720eeb02fe4e3" translate="yes" xml:space="preserve">
          <source>Note: The native modifiers may be 0, even if the key event contains extended information.</source>
          <target state="translated">참고 : 키 이벤트에 확장 정보가 포함되어 있어도 기본 수정자는 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1eb8d2d5ec422275aec2de509bdada03cb2ad2b9" translate="yes" xml:space="preserve">
          <source>Note: The native scan code may be 0, even if the key event contains extended information.</source>
          <target state="translated">참고 : 키 이벤트에 확장 정보가 포함되어 있어도 기본 스캔 코드는 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d10827b158d22b580bf59a846fee4e9a366a4261" translate="yes" xml:space="preserve">
          <source>Note: The native virtual key may be 0, even if the key event contains extended information.</source>
          <target state="translated">참고 : 키 이벤트에 확장 정보가 포함되어 있어도 기본 가상 키는 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="907ba64e174a0575f21b9fa584b252518465f2c8" translate="yes" xml:space="preserve">
          <source>Note: The per-thread data stored is not deleted. Any data left in &lt;a href=&quot;qthreadstorage&quot;&gt;QThreadStorage&lt;/a&gt; is leaked. Make sure that all threads using &lt;a href=&quot;qthreadstorage&quot;&gt;QThreadStorage&lt;/a&gt; have exited before deleting the &lt;a href=&quot;qthreadstorage&quot;&gt;QThreadStorage&lt;/a&gt;.</source>
          <target state="translated">참고 : 저장된 스레드 별 데이터는 삭제되지 않습니다. &lt;a href=&quot;qthreadstorage&quot;&gt;QThreadStorage에&lt;/a&gt; 남아있는 모든 데이터 가 누출됩니다. 사용하는 모든 스레드가 있는지 확인 &lt;a href=&quot;qthreadstorage&quot;&gt;QThreadStorage이&lt;/a&gt; 삭제하기 전에 종료 한 &lt;a href=&quot;qthreadstorage&quot;&gt;QThreadStorage을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8299371722751a1e97afecc9d0d681bda59d4fd7" translate="yes" xml:space="preserve">
          <source>Note: The returned &lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt; object cannot be used from another thread.</source>
          <target state="translated">참고 : 리턴 된 &lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt; 오브젝트는 다른 스레드에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b353eb316210c871c2ffd9eb2e9b96e804de2e0" translate="yes" xml:space="preserve">
          <source>Note: The table's primary key may not contain a relation to another table.</source>
          <target state="translated">참고 : 테이블의 기본 키에는 다른 테이블과의 관계가 포함되어 있지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3840dc20cfd5fdc07ea5d746ae2f42e58bf0d0e3" translate="yes" xml:space="preserve">
          <source>Note: The use of &lt;a href=&quot;qdir#Q_INIT_RESOURCE&quot;&gt;Q_INIT_RESOURCE&lt;/a&gt;() and &lt;a href=&quot;qdir#Q_CLEANUP_RESOURCE&quot;&gt;Q_CLEANUP_RESOURCE&lt;/a&gt;() is not necessary when the resource is built as part of the application.</source>
          <target state="translated">참고 : 자원이 애플리케이션의 일부로 빌드 될 때는 &lt;a href=&quot;qdir#Q_INIT_RESOURCE&quot;&gt;Q_INIT_RESOURCE&lt;/a&gt; () 및 &lt;a href=&quot;qdir#Q_CLEANUP_RESOURCE&quot;&gt;Q_CLEANUP_RESOURCE&lt;/a&gt; ()를 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec2f1091c5560a3634fa246cf7b1ce10e45a51be" translate="yes" xml:space="preserve">
          <source>Note: The value will be rounded so it can be displayed with the current setting of decimals.</source>
          <target state="translated">참고 : 값은 반올림되므로 현재 10 진수 설정으로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5231075cd422ce6151d27df74d445e82000bbb1a" translate="yes" xml:space="preserve">
          <source>Note: There are different date formats with different understandings of negative years. Common human language does not have a year 0. The year after 1BC is 1AD. This understanding is reflected when printing or parsing dates in one of the formats not standardized by ECMAScript. That is: toString(), &lt;a href=&quot;qml-qtqml-date#toLocaleString-method&quot;&gt;toLocaleString()&lt;/a&gt;, toUTCString() and friends. ECMAScript does standardize one format: ISO 8601. This is what you get when you call toISOString(). This format does include a year 0, which is 1BC in other formats. Thus you get different years when printing negative dates with toISOString() and toString().</source>
          <target state="translated">참고 : 음의 연도에 대한 이해가 다른 날짜 형식이 있습니다. 일반적인 휴먼 랭귀지에는 0 년이 없습니다. 1BC 이후 1AD는 1AD입니다. ECMAScript에서 표준화하지 않은 형식 중 하나로 날짜를 인쇄하거나 구문 분석 할 때 이러한 이해가 반영됩니다. 즉 : toString (), &lt;a href=&quot;qml-qtqml-date#toLocaleString-method&quot;&gt;toLocaleString ()&lt;/a&gt; , toUTCString () 및 친구들입니다. ECMAScript는 ISO 8601 형식을 표준화합니다. ISOString ()을 호출하면 얻을 수있는 것입니다. 이 형식에는 연도 0이 포함되며 다른 형식에서는 1BC입니다. 따라서 toISOString () 및 toString ()을 사용하여 음수 날짜를 인쇄하면 연도가 달라집니다.</target>
        </trans-unit>
        <trans-unit id="4e7cfff4dd81ab1993ad11501200382a59be3a1c" translate="yes" xml:space="preserve">
          <source>Note: There is no way for the view to know that the contents of a &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; has changed. If the &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; changes, it is necessary to reset the model by calling &lt;a href=&quot;qqmlcontext#setContextProperty&quot;&gt;QQmlContext::setContextProperty&lt;/a&gt;() again.</source>
          <target state="translated">참고 : 뷰가 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; 의 내용 이 변경 되었음을 알 수있는 방법이 없습니다 . 는 IF &lt;a href=&quot;qlist&quot;&gt;QList이&lt;/a&gt; 변경, 호출하여 모델을 재설정 할 필요가 &lt;a href=&quot;qqmlcontext#setContextProperty&quot;&gt;QQmlContext :: setContextProperty를&lt;/a&gt; ()를 다시.</target>
        </trans-unit>
        <trans-unit id="97feade5825fbdbeff72e97cf8288957cdc5678f" translate="yes" xml:space="preserve">
          <source>Note: This function can be called anytime before &lt;a href=&quot;qaudioinput#start-1&quot;&gt;start&lt;/a&gt;(), calls to this are ignored after &lt;a href=&quot;qaudioinput#start-1&quot;&gt;start&lt;/a&gt;(). It should not be assumed that the buffer size set is the actual buffer size used, calling &lt;a href=&quot;qaudioinput#bufferSize&quot;&gt;bufferSize&lt;/a&gt;() anytime after &lt;a href=&quot;qaudioinput#start-1&quot;&gt;start&lt;/a&gt;() will return the actual buffer size being used.</source>
          <target state="translated">참고 :이 기능은 언제 전에 호출 할 수 있습니다 &lt;a href=&quot;qaudioinput#start-1&quot;&gt;시작&lt;/a&gt; ()이 호출이 후 무시됩니다 &lt;a href=&quot;qaudioinput#start-1&quot;&gt;시작&lt;/a&gt; (). 버퍼 크기 세트가 사용 된 실제 버퍼 크기라고 가정해서는 안되며 &lt;a href=&quot;qaudioinput#start-1&quot;&gt;start&lt;/a&gt; () 이후에 &lt;a href=&quot;qaudioinput#bufferSize&quot;&gt;bufferSize&lt;/a&gt; ()를 호출 하면 사용중인 실제 버퍼 크기가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="eb4ccaa0bae3191f3c09c1335517de218b6fb82c" translate="yes" xml:space="preserve">
          <source>Note: This function is not reentrant, only one test can run at a time. A test that was executed with qExec() can't run another test via qExec() and threads are not allowed to call qExec() simultaneously.</source>
          <target state="translated">참고 :이 기능은 재진입 할 ​​수 없으며 한 번에 하나의 테스트 만 실행할 수 있습니다. qExec ()로 실행 된 테스트는 qExec ()를 통해 다른 테스트를 실행할 수 없으며 스레드는 qExec ()를 동시에 호출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f30873e34cf4608d4535f9d1f95d913d3a97ae7c" translate="yes" xml:space="preserve">
          <source>Note: This function returns true even if the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; that this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; wraps has been deleted.</source>
          <target state="translated">참고 :이 함수는 이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue가&lt;/a&gt; 랩핑 한 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 가 삭제 된 경우에도 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="7165b39115966b2b555efbbb37e2bec9cb2a0687" translate="yes" xml:space="preserve">
          <source>Note: This is not intended to prevent overwriting of items. The model's implementation of flags() should do that by not returning &lt;a href=&quot;qt#ItemFlag-enum&quot;&gt;Qt::ItemIsDropEnabled&lt;/a&gt;.</source>
          <target state="translated">참고 : 이것은 항목 덮어 쓰기를 방지하기위한 것이 아닙니다. 모델의 flags () 구현은 &lt;a href=&quot;qt#ItemFlag-enum&quot;&gt;Qt :: ItemIsDropEnabled를&lt;/a&gt; 반환하지 않음으로써 그렇게해야합니다 .</target>
        </trans-unit>
        <trans-unit id="080c7cf7c251021d23858c561c9e995b1d687906" translate="yes" xml:space="preserve">
          <source>Note: This is platform specific</source>
          <target state="translated">참고 : 이것은 플랫폼에 따라 다릅니다</target>
        </trans-unit>
        <trans-unit id="e901b4e31ede36978c043da18eac84ec3d00d209" translate="yes" xml:space="preserve">
          <source>Note: This is the recommended read size in bytes.</source>
          <target state="translated">참고 : 권장되는 읽기 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="eb95e5137414e58398235720b280de0af028b4ba" translate="yes" xml:space="preserve">
          <source>Note: This macro cannot be used in a namespace. It should be called from main(). If that is not possible, the following workaround can be used to init the resource &lt;code&gt;myapp&lt;/code&gt; from the function &lt;code&gt;MyNamespace::myFunction&lt;/code&gt;:</source>
          <target state="translated">참고 :이 매크로는 네임 스페이스에서 사용할 수 없습니다. main ()에서 호출해야합니다. 이것이 가능하지 않은 경우 다음 해결 방법을 사용하여 &lt;code&gt;MyNamespace::myFunction&lt;/code&gt; 함수에서 &lt;code&gt;myapp&lt;/code&gt; 자원을 초기화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50494017012c56e4e4ab7a8894682a95d9e9590d" translate="yes" xml:space="preserve">
          <source>Note: This macro cannot be used in a namespace. Please see the &lt;a href=&quot;qdir#Q_INIT_RESOURCE&quot;&gt;Q_INIT_RESOURCE&lt;/a&gt; documentation for a workaround.</source>
          <target state="translated">참고 :이 매크로는 네임 스페이스에서 사용할 수 없습니다. 해결 방법 은 &lt;a href=&quot;qdir#Q_INIT_RESOURCE&quot;&gt;Q_INIT_RESOURCE&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f83db0c7f230e3d8ae99d9afba3bb1040e862518" translate="yes" xml:space="preserve">
          <source>Note: This method should have been called &quot;safePrepare()&quot;.</source>
          <target state="translated">참고 :이 메소드는 &quot;safePrepare ()&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="ee0c7780e8b10d097a2d5158c34d5954a87f3561" translate="yes" xml:space="preserve">
          <source>Note: This property makes most sense for sliders and dials. For scroll bars, the visual effect of the scroll bar subcontrols depends on whether or not the styles understand inverted appearance; most styles ignore this property for scroll bars.</source>
          <target state="translated">참고 :이 속성은 슬라이더와 다이얼에 가장 적합합니다. 스크롤 막대의 경우 스크롤 막대 하위 컨트롤의 시각적 효과는 스타일이 반전 된 모양을 이해하는지 여부에 따라 다릅니다. 대부분의 스타일은 스크롤 막대에 대해이 속성을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="f919932338ca62061eae222d54e731bb1bcd6e84" translate="yes" xml:space="preserve">
          <source>Note: This signal will still be emitted in a case where part of the text is accepted but not all of it is. For example, if there is a maximum length set and the clipboard text is longer than the maximum length when it is pasted.</source>
          <target state="translated">참고 :이 신호는 텍스트의 일부는 받아 들여지지 만 일부는 받아 들여지지 않는 경우에도 계속 방출됩니다. 예를 들어, 최대 길이가 설정되어 있고 클립 보드 텍스트가 붙여 넣을 때 최대 길이보다 긴 경우.</target>
        </trans-unit>
        <trans-unit id="1e882cd8a54a25ea565a9e033d4b6a5c0da2f550" translate="yes" xml:space="preserve">
          <source>Note: To prevent inserting only partly initialized rows into the database, &lt;code&gt;OnFieldChange&lt;/code&gt; will behave like &lt;code&gt;OnRowChange&lt;/code&gt; for newly inserted rows.</source>
          <target state="translated">참고 : 데이터베이스에 부분적으로 만 초기화 행을 삽입 방지하려면, &lt;code&gt;OnFieldChange&lt;/code&gt; 는 같이 행동한다 &lt;code&gt;OnRowChange&lt;/code&gt; 새로 삽입 된 행에 대해.</target>
        </trans-unit>
        <trans-unit id="bd6b357731ba6aaa973da2813d4a32eb08e989e0" translate="yes" xml:space="preserve">
          <source>Note: Unlike the &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt;, the Canvas API uses the winding fill as the default fill rule. The fillRule property is part of the context rendering state.</source>
          <target state="translated">참고 : &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt; 와 달리 Canvas API는 와인딩 채우기를 기본 채우기 규칙으로 사용합니다. fillRule 속성은 컨텍스트 렌더링 상태의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="ca99011da016b46a9b5232cf15f94cf491807369" translate="yes" xml:space="preserve">
          <source>Note: Using the locale-aware functions to perform date or time formatting can result in incorrectly formatted times, due to an inconsistency in specification between Qt and JS. ECMA-262 specifies that historical dates should be intrepreted by projecting the current rules for daylight-saving onto past years, while Qt uses historical data (where available) to determine whether daylight-saving was in effect for a given date. Therefore, constructing a Date value in JS and converting it to a string using the locale-aware functions can yield a result incorrect by one hour, if DST is currently in effect, while it was not for the time specified, or vice versa.</source>
          <target state="translated">참고 : 로케일 인식 기능을 사용하여 날짜 또는 시간 형식을 수행하면 Qt와 JS의 사양이 일치하지 않아서 형식이 잘못 지정된 시간이 발생할 수 있습니다. ECMA-262는 일광 절약 시간제에 대한 현재 규칙을 지난 몇 년 동안 투영하여 과거 날짜를 해석하지 않도록 지정하고 Qt는 과거 데이터 (사용 가능한 경우)를 사용하여 지정된 날짜에 일광 절약 효과가 적용되는지 여부를 결정합니다. 따라서 JS에서 Date 값을 구성하고 로케일 인식 함수를 사용하여 문자열로 변환하면 DST가 현재 적용되어 있고 지정된 시간이 아니거나 그 반대 인 경우 1 시간이 지나서 결과가 잘못 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="862dcd96643b4ef94796f1175f6a5ce36da56b6a" translate="yes" xml:space="preserve">
          <source>Note: You should use &lt;a href=&quot;qaction#visible-prop&quot;&gt;QAction::setVisible&lt;/a&gt;() to change the visibility of the widget. Using &lt;a href=&quot;qwidget#visible-prop&quot;&gt;QWidget::setVisible&lt;/a&gt;(), &lt;a href=&quot;qwidget#show&quot;&gt;QWidget::show&lt;/a&gt;() and &lt;a href=&quot;qwidget#hide&quot;&gt;QWidget::hide&lt;/a&gt;() does not work.</source>
          <target state="translated">참고 : 위젯의 가시성을 변경 하려면 &lt;a href=&quot;qaction#visible-prop&quot;&gt;QAction :: setVisible&lt;/a&gt; ()을 사용해야합니다 . &lt;a href=&quot;qwidget#visible-prop&quot;&gt;QWidget :: setVisible&lt;/a&gt; ()을 사용하면 QWidget :: &lt;a href=&quot;qwidget#show&quot;&gt;show&lt;/a&gt; () 및 &lt;a href=&quot;qwidget#hide&quot;&gt;QWidget :: hide&lt;/a&gt; ()가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95b923e4c210c7f9aaed196d6d6837c7d0e73a22" translate="yes" xml:space="preserve">
          <source>Note: because C++ transforms \'s they must be written</source>
          <target state="translated">참고 : C ++는 \를 변환하므로 반드시 작성해야합니다</target>
        </trans-unit>
        <trans-unit id="68e1985ed0edc769c4c732a0346fbdd01601ce55" translate="yes" xml:space="preserve">
          <source>Note: calling this method will force painting the whole canvas, not just the current canvas visible window.</source>
          <target state="translated">참고 :이 메소드를 호출하면 현재 캔버스 표시 창뿐만 아니라 전체 캔버스를 강제로 페인팅합니다.</target>
        </trans-unit>
        <trans-unit id="ac849d8583ef5be2d44dfa3ef506e19e3b6eef7f" translate="yes" xml:space="preserve">
          <source>Note: components derived from &lt;a href=&quot;qml-qt3d-render-abstractraycaster&quot;&gt;AbstractRayCaster&lt;/a&gt; should not be shared amount multiple entities.</source>
          <target state="translated">참고 : &lt;a href=&quot;qml-qt3d-render-abstractraycaster&quot;&gt;AbstractRayCaster&lt;/a&gt; 에서 파생 된 구성 요소 는 여러 개체를 공유 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a402f2f8e3f820595297f1a03a1b19f79e568af" translate="yes" xml:space="preserve">
          <source>Note: do not delete the pointer returned by this function or pass it to another function that could delete it, including creating &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; or &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; objects.</source>
          <target state="translated">참고 : &lt;a href=&quot;qsharedpointer&quot;&gt;QSharedPointer&lt;/a&gt; 또는 &lt;a href=&quot;qweakpointer&quot;&gt;QWeakPointer&lt;/a&gt; 오브젝트 작성을 포함하여이 함수가 리턴 한 포인터를 삭제하거나 삭제할 수있는 다른 함수로 전달하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="52c2b4ac15d8b9b4a612f76f51386d8066e7c7b1" translate="yes" xml:space="preserve">
          <source>Note: do not subclass &lt;a href=&quot;qdbuscontext&quot;&gt;QDBusContext&lt;/a&gt; and &lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt; at the same time. &lt;a href=&quot;qdbuscontext&quot;&gt;QDBusContext&lt;/a&gt; should appear in the real object, not the adaptor. If it's necessary from the adaptor code to determine the context, use a public inheritance and access the functions via &lt;a href=&quot;qobject#parent&quot;&gt;QObject::parent&lt;/a&gt;().</source>
          <target state="translated">참고 : &lt;a href=&quot;qdbuscontext&quot;&gt;QDBusContext&lt;/a&gt; 및 &lt;a href=&quot;qdbusabstractadaptor&quot;&gt;QDBusAbstractAdaptor&lt;/a&gt; 를 동시에 서브 클래스하지 마십시오 . &lt;a href=&quot;qdbuscontext&quot;&gt;QDBusContext&lt;/a&gt; 는 어댑터가 아닌 실제 객체에 나타나야합니다. 컨텍스트를 판별하기 위해 어댑터 코드에서 필요한 경우 공용 상속을 사용하고 &lt;a href=&quot;qobject#parent&quot;&gt;QObject :: parent&lt;/a&gt; () 를 통해 함수에 액세스하십시오 .</target>
        </trans-unit>
        <trans-unit id="b265356b6831e6a9e72c3cdb38e5b285251f0d57" translate="yes" xml:space="preserve">
          <source>Note: if &lt;a href=&quot;qprocess#setProcessChannelMode&quot;&gt;setProcessChannelMode&lt;/a&gt;() was called with an argument of &lt;a href=&quot;qprocess#ProcessChannelMode-enum&quot;&gt;QProcess::MergedChannels&lt;/a&gt;, this function has no effect.</source>
          <target state="translated">참고 : &lt;a href=&quot;qprocess#ProcessChannelMode-enum&quot;&gt;QProcess :: MergedChannels&lt;/a&gt; 의 인수로 &lt;a href=&quot;qprocess#setProcessChannelMode&quot;&gt;setProcessChannelMode&lt;/a&gt; ()를 호출 한 경우이 함수는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff6c801fb5ecd2c86ff89caf02a8dc54b4757713" translate="yes" xml:space="preserve">
          <source>Note: if the path component of this URL contains a non-UTF-8 binary sequence (such as %80), the behaviour of this function is undefined.</source>
          <target state="translated">참고 :이 URL의 경로 구성 요소에 비 UTF-8 이진 시퀀스 (예 : % 80)가 포함 된 경우이 함수의 동작은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f61abd2e1b79ab02fae5fe0ef0b76f6dc36d1779" translate="yes" xml:space="preserve">
          <source>Note: returned value is only valid while in &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio::ActiveState&lt;/a&gt; or &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio::IdleState&lt;/a&gt; state, otherwise returns zero.</source>
          <target state="translated">참고 : 반환 된 값은 &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio :: ActiveState&lt;/a&gt; 또는 &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio :: IdleState&lt;/a&gt; 상태에있는 동안에 만 유효하며 , 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b7d3e3f2e581cfd40fa99cf21129360424a976e" translate="yes" xml:space="preserve">
          <source>Note: setting the drag cursor for IgnoreAction may not work on all platforms. X11 and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; has been tested to work. Windows does not support it.</source>
          <target state="translated">참고 : IgnoreAction에 대해 드래그 커서를 설정하면 일부 플랫폼에서 작동하지 않을 수 있습니다. X11 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 가 작동하도록 테스트되었습니다. Windows는이를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f915849c9d13bb240cbebb2628a205376dcb32a1" translate="yes" xml:space="preserve">
          <source>Note: the &lt;a href=&quot;qt#Axis-enum&quot;&gt;Qt::YAxis&lt;/a&gt; rotation for &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; is inverted from the correct mathematical rotation in 3D space. The &lt;a href=&quot;qgraphicsrotation&quot;&gt;QGraphicsRotation&lt;/a&gt; class implements a correct mathematical rotation. The following two sequences of code will perform the same transformation:</source>
          <target state="translated">참고 : &lt;a href=&quot;qt#Axis-enum&quot;&gt;Qt는 : y 축에&lt;/a&gt; 대한 회전 &lt;a href=&quot;qtransform&quot;&gt;QTransform는&lt;/a&gt; 3D 공간에서 올바른 수학 회전이 반전됩니다. &lt;a href=&quot;qgraphicsrotation&quot;&gt;QGraphicsRotation의&lt;/a&gt; 클래스는 올바른 수학 회전을 구현합니다. 다음 두 코드 시퀀스는 동일한 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a4fa48ad1e947bc059c3be6c49b0537fe933921d" translate="yes" xml:space="preserve">
          <source>Note: the coordinates will be used for every available render surface as long as they are in the valid range.</source>
          <target state="translated">참고 : 좌표는 유효한 범위에있는 한 사용 가능한 모든 렌더 표면에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="76e45982cb3ecdf2cf3c580a6a13f2bd7e245b20" translate="yes" xml:space="preserve">
          <source>Note: the final rotation is the combined effect of a rotation in 3D space followed by a projection back to 2D. If several rotations are performed in succession, they will not behave as expected unless they were all around the Z axis.</source>
          <target state="translated">참고 : 최종 회전은 3D 공간에서의 회전과 2D 로의 투영의 결합 효과입니다. 여러 회전이 연속적으로 수행되면 모두 Z 축 주위에 있지 않으면 예상대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="65876d2ebdc6e5f946603197c0f002209a34cb54" translate="yes" xml:space="preserve">
          <source>Note: the string is not translated. Applications whose interface allow users to parse CBOR streams need to provide their own, translated strings.</source>
          <target state="translated">참고 : 문자열은 번역되지 않습니다. 사용자가 CBOR 스트림을 구문 분석 할 수있는 인터페이스를 가진 응용 프로그램은 번역 된 고유 한 문자열을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="da29b558e382c1e29c7dacdb12ab54b89d89cfaf" translate="yes" xml:space="preserve">
          <source>Note: the template type &lt;code&gt;X&lt;/code&gt; must have the same const and volatile qualifiers as the template of this object, or the cast will fail. Use &lt;a href=&quot;qsharedpointer#constCast&quot;&gt;constCast&lt;/a&gt;() if you need to drop those qualifiers.</source>
          <target state="translated">참고 : 템플릿 유형 &lt;code&gt;X&lt;/code&gt; 에는이 객체의 템플릿과 동일한 const 및 volatile 한정자가 있어야합니다. 그렇지 않으면 캐스트가 실패합니다. 한정자를 삭제해야 할 경우 &lt;a href=&quot;qsharedpointer#constCast&quot;&gt;constCast&lt;/a&gt; ()를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="26ce4a9840bd1302d0e81dffaf937801009bb77a" translate="yes" xml:space="preserve">
          <source>Note: there will always be an &lt;a href=&quot;qml-qtaudioengine-audiocategory&quot;&gt;AudioCategory&lt;/a&gt; named &lt;code&gt;default&lt;/code&gt; whether you explicitly define it or not. If you do not specify any category for a &lt;a href=&quot;qml-qtaudioengine-sound&quot;&gt;Sound&lt;/a&gt;, it will be grouped into the &lt;code&gt;default&lt;/code&gt; category.</source>
          <target state="translated">참고 : 항상있을 것 &lt;a href=&quot;qml-qtaudioengine-audiocategory&quot;&gt;AudioCategory&lt;/a&gt; 라는 이름의 &lt;code&gt;default&lt;/code&gt; 당신이 명시 적으로 정의 여부. &lt;a href=&quot;qml-qtaudioengine-sound&quot;&gt;Sound에&lt;/a&gt; 카테고리를 지정하지 않으면 &lt;code&gt;default&lt;/code&gt; 카테고리 로 그룹화됩니다 .</target>
        </trans-unit>
        <trans-unit id="c305bdfff93445e8350fe38014a65da155a61aeb" translate="yes" xml:space="preserve">
          <source>Note: this constructor just creates the &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt; instance. The actual buffer object in the OpenGL server is not created until &lt;a href=&quot;qopenglbuffer#create&quot;&gt;create&lt;/a&gt;() is called.</source>
          <target state="translated">참고 :이 생성자는 &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt; 인스턴스를 작성합니다 . &lt;a href=&quot;qopenglbuffer#create&quot;&gt;create&lt;/a&gt; ()가 호출 될 때까지 OpenGL 서버의 실제 버퍼 객체가 생성되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8404a546af066ec1dcae4433df2a21d1b5b1bf4b" translate="yes" xml:space="preserve">
          <source>Note: this function is meant for removing a small application-internal directory (such as a temporary directory), but not user-visible directories. For user-visible operations, it is rather recommended to report errors more precisely to the user, to offer solutions in case of errors, to show progress during the deletion since it could take several minutes, etc.</source>
          <target state="translated">참고 :이 기능은 작은 응용 프로그램 내부 디렉토리 (예 : 임시 디렉토리)는 제거하지만 사용자가 볼 수있는 디렉토리는 제거하지 않습니다. 사용자가 볼 수있는 작업의 경우 오류를보다 정확하게 사용자에게보고하고, 오류가 발생한 경우 솔루션을 제공하고, 삭제하는 동안 몇 분 정도 걸릴 수 있으므로 삭제 진행률을 표시하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6653079f1063115d641ace31d88de930c5be9ed8" translate="yes" xml:space="preserve">
          <source>Note: this function was part of Qt 3 support in Qt 4.6 and earlier. It has been promoted to official API status in 4.7 to support updating the pixmap's image without creating a new &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; as &lt;a href=&quot;qpixmap#fromImage&quot;&gt;fromImage&lt;/a&gt;() would.</source>
          <target state="translated">참고 :이 기능은 Qt 4.6 이하에서 Qt 3 지원의 일부였습니다. &lt;a href=&quot;qpixmap#fromImage&quot;&gt;fromImage&lt;/a&gt; ()에서 와 같이 새로운 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 을 만들지 않고 pixmap의 이미지 업데이트를 지원하기 위해 4.7에서 공식 API 상태로 승격되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7f678a24fcf808a6ae45cd174af7bd26f1c80475" translate="yes" xml:space="preserve">
          <source>Note: this is not the same as the &lt;a href=&quot;qvector3d#crossProduct&quot;&gt;crossProduct&lt;/a&gt;() of</source>
          <target state="translated">참고 : 이것은 &lt;a href=&quot;qvector3d#crossProduct&quot;&gt;교차 제품&lt;/a&gt; ()과 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6f6e924b699f7006065e1ff6b3e043c83dc9052" translate="yes" xml:space="preserve">
          <source>Note: this is not the same as the &lt;a href=&quot;qvector3d#crossProduct&quot;&gt;crossProduct&lt;/a&gt;() of this vector and</source>
          <target state="translated">참고 : 이것은 이 벡터 의 &lt;a href=&quot;qvector3d#crossProduct&quot;&gt;crossProduct&lt;/a&gt; () 와 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32a63c72a58db3c866295ae3e78a540e25076793" translate="yes" xml:space="preserve">
          <source>Note: this method may be called by multiple threads, so ensure the implementation of this method is reentrant.</source>
          <target state="translated">참고 :이 메소드는 여러 스레드에서 호출 할 수 있으므로이 메소드의 구현이 재진입되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="14272495586217615cc25adeab4b04ae9a865953" translate="yes" xml:space="preserve">
          <source>Note: this method returns true only for elements that can be rendered. Which implies that elements that are considered part of the fill/stroke style properties, e.g. radialGradients even tough marked with &quot;id&quot; attributes will not be found by this method.</source>
          <target state="translated">참고 :이 메서드는 렌더링 할 수있는 요소에 대해서만 true를 반환합니다. 이는 채우기 / 획 스타일 속성의 일부로 간주되는 요소, 예를 들어 &quot;id&quot;속성으로 표시된 방사형 그라디언트는이 방법으로 찾을 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d2df7ff48333ab0e5ac40d21cc942342ad585da5" translate="yes" xml:space="preserve">
          <source>Note: this property's changed() signal is currently emitted only if the whole object changes, not if only the contents of the object change.</source>
          <target state="translated">참고 :이 속성의 changed () 신호는 현재 객체의 내용 만 변경되는 것이 아니라 전체 객체가 변경되는 경우에만 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="7a0b92f2bf074539fdba05ade552b7bd53ca85ff" translate="yes" xml:space="preserve">
          <source>Note: to check for a default prefix, use the &lt;a href=&quot;qxmlnamespacesupport#uri&quot;&gt;uri&lt;/a&gt;() function with an argument of &quot;&quot;.</source>
          <target state="translated">참고 : 기본 접두사를 확인하려면 &lt;a href=&quot;qxmlnamespacesupport#uri&quot;&gt;uri&lt;/a&gt; () 함수를 인수 &quot;&quot;와 함께 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="14ec88f8d6a68fdf9b6f6991bc8d60e334c60463" translate="yes" xml:space="preserve">
          <source>Note: when dealing with remote objects, it is not always possible to determine if it exists when creating a &lt;a href=&quot;qdbusinterface&quot;&gt;QDBusInterface&lt;/a&gt;.</source>
          <target state="translated">참고 : 원격 오브젝트를 처리 할 때 &lt;a href=&quot;qdbusinterface&quot;&gt;QDBusInterface를&lt;/a&gt; 작성할 때 존재하는지 여부를 항상 판별 할 수있는 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="2d608877188f5242e67358cea581b38a5a3bfa95" translate="yes" xml:space="preserve">
          <source>Note:An animation controlled by &lt;a href=&quot;qml-qtquick-animationcontroller&quot;&gt;AnimationController&lt;/a&gt; will always have its &lt;code&gt;running&lt;/code&gt; and &lt;code&gt;paused&lt;/code&gt; properties set to true. It can not be manually started or stopped (much like an animation in a Behavior can not be manually started or stopped).</source>
          <target state="translated">참고 : &lt;a href=&quot;qml-qtquick-animationcontroller&quot;&gt;AnimationController로&lt;/a&gt; 제어되는 애니메이션 은 항상 &lt;code&gt;running&lt;/code&gt; 및 &lt;code&gt;paused&lt;/code&gt; 속성이 true로 설정됩니다. 동작의 애니메이션을 수동으로 시작하거나 중지 할 수없는 것처럼 수동으로 시작하거나 중지 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="b374c1b47330d231078bb4413a030c5c6e9f5525" translate="yes" xml:space="preserve">
          <source>Notes for Perl Users</source>
          <target state="translated">Perl 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="4154d75f46826d0d055fd5241282b19935616711" translate="yes" xml:space="preserve">
          <source>Notes for QRegExp Users</source>
          <target state="translated">QRegExp 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="932b4cd8d94de09811f785619b04c9d56612ff6d" translate="yes" xml:space="preserve">
          <source>Notes for Universal Windows Platform Users</source>
          <target state="translated">Universal Windows 플랫폼 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="9128e4dc19fdcbce3767684f6724986d863634bf" translate="yes" xml:space="preserve">
          <source>Notes for Windows Users</source>
          <target state="translated">Windows 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="f8065561874bdf8cf5ca3acfd4a06a024ed512b7" translate="yes" xml:space="preserve">
          <source>Notes for Windows and macOS Users</source>
          <target state="translated">Windows 및 macOS 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="15e123abf3898680713e4321c628318d06dc6f4e" translate="yes" xml:space="preserve">
          <source>Notes for X11 Users</source>
          <target state="translated">X11 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="f5895a8c3ecb8567fef9e814c81890589257c61a" translate="yes" xml:space="preserve">
          <source>Notes for macOS Users</source>
          <target state="translated">macOS 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="2b580f8081df45d58ecf613f9b4e7ae11540fec7" translate="yes" xml:space="preserve">
          <source>Notes on Locale</source>
          <target state="translated">로캘에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="f038ea8701df29241a73c1e6e1de3fee1570e938" translate="yes" xml:space="preserve">
          <source>Notes on Possible Issues</source>
          <target state="translated">가능한 문제에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="171ac5a3205710042a8cbb0da69a3c49668788cb" translate="yes" xml:space="preserve">
          <source>Notes on Qt Classes</source>
          <target state="translated">Qt 클래스에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="74d47d24cb761b24134a09fda747ebc80ed57f58" translate="yes" xml:space="preserve">
          <source>Notes on Use of Notify Signals</source>
          <target state="translated">알림 신호 사용에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="026124a1f897d289b0c34a8914fc074da1fea84b" translate="yes" xml:space="preserve">
          <source>Notes on the &lt;code&gt;domXml()&lt;/code&gt; Function</source>
          <target state="translated">&lt;code&gt;domXml()&lt;/code&gt; 함수 에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="15a36c675a3fd9923d39fae085bf5c897edc8d7d" translate="yes" xml:space="preserve">
          <source>Notes to Desktop Users</source>
          <target state="translated">데스크톱 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="4481948392a8846400c954e77f58d76cdaa73963" translate="yes" xml:space="preserve">
          <source>Nothing</source>
          <target state="translated">Nothing</target>
        </trans-unit>
        <trans-unit id="b0aa33f02aefe3d763eef2da98aa3d318eb7e0ef" translate="yes" xml:space="preserve">
          <source>Nothing done yet.</source>
          <target state="translated">아직 아무것도하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="87bf71867fcaeaada1d0e2d72f0b00dce542f8de" translate="yes" xml:space="preserve">
          <source>Nothing happens; the mouse event is ignored.</source>
          <target state="translated">아무 반응이 없습니다; 마우스 이벤트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c7ec4abc840bf0e4b54c1deb9d38f9a5936d7d35" translate="yes" xml:space="preserve">
          <source>Notice how the default value is now specified in the persistent setting property, and the actual property is bound to the setting in order to get the initial value from the persistent settings.</source>
          <target state="translated">지속 설정 속성에서 기본값이 어떻게 지정되는지, 지속 설정에서 초기 값을 얻기 위해 실제 속성이 설정에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="acfeb5f715ee7224660bc8e6fae8823708d439b7" translate="yes" xml:space="preserve">
          <source>Notice how the sizes of the page items are set by hand. This is because the example uses a plain Container, which does not make any assumptions on the visual layout. It is typically not necessary to specify sizes for items in concrete Container implementations, such as &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt; and &lt;a href=&quot;qtquickcontrols2-navigation#tabbar&quot;&gt;TabBar&lt;/a&gt;.</source>
          <target state="translated">페이지 항목의 크기가 수동으로 어떻게 설정되는지 확인하십시오. 이는 예제가 일반 컨테이너를 사용하기 때문에 시각적 레이아웃에 대한 가정을하지 않기 때문입니다. 일반적으로 &lt;a href=&quot;qml-qtquick-controls2-swipeview&quot;&gt;SwipeView&lt;/a&gt; 및 &lt;a href=&quot;qtquickcontrols2-navigation#tabbar&quot;&gt;TabBar&lt;/a&gt; 와 같은 구체적인 컨테이너 구현에서 항목의 크기를 지정할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="051a8a4207d6e90badc250ab22ffb86723eeffe8" translate="yes" xml:space="preserve">
          <source>Notice how the the rounded corners keep their original size, as they are outside the range of the lines.</source>
          <target state="translated">둥근 모서리가 선 범위를 벗어나므로 원래 크기를 유지하는 방법에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="fffb1c32cd0d20c8c8d313553b42beb83ae4b4e7" translate="yes" xml:space="preserve">
          <source>Notice in both instances, &lt;a href=&quot;qml-qtqml-component#createObject-method&quot;&gt;createObject()&lt;/a&gt; is called with &lt;code&gt;appWindow&lt;/code&gt; passed as the parent argument, since the dynamically created object is a visual (Qt Quick) object. The created object will become a child of the &lt;code&gt;appWindow&lt;/code&gt; object in &lt;code&gt;main.qml&lt;/code&gt;, and appear in the scene.</source>
          <target state="translated">동적으로 생성 된 객체는 시각적 (Qt Quick) 객체 이므로 &lt;a href=&quot;qml-qtqml-component#createObject-method&quot;&gt;createObject ()&lt;/a&gt; 는 부모 인수로 전달 된 &lt;code&gt;appWindow&lt;/code&gt; 와 함께 호출됩니다 . 생성 된 객체는의 자식이 될 것이다 &lt;code&gt;appWindow&lt;/code&gt; 의 에서 객체 &lt;code&gt;main.qml&lt;/code&gt; , 장면에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="4cfb568e49b2c6b28b42072911eaf9c2e06d4e5f" translate="yes" xml:space="preserve">
          <source>Notice in the example above that unhandled events are passed to the base class's eventFilter() function, since the base class might have reimplemented eventFilter() for its own internal purposes.</source>
          <target state="translated">위의 예제에서 처리되지 않은 이벤트는 기본 클래스가 자체 내부 목적으로 eventFilter ()를 다시 구현했을 수 있으므로 기본 클래스의 eventFilter () 함수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6f333808bd82420a615128b3e13ffe515c8a7857" translate="yes" xml:space="preserve">
          <source>Notice that</source>
          <target state="translated">그것을주의해라</target>
        </trans-unit>
        <trans-unit id="e516ae82234af9c4d594398e5101f9fea96882a3" translate="yes" xml:space="preserve">
          <source>Notice that &lt;a href=&quot;qml-qtquick-controls2-scrollbar&quot;&gt;ScrollBar&lt;/a&gt; does not filter key events of the Flickable it is attached to. The following example illustrates how to implement scrolling with up and down keys:</source>
          <target state="translated">것을 알 &lt;a href=&quot;qml-qtquick-controls2-scrollbar&quot;&gt;스크롤 막대&lt;/a&gt; 가 부착되어있는 flickable 한의 키 이벤트를 필터링하지 않습니다. 다음 예제는 위 / 아래 키를 사용하여 스크롤을 구현하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="921aed1c6a8c5d44ea24b7d50d64e99e10cb52f9" translate="yes" xml:space="preserve">
          <source>Notice that a URL can be absolute while containing a relative path, and vice versa:</source>
          <target state="translated">상대 경로를 포함하는 동안 URL은 절대적 일 수 있으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="ef9dfb8cebce27b2d7a89f4af6c3697a06cceef2" translate="yes" xml:space="preserve">
          <source>Notice that all painter settings (&lt;a href=&quot;qpainter#setPen&quot;&gt;setPen&lt;/a&gt;(), &lt;a href=&quot;qpainter#setBrush&quot;&gt;setBrush&lt;/a&gt;() etc.) are reset to default values when begin() is called.</source>
          <target state="translated">begin ()을 호출하면 모든 페인터 설정 ( &lt;a href=&quot;qpainter#setPen&quot;&gt;setPen&lt;/a&gt; (), &lt;a href=&quot;qpainter#setBrush&quot;&gt;setBrush&lt;/a&gt; () 등)이 기본값으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="64f6b2e6843e244f70d2e311c4f5a4cad263884c" translate="yes" xml:space="preserve">
          <source>Notice that colorCount() returns 0 for 32-bpp images because these images do not use color tables, but instead encode pixel values as ARGB quadruplets.</source>
          <target state="translated">32bpp 이미지의 경우 colorCount ()는 0을 반환합니다. 이러한 이미지는 색상 표를 사용하지 않고 대신 픽셀 값을 ARGB 4 배로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="358a4f242f26241665405b9f9c5590f599c8622a" translate="yes" xml:space="preserve">
          <source>Notice that part of this &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; can be outise the visual viewport. It can e.g contain negative values.</source>
          <target state="translated">이 &lt;a href=&quot;qrect&quot;&gt;QRect의&lt;/a&gt; 일부 는 시각적 뷰포트를 능가 할 수 있습니다. 예를 들어 음수 값을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb3ce21abee2ea6955b6722f2a2f4fe66112f9a6" translate="yes" xml:space="preserve">
          <source>Notice that qDeleteAll() doesn't remove the items from the container; it merely calls &lt;code&gt;delete&lt;/code&gt; on them. In the example above, we call clear() on the container to remove the items.</source>
          <target state="translated">qDeleteAll ()은 컨테이너에서 항목을 제거하지 않습니다. 단지 그것들을 &lt;code&gt;delete&lt;/code&gt; 라고 부릅니다 . 위의 예제에서 컨테이너에서 clear ()를 호출하여 항목을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="e932a7417bbd2e5d5dcf3bdfd0652267becd7808" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; objects above do not need to specify a &lt;code&gt;target&lt;/code&gt; to animate the appropriate item. Also, the &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; in the &lt;code&gt;addTransition&lt;/code&gt; does not need to specify the &lt;code&gt;to&lt;/code&gt; value to move the item to its correct position in the view. This is because the view implicitly sets the &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; values with the correct item and final item position values if these properties are not explicitly defined.</source>
          <target state="translated">위 의 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 객체 는 적절한 항목을 애니메이션하기 위해 &lt;code&gt;target&lt;/code&gt; 을 지정할 필요가 없습니다 . 또한, &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 에 &lt;code&gt;addTransition&lt;/code&gt; 는 을 지정할 필요가 없습니다 &lt;code&gt;to&lt;/code&gt; 뷰의 해당 위치로 항목을 이동하는 값. 뷰가 암시 적으로 설정하기 때문입니다 &lt;code&gt;target&lt;/code&gt; 과 &lt;code&gt;to&lt;/code&gt; 이러한 속성이 명시 적으로 정의되지 않은 경우 올바른 항목과 마지막 항목의 위치 값으로 값을.</target>
        </trans-unit>
        <trans-unit id="783a9605d0185646cedd6ee8d4597feda8812ed1" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; macro is mandatory for any object that implements signals, slots or properties. You also need to run the &lt;a href=&quot;moc&quot;&gt;Meta Object Compiler&lt;/a&gt; on the source file. We strongly recommend the use of this macro in all subclasses of &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; regardless of whether or not they actually use signals, slots and properties, since failure to do so may lead certain functions to exhibit strange behavior.</source>
          <target state="translated">있음을 주목 &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT의&lt;/a&gt; 매크로 모든 객체 필수 구현하는 신호들, 슬롯 또는 속성. 소스 파일 에서 &lt;a href=&quot;moc&quot;&gt;Meta Object Compiler도&lt;/a&gt; 실행해야 합니다. 신호, 슬롯 및 속성을 실제로 사용하는지 여부에 관계없이 &lt;a href=&quot;qobject&quot;&gt;QObject의&lt;/a&gt; 모든 서브 클래스에서이 매크로를 사용하는 것이 좋습니다. 그렇지 않으면 특정 기능으로 인해 이상한 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="996372cb44362c51c39218414f18924193fffaad" translate="yes" xml:space="preserve">
          <source>Notice that the last conversion returns 1234.0, because '.' is the thousands group separator in the German locale.</source>
          <target state="translated">'.'때문에 마지막 변환은 1234.0을 반환합니다. 독일어 로켈의 천 단위 그룹 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="56c0275dae4c44e356cf9be5d26967b463d073ea" translate="yes" xml:space="preserve">
          <source>Notice that the returned item therefore might not belong to this layout, but to a sub-layout.</source>
          <target state="translated">따라서 반환 된 항목은이 레이아웃에 속하지 않고 하위 레이아웃에 속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a79c1342250a66bcd0681c638ea39ca041d95ce" translate="yes" xml:space="preserve">
          <source>Notice that the value &lt;code&gt;999&lt;/code&gt; returns Intermediate. Values consisting of a number of digits equal to or less than the max value are considered intermediate. This is intended because the digit that prevents a number from being in range is not necessarily the last digit typed. This also means that an intermediate number can have leading zeros.</source>
          <target state="translated">값 &lt;code&gt;999&lt;/code&gt; 는 중간을 반환합니다. 최대 값 이하의 숫자로 구성된 값은 중간으로 간주됩니다. 숫자가 범위 내에 있지 못하도록하는 숫자가 마지막으로 입력 한 숫자가 아니기 때문입니다. 이것은 또한 중간 숫자가 선행 0을 가질 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8b94f5a054fac52cdc15d198f546c7b6b44609e2" translate="yes" xml:space="preserve">
          <source>Notice that there is no need to implement a copy constructor or an assignment operator for the &lt;code&gt;Employee&lt;/code&gt; class, because the copy constructor and assignment operator provided by the C++ compiler will do the</source>
          <target state="translated">C ++ 컴파일러가 제공하는 복사 생성자 및 할당 연산자 는 &lt;code&gt;Employee&lt;/code&gt; 클래스에 대한 복사 생성자 또는 할당 연산자를 구현할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9e7eaf1accd82d81afa12a149e8280b58a574ef7" translate="yes" xml:space="preserve">
          <source>Notice that we don't use the &lt;code&gt;widget&lt;/code&gt; argument, except to pass it on to the QWindowStyle::drawPrimitive() function. As mentioned earlier, the information about what is to be drawn and how it should be drawn is specified by a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; object, so there is no need to ask the widget.</source>
          <target state="translated">QWindowStyle :: drawPrimitive () 함수에 전달하는 것 외에는 &lt;code&gt;widget&lt;/code&gt; 인수를 사용하지 않습니다 . 앞에서 언급 한 바와 같이, 무엇을 그리고 어떻게 그려야하는지에 대한 정보는 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; 객체에 의해 지정 되므로 위젯을 요청할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4327a529092d6042e6848488acc5a896af35a0e" translate="yes" xml:space="preserve">
          <source>Notice that we use a &lt;a href=&quot;qstyleoptionprogressbar&quot;&gt;QStyleOptionProgressBar&lt;/a&gt; and initialize its members. We can then use the current &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; to draw it.</source>
          <target state="translated">&lt;a href=&quot;qstyleoptionprogressbar&quot;&gt;QStyleOptionProgressBar를&lt;/a&gt; 사용 하고 멤버를 초기화합니다. 그런 다음 현재 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 을 사용하여 그릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c6ed32a1e528364de2dafc821200655eede755e" translate="yes" xml:space="preserve">
          <source>Notice that when using this &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt; as part of a &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; this method will have no effect.</source>
          <target state="translated">이 사용할 때주의 &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout을&lt;/a&gt; 의 일환으로 &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; 이 방법은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="36827750343dacc8babe5c6490b79f7e72fedfca" translate="yes" xml:space="preserve">
          <source>Notice that while a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; by itself would be automatically rendered and displayed, this is not the case for the above rectangle because it is defined inside a &lt;code&gt;Component&lt;/code&gt;. The component encapsulates the QML types within, as if they were defined in a separate QML file, and is not loaded until requested (in this case, by the two &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; objects). Because Component is not derived from Item, you cannot anchor anything to it.</source>
          <target state="translated">잠시 통지 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;사각형&lt;/a&gt; 자체가 자동으로 렌더링 및 표시되는 그것이 내부에 정의되어 있기 때문에,이 위의 사각형의 경우에는 해당되지 않습니다 &lt;code&gt;Component&lt;/code&gt; . 컴포넌트는 마치 별도의 QML 파일에 정의 된 것처럼 QML 유형을 캡슐화하고 요청 될 때까지 (이 경우에는 두 개의 &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; 오브젝트에 의해)로드되지 않습니다 . Component는 Item에서 파생되지 않으므로 아무것도 고정 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e9599176e8d8e535c298cec6cc986010a0d0fabd" translate="yes" xml:space="preserve">
          <source>Notice the &lt;a href=&quot;qmetaobject#Q_RETURN_ARG&quot;&gt;Q_RETURN_ARG&lt;/a&gt;() and &lt;a href=&quot;qmetaobject#Q_ARG&quot;&gt;Q_ARG&lt;/a&gt;() arguments for &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject::invokeMethod&lt;/a&gt;() must be specified as &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; types, as this is the generic data type used for QML method parameters and return values.</source>
          <target state="translated">통지 &lt;a href=&quot;qmetaobject#Q_RETURN_ARG&quot;&gt;Q_RETURN_ARG&lt;/a&gt; ()와 &lt;a href=&quot;qmetaobject#Q_ARG&quot;&gt;Q_ARG&lt;/a&gt; ()에 인수 &lt;a href=&quot;qmetaobject#invokeMethod&quot;&gt;QMetaObject :: invokeMethod를&lt;/a&gt; ()로 지정해야합니다 &lt;a href=&quot;qvariant&quot;&gt;QVariant의&lt;/a&gt; 이 QML 방법 매개 변수와 반환 값에 사용되는 일반 데이터 유형이 같은 유형.</target>
        </trans-unit>
        <trans-unit id="1acdea36df9b60315c148a5214948c56dc80a427" translate="yes" xml:space="preserve">
          <source>Notice the &lt;a href=&quot;qml-qtquick-rotationanimation&quot;&gt;RotationAnimation&lt;/a&gt; did not need to set a &lt;code&gt;target&lt;/code&gt; value. As a convenience, when used in a transition, &lt;a href=&quot;qml-qtquick-rotationanimation&quot;&gt;RotationAnimation&lt;/a&gt; will rotate all properties named &quot;rotation&quot; or &quot;angle&quot;. You can override this by providing your own properties via &lt;a href=&quot;qml-qtquick-propertyanimation#properties-prop&quot;&gt;properties&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-propertyanimation#property-prop&quot;&gt;property&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-rotationanimation&quot;&gt;RotationAnimation&lt;/a&gt; 이 &lt;code&gt;target&lt;/code&gt; 값 을 설정할 필요가 없었 음을 주목하십시오 . 편의상 전환에 사용될 때 &lt;a href=&quot;qml-qtquick-rotationanimation&quot;&gt;RotationAnimation&lt;/a&gt; 은 &quot;rotation&quot;또는 &quot;angle&quot;이라는 모든 속성을 회전시킵니다. &lt;a href=&quot;qml-qtquick-propertyanimation#properties-prop&quot;&gt;properties&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-propertyanimation#property-prop&quot;&gt;property&lt;/a&gt; 를 통해 고유 한 특성을 제공하여이를 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8a0a4d5436d9bd18606a9976301235abace1e6a" translate="yes" xml:space="preserve">
          <source>Notice the default state is referred to using an empty string (&quot;&quot;).</source>
          <target state="translated">기본 상태는 빈 문자열 ( &quot;&quot;)을 사용하여 나타납니다.</target>
        </trans-unit>
        <trans-unit id="09d6f6673cc58f9bbc80d0d53337c40495ad9340" translate="yes" xml:space="preserve">
          <source>Notice the example does not require &lt;a href=&quot;qml-qtquick-propertyanimation#to-prop&quot;&gt;to&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-propertyanimation#from-prop&quot;&gt;from&lt;/a&gt; values for the &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt;. As a convenience, these properties are automatically set to the values of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; before and after the state change; the &lt;code&gt;from&lt;/code&gt; values are provided by the current values of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and the &lt;code&gt;to&lt;/code&gt; values are provided by the &lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges&lt;/a&gt; object. If you wish, you can provide &lt;a href=&quot;qml-qtquick-propertyanimation#to-prop&quot;&gt;to&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-propertyanimation#from-prop&quot;&gt;from&lt;/a&gt; values anyway to override the default values.</source>
          <target state="translated">필요로하지 않는 예를주의 &lt;a href=&quot;qml-qtquick-propertyanimation#to-prop&quot;&gt;로&lt;/a&gt; 와 &lt;a href=&quot;qml-qtquick-propertyanimation#from-prop&quot;&gt;에서&lt;/a&gt; 값 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; . 편의상 이러한 속성은 상태 변경 전후 의 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 값으로 자동 설정됩니다 . &lt;code&gt;from&lt;/code&gt; 값의 현재 값에 의해 제공되는 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; , 및 &lt;code&gt;to&lt;/code&gt; 값에 의해 제공된다 &lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges의&lt;/a&gt; 개체. 당신이 원한다면, 당신은 제공 할 수 있습니다 &lt;a href=&quot;qml-qtquick-propertyanimation#to-prop&quot;&gt;에&lt;/a&gt; 와 &lt;a href=&quot;qml-qtquick-propertyanimation#from-prop&quot;&gt;에서&lt;/a&gt; 디폴트 값을 대체하기 위하여 어쨌든 값.</target>
        </trans-unit>
        <trans-unit id="301a28dd35706dd94188caf5732576f4fcfd0b24" translate="yes" xml:space="preserve">
          <source>Notice, however, that assigning a &lt;code&gt;currentIndex&lt;/code&gt; value in JavaScript removes the respective binding. In order to retain the bindings, use the following methods to alter the current index:</source>
          <target state="translated">그러나 JavaScript에서 &lt;code&gt;currentIndex&lt;/code&gt; 값 을 할당 하면 각 바인딩이 제거됩니다. 바인딩을 유지하려면 다음 방법을 사용하여 현재 색인을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="608a0641d7bdd92cb95ef256ba25681da29dffae" translate="yes" xml:space="preserve">
          <source>Notice: this can change the length of the byte array.</source>
          <target state="translated">참고 : 바이트 배열의 길이를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30ef0e1394740601cf26701a4ea5795a88609657" translate="yes" xml:space="preserve">
          <source>Noticeable differences between &lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; and &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;graphicsview#qgraphicswidget&quot;&gt;QGraphicsWidget&lt;/a&gt; 과 &lt;a href=&quot;qwidget&quot;&gt;QWidget의&lt;/a&gt; 현저한 차이점 은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3df8c0589830f636ac9b26d2ab95652cec513937" translate="yes" xml:space="preserve">
          <source>Notification messages</source>
          <target state="translated">알림 메시지</target>
        </trans-unit>
        <trans-unit id="c4510c4d2ce942975c3872cac559615d1262cea6" translate="yes" xml:space="preserve">
          <source>Notification that a &lt;a href=&quot;qml-qtquick-window-window&quot;&gt;Window&lt;/a&gt; is about to be closed. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-window-window&quot;&gt;창&lt;/a&gt; 을 닫으려고 한다는 알림 . &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c419caaa36ff0b8fcae8637be5d1503c551b1bda" translate="yes" xml:space="preserve">
          <source>Notification that a window is about to be closed by the windowing system (e.g. the user clicked the title bar close button). The &lt;a href=&quot;qml-qtquick-window-closeevent&quot;&gt;CloseEvent&lt;/a&gt; contains an accepted property which can be set to false to abort closing the window.</source>
          <target state="translated">윈도우 시스템에서 윈도우를 닫으려고한다는 알림 (예 : 사용자가 제목 표시 줄 닫기 버튼을 클릭) &lt;a href=&quot;qml-qtquick-window-closeevent&quot;&gt;CloseEvent은&lt;/a&gt; 창을 닫지 중단 false로 설정할 수있는 허용 속성을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b4de0a2ea1f8fb289240f48a6991fd6bcdd41961" translate="yes" xml:space="preserve">
          <source>Notification, such as an incoming e-mail or a chat request</source>
          <target state="translated">수신 이메일 또는 채팅 요청과 같은 알림</target>
        </trans-unit>
        <trans-unit id="a89bdc8b4c76dad33197fd6a72ea0efcb0791742" translate="yes" xml:space="preserve">
          <source>NotificationRole - notification, such as an incoming e-mail or a chat request.</source>
          <target state="translated">NotificationRole-수신 이메일 또는 채팅 요청과 같은 알림</target>
        </trans-unit>
        <trans-unit id="3d07659efe8328b7900d2dbc28d0730d51c73224" translate="yes" xml:space="preserve">
          <source>Notifications for added/removed places/categories</source>
          <target state="translated">추가 / 제거 된 장소 / 카테고리에 대한 알림</target>
        </trans-unit>
        <trans-unit id="db2035ff2dbde4d3fb8a66eefce1115ea04d5af8" translate="yes" xml:space="preserve">
          <source>Notifications of place and category changes is supported.</source>
          <target state="translated">장소 및 카테고리 변경 알림이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8700e9a6f8044b4edf9a336f37179cf7fcbe215b" translate="yes" xml:space="preserve">
          <source>Notifications on incoming new connections can be received by installing a &lt;a href=&quot;qmodbustcpconnectionobserver&quot;&gt;QModbusTcpConnectionObserver&lt;/a&gt; via &lt;a href=&quot;qmodbustcpserver#installConnectionObserver&quot;&gt;installConnectionObserver&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qmodbustcpserver#installConnectionObserver&quot;&gt;installConnectionObserver&lt;/a&gt; () 를 통해 &lt;a href=&quot;qmodbustcpconnectionobserver&quot;&gt;QModbusTcpConnectionObserver&lt;/a&gt; 를 설치하면 수신되는 새 연결에 대한 알림을받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0bfacd0e4948553023fe1a031da56e2425dfc2e8" translate="yes" xml:space="preserve">
          <source>Notifies &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; that the scene's scene rect has changed.</source>
          <target state="translated">장면의 장면 사각형이 변경 되었음을 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 에 알립니다 .</target>
        </trans-unit>
        <trans-unit id="d3b1348426df0bd9235f66a574bb1d3c08ca3baf" translate="yes" xml:space="preserve">
          <source>Notifies about a change that might be relevant for accessibility clients.</source>
          <target state="translated">내게 필요한 옵션 클라이언트와 관련이있을 수있는 변경 사항을 알립니다.</target>
        </trans-unit>
        <trans-unit id="18f22244c309a222b570b44e6d80617be15c2a84" translate="yes" xml:space="preserve">
          <source>Notifies all connected renderers that the node has dirty</source>
          <target state="translated">연결된 모든 렌더러에게 노드가 더러워 졌음을 알립니다</target>
        </trans-unit>
        <trans-unit id="a5dc10ecc52b17f8bfd34c57fe2f40b608e48771" translate="yes" xml:space="preserve">
          <source>Notifies observers of scene change</source>
          <target state="translated">관찰자에게 장면 변경 알림</target>
        </trans-unit>
        <trans-unit id="96c4c7c784572a4d671015f0ffb45c7578cbe226" translate="yes" xml:space="preserve">
          <source>Notifies that this transform operation has changed its parameters in such a way that &lt;a href=&quot;qgraphicstransform#applyTo&quot;&gt;applyTo&lt;/a&gt;() will return a different result than before.</source>
          <target state="translated">이 변환 조작이 &lt;a href=&quot;qgraphicstransform#applyTo&quot;&gt;applyTo&lt;/a&gt; ()가 이전과 다른 결과를 리턴하는 방식으로 매개 변수를 변경했음을 알립니다 .</target>
        </trans-unit>
        <trans-unit id="fc6cbfb31efc6d1d86482f4b112b2971441ff29c" translate="yes" xml:space="preserve">
          <source>Notifies the attached sensor (if any) that the filter is being destroyed.</source>
          <target state="translated">연결된 센서 (있는 경우)에 필터가 손상되었음을 알립니다.</target>
        </trans-unit>
        <trans-unit id="65b074b3f524475fa0e3b36b0a9240510b37a9d2" translate="yes" xml:space="preserve">
          <source>Notifies the layout system that this widget has changed and may need to change geometry.</source>
          <target state="translated">이 위젯이 변경되었으며 형상을 변경해야 할 수도 있음을 레이아웃 시스템에 알립니다.</target>
        </trans-unit>
        <trans-unit id="0fe668534b0c3627f437220f47c1f4c8486cde95" translate="yes" xml:space="preserve">
          <source>Notifies you when the geometry of the layout is set. You can store the geometry in your own layout class in a reimplementation of this function.</source>
          <target state="translated">레이아웃 지오메트리가 설정되면 알려줍니다. 이 함수를 다시 구현하여 자신의 레이아웃 클래스에 형상을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f79af4520f90c6792580eda73038648f198214c" translate="yes" xml:space="preserve">
          <source>Notify input method on updated query values if needed.</source>
          <target state="translated">필요한 경우 업데이트 된 쿼리 값에 대한 입력 방법을 통지하십시오.</target>
        </trans-unit>
        <trans-unit id="d5ab18dcc84c48e8636bdced3422891e7427ee35" translate="yes" xml:space="preserve">
          <source>Notify that both &lt;a href=&quot;qt3drender-qblendequationarguments#destinationRgb-prop&quot;&gt;destinationRgb&lt;/a&gt; and &lt;a href=&quot;qt3drender-qblendequationarguments#destinationAlpha-prop&quot;&gt;destinationAlpha&lt;/a&gt; properties have changed to</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qblendequationarguments#destinationRgb-prop&quot;&gt;destinationRgb&lt;/a&gt; 및 &lt;a href=&quot;qt3drender-qblendequationarguments#destinationAlpha-prop&quot;&gt;destinationAlpha&lt;/a&gt; 속성이 모두 로 변경 되었음을 알립니다.</target>
        </trans-unit>
        <trans-unit id="21fbad56849646ffa4eeaadf69c76d517b9fb66e" translate="yes" xml:space="preserve">
          <source>Notify that both &lt;a href=&quot;qt3drender-qblendequationarguments#sourceRgb-prop&quot;&gt;sourceRgb&lt;/a&gt; and &lt;a href=&quot;qt3drender-qblendequationarguments#sourceAlpha-prop&quot;&gt;sourceAlpha&lt;/a&gt; properties have changed to</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qblendequationarguments#sourceRgb-prop&quot;&gt;sourceRgb&lt;/a&gt; 및 &lt;a href=&quot;qt3drender-qblendequationarguments#sourceAlpha-prop&quot;&gt;sourceAlpha&lt;/a&gt; 속성이 모두 다음으로 변경 되었음을 알립니다.</target>
        </trans-unit>
        <trans-unit id="6452884aa35fe617ac701e02fabe909fa0b0cf08" translate="yes" xml:space="preserve">
          <source>Notify the &lt;a href=&quot;qsensor&quot;&gt;QSensor&lt;/a&gt; class that a new reading is available.</source>
          <target state="translated">새로운 판독 값을 사용할 수 있음을 &lt;a href=&quot;qsensor&quot;&gt;QSensor&lt;/a&gt; 클래스에 알립니다 .</target>
        </trans-unit>
        <trans-unit id="8f91bb394c0242cbf37ac2bce6c581dd193d61ea" translate="yes" xml:space="preserve">
          <source>November (10)</source>
          <target state="translated">11 월 (10)</target>
        </trans-unit>
        <trans-unit id="aee655620aa23c92d0397381050cd566a5bbade9" translate="yes" xml:space="preserve">
          <source>Now &lt;a href=&quot;q3dbars&quot;&gt;Q3DBars&lt;/a&gt; is ready to receive data to be rendered. Create a series with one row of 5 values:</source>
          <target state="translated">이제 &lt;a href=&quot;q3dbars&quot;&gt;Q3DBars&lt;/a&gt; 는 렌더링 할 데이터를 수신 할 준비가되었습니다. 한 행의 5 개 값으로 시리즈를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9be3eba733b149dcecd1825ffa838e3b93c31cc6" translate="yes" xml:space="preserve">
          <source>Now &lt;a href=&quot;q3dscatter&quot;&gt;Q3DScatter&lt;/a&gt; is ready to receive data to be rendered. Add one series of 3 &lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt; items:</source>
          <target state="translated">이제 &lt;a href=&quot;q3dscatter&quot;&gt;Q3DScatter&lt;/a&gt; 는 렌더링 할 데이터를 수신 할 준비가되었습니다. 일련의 3 가지 &lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt; 항목 추가 :</target>
        </trans-unit>
        <trans-unit id="331c0db8cef25cfe0cebfe904f7923432bb91b78" translate="yes" xml:space="preserve">
          <source>Now &lt;a href=&quot;q3dsurface&quot;&gt;Q3DSurface&lt;/a&gt; is ready to receive data to be rendered. Create data elements to receive values:</source>
          <target state="translated">이제 &lt;a href=&quot;q3dsurface&quot;&gt;Q3DSurface&lt;/a&gt; 는 렌더링 할 데이터를 수신 할 준비가되었습니다. 값을 수신 할 데이터 요소를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="2db0a3fc9fe56423c21081ea7b6602b05a9ffae8" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;delegateItem.ListView.isCurrentItem&lt;/code&gt; correctly refers to the &lt;code&gt;isCurrentItem&lt;/code&gt; attached property of the delegate.</source>
          <target state="translated">이제 &lt;code&gt;delegateItem.ListView.isCurrentItem&lt;/code&gt; 은 대리자 의 &lt;code&gt;isCurrentItem&lt;/code&gt; 연결된 속성을 올바르게 참조합니다 .</target>
        </trans-unit>
        <trans-unit id="a805c4ae4d8ce078bc70d4e5781b4c02679f5347" translate="yes" xml:space="preserve">
          <source>Now any objects of the &lt;code&gt;SquareButton&lt;/code&gt; can connect to the &lt;code&gt;activated&lt;/code&gt; signal using an &lt;code&gt;onActivated&lt;/code&gt; signal handler:</source>
          <target state="translated">이제 &lt;code&gt;SquareButton&lt;/code&gt; 의 모든 객체 는 &lt;code&gt;onActivated&lt;/code&gt; 신호 처리기를 사용하여 &lt;code&gt;activated&lt;/code&gt; 신호에 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4284fa172b913371a5257f480b33e7d4da6ac738" translate="yes" xml:space="preserve">
          <source>Now it is possible to use named icons from the bundled icon theme without having to specify any fallback source:</source>
          <target state="translated">이제 대체 소스를 지정하지 않고도 번들 아이콘 테마에서 이름이 지정된 아이콘을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a98c2cb6750505b0d8e04eacbe54cd5621f5726" translate="yes" xml:space="preserve">
          <source>Now let's do the same for the three highest tickmarks:</source>
          <target state="translated">이제 세 개의 가장 높은 눈금에 대해 동일한 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f1a405e2933f9a35bab3dc4fb4e4e924e944a6ce" translate="yes" xml:space="preserve">
          <source>Now suppose we want to link to the &lt;a href=&quot;qml-qtqml-qt&quot;&gt;Qt QML type&lt;/a&gt;. At the time qdoc generated this HTML page, that link was also correct, but we had to use this link command:</source>
          <target state="translated">이제 &lt;a href=&quot;qml-qtqml-qt&quot;&gt;Qt QML 타입&lt;/a&gt; 에 링크하려고한다고 가정하자 . qdoc이이 HTML 페이지를 생성 할 때 해당 링크도 정확했지만이 링크 명령을 사용해야했습니다.</target>
        </trans-unit>
        <trans-unit id="e5a133c99da11e95a417ef7b4d7dfb7dea30049c" translate="yes" xml:space="preserve">
          <source>Now that you have seen QML in action, you are ready to take your next step. The follow page will lead you in your journey with QML.</source>
          <target state="translated">QML이 실제로 작동하는 것을 보았으므로 다음 단계로 넘어갈 준비가되었습니다. 다음 페이지는 QML 여행을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="9bf71c6330f6d223169fb14131fc31d8ba31e68c" translate="yes" xml:space="preserve">
          <source>Now that you have successfully connected the objects for the &quot;RED&quot; component of the RGB Controller, do the same for the &quot;GREEN&quot; and &quot;BLUE&quot; components as well.</source>
          <target state="translated">RGB 컨트롤러의 &quot;RED&quot;컴포넌트에 대한 객체를 성공적으로 연결 했으므로 &quot;GREEN&quot;및 &quot;BLUE&quot;컴포넌트에 대해서도 동일하게 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e21b96c54bf1c97a402bf9ebbaf1b0d2d9ac037a" translate="yes" xml:space="preserve">
          <source>Now that you know the rules to abide by when writing a framegraph tree, we will go over a few examples and break them down.</source>
          <target state="translated">프레임 그래프 트리를 작성할 때 준수해야 할 규칙을 알고 있으므로 몇 가지 예를 살펴보고 세분화합니다.</target>
        </trans-unit>
        <trans-unit id="751d20c329ec64db069ad0b321dda5ed3f36291e" translate="yes" xml:space="preserve">
          <source>Now the MY_DEFINES variable contains what is in the DEFINES variable at this point in the project file. This is also equivalent to:</source>
          <target state="translated">이제 MY_DEFINES 변수는 프로젝트 파일의이 시점에서 DEFINES 변수에있는 것을 포함합니다. 이것은 또한 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5c1142a192642e38cc288100f9e53ccc06cc40c" translate="yes" xml:space="preserve">
          <source>Now the images can be successfully loaded in QML:</source>
          <target state="translated">이제 이미지를 QML에 성공적으로로드 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="bc4e54c1c64a54da47872c9ae3eefef136b71fb4" translate="yes" xml:space="preserve">
          <source>Now the total key weight of a row is</source>
          <target state="translated">이제 행의 총 키 가중치는</target>
        </trans-unit>
        <trans-unit id="75eea6953174c82ec38c97658560369e148815ab" translate="yes" xml:space="preserve">
          <source>Now we can compile and start the project, which will open a user interface with our two Qt widgets. If we can resize the dialog, the widgets will resize appropriately.</source>
          <target state="translated">이제 프로젝트를 컴파일하고 시작할 수 있습니다. 그러면 두 개의 Qt 위젯으로 사용자 인터페이스가 열립니다. 대화 상자의 크기를 조정할 수 있으면 위젯의 크기가 적절하게 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="1e93438e0c47d51130b0c52a38f0a11f498cf21f" translate="yes" xml:space="preserve">
          <source>Now we can write an XQuery to find all the XML files and parse them to find the ones that don't contain well-formed XML.</source>
          <target state="translated">이제 XQuery를 작성하여 모든 XML 파일을 찾고 구문 분석하여 올바른 형식의 XML을 포함하지 않는 파일을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15bc3eb1112afd6bd39d30bffaf552565ec10df9" translate="yes" xml:space="preserve">
          <source>Now when we try to run the previous &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; example, no output is produced! The path expression no longer matches anything in the cookbook file because our &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; doesn't yet know about the namespace declaration we added to the cookbook document. There are two ways we can declare the namespace in the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;. We can give it a</source>
          <target state="translated">이제 이전 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 예제 를 실행하려고하면 출력이 생성되지 않습니다! &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 가 아직 요리 책 문서에 추가 한 네임 스페이스 선언에 대해 알지 못 하므로 경로 표현식이 더 이상 요리 책 파일의 내용과 일치 하지 않습니다. &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 에서 네임 스페이스를 선언 할 수있는 두 가지 방법이 있습니다 . 우리는 그것을 줄 수 있습니다</target>
        </trans-unit>
        <trans-unit id="84a546371797b5748135f1ad79247f1f130c24b1" translate="yes" xml:space="preserve">
          <source>Now you can test your development setup by running the examples that came with the Qt 5 installation. You can browse these examples in Qt Creator &lt;b&gt;Welcome&lt;/b&gt; mode. Use the &lt;code&gt;android&lt;/code&gt; filter in the search field to list all the examples tested on Android.</source>
          <target state="translated">이제 Qt 5 설치와 함께 제공된 예제를 실행하여 개발 설정을 테스트 할 수 있습니다. 당신은 Qt는 창조주에서 이러한 예를 찾아 볼 수 있습니다 &lt;b&gt;환영&lt;/b&gt; 모드. 검색 필드에서 &lt;code&gt;android&lt;/code&gt; 필터를 사용하여 Android 에서 테스트 된 모든 예제를 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="0e9e9fe835b1353248af7280ca779de75d0d1856" translate="yes" xml:space="preserve">
          <source>Now your application is available to other Android device users via Google Play. You can also choose to publish the application to a smaller group, so that you can test and improve the application before publishing it to a larger audience.</source>
          <target state="translated">이제 Google Play를 통해 다른 Android 기기 사용자가 애플리케이션을 사용할 수 있습니다. 응용 프로그램을 더 작은 그룹에 게시하도록 선택할 수도 있으므로 더 많은 사용자에게 응용 프로그램을 게시하기 전에 응용 프로그램을 테스트하고 개선 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f6e1017174f7e2d156a7e546c1b8c19d62236c4" translate="yes" xml:space="preserve">
          <source>Now, a &lt;code&gt;Message&lt;/code&gt; type can access the properties and signals of the attached object type:</source>
          <target state="translated">이제 &lt;code&gt;Message&lt;/code&gt; 유형은 첨부 된 객체 유형의 속성 및 신호에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3764460d9a256bfb9eddc4788d15262cb97b19d0" translate="yes" xml:space="preserve">
          <source>Now, a displaced item will first move to a position of (20, 50) relative to its starting position, and then to its final, correct position in the view:</source>
          <target state="translated">이제 변위 된 항목은 먼저 시작 위치를 기준으로 (20, 50)의 위치로 이동 한 다음 뷰에서 최종 올바른 위치로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="06322c5960762faf21f5be048b2a8e4389c77ea3" translate="yes" xml:space="preserve">
          <source>Now, after the space key is pressed, the rectangle's height will continue auto-updating to always be three times its width.</source>
          <target state="translated">이제 스페이스 키를 누른 후 사각형의 높이는 항상 너비의 3 배가되도록 자동 업데이트를 계속합니다.</target>
        </trans-unit>
        <trans-unit id="0d532067038fbb056220a95c58c55f26dc5d05e9" translate="yes" xml:space="preserve">
          <source>Now, if you move the cursor from the top to the bottom in the middle of A, you will get the following &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::MouseMove&lt;/a&gt; events:</source>
          <target state="translated">이제 A 중간에서 커서를 위에서 아래로 &lt;a href=&quot;qevent#Type-enum&quot;&gt;움직이면&lt;/a&gt; 다음과 같은 QEvent :: MouseMove 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e481844fe754938a92b7bad4d082a76299170b34" translate="yes" xml:space="preserve">
          <source>Now, the logical coordinates (-50,-50) correspond to the paint device's physical coordinates (0, 0). Independent of the paint device, your painting code will always operate on the specified logical coordinates.</source>
          <target state="translated">이제 논리 좌표 (-50, -50)는 페인트 장치의 실제 좌표 (0, 0)에 해당합니다. 페인트 장치와 상관없이 페인팅 코드는 항상 지정된 논리 좌표에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6fd2fc7870ed44d5e0bb30d58d403b9ebf9e0073" translate="yes" xml:space="preserve">
          <source>Now, the mutex will always be unlocked when the &lt;a href=&quot;qmutexlocker&quot;&gt;QMutexLocker&lt;/a&gt; object is destroyed (when the function returns since &lt;code&gt;locker&lt;/code&gt; is an auto variable).</source>
          <target state="translated">이제 &lt;a href=&quot;qmutexlocker&quot;&gt;QMutexLocker&lt;/a&gt; 객체가 파괴 될 때 뮤텍스는 항상 잠금 해제됩니다 ( &lt;code&gt;locker&lt;/code&gt; 가 자동 변수 이므로 함수가 반환 될 때 ).</target>
        </trans-unit>
        <trans-unit id="83855bd860aa914a5c93e57a2cf1745228a1f284" translate="yes" xml:space="preserve">
          <source>Now, we preview your form to see how it would look in your application - press &lt;b&gt;Ctrl + R&lt;/b&gt; or select &lt;b&gt;Preview&lt;/b&gt; from the &lt;b&gt;Form&lt;/b&gt; menu. Try dragging the slider - the spin box will mirror its value too (and vice versa). Also, you can resize it to see how the layouts that are used to manage the child widgets, respond to different window sizes.</source>
          <target state="translated">이제 애플리케이션에서 어떻게 보이는지보기 위해 양식을 미리 봅니다. &lt;b&gt;Ctrl + R을&lt;/b&gt; 누르 거나 &lt;b&gt;양식&lt;/b&gt; 메뉴 에서 &lt;b&gt;미리보기&lt;/b&gt; 를 선택하십시오 . 슬라이더를 드래그 해보십시오. 스핀 상자도 그 값을 반영합니다 (또는 그 반대). 또한 하위 위젯을 관리하는 데 사용되는 레이아웃이 다른 창 크기에 어떻게 반응하는지 확인하기 위해 크기를 조정할 수 있습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="84b4c11c7fd0cf44538aed74cc1d5928fd4ad0b5" translate="yes" xml:space="preserve">
          <source>Now, when an item's &lt;code&gt;add&lt;/code&gt; transition is interrupted, its opacity and scale are animated to 1.0 upon displacement, avoiding the erroneous visual effects from before:</source>
          <target state="translated">이제 아이템의 &lt;code&gt;add&lt;/code&gt; 전환이 중단되면 변위시 불투명도와 스케일이 1.0으로 애니메이션되어 이전의 잘못된 시각 효과를 피합니다.</target>
        </trans-unit>
        <trans-unit id="0c277108c7c0452add58bf7a5904a7c9e8c2db50" translate="yes" xml:space="preserve">
          <source>Now, when the form's context menu is opened over objects of the base class, the placeholder class will appear in the &lt;b&gt;Promote to&lt;/b&gt; submenu, allowing for convenient promotion of objects to that class.</source>
          <target state="translated">이제 폼의 컨텍스트 메뉴가 기본 클래스의 개체 위에 열리면 자리 표시 자 클래스가 &lt;b&gt;승격&lt;/b&gt; 하위 메뉴에 표시되어 해당 클래스로 개체를 편리하게 승격시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbcbfce05f3a013dbb7cbbd2902536318fa7a070" translate="yes" xml:space="preserve">
          <source>Now, whenever a QML file is changed, only the QML files have to be recompiled.</source>
          <target state="translated">이제 QML 파일이 변경 될 때마다 QML 파일 만 다시 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="20ce0004d95c8c52d22835e9574d0c0e574dfb78" translate="yes" xml:space="preserve">
          <source>Null documents are documents created through the default constructor.</source>
          <target state="translated">널 문서는 기본 생성자를 통해 작성된 문서입니다.</target>
        </trans-unit>
        <trans-unit id="1dcad64095a7e868acb464e3fd1988e4de7532bb" translate="yes" xml:space="preserve">
          <source>Null pointers can be passed for any function. If any null pointers are passed in, the list will be neither designable nor alterable by the debugger. It is recommended to provide valid pointers for all functions.</source>
          <target state="translated">모든 함수에 대해 널 포인터를 전달할 수 있습니다. 널 포인터가 전달되면 디버거가 목록을 디자인하거나 변경할 수 없습니다. 모든 기능에 유효한 포인터를 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="69b632102a3968648a3ed2625df9a730b484b41e" translate="yes" xml:space="preserve">
          <source>Null values are distinct from undefined values and from invalid &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; objects. The API will not create invalid QCborValues, but they may exist as a result of a parsing error.</source>
          <target state="translated">널값은 정의되지 않은 값 및 유효하지 않은 &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; 오브젝트 와 다릅니다 . API는 유효하지 않은 QCborValue를 작성하지 않지만 구문 분석 오류로 인해 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a97d7a55d5f211b659e841c16281be6ac207623b" translate="yes" xml:space="preserve">
          <source>Null values are used to indicate that an optional value is not present. In that aspect, it is similar to the C++ Standard Library type &lt;code&gt;std::optional&lt;/code&gt; when that is disengaged. Unlike the C++ type, CBOR nulls are simply of type &quot;Null&quot; and it is not possible to determine what concrete type it is replacing.</source>
          <target state="translated">널값은 선택적 값이 존재하지 않음을 표시하는 데 사용됩니다. 이 측면에서 C ++ 표준 라이브러리 유형 &lt;code&gt;std::optional&lt;/code&gt; 과 비슷합니다 . C ++ 유형과 달리 CBOR 널은 단순히 &quot;Null&quot;유형이며 대체 할 콘크리트 유형을 판별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c91466faff2764b37f16753046c2c2356df3e1f0" translate="yes" xml:space="preserve">
          <source>Null-terminated character string of the following format: hh.mm.ss</source>
          <target state="translated">다음 형식의 널 종료 문자열 : hh.mm.ss</target>
        </trans-unit>
        <trans-unit id="2e713b74e51091210b48812cf2f20d24d60f843e" translate="yes" xml:space="preserve">
          <source>Null-terminated character string of the following format: yyyy-mm-dd</source>
          <target state="translated">다음 형식의 널 종료 문자열 : yyyy-mm-dd</target>
        </trans-unit>
        <trans-unit id="07e2b31a37b2a1d2aa894c8f05e8168d1a81015a" translate="yes" xml:space="preserve">
          <source>Null-terminated character string of the following format: yyyy-mm-dd-hh.mm.ss.nnnnnn</source>
          <target state="translated">다음 형식의 널 종료 문자열 : yyyy-mm-dd-hh.mm.ss.nnnnnn</target>
        </trans-unit>
        <trans-unit id="0f194d031cfb916fdcaf72438e49dc4cf8085d1a" translate="yes" xml:space="preserve">
          <source>Null-terminated varying length string</source>
          <target state="translated">널 종료 가변 길이 문자열</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="bd04ea4621d658ed1290cccfcdd817d13897b157" translate="yes" xml:space="preserve">
          <source>Number (QML type)</source>
          <target state="translated">번호 (QML 유형)</target>
        </trans-unit>
        <trans-unit id="c113c1ce38ed141fcae0f6b76ce2cd2c5c8f74af" translate="yes" xml:space="preserve">
          <source>Number Objects</source>
          <target state="translated">숫자 객체</target>
        </trans-unit>
        <trans-unit id="82a0aab3003d37def7a9d10fc943d715c4eb34bc" translate="yes" xml:space="preserve">
          <source>Number Prototype Object</source>
          <target state="translated">숫자 프로토 타입 객체</target>
        </trans-unit>
        <trans-unit id="129277b370f66290dc57a1a03c96346bb7d8fc59" translate="yes" xml:space="preserve">
          <source>Number QML Type</source>
          <target state="translated">숫자 QML 유형</target>
        </trans-unit>
        <trans-unit id="f5437120cfcccb28c6a74d9343e189785f9e28d1" translate="yes" xml:space="preserve">
          <source>Number of available cpus</source>
          <target state="translated">사용 가능한 CPU 수</target>
        </trans-unit>
        <trans-unit id="500e2b6bc22efab7164b45852f67b348ff6f65f3" translate="yes" xml:space="preserve">
          <source>Number of channels</source>
          <target state="translated">채널 수</target>
        </trans-unit>
        <trans-unit id="4b43bab8dbd3ca8a21f75cb7a351549dab6e42fa" translate="yes" xml:space="preserve">
          <source>Number of columns.</source>
          <target state="translated">열 수</target>
        </trans-unit>
        <trans-unit id="95aa88f742fec71068ba90c5df3443d7f96acc87" translate="yes" xml:space="preserve">
          <source>Number of frames in this &lt;a href=&quot;qml-qtquick-animatedsprite&quot;&gt;AnimatedSprite&lt;/a&gt;.</source>
          <target state="translated">이 &lt;a href=&quot;qml-qtquick-animatedsprite&quot;&gt;AnimatedSprite&lt;/a&gt; 의 프레임 수입니다 .</target>
        </trans-unit>
        <trans-unit id="f834f20637f46d00335a4672f4cd5855a7e77339" translate="yes" xml:space="preserve">
          <source>Number of frames in this sprite.</source>
          <target state="translated">이 스프라이트의 프레임 수입니다.</target>
        </trans-unit>
        <trans-unit id="953834b4bdb54e1e2b2933c4b60cdaac7c358715" translate="yes" xml:space="preserve">
          <source>Number of lines to scroll by default for each wheel click.</source>
          <target state="translated">각 휠 클릭에 대해 기본적으로 스크롤 할 줄 수입니다.</target>
        </trans-unit>
        <trans-unit id="c4de77416557276d36e983053906df7898a8bb99" translate="yes" xml:space="preserve">
          <source>Number of particles emitted per second.</source>
          <target state="translated">초당 방출되는 입자 수</target>
        </trans-unit>
        <trans-unit id="99784d5348f9c9161b7d0abdfc2978931bde09d7" translate="yes" xml:space="preserve">
          <source>Number of pixels between the top of each key and the bottom of the &lt;a href=&quot;qml-qtquick-virtualkeyboard-styles-keyboardstyle#characterPreviewDelegate-prop&quot;&gt;characterPreviewDelegate&lt;/a&gt;.</source>
          <target state="translated">각 키의 상단과 &lt;a href=&quot;qml-qtquick-virtualkeyboard-styles-keyboardstyle#characterPreviewDelegate-prop&quot;&gt;characterPreviewDelegate&lt;/a&gt; 의 하단 사이의 픽셀 수입니다 .</target>
        </trans-unit>
        <trans-unit id="117b11fe1707172fb3103fd8d37a75c468c0ec15" translate="yes" xml:space="preserve">
          <source>Number of pixels the tab bar overlaps the tab bar base.</source>
          <target state="translated">탭 막대가 탭 막대베이스와 겹치는 픽셀 수입니다.</target>
        </trans-unit>
        <trans-unit id="aa1086817770ad305f4259ede691b45af504dfd9" translate="yes" xml:space="preserve">
          <source>Number of pixels the tabs should overlap. (Currently only used in styles, not inside of &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt;)</source>
          <target state="translated">탭이 겹치는 픽셀 수입니다. (현재 &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; 내부가 아닌 스타일에서만 사용됨 )</target>
        </trans-unit>
        <trans-unit id="1c099e65a07762829f7dc4f02bbef87f1902e005" translate="yes" xml:space="preserve">
          <source>Number of rows.</source>
          <target state="translated">행 수</target>
        </trans-unit>
        <trans-unit id="e7310da02777697d15f246cacbdda11278ae3b7e" translate="yes" xml:space="preserve">
          <source>Number of samples per pixels.</source>
          <target state="translated">픽셀 당 샘플 수</target>
        </trans-unit>
        <trans-unit id="345a32be56f183547ba365cbc91a5a42c09f45bf" translate="yes" xml:space="preserve">
          <source>Number of seconds for which the service record is expected to remain valid and unchanged.</source>
          <target state="translated">서비스 레코드가 유효하고 변경되지 않은 것으로 예상되는 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="10179913cf23a4c785c56399981d100dee5ea09c" translate="yes" xml:space="preserve">
          <source>Number with a decimal point</source>
          <target state="translated">소수점이있는 숫자</target>
        </trans-unit>
        <trans-unit id="6930ecdabd21ef35de372e2b65c40913aa7fbe51" translate="yes" xml:space="preserve">
          <source>Number with a decimal point, stored in double precision</source>
          <target state="translated">소수점이있는 숫자로 배정 밀도로 저장 됨</target>
        </trans-unit>
        <trans-unit id="61e2eb6c2092496cb709b33bde8b0c1fdb152876" translate="yes" xml:space="preserve">
          <source>Number-String Conversions</source>
          <target state="translated">숫자 스트링 변환</target>
        </trans-unit>
        <trans-unit id="8853b35bfc0b315f9a4aa9f24776f3df91d59844" translate="yes" xml:space="preserve">
          <source>Number.fromLocaleString()</source>
          <target state="translated">Number.fromLocaleString()</target>
        </trans-unit>
        <trans-unit id="0e928443306d0e3608dc13956f467c25354b8134" translate="yes" xml:space="preserve">
          <source>Number.toLocaleCurrencyString()</source>
          <target state="translated">Number.toLocaleCurrencyString()</target>
        </trans-unit>
        <trans-unit id="d1bfceb3f74807a1e09af5f567b5211834fc09fe" translate="yes" xml:space="preserve">
          <source>Number.toLocaleString()</source>
          <target state="translated">Number.toLocaleString()</target>
        </trans-unit>
        <trans-unit id="694f436bf150c20dc3b5d72fd327f6f23a6ec02a" translate="yes" xml:space="preserve">
          <source>NumberAnimation</source>
          <target state="translated">NumberAnimation</target>
        </trans-unit>
        <trans-unit id="eb519c713f65c73fb16c6c3867b306394928735d" translate="yes" xml:space="preserve">
          <source>NumberAnimation (QML type)</source>
          <target state="translated">NumberAnimation (QML 유형)</target>
        </trans-unit>
        <trans-unit id="b294cca2f833e4c8c97789eb72141ab5a01b8d0c" translate="yes" xml:space="preserve">
          <source>NumberAnimation QML Type</source>
          <target state="translated">NumberAnimation QML 유형</target>
        </trans-unit>
        <trans-unit id="65e4e61df8999404b8b5ad166882cb1457e35a93" translate="yes" xml:space="preserve">
          <source>NumberAnimation.from</source>
          <target state="translated">NumberAnimation.from</target>
        </trans-unit>
        <trans-unit id="977d11c79d0ddc0ee6061e53dec292680faa6ebb" translate="yes" xml:space="preserve">
          <source>NumberAnimation.to</source>
          <target state="translated">NumberAnimation.to</target>
        </trans-unit>
        <trans-unit id="35a45152d1ca143684b413835f52129e231f1fc5" translate="yes" xml:space="preserve">
          <source>NumberKey</source>
          <target state="translated">NumberKey</target>
        </trans-unit>
        <trans-unit id="b6727a8e20eef56656ce7cac5201120eb3d8c86a" translate="yes" xml:space="preserve">
          <source>NumberKey (QML type)</source>
          <target state="translated">숫자 키 (QML 유형)</target>
        </trans-unit>
        <trans-unit id="ded1c795537c6d0db49b85fbb4c5d59425e6ba26" translate="yes" xml:space="preserve">
          <source>NumberKey QML Type</source>
          <target state="translated">NumberKey QML 유형</target>
        </trans-unit>
        <trans-unit id="e249d9031dd18938937b7eec1e67c86b2dfc203a" translate="yes" xml:space="preserve">
          <source>Numbers are preferred (but not required).</source>
          <target state="translated">숫자가 선호되지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e7c06a130c65a61ca60fa4f91de0c968043c1eae" translate="yes" xml:space="preserve">
          <source>Numerical representation of sample (typically signed integer, unsigned integer or float)</source>
          <target state="translated">샘플의 숫자 표현 (일반적으로 부호있는 정수, 부호없는 정수 또는 부동 소수점)</target>
        </trans-unit>
        <trans-unit id="bb6f681ce5e6ca483e629f9886404c800d5b2c9c" translate="yes" xml:space="preserve">
          <source>Numerical sorting can be accomplished by zero-padding the values to a fixed length with the help of the &lt;a href=&quot;#format-number&quot;&gt;format_number&lt;/a&gt;() function.</source>
          <target state="translated">&lt;a href=&quot;#format-number&quot;&gt;format_number&lt;/a&gt; () 함수 를 사용하여 고정 길이로 값을 0으로 채워서 숫자 정렬을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8eaaf3f2e73194df2847d7fd9363869f9713855e" translate="yes" xml:space="preserve">
          <source>Numerical values in a database can have precisions greater than their corresponding C++ types. This enum lists the policies for representing such values in the application.</source>
          <target state="translated">데이터베이스의 숫자 값은 해당 C ++ 유형보다 높은 정밀도를 가질 수 있습니다. 이 열거 형은 응용 프로그램에서 이러한 값을 나타내는 정책을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="d6b659d658bf35b86d5fff3cd0fcc74348fd88a9" translate="yes" xml:space="preserve">
          <source>O G&amp;ecirc;nio e as Rosas</source>
          <target state="translated">O G&amp;ecirc;nio e as Rosas</target>
        </trans-unit>
        <trans-unit id="b77c741d1f9cd669d002e4e86286a37c1adb4f06" translate="yes" xml:space="preserve">
          <source>O(</source>
          <target state="translated">O(</target>
        </trans-unit>
        <trans-unit id="6c69dc5bbeb314ef78589c0047ce04c8e5006432" translate="yes" xml:space="preserve">
          <source>O(1)</source>
          <target state="translated">O(1)</target>
        </trans-unit>
        <trans-unit id="26ec14657697a25c3824a35ea3e5f1e616f8b70c" translate="yes" xml:space="preserve">
          <source>O(log</source>
          <target state="translated">O(log</target>
        </trans-unit>
        <trans-unit id="ebc75cd71fe8ecc45d16e8fbe4ca608d05d1efe0" translate="yes" xml:space="preserve">
          <source>O(n)</source>
          <target state="translated">O(n)</target>
        </trans-unit>
        <trans-unit id="88d917ebe28a4594d8b851667720080155024195" translate="yes" xml:space="preserve">
          <source>OAuth 1</source>
          <target state="translated">OAuth 1</target>
        </trans-unit>
        <trans-unit id="33d4fc04c495fd922d4d5a9639d9d4daad5ef02c" translate="yes" xml:space="preserve">
          <source>OAuth 2</source>
          <target state="translated">OAuth 2</target>
        </trans-unit>
        <trans-unit id="286a9950d8b7439d591175d1477185a445560ee1" translate="yes" xml:space="preserve">
          <source>OAuth specifies three methods for the client to establish its rightful ownership of the credentials: &quot;HMAC-SHA1&quot;, &quot;RSA-SHA1&quot;, and &quot;PLAINTEXT&quot;. Each generates a &quot;signature&quot; with which the request is &quot;signed&quot;; the first two use a digest of the data signed in generating this, though the last does not. The &quot;RSA-SHA1&quot; method is not supported here; it would use an RSA key rather than the shared-secret associated with the client credentials.</source>
          <target state="translated">OAuth는 &quot;HMAC-SHA1&quot;, &quot;RSA-SHA1&quot;및 &quot;PLAINTEXT&quot;와 같이 클라이언트가 자격 증명에 대한 올바른 소유권을 설정하는 세 가지 방법을 지정합니다. 각 요청은 &quot;서명&quot;과 함께 &quot;서명&quot;을 생성합니다. 처음 두 개는 이것을 생성하도록 서명 된 데이터의 다이제스트를 사용하지만 마지막 두 개는 그렇지 않습니다. &quot;RSA-SHA1&quot;방법은 여기서 지원되지 않습니다. 클라이언트 자격 증명과 연결된 공유 암호 대신 RSA 키를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="87f31c8069eb8dad7d5d244f603f0f20b29a8937" translate="yes" xml:space="preserve">
          <source>OAuth-authenticated requests can have two sets of credentials: those passed via the &quot;oauth_consumer_key&quot; parameter and those in the &quot;oauth_token&quot; parameter. In order for the server to verify the authenticity of the request and prevent unauthorized access, the client needs to prove that it is the rightful owner of the credentials. This is accomplished using the shared-secret (or RSA key) part of each set of credentials.</source>
          <target state="translated">OAuth 인증 요청에는 &quot;oauth_consumer_key&quot;매개 변수를 통해 전달 된 것과 &quot;oauth_token&quot;매개 변수를 통해 전달되는 자격 증명이 있습니다. 서버가 요청의 진위 여부를 확인하고 무단 액세스를 방지하려면 클라이언트가 자격 증명의 정당한 소유자임을 증명해야합니다. 이는 각 자격 증명 세트의 공유 비밀 (또는 RSA 키) 부분을 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="3fa2004d9c5fb45107e8ba92881d9fc51650ef56" translate="yes" xml:space="preserve">
          <source>OBEX object push service UUID (service &amp;amp; profile)</source>
          <target state="translated">OBEX 객체 푸시 서비스 UUID (서비스 및 프로파일)</target>
        </trans-unit>
        <trans-unit id="30a3ad09b587523d25c7de596e4504c5d2f3dc1e" translate="yes" xml:space="preserve">
          <source>OBEX protocol UUID</source>
          <target state="translated">OBEX 프로토콜 UUID</target>
        </trans-unit>
        <trans-unit id="841711cb0a31c0d559b38249e56010c7811328b8" translate="yes" xml:space="preserve">
          <source>OBJECTIVE_HEADERS</source>
          <target state="translated">OBJECTIVE_HEADERS</target>
        </trans-unit>
        <trans-unit id="04f20aa09e3210fdc27d763821e80a7e7be97cd7" translate="yes" xml:space="preserve">
          <source>OBJECTIVE_SOURCES</source>
          <target state="translated">OBJECTIVE_SOURCES</target>
        </trans-unit>
        <trans-unit id="83ccf14b6fc5001c270b87a25f6dbd0dd2dbdb90" translate="yes" xml:space="preserve">
          <source>OBJECTS</source>
          <target state="translated">OBJECTS</target>
        </trans-unit>
        <trans-unit id="be405de2bfc768c1fbdccb9c1d34d444fb431cbf" translate="yes" xml:space="preserve">
          <source>OBJECTS_DIR</source>
          <target state="translated">OBJECTS_DIR</target>
        </trans-unit>
        <trans-unit id="884fe42d7e2e7bcd001fae8aa79b945821553691" translate="yes" xml:space="preserve">
          <source>OBJECT_PATH</source>
          <target state="translated">OBJECT_PATH</target>
        </trans-unit>
        <trans-unit id="695ae40e746bef24e4df9f63ee368014f1d7e7e4" translate="yes" xml:space="preserve">
          <source>OCI</source>
          <target state="translated">OCI</target>
        </trans-unit>
        <trans-unit id="0d13ae4dd116aec015f36e45386f3e152358d36c" translate="yes" xml:space="preserve">
          <source>OCI BLOB/LOB Support</source>
          <target state="translated">OCI BLOB / LOB 지원</target>
        </trans-unit>
        <trans-unit id="5d450429b3e0e135a15f0dd98a6d3bd981a4aec8" translate="yes" xml:space="preserve">
          <source>OCI User Authentication</source>
          <target state="translated">OCI 사용자 인증</target>
        </trans-unit>
        <trans-unit id="4023014467d78e594d17088f3b828278cac3c54b" translate="yes" xml:space="preserve">
          <source>OCIEnv *environment, OCISvcCtx *serviceContext</source>
          <target state="translated">OCIEnv * 환경, OCISvcCtx * serviceContext</target>
        </trans-unit>
        <trans-unit id="315055fe91d5810cc0cce867d3885759def60c87" translate="yes" xml:space="preserve">
          <source>OCI_ATTR_PREFETCH_MEMORY</source>
          <target state="translated">OCI_ATTR_PREFETCH_MEMORY</target>
        </trans-unit>
        <trans-unit id="208ef5c2b1609274552eee43cd79e96ec0a5d616" translate="yes" xml:space="preserve">
          <source>OCI_ATTR_PREFETCH_ROWS</source>
          <target state="translated">OCI_ATTR_PREFETCH_ROWS</target>
        </trans-unit>
        <trans-unit id="fb91068c51189c866a8e510b38ba4dfebf5d32bc" translate="yes" xml:space="preserve">
          <source>ODBC</source>
          <target state="translated">ODBC</target>
        </trans-unit>
        <trans-unit id="828f47c7b62b20841f0a9fe84c87d0697033c31a" translate="yes" xml:space="preserve">
          <source>ODBC Data Types</source>
          <target state="translated">ODBC 데이터 유형</target>
        </trans-unit>
        <trans-unit id="60f7665529f2f925b978d290b59ba4ff688d3f27" translate="yes" xml:space="preserve">
          <source>ODBC Driver (includes Microsoft SQL Server)</source>
          <target state="translated">ODBC 드라이버 (Microsoft SQL Server 포함)</target>
        </trans-unit>
        <trans-unit id="994c7f90ba717b0252c04ad6c532c4ba66426ca2" translate="yes" xml:space="preserve">
          <source>ODBC Stored Procedure Support</source>
          <target state="translated">ODBC 저장 프로 시저 지원</target>
        </trans-unit>
        <trans-unit id="2057f16fa8465062b88a6e5e145a9dcdd949d419" translate="yes" xml:space="preserve">
          <source>ODBC Unicode Support</source>
          <target state="translated">ODBC 유니 코드 지원</target>
        </trans-unit>
        <trans-unit id="a8fbcef4f5ba09caf931cea9075e77a5e551ffd3" translate="yes" xml:space="preserve">
          <source>ODBC data type</source>
          <target state="translated">ODBC 데이터 유형</target>
        </trans-unit>
        <trans-unit id="e6e72739f18a92d5b218c3d441c28fa23a05bd74" translate="yes" xml:space="preserve">
          <source>ODBC is a general interface that allows you to connect to multiple DBMSs using a common interface. The QODBC driver allows you to connect to an ODBC driver manager and access the available data sources. Note that you also need to install and configure ODBC drivers for the ODBC driver manager that is installed on your system. The QODBC plugin then allows you to use these data sources in your Qt applications.</source>
          <target state="translated">ODBC는 공통 인터페이스를 사용하여 여러 DBMS에 연결할 수있는 일반 인터페이스입니다. QODBC 드라이버를 사용하면 ODBC 드라이버 관리자에 연결하고 사용 가능한 데이터 소스에 액세스 할 수 있습니다. 시스템에 설치된 ODBC 드라이버 관리자에 대한 ODBC 드라이버도 설치하고 구성해야합니다. 그러면 QODBC 플러그인을 통해 Qt 애플리케이션에서 이러한 데이터 소스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce51f5620f2dc95a3693afb895c3f3b71e1a3af3" translate="yes" xml:space="preserve">
          <source>ODF</source>
          <target state="translated">ODF</target>
        </trans-unit>
        <trans-unit id="4d314276ba61e4f3bc6a1b4a234e301a4e785ad9" translate="yes" xml:space="preserve">
          <source>OID</source>
          <target state="translated">OID</target>
        </trans-unit>
        <trans-unit id="9ce3bd4224c8c1780db56b4125ecf3f24bf748b7" translate="yes" xml:space="preserve">
          <source>OK</source>
          <target state="translated">OK</target>
        </trans-unit>
        <trans-unit id="ef0b695e83be27386b36470c50c7f6aaf76e0c49" translate="yes" xml:space="preserve">
          <source>OLE_COLOR</source>
          <target state="translated">OLE_COLOR</target>
        </trans-unit>
        <trans-unit id="be32a2ba6c79c28539a90a34ead9a2e50ea8d370" translate="yes" xml:space="preserve">
          <source>OPERATION</source>
          <target state="translated">OPERATION</target>
        </trans-unit>
        <trans-unit id="9954b5cb646af3e1d62f8936ee802e399e164efe" translate="yes" xml:space="preserve">
          <source>OS X</source>
          <target state="translated">OS X</target>
        </trans-unit>
        <trans-unit id="71af95a01f4f17e1db7ce58248c17727d6bccd76" translate="yes" xml:space="preserve">
          <source>OUT_PWD</source>
          <target state="translated">OUT_PWD</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="e3805ab06696aa72f9cb17dcaeddd521f5f13046" translate="yes" xml:space="preserve">
          <source>Object Constructor</source>
          <target state="translated">객체 생성자</target>
        </trans-unit>
        <trans-unit id="9cf5c3411eb513b108884e51c19ba17172ea9665" translate="yes" xml:space="preserve">
          <source>Object Declarations</source>
          <target state="translated">객체 선언</target>
        </trans-unit>
        <trans-unit id="3f59301f7416504f287f1f698afb5f3926cb4024" translate="yes" xml:space="preserve">
          <source>Object Instances as Models</source>
          <target state="translated">모델로서의 객체 인스턴스</target>
        </trans-unit>
        <trans-unit id="8e8f73597a618314a275940fda3ddbf67d61ed8c" translate="yes" xml:space="preserve">
          <source>Object Life Cycle</source>
          <target state="translated">객체 수명주기</target>
        </trans-unit>
        <trans-unit id="2190ecef1ae8c952744acc1fe3a0dfc304f621fa" translate="yes" xml:space="preserve">
          <source>Object List Property Attributes</source>
          <target state="translated">객체 목록 속성</target>
        </trans-unit>
        <trans-unit id="aaa80f910817ebd1e9f2fa00be8e23153b3e201b" translate="yes" xml:space="preserve">
          <source>Object ListModel</source>
          <target state="translated">객체리스트 모델</target>
        </trans-unit>
        <trans-unit id="9acd850a30238a54eae733b2ef6db2b68124fe1e" translate="yes" xml:space="preserve">
          <source>Object Model</source>
          <target state="translated">객체 모델</target>
        </trans-unit>
        <trans-unit id="e6720a40de19cc539e25cc2ae1ae5e5f90874501" translate="yes" xml:space="preserve">
          <source>Object Paths</source>
          <target state="translated">객체 경로</target>
        </trans-unit>
        <trans-unit id="16b3286580da806e3257bdff8601d05ac12e4df0" translate="yes" xml:space="preserve">
          <source>Object Prototype</source>
          <target state="translated">객체 프로토 타입</target>
        </trans-unit>
        <trans-unit id="0af502f2ae3dd68173726a626d83522053ce2848" translate="yes" xml:space="preserve">
          <source>Object Trees &amp;amp; Ownership</source>
          <target state="translated">객체 트리 및 소유권</target>
        </trans-unit>
        <trans-unit id="cadc94239cb6d9721bc9abae7ab74549ddda3fbb" translate="yes" xml:space="preserve">
          <source>Object Type</source>
          <target state="translated">객체 유형</target>
        </trans-unit>
        <trans-unit id="6d1ee094001a93ed2e61b87b4d76e3a69bbe1573" translate="yes" xml:space="preserve">
          <source>Object Type Declaration</source>
          <target state="translated">객체 타입 선언</target>
        </trans-unit>
        <trans-unit id="cbf147d445453a6660add525598d56066b954b1c" translate="yes" xml:space="preserve">
          <source>Object Types</source>
          <target state="translated">객체 유형</target>
        </trans-unit>
        <trans-unit id="724abbaa9e50ed8d083e80ecfd6b822312ab888a" translate="yes" xml:space="preserve">
          <source>Object assignment (with operator=()) for implicitly shared objects is implemented using shallow copies.</source>
          <target state="translated">내재적으로 공유 된 객체에 대한 객체 할당 (operator = () 사용)은 단순 복사본을 사용하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="7d24a041e67eb9c7378894eed68408469f03a849" translate="yes" xml:space="preserve">
          <source>Object creation requires the specified license key. The key can be empty to require a licensed machine. By default classes are not licensed. Also see the following section.</source>
          <target state="translated">객체 생성에는 지정된 라이센스 키가 필요합니다. 라이센스가있는 머신이 필요하면 키를 비울 수 있습니다. 기본적으로 클래스는 라이센스가 없습니다. 다음 섹션도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b54ee048c2801ae45779415e6f4e268e23af0319" translate="yes" xml:space="preserve">
          <source>Object instances can be instantiated &quot;lazily&quot; at run-time, to avoid performing unnecessary work until needed. Qt Quick provides the &lt;a href=&quot;qml-qtquick-loader&quot;&gt;Loader&lt;/a&gt; type to make lazy instantiation more convenient.</source>
          <target state="translated">필요할 때까지 불필요한 작업을 수행하지 않기 위해 런타임에 객체 인스턴스를 &quot;지연 적으로&quot;인스턴스화 할 수 있습니다. Qt Quick은 &lt;a href=&quot;qml-qtquick-loader&quot;&gt;로더&lt;/a&gt; 유형을 제공하여 지연 인스턴스화를보다 편리하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="3cea97df0b740945c7cd547fced0589e4c407d8c" translate="yes" xml:space="preserve">
          <source>Object path</source>
          <target state="translated">객체 경로</target>
        </trans-unit>
        <trans-unit id="203291fcf92cec017d179c96285b0d1e76accb7f" translate="yes" xml:space="preserve">
          <source>Object values have an internal &lt;code&gt;prototype&lt;/code&gt; property, which can be accessed with &lt;a href=&quot;qjsvalue#prototype&quot;&gt;prototype&lt;/a&gt;() and &lt;a href=&quot;qjsvalue#setPrototype&quot;&gt;setPrototype&lt;/a&gt;().</source>
          <target state="translated">객체 값에는 &lt;a href=&quot;qjsvalue#prototype&quot;&gt;프로토 타입&lt;/a&gt; () 및 &lt;a href=&quot;qjsvalue#setPrototype&quot;&gt;setPrototype&lt;/a&gt; () 으로 액세스 할 수 있는 내부 &lt;code&gt;prototype&lt;/code&gt; 속성이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfd7ce32b18ccc93e091fb9ba1044f2c15579bf2" translate="yes" xml:space="preserve">
          <source>Object values have zero or more properties which are themselves QJSValues. Use &lt;a href=&quot;qjsvalue#setProperty&quot;&gt;setProperty&lt;/a&gt;() to set a property of an object, and call &lt;a href=&quot;qjsvalue#property&quot;&gt;property&lt;/a&gt;() to retrieve the value of a property.</source>
          <target state="translated">오브젝트 값에는 자체 QJSValue 인 0 개 이상의 특성이 있습니다. &lt;a href=&quot;qjsvalue#setProperty&quot;&gt;setProperty&lt;/a&gt; ()를 사용 하여 객체의 속성을 설정하고 &lt;a href=&quot;qjsvalue#property&quot;&gt;property&lt;/a&gt; ()를 호출 하여 속성 값을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="54b21916ca98dfc8439fcd99e018df80869ced7d" translate="yes" xml:space="preserve">
          <source>Object-type properties are accessible from QML providing that the object type has been appropriately &lt;a href=&quot;qtqml-cppintegration-definetypes#registering-c-types-with-the-qml-type-system&quot;&gt;registered&lt;/a&gt; with the QML type system.</source>
          <target state="translated">QML 유형 시스템에 오브젝트 유형이 적절하게 &lt;a href=&quot;qtqml-cppintegration-definetypes#registering-c-types-with-the-qml-type-system&quot;&gt;등록&lt;/a&gt; 되어 있으면 QML에서 오브젝트 유형 특성에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5cdd7a1d073fcc8d75672b9e907657f7abe1bc7" translate="yes" xml:space="preserve">
          <source>Object3D</source>
          <target state="translated">Object3D</target>
        </trans-unit>
        <trans-unit id="4065a84a78b909b3647f336d16ff01b025b3ebb3" translate="yes" xml:space="preserve">
          <source>Object3D (QML type)</source>
          <target state="translated">Object3D (QML 유형)</target>
        </trans-unit>
        <trans-unit id="4785724e157098f2f7c3eaab5a51d123815291b2" translate="yes" xml:space="preserve">
          <source>Object3D QML Type</source>
          <target state="translated">Object3D QML 유형</target>
        </trans-unit>
        <trans-unit id="64bfa4294b96e3d190e235ed69448a5ad6514d90" translate="yes" xml:space="preserve">
          <source>Object3D.position</source>
          <target state="translated">Object3D.position</target>
        </trans-unit>
        <trans-unit id="32cc615a7b7001e3ff856d52e1c78e6e3e8d014d" translate="yes" xml:space="preserve">
          <source>ObjectModel</source>
          <target state="translated">ObjectModel</target>
        </trans-unit>
        <trans-unit id="aec80b03553ebb7dde91b86f2bc7e88ed514ea8c" translate="yes" xml:space="preserve">
          <source>ObjectModel (QML type)</source>
          <target state="translated">ObjectModel (QML 유형)</target>
        </trans-unit>
        <trans-unit id="9b28895c6bcc7dfa7ec11cd69a80612fce798c5e" translate="yes" xml:space="preserve">
          <source>ObjectModel QML Type</source>
          <target state="translated">ObjectModel QML 유형</target>
        </trans-unit>
        <trans-unit id="dff4370260bd3b6b1d459cf919f71ab1463c3299" translate="yes" xml:space="preserve">
          <source>ObjectModel.ObjectModel.index</source>
          <target state="translated">ObjectModel.ObjectModel.index</target>
        </trans-unit>
        <trans-unit id="bf79171018170163b69ed060410e79b23236ca4a" translate="yes" xml:space="preserve">
          <source>ObjectModel.append()</source>
          <target state="translated">ObjectModel.append()</target>
        </trans-unit>
        <trans-unit id="cb209f0994341e86e077877fbe0b0425e8b750fc" translate="yes" xml:space="preserve">
          <source>ObjectModel.clear()</source>
          <target state="translated">ObjectModel.clear()</target>
        </trans-unit>
        <trans-unit id="3c5a7c047b729c4dfa9d1559dba39e7b29bcb0bc" translate="yes" xml:space="preserve">
          <source>ObjectModel.count</source>
          <target state="translated">ObjectModel.count</target>
        </trans-unit>
        <trans-unit id="644bab37ce157b32cff688f709537ade82a223e7" translate="yes" xml:space="preserve">
          <source>ObjectModel.get()</source>
          <target state="translated">ObjectModel.get()</target>
        </trans-unit>
        <trans-unit id="adb704e5c2bcf604ffa4b3e4a4ad0e6a41f259d0" translate="yes" xml:space="preserve">
          <source>ObjectModel.index : &lt;a href=&quot;qml-int&quot;&gt;int&lt;/a&gt;</source>
          <target state="translated">ObjectModel.index : &lt;a href=&quot;qml-int&quot;&gt;int&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd346ecc58d13dae770758b38b9d8bc20e15bf46" translate="yes" xml:space="preserve">
          <source>ObjectModel.insert()</source>
          <target state="translated">ObjectModel.insert()</target>
        </trans-unit>
        <trans-unit id="d63148abda2ca84caa62395733da1faeb324e2fb" translate="yes" xml:space="preserve">
          <source>ObjectModel.move()</source>
          <target state="translated">ObjectModel.move()</target>
        </trans-unit>
        <trans-unit id="53439117cd016c1645e4bb61b6fd813149721878" translate="yes" xml:space="preserve">
          <source>ObjectModel.remove()</source>
          <target state="translated">ObjectModel.remove()</target>
        </trans-unit>
        <trans-unit id="f440e660c5232ac31cba1d040ea9f607a471cfd1" translate="yes" xml:space="preserve">
          <source>ObjectOwnership controls whether or not QML automatically destroys the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; when the corresponding JavaScript object is garbage collected by the engine. The two ownership options are:</source>
          <target state="translated">ObjectOwnership 은 해당 JavaScript 오브젝트가 엔진에 의해 가비지 수집 될 때 QML이 &lt;a href=&quot;qobject&quot;&gt;QObject를&lt;/a&gt; 자동으로 제거하는지 여부를 제어합니다 . 두 가지 소유권 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1369c2fee536e9fa8c60ca26d701c6401f9fd9f1" translate="yes" xml:space="preserve">
          <source>ObjectPicker</source>
          <target state="translated">ObjectPicker</target>
        </trans-unit>
        <trans-unit id="0f4891d4118b365ec653e1e4eca5914fa49041e5" translate="yes" xml:space="preserve">
          <source>ObjectPicker (QML type)</source>
          <target state="translated">ObjectPicker (QML 유형)</target>
        </trans-unit>
        <trans-unit id="1758dc9d669c3dae2c2211d5eaf992aacbe591b7" translate="yes" xml:space="preserve">
          <source>ObjectPicker QML Type</source>
          <target state="translated">ObjectPicker QML 유형</target>
        </trans-unit>
        <trans-unit id="507339a348dd2d6b196a98c18b40c02ba4df22a8" translate="yes" xml:space="preserve">
          <source>ObjectPicker.clicked()</source>
          <target state="translated">ObjectPicker.clicked()</target>
        </trans-unit>
        <trans-unit id="27866cd0f6d62f2e339bdee1f0c0230c076380e7" translate="yes" xml:space="preserve">
          <source>ObjectPicker.containsMouse</source>
          <target state="translated">ObjectPicker.containsMouse</target>
        </trans-unit>
        <trans-unit id="300340c1f2a8b92d91339a7eb11dcc6d918752fe" translate="yes" xml:space="preserve">
          <source>ObjectPicker.dragEnabled</source>
          <target state="translated">ObjectPicker.dragEnabled</target>
        </trans-unit>
        <trans-unit id="bb821c4a974ac836f5c749c47eac4234ebd0ba93" translate="yes" xml:space="preserve">
          <source>ObjectPicker.entered()</source>
          <target state="translated">ObjectPicker.entered()</target>
        </trans-unit>
        <trans-unit id="00792cc1be17d67a85c13a0e2a6a6d728e7c9497" translate="yes" xml:space="preserve">
          <source>ObjectPicker.exited()</source>
          <target state="translated">ObjectPicker.exited()</target>
        </trans-unit>
        <trans-unit id="d08009166a3d37ee63723f549b2c4fbb61eef012" translate="yes" xml:space="preserve">
          <source>ObjectPicker.hoverEnabled</source>
          <target state="translated">ObjectPicker.hoverEnabled</target>
        </trans-unit>
        <trans-unit id="bec1be36848c446606c738946083276662813747" translate="yes" xml:space="preserve">
          <source>ObjectPicker.moved()</source>
          <target state="translated">ObjectPicker.moved()</target>
        </trans-unit>
        <trans-unit id="8dd5ea1a0a6304cea13b321baa29a6466829005c" translate="yes" xml:space="preserve">
          <source>ObjectPicker.pressed</source>
          <target state="translated">ObjectPicker.pressed</target>
        </trans-unit>
        <trans-unit id="d4fe5a38f133ca841e86e4776346655604454350" translate="yes" xml:space="preserve">
          <source>ObjectPicker.pressed()</source>
          <target state="translated">ObjectPicker.pressed()</target>
        </trans-unit>
        <trans-unit id="7a14a61287843ea6096b325f76352d77cc498df2" translate="yes" xml:space="preserve">
          <source>ObjectPicker.priority</source>
          <target state="translated">ObjectPicker.priority</target>
        </trans-unit>
        <trans-unit id="5297e8bc5538b08bd4dc7e94f07f455a5c95a6ee" translate="yes" xml:space="preserve">
          <source>ObjectPicker.released()</source>
          <target state="translated">ObjectPicker.released()</target>
        </trans-unit>
        <trans-unit id="242f07e44cae59f9d77439e072977b098b649199" translate="yes" xml:space="preserve">
          <source>ObjectType *</source>
          <target state="translated">객체 유형 *</target>
        </trans-unit>
        <trans-unit id="e46bdd3b3ef0bf18798ba83ac0aa56a0b8c72fce" translate="yes" xml:space="preserve">
          <source>ObjectType *QRemoteObjectNode::acquire(const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp;</source>
          <target state="translated">ObjectType * QRemoteObjectNode :: acquire (const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp;</target>
        </trans-unit>
        <trans-unit id="39255a2a89f3ceb835e0d6a0969bd48af940aed0" translate="yes" xml:space="preserve">
          <source>Objects and their properties form the basis of a graphical interface defined in a QML document. The QML language allows properties to be bound to each other in various ways, enabling highly dynamic user interfaces.</source>
          <target state="translated">오브젝트 및 해당 특성은 QML 문서에 정의 된 그래픽 인터페이스의 기초를 형성합니다. QML 언어를 사용하면 속성을 다양한 방식으로 서로 바인딩 할 수 있으므로 매우 동적 인 사용자 인터페이스가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4a917cd25aa30b58e4896cb03b974abb05e020fd" translate="yes" xml:space="preserve">
          <source>Objects are added to the form by dragging them from the main widget box and dropping them in the desired location on the form. Once there, they can be moved around simply by dragging them, or using the cursor keys. Pressing the &lt;b&gt;Ctrl&lt;/b&gt; key at the same time moves the selected widget pixel by pixel, while using the cursor keys alone make the selected widget snap to the grid when it is moved. Objects can be selected by clicking on them with the left mouse button. You can also use the &lt;b&gt;Tab&lt;/b&gt; key to change the selection.</source>
          <target state="translated">기본 위젯 상자에서 개체를 끌어서 양식의 원하는 위치에 놓으면 개체가 양식에 추가됩니다. 일단 이동하면 커서를 끌거나 커서 키를 사용하여 간단히 이동할 수 있습니다. &lt;b&gt;Ctrl&lt;/b&gt; 키를 동시에 누르면 선택한 위젯이 픽셀 단위로 이동하는 반면 커서 키만 사용하면 선택한 위젯이 이동 될 때 그리드에 스냅됩니다. 마우스 왼쪽 버튼으로 개체를 클릭하여 개체를 선택할 수 있습니다. &lt;b&gt;Tab&lt;/b&gt; 키를 사용하여 선택을 변경할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="778ae058d98e2788188f6cc27919e4753053c228" translate="yes" xml:space="preserve">
          <source>Objects are colored using a full gradient for each object regardless of object height. The gradient used is specified in &lt;a href=&quot;q3dtheme#baseGradients-prop&quot;&gt;baseGradients&lt;/a&gt;, &lt;a href=&quot;q3dtheme#singleHighlightGradient-prop&quot;&gt;singleHighlightGradient&lt;/a&gt; and &lt;a href=&quot;q3dtheme#multiHighlightGradient-prop&quot;&gt;multiHighlightGradient&lt;/a&gt; properties.</source>
          <target state="translated">객체는 객체 높이에 관계없이 각 객체에 대해 전체 그라데이션을 사용하여 색상이 지정됩니다. 사용 된 그라디언트는 &lt;a href=&quot;q3dtheme#baseGradients-prop&quot;&gt;baseGradients&lt;/a&gt; , &lt;a href=&quot;q3dtheme#singleHighlightGradient-prop&quot;&gt;singleHighlightGradient&lt;/a&gt; 및 &lt;a href=&quot;q3dtheme#multiHighlightGradient-prop&quot;&gt;multiHighlightGradient&lt;/a&gt; 속성에 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="c06922c099c931bd955e1c74efd413ccb359bd5f" translate="yes" xml:space="preserve">
          <source>Objects are colored using a portion of the full gradient determined by the object's height and its position on the Y-axis. The gradient used is specified in &lt;a href=&quot;q3dtheme#baseGradients-prop&quot;&gt;baseGradients&lt;/a&gt;, &lt;a href=&quot;q3dtheme#singleHighlightGradient-prop&quot;&gt;singleHighlightGradient&lt;/a&gt; and &lt;a href=&quot;q3dtheme#multiHighlightGradient-prop&quot;&gt;multiHighlightGradient&lt;/a&gt; properties.</source>
          <target state="translated">객체의 높이와 Y 축에서의 위치에 따라 결정된 전체 그라디언트의 일부를 사용하여 객체의 색상이 지정됩니다. 사용 된 그라디언트는 &lt;a href=&quot;q3dtheme#baseGradients-prop&quot;&gt;baseGradients&lt;/a&gt; , &lt;a href=&quot;q3dtheme#singleHighlightGradient-prop&quot;&gt;singleHighlightGradient&lt;/a&gt; 및 &lt;a href=&quot;q3dtheme#multiHighlightGradient-prop&quot;&gt;multiHighlightGradient&lt;/a&gt; 속성에 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="68ba03f4d3ce8e325872eb66deb74b9f22065f4b" translate="yes" xml:space="preserve">
          <source>Objects are rendered in a single color. The color used is specified in &lt;a href=&quot;q3dtheme#baseColors-prop&quot;&gt;baseColors&lt;/a&gt;, &lt;a href=&quot;q3dtheme#singleHighlightColor-prop&quot;&gt;singleHighlightColor&lt;/a&gt; and &lt;a href=&quot;q3dtheme#multiHighlightColor-prop&quot;&gt;multiHighlightColor&lt;/a&gt; properties.</source>
          <target state="translated">객체는 단일 색상으로 렌더링됩니다. 사용되는 색상은 &lt;a href=&quot;q3dtheme#baseColors-prop&quot;&gt;baseColors&lt;/a&gt; , &lt;a href=&quot;q3dtheme#singleHighlightColor-prop&quot;&gt;singleHighlightColor&lt;/a&gt; 및 &lt;a href=&quot;q3dtheme#multiHighlightColor-prop&quot;&gt;multiHighlightColor&lt;/a&gt; 속성에 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e5c30edaf09673ff06977a35ad3cd677c002aa2e" translate="yes" xml:space="preserve">
          <source>Objects can be inserted into an existing layout by dragging them from their current positions and dropping them at the required location. A blue cursor is displayed in the layout as an object is dragged over it to indicate where the object will be added.</source>
          <target state="translated">객체를 현재 위치에서 드래그하여 필요한 위치에 놓아 기존 레이아웃에 삽입 할 수 있습니다. 객체를 드래그 할 때 레이아웃에 파란색 커서가 표시되어 객체가 추가 될 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7b0c34712c09d9361a7a0125db02767882015b02" translate="yes" xml:space="preserve">
          <source>Objects created with &lt;a href=&quot;qml-qtqml-qt#createQmlObject-method&quot;&gt;Qt.createQmlObject()&lt;/a&gt; can similarly be destroyed using &lt;code&gt;destroy()&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;qml-qtqml-qt#createQmlObject-method&quot;&gt;Qt.createQmlObject ()로&lt;/a&gt; 생성 된 객체는 &lt;code&gt;destroy()&lt;/code&gt; 사용하여 비슷하게 파괴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7124bb3bfd66f83df7d12d9629a94cf43a5fe842" translate="yes" xml:space="preserve">
          <source>Objects created with the default constructor will be invalid and therefore not ready for use.</source>
          <target state="translated">기본 생성자로 작성된 객체는 유효하지 않으므로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b72af5140bc7d68db27b2814ddd4bd23c00938e" translate="yes" xml:space="preserve">
          <source>Objects expose functionality of all super-classes up to and including the class name in value. See &lt;a href=&quot;qaxfactory#exposeToSuperClass&quot;&gt;QAxFactory::exposeToSuperClass&lt;/a&gt;()</source>
          <target state="translated">객체는 클래스 이름 이하의 모든 수퍼 클래스의 기능을 가치에 노출시킵니다. 참조 &lt;a href=&quot;qaxfactory#exposeToSuperClass&quot;&gt;QAxFactory :: exposeToSuperClass을&lt;/a&gt; ()</target>
        </trans-unit>
        <trans-unit id="3a48d867388a6607b5f267eb72c29b56840d7548" translate="yes" xml:space="preserve">
          <source>Objects expose stock events if value is &quot;yes&quot;. See &lt;a href=&quot;qaxfactory#hasStockEvents&quot;&gt;QAxFactory::hasStockEvents&lt;/a&gt;()</source>
          <target state="translated">값이 &quot;예&quot;인 경우 개체가 스톡 이벤트를 노출합니다. 참조 &lt;a href=&quot;qaxfactory#hasStockEvents&quot;&gt;QAxFactory :: hasStockEvents을&lt;/a&gt; ()</target>
        </trans-unit>
        <trans-unit id="d9d6a6cf35a0baf2f93a28ee44478c86e73d0ab4" translate="yes" xml:space="preserve">
          <source>Objects not-created by QML have CppOwnership by default. The exception to this are objects returned from C++ method calls; their ownership will be set to JavaScriptOwnership. This applies only to explicit invocations of &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; methods or slots, but not to property getter invocations.</source>
          <target state="translated">QML에 의해 생성되지 않은 객체는 기본적으로 CppOwnership을 갖습니다. 이에 대한 예외는 C ++ 메소드 호출에서 리턴 된 오브젝트입니다. 소유권은 JavaScriptOwnership으로 설정됩니다. 이는 &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; 메소드 또는 슬롯 의 명시 적 호출에만 적용되며 특성 게터 호출에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2ed93aa58cc4d930e4072f860845a2be981a58c" translate="yes" xml:space="preserve">
          <source>Objects of this type are created with the static &lt;a href=&quot;qdbusmessage#createError&quot;&gt;createError&lt;/a&gt;(), &lt;a href=&quot;qdbusmessage#createMethodCall&quot;&gt;createMethodCall&lt;/a&gt;() and &lt;a href=&quot;qdbusmessage#createSignal&quot;&gt;createSignal&lt;/a&gt;() functions. Use the &lt;a href=&quot;qdbusconnection#send&quot;&gt;QDBusConnection::send&lt;/a&gt;() function to send the messages.</source>
          <target state="translated">이 유형의 객체는 정적 &lt;a href=&quot;qdbusmessage#createError&quot;&gt;createError&lt;/a&gt; (), &lt;a href=&quot;qdbusmessage#createMethodCall&quot;&gt;createMethodCall&lt;/a&gt; () 및 &lt;a href=&quot;qdbusmessage#createSignal&quot;&gt;createSignal&lt;/a&gt; () 함수로 생성됩니다. 사용 &lt;a href=&quot;qdbusconnection#send&quot;&gt;QDBusConnection :: 전송&lt;/a&gt; 메시지를 보내 () 함수를.</target>
        </trans-unit>
        <trans-unit id="e5bf01167f885dfa1d79c937e78f82db58954789" translate="yes" xml:space="preserve">
          <source>Objects of type QDBusUnixFileDescriptors can be used also as parameters in signals and slots that get exported to D-Bus by registering with &lt;a href=&quot;qdbusconnection#registerObject&quot;&gt;QDBusConnection::registerObject&lt;/a&gt;.</source>
          <target state="translated">QDBusUnixFileDescriptors 유형의 오브젝트는 &lt;a href=&quot;qdbusconnection#registerObject&quot;&gt;QDBusConnection :: registerObject&lt;/a&gt; 에 등록하여 D-Bus로 내보내는 신호 및 슬롯의 매개 변수로도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e357d1ff5ca324987ebd92b7b26ec3eef631c85" translate="yes" xml:space="preserve">
          <source>Objects on the form are selected by clicking on them with the left mouse button. When an object is selected, resize handles are shown at each corner and the midpoint of each side, indicating that it can be resized.</source>
          <target state="translated">마우스 왼쪽 버튼으로 개체를 클릭하면 양식의 개체가 선택됩니다. 객체를 선택하면 크기 조정 핸들이 각 모서리와 중간 점에 표시되어 크기를 조정할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6294b16895408ae8a18e40be4d509eccd34a9318" translate="yes" xml:space="preserve">
          <source>Objects shared over QtRO use the links (conduits) between nodes for all communication. If you intend to share a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, you must create a</source>
          <target state="translated">QtRO를 통해 공유되는 객체는 모든 통신에 노드 간 링크 (도관)를 사용합니다. 당신이 공유하려는 경우 &lt;a href=&quot;qobject&quot;&gt;QObject를을&lt;/a&gt; , 당신은을 만들어야합니다</target>
        </trans-unit>
        <trans-unit id="d5419a33da466649584283aaf981083ab4d6ec39" translate="yes" xml:space="preserve">
          <source>Obsolete Commands</source>
          <target state="translated">사용되지 않는 명령</target>
        </trans-unit>
        <trans-unit id="b2bb056990421e57e9424fc4be204dff38320098" translate="yes" xml:space="preserve">
          <source>Obsolete Members for MyClass</source>
          <target state="translated">MyClass에 사용되지 않는 멤버</target>
        </trans-unit>
        <trans-unit id="d81ea7373bafcdbcce99144225ab981920b37861" translate="yes" xml:space="preserve">
          <source>Obsolete members</source>
          <target state="translated">더 이상 사용되지 않는 회원</target>
        </trans-unit>
        <trans-unit id="1303b64b626f9862a3ab911f54129595488daeb3" translate="yes" xml:space="preserve">
          <source>Obsolete, means the same as TlsV1_0</source>
          <target state="translated">폐기 됨, TlsV1_0과 동일 함</target>
        </trans-unit>
        <trans-unit id="126f68650a3c883c5966dde77a69da756c5112f6" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Akan</source>
          <target state="translated">단종 된 Akan을 사용하십시오</target>
        </trans-unit>
        <trans-unit id="55c870676c833eb851ce2251ea0fb2c660adcef2" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Belarusian</source>
          <target state="translated">구식, 벨로루시 어를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="3da6cf42e78de4a6316a4146df5315740e38de45" translate="yes" xml:space="preserve">
          <source>Obsolete, please use CongoBrazzaville</source>
          <target state="translated">더 이상 사용되지 않습니다. CongoBrazzaville를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="6d2f24715c910c01cee7a6bdb458cfd85ae37fee" translate="yes" xml:space="preserve">
          <source>Obsolete, please use CongoKinshasa</source>
          <target state="translated">단종 된 콩고 킨 샤사</target>
        </trans-unit>
        <trans-unit id="a8bbfbffc459308085ae7bcbd4ab175bc1514e12" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Dzongkha</source>
          <target state="translated">더 이상 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="0700b24d6a0b0f0e3ea0a5836dabf2ac82487ba8" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Filipino</source>
          <target state="translated">더 이상 사용되지 않는 필리핀어를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="d46ef5f9abcd242fdeb3181e8b45efccbbb82103" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Khmer</source>
          <target state="translated">더 이상 사용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="8ff018a1d754e1ce47ee01712b04779873ce2b1d" translate="yes" xml:space="preserve">
          <source>Obsolete, please use LatinAmerica</source>
          <target state="translated">더 이상 사용되지 않는 라틴 아메리카를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="2b8ccf7bea421707eefa30235f7572ea439a4abb" translate="yes" xml:space="preserve">
          <source>Obsolete, please use NorthKorea</source>
          <target state="translated">단종 된 북한을 사용하십시오</target>
        </trans-unit>
        <trans-unit id="d2d1cb393abd98e3ff6261155d4e607836200851" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Nyanja</source>
          <target state="translated">더 이상 사용되지 않습니다, Nyanja를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="a7478563538ec1b6c82c6bb040e62619f99bd2a5" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Oromo</source>
          <target state="translated">더 이상 사용되지 않는 Oromo를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="8b81ecf2c2588da244ebeeb3d81f861589d50007" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Romanian</source>
          <target state="translated">더 이상 사용되지 않는, 루마니아어를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="631c312eb9e58b6681dbd0404f966e48161ad5be" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Romansh</source>
          <target state="translated">더 이상 사용하지 않는 Romansh를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="f1d6ec2cba377ca839f8d0319e22054341e2efbd" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Rundi</source>
          <target state="translated">더 이상 사용되지 않는 Rundi를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2b5f6472f178dc5c562335121461ec9c54b95f97" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Serbian</source>
          <target state="translated">더 이상 사용되지 않는 세르비아어를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="c3622b3f40bd9d783777119d4d1919f9d42671d3" translate="yes" xml:space="preserve">
          <source>Obsolete, please use SouthKorea</source>
          <target state="translated">더 이상 사용하지 마십시오, 한국을 사용하십시오</target>
        </trans-unit>
        <trans-unit id="1d1a07b7ce475df352aa2224331a00f5c08b365f" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Syria</source>
          <target state="translated">사용되지 않는 시리아를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="405b7c971de173fb7c7cbbde4e414f9e6f78de67" translate="yes" xml:space="preserve">
          <source>Obsolete, please use TokelauCountry</source>
          <target state="translated">더 이상 사용되지 않는 TokelauCountry를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="8fee2ea224ba53f58e94ad98c90e10c5d5366349" translate="yes" xml:space="preserve">
          <source>Obsolete, please use TuvaluCountry</source>
          <target state="translated">더 이상 사용되지 않는 TuvaluCountry를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="91e80585316dcd90e53eff17afd2561970d07bd1" translate="yes" xml:space="preserve">
          <source>Obsolete, please use Uighur</source>
          <target state="translated">구식, 위구르어를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="c05733879e2e00081332ab4303d245049251051f" translate="yes" xml:space="preserve">
          <source>Obsolete. An integer specifying the number of copies. Use PPK_CopyCount instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 사본 수를 지정하는 정수입니다. PPK_CopyCount를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7a5b66ae61a030c47ab12b2f0221016d2bd5445e" translate="yes" xml:space="preserve">
          <source>Obsolete. Use PE_FrameStatusBarItem instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 PE_FrameStatusBarItem을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="214d5b6c283a8d0e6e4f53ff8d7222ffa0d8e03e" translate="yes" xml:space="preserve">
          <source>Obsolete. Use PM_MdiSubWindowFrameWidth instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 PM_MdiSubWindowFrameWidth를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="79fb8305b897a9121d3571cf9f3ca69601017cef" translate="yes" xml:space="preserve">
          <source>Obsolete. Use PM_MdiSubWindowMinimizedWidth instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 PM_MdiSubWindowMinimizedWidth를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="81baebcc9e684d95840e47fc12b98c40734d57de" translate="yes" xml:space="preserve">
          <source>Obsolete. Use PPK_PaperSize instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 PPK_PaperSize를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f78c6b669563292a61139c7561d8dc5b8adbc604" translate="yes" xml:space="preserve">
          <source>Obsolete. Use SH_Slider_StopMouseOverSlider instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 SH_Slider_StopMouseOverSlider를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dfe119493aae9f23597894a4d012c4249abe1f9e" translate="yes" xml:space="preserve">
          <source>Obsolete. Use SpellCheckUnderlineStyle hint in QPlatformTheme instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 QPlatformTheme에서 SpellCheckUnderlineStyle 힌트를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="29f3ef2bc31211e02b61235b0b8fe8e0c3f3ed6b" translate="yes" xml:space="preserve">
          <source>Obsoletes the action accessors of Qt 4.X.</source>
          <target state="translated">Qt 4.X의 액션 접근자를 폐기합니다.</target>
        </trans-unit>
        <trans-unit id="19ebe07d722b6f7241198edb1da1a709cb2aa6e4" translate="yes" xml:space="preserve">
          <source>Obtaining a Desktop Widget</source>
          <target state="translated">데스크탑 위젯 얻기</target>
        </trans-unit>
        <trans-unit id="e9dad526834de21f7dba68e0aa7bd1a4484997e9" translate="yes" xml:space="preserve">
          <source>Obtaining a QPlaceManager Instance</source>
          <target state="translated">QPlaceManager 인스턴스 얻기</target>
        </trans-unit>
        <trans-unit id="fd579e0f2327bfda15d734738c0594357b10bb01" translate="yes" xml:space="preserve">
          <source>Obviously if you just want to render a simple cube onscreen you may think this is overkill. However, as soon as you want to start doing slightly more complex scenes this comes in handy. For the common cases, Qt 3D provides some example framegraphs that are ready to use out of the box.</source>
          <target state="translated">분명히 간단한 큐브를 화면에 렌더링하려면 이것이 과도하다고 생각할 수 있습니다. 그러나 좀 더 복잡한 장면을 시작하자마자 편리합니다. 일반적인 경우, Qt 3D는 즉시 사용할 수있는 몇 가지 프레임 그래프 예제를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5794e8aaef4df676e90ec4ba52f306c4e4be8bf0" translate="yes" xml:space="preserve">
          <source>Obviously, the &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; object declared in this example is very simple indeed, as it defines nothing more than a few property values. To create more useful objects, an object declaration may define many other types of attributes: these are discussed in the &lt;a href=&quot;qtqml-syntax-objectattributes#&quot;&gt;QML Object Attributes&lt;/a&gt; documentation. Additionally, an object declaration may define child objects, as discussed below.</source>
          <target state="translated">분명히이 예제에서 선언 된 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; 객체는 속성 값이 몇 개에 지나지 않기 때문에 매우 간단합니다. 보다 유용한 객체를 생성하기 위해 객체 선언은 많은 다른 유형의 속성을 정의 할 수 있습니다. 이러한 속성은 &lt;a href=&quot;qtqml-syntax-objectattributes#&quot;&gt;QML 객체 속성&lt;/a&gt; 문서에서 설명합니다. 또한 객체 선언은 아래에 설명 된대로 자식 객체를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7de031c038bfc07c9211f623862c607d8ce2ceb2" translate="yes" xml:space="preserve">
          <source>Occasionally, there isn't such an event-specific function, or the event-specific function isn't sufficient. The most common example involves Tab key presses. Normally, &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; intercepts these to move the keyboard focus, but a few widgets need the Tab key for themselves.</source>
          <target state="translated">경우에 따라 이러한 이벤트 별 기능이 없거나 이벤트 별 기능이 충분하지 않은 경우가 있습니다. 가장 일반적인 예는 Tab 키 누름입니다. 일반적으로 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 은 키보드 포커스를 이동하기 위해이를 가로 채지 만 일부 위젯에는 Tab 키가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="10500e54805775e3d661be35724e87f0b1dbc4c9" translate="yes" xml:space="preserve">
          <source>Octal</source>
          <target state="translated">Octal</target>
        </trans-unit>
        <trans-unit id="006ddfd33a63722690d4c6b3c3135a3cf67e75f1" translate="yes" xml:space="preserve">
          <source>October (9)</source>
          <target state="translated">10 월 (9)</target>
        </trans-unit>
        <trans-unit id="ee1aa86865e42a6f5fe2b3d0dce31a842ab7d9d1" translate="yes" xml:space="preserve">
          <source>Odd-even fill rule.</source>
          <target state="translated">홀수-짝 채우기 규칙.</target>
        </trans-unit>
        <trans-unit id="5a2656ce3572fd6f14dc4d342e513795f4ff9a0a" translate="yes" xml:space="preserve">
          <source>Of course the action also needs a way to be triggered. &lt;a href=&quot;qaccessibleactioninterface#doAction&quot;&gt;doAction()&lt;/a&gt; should invoke the action as advertised by name and description.</source>
          <target state="translated">물론 액션도 트리거 할 수있는 방법이 필요합니다. &lt;a href=&quot;qaccessibleactioninterface#doAction&quot;&gt;doAction ()&lt;/a&gt; 은 이름과 설명으로 알려진 대로 조치를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="539d1ecde8cdd93d82e55c70db69b2f9d0111055" translate="yes" xml:space="preserve">
          <source>Of course, for this case we could have simply used &lt;a href=&quot;qmimedata#setImageData&quot;&gt;setImageData()&lt;/a&gt; instead to supply image data in a variety of formats:</source>
          <target state="translated">물론이 경우 &lt;a href=&quot;qmimedata#setImageData&quot;&gt;setImageData ()를&lt;/a&gt; 사용하여 다양한 형식으로 이미지 데이터를 제공 할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="6b2dbf2d303311c5d81f16daba5d932f6b707a9b" translate="yes" xml:space="preserve">
          <source>Of course, in this case, you could (and probably should) have declared &lt;code&gt;s&lt;/code&gt; as &lt;code&gt;const&lt;/code&gt; in the first place:</source>
          <target state="translated">물론,이 경우에, 당신은 &lt;code&gt;s&lt;/code&gt; 를 &lt;code&gt;const&lt;/code&gt; 로 선언 할 수 있었을 것입니다 .</target>
        </trans-unit>
        <trans-unit id="8e698c91a3434a1208848e40d29b43e559271ac6" translate="yes" xml:space="preserve">
          <source>Of course, it is possible to specify more than one file in the &lt;code&gt;generate&lt;/code&gt; or &lt;code&gt;register&lt;/code&gt; section, so any number of compressed help files can be generated and registered in one go.</source>
          <target state="translated">물론 &lt;code&gt;generate&lt;/code&gt; 또는 &lt;code&gt;register&lt;/code&gt; 섹션 에 둘 이상의 파일을 지정할 수 있으므로 압축 도움말 파일을 한 번에 여러 개 생성하고 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1cdbb36314a4a563bd95617e218b9fe7a8b8388" translate="yes" xml:space="preserve">
          <source>Of the list above, only the 32-bit- and pointer-sized instantiations are guaranteed to work on all platforms. Support for other sizes depends on the compiler and processor architecture the code is being compiled for. To test whether the other types are supported, check the macro &lt;code&gt;Q_ATOMIC_INT\e{nn}_IS_SUPPORTED&lt;/code&gt;, where &lt;code&gt;\e{nn}&lt;/code&gt; is the number of bits desired.</source>
          <target state="translated">위 목록 중 32 비트 및 포인터 크기 인스턴스화 만 모든 플랫폼에서 작동하도록 보장됩니다. 다른 크기에 대한 지원은 코드가 컴파일되는 컴파일러 및 프로세서 아키텍처에 따라 다릅니다. 다른 유형이 지원되는지 테스트하려면 매크로 &lt;code&gt;Q_ATOMIC_INT\e{nn}_IS_SUPPORTED&lt;/code&gt; . 여기서 &lt;code&gt;\e{nn}&lt;/code&gt; 은 원하는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="cf30ca7a7191899f1004deabb699e242711ae17d" translate="yes" xml:space="preserve">
          <source>Of which module is this class a member ?</source>
          <target state="translated">이 클래스는 어떤 모듈입니까?</target>
        </trans-unit>
        <trans-unit id="c61f18c6a55522accf7d2771b789abc3c13411d0" translate="yes" xml:space="preserve">
          <source>Off-screen image representation that can be used as a paint device</source>
          <target state="translated">페인트 장치로 사용할 수있는 오프 스크린 이미지 표현</target>
        </trans-unit>
        <trans-unit id="e71af008d7e5aa29d45aeff84d01efd0bd7d1718" translate="yes" xml:space="preserve">
          <source>Offers an API to access and modify QTextDocuments</source>
          <target state="translated">QTextDocuments에 액세스하고 수정할 수있는 API를 제공합니다</target>
        </trans-unit>
        <trans-unit id="3e5b4d5d08b2c4a1dd9ed75e0f01d5b0d8c6e227" translate="yes" xml:space="preserve">
          <source>Offline Installation</source>
          <target state="translated">오프라인 설치</target>
        </trans-unit>
        <trans-unit id="f04dd3eb6e5b722524af07586142a6a5e22a05d2" translate="yes" xml:space="preserve">
          <source>Offline geocoding is supported.</source>
          <target state="translated">오프라인 지오 코딩이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="e2b02b40206dadcaa999b070b1015221f9826829" translate="yes" xml:space="preserve">
          <source>Offline mapping is supported.</source>
          <target state="translated">오프라인 매핑이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0f03171d3974527f420ac51feda38bf492bf0e7c" translate="yes" xml:space="preserve">
          <source>Offline navigation is supported.</source>
          <target state="translated">오프라인 탐색이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4de115fa9165a74583fc9562660bb964a3f750b8" translate="yes" xml:space="preserve">
          <source>Offline places is supported.</source>
          <target state="translated">오프라인 장소가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="1b3ad425580a2eef53462c2cf2e115d57798eec7" translate="yes" xml:space="preserve">
          <source>Offline routing is supported.</source>
          <target state="translated">오프라인 라우팅이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5bc62c6a6bdc8447e3e98a86b4a6c284573ceb44" translate="yes" xml:space="preserve">
          <source>OffsetData Struct</source>
          <target state="translated">오프셋 데이터 구조</target>
        </trans-unit>
        <trans-unit id="478b0ce81a8454b53cb8994943841aa6ee3577ce" translate="yes" xml:space="preserve">
          <source>OffsetData::abbreviation The abbreviation in effect at the datetime.</source>
          <target state="translated">OffsetData :: abbreviation 날짜 / 시간에 적용되는 약어입니다.</target>
        </trans-unit>
        <trans-unit id="809a2b71f3d6d907133331da1fcf794e18433002" translate="yes" xml:space="preserve">
          <source>OffsetData::atUtc The datetime of the offset data in UTC time.</source>
          <target state="translated">OffsetData :: atUtc 오프셋 데이터의 날짜 시간 (UTC 시간)입니다.</target>
        </trans-unit>
        <trans-unit id="d51b4e24aef300f101d0666b301db6b53d8915a9" translate="yes" xml:space="preserve">
          <source>OffsetData::daylightTimeOffset The DST offset component of the total offset.</source>
          <target state="translated">OffsetData :: daylightTimeOffset 총 오프셋의 DST 오프셋 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="b6a128d5c88c058a76a0bb3f99106b4d50940e3e" translate="yes" xml:space="preserve">
          <source>OffsetData::offsetFromUtc The total offset from UTC in effect at the datetime.</source>
          <target state="translated">OffsetData :: offsetFromUtc 날짜 시간에 적용된 UTC로부터의 총 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="5d8ebe0ff851df709200f23565e3b8c61bffe185" translate="yes" xml:space="preserve">
          <source>OffsetData::standardTimeOffset The standard time offset component of the total offset.</source>
          <target state="translated">OffsetData :: standardTimeOffset 총 오프셋의 표준 시간 오프셋 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="21e683ce4d08545b363ed41ad6d53878ec077e61" translate="yes" xml:space="preserve">
          <source>Offsets From UTC</source>
          <target state="translated">UTC로부터의 오프셋</target>
        </trans-unit>
        <trans-unit id="5db66a762da27792167b5e661317ef121ab59dcf" translate="yes" xml:space="preserve">
          <source>Offsets apply for horizontal center, vertical center, and baseline anchors.</source>
          <target state="translated">오프셋은 수평 중심, 수직 중심 및 기준선 앵커에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="083a5552133afe7c7b78d7e92bf25dc839408eb4" translate="yes" xml:space="preserve">
          <source>Often the item models will have a single role that contains information you want to map to multiple values. A typical example of this is a timestamp field when generating a bar graph with two time related axes, for example years and months. To enable mapping a single item model role to more than one data field, pattern matching and replacing mechanism is provided by item model proxies. You can also use this mechanism to reformat data even in one-to-one mapping cases.</source>
          <target state="translated">항목 모델에는 종종 여러 값에 매핑하려는 정보가 포함 된 단일 역할이 있습니다. 대표적인 예는 연도 및 월과 같이 두 개의 시간 관련 축이있는 막대 그래프를 생성 할 때 타임 스탬프 필드입니다. 단일 항목 모델 역할을 둘 이상의 데이터 필드에 매핑 할 수 있도록 항목 모델 프록시에서 패턴 일치 및 대체 메커니즘을 제공합니다. 이 메커니즘을 사용하여 일대일 매핑 사례에서도 데이터를 다시 포맷 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07351a73c13b6ecf21ea7d8a4dde2b05e544964c" translate="yes" xml:space="preserve">
          <source>Often this is used to update status information.</source>
          <target state="translated">상태 정보를 업데이트하는 데 종종 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f3ffa543d2ed458a9b9a43ff40cd280625f0a189" translate="yes" xml:space="preserve">
          <source>Often when dealing with items in a scene, it can be useful to map coordinates and arbitrary shapes from the scene to an item, from item to item, or from the view to the scene. For example, when you click your mouse in &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt;'s viewport, you can ask the scene what item is under the cursor by calling &lt;a href=&quot;qgraphicsview#mapToScene&quot;&gt;QGraphicsView::mapToScene&lt;/a&gt;(), followed by &lt;a href=&quot;qgraphicsscene#itemAt&quot;&gt;QGraphicsScene::itemAt&lt;/a&gt;(). If you want to know where in the viewport an item is located, you can call &lt;a href=&quot;qgraphicsitem#mapToScene&quot;&gt;QGraphicsItem::mapToScene&lt;/a&gt;() on the item, then &lt;a href=&quot;qgraphicsview#mapFromScene&quot;&gt;QGraphicsView::mapFromScene&lt;/a&gt;() on the view. Finally, if you use want to find what items are inside a view ellipse, you can pass a &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt; to mapToScene(), and then pass the mapped path to &lt;a href=&quot;qgraphicsscene#items&quot;&gt;QGraphicsScene::items&lt;/a&gt;().</source>
          <target state="translated">장면에서 항목을 처리 할 때 장면에서 항목으로, 항목에서 항목으로 또는보기에서 장면으로 좌표 및 임의 모양을 매핑하는 것이 유용 할 수 있습니다. 예를 들어, 당신이 당신의 마우스를 클릭 할 때 &lt;a href=&quot;qgraphicsview&quot;&gt;를 QGraphicsView&lt;/a&gt; 의 뷰포트를, 당신이 호출하여 커서 아래에 어떤 항목 장면 요청할 수 있습니다 &lt;a href=&quot;qgraphicsview#mapToScene&quot;&gt;를 QGraphicsView :: mapToScene를&lt;/a&gt; 다음 (), &lt;a href=&quot;qgraphicsscene#itemAt&quot;&gt;QGraphicsScene을 :: itemAt을&lt;/a&gt; (). 항목이 뷰포트에서 어디에 있는지 알고 싶다면 항목에서 &lt;a href=&quot;qgraphicsitem#mapToScene&quot;&gt;QGraphicsItem :: mapToScene&lt;/a&gt; ()을 호출 한 다음보기에서 &lt;a href=&quot;qgraphicsview#mapFromScene&quot;&gt;QGraphicsView :: mapFromScene&lt;/a&gt; ()을 호출 할 수 있습니다. 마지막으로 뷰 타원 안에있는 항목을 찾으려면 &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt; 를 mapToScene ()에 전달한 다음 매핑 된 경로를&lt;a href=&quot;qgraphicsscene#items&quot;&gt;QGraphicsScene :: items&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="e9d4b48fe3693b0cdf78b8dc6d9851b89bb75ecc" translate="yes" xml:space="preserve">
          <source>Often when linking against a library, qmake relies on the underlying platform to know what other libraries this library links against, and lets the platform pull them in. In many cases, however, this is not sufficient. For example, when statically linking a library, no other libraries are linked to, and therefore no dependencies to those libraries are created. However, an application that later links against this library will need to know where to find the symbols that the static library will require. qmake attempts to keep track of the dependencies of a library, where appropriate, if you explicitly enable tracking.</source>
          <target state="translated">라이브러리와 링크 할 때 qmake는 기본 플랫폼에 의존하여이 라이브러리가 링크하는 다른 라이브러리를 알고 플랫폼이 라이브러리를 가져 오도록합니다. 그러나 대부분의 경우 충분하지 않습니다. 예를 들어 라이브러리를 정적으로 링크 할 때 다른 라이브러리는 링크되지 않으므로 해당 라이브러리에 대한 종속성이 작성되지 않습니다. 그러나 나중에이 라이브러리와 링크되는 응용 프로그램은 정적 라이브러리에 필요한 기호를 찾을 위치를 알아야합니다. qmake는 명시 적으로 추적을 활성화 한 경우 적절한 경우 라이브러리의 종속성을 추적하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="8113d33edda2a9347e8827e56055228866817309" translate="yes" xml:space="preserve">
          <source>Often, QML applications are prototyped with test data that is later replaced by real data sources from C++ plugins. The &lt;code&gt;qmlscene&lt;/code&gt; utility assists in this aspect by loading test data into the application context. It looks for a directory named &lt;code&gt;dummydata&lt;/code&gt; in the same directory as the target QML file, and loads the .qml files in that directory as QML objects and bind them to the root context as properties named after the files.</source>
          <target state="translated">종종 QML 애플리케이션은 테스트 데이터로 프로토 타입 화되어 나중에 C ++ 플러그인의 실제 데이터 소스로 대체됩니다. &lt;code&gt;qmlscene&lt;/code&gt; 의 유틸리티는 응용 프로그램 컨텍스트에로드 테스트 데이터에 의해 이러한 측면에서 도움이됩니다. 대상 QML 파일과 동일한 디렉토리에서 &lt;code&gt;dummydata&lt;/code&gt; 라는 디렉토리를 찾고 해당 디렉토리의 .qml 파일을 QML 오브젝트로로드하고 파일의 이름을 딴 특성으로 루트 컨텍스트에 바인드합니다.</target>
        </trans-unit>
        <trans-unit id="2ff6652bbae9100b879243bc1708a5778f0cca77" translate="yes" xml:space="preserve">
          <source>Often, it is required to set a fill pattern similar to the styles in &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::BrushStyle&lt;/a&gt;. You can use the background-color property for &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::SolidPattern&lt;/a&gt;, &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::RadialGradientPattern&lt;/a&gt;, &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::LinearGradientPattern&lt;/a&gt; and &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt::ConicalGradientPattern&lt;/a&gt;. The other patterns are easily achieved by creating a background image that contains the pattern.</source>
          <target state="translated">종종 &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: BrushStyle&lt;/a&gt; 의 스타일과 유사한 채우기 패턴을 설정해야합니다 . &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: SolidPattern&lt;/a&gt; , &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: RadialGradientPattern&lt;/a&gt; , &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: LinearGradientPattern&lt;/a&gt; 및 &lt;a href=&quot;qt#BrushStyle-enum&quot;&gt;Qt :: ConicalGradientPattern에&lt;/a&gt; 배경색 속성을 사용할 수 있습니다 . 다른 패턴은 패턴이 포함 된 배경 이미지를 만들어 쉽게 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eff7f785639780a987136b4902b533bccaf698b9" translate="yes" xml:space="preserve">
          <source>Often, the design of RPC is such that different clients are independent of each other: for instance, two clients can ask a mapping service for directions and get different results.</source>
          <target state="translated">종종 RPC의 디자인은 서로 다른 클라이언트가 서로 독립적 이도록 설계됩니다. 예를 들어, 두 클라이언트는 매핑 서비스에 방향을 요청하고 다른 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="602ad5e704343341cb60cce74db092f1bad4f667" translate="yes" xml:space="preserve">
          <source>Often, the documentor knows which Qt module the link target is in. When the module name is known, use the module name as the</source>
          <target state="translated">종종 문서 작성자는 링크 대상이있는 Qt 모듈을 알고 있습니다. 모듈 이름을 알면 모듈 이름을</target>
        </trans-unit>
        <trans-unit id="ce673dc82d88a7fb26299bc0da6bea8af09e995c" translate="yes" xml:space="preserve">
          <source>Older QNX SDP releases and other architectures may also work, but are not subject to regular builds and testing.</source>
          <target state="translated">이전 QNX SDP 릴리스 및 기타 아키텍처도 작동 할 수 있지만 정기적 인 빌드 및 테스트 대상이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4d8b1438569bf0c09e303aa88ebfe324ecdff0d2" translate="yes" xml:space="preserve">
          <source>OldiesMusic</source>
          <target state="translated">OldiesMusic</target>
        </trans-unit>
        <trans-unit id="f84e621732c7417e4b038431f9cda4dfbe6e1e1e" translate="yes" xml:space="preserve">
          <source>Omits adding the padding equal signs at the end of the encoded data.</source>
          <target state="translated">인코딩 된 데이터 끝에 패딩 등호를 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="708c057c8ea1d7f4ab116e5d3cabcb22bb3a6b30" translate="yes" xml:space="preserve">
          <source>Omitting this import will allow you to have a QML environment without access to window system features.</source>
          <target state="translated">이 가져 오기를 생략하면 창 시스템 기능에 액세스하지 않고도 QML 환경을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="beb53630cea57a3b4463541f0e611323d0c3c7de" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;#macos&quot;&gt;macOS&lt;/a&gt;, if the default &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; is set after the application instance, the application will exit with &lt;a href=&quot;#qFatal&quot;&gt;qFatal&lt;/a&gt;(), and print a message that the default &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; should be set before the application instance.</source>
          <target state="translated">에 &lt;a href=&quot;#macos&quot;&gt;맥 OS&lt;/a&gt; 기본 경우, &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat이&lt;/a&gt; 응용 프로그램 인스턴스 후 설정, 응용 프로그램과 함께 종료됩니다 &lt;a href=&quot;#qFatal&quot;&gt;qFatal&lt;/a&gt; () 및 기본 있다는 메시지를 인쇄 &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat이&lt;/a&gt; 응용 프로그램 인스턴스하기 전에 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="48983f7907a89cb00fd4a0e1da0a76bd00c7750e" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;#macos&quot;&gt;macOS&lt;/a&gt;, the following are required:</source>
          <target state="translated">에 &lt;a href=&quot;#macos&quot;&gt;맥 OS&lt;/a&gt; , 다음이 필요합니다 :</target>
        </trans-unit>
        <trans-unit id="5f8f3bcad2004aa59e2b7948d34aca8342d16877" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;#macos&quot;&gt;macOS&lt;/a&gt;, there are no special requirements for enabling sandbox support.</source>
          <target state="translated">에 &lt;a href=&quot;#macos&quot;&gt;맥 OS&lt;/a&gt; , 샌드 박스 지원을 가능하게하기위한 특별한 요구 사항이 없습니다.</target>
        </trans-unit>
        <trans-unit id="02407378beec6ff1f9fd53476003148fce3032f0" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;MacOS&lt;/a&gt; the color dialog is only allowed to be non-modal.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 색상 대화 상자는 비 모달로 할 수있다.</target>
        </trans-unit>
        <trans-unit id="896e5aeb9f74a7eae8da5b7aefbd0e6400cc7a1c" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; adds a fullscreen button.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 전체 화면 버튼을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1263f61e81dd5282840aff4a8e24fd1f82c20e3b" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; adds a tool bar button (i.e., the oblong button that is on the top right of windows that have toolbars).</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 도구 모음 버튼을 추가합니다 (즉, 도구 모음이 윈도우의 상단 오른쪽에있는 직사각형 버튼).</target>
        </trans-unit>
        <trans-unit id="fe348f0673364ee4617b20e1f55989c2b3f17704" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS this function compares according the &quot;Order for sorted lists&quot; setting in the International preferences panel.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 및 iOS이 기능은 &quot;주문을위한 정렬 된 목록&quot;에 따라 비교하여 국제 환경 설정 패널에서 설정.</target>
        </trans-unit>
        <trans-unit id="b97b0a04a3472cc7c0aa2fab68d1ec5936119928" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS this returns the proper localized name for a bundle if the path &lt;a href=&quot;qfileinfo#isBundle&quot;&gt;isBundle&lt;/a&gt;(). On all other platforms an empty &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; is returned.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 와 iOS의 경우 경로 번들이 반환 적절한 지역화 된 이름 &lt;a href=&quot;qfileinfo#isBundle&quot;&gt;isBundle&lt;/a&gt; (). 다른 모든 플랫폼에서는 빈 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1bacab286a6bc6c27c2d11a36406a4fc8b1f9dba" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS this will point to the directory actually containing the executable, which may be inside an application bundle (if the application is bundled).</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 및 iOS이 실제로 (응용 프로그램이 번들로 제공되는 경우) 응용 프로그램 번들 내에서 될 수있는 실행 파일을 포함하는 디렉토리를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="74fca3806b524f89c61474a23c98de0edc165b5e" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS, &lt;a href=&quot;qsettings#allKeys&quot;&gt;allKeys&lt;/a&gt;() will return some extra keys for global settings that apply to all applications. These keys can be read using &lt;a href=&quot;qsettings#value&quot;&gt;value&lt;/a&gt;() but cannot be changed, only shadowed. Calling &lt;a href=&quot;qsettings#setFallbacksEnabled&quot;&gt;setFallbacksEnabled&lt;/a&gt;(false) will hide these global settings.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 및 iOS, &lt;a href=&quot;qsettings#allKeys&quot;&gt;해서 AllKeys는&lt;/a&gt; () 모든 응용 프로그램에 적용되는 전역 설정에 대한 몇 가지 여분의 키를 반환합니다. 이 키는 &lt;a href=&quot;qsettings#value&quot;&gt;값&lt;/a&gt; ()을 사용하여 읽을 수 있지만 변경할 수 없으며 그림자 만 있습니다. &lt;a href=&quot;qsettings#setFallbacksEnabled&quot;&gt;setFallbacksEnabled&lt;/a&gt; (false)를 호출 하면 이러한 전역 설정이 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="a9784bd0835cdc1d60a8d6be41cf3fae4c475ec0" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS, the CFPreferences API used by &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; expects Internet domain names rather than organization names. To provide a uniform API, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; derives a fake domain name from the organization name (unless the organization name already is a domain name, e.g. OpenOffice.org). The algorithm appends &quot;.com&quot; to the company name and replaces spaces and other illegal characters with hyphens. If you want to specify a different domain name, call &lt;a href=&quot;qcoreapplication#organizationDomain-prop&quot;&gt;QCoreApplication::setOrganizationDomain&lt;/a&gt;(), &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;QCoreApplication::setOrganizationName&lt;/a&gt;(), and &lt;a href=&quot;qcoreapplication#applicationName-prop&quot;&gt;QCoreApplication::setApplicationName&lt;/a&gt;() in your &lt;code&gt;main()&lt;/code&gt; function and then use the default &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; constructor. Another solution is to use preprocessor directives, for example:</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 및 iOS에서 사용하는 CFPreferences의 API &lt;a href=&quot;qsettings&quot;&gt;QSettings는&lt;/a&gt; 인터넷 도메인 이름이 아닌 조직의 이름을 기대하고있다. 균일 한 API를 제공하기 위해 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 는 조직 이름에서 가짜 도메인 이름을 파생합니다 (조직 이름이 이미 OpenOffice.org와 같은 도메인 이름이 아닌 한). 이 알고리즘은 회사 이름에 &quot;.com&quot;을 추가하고 공백 및 기타 잘못된 문자를 하이픈으로 바꿉니다. 다른 도메인 이름을 지정하려면 &lt;code&gt;main()&lt;/code&gt; 함수 에서 &lt;a href=&quot;qcoreapplication#organizationDomain-prop&quot;&gt;QCoreApplication :: setOrganizationDomain&lt;/a&gt; (), &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;QCoreApplication :: setOrganizationName&lt;/a&gt; () 및 &lt;a href=&quot;qcoreapplication#applicationName-prop&quot;&gt;QCoreApplication :: setApplicationName&lt;/a&gt; ()을 호출 한 다음 기본 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 를 사용하십시오.건설자. 또 다른 솔루션은 전 처리기 지시문을 사용하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da0aaa820fd6ef22793ef435bf386f39ba1162e8" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS, this function compares according the &quot;Order for sorted lists&quot; setting in the International prefereces panel.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 국제에서 설정 패널을 prefereces 및 iOS,이 기능은 &quot;정렬 된리스트가 순서&quot;에 따라 비교합니다.</target>
        </trans-unit>
        <trans-unit id="571535e6d5a4810b87bbb8adfbfdb99e81578b79" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS, you can access property list &lt;code&gt;.plist&lt;/code&gt; files by passing &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings::NativeFormat&lt;/a&gt; as second argument. For example:</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 및 iOS, 당신은 속성 목록에 액세스 할 수 있습니다 &lt;code&gt;.plist&lt;/code&gt; 전달하여 파일을 &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings :: NativeFormat을&lt;/a&gt; 두 번째 인수로. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd67470be80f5cf6282fa567bbbecb7e060ec1a1" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and on certain Linux desktop environments such as Ubuntu Unity, &lt;a href=&quot;qmenubar&quot;&gt;QMenuBar&lt;/a&gt; is a wrapper for using the system-wide menu bar. If you have multiple menu bars in one dialog the outermost menu bar (normally inside a widget with widget flag &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Window&lt;/a&gt;) will be used for the system-wide menu bar.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 및 우분투 유니티와 같은 특정 리눅스 데스크톱 환경에 &lt;a href=&quot;qmenubar&quot;&gt;QMenuBar는&lt;/a&gt; 시스템 전체 메뉴 표시 줄을 사용하는 래퍼입니다. 하나의 대화 상자에 여러 개의 메뉴 표시 줄이있는 경우 가장 바깥 쪽 메뉴 표시 줄 (일반적으로 위젯 플래그가 &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt :: Window 인&lt;/a&gt; 위젯 내부) )이 시스템 전체 메뉴 표시 줄에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="50371ff4facf12b43ac86104b79a75268fc089a3" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and with Qt version 4.3 or higher, clipboard changes made by other applications will only be detected when the application is activated.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 응용 프로그램이 활성화 될 때와 Qt는 버전 4.3 이상과는 다른 응용 프로그램에서 만든 클립 보드의 변화 만 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="e6ccdce7fdcb9c3206b9165c144f45728d52799a" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; by default, Qt swaps the Control and Meta (Command) keys (i.e., whenever Control is pressed, Qt sends Meta, and whenever Meta is pressed Control is sent). When this attribute is true, Qt will not do the flip. &lt;a href=&quot;qkeysequence#StandardKey-enum&quot;&gt;QKeySequence::StandardKey&lt;/a&gt; will also flip accordingly (i.e., &lt;a href=&quot;qkeysequence#StandardKey-enum&quot;&gt;QKeySequence::Copy&lt;/a&gt; will be Command+C on the keyboard regardless of the value set, though what is output for &lt;a href=&quot;qkeysequence#toString&quot;&gt;QKeySequence::toString&lt;/a&gt;() will be different).</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 는 기본적으로, Qt는이 제어 및 메타 (명령) 키를 교환합니다 (즉, 제어를 누를 때마다, Qt는 메타는 전송하고, 메타 누를 때마다 제어가 전송됩니다). 이 속성이 true이면 Qt는 플립을 수행하지 않습니다. &lt;a href=&quot;qkeysequence#StandardKey-enum&quot;&gt;QKeySequence :: StandardKey&lt;/a&gt; 도 그에 따라 뒤집 &lt;a href=&quot;qkeysequence#StandardKey-enum&quot;&gt;힙니다&lt;/a&gt; (예 : &lt;a href=&quot;qkeysequence#toString&quot;&gt;QKeySequence :: toString에&lt;/a&gt; 대해 출력되는 내용이 설정되어 있지만 QKeySequence :: Copy 는 값 설정에 상관없이 키보드에서 Command + C가됩니다) ()에 가됩니다).</target>
        </trans-unit>
        <trans-unit id="bffe222338b643c2477ba996114f1133f75cfd9c" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; only, if there is exactly one button with the role &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;QMessageBox::RejectRole&lt;/a&gt;, it is made the escape button.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 역할과 정확히 하나 개의 버튼이있는 경우에만, &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;QMessageBox :: RejectRole&lt;/a&gt; , 그것은 이스케이프 버튼을한다.</target>
        </trans-unit>
        <trans-unit id="f19cde677c2916be9dcaf95716c315a18f596126" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; versions 10.2 and 10.3, these files are used by default:</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 버전 10.2 및 10.3,이 파일은 기본적으로 사용됩니다</target>
        </trans-unit>
        <trans-unit id="137ab3c697e78f6f2e6deec928018a72318cf267" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;,</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="a2ba4249a4d1704d0e563fdfe0da86c2b5ffcda0" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, data goes to</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 데이터로 이동</target>
        </trans-unit>
        <trans-unit id="1cf94bbce32ce9a9a1f88a2545fed9e5441426cd" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, if</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 경우</target>
        </trans-unit>
        <trans-unit id="e02d7a3a20669ba308c919d34f684f48c01488d1" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, if the modality is set to &lt;a href=&quot;qt#WindowModality-enum&quot;&gt;Qt::WindowModal&lt;/a&gt; and the message box has a parent, then the message box will be a &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Sheet&lt;/a&gt;, otherwise the message box will be a standard dialog.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 모달로 설정되어있는 경우, &lt;a href=&quot;qt#WindowModality-enum&quot;&gt;Qt는 :: WindowModal&lt;/a&gt; 및 메시지 상자가 부모가, 다음 메시지 상자가 될 것입니다 &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt는 :: 시트&lt;/a&gt; 그렇지 않으면 메시지 상자는 표준 대화 상자가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="0881ce6136c22ae57b7049c765ec8e08e3b2c3f0" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, if you want your message box to appear as a &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt::Sheet&lt;/a&gt; of its</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 당신이 원하는 경우, 메시지 상자가로 표시하는 &lt;a href=&quot;qt#WindowType-enum&quot;&gt;Qt는 :: 시트&lt;/a&gt; 의 그것</target>
        </trans-unit>
        <trans-unit id="bdd25851047c8427f1ea42edfa248f6d340c43f9" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, it is not possible to unpair a device. If Unpaired is requested, &lt;a href=&quot;qbluetoothlocaldevice#pairingFinished&quot;&gt;pairingFinished&lt;/a&gt;() is immediately emitted although the device remains paired. It is possible to request the pairing for a previously unpaired device. In addition &lt;a href=&quot;qbluetoothlocaldevice#Pairing-enum&quot;&gt;AuthorizedPaired&lt;/a&gt; has the same behavior as &lt;a href=&quot;qbluetoothlocaldevice#Pairing-enum&quot;&gt;Paired&lt;/a&gt;.</source>
          <target state="translated">일 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 장치를 연결 해제 할 수 없다. Unpaired가 요청되면 장치가 페어링 된 상태로 남아 있지만 &lt;a href=&quot;qbluetoothlocaldevice#pairingFinished&quot;&gt;pairingFinished&lt;/a&gt; ()가 즉시 방출됩니다. 이전에 페어링되지 않은 장치에 대한 페어링을 요청할 수 있습니다. 또한 &lt;a href=&quot;qbluetoothlocaldevice#Pairing-enum&quot;&gt;AuthorizedPaired&lt;/a&gt; 는 &lt;a href=&quot;qbluetoothlocaldevice#Pairing-enum&quot;&gt;Paired&lt;/a&gt; 와 동일한 동작을 합니다.</target>
        </trans-unit>
        <trans-unit id="97ccb6feb705e423758172c8ff7ae512c93b6598" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, permissions to access settings not belonging to the current user (i.e. &lt;a href=&quot;qsettings#Scope-enum&quot;&gt;SystemScope&lt;/a&gt;) have changed with 10.7 (Lion). Prior to that version, users having admin rights could access these. For 10.7 and 10.8 (Mountain Lion), only root can. However, 10.9 (Mavericks) changes that rule again but only for the native format (plist files).</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 현재 사용자 (예에 속하지 않는 설정에 액세스 권한 &lt;a href=&quot;qsettings#Scope-enum&quot;&gt;SystemScope는&lt;/a&gt; ) 10.7 (사자)로 변경되었습니다. 해당 버전 이전에는 관리자 권한이있는 사용자가 이에 액세스 할 수있었습니다. 10.7 및 10.8 (마운틴 라이온)의 경우 루트 만 가능합니다. 그러나 10.9 (Mavericks)는 해당 규칙을 다시 변경하지만 기본 형식 (plist 파일)에 대해서만 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="c988eedd182f7aa69e779c11100a56d0e5217c5e" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, security flags are not supported and will be ignored.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 보안 플래그는 지원되지 않으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3daff32b3d70038ff27a9fff6456ce23c43ffd09" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, show the tool window even when the application is not active. By default, all tool windows are hidden when the application is inactive.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 응용 프로그램이 활성화되어 있지 않은 경우에도 도구 창을 보여줍니다. 기본적으로 응용 프로그램이 비활성화되면 모든 도구 창이 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="41bb25290e5ced6d2e4655900e8268895af65ec7" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, the Up/Down key bindings for Home/End are explicitly disabled. If you want such bindings (on any platform), you will need to construct them in QML.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 홈 / 엔드의 위 / 아래 키 바인딩은 명시 적으로 사용할 수 없습니다. 이러한 바인딩을 원하는 경우 (플랫폼에서) QML로 바인딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="d9360f7e65dc3917d81977d44c9e83bb1515131d" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, the about box is popped up as a modeless window; on other platforms, it is currently application modal.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 정보 상자는 모덜리스 창으로 팝업됩니다; 다른 플랫폼에서는 현재 응용 프로그램 모달입니다.</target>
        </trans-unit>
        <trans-unit id="ab3457bf26c7bbccfc755f084a6a734e19ac4bdd" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, the string returned resembles the sequence that is shown in the menu bar if</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 문자열과 유사에게 메뉴 바의 경우에 표시되는 순서를 반환</target>
        </trans-unit>
        <trans-unit id="3c209eddec42f62fe0b0847af7729ce53a32e681" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, the threaded render loop is not supported when building with XCode 10 (10.14 SDK) or later, since this opts in to layer-backed views on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 10.14. You can build with Xcode 9 (10.13 SDK) to opt out of layer-backing, in which case the threaded render loop is available and used by default.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 에 레이어 백업 뷰에이 OPTS 때문에, 나중에 엑스 코드 (10) (10.14 SDK) 또는 건물 때, 렌더 스레드 루프는 지원되지 않습니다 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 10.14. Xcode 9 (10.13 SDK)로 빌드하여 레이어 백업을 옵트 아웃 할 수 있습니다.이 경우 스레드 렌더링 루프를 사용할 수 있으며 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="20c8c82ed4737ad355dc66de46b9c968eba39f83" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, there is a difference between a window and view; normally expressed as widgets in Qt. Qt makes assumptions about its parent-child hierarchy that make it complex to put an arbitrary Qt widget into a hierarchy of &quot;normal&quot; views from Apple frameworks. &lt;a href=&quot;qmacnativewidget&quot;&gt;QMacNativeWidget&lt;/a&gt; bridges the gap between views and windows and makes it possible to put a hierarchy of Qt widgets into a non-Qt window or view.</source>
          <target state="translated">일 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 윈도우 및 뷰 사이의 차이가있다; 일반적으로 Qt에서 위젯으로 표시됩니다. Qt는 임의의 Qt 위젯을 Apple 프레임 워크의 &quot;정상&quot;뷰 계층 구조에 배치하기가 어려운 부모-자식 계층 구조를 가정합니다. &lt;a href=&quot;qmacnativewidget&quot;&gt;QMacNativeWidget&lt;/a&gt; 은보기와 창 사이의 간격을 메우고 Qt 위젯 계층을 Qt가 아닌 창이나보기에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4e9e1a6e0bd01c2b3df3d1e521de78fd87e87fc" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this corresponds to the Command keys.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 명령 키에이 해당한다.</target>
        </trans-unit>
        <trans-unit id="a03ef9a5a6ca2b6c7189ec951ef3efa94d47d173" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this corresponds to the Control keys. On Windows keyboards, this key is mapped to the Windows key.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 컨트롤 키에이 해당한다. Windows 키보드에서이 키는 Windows 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="0315922804130991e6d6ee4a53830a731f5ef05e" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this flag is always set to &lt;a href=&quot;qbluetooth#Security-enum&quot;&gt;QBluetooth::Secure&lt;/a&gt;.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; ,이 플래그는 항상로 설정되어 &lt;a href=&quot;qbluetooth#Security-enum&quot;&gt;QBluetooth :: 안전&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17ab0291187163bb381d29fb4917bd52100ce9ba" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this function will ignore the Proxy Auto Configuration settings, since it cannot execute the associated ECMAScript code.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 는 관련 인 ECMAScript 코드를 실행할 수 없기 때문에,이 기능은 프록시 자동 구성 설정을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="99de586dbee9328e2ad3dc83f95209b0bbbca885" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this function will obtain the proxy settings using the SystemConfiguration framework from Apple. It will apply the FTP, HTTP and HTTPS proxy configurations for queries that contain the protocol tag &quot;ftp&quot;, &quot;http&quot; and &quot;https&quot;, respectively. If the SOCKS proxy is enabled in that configuration, this function will use the SOCKS server for all queries. If SOCKS isn't enabled, it will use the HTTPS proxy for all TcpSocket and UrlRequest queries.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; ,이 기능은 애플에서에서 SystemConfiguration 프레임 워크를 사용하여 프록시 설정을 얻을 것이다. 프로토콜 태그 &quot;ftp&quot;, &quot;http&quot;및 &quot;https&quot;를 각각 포함하는 쿼리에 FTP, HTTP 및 HTTPS 프록시 구성을 적용합니다. 해당 구성에서 SOCKS 프록시가 사용 가능한 경우이 기능은 모든 조회에 SOCKS 서버를 사용합니다. SOCKS를 사용하지 않으면 모든 TcpSocket 및 UrlRequest 쿼리에 HTTPS 프록시를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9bd0075037d9af00366805910b74ee7b22c148a6" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this is currenly converted to a NSMenu, so the aboutToHide() signal is not emitted.</source>
          <target state="translated">일 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; aboutToHide () 신호가 방출되지 않도록,이 currenly하는 NSMenu로 변환된다.</target>
        </trans-unit>
        <trans-unit id="3e9b8a514ee8a5e1aefdd8de972ff8cbfed33d69" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this value is ignored as the platform does not permit access to the security parameter of the socket. By default the platform prefers secure/encrypted connections though and therefore this function always returns &lt;a href=&quot;qbluetooth#Security-enum&quot;&gt;QBluetooth::Secure&lt;/a&gt;.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 플랫폼이 소켓의 보안 매개 변수에 대한 액세스를 허용하지 않는 한,이 값은 무시됩니다. 기본적으로 플랫폼은 보안 / 암호화 된 연결을 선호 &lt;a href=&quot;qbluetooth#Security-enum&quot;&gt;하므로이&lt;/a&gt; 함수는 항상 QBluetooth :: Secure를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d46bca2f6d20f99c43e27ea2a02a87e7f1ccd8f5" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this works more at the application level and will cause the application icon to bounce in the dock.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; ,이 작품을 더 많은 응용 프로그램 수준에서 응용 프로그램 아이콘이 도크에 반송하게됩니다.</target>
        </trans-unit>
        <trans-unit id="ed641e37d6e60c795f761bd151b9333173ad7a4c" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;/iOS/tvOS CoreBluetooth does not expose/accept hardware addresses for LE devices; instead developers are supposed to use unique 128-bit UUIDs, generated by CoreBluetooth. These UUIDS will stay constant for the same central &amp;lt;-&amp;gt; peripheral pair and we use them when connecting to a remote device. For a controller in the &lt;a href=&quot;qlowenergycontroller#Role-enum&quot;&gt;CentralRole&lt;/a&gt;, this value will always be the one passed in when the controller object was created. For a controller in the &lt;a href=&quot;qlowenergycontroller#Role-enum&quot;&gt;PeripheralRole&lt;/a&gt;, this value is invalid.</source>
          <target state="translated">에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; / 아이폰 OS / tvOS CoreBluetooth은 / 노출 LE 장치의 하드웨어 주소를 허용하지 않습니다; 대신 개발자는 CoreBluetooth에서 생성 한 고유 한 128 비트 UUID를 사용해야합니다. 이 UUIDS는 동일한 중앙 &amp;lt;-&amp;gt; 주변 장치 쌍에 대해 일정하게 유지되며 원격 장치에 연결할 때 사용합니다. &lt;a href=&quot;qlowenergycontroller#Role-enum&quot;&gt;CentralRole&lt;/a&gt; 의 컨트롤러의 경우이 값은 항상 컨트롤러 개체를 만들 때 전달 된 값입니다. &lt;a href=&quot;qlowenergycontroller#Role-enum&quot;&gt;PeripheralRole&lt;/a&gt; 의 컨트롤러에 대해서는 이 값이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d1fc5e449dc389fccc7ea9794a709d546ef66a0" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::HoverEnter&lt;/a&gt; events, this position will always be &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;(-1, -1).</source>
          <target state="translated">에 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: HoverEnter의&lt;/a&gt; 이벤트,이 위치는 항상있을 것입니다 &lt;a href=&quot;qpoint&quot;&gt;의 QPoint&lt;/a&gt; (-1, -1).</target>
        </trans-unit>
        <trans-unit id="eca3159a31c71a6096451f0020afb882ea28272e" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::HoverEnter&lt;/a&gt; events, this position will always be &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;(-1, -1).</source>
          <target state="translated">에 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: HoverEnter의&lt;/a&gt; 이벤트,이 위치는 항상있을 것입니다 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; (-1, -1).</target>
        </trans-unit>
        <trans-unit id="5be8cee74ee586a968e595661b0504acbb74fb12" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::HoverLeave&lt;/a&gt; events, this position will always be &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;(-1, -1).</source>
          <target state="translated">에 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: HoverLeave의&lt;/a&gt; 이벤트,이 위치는 항상있을 것입니다 &lt;a href=&quot;qpoint&quot;&gt;의 QPoint&lt;/a&gt; (-1, -1).</target>
        </trans-unit>
        <trans-unit id="d6065b3aece372537d4f0991300b9b49a9d7091a" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::HoverLeave&lt;/a&gt; events, this position will always be &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;(-1, -1).</source>
          <target state="translated">에 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: HoverLeave의&lt;/a&gt; 이벤트,이 위치는 항상있을 것입니다 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; (-1, -1).</target>
        </trans-unit>
        <trans-unit id="274f958c0eae3155ea8914ca95a23815e0090326" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;qtwebengine-platform-notes#macos&quot;&gt;macOS&lt;/a&gt;, depending on how Qt WebEngine is configured at build time, there are two possibilities how spellchecking data is found:</source>
          <target state="translated">에 &lt;a href=&quot;qtwebengine-platform-notes#macos&quot;&gt;맥 OS&lt;/a&gt; , Qt는 WebEngine이 빌드시에 구성 방식에 따라, 맞춤법 검사 데이터를 발견하는 방법을 두 가지 가능성이있다 :</target>
        </trans-unit>
        <trans-unit id="312cfb23402492c9dba9019443c70a3da3229225" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt;, the default value is the value of the environment variable &lt;code&gt;UCRTVERSION&lt;/code&gt;.</source>
          <target state="translated">에 &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; , 디폴트 값은 환경 변수의 값입니다 &lt;code&gt;UCRTVERSION&lt;/code&gt; 은 .</target>
        </trans-unit>
        <trans-unit id="5248dab8a678e7827d8faf7dd52bc2a892f37839" translate="yes" xml:space="preserve">
          <source>On &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt;, this isn't relevant because the backend there always uses a composition swapchain which is associated with the ISwapChainPanel that backs &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; on that platform.</source>
          <target state="translated">에 &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; 백엔드가 항상 백업이있는 ISwapChainPanel와 연관된 구성 swapchain 사용하기 때문에, 이것은 관련이 없습니다 &lt;a href=&quot;qwindow&quot;&gt;QWindow&lt;/a&gt; 해당 플랫폼에 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e6478c9d4b1aea6bb2f93a9091144157062c962" translate="yes" xml:space="preserve">
          <source>On Android and &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtbluetooth-attribution-bluez.html#&quot;&gt;BlueZ&lt;/a&gt; (version 5.46 or above), a connection to a service can not be established using a port. Calling this function will emit a &lt;a href=&quot;qbluetoothsocket#SocketError-enum&quot;&gt;ServiceNotFoundError&lt;/a&gt;.</source>
          <target state="translated">Android 및 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtbluetooth-attribution-bluez.html#&quot;&gt;BlueZ&lt;/a&gt; (버전 5.46 이상)에서는 포트를 사용하여 서비스에 연결할 수 없습니다. 이 함수를 호출하면 &lt;a href=&quot;qbluetoothsocket#SocketError-enum&quot;&gt;ServiceNotFoundError가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="815f65d23f664d13f8648829ba0d4205930d38fa" translate="yes" xml:space="preserve">
          <source>On Android and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, it is not possible to retrieve a list of connected devices. It is only possible to listen to (dis)connect changes. For convenience, this class monitors all connect and disconnect events since its instanciation and returns the current list when calling this function. Therefore it is possible that this function returns an empty list shortly after creating an instance.</source>
          <target state="translated">Android 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서는 연결된 장치 목록을 검색 할 수 없습니다. 연결 변경 사항을들을 수 있습니다. 편의상이 클래스는 인스턴스화 이후 모든 연결 및 연결 끊기 이벤트를 모니터하고이 함수를 호출 할 때 현재 목록을 리턴합니다. 따라서이 함수는 인스턴스를 생성 한 직후 빈 목록을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19265de97bfc16b2f9ea0375c004e5540a968f5f" translate="yes" xml:space="preserve">
          <source>On Android and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this feature is not supported and returns 0.</source>
          <target state="translated">Android 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서이 기능은 지원되지 않으며 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="63fcd2d9c70d71102c353c1cb82e59375e7f08d8" translate="yes" xml:space="preserve">
          <source>On Android, Vulkan headers were added in API level 24 of the NDK.</source>
          <target state="translated">Android에서는 Vulkan 헤더가 NDK의 API 레벨 24에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="be4db8b98b4f6164235f4d89c54546ee114c1c59" translate="yes" xml:space="preserve">
          <source>On Android, apps are distributed in packages called</source>
          <target state="translated">Android에서 앱은</target>
        </trans-unit>
        <trans-unit id="dbc9aae4c83116bcdc68d109344ce9e60a8f4125" translate="yes" xml:space="preserve">
          <source>On Android, only RFCOMM connections are possible. This function ignores any socket protocol indicator and assumes RFCOMM.</source>
          <target state="translated">Android에서는 RFCOMM 연결 만 가능합니다. 이 기능은 모든 소켓 프로토콜 표시기를 무시하고 RFCOMM을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="770e981e9a4839b09d200fe33ae180ff79808d01" translate="yes" xml:space="preserve">
          <source>On Android, the local name cannot be changed. Android always uses the device name. If this local name is not empty, the Android implementation includes the device name in the advertisement packet; otherwise the device name is omitted from the advertisement packet.</source>
          <target state="translated">Android에서는 로컬 이름을 변경할 수 없습니다. Android는 항상 기기 이름을 사용합니다. 이 로컬 이름이 비어 있지 않으면 Android 구현은 광고 패킷에 장치 이름을 포함합니다. 그렇지 않으면 장치 이름이 보급 알림 패킷에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="f65b58aaa1b281afed9ed3918396f4b1bdf264b1" translate="yes" xml:space="preserve">
          <source>On Android, the service connection can directly be established using the UUID of the remote service. Therefore the platform does not require the &lt;a href=&quot;qbluetoothsocket#SocketState-enum&quot;&gt;ServiceLookupState&lt;/a&gt; and &lt;a href=&quot;qbluetoothsocket#socketType&quot;&gt;socketType&lt;/a&gt;() is always set to &lt;a href=&quot;qbluetoothserviceinfo#Protocol-enum&quot;&gt;QBluetoothServiceInfo::RfcommProtocol&lt;/a&gt;.</source>
          <target state="translated">Android에서는 원격 서비스의 UUID를 사용하여 서비스 연결을 직접 설정할 수 있습니다. 따라서 플랫폼은 필요하지 않습니다 &lt;a href=&quot;qbluetoothsocket#SocketState-enum&quot;&gt;ServiceLookupState&lt;/a&gt; 및 &lt;a href=&quot;qbluetoothsocket#socketType&quot;&gt;socketType이&lt;/a&gt; ()는 항상로 설정 &lt;a href=&quot;qbluetoothserviceinfo#Protocol-enum&quot;&gt;QBluetoothServiceInfo :: RfcommProtocol을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d89c9874989e9b8b9d98b80e3b3a534396717417" translate="yes" xml:space="preserve">
          <source>On Android, this timeout is not adjustable and therefore ignored.</source>
          <target state="translated">Android에서는이 시간 제한을 조정할 수 없으므로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6416a86402f10d7bee16b446d89f7c5bff574c53" translate="yes" xml:space="preserve">
          <source>On Bluez this property is set to &lt;a href=&quot;qbluetooth#Security-enum&quot;&gt;QBluetooth::Authorization&lt;/a&gt; by default.</source>
          <target state="translated">Bluez에서이 속성은 기본적 으로 &lt;a href=&quot;qbluetooth#Security-enum&quot;&gt;QBluetooth :: Authorization&lt;/a&gt; 으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="38be6ebf6ed6321d81be56cae6640824c62d19dc" translate="yes" xml:space="preserve">
          <source>On Embedded Linux and X11 platforms, parts of this class rely on code obtained under the following licenses:</source>
          <target state="translated">임베디드 Linux 및 X11 플랫폼에서이 클래스의 일부는 다음 라이센스에 따라 얻은 코드에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="39517387790a4ddc25d1fee2b8ee49b79463ca57" translate="yes" xml:space="preserve">
          <source>On Embedded Linux systems that do not have their terminal sessions disabled, the behavior on a key press can be confusing as input event is processed by the Qt application and the tty. To overcome this, the following options are available:</source>
          <target state="translated">터미널 세션을 비활성화하지 않은 내장 Linux 시스템에서는 입력 이벤트가 Qt 응용 프로그램 및 tty에 의해 처리 될 때 키 누름 동작이 혼동 될 수 있습니다. 이를 극복하기 위해 다음 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1903a3af5f94e99f63f667d5b59e51dbaf4f5865" translate="yes" xml:space="preserve">
          <source>On Embedded Linux systems, there are multiple platform plugins that you can use: EGLFS, &lt;a href=&quot;#linuxfb&quot;&gt;LinuxFB&lt;/a&gt;, DirectFB, or Wayland. However, the availability of these plugins depend on how Qt is configured.</source>
          <target state="translated">임베디드 Linux 시스템에는 EGLFS, &lt;a href=&quot;#linuxfb&quot;&gt;LinuxFB&lt;/a&gt; , DirectFB 또는 Wayland 와 같이 사용할 수있는 여러 플랫폼 플러그인이 있습니다 . 그러나 이러한 플러그인의 가용성은 Qt 구성 방법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="11d7dd25953d11e666864822cf6e9d7877cb7d94" translate="yes" xml:space="preserve">
          <source>On Linux systems, it will try to determine the distribution version and will return that. This is also done on Debian/kFreeBSD, so this function will return Debian version in that case.</source>
          <target state="translated">Linux 시스템에서는 배포 버전을 확인하려고 시도하고이를 반환합니다. 이것은 Debian / kFreeBSD에서도 수행되므로이 ​​경우 데비안 버전을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="050fee7dfb12508ea2f91e1c95c371c4d9b0ee6e" translate="yes" xml:space="preserve">
          <source>On Linux, Clang or GCC version 5 or later is required. Supported configurations are &lt;code&gt;linux-g++&lt;/code&gt; and &lt;code&gt;linux-clang&lt;/code&gt;.</source>
          <target state="translated">Linux에서는 Clang 또는 GCC 버전 5 이상이 필요합니다. 지원되는 구성은 &lt;code&gt;linux-g++&lt;/code&gt; 및 &lt;code&gt;linux-clang&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c6db7933f7885ae873ea9d6b85de74fc5c4be3e7" translate="yes" xml:space="preserve">
          <source>On Linux, Qt Bluetooth uses a separate executable, &lt;code&gt;sdpscanner&lt;/code&gt;, to integrate with the official Linux bluetooth protocol stack &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtbluetooth-attribution-bluez.html#&quot;&gt;BlueZ&lt;/a&gt;. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtbluetooth-attribution-bluez.html#&quot;&gt;BlueZ&lt;/a&gt; is available under the &lt;a href=&quot;http://www.gnu.org/licenses/gpl-2.0.html&quot;&gt;GNU General Public License, version 2&lt;/a&gt;.</source>
          <target state="translated">Linux에서 Qt Bluetooth는 별도의 실행 파일 인 &lt;code&gt;sdpscanner&lt;/code&gt; 를 사용하여 공식 Linux Bluetooth 프로토콜 스택 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtbluetooth-attribution-bluez.html#&quot;&gt;BlueZ&lt;/a&gt; 와 통합합니다 . &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtbluetooth-attribution-bluez.html#&quot;&gt;BlueZ&lt;/a&gt; 는 &lt;a href=&quot;http://www.gnu.org/licenses/gpl-2.0.html&quot;&gt;GNU General Public License, version 2&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2b3f797e33b6ce2d5f62a1251736f6421be715d" translate="yes" xml:space="preserve">
          <source>On Linux, Windows and Apple platforms, this value is usually the time since the system boot, though it usually does not include the time the system has spent in sleep states.</source>
          <target state="translated">Linux, Windows 및 Apple 플랫폼에서이 값은 일반적으로 시스템 부팅 이후의 시간이지만 일반적으로 시스템이 휴면 상태에서 소비 한 시간은 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9868f3840fcc2cfb72fa85ed6470a1c5286ad448" translate="yes" xml:space="preserve">
          <source>On Linux, retrieving the volume's label requires &lt;code&gt;udev&lt;/code&gt; to be present in the system.</source>
          <target state="translated">Linux에서 볼륨 레이블을 검색하려면 시스템에 &lt;code&gt;udev&lt;/code&gt; 가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="860b940943efd67e5351c2fa69ea361b0a647f4f" translate="yes" xml:space="preserve">
          <source>On Linux, the</source>
          <target state="translated">Linux에서</target>
        </trans-unit>
        <trans-unit id="48890158ae2cda54f400fa9db2242f01fbca64c4" translate="yes" xml:space="preserve">
          <source>On Linux, the kernel has to support the anonymous namespaces feature (kernel version &amp;gt;= 3.8) and seccomp-bpf feature (kernel version &amp;gt;= 3.5). Setuid sandboxes are not supported and are thus disabled.</source>
          <target state="translated">Linux에서 커널은 익명 네임 스페이스 기능 (커널 버전&amp;gt; = 3.8) 및 seccomp-bpf 기능 (커널 버전&amp;gt; = 3.5)을 지원해야합니다. Setuid 샌드 박스는 지원되지 않으므로 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="e18810d4ece678f4372cf474aca3fc209ebfc264" translate="yes" xml:space="preserve">
          <source>On Linux/&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtbluetooth-attribution-bluez.html#&quot;&gt;BlueZ&lt;/a&gt; systems, it is not possible to connect to the same remote device using two instances of this class. The second call to this function may fail with an error. This limitation may be removed in future releases.</source>
          <target state="translated">Linux / &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtbluetooth-attribution-bluez.html#&quot;&gt;BlueZ&lt;/a&gt; 시스템에서는이 클래스의 두 인스턴스를 사용하여 동일한 원격 장치에 연결할 수 없습니다. 이 함수에 대한 두 번째 호출은 오류와 함께 실패 할 수 있습니다. 이 제한은 향후 릴리스에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be86cf8677a1438eaed02b537278783288f434af" translate="yes" xml:space="preserve">
          <source>On Mac, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; uses &lt;a href=&quot;qcoreapplication#organizationDomain-prop&quot;&gt;organizationDomain()&lt;/a&gt; as the organization if it's not an empty string; otherwise it uses organizationName(). On all other platforms, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; uses organizationName() as the organization.</source>
          <target state="translated">Mac에서 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 는 빈 문자열이 아닌 경우 &lt;a href=&quot;qcoreapplication#organizationDomain-prop&quot;&gt;organizationDomain ()&lt;/a&gt; 을 조직으로 사용 합니다. 그렇지 않으면 organizationName ()을 사용합니다. 다른 모든 플랫폼에서 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 는 organizationName ()을 조직으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fdcac537267b374784eb9ce033e40b4e0eb5764c" translate="yes" xml:space="preserve">
          <source>On Mac, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; uses organizationDomain() as the organization if it's not an empty string; otherwise it uses &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;organizationName&lt;/a&gt;(). On all other platforms, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; uses &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;organizationName&lt;/a&gt;() as the organization.</source>
          <target state="translated">Mac에서 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 는 빈 문자열이 아닌 경우 organizationDomain ()을 조직으로 사용합니다. 그렇지 않으면 &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;organizationName&lt;/a&gt; ()을 사용 합니다 . 다른 모든 플랫폼에서 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 는 &lt;a href=&quot;qcoreapplication#organizationName-prop&quot;&gt;organizationName&lt;/a&gt; ()을 조직으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="936548b28a7b4a6e49bd38e06c550258eed3eeba" translate="yes" xml:space="preserve">
          <source>On Microsoft Windows, mouse wheel usage is always handled by the widget that has keyboard focus. On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and X11, it's handled by the widget that gets other mouse events.</source>
          <target state="translated">Microsoft Windows에서 마우스 휠 사용은 항상 키보드 포커스가있는 위젯에 의해 처리됩니다. 에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; 와 X11, 그것은 다른 마우스 이벤트를 가져옵니다 위젯에 의해 처리합니다.</target>
        </trans-unit>
        <trans-unit id="104b5202331c5da26bf22f5bad018a37e0ceda3c" translate="yes" xml:space="preserve">
          <source>On UNIX (including Linux, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, and iOS), Qt will keep millisecond accuracy for Qt::PreciseTimer. For Qt::CoarseTimer, the interval will be adjusted up to 5% to align the timer with other timers that are expected to fire at or around the same time. The objective is to make most timers wake up at the same time, thereby reducing CPU wakeups and power consumption.</source>
          <target state="translated">UNIX (Linux, &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 및 iOS 포함)에서 Qt는 Qt :: PreciseTimer의 밀리 초 정확도를 유지합니다. Qt :: CoarseTimer의 경우 간격이 최대 5 %로 조정되어 타이머가 동시에 또는 거의 동시에 발생할 것으로 예상되는 다른 타이머와 타이머를 정렬합니다. 목표는 대부분의 타이머를 동시에 깨우 게하여 CPU 깨우기와 전력 소비를 줄이는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9e6bc2903e79f45ee2f81d86c0a91d5d49c7139a" translate="yes" xml:space="preserve">
          <source>On Unix (including &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; and iOS), the symlink has the same &lt;a href=&quot;qfileinfo#size&quot;&gt;size&lt;/a&gt;() has the file it points to, because Unix handles symlinks transparently; similarly, opening a symlink using &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; effectively opens the link's target. For example:</source>
          <target state="translated">유닉스 ( &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 및 iOS 포함)에서 심볼릭 링크의 &lt;a href=&quot;qfileinfo#size&quot;&gt;크기&lt;/a&gt; ()는 파일이 가리키는 파일 과 동일 합니다 . Unix는 심볼릭 링크를 투명하게 처리하기 때문입니다. 마찬가지로 &lt;a href=&quot;qfile&quot;&gt;QFile을&lt;/a&gt; 사용하여 심볼릭 링크를 열면 링크 대상이 효과적으로 열립니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6601c6c8c0ed07a385aac8cf7d5f6cad57fb84e" translate="yes" xml:space="preserve">
          <source>On Unix and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; (replace &lt;code&gt;$SQLITE&lt;/code&gt; with the directory where &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; resides):</source>
          <target state="translated">Unix 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; ( &lt;code&gt;$SQLITE&lt;/code&gt; 을 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsql-attribution-sqlite.html#sqlite&quot;&gt;SQLite&lt;/a&gt; 가있는 디렉토리로 대체 ) :</target>
        </trans-unit>
        <trans-unit id="f17af98e38048982a6ae01200dfc2f8c351686df" translate="yes" xml:space="preserve">
          <source>On Unix filesystems, the root volume is a volume mounted on &lt;code&gt;/&lt;/code&gt;. On Windows, the root volume is the volume where the OS is installed.</source>
          <target state="translated">Unix 파일 시스템에서 루트 볼륨은 &lt;code&gt;/&lt;/code&gt; 에 마운트 된 볼륨입니다 . Windows에서 루트 볼륨은 OS가 설치된 볼륨입니다.</target>
        </trans-unit>
        <trans-unit id="bace692e6aba923077fe382f0c0ab904a3051d37" translate="yes" xml:space="preserve">
          <source>On Unix systems this call returns the root ('/') volume; in Windows the volume where the operating system is installed.</source>
          <target state="translated">유닉스 시스템에서이 호출은 루트 ( '/') 볼륨을 반환합니다. Windows에서는 운영 체제가 설치된 볼륨입니다.</target>
        </trans-unit>
        <trans-unit id="fbccf7366e1baa7565e0b1f8d2ddc72d16e641ba" translate="yes" xml:space="preserve">
          <source>On Unix systems, a binary cache is used for more performance. This cache is generated by the command &quot;update-mime-database path&quot;, where path would be /opt/myapp/share/mime in the above example. Make sure to run this command when installing the MIME type definition file.</source>
          <target state="translated">Unix 시스템에서는 성능 향상을 위해 이진 캐시가 사용됩니다. 이 캐시는 &quot;update-mime-database path&quot;명령으로 생성되며 여기서 위의 경로는 / opt / myapp / share / mime입니다. MIME 유형 정의 파일을 설치할 때이 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e4cb0eaa6ed531dabf48c928b44a40335b561e57" translate="yes" xml:space="preserve">
          <source>On Unix systems, if the file format is &lt;a href=&quot;qsettings#Format-enum&quot;&gt;NativeFormat&lt;/a&gt;, the following files are used by default:</source>
          <target state="translated">Unix 시스템에서 파일 형식이 &lt;a href=&quot;qsettings#Format-enum&quot;&gt;NativeFormat&lt;/a&gt; 인 경우 기본적으로 다음 파일이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="93ba505e997dfa29c95903bafb91601da153ec19" translate="yes" xml:space="preserve">
          <source>On Unix systems, the variable names are case-sensitive. Note that the Unix environment allows both variable names and contents to contain arbitrary binary data (except for the NUL character). &lt;a href=&quot;qprocessenvironment&quot;&gt;QProcessEnvironment&lt;/a&gt; will preserve such variables, but does not support manipulating variables whose names or values cannot be encoded by the current locale settings (see &lt;a href=&quot;qtextcodec#codecForLocale&quot;&gt;QTextCodec::codecForLocale&lt;/a&gt;).</source>
          <target state="translated">Unix 시스템에서 변수 이름은 대소 문자를 구분합니다. Unix 환경에서는 변수 이름과 내용 모두 임의의 이진 데이터를 포함 할 수 있습니다 (NUL 문자 제외). &lt;a href=&quot;qprocessenvironment&quot;&gt;QProcessEnvironment&lt;/a&gt; 는 이러한 변수를 유지하지만 현재 로케일 설정으로 이름 또는 값을 인코딩 할 수없는 변수 조작을 지원하지 않습니다 ( &lt;a href=&quot;qtextcodec#codecForLocale&quot;&gt;QTextCodec :: codecForLocale&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="11fd2ef57d776661880d860224f2b7e6a97d35df" translate="yes" xml:space="preserve">
          <source>On Unix the absolute path will always begin with the root, '/', directory. On Windows this will always begin 'D:/' where D is a drive letter, except for network shares that are not mapped to a drive letter, in which case the path will begin '//sharename/'.</source>
          <target state="translated">유닉스에서 절대 경로는 항상 루트 '/', 디렉토리로 시작합니다. Windows에서는 항상 'D : /'로 시작합니다. 여기서 D는 드라이브 문자에 매핑되지 않은 네트워크 공유를 제외하고 드라이브 문자입니다.이 경우 경로는 '// sharename /'으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1e3b98776696cf1f7c4fdcd2ef4da38ddb1d19f1" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; is set to</source>
          <target state="translated">유닉스에서 &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="f6b62d543e73f8db440c1c3ba2771570a56bf10a" translate="yes" xml:space="preserve">
          <source>On Unix, NativeFormat and IniFormat mean the same thing, except that the file extension is different (&lt;code&gt;.conf&lt;/code&gt; for NativeFormat, &lt;code&gt;.ini&lt;/code&gt; for IniFormat).</source>
          <target state="translated">Unix에서 NativeFormat과 IniFormat은 파일 확장자가 다릅니다 ( NativeFormat의 경우 &lt;code&gt;.conf&lt;/code&gt; , IniFormat의 경우 &lt;code&gt;.ini&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="09c58f46dccacecb57866673b0c94614f0721a76" translate="yes" xml:space="preserve">
          <source>On Unix, there are some special system files (e.g. in &lt;code&gt;/proc&lt;/code&gt;) for which &lt;a href=&quot;qfile#size&quot;&gt;size&lt;/a&gt;() will always return 0, yet you may still be able to read more data from such a file; the data is generated in direct response to you calling &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt;(). In this case, however, you cannot use &lt;a href=&quot;qfiledevice#atEnd&quot;&gt;atEnd&lt;/a&gt;() to determine if there is more data to read (since &lt;a href=&quot;qfiledevice#atEnd&quot;&gt;atEnd&lt;/a&gt;() will return true for a file that claims to have size 0). Instead, you should either call &lt;a href=&quot;qiodevice#readAll&quot;&gt;readAll&lt;/a&gt;(), or call &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt;() or &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt;() repeatedly until no more data can be read. The next example uses &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; to read &lt;code&gt;/proc/modules&lt;/code&gt; line by line:</source>
          <target state="translated">Unix에는 &lt;a href=&quot;qfile#size&quot;&gt;size&lt;/a&gt; ()가 항상 0을 반환 하는 특수 시스템 파일 (예 : &lt;code&gt;/proc&lt;/code&gt; ) 이 있지만 여전히 이러한 파일에서 더 많은 데이터를 읽을 수 있습니다. &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt; () 호출에 대한 직접적인 응답으로 데이터가 생성됩니다 . 그러나이 경우 &lt;a href=&quot;qfiledevice#atEnd&quot;&gt;atEnd&lt;/a&gt; ()를 사용 하여 읽을 데이터가 더 있는지 판별 할 수 없습니다 ( &lt;a href=&quot;qfiledevice#atEnd&quot;&gt;atEnd&lt;/a&gt; ()는 크기가 0이라고 주장하는 파일에 대해 true를 리턴하므로). 대신 더 이상 데이터를 읽을 수 없을 때까지 &lt;a href=&quot;qiodevice#readAll&quot;&gt;readAll&lt;/a&gt; ()을 호출하거나 &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt; () 또는 &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt; ()을 반복해서 호출해야합니다 . 다음 예제는 &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt; 을 사용 하여 &lt;code&gt;/proc/modules&lt;/code&gt; 를 한 줄씩 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="0602921fc400588e0a70165d9faf3eaf62f0752d" translate="yes" xml:space="preserve">
          <source>On Unix, this function currently always returns the same as &lt;a href=&quot;qnetworkinterface#name&quot;&gt;name&lt;/a&gt;(), since Unix systems don't store a configuration for human-readable names.</source>
          <target state="translated">Unix에서이 함수는 현재 항상 &lt;a href=&quot;qnetworkinterface#name&quot;&gt;name&lt;/a&gt; () 과 동일하게 반환됩니다. Unix 시스템은 사람이 읽을 수있는 이름에 대한 구성을 저장하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="687c99b02f8e40a7be8b68d5fe13db95f6a22e8d" translate="yes" xml:space="preserve">
          <source>On Unix, this sets the executable flag.</source>
          <target state="translated">유닉스에서는 실행 플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c5a6786599b2cdaef1671f8f5d1e3f31e3b9479c" translate="yes" xml:space="preserve">
          <source>On Unix/Linux Qt is configured to use the system locale settings by default. This can cause a conflict when using POSIX functions, for instance, when converting between data types such as floats and strings, since the notation may differ between locales. To get around this problem, call the POSIX function &lt;code&gt;setlocale(LC_NUMERIC,&quot;C&quot;)&lt;/code&gt; right after initializing &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt;, &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; or &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; to reset the locale that is used for number formatting to &quot;C&quot;-locale.</source>
          <target state="translated">Unix / Linux에서 Qt는 기본적으로 시스템 로케일 설정을 사용하도록 구성되어 있습니다. 로케일마다 표기법이 다를 수 있으므로 POSIX 함수를 사용할 때 예를 들어 부동 소수점 및 문자열과 같은 데이터 유형 간 변환시 충돌이 발생할 수 있습니다. 이 문제를 해결하려면 &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; , &lt;a href=&quot;qguiapplication&quot;&gt;QGuiApplication&lt;/a&gt; 또는 &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; 을 초기화 한 직후 POSIX 함수 &lt;code&gt;setlocale(LC_NUMERIC,&quot;C&quot;)&lt;/code&gt; 호출하여 숫자 형식에 사용되는 로케일을 &quot;C&quot;-로케일로 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0eee08701b37711b726bc5c326a520a7795b78a1" translate="yes" xml:space="preserve">
          <source>On Unix/Linux systems this is the path in the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable or &lt;code&gt;/tmp&lt;/code&gt; if &lt;code&gt;TMPDIR&lt;/code&gt; is not defined. On Windows this is usually the path in the &lt;code&gt;TEMP&lt;/code&gt; or &lt;code&gt;TMP&lt;/code&gt; environment variable. The path returned by this method doesn't end with a directory separator unless it is the root directory (of a drive).</source>
          <target state="translated">Unix / Linux 시스템에서이 경로는 &lt;code&gt;TMPDIR&lt;/code&gt; 환경 변수 의 경로 이거나 &lt;code&gt;TMPDIR&lt;/code&gt; 이 정의되지 않은 경우 &lt;code&gt;/tmp&lt;/code&gt; 입니다. Windows에서 이는 일반적으로 &lt;code&gt;TEMP&lt;/code&gt; 또는 &lt;code&gt;TMP&lt;/code&gt; 환경 변수 의 경로입니다 . 이 메소드가 리턴 한 경로는 디렉토리 분리기가 드라이브의 루트 디렉토리가 아닌 경우 디렉토리 분리 자로 끝나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3844b76c72de9814ba134528a2e98ebfade0de2" translate="yes" xml:space="preserve">
          <source>On Unix/X11, the normal behavior of the file dialog is to resolve and follow symlinks. For example, if &lt;code&gt;/usr/tmp&lt;/code&gt; is a symlink to &lt;code&gt;/var/tmp&lt;/code&gt;, the file dialog will change to &lt;code&gt;/var/tmp&lt;/code&gt; after entering &lt;code&gt;/usr/tmp&lt;/code&gt;. If</source>
          <target state="translated">Unix / X11에서 파일 대화 상자의 일반적인 동작은 심볼릭 링크를 해결하고 따르는 것입니다. 예를 들어, &lt;code&gt;/usr/tmp&lt;/code&gt; 있는 심볼릭 링크로 &lt;code&gt;/var/tmp&lt;/code&gt; 파일 대화 상자가 변경됩니다에 &lt;code&gt;/var/tmp&lt;/code&gt; 입력 한 후 &lt;code&gt;/usr/tmp&lt;/code&gt; . 만약</target>
        </trans-unit>
        <trans-unit id="946affb9561bc980c61b450f36bafb68b8cc7412" translate="yes" xml:space="preserve">
          <source>On Unix/X11, the normal behavior of the file dialog is to resolve and follow symlinks. For example, if &lt;code&gt;/usr/tmp&lt;/code&gt; is a symlink to &lt;code&gt;/var/tmp&lt;/code&gt;, the file dialog will change to &lt;code&gt;/var/tmp&lt;/code&gt; after entering &lt;code&gt;/usr/tmp&lt;/code&gt;. The</source>
          <target state="translated">Unix / X11에서 파일 대화 상자의 일반적인 동작은 심볼릭 링크를 해결하고 따르는 것입니다. 예를 들어, &lt;code&gt;/usr/tmp&lt;/code&gt; 있는 심볼릭 링크로 &lt;code&gt;/var/tmp&lt;/code&gt; 파일 대화 상자가 변경됩니다에 &lt;code&gt;/var/tmp&lt;/code&gt; 입력 한 후 &lt;code&gt;/usr/tmp&lt;/code&gt; . 그만큼</target>
        </trans-unit>
        <trans-unit id="8790ba2d042320ac0ff89cc6fbfd713e3f294b72" translate="yes" xml:space="preserve">
          <source>On Windows Vista and above grabbing a layered window, which is created by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_TranslucentBackground&lt;/a&gt; attribute, will not work. Instead grabbing the desktop widget should work.</source>
          <target state="translated">Windows Vista 이상에서 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_TranslucentBackground&lt;/a&gt; 속성 을 설정하여 만든 계층화 된 창을 가져 오면 작동하지 않습니다. 대신 데스크탑 위젯을 잡아야합니다.</target>
        </trans-unit>
        <trans-unit id="1d0e589073490d5159cfe11285c50f7a1f85db9b" translate="yes" xml:space="preserve">
          <source>On Windows and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; the page setup dialog is implemented using the native page setup dialogs.</source>
          <target state="translated">Windows 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서 페이지 설정 대화 상자는 기본 페이지 설정 대화 상자를 사용하여 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="153b1e39841abcf2158fa5299c7935bc61f925b4" translate="yes" xml:space="preserve">
          <source>On Windows and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, the native print dialog is used, which means that some &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; and &lt;a href=&quot;qdialog&quot;&gt;QDialog&lt;/a&gt; properties set on the dialog won't be respected. The native print dialog on &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; does not support setting printer options, i.e. &lt;a href=&quot;qprintdialog#options-prop&quot;&gt;setOptions&lt;/a&gt;() and &lt;a href=&quot;qprintdialog#setOption&quot;&gt;setOption&lt;/a&gt;() have no effect.</source>
          <target state="translated">Windows 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서는 기본 인쇄 대화 상자가 사용 되므로 대화 상자에 설정된 일부 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 및 &lt;a href=&quot;qdialog&quot;&gt;QDialog&lt;/a&gt; 속성이 적용되지 않습니다. &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 의 기본 인쇄 대화 상자는 프린터 옵션 설정을 지원하지 않습니다. 즉 &lt;a href=&quot;qprintdialog#options-prop&quot;&gt;setOptions&lt;/a&gt; () 및 &lt;a href=&quot;qprintdialog#setOption&quot;&gt;setOption&lt;/a&gt; ()은 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9fb552f0c6ee026f6a2d5cdf2c2faba130e66307" translate="yes" xml:space="preserve">
          <source>On Windows and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this static function will use the native file dialog and not a &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;. However, the native Windows file dialog does not support displaying files in the directory chooser. You need to pass &lt;a href=&quot;qfiledialog#Option-enum&quot;&gt;DontUseNativeDialog&lt;/a&gt; to display files using a &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;.</source>
          <target state="translated">Windows 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서이 정적 함수는 &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog가&lt;/a&gt; 아닌 기본 파일 대화 상자를 사용합니다 . 그러나 기본 Windows 파일 대화 상자는 디렉토리 선택기에 파일 표시를 지원하지 않습니다. 당신은 전달해야 &lt;a href=&quot;qfiledialog#Option-enum&quot;&gt;DontUseNativeDialog을&lt;/a&gt; 사용하여 표시 파일을 &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a70298dd5c537a10885dffc0b4796cc69c26b290" translate="yes" xml:space="preserve">
          <source>On Windows and Mac, this locale will use the decimal/grouping characters and date/time formats specified in the system configuration panel.</source>
          <target state="translated">Windows 및 Mac에서이 로케일은 시스템 구성 패널에 지정된 10 진수 / 그룹화 문자 및 날짜 / 시간 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d9517590c1b7334224700261590c3cf915514625" translate="yes" xml:space="preserve">
          <source>On Windows and Mac, this option can be changed while printing and will take effect from the next call to &lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt;().</source>
          <target state="translated">Windows 및 Mac에서이 옵션은 인쇄하는 동안 변경 될 수 있으며 다음에 &lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt; ()를 호출 할 때 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a5d18eab9424efb8eb9d67b73f2554a661d53b8d" translate="yes" xml:space="preserve">
          <source>On Windows and on systems where files do not have groups this function always returns (uint) -2.</source>
          <target state="translated">Windows 및 파일에 그룹이없는 시스템에서이 기능은 항상 (uint) -2를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="79144f75391086deffcb8615df18ab19f80fdaf7" translate="yes" xml:space="preserve">
          <source>On Windows and on systems where files do not have owners this function returns ((uint) -2).</source>
          <target state="translated">Windows 및 파일에 소유자가없는 시스템에서이 함수는 ((uint) -2)를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="32afade7d47abda738aacc3512c2b30ffaabeca2" translate="yes" xml:space="preserve">
          <source>On Windows platforms, this function may take several seconds to execute depending on the configuration of the user's system.</source>
          <target state="translated">Windows 플랫폼에서이 기능은 사용자 시스템 구성에 따라 몇 초가 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5aecee188c7f1b1294a2d0e762ebebb7959f0ca" translate="yes" xml:space="preserve">
          <source>On Windows systems, the clock overflows after 2^32 milliseconds, which corresponds to roughly 49.7 days. This means two processes' reckoning of the time since the reference may be different by multiples of 2^32 milliseconds. When comparing such values, it's recommended that the high 32 bits of the millisecond count be masked off.</source>
          <target state="translated">Windows 시스템에서 시계는 2 ^ 32 밀리 초 후에 오버플로되며 이는 대략 49.7 일에 해당합니다. 이는 기준이 2 ^ 32 밀리 초의 배수로 다를 수 있기 때문에 두 프로세스의 시간 계산을 의미합니다. 이러한 값을 비교할 때는 밀리 초 카운트의 상위 32 비트를 마스킹하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4438b8406b08ce691061664d1b8e89e958e240ba" translate="yes" xml:space="preserve">
          <source>On Windows the dialog will spin a blocking modal event loop that will not dispatch any QTimers, and if</source>
          <target state="translated">Windows에서 대화 상자는 QTimers를 전달하지 않는 차단 모달 이벤트 루프를 회전시킵니다.</target>
        </trans-unit>
        <trans-unit id="d60ef4abd5ddf2ac11833e853cd9b3a90a8a9a4c" translate="yes" xml:space="preserve">
          <source>On Windows this ID is translated from the Windows ID using an internal translation table and the user's selected country. As a consequence there is a small chance any Windows install may have IDs not known by Qt, in which case &quot;UTC&quot; will be returned.</source>
          <target state="translated">Windows에서이 ID는 내부 변환 테이블과 사용자가 선택한 국가를 사용하여 Windows ID에서 변환됩니다. 결과적으로 Windows 설치에 Qt에 의해 알려지지 않은 ID가있을 가능성이 적습니다.이 경우 &quot;UTC&quot;가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0f5bb54d8a742f78761067d364ae5dee864e5618" translate="yes" xml:space="preserve">
          <source>On Windows this is a named pipe and on Unix this is a local domain socket.</source>
          <target state="translated">Windows에서 이것은 명명 된 파이프이고 Unix에서 이것은 로컬 도메인 소켓입니다.</target>
        </trans-unit>
        <trans-unit id="173484095c13480d2e28bd6242bb96dbc6170feb" translate="yes" xml:space="preserve">
          <source>On Windows this returns a list of &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; objects containing &quot;C:/&quot;, &quot;D:/&quot;, etc. On other operating systems, it returns a list containing just one root directory (i.e. &quot;/&quot;).</source>
          <target state="translated">Windows에서는 &quot;C : /&quot;, &quot;D : /&quot;등을 포함하는 &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; 객체 의 목록을 반환합니다 . 다른 운영 체제에서는 루트 디렉토리가 하나만 포함 된 목록 (예 : &quot;/&quot;)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d081113f7df8bc79a1aef37cb9f1492bed7c99fc" translate="yes" xml:space="preserve">
          <source>On Windows,</source>
          <target state="translated">Windows에서는</target>
        </trans-unit>
        <trans-unit id="2f9f91efe038a9e14ae2e98d9d2d49df516d2ec0" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;qcommandlineparser&quot;&gt;QCommandLineParser&lt;/a&gt; uses message boxes to display usage information and errors if no console window can be obtained.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;qcommandlineparser&quot;&gt;QCommandLineParser&lt;/a&gt; 는 콘솔 창을 확보 할 수없는 경우 메시지 상자를 사용하여 사용 정보 및 오류를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7aaacc0a16e055c426abc12b5c974f97f3a6cc14" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;qlocalserver#SocketOption-enum&quot;&gt;UserAccessOption&lt;/a&gt; is sufficient to allow a non elevated process to connect to a local server created by an elevated process run by the same user. &lt;a href=&quot;qlocalserver#SocketOption-enum&quot;&gt;GroupAccessOption&lt;/a&gt; refers to the primary group of the process (see TokenPrimaryGroup in the Windows documentation). &lt;a href=&quot;qlocalserver#SocketOption-enum&quot;&gt;OtherAccessOption&lt;/a&gt; refers to the well known &quot;Everyone&quot; group.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;qlocalserver#SocketOption-enum&quot;&gt;UserAccessOption&lt;/a&gt; 은 비 높은 프로세스가 동일한 사용자가 실행하는 높은 프로세스로 작성된 로컬 서버에 연결하기에 충분합니다. &lt;a href=&quot;qlocalserver#SocketOption-enum&quot;&gt;GroupAccessOption&lt;/a&gt; 은 프로세스의 기본 그룹을 나타냅니다 (Windows 설명서의 TokenPrimaryGroup 참조). &lt;a href=&quot;qlocalserver#SocketOption-enum&quot;&gt;OtherAccessOption&lt;/a&gt; 은 잘 알려진 &quot;모두&quot;그룹을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7657792c855355b2e1bf8322e309cc98bee5fb9b" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;qmimedata#formats&quot;&gt;formats&lt;/a&gt;() will also return custom formats available in the MIME data, using the &lt;code&gt;x-qt-windows-mime&lt;/code&gt; subtype to indicate that they represent data in non-standard formats. The formats will take the following form:</source>
          <target state="translated">Windows에서 &lt;a href=&quot;qmimedata#formats&quot;&gt;형식&lt;/a&gt; ()은 &lt;code&gt;x-qt-windows-mime&lt;/code&gt; 하위 유형을 사용하여 MIME 데이터에서 사용 가능한 사용자 지정 형식을 반환하여 비표준 형식의 데이터를 나타냅니다. 형식은 다음 형식을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="1d34b7d36338db117c47d6d8a642c55e9be69ad9" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; uses the Win32 API function &lt;code&gt;CreateProcess&lt;/code&gt; to start child processes. While &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; provides a comfortable way to start processes without worrying about platform details, it is in some cases desirable to fine-tune the parameters that are passed to &lt;code&gt;CreateProcess&lt;/code&gt;. This is done by defining a &lt;code&gt;CreateProcessArgumentModifier&lt;/code&gt; function and passing it to &lt;code&gt;setCreateProcessArgumentsModifier&lt;/code&gt;.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; 는 Win32 API 함수 &lt;code&gt;CreateProcess&lt;/code&gt; 를 사용하여 하위 프로세스를 시작합니다. &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; 는 플랫폼 세부 사항에 대해 걱정하지 않고 프로세스를 시작하는 편안한 방법을 제공 하지만 &lt;code&gt;CreateProcess&lt;/code&gt; 로 전달되는 매개 변수를 미세 조정하는 것이 바람직한 경우도 있습니다. 이것은 &lt;code&gt;CreateProcessArgumentModifier&lt;/code&gt; 함수 이를 &lt;code&gt;setCreateProcessArgumentsModifier&lt;/code&gt; 에 전달하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="6211efcbbb8b3d6c4e6c2ffb8fe77c3c3f76389c" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; lets you access settings that have been written with &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; (or settings in a supported format, e.g., string data) in the system registry. This is done by constructing a &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; object with a path in the registry and &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings::NativeFormat&lt;/a&gt;.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;qsettings&quot;&gt;QSettings를&lt;/a&gt; 사용하면 시스템 레지스트리에서 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 로 작성된 설정 (또는 지원되는 형식 (예 : 문자열 데이터) 설정)에 액세스 할 수 있습니다 . 이것은&lt;a href=&quot;qsettings&quot;&gt;&lt;/a&gt;레지스트리의 경로와 &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings :: NativeFormat을 사용&lt;/a&gt; QSettings 객체를 됩니다.</target>
        </trans-unit>
        <trans-unit id="bd0c88cc322d1d15cf5b6bfab2befeec4005d8b4" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;qsettings#Format-enum&quot;&gt;NativeFormat&lt;/a&gt; settings are stored in the following registry paths:</source>
          <target state="translated">Windows에서는 &lt;a href=&quot;qsettings#Format-enum&quot;&gt; NativeFormat&lt;/a&gt; 설정은 다음 레지스트리 경로에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="c9f6224e430c62533d0c15d70a2952272d66f0c4" translate="yes" xml:space="preserve">
          <source>On Windows, Linux and Unix with FontConfig (client side font support) the following languages are also supported:</source>
          <target state="translated">FontConfig (클라이언트 측 글꼴 지원)가있는 Windows, Linux 및 Unix에서는 다음 언어도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8ec750030fc86c431fc0cc22d96c707066b1bf1d" translate="yes" xml:space="preserve">
          <source>On Windows, Linux, and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, Qt WebView depends on the &lt;a href=&quot;qtwebengine-index&quot;&gt;Qt WebEngine&lt;/a&gt; module to render content.</source>
          <target state="translated">Windows, Linux 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서 Qt WebView는 컨텐츠를 렌더링하기 위해 &lt;a href=&quot;qtwebengine-index&quot;&gt;Qt WebEngine&lt;/a&gt; 모듈 에 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="36084b6a38d0046457329edc1ce7035a57de9ca1" translate="yes" xml:space="preserve">
          <source>On Windows, Qt can be configured with the system OpenGL or with &lt;a href=&quot;https://chromium.googlesource.com/angle/angle/+/master/README.md#&quot;&gt;ANGLE&lt;/a&gt;. By default, Qt is configured to use dynamic OpenGL. This means that it tries to use system OpenGL and falls back to ANGLE, which is bundled with Qt and depends on the DirectX SDK, if native OpenGL does not work. ANGLE enables running Qt applications that depend on OpenGL, without installing the latest OpenGL drivers. If ANGLE also fails, Qt will fall back to software rendering, which is the slowest but most safe of the rendering methods.</source>
          <target state="translated">Windows에서 Qt는 시스템 OpenGL 또는 &lt;a href=&quot;https://chromium.googlesource.com/angle/angle/+/master/README.md#&quot;&gt;ANGLE&lt;/a&gt; 로 구성 할 수 있습니다 . 기본적으로 Qt는 동적 OpenGL을 사용하도록 구성되어 있습니다. 이것은 시스템 OpenGL을 사용하려고 시도하고 Qt에 번들로 제공되는 ANGLE로 폴백하며 기본 OpenGL이 작동하지 않는 경우 DirectX SDK에 의존합니다. ANGLE을 사용하면 최신 OpenGL 드라이버를 설치하지 않고도 OpenGL에 의존하는 Qt 응용 프로그램을 실행할 수 있습니다. ANGLE도 실패하면 Qt는 렌더링 방법 중 가장 느리지 만 가장 안전한 소프트웨어 렌더링으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="86cb408cc7a3276abc43d23f5e1d0e4694746fda" translate="yes" xml:space="preserve">
          <source>On Windows, Qt will use Windows's Multimedia timer facility (if available) for Qt::PreciseTimer and normal Windows timers for Qt::CoarseTimer and Qt::VeryCoarseTimer.</source>
          <target state="translated">Windows에서 Qt는 Qt :: PreciseTimer에 Windows의 멀티미디어 타이머 기능 (사용 가능한 경우)을 사용하고 Qt :: CoarseTimer 및 Qt :: VeryCoarseTimer에 일반 Windows 타이머를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5f6c67b3c388f495ed43d8c62ac9b5423438cb1b" translate="yes" xml:space="preserve">
          <source>On Windows, Visual Studio 2017 and Windows 10 SDK are required.</source>
          <target state="translated">Windows에서는 Visual Studio 2017 및 Windows 10 SDK가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b94e7d980488a2cafad803911d11239698908891" translate="yes" xml:space="preserve">
          <source>On Windows, an ODBC driver manager should be installed by default. For Unix systems, there are some implementations which must be installed first. Note that every end user of your application is required to have an ODBC driver manager installed, otherwise the QODBC plugin will not work.</source>
          <target state="translated">Windows에서는 기본적으로 ODBC 드라이버 관리자가 설치되어 있어야합니다. 유닉스 시스템의 경우, 먼저 설치해야하는 구현이 있습니다. 응용 프로그램의 모든 최종 사용자는 ODBC 드라이버 관리자를 설치해야합니다. 그렇지 않으면 QODBC 플러그인이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a046a49eb862192bc389c249bdcd0b52a2654ed" translate="yes" xml:space="preserve">
          <source>On Windows, and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, this static function will use the native file dialog and not a &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog&lt;/a&gt;.</source>
          <target state="translated">Windows 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서이 정적 함수는 &lt;a href=&quot;qfiledialog&quot;&gt;QFileDialog가&lt;/a&gt; 아닌 기본 파일 대화 상자를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0a8742992833152e679e7ac230e6cd6497be0b03" translate="yes" xml:space="preserve">
          <source>On Windows, everything goes to a &quot;qttest&quot; directory under Application Data.</source>
          <target state="translated">Windows에서는 모든 것이 Application Data 아래의 &quot;qttest&quot;디렉토리로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="41e4b76e5497497f0e910648c84c8b22896c2a3d" translate="yes" xml:space="preserve">
          <source>On Windows, if the format is &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings::NativeFormat&lt;/a&gt;, the return value is a system registry path, not a file path.</source>
          <target state="translated">Windows에서 형식이 &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings :: NativeFormat&lt;/a&gt; 인 경우 리턴 값은 파일 경로가 아닌 시스템 레지스트리 경로입니다.</target>
        </trans-unit>
        <trans-unit id="19db6fa9c0e6ecdb9dc3ed8c0e4c8646568b7e81" translate="yes" xml:space="preserve">
          <source>On Windows, if the process was terminated with TerminateProcess() from another application, this function will still return &lt;a href=&quot;qprocess#ExitStatus-enum&quot;&gt;NormalExit&lt;/a&gt; unless the exit code is less than 0.</source>
          <target state="translated">Windows에서 프로세스가 다른 애플리케이션에서 TerminateProcess ()로 종료 된 경우 종료 코드가 0보다 &lt;a href=&quot;qprocess#ExitStatus-enum&quot;&gt;작지&lt;/a&gt; 않으면 이 함수는 여전히 NormalExit를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="f4de3ffade0f14541e5fc34016a77889d9f60f1d" translate="yes" xml:space="preserve">
          <source>On Windows, if you are calling this when the application is not currently the active one then it will not make it the active window. It will change the color of the taskbar entry to indicate that the window has changed in some way. This is because Microsoft does not allow an application to interrupt what the user is currently doing in another application.</source>
          <target state="translated">Windows에서 응용 프로그램이 현재 활성화되어 있지 않을 때 이것을 호출하면 응용 프로그램을 활성 창으로 만들지 않습니다. 작업 표시 줄 항목의 색상이 변경되어 창이 변경되었음을 나타냅니다. Microsoft가 사용자가 다른 응용 프로그램에서 현재하고있는 작업을 응용 프로그램이 중단하도록 허용하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="575d9b3a78af0da2b74620b3d569a1bc8e316a74" translate="yes" xml:space="preserve">
          <source>On Windows, it is possible for a key to have both a value and subkeys. Its default value is accessed by using &quot;Default&quot; or &quot;.&quot; in place of a subkey:</source>
          <target state="translated">Windows에서는 키에 값과 하위 키가 모두있을 수 있습니다. 기본값은 &quot;Default&quot;또는 &quot;.&quot;를 사용하여 액세스합니다. 하위 키 대신 :</target>
        </trans-unit>
        <trans-unit id="789849527f55dd326ab8965b01a0cd4e3d42c782" translate="yes" xml:space="preserve">
          <source>On Windows, it returns the volume letter in case the volume is not mounted to a directory.</source>
          <target state="translated">Windows에서는 볼륨이 디렉토리에 마운트되지 않은 경우 볼륨 문자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6f45ef2557d2763eeb9ce7f467fe135973457929" translate="yes" xml:space="preserve">
          <source>On Windows, kill() uses TerminateProcess, and on Unix and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, the SIGKILL signal is sent to the process.</source>
          <target state="translated">Windows에서 kill ()은 TerminateProcess를 사용하고 Unix 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서는 SIGKILL 신호가 프로세스로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="be08508e87dfb9c0df0e01746b667cf36cea0b24" translate="yes" xml:space="preserve">
          <source>On Windows, sets the printer resolution to that defined for the printer in use. For PDF printing, sets the resolution of the PDF driver to 1200 dpi.</source>
          <target state="translated">Windows에서는 프린터 해상도를 사용중인 프린터에 정의 된 해상도로 설정합니다. PDF 인쇄의 경우 PDF 드라이버의 해상도를 1200dpi로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="14d9e4ccb9a6bff1ad352d4396e5ff42f362bb10" translate="yes" xml:space="preserve">
          <source>On Windows, symlinks (shortcuts) are &lt;code&gt;.lnk&lt;/code&gt; files. The reported &lt;a href=&quot;qfileinfo#size&quot;&gt;size&lt;/a&gt;() is that of the symlink (not the link's target), and opening a symlink using &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; opens the &lt;code&gt;.lnk&lt;/code&gt; file. For example:</source>
          <target state="translated">Windows에서 심볼릭 링크 (바로 가기)는 &lt;code&gt;.lnk&lt;/code&gt; 파일입니다. 보고 된 &lt;a href=&quot;qfileinfo#size&quot;&gt;크기&lt;/a&gt; ()는 링크의 대상이 아닌 심볼릭 링크의 크기 이며 &lt;a href=&quot;qfile&quot;&gt;QFile을&lt;/a&gt; 사용하여 심볼릭 링크를 열면 &lt;code&gt;.lnk&lt;/code&gt; 파일이 열립니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="894c53cc3aa9870814680f88a38324b2cbcc4b60" translate="yes" xml:space="preserve">
          <source>On Windows, terminate() posts a WM_CLOSE message to all top-level windows of the process and then to the main thread of the process itself. On Unix and &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; the &lt;code&gt;SIGTERM&lt;/code&gt; signal is sent.</source>
          <target state="translated">Windows에서 terminate ()는 프로세스의 모든 최상위 창에 WM_CLOSE 메시지를 게시 한 다음 프로세스 자체의 기본 스레드에 게시합니다. Unix 및 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 에서는 &lt;code&gt;SIGTERM&lt;/code&gt; 신호가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="c023ed2fa00db5821f38f2a7733300b417f3e3d0" translate="yes" xml:space="preserve">
          <source>On Windows, the</source>
          <target state="translated">Windows에서는</target>
        </trans-unit>
        <trans-unit id="50b76eb87355aa84c9f176e1e2fa2a2d4e2b8c28" translate="yes" xml:space="preserve">
          <source>On Windows, the MIME format does not always map directly to the clipboard formats. Qt provides &lt;a href=&quot;qwinmime&quot;&gt;QWinMime&lt;/a&gt; to map clipboard formats to open-standard MIME formats. Similarly, the &lt;a href=&quot;qmacpasteboardmime&quot;&gt;QMacPasteboardMime&lt;/a&gt; maps MIME to Mac flavors.</source>
          <target state="translated">Windows에서 MIME 형식이 항상 클립 보드 형식으로 직접 매핑되는 것은 아닙니다. Qt는 &lt;a href=&quot;qwinmime&quot;&gt;QWinMime&lt;/a&gt; 을 제공 하여 클립 보드 형식을 공개 표준 MIME 형식으로 매핑 합니다 . 마찬가지로 &lt;a href=&quot;qmacpasteboardmime&quot;&gt;QMacPasteboardMime&lt;/a&gt; 은 MIME을 Mac 맛에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="c9d9f0d80797bfabd82eb565989c14db0a2d588d" translate="yes" xml:space="preserve">
          <source>On Windows, the SDK sets the environment variable &lt;code&gt;VULKAN_SDK&lt;/code&gt;, which will be detected by the &lt;code&gt;configure&lt;/code&gt; script.</source>
          <target state="translated">Windows에서 SDK는 환경 변수 &lt;code&gt;VULKAN_SDK&lt;/code&gt; 를 설정 하며이 변수 는 &lt;code&gt;configure&lt;/code&gt; 스크립트에 의해 감지됩니다 .</target>
        </trans-unit>
        <trans-unit id="3dd65d4ac7293575c89dbbc61edd2fa3c9540a48" translate="yes" xml:space="preserve">
          <source>On Windows, the dialog will spin a blocking modal event loop that will not dispatch any QTimers, and if</source>
          <target state="translated">Windows에서 대화 상자는 QTimers를 전달하지 않는 차단 모달 이벤트 루프를 회전시킵니다.</target>
        </trans-unit>
        <trans-unit id="070069766453e3eb3bc17c26dcc40196783ed1a2" translate="yes" xml:space="preserve">
          <source>On Windows, the following files are used:</source>
          <target state="translated">Windows에서는 다음 파일이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="357070b8ee3d0513c5e8e0a083173878f3a0115d" translate="yes" xml:space="preserve">
          <source>On Windows, the installation binaries provided by LLVM do not include &lt;code&gt;llvm-config&lt;/code&gt;. You may still have it on your system, if you have built LLVM yourself from source. If that is the case, and you want to let the build system find Clang automatically, add the path to &lt;code&gt;llvm-config&lt;/code&gt; to your &lt;code&gt;PATH&lt;/code&gt; environment variable. For example:</source>
          <target state="translated">Windows에서 LLVM이 제공하는 설치 바이너리에는 &lt;code&gt;llvm-config&lt;/code&gt; 가 포함되지 않습니다 . 소스에서 직접 LLVM을 빌드 한 경우 시스템에 여전히있을 수 있습니다. 그 경우, 당신은 빌드 시스템이 자동으로 연타를 찾을 경로 추가 할 수 있도록하려면 &lt;code&gt;llvm-config&lt;/code&gt; 사용자에 &lt;code&gt;PATH&lt;/code&gt; 의 환경 변수입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c1657afc1bc02dca1b80b856b5ed6552a224065" translate="yes" xml:space="preserve">
          <source>On Windows, the list is built from the argc and argv parameters only if modified argv/argc parameters are passed to the constructor. In that case, encoding problems might occur.</source>
          <target state="translated">Windows에서 수정 된 argv / argc 매개 변수가 생성자에 전달되는 경우에만 argc 및 argv 매개 변수로 목록이 작성됩니다. 이 경우 인코딩 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30bdeaf7adcfd048228bfae9a8c9c60cf24a9435" translate="yes" xml:space="preserve">
          <source>On Windows, the returned value is a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms740522(v=vs.85).aspx&quot;&gt;Winsock 2 Socket Handle&lt;/a&gt;.</source>
          <target state="translated">Windows에서 리턴 된 값은 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms740522(v=vs.85).aspx&quot;&gt;Winsock 2 Socket Handle&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8a57532f83aee4223bce412df8949bba23b8bbe1" translate="yes" xml:space="preserve">
          <source>On Windows, the second example above will be translated to &lt;code&gt;C:\Documents and Settings&lt;/code&gt; when used to access files.</source>
          <target state="translated">Windows에서 위의 두 번째 예는 파일에 액세스 할 때 &lt;code&gt;C:\Documents and Settings&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="c821ce0a17f8bc969c387de22bee5900320ead8a" translate="yes" xml:space="preserve">
          <source>On Windows, the system tray icon size is 16x16; on X11, the preferred size is 22x22. The icon will be scaled to the appropriate size as necessary.</source>
          <target state="translated">Windows에서 시스템 트레이 아이콘 크기는 16x16입니다. X11에서 기본 크기는 22x22입니다. 필요에 따라 아이콘 크기가 적절한 크기로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="6fa2dea46c7c5f0f1f0cbdcde22e07fe259c0a30" translate="yes" xml:space="preserve">
          <source>On Windows, the variable names are case-insensitive, but case-preserving. &lt;a href=&quot;qprocessenvironment&quot;&gt;QProcessEnvironment&lt;/a&gt; behaves accordingly.</source>
          <target state="translated">Windows에서 변수 이름은 대소 문자를 구분하지 않지만 대소 문자를 유지합니다. &lt;a href=&quot;qprocessenvironment&quot;&gt;QProcessEnvironment가&lt;/a&gt; 그에 따라 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b5b32a2cff36ed3a8a335860a856ed4c4634f194" translate="yes" xml:space="preserve">
          <source>On Windows, this causes the window's taskbar entry to flash for a time. If</source>
          <target state="translated">Windows에서는 이로 인해 창의 작업 표시 줄 항목이 한동안 깜박입니다. 만약</target>
        </trans-unit>
        <trans-unit id="7ad2a1df3d377f75556f4b4104f12737db507920" translate="yes" xml:space="preserve">
          <source>On Windows, this function does nothing; on Unix, it removes the socket file given by</source>
          <target state="translated">Windows에서이 기능은 아무 것도 수행하지 않습니다. 유닉스에서는 다음과 같이 주어진 소켓 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="09eae3a8474264613a1bb0546b833063ce47363e" translate="yes" xml:space="preserve">
          <source>On Windows, this function returns the type of Windows kernel, like &quot;winnt&quot;. On Unix systems, it returns the same as the output of &lt;code&gt;uname -s&lt;/code&gt; (lowercased).</source>
          <target state="translated">Windows에서이 함수는 &quot;winnt&quot;와 같은 Windows 커널 유형을 리턴합니다. Unix 시스템에서는 &lt;code&gt;uname -s&lt;/code&gt; (소문자) 의 출력과 동일한 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7d6249275f9fbc46af397c053e27c8e82ae55f49" translate="yes" xml:space="preserve">
          <source>On Windows, this function will use the WinHTTP DLL functions. Despite its name, Microsoft suggests using it for all applications that require network connections, not just HTTP. This will respect the proxy settings set on the registry with the proxycfg.exe tool. If those settings are not found, this function will attempt to obtain Internet Explorer's settings and use them.</source>
          <target state="translated">Windows에서이 기능은 WinHTTP DLL 기능을 사용합니다. 그 이름에도 불구하고 Microsoft는 HTTP뿐만 아니라 네트워크 연결이 필요한 모든 응용 프로그램에 사용하는 것이 좋습니다. 이는 proxycfg.exe 도구를 사용하여 레지스트리에 설정된 프록시 설정을 준수합니다. 해당 설정을 찾지 못하면이 기능은 Internet Explorer의 설정을 가져 와서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="009e0df97f2e5d4e01405a88357006f9f19e7723" translate="yes" xml:space="preserve">
          <source>On Windows, this returns the drives visible in the &lt;b&gt;My Computer&lt;/b&gt; folder. On Unix operating systems, it returns the list of all mounted filesystems (except for pseudo filesystems).</source>
          <target state="translated">Windows에서는 &lt;b&gt;내 컴퓨터&lt;/b&gt; 폴더에 표시된 드라이브를 반환 합니다. Unix 운영 체제에서는 마운트 된 모든 파일 시스템 목록을 반환합니다 (의사 파일 시스템 제외).</target>
        </trans-unit>
        <trans-unit id="0936561a0967352768bfbc841c656154826ca8d9" translate="yes" xml:space="preserve">
          <source>On Windows, this value is used when the ownership of the D&amp;amp;D data should be taken over by the target application, i.e., the source application should not delete the data. On X11 this value is used to do a move. TargetMoveAction is not used on the Mac.</source>
          <target state="translated">Windows에서이 값은 대상 애플리케이션이 D &amp;amp; D 데이터의 소유권을 인계해야하는 경우에 사용됩니다. 즉, 소스 애플리케이션은 데이터를 삭제하지 않아야합니다. X11에서이 값은 이동을 수행하는 데 사용됩니다. Mac에서는 TargetMoveAction이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4eee6c744c3777dbddff6484cd65a374f2977b75" translate="yes" xml:space="preserve">
          <source>On Windows, toNativeSeparators(&quot;c:/winnt/system32&quot;) returns &quot;c:\winnt\system32&quot;.</source>
          <target state="translated">Windows에서 toNativeSeparators ( &quot;c : / winnt / system32&quot;)는 &quot;c : \ winnt \ system32&quot;를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6fb53d8edcc5cae3f92a646a3ff9898177717167" translate="yes" xml:space="preserve">
          <source>On Windows, triggers auto-generation of an .rc file if the &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; and &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; variables are not set. The generated .rc file will have the FILEVERSION and PRODUCTVERSION entries filled with major, minor, patch level, and build number. Each number must be in the range from 0 to 65535. More details about the generation of .rc files can be found in the &lt;a href=&quot;qmake-platform-notes#&quot;&gt;Platform Notes&lt;/a&gt;.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;#rc-file&quot;&gt;RC_FILE&lt;/a&gt; 및 &lt;a href=&quot;#res-file&quot;&gt;RES_FILE&lt;/a&gt; 변수가 설정되지 않은 경우 .rc 파일의 자동 생성을 트리거합니다 . 생성 된 .rc 파일에는 FILEVERSION 및 PRODUCTVERSION 항목이 주, 부, 패치 레벨 및 빌드 번호로 채워집니다. 각 숫자의 범위는 0에서 65535 사이 여야합니다. .rc 파일 생성에 대한 자세한 내용은 &lt;a href=&quot;qmake-platform-notes#&quot;&gt;플랫폼 노트를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7804dbafb95752380b7a75defcc7241f6d49bcef" translate="yes" xml:space="preserve">
          <source>On Windows, when the KeyDown event for this key is sent, the Ctrl+Alt modifiers are also set.</source>
          <target state="translated">Windows에서이 키의 KeyDown 이벤트가 전송되면 Ctrl + Alt 수정 자도 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="730b836d8881154172539b5edb8b7c3bd51ef995" translate="yes" xml:space="preserve">
          <source>On Windows, when the Windows system registry is used, &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; does not preserve the original type of the value. Therefore, the type of the value might change when a new value is set. For example, a value with type &lt;code&gt;REG_EXPAND_SZ&lt;/code&gt; will change to &lt;code&gt;REG_SZ&lt;/code&gt;.</source>
          <target state="translated">Windows에서 Windows 시스템 레지스트리가 사용될 때 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 는 원래 유형의 값을 유지하지 않습니다. 따라서 새 값이 설정되면 값 유형이 변경 될 수 있습니다. 예를 들어, &lt;code&gt;REG_EXPAND_SZ&lt;/code&gt; 유형의 값은 &lt;code&gt;REG_SZ&lt;/code&gt; 로 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">Windows에서 :</target>
        </trans-unit>
        <trans-unit id="38bff627717e84c4edabc4f72056215a56db78a2" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to &quot;Calculator&quot; (XF86XK_Calculator) key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 &quot;계산기&quot;(XF86XK_Calculator) 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="eb011980df49c4979891a410f0db4938cb3a60ae" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to &quot;My Computer&quot; (XF86XK_MyComputer) key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 &quot;내 컴퓨터&quot;(XF86XK_MyComputer) 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="1bfe3c4f8fe5bd9ee3a20c50dccea55489cf6b63" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch0 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch0 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="38110747083a8ebebaf5bf2227de795089502230" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch1 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch1 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="b433e57774b23b1fba9ac94ebed25e6c5098b77e" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch2 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch2 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="215b19cd3792ab1e486526f2d225ecf7872a3a68" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch3 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch3 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="b6eba023acc8788fb39359621ce09415b381e3bb" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch4 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch4 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="044e49228d4ec744fae5846dcd722959672c193d" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch5 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch5 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="176c13710f95a8daaef6f59eb59cd96fe3499fa1" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch6 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch6 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="49ed2cc9414463eb9e5c87ff2895b838b0927830" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch7 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch7 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="eebef0fa1c574243e457f228b23d8b747720e57a" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch8 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch8 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="8973833e72301ced8eca68397f583495d93f340f" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_Launch9 key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_Launch9 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="a9cda10da6811c461130577bf71c1b62570896a4" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_LaunchA key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_LaunchA 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="993b0f9701007d991189241d64f74b997482bcaf" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_LaunchB key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_LaunchB 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="edf8b286ee85c0b86bad62052749b94265fdc9c6" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_LaunchC key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_LaunchC 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="282a7579d151d39c6224732c8fd9e0e00d5e6878" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_LaunchD key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_LaunchD 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="0d49d72dc7b9cad7ec0bd39bc7e8903b3e9d0eb8" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_LaunchE key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_LaunchE 키에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="c3399a59cc479f88fd5846b477a3d2bbce888eeb" translate="yes" xml:space="preserve">
          <source>On X11 this key is mapped to XF86XK_LaunchF key for legacy reasons.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 XF86XK_LaunchF 키에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="cf05a551e29074459d59198f9285d4acca8fe607" translate="yes" xml:space="preserve">
          <source>On X11 this key is not mapped for legacy reasons. Use Qt::Key_Launch1 instead.</source>
          <target state="translated">X11에서이 키는 레거시 이유로 매핑되지 않습니다. Qt :: Key_Launch1을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ca4b93013030e6ab4726dc905a308d068ce1d21e" translate="yes" xml:space="preserve">
          <source>On X11,</source>
          <target state="translated">X11에서는</target>
        </trans-unit>
        <trans-unit id="9b6fe6b086079c230da14348db2af20226d626fc" translate="yes" xml:space="preserve">
          <source>On X11, Qt supports the &lt;a href=&quot;http://www.xfree86.org/4.3.0/Xcursor.3.html#&quot;&gt;Xcursor&lt;/a&gt; library, which allows for full color icon themes. The table below shows the cursor name used for each &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt::CursorShape&lt;/a&gt; value. If a cursor cannot be found using the name shown below, a standard X11 cursor will be used instead. Note: X11 does not provide appropriate cursors for all possible &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt::CursorShape&lt;/a&gt; values. It is possible that some cursors will be taken from the Xcursor theme, while others will use an internal bitmap cursor.</source>
          <target state="translated">X11에서 Qt는 풀 &lt;a href=&quot;http://www.xfree86.org/4.3.0/Xcursor.3.html#&quot;&gt;커버&lt;/a&gt; 아이콘 테마를 허용 하는 Xcursor 라이브러리를 지원합니다 . 아래 표는 각 &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt :: CursorShape&lt;/a&gt; 값에 사용되는 커서 이름을 보여줍니다 . 아래 표시된 이름으로 커서를 찾을 수 없으면 표준 X11 커서가 대신 사용됩니다. 참고 : X11은 가능한 모든 &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt :: CursorShape&lt;/a&gt; 값에 적절한 커서를 제공하지 않습니다 . 일부 커서는 Xcursor 테마에서 가져 오는 반면 다른 커서는 내부 비트 맵 커서를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f66a29a941a3f1c1178fa1f4051ed7633dcc7944" translate="yes" xml:space="preserve">
          <source>On X11, a window does not have a frame until the window manager decorates it. This happens asynchronously at some point in time after calling &lt;a href=&quot;qwidget#show&quot;&gt;QWidget::show&lt;/a&gt;() and the first paint event the window receives, or it does not happen at all. Bear in mind that X11 is policy-free (others call it flexible). Thus you cannot make any safe assumption about the decoration frame your window will get. Basic rule: There's always one user who uses a window manager that breaks your assumption, and who will complain to you.</source>
          <target state="translated">X11에서는 창 관리자가 장식 할 때까지 창에 프레임이 없습니다. 이것은 &lt;a href=&quot;qwidget#show&quot;&gt;QWidget :: show&lt;/a&gt; ()를 호출 한 후 특정 시점에서 비동기 적으로 발생 하며 윈도우가 수신하는 첫 번째 페인트 이벤트이거나 전혀 발생하지 않습니다. X11은 정책이 필요 없습니다 (다른 사람들은 유연하다고 부릅니다). 따라서 창을 가져올 장식 프레임에 대해 안전한 가정을 할 수 없습니다. 기본 규칙 : 항상 가정 관리자를 사용하여 가정을 어 기고 불만을 제기하는 사용자는 한 명입니다.</target>
        </trans-unit>
        <trans-unit id="74bd622a9f5b268193d42ed1193ac4712fc8aefe" translate="yes" xml:space="preserve">
          <source>On X11, if not set, the fallback icon theme depends on your desktop settings. On other platforms it is not set by default.</source>
          <target state="translated">X11에서 설정하지 않은 경우 대체 아이콘 테마는 데스크탑 설정에 따라 다릅니다. 다른 플랫폼에서는 기본적으로 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54da02e1730b21efd6d44aefe3448beb691d16ba" translate="yes" xml:space="preserve">
          <source>On X11, it is also possible to draw on the desktop.</source>
          <target state="translated">X11에서는 바탕 화면에 그릴 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad44e1dbefcc93a469ce1e22bfadbf193d474b6d" translate="yes" xml:space="preserve">
          <source>On X11, the current icon theme depends on your desktop settings. On other platforms it is not set by default.</source>
          <target state="translated">X11에서 현재 아이콘 테마는 데스크탑 설정에 따라 다릅니다. 다른 플랫폼에서는 기본적으로 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="984489ecfc83d609f42ecee5acbf6bd8aa4e72cd" translate="yes" xml:space="preserve">
          <source>On X11, the document name is for example used as the default output filename in &lt;a href=&quot;qprintdialog&quot;&gt;QPrintDialog&lt;/a&gt;. Note that the document name does not affect the file name if the printer is printing to a file. Use the setOutputFile() function for this.</source>
          <target state="translated">X11에서 문서 이름은 예를 들어 &lt;a href=&quot;qprintdialog&quot;&gt;QPrintDialog&lt;/a&gt; 에서 기본 출력 파일 이름으로 사용됩니다 . 프린터가 파일로 인쇄하는 경우 문서 이름은 파일 이름에 영향을주지 않습니다. 이를 위해 setOutputFile () 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f27fe241c6c987ddd4ff6638b2510debe04bb5c0" translate="yes" xml:space="preserve">
          <source>On X11, the public &lt;a href=&quot;http://www.newplanetsoftware.com/xdnd/&quot;&gt;XDND protocol&lt;/a&gt; is used, while on Windows Qt uses the OLE standard, and Qt for &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; uses the Cocoa Drag Manager. On X11, XDND uses MIME, so no translation is necessary. The Qt API is the same regardless of the platform. On Windows, MIME-aware applications can communicate by using clipboard format names that are MIME types. Already some Windows applications use MIME naming conventions for their clipboard formats.</source>
          <target state="translated">X11에서는 공개 &lt;a href=&quot;http://www.newplanetsoftware.com/xdnd/&quot;&gt;XDND 프로토콜&lt;/a&gt; 이 사용되는 반면 Windows Qt는 OLE 표준을 사용하고 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS 용&lt;/a&gt; Qt 는 Cocoa Drag Manager를 사용합니다. X11에서 XDND는 MIME을 사용하므로 변환이 필요하지 않습니다. Qt API는 플랫폼에 관계없이 동일합니다. Windows에서 MIME 인식 응용 프로그램은 MIME 유형 인 클립 보드 형식 이름을 사용하여 통신 할 수 있습니다. 이미 일부 Windows 응용 프로그램은 클립 보드 형식에 MIME 명명 규칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="746576bc1b84c50d9a8e7498467d0d47eb363722" translate="yes" xml:space="preserve">
          <source>On X11, the search path will use the XDG_DATA_DIRS environment variable if available.</source>
          <target state="translated">X11에서 검색 경로는 사용 가능한 경우 XDG_DATA_DIRS 환경 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a9074f202c6877dc2505a9ae7cf75c9f51f7cbf3" translate="yes" xml:space="preserve">
          <source>On X11, this function may not work properly with certain window managers. See the &lt;a href=&quot;application-windows#window-geometry&quot;&gt;Window Geometry&lt;/a&gt; documentation for an explanation.</source>
          <target state="translated">X11에서는이 기능이 특정 창 관리자에서 제대로 작동하지 않을 수 있습니다. 설명은 &lt;a href=&quot;application-windows#window-geometry&quot;&gt;Window Geometry&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca8a7c2c378269fc18338fdfb24d9563e2b0b997" translate="yes" xml:space="preserve">
          <source>On X11, this function sets the program to call with the PDF output. On other platforms, it has no effect.</source>
          <target state="translated">X11에서이 기능은 프로그램이 PDF 출력으로 호출하도록 설정합니다. 다른 플랫폼에서는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="378efc0cfc3a063ee9441da0010f98a74ba38499" translate="yes" xml:space="preserve">
          <source>On X11, this will cause the window to be marked as &quot;demands attention&quot;, the window must not be hidden (i.e. not have hide() called on it, but be visible in some sort of way) in order for this to work.</source>
          <target state="translated">X11에서는 이로 인해 창에 &quot;주의가 필요함&quot;으로 표시됩니다.이 작업을 수행하려면 창을 숨기지 않아야합니다 (즉, hide ()를 호출하지 말고 어떤 방식으로 볼 수 있어야 함).</target>
        </trans-unit>
        <trans-unit id="ce39c3052ac1f59f934bd2a1073483ba593e315a" translate="yes" xml:space="preserve">
          <source>On a Windows system with LLVM installed to &lt;code&gt;C:\Program Files\LLVM&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;C:\Program Files\LLVM&lt;/code&gt; LLVM이 설치된 Windows 시스템 :</target>
        </trans-unit>
        <trans-unit id="aa27746d74f17d76cf69db42d49e7edcd107a3bc" translate="yes" xml:space="preserve">
          <source>On a device there can be many types of sensors. Not all of the types that the Qt Sensors API supports may be available. There may also be types available that are not defined in the Qt Sensors API. The types of sensors available on a device is found using the &lt;a href=&quot;qsensor#sensorTypes&quot;&gt;QSensor::sensorTypes&lt;/a&gt;() function.</source>
          <target state="translated">장치에는 여러 유형의 센서가있을 수 있습니다. Qt 센서 API가 지원하는 모든 유형을 사용할 수있는 것은 아닙니다. Qt 센서 API에 정의되지 않은 사용 가능한 유형이있을 수도 있습니다. 장치에서 사용 가능한 센서 유형은 &lt;a href=&quot;qsensor#sensorTypes&quot;&gt;QSensor :: sensorTypes&lt;/a&gt; () 함수를 사용하여 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="340cb1db0d82a6cc7816d765de5e6299d3925a35" translate="yes" xml:space="preserve">
          <source>On a graphics tablet, each type of stylus or other tool often has a unique ID or serial number, which can be useful to respond in different ways to different tools.</source>
          <target state="translated">그래픽 태블릿에서 각 스타일러스 또는 기타 도구 유형은 종종 고유 한 ID 또는 일련 번호를 가지므로 다른 도구에 다른 방식으로 응답하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5a208e157e201403e7f8007e1aae656a1c9dcbe" translate="yes" xml:space="preserve">
          <source>On a mobile device it can be used to easily choose between front-facing and back-facing cameras. If this property is set to &lt;code&gt;Camera.UnspecifiedPosition&lt;/code&gt;, the system's default camera will be used.</source>
          <target state="translated">모바일 장치에서는 전면 카메라와 후면 카메라 중 하나를 쉽게 선택할 수 있습니다. 이 속성을 &lt;code&gt;Camera.UnspecifiedPosition&lt;/code&gt; 으로 설정 하면 시스템의 기본 카메라가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ca20d418a110fc0695735cdb329e225f1c92da2e" translate="yes" xml:space="preserve">
          <source>On a typical Unix system, this will be /usr/share/mime/packages/, but it is also possible to extend the list of directories by setting the environment variable &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt;. For instance adding /opt/myapp/share to &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; will result in /opt/myapp/share/mime/packages/ being searched for MIME definitions.</source>
          <target state="translated">일반적인 Unix 시스템에서 이것은 / usr / share / mime / packages /이지만 환경 변수 &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; 를 설정하여 디렉토리 목록을 확장 할 수도 있습니다 . 예를 들어 / opt / myapp / share를 &lt;code&gt;XDG_DATA_DIRS&lt;/code&gt; 에 추가하면 / opt / myapp / share / mime / packages /에서 MIME 정의를 검색하게됩니다.</target>
        </trans-unit>
        <trans-unit id="a045d83adbceaaf476607421f1d3a7548e3674dc" translate="yes" xml:space="preserve">
          <source>On accepting one gesture Qt can automatically cancel other gestures that belong to other targets. The policy is normally set to not cancel any other gestures and can be set to cancel all active gestures in the context. For example for all child widgets.</source>
          <target state="translated">하나의 제스처 수락시 Qt는 다른 대상에 속하는 다른 제스처를 자동으로 취소 할 수 있습니다. 정책은 일반적으로 다른 제스처를 취소하지 않도록 설정되며 컨텍스트에서 모든 활성 제스처를 취소하도록 설정할 수 있습니다. 예를 들어 모든 하위 위젯의 경우.</target>
        </trans-unit>
        <trans-unit id="3d5d4aac9f5bb2f56e17586b4f740822cb3feebc" translate="yes" xml:space="preserve">
          <source>On accepting this gesture all gestures that are active in the context (respecting the &lt;a href=&quot;qt#GestureFlag-enum&quot;&gt;Qt::GestureFlag&lt;/a&gt; that were specified when subscribed to the gesture) will be cancelled.</source>
          <target state="translated">이 제스처를 수락하면 컨텍스트에서 활성화 된 모든 제스처 (제스처를 구독 할 때 지정된 &lt;a href=&quot;qt#GestureFlag-enum&quot;&gt;Qt :: GestureFlag&lt;/a&gt; 와 관련)가 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="b421fa6b19590a40b1da7065155d72721b081222" translate="yes" xml:space="preserve">
          <source>On accepting this gesture no other gestures will be affected.</source>
          <target state="translated">이 제스처를 수락하면 다른 제스처는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2dae3f602210c8a1c83d3cfe0e15ba0c18cb1abd" translate="yes" xml:space="preserve">
          <source>On all other UNIX-like operating systems, the type is a file descriptor representing a listening socket.</source>
          <target state="translated">다른 모든 UNIX 유사 운영 체제에서 유형은 청취 소켓을 나타내는 파일 디스크립터입니다.</target>
        </trans-unit>
        <trans-unit id="a3e3bd97df1ff42c4cc75d81c6f780421ba4b461" translate="yes" xml:space="preserve">
          <source>On all other UNIX-like operating systems, the type is a file descriptor representing a socket.</source>
          <target state="translated">다른 모든 UNIX 유사 운영 체제에서 유형은 소켓을 나타내는 파일 디스크립터입니다.</target>
        </trans-unit>
        <trans-unit id="3015490dacdd20b476d47e7ff4c0f6c454b09ba0" translate="yes" xml:space="preserve">
          <source>On all platforms the depth of the primary screen will be returned.</source>
          <target state="translated">모든 플랫폼에서 기본 화면의 깊이가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="082bb82a57d92617162ab4a21855edeecb241b8d" translate="yes" xml:space="preserve">
          <source>On all platforms, the following tools are required:</source>
          <target state="translated">모든 플랫폼에서 다음 도구가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7cb19b7a63de8255c0da90508c370aab063f74ef" translate="yes" xml:space="preserve">
          <source>On all platforms, the interval for Qt::VeryCoarseTimer is rounded to the nearest full second (e.g. an interval of 23500ms will be rounded to 24000ms, and 20300ms to 20000ms).</source>
          <target state="translated">모든 플랫폼에서 Qt :: VeryCoarseTimer의 간격은 가장 가까운 초 단위로 반올림됩니다 (예 : 23500ms 간격은 24000ms로, 20300ms ~ 20000ms로 반올림 됨).</target>
        </trans-unit>
        <trans-unit id="45fdfa68c255f9c04c3bf620adbf177e0249cf92" translate="yes" xml:space="preserve">
          <source>On and Off states of a Switch.</source>
          <target state="translated">스위치의 켜짐 및 꺼짐 상태.</target>
        </trans-unit>
        <trans-unit id="8b8ba8893e72c59a415a54b794c557d21b211bf7" translate="yes" xml:space="preserve">
          <source>On any platform other than Windows, this function returns a new UUID with variant &lt;a href=&quot;quuid#Variant-enum&quot;&gt;QUuid::DCE&lt;/a&gt; and version &lt;a href=&quot;quuid#Version-enum&quot;&gt;QUuid::Random&lt;/a&gt;. On Windows, a GUID is generated using the Windows API and will be of the type that the API decides to create.</source>
          <target state="translated">Windows 이외의 플랫폼에서이 함수는 변형 &lt;a href=&quot;quuid#Variant-enum&quot;&gt;QUuid :: DCE&lt;/a&gt; 및 버전 &lt;a href=&quot;quuid#Version-enum&quot;&gt;QUuid :: Random&lt;/a&gt; 과 함께 새 UUID를 리턴합니다 . Windows에서 GUID는 Windows API를 사용하여 생성되며 API가 작성하기로 결정한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="70aae88ca52c27299c6a2609cdb44d734f570ae4" translate="yes" xml:space="preserve">
          <source>On application start-up, the default font depends on the window system. It can vary depending on both the window system version and the locale. This function lets you override the default font; but overriding may be a bad idea because, for example, some locales need extra large fonts to support their special characters.</source>
          <target state="translated">응용 프로그램 시작시 기본 글꼴은 창 시스템에 따라 다릅니다. 윈도우 시스템 버전과 로케일에 따라 다를 수 있습니다. 이 기능을 사용하면 기본 글꼴을 무시할 수 있습니다. 예를 들어, 일부 로케일은 특수 문자를 지원하기 위해 더 큰 글꼴이 필요하기 때문에 재정의는 나쁜 생각 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0568eb2583df7e6d21c288f87183e801bfabfbe9" translate="yes" xml:space="preserve">
          <source>On certain platforms, a framebuffer other than 0 might be the default frame buffer depending on the current surface. Instead of calling glBindFramebuffer(0), it is recommended that you use glBindFramebuffer(ctx-&amp;gt;&lt;a href=&quot;qopenglcontext#defaultFramebufferObject&quot;&gt;defaultFramebufferObject&lt;/a&gt;()), to ensure that your application is portable between different platforms. However, if you use &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html#glBindFramebuffer&quot;&gt;QOpenGLFunctions::glBindFramebuffer&lt;/a&gt;(), this is done automatically for you.</source>
          <target state="translated">특정 플랫폼에서 현재 표면에 따라 0 이외의 프레임 버퍼가 기본 프레임 버퍼 일 수 있습니다. glBindFramebuffer (0)를 호출하는 대신 glBindFramebuffer (ctx-&amp;gt; &lt;a href=&quot;qopenglcontext#defaultFramebufferObject&quot;&gt;defaultFramebufferObject&lt;/a&gt; ())를 사용하여 응용 프로그램이 다른 플랫폼간에 이식 가능하도록하는 것이 좋습니다 . 그러나 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html#glBindFramebuffer&quot;&gt;QOpenGLFunctions :: glBindFramebuffer&lt;/a&gt; ()를 사용하면 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6156b0e0e39a185887766587b4acdb86aac5fbc4" translate="yes" xml:space="preserve">
          <source>On certain widgets, using '&amp;amp;' in front of a character will automatically create a mnemonic (a shortcut) for that character, e.g. &quot;E&amp;amp;xit&quot; will create the shortcut &lt;b&gt;Alt+X&lt;/b&gt; (use '&amp;amp;&amp;amp;' to display an actual ampersand). The widget might consume and perform an action on a given shortcut. On X11 the ampersand will not be shown and the character will be underlined. On Windows, shortcuts are normally not displayed until the user presses the &lt;b&gt;Alt&lt;/b&gt; key, but this is a setting the user can change. On Mac, shortcuts are disabled by default. Call &lt;a href=&quot;qkeysequence#qt_set_sequence_auto_mnemonic&quot;&gt;qt_set_sequence_auto_mnemonic&lt;/a&gt;() to enable them. However, because mnemonic shortcuts do not fit in with Aqua's guidelines, Qt will not show the shortcut character underlined.</source>
          <target state="translated">특정 위젯에서 문자 앞에 '&amp;amp;'를 사용하면 해당 문자에 대한 니모닉 (단축키)이 자동으로 생성됩니다. 예를 들어 &quot;E &amp;amp; xit&quot;는 단축키 &lt;b&gt;Alt + X를&lt;/b&gt; 생성합니다 ( '&amp;amp;&amp;amp;'를 사용하여 실제 앰퍼샌드 표시). 위젯은 주어진 단축키에 대해 조치를 수행하고 수행 할 수 있습니다. X11에서는 앰퍼샌드가 표시되지 않고 문자에 밑줄이 표시됩니다. Windows에서는 사용자가 &lt;b&gt;Alt&lt;/b&gt; 키를 누를 때까지 바로 가기가 일반적으로 표시되지 않지만 사용자가 변경할 수있는 설정입니다. Mac에서는 단축키가 기본적으로 비활성화되어 있습니다. 활성화하려면 &lt;a href=&quot;qkeysequence#qt_set_sequence_auto_mnemonic&quot;&gt;qt_set_sequence_auto_mnemonic&lt;/a&gt; ()을 호출 하십시오 . 그러나 니모닉 바로 가기는 Aqua의 지침에 맞지 않기 때문에 Qt는 바로 가기 문자에 밑줄이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3eb68cd74bebcf6de6cd1cde5ba9951e6cfab0cd" translate="yes" xml:space="preserve">
          <source>On desktop Windows, the default value is the value of the environment variable &lt;code&gt;WindowsSDKVersion&lt;/code&gt;.</source>
          <target state="translated">데스크탑 Windows에서 기본값은 환경 변수 &lt;code&gt;WindowsSDKVersion&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="cbcfc50480ff53139c39f8329ec33e7886b52267" translate="yes" xml:space="preserve">
          <source>On desktop platforms, it is common for modal popups to be closed only when the escape key is pressed. To achieve this behavior, set &lt;a href=&quot;qml-qtquick-controls2-popup#closePolicy-prop&quot;&gt;closePolicy&lt;/a&gt; to &lt;code&gt;Popup.CloseOnEscape&lt;/code&gt;. By default, &lt;code&gt;closePolicy&lt;/code&gt; is set to &lt;code&gt;Popup.CloseOnEscape | Popup.CloseOnPressOutside&lt;/code&gt;, which means that clicking outside of a modal popup will close it.</source>
          <target state="translated">데스크탑 플랫폼에서는 이스케이프 키를 누를 때만 모달 팝업이 닫히는 것이 일반적입니다. 이 동작을 수행하려면 &lt;a href=&quot;qml-qtquick-controls2-popup#closePolicy-prop&quot;&gt;closePolicy&lt;/a&gt; 를 &lt;code&gt;Popup.CloseOnEscape&lt;/code&gt; 로 설정 하십시오 . 기본적으로 &lt;code&gt;closePolicy&lt;/code&gt; 는 &lt;code&gt;Popup.CloseOnEscape | Popup.CloseOnPressOutside&lt;/code&gt; 는 모달 팝업 외부를 클릭하면 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="c915f9e77e2dea119e73f345df9b72d3f2df7349" translate="yes" xml:space="preserve">
          <source>On embedded systems, where the hardware has limited resources, this approach can be inefficient. Qt Quick Controls 2 was designed to solve this problem, using &lt;a href=&quot;https://blog.qt.io/blog/2015/03/31/qt-quick-controls-for-embedded/&quot;&gt;benchmarks&lt;/a&gt; to guide the development.</source>
          <target state="translated">하드웨어의 리소스가 제한적인 임베디드 시스템에서는이 방법이 비효율적 일 수 있습니다. Qt Quick Controls 2는 개발을 안내하기 위해 &lt;a href=&quot;https://blog.qt.io/blog/2015/03/31/qt-quick-controls-for-embedded/&quot;&gt;벤치 마크&lt;/a&gt; 를 사용하여이 문제를 해결하도록 설계되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ce146db8bcf0076c6e6ab523d6cb838851bd351f" translate="yes" xml:space="preserve">
          <source>On failure and if non-null, the</source>
          <target state="translated">실패시 및 널이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="05eb7270f90398951853ca19b852813c90eb6fdd" translate="yes" xml:space="preserve">
          <source>On failure, returns a &lt;a href=&quot;qnetworkdatagram&quot;&gt;QNetworkDatagram&lt;/a&gt; that reports &lt;a href=&quot;qnetworkdatagram#isValid&quot;&gt;not valid&lt;/a&gt;.</source>
          <target state="translated">실패하면 &lt;a href=&quot;qnetworkdatagram#isValid&quot;&gt;유효하지 않은&lt;/a&gt; 것으로보고 하는 &lt;a href=&quot;qnetworkdatagram&quot;&gt;QNetworkDatagram&lt;/a&gt; 을 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="cffad191a057506e0a048b861e4057f9315bad97" translate="yes" xml:space="preserve">
          <source>On hardware that supports it, this class lets you adjust the focus or zoom (both optical and digital). This also includes things like &quot;Macro&quot; mode for close up work (e.g. reading barcodes, or recognising letters), or &quot;touch to focus&quot; - indicating an interesting area of the viewfinder for the hardware to attempt to focus on.</source>
          <target state="translated">이를 지원하는 하드웨어에서이 클래스를 사용하면 초점 또는 줌 (광학 및 디지털)을 조정할 수 있습니다. 여기에는 근접 작업을위한 &quot;매크로&quot;모드 (예 : 바코드 읽기 또는 문자 인식) 또는 &quot;초점을 터치&quot;와 같은 것들이 포함됩니다. 이는 하드웨어가 초점을 맞추려고하는 뷰 파인더의 흥미로운 영역을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8363885fcb9687f6ab4a2f24d0dcc370caef0bdb" translate="yes" xml:space="preserve">
          <source>On iOS and Windows, this class cannot be used because the platform does not expose any data or API which may provide information on the local Bluetooth device.</source>
          <target state="translated">iOS 및 Windows에서는 플랫폼이 로컬 Bluetooth 장치에 대한 정보를 제공 할 수있는 데이터 또는 API를 노출하지 않으므로이 클래스를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a56aadea1cc7d6d509c113bc4866c5274d8796fb" translate="yes" xml:space="preserve">
          <source>On iOS, starting from version 8, Core Location framework requires additional entries in the application's Info.plist with keys NSLocationAlwaysUsageDescription or NSLocationWhenInUseUsageDescription and a string to be displayed in the authorization prompt. The key NSLocationWhenInUseUsageDescription is used when requesting permission to use location services while the app is in the foreground. The key NSLocationAlwaysUsageDescription is used when requesting permission to use location services whenever the app is running (both the foreground and the background). If both entries are defined, NSLocationWhenInUseUsageDescription has a priority in the foreground mode.</source>
          <target state="translated">iOS에서 버전 8부터 핵심 위치 프레임 워크는 애플리케이션의 Info.plist에 NSLocationAlwaysUsageDescription 또는 NSLocationWhenInUseUsageDescription 키와 함께 권한 프롬프트에 표시 할 추가 항목이 필요합니다. NSLocationWhenInUseUsageDescription 키는 앱이 포 그라운드에있는 동안 위치 서비스 사용 권한을 요청할 때 사용됩니다. NSLocationAlwaysUsageDescription 키는 앱이 실행될 때마다 (포 그라운드 및 백그라운드 모두) 위치 서비스 사용 권한을 요청할 때 사용됩니다. 두 항목이 모두 정의 된 경우 NSLocationWhenInUseUsageDescription은 포 그라운드 모드에서 우선 순위를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="7ec73f72e47f18ae88197f2e4f20a3d1a36d1ce2" translate="yes" xml:space="preserve">
          <source>On iOS, this class cannot be used because the platform does not expose an API which may permit access to &lt;a href=&quot;qbluetoothserver&quot;&gt;QBluetoothServer&lt;/a&gt; related features.</source>
          <target state="translated">iOS에서는 플랫폼이 &lt;a href=&quot;qbluetoothserver&quot;&gt;QBluetoothServer&lt;/a&gt; 관련 기능에 대한 액세스를 허용 할 수있는 API를 노출하지 않으므로이 클래스를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="339598eed30335c3b1dba3c33ce2e9524cb4dfb3" translate="yes" xml:space="preserve">
          <source>On iOS, this class cannot be used because the platform does not expose an API which may permit access to &lt;a href=&quot;qbluetoothservicediscoveryagent&quot;&gt;QBluetoothServiceDiscoveryAgent&lt;/a&gt; related features.</source>
          <target state="translated">iOS에서는 플랫폼이 &lt;a href=&quot;qbluetoothservicediscoveryagent&quot;&gt;QBluetoothServiceDiscoveryAgent&lt;/a&gt; 관련 기능에 대한 액세스를 허용 할 수있는 API를 노출하지 않으므로이 클래스를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d1eaa32fa95be2fefceece0a927dee8f9ec94159" translate="yes" xml:space="preserve">
          <source>On iOS, this class cannot be used because the platform does not expose an API which may permit access to &lt;a href=&quot;qbluetoothserviceinfo&quot;&gt;QBluetoothServiceInfo&lt;/a&gt; related features.</source>
          <target state="translated">iOS에서는 플랫폼이 &lt;a href=&quot;qbluetoothserviceinfo&quot;&gt;QBluetoothServiceInfo&lt;/a&gt; 관련 기능에 대한 액세스를 허용 할 수있는 API를 노출하지 않으므로이 클래스를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9faf3405ced15a18dfd9b103a487f9e78fd57842" translate="yes" xml:space="preserve">
          <source>On iOS, this class cannot be used because the platform does not expose an API which may permit access to &lt;a href=&quot;qbluetoothsocket&quot;&gt;QBluetoothSocket&lt;/a&gt; related features.</source>
          <target state="translated">iOS에서는 플랫폼이 &lt;a href=&quot;qbluetoothsocket&quot;&gt;QBluetoothSocket&lt;/a&gt; 관련 기능에 대한 액세스를 허용 할 수있는 API를 노출하지 않으므로이 클래스를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="93397ef8a3c751fea0b8cb626257ac44c252230a" translate="yes" xml:space="preserve">
          <source>On low-end hardware blending can also be quite expensive so for an image or rounded rectangle that covers most of the screen, the amount of blending needed for the interior of these primitives can result in significant performance loss as the entire primitive must be blended.</source>
          <target state="translated">로우 엔드 하드웨어 블렌딩은 상당히 비싸기 때문에 대부분의 화면을 덮는 이미지 또는 둥근 사각형의 경우, 프리미티브의 내부에 필요한 블렌딩 양은 전체 프리미티브를 블렌딩해야하기 때문에 상당한 성능 손실을 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b1d13fa7b490c6c0a0822b9a6ac39354b8a6525" translate="yes" xml:space="preserve">
          <source>On macOS, the following languages are also supported:</source>
          <target state="translated">macOS에서는 다음 언어도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8a0410214f377ebe2837d431e983e7ed11b07c0e" translate="yes" xml:space="preserve">
          <source>On many configurations, the scene graph rendering will happen on a dedicated render thread. This is done to increase parallelism of multi-core processors and make better use of stall times such as waiting for a blocking swap buffer call. This offers significant performance improvements, but imposes certain restrictions on where and when interaction with the scene graph can happen.</source>
          <target state="translated">많은 구성에서 장면 그래프 렌더링은 전용 렌더링 스레드에서 발생합니다. 이는 멀티 코어 프로세서의 병렬성을 높이고 차단 스왑 버퍼 호출 대기와 같은 스톨 시간을 더 잘 활용하기 위해 수행됩니다. 이를 통해 성능이 크게 향상되지만 장면 그래프와 상호 작용할 수있는 위치와시기에 특정 제한이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c4bb4017320968dc14a101cf9ab007de6abbaffa" translate="yes" xml:space="preserve">
          <source>On many platforms, the &lt;a href=&quot;https://doc.qt.io/qt-5.13/topics-graphics.html#qt-quick-scene-graph&quot;&gt;scene graph&lt;/a&gt; will even be rendered on a dedicated render thread while the GUI thread is preparing the next frame's state.</source>
          <target state="translated">많은 플랫폼 에서 GUI 스레드가 다음 프레임의 상태를 준비하는 동안 &lt;a href=&quot;https://doc.qt.io/qt-5.13/topics-graphics.html#qt-quick-scene-graph&quot;&gt;장면 그래프&lt;/a&gt; 는 전용 렌더링 스레드에서 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="1f2294b173fa00f42e1dc8880ac84178d20f0a23" translate="yes" xml:space="preserve">
          <source>On mobile platforms, switches are commonly used to enable or disable features.</source>
          <target state="translated">모바일 플랫폼에서 스위치는 일반적으로 기능을 활성화 또는 비활성화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a5a9de5d6cdeb88a2c4ac6389030bc54e56f99e" translate="yes" xml:space="preserve">
          <source>On models that support this, inserts</source>
          <target state="translated">이를 지원하는 모델에서는</target>
        </trans-unit>
        <trans-unit id="41592e465ed21517e25d1b60b76d4898a3a7a988" translate="yes" xml:space="preserve">
          <source>On models that support this, moves</source>
          <target state="translated">이를 지원하는 모델에서는</target>
        </trans-unit>
        <trans-unit id="ade874bfdcf68f6016f74be542e10e3dda132736" translate="yes" xml:space="preserve">
          <source>On models that support this, removes</source>
          <target state="translated">이를 지원하는 모델에서 제거</target>
        </trans-unit>
        <trans-unit id="fd0206cd94aa8cab3850091bd8cf6f5f8adff5cd" translate="yes" xml:space="preserve">
          <source>On modern Unix systems, this means &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; usually has accurate information about historical transitions (including DST, see below) whenever possible. On Windows, where the system doesn't support historical timezone data, historical accuracy is not maintained with respect to timezone transitions, notably including DST.</source>
          <target state="translated">현대 유닉스 시스템에서 이것은 &lt;a href=&quot;qdatetime&quot;&gt;QDateTime이&lt;/a&gt; 일반적으로 가능할 때마다 역사적 전환 (DST 포함, 아래 참조)에 대한 정확한 정보를 가지고 있음을 의미 합니다. 시스템이 과거 시간대 데이터를 지원하지 않는 Windows에서는 특히 DST를 포함하여 시간대 전환과 관련하여 과거 정확도가 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5c6c7e7a600194ac0290642a7c35ead0986ada6" translate="yes" xml:space="preserve">
          <source>On most file systems, rename() fails only if</source>
          <target state="translated">대부분의 파일 시스템에서 rename ()은 다음과 같은 경우에만 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c4189cdb33281e6173c000846c64209d4eb96979" translate="yes" xml:space="preserve">
          <source>On most operating systems the system path is determined by the PATH environment variable.</source>
          <target state="translated">대부분의 운영 체제에서 시스템 경로는 PATH 환경 변수에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="9e599cf93a104519a9331e2aca4dc391624e212f" translate="yes" xml:space="preserve">
          <source>On most platforms, the rendering will occur on a &lt;a href=&quot;qtquick-visualcanvas-scenegraph#scene-graph-and-rendering&quot;&gt;dedicated thread&lt;/a&gt;. For this reason, the &lt;a href=&quot;qquickframebufferobject&quot;&gt;QQuickFramebufferObject&lt;/a&gt; class enforces a strict separation between the item implementation and the FBO rendering. All item logic, such as properties and UI-related helper functions needed by QML should be located in a &lt;a href=&quot;qquickframebufferobject&quot;&gt;QQuickFramebufferObject&lt;/a&gt; class subclass. Everything that relates to rendering must be located in the &lt;a href=&quot;qquickframebufferobject-renderer&quot;&gt;QQuickFramebufferObject::Renderer&lt;/a&gt; class.</source>
          <target state="translated">대부분의 플랫폼에서 렌더링은 &lt;a href=&quot;qtquick-visualcanvas-scenegraph#scene-graph-and-rendering&quot;&gt;전용 스레드&lt;/a&gt; 에서 발생 합니다 . 이러한 이유로 &lt;a href=&quot;qquickframebufferobject&quot;&gt;QQuickFramebufferObject&lt;/a&gt; 클래스는 항목 구현과 FBO 렌더링을 엄격하게 분리합니다. QML에 필요한 속성 및 UI 관련 도우미 함수와 같은 모든 항목 논리는 &lt;a href=&quot;qquickframebufferobject&quot;&gt;QQuickFramebufferObject&lt;/a&gt; 클래스 서브 클래스 에 있어야합니다 . 렌더링과 관련된 모든 것은 &lt;a href=&quot;qquickframebufferobject-renderer&quot;&gt;QQuickFramebufferObject :: Renderer&lt;/a&gt; 클래스 에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e56f7e639613b5b65503e1bb78af1b62cc5594cb" translate="yes" xml:space="preserve">
          <source>On most systems this function will return true. However, on X11 systems that do not support CUPS, this function will return false. That means the application has to handle the number of copies by printing the same document the required number of times.</source>
          <target state="translated">대부분의 시스템에서이 기능은 true를 반환합니다. 그러나 CUPS를 지원하지 않는 X11 시스템에서는이 함수가 false를 반환합니다. 즉, 응용 프로그램은 필요한 횟수만큼 동일한 문서를 인쇄하여 인쇄 매수를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f23b1863f40dc4ba0720c4de3e06f71c2964972" translate="yes" xml:space="preserve">
          <source>On most systems, inserting a variable with no contents will have the same effect for applications as if the variable had not been set at all. However, to guarantee that there are no incompatibilities, to remove a variable, please use the &lt;a href=&quot;qprocessenvironment#remove&quot;&gt;remove&lt;/a&gt;() function.</source>
          <target state="translated">대부분의 시스템에서 내용이없는 변수를 삽입하면 변수가 전혀 설정되지 않은 것처럼 응용 프로그램에 동일한 효과가 있습니다. 그러나 비 호환성이 없도록 변수를 제거하려면 &lt;a href=&quot;qprocessenvironment#remove&quot;&gt;remove&lt;/a&gt; () 함수 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="efac2b84fadb23f4a588caa9754c76356866e879" translate="yes" xml:space="preserve">
          <source>On non-Unix systems, &lt;a href=&quot;qdbusunixfiledescriptor&quot;&gt;QDBusUnixFileDescriptor&lt;/a&gt; will always report an invalid state and &lt;a href=&quot;qdbusunixfiledescriptor#isSupported&quot;&gt;QDBusUnixFileDescriptor::isSupported&lt;/a&gt;() will return false.</source>
          <target state="translated">비 유닉스 시스템에서 &lt;a href=&quot;qdbusunixfiledescriptor&quot;&gt;QDBusUnixFileDescriptor&lt;/a&gt; 는 항상 유효하지 않은 상태를보고하며 &lt;a href=&quot;qdbusunixfiledescriptor#isSupported&quot;&gt;QDBusUnixFileDescriptor :: isSupported&lt;/a&gt; ()는 false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e38c3a23dee5fa9311a5107003b6936f0a0d73bb" translate="yes" xml:space="preserve">
          <source>On operating systems where file system is case sensitive, &lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt; also tries to load a lower-cased version of the locale name.</source>
          <target state="translated">파일 시스템이 대소 문자를 구분하는 운영 체제에서 &lt;a href=&quot;qtranslator&quot;&gt;QTranslator&lt;/a&gt; 는 로케일 이름의 소문자 버전을로드하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="1aa7f8494db2fc0822ab3e263ae6aa016fb72ef0" translate="yes" xml:space="preserve">
          <source>On operating systems where the system API for passing command line</source>
          <target state="translated">명령 행을 전달하기위한 시스템 API가있는 운영 체제에서</target>
        </trans-unit>
        <trans-unit id="05e5202b8c925c0c913ef79c144980eb361aa914" translate="yes" xml:space="preserve">
          <source>On operating systems where the system API for passing command line arguments to a subprocess natively uses a single string (Windows), one can conceive command lines which cannot be passed via &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt;'s portable list-based API. In these rare cases you need to use &lt;a href=&quot;qprocess#setProgram&quot;&gt;setProgram&lt;/a&gt;() and &lt;a href=&quot;qprocess#setNativeArguments&quot;&gt;setNativeArguments&lt;/a&gt;() instead of this function.</source>
          <target state="translated">서브 프로세스에 명령 행 인수를 전달하기위한 시스템 API가 기본적으로 단일 문자열 (Windows)을 사용하는 운영 체제에서 &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; 의 이식 가능한 목록 기반 API 를 통해 전달할 수없는 명령 행을 생각할 수 있습니다 . 드문 경우이지만 이 함수 대신 &lt;a href=&quot;qprocess#setProgram&quot;&gt;setProgram&lt;/a&gt; () 및 &lt;a href=&quot;qprocess#setNativeArguments&quot;&gt;setNativeArguments&lt;/a&gt; () 를 사용해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="28136e7d36f13be0dbb0c61f2f62bad732585c92" translate="yes" xml:space="preserve">
          <source>On or off (only for toggling push buttons).</source>
          <target state="translated">켜짐 또는 꺼짐 (푸시 버튼 토글 전용).</target>
        </trans-unit>
        <trans-unit id="3f1b1f250acb8d5ddcc132e442f60e2cb28137a4" translate="yes" xml:space="preserve">
          <source>On other operating systems, &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; will fall back to a PRNG of good numeric distribution, but it cannot guarantee proper seeding in all cases. Please consult the OS documentation for more information.</source>
          <target state="translated">다른 운영 체제에서 &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; 는 양호한 숫자 분배 PRNG로 대체 되지만 모든 경우에 올바른 시딩을 보장 할 수는 없습니다. 자세한 내용은 OS 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d15b206f77ee2ee8cfd8115fd9c168f87e0d6541" translate="yes" xml:space="preserve">
          <source>On other platforms than Windows, &quot;Default&quot; and &quot;.&quot; would be treated as regular subkeys.</source>
          <target state="translated">Windows 이외의 다른 플랫폼에서는 &quot;기본&quot;및 &quot;.&quot; 일반 하위 키로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="707eb1c8724241a1e87379d817c5d04fe6cf181a" translate="yes" xml:space="preserve">
          <source>On other platforms, the default is the empty string.</source>
          <target state="translated">다른 플랫폼에서 기본값은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c16c91f3148fe99500ed5d9ed9ec9a9afcaa8921" translate="yes" xml:space="preserve">
          <source>On other systems, this function will pick up proxy settings from the &quot;http_proxy&quot; environment variable. This variable must be a URL using one of the following schemes: &quot;http&quot;, &quot;socks5&quot; or &quot;socks5h&quot;.</source>
          <target state="translated">다른 시스템에서는이 기능이 &quot;http_proxy&quot;환경 변수에서 프록시 설정을 선택합니다. 이 변수는 &quot;http&quot;, &quot;socks5&quot;또는 &quot;socks5h&quot;체계 중 하나를 사용하는 URL이어야합니다.</target>
        </trans-unit>
        <trans-unit id="ffa936f15b2bfcf36e9b62a214708044a04b8087" translate="yes" xml:space="preserve">
          <source>On platforms that do not provide nanosecond resolution, the value returned will be the best estimate available.</source>
          <target state="translated">나노초 해상도를 제공하지 않는 플랫폼에서는 반환되는 값이 사용 가능한 최상의 추정치입니다.</target>
        </trans-unit>
        <trans-unit id="f8e36630f309db9813967e18eaa4f77c0b022776" translate="yes" xml:space="preserve">
          <source>On platforms that do not use dynamic GL switching, the return value is &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">동적 GL 스위칭을 사용하지 않는 플랫폼에서 리턴 값은 &lt;code&gt;nullptr&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e089be5b188ff534e5a5114f53ca6db3653567b5" translate="yes" xml:space="preserve">
          <source>On platforms where retrieving the native handle is not supported, or if neither &lt;a href=&quot;qopenglcontext#create&quot;&gt;create&lt;/a&gt;() nor &lt;a href=&quot;qopenglcontext#setNativeHandle&quot;&gt;setNativeHandle&lt;/a&gt;() was called, a null variant is returned.</source>
          <target state="translated">원시 핸들 검색이 지원되지 않거나 &lt;a href=&quot;qopenglcontext#create&quot;&gt;create&lt;/a&gt; () 또는 &lt;a href=&quot;qopenglcontext#setNativeHandle&quot;&gt;setNativeHandle&lt;/a&gt; ()이 호출 되지 않은 플랫폼에서는 널 (null) 변형이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="097e335f3aa7896ef14a46c7227eceadb182fa7f" translate="yes" xml:space="preserve">
          <source>On platforms where the OpenGL implementation is not dynamically loaded, the return value is determined during compile time and never changes.</source>
          <target state="translated">OpenGL 구현이 동적으로로드되지 않는 플랫폼에서는 반환 시간이 컴파일 시간 동안 결정되며 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11551870c462ac03be9f07e2e333fda2d6df3f73" translate="yes" xml:space="preserve">
          <source>On platforms where this information is not available, returns the same as &lt;a href=&quot;qfileinfo#lastModified&quot;&gt;lastModified&lt;/a&gt;().</source>
          <target state="translated">이 정보를 사용할 수없는 플랫폼에서는 &lt;a href=&quot;qfileinfo#lastModified&quot;&gt;lastModified&lt;/a&gt; () 와 동일한 정보를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="de86b2310b46ab95d774db26591152dc57268371" translate="yes" xml:space="preserve">
          <source>On press of the &lt;code&gt;[TAB]&lt;/code&gt; key, the item inside the &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; gets focus. If this item can handle &lt;code&gt;[TAB]&lt;/code&gt; key press, focus will change accordingly within the item, otherwise the next widget in the focus chain gets focus.</source>
          <target state="translated">의 키를 누릅니다에 &lt;code&gt;[TAB]&lt;/code&gt; 키를 내부 항목 &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget는&lt;/a&gt; 초점을 가져옵니다. 이 항목이 &lt;code&gt;[TAB]&lt;/code&gt; 키 누름을 처리 할 수 ​​있으면 항목 내에서 초점이 적절하게 변경되고, 그렇지 않으면 초점 체인의 다음 위젯이 초점을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="216f293e577fbbb41756144aacb2342b7d858e73" translate="yes" xml:space="preserve">
          <source>On some desktop platforms (including Windows and Unix), the application name (from &lt;a href=&quot;qguiapplication#applicationDisplayName-prop&quot;&gt;QGuiApplication::applicationDisplayName&lt;/a&gt;) is added at the end of the window title, if set. This is done by the QPA plugin, so it is shown to the user, but isn't part of the windowTitle string.</source>
          <target state="translated">일부 데스크탑 플랫폼 (Windows 및 Unix 포함)에서 응용 프로그램 이름 ( &lt;a href=&quot;qguiapplication#applicationDisplayName-prop&quot;&gt;QGuiApplication :: applicationDisplayName&lt;/a&gt; )은 설정된 경우 창 제목 끝에 추가됩니다. 이것은 QPA 플러그인에 의해 수행되므로 사용자에게 표시되지만 windowTitle 문자열의 일부는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="13fac2949d067de8eee19c6e772df44625a7e5d3" translate="yes" xml:space="preserve">
          <source>On some platforms (e.g. X11), the drawConvexPolygon() function can be faster than the &lt;a href=&quot;qpainter#drawPolygon&quot;&gt;drawPolygon&lt;/a&gt;() function.</source>
          <target state="translated">일부 플랫폼 (예 : X11)에서 drawConvexPolygon () 함수는 &lt;a href=&quot;qpainter#drawPolygon&quot;&gt;drawPolygon&lt;/a&gt; () 함수 보다 빠를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34f97bbe7845b46e635a2c35b414f90487ac3ba8" translate="yes" xml:space="preserve">
          <source>On some platforms (for instance, iOS) the default framebuffer object depends on the surface being rendered to, and might be different from 0. Thus, instead of calling glBindFramebuffer(0), you should call glBindFramebuffer(ctx-&amp;gt;defaultFramebufferObject()) if you want your application to work across different Qt platforms.</source>
          <target state="translated">일부 플랫폼 (예 : iOS)에서 기본 프레임 버퍼 객체는 렌더링되는 표면에 따라 다르며 0과 다를 수 있습니다. 따라서 glBindFramebuffer (0)를 호출하는 대신 glBindFramebuffer (ctx-&amp;gt; defaultFramebufferObject ())를 호출해야합니다. 애플리케이션이 다른 Qt 플랫폼에서 작동하게하려면</target>
        </trans-unit>
        <trans-unit id="0cb4e721238ec59021d213a4d04d779ecf98d2b8" translate="yes" xml:space="preserve">
          <source>On some platforms it is a platform requirement that the application open a network session before any network operations can be performed. This can be tested by the presents of the &lt;a href=&quot;qnetworkconfigurationmanager#Capability-enum&quot;&gt;QNetworkConfigurationManager::NetworkSessionRequired&lt;/a&gt; flag in the value returned by the &lt;a href=&quot;qnetworkconfigurationmanager#capabilities&quot;&gt;QNetworkConfigurationManager::capabilities&lt;/a&gt;() function.</source>
          <target state="translated">일부 플랫폼에서는 네트워크 작업을 수행하기 전에 응용 프로그램에서 네트워크 세션을 열어야합니다. 이것은 &lt;a href=&quot;qnetworkconfigurationmanager#capabilities&quot;&gt;QNetworkConfigurationManager :: capabilities&lt;/a&gt; () 함수가 반환 한 값에 &lt;a href=&quot;qnetworkconfigurationmanager#Capability-enum&quot;&gt;QNetworkConfigurationManager :: NetworkSessionRequired&lt;/a&gt; 플래그를 제시하여 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="958c141ccc5a684fa33965a31052364570d61d43" translate="yes" xml:space="preserve">
          <source>On some platforms it is possible to pre-register an application to receive NDEF messages matching a given criteria. This is useful to get the system to automatically launch your application when a matching NDEF message is received. This removes the need to have the user manually launch NDEF handling applications, prior to touching a tag, or to have those applications always running and using system resources.</source>
          <target state="translated">일부 플랫폼에서는 지정된 기준과 일치하는 NDEF 메시지를 수신하도록 애플리케이션을 사전 등록 할 수 있습니다. 일치하는 NDEF 메시지가 수신 될 때 시스템이 자동으로 응용 프로그램을 시작하도록하는 데 유용합니다. 따라서 태그를 만지기 전에 사용자가 NDEF 처리 응용 프로그램을 수동으로 시작하거나 해당 응용 프로그램이 항상 실행되고 시스템 리소스를 사용하도록 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c2a2a1e397e164b7f23274f35cdc6d18e0a707f9" translate="yes" xml:space="preserve">
          <source>On some platforms the native context handle is not sufficient and other related handles (for example, for a window or display) have to be provided in addition. Therefore</source>
          <target state="translated">일부 플랫폼에서는 기본 컨텍스트 핸들이 충분하지 않으며 다른 관련 핸들 (예 : 창 또는 디스플레이)이 추가로 제공되어야합니다. 따라서</target>
        </trans-unit>
        <trans-unit id="20010ff5a4b8e3a16de71feedf70aa68fe2c3db7" translate="yes" xml:space="preserve">
          <source>On some platforms the return value of &lt;code&gt;false&lt;/code&gt; for a context that was successfully created previously indicates that the OpenGL context was lost.</source>
          <target state="translated">일부 플랫폼에서 이전에 성공적으로 작성된 컨텍스트에 대한 리턴 값 &lt;code&gt;false&lt;/code&gt; 는 OpenGL 컨텍스트가 유실되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9c8be1c2d514ab4d9b4b152b27947d9b30037220" translate="yes" xml:space="preserve">
          <source>On some platforms the service discovery might lead to pairing requests. Therefore it is not recommended to do service discoveries on all devices. This function can be used to restrict the service discovery to a particular device.</source>
          <target state="translated">일부 플랫폼에서 서비스 검색으로 인해 요청 요청이 발생할 수 있습니다. 따라서 모든 장치에서 서비스 검색을 수행하지 않는 것이 좋습니다. 이 기능을 사용하여 서비스 검색을 특정 장치로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="684b93ba29be6c4ee11d9560ae8a7c160f610ce5" translate="yes" xml:space="preserve">
          <source>On some platforms the size grip automatically hides itself when the window is shown full screen or maximised.</source>
          <target state="translated">일부 플랫폼에서 창을 전체 화면으로 표시하거나 최대화하면 크기 그립이 자동으로 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="02bee986cbf2492c7d23749e33b81016094ebe37" translate="yes" xml:space="preserve">
          <source>On some platforms, device discovery may lead to pairing requests.</source>
          <target state="translated">일부 플랫폼에서는 장치 검색으로 인해 페어링 요청이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46574dd13730a320c02663d04dec60fd6f1ff980" translate="yes" xml:space="preserve">
          <source>On some platforms, the file name suffix for precompiled header files is the same as that for other object files. For example, the following declarations may cause two different object files with the same name to be generated:</source>
          <target state="translated">일부 플랫폼에서 사전 컴파일 된 헤더 파일의 파일 이름 접미사는 다른 오브젝트 파일의 파일 이름 접미 부와 동일합니다. 예를 들어, 다음 선언으로 인해 동일한 이름을 가진 두 개의 다른 오브젝트 파일이 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b07f91e16f98dc094fe104a3dd260214ab60fd05" translate="yes" xml:space="preserve">
          <source>On some platforms, the frame may be put into a queue and the return value may only indicate a successful insertion into the queue. The actual frame will be send later on. Therefore the &lt;a href=&quot;qcanbusdevice#framesWritten&quot;&gt;framesWritten&lt;/a&gt;() signal is the final confirmation that the frame has been handed off to the transport layer. If an error occurs the &lt;a href=&quot;qcanbusdevice#errorOccurred&quot;&gt;errorOccurred&lt;/a&gt;() is emitted.</source>
          <target state="translated">일부 플랫폼에서는 프레임이 대기열에 배치 될 수 있으며 반환 값은 대기열에 성공적으로 삽입되었음을 나타냅니다. 실제 프레임은 나중에 전송됩니다. 따라서 &lt;a href=&quot;qcanbusdevice#framesWritten&quot;&gt;framesWritten&lt;/a&gt; () 신호는 프레임이 전송 계층으로 전달되었음을 최종 확인합니다. 오류가 발생하면 &lt;a href=&quot;qcanbusdevice#errorOccurred&quot;&gt;errorOccurred&lt;/a&gt; ()가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b14591797de380c2198aeb57dc2186da2a5f17cc" translate="yes" xml:space="preserve">
          <source>On some platforms, the symbols required by</source>
          <target state="translated">일부 플랫폼에서 필요한 기호</target>
        </trans-unit>
        <trans-unit id="e492c97f7f48a3b1d74e81536ecae5753a49beaf" translate="yes" xml:space="preserve">
          <source>On some systems it is possible for there to be available printers but none of them set to be the default printer.</source>
          <target state="translated">일부 시스템에서는 사용 가능한 프린터가있을 수 있지만 기본 프린터로 설정된 프린터는 없습니다.</target>
        </trans-unit>
        <trans-unit id="87e8d766af5194858d7c9f0eb0881452ec8c871f" translate="yes" xml:space="preserve">
          <source>On some systems it may become necessary to target a specific overlay plane through a pre-defined connector. Just forcing a layer index via &lt;code&gt;QT_QPA_EGLFS_LAYER_INDEX&lt;/code&gt; does not perform plane configuration and is therefore not suitable in itself. Instead, in such special scenarios use the &lt;code&gt;QT_QPA_EGLFS_KMS_CONNECTOR_INDEX&lt;/code&gt; and &lt;code&gt;QT_QPA_EGLFS_KMS_PLANE_INDEX&lt;/code&gt; environment variables. When these are set, only the specified connector and plane will be in use, all other outputs will get ignored. The backend will take care of picking the EGL layer that corresponds to the desired plane, and the configuring of the plane.</source>
          <target state="translated">일부 시스템에서는 사전 정의 된 커넥터를 통해 특정 오버레이 평면을 대상으로해야 할 수도 있습니다. &lt;code&gt;QT_QPA_EGLFS_LAYER_INDEX&lt;/code&gt; 를 통해 레이어 인덱스를 강제 실행하면 평면 구성이 수행되지 않으므로 자체적으로 적합하지 않습니다. 대신, 이러한 특수 시나리오에서 &lt;code&gt;QT_QPA_EGLFS_KMS_CONNECTOR_INDEX&lt;/code&gt; 및 &lt;code&gt;QT_QPA_EGLFS_KMS_PLANE_INDEX&lt;/code&gt; 환경 변수를 사용하십시오 . 이들을 설정하면 지정된 커넥터와 평면 만 사용되며 다른 모든 출력은 무시됩니다. 백엔드는 원하는 평면에 해당하는 EGL 계층을 선택하고 평면을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="283b10be9f34b91b6891d6c6ccb6950c21d9f437" translate="yes" xml:space="preserve">
          <source>On some systems, &lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface&lt;/a&gt; will need to heuristically determine which addresses are eligible.</source>
          <target state="translated">일부 시스템에서 &lt;a href=&quot;qnetworkinterface&quot;&gt;QNetworkInterface&lt;/a&gt; 는 적격 인 주소를 경험적으로 결정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0dee526eee6dcf66479929545416072bde171509" translate="yes" xml:space="preserve">
          <source>On some systems, if &lt;a href=&quot;qtemporaryfile#fileName&quot;&gt;fileName&lt;/a&gt;() is not called before closing the file, the temporary file may be removed regardless of the state of this property. This behavior should not be relied upon, so application code should either call &lt;a href=&quot;qtemporaryfile#fileName&quot;&gt;fileName&lt;/a&gt;() or leave the auto removal functionality enabled.</source>
          <target state="translated">일부 시스템 에서 파일을 닫기 전에 &lt;a href=&quot;qtemporaryfile#fileName&quot;&gt;fileName&lt;/a&gt; ()을 호출하지 않으면이 특성의 상태에 관계없이 임시 파일이 제거 될 수 있습니다. 이 동작에 의존해서는 &lt;a href=&quot;qtemporaryfile#fileName&quot;&gt;안되므로&lt;/a&gt; 응용 프로그램 코드는 fileName ()을 호출 하거나 자동 제거 기능을 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="c80e7654a8bec1f4d5facbbd74deaca93f98ee25" translate="yes" xml:space="preserve">
          <source>On some systems, reading an image directly to &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; can use less memory than reading a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; to convert it to &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt;.</source>
          <target state="translated">일부 시스템에서 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap으로&lt;/a&gt; 직접 이미지를 읽는 것은 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 를 &lt;a href=&quot;qpixmap&quot;&gt;QPixmap&lt;/a&gt; 으로 변환하기 위해 읽는 것보다 적은 메모리를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0317377699bff9eb7d97170a601767a6a9cfb34e" translate="yes" xml:space="preserve">
          <source>On some systems, the tooltip's length is limited. The tooltip will be truncated if necessary.</source>
          <target state="translated">일부 시스템에서는 툴팁 길이가 제한됩니다. 필요한 경우 툴팁이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="6d596c23df0bcb80eb02dee73f5b9614aa3ed6e0" translate="yes" xml:space="preserve">
          <source>On some types of touchscreens, especially those using TUIO drivers, it's possible to use recognizable physical tokens (fiducial objects) in addition to fingers. So if this point is a touch point, and uniqueId is set, it is the identifier for such an object.</source>
          <target state="translated">일부 유형의 터치 스크린, 특히 TUIO 드라이버를 사용하는 터치 스크린에서는 손가락 외에 인식 가능한 물리적 토큰 (기준 객체)을 사용할 수 있습니다. 따라서이 점이 터치 점이고 uniqueId가 설정된 경우 해당 점의 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="e04c70e0a07d9e15dd2ce9a8af14e64663eef194" translate="yes" xml:space="preserve">
          <source>On standard Linux distributions such as Ubuntu, gamepads such as XBox or PlayStation controllers are detected out-of-the-box. To check if the gamepad is detected, &lt;code&gt;grep&lt;/code&gt; the &lt;code&gt;dmesg&lt;/code&gt; logs using:</source>
          <target state="translated">Ubuntu와 같은 표준 Linux 배포에서는 XBox 또는 PlayStation 컨트롤러와 같은 게임 패드가 기본적으로 감지됩니다. 게임 패드가 감지되는지 확인하려면 다음을 사용하여 &lt;code&gt;dmesg&lt;/code&gt; 로그를 &lt;code&gt;grep&lt;/code&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d5472790337d1d4e59cdd56ed2dea3a96341787" translate="yes" xml:space="preserve">
          <source>On success, the function returns &lt;code&gt;true&lt;/code&gt; and the socket enters &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;BoundState&lt;/a&gt;; otherwise it returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">성공하면 함수는 &lt;code&gt;true&lt;/code&gt; 를 반환 하고 소켓은 &lt;a href=&quot;qabstractsocket#SocketState-enum&quot;&gt;BoundState에&lt;/a&gt; 들어 갑니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="217a151d2ba7560a1f4a4b2e9000d3ada58dd09c" translate="yes" xml:space="preserve">
          <source>On success, this function returns the integer which has been entered by the user; on failure, it returns the initial</source>
          <target state="translated">성공하면이 함수는 사용자가 입력 한 정수를 반환합니다. 실패하면 초기 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0a549d2d16f78dece6ffe5f4ba948cc6c05ced1e" translate="yes" xml:space="preserve">
          <source>On successful completion of the operation, the reply will contain a list of search term suggestions. See &lt;a href=&quot;location-places-cpp#search-suggestions&quot;&gt;Search Suggestions&lt;/a&gt; for an example on how to use a search suggestion reply.</source>
          <target state="translated">작업이 성공적으로 완료되면 회신에 검색어 제안 목록이 포함됩니다. 검색 제안 응답을 사용하는 방법에 대한 예는 &lt;a href=&quot;location-places-cpp#search-suggestions&quot;&gt;검색 제안&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="48432cc5d48df67b159bc70dcb3b1ff5be20eb08" translate="yes" xml:space="preserve">
          <source>On system start-up, the default layout direction depends on the application's language.</source>
          <target state="translated">시스템 시작시 기본 레이아웃 방향은 응용 프로그램의 언어에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9f6f61c3a0a5edacdb6941ae738f76fa70e3be35" translate="yes" xml:space="preserve">
          <source>On systems running a Linux kernel without inotify support, file systems that contain watched paths cannot be unmounted.</source>
          <target state="translated">inotify를 지원하지 않고 Linux 커널을 실행하는 시스템에서는 감시 경로가 포함 된 파일 시스템을 마운트 해제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa66645afc6a39ae41bd9362f5877b326bd036c5" translate="yes" xml:space="preserve">
          <source>On systems that are configured to use the available screens as a single, large virtual desktop, the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qdesktopwidget-obsolete.html#virtualDesktop-prop&quot;&gt;virtualDesktop&lt;/a&gt; property will be set to true. In this case, the widget's size is usually the size of the bounding rectangle of all the screens.</source>
          <target state="translated">사용 가능한 화면을 하나의 큰 가상 데스크톱으로 사용하도록 구성된 시스템에서 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qdesktopwidget-obsolete.html#virtualDesktop-prop&quot;&gt;virtualDesktop&lt;/a&gt; 속성이 true로 설정됩니다. 이 경우 위젯의 크기는 일반적으로 모든 화면의 경계 사각형 크기입니다.</target>
        </trans-unit>
        <trans-unit id="6b75b64683e6a4695e0bfa1ff74f76fc05dfdc7a" translate="yes" xml:space="preserve">
          <source>On systems that do not have symbolic links this function will always return the same string that &lt;a href=&quot;qdir#absolutePath&quot;&gt;absolutePath&lt;/a&gt;() returns. If the canonical path does not exist (normally due to dangling symbolic links) canonicalPath() returns an empty string.</source>
          <target state="translated">심볼릭 링크가없는 시스템에서이 함수는 항상 &lt;a href=&quot;qdir#absolutePath&quot;&gt;absolutePath&lt;/a&gt; ()가 반환하는 것과 동일한 문자열을 반환합니다. 표준 경로가 존재하지 않으면 (일반적으로 매달려있는 심볼릭 링크로 인해) canonicalPath ()는 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bf055bffb495271e6b40153e0db0d5bea81548b3" translate="yes" xml:space="preserve">
          <source>On systems that do not support time zones, this function will behave as if local time were &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::UTC&lt;/a&gt;.</source>
          <target state="translated">시간대를 지원하지 않는 시스템에서이 기능은 현지 시간이 &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt :: UTC 인&lt;/a&gt; 것처럼 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="8426a5b516aee828131cfae3e4c5e93ba71cdc42" translate="yes" xml:space="preserve">
          <source>On systems where files do not have permissions this function always returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">파일에 권한이없는 시스템에서이 함수는 항상 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="d9f5896ef661837ef656cf71b6500f89533d6442" translate="yes" xml:space="preserve">
          <source>On systems where the user's desktop is displayed using more than one screen, certain types of applications may need to obtain information about the configuration of the user's workspace to ensure that new windows and dialogs are opened in appropriate locations.</source>
          <target state="translated">사용자 바탕 화면이 둘 이상의 화면을 사용하여 표시되는 시스템에서 특정 유형의 응용 프로그램은 적절한 위치에서 새 창과 대화 상자가 열리도록 사용자 작업 공간 구성에 대한 정보를 얻어야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ff05ff4d4fd2a0c4ec48dd98879ec9f55a8f523" translate="yes" xml:space="preserve">
          <source>On systems which do not maintain a list of &lt;a href=&quot;qnetworkconfigurationmanager#defaultConfiguration&quot;&gt;defaultConfiguration()&lt;/a&gt; an invalid configuration is returned. A possible workaround could be to implement a custom dialog which is populated based on what &lt;a href=&quot;qnetworkconfigurationmanager#allConfigurations&quot;&gt;QNetworkConfigurationManager::allConfigurations&lt;/a&gt;() returns.</source>
          <target state="translated">&lt;a href=&quot;qnetworkconfigurationmanager#defaultConfiguration&quot;&gt;defaultConfiguration ()&lt;/a&gt; 목록을 유지 보수하지 않는 시스템 에서는 유효하지 않은 구성이 리턴됩니다. 가능한 해결책은 &lt;a href=&quot;qnetworkconfigurationmanager#allConfigurations&quot;&gt;QNetworkConfigurationManager :: allConfigurations&lt;/a&gt; ()가 리턴 하는 내용에 따라 채워지는 사용자 정의 대화 상자를 구현하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="8c7112f14169be9a416c8fe33e65874cb5a01deb" translate="yes" xml:space="preserve">
          <source>On the &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; side, the &lt;a href=&quot;qremoteobjectnode&quot;&gt;QRemoteObjectNode&lt;/a&gt; needs to register a callback to be used when the external schema is detected. The callback must be a &lt;a href=&quot;qremoteobjectnode#RemoteObjectSchemaHandler-typedef&quot;&gt;RemoteObjectSchemaHandler&lt;/a&gt;.</source>
          <target state="translated">온 &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;복제&lt;/a&gt; 측의 &lt;a href=&quot;qremoteobjectnode&quot;&gt;QRemoteObjectNode는&lt;/a&gt; 외부 스키마가 검출 될 때 사용될 콜백을 등록 할 필요가있다. 콜백은 &lt;a href=&quot;qremoteobjectnode#RemoteObjectSchemaHandler-typedef&quot;&gt;RemoteObjectSchemaHandler&lt;/a&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="434b12f1d40f9f93e07ace07abf7185c1c9c874a" translate="yes" xml:space="preserve">
          <source>On the QML side, you can now use the registered enums:</source>
          <target state="translated">QML 측에서 등록 된 열거 형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2d93553590cf4d762928f286dacc78e76252159" translate="yes" xml:space="preserve">
          <source>On the Session Bus, one can find other applications by the same user that are sharing the same desktop session (hence the name). On the System Bus, however, processes shared for the whole system are usually found.</source>
          <target state="translated">세션 버스에서 동일한 데스크톱 세션을 공유하는 동일한 사용자 (따라서 이름)가 다른 응용 프로그램을 찾을 수 있습니다. 그러나 시스템 버스에서는 일반적으로 전체 시스템에 대해 공유 된 프로세스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac0312dc21f0f689a2421be25d12d0f7d2a078ba" translate="yes" xml:space="preserve">
          <source>On the command-line, applications can be built using &lt;code&gt;qmake&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt;. Optionally, &lt;code&gt;qmake&lt;/code&gt; can generate project files for Xcode with &lt;code&gt;-spec macx-xcode&lt;/code&gt;. If you are using the binary package, &lt;code&gt;qmake&lt;/code&gt; generates Xcode projects by default; use &lt;code&gt;-spec macx-gcc&lt;/code&gt; to generate makefiles. For example:</source>
          <target state="translated">명령 행에서 &lt;code&gt;qmake&lt;/code&gt; 및 &lt;code&gt;make&lt;/code&gt; 를 사용하여 애플리케이션을 빌드 할 수 있습니다 . 선택적으로 &lt;code&gt;qmake&lt;/code&gt; 는 &lt;code&gt;-spec macx-xcode&lt;/code&gt; 를 사용 하여 Xcode 용 프로젝트 파일을 생성 할 수 있습니다 . 이진 패키지를 사용하는 경우 &lt;code&gt;qmake&lt;/code&gt; 는 기본적으로 Xcode 프로젝트를 생성합니다. makefile을 생성 하려면 &lt;code&gt;-spec macx-gcc&lt;/code&gt; 를 사용 하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e7a075199183b4ffd28da5b3a472c3762bf816a8" translate="yes" xml:space="preserve">
          <source>On the left of the text.</source>
          <target state="translated">텍스트 왼쪽</target>
        </trans-unit>
        <trans-unit id="b893e06264de3baeae08aa2679375bca3ba98d66" translate="yes" xml:space="preserve">
          <source>On the low level, applications communicate over D-Bus by sending messages to one another. Messages are used to relay the remote procedure calls as well as the replies and errors associated with them. When used over a bus, messages have a destination, which means they are routed only to the interested parties, avoiding congestion due to &quot;swarming&quot; or broadcasting.</source>
          <target state="translated">낮은 수준에서 응용 프로그램은 서로에게 메시지를 보내 D-Bus를 통해 통신합니다. 메시지는 원격 프로 시저 호출과 관련된 응답 및 오류를 릴레이하는 데 사용됩니다. 버스를 통해 사용될 때, 메시지는 목적지를 가지게됩니다. 즉, 메시지는 &quot;스 워밍&quot;또는 브로드 캐스트로 인한 혼잡을 피하면서 이해 당사자에게만 라우팅됩니다.</target>
        </trans-unit>
        <trans-unit id="474353455aaf6ed877e94689a204a43c53528cfe" translate="yes" xml:space="preserve">
          <source>On the next page you will need to select the certificates that will be distributed with your Provisioning Profile. You would have needed to uploaded a certificate on your local development machine to the Apple Developer Certificate, Identifiers, and Profiles manger previously. Generally you will want to add any certificates of the members of your team who will need to build your App.</source>
          <target state="translated">다음 페이지에서 프로비저닝 프로파일과 함께 배포 할 인증서를 선택해야합니다. 로컬 개발 시스템의 인증서를 이전에 Apple Developer Certificate, Identifiers 및 Profiles 관리자에 업로드해야했습니다. 일반적으로 앱을 빌드해야하는 팀 구성원의 인증서를 추가하려고합니다.</target>
        </trans-unit>
        <trans-unit id="4cd8b38bae57b5c4b4f560bf9622743d3abe6099" translate="yes" xml:space="preserve">
          <source>On the next page you will need to select the devices you will be developing and testing your app on. You must register your devices to the Apple Developer Certificate, Identifiers, and Profiles manger previously. The devices you select here are the only ones capable of running apps signed against this provisioning profile, so select all the devices you intend use during the development and testing phase.</source>
          <target state="translated">다음 페이지에서 앱을 개발하고 테스트 할 장치를 선택해야합니다. 이전에 장치를 Apple 개발자 인증서, 식별자 및 프로파일 관리자에 등록해야합니다. 여기에서 선택한 장치는이 프로비저닝 프로파일에 서명 된 앱을 실행할 수있는 유일한 장치이므로 개발 및 테스트 단계에서 사용하려는 모든 장치를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="1095c34dea0969f3125e4d8c989adc79207f7f0a" translate="yes" xml:space="preserve">
          <source>On the next page, you must fill out the details about your product. The &lt;b&gt;Reference Name&lt;/b&gt; field refers to how the product will be displayed in iTunes Connect and in sales reports, but not in the App Store itself. The &lt;b&gt;Product ID&lt;/b&gt; field is very important as it is the unique ID that will be used to query for the product from your app itself. If possible make this the same ID as the corresponding products in the other platform&amp;rsquo;s stores, otherwise you will have to conditional logic in your app for each platform when specifying product identifiers.</source>
          <target state="translated">다음 페이지에서 제품에 대한 세부 사항을 작성해야합니다. &lt;b&gt;Reference Name&lt;/b&gt; ( &lt;b&gt;참조 이름)&lt;/b&gt; 필드는 제품이 iTunes Connect 및 판매 보고서에 표시되지만 App Store 자체에는 표시되지 않는 방식을 나타냅니다. &lt;b&gt;제품 ID&lt;/b&gt; 이 앱 자체에서 제품에 대한 쿼리에 사용되는 고유 한 ID가 같은 필드는 매우 중요하다. 가능하면이 ID를 다른 플랫폼의 상점에있는 해당 제품과 동일한 ID로 설정하십시오. 그렇지 않으면 제품 식별자를 지정할 때 각 플랫폼에 대해 앱의 조건부 논리를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb222a18690f0b2c76bb9525cee3e76a8903aa6d" translate="yes" xml:space="preserve">
          <source>On the other hand, if a bus is not used, service names are also not used. If we compare this to a computer network again, this would equate to a point-to-point network: since the peer is known, there is no need to use hostnames to find it or its IP address.</source>
          <target state="translated">한편, 버스를 사용하지 않으면 서비스 이름도 사용되지 않습니다. 이것을 컴퓨터 네트워크와 다시 비교하면, 이것은 포인트-투-포인트 네트워크와 같습니다. 피어가 알려져 있기 때문에 호스트 이름을 사용하여 호스트 나 IP 주소를 찾을 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="dcdc862fdefd8cd0bf302443bbccbf1004374cfc" translate="yes" xml:space="preserve">
          <source>On the other hand, logging in synchronous mode has a high overhead, but the OpenGL implementation guarantees that all the messages caused by a certain command are received in order, before the command returns, and from the same thread the OpenGL context is bound to.</source>
          <target state="translated">반면, 동기 모드로 로깅하면 오버 헤드가 크지 만 OpenGL 구현은 명령이 리턴되기 전에 OpenGL 컨텍스트가 바인드 된 동일한 스레드에서 특정 명령으로 인해 발생하는 모든 메시지가 순서대로 수신되도록합니다.</target>
        </trans-unit>
        <trans-unit id="1e9c8ca1de36db669e292891fcbf1796fb641b2f" translate="yes" xml:space="preserve">
          <source>On the other hand, suppose you really want only one &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; element, the first one in the document (i.e., you only want the first &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; element in the first &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element). Then you have to do more filtering. There are two ways you can do it. You can apply the &lt;code&gt;[1]&lt;/code&gt; filter in the same place as above but enclose the path expression in parentheses:</source>
          <target state="translated">반면에, 당신이 정말로 하나의 경우를 가정 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; , 문서의 첫 번째 (즉, 당신이 첫 번째 원하는 요소를 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 최초의 요소 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 요소). 그런 다음 더 많은 필터링을 수행해야합니다. 당신이 그것을 할 수있는 두 가지 방법이 있습니다. &lt;code&gt;[1]&lt;/code&gt; 필터를 위와 같은 곳에 적용 할 수 있지만 경로 식을 괄호로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a6cc0954d4400f7b8d60c4b505bd97e38e7f9c3" translate="yes" xml:space="preserve">
          <source>On the other hand, this means &lt;a href=&quot;qelapsedtimer&quot;&gt;QElapsedTimer&lt;/a&gt; values can only be compared with other values that use the same reference. This is especially true if the time since the reference is extracted from the &lt;a href=&quot;qelapsedtimer&quot;&gt;QElapsedTimer&lt;/a&gt; object (&lt;a href=&quot;qelapsedtimer#msecsSinceReference&quot;&gt;QElapsedTimer::msecsSinceReference&lt;/a&gt;()) and serialised. These values should never be exchanged across the network or saved to disk, since there's no telling whether the computer node receiving the data is the same as the one originating it or if it has rebooted since.</source>
          <target state="translated">반면에 &lt;a href=&quot;qelapsedtimer&quot;&gt;QElapsedTimer&lt;/a&gt; 값은 동일한 참조를 사용하는 다른 값과 만 비교할 수 있습니다. 이는 &lt;a href=&quot;qelapsedtimer&quot;&gt;QElapsedTimer&lt;/a&gt; 오브젝트 ( &lt;a href=&quot;qelapsedtimer#msecsSinceReference&quot;&gt;QElapsedTimer :: msecsSinceReference&lt;/a&gt; ()) 에서 참조 이후의 시간이 추출되어 직렬화 된 경우 특히 그렇습니다 . 이 값은 네트워크를 통해 교환하거나 디스크에 저장해서는 안됩니다. 데이터를 수신하는 컴퓨터 노드가 데이터를 수신 한 컴퓨터 노드가 원래 노드와 동일한 지 또는 그 이후에 재부팅되었는지를 알 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="77efd63831eb7f5c8d427c682d396f441648e591" translate="yes" xml:space="preserve">
          <source>On the other hand, you can safely emit signals from your &lt;a href=&quot;qthread#run&quot;&gt;QThread::run&lt;/a&gt;() implementation, because signal emission is thread-safe.</source>
          <target state="translated">반면, 신호 방출은 스레드로부터 안전하기 때문에 &lt;a href=&quot;qthread#run&quot;&gt;QThread :: run&lt;/a&gt; () 구현 에서 신호를 안전하게 방출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="344ebd30c1691d76097cb441fd3a73887ee9baef" translate="yes" xml:space="preserve">
          <source>On the right of the text.</source>
          <target state="translated">텍스트 오른쪽에</target>
        </trans-unit>
        <trans-unit id="d9695003eed75e0367ce194cd0631e7c102416ac" translate="yes" xml:space="preserve">
          <source>On the system bus, one can also expect to find restrictions on what services each application is allowed to offer. Therefore, one can be reasonably certain that, if a certain service is present, it is being offered by a trusted application.</source>
          <target state="translated">또한 시스템 버스에서 각 응용 프로그램이 제공 할 수있는 서비스에 대한 제한 사항을 찾을 수 있습니다. 따라서 특정 서비스가있는 경우 신뢰할 수있는 응용 프로그램에서 제공하고 있다고 합리적으로 확신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1d30a51f1a28aaad2ba00d5b901c1fe57bc5e80" translate="yes" xml:space="preserve">
          <source>On touch, &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt; enables flicking and makes the scroll bars non-interactive.</source>
          <target state="translated">터치하면 &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView가 깜박임을&lt;/a&gt; 활성화하고 스크롤 막대를 비 대화식으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c953e28176379d2bdf43ea5238ba0de72683afb1" translate="yes" xml:space="preserve">
          <source>On touchscreens that can track physical objects (such as knobs or game pieces) in addition to fingers, each object usually has a unique ID. Likewise, each stylus that can be used with a graphics tablet usually has a unique serial number. Qt so far only supports numeric IDs. You can get the actual number as uniqueId.numeric, but that is a device-specific detail. In the future, there may be support for non-numeric IDs, so you should not assume that the number is meaningful.</source>
          <target state="translated">손가락 외에 물리적 인 물체 (예 : 손잡이 또는 게임 조각)를 추적 할 수있는 터치 스크린에서 각 물체에는 일반적으로 고유 한 ID가 있습니다. 마찬가지로 그래픽 태블릿과 함께 사용할 수있는 각 스타일러스에는 일반적으로 고유 한 일련 번호가 있습니다. 지금까지 Qt는 숫자 ID 만 지원합니다. 실제 숫자는 uniqueId.numeric로 얻을 수 있지만 장치 별 세부 정보입니다. 앞으로는 숫자가 아닌 ID를 지원할 수 있으므로 숫자가 의미가 있다고 가정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="acea668c9e98f42ef4ea326d649ea01ba5737ffb" translate="yes" xml:space="preserve">
          <source>On/off indicator for a view item.</source>
          <target state="translated">보기 항목의 켜짐 / 꺼짐 표시기.</target>
        </trans-unit>
        <trans-unit id="5fa999adb84b2c0031f4fad0cfc3a2031e391918" translate="yes" xml:space="preserve">
          <source>On/off indicator, for example, a &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt;.</source>
          <target state="translated">켜짐 / 꺼짐 표시기 (예 : &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c88a3d71536ddc26913f73b46ff11d4bbed4857e" translate="yes" xml:space="preserve">
          <source>Once &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtvirtualkeyboard-deployment-guide.html#&quot;&gt;properly installed&lt;/a&gt;, the virtual keyboard can be opened by clicking on a text input field.</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtvirtualkeyboard-deployment-guide.html#&quot;&gt;올바르게 설치&lt;/a&gt; 되면 텍스트 입력 필드를 클릭하여 가상 키보드를 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d8ad2f36ec3282a9f11a068428d2804dd485c82" translate="yes" xml:space="preserve">
          <source>Once &lt;a href=&quot;qtextline#setLineWidth&quot;&gt;QTextLine::setLineWidth&lt;/a&gt;() is called, a new line can be created and filled with text. Repeating this process will lay out the whole block of text contained in the &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt;. If there is no text left to be inserted into the layout, the &lt;a href=&quot;qtextline&quot;&gt;QTextLine&lt;/a&gt; returned will not be valid (isValid() will return false).</source>
          <target state="translated">일단 &lt;a href=&quot;qtextline#setLineWidth&quot;&gt;QTextLine :: setLineWidth은&lt;/a&gt; ()가 호출, 새로운 라인이 생성 및 텍스트로 가득 할 수 있습니다. 이 과정을 반복하면 &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout에&lt;/a&gt; 포함 된 전체 텍스트 블록이 레이아웃됩니다 . 레이아웃에 삽입 할 텍스트가 없으면 반환 된 &lt;a href=&quot;qtextline&quot;&gt;QTextLine&lt;/a&gt; 이 유효하지 않습니다 (isValid ()는 false를 반환 함).</target>
        </trans-unit>
        <trans-unit id="fc12fd14aa59b1809aeda499e402a77f7adedf6b" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;KeyReader.qml&lt;/code&gt; is loaded, it accepts key events and sets &lt;code&gt;event.accepted&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; so that the event is not propagated to the parent &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;KeyReader.qml&lt;/code&gt; 이로 드 되면 키 이벤트를 승인하고 &lt;code&gt;event.accepted&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정 하여 이벤트가 상위 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle로&lt;/a&gt; 전파되지 않도록합니다 .</target>
        </trans-unit>
        <trans-unit id="369b21cf40402245a2f9ab26af7722f2887f9ea4" translate="yes" xml:space="preserve">
          <source>Once &lt;code&gt;doc&lt;/code&gt; and &lt;code&gt;elem&lt;/code&gt; go out of scope, the whole internal tree representing the XML document is deleted.</source>
          <target state="translated">일단 &lt;code&gt;doc&lt;/code&gt; 및 &lt;code&gt;elem&lt;/code&gt; 범위의 외출, XML 문서를 나타내는 전체 내부 트리가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="ee1dc491fdd55ffd0fc4b2fbeb16f60438de0327" translate="yes" xml:space="preserve">
          <source>Once Qt is installed, you can use the Maintenance Tool under</source>
          <target state="translated">Qt가 설치되면 아래의 유지 관리 도구를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="83d0b39e5b2ba9fd3ca62bf11a2e51fe3ba848ee" translate="yes" xml:space="preserve">
          <source>Once a &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; has been created it should be added to the relevant menu and toolbar, then connected to the slot which will perform the action. For example:</source>
          <target state="translated">&lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; 이 생성 되면 관련 메뉴 및 도구 모음에 추가 된 다음 작업을 수행 할 슬롯에 연결되어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43e1f30afc29295352c577708ea4d49f0ba6df3c" translate="yes" xml:space="preserve">
          <source>Once a &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; has been created for a target object, the gesture recognizer will receive events for it in its &lt;a href=&quot;qgesturerecognizer#recognize&quot;&gt;recognize&lt;/a&gt;() handler function.</source>
          <target state="translated">대상 객체에 대한 &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; 가 작성 되면 제스처 인식기는 &lt;a href=&quot;qgesturerecognizer#recognize&quot;&gt;인식&lt;/a&gt; () 핸들러 함수 에서 해당 이벤트에 대한 이벤트를 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="61d56c40b76bb9d0bb53c2596af9a9d3b932c1f7" translate="yes" xml:space="preserve">
          <source>Once a &lt;a href=&quot;qmodbusclient&quot;&gt;QModbusClient&lt;/a&gt; object has been created, the application can use it to send requests. The returned object is used to obtain any data returned in response to the corresponding request.</source>
          <target state="translated">한 번 &lt;a href=&quot;qmodbusclient&quot;&gt;QModbusClient의&lt;/a&gt; 객체가 생성 된 응용 프로그램이 요청을 전송하는 데 사용할 수 있습니다. 반환 된 객체는 해당 요청에 대한 응답으로 반환 된 데이터를 가져 오는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d98a7ef943520707456603e0929cc41dd24752d6" translate="yes" xml:space="preserve">
          <source>Once a &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; object has been created, the application can use it to send requests over the network. A group of standard functions are supplied that take a request and optional data, and each return a &lt;a href=&quot;qnetworkreply&quot;&gt;QNetworkReply&lt;/a&gt; object. The returned object is used to obtain any data returned in response to the corresponding request.</source>
          <target state="translated">한 번 &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager의&lt;/a&gt; 객체가 생성 된 응용 프로그램은 네트워크를 통해 요청을 전송하는 데 사용할 수 있습니다. 요청 및 선택적 데이터를 취하는 표준 기능 그룹이 제공되며 각각 &lt;a href=&quot;qnetworkreply&quot;&gt;QNetworkReply&lt;/a&gt; 객체를 반환 합니다. 반환 된 객체는 해당 요청에 대한 응답으로 반환 된 데이터를 가져 오는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3b084b214d79ee12ee2d4e237b98fa9681392b7d" translate="yes" xml:space="preserve">
          <source>Once a &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; has been made current, you can render to it in a platform independent way by using Qt's OpenGL enablers such as &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt;, &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt;, &lt;a href=&quot;qopenglshaderprogram&quot;&gt;QOpenGLShaderProgram&lt;/a&gt;, and &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt;. It is also possible to use the platform's OpenGL API directly, without using the Qt enablers, although potentially at the cost of portability. The latter is necessary when wanting to use OpenGL 1.x or OpenGL ES 1.x.</source>
          <target state="translated">&lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; 가 최신 상태 가 되면 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; , &lt;a href=&quot;qopenglbuffer&quot;&gt;QOpenGLBuffer&lt;/a&gt; , &lt;a href=&quot;qopenglshaderprogram&quot;&gt;QOpenGLShaderProgram&lt;/a&gt; 및 &lt;a href=&quot;qopenglframebufferobject&quot;&gt;QOpenGLFramebufferObject&lt;/a&gt; 와 같은 Qt의 OpenGL 인 에이 블러를 사용하여 플랫폼 독립적 인 방식으로 렌더링 할 수 있습니다 . Qt 인 에이 블러를 사용하지 않고도 플랫폼의 OpenGL API를 직접 사용할 수도 있지만 이식성이 떨어질 수 있습니다. 후자는 OpenGL 1.x 또는 OpenGL ES 1.x를 사용하고자 할 때 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e27bff41670537dc5d121238abb2648ff3024d56" translate="yes" xml:space="preserve">
          <source>Once a &lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt; object is constructed, subpaths like lines and curves can be added to the path (creating &lt;a href=&quot;qpainterpath#ElementType-enum&quot;&gt;QPainterPath::LineToElement&lt;/a&gt; and &lt;a href=&quot;qpainterpath#ElementType-enum&quot;&gt;QPainterPath::CurveToElement&lt;/a&gt; components).</source>
          <target state="translated">&lt;a href=&quot;qpainterpath&quot;&gt;QPainterPath&lt;/a&gt; 오브젝트가 구성 되면 선 및 곡선과 같은 서브 패스를 경로에 추가 할 수 있습니다 ( &lt;a href=&quot;qpainterpath#ElementType-enum&quot;&gt;QPainterPath :: LineToElement&lt;/a&gt; 및 &lt;a href=&quot;qpainterpath#ElementType-enum&quot;&gt;QPainterPath :: CurveToElement&lt;/a&gt; 컴포넌트 작성).</target>
        </trans-unit>
        <trans-unit id="6a2d4470eae5a525141184fc66126986ce9f96a3" translate="yes" xml:space="preserve">
          <source>Once a &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; object has been constructed and set up, a &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; can be used to perform painting operations on it. We can construct and set up a painter in the following way:</source>
          <target state="translated">한 번 &lt;a href=&quot;qprinter&quot;&gt;QPrinter의&lt;/a&gt; 개체를 구성하고 설정 한하는 &lt;a href=&quot;qpainter&quot;&gt;QPainter를가&lt;/a&gt; 그 위에 그림 작업을 수행 할 수 있습니다. 다음과 같은 방법으로 화가를 구성하고 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27b48feb01099b3cfeaf6cb1cbf57f32d92d8f98" translate="yes" xml:space="preserve">
          <source>Once a client is connected to a host, valid Replicas can then be acquired if the corresponding Source is being remoted.</source>
          <target state="translated">클라이언트가 호스트에 연결되면 해당 소스가 원격 인 경우 유효한 복제본을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="865107c84714f3448d7fb0b9cda071b0e4feba9e" translate="yes" xml:space="preserve">
          <source>Once a command is pushed, the stack takes ownership of it. There are no getters to return the command, since modifying it after it has been executed will almost always lead to corruption of the document's state.</source>
          <target state="translated">명령이 푸시되면 스택이 그 소유권을 갖습니다. 명령을 실행 한 후에 수정하면 거의 항상 문서 상태가 손상되므로 명령을 반환 할 게터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5256abfdd146b98943e67f2f6ec9c59215b01a99" translate="yes" xml:space="preserve">
          <source>Once a connection is established, we can call the static function &lt;a href=&quot;qsqldatabase#database&quot;&gt;QSqlDatabase::database&lt;/a&gt;() from anywhere with a connection name to get a pointer to that database connection. If we don't pass a connection name, it will return the default connection. For example:</source>
          <target state="translated">연결이 설정되면 연결 이름이있는 곳 어디에서나 정적 함수 &lt;a href=&quot;qsqldatabase#database&quot;&gt;QSqlDatabase :: database&lt;/a&gt; ()를 호출하여 해당 데이터베이스 연결에 대한 포인터를 얻을 수 있습니다. 연결 이름을 전달하지 않으면 기본 연결이 반환됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e3e1292f78955db255d4d252e5a0511c1b9c9e2" translate="yes" xml:space="preserve">
          <source>Once a document has been parsed, its internal representation is maintained in the &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; instance and shared among multiple &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; instances.</source>
          <target state="translated">문서가 구문 분석되면 내부 표현이 &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; 인스턴스 에서 유지 관리되고 여러 &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; 인스턴스 간에 공유 됩니다.</target>
        </trans-unit>
        <trans-unit id="3e617583a12847fefb05daac54125f2414156dfa" translate="yes" xml:space="preserve">
          <source>Once a font is found, the remaining attributes are matched in order of priority:</source>
          <target state="translated">글꼴이 발견되면 나머지 속성은 우선 순위에 따라 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8c022caf014d337f979e44b5cdd38456d077c269" translate="yes" xml:space="preserve">
          <source>Once a place is saved the reply contains the new identifier for that place.</source>
          <target state="translated">장소가 저장되면 회신에 해당 장소의 새 식별자가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="985c8565b7a16848e0e99e52adeb2e4c33ee20e9" translate="yes" xml:space="preserve">
          <source>Once a resource file is loaded, you can create or remove entries in it using the given &lt;b&gt;Add Files&lt;/b&gt;</source>
          <target state="translated">리소스 파일이로드되면 주어진 &lt;b&gt;파일 추가를&lt;/b&gt; 사용하여 리소스 파일을 만들거나 제거 할 수 있습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="c67240efc1ed0ad6dc10910948e36f600f7638a5" translate="yes" xml:space="preserve">
          <source>Once a service object was created for the first time, its details are yet to be discovered. This is indicated by its current &lt;a href=&quot;qlowenergyservice#state&quot;&gt;state&lt;/a&gt;() being &lt;a href=&quot;qlowenergyservice#ServiceState-enum&quot;&gt;DiscoveryRequired&lt;/a&gt;. It is only possible to retrieve the &lt;a href=&quot;qlowenergyservice#serviceUuid&quot;&gt;serviceUuid&lt;/a&gt;() and &lt;a href=&quot;qlowenergyservice#serviceName&quot;&gt;serviceName&lt;/a&gt;().</source>
          <target state="translated">서비스 오브젝트가 처음 작성된 후에는 세부 사항이 아직 발견되지 않았습니다. 현재 &lt;a href=&quot;qlowenergyservice#state&quot;&gt;상태&lt;/a&gt; ()가 &lt;a href=&quot;qlowenergyservice#ServiceState-enum&quot;&gt;DiscoveryRequired로 표시&lt;/a&gt; 됩니다. &lt;a href=&quot;qlowenergyservice#serviceUuid&quot;&gt;serviceUuid&lt;/a&gt; () 및 &lt;a href=&quot;qlowenergyservice#serviceName&quot;&gt;serviceName&lt;/a&gt; () 만 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e53733a3477bb6bf01bf485f428bc1bbf91fcb57" translate="yes" xml:space="preserve">
          <source>Once a transaction is started, subsequent calls to this function will make the transaction recursive. Inner transactions act as agents of the outermost transaction (i.e., report the status of read operations to the outermost transaction, which can restore the position of the stream).</source>
          <target state="translated">트랜잭션이 시작되면이 함수에 대한 후속 호출은 트랜잭션을 재귀 적으로 만듭니다. 내부 트랜잭션은 가장 바깥 쪽 트랜잭션의 에이전트 역할을합니다 (즉, 읽기 작업 상태를 가장 바깥 쪽 트랜잭션에보고하여 스트림의 위치를 ​​복원 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="5a48b1bd8759f52d071295cfdc69c1cd7f1884fd" translate="yes" xml:space="preserve">
          <source>Once actions have been created, we can add them to the main window components. To begin with, we add them to the pop-up menus:</source>
          <target state="translated">조치가 작성되면 기본 창 구성 요소에 추가 할 수 있습니다. 우선 팝업 메뉴에 추가합니다 :</target>
        </trans-unit>
        <trans-unit id="3faa39f01db6ebf3d4a8f5b16def0e447e0383ca" translate="yes" xml:space="preserve">
          <source>Once all of the main window components have been set up, the central widget is created and installed by using code similar to the following:</source>
          <target state="translated">모든 기본 창 구성 요소가 설정되면 다음과 유사한 코드를 사용하여 중앙 위젯이 작성되고 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="fce4756a3b2fcb3adfa961f884ca86f0a7647bbc" translate="yes" xml:space="preserve">
          <source>Once all the meshes have been drawn, the G-Buffer is filled with all the meshes that can currently be seen by the camera. The second render pass is then used to render the scene to the back buffer with the final color shading by reading the normal, color, and position values from the G-buffer textures and outputting a color onto a full screen quad.</source>
          <target state="translated">모든 메쉬가 그려지면 G-Buffer는 현재 카메라에서 볼 수있는 모든 메쉬로 채워집니다. 그런 다음 두 번째 렌더 패스를 사용하여 G- 버퍼 텍스처에서 법선, 색상 및 위치 값을 읽고 전체 화면 쿼드로 색상을 출력하여 최종 색상 음영으로 장면을 백 버퍼로 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="ae1c4a2bb77b441f2cea129f7c14216ee5ea4029" translate="yes" xml:space="preserve">
          <source>Once an application has started a sensor it must wait until the sensor receives a new value before it can query the sensor's values. This is due to how the sensor receives values from the system. Sensors do not (in general) poll for new values, rather new values are pushed to the sensors as they happen.</source>
          <target state="translated">애플리케이션이 센서를 시작하면 센서 값을 쿼리하기 전에 센서가 새로운 값을 수신 할 때까지 기다려야합니다. 이는 센서가 시스템에서 값을받는 방식 때문입니다. 센서는 일반적으로 새로운 값을 폴링하지 않고 새로운 값이 센서에 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="cf3bcacf32514d75fb5446b9cc235894721a3d4a" translate="yes" xml:space="preserve">
          <source>Once an image is unloaded it cannot be painted by the canvas context unless it is loaded again.</source>
          <target state="translated">이미지가 언로드되면 다시로드되지 않으면 캔버스 컨텍스트에서 이미지를 페인트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="daa3720dcc2e979ce83cc61dee70ef7eeb6add35" translate="yes" xml:space="preserve">
          <source>Once an install set has been fully described, you can append it to the install list with a line like this:</source>
          <target state="translated">설치 세트에 대한 설명이 완료되면 다음과 같이 설치 목록에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e181648ef9fa7a0206e5311b32e008cb1d0d2fac" translate="yes" xml:space="preserve">
          <source>Once an object instance is created, the value of its</source>
          <target state="translated">객체 인스턴스가 생성되면 객체 인스턴스의 값</target>
        </trans-unit>
        <trans-unit id="b7d193ac2a6316f487a04fe32ee9b74c0b8dfdce" translate="yes" xml:space="preserve">
          <source>Once any setter methods are called, &lt;a href=&quot;qsslconfiguration#isNull&quot;&gt;isNull&lt;/a&gt;() will return false.</source>
          <target state="translated">setter 메소드가 호출되면 &lt;a href=&quot;qsslconfiguration#isNull&quot;&gt;isNull&lt;/a&gt; ()은 false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c1ec356434daf43ee99f34ac3d62059f73505f2e" translate="yes" xml:space="preserve">
          <source>Once associated with a Shape, here is the output with a joinStyleIndex of 2 (&lt;a href=&quot;qml-qtquick-shapes-shapepath&quot;&gt;ShapePath&lt;/a&gt;.RoundJoin):</source>
          <target state="translated">Shape와 연결되면 joinStyleIndex가 2 ( &lt;a href=&quot;qml-qtquick-shapes-shapepath&quot;&gt;ShapePath&lt;/a&gt; .RoundJoin) 인 출력이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e4ee61e7445fa6fb6664b755a4063025b9d41f7" translate="yes" xml:space="preserve">
          <source>Once created a &lt;a href=&quot;qsound&quot;&gt;QSound&lt;/a&gt; object can be queried for its &lt;a href=&quot;qsound#fileName&quot;&gt;fileName&lt;/a&gt;() and total number of &lt;a href=&quot;qsound#loops&quot;&gt;loops&lt;/a&gt;() (i.e. the number of times the sound will play). The number of repetitions can be altered using the &lt;a href=&quot;qsound#setLoops&quot;&gt;setLoops&lt;/a&gt;() function. While playing the sound, the &lt;a href=&quot;qsound#loopsRemaining&quot;&gt;loopsRemaining&lt;/a&gt;() function returns the remaining number of repetitions. Use the &lt;a href=&quot;qsound#isFinished&quot;&gt;isFinished&lt;/a&gt;() function to determine whether the sound has finished playing.</source>
          <target state="translated">일단 생성 된 &lt;a href=&quot;qsound&quot;&gt;QSound&lt;/a&gt; 객체는 &lt;a href=&quot;qsound#fileName&quot;&gt;fileName&lt;/a&gt; () 및 총 &lt;a href=&quot;qsound#loops&quot;&gt;루프 수&lt;/a&gt; () (즉, 사운드가 재생되는 횟수)를 쿼리 할 수 ​​있습니다 . 반복 횟수는 &lt;a href=&quot;qsound#setLoops&quot;&gt;setLoops&lt;/a&gt; () 함수를 사용하여 변경할 수 있습니다 . 사운드를 재생하는 동안 &lt;a href=&quot;qsound#loopsRemaining&quot;&gt;loopsRemaining&lt;/a&gt; () 함수는 나머지 반복 횟수를 반환합니다. 사용 &lt;a href=&quot;qsound#isFinished&quot;&gt;isFinished&lt;/a&gt; 소리가 재생 완료가 있는지 여부를 결정하기 위해 () 함수를.</target>
        </trans-unit>
        <trans-unit id="a80eaeebd004cac4f94cd86d98f54dd28509f27b" translate="yes" xml:space="preserve">
          <source>Once created, &lt;a href=&quot;qvideofilterrunnable&quot;&gt;QVideoFilterRunnable&lt;/a&gt; instances are managed by Qt Multimedia and will be automatically destroyed and recreated when necessary, for example when the scene graph is invalidated or the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; changes or is closed. Creation happens via the &lt;a href=&quot;qabstractvideofilter#createFilterRunnable&quot;&gt;QAbstractVideoFilter::createFilterRunnable&lt;/a&gt;() factory function.</source>
          <target state="translated">일단 생성 된 &lt;a href=&quot;qvideofilterrunnable&quot;&gt;QVideoFilterRunnable&lt;/a&gt; 인스턴스는 Qt Multimedia에 의해 관리되며 필요에 따라 (예 : 장면 그래프가 무효화되거나 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow가&lt;/a&gt; 변경되거나 닫히는 경우) 자동으로 삭제되고 다시 생성됩니다 . 생성은 &lt;a href=&quot;qabstractvideofilter#createFilterRunnable&quot;&gt;QAbstractVideoFilter :: createFilterRunnable&lt;/a&gt; () 팩토리 함수 를 통해 이루어집니다 .</target>
        </trans-unit>
        <trans-unit id="cd5e2fb5148480d8fcfc9bd868cceb10c5f8a778" translate="yes" xml:space="preserve">
          <source>Once created, the object provides functions to access the individual metrics of the font, its characters, and for strings rendered in the font.</source>
          <target state="translated">생성 된 객체는 글꼴, 해당 문자 및 글꼴로 렌더링 된 문자열의 개별 메트릭에 액세스하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1340e8fa34d48e4b5e320a1558f7bb4ee5e8ed98" translate="yes" xml:space="preserve">
          <source>Once created, the properties of a menu can be accessed using the &lt;a href=&quot;designer-widget-mode#the-property-editor&quot;&gt;Property Editor&lt;/a&gt;, and each menu can be accessed for this purpose via the &lt;a href=&quot;designer-widget-mode#the-object-inspector&quot;&gt;The Object Inspector&lt;/a&gt;.</source>
          <target state="translated">일단 생성되면 메뉴의 속성은 &lt;a href=&quot;designer-widget-mode#the-property-editor&quot;&gt;속성 편집기를&lt;/a&gt; 사용하여 액세스 할 수 있으며 , 각 메뉴는이 목적으로 &lt;a href=&quot;designer-widget-mode#the-object-inspector&quot;&gt;Object Inspector&lt;/a&gt; 를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4318286cc00389860c860891593d046999063bf7" translate="yes" xml:space="preserve">
          <source>Once created, timer queries can be issued in one of several ways. The simplest method is to delimit a block of commands with calls to &lt;a href=&quot;qopengltimerquery#begin&quot;&gt;begin&lt;/a&gt;() and &lt;a href=&quot;qopengltimerquery#end&quot;&gt;end&lt;/a&gt;(). This instructs OpenGL to measure the time taken from completing all commands issued prior to &lt;a href=&quot;qopengltimerquery#begin&quot;&gt;begin&lt;/a&gt;() until the completion of all commands issued prior to &lt;a href=&quot;qopengltimerquery#end&quot;&gt;end&lt;/a&gt;().</source>
          <target state="translated">일단 타이머 쿼리는 여러 가지 방법 중 하나로 발행 될 수 있습니다. 가장 간단한 방법은 &lt;a href=&quot;qopengltimerquery#begin&quot;&gt;시작&lt;/a&gt; () 및 &lt;a href=&quot;qopengltimerquery#end&quot;&gt;종료&lt;/a&gt; () 호출로 명령 블록을 구분하는 것 입니다. 이것은 이전에 발행 된 모든 명령 완료까지의 시간을 측정하기 위해 OpenGL을 지시 &lt;a href=&quot;qopengltimerquery#begin&quot;&gt;시작&lt;/a&gt; 이전에 발행 된 모든 명령이 완료 될 때까지 (를) &lt;a href=&quot;qopengltimerquery#end&quot;&gt;종료&lt;/a&gt; ()를.</target>
        </trans-unit>
        <trans-unit id="3563861d604d9a741f2f3133b5b1fd396a55a5de" translate="yes" xml:space="preserve">
          <source>Once disconnected, calling &lt;a href=&quot;qdbusconnection#connectToBus&quot;&gt;connectToBus&lt;/a&gt;() will not reestablish a connection, you must create a new &lt;a href=&quot;qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; instance.</source>
          <target state="translated">연결이 해제되면 &lt;a href=&quot;qdbusconnection#connectToBus&quot;&gt;connectToBus&lt;/a&gt; ()를 호출 해도 연결이 다시 설정되지 않으므로 새 &lt;a href=&quot;qdbusconnection&quot;&gt;QDBusConnection&lt;/a&gt; 인스턴스를 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0a771404be80a49f1bcd8129102f800ceae68ca3" translate="yes" xml:space="preserve">
          <source>Once enabled, applications have two typical choices to perform offscreen rendering in headless mode:</source>
          <target state="translated">활성화 된 응용 프로그램은 헤드리스 모드에서 오프 스크린 렌더링을 수행하기위한 두 가지 일반적인 선택 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="af11aa38925611d44c0c3134bc9e277087c165b5" translate="yes" xml:space="preserve">
          <source>Once encrypted, you use &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; as a regular &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt;. When &lt;a href=&quot;qiodevice#readyRead&quot;&gt;readyRead&lt;/a&gt;() is emitted, you can call &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt;(), &lt;a href=&quot;qsslsocket#canReadLine&quot;&gt;canReadLine&lt;/a&gt;() and &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt;(), or &lt;a href=&quot;qiodevice#getChar&quot;&gt;getChar&lt;/a&gt;() to read decrypted data from &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt;'s internal buffer, and you can call &lt;a href=&quot;qiodevice#write&quot;&gt;write&lt;/a&gt;() or &lt;a href=&quot;qiodevice#putChar&quot;&gt;putChar&lt;/a&gt;() to write data back to the peer. &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; will automatically encrypt the written data for you, and emit &lt;a href=&quot;qsslsocket#encryptedBytesWritten&quot;&gt;encryptedBytesWritten&lt;/a&gt;() once the data has been written to the peer.</source>
          <target state="translated">암호화되면 &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 을 일반 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket으로 사용&lt;/a&gt; 합니다. &lt;a href=&quot;qiodevice#readyRead&quot;&gt;readyRead&lt;/a&gt; ()가 생성 되면 &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt; (), &lt;a href=&quot;qsslsocket#canReadLine&quot;&gt;canReadLine&lt;/a&gt; () 및 &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt; () 또는 &lt;a href=&quot;qiodevice#getChar&quot;&gt;getChar&lt;/a&gt; ()를 호출 하여 &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 의 내부 버퍼 에서 해독 된 데이터를 읽고 &lt;a href=&quot;qiodevice#write&quot;&gt;write&lt;/a&gt; () 또는 &lt;a href=&quot;qiodevice#putChar&quot;&gt;putChar&lt;/a&gt; ()를 호출 하여 쓸 수 있습니다. 피어에게 데이터를 다시 보냅니다. &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 은 작성된 데이터를 자동으로 암호화하고 데이터가 피어에 쓰여지면 &lt;a href=&quot;qsslsocket#encryptedBytesWritten&quot;&gt;encryptedBytesWritten&lt;/a&gt; ()을 방출 합니다.</target>
        </trans-unit>
        <trans-unit id="47fd7e76dcd700654b875f9d31d09a0ed43c1e0f" translate="yes" xml:space="preserve">
          <source>Once individual animations are placed into a &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-parallelanimation&quot;&gt;ParallelAnimation&lt;/a&gt;, they can no longer be started and stopped independently. The sequential or parallel animation must be started and stopped as a group.</source>
          <target state="translated">개별 애니메이션을 &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-parallelanimation&quot;&gt;ParallelAnimation에&lt;/a&gt; 배치하면 더 이상 독립적으로 시작 및 중지 할 수 없습니다. 순차적 또는 병렬 애니메이션은 그룹으로 시작하고 중지해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7065d1862b32bf508458b0290a47c13567e0119" translate="yes" xml:space="preserve">
          <source>Once invalidate() has been called, it is possible to reuse the &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt; instance by calling &lt;a href=&quot;qquickrendercontrol#initialize&quot;&gt;initialize&lt;/a&gt;() again.</source>
          <target state="translated">invalidate ()가 호출되면 &lt;a href=&quot;qquickrendercontrol#initialize&quot;&gt;initialize&lt;/a&gt; ()를 다시 호출 하여 &lt;a href=&quot;qquickrendercontrol&quot;&gt;QQuickRenderControl&lt;/a&gt; 인스턴스 를 재사용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a86569ce76e4c0379ce20067c838e075579f2bf0" translate="yes" xml:space="preserve">
          <source>Once loaded, plugins remain in memory until all instances of &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; has been unloaded, or until the application terminates. You can attempt to unload a plugin using &lt;a href=&quot;qpluginloader#unload&quot;&gt;unload&lt;/a&gt;(), but if other instances of &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; are using the same library, the call will fail, and unloading will only happen when every instance has called &lt;a href=&quot;qpluginloader#unload&quot;&gt;unload&lt;/a&gt;(). Right before the unloading happens, the root component will also be deleted.</source>
          <target state="translated">일단로드되면 플러그인은 &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader의&lt;/a&gt; 모든 인스턴스 가 언로드 될 때까지 또는 응용 프로그램이 종료 될 때까지 메모리에 남아 있습니다 . &lt;a href=&quot;qpluginloader#unload&quot;&gt;unload&lt;/a&gt; ()를 사용하여 플러그인 언로드를 시도 할 수 있지만 &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader의&lt;/a&gt; 다른 인스턴스가 동일한 라이브러리를 사용하는 경우 호출이 실패하며 언로드는 모든 인스턴스가 &lt;a href=&quot;qpluginloader#unload&quot;&gt;unload&lt;/a&gt; ()를 호출 한 경우에만 발생 합니다. 언로드가 발생하기 직전에 루트 구성 요소도 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4fc26d0a14582bafdc9354c84ba528981f69fdec" translate="yes" xml:space="preserve">
          <source>Once opaque primitives have been drawn, the renderer will disable &lt;code&gt;glDepthMask&lt;/code&gt;, enable &lt;code&gt;GL_BLEND&lt;/code&gt; and render all alpha blended primitives in a back-to-front manner.</source>
          <target state="translated">불투명 프리미티브가 그려지면 렌더러는 &lt;code&gt;glDepthMask&lt;/code&gt; 를 비활성화하고 GL_BLEND 를 활성화 &lt;code&gt;GL_BLEND&lt;/code&gt; 모든 알파 블렌드 프리미티브를 연속적인 방식으로 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="b9db82184c27bdceb25bd1b08e3b5517bb8c8615" translate="yes" xml:space="preserve">
          <source>Once positioned, sub-controls can be styled using the &lt;a href=&quot;#box-model&quot;&gt;box model&lt;/a&gt;.</source>
          <target state="translated">일단 배치되면 &lt;a href=&quot;#box-model&quot;&gt;상자 모델을&lt;/a&gt; 사용하여 하위 제어를 스타일 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e44aa1cb73bede9c422aed8bc491a71274d8dc04" translate="yes" xml:space="preserve">
          <source>Once positioned, they are treated the same as widgets and can be styled using the &lt;a href=&quot;stylesheet-customizing#box-model&quot;&gt;box model&lt;/a&gt;.</source>
          <target state="translated">일단 배치되면 위젯과 동일하게 취급되며 &lt;a href=&quot;stylesheet-customizing#box-model&quot;&gt;상자 모델을&lt;/a&gt; 사용하여 스타일을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="011ec39e07e233ee8b7dbb26cded772667837811" translate="yes" xml:space="preserve">
          <source>Once registered, a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; singleton type may be imported and used like any other &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; instance exposed to QML. The following example assumes that a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; singleton type was registered into the &quot;MyThemeModule&quot; namespace with version 1.0, where that &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; has a &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; &quot;color&quot; &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt;:</source>
          <target state="translated">일단 등록되면 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 싱글 톤 유형을 가져 와서 QML에 노출 된 다른 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 인스턴스 와 같이 사용할 수 있습니다 . 다음 예제에서는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 싱글 톤 유형이 버전 1.0으로 &quot;MyThemeModule&quot;네임 스페이스에 등록 되었다고 가정합니다. 여기서 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 에는 &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; &quot;color&quot; &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY가 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f212ed18637128978ee635a7f85b1291a909b355" translate="yes" xml:space="preserve">
          <source>Once registered, a type can be used in outgoing method calls (placed with &lt;a href=&quot;qdbusabstractinterface#call&quot;&gt;QDBusAbstractInterface::call&lt;/a&gt;()), signal emissions from registered objects or in incoming calls from remote applications.</source>
          <target state="translated">등록 된 유형은 발신 메소드 호출 ( &lt;a href=&quot;qdbusabstractinterface#call&quot;&gt;QDBusAbstractInterface :: call&lt;/a&gt; ()로 배치 ), 등록 된 객체의 신호 방출 또는 원격 애플리케이션의 수신 호출에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76fdb923b97b3639512618d76df193ba658ae763" translate="yes" xml:space="preserve">
          <source>Once registered, all signals and property changes are automatically propagated to the clients. Public invokable methods, including slots, are also accessible to the clients.</source>
          <target state="translated">등록되면 모든 신호 및 속성 변경 사항이 클라이언트에 자동으로 전파됩니다. 슬롯을 포함한 공개 호출 가능 메소드도 클라이언트가 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b2acb02284decccb2539c681f480973c653d7a5" translate="yes" xml:space="preserve">
          <source>Once storage has been allocated for the texture then pixel data can be uploaded via one of the &lt;a href=&quot;qopengltexture#setData&quot;&gt;setData&lt;/a&gt;() overloads.</source>
          <target state="translated">텍스처에 스토리지가 할당되면 &lt;a href=&quot;qopengltexture#setData&quot;&gt;setData&lt;/a&gt; () 오버로드 중 하나를 통해 픽셀 데이터를 업로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4066d6598bee2916f9c3b08e94545af3dd0223ef" translate="yes" xml:space="preserve">
          <source>Once storage has been allocated it is no longer possible to change these properties.</source>
          <target state="translated">스토리지가 할당되면 더 이상 이러한 속성을 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf5fd6231cbbc871a1f444bb695dec4a43eaab55" translate="yes" xml:space="preserve">
          <source>Once the &lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase&lt;/a&gt; object has been created, set the connection parameters with &lt;a href=&quot;qsqldatabase#setDatabaseName&quot;&gt;setDatabaseName&lt;/a&gt;(), &lt;a href=&quot;qsqldatabase#setUserName&quot;&gt;setUserName&lt;/a&gt;(), &lt;a href=&quot;qsqldatabase#setPassword&quot;&gt;setPassword&lt;/a&gt;(), &lt;a href=&quot;qsqldatabase#setHostName&quot;&gt;setHostName&lt;/a&gt;(), &lt;a href=&quot;qsqldatabase#setPort&quot;&gt;setPort&lt;/a&gt;(), and &lt;a href=&quot;qsqldatabase#setConnectOptions&quot;&gt;setConnectOptions&lt;/a&gt;(). Then call &lt;a href=&quot;qsqldatabase#open&quot;&gt;open&lt;/a&gt;() to activate the physical connection to the database. The connection is not usable until you open it.</source>
          <target state="translated">일단 &lt;a href=&quot;qsqldatabase&quot;&gt;QSqlDatabase의&lt;/a&gt; 객체가 생성되어, 함께 연결 매개 변수를 설정 &lt;a href=&quot;qsqldatabase#setDatabaseName&quot;&gt;하는 setDataBaseName&lt;/a&gt; () &lt;a href=&quot;qsqldatabase#setUserName&quot;&gt;setUserName&lt;/a&gt; () &lt;a href=&quot;qsqldatabase#setPassword&quot;&gt;SETPASSWORD&lt;/a&gt; () &lt;a href=&quot;qsqldatabase#setHostName&quot;&gt;sethostname시&lt;/a&gt; () &lt;a href=&quot;qsqldatabase#setPort&quot;&gt;setPort&lt;/a&gt; () 및 &lt;a href=&quot;qsqldatabase#setConnectOptions&quot;&gt;setConnectOptions&lt;/a&gt; (). 그런 다음 &lt;a href=&quot;qsqldatabase#open&quot;&gt;open&lt;/a&gt; ()을 호출 하여 데이터베이스에 대한 물리적 연결을 활성화하십시오. 연결을 열 때까지 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d693e653a5aefa95f90913cd528053a2853d850b" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;RandomNumberGenerator&lt;/code&gt; class has been registered with the QML type system, it can be used from QML as a property value source. Below, it is used to change the width of a &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; every 500 milliseconds:</source>
          <target state="translated">일단 &lt;code&gt;RandomNumberGenerator&lt;/code&gt; 의 클래스가 QML 형 시스템에 등록되어,이를 속성 값 소스로 QML에서 사용될 수있다. 아래에서는 500 밀리 초마다 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;사각형&lt;/a&gt; 의 너비를 변경하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="56ae2c1e1c709d43479f94e48c10b97999f58390" translate="yes" xml:space="preserve">
          <source>Once the HTML documents are in place, a &lt;a href=&quot;qthelpproject#&quot;&gt;Qt Help Project&lt;/a&gt; file, with an extension of &lt;code&gt;.qhp&lt;/code&gt;, has to be created. After specifying all the relevant information in this file, it needs to be compiled by calling:</source>
          <target state="translated">HTML 문서가 &lt;code&gt;.qhp&lt;/code&gt; 되면 확장자가 .qhp 인 &lt;a href=&quot;qthelpproject#&quot;&gt;Qt 도움말 프로젝트&lt;/a&gt; 파일 을 작성해야합니다. 이 파일에 모든 관련 정보를 지정한 후 다음을 호출하여 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="9bb5a703a85da112bfdfb22564c6b753fb342d2b" translate="yes" xml:space="preserve">
          <source>Once the action is created, it can be used wherever actions are applicable.</source>
          <target state="translated">조치가 작성되면 조치가 적용 가능한 모든 위치에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1f4caca220052a1d05453a5cf60436aa66ce30c" translate="yes" xml:space="preserve">
          <source>Once the animation clip has been populated with data using the above methods, the read-only duration property will be updated by the Qt 3D Animation backend.</source>
          <target state="translated">위의 방법을 사용하여 애니메이션 클립에 데이터가 채워지면 Qt 3D 애니메이션 백엔드에 의해 읽기 전용 지속 시간 속성이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="205b5c208dd11021e42c1f0cb029c8ea2f565ea8" translate="yes" xml:space="preserve">
          <source>Once the application is prepared for publishing, you can create a listing for it in Google Play.</source>
          <target state="translated">애플리케이션을 게시 할 준비가되면 Google Play에서 목록을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea0b767aded5ed6d7f67a23165e680f703e3eddf" translate="yes" xml:space="preserve">
          <source>Once the callback passed to the &lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; object is invoked, the channel has finished initialization and all published objects are accessible to the HTML client via the &lt;code&gt;channel.objects&lt;/code&gt; property. Thus, assuming an object was published with the identifier &quot;foo&quot;, then we can interact with it as shown in the example below. Note that all communication between the HTML client and the QML/C++ server is asynchronous. Properties are cached on the HTML side. Furthermore keep in mind that only QML/C++ data types which can be converted to JSON will be (de-)serialized properly and thus accessible to HTML clients.</source>
          <target state="translated">&lt;a href=&quot;qwebchannel&quot;&gt;QWebChannel&lt;/a&gt; 객체로 전달 된 콜백 이 호출되면 채널 초기화가 완료되고 게시 된 모든 객체는 &lt;code&gt;channel.objects&lt;/code&gt; 속성을 통해 HTML 클라이언트에 액세스 할 수 있습니다. 따라서 개체가 식별자 &quot;foo&quot;로 게시되었다고 가정하면 아래 예와 같이 해당 개체와 상호 작용할 수 있습니다. HTML 클라이언트와 QML / C ++ 서버 간의 모든 통신은 비동기 적입니다. 속성은 HTML 측에 캐시됩니다. 또한 JSON으로 변환 할 수있는 QML / C ++ 데이터 유형 만 올바르게 직렬화 해제되어 HTML 클라이언트가 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4870e02dd16024ea585e0185e39f0f403481f28d" translate="yes" xml:space="preserve">
          <source>Once the character format has been used with a cursor, that format becomes the default format for any text inserted with that cursor until another character format is specified.</source>
          <target state="translated">문자 형식을 커서와 함께 사용하면 해당 문자 형식은 다른 문자 형식이 지정 될 때까지 해당 커서로 삽입 된 텍스트의 기본 형식이됩니다.</target>
        </trans-unit>
        <trans-unit id="496af005595ecb484db08b997602438633276ba2" translate="yes" xml:space="preserve">
          <source>Once the component cache has been cleared, components must be loaded before any new objects can be created.</source>
          <target state="translated">구성 요소 캐시가 지워지면 새 오브젝트를 작성하기 전에 구성 요소를로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="c23878cf26f59a37f5b55e0c5b866fe62d4c572e" translate="yes" xml:space="preserve">
          <source>Once the items have been successfully registered in the store, you can purchase them. Get the previously registered &lt;a href=&quot;qinappproduct&quot;&gt;QInAppProduct&lt;/a&gt; using &lt;a href=&quot;qinappstore#registeredProduct&quot;&gt;registeredProduct&lt;/a&gt;() and call &lt;a href=&quot;qinappproduct#purchase&quot;&gt;QInAppProduct::purchase&lt;/a&gt;(). This call is also asynchronous.</source>
          <target state="translated">상품이 상점에 등록되면 구입할 수 있습니다. &lt;a href=&quot;qinappstore#registeredProduct&quot;&gt;registeredProduct&lt;/a&gt; ()를 사용하여 이전에 등록 된 &lt;a href=&quot;qinappproduct&quot;&gt;QInAppProduct&lt;/a&gt; 를 &lt;a href=&quot;qinappproduct#purchase&quot;&gt;가져오고 QInAppProduct :: purchase&lt;/a&gt; ()를 호출 하십시오 . 이 호출은 또한 비동기 적입니다.</target>
        </trans-unit>
        <trans-unit id="b5dda2fa2d7123529d9fd69fe7226be909e75bed" translate="yes" xml:space="preserve">
          <source>Once the machine is started, we can post events to it.</source>
          <target state="translated">머신이 시작되면 이벤트를 게시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f87051ba877349a528b632247c69a275e5b35131" translate="yes" xml:space="preserve">
          <source>Once the manifest is added to your project, you can modify it. The most important parts are the application name and the package name. The package name must be unique, and it is recommended to follow the com.mycompany.myappname naming convention. The &quot;com.mycompany&quot; namespace is based on the Internet domain ownership to avoid naming collisions with other applications.</source>
          <target state="translated">매니페스트가 프로젝트에 추가되면 수정할 수 있습니다. 가장 중요한 부분은 응용 프로그램 이름과 패키지 이름입니다. 패키지 이름은 고유해야하며 com.mycompany.myappname 이름 지정 규칙을 따르는 것이 좋습니다. &quot;com.mycompany&quot;네임 스페이스는 다른 응용 프로그램과의 이름 충돌을 피하기 위해 인터넷 도메인 소유권을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="f521cefaaba3fda658fcaf0b5cd9bc12020db606" translate="yes" xml:space="preserve">
          <source>Once the numerical segments have been parsed, the remainder of the string is considered to be the suffix string. The start index of that string will be stored in</source>
          <target state="translated">숫자 세그먼트가 구문 분석되면 나머지 문자열은 접미사 문자열로 간주됩니다. 해당 문자열의 시작 색인은</target>
        </trans-unit>
        <trans-unit id="f1302f6bf7bb8a9fd947b5e568d478ba086c5f3a" translate="yes" xml:space="preserve">
          <source>Once the operation has completed, &lt;a href=&quot;qgeocodereply#locations&quot;&gt;QGeoCodeReply::locations&lt;/a&gt;() can be used to retrieve the results, which will consist of a list of &lt;a href=&quot;qgeolocation&quot;&gt;QGeoLocation&lt;/a&gt; objects. These objects represent a combination of coordinate and address data.</source>
          <target state="translated">작업이 완료되면 &lt;a href=&quot;qgeocodereply#locations&quot;&gt;QGeoCodeReply :: locations&lt;/a&gt; ()를 사용하여 결과를 검색 할 수 있으며, &lt;a href=&quot;qgeolocation&quot;&gt;QGeoLocation&lt;/a&gt; 객체 목록으로 구성 됩니다. 이러한 객체는 좌표 및 주소 데이터의 조합을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="01b5acac21beaef0597f322faf8c937236d32d9e" translate="yes" xml:space="preserve">
          <source>Once the operation has completed, &lt;a href=&quot;qgeoroutereply#routes&quot;&gt;QGeoRouteReply::routes&lt;/a&gt; can be used to retrieve the calculated route or routes.</source>
          <target state="translated">작업이 완료되면 &lt;a href=&quot;qgeoroutereply#routes&quot;&gt;QGeoRouteReply :: routes&lt;/a&gt; 를 사용하여 계산 된 경로를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a1009ef434c48bb9be4042007fd562ae5ccb125" translate="yes" xml:space="preserve">
          <source>Once the operation has completed, &lt;a href=&quot;qgeoroutereply#routes&quot;&gt;QGeoRouteReply::routes&lt;/a&gt; can be used to retrieve the updated route.</source>
          <target state="translated">작업이 완료되면 &lt;a href=&quot;qgeoroutereply#routes&quot;&gt;QGeoRouteReply :: routes&lt;/a&gt; 를 사용하여 업데이트 된 경로를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8237d24f440ae3aaa3b7945827ee52601fc76fe" translate="yes" xml:space="preserve">
          <source>Once the plugin is set, create a &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery&lt;/a&gt; with the appropriate waypoints and other settings, and set the &lt;a href=&quot;qml-qtlocation-routemodel&quot;&gt;RouteModel&lt;/a&gt;'s &lt;a href=&quot;qml-qtlocation-routemodel#query-prop&quot;&gt;query&lt;/a&gt; property. If &lt;a href=&quot;qml-qtlocation-routemodel#autoUpdate-prop&quot;&gt;autoUpdate&lt;/a&gt; is enabled, the update will being automatically. Otherwise, the &lt;a href=&quot;qml-qtlocation-routemodel#update-method&quot;&gt;update&lt;/a&gt; method may be used. By default, &lt;a href=&quot;qml-qtlocation-routemodel#autoUpdate-prop&quot;&gt;autoUpdate&lt;/a&gt; is disabled.</source>
          <target state="translated">플러그인이 설정되면 적절한 웨이 포인트 및 기타 설정 으로 &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery&lt;/a&gt; 를 생성 하고 &lt;a href=&quot;qml-qtlocation-routemodel&quot;&gt;RouteModel&lt;/a&gt; 의 &lt;a href=&quot;qml-qtlocation-routemodel#query-prop&quot;&gt;쿼리&lt;/a&gt; 속성을 설정하십시오 . 경우 &lt;a href=&quot;qml-qtlocation-routemodel#autoUpdate-prop&quot;&gt;자동 업데이트가&lt;/a&gt; 활성화되어 업데이트가 자동으로되는 것입니다. 그렇지 않으면 &lt;a href=&quot;qml-qtlocation-routemodel#update-method&quot;&gt;업데이트&lt;/a&gt; 방법을 사용할 수 있습니다. 기본적으로 &lt;a href=&quot;qml-qtlocation-routemodel#autoUpdate-prop&quot;&gt;자동 업데이트는&lt;/a&gt; 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2a4a4e9814333870e00d88728fd47606694571eb" translate="yes" xml:space="preserve">
          <source>Once the plugin is set, the &lt;a href=&quot;qml-qtlocation-geocodemodel#query-prop&quot;&gt;query&lt;/a&gt; property can be used to specify the address or search string to match. If &lt;a href=&quot;qml-qtlocation-geocodemodel#autoUpdate-prop&quot;&gt;autoUpdate&lt;/a&gt; is enabled, the Model will update its output automatically. Otherwise, the &lt;a href=&quot;qml-qtlocation-geocodemodel#update-method&quot;&gt;update&lt;/a&gt; method may be used. By default, &lt;a href=&quot;qml-qtlocation-geocodemodel#autoUpdate-prop&quot;&gt;autoUpdate&lt;/a&gt; is disabled.</source>
          <target state="translated">플러그인이 설정되면 &lt;a href=&quot;qml-qtlocation-geocodemodel#query-prop&quot;&gt;검색어&lt;/a&gt; 속성을 사용하여 일치하는 주소 또는 검색 문자열을 지정할 수 있습니다. 경우 &lt;a href=&quot;qml-qtlocation-geocodemodel#autoUpdate-prop&quot;&gt;자동 업데이트가&lt;/a&gt; 활성화되어, 모델은 자동으로 출력을 업데이트합니다. 그렇지 않으면 &lt;a href=&quot;qml-qtlocation-geocodemodel#update-method&quot;&gt;업데이트&lt;/a&gt; 방법을 사용할 수 있습니다. 기본적으로 &lt;a href=&quot;qml-qtlocation-geocodemodel#autoUpdate-prop&quot;&gt;자동 업데이트는&lt;/a&gt; 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="51573a29d91f36ec0e9aa557f5fc03263d8d4e9a" translate="yes" xml:space="preserve">
          <source>Once the project is built and installed, the new &lt;code&gt;Time&lt;/code&gt; component is accessible by any QML component that imports the &lt;code&gt;TimeExample&lt;/code&gt; module</source>
          <target state="translated">프로젝트가 빌드되고 설치되면 &lt;code&gt;TimeExample&lt;/code&gt; 모듈 을 가져 오는 QML 구성 요소가 새 &lt;code&gt;Time&lt;/code&gt; 구성 요소에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93b788d9ad88ab09075085e62bbb75e2121a947c" translate="yes" xml:space="preserve">
          <source>Once the request completes successfully the response can be retrieved from the &lt;a href=&quot;qnearfieldtarget#requestResponse&quot;&gt;requestResponse&lt;/a&gt;() function. The response of this request will be a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;.</source>
          <target state="translated">요청이 성공적으로 완료되면 &lt;a href=&quot;qnearfieldtarget#requestResponse&quot;&gt;requestResponse&lt;/a&gt; () 함수 에서 응답을 검색 할 수 있습니다 . 이 요청의 응답은 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b8111f76953cdb0759d595d2a88f5fa509a36db0" translate="yes" xml:space="preserve">
          <source>Once the request completes the response for successfully completed requests can be retrieved from the &lt;a href=&quot;qnearfieldtarget#requestResponse&quot;&gt;requestResponse&lt;/a&gt;() function. The response of this request will be a &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt;&amp;lt;&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">요청이 완료되면 &lt;a href=&quot;qnearfieldtarget#requestResponse&quot;&gt;requestResponse&lt;/a&gt; () 함수 에서 성공적으로 완료된 요청에 대한 응답을 검색 할 수 있습니다 . 이 요청의 응답은 &lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; &amp;lt; &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; &amp;gt;입니다.</target>
        </trans-unit>
        <trans-unit id="6dff09d559cd10dbb9244d06b7374557ff114f63" translate="yes" xml:space="preserve">
          <source>Once the request finishes you can handle the results with:</source>
          <target state="translated">요청이 완료되면 다음을 사용하여 결과를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="9675df906f3b4dd39c0f3e7e2d9daa0adf9f201f" translate="yes" xml:space="preserve">
          <source>Once the resources are defined you can use them actively when composing your form. For example, you might want to create a tool button using an icon specified in the resource file.</source>
          <target state="translated">리소스가 정의되면 양식을 작성할 때 적극적으로 사용할 수 있습니다. 예를 들어 리소스 파일에 지정된 아이콘을 사용하여 도구 단추를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cef2ed87f29621407fe223b5c500043ff82db994" translate="yes" xml:space="preserve">
          <source>Once the texture object is created you can obtain the object name from the &lt;a href=&quot;qopengltexture#textureId&quot;&gt;textureId&lt;/a&gt;() function. This may be useful if you wish to make some raw OpenGL calls related to this texture.</source>
          <target state="translated">텍스처 오브젝트가 생성되면 &lt;a href=&quot;qopengltexture#textureId&quot;&gt;textureId&lt;/a&gt; () 함수 에서 오브젝트 이름을 얻을 수 있습니다 . 이 텍스처와 관련된 원시 OpenGL 호출을 원할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a854609fbf0cc0561a8527b2bba9a2242f014e3e" translate="yes" xml:space="preserve">
          <source>Once the window has been embedded into the container, the container will control the window's geometry and visibility. Explicit calls to &lt;a href=&quot;qwindow#setGeometry&quot;&gt;QWindow::setGeometry&lt;/a&gt;(), &lt;a href=&quot;qwindow#show&quot;&gt;QWindow::show&lt;/a&gt;() or &lt;a href=&quot;qwindow#hide&quot;&gt;QWindow::hide&lt;/a&gt;() on an embedded window is not recommended.</source>
          <target state="translated">윈도우가 컨테이너에 포함되면 컨테이너는 윈도우의 지오메트리와 가시성을 제어합니다. 내장 된 창 에서 &lt;a href=&quot;qwindow#setGeometry&quot;&gt;QWindow :: setGeometry&lt;/a&gt; (), &lt;a href=&quot;qwindow#show&quot;&gt;QWindow :: show&lt;/a&gt; () 또는 &lt;a href=&quot;qwindow#hide&quot;&gt;QWindow :: hide&lt;/a&gt; ()에 대한 명시 적 호출 은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf2e6243d5e6c8c2c5e1273d53d655f0a1ad06bd" translate="yes" xml:space="preserve">
          <source>Once these details are added, &lt;b&gt;Activate&lt;/b&gt; the product. If you have not published the application yet, the product is marked as &lt;b&gt;To be activated&lt;/b&gt;. Otherwise, it is marked as active. The product must be activated before it can be queried from the Qt Purchasing API. If the application has recently been published, then it may take a few hours before the in-app products can be accessed from your application. Look for the &lt;b&gt;Updates pending&lt;/b&gt; label on the top right side of the screen. If this is visible, then there are updates pending which are not yet visible from the outside.</source>
          <target state="translated">이러한 세부 사항이 추가되면 제품을 &lt;b&gt;활성화&lt;/b&gt; 하십시오. 아직 애플리케이션을 공개하지 않은 경우 제품은 &lt;b&gt;활성화&lt;/b&gt; 됨으로 표시 &lt;b&gt;됩니다&lt;/b&gt; . 그렇지 않으면 활성으로 표시됩니다. Qt 구매 API에서 쿼리하기 전에 제품을 활성화해야합니다. 응용 프로그램이 최근에 게시 된 경우 응용 프로그램에서 인앱 제품에 액세스하려면 몇 시간이 걸릴 수 있습니다. 화면 오른쪽 상단 에서 &lt;b&gt;업데이트 보류 중&lt;/b&gt; 레이블을 찾으십시오 . 이것이 보이는 경우 아직 외부에서 볼 수없는 업데이트 보류 중입니다.</target>
        </trans-unit>
        <trans-unit id="a7f71a05800de7ca2d4dd08b9121a4d845b7a47f" translate="yes" xml:space="preserve">
          <source>Once this is registered, the type can be used in QML by importing the specified type namespace and version number:</source>
          <target state="translated">등록되면 지정된 유형 네임 스페이스 및 버전 번호를 가져 와서 QML에서 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d11ad319c8411fb480cef806b8c18cbdbaa86f1" translate="yes" xml:space="preserve">
          <source>Once widgets have been inserted into a layout, it is not possible to move and resize them individually because the layout itself controls the geometry of each widget within it, taking account of the hints provided by spacers. Spacers can be added to the layout to influence the geometries of the widgets.</source>
          <target state="translated">위젯이 레이아웃에 삽입 된 후에는 레이아웃 자체가 스페이서에서 제공하는 힌트를 고려하여 레이아웃 자체가 위젯 내 각 위젯의 지오메트리를 제어하므로 개별적으로 이동하고 크기를 조정할 수 없습니다. 위젯의 형상에 영향을주기 위해 스페이서를 레이아웃에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48f853c377dfafa75d073fe8c2ac1f2d9bbf4804" translate="yes" xml:space="preserve">
          <source>Once you are done with the thread, call &lt;a href=&quot;qthreadpool#releaseThread&quot;&gt;releaseThread&lt;/a&gt;() to allow it to be reused.</source>
          <target state="translated">스레드가 완료되면 &lt;a href=&quot;qthreadpool#releaseThread&quot;&gt;releaseThread&lt;/a&gt; ()를 호출 하여 재사용 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="4f99787523ca86812e43fea58bf63058f32b7a4f" translate="yes" xml:space="preserve">
          <source>Once you have a &lt;a href=&quot;qml-qtqml-component&quot;&gt;Component&lt;/a&gt;, you can call its &lt;a href=&quot;qml-qtqml-component#createObject-method&quot;&gt;createObject()&lt;/a&gt; method to create an instance of the component. This function can take one or two arguments:</source>
          <target state="translated">당신은 일단 &lt;a href=&quot;qml-qtqml-component&quot;&gt;구성 요소&lt;/a&gt; , 당신은 호출 할 수 있습니다 &lt;a href=&quot;qml-qtqml-component#createObject-method&quot;&gt;CreateObject를 ()&lt;/a&gt; 구성 요소의 인스턴스를 만들 수있는 방법을. 이 함수는 하나 또는 두 개의 인수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c640f9181d5bd6296e2924bbca96e44926980a3" translate="yes" xml:space="preserve">
          <source>Once you have a custom widget plugin for</source>
          <target state="translated">에 대한 사용자 정의 위젯 플러그인이 있으면</target>
        </trans-unit>
        <trans-unit id="6e7fd47ef3ed9aa04b7236db70c3b3a14b8dea7b" translate="yes" xml:space="preserve">
          <source>Once you have a form window's cursor interface, you can check if the form window has a selection at all using the &lt;a href=&quot;qdesignerformwindowcursorinterface#hasSelection&quot;&gt;hasSelection&lt;/a&gt;() function. You can query the form window for its total &lt;a href=&quot;qdesignerformwindowcursorinterface#widgetCount&quot;&gt;widgetCount&lt;/a&gt;() and &lt;a href=&quot;qdesignerformwindowcursorinterface#selectedWidgetCount&quot;&gt;selectedWidgetCount&lt;/a&gt;(). You can retrieve the currently selected widget (or widgets) using the &lt;a href=&quot;qdesignerformwindowcursorinterface#current&quot;&gt;current&lt;/a&gt;() or &lt;a href=&quot;qdesignerformwindowcursorinterface#selectedWidget&quot;&gt;selectedWidget&lt;/a&gt;() functions.</source>
          <target state="translated">양식 창의 커서 인터페이스가 있으면 &lt;a href=&quot;qdesignerformwindowcursorinterface#hasSelection&quot;&gt;hasSelection&lt;/a&gt; () 함수를 사용하여 양식 창에 선택 항목이 있는지 확인할 수 있습니다 . 총 &lt;a href=&quot;qdesignerformwindowcursorinterface#widgetCount&quot;&gt;widgetCount&lt;/a&gt; () 및 &lt;a href=&quot;qdesignerformwindowcursorinterface#selectedWidgetCount&quot;&gt;selectedWidgetCount&lt;/a&gt; ()에 대해 양식 창을 쿼리 할 수 ​​있습니다 . &lt;a href=&quot;qdesignerformwindowcursorinterface#current&quot;&gt;현재&lt;/a&gt; () 또는 &lt;a href=&quot;qdesignerformwindowcursorinterface#selectedWidget&quot;&gt;selectedWidget&lt;/a&gt; () 함수를 사용하여 현재 선택된 위젯 (또는 위젯)을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86f4ced0f47e3cdafee5ebd0c20cd011a17a4dce" translate="yes" xml:space="preserve">
          <source>Once you have added your layout you can start putting widgets and other layouts into the cells of your grid layout using &lt;a href=&quot;qgridlayout#addWidget-1&quot;&gt;addWidget&lt;/a&gt;(), &lt;a href=&quot;qgridlayout#addItem&quot;&gt;addItem&lt;/a&gt;(), and &lt;a href=&quot;qgridlayout#addLayout&quot;&gt;addLayout&lt;/a&gt;().</source>
          <target state="translated">레이아웃을 추가 한 후에는 &lt;a href=&quot;qgridlayout#addWidget-1&quot;&gt;addWidget&lt;/a&gt; (), &lt;a href=&quot;qgridlayout#addItem&quot;&gt;addItem&lt;/a&gt; () 및 &lt;a href=&quot;qgridlayout#addLayout&quot;&gt;addLayout&lt;/a&gt; ()을 사용하여 위젯 및 기타 레이아웃을 그리드 레이아웃의 셀에 넣을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25fd7c4374dacc7fdac166445af55cb19e44130f" translate="yes" xml:space="preserve">
          <source>Once you have created a event object using Windows API such as CreateEvent() or OpenEvent(), you can create an event notifier to monitor the event handle. If the event notifier is enabled, it will emit the &lt;a href=&quot;qwineventnotifier#activated&quot;&gt;activated&lt;/a&gt;() signal whenever the corresponding event object is signalled.</source>
          <target state="translated">CreateEvent () 또는 OpenEvent ()와 같은 Windows API를 사용하여 이벤트 객체를 만든 후에는 이벤트 알리미를 만들어 이벤트 핸들을 모니터링 할 수 있습니다. 이벤트 알리미가 활성화 된 경우 해당 이벤트 객체가 시그널링 될 때마다 &lt;a href=&quot;qwineventnotifier#activated&quot;&gt;활성화 된&lt;/a&gt; () 신호를 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="ad85489ea8db0c725079f5ce1c8dbf56a58f4d84" translate="yes" xml:space="preserve">
          <source>Once you have created your iTunes test user, you will be able to log in to the sandbox app store when developing your app.</source>
          <target state="translated">iTunes 테스트 사용자를 생성하면 앱을 개발할 때 샌드 박스 앱 스토어에 로그인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58b03b1720b139f341a87cbf7ff93042e86f9554" translate="yes" xml:space="preserve">
          <source>Once you have done this, you can add boxes to the &lt;a href=&quot;qboxlayout&quot;&gt;QBoxLayout&lt;/a&gt; using one of four functions:</source>
          <target state="translated">이 작업을 완료하면 다음 네 가지 기능 중 하나를 사용 하여 &lt;a href=&quot;qboxlayout&quot;&gt;QBoxLayout&lt;/a&gt; 에 상자를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f03a38ef87621940dfad6538c8a44a1d3f2e107" translate="yes" xml:space="preserve">
          <source>Once you have installed Qt, you can start</source>
          <target state="translated">Qt를 설치하면 시작할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="95048dcfd3150cfb77e6dc7ba9e8b45084bb3618" translate="yes" xml:space="preserve">
          <source>Once you have loaded the SVG file successfully, you can render it with the &lt;a href=&quot;qsvgrenderer#render&quot;&gt;QSvgRenderer::render&lt;/a&gt;() function. Note that this scheme allows you to render SVG files on all paint devices supported by Qt, including &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;, QGLWidget, and &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. See the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsvg-svgviewer-example.html#&quot;&gt;SVG Viewer&lt;/a&gt; example for more details.</source>
          <target state="translated">SVG 파일을 성공적으로로드하면 &lt;a href=&quot;qsvgrenderer#render&quot;&gt;QSvgRenderer :: render&lt;/a&gt; () 함수를 사용하여 렌더링 할 수 있습니다 . 이 체계를 사용하면 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; , QGLWidget 및 &lt;a href=&quot;qimage&quot;&gt;QImage를&lt;/a&gt; 포함하여 Qt가 지원하는 모든 페인트 장치에서 SVG 파일을 렌더링 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtsvg-svgviewer-example.html#&quot;&gt;SVG 뷰어&lt;/a&gt; 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ead5f946dd8a41570e30cb9f83c06bd9bcc6cc49" translate="yes" xml:space="preserve">
          <source>Once you have opened a device using a low-level (usually platform-specific) API, you can create a socket notifier to monitor the file descriptor. The socket notifier is enabled by default, i.e. it emits the &lt;a href=&quot;qsocketnotifier#activated&quot;&gt;activated&lt;/a&gt;() signal whenever a socket event corresponding to its type occurs. Connect the &lt;a href=&quot;qsocketnotifier#activated&quot;&gt;activated&lt;/a&gt;() signal to the slot you want to be called when an event corresponding to your socket notifier's type occurs.</source>
          <target state="translated">저수준 (일반적으로 플랫폼 별) API를 사용하여 장치를 열면 파일 설명자를 모니터링하는 소켓 알리미를 만들 수 있습니다. 소켓 알리미는 기본적으로 활성화되어 있습니다. 즉, 해당 유형에 해당하는 소켓 이벤트가 발생할 때마다 &lt;a href=&quot;qsocketnotifier#activated&quot;&gt;활성화 된&lt;/a&gt; () 신호를 방출 합니다. 소켓 알리미 유형에 해당하는 이벤트가 발생할 때 호출하려는 슬롯에 &lt;a href=&quot;qsocketnotifier#activated&quot;&gt;활성화 된&lt;/a&gt; () 신호를 연결하십시오 .</target>
        </trans-unit>
        <trans-unit id="587696ac7394a789e6d77c3e76bb0fb746a545e6" translate="yes" xml:space="preserve">
          <source>Once you have successfully created a VAO the typical usage pattern is:</source>
          <target state="translated">VAO를 성공적으로 생성하면 일반적인 사용 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d0d6925f527558c514eaf74004bfb2fa5c285db" translate="yes" xml:space="preserve">
          <source>Once you have supplied a replacement drop action, call &lt;a href=&quot;qevent#accept&quot;&gt;accept&lt;/a&gt;() instead of &lt;a href=&quot;qdropevent#acceptProposedAction&quot;&gt;acceptProposedAction&lt;/a&gt;().</source>
          <target state="translated">대체 삭제 조치를 제공 한 후 &lt;a href=&quot;qdropevent#acceptProposedAction&quot;&gt;acceptProposedAction&lt;/a&gt; () 대신 &lt;a href=&quot;qevent#accept&quot;&gt;accept&lt;/a&gt; ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc887faa98989e4a295984bfa5e50ddccee219e1" translate="yes" xml:space="preserve">
          <source>Once you have the form window, you can query its properties. For example, a plain custom widget plugin is managed by</source>
          <target state="translated">양식 창이 있으면 속성을 쿼리 할 수 ​​있습니다. 예를 들어 일반 사용자 정의 위젯 플러그인은</target>
        </trans-unit>
        <trans-unit id="0cb9d678077cb6771f2d5c1164d88f0d756afb40" translate="yes" xml:space="preserve">
          <source>Once you know that the ports are ready to read or write, you can use the &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt;() or &lt;a href=&quot;qiodevice#write&quot;&gt;write&lt;/a&gt;() methods. Alternatively the &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt;() and &lt;a href=&quot;qiodevice#readAll&quot;&gt;readAll&lt;/a&gt;() convenience methods can also be invoked. If not all the data is read at once, the remaining data will be available for later as new incoming data is appended to the &lt;a href=&quot;qserialport&quot;&gt;QSerialPort&lt;/a&gt;'s internal read buffer. You can limit the size of the read buffer using &lt;a href=&quot;qserialport#setReadBufferSize&quot;&gt;setReadBufferSize&lt;/a&gt;().</source>
          <target state="translated">포트가 읽거나 쓸 준비가되었음을 알게되면 &lt;a href=&quot;qiodevice#read&quot;&gt;read&lt;/a&gt; () 또는 &lt;a href=&quot;qiodevice#write&quot;&gt;write&lt;/a&gt; () 메소드를 사용할 수 있습니다 . 또는 &lt;a href=&quot;qiodevice#readLine&quot;&gt;readLine&lt;/a&gt; () 및 &lt;a href=&quot;qiodevice#readAll&quot;&gt;readAll&lt;/a&gt; () 편의 메소드를 호출 할 수도 있습니다. 모든 데이터를 한 번에 읽을 수없는 경우 새로운 수신 데이터가 &lt;a href=&quot;qserialport&quot;&gt;QSerialPort&lt;/a&gt; 의 내부 읽기 버퍼에 추가 될 때 나머지 데이터를 나중에 사용할 수 있습니다 . &lt;a href=&quot;qserialport#setReadBufferSize&quot;&gt;setReadBufferSize&lt;/a&gt; ()를 사용하여 읽기 버퍼의 크기를 제한 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e4978bbca70c81bd39582d9d963d8617f1d74dd" translate="yes" xml:space="preserve">
          <source>Once your app is registered in iTunes Connect you will have additional options available to manage that App. In the &lt;b&gt;Manage Your Apps&lt;/b&gt; page of iTunes Connect, click the icon representing your app to manage its details. Within this menu you can select the &lt;b&gt;Manage In-App Purchases&lt;/b&gt; button on the right to register in-app products you wish to offer.</source>
          <target state="translated">App이 iTunes Connect에 등록되면 해당 App을 관리하기위한 추가 옵션이 제공됩니다. (가)에서 &lt;b&gt;내 앱의 관리를&lt;/b&gt; 아이튠즈에 연결 페이지를 세부 정보를 관리 할 응용 프로그램을 나타내는 아이콘을 클릭합니다. 이 메뉴 내 에서 오른쪽의 &lt;b&gt;인앱 구매 관리&lt;/b&gt; 버튼을 선택하여 제공하려는 인앱 제품을 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82c37a941ba03279b12ed1a3e19e39a2cd9bc7f3" translate="yes" xml:space="preserve">
          <source>Once your products are registered you will be able to purchase them from your app. When you are developing your app it is desirable to test buying your products without spending real currency. There are actually two separate stores that requests can be sent to when using the In-App Purchasing service on iOS. While your app is being developed, any iOS App Store requests will be sent to a sandbox store. This occurs when your app has been signed with a developer Provisioning Profile. The sandbox store will only accept requests from test users and will not charge for the purchases. However, when you submit your app to the iOS App Store and it is accepted, all in-app purchasing requests are sent to the production store, which requires real iTunes users accounts, and will charge for the purchases.</source>
          <target state="translated">제품이 등록되면 앱에서 제품을 구입할 수 있습니다. 앱을 개발할 때 실제 통화를 소비하지 않고 제품 구매를 테스트하는 것이 바람직합니다. iOS에서 인앱 구매 서비스를 사용할 때 실제로 요청을 보낼 수있는 두 개의 개별 저장소가 있습니다. 앱이 개발되는 동안 모든 iOS 앱 스토어 요청은 샌드 박스 스토어로 전송됩니다. 앱이 개발자 프로비저닝 프로파일로 서명 된 경우 발생합니다. 샌드 박스 저장소는 테스트 사용자의 요청 만 수락하며 구매 비용을 청구하지 않습니다. 그러나 앱을 iOS App Store에 제출하고 승인하면 모든 인앱 구매 요청이 프로덕션 스토어로 전송되며, 실제 iTunes 사용자 계정이 필요하며 구매 비용이 청구됩니다.</target>
        </trans-unit>
        <trans-unit id="68a40ec4ea1c7cab77a9f3596ca2355b12bad46e" translate="yes" xml:space="preserve">
          <source>One advantage of using &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; as a paint device is that it is possible to guarantee the pixel exactness of any drawing operation in a platform-independent way. Another benefit is that the painting can be performed in another thread than the current GUI thread.</source>
          <target state="translated">페인트 장치로 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 를 사용 하면 플랫폼 독립적 인 방식으로 모든 드로잉 작업의 픽셀 정확도를 보장 할 수 있다는 이점 이 있습니다. 또 다른 이점은 현재 GUI 스레드가 아닌 다른 스레드에서 페인팅을 수행 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="552d0d068ba98a7ae885e564b90cd22da8285c55" translate="yes" xml:space="preserve">
          <source>One advantage of using &lt;a href=&quot;qstring#arg&quot;&gt;arg&lt;/a&gt;() over &lt;a href=&quot;qstring#asprintf&quot;&gt;asprintf&lt;/a&gt;() is that the order of the numbered place markers can change, if the application's strings are translated into other languages, but each &lt;a href=&quot;qstring#arg&quot;&gt;arg&lt;/a&gt;() will still replace the lowest-numbered unreplaced place-marker, no matter where it appears. Also, if place-marker &lt;code&gt;%i&lt;/code&gt; appears more than once in the string, &lt;a href=&quot;qstring#arg&quot;&gt;arg&lt;/a&gt;() replaces all of them.</source>
          <target state="translated">&lt;a href=&quot;qstring#asprintf&quot;&gt;asprintf&lt;/a&gt; ()보다 &lt;a href=&quot;qstring#arg&quot;&gt;arg&lt;/a&gt; () 를 사용 하면 응용 프로그램의 문자열이 다른 언어로 번역 된 경우 번호가 매겨진 자리 표시 자의 순서가 변경 될 수 있지만 각 &lt;a href=&quot;qstring#arg&quot;&gt;arg&lt;/a&gt; ()는 여전히 교체되지 않은 가장 낮은 자리 표시자를 대체합니다. 어디에 있든지 상관 없습니다. 또한 장소 표시기 &lt;code&gt;%i&lt;/code&gt; 가 문자열에 두 번 이상 나타나면 &lt;a href=&quot;qstring#arg&quot;&gt;arg&lt;/a&gt; ()가 모든 것을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="8a496cae007faea94b56b0456c6f81a542d18513" translate="yes" xml:space="preserve">
          <source>One advantage of using arg() over &lt;a href=&quot;qstring#asprintf&quot;&gt;asprintf&lt;/a&gt;() is that the order of the numbered place markers can change, if the application's strings are translated into other languages, but each arg() will still replace the lowest numbered unreplaced place marker, no matter where it appears. Also, if place marker &lt;code&gt;%i&lt;/code&gt; appears more than once in the string, the arg() replaces all of them.</source>
          <target state="translated">&lt;a href=&quot;qstring#asprintf&quot;&gt;asprintf&lt;/a&gt; ()에 비해 arg ()를 사용 하면 응용 프로그램의 문자열이 다른 언어로 번역 된 경우 번호가 매겨진 자리 표시 자의 순서가 변경 될 수 있지만 각 arg ()는 여전히 가장 낮은 번호의 대체되지 않은 장소 표식을 대체합니다. 그것이 나타나는 곳. 또한 자리 표시 자 &lt;code&gt;%i&lt;/code&gt; 가 문자열에 두 번 이상 나타나면 arg ()가 모든 것을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="3651c6efb4c28103edacfd4bc6574f7b189b8dbf" translate="yes" xml:space="preserve">
          <source>One button has no elevation, and the other has an elevation of &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">한 버튼에는 표고가없고 다른 버튼에는 표고가 &lt;code&gt;10&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c7462448543cbd1c364bf32e079f8120754aeedc" translate="yes" xml:space="preserve">
          <source>One call</source>
          <target state="translated">한 번의 전화</target>
        </trans-unit>
        <trans-unit id="1d31b5cb24602913e72c9b9c94c60333e286c2d6" translate="yes" xml:space="preserve">
          <source>One call/Permanent</source>
          <target state="translated">한 번의 통화 / 영구</target>
        </trans-unit>
        <trans-unit id="4615cf68efe02b80727d8bb5e130a46af5cc2480" translate="yes" xml:space="preserve">
          <source>One can write a switch table like so:</source>
          <target state="translated">다음과 같이 스위치 테이블을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="021a5a769eb2a744869076c94a4ea5e56547536b" translate="yes" xml:space="preserve">
          <source>One caveat to using the latest Xcode version and SDK to build your application is that macOS's system frameworks will sometimes decide whether or not to enable behavior changes based on the SDK you built your application with.</source>
          <target state="translated">최신 Xcode 버전과 SDK를 사용하여 응용 프로그램을 빌드 할 때주의해야 할 점은 macOS의 시스템 프레임 워크가 응용 프로그램을 빌드 한 SDK를 기반으로 동작 변경을 활성화할지 여부를 결정한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="87ebc6df2d743bdf4de7159a1f5bedb57c85b959" translate="yes" xml:space="preserve">
          <source>One classic use of a tool button is to select tools; for example, the &quot;pen&quot; tool in a drawing program. This would be implemented by using a &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; as a toggle button (see &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;setCheckable&lt;/a&gt;()).</source>
          <target state="translated">툴 버튼의 전형적인 사용은 툴을 선택하는 것입니다. 예를 들어, 드로잉 프로그램의 &quot;펜&quot;도구입니다. 이것은 &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; 을 토글 버튼으로 사용하여 구현됩니다 ( &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;setCheckable&lt;/a&gt; () 참조 ).</target>
        </trans-unit>
        <trans-unit id="9e8892553d88581416dd3b2fcd31e82c19652dca" translate="yes" xml:space="preserve">
          <source>One common use of regexps is to split lines of delimited data into their component fields.</source>
          <target state="translated">정규 표현식의 일반적인 용도 중 하나는 구분 된 데이터 행을 구성 요소 필드로 분할하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a24ebc94394fa5f9d9f697e53dcf5f013c959c9e" translate="yes" xml:space="preserve">
          <source>One consequence of this is that setting a style rule on a widget automatically gives it precedence over other rules specified in the ancestor widgets' style sheets or the &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; style sheet. Consider the following example. First, we set a style sheet on the &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt;:</source>
          <target state="translated">그 결과 위젯에 스타일 규칙을 설정하면 &lt;a href=&quot;qapplication&quot;&gt;상위&lt;/a&gt; 위젯의 스타일 시트 또는 QApplication 스타일 시트에 지정된 다른 규칙보다 자동으로 우선 순위가 부여됩니다 . 다음 예를 고려하십시오. 먼저 &lt;a href=&quot;qapplication&quot;&gt;QApplication&lt;/a&gt; 에서 스타일 시트를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="38908edf573bb7b97e00bc1e6ec62c659e5cdcf0" translate="yes" xml:space="preserve">
          <source>One dash, two dots, one dash, two dots.</source>
          <target state="translated">하나의 대시, 두 개의 점, 하나의 대시, 두 개의 점.</target>
        </trans-unit>
        <trans-unit id="bb641bfb37d3bb45179d996104a3fdbdef166310" translate="yes" xml:space="preserve">
          <source>One data model can only belong to one state machine.</source>
          <target state="translated">하나의 데이터 모델은 하나의 상태 시스템에만 속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d9cb7313469561dfcceffea7241129fa4481e2e" translate="yes" xml:space="preserve">
          <source>One does not need to understand the internals of the renderer to get good performance. However, it might help when integrating with the scene graph or to figure out why it is not possible to squeeze the maximum efficiency out of the graphics chip.</source>
          <target state="translated">좋은 성능을 얻기 위해 렌더러의 내부를 이해할 필요는 없습니다. 그러나 장면 그래프와 통합하거나 그래픽 칩에서 최대 효율을 짜낼 수없는 이유를 알아내는 것이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d322aa94d574b82fc6b52bfde114ac5315193aae" translate="yes" xml:space="preserve">
          <source>One entry in an associative container: both the key and the value form one map-entry type.</source>
          <target state="translated">연관 컨테이너에있는 하나의 항목 : 키와 값 모두 하나의 맵 입력 유형을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="a7e131d96d2f2dc51922f5d25204edf525fe4a8e" translate="yes" xml:space="preserve">
          <source>One example of direct use is to forward errors that stem from a scripting language, e.g. QML:</source>
          <target state="translated">직접 사용의 한 예는 스크립팅 언어에서 발생하는 오류 (예 : QML)를 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="924d7d4ee16dfff2662059020c1bdf8cf28b1b66" translate="yes" xml:space="preserve">
          <source>One frequent need for the transformation matrix is when reusing the same drawing code on a variety of paint devices. Without transformations, the results are tightly bound to the resolution of the paint device. Printers have high resolution, e.g. 600 dots per inch, whereas screens often have between 72 and 100 dots per inch.</source>
          <target state="translated">변환 매트릭스에 대한 한 가지 빈번한 요구는 다양한 페인트 장치에서 동일한 도면 코드를 재사용 할 때입니다. 변형이 없으면 결과가 페인트 장치의 해상도에 밀접하게 바인딩됩니다. 프린터는 해상도가 높으며 (예 : 인치당 600 도트) 화면은 종종 인치당 72-100 도트입니다.</target>
        </trans-unit>
        <trans-unit id="a41737d2b52315e3e7b77b5a84fc7cc9fe2b25ce" translate="yes" xml:space="preserve">
          <source>One input handler can control one scene. Setting a scene to an input handler does not transfer the ownership of the scene.</source>
          <target state="translated">하나의 입력 핸들러가 하나의 장면을 제어 할 수 있습니다. 장면을 입력 핸들러로 설정하면 장면의 소유권이 이전되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df1b400b13392aa822e4cb0b5acdac49738c9c08" translate="yes" xml:space="preserve">
          <source>One instance per day of month.</source>
          <target state="translated">한 달에 한 번 인스턴스.</target>
        </trans-unit>
        <trans-unit id="f3183f5f9d7dcdfd03d2cd7a8ac85c86fb10dfc4" translate="yes" xml:space="preserve">
          <source>One instance per day of week.</source>
          <target state="translated">요 일당 하나의 인스턴스.</target>
        </trans-unit>
        <trans-unit id="ba0ceb58ac884f9abf155cd9df5794beb04c7727" translate="yes" xml:space="preserve">
          <source>One instance per week.</source>
          <target state="translated">주당 하나의 인스턴스.</target>
        </trans-unit>
        <trans-unit id="3589f2b7c774a6be6d231f82ea0f6fae4a5452d0" translate="yes" xml:space="preserve">
          <source>One major cost of using JavaScript is that in most cases when a property from a QML type is accessed, a JavaScript object with an external resource containing the underlying C++ data (or a reference to it) is created. In most cases, this is fairly inexpensive, but in others it can be quite expensive. One example of where it is expensive is assigning a C++ &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt;&lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt; to a QML &quot;variant&quot; property. Lists can also be expensive, although sequences of specific types (&lt;a href=&quot;qlist&quot;&gt;QList&lt;/a&gt; of int, qreal, bool, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, and &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;) should be inexpensive; other list types involve an expensive conversion cost (creating a new JavaScript Array, and adding new types one by one, with per-type conversion from C++ type instance to JavaScript value).</source>
          <target state="translated">JavaScript를 사용하는 주요 비용 중 하나는 대부분의 경우 QML 유형의 특성에 액세스 할 때 기본 C ++ 데이터 (또는 이에 대한 참조)를 포함하는 외부 자원이있는 JavaScript 오브젝트가 작성되는 것입니다. 대부분의 경우 이것은 상당히 비싸지 만 다른 경우에는 꽤 비쌀 수 있습니다. 비용이 많이 드는 예 중 하나는 C ++ &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap &lt;/a&gt;&lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt; 를 QML &quot;variant&quot;속성에 할당하는 것 입니다. 특정 유형의 시퀀스 ( int, qreal, bool, &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 및 &lt;a href=&quot;qurl&quot;&gt;QUrl의 &lt;/a&gt;&lt;a href=&quot;qlist&quot;&gt;QList)&lt;/a&gt; 에도 불구하고 목록은 비쌀 수 있습니다.) 저렴해야한다. 다른 목록 유형에는 변환 비용이 많이 듭니다 (새로운 JavaScript 배열 작성 및 C ++ 유형 인스턴스에서 JavaScript 값으로 유형별로 변환하여 하나씩 새 유형 추가).</target>
        </trans-unit>
        <trans-unit id="f8e864d68489bf38b989fae405a3102cc97b5939" translate="yes" xml:space="preserve">
          <source>One of &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt;'s greatest strengths is its ability to efficiently determine the location of items. Even with millions of items on the scene, the &lt;a href=&quot;qgraphicsscene#items&quot;&gt;items&lt;/a&gt;() functions can determine the location of an item within a few milliseconds. There are several overloads to &lt;a href=&quot;qgraphicsscene#items&quot;&gt;items&lt;/a&gt;(): one that finds items at a certain position, one that finds items inside or intersecting with a polygon or a rectangle, and more. The list of returned items is sorted by stacking order, with the topmost item being the first item in the list. For convenience, there is also an &lt;a href=&quot;qgraphicsscene#itemAt&quot;&gt;itemAt&lt;/a&gt;() function that returns the topmost item at a given position.</source>
          <target state="translated">&lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 의 가장 큰 강점 중 하나는 항목의 위치를 ​​효율적으로 결정하는 능력입니다. 장면에 수백만 개의 항목이 있어도 &lt;a href=&quot;qgraphicsscene#items&quot;&gt;items&lt;/a&gt; () 함수는 몇 밀리 초 내에 항목의 위치를 ​​결정할 수 있습니다. &lt;a href=&quot;qgraphicsscene#items&quot;&gt;항목&lt;/a&gt; () 에는 여러 가지 과부하가 있습니다 . 하나는 특정 위치에서 항목을 찾거나 하나는 다각형 또는 사각형 내부 또는 교차하는 항목을 찾습니다. 반환 된 항목 목록은 스택 순서에 따라 정렬되며 최상위 항목은 목록의 첫 번째 항목입니다. 편의상 주어진 위치에서 최상위 항목을 반환 하는 &lt;a href=&quot;qgraphicsscene#itemAt&quot;&gt;itemAt&lt;/a&gt; () 함수 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6877a7adf6c6f197b61a3386bee49d537fed067e" translate="yes" xml:space="preserve">
          <source>One of Qt's key features, to enable this information exchange, is the distinction between an object's API (defined by its properties, signals, and slots) and the implementation of that API. QtRO's purpose is to meet that expected API, even if the true &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is in a different process. A slot called on a copy of an object (the &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; in QtRO) is forwarded to the true object (the &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; in QtRO) for handling. Every Replica receives updates to the Source, either property changes or emitted signals.</source>
          <target state="translated">이 정보 교환을 가능하게하는 Qt의 주요 기능 중 하나는 객체의 API (속성, 신호 및 슬롯으로 정의)와 해당 API의 구현을 구분하는 것입니다. QtRO의 목적은 실제 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 가 다른 프로세스에 있더라도 예상되는 API를 충족시키는 것입니다 . 오브젝트 사본 ( QtRO 의 &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;복제본)&lt;/a&gt; 에서 호출 된 슬롯 은 처리를 위해 실제 오브젝트 ( QtRO 의 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;소스&lt;/a&gt; )로 전달됩니다 . 모든 복제본은 속성 변경 또는 방출 된 신호 중 하나 인 소스에 대한 업데이트를받습니다.</target>
        </trans-unit>
        <trans-unit id="ab0dc330c8a6c23af3e80e8c2ab7c44bf261e934" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;q3dtheme#ColorStyle-enum&quot;&gt;ColorStyle&lt;/a&gt; enum values.</source>
          <target state="translated">&lt;a href=&quot;q3dtheme#ColorStyle-enum&quot;&gt;ColorStyle&lt;/a&gt; 열거 형 값 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="09637215558791f84dc766275fa305328d994a06" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;qabstract3dgraph#ShadowQuality-enum&quot;&gt;ShadowQuality&lt;/a&gt; enum values. By default, &lt;code&gt;ShadowQualityMedium&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qabstract3dgraph#ShadowQuality-enum&quot;&gt;ShadowQuality&lt;/a&gt; 열거 형 값 중 하나입니다 . 기본적으로 &lt;code&gt;ShadowQualityMedium&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="07d163b1ad469f9585e1ff0e2598072e284c843b" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;qabstract3dinputhandler#InputView-enum&quot;&gt;InputView&lt;/a&gt; enum values.</source>
          <target state="translated">&lt;a href=&quot;qabstract3dinputhandler#InputView-enum&quot;&gt;InputView&lt;/a&gt; 열거 형 값 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="613c05d992a3edd6749c6b40952f8297fa534928" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt::DateFormat&lt;/a&gt; enumeration values, such as &lt;code&gt;Qt.DefaultLocaleShortDate&lt;/code&gt; or &lt;code&gt;Qt.ISODate&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Qt.DefaultLocaleShortDate&lt;/code&gt; 또는 &lt;code&gt;Qt.ISODate&lt;/code&gt; 와 같은 &lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt :: DateFormat&lt;/a&gt; 열거 값 중 하나</target>
        </trans-unit>
        <trans-unit id="f5831d1f70b9397cda568b627e5c2de6827e6831" translate="yes" xml:space="preserve">
          <source>One of the URL schemes built into Qt is the &quot;qrc&quot; scheme. This allows content to be compiled into the executable using &lt;a href=&quot;resources&quot;&gt;The Qt Resource System&lt;/a&gt;. Using this, an executable can reference QML content that is compiled into the executable:</source>
          <target state="translated">Qt에 내장 된 URL 체계 중 하나는 &quot;qrc&quot;체계입니다. 이를 통해 &lt;a href=&quot;resources&quot;&gt;Qt Resource System을&lt;/a&gt; 사용하여 컨텐츠를 실행 파일로 컴파일 할 수 있습니다 . 이를 사용하여 실행 파일은 실행 파일로 컴파일 된 QML 컨텐츠를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de02ef4459ecf6d496f2215936d878afbff5850f" translate="yes" xml:space="preserve">
          <source>One of the core features of QML is that it enables QML object types to be easily defined in a lightweight manner through QML documents to suit the needs of individual QML applications. The standard &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; module provides various types like &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-image&quot;&gt;Image&lt;/a&gt; for building a QML application; beyond these, you can easily define your own QML types to be reused within your application. This ability to create your own types forms the building blocks of any QML application.</source>
          <target state="translated">QML의 핵심 기능 중 하나는 개별 QML 애플리케이션의 요구에 맞게 QML 문서를 통해 QML 객체 유형을 간단한 방식으로 쉽게 정의 할 수 있다는 것입니다. 표준 &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; 모듈은 QML 애플리케이션 구축을 위해 &lt;a href=&quot;qml-qtquick-rectangle&quot;&gt;Rectangle&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-text&quot;&gt;Text&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-image&quot;&gt;Image&lt;/a&gt; 와 같은 다양한 유형을 제공 합니다. 이 외에도 애플리케이션 내에서 재사용 할 자체 QML 유형을 쉽게 정의 할 수 있습니다. 고유 한 유형을 만들 수있는이 기능은 모든 QML 응용 프로그램의 빌딩 블록을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="3809a20bc81eacc8be68aeec501f8c163ad6e90f" translate="yes" xml:space="preserve">
          <source>One of the great advantages of using QML to define a user interface is that it allows the user interface designer to define how the application should react to events with simple JavaScript expressions. In QML, we refer to those events as &lt;a href=&quot;qtqml-syntax-signals&quot;&gt;signals&lt;/a&gt; and these signals are handled by &lt;a href=&quot;qtqml-syntax-signals#qml-signals-and-handlers&quot;&gt;signal handlers&lt;/a&gt;.</source>
          <target state="translated">QML을 사용하여 사용자 인터페이스를 정의 할 때 얻을 수있는 가장 큰 장점 중 하나는 사용자 인터페이스 디자이너가 간단한 JavaScript 표현식으로 응용 프로그램이 이벤트에 반응하는 방식을 정의 할 수 있다는 것입니다. QML에서는 이러한 이벤트를 &lt;a href=&quot;qtqml-syntax-signals&quot;&gt;신호라고&lt;/a&gt; 하며 이러한 신호는 &lt;a href=&quot;qtqml-syntax-signals#qml-signals-and-handlers&quot;&gt;신호 처리기에서 처리&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b4c186fd917df6bd21db9cfed12c08d935e4fbb7" translate="yes" xml:space="preserve">
          <source>One of the key concepts of .NET is the idea of &quot;intermediate language code&quot; - the source code is compiled into a bytecode format, and at runtime, that bytecode is executed in a virtual machine - the</source>
          <target state="translated">.NET의 주요 개념 중 하나는 &quot;중급 언어 코드&quot;라는 아이디어입니다. 소스 코드는 바이트 코드 형식으로 컴파일되고 런타임에 해당 바이트 코드는 가상 머신에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f2165e2cfc45409f48d8a4ff1c18c18165fe8229" translate="yes" xml:space="preserve">
          <source>One of the key goals that most application developers want to achieve is to create a maintainable application. One of the ways to achieve this goal is to separate the user interface from the business logic. The following are a few reasons why an application's UI should be written in QML:</source>
          <target state="translated">대부분의 응용 프로그램 개발자가 달성하고자하는 주요 목표 중 하나는 유지 관리 가능한 응용 프로그램을 만드는 것입니다. 이 목표를 달성하는 방법 중 하나는 사용자 인터페이스와 비즈니스 로직을 분리하는 것입니다. 다음은 QML로 애플리케이션의 UI를 작성해야하는 몇 가지 이유입니다.</target>
        </trans-unit>
        <trans-unit id="cd16d5b033b6834a5a9611e78f3e2213cb9bd2c3" translate="yes" xml:space="preserve">
          <source>One of the most important concepts in QML is that of type re-use. An application will probably have multiple visual types which are all similar (for example, multiple push buttons), and QML allows these sort of things to be defined as re-usable, custom types, to minimize code duplication and maximize readability.</source>
          <target state="translated">QML에서 가장 중요한 개념 중 하나는 재사용 유형입니다. 응용 프로그램에는 아마도 여러 개의 시각적 유형이 모두 비슷할 것입니다 (예 : 다중 누름 버튼). QML을 사용하면 이러한 유형의 항목을 재사용 가능한 사용자 정의 유형으로 정의하여 코드 복제를 최소화하고 가독성을 극대화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="946011cfa449ec7f7b9caff43717b47b8e240db0" translate="yes" xml:space="preserve">
          <source>One of the most useful basic features of Qt is the support for buddy widgets. A buddy widget accepts the input focus on behalf of a &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; when the user types the label's shortcut key combination. The buddy concept is also used in Qt's &lt;a href=&quot;model-view-programming&quot;&gt;model/view&lt;/a&gt; framework.</source>
          <target state="translated">Qt의 가장 유용한 기본 기능 중 하나는 친구 위젯 지원입니다. 사용자가 레이블의 바로 가기 키 조합을 입력하면 대화 상대 위젯이 &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; 대신 입력 초점을 수락합니다 . 친구 개념은 Qt의 &lt;a href=&quot;model-view-programming&quot;&gt;모델 / 뷰&lt;/a&gt; 프레임 워크 에서도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="30363581ec584febf43e57cce904b9c9605766ff" translate="yes" xml:space="preserve">
          <source>One of the requested discovery methods is not supported by the current platform. This value was introduced by Qt 5.8.</source>
          <target state="translated">요청 된 검색 방법 중 하나가 현재 플랫폼에서 지원되지 않습니다. 이 값은 Qt 5.8에 의해 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="27872144c06fca2dc32bc579b3aff1208da29b65" translate="yes" xml:space="preserve">
          <source>One of the requirements to support in-app purchases on iOS is to have a registered unique App ID. This means that it is not possible to use an App ID that contains a wildcard character. You can check the existing App IDs and create new ones from the &lt;a href=&quot;https://developer.apple.com/account/ios/identifiers/bundle/bundleList.action&quot;&gt;Apple Developer Certificate, Identifiers, and Profiles manager&lt;/a&gt;.</source>
          <target state="translated">iOS에서 인앱 구매를 지원하기위한 요구 사항 중 하나는 고유 한 앱 ID를 등록하는 것입니다. 이는 와일드 카드 문자가 포함 된 앱 ID를 사용할 수 없음을 의미합니다. 기존 앱 ID를 확인하고 &lt;a href=&quot;https://developer.apple.com/account/ios/identifiers/bundle/bundleList.action&quot;&gt;Apple 개발자 인증서, 식별자 및 프로파일 관리자&lt;/a&gt; 에서 새 ID를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d829c82306decdaf26640b18173d9b3b96ca0b69" translate="yes" xml:space="preserve">
          <source>One of the signals might be emitted for the current state of the</source>
          <target state="translated">신호 중 하나가 현재 상태에서 방출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7312240af405956c435f0d722687ac2cd9912c5b" translate="yes" xml:space="preserve">
          <source>One or more errors has occurred. Call &lt;a href=&quot;qquickview#errors&quot;&gt;errors&lt;/a&gt;() to retrieve a list of errors.</source>
          <target state="translated">하나 이상의 오류가 발생했습니다. &lt;a href=&quot;qquickview#errors&quot;&gt;오류&lt;/a&gt; 목록을 검색하려면 오류 ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff1d7c07ab82ad3c6fe97e07e506c72e4b39eb60" translate="yes" xml:space="preserve">
          <source>One or more errors occurred. Call &lt;a href=&quot;qquickwidget#errors&quot;&gt;errors&lt;/a&gt;() to retrieve a list of errors.</source>
          <target state="translated">하나 이상의 오류가 발생했습니다. &lt;a href=&quot;qquickwidget#errors&quot;&gt;오류&lt;/a&gt; 목록을 검색하려면 오류 ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c562be14a0f3a541154814641a1055fb9c8c75c" translate="yes" xml:space="preserve">
          <source>One or two occurrences of &lt;a href=&quot;#length&quot;&gt;Length&lt;/a&gt;. If only one length is specified, it is used as the radius of the quarter circle defining the corner. If two lengths are specified, the first length is the horizontal radius of a quarter ellipse, whereas the second length is the vertical radius.</source>
          <target state="translated">&lt;a href=&quot;#length&quot;&gt;Length가&lt;/a&gt; 한두 번 나타납니다 . 길이가 하나만 지정된 경우 모서리를 정의하는 1/4 원의 반지름으로 사용됩니다. 두 개의 길이를 지정하면 첫 번째 길이는 1/4 타원의 가로 반지름이고 두 번째 길이는 세로 반지름입니다.</target>
        </trans-unit>
        <trans-unit id="463a49dac2612f25b516e3cb3a7d4930f9d855ca" translate="yes" xml:space="preserve">
          <source>One or two pixel space between the menu bar and the dockarea, as done on Windows.</source>
          <target state="translated">Windows에서와 같이 메뉴 표시 줄과 도크 영역 사이에 하나 또는 두 개의 픽셀 공간이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab6ea547facb8d8e1977c533d0dff798d91798e2" translate="yes" xml:space="preserve">
          <source>One pixel wide pen</source>
          <target state="translated">1 픽셀 너비의 펜</target>
        </trans-unit>
        <trans-unit id="a1ef8c08328d1edf403fc8a36daace2fa3784639" translate="yes" xml:space="preserve">
          <source>One possible use case is to add this handler to a transparent Item which is on top of the rest of the scene (by having a high &lt;a href=&quot;qml-qtquick-item#z-prop&quot;&gt;z&lt;/a&gt; value), so that when a point is freshly pressed, it will be delivered to that Item and its handlers first, providing the opportunity to take the passive grab as early as possible. Such an item (like a pane of glass over the whole UI) can be a convenient parent for other Items which visualize the kind of reactive feedback which must always be on top; and likewise it can be the parent for popups, popovers, dialogs and so on. If it will be used in that way, it can be helpful for your main.cpp to use &lt;a href=&quot;qqmlcontext#setContextProperty&quot;&gt;QQmlContext::setContextProperty()&lt;/a&gt; to make the &quot;glass pane&quot; accessible by ID to the entire UI, so that other Items and PointHandlers can be reparented to it.</source>
          <target state="translated">가능한 사용 사례 중 하나는이 핸들러를 나머지 장면 위에있는 투명한 항목에 추가하고 ( &lt;a href=&quot;qml-qtquick-item#z-prop&quot;&gt;z&lt;/a&gt; 값 이 높음 ) 점을 새로 누르면 해당 항목과 해당 항목에 전달됩니다. 처리기를 먼저 시작하여 가능한 한 빨리 패시브를 잡을 수있는 기회를 제공합니다. 이러한 항목 (전체 UI의 유리 창과 같은)은 항상 맨 위에 있어야하는 반응 형 피드백의 종류를 시각화하는 다른 항목의 편리한 부모가 될 수 있습니다. 마찬가지로 팝업, 팝업, 대화 상자의 부모가 될 수 있습니다. 그런 식으로 사용될 경우 main.cpp가 &lt;a href=&quot;qqmlcontext#setContextProperty&quot;&gt;QQmlContext :: setContextProperty ()&lt;/a&gt; 를 사용하여 ID로 &quot;유리 창&quot;을 전체 UI에 액세스 할 수 있도록하여 다른 항목 및 PointHandler를 다시 만들 수 있습니다. 그것에.</target>
        </trans-unit>
        <trans-unit id="b94b0da25fe601fd37aaafc21d9d291d763695f0" translate="yes" xml:space="preserve">
          <source>One reason why isWritable() might return false is if &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; operates on a read-only file.</source>
          <target state="translated">isWritable ()이 false를 리턴하는 한 가지 이유는 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 가 읽기 전용 파일에서 작동하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="92bef01f9dd59d9f5483ce6e7064d464b098e27d" translate="yes" xml:space="preserve">
          <source>One section tag represents one item in the table of contents. The sections can be nested to any degree, but from a user's perspective it should not be more than four or five levels. A section is defined by its title and reference. The reference, like all file references in a Qt help project, are relative to the help project file itself.</source>
          <target state="translated">섹션 태그 하나는 목차에서 하나의 항목을 나타냅니다. 섹션은 어느 정도 중첩 될 수 있지만 사용자의 관점에서 4 ~ 5 레벨을 넘지 않아야합니다. 섹션은 제목과 참조로 정의됩니다. Qt 도움말 프로젝트의 모든 파일 참조와 마찬가지로 참조는 도움말 프로젝트 파일 자체와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3824fa50476a7eaeee5469d568f55cd47157896c" translate="yes" xml:space="preserve">
          <source>One shot auto focus to objects close to camera.</source>
          <target state="translated">카메라에 가까운 물체에 한 번의 자동 초점.</target>
        </trans-unit>
        <trans-unit id="79890f10172a98fd3ab203c0cf2431528cfa371d" translate="yes" xml:space="preserve">
          <source>One thing to keep in mind from this namespace discussion, whether you run XQueries in a Qt program using Qt XML Patterns, or you run them from the command line using xmlpatterns, is that if you don't get the output you expect, it might be because the data you are querying uses namespaces, but you didn't declare those namespaces in your &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;.</source>
          <target state="translated">Qt XML 패턴을 사용하여 Qt 프로그램에서 XQueries를 실행하든 xmlpatterns를 사용하여 명령 행에서 XQueries를 실행하든,이 네임 스페이스 토론에서 명심해야 할 한 가지는 예상되는 출력을 얻지 못하면 쿼리하는 데이터가 네임 스페이스를 사용하기 때문에 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 에서 해당 네임 스페이스를 선언하지 않았기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="0ddf250291fc0a37a862cc3eb5dcdd0fa9eaffcb" translate="yes" xml:space="preserve">
          <source>One to four occurrences of &lt;a href=&quot;#brush&quot;&gt;Brush&lt;/a&gt;, specifying the top, right, bottom, and left edges of a box, respectively. If the left color is not specified, it is taken to be the same as the right color. If the bottom color is not specified, it is taken to be the same as the top color. If the right color is not specified, it is taken to be the same as the top color.</source>
          <target state="translated">상자의 위쪽, 오른쪽, 아래쪽 및 왼쪽 가장자리를 각각 지정하는 1 ~ 4 개의 &lt;a href=&quot;#brush&quot;&gt;브러시&lt;/a&gt; 발생 . 왼쪽 색상을 지정하지 않으면 오른쪽 색상과 동일하게 간주됩니다. 하단 색상을 지정하지 않으면 상단 색상과 동일하게 간주됩니다. 올바른 색상을 지정하지 않으면 상단 색상과 동일하게 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e08ef974a3e7bb738b48f0eeaf9b9216a6d5c063" translate="yes" xml:space="preserve">
          <source>One to four occurrences of &lt;a href=&quot;#length&quot;&gt;Length&lt;/a&gt;, specifying the top, right, bottom, and left edges of a box, respectively. If the left length is not specified, it is taken to be the same as the right length. If the bottom length is not specified, is it taken to be the same as the top length. If the right length is not specified, it is taken to be the same as the top length.</source>
          <target state="translated">상자의 위쪽, 오른쪽, 아래쪽 및 왼쪽 가장자리를 각각 지정하여 &lt;a href=&quot;#length&quot;&gt;길이가&lt;/a&gt; 1 ~ 4 회 발생 합니다. 왼쪽 길이를 지정하지 않으면 오른쪽 길이와 동일하게됩니다. 하단 길이를 지정하지 않으면 상단 길이와 동일하게 설정됩니다. 올바른 길이를 지정하지 않으면 상단 길이와 동일하게 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="bb13534be607b594e5d4fd2e50c8a12cd963a1b5" translate="yes" xml:space="preserve">
          <source>One way to define these preprocessor symbols globally for your application is to add the following entry to your &lt;a href=&quot;qmake-project-files&quot;&gt;qmake project file&lt;/a&gt;:</source>
          <target state="translated">응용 프로그램에 대해 이러한 전 처리기 기호를 전체적으로 정의하는 한 가지 방법은 &lt;a href=&quot;qmake-project-files&quot;&gt;qmake 프로젝트 파일에&lt;/a&gt; 다음 항목을 추가하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="223f7c148d75ac21a0035b635145d191f7358d4e" translate="yes" xml:space="preserve">
          <source>One way to do this is to add translation support to a non-Qt class using the &lt;a href=&quot;qcoreapplication#Q_DECLARE_TR_FUNCTIONS&quot;&gt;Q_DECLARE_TR_FUNCTIONS&lt;/a&gt;() macro; for example:</source>
          <target state="translated">이를 수행하는 한 가지 방법은 &lt;a href=&quot;qcoreapplication#Q_DECLARE_TR_FUNCTIONS&quot;&gt;Q_DECLARE_TR_FUNCTIONS&lt;/a&gt; () 매크로를 사용하여 비 Qt 클래스에 번역 지원을 추가하는 것입니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e8dad5716f44bbc2825b993d58097ca36e3e569" translate="yes" xml:space="preserve">
          <source>One way to initialize a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; is simply to pass a &lt;code&gt;const char *&lt;/code&gt; to its constructor. For example, the following code creates a byte array of size 5 containing the data &quot;Hello&quot;:</source>
          <target state="translated">&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 를 초기화하는 한 가지 방법 은 &lt;code&gt;const char *&lt;/code&gt; 를 생성자 에 전달하는 것 입니다. 예를 들어 다음 코드는 &quot;Hello&quot;데이터를 포함하는 크기 5의 바이트 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2ba2f1cc0f79034b36c2a103783eeb702b2a12a0" translate="yes" xml:space="preserve">
          <source>One way to initialize a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; is simply to pass a &lt;code&gt;const char *&lt;/code&gt; to its constructor. For example, the following code creates a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; of size 5 containing the data &quot;Hello&quot;:</source>
          <target state="translated">&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 을 초기화하는 한 가지 방법 은 &lt;code&gt;const char *&lt;/code&gt; 를 생성자 에 전달하는 것 입니다. 예를 들어 다음 코드 는 &quot;Hello&quot;데이터를 포함하는 크기 5 의 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="cb26e00428206c5a087e4bd954ff814ca5ff8b6c" translate="yes" xml:space="preserve">
          <source>One way to speed up the &lt;code&gt;FillContains&lt;/code&gt; check is to generate an approximate outline with as few points as possible, place that in a transparent Shape on top, and add your Pointer Handlers to that, so that the containment check is cheaper during event delivery.</source>
          <target state="translated">&lt;code&gt;FillContains&lt;/code&gt; 검사 속도를 높이는 한 가지 방법 은 가능한 한 적은 수의 점으로 대략적인 개요를 생성하고 투명한 모양 위에 배치하고 포인터 처리기를 추가하여 이벤트 전달 중에 봉쇄 검사가 더 저렴하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0f3ae55a89898820823b772b68d03c22e2bd821c" translate="yes" xml:space="preserve">
          <source>One-line text editor</source>
          <target state="translated">한 줄 텍스트 편집기</target>
        </trans-unit>
        <trans-unit id="e59fd204b822f9c79f6aef0a50f084bf2214e1f8" translate="yes" xml:space="preserve">
          <source>One-shot auto focus mode.</source>
          <target state="translated">원샷 자동 초점 모드.</target>
        </trans-unit>
        <trans-unit id="8eb5dfce967d8a943c9326524741741275b32898" translate="yes" xml:space="preserve">
          <source>Online Installation</source>
          <target state="translated">온라인 설치</target>
        </trans-unit>
        <trans-unit id="e8fd5f2a0f9df3ef30bb295e56ff9a4f6501e8fd" translate="yes" xml:space="preserve">
          <source>Online geocoding is supported.</source>
          <target state="translated">온라인 지오 코딩이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6e94f4a22f48e532df16fc87be0d43fcc763a463" translate="yes" xml:space="preserve">
          <source>Online mapping is supported.</source>
          <target state="translated">온라인 매핑이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="37985b6e22c37ff83b1855d037ac0df9c2c84bf9" translate="yes" xml:space="preserve">
          <source>Online navigation is supported.</source>
          <target state="translated">온라인 탐색이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="af889436cf506e074df27705b4cc0b25fff47cab" translate="yes" xml:space="preserve">
          <source>Online places is supported.</source>
          <target state="translated">온라인 장소가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9f7147cd02926e21fb68213a11cbb540adb516aa" translate="yes" xml:space="preserve">
          <source>Online routing is supported.</source>
          <target state="translated">온라인 라우팅이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4f153935e68f74bbea5e8fc6ce480ca9811c1d7d" translate="yes" xml:space="preserve">
          <source>Only &quot;http&quot;-&amp;gt;&quot;http&quot;, &quot;http&quot; -&amp;gt; &quot;https&quot; or &quot;https&quot; -&amp;gt; &quot;https&quot; redirects are allowed. Equivalent to setting the old &lt;a href=&quot;qnetworkrequest#Attribute-enum&quot;&gt;FollowRedirectsAttribute&lt;/a&gt; to true</source>
          <target state="translated">&quot;http&quot;-&amp;gt; &quot;http&quot;, &quot;http&quot;-&amp;gt; &quot;https&quot;또는 &quot;https&quot;-&amp;gt; &quot;https&quot;리디렉션 만 허용됩니다. 이전 &lt;a href=&quot;qnetworkrequest#Attribute-enum&quot;&gt;FollowRedirectsAttribute&lt;/a&gt; 를 true 로 설정하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="061c38f429d66e7bd7c7707bdeffdb4473422e38" translate="yes" xml:space="preserve">
          <source>Only &quot;plain data&quot; can be returned from JavaScript as the result value. Supported data types include all of the JSON data types as well as, for example, &lt;code&gt;Date&lt;/code&gt; and &lt;code&gt;ArrayBuffer&lt;/code&gt;. Unsupported data types include, for example, &lt;code&gt;Function&lt;/code&gt; and &lt;code&gt;Promise&lt;/code&gt;.</source>
          <target state="translated">JavaScript에서는 &quot;일반 데이터&quot;만 결과 값으로 반환 될 수 있습니다. 지원되는 데이터 유형에는 모든 JSON 데이터 유형뿐만 아니라 &lt;code&gt;Date&lt;/code&gt; 및 &lt;code&gt;ArrayBuffer&lt;/code&gt; 가 포함 됩니다. 지원되지 않는 데이터 유형은 예를 들어 &lt;code&gt;Function&lt;/code&gt; 및 &lt;code&gt;Promise&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d0cba37af2614a4e4f6ddf0c51d2fcd4cf170760" translate="yes" xml:space="preserve">
          <source>Only &lt;a href=&quot;#QtMsgType-enum&quot;&gt;QtWarningMsg&lt;/a&gt; and &lt;a href=&quot;#QtMsgType-enum&quot;&gt;QtFatalMsg&lt;/a&gt; are used. The former identifies a compile or runtime warning, while the latter identifies a dynamic or static error.</source>
          <target state="translated">만 &lt;a href=&quot;#QtMsgType-enum&quot;&gt;QtWarningMsg&lt;/a&gt; 및 &lt;a href=&quot;#QtMsgType-enum&quot;&gt;QtFatalMsg이&lt;/a&gt; 사용된다. 전자는 컴파일 또는 런타임 경고를 식별하고 후자는 동적 또는 정적 오류를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="5a7eec6f52e281f42b54e3d9ce6ff843282aa29e" translate="yes" xml:space="preserve">
          <source>Only &lt;a href=&quot;#QtMsgType-enum&quot;&gt;QtWarningMsg&lt;/a&gt; and &lt;a href=&quot;#QtMsgType-enum&quot;&gt;QtFatalMsg&lt;/a&gt; are used. The former identifies a warning, while the latter identifies an error.</source>
          <target state="translated">만 &lt;a href=&quot;#QtMsgType-enum&quot;&gt;QtWarningMsg&lt;/a&gt; 및 &lt;a href=&quot;#QtMsgType-enum&quot;&gt;QtFatalMsg이&lt;/a&gt; 사용된다. 전자는 경고를, 후자는 오류를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="00c0225557dcf5a66aeb0575fed3923085b73ec8" translate="yes" xml:space="preserve">
          <source>Only &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; uses &lt;a href=&quot;qabstractsocket&quot;&gt;QAbstractSocket&lt;/a&gt;'s internal buffer; &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt; does not use any buffering at all, but rather relies on the implicit buffering provided by the operating system. Because of this, calling this function on &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt; has no effect.</source>
          <target state="translated">전용 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket는&lt;/a&gt; 사용 &lt;a href=&quot;qabstractsocket&quot;&gt;QAbstractSocket&lt;/a&gt; 의 내부 버퍼; &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt; 은 전혀 버퍼링을 사용하지 않고 운영 체제가 제공하는 암시 적 버퍼링에 의존합니다. 이 때문에 &lt;a href=&quot;qudpsocket&quot;&gt;QUdpSocket&lt;/a&gt; 에서이 함수를 호출해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5102c1754518c4338955afd409dc169f702e8585" translate="yes" xml:space="preserve">
          <source>Only OpenGL ES 2</source>
          <target state="translated">OpenGL ES 2 만</target>
        </trans-unit>
        <trans-unit id="7243dc9588e7d32cd89d22c4fd52510a4994cbe2" translate="yes" xml:space="preserve">
          <source>Only Shape layer supported</source>
          <target state="translated">모양 레이어 만 지원</target>
        </trans-unit>
        <trans-unit id="997fa52e769e0a4d59c8365090166ca6b5927b69" translate="yes" xml:space="preserve">
          <source>Only Signals and Slots May Appear in the &lt;code&gt;signals&lt;/code&gt; and &lt;code&gt;slots&lt;/code&gt; Sections of a Class</source>
          <target state="translated">신호 및 슬롯 만 클래스 의 &lt;code&gt;signals&lt;/code&gt; 및 &lt;code&gt;slots&lt;/code&gt; 섹션에 나타날 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3319c794abcdb28819b733bc2a2b0abb219f6fcf" translate="yes" xml:space="preserve">
          <source>Only a given</source>
          <target state="translated">주어진 것만</target>
        </trans-unit>
        <trans-unit id="a06c7e81c93a88a08338ca6aec75092f1ff90cec" translate="yes" xml:space="preserve">
          <source>Only a partial</source>
          <target state="translated">일부만</target>
        </trans-unit>
        <trans-unit id="7f046cd2892da95841135a185cd4f4e6ea1db36d" translate="yes" xml:space="preserve">
          <source>Only a single instance of this characteristic exists as part of a HID Service.</source>
          <target state="translated">이 특성의 단일 인스턴스 만 HID 서비스의 일부로 존재합니다.</target>
        </trans-unit>
        <trans-unit id="01749c411894106bfeb3addcbe0e8ae80d152af4" translate="yes" xml:space="preserve">
          <source>Only a subset of the properties in &lt;a href=&quot;qtextcharformat&quot;&gt;QTextCharFormat&lt;/a&gt; are used by the calendar widget. Currently, the foreground, background and font properties are used to determine the rendering of individual cells in the widget.</source>
          <target state="translated">캘린더 위젯은 &lt;a href=&quot;qtextcharformat&quot;&gt;QTextCharFormat&lt;/a&gt; 의 속성 중 일부만 사용합니다. 현재 전경, 배경 및 글꼴 속성은 위젯에서 개별 셀의 렌더링을 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7966f02e32af2bc52e892f9d86b8be70ebe8ac04" translate="yes" xml:space="preserve">
          <source>Only active items can gain input focus.</source>
          <target state="translated">활성 항목 만 입력 초점을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bb8d0321ed54742c0b1fc91a7b2d143bab06e67" translate="yes" xml:space="preserve">
          <source>Only allow the hostUrl to be set to a QtRO supported schema. This is the default value, and causes a Node error to be set if an unrecognized schema is provided.</source>
          <target state="translated">hostUrl 만 QtRO 지원 스키마로 설정하십시오. 이것이 기본값이며 인식 할 수없는 스키마가 제공되면 노드 오류가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="34cf96d4b14226df0b6ec792d6c4e3c938d7f8d6" translate="yes" xml:space="preserve">
          <source>Only back-facing triangles will be picked.</source>
          <target state="translated">후면 삼각형 만 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="acebd9b91d2a9373d89a75b647d1a05167876851" translate="yes" xml:space="preserve">
          <source>Only characters suitable for URLs are allowed.</source>
          <target state="translated">URL에 적합한 문자 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a6559e1245f41618e379cc4cfccde656e9462111" translate="yes" xml:space="preserve">
          <source>Only characters suitable for email addresses are allowed.</source>
          <target state="translated">이메일 주소에 적합한 문자 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="16b980c1676a070c2f8ef9d269147dba31003618" translate="yes" xml:space="preserve">
          <source>Only characters suitable for phone dialing are allowed.</source>
          <target state="translated">전화 걸기에 적합한 문자 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e62882708034c57573cdd9e7f3b5f6cda8b08829" translate="yes" xml:space="preserve">
          <source>Only checkable actions can be checked. By default, this is false (the action is unchecked).</source>
          <target state="translated">점검 가능한 조치 만 점검 할 수 있습니다. 기본적으로 이것은 false입니다 (작업은 선택 해제되어 있음).</target>
        </trans-unit>
        <trans-unit id="d1df5af120516c42a3e9ca0be1b2c450f2973529" translate="yes" xml:space="preserve">
          <source>Only checkable buttons can be checked. By default, the button is unchecked.</source>
          <target state="translated">확인 가능한 버튼 만 확인할 수 있습니다. 기본적으로이 버튼은 선택되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9dc3b4af8780ed2b7244ae6ca4a682fbaa668e3" translate="yes" xml:space="preserve">
          <source>Only dialable input is allowed.</source>
          <target state="translated">다이얼 가능한 입력 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c8bebe53e929796679027326ec01f32cb9eca399" translate="yes" xml:space="preserve">
          <source>Only digits are allowed.</source>
          <target state="translated">숫자 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="344ffbc8b5ed91b54430eb6da6076aa5951e7cbc" translate="yes" xml:space="preserve">
          <source>Only display the icon.</source>
          <target state="translated">아이콘 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="4c3c090015e545870f3cb11a2c51d47e8b827f0a" translate="yes" xml:space="preserve">
          <source>Only display the text.</source>
          <target state="translated">텍스트 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="35eed40534af6dd7588605a96b90a6fea480866e" translate="yes" xml:space="preserve">
          <source>Only dither to indexed formats if the source image uses more different colors than the size of the color table of the destination format.</source>
          <target state="translated">소스 이미지가 대상 형식의 색상 표 크기와 다른 색상을 사용하는 경우에만 색인 형식으로 디더링하십시오.</target>
        </trans-unit>
        <trans-unit id="b3901def538061843c03f3797f5d3105889c2004" translate="yes" xml:space="preserve">
          <source>Only editable combo boxes have a line edit.</source>
          <target state="translated">편집 가능한 콤보 상자에만 줄 편집이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c2502f7d0a3edec7872a1fb7ab692c740e95d69" translate="yes" xml:space="preserve">
          <source>Only enabled items that set the &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt; flag can accept keyboard focus.</source>
          <target state="translated">&lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt; 플래그 를 설정 한 활성화 된 항목 만 키보드 포커스를 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c33f03b42aa5debac6e83482f764721b5e9a84b7" translate="yes" xml:space="preserve">
          <source>Only flat models (lists and tables) are supported, tree models are not.</source>
          <target state="translated">플랫 모델 (목록 및 테이블) 만 지원되며 트리 모델은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0886825525b27aef071d1d36dd9891332bc3c4d" translate="yes" xml:space="preserve">
          <source>Only for IPv6</source>
          <target state="translated">IPv6 전용</target>
        </trans-unit>
        <trans-unit id="0f7a6704e7a0ad432fcc65a63542d5bd64d35dd7" translate="yes" xml:space="preserve">
          <source>Only front-facing triangles will be picked (default).</source>
          <target state="translated">정면 삼각형 만 선택됩니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="1d349dcca0926ada1d5bba06ff5e98f26d653fbe" translate="yes" xml:space="preserve">
          <source>Only function names are returned.</source>
          <target state="translated">함수 이름 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5392b2ac53d6221666603d531f0410a99bf89ae2" translate="yes" xml:space="preserve">
          <source>Only integer frame-mode of a timeline supported (real frame numbers and time are rounded to the nearest integer)</source>
          <target state="translated">타임 라인의 정수 프레임 모드 만 지원됩니다 (실제 프레임 번호와 시간은 가장 가까운 정수로 반올림 됨)</target>
        </trans-unit>
        <trans-unit id="44948f37bb4db4bd9a2aed10375dc786efd3cadf" translate="yes" xml:space="preserve">
          <source>Only items that &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquickcontrols-chattutorial-example.html#stackview&quot;&gt;StackView&lt;/a&gt; created itself (from a &lt;a href=&quot;qml-qtqml-component&quot;&gt;Component&lt;/a&gt; or &lt;a href=&quot;qml-url&quot;&gt;url&lt;/a&gt;) will be destroyed when popped. See &lt;a href=&quot;qml-qtquick-controls2-stackview#item-ownership&quot;&gt;Item Ownership&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;qml-qtqml-component&quot;&gt;구성 요소&lt;/a&gt; 또는 &lt;a href=&quot;qml-url&quot;&gt;url&lt;/a&gt; 에서 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquickcontrols-chattutorial-example.html#stackview&quot;&gt;StackView&lt;/a&gt; 자체가 생성 한 항목 만 팝업되면 삭제됩니다. 자세한 내용은 &lt;a href=&quot;qml-qtquick-controls2-stackview#item-ownership&quot;&gt;항목 소유권&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9e37f535e5c62f28a9a6e9ecae26a61dad1f62b3" translate="yes" xml:space="preserve">
          <source>Only items that are children of the &lt;a href=&quot;qml-qtquick-layouts-stacklayout&quot;&gt;StackLayout&lt;/a&gt; will be candidates for layouting.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-layouts-stacklayout&quot;&gt;StackLayout의&lt;/a&gt; 하위 항목 만 레이아웃 후보가됩니다.</target>
        </trans-unit>
        <trans-unit id="c9dfd3fb5bd8ed2bd6a32f48ee311389249f3218" translate="yes" xml:space="preserve">
          <source>Only items that belong to this group are visible to a view.</source>
          <target state="translated">이 그룹에 속하는 항목 만보기에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c8168ea033dd3d3d177585811115776bae643be6" translate="yes" xml:space="preserve">
          <source>Only items that set the &lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt; flag, or widgets that set an appropriate focus policy, can accept keyboard focus.</source>
          <target state="translated">&lt;a href=&quot;qgraphicsitem#GraphicsItemFlag-enum&quot;&gt;ItemIsFocusable&lt;/a&gt; 플래그 를 설정하는 항목 또는 적절한 초점 정책을 설정하는 위젯 만 키보드 초점을 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbbfc9d955628abe0b8994e7bc9e7fedd9ddf0eb" translate="yes" xml:space="preserve">
          <source>Only items which specify &lt;a href=&quot;qquickitem#Flag-enum&quot;&gt;QQuickItem::ItemHasContents&lt;/a&gt; are allowed to call QQuickItem::update().</source>
          <target state="translated">&lt;a href=&quot;qquickitem#Flag-enum&quot;&gt;QQuickItem :: ItemHasContents&lt;/a&gt; 를 지정하는 항목 만 QQuickItem :: update ()를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="547bf1587da62d5bef95920f2782ef465d057ee4" translate="yes" xml:space="preserve">
          <source>Only latin based input is allowed.</source>
          <target state="translated">라틴 기반 입력 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a4047b356fb29b5d84e935cb033fa90fbb1fe809" translate="yes" xml:space="preserve">
          <source>Only list .qrc file entries, do not generate code.</source>
          <target state="translated">.qrc 파일 항목 만 나열하고 코드를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d5482ecc95a82b6bfe1ed407a6c99d94d7e0da1c" translate="yes" xml:space="preserve">
          <source>Only list files that have been modified (ignored on Unix).</source>
          <target state="translated">수정 된 파일 만 나열하십시오 (Unix에서 무시).</target>
        </trans-unit>
        <trans-unit id="4ceaf763a33bcb125b8cfb24f1e36ffac2200774" translate="yes" xml:space="preserve">
          <source>Only lower case letter input is allowed.</source>
          <target state="translated">소문자 입력 만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="9862f27489035178e0538dccef177ac6a28c837d" translate="yes" xml:space="preserve">
          <source>Only match to a standard page size if the sizes match exactly.</source>
          <target state="translated">크기가 정확히 일치하는 경우에만 표준 페이지 크기와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c0d71635cf00a59e98c2eda6c62ad5991c0deb65" translate="yes" xml:space="preserve">
          <source>Only network configurations of type &lt;a href=&quot;qnetworkconfiguration#Type-enum&quot;&gt;ServiceNetwork&lt;/a&gt; can have children. Otherwise this function returns an empty list.</source>
          <target state="translated">&lt;a href=&quot;qnetworkconfiguration#Type-enum&quot;&gt;ServiceNetwork&lt;/a&gt; 유형의 네트워크 구성 만 하위를 가질 수 있습니다. 그렇지 않으면이 함수는 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="81e7ce30d833f00e89b96b50ef1962325eacb9ba" translate="yes" xml:space="preserve">
          <source>Only nodes of type &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;ElementNode&lt;/a&gt; or &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;AttributeNode&lt;/a&gt; can have namespaces. A namespace URI must be specified at creation time and cannot be changed later.</source>
          <target state="translated">&lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;ElementNode&lt;/a&gt; 또는 &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;AttributeNode&lt;/a&gt; 유형의 노드 만 네임 스페이스를 가질 수 있습니다. 네임 스페이스 URI는 생성시 지정해야하며 나중에 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="08af18848d1be9d81cb5216c9a56e01e3ae655d6" translate="yes" xml:space="preserve">
          <source>Only nodes of type &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;ElementNode&lt;/a&gt; or &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;AttributeNode&lt;/a&gt; can have namespaces. A namespace must have been specified at creation time; it is not possible to add a namespace afterwards.</source>
          <target state="translated">&lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;ElementNode&lt;/a&gt; 또는 &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;AttributeNode&lt;/a&gt; 유형의 노드 만 네임 스페이스를 가질 수 있습니다. 작성시 네임 스페이스가 지정되어 있어야합니다. 나중에 네임 스페이스를 추가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a49b9e1f13cc73159d3efb2e4bd7e96e1b0d5c8f" translate="yes" xml:space="preserve">
          <source>Only nodes of type &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;ElementNode&lt;/a&gt; or &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;AttributeNode&lt;/a&gt; can have namespaces. A namespace prefix must be specified at creation time. If a node was created with a namespace prefix, you can change it later with &lt;a href=&quot;qdomnode#setPrefix&quot;&gt;setPrefix&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;ElementNode&lt;/a&gt; 또는 &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;AttributeNode&lt;/a&gt; 유형의 노드 만 네임 스페이스를 가질 수 있습니다. 작성시 네임 스페이스 접 두부를 지정해야합니다. 네임 스페이스 접두사를 사용하여 노드를 만든 경우 나중에 &lt;a href=&quot;qdomnode#setPrefix&quot;&gt;setPrefix&lt;/a&gt; ()를 사용 하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4229d3dfaba3b86156753fc6e1e4cf70a2dc792f" translate="yes" xml:space="preserve">
          <source>Only nodes of type &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;ElementNode&lt;/a&gt; or &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;AttributeNode&lt;/a&gt; can have namespaces. A namespace prefix must have be specified at creation time; it is not possible to add a namespace prefix afterwards.</source>
          <target state="translated">&lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;ElementNode&lt;/a&gt; 또는 &lt;a href=&quot;qdomnode#NodeType-enum&quot;&gt;AttributeNode&lt;/a&gt; 유형의 노드 만 네임 스페이스를 가질 수 있습니다. 네임 스페이스 접두사는 작성시 지정해야합니다. 나중에 네임 스페이스 접두사를 추가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="db7d2b4b74d3f19d24ab1738b1cd3550761be1cb" translate="yes" xml:space="preserve">
          <source>Only number input is allowed. This includes decimal point and minus sign.</source>
          <target state="translated">숫자 입력 만 허용됩니다. 여기에는 소수점과 빼기 부호가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bd3f064c7188629f6eedfba5abfa3b90080fc85c" translate="yes" xml:space="preserve">
          <source>Only numeric input is allowed.</source>
          <target state="translated">숫자 입력 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="9d9b5680177318989bd0ac87a5b746c5fe565830" translate="yes" xml:space="preserve">
          <source>Only on X11, when a tooltip is requested, the &lt;a href=&quot;qsystemtrayicon&quot;&gt;QSystemTrayIcon&lt;/a&gt; receives a &lt;a href=&quot;qhelpevent&quot;&gt;QHelpEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;. Additionally, the &lt;a href=&quot;qsystemtrayicon&quot;&gt;QSystemTrayIcon&lt;/a&gt; receives wheel events of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::Wheel&lt;/a&gt;. These are not supported on any other platform.</source>
          <target state="translated">툴팁이 요청되면 X11에서만 &lt;a href=&quot;qhelpevent&quot;&gt;QSystemTrayIcon&lt;/a&gt; 이 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: ToolTip&lt;/a&gt; 유형 의 &lt;a href=&quot;qsystemtrayicon&quot;&gt;QHelpEvent를&lt;/a&gt; 수신합니다 . 또한 &lt;a href=&quot;qsystemtrayicon&quot;&gt;QSystemTrayIcon&lt;/a&gt; 은 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: Wheel&lt;/a&gt; 유형의 휠 이벤트를 수신합니다 . 다른 플랫폼에서는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c966c2e5c8671dd2923be1ef96b426246e45e1b7" translate="yes" xml:space="preserve">
          <source>Only one &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; implementation may be instantiated and exported by an ActiveX server application. This instance is accessible through the global qAxFactory() function.</source>
          <target state="translated">ActiveX 서버 응용 프로그램에서 하나의 &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; 구현 만 인스턴스화하고 내보낼 수 있습니다. 이 인스턴스는 글로벌 qAxFactory () 함수를 통해 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e86f4ac4cc6b87c39c80af06e95ad366bf44a46" translate="yes" xml:space="preserve">
          <source>Only one &lt;a href=&quot;qwebengineprofile&quot;&gt;QWebEngineProfile&lt;/a&gt; can do this at a time, and it is recommended that the profile fullfilling this role has a disk HTTP cache to avoid needlessly re-downloading. If you set the option on a second profile, it will be disabled on the profile it is currently set.</source>
          <target state="translated">한 번에 하나의 &lt;a href=&quot;qwebengineprofile&quot;&gt;QWebEngineProfile&lt;/a&gt; 만이 작업을 수행 할 수 있으며,이 역할을 가득 채우는 프로파일에는 불필요하게 다시 다운로드하지 않도록 디스크 HTTP 캐시가있는 것이 좋습니다. 두 번째 프로필에서 옵션을 설정하면 현재 설정된 프로필에서 해당 옵션이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="e4c11af563f43ba6ea402c5a014c8f73ee682437" translate="yes" xml:space="preserve">
          <source>Only one Item can be a direct child of the &lt;a href=&quot;qml-qtquick-controls-scrollview&quot;&gt;ScrollView&lt;/a&gt; and the child is implicitly anchored to fill the scroll view.</source>
          <target state="translated">하나의 항목 만 &lt;a href=&quot;qml-qtquick-controls-scrollview&quot;&gt;ScrollView&lt;/a&gt; 의 직접적인 자식이 될 수 있으며 자식은 암시 적으로 스크롤 뷰를 채우도록 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="292e949684a8f6c4b156ae93709d421ea5f0395b" translate="yes" xml:space="preserve">
          <source>Only one active client per process is permitted. Subsequent clients attempting to connect to the server will see a loading indicator until the previous client disconnects.</source>
          <target state="translated">프로세스 당 하나의 활성 클라이언트 만 허용됩니다. 서버에 연결하려는 후속 클라이언트는 이전 클라이언트의 연결이 끊어 질 때까지로드 표시기를 보게됩니다.</target>
        </trans-unit>
        <trans-unit id="c14a4f82853654d11a23a22cc141c5f953167116" translate="yes" xml:space="preserve">
          <source>Only one bar can be selected at a time.</source>
          <target state="translated">한 번에 하나의 막대 만 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2248a190c0d660c4e6fafd48299f24aadeb660a0" translate="yes" xml:space="preserve">
          <source>Only one buddy widget can be defined for each label. To change the buddy used, it is necessary to delete any existing buddy connection before you create a new one.</source>
          <target state="translated">각 레이블마다 하나의 친구 위젯 만 정의 할 수 있습니다. 사용 된 대화 상대를 변경하려면 새 대화 상대 연결을 작성하기 전에 기존 대화 상대 연결을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="b837aab653c3f13381cebe1c32aa58e3fc22bcd1" translate="yes" xml:space="preserve">
          <source>Only one header section</source>
          <target state="translated">하나의 헤더 섹션</target>
        </trans-unit>
        <trans-unit id="c32ad496411f8470797a9d1405de91a586a1592b" translate="yes" xml:space="preserve">
          <source>Only one initial value will be saved for any given property. If a value for a property has already been saved by the state machine, it will not be overwritten until the property has been successfully restored.</source>
          <target state="translated">주어진 속성에 대해 하나의 초기 값 만 저장됩니다. 상태 머신이 속성 값을 이미 저장 한 경우 속성이 성공적으로 복원 될 때까지 해당 값을 덮어 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56c4fb4a1b813dbde0f9b03691f0bcb74858feb3" translate="yes" xml:space="preserve">
          <source>Only one message handler can be defined, since this is usually done on an application-wide basis to control debug output.</source>
          <target state="translated">일반적으로 디버그 출력을 제어하기 위해 애플리케이션 전체에서 수행되므로 하나의 메시지 핸들러 만 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc87ea28a98ab006d46ca69cd53da1af243ce5d9" translate="yes" xml:space="preserve">
          <source>Only one mutable iterator can be active on a given hash at any time. Furthermore, no changes should be done directly to the hash while the iterator is active (as opposed to through the iterator), since this could invalidate the iterator and lead to undefined behavior.</source>
          <target state="translated">주어진 해시에서 언제든지 하나의 변경 가능한 반복자 만 활성화 할 수 있습니다. 또한 이터레이터가 활성화되어있는 동안 (이터레이터와 반대로) 해시를 직접 변경하면 안됩니다. 이터레이터는 무효화되고 정의되지 않은 동작이 발생할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c469cc338e6d0b9e955d25b2d6ead3b2a9ef65c3" translate="yes" xml:space="preserve">
          <source>Only one mutable iterator can be active on a given list at any time. Furthermore, no changes should be done directly to the list while the iterator is active (as opposed to through the iterator), since this could invalidate the iterator and lead to undefined behavior.</source>
          <target state="translated">주어진 목록에서 언제든지 하나의 변경 가능한 반복자 만 활성화 할 수 있습니다. 또한 이터레이터가 활성화되어있는 동안 (이터레이터와 반대되는) 목록을 직접 변경하면 안됩니다. 이터레이터가 무효화되고 정의되지 않은 동작이 발생할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="15df6c3f42b2f7115677be583aa34c4498d388ca" translate="yes" xml:space="preserve">
          <source>Only one mutable iterator can be active on a given map at any time. Furthermore, no changes should be done directly to the map while the iterator is active (as opposed to through the iterator), since this could invalidate the iterator and lead to undefined behavior.</source>
          <target state="translated">주어진 맵에서 언제든지 하나의 변경 가능한 반복자 만 활성화 할 수 있습니다. 또한 이터레이터가 활성화되어있는 동안 (이터레이터가 아닌) 맵을 직접 변경해서는 안됩니다. 이터레이터가 무효화되고 정의되지 않은 동작이 발생할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="5c64dda345ccabc4c3041144fe96e1a95beb363a" translate="yes" xml:space="preserve">
          <source>Only one mutable iterator can be active on a given set at any time. Furthermore, no changes should be done directly to the set while the iterator is active (as opposed to through the iterator), since this could invalidate the iterator and lead to undefined behavior.</source>
          <target state="translated">주어진 세트에서 언제든지 하나의 변경 가능한 반복자 만 활성화 할 수 있습니다. 또한 이터레이터가 활성화되어있는 동안 (이터레이터와 반대로) 세트를 직접 변경하지 않아야합니다. 이터레이터는 무효화되고 정의되지 않은 동작이 발생할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1830ab079be5c68c7386e6ec0031ce349b862861" translate="yes" xml:space="preserve">
          <source>Only one mutable iterator can be active on a given vector at any time. Furthermore, no changes should be done directly to the vector while the iterator is active (as opposed to through the iterator), since this could invalidate the iterator and lead to undefined behavior.</source>
          <target state="translated">주어진 벡터에서 언제든지 하나의 변경 가능한 반복자 만 활성화 할 수 있습니다. 또한 이터레이터가 활성화되어있는 동안 (이터레이터를 통하는 것과 달리) 벡터를 직접 변경하지 않아야합니다. 이터레이터는 무효화되고 정의되지 않은 동작이 발생할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1687e81a43679ccb19fe9f14a9cb45accf06cbac" translate="yes" xml:space="preserve">
          <source>Only one point can be selected at a time.</source>
          <target state="translated">한 번에 하나의 지점 만 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="093f87644501fdcc4886a90098fbd311f8306624" translate="yes" xml:space="preserve">
          <source>Only one scroll gesture can be active on a single object at the same time. If you call this function twice on the same object, it will ungrab the existing gesture before grabbing the new one.</source>
          <target state="translated">단일 객체에서 동시에 하나의 스크롤 제스처 만 활성화 할 수 있습니다. 같은 객체에서이 함수를 두 번 호출하면 새 제스처를 잡기 전에 기존 제스처를 풀게됩니다.</target>
        </trans-unit>
        <trans-unit id="2e4550eba5d2cb877022457af0a20f908987a632" translate="yes" xml:space="preserve">
          <source>Only one translation unit in a library or executable can define a category with a specific name. The implicitly defined &lt;a href=&quot;qloggingcategory&quot;&gt;QLoggingCategory&lt;/a&gt; object is created on first use, in a thread-safe manner.</source>
          <target state="translated">라이브러리 또는 실행 파일에서 하나의 번역 단위 만 특정 이름으로 범주를 정의 할 수 있습니다. 암시 적으로 정의 된 &lt;a href=&quot;qloggingcategory&quot;&gt;QLoggingCategory&lt;/a&gt; 오브젝트는 처음 사용시 스레드 안전 방식으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="5874588876a240484d30519201ad794f4662dd84" translate="yes" xml:space="preserve">
          <source>Only one-to-one mappings between sections and widgets are allowed. It is not possible to map a single section to multiple widgets, or to map a single widget to multiple sections.</source>
          <target state="translated">섹션과 위젯 간의 일대일 매핑 만 허용됩니다. 단일 섹션을 여러 위젯에 맵핑하거나 단일 위젯을 여러 섹션에 맵핑 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f2a45607d8658353b26735883f2e38c61635354a" translate="yes" xml:space="preserve">
          <source>Only options set by &lt;a href=&quot;qsslconfiguration#setBackendConfigurationOption&quot;&gt;setBackendConfigurationOption&lt;/a&gt;() or &lt;a href=&quot;qsslconfiguration#setBackendConfiguration&quot;&gt;setBackendConfiguration&lt;/a&gt;() will be returned. The internal standard configuration of the backend is not reported.</source>
          <target state="translated">&lt;a href=&quot;qsslconfiguration#setBackendConfigurationOption&quot;&gt;setBackendConfigurationOption&lt;/a&gt; () 또는 &lt;a href=&quot;qsslconfiguration#setBackendConfiguration&quot;&gt;setBackendConfiguration&lt;/a&gt; ()에 의해 설정된 옵션 만 리턴됩니다. 백엔드의 내부 표준 구성은보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4a5c6b841d6408cc1b09eaf7068ca617d6bfa3d" translate="yes" xml:space="preserve">
          <source>Only other popup widgets may be opened when a popup widget is shown. The popup widgets are organized in a stack. This function returns the active popup widget at the top of the stack.</source>
          <target state="translated">팝업 위젯이 표시되면 다른 팝업 위젯 만 열 수 있습니다. 팝업 위젯은 스택으로 구성됩니다. 이 함수는 스택 상단에 활성 팝업 위젯을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a3213412928a79f8f1d6dbe0ff3a3e452532e3d4" translate="yes" xml:space="preserve">
          <source>Only place details that are supported by this manager is present in the modified version. Manager specific data such as the place id, is not copied over from the</source>
          <target state="translated">이 관리자가 지원하는 장소 세부 정보 만 수정 된 버전으로 제공됩니다. 장소 ID와 같은 관리자 별 데이터는</target>
        </trans-unit>
        <trans-unit id="022afb059dd2523132844dbb94dc64522c374309" translate="yes" xml:space="preserve">
          <source>Only places stored on the local device will be part of the search results.</source>
          <target state="translated">로컬 장치에 저장된 장소 만 검색 결과의 일부가됩니다.</target>
        </trans-unit>
        <trans-unit id="58dfa7ad56821797b65e4226af2c1b3e86ea2cd8" translate="yes" xml:space="preserve">
          <source>Only places that are private to the current user will be part of the search results.</source>
          <target state="translated">현재 사용자에게 비공개 인 장소 만 검색 결과에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ce754b83ce67299b26bccbd0672b437340fbf99e" translate="yes" xml:space="preserve">
          <source>Only places that are public will be part of the search results.</source>
          <target state="translated">공개 장소 만 검색 결과에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="01f3c132b1849d856881232b4ef1c60be7e512ab" translate="yes" xml:space="preserve">
          <source>Only primitive type accepted by tesselation shader where a patch consists of arbitrary number of vertices</source>
          <target state="translated">패치가 임의의 수의 정점으로 구성된 테셀레이션 셰이더에서 허용되는 기본 유형 만</target>
        </trans-unit>
        <trans-unit id="9dfd6bfa7305895a60f77674f4e18dabf7f170e7" translate="yes" xml:space="preserve">
          <source>Only queries encoded in UTF-8 are supported.</source>
          <target state="translated">UTF-8로 인코딩 된 쿼리 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f9255b8d5e908b1c057dedafa0e435395295dbc0" translate="yes" xml:space="preserve">
          <source>Only routes which contain the feature will be considered, otherwise no route will be returned</source>
          <target state="translated">지형지 물이 포함 된 경로 만 고려됩니다. 그렇지 않으면 경로가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7fdc0ad98caecb9009f0b11619aa918b2444b645" translate="yes" xml:space="preserve">
          <source>Only routes which contain the feature will be considered, otherwise no route will be returned.</source>
          <target state="translated">지형지 물이 포함 된 경로 만 고려되며, 그렇지 않으면 경로가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8d85783e1de0673e901d7a4dca553574f5039c6" translate="yes" xml:space="preserve">
          <source>Only routes which do not contain the feature will be considered, otherwise no route will be returned</source>
          <target state="translated">지형지 물이 포함되지 않은 경로 만 고려됩니다. 그렇지 않으면 경로가 반환되지 않습니다</target>
        </trans-unit>
        <trans-unit id="007e500e4d7218935cd1d79463df12a7be146591" translate="yes" xml:space="preserve">
          <source>Only routes which do not contain the feature will be considered, otherwise no route will be returned.</source>
          <target state="translated">지형지 물이 포함되지 않은 경로 만 고려되며, 그렇지 않으면 경로가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b99c13a867fa4d3cbc645acd24ad9522fb48037" translate="yes" xml:space="preserve">
          <source>Only show directories in the file dialog. By default both files and directories are shown. (Valid only in the &lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;Directory&lt;/a&gt; file mode.)</source>
          <target state="translated">파일 대화 상자에만 디렉토리를 표시하십시오. 기본적으로 파일과 디렉토리가 모두 표시됩니다. ( &lt;a href=&quot;qfiledialog#FileMode-enum&quot;&gt;디렉토리&lt;/a&gt; 파일 모드 에서만 유효 합니다.)</target>
        </trans-unit>
        <trans-unit id="900803d3a3fe28377b84720dbf28d5167a85641b" translate="yes" xml:space="preserve">
          <source>Only show directories in the folder dialog. By default both folders and directories are shown.</source>
          <target state="translated">폴더 대화 상자에만 디렉토리를 표시하십시오. 기본적으로 폴더와 디렉토리가 모두 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="88000814598313fb38d4e244e5dfccadf2621dbe" translate="yes" xml:space="preserve">
          <source>Only the acceleration caused by gravity is reported. Movements of the device caused by the user have no effect other than changing the direction when the device is rotated.</source>
          <target state="translated">중력으로 인한 가속 만보고됩니다. 사용자에 의한 장치의 움직임은 장치가 회전 할 때 방향을 변경하는 것 외에는 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b0b647478e89f4b60717d31245125ad915741989" translate="yes" xml:space="preserve">
          <source>Only the acceleration caused by the user moving the device is reported, the effect of gravity is canceled out. A device at rest therefore should report values of, or close to, zero. In other APIs, this mode might be known as</source>
          <target state="translated">사용자의 장치 이동으로 인한 가속 만보고되며 중력의 영향이 사라집니다. 그러므로 정지 상태의 장치는 0의 값 또는 0에 가까운 값을보고해야합니다. 다른 API에서이 모드는</target>
        </trans-unit>
        <trans-unit id="28c2b6d10db770a994e0a219eb84b16aee9277b9" translate="yes" xml:space="preserve">
          <source>Only the bounding volume was considered; the primitive and vertex indices will be undefined</source>
          <target state="translated">경계 볼륨 만 고려되었습니다. 프리미티브 및 버텍스 인덱스는 정의되지 않습니다</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
