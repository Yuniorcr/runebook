<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="6f562a1b0da2c16bb383eaca09b915bee506f32e" translate="yes" xml:space="preserve">
          <source>Wayland EGLStream Controller Protocol</source>
          <target state="translated">웨이 랜드 EGLStream 컨트롤러 프로토콜</target>
        </trans-unit>
        <trans-unit id="e3ab2649f88b3ce4ce82da915fb07b5cc4e36134" translate="yes" xml:space="preserve">
          <source>Wayland Fullscreen Shell Protocol, version unstable v1</source>
          <target state="translated">Wayland Fullscreen Shell Protocol, 버전 불안정 v1</target>
        </trans-unit>
        <trans-unit id="5b65922254e052b94ab43214e11811ef62e5dcc6" translate="yes" xml:space="preserve">
          <source>Wayland IVI Extension Protocol, version 1.9.1</source>
          <target state="translated">Wayland IVI 확장 프로토콜, 버전 1.9.1</target>
        </trans-unit>
        <trans-unit id="14c82fa3a3aa28c48b044c6fdc4233f225837ad3" translate="yes" xml:space="preserve">
          <source>Wayland Linux Dmabuf Unstable V1 Protocol</source>
          <target state="translated">Wayland Linux Dmabuf 불안정 V1 프로토콜</target>
        </trans-unit>
        <trans-unit id="92fa7323780b3f243cfb70e3426e80b4082cb3cd" translate="yes" xml:space="preserve">
          <source>Wayland Protocol, version 1.16.0</source>
          <target state="translated">웨이 랜드 프로토콜, 버전 1.16.0</target>
        </trans-unit>
        <trans-unit id="f596cc4063bd8a17256b0b91f16b40ac7e3359d8" translate="yes" xml:space="preserve">
          <source>Wayland Scaler Protocol, version 2</source>
          <target state="translated">웨이 랜드 스케일러 프로토콜, 버전 2</target>
        </trans-unit>
        <trans-unit id="ab1e2b913253c8b66950161f20618e7f4da33eee" translate="yes" xml:space="preserve">
          <source>Wayland Text Input Protocol</source>
          <target state="translated">웨이 랜드 텍스트 입력 프로토콜</target>
        </trans-unit>
        <trans-unit id="1f4d7c8f1395ffc68ba2df0ac952095bdde7ad14" translate="yes" xml:space="preserve">
          <source>Wayland Viewporter Protocol, version 1</source>
          <target state="translated">Wayland Viewporter Protocol, 버전 1</target>
        </trans-unit>
        <trans-unit id="5cb777633a797ea416c1cddcde9da2b65f6e0a82" translate="yes" xml:space="preserve">
          <source>Wayland XDG Output Protocol, version unstable v1, version 2</source>
          <target state="translated">Wayland XDG 출력 프로토콜, 버전 불안정 v1, 버전 2</target>
        </trans-unit>
        <trans-unit id="a55fb8b8ea5db99b1335f3bd24c958a444f6858b" translate="yes" xml:space="preserve">
          <source>Wayland XDG Shell Protocol, version 1.9.0</source>
          <target state="translated">Wayland XDG Shell Protocol, 버전 1.9.0</target>
        </trans-unit>
        <trans-unit id="2c2277577c212d8c8bd99a4dbce0e7202f070a74" translate="yes" xml:space="preserve">
          <source>Wayland and Qt</source>
          <target state="translated">웨이 랜드와 Qt</target>
        </trans-unit>
        <trans-unit id="1ef7f496f889f5b7b6ae31c90057f9e370025b9f" translate="yes" xml:space="preserve">
          <source>Wayland support</source>
          <target state="translated">웨이 랜드 지원</target>
        </trans-unit>
        <trans-unit id="a6136dd016ee98c8c3eea0e86ec06a1cd5d040e5" translate="yes" xml:space="preserve">
          <source>Wayland xdg-decoration Protocol, version unstable v1, version 1</source>
          <target state="translated">Wayland xdg-decoration Protocol, 버전 불안정 v1, 버전 1</target>
        </trans-unit>
        <trans-unit id="09964721be00170432119fb75b7d3e0e950e96df" translate="yes" xml:space="preserve">
          <source>Wayland's design philosophy is to keep the core protocol simple and minimal. Developers can then expand on this core protocol with use-case-specific extensions. Qt Wayland Compositor supports many common extensions by default, and also has APIs to enable the creation of new, custom extensions.</source>
          <target state="translated">Wayland의 디자인 철학은 핵심 프로토콜을 단순하고 최소화하는 것입니다. 그런 다음 개발자는 사용 사례 별 확장을 통해이 핵심 프로토콜을 확장 할 수 있습니다. Qt Wayland Compositor는 기본적으로 많은 공통 확장을 지원하며 새로운 사용자 정의 확장을 생성 할 수있는 API도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2181766b46bdb83d83d0541391f04262e20982f7" translate="yes" xml:space="preserve">
          <source>WaylandClient (QML type)</source>
          <target state="translated">WaylandClient (QML 유형)</target>
        </trans-unit>
        <trans-unit id="86eb74daf28d6d13e88b956700448aae01ea946d" translate="yes" xml:space="preserve">
          <source>WaylandClient QML Type</source>
          <target state="translated">WaylandClient QML 유형</target>
        </trans-unit>
        <trans-unit id="e13bce03d3f1a5362b09bd4d25ba3f541e6e5217" translate="yes" xml:space="preserve">
          <source>WaylandClient.close()</source>
          <target state="translated">WaylandClient.close()</target>
        </trans-unit>
        <trans-unit id="eedc418641c0a2170d91fe4f887e5e74a9e9c2e0" translate="yes" xml:space="preserve">
          <source>WaylandClient.compositor</source>
          <target state="translated">WaylandClient.compositor</target>
        </trans-unit>
        <trans-unit id="305abd3158d75caed3cef4586f31caf82350bc6b" translate="yes" xml:space="preserve">
          <source>WaylandClient.groupId</source>
          <target state="translated">WaylandClient.groupId</target>
        </trans-unit>
        <trans-unit id="56c2d57bb6e505d83b9bbf596d71268d15edcec7" translate="yes" xml:space="preserve">
          <source>WaylandClient.kill()</source>
          <target state="translated">WaylandClient.kill()</target>
        </trans-unit>
        <trans-unit id="089d80a84a3ac1c5345e565684700635a44bd81e" translate="yes" xml:space="preserve">
          <source>WaylandClient.processId</source>
          <target state="translated">WaylandClient.processId</target>
        </trans-unit>
        <trans-unit id="837d6c2b356c9a073f37bf64d353766945b2edf4" translate="yes" xml:space="preserve">
          <source>WaylandClient.userId</source>
          <target state="translated">WaylandClient.userId</target>
        </trans-unit>
        <trans-unit id="4c88365334a105aa24fcd86db9584bdc3a48f4a4" translate="yes" xml:space="preserve">
          <source>WaylandCompositor (QML type)</source>
          <target state="translated">WaylandCompositor (QML 유형)</target>
        </trans-unit>
        <trans-unit id="701c0d0b373af9d136b0aa520a922356461eb482" translate="yes" xml:space="preserve">
          <source>WaylandCompositor QML Type</source>
          <target state="translated">WaylandCompositor QML 유형</target>
        </trans-unit>
        <trans-unit id="5cd02658cebdaa3d9655ab2065d8608e0de3ed30" translate="yes" xml:space="preserve">
          <source>WaylandCompositor.addSocketDescriptor()</source>
          <target state="translated">WaylandCompositor.addSocketDescriptor()</target>
        </trans-unit>
        <trans-unit id="e2179ee55b21857817defac97658d82c6f7ee043" translate="yes" xml:space="preserve">
          <source>WaylandCompositor.created</source>
          <target state="translated">WaylandCompositor.created</target>
        </trans-unit>
        <trans-unit id="9d85849384b708ae724c352d92b8f1422d4e4a44" translate="yes" xml:space="preserve">
          <source>WaylandCompositor.defaultOutput</source>
          <target state="translated">WaylandCompositor.defaultOutput</target>
        </trans-unit>
        <trans-unit id="5242ee6a9acc6468c03350b5458778097e162b8e" translate="yes" xml:space="preserve">
          <source>WaylandCompositor.defaultSeat</source>
          <target state="translated">WaylandCompositor.defaultSeat</target>
        </trans-unit>
        <trans-unit id="753f872bd71d9928c5ff37e6ff7d766f8f56c404" translate="yes" xml:space="preserve">
          <source>WaylandCompositor.destroyClient()</source>
          <target state="translated">WaylandCompositor.destroyClient()</target>
        </trans-unit>
        <trans-unit id="f619866f52fd4bf7eb28a2bc87291ba4ca2577c5" translate="yes" xml:space="preserve">
          <source>WaylandCompositor.destroyClientForSurface()</source>
          <target state="translated">WaylandCompositor.destroyClientForSurface()</target>
        </trans-unit>
        <trans-unit id="8a8829df6434ca0fdad83cd292262d95ae17301e" translate="yes" xml:space="preserve">
          <source>WaylandCompositor.extensions</source>
          <target state="translated">WaylandCompositor.extensions</target>
        </trans-unit>
        <trans-unit id="0104f5bdd14e87f4cd4760e3bed47a51b3cd8f1f" translate="yes" xml:space="preserve">
          <source>WaylandCompositor.retainedSelection</source>
          <target state="translated">WaylandCompositor.retainedSelection</target>
        </trans-unit>
        <trans-unit id="5c02b095f69b0b83c2cf21cb167e8ef849d95a92" translate="yes" xml:space="preserve">
          <source>WaylandCompositor.socketName</source>
          <target state="translated">WaylandCompositor.socketName</target>
        </trans-unit>
        <trans-unit id="931a408368a43e35e48ce08ddec15d03aba056a4" translate="yes" xml:space="preserve">
          <source>WaylandCompositor.surfaceCreated()</source>
          <target state="translated">WaylandCompositor.surfaceCreated()</target>
        </trans-unit>
        <trans-unit id="686529b41f199bf9cfaa6a4ed7ab9881a0dc5103" translate="yes" xml:space="preserve">
          <source>WaylandCompositor.surfaceRequested()</source>
          <target state="translated">WaylandCompositor.surfaceRequested()</target>
        </trans-unit>
        <trans-unit id="c787146fd72a506383fe9bde6672a47d97595b19" translate="yes" xml:space="preserve">
          <source>WaylandCompositor.useHardwareIntegrationExtension</source>
          <target state="translated">WaylandCompositor.useHardwareIntegrationExtension</target>
        </trans-unit>
        <trans-unit id="830825ef4560b5b16fcc4cb145d58c0249028476" translate="yes" xml:space="preserve">
          <source>WaylandHardwareLayer (QML type)</source>
          <target state="translated">WaylandHardwareLayer (QML 유형)</target>
        </trans-unit>
        <trans-unit id="3485a0bc3bdf9b7c2cbe0f94097ba23732655307" translate="yes" xml:space="preserve">
          <source>WaylandHardwareLayer QML Type</source>
          <target state="translated">WaylandHardwareLayer QML 유형</target>
        </trans-unit>
        <trans-unit id="79ec3d48a0bbdd7684ef0b06f4e0dfe06975c1bc" translate="yes" xml:space="preserve">
          <source>WaylandHardwareLayer.stackingLevel</source>
          <target state="translated">WaylandHardwareLayer.stackingLevel</target>
        </trans-unit>
        <trans-unit id="947258416de4263bafedcdfdfef48b601c50bf65" translate="yes" xml:space="preserve">
          <source>WaylandOutput (QML type)</source>
          <target state="translated">WaylandOutput (QML 유형)</target>
        </trans-unit>
        <trans-unit id="230c2b9ecb66c3b17f949e41070de69bbe5dbd86" translate="yes" xml:space="preserve">
          <source>WaylandOutput QML Type</source>
          <target state="translated">WaylandOutput QML 유형</target>
        </trans-unit>
        <trans-unit id="ec37e8d61e1a34d4dd1133fa6d3741eeb0a584eb" translate="yes" xml:space="preserve">
          <source>WaylandOutput.automaticFrameCallback</source>
          <target state="translated">WaylandOutput.automaticFrameCallback</target>
        </trans-unit>
        <trans-unit id="3c424aedb084acd14dc45ae0c449c2a15f2b8a12" translate="yes" xml:space="preserve">
          <source>WaylandOutput.availableGeometry</source>
          <target state="translated">WaylandOutput.availableGeometry</target>
        </trans-unit>
        <trans-unit id="815d7372c5299d242ff097169632311ab08ca94f" translate="yes" xml:space="preserve">
          <source>WaylandOutput.compositor</source>
          <target state="translated">WaylandOutput.compositor</target>
        </trans-unit>
        <trans-unit id="005b3e8169955e939d7a3e59f0ffe542c1a13cb3" translate="yes" xml:space="preserve">
          <source>WaylandOutput.geometry</source>
          <target state="translated">WaylandOutput.geometry</target>
        </trans-unit>
        <trans-unit id="33744719babfe95e43f0b0963ec0642f306f179e" translate="yes" xml:space="preserve">
          <source>WaylandOutput.manufacturer</source>
          <target state="translated">WaylandOutput.manufacturer</target>
        </trans-unit>
        <trans-unit id="ccd649b333af0eeca4592384a8b868c5505fd933" translate="yes" xml:space="preserve">
          <source>WaylandOutput.model</source>
          <target state="translated">WaylandOutput.model</target>
        </trans-unit>
        <trans-unit id="04888ea741aaeb55f1bf6ff04181b29040d2f6eb" translate="yes" xml:space="preserve">
          <source>WaylandOutput.physicalSize</source>
          <target state="translated">WaylandOutput.physicalSize</target>
        </trans-unit>
        <trans-unit id="04a983e39cf7d6f6b133c90640a0774a3c927e8f" translate="yes" xml:space="preserve">
          <source>WaylandOutput.position</source>
          <target state="translated">WaylandOutput.position</target>
        </trans-unit>
        <trans-unit id="7a703eb83de08dab12dcfb46e5ebac843cc8cbe4" translate="yes" xml:space="preserve">
          <source>WaylandOutput.scaleFactor</source>
          <target state="translated">WaylandOutput.scaleFactor</target>
        </trans-unit>
        <trans-unit id="41e55f7a79f1ca5726f24a6d686e1845875b576c" translate="yes" xml:space="preserve">
          <source>WaylandOutput.sizeFollowsWindow</source>
          <target state="translated">WaylandOutput.sizeFollowsWindow</target>
        </trans-unit>
        <trans-unit id="685f3ab78449be3349b478198b5abf9539f66f68" translate="yes" xml:space="preserve">
          <source>WaylandOutput.subpixel</source>
          <target state="translated">WaylandOutput.subpixel</target>
        </trans-unit>
        <trans-unit id="057a722a05aa16697f2651ff7fc7e60c55afb632" translate="yes" xml:space="preserve">
          <source>WaylandOutput.transform</source>
          <target state="translated">WaylandOutput.transform</target>
        </trans-unit>
        <trans-unit id="4fb745f7399c7aeddf7c055fd4c99fc1a04ddc25" translate="yes" xml:space="preserve">
          <source>WaylandOutput.window</source>
          <target state="translated">WaylandOutput.window</target>
        </trans-unit>
        <trans-unit id="e8028fdedde35a8cf72996b1c86aa8266d827d99" translate="yes" xml:space="preserve">
          <source>WaylandQuickItem</source>
          <target state="translated">WaylandQuickItem</target>
        </trans-unit>
        <trans-unit id="627f03d675deceab98d7a9d6f299af11e1e27687" translate="yes" xml:space="preserve">
          <source>WaylandQuickItem (QML type)</source>
          <target state="translated">WaylandQuickItem (QML 유형)</target>
        </trans-unit>
        <trans-unit id="6fc002f74477d7bab991bbada2bc0c7a9c003183" translate="yes" xml:space="preserve">
          <source>WaylandQuickItem QML Type</source>
          <target state="translated">WaylandQuickItem QML 유형</target>
        </trans-unit>
        <trans-unit id="bc619699209c22e88ec6042ee42169c4607f2af8" translate="yes" xml:space="preserve">
          <source>WaylandQuickItem.bufferLocked</source>
          <target state="translated">WaylandQuickItem.bufferLocked</target>
        </trans-unit>
        <trans-unit id="178f76ae33a2a50e877a984b52809dc3c2ce81c8" translate="yes" xml:space="preserve">
          <source>WaylandQuickItem.compositor</source>
          <target state="translated">WaylandQuickItem.compositor</target>
        </trans-unit>
        <trans-unit id="cf103541a782790c31bdf70a88862cf9f10a3bf2" translate="yes" xml:space="preserve">
          <source>WaylandQuickItem.focusOnClick</source>
          <target state="translated">WaylandQuickItem.focusOnClick</target>
        </trans-unit>
        <trans-unit id="d6e45b5ea90b092234887ec47cca2aafc7bb86d7" translate="yes" xml:space="preserve">
          <source>WaylandQuickItem.mapFromSurface()</source>
          <target state="translated">WaylandQuickItem.mapFromSurface()</target>
        </trans-unit>
        <trans-unit id="d62b149485a9a6ab5ad0f5aa0b9f8ef4ae7b68e0" translate="yes" xml:space="preserve">
          <source>WaylandQuickItem.mapToSurface()</source>
          <target state="translated">WaylandQuickItem.mapToSurface()</target>
        </trans-unit>
        <trans-unit id="c5f53e219a2f7af655fc6296a61cc83946a07949" translate="yes" xml:space="preserve">
          <source>WaylandQuickItem.origin</source>
          <target state="translated">WaylandQuickItem.origin</target>
        </trans-unit>
        <trans-unit id="4586123b1255dd4d091ef81d0120a4e5017f83be" translate="yes" xml:space="preserve">
          <source>WaylandQuickItem.paintEnabled</source>
          <target state="translated">WaylandQuickItem.paintEnabled</target>
        </trans-unit>
        <trans-unit id="1e8e19ed0ef443734e56722a8c4899a4419e89db" translate="yes" xml:space="preserve">
          <source>WaylandQuickItem.setPrimary()</source>
          <target state="translated">WaylandQuickItem.setPrimary()</target>
        </trans-unit>
        <trans-unit id="55ce993b2a71304575ef8245b4feec3ab8215e88" translate="yes" xml:space="preserve">
          <source>WaylandQuickItem.sizeFollowsSurface</source>
          <target state="translated">WaylandQuickItem.sizeFollowsSurface</target>
        </trans-unit>
        <trans-unit id="f2089a98f1dfa127745f263e0b496ec0a248a1d0" translate="yes" xml:space="preserve">
          <source>WaylandQuickItem.subsurfaceHandler</source>
          <target state="translated">WaylandQuickItem.subsurfaceHandler</target>
        </trans-unit>
        <trans-unit id="dd524801d83c4dc517f818c5bde8fdc96d9093a5" translate="yes" xml:space="preserve">
          <source>WaylandQuickItem.surface</source>
          <target state="translated">WaylandQuickItem.surface</target>
        </trans-unit>
        <trans-unit id="f8568faf691dde6c888bc5d7b343a0514f34368e" translate="yes" xml:space="preserve">
          <source>WaylandQuickItem.surfaceDestroyed()</source>
          <target state="translated">WaylandQuickItem.surfaceDestroyed()</target>
        </trans-unit>
        <trans-unit id="7815d87e9d4f39cd925bddca71c6a36a59d9eef8" translate="yes" xml:space="preserve">
          <source>WaylandSeat (QML type)</source>
          <target state="translated">WaylandSeat (QML 유형)</target>
        </trans-unit>
        <trans-unit id="d26b1f63d5390001ee707b00132066d693cb5926" translate="yes" xml:space="preserve">
          <source>WaylandSeat QML Type</source>
          <target state="translated">WaylandSeat QML 유형</target>
        </trans-unit>
        <trans-unit id="af28fb720343c01722e73765b8809724194e8c64" translate="yes" xml:space="preserve">
          <source>WaylandSeat.sendKeyEvent()</source>
          <target state="translated">WaylandSeat.sendKeyEvent()</target>
        </trans-unit>
        <trans-unit id="27e30cc88a85cb531a3df0b4c5097cf5cc731e08" translate="yes" xml:space="preserve">
          <source>WaylandSeat.sendTouchCancelEvent()</source>
          <target state="translated">WaylandSeat.sendTouchCancelEvent()</target>
        </trans-unit>
        <trans-unit id="56d06201ea9df866707d462ef399a59c95224692" translate="yes" xml:space="preserve">
          <source>WaylandSeat.sendTouchFrameEvent()</source>
          <target state="translated">WaylandSeat.sendTouchFrameEvent()</target>
        </trans-unit>
        <trans-unit id="341b1b1bb5cde1d24e0248358f9423c3272cc7c6" translate="yes" xml:space="preserve">
          <source>WaylandSeat.sendTouchPointMoved()</source>
          <target state="translated">WaylandSeat.sendTouchPointMoved()</target>
        </trans-unit>
        <trans-unit id="62c4255a175627a999ee8ad63e9df893274e059a" translate="yes" xml:space="preserve">
          <source>WaylandSeat.sendTouchPointPressed()</source>
          <target state="translated">WaylandSeat.sendTouchPointPressed()</target>
        </trans-unit>
        <trans-unit id="776ca85d1ddaf71852f451600b9edcd6a2556f90" translate="yes" xml:space="preserve">
          <source>WaylandSeat.sendTouchPointReleased()</source>
          <target state="translated">WaylandSeat.sendTouchPointReleased()</target>
        </trans-unit>
        <trans-unit id="27e1dc78b1488cef395dcbc82be2930e5db83846" translate="yes" xml:space="preserve">
          <source>WaylandSurface (QML type)</source>
          <target state="translated">WaylandSurface (QML 유형)</target>
        </trans-unit>
        <trans-unit id="d5b584359d49c2e0a2935e5579b8067349fc1397" translate="yes" xml:space="preserve">
          <source>WaylandSurface QML Type</source>
          <target state="translated">WaylandSurface QML 유형</target>
        </trans-unit>
        <trans-unit id="f9b7e04e9558af4d047c438db8b1f2c79d2f7ac7" translate="yes" xml:space="preserve">
          <source>WaylandSurface.bufferScale</source>
          <target state="translated">WaylandSurface.bufferScale</target>
        </trans-unit>
        <trans-unit id="5b102c1810373471dcfe3ea979caece0c529f7e3" translate="yes" xml:space="preserve">
          <source>WaylandSurface.bufferSize</source>
          <target state="translated">WaylandSurface.bufferSize</target>
        </trans-unit>
        <trans-unit id="eb886ad49b75767813061ba5ae87ce016fa48469" translate="yes" xml:space="preserve">
          <source>WaylandSurface.childAdded()</source>
          <target state="translated">WaylandSurface.childAdded()</target>
        </trans-unit>
        <trans-unit id="eec1d33e2d474b36b7006cc88f86c8c193e63b9d" translate="yes" xml:space="preserve">
          <source>WaylandSurface.client</source>
          <target state="translated">WaylandSurface.client</target>
        </trans-unit>
        <trans-unit id="8e9ba3221ed7bc360dfc0ae809a197e86fb5d1fb" translate="yes" xml:space="preserve">
          <source>WaylandSurface.contentOrientation</source>
          <target state="translated">WaylandSurface.contentOrientation</target>
        </trans-unit>
        <trans-unit id="7550952c0b033642144ae52c6fcdab547223539d" translate="yes" xml:space="preserve">
          <source>WaylandSurface.cursorSurface</source>
          <target state="translated">WaylandSurface.cursorSurface</target>
        </trans-unit>
        <trans-unit id="dd055057603a0152e0c2ece177b50e5831345596" translate="yes" xml:space="preserve">
          <source>WaylandSurface.destinationSize</source>
          <target state="translated">WaylandSurface.destinationSize</target>
        </trans-unit>
        <trans-unit id="6ae54f88bd67adcbb57bd335e5f5b9e8899abbdb" translate="yes" xml:space="preserve">
          <source>WaylandSurface.destroy()</source>
          <target state="translated">WaylandSurface.destroy()</target>
        </trans-unit>
        <trans-unit id="25421d224b57a1a767f68732177f20310f37f67b" translate="yes" xml:space="preserve">
          <source>WaylandSurface.dragStarted()</source>
          <target state="translated">WaylandSurface.dragStarted()</target>
        </trans-unit>
        <trans-unit id="e2a3cadb6c6fdc7550f301a26187c9e276062e84" translate="yes" xml:space="preserve">
          <source>WaylandSurface.hasContent</source>
          <target state="translated">WaylandSurface.hasContent</target>
        </trans-unit>
        <trans-unit id="a7e2fd33cb5536cb8a0423d502a6de99a531409f" translate="yes" xml:space="preserve">
          <source>WaylandSurface.initialize()</source>
          <target state="translated">WaylandSurface.initialize()</target>
        </trans-unit>
        <trans-unit id="6a8e5fbe953993844436a4972bbecabef797a925" translate="yes" xml:space="preserve">
          <source>WaylandSurface.isDestroyed()</source>
          <target state="translated">WaylandSurface.isDestroyed()</target>
        </trans-unit>
        <trans-unit id="4f58e4e281b66dbea852b76411645639add37186" translate="yes" xml:space="preserve">
          <source>WaylandSurface.origin</source>
          <target state="translated">WaylandSurface.origin</target>
        </trans-unit>
        <trans-unit id="ea4cd366ad7ffe909d0cb0166c671a41b19ade11" translate="yes" xml:space="preserve">
          <source>WaylandSurface.sourceGeometry</source>
          <target state="translated">WaylandSurface.sourceGeometry</target>
        </trans-unit>
        <trans-unit id="b4d33926da532ec66fea6c48a782dd09c62a9f23" translate="yes" xml:space="preserve">
          <source>WaylandSurface.surfaceDestroyed()</source>
          <target state="translated">WaylandSurface.surfaceDestroyed()</target>
        </trans-unit>
        <trans-unit id="68944967f2bf332055b63eb99243a185ff3d118e" translate="yes" xml:space="preserve">
          <source>WaylandSurface.useTextureAlpha</source>
          <target state="translated">WaylandSurface.useTextureAlpha</target>
        </trans-unit>
        <trans-unit id="6da642f02bb09adfeae4bf0ca6b416dc211d85bd" translate="yes" xml:space="preserve">
          <source>WaylandView (QML type)</source>
          <target state="translated">WaylandView (QML 유형)</target>
        </trans-unit>
        <trans-unit id="091b14cfe3054245495d6077aeaae67cad9218a9" translate="yes" xml:space="preserve">
          <source>WaylandView QML Type</source>
          <target state="translated">WaylandView QML 유형</target>
        </trans-unit>
        <trans-unit id="c27de23a2d398d02c25b3eabbfc6e3a8127b3eda" translate="yes" xml:space="preserve">
          <source>WaylandView.allowDiscardFrontBuffer</source>
          <target state="translated">WaylandView.allowDiscardFrontBuffer</target>
        </trans-unit>
        <trans-unit id="ec0db058505b95467ed6a5a4f433a2a38d42eced" translate="yes" xml:space="preserve">
          <source>WaylandView.bufferLocked</source>
          <target state="translated">WaylandView.bufferLocked</target>
        </trans-unit>
        <trans-unit id="74055b41e17eabfa61b39bc77645596bdf54ff2a" translate="yes" xml:space="preserve">
          <source>WaylandView.output</source>
          <target state="translated">WaylandView.output</target>
        </trans-unit>
        <trans-unit id="0eb0b30eb9f90206b2db55b7c6b5b9ce2000ffd1" translate="yes" xml:space="preserve">
          <source>WaylandView.surface</source>
          <target state="translated">WaylandView.surface</target>
        </trans-unit>
        <trans-unit id="71648dd8c0e0ab094578f2e030db26c525c7ba67" translate="yes" xml:space="preserve">
          <source>Waypoint</source>
          <target state="translated">Waypoint</target>
        </trans-unit>
        <trans-unit id="b71407c273f51eb9a8a7ec75703eae02afa10155" translate="yes" xml:space="preserve">
          <source>Waypoint (QML type)</source>
          <target state="translated">웨이 포인트 (QML 유형)</target>
        </trans-unit>
        <trans-unit id="c0a8c25d2a968fa57871442e0f517118a1f08790" translate="yes" xml:space="preserve">
          <source>Waypoint QML Type</source>
          <target state="translated">웨이 포인트 QML 유형</target>
        </trans-unit>
        <trans-unit id="2883762d2122129db5f39643cd3a0a0b7cc8c672" translate="yes" xml:space="preserve">
          <source>Waypoint.altitude</source>
          <target state="translated">Waypoint.altitude</target>
        </trans-unit>
        <trans-unit id="d4b68f5bfa4e54d3c9e83cea7b3f8c0d2cc7664e" translate="yes" xml:space="preserve">
          <source>Waypoint.bearing</source>
          <target state="translated">Waypoint.bearing</target>
        </trans-unit>
        <trans-unit id="d9fba561d711139e47ce3d326b667f9c8e0361a2" translate="yes" xml:space="preserve">
          <source>Waypoint.coordinate</source>
          <target state="translated">Waypoint.coordinate</target>
        </trans-unit>
        <trans-unit id="4157b661a2c1f7fddb21ed856fa3ecc78406f3ea" translate="yes" xml:space="preserve">
          <source>Waypoint.latitude</source>
          <target state="translated">Waypoint.latitude</target>
        </trans-unit>
        <trans-unit id="b84dee8fedf346e5b79c2f35e47717e111cc8c31" translate="yes" xml:space="preserve">
          <source>Waypoint.longitude</source>
          <target state="translated">Waypoint.longitude</target>
        </trans-unit>
        <trans-unit id="3212e52ebd5dd66c5e927459ab1ca2b24d7ae9bf" translate="yes" xml:space="preserve">
          <source>Waypoint.metadata</source>
          <target state="translated">Waypoint.metadata</target>
        </trans-unit>
        <trans-unit id="3013814b5b292ee2f5e6d99e80d2c9ff0f64e885" translate="yes" xml:space="preserve">
          <source>Waypoints can be set as part of the &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery&lt;/a&gt; type declaration or dynamically with the functions provided.</source>
          <target state="translated">웨이 포인트는 &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery&lt;/a&gt; 유형 선언의 일부로 또는 제공된 함수를 사용하여 동적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de02a752b93af9ad9f02da12065a86871c557ad9" translate="yes" xml:space="preserve">
          <source>We account for every possible orientation and tickmark alignment, something that is not necessary if the gauge will only ever have one orientation and alignment. For example, if the gauge will always be of a vertical orientation and the tickmarks left-aligned, then it is enough to set the &lt;code&gt;x&lt;/code&gt; property of the &lt;code&gt;Rectangle&lt;/code&gt; to the following:</source>
          <target state="translated">우리는 가능한 모든 방향과 눈금 표시 정렬을 설명합니다. 게이지가 하나의 방향과 정렬 만 갖는 경우에는 필요하지 않습니다. 예를 들어 게이지가 항상 세로 방향이고 눈금이 왼쪽 정렬 된 경우 &lt;code&gt;Rectangle&lt;/code&gt; 의 &lt;code&gt;x&lt;/code&gt; 속성을 다음과 같이 설정하면 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="6afa1836d77cc695aad50ffeeec2e61dcaeef748" translate="yes" xml:space="preserve">
          <source>We add some text to the document immediately after we insert the frame. Since the text cursor is positioned</source>
          <target state="translated">프레임을 삽입 한 직후에 문서에 텍스트를 추가합니다. 텍스트 커서가 위치하기 때문에</target>
        </trans-unit>
        <trans-unit id="37d7cc54982e719560b2c9451179148ca134d40b" translate="yes" xml:space="preserve">
          <source>We add support for image MIME types by returning true. For all other MIME types, we use the default implementation.</source>
          <target state="translated">true를 반환하여 이미지 MIME 유형에 대한 지원을 추가합니다. 다른 모든 MIME 유형에는 기본 구현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="367c577300148e44bf49897d1eea3495b9e7ad95" translate="yes" xml:space="preserve">
          <source>We advise supporting click-to-focus for widgets that support text entry, and to avoid it for most widgets where a mouse click has a different effect. (For buttons, we also recommend adding a keyboard shortcut: &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; and its subclasses make this very easy.)</source>
          <target state="translated">텍스트 입력을 지원하는 위젯의 경우 클릭 투 포커스를 지원하고 마우스 클릭이 다른 효과를 나타내는 대부분의 위젯에서는이를 피하는 것이 좋습니다. 버튼의 경우 바로 가기 키를 추가하는 것이 좋습니다. &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; 및 해당 하위 클래스를 사용하면이 작업을 매우 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="330705dc48929d5ca58f796b80302e5061695e54" translate="yes" xml:space="preserve">
          <source>We advise supporting shortcut focus for all widgets that the user may want to jump to. For example, a tab dialog can have keyboard shortcuts for each of its pages, so the user can press e.g. &lt;b&gt;Alt+P&lt;/b&gt; to step to the &lt;u&gt;P&lt;/u&gt;rinting page. It is easy to overdo this: there are only a few keys, and it's also important to provide keyboard shortcuts for commands. &lt;b&gt;Alt+P&lt;/b&gt; is also used for Paste, Play, Print, and Print Here in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/accelerators.html&quot;&gt;Standard Accelerator Keys&lt;/a&gt; list, for example.</source>
          <target state="translated">사용자가 이동하려는 모든 위젯에 대한 바로 가기 포커스를 지원하는 것이 좋습니다. 사용자가 예를 누를 수 있도록 예를 들어, 탭 대화는 그것의 각 페이지에 대한 키보드 단축키를 가질 수 &lt;b&gt;Alt + P를&lt;/b&gt; 받는 단계로 &lt;u&gt;P&lt;/u&gt; 프 린 팅 페이지입니다. 이 작업을 쉽게 수행 할 수 있습니다. 몇 개의 키만 있으며 명령에 대한 바로 가기 키를 제공하는 것도 중요합니다. &lt;b&gt;Alt + P&lt;/b&gt; 는 예를 들어 &lt;a href=&quot;https://doc.qt.io/qt-5.13/accelerators.html&quot;&gt;표준 액셀러레이터 키&lt;/a&gt; 목록 에서 붙여 넣기, 재생, 인쇄 및 여기에 인쇄에도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="89bbf1b6be9aaaa009363ebc75b1ce6bd1fb6693" translate="yes" xml:space="preserve">
          <source>We also change the color of the rest of the labels to the same white that we used for the needle and knob.</source>
          <target state="translated">또한 나머지 레이블의 색상을 바늘과 손잡이에 사용한 것과 동일한 흰색으로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="1f9eb23eeb14ee5385c305e3c948ca86090954cd" translate="yes" xml:space="preserve">
          <source>We also give an image of the widget with the sub controls and sub control rectangles drawn:</source>
          <target state="translated">하위 컨트롤과 하위 컨트롤 사각형이 그려진 위젯 이미지도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5a3566728b67d37ddb4ea60257c01caef19ef58f" translate="yes" xml:space="preserve">
          <source>We also have an image of a tool button where we have outlined the sub element bounding rectangles and sub controls.</source>
          <target state="translated">또한 하위 요소 경계 사각형 및 하위 컨트롤을 설명한 도구 단추 이미지도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2081028fcd74b65596c17a4bc7871948ce46c9af" translate="yes" xml:space="preserve">
          <source>We also show a picture of a slider in the Java style. We show the bounding rectangles of the sub elements, as all drawing is done in &lt;code&gt;CC_Slider&lt;/code&gt;.</source>
          <target state="translated">또한 Java 스타일의 슬라이더 그림을 보여줍니다. 모든 그리기가 &lt;code&gt;CC_Slider&lt;/code&gt; 에서 수행되므로 하위 요소의 경계 사각형을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="236e7cf2778b7b8286cff66e57d8c6de489bb996" translate="yes" xml:space="preserve">
          <source>We assume that you have cloned the Qt 5 repositories (or obtained the Qt sources elsewhere) and followed the platform-independent requirements for building Qt. The process of building Qt is found in the &lt;a href=&quot;build-sources#&quot;&gt;Building Qt Sources&lt;/a&gt; page.</source>
          <target state="translated">Qt 5 리포지토리를 복제했거나 다른 곳에서 Qt 소스를 얻었으며 Qt 구축을위한 플랫폼 독립적 요구 사항을 따른다고 가정합니다. Qt 빌드 프로세스는 &lt;a href=&quot;build-sources#&quot;&gt;Qt 소스 빌드&lt;/a&gt; 페이지 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42678ce95d618417374ca155bee3a1d03d1384ab" translate="yes" xml:space="preserve">
          <source>We build the string &lt;code&gt;out&lt;/code&gt; dynamically by appending one character to it at a time. Let's assume that we append 15000 characters to the &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; string. Then the following 18 reallocations (out of a possible 15000) occur when &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; runs out of space: 4, 8, 12, 16, 20, 52, 116, 244, 500, 1012, 2036, 4084, 6132, 8180, 10228, 12276, 14324, 16372. At the end, the &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; has 16372 Unicode characters allocated, 15000 of which are occupied.</source>
          <target state="translated">한 번에 하나의 문자를 추가 하여 문자열 &lt;code&gt;out&lt;/code&gt; 동적으로 작성합니다. &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 문자열에 15000자를 추가한다고 가정 해 봅시다 . 그런 다음 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 의 공간이 부족 하면 다음 1 개의 18 재 할당 (15000 중)이 발생 합니다. 4, 8, 12, 16, 20, 52, 116, 244, 500, 1012, 2036, 4084, 6132, 8180, 10228, 결국 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 에는 16372 개의 유니 코드 문자가 할당되며 그 중 15000 개가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="de3febcea78ebf47ea06553fdaa4cfbc79a4921d" translate="yes" xml:space="preserve">
          <source>We can achieve the same behavior (namely that clicking the Quit button quits the state machine, regardless of which state the state machine is in) by grouping states &lt;code&gt;s1&lt;/code&gt;, &lt;code&gt;s2&lt;/code&gt; and &lt;code&gt;s3&lt;/code&gt;. This is done by creating a new top-level state and making the three original states children of the new state. The following diagram shows the new state machine.</source>
          <target state="translated">상태 &lt;code&gt;s1&lt;/code&gt; , &lt;code&gt;s2&lt;/code&gt; 및 &lt;code&gt;s3&lt;/code&gt; 을 그룹화하여 동일한 동작을 수행 할 수 있습니다 (즉, 종료 단추를 클릭하면 상태 머신의 상태에 관계없이 상태 머신이 종료 됨) . 이것은 새로운 최상위 상태를 만들고 새로운 상태의 세 가지 원래 상태를 자식으로 만들어서 수행됩니다. 다음 다이어그램은 새로운 상태 머신을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="976a478402f8e05d9285f7ae03ebdc0b65d105e9" translate="yes" xml:space="preserve">
          <source>We can also change the Qt properties, e.g. set the &quot;text&quot; property of the &lt;code&gt;resetButton&lt;/code&gt; to &quot;Reset&quot;, and the &quot;lineWidth&quot; property of the &lt;code&gt;circleWidget&lt;/code&gt; to 5. We can also put those objects into the layout system that Visual Studio's dialog editor provides, e.g. by setting the anchors of the &lt;code&gt;circleWidget&lt;/code&gt; to &quot;Left, Top, Right, Bottom&quot;, and the anchors of the &lt;code&gt;resetButton&lt;/code&gt; to &quot;Bottom, Right&quot;.</source>
          <target state="translated">우리는 또한 예를 들어, Qt의 속성을 변경의 &quot;텍스트&quot;속성을 설정할 수 있습니다 &lt;code&gt;resetButton&lt;/code&gt; &quot;재설정&quot;을을, 그리고의 &quot;선폭&quot;속성 &lt;code&gt;circleWidget&lt;/code&gt; 5에 우리는 또한 레이아웃 시스템으로 그 물건을 올려 수있는 비주얼 스튜디오의 대화 상자 편집기 예를 들어 &lt;code&gt;circleWidget&lt;/code&gt; 의 앵커 를 &quot;Left, Top, Right, Bottom&quot;으로 설정하고 &lt;code&gt;resetButton&lt;/code&gt; 의 앵커 를 &quot;Bottom, Right&quot;로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c9dc4fce2083d172f826d482ad7e7d9cf84d7f29" translate="yes" xml:space="preserve">
          <source>We can also use the &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-position&quot;&gt;position()&lt;/a&gt; function in a comparison to inspect positions with conditional logic. The &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-position&quot;&gt;position()&lt;/a&gt; function returns the position index of the current context item in the sequence of items:</source>
          <target state="translated">조건부 논리를 사용하여 위치를 검사하기 위해 position &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-position&quot;&gt;()&lt;/a&gt; 함수를 비교할 수도 있습니다 . &lt;a href=&quot;http://www.w3.org/TR/xpath-functions/#func-position&quot;&gt;위치 ()&lt;/a&gt; 함수는 항목의 시퀀스에서의 현재 컨텍스트 항목의 위치 인덱스를 반환</target>
        </trans-unit>
        <trans-unit id="5f210fa7a16aa308e6be15306e222b4140e26dc8" translate="yes" xml:space="preserve">
          <source>We can ask the model for the item's data by passing it the model index corresponding to the item, and by specifying a role to obtain the type of data we want:</source>
          <target state="translated">항목에 해당하는 모델 색인을 전달하고 원하는 데이터 유형을 얻는 역할을 지정하여 항목의 데이터를 모델에 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7da324cafc37c36ecbf6cf79f283e627ae2ba2b9" translate="yes" xml:space="preserve">
          <source>We can connect signals and slots in user interface widgets in the usual way by adding the on_&amp;lt;object name&amp;gt; - prefix. For more information, see &lt;a href=&quot;#widgets-and-dialogs-with-auto-connect&quot;&gt;widgets-and-dialogs-with-auto-connect&lt;/a&gt;.</source>
          <target state="translated">on_ &amp;lt;object name&amp;gt;-접두사를 추가하여 일반적인 방식으로 사용자 인터페이스 위젯의 신호 및 슬롯을 연결할 수 있습니다. 자세한 정보는 &lt;a href=&quot;#widgets-and-dialogs-with-auto-connect&quot;&gt;widgets-and-dialogs-with-auto-connect를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e584ead46b7ac3ea8bcd69be46ce7cfe14c78a80" translate="yes" xml:space="preserve">
          <source>We can create a simple timetable by following this approach:</source>
          <target state="translated">이 접근법을 따르면 간단한 시간표를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c1e0556f0b1fb534a383b85a8b8e8895878af67" translate="yes" xml:space="preserve">
          <source>We can display the data provided by this model, or any other model, using the &lt;a href=&quot;qlistview&quot;&gt;QListView&lt;/a&gt; class to present the model's items in the form of a vertical list. For the string list model, this view also provides a default editor so that the items can be manipulated. We examine the possibilities made available by the standard view classes in &lt;a href=&quot;#view-classes&quot;&gt;View Classes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qlistview&quot;&gt;QListView&lt;/a&gt; 클래스를 사용하여이 모델 또는 다른 모델에서 제공 한 데이터를 표시하여 모델의 항목을 세로 목록 형식으로 표시 할 수 있습니다. 문자열 목록 모델의 경우이보기는 항목을 조작 할 수 있도록 기본 편집기를 제공합니다. 우리는 &lt;a href=&quot;#view-classes&quot;&gt;View Classes&lt;/a&gt; 의 표준 뷰 클래스가 제공하는 가능성을 조사합니다 .</target>
        </trans-unit>
        <trans-unit id="56483d108eca59ca79a39eb7491a1a378a351a14" translate="yes" xml:space="preserve">
          <source>We can handle the content request as shown below.</source>
          <target state="translated">아래와 같이 컨텐츠 요청을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="1ca7294f827b792729f62c74929df44c48c06877" translate="yes" xml:space="preserve">
          <source>We can keep track of the currently focused item by connecting the &lt;a href=&quot;qitemselectionmodel#currentChanged&quot;&gt;currentChanged()&lt;/a&gt; signal to a slot that is called with two model indexes. These correspond to the previously focused item, and the currently focused item.</source>
          <target state="translated">&lt;a href=&quot;qitemselectionmodel#currentChanged&quot;&gt;currentChanged ()&lt;/a&gt; 신호를 두 개의 모델 인덱스로 호출되는 슬롯 에 연결하여 현재 포커스가있는 항목을 추적 할 수 있습니다 . 이것들은 이전에 초점을 맞춘 항목과 현재 초점을 맞춘 항목에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="ce33fc533cadb4771864d6112561300dcdbc5b3c" translate="yes" xml:space="preserve">
          <source>We can now add an instance of QAxWidget2 and a &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; to the form. Visual Studio will automatically generate the RCW for the object servers. The QAxWidget2 instance takes most of the upper part of the form, with the &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; in the lower right corner.</source>
          <target state="translated">이제 QAxWidget2 인스턴스와 &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; 을 폼에 추가 할 수 있습니다 . Visual Studio는 개체 서버에 대한 RCW를 자동으로 생성합니다. QAxWidget2 인스턴스는 양식의 상단 부분을 대부분 차지하며 오른쪽 아래 모서리에 &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d962eaf42e2da7d49625ec55cc5ae71efcce7d7" translate="yes" xml:space="preserve">
          <source>We can refer to each list item by its index in the list:</source>
          <target state="translated">목록의 색인으로 각 목록 항목을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1badb18168f43595d1160632055fc65cf4482b0b" translate="yes" xml:space="preserve">
          <source>We can reimplement the mouseMoveEvent() for a widget, and start a drag and drop operation with a combination of possible drop actions. For example, we may want to ensure that dragging always moves objects in the widget:</source>
          <target state="translated">위젯에 대해 mouseMoveEvent ()를 다시 구현하고 가능한 드롭 액션 조합으로 드래그 앤 드롭 작업을 시작할 수 있습니다. 예를 들어, 드래그하면 항상 위젯에서 객체가 이동되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="104ae040fc9f2d606038c18efc4a7cc5942aa249" translate="yes" xml:space="preserve">
          <source>We can subclass &lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; and reimplement &lt;a href=&quot;qmimedata#hasFormat&quot;&gt;hasFormat&lt;/a&gt;(), &lt;a href=&quot;qmimedata#formats&quot;&gt;formats&lt;/a&gt;(), and &lt;a href=&quot;qmimedata#retrieveData&quot;&gt;retrieveData&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qmimedata&quot;&gt;QMimeData&lt;/a&gt; 를 서브 클래 싱 하고 &lt;a href=&quot;qmimedata#hasFormat&quot;&gt;hasFormat&lt;/a&gt; (), &lt;a href=&quot;qmimedata#formats&quot;&gt;형식&lt;/a&gt; () 및 &lt;a href=&quot;qmimedata#retrieveData&quot;&gt;retrieveData&lt;/a&gt; ()를 다시 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6ca8081caaa3e9265df0ec579adf531979d342d" translate="yes" xml:space="preserve">
          <source>We can use captured text within the regexp itself. To refer to the captured text we use</source>
          <target state="translated">정규 표현식 자체에서 캡처 된 텍스트를 사용할 수 있습니다. 우리가 사용하는 캡처 된 텍스트를 참조하려면</target>
        </trans-unit>
        <trans-unit id="955434e7ae7a2f8ce12ff7b6c6aec8643bba0792" translate="yes" xml:space="preserve">
          <source>We check whether the interface requested is for &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt;; if it is, we create and return an interface for it. Note that &lt;code&gt;object&lt;/code&gt; will always be an instance of &lt;code&gt;classname&lt;/code&gt;. You must return 0 if you do not support the class. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt; checks with the available accessibility plugins until it finds one that does not return 0.</source>
          <target state="translated">요청 된 인터페이스가 &lt;a href=&quot;qslider&quot;&gt;QSlider를&lt;/a&gt; 위한 것인지 확인합니다 . 그렇다면 인터페이스를 만들고 반환합니다. 그 주 &lt;code&gt;object&lt;/code&gt; 항상의 인스턴스가 될 것이다 &lt;code&gt;classname&lt;/code&gt; . 클래스를 지원하지 않으면 0을 반환해야합니다. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility ()&lt;/a&gt; 는 0을 반환하지 않는 플러그인을 찾을 때까지 사용 가능한 접근성 플러그인을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="773201dd186d68212b28c952acb636d33ee4f4c8" translate="yes" xml:space="preserve">
          <source>We connect the &lt;b&gt;OK&lt;/b&gt; button's &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;clicked()&lt;/a&gt; signal to the dialog's checkValues() slot which we implement as follows:</source>
          <target state="translated">우리는 연결 &lt;b&gt;OK의&lt;/b&gt; 버튼의 &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;클릭 ()&lt;/a&gt; 대화 상자의 checkValues () 우리가 구현 슬롯으로 다음에 신호를 :</target>
        </trans-unit>
        <trans-unit id="a7cd0733fe7abae864b47e1a416a3d03cbd3b2a6" translate="yes" xml:space="preserve">
          <source>We construct a file system model in the following way:</source>
          <target state="translated">다음과 같은 방법으로 파일 시스템 모델을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="16152d97bdefe59b991736c37f73262679a2614a" translate="yes" xml:space="preserve">
          <source>We could instead resolve the common base just once in the block:</source>
          <target state="translated">대신 블록에서 공통베이스를 한 번만 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="490913b53c96135545b690afe61f043f9d3abb4e" translate="yes" xml:space="preserve">
          <source>We create a text layout, specifying the text string we want to display and the font to use. We ensure that the text we supplied is formatted correctly by obtaining text lines from the text format, and wrapping the remaining text using the available space. The lines are positioned as we move down the page.</source>
          <target state="translated">표시 할 텍스트 문자열과 사용할 글꼴을 지정하여 텍스트 레이아웃을 만듭니다. 제공 한 텍스트는 텍스트 형식에서 텍스트 줄을 가져 와서 사용 가능한 공간을 사용하여 나머지 텍스트를 줄 바꿈하여 올바른 형식을 지정합니다. 페이지를 아래로 이동할 때 선이 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="0da5fb1f24a5c09b41a88c9c2bb9065ef4a6b0ce" translate="yes" xml:space="preserve">
          <source>We create a toolbar as a child of the main window, and add the desired actions to it:</source>
          <target state="translated">우리는 툴바를 메인 윈도우의 자식으로 생성하고 원하는 액션을 추가합니다 :</target>
        </trans-unit>
        <trans-unit id="d920f00c9c5c21db617b5ff11b7b839f2f02daea" translate="yes" xml:space="preserve">
          <source>We create the &lt;code&gt;WidgetDelegate&lt;/code&gt; class, which inherits from &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;. We do the drawing in the &lt;a href=&quot;qabstractitemdelegate#paint&quot;&gt;paint&lt;/a&gt;() function:</source>
          <target state="translated">우리는 만들 &lt;code&gt;WidgetDelegate&lt;/code&gt; 의 어떤에서 상속 클래스, &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate을&lt;/a&gt; . 우리는 &lt;a href=&quot;qabstractitemdelegate#paint&quot;&gt;paint&lt;/a&gt; () 함수 에서 그리기를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="d2d346d40d0b07d9ebfaee9356c31c3ded1beb60" translate="yes" xml:space="preserve">
          <source>We create two views so that we can examine the items held in the model in two different ways:</source>
          <target state="translated">모델에 보유 된 항목을 서로 다른 두 가지 방식으로 검사 할 수 있도록 두 개의 뷰를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0b44079907108ff46a4acb087613513fa05abb44" translate="yes" xml:space="preserve">
          <source>We declare namespaces in the same way as attributes; strictly speaking they</source>
          <target state="translated">속성과 같은 방식으로 네임 스페이스를 선언합니다. 엄밀히 말하면</target>
        </trans-unit>
        <trans-unit id="58496a5029cc1fa9055f408cf50101d427ca5c01" translate="yes" xml:space="preserve">
          <source>We declare the property with the &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt;() macro in the private section of the class. The required &lt;code&gt;READ&lt;/code&gt; function is named &lt;code&gt;priority&lt;/code&gt;, and we include a &lt;code&gt;WRITE&lt;/code&gt; function named &lt;code&gt;setPriority&lt;/code&gt;. The enumeration type must be registered with the &lt;a href=&quot;metaobjects#&quot;&gt;Meta-Object System&lt;/a&gt; using the &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt;() macro. Registering an enumeration type makes the enumerator names available for use in calls to &lt;a href=&quot;qobject#setProperty&quot;&gt;QObject::setProperty&lt;/a&gt;(). We must also provide our own declarations for the &lt;code&gt;READ&lt;/code&gt; and &lt;code&gt;WRITE&lt;/code&gt; functions. The declaration of MyClass then might look like this:</source>
          <target state="translated">클래스의 private 섹션에서 &lt;a href=&quot;qobject#Q_PROPERTY&quot;&gt;Q_PROPERTY&lt;/a&gt; () 매크로를 사용 하여 속성을 선언합니다 . 필요한 &lt;code&gt;READ&lt;/code&gt; 함수의 이름은 &lt;code&gt;priority&lt;/code&gt; 이며 &lt;code&gt;setPriority&lt;/code&gt; 라는 &lt;code&gt;WRITE&lt;/code&gt; 함수 가 포함되어 있습니다. 열거 유형은 &lt;a href=&quot;qobject#Q_ENUM&quot;&gt;Q_ENUM&lt;/a&gt; () 매크로를 사용하여 &lt;a href=&quot;metaobjects#&quot;&gt;Meta-Object System에&lt;/a&gt; 등록해야합니다 . 열거 형을 등록하면 열거 자 이름을 &lt;a href=&quot;qobject#setProperty&quot;&gt;QObject :: setProperty&lt;/a&gt; () 호출에 사용할 수 있습니다 . 또한 &lt;code&gt;READ&lt;/code&gt; 및 &lt;code&gt;WRITE&lt;/code&gt; 함수에 대한 자체 선언도 제공해야합니다 . MyClass 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44054f95bc27b2cf9d35ae98d9d528131dc95c37" translate="yes" xml:space="preserve">
          <source>We define a function to convert degrees to radians, which are the units used by &lt;a href=&quot;qml-qtquick-canvas&quot;&gt;Canvas&lt;/a&gt;.</source>
          <target state="translated">도를 라디안으로 변환하는 함수를 정의합니다.이 함수는 &lt;a href=&quot;qml-qtquick-canvas&quot;&gt;Canvas에&lt;/a&gt; 사용되는 단위 입니다.</target>
        </trans-unit>
        <trans-unit id="a740c071c8203575c8eccc44afeee8b6040311fb" translate="yes" xml:space="preserve">
          <source>We define the dialog in the same way as before, but now include a slot in addition to the constructor:</source>
          <target state="translated">이전과 같은 방식으로 대화 상자를 정의하지만 생성자 외에 슬롯도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8d83b3b4a0a8603bdd21e0396866642e314c0b8a" translate="yes" xml:space="preserve">
          <source>We do the same for the clock's minute hand, which is defined by the four points (1, 0), (0, 1), (-1, 0), and (0, -40). These coordinates specify a hand that is thinner and longer than the minute hand.</source>
          <target state="translated">우리는 시계의 분침에 대해 동일한 작업을 수행하는데, 이는 4 개의 점 (1, 0), (0, 1), (-1, 0) 및 (0, -40)으로 정의됩니다. 이 좌표는 분침보다 얇고 긴 손을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="bacb72866705b08b98605d98203499720468a7fe" translate="yes" xml:space="preserve">
          <source>We do this by writing a slot that stores the request data in a persistent structure, indicating to the caller using &lt;a href=&quot;qdbusmessage#setDelayedReply&quot;&gt;QDBusMessage::setDelayedReply(true)&lt;/a&gt; that the response will be sent later.</source>
          <target state="translated">요청 데이터를 영구 구조로 저장하는 슬롯을 작성하여 &lt;a href=&quot;qdbusmessage#setDelayedReply&quot;&gt;QDBusMessage :: setDelayedReply (true)&lt;/a&gt; 를 사용하여 호출자 에게 응답이 나중에 전송 될 것임을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4d2748a4d54f127b97dca5190a6be37374f98a58" translate="yes" xml:space="preserve">
          <source>We draw the clock's hour hand by rotating the coordinate system and calling &lt;a href=&quot;qpainter#drawConvexPolygon&quot;&gt;QPainter::drawConvexPolygon&lt;/a&gt;(). Thank's to the rotation, it's drawn pointed in the right direction.</source>
          <target state="translated">좌표계를 회전시키고 &lt;a href=&quot;qpainter#drawConvexPolygon&quot;&gt;QPainter :: drawConvexPolygon&lt;/a&gt; ()을 호출하여 시계의 시침을 그립니다 . 회전 덕분에 올바른 방향으로 그려집니다.</target>
        </trans-unit>
        <trans-unit id="a7e46978ecc31231e2fd73a6ebf144b0b50eaf5e" translate="yes" xml:space="preserve">
          <source>We ensure that the parent Rectangle is large enough so that there is some space left around the edges of the horizontally centered Row item.</source>
          <target state="translated">부모 사각형이 수평으로 중앙에있는 행 항목의 가장자리 주위에 약간의 공간이 남을만큼 충분히 커야합니다.</target>
        </trans-unit>
        <trans-unit id="8fdf8f0203ad2aa4dd01166cf9036c5692d968d4" translate="yes" xml:space="preserve">
          <source>We first save the state of the painter. This is not always necessary, but in this case the &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt; needs the painter in the same state as it was when PE_IndicatorCheckBox was called (We could also set the state with function calls, of course). We then use &lt;code&gt;drawButtonBackground()&lt;/code&gt; to draw the background of the check box indicator. This is a helper function that draws the background and also the frame of push buttons and check boxes. We take a look at that function below. We then check if the mouse is hovering over the checkbox. If it is, we draw the frame that Java checkboxes have when the box is not pressed down and the mouse is over it. You may note that Java does not handle tri-state boxes, so we have not implemented it.</source>
          <target state="translated">먼저 화가의 상태를 저장합니다. 이것은 항상 필요하지 않지만이 경우 &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle는&lt;/a&gt; PE_IndicatorCheckBox가 호출 된 때 (우리는 또한 물론, 함수 호출로 상태를 설정할 수 있습니다)이었다 같은 상태로 화가 필요합니다. 그런 다음 &lt;code&gt;drawButtonBackground()&lt;/code&gt; 를 사용 하여 확인란 표시기의 배경을 그립니다. 배경과 푸시 버튼 및 확인란의 프레임을 그리는 도우미 기능입니다. 아래에서 그 기능을 살펴 봅니다. 그런 다음 마우스가 확인란 위로 마우스를 가져 가고 있는지 확인합니다. 만약 그렇다면, 상자를 누르지 않고 마우스가 그 위에있을 때 Java 체크 박스가 가지고있는 프레임을 그립니다. Java가 3 상태 상자를 처리하지 않으므로 구현하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="3b83f66e4830b4873cf2977b8f9161cb0fb7a9fc" translate="yes" xml:space="preserve">
          <source>We generally recommend this approach for libraries and large applications. For more information, see &lt;a href=&quot;https://doc.qt.io/qt-5.13/sharedlibrary.html&quot;&gt;Creating Shared Libraries&lt;/a&gt;.</source>
          <target state="translated">일반적으로 라이브러리 및 대규모 응용 프로그램에이 방법을 권장합니다. 자세한 내용은 &lt;a href=&quot;https://doc.qt.io/qt-5.13/sharedlibrary.html&quot;&gt;공유 라이브러리 만들기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c13396b5ba8d917d8224b65aad78ac2b3725f40" translate="yes" xml:space="preserve">
          <source>We give a simple example, in which we have implemented a scroll area that can scroll any &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt;. We make the widget a child of the viewport; this way, we do not have to calculate which part of the widget to draw but can simply move the widget with &lt;a href=&quot;qwidget#pos-prop&quot;&gt;QWidget::move&lt;/a&gt;(). When the area contents or the viewport size changes, we do the following:</source>
          <target state="translated">&lt;a href=&quot;qwidget&quot;&gt;QWidget을&lt;/a&gt; 스크롤 할 수있는 스크롤 영역을 구현 한 간단한 예제를 제공합니다 . 위젯을 뷰포트의 자식으로 만듭니다. 이런 식으로 위젯의 어느 부분을 그릴 지 계산할 필요는 없지만 &lt;a href=&quot;qwidget#pos-prop&quot;&gt;QWidget :: move&lt;/a&gt; ()를 사용 하여 위젯을 간단히 이동할 수 있습니다 . 영역 내용 또는 뷰포트 크기가 변경되면 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1d8edcd4540aeaea40350185d3fa150c56bd4968" translate="yes" xml:space="preserve">
          <source>We give an example of drawing a progress bar in items; in our case for a package management program.</source>
          <target state="translated">항목에 진행률 표시 줄을 그리는 예제를 제공합니다. 우리의 경우 패키지 관리 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="8e216822e6cf1bb69f1d52634794d57be4ecc9e0" translate="yes" xml:space="preserve">
          <source>We give an example of how to create and add dock widgets to a main window:</source>
          <target state="translated">메인 창에 독 위젯을 생성하고 추가하는 방법에 대한 예제를 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="4708171d63d5179a5bf148ded39866e8efba4e93" translate="yes" xml:space="preserve">
          <source>We give an example of the latter technique from the list. We assume that the text edit is visible.</source>
          <target state="translated">우리는 목록에서 후자의 기술의 예를 제공합니다. 텍스트 편집이 보인다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="230fb10a7d6e7c8883ca898dc36534eb3c95f58e" translate="yes" xml:space="preserve">
          <source>We give an image of a checkbox and the style option to match it.</source>
          <target state="translated">확인란 이미지와 스타일 옵션을 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="3461e3c3cf88b36c84571bd94ca302d9601eec1c" translate="yes" xml:space="preserve">
          <source>We have a Position type, a &lt;a href=&quot;qml-coordinate&quot;&gt;coordinate&lt;/a&gt; type but where does the data come from? Also it is a good idea to be able to indicate alternative sources. Perhaps instead of directly picking up GPS satellites it might be desirable to do some testing using a datafile.</source>
          <target state="translated">위치 유형, &lt;a href=&quot;qml-coordinate&quot;&gt;좌표&lt;/a&gt; 유형이 있지만 데이터의 출처는 어디입니까? 또한 대체 출처를 표시 할 수있는 것이 좋습니다. GPS 위성을 직접 선택하는 대신 데이터 파일을 사용하여 일부 테스트를 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="770fe300fe7b100c5df5649cbc8bd2852c6c4ef8" translate="yes" xml:space="preserve">
          <source>We have a look at the different states a scroll bar can set on the style option:</source>
          <target state="translated">스크롤 막대가 스타일 옵션에서 설정할 수있는 다양한 상태를 살펴 보았습니다.</target>
        </trans-unit>
        <trans-unit id="5fbca3feda66640aee7a7167823440cff2ce86bc" translate="yes" xml:space="preserve">
          <source>We have already seen some boolean predicates in use. Earlier, we saw a</source>
          <target state="translated">우리는 이미 사용중인 부울 술어를 보았습니다. 앞서 우리는</target>
        </trans-unit>
        <trans-unit id="26bedb6604cc9236167296cef082520039e5cdb3" translate="yes" xml:space="preserve">
          <source>We have hard-coded the colors (we don't use the &lt;a href=&quot;qpalette&quot;&gt;QPalette&lt;/a&gt;) for the linear gradients, which are used, for example, for button bevels, tool bars, and check boxes. This is because the Java palette cannot produce these colors. Java does not change these colors based on widget color group or role anyway (they are not dependent on the palette), so it does not present a problem in any case.</source>
          <target state="translated">버튼 경사, 도구 모음 및 확인란과 같은 선형 그라디언트 의 색상을 하드 코딩했습니다 ( &lt;a href=&quot;qpalette&quot;&gt;QPalette&lt;/a&gt; 사용하지 않음 ). Java 팔레트가 이러한 색상을 생성 할 수 없기 때문입니다. Java는 어쨌든 위젯 색상 그룹 또는 역할을 기반으로 이러한 색상을 변경하지 않으므로 팔레트에 의존하지 않으므로 어떤 경우에도 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1595df0b2315570f704b0293461bb9de1e16dfdd" translate="yes" xml:space="preserve">
          <source>We have implemented a style that resembles the Java default look and feel (previously known as Metal). We have done this as it is relatively simple to implement and we wanted to build a style for this overview document. To keep it simple and not too extensive, we have simplified the style somewhat, but Qt is perfectly able to make an exact copy of the style. However, there are no concrete plans to implement the style as a part of Qt.</source>
          <target state="translated">Java 기본 모양과 느낌 (이전의 Metal)과 유사한 스타일을 구현했습니다. 구현하기가 비교적 간단하므로이 개요 문서에 대한 스타일을 만들고 싶었습니다. 단순하고 지나치게 광범위하게 유지하기 위해 스타일을 다소 단순화했지만 Qt는 스타일의 정확한 사본을 완벽하게 만들 수 있습니다. 그러나 Qt의 일부로 스타일을 구현하려는 구체적인 계획은 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a6de4d0ba26b1933f0ba96969e3bc28cac2c8d8" translate="yes" xml:space="preserve">
          <source>We have introduced the FrameGraph and the node types that compose it. We then went on to discuss a few examples to illustrate the framegraph building rules and how the Qt 3D engine uses the framegraph behind the scenes. By now you should have a pretty good overview of the FrameGraph and how it can be used (perhaps to add an &lt;a href=&quot;http://en.wikipedia.org/wiki/Z-buffering#&quot;&gt;early z-fill pass&lt;/a&gt; to a forward renderer). Also you should always keep in mind that the FrameGraph is a tool for you to use so that you are not tied down to the provided renderer and materials that Qt 3D provides out of the box.</source>
          <target state="translated">우리는 FrameGraph와 그것을 구성하는 노드 타입을 소개했습니다. 그런 다음 프레임 그래프 작성 규칙과 Qt 3D 엔진이 장면 뒤에서 프레임 그래프를 사용하는 방법을 설명하기위한 몇 가지 예를 계속 설명했습니다. 이제 FrameGraph에 대한 개요와이를 사용하는 방법 (아마도 &lt;a href=&quot;http://en.wikipedia.org/wiki/Z-buffering#&quot;&gt;z-fill 패스&lt;/a&gt; 를 포워드 렌더러 에 추가하는 방법)에 대한 개요를 갖추어야합니다 . 또한 FrameGraph는 Qt 3D가 제공하는 제공된 렌더러 및 재질에 묶이지 않도록 사용할 수있는 도구라는 것을 항상 명심해야합니다.</target>
        </trans-unit>
        <trans-unit id="45a118ce0fef998727b037e57d5b159ee482e6f6" translate="yes" xml:space="preserve">
          <source>We have not fully implemented every element in the Java style. This way, we have reduced the amount and complexity of the code. In general, the style was intended as a practical example for this style overview document, and not to be a part of Qt itself.</source>
          <target state="translated">Java 스타일의 모든 요소를 ​​완전히 구현하지는 않았습니다. 이런 식으로 코드의 양과 복잡성을 줄였습니다. 일반적으로 스타일은이 스타일 개요 문서의 실제 예제로 의도되었으며 Qt 자체의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="dd0beb555a95cc28cc49453dd8cf817d5005ec71" translate="yes" xml:space="preserve">
          <source>We have not managed to make &lt;a href=&quot;activeqt-index#&quot;&gt;ActiveQt&lt;/a&gt; based COM objects work with the following client applications.</source>
          <target state="translated">&lt;a href=&quot;activeqt-index#&quot;&gt;ActiveQt&lt;/a&gt; 기반 COM 개체를 다음 클라이언트 응용 프로그램과 함께 작동 하도록 만들지 못했습니다 .</target>
        </trans-unit>
        <trans-unit id="ec4d24d3e01ff826856ab8c167a4f95c2e9fe205" translate="yes" xml:space="preserve">
          <source>We have not tried to emulate the Java fonts. Java and Qt use very different font engines, so we don't consider it worth the effort as we only use the style as an example for this overview.</source>
          <target state="translated">우리는 자바 폰트를 모방하려고하지 않았다. Java와 Qt는 매우 다른 글꼴 엔진을 사용하므로이 개요의 예제로만 스타일을 사용하기 때문에 노력할 가치가 있다고 생각하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a70fdb392ae2fede264feab8783b8058cb6c17f" translate="yes" xml:space="preserve">
          <source>We have now exposed the information we have about the slider to the clients. For the clients to be able to alter the slider - for example, to change its value - we must provide information about the actions that can be performed and perform them upon request. We discuss this in the next section.</source>
          <target state="translated">이제 슬라이더에 대한 정보를 클라이언트에 공개했습니다. 클라이언트가 슬라이더를 변경 (예 : 값 변경) 할 수 있으려면 요청시 수행 할 수있는 조치에 대한 정보를 제공해야합니다. 다음 섹션에서 이에 대해 논의합니다.</target>
        </trans-unit>
        <trans-unit id="c338df5efc75cbc2bff6e849f9371416139562e6" translate="yes" xml:space="preserve">
          <source>We have only implemented ticks below the slider. Flat push buttons are also left out. We do not handle the case where the title bars and dock window titles grow too small for their contents, but simply draw sub controls over each other.</source>
          <target state="translated">슬라이더 아래에 진드기 만 구현했습니다. 플랫 푸시 버튼도 빠져 있습니다. 제목 표시 줄과 독 창 제목이 내용물에 비해 너무 작아지는 경우를 다루지 않고 단순히 서로 하위 컨트롤을 그립니다.</target>
        </trans-unit>
        <trans-unit id="ca9881b5099400a44759514844340b827927f62c" translate="yes" xml:space="preserve">
          <source>We have seen how check boxes are styled in the Java style from the time the widget gets a paint request to the time the style is finished painting. To learn in detail how each widget is painted, you need to go through the code step-by-step as we have done here. However, it is usually enough to know which style elements the widgets draw. The widget builds a style option and calls on the style one or more times to draw the style elements of which it consists. Usually, it is also sufficient to know the states a widget can be in and the other contents of the style option, i.e., what we list in the next section.</source>
          <target state="translated">우리는 위젯이 페인트 요청을했을 때부터 스타일이 완성 될 때까지 Java 스타일에서 확인란의 스타일을 지정하는 방법을 보았습니다. 각 위젯의 페인트 방법을 자세히 알아 보려면 여기에서 수행 한대로 단계별로 코드를 진행해야합니다. 그러나 일반적으로 위젯이 그리는 스타일 요소를 아는 것으로 충분합니다. 위젯은 스타일 옵션을 빌드하고 스타일을 구성하는 스타일 요소를 그리기 위해 스타일을 한 번 이상 호출합니다. 일반적으로 위젯이있을 수있는 상태와 스타일 옵션의 다른 내용, 즉 다음 섹션에서 나열하는 내용을 아는 것만으로도 충분합니다.</target>
        </trans-unit>
        <trans-unit id="bba2c3785373235e7368cf0f40f1bd69598a3b2c" translate="yes" xml:space="preserve">
          <source>We ignore &lt;a href=&quot;qlayoutitem#isEmpty&quot;&gt;QLayoutItem::isEmpty&lt;/a&gt;(); this means that the layout will treat hidden widgets as visible.</source>
          <target state="translated">&lt;a href=&quot;qlayoutitem#isEmpty&quot;&gt;QLayoutItem :: isEmpty&lt;/a&gt; ()를 무시합니다 . 이것은 레이아웃이 숨겨진 위젯을 보이는 것으로 취급한다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="47dd0e9e8b212523675778c9bac8c266d9a5865d" translate="yes" xml:space="preserve">
          <source>We include a small example where we customize the drawing of item backgrounds.</source>
          <target state="translated">항목 배경 그림을 사용자 정의하는 작은 예를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2b3ec31f307cd2391e8f96d564fa1624f98fcac1" translate="yes" xml:space="preserve">
          <source>We inherit &lt;code&gt;Ui::CalculatorForm&lt;/code&gt; privately to ensure that the user interface objects are private in our subclass. We can also inherit it with the &lt;code&gt;public&lt;/code&gt; or &lt;code&gt;protected&lt;/code&gt; keywords in the same way that we could have made &lt;code&gt;ui&lt;/code&gt; public or protected in the previous case.</source>
          <target state="translated">우리는 &lt;code&gt;Ui::CalculatorForm&lt;/code&gt; 프라이빗으로 상속 하여 사용자 인터페이스 객체가 서브 클래스에서 프라이빗인지 확인합니다. 또한 이전의 경우 &lt;code&gt;ui&lt;/code&gt; 공개하거나 보호 할 수있는 것과 같은 방식으로 &lt;code&gt;public&lt;/code&gt; 또는 &lt;code&gt;protected&lt;/code&gt; 키워드로 이를 상속 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa51790a150e3d6d809c823ab45f268d4b470c29" translate="yes" xml:space="preserve">
          <source>We initially examine the row number supplied to see if we can use it to insert items into the model, regardless of whether the parent index is valid or not.</source>
          <target state="translated">우리는 처음에 제공된 행 번호를 검사하여 부모 인덱스가 유효한지 여부에 관계없이 모델에 항목을 삽입하는 데 사용할 수 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="de73b89337c29aa0cd102b08705e40ddca202a52" translate="yes" xml:space="preserve">
          <source>We insert some text in this frame then set up a frame format for the child frame:</source>
          <target state="translated">이 프레임에 텍스트를 삽입 한 다음 자식 프레임의 프레임 형식을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7a9d5cf19dbdabbbb0431b44b66500721cbc4939" translate="yes" xml:space="preserve">
          <source>We install the delegate's default event filter on the editor to ensure that it provides the standard editing shortcuts that users expect. Additional shortcuts can be added to the editor to allow more sophisticated behavior; these are discussed in the section on &lt;a href=&quot;#editinghints&quot;&gt;Editing Hints&lt;/a&gt;.</source>
          <target state="translated">델리게이트의 기본 이벤트 필터를 편집기에 설치하여 사용자가 기대하는 표준 편집 바로 가기를 제공합니다. 보다 정교한 동작을 위해 편집기에 추가 단축키를 추가 할 수 있습니다. 이에 대한 내용은 &lt;a href=&quot;#editinghints&quot;&gt;힌트 편집&lt;/a&gt; 섹션에서 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="58941aa6e0777ba6c916060ed1f8f5fafdcb1430" translate="yes" xml:space="preserve">
          <source>We invite you to explore the rest of Qt. We prepared overviews to help you decide which APIs to use and our examples demonstrate how to use our API.</source>
          <target state="translated">우리는 당신이 나머지 Qt를 탐험하도록 초대합니다. 사용할 API를 결정하는 데 도움이되는 개요를 준비했으며 예제를 통해 API 사용 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b859f98564a54fdc2cf142b42380327266f738d7" translate="yes" xml:space="preserve">
          <source>We invite you to explore the rest of Qt. We prepared overviews which help you decide which APIs to use and our examples demonstrate how to use our API.</source>
          <target state="translated">우리는 당신이 나머지 Qt를 탐험하도록 초대합니다. 사용할 API를 결정하는 데 도움이되는 개요와 예제를 통해 API 사용법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="310afce11316171a64f006ec0944b1f2b38cf71b" translate="yes" xml:space="preserve">
          <source>We invite you to explore the rest of Qt. We prepared overviews which help you decide which APIs to use and our examples demonstrate how to use them.</source>
          <target state="translated">우리는 당신이 나머지 Qt를 탐험하도록 초대합니다. 사용할 API를 결정하는 데 도움이되는 개요와 예제 사용 방법을 보여주는 예제를 준비했습니다.</target>
        </trans-unit>
        <trans-unit id="fe4c9224f9101ce108abb40925d8ae2196ebdeec" translate="yes" xml:space="preserve">
          <source>We may also ignore the proposed action, and perform some other action on the data. To do this, we would call the event object's &lt;a href=&quot;qdropevent#setDropAction&quot;&gt;setDropAction()&lt;/a&gt; with the preferred action from &lt;a href=&quot;qt#DropAction-enum&quot;&gt;Qt::DropAction&lt;/a&gt; before calling &lt;a href=&quot;qevent#accept&quot;&gt;accept()&lt;/a&gt;. This ensures that the replacement drop action is used instead of the proposed action.</source>
          <target state="translated">제안 된 조치를 무시하고 데이터에 대해 다른 조치를 수행 할 수도 있습니다. 이를 위해 &lt;a href=&quot;qevent#accept&quot;&gt;accept ()&lt;/a&gt; 를 호출하기 전에 &lt;a href=&quot;qt#DropAction-enum&quot;&gt;Qt :: DropAction&lt;/a&gt; 에서 선호하는 액션으로 이벤트 객체의 &lt;a href=&quot;qdropevent#setDropAction&quot;&gt;setDropAction ()&lt;/a&gt; 을 호출 합니다. 이를 통해 제안 된 조치 대신 대체 삭제 조치가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fcbc1ee840d899d3843383b84c0969866ac3228a" translate="yes" xml:space="preserve">
          <source>We mostly use Java style widgets as examples. The Java style does not draw every element in the element trees. This is because they are not visible for that widget in the Java style. We still make sure that all elements are implemented in a way that conforms with the Java style, as custom widgets might need them (this does not exclude leaving implementations to &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt; though).</source>
          <target state="translated">우리는 주로 자바 스타일 위젯을 예제로 사용합니다. Java 스타일은 요소 트리의 모든 요소를 ​​그리지 않습니다. Java 스타일에서 해당 위젯에 표시되지 않기 때문입니다. 우리는 여전히 커스텀 위젯이 필요할 수 있기 때문에 모든 요소가 Java 스타일을 준수하는 방식으로 구현되어 있는지 확인합니다 (이것은 &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle에&lt;/a&gt; 구현을 남겨 두는 것을 제외하지 않습니다 ).</target>
        </trans-unit>
        <trans-unit id="c04ae4ec71b6cc29ca6f4c93566e033dfb532b2e" translate="yes" xml:space="preserve">
          <source>We need to include the header file that &lt;code&gt;uic&lt;/code&gt; generates from the &lt;code&gt;calculatorform.ui&lt;/code&gt; file, as follows:</source>
          <target state="translated">&lt;code&gt;uic&lt;/code&gt; 이 &lt;code&gt;calculatorform.ui&lt;/code&gt; 파일 에서 생성 하는 헤더 파일을 다음과 같이 포함시켜야합니다 .</target>
        </trans-unit>
        <trans-unit id="8d2abfeef0d59c4bfcf28fdf37709a7b28c43e15" translate="yes" xml:space="preserve">
          <source>We obtain the root frame in the following manner:</source>
          <target state="translated">다음과 같은 방법으로 루트 프레임을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="1f89f455530b2a307b05c9b16a5b2625979a79eb" translate="yes" xml:space="preserve">
          <source>We offset the needle vertically so that its back sits beyond the knob.</source>
          <target state="translated">우리는 바늘이 수직으로 오프셋되어 등이 손잡이 너머에 앉도록합니다.</target>
        </trans-unit>
        <trans-unit id="af30d43ad0473e4184c79dbacca4937c288b7682" translate="yes" xml:space="preserve">
          <source>We only return a valid &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; if the model index supplied is valid, the row number is within the range of items in the string list, and the requested role is one that we support.</source>
          <target state="translated">제공된 모델 색인이 유효하고 행 번호가 문자열 목록의 항목 범위 내에 있으며 요청 된 역할이 지원하는 역할 인 경우 에만 유효한 &lt;a href=&quot;qvariant&quot;&gt;QVariant를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d519bf1e0eade86a44363d7da9a1e943e2f9a1dd" translate="yes" xml:space="preserve">
          <source>We present an image of a Java style window being moved in a &lt;a href=&quot;qmdiarea&quot;&gt;QMdiArea&lt;/a&gt; with a rubber band:</source>
          <target state="translated">&lt;a href=&quot;qmdiarea&quot;&gt;QMdiArea&lt;/a&gt; 에서 고무 밴드 가있는 Java 스타일 창의 이미지가 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="472174111ba0c508f8013d91cecf491da783f4ec" translate="yes" xml:space="preserve">
          <source>We provide a &lt;a href=&quot;https://doc.qt.io/qt-5.13/accelerators.html&quot;&gt;list of common mnemonics&lt;/a&gt; in English. At the time of writing, Microsoft and Open Group do not appear to have issued equivalent recommendations for other languages.</source>
          <target state="translated">우리는 제공하는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/accelerators.html&quot;&gt;일반적인 니모닉 목록&lt;/a&gt; 영어를. 작성 당시 Microsoft와 Open Group은 다른 언어에 대해 동등한 권장 사항을 제시하지 않은 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="66f4ffe62d2465ce2ca8722b4ee9f29b8fb5a0bc" translate="yes" xml:space="preserve">
          <source>We recommend compiling and running this example before you read any further. In particular, try resizing the window to different sizes.</source>
          <target state="translated">더 읽기 전에이 예제를 컴파일하고 실행하는 것이 좋습니다. 특히, 창의 크기를 다른 크기로 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="3709a9c9d98ecde164d90f6d476610e0e2098877" translate="yes" xml:space="preserve">
          <source>We recommend omitting the file's suffix in</source>
          <target state="translated">파일의 접미사를 생략하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e1d7c56b00842e33a9702e020b9f35d7e9d5b5ce" translate="yes" xml:space="preserve">
          <source>We recommend omitting the file's suffix in the file name, since &lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; will automatically look for the file with the appropriate suffix (see &lt;a href=&quot;qlibrary#isLibrary&quot;&gt;isLibrary&lt;/a&gt;()).</source>
          <target state="translated">&lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; 는 적절한 접미사가있는 파일을 자동으로 찾게 되므로 파일 이름에서 파일 접미사를 생략하는 것이 좋습니다 ( &lt;a href=&quot;qlibrary#isLibrary&quot;&gt;isLibrary&lt;/a&gt; () 참조 ).</target>
        </trans-unit>
        <trans-unit id="3114e2f2285bee294daab90e88c4b2f51c31b6ce" translate="yes" xml:space="preserve">
          <source>We recommend omitting the file's suffix in the file name, since &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; will automatically look for the file with the appropriate suffix (see &lt;a href=&quot;qlibrary#isLibrary&quot;&gt;QLibrary::isLibrary&lt;/a&gt;()).</source>
          <target state="translated">&lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; 는 자동으로 적절한 접미사가있는 파일을 찾기 때문에 파일 이름에서 파일 접미 부를 생략하는 것이 좋습니다 ( &lt;a href=&quot;qlibrary#isLibrary&quot;&gt;QLibrary :: isLibrary&lt;/a&gt; () 참조).</target>
        </trans-unit>
        <trans-unit id="b227f5c93e7ea2541dfc11c2c90ce7a0bbb5ae73" translate="yes" xml:space="preserve">
          <source>We recommend setting the restart hint in &lt;a href=&quot;qguiapplication#saveStateRequest&quot;&gt;QGuiApplication::saveStateRequest&lt;/a&gt;() because most session managers perform a checkpoint shortly after an application's startup.</source>
          <target state="translated">&lt;a href=&quot;qguiapplication#saveStateRequest&quot;&gt;QGuiApplication :: saveStateRequest&lt;/a&gt; () 에서 재시작 힌트를 설정하는 것이 좋습니다. 대부분의 세션 관리자는 응용 프로그램 시작 직후 검사 점을 수행하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="16685481c388a876cf1e5398d1b1774eb6d50794" translate="yes" xml:space="preserve">
          <source>We recommend that actions are created as children of the window they are used in. In most cases actions will be children of the application's main window.</source>
          <target state="translated">조치는 사용되는 창의 하위로 작성하는 것이 좋습니다. 대부분의 경우 조치는 응용 프로그램 기본 창의 하위입니다.</target>
        </trans-unit>
        <trans-unit id="4be62ee58307e6c6e0d2d2579e74cf535a8918ce" translate="yes" xml:space="preserve">
          <source>We recommend that widgets do not cache this value as it may change at any time if the user changes the global desktop settings.</source>
          <target state="translated">사용자가 전역 데스크톱 설정을 변경하면 언제든지 변경 될 수 있으므로 위젯은이 값을 캐시하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3fff2be0c1008c6486d9ae1e414050772e83df67" translate="yes" xml:space="preserve">
          <source>We recommend that you connect clean-up code to the &lt;a href=&quot;qcoreapplication#aboutToQuit&quot;&gt;aboutToQuit()&lt;/a&gt; signal, instead of putting it in your application's &lt;code&gt;main()&lt;/code&gt; function because on some platforms the exec() call may not return. For example, on Windows when the user logs off, the system terminates the process after Qt closes all top-level windows. Hence, there is no guarantee that the application will have time to exit its event loop and execute code at the end of the &lt;code&gt;main()&lt;/code&gt; function after the exec() call.</source>
          <target state="translated">일부 플랫폼에서는 exec () 호출이 반환되지 않을 수 있으므로 정리 코드를 응용 프로그램의 &lt;code&gt;main()&lt;/code&gt; 함수 에 넣지 않고 &lt;a href=&quot;qcoreapplication#aboutToQuit&quot;&gt;aboutToQuit ()&lt;/a&gt; 신호에 연결하는 것이 좋습니다 . 예를 들어, Windows에서 사용자가 로그 오프하면 Qt가 모든 최상위 창을 닫은 후 시스템이 프로세스를 종료합니다. 따라서 exec () 호출 후 응용 프로그램이 이벤트 루프를 종료하고 &lt;code&gt;main()&lt;/code&gt; 함수 끝에서 코드를 실행할 시간이 있다는 보장은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a876acf0bde84a5e74e18d96c6614430e5031b27" translate="yes" xml:space="preserve">
          <source>We recommend that you connect clean-up code to the &lt;a href=&quot;qcoreapplication#aboutToQuit&quot;&gt;aboutToQuit()&lt;/a&gt; signal, instead of putting it in your application's &lt;code&gt;main()&lt;/code&gt; function. This is because, on some platforms the QApplication::exec() call may not return. For example, on the Windows platform, when the user logs off, the system terminates the process after Qt closes all top-level windows. Hence, there is</source>
          <target state="translated">정리 코드를 응용 프로그램의 &lt;code&gt;main()&lt;/code&gt; 함수 에 넣지 않고 &lt;a href=&quot;qcoreapplication#aboutToQuit&quot;&gt;aboutToQuit ()&lt;/a&gt; 신호에 연결하는 것이 좋습니다 . 일부 플랫폼에서는 QApplication :: exec () 호출이 리턴되지 않을 수 있기 때문입니다. 예를 들어, Windows 플랫폼에서 사용자가 로그 오프하면 Qt가 모든 최상위 창을 닫은 후 시스템이 프로세스를 종료합니다. 따라서</target>
        </trans-unit>
        <trans-unit id="363d34ad650f6088ca795957f17c975a74cfb11e" translate="yes" xml:space="preserve">
          <source>We recommend that you connect clean-up code to the &lt;a href=&quot;qcoreapplication#aboutToQuit&quot;&gt;aboutToQuit()&lt;/a&gt; signal, instead of putting it in your application's &lt;code&gt;main()&lt;/code&gt; function. This is because, on some platforms, the &lt;a href=&quot;qapplication#exec&quot;&gt;QApplication::exec&lt;/a&gt;() call may not return.</source>
          <target state="translated">정리 코드를 응용 프로그램의 &lt;code&gt;main()&lt;/code&gt; 함수 에 넣지 않고 &lt;a href=&quot;qcoreapplication#aboutToQuit&quot;&gt;aboutToQuit ()&lt;/a&gt; 신호에 연결하는 것이 좋습니다 . 일부 플랫폼에서는 &lt;a href=&quot;qapplication#exec&quot;&gt;QApplication :: exec&lt;/a&gt; () 호출이 리턴되지 않을 수 있기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="8735a098aa9738ceb9e7bb24c6ccd3a6c7cccaf6" translate="yes" xml:space="preserve">
          <source>We recommend that you simply use &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; instead: The &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; class defines a rectangle in the plane using floating point coordinates for accuracy (&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; uses integer coordinates), and the &lt;a href=&quot;qrectf#right&quot;&gt;QRectF::right&lt;/a&gt;() and &lt;a href=&quot;qrectf#bottom&quot;&gt;QRectF::bottom&lt;/a&gt;() functions</source>
          <target state="translated">&lt;a href=&quot;qrectf&quot;&gt;QRectF를&lt;/a&gt; 대신 사용하는 것이 좋습니다 . &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 클래스는 정확도를 위해 부동 소수점 좌표 ( &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 는 정수 좌표를 사용함), &lt;a href=&quot;qrectf#right&quot;&gt;QRectF :: right&lt;/a&gt; () 및 &lt;a href=&quot;qrectf#bottom&quot;&gt;QRectF :: bottom&lt;/a&gt; () 함수를 사용하여 평면에서 사각형을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="5d9159463f9722b39bd115c71e1e3cd67a948e94" translate="yes" xml:space="preserve">
          <source>We recommend that you use &lt;a href=&quot;qrect#x&quot;&gt;x&lt;/a&gt;() + &lt;a href=&quot;qrect#width&quot;&gt;width&lt;/a&gt;() and &lt;a href=&quot;qrect#y&quot;&gt;y&lt;/a&gt;() + &lt;a href=&quot;qrect#height&quot;&gt;height&lt;/a&gt;() to find the true bottom-right corner, and avoid &lt;a href=&quot;qrect#right&quot;&gt;right&lt;/a&gt;() and &lt;a href=&quot;qrect#bottom&quot;&gt;bottom&lt;/a&gt;(). Another solution is to use &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt;: The &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; class defines a rectangle in the plane using floating point accuracy for coordinates, and the &lt;a href=&quot;qrectf#right&quot;&gt;QRectF::right&lt;/a&gt;() and &lt;a href=&quot;qrectf#bottom&quot;&gt;QRectF::bottom&lt;/a&gt;() functions</source>
          <target state="translated">오른쪽 하단 모서리를 찾아 &lt;a href=&quot;qrect#right&quot;&gt;오른쪽&lt;/a&gt; () 및 &lt;a href=&quot;qrect#bottom&quot;&gt;아래쪽&lt;/a&gt; ()을 피 하려면 &lt;a href=&quot;qrect#x&quot;&gt;x&lt;/a&gt; () + &lt;a href=&quot;qrect#width&quot;&gt;너비&lt;/a&gt; () 및 &lt;a href=&quot;qrect#y&quot;&gt;y&lt;/a&gt; () + &lt;a href=&quot;qrect#height&quot;&gt;높이&lt;/a&gt; ()를 사용하는 것이 좋습니다 . 또 다른 해결책은 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 를 사용하는 것입니다 . &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 클래스는 좌표의 부동 소수점 정확도 및 &lt;a href=&quot;qrectf#right&quot;&gt;QRectF :: right&lt;/a&gt; () 및 &lt;a href=&quot;qrectf#bottom&quot;&gt;QRectF :: bottom&lt;/a&gt; () 함수를 사용하여 평면에서 사각형을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="d2599bef4436f51d4e5d500b4dbae4ddb3f6ffae" translate="yes" xml:space="preserve">
          <source>We recommend that you use the createStandardContextMenu(&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt;) version instead which will enable the actions that are sensitive to where the user clicked.</source>
          <target state="translated">대신 사용자가 클릭 한 위치에 민감한 작업을 활성화 하는 createStandardContextMenu ( &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; ) 버전 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e1b84b8e7214d8fbac571e734ae3fd011fdbdd3b" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt; makefile generation tool for building your makefiles. This tool generates a makefile that does all the necessary &lt;code&gt;moc&lt;/code&gt; handling.</source>
          <target state="translated">makefile을 빌드하기 위해 &lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt; makefile 생성 도구를 사용하는 것이 좋습니다 . 이 도구는 필요한 모든 &lt;code&gt;moc&lt;/code&gt; 처리 를 수행하는 makefile을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="11d5914a38899ecabc6f28a34babf2f610c11691" translate="yes" xml:space="preserve">
          <source>We reset the property to 1, and also call the &lt;code&gt;setFocus()&lt;/code&gt; slot to simulate the user style on Windows, where a button grabs focus when you click it (so that you can click it again with the spacebar).</source>
          <target state="translated">속성을 1로 재설정하고 &lt;code&gt;setFocus()&lt;/code&gt; 슬롯을 호출하여 Windows에서 사용자 스타일을 시뮬레이트합니다. 여기서 버튼을 클릭하면 포커스를 잡고 스페이스 바로 다시 클릭 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ba58731a746f01957250987920180f7283895f3" translate="yes" xml:space="preserve">
          <source>We set the SQL table's name and the edit strategy, then we set up the labels displayed in the view header. The edit strategy dictates when the changes done by the user in the view are actually applied to the database. The possible values are &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnFieldChange&lt;/a&gt;, &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnRowChange&lt;/a&gt;, and &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit&lt;/a&gt;.</source>
          <target state="translated">SQL 테이블의 이름과 편집 전략을 설정 한 다음 뷰 헤더에 표시되는 레이블을 설정합니다. 편집 전략은 뷰에서 사용자가 수행 한 변경 사항이 실제로 데이터베이스에 적용되는 시점을 나타냅니다. 가능한 값은 &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnFieldChange&lt;/a&gt; , &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnRowChange&lt;/a&gt; 및 &lt;a href=&quot;qsqltablemodel#EditStrategy-enum&quot;&gt;OnManualSubmit&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="43d85a09563f7762501a85aaabcaee95656efa4d" translate="yes" xml:space="preserve">
          <source>We set the color of the knob to the same white that we used before.</source>
          <target state="translated">노브의 색상을 이전에 사용한 것과 동일한 흰색으로 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="a6ee2571ce9e1f226f14f924e4640f2a68b9d43d" translate="yes" xml:space="preserve">
          <source>We set the model's query, then we set up the labels displayed in the view header.</source>
          <target state="translated">모델의 쿼리를 설정 한 다음 뷰 헤더에 표시되는 레이블을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7c73685c07450896607e2b5743ab8fd37fc58fa2" translate="yes" xml:space="preserve">
          <source>We set up a &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel&lt;/a&gt; so that it is ready for use, and create some views to display the contents of a directory. This shows the simplest way to use a model. The construction and use of the model is performed from within a single &lt;code&gt;main()&lt;/code&gt; function:</source>
          <target state="translated">사용할 준비가되도록 &lt;a href=&quot;qfilesystemmodel&quot;&gt;QFileSystemModel을&lt;/a&gt; 설정 하고 디렉토리의 내용을 표시하는 뷰를 작성합니다. 모델을 사용하는 가장 간단한 방법을 보여줍니다. 모델의 구성 및 사용은 단일 &lt;code&gt;main()&lt;/code&gt; 함수 내에서 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="02c6bb08be62f95c95355b44dafdb980f1a8611c" translate="yes" xml:space="preserve">
          <source>We show an example:</source>
          <target state="translated">우리는 예를 보여줍니다 :</target>
        </trans-unit>
        <trans-unit id="5402b5b9bc993e98776846f7204ba8d2a16881d6" translate="yes" xml:space="preserve">
          <source>We show an image of a tool box in the Plastique style:</source>
          <target state="translated">Plastique 스타일의 도구 상자 이미지를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b5648ede2b19e6688d33ee53314e77a9d517168a" translate="yes" xml:space="preserve">
          <source>We show an image over a Java style combo box in which we have outlined its sub elements and sub element rectangles:</source>
          <target state="translated">우리는 하위 요소와 하위 요소 사각형을 설명한 Java 스타일 콤보 상자 위에 이미지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="06b266dff182955ddfb693b6f73ecc4ef6c02840" translate="yes" xml:space="preserve">
          <source>We show the size grip in &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;'s bottom right corner.</source>
          <target state="translated">&lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; 의 오른쪽 하단 모서리 에 크기 그립이 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="ccd6e2d3d2506a399e8e13141041014b1d0e5bd6" translate="yes" xml:space="preserve">
          <source>We simply need to return the class name of the single interface our plugin can create an accessible interface for. A plugin can support any number of classes; just add more class names to the string list. We move on to the &lt;code&gt;create()&lt;/code&gt; function:</source>
          <target state="translated">플러그인이 액세스 가능한 인터페이스를 만들 수있는 단일 인터페이스의 클래스 이름 만 반환하면됩니다. 플러그인은 여러 클래스를 지원할 수 있습니다. 문자열 목록에 클래스 이름을 더 추가하십시오. &lt;code&gt;create()&lt;/code&gt; 함수로 넘어갑니다 .</target>
        </trans-unit>
        <trans-unit id="2c39624e55f03668e4a38d91ead282bc2f84d181" translate="yes" xml:space="preserve">
          <source>We start by connecting to the `connected()` signal.</source>
          <target state="translated">우리는`connected ()`신호에 연결하는 것으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="5d321c05d3bfceed912d30efc41c511fcc4483e8" translate="yes" xml:space="preserve">
          <source>We start by creating a &lt;a href=&quot;qwebsocketserver&quot;&gt;QWebSocketServer&lt;/a&gt; (`new QWebSocketServer()`). After the creation, we listen on all local network interfaces (`&lt;a href=&quot;qhostaddress#SpecialAddress-enum&quot;&gt;QHostAddress::Any&lt;/a&gt;`) on the specified</source>
          <target state="translated">&lt;a href=&quot;qwebsocketserver&quot;&gt;QWebSocketServer&lt;/a&gt; (`new QWebSocketServer ()`) 를 생성하는 것으로 시작합니다 . 생성 후 지정된 로컬 네트워크 인터페이스 (` &lt;a href=&quot;qhostaddress#SpecialAddress-enum&quot;&gt;QHostAddress :: Any`&lt;/a&gt; )를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="a497a14a7cf2acf61c8ce0f618c9d8c364543756" translate="yes" xml:space="preserve">
          <source>We start with a look at how &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; builds its style option, which is &lt;a href=&quot;qstyleoptionbutton&quot;&gt;QStyleOptionButton&lt;/a&gt; for checkboxes:</source>
          <target state="translated">우리는 방법에 대해 살펴 시작 &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox은&lt;/a&gt; 자사의 스타일 옵션, 빌드 &lt;a href=&quot;qstyleoptionbutton&quot;&gt;QStyleOptionButton을&lt;/a&gt; 체크 박스를 들어 :</target>
        </trans-unit>
        <trans-unit id="aa0e0d220b4b12f08bb6b7f6f1a8cebb51d067e6" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you use the default palette of the current style (returned by &lt;a href=&quot;qguiapplication#palette&quot;&gt;QGuiApplication::palette&lt;/a&gt;()) and modify that as necessary. This is done by Qt's widgets when they are drawn.</source>
          <target state="translated">현재 스타일의 기본 팔레트 ( &lt;a href=&quot;qguiapplication#palette&quot;&gt;QGuiApplication :: palette&lt;/a&gt; ()에서 반환 )를 사용하고 필요에 따라 수정하는 것이 좋습니다. 이것은 Qt의 위젯이 그려 질 때 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="d300d8e5a958a2559e4a4bd8db8848789d04b082" translate="yes" xml:space="preserve">
          <source>We subclass the delegate from &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; because we do not want to write custom display functions. However, we must still provide functions to manage the editor widget:</source>
          <target state="translated">커스텀 디스플레이 함수를 작성하고 싶지 않기 때문에 &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; 에서 델리게이트를 서브 클래 싱합니다 . 그러나 여전히 편집기 위젯을 관리하는 기능을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c6d2f84d65277109aae35df0700529cc358b168" translate="yes" xml:space="preserve">
          <source>We suggest only using repaint() if you need an immediate repaint, for example during animation. In almost all circumstances &lt;a href=&quot;qwidget#update&quot;&gt;update&lt;/a&gt;() is better, as it permits Qt to optimize for speed and minimize flicker.</source>
          <target state="translated">애니메이션과 같이 즉시 다시 페인트해야하는 경우 repaint () 만 사용하는 것이 좋습니다. 거의 모든 상황에서 &lt;a href=&quot;qwidget#update&quot;&gt;업데이트&lt;/a&gt; ()는 Qt가 속도를 최적화하고 깜박임을 최소화 할 수 있기 때문에 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="231ff3c2c5d46c0ea88903540f5485031a804b17" translate="yes" xml:space="preserve">
          <source>We suggest that you only use this class in stable code where profiling has clearly identified that performance improvements can be made by replacing standard string operations with the optimized substring handling provided by this class.</source>
          <target state="translated">프로파일 링에서 표준 문자열 연산을이 클래스에서 제공하는 최적화 된 하위 문자열 처리로 대체하여 성능을 향상시킬 수 있음을 명확하게 식별 한 안정적인 코드에서만이 클래스를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4fa1a26948c719f9149dccb91279491623c52ae9" translate="yes" xml:space="preserve">
          <source>We suggest using a forward-only query when calling stored procedures in DB2 (see &lt;a href=&quot;qsqlquery#setForwardOnly&quot;&gt;QSqlQuery::setForwardOnly&lt;/a&gt;()).</source>
          <target state="translated">DB2에서 스토어드 프로 시저를 호출 할 때 정방향 조회를 사용하는 것이 좋습니다 ( &lt;a href=&quot;qsqlquery#setForwardOnly&quot;&gt;QSqlQuery :: setForwardOnly&lt;/a&gt; () 참조).</target>
        </trans-unit>
        <trans-unit id="e975305feef4b668f5ae97628e067e8fff9ce7f6" translate="yes" xml:space="preserve">
          <source>We take the string list model that &lt;a href=&quot;#creating-new-models&quot;&gt;we created as an example model&lt;/a&gt;, set it up with some data, and construct a view to display the contents of the model. This can all be performed within a single function:</source>
          <target state="translated">우리 &lt;a href=&quot;#creating-new-models&quot;&gt;는 예제 모델로 만든&lt;/a&gt; 문자열 목록 모델을 가져 와서 일부 데이터로 설정하고 모델의 내용을 표시하는 뷰를 구성합니다. 이것은 모두 단일 기능 내에서 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3b08c7fa93f3fb2c8f15bf634f70039876a38af" translate="yes" xml:space="preserve">
          <source>We then copy &lt;code&gt;Button.qml&lt;/code&gt; from the Default style in &lt;code&gt;$QTDIR/qml/QtQuick/Controls.2/&lt;/code&gt; into a new &lt;code&gt;myproject&lt;/code&gt; folder in our project directory. Add the newly copied &lt;code&gt;Button.qml&lt;/code&gt; to &lt;code&gt;qml.qrc&lt;/code&gt;, which is the resource file that contains our QML files.</source>
          <target state="translated">우리는 다음 복사 &lt;code&gt;Button.qml&lt;/code&gt; 을 에서 기본 스타일에서 &lt;code&gt;$QTDIR/qml/QtQuick/Controls.2/&lt;/code&gt; 에 새 &lt;code&gt;myproject&lt;/code&gt; 라는 우리의 프로젝트 디렉토리에 폴더. 새로 복사 추가 &lt;code&gt;Button.qml&lt;/code&gt; 에 &lt;code&gt;qml.qrc&lt;/code&gt; 우리 QML 파일이 포함 된 리소스 파일입니다.</target>
        </trans-unit>
        <trans-unit id="9ddfc9b7a77f7a110978e2b4a71cd379b9278608" translate="yes" xml:space="preserve">
          <source>We translate the coordinate system so that point (0, 0) is in the widget's center, instead of being at the top-left corner. We also scale the system by &lt;code&gt;side&lt;/code&gt; / 100, where &lt;code&gt;side&lt;/code&gt; is either the widget's width or the height, whichever is shortest. We want the clock to be square, even if the device isn't.</source>
          <target state="translated">좌표계를 변환하여 점 (0, 0)이 왼쪽 상단이 아닌 위젯 중심에 오도록합니다. 또한 &lt;code&gt;side&lt;/code&gt; / 100을 기준으로 시스템의 크기를 조정합니다 . 여기서 &lt;code&gt;side&lt;/code&gt; 는 위젯의 너비 또는 높이 중 가장 짧은 쪽입니다. 장치가 아니더라도 시계가 정사각형이되기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="ba7115a587e529a701a8ef0581cb4749af6e6545" translate="yes" xml:space="preserve">
          <source>We unpack the image from the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; held by the MIME source and insert it into the document as a resource.</source>
          <target state="translated">MIME 소스가 보유한 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 에서 이미지의 압축을 풀고 문서에 리소스로 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="6702c84f9f593c4966ed24556d4e614a95a5b081" translate="yes" xml:space="preserve">
          <source>We use &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt;'s system to enable signal and slot connections:</source>
          <target state="translated">우리는 &lt;a href=&quot;qmetaobject&quot;&gt;QMetaObject&lt;/a&gt; 시스템을 사용하여 신호 및 슬롯 연결을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ba8aa43a34f113e8d51062b7a92d6c16d9756970" translate="yes" xml:space="preserve">
          <source>We want the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; nodes we create in the output to be in the standard XHTML namespace, so we declare the default namespace to be &lt;code&gt;http://www.w3.org/1999/xhtml&lt;/code&gt;. That's correct for the output, but that same default namespace will also be applied to the node names in the path expression we're trying to match in the input (&lt;code&gt;/tests/test[@status = &quot;failure&quot;]&lt;/code&gt;), which is wrong, because the namespace used in &lt;code&gt;testResult.xml&lt;/code&gt; is perhaps in the empty namespace. So we must declare that namespace too, with a namespace prefix, and then use the prefix with the node names in the path expression. This one will probably work better:</source>
          <target state="translated">출력에서 만든 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 노드가 표준 XHTML 네임 스페이스에 있기를 원하므로 기본 네임 스페이스를 &lt;code&gt;http://www.w3.org/1999/xhtml&lt;/code&gt; 로 선언합니다 . . 출력에는 맞지만 입력에서 일치시키려는 경로 표현식의 노드 이름에도 동일한 기본 네임 스페이스가 적용됩니다 ( &lt;code&gt;/tests/test[@status = &quot;failure&quot;]&lt;/code&gt; ). &lt;code&gt;testResult.xml&lt;/code&gt; 에 사용 된 네임 스페이스가 비어있는 네임 스페이스에있을 수 있기 때문 입니다. 따라서 네임 스페이스 접두사를 사용하여 해당 네임 스페이스도 선언 한 다음 경로 식에서 노드 이름과 함께 접두사를 사용해야합니다. 이것은 아마도 더 잘 작동 할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="4f1b5e3a93b1d9e7d28bf6a110f1a7d7f3adcda3" translate="yes" xml:space="preserve">
          <source>We want the button to do something in C++ when it is clicked. We know objects in QML can emit change signals just like they can in C++, so we give the button an &lt;a href=&quot;qml-qtqml-qtobject#objectName-prop&quot;&gt;objectName&lt;/a&gt; so that we can find it from C++:</source>
          <target state="translated">버튼을 클릭했을 때 C ++에서 버튼이 작동하기를 원합니다. QML의 객체는 C ++에서와 마찬가지로 변경 신호를 방출 할 수 있으므로 버튼에 &lt;a href=&quot;qml-qtqml-qtobject#objectName-prop&quot;&gt;objectName을&lt;/a&gt; 지정하여 C ++에서 찾을 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="76e6ab0239065e2e638f25201b476daf0bcd47ca" translate="yes" xml:space="preserve">
          <source>We want the first &lt;code&gt;MyWidget&lt;/code&gt; object to have the focus, so we set its &lt;code&gt;focus&lt;/code&gt; property to &lt;code&gt;true&lt;/code&gt;. However, by running the code, we can confirm that the second widget receives the focus.</source>
          <target state="translated">첫 번째 &lt;code&gt;MyWidget&lt;/code&gt; 객체가 포커스를 갖기를 원하므로 &lt;code&gt;focus&lt;/code&gt; 속성을 &lt;code&gt;true&lt;/code&gt; 로 설정 합니다 . 그러나 코드를 실행하면 두 번째 위젯이 포커스를 받는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b84db86530609eef16fd85299c419ab944a2147" translate="yes" xml:space="preserve">
          <source>We want the number of rows in the model to be the same as the number of strings in the string list. We implement the &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount()&lt;/a&gt; function with this in mind:</source>
          <target state="translated">모델의 행 수는 문자열 목록의 문자열 수와 같기를 원합니다. 이를 염두에두고 &lt;a href=&quot;qabstractitemmodel#rowCount&quot;&gt;rowCount ()&lt;/a&gt; 함수를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="04444172f0395edd2c58b3f9c46f2e88a8178690" translate="yes" xml:space="preserve">
          <source>We will also implement an event handler for the &lt;code&gt;clicked&lt;/code&gt; signal emitted by &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt;. Add the event handler &lt;code&gt;resetLineWidth&lt;/code&gt; to the &lt;code&gt;clicked&lt;/code&gt; event, and implement the generated function:</source>
          <target state="translated">우리는 또한 &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton에&lt;/a&gt; 의해 방출 된 &lt;code&gt;clicked&lt;/code&gt; 신호에 대한 이벤트 핸들러를 구현할 것 입니다. 이벤트 핸들러 추가 &lt;code&gt;resetLineWidth&lt;/code&gt; 을 받는 &lt;code&gt;clicked&lt;/code&gt; 이벤트 및 생성 기능을 구현 :</target>
        </trans-unit>
        <trans-unit id="fe26cfd4b7c0e274d37e6ad076164fcd0bb38ec0" translate="yes" xml:space="preserve">
          <source>We will demonstrate the flexibility of the framegraph concept by presenting a few examples and the resulting framegraphs.</source>
          <target state="translated">우리는 몇 가지 예와 결과 프레임 그래프를 제시하여 프레임 그래프 개념의 유연성을 보여줄 것입니다.</target>
        </trans-unit>
        <trans-unit id="a975a2165ab3f49a74c5fcbda8dd399f508b0107" translate="yes" xml:space="preserve">
          <source>We will focus on the Qt accessibility interface &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; and how to make applications accessible.</source>
          <target state="translated">우리는 Qt 접근성 인터페이스 &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; 와 응용 프로그램에 접근하는 방법 에 중점을 둘 것 입니다.</target>
        </trans-unit>
        <trans-unit id="817a5a25e73bd282d9a86c86e09bc026b74379d0" translate="yes" xml:space="preserve">
          <source>We will go through the implementation of &lt;code&gt;SliderPlugin&lt;/code&gt;, which is an accessible plugin that produces the QAccessibleSlider interface from the &lt;a href=&quot;#qaccessiblewidget-example&quot;&gt;QAccessibleWidget Example&lt;/a&gt;. We start with the &lt;code&gt;key()&lt;/code&gt; function:</source>
          <target state="translated">&lt;a href=&quot;#qaccessiblewidget-example&quot;&gt;QAccessibleWidget 예제&lt;/a&gt; 에서 QAccessibleSlider 인터페이스를 생성하는 액세스 가능한 플러그인 인 &lt;code&gt;SliderPlugin&lt;/code&gt; 구현을 살펴 보겠습니다 . 우리는 &lt;code&gt;key()&lt;/code&gt; 함수로 시작 합니다 :</target>
        </trans-unit>
        <trans-unit id="a1f504c48e7d906777695a3518cbad888a6eb480" translate="yes" xml:space="preserve">
          <source>We will now examine each of the other widgets that can be added to a main window. We give examples on how to create and add them.</source>
          <target state="translated">이제 기본 창에 추가 할 수있는 다른 위젯을 각각 살펴 보겠습니다. 작성하고 추가하는 방법에 대한 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3033ee3ae85cfb9b54305fe3eaf0f54fbdf82148" translate="yes" xml:space="preserve">
          <source>We will now examine the style option for push buttons - &lt;a href=&quot;qstyleoptionbutton&quot;&gt;QStyleOptionButton&lt;/a&gt;. A table for the states that &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; can set on the style option follows:</source>
          <target state="translated">이제 푸시 버튼의 스타일 옵션 ( &lt;a href=&quot;qstyleoptionbutton&quot;&gt;QStyleOptionButton)을 살펴 보겠습니다&lt;/a&gt; . &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; 이 스타일 옵션에서 설정할 수 있는 상태에 대한 테이블은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c093c0a628afe0d59b2cfe63a947dce0fbaee0bf" translate="yes" xml:space="preserve">
          <source>We will now implement event handlers for the widgets. Select the &lt;code&gt;circleWidget&lt;/code&gt; and select the &quot;Events&quot; page in the property editor. The widget exposes events because the QAxWidget2 class has the &quot;StockEvents&quot; attribute set in its class definition. We implement the event handler &lt;code&gt;circleClicked&lt;/code&gt; for the &lt;code&gt;ClickEvent&lt;/code&gt; to increase the line width by one for every click:</source>
          <target state="translated">이제 위젯에 대한 이벤트 핸들러를 구현할 것입니다. 선택 &lt;code&gt;circleWidget&lt;/code&gt; 을 하고 속성 편집기에서 &quot;이벤트&quot;페이지를 선택합니다. QAxWidget2 클래스의 클래스 정의에 &quot;StockEvents&quot;속성이 설정되어 있으므로 위젯이 이벤트를 노출합니다. 우리는 이벤트 핸들러 구현 &lt;code&gt;circleClicked&lt;/code&gt; 에 대한 &lt;code&gt;ClickEvent&lt;/code&gt; 모든 클릭에 대해 하나 선 두께를 증가 :</target>
        </trans-unit>
        <trans-unit id="8494feec9f0c9cd3eebfc207ae8aff3456a8b9a9" translate="yes" xml:space="preserve">
          <source>We will soon see how to construct our first simple framegraph but before that we will introduce the framegraph nodes available to you. Also as with the Scenegraph tree, the QML and C++ APIs are a 1 to 1 match so you can favor the one you like best. For the sake of readability and conciseness, the QML API was chosen for this article.</source>
          <target state="translated">우리는 곧 첫 번째 간단한 프레임 그래프를 구성하는 방법을 보게 될 것입니다. 그러나 그 전에는 사용할 수있는 프레임 그래프 노드를 소개 할 것입니다. 또한 장면 그래프 트리와 마찬가지로 QML 및 C ++ API는 일대일로 일치하므로 가장 좋아하는 것을 선호 할 수 있습니다. 가독성과 간결성을 위해이 기사에서는 QML API를 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="b33d6ad08e06cb51eafa7a1fbd72d77aa02efa7d" translate="yes" xml:space="preserve">
          <source>We will use &lt;code&gt;qmake&lt;/code&gt; to build the executable, so we need to write a &lt;code&gt;.pro&lt;/code&gt; file:</source>
          <target state="translated">우리는 사용 &lt;code&gt;qmake&lt;/code&gt; 를을 우리가 작성해야하므로, 실행 파일을 구축 할 &lt;code&gt;.pro&lt;/code&gt; 파일 :</target>
        </trans-unit>
        <trans-unit id="742741817849b3e4883e222e4dd1dcb5e67a5572" translate="yes" xml:space="preserve">
          <source>We would like to validate the input with this regular expression</source>
          <target state="translated">이 정규 표현식으로 입력을 확인하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="2d6d212a7dfdbab23c13897756fa6f2acd558d0a" translate="yes" xml:space="preserve">
          <source>We'll choose options 1 and 3, as they are more flexible than using an image.</source>
          <target state="translated">옵션 1과 3은 이미지를 사용하는 것보다 융통성이 있으므로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="fcf246de9f4cf8cb7b13094da773d9b01e23ca5d" translate="yes" xml:space="preserve">
          <source>We'll display the range that indicates caution with an orange arc:</source>
          <target state="translated">주황색 원호로주의를 나타내는 범위를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d2ebe03d1ec0aaa652b91a007ddf1889092f229a" translate="yes" xml:space="preserve">
          <source>We'll now take a look at the Java implementation of CE_CheckBoxIndicator in &lt;code&gt;drawControl()&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;drawControl()&lt;/code&gt; 에서 CE_CheckBoxIndicator 의 Java 구현을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="83d3a48d85ff1c4641608d505ba31ba41996686f" translate="yes" xml:space="preserve">
          <source>We've now changed the needle, but the default knob is still there; let's replace it. The &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle#foreground-prop&quot;&gt;foreground&lt;/a&gt; component defines the default knob, so we can specify our own by overriding it (note that we could also set it to &lt;code&gt;null&lt;/code&gt; if we didn't want a foreground):</source>
          <target state="translated">우리는 이제 바늘을 바꾸었지만 기본 손잡이는 여전히 있습니다. 교체합시다. &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle#foreground-prop&quot;&gt;전경&lt;/a&gt; 우리가 (우리는 또한 그것을 설정할 수 있습니다를 재정 의하여 우리 자신을 지정할 수 있도록 구성 요소는 기본 노브를 정의 &lt;code&gt;null&lt;/code&gt; 우리는 전경을하지 않은 경우) :</target>
        </trans-unit>
        <trans-unit id="efe4ed4659e96cae0221357878685ccb209e3a9e" translate="yes" xml:space="preserve">
          <source>We've replaced the conventional</source>
          <target state="translated">우리는 기존의</target>
        </trans-unit>
        <trans-unit id="91104111351164bbe558f23229d399ff5052c452" translate="yes" xml:space="preserve">
          <source>We've used the &lt;a href=&quot;qregexp#indexIn&quot;&gt;indexIn&lt;/a&gt;() function to repeatedly match the regexp in the string. Note that instead of moving forward by one character at a time &lt;code&gt;pos++&lt;/code&gt; we could have written &lt;code&gt;pos += rx.matchedLength()&lt;/code&gt; to skip over the already matched string. The count will equal 3, matching 'One &lt;u&gt;Eric&lt;/u&gt; another &lt;u&gt;Eirik&lt;/u&gt;, and an Ericsson. How many Eiriks, &lt;u&gt;Eric&lt;/u&gt;?'; it doesn't match 'Ericsson' or 'Eiriks' because they are not bounded by non-word boundaries.</source>
          <target state="translated">우리는 &lt;a href=&quot;qregexp#indexIn&quot;&gt;indexIn&lt;/a&gt; () 함수를 사용 하여 문자열의 정규 표현식을 반복적으로 일치시킵니다. &lt;code&gt;pos++&lt;/code&gt; 에서 한 문자 씩 앞으로 이동하는 대신 &lt;code&gt;pos += rx.matchedLength()&lt;/code&gt; 를 작성 하여 이미 일치하는 문자열을 건너 뛸 수 있습니다. 카운트가 '일치 한 3 같을 것이다 &lt;u&gt;에릭&lt;/u&gt; 다른 &lt;u&gt;에이 릭&lt;/u&gt; , 그리고 에릭슨. 얼마나 많은 Eiriks, &lt;u&gt;에릭&lt;/u&gt; ? '; '에릭슨'또는 '에릭스'와 일치하지 않습니다. 단어 경계가 아닌 경계에 묶이지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6279a80821249cab2332a0d932a3e191da10ddc9" translate="yes" xml:space="preserve">
          <source>WeakMap</source>
          <target state="translated">WeakMap</target>
        </trans-unit>
        <trans-unit id="9f48b9d4c39134a88b6b1b3ddc4feab4fccf55c5" translate="yes" xml:space="preserve">
          <source>WeakSet</source>
          <target state="translated">WeakSet</target>
        </trans-unit>
        <trans-unit id="ab20c91b52c6b3395709cda0ed8f5171e24c5c60" translate="yes" xml:space="preserve">
          <source>Wearable Demo</source>
          <target state="translated">웨어러블 데모</target>
        </trans-unit>
        <trans-unit id="284af3e8882bbc45760521be2f100a2d104ff5d8" translate="yes" xml:space="preserve">
          <source>Weather</source>
          <target state="translated">Weather</target>
        </trans-unit>
        <trans-unit id="cb2c23b46c498ad3111ef3d9331c1a2842333d4f" translate="yes" xml:space="preserve">
          <source>Weather Info (C++/QML)</source>
          <target state="translated">날씨 정보 (C ++ / QML)</target>
        </trans-unit>
        <trans-unit id="e23aaa085b681c21761fb11248617eabf695baf0" translate="yes" xml:space="preserve">
          <source>Web Notifications</source>
          <target state="translated">웹 알림</target>
        </trans-unit>
        <trans-unit id="4b714adfb96a60c16c6ae25ae0fe3509edc8dec1" translate="yes" xml:space="preserve">
          <source>Web Page Downloads</source>
          <target state="translated">웹 페이지 다운로드</target>
        </trans-unit>
        <trans-unit id="773f6d516e9f04534328298b39954666fb6764cc" translate="yes" xml:space="preserve">
          <source>Web browsers usually encode spaces found in HTML FORM elements to a plus sign (&quot;+&quot;) and plus signs to its percent-encoded form (%2B). However, the Internet specifications governing URLs do not consider spaces and the plus character equivalent.</source>
          <target state="translated">웹 브라우저는 일반적으로 HTML FORM 요소에서 찾은 공백을 더하기 부호 ( &quot;+&quot;)로, 더하기 부호는 퍼센트 인코딩 형식 (% 2B)으로 인코딩합니다. 그러나 URL을 관리하는 인터넷 사양에서는 공백과 더하기 문자를 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca4ad7507c2b9c2e1f2d04084ecd062596c650c5" translate="yes" xml:space="preserve">
          <source>Web engine notifications are passed to the user in the &lt;a href=&quot;qwebengineprofile#setNotificationPresenter&quot;&gt;QWebEngineProfile::setNotificationPresenter&lt;/a&gt;() and &lt;a href=&quot;qquickwebengineprofile#presentNotification&quot;&gt;QQuickWebEngineProfile::presentNotification&lt;/a&gt;() calls and the &lt;a href=&quot;qml-qtwebengine-webengineprofile#presentNotification-signal&quot;&gt;WebEngineProfile::presentNotification&lt;/a&gt;() signal.</source>
          <target state="translated">웹 엔진 알림이있는 사용자에게 전달되는 &lt;a href=&quot;qwebengineprofile#setNotificationPresenter&quot;&gt;QWebEngineProfile :: setNotificationPresenter&lt;/a&gt; ()와 &lt;a href=&quot;qquickwebengineprofile#presentNotification&quot;&gt;QQuickWebEngineProfile :: presentNotification&lt;/a&gt; ()를 호출하고 &lt;a href=&quot;qml-qtwebengine-webengineprofile#presentNotification-signal&quot;&gt;WebEngineProfile :: presentNotification&lt;/a&gt; () 신호를.</target>
        </trans-unit>
        <trans-unit id="17e7758e0d04e82d68c8b66a939a8fc600ba0ce2" translate="yes" xml:space="preserve">
          <source>Web engine views can be isolated from each other by using the &lt;a href=&quot;qml-qtwebengine-webengineprofile&quot;&gt;WebEngineProfile&lt;/a&gt; type. A profile contains settings, scripts, and the list of visited links shared by all views that belong to the profile. For example, a dedicated profile could be created for a</source>
          <target state="translated">&lt;a href=&quot;qml-qtwebengine-webengineprofile&quot;&gt;WebEngineProfile&lt;/a&gt; 유형 을 사용하여 웹 엔진보기를 서로 분리 할 수 ​​있습니다 . 프로필에는 설정, 스크립트 및 프로필에 속한 모든보기가 공유하는 방문한 링크 목록이 포함됩니다. 예를 들어 전용 프로필을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dde01aa10bc79235ecfaa6217ac2c98b9269cba0" translate="yes" xml:space="preserve">
          <source>Web notifications for the end-user.</source>
          <target state="translated">최종 사용자를위한 웹 알림.</target>
        </trans-unit>
        <trans-unit id="9463a2ebae1f28cb0326c4fc23a598a8146a368f" translate="yes" xml:space="preserve">
          <source>Web pages can request access to platform features, such as geolocation or audio and video capture devices. The &lt;a href=&quot;qml-qtwebengine-webengineview#featurePermissionRequested-signal&quot;&gt;featurePermissionRequested()&lt;/a&gt; signal is emitted when a web page requests to make use of a resource. The supported platform features are described by the &lt;a href=&quot;qml-qtwebengine-webengineview#Feature-prop&quot;&gt;Feature&lt;/a&gt; property. If users grant the permission, the &lt;a href=&quot;qml-qtwebengine-webengineview#grantFeaturePermission-method&quot;&gt;grantFeaturePermission()&lt;/a&gt; method is used to set it to</source>
          <target state="translated">웹 페이지는 지리적 위치 또는 오디오 및 비디오 캡처 장치와 같은 플랫폼 기능에 대한 액세스를 요청할 수 있습니다. &lt;a href=&quot;qml-qtwebengine-webengineview#featurePermissionRequested-signal&quot;&gt;featurePermissionRequested ()&lt;/a&gt; 웹 페이지가 자원을 사용하도록 요청할 때 신호가 방출된다. 지원되는 플랫폼 기능은 &lt;a href=&quot;qml-qtwebengine-webengineview#Feature-prop&quot;&gt;Feature&lt;/a&gt; 속성에 설명되어 있습니다. 사용자가 권한을 부여하면 &lt;a href=&quot;qml-qtwebengine-webengineview#grantFeaturePermission-method&quot;&gt;grantFeaturePermission ()&lt;/a&gt; 메소드를 사용 하여 권한 을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6bf04b6dbe5f0a11bb482907c1a79957319ebd91" translate="yes" xml:space="preserve">
          <source>Web sites define</source>
          <target state="translated">웹 사이트는 정의</target>
        </trans-unit>
        <trans-unit id="049620e675bb4f980c04ddae257b90b546509993" translate="yes" xml:space="preserve">
          <source>WebAction : &lt;a href=&quot;qml-enumeration&quot;&gt;enumeration&lt;/a&gt;</source>
          <target state="translated">WebAction : &lt;a href=&quot;qml-enumeration&quot;&gt;열거&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b635c3761f86dca41114981dabf9fe4c1bc93606" translate="yes" xml:space="preserve">
          <source>WebChannel (QML type)</source>
          <target state="translated">WebChannel (QML 유형)</target>
        </trans-unit>
        <trans-unit id="fed4dd033dd4a694f8f5cf71aca31fee6163a6fd" translate="yes" xml:space="preserve">
          <source>WebChannel QML Type</source>
          <target state="translated">WebChannel QML 유형</target>
        </trans-unit>
        <trans-unit id="2a01d9d856283e6cae854a3d5a6d628d7079617f" translate="yes" xml:space="preserve">
          <source>WebChannel.WebChannel.id</source>
          <target state="translated">WebChannel.WebChannel.id</target>
        </trans-unit>
        <trans-unit id="5d3c7030e75f697f09983ed2a4f06ffde88832fe" translate="yes" xml:space="preserve">
          <source>WebChannel.connectTo()</source>
          <target state="translated">WebChannel.connectTo()</target>
        </trans-unit>
        <trans-unit id="9aa6f6d163158c256eaf3f04fe636535bf770a52" translate="yes" xml:space="preserve">
          <source>WebChannel.disconnectFrom()</source>
          <target state="translated">WebChannel.disconnectFrom()</target>
        </trans-unit>
        <trans-unit id="6bdf0c3e2155d9a9aafef29104a7e4216adc7f13" translate="yes" xml:space="preserve">
          <source>WebChannel.id : QString</source>
          <target state="translated">WebChannel.id : QString</target>
        </trans-unit>
        <trans-unit id="277ec41f57f5494feedfd01223e186bb3547a4f3" translate="yes" xml:space="preserve">
          <source>WebChannel.registerObjects()</source>
          <target state="translated">WebChannel.registerObjects()</target>
        </trans-unit>
        <trans-unit id="354fcb03a3ba4bd8657f338ca2900166cf397130" translate="yes" xml:space="preserve">
          <source>WebChannel.registeredObjects</source>
          <target state="translated">WebChannel.registeredObjects</target>
        </trans-unit>
        <trans-unit id="1d036d99a8eb0cecb5e84476d8e047e00d04a165" translate="yes" xml:space="preserve">
          <source>WebChannel.transports</source>
          <target state="translated">WebChannel.transports</target>
        </trans-unit>
        <trans-unit id="beb346307f932e846c7855d1e4a05fe8ac20bd5e" translate="yes" xml:space="preserve">
          <source>WebEngine (QML type)</source>
          <target state="translated">WebEngine (QML 유형)</target>
        </trans-unit>
        <trans-unit id="98cef6da5e975da2895314c46f3d70c0c5c8a8e5" translate="yes" xml:space="preserve">
          <source>WebEngine QML Type</source>
          <target state="translated">WebEngine QML 유형</target>
        </trans-unit>
        <trans-unit id="a43c71604b296c60d52ad8c6b3c273af4d1aa694" translate="yes" xml:space="preserve">
          <source>WebEngine.defaultProfile</source>
          <target state="translated">WebEngine.defaultProfile</target>
        </trans-unit>
        <trans-unit id="d5f3b779f5ca140b6cbea3d836885bab56d597c5" translate="yes" xml:space="preserve">
          <source>WebEngine.settings</source>
          <target state="translated">WebEngine.settings</target>
        </trans-unit>
        <trans-unit id="dd58e3c828708935c590efa36445ce31ece0d6ab" translate="yes" xml:space="preserve">
          <source>WebEngineAction (QML type)</source>
          <target state="translated">WebEngineAction (QML 유형)</target>
        </trans-unit>
        <trans-unit id="73f834d73a6c5a3e525fa956e1e553adfdf96bc4" translate="yes" xml:space="preserve">
          <source>WebEngineAction &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtwebengine-webengineview#action-method&quot;&gt;action&lt;/a&gt;&lt;/b&gt;&lt;/b&gt;(</source>
          <target state="translated">WebEngineAction &lt;b&gt;&lt;b&gt;&lt;a href=&quot;qml-qtwebengine-webengineview#action-method&quot;&gt;조치&lt;/a&gt;&lt;/b&gt;&lt;/b&gt; (</target>
        </trans-unit>
        <trans-unit id="c1e7dc08ec18ee2a4ea7f69f92743dafa62d80a9" translate="yes" xml:space="preserve">
          <source>WebEngineAction QML Type</source>
          <target state="translated">WebEngineAction QML 유형</target>
        </trans-unit>
        <trans-unit id="88562a6c283fbd6e498ddb0cfa61ff0c75f8eb5c" translate="yes" xml:space="preserve">
          <source>WebEngineAction.enabled</source>
          <target state="translated">WebEngineAction.enabled</target>
        </trans-unit>
        <trans-unit id="bb7a5dde35c60f14c4305cddfddc2691208c6e86" translate="yes" xml:space="preserve">
          <source>WebEngineAction.iconName</source>
          <target state="translated">WebEngineAction.iconName</target>
        </trans-unit>
        <trans-unit id="616b5f3c588a01c1d005d7d81fca17f31de79113" translate="yes" xml:space="preserve">
          <source>WebEngineAction.text</source>
          <target state="translated">WebEngineAction.text</target>
        </trans-unit>
        <trans-unit id="e96db3d16470d8661f2e39862370a288cee9c04e" translate="yes" xml:space="preserve">
          <source>WebEngineAction.trigger()</source>
          <target state="translated">WebEngineAction.trigger()</target>
        </trans-unit>
        <trans-unit id="3ce6998eb134f0b6d91c2973b09f629137e6eefa" translate="yes" xml:space="preserve">
          <source>WebEngineCertificateError (QML type)</source>
          <target state="translated">WebEngineCertificateError (QML 유형)</target>
        </trans-unit>
        <trans-unit id="742e921cd235d97d79337df879d1ac2530256944" translate="yes" xml:space="preserve">
          <source>WebEngineCertificateError QML Type</source>
          <target state="translated">WebEngineCertificateError QML 유형</target>
        </trans-unit>
        <trans-unit id="203a67f2ed47637cd77fe953dc3bb0a444ed6360" translate="yes" xml:space="preserve">
          <source>WebEngineCertificateError.defer()</source>
          <target state="translated">WebEngineCertificateError.defer()</target>
        </trans-unit>
        <trans-unit id="ca8b26aebaea727489b5f3bd3f04e50821402a12" translate="yes" xml:space="preserve">
          <source>WebEngineCertificateError.description</source>
          <target state="translated">WebEngineCertificateError.description</target>
        </trans-unit>
        <trans-unit id="249a4cd98582d035a68f7486bf1870d908c18961" translate="yes" xml:space="preserve">
          <source>WebEngineCertificateError.error</source>
          <target state="translated">WebEngineCertificateError.error</target>
        </trans-unit>
        <trans-unit id="381bbbd18fce5bd59bdb9672fc6071fc0d740d2b" translate="yes" xml:space="preserve">
          <source>WebEngineCertificateError.ignoreCertificateError()</source>
          <target state="translated">WebEngineCertificateError.ignoreCertificateError()</target>
        </trans-unit>
        <trans-unit id="a76d8d0457e072ddda631c2dddc503eda8661a96" translate="yes" xml:space="preserve">
          <source>WebEngineCertificateError.overridable</source>
          <target state="translated">WebEngineCertificateError.overridable</target>
        </trans-unit>
        <trans-unit id="51d371a8d6f8e21063be021287748c6866cd77ae" translate="yes" xml:space="preserve">
          <source>WebEngineCertificateError.rejectCertificate()</source>
          <target state="translated">WebEngineCertificateError.rejectCertificate()</target>
        </trans-unit>
        <trans-unit id="cd691ac579d7c18ce775a7963ba2357e01d7c77a" translate="yes" xml:space="preserve">
          <source>WebEngineCertificateError.url</source>
          <target state="translated">WebEngineCertificateError.url</target>
        </trans-unit>
        <trans-unit id="97afa6eb0616ad6112e36db1d1101e5a4db9a6f3" translate="yes" xml:space="preserve">
          <source>WebEngineClientCertificateOption (QML type)</source>
          <target state="translated">WebEngineClientCertificateOption (QML 유형)</target>
        </trans-unit>
        <trans-unit id="0ca13a20b0408814d0cb91473ddfbe5ce5e0edbb" translate="yes" xml:space="preserve">
          <source>WebEngineClientCertificateOption QML Type</source>
          <target state="translated">WebEngineClientCertificateOption QML 유형</target>
        </trans-unit>
        <trans-unit id="1ccff0ae0d85c9e6205706e65ea4cc41de8b937f" translate="yes" xml:space="preserve">
          <source>WebEngineClientCertificateOption.effectiveDate</source>
          <target state="translated">WebEngineClientCertificateOption.effectiveDate</target>
        </trans-unit>
        <trans-unit id="b8830d76722a9395fcca365d29a13cc948b02569" translate="yes" xml:space="preserve">
          <source>WebEngineClientCertificateOption.expiryDate</source>
          <target state="translated">WebEngineClientCertificateOption.expiryDate</target>
        </trans-unit>
        <trans-unit id="766c70111b9fed77cac41a78429833ebe19266ce" translate="yes" xml:space="preserve">
          <source>WebEngineClientCertificateOption.isSelfSigned</source>
          <target state="translated">WebEngineClientCertificateOption.isSelfSigned</target>
        </trans-unit>
        <trans-unit id="c06ac61e33ff1eda01e80ce36b07fa28b2907823" translate="yes" xml:space="preserve">
          <source>WebEngineClientCertificateOption.issuer</source>
          <target state="translated">WebEngineClientCertificateOption.issuer</target>
        </trans-unit>
        <trans-unit id="f5ae108bdcb12eadcab59032e1a1a5515fad1336" translate="yes" xml:space="preserve">
          <source>WebEngineClientCertificateOption.select()</source>
          <target state="translated">WebEngineClientCertificateOption.select()</target>
        </trans-unit>
        <trans-unit id="ff8bfabd63aa4958297cb1169b12446bb4b29176" translate="yes" xml:space="preserve">
          <source>WebEngineClientCertificateOption.subject</source>
          <target state="translated">WebEngineClientCertificateOption.subject</target>
        </trans-unit>
        <trans-unit id="e8e414d305ef4364ac4dc8ca005d6e20a415922a" translate="yes" xml:space="preserve">
          <source>WebEngineClientCertificateSelection (QML type)</source>
          <target state="translated">WebEngineClientCertificateSelection (QML 유형)</target>
        </trans-unit>
        <trans-unit id="0cb3be3dd56bb64437926111611d9f00d1014d1e" translate="yes" xml:space="preserve">
          <source>WebEngineClientCertificateSelection QML Type</source>
          <target state="translated">WebEngineClientCertificateSelection QML 유형</target>
        </trans-unit>
        <trans-unit id="77393aefd8bbae718d883cfe8cee38d0d442202a" translate="yes" xml:space="preserve">
          <source>WebEngineClientCertificateSelection.certificates</source>
          <target state="translated">WebEngineClientCertificateSelection.certificates</target>
        </trans-unit>
        <trans-unit id="da597bd73b2cd94081b1f2423e3e6429851704eb" translate="yes" xml:space="preserve">
          <source>WebEngineClientCertificateSelection.host</source>
          <target state="translated">WebEngineClientCertificateSelection.host</target>
        </trans-unit>
        <trans-unit id="9d2d683963b4c30d8392f8c7667b1f8103578cfb" translate="yes" xml:space="preserve">
          <source>WebEngineClientCertificateSelection.select()</source>
          <target state="translated">WebEngineClientCertificateSelection.select()</target>
        </trans-unit>
        <trans-unit id="cc3133ed7cf2eea5920feb895305610da3f36ef8" translate="yes" xml:space="preserve">
          <source>WebEngineClientCertificateSelection.selectNone()</source>
          <target state="translated">WebEngineClientCertificateSelection.selectNone()</target>
        </trans-unit>
        <trans-unit id="36f6107531c0d842af8ebe03c3cf4378d97bd9c0" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem (QML type)</source>
          <target state="translated">WebEngineDownloadItem (QML 유형)</target>
        </trans-unit>
        <trans-unit id="d6b00361126a479a3c3b632725138c778c0da196" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem QML Type</source>
          <target state="translated">WebEngineDownloadItem QML 유형</target>
        </trans-unit>
        <trans-unit id="ceaebdcf5ae55e8ebcc8d497e6ad9a6b3ce81224" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem.accept()</source>
          <target state="translated">WebEngineDownloadItem.accept()</target>
        </trans-unit>
        <trans-unit id="e8ead6641dc31dc2884c85653a15a0fbf53b64da" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem.cancel()</source>
          <target state="translated">WebEngineDownloadItem.cancel()</target>
        </trans-unit>
        <trans-unit id="fa61e40728e6736a1b4906f922467a7c350445d8" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem.id</source>
          <target state="translated">WebEngineDownloadItem.id</target>
        </trans-unit>
        <trans-unit id="7e75a55da3d09d0c93447be046fd68115c042a09" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem.interruptReason</source>
          <target state="translated">WebEngineDownloadItem.interruptReason</target>
        </trans-unit>
        <trans-unit id="80ecebc0ed415633ee5e67be41abbc2c2fb68008" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem.interruptReasonString</source>
          <target state="translated">WebEngineDownloadItem.interruptReasonString</target>
        </trans-unit>
        <trans-unit id="3ee1c53af6bc91ea84490fde7b6cedc362449c30" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem.isFinished</source>
          <target state="translated">WebEngineDownloadItem.isFinished</target>
        </trans-unit>
        <trans-unit id="80def885450d5ae3e25641a3392ba76ebbfa9443" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem.isPaused</source>
          <target state="translated">WebEngineDownloadItem.isPaused</target>
        </trans-unit>
        <trans-unit id="0f40bdf7e14d74a0ec763ea85d20745a35627682" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem.isSavePageDownload</source>
          <target state="translated">WebEngineDownloadItem.isSavePageDownload</target>
        </trans-unit>
        <trans-unit id="6f729bdbcd5f4d4b81873f3c451a79a295b5a8b1" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem.mimeType</source>
          <target state="translated">WebEngineDownloadItem.mimeType</target>
        </trans-unit>
        <trans-unit id="6e18cfb040606400c2bdbc9c309cc2dec98334a5" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem.path</source>
          <target state="translated">WebEngineDownloadItem.path</target>
        </trans-unit>
        <trans-unit id="25c3caf1ff1c7a55d8c87778e82de72caa8fa5fe" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem.pause()</source>
          <target state="translated">WebEngineDownloadItem.pause()</target>
        </trans-unit>
        <trans-unit id="ed05f3a84b731d59fbadc9b8288a91410f18d40d" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem.receivedBytes</source>
          <target state="translated">WebEngineDownloadItem.receivedBytes</target>
        </trans-unit>
        <trans-unit id="61a7f81cafb9dff274ecd3f5a9047c15b056d4a3" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem.resume()</source>
          <target state="translated">WebEngineDownloadItem.resume()</target>
        </trans-unit>
        <trans-unit id="8ac10f0d71e92f3c9659ce036252a7903bff024d" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem.savePageFormat</source>
          <target state="translated">WebEngineDownloadItem.savePageFormat</target>
        </trans-unit>
        <trans-unit id="43fe346a1a5db2d95e1f6e4e7b4e20da262e03ac" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem.state</source>
          <target state="translated">WebEngineDownloadItem.state</target>
        </trans-unit>
        <trans-unit id="dbf66af1225e8027cc7c24aae9fef111f42e732b" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem.totalBytes</source>
          <target state="translated">WebEngineDownloadItem.totalBytes</target>
        </trans-unit>
        <trans-unit id="401d5e9a8402b3ae41815f2d6c514660e335ee4b" translate="yes" xml:space="preserve">
          <source>WebEngineDownloadItem.view</source>
          <target state="translated">WebEngineDownloadItem.view</target>
        </trans-unit>
        <trans-unit id="e06b4ae1902342bfb8ba65761215457e9af5c9b3" translate="yes" xml:space="preserve">
          <source>WebEngineHistory (QML type)</source>
          <target state="translated">WebEngineHistory (QML 유형)</target>
        </trans-unit>
        <trans-unit id="508cb5276b2144d3b6ebecbd8c2aa5c22e6994ad" translate="yes" xml:space="preserve">
          <source>WebEngineHistory QML Type</source>
          <target state="translated">WebEngineHistory QML 유형</target>
        </trans-unit>
        <trans-unit id="d3aab51e984df20177caddd70f6587b73b7268ea" translate="yes" xml:space="preserve">
          <source>WebEngineHistory.backItems</source>
          <target state="translated">WebEngineHistory.backItems</target>
        </trans-unit>
        <trans-unit id="0c122ea06b612782ee2d2f3fa82bd682b0d39777" translate="yes" xml:space="preserve">
          <source>WebEngineHistory.forwardItems</source>
          <target state="translated">WebEngineHistory.forwardItems</target>
        </trans-unit>
        <trans-unit id="314d63e2a7d5ca7ecbed605d6d38b5834908ec0b" translate="yes" xml:space="preserve">
          <source>WebEngineHistory.items</source>
          <target state="translated">WebEngineHistory.items</target>
        </trans-unit>
        <trans-unit id="7f33d69c23e47de284f264775d2007cb7749ee18" translate="yes" xml:space="preserve">
          <source>WebEngineHistoryListModel (QML type)</source>
          <target state="translated">WebEngineHistoryListModel (QML 유형)</target>
        </trans-unit>
        <trans-unit id="282e152b3dc0d8d4231f5457f9914306036a0661" translate="yes" xml:space="preserve">
          <source>WebEngineHistoryListModel QML Type</source>
          <target state="translated">WebEngineHistoryListModel QML 유형</target>
        </trans-unit>
        <trans-unit id="51ff605123e3d849720d654e61e1cccdc38c79d7" translate="yes" xml:space="preserve">
          <source>WebEngineLoadRequest (QML type)</source>
          <target state="translated">WebEngineLoadRequest (QML 유형)</target>
        </trans-unit>
        <trans-unit id="e69227c13a50f048a3ebe8a6416b3d0bcb031d89" translate="yes" xml:space="preserve">
          <source>WebEngineLoadRequest QML Type</source>
          <target state="translated">WebEngineLoadRequest QML 유형</target>
        </trans-unit>
        <trans-unit id="85969e9c108bc0bb87e3a73daa9dc500b2e8e35f" translate="yes" xml:space="preserve">
          <source>WebEngineLoadRequest.errorCode</source>
          <target state="translated">WebEngineLoadRequest.errorCode</target>
        </trans-unit>
        <trans-unit id="b94913c9709febec999cec6d7f9da1db83d3bdd5" translate="yes" xml:space="preserve">
          <source>WebEngineLoadRequest.errorDomain</source>
          <target state="translated">WebEngineLoadRequest.errorDomain</target>
        </trans-unit>
        <trans-unit id="e99ce41e5dbd0e919b90ab67204fac61797421ad" translate="yes" xml:space="preserve">
          <source>WebEngineLoadRequest.errorString</source>
          <target state="translated">WebEngineLoadRequest.errorString</target>
        </trans-unit>
        <trans-unit id="fdaa6f15a356365fed0c03cbb3b6bb91b58b3048" translate="yes" xml:space="preserve">
          <source>WebEngineLoadRequest.status</source>
          <target state="translated">WebEngineLoadRequest.status</target>
        </trans-unit>
        <trans-unit id="3fbe2293153fb23f95814eab5948e909dbe0c192" translate="yes" xml:space="preserve">
          <source>WebEngineLoadRequest.url</source>
          <target state="translated">WebEngineLoadRequest.url</target>
        </trans-unit>
        <trans-unit id="0996569032aaf4e8572763437c6d34c0102a09a0" translate="yes" xml:space="preserve">
          <source>WebEngineNavigationRequest (QML type)</source>
          <target state="translated">WebEngineNavigationRequest (QML 유형)</target>
        </trans-unit>
        <trans-unit id="485d98a1876ad875fd442129fe993ec9303c5fb5" translate="yes" xml:space="preserve">
          <source>WebEngineNavigationRequest QML Type</source>
          <target state="translated">WebEngineNavigationRequest QML 유형</target>
        </trans-unit>
        <trans-unit id="0a4bb9cdd9d58cfcee53dfbb0fe84d0a04d4b1db" translate="yes" xml:space="preserve">
          <source>WebEngineNavigationRequest.action</source>
          <target state="translated">WebEngineNavigationRequest.action</target>
        </trans-unit>
        <trans-unit id="54a4809f4bd79af38201b653a10b363c07f0dd87" translate="yes" xml:space="preserve">
          <source>WebEngineNavigationRequest.isMainFrame</source>
          <target state="translated">WebEngineNavigationRequest.isMainFrame</target>
        </trans-unit>
        <trans-unit id="2932812a972a7de9a432550c294037ed20d457a4" translate="yes" xml:space="preserve">
          <source>WebEngineNavigationRequest.navigationType</source>
          <target state="translated">WebEngineNavigationRequest.navigationType</target>
        </trans-unit>
        <trans-unit id="c4d0371352115a04af4e50135beae20d1cd43f7d" translate="yes" xml:space="preserve">
          <source>WebEngineNavigationRequest.url</source>
          <target state="translated">WebEngineNavigationRequest.url</target>
        </trans-unit>
        <trans-unit id="6bc96ad0b99177513aa9df51dd51d6ceeaeaa7ba" translate="yes" xml:space="preserve">
          <source>WebEngineNewViewRequest (QML type)</source>
          <target state="translated">WebEngineNewViewRequest (QML 유형)</target>
        </trans-unit>
        <trans-unit id="3d26ffb7610914eee54aeda49a31b45f363c04ee" translate="yes" xml:space="preserve">
          <source>WebEngineNewViewRequest QML Type</source>
          <target state="translated">WebEngineNewViewRequest QML 유형</target>
        </trans-unit>
        <trans-unit id="c7b0b46d96cb93b1cef2e7d4a2f446ce11c31671" translate="yes" xml:space="preserve">
          <source>WebEngineNewViewRequest.destination</source>
          <target state="translated">WebEngineNewViewRequest.destination</target>
        </trans-unit>
        <trans-unit id="33314a3b0b56dddc205faccac3e3c39414a1923d" translate="yes" xml:space="preserve">
          <source>WebEngineNewViewRequest.openIn()</source>
          <target state="translated">WebEngineNewViewRequest.openIn()</target>
        </trans-unit>
        <trans-unit id="350aceb7a1011ab8d1e262ddf4c239e7bef41c1e" translate="yes" xml:space="preserve">
          <source>WebEngineNewViewRequest.requestedUrl</source>
          <target state="translated">WebEngineNewViewRequest.requestedUrl</target>
        </trans-unit>
        <trans-unit id="2f1ea548134e3ab1f552924a124796d47ec4c37f" translate="yes" xml:space="preserve">
          <source>WebEngineNewViewRequest.userInitiated</source>
          <target state="translated">WebEngineNewViewRequest.userInitiated</target>
        </trans-unit>
        <trans-unit id="6e8fae3f1c24d2e0769d18a56350f9ed944b5a74" translate="yes" xml:space="preserve">
          <source>WebEngineProfile</source>
          <target state="translated">WebEngineProfile</target>
        </trans-unit>
        <trans-unit id="518d631b729885277ac98e7639b5d222d656b3fb" translate="yes" xml:space="preserve">
          <source>WebEngineProfile (QML type)</source>
          <target state="translated">WebEngineProfile (QML 유형)</target>
        </trans-unit>
        <trans-unit id="ab751277fa36cb67cd83270ab44c9e2ee5f02892" translate="yes" xml:space="preserve">
          <source>WebEngineProfile QML Type</source>
          <target state="translated">WebEngineProfile QML 유형</target>
        </trans-unit>
        <trans-unit id="5b2d51a7038a97679ae840e12a71807db3000dba" translate="yes" xml:space="preserve">
          <source>WebEngineProfile.cachePath</source>
          <target state="translated">WebEngineProfile.cachePath</target>
        </trans-unit>
        <trans-unit id="53265e2ce6e298fadd27130e63ac73ad109fce8e" translate="yes" xml:space="preserve">
          <source>WebEngineProfile.clearHttpCache()</source>
          <target state="translated">WebEngineProfile.clearHttpCache()</target>
        </trans-unit>
        <trans-unit id="f3d3d521e72d51971f7431a63ba7097af70a946b" translate="yes" xml:space="preserve">
          <source>WebEngineProfile.downloadFinished()</source>
          <target state="translated">WebEngineProfile.downloadFinished()</target>
        </trans-unit>
        <trans-unit id="26e4a1a53da739ed605f6d2a131010ef1b9275c8" translate="yes" xml:space="preserve">
          <source>WebEngineProfile.downloadPath</source>
          <target state="translated">WebEngineProfile.downloadPath</target>
        </trans-unit>
        <trans-unit id="d2f05f50b1264decd8fb1570c10271648ddd97ee" translate="yes" xml:space="preserve">
          <source>WebEngineProfile.downloadRequested()</source>
          <target state="translated">WebEngineProfile.downloadRequested()</target>
        </trans-unit>
        <trans-unit id="e4e8e62e09ae5ad2caaba1879c723bbbbd54b602" translate="yes" xml:space="preserve">
          <source>WebEngineProfile.httpAcceptLanguage</source>
          <target state="translated">WebEngineProfile.httpAcceptLanguage</target>
        </trans-unit>
        <trans-unit id="e901376b60658163fb2143915748ae82a686fec4" translate="yes" xml:space="preserve">
          <source>WebEngineProfile.httpCacheMaximumSize</source>
          <target state="translated">WebEngineProfile.httpCacheMaximumSize</target>
        </trans-unit>
        <trans-unit id="a392cbcff140c4155cd0ed7e87adbb708f0260b1" translate="yes" xml:space="preserve">
          <source>WebEngineProfile.httpCacheType</source>
          <target state="translated">WebEngineProfile.httpCacheType</target>
        </trans-unit>
        <trans-unit id="228d41938fe83f23d3c5c61b9bb8076d7ce61a80" translate="yes" xml:space="preserve">
          <source>WebEngineProfile.httpUserAgent</source>
          <target state="translated">WebEngineProfile.httpUserAgent</target>
        </trans-unit>
        <trans-unit id="05058daa887902e5ffa0a69460d2936952d292d4" translate="yes" xml:space="preserve">
          <source>WebEngineProfile.offTheRecord</source>
          <target state="translated">WebEngineProfile.offTheRecord</target>
        </trans-unit>
        <trans-unit id="eaacc15b935f57495d8ccf328b8bb6651374022b" translate="yes" xml:space="preserve">
          <source>WebEngineProfile.persistentCookiesPolicy</source>
          <target state="translated">WebEngineProfile.persistentCookiesPolicy</target>
        </trans-unit>
        <trans-unit id="9c4e6635fa42e698a2cf593c6d46b270a21b2ecb" translate="yes" xml:space="preserve">
          <source>WebEngineProfile.persistentStoragePath</source>
          <target state="translated">WebEngineProfile.persistentStoragePath</target>
        </trans-unit>
        <trans-unit id="d7541eac73f6db816e8a41c7237443affe9866ff" translate="yes" xml:space="preserve">
          <source>WebEngineProfile.presentNotification()</source>
          <target state="translated">WebEngineProfile.presentNotification()</target>
        </trans-unit>
        <trans-unit id="ae05cc8827cff2bd8d9b25f1d4cd86b746825d33" translate="yes" xml:space="preserve">
          <source>WebEngineProfile.spellCheckEnabled</source>
          <target state="translated">WebEngineProfile.spellCheckEnabled</target>
        </trans-unit>
        <trans-unit id="50b08645cf2b673ed6094b75a0d09872ac4291ea" translate="yes" xml:space="preserve">
          <source>WebEngineProfile.spellCheckLanguages</source>
          <target state="translated">WebEngineProfile.spellCheckLanguages</target>
        </trans-unit>
        <trans-unit id="e5650f8b787ca386e9338e3554b8ff3f8c7a9806" translate="yes" xml:space="preserve">
          <source>WebEngineProfile.storageName</source>
          <target state="translated">WebEngineProfile.storageName</target>
        </trans-unit>
        <trans-unit id="f1ea6d85679e535953caf8f350cc095f1146f94e" translate="yes" xml:space="preserve">
          <source>WebEngineProfile.useForGlobalCertificateVerification</source>
          <target state="translated">WebEngineProfile.useForGlobalCertificateVerification</target>
        </trans-unit>
        <trans-unit id="618217f64591b166cd92b37ea63c282088800ca7" translate="yes" xml:space="preserve">
          <source>WebEngineProfile.userScripts</source>
          <target state="translated">WebEngineProfile.userScripts</target>
        </trans-unit>
        <trans-unit id="6ef79401fe3fb68cad6d44fc60c25dcfaf684a9a" translate="yes" xml:space="preserve">
          <source>WebEngineScript</source>
          <target state="translated">WebEngineScript</target>
        </trans-unit>
        <trans-unit id="c16a28ec903b3ea9edc84579297dbac625fbc01c" translate="yes" xml:space="preserve">
          <source>WebEngineScript (QML type)</source>
          <target state="translated">WebEngineScript (QML 유형)</target>
        </trans-unit>
        <trans-unit id="8de45d3b9e6cb42f41d5981a14910e85ea0c1074" translate="yes" xml:space="preserve">
          <source>WebEngineScript QML Type</source>
          <target state="translated">WebEngineScript QML 유형</target>
        </trans-unit>
        <trans-unit id="5394d4b3c85f735d8353012da5fb754aaf780f9f" translate="yes" xml:space="preserve">
          <source>WebEngineScript.injectionPoint</source>
          <target state="translated">WebEngineScript.injectionPoint</target>
        </trans-unit>
        <trans-unit id="c3283b9f129bdad73a4022d69a4d7962b4f328bd" translate="yes" xml:space="preserve">
          <source>WebEngineScript.name</source>
          <target state="translated">WebEngineScript.name</target>
        </trans-unit>
        <trans-unit id="3a7793aaf37fed1e4cb3f44c7904dbd575ba84dd" translate="yes" xml:space="preserve">
          <source>WebEngineScript.runOnSubframes</source>
          <target state="translated">WebEngineScript.runOnSubframes</target>
        </trans-unit>
        <trans-unit id="1ffceca5339c5fbbd35a1f3d987c74b7e8b82b63" translate="yes" xml:space="preserve">
          <source>WebEngineScript.sourceCode</source>
          <target state="translated">WebEngineScript.sourceCode</target>
        </trans-unit>
        <trans-unit id="7af40e9e2a52edd866ba2b1c704b41386453d47a" translate="yes" xml:space="preserve">
          <source>WebEngineScript.sourceUrl</source>
          <target state="translated">WebEngineScript.sourceUrl</target>
        </trans-unit>
        <trans-unit id="e978ad985da64d96d8ba11e5485864b3e15edfb5" translate="yes" xml:space="preserve">
          <source>WebEngineScript.worldId</source>
          <target state="translated">WebEngineScript.worldId</target>
        </trans-unit>
        <trans-unit id="091e5b3a46252aa7cf3b9335386ddbb0b2d2eed4" translate="yes" xml:space="preserve">
          <source>WebEngineSettings (QML type)</source>
          <target state="translated">WebEngineSettings (QML 유형)</target>
        </trans-unit>
        <trans-unit id="faa6d1c1ab8086fbe4cbb74abdca6a38fb6fafab" translate="yes" xml:space="preserve">
          <source>WebEngineSettings QML Type</source>
          <target state="translated">WebEngineSettings QML 유형</target>
        </trans-unit>
        <trans-unit id="1fea7ecaa8fb05a23cd07abf97ae1f4ad7506d4b" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.accelerated2dCanvasEnabled</source>
          <target state="translated">WebEngineSettings.accelerated2dCanvasEnabled</target>
        </trans-unit>
        <trans-unit id="5349878810be3b79b9be4fc583e17bf74bd438b6" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.allowGeolocationOnInsecureOrigins</source>
          <target state="translated">WebEngineSettings.allowGeolocationOnInsecureOrigins</target>
        </trans-unit>
        <trans-unit id="5f4a076b1da98d289ce61a4156f59ab9353ef549" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.allowRunningInsecureContent</source>
          <target state="translated">WebEngineSettings.allowRunningInsecureContent</target>
        </trans-unit>
        <trans-unit id="5dfbcdae30dfc6ea2c6fc74b08bd6b8865632692" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.allowWindowActivationFromJavaScript</source>
          <target state="translated">WebEngineSettings.allowWindowActivationFromJavaScript</target>
        </trans-unit>
        <trans-unit id="4f83caf7d8c28204785e76d31869881589d3d408" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.autoLoadIconsForPage</source>
          <target state="translated">WebEngineSettings.autoLoadIconsForPage</target>
        </trans-unit>
        <trans-unit id="4ecf84282c87a0c6390239645e38a88f4844ec61" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.autoLoadImages</source>
          <target state="translated">WebEngineSettings.autoLoadImages</target>
        </trans-unit>
        <trans-unit id="62723612696cead9849f6586657770c05b6c8fcb" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.defaultTextEncoding</source>
          <target state="translated">WebEngineSettings.defaultTextEncoding</target>
        </trans-unit>
        <trans-unit id="eb5c2d93102a0d2fe2325960cb564edd80c3dc4f" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.dnsPrefetchEnabled</source>
          <target state="translated">WebEngineSettings.dnsPrefetchEnabled</target>
        </trans-unit>
        <trans-unit id="b29dc6f8dfbd0c0c71333f8ac56f331cfecdbf33" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.errorPageEnabled</source>
          <target state="translated">WebEngineSettings.errorPageEnabled</target>
        </trans-unit>
        <trans-unit id="d482a8aa1cb014cd6154ddcd0793cf73ff954d5f" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.focusOnNavigationEnabled</source>
          <target state="translated">WebEngineSettings.focusOnNavigationEnabled</target>
        </trans-unit>
        <trans-unit id="95e72e481a8591131f9f0dd67865ce1cc87f394c" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.fullscreenSupportEnabled</source>
          <target state="translated">WebEngineSettings.fullscreenSupportEnabled</target>
        </trans-unit>
        <trans-unit id="26c00e549f2a94ac71c7c9aaf5e5a903db8dd282" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.hyperlinkAuditingEnabled</source>
          <target state="translated">WebEngineSettings.hyperlinkAuditingEnabled</target>
        </trans-unit>
        <trans-unit id="92390f77eb8970b991dbd891ffba70dc76bcd66b" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.javascriptCanAccessClipboard</source>
          <target state="translated">WebEngineSettings.javascriptCanAccessClipboard</target>
        </trans-unit>
        <trans-unit id="cb4b5e7c640938495f92835b3d94f39b87682371" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.javascriptCanOpenWindows</source>
          <target state="translated">WebEngineSettings.javascriptCanOpenWindows</target>
        </trans-unit>
        <trans-unit id="0398f6038d040b4f6a63df0682e0dafd34d1fe99" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.javascriptCanPaste</source>
          <target state="translated">WebEngineSettings.javascriptCanPaste</target>
        </trans-unit>
        <trans-unit id="c17e8bc7ae3e4a755f6a16606b6df8c7f1385999" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.javascriptEnabled</source>
          <target state="translated">WebEngineSettings.javascriptEnabled</target>
        </trans-unit>
        <trans-unit id="93dca592f197d0d71841be53312a3eacf73957ba" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.linksIncludedInFocusChain</source>
          <target state="translated">WebEngineSettings.linksIncludedInFocusChain</target>
        </trans-unit>
        <trans-unit id="5c9725e7e180d7a24a843dd450bbde09c6b4376f" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.localContentCanAccessFileUrls</source>
          <target state="translated">WebEngineSettings.localContentCanAccessFileUrls</target>
        </trans-unit>
        <trans-unit id="68de5ecfca1232efc157c6bda3618f64706a803a" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.localContentCanAccessRemoteUrls</source>
          <target state="translated">WebEngineSettings.localContentCanAccessRemoteUrls</target>
        </trans-unit>
        <trans-unit id="c46343a688cfff60533796524408cdb9d74802e3" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.localStorageEnabled</source>
          <target state="translated">WebEngineSettings.localStorageEnabled</target>
        </trans-unit>
        <trans-unit id="06859934675b7a9d7a3992c6714527e10f47860c" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.pdfViewerEnabled</source>
          <target state="translated">WebEngineSettings.pdfViewerEnabled</target>
        </trans-unit>
        <trans-unit id="e58ca6e4f65e101898c896fb478d2a9b0440ca0c" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.playbackRequiresUserGesture</source>
          <target state="translated">WebEngineSettings.playbackRequiresUserGesture</target>
        </trans-unit>
        <trans-unit id="3fea5a8da30eef6cac698ee56e1d00bd2d261431" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.pluginsEnabled</source>
          <target state="translated">WebEngineSettings.pluginsEnabled</target>
        </trans-unit>
        <trans-unit id="4fc746c749bf74407f9e162f4f2538a6f67db30a" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.printElementBackgrounds</source>
          <target state="translated">WebEngineSettings.printElementBackgrounds</target>
        </trans-unit>
        <trans-unit id="44fd6452f36faf75de0cf5ef6ca7e1104fcf050d" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.screenCaptureEnabled</source>
          <target state="translated">WebEngineSettings.screenCaptureEnabled</target>
        </trans-unit>
        <trans-unit id="cb6a978a93aadad68f07a35955bcd06434f2ce8c" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.showScrollBars</source>
          <target state="translated">WebEngineSettings.showScrollBars</target>
        </trans-unit>
        <trans-unit id="7c14a2b3b16c45e0a46fa861c6a2257fc3f5948a" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.spatialNavigationEnabled</source>
          <target state="translated">WebEngineSettings.spatialNavigationEnabled</target>
        </trans-unit>
        <trans-unit id="17d5f39d317053a5a12b7ef2be06b7ca570eb62d" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.touchIconsEnabled</source>
          <target state="translated">WebEngineSettings.touchIconsEnabled</target>
        </trans-unit>
        <trans-unit id="9c47be665e8347f5c86a70b7c5483bbbc22c99d8" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.unknownUrlSchemePolicy</source>
          <target state="translated">WebEngineSettings.unknownUrlSchemePolicy</target>
        </trans-unit>
        <trans-unit id="27ac594d3409c6b9fe5b16b5e82353e99cdbda7b" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.webGLEnabled</source>
          <target state="translated">WebEngineSettings.webGLEnabled</target>
        </trans-unit>
        <trans-unit id="94f59f6df728d0d424d7c8d46c85b3b189fa5186" translate="yes" xml:space="preserve">
          <source>WebEngineSettings.webRTCPublicInterfacesOnly</source>
          <target state="translated">WebEngineSettings.webRTCPublicInterfacesOnly</target>
        </trans-unit>
        <trans-unit id="0b877e37195add35a999ee4e8c9b40d8bdd62fdb" translate="yes" xml:space="preserve">
          <source>WebEngineView (QML type)</source>
          <target state="translated">WebEngineView (QML 유형)</target>
        </trans-unit>
        <trans-unit id="69acf8aaa036511b5d9f591d9d99184296b25a82" translate="yes" xml:space="preserve">
          <source>WebEngineView QML Type</source>
          <target state="translated">WebEngineView QML 유형</target>
        </trans-unit>
        <trans-unit id="be4f1be65108ff84eaee4e86b0ebddcea4c56ec5" translate="yes" xml:space="preserve">
          <source>WebEngineView.ErrorDomain</source>
          <target state="translated">WebEngineView.ErrorDomain</target>
        </trans-unit>
        <trans-unit id="d16bcb3d9d57a538fd90bc2e8aa67ce3ca8d9c5c" translate="yes" xml:space="preserve">
          <source>WebEngineView.Feature</source>
          <target state="translated">WebEngineView.Feature</target>
        </trans-unit>
        <trans-unit id="fe1ff15b4510bbed77995a94752ebe559582a37b" translate="yes" xml:space="preserve">
          <source>WebEngineView.FindFlags</source>
          <target state="translated">WebEngineView.FindFlags</target>
        </trans-unit>
        <trans-unit id="27fa32817407f6d749b0ef8c4951a6ae9134c8f0" translate="yes" xml:space="preserve">
          <source>WebEngineView.JavaScriptConsoleMessageLevel</source>
          <target state="translated">WebEngineView.JavaScriptConsoleMessageLevel</target>
        </trans-unit>
        <trans-unit id="f0ad79fc32b7d46b6dfbab37f472e88c60e98ee4" translate="yes" xml:space="preserve">
          <source>WebEngineView.LoadStatus</source>
          <target state="translated">WebEngineView.LoadStatus</target>
        </trans-unit>
        <trans-unit id="7ff6f2ea2c6ee2ec167a0bc37a1b932c5125356e" translate="yes" xml:space="preserve">
          <source>WebEngineView.NewViewDestination</source>
          <target state="translated">WebEngineView.NewViewDestination</target>
        </trans-unit>
        <trans-unit id="a4a561c375af48294360ad09288e52d3a4ba85cb" translate="yes" xml:space="preserve">
          <source>WebEngineView.PrintedPageOrientation</source>
          <target state="translated">WebEngineView.PrintedPageOrientation</target>
        </trans-unit>
        <trans-unit id="b0cf82971b8a4cd70eb9c6efe36187e3f1391355" translate="yes" xml:space="preserve">
          <source>WebEngineView.PrintedPageSizeId</source>
          <target state="translated">WebEngineView.PrintedPageSizeId</target>
        </trans-unit>
        <trans-unit id="3ac8d9ba1f694d226c3ede1ebc567c0adfc5d962" translate="yes" xml:space="preserve">
          <source>WebEngineView.RenderProcessTerminationStatus</source>
          <target state="translated">WebEngineView.RenderProcessTerminationStatus</target>
        </trans-unit>
        <trans-unit id="9ece392f89a8f2375ac3380cbdcc2a34d4293391" translate="yes" xml:space="preserve">
          <source>WebEngineView.WebAction</source>
          <target state="translated">WebEngineView.WebAction</target>
        </trans-unit>
        <trans-unit id="30f99522aa97256e24cf8fbb7015742813dd83b2" translate="yes" xml:space="preserve">
          <source>WebEngineView.action()</source>
          <target state="translated">WebEngineView.action()</target>
        </trans-unit>
        <trans-unit id="5fee55782d93693b1c0af7eeb0da51bc8f6a0eb5" translate="yes" xml:space="preserve">
          <source>WebEngineView.activeFocusOnPress</source>
          <target state="translated">WebEngineView.activeFocusOnPress</target>
        </trans-unit>
        <trans-unit id="2013ef8a7927d043fa684eefd13ebe85fbfa8110" translate="yes" xml:space="preserve">
          <source>WebEngineView.activeFocusOnPressChanged()</source>
          <target state="translated">WebEngineView.activeFocusOnPressChanged()</target>
        </trans-unit>
        <trans-unit id="2ed062582050635e6e27ab7b8d3be932b8dbcde2" translate="yes" xml:space="preserve">
          <source>WebEngineView.audioMuted</source>
          <target state="translated">WebEngineView.audioMuted</target>
        </trans-unit>
        <trans-unit id="8c8ca042e0ba05d776a8d5f019c52acb69243bdd" translate="yes" xml:space="preserve">
          <source>WebEngineView.audioMutedChanged()</source>
          <target state="translated">WebEngineView.audioMutedChanged()</target>
        </trans-unit>
        <trans-unit id="eeea28b3a23aebff09c6f5b5e2d84757354158fb" translate="yes" xml:space="preserve">
          <source>WebEngineView.authenticationDialogRequested()</source>
          <target state="translated">WebEngineView.authenticationDialogRequested()</target>
        </trans-unit>
        <trans-unit id="5dcf5ec43e9bd1083c20e8d6ac448086277917e2" translate="yes" xml:space="preserve">
          <source>WebEngineView.backgroundColor</source>
          <target state="translated">WebEngineView.backgroundColor</target>
        </trans-unit>
        <trans-unit id="488f9f96d4c816aa3ee19a19e8f157550f702dc8" translate="yes" xml:space="preserve">
          <source>WebEngineView.backgroundColorChanged()</source>
          <target state="translated">WebEngineView.backgroundColorChanged()</target>
        </trans-unit>
        <trans-unit id="1c9ec66231ac8d8e0f049bc5bfe17d880e9ab559" translate="yes" xml:space="preserve">
          <source>WebEngineView.canGoBack</source>
          <target state="translated">WebEngineView.canGoBack</target>
        </trans-unit>
        <trans-unit id="09200f1a699b043eef91efe32a0181dde241c6da" translate="yes" xml:space="preserve">
          <source>WebEngineView.canGoForward</source>
          <target state="translated">WebEngineView.canGoForward</target>
        </trans-unit>
        <trans-unit id="7374c93518161e6aeb6c0e2ad8db97f814081869" translate="yes" xml:space="preserve">
          <source>WebEngineView.certificateError()</source>
          <target state="translated">WebEngineView.certificateError()</target>
        </trans-unit>
        <trans-unit id="98254b8bb9bb363857e3f9220800d2950ffe7d17" translate="yes" xml:space="preserve">
          <source>WebEngineView.colorDialogRequested()</source>
          <target state="translated">WebEngineView.colorDialogRequested()</target>
        </trans-unit>
        <trans-unit id="d27389f1a38b044a0906b0976703fef3bb3b3181" translate="yes" xml:space="preserve">
          <source>WebEngineView.contentsSize</source>
          <target state="translated">WebEngineView.contentsSize</target>
        </trans-unit>
        <trans-unit id="a70aea728b997bc48e73bc1f16fc334c8ec0ee33" translate="yes" xml:space="preserve">
          <source>WebEngineView.contextMenuRequested()</source>
          <target state="translated">WebEngineView.contextMenuRequested()</target>
        </trans-unit>
        <trans-unit id="d1c7fd8646e220d402c63bb9ad8c4d10dd15efc8" translate="yes" xml:space="preserve">
          <source>WebEngineView.devToolsView</source>
          <target state="translated">WebEngineView.devToolsView</target>
        </trans-unit>
        <trans-unit id="42389ded9c72cc62f10409286c47d6a8600965cd" translate="yes" xml:space="preserve">
          <source>WebEngineView.featurePermissionRequested()</source>
          <target state="translated">WebEngineView.featurePermissionRequested()</target>
        </trans-unit>
        <trans-unit id="9d62f0fafb4982ec4d80824aabccfb013342c056" translate="yes" xml:space="preserve">
          <source>WebEngineView.fileDialogRequested()</source>
          <target state="translated">WebEngineView.fileDialogRequested()</target>
        </trans-unit>
        <trans-unit id="33be853a1a294e0c2e530e05515e140450d0a489" translate="yes" xml:space="preserve">
          <source>WebEngineView.findText()</source>
          <target state="translated">WebEngineView.findText()</target>
        </trans-unit>
        <trans-unit id="14a82a3c830d85b2b01d2706feddc8ddf5aa28c3" translate="yes" xml:space="preserve">
          <source>WebEngineView.fullScreenCancelled()</source>
          <target state="translated">WebEngineView.fullScreenCancelled()</target>
        </trans-unit>
        <trans-unit id="9e88adcbd663c82bb6ecc64a496a5c8541d9523d" translate="yes" xml:space="preserve">
          <source>WebEngineView.fullScreenRequested()</source>
          <target state="translated">WebEngineView.fullScreenRequested()</target>
        </trans-unit>
        <trans-unit id="68cec121b65f8d2ef2ba82fa8110b7c93e830efe" translate="yes" xml:space="preserve">
          <source>WebEngineView.geometryChangeRequested()</source>
          <target state="translated">WebEngineView.geometryChangeRequested()</target>
        </trans-unit>
        <trans-unit id="c97d242c87d754160f9c76bdc14bcc8ddfda2338" translate="yes" xml:space="preserve">
          <source>WebEngineView.goBack()</source>
          <target state="translated">WebEngineView.goBack()</target>
        </trans-unit>
        <trans-unit id="14178b132bd8f3260a3ac28944791dc0d0cde82c" translate="yes" xml:space="preserve">
          <source>WebEngineView.goBackOrForward()</source>
          <target state="translated">WebEngineView.goBackOrForward()</target>
        </trans-unit>
        <trans-unit id="e6ac0e0cff7352d10ca78ce8786fd7c4e95e84a3" translate="yes" xml:space="preserve">
          <source>WebEngineView.goForward()</source>
          <target state="translated">WebEngineView.goForward()</target>
        </trans-unit>
        <trans-unit id="d8d03a4c0249f69ab0bc8c3a08ef420f0ea7773f" translate="yes" xml:space="preserve">
          <source>WebEngineView.grantFeaturePermission()</source>
          <target state="translated">WebEngineView.grantFeaturePermission()</target>
        </trans-unit>
        <trans-unit id="5388743b855359e1a898314e3a239ac47b5cff06" translate="yes" xml:space="preserve">
          <source>WebEngineView.icon</source>
          <target state="translated">WebEngineView.icon</target>
        </trans-unit>
        <trans-unit id="09b2eab9b08dd622363646c69fa0f28bef7b81ee" translate="yes" xml:space="preserve">
          <source>WebEngineView.inspectedView</source>
          <target state="translated">WebEngineView.inspectedView</target>
        </trans-unit>
        <trans-unit id="b43db3b563d5c63e05dbda10e153834ab7a97fc8" translate="yes" xml:space="preserve">
          <source>WebEngineView.isFullScreen</source>
          <target state="translated">WebEngineView.isFullScreen</target>
        </trans-unit>
        <trans-unit id="7c890a9f78e5631f2578b0eb19d7f0f93d298a1b" translate="yes" xml:space="preserve">
          <source>WebEngineView.javaScriptConsoleMessage()</source>
          <target state="translated">WebEngineView.javaScriptConsoleMessage()</target>
        </trans-unit>
        <trans-unit id="2591f19dc9a64d6fa194da5d773571fb0b9c6719" translate="yes" xml:space="preserve">
          <source>WebEngineView.javaScriptDialogRequested()</source>
          <target state="translated">WebEngineView.javaScriptDialogRequested()</target>
        </trans-unit>
        <trans-unit id="9710ab99fd19e1c62de3220edd8e39f918678971" translate="yes" xml:space="preserve">
          <source>WebEngineView.linkHovered()</source>
          <target state="translated">WebEngineView.linkHovered()</target>
        </trans-unit>
        <trans-unit id="9a68ea9ecd41a41205475e0161ba7b2b53a6dce4" translate="yes" xml:space="preserve">
          <source>WebEngineView.loadHtml()</source>
          <target state="translated">WebEngineView.loadHtml()</target>
        </trans-unit>
        <trans-unit id="142347e4e5534c72ba24963c91c530319f1c5eeb" translate="yes" xml:space="preserve">
          <source>WebEngineView.loadProgress</source>
          <target state="translated">WebEngineView.loadProgress</target>
        </trans-unit>
        <trans-unit id="def22685500638326527ded9e5c75d638d0f35a9" translate="yes" xml:space="preserve">
          <source>WebEngineView.loading</source>
          <target state="translated">WebEngineView.loading</target>
        </trans-unit>
        <trans-unit id="28c432a7a2acb73152bdcd6b35f2f2530c7e316c" translate="yes" xml:space="preserve">
          <source>WebEngineView.loadingChanged()</source>
          <target state="translated">WebEngineView.loadingChanged()</target>
        </trans-unit>
        <trans-unit id="ebb9c4c1c712756b90971e68a373e4c8ba5f5f20" translate="yes" xml:space="preserve">
          <source>WebEngineView.navigationHistory</source>
          <target state="translated">WebEngineView.navigationHistory</target>
        </trans-unit>
        <trans-unit id="3160dc3b1a72e83850b841b10613488f921c5cef" translate="yes" xml:space="preserve">
          <source>WebEngineView.navigationRequested()</source>
          <target state="translated">WebEngineView.navigationRequested()</target>
        </trans-unit>
        <trans-unit id="4550665b53c9a63149e9afcaceaff3a3f1900d8b" translate="yes" xml:space="preserve">
          <source>WebEngineView.newViewRequested()</source>
          <target state="translated">WebEngineView.newViewRequested()</target>
        </trans-unit>
        <trans-unit id="35a664f58d6555866fedcc1cfa106b440eee126f" translate="yes" xml:space="preserve">
          <source>WebEngineView.pdfPrintingFinished()</source>
          <target state="translated">WebEngineView.pdfPrintingFinished()</target>
        </trans-unit>
        <trans-unit id="23ad87f76a2c6929c439f0d0362ad5de1fc9b700" translate="yes" xml:space="preserve">
          <source>WebEngineView.printRequest()</source>
          <target state="translated">WebEngineView.printRequest()</target>
        </trans-unit>
        <trans-unit id="195c86677ed50b3e2cf5d484b7ec20a783a0aa4c" translate="yes" xml:space="preserve">
          <source>WebEngineView.printToPdf()</source>
          <target state="translated">WebEngineView.printToPdf()</target>
        </trans-unit>
        <trans-unit id="f26e17447f55ef53d70244f295be63ef1fc4c8d5" translate="yes" xml:space="preserve">
          <source>WebEngineView.profile</source>
          <target state="translated">WebEngineView.profile</target>
        </trans-unit>
        <trans-unit id="48e016c6abf0b47e0e459a0e39d57605d82c2d3d" translate="yes" xml:space="preserve">
          <source>WebEngineView.quotaRequested()</source>
          <target state="translated">WebEngineView.quotaRequested()</target>
        </trans-unit>
        <trans-unit id="2b0a1c592762897c5fc9f2b53a4d05f6902f8e15" translate="yes" xml:space="preserve">
          <source>WebEngineView.recentlyAudible</source>
          <target state="translated">WebEngineView.recentlyAudible</target>
        </trans-unit>
        <trans-unit id="46a587433211b853deb9a215c46c4dbdc9665607" translate="yes" xml:space="preserve">
          <source>WebEngineView.recentlyAudibleChanged()</source>
          <target state="translated">WebEngineView.recentlyAudibleChanged()</target>
        </trans-unit>
        <trans-unit id="fc150a65382afacbdbefa9a1c52fa8e2ac6f723e" translate="yes" xml:space="preserve">
          <source>WebEngineView.registerProtocolHandlerRequested()</source>
          <target state="translated">WebEngineView.registerProtocolHandlerRequested()</target>
        </trans-unit>
        <trans-unit id="6bb5745e003997e47cfe8c0274da7eb705afd984" translate="yes" xml:space="preserve">
          <source>WebEngineView.reload()</source>
          <target state="translated">WebEngineView.reload()</target>
        </trans-unit>
        <trans-unit id="799d6344bf5e351e7b4592f78ebdfc176ab2f7d3" translate="yes" xml:space="preserve">
          <source>WebEngineView.reloadAndBypassCache()</source>
          <target state="translated">WebEngineView.reloadAndBypassCache()</target>
        </trans-unit>
        <trans-unit id="b49d212177393866b03b5219b81effea5947ebfc" translate="yes" xml:space="preserve">
          <source>WebEngineView.renderProcessTerminated()</source>
          <target state="translated">WebEngineView.renderProcessTerminated()</target>
        </trans-unit>
        <trans-unit id="7559eafc68c1babd8a51456286fa398a9c67cce5" translate="yes" xml:space="preserve">
          <source>WebEngineView.replaceMisspelledWord()</source>
          <target state="translated">WebEngineView.replaceMisspelledWord()</target>
        </trans-unit>
        <trans-unit id="99f3a08b9113b60d1a735789c10d4a9f46680e53" translate="yes" xml:space="preserve">
          <source>WebEngineView.runJavaScript()</source>
          <target state="translated">WebEngineView.runJavaScript()</target>
        </trans-unit>
        <trans-unit id="0f87cc21f65143d9a7dd68d91c4af8e6cc39068d" translate="yes" xml:space="preserve">
          <source>WebEngineView.scrollPosition</source>
          <target state="translated">WebEngineView.scrollPosition</target>
        </trans-unit>
        <trans-unit id="931f32a7fd69578259259f091f97661e1e12ce79" translate="yes" xml:space="preserve">
          <source>WebEngineView.selectClientCertificate()</source>
          <target state="translated">WebEngineView.selectClientCertificate()</target>
        </trans-unit>
        <trans-unit id="9fb233ce902952e279ca96f71a47097ce92cd326" translate="yes" xml:space="preserve">
          <source>WebEngineView.setActiveFocusOnPress()</source>
          <target state="translated">WebEngineView.setActiveFocusOnPress()</target>
        </trans-unit>
        <trans-unit id="1406f3042713e2ede7377a7fbd399594741a4390" translate="yes" xml:space="preserve">
          <source>WebEngineView.settings</source>
          <target state="translated">WebEngineView.settings</target>
        </trans-unit>
        <trans-unit id="eaaded39b717e96c9da5628d643355743fe7322c" translate="yes" xml:space="preserve">
          <source>WebEngineView.stop()</source>
          <target state="translated">WebEngineView.stop()</target>
        </trans-unit>
        <trans-unit id="2963bc2d66dc5d5eaa391a65302e8cc32547e784" translate="yes" xml:space="preserve">
          <source>WebEngineView.title</source>
          <target state="translated">WebEngineView.title</target>
        </trans-unit>
        <trans-unit id="01be5755351b937b81a782b79a68ea3cb9300873" translate="yes" xml:space="preserve">
          <source>WebEngineView.triggerWebAction()</source>
          <target state="translated">WebEngineView.triggerWebAction()</target>
        </trans-unit>
        <trans-unit id="484e29f697c664ccf881e4994e92a8d7ba843e82" translate="yes" xml:space="preserve">
          <source>WebEngineView.url</source>
          <target state="translated">WebEngineView.url</target>
        </trans-unit>
        <trans-unit id="d0705df93b009f547f343ff90d1fee7d44b40be6" translate="yes" xml:space="preserve">
          <source>WebEngineView.userScripts</source>
          <target state="translated">WebEngineView.userScripts</target>
        </trans-unit>
        <trans-unit id="955e3c8570ac797ccac5dcd591ef4d05a097ff76" translate="yes" xml:space="preserve">
          <source>WebEngineView.wasRecentlyAudibleChanged()</source>
          <target state="translated">WebEngineView.wasRecentlyAudibleChanged()</target>
        </trans-unit>
        <trans-unit id="ffdd37d1223dc1067bf7dcd4db8ec6a2d5e7c4de" translate="yes" xml:space="preserve">
          <source>WebEngineView.webChannel</source>
          <target state="translated">WebEngineView.webChannel</target>
        </trans-unit>
        <trans-unit id="338c517760532741683df475ff6869f96bd8f670" translate="yes" xml:space="preserve">
          <source>WebEngineView.webChannelWorld</source>
          <target state="translated">WebEngineView.webChannelWorld</target>
        </trans-unit>
        <trans-unit id="399ee6be714057e0296ae36d793a438c02d48099" translate="yes" xml:space="preserve">
          <source>WebEngineView.windowCloseRequested()</source>
          <target state="translated">WebEngineView.windowCloseRequested()</target>
        </trans-unit>
        <trans-unit id="1db2143a7e1e8ad414e4a3407684e331f4236214" translate="yes" xml:space="preserve">
          <source>WebEngineView.zoomFactor</source>
          <target state="translated">WebEngineView.zoomFactor</target>
        </trans-unit>
        <trans-unit id="1213d8e4899a879d402180c42969e41160db73a8" translate="yes" xml:space="preserve">
          <source>WebGL is required, even for applications which do not use OpenGL themselves. Most modern browsers support WebGL, but note that some browsers blacklist certain older GPUs. The Qt loader will detect this and display an error message.</source>
          <target state="translated">OpenGL 자체를 사용하지 않는 응용 프로그램의 경우에도 WebGL이 필요합니다. 대부분의 최신 브라우저는 WebGL을 지원하지만 일부 브라우저는 특정 구형 GPU를 블랙리스트에 추가합니다. Qt 로더가이를 감지하고 오류 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="908432272f47f5bade571c1269768a1d308f584e" translate="yes" xml:space="preserve">
          <source>WebGradients</source>
          <target state="translated">WebGradients</target>
        </trans-unit>
        <trans-unit id="6fa39ac0c7eff59abc27629413eef3a672293245" translate="yes" xml:space="preserve">
          <source>WebP</source>
          <target state="translated">WebP</target>
        </trans-unit>
        <trans-unit id="abef59e016262e300b821f10389206baee40a796" translate="yes" xml:space="preserve">
          <source>WebP (libwebp), version 1.0.2</source>
          <target state="translated">WebP (libwebp) 버전 1.0.2</target>
        </trans-unit>
        <trans-unit id="d45467ff69e35666865e74f6cccea4ede203d9e9" translate="yes" xml:space="preserve">
          <source>WebRTC</source>
          <target state="translated">WebRTC</target>
        </trans-unit>
        <trans-unit id="8213fa340d26aa082e8938fc141ca063d103e00f" translate="yes" xml:space="preserve">
          <source>WebSocket (QML type)</source>
          <target state="translated">WebSocket (QML 유형)</target>
        </trans-unit>
        <trans-unit id="e0a0476d9337d2588e94b879f507f8e4f263cc4f" translate="yes" xml:space="preserve">
          <source>WebSocket QML Type</source>
          <target state="translated">WebSocket QML 유형</target>
        </trans-unit>
        <trans-unit id="69fb9fa50b0471dfb98c7f9878dbe8aad415e99d" translate="yes" xml:space="preserve">
          <source>WebSocket is a web-based protocol designed to enable two-way communication between a client application and a remote host. It enables the two entities to send data back and forth if the initial handshake succeeds. WebSocket is the solution for applications that struggle to get real-time data feeds with less network latency and minimum data exchange.</source>
          <target state="translated">WebSocket은 클라이언트 응용 프로그램과 원격 호스트간에 양방향 통신이 가능하도록 설계된 웹 기반 프로토콜입니다. 초기 핸드 셰이크가 성공하면 두 엔티티가 데이터를주고받을 수 있습니다. WebSocket은 네트워크 대기 시간을 줄이고 데이터 교환을 최소화하면서 실시간 데이터 피드를 얻는 데 어려움을 겪는 응용 프로그램을위한 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="07f90674c2459e714c345caa5c513d591bddf57e" translate="yes" xml:space="preserve">
          <source>WebSocket server example</source>
          <target state="translated">WebSocket 서버 예</target>
        </trans-unit>
        <trans-unit id="e61d9471b625721deef3aadb0f7d0788f0c1609f" translate="yes" xml:space="preserve">
          <source>WebSocket.Closed</source>
          <target state="translated">WebSocket.Closed</target>
        </trans-unit>
        <trans-unit id="8060dacca324ea6834f12add4e6ad4b5a5d8c5fb" translate="yes" xml:space="preserve">
          <source>WebSocket.Closing</source>
          <target state="translated">WebSocket.Closing</target>
        </trans-unit>
        <trans-unit id="d89bb864dd8411352adc93f162846c1e76f98167" translate="yes" xml:space="preserve">
          <source>WebSocket.Connecting</source>
          <target state="translated">WebSocket.Connecting</target>
        </trans-unit>
        <trans-unit id="8d33f5112eb8775758c6b56599ad961f90b59d76" translate="yes" xml:space="preserve">
          <source>WebSocket.Error</source>
          <target state="translated">WebSocket.Error</target>
        </trans-unit>
        <trans-unit id="0e5c5102b7d8a33607bf1e420c4cc5204e27f78b" translate="yes" xml:space="preserve">
          <source>WebSocket.Open</source>
          <target state="translated">WebSocket.Open</target>
        </trans-unit>
        <trans-unit id="db6f59a2cd8416b06e33169678e26c5820213d03" translate="yes" xml:space="preserve">
          <source>WebSocket.active</source>
          <target state="translated">WebSocket.active</target>
        </trans-unit>
        <trans-unit id="56c5cc2e30c870b6ef0f3383441976f3e7d57f04" translate="yes" xml:space="preserve">
          <source>WebSocket.binaryMessageReceived()</source>
          <target state="translated">WebSocket.binaryMessageReceived()</target>
        </trans-unit>
        <trans-unit id="5763fe824ff6d3a08edfc10753f2027a2d6a1f90" translate="yes" xml:space="preserve">
          <source>WebSocket.errorString</source>
          <target state="translated">WebSocket.errorString</target>
        </trans-unit>
        <trans-unit id="310eeece1712c29e5bc5487bd1d4b1640253b6c2" translate="yes" xml:space="preserve">
          <source>WebSocket.sendBinaryMessage()</source>
          <target state="translated">WebSocket.sendBinaryMessage()</target>
        </trans-unit>
        <trans-unit id="8dbaff249c36d4481ae2fec17762fdd9c3b87ffc" translate="yes" xml:space="preserve">
          <source>WebSocket.sendTextMessage()</source>
          <target state="translated">WebSocket.sendTextMessage()</target>
        </trans-unit>
        <trans-unit id="37364bf0ebcb82b04781aebf4c68037887d9d6f3" translate="yes" xml:space="preserve">
          <source>WebSocket.status</source>
          <target state="translated">WebSocket.status</target>
        </trans-unit>
        <trans-unit id="3cc530c3bc22ae3bc0c43697c081c73ad94ba0e4" translate="yes" xml:space="preserve">
          <source>WebSocket.statusChanged()</source>
          <target state="translated">WebSocket.statusChanged()</target>
        </trans-unit>
        <trans-unit id="f277032aed27e61917fc53c0484a1faca9baeb36" translate="yes" xml:space="preserve">
          <source>WebSocket.textMessageReceived()</source>
          <target state="translated">WebSocket.textMessageReceived()</target>
        </trans-unit>
        <trans-unit id="da6cc56cf140f2ed0d8b14abefcba008bbbbac16" translate="yes" xml:space="preserve">
          <source>WebSocket.url</source>
          <target state="translated">WebSocket.url</target>
        </trans-unit>
        <trans-unit id="cbcc02f604b303085a9eb27ce020efca2fe6fb16" translate="yes" xml:space="preserve">
          <source>WebSocketServer (QML type)</source>
          <target state="translated">WebSocketServer (QML 유형)</target>
        </trans-unit>
        <trans-unit id="59eb48fb5e578c992c80eb5d1735a548c3485a2f" translate="yes" xml:space="preserve">
          <source>WebSocketServer QML Type</source>
          <target state="translated">WebSocketServer QML 유형</target>
        </trans-unit>
        <trans-unit id="f0984c31280831a4b32bfd8d165a82be068d5685" translate="yes" xml:space="preserve">
          <source>WebSocketServer.accept</source>
          <target state="translated">WebSocketServer.accept</target>
        </trans-unit>
        <trans-unit id="359c97d289adebae04f76520ed53c912c60c9fd4" translate="yes" xml:space="preserve">
          <source>WebSocketServer.clientConnected()</source>
          <target state="translated">WebSocketServer.clientConnected()</target>
        </trans-unit>
        <trans-unit id="aaa9d4c78cf42b8b05a18ca01b59d05e30d14641" translate="yes" xml:space="preserve">
          <source>WebSocketServer.errorString</source>
          <target state="translated">WebSocketServer.errorString</target>
        </trans-unit>
        <trans-unit id="535675aa78403b22a6a51f65e564e3090f275e92" translate="yes" xml:space="preserve">
          <source>WebSocketServer.host</source>
          <target state="translated">WebSocketServer.host</target>
        </trans-unit>
        <trans-unit id="157bacbaaf16348d61b09b426cc9c21914e9e5c3" translate="yes" xml:space="preserve">
          <source>WebSocketServer.listen</source>
          <target state="translated">WebSocketServer.listen</target>
        </trans-unit>
        <trans-unit id="9be1ccf63936479971942fee2b07172abfec1f86" translate="yes" xml:space="preserve">
          <source>WebSocketServer.name</source>
          <target state="translated">WebSocketServer.name</target>
        </trans-unit>
        <trans-unit id="9cd8d098ee821f71e181e344387870a4eaf2643c" translate="yes" xml:space="preserve">
          <source>WebSocketServer.port</source>
          <target state="translated">WebSocketServer.port</target>
        </trans-unit>
        <trans-unit id="865df754f1ce58a620fe7b77813a7c5705f8c766" translate="yes" xml:space="preserve">
          <source>WebSocketServer.url</source>
          <target state="translated">WebSocketServer.url</target>
        </trans-unit>
        <trans-unit id="5fd8957203d02449a377e9d4b44ec5f9d48ec525" translate="yes" xml:space="preserve">
          <source>WebSockets is a web technology providing full-duplex communications channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as &lt;a href=&quot;http://tools.ietf.org/html/rfc6455#&quot;&gt;RFC 6455&lt;/a&gt; in 2011.</source>
          <target state="translated">WebSockets는 단일 TCP 연결을 통해 전이중 통신 채널을 제공하는 웹 기술입니다. WebSocket 프로토콜은 2011 년 IETF에 의해 &lt;a href=&quot;http://tools.ietf.org/html/rfc6455#&quot;&gt;RFC 6455&lt;/a&gt; 로 표준화되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b1e215712971ac4baed9570ad13a61bb4aa3b781" translate="yes" xml:space="preserve">
          <source>WebSockets is a web technology providing full-duplex communications channels over a single TCP connection. The WebSocket protocol was standardized by the IETF as &lt;a href=&quot;http://tools.ietf.org/html/rfc6455#&quot;&gt;RFC 6455&lt;/a&gt; in 2011. &lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt; can both be used in a client application and server application.</source>
          <target state="translated">WebSockets는 단일 TCP 연결을 통해 전이중 통신 채널을 제공하는 웹 기술입니다. WebSocket 프로토콜은 2011 년 IETF에 의해 &lt;a href=&quot;http://tools.ietf.org/html/rfc6455#&quot;&gt;RFC 6455&lt;/a&gt; 로 표준화되었습니다 . &lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt; 은 클라이언트 응용 프로그램과 서버 응용 프로그램에서 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="885c489c2f8a6b92120e69b5de2b45883f6775d7" translate="yes" xml:space="preserve">
          <source>WebView (QML type)</source>
          <target state="translated">WebView (QML 유형)</target>
        </trans-unit>
        <trans-unit id="827b614033071efc2c63d65d4d993276c73e78d9" translate="yes" xml:space="preserve">
          <source>WebView QML Type</source>
          <target state="translated">WebView QML 유형</target>
        </trans-unit>
        <trans-unit id="eb851872c2b19c6866cc3cc03a0b186c029b54c7" translate="yes" xml:space="preserve">
          <source>WebView.canGoBack</source>
          <target state="translated">WebView.canGoBack</target>
        </trans-unit>
        <trans-unit id="556e772d7de6288fda4aa834440fd82a3e3a10d8" translate="yes" xml:space="preserve">
          <source>WebView.canGoForward</source>
          <target state="translated">WebView.canGoForward</target>
        </trans-unit>
        <trans-unit id="01d6d30ec35ee9c1968486d53a2fb2f158b32936" translate="yes" xml:space="preserve">
          <source>WebView.goBack()</source>
          <target state="translated">WebView.goBack()</target>
        </trans-unit>
        <trans-unit id="c77dd030343e8691f50153905d45045b9a035094" translate="yes" xml:space="preserve">
          <source>WebView.goForward()</source>
          <target state="translated">WebView.goForward()</target>
        </trans-unit>
        <trans-unit id="eeb64200760896a269ab89b4d9c2bfef845ddc95" translate="yes" xml:space="preserve">
          <source>WebView.loadHtml()</source>
          <target state="translated">WebView.loadHtml()</target>
        </trans-unit>
        <trans-unit id="5aea0e54040c329364fb04bd8dd6d978cd0e8865" translate="yes" xml:space="preserve">
          <source>WebView.loadProgress</source>
          <target state="translated">WebView.loadProgress</target>
        </trans-unit>
        <trans-unit id="4dde43a37f9096ec81c9e6e13d4a24d10fa86aa5" translate="yes" xml:space="preserve">
          <source>WebView.loading</source>
          <target state="translated">WebView.loading</target>
        </trans-unit>
        <trans-unit id="cc3580281e13aa2c2728e82f2e47cca9b4ac1105" translate="yes" xml:space="preserve">
          <source>WebView.loadingChanged()</source>
          <target state="translated">WebView.loadingChanged()</target>
        </trans-unit>
        <trans-unit id="4250949ce6ab33ee1d1b397b0eafd9d9191265eb" translate="yes" xml:space="preserve">
          <source>WebView.reload()</source>
          <target state="translated">WebView.reload()</target>
        </trans-unit>
        <trans-unit id="bb7c173227b6fe376635f6a86dc62a11e8c81f96" translate="yes" xml:space="preserve">
          <source>WebView.runJavaScript()</source>
          <target state="translated">WebView.runJavaScript()</target>
        </trans-unit>
        <trans-unit id="ad4f865b54e60ed0553766b4d83085e8c9f739b4" translate="yes" xml:space="preserve">
          <source>WebView.stop()</source>
          <target state="translated">WebView.stop()</target>
        </trans-unit>
        <trans-unit id="51058de9d4c17d3a06dad9e94c9dd019a6af2192" translate="yes" xml:space="preserve">
          <source>WebView.title</source>
          <target state="translated">WebView.title</target>
        </trans-unit>
        <trans-unit id="55d62d15c787df0ade5a06967d4bee9479e57217" translate="yes" xml:space="preserve">
          <source>WebView.url</source>
          <target state="translated">WebView.url</target>
        </trans-unit>
        <trans-unit id="b7dd5e35810f2f266ea2c30c1406f512aff95c79" translate="yes" xml:space="preserve">
          <source>WebViewLoadRequest (QML type)</source>
          <target state="translated">WebViewLoadRequest (QML 유형)</target>
        </trans-unit>
        <trans-unit id="671970c5ad73340915882761c18aeed9b56dfd20" translate="yes" xml:space="preserve">
          <source>WebViewLoadRequest QML Type</source>
          <target state="translated">WebViewLoadRequest QML 유형</target>
        </trans-unit>
        <trans-unit id="6d4810263b5877644513482ef317753320da38d1" translate="yes" xml:space="preserve">
          <source>WebViewLoadRequest.errorString</source>
          <target state="translated">WebViewLoadRequest.errorString</target>
        </trans-unit>
        <trans-unit id="da974673bad7a25a2af8556daff61f7ac1806de3" translate="yes" xml:space="preserve">
          <source>WebViewLoadRequest.status</source>
          <target state="translated">WebViewLoadRequest.status</target>
        </trans-unit>
        <trans-unit id="67d567b06712313ae43fbbdf0081d93f362b5a30" translate="yes" xml:space="preserve">
          <source>WebViewLoadRequest.url</source>
          <target state="translated">WebViewLoadRequest.url</target>
        </trans-unit>
        <trans-unit id="b3e03ae44af4edfd2f0f6785a95b2d981795aff6" translate="yes" xml:space="preserve">
          <source>Websockify v0.8.0 can be used to tunnel TCP connections with QT5.12 but it is MANDATORY to specify the base64 or binary subprotocols before calling &lt;a href=&quot;qwebsocket#open&quot;&gt;QWebSocket::open&lt;/a&gt;().</source>
          <target state="translated">Websockify v0.8.0을 사용하여 QT5.12와의 TCP 연결을 터널링 할 수 있지만 &lt;a href=&quot;qwebsocket#open&quot;&gt;QWebSocket :: open&lt;/a&gt; ()을 호출하기 전에 base64 또는 2 진 서브 프로토콜을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="892b2561ad6ab98eb62ee45038da884a629b1645" translate="yes" xml:space="preserve">
          <source>Week numbers can be displayed by setting the &lt;a href=&quot;qml-qtquick-controls-calendar#weekNumbersVisible-prop&quot;&gt;weekNumbersVisible&lt;/a&gt; property to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-calendar#weekNumbersVisible-prop&quot;&gt;weekNumbersVisible&lt;/a&gt; 특성을 &lt;code&gt;true&lt;/code&gt; 로 설정하여 주 번호를 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86019d0d92d2931aad4fe9f82b8882eb97f7ecce" translate="yes" xml:space="preserve">
          <source>WeekNumberColumn</source>
          <target state="translated">WeekNumberColumn</target>
        </trans-unit>
        <trans-unit id="eb5bc02155c1c98619e903c3304fa59dbb999a5c" translate="yes" xml:space="preserve">
          <source>WeekNumberColumn (QML type)</source>
          <target state="translated">WeekNumberColumn (QML 유형)</target>
        </trans-unit>
        <trans-unit id="767a943073d98b5d3856df88505b41707b294713" translate="yes" xml:space="preserve">
          <source>WeekNumberColumn QML Type</source>
          <target state="translated">WeekNumberColumn QML 유형</target>
        </trans-unit>
        <trans-unit id="9a13d84329d5dafdcb7f822e38ae3fff10b4085a" translate="yes" xml:space="preserve">
          <source>WeekNumberColumn.delegate</source>
          <target state="translated">WeekNumberColumn.delegate</target>
        </trans-unit>
        <trans-unit id="b447d1091ed7dd1bebd00325ab31ce82bed51d92" translate="yes" xml:space="preserve">
          <source>WeekNumberColumn.month</source>
          <target state="translated">WeekNumberColumn.month</target>
        </trans-unit>
        <trans-unit id="943a91646ed56fac3a15b75c4dcd4a7788108cb3" translate="yes" xml:space="preserve">
          <source>WeekNumberColumn.year</source>
          <target state="translated">WeekNumberColumn.year</target>
        </trans-unit>
        <trans-unit id="3a391c5b1f457da2b6172f7c76fc4d1dfae3cf44" translate="yes" xml:space="preserve">
          <source>Weight Scale UUID (service). The Weight Scale service exposes weight-related data from a scale for consumer healthcare, sports and fitness applications.</source>
          <target state="translated">체중계 UUID (서비스). 체중계 서비스는 소비자 건강 관리, 스포츠 및 피트니스 애플리케이션을 위해 체중계에서 체중 관련 데이터를 노출합니다.</target>
        </trans-unit>
        <trans-unit id="f767308ef7f2c48da453802b956e6a2d317eda45" translate="yes" xml:space="preserve">
          <source>Well behaved models also implement &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData()&lt;/a&gt; to give tree and table views something to display in their headers.</source>
          <target state="translated">잘 동작하는 모델은 &lt;a href=&quot;qabstractitemmodel#headerData&quot;&gt;headerData ()&lt;/a&gt; 를 구현 하여 트리 및 테이블보기에 헤더에 표시 할 항목을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="97211a8888128314d9ca34d1005f08cb83ed5d9c" translate="yes" xml:space="preserve">
          <source>What</source>
          <target state="translated">What</target>
        </trans-unit>
        <trans-unit id="3a91b96d5e68c04a34191d75ec30f85511472e43" translate="yes" xml:space="preserve">
          <source>What Happens If A State Is Exited Before The Animation Has Finished</source>
          <target state="translated">애니메이션이 끝나기 전에 상태가 종료되면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="a5b95866b545f293e2c22baf583addd6955adb06" translate="yes" xml:space="preserve">
          <source>What Qt Wayland Offers</source>
          <target state="translated">Qt Wayland가 제공하는 것</target>
        </trans-unit>
        <trans-unit id="f1c7876c2431b585c32362c45a116d39b49e3fb2" translate="yes" xml:space="preserve">
          <source>What arguments can appear in square brackets?</source>
          <target state="translated">대괄호 안에 어떤 인수가 나타날 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="bf12281fadddea4a903c385214943b2396829309" translate="yes" xml:space="preserve">
          <source>What attribute of particles is directly affected.</source>
          <target state="translated">입자의 어떤 속성이 직접 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="052744ad88722c540c26b12167c015ec06975d82" translate="yes" xml:space="preserve">
          <source>What happens when you link depends on whether you use frameworks or not. We don't see a compelling reason to recommend one over the other.</source>
          <target state="translated">링크 할 때 발생하는 일은 프레임 워크 사용 여부에 따라 다릅니다. 우리는 서로를 추천해야 할 강력한 이유를 찾지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="295e3792a1a059db7dcede99b827f01d3954a183" translate="yes" xml:space="preserve">
          <source>What if my input namespace is different from my output namespace?</source>
          <target state="translated">입력 네임 스페이스가 출력 네임 스페이스와 다른 경우 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="12767e028b8b33b9ba47990cf494bbd3904aec84" translate="yes" xml:space="preserve">
          <source>What input method specific hints the widget has.</source>
          <target state="translated">위젯에 어떤 입력 방법 관련 힌트가 있습니까?</target>
        </trans-unit>
        <trans-unit id="364007429eff8c97bc4d4b7e513270d89be657be" translate="yes" xml:space="preserve">
          <source>What is QML?</source>
          <target state="translated">QML이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e17b9340ad4720831c95a8522f08aa386cc292e2" translate="yes" xml:space="preserve">
          <source>What is Qt Quick?</source>
          <target state="translated">Qt Quick은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="39ea9b04c66b4480d6c886a257db36daf4f2c330" translate="yes" xml:space="preserve">
          <source>What is a DITA Map?</source>
          <target state="translated">DITA 맵은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f66eacd318bf68ecd7a4172da25f4cbffb450c37" translate="yes" xml:space="preserve">
          <source>What is important is the name of the directory that the qmldir is installed into. When the user imports our module, the QML engine uses the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-qmldir.html#contents-of-a-module-definition-qmldir-file&quot;&gt;module identifier&lt;/a&gt; (&lt;code&gt;TimeExample&lt;/code&gt;) to find the plugin, and so the directory in which it is installed must match the module identifier.</source>
          <target state="translated">중요한 것은 qmldir이 설치된 디렉토리의 이름입니다. 사용자가 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-qmldir.html#contents-of-a-module-definition-qmldir-file&quot;&gt;모듈을 &lt;/a&gt; &lt;code&gt;TimeExample&lt;/code&gt; 때 QML 엔진은 모듈 식별자 ( TimeExample )를 사용하여 플러그인을 찾으므로 플러그인이 설치된 디렉토리는 모듈 식별자와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="9bc2635131e240dcafb2819e5d71d705d8f7a6f8" translate="yes" xml:space="preserve">
          <source>What properties have to be put inside a particular &lt;a href=&quot;qml-qtlocation-dynamicparameter&quot;&gt;DynamicParameter&lt;/a&gt; type for a particular plugin can be found in the documentation of the plugin. Note that DynamicParameters are &lt;b&gt;optional&lt;/b&gt;. By not specifying any of them, the Map will have the default behavior.</source>
          <target state="translated">특정 플러그인에 대한 특정 &lt;a href=&quot;qml-qtlocation-dynamicparameter&quot;&gt;DynamicParameter&lt;/a&gt; 유형에 어떤 속성을 넣어야하는지 플러그인 설명서에서 찾을 수 있습니다. DynamicParameters는 &lt;b&gt;선택 사항&lt;/b&gt; 입니다. 이들 중 하나를 지정하지 않으면 맵에 기본 동작이 있습니다.</target>
        </trans-unit>
        <trans-unit id="99a2cceb544883c9d4fd8511523ad7e154e9e118" translate="yes" xml:space="preserve">
          <source>What tab should be set as current when &lt;a href=&quot;qtabbar#removeTab&quot;&gt;removeTab&lt;/a&gt; is called if the removed tab is also the current tab.</source>
          <target state="translated">제거 된 탭이 현재 탭인 경우 &lt;a href=&quot;qtabbar#removeTab&quot;&gt;removeTab&lt;/a&gt; 을 호출 할 때 현재로 설정해야 할 탭</target>
        </trans-unit>
        <trans-unit id="197a93f48a709674005231e1863485534639c819" translate="yes" xml:space="preserve">
          <source>What this means is that you can implement as many controls as you like for your custom style, and place them almost anywhere. It also allows users to create their own styles for your application.</source>
          <target state="translated">이것이 의미하는 바는 사용자 정의 스타일에 대해 원하는만큼 많은 컨트롤을 구현하고 거의 모든 곳에 배치 할 수 있다는 것입니다. 또한 사용자가 자신의 응용 프로그램에 맞는 스타일을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1993c509dd0c5463e38a4a0589bef8931a264e63" translate="yes" xml:space="preserve">
          <source>What to do with the different client graphics buffers</source>
          <target state="translated">다른 클라이언트 그래픽 버퍼로 수행 할 작업</target>
        </trans-unit>
        <trans-unit id="3febb8f0fb212ae52dcdb454cb322c2c1559a386" translate="yes" xml:space="preserve">
          <source>What you probably want to see instead are the &lt;code&gt;&amp;lt;recipe&amp;gt;&lt;/code&gt; elements that have empty &lt;code&gt;&amp;lt;method&amp;gt;&lt;/code&gt; elements:</source>
          <target state="translated">대신 빈 &lt;code&gt;&amp;lt;method&amp;gt;&lt;/code&gt; 요소 가있는 &lt;code&gt;&amp;lt;recipe&amp;gt;&lt;/code&gt; 요소가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="629d08df1df409e7886c5c11ef223e22e9e9fca7" translate="yes" xml:space="preserve">
          <source>What's new in Qt 4.7</source>
          <target state="translated">Qt 4.7의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="a8469d0d576ee5d765ed335f5bffcc22e8128055" translate="yes" xml:space="preserve">
          <source>Whatever form the underlying data structure takes, it is usually a good idea to supplement the standard &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; API in specialized models with one that allows more natural access to the underlying data structure. This makes it easier to populate the model with data, yet still enables other general model/view components to interact with it using the standard API. The model described below provides a custom constructor for just this purpose.</source>
          <target state="translated">기본 데이터 구조에 어떤 형태를 &lt;a href=&quot;qabstractitemmodel&quot;&gt;취하 든&lt;/a&gt; 기본 데이터 구조에보다 자연스럽게 액세스 할 수있는 특수 모델 의 표준 QAbstractItemModel API 를 보완하는 것이 좋습니다 . 이를 통해 모델로 데이터를 더 쉽게 채울 수 있지만 표준 모델을 사용하여 다른 일반 모델 / 뷰 구성 요소와 상호 작용할 수 있습니다. 아래 설명 된 모델은이 목적을위한 맞춤형 생성자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8eec75ee54baf1c26ea1a419c0e75e480e7d107b" translate="yes" xml:space="preserve">
          <source>WhatsThis</source>
          <target state="translated">WhatsThis</target>
        </trans-unit>
        <trans-unit id="ee3f5d5b9f3adb42ad9be6c7bc599808b7e12183" translate="yes" xml:space="preserve">
          <source>Wheel events are sent to the widget under the mouse cursor, but if that widget does not handle the event they are sent to the focus widget. Wheel events are generated for both mouse wheels and trackpad scroll gestures. There are two ways to read the wheel event delta: &lt;a href=&quot;qwheelevent#angleDelta&quot;&gt;angleDelta&lt;/a&gt;() returns the delta in wheel degrees. This value is always provided. &lt;a href=&quot;qwheelevent#pixelDelta&quot;&gt;pixelDelta&lt;/a&gt;() returns the delta in screen pixels and is available on platforms that have high-resolution trackpads, such as &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;. If that is the case, &lt;a href=&quot;qwheelevent#source&quot;&gt;source&lt;/a&gt;() will return &lt;a href=&quot;qt#MouseEventSource-enum&quot;&gt;Qt::MouseEventSynthesizedBySystem&lt;/a&gt;.</source>
          <target state="translated">휠 이벤트는 마우스 커서 아래의 위젯으로 전송되지만 해당 위젯이 이벤트를 처리하지 않으면 포커스 위젯으로 전송됩니다. 휠 이벤트는 마우스 휠과 트랙 패드 스크롤 제스처 모두에 대해 생성됩니다. 휠 이벤트 델타를 읽는 방법에는 두 가지가 있습니다. &lt;a href=&quot;qwheelevent#angleDelta&quot;&gt;angleDelta&lt;/a&gt; ()는 델타를 휠 각도로 반환합니다. 이 값은 항상 제공됩니다. &lt;a href=&quot;qwheelevent#pixelDelta&quot;&gt;pixelDelta&lt;/a&gt; ()는 화면 픽셀의 델타를 반환하며 &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt; 와 같은 고해상도 트랙 패드가있는 플랫폼에서 사용할 수 있습니다 . 이 경우 &lt;a href=&quot;qwheelevent#source&quot;&gt;source&lt;/a&gt; ()는 &lt;a href=&quot;qt#MouseEventSource-enum&quot;&gt;Qt :: MouseEventSynthesizedBySystem&lt;/a&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3d5d09f0bf28a26f226208f3c55c481ff5cd1071" translate="yes" xml:space="preserve">
          <source>Wheel events in the graphics view framework</source>
          <target state="translated">그래픽 뷰 프레임 워크의 휠 이벤트</target>
        </trans-unit>
        <trans-unit id="2f9a04144c12aa6a0a70aca28f6f197de1ab5301" translate="yes" xml:space="preserve">
          <source>WheelEvent</source>
          <target state="translated">WheelEvent</target>
        </trans-unit>
        <trans-unit id="a1823b970b11b8a9b89c9306a5840acc5dbf562b" translate="yes" xml:space="preserve">
          <source>WheelEvent (QML type)</source>
          <target state="translated">WheelEvent (QML 유형)</target>
        </trans-unit>
        <trans-unit id="246550e1a76a3ff97fe84d5f63e2fa253b921c33" translate="yes" xml:space="preserve">
          <source>WheelEvent QML Type</source>
          <target state="translated">WheelEvent QML 유형</target>
        </trans-unit>
        <trans-unit id="cbbe58bce25951834630e64dd9b6a6c7bc7d30d5" translate="yes" xml:space="preserve">
          <source>WheelEvent.accepted</source>
          <target state="translated">WheelEvent.accepted</target>
        </trans-unit>
        <trans-unit id="c8ac526eec73ae51b08ba4dbf883916d54d111d6" translate="yes" xml:space="preserve">
          <source>WheelEvent.angleDelta</source>
          <target state="translated">WheelEvent.angleDelta</target>
        </trans-unit>
        <trans-unit id="a97374302b0712b79d4c6e63cd0e390a4568ad8e" translate="yes" xml:space="preserve">
          <source>WheelEvent.buttons</source>
          <target state="translated">WheelEvent.buttons</target>
        </trans-unit>
        <trans-unit id="26dc4a0386af7486bb281e868258f3a863e4f7ec" translate="yes" xml:space="preserve">
          <source>WheelEvent.inverted</source>
          <target state="translated">WheelEvent.inverted</target>
        </trans-unit>
        <trans-unit id="031bafb46460ea761ccd0b2318eed3dba81a7561" translate="yes" xml:space="preserve">
          <source>WheelEvent.modifiers</source>
          <target state="translated">WheelEvent.modifiers</target>
        </trans-unit>
        <trans-unit id="00a8c077d0e8964bb14dd415e1ad20ce653df397" translate="yes" xml:space="preserve">
          <source>WheelEvent.pixelDelta</source>
          <target state="translated">WheelEvent.pixelDelta</target>
        </trans-unit>
        <trans-unit id="c1dacb154a0136c85af43c883ae831be9ce68e06" translate="yes" xml:space="preserve">
          <source>WheelEvent.x</source>
          <target state="translated">WheelEvent.x</target>
        </trans-unit>
        <trans-unit id="230ef11cb03e402544f9e1995cee252cbe3ecffa" translate="yes" xml:space="preserve">
          <source>WheelEvent.y</source>
          <target state="translated">WheelEvent.y</target>
        </trans-unit>
        <trans-unit id="769bb19e615b7f8e2809e5882e2d05a18f57a531" translate="yes" xml:space="preserve">
          <source>When</source>
          <target state="translated">When</target>
        </trans-unit>
        <trans-unit id="4ed7422c4b381275d6494ce5497b021976af6b6c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;configure-options#&quot;&gt;configuring&lt;/a&gt; Qt for installation, it is possible to ensure that it is built to include debug symbols that can make it easier to track bugs in applications and libraries. However, on some platforms, building Qt in debug mode will cause applications to be larger than desirable.</source>
          <target state="translated">설치를 위해 Qt를 &lt;a href=&quot;configure-options#&quot;&gt;구성&lt;/a&gt; 할 때 , 응용 프로그램 및 라이브러리의 버그를보다 쉽게 ​​추적 할 수있는 디버그 기호를 포함하도록 빌드 될 수 있습니다. 그러나 일부 플랫폼에서는 디버그 모드에서 Qt를 빌드하면 응용 프로그램이 원하는 것보다 더 커집니다.</target>
        </trans-unit>
        <trans-unit id="369d9cfc62e315d40c391ad82bfdaa472a18113a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;DockWidgetVerticalTitleBar&lt;/a&gt; is set on &lt;a href=&quot;qdockwidget&quot;&gt;QDockWidget&lt;/a&gt;, the title bar widget is repositioned accordingly. In &lt;a href=&quot;qwidget#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt;(), the title bar should check what orientation it should assume:</source>
          <target state="translated">때 &lt;a href=&quot;qdockwidget#DockWidgetFeature-enum&quot;&gt;DockWidgetVerticalTitleBar이&lt;/a&gt; 설정되어 &lt;a href=&quot;qdockwidget&quot;&gt;QDockWidget&lt;/a&gt; , 이에 따라 재배치 위젯 제목 표시 줄. 에서 &lt;a href=&quot;qwidget#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt; (), 제목 표시 줄은 생각해야하는지 방향을 확인해야합니다 :</target>
        </trans-unit>
        <trans-unit id="db8e1da66e519efacbcf5ae28e29d8b6a42af820" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qml-qtgraphicaleffects-innershadow#fast-prop&quot;&gt;fast&lt;/a&gt; property is set to true, this property has no effect.</source>
          <target state="translated">때 &lt;a href=&quot;qml-qtgraphicaleffects-innershadow#fast-prop&quot;&gt;빠른&lt;/a&gt; 속성이 true로 설정되어 있으며,이 건물은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="068fe878b2fd1b5879499e8ded388d63b122f13f" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qml-qtquick-controls2-scrollbar&quot;&gt;ScrollBar&lt;/a&gt; is attached &lt;a href=&quot;qml-qtquick-controls2-scrollbar#vertical-attached-prop&quot;&gt;vertically&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-controls2-scrollbar#horizontal-attached-prop&quot;&gt;horizontally&lt;/a&gt; to a Flickable, its geometry and the following properties are automatically set and updated as appropriate:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-scrollbar&quot;&gt;ScrollBar&lt;/a&gt; 가 Flickable 에 &lt;a href=&quot;qml-qtquick-controls2-scrollbar#vertical-attached-prop&quot;&gt;세로&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-controls2-scrollbar#horizontal-attached-prop&quot;&gt;가로&lt;/a&gt; 로 연결 되면 해당 지오메트리와 다음 속성이 자동으로 설정되고 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="2537c42519e3b600623d35e309f6c9c1c2ea818a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qml-qtquick-extras-gauge#orientation-prop&quot;&gt;orientation&lt;/a&gt; is &lt;code&gt;Qt.Horizontal&lt;/code&gt;, the valid values are:</source>
          <target state="translated">때 &lt;a href=&quot;qml-qtquick-extras-gauge#orientation-prop&quot;&gt;방향&lt;/a&gt; 이다 &lt;code&gt;Qt.Horizontal&lt;/code&gt; , 유효한 값은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="d3a11e0e6e5e393e9278e077b734d35f0fe6c943" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qml-qtquick-shapes-shape#rendererType-prop&quot;&gt;rendererType&lt;/a&gt; is &lt;code&gt;Shape.GeometryRenderer&lt;/code&gt;, the input path is triangulated on the CPU during the polishing phase of the Shape. This is potentially expensive. To offload this work to separate worker threads, set this property to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;qml-qtquick-shapes-shape#rendererType-prop&quot;&gt;rendererType가&lt;/a&gt; 있다 &lt;code&gt;Shape.GeometryRenderer&lt;/code&gt; 입력 경로 모양의 연마 단계 동안 CPU에 삼각된다. 이것은 잠재적으로 비싸다. 이 작업을 분리하여 작업자 스레드를 분리하려면이 특성을 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c18767293ff3b0e325bc6a72a1b6a1318d5de9d" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qml-qtquick-shapes-shapepath#joinStyle-prop&quot;&gt;joinStyle&lt;/a&gt; is set to &lt;code&gt;ShapePath.MiterJoin&lt;/code&gt;, this property specifies how far the miter join can extend from the join point.</source>
          <target state="translated">때 &lt;a href=&quot;qml-qtquick-shapes-shapepath#joinStyle-prop&quot;&gt;joinStyle가&lt;/a&gt; 설정되어 &lt;code&gt;ShapePath.MiterJoin&lt;/code&gt; (가) 조인 포인트에서, 이음에 가입하는 방법까지이 부동산에 지정 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8048e21c76f9446c61b651141b0ad181583adef0" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qobject&quot;&gt;QObjects&lt;/a&gt; are created on the heap (i.e., created with</source>
          <target state="translated">&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 가 힙에 생성 될 때 (즉,</target>
        </trans-unit>
        <trans-unit id="4bc3005be93ece2557efc1b3b70d2d777b42720f" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qobject&quot;&gt;QObjects&lt;/a&gt; are created on the stack, the same behavior applies. Normally, the order of destruction still doesn't present a problem. Consider the following snippet:</source>
          <target state="translated">&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 가 스택에서 생성 될 때 동일한 동작이 적용됩니다. 일반적으로, 파괴 순서는 여전히 문제가되지 않습니다. 다음 스 니펫을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="29f1b3daf43311cef69762476c52320fee461407" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qopenglcontext#create&quot;&gt;create&lt;/a&gt;() is called with native handles set, &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; does not take ownership of the handles, so destroying the &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; does not destroy the native context.</source>
          <target state="translated">때 &lt;a href=&quot;qopenglcontext#create&quot;&gt;생성&lt;/a&gt; 기본 핸들 세트 ()를 호출, &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext는&lt;/a&gt; 그래서 파괴, 핸들의 소유권을하지 않는 &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext를&lt;/a&gt; 네이티브 환경을 파괴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ed83495c3a9572cee487cfe4ab135ee582eb1bb" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qpainter#begin&quot;&gt;QPainter::begin&lt;/a&gt;() is called, the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; it operates on is prepared for a new page, enabling the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; to be used immediately to paint the first page in a document. Once the first page has been painted, &lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt;() can be called to request a new blank page to paint on, or &lt;a href=&quot;qpainter#end&quot;&gt;QPainter::end&lt;/a&gt;() can be called to finish printing. The second page and all following pages are prepared using a call to &lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt;() before they are painted.</source>
          <target state="translated">때 &lt;a href=&quot;qpainter#begin&quot;&gt;QPainter를이 :: 시작&lt;/a&gt; 이라고 ()를 &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; 이 켜져 작동이 가능하게 새로운 페이지에 대한 준비가되어 &lt;a href=&quot;qpainter&quot;&gt;QPainter를이&lt;/a&gt; 문서의 첫 번째 페이지를 페인트 즉시 사용 할 수 있습니다. 첫 번째 페이지가 페인트되면 &lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt; ()를 호출하여 페인트 할 새 빈 페이지를 요청하거나 &lt;a href=&quot;qpainter#end&quot;&gt;QPainter :: end&lt;/a&gt; ()를 호출하여 인쇄를 완료 할 수 있습니다. 두 번째 페이지와 그 다음 페이지는 모두 페인트하기 전에 &lt;a href=&quot;qprinter#newPage&quot;&gt;newPage&lt;/a&gt; ()를 호출하여 준비 합니다.</target>
        </trans-unit>
        <trans-unit id="2132738322003eb64c9c6a02ba3636be358ff774" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit&lt;/a&gt; is used read-only the key bindings are limited to navigation, and text may only be selected with the mouse:</source>
          <target state="translated">때 &lt;a href=&quot;qplaintextedit&quot;&gt;QPlainTextEdit이&lt;/a&gt; 사용되는 키 바인딩 내비게이션으로 제한됩니다 읽기 전용, 텍스트 만 마우스로 선택할 수있다 :</target>
        </trans-unit>
        <trans-unit id="a1cbf613a60143088f9ded6faf6fa5ff31064559" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qqmlcomponent&quot;&gt;QQmlComponent&lt;/a&gt; constructs an instance, it occurs in three steps:</source>
          <target state="translated">&lt;a href=&quot;qqmlcomponent&quot;&gt;QQmlComponent&lt;/a&gt; 가 인스턴스를 구성 할 때 세 단계로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1d3dd2b06d7abdd2012e8653307609b9dca7b6c0" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qquickitem#polish&quot;&gt;polish&lt;/a&gt;() is called, the scene graph schedules a polish event for this item. When the scene graph is ready to render this item, it calls updatePolish() to do any item layout as required before it renders the next frame.</source>
          <target state="translated">때 &lt;a href=&quot;qquickitem#polish&quot;&gt;폴란드어&lt;/a&gt; ()이 항목에 대한 장면 그래프 일정 폴란드어 이벤트라고합니다. 장면 그래프에서이 항목을 렌더링 할 준비가되면 updatePolish ()를 호출하여 다음 프레임을 렌더링하기 전에 필요한 항목 레이아웃을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="fdb2404d8f94babd0d1763bb41f0ba653ebe7903" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qregexpvalidator&quot;&gt;QRegExpValidator&lt;/a&gt; determines whether a string is &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Acceptable&lt;/a&gt; or not, the regexp is treated as if it begins with the start of string assertion (&lt;b&gt;^&lt;/b&gt;) and ends with the end of string assertion (&lt;b&gt;$&lt;/b&gt;); the match is against the entire input string, or from the given position if a start position greater than zero is given.</source>
          <target state="translated">경우 &lt;a href=&quot;qregexpvalidator&quot;&gt;QRegExpValidator가&lt;/a&gt; 문자열인지의 여부를 판정 &lt;a href=&quot;qvalidator#State-enum&quot;&gt;수락&lt;/a&gt; 여부는 문자열 표명 (개시로 시작하는 경우와 같이 정규 표현식을 치료한다 &lt;b&gt;^&lt;/b&gt; 문자열 표명 (끝)와 단부와 &lt;b&gt;$&lt;/b&gt; ); 일치는 전체 입력 문자열에 대해 또는 시작 위치가 0보다 큰 경우 지정된 위치에서 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a05be2c57c6c960755c5ba666c019e97d5fb9256" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qsensor#connectToBackend&quot;&gt;QSensor::connectToBackend&lt;/a&gt;() is called, the &lt;a href=&quot;qsensormanager#createBackend&quot;&gt;createBackend&lt;/a&gt;() function will be called.</source>
          <target state="translated">때 &lt;a href=&quot;qsensor#connectToBackend&quot;&gt;QSensor :: connectToBackend은&lt;/a&gt; ()가 호출되면, &lt;a href=&quot;qsensormanager#createBackend&quot;&gt;createBackend&lt;/a&gt; () 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b989e35c468a854106b411ae681aa5098d09dc07" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; paints itself, it creates a &lt;a href=&quot;qstyleoptionspinbox&quot;&gt;QStyleOptionSpinBox&lt;/a&gt; and asks the style to draw &lt;code&gt;CC_SpinBox&lt;/code&gt;. The edit field is a line edit that is a child of the spin box. The dimensions of the field are calculated by the style with &lt;code&gt;SC_SpinBoxEditField&lt;/code&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox이&lt;/a&gt; 자체 페인트, 그것은 생성 &lt;a href=&quot;qstyleoptionspinbox&quot;&gt;QStyleOptionSpinBox을&lt;/a&gt; 하고 그릴 스타일 묻는 &lt;code&gt;CC_SpinBox&lt;/code&gt; 을 . 편집 필드는 스핀 상자의 자식 인 라인 편집입니다. 필드의 크기는 &lt;code&gt;SC_SpinBoxEditField&lt;/code&gt; 를 사용한 스타일로 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d6ef76b83d0b24340125905e68a2cd58df5e13a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; paints its items, it draws &lt;a href=&quot;qstyle#ControlElement-enum&quot;&gt;CE_ItemViewItem&lt;/a&gt;, and calculates their size with &lt;a href=&quot;qstyle#ContentsType-enum&quot;&gt;CT_ItemViewItem&lt;/a&gt;. Note also that it uses &lt;a href=&quot;qstyle#SubElement-enum&quot;&gt;SE_ItemViewItemText&lt;/a&gt; to set the size of editors. When implementing a style to customize drawing of item views, you need to check the implementation of &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt; (and any other subclasses from which your style inherits). This way, you find out which and how other style elements are painted, and you can then reimplement the painting of elements that should be drawn differently.</source>
          <target state="translated">때 &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate은&lt;/a&gt; 해당 항목을 페인트, 그것은 그립니다 &lt;a href=&quot;qstyle#ControlElement-enum&quot;&gt;CE_ItemViewItem을&lt;/a&gt; 하고와 크기를 계산 &lt;a href=&quot;qstyle#ContentsType-enum&quot;&gt;CT_ItemViewItem을&lt;/a&gt; . 또한 &lt;a href=&quot;qstyle#SubElement-enum&quot;&gt;SE_ItemViewItemText&lt;/a&gt; 를 사용하여 편집기 크기를 설정합니다. 항목보기의 도면을 사용자 정의하기 위해 스타일을 구현할 때 &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt; (및 스타일이 상속하는 다른 서브 클래스) 의 구현을 확인해야합니다 . 이런 식으로, 어떤 스타일 요소가 어떤 스타일로 그려 지는지 알아 낸 다음 다르게 그려야하는 요소의 그림을 다시 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55966be334da9caaf8746ba7acb096ad107e6834" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;setDefaultFormat&lt;/a&gt;() is not called, this is a default-constructed &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;qsurfaceformat#setDefaultFormat&quot;&gt;setDefaultFormat가&lt;/a&gt; ()가 호출되지 않으며, 이것은 기본적으로 구성되어 &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c7efa0e1fde6dd5d2897211dec34038ac8d3a942" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qtextblock&quot;&gt;QTextBlock&lt;/a&gt;s are created, the &lt;a href=&quot;qtextdocument#defaultTextOption&quot;&gt;defaultTextOption&lt;/a&gt; is set on their &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt;. This allows setting global properties for the document such as the default word wrap mode.</source>
          <target state="translated">때 &lt;a href=&quot;qtextblock&quot;&gt;QTextBlock&lt;/a&gt; 의이 생성의 &lt;a href=&quot;qtextdocument#defaultTextOption&quot;&gt;defaultTextOption는&lt;/a&gt; 자신에 설정되어 &lt;a href=&quot;qtextlayout&quot;&gt;QTextLayout&lt;/a&gt; . 이를 통해 기본 단어 줄 바꿈 모드와 같은 문서의 전역 속성을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b325a2734b254fce15499dccbb94d7fc5d4dd1e5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt; is used read-only the key bindings are limited to navigation, and text may only be selected with the mouse:</source>
          <target state="translated">하면 &lt;a href=&quot;qtextedit&quot;&gt;은 QTextEdit가&lt;/a&gt; 사용되는 키 바인딩 내비게이션으로 제한됩니다 읽기 전용, 텍스트 만 마우스로 선택할 수있다 :</target>
        </trans-unit>
        <trans-unit id="800ac5001a1f10a43a1506615ad1662fb3b47f34" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; is in Running state, this value is updated continuously as a function of the duration and direction of the timeline. Otherwise, it is value that was current when &lt;a href=&quot;qtimeline#stop&quot;&gt;stop&lt;/a&gt;() was called last, or the value set by setCurrentTime().</source>
          <target state="translated">경우 &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine이&lt;/a&gt; 실행 상태에 있고,이 값은 타임 라인의 길이 방향의 함수로서 연속적으로 갱신된다. 그렇지 않으면, &lt;a href=&quot;qtimeline#stop&quot;&gt;stop&lt;/a&gt; ()이 마지막으로 호출 되었을 때의 현재 값이거나 setCurrentTime ()에 의해 설정된 값입니다.</target>
        </trans-unit>
        <trans-unit id="670177e5cc964489b3254306d4402e54f95e632a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qtquick-statesanimations-animations#&quot;&gt;Transitions&lt;/a&gt; are used to animate state changes, they animate properties from their values in the current state to those defined in the new state (as defined by &lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges&lt;/a&gt; objects). However, it is sometimes desirable to set a property value</source>
          <target state="translated">경우 &lt;a href=&quot;qtquick-statesanimations-animations#&quot;&gt;천이&lt;/a&gt; 애니메이션 상태의 변경에 사용되고, 그들은 (의해 정의되는 새로운 상태에 정의 된 현재 상태에서의 값으로부터 애니메이션 속성 &lt;a href=&quot;qml-qtquick-propertychanges&quot;&gt;PropertyChanges의&lt;/a&gt; 개체). 그러나 때로는 속성 값을 설정하는 것이 바람직합니다</target>
        </trans-unit>
        <trans-unit id="adf54fd7881b01dd5fbb317fe0878e5876b7ee5a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qvulkanwindow#supportsGrab&quot;&gt;supportsGrab&lt;/a&gt;() returns true, &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow&lt;/a&gt; can perform readbacks from the color buffer into a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. &lt;a href=&quot;qvulkanwindow#grab&quot;&gt;grab&lt;/a&gt;() is a slow and inefficient operation, so frequent usage should be avoided. It is nonetheless valuable since it allows applications to take screenshots, or tools and tests to process and verify the output of the GPU rendering.</source>
          <target state="translated">경우 &lt;a href=&quot;qvulkanwindow#supportsGrab&quot;&gt;supportsGrab가&lt;/a&gt; true를 반환 &lt;a href=&quot;qvulkanwindow&quot;&gt;QVulkanWindow은&lt;/a&gt; (A) 내로 컬러 버퍼로부터 readbacks를 수행 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; . &lt;a href=&quot;qvulkanwindow#grab&quot;&gt;grab&lt;/a&gt; ()는 느리고 비효율적 인 작업이므로 자주 사용하지 않아야합니다. 그럼에도 불구하고 응용 프로그램이 스크린 샷 또는 도구 및 테스트를 수행하여 GPU 렌더링의 출력을 처리하고 확인할 수 있기 때문에 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6823f0c205033d4ea128122af4b97d19b1b0c274" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; accesses resources (e.g., calling &lt;code&gt;fn:doc()&lt;/code&gt; to load a file, or accessing a device via a bound variable), the event loop is used, which means events will be processed. To avoid processing events when &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; accesses resources, create your &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; instance in a separate thread.</source>
          <target state="translated">&lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery가&lt;/a&gt; 리소스에 액세스 할 때 (예 &lt;code&gt;fn:doc()&lt;/code&gt; 를 호출 하여 파일을로드하거나 바운드 변수를 통해 장치에 액세스) 이벤트 루프가 사용되므로 이벤트가 처리됩니다. &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery가&lt;/a&gt; 자원에 액세스 할 때 이벤트 처리를 피하려면 별도의 스레드에서 &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; 인스턴스를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a4303763eb160478daacc616e1e09a84ccb3fd3" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; calls &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler::message&lt;/a&gt;(), the arguments are as follows:</source>
          <target state="translated">&lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; 가 &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler :: message&lt;/a&gt; ()를 호출 할 때 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2414e2eb1638148ea5acad1b6c425e2a2fa8d639" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery&lt;/a&gt;() is called, the query text is compiled into an internal data structure and optimized. The optimized form can then be reused for multiple evaluations of the query. Since the compile-and-optimize process can be expensive, repeating it for the same query should be avoided by using a separate instance of &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; for each query text.</source>
          <target state="translated">경우 &lt;a href=&quot;qxmlquery#setQuery&quot;&gt;setQuery는&lt;/a&gt; ()가 호출되면, 쿼리 텍스트는 내부 데이터 구조로 컴파일되고 최적화된다. 그런 다음 쿼리의 여러 평가에 최적화 된 양식을 재사용 할 수 있습니다. 컴파일 및 최적화 프로세스는 비용이 많이들 수 있으므로 각 쿼리 텍스트에 대해 별도의 &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; 인스턴스를 사용하여 동일한 쿼리에 대해 반복하는 과정을 피해야 합니다.</target>
        </trans-unit>
        <trans-unit id="8f0e33d48640a9980a60399682ba53ff818618de" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlschema&quot;&gt;QXmlSchema&lt;/a&gt; calls &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler::message&lt;/a&gt;(), the arguments are as follows:</source>
          <target state="translated">&lt;a href=&quot;qxmlschema&quot;&gt;QXmlSchema&lt;/a&gt; 가 &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler :: message&lt;/a&gt; ()를 호출 할 때 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34a36de9f3978a9dc52660020f38e10757c3b33a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;qxmlschemavalidator&quot;&gt;QXmlSchemaValidator&lt;/a&gt; calls &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler::message&lt;/a&gt;(), the arguments are as follows:</source>
          <target state="translated">&lt;a href=&quot;qxmlschemavalidator&quot;&gt;QXmlSchemaValidator&lt;/a&gt; 가 &lt;a href=&quot;qabstractmessagehandler#message&quot;&gt;QAbstractMessageHandler :: message&lt;/a&gt; ()를 호출 할 때 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="abc180cdaa67db2334bc9aec8221bc677db91dc0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&amp;lt;param&amp;gt;&lt;/code&gt; elements are used in the &lt;code&gt;&amp;lt;send&amp;gt;&lt;/code&gt; element, the data will contain a &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; where the key is the</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;param&amp;gt;&lt;/code&gt; 에서 사용되는 요소 &lt;code&gt;&amp;lt;send&amp;gt;&lt;/code&gt; 소자, 포함될 데이터 &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap는&lt;/a&gt; 키가되는 위치</target>
        </trans-unit>
        <trans-unit id="a06133ee79a232acbfba343775e247dd1fc22db2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;GL_ARB_framebuffer_sRGB&lt;/code&gt; or &lt;code&gt;GL_EXT_framebuffer_sRGB&lt;/code&gt; is supported by the platform and this value is set, the window will be created with an sRGB-capable default framebuffer. Note that some platforms may return windows with a sRGB-capable default framebuffer even when not requested explicitly.</source>
          <target state="translated">때 &lt;code&gt;GL_ARB_framebuffer_sRGB&lt;/code&gt; 또는 &lt;code&gt;GL_EXT_framebuffer_sRGB&lt;/code&gt; 이 플랫폼에서 지원되며,이 값을 설정, 윈도우는 sRGB를 지원 기본 프레임 버퍼에 생성됩니다. 일부 플랫폼에서는 명시 적으로 요청하지 않은 경우에도 sRGB 가능 기본 프레임 버퍼가있는 창을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed4d9b70602719a6967792783570916cdfb715ef" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;button&lt;/code&gt; is clicked, the machine will transition into state &lt;code&gt;s2&lt;/code&gt;, which will set the geometry of the button, and then pop up a message box to alert the user that the geometry has been changed.</source>
          <target state="translated">때 &lt;code&gt;button&lt;/code&gt; 클릭, 기계 상태로 전환됩니다 &lt;code&gt;s2&lt;/code&gt; 버튼의 형상을 설정하고 형상이 변경되었음을 사용자에게 경고하는 메시지 상자가 나타납니다한다.</target>
        </trans-unit>
        <trans-unit id="2388f2e21addac6210aabde322ea581bb6afffb1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;mode&lt;/code&gt; is not defined, the mode that is reported as preferred by the system is chosen. The accepted values for &lt;code&gt;mode&lt;/code&gt; are: &lt;code&gt;off&lt;/code&gt;, &lt;code&gt;current&lt;/code&gt;, &lt;code&gt;preferred&lt;/code&gt;, &lt;code&gt;skip&lt;/code&gt;, width&lt;code&gt;x&lt;/code&gt;height, width&lt;code&gt;x&lt;/code&gt;height&lt;code&gt;@&lt;/code&gt;vrefresh, or a modeline string.</source>
          <target state="translated">시 &lt;code&gt;mode&lt;/code&gt; 정의되어 있지 않은, 시스템이 바람직한 것으로보고 모드가 선택된다. &lt;code&gt;mode&lt;/code&gt; 에 허용되는 값 은 &lt;code&gt;off&lt;/code&gt; , &lt;code&gt;current&lt;/code&gt; , &lt;code&gt;preferred&lt;/code&gt; , &lt;code&gt;skip&lt;/code&gt; , width &lt;code&gt;x&lt;/code&gt; height, width &lt;code&gt;x&lt;/code&gt; height &lt;code&gt;@&lt;/code&gt; vrefresh 또는 modeline string입니다.</target>
        </trans-unit>
        <trans-unit id="bebb2b33e2691fc3d175656c1b70af1ee1b6346d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;reanchorToRight&lt;/code&gt; is called, the function first sets the right anchor. At that point, both left and right anchors are set, and the item will be stretched horizontally to fill its parent. When the left anchor is unset, the new width will remain. Thus when updating anchors within JavaScript, you should first unset any anchors that are no longer required, and only then set any new anchors that are required, as shown below:</source>
          <target state="translated">&lt;code&gt;reanchorToRight&lt;/code&gt; 때 호출 함수는 먼저 오른쪽 앵커를 설정한다. 이 시점에서 왼쪽 및 오른쪽 앵커가 모두 설정되고 항목이 부모를 채우기 위해 가로로 늘어납니다. 왼쪽 앵커를 설정하지 않으면 새 너비가 유지됩니다. 따라서 JavaScript 내에서 앵커를 업데이트 할 때는 먼저 더 이상 필요하지 않은 앵커를 설정 해제 한 다음 아래에 표시된대로 필요한 새 앵커 만 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8825f7725f1dc91940c2a034ec29bd99db520ddf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;s1&lt;/code&gt; 's final state is entered, &lt;code&gt;s1&lt;/code&gt; will automatically emit &lt;a href=&quot;qml-qtqml-statemachine-state#finished-signal&quot;&gt;finished&lt;/a&gt;. We use a signal transition to cause this event to trigger a state change:</source>
          <target state="translated">시 &lt;code&gt;s1&lt;/code&gt; 의 최종 상태를 입력 할 때, &lt;code&gt;s1&lt;/code&gt; 자동으로 내 보냅니다 &lt;a href=&quot;qml-qtqml-statemachine-state#finished-signal&quot;&gt;완료&lt;/a&gt; . 이 이벤트가 상태 변경을 트리거하도록 신호 전이를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a068e7c1d71be79be1747b295f8d0bdf7d0f76ad" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;s1&lt;/code&gt; 's final state is entered, &lt;code&gt;s1&lt;/code&gt; will automatically emit &lt;a href=&quot;qstate#finished&quot;&gt;finished()&lt;/a&gt;. We use a signal transition to cause this event to trigger a state change:</source>
          <target state="translated">하면 &lt;code&gt;s1&lt;/code&gt; 의 최종 상태가 입력된다 &lt;code&gt;s1&lt;/code&gt; 자동으로 발광한다 &lt;a href=&quot;qstate#finished&quot;&gt;완료 ()&lt;/a&gt; . 이 이벤트가 상태 변경을 트리거하도록 신호 전이를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7c85d7dd31dd96c49b09a16e731e181b35179393" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;text&lt;/code&gt; changes, the C++ property &lt;code&gt;enteredText&lt;/code&gt; will update automatically.</source>
          <target state="translated">때 &lt;code&gt;text&lt;/code&gt; 변경의 C ++ 특성 &lt;code&gt;enteredText&lt;/code&gt; 가 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="274f974610c7463228dfb5154f647e8c8a8ccdcb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, all generated numbers appearing in various series and axis labels will be localized using the &lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt; set with the &lt;a href=&quot;qchart#locale-prop&quot;&gt;locale&lt;/a&gt; property. When &lt;code&gt;false&lt;/code&gt;, the</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; , 모든 생성 된 다양한 시리즈에 나오는 숫자와 축 라벨은 사용 현지화됩니다 &lt;a href=&quot;qlocale&quot;&gt;QLocale의&lt;/a&gt; 설정 &lt;a href=&quot;qchart#locale-prop&quot;&gt;로케일&lt;/a&gt; 속성을. 때 &lt;code&gt;false&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="36e568b70799170c0d96b90a8147537bfc741c8b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, all generated numbers appearing in various series and axis labels will be localized using the &lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt; set with the &lt;a href=&quot;qml-qtcharts-chartview#locale-prop&quot;&gt;locale&lt;/a&gt; property. When &lt;code&gt;false&lt;/code&gt;, the</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; , 모든 생성 된 다양한 시리즈에 나오는 숫자와 축 라벨은 사용 현지화됩니다 &lt;a href=&quot;qlocale&quot;&gt;QLocale의&lt;/a&gt; 설정 &lt;a href=&quot;qml-qtcharts-chartview#locale-prop&quot;&gt;로케일&lt;/a&gt; 속성을. 때 &lt;code&gt;false&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="3e953b3a9be5222efb277759886bb97613fdfda7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, the style should underline the menu item's label mnemonic.</source>
          <target state="translated">때 &lt;code&gt;true&lt;/code&gt; , 스타일이 메뉴 항목의 라벨이 니모닉 강조한다.</target>
        </trans-unit>
        <trans-unit id="21a5b61887b0cac6a56dd588dce0ad7f3bbdb837" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;virtualIndex&lt;/code&gt; is not sufficient, the property &lt;code&gt;virtualPos&lt;/code&gt; can be used to explicitly specify the top-left position of the screen in question. Taking the previous example and assuming a resolution of 1080p for HDMI1, the following places a second HDMI-based screen below the first one:</source>
          <target state="translated">때 &lt;code&gt;virtualIndex&lt;/code&gt; 가 충분하지 않습니다, 속성 &lt;code&gt;virtualPos&lt;/code&gt; 은 명시 적으로 문제가되는 화면의 왼쪽 상단 위치를 지정할 수 있습니다. 앞의 예를보고 HDMI1의 1080p 해상도를 가정하면 다음은 첫 번째 화면 아래에 두 번째 HDMI 기반 화면을 배치합니다.</target>
        </trans-unit>
        <trans-unit id="ce9c2c5e673edc4df91dd9cd97b16eb59ee71073" translate="yes" xml:space="preserve">
          <source>When DPI scaling is used by the system, the logical surface size, which is used by mouse events, and the actual 'physical' size of the surface can differ. The &lt;a href=&quot;qml-qt3d-render-rendersurfaceselector#surfacePixelRatio-prop&quot;&gt;surfacePixelRatio&lt;/a&gt; is the factor to convert the logical size to the physical size.</source>
          <target state="translated">시스템에서 DPI 스케일링을 사용하는 경우 마우스 이벤트에 사용되는 논리적 표면 크기와 표면의 실제 '물리적'크기가 다를 수 있습니다. &lt;a href=&quot;qml-qt3d-render-rendersurfaceselector#surfacePixelRatio-prop&quot;&gt;surfacePixelRatio은&lt;/a&gt; 물리적 크기에 논리적 크기를 변환 할 수있는 요인이다.</target>
        </trans-unit>
        <trans-unit id="67b4917a54c5a1f83822bb816252770e66fe2a99" translate="yes" xml:space="preserve">
          <source>When DPI scaling is used by the system, the logical surface size, which is used by mouse events, and the actual 'physical' size of the surface can differ. The &lt;a href=&quot;qt3drender-qrendersurfaceselector#surfacePixelRatio-prop&quot;&gt;surfacePixelRatio&lt;/a&gt; is the factor to convert the logical size to the physical size.</source>
          <target state="translated">시스템에서 DPI 스케일링을 사용하는 경우 마우스 이벤트에 사용되는 논리적 표면 크기와 표면의 실제 '물리적'크기가 다를 수 있습니다. &lt;a href=&quot;qt3drender-qrendersurfaceselector#surfacePixelRatio-prop&quot;&gt;surfacePixelRatio은&lt;/a&gt; 물리적 크기에 논리적 크기를 변환 할 수있는 요인이다.</target>
        </trans-unit>
        <trans-unit id="f1b60dd5dc0ba61c9eadb5e24ff7b6a22b038279" translate="yes" xml:space="preserve">
          <source>When FPS measuring is enabled, the results for the last second are stored in this read-only property. It takes at least a second before this value updates after measuring is activated.</source>
          <target state="translated">FPS 측정이 활성화되면 마지막 초에 대한 결과가이 읽기 전용 속성에 저장됩니다. 측정이 활성화 된 후이 값이 업데이트 되려면 최소한 1 초가 걸립니다.</target>
        </trans-unit>
        <trans-unit id="c6d97e48bea8d713090e390fc1224dfc4ec5d0cc" translate="yes" xml:space="preserve">
          <source>When HSTS is enabled, for each HTTP response containing HSTS header and received over a secure transport, &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; will update its HSTS cache, either remembering a host with a valid policy or removing a host with an expired or disabled HSTS policy.</source>
          <target state="translated">HSTS가 활성화되면 HSTS 헤더를 포함하고 보안 전송을 통해 수신 된 각 HTTP 응답에 대해 &lt;a href=&quot;qnetworkaccessmanager&quot;&gt;QNetworkAccessManager&lt;/a&gt; 는 HSTS 캐시를 업데이트하여 유효한 정책이있는 호스트를 기억하거나 HSTS 정책이 만료되었거나 비활성화 된 호스트를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="c813b063d1c6a422bc40a6bf5d97ec4ee0b41451" translate="yes" xml:space="preserve">
          <source>When HTML markup is used for text, Qt follows the rules defined by the &lt;a href=&quot;http://www.w3.org/TR/html401/&quot;&gt;HTML 4&lt;/a&gt; specification. This includes default properties for text layout, such as the direction of the text flow (left-to-right) which can be changed by applying the &lt;a href=&quot;#block-attributes&quot;&gt;&lt;code&gt;dir&lt;/code&gt;&lt;/a&gt; attribute to blocks of text.</source>
          <target state="translated">HTML 마크 업이 텍스트에 사용되는 경우 Qt는 &lt;a href=&quot;http://www.w3.org/TR/html401/&quot;&gt;HTML 4&lt;/a&gt; 사양에 정의 된 규칙을 따릅니다 . 여기에는 &lt;a href=&quot;#block-attributes&quot;&gt; &lt;code&gt;dir&lt;/code&gt; &lt;/a&gt; 속성을 텍스트 블록 에 적용하여 변경할 수있는 텍스트 흐름 방향 (왼쪽에서 오른쪽으로)과 같은 텍스트 레이아웃의 기본 속성이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="d031a5aad62e51b34085c95c6997afabca63874d" translate="yes" xml:space="preserve">
          <source>When LayoutDirectionAuto is used in conjunction with text layouting, it will imply that the text directionality is determined from the content of the string to be layouted.</source>
          <target state="translated">LayoutDirectionAuto를 텍스트 레이아웃과 함께 사용하면 레이아웃 할 문자열의 내용에서 텍스트 방향이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="7dc427b9427e3f31178f1302dfba94644ceb86f8" translate="yes" xml:space="preserve">
          <source>When QML types produce logging messages, it improves traceability if they include the QML file and line number on which the particular instance was instantiated.</source>
          <target state="translated">QML 유형이 로깅 메시지를 생성 할 때 특정 인스턴스가 인스턴스화 된 QML 파일 및 행 번호를 포함하면 추적 성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="28bd2e83bcbfe95859e587b4383125510038621a" translate="yes" xml:space="preserve">
          <source>When QPickingSettings::pickMode() is set to &lt;a href=&quot;qt3drender-qpickingsettings#PickMethod-enum&quot;&gt;QPickingSettings::TrianglePicking&lt;/a&gt;, the signals on &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; will carry an instance of &lt;a href=&quot;qt3drender-qpicktriangleevent&quot;&gt;QPickTriangleEvent&lt;/a&gt;.</source>
          <target state="translated">QPickingSettings :: pickMode ()가 &lt;a href=&quot;qt3drender-qpickingsettings#PickMethod-enum&quot;&gt;QPickingSettings :: TrianglePicking으로&lt;/a&gt; 설정되면 QObjectPicker 의 신호는 &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QPickTriangleEvent&lt;/a&gt; 인스턴스를 &lt;a href=&quot;qt3drender-qpicktriangleevent&quot;&gt;전달&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="457be61d0f002d025c887c713d51fbbfadff17ad" translate="yes" xml:space="preserve">
          <source>When QPickingSettings::pickMode() is set to QPickingSettings::TrianglePicking, the signals on QObjectPicker will carry an instance of QPickTriangleEvent.</source>
          <target state="translated">QPickingSettings :: pickMode ()가 QPickingSettings :: TrianglePicking으로 설정되면 QObjectPicker의 신호는 QPickTriangleEvent의 인스턴스를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="e7ad967bec3128bd4f1fd05f2c5749f62466760b" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns calls &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver::resolve&lt;/a&gt;() the absolute URI is the URI mandated by the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; language, and the relative URI is the URI specified by the user.</source>
          <target state="translated">Qt XML 패턴이 &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver :: resolve&lt;/a&gt; ()를 호출 할 때 절대 URI는 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 언어에 의해 지정된 URI이고 상대 URI는 사용자가 지정한 URI입니다.</target>
        </trans-unit>
        <trans-unit id="f47f9cfcc0372f2d7543bfb2e549c724e778aa90" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns calls &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver::resolve&lt;/a&gt;() the absolute URI is the URI mandated by the schema specification, and the relative URI is the URI specified by the user.</source>
          <target state="translated">Qt XML Patterns가 &lt;a href=&quot;qabstracturiresolver#resolve&quot;&gt;QAbstractUriResolver :: resolve&lt;/a&gt; ()를 호출 할 때 절대 URI는 스키마 스펙에 의해 지정된 URI이고 상대 URI는 사용자가 지정한 URI입니다.</target>
        </trans-unit>
        <trans-unit id="b7e889092d153ecf78cedbfcbcb9a5e6e6e850e1" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns evaluate path expressions, it emulate them through a combination of calls with &lt;a href=&quot;qabstractxmlnodemodel#SimpleAxis-enum&quot;&gt;QSimpleXmlNodeModel::SimpleAxis&lt;/a&gt; values. Therefore, the implementation of this function must return the node, if any, that appears on the</source>
          <target state="translated">Qt XML 패턴은 경로 표현식을 평가할 때 &lt;a href=&quot;qabstractxmlnodemodel#SimpleAxis-enum&quot;&gt;QSimpleXmlNodeModel :: SimpleAxis&lt;/a&gt; 값 과의 호출 조합을 통해 경로 표현식을 에뮬레이트합니다 . 따라서이 함수를 구현하면 해당 노드에있는 노드가 있으면이를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="e87346c400d28fb6331382be4402bbe0f7b9fc30" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns loads an XML resource, e.g., using the &lt;code&gt;fn:doc()&lt;/code&gt; function, the following schemes are supported:</source>
          <target state="translated">Qt XML 패턴이 예를 들어 &lt;code&gt;fn:doc()&lt;/code&gt; 함수를 사용하여 XML 리소스를로드 할 때 다음 체계가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="fbd1af30e0b1f7879d2e090097ce1ee9bc1b1e77" translate="yes" xml:space="preserve">
          <source>When Qt XML Patterns loads and queries XML files and produces XML output, it can always load the XML data into its default XML node model, where it can be traversed efficiently. The XQuery below traverses the product orders found in the XML file</source>
          <target state="translated">Qt XML 패턴이 XML 파일을로드 및 쿼리하고 XML 출력을 생성하면 항상 XML 데이터를 기본 XML 노드 모델로로드하여 효율적으로 순회 할 수 있습니다. 아래 XQuery는 XML 파일에서 찾은 제품 주문을 순회합니다.</target>
        </trans-unit>
        <trans-unit id="27bec0f91bee9a8e04a2b33675d236e7ab402351" translate="yes" xml:space="preserve">
          <source>When Qt's translation tool, &lt;a href=&quot;https://doc.qt.io/qt-5.13/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt;, is used to process a set of source files, the text wrapped in tr() calls is stored in a section of the translation file that corresponds to its translation context.</source>
          <target state="translated">Qt의 번역 도구 인 &lt;a href=&quot;https://doc.qt.io/qt-5.13/linguist-manager.html#using-lupdate&quot;&gt;lupdate&lt;/a&gt; 가 소스 파일 세트를 처리하는 데 사용될 때 tr () 호출로 랩핑 된 텍스트는 번역 컨텍스트에 해당하는 번역 파일의 섹션에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="d716f69d72489992d975e006d6741d1a3935bbd6" translate="yes" xml:space="preserve">
          <source>When Qt5 came along, Qt was divided into modules. Since then, many new modules have been added to Qt. As of version 5.5, there are over 40 separate modules in Qt5, each with its own documentation that links to (depends on) the documentation of other Qt modules.</source>
          <target state="translated">Qt5가 등장하자 Qt는 모듈로 나뉘어졌습니다. 그 이후로 많은 새로운 모듈이 Qt에 추가되었습니다. 버전 5.5부터 Qt5에는 40 개가 넘는 개별 모듈이 있으며, 각 모듈에는 다른 Qt 모듈의 문서에 연결되는 문서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="709f09eba453dec3aff9d67b6d37f765373bd46f" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; is opened using this function, behaviour of &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;() is controlled by the &lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle&lt;/a&gt; flag. If &lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle&lt;/a&gt; is specified, and this function succeeds, then calling &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;() closes the adopted handle. Otherwise, &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt;() does not actually close the file, but only flushes it.</source>
          <target state="translated">때 &lt;a href=&quot;qfile&quot;&gt;Qfile을는&lt;/a&gt; 이 함수의 동작하여 개방 &lt;a href=&quot;qfiledevice#close&quot;&gt;가까이&lt;/a&gt; 에 의해 제어되는 () &lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle의&lt;/a&gt; 플래그. 경우 &lt;a href=&quot;qfiledevice#FileHandleFlag-enum&quot;&gt;AutoCloseHandle가&lt;/a&gt; 지정되고,이 기능에 성공, 다음 호출 &lt;a href=&quot;qfiledevice#close&quot;&gt;가까운&lt;/a&gt; () 채택 된 핸들을 닫습니다. 그렇지 않으면 &lt;a href=&quot;qfiledevice#close&quot;&gt;close&lt;/a&gt; ()는 실제로 파일을 닫지 않고 플러시 만합니다.</target>
        </trans-unit>
        <trans-unit id="cb1e3502bc0fff8a5da1c27970f713a4cbcb877b" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives Qt mouse, keyboard, and drag and drop events (&lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, &lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent&lt;/a&gt;, QDragEvent, etc.), it translates them into instances of &lt;a href=&quot;qgraphicssceneevent&quot;&gt;QGraphicsSceneEvent&lt;/a&gt; subclasses and forwards them to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; it displays. The scene then forwards the events to the relevant items.</source>
          <target state="translated">때 &lt;a href=&quot;qgraphicsview&quot;&gt;를 QGraphicsView는&lt;/a&gt; Qt는 마우스, 키보드 및 드래그 앤 드롭 이벤트 (수신 &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt; , &lt;a href=&quot;qkeyevent&quot;&gt;QKeyEvent&lt;/a&gt; 등 QDragEvent을), 그것은의 인스턴스로 변환 &lt;a href=&quot;qgraphicssceneevent&quot;&gt;QGraphicsSceneEvent의&lt;/a&gt; 서브 클래스와 앞으로 그들에게로 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 이 표시됩니다. 그런 다음 장면은 이벤트를 관련 항목으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="7ca650c784a62d89aa1bd61df5a5c661ba25f79c" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::ToolTip&lt;/a&gt;, it creates a &lt;a href=&quot;qgraphicsscenehelpevent&quot;&gt;QGraphicsSceneHelpEvent&lt;/a&gt;, which is forwarded to the scene. You can set a tooltip on a &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with &lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip()&lt;/a&gt;; by default &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; displays the tooltip of the &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; with the highest z-value (i.e, the top-most item) under the mouse position.</source>
          <target state="translated">때 &lt;a href=&quot;qgraphicsview&quot;&gt;를 QGraphicsView가&lt;/a&gt; 수신 &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; 형의 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent : 도구 설명&lt;/a&gt; , 그것은 생성 &lt;a href=&quot;qgraphicsscenehelpevent&quot;&gt;QGraphicsSceneHelpEvent&lt;/a&gt; 현장에 전달됩니다. 당신은에 툴팁 설정할 수 있습니다 &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 와 &lt;a href=&quot;qgraphicsitem#setToolTip&quot;&gt;setToolTip를 ()&lt;/a&gt; ; 기본적으로 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 은 마우스 위치 아래에 z 값이 가장 높은 (즉, 최상위 항목) &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 의 툴팁을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="393e354c9ea9f2a89f579509e189a24bb7a827a0" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent&lt;/a&gt; event, it translates it into &lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt;. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view.</source>
          <target state="translated">경우 &lt;a href=&quot;qgraphicsview&quot;&gt;를 QGraphicsView가&lt;/a&gt; 수신 &lt;a href=&quot;qhoverevent&quot;&gt;QHoverEvent의&lt;/a&gt; 이벤트, 그것으로 변환 &lt;a href=&quot;qgraphicsscenehoverevent&quot;&gt;QGraphicsSceneHoverEvent&lt;/a&gt; . 그런 다음 이벤트는 보기와 연관된 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene으로&lt;/a&gt; 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="beba9444d0901cd09b88793cbb92e83a0fb0a4c8" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; receives a &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;, it translates it to a &lt;a href=&quot;qgraphicsscenemouseevent&quot;&gt;QGraphicsSceneMouseEvent&lt;/a&gt;. The event is then forwarded to the &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; associated with the view. If the event is not handled by the scene, the view may use it, e.g., for the &lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;qgraphicsview&quot;&gt;를 QGraphicsView가&lt;/a&gt; 수신 &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent를&lt;/a&gt; , 그것은로 변환 &lt;a href=&quot;qgraphicsscenemouseevent&quot;&gt;QGraphicsSceneMouseEvent&lt;/a&gt; . 그런 다음 이벤트는 보기와 연관된 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene으로&lt;/a&gt; 전달됩니다 . 이벤트가 장면에 의해 처리되지 않으면 뷰는 예를 들어 &lt;a href=&quot;qgraphicsview#DragMode-enum&quot;&gt;DragMode 등&lt;/a&gt; 의 이벤트를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1aa704cf88adf38927fd01a2a14f929a34849e2" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">때 &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw의&lt;/a&gt; 노드가 FrameGraph 지점에 존재하는이 방지 모든 프리미티브를 렌더링하는 렌더러에서. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d712cc482a400f11481ce544723b23f89d2fced9" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;, clients that are listening to events are notified of the change. The function is used to post events to the assistive technology, and accessible &lt;a href=&quot;qaccessible#Event-enum&quot;&gt;events&lt;/a&gt; are posted by &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 가 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility ()를&lt;/a&gt; 호출 하면 이벤트를 수신하는 클라이언트에게 변경 사항이 통지됩니다. 이 함수는 보조 기술에 이벤트를 게시하는 데 사용되며 액세스 가능한 &lt;a href=&quot;qaccessible#Event-enum&quot;&gt;이벤트&lt;/a&gt; 는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility ()&lt;/a&gt; 에 의해 게시됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc5c853e12ceaddd145dd8068a3f01709b57c0cc" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is deleted, it emits this &lt;a href=&quot;qobject#destroyed&quot;&gt;QObject::destroyed&lt;/a&gt;() signal. We want to catch this signal, wherever we might have a dangling reference to the deleted &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;, so we can clean it up. A suitable slot signature might be:</source>
          <target state="translated">때 &lt;a href=&quot;qobject&quot;&gt;QObject를가&lt;/a&gt; 삭제되고,이 방출 &lt;a href=&quot;qobject#destroyed&quot;&gt;QObject를 :: 파괴&lt;/a&gt; () 신호를. 삭제 된 &lt;a href=&quot;qobject&quot;&gt;QObject에&lt;/a&gt; 매달려있는 참조가있을 때마다이 신호를 포착하여 정리할 수 있습니다. 적합한 슬롯 서명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d5dd864966ee74351524f25c84e86e7278c96ac6" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is moved to another thread, all its children will be automatically moved too.</source>
          <target state="translated">때 &lt;a href=&quot;qobject&quot;&gt;QObject를이&lt;/a&gt; 다른 스레드로 이동, 모든 아이들은 자동으로 너무 이동합니다.</target>
        </trans-unit>
        <trans-unit id="5954371cae64cc8ee9901844bd7778dc5d52aaf5" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is passed to the &lt;a href=&quot;qjsengine#newQObject&quot;&gt;QJSEngine::newQObject&lt;/a&gt;() function, a Qt Script wrapper object is created that can be used to make the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;'s signals, slots, properties, and child objects available to scripts.</source>
          <target state="translated">때 &lt;a href=&quot;qobject&quot;&gt;QObject를가&lt;/a&gt; 받는 전달 &lt;a href=&quot;qjsengine#newQObject&quot;&gt;QJSEngine :: newQObject&lt;/a&gt; () 함수, Qt는 스크립트 객체 랩퍼가이 확인하는 데 사용할 수 있습니다 생성 &lt;a href=&quot;qobject&quot;&gt;QObject를&lt;/a&gt; 의 신호, 슬롯, 속성, 그리고 아이는 스크립트를 사용할 객체.</target>
        </trans-unit>
        <trans-unit id="3af90ba954a525651c11676587fb2037323acba5" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; instance is deliberately hidden with &lt;a href=&quot;qwindow#hide&quot;&gt;hide&lt;/a&gt;() or &lt;a href=&quot;qwindow#visible-prop&quot;&gt;setVisible&lt;/a&gt;(false), it will stop rendering and its scene graph and graphics context might be released. The &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt;() signal will be emitted when this happens.</source>
          <target state="translated">때 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow의&lt;/a&gt; 인스턴스가 의도적으로 숨겨 &lt;a href=&quot;qwindow#hide&quot;&gt;숨기기&lt;/a&gt; () 또는 &lt;a href=&quot;qwindow#visible-prop&quot;&gt;는, setVisible&lt;/a&gt; (false)를, 그것은 렌더링을 중지하고 장면 그래프 및 그래픽 컨텍스트가 해제 될 수 있습니다. 이 경우 &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;sceneGraphInvalidated&lt;/a&gt; () 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5554553d845c524ddee2156401f7cea7ba23f3a7" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qmemorybarrier&quot;&gt;QMemoryBarrier&lt;/a&gt; node is found in a FrameGraph branch, the barrier will be enforced prior to any draw or compute command even if these are defined deeper in the branch.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qmemorybarrier&quot;&gt;QMemoryBarrier&lt;/a&gt; 노드가 FrameGraph 브랜치에서 발견 되면, 브랜치에서 더 깊이 정의 된 경우에도 그리기 또는 계산 명령 전에 장벽이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ba17b5ca58006cf8654bdb06b74fa570795c9e22" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">때 &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw의&lt;/a&gt; 노드가 FrameGraph 지점에 존재하는이 방지 모든 프리미티브를 렌더링하는 렌더러에서. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="548a84d157a52956b642a6c79fa3b16cff4cbb88" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive. &lt;a href=&quot;qt3drender-qnodraw#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">때 &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw의&lt;/a&gt; 노드가 FrameGraph 지점에 존재하는이 방지 모든 프리미티브를 렌더링하는 렌더러에서. &lt;a href=&quot;qt3drender-qnodraw#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88153895f9568d781c480af110178d98fc9ac494" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt; is not a child of a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;, it loses the ability to populate the extension pop up with widgets added to the toolbar using &lt;a href=&quot;qtoolbar#addWidget&quot;&gt;addWidget&lt;/a&gt;(). Please use widget actions created by inheriting &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; and implementing &lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction::createWidget&lt;/a&gt;() instead.</source>
          <target state="translated">때 &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar이&lt;/a&gt; 의 아이가 아닌 &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; , 그것은 확장 사용하여 도구 모음에 추가 위젯 팝업 채울 수있는 능력 상실 &lt;a href=&quot;qtoolbar#addWidget&quot;&gt;개의 addWidget을&lt;/a&gt; (). &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; 을 상속 하고 대신 &lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction :: createWidget&lt;/a&gt; ()을 구현 하여 작성된 위젯 조치를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea339d196247f8a4535ab539b791214e5503ae1d" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;subTitle&lt;/a&gt; is set, &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; displays it in a header, in which case it also uses the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt; and the &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmap&lt;/a&gt; to decorate the header. The &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmap&lt;/a&gt; is displayed on the left side, below the header. At the bottom, there is a row of buttons allowing the user to navigate through the pages.</source>
          <target state="translated">때 &lt;a href=&quot;qwizardpage#subTitle-prop&quot;&gt;자막이&lt;/a&gt; 설정된다 &lt;a href=&quot;qwizard&quot;&gt;QWizard의&lt;/a&gt; 그것도 사용하는 경우의 헤더에 표시를하여 &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;BannerPixmap&lt;/a&gt; 및 &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;LogoPixmap를&lt;/a&gt; 헤더 장식. &lt;a href=&quot;qwizard#WizardPixmap-enum&quot;&gt;WatermarkPixmap는&lt;/a&gt; 헤더 아래 왼쪽에 표시된다. 맨 아래에는 사용자가 페이지를 탐색 할 수있는 일련의 단추가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7322771e8958658ead503160124f934fb65197f8" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;&amp;lt;content&amp;gt;&lt;/code&gt; element is used, the data will contain a single item with either the value of the</source>
          <target state="translated">때 &lt;code&gt;&amp;lt;content&amp;gt;&lt;/code&gt; 요소가 사용되며, 데이터는 하나의 값과 하나의 항목을 포함</target>
        </trans-unit>
        <trans-unit id="2672663ccea1c72ceff571e1774f7c56bc159e61" translate="yes" xml:space="preserve">
          <source>When a D-Bus function returns a D-Bus variant, it can be retrieved as follows:</source>
          <target state="translated">D-Bus 함수가 D-Bus 변형을 반환하면 다음과 같이 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1017702957d7db1428d00195f1759c2c2ce9ca31" translate="yes" xml:space="preserve">
          <source>When a JavaScript file is imported this way, it is imported with a qualifier. The functions in that file are then accessible from the importing script via the qualifier (that is, as &lt;code&gt;Qualifier.functionName(params)&lt;/code&gt;).</source>
          <target state="translated">이 방법으로 JavaScript 파일을 가져 오면 한정자를 사용하여 가져옵니다. 그런 다음 규정자를 통해 가져 오기 스크립트에서 해당 파일의 함수에 액세스 할 수 있습니다 (즉, &lt;code&gt;Qualifier.functionName(params)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b5239011b0ce80a40d0520fced8dbad82a40aa0a" translate="yes" xml:space="preserve">
          <source>When a Plugin object is created, it is &quot;detached&quot; and not associated with any actual service plugin. Once it has received information via setting its &lt;a href=&quot;qml-qtlocation-plugin#name-prop&quot;&gt;name&lt;/a&gt;, &lt;a href=&quot;qml-qtlocation-plugin#preferred-prop&quot;&gt;preferred&lt;/a&gt;, or &lt;a href=&quot;qml-qtlocation-plugin#required-prop&quot;&gt;required&lt;/a&gt; properties, it will choose an appropriate service plugin to attach to. Plugin objects can only be attached once; to use multiple plugins, create multiple Plugin objects.</source>
          <target state="translated">플러그인 오브젝트가 작성되면 &quot;분리&quot;되며 실제 서비스 플러그인과 연관되지 않습니다. &lt;a href=&quot;qml-qtlocation-plugin#name-prop&quot;&gt;name&lt;/a&gt; , &lt;a href=&quot;qml-qtlocation-plugin#preferred-prop&quot;&gt;preferred&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtlocation-plugin#required-prop&quot;&gt;required&lt;/a&gt; 특성 을 설정하여 정보를 수신 하면 첨부 할 적절한 서비스 플러그인을 선택합니다. 플러그인 객체는 한 번만 첨부 할 수 있습니다. 여러 플러그인을 사용하려면 여러 플러그인 오브젝트를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b6f220e6e802d62e7eddcb10a35ca79f2887d75d" translate="yes" xml:space="preserve">
          <source>When a QML &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; explicitly relinquishes focus (by setting its &lt;code&gt;focus&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt; while it has active focus), the system does not automatically select another type to receive focus. That is, it is possible for there to be no currently active focus.</source>
          <target state="translated">QML &lt;a href=&quot;qml-qtquick-item&quot;&gt;항목&lt;/a&gt; 이 &lt;code&gt;focus&lt;/code&gt; 를 활성 상태 인 동안 포커스 속성을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 포커스를 명시 적으로 포기 하면 시스템은 포커스를받을 다른 유형을 자동으로 선택하지 않습니다. 즉, 현재 활성화 된 초점이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7001a12de2df6c574e67e9da9ad3f2fc320aad4f" translate="yes" xml:space="preserve">
          <source>When a QML object type is used as a signal parameter, the parameter should use &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; as the type, and the value should be received in C++ using the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; type:</source>
          <target state="translated">QML 오브젝트 유형이 신호 매개 변수로 사용되는 경우 매개 변수는 &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; 를 유형으로 사용 하고 값은 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 유형을 사용하여 C ++로 수신해야합니다 .</target>
        </trans-unit>
        <trans-unit id="15f000278e72ce7b8d6c307887252da7193e1ede" translate="yes" xml:space="preserve">
          <source>When a QMemoryBarrier node is found in a FrameGraph branch, the barrier will be enforced prior to any draw or compute command even if these are defined deeper in the branch.</source>
          <target state="translated">QMemoryBarrier 노드가 FrameGraph 브랜치에서 발견되면, 브랜치에서 더 깊이 정의 된 경우에도 그리기 또는 계산 명령 전에 장벽이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f8aa88cb70cc32f83b8553c1a39321db3fc1b25e" translate="yes" xml:space="preserve">
          <source>When a Qt3DRender::QNoDraw node is present in a FrameGraph branch, this prevents the renderer from rendering any primitive</source>
          <target state="translated">Qt3DRender :: QNoDraw 노드가 FrameGraph 브랜치에 있으면 렌더러가 프리미티브를 렌더링하지 못합니다</target>
        </trans-unit>
        <trans-unit id="40263f24ec17a09841c1926737df4393300f3b67" translate="yes" xml:space="preserve">
          <source>When a button is clicked in the button box, the &lt;a href=&quot;qdialogbuttonbox#clicked&quot;&gt;clicked&lt;/a&gt;() signal is emitted for the actual button is that is pressed. For convenience, if the button has an &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;AcceptRole&lt;/a&gt;, &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;RejectRole&lt;/a&gt;, or &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;HelpRole&lt;/a&gt;, the &lt;a href=&quot;qdialogbuttonbox#accepted&quot;&gt;accepted&lt;/a&gt;(), &lt;a href=&quot;qdialogbuttonbox#rejected&quot;&gt;rejected&lt;/a&gt;(), or &lt;a href=&quot;qdialogbuttonbox#helpRequested&quot;&gt;helpRequested&lt;/a&gt;() signals are emitted respectively.</source>
          <target state="translated">버튼 상자에서 버튼을 클릭하면 실제 버튼에 대한 &lt;a href=&quot;qdialogbuttonbox#clicked&quot;&gt;클릭 된&lt;/a&gt; () 신호가 출력됩니다. 편의상 버튼에 &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;AcceptRole&lt;/a&gt; , &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;RejectRole&lt;/a&gt; 또는 &lt;a href=&quot;qdialogbuttonbox#ButtonRole-enum&quot;&gt;HelpRole&lt;/a&gt; 이있는 경우 &lt;a href=&quot;qdialogbuttonbox#accepted&quot;&gt;accept&lt;/a&gt; (), &lt;a href=&quot;qdialogbuttonbox#rejected&quot;&gt;rejected&lt;/a&gt; () 또는 &lt;a href=&quot;qdialogbuttonbox#helpRequested&quot;&gt;helpRequested&lt;/a&gt; () 신호가 각각 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="3391d8c7ccaaea73a623e4d861dba6f56e546160" translate="yes" xml:space="preserve">
          <source>When a button is clicked in the button box, the &lt;a href=&quot;qml-qtquick-controls2-dialogbuttonbox#clicked-signal&quot;&gt;clicked()&lt;/a&gt; signal is emitted for the actual button that is pressed. In addition, the following signals are automatically emitted when a button with the respective role(s) is pressed:</source>
          <target state="translated">버튼 상자에서 버튼을 클릭하면 누른 실제 버튼에 대해 &lt;a href=&quot;qml-qtquick-controls2-dialogbuttonbox#clicked-signal&quot;&gt;clicked ()&lt;/a&gt; 신호가 발생합니다. 또한 각 역할이있는 버튼을 누르면 다음 신호가 자동으로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="06c02f6a9dbac4345d72fdb9bb347db0a2b3bcdc" translate="yes" xml:space="preserve">
          <source>When a category is removed, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit the &lt;a href=&quot;qplacemanager#categoryRemoved&quot;&gt;QPlaceManager::categoryRemoved&lt;/a&gt;() signal. Whether a manager does so is provider specific. Managers accessing places from a web service will typically not emit these signals, while managers accessing places stored locally generally will.</source>
          <target state="translated">카테고리가 제거되면 &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; 가 &lt;a href=&quot;qplacemanager#categoryRemoved&quot;&gt;QPlaceManager :: categoryRemoved&lt;/a&gt; () 신호를 방출 할 수 있습니다 . 관리자가 그렇게하는지 여부는 공급자마다 다릅니다. 웹 서비스에서 장소에 액세스하는 관리자는 일반적으로 이러한 신호를 내 보내지 않지만 로컬에 저장된 장소에 액세스하는 관리자는 일반적으로 신호를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="2153d9fed3f02a16b6a6ca1c21681db29241b851" translate="yes" xml:space="preserve">
          <source>When a category is saved, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit &lt;a href=&quot;qplacemanager#categoryAdded&quot;&gt;QPlaceManager::categoryAdded&lt;/a&gt;() or &lt;a href=&quot;qplacemanager#categoryUpdated&quot;&gt;QPlaceManager::categoryUpdated&lt;/a&gt;() signals. However whether a manager does so or not is provider specific, managers accessing places from a web service will typically not emit these signals while managers accessing places locally stored generally will.</source>
          <target state="translated">카테고리가 저장되면 &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; 가 &lt;a href=&quot;qplacemanager#categoryAdded&quot;&gt;QPlaceManager :: categoryAdded&lt;/a&gt; () 또는 &lt;a href=&quot;qplacemanager#categoryUpdated&quot;&gt;QPlaceManager :: categoryUpdated&lt;/a&gt; () 신호를 방출 할 수 있습니다 . 그러나, 관리자가 제공하는지 여부는 공급자마다 다르지만, 웹 서비스에서 장소에 액세스하는 관리자는 일반적으로 이러한 신호를 방출하지 않지만 일반적으로 로컬에 저장된 장소에 액세스하는 관리자는 신호를 방출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d7ef2995bb1b9278679a4db6eb4f1c8a80df088" translate="yes" xml:space="preserve">
          <source>When a child layout object is selected, its parent layout object can be selected by pressing down the &lt;b&gt;Shift&lt;/b&gt; key while clicking on it. This makes it possible to select a specific layout in a hierarchy, which is otherwise difficult due to the small frame.</source>
          <target state="translated">자식 레이아웃 개체를 선택한 경우 &lt;b&gt;Shift&lt;/b&gt; 키를 누른 채로 클릭하면 부모 레이아웃 개체를 선택할 수 있습니다 . 따라서 계층 구조에서 특정 레이아웃을 선택할 수 있습니다. 그렇지 않으면 작은 프레임으로 인해 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="4d44facce222efbda291b9b00896c00605e23c4d" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using the &lt;a href=&quot;#nonreentrant-command&quot;&gt;\nonreentrant&lt;/a&gt; command.</source>
          <target state="translated">클래스가 &lt;a href=&quot;#reentrant-command&quot;&gt;\ reentrant&lt;/a&gt; 또는 &lt;a href=&quot;#threadsafe-command&quot;&gt;\ threadsafe&lt;/a&gt; 로 표시 되면 &lt;a href=&quot;#nonreentrant-command&quot;&gt;\ nonreentrant&lt;/a&gt; 명령을 사용하여 해당 클래스의 함수를 &lt;code&gt;nonreentrant&lt;/code&gt; 으로 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0630e10d812ca6a44e69948c6fbb1d3fde2d9e6c" translate="yes" xml:space="preserve">
          <source>When a class is marked &lt;a href=&quot;#reentrant-command&quot;&gt;\reentrant&lt;/a&gt; or &lt;a href=&quot;#threadsafe-command&quot;&gt;\threadsafe&lt;/a&gt;, functions in that class can be marked &lt;code&gt;nonreentrant&lt;/code&gt; using this command in the &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#fn-command&quot;&gt;\fn&lt;/a&gt; comment of the functions to be excluded.</source>
          <target state="translated">클래스가 &lt;a href=&quot;#reentrant-command&quot;&gt;\ reentrant&lt;/a&gt; 또는 &lt;a href=&quot;#threadsafe-command&quot;&gt;\ threadsafe&lt;/a&gt; 로 표시 되면 제외 할 함수 의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#fn-command&quot;&gt;\ fn&lt;/a&gt; 주석 에서이 명령을 사용하여 해당 클래스의 함수를 &lt;code&gt;nonreentrant&lt;/code&gt; 것으로 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb8493d30c9e50739fc7b9788b39ac10cc03ca43" translate="yes" xml:space="preserve">
          <source>When a composition mode is set it applies to all painting operator, pens, brushes, gradients and pixmap/image drawing.</source>
          <target state="translated">컴포지션 모드가 설정되면 모든 페인팅 연산자, 펜, 브러쉬, 그라디언트 및 픽스맵 / 이미지 드로잉에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="38b6f0bc81c40f221944d8b87c8853be0ed28449" translate="yes" xml:space="preserve">
          <source>When a container extension is required,</source>
          <target state="translated">컨테이너 확장이 필요한 경우</target>
        </trans-unit>
        <trans-unit id="0e4a24a47776590b3614eff94072d51c15c8244d" translate="yes" xml:space="preserve">
          <source>When a custom valueBar is defined, its &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; property must be set.</source>
          <target state="translated">사용자 정의 valueBar가 정의되면 &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; 속성을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c4b40a6fbd23b160b7fe00aefbf0818b8bf8785" translate="yes" xml:space="preserve">
          <source>When a data stream operates on an asynchronous device, the chunks of data can arrive at arbitrary points in time. The &lt;a href=&quot;qdatastream&quot;&gt;QDataStream&lt;/a&gt; class implements a transaction mechanism that provides the ability to read the data atomically with a series of stream operators. As an example, you can handle incomplete reads from a socket by using a transaction in a slot connected to the readyRead() signal:</source>
          <target state="translated">데이터 스트림이 비동기 장치에서 작동하면 데이터 청크가 임의의 시점에 도달 할 수 있습니다. &lt;a href=&quot;qdatastream&quot;&gt;QDataStream의&lt;/a&gt; 클래스가 구현하는 스트림 사업자의 일련의 원자 적 데이터를 읽을 수있는 기능을 제공하는 거래 메커니즘. 예를 들어 readyRead () 신호에 연결된 슬롯에서 트랜잭션을 사용하여 소켓에서 불완전한 읽기를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="2b820cde4dc4a7341cb53aee76f1d46245199229" translate="yes" xml:space="preserve">
          <source>When a delay is set, the event will be queued for delivery after the timeout has passed. The state machine takes ownership of</source>
          <target state="translated">지연이 설정되면 시간 초과가 지나면 이벤트가 배달 대기 상태가됩니다. 상태 머신은</target>
        </trans-unit>
        <trans-unit id="23bd60283b08b2b77caeefa53fd2bdd658b2b566" translate="yes" xml:space="preserve">
          <source>When a delay is set, the event will be queued for delivery after the timeout has passed. The state machine takes ownership of the event and deletes it after processing.</source>
          <target state="translated">지연이 설정되면 시간 초과가 지나면 이벤트가 배달 대기 상태가됩니다. 상태 머신은 이벤트의 소유권을 가져 와서 처리 후 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="d09fa2d377e5a85c50e883812625f0a7a5fde3e3" translate="yes" xml:space="preserve">
          <source>When a dock widget or tool bar is dragged over the main window, the main window adjusts its contents to indicate where the dock widget or tool bar will be docked if it is dropped. Setting this property causes &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; to move its contents in a smooth animation. Clearing this property causes the contents to snap into their new positions.</source>
          <target state="translated">도크 위젯 또는 도구 모음을 기본 창 위로 끌면 기본 창은 도크 위젯 또는 도구 모음을 떨어 뜨린 경우 도킹 될 위치를 표시하도록 컨텐츠를 조정합니다. 이 속성을 설정하면 &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; 가 내용을 부드러운 애니메이션으로 이동시킵니다. 이 속성을 지우면 내용이 새 위치로 스냅됩니다.</target>
        </trans-unit>
        <trans-unit id="da9490d3c1f9946041e7eb1512b2be2ffa63a1b3" translate="yes" xml:space="preserve">
          <source>When a drag and drop operation is performed over a view, the underlying model is queried to determine which types of operation it supports and the MIME types it can accept. This information is provided by the &lt;a href=&quot;qabstractitemmodel#supportedDropActions&quot;&gt;QAbstractItemModel::supportedDropActions&lt;/a&gt;() and &lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel::mimeTypes&lt;/a&gt;() functions. Models that do not override the implementations provided by &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; support copy operations and the default internal MIME type for items.</source>
          <target state="translated">보기에 대해 끌어서 놓기 작업을 수행하면 기본 모델이 쿼리되어 지원하는 작업 유형과 허용 가능한 MIME 유형을 결정합니다. 이 정보는 &lt;a href=&quot;qabstractitemmodel#supportedDropActions&quot;&gt;QAbstractItemModel :: supportedDropActions&lt;/a&gt; () 및 &lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel :: mimeTypes&lt;/a&gt; () 함수에 의해 제공됩니다 . &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel에서&lt;/a&gt; 제공하는 구현을 대체하지 않는 모델은 복사 조작 및 항목의 기본 내부 MIME 유형을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e9b8c9681d5d37404723c8f5a9ebfc9d97539a77" translate="yes" xml:space="preserve">
          <source>When a drag is &lt;a href=&quot;qml-qtquick-drag#active-attached-prop&quot;&gt;active&lt;/a&gt; on an item, any change in that item's position will generate a drag event that will be sent to any &lt;a href=&quot;qml-qtquick-droparea&quot;&gt;DropArea&lt;/a&gt; that intersects with the new position of the item. Other items which implement drag and drop event handlers can also receive these events.</source>
          <target state="translated">항목에서 끌기가 &lt;a href=&quot;qml-qtquick-drag#active-attached-prop&quot;&gt;활성화&lt;/a&gt; 되면 해당 항목의 위치가 변경되면 항목의 새 위치와 교차 하는 &lt;a href=&quot;qml-qtquick-droparea&quot;&gt;DropArea&lt;/a&gt; 로 전송되는 끌기 이벤트가 생성됩니다 . 끌어서 놓기 이벤트 핸들러를 구현하는 다른 항목도 이러한 이벤트를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c95a54f3a1918c06f2cbe85cf290554fb693d8ac" translate="yes" xml:space="preserve">
          <source>When a drag is not active this property holds the object that accepted the drop event that ended the drag, if no object accepted the drop or the drag was canceled the target will then be null.</source>
          <target state="translated">드래그가 활성화되어 있지 않으면이 속성은 드래그를 종료 한 드롭 이벤트를 수락 한 객체를 유지합니다. 객체가 드롭을 수락하지 않았거나 드래그가 취소 된 경우 대상은 null입니다.</target>
        </trans-unit>
        <trans-unit id="8dd9d07c03937978798b7bb1627270a6ea3c810d" translate="yes" xml:space="preserve">
          <source>When a drop occurs elsewhere in the view, and the row number is unusable, we append items to the top level of the model.</source>
          <target state="translated">뷰의 다른 곳에서 드롭이 발생하고 행 번호를 사용할 수없는 경우 모델의 최상위 레벨에 항목을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f51c41bb148e0dd3152b4f6f3f9915d8028fe189" translate="yes" xml:space="preserve">
          <source>When a drop occurs in the widget, the dropEvent() handler function is called, and we can deal with each possible action in turn. First, we deal with drag and drop operations within the same widget:</source>
          <target state="translated">위젯에서 드롭이 발생하면 dropEvent () 핸들러 함수가 호출되고 가능한 각 조치를 차례로 처리 할 수 ​​있습니다. 먼저 동일한 위젯 내에서 끌어서 놓기 작업을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="b42ee2ab5c63e4e31745c7c35ebc8cf0bcf255bd" translate="yes" xml:space="preserve">
          <source>When a drop occurs, the model index corresponding to the parent item will either be valid, indicating that the drop occurred on an item, or it will be invalid, indicating that the drop occurred somewhere in the view that corresponds to top level of the model.</source>
          <target state="translated">삭제가 발생하면 상위 항목에 해당하는 모델 색인이 유효하여 항목에서 삭제가 발생했음을 표시하거나 유효하지 않아 모델의 최상위 레벨에 해당하는보기에서 삭제가 발생했음을 표시합니다. .</target>
        </trans-unit>
        <trans-unit id="fa514711ce33d2215ed2e3d6a6f7e5ed0189a13b" translate="yes" xml:space="preserve">
          <source>When a focus scope receives active focus, the contained type with &lt;code&gt;focus&lt;/code&gt; set (if any) also gets the active focus. If this type is also a &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt;, the proxying behavior continues. Both the focus scope and the sub-focused item will have the &lt;code&gt;activeFocus&lt;/code&gt; property set.</source>
          <target state="translated">포커스 범위가 활성 포커스를 받으면 &lt;code&gt;focus&lt;/code&gt; 설정된 포함 된 유형 (있는 경우)도 활성 포커스를 얻습니다. 이 유형이 &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt; 인 경우 프록시 동작이 계속됩니다. 초점 범위와 하위 초점 항목 모두 &lt;code&gt;activeFocus&lt;/code&gt; 속성이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9e613a8bc60ebbcd1e9e0949919a88ee9070005d" translate="yes" xml:space="preserve">
          <source>When a formatter is attached to a value axis, the axis range cannot include negative values or the zero.</source>
          <target state="translated">포맷터가 값 축에 연결된 경우 축 범위는 음수 값 또는 0을 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f6b92c6c88b8efb6145fe6bc4f3bfc2d29e118a" translate="yes" xml:space="preserve">
          <source>When a gesture is canceled, the &lt;a href=&quot;qgesturerecognizer#reset&quot;&gt;reset&lt;/a&gt;() function is called, giving the recognizer the chance to update the appropriate properties in the corresponding &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; object.</source>
          <target state="translated">제스처가 취소되면 &lt;a href=&quot;qgesturerecognizer#reset&quot;&gt;reset&lt;/a&gt; () 함수가 호출되어 인식자가 해당 &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; 객체 의 적절한 속성을 업데이트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="428d7789009cbf1fc7ea52cad52f4379b3aabfc7" translate="yes" xml:space="preserve">
          <source>When a highlighted item is activated, the popup is closed, &lt;a href=&quot;qml-qtquick-controls2-combobox#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; is set to &lt;code&gt;highlightedIndex&lt;/code&gt;, and the value of this property is reset to &lt;code&gt;-1&lt;/code&gt;, as there is no longer a highlighted item.</source>
          <target state="translated">강조 표시된 항목이 활성화되면 팝업이 닫히고 &lt;a href=&quot;qml-qtquick-controls2-combobox#currentIndex-prop&quot;&gt;currentIndex&lt;/a&gt; 가 &lt;code&gt;highlightedIndex&lt;/code&gt; 로 설정되고 더 이상 강조 표시된 항목 이 없으므로이 속성 값이 &lt;code&gt;-1&lt;/code&gt; 로 재설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="4eebccda1013bfd9e4d9b4103626dd2994ae925f" translate="yes" xml:space="preserve">
          <source>When a key is pressed or released, a key event is generated and delivered to the focused Qt Quick &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt;. To facilitate the construction of reusable components and to address some of the cases unique to fluid user interfaces, the Qt Quick items add a scope based extension to Qt's traditional keyboard focus model.</source>
          <target state="translated">키를 누르거나 놓으면 키 이벤트가 생성되어 포커스 된 Qt Quick &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item에&lt;/a&gt; 전달됩니다 . 재사용 가능한 컴포넌트의 구성을 용이하게하고 유동적 인 사용자 인터페이스 고유의 일부 사례를 처리하기 위해 Qt Quick 항목은 Qt의 기존 키보드 포커스 모델에 범위 기반 확장을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5280aa5c73ecda9d4fb3b4f001bfc13d6e4c77a0" translate="yes" xml:space="preserve">
          <source>When a key sequence is being typed at the keyboard, it is said to be ambiguous as long as it matches the start of more than one shortcut.</source>
          <target state="translated">키보드에서 키 시퀀스를 입력 할 때 하나 이상의 단축키 시작과 일치하는 한 모호하다고합니다.</target>
        </trans-unit>
        <trans-unit id="332bb39a2cb3399af84efd51d32cde06e1b10d08" translate="yes" xml:space="preserve">
          <source>When a language/country pair is specified in the constructor, one of three things can happen:</source>
          <target state="translated">생성자에서 언어 / 국가 쌍을 지정하면 다음 세 가지 중 하나가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c010514fe89fada083c82bb7ef5814f38b6c278" translate="yes" xml:space="preserve">
          <source>When a layout is resized, items may grow or shrink. Due to this, items have a &lt;a href=&quot;qml-qtquick-layouts-layout#minimumWidth-attached-prop&quot;&gt;minimum size&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-layouts-layout#preferredWidth-attached-prop&quot;&gt;preferred size&lt;/a&gt; and a &lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;maximum size&lt;/a&gt;.</source>
          <target state="translated">레이아웃 크기를 조정하면 항목이 커지거나 줄어들 수 있습니다. 이로 인해 항목의 &lt;a href=&quot;qml-qtquick-layouts-layout#minimumWidth-attached-prop&quot;&gt;최소 크기&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-layouts-layout#preferredWidth-attached-prop&quot;&gt;기본 크기&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-layouts-layout#maximumWidth-attached-prop&quot;&gt;최대 크기가 다릅니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2aaeb9d71f67c32d894e19f355e445af1f673900" translate="yes" xml:space="preserve">
          <source>When a low-level graphics API is in use, the scenegraph will make sure there is a CPU-side wait for the GPU to complete all work submitted to the scenegraph's graphics command queue before the scenegraph's nodes are deleted. Therefore there is no need to issue additional waits here, unless the &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt;() implementation is using additional command queues.</source>
          <target state="translated">저수준 그래픽 API를 사용하는 경우 장면 그래프는 장면 그래프의 노드가 삭제되기 전에 GPU가 장면 그래프의 그래픽 명령 대기열에 제출 된 모든 작업을 완료 할 때까지 CPU 측 대기 시간이 있는지 확인합니다. 따라서 &lt;a href=&quot;qsgrendernode#render&quot;&gt;render&lt;/a&gt; () 구현이 추가 명령 큐를 사용 하지 않는 한 여기에서 추가 대기를 발행 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c845af89f01e419749914b45895c1bb235d5ce01" translate="yes" xml:space="preserve">
          <source>When a menu is torn off a second menu is shown to display the menu contents in a new window. When the menu is in this mode and the menu is visible returns &lt;code&gt;true&lt;/code&gt;; otherwise false.</source>
          <target state="translated">메뉴가 해제되면 메뉴 내용이 새 창에 표시되는 두 번째 메뉴가 표시됩니다. 메뉴가이 모드에 있고 메뉴가 표시되면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 거짓.</target>
        </trans-unit>
        <trans-unit id="728dd6daea54bbbc47c1c0afd43ec24383ab26a3" translate="yes" xml:space="preserve">
          <source>When a model is reset it means that any previous data reported from the model is now invalid and has to be queried for again. This also means that the current item and any selected items will become invalid.</source>
          <target state="translated">모델이 재설정되면 모델에서보고 된 이전 데이터가 이제 유효하지 않으며 다시 쿼리해야 함을 의미합니다. 또한 현재 항목과 선택한 항목이 유효하지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="5f301e5dc3d747cffb379d30922ea2160d2c0277" translate="yes" xml:space="preserve">
          <source>When a model radically changes its data it can sometimes be easier to just call this function rather than emit &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged&lt;/a&gt;() to inform other components when the underlying data source, or its structure, has changed.</source>
          <target state="translated">모델이 데이터를 근본적으로 변경하는 경우 기본 데이터 소스 또는 구조가 변경되었을 때 다른 구성 요소에 알리기 위해 &lt;a href=&quot;qabstractitemmodel#dataChanged&quot;&gt;dataChanged&lt;/a&gt; ()를 내보내는 대신이 함수를 호출하는 것이 더 쉬운 경우가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="798d38793d411f71af72b3a052c51c022e51937d" translate="yes" xml:space="preserve">
          <source>When a module name is used as the</source>
          <target state="translated">모듈 이름이</target>
        </trans-unit>
        <trans-unit id="c8bb4a36e1cc58b9d2f69c2e0e1701bc5743d489" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;q3dcamera&quot;&gt;Q3DCamera&lt;/a&gt; object is set, it is automatically added as child of the scene.</source>
          <target state="translated">새로운 &lt;a href=&quot;q3dcamera&quot;&gt;Q3DCamera&lt;/a&gt; 객체가 설정되면 장면의 자식으로 자동 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="8b455ee9f46ef6792f12c0936577f332d927c927" translate="yes" xml:space="preserve">
          <source>When a new &lt;a href=&quot;q3dlight&quot;&gt;Q3DLight&lt;/a&gt; objects is set, it is automatically added as child of the scene.</source>
          <target state="translated">새로운 &lt;a href=&quot;q3dlight&quot;&gt;Q3DLight&lt;/a&gt; 객체가 설정되면 장면의 자식으로 자동 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="92c136ff15dc3f6e6eb98af265af4b77642b9592" translate="yes" xml:space="preserve">
          <source>When a new column is flicked into view, &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; will determine its width by calling the &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; function. &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; itself will never store row height or column width, as it's designed to support large models containing any number of rows and columns. Instead, it will ask the application whenever it needs to know.</source>
          <target state="translated">새 열을 뷰로 &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;넘기면 TableView&lt;/a&gt; 는 &lt;a href=&quot;qml-qtquick-tableview#columnWidthProvider-prop&quot;&gt;columnWidthProvider&lt;/a&gt; 함수 를 호출하여 너비를 결정 합니다. &lt;a href=&quot;qml-qtquick-tableview&quot;&gt;TableView&lt;/a&gt; 자체는 행 높이 또는 열 너비를 저장하지 않습니다. 행과 열을 포함하는 큰 모델을 지원하도록 설계 되었기 때문입니다. 대신, 필요할 때마다 응용 프로그램에 요청합니다.</target>
        </trans-unit>
        <trans-unit id="be74d7e819d89ccb9b1b730a61146409cce1e842" translate="yes" xml:space="preserve">
          <source>When a new connection is received, the client &lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt; is retrieved (`nextPendingConnection()`), and the signals we are interested in are connected to our slots (`textMessageReceived()`, `binaryMessageReceived()` and `disconnected()`). The client socket is remembered in a list, in case we would like to use it later (in this example, nothing is done with it).</source>
          <target state="translated">새로운 연결이 수신되면 클라이언트 &lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt; 이 검색되고 (`nextPendingConnection ()`) 관심있는 신호가 슬롯 (`textMessageReceived ()`,`binaryMessageReceived ()`및`disconnected ()`에 연결됩니다. ). 클라이언트 소켓은 나중에 사용하려는 경우를 위해 목록에 기억됩니다 (이 예에서는 아무 것도 수행되지 않음).</target>
        </trans-unit>
        <trans-unit id="bda773011b553996318d1ca0425ceb0218190f09" translate="yes" xml:space="preserve">
          <source>When a new group is pushed onto the debug groups stack, it will inherit the configuration of the group that was previously on the top of the stack. Vice versa, popping a debug group will restore the configuration of the debug group that becomes the new top.</source>
          <target state="translated">새 그룹을 디버그 그룹 스택으로 푸시하면 이전에 스택 맨 위에 있던 그룹의 구성이 상속됩니다. 반대로 디버그 그룹을 팝업하면 새로운 최상위가되는 디버그 그룹의 구성이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="ec32af560002a3f2954d27992ea538e7e19a3001" translate="yes" xml:space="preserve">
          <source>When a node acquires a replica for a known source, it sends a request for that source to the host node. Upon receipt of this request, the host will create a reply packet with the current values of all properties of the source. If the requested replica is dynamic, it will include the API definition for the source. The replica's node will be included in the list of connections that receive changes to that source from then on.</source>
          <target state="translated">노드는 알려진 소스의 복제본을 획득하면 해당 소스에 대한 요청을 호스트 노드로 보냅니다. 이 요청을 수신하면 호스트는 소스의 모든 속성에 대한 현재 값으로 응답 패킷을 만듭니다. 요청 된 복제본이 동적 인 경우 소스에 대한 API 정의가 포함됩니다. 복제본의 노드는 그때부터 해당 소스에 대한 변경 사항을 수신하는 연결 목록에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d63ba8e6603b8cbc973323b39127ee0bc0ad55ba" translate="yes" xml:space="preserve">
          <source>When a page is about to be shown, &lt;a href=&quot;qwizard&quot;&gt;QWizard&lt;/a&gt; calls &lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt;() (which in turn calls &lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage::initializePage&lt;/a&gt;()) to fill the page with default values. By default, this function does nothing, but it can be reimplemented to initialize the page's contents based on other pages' fields (see the &lt;a href=&quot;qwizard#initialize-page&quot;&gt;example above&lt;/a&gt;).</source>
          <target state="translated">페이지가 표시하려고 할 때, &lt;a href=&quot;qwizard&quot;&gt;QWizard는&lt;/a&gt; 호출 &lt;a href=&quot;qwizard#initializePage&quot;&gt;initializePage&lt;/a&gt; () (차례로 호출하는 &lt;a href=&quot;qwizardpage#initializePage&quot;&gt;QWizardPage :: initializePage가&lt;/a&gt; 기본 값으로 페이지를 채우기 위해 ()). 기본적으로이 함수는 아무 작업도 수행하지 않지만 다른 페이지의 필드를 기반으로 페이지의 내용을 초기화하도록 다시 구현할 수 있습니다 (&lt;a href=&quot;qwizard#initialize-page&quot;&gt; 위 예 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c63e8b4686c2ce6ea480da0dde82d96ac157403d" translate="yes" xml:space="preserve">
          <source>When a parallel state group is entered, all its child states will be simultaneously entered. Transitions within the individual child states operate normally. However, any of the child states may take a transition which exits the parent state. When this happens, the parent state and all of its child states are exited.</source>
          <target state="translated">병렬 상태 그룹이 입력되면 모든 하위 상태가 동시에 입력됩니다. 개별 하위 상태 내에서의 전환은 정상적으로 작동합니다. 그러나 모든 하위 상태는 상위 상태를 종료하는 전환을 수행 할 수 있습니다. 이 경우 상위 상태 및 모든 하위 상태가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="f1b2b5f7aefbb0cb0ec4ae4792cb7356d5cdee30" translate="yes" xml:space="preserve">
          <source>When a partial match is found, no captured substrings are returned, and the (implicit) capturing group 0 corresponding to the whole match captures the partially matched substring of the subject string.</source>
          <target state="translated">부분 일치가 발견되면 캡처 된 하위 문자열이 리턴되지 않고 전체 일치에 해당하는 (암시 적) 캡처 그룹 0이 주제 문자열의 부분 일치 하위 문자열을 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="949ea8688bbfcd915778d80bb9ad32883794d483" translate="yes" xml:space="preserve">
          <source>When a pinch gesture is started, the rotation is &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">핀치 제스처가 시작되면 회전은 &lt;code&gt;0.0&lt;/code&gt; 입니다 입니다.</target>
        </trans-unit>
        <trans-unit id="6eeed75e83f5493322e8f521ba32040bf1a5bd87" translate="yes" xml:space="preserve">
          <source>When a pinch gesture is started, the scale is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">핀치 제스처가 시작되면 배율은 &lt;code&gt;1.0&lt;/code&gt; 입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="3947f323d774ee42a9f53aab29ffa36c8280798a" translate="yes" xml:space="preserve">
          <source>When a pixmap is inserted and the cache is about to exceed its limit, it removes pixmaps until there is enough room for the pixmap to be inserted.</source>
          <target state="translated">픽스맵이 삽입되고 캐시가 한계를 초과하려고하면 픽스맵을 삽입 할 공간이 충분해질 때까지 픽스맵을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="14e43d5273a0f220d3f6cca0d60985a5d4b8fc21" translate="yes" xml:space="preserve">
          <source>When a place is removed, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit the &lt;a href=&quot;qplacemanager#placeRemoved&quot;&gt;QPlaceManager::placeRemoved&lt;/a&gt;() signal. Whether a manager does so is provider specific. Managers accessing places from a web service will typically not emit these signals, while managers accessing places stored locally generally will.</source>
          <target state="translated">장소가 제거되면 &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; 가 &lt;a href=&quot;qplacemanager#placeRemoved&quot;&gt;QPlaceManager :: placeRemoved를&lt;/a&gt; 방출 할 수 있습니다. () 신호를 . 관리자가 그렇게하는지 여부는 공급자마다 다릅니다. 웹 서비스에서 장소에 액세스하는 관리자는 일반적으로 이러한 신호를 내 보내지 않지만 로컬에 저장된 장소에 액세스하는 관리자는 일반적으로 신호를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="955b392e62b44331ff658695f8bca3787dde24b9" translate="yes" xml:space="preserve">
          <source>When a place is saved, the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; may emit QPlaceManager::placedAdded() or &lt;a href=&quot;qplacemanager#placeUpdated&quot;&gt;QPlaceManager::placeUpdated&lt;/a&gt;() signals. However whether a manager does so or not is provider specific, managers accessing places from a web service will typically not emit these signals while managers accessing places locally stored generally will.</source>
          <target state="translated">장소가 저장되면 &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; 가 QPlaceManager :: placedAdded () 또는 &lt;a href=&quot;qplacemanager#placeUpdated&quot;&gt;QPlaceManager :: placeUpdated&lt;/a&gt; () 신호를 방출 할 수 있습니다 . 그러나, 관리자가 제공하는지 여부는 공급자별로 다르지만, 웹 서비스에서 장소에 액세스하는 관리자는 일반적으로 이러한 신호를 방출하지 않지만 일반적으로 로컬에 저장된 장소에 액세스하는 관리자는 신호를 방출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb76ccab6b6330b8216b91871b1f1a7518967e70" translate="yes" xml:space="preserve">
          <source>When a preprocessor symbol is specified using the &lt;code&gt;defines&lt;/code&gt; variable, you can also use the &lt;a href=&quot;12-0-qdoc-commands-miscellaneous#if-command&quot;&gt;\if&lt;/a&gt; command to enclose documentation that only will be included if the preprocessor symbol is defined.</source>
          <target state="translated">&lt;code&gt;defines&lt;/code&gt; 변수를 사용하여 전 처리기 기호를 지정 하면 &lt;a href=&quot;12-0-qdoc-commands-miscellaneous#if-command&quot;&gt;\ if&lt;/a&gt; 명령을 사용 하여 전 처리기 기호가 정의 된 경우에만 포함되는 설명서를 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f785beae5730b83f41acbcf90ef75b7556aac2f1" translate="yes" xml:space="preserve">
          <source>When a press event occurs, each instance of &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; chooses a single point which is not yet &quot;taken&quot; at that moment: if the press occurs within the bounds of the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt;, and no sibling &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; within the same &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; has yet acquired a passive grab on that point, and if the other constraints such as &lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt; etc. are satisfied, it's eligible, and the &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; then acquires a passive grab. In this way, the &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler::parent&lt;/a&gt; acts like an exclusive group: there can be multiple instances of &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt;, and the set of pressed touchpoints will be distributed among them. Each &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; which has chosen a point to track has its &lt;a href=&quot;stylesheet-reference#active&quot;&gt;active&lt;/a&gt; property &lt;code&gt;true&lt;/code&gt;. It then continues to track its chosen point until release: the properties of the &lt;a href=&quot;qml-point&quot;&gt;point&lt;/a&gt; will be kept up-to-date. Any Item can bind to these properties, and thereby follow the point's movements.</source>
          <target state="translated">프레스 이벤트가 발생하면 &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler의&lt;/a&gt; 각 인스턴스는 해당 시점에 아직 &quot;취득되지 않은&quot;단일 포인트를 선택합니다. 프레스가 &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt; 범위 내에서 발생 하고 동일한 &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: parent&lt;/a&gt; 내에 형제 &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler가&lt;/a&gt; 없는 경우 그러나이 시점에서 수동 손잡이를 취득하고, 같은 경우, 다른 제약있다 &lt;a href=&quot;qml-qtquick-pointhandler#acceptedButtons-prop&quot;&gt;acceptedButtons&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-pointhandler#acceptedDevices-prop&quot;&gt;acceptedDevices&lt;/a&gt; 등이 충족되고, 그것의 자격과 &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler는&lt;/a&gt; 다음 수동 손잡이를 취득한다. 이러한 방법으로, &lt;a href=&quot;qml-qtquick-pointhandler#parent-prop&quot;&gt;PointerHandler :: 부모는&lt;/a&gt; 독점 그룹 같은 역할 :의 여러 인스턴스가있을 수 &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt;을 누르면 일련의 눌린 터치 포인트가 그 사이에 분배됩니다. 추적 할 지점을 선택한 각 &lt;a href=&quot;qml-qtquick-pointhandler&quot;&gt;PointHandler&lt;/a&gt; 의 &lt;a href=&quot;stylesheet-reference#active&quot;&gt;활성&lt;/a&gt; 속성은 &lt;code&gt;true&lt;/code&gt; 입니다. 그런 다음 릴리스 때까지 선택 점을 계속 추적 :의 특성 &lt;a href=&quot;qml-point&quot;&gt;포인트가&lt;/a&gt; 최신 상태로 유지됩니다. 모든 아이템은 이러한 속성에 바인딩되어 포인트의 움직임을 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfbfb0ebbd6646025b981fa339de3293519a353e" translate="yes" xml:space="preserve">
          <source>When a print request is accepted, the printer status would change, triggering a change in the status property. This would then be reported to all Replicas.</source>
          <target state="translated">인쇄 요청이 수락되면 프린터 상태가 변경되어 상태 속성이 변경됩니다. 그런 다음 모든 복제본에보고됩니다.</target>
        </trans-unit>
        <trans-unit id="666537301706b87af8a406d9ea46793d0d017481" translate="yes" xml:space="preserve">
          <source>When a process using &lt;a href=&quot;qsystemsemaphore&quot;&gt;QSystemSemaphore&lt;/a&gt; terminates for any reason, Unix automatically reverses the effect of all acquire operations that were not released. Thus if the process acquires a resource and then exits without releasing it, Unix will release that resource.</source>
          <target state="translated">어떤 이유로 든 &lt;a href=&quot;qsystemsemaphore&quot;&gt;QSystemSemaphore를&lt;/a&gt; 사용하는 프로세스가 종료되면 Unix는 릴리스되지 않은 모든 획득 작업의 효과를 자동으로 되돌립니다. 따라서 프로세스가 자원을 확보 한 후 해제하지 않고 종료하면 Unix는 해당 자원을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="3fb2e9f6ef5f613c87a38c8fd666c38c8b51fe6f" translate="yes" xml:space="preserve">
          <source>When a property sheet extension is required,</source>
          <target state="translated">속성 시트 확장이 필요한 경우</target>
        </trans-unit>
        <trans-unit id="a0431b9169541b5942ac50072a09a56ca2303178" translate="yes" xml:space="preserve">
          <source>When a property value source object is assigned to a property, QML first tries to assign it normally, as though it were a regular QML type. Only if this assignment fails does the engine call the &lt;a href=&quot;qqmlpropertyvaluesource#setTarget&quot;&gt;setTarget()&lt;/a&gt; method. This allows the type to also be used in contexts other than just as a value source.</source>
          <target state="translated">특성 값 소스 오브젝트가 특성에 지정되면 QML은 먼저 일반 QML 유형 인 것처럼 정상적으로 지정하려고합니다. 이 지정이 실패한 경우에만 엔진이 &lt;a href=&quot;qqmlpropertyvaluesource#setTarget&quot;&gt;setTarget ()&lt;/a&gt; 메소드를 호출합니다 . 따라서 유형을 값 소스가 아닌 다른 컨텍스트에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="865208c91375893b92d822994a4204209a37ba98" translate="yes" xml:space="preserve">
          <source>When a query is run on XML data, as in the snippet above, the &lt;code&gt;doc()&lt;/code&gt; function returns the node in the built-in data model where the query evaluation will begin. But when a query is run on a custom node model containing non-XML data, one of the &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt;() functions must be called to bind a variable name to a starting node in the custom model. A $variable reference is used in the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; text to access the starting node in the custom model. It is not necessary to declare the variable name external in the query. See the example in the documentation for &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;.</source>
          <target state="translated">위의 스 니펫에서와 같이 XML 데이터에서 쿼리를 실행하면 &lt;code&gt;doc()&lt;/code&gt; 함수는 쿼리 평가가 시작될 내장 데이터 모델의 노드를 반환합니다. 그러나 XML이 아닌 데이터가 포함 된 사용자 정의 노드 모델에서 쿼리를 실행할 때 변수 이름을 사용자 정의 모델의 시작 노드에 바인딩하려면 &lt;a href=&quot;qxmlquery#bindVariable&quot;&gt;bindVariable&lt;/a&gt; () 함수 중 하나를 호출해야합니다. $ 변수 참조는 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 텍스트에서 사용자 정의 모델의 시작 노드에 액세스하는 데 사용됩니다 . 쿼리에서 변수 이름을 외부로 선언 할 필요는 없습니다. &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt; 문서의 예제를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b9712c67436ef44e2898fc4063b230c597593f7" translate="yes" xml:space="preserve">
          <source>When a query runs, it parses documents, allocating internal data structures to hold them, and it may load other resources over the network. It reuses these allocated resources when possible, to avoid having to reload and reparse them.</source>
          <target state="translated">쿼리가 실행될 때 문서를 구문 분석하고이를 보유하기 위해 내부 데이터 구조를 할당하며 네트워크를 통해 다른 리소스를로드 할 수 있습니다. 재 할당 및 재분석을 피하기 위해 가능하면 이러한 할당 된 자원을 재사용합니다.</target>
        </trans-unit>
        <trans-unit id="8a593010a6662d2b59e4a72e57582a95f2f8033f" translate="yes" xml:space="preserve">
          <source>When a rectangular clip is set in combination with &lt;a href=&quot;qsgclipnode#setIsRectangular&quot;&gt;setIsRectangular&lt;/a&gt; the renderer may in some cases use a more optimal clip method.</source>
          <target state="translated">직사각형 클립을 &lt;a href=&quot;qsgclipnode#setIsRectangular&quot;&gt;setIsRectangular&lt;/a&gt; 와 함께 설정 하면 렌더러가 더 최적의 클립 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65c8e122245f9ff6c381bb4990517a1724e6f958" translate="yes" xml:space="preserve">
          <source>When a relative URL is written to a &lt;code&gt;url&lt;/code&gt; type property, it is converted into a URL object, so &lt;b&gt;matching the URL value against the input string value will fail&lt;/b&gt;. Instead, convert the string to a URL using Qt.resolvedUrl() for means of comparison, and use &lt;code&gt;toString()&lt;/code&gt; to get the contents of the URL:</source>
          <target state="translated">상대 URL이 &lt;code&gt;url&lt;/code&gt; 유형 특성에 기록되면 URL 오브젝트로 변환되므로 &lt;b&gt;URL 값을 입력 문자열 값과 일치시키는 데 실패&lt;/b&gt; 합니다. 대신 비교를 위해 Qt.resolvedUrl ()을 사용하여 문자열을 URL로 변환하고 &lt;code&gt;toString()&lt;/code&gt; 을 사용 하여 URL의 컨텐츠를 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="fccc71619fd1248dd374a7ce2288a8bbb7a01715" translate="yes" xml:space="preserve">
          <source>When a scene is set on a view, the &lt;a href=&quot;qgraphicsscene#changed&quot;&gt;QGraphicsScene::changed&lt;/a&gt;() signal is automatically connected to this view's &lt;a href=&quot;qgraphicsview#updateScene&quot;&gt;updateScene&lt;/a&gt;() slot, and the view's scroll bars are adjusted to fit the size of the scene.</source>
          <target state="translated">장면에 뷰가 설정되면 &lt;a href=&quot;qgraphicsscene#changed&quot;&gt;QGraphicsScene :: changed&lt;/a&gt; () 신호가이 뷰의 &lt;a href=&quot;qgraphicsview#updateScene&quot;&gt;updateScene&lt;/a&gt; () 슬롯에 자동으로 연결되고 뷰의 스크롤 막대가 장면의 크기에 맞게 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="a9d5b266152d0f4cd9bb69c2a4c651cf03cd822b" translate="yes" xml:space="preserve">
          <source>When a shared object is created, it sets the reference count to 1. The reference count is incremented whenever a new object references the shared data, and decremented when the object dereferences the shared data. The shared data is deleted when the reference count becomes zero.</source>
          <target state="translated">공유 객체는 생성 될 때 참조 카운트를 1로 설정합니다. 참조 카운트는 새 객체가 공유 데이터를 참조 할 때마다 증가하고 객체가 공유 데이터를 역 참조 할 때 감소합니다. 참조 횟수가 0이되면 공유 데이터가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="cc3649a6da4b8adb60932067105d0642a4d24c46" translate="yes" xml:space="preserve">
          <source>When a shortcut's key sequence is completed, activatedAmbiguously() is emitted if the key sequence is still ambiguous (i.e., it is the start of one or more other shortcuts). The &lt;a href=&quot;qshortcut#activated&quot;&gt;activated&lt;/a&gt;() signal is not emitted in this case.</source>
          <target state="translated">바로 가기 키 시퀀스가 ​​완료되면 키 시퀀스가 ​​여전히 모호한 경우 (즉, 하나 이상의 다른 바로 가기의 시작 인 경우) activateAmbiguously ()가 발생합니다. 이 &lt;a href=&quot;qshortcut#activated&quot;&gt;경우 활성화 된&lt;/a&gt; () 신호가 방출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6332ae030a9135a45f7906377ec58084cbfab446" translate="yes" xml:space="preserve">
          <source>When a signal is emitted, the slots connected to it are usually executed immediately, just like a normal function call. When this happens, the signals and slots mechanism is totally independent of any GUI event loop. Execution of the code following the &lt;code&gt;emit&lt;/code&gt; statement will occur once all slots have returned. The situation is slightly different when using &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;queued connections&lt;/a&gt;; in such a case, the code following the &lt;code&gt;emit&lt;/code&gt; keyword will continue immediately, and the slots will be executed later.</source>
          <target state="translated">신호가 방출되면 연결된 함수는 보통 일반 함수 호출과 마찬가지로 즉시 실행됩니다. 이 경우 신호 및 슬롯 메커니즘은 GUI 이벤트 루프와 완전히 독립적입니다. 모든 슬롯이 반환되면 &lt;code&gt;emit&lt;/code&gt; 문 다음에 나오는 코드가 실행 됩니다. &lt;a href=&quot;qt#ConnectionType-enum&quot;&gt;대기 연결을&lt;/a&gt; 사용할 때 상황이 약간 다릅니다 . 이 경우 &lt;code&gt;emit&lt;/code&gt; 키워드 다음에 오는 코드 는 즉시 계속되고 슬롯은 나중에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9ddb05e9c434f565919399ed11ae59e44adc1a53" translate="yes" xml:space="preserve">
          <source>When a slot is called in an object due to a signal delivery or due to a remote method call, it is sometimes necessary to know the context in which that happened. In particular, if the slot determines that it wants to send the reply at a later opportunity or if it wants to reply with an error, the context is needed.</source>
          <target state="translated">신호 전달 또는 원격 메소드 호출로 인해 오브젝트에서 슬롯이 호출 될 때 발생하는 컨텍스트를 알아야하는 경우가 있습니다. 특히, 슬롯이 나중에 기회에 응답을 보내려고한다고 판단하거나 오류로 응답하려면 컨텍스트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b82f70b447a179232f4e12d074947bc0969bd039" translate="yes" xml:space="preserve">
          <source>When a split handle is dragged, the &lt;code&gt;SplitView.preferredWidth&lt;/code&gt; or &lt;code&gt;SplitView.preferredHeight&lt;/code&gt; property is overwritten, depending on the &lt;a href=&quot;qml-qtquick-controls2-splitview#orientation-prop&quot;&gt;orientation&lt;/a&gt; of the view.</source>
          <target state="translated">분할 핸들을 끌면 뷰 의 &lt;a href=&quot;qml-qtquick-controls2-splitview#orientation-prop&quot;&gt;방향&lt;/a&gt; 에 따라 &lt;code&gt;SplitView.preferredWidth&lt;/code&gt; 또는 &lt;code&gt;SplitView.preferredHeight&lt;/code&gt; 속성을 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="7d4d5ea445229544da0d5338a305894b8698bdd0" translate="yes" xml:space="preserve">
          <source>When a split item is resized, the preferredHeight will be set in order to keep track of the new size.</source>
          <target state="translated">분할 항목의 크기를 조정하면 새 크기를 추적하기 위해 preferredHeight가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="161235a5aac72fca97ccfb11b438ac5fe662b266" translate="yes" xml:space="preserve">
          <source>When a split item is resized, the preferredWidth will be set in order to keep track of the new size.</source>
          <target state="translated">분할 항목의 크기가 조정되면 새 크기를 추적하기 위해 preferredWidth가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2a09b738b648e2f453338d46763c1dca7735230f" translate="yes" xml:space="preserve">
          <source>When a stack is added to a group using &lt;a href=&quot;qundogroup#addStack&quot;&gt;addStack&lt;/a&gt;(), the group does not take ownership of the stack. This means the stack has to be deleted separately from the group. When a stack is deleted, it is automatically removed from a group. A stack may belong to only one group. Adding it to another group will cause it to be removed from the previous group.</source>
          <target state="translated">&lt;a href=&quot;qundogroup#addStack&quot;&gt;addStack&lt;/a&gt; ()을 사용하여 스택을 그룹에 추가 하면 그룹은 스택의 소유권을 갖지 않습니다. 이는 스택을 그룹과 별도로 삭제해야 함을 의미합니다. 스택이 삭제되면 그룹에서 자동으로 제거됩니다. 스택은 하나의 그룹에만 속할 수 있습니다. 다른 그룹에 추가하면 이전 그룹에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3d6e4a2b53c50f2891abb48a8f6f6cc25d79ab52" translate="yes" xml:space="preserve">
          <source>When a state extends another state, it inherits all the changes of that state.</source>
          <target state="translated">상태가 다른 상태를 확장하면 해당 상태의 모든 변경 사항이 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="6a4a099453c8a8d91cb5a5c167ee9f1538c09b8c" translate="yes" xml:space="preserve">
          <source>When a state is active, all its parent states are active by definition. When</source>
          <target state="translated">상태가 활성화되면 모든 상위 상태가 정의에 따라 활성화됩니다. 언제</target>
        </trans-unit>
        <trans-unit id="ba9d99ab4b7d6deb7d6417df3035d1441aabe91d" translate="yes" xml:space="preserve">
          <source>When a state is exited prior to the animation finishing, the behavior of the state machine depends on the target state of the transition. If the target state explicitly assigns a value to the property, no additional action will be taken. The property will be assigned the value defined by the target state.</source>
          <target state="translated">애니메이션 마무리 전에 상태가 종료되면 상태 머신의 동작은 전환의 대상 상태에 따라 다릅니다. 대상 상태가 명시 적으로 속성에 값을 할당하면 추가 작업이 수행되지 않습니다. 속성에 대상 상태에 의해 정의 된 값이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="537b863aa4165206f1678fd45b68c897e7e5bb32" translate="yes" xml:space="preserve">
          <source>When a string is surrounded by slashes, it is interpreted as a &lt;a href=&quot;qregularexpression&quot;&gt;regular expression&lt;/a&gt;.</source>
          <target state="translated">문자열을 슬래시로 묶으면 &lt;a href=&quot;qregularexpression&quot;&gt;정규식으로&lt;/a&gt; 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4d38a1eefb6595f564c6b5c58858271837243de" translate="yes" xml:space="preserve">
          <source>When a style sheet is active, the &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; returned by &lt;a href=&quot;qwidget#style&quot;&gt;QWidget::style&lt;/a&gt;() is a wrapper &quot;style sheet&quot; style,</source>
          <target state="translated">스타일 시트가 활성화되면 &lt;a href=&quot;qwidget#style&quot;&gt;QWidget :: style&lt;/a&gt; ()에 의해 리턴 된 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 은 랩퍼 &quot;스타일 시트&quot;스타일입니다.</target>
        </trans-unit>
        <trans-unit id="e7f2cf6a190dccb2e1846d702f8b4fdcc1492b48" translate="yes" xml:space="preserve">
          <source>When a task menu extension is required,</source>
          <target state="translated">작업 메뉴 확장이 필요한 경우</target>
        </trans-unit>
        <trans-unit id="67462236b92450150e95164abdc0c9f99abaed6b" translate="yes" xml:space="preserve">
          <source>When a timer is started, the first trigger is usually after the specified interval has elapsed. It is sometimes desirable to trigger immediately when the timer is started; for example, to establish an initial state.</source>
          <target state="translated">타이머가 시작되면 첫 번째 트리거는 일반적으로 지정된 간격이 경과 한 후입니다. 때로는 타이머가 시작될 때 즉시 트리거하는 것이 바람직합니다. 예를 들어 초기 상태를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="af89fc9ae90b687bd3803dfbbaa74da9d0b068bb" translate="yes" xml:space="preserve">
          <source>When a toolbar is resized in such a way that it is too small to show all the items it contains, an extension button will appear as the last item in the toolbar. Pressing the extension button will pop up a menu containing the items that do not currently fit in the toolbar.</source>
          <target state="translated">툴바의 크기가 너무 작아 툴바에 포함 된 모든 항목을 표시 할 수없는 경우 툴바의 마지막 항목으로 확장 버튼이 나타납니다. 확장 버튼을 누르면 현재 툴바에 맞지 않는 항목이 포함 된 메뉴가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="fd7d3a341e5fbdb2b1a43242fcba495d019b0218" translate="yes" xml:space="preserve">
          <source>When a validator is set, the text field will only accept input which leaves the text property in an intermediate state. The &lt;a href=&quot;qml-qtquick-controls2-combobox#accepted-signal&quot;&gt;accepted&lt;/a&gt; signal will only be emitted if the text is in an acceptable state when the &lt;b&gt;Return&lt;/b&gt; or &lt;b&gt;Enter&lt;/b&gt; key is pressed.</source>
          <target state="translated">유효성 검사기가 설정되면 텍스트 필드는 텍스트 속성을 중간 상태로 유지하는 입력 만 허용합니다. &lt;a href=&quot;qml-qtquick-controls2-combobox#accepted-signal&quot;&gt;받아&lt;/a&gt; 때 텍스트가 허용 상태에있는 경우에만 신호를 방출한다 &lt;b&gt;반환&lt;/b&gt; 또는이 &lt;b&gt;입력합니다&lt;/b&gt; 키가 눌려진다.</target>
        </trans-unit>
        <trans-unit id="9881f5360fc059aa0376cd9d05bbf2f898c14217" translate="yes" xml:space="preserve">
          <source>When a variable or property holds a basic type and it is assigned to another variable or property, then a copy of the value is made. In JavaScript, this value is called a primitive value.</source>
          <target state="translated">변수 나 속성에 기본 유형이 있고 다른 변수 나 속성에 할당되면 값의 복사본이 만들어집니다. JavaScript에서이 값을 기본 값이라고합니다.</target>
        </trans-unit>
        <trans-unit id="c53c2d5ff931b774b8c26a43310ae5dc80383c71" translate="yes" xml:space="preserve">
          <source>When a version number is specified (using the &lt;code&gt;&lt;a href=&quot;#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; variables in a &lt;code&gt;.qdocconf&lt;/code&gt; file), it is accessible through the corresponding \version command for use in the documentation.</source>
          <target state="translated">&lt;code&gt;.qdocconf&lt;/code&gt; 파일 에서 &lt;code&gt;&lt;a href=&quot;#version&quot;&gt;version&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#versionsym&quot;&gt;versionsym&lt;/a&gt;&lt;/code&gt; 변수를 사용하여 버전 번호를 지정 하면 해당 \ version 명령을 통해 문서에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1aed6e59537ae181997a746ca0c8b7b7d30d9468" translate="yes" xml:space="preserve">
          <source>When a view transition is initialized, any property bindings that refer to the &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; attached property are evaluated in preparation for the transition. Due to the nature of the internal construction of a view transition, the attributes of the &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; attached property are only valid for the relevant item when the transition is initialized, and may not be valid when the transition is actually run.</source>
          <target state="translated">뷰 전환이 초기화되면 &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; 연결 속성 을 참조하는 모든 속성 바인딩이 전환 준비 과정에서 평가됩니다. 뷰 전환의 내부 구성 특성으로 인해 &lt;a href=&quot;qml-qtquick-viewtransition&quot;&gt;ViewTransition&lt;/a&gt; 첨부 속성의 속성은 전환이 초기화 될 때 관련 항목에만 유효하며 전환이 실제로 실행될 때는 유효하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="079663e19f7c1ba992af80c0570d23237432e8c5" translate="yes" xml:space="preserve">
          <source>When a web site requests an SSL client certificate, and one or more certificates are found in the system's client certificate store, this class provides access to the certificates to choose from, as well as a method for selecting one.</source>
          <target state="translated">웹 사이트가 SSL 클라이언트 인증서를 요청하고 시스템의 클라이언트 인증서 저장소에서 하나 이상의 인증서가 발견되면이 클래스는 선택할 인증서에 대한 액세스 권한과 인증서 선택 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="47f6110b5cfc30bcf437b8673336a30eccbb3a9e" translate="yes" xml:space="preserve">
          <source>When a web site requests an SSL client certificate, and one or more certificates are found in the system's client certificate store, this type provides access to the certificates to choose from, as well as a method for selecting one.</source>
          <target state="translated">웹 사이트가 SSL 클라이언트 인증서를 요청하고 시스템의 클라이언트 인증서 저장소에 하나 이상의 인증서가있는 경우이 유형은 선택할 인증서에 대한 액세스 권한과 인증서 선택 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1a0abde4adaf9ada28bc188c310ca57b1baed315" translate="yes" xml:space="preserve">
          <source>When a widget &lt;a href=&quot;qwidget#acceptDrops-prop&quot;&gt;accepts drop events&lt;/a&gt;, it will receive this event if it has accepted the most recent &lt;a href=&quot;qdragenterevent&quot;&gt;QDragEnterEvent&lt;/a&gt; or &lt;a href=&quot;qdragmoveevent&quot;&gt;QDragMoveEvent&lt;/a&gt; sent to it.</source>
          <target state="translated">위젯 &lt;a href=&quot;qwidget#acceptDrops-prop&quot;&gt;이 드롭 이벤트&lt;/a&gt; 를 승인하면 가장 최근에 전송 된 &lt;a href=&quot;qdragenterevent&quot;&gt;QDragEnterEvent&lt;/a&gt; 또는 &lt;a href=&quot;qdragmoveevent&quot;&gt;QDragMoveEvent를&lt;/a&gt; 승인 한 경우이 이벤트를 수신 합니다.</target>
        </trans-unit>
        <trans-unit id="460e4079ae7809950eebb7e9e8f3fa669aaa1958" translate="yes" xml:space="preserve">
          <source>When a widget asks a style to draw an element, it provides the style with a &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;, which is a class that contains the information necessary for drawing. Thanks to &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt;, it is possible to make &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; draw widgets without linking in any code for the widget. This makes it possible to use &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;'s draw functions on any paint device, i.e., you can draw a combobox on any widget, not just on a &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;.</source>
          <target state="translated">위젯이 스타일을 요청하여 요소를 그리면 스타일에 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption을&lt;/a&gt; 제공합니다. QStyleOption 은 그리기에 필요한 정보가 포함 된 클래스입니다. 덕분에 &lt;a href=&quot;qstyleoption&quot;&gt;QStyleOption&lt;/a&gt; , 할 수 &lt;a href=&quot;qstyle&quot;&gt;QStyle이&lt;/a&gt; 위젯 코드에 연결하지 않고 위젯을 그립니다. 따라서 모든 페인트 장치에서 &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt; 의 그리기 기능을 사용할 수 있습니다. 즉, &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; 뿐만 아니라 모든 위젯에서 콤보 박스를 그릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6f3f2c1aa86e2bdbf72b92865fad22cdf8f8992" translate="yes" xml:space="preserve">
          <source>When a widget is selected, normal clipboard operations such as cut, copy, and paste can be performed on it. All of these operations can be done and undone, as necessary.</source>
          <target state="translated">위젯을 선택하면 잘라 내기, 복사 및 붙여 넣기와 같은 일반적인 클립 보드 작업을 수행 할 수 있습니다. 필요에 따라 이러한 모든 작업을 수행하고 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32939db177a40f178792d1ab4a3586964a02a117" translate="yes" xml:space="preserve">
          <source>When a widget is used as a container to group a number of child widgets, it is known as a composite widget. These can be created by constructing a widget with the required visual properties - a &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt;, for example - and adding child widgets to it, usually managed by a layout. The above diagram shows such a composite widget that was created using Qt Designer.</source>
          <target state="translated">위젯을 여러 하위 위젯을 그룹화하기위한 컨테이너로 사용하는 경우이를 복합 위젯이라고합니다. 필요한 시각적 속성 ( 예 : &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt; )으로 위젯을 구성하고 일반적으로 레이아웃으로 관리되는 하위 위젯을 추가 하여 작성할 수 있습니다. 위의 다이어그램은 Qt Designer를 사용하여 작성된 복합 위젯을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="752f1a934fb7040e2a75e0adc0d7c4e3b00e3529" translate="yes" xml:space="preserve">
          <source>When a widget's font changes, it resolves its entries against its parent widget. If the widget does not have a parent widget, it resolves its entries against the scene. The widget then sends itself a &lt;a href=&quot;qevent#Type-enum&quot;&gt;FontChange&lt;/a&gt; event and notifies all its descendants so that they can resolve their fonts as well.</source>
          <target state="translated">위젯의 글꼴이 변경되면 해당 위젯이 상위 위젯에 대해 해당 항목을 해결합니다. 위젯에 상위 위젯이 없으면 장면에 대한 항목을 분석합니다. 그런 다음 위젯은 자체적으로 &lt;a href=&quot;qevent#Type-enum&quot;&gt;FontChange&lt;/a&gt; 이벤트 를 전송하고 모든 하위 항목에 통지하여 글꼴을 확인할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="8a4c47081bd0d78ce71a943dd5b9dd67bf60e6f3" translate="yes" xml:space="preserve">
          <source>When a widget's palette changes, it resolves its entries against its parent widget, or if it doesn't have a parent widget, it resolves against the scene. It then sends itself a &lt;a href=&quot;qevent#Type-enum&quot;&gt;PaletteChange&lt;/a&gt; event, and notifies all its descendants so they can resolve their palettes as well.</source>
          <target state="translated">위젯의 팔레트가 변경되면 상위 위젯에 대한 항목을 분석하거나 상위 위젯이없는 경우 장면에 대해 분석됩니다. 그런 다음 자신에게 &lt;a href=&quot;qevent#Type-enum&quot;&gt;PaletteChange&lt;/a&gt; 이벤트 를 보내고 모든 후손에게 알릴 수 있도록 팔레트를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c935a584189a93e055ba79f2173aba07e5d505b" translate="yes" xml:space="preserve">
          <source>When a window is not visible its visibility is Hidden, and setting visibility to &lt;a href=&quot;qwindow#Visibility-enum&quot;&gt;Hidden&lt;/a&gt; is the same as setting &lt;a href=&quot;qml-qtquick-window-window#visible-prop&quot;&gt;visible&lt;/a&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">윈도우가 보이지 않으면 가시성은 숨겨지고 &lt;a href=&quot;qwindow#Visibility-enum&quot;&gt;숨김&lt;/a&gt; 으로 가시성을 설정하는 것은 &lt;a href=&quot;qml-qtquick-window-window#visible-prop&quot;&gt;visible&lt;/a&gt; 을 &lt;code&gt;false&lt;/code&gt; 로 설정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="328cfe9dc26b3602c3dd93834eca6371ca53bcbc" translate="yes" xml:space="preserve">
          <source>When a window is using an OpenGL based surface and is appearing in full screen mode, problems can occur with other top-level windows which are part of the application. Due to limitations of the Windows DWM, compositing is not handled correctly for OpenGL based windows when going into full screen mode. As a result, other top-level windows are not placed on top of the full screen window when they are made visible. For example, menus may not appear correctly, or dialogs fail to show up.</source>
          <target state="translated">창에서 OpenGL 기반 표면을 사용하고 전체 화면 모드로 표시되는 경우 응용 프로그램의 일부인 다른 최상위 창에서 문제가 발생할 수 있습니다. Windows DWM의 제한으로 인해 전체 화면 모드로 전환 할 때 OpenGL 기반 창에 대해 합성이 올바르게 처리되지 않습니다. 결과적으로 다른 최상위 창은 표시 될 때 전체 화면 창 위에 배치되지 않습니다. 예를 들어, 메뉴가 올바르게 나타나지 않거나 대화 상자가 표시되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6e925bbf3d90d27901234a3378310aa8ca76a99" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;. Be aware however that this breaks stacking order, for example it will not be possible to have other widgets on top of the &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt;, so it should only be used in situations where a semi-transparent &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; with other widgets visible underneath is required.</source>
          <target state="translated">절대적으로 필요한 경우,이 제한은 설정하여 극복 할 수 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt는 :: WA_AlwaysStackOnTop의&lt;/a&gt; 온 속성 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget을&lt;/a&gt; . 그러나 이것은 스택 순서를 &lt;a href=&quot;qopenglwidget&quot;&gt;깨뜨립니다.&lt;/a&gt; 예를 들어 QOpenGLWidget 위에 다른 위젯을 가질 수 없으므로 아래에 다른 위젯이 보이는 반투명 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 이 필요한 상황에서만 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b6f91c3f1d20bbeecc7d389e5ae573aae0f28831" translate="yes" xml:space="preserve">
          <source>When absolutely necessary, this limitation can be overcome by setting the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_AlwaysStackOnTop&lt;/a&gt; attribute on the &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;. Be aware, however that this breaks stacking order. For example it will not be possible to have other widgets on top of the &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt;, so it should only be used in situations where a semi-transparent &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; with other widgets visible underneath is required.</source>
          <target state="translated">절대적으로 필요한 경우,이 제한은 설정하여 극복 할 수 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt는 :: WA_AlwaysStackOnTop의&lt;/a&gt; 온 속성 &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget을&lt;/a&gt; . 그러나 이렇게하면 쌓임 순서가 깨집니다. 예를 들어, &lt;a href=&quot;qquickwidget&quot;&gt;QQuickWidget&lt;/a&gt; 위에 다른 위젯을 가질 수 &lt;a href=&quot;qquickwidget&quot;&gt;없으므로&lt;/a&gt; 다른 위젯이 보이는 반투명 QQuickWidget 이 필요한 상황에서만 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="9df5199ed73ebbcc06766d6511a4572850a19641" translate="yes" xml:space="preserve">
          <source>When access to the data is no longer needed be sure to call the &lt;a href=&quot;qabstractvideobuffer#unmap&quot;&gt;unmap&lt;/a&gt;() function to release the mapped memory and possibly update the buffer contents.</source>
          <target state="translated">더 이상 데이터에 액세스 할 필요가 없으면 &lt;a href=&quot;qabstractvideobuffer#unmap&quot;&gt;매핑 해제&lt;/a&gt; 메모리를 해제하고 버퍼 내용을 업데이트하기 위해 unmap () 함수를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7f19c431a0d32b110924683908433279ea139496" translate="yes" xml:space="preserve">
          <source>When access to the data is no longer needed, be sure to call the &lt;a href=&quot;qvideoframe#unmap&quot;&gt;unmap&lt;/a&gt;() function to release the mapped memory and possibly update the video frame contents.</source>
          <target state="translated">더 이상 데이터에 액세스 할 필요가 없으면 &lt;a href=&quot;qvideoframe#unmap&quot;&gt;unmap&lt;/a&gt; () 함수를 호출 하여 매핑 된 메모리를 해제하고 비디오 프레임 내용을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="76c2596888d85f6b2c006508a41b7c104d68f3e1" translate="yes" xml:space="preserve">
          <source>When active is &lt;code&gt;true&lt;/code&gt;, and the delegate component is ready, the Instantiator will create objects according to the model. When active is &lt;code&gt;false&lt;/code&gt;, no objects will be created and any previously created objects will be destroyed.</source>
          <target state="translated">active가 &lt;code&gt;true&lt;/code&gt; 이고 델리게이트 구성 요소가 준비되면 Instantiator는 모델에 따라 객체를 만듭니다. active가 &lt;code&gt;false&lt;/code&gt; 인 경우 오브젝트가 작성되지 않으며 이전에 작성된 오브젝트가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="12b8ae889e8cb41399d2e7e574fc759816dcd949" translate="yes" xml:space="preserve">
          <source>When active is true, and the delegate component is ready, the Instantiator will create objects according to the model. When active is false, no objects will be created and any previously created objects will be destroyed.</source>
          <target state="translated">active가 true이고 델리게이트 구성 요소가 준비되면 Instantiator는 모델에 따라 객체를 만듭니다. active가 false이면 오브젝트가 작성되지 않으며 이전에 작성된 오브젝트가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="bb891bbb3b1590bf7288c70b1d889bb5699abbfb" translate="yes" xml:space="preserve">
          <source>When adding or removing intervals from the time range, existing intervals within the range may be expanded, trimmed, deleted, merged or split to ensure that all intervals within the time range remain distinct and disjoint. As a consequence, all intervals added or removed from a time range must be &lt;a href=&quot;qmediatimeinterval#isNormal&quot;&gt;normal&lt;/a&gt;.</source>
          <target state="translated">시간 범위에서 간격을 추가하거나 제거 할 때 시간 범위 내의 모든 간격이 명확하고 분리되지 않도록 범위 내의 기존 간격을 확장, 다듬기, 삭제, 병합 또는 분할 할 수 있습니다. 결과적으로 시간 범위에서 추가 또는 제거 된 모든 간격은 &lt;a href=&quot;qmediatimeinterval#isNormal&quot;&gt;정상&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0d4f3812ee3ea698da8238994dd265c1c75c9c45" translate="yes" xml:space="preserve">
          <source>When adding text to a text edit, it is an advantage to add it in an edit block (see example below). The result is that the text edit does not need to build the entire document structure at once.</source>
          <target state="translated">텍스트 편집에 텍스트를 추가 할 때 편집 블록에 추가하는 것이 유리합니다 (아래 예 참조). 결과적으로 텍스트 편집으로 전체 문서 구조를 한 번에 만들 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bb84371278c0809ff19ae10f5e09e0a84286da38" translate="yes" xml:space="preserve">
          <source>When adding touch events to the sequence,</source>
          <target state="translated">터치 이벤트를 시퀀스에 추가 할 때</target>
        </trans-unit>
        <trans-unit id="f1538eed1aaf041d2e66701f8146b1df9ccdc51d" translate="yes" xml:space="preserve">
          <source>When additional touch points are detected, Qt first looks to see if there are any active touch points on any ancestor or descendent of the widget under the new touch point. If there are, the new touch point is grouped with the first, and the new touch point will be sent in a single &lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent&lt;/a&gt; to the widget that handled the first touch point. (The widget under the new touch point will not receive an event).</source>
          <target state="translated">추가 터치 포인트가 감지되면 Qt는 먼저 새 터치 포인트 아래 위젯의 상위 또는 하위 항목에 활성 터치 포인트가 있는지 확인합니다. 있는 경우 새 터치 포인트가 첫 번째 터치 포인트와 그룹화되고 새 터치 포인트가 단일 &lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent&lt;/a&gt; 에서 첫 번째 터치 포인트를 처리 한 위젯 으로 전송됩니다 . (새로운 터치 포인트 아래의 위젯은 이벤트를받지 않습니다).</target>
        </trans-unit>
        <trans-unit id="e831f4eb7ef019746768c98e62442552c2eec2dc" translate="yes" xml:space="preserve">
          <source>When all the class attribute values are defined as they are in the style.css file that is used for rendering the Qt documentation, the above example is rendered as:</source>
          <target state="translated">Qt 문서를 렌더링하는 데 사용되는 style.css 파일에서와 같이 모든 클래스 속성 값이 정의되면 위 예제는 다음과 같이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="bddff14c450c718712b8166ec8a19a179f1d175d" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-identifiedmodules.html#&quot;&gt;identified module&lt;/a&gt; is imported, the QML engine searches the</source>
          <target state="translated">때 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtqml-modules-identifiedmodules.html#&quot;&gt;식별 모듈이&lt;/a&gt; 수입되면, QML 엔진 검색한다</target>
        </trans-unit>
        <trans-unit id="0cb0af928cd358589c97b0ea36760a95bf56bf0a" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;qml-qtquick-anchoranimation&quot;&gt;AnchorAnimation&lt;/a&gt; is used in a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, it will animate any &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt; that have occurred during the state change. This can be overridden by setting a specific target item using the &lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt; property.</source>
          <target state="translated">때 &lt;a href=&quot;qml-qtquick-anchoranimation&quot;&gt;AnchorAnimation는&lt;/a&gt; (A)에 사용되는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; , 어떤 애니메이션 것이다 &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt; 상태 변화시 발생. &lt;a href=&quot;qml-qtquick-anchorchanges#target-prop&quot;&gt;AnchorChanges.target&lt;/a&gt; 속성을 사용하여 특정 대상 항목을 설정하여이를 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ba28642fdd34030f92c386fbe056673579dd0c3" translate="yes" xml:space="preserve">
          <source>When an accessible object is changed in a way that users need to know about, it notifies clients of the change by sending them an event via the accessible interface. This is how &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; calls &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility()&lt;/a&gt; to indicate that its value has changed:</source>
          <target state="translated">사용자가 알아야 할 방식으로 액세스 가능한 객체가 변경되면 액세스 가능한 인터페이스를 통해 이벤트를 보내 클라이언트에게 변경 사항을 알립니다. 방법이다 &lt;a href=&quot;qslider&quot;&gt;QSlider가&lt;/a&gt; 호출 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qaccessible-obsolete.html#updateAccessibility&quot;&gt;updateAccessibility을 ()&lt;/a&gt; 값이 변경된 것을 나타냅니다 :</target>
        </trans-unit>
        <trans-unit id="6576db350133d85ab8ecdf7d5ae903317f8a0480" translate="yes" xml:space="preserve">
          <source>When an action is paired with buttons and menu items, the &lt;code&gt;enabled&lt;/code&gt;, &lt;code&gt;checkable&lt;/code&gt;, and &lt;code&gt;checked&lt;/code&gt; states are synced automatically. For example, in a word processor, if the user clicks a &quot;Bold&quot; toolbar button, the &quot;Bold&quot; menu item will automatically be checked. Buttons and menu items get their &lt;code&gt;text&lt;/code&gt; and &lt;code&gt;icon&lt;/code&gt; from the action by default. An action-specific &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;icon&lt;/code&gt; can be overridden for a specific control by specifying &lt;code&gt;text&lt;/code&gt; or &lt;code&gt;icon&lt;/code&gt; directly on the control.</source>
          <target state="translated">동작이 버튼 및 메뉴 항목과 쌍을 이루면 &lt;code&gt;enabled&lt;/code&gt; , &lt;code&gt;checkable&lt;/code&gt; 가능 및 &lt;code&gt;checked&lt;/code&gt; 상태가 자동으로 동기화됩니다. 예를 들어 워드 프로세서에서 사용자가 &quot;굵게&quot;도구 모음 단추를 클릭하면 &quot;굵게&quot;메뉴 항목이 자동으로 확인됩니다. 버튼과 메뉴 항목은 기본적으로 작업에서 &lt;code&gt;text&lt;/code&gt; 와 &lt;code&gt;icon&lt;/code&gt; 을 가져옵니다 . 컨트롤에 직접 &lt;code&gt;text&lt;/code&gt; 또는 &lt;code&gt;icon&lt;/code&gt; 을 지정하여 특정 컨트롤에 대해 작업 별 &lt;code&gt;text&lt;/code&gt; 또는 &lt;code&gt;icon&lt;/code&gt; 을 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afbbfa71a43b518eb49ebc7fe0e3a201130db196" translate="yes" xml:space="preserve">
          <source>When an animation is used as a value source or in a Behavior, the default target and property name to be animated can both be inferred.</source>
          <target state="translated">애니메이션을 값 소스 또는 동작으로 사용하는 경우 애니메이션을 적용 할 기본 대상 및 속성 이름을 모두 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="336fbed65cc485dcf3185a5f916cafb70ff1cbed" translate="yes" xml:space="preserve">
          <source>When an animation is used standalone, both the target and property need to be explicitly specified.</source>
          <target state="translated">애니메이션을 독립형으로 사용하는 경우 대상과 속성을 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e063384f01e7cc982fe175643205033a89ac5c6" translate="yes" xml:space="preserve">
          <source>When an application modal dialog is opened, the user must finish interacting with the dialog and close it before they can access any other window in the application. Window modal dialogs only block access to the window associated with the dialog, allowing the user to continue to use other windows in an application.</source>
          <target state="translated">응용 프로그램 모달 대화 상자가 열리면 사용자는 응용 프로그램의 다른 창에 액세스하기 전에 대화 상자와 상호 작용하고 대화 상자를 닫아야합니다. 창 모달 대화 상자는 대화 상자와 관련된 창에 대한 액세스 만 차단하므로 사용자는 응용 프로그램에서 다른 창을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03f1ac029efa0e89898412a8bc3f237fc158d829" translate="yes" xml:space="preserve">
          <source>When an error occurs during a transaction (including an inner transaction failing), reading from the data stream is suspended (all subsequent read operations return empty/zero values) and subsequent inner transactions are forced to fail. Starting a new outermost transaction recovers from this state. This behavior makes it unnecessary to error-check every read operation separately.</source>
          <target state="translated">트랜잭션 (내부 트랜잭션 실패 포함) 중에 오류가 발생하면 데이터 스트림으로부터의 읽기가 일시 중지되고 (모든 후속 읽기 작업이 비어 있거나 0을 반환 함) 후속 내부 트랜잭션이 강제로 실패합니다. 새로운 최 외곽 트랜잭션을 시작하면이 상태에서 복구됩니다. 이 동작으로 인해 모든 읽기 작업을 개별적으로 오류 점검 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d4d4dd6c5a276f9a88210865c11ad3239fc05498" translate="yes" xml:space="preserve">
          <source>When an escape button can't be determined using these rules, pressing &lt;b&gt;Esc&lt;/b&gt; has no effect.</source>
          <target state="translated">이 규칙을 사용하여 이스케이프 버튼을 확인할 수없는 경우 &lt;b&gt;Esc를&lt;/b&gt; 누릅니다.&lt;b&gt;&lt;/b&gt; 를 아무 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="88e91d6c3ac2f70e9dc327611729bb3fc23462f4" translate="yes" xml:space="preserve">
          <source>When an escape button could not be automatically detected, pressing &lt;b&gt;Esc&lt;/b&gt; has no effect.</source>
          <target state="translated">이스케이프 버튼을 자동으로 감지 할 수 없으면 &lt;b&gt;Esc를&lt;/b&gt; 누릅니다.&lt;b&gt;&lt;/b&gt; 를 아무런 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="60deb4d5ec6470a1989d6f1aae50fd37df3fb27a" translate="yes" xml:space="preserve">
          <source>When an event notification identified by</source>
          <target state="translated">이벤트 알림이</target>
        </trans-unit>
        <trans-unit id="cc1c8c604562d809abc5eea2fc6d1c3875525ea6" translate="yes" xml:space="preserve">
          <source>When an event occurs, Qt creates an event object to represent it by constructing an instance of the appropriate &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; subclass, and delivers it to a particular instance of &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; (or one of its subclasses) by calling its &lt;a href=&quot;qobject#event&quot;&gt;event()&lt;/a&gt; function.</source>
          <target state="translated">이벤트가 발생하면 Qt는 적절한 &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; 서브 클래스 의 인스턴스를 생성하여 이벤트 객체를 생성하고 이벤트 ()를 호출하여 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 의 특정 인스턴스 (또는 서브 클래스 중 하나 &lt;a href=&quot;qobject#event&quot;&gt;)에 전달합니다.&lt;/a&gt; 함수를 합니다.</target>
        </trans-unit>
        <trans-unit id="de6f46d25c54bf3f5ae53599544aff515fdc8c6f" translate="yes" xml:space="preserve">
          <source>When an extension is requested,</source>
          <target state="translated">확장이 요청되면</target>
        </trans-unit>
        <trans-unit id="82176d3ebc0806a90e56a238f12634352670b5cd" translate="yes" xml:space="preserve">
          <source>When an extension is required,</source>
          <target state="translated">확장이 필요한 경우</target>
        </trans-unit>
        <trans-unit id="e58900421752248eb5fa9c7e1a8662c806ac6e45" translate="yes" xml:space="preserve">
          <source>When an item becomes the child of another item:</source>
          <target state="translated">항목이 다른 항목의 자식이되는 경우 :</target>
        </trans-unit>
        <trans-unit id="6de19d2590d4fe0fe6e06630c40b5632e67df7b0" translate="yes" xml:space="preserve">
          <source>When an item gains the keyboard grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::GrabKeyboard&lt;/a&gt; event. When it loses the keyboard grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::UngrabKeyboard&lt;/a&gt; event. These events can be used to detect when your item gains or loses the keyboard grab through other means than gaining input focus.</source>
          <target state="translated">항목이 키보드 잡기를 &lt;a href=&quot;qevent#Type-enum&quot;&gt;얻으면 QEvent :: GrabKeyboard&lt;/a&gt; 이벤트가 수신 됩니다. 키보드 잡기를 잃으면 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: UngrabKeyboard를받습니다.&lt;/a&gt; 이벤트를 . 이 이벤트는 항목이 입력 포커스를 얻는 것 이외의 다른 방법을 통해 키보드를 잡거나 잃을 때를 감지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64c535dc14ed7e2aa62d21df9de2e71bdefba665" translate="yes" xml:space="preserve">
          <source>When an item gains the mouse grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::GrabMouse&lt;/a&gt; event. When it loses the mouse grab, it receives a &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent::UngrabMouse&lt;/a&gt; event. These events can be used to detect when your item gains or loses the mouse grab through other means than receiving mouse button events.</source>
          <target state="translated">항목이 마우스를 가져 &lt;a href=&quot;qevent#Type-enum&quot;&gt;오면 QEvent :: GrabMouse&lt;/a&gt; 이벤트를 받습니다 . 마우스 잡기를 잃으면 &lt;a href=&quot;qevent#Type-enum&quot;&gt;QEvent :: UngrabMouse&lt;/a&gt; 이벤트를 받습니다 . 이 이벤트는 항목이 마우스 버튼 이벤트를받는 것 이외의 다른 수단을 통해 마우스를 가져 오거나 잃는시기를 감지하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f8dc2c7ef923f949343da800eb159af2c1dde1c" translate="yes" xml:space="preserve">
          <source>When an item in an item view is selected, also highlight the branch or other decoration.</source>
          <target state="translated">항목보기에서 항목을 선택하면 분기 또는 다른 장식도 강조 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fcc2ea9c9f7cae3dd849abe3ca69b4158eef37eb" translate="yes" xml:space="preserve">
          <source>When an item is disabled, it is not possible to trigger it through its &lt;a href=&quot;qml-qt-labs-platform-menuitem#shortcut-prop&quot;&gt;shortcut&lt;/a&gt;.</source>
          <target state="translated">항목이 비활성화되면 &lt;a href=&quot;qml-qt-labs-platform-menuitem#shortcut-prop&quot;&gt;바로 가기를&lt;/a&gt; 통해 트리거 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="452a0cf012b3cb9c186457a25f7cb1b1b7718e16" translate="yes" xml:space="preserve">
          <source>When an item is editable (and enabled), the user can edit the item by invoking one of the view's edit triggers; see &lt;a href=&quot;qabstractitemview#editTriggers-prop&quot;&gt;QAbstractItemView::editTriggers&lt;/a&gt;.</source>
          <target state="translated">항목을 편집 할 수 있고 활성화 한 경우 사용자는보기의 편집 트리거 중 하나를 호출하여 항목을 편집 할 수 있습니다. &lt;a href=&quot;qabstractitemview#editTriggers-prop&quot;&gt;QAbstractItemView :: editTriggers를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53f7062365ff27f397c1a00527a4d2f3130aae95" translate="yes" xml:space="preserve">
          <source>When an item is enabled, the user can interact with it. The possible types of interaction are specified by the other item flags, such as &lt;a href=&quot;qstandarditem#isEditable&quot;&gt;isEditable&lt;/a&gt;() and &lt;a href=&quot;qstandarditem#isSelectable&quot;&gt;isSelectable&lt;/a&gt;().</source>
          <target state="translated">항목이 활성화되면 사용자는 해당 항목과 상호 작용할 수 있습니다. 가능한 상호 작용 유형은 &lt;a href=&quot;qstandarditem#isEditable&quot;&gt;isEditable&lt;/a&gt; () 및 &lt;a href=&quot;qstandarditem#isSelectable&quot;&gt;isSelectable&lt;/a&gt; () 과 같은 다른 항목 플래그로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc78ed51b3f4dd69fbf5c809ac07b2202ac93036" translate="yes" xml:space="preserve">
          <source>When an item is flicked out, it moves to the</source>
          <target state="translated">항목을 쓸어 내면</target>
        </trans-unit>
        <trans-unit id="edf649890497fe5584e977a2ddf9e845a6d9adbb" translate="yes" xml:space="preserve">
          <source>When an item's layer is enabled, the scene graph will allocate memory in the GPU equal to &lt;code&gt;width x height x 4&lt;/code&gt;. In memory constrained configurations, large layers should be used with care.</source>
          <target state="translated">아이템의 레이어가 활성화되면 장면 그래프는 &lt;code&gt;width x height x 4&lt;/code&gt; 같은 GPU의 메모리를 할당합니다 . 메모리 제한 구성에서는 큰 계층을주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="01223f794ced4ae7d5d61d347c9ab920ed50ad46" translate="yes" xml:space="preserve">
          <source>When an object is deleted, it emits a &lt;a href=&quot;qobject#destroyed&quot;&gt;destroyed&lt;/a&gt;() signal. You can catch this signal to avoid dangling references to QObjects.</source>
          <target state="translated">객체가 삭제되면 &lt;a href=&quot;qobject#destroyed&quot;&gt;파괴됩니다.&lt;/a&gt; () 신호가 발생합니다. QObject에 대한 참조가 매달려 있지 않도록이 신호를 포착 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5486876fa77fcc351c0468b0f817e3d9df8a75d" translate="yes" xml:space="preserve">
          <source>When and whether you actually</source>
          <target state="translated">언제 그리고 실제로</target>
        </trans-unit>
        <trans-unit id="9d01348a9aece3a4b6e828d26241b1bbac417b30" translate="yes" xml:space="preserve">
          <source>When animations are used to assign properties, a state no longer defines the exact values that a property will have when the machine is in the given state. While the animation is running, the property can potentially have any value, depending on the animation.</source>
          <target state="translated">애니메이션을 사용하여 속성을 할당 할 때 상태는 더 이상 기계가 지정된 상태에있을 때 속성의 정확한 값을 정의하지 않습니다. 애니메이션이 실행되는 동안 속성은 애니메이션에 따라 임의의 값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2fc21797749a0f52070944bd489489ff6abab01" translate="yes" xml:space="preserve">
          <source>When any item is added, moved or removed within the above view, the items below it are displaced, causing them to move down (or sideways, if horizontally orientated) within the view. As this displacement occurs, the items' movement to their new x,y positions within the view will be animated by a &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; over one second, as specified.</source>
          <target state="translated">위의보기에서 항목을 추가, 이동 또는 제거하면 그 아래 항목이 이동하여보기 내에서 아래로 (또는 가로 방향 인 경우 옆으로) 이동합니다. 이 변위가 발생하면 뷰 내에서 새로운 x, y 위치로의 항목 이동 은 지정된대로 1 초 동안 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; 에 의해 애니메이션됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ad254e9576e1f6e7ddb5f7d88c66a573a0635ac" translate="yes" xml:space="preserve">
          <source>When any of the states is entered, the label's text will be changed accordingly.</source>
          <target state="translated">상태를 입력하면 레이블의 텍스트가 그에 따라 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="92871574343d3169789071570bca986c9cf96ef4" translate="yes" xml:space="preserve">
          <source>When any of these are needed, the Connections type can be used instead.</source>
          <target state="translated">이들 중 하나가 필요한 경우 연결 유형을 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="217cf31f7ecab879e6aeaf0c5c92b52eaff625db" translate="yes" xml:space="preserve">
          <source>When any visible part of the scene changes or is reexposed, &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will update the entire viewport. This approach is fastest when &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; spends more time figuring out what to draw than it would spend drawing (e.g., when very many small items are repeatedly updated). This is the preferred update mode for viewports that do not support partial updates, such as QGLWidget, and for viewports that need to disable scroll optimization.</source>
          <target state="translated">장면의 보이는 부분이 변경되거나 다시 노출되면 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 가 전체 뷰포트를 업데이트합니다. 이 방법은 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 가 그림을 그리는 것보다 무엇을 그리는지 알아내는 데 더 많은 시간을 소비 할 때 가장 빠릅니다 (예 : 매우 많은 작은 항목이 반복적으로 업데이트되는 경우). 이는 QGLWidget과 같은 부분 업데이트를 지원하지 않는 뷰포트 및 스크롤 최적화를 비활성화해야하는 뷰포트의 기본 업데이트 모드입니다.</target>
        </trans-unit>
        <trans-unit id="a06bc6d7390ca623b0217a85f5d3800a53cff310" translate="yes" xml:space="preserve">
          <source>When applying &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-effects-topic.html#opacity&quot;&gt;opacity&lt;/a&gt; to an item hierarchy the opacity is applied to each item individually. This can lead to undesired visual results when the opacity is applied to a subtree. Consider the following example:</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-effects-topic.html#opacity&quot;&gt;불투명도를&lt;/a&gt; 적용 할 때 항목 계층 불투명도가 각 항목을 개별적으로 적용된다. 이로 인해 불투명도가 하위 트리에 적용될 때 원하지 않는 시각적 결과가 발생할 수 있습니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="03f4da2f8d439defdd9e3b555f171b3b3c94fa9c" translate="yes" xml:space="preserve">
          <source>When applying a clip to a subtree, that subtree needs to be rendered with a unique OpenGL state. This means that when &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item::clip&lt;/a&gt; is true, batching of that item is limited to its children. When there are many children, like a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt;, or complex children, like a &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt;, this is fine. One should, however, use clip on smaller items with caution as it prevents batching. This includes button label, text field or list delegate and table cells.</source>
          <target state="translated">서브 트리에 클립을 적용 할 때 해당 서브 트리는 고유 한 OpenGL 상태로 렌더링되어야합니다. 이는 &lt;a href=&quot;qml-qtquick-item#clip-prop&quot;&gt;Item :: clip&lt;/a&gt; 이 true 일 때 해당 항목의 배치가 하위 항목으로 제한됨을 의미합니다. &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-gridview&quot;&gt;GridView&lt;/a&gt; 와 같은 많은 자식 이나 &lt;a href=&quot;qml-qtquick-controls-textarea&quot;&gt;TextArea&lt;/a&gt; 와 같은 복잡한 자식 이 있으면 괜찮습니다. 그러나 작은 항목에 클립을 사용하면 배치가 방지되므로주의해서 사용해야합니다. 여기에는 버튼 레이블, 텍스트 필드 또는 목록 대리자 및 테이블 셀이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b46cb236869034e639f5c98ef59e6e0dc79b743e" translate="yes" xml:space="preserve">
          <source>When assigning values to properties in QML, any layouting the item must do as a result of the assignment might not take effect immediately, but can instead be postponed until the item is polished. For these cases, you can use this function to ensure that the item has been polished before the execution of the test continues. For example:</source>
          <target state="translated">QML에서 속성에 값을 할당 할 때 할당 결과로 아이템을 배치해야하는 레이아웃은 즉시 적용되지 않을 수 있지만 대신 아이템이 다듬어 질 때까지 연기 될 수 있습니다. 이 경우이 기능을 사용하여 테스트 실행이 계속되기 전에 항목이 연마되었는지 확인할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9aade8d1fb980c82f7d60913e871590165c272dc" translate="yes" xml:space="preserve">
          <source>When asynchronous is true the Instantiator will attempt to create objects asynchronously. This means that objects may not be available immediately, even if active is set to true.</source>
          <target state="translated">비동기가 참이면 Instantiator는 객체를 비동기 적으로 만들려고 시도합니다. 즉, active가 true로 설정되어 있어도 개체를 즉시 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ed095d8711f54124e3343d3e3564a7eefda4e48d" translate="yes" xml:space="preserve">
          <source>When atEnd() and &lt;a href=&quot;qxmlstreamreader#hasError&quot;&gt;hasError&lt;/a&gt;() return true and &lt;a href=&quot;qxmlstreamreader#error&quot;&gt;error&lt;/a&gt;() returns &lt;a href=&quot;qxmlstreamreader#Error-enum&quot;&gt;PrematureEndOfDocumentError&lt;/a&gt;, it means the XML has been well-formed so far, but a complete XML document has not been parsed. The next chunk of XML can be added with &lt;a href=&quot;qxmlstreamreader#addData&quot;&gt;addData&lt;/a&gt;(), if the XML is being read from a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, or by waiting for more data to arrive if the XML is being read from a &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;. Either way, atEnd() will return false once more data is available.</source>
          <target state="translated">atEnd () 및 &lt;a href=&quot;qxmlstreamreader#hasError&quot;&gt;hasError&lt;/a&gt; ()가 true를 리턴하고 &lt;a href=&quot;qxmlstreamreader#error&quot;&gt;error&lt;/a&gt; ()가 &lt;a href=&quot;qxmlstreamreader#Error-enum&quot;&gt;PrematureEndOfDocumentError를&lt;/a&gt; 리턴 하면, XML이 지금까지 제대로 구성되었지만 완전한 XML 문서가 구문 분석되지 않았 음을 의미합니다. XML의 다음 청크로 추가 할 수 &lt;a href=&quot;qxmlstreamreader#addData&quot;&gt;는, addData&lt;/a&gt; 는 XML이에서 읽을 경우, () &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; , 또는 XML이 읽을되는 경우 더 많은 데이터가 도착하기를 기다리고에 의해 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; . 어느 쪽이든 더 많은 데이터를 사용할 수있게되면 atEnd ()는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="769b89390fbaab8a30caa729005e13bd89dd70b2" translate="yes" xml:space="preserve">
          <source>When both the &lt;a href=&quot;qml-qtpurchasing-product#identifier-prop&quot;&gt;identifier&lt;/a&gt; and type is set, the product is queried from the external market place, and its other properties are updated asynchronously. At this point, the identifier and type can no longer be changed.</source>
          <target state="translated">&lt;a href=&quot;qml-qtpurchasing-product#identifier-prop&quot;&gt;식별자&lt;/a&gt; 와 유형이 모두 설정되면 외부 마켓 플레이스에서 제품이 쿼리되고 다른 속성이 비동기 적으로 업데이트됩니다. 이 시점에서 식별자와 유형을 더 이상 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e66ead871376ec31f6b0bdabc0d22f6168fd30da" translate="yes" xml:space="preserve">
          <source>When both the identifier and &lt;a href=&quot;qml-qtpurchasing-product#type-prop&quot;&gt;type&lt;/a&gt; is set, the product is queried from the external market place, and its other properties are updated asynchronously. At this point, the identifier and type can no longer be changed.</source>
          <target state="translated">식별자와 &lt;a href=&quot;qml-qtpurchasing-product#type-prop&quot;&gt;유형&lt;/a&gt; 이 모두 이 설정되면 외부 시장에서 제품이 쿼리되고 다른 속성이 비동기 적으로 업데이트됩니다. 이 시점에서 식별자와 유형을 더 이상 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a77db60a6597f85a3430717a9225f81f9e8efd43" translate="yes" xml:space="preserve">
          <source>When building Qt from source, the configuration system checks for the presence of the &lt;code&gt;openssl/opensslv.h&lt;/code&gt; header provided by source or developer packages of OpenSSL.</source>
          <target state="translated">소스에서 Qt를 빌드 할 때 구성 시스템 은 OpenSSL의 소스 또는 개발자 패키지에서 제공 하는 &lt;code&gt;openssl/opensslv.h&lt;/code&gt; 헤더가 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="481f920a35be00bb71b2fc213b17ba321c9ce91c" translate="yes" xml:space="preserve">
          <source>When building a list or a tree that has only one column, this function provides a convenient way to append a single new</source>
          <target state="translated">하나의 열만있는 목록 또는 트리를 작성할 때이 함수는 하나의 새 항목을 추가하는 편리한 방법을 제공합니다</target>
        </trans-unit>
        <trans-unit id="f4d252c2c2fbed789c886d3ea6d5aac266ab2c26" translate="yes" xml:space="preserve">
          <source>When building a list or a tree that has only one column, this function provides a convenient way to append a single new item.</source>
          <target state="translated">하나의 열만있는 목록 또는 트리를 작성할 때이 기능을 사용하면 하나의 새 항목을 편리하게 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2ec3d7c6f7c3543ad312c99f702307e4ac89f3b" translate="yes" xml:space="preserve">
          <source>When building a list or a tree that has only one column, this function provides a convenient way to insert a single new item.</source>
          <target state="translated">하나의 열만있는 목록 또는 트리를 작성할 때이 기능을 사용하면 하나의 새 항목을 편리하게 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c09737d74d2162e6fdbbf52bfd0b26549723d50" translate="yes" xml:space="preserve">
          <source>When building a version of Qt linked against OpenSSL, the build system will attempt to link with libssl and libcrypt libraries located in the default location on the developer's system. This location is configurable: set the &lt;code&gt;OPENSSL_LIBS&lt;/code&gt; environment variable to contain the linker options required to link Qt against the installed library. For example, on a Unix/Linux system:</source>
          <target state="translated">OpenSSL에 링크 된 Qt 버전을 빌드 할 때 빌드 시스템은 개발자 시스템의 기본 위치에있는 libssl 및 libcrypt 라이브러리와의 링크를 시도합니다. 이 위치는 구성 가능합니다. &lt;code&gt;OPENSSL_LIBS&lt;/code&gt; 환경 변수를 설정 하여 설치된 라이브러리와 Qt를 연결하는 데 필요한 링커 옵션을 포함하십시오. 예를 들어, 유닉스 / 리눅스 시스템에서 :</target>
        </trans-unit>
        <trans-unit id="62819592f1c6df3a87bed54e97d13fd158256db9" translate="yes" xml:space="preserve">
          <source>When building from source, ensure that the &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt Graphical Effects&lt;/a&gt; module is also built, as Qt Quick Controls 2 requires it.</source>
          <target state="translated">소스에서 빌드 할 때는 Qt Quick Controls 2에서 요구 하는 &lt;a href=&quot;qtgraphicaleffects-index&quot;&gt;Qt 그래픽 효과&lt;/a&gt; 모듈도 빌드해야합니다.</target>
        </trans-unit>
        <trans-unit id="7251f805a1544f17a9559e9785d85be1aae09528" translate="yes" xml:space="preserve">
          <source>When building user interfaces with the &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; module, all QML objects that are to be visually rendered must derive from the &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; type, as it is the base type for all visual objects in &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt;. This &lt;a href=&quot;qml-qtquick-item&quot;&gt;Item&lt;/a&gt; type is implemented by the &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; C++ class, which is provided by the &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; module. Therefore, this class should be subclassed when it is necessary to implement a visual type in C++ that can be integrated into a QML-based user interface.</source>
          <target state="translated">&lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; 모듈로 사용자 인터페이스를 구축 할 때 시각적으로 렌더링되는 모든 QML 객체는 &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick의&lt;/a&gt; 모든 시각적 객체에 대한 기본 유형이므로 &lt;a href=&quot;qml-qtquick-item&quot;&gt;항목&lt;/a&gt; 유형 에서 파생되어야합니다 . 이 &lt;a href=&quot;qml-qtquick-item&quot;&gt;항목&lt;/a&gt; 유형은 &lt;a href=&quot;qtquick-index&quot;&gt;Qt Quick&lt;/a&gt; 모듈 에서 제공 하는 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; C ++ 클래스에 의해 구현됩니다 . 따라서이 클래스는 QML 기반 사용자 인터페이스에 통합 될 수있는 C ++에서 비주얼 유형을 구현해야 할 때 서브 클래스 화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="573536b41f02e737bb17c87ec630c4949eebe25a" translate="yes" xml:space="preserve">
          <source>When built, the Qt Image Formats plugins are located as dynamic libraries in the runtime plugin directory (typically &lt;code&gt;plugins/imageformats&lt;/code&gt;), together with the default image format plugins. They may be deployed to the target system in the same way as other plugins, see the &lt;a href=&quot;https://doc.qt.io/qt-5.13/deployment-plugins.html&quot;&gt;Deploying Plugins&lt;/a&gt; documentation.</source>
          <target state="translated">빌드되면 Qt 이미지 형식 플러그인은 기본 이미지 형식 플러그인과 함께 런타임 플러그인 디렉토리 (일반적으로 &lt;code&gt;plugins/imageformats&lt;/code&gt; )에 동적 라이브러리로 위치 합니다. 다른 플러그인과 동일한 방식으로 대상 시스템에 배포 될 수 있습니다 . &lt;a href=&quot;https://doc.qt.io/qt-5.13/deployment-plugins.html&quot;&gt;플러그인 배포&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85c65eea35b46ad9adc8aa9df7e19d248494566d" translate="yes" xml:space="preserve">
          <source>When caching is enabled, &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; reads the file information from the file system the first time it's needed, but generally not later.</source>
          <target state="translated">캐싱이 활성화되면 &lt;a href=&quot;qfileinfo&quot;&gt;QFileInfo&lt;/a&gt; 는 파일 시스템에서 파일 정보를 처음 필요할 때 읽지 만 일반적으로 나중에 읽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63f929311e0c136280261b1674d609c45952f607" translate="yes" xml:space="preserve">
          <source>When caching is enabled, an item's &lt;a href=&quot;qgraphicsitem#paint&quot;&gt;paint&lt;/a&gt;() function will generally draw into an offscreen pixmap cache; for any subsequent repaint requests, the Graphics View framework will redraw from the cache. This approach works particularly well with QGLWidget, which stores all the cache as OpenGL textures.</source>
          <target state="translated">캐싱이 활성화되면 항목의 &lt;a href=&quot;qgraphicsitem#paint&quot;&gt;paint&lt;/a&gt; () 함수는 일반적으로 오프 스크린 픽스맵 캐시로 끌어들입니다. 이후의 다시 그리기 요청에 대해 기하 창 프레임 워크가 캐시에서 다시 그려집니다. 이 접근 방식은 모든 캐시를 OpenGL 텍스처로 저장하는 QGLWidget과 특히 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="49d3402980e692757da4d25c7f056cfbcbc4090c" translate="yes" xml:space="preserve">
          <source>When calculating the size hint, &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; fetches three pixel metrics from the style: &lt;code&gt;PM_IndicatorWidth&lt;/code&gt;, &lt;code&gt;PM_CheckBoxLabelSpacing&lt;/code&gt;, and &lt;code&gt;PM_IndicatorHeight&lt;/code&gt;. &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; has the following style element tree:</source>
          <target state="translated">크기 힌트를 계산할 때, &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox가&lt;/a&gt; : 스타일에서 세 개의 픽셀의 메트릭 가져 &lt;code&gt;PM_IndicatorWidth&lt;/code&gt; , &lt;code&gt;PM_CheckBoxLabelSpacing&lt;/code&gt; 및 &lt;code&gt;PM_IndicatorHeight&lt;/code&gt; 을 . &lt;a href=&quot;qgroupbox&quot;&gt;QGroupBox&lt;/a&gt; 에는 다음과 같은 스타일 요소 트리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="21b955b352a198452eb600dee09c98ed26feb22d" translate="yes" xml:space="preserve">
          <source>When calculating the slider's size hint, &lt;code&gt;PM_SliderThickness&lt;/code&gt; and &lt;code&gt;PM_SliderLength&lt;/code&gt; are queried from the style. As with scroll bars, the &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; only lets the user move the handle if the mouse is within &lt;code&gt;PM_MaximumDragDistance&lt;/code&gt; from the slider bounds. When it draws itself, it creates the style option and calls &lt;code&gt;drawComplexControl()&lt;/code&gt; with &lt;code&gt;CC_Slider&lt;/code&gt;:</source>
          <target state="translated">슬라이더의 크기 힌트를 계산할 때 스타일에서 &lt;code&gt;PM_SliderThickness&lt;/code&gt; 및 &lt;code&gt;PM_SliderLength&lt;/code&gt; 가 쿼리됩니다. 스크롤 막대와 마찬가지로 &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; 는 마우스가 슬라이더 경계 에서 &lt;code&gt;PM_MaximumDragDistance&lt;/code&gt; 내에있는 경우에만 사용자가 핸들을 이동할 수 있도록 합니다. 스스로 그릴 때 스타일 옵션을 만들고 &lt;code&gt;drawComplexControl()&lt;/code&gt; 하여 &lt;code&gt;CC_Slider&lt;/code&gt; () 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1d40ba7fa0fde8f8ba84bf5f3be3928589a792a0" translate="yes" xml:space="preserve">
          <source>When called as a constructor, a new instance of the class will be created. Only constructors exposed by &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; will be visible from the script engine.</source>
          <target state="translated">생성자로 호출되면 클래스의 새 인스턴스가 생성됩니다. &lt;a href=&quot;qobject#Q_INVOKABLE&quot;&gt;Q_INVOKABLE&lt;/a&gt; 에 의해 노출 된 생성자 만 스크립트 엔진에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a17521f28b13cf15c64f48b6b71bf71a004d243" translate="yes" xml:space="preserve">
          <source>When called by Qt,</source>
          <target state="translated">Qt에 의해 호출되면</target>
        </trans-unit>
        <trans-unit id="914ad22810e57e0a208c0b39ab77807e77834ddd" translate="yes" xml:space="preserve">
          <source>When calling Java functions that might throw an exception, it is important that you check, handle and clear out the exception before continuing.</source>
          <target state="translated">예외가 발생할 수있는 Java 함수를 호출 할 때는 계속하기 전에 예외를 확인, 처리 및 지우는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="2a2e7ae65f87e90c76479fdc5ff2e4326b27c302" translate="yes" xml:space="preserve">
          <source>When calling this function, you can use the &lt;code&gt;SIGNAL()&lt;/code&gt; macro to pass a specific signal:</source>
          <target state="translated">이 함수를 호출 할 때 &lt;code&gt;SIGNAL()&lt;/code&gt; 매크로를 사용하여 특정 신호를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16fd68ecc7c1ca2e0fddbce432b5a471d518bb57" translate="yes" xml:space="preserve">
          <source>When changing properties with values that may be defined within a resource file,</source>
          <target state="translated">리소스 파일 내에 정의 할 수있는 값으로 속성을 변경할 때</target>
        </trans-unit>
        <trans-unit id="10172d955b561d851a1e685787b7d1f3cc20d57f" translate="yes" xml:space="preserve">
          <source>When changing the geometry, the widget, if visible, receives a move event (&lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt;()) and/or a resize event (&lt;a href=&quot;qwidget#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt;()) immediately. If the widget is not currently visible, it is guaranteed to receive appropriate events before it is shown.</source>
          <target state="translated">지오메트리를 변경할 때 위젯은 표시되는 경우 이동 이벤트 ( &lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt; ()) 및 / 또는 크기 조정 이벤트 ( &lt;a href=&quot;qwidget#resizeEvent&quot;&gt;resizeEvent&lt;/a&gt; ())를 즉시받습니다. 위젯이 현재 표시되지 않으면 위젯이 표시되기 전에 적절한 이벤트를 수신하는 것이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="3dcc6167c4c8ec1a522615dcd2a97bfd046a2f80" translate="yes" xml:space="preserve">
          <source>When changing the position, the widget, if visible, receives a move event (&lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt;()) immediately. If the widget is not currently visible, it is guaranteed to receive an event before it is shown.</source>
          <target state="translated">위치를 변경할 때 위젯이 표시되면 즉시 이동 이벤트 ( &lt;a href=&quot;qwidget#moveEvent&quot;&gt;moveEvent&lt;/a&gt; ())를받습니다. 위젯이 현재 표시되어 있지 않으면 표시되기 전에 이벤트를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d10e878de0de661440ee8d64ce4885521ddfa38a" translate="yes" xml:space="preserve">
          <source>When checking the signatures of its arguments, &lt;a href=&quot;qobject#connect&quot;&gt;QObject::connect&lt;/a&gt;() compares the data types literally. Thus, &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Alignment&lt;/a&gt; and &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt::Alignment&lt;/a&gt; are treated as two distinct types. To work around this limitation, make sure to fully qualify the data types when declaring signals and slots, and when establishing connections. For example:</source>
          <target state="translated">인수의 서명을 확인할 때 &lt;a href=&quot;qobject#connect&quot;&gt;QObject :: connect&lt;/a&gt; ()는 데이터 유형을 문자 그대로 비교합니다. 따라서 &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Alignment&lt;/a&gt; 및 &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt :: Alignment&lt;/a&gt; 는 두 가지 유형으로 처리됩니다. 이 제한 사항을 해결하려면 신호 및 슬롯을 선언 할 때와 연결을 설정할 때 데이터 유형을 완전히 규정하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c76cad238f22ed5e500ffc1b09ea0553c302ab3" translate="yes" xml:space="preserve">
          <source>When choosing a widget to use as a placeholder, it is useful to compare the API of the missing widget with those of standard Qt widgets. For specialized widgets that subclass standard classes, the obvious choice of placeholder is the base class of the custom widget; for example, &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; might be used for specialized &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; subclasses.</source>
          <target state="translated">자리 표시 자로 사용할 위젯을 선택할 때 누락 된 위젯의 API를 표준 Qt 위젯의 API와 비교하는 것이 유용합니다. 표준 클래스를 서브 클래스로 분류하는 특수 위젯의 경우 자리 표시 자 선택은 사용자 정의 위젯의 기본 클래스입니다. 예를 들어, &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; 는 특수 &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; 서브 클래스에 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16d44be4536ee05b1e19ae36cfa871d577dd74c9" translate="yes" xml:space="preserve">
          <source>When client code handling the &lt;a href=&quot;qnetworkreply#redirected&quot;&gt;redirected&lt;/a&gt;() signal has verified the new URL, it emits this signal to allow the redirect to go ahead. This protocol applies to network requests whose redirects policy is set to &lt;a href=&quot;qnetworkrequest#RedirectPolicy-enum&quot;&gt;QNetworkRequest::UserVerifiedRedirectPolicy&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;qnetworkreply#redirected&quot;&gt;리디렉션 된&lt;/a&gt; () 신호를 처리하는 클라이언트 코드 가 새 URL을 확인하면이 신호를 내보내 리디렉션을 진행할 수 있습니다. 이 프로토콜은 리디렉션 정책이 &lt;a href=&quot;qnetworkrequest#RedirectPolicy-enum&quot;&gt;QNetworkRequest :: UserVerifiedRedirectPolicy로&lt;/a&gt; 설정된 네트워크 요청에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a496bd66ef281f3e102e4c15780975eb23b209d8" translate="yes" xml:space="preserve">
          <source>When combined with Subdirectories, this flag enables iterating through all subdirectories of the assigned path, following all symbolic links. Symbolic link loops (e.g., &quot;link&quot; =&amp;gt; &quot;.&quot; or &quot;link&quot; =&amp;gt; &quot;..&quot;) are automatically detected and ignored.</source>
          <target state="translated">서브 디렉토리와 결합 될 때이 플래그를 사용하면 모든 기호 링크를 따라 지정된 경로의 모든 서브 디렉토리를 반복 할 수 있습니다. 심볼릭 링크 루프 (예 : &quot;link&quot;=&amp;gt; &quot;.&quot;또는 &quot;link&quot;=&amp;gt; &quot;..&quot;)는 자동으로 감지되어 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b152fe7b18bfb7ca1bd752cf950491f1cf2f642f" translate="yes" xml:space="preserve">
          <source>When communicating over a bus, applications obtain what is called a &quot;service name&quot;: it is how that application chooses to be known by other applications on the same bus. The service names are brokered by the D-Bus bus daemon and are used to route messages from one application to another. An analogous concept to service names are IP addresses and hostnames: a computer normally has one IP address and may have one or more hostnames associated with it, according to the services that it provides to the network.</source>
          <target state="translated">버스를 통해 통신 할 때 응용 프로그램은 &quot;서비스 이름&quot;이라는 것을 얻습니다. 동일한 버스의 다른 응용 프로그램이 해당 응용 프로그램을 알도록 선택하는 방법입니다. 서비스 이름은 D-Bus 버스 데몬에 의해 중개되며 한 응용 프로그램에서 다른 응용 프로그램으로 메시지를 라우팅하는 데 사용됩니다. 서비스 이름과 유사한 개념은 IP 주소 및 호스트 이름입니다. 컴퓨터에는 일반적으로 하나의 IP 주소가 있으며 네트워크에 제공하는 서비스에 따라 하나 이상의 IP 주소가 연결될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ae6fe5944e7f5e553d8111bc79c5d3e6ba7dace" translate="yes" xml:space="preserve">
          <source>When complete is &lt;code&gt;true&lt;/code&gt;, any interactive items declared in &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;right&lt;/code&gt;, or &lt;code&gt;behind&lt;/code&gt; will receive mouse events.</source>
          <target state="translated">complete가 &lt;code&gt;true&lt;/code&gt; 인 경우 , &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;right&lt;/code&gt; 또는 &lt;code&gt;behind&lt;/code&gt; 선언 된 모든 대화 형 항목은 마우스 이벤트를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="1731f47b651e66fd70df77e065cbada56a586326" translate="yes" xml:space="preserve">
          <source>When conflicts arise, the widget's own style sheet is always preferred to any inherited style sheet, irrespective of the specificity of the conflicting rules. Likewise, the parent widget's style sheet is preferred to the grandparent's, etc.</source>
          <target state="translated">충돌이 발생하면 충돌 규칙의 특수성에 관계없이 위젯 자체 스타일 시트가 상속 된 스타일 시트보다 항상 선호됩니다. 마찬가지로 부모 위젯의 스타일 시트는 조부모 등이 선호합니다.</target>
        </trans-unit>
        <trans-unit id="0ee6235e959f1c122804e1ee8f220bac499a0e14" translate="yes" xml:space="preserve">
          <source>When connecting to an ODBC datasource, you should pass the name of the ODBC datasource to the &lt;a href=&quot;qsqldatabase#setDatabaseName&quot;&gt;QSqlDatabase::setDatabaseName&lt;/a&gt;() function, rather than the actual database name.</source>
          <target state="translated">ODBC 데이터 소스에 연결할 때 실제 데이터베이스 이름이 아닌 ODBC 데이터 소스의 이름을 &lt;a href=&quot;qsqldatabase#setDatabaseName&quot;&gt;QSqlDatabase :: setDatabaseName&lt;/a&gt; () 함수에 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2f2cbe1c8aedff9ebebfb5ee6584df1a788d8183" translate="yes" xml:space="preserve">
          <source>When connecting to signals in QML, the usual way is to create an &quot;on&amp;lt;Signal&amp;gt;&quot; handler that reacts when a signal is received, like this:</source>
          <target state="translated">QML에서 신호에 연결할 때 일반적인 방법은 다음과 같이 신호가 수신 될 때 반응하는 &quot;on &amp;lt;Signal&amp;gt;&quot;핸들러를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="50ad6900d430167293c28de8c15b55b92afdb96d" translate="yes" xml:space="preserve">
          <source>When considering the above example, there are several parties involved:</source>
          <target state="translated">위의 예를 고려할 때 관련된 여러 당사자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="490cc9bd30b6bceb26457d2a8efbb90a6b3f5fe5" translate="yes" xml:space="preserve">
          <source>When control returns to the main event loop, all events that are stored in the queue will be sent using the &lt;a href=&quot;qcoreapplication#notify&quot;&gt;notify&lt;/a&gt;() function.</source>
          <target state="translated">제어가 기본 이벤트 루프로 리턴되면 대기 행렬에 저장된 모든 이벤트는 &lt;a href=&quot;qcoreapplication#notify&quot;&gt;notify&lt;/a&gt; () 기능을 사용하여 전송 됩니다.</target>
        </trans-unit>
        <trans-unit id="0aae57f52813e54337f9b3ba12b5d957d0e7706b" translate="yes" xml:space="preserve">
          <source>When creating a &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; using a custom &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; you can choose if you want &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; to try match the size to a standard page size. By default QPaperSize uses a &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; mode where it will match a given page size to a standard page size if it falls within 3 postscript points of a defined standard size. You can override this to request only an exact match but this is not recommended as conversions between units can easily lose 3 points and result in incorrect page sizes.</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; 를 사용하여 &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; 를 생성 할 때 QPageSize 가 표준 페이지 크기와 크기를 일치 &lt;a href=&quot;qpagesize&quot;&gt;시키&lt;/a&gt; 도록 선택할 수 있습니다 . 기본적으로 QPaperSize는 지정된 페이지 크기가 정의 된 표준 크기의 3 개의 포스트 스크립트 포인트 내에있는 경우 지정된 페이지 크기를 표준 페이지 크기와 일치 시키는 &lt;a href=&quot;qpagesize#SizeMatchPolicy-enum&quot;&gt;FuzzyMatch&lt;/a&gt; 모드를 사용합니다 . 이 옵션을 재정의하면 정확히 일치하는 항목 만 요청할 수 있지만 단위 간 변환시 쉽게 3 점을 잃고 페이지 크기가 잘못 될 수 있으므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ac98a689f6faf1b4d4a231d05990beaabb87945" translate="yes" xml:space="preserve">
          <source>When creating a &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; object, you must pass the name of your company or organization as well as the name of your application. For example, if your product is called Star Runner and your company is called MySoft, you would construct the &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; object as follows:</source>
          <target state="translated">&lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 객체를 생성 할 때는 회사 또는 조직의 이름과 응용 프로그램의 이름을 전달해야합니다. 예를 들어, 제품 이름이 Star Runner이고 회사 이름이 MySoft 인 경우 다음과 같이 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 객체를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="acdb8c3cb9399aef996527a1d8f6a87298ec82bb" translate="yes" xml:space="preserve">
          <source>When creating a &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; to contain a URL from a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; or a char*, always use &lt;a href=&quot;qstring#fromUtf8&quot;&gt;QString::fromUtf8&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 또는 char * 의 URL을 포함 하도록 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 을 작성할 때는 항상 &lt;a href=&quot;qstring#fromUtf8&quot;&gt;QString :: fromUtf8&lt;/a&gt; ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5d773d0579d473100a4c07b005ea00f7960a8020" translate="yes" xml:space="preserve">
          <source>When creating a custom help viewer the viewer can be configured by writing a custom collection file which could contain various keywords to be used to configure the help engine. These keywords and values and their meaning can be found in the help information for &lt;a href=&quot;https://doc.qt.io/qt-5.13/assistant-custom-help-viewer.html&quot;&gt;creating a custom help collection file&lt;/a&gt; for Assistant.</source>
          <target state="translated">사용자 정의 도움말 뷰어를 작성할 때 도움말 엔진을 구성하는 데 사용할 다양한 키워드를 포함 할 수있는 사용자 정의 콜렉션 파일을 작성하여 뷰어를 구성 할 수 있습니다. 이러한 키워드와 값 및 의미는 Assistant &lt;a href=&quot;https://doc.qt.io/qt-5.13/assistant-custom-help-viewer.html&quot;&gt;의 사용자 정의 도움말 콜렉션 파일 작성을&lt;/a&gt; 위한 도움말 정보에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65bcfdb381290d9bee6e16ff1d2353f984f24d0f" translate="yes" xml:space="preserve">
          <source>When creating a custom item, item coordinates are all you need to worry about; &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; and &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; will perform all transformations for you. This makes it very easy to implement custom items. For example, if you receive a mouse press or a drag enter event, the event position is given in item coordinates. The &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;QGraphicsItem::contains&lt;/a&gt;() virtual function, which returns &lt;code&gt;true&lt;/code&gt; if a certain point is inside your item, and false otherwise, takes a point argument in item coordinates. Similarly, an item's bounding rect and shape are in item coordinates.</source>
          <target state="translated">커스텀 아이템을 생성 할 때, 아이템 좌표 만 걱정하면됩니다. &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 및 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 가 모든 변환을 수행합니다. 따라서 사용자 정의 항목을 매우 쉽게 구현할 수 있습니다. 예를 들어, 마우스 누르기 또는 드래그 입력 이벤트가 수신되면 이벤트 위치가 항목 좌표로 제공됩니다. &lt;a href=&quot;qgraphicsitem#contains&quot;&gt;QGraphicsItem :: 포함&lt;/a&gt; () 가상 반환 기능, &lt;code&gt;true&lt;/code&gt; 특정 지점이 당신의 품목 내부에있는 경우와 그렇지 않은 경우는 false 항목의 좌표로 포인트 인수를합니다. 마찬가지로 항목의 경계 사각형과 모양은 항목 좌표에 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e08552b85a95188c1665a4dafe6b362ee82355f" translate="yes" xml:space="preserve">
          <source>When creating a map from sorted data inserting the largest key first with &lt;a href=&quot;qmap#constBegin&quot;&gt;constBegin&lt;/a&gt;() is faster than inserting in sorted order with &lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt;(), since &lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt;() - 1 (which is needed to check if the hint is valid) needs &lt;a href=&quot;containers#logarithmic-time&quot;&gt;logarithmic time&lt;/a&gt;.</source>
          <target state="translated">먼저 가장 큰 키를 삽입 소트 데이터로부터지도를 작성할 때 &lt;a href=&quot;qmap#constBegin&quot;&gt;constBegin하면&lt;/a&gt; () 속도로 정렬 된 순서로 삽입보다 &lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt; 때문에, () &lt;a href=&quot;qmap#constEnd&quot;&gt;constEnd&lt;/a&gt; (힌트가 유효한지 확인하기 위해 필요한 1)의 요구 (-) &lt;a href=&quot;containers#logarithmic-time&quot;&gt;대수 시간&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da378fc2f1f498e22d7abb9c20072ff5f0d3d3c4" translate="yes" xml:space="preserve">
          <source>When creating a new model for an existing data structure, it is important to consider which type of model should be used to provide an interface onto the data. If the data structure can be represented as a list or table of items, you can subclass &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; or &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel&lt;/a&gt; since these classes provide suitable default implementations for many functions.</source>
          <target state="translated">기존 데이터 구조에 대한 새 모델을 작성할 때 데이터에 대한 인터페이스를 제공하기 위해 사용해야하는 모델 유형을 고려해야합니다. 데이터 구조를 항목 목록 또는 테이블로 표시 할 수있는 경우, &lt;a href=&quot;qabstractlistmodel&quot;&gt;QAbstractListModel&lt;/a&gt; 또는 &lt;a href=&quot;qabstracttablemodel&quot;&gt;QAbstractTableModel을&lt;/a&gt; 서브 클래스로 작성할 수 있습니다. 이러한 클래스는 많은 함수에 적합한 기본 구현을 제공하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8500b569b9e4d2538da567830ca173bb7a100287" translate="yes" xml:space="preserve">
          <source>When creating a property binding from JavaScript, the &lt;code&gt;this&lt;/code&gt; keyword can be used to refer to the object which receives the binding. This is helpful for resolving ambiguities with property names.</source>
          <target state="translated">JavaScript에서 속성 바인딩을 만들 때 &lt;code&gt;this&lt;/code&gt; 키워드를 사용하여 바인딩을받는 객체를 참조 할 수 있습니다. 속성 이름으로 모호성을 해결하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="a4acef9238768bf956778e2a447e1184f2109294" translate="yes" xml:space="preserve">
          <source>When creating an &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; that targets several versions of a graphics API, it is useful to create several &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; nodes each with a &lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt; set to match one of the targeted GL versions. At runtime, the Qt3D renderer will select the most appropriate &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; based on which graphics API versions are supported and (if specified) the &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKey&lt;/a&gt; nodes that satisfy a given &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; in the FrameGraph.</source>
          <target state="translated">여러 버전의 그래픽 API를 대상으로 하는 &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; 를 작성할 때 대상 GL 버전 중 하나와 일치하도록 &lt;a href=&quot;qt3drender-qtechnique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter가&lt;/a&gt; 각각 설정된 여러 &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; 노드 를 작성하는 것이 유용 합니다 . 런타임시 Qt3D 렌더러 는 지원되는 그래픽 API 버전 및 &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;프레임 그래프&lt;/a&gt; 에서 지정된 QTechniqueFilter 를 만족하는 &lt;a href=&quot;qt3drender-qfilterkey&quot;&gt;QFilterKey&lt;/a&gt; 노드 (지정된 경우)에 따라 가장 적합한 &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique를&lt;/a&gt; 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="bd5a5c9f752ad47937d6434e44c62e97758c6944" translate="yes" xml:space="preserve">
          <source>When creating an Effect that targets several versions of a graphics API, it is useful to create several Technique nodes each with a &lt;a href=&quot;qml-qt3d-render-technique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter&lt;/a&gt; set to match one of the targeted versions. At runtime, the Qt3D renderer will select the most appropriate Technique based on which graphics API versions are supported and (if specified) the &lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKey&lt;/a&gt; nodes that satisfy a given &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt; in the FrameGraph.</source>
          <target state="translated">여러 버전의 그래픽 API를 대상으로하는 Effect를 만들 때 각각 대상 버전 중 하나와 일치하도록 &lt;a href=&quot;qml-qt3d-render-technique#graphicsApiFilter-prop&quot;&gt;graphicsApiFilter가&lt;/a&gt; 설정된 여러 Technique 노드를 만드는 것이 좋습니다. 런타임시 Qt3D 렌더러는 지원되는 그래픽 API 버전과 프레임 그래프 에서 지정된 &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt; 를 충족하는 &lt;a href=&quot;qml-qt3d-render-filterkey&quot;&gt;FilterKey&lt;/a&gt; 노드 (지정된 경우)를 기반으로 가장 적합한 기법을 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="f722c75ee9a2de387fc8f2d451fedcecaaa57d68" translate="yes" xml:space="preserve">
          <source>When creating custom items, use the new &lt;a href=&quot;qsgrectanglenode&quot;&gt;QSGRectangleNode&lt;/a&gt; and &lt;a href=&quot;qsgimagenode&quot;&gt;QSGImageNode&lt;/a&gt; classes. These replace the now deprecated QSGSimpleRectNode and QSGSimpleTextureNode. Unlike their predecessors, these new classes are interfaces, and implementations are created via the &lt;a href=&quot;qquickwindow#createRectangleNode&quot;&gt;QQuickWindow::createRectangleNode&lt;/a&gt;() and &lt;a href=&quot;qquickwindow#createImageNode&quot;&gt;QQuickWindow::createImageNode&lt;/a&gt;() factory functions.</source>
          <target state="translated">사용자 정의 항목을 작성할 때 새로운 &lt;a href=&quot;qsgrectanglenode&quot;&gt;QSGRectangleNode&lt;/a&gt; 및 &lt;a href=&quot;qsgimagenode&quot;&gt;QSGImageNode&lt;/a&gt; 클래스를 사용하십시오 . 이것은 더 이상 사용되지 않는 QSGSimpleRectNode 및 QSGSimpleTextureNode를 대체합니다. 이전 모델과 달리,이 새로운 클래스는 인터페이스이며 구현은 &lt;a href=&quot;qquickwindow#createRectangleNode&quot;&gt;QQuickWindow :: createRectangleNode&lt;/a&gt; () 및 &lt;a href=&quot;qquickwindow#createImageNode&quot;&gt;QQuickWindow :: createImageNode&lt;/a&gt; () 팩토리 함수 를 통해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad1ca55154d7a13bb0a82b3ada46b98f3f2fa71a" translate="yes" xml:space="preserve">
          <source>When creating textures via C++ scene graph APIs like &lt;a href=&quot;qquickwindow#createTextureFromImage&quot;&gt;QQuickWindow::createTextureFromImage&lt;/a&gt;(), 32-bit formats won't involve any conversion, they'll map directly to the corresponding &lt;code&gt;R8G8B8A8_UNORM&lt;/code&gt; or &lt;code&gt;B8G8R8A8_UNORM&lt;/code&gt; format. Everything else will trigger a &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;-based format conversion on the CPU first.</source>
          <target state="translated">&lt;a href=&quot;qquickwindow#createTextureFromImage&quot;&gt;QQuickWindow :: createTextureFromImage&lt;/a&gt; () 와 같은 C ++ 장면 그래프 API를 통해 텍스처를 만들 때 32 비트 형식은 변환이 필요하지 않으며 해당 &lt;code&gt;R8G8B8A8_UNORM&lt;/code&gt; 또는 &lt;code&gt;B8G8R8A8_UNORM&lt;/code&gt; 형식으로 직접 매핑 됩니다. 다른 모든 것은 먼저 CPU에서 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 기반 형식 변환을 트리거합니다 .</target>
        </trans-unit>
        <trans-unit id="ac8c6318f0656d7823865940204d8f34b4f9e2dc" translate="yes" xml:space="preserve">
          <source>When creating user interfaces with Qt, particularly those with specialized controls and features, developers sometimes need to create new data types that can be used alongside or in place of Qt's existing set of value types.</source>
          <target state="translated">Qt로 사용자 인터페이스, 특히 특수한 컨트롤과 기능이있는 사용자 인터페이스를 만들 때 개발자는 Qt의 기존 값 유형과 함께 또는 대신 사용할 수있는 새로운 데이터 유형을 만들어야하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c5cad017177801067fb33fec32abbde43a2a0a2" translate="yes" xml:space="preserve">
          <source>When creating visual scenes with Qt Quick, it is important to understand the concept of the</source>
          <target state="translated">Qt Quick을 사용하여 시각적 장면을 만들 때 개념을 이해하는 것이 중요합니다</target>
        </trans-unit>
        <trans-unit id="d8deccb0e684f6ccb3eb82d7b6672c38b9e7d190" translate="yes" xml:space="preserve">
          <source>When data is transferred from C++ to QML, the ownership of the data always remains with C++. The exception to this rule is when a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; is returned from an explicit C++ method call: in this case, the QML engine assumes ownership of the object, unless the ownership of the object has explicitly been set to remain with C++ by invoking &lt;a href=&quot;qqmlengine#setObjectOwnership&quot;&gt;QQmlEngine::setObjectOwnership&lt;/a&gt;() with &lt;a href=&quot;qqmlengine#ObjectOwnership-enum&quot;&gt;QQmlEngine::CppOwnership&lt;/a&gt; specified.</source>
          <target state="translated">데이터가 C ++에서 QML로 전송 될 때 데이터 소유권은 항상 C ++로 유지됩니다. 이 규칙의 예외 는 명시 적 C ++ 메소드 호출에서 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 가 리턴되는 경우입니다.이 경우 &lt;a href=&quot;qqmlengine#setObjectOwnership&quot;&gt;QQmlEngine ::&lt;/a&gt; 을 호출하여 오브젝트의 소유권이 명시 적으로 C ++로 유지되도록 설정되지 않은 한 QML 엔진은 오브젝트의 소유권을 가정합니다. &lt;a href=&quot;qqmlengine#ObjectOwnership-enum&quot;&gt;QQmlEngine :: CppOwnership이&lt;/a&gt; 지정된 setObjectOwnership () .</target>
        </trans-unit>
        <trans-unit id="833825b15200463ac0253e002ab1f7246eda7871" translate="yes" xml:space="preserve">
          <source>When data values are exchanged between QML and C++, they are converted by the QML engine to have the correct data types as appropriate for use in QML or C++. This requires the exchanged data to be of a type that is recognizable by the engine.</source>
          <target state="translated">QML과 C ++간에 데이터 값이 교환되면 QML 엔진에서 QML 또는 C ++에 사용하기에 적합한 데이터 유형을 갖도록 변환합니다. 이를 위해서는 교환 된 데이터가 엔진이 인식 할 수있는 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="88de44478b8ed2bd120794db0b7d5b455c64de25" translate="yes" xml:space="preserve">
          <source>When dealing with shared objects, there are two ways of copying an object. We usually speak about</source>
          <target state="translated">공유 객체를 처리 할 때 객체를 복사하는 두 가지 방법이 있습니다. 우리는 보통</target>
        </trans-unit>
        <trans-unit id="880f2e372d228c68b46fdc809205b92833a51398" translate="yes" xml:space="preserve">
          <source>When dealing with the D-Bus bus service or with remote applications over D-Bus, a number of error conditions can happen. This error conditions are sometimes signalled by a returned error value or by a &lt;a href=&quot;qdbuserror&quot;&gt;QDBusError&lt;/a&gt;.</source>
          <target state="translated">D-Bus 버스 서비스 또는 D-Bus를 통한 원격 애플리케이션을 처리 할 때 여러 가지 오류 조건이 발생할 수 있습니다. 이 오류 조건은 때때로 리턴 된 오류 값 또는 &lt;a href=&quot;qdbuserror&quot;&gt;QDBusError에&lt;/a&gt; 의해 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="37e1660403429a1797eb4c0aeb989abc574ce656" translate="yes" xml:space="preserve">
          <source>When declaring properties in QML, it's easy and convenient to use the &quot;var&quot; type:</source>
          <target state="translated">QML에서 속성을 선언 할 때 &quot;var&quot;유형을 사용하는 것이 쉽고 편리합니다.</target>
        </trans-unit>
        <trans-unit id="f6c7b9b1412f471c238127a4b55f7698c8fb1c87" translate="yes" xml:space="preserve">
          <source>When defining your own needle component, the only properties that the style requires you to set are the &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#implicitHeight-prop&quot;&gt;implicitHeight&lt;/a&gt;.</source>
          <target state="translated">자체 바늘 구성 요소를 정의 할 때 스타일에서 설정해야하는 유일한 속성은 &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;implicitWidth&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-item#implicitHeight-prop&quot;&gt;implicitHeight&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a11f2000ac0edf67c2b20ae00acff6fb70863dbe" translate="yes" xml:space="preserve">
          <source>When deploying Qt applications built using Visual Studio 2005, or later, make sure that the manifest file that was created when the application was linked is handled correctly. This is handled automatically for projects that generate DLLs.</source>
          <target state="translated">Visual Studio 2005 이상을 사용하여 빌드 된 Qt 응용 프로그램을 배포 할 때는 응용 프로그램을 연결할 때 만들어진 매니페스트 파일이 올바르게 처리되는지 확인하십시오. 이것은 DLL을 생성하는 프로젝트에서 자동으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="fc8ea9ac8ca6cf4cf6b3b5f4d012ccb4493d9e28" translate="yes" xml:space="preserve">
          <source>When developing applications that use D-Bus, it is sometimes useful to be able to see information about the messages that are sent and received across the bus by each application.</source>
          <target state="translated">D-Bus를 사용하는 응용 프로그램을 개발할 때 각 응용 프로그램이 버스를 통해 보내고받는 메시지에 대한 정보를 볼 수있는 것이 때때로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1a1c1be356204dfd455ba7ec0d01e973b146ec67" translate="yes" xml:space="preserve">
          <source>When disabled, a &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; node won't prevent the scene from being rendered. Toggling the enabled property is therefore a way to make a &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; active or inactive.</source>
          <target state="translated">비활성화하면 &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw&lt;/a&gt; 노드는 장면이 렌더링되는 것을 막지 않습니다. 따라서 enabled 속성을 전환하면 &lt;a href=&quot;qml-qt3d-render-nodraw&quot;&gt;NoDraw를&lt;/a&gt; 활성화하거나 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="857e0ffe6bd1478d0544df44c2c658d65e015926" translate="yes" xml:space="preserve">
          <source>When disabled, a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; node won't prevent the scene from being rendered. Toggling the enabled property is therefore a way to make a &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender::QNoDraw&lt;/a&gt; active or inactive.</source>
          <target state="translated">비활성화되면 &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw&lt;/a&gt; 노드는 장면이 렌더링되는 것을 막지 않습니다. 따라서 enabled 속성을 전환하면 &lt;a href=&quot;qt3drender-qnodraw&quot;&gt;Qt3DRender :: QNoDraw를&lt;/a&gt; 활성화 또는 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc1e687319c686b682a905da3e6616cd03084a73" translate="yes" xml:space="preserve">
          <source>When disabled, the normals on the surface are interpolated making the edges look round. When enabled, the normals are kept the same on a triangle making the color of the triangle solid. This makes the data more readable from the model.</source>
          <target state="translated">비활성화하면 표면의 법선이 보간되어 가장자리가 둥글게 보입니다. 활성화하면 삼각형의 색상이 단색으로 만들어지는 삼각형에서 법선이 동일하게 유지됩니다. 이는 모델에서 데이터를 더 읽기 쉽게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="24f4c0f2f49fed31d9cd8577cea9ab05b39be5e3" translate="yes" xml:space="preserve">
          <source>When displaying data from models in Qt item views, e.g., a &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, the individual items are drawn by a delegate. Also, when an item is edited, it provides an editor widget, which is placed on top of the item view while editing takes place. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; is the default delegate for all Qt item views, and is installed upon them when they are created.</source>
          <target state="translated">&lt;a href=&quot;qtableview&quot;&gt;QtItem&lt;/a&gt; 보기 (예 : QTableView) 에서 모델의 데이터를 표시 할 때 개별 항목은 대리자가 가져옵니다. 또한 항목을 편집 할 때 편집이 수행되는 동안 항목보기 위에 배치되는 편집기 위젯을 제공합니다. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; 는 모든 Qt 항목보기의 기본 대리자이며, 생성 될 때 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="0352c49318cb9d0b30ba555050217480183cb03e" translate="yes" xml:space="preserve">
          <source>When displaying items from a custom model in a standard view, it is often sufficient to simply ensure that the model returns appropriate data for each of the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;roles&lt;/a&gt; that determine the appearance of items in views. The default delegate used by Qt's standard views uses this role information to display items in most of the common forms expected by users. However, it is sometimes necessary to have even more control over the appearance of items than the default delegate can provide.</source>
          <target state="translated">표준보기에서 사용자 지정 모델의 항목을 표시 할 때보기에서 항목의 모양을 결정하는 각 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;역할&lt;/a&gt; 에 대해 모델이 적절한 데이터를 반환하도록하는 것만으로도 충분합니다 . Qt의 표준보기에서 사용되는 기본 대리자는이 역할 정보를 사용하여 사용자가 기대하는 대부분의 일반적인 양식으로 항목을 표시합니다. 그러나 기본 대리자가 제공 할 수있는 것보다 항목의 모양을 훨씬 더 잘 제어해야하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="159720c88af83f5ac94a174365550a72f0765067" translate="yes" xml:space="preserve">
          <source>When documenting a QML type in a</source>
          <target state="translated">QML 유형을 문서화 할 때</target>
        </trans-unit>
        <trans-unit id="b7e55292b4abae3e9e4e7263b6533ed85abbb41e" translate="yes" xml:space="preserve">
          <source>When documenting a QML type in the</source>
          <target state="translated">QML 유형을 문서화 할 때</target>
        </trans-unit>
        <trans-unit id="fd4be1f4d3d4fe684047540a2b498b3e14a564e5" translate="yes" xml:space="preserve">
          <source>When doing replacement the area of the preedit string is ignored, thus a replacement starting at -1 with a length of 2 will remove the last character before the preedit string and the first character afterwards, and insert the commit string directly before the preedit string.</source>
          <target state="translated">대체를 수행 할 때 사전 편집 문자열의 영역이 무시되므로 길이가 2 인 -1에서 시작하면 사전 편집 문자열 앞의 마지막 문자와 이후의 첫 문자가 제거되고 커미트 문자열이 사전 편집 문자열의 바로 앞에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="7b591bbff5ab07d40d7612a73ab5fcdc537e41fa" translate="yes" xml:space="preserve">
          <source>When doubleclicking an item, the item will first receive a mouse press event, followed by a release event (i.e., a click), then a doubleclick event, and finally a release event.</source>
          <target state="translated">아이템을 더블 클릭하면, 아이템은 먼저 마우스 프레스 이벤트를 수신 한 다음, 릴리즈 이벤트 (즉, 클릭), 더블 클릭 이벤트 및 마지막으로 릴리즈 이벤트를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="a02484f5ce286a79ae6a871b9106f5799cb1d5dc" translate="yes" xml:space="preserve">
          <source>When dragging the titlebar of a dock, all the tabs that are tabbed with it are going to be dragged. Implies AllowTabbedDocks. Does not work well if some QDockWidgets have restrictions in which area they are allowed. (This enum value was added in Qt 5.6.)</source>
          <target state="translated">도크의 제목 표시 줄을 드래그하면 탭이있는 모든 탭이 드래그됩니다. AllowTabbedDocks를 의미합니다. 일부 QDockWidget에 허용되는 영역에 제한이있는 경우 제대로 작동하지 않습니다. (이 열거 형 값은 Qt 5.6에서 추가되었습니다.)</target>
        </trans-unit>
        <trans-unit id="19649a7c3fc63002d50d3cb1460af355d223d55e" translate="yes" xml:space="preserve">
          <source>When drawStaticText() is called, the layout of the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; will be recalculated if any part of the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; object has changed since the last time it was drawn. It will also be recalculated if the painter's font is not the same as when the &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; was last drawn, or, on any other paint engine than the OpenGL2 engine, if the painter's matrix has been altered since the static text was last drawn.</source>
          <target state="translated">drawStaticText ()가 호출 될 때의 레이아웃 &lt;a href=&quot;qstatictext&quot;&gt;QStaticText는&lt;/a&gt; 의 어떤 부분 경우 다시 계산됩니다 &lt;a href=&quot;qstatictext&quot;&gt;QStaticText의&lt;/a&gt; 객체가 그려진 마지막 시간 이후 변경되었습니다. 또한 페인터의 글꼴이 &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; 가 마지막으로 그려졌 을 때와 같지 않거나 OpenGL2 엔진 이외의 다른 페인트 엔진에서 정적 텍스트가 마지막으로 그려진 이후에 페인터의 행렬이 변경된 경우에도 다시 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb13eb36af2066f03f57ae49bb001cd98eedd84c" translate="yes" xml:space="preserve">
          <source>When drawing text, the font is specified using the &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; class. Qt will use the font with the specified attributes, or if no matching font exists, Qt will use the closest matching installed font. The attributes of the font that is actually used can be retrieved using the &lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt; class. In addition, the &lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt; class provides the font measurements, and the &lt;a href=&quot;qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt; class provides information about the fonts available in the underlying window system.</source>
          <target state="translated">텍스트를 그릴 때 글꼴은 &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; 클래스를 사용하여 지정됩니다 . Qt는 지정된 속성을 가진 글꼴을 사용하거나 일치하는 글꼴이 없으면 가장 가까운 일치하는 설치된 글꼴을 사용합니다. 실제로 사용되는 글꼴의 속성은 &lt;a href=&quot;qfontinfo&quot;&gt;QFontInfo&lt;/a&gt; 클래스를 사용하여 검색 할 수 있습니다 . 또한 &lt;a href=&quot;qfontmetrics&quot;&gt;QFontMetrics&lt;/a&gt; 클래스는 글꼴 측정을 제공하고 &lt;a href=&quot;qfontdatabase&quot;&gt;QFontDatabase&lt;/a&gt; 클래스는 기본 윈도우 시스템에서 사용 가능한 글꼴에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2b8fa7bd4261a029b6f3fdf343d1e4a3de0c8942" translate="yes" xml:space="preserve">
          <source>When drawing with &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device.</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter로&lt;/a&gt; 그릴 때 논리 좌표를 사용하여 점을 지정하면 페인트 장치의 물리적 좌표로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="410e5ecacd6f13933f5b02a517c03bf075b15730" translate="yes" xml:space="preserve">
          <source>When drawing with &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, we specify points using logical coordinates which then are converted into the physical coordinates of the paint device. The mapping of the logical coordinates to the physical coordinates are handled by &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;'s &lt;a href=&quot;qpainter#combinedTransform&quot;&gt;combinedTransform&lt;/a&gt;(), a combination of &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() and &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() and &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;(). The &lt;a href=&quot;qpainter#viewport&quot;&gt;viewport&lt;/a&gt;() represents the physical coordinates specifying an arbitrary rectangle, the &lt;a href=&quot;qpainter#window&quot;&gt;window&lt;/a&gt;() describes the same rectangle in logical coordinates, and the &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt;() is identical with the transformation matrix.</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter로&lt;/a&gt; 그릴 때 논리 좌표를 사용하여 점을 지정하면 페인트 장치의 물리적 좌표로 변환됩니다. 논리 좌표를 물리 좌표에 맵핑하는 것은 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 의 &lt;a href=&quot;qpainter#combinedTransform&quot;&gt;CombinedTransform&lt;/a&gt; (), &lt;a href=&quot;qpainter#viewport&quot;&gt;뷰포트&lt;/a&gt; ()와 &lt;a href=&quot;qpainter#window&quot;&gt;창&lt;/a&gt; () 및 &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform&lt;/a&gt; () 의 조합에 의해 처리됩니다 . &lt;a href=&quot;qpainter#viewport&quot;&gt;뷰포트&lt;/a&gt; () 임의의 직사각형을 특정 물리 좌표를 상기 대표 &lt;a href=&quot;qpainter#window&quot;&gt;창&lt;/a&gt; () 논리 좌표 동일한 사각형을 설명하고 &lt;a href=&quot;qpainter#worldTransform&quot;&gt;worldTransform는&lt;/a&gt; () 변환 행렬과 동일하다.</target>
        </trans-unit>
        <trans-unit id="c5ed330ed405cc570c36b8d34b32b0e9f282124b" translate="yes" xml:space="preserve">
          <source>When drawing, the pixel rendering is controlled by the &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter::Antialiasing&lt;/a&gt; render hint.</source>
          <target state="translated">그릴 때 픽셀 렌더링은 &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter :: Antialiasing&lt;/a&gt; 렌더 힌트에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="d15b0d71322e99bde4953dbe90c85c3ef7baf9a0" translate="yes" xml:space="preserve">
          <source>When drawing, the pixel rendering is controlled by the &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter::Antialiasing&lt;/a&gt; render hint. The &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter::RenderHint&lt;/a&gt; enum is used to specify flags to &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; that may or may not be respected by any given engine.</source>
          <target state="translated">그릴 때 픽셀 렌더링은 &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter :: Antialiasing&lt;/a&gt; 렌더 힌트에 의해 제어됩니다 . &lt;a href=&quot;qpainter#RenderHint-enum&quot;&gt;QPainter를 :: RenderHint의&lt;/a&gt; 열거가에 플래그를 지정하는 데 사용됩니다 &lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; 또는 특정 엔진에 의해 존중 될 수도 있고 그렇지 않을 수도있다.</target>
        </trans-unit>
        <trans-unit id="6ebdf8b96fea44b5a3aed78415b3fda3d62aa0c1" translate="yes" xml:space="preserve">
          <source>When driving animations, this function should be called once after drawing has completed. Calling this function multiple times will result in a single event being delivered to the window.</source>
          <target state="translated">애니메이션을 구동 할 때 그리기가 완료된 후에이 함수를 한 번 호출해야합니다. 이 함수를 여러 번 호출하면 단일 이벤트가 창에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="1ce5dba37bb8921ab742160f013368e5f3259059" translate="yes" xml:space="preserve">
          <source>When duplicate skipping is enabled, successive readings with the same or very similar values are omitted. This helps reducing the amount of processing done, as less sensor readings are made available. As a consequence, readings arrive at an irregular interval.</source>
          <target state="translated">중복 건너 뛰기를 사용하면 동일하거나 매우 유사한 값을 가진 연속 판독 값이 생략됩니다. 이는 적은 센서 판독 값이 제공되므로 처리량을 줄이는 데 도움이됩니다. 결과적으로 판독 값이 불규칙적으로 도착합니다.</target>
        </trans-unit>
        <trans-unit id="d5e3a8786c0102ae5523b4a9dad7cca51f61d1c8" translate="yes" xml:space="preserve">
          <source>When each primitive is large, this overhead is negligible, but in the case of a typical UI, there are many small items which add up to a considerable overhead.</source>
          <target state="translated">각 프리미티브가 크면이 오버 헤드는 무시할 수 있지만 일반적인 UI의 경우 많은 오버 헤드를 추가하는 작은 항목이 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbc38d0da8ee345ba2fd00eef535419aae91f344" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; provides an editor widget, which is a widget that is placed on top of the view while editing takes place. Editors are created with a &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt;; a default static instance provided by &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; is installed on all item delegates. You can set a custom factory using &lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt;() or set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory::setDefaultFactory&lt;/a&gt;(). It is the data stored in the item model with the &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt::EditRole&lt;/a&gt; that is edited.</source>
          <target state="translated">항목보기에서 데이터를 편집 할 때 &lt;a href=&quot;qitemdelegate&quot;&gt;QItemDelegate&lt;/a&gt; 는 편집이 수행되는 동안보기 위에 배치되는 위젯 인 편집기 위젯을 제공합니다. 에디터는 &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; 로 작성됩니다 . &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; 가 제공하는 기본 정적 인스턴스 는 모든 항목 대리자에 설치됩니다. &lt;a href=&quot;qitemdelegate#setItemEditorFactory&quot;&gt;setItemEditorFactory&lt;/a&gt; ()를 사용하여 사용자 정의 팩토리를 설정하거나 &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;QItemEditorFactory :: setDefaultFactory&lt;/a&gt; ()를 사용하여 새 기본 팩토리를 설정할 수 있습니다 . 편집 된 &lt;a href=&quot;qt#ItemDataRole-enum&quot;&gt;Qt :: EditRole&lt;/a&gt; 과 함께 항목 모델에 저장된 데이터 입니다.</target>
        </trans-unit>
        <trans-unit id="6f6344a0186d030dc605de997efbebf65f1b9a99" translate="yes" xml:space="preserve">
          <source>When editing data in an item view, editors are created and displayed by a delegate. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt;, which is the delegate by default installed on Qt's item views, uses a &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; to create editors for it. A default unique instance provided by &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; is used by all item delegates. If you set a new default factory with &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt;(), the new factory will be used by existing and new delegates.</source>
          <target state="translated">항목보기에서 데이터를 편집하면 대리자가 편집기를 작성하고 표시합니다. &lt;a href=&quot;qstyleditemdelegate&quot;&gt;QStyledItemDelegate&lt;/a&gt; Qt의 아이템 뷰에 설치 기본적으로 위임이다,하는 사용 &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; 그것을 위해 에디터를 만들 수 있습니다. &lt;a href=&quot;qitemeditorfactory&quot;&gt;QItemEditorFactory&lt;/a&gt; 가 제공하는 기본 고유 인스턴스 는 모든 항목 대리자가 사용합니다. &lt;a href=&quot;qitemeditorfactory#setDefaultFactory&quot;&gt;setDefaultFactory&lt;/a&gt; () 를 사용하여 새 기본 팩토리를 설정하면 기존 및 새 대리자가 새 팩토리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c0e7a6ec88186d061ca22e9701050d741f30a191" translate="yes" xml:space="preserve">
          <source>When editing is finished, either because the line edit lost focus or Return/Enter is pressed the &lt;a href=&quot;qlineedit#editingFinished&quot;&gt;editingFinished&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">편집이 완료되면, 라인 편집 상실 포커스 또는 Return / Enter를 눌렀을 때 &lt;a href=&quot;qlineedit#editingFinished&quot;&gt;editingFinished&lt;/a&gt; () 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d66bfe606de9465976bab385d92db6b5ec57c788" translate="yes" xml:space="preserve">
          <source>When editing of an item starts, this function is called with the</source>
          <target state="translated">항목 편집이 시작되면이 함수는</target>
        </trans-unit>
        <trans-unit id="b9a4a24a7b2e2cf96998146b51d4cf55a3e5c82a" translate="yes" xml:space="preserve">
          <source>When enabled and the label shows a pixmap, it will scale the pixmap to fill the available space.</source>
          <target state="translated">활성화되고 레이블에 픽스맵이 표시되면 사용 가능한 공간을 채우도록 픽스맵의 크기가 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="809e3c2e92b5437339d00438d8ac5682f3c1094a" translate="yes" xml:space="preserve">
          <source>When enabled, making a Shape visible will not wait for the content to become available. Instead, the gui/main thread is not blocked and the results of the path rendering are shown only when all the asynchronous work has been finished.</source>
          <target state="translated">활성화하면 모양을 표시해도 내용을 사용할 수있을 때까지 기다리지 않습니다. 대신 gui / main 스레드는 차단되지 않으며 모든 비동기 작업이 완료된 경우에만 경로 렌더링 결과가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fef9dffa012fb5631fc857fa121adc562514620b" translate="yes" xml:space="preserve">
          <source>When enabled, this attribute disables the delivery of mouse events to the widget and its children. Mouse events are delivered to other widgets as if the widget and its children were not present in the widget hierarchy; mouse clicks and other events effectively &quot;pass through&quot; them. This attribute is disabled by default.</source>
          <target state="translated">사용 가능한 경우이 속성은 마우스 이벤트를 위젯 및 해당 하위로 전달할 수 없게합니다. 위젯 및 해당 하위가 위젯 계층 구조에없는 것처럼 마우스 이벤트가 다른 위젯으로 전달됩니다. 마우스 클릭 및 기타 이벤트는 효과적으로 &quot;통과&quot;합니다. 이 속성은 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="482662a30996d40d4a1c18a3374e7b2c360e9d38" translate="yes" xml:space="preserve">
          <source>When entering &quot;What's This?&quot; mode, a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type Qt::EnterWhatsThisMode is sent to all toplevel widgets.</source>
          <target state="translated">&quot;무엇입니까?&quot;를 입력 할 때 모드, &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; 유형 Qt는 :: EnterWhatsThisMode의 모든 최상위 위젯으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="6190eb6bb23c0ba0b8cd55075c9df2ea7f1a0eef" translate="yes" xml:space="preserve">
          <source>When executed together with the source-side example, the output is identical to &lt;a href=&quot;#qtro-example1&quot;&gt;Example 1&lt;/a&gt;.</source>
          <target state="translated">소스 측 예제와 함께 실행하면 출력은 &lt;a href=&quot;#qtro-example1&quot;&gt;예제 1&lt;/a&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c9a96d672de3f61af853bd3fb2b4ddb09401c17a" translate="yes" xml:space="preserve">
          <source>When executed, QDoc will exclude the listed directories from further consideration. Files in these directories will not be read by qdoc.</source>
          <target state="translated">실행되면 QDoc은 나열된 디렉토리를 추가 고려 대상에서 제외합니다. 이 디렉토리의 파일은 qdoc에서 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f0b8e30c664f1e368519b1a60f634e4ae26e999b" translate="yes" xml:space="preserve">
          <source>When executed, QDoc will ignore the directories listed. &lt;b&gt;See also&lt;/b&gt;: &lt;a href=&quot;22-qdoc-configuration-generalvariables#excludefiles&quot;&gt;excludefiles&lt;/a&gt;.</source>
          <target state="translated">실행되면 QDoc은 나열된 디렉토리를 무시합니다. &lt;b&gt;참고&lt;/b&gt; : &lt;a href=&quot;22-qdoc-configuration-generalvariables#excludefiles&quot;&gt;excludefiles&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca04becdda83845f40b583b367041236f99a3f37" translate="yes" xml:space="preserve">
          <source>When executed, the first thing QDoc will do is to read through the headers specified in the &lt;a href=&quot;#headers&quot;&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/a&gt; variable, and the ones located in the directories specified in the &lt;code&gt;headerdir&lt;/code&gt; variable (including all subdirectories), building an internal structure of the classes and their functions.</source>
          <target state="translated">QDoc이 실행될 때 가장 먼저 할 일은 &lt;a href=&quot;#headers&quot;&gt; &lt;code&gt;headers&lt;/code&gt; &lt;/a&gt; 변수에 지정된 헤더 와 &lt;code&gt;headerdir&lt;/code&gt; 변수에 지정된 디렉토리 (모든 서브 디렉토리 포함)에있는 클래스를 읽고 클래스의 내부 구조와 함수를 빌드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5cb7e1f93541ac06ba092ca034af95b10f030b3f" translate="yes" xml:space="preserve">
          <source>When executed, the first thing QDoc will do is to read through the headers specified in the &lt;a href=&quot;10-qdoc-commands-tablesandlists#header-command&quot;&gt;&lt;code&gt;header&lt;/code&gt;&lt;/a&gt; variable, and the ones located in the directories specified in the &lt;code&gt;headerdir&lt;/code&gt; variable (including all subdirectories), building an internal structure of the classes and their functions.</source>
          <target state="translated">QDoc이 실행될 때 가장 먼저 할 일은 &lt;a href=&quot;10-qdoc-commands-tablesandlists#header-command&quot;&gt; &lt;code&gt;header&lt;/code&gt; &lt;/a&gt; 변수에 지정된 헤더 와 &lt;code&gt;headerdir&lt;/code&gt; 변수에 지정된 디렉토리 (모든 서브 디렉토리 포함)에있는 클래스를 읽고 클래스의 내부 구조와 함수를 빌드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="09ffff96391333a52eee7a9ad80e057863c3ba11" translate="yes" xml:space="preserve">
          <source>When expanding is true &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; will expand the tabs to use the empty space.</source>
          <target state="translated">확장이 true 일 때 &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; 는 탭을 확장하여 빈 공간을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2620b86db1234798b63f39503859611b9649e059" translate="yes" xml:space="preserve">
          <source>When exporting 9-patch images in several DPI variants (&lt;code&gt;@2x&lt;/code&gt;, &lt;code&gt;@3x&lt;/code&gt;, etc.), the 9-patch lines will typically be scaled up along with the image. There are several ways to fix this, but perhaps the simplest approach is to use &lt;a href=&quot;https://www.imagemagick.org/script/mogrify.php&quot;&gt;ImageMagick's mogrify&lt;/a&gt; tool. The tool has a &lt;code&gt;-shave&lt;/code&gt; feature that can be used to crop the image to reduce the thickness of the 9-patch lines:</source>
          <target state="translated">여러 DPI 변형 ( &lt;code&gt;@2x&lt;/code&gt; , &lt;code&gt;@3x&lt;/code&gt; 등)으로 9 패치 이미지를 내 보내면 일반적으로 9 패치 라인이 이미지와 함께 확대됩니다. 이 문제를 해결하는 방법에는 여러 가지가 있지만 가장 간단한 방법은 &lt;a href=&quot;https://www.imagemagick.org/script/mogrify.php&quot;&gt;ImageMagick의 mogrify&lt;/a&gt; 도구 를 사용하는 것 입니다. 이 도구에는 9 패치 라인의 두께를 줄이기 위해 이미지를 자르는 데 사용할 수 있는 &lt;code&gt;-shave&lt;/code&gt; 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="426d2b133ccf9d0aab48e582602ba3229910acac" translate="yes" xml:space="preserve">
          <source>When extending QML with C++ code, a C++ class can be registered with the QML type system to enable the class to be used as a data type within QML code. While the properties, methods and signals of any &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;-derived class are accessible from QML, as discussed in &lt;a href=&quot;qtqml-cppintegration-exposecppattributes#&quot;&gt;Exposing Attributes of C++ Types to QML&lt;/a&gt;, such a class cannot be used as a data type from QML until it is registered with the type system. Additionally registration can provide other features, such as allowing a class to be used as an instantiable &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML object type&lt;/a&gt; from QML, or enabling a singleton instance of the class to be imported and used from QML.</source>
          <target state="translated">C ++ 코드를 사용하여 QML을 확장 할 때 C ++ 클래스를 QML 유형 시스템에 등록하여 클래스를 QML 코드 내에서 데이터 유형으로 사용할 수 있습니다. &lt;a href=&quot;qtqml-cppintegration-exposecppattributes#&quot;&gt;C ++ 유형의 속성을 QML&lt;/a&gt; 에 노출 에서 설명한대로 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 파생 클래스 의 특성, 메소드 및 신호에 액세스 할 수 있지만 이러한 클래스는 유형 시스템에 등록 될 때까지 QML의 데이터 유형으로 사용할 수 없습니다. 또한 등록을 통해 &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML&lt;/a&gt; 에서 클래스를 인스턴스화 가능한 QML 객체 유형 으로 사용 하거나 클래스의 단일 인스턴스를 가져 와서 QML에서 사용할 수 있도록하는 등의 다른 기능을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9db3502d0d4498df3a64124b7eb7242bd03e84ad" translate="yes" xml:space="preserve">
          <source>When generating DITA XML, qdoc outputs the nested</source>
          <target state="translated">DITA XML을 생성 할 때 qdoc는 중첩을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="6359268011bd2e23ea07a88afa77e4d08fbb1147" translate="yes" xml:space="preserve">
          <source>When generating the reference documentation for a class, QDoc will create and link to a separate page documenting its obsolete functions. Usually an equivalent function is provided as an alternative.</source>
          <target state="translated">클래스에 대한 참조 문서를 생성 할 때 QDoc은 더 이상 사용되지 않는 기능을 설명하는 별도의 페이지를 작성하고 링크합니다. 대체로 동등한 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="71f447939a909dfa27ce949444c9508a3a7d93da" translate="yes" xml:space="preserve">
          <source>When getting started with developing on a given embedded device, it is often necessary to verify the behavior of the device and drivers, and that the connected displays are working as they should. One easy way is to use the hellowindow example. Launching it with &lt;code&gt;-platform eglfs --multiscreen --timeout&lt;/code&gt; arguments shows a rotating Qt logo on each connected screen for a few seconds.</source>
          <target state="translated">주어진 임베디드 장치에서 개발을 시작할 때 종종 장치와 드라이버의 동작을 확인하고 연결된 디스플레이가 정상적으로 작동하는지 확인해야합니다. 한 가지 쉬운 방법은 hellowindow 예제를 사용하는 것입니다. &lt;code&gt;-platform eglfs --multiscreen --timeout&lt;/code&gt; 인수를 사용 하여 시작하면 연결된 각 화면에 몇 초 동안 회전하는 Qt 로고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b8ddc3778afe40355df31ec30ad7ce29680583ba" translate="yes" xml:space="preserve">
          <source>When handling the signal with &lt;code&gt;onLoadingChanged&lt;/code&gt;, various read-only parameters are available on the &lt;a href=&quot;qml-qtwebengine-webengineloadrequest&quot;&gt;WebEngineLoadRequest&lt;/a&gt; specified by</source>
          <target state="translated">로 신호 처리하면 &lt;code&gt;onLoadingChanged&lt;/code&gt; 를 다양한 읽기 전용 변수는에 사용할 &lt;a href=&quot;qml-qtwebengine-webengineloadrequest&quot;&gt;WebEngineLoadRequest가&lt;/a&gt; 의해 지정된</target>
        </trans-unit>
        <trans-unit id="dd3376f42ea41d22705767c518b03411a09688ef" translate="yes" xml:space="preserve">
          <source>When handling this signal, changing the &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accepted&lt;/a&gt; property of the</source>
          <target state="translated">이 신호를 처리 할 때, 변경 &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;수락&lt;/a&gt; 의 속성</target>
        </trans-unit>
        <trans-unit id="6609fd77e98998e1210abc85df3c2fabea25a8b3" translate="yes" xml:space="preserve">
          <source>When handling this signal, if the &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accepted&lt;/a&gt; property of the</source>
          <target state="translated">이 신호 처리, 만약 &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;수락&lt;/a&gt; 의 속성</target>
        </trans-unit>
        <trans-unit id="b478004d57f010bec2ae3794bb546849c254693f" translate="yes" xml:space="preserve">
          <source>When handling this signal, use the &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;accepted&lt;/a&gt; property of the</source>
          <target state="translated">이 신호를 처리 할 때 사용 &lt;a href=&quot;qml-qtquick-mouseevent#accepted-prop&quot;&gt;허용&lt;/a&gt; 의 속성을</target>
        </trans-unit>
        <trans-unit id="6295b7b616f0d9112be806cf906b2998b3813947" translate="yes" xml:space="preserve">
          <source>When having multiple displays connected, the level of support for targeting one or more of these from one single Qt application varies between the platform plugins and often depends on the device and its graphics stack.</source>
          <target state="translated">여러 개의 디스플레이가 연결된 경우 하나의 단일 Qt 애플리케이션에서 하나 이상의 대상을 대상으로하는 지원 수준은 플랫폼 플러그인마다 다르며 종종 장치와 그래픽 스택에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="33cb76c34e5dfbfadb36579df2b883f159a00960" translate="yes" xml:space="preserve">
          <source>When implemented, this function is responsible for checking the paint engine's current</source>
          <target state="translated">구현시이 기능은 페인트 엔진의 전류를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="cb84a9cfef6f8292ec44602b7462e414abc9870a" translate="yes" xml:space="preserve">
          <source>When implementing a custom extension class, you must use Q_DECLARE_EXTENSION_INTERFACE() to enable usage of the &lt;a href=&quot;qextensionmanager#qt_extension&quot;&gt;qt_extension&lt;/a&gt;() function. The macro is normally located right after the class definition for</source>
          <target state="translated">사용자 정의 확장 클래스를 구현할 때 &lt;a href=&quot;qextensionmanager#qt_extension&quot;&gt;qt_extension&lt;/a&gt; () 함수 를 사용하려면 Q_DECLARE_EXTENSION_INTERFACE ()를 사용해야합니다 . 매크로는 일반적으로 클래스 정의 바로 뒤에 있습니다.</target>
        </trans-unit>
        <trans-unit id="84772bea2f59837a3da39c7af78975341f21eb2b" translate="yes" xml:space="preserve">
          <source>When implementing a custom style, you cannot assume that the widget is a &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; just because the enum value is called &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinUp&lt;/a&gt; or &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinDown&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 스타일을 구현할 때 열거 형 값이 &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinUp&lt;/a&gt; 또는 &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_IndicatorSpinDown&lt;/a&gt; 이라고 해서 위젯이 &lt;a href=&quot;qspinbox&quot;&gt;QSpinBox&lt;/a&gt; 라고 가정 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="869ecc6a6e96e1eee7be87f15ad29e53d15bface" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, a pointer to</source>
          <target state="translated">사용자 정의 위젯 플러그인을 구현할 때</target>
        </trans-unit>
        <trans-unit id="b5e58b90ddc89647665b1bcd29b18d24dcef1559" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, you build it as a separate library. If you want to include several custom widget plugins in the same library, you must in addition subclass &lt;a href=&quot;qdesignercustomwidgetcollectioninterface&quot;&gt;QDesignerCustomWidgetCollectionInterface&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 위젯 플러그인을 구현할 때 별도의 라이브러리로 빌드하십시오. 동일한 라이브러리에 여러 개의 사용자 정의 위젯 플러그인을 포함 시키려면 또한 하위 클래스 &lt;a href=&quot;qdesignercustomwidgetcollectioninterface&quot;&gt;QDesignerCustomWidgetCollectionInterface&lt;/a&gt; 를 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4c647a12112d8ed46e7c8ca84107c20d588614b0" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget plugin, you must subclass the &lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt; to expose your plugin to</source>
          <target state="translated">사용자 정의 위젯 플러그인을 구현할 때 플러그인 을 노출 시키려면 &lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt; 를 서브 클래스해야합니다.</target>
        </trans-unit>
        <trans-unit id="91021ae6ff5dfe6164732e25da258734b737eb88" translate="yes" xml:space="preserve">
          <source>When implementing a custom widget you must subclass &lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt; to expose your widget to</source>
          <target state="translated">사용자 정의 위젯을 구현할 때 위젯 을 노출 하려면 &lt;a href=&quot;qdesignercustomwidgetinterface&quot;&gt;QDesignerCustomWidgetInterface&lt;/a&gt; 를 서브 클래스해야합니다.</target>
        </trans-unit>
        <trans-unit id="595ba0ecf978bd65b6513cd7266fa82465645c81" translate="yes" xml:space="preserve">
          <source>When implementing a model it is important to remember that &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; does not store any data itself, it merely presents an interface that the views use to access the data. For a minimal read-only model it is only necessary to implement a few functions as there are default implementations for most of the interface. The class declaration is as follows:</source>
          <target state="translated">모델을 구현할 때 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 은 데이터 자체를 저장하지 않으며 뷰가 데이터에 액세스하는 데 사용하는 인터페이스 만 제공 한다는 점을 기억해야 합니다. 최소 읽기 전용 모델의 경우 대부분의 인터페이스에 대한 기본 구현이 있으므로 몇 가지 기능 만 구현하면됩니다. 클래스 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="445cd07d2a0506cd16ff907563ea7c0e381a4ac2" translate="yes" xml:space="preserve">
          <source>When implementing a new widget, it is almost always useful to reimplement &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;sizeHint&lt;/a&gt;() to provide a reasonable default size for the widget and to set the correct size policy with &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;setSizePolicy&lt;/a&gt;().</source>
          <target state="translated">새 위젯을 구현할 때 &lt;a href=&quot;qwidget#sizeHint-prop&quot;&gt;sizeHint&lt;/a&gt; () 를 다시 구현 하여 위젯에 적절한 기본 크기를 제공하고 &lt;a href=&quot;qwidget#sizePolicy-prop&quot;&gt;setSizePolicy&lt;/a&gt; () 를 사용하여 올바른 크기 정책을 설정하는 것이 거의 항상 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="4c9d446fde723c06b31550398f72ba270ba5a90c" translate="yes" xml:space="preserve">
          <source>When implementing a subclass of this interface, there are only a handful of functions to implement, broken down into two classes:</source>
          <target state="translated">이 인터페이스의 서브 클래스를 구현할 때 구현할 소수의 함수 만 두 가지 클래스로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="d65384984581a6d6fbb1f4f4bccbb7923f82cdc1" translate="yes" xml:space="preserve">
          <source>When implementing a subclass, you must call this function</source>
          <target state="translated">서브 클래스를 구현할 때이 함수를 호출해야합니다</target>
        </trans-unit>
        <trans-unit id="7c18f33bf2a59c6087f18cc24038056a308ad7f2" translate="yes" xml:space="preserve">
          <source>When implementing an accessibility interface for widgets, one would as a rule inherit &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;, which is a convenience class for widgets. Another available convenience class, which is inherited by &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt;, is the &lt;a href=&quot;qaccessibleobject&quot;&gt;QAccessibleObject&lt;/a&gt;, which implements part of the interface for QObjects.</source>
          <target state="translated">위젯에 대한 액세스 가능성 인터페이스를 구현할 때, 위젯 의 편의 클래스 인 &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget을&lt;/a&gt; 상속 합니다. &lt;a href=&quot;qaccessiblewidget&quot;&gt;QAccessibleWidget&lt;/a&gt; 에 의해 상속되는 또 다른 사용 가능한 편의 클래스 는 &lt;a href=&quot;qaccessibleobject&quot;&gt;QObjects&lt;/a&gt; 인터페이스의 일부를 구현 하는 QAccessibleObject 입니다.</target>
        </trans-unit>
        <trans-unit id="4e43675b73f85281cf7ffd4c9feb92576f97c666" translate="yes" xml:space="preserve">
          <source>When implementing an item model (that is, a concrete &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass) one must abide to a very strict set of rules that ensure consistency for users of the model (views, proxy models, and so on).</source>
          <target state="translated">아이템 모델 (구체적인 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 서브 클래스)을 구현할 때는 모델 사용자 (뷰, 프록시 모델 등)의 일관성을 보장하는 매우 엄격한 규칙을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="71c25ae80d1eb821bd312d0369953f3099005788" translate="yes" xml:space="preserve">
          <source>When implementing drag and drop support in a custom model, if you will return data in formats other than the default internal MIME type, reimplement this function to return your list of MIME types.</source>
          <target state="translated">사용자 정의 모델에서 끌어서 놓기 지원을 구현할 때 기본 내부 MIME 유형 이외의 형식으로 데이터를 리턴하는 경우이 함수를 다시 구현하여 MIME 유형 목록을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="3e1de2caa20c3401ccd297583ca14adb9e36f89e" translate="yes" xml:space="preserve">
          <source>When implementing drag and drop support in a custom model, it is possible to export items of data in specialized formats by reimplementing the following function:</source>
          <target state="translated">사용자 정의 모델에서 끌어서 놓기 지원을 구현할 때 다음 기능을 다시 구현하여 특수 형식으로 데이터 항목을 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="891ebe7dedc591934a24e2e5c92f98ba49623d2e" translate="yes" xml:space="preserve">
          <source>When implementing styles, it is necessary to look through the code of the widgets and code of the base class and its ancestors. This is because the widgets use the style differently, because the implementation in the different styles' virtual functions can affect the state of the drawing (e.g., by altering the &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; state without restoring it and drawing some elements without using the appropriate pixel metrics and sub elements).</source>
          <target state="translated">스타일을 구현할 때는 위젯 코드와 기본 클래스 및 상위 클래스의 코드를 살펴 봐야합니다. 이는 다른 스타일의 가상 함수에서의 구현이 드로잉의 상태에 영향을 줄 수 있기 때문에 위젯이 스타일을 다르게 사용하기 때문입니다 (예 : 적절한 픽셀 메트릭 및 하위를 사용하지 않고 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 상태를 복원하지 않고 변경하고 일부 요소를 드로잉하여) 집단).</target>
        </trans-unit>
        <trans-unit id="1c4d91075815fdbbae33aba2b667fd4633c4c3da" translate="yes" xml:space="preserve">
          <source>When implementing the property write function, use &lt;a href=&quot;qaxbindable#requestPropertyChange&quot;&gt;requestPropertyChange&lt;/a&gt;() to get permission from the ActiveX client application to change this property. When the property changes, call &lt;a href=&quot;qaxbindable#propertyChanged&quot;&gt;propertyChanged&lt;/a&gt;() to notify the ActiveX client application about the change. If a fatal error occurs in the control, use the static &lt;a href=&quot;qaxbindable#reportError&quot;&gt;reportError&lt;/a&gt;() function to notify the client.</source>
          <target state="translated">속성 쓰기 기능을 구현할 때 &lt;a href=&quot;qaxbindable#requestPropertyChange&quot;&gt;requestPropertyChange&lt;/a&gt; ()를 사용하여 ActiveX 클라이언트 응용 프로그램에서이 속성을 변경할 수있는 권한을 얻습니다. 속성이 변경되면 &lt;a href=&quot;qaxbindable#propertyChanged&quot;&gt;propertyChanged&lt;/a&gt; ()를 호출 하여 ActiveX 클라이언트 응용 프로그램에 변경 내용을 알립니다. 컨트롤에서 치명적인 오류가 발생하면 정적 &lt;a href=&quot;qaxbindable#reportError&quot;&gt;reportError&lt;/a&gt; () 함수를 사용하여 클라이언트에 알립니다.</target>
        </trans-unit>
        <trans-unit id="5c75a646668a787fcace5c55f81aa7bf0b70d1c6" translate="yes" xml:space="preserve">
          <source>When implementing the property write functions, use the &lt;a href=&quot;qaxbindable&quot;&gt;QAxBindable&lt;/a&gt; class's requestPropertyChange() and propertyChanged() functions to allow ActiveX clients to bind to the control properties.</source>
          <target state="translated">속성 쓰기 함수를 구현할 때 &lt;a href=&quot;qaxbindable&quot;&gt;QAxBindable&lt;/a&gt; 클래스의 requestPropertyChange () 및 propertyChanged () 함수를 사용하여 ActiveX 클라이언트가 컨트롤 속성에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b41031e55866a68b8184e142ce7198e2e1fe7ec" translate="yes" xml:space="preserve">
          <source>When implementing this function in subclasses of this class, you must construct and return new editor widgets with the parent widget specified.</source>
          <target state="translated">이 클래스의 서브 클래스에서이 함수를 구현할 때 지정된 상위 위젯으로 새 편집기 위젯을 구성하고 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="1591d2c3ab41219fe3e148cfbb0593be15c3c678" translate="yes" xml:space="preserve">
          <source>When implementing this function in subclasses, you must ensure that the editor widget's property specified by this function can accept the type the creator is registered for. For example, a creator which constructs &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; widgets to edit boolean values would return the &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;checkable&lt;/a&gt; property name from this function, and must be registered in the item editor factory for the QVariant::Bool type.</source>
          <target state="translated">서브 클래스에서이 함수를 구현할 때이 함수로 지정된 편집기 위젯의 특성이 작성자가 등록 된 유형을 승인 할 수 있는지 확인해야합니다. 예를 들어, 부울 값을 편집하기 위해 &lt;a href=&quot;qcheckbox&quot;&gt;QCheckBox&lt;/a&gt; 위젯을 구성하는 작성자 는이 함수에서 &lt;a href=&quot;qabstractbutton#checkable-prop&quot;&gt;확인할 수있는&lt;/a&gt; 특성 이름을 리턴 하며 QVariant :: Bool 유형의 항목 편집기 팩토리에 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ce39d7538e9c5292578832459d332de3effbff1" translate="yes" xml:space="preserve">
          <source>When implementing this interface you will almost certainly also want to implement &lt;a href=&quot;qaccessibletextinterface&quot;&gt;QAccessibleTextInterface&lt;/a&gt;.</source>
          <target state="translated">이 인터페이스를 구현할 때 거의 확실하게 &lt;a href=&quot;qaccessibletextinterface&quot;&gt;QAccessibleTextInterface&lt;/a&gt; 구현을 원할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6268d96d04a4d653a0acc9732f0ac32216ce55c6" translate="yes" xml:space="preserve">
          <source>When implementing you own custom graphics transform, you must call this function every time you change a parameter, to let &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; know that its transformation needs to be updated.</source>
          <target state="translated">사용자 정의 그래픽 변환을 구현할 때 매개 변수를 변경할 때마다이 함수를 호출하여 &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 에 변환이 업데이트 되어야 함을 알려야합니다 .</target>
        </trans-unit>
        <trans-unit id="e0faa4d1d0c8b9ed5d373ba76a73de237e335d71" translate="yes" xml:space="preserve">
          <source>When implementing your own implicitly shared classes, use the &lt;a href=&quot;qshareddata&quot;&gt;QSharedData&lt;/a&gt; and &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; classes.</source>
          <target state="translated">내재적으로 공유 된 클래스를 구현할 때는 &lt;a href=&quot;qshareddata&quot;&gt;QSharedData&lt;/a&gt; 및 &lt;a href=&quot;qshareddatapointer&quot;&gt;QSharedDataPointer&lt;/a&gt; 클래스를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed089988e57c5a0f9eb64a54af80f4e4cc7da5be" translate="yes" xml:space="preserve">
          <source>When implementing your own itemview setSelection should call &lt;a href=&quot;qabstractitemview#selectionModel&quot;&gt;selectionModel&lt;/a&gt;()-&amp;gt;select(selection, flags) where selection is either an empty &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; or a &lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt; that contains all items that are contained in</source>
          <target state="translated">자신의 itemview를 구현할 때 setSelection은 &lt;a href=&quot;qabstractitemview#selectionModel&quot;&gt;selectionModel&lt;/a&gt; ()-&amp;gt; select (selection, flags)를 호출해야합니다. 여기서 selection은 빈 &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; 또는에 포함 된 모든 항목을 포함 하는 &lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6d2c6cac0080194cff24d54acaddace27ee77592" translate="yes" xml:space="preserve">
          <source>When importing a &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML object type&lt;/a&gt; with a property alias in the root object, however, the property appear as a regular Qt property and consequently can be used in alias references.</source>
          <target state="translated">그러나 루트 오브젝트에서 특성 별명을 가진 &lt;a href=&quot;qtqml-typesystem-objecttypes#&quot;&gt;QML 오브젝트 유형&lt;/a&gt; 을 가져올 때 , 특성은 일반 Qt 특성으로 나타나므로 별명 참조에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63972382ca72bfae9a1039f20443d3527d3f328d" translate="yes" xml:space="preserve">
          <source>When in Running state, &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; also emits the &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt;() signal when the frame changes.</source>
          <target state="translated">Running 상태 일 때 &lt;a href=&quot;qtimeline&quot;&gt;QTimeLine&lt;/a&gt; 은 프레임이 변경 될 때 &lt;a href=&quot;qtimeline#frameChanged&quot;&gt;frameChanged&lt;/a&gt; () 신호 도 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="ef3e888a5ecf29cb8462a72debc447a17e27543a" translate="yes" xml:space="preserve">
          <source>When in StrictMode, if a parsing error is found, &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt;() will return &lt;code&gt;false&lt;/code&gt; and &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt;() will return a message describing the error. If more than one error is detected, it is undefined which error gets reported.</source>
          <target state="translated">StrictMode에있을 때 구문 분석 오류가 발견되면 &lt;a href=&quot;qurl#isValid&quot;&gt;isValid&lt;/a&gt; ()는 &lt;code&gt;false&lt;/code&gt; 를 반환 하고 &lt;a href=&quot;qurl#errorString&quot;&gt;errorString&lt;/a&gt; ()은 오류를 설명하는 메시지를 반환합니다. 둘 이상의 오류가 감지되면 어떤 오류가보고되는지 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3456c56afa83ec7dbd61d985f62e50c29f6549e1" translate="yes" xml:space="preserve">
          <source>When in keyboard-interactive mode, you can use the arrow and page keys to either move or resize the window. This property controls the arrow keys. The common way to enter keyboard interactive mode is to enter the subwindow menu, and select either &quot;resize&quot; or &quot;move&quot;.</source>
          <target state="translated">키보드 대화 형 모드에서 화살표 및 페이지 키를 사용하여 창을 이동하거나 크기를 조정할 수 있습니다. 이 속성은 화살표 키를 제어합니다. 키보드 대화식 모드로 들어가는 일반적인 방법은 하위 창 메뉴로 들어가서 &quot;크기 조정&quot;또는 &quot;이동&quot;을 선택하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3fb322ebc9c9cd2d657c0fb9d224a6635a538d7d" translate="yes" xml:space="preserve">
          <source>When in keyboard-interactive mode, you can use the arrow and page keys to either move or resize the window. This property controls the page keys. The common way to enter keyboard interactive mode is to enter the subwindow menu, and select either &quot;resize&quot; or &quot;move&quot;.</source>
          <target state="translated">키보드 대화 형 모드에서 화살표 및 페이지 키를 사용하여 창을 이동하거나 크기를 조정할 수 있습니다. 이 속성은 페이지 키를 제어합니다. 키보드 대화식 모드로 들어가는 일반적인 방법은 하위 창 메뉴로 들어가서 &quot;크기 조정&quot;또는 &quot;이동&quot;을 선택하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2c08753db2a8aa137364ee7093529568335fe121" translate="yes" xml:space="preserve">
          <source>When inheriting &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt;, you need to do the following:</source>
          <target state="translated">&lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea를&lt;/a&gt; 상속 할 때 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef5ec1307e1565c3ba533b6306e4c4fb6e84f432" translate="yes" xml:space="preserve">
          <source>When inserting action items you usually specify a receiver and a slot. The receiver will be notifed whenever the item is &lt;a href=&quot;qaction#triggered&quot;&gt;triggered()&lt;/a&gt;. In addition, &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; provides two signals, &lt;a href=&quot;qmenu#triggered&quot;&gt;triggered&lt;/a&gt;() and &lt;a href=&quot;qmenu#hovered&quot;&gt;hovered&lt;/a&gt;(), which signal the &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; that was triggered from the menu.</source>
          <target state="translated">동작 항목을 삽입 할 때 일반적으로 수신기와 슬롯을 지정합니다. 항목이 &lt;a href=&quot;qaction#triggered&quot;&gt;트리거&lt;/a&gt; 될 때마다 수신자에게 통지됩니다 () . 또한 &lt;a href=&quot;qmenu&quot;&gt;QMenu를이&lt;/a&gt; 두 신호 제공 &lt;a href=&quot;qmenu#triggered&quot;&gt;트리거&lt;/a&gt; () 및 &lt;a href=&quot;qmenu#hovered&quot;&gt;맴돌고&lt;/a&gt; 신호 () &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; 메뉴에서 유발 하였다.</target>
        </trans-unit>
        <trans-unit id="864005fb46a1674119933552576b5eb471667e9c" translate="yes" xml:space="preserve">
          <source>When inserting multiple records, you only need to call &lt;a href=&quot;qsqlquery#prepare&quot;&gt;QSqlQuery::prepare&lt;/a&gt;() once. Then you call &lt;a href=&quot;qsqlquery#bindValue&quot;&gt;bindValue()&lt;/a&gt; or &lt;a href=&quot;qsqlquery#addBindValue&quot;&gt;addBindValue()&lt;/a&gt; followed by &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec()&lt;/a&gt; as many times as necessary.</source>
          <target state="translated">여러 레코드를 삽입 할 때는 &lt;a href=&quot;qsqlquery#prepare&quot;&gt;QSqlQuery :: prepare&lt;/a&gt; ()를 한 번만 호출 하면됩니다. 그런 다음 &lt;a href=&quot;qsqlquery#bindValue&quot;&gt;bindValue ()&lt;/a&gt; 또는 &lt;a href=&quot;qsqlquery#addBindValue&quot;&gt;addBindValue ()&lt;/a&gt; 와 &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec ()&lt;/a&gt; 를 필요한 횟수만큼 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="f4a6a2c17602b8ef1614b658343d290c1bd56516" translate="yes" xml:space="preserve">
          <source>When inserting such a fragment into a &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; the current char format of the &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; used for insertion is used as format for the text.</source>
          <target state="translated">(A) 내로 이러한 단편을 삽입 할 때 &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; 의 현재 문자 형식 &lt;a href=&quot;qtextcursor&quot;&gt;QTextCursor&lt;/a&gt; 삽입 사용이 텍스트 형식으로 사용된다.</target>
        </trans-unit>
        <trans-unit id="6ee49651f87fc18143f2662752cc1cf4e9cb8b10" translate="yes" xml:space="preserve">
          <source>When integrating existing classes and technology into QML, APIs will often need tweaking to fit better into the declarative environment. Although the best results are usually obtained by modifying the original classes directly, if this is either not possible or is complicated by some other concerns, extension objects allow limited extension possibilities without direct modifications.</source>
          <target state="translated">기존 클래스와 기술을 QML에 통합 할 때 선언 환경에 더 잘 맞도록 API를 조정해야하는 경우가 종종 있습니다. 일반적으로 원래 클래스를 직접 수정하여 최상의 결과를 얻을 수 있지만 이것이 불가능하거나 다른 문제로 인해 복잡 할 경우 확장 개체는 직접 수정하지 않고도 확장 가능성을 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46cd534349e4b4409b3a901102a23c1cbd1d64c6" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;color&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; 값 은 자동으로 &lt;code&gt;color&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="94f4f40b3918cac601587862fbf8acc3e95d325a" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; or &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;date&lt;/code&gt; value, and vice-versa. Note, however, that converting a &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; will result in UTC's start of the day, which falls on a different date in some other time-zones. It is usually more robust to convert the &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; via a &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; explicitly, specifying local-time or a relevant time-zone and selecting a time of day (such as noon) that reliably exists (daylight-savings transitions skip an hour, near one end or the other of a day).</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 또는 &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; 값 은 자동으로 &lt;code&gt;date&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다. 그러나 &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 를 변환하면 UTC가 시작되어 다른 시간대의 다른 날짜로 표시됩니다. 일반적으로 현지 시간 또는 관련 시간대를 지정하고 안정적으로 존재하는 시간 (정오와 같은)을 선택하여 (일광 절약 전환이 한 쪽 끝에서 한 시간 건너 뛰기) &lt;a href=&quot;qdate&quot;&gt;QDateTime을&lt;/a&gt; 통해 &lt;a href=&quot;qdatetime&quot;&gt;QDate를&lt;/a&gt; 명시 적으로 변환하는 것이 더 강력 합니다. 또는 다른 날).</target>
        </trans-unit>
        <trans-unit id="2a3e9ea44f85bb16e221814f180ac27358c1f643" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;font&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; 값 은 자동으로 &lt;code&gt;font&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="c80b7cd162c43b0104ef58b6d7d770bb2b3dc0c9" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;geocircle&lt;/code&gt; value, and vise-versa.</source>
          <target state="translated">C ++과 통합 할 때 C ++에서 QML로 전달 된 &lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle&lt;/a&gt; 값은 자동으로 &lt;code&gt;geocircle&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="f90dc519be0e60fb444dc1c5260f47cc6cd907ee" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;coordinate&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 QML로 전달 된 &lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate&lt;/a&gt; 값은 자동으로 &lt;code&gt;coordinate&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="c5bbf6333d877f577a96dba2b55b5c884f293ae5" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeopath&quot;&gt;QGeoPath&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;geopath&lt;/code&gt; value, and vice versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 QML로 전달 된 &lt;a href=&quot;qgeopath&quot;&gt;QGeoPath&lt;/a&gt; 값은 자동으로 &lt;code&gt;geopath&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="fc4029c75e55b88c42d4329274584c8e9c0128eb" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeopolygon&quot;&gt;QGeoPolygon&lt;/a&gt; value passed into QML is automatically converted into a &lt;code&gt;geopolygon&lt;/code&gt;, and vice versa.</source>
          <target state="translated">C ++와 통합 할 때 QML로 전달 된 &lt;a href=&quot;qgeopolygon&quot;&gt;QGeoPolygon&lt;/a&gt; 값은 자동으로 &lt;code&gt;geopolygon&lt;/code&gt; 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="a7dba58612710895f3116ae91ec3e71bc80778eb" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeorectangle&quot;&gt;QGeoRectangle&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;georectangle&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 QML로 전달 된 &lt;a href=&quot;qgeorectangle&quot;&gt;QGeoRectangle&lt;/a&gt; 값은 자동으로 &lt;code&gt;georectangle&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="4d5c3d73097853ceb2db3f5a71a11d6fad5cb8d2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qgeoshape&quot;&gt;QGeoShape&lt;/a&gt; value passed into QML from C++ is automatically converted into a &lt;code&gt;geoshape&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 QML로 전달 된 &lt;a href=&quot;qgeoshape&quot;&gt;QGeoShape&lt;/a&gt; 값은 자동으로 &lt;code&gt;geoshape&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="06f6b135e98805bdd8065da59a778cd9f4c5215e" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; or &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;point&lt;/code&gt; value. When a &lt;code&gt;point&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; value.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qpoint&quot;&gt;QPoint&lt;/a&gt; 또는 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; 값 은 자동으로 &lt;code&gt;point&lt;/code&gt; 값 으로 변환됩니다 . &lt;code&gt;point&lt;/code&gt; 값이 C ++로 전달 되면 자동으로 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; 값 으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="4537d2f61ed5eb33aa48c28e4d1f2cbe5739fee6" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;list&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt; 값 은 자동으로 &lt;code&gt;list&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="bde76fc240f3c1a3b45734a6b9372df275b0771e" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; or &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;rect&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;rect&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; value.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 또는 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 값 은 자동으로 &lt;code&gt;rect&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다. &lt;code&gt;rect&lt;/code&gt; 값이 C ++에 전달 되면 자동으로 &lt;a href=&quot;qrectf&quot;&gt;QRectF&lt;/a&gt; 값 으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="efe91bec14c646d63c8cb49b132911ca4fb70cf2" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; or &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;size&lt;/code&gt; value, and vice-versa. When a &lt;code&gt;size&lt;/code&gt; value is passed to C++, it is automatically converted into a &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; value.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; 또는 &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; 값 은 자동으로 &lt;code&gt;size&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다. &lt;code&gt;size&lt;/code&gt; 값이 C ++로 전달 되면 자동으로 &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; 값 으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="7fd4e1a3e2c35dda93f104508cebf19c9ae03217" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;string&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 값 은 자동으로 &lt;code&gt;string&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="b5784d74b9c118ae7229636ff92faf312a5dfe71" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;url&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 값 은 자동으로 &lt;code&gt;url&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="4782c07688335b98c18e7337dd4cb33a506d5caa" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;variant&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 값 은 자동으로 &lt;code&gt;variant&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="0f08c295ab9d317506d3417a8c5ed2ce92dffe9c" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt; value &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into a &lt;code&gt;vector3d&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C ++와 통합 할 때 C ++에서 &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;QML로 전달 된 &lt;/a&gt;&lt;a href=&quot;qvector3d&quot;&gt;QVector3D&lt;/a&gt; 값 은 자동으로 &lt;code&gt;vector3d&lt;/code&gt; 값 으로 변환되며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="174229e59467abdea54b7e746d86e6764e7d6c9d" translate="yes" xml:space="preserve">
          <source>When integrating with C++, note that any &lt;code&gt;enum&lt;/code&gt; value &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;passed into QML from C++&lt;/a&gt; is automatically converted into an &lt;code&gt;enumeration&lt;/code&gt; value, and vice-versa.</source>
          <target state="translated">C와 통합 할 때 ++, 기록이있는 것을 &lt;code&gt;enum&lt;/code&gt; 값 &lt;a href=&quot;qtqml-cppintegration-data#&quot;&gt;C ++에서 QML로 전달이&lt;/a&gt; 자동으로 변환됩니다 &lt;code&gt;enumeration&lt;/code&gt; 값, 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="f7482e71bbdd52848ddeffbe95fcd0b8e2b5663e" translate="yes" xml:space="preserve">
          <source>When interacted with a mouse device, flicking is disabled and the scroll bars are interactive.</source>
          <target state="translated">마우스 장치와 상호 작용할 때 깜박임이 비활성화되고 스크롤 막대가 대화 형입니다.</target>
        </trans-unit>
        <trans-unit id="8777d7fa43f475169d9e2b3537e4248eaedbf1d8" translate="yes" xml:space="preserve">
          <source>When intermixing &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; and OpenGL, it is important to notify &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; that the OpenGL state may have been cluttered so it can restore its internal state. This is achieved by calling &lt;a href=&quot;qpainter#beginNativePainting&quot;&gt;QPainter::beginNativePainting&lt;/a&gt;() before starting the OpenGL rendering and calling &lt;a href=&quot;qpainter#endNativePainting&quot;&gt;QPainter::endNativePainting&lt;/a&gt;() after finishing.</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 와 OpenGL을 혼합 할 때 OpenGL 상태가 어수선 해 내부 상태를 복원 할 수 있음을 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 에 알리는 것이 중요합니다 . 이 호출에 의해 달성된다 &lt;a href=&quot;qpainter#beginNativePainting&quot;&gt;QPainter를 :: beginNativePainting을&lt;/a&gt; OpenGL을 렌더링을 시작하고 호출하기 전에 () &lt;a href=&quot;qpainter#endNativePainting&quot;&gt;QPainter를을 :: endNativePainting&lt;/a&gt; 마무리 한 후 ().</target>
        </trans-unit>
        <trans-unit id="19950d97cb8c934f1e5c65f401298cb13bebd643" translate="yes" xml:space="preserve">
          <source>When invoking one of these options, or when an error happens (for instance an unknown option was passed), the current process will then stop, using the exit() function.</source>
          <target state="translated">이러한 옵션 중 하나를 호출하거나 오류 (예 : 알 수없는 옵션이 전달 된 경우)가 발생하면 exit () 함수를 사용하여 현재 프로세스가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="071c0d6d52ee604f468daeb0ab63c0a2099e201d" translate="yes" xml:space="preserve">
          <source>When it comes to more complex controls, it is sometimes better to split them up into separate building blocks. As an example, the complex &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt; control:</source>
          <target state="translated">더 복잡한 컨트롤에 관해서는, 때로는 별도의 빌딩 블록으로 나누는 것이 좋습니다. 예를 들어 복잡한 &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt; 컨트롤은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e8c72fd29bc00795105647d117aa1d234784718" translate="yes" xml:space="preserve">
          <source>When it comes to rendering, deferred rendering is a different beast in terms of renderer configuration compared to forward rendering. Instead of drawing each mesh and applying a shader effect to shade it, deferred rendering adopts a</source>
          <target state="translated">렌더링의 경우 지연 렌더링은 정방향 렌더링과 비교하여 렌더러 구성 측면에서 다른 짐승입니다. 각 메시를 그리고 셰이더 효과를 적용하여 음영 처리하는 대신 지연 렌더링은</target>
        </trans-unit>
        <trans-unit id="626ed890d480d0a4b856052f27b67e8d0b322b1a" translate="yes" xml:space="preserve">
          <source>When it comes to texture support, the &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; value should be set to the appropriate &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; subclass that matches the sampler type of the shader uniform.</source>
          <target state="translated">텍스처 지원과 관련하여 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; 값은 쉐이더 유니폼의 샘플러 유형과 일치하는 적절한 &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;QAbstractTexture&lt;/a&gt; 서브 클래스 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5979b40af94b30c33380148b42cb7fe798d86843" translate="yes" xml:space="preserve">
          <source>When it comes to texture support, the Parameter value should be set to the appropriate &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;texture&lt;/a&gt; subclass that matches the sampler type of the shader uniform.</source>
          <target state="translated">텍스처 지원과 관련하여 Parameter 값은 쉐이더 유니폼의 샘플러 유형과 일치하는 적절한 &lt;a href=&quot;qt3drender-qabstracttexture&quot;&gt;텍스처&lt;/a&gt; 서브 클래스 로 설정되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ac390c6893275dbab12f259c5a78a8285bc68bc5" translate="yes" xml:space="preserve">
          <source>When it does not call &lt;a href=&quot;qstyle&quot;&gt;QStyle&lt;/a&gt;, Shape interacts with &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;QFrame::Shadow&lt;/a&gt;, the &lt;a href=&quot;qframe#lineWidth-prop&quot;&gt;lineWidth&lt;/a&gt;() and the &lt;a href=&quot;qframe#midLineWidth-prop&quot;&gt;midLineWidth&lt;/a&gt;() to create the total result. See the picture of the frames in the main class documentation.</source>
          <target state="translated">&lt;a href=&quot;qstyle&quot;&gt;QStyle을&lt;/a&gt; 호출하지 않으면 Shape는 &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;QFrame :: Shadow&lt;/a&gt; , &lt;a href=&quot;qframe#lineWidth-prop&quot;&gt;lineWidth&lt;/a&gt; () 및 &lt;a href=&quot;qframe#midLineWidth-prop&quot;&gt;midLineWidth&lt;/a&gt; () 와 상호 작용 하여 총 결과를 만듭니다. 메인 클래스 문서의 프레임 그림을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4261303376e29e827bb3d9ad715c1736160cb00b" translate="yes" xml:space="preserve">
          <source>When it is necessary to reimplement the &lt;a href=&quot;qaccessibleinterface#child&quot;&gt;QAccessibleInterface::child&lt;/a&gt;() function and returning the child after constructing it, this function needs to be called.</source>
          <target state="translated">&lt;a href=&quot;qaccessibleinterface#child&quot;&gt;QAccessibleInterface :: child&lt;/a&gt; () 함수 를 다시 구현하고 생성 후 자식을 리턴해야하는 경우이 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="638905df9b46e03441949d29b36f66dcb7394603" translate="yes" xml:space="preserve">
          <source>When items of data are exported from a model in a drag and drop operation, they are encoded into an appropriate format corresponding to one or more MIME types. Models declare the MIME types that they can use to supply items by reimplementing the &lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel::mimeTypes&lt;/a&gt;() function, returning a list of standard MIME types.</source>
          <target state="translated">끌어서 놓기 조작으로 모델에서 데이터 항목을 내 보내면 하나 이상의 MIME 유형에 해당하는 적절한 형식으로 인코딩됩니다. 모델은 &lt;a href=&quot;qabstractitemmodel#mimeTypes&quot;&gt;QAbstractItemModel :: mimeTypes&lt;/a&gt; () 함수 를 다시 구현하여 표준 MIME 유형 목록을 반환하여 항목을 제공하는 데 사용할 수있는 MIME 유형을 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="3d596a81dc328e917e2efe8c14460f7b21b5e36e" translate="yes" xml:space="preserve">
          <source>When iterating from 0 and up, it will return the items in the visual arranged order.</source>
          <target state="translated">0 이상에서 반복하면 항목이 시각적으로 정렬 된 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f808486c7714b611743ef8e1139711cba9bfa51a" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the items are arbitrarily ordered. With &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the items are always sorted by key.</source>
          <target state="translated">&lt;a href=&quot;qhash#qhash&quot;&gt;QHash를&lt;/a&gt; 반복 하면 항목이 임의로 주문됩니다. 로 &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; , 항목은 항상 핵심으로 분류되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8708ebbe834470a66afd3e678569b47f4a25996" translate="yes" xml:space="preserve">
          <source>When iterating over a &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;, the items are always sorted by key. With &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;, the items are arbitrarily ordered.</source>
          <target state="translated">&lt;a href=&quot;qmap&quot;&gt;QMap을&lt;/a&gt; 반복 할 때 항목은 항상 키별로 정렬됩니다. 로 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; , 항목 임의로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="9a98982cb360d3887455667bec14b4371ac7fe09" translate="yes" xml:space="preserve">
          <source>When kerning is enabled, glyph metrics do not add up anymore, even for Latin text. In other words, the assumption that width('a') + width('b') is equal to width(&quot;ab&quot;) is not neccesairly true.</source>
          <target state="translated">커닝이 활성화되면 라틴 텍스트의 경우에도 글리프 메트릭이 더 이상 추가되지 않습니다. 즉, width ( 'a') + width ( 'b')가 width ( &quot;ab&quot;)와 같다는 가정은 절대적으로 사실이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c7c90cd5b86c3de4a86dbc5bca9301f0623600e2" translate="yes" xml:space="preserve">
          <source>When kerning is enabled, glyph metrics do not add up anymore, even for Latin text. In other words, the assumption that width('a') + width('b') is equal to width(&quot;ab&quot;) is not necessarily true.</source>
          <target state="translated">커닝이 활성화되면 라틴 텍스트의 경우에도 글리프 메트릭이 더 이상 추가되지 않습니다. 다시 말해, width ( 'a') + width ( 'b')가 width ( &quot;ab&quot;)와 같다는 가정이 반드시 참인 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4935f0a00031f4e75a93ae9dcce7afc6159f9c52" translate="yes" xml:space="preserve">
          <source>When leaving &quot;What's This?&quot; mode, a &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; of type Qt::LeaveWhatsThisMode is sent to all toplevel widgets.</source>
          <target state="translated">&quot;무엇입니까?&quot;를 떠날 때 모드는하는 &lt;a href=&quot;qevent&quot;&gt;QEvent&lt;/a&gt; 유형 Qt는 :: LeaveWhatsThisMode의 모든 최상위 위젯으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="68c47022708d018c6f6b21000a13611ed6e90869" translate="yes" xml:space="preserve">
          <source>When linking a library, qmake relies on the underlying platform to know what other libraries this library links against. However, if linking statically, qmake will not get this information unless we use the following &lt;code&gt;CONFIG&lt;/code&gt; options:</source>
          <target state="translated">라이브러리를 링크 할 때 qmake는 기본 플랫폼을 사용하여이 라이브러리가 링크하는 다른 라이브러리를 확인합니다. 그러나 정적으로 링크하는 경우 qmake는 다음 &lt;code&gt;CONFIG&lt;/code&gt; 옵션을 사용하지 않으면이 정보를 얻지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="a540dbd6e20238800d7ddd333a082e8843bed862" translate="yes" xml:space="preserve">
          <source>When listening for connections, the address and port on which the server is listening are available as &lt;a href=&quot;qtcpserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt;() and &lt;a href=&quot;qtcpserver#serverPort&quot;&gt;serverPort&lt;/a&gt;().</source>
          <target state="translated">연결을 청취 할 때 서버가 청취하는 주소 및 포트는 &lt;a href=&quot;qtcpserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt; () 및 &lt;a href=&quot;qtcpserver#serverPort&quot;&gt;serverPort&lt;/a&gt; ()로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e0c7db0652d32fbb04e043b9bb98640d9fdf9268" translate="yes" xml:space="preserve">
          <source>When listening for connections, the address and port on which the server is listening are available as &lt;a href=&quot;qwebsocketserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt;() and &lt;a href=&quot;qwebsocketserver#serverPort&quot;&gt;serverPort&lt;/a&gt;().</source>
          <target state="translated">연결을 청취 할 때 서버가 청취하는 주소 및 포트는 &lt;a href=&quot;qwebsocketserver#serverAddress&quot;&gt;serverAddress&lt;/a&gt; () 및 &lt;a href=&quot;qwebsocketserver#serverPort&quot;&gt;serverPort&lt;/a&gt; ()로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="31ca6375539521ce018e40aba55ef1cfd8ac0a7b" translate="yes" xml:space="preserve">
          <source>When listening for connections, the name which the server is listening on is available through &lt;a href=&quot;qlocalserver#serverName&quot;&gt;serverName&lt;/a&gt;().</source>
          <target state="translated">연결을 청취 할 때 서버가 청취중인 이름은 &lt;a href=&quot;qlocalserver#serverName&quot;&gt;serverName&lt;/a&gt; ()을 통해 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="f562b333fc7588768d7b731fad5e57e2bf351983" translate="yes" xml:space="preserve">
          <source>When loading a QML object into a C++ application, it can be useful to directly embed some C++ data that can be used from within the QML code. This makes it possible, for example, to invoke a C++ method on the embedded object, or use a C++ object instance as a data model for a QML view.</source>
          <target state="translated">QML 오브젝트를 C ++ 애플리케이션으로로드 할 때 QML 코드 내에서 사용할 수있는 일부 C ++ 데이터를 직접 임베드하는 것이 유용 할 수 있습니다. 예를 들어 임베디드 오브젝트에서 C ++ 메소드를 호출하거나 C ++ 오브젝트 인스턴스를 QML보기의 데이터 모델로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5937553b7180f604506425e217e2f3d3eb8c1b4d" translate="yes" xml:space="preserve">
          <source>When loading the library, &lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; searches in all system-specific library locations (for example, &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; on Unix), unless the file name has an absolute path. After loading the library successfully, fileName() returns the fully-qualified file name of the library, including the full path to the library if one was given in the constructor or passed to setFileName().</source>
          <target state="translated">라이브러리를로드 할 때 &lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; 는 파일 이름에 절대 경로가 없으면 모든 시스템 별 라이브러리 위치 (예 : Unix의 &lt;code&gt;LD_LIBRARY_PATH&lt;/code&gt; )를 검색합니다. 라이브러리를 성공적으로로드 한 후, fileName ()은 라이브러리에 대한 전체 경로를 포함하여 라이브러리에 대한 완전한 파일 이름을 포함하여 라이브러리의 완전한 파일 이름을 리턴합니다 (파일이 setFileName ()에 전달 된 경우).</target>
        </trans-unit>
        <trans-unit id="07f1533b7f9a425f6f190f84dd677e6063996b77" translate="yes" xml:space="preserve">
          <source>When loading the plugin, &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; searches in the current directory and in all plugin locations specified by &lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication::libraryPaths&lt;/a&gt;(), unless the file name has an absolute path. After loading the plugin successfully, fileName() returns the fully-qualified file name of the plugin, including the full path to the plugin if one was given in the constructor or passed to setFileName().</source>
          <target state="translated">플러그인을로드 할 때 &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; 는 파일 이름에 절대 경로가 없으면 현재 디렉토리 및 &lt;a href=&quot;qcoreapplication#libraryPaths&quot;&gt;QCoreApplication :: libraryPaths&lt;/a&gt; ()로 지정된 모든 플러그인 위치에서 검색 합니다. 플러그인을 성공적으로로드 한 후 fileName ()은 플러그인에 대한 완전한 경로를 포함하여 플러그인의 완전한 파일 이름을 포함하여 플러그인의 완전한 파일 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="fed00e705cb06cd3fa7ef9acd6a2a5b4614acebf" translate="yes" xml:space="preserve">
          <source>When making OpenGL function calls, it is strongly recommended to avoid calling the functions directly. Instead, prefer using &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; (when making portable applications) or the versioned variants (for example, &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt; and similar, when targeting modern, desktop-only OpenGL). This way the application will work correctly in all Qt build configurations, including the ones that perform dynamic OpenGL implementation loading which means applications are not directly linking to an GL implementation and thus direct function calls are not feasible.</source>
          <target state="translated">OpenGL 함수 호출을 수행 할 때는 함수를 직접 호출하지 않는 것이 좋습니다. 대신, &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; (휴대용 응용 프로그램을 작성할 때) 또는 버전 변형 (예 : 최신 데스크탑 전용 OpenGL을 대상으로하는 경우 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions-3-2-core.html&quot;&gt;QOpenGLFunctions_3_2_Core&lt;/a&gt; 등)을 사용하십시오. 이런 식으로 응용 프로그램은 동적 OpenGL 구현 로딩을 수행하는 구성을 포함하여 모든 Qt 빌드 구성에서 올바르게 작동합니다. 즉, 응용 프로그램이 GL 구현에 직접 연결되어 있지 않으므로 직접 함수 호출을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d7812b8e5267196ba2ad8e65b065aaa80e3d29f0" translate="yes" xml:space="preserve">
          <source>When making a context current using &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt;, do not check that the &lt;a href=&quot;qobject#thread-affinity&quot;&gt;QObject thread affinity&lt;/a&gt; of the &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; object is the same thread calling &lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent()&lt;/a&gt;. This value was added in Qt 5.8.</source>
          <target state="translated">&lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext를&lt;/a&gt; 사용하여 컨텍스트를 현재로 만들 때 &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; 객체 의 &lt;a href=&quot;qobject#thread-affinity&quot;&gt;QObject 스레드 선호도&lt;/a&gt; 가 &lt;a href=&quot;qopenglcontext#makeCurrent&quot;&gt;makeCurrent ()를&lt;/a&gt; 호출하는 동일한 스레드 인지 확인하지 마십시오 . 이 값은 Qt 5.8에서 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="3d457ffc5179988c0d911e245311c267b3667157" translate="yes" xml:space="preserve">
          <source>When making the temporary credentials request, the client authenticates using only the client credentials. When making the token request, the client authenticates using the client credentials as well as the temporary credentials. Once the client receives and stores the token credentials, it can proceed to access protected resources on behalf of the resource owner by making authenticated requests using the client credentials together with the token credentials received.</source>
          <target state="translated">임시 자격 증명 요청을 할 때 클라이언트는 클라이언트 자격 증명 만 사용하여 인증합니다. 토큰 요청을 할 때 클라이언트는 클라이언트 자격 증명과 임시 자격 증명을 사용하여 인증합니다. 클라이언트가 토큰 자격 증명을 수신하고 저장하면 클라이언트 자격 증명과 수신 된 토큰 자격 증명을 사용하여 인증 된 요청을 수행하여 리소스 소유자 대신 보호 된 리소스에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="810316d46e7d600660a66af0e59fa7e02d7433b6" translate="yes" xml:space="preserve">
          <source>When managing dynamically created objects, you must ensure the creation context outlives the created object. Otherwise, if the creation context is destroyed first, the bindings and signal handlers in the dynamic object will no longer work.</source>
          <target state="translated">동적으로 생성 된 객체를 관리 할 때는 생성 컨텍스트가 생성 된 객체보다 오래 지속되도록해야합니다. 그렇지 않으면 생성 컨텍스트가 먼저 파괴되면 동적 객체의 바인딩 및 신호 처리기가 더 이상 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b19286d402c202adf58ff1b66a30b97e15b4a785" translate="yes" xml:space="preserve">
          <source>When manipulating selections, it is often helpful to think of &lt;a href=&quot;qitemselectionmodel&quot;&gt;QItemSelectionModel&lt;/a&gt; as a record of the selection state of all the items in an item model. Once a selection model is set up, collections of items can be selected, deselected, or their selection states can be toggled without the need to know which items are already selected. The indexes of all selected items can be retrieved at any time, and other components can be informed of changes to the selection model via the signals and slots mechanism.</source>
          <target state="translated">선택을 조작 할 때 &lt;a href=&quot;qitemselectionmodel&quot;&gt;QItemSelectionModel&lt;/a&gt; 을 항목 모델에있는 모든 항목의 선택 상태 레코드로 생각하면 도움이됩니다 . 선택 모델이 설정되면 어떤 항목이 이미 선택되어 있는지 알 필요없이 항목 모음을 선택하거나 선택 해제하거나 선택 상태를 전환 할 수 있습니다. 선택한 모든 항목의 색인을 언제든지 검색 할 수 있으며 신호 및 슬롯 메커니즘을 통해 다른 구성 요소에 선택 모델의 변경 사항을 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fe612b6914bd28d3a91c181ce17418b66edda3f" translate="yes" xml:space="preserve">
          <source>When mirroring the layout using either the attached property &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring::enabled&lt;/a&gt; or by setting the &lt;a href=&quot;qml-qtquick-grid#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt;, the horizontal alignment of items will be mirrored as well. However, the property &lt;code&gt;horizontalItemAlignment&lt;/code&gt; will remain unchanged. To query the effective horizontal alignment of items, use the read-only property &lt;code&gt;effectiveHorizontalItemAlignment&lt;/code&gt;.</source>
          <target state="translated">연결된 속성 &lt;a href=&quot;qml-qtquick-layoutmirroring#enabled-prop&quot;&gt;LayoutMirroring :: enabled를 사용&lt;/a&gt; 하거나 &lt;a href=&quot;qml-qtquick-grid#layoutDirection-prop&quot;&gt;layoutDirection&lt;/a&gt; 을 설정 하여 레이아웃을 미러링 할 때 항목의 가로 정렬도 미러링됩니다. 그러나 &lt;code&gt;horizontalItemAlignment&lt;/code&gt; 속성 은 변경되지 않습니다. 항목의 효과적인 가로 정렬을 쿼리하려면 읽기 전용 속성 인 &lt;code&gt;effectiveHorizontalItemAlignment&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b20aa7e6cd799e3bf7fad3e47e4d5468b0303506" translate="yes" xml:space="preserve">
          <source>When multiple QOpenGLWidgets are added as children to the same top-level widget, their contexts will share with each other. This does not apply for &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; instances that belong to different windows.</source>
          <target state="translated">여러 개의 QOpenGLWidget이 동일한 최상위 레벨 위젯에 하위로 추가되면 해당 컨텍스트가 서로 공유됩니다. 다른 창에 속하는 &lt;a href=&quot;qopenglwidget&quot;&gt;QOpenGLWidget&lt;/a&gt; 인스턴스 에는 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="be71f48901e09c1cafec1c8d3da6f3f42996e8be" translate="yes" xml:space="preserve">
          <source>When multiple render targets are in use,</source>
          <target state="translated">여러 렌더 타겟이 사용중인 경우</target>
        </trans-unit>
        <trans-unit id="cca7faed1dcf3acb3787eb6ed52f3e078b4e846e" translate="yes" xml:space="preserve">
          <source>When multiple selectors could be applied to the same file, the first matching selector is chosen. The order selectors are checked in are:</source>
          <target state="translated">여러 개의 선택기를 동일한 파일에 적용 할 수 있으면 첫 번째 일치하는 선택기가 선택됩니다. 체크인 된 주문 선택기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a2d60a792f80124c96dcd07ddb164770dfe0ca59" translate="yes" xml:space="preserve">
          <source>When multiple series are added to a graph, selecting an item in one of them will clear the selection on other series.</source>
          <target state="translated">그래프에 여러 계열이 추가되면 그 중 하나에서 항목을 선택하면 다른 계열의 선택이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="b98c31c0b36eccbc7c80561d52175a75bcc24aef" translate="yes" xml:space="preserve">
          <source>When multiple textures are attached, the return value is the ID of the first one.</source>
          <target state="translated">여러 텍스처가 연결되면 반환 값은 첫 번째 텍스처의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="5ea247c1f56cf273fe99668ba49d31b1b499bfbe" translate="yes" xml:space="preserve">
          <source>When multisample antialiasing is used, content rendered into framebuffer objects need additional extensions to support multisampling of framebuffers. Typically &lt;code&gt;GL_EXT_framebuffer_multisample&lt;/code&gt; and &lt;code&gt;GL_EXT_framebuffer_blit&lt;/code&gt;. Most desktop chips have these extensions present, but they are less common in embedded chips. When framebuffer multisampling is not available in the hardware, content rendered into framebuffer objects will not be antialiased, including the content of a &lt;a href=&quot;qml-qtquick-shadereffectsource&quot;&gt;ShaderEffectSource&lt;/a&gt;.</source>
          <target state="translated">멀티 샘플 앤티 앨리어싱을 사용하는 경우 프레임 버퍼 객체로 렌더링되는 내용에는 프레임 버퍼의 멀티 샘플링을 지원하기 위해 추가 확장이 필요합니다. 일반적으로 &lt;code&gt;GL_EXT_framebuffer_multisample&lt;/code&gt; 및 &lt;code&gt;GL_EXT_framebuffer_blit&lt;/code&gt; 입니다. 대부분의 데스크탑 칩에는 이러한 확장 기능이 있지만 임베디드 칩에서는 일반적이지 않습니다. 하드웨어에서 프레임 버퍼 멀티 샘플링을 사용할 수없는 경우 &lt;a href=&quot;qml-qtquick-shadereffectsource&quot;&gt;ShaderEffectSource&lt;/a&gt; 의 내용을 포함하여 프레임 버퍼 객체로 렌더링 된 내용은 앤티 앨리어싱되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fccefc8901100b2f82142ca7d8bb3223d24d7501" translate="yes" xml:space="preserve">
          <source>When navigating the document structure, it is useful to begin at the root frame because it provides access to the entire document structure.</source>
          <target state="translated">문서 구조를 탐색 할 때 전체 문서 구조에 대한 액세스를 제공하므로 루트 프레임에서 시작하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3e0a254e08acf9d6be4fd4d7a634988147b26055" translate="yes" xml:space="preserve">
          <source>When nested opacity gets below a certain threshold, the subtree might be marked as blocked, causing &lt;a href=&quot;qsgnode#isSubtreeBlocked&quot;&gt;isSubtreeBlocked&lt;/a&gt;() to return true. This is done for performance reasons.</source>
          <target state="translated">중첩 된 불투명도가 특정 임계 값 아래로 떨어지면 하위 트리가 차단 된 것으로 표시되어 &lt;a href=&quot;qsgnode#isSubtreeBlocked&quot;&gt;isSubtreeBlocked&lt;/a&gt; ()가 true를 반환 할 수 있습니다. 이것은 성능상의 이유로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4d85ccf2069fc6eae18e11975d88bfe1fadc019f" translate="yes" xml:space="preserve">
          <source>When no windowing system is present, the mouse, keyboard and touch input are read directly via &lt;code&gt;evdev&lt;/code&gt;. Note that this requires that devices nodes &lt;code&gt;/input/event*&lt;/code&gt; are readable by the user. eglfs and vxworksfb has all the evdev input handling code built-in.</source>
          <target state="translated">윈도우 시스템이 없으면 마우스, 키보드 및 터치 입력을 &lt;code&gt;evdev&lt;/code&gt; 를 통해 직접 읽습니다 . 이를 위해서는 사용자가 장치 노드 &lt;code&gt;/input/event*&lt;/code&gt; 를 읽을 수 있어야합니다. eglfs 및 vxworksfb에는 모든 evdev 입력 처리 코드가 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b0f164920aba9354f027a11efdb935f7ff22e14" translate="yes" xml:space="preserve">
          <source>When no windowing system is present, the mouse, keyboard, and touch input are read directly via &lt;code&gt;evdev&lt;/code&gt; or using helper libraries such as &lt;code&gt;libinput&lt;/code&gt; or &lt;code&gt;tslib&lt;/code&gt;. Note that this requires that device nodes &lt;code&gt;/dev/input/event*&lt;/code&gt; are readable by the user. &lt;code&gt;eglfs&lt;/code&gt; and &lt;code&gt;linuxfb&lt;/code&gt; have all the input handling code compiled-in.</source>
          <target state="translated">윈도우 시스템이 없으면 마우스, 키보드 및 터치 입력을 &lt;code&gt;evdev&lt;/code&gt; 를 통해 또는 &lt;code&gt;libinput&lt;/code&gt; 또는 &lt;code&gt;tslib&lt;/code&gt; 와 같은 도우미 라이브러리를 사용하여 직접 읽습니다 . 이를 위해서는 사용자가 장치 노드 &lt;code&gt;/dev/input/event*&lt;/code&gt; 를 읽을 수 있어야합니다. &lt;code&gt;eglfs&lt;/code&gt; 와 &lt;code&gt;linuxfb&lt;/code&gt; 에는 모든 입력 처리 코드가 컴파일되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dca5d911ae2265eef32ee4fee8077e25696a9db8" translate="yes" xml:space="preserve">
          <source>When one of the statements is a non-select statement a count of affected rows may be available instead of a result set.</source>
          <target state="translated">명령문 중 하나가 비 선택 명령문 인 경우 결과 세트 대신 영향을받는 행 수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9136aaa0ef09df9e9f07e3241b2a9f838fd494d" translate="yes" xml:space="preserve">
          <source>When operating in deterministic mode, &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; may be used for bulk data generation. In fact, applications that do not need cryptographically-secure or true random data are advised to use a regular &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; instead of &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator::system&lt;/a&gt;() for their random data needs.</source>
          <target state="translated">결정적 모드에서 작동하는 경우 &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; 를 대량 데이터 생성에 사용할 수 있습니다. 실제로 암호화 보안 또는 실제 임의 데이터가 필요없는 애플리케이션은 임의 데이터 요구 에 &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator :: system&lt;/a&gt; () 대신 일반 &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ca0c853a6a3df272210d1c9d0c36c813572cdfe7" translate="yes" xml:space="preserve">
          <source>When operating on managed objects in normal C++ code, a little extra care must be taken because of the CLR's garbage collection. A normal pointer variable should not</source>
          <target state="translated">일반 C ++ 코드로 관리 객체에서 작업 할 때는 CLR의 가비지 수집 때문에 약간의주의가 필요합니다. 일반적인 포인터 변수는</target>
        </trans-unit>
        <trans-unit id="ea7e897063825784978303959c1455b5d44412c2" translate="yes" xml:space="preserve">
          <source>When options can be grouped, you can use a partially checked &lt;a href=&quot;qml-qtquick-controls2-checkbox&quot;&gt;CheckBox&lt;/a&gt; to represent the whole group. Use the checkbox's &lt;a href=&quot;qml-qtquick-controls2-checkbox#checkState-prop&quot;&gt;partially checked state&lt;/a&gt; when a user selects some, but not all, sub-items in the group.</source>
          <target state="translated">옵션을 그룹화 할 수 있으면 부분적으로 선택된 &lt;a href=&quot;qml-qtquick-controls2-checkbox&quot;&gt;CheckBox&lt;/a&gt; 를 사용 하여 전체 그룹을 나타낼 수 있습니다 . 사용자가 그룹의 일부 하위 항목을 선택 하면 확인란의 &lt;a href=&quot;qml-qtquick-controls2-checkbox#checkState-prop&quot;&gt;부분적으로 선택된 상태를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe4c38cfe45b7ff5d5ad3092c911b19539b422d2" translate="yes" xml:space="preserve">
          <source>When painting to a &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice&lt;/a&gt; using &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt;, the state of the current OpenGL context will be altered by the paint engine to reflect its needs. Applications should not rely upon the OpenGL state being reset to its original conditions, particularly the current shader program, OpenGL viewport, texture units, and drawing modes.</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter를&lt;/a&gt; 사용하여 &lt;a href=&quot;qopenglpaintdevice&quot;&gt;QOpenGLPaintDevice에&lt;/a&gt; 페인트 할 때 페인트 엔진에 의해 현재 OpenGL 컨텍스트의 상태가 변경되어 요구를 반영합니다. 응용 프로그램은 OpenGL 상태가 원래 조건, 특히 현재 셰이더 프로그램, OpenGL 뷰포트, 텍스처 단위 및 드로잉 모드로 재설정되는 것에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="8e4b844ee7e4c5be1b0dab1bbe7aaa712b977db0" translate="yes" xml:space="preserve">
          <source>When paused, the current frame can be advanced manually by setting this property or calling &lt;a href=&quot;qml-qtquick-animatedsprite#advance-method&quot;&gt;advance()&lt;/a&gt;.</source>
          <target state="translated">일시 중지되면이 속성을 설정하거나 &lt;a href=&quot;qml-qtquick-animatedsprite#advance-method&quot;&gt;advance ()를&lt;/a&gt; 호출하여 현재 프레임을 수동으로 진행시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36bc00e334ac8aa1eea3755d12934f7608da4dea" translate="yes" xml:space="preserve">
          <source>When paused, the current frame can be advanced manually.</source>
          <target state="translated">일시 정지하면 현재 프레임을 수동으로 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40753593df1bbb77361dbb8a61ae51ec564eb417" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnsmailexchangerecord&quot;&gt;QDnsMailExchangeRecord&lt;/a&gt; instance.</source>
          <target state="translated">서비스에서 조회를 수행 할 때 0 개 이상의 레코드가 리턴됩니다. 각 레코드는 &lt;a href=&quot;qdnsmailexchangerecord&quot;&gt;QDnsMailExchangeRecord&lt;/a&gt; 인스턴스로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="745159504ea8964595662dfda6ea6803520cab14" translate="yes" xml:space="preserve">
          <source>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnsservicerecord&quot;&gt;QDnsServiceRecord&lt;/a&gt; instance.</source>
          <target state="translated">서비스에서 조회를 수행 할 때 0 개 이상의 레코드가 리턴됩니다. 각 레코드는 &lt;a href=&quot;qdnsservicerecord&quot;&gt;QDnsServiceRecord&lt;/a&gt; 인스턴스로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="89b6dd291204471e81a34c81e897e2eae987238a" translate="yes" xml:space="preserve">
          <source>When performing a name server lookup, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnsdomainnamerecord&quot;&gt;QDnsDomainNameRecord&lt;/a&gt; instance.</source>
          <target state="translated">이름 서버 조회를 수행 할 때 0 개 이상의 레코드가 리턴됩니다. 각 레코드는 &lt;a href=&quot;qdnsdomainnamerecord&quot;&gt;QDnsDomainNameRecord&lt;/a&gt; 인스턴스로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3612e920959430b2f4633a7ed7ecb7c74231f462" translate="yes" xml:space="preserve">
          <source>When performing a text lookup, zero or more records will be returned. Each record is represented by a &lt;a href=&quot;qdnstextrecord&quot;&gt;QDnsTextRecord&lt;/a&gt; instance.</source>
          <target state="translated">텍스트 조회를 수행 할 때 0 개 이상의 레코드가 반환됩니다. 각 레코드는 &lt;a href=&quot;qdnstextrecord&quot;&gt;QDnsTextRecord&lt;/a&gt; 인스턴스로 표시됩니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
