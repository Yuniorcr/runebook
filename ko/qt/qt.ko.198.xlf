<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="7b12fa97afcd71c7c1cee885c7d4a1554dce10fc" translate="yes" xml:space="preserve">
          <source>The preferred way to deal with sensor data is via the &lt;a href=&quot;#reading-classes&quot;&gt;Reading Classes&lt;/a&gt;. However, sometimes this may not be possible. For example, you may be deploying an application to a device that has a new sensor type but no C++ header describing the reading class is available.</source>
          <target state="translated">센서 데이터를 다루는 가장 좋은 방법은 &lt;a href=&quot;#reading-classes&quot;&gt;Reading Classes&lt;/a&gt; 를 이용하는 것 입니다. 그러나 때때로 이것이 불가능할 수도 있습니다. 예를 들어, 새로운 센서 유형은 있지만 판독 등급을 설명하는 C ++ 헤더가없는 장치에 응용 프로그램을 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a047478de855593594e5eea7307de97ddcc7281c" translate="yes" xml:space="preserve">
          <source>The preferred way to handle cleanup of graphics resources used in the scene graph, is to rely on the automatic cleanup of nodes. A &lt;a href=&quot;qsgnode&quot;&gt;QSGNode&lt;/a&gt; returned from &lt;a href=&quot;qquickitem#updatePaintNode&quot;&gt;QQuickItem::updatePaintNode&lt;/a&gt;() is automatically deleted on the right thread at the right time. Trees of &lt;a href=&quot;qsgnode&quot;&gt;QSGNode&lt;/a&gt; instances are managed through the use of &lt;a href=&quot;qsgnode#Flag-enum&quot;&gt;QSGNode::OwnedByParent&lt;/a&gt;, which is set by default. So, for the majority of custom scene graph items, no extra work will be required.</source>
          <target state="translated">장면 그래프에 사용 된 그래픽 리소스 정리를 처리하는 기본 방법은 자동 정리 노드에 의존하는 것입니다. &lt;a href=&quot;qsgnode&quot;&gt;QSGNode는&lt;/a&gt; 에서 반환 &lt;a href=&quot;qquickitem#updatePaintNode&quot;&gt;QQuickItem :: updatePaintNode&lt;/a&gt; () 자동으로 적절한시기에 적절한 스레드에서 삭제됩니다. 의 나무 &lt;a href=&quot;qsgnode&quot;&gt;QSGNode의&lt;/a&gt; 인스턴스를 사용하여 관리 &lt;a href=&quot;qsgnode#Flag-enum&quot;&gt;QSGNode :: OwnedByParent&lt;/a&gt; 기본적으로 설정되어 있습니다. 따라서 대부분의 사용자 정의 장면 그래프 항목에는 추가 작업이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db95828b13fdf19e88f4d598e1ebe21025aac0ac" translate="yes" xml:space="preserve">
          <source>The prefix ++ operator (++it) advances the iterator to the next matching item and returns a reference to the resulting iterator. Sets the current pointer to &lt;code&gt;nullptr&lt;/code&gt; if the current item is the last matching item.</source>
          <target state="translated">접두사 ++ 연산자 (++ it)는 반복자를 다음 일치하는 항목으로 진행하고 결과 반복기에 대한 참조를 반환합니다. 현재 항목이 마지막으로 일치하는 항목 인 경우 현재 포인터를 &lt;code&gt;nullptr&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="724098ea183c4a51375791d0dc3505dd8b52de44" translate="yes" xml:space="preserve">
          <source>The prefix ++ operator (&lt;code&gt;++i&lt;/code&gt;) advances the iterator to the next item in the container and returns the iterator.</source>
          <target state="translated">접두사 ++ 연산자 ( &lt;code&gt;++i&lt;/code&gt; )는 반복자를 컨테이너의 다음 항목으로 진행시키고 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3742660eec8ee032ae18e406805426697b40b47" translate="yes" xml:space="preserve">
          <source>The prefix ++ operator (&lt;code&gt;++i&lt;/code&gt;) advances the iterator to the next item in the hash and returns an iterator to the new current item.</source>
          <target state="translated">접두사 ++ 연산자 ( &lt;code&gt;++i&lt;/code&gt; )는 반복자를 해시의 다음 항목으로 진행시키고 반복자를 새 현재 항목으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d935529d64564aaf8455a2d08bba9c416c0da699" translate="yes" xml:space="preserve">
          <source>The prefix ++ operator (&lt;code&gt;++i&lt;/code&gt;) advances the iterator to the next item in the map and returns an iterator to the new current item.</source>
          <target state="translated">접두사 ++ 연산자 ( &lt;code&gt;++i&lt;/code&gt; )는 반복자를 맵의 다음 항목으로 진행시키고 반복자를 새 현재 항목으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dee3dd87c894053f4d4757c0b2c7bc471bfaf45c" translate="yes" xml:space="preserve">
          <source>The prefix ++ operator (&lt;code&gt;++it&lt;/code&gt;) advances the iterator to the next item in the container and returns an iterator to the new current item.</source>
          <target state="translated">접두사 ++ 연산자 ( &lt;code&gt;++it&lt;/code&gt; )는 반복자를 컨테이너의 다음 항목으로 진행시키고 반복자를 새 현재 항목으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bdd1a01bfd01bf5656fdeff0a344a9e3a2cf41b5" translate="yes" xml:space="preserve">
          <source>The prefix ++ operator (&lt;code&gt;++it&lt;/code&gt;) advances the iterator to the next item in the list and returns an iterator to the new current item.</source>
          <target state="translated">접두사 ++ 연산자 ( &lt;code&gt;++it&lt;/code&gt; )는 반복자를 목록의 다음 항목으로 진행시키고 반복자를 새 현재 항목으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="47f5a8bf3d43c8943c7d14b45d083199a8495f54" translate="yes" xml:space="preserve">
          <source>The prefix ++ operator (&lt;code&gt;++it&lt;/code&gt;) advances the iterator to the next item in the set and returns an iterator to the new current item.</source>
          <target state="translated">접두사 ++ 연산자 ( &lt;code&gt;++it&lt;/code&gt; )는 반복자를 세트의 다음 항목으로 진행시키고 반복자를 새 현재 항목으로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3558580d672bcc275882f35eba921c2980b5b0eb" translate="yes" xml:space="preserve">
          <source>The prefix ++ operator (&lt;code&gt;++it&lt;/code&gt;) advances the iterator to the next result in the future and returns an iterator to the new current result.</source>
          <target state="translated">접두사 ++ 연산자 ( &lt;code&gt;++it&lt;/code&gt; )는 나중에 반복자를 다음 결과로 진행시키고 반복자를 새로운 현재 결과로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0f6000fa6c456354984112e31bef4156f6dfd08c" translate="yes" xml:space="preserve">
          <source>The prefix ++ operator, &lt;code&gt;++i&lt;/code&gt;, advances the iterator to the next item in the map and returns this iterator.</source>
          <target state="translated">접두사 ++ 연산자 &lt;code&gt;++i&lt;/code&gt; 는 반복자를 맵의 다음 항목으로 진행시키고이 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bb4b1be8160b56d3e7a361cc7f9139c58e2460e9" translate="yes" xml:space="preserve">
          <source>The prefix ++ operator, &lt;code&gt;++i&lt;/code&gt;, advances the iterator to the next item in the object and returns an iterator to the new current item.</source>
          <target state="translated">접두사 ++ 연산자 &lt;code&gt;++i&lt;/code&gt; 는 반복자를 객체의 다음 항목으로 진행시키고 반복자를 새 현재 항목으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b603b3ebd044e44404fdeecf5b2e763fd712c1c" translate="yes" xml:space="preserve">
          <source>The prefix ++ operator, &lt;code&gt;++it&lt;/code&gt;, advances the iterator to the next item in the array and returns an iterator to the new current item.</source>
          <target state="translated">접두사 ++ 연산자 &lt;code&gt;++it&lt;/code&gt; 는 반복자를 배열의 다음 항목으로 진행시키고 반복자를 새 현재 항목으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="04e5e350deaf5d052fd2bc774c49fbd52c2d178d" translate="yes" xml:space="preserve">
          <source>The prefix ++ operator, &lt;code&gt;++it&lt;/code&gt;, advances the iterator to the next item in the array and returns this iterator.</source>
          <target state="translated">접두사 ++ 연산자 &lt;code&gt;++it&lt;/code&gt; 는 반복자를 배열의 다음 항목으로 진행시키고이 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e467daca3f1af5b766b6625ea80f7ca888ff5b9a" translate="yes" xml:space="preserve">
          <source>The prefix -- operator (--it) advances the iterator to the previous matching item and returns a reference to the resulting iterator. Sets the current pointer to &lt;code&gt;nullptr&lt;/code&gt; if the current item is the first matching item.</source>
          <target state="translated">접두사-연산자 (--it)는 반복자를 이전 일치 항목으로 진행하고 결과 반복기에 대한 참조를 반환합니다. 현재 항목이 첫 번째로 일치하는 항목 인 경우 현재 포인터를 &lt;code&gt;nullptr&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="7b155e791cc02ea5b847c5b502028f2e3d3095b8" translate="yes" xml:space="preserve">
          <source>The prefix -- operator (&lt;code&gt;--i&lt;/code&gt;) backs the iterator up to the previous item in the container and returns the iterator.</source>
          <target state="translated">접두사-연산자 ( &lt;code&gt;--i&lt;/code&gt; )는 컨테이너의 이전 항목까지 반복자를 백업하고 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="841a2bfb677d8eb190ce353a9244426d538c1411" translate="yes" xml:space="preserve">
          <source>The prefix -- operator (&lt;code&gt;--i&lt;/code&gt;) makes the preceding item current and returns an iterator pointing to the new current item.</source>
          <target state="translated">접두사-연산자 ( &lt;code&gt;--i&lt;/code&gt; )는 이전 항목을 현재로 만들고 새 현재 항목을 가리키는 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a97b6849ea8b2a1fce87b2cbcda0cb532d5db1f7" translate="yes" xml:space="preserve">
          <source>The prefix -- operator (&lt;code&gt;--it&lt;/code&gt;) makes the preceding item current and returns an iterator to the new current item.</source>
          <target state="translated">접두사-연산자 ( &lt;code&gt;--it&lt;/code&gt; )는 이전 항목을 현재로 만들고 반복자를 새 현재 항목으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9d18cc7e8a0a8ce7027aa4308fa64f3ce647a78b" translate="yes" xml:space="preserve">
          <source>The prefix -- operator (&lt;code&gt;--it&lt;/code&gt;) makes the preceding result current and returns an iterator to the new current result.</source>
          <target state="translated">접두사-연산자 ( &lt;code&gt;--it&lt;/code&gt; )는 선행 결과를 현재로 만들고 반복자를 새 현재 결과로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a6695eae66b64b33fbc08fd468a1cdb1fec87188" translate="yes" xml:space="preserve">
          <source>The prefix -- operator, &lt;code&gt;--i&lt;/code&gt;, makes the preceding item current and returns an iterator pointing to the new current item.</source>
          <target state="translated">접두사-연산자 &lt;code&gt;--i&lt;/code&gt; 는 이전 항목을 현재로 만들고 새 현재 항목을 가리키는 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="31fe28a16d6009676e9f5f5e95a33abf97d17126" translate="yes" xml:space="preserve">
          <source>The prefix -- operator, &lt;code&gt;--i&lt;/code&gt;, makes the preceding item current and returns this iterator.</source>
          <target state="translated">접두사-연산자 &lt;code&gt;--i&lt;/code&gt; 는 이전 항목을 현재로 만들고이 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ab18ace150d0d16c34bc33a98bfb8cdf15c23b7e" translate="yes" xml:space="preserve">
          <source>The prefix -- operator, &lt;code&gt;--it&lt;/code&gt;, makes the preceding item current and returns an iterator to the new current item.</source>
          <target state="translated">접두사-연산자 &lt;code&gt;--it&lt;/code&gt; 는 선행 항목을 현재로 만들고 반복자를 새 현재 항목으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="726f670275a12a2ad6fa4d960c1727ea87cca51f" translate="yes" xml:space="preserve">
          <source>The prefix -- operator, &lt;code&gt;--it&lt;/code&gt;, makes the preceding item current and returns this iterator.</source>
          <target state="translated">접두사-연산자 &lt;code&gt;--it&lt;/code&gt; 는 선행 항목을 현재로 만들고이 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fe683d9fd2019997729fcd49d3ae1cae49a35dea" translate="yes" xml:space="preserve">
          <source>The prefix for the value. I.e &quot;$&quot;</source>
          <target state="translated">값의 접두사입니다. 즉 &quot;$&quot;</target>
        </trans-unit>
        <trans-unit id="f6d6e5b199e585b4a56c85be2cfd312259954f2d" translate="yes" xml:space="preserve">
          <source>The prefix is prepended to the start of the displayed value. Typical use is to display a unit of measurement or a currency symbol. For example:</source>
          <target state="translated">접두사는 표시된 값의 시작 부분 앞에 추가됩니다. 일반적으로 측정 단위 또는 통화 기호를 표시합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="835fa2185ab1eb6cd3b451ae5a0820dd5e720cb6" translate="yes" xml:space="preserve">
          <source>The presence of a NOTIFY signal does incur a small overhead. There are cases where a property's value is set at object construction time, and does not subsequently change. The most common case of this is when a type uses &lt;a href=&quot;qtqml-syntax-objectattributes#grouped-properties&quot;&gt;Grouped Properties&lt;/a&gt;, and the grouped property object is allocated once, and only freed when the object is deleted. In these cases, the CONSTANT attribute may be added to the property declaration instead of a NOTIFY signal.</source>
          <target state="translated">NOTIFY 신호가 있으면 작은 오버 헤드가 발생합니다. 개체 생성시 속성 값이 설정되고 이후에 변경되지 않는 경우가 있습니다. 가장 일반적인 경우는 유형이 &lt;a href=&quot;qtqml-syntax-objectattributes#grouped-properties&quot;&gt;Grouped Properties를&lt;/a&gt; 사용 하고 그룹화 된 특성 오브젝트가 한 번 할당되고 오브젝트가 삭제 될 때만 해제되는 경우입니다. 이러한 경우, NOTSTY 신호 대신 CONSTANT 속성을 속성 선언에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f793d65d58aec48f96dad6b8902bb31445ad0727" translate="yes" xml:space="preserve">
          <source>The presence of the &lt;code&gt;CONSTANT&lt;/code&gt; attribute indicates that the property value is constant. For a given object instance, the READ method of a constant property must return the same value every time it is called. This constant value may be different for different instances of the object. A constant property cannot have a WRITE method or a NOTIFY signal.</source>
          <target state="translated">의 존재 &lt;code&gt;CONSTANT&lt;/code&gt; 의 특성은 특성 값이 상수임을 나타낸다. 지정된 객체 인스턴스의 경우 상수 속성의 READ 메서드는 호출 될 때마다 동일한 값을 반환해야합니다. 이 상수 값은 객체의 인스턴스마다 다를 수 있습니다. 상수 속성은 WRITE 메서드 또는 NOTIFY 신호를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="62bd5aae5aa02aaebf1c1c20d36c782079324f16" translate="yes" xml:space="preserve">
          <source>The presence of the &lt;code&gt;FINAL&lt;/code&gt; attribute indicates that the property will not be overridden by a derived class. This can be used for performance optimizations in some cases, but is not enforced by moc. Care must be taken never to override a &lt;code&gt;FINAL&lt;/code&gt; property.</source>
          <target state="translated">의 존재 &lt;code&gt;FINAL&lt;/code&gt; 속성은 속성이 파생 클래스에서 재정의 할 수 없습니다 나타냅니다. 경우에 따라 성능 최적화에 사용할 수 있지만 moc에서는 적용되지 않습니다. &lt;code&gt;FINAL&lt;/code&gt; 속성 을 재정의하지 않도록주의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c20bb4159c548fda2f916d5cca55d9791ee4747b" translate="yes" xml:space="preserve">
          <source>The presence or absence of the feature will not affect the planning of the route</source>
          <target state="translated">지형지 물의 존재 유무는 경로 계획에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c32d3c50f22e9ae401e049b5d8432ee73c37a46" translate="yes" xml:space="preserve">
          <source>The presence or absence of the feature will not affect the planning of the route.</source>
          <target state="translated">지형지 물의 존재 유무는 경로 계획에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1dfc17c1112699aebb39ee6c9a201cc1e56bccbf" translate="yes" xml:space="preserve">
          <source>The preset default is &lt;code&gt;0.0f&lt;/code&gt;.</source>
          <target state="translated">사전 설정 기본값은 &lt;code&gt;0.0f&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="962cc481498139edef93eb3eb03930161e027901" translate="yes" xml:space="preserve">
          <source>The pressed position within the &lt;code&gt;parent&lt;/code&gt; Item</source>
          <target state="translated">&lt;code&gt;parent&lt;/code&gt; 항목 내에서 눌린 위치</target>
        </trans-unit>
        <trans-unit id="463f367bce3fb9bb0be862a4d3eab505de26de2d" translate="yes" xml:space="preserve">
          <source>The pressed position within the scene</source>
          <target state="translated">장면 내에서 눌린 위치</target>
        </trans-unit>
        <trans-unit id="e0deb7269c99526616bb7ca538736edbdaa1aa5b" translate="yes" xml:space="preserve">
          <source>The pressed status can only be true if the key is both enabled and active. When the key state becomes pressed, it triggers a key down event for the input engine. A key up event is triggered when the key is released.</source>
          <target state="translated">눌림 상태는 키가 활성화 및 활성화 된 경우에만 참일 수 있습니다. 키 상태가 눌려지면 입력 엔진에 대한 키 다운 이벤트가 트리거됩니다. 키를 놓으면 키 업 이벤트가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="3a994bb3a6374953a75fe37bb7b3281300bc3178" translate="yes" xml:space="preserve">
          <source>The pressure sensor returns atmospheric pressure values in Pascals.</source>
          <target state="translated">압력 센서는 대기압 값을 파스칼로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62e9fda22bd8c9d3ea4af4df9b653d48148f617f" translate="yes" xml:space="preserve">
          <source>The preview shows exactly what the final component will look like when used in an application.</source>
          <target state="translated">미리보기는 애플리케이션에서 사용될 때 최종 구성 요소가 어떻게 보이는지 정확하게 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="286347558e20d7d1715294df8e3410b7350877c4" translate="yes" xml:space="preserve">
          <source>The previous active texture unit will be reset</source>
          <target state="translated">이전 활성 텍스처 유닛이 재설정됩니다</target>
        </trans-unit>
        <trans-unit id="62db34215ce585d6e203c074e52098114b68a430" translate="yes" xml:space="preserve">
          <source>The previous active texture unit will not be rest</source>
          <target state="translated">이전 활성 텍스처 유닛은 휴식하지 않습니다</target>
        </trans-unit>
        <trans-unit id="554f6821f75ca67a45f462c39f059e3f6b71d8fc" translate="yes" xml:space="preserve">
          <source>The previous child of the context node</source>
          <target state="translated">컨텍스트 노드의 이전 자식</target>
        </trans-unit>
        <trans-unit id="dd4cc805c2e9d04a6cc32db9c442535d45b637ce" translate="yes" xml:space="preserve">
          <source>The previous contents of this translator object are discarded.</source>
          <target state="translated">이 번역기 객체의 이전 내용은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="7942610b1e333b464f89612e29d78332a2344c76" translate="yes" xml:space="preserve">
          <source>The previous expression is optional</source>
          <target state="translated">이전 표현은 선택 사항입니다</target>
        </trans-unit>
        <trans-unit id="67c8f97c19551b0109ff0d9b3e42e4cf23ade89b" translate="yes" xml:space="preserve">
          <source>The previous item (in a list) is selected. For example, a tab in a &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; that is next to the selected tab.</source>
          <target state="translated">이전 항목 (목록에서)이 선택되었습니다. 예를 들어, 선택된 탭 옆 에있는 &lt;a href=&quot;qtabbar&quot;&gt;QTabBar의&lt;/a&gt; 탭.</target>
        </trans-unit>
        <trans-unit id="81fff01bec35e8fb551df8ae93757c1d85ada815" translate="yes" xml:space="preserve">
          <source>The previous object will no longer be monitored. Passing in the same object will be ignored, but monitoring will continue.</source>
          <target state="translated">이전 개체는 더 이상 모니터링되지 않습니다. 동일한 객체를 전달하는 것은 무시되지만 모니터링은 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="27815572f5b0a3641d7c2f5cf35495708c195791" translate="yes" xml:space="preserve">
          <source>The previous section is selected</source>
          <target state="translated">이전 섹션이 선택되었습니다</target>
        </trans-unit>
        <trans-unit id="db0b0579386f1e17d586a2a625c2979b4fca2586" translate="yes" xml:space="preserve">
          <source>The previous tab (typically the tab on the left) is selected.</source>
          <target state="translated">이전 탭 (일반적으로 왼쪽의 탭)이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="4b6c201170fd2c8f715eadb0106ba4703636cde2" translate="yes" xml:space="preserve">
          <source>The previous tab is selected.</source>
          <target state="translated">이전 탭이 선택되었습니다.</target>
        </trans-unit>
        <trans-unit id="10f1589c89118cdaae0cc5e71e774e75985cd377" translate="yes" xml:space="preserve">
          <source>The previousInFocusChain function returns the previous widget in this widget's focus chain.</source>
          <target state="translated">previousInFocusChain 함수는이 위젯의 ​​포커스 체인에서 이전 위젯을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="14d02989b0de80c6a4b2b606dd4b1a26d06bdc49" translate="yes" xml:space="preserve">
          <source>The primary classes that make up the &lt;code&gt;QtSensorGesturesRecognizers&lt;/code&gt; API:</source>
          <target state="translated">&lt;code&gt;QtSensorGesturesRecognizers&lt;/code&gt; API를 구성하는 기본 클래스 :</target>
        </trans-unit>
        <trans-unit id="e0caac4f3a9c7a0ff8d2953f747ba790f6107785" translate="yes" xml:space="preserve">
          <source>The primary classes that make up the Qt Sensors API.</source>
          <target state="translated">Qt Sensors API를 구성하는 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="64dd3a2e6ef179b96a979e8cfca2bf5551ca84ec" translate="yes" xml:space="preserve">
          <source>The primary classes that make up the QtSensorGestures API:</source>
          <target state="translated">QtSensorGestures API를 구성하는 기본 클래스 :</target>
        </trans-unit>
        <trans-unit id="bd19bad54878d0a69173795f810e8875c774f3a7" translate="yes" xml:space="preserve">
          <source>The primary color is used as the background color of &lt;a href=&quot;qml-qtquick-controls2-toolbar&quot;&gt;ToolBar&lt;/a&gt; by default.</source>
          <target state="translated">기본 색상은 기본적 으로 &lt;a href=&quot;qml-qtquick-controls2-toolbar&quot;&gt;툴바&lt;/a&gt; 의 배경색으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="65593acf5fdb3efe574caa31999e3fdd54cd95fe" translate="yes" xml:space="preserve">
          <source>The primary difference between raw and geomagnetic values is that extra processing is done to eliminate local magnetic interference from the geomagnetic values so they represent only the effect of the Earth's magnetic field. This process is not perfect and the accuracy of each reading may change.</source>
          <target state="translated">원시 값과 지자기 값의 주요 차이점은 지자기 값에서 국지적 자기 간섭을 제거하기 위해 추가 처리가 수행되어 지구 자기장의 영향만을 나타냅니다. 이 과정은 완벽하지 않으며 각 판독 값의 정확도가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93ec0e7856f8f3f5d3aaf996e0e6d389421327ba" translate="yes" xml:space="preserve">
          <source>The primary means of acquiring Route objects is &lt;a href=&quot;qml-qtlocation-routemodel&quot;&gt;RouteModel&lt;/a&gt;.</source>
          <target state="translated">Route 객체를 얻는 주요 수단은 &lt;a href=&quot;qml-qtlocation-routemodel&quot;&gt;RouteModel&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8644e95c1ea1d670c3ba0b605faa1fb470f0b09a" translate="yes" xml:space="preserve">
          <source>The primary means of acquiring Route objects is via Routes via &lt;a href=&quot;qml-qtlocation-routemodel&quot;&gt;RouteModel&lt;/a&gt;.</source>
          <target state="translated">Route 객체를 얻는 주요 수단은 &lt;a href=&quot;qml-qtlocation-routemodel&quot;&gt;RouteModel을&lt;/a&gt; 통한 경로를 통한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="747b99f623106fb9346758adda3af3f188e128d5" translate="yes" xml:space="preserve">
          <source>The primary screen orientation is &lt;a href=&quot;qt#ScreenOrientation-enum&quot;&gt;Qt::LandscapeOrientation&lt;/a&gt; if the screen geometry's width is greater than or equal to its height, or &lt;a href=&quot;qt#ScreenOrientation-enum&quot;&gt;Qt::PortraitOrientation&lt;/a&gt; otherwise. This property might change when the screen orientation was changed (i.e. when the display is rotated). The behavior is however platform dependent and can often be specified in an application manifest file.</source>
          <target state="translated">화면 지오메트리의 너비가 높이보다 크거나 같으면 기본 화면 방향은 &lt;a href=&quot;qt#ScreenOrientation-enum&quot;&gt;Qt :: LandscapeOrientation&lt;/a&gt; 이고, 그렇지 않으면 &lt;a href=&quot;qt#ScreenOrientation-enum&quot;&gt;Qt :: PortraitOrientation&lt;/a&gt; 입니다. 이 속성은 화면 방향이 변경 될 때 (예 : 디스플레이가 회전 할 때) 변경 될 수 있습니다. 그러나이 동작은 플랫폼에 따라 다르며 종종 응용 프로그램 매니페스트 파일에서 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65056618e6d1348fdefc36c2e2d752cf39edfddb" translate="yes" xml:space="preserve">
          <source>The primary series of the graph. It is used to determine the row and column axis labels when the labels are not explicitly set to the axes.</source>
          <target state="translated">그래프의 기본 시리즈. 레이블이 축으로 명시 적으로 설정되지 않은 경우 행 및 열 축 레이블을 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="04906ed9e8841e21e2c36b5d8d2001db43146bf4" translate="yes" xml:space="preserve">
          <source>The primary text to be displayed.</source>
          <target state="translated">표시 할 기본 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="0a8c77124b4b04c3b25dfca00c310f413e1bb1c6" translate="yes" xml:space="preserve">
          <source>The primaryScreenChanged signal was introduced in Qt 5.6.</source>
          <target state="translated">primaryScreenChanged 신호는 Qt 5.6에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="2a717814c7cda7c0e012cbaacc3fcaf645446a47" translate="yes" xml:space="preserve">
          <source>The primitive element &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_PanelItemViewItem&lt;/a&gt; is responsible for painting the background of items, and is called from &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt;'s implementation of &lt;a href=&quot;qstyle#ControlElement-enum&quot;&gt;CE_ItemViewItem&lt;/a&gt;.</source>
          <target state="translated">기본 요소 &lt;a href=&quot;qstyle#PrimitiveElement-enum&quot;&gt;PE_PanelItemViewItem&lt;/a&gt; 은 항목의 배경을 그리는 역할을하며 &lt;a href=&quot;qcommonstyle&quot;&gt;QCommonStyle&lt;/a&gt; 의 &lt;a href=&quot;qstyle#ControlElement-enum&quot;&gt;CE_ItemViewItem&lt;/a&gt; 구현에서 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="8fa471442cfbae73a009be6c560d29ef085bcab2" translate="yes" xml:space="preserve">
          <source>The primitive types are supported natively by &lt;a href=&quot;qdbusargument&quot;&gt;QDBusArgument&lt;/a&gt; and need no special customization to be sent or received. They are listed below, along with the C++ class they relate to:</source>
          <target state="translated">프리미티브 유형은 기본적으로 &lt;a href=&quot;qdbusargument&quot;&gt;QDBusArgument에서&lt;/a&gt; 지원되며 특별한 사용자 정의를 보내거나받을 필요가 없습니다. 그것들은 그들이 관련된 C ++ 클래스와 함께 아래에 나열되어 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4a117fd0563a1368472c9190b8e6ca9e41964a47" translate="yes" xml:space="preserve">
          <source>The principal artist of the album the media belongs to.</source>
          <target state="translated">미디어가 속한 앨범의 주요 아티스트.</target>
        </trans-unit>
        <trans-unit id="34e3c1fc2a091353a48d6a377bc0f51e49c938a6" translate="yes" xml:space="preserve">
          <source>The print current page option is enabled</source>
          <target state="translated">현재 페이지 인쇄 옵션이 활성화되었습니다</target>
        </trans-unit>
        <trans-unit id="284fb5fd58b9708ba71ff3e13af6d35ecf08d900" translate="yes" xml:space="preserve">
          <source>The print selection option is enabled.</source>
          <target state="translated">인쇄 선택 옵션이 활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="2275f2e5202d38a4e34489892e27e1aeae881a59" translate="yes" xml:space="preserve">
          <source>The print to file option is enabled.</source>
          <target state="translated">파일로 인쇄 옵션이 활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="65162f87097c85ded455ffa8c044bbef51dd2285" translate="yes" xml:space="preserve">
          <source>The printer dialog (shown above in Plastique style) enables access to common printing properties. On X11 platforms that use the CUPS printing system, the settings for each available printer can be modified via the dialog's &lt;b&gt;Properties&lt;/b&gt; push button.</source>
          <target state="translated">위의 Plastique 스타일로 표시된 프린터 대화 상자를 통해 일반적인 인쇄 속성에 액세스 할 수 있습니다. CUPS 인쇄 시스템을 사용하는 X11 플랫폼에서 사용 가능한 각 프린터의 설정은 대화 상자의 &lt;b&gt;속성&lt;/b&gt; 누름 버튼을 통해 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce8111ee0e09f16ed9442f73a739c1a536ea6111" translate="yes" xml:space="preserve">
          <source>The printer driver reads this setting and prints the page using the specified orientation.</source>
          <target state="translated">프린터 드라이버는이 설정을 읽고 지정된 방향으로 페이지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f1144121c274ea4698139b225f7f7eb99ad4f16d" translate="yes" xml:space="preserve">
          <source>The printer driver reads this setting and prints the specified number of copies.</source>
          <target state="translated">프린터 드라이버는이 설정을 읽고 지정된 매수를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="1297cbfcc352d595cfe21f35d56f36a3d34aae21" translate="yes" xml:space="preserve">
          <source>The printer's default setting is used to determine whether duplex printing is used.</source>
          <target state="translated">프린터의 기본 설정은 양면 인쇄 사용 여부를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a03ca21cce75b9be05403f3623ebd6ab6d813d3d" translate="yes" xml:space="preserve">
          <source>The priority of these approaches follows the order they are listed below, from highest to lowest. That is, using &lt;a href=&quot;qquickstyle&quot;&gt;QQuickStyle&lt;/a&gt; to set the style will always take priority over using the command line argument, for example.</source>
          <target state="translated">이러한 접근 방식의 우선 순위는 아래에 나열된 순서대로 높은 순서에서 가장 낮은 순서로 따릅니다. 즉, &lt;a href=&quot;qquickstyle&quot;&gt;QQuickStyle&lt;/a&gt; 을 사용하여 스타일을 설정하면 명령 줄 인수를 사용하는 것보다 항상 우선합니다.</target>
        </trans-unit>
        <trans-unit id="559c3a23523aa9889cce8013101a630c9fba4cd0" translate="yes" xml:space="preserve">
          <source>The priority to be used when filtering pick results by priority when &lt;a href=&quot;qml-qt3d-render-pickingsettings&quot;&gt;PickingSettings&lt;/a&gt;.pickResultMode is set to &lt;a href=&quot;qml-qt3d-render-pickingsettings&quot;&gt;PickingSettings&lt;/a&gt;.PriorityPick.</source>
          <target state="translated">픽업시 우선 순위 결과를 필터링 할 때 우선 순위가 사용될 &lt;a href=&quot;qml-qt3d-render-pickingsettings&quot;&gt;PickingSettings&lt;/a&gt; .pickResultMode로 설정 &lt;a href=&quot;qml-qt3d-render-pickingsettings&quot;&gt;PickingSettings&lt;/a&gt; .PriorityPick.</target>
        </trans-unit>
        <trans-unit id="c6296fcb1fc538b3ff5ca22700d77c077bd85563" translate="yes" xml:space="preserve">
          <source>The priority to be used when filtering pick results by priority when &lt;a href=&quot;qt3drender-qpickingsettings#pickResultMode-prop&quot;&gt;QPickingSettings::pickResultMode&lt;/a&gt; is set to &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;QPickingSettings::NearestPriorityPick&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qt3drender-qpickingsettings#pickResultMode-prop&quot;&gt;QPickingSettings :: pickResultMode&lt;/a&gt; 가 &lt;a href=&quot;qt3drender-qpickingsettings#PickResultMode-enum&quot;&gt;QPickingSettings :: NearestPriorityPick으로&lt;/a&gt; 설정된 경우 우선 순위별로 선택 결과를 필터링 할 때 사용되는 우선 순위 입니다.</target>
        </trans-unit>
        <trans-unit id="12bf986050a605cd3660b5faf865697cb3d69e10" translate="yes" xml:space="preserve">
          <source>The problem occurs because of the way the base state is defined for QML: as the &quot;snapshot&quot; state of the application just prior to entering an explicitly defined state. In this case, if we are in the process of animating from green back to red, and interrupt the animation to return to &quot;GreenState&quot;, the base state will include the color in its intermediate, mid-animation form.</source>
          <target state="translated">QML에 대해 기본 상태가 정의 된 방식으로 인해 문제점이 발생합니다. 명시 적으로 정의 된 상태로 들어가기 직전에 응용 프로그램의 &quot;스냅 샷&quot;상태입니다. 이 경우 녹색에서 빨간색으로 애니메이션을 적용하고 &quot;GreenState&quot;로 돌아가도록 애니메이션을 중단하는 경우 기본 상태에는 중간 중간 애니메이션 형태의 색상이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9256bfdd02e8ab7ee965df2250265962454edade" translate="yes" xml:space="preserve">
          <source>The problem with this pattern is that any failures in the test function will cause the call to &lt;code&gt;item.destroy()&lt;/code&gt; to be skipped, leaving the item hanging around in the scene until the test case has finished. This can result in interference with future tests; for example, by blocking input events or producing unrelated debug output that makes it difficult to follow the code's execution.</source>
          <target state="translated">이 패턴의 문제점은 테스트 함수가 실패하면 &lt;code&gt;item.destroy()&lt;/code&gt; 호출을 건너 뛰고 테스트 케이스가 완료 될 때까지 항목을 씬에 남겨 두는 것입니다. 이로 인해 향후 테스트에 방해가 될 수 있습니다. 예를 들어, 입력 이벤트를 차단하거나 관련없는 디버그 출력을 생성하여 코드 실행을 따르기가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="b2fc406cb4d71f6aa121e0f232b68561e3878a40" translate="yes" xml:space="preserve">
          <source>The process crashed some time after starting successfully.</source>
          <target state="translated">성공적으로 시작한 후 프로세스가 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="8c900079d4e3f5a874a304cf3e74c71014523a3f" translate="yes" xml:space="preserve">
          <source>The process crashed.</source>
          <target state="translated">프로세스가 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="9901ad25a17e461196937137f8bb564603277f58" translate="yes" xml:space="preserve">
          <source>The process exited normally.</source>
          <target state="translated">프로세스가 정상적으로 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="b0143b4b815305ac4ab1996d636156355b2482f5" translate="yes" xml:space="preserve">
          <source>The process failed to start. Either the invoked program is missing, or you may have insufficient permissions to invoke the program.</source>
          <target state="translated">프로세스를 시작하지 못했습니다. 호출 된 프로그램이 누락되었거나 프로그램을 호출 할 권한이 충분하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d45284806d61a3cc89e9851abf7d032b461ede2b" translate="yes" xml:space="preserve">
          <source>The process is not running.</source>
          <target state="translated">프로세스가 실행되고 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2468ab6f60366a7b2ebd5c89e0fb7694984c2a31" translate="yes" xml:space="preserve">
          <source>The process is running and is ready for reading and writing.</source>
          <target state="translated">프로세스가 실행 중이며 읽고 쓸 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="85d90071ab19cbe541b7779b668905c4756645b3" translate="yes" xml:space="preserve">
          <source>The process is starting, but the program has not yet been invoked.</source>
          <target state="translated">프로세스가 시작되었지만 프로그램이 아직 호출되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c71111f164232fa75193646368fa8f7ec2995e93" translate="yes" xml:space="preserve">
          <source>The process may not exit as a result of calling this function (it is given the chance to prompt the user for any unsaved files, etc).</source>
          <target state="translated">이 함수를 호출 한 결과 프로세스가 종료되지 않을 수 있습니다 (저장되지 않은 파일 등을 사용자에게 프롬프트 할 수있는 기회가 제공됨).</target>
        </trans-unit>
        <trans-unit id="760259d7cedfb370f3d766799e76215b22b4cb39" translate="yes" xml:space="preserve">
          <source>The process of creating a new style begins by creating a new subdirectory for the style in a QML import path under the URL-based directory structure &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-qmlmodule.html&quot;&gt;QtQuick&lt;/a&gt;/VirtualKeyboard/Styles/. See &lt;a href=&quot;qtqml-syntax-imports#qml-import-path&quot;&gt;QML Import Path&lt;/a&gt; for information about QML import paths. The directory name can not contain spaces or special characters other than underscore. Also, the directory name can not be the same as one of the built-in style, which currently includes &quot;default&quot; and &quot;retro&quot;.</source>
          <target state="translated">새 스타일을 작성하는 프로세스는 URL 기반 디렉토리 구조 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-qmlmodule.html&quot;&gt;QtQuick&lt;/a&gt; / VirtualKeyboard / Styles / 아래의 QML 가져 오기 경로에 스타일에 대한 새 서브 디렉토리를 작성하는 것으로 시작합니다 . &lt;a href=&quot;qtqml-syntax-imports#qml-import-path&quot;&gt;QML 가져 오기 경로에&lt;/a&gt; 대한 정보는 QML 가져 오기 경로 를 참조하십시오 . 디렉토리 이름은 밑줄 이외의 공백이나 특수 문자를 포함 할 수 없습니다. 또한 디렉토리 이름은 현재 &quot;default&quot;및 &quot;retro&quot;를 포함하는 내장 스타일 중 하나와 같을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c3dd52030b45e3790fc7eaf250a9db91da8750bb" translate="yes" xml:space="preserve">
          <source>The process of laying out widgets consists of creating the layout hierarchy while setting as few widget size constraints as possible.</source>
          <target state="translated">위젯을 배치하는 프로세스는 레이아웃 계층 구조를 작성하는 동시에 위젯 크기 제한을 가능한 적게 설정하는 것으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="eab17337b5b64fef92e58e8da2c46a5644a6ef71" translate="yes" xml:space="preserve">
          <source>The process of recognizing gestures involves filtering input events sent to specific objects, and modifying the associated &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; objects to include relevant information about the user's input.</source>
          <target state="translated">제스처를 인식하는 프로세스에는 특정 개체로 전송 된 입력 이벤트를 필터링하고 관련 &lt;a href=&quot;qgesture&quot;&gt;QGesture&lt;/a&gt; 개체를 수정 하여 사용자 입력에 대한 관련 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="6b7b9f69d2ec887a3722ebd4606bd79919eefd92" translate="yes" xml:space="preserve">
          <source>The process of registering the handler is different for each platform. Please refer to the platform documentation on how such a registration may be done. If the application has been registered as an NDEF message handler, the application only needs to call the &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler&lt;/a&gt;() function:</source>
          <target state="translated">핸들러를 등록하는 프로세스는 플랫폼마다 다릅니다. 이러한 등록 방법에 대해서는 플랫폼 설명서를 참조하십시오. 애플리케이션이 NDEF 메시지 핸들러로 등록 된 경우 애플리케이션은 &lt;a href=&quot;qnearfieldmanager#registerNdefMessageHandler&quot;&gt;registerNdefMessageHandler&lt;/a&gt; () 함수 만 호출하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="8b2cf7499ce1564819a2a6cf9b82003e064fd8d6" translate="yes" xml:space="preserve">
          <source>The process of sharing files via NFC involves other underlying communication transports such as Bluetooth or Wi-Fi Direct. It is implementation specific how and what type of transports are used to perform file transfer. The overall time taken to transfer content depends on the maximum speed of the transport used. Note that the process of sharing NDEF message/data does not require the use of other transports outside NFC.</source>
          <target state="translated">NFC를 통해 파일을 공유하는 프로세스에는 Bluetooth 또는 Wi-Fi Direct와 같은 다른 기본 통신 전송이 포함됩니다. 파일 전송을 수행하는 데 사용되는 전송 유형 및 방법은 구현별로 다릅니다. 콘텐츠를 전송하는 데 걸리는 전체 시간은 사용 된 최대 전송 속도에 따라 다릅니다. NDEF 메시지 / 데이터 공유 프로세스에는 NFC 외부의 다른 전송을 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4d171880f92aba9d948fd0460c37df934570dbd1" translate="yes" xml:space="preserve">
          <source>The process of subclassing models is discussed in the section on &lt;a href=&quot;#creating-new-models&quot;&gt;Creating New Models&lt;/a&gt;.</source>
          <target state="translated">모델을 서브 클래 싱하는 프로세스는 &lt;a href=&quot;#creating-new-models&quot;&gt;새 모델 작성&lt;/a&gt; 섹션에서 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="c67be6a7f7b634a8d10f51eb80b705c2fb2bc3bc" translate="yes" xml:space="preserve">
          <source>The process will be started in the directory</source>
          <target state="translated">프로세스는 디렉토리에서 시작됩니다</target>
        </trans-unit>
        <trans-unit id="ea4691656c9a8b1ed7df5652f7b6dc9556d32515" translate="yes" xml:space="preserve">
          <source>The process will be started in the directory set by &lt;a href=&quot;qprocess#setWorkingDirectory&quot;&gt;setWorkingDirectory&lt;/a&gt;(). If &lt;a href=&quot;qprocess#workingDirectory&quot;&gt;workingDirectory&lt;/a&gt;() is empty, the working directory is inherited from the calling process.</source>
          <target state="translated">프로세스는 &lt;a href=&quot;qprocess#setWorkingDirectory&quot;&gt;setWorkingDirectory&lt;/a&gt; ()에 의해 설정된 디렉토리에서 시작됩니다 . 경우 &lt;a href=&quot;qprocess#workingDirectory&quot;&gt;WORKINGDIRECTORY은&lt;/a&gt; () 비어, 작업 디렉토리는 호출 한 프로세스에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="a876ef3e9b3765838e5fcba3dbcfdfcb7d255cf5" translate="yes" xml:space="preserve">
          <source>The producer of the video frame might use this to associate certain data with this frame, or for an intermediate processor to add information for a consumer of this frame.</source>
          <target state="translated">비디오 프레임의 제작자는이 데이터를 사용하여 특정 데이터를이 프레임과 연결하거나 중간 프로세서가이 프레임의 소비자에 대한 정보를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c728fe28d1d9bb34f8fdd783baff0d9fcd2fd4ed" translate="yes" xml:space="preserve">
          <source>The product code of the device.</source>
          <target state="translated">장치의 제품 코드입니다.</target>
        </trans-unit>
        <trans-unit id="f064489f34c39a47aa6f573e27e5a159fb7c6115" translate="yes" xml:space="preserve">
          <source>The product has previously been purchased and the purchase has now been restored as a result of calling &lt;a href=&quot;qinappstore#restorePurchases&quot;&gt;QInAppStore::restorePurchases&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qinappstore#restorePurchases&quot;&gt;QInAppStore :: restorePurchases&lt;/a&gt; () 를 호출 한 결과 이전에 제품을 구매했으며 구매가 복원되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0ea856467aeb8695c1887424228fd31d57aace80" translate="yes" xml:space="preserve">
          <source>The product is consumable, meaning that once the transaction for a purchase of the product has been finalized, it can be purchased again.</source>
          <target state="translated">이 제품은 소모품이므로 제품 구매 거래가 완료되면 다시 구매할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64692b15d2acb1df27609babd154f015f9cb9cc3" translate="yes" xml:space="preserve">
          <source>The product is unlockable, meaning that it can only be purchased once per user. Purchases of unlockable products can be restored using the &lt;a href=&quot;qinappstore#restorePurchases&quot;&gt;QInAppStore::restorePurchases&lt;/a&gt;().</source>
          <target state="translated">제품은 잠금 해제 가능하므로 사용자 당 한 번만 구매할 수 있습니다. 잠금 해제 가능한 제품 구매는 &lt;a href=&quot;qinappstore#restorePurchases&quot;&gt;QInAppStore :: restorePurchases&lt;/a&gt; ()를 사용하여 복원 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02d439f0b399ef82023e6ca0b9b8fad3bb0c9efb" translate="yes" xml:space="preserve">
          <source>The product name of the device.</source>
          <target state="translated">장치의 제품 이름입니다.</target>
        </trans-unit>
        <trans-unit id="986296d9fbeb75a51d0480beb2bc9b0a200f90ed" translate="yes" xml:space="preserve">
          <source>The product type can be either &lt;code&gt;Consumable&lt;/code&gt; or &lt;code&gt;Unlockable&lt;/code&gt;. The former type of products can be purchased any number of times as long as each transaction is finalized explicitly by the application. The latter type can only be purchased once.</source>
          <target state="translated">제품 유형은 &lt;code&gt;Consumable&lt;/code&gt; 또는 &lt;code&gt;Unlockable&lt;/code&gt; 수 있습니다 . 이전 유형의 제품은 각 트랜잭션이 애플리케이션에 의해 명시 적으로 완료되는 한 여러 번 구매할 수 있습니다. 후자 유형은 한 번만 구입할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e21e6b9917ee753e95dfa648a4a39c377bfb9a0d" translate="yes" xml:space="preserve">
          <source>The product version numbering.</source>
          <target state="translated">제품 버전 번호입니다.</target>
        </trans-unit>
        <trans-unit id="0aaa6fb21a7e222a982aac543ed816692e6df4d5" translate="yes" xml:space="preserve">
          <source>The profile does not take ownership of the pointer.</source>
          <target state="translated">프로파일은 포인터의 소유권을 갖지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c8dc09f910c1d25243bcd73ec11b760861bef4c" translate="yes" xml:space="preserve">
          <source>The program logic for a QML application may be defined in JavaScript. The JavaScript code may either be defined in-line in QML documents, or separated into JavaScript files (known as &lt;code&gt;JavaScript Resources&lt;/code&gt; in QML).</source>
          <target state="translated">QML 어플리케이션을위한 프로그램 로직은 JavaScript로 정의 될 수 있습니다. JavaScript 코드는 QML 문서에서 인라인으로 정의되거나 JavaScript 파일 ( QML에서 &lt;code&gt;JavaScript Resources&lt;/code&gt; 라고 함)로 분리 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9813dd3e1cf11e07abc67b4bcf1a4d3e6dacda9" translate="yes" xml:space="preserve">
          <source>The programmer is responsible for reading this setting and printing accordingly.</source>
          <target state="translated">프로그래머는이 설정을 읽고 그에 따라 인쇄 할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd1d47ceffc371634db4e7813dba653493fd760e" translate="yes" xml:space="preserve">
          <source>The progress bar is drawn here.</source>
          <target state="translated">진행률 표시 줄이 여기에 그려집니다.</target>
        </trans-unit>
        <trans-unit id="ecd4fc88e7856e6048021b76224656a81bf91837" translate="yes" xml:space="preserve">
          <source>The progress bar text is usually just the progress expressed as a string. An empty string indicates that the progress bar has not started yet. The default value is an empty string.</source>
          <target state="translated">진행률 표시 줄 텍스트는 일반적으로 문자열로 표시되는 진행률입니다. 빈 문자열은 진행률 표시 줄이 아직 시작되지 않았 음을 나타냅니다. 기본값은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="205dc254e5ce1951d1beb42381afd343297b39ed" translate="yes" xml:space="preserve">
          <source>The progress bar uses the concept of</source>
          <target state="translated">진행률 표시 줄은</target>
        </trans-unit>
        <trans-unit id="764c739da08f812f714c284950f7f81ce0c54787" translate="yes" xml:space="preserve">
          <source>The progress chunk of a &lt;a href=&quot;qprogressbar&quot;&gt;QProgressBar&lt;/a&gt;.</source>
          <target state="translated">a의 진행 덩어리 &lt;a href=&quot;qprogressbar&quot;&gt;QProgressBar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8f4a9ebb4d7f5bb1d05972823b862dbbd7eea85" translate="yes" xml:space="preserve">
          <source>The progress component for this style.</source>
          <target state="translated">이 스타일의 진행 요소입니다.</target>
        </trans-unit>
        <trans-unit id="cd5024f44b276d00b957d049c65f6627a06de26e" translate="yes" xml:space="preserve">
          <source>The progress indicator of a &lt;a href=&quot;qprogressbar&quot;&gt;QProgressBar&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qprogressbar&quot;&gt;QProgressBar&lt;/a&gt; 의 진행 표시기입니다 .</target>
        </trans-unit>
        <trans-unit id="3c996759b3730744938eb0bab501f2cc5a7da93c" translate="yes" xml:space="preserve">
          <source>The progress indicator uses the concept of</source>
          <target state="translated">진행 표시기는</target>
        </trans-unit>
        <trans-unit id="69669b97aa8226e8fff9836e395d3301e21f20a5" translate="yes" xml:space="preserve">
          <source>The progress is indicated by a progress indicator around the button. When the indicator reaches completion, it flashes.</source>
          <target state="translated">진행률은 버튼 주위에 진행률 표시기로 표시됩니다. 표시기가 완료되면 깜박입니다.</target>
        </trans-unit>
        <trans-unit id="ff49a2668a9fc911a31052336c0484f39f81aef1" translate="yes" xml:space="preserve">
          <source>The progress is indicated by a progress indicator on the button.</source>
          <target state="translated">진행률은 버튼의 진행률 표시기로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="88b4ed52037879b666a70b59118a8014235667aa" translate="yes" xml:space="preserve">
          <source>The progress is inverted (i.e., right to left in a horizontal bar).</source>
          <target state="translated">진행률이 반전됩니다 (예 : 가로 막대에서 오른쪽에서 왼쪽으로).</target>
        </trans-unit>
        <trans-unit id="b8b912d7950337fb5cda19b3b3d8811350d310fe" translate="yes" xml:space="preserve">
          <source>The progress of an animation is given by its current time (&lt;a href=&quot;qabstractanimation#currentLoopTime&quot;&gt;currentLoopTime&lt;/a&gt;()), which is measured in milliseconds from the start of the animation (0) to its end (&lt;a href=&quot;qabstractanimation#duration&quot;&gt;duration&lt;/a&gt;()). The value is updated automatically while the animation is running. It can also be set directly with &lt;a href=&quot;qabstractanimation#currentTime-prop&quot;&gt;setCurrentTime&lt;/a&gt;().</source>
          <target state="translated">애니메이션의 진행률은 현재 시간 ( &lt;a href=&quot;qabstractanimation#currentLoopTime&quot;&gt;currentLoopTime&lt;/a&gt; ())으로 제공되며 애니메이션 시작 (0)에서 끝 ( &lt;a href=&quot;qabstractanimation#duration&quot;&gt;지속 시간&lt;/a&gt; ()) 까지 밀리 초 단위로 측정됩니다 . 애니메이션이 실행되는 동안 값이 자동으로 업데이트됩니다. &lt;a href=&quot;qabstractanimation#currentTime-prop&quot;&gt;setCurrentTime&lt;/a&gt; ()으로 직접 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0737c23a9fd96b2c7b78f05373840cbf6d95c06a" translate="yes" xml:space="preserve">
          <source>The progress of loading the component, from 0.0 (nothing loaded) to 1.0 (finished).</source>
          <target state="translated">구성 요소로드 진행률은 0.0 (무적 재)에서 1.0 (완료)까지입니다.</target>
        </trans-unit>
        <trans-unit id="11495b1903706918c42caf90646c8523d453b7f6" translate="yes" xml:space="preserve">
          <source>The progress range for the watched future has changed to</source>
          <target state="translated">본 미래의 진행 범위가</target>
        </trans-unit>
        <trans-unit id="b9aba6c8c9524fda022ec5dec2b12f2fe03141a7" translate="yes" xml:space="preserve">
          <source>The progress shown in the text may be smaller than the minimum value, indicating that the progress bar is in the &quot;reset&quot; state before any progress is set.</source>
          <target state="translated">텍스트에 표시된 진행률은 최소값보다 작을 수 있으며 진행률이 설정되기 전에 진행률 표시 줄이 &quot;재설정&quot;상태임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="134983617464e4e5785e8166b7816d8bbc2a0168" translate="yes" xml:space="preserve">
          <source>The project can be built in</source>
          <target state="translated">프로젝트를 내장 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="31bb9094c837b7207fb25f6b62ee406b51043adc" translate="yes" xml:space="preserve">
          <source>The project configuration contains information that qdoc uses to create the documentation.</source>
          <target state="translated">프로젝트 구성에는 qdoc이 문서를 작성하는 데 사용하는 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e1daedfa76bae09d2dfee77bb4888ad8690cc6e3" translate="yes" xml:space="preserve">
          <source>The project file above would produce an executable named &lt;code&gt;myapp&lt;/code&gt; on unix and &lt;code&gt;myapp.exe&lt;/code&gt; on Windows.</source>
          <target state="translated">위의 프로젝트 파일 은 unix에서 &lt;code&gt;myapp&lt;/code&gt; , Windows에서 &lt;code&gt;myapp.exe&lt;/code&gt; 라는 실행 파일을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="00924d11924f2404e4dad49869fac7e2de69a1da" translate="yes" xml:space="preserve">
          <source>The project file format used by qmake can be used to support both simple and fairly complex build systems. Simple project files use a straightforward declarative style, defining standard variables to indicate the source and header files that are used in the project. Complex projects may use control flow structures to fine-tune the build process.</source>
          <target state="translated">qmake가 사용하는 프로젝트 파일 형식은 단순하고 복잡한 빌드 시스템을 모두 지원하는 데 사용할 수 있습니다. 간단한 프로젝트 파일은 간단한 선언 스타일을 사용하여 표준 변수를 정의하여 프로젝트에서 사용되는 소스 및 헤더 파일을 나타냅니다. 복잡한 프로젝트는 제어 흐름 구조를 사용하여 빌드 프로세스를 미세 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e93f4a67d161b3730cb5deb44da8a39e97e666f" translate="yes" xml:space="preserve">
          <source>The project is a Qt application and should link against the Qt library. You can use the &lt;code&gt;QT&lt;/code&gt; variable to control any additional Qt modules that are required by your application. This value is added by default, but you can remove it to use qmake for a non-Qt project.</source>
          <target state="translated">프로젝트는 Qt 애플리케이션이며 Qt 라이브러리와 연결되어야합니다. &lt;code&gt;QT&lt;/code&gt; 변수를 사용 하여 애플리케이션에 필요한 추가 Qt 모듈을 제어 할 수 있습니다 . 이 값은 기본적으로 추가되지만 Qt가 아닌 프로젝트에 qmake를 사용하기 위해 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="361ccb6c686234943948799ca0873ba39ba50ce6" translate="yes" xml:space="preserve">
          <source>The project is an X11 application or library. This value is not needed if the target uses Qt.</source>
          <target state="translated">프로젝트는 X11 응용 프로그램 또는 라이브러리입니다. 대상이 Qt를 사용하는 경우이 값은 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42385d4a6c7f867c10cc7281084a2c818038c8f7" translate="yes" xml:space="preserve">
          <source>The project is prepared to be built in</source>
          <target state="translated">프로젝트는 내장 될 준비가되었습니다</target>
        </trans-unit>
        <trans-unit id="c20932996be7c2c2237000e18e2358feab2b28ba" translate="yes" xml:space="preserve">
          <source>The project is to be built in debug mode.</source>
          <target state="translated">프로젝트는 디버그 모드로 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="40eff1b4df1c17cf87cd206f8d92e67fb2b72eff" translate="yes" xml:space="preserve">
          <source>The project is to be built in release mode. If &lt;code&gt;debug&lt;/code&gt; is also specified, the last one takes effect.</source>
          <target state="translated">프로젝트는 릴리스 모드로 빌드됩니다. 경우 &lt;code&gt;debug&lt;/code&gt; 도 지정되어, 마지막이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1d1f2c4d7255aefe0ee34b3499cb955aa073c010" translate="yes" xml:space="preserve">
          <source>The project's name is used to form a file name for the associated project's</source>
          <target state="translated">프로젝트 이름은 연결된 프로젝트의 파일 이름을 형성하는 데 사용됩니다</target>
        </trans-unit>
        <trans-unit id="a47d9fef716160f945882b12fe2bf39738a6f5c1" translate="yes" xml:space="preserve">
          <source>The projection matrix is available through</source>
          <target state="translated">프로젝션 매트릭스는</target>
        </trans-unit>
        <trans-unit id="8bb5936d76337d842f4b506887727f07026bee22" translate="yes" xml:space="preserve">
          <source>The projectionPlaneV is one of two vectors in the plane in 3D space. If either this, or &lt;a href=&quot;qml-qt-labs-wavefrontmesh-wavefrontmesh#projectionPlaneW-prop&quot;&gt;projectionPlaneW&lt;/a&gt; is set to (0, 0, 0) (the default), then the plane will be detected based on the first encountered face in the data set.</source>
          <target state="translated">projectionPlaneV는 3D 공간에서 평면의 두 벡터 중 하나입니다. 이 또는 &lt;a href=&quot;qml-qt-labs-wavefrontmesh-wavefrontmesh#projectionPlaneW-prop&quot;&gt;projectionPlaneW&lt;/a&gt; 가 (0, 0, 0) (기본값)으로 설정되면 데이터 세트에서 처음 만나는면을 기준으로 평면이 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="b80c361cdb259b380f37aa16ee52102151013e3d" translate="yes" xml:space="preserve">
          <source>The projectionPlaneW is one of two vectors in the plane in 3D space. If either this, or &lt;a href=&quot;qml-qt-labs-wavefrontmesh-wavefrontmesh#projectionPlaneV-prop&quot;&gt;projectionPlaneV&lt;/a&gt; is set to (0, 0, 0) (the default), then the plane will be detected based on the first encountered face in the data set.</source>
          <target state="translated">projectionPlaneW는 3D 공간에서 평면의 두 벡터 중 하나입니다. 이 또는 &lt;a href=&quot;qml-qt-labs-wavefrontmesh-wavefrontmesh#projectionPlaneV-prop&quot;&gt;projectionPlaneV&lt;/a&gt; 가 (0, 0, 0) (기본값)으로 설정되면 데이터 세트에서 처음 만나는면을 기준으로 평면이 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="178add6edc0646d03269463d0ee9dd51d8ad9bd3" translate="yes" xml:space="preserve">
          <source>The properties &lt;a href=&quot;qml-qtsensors-sensorgesture#validGestures-prop&quot;&gt;validGestures&lt;/a&gt; and &lt;a href=&quot;qml-qtsensors-sensorgesture#invalidGestures-prop&quot;&gt;invalidGestures&lt;/a&gt; will be set as appropriate immediately. To determine all available getures on the system please use the &lt;a href=&quot;qml-qtsensors-sensorgesture#availableGestures-prop&quot;&gt;availableGestures&lt;/a&gt; property.</source>
          <target state="translated">&lt;a href=&quot;qml-qtsensors-sensorgesture#validGestures-prop&quot;&gt;validGestures&lt;/a&gt; 및 &lt;a href=&quot;qml-qtsensors-sensorgesture#invalidGestures-prop&quot;&gt;invalidGestures&lt;/a&gt; 속성이 즉시 적절하게 설정됩니다. 시스템에서 사용 가능한 모든 geture를 판별하려면 &lt;a href=&quot;qml-qtsensors-sensorgesture#availableGestures-prop&quot;&gt;availableGestures&lt;/a&gt; 특성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c0fc49a2f02f407a5fd6c49a5b30f77d659cc4b6" translate="yes" xml:space="preserve">
          <source>The properties accessible with this operator are typically used to enable third party plugins and components to be integrated in Qt. For example, a</source>
          <target state="translated">이 연산자로 액세스 할 수있는 속성은 일반적으로 타사 플러그인 및 구성 요소를 Qt에 통합하는 데 사용됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="10168760ff16198f19ee3e2462620997ac4aa10f" translate="yes" xml:space="preserve">
          <source>The properties and functions &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; inherits from &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt; can also be used to specify the widget frame to be used for any given label.</source>
          <target state="translated">&lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; 이 &lt;a href=&quot;qframe&quot;&gt;QFrame&lt;/a&gt; 에서 상속 한 속성 및 함수 를 사용하여 특정 레이블에 사용할 위젯 프레임을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="18fb14bd7094e7472c5cd8a5740e56c118667419" translate="yes" xml:space="preserve">
          <source>The properties and visibility of various axis elements, such as axis line, title, labels, grid lines, and shades, can be individually controlled.</source>
          <target state="translated">축선, 제목, 레이블, 격자 선 및 음영과 같은 다양한 축 요소의 속성 및 가시성을 개별적으로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebd48d8b5dbda062b994a31f5c1c6caa2f38c008" translate="yes" xml:space="preserve">
          <source>The properties define the access permissions for the characteristic.</source>
          <target state="translated">특성은 특성에 대한 액세스 권한을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5041bd2d68d59b42966563b6088fae5de39cd6a9" translate="yes" xml:space="preserve">
          <source>The properties for controlling the animator are provided by the &lt;a href=&quot;qml-qt3d-animation-abstractclipanimator&quot;&gt;AbstractClipAnimator&lt;/a&gt; base class.</source>
          <target state="translated">애니메이터를 제어하기위한 속성은 &lt;a href=&quot;qml-qt3d-animation-abstractclipanimator&quot;&gt;AbstractClipAnimator&lt;/a&gt; 기본 클래스에 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="c6d7401e64cdb4f8ca644efa0b64d0277a33f880" translate="yes" xml:space="preserve">
          <source>The properties for controlling the animator are provided by the &lt;a href=&quot;qt3danimation-qabstractclipanimator&quot;&gt;QAbstractClipAnimator&lt;/a&gt; base class.</source>
          <target state="translated">애니메이터를 제어하기위한 속성은 &lt;a href=&quot;qt3danimation-qabstractclipanimator&quot;&gt;QAbstractClipAnimator&lt;/a&gt; 기본 클래스에서 제공합니다.</target>
        </trans-unit>
        <trans-unit id="98777d0d092cbf3067e0ea5967afe87192ec21bd" translate="yes" xml:space="preserve">
          <source>The properties of the specified</source>
          <target state="translated">지정된 속성</target>
        </trans-unit>
        <trans-unit id="e28c7d94a40557bd9b5a512ee665cfb9e9d17180" translate="yes" xml:space="preserve">
          <source>The properties provided to each delegate are:</source>
          <target state="translated">각 대리인에게 제공되는 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e96421c776b60d06327b1a62ee017d7ed0ba9652" translate="yes" xml:space="preserve">
          <source>The properties provided to the delegate are:</source>
          <target state="translated">대리인에게 제공되는 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ae853bf527399e7388b9e2526bfa03ae18fc0c85" translate="yes" xml:space="preserve">
          <source>The properties, signals and public invokable methods of the objects are published to the remote clients. There, an object with the identifier used as key in the</source>
          <target state="translated">개체의 속성, 신호 및 공개 호출 가능한 방법이 원격 클라이언트에 게시됩니다. 거기에 키로 사용 된 식별자를 가진 객체가</target>
        </trans-unit>
        <trans-unit id="bdb881e0c60580f20036065b15375c51bcce763c" translate="yes" xml:space="preserve">
          <source>The properties, signals and public methods of the</source>
          <target state="translated">의 속성, 신호 및 공개 방법</target>
        </trans-unit>
        <trans-unit id="30b1d2f9608d08fbc714784e823e061103847a75" translate="yes" xml:space="preserve">
          <source>The property also accepts gradient presets from &lt;a href=&quot;qgradient#Preset-enum&quot;&gt;QGradient::Preset&lt;/a&gt;. Note however that due to Rectangle only supporting simple vertical or horizontal gradients, any preset with an unsupported angle will revert to the closest representation.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;qgradient#Preset-enum&quot;&gt;QGradient :: Preset의&lt;/a&gt; 그라디언트 사전 설정도 허용합니다 . 그러나 Rectangle은 단순한 수직 또는 수평 그라디언트 만 지원하므로 각도가 지원되지 않는 모든 사전 설정은 가장 가까운 표현으로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="0b87eb5a21ca96e3e4b6575a664071428a4f053c" translate="yes" xml:space="preserve">
          <source>The property called</source>
          <target state="translated">라는 속성</target>
        </trans-unit>
        <trans-unit id="a6419c751a5247dd219c6dcbb491825e2c4d661a" translate="yes" xml:space="preserve">
          <source>The property can be attached to any item, popup, or window. When attached to an item or a popup, the value is &lt;code&gt;null&lt;/code&gt; if the item or popup is not in a window.</source>
          <target state="translated">속성은 모든 항목, 팝업 또는 창에 첨부 할 수 있습니다. 항목 또는 팝업에 첨부 될 때 항목 또는 팝업이 창에 없으면 값은 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f2f0a8268136920e0bd7e93a04ed031a22a0d75a" translate="yes" xml:space="preserve">
          <source>The property can be attached to any popup.</source>
          <target state="translated">이 속성은 모든 팝업에 첨부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="295229d6bf9cf86516c1dc95f42847c9094664e2" translate="yes" xml:space="preserve">
          <source>The property can take one of the following values:</source>
          <target state="translated">이 속성은 다음 값 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e4e8d2784d55da45ae163028800bc00bd2298ac" translate="yes" xml:space="preserve">
          <source>The property description focuses on what the property</source>
          <target state="translated">속성 설명은 속성에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="b04c38a5369fa5e569153d51481f1f89f981a611" translate="yes" xml:space="preserve">
          <source>The property documentation resides immediately above the read function's implementation. The &lt;a href=&quot;qdoc-guide-writing#writing-topic-commands&quot;&gt;topic command&lt;/a&gt; for properties is &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#property-command&quot;&gt;\property&lt;/a&gt;.</source>
          <target state="translated">속성 문서는 읽기 기능의 구현 바로 위에 있습니다. 특성 의 &lt;a href=&quot;qdoc-guide-writing#writing-topic-commands&quot;&gt;주제 명령&lt;/a&gt; 은 &lt;a href=&quot;https://doc.qt.io/qt-5.13/13-qdoc-commands-topics.html#property-command&quot;&gt;\ property&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e832a30a6da83d250494f64d9d053b9fde774c44" translate="yes" xml:space="preserve">
          <source>The property does not exist in this interface (&lt;code&gt;org.freedesktop.DBus.Error.UnknownProperty&lt;/code&gt;)</source>
          <target state="translated">이 인터페이스에 특성이 없습니다 ( &lt;code&gt;org.freedesktop.DBus.Error.UnknownProperty&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4a7f0bb2028ce34365edd79f8e5cf123996f6c62" translate="yes" xml:space="preserve">
          <source>The property editor can also be used to add new &lt;a href=&quot;qobject#dynamic-properties&quot;&gt;dynamic properties&lt;/a&gt; to both standard Qt widgets and to forms themselves. Since Qt 4.4, dynamic properties are added and removed via the property editor's toolbar, shown below.</source>
          <target state="translated">속성 편집기를 사용하여 표준 Qt 위젯과 폼 자체 에 새로운 &lt;a href=&quot;qobject#dynamic-properties&quot;&gt;동적 속성&lt;/a&gt; 을 추가 할 수도 있습니다 . Qt 4.4부터 동적 속성은 아래와 같이 속성 편집기의 툴바를 통해 추가 및 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3faaad4b3dba8829bd70426a5dc2986038d7cbf5" translate="yes" xml:space="preserve">
          <source>The property editor uses standard Qt input widgets to manage the properties of objects on the form. Textual properties are shown in line edits, integer properties are displayed in spinboxes, boolean properties are displayed in check boxes, and compound properties such as colors and sizes are presented in drop-down lists of input widgets.</source>
          <target state="translated">특성 편집기는 표준 Qt 입력 위젯을 사용하여 양식에서 오브젝트의 특성을 관리합니다. 텍스트 속성은 라인 편집으로 표시되고, 정수 속성은 스핀 박스에 표시되고, 부울 속성은 확인란에 표시되며, 색상 및 크기와 같은 복합 속성은 입력 위젯의 드롭 다운 목록에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="37b5c1e5562c4265cb316dddb1d1f47497de8104" translate="yes" xml:space="preserve">
          <source>The property has no effect on buttons that belong to a button group.</source>
          <target state="translated">이 속성은 버튼 그룹에 속하는 버튼에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="520caa4eb1b93b077718350eb961b593a8bf1cd3" translate="yes" xml:space="preserve">
          <source>The property holds the frame coordinates of the point to use for exposure metering. This point is only used in spot metering mode, and it typically defaults to the center &lt;code&gt;(0.5, 0.5)&lt;/code&gt;.</source>
          <target state="translated">이 속성은 노출 측정에 사용할 점의 프레임 좌표를 유지합니다. 이 지점은 스팟 측광 모드에서만 사용되며 일반적으로 중심 &lt;code&gt;(0.5, 0.5)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f7babef92b1fe33cb9d3996052f223b46a438f3d" translate="yes" xml:space="preserve">
          <source>The property holds the maximum buffer size.</source>
          <target state="translated">이 속성은 최대 버퍼 크기를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="a0199e16c6a2e6814172e22d5b2839388b12d5b2" translate="yes" xml:space="preserve">
          <source>The property holds the most efficient buffer size.</source>
          <target state="translated">이 속성은 가장 효율적인 버퍼 크기를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="b9adc1a3e68db883276dd6af6a1031586fb97ff0" translate="yes" xml:space="preserve">
          <source>The property holds the most efficient buffer size. Normally this is 1 (which means no particular size is most efficient). Some sensor drivers have a FIFO buffer which makes it more efficient to deliver the FIFO's size worth of readings at one time.</source>
          <target state="translated">이 속성은 가장 효율적인 버퍼 크기를 유지합니다. 일반적으로 이것은 1입니다 (즉, 특정 크기가 가장 효율적이지 않음). 일부 센서 드라이버에는 FIFO 버퍼가있어 FIFO 크기의 판독 값을 한 번에보다 효율적으로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1784d2095ce5bbdb37a0d354026abcaccde1ea3e" translate="yes" xml:space="preserve">
          <source>The property holds the plugin that is responsible for managing this icon.</source>
          <target state="translated">속성에는이 아이콘을 관리하는 플러그인이 있습니다.</target>
        </trans-unit>
        <trans-unit id="86616bcd0dff5d114037760fd5e242814c544bf0" translate="yes" xml:space="preserve">
          <source>The property is a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; derived type pointer</source>
          <target state="translated">이 속성은 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 파생 형식 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="47a87abfb1cc02896e887bcf7a4283dda233b19d" translate="yes" xml:space="preserve">
          <source>The property is a &lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt; list property</source>
          <target state="translated">이 특성은 &lt;a href=&quot;qqmllistproperty&quot;&gt;QQmlListProperty&lt;/a&gt; 목록 특성입니다.</target>
        </trans-unit>
        <trans-unit id="22513a540eefbdca18047177fa6885f0e254164f" translate="yes" xml:space="preserve">
          <source>The property is a normal value property.</source>
          <target state="translated">이 속성은 일반 값 속성입니다.</target>
        </trans-unit>
        <trans-unit id="6c3739bb31732bbb62ff4c72a24b2c0a5d767259" translate="yes" xml:space="preserve">
          <source>The property is a regular Qt property.</source>
          <target state="translated">이 속성은 일반 Qt 속성입니다.</target>
        </trans-unit>
        <trans-unit id="354c40a46a857fdfc73b4a86a1b29dec420f8797" translate="yes" xml:space="preserve">
          <source>The property is a signal property.</source>
          <target state="translated">이 속성은 신호 속성입니다.</target>
        </trans-unit>
        <trans-unit id="abe0dc7013c6d1dbf036b1e15c4595ba775ff421" translate="yes" xml:space="preserve">
          <source>The property is ignored if device discovery is selected.</source>
          <target state="translated">장치 검색이 선택된 경우이 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="72909c8e591e84ac66b08ca2f95c64df58c9fa4d" translate="yes" xml:space="preserve">
          <source>The property is invalid, or is a signal property.</source>
          <target state="translated">특성이 유효하지 않거나 신호 특성입니다.</target>
        </trans-unit>
        <trans-unit id="a93351190c2208848219b12abae604afefd913d3" translate="yes" xml:space="preserve">
          <source>The property is invalid.</source>
          <target state="translated">속성이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15f0782742317fd77732a74fbbe7ea87232e62f0" translate="yes" xml:space="preserve">
          <source>The property is set by subclasses in order to let the abstract slider know whether or not &lt;a href=&quot;qabstractslider#tracking-prop&quot;&gt;tracking&lt;/a&gt; has any effect.</source>
          <target state="translated">이 속성은 추상 슬라이더가 &lt;a href=&quot;qabstractslider#tracking-prop&quot;&gt;추적&lt;/a&gt; 에 영향을 미치는지 여부를 알리기 위해 서브 클래스에 의해 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="6c8095102fa4cfbb51bc6867871fafaf6ecb559f" translate="yes" xml:space="preserve">
          <source>The property is undefined (&lt;a href=&quot;#qQNaN&quot;&gt;qQNaN&lt;/a&gt;()) if the altitude has not been set.</source>
          <target state="translated">고도가 설정되지 않은 경우 속성이 정의되지 않습니다 ( &lt;a href=&quot;#qQNaN&quot;&gt;qQNaN&lt;/a&gt; ()).</target>
        </trans-unit>
        <trans-unit id="84f0f7ca7da65ea0be2ff0a9d0650962aef82258" translate="yes" xml:space="preserve">
          <source>The property is undefined (&lt;a href=&quot;#qQNaN&quot;&gt;qQNaN&lt;/a&gt;()) if the latitude has not been set. A positive latitude indicates the Northern Hemisphere, and a negative latitude indicates the Southern Hemisphere. When setting the latitude the new value should be in the &lt;a href=&quot;http://en.wikipedia.org/wiki/World_Geodetic_System&quot;&gt;WGS84&lt;/a&gt; datum format.</source>
          <target state="translated">위도를 설정하지 않은 경우 속성이 정의되지 않습니다 ( &lt;a href=&quot;#qQNaN&quot;&gt;qQNaN&lt;/a&gt; ()). 양의 위도는 북반구를 나타내고 음의 위도는 남반구를 나타냅니다. 위도를 설정할 때 새 값은 &lt;a href=&quot;http://en.wikipedia.org/wiki/World_Geodetic_System&quot;&gt;WGS84&lt;/a&gt; 데이텀 형식 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="926c6f25ee209b715f5c4b54bd5366334adf788c" translate="yes" xml:space="preserve">
          <source>The property is undefined (&lt;a href=&quot;#qQNaN&quot;&gt;qQNaN&lt;/a&gt;()) if the longitude has not been set. A positive longitude indicates the Eastern Hemisphere, and a negative longitude indicates the Western Hemisphere. When setting the longitude the new value should be in the &lt;a href=&quot;http://en.wikipedia.org/wiki/World_Geodetic_System&quot;&gt;WGS84&lt;/a&gt; datum format.</source>
          <target state="translated">경도가 설정되지 않은 경우 특성이 정의되지 않습니다 ( &lt;a href=&quot;#qQNaN&quot;&gt;qQNaN&lt;/a&gt; ()). 양의 경도는 동반구를 나타내고 음의 경도는 서반구를 나타냅니다. 경도를 설정할 때 새 값은 &lt;a href=&quot;http://en.wikipedia.org/wiki/World_Geodetic_System&quot;&gt;WGS84&lt;/a&gt; 데이텀 형식 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="dc213362074c744d1143acc58bebf0393a39bf86" translate="yes" xml:space="preserve">
          <source>The property must be set before calling &lt;a href=&quot;qsensor#start&quot;&gt;start&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qsensor#start&quot;&gt;start&lt;/a&gt; () 를 호출하기 전에 속성을 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="75bab2e361b966332165723c70f1c800c6b58d95" translate="yes" xml:space="preserve">
          <source>The property name and the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; instance of which property should be animated are passed to the constructor. You can then specify the start and end value of the property. The procedure is equal for properties in classes you have implemented yourself--just check with &lt;a href=&quot;qvariantanimation&quot;&gt;QVariantAnimation&lt;/a&gt; that your &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; type is supported.</source>
          <target state="translated">속성을 애니메이션화해야하는 속성 이름과 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 인스턴스가 생성자에 전달됩니다. 그런 다음 속성의 시작 및 끝 값을 지정할 수 있습니다. 이 절차는 직접 구현 한 클래스의 속성과 동일합니다. &lt;a href=&quot;qvariantanimation&quot;&gt;QVariantAnimation&lt;/a&gt; 을 통해 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 유형이 지원 되는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="80cce38fa23e892e6edb06c97ae26013d1ff5fd5" translate="yes" xml:space="preserve">
          <source>The property name and type and the &lt;code&gt;READ&lt;/code&gt; function are required. The type can be any type supported by &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;, or it can be a user-defined type. The other items are optional, but a &lt;code&gt;WRITE&lt;/code&gt; function is common. The attributes default to true except &lt;code&gt;USER&lt;/code&gt;, which defaults to false.</source>
          <target state="translated">속성 이름 및 유형과 &lt;code&gt;READ&lt;/code&gt; 기능이 필요합니다. 유형은 &lt;a href=&quot;qvariant&quot;&gt;QVariant가&lt;/a&gt; 지원하는 모든 유형 이거나 사용자 정의 유형일 수 있습니다. 다른 항목은 선택 사항이지만 &lt;code&gt;WRITE&lt;/code&gt; 기능이 일반적입니다. &lt;code&gt;USER&lt;/code&gt; 를 제외하고 속성의 기본값은 true 이며 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="ff6199f5dcb0df58d75218a87817a938d045339f" translate="yes" xml:space="preserve">
          <source>The property name or index.</source>
          <target state="translated">속성 이름 또는 인덱스</target>
        </trans-unit>
        <trans-unit id="ae50cd40962207c0f7a5c76f1d1baba0357bf9c3" translate="yes" xml:space="preserve">
          <source>The property only has effect when the menu is used as a cascading sub-menu.</source>
          <target state="translated">메뉴가 계단식 하위 메뉴로 사용되는 경우에만 속성이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2c660aac1a963c195a33394b3aee4a868672fc2d" translate="yes" xml:space="preserve">
          <source>The property set failed because the property is read-only (&lt;code&gt;org.freedesktop.DBus.Error.PropertyReadOnly&lt;/code&gt;)</source>
          <target state="translated">특성이 읽기 전용이므로 특성 세트가 실패했습니다 ( &lt;code&gt;org.freedesktop.DBus.Error.PropertyReadOnly&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1f4945af7d298467a953a2c3ccbb7767eb1f1584" translate="yes" xml:space="preserve">
          <source>The property setter calls the native Qt class before firing the event using the &lt;code&gt;__raise&lt;/code&gt; keyword.</source>
          <target state="translated">속성 설정 &lt;code&gt;__raise&lt;/code&gt; 키워드를 사용하여 이벤트를 시작하기 전에 기본 Qt 클래스를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ee94627ddbff1daeb8ce677f3b7811d8506c4077" translate="yes" xml:space="preserve">
          <source>The property sheet, or any other extension, can be retrieved by querying</source>
          <target state="translated">속성 시트 또는 기타 확장은 쿼리하여 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ab99b4ab5fa69acb076aa60ea7c4cba715c6279" translate="yes" xml:space="preserve">
          <source>The property specified represents the default property of this class. Ie. the default property of a push button would be &quot;text&quot;.</source>
          <target state="translated">지정된 속성은이 클래스의 기본 속성을 나타냅니다. 즉. 누름 버튼의 기본 속성은 &quot;text&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="30db5c400dbafd43448aea53e7c193c3ea19aaa1" translate="yes" xml:space="preserve">
          <source>The property to be updated.</source>
          <target state="translated">업데이트 할 속성입니다.</target>
        </trans-unit>
        <trans-unit id="ad0c5f48e59611a6c19b970f3ff6e0eae8c5a507" translate="yes" xml:space="preserve">
          <source>The property type can be any type supported by &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;, or it can be a user-defined type. In this example, class &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; is considered to be a user-defined type.</source>
          <target state="translated">특성 유형은 &lt;a href=&quot;qvariant&quot;&gt;QVariant가&lt;/a&gt; 지원하는 모든 유형 이거나 사용자 정의 유형일 수 있습니다. 이 예에서 &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 클래스 는 사용자 정의 유형으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="656876912b7a289057e6ad57e0bc20f3dadc837e" translate="yes" xml:space="preserve">
          <source>The property type or a comparable type.</source>
          <target state="translated">속성 유형 또는 비교 가능한 유형</target>
        </trans-unit>
        <trans-unit id="96c0a3cfc645d54cc9b060186c84873410536273" translate="yes" xml:space="preserve">
          <source>The property value is undefined if this geo rectangle is invalid.</source>
          <target state="translated">이 지역 사각형이 유효하지 않은 경우 속성 값이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="895c64bb5f02b95127a6ce899c9bf0c07061a411" translate="yes" xml:space="preserve">
          <source>The property's values are set and retrieved with &lt;a href=&quot;qmetaproperty#read&quot;&gt;read&lt;/a&gt;(), &lt;a href=&quot;qmetaproperty#write&quot;&gt;write&lt;/a&gt;(), and &lt;a href=&quot;qmetaproperty#reset&quot;&gt;reset&lt;/a&gt;(); they can also be changed through &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;'s set and get functions. See &lt;a href=&quot;qobject#setProperty&quot;&gt;QObject::setProperty&lt;/a&gt;() and &lt;a href=&quot;qobject#property&quot;&gt;QObject::property&lt;/a&gt;() for details.</source>
          <target state="translated">속성 값은 &lt;a href=&quot;qmetaproperty#read&quot;&gt;read&lt;/a&gt; (), &lt;a href=&quot;qmetaproperty#write&quot;&gt;write&lt;/a&gt; () 및 &lt;a href=&quot;qmetaproperty#reset&quot;&gt;reset&lt;/a&gt; () 으로 설정 및 검색됩니다 . &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 의 set 및 get 함수를 통해 변경할 수도 있습니다 . 자세한 내용은 &lt;a href=&quot;qobject#setProperty&quot;&gt;QObject :: setProperty&lt;/a&gt; () 및 &lt;a href=&quot;qobject#property&quot;&gt;QObject :: property&lt;/a&gt; ()를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3f09419c0baa87913f34eb0399c75bf7e280ed68" translate="yes" xml:space="preserve">
          <source>The proportion of items that should be laid out up to this point.</source>
          <target state="translated">이 시점까지 배치해야 할 항목의 비율입니다.</target>
        </trans-unit>
        <trans-unit id="d0ccb2160cd8538ec2e10c955818b22a5fe2d553" translate="yes" xml:space="preserve">
          <source>The proposed drop actions can be filtered in a widget's dragMoveEvent() function. However, it is possible to accept all proposed actions in the dragEnterEvent() and let the user decide which they want to accept later:</source>
          <target state="translated">제안 된 놓기 동작은 위젯의 dragMoveEvent () 함수에서 필터링 할 수 있습니다. 그러나 dragEnterEvent ()에서 제안 된 모든 작업을 수락하고 사용자가 나중에 수락 할 작업을 결정하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44a4550b42d49342de4a90d492452080a040da0f" translate="yes" xml:space="preserve">
          <source>The protected functions of &lt;a href=&quot;qplacesearchreply#setResults&quot;&gt;QPlaceSearchReply::setResults&lt;/a&gt;() and &lt;a href=&quot;qplacesearchreply#setRequest&quot;&gt;QPlaceSearchReply::setRequest&lt;/a&gt;() are made publicly accessible so the plugin can assign results and requests. Because these functions are not publicly exported, accessibility is not so much of an issue. An alternative would have been to declare a friend class in SearchReply.</source>
          <target state="translated">&lt;a href=&quot;qplacesearchreply#setResults&quot;&gt;QPlaceSearchReply :: setResults&lt;/a&gt; () 및 &lt;a href=&quot;qplacesearchreply#setRequest&quot;&gt;QPlaceSearchReply :: setRequest&lt;/a&gt; () 의 보호 된 기능은 공개적으로 액세스 가능하므로 플러그인이 결과 및 요청을 지정할 수 있습니다. 이러한 기능은 공개적으로 내 보내지 않기 때문에 접근성은 그다지 중요하지 않습니다. 대안은 SearchReply에서 친구 클래스를 선언하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8afe5a2d9b2e659e0cb652b218cf31c958340b5d" translate="yes" xml:space="preserve">
          <source>The protocol is unknown.</source>
          <target state="translated">프로토콜을 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c3975aefea1df70b759fef7238914e9e619c1d4c" translate="yes" xml:space="preserve">
          <source>The protocol name is an arbitrary string that indicates the type of connection being attempted. For example, it can match the scheme of a URL, like &quot;http&quot;, &quot;https&quot; and &quot;ftp&quot;. In most cases, the proxy selection will not change depending on the protocol, but this information is provided in case a better choice can be made, like choosing an caching HTTP proxy for HTTP-based connections, but a more powerful SOCKSv5 proxy for all others.</source>
          <target state="translated">프로토콜 이름은 시도중인 연결 유형을 나타내는 임의의 문자열입니다. 예를 들어 &quot;http&quot;, &quot;https&quot;및 &quot;ftp&quot;와 같은 URL 체계와 일치 할 수 있습니다. 대부분의 경우 프록시 선택은 프로토콜에 따라 변경되지 않지만이 정보는 HTTP 기반 연결을위한 캐싱 HTTP 프록시 선택과 같은 더 나은 선택이 가능하지만 다른 모든 경우에는 더 강력한 SOCKSv5 프록시를 선택할 수있는 경우에 제공됩니다. .</target>
        </trans-unit>
        <trans-unit id="c588d1f1988165cfc199ec7fd38b01370377aae2" translate="yes" xml:space="preserve">
          <source>The protocol tag is an arbitrary string that indicates which protocol is being talked over the socket, such as &quot;http&quot;, &quot;xmpp&quot;, &quot;telnet&quot;, etc. The protocol tag is used by the backend to return a request that is more specific to the protocol in question: for example, a HTTP connection could be use a caching HTTP proxy server, while all other connections use a more powerful SOCKSv5 proxy server.</source>
          <target state="translated">프로토콜 태그는 &quot;http&quot;, &quot;xmpp&quot;, &quot;telnet&quot;등과 같이 소켓을 통해 통신중인 프로토콜을 나타내는 임의의 문자열입니다. 프로토콜 태그는 백엔드에서보다 구체적인 요청을 반환하는 데 사용됩니다. 예를 들어 HTTP 연결은 캐싱 HTTP 프록시 서버를 사용하는 반면 다른 모든 연결은보다 강력한 SOCKSv5 프록시 서버를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9e4e721f55f2ad65d472c1333c17d0d255773f0b" translate="yes" xml:space="preserve">
          <source>The prototype of the created object will be</source>
          <target state="translated">생성 된 객체의 프로토 타입은</target>
        </trans-unit>
        <trans-unit id="be64406c6cb3eb656b06260a3940e96ea7559a5c" translate="yes" xml:space="preserve">
          <source>The prototype of the created object will be the Object prototype object.</source>
          <target state="translated">생성 된 객체의 프로토 타입은 객체 프로토 타입 객체가됩니다.</target>
        </trans-unit>
        <trans-unit id="5d16a71a4f2c482135a94381bbb969c55835e218" translate="yes" xml:space="preserve">
          <source>The provided</source>
          <target state="translated">제공</target>
        </trans-unit>
        <trans-unit id="9768c1b1c2c3487ea41bdbbaf37c400be68ca645" translate="yes" xml:space="preserve">
          <source>The provided URL should also include the scheme.</source>
          <target state="translated">제공된 URL에도 체계가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0e8e6029cbd76e0b04cd5b20367b67344d41412c" translate="yes" xml:space="preserve">
          <source>The provided method must be implemented as a slot that only accepts a single &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; argument.</source>
          <target state="translated">제공된 메소드는 단일 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 인수 만 허용하는 슬롯으로 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6cc972355af03be8a1a80220c58304bae1d7fe1a" translate="yes" xml:space="preserve">
          <source>The provided method,</source>
          <target state="translated">제공된 방법</target>
        </trans-unit>
        <trans-unit id="2f7c94b0083832a490e21ce278013b1a14cb57f0" translate="yes" xml:space="preserve">
          <source>The provided schema is registered as an &lt;a href=&quot;qtremoteobjects-external-schemas#external-schemas&quot;&gt;External Schema&lt;/a&gt;</source>
          <target state="translated">제공된 스키마가 &lt;a href=&quot;qtremoteobjects-external-schemas#external-schemas&quot;&gt;외부 스키마&lt;/a&gt; 로 등록되었습니다</target>
        </trans-unit>
        <trans-unit id="eec38d34cd3f171baa849061e5a7aab06451b6e2" translate="yes" xml:space="preserve">
          <source>The provider name of the services. Multiple plugins may have the same name. In such cases the Version string will be used to further distinguish the plugins.</source>
          <target state="translated">서비스 제공자 이름. 여러 플러그인의 이름이 동일 할 수 있습니다. 이러한 경우 버전 문자열을 사용하여 플러그인을 더욱 구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab5ed1c9b7a8ee833511c578eefa5ac9f4b3c416" translate="yes" xml:space="preserve">
          <source>The proximity sensor can only indicate if an object is close or not.</source>
          <target state="translated">근접 센서는 물체가 가까이 있는지 여부 만 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a725e32a5516186494757d72df7c66c40010e823" translate="yes" xml:space="preserve">
          <source>The proxy address set with &lt;a href=&quot;qabstractsocket#setProxy&quot;&gt;setProxy&lt;/a&gt;() (or the application proxy) was not found.</source>
          <target state="translated">&lt;a href=&quot;qabstractsocket#setProxy&quot;&gt;setProxy&lt;/a&gt; () (또는 애플리케이션 프록시)로 설정된 프록시 주소를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="92b764dc074a33ed2713908072d1b801c6ccb28f" translate="yes" xml:space="preserve">
          <source>The proxy functionality is useful when you want to share &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; objects over multiple networks. For instance, if you have an embedded target using target-only connections (like local) and you want to make some of those same objects available externally.</source>
          <target state="translated">프록시 기능은 여러 네트워크를 통해 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;소스&lt;/a&gt; 객체 를 공유하려는 경우에 유용합니다 . 예를 들어 로컬과 같은 대상 전용 연결을 사용하여 대상을 포함하고 동일한 객체 중 일부를 외부에서 사용할 수 있도록하려는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="065bbf22b0d904bdb290dda88a8ba95c2409f5e4" translate="yes" xml:space="preserve">
          <source>The publisher of the media.</source>
          <target state="translated">미디어 출판사.</target>
        </trans-unit>
        <trans-unit id="bdf9b449863625937e484839c38d4a8d81007d46" translate="yes" xml:space="preserve">
          <source>The publisher's distinguished name (default: &lt;code&gt;CN=MyCN&lt;/code&gt;).</source>
          <target state="translated">게시자의 고유 이름 (기본값 : &lt;code&gt;CN=MyCN&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="56aa5b8b41c3bcd8d01eef9d9534165075bba47f" translate="yes" xml:space="preserve">
          <source>The purchase was not completed for some reason. This could be because the user canceled the transaction, but it could also for example be caused by a missing network connection.</source>
          <target state="translated">어떤 이유로 구매가 완료되지 않았습니다. 사용자가 트랜잭션을 취소했기 때문일 수 있지만 네트워크 연결이 끊어져서 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b574d1d89075632c690d3b4d61b16176cbbc175" translate="yes" xml:space="preserve">
          <source>The purchase was successfully completed.</source>
          <target state="translated">구매가 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="a04128f83c29c755681a8f9c5a595c806a834056" translate="yes" xml:space="preserve">
          <source>The pure virtual functions describe the encoder to the system and the coder is used as required in the different text file formats supported by &lt;a href=&quot;qtextstream&quot;&gt;QTextStream&lt;/a&gt;, and under X11, for the locale-specific character input and output.</source>
          <target state="translated">순수한 가상 함수는 시스템에 인코더를 설명 하며 로케일 별 문자 입력 및 출력을 위해 &lt;a href=&quot;qtextstream&quot;&gt;QTextStream이&lt;/a&gt; 지원하는 다른 텍스트 파일 형식 및 X11 에서 필요한대로 코더를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="974d974090d65dc80d91e51a9dae8dd6ac20f247" translate="yes" xml:space="preserve">
          <source>The pure virtual interface to sensor gesture plugins</source>
          <target state="translated">센서 제스처 플러그인을위한 순수한 가상 인터페이스</target>
        </trans-unit>
        <trans-unit id="31a7324aae4e1fbf86b821b6f3ed921edd51591b" translate="yes" xml:space="preserve">
          <source>The purpose field may be used to programmatically determine the purpose of a configuration. Such information is usually part of the access point or service network meta data.</source>
          <target state="translated">목적 필드는 구성 목적을 프로그래밍 방식으로 결정하는 데 사용될 수 있습니다. 이러한 정보는 일반적으로 액세스 포인트 또는 서비스 네트워크 메타 데이터의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="edca656a64be5ff89c8cbf6e808611839a9c7ac2" translate="yes" xml:space="preserve">
          <source>The purpose is to reimplement the &lt;a href=&quot;qextensionfactory#createExtension&quot;&gt;QExtensionFactory::createExtension&lt;/a&gt;() function, making it able to create your extension, such as a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdesigner-containerextension-example.html#&quot;&gt;MultiPageWidget&lt;/a&gt; container extension.</source>
          <target state="translated">&lt;a href=&quot;qextensionfactory#createExtension&quot;&gt;QExtensionFactory :: createExtension&lt;/a&gt; () 함수 를 다시 구현하여 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdesigner-containerextension-example.html#&quot;&gt;MultiPageWidget&lt;/a&gt; 컨테이너 확장 과 같은 확장을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="502e98c9a9dc5c8b9e445167e71a0a5f7fe79295" translate="yes" xml:space="preserve">
          <source>The purpose of &lt;a href=&quot;qbytearraylist&quot;&gt;QByteArrayList&lt;/a&gt; is quite different from that of &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt;. Whereas &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; has many methods for manipulation of elements within the list, &lt;a href=&quot;qbytearraylist&quot;&gt;QByteArrayList&lt;/a&gt; does not. Normally, &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; should be used whenever working with a list of printable strings. &lt;a href=&quot;qbytearraylist&quot;&gt;QByteArrayList&lt;/a&gt; should be used to handle and efficiently join large blobs of binary data, as when sequentially receiving serialized data through a &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qbytearraylist&quot;&gt;QByteArrayList&lt;/a&gt; 의 목적은 &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; 의 목적과 상당히 다릅니다 . &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; 에는 목록 내 요소를 조작하는 많은 메소드가 있지만 &lt;a href=&quot;qbytearraylist&quot;&gt;QByteArrayList&lt;/a&gt; 는 없습니다. 일반적으로 &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; 는 인쇄 가능한 문자열 목록으로 작업 할 때마다 사용해야합니다. &lt;a href=&quot;qbytearraylist&quot;&gt;QByteArrayList을&lt;/a&gt; 처리하는 데 효율적 순차적 통해 직렬화 된 데이터를 수신하는 경우와 같이, 바이너리 데이터의 큰 블롭들에 가입하여야한다 &lt;a href=&quot;qiodevice&quot;&gt;QIODevice&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6e43f1e78d7516339c86a4eef1d18891a898f4e" translate="yes" xml:space="preserve">
          <source>The purpose of &lt;a href=&quot;qreadlocker&quot;&gt;QReadLocker&lt;/a&gt; (and &lt;a href=&quot;qwritelocker&quot;&gt;QWriteLocker&lt;/a&gt;) is to simplify &lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock&lt;/a&gt; locking and unlocking. Locking and unlocking statements or in exception handling code is error-prone and difficult to debug. &lt;a href=&quot;qreadlocker&quot;&gt;QReadLocker&lt;/a&gt; can be used in such situations to ensure that the state of the lock is always well-defined.</source>
          <target state="translated">&lt;a href=&quot;qreadlocker&quot;&gt;QReadLocker&lt;/a&gt; (및 &lt;a href=&quot;qwritelocker&quot;&gt;QWriteLocker&lt;/a&gt; ) 의 목적은 QReadWriteLock 잠금 및 잠금 해제 를 단순화하는 &lt;a href=&quot;qreadwritelock&quot;&gt;것&lt;/a&gt; 입니다. 명령문 잠금 또는 잠금 해제 또는 예외 처리 코드는 오류가 발생하기 쉽고 디버그하기가 어렵습니다. 이러한 상황에서 &lt;a href=&quot;qreadlocker&quot;&gt;QReadLocker&lt;/a&gt; 를 사용하여 잠금 상태를 항상 잘 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="706ba6c4a1231c7ab6ca18bf21a00482235328a7" translate="yes" xml:space="preserve">
          <source>The purpose of &lt;a href=&quot;qwritelocker&quot;&gt;QWriteLocker&lt;/a&gt; (and &lt;a href=&quot;qreadlocker&quot;&gt;QReadLocker&lt;/a&gt;) is to simplify &lt;a href=&quot;qreadwritelock&quot;&gt;QReadWriteLock&lt;/a&gt; locking and unlocking. Locking and unlocking statements or in exception handling code is error-prone and difficult to debug. &lt;a href=&quot;qwritelocker&quot;&gt;QWriteLocker&lt;/a&gt; can be used in such situations to ensure that the state of the lock is always well-defined.</source>
          <target state="translated">&lt;a href=&quot;qwritelocker&quot;&gt;QWriteLocker&lt;/a&gt; (및 &lt;a href=&quot;qreadlocker&quot;&gt;QReadLocker&lt;/a&gt; ) 의 목적은 QReadWriteLock 잠금 및 잠금 해제 를 단순화하는 &lt;a href=&quot;qreadwritelock&quot;&gt;것&lt;/a&gt; 입니다. 명령문 잠금 또는 잠금 해제 또는 예외 처리 코드는 오류가 발생하기 쉽고 디버그하기가 어렵습니다. 이러한 상황에서 &lt;a href=&quot;qwritelocker&quot;&gt;QWriteLocker&lt;/a&gt; 를 사용하여 잠금 상태를 항상 잘 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="091cbdeae9d1bd7c37b5c4b6a287cf2bd74783cd" translate="yes" xml:space="preserve">
          <source>The purpose of Dialog is to wrap arbitrary content into a</source>
          <target state="translated">Dialog의 목적은 임의의 내용을</target>
        </trans-unit>
        <trans-unit id="efdf31e4e343f1b4607024b79916a63262ae6789" translate="yes" xml:space="preserve">
          <source>The purpose of a &lt;a href=&quot;qmutex&quot;&gt;QMutex&lt;/a&gt; is to protect an object, data structure or section of code so that only one thread can access it at a time (this is similar to the Java &lt;code&gt;synchronized&lt;/code&gt; keyword). It is usually best to use a mutex with a &lt;a href=&quot;qmutexlocker&quot;&gt;QMutexLocker&lt;/a&gt; since this makes it easy to ensure that locking and unlocking are performed consistently.</source>
          <target state="translated">&lt;a href=&quot;qmutex&quot;&gt;QMutex&lt;/a&gt; 의 목적은 한 번에 하나의 스레드 만 액세스 할 수 있도록 오브젝트, 데이터 구조 또는 코드 섹션을 보호하는 것입니다 (Java &lt;code&gt;synchronized&lt;/code&gt; 키워드 와 유사 함 ). 잠금 및 잠금 해제가 일관되게 수행되도록하기 때문에 &lt;a href=&quot;qmutexlocker&quot;&gt;QMutexLocker&lt;/a&gt; 와 함께 뮤텍스를 사용하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="400f2ee7723cda18c4e5917225ccf785b23b2130" translate="yes" xml:space="preserve">
          <source>The purpose of an image response is to provide a way for image provider jobs to be executed in an asynchronous way.</source>
          <target state="translated">이미지 응답의 목적은 이미지 제공자 작업이 비동기 방식으로 실행될 수있는 방법을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="77072cebbe2822df71ee62c4ef8500c7a5b6b622" translate="yes" xml:space="preserve">
          <source>The purpose of area monitoring is to inform a user when he/she comes close to an area of interest. In general such an area is described by a &lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle&lt;/a&gt;. The circle's center represents the place of interest and the area around it identifies the geographical region within which notifications are sent.</source>
          <target state="translated">영역 모니터링의 목적은 사용자가 관심 영역에 가까이 오면 사용자에게 알리는 것입니다. 일반적으로 이러한 영역은 &lt;a href=&quot;qgeocircle&quot;&gt;QGeoCircle에&lt;/a&gt; 의해 설명됩니다 . 서클의 중심은 관심 장소를 나타내고 주변 영역은 알림이 전송되는 지역을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="74dd39b7885f852a3be2e3a3b2f59e5b352d4e61" translate="yes" xml:space="preserve">
          <source>The purpose of the signal is to support extra widgets in plain text edit subclasses that e.g. show line numbers, breakpoints, or other extra information.</source>
          <target state="translated">신호의 목적은 행 번호, 중단 점 또는 기타 추가 정보를 표시하는 일반 텍스트 편집 서브 클래스에서 추가 위젯을 지원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="083ff131647836bcef0ff162f70cbd2fad48d49e" translate="yes" xml:space="preserve">
          <source>The purpose of the texture factory is to provide a placeholder for a image data that can be converted into an OpenGL texture.</source>
          <target state="translated">텍스처 팩토리의 목적은 OpenGL 텍스처로 변환 될 수있는 이미지 데이터를위한 자리 표시자를 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d889c6a0fe377ecb837abf1648c0856192561375" translate="yes" xml:space="preserve">
          <source>The purpose of these macros is to enable programmers to add compiler or platform specific code to their application.</source>
          <target state="translated">이 매크로의 목적은 프로그래머가 응용 프로그램에 컴파일러 또는 플랫폼 별 코드를 추가 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="28e97320bda867f80ec03c62516cddfbce949d29" translate="yes" xml:space="preserve">
          <source>The purpose of this function is to support chained processing of XML data.</source>
          <target state="translated">이 함수의 목적은 XML 데이터의 체인 처리를 지원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="820cbf1d23a190304be5cda1a1c1cd34d39dd89f" translate="yes" xml:space="preserve">
          <source>The purpose of this key is to determine the real &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration&lt;/a&gt; that the session is using. This key is different from</source>
          <target state="translated">이 키의 목적은 세션이 사용 중인 실제 &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration&lt;/a&gt; 을 결정하는 것 입니다. 이 키는</target>
        </trans-unit>
        <trans-unit id="d1e14125c801723060c023b658351bca9571def2" translate="yes" xml:space="preserve">
          <source>The purpose of this method is to handle the key events generated by the the input engine.</source>
          <target state="translated">이 방법의 목적은 입력 엔진에서 생성 된 주요 이벤트를 처리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8cfb7817c890e4df7ff8e04352475a884f0e1454" translate="yes" xml:space="preserve">
          <source>The purpose of this property is to minimize resource use on platforms that use polling to update the state of the session. Applications can set the value of this property to the desired timeout before the session is closed. In response to the &lt;a href=&quot;qnetworksession#closed&quot;&gt;closed&lt;/a&gt;() signal the network session should be deleted to ensure that all polling is stopped. The session can then be recreated once it is required again. This property has no effect for sessions that do not require polling.</source>
          <target state="translated">이 특성의 목적은 폴링을 사용하여 세션 상태를 업데이트하는 플랫폼에서 자원 사용을 최소화하는 것입니다. 응용 프로그램은이 속성 값을 세션을 닫기 전에 원하는 시간 초과로 설정할 수 있습니다. &lt;a href=&quot;qnetworksession#closed&quot;&gt;닫힌&lt;/a&gt; () 신호에 응답하여 모든 폴링이 중지되도록 네트워크 세션을 삭제해야합니다. 그런 다음 세션이 다시 필요한 경우 다시 만들 수 있습니다. 이 속성은 폴링이 필요없는 세션에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5edcfc15b6caa7862470ab461d9cfe2e3b6a9856" translate="yes" xml:space="preserve">
          <source>The push button is perhaps the most commonly used widget in any graphical user interface. Pushing (or clicking) a button commands the computer to perform some action or answer a question. Common examples of buttons are OK, Apply, Cancel, Close, Yes, No, and Help buttons.</source>
          <target state="translated">누름 버튼은 그래픽 사용자 인터페이스에서 가장 일반적으로 사용되는 위젯입니다. 버튼을 누르거나 클릭하면 컴퓨터가 동작을 수행하거나 질문에 대답하도록 명령합니다. 버튼의 일반적인 예로는 확인, 적용, 취소, 닫기, 예, 아니요 및 도움말 버튼이 있습니다.</target>
        </trans-unit>
        <trans-unit id="26e5dbfc71351803b9d086f1d226ffb6e9e5749c" translate="yes" xml:space="preserve">
          <source>The push button, or command button, is perhaps the most commonly used widget in any graphical user interface. Push (click) a button to command the computer to perform some action, or to answer a question. Typical buttons are OK, Apply, Cancel, Close, Yes, No and Help.</source>
          <target state="translated">누름 단추 또는 명령 단추는 그래픽 사용자 인터페이스에서 가장 일반적으로 사용되는 위젯입니다. 버튼을 눌러 (클릭) 컴퓨터가 일부 작업을 수행하거나 질문에 대답하도록 명령합니다. 일반적인 버튼은 확인, 적용, 취소, 닫기, 예, 아니요 및 도움말입니다.</target>
        </trans-unit>
        <trans-unit id="d9f72e1849c5e9d251166bedeb07dbe7373ea114" translate="yes" xml:space="preserve">
          <source>The qFuzzyCompare function is for comparing two matrices using a fuzziness factor.</source>
          <target state="translated">qFuzzyCompare 함수는 퍼지 계수를 사용하여 두 행렬을 비교하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b56f74fac573ab9aa562af43ba09739b242ff42b" translate="yes" xml:space="preserve">
          <source>The qHash() hashing function</source>
          <target state="translated">qHash () 해싱 함수</target>
        </trans-unit>
        <trans-unit id="9acee225eada84057ddc6adf9deb5876529286f5" translate="yes" xml:space="preserve">
          <source>The qScopeGuard function can be used to call a function at the end of the scope.</source>
          <target state="translated">qScopeGuard 함수를 사용하여 범위 끝에서 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d09c78965043a3c44e8fabb3057897ee2132838c" translate="yes" xml:space="preserve">
          <source>The qSharedPointerObjectCast function is for casting a shared pointer.</source>
          <target state="translated">qSharedPointerObjectCast 함수는 공유 포인터를 캐스트하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="f95dc943b1d7c6cbab08c21a4da138ac019d8a4b" translate="yes" xml:space="preserve">
          <source>The qdocconf file, &lt;code&gt;master.qdocconf&lt;/code&gt;, just lists the qdocconf files for all the Qt5 modules to be processed:</source>
          <target state="translated">qdocconf 파일 &lt;code&gt;master.qdocconf&lt;/code&gt; 는 처리 될 모든 Qt5 모듈에 대한 qdocconf 파일 만 나열합니다.</target>
        </trans-unit>
        <trans-unit id="50d1945b34de4f7c034f65fe6fea48fe683e2f78" translate="yes" xml:space="preserve">
          <source>The qmake tool helps simplify the build process for development projects across different platforms. It automates the generation of Makefiles so that only a few lines of information are needed to create each Makefile. You can use qmake for any software project, whether it is written with Qt or not.</source>
          <target state="translated">qmake 도구는 여러 플랫폼에서 개발 프로젝트를위한 빌드 프로세스를 단순화합니다. 각 Makefile을 작성하는 데 몇 줄의 정보 만 필요하도록 Makefile 생성을 자동화합니다. Qt로 작성되었는지 여부에 관계없이 모든 소프트웨어 프로젝트에 qmake를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4952d5bb5f78ee1ec6c5a2fcaef0281965f9452a" translate="yes" xml:space="preserve">
          <source>The qoutputrange class holds the specifics of an output range. &lt;a href=&quot;#details&quot;&gt;More...&lt;/a&gt;</source>
          <target state="translated">qoutputrange 클래스는 출력 범위의 세부 사항을 보유합니다. &lt;a href=&quot;#details&quot;&gt;더...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aac17bc25ddc114da6e8b53dd19da72e04105a06" translate="yes" xml:space="preserve">
          <source>The qrc:/qt-project.org/imports path inside the resources.</source>
          <target state="translated">자원 내부의 qrc : /qt-project.org/imports 경로</target>
        </trans-unit>
        <trans-unit id="277b56ed3d6b978cbf0d969ce5a6962c59a45ae8" translate="yes" xml:space="preserve">
          <source>The qtTrId function finds and returns a translated string.</source>
          <target state="translated">qtTrId 함수는 번역 된 문자열을 찾아 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c37c062384fcb310263df4609fea2138fda7bfce" translate="yes" xml:space="preserve">
          <source>The qtmain Library</source>
          <target state="translated">qtmain 라이브러리</target>
        </trans-unit>
        <trans-unit id="b5bbb8a1deb011b5ee18818c8fd933227b1e3b39" translate="yes" xml:space="preserve">
          <source>The qtmain library is statically linked with the application. To avoid issues with static linking and the &lt;a href=&quot;https://doc.qt.io/qt-5.13/lgpl.html#&quot;&gt;GNU Lesser General Public License (LGPL)&lt;/a&gt;, it is licensed both under the commercial licenses, and the &lt;a href=&quot;https://spdx.org/licenses/BSD-3-Clause.html#&quot;&gt;BSD 3-clause &quot;New&quot; or &quot;Revised&quot; License&lt;/a&gt;.</source>
          <target state="translated">qtmain 라이브러리는 응용 프로그램과 정적으로 연결되어 있습니다. 정적 링크 및 &lt;a href=&quot;https://doc.qt.io/qt-5.13/lgpl.html#&quot;&gt;GNU LGPL (Lesser General Public License)&lt;/a&gt; 과 관련된 문제를 피하기 위해 상업용 라이센스와 &lt;a href=&quot;https://spdx.org/licenses/BSD-3-Clause.html#&quot;&gt;BSD 3 절 &quot;신규&quot;또는 &quot;개정 된&quot;라이센스로 라이센스가 부여&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="25c22e9f716cfce92384d8c66f8132b618307d9a" translate="yes" xml:space="preserve">
          <source>The qualified names of elements and attributes are reported.</source>
          <target state="translated">요소 및 속성의 규정 된 이름이보고됩니다.</target>
        </trans-unit>
        <trans-unit id="13367d9beef661502ee2afb48c1d085529511929" translate="yes" xml:space="preserve">
          <source>The quality level of the image. A handler that supports this option is expected to set the image quality level depending on the value of this option (an int) when writing.</source>
          <target state="translated">이미지의 품질 수준. 이 옵션을 지원하는 핸들러는 쓸 때이 옵션의 값 (int)에 따라 이미지 품질 수준을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5764a1eb8b4bc5a7c1d99a0e4e120e4ef462bbaa" translate="yes" xml:space="preserve">
          <source>The quality of shadows. One of the &lt;a href=&quot;qabstract3dgraph#ShadowQuality-enum&quot;&gt;QAbstract3DGraph::ShadowQuality&lt;/a&gt; enum values.</source>
          <target state="translated">그림자의 품질. &lt;a href=&quot;qabstract3dgraph#ShadowQuality-enum&quot;&gt;QAbstract3DGraph :: ShadowQuality&lt;/a&gt; 열거 형 값 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="b6023ac398ad7bdd4b21dee6c49f8be78d57d957" translate="yes" xml:space="preserve">
          <source>The quality of the blur depends on &lt;a href=&quot;qml-qtgraphicaleffects-directionalblur#samples-prop&quot;&gt;samples&lt;/a&gt; property. If length value is large, more samples are needed to keep the visual quality at high level.</source>
          <target state="translated">흐림의 품질은 &lt;a href=&quot;qml-qtgraphicaleffects-directionalblur#samples-prop&quot;&gt;샘플&lt;/a&gt; 속성에 따라 다릅니다 . 길이 값이 크면 시각적 품질을 높은 수준으로 유지하기 위해 더 많은 샘플이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="47c01775847d883fa2c2f114239496bd9fb1f357" translate="yes" xml:space="preserve">
          <source>The quality of the blur depends on &lt;a href=&quot;qml-qtgraphicaleffects-zoomblur#samples-prop&quot;&gt;samples&lt;/a&gt; property. If length value is large, more samples are needed to keep the visual quality at high level.</source>
          <target state="translated">흐림의 품질은 &lt;a href=&quot;qml-qtgraphicaleffects-zoomblur#samples-prop&quot;&gt;샘플&lt;/a&gt; 속성에 따라 다릅니다 . 길이 값이 크면 시각적 품질을 높은 수준으로 유지하기 위해 더 많은 샘플이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ef6d24985b2f7ba0d7b0c617251ab09e8c1794a0" translate="yes" xml:space="preserve">
          <source>The query finds all the &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; elements in the file. For each &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element, it builds a &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element in the output containing the concatenated contents of all the &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element's child &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; elements. Running the query through &lt;code&gt;xmlpatterns&lt;/code&gt; might produce the following output, which is not sorted in the expected order.</source>
          <target state="translated">쿼리는 파일에서 모든 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 요소를 찾습니다 . 각 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 요소 에 대해 모든 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 요소의 하위 &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 요소에 연결된 컨텐츠를 포함하는 출력에 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 요소를 빌드합니다 . &lt;code&gt;xmlpatterns&lt;/code&gt; 를 통해 쿼리를 실행하면 다음과 같은 출력이 생성 될 수 있으며 예상 된 순서대로 정렬되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="810a6fcd6001f18e7f6b9d384e3e7ddcf8701871" translate="yes" xml:space="preserve">
          <source>The query is executed when the application calls one of the &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; evaluation functions. The application uses &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery::evaluateTo&lt;/a&gt;(&lt;a href=&quot;qabstractxmlreceiver&quot;&gt;QAbstractXmlReceiver&lt;/a&gt; *), because it then uses a &lt;a href=&quot;qxmlserializer&quot;&gt;serializer&lt;/a&gt; to out the query result as XML to &lt;code&gt;stdout&lt;/code&gt;. We could have used &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery::evaluateTo&lt;/a&gt;(&lt;a href=&quot;qxmlresultitems&quot;&gt;QXmlResultItems&lt;/a&gt; *) to get a list of result items, or &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery::evaluateTo&lt;/a&gt;(&lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; *) if the query evaluated to a sequence of &lt;code&gt;xs:string&lt;/code&gt; values.</source>
          <target state="translated">응용 프로그램이 &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; 평가 기능 중 하나를 호출 할 때 조회가 실행됩니다 . 응용 프로그램은 &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery :: evaluateTo&lt;/a&gt; ( &lt;a href=&quot;qabstractxmlreceiver&quot;&gt;QAbstractXmlReceiver&lt;/a&gt; *)를 사용합니다. &lt;a href=&quot;qxmlserializer&quot;&gt;직렬화 &lt;/a&gt;기를 사용 하여 쿼리 결과를 XML에서 &lt;code&gt;stdout&lt;/code&gt; 으로 출력하기 때문 입니다. 우리는 사용할 수도 &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery :: evaluateTo을&lt;/a&gt; ( &lt;a href=&quot;qxmlresultitems&quot;&gt;QXmlResultItems이&lt;/a&gt; 결과 항목 또는 목록을 얻을 *) &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery :: evaluateTo&lt;/a&gt; ( &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; 쿼리의 순서에 따라 평가하는 경우 *)를 &lt;code&gt;xs:string&lt;/code&gt; 값.</target>
        </trans-unit>
        <trans-unit id="5e00f490585b52fa0d5c68dea42d673492b90dfb" translate="yes" xml:space="preserve">
          <source>The query may contain placeholders for binding values. Both Oracle style colon-name (e.g., &lt;code&gt;:surname&lt;/code&gt;), and ODBC style (&lt;code&gt;?&lt;/code&gt;) placeholders are supported; but they cannot be mixed in the same query. See the &lt;a href=&quot;qsqlquery#qsqlquery-examples&quot;&gt;Detailed Description&lt;/a&gt; for examples.</source>
          <target state="translated">쿼리에는 값을 바인딩하기위한 자리 표시자가 포함될 수 있습니다. Oracle 스타일 콜론 이름 (예 &lt;code&gt;:surname&lt;/code&gt; ) 및 ODBC 스타일 ( &lt;code&gt;?&lt;/code&gt; ) 플레이스 홀더가 모두 지원됩니다. 그러나 동일한 쿼리에서 혼합 될 수 없습니다. 예 는 &lt;a href=&quot;qsqlquery#qsqlquery-examples&quot;&gt;자세한 설명&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abc33ec1a6cbf405f8ca29df5cf475064663b40c" translate="yes" xml:space="preserve">
          <source>The query must evaluate to a sequence of &lt;code&gt;xs:string&lt;/code&gt; values. If the query does not evaluate to a sequence of strings, the values can often be converted by adding a call to &lt;code&gt;string()&lt;/code&gt; at the end of the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt;.</source>
          <target state="translated">쿼리는 일련의 &lt;code&gt;xs:string&lt;/code&gt; 값으로 평가되어야 합니다. 쿼리가 일련의 문자열로 평가되지 않으면 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 끝에 &lt;code&gt;string()&lt;/code&gt; 에 대한 호출을 추가하여 값을 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5503c6a7b6b39e96da6b83f5cacd55b3880e3ba4" translate="yes" xml:space="preserve">
          <source>The query part of the URL (following a '?' character) is removed.</source>
          <target state="translated">URL의 쿼리 부분 ( '?'문자 뒤)이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="18a6dcdc67ebf52344bfceb4293eb9dc6cf53110" translate="yes" xml:space="preserve">
          <source>The queue operates according to the FIFO principle.</source>
          <target state="translated">대기열은 FIFO 원칙에 따라 작동합니다.</target>
        </trans-unit>
        <trans-unit id="747430c02d70a6e66176ddd5fb4df524af9ac6d5" translate="yes" xml:space="preserve">
          <source>The quick answer is you probably expected your &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; FLWOR to behave just like a C++</source>
          <target state="translated">빠른 답변은 아마도 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; FLWOR가 C ++처럼 작동 할 것으로 예상 한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="021b66c2f450625978f0f30d14db15ed0a0ce22b" translate="yes" xml:space="preserve">
          <source>The quoted text is treated as a single item in the list of values held by the variable. A similar approach is used to deal with paths that contain spaces, particularly when defining the &lt;a href=&quot;qmake-variable-reference#includepath&quot;&gt;INCLUDEPATH&lt;/a&gt; and &lt;a href=&quot;qmake-variable-reference#libs&quot;&gt;LIBS&lt;/a&gt; variables for the Windows platform:</source>
          <target state="translated">인용 된 텍스트는 변수가 보유한 값 목록에서 단일 항목으로 취급됩니다. 특히 Windows 플랫폼에 대해 &lt;a href=&quot;qmake-variable-reference#includepath&quot;&gt;INCLUDEPATH&lt;/a&gt; 및 &lt;a href=&quot;qmake-variable-reference#libs&quot;&gt;LIBS&lt;/a&gt; 변수를 정의 할 때 공백이 포함 된 경로를 처리하는 데 유사한 방법이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c8dff97572bfaef45151f71747ee3e00411e6c8d" translate="yes" xml:space="preserve">
          <source>The radial axis used for the series, drawn inside the polar chart view.</source>
          <target state="translated">극좌표 형 차트 뷰 내에 그려진 시리즈에 사용되는 방사형 축입니다.</target>
        </trans-unit>
        <trans-unit id="51464b7c75628735ad2877ba6e73ac4e0862fdff" translate="yes" xml:space="preserve">
          <source>The radio data interface is available to use</source>
          <target state="translated">무선 데이터 인터페이스를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4ad23535fdc4d3c3e2fdfb754ba9dd5a7b6af0e7" translate="yes" xml:space="preserve">
          <source>The radio data interface is not available to use (there may be no radio hardware)</source>
          <target state="translated">무선 데이터 인터페이스를 사용할 수 없습니다 (무선 하드웨어가 없을 수 있음)</target>
        </trans-unit>
        <trans-unit id="1911686dfe25cd78698fec2d12a7383e952a4ec8" translate="yes" xml:space="preserve">
          <source>The radio data interface is usually available to use, but is currently busy.</source>
          <target state="translated">라디오 데이터 인터페이스는 일반적으로 사용 가능하지만 현재 사용 중입니다.</target>
        </trans-unit>
        <trans-unit id="5d17f8ec378bfdcdefdabd0eb5728d109a3181c2" translate="yes" xml:space="preserve">
          <source>The radio data object will emit signals for any changes in radio data. You can enable or disable alternative frequency with &lt;a href=&quot;qradiodata#alternativeFrequenciesEnabled-prop&quot;&gt;setAlternativeFrequenciesEnabled&lt;/a&gt;().</source>
          <target state="translated">라디오 데이터 객체는 라디오 데이터의 변경 사항에 대한 신호를 방출합니다. &lt;a href=&quot;qradiodata#alternativeFrequenciesEnabled-prop&quot;&gt;setAlternativeFrequenciesEnabled&lt;/a&gt; ()를 사용하여 대체 주파수를 활성화하거나 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e0e98dcdf4813e89e07b6973f34312e21910766" translate="yes" xml:space="preserve">
          <source>The radio is available to use</source>
          <target state="translated">라디오를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="402d3ec3cf50b57cb6d68c32010965699d228b5e" translate="yes" xml:space="preserve">
          <source>The radio is not available to use (there may be no radio hardware)</source>
          <target state="translated">라디오를 사용할 수 없습니다 (무선 하드웨어가 없을 수 있음)</target>
        </trans-unit>
        <trans-unit id="c132372aeba6fd972ebaac8a8994655d63e936d2" translate="yes" xml:space="preserve">
          <source>The radio is started and active</source>
          <target state="translated">라디오가 시작되고 활성화되었습니다</target>
        </trans-unit>
        <trans-unit id="c5542637563cae3f2b9747e6d657f49f429f05de" translate="yes" xml:space="preserve">
          <source>The radio is stopped</source>
          <target state="translated">라디오가 멈췄다</target>
        </trans-unit>
        <trans-unit id="b4833184ee147ab64ac23f770a608e436b07ae1d" translate="yes" xml:space="preserve">
          <source>The radio is usually available to use, but is currently busy. This can happen when some other process needs to use the audio hardware.</source>
          <target state="translated">라디오는 일반적으로 사용 가능하지만 현재 사용 중입니다. 다른 프로세스에서 오디오 하드웨어를 사용해야 할 때 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb34e970d370fa01f584b759df0a0e617a41dbfe" translate="yes" xml:space="preserve">
          <source>The radio object will emit signals for any changes in state such as: &lt;a href=&quot;qradiotuner#bandChanged&quot;&gt;bandChanged&lt;/a&gt;(), &lt;a href=&quot;qradiotuner#frequencyChanged&quot;&gt;frequencyChanged&lt;/a&gt;(), &lt;a href=&quot;qradiotuner#stereoStatusChanged&quot;&gt;stereoStatusChanged&lt;/a&gt;(), &lt;a href=&quot;qradiotuner#searchingChanged&quot;&gt;searchingChanged&lt;/a&gt;(), &lt;a href=&quot;qradiotuner#signalStrengthChanged&quot;&gt;signalStrengthChanged&lt;/a&gt;(), &lt;a href=&quot;qradiotuner#volumeChanged&quot;&gt;volumeChanged&lt;/a&gt;(), &lt;a href=&quot;qradiotuner#mutedChanged&quot;&gt;mutedChanged&lt;/a&gt;().</source>
          <target state="translated">라디오 객체는 &lt;a href=&quot;qradiotuner#bandChanged&quot;&gt;bandChanged&lt;/a&gt; (), &lt;a href=&quot;qradiotuner#frequencyChanged&quot;&gt;frequencyChanged&lt;/a&gt; (), &lt;a href=&quot;qradiotuner#stereoStatusChanged&quot;&gt;stereoStatusChanged&lt;/a&gt; (), &lt;a href=&quot;qradiotuner#searchingChanged&quot;&gt;searchingChanged&lt;/a&gt; (), &lt;a href=&quot;qradiotuner#signalStrengthChanged&quot;&gt;signalStrengthChanged&lt;/a&gt; (), &lt;a href=&quot;qradiotuner#volumeChanged&quot;&gt;volumeChanged&lt;/a&gt; (), &lt;a href=&quot;qradiotuner#mutedChanged&quot;&gt;mutedChanged&lt;/a&gt; () 와 같은 상태 변화에 대한 신호를 방출합니다 .</target>
        </trans-unit>
        <trans-unit id="5428a5c95565db02f7395264f650dcfac5b84374" translate="yes" xml:space="preserve">
          <source>The radius for the bottom-left rounded corner of the outline.</source>
          <target state="translated">윤곽선의 왼쪽 하단 둥근 모서리의 반경입니다.</target>
        </trans-unit>
        <trans-unit id="10fd0fa335628d787c3afd75020c5c59c9c516b6" translate="yes" xml:space="preserve">
          <source>The radius for the bottom-right rounded corner of the outline.</source>
          <target state="translated">윤곽선의 오른쪽 아래 모서리의 반경입니다.</target>
        </trans-unit>
        <trans-unit id="2ad3bd5122a70615ab0864e610908093a11b0100" translate="yes" xml:space="preserve">
          <source>The radius for the top-left corner of the outline.</source>
          <target state="translated">윤곽선의 왼쪽 상단 모서리에 대한 반경입니다.</target>
        </trans-unit>
        <trans-unit id="2c121441b9a644ccb1535b1c2927e6e1ed58594b" translate="yes" xml:space="preserve">
          <source>The radius for the top-right rounded corner of the outline.</source>
          <target state="translated">윤곽선의 오른쪽 상단 모서리에 대한 반경입니다.</target>
        </trans-unit>
        <trans-unit id="1178f627d0db6416b46b85091114b3879b8a5fef" translate="yes" xml:space="preserve">
          <source>The radius is given in device coordinates, meaning it is unaffected by scale.</source>
          <target state="translated">반지름은 장치 좌표로 제공되며 이는 스케일의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5bbda9fa291be4b51596d70f6447ed7a3e54e3e" translate="yes" xml:space="preserve">
          <source>The radius of the area that is used to cancel the menu.</source>
          <target state="translated">메뉴를 취소하는 데 사용되는 영역의 반경입니다.</target>
        </trans-unit>
        <trans-unit id="0d0af8ddce6e7824e415b7082a58567a305ddcdc" translate="yes" xml:space="preserve">
          <source>The radius of the border's bottom-left corner. Setting this property to a positive value results in a rounded corner.</source>
          <target state="translated">테두리 왼쪽 아래 모서리의 반경입니다. 이 속성을 양수 값으로 설정하면 모서리가 둥글게됩니다.</target>
        </trans-unit>
        <trans-unit id="e320f88cfd63a10cf38338277ed58ac8da069181" translate="yes" xml:space="preserve">
          <source>The radius of the border's bottom-right corner. Setting this property to a positive value results in a rounded corner.</source>
          <target state="translated">테두리 오른쪽 하단 모서리의 반경입니다. 이 속성을 양수 값으로 설정하면 모서리가 둥글게됩니다.</target>
        </trans-unit>
        <trans-unit id="258a52fa378c16469441a07ddfd92e420d237bee" translate="yes" xml:space="preserve">
          <source>The radius of the border's corners. Equivalent to specifying &lt;code&gt;border-top-left-radius&lt;/code&gt;, &lt;code&gt;border-top-right-radius&lt;/code&gt;, &lt;code&gt;border-bottom-right-radius&lt;/code&gt;, and &lt;code&gt;border-bottom-left-radius&lt;/code&gt;.</source>
          <target state="translated">테두리 모서리의 반경입니다. &lt;code&gt;border-top-left-radius&lt;/code&gt; , &lt;code&gt;border-top-right-radius&lt;/code&gt; , &lt;code&gt;border-bottom-right-radius&lt;/code&gt; 및 &lt;code&gt;border-bottom-left-radius&lt;/code&gt; 를 지정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a95545e52353bc16cc0ecbd058fefd094a4e495b" translate="yes" xml:space="preserve">
          <source>The radius of the border's top-left corner.</source>
          <target state="translated">테두리 왼쪽 위 모서리의 반경입니다.</target>
        </trans-unit>
        <trans-unit id="709377fda9805f43e825b1f169ca917281cf6d24" translate="yes" xml:space="preserve">
          <source>The radius of the border's top-right corner.</source>
          <target state="translated">테두리 오른쪽 위 모서리의 반경입니다.</target>
        </trans-unit>
        <trans-unit id="da50a020dfe57ad1f4c718da2702420094b4954a" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first,last)&lt;/code&gt; must remain valid for the lifetime of this Latin-1 string object.</source>
          <target state="translated">범위 &lt;code&gt;[first,last)&lt;/code&gt; 는이 Latin-1 문자열 객체의 수명 동안 유효해야합니다.</target>
        </trans-unit>
        <trans-unit id="e0738a948429ac27495750a9ff0004664c04ddd0" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[first,last)&lt;/code&gt; must remain valid for the lifetime of this string view object.</source>
          <target state="translated">&lt;code&gt;[first,last)&lt;/code&gt; 범위 는이 문자열 뷰 객체의 수명 동안 유효해야합니다.</target>
        </trans-unit>
        <trans-unit id="beac7a55ca55967ee50775926befaecc075b0b29" translate="yes" xml:space="preserve">
          <source>The range &lt;code&gt;[str,len)&lt;/code&gt; must remain valid for the lifetime of this string view object.</source>
          <target state="translated">&lt;code&gt;[str,len)&lt;/code&gt; 범위 는이 문자열 뷰 객체의 수명 동안 유효해야합니다.</target>
        </trans-unit>
        <trans-unit id="d73c439d2532386ec37fdfc7c6cf8621e7b54d55" translate="yes" xml:space="preserve">
          <source>The range between &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle#minimumValueAngle-prop&quot;&gt;minimumValueAngle&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle#maximumValueAngle-prop&quot;&gt;maximumValueAngle&lt;/a&gt;, in degrees. This value will always be positive.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle#minimumValueAngle-prop&quot;&gt;minimumValueAngle&lt;/a&gt; 과 &lt;a href=&quot;qml-qtquick-controls-styles-circulargaugestyle#maximumValueAngle-prop&quot;&gt;maximumValueAngle&lt;/a&gt; 사이의 범위 ( 도)입니다. 이 값은 항상 양수입니다.</target>
        </trans-unit>
        <trans-unit id="eac3108b73e01f5c80a4cb1cc35a9a1293a363f4" translate="yes" xml:space="preserve">
          <source>The range is from 0 (the beginning of the string) to the length of the string inclusive.</source>
          <target state="translated">범위는 0 (문자열의 시작)에서 문자열의 길이까지입니다.</target>
        </trans-unit>
        <trans-unit id="b8a9a17bb5c7143a5e122a3457e11df36373f5be" translate="yes" xml:space="preserve">
          <source>The range is from &lt;code&gt;-140&lt;/code&gt; degrees to &lt;code&gt;140&lt;/code&gt; degrees.</source>
          <target state="translated">범위는 &lt;code&gt;-140&lt;/code&gt; 도에서 &lt;code&gt;140&lt;/code&gt; 도입니다.</target>
        </trans-unit>
        <trans-unit id="d7077084adb5192cadc626ff09328d970acd7e6e" translate="yes" xml:space="preserve">
          <source>The range of dates able to be stored by &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; as a Julian Day number is for technical reasons limited to between -784350574879 and 784354017364, which means from before 2 billion BCE to after 2 billion CE.</source>
          <target state="translated">&lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 가 Julian Day 번호로 저장할 수있는 날짜 범위는 기술적 인 이유로 -784350574879와 784354017364 사이로 제한되어 있습니다. 이는 기원전 20 억에서 20 억 사이에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="e8fbc6a6e2de12366bd1d1a64f28c3352dfefe41" translate="yes" xml:space="preserve">
          <source>The range of valid dates taking DST into account is 1970-01-01 to the present, and rules are in place for handling DST correctly until 2037-12-31, but these could change. For dates falling outside that range, &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; makes a</source>
          <target state="translated">DST를 고려한 유효한 날짜 범위는 현재 1970-01-01이며 2037-12-31까지 DST를 올바르게 처리하기위한 규칙이 있지만 변경 될 수 있습니다. 해당 범위를 벗어나는 날짜의 경우 &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; 은</target>
        </trans-unit>
        <trans-unit id="b5a3f0fe9d1b437f0c98c9ce11689e610bb3f7db" translate="yes" xml:space="preserve">
          <source>The range of valid indexes for the &lt;a href=&quot;qcontiguouscache&quot;&gt;QContiguousCache&lt;/a&gt; class are from 0 to INT_MAX. Calling &lt;a href=&quot;qcontiguouscache#prepend&quot;&gt;prepend&lt;/a&gt;() such that the first index would become less than 0 or &lt;a href=&quot;qcontiguouscache#append&quot;&gt;append&lt;/a&gt;() such that the last index would become greater than INT_MAX can result in the indexes of the cache being invalid. When the cache indexes are invalid it is important to call &lt;a href=&quot;qcontiguouscache#normalizeIndexes&quot;&gt;normalizeIndexes&lt;/a&gt;() before calling any of &lt;a href=&quot;qcontiguouscache#containsIndex&quot;&gt;containsIndex&lt;/a&gt;(), &lt;a href=&quot;qcontiguouscache#firstIndex&quot;&gt;firstIndex&lt;/a&gt;(), &lt;a href=&quot;qcontiguouscache#lastIndex&quot;&gt;lastIndex&lt;/a&gt;(), &lt;a href=&quot;qcontiguouscache#at&quot;&gt;at&lt;/a&gt;() or &lt;a href=&quot;qcontiguouscache#operator-5b-5d&quot;&gt;operator[]&lt;/a&gt;(). Calling these functions when the cache has invalid indexes will result in undefined behavior. The indexes can be checked by using &lt;a href=&quot;qcontiguouscache#areIndexesValid&quot;&gt;areIndexesValid&lt;/a&gt;()</source>
          <target state="translated">&lt;a href=&quot;qcontiguouscache&quot;&gt;QContiguousCache&lt;/a&gt; 클래스 의 유효한 인덱스 범위는 0에서 INT_MAX입니다. 첫 번째 인덱스가 0보다 작아 &lt;a href=&quot;qcontiguouscache#prepend&quot;&gt;지도록 prepend&lt;/a&gt; ()를 호출 하거나 마지막 인덱스가 INT_MAX보다 커지도록 &lt;a href=&quot;qcontiguouscache#append&quot;&gt;append&lt;/a&gt; ()를 호출 하면 캐시의 인덱스가 유효하지 않을 수 있습니다. 캐시 인덱스가 유효하지 않은 경우 &lt;a href=&quot;qcontiguouscache#containsIndex&quot;&gt;containsIndex&lt;/a&gt; (), &lt;a href=&quot;qcontiguouscache#firstIndex&quot;&gt;firstIndex&lt;/a&gt; (), &lt;a href=&quot;qcontiguouscache#lastIndex&quot;&gt;lastIndex&lt;/a&gt; (), &lt;a href=&quot;qcontiguouscache#at&quot;&gt;at&lt;/a&gt; () 또는 &lt;a href=&quot;qcontiguouscache#operator-5b-5d&quot;&gt;operator []&lt;/a&gt; () 를 호출하기 전에 &lt;a href=&quot;qcontiguouscache#normalizeIndexes&quot;&gt;normalizeIndexes&lt;/a&gt; () 를 호출하는 것이 중요합니다 . 캐시에 유효하지 않은 인덱스가있을 때이 함수를 호출하면 정의되지 않은 동작이 발생합니다. &lt;a href=&quot;qcontiguouscache#areIndexesValid&quot;&gt;areIndexesValid&lt;/a&gt; 를 사용하여 인덱스를 확인할 수 있습니다.()</target>
        </trans-unit>
        <trans-unit id="3f1c97d1623623d52a317c3a6b3d3021449cf3ea" translate="yes" xml:space="preserve">
          <source>The range of valid indexes for the &lt;a href=&quot;qcontiguouscache&quot;&gt;QContiguousCache&lt;/a&gt; class are from 0 to INT_MAX. Inserting outside of this range has undefined behavior.</source>
          <target state="translated">&lt;a href=&quot;qcontiguouscache&quot;&gt;QContiguousCache&lt;/a&gt; 클래스 의 유효한 인덱스 범위는 0에서 INT_MAX입니다. 이 범위 밖에 삽입하면 정의되지 않은 동작이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7825afd94a63848779aacd792309a99b2fc8177a" translate="yes" xml:space="preserve">
          <source>The range of values specified for the scroll bar are often determined differently to those for a &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; because the length of the slider needs to be taken into account. If we have a document with 100 lines, and we can only show 20 lines in a widget, we may wish to construct a scroll bar with a page step of 20, a minimum value of 0, and a maximum value of 80. This would give us a scroll bar with five &quot;pages&quot;.</source>
          <target state="translated">슬라이더의 길이를 고려해야하기 때문에 스크롤 막대에 지정된 값의 범위는 종종 &lt;a href=&quot;qslider&quot;&gt;QSlider&lt;/a&gt; 의 값과 다르게 결정 됩니다. 100 줄의 문서가 있고 위젯에 20 줄만 표시 할 수있는 경우 페이지 단계 20, 최소값 0 및 최대 값 80으로 스크롤 막대를 구성 할 수 있습니다. 5 개의 &quot;페이지&quot;가있는 스크롤 막대를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="bcfa72b05f0821c8e9d827b22be32a43d9b28596" translate="yes" xml:space="preserve">
          <source>The range of values that &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; can represent is dependent on the internal storage implementation. &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; is currently stored in a qint64 as a serial msecs value encoding the date and time. This restricts the date range to about +/- 292 million years, compared to the &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; range of +/- 2 billion years. Care must be taken when creating a &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; with extreme values that you do not overflow the storage. The exact range of supported values varies depending on the &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::TimeSpec&lt;/a&gt; and time zone.</source>
          <target state="translated">&lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; 이 나타낼 수 있는 값의 범위 는 내부 스토리지 구현에 따라 다릅니다. &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; 은 현재 날짜와 시간을 인코딩하는 직렬 msec 값으로 qint64에 저장됩니다. &lt;a href=&quot;qdate&quot;&gt;QDate&lt;/a&gt; 범위 +/- 20 억 년에 비해 날짜 범위가 약 +/- 2 억 9 천 2 백만 년으로 제한됩니다. 스토리지를 오버 플로우하지 않는 극단적 인 값 으로 &lt;a href=&quot;qdatetime&quot;&gt;QDateTime&lt;/a&gt; 을 작성할 때주의해야합니다 . 지원되는 값의 정확한 범위는 &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt :: TimeSpec&lt;/a&gt; 및 시간대 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="962de02e8504d092a7b596b0c569568b282abd47" translate="yes" xml:space="preserve">
          <source>The rate at which audio is played at as a multiple of the normal rate.</source>
          <target state="translated">오디오가 일반 속도의 배수로 재생되는 속도입니다.</target>
        </trans-unit>
        <trans-unit id="4d3be7880d156f2ffcc5fbb37e642e69632c92b4" translate="yes" xml:space="preserve">
          <source>The rating that the reviewer gave to the place.</source>
          <target state="translated">검토자가 해당 장소에 부여한 평가입니다.</target>
        </trans-unit>
        <trans-unit id="b492f535847ea5155703b1e3a3ff09b0e6b959a8" translate="yes" xml:space="preserve">
          <source>The ratio between physical pixels and device-independent pixels for the screen.</source>
          <target state="translated">화면의 실제 픽셀과 장치 독립적 픽셀 간의 비율입니다.</target>
        </trans-unit>
        <trans-unit id="3cca1d707d53a48be4b6de9d06de6049766ce5c9" translate="yes" xml:space="preserve">
          <source>The ratio of the graph scaling between the longest axis on the horizontal plane and the y-axis. Defaults to &lt;code&gt;2.0&lt;/code&gt;.</source>
          <target state="translated">수평면에서 가장 긴 축과 y 축 사이의 그래프 배율 비율입니다. 기본값은 &lt;code&gt;2.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8a4d12eafa94bbc13fb8c8584c378653412ccddb" translate="yes" xml:space="preserve">
          <source>The ratio of the graph scaling between the x-axis and z-axis. The value of &lt;code&gt;0.0&lt;/code&gt; indicates automatic scaling according to axis ranges. Defaults to &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">x 축과 z 축 사이의 그래프 배율 비율입니다. &lt;code&gt;0.0&lt;/code&gt; 값은 축 범위에 따른 자동 스케일링을 나타냅니다. 기본값은 &lt;code&gt;0.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="278bac1866e19ebdf8c90acd3d09e9fb8d7514b9" translate="yes" xml:space="preserve">
          <source>The rationale behind this mechanism is to make it possible to synchronize user interaction during a shutdown. Advanced session managers may ask all applications simultaneously to commit their data, resulting in a much faster shutdown.</source>
          <target state="translated">이 메커니즘의 근거는 종료 중에 사용자 상호 작용을 동기화 할 수 있도록하는 것입니다. 고급 세션 관리자는 모든 응용 프로그램에 동시에 데이터를 커밋하도록 요청하여 훨씬 빨리 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="6f4c886e05a39053d11bb92e7ce2bb293cd89803" translate="yes" xml:space="preserve">
          <source>The raw XML attribute name is returned as &lt;a href=&quot;qxmlstreamattribute#qualifiedName&quot;&gt;qualifiedName&lt;/a&gt;().</source>
          <target state="translated">원시 XML 속성 이름은 &lt;a href=&quot;qxmlstreamattribute#qualifiedName&quot;&gt;QualifiedName&lt;/a&gt; ()으로 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="e2f6b1743d14df08f6365d86ae08a8fe50f969d6" translate="yes" xml:space="preserve">
          <source>The read-only model shows how simple choices could be presented to the user but, for many applications, an editable list model is much more useful. We can modify the read-only model to make the items editable by changing the data() function we implemented for read-only, and by implementing two extra functions: &lt;a href=&quot;qabstractitemmodel#flags&quot;&gt;flags()&lt;/a&gt; and &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData()&lt;/a&gt;. The following function declarations are added to the class definition:</source>
          <target state="translated">읽기 전용 모델은 간단한 선택을 사용자에게 제시하는 방법을 보여 주지만 많은 응용 프로그램에서 편집 가능한 목록 모델이 훨씬 유용합니다. 읽기 전용 모델을 수정하여 읽기 전용으로 구현 한 data () 함수를 변경하고 &lt;a href=&quot;qabstractitemmodel#flags&quot;&gt;flags ()&lt;/a&gt; 및 &lt;a href=&quot;qabstractitemmodel#setData&quot;&gt;setData ()의&lt;/a&gt; 두 가지 추가 함수를 구현하여 항목을 편집 가능하게 만들 수 있습니다 . 다음 함수 선언이 클래스 정의에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="cb036b42d4ed59062c2bbde4b0639e3390682e0c" translate="yes" xml:space="preserve">
          <source>The reader calls this function after it has finished parsing. It is called just once, and is the last handler function called. It is called after the reader has read all input or has abandoned parsing because of a fatal error.</source>
          <target state="translated">리더는 구문 분석을 마친 후에이 함수를 호출합니다. 한 번만 호출되며 마지막으로 호출 된 핸들러 함수입니다. 리더가 치명적인 오류로 인해 모든 입력을 읽거나 구문 분석을 포기한 후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3a8b1b36b2b039da8f3c6031cf0ca9d0a3f558a0" translate="yes" xml:space="preserve">
          <source>The reader calls this function before it opens any external entity, except the top-level document entity. The application may request the reader to resolve the entity itself (</source>
          <target state="translated">독자는 최상위 문서 엔티티를 제외한 외부 엔티티를 열기 전에이 함수를 호출합니다. 응용 프로그램은 독자에게 엔티티 자체를 해결하도록 요청할 수 있습니다 (</target>
        </trans-unit>
        <trans-unit id="9f100a29b6877267d435b6c73b8d80996a00de9e" translate="yes" xml:space="preserve">
          <source>The reader calls this function before it starts parsing the document. The argument</source>
          <target state="translated">독자는 문서 파싱을 시작하기 전에이 함수를 호출합니다. 논쟁 거리</target>
        </trans-unit>
        <trans-unit id="7d4684ab6bf3e0e4afa59ecf426aa58b4b5bf320" translate="yes" xml:space="preserve">
          <source>The reader calls this function to get an error string if any of the handler functions returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">처리기 함수 중 하나가 &lt;code&gt;false&lt;/code&gt; 를 반환하면 판독기는이 함수를 호출하여 오류 문자열을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="59c3416bfc1f7867baa8f30cb785f0c4ca1fb891" translate="yes" xml:space="preserve">
          <source>The reader calls this function to get an error string, e.g. if any of the handler functions returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">판독기는이 함수를 호출하여 오류 문자열을 가져옵니다 (예 : 핸들러 함수 중 하나가 &lt;code&gt;false&lt;/code&gt; 를 반환하는 경우) .</target>
        </trans-unit>
        <trans-unit id="d54288793e5ccd13b0a0f3851298324f666d4ee2" translate="yes" xml:space="preserve">
          <source>The reader calls this function to report a parsed external entity declaration. Only the effective (first) declaration for each entity is reported.</source>
          <target state="translated">독자는이 함수를 호출하여 구문 분석 된 외부 엔티티 선언을보고합니다. 각 엔터티에 대한 효과적인 (첫 번째) 선언 만보고됩니다.</target>
        </trans-unit>
        <trans-unit id="1fbf0deca42d555adf081675f9c084c6b01bad10" translate="yes" xml:space="preserve">
          <source>The reader calls this function to report an XML comment anywhere in the document. It reports the text of the comment in</source>
          <target state="translated">독자는이 함수를 호출하여 문서의 어느 곳에서나 XML 주석을보고합니다. 주석의 텍스트를</target>
        </trans-unit>
        <trans-unit id="0ca26c773e70537db6c129d451d898c0a7872788" translate="yes" xml:space="preserve">
          <source>The reader calls this function to report an attribute type declaration. Only the effective (first) declaration for an attribute is reported.</source>
          <target state="translated">독자는이 함수를 호출하여 속성 유형 선언을보고합니다. 속성에 대한 효과적인 (첫 번째) 선언 만보고됩니다.</target>
        </trans-unit>
        <trans-unit id="e233eb283b901b43c38714e5e83919343a937f45" translate="yes" xml:space="preserve">
          <source>The reader calls this function to report an internal entity declaration. Only the effective (first) declaration is reported.</source>
          <target state="translated">독자는이 함수를 호출하여 내부 엔티티 선언을보고합니다. 유효 (첫 번째) 선언 만보고됩니다.</target>
        </trans-unit>
        <trans-unit id="f78c0f1f539df9e98252167ce46a32931689b7df" translate="yes" xml:space="preserve">
          <source>The reader calls this function to report the end of a CDATA section.</source>
          <target state="translated">독자는이 함수를 호출하여 CDATA 섹션의 끝을보고합니다.</target>
        </trans-unit>
        <trans-unit id="18c91b265b8a113f8decf0a070d7dd2f62fd1716" translate="yes" xml:space="preserve">
          <source>The reader calls this function to report the end of a DTD declaration, if any.</source>
          <target state="translated">독자는이 함수를 호출하여 DTD 선언의 끝을보고합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="810a1c6bd956fb49757387ac1989ce869ddb6096" translate="yes" xml:space="preserve">
          <source>The reader calls this function to report the end of an entity called</source>
          <target state="translated">독자는이 함수를 호출하여 호출 된 엔티티의 끝을보고합니다.</target>
        </trans-unit>
        <trans-unit id="4f36a5cd9516450a0cccf65ebe19f9b83bc94073" translate="yes" xml:space="preserve">
          <source>The reader calls this function to report the start of a CDATA section. The content of the CDATA section is reported through the &lt;a href=&quot;qxmlcontenthandler#characters&quot;&gt;QXmlContentHandler::characters&lt;/a&gt;() function. This function is intended only to report the boundary.</source>
          <target state="translated">독자는이 함수를 호출하여 CDATA 섹션의 시작을보고합니다. CDATA 섹션의 내용은 &lt;a href=&quot;qxmlcontenthandler#characters&quot;&gt;QXmlContentHandler :: characters&lt;/a&gt; () 함수를 통해보고됩니다 . 이 기능은 경계를보고하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="774100d0a163dd1373dda8b655894ef9496178f3" translate="yes" xml:space="preserve">
          <source>The reader calls this function to report the start of a DTD declaration, if any. It reports the name of the document type in</source>
          <target state="translated">독자는이 함수를 호출하여 DTD 선언의 시작을보고합니다 (있는 경우). 문서 유형의 이름을</target>
        </trans-unit>
        <trans-unit id="75519efc3f32979aa9094430cd77278b05cf0357" translate="yes" xml:space="preserve">
          <source>The reader calls this function to report the start of an entity called</source>
          <target state="translated">독자는이 함수를 호출하여 호출 된 엔티티의 시작을보고합니다.</target>
        </trans-unit>
        <trans-unit id="2b87088e31a84a1c00fda65552d8e49435b5b241" translate="yes" xml:space="preserve">
          <source>The reader calls this function to signal the begin of a prefix-URI namespace mapping scope. This information is not necessary for normal namespace processing since the reader automatically replaces prefixes for element and attribute names.</source>
          <target state="translated">독자는이 함수를 호출하여 접두사 URI 네임 스페이스 매핑 범위의 시작을 알립니다. 판독기는 요소 및 속성 이름의 접두사를 자동으로 대체하므로이 정보는 일반적인 네임 스페이스 처리에 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36dee23e738801b10093189198ac47c34754a2a9" translate="yes" xml:space="preserve">
          <source>The reader calls this function to signal the end of a prefix mapping for the prefix</source>
          <target state="translated">독자는이 함수를 호출하여 접두사에 대한 접두사 매핑의 끝을 알립니다.</target>
        </trans-unit>
        <trans-unit id="ef01ce4148d849f05df2ed061248536d409fe5de" translate="yes" xml:space="preserve">
          <source>The reader calls this function when it finds an unparsed entity declaration.</source>
          <target state="translated">독자는 구문 분석되지 않은 엔티티 선언을 찾으면이 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="2919f9bfadef86234f57e932bdf2150a0d55c30a" translate="yes" xml:space="preserve">
          <source>The reader calls this function when it has parsed a chunk of character data (either normal character data or character data inside a CDATA section; if you need to distinguish between those two types you must use &lt;a href=&quot;qxmllexicalhandler#startCDATA&quot;&gt;QXmlLexicalHandler::startCDATA&lt;/a&gt;() and &lt;a href=&quot;qxmllexicalhandler#endCDATA&quot;&gt;QXmlLexicalHandler::endCDATA&lt;/a&gt;()). The character data is reported in</source>
          <target state="translated">독자는 문자 데이터 (일반 문자 데이터 또는 CDATA 섹션 내의 문자 데이터)를 구문 분석 할 때이 함수를 호출합니다.이 두 유형을 구별해야하는 경우 &lt;a href=&quot;qxmllexicalhandler#startCDATA&quot;&gt;QXmlLexicalHandler :: startCDATA&lt;/a&gt; () 및 &lt;a href=&quot;qxmllexicalhandler#endCDATA&quot;&gt;QXmlLexicalHandler :: endCDATA&lt;/a&gt; 를 사용해야합니다. ()). 문자 데이터는</target>
        </trans-unit>
        <trans-unit id="b9b10ff960c5f25977e2882c845e964a4f5e0013" translate="yes" xml:space="preserve">
          <source>The reader calls this function when it has parsed a notation declaration.</source>
          <target state="translated">독자는 표기법 선언을 구문 분석 할 때이 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="62a136241549a0c2e475f47ff7314ae6fdfac4c4" translate="yes" xml:space="preserve">
          <source>The reader calls this function when it has parsed a processing instruction.</source>
          <target state="translated">리더는 처리 명령을 구문 분석 할 때이 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="51367f233bd900277949969e38bd3fe63d3a028c" translate="yes" xml:space="preserve">
          <source>The reader calls this function when it has parsed a start element tag.</source>
          <target state="translated">리더는 시작 요소 태그를 구문 분석 할 때이 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="631268ef29fb3f55e9a5ff9e8a48f479b8163025" translate="yes" xml:space="preserve">
          <source>The reader calls this function when it has parsed an end element tag with the qualified name</source>
          <target state="translated">독자는 규정 된 이름으로 종료 요소 태그를 구문 분석 할 때이 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="489fa7a9e474821a804ece25d788fa082e95f431" translate="yes" xml:space="preserve">
          <source>The reader calls this function when it starts parsing the document. The reader calls this function just once, after the call to &lt;a href=&quot;qxmlcontenthandler#setDocumentLocator&quot;&gt;setDocumentLocator&lt;/a&gt;(), and before any other functions in this class or in the &lt;a href=&quot;qxmldtdhandler&quot;&gt;QXmlDTDHandler&lt;/a&gt; class are called.</source>
          <target state="translated">독자는 문서 파싱을 시작할 때이 함수를 호출합니다. 리더는 &lt;a href=&quot;qxmlcontenthandler#setDocumentLocator&quot;&gt;setDocumentLocator&lt;/a&gt; () 호출 &lt;a href=&quot;qxmldtdhandler&quot;&gt;후이&lt;/a&gt; 클래스 또는 QXmlDTDHandler 클래스의 다른 함수가 호출 되기 전에이 함수를 한 번만 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ebbeb52e48afea3c5137eb5faa2ced7f5c4cf97d" translate="yes" xml:space="preserve">
          <source>The reader deletes the input source</source>
          <target state="translated">리더가 입력 소스를 삭제합니다</target>
        </trans-unit>
        <trans-unit id="99aead4ab38b94913a79eb14df73011e4955b58a" translate="yes" xml:space="preserve">
          <source>The reader has not yet read anything.</source>
          <target state="translated">독자는 아직 아무것도 읽지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="daa0f992eb4bd988a07091bfb871798ee8b0f54f" translate="yes" xml:space="preserve">
          <source>The reader must continue to provide normal parsing events after invoking this function.</source>
          <target state="translated">독자는이 기능을 호출 한 후 정상적인 구문 분석 이벤트를 계속 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="0796564aef4144d30e930ffcce6c398b46483225" translate="yes" xml:space="preserve">
          <source>The reader passes the name of the associated element in</source>
          <target state="translated">독자는 관련 요소의 이름을</target>
        </trans-unit>
        <trans-unit id="89b491baa56103918ae9f3fad27d065bc8d549c9" translate="yes" xml:space="preserve">
          <source>The reader passes the name of the entity in</source>
          <target state="translated">독자는 엔티티의 이름을</target>
        </trans-unit>
        <trans-unit id="c47379afdb49de60f5b35a5b1b15b6e9cbf4f959" translate="yes" xml:space="preserve">
          <source>The reader reports a &lt;a href=&quot;qxmllocator&quot;&gt;QXmlLocator&lt;/a&gt; to the content handler before it starts to parse the document. This is done with the &lt;a href=&quot;qxmlcontenthandler#setDocumentLocator&quot;&gt;QXmlContentHandler::setDocumentLocator&lt;/a&gt;() function. The handler classes can now use this locator to get the position (&lt;a href=&quot;qxmllocator#lineNumber&quot;&gt;lineNumber&lt;/a&gt;() and &lt;a href=&quot;qxmllocator#columnNumber&quot;&gt;columnNumber&lt;/a&gt;()) that the reader has reached.</source>
          <target state="translated">독자는 &lt;a href=&quot;qxmllocator&quot;&gt;QXmlLocator&lt;/a&gt; 를 문서 구문 분석을 시작하기 전에 컨텐츠 핸들러에 보고합니다 . 이것은 &lt;a href=&quot;qxmlcontenthandler#setDocumentLocator&quot;&gt;QXmlContentHandler :: setDocumentLocator&lt;/a&gt; () 함수로 수행됩니다. 핸들러 클래스는 이제이 로케이터를 사용 하여 독자가 도달 한 위치 ( &lt;a href=&quot;qxmllocator#lineNumber&quot;&gt;lineNumber&lt;/a&gt; () 및 &lt;a href=&quot;qxmllocator#columnNumber&quot;&gt;columnNumber&lt;/a&gt; ()) 를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2763f82d0a78459df397e2f0b72009ac46b8e7f4" translate="yes" xml:space="preserve">
          <source>The reader reports a DTD in &lt;a href=&quot;qxmlstreamreader#text&quot;&gt;text&lt;/a&gt;(), notation declarations in &lt;a href=&quot;qxmlstreamreader#notationDeclarations&quot;&gt;notationDeclarations&lt;/a&gt;(), and entity declarations in &lt;a href=&quot;qxmlstreamreader#entityDeclarations&quot;&gt;entityDeclarations&lt;/a&gt;(). Details of the DTD declaration are reported in in &lt;a href=&quot;qxmlstreamreader#dtdName&quot;&gt;dtdName&lt;/a&gt;(), &lt;a href=&quot;qxmlstreamreader#dtdPublicId&quot;&gt;dtdPublicId&lt;/a&gt;(), and &lt;a href=&quot;qxmlstreamreader#dtdSystemId&quot;&gt;dtdSystemId&lt;/a&gt;().</source>
          <target state="translated">독자 보고서에서 DTD &lt;a href=&quot;qxmlstreamreader#text&quot;&gt;텍스트&lt;/a&gt; ()에 표기 선언 &lt;a href=&quot;qxmlstreamreader#notationDeclarations&quot;&gt;notationDeclarations&lt;/a&gt; 에서 (), 엔티티 선언 &lt;a href=&quot;qxmlstreamreader#entityDeclarations&quot;&gt;entityDeclarations&lt;/a&gt; (). DTD 선언의 세부 사항은 &lt;a href=&quot;qxmlstreamreader#dtdName&quot;&gt;dtdName&lt;/a&gt; (), &lt;a href=&quot;qxmlstreamreader#dtdPublicId&quot;&gt;dtdPublicId&lt;/a&gt; () 및 &lt;a href=&quot;qxmlstreamreader#dtdSystemId&quot;&gt;dtdSystemId&lt;/a&gt; () 에보고 됩니다.</target>
        </trans-unit>
        <trans-unit id="e96567351ab446a725fca627b523625187b55be0" translate="yes" xml:space="preserve">
          <source>The reader reports a comment in &lt;a href=&quot;qxmlstreamreader#text&quot;&gt;text&lt;/a&gt;().</source>
          <target state="translated">독자는 &lt;a href=&quot;qxmlstreamreader#text&quot;&gt;텍스트&lt;/a&gt; () 로 주석을보고합니다 .</target>
        </trans-unit>
        <trans-unit id="89582bedca5d037b958f334fb982c5b7b78f3f50" translate="yes" xml:space="preserve">
          <source>The reader reports a processing instruction in &lt;a href=&quot;qxmlstreamreader#processingInstructionTarget&quot;&gt;processingInstructionTarget&lt;/a&gt;() and &lt;a href=&quot;qxmlstreamreader#processingInstructionData&quot;&gt;processingInstructionData&lt;/a&gt;().</source>
          <target state="translated">리더는 &lt;a href=&quot;qxmlstreamreader#processingInstructionTarget&quot;&gt;processingInstructionTarget&lt;/a&gt; () 및 &lt;a href=&quot;qxmlstreamreader#processingInstructionData&quot;&gt;processingInstructionData&lt;/a&gt; () 에서 처리 명령을보고합니다 .</target>
        </trans-unit>
        <trans-unit id="59011fa4dbecf946340da83827885e7c8f48cf06" translate="yes" xml:space="preserve">
          <source>The reader reports an entity reference that could not be resolved. The name of the reference is reported in &lt;a href=&quot;qxmlstreamreader#name&quot;&gt;name&lt;/a&gt;(), the replacement text in &lt;a href=&quot;qxmlstreamreader#text&quot;&gt;text&lt;/a&gt;().</source>
          <target state="translated">독자는 해결할 수없는 엔티티 참조를보고합니다. 참조 이름은 &lt;a href=&quot;qxmlstreamreader#name&quot;&gt;이름&lt;/a&gt; ()으로 대체 텍스트는 &lt;a href=&quot;qxmlstreamreader#text&quot;&gt;텍스트&lt;/a&gt; () 로보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="618ec7652df09fd74fba2408deb6bd2f7ccf07fe" translate="yes" xml:space="preserve">
          <source>The reader reports characters in &lt;a href=&quot;qxmlstreamreader#text&quot;&gt;text&lt;/a&gt;(). If the characters are all white-space, &lt;a href=&quot;qxmlstreamreader#isWhitespace&quot;&gt;isWhitespace&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;. If the characters stem from a CDATA section, &lt;a href=&quot;qxmlstreamreader#isCDATA&quot;&gt;isCDATA&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">의 리더 보고서 문자 &lt;a href=&quot;qxmlstreamreader#text&quot;&gt;텍스트&lt;/a&gt; (). 문자가 모두 공백이면 &lt;a href=&quot;qxmlstreamreader#isWhitespace&quot;&gt;isWhitespace&lt;/a&gt; ()는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 문자가 CDATA 섹션에서 &lt;a href=&quot;qxmlstreamreader#isCDATA&quot;&gt;오는&lt;/a&gt; 경우 isCDATA ()는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="36a6b549f709951a3875292010020af7ff1327ab" translate="yes" xml:space="preserve">
          <source>The reader reports parsing events through special handler classes:</source>
          <target state="translated">독자는 특수 핸들러 클래스를 통해 구문 분석 이벤트를보고합니다.</target>
        </trans-unit>
        <trans-unit id="9dd9561746df1bcb91db32a7862ea39ff1663ca1" translate="yes" xml:space="preserve">
          <source>The reader reports the XML version number in &lt;a href=&quot;qxmlstreamreader#documentVersion&quot;&gt;documentVersion&lt;/a&gt;(), and the encoding as specified in the XML document in &lt;a href=&quot;qxmlstreamreader#documentEncoding&quot;&gt;documentEncoding&lt;/a&gt;(). If the document is declared standalone, &lt;a href=&quot;qxmlstreamreader#isStandaloneDocument&quot;&gt;isStandaloneDocument&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;; otherwise it returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">독자의 XML 버전 번호보고 &lt;a href=&quot;qxmlstreamreader#documentVersion&quot;&gt;documentVersion&lt;/a&gt; ()과의 XML 문서에 지정된대로 인코딩 &lt;a href=&quot;qxmlstreamreader#documentEncoding&quot;&gt;documentEncoding을&lt;/a&gt; (). 문서가 독립형으로 선언되면 &lt;a href=&quot;qxmlstreamreader#isStandaloneDocument&quot;&gt;isStandaloneDocument&lt;/a&gt; ()는 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="27144a070d8d5ff0574faa2c1a5fe6b99b44a232" translate="yes" xml:space="preserve">
          <source>The reader reports the end of an element with &lt;a href=&quot;qxmlstreamreader#namespaceUri&quot;&gt;namespaceUri&lt;/a&gt;() and &lt;a href=&quot;qxmlstreamreader#name&quot;&gt;name&lt;/a&gt;().</source>
          <target state="translated">독자는 &lt;a href=&quot;qxmlstreamreader#namespaceUri&quot;&gt;namespaceUri&lt;/a&gt; () 및 &lt;a href=&quot;qxmlstreamreader#name&quot;&gt;name&lt;/a&gt; ()으로 요소의 끝을보고합니다 .</target>
        </trans-unit>
        <trans-unit id="3a1aa900af013bc1ee803147ffbb1363011478a7" translate="yes" xml:space="preserve">
          <source>The reader reports the end of the document.</source>
          <target state="translated">독자는 문서의 끝을보고합니다.</target>
        </trans-unit>
        <trans-unit id="9f113620a201cee3b2369fda5a42b0088d80ce6a" translate="yes" xml:space="preserve">
          <source>The reader reports the start of an element with &lt;a href=&quot;qxmlstreamreader#namespaceUri&quot;&gt;namespaceUri&lt;/a&gt;() and &lt;a href=&quot;qxmlstreamreader#name&quot;&gt;name&lt;/a&gt;(). Empty elements are also reported as StartElement, followed directly by EndElement. The convenience function &lt;a href=&quot;qxmlstreamreader#readElementText&quot;&gt;readElementText&lt;/a&gt;() can be called to concatenate all content until the corresponding EndElement. Attributes are reported in &lt;a href=&quot;qxmlstreamreader#attributes&quot;&gt;attributes&lt;/a&gt;(), namespace declarations in &lt;a href=&quot;qxmlstreamreader#namespaceDeclarations&quot;&gt;namespaceDeclarations&lt;/a&gt;().</source>
          <target state="translated">독자는 &lt;a href=&quot;qxmlstreamreader#namespaceUri&quot;&gt;namespaceUri&lt;/a&gt; () 및 &lt;a href=&quot;qxmlstreamreader#name&quot;&gt;name&lt;/a&gt; ()으로 요소의 시작을보고합니다 . 빈 요소는 StartElement로보고 된 다음 EndElement가 바로 뒤 따릅니다. 편의 기능 &lt;a href=&quot;qxmlstreamreader#readElementText&quot;&gt;readElementText&lt;/a&gt; ()를 호출하여 해당 EndElement까지 모든 내용을 연결합니다. 속성에보고 &lt;a href=&quot;qxmlstreamreader#attributes&quot;&gt;속성&lt;/a&gt; 에서 (), 네임 스페이스 선언 &lt;a href=&quot;qxmlstreamreader#namespaceDeclarations&quot;&gt;namespaceDeclarations&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="dcca1472bab50e523fc8ec09a66b9639c735d19f" translate="yes" xml:space="preserve">
          <source>The reader will be used from where it currently is positioned. If</source>
          <target state="translated">리더는 현재 위치에서 사용됩니다. 만약</target>
        </trans-unit>
        <trans-unit id="7ee1fd46028de8016c69898286cc981bda13bba1" translate="yes" xml:space="preserve">
          <source>The reading class provides access to sensor readings. The reading object is a volatile cache of the most recent sensor reading that has been received so the application should process readings immediately or save the values somewhere for later processing.</source>
          <target state="translated">판독 등급은 센서 판독 값에 대한 액세스를 제공합니다. 판독 개체는 가장 최근에 수신 된 센서 판독 값의 휘발성 캐시이므로 응용 프로그램은 판독 값을 즉시 처리하거나 나중에 처리하기 위해 어딘가에 값을 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="9ab8c073de09329d6c9cf6b6aecb4918024e16d7" translate="yes" xml:space="preserve">
          <source>The reading contains 3 values, measured in degrees per second that define the movement of the device around the x, y and z axes. Unlike &lt;a href=&quot;qrotationreading&quot;&gt;QRotationReading&lt;/a&gt;, the values represent the current angular velocity rather than a fixed rotation. The measurements are in degrees per second.</source>
          <target state="translated">판독 값에는 x, y 및 z 축 주위의 장치 이동을 정의하는 초당도 단위로 측정 된 3 개의 값이 포함됩니다. &lt;a href=&quot;qrotationreading&quot;&gt;QRotationReading&lt;/a&gt; 과 달리 값은 고정 회전이 아닌 현재 각속도를 나타냅니다. 측정 값은 초당 각도입니다.</target>
        </trans-unit>
        <trans-unit id="c7e561be5fdce2691a467e061169b36061d10598" translate="yes" xml:space="preserve">
          <source>The reading values are automatically rotated based on the screen orientation.</source>
          <target state="translated">판독 값은 화면 방향에 따라 자동으로 회전합니다.</target>
        </trans-unit>
        <trans-unit id="018572cdcb43049ff563b0103ed4bd7a19202eda" translate="yes" xml:space="preserve">
          <source>The reading values are rotated based on the angle of the &lt;a href=&quot;qsensor#userOrientation-prop&quot;&gt;userOrientation&lt;/a&gt; property.</source>
          <target state="translated">판독 값은 &lt;a href=&quot;qsensor#userOrientation-prop&quot;&gt;userOrientation&lt;/a&gt; 속성 의 각도를 기준으로 회전 됩니다.</target>
        </trans-unit>
        <trans-unit id="6dfee439b2de3a63188256d5dd8b6d0454e02b3e" translate="yes" xml:space="preserve">
          <source>The reason for the focus change will be &lt;a href=&quot;qt#FocusReason-enum&quot;&gt;Qt::OtherFocusReason&lt;/a&gt;. Use the overloaded method to specify the focus reason to enable better handling of the focus change.</source>
          <target state="translated">포커스 변경 이유는 &lt;a href=&quot;qt#FocusReason-enum&quot;&gt;Qt :: OtherFocusReason&lt;/a&gt; 입니다. 오버로드 된 방법을 사용하여 초점 변경을보다 잘 처리 할 수 ​​있도록 초점 이유를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="ce42e381a281f3d065300aadb8cb7d9c3c7db2b5" translate="yes" xml:space="preserve">
          <source>The received data address in the query is not an allowable address for the Modbus server.</source>
          <target state="translated">쿼리에서 수신 된 데이터 주소가 Modbus 서버에 허용되는 주소가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4ade544a6f7549cc47d146700492f739c7800e7b" translate="yes" xml:space="preserve">
          <source>The receiver's</source>
          <target state="translated">수신자의</target>
        </trans-unit>
        <trans-unit id="0ba813e1edf2896468786cc67bd33fc901a0cbf1" translate="yes" xml:space="preserve">
          <source>The recent items category.</source>
          <target state="translated">최근 항목 카테고리.</target>
        </trans-unit>
        <trans-unit id="ce5cc7a21b4bcb80171e121c605734076f2405c1" translate="yes" xml:space="preserve">
          <source>The reception of the written signal can be considered as a sign that the target device received the to-be-written value and reports back the status of write request.</source>
          <target state="translated">기록 된 신호의 수신은 대상 장치가 기록 될 값을 수신하고 기록 요청의 상태를 다시보고한다는 표시로 간주 될 수있다.</target>
        </trans-unit>
        <trans-unit id="eb97377f751e17ba2967d5f6ce0d3f515e70a26d" translate="yes" xml:space="preserve">
          <source>The recognizer will detect a touch down and if</source>
          <target state="translated">인식기는 터치 다운을 감지하고</target>
        </trans-unit>
        <trans-unit id="5f10adbfd8bcda49fc2a20016529b6d3dff4a8a7" translate="yes" xml:space="preserve">
          <source>The recognizer will detect a touch down and if timeout() later the touch is still down, it will trigger the &lt;a href=&quot;qtapandholdgesture&quot;&gt;QTapAndHoldGesture&lt;/a&gt;. The default value is 700 milliseconds.</source>
          <target state="translated">인식기는 터치 다운을 감지하고 나중에 timeout ()이 여전히 다운되면 &lt;a href=&quot;qtapandholdgesture&quot;&gt;QTapAndHoldGesture&lt;/a&gt; 를 트리거합니다 . 기본값은 700 밀리 초입니다.</target>
        </trans-unit>
        <trans-unit id="5ec887ca3adfe5461f221262745b570ed3376b7e" translate="yes" xml:space="preserve">
          <source>The recommended orientation is &lt;a href=&quot;qml-qtquick-window-screen#orientation-attached-prop&quot;&gt;Screen.orientation&lt;/a&gt;, but an application doesn't have to support all possible orientations, and thus can opt to ignore the current screen orientation.</source>
          <target state="translated">권장되는 방향은 &lt;a href=&quot;qml-qtquick-window-screen#orientation-attached-prop&quot;&gt;Screen.orientation&lt;/a&gt; 이지만 응용 프로그램이 가능한 모든 방향을 지원할 필요는 없으므로 현재 화면 방향을 무시하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adb3ba1754a77814b584d0374a182abb3f7da508" translate="yes" xml:space="preserve">
          <source>The recommended orientation is &lt;a href=&quot;qscreen#orientation-prop&quot;&gt;QScreen::orientation&lt;/a&gt;() but an application doesn't have to support all possible orientations, and thus can opt to ignore the current screen orientation.</source>
          <target state="translated">권장되는 방향은 &lt;a href=&quot;qscreen#orientation-prop&quot;&gt;QScreen :: orientation&lt;/a&gt; ()이지만 응용 프로그램이 가능한 모든 방향을 지원할 필요는 없으므로 현재 화면 방향을 무시하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84b1fced2d351b8350696bdff3c55f0fc4d85f8d" translate="yes" xml:space="preserve">
          <source>The recommended way to use Qt libraries and headers with &lt;code&gt;CMake&lt;/code&gt; is to use the &lt;code&gt;target_link_libraries&lt;/code&gt; command. This command automatically adds appropriate include directories, compile definitions, the position-independent-code flag, and links to the qtmain.lib library on Windows.</source>
          <target state="translated">&lt;code&gt;CMake&lt;/code&gt; 와 함께 Qt 라이브러리 및 헤더를 사용하는 권장 방법 은 &lt;code&gt;target_link_libraries&lt;/code&gt; 명령 을 사용하는 것 입니다 . 이 명령은 적절한 포함 디렉토리, 컴파일 정의, 위치 독립적 코드 플래그 및 Windows의 qtmain.lib 라이브러리에 대한 링크를 자동으로 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4c1cddeeb3627ca3c210cdbc001c46699ba2d684" translate="yes" xml:space="preserve">
          <source>The recorder is available but not loaded.</source>
          <target state="translated">레코더를 사용할 수 있지만로드되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="9436f12bd3c4890955778d6fd859c75dff02c729" translate="yes" xml:space="preserve">
          <source>The recorder is avilable but not loaded.</source>
          <target state="translated">레코더는 사용 가능하지만로드되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0d412e07696fedf669c5c9011bbbd8650727e83d" translate="yes" xml:space="preserve">
          <source>The recorder is initialized and ready to record media.</source>
          <target state="translated">레코더가 초기화되고 미디어를 기록 할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="f76e62d1e9a221159940e8df594b417dd65a19b8" translate="yes" xml:space="preserve">
          <source>The recorder is initializing.</source>
          <target state="translated">레코더가 초기화 중입니다.</target>
        </trans-unit>
        <trans-unit id="31c7f858faa1804a1d7ed22479ff099da9f4f7b5" translate="yes" xml:space="preserve">
          <source>The recorder is not active. If this is the state after recording then the actual created recording has finished being written to the final location and is ready on all platforms except on Android. On Android, due to platform limitations, there is no way to be certain that the recording has finished writing to the final location.</source>
          <target state="translated">레코더가 활성화되지 않았습니다. 레코딩 후의 상태 인 경우 실제 작성된 레코딩은 최종 위치에 작성이 완료되었으며 Android를 제외한 모든 플랫폼에서 준비됩니다. Android에서는 플랫폼 제한으로 인해 레코딩이 최종 위치에 대한 쓰기를 완료했는지 확인할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="51f5948edf7798ffc901854643e1fa793323e8e9" translate="yes" xml:space="preserve">
          <source>The recorder is not available or not supported by connected media object.</source>
          <target state="translated">연결된 미디어 개체에서 레코더를 사용할 수 없거나 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b173acc5f65a7610983d679091f5b75d709e191c" translate="yes" xml:space="preserve">
          <source>The recorder is paused.</source>
          <target state="translated">레코더가 일시 정지되었습니다.</target>
        </trans-unit>
        <trans-unit id="70ceb3438b40e1c8e251d4adca6485c4774ef22f" translate="yes" xml:space="preserve">
          <source>The recorder state is changed to &lt;a href=&quot;qmediarecorder#State-enum&quot;&gt;QMediaRecorder::PausedState&lt;/a&gt;.</source>
          <target state="translated">레코더 상태가 &lt;a href=&quot;qmediarecorder#State-enum&quot;&gt;QMediaRecorder :: PausedState로&lt;/a&gt; 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="074b932502dd715d961a074f69451e7c063832cd" translate="yes" xml:space="preserve">
          <source>The recorder state is changed to &lt;a href=&quot;qmediarecorder#State-enum&quot;&gt;QMediaRecorder::StoppedState&lt;/a&gt;.</source>
          <target state="translated">레코더 상태가 &lt;a href=&quot;qmediarecorder#State-enum&quot;&gt;QMediaRecorder :: StoppedState로&lt;/a&gt; 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="abbd5c05b01bc44753bae4c5f5d7877a1301ee97" translate="yes" xml:space="preserve">
          <source>The recording is requested.</source>
          <target state="translated">녹음이 요청됩니다.</target>
        </trans-unit>
        <trans-unit id="0e27777f6eb8a63d39e0e0dc419fe60439871cc0" translate="yes" xml:space="preserve">
          <source>The records are sorted according to &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc2782.txt&quot;&gt;RFC 2782&lt;/a&gt;, so if you use them to connect to servers, you should try them in the order they are listed.</source>
          <target state="translated">레코드는 &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc2782.txt&quot;&gt;RFC 2782&lt;/a&gt; 에 따라 정렬 되므로이를 사용하여 서버에 연결하는 경우 나열된 순서대로 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="3b152422a52773c7425a60d2e385e7cad2d55592" translate="yes" xml:space="preserve">
          <source>The records are sorted according to &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc5321.txt&quot;&gt;RFC 5321&lt;/a&gt;, so if you use them to connect to servers, you should try them in the order they are listed.</source>
          <target state="translated">레코드는 &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc5321.txt&quot;&gt;RFC 5321&lt;/a&gt; 에 따라 정렬 되므로이를 사용하여 서버에 연결하는 경우 나열된 순서대로 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b77f0ec57e824795adb4b4c087887699d7981ca" translate="yes" xml:space="preserve">
          <source>The rect property equals &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;(0, 0, &lt;a href=&quot;qwidget#width-prop&quot;&gt;width&lt;/a&gt;(), &lt;a href=&quot;qwidget#height-prop&quot;&gt;height&lt;/a&gt;()).</source>
          <target state="translated">rect 특성은 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; (0, 0, &lt;a href=&quot;qwidget#width-prop&quot;&gt;너비&lt;/a&gt; (), &lt;a href=&quot;qwidget#height-prop&quot;&gt;높이&lt;/a&gt; ())와 같습니다.</target>
        </trans-unit>
        <trans-unit id="fcff2d2c30a1abea9c6c4a748d3bf01b2647b9bc" translate="yes" xml:space="preserve">
          <source>The rectangle covering the area of the input cursor in widget coordinates.</source>
          <target state="translated">위젯 좌표에서 입력 커서 영역을 덮는 사각형입니다.</target>
        </trans-unit>
        <trans-unit id="8ea6076f1b616abb95a6cda9790371dfb096423d" translate="yes" xml:space="preserve">
          <source>The rectangle is defined in terms of a &lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate&lt;/a&gt; which specifies the top left coordinate of the rectangle and a &lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate&lt;/a&gt; which specifies the bottom right coordinate of the rectangle.</source>
          <target state="translated">사각형은로 정의된다 &lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate&lt;/a&gt; 사각형의 좌표 및 좌측 상단 지정 &lt;a href=&quot;qgeocoordinate&quot;&gt;QGeoCoordinate&lt;/a&gt; 하단 오른쪽 사각형의 좌표를 지정한다.</target>
        </trans-unit>
        <trans-unit id="f5180a6920230b89e88e62ae15e76059d49738c2" translate="yes" xml:space="preserve">
          <source>The rectangle returned by &lt;a href=&quot;https://doc.qt.io/qt-5.13/qprinter-obsolete.html#pageRect&quot;&gt;pageRect()&lt;/a&gt; usually lies inside the rectangle returned by &lt;a href=&quot;https://doc.qt.io/qt-5.13/qprinter-obsolete.html#paperRect&quot;&gt;paperRect()&lt;/a&gt;. You do not need to take the positions and sizes of these area into account when using a &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; with a &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; as the underlying paint device; the origin of the painter's coordinate system will coincide with the top-left corner of the page rectangle, and painting operations will be clipped to the bounds of the drawable part of the page.</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.13/qprinter-obsolete.html#pageRect&quot;&gt;pageRect ()에&lt;/a&gt; 의해 반환 된 사각형은 일반적으로 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qprinter-obsolete.html#paperRect&quot;&gt;paperRect ()에&lt;/a&gt; 의해 반환 된 사각형 안에 있습니다 . &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; 와 함께 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 를 기본 페인트 장치로 사용할 때이 영역의 위치와 크기를 고려할 필요는 없습니다 . 페인터 좌표계의 원점은 페이지 사각형의 왼쪽 상단 모서리와 일치하며 페인팅 작업은 페이지의 그리기 가능 부분의 경계에 잘립니다.</target>
        </trans-unit>
        <trans-unit id="c339f1d8f48a22470fabc5f938295cd222824ef5" translate="yes" xml:space="preserve">
          <source>The rectangle supplied by the &lt;a href=&quot;qdragmoveevent#answerRect&quot;&gt;answerRect&lt;/a&gt;() function can be used to restrict drops to certain parts of the widget. For example, we can check whether the rectangle intersects with the geometry of a certain child widget and only call &lt;a href=&quot;qdropevent#acceptProposedAction&quot;&gt;acceptProposedAction()&lt;/a&gt; if that is the case.</source>
          <target state="translated">&lt;a href=&quot;qdragmoveevent#answerRect&quot;&gt;answerRect&lt;/a&gt; () 함수가 제공하는 사각형 은 방울을 위젯의 특정 부분으로 제한하는 데 사용할 수 있습니다. 예를 들어 사각형이 특정 자식 위젯의 지오메트리와 교차하는지 확인할 수 있으며, 그런 경우 &lt;a href=&quot;qdropevent#acceptProposedAction&quot;&gt;acceptProposedAction ()&lt;/a&gt; 만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa592685e9c33af6019cb65de2af054d1e35372d" translate="yes" xml:space="preserve">
          <source>The rectangle where the standard text cursor is rendered within the text edit. Read-only.</source>
          <target state="translated">텍스트 편집 내에서 표준 텍스트 커서가 렌더링되는 사각형입니다. 읽기 전용</target>
        </trans-unit>
        <trans-unit id="cfef3e222d0fcb75e693fe4478aed27110e4654e" translate="yes" xml:space="preserve">
          <source>The rectangle where the standard text cursor is rendered within the text input. Read only.</source>
          <target state="translated">텍스트 입력 내에서 표준 텍스트 커서가 렌더링되는 사각형입니다. 읽기 전용.</target>
        </trans-unit>
        <trans-unit id="cf0e45213b89d2218a6fe700d2e109d7b5f52188" translate="yes" xml:space="preserve">
          <source>The rectangle where the text cursor is rendered within the text area.</source>
          <target state="translated">텍스트 영역 내에서 텍스트 커서가 렌더링되는 사각형입니다.</target>
        </trans-unit>
        <trans-unit id="930008879476c401f9a5c7bd7843574b05709834" translate="yes" xml:space="preserve">
          <source>The rectangle where the text cursor is rendered within the text field.</source>
          <target state="translated">텍스트 필드 내에서 텍스트 커서가 렌더링되는 사각형입니다.</target>
        </trans-unit>
        <trans-unit id="c8867232524e7f31bcbe2d89f5618aae2d6c94c4" translate="yes" xml:space="preserve">
          <source>The rectangle within which the chart is drawn.</source>
          <target state="translated">차트가 그려지는 사각형입니다.</target>
        </trans-unit>
        <trans-unit id="d64d2adc17fd1e986955bd500a359b87f0ae9c5e" translate="yes" xml:space="preserve">
          <source>The rectangle's coordinates are transformed using the following formulas:</source>
          <target state="translated">사각형의 좌표는 다음 공식을 사용하여 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ecc46d9ed0f6f0982c796a4b755fc3745c42e2c6" translate="yes" xml:space="preserve">
          <source>The rectangles must be sorted in ascending order, with Y as the major sort key and X as the minor sort key.</source>
          <target state="translated">사각형은 오름차순으로 정렬해야하며 Y는 주 정렬 키이고 X는 마이너 정렬 키입니다.</target>
        </trans-unit>
        <trans-unit id="26a7af33382824873f1f6797d73ed6078ca2d65a" translate="yes" xml:space="preserve">
          <source>The rectangles must not intersect.</source>
          <target state="translated">사각형은 교차하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d81621a977ce9f18af0c46a8641d122797cd4add" translate="yes" xml:space="preserve">
          <source>The red component. Equivalent to GL_TEXTURE_SWIZZLE_R</source>
          <target state="translated">빨간색 구성 요소 GL_TEXTURE_SWIZZLE_R에 해당</target>
        </trans-unit>
        <trans-unit id="3d90e982eb4fea08ad80f3eb4569d23a940f493e" translate="yes" xml:space="preserve">
          <source>The red rectangle will be 50x50, centered in the root item.</source>
          <target state="translated">빨간색 사각형은 루트 항목을 중심으로 50x50입니다.</target>
        </trans-unit>
        <trans-unit id="f43fd29cf65810f3a565e35d5295632fe6716b13" translate="yes" xml:space="preserve">
          <source>The red rectangle will be sized to the size of the root item.</source>
          <target state="translated">빨간색 사각형은 루트 항목의 크기로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="804b388c72962ba1c4a0824f70590ea8ee776ad4" translate="yes" xml:space="preserve">
          <source>The redo stack.</source>
          <target state="translated">리두 스택.</target>
        </trans-unit>
        <trans-unit id="b3680d67e6ed7ecf07ad7d0db2f946530943c782" translate="yes" xml:space="preserve">
          <source>The reduce function must be of the form:</source>
          <target state="translated">감소 기능은 다음과 같은 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="906a82c4bc190878cbc52c38ee54413be2abc2a6" translate="yes" xml:space="preserve">
          <source>The reduce function will be called once for each result kept by the filter function, and should merge the</source>
          <target state="translated">감소 함수는 필터 함수가 유지하는 각 결과에 대해 한 번 호출되며</target>
        </trans-unit>
        <trans-unit id="c55daeacd44197d28cb50c4cf61c08341cff25da" translate="yes" xml:space="preserve">
          <source>The reduce function will be called once for each result returned by the map function, and should merge the</source>
          <target state="translated">map 함수가 반환 한 각 결과에 대해 reduce 함수가 한 번 호출되며</target>
        </trans-unit>
        <trans-unit id="39d7614f1edf165dc738e577a905febf209415e8" translate="yes" xml:space="preserve">
          <source>The reference configurations are run on the continuous integration (CI) system within Qt Project. In addition, they are subjected to unit test suite and other internal testing tools on a frequent basis (prior to new version releases, source tree branching, and at other significant period points in the development process). Errors or bugs discovered in these platforms are prioritized for correction. Significant errors discovered in tested configurations can impact release dates.</source>
          <target state="translated">참조 구성은 Qt 프로젝트 내의 CI (Continuous Integration) 시스템에서 실행됩니다. 또한 단위 테스트 스위트 및 기타 내부 테스트 도구를 자주 사용합니다 (새 버전 릴리스, 소스 트리 분기 및 개발 프로세스의 다른 중요한 시점 이전). 이러한 플랫폼에서 발견 된 오류 또는 버그는 수정 우선 순위가 지정됩니다. 테스트 한 구성에서 발견 된 중대한 오류는 릴리스 날짜에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb2a3261546f4db850915beb977ec34990050849" translate="yes" xml:space="preserve">
          <source>The reference rectangle for the combobox popup. Used to calculate the position of the popup.</source>
          <target state="translated">콤보 박스 팝업의 참조 사각형. 팝업의 위치를 ​​계산하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d9c65be55e2a2c55fafe3500e66c8f0b76db9694" translate="yes" xml:space="preserve">
          <source>The reference sections describe in detail the variables and functions that are available for use in qmake project files.</source>
          <target state="translated">참조 섹션은 qmake 프로젝트 파일에서 사용할 수있는 변수와 기능을 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="76b0036bb13e8e7c16ae4bf3fefd931e13aafa5c" translate="yes" xml:space="preserve">
          <source>The reference table name is aliased. The alias is the word &quot;relTblAl&quot; and the relationed column index joined by an underscore (e.g. relTblAl_2). The alias can be used to filter the table (For example, &lt;a href=&quot;qsqltablemodel#setFilter&quot;&gt;setFilter&lt;/a&gt;(&quot;relTblAl_2='Oslo' OR relTblAl_3='USA'&quot;)).</source>
          <target state="translated">참조 테이블 이름은 별명입니다. 별명은 &quot;relTblAl&quot;이라는 단어이며 밑줄로 연결된 관계형 열 인덱스 (예 : relTblAl_2)입니다. 별명을 사용하여 테이블을 필터링 할 수 있습니다 (예 : &lt;a href=&quot;qsqltablemodel#setFilter&quot;&gt;setFilter&lt;/a&gt; ( &quot;relTblAl_2 = 'Oslo'OR relTblAl_3 = 'USA'&quot;)).</target>
        </trans-unit>
        <trans-unit id="ddc466c3b2079a83e5a7bda30c960965977f8821" translate="yes" xml:space="preserve">
          <source>The reflectance is a decimal fraction (from 0 to 1) indicating how much of the transmitted infra-red light was returned.</source>
          <target state="translated">반사율은 투과 된 적외선의 반사량을 나타내는 소수 (0에서 1까지)입니다.</target>
        </trans-unit>
        <trans-unit id="a6cea53ccabf4ee26f3069a52cbcf3333a9f3a4e" translate="yes" xml:space="preserve">
          <source>The regexp is only applied on the first 14 bytes of the file.</source>
          <target state="translated">정규 표현식은 파일의 처음 14 바이트에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7551cdc8cb937bdaf2a754b05490b2b6da6a5757" translate="yes" xml:space="preserve">
          <source>The region between the handle (slider) and the &lt;a href=&quot;#add-line-sub&quot;&gt;add-line&lt;/a&gt; of a &lt;a href=&quot;qscrollbar&quot;&gt;QScrollBar&lt;/a&gt;.</source>
          <target state="translated">핸들 (슬라이더)과 사이의 영역 &lt;a href=&quot;#add-line-sub&quot;&gt;추가 라인&lt;/a&gt; (A)의 &lt;a href=&quot;qscrollbar&quot;&gt;QScrollBar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="622180a8dfa50dcd8a7b78726686e3c542ec5038" translate="yes" xml:space="preserve">
          <source>The region between the handle (slider) and the &lt;a href=&quot;#sub-line-sub&quot;&gt;sub-line&lt;/a&gt; of a &lt;a href=&quot;qscrollbar&quot;&gt;QScrollBar&lt;/a&gt;.</source>
          <target state="translated">핸들 (슬라이더)과 사이의 영역 &lt;a href=&quot;#sub-line-sub&quot;&gt;의 서브 라인&lt;/a&gt; (A)의 &lt;a href=&quot;qscrollbar&quot;&gt;QScrollBar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ad08d1ebd2f3c72ff0730f2738febe1b75b5928" translate="yes" xml:space="preserve">
          <source>The region of a frame that is actually displayed on a video surface is given by the &lt;a href=&quot;qvideosurfaceformat#viewport&quot;&gt;viewport&lt;/a&gt;(). A stream may have a viewport less than the entire region of a frame to allow for videos smaller than the nearest optimal size of a video frame. For example the width of a frame may be extended so that the start of each scan line is eight byte aligned.</source>
          <target state="translated">실제로 비디오 표면에 표시되는 프레임 영역은 &lt;a href=&quot;qvideosurfaceformat#viewport&quot;&gt;뷰포트&lt;/a&gt; ()로 제공됩니다. 스트림은 비디오 프레임의 최적의 최적 크기보다 작은 비디오를 허용하기 위해 프레임의 전체 영역보다 작은 뷰포트를 가질 수있다. 예를 들어, 프레임의 폭은 각 스캔 라인의 시작이 8 바이트로 정렬되도록 확장 될 수있다.</target>
        </trans-unit>
        <trans-unit id="820236f3cc93e3fb708e8122c9c98880f0866a28" translate="yes" xml:space="preserve">
          <source>The regions of the image are defined using the &lt;a href=&quot;qml-qtquick-borderimage#border-prop&quot;&gt;border&lt;/a&gt; property group, which describes the distance from each edge of the source image to use as a border.</source>
          <target state="translated">이미지의 영역은 &lt;a href=&quot;qml-qtquick-borderimage#border-prop&quot;&gt;경계&lt;/a&gt; 속성 그룹을 사용하여 정의되며, 경계 속성 그룹은 소스 이미지의 각 가장자리에서 경계로 사용할 거리를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6e72bb6931447a4f2cf1fa9fc44f38fcd3f4a4f5" translate="yes" xml:space="preserve">
          <source>The registered gesture recognizer monitors the input events for the target object via its &lt;a href=&quot;qgesturerecognizer#recognize&quot;&gt;recognize()&lt;/a&gt; function, updating the properties of the gesture object as required.</source>
          <target state="translated">등록 된 제스처 인식기는 필요한 경우 제스처 객체의 속성을 업데이트하여 그 &lt;a href=&quot;qgesturerecognizer#recognize&quot;&gt;인식 ()&lt;/a&gt; 함수 를 통해 대상 객체의 입력 이벤트를 모니터링 합니다.</target>
        </trans-unit>
        <trans-unit id="8d2567af61b5be8f529a48f14dd2abce2b5e9674" translate="yes" xml:space="preserve">
          <source>The registration of an extension factory is typically made in the &lt;a href=&quot;qdesignercustomwidgetinterface#initialize&quot;&gt;QDesignerCustomWidgetInterface::initialize&lt;/a&gt;() function:</source>
          <target state="translated">확장 팩토리 등록은 일반적으로 &lt;a href=&quot;qdesignercustomwidgetinterface#initialize&quot;&gt;QDesignerCustomWidgetInterface :: initialize&lt;/a&gt; () 함수에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="033c16be2721f31b034e538b3b5bfc1cb2a81d82" translate="yes" xml:space="preserve">
          <source>The registry could not be acquired.</source>
          <target state="translated">레지스트리를 얻을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="25b2d846e2849976b8157f769b4f0f9673b5d897" translate="yes" xml:space="preserve">
          <source>The registry is already defined and hosting Sources.</source>
          <target state="translated">레지스트리가 이미 정의되어 있으며 소스를 호스팅합니다.</target>
        </trans-unit>
        <trans-unit id="0256af57ae63f7001194abeebcbb0432be895260" translate="yes" xml:space="preserve">
          <source>The registry is tightly integrated with QtRO. Whenever a &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; is added or removed, the name/URL is updated in the registry automatically. So once your node is connected to the registry, it is not necessary to connect to any other nodes manually. If you request an object on the network and you aren't connected to the hosting node, the registry will know what URL to connect to and will initiate the connection. Once connected (and the list of available objects is passed along, including the desired &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt;), the initialization process for the requested &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; will start automatically.</source>
          <target state="translated">레지스트리는 QtRO와 긴밀하게 통합되어 있습니다. &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;소스&lt;/a&gt; 가 추가되거나 제거 될 때마다 이름 / URL이 레지스트리에서 자동으로 업데이트됩니다. 따라서 노드가 레지스트리에 연결되면 다른 노드에 수동으로 연결할 필요가 없습니다. 네트워크에서 개체를 요청하고 호스팅 노드에 연결되어 있지 않으면 레지스트리는 연결할 URL을 알고 연결을 시작합니다. 연결되면 (및 원하는 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;소스를&lt;/a&gt; 포함하여 사용 가능한 객체 목록이 전달됨 ) 요청 된 &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;복제본&lt;/a&gt; 의 초기화 프로세스 가 자동으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="a1f94d934e150b792202d4c460395ad69322a8cd" translate="yes" xml:space="preserve">
          <source>The registry provides a simpler way to establish these connections. Every node that wants to be part of the registry's network connects to the registry. The registry is itself a specialized source object, and thus is hosted by a node. Connecting to the registry is simply a matter of passing the registry's URL to the &lt;a href=&quot;qremoteobjectnode&quot;&gt;QRemoteObjectNode&lt;/a&gt; or &lt;a href=&quot;qremoteobjecthost&quot;&gt;QRemoteObjectHost&lt;/a&gt; constructor, or passing the URL to the setRegistryUrl method.</source>
          <target state="translated">레지스트리는 이러한 연결을 설정하는보다 간단한 방법을 제공합니다. 레지스트리 네트워크의 일부가 되려는 모든 노드는 레지스트리에 연결됩니다. 레지스트리 자체는 특화된 소스 오브젝트이므로 노드가 호스트합니다. 레지스트리에 연결하는 것은 단순히 레지스트리 URL을 &lt;a href=&quot;qremoteobjectnode&quot;&gt;QRemoteObjectNode&lt;/a&gt; 또는 &lt;a href=&quot;qremoteobjecthost&quot;&gt;QRemoteObjectHost&lt;/a&gt; 생성자에 전달하거나 URL을 setRegistryUrl 메소드에 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6ca0668d43a1e83ab5edfcebf46eaa3724d61f25" translate="yes" xml:space="preserve">
          <source>The regular expression &lt;code&gt;/^\&lt;/code&gt;}/ makes QDoc print until the first '}' character occurring at the beginning of the line without indentation. /.../ encloses the regular expression, and '^' means the beginning of the line. The '}' character must be escaped since it is a special character in regular expressions.</source>
          <target state="translated">정규식 &lt;code&gt;/^\&lt;/code&gt; } /는 들여 쓰기없이 행의 시작 부분에서 첫 번째 '}'문자가 나타날 때까지 QDoc을 인쇄합니다. /.../는 정규식을 묶고 '^'는 줄의 시작을 의미합니다. '}'문자는 정규식의 특수 문자이므로 이스케이프해야합니다.</target>
        </trans-unit>
        <trans-unit id="9a51acccf00ec456c2a07bf8128caea71c6712c9" translate="yes" xml:space="preserve">
          <source>The relating commands are for specifying how one documented element relates to another documented element. Some examples:</source>
          <target state="translated">관련 명령은 한 문서화 된 요소가 다른 문서화 된 요소와 관련되는 방법을 지정하기위한 것입니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="34d21714c88cf6be64c13ee8dd66c3adaa534764" translate="yes" xml:space="preserve">
          <source>The relation between script translation functions and C++ translation functions is described in the following table:</source>
          <target state="translated">스크립트 변환 함수와 C ++ 변환 함수의 관계는 다음 표에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8a2041ead55f16d2f4280060cad99a50c3f206d" translate="yes" xml:space="preserve">
          <source>The relationship between a document length, the range of values used in a scroll bar, and the page step is simple in many common situations. The scroll bar's range of values is determined by subtracting a chosen page step from some value representing the length of the document. In such cases, the following equation is useful:</source>
          <target state="translated">문서 길이, 스크롤 막대에 사용 된 값 범위 및 페이지 단계 간의 관계는 많은 일반적인 상황에서 간단합니다. 스크롤 막대의 값 범위는 문서의 길이를 나타내는 일부 값에서 선택한 페이지 단계를 빼서 결정됩니다. 이러한 경우 다음 방정식이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a426c48cc20eed24f050d4fa3cfe5c644dbf8c5f" translate="yes" xml:space="preserve">
          <source>The relationships between items can be explored using the &lt;a href=&quot;qgraphicsitem#parentItem&quot;&gt;parentItem&lt;/a&gt;() and &lt;a href=&quot;qgraphicsitem#childItems&quot;&gt;childItems&lt;/a&gt;() functions. In the hierarchy of items in a scene, the &lt;a href=&quot;qgraphicsitem#parentObject&quot;&gt;parentObject&lt;/a&gt;() and &lt;a href=&quot;qgraphicsitem#parentWidget&quot;&gt;parentWidget&lt;/a&gt;() functions are the equivalent of the &lt;a href=&quot;qobject#parent&quot;&gt;QWidget::parent&lt;/a&gt;() and &lt;a href=&quot;qwidget#parentWidget&quot;&gt;QWidget::parentWidget&lt;/a&gt;() functions for &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; subclasses.</source>
          <target state="translated">&lt;a href=&quot;qgraphicsitem#parentItem&quot;&gt;parentItem&lt;/a&gt; () 및 &lt;a href=&quot;qgraphicsitem#childItems&quot;&gt;childItems&lt;/a&gt; () 함수를 사용하여 항목 간의 관계를 탐색 할 수 있습니다 . 장면의 항목 계층에서 &lt;a href=&quot;qgraphicsitem#parentObject&quot;&gt;parentObject&lt;/a&gt; () 및 &lt;a href=&quot;qgraphicsitem#parentWidget&quot;&gt;parentWidget&lt;/a&gt; () 함수는 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 서브 클래스 에 대한 &lt;a href=&quot;qobject#parent&quot;&gt;QWidget :: parent&lt;/a&gt; () 및 &lt;a href=&quot;qwidget#parentWidget&quot;&gt;QWidget :: parentWidget&lt;/a&gt; () 함수와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7b6ffe3ab4d8704b12584cbfb36c32527f952400" translate="yes" xml:space="preserve">
          <source>The relative XPath expression query for this role. The query must be relative; it cannot start with a '/'.</source>
          <target state="translated">이 역할에 대한 상대 XPath 표현식 쿼리. 쿼리는 상대적이어야합니다. '/'로 시작할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b0cdf55d3a26d00ff11c695b7210876cdddc6631" translate="yes" xml:space="preserve">
          <source>The relative frame coordinate of the point to use for exposure metering in spot metering mode, specified as a &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt;.</source>
          <target state="translated">스팟 측광 모드에서 노출 측광에 사용할 포인트의 상대 프레임 좌표로, &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; 로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="486ac3b7dea93d4423ce027ba1a808a92d5c4f52" translate="yes" xml:space="preserve">
          <source>The relative positioning scheme (&lt;a href=&quot;stylesheet-reference#position-prop&quot;&gt;position&lt;/a&gt; : relative), allows the position of the Sub-Control to be offset from its initial position. For example, when the &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt;'s drop-down button is pressed, we might like the arrow inside to be offset to give a &quot;pressed&quot; effect. To achieve this, we can specify:</source>
          <target state="translated">상대 위치 지정 체계 ( &lt;a href=&quot;stylesheet-reference#position-prop&quot;&gt;position&lt;/a&gt; : relative)는 하위 제어의 위치가 초기 위치에서 오프셋되도록합니다. 예를 들어, &lt;a href=&quot;qcombobox&quot;&gt;QComboBox&lt;/a&gt; 의 드롭 다운 버튼을 누르면 내부의 화살표가 오프셋되어 &quot;눌린&quot;효과를 줄 수 있습니다. 이를 위해 다음을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b0c6007944e1665c0f0185c3b2bfc70d86e6512" translate="yes" xml:space="preserve">
          <source>The relative width of the candlestick item within its own slot, in the range from 0.0 to 1.0. Values outside this range are clamped to 0.0 or 1.0.</source>
          <target state="translated">자체 슬롯 내 촛대 항목의 상대적 너비는 0.0에서 1.0 사이입니다. 이 범위 밖의 값은 0.0 또는 1.0으로 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="30dbf34f27f002866d8b8ca19d35326c091b829f" translate="yes" xml:space="preserve">
          <source>The relative width of the caps within a candlestick, in the range from 0.0 to 1.0. Values outside this range are clamped to 0.0 or 1.0.</source>
          <target state="translated">촛대 내 캡의 상대적 너비는 0.0에서 1.0 사이입니다. 이 범위 밖의 값은 0.0 또는 1.0으로 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="ccf3958e4b6939515c2e3fe74d180fe5375a0635" translate="yes" xml:space="preserve">
          <source>The release of this API with Qt 5.10 is a Technology Preview.</source>
          <target state="translated">Qt 5.10과 함께이 API 릴리스는 기술 평가 사항입니다.</target>
        </trans-unit>
        <trans-unit id="50c84b4ebce3a855cd575a21ddecd7464b7459b7" translate="yes" xml:space="preserve">
          <source>The release of this API with Qt 5.9 is a Technology Preview.</source>
          <target state="translated">Qt 5.9와 함께이 API 릴리스는 기술 평가 사항입니다.</target>
        </trans-unit>
        <trans-unit id="49838519acff85e5f310df8a07874b615296ea9a" translate="yes" xml:space="preserve">
          <source>The remaining functions are &lt;a href=&quot;qtglobal#qRound&quot;&gt;qRound&lt;/a&gt;() and &lt;a href=&quot;qtglobal#qRound64&quot;&gt;qRound64&lt;/a&gt;(), which both accept a &lt;code&gt;double&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt; value as their argument returning the value rounded up to the nearest integer and 64-bit integer respectively, the &lt;a href=&quot;qtglobal#qInstallMessageHandler&quot;&gt;qInstallMessageHandler&lt;/a&gt;() function which installs the given &lt;a href=&quot;qtglobal#QtMessageHandler-typedef&quot;&gt;QtMessageHandler&lt;/a&gt;, and the &lt;a href=&quot;qtglobal#qVersion&quot;&gt;qVersion&lt;/a&gt;() function which returns the version number of Qt at run-time as a string.</source>
          <target state="translated">나머지 기능은 &lt;a href=&quot;qtglobal#qRound&quot;&gt;qRound&lt;/a&gt; () 및 &lt;a href=&quot;qtglobal#qRound64&quot;&gt;qRound64&lt;/a&gt; 둘 다 허용하는 () &lt;code&gt;double&lt;/code&gt; 또는 &lt;code&gt;float&lt;/code&gt; 값을 반환 그 인수 값은 각각 가장 가까운 정수 비트 및 64 비트 정수로 반올림 &lt;a href=&quot;qtglobal#qInstallMessageHandler&quot;&gt;qInstallMessageHandler&lt;/a&gt; 지정된 설치 () 함수 &lt;a href=&quot;qtglobal#QtMessageHandler-typedef&quot;&gt;QtMessageHandler을&lt;/a&gt; , 런타임에 Qt의 버전 번호를 문자열로 반환 하는 &lt;a href=&quot;qtglobal#qVersion&quot;&gt;qVersion&lt;/a&gt; () 함수.</target>
        </trans-unit>
        <trans-unit id="b8108000f860257fa46d4236f1c9527ca1662ef9" translate="yes" xml:space="preserve">
          <source>The remaining macros are convenience macros for larger operations: The &lt;a href=&quot;qtglobal#QT_TR_NOOP&quot;&gt;QT_TR_NOOP&lt;/a&gt;(), &lt;a href=&quot;qtglobal#QT_TRANSLATE_NOOP&quot;&gt;QT_TRANSLATE_NOOP&lt;/a&gt;(), and &lt;a href=&quot;qtglobal#QT_TRANSLATE_NOOP3&quot;&gt;QT_TRANSLATE_NOOP3&lt;/a&gt;() macros provide the possibility of marking strings for delayed translation. &lt;a href=&quot;qtglobal#QT_TR_N_NOOP&quot;&gt;QT_TR_N_NOOP&lt;/a&gt;(), &lt;a href=&quot;qtglobal#QT_TRANSLATE_N_NOOP&quot;&gt;QT_TRANSLATE_N_NOOP&lt;/a&gt;(), and &lt;a href=&quot;qtglobal#QT_TRANSLATE_N_NOOP3&quot;&gt;QT_TRANSLATE_N_NOOP3&lt;/a&gt;() are numerator dependent variants of these. The &lt;a href=&quot;qtglobal#Q_ASSERT&quot;&gt;Q_ASSERT&lt;/a&gt;() and &lt;a href=&quot;qtglobal#Q_ASSERT_X&quot;&gt;Q_ASSERT_X&lt;/a&gt;() enables warning messages of various level of refinement. The &lt;a href=&quot;qtglobal#Q_FOREACH&quot;&gt;Q_FOREACH&lt;/a&gt;() and &lt;a href=&quot;qtglobal#foreach&quot;&gt;foreach&lt;/a&gt;() macros implement Qt's foreach loop.</source>
          <target state="translated">나머지 매크로는 대규모 작업을위한 편의 매크로입니다. &lt;a href=&quot;qtglobal#QT_TR_NOOP&quot;&gt;QT_TR_NOOP&lt;/a&gt; (), &lt;a href=&quot;qtglobal#QT_TRANSLATE_NOOP&quot;&gt;QT_TRANSLATE_NOOP&lt;/a&gt; () 및 &lt;a href=&quot;qtglobal#QT_TRANSLATE_NOOP3&quot;&gt;QT_TRANSLATE_NOOP3&lt;/a&gt; () 매크로는 번역 지연을 위해 문자열을 표시 할 수있는 가능성을 제공합니다. &lt;a href=&quot;qtglobal#QT_TR_N_NOOP&quot;&gt;QT_TR_N_NOOP&lt;/a&gt; (), &lt;a href=&quot;qtglobal#QT_TRANSLATE_N_NOOP&quot;&gt;QT_TRANSLATE_N_NOOP&lt;/a&gt; () 및 &lt;a href=&quot;qtglobal#QT_TRANSLATE_N_NOOP3&quot;&gt;QT_TRANSLATE_N_NOOP3&lt;/a&gt; ()은 이들의 분자 종속 변형입니다. &lt;a href=&quot;qtglobal#Q_ASSERT&quot;&gt;Q_ASSERT&lt;/a&gt; ()와 &lt;a href=&quot;qtglobal#Q_ASSERT_X&quot;&gt;Q_ASSERT_X는&lt;/a&gt; () 정제의 다양한 수준의 경고 메시지를 수 있습니다. &lt;a href=&quot;qtglobal#Q_FOREACH&quot;&gt;Q_FOREACH&lt;/a&gt; ()와 &lt;a href=&quot;qtglobal#foreach&quot;&gt;foreach는&lt;/a&gt; () 매크로는 Qt의 foreach 루프를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ebe7510d1698dac85802bd2844f79b9d7151197b" translate="yes" xml:space="preserve">
          <source>The remaining members of &lt;a href=&quot;qstyleoptiongroupbox&quot;&gt;QStyleOptionGroupBox&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;qstyleoptiongroupbox&quot;&gt;QStyleOptionGroupBox&lt;/a&gt; 의 나머지 멤버는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="24ea8f1c592ba4e0d8a1f78cd2c5547b1b5f2c0c" translate="yes" xml:space="preserve">
          <source>The remaining route segments can be accessed sequentially with &lt;a href=&quot;qgeoroutesegment#nextRouteSegment&quot;&gt;QGeoRouteSegment::nextRouteSegment&lt;/a&gt;.</source>
          <target state="translated">나머지 라우트 세그먼트는 &lt;a href=&quot;qgeoroutesegment#nextRouteSegment&quot;&gt;QGeoRouteSegment :: nextRouteSegment를 사용&lt;/a&gt; 하여 순차적으로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="481be3eae7dd3200a08f18a12e8e85d00807f9f5" translate="yes" xml:space="preserve">
          <source>The remaining text</source>
          <target state="translated">나머지 텍스트</target>
        </trans-unit>
        <trans-unit id="2c68ee7b5f59552c0c6c819e8d88cc2cd4afcfe7" translate="yes" xml:space="preserve">
          <source>The remote Bluetooth Low Energy device with the address passed to the constructor of this class cannot be found.</source>
          <target state="translated">주소가이 클래스의 생성자에게 전달 된 원격 Bluetooth 저에너지 장치를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="268bb3ecaedf6ea75f5252e9a50eaf4cf042b713" translate="yes" xml:space="preserve">
          <source>The remote device closed the connection. This value was introduced by Qt 5.10.</source>
          <target state="translated">원격 장치가 연결을 닫았습니다. 이 값은 Qt 5.10에 의해 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="72a627de591bf36c2583028f1ca47faf8d690f85" translate="yes" xml:space="preserve">
          <source>The remote device uses a public Bluetooth address.</source>
          <target state="translated">원격 장치는 공용 Bluetooth 주소를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="26d2c808f22fbf2893016e0e8b9dabff7d175ba7" translate="yes" xml:space="preserve">
          <source>The remote host closed the connection. Note that the client socket (i.e., this socket) will be closed after the remote close notification has been sent.</source>
          <target state="translated">원격 호스트가 연결을 닫았습니다. 원격 닫기 알림이 전송 된 후 클라이언트 소켓 (예 :이 소켓)이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="d40c3fdf5e515962428e3b65e2acc87d27b4e3b8" translate="yes" xml:space="preserve">
          <source>The remote host closed the connection. This value was introduced by Qt 5.10.</source>
          <target state="translated">원격 호스트가 연결을 닫았습니다. 이 값은 Qt 5.10에 의해 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="50cf405ab359c951595923ee951037f8a3120623" translate="yes" xml:space="preserve">
          <source>The remote positioning backend closed the connection, which happens for example in case the user is switching location services to off. As soon as the location service is re-enabled regular updates will resume.</source>
          <target state="translated">원격 포지셔닝 백엔드는 연결을 닫았습니다. 예를 들어 사용자가 위치 서비스를 끄는 경우에 발생합니다. 위치 서비스가 다시 활성화되면 정기 업데이트가 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="c81ef535ca4612056fc72be6c9fc97d21c457345" translate="yes" xml:space="preserve">
          <source>The remote socket closed the connection. Note that the client socket (i.e., this socket) will be closed after the remote close notification has been sent.</source>
          <target state="translated">원격 소켓이 연결을 닫았습니다. 원격 닫기 알림이 전송 된 후 클라이언트 소켓 (예 :이 소켓)이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="7035faf1330226e10d2fddb79a1e33eabbdcc2e4" translate="yes" xml:space="preserve">
          <source>The removal of a place is performed as follows:</source>
          <target state="translated">장소 제거는 다음과 같이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ea2e684925d1f9781a8c742ce98831a1144a8933" translate="yes" xml:space="preserve">
          <source>The render hints is dirty and needs to be updated.</source>
          <target state="translated">렌더 힌트가 지저분하고 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="7212ec45cae3e81e5d82783c5a5a345e03b266f5" translate="yes" xml:space="preserve">
          <source>The render policy.</source>
          <target state="translated">렌더링 정책.</target>
        </trans-unit>
        <trans-unit id="d59d7bff4fda676045e97b8956d63d545df5827c" translate="yes" xml:space="preserve">
          <source>The render process crashed, for example because of a segmentation fault.</source>
          <target state="translated">예를 들어 세그먼트 오류로 인해 렌더링 프로세스가 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="c48d03c3e2fbb0032e681b6d21e05a7880fd782e" translate="yes" xml:space="preserve">
          <source>The render process terminated normally.</source>
          <target state="translated">렌더 프로세스가 정상적으로 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="72aed47411d12f36e56ef476b339e0a84d8738df" translate="yes" xml:space="preserve">
          <source>The render process terminated with a non-zero exit status.</source>
          <target state="translated">렌더링 프로세스가 0이 아닌 종료 상태로 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="d3ef8c2655d48b3e41e69bf1de9630576fcf481e" translate="yes" xml:space="preserve">
          <source>The render process terminated with with a non-zero exit status.</source>
          <target state="translated">렌더링 프로세스가 0이 아닌 종료 상태로 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="0fd71142a57640d7455f75ce187ec7e0e1a60f1f" translate="yes" xml:space="preserve">
          <source>The render process was killed, for example by &lt;code&gt;SIGKILL&lt;/code&gt; or task manager kill.</source>
          <target state="translated">렌더링 프로세스는 예를 들어 &lt;code&gt;SIGKILL&lt;/code&gt; 또는 작업 관리자 kill에 의해 종료 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="50f5aaa9dd0c8f8ac06b6c60f62b108f3c5c5418" translate="yes" xml:space="preserve">
          <source>The render state contains a number of accessors that the shader needs to respect in order to conform to the current state of the scene graph.</source>
          <target state="translated">렌더 상태에는 씬 그래프의 현재 상태를 준수하기 위해 셰이더가 존중해야하는 여러 접근자가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d01b715362940f36bacd68f81625251bb3bddf56" translate="yes" xml:space="preserve">
          <source>The render thread prepares to draw a new frame and makes the OpenGL context current and initiates a block on the GUI thread.</source>
          <target state="translated">렌더 스레드는 새 프레임을 그릴 준비를하고 OpenGL 컨텍스트를 최신 상태로 만들고 GUI 스레드에서 블록을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="021226e75ed28be7b07dd222d51efa05107d3327" translate="yes" xml:space="preserve">
          <source>The rendered frame is swapped and &lt;a href=&quot;qquickwindow#frameSwapped&quot;&gt;QQuickWindow::frameSwapped&lt;/a&gt;() is emitted.</source>
          <target state="translated">렌더링 된 프레임이 &lt;a href=&quot;qquickwindow#frameSwapped&quot;&gt;바뀌고 QQuickWindow :: frameSwapped&lt;/a&gt; ()가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3e1174291c0675e803165d22e2f17ef46201384f" translate="yes" xml:space="preserve">
          <source>The renderer is implemented in a &lt;a href=&quot;qvulkanwindowrenderer&quot;&gt;QVulkanWindowRenderer&lt;/a&gt; subclass, an instance of which is created in the &lt;a href=&quot;qvulkanwindow#createRenderer&quot;&gt;createRenderer&lt;/a&gt;() factory function.</source>
          <target state="translated">렌더러는 &lt;a href=&quot;qvulkanwindowrenderer&quot;&gt;QVulkanWindowRenderer&lt;/a&gt; 서브 클래스 에서 구현되며 인스턴스는 &lt;a href=&quot;qvulkanwindow#createRenderer&quot;&gt;createRenderer&lt;/a&gt; () 팩토리 함수 에서 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="6cfc6cdbd8a6d989726ec569cef8d2d7ea1e99d8" translate="yes" xml:space="preserve">
          <source>The renderer is unknown.</source>
          <target state="translated">렌더러를 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="405999271c82cc8e4ff86ce9ac1fc3a788589152" translate="yes" xml:space="preserve">
          <source>The renderer lives in the gui/main thread, like the window itself. This thread is then throttled to the presentation rate, similarly to how OpenGL with a swap interval of 1 would behave. However, the renderer implementation is free to utilize multiple threads in any way it sees fit. The accessors like &lt;a href=&quot;qwindow#vulkanInstance&quot;&gt;vulkanInstance&lt;/a&gt;(), &lt;a href=&quot;qvulkanwindow#currentCommandBuffer&quot;&gt;currentCommandBuffer&lt;/a&gt;(), etc. can be called from any thread. The submission of the main command buffer, the queueing of present, and the building of the next frame do not start until &lt;a href=&quot;qvulkanwindow#frameReady&quot;&gt;frameReady&lt;/a&gt;() is invoked on the gui/main thread.</source>
          <target state="translated">렌더러는 창 자체와 같은 gui / main 스레드에 있습니다. 이 스레드는 스왑 간격이 1 인 OpenGL이 작동하는 방식과 유사하게 프리젠 테이션 속도로 조절됩니다. 그러나 렌더러 구현은 원하는 방식으로 여러 스레드를 자유롭게 사용할 수 있습니다. &lt;a href=&quot;qwindow#vulkanInstance&quot;&gt;vulkanInstance&lt;/a&gt; (), &lt;a href=&quot;qvulkanwindow#currentCommandBuffer&quot;&gt;currentCommandBuffer&lt;/a&gt; () 등과 같은 접근자는 모든 스레드에서 호출 할 수 있습니다. 메인 명령 버퍼 제출, 현재 큐잉 및 다음 프레임의 빌드 는 gui / main 스레드에서 &lt;a href=&quot;qvulkanwindow#frameReady&quot;&gt;frameReady&lt;/a&gt; ()가 호출 될 때까지 시작되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2d38d71b45f572d9164959eed6e8c29215a7b3a0" translate="yes" xml:space="preserve">
          <source>The renderer may lack support for certain minor features, such as drawing points and lines with a width other than 1.</source>
          <target state="translated">렌더러는 드로잉 포인트 및 너비가 1 이외의 선과 같은 특정 사소한 피쳐에 대한 지원이 부족할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42e6021cf969d43c31126ab42fbdf36be8841638" translate="yes" xml:space="preserve">
          <source>The renderer modifies the vertex shader returned from &lt;a href=&quot;qsgmaterialshader#vertexShader&quot;&gt;QSGMaterialShader::vertexShader&lt;/a&gt;() and compresses the z values of the vertex after the model-view and projection matrices have been applied and then adds a small translation on the z to position it the correct z position.</source>
          <target state="translated">렌더러는 &lt;a href=&quot;qsgmaterialshader#vertexShader&quot;&gt;QSGMaterialShader :: vertexShader&lt;/a&gt; () 에서 반환 된 정점 셰이더를 수정하고 모델 뷰 및 프로젝션 매트릭스가 적용된 후 정점의 z 값을 압축 한 다음 z에 작은 변환을 추가하여 올바른 z 위치를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="c9329bc2950e018c7f84607a75a66e84c5118c65" translate="yes" xml:space="preserve">
          <source>The renderer processes the nodes and calls OpenGL functions.</source>
          <target state="translated">렌더러는 노드를 처리하고 OpenGL 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="d85a81a166789c82bbc588c3b4dcd6c6bbb5d888" translate="yes" xml:space="preserve">
          <source>The renderer separates between opaque primitives and primitives which require alpha blending. By using OpenGL's Z-buffer and giving each primitive a unique z position, the renderer can freely reorder opaque primitives without any regard for their location on screen and which other elements they overlap with. By looking at each primitive's material state, the renderer will create opaque batches. From Qt Quick core item set, this includes Rectangle items with opaque colors and fully opaque images, such as JPEGs or BMPs.</source>
          <target state="translated">렌더러는 알파 블렌딩이 필요한 불투명 프리미티브와 프리미티브를 분리합니다. OpenGL의 Z- 버퍼를 사용하고 각 프리미티브에 고유 한 z 위치를 제공함으로써 렌더러는 화면상의 위치와 겹치는 다른 요소에 관계없이 불투명 프리미티브를 자유롭게 재정렬 할 수 있습니다. 각 프리미티브의 머티리얼 상태를 보면 렌더러는 불투명 한 배치를 생성합니다. Qt Quick 핵심 항목 세트에는 불투명 한 색상의 사각형 항목과 JPEG 또는 BMP와 같은 완전히 불투명 한 이미지가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="ac6a9f3802f2a5d5a390964d9da37c3119d8152a" translate="yes" xml:space="preserve">
          <source>The rendering function can be changed with the &lt;a href=&quot;qml-qtquick-virtualkeyboard-styles-tracecanvas#renderFunction-prop&quot;&gt;renderFunction&lt;/a&gt; property.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-virtualkeyboard-styles-tracecanvas#renderFunction-prop&quot;&gt;renderFunction&lt;/a&gt; 속성으로 렌더링 기능을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecd37b364d4cd42065c4dc85301e4a91553fac4e" translate="yes" xml:space="preserve">
          <source>The rendering of a &lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; object is handled by the &lt;a href=&quot;qiconengine&quot;&gt;QIconEngine&lt;/a&gt; class. Each icon has a corresponding icon engine that is responsible for drawing the icon with a requested size, mode and state.</source>
          <target state="translated">&lt;a href=&quot;qicon&quot;&gt;QIcon&lt;/a&gt; 객체 의 렌더링은 &lt;a href=&quot;qiconengine&quot;&gt;QIconEngine&lt;/a&gt; 클래스에 의해 처리됩니다 . 각 아이콘에는 요청 된 크기, 모드 및 상태로 아이콘을 그릴 책임이있는 해당 아이콘 엔진이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4c31947736283aa3c54d2eb038fbe66450b89d6" translate="yes" xml:space="preserve">
          <source>The rendering of the headers, weekdays or single days can be largely customized by setting &lt;a href=&quot;qtextcharformat&quot;&gt;QTextCharFormat&lt;/a&gt;'s for some special weekday, a special date or for the rendering of the headers.</source>
          <target state="translated">특별한 요일, 특별한 날짜 또는 헤더의 렌더링에 대해 &lt;a href=&quot;qtextcharformat&quot;&gt;QTextCharFormat&lt;/a&gt; 을 설정하여 헤더, 평일 또는 하루의 렌더링을 크게 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bbb594e532527e41417f89174bf1428d49d6ef4" translate="yes" xml:space="preserve">
          <source>The rendering of the hint is style and platform dependent. Widget styles can use the text information in the rendering for sections, or can choose to ignore it and render sections like simple separators.</source>
          <target state="translated">힌트의 렌더링은 스타일과 플랫폼에 따라 다릅니다. 위젯 스타일은 섹션의 렌더링에서 텍스트 정보를 사용하거나이를 무시하고 간단한 구분 기호와 같은 섹션을 렌더링하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d791ea518431a4642a2e892906e41f97281e9d5" translate="yes" xml:space="preserve">
          <source>The rendering of the hints is style and platform dependent. Widget styles can use the text and icon information in the rendering for sections, or can choose to ignore them and render sections like simple separators.</source>
          <target state="translated">힌트의 렌더링은 스타일과 플랫폼에 따라 다릅니다. 위젯 스타일은 섹션의 렌더링에서 텍스트 및 아이콘 정보를 사용하거나 무시하고 간단한 구분 기호와 같은 섹션을 렌더링하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28764f7385ee67dac75d3749731b655388f644e2" translate="yes" xml:space="preserve">
          <source>The rendering of the scene graph happens internally in the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; class, and there is no public API to access it. There are, however, a few places in the rendering pipeline where the user can attach application code. This can be used to add custom scene graph content or render raw OpenGL content. The integration points are defined by the render loop.</source>
          <target state="translated">장면 그래프의 렌더링은 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 클래스 에서 내부적으로 이루어지며 액세스 할 수있는 공개 API가 없습니다. 그러나 렌더링 파이프 라인에는 사용자가 응용 프로그램 코드를 첨부 할 수있는 곳이 몇 군데 있습니다. 사용자 정의 장면 그래프 컨텐츠를 추가하거나 원시 OpenGL 컨텐츠를 렌더링하는 데 사용할 수 있습니다. 통합 지점은 렌더 루프에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a55a57a6cc9925904aca05076bbb2460f71c0a95" translate="yes" xml:space="preserve">
          <source>The rep file defines an interface, but interfaces often require external elements. In order to support this, repc will include any (single line) directives at the top of the generated files. This allows you to, for instance, use #include or #define directives that support the logic or datatypes needed.</source>
          <target state="translated">rep 파일은 인터페이스를 정의하지만 인터페이스에는 종종 외부 요소가 필요합니다. 이를 지원하기 위해 repc는 생성 된 파일의 맨 위에 (한 줄) 지시문을 포함합니다. 예를 들어 필요한 논리 또는 데이터 유형을 지원하는 #include 또는 #define 지시문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aa7be4844cee6ce7de78fd84fcbf63a2012e47e" translate="yes" xml:space="preserve">
          <source>The rep file format</source>
          <target state="translated">담당자 파일 형식</target>
        </trans-unit>
        <trans-unit id="8b7c2aa2523f53907e5af73ce137d83e407d1dc3" translate="yes" xml:space="preserve">
          <source>The rep file format is a simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Domain-specific_language#&quot;&gt;Domain Specific Language (DSL)&lt;/a&gt; for describing an interface supported over Qt Remote Objects (QtRO). Since QtRO is an object based system, these interfaces are defined by APIs available through objects, that is, classes with properties, signals, and slots.</source>
          <target state="translated">rep 파일 형식은 QtRO (Qt Remote Objects)를 통해 지원되는 인터페이스를 설명하기위한 간단한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Domain-specific_language#&quot;&gt;DSL (Domain Specific Language&lt;/a&gt; )입니다. QtRO는 객체 기반 시스템이므로 이러한 인터페이스는 객체를 통해 사용 가능한 API, 즉 속성, 신호 및 슬롯이있는 클래스로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="4e85045c9b4aad1c1ff2a6f46ee3ddcfb6d80d22" translate="yes" xml:space="preserve">
          <source>The repc tool currently ignores everything from the &quot;#&quot; symbol to the end-of-line and adds that to the generated files. So multi-line #if/#else/#endif statements and multi-line macros are not supported.</source>
          <target state="translated">repc 도구는 현재 &quot;#&quot;기호부터 줄 끝까지의 모든 것을 무시하고 생성 된 파일에 추가합니다. 따라서 여러 줄 # if / # else / # endif 문과 여러 줄 매크로는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94e4098e9cdb06e673347f49d0cae5fb6451c89a" translate="yes" xml:space="preserve">
          <source>The replace content to be used in conjunction with &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#columnRolePattern-prop&quot;&gt;columnRolePattern&lt;/a&gt;. Defaults to an empty string. For more information on how the search and replace using regular expressions works, see the &lt;a href=&quot;qstring#replace&quot;&gt;QString::replace&lt;/a&gt;(const &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; &amp;amp;rx, const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp;after) function documentation.</source>
          <target state="translated">&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#columnRolePattern-prop&quot;&gt;columnRolePattern&lt;/a&gt; 과 함께 사용될 대체 내용 입니다. 기본값은 빈 문자열입니다. 정규 표현식을 사용한 검색 및 바꾸기 작동 방식에 대한 자세한 정보는 &lt;a href=&quot;qstring#replace&quot;&gt;QString :: replace&lt;/a&gt; (const &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; &amp;amp; rx, const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp; after) 함수 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4f6eab0d031c629d545f629a9a01bba76799b253" translate="yes" xml:space="preserve">
          <source>The replace content to be used in conjunction with &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#rowRolePattern-prop&quot;&gt;rowRolePattern&lt;/a&gt;. Defaults to an empty string. For more information on how the search and replace using regular expressions works, see the &lt;a href=&quot;qstring#replace&quot;&gt;QString::replace&lt;/a&gt;(const &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; &amp;amp;rx, const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp;after) function documentation.</source>
          <target state="translated">&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#rowRolePattern-prop&quot;&gt;rowRolePattern&lt;/a&gt; 과 함께 사용될 대체 내용 입니다. 기본값은 빈 문자열입니다. 정규 표현식을 사용한 검색 및 바꾸기 작동 방식에 대한 자세한 정보는 &lt;a href=&quot;qstring#replace&quot;&gt;QString :: replace&lt;/a&gt; (const &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; &amp;amp; rx, const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp; after) 함수 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d93b58a054db2ceaa2d4a58087de982043b561b1" translate="yes" xml:space="preserve">
          <source>The replace content to be used in conjunction with &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#xPosRolePattern-prop&quot;&gt;xPosRolePattern&lt;/a&gt;. Defaults to an empty string. For more information on how the search and replace using regular expressions works, see the &lt;a href=&quot;qstring#replace&quot;&gt;QString::replace&lt;/a&gt;(const &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; &amp;amp;rx, const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp;after) function documentation.</source>
          <target state="translated">&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#xPosRolePattern-prop&quot;&gt;xPosRolePattern&lt;/a&gt; 과 함께 사용할 대체 내용 입니다. 기본값은 빈 문자열입니다. 정규 표현식을 사용한 검색 및 바꾸기 작동 방식에 대한 자세한 정보는 &lt;a href=&quot;qstring#replace&quot;&gt;QString :: replace&lt;/a&gt; (const &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; &amp;amp; rx, const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp; after) 함수 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="34434ed08681fd26d0a5ea517f5b1b4e324847dd" translate="yes" xml:space="preserve">
          <source>The replace content to be used in conjunction with &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#yPosRolePattern-prop&quot;&gt;yPosRolePattern&lt;/a&gt;. Defaults to an empty string. For more information on how the search and replace using regular expressions works, see the &lt;a href=&quot;qstring#replace&quot;&gt;QString::replace&lt;/a&gt;(const &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; &amp;amp;rx, const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp;after) function documentation.</source>
          <target state="translated">&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#yPosRolePattern-prop&quot;&gt;yPosRolePattern&lt;/a&gt; 과 함께 사용할 대체 내용 입니다. 기본값은 빈 문자열입니다. 정규 표현식을 사용한 검색 및 바꾸기 작동 방식에 대한 자세한 정보는 &lt;a href=&quot;qstring#replace&quot;&gt;QString :: replace&lt;/a&gt; (const &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; &amp;amp; rx, const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp; after) 함수 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4b5adbf228d94487ab773942ffc73760f1f503ce" translate="yes" xml:space="preserve">
          <source>The replace content to be used in conjunction with &lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#zPosRolePattern-prop&quot;&gt;zPosRolePattern&lt;/a&gt;. Defaults to an empty string. For more information on how the search and replace using regular expressions works, see the &lt;a href=&quot;qstring#replace&quot;&gt;QString::replace&lt;/a&gt;(const &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; &amp;amp;rx, const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp;after) function documentation.</source>
          <target state="translated">&lt;a href=&quot;qml-qtdatavisualization-itemmodelsurfacedataproxy#zPosRolePattern-prop&quot;&gt;zPosRolePattern&lt;/a&gt; 과 함께 사용할 대체 컨텐츠 입니다. 기본값은 빈 문자열입니다. 정규 표현식을 사용한 검색 및 바꾸기 작동 방식에 대한 자세한 정보는 &lt;a href=&quot;qstring#replace&quot;&gt;QString :: replace&lt;/a&gt; (const &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; &amp;amp; rx, const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp; after) 함수 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="20aa269b93bb76f75d98c23874191bbbc7bea348" translate="yes" xml:space="preserve">
          <source>The reply originates from a Modbus broadcast request. The &lt;a href=&quot;qmodbusreply#serverAddress&quot;&gt;serverAddress&lt;/a&gt;() will return &lt;code&gt;0&lt;/code&gt; and the &lt;a href=&quot;qmodbusreply#finished&quot;&gt;finished&lt;/a&gt;() signal will be emitted immediately.</source>
          <target state="translated">회신은 Modbus 브로드 캐스트 요청에서 시작됩니다. &lt;a href=&quot;qmodbusreply#serverAddress&quot;&gt;serverAddress는&lt;/a&gt; ()를 호출한다 &lt;code&gt;0&lt;/code&gt; 및 &lt;a href=&quot;qmodbusreply#finished&quot;&gt;마무리&lt;/a&gt; () 신호는 즉시 방출한다.</target>
        </trans-unit>
        <trans-unit id="32b9fbd6c35b20dea6bfe5c6e1cdceb805b063a8" translate="yes" xml:space="preserve">
          <source>The reply originates from a common read, write or read/write request. See &lt;a href=&quot;qmodbusclient#sendReadRequest&quot;&gt;QModbusClient::sendReadRequest&lt;/a&gt;, &lt;a href=&quot;qmodbusclient#sendWriteRequest&quot;&gt;QModbusClient::sendWriteRequest&lt;/a&gt; and &lt;a href=&quot;qmodbusclient#sendReadWriteRequest&quot;&gt;QModbusClient::sendReadWriteRequest&lt;/a&gt;</source>
          <target state="translated">응답은 공통 읽기, 쓰기 또는 읽기 / 쓰기 요청에서 시작됩니다. &lt;a href=&quot;qmodbusclient#sendReadRequest&quot;&gt;QModbusClient :: sendReadRequest&lt;/a&gt; , &lt;a href=&quot;qmodbusclient#sendWriteRequest&quot;&gt;QModbusClient :: sendWriteRequest&lt;/a&gt; 및 &lt;a href=&quot;qmodbusclient#sendReadWriteRequest&quot;&gt;QModbusClient :: sendReadWriteRequest를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0bc6fb999bd7683da90d545bd22e20a6fe5231e9" translate="yes" xml:space="preserve">
          <source>The reply originates from a raw Modbus request. See &lt;a href=&quot;qmodbusclient#sendRawRequest&quot;&gt;QModbusClient::sendRawRequest&lt;/a&gt;</source>
          <target state="translated">응답은 원시 Modbus 요청에서 시작됩니다. &lt;a href=&quot;qmodbusclient#sendRawRequest&quot;&gt;QModbusClient :: sendRawRequest를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7b814ed049a0479582dcfcd9125cf3fbe82a3c02" translate="yes" xml:space="preserve">
          <source>The reply was aborted due to a disconnection of the device.</source>
          <target state="translated">기기 연결이 끊어져서 회신이 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="aee03cbfa3d52f5ac2f413684553766428bba30f" translate="yes" xml:space="preserve">
          <source>The reply was created for a remove category operation.</source>
          <target state="translated">카테고리 제거 작업에 대한 회신이 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="cdfdb92cac9357931752c7be4846ce9e575fd7b1" translate="yes" xml:space="preserve">
          <source>The reply was created for a remove place operation.</source>
          <target state="translated">장소 제거 작업에 대한 회신이 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="b98909b8e54abd85b28c6ee3c6ac77d4c5eff4a2" translate="yes" xml:space="preserve">
          <source>The reply was created for a save category operation</source>
          <target state="translated">카테고리 저장 조작에 대한 회신이 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="a006ee005b54fe3093905fb257600ed9e21d26bc" translate="yes" xml:space="preserve">
          <source>The reply was created for a save place operation</source>
          <target state="translated">장소 저장 작업에 대한 회신이 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="0c66fc361e95aa6e25d06a1f892f6166a5273890" translate="yes" xml:space="preserve">
          <source>The reply will be send to the Modbus client represented by</source>
          <target state="translated">답장은 Modbus 클라이언트로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="101e2f2e82be87c39f57ab103a74e4ebf487b60c" translate="yes" xml:space="preserve">
          <source>The reported name of the gamepad if one is available.</source>
          <target state="translated">사용 가능한 경우 게임 패드의보고 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c73bfae9773826e0bbabe6d92d6bddaea1696394" translate="yes" xml:space="preserve">
          <source>The reported velocity is smoothed to avoid erratic output.</source>
          <target state="translated">불규칙한 출력을 피하기 위해보고 된 속도가 부드럽게됩니다.</target>
        </trans-unit>
        <trans-unit id="9b647678e5212624e757628f9a78c428ccede084" translate="yes" xml:space="preserve">
          <source>The representation of the DTD in the document tree</source>
          <target state="translated">문서 트리에서 DTD 표현</target>
        </trans-unit>
        <trans-unit id="9f2e68f5306aeac0897627bf810f854648f15a25" translate="yes" xml:space="preserve">
          <source>The request failed.</source>
          <target state="translated">요청이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="4a87ebfca6028a84f1c98e2e8e25288dc441e2e4" translate="yes" xml:space="preserve">
          <source>The request is an asynchronous operation so we need a slot to handle the completion of the request. In the handler we check that there are no errors and that our search result type is a place. If so we can then retrieve some of the core details of the place. At the end of the slot, we delete the reply since they are for single use only.</source>
          <target state="translated">요청은 비동기 작업이므로 요청 완료를 처리하는 슬롯이 필요합니다. 핸들러에서 오류가없고 검색 결과 유형이 올바른지 확인합니다. 그렇다면 우리는 장소의 핵심 세부 사항 중 일부를 검색 할 수 있습니다. 슬롯 끝에서 답글은 일회용이므로 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="aa4d63e3636298fbef836af311263acfcd0c2e08" translate="yes" xml:space="preserve">
          <source>The request object</source>
          <target state="translated">요청 객체</target>
        </trans-unit>
        <trans-unit id="7ef95f14af3e24b8942c944144d6749c5aca09d7" translate="yes" xml:space="preserve">
          <source>The request was canceled.</source>
          <target state="translated">요청이 취소되었습니다.</target>
        </trans-unit>
        <trans-unit id="cca7625dae4b9a200905258fe88ad122bd64a65c" translate="yes" xml:space="preserve">
          <source>The request was denied.</source>
          <target state="translated">요청이 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="892ac445db33ec361f0a2f9e8b9adbe27033c1db" translate="yes" xml:space="preserve">
          <source>The request was successful.</source>
          <target state="translated">요청이 성공했습니다.</target>
        </trans-unit>
        <trans-unit id="f7c79cfed6458e3e528ab941cdb5cdfa1e62a409" translate="yes" xml:space="preserve">
          <source>The requested URL is invalid.</source>
          <target state="translated">요청하신 URL이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd26288edf8a8afb730906c752d8124e635239bd" translate="yes" xml:space="preserve">
          <source>The requested URL was not found.</source>
          <target state="translated">요청하신 URL을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5bdf0d9e2037fe9c25b23ae1eea62451296b7f8a" translate="yes" xml:space="preserve">
          <source>The requested and the actual format may differ. Requesting a given OpenGL version does not mean the resulting context will target exactly the requested version. It is only guaranteed that the version/profile/options combination for the created context is compatible with the request, as long as the driver is able to provide such a context.</source>
          <target state="translated">요청한 형식과 실제 형식이 다를 수 있습니다. 주어진 OpenGL 버전을 요청한다고해서 결과 컨텍스트가 요청 된 버전을 정확하게 대상으로한다는 의미는 아닙니다. 드라이버가 해당 컨텍스트를 제공 할 수있는 경우 작성된 ​​컨텍스트에 대한 버전 / 프로파일 / 옵션 조합이 요청과 호환되는 것만 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="d4926cd421f435d5a7ee48fa383b829da4cfe263" translate="yes" xml:space="preserve">
          <source>The requested device operation is not supported or prohibited by the running operating system.</source>
          <target state="translated">요청한 장치 작업이 실행중인 운영 체제에서 지원되거나 금지되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="856578417ff89a98759cd00c77adf6e787be7deb" translate="yes" xml:space="preserve">
          <source>The requested operation is unsupported by this near field target.</source>
          <target state="translated">이 근거리 대상이 요청한 작업을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a290c0a190d0050311ad4640b591975eddd4df0" translate="yes" xml:space="preserve">
          <source>The requested operation or one of the options for the operation are not supported by the service provider.</source>
          <target state="translated">요청한 작업 또는 작업 옵션 중 하나가 서비스 공급자에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e6d15208eb10f738d2d9c45b7497c6bc09a42b9" translate="yes" xml:space="preserve">
          <source>The requested socket operation is not supported by the local operating system (e.g., lack of IPv6 support).</source>
          <target state="translated">요청 된 소켓 작업이 로컬 운영 체제에서 지원되지 않습니다 (예 : IPv6 지원 부족).</target>
        </trans-unit>
        <trans-unit id="dfeb14f9a0c24719dab19df32c3392b0a444f103" translate="yes" xml:space="preserve">
          <source>The requested socket operation is not supported by the local operating system.</source>
          <target state="translated">요청한 소켓 작업이 로컬 운영 체제에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fa0899e2ab8e017f36b1a3e9e6ddeb097227eae" translate="yes" xml:space="preserve">
          <source>The requestor object used for this example is the dynamic replica client discussed in &lt;a href=&quot;#qtro-example2&quot;&gt;Example 2&lt;/a&gt;.</source>
          <target state="translated">이 예에 사용 된 요청자 객체는 &lt;a href=&quot;#qtro-example2&quot;&gt;예 2&lt;/a&gt; 에서 설명한 동적 복제본 클라이언트 입니다.</target>
        </trans-unit>
        <trans-unit id="6cb9ccc62f57c33e531a1b864e1c215eddbf9e91" translate="yes" xml:space="preserve">
          <source>The requirements for a model that only allows items to be exported from a view, and which does not allow data to be dropped into it, are fewer than those for a fully-enabled drag and drop model.</source>
          <target state="translated">항목을보기에서만 내보낼 수 있고 데이터를 끌어 놓을 수없는 모델의 요구 사항은 완전히 활성화 된 끌어서 놓기 모델의 요구 사항보다 적습니다.</target>
        </trans-unit>
        <trans-unit id="0878dcc5a7be2124ae3a490c24167c8dfcd53844" translate="yes" xml:space="preserve">
          <source>The requirements for building Qt 5 modules from source are listed separately for each supported platform:</source>
          <target state="translated">소스에서 Qt 5 모듈을 빌드하기위한 요구 사항은 지원되는 각 플랫폼에 대해 별도로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="6d385d8972858c7bf4bd27a60662c794beb20745" translate="yes" xml:space="preserve">
          <source>The requirements of &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclasses is described in more detail in the &lt;a href=&quot;#model-subclassing-reference&quot;&gt;Model Subclassing Reference&lt;/a&gt; document.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 서브 클래스 의 요구 사항은 &lt;a href=&quot;#model-subclassing-reference&quot;&gt;모델 서브&lt;/a&gt; 클래 싱 참조 문서에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7523c20f93d244a7951fba6d7edb3e194fdc0c5" translate="yes" xml:space="preserve">
          <source>The reset method will be called by assigning undefined.</source>
          <target state="translated">재설정 메소드는 undefined를 지정하여 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3143d6277c67efbe49f158f858755b8c3a74ca48" translate="yes" xml:space="preserve">
          <source>The resize event is called whenever the window is resized in the windowing system, either directly through the windowing system acknowledging a &lt;a href=&quot;qwindow#setGeometry&quot;&gt;setGeometry&lt;/a&gt;() or &lt;a href=&quot;qwindow#resize&quot;&gt;resize&lt;/a&gt;() request, or indirectly through the user resizing the window manually.</source>
          <target state="translated">resize 이벤트는 &lt;a href=&quot;qwindow#setGeometry&quot;&gt;setGeometry&lt;/a&gt; () 또는 &lt;a href=&quot;qwindow#resize&quot;&gt;resize&lt;/a&gt; () 요청을 확인하는 윈도우 시스템을 통해 직접 또는 윈도우 크기를 수동으로 사용자를 통해 간접적으로 윈도우 시스템에서 윈도우 크기를 조정할 때마다 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="3ef2955784264ce09080959bea214d7a1c250cf6" translate="yes" xml:space="preserve">
          <source>The resize mode specifies the behavior of the header sections. It can be set on the entire header view or on individual sections using &lt;a href=&quot;qheaderview#setSectionResizeMode&quot;&gt;setSectionResizeMode&lt;/a&gt;().</source>
          <target state="translated">크기 조정 모드는 헤더 섹션의 동작을 지정합니다. &lt;a href=&quot;qheaderview#setSectionResizeMode&quot;&gt;setSectionResizeMode&lt;/a&gt; ()를 사용하여 전체 헤더보기 또는 개별 섹션에서 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8240fad60fd5f9a36ae9016489c96c551d9c9fdf" translate="yes" xml:space="preserve">
          <source>The resolution is specified in dots per inch, and is used to calculate the physical size of an SVG drawing.</source>
          <target state="translated">해상도는 인치당 도트 수로 지정되며 SVG 도면의 실제 크기를 계산하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7144f09cf88bce1d10fb3e7155505330eb740a61" translate="yes" xml:space="preserve">
          <source>The resource contains CSS.</source>
          <target state="translated">리소스에는 CSS가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="11f3edb8282eaedf3c5711831123df7e412d120b" translate="yes" xml:space="preserve">
          <source>The resource contains HTML.</source>
          <target state="translated">리소스에 HTML이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d96ea069f293fec1eb3f609a0264a4917270f46" translate="yes" xml:space="preserve">
          <source>The resource contains image data. Currently supported data types are QVariant::Pixmap and QVariant::Image. If the corresponding variant is of type QVariant::ByteArray then Qt attempts to load the image using &lt;a href=&quot;qimage#loadFromData&quot;&gt;QImage::loadFromData&lt;/a&gt;. QVariant::Icon is currently not supported. The icon needs to be converted to one of the supported types first, for example using &lt;a href=&quot;qicon#pixmap&quot;&gt;QIcon::pixmap&lt;/a&gt;.</source>
          <target state="translated">리소스에는 이미지 데이터가 포함되어 있습니다. 현재 지원되는 데이터 유형은 QVariant :: Pixmap 및 QVariant :: Image입니다. 해당 변형이 QVariant :: ByteArray 유형 인 경우 Qt는 &lt;a href=&quot;qimage#loadFromData&quot;&gt;QImage :: loadFromData를&lt;/a&gt; 사용하여 이미지로드를 시도합니다 . QVariant :: Icon은 현재 지원되지 않습니다. 아이콘은 먼저 지원되는 유형 중 하나로 변환되어야합니다 (예 &lt;a href=&quot;qicon#pixmap&quot;&gt;: QIcon :: pixmap)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="846a8769e886104b6c9a647e0a7ba40990805a00" translate="yes" xml:space="preserve">
          <source>The resource files listed in the &lt;code&gt;.qrc&lt;/code&gt; file are files that are part of the application's source tree. The specified paths are relative to the directory containing the &lt;code&gt;.qrc&lt;/code&gt; file. Note that the listed resource files must be located in the same directory as the &lt;code&gt;.qrc&lt;/code&gt; file, or one of its subdirectories.</source>
          <target state="translated">&lt;code&gt;.qrc&lt;/code&gt; 파일에 나열된 리소스 파일 은 응용 프로그램 소스 트리의 일부인 파일입니다. 지정된 경로는 &lt;code&gt;.qrc&lt;/code&gt; 파일을 포함하는 디렉토리에 상대적 입니다. 나열된 자원 파일은 &lt;code&gt;.qrc&lt;/code&gt; 파일 과 동일한 디렉토리 또는 해당 서브 디렉토리 중 하나에 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="df269232e03f7f22925553c75c707cf31356fdc7" translate="yes" xml:space="preserve">
          <source>The resource system is based on tight cooperation between &lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt;, &lt;a href=&quot;rcc&quot;&gt;rcc&lt;/a&gt; (Qt's resource compiler), and &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt;.</source>
          <target state="translated">자원 시스템은 &lt;a href=&quot;qmake-manual&quot;&gt;qmake&lt;/a&gt; , &lt;a href=&quot;rcc&quot;&gt;rcc&lt;/a&gt; (Qt의 자원 컴파일러) 및 &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; 간의 긴밀한 협력을 기반으로 합니다.</target>
        </trans-unit>
        <trans-unit id="01846baca86d6e207b12b9149eafdcfd4847181d" translate="yes" xml:space="preserve">
          <source>The resources associated with an application are specified in a &lt;code&gt;.qrc&lt;/code&gt; file, an XML-based file format that lists files on the disk and optionally assigns them a resource name that the application must use to access the resource.</source>
          <target state="translated">응용 프로그램과 관련된 리소스 는 디스크의 파일을 나열하고 응용 프로그램이 리소스에 액세스하는 데 사용해야하는 리소스 이름을 선택적으로 할당하는 XML 기반 파일 형식 인 &lt;code&gt;.qrc&lt;/code&gt; 파일로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="96593145fb324450ad5f1587b7cb7f5b293055a7" translate="yes" xml:space="preserve">
          <source>The respective QML properties are &lt;a href=&quot;qml-qtwebengine-webengineview#devToolsView-prop&quot;&gt;WebEngineView.devToolsView&lt;/a&gt; and &lt;a href=&quot;qml-qtwebengine-webengineview#inspectedView-prop&quot;&gt;WebEngineView.inspectedView&lt;/a&gt;.</source>
          <target state="translated">각각의 QML 특성은 &lt;a href=&quot;qml-qtwebengine-webengineview#devToolsView-prop&quot;&gt;WebEngineView.devToolsView&lt;/a&gt; 및 &lt;a href=&quot;qml-qtwebengine-webengineview#inspectedView-prop&quot;&gt;WebEngineView.inspectedView&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="97f12fd63cfd08c46ff183c6e02d64c4bd8eabf0" translate="yes" xml:space="preserve">
          <source>The response from the service provider or an import file was in an unrecognizable format</source>
          <target state="translated">서비스 제공 업체 또는 가져 오기 파일의 응답이 인식 할 수없는 형식입니다</target>
        </trans-unit>
        <trans-unit id="828d7128978e1aa8cdff8891db4b01f3a32b96c8" translate="yes" xml:space="preserve">
          <source>The response from the service provider was in an unrecognizable format.</source>
          <target state="translated">서비스 제공 업체의 응답이 인식 할 수없는 형식이었습니다.</target>
        </trans-unit>
        <trans-unit id="9609d0743a45b07b56be45e247142d8f727d91a4" translate="yes" xml:space="preserve">
          <source>The rest of encoding settings are respected regardless of encoding mode.</source>
          <target state="translated">나머지 인코딩 설정은 인코딩 모드에 관계없이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b84f5bbb28c67e41b00b8e7f95fe8f0583e9f5b8" translate="yes" xml:space="preserve">
          <source>The rest of the document focuses mainly on how to implement drag and drop in C++. For using drag and drop inside a Qt Quick scene, please read the documentation for the Qt Quick &lt;a href=&quot;qml-qtquick-drag&quot;&gt;Drag&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-dragevent&quot;&gt;DragEvent&lt;/a&gt;, and &lt;a href=&quot;qml-qtquick-droparea&quot;&gt;DropArea&lt;/a&gt; items, as well as the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-draganddrop-example.html&quot;&gt;Qt Quick Drag and Drop&lt;/a&gt; examples.</source>
          <target state="translated">이 문서의 나머지 부분에서는 주로 C ++에서 끌어서 놓기를 구현하는 방법에 중점을 둡니다. Qt Quick 장면 내에서 드래그 앤 드롭을 사용 하려면 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-draganddrop-example.html&quot;&gt;Qt Quick Drag 및 Drop&lt;/a&gt; 예제 뿐만 아니라 Qt Quick &lt;a href=&quot;qml-qtquick-drag&quot;&gt;Drag&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-dragevent&quot;&gt;DragEvent&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-droparea&quot;&gt;DropArea&lt;/a&gt; 항목에 대한 설명서를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="8b6e82347549e63989f320374cc14695ee0d4168" translate="yes" xml:space="preserve">
          <source>The rest of the function just displays the views within a splitter widget, and runs the application's event loop:</source>
          <target state="translated">나머지 함수는 스플리터 위젯 내에서보기를 표시하고 애플리케이션의 이벤트 루프를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="2b7be9a9cf34621cbe9e4afc09bb31919fcf2d0c" translate="yes" xml:space="preserve">
          <source>The rest of the members in the spin box style options are:</source>
          <target state="translated">스핀 상자 스타일 옵션의 나머지 멤버는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="58e98e9fda9081de5ee5d3970ae0f12385f760f1" translate="yes" xml:space="preserve">
          <source>The restore policy for states of this state machine.</source>
          <target state="translated">이 상태 머신의 상태에 대한 복원 정책.</target>
        </trans-unit>
        <trans-unit id="bb9f010c21ef59ee53312b1bb56f6978a48a11df" translate="yes" xml:space="preserve">
          <source>The result consists of a state value (one of Ignore, MayBeGesture, TriggerGesture, FinishGesture, CancelGesture) and an optional hint (ConsumeEventHint).</source>
          <target state="translated">결과는 상태 값 (Ignore, MayBeGesture, TriggerGesture, FinishGesture, CancelGesture 중 하나)과 선택적 힌트 (ConsumeEventHint)로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f1487e68d93b9773ac2bb336e7d5a025c53752ad" translate="yes" xml:space="preserve">
          <source>The result has the length of the longest of the two bit arrays, with any missing bits (if one array is shorter than the other) taken to be 0.</source>
          <target state="translated">결과는 두 비트 배열 중 가장 긴 길이를 가지며 누락 된 비트 (한 배열이 다른 배열보다 짧은 경우)는 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="1b2343e47f741cef215e3e4def72c7e15ef6ddf4" translate="yes" xml:space="preserve">
          <source>The result is a list widget which allows the items to be copied around within the view, and even lets the user drag items between views containing the same type of data. In both situations, the items are copied rather than moved.</source>
          <target state="translated">결과는보기 내에서 항목을 복사 할 수있는 목록 위젯이며, 동일한 유형의 데이터가 포함 된보기간에 항목을 끌 수도 있습니다. 두 경우 모두 항목이 이동되지 않고 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="0bb8c0d7c285e6a056eff23e313f84fa166d4e28" translate="yes" xml:space="preserve">
          <source>The result is derived from &lt;a href=&quot;qlayoutitem#sizeHint&quot;&gt;sizeHint&lt;/a&gt;() and expanding(). It is never larger than</source>
          <target state="translated">결과는 &lt;a href=&quot;qlayoutitem#sizeHint&quot;&gt;sizeHint&lt;/a&gt; () 및 확장 () 에서 파생됩니다 . 결코 더 크지 않습니다</target>
        </trans-unit>
        <trans-unit id="0017ac5282ca490ea09d5e5413159c9a7e16bf82" translate="yes" xml:space="preserve">
          <source>The result is the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; value of the object (no conversion).</source>
          <target state="translated">결과는 오브젝트 의 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 값입니다 (변환 없음).</target>
        </trans-unit>
        <trans-unit id="53e332ca63bb528d25e2ca0fc5665191856d9010" translate="yes" xml:space="preserve">
          <source>The result of a &lt;code&gt;find_package&lt;/code&gt; call is that imported targets will be created for use with &lt;code&gt;target_link_libraries&lt;/code&gt;, some variables will be populated with information required to configure the build, and macros will be made available for use. The name of the imported target for each module matches the name of the module with a prefix of 'Qt5::', for example Qt5::Widgets. All of the package-specific variables have a consistent name with a prefix of the name of the package. For example, &lt;code&gt;find_package(Qt5 COMPONENTS Widgets)&lt;/code&gt; will make the following variables available if successfully found:</source>
          <target state="translated">&lt;code&gt;find_package&lt;/code&gt; 호출 의 결과로 가져온 대상이 &lt;code&gt;target_link_libraries&lt;/code&gt; 와 함께 사용되도록 작성 되고 일부 변수에는 빌드를 구성하는 데 필요한 정보가 채워지고 매크로를 사용할 수있게됩니다. 각 모듈에 대해 가져온 대상의 이름은 접두사가 'Qt5 ::'인 모듈 이름과 일치합니다 (예 : Qt5 :: Widgets). 모든 패키지 특정 변수에는 패키지 이름의 접두사가있는 일관된 이름이 있습니다. 예를 들어, &lt;code&gt;find_package(Qt5 COMPONENTS Widgets)&lt;/code&gt; 는 성공적으로 찾은 경우 다음 변수를 사용 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="d578abbbead40b261c9aa6f762757f25a9e6e7ad" translate="yes" xml:space="preserve">
          <source>The result of the build process is an application bundle, which is a directory structure that contains the actual application executable. The application can be launched by double-clicking it in Finder, or by referring directly to its executable from the command line, for example, &lt;code&gt;myApp.app/Contents/MacOS/myApp&lt;/code&gt;.</source>
          <target state="translated">빌드 프로세스의 결과는 실제 애플리케이션 실행 파일이 포함 된 디렉토리 구조 인 애플리케이션 번들입니다. 응용 프로그램은 Finder에서 응용 프로그램을 두 번 클릭하거나 명령 줄에서 실행 파일을 직접 참조하여 &lt;code&gt;myApp.app/Contents/MacOS/myApp&lt;/code&gt; 있습니다 ( 예 : myApp.app/Contents/MacOS/myApp) .</target>
        </trans-unit>
        <trans-unit id="4e098df6153e544affa48c66d475a483af0ed006" translate="yes" xml:space="preserve">
          <source>The result of the function is not affected by the result of &lt;a href=&quot;qvariant#isNull&quot;&gt;QVariant::isNull&lt;/a&gt;, which means that two values can be equal even if one of them is null and another is not.</source>
          <target state="translated">함수의 결과는 &lt;a href=&quot;qvariant#isNull&quot;&gt;QVariant :: isNull&lt;/a&gt; 의 결과에 영향을받지 않습니다. 즉, 두 값 중 하나가 널이고 다른 값이 아닌 경우에도 두 값이 같을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="102ab45feb3076e4ff2162d8a8fcaa33e02cc6ee" translate="yes" xml:space="preserve">
          <source>The result reflects how much of the gesture has been recognized. The state of the</source>
          <target state="translated">결과는 인식 된 제스처의 양을 반영합니다. 의 상태</target>
        </trans-unit>
        <trans-unit id="8dfb2180f251584661cf4c3383e131d81e581f81" translate="yes" xml:space="preserve">
          <source>The result will be 0, 90, 180, or 270.</source>
          <target state="translated">결과는 0, 90, 180 또는 270입니다.</target>
        </trans-unit>
        <trans-unit id="8d82abe666c37c29fa16843525457a55b1b189ee" translate="yes" xml:space="preserve">
          <source>The result would have been the same if we had written</source>
          <target state="translated">우리가 쓴다면 결과는 같을 것입니다</target>
        </trans-unit>
        <trans-unit id="01be55a0c09b1d115faa58cff213ed7e949d0a99" translate="yes" xml:space="preserve">
          <source>The result:</source>
          <target state="translated">결과:</target>
        </trans-unit>
        <trans-unit id="cb03486b7b7b490cd40aa86f8b466f3b7d3e6da4" translate="yes" xml:space="preserve">
          <source>The resulting &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; can be passed back to a &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; later on.</source>
          <target state="translated">결과 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 은 나중에 &lt;a href=&quot;qurl&quot;&gt;QUrl로&lt;/a&gt; 다시 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee4c98ecdb330bc882223a45c9c7d197188961b8" translate="yes" xml:space="preserve">
          <source>The resulting image is transformed using bilinear filtering.</source>
          <target state="translated">결과 이미지는 이중 선형 필터링을 사용하여 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="811e3ec51abd22d1d3b5c7bcf597dcf995079caf" translate="yes" xml:space="preserve">
          <source>The resulting line has no trailing end-of-line characters (&quot;\n&quot; or &quot;\r\n&quot;), so calling &lt;a href=&quot;qstring#trimmed&quot;&gt;QString::trimmed&lt;/a&gt;() can be unnecessary.</source>
          <target state="translated">결과 줄에는 줄 끝 문자 ( &quot;\ n&quot;또는 &quot;\ r \ n&quot;)가 없으므로 &lt;a href=&quot;qstring#trimmed&quot;&gt;QString :: trimmed&lt;/a&gt; ()를 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="957a676bfdbb2b544a241041b952afb60f69ef80" translate="yes" xml:space="preserve">
          <source>The resulting object will be based on the first element in the list of key bindings for the</source>
          <target state="translated">결과 객체는 키 바인딩 목록의 첫 번째 요소를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="a0c5062e8b205b5163571de51cc566a4cf7a19fc" translate="yes" xml:space="preserve">
          <source>The resulting region consists of the pixels in bitmap</source>
          <target state="translated">결과 영역은 비트 맵의 ​​픽셀로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e0a42a93cd36fc0629ca5d64c836c6be1e1ee3eb" translate="yes" xml:space="preserve">
          <source>The results are stored in this read-only property when FPS measuring is enabled. It takes at least a second before this value is updated after measuring is activated.</source>
          <target state="translated">FPS 측정이 활성화되면 결과가이 읽기 전용 속성에 저장됩니다. 측정이 활성화 된 후이 값이 업데이트 되려면 1 초 이상 걸립니다.</target>
        </trans-unit>
        <trans-unit id="b25735cae381f64de9b9a770a58890bdd8cdeb70" translate="yes" xml:space="preserve">
          <source>The results of a matching a QRegularExpression against a string</source>
          <target state="translated">문자열과 QRegularExpression을 일치시킨 결과</target>
        </trans-unit>
        <trans-unit id="a27342fc6e91995a7ef48dc0cb701146f0e50a3e" translate="yes" xml:space="preserve">
          <source>The results of the evaluation are undefined.</source>
          <target state="translated">평가 결과는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb930c65d903b0bbc0529fc43cb7fb7e5f5c44cf" translate="yes" xml:space="preserve">
          <source>The results of the filter are made available through &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt;. See the &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt; and &lt;a href=&quot;qfuturewatcher&quot;&gt;QFutureWatcher&lt;/a&gt; documentation for more information on how to use &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt; in your applications.</source>
          <target state="translated">필터 결과는 &lt;a href=&quot;qfuture&quot;&gt;QFuture를&lt;/a&gt; 통해 제공됩니다 . 응용 프로그램에서 &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt; 를 사용하는 방법에 대한 자세한 내용은 &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt; 및 &lt;a href=&quot;qfuturewatcher&quot;&gt;QFutureWatcher&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1cc29fa4fd22174b8a3b2141fe6816608dc2d1de" translate="yes" xml:space="preserve">
          <source>The results of the map are made available through &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt;. See the &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt; and &lt;a href=&quot;qfuturewatcher&quot;&gt;QFutureWatcher&lt;/a&gt; documentation for more information on how to use &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt; in your applications.</source>
          <target state="translated">지도 결과는 &lt;a href=&quot;qfuture&quot;&gt;QFuture를&lt;/a&gt; 통해 제공됩니다 . 응용 프로그램에서 &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt; 를 사용하는 방법에 대한 자세한 내용은 &lt;a href=&quot;qfuture&quot;&gt;QFuture&lt;/a&gt; 및 &lt;a href=&quot;qfuturewatcher&quot;&gt;QFutureWatcher&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6cceacce1523f2703275115ec8fa91a732df7bc" translate="yes" xml:space="preserve">
          <source>The results of this operation are displayed in the table view, providing a convenient way of visualizing what we have achieved:</source>
          <target state="translated">이 작업의 결과는 테이블보기에 표시되어 달성 한 것을 시각화하는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cf52a689f454268d3f82221723168c924a1032e1" translate="yes" xml:space="preserve">
          <source>The retrieval of search term suggestions is very similar to performing a place search. A &lt;a href=&quot;qplacesearchrequest&quot;&gt;QPlaceSearchRequest&lt;/a&gt; is used just like a place search, the only difference being that the search term is set to a partially completed string.</source>
          <target state="translated">검색어 제안 검색은 장소 검색을 수행하는 것과 매우 유사합니다. &lt;a href=&quot;qplacesearchrequest&quot;&gt;QPlaceSearchRequest은&lt;/a&gt; 단지 장소 검색, 검색 용어가 부분적으로 완성 된 문자열로 설정되어있는 유일한 차이점처럼 사용된다.</target>
        </trans-unit>
        <trans-unit id="91c7738d04a7798cc11c5c6a879bb5d2a4cbf02e" translate="yes" xml:space="preserve">
          <source>The return value can be considered as the &quot;error&quot;, so if you for instance want to compare two 32-bit floating point numbers and all you need is an approximated 24-bit precision, you can use this function like this:</source>
          <target state="translated">반환 값은 &quot;오류&quot;로 간주 될 수 있으므로, 예를 들어 두 개의 32 비트 부동 소수점 숫자를 비교하고 대략 24 비트 정밀도 만 필요한 경우 다음과 같이이 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a38a9e3f0344debd7459464994d9b2312ec18f7a" translate="yes" xml:space="preserve">
          <source>The return value from this function is also the exit code of the test application when the &lt;a href=&quot;qtest#QTEST_MAIN&quot;&gt;QTEST_MAIN&lt;/a&gt;() macro is used.</source>
          <target state="translated">이 함수의 리턴 값은 &lt;a href=&quot;qtest#QTEST_MAIN&quot;&gt;QTEST_MAIN&lt;/a&gt; () 매크로가 사용될 때 테스트 애플리케이션의 종료 코드이기도합니다 .</target>
        </trans-unit>
        <trans-unit id="713a5c37900252bd61b1ac6d7de2ca129bac69eb" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;true&lt;/code&gt; if the event should be consumed by the calling filter or &lt;code&gt;false&lt;/code&gt; if the event should be forwarded to the control.</source>
          <target state="translated">이벤트가 호출 필터에 의해 소비되어야하는 경우 반환 값은 &lt;code&gt;true&lt;/code&gt; 이고, 이벤트가 컨트롤에 전달되어야하는 경우 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="60f1c5eb8ab58e89f455d69d31bcdaed82fc8221" translate="yes" xml:space="preserve">
          <source>The return value is a list of paths that could not be watched.</source>
          <target state="translated">리턴 값은 볼 수없는 경로 목록입니다.</target>
        </trans-unit>
        <trans-unit id="27ef6c59fecc8442de714ba34e782f3b4c87c7c8" translate="yes" xml:space="preserve">
          <source>The return value is a list of paths which were not able to be unwatched successfully.</source>
          <target state="translated">리턴 값은 성공적으로 감시 할 수 없었던 경로 목록입니다.</target>
        </trans-unit>
        <trans-unit id="eee0dc99987d2dfb2f6cd96111be39464fcb07cd" translate="yes" xml:space="preserve">
          <source>The return value is identical to</source>
          <target state="translated">반환 값은</target>
        </trans-unit>
        <trans-unit id="9590e08cda79f289fbe0bb5d22281b640ae3d5b3" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;a href=&quot;qbyteref&quot;&gt;QByteRef&lt;/a&gt;, a helper class for &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;. When you get an object of type &lt;a href=&quot;qbyteref&quot;&gt;QByteRef&lt;/a&gt;, you can use it as if it were a char &amp;amp;. If you assign to it, the assignment will apply to the character in the &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; from which you got the reference.</source>
          <target state="translated">반환 값은 유형 인 &lt;a href=&quot;qbyteref&quot;&gt;QByteRef&lt;/a&gt; 위한 헬퍼 클래스 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; . &lt;a href=&quot;qbyteref&quot;&gt;QByteRef&lt;/a&gt; 유형의 오브젝트를 확보하면 문자 &amp;amp; 인 것처럼 사용할 수 있습니다. 할당하면 할당이 참조를받은 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 의 문자에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a616a8103fe82b3d8ec6566eabd7b1d99ad49cea" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;a href=&quot;qcborvalue#qcborvalueref&quot;&gt;QCborValueRef&lt;/a&gt;, a helper class for &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt; and &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt;. When you get an object of type &lt;a href=&quot;qcborvalue#qcborvalueref&quot;&gt;QCborValueRef&lt;/a&gt;, you can use it as if it were a reference to a &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt;. If you assign to it, the assignment will apply to the element in the &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt; or &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt; from which you got the reference.</source>
          <target state="translated">리턴 값은 &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt; 및 &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt; 의 헬퍼 클래스 인 &lt;a href=&quot;qcborvalue#qcborvalueref&quot;&gt;QCborValueRef&lt;/a&gt; 유형 입니다. 당신이 형식의 개체 얻을 때 &lt;a href=&quot;qcborvalue#qcborvalueref&quot;&gt;QCborValueRef을&lt;/a&gt; 그것의 참조 것처럼, 당신은 그것을 사용할 수 있습니다 &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; . 할당 하면 참조가있는 &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt; 또는 &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt; 의 요소에 할당이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4bcc52e9c329a0d7174e21f63cec403c88effc98" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;a href=&quot;qjsonvalue#qjsonvalueref&quot;&gt;QJsonValueRef&lt;/a&gt;, a helper class for &lt;a href=&quot;qjsonarray&quot;&gt;QJsonArray&lt;/a&gt; and &lt;a href=&quot;qjsonobject&quot;&gt;QJsonObject&lt;/a&gt;. When you get an object of type &lt;a href=&quot;qjsonvalue#qjsonvalueref&quot;&gt;QJsonValueRef&lt;/a&gt;, you can use it as if it were a reference to a &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt;. If you assign to it, the assignment will apply to the character in the &lt;a href=&quot;qjsonarray&quot;&gt;QJsonArray&lt;/a&gt; of &lt;a href=&quot;qjsonobject&quot;&gt;QJsonObject&lt;/a&gt; from which you got the reference.</source>
          <target state="translated">리턴 값은 &lt;a href=&quot;qjsonarray&quot;&gt;QJsonArray&lt;/a&gt; 및 &lt;a href=&quot;qjsonobject&quot;&gt;QJsonObject&lt;/a&gt; 의 헬퍼 클래스 인 &lt;a href=&quot;qjsonvalue#qjsonvalueref&quot;&gt;QJsonValueRef&lt;/a&gt; 유형 입니다. 당신이 형식의 개체 얻을 때 &lt;a href=&quot;qjsonvalue#qjsonvalueref&quot;&gt;QJsonValueRef을&lt;/a&gt; 그것의 참조 것처럼, 당신은 그것을 사용할 수 있습니다 &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt; . 할당 하면 참조가있는 &lt;a href=&quot;qjsonarray&quot;&gt;QJsonObject&lt;/a&gt; 의 &lt;a href=&quot;qjsonobject&quot;&gt;QJsonArray&lt;/a&gt; 에있는 문자에 할당이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4fb6100b37c7e0eef72ee0d81dd6ac1d59fe1c14" translate="yes" xml:space="preserve">
          <source>The return value is of type &lt;a href=&quot;qjsonvalue#qjsonvalueref&quot;&gt;QJsonValueRef&lt;/a&gt;, a helper class for &lt;a href=&quot;qjsonarray&quot;&gt;QJsonArray&lt;/a&gt; and &lt;a href=&quot;qjsonobject&quot;&gt;QJsonObject&lt;/a&gt;. When you get an object of type &lt;a href=&quot;qjsonvalue#qjsonvalueref&quot;&gt;QJsonValueRef&lt;/a&gt;, you can use it as if it were a reference to a &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt;. If you assign to it, the assignment will apply to the element in the &lt;a href=&quot;qjsonarray&quot;&gt;QJsonArray&lt;/a&gt; or &lt;a href=&quot;qjsonobject&quot;&gt;QJsonObject&lt;/a&gt; from which you got the reference.</source>
          <target state="translated">리턴 값은 &lt;a href=&quot;qjsonarray&quot;&gt;QJsonArray&lt;/a&gt; 및 &lt;a href=&quot;qjsonobject&quot;&gt;QJsonObject&lt;/a&gt; 의 헬퍼 클래스 인 &lt;a href=&quot;qjsonvalue#qjsonvalueref&quot;&gt;QJsonValueRef&lt;/a&gt; 유형 입니다. 당신이 형식의 개체 얻을 때 &lt;a href=&quot;qjsonvalue#qjsonvalueref&quot;&gt;QJsonValueRef을&lt;/a&gt; 그것의 참조 것처럼, 당신은 그것을 사용할 수 있습니다 &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt; . 할당하면 할당이 참조를 얻은 &lt;a href=&quot;qjsonarray&quot;&gt;QJsonArray&lt;/a&gt; 또는 &lt;a href=&quot;qjsonobject&quot;&gt;QJsonObject&lt;/a&gt; 의 요소에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a5870a6f0204477b5a8cb39d3049f6a267689740" translate="yes" xml:space="preserve">
          <source>The return value is of type QBitRef, a helper class for &lt;a href=&quot;qbitarray&quot;&gt;QBitArray&lt;/a&gt;. When you get an object of type QBitRef, you can assign to it, and the assignment will apply to the bit in the &lt;a href=&quot;qbitarray&quot;&gt;QBitArray&lt;/a&gt; from which you got the reference.</source>
          <target state="translated">반환 값은 유형 QBitRef위한 도우미 클래스입니다 &lt;a href=&quot;qbitarray&quot;&gt;QBitArray&lt;/a&gt; . QBitRef 유형의 객체를 가져 오면 할당 할 수 있으며 할당 은 참조를 얻은 &lt;a href=&quot;qbitarray&quot;&gt;QBitArray&lt;/a&gt; 의 비트에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2bcb2c61c7aea92fe0a5cec79dda583b8f9c8b39" translate="yes" xml:space="preserve">
          <source>The return value is of type QCharRef, a helper class for &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;. When you get an object of type QCharRef, you can use it as if it were a reference to a &lt;a href=&quot;qchar&quot;&gt;QChar&lt;/a&gt;. If you assign to it, the assignment will apply to the character in the &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; from which you got the reference.</source>
          <target state="translated">리턴 값은 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 의 헬퍼 클래스 인 QCharRef 유형 입니다. 당신이 유형 QCharRef의 객체를 얻을 때 그것이 참조 것처럼, 당신은 그것을 사용할 수 있습니다 &lt;a href=&quot;qchar&quot;&gt;QChar&lt;/a&gt; . 할당 하면 참조가있는 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 의 문자에 할당이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3dd9ecb750535c3858662da02ca0db014fff1fbb" translate="yes" xml:space="preserve">
          <source>The return value is one of the types that are registered with &lt;a href=&quot;qmetatype&quot;&gt;QMetaType&lt;/a&gt;, or &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType::UnknownType&lt;/a&gt; if the type is not registered.</source>
          <target state="translated">리턴 값은 &lt;a href=&quot;qmetatype&quot;&gt;QMetaType&lt;/a&gt; 으로 등록 된 유형 중 하나 이거나 , 유형이 등록되지 않은 경우 &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType :: UnknownType&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8ea3d824aaaf824430b5abfbab449439bcd427f3" translate="yes" xml:space="preserve">
          <source>The return value is the ID of the next page, or -1 if no page follows.</source>
          <target state="translated">리턴 값은 다음 페이지의 ID이거나 페이지가 뒤 따르지 않으면 -1입니다.</target>
        </trans-unit>
        <trans-unit id="da0714cc3b596481cfd178fa0cc14ee9a2cdb0e0" translate="yes" xml:space="preserve">
          <source>The return value is the previous value of &lt;a href=&quot;qobject#signalsBlocked&quot;&gt;signalsBlocked&lt;/a&gt;().</source>
          <target state="translated">리턴 값은 &lt;a href=&quot;qobject#signalsBlocked&quot;&gt;signalBlocked&lt;/a&gt; () 의 이전 값입니다 .</target>
        </trans-unit>
        <trans-unit id="650faedffed690fc2771a34518e7e36f1be652d3" translate="yes" xml:space="preserve">
          <source>The return value is the previous value of &lt;a href=&quot;qt3dcore-qnode#notificationsBlocked&quot;&gt;notificationsBlocked&lt;/a&gt;().</source>
          <target state="translated">리턴 값은 &lt;a href=&quot;qt3dcore-qnode#notificationsBlocked&quot;&gt;notificationsBlocked&lt;/a&gt; () 의 이전 값입니다 .</target>
        </trans-unit>
        <trans-unit id="9d6236e467018d84e783348314abb770526e2a48" translate="yes" xml:space="preserve">
          <source>The return value is undefined if the altitude has not been set.</source>
          <target state="translated">고도가 설정되지 않은 경우 반환 값이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f353914506af48598354cf62b29f9d3b767b0fc9" translate="yes" xml:space="preserve">
          <source>The return value is undefined if this geo rectangle is invalid.</source>
          <target state="translated">이 지역 사각형이 유효하지 않은 경우 반환 값이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5069b818177986258f951a8154b09a3f1d7c7586" translate="yes" xml:space="preserve">
          <source>The return value is undefined if this object or</source>
          <target state="translated">이 객체 또는</target>
        </trans-unit>
        <trans-unit id="e3d22d67c00a989e86cd5290a9b266b29fa007e3" translate="yes" xml:space="preserve">
          <source>The return value is useful to call other Java API which are not covered by this wrapper</source>
          <target state="translated">리턴 값은이 랩퍼에서 다루지 않은 다른 Java API를 호출하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="620b0ece86f16c07085b26056d0de802540bf4a0" translate="yes" xml:space="preserve">
          <source>The return value of the</source>
          <target state="translated">의 반환 값</target>
        </trans-unit>
        <trans-unit id="87eee9f07f7497b8c815f373071adfe312babb45" translate="yes" xml:space="preserve">
          <source>The return value of this function conforms to the format defined in the NFC Data Exchange Format technical specification.</source>
          <target state="translated">이 기능의 반환 값은 NFC 데이터 교환 형식 기술 사양에 정의 된 형식을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="93d93f93010f9dd8f458472b9c59ebcb2df9fb2b" translate="yes" xml:space="preserve">
          <source>The return value of this function depends on the order of elements in the range. That means that</source>
          <target state="translated">이 함수의 반환 값은 해당 범위의 요소 순서에 따라 다릅니다. 그 의미는</target>
        </trans-unit>
        <trans-unit id="cd25f8e83f922c429a591c7410493ba9997a49d8" translate="yes" xml:space="preserve">
          <source>The return value of this function does not depend on the order of elements in the range. That means that</source>
          <target state="translated">이 함수의 반환 값은 범위의 요소 순서에 따라 달라지지 않습니다. 그 의미는</target>
        </trans-unit>
        <trans-unit id="8c8f60021cb21bead8a9b07c6f6ab4db162f6cbd" translate="yes" xml:space="preserve">
          <source>The return value of this function is not defined for paint events.</source>
          <target state="translated">이 함수의 반환 값은 페인트 이벤트에 대해 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7a5a05951705b4518929ec2dfa0addba66e8a0e5" translate="yes" xml:space="preserve">
          <source>The return value of this function may change when a &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; is created. It is not recommended to call it before creating a &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt;. The directory of the application executable (&lt;b&gt;not&lt;/b&gt; the working directory) is part of the list if it is known. In order to make it known a &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; has to be constructed as it will use &lt;code&gt;argv[0]&lt;/code&gt; to find it.</source>
          <target state="translated">&lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; 이 작성 될 때이 함수의 리턴 값이 변경 될 수 있습니다 . &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication을&lt;/a&gt; 작성하기 전에 호출하지 않는 것이 좋습니다 . 작업 디렉토리가 &lt;b&gt;아닌&lt;/b&gt; 응용 프로그램 실행 파일의 디렉토리 는 알려진 경우 목록의 일부입니다. 그것을 알기 위해서 &lt;a href=&quot;qcoreapplication&quot;&gt;QCoreApplication&lt;/a&gt; 은 &lt;code&gt;argv[0]&lt;/code&gt; 을 사용 하여 그것을 찾을 것이기 때문에 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a890af469ecd6bf62ae869813ea8a113622e24d2" translate="yes" xml:space="preserve">
          <source>The return value of this method call is placed in</source>
          <target state="translated">이 메소드 호출의 리턴 값은</target>
        </trans-unit>
        <trans-unit id="455e587307f900bfcdef3de62d387ad35b46ba52" translate="yes" xml:space="preserve">
          <source>The return value represents locale names that the user expects to see the UI translation in.</source>
          <target state="translated">리턴 값은 사용자가 UI 변환을 볼 것으로 예상되는 로케일 이름을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4baf901c0b5ea8cced6adf8d6cf3efaf066e4405" translate="yes" xml:space="preserve">
          <source>The return value should be checked using &lt;a href=&quot;qprinterinfo#isNull&quot;&gt;isNull&lt;/a&gt;() before being used, in case the named printer does not exist.</source>
          <target state="translated">명명 된 프린터가없는 경우 사용하기 전에 &lt;a href=&quot;qprinterinfo#isNull&quot;&gt;isNull&lt;/a&gt; ()을 사용하여 반환 값을 확인해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e00da529830e42c1e1e1bef2b8128fa3a97f086e" translate="yes" xml:space="preserve">
          <source>The return value should be checked using &lt;a href=&quot;qprinterinfo#isNull&quot;&gt;isNull&lt;/a&gt;() before being used, in case there is no default printer.</source>
          <target state="translated">기본 프린터가없는 경우 사용하기 전에 &lt;a href=&quot;qprinterinfo#isNull&quot;&gt;isNull&lt;/a&gt; ()을 사용하여 반환 값을 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3531318044c13b8f869636e7a1c452b4250fdc9e" translate="yes" xml:space="preserve">
          <source>The return value will be in the range of values from 0.0 up to but not including 360.0. The angles are measured counter-clockwise from a point on the x-axis to the right of the origin (x &amp;gt; 0).</source>
          <target state="translated">반환 값은 0.0에서 360.0까지는 포함하지 않습니다. 각도는 x 축의 한 점에서 원점의 ​​오른쪽 (x&amp;gt; 0)에서 시계 반대 방향으로 측정됩니다.</target>
        </trans-unit>
        <trans-unit id="3a79b39e8cdf31537158ece863731afda5cf387e" translate="yes" xml:space="preserve">
          <source>The return value will be negative if the vertex is below the plane, or zero if it is on the plane.</source>
          <target state="translated">정점이 평면 아래이면 반환 값이 음수이고 평면 위에 있으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="dc24ad0c5a4378ac960550daf336d8c27acabd23" translate="yes" xml:space="preserve">
          <source>The return value will be the null &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; if and only if this string view is null.</source>
          <target state="translated">이 문자열 뷰가 널인 경우에만 리턴 값이 널 &lt;a href=&quot;qstring&quot;&gt;QString이&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="3252c2aca4dfb06746341d3c404f8797cdad93b7" translate="yes" xml:space="preserve">
          <source>The return value will be the result of the evaluation (represented as a &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; object); this can be converted to standard C++ and Qt types.</source>
          <target state="translated">리턴 값은 평가 결과 ( &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; 오브젝트로 표시됨)입니다. 이것은 표준 C ++ 및 Qt 유형으로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="070902b2ff076dce4940fff039ef06dba6430841" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; instance is ready to be used and it does not need initializeOpenGLFunctions() to be called.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qopenglfunctions.html&quot;&gt;QOpenGLFunctions&lt;/a&gt; 인스턴스를 사용할 준비가되었으며 initializeOpenGLFunctions ()를 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8cd045874bc692461b7951074232bc64a3ad87d2" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; provides a convenient way to let users enter &quot;What's This?&quot; mode.</source>
          <target state="translated">반환 된 &lt;a href=&quot;qaction&quot;&gt;QAction&lt;/a&gt; 은 사용자가 &quot;What 's This?&quot;를 입력 할 수있는 편리한 방법을 제공합니다. 양식.</target>
        </trans-unit>
        <trans-unit id="c38a3e41a7d335e821a08d9406a4357c962ebaab" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;qaxobject&quot;&gt;QAxObject&lt;/a&gt; is a child of this object (which is either of type &lt;a href=&quot;qaxobject&quot;&gt;QAxObject&lt;/a&gt; or &lt;a href=&quot;qaxwidget&quot;&gt;QAxWidget&lt;/a&gt;), and is deleted when this object is deleted. It is however safe to delete the returned object yourself, and you should do so when you iterate over lists of subobjects.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;qaxobject&quot;&gt;QAxObject&lt;/a&gt; 는이 오브젝트의 하위 ( &lt;a href=&quot;qaxobject&quot;&gt;QAxObject&lt;/a&gt; 또는 &lt;a href=&quot;qaxwidget&quot;&gt;QAxWidget&lt;/a&gt; 유형) 이며이 오브젝트가 삭제되면 삭제됩니다. 그러나 반환 된 객체를 직접 삭제하는 것이 안전하므로 하위 객체 목록을 반복 할 때 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef4757c9ffd54501ef57c243985e353255154e9e" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;qbluetoothtransferreply&quot;&gt;QBluetoothTransferReply&lt;/a&gt; object must be immediately checked for its &lt;a href=&quot;qbluetoothtransferreply#error&quot;&gt;error()&lt;/a&gt; state. This is required in case this function detects an error during the initialization of the &lt;a href=&quot;qbluetoothtransferreply&quot;&gt;QBluetoothTransferReply&lt;/a&gt;. In such cases &lt;a href=&quot;qbluetoothtransferreply#isFinished&quot;&gt;QBluetoothTransferReply::isFinished&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt; as well.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;qbluetoothtransferreply&quot;&gt;QBluetoothTransferReply&lt;/a&gt; 오브젝트는 즉시 &lt;a href=&quot;qbluetoothtransferreply#error&quot;&gt;error ()&lt;/a&gt; 상태를 점검해야합니다 . &lt;a href=&quot;qbluetoothtransferreply&quot;&gt;QBluetoothTransferReply&lt;/a&gt; 의 초기화 중에이 함수가 오류를 감지 한 경우에 필요합니다 . 이러한 경우 &lt;a href=&quot;qbluetoothtransferreply#isFinished&quot;&gt;QBluetoothTransferReply :: isFinished&lt;/a&gt; ()도 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="05a4ef58d1a6dec25c41c6920c31eaa2e0a6fdbb" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; always remains empty if the characteristic does not have the &lt;a href=&quot;qlowenergycharacteristic#PropertyType-enum&quot;&gt;read permission&lt;/a&gt;. In such cases only the &lt;a href=&quot;qlowenergyservice#characteristicChanged&quot;&gt;QLowEnergyService::characteristicChanged&lt;/a&gt;() or &lt;a href=&quot;qlowenergyservice#characteristicWritten&quot;&gt;QLowEnergyService::characteristicWritten&lt;/a&gt;() may provice information about the value of this characteristic.</source>
          <target state="translated">특성에 &lt;a href=&quot;qlowenergycharacteristic#PropertyType-enum&quot;&gt;읽기 권한&lt;/a&gt; 이없는 경우 반환 된 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray는&lt;/a&gt; 항상 비어 있습니다. 이러한 경우 &lt;a href=&quot;qlowenergyservice#characteristicChanged&quot;&gt;QLowEnergyService :: characteristicChanged&lt;/a&gt; () 또는 &lt;a href=&quot;qlowenergyservice#characteristicWritten&quot;&gt;QLowEnergyService :: characteristicWritten&lt;/a&gt; () 만이이 특성 의 값에 대한 정보를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce1fc9bbba8371e9f630fc95cdbb5cc6ac61d36a" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt; is &lt;a href=&quot;qjsonvalue#Type-enum&quot;&gt;QJsonValue::Undefined&lt;/a&gt; if the key does not exist, or if &lt;a href=&quot;qjsondocument#isObject&quot;&gt;isObject&lt;/a&gt;() is false.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt; 는 키가 없거나 &lt;a href=&quot;qjsondocument#isObject&quot;&gt;isObject&lt;/a&gt; ()가 false 인 경우 &lt;a href=&quot;qjsonvalue#Type-enum&quot;&gt;QJsonValue :: Undefined&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c0bfea5bd30900188052cf948d709cdc5910dfa1" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt; is &lt;a href=&quot;qjsonvalue#Type-enum&quot;&gt;QJsonValue::Undefined&lt;/a&gt; if the key does not exist, or if &lt;a href=&quot;qjsonvalue#isObject&quot;&gt;isObject&lt;/a&gt;() is false.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt; 는 키가 없거나 &lt;a href=&quot;qjsonvalue#isObject&quot;&gt;isObject&lt;/a&gt; ()가 false 인 경우 &lt;a href=&quot;qjsonvalue#Type-enum&quot;&gt;QJsonValue :: Undefined&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c7c753e67ec13e887fd2c92f3b8cc26b6e4a3878" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt; is &lt;a href=&quot;qjsonvalue#Type-enum&quot;&gt;QJsonValue::Undefined&lt;/a&gt; if the key does not exist.</source>
          <target state="translated">키가 존재하지 않으면 리턴 된 &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt; 는 &lt;a href=&quot;qjsonvalue#Type-enum&quot;&gt;QJsonValue :: Undefined&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3dcd764521b9eda1eb405aa6ca69ba42f3a89434" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt; is &lt;a href=&quot;qjsonvalue#Type-enum&quot;&gt;QJsonValue::Undefined&lt;/a&gt;, if</source>
          <target state="translated">리턴 된 &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt; 는 &lt;a href=&quot;qjsonvalue#Type-enum&quot;&gt;다음&lt;/a&gt; 과 같은 경우 QJsonValue :: Undefined입니다 .</target>
        </trans-unit>
        <trans-unit id="f3e7d876541832e924bea7e5525e5a8bfaf204e9" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt; is &lt;code&gt;Undefined&lt;/code&gt;, if</source>
          <target state="translated">리턴 된 &lt;a href=&quot;qjsonvalue&quot;&gt;QJsonValue&lt;/a&gt; 는 &lt;code&gt;Undefined&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="a43eaf9a46cfc947017ceb24272c0aada1915e86" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;qopenglextrafunctions&quot;&gt;QOpenGLExtraFunctions&lt;/a&gt; instance is ready to be used and it does not need initializeOpenGLFunctions() to be called.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;qopenglextrafunctions&quot;&gt;QOpenGLExtraFunctions&lt;/a&gt; 인스턴스를 사용할 수 있으며 initializeOpenGLFunctions ()를 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="76a5d20fd7d54a12362193ac6533f54e34442e8d" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt; object contains the results of the match.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt; 오브젝트에는 일치 결과가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c71049ee6da7deb25e8d55eaa173affd42d8a186" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;qregularexpressionmatchiterator&quot;&gt;QRegularExpressionMatchIterator&lt;/a&gt; is positioned before the first match result (if any).</source>
          <target state="translated">리턴 된 &lt;a href=&quot;qregularexpressionmatchiterator&quot;&gt;QRegularExpressionMatchIterator&lt;/a&gt; 는 첫 번째 일치 결과 (있는 경우) 앞에 위치합니다.</target>
        </trans-unit>
        <trans-unit id="8340ea3e40f7b0ed3b4e2b2a1972cf7987cb37df" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;qtransform&quot;&gt;QTransform&lt;/a&gt; is formed by simply dropping the third row and third column of the &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4&lt;/a&gt;. This is suitable for implementing orthographic projections where the z co-ordinate should be dropped rather than projected.</source>
          <target state="translated">반환 &lt;a href=&quot;qtransform&quot;&gt;QTransform은&lt;/a&gt; 단지 세 번째 행의 세 번째 열에 놓아 형성되어 &lt;a href=&quot;qmatrix4x4&quot;&gt;QMatrix4x4를&lt;/a&gt; . z 좌표를 투영하지 않고 떨어 뜨려야하는 직교 투영법을 구현하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="425ca94ac2e2b61df81c9fa0223afc0097c58389" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; can be a default constructed &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;. If it is not a default constructed &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;, it will be absolute and valid. If a default constructed &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; is returned, it means the</source>
          <target state="translated">리턴 된 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 은 기본적으로 구성된 &lt;a href=&quot;qurl&quot;&gt;QUrl 일&lt;/a&gt; 수 있습니다 . 기본 구성된 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 이 아닌 경우 절대적이고 유효합니다. 기본 생성 된 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 이 반환되면</target>
        </trans-unit>
        <trans-unit id="4c60ec623bfd1e75b0dd0e1b3c45512e3568dc65" translate="yes" xml:space="preserve">
          <source>The returned CGImageRef partakes in the &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; implicit sharing, and holds a reference to the &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; data. CGImage is immutable and will never detach the &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. Writing to the &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; will detach as usual.</source>
          <target state="translated">반환 된 CGImageRef는 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 암시 적 공유에 참여 하고 &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 데이터에 대한 참조를 보유합니다 . CGImage는 변경할 수 없으며 &lt;a href=&quot;qimage&quot;&gt;QImage를&lt;/a&gt; 분리하지 않습니다 . &lt;a href=&quot;qimage&quot;&gt;QImage에&lt;/a&gt; 쓰면 평소대로 분리됩니다.</target>
        </trans-unit>
        <trans-unit id="6ecd5d5375bb11781e2b4c6b2ec9a5253f4d9b3b" translate="yes" xml:space="preserve">
          <source>The returned FBO can have any attachment. If the &lt;a href=&quot;qopenglframebufferobjectformat&quot;&gt;QOpenGLFramebufferObjectFormat&lt;/a&gt; indicates that the FBO should be multisampled, the internal implementation of the Renderer will allocate a second FBO and blit the multisampled FBO into the FBO used to display the texture.</source>
          <target state="translated">반환 된 FBO에는 첨부 파일이있을 수 있습니다. &lt;a href=&quot;qopenglframebufferobjectformat&quot;&gt;QOpenGLFramebufferObjectFormat&lt;/a&gt; 이 FBO가 멀티 샘플링되어야 함을 나타내는 경우, 렌더러의 내부 구현은 두 번째 FBO를 할당하고 멀티 샘플링 된 FBO를 텍스처를 표시하는 데 사용되는 FBO에 블리 팅 합니다.</target>
        </trans-unit>
        <trans-unit id="12295719f07e3ab125fa18a63cd75787802bf273" translate="yes" xml:space="preserve">
          <source>The returned URL is based on</source>
          <target state="translated">반환 된 URL은</target>
        </trans-unit>
        <trans-unit id="163c4f64bd989693f030e5a1bb63d86928ef0434" translate="yes" xml:space="preserve">
          <source>The returned binder is used by the caller to perform IPC calls.</source>
          <target state="translated">리턴 된 바인더는 호출자가 IPC 호출을 수행하는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dbfbadd905cd18fe0bed6c96f4be42a51911aa84" translate="yes" xml:space="preserve">
          <source>The returned byte array is undefined if the string contains non-Latin1 characters. Those characters may be suppressed or replaced with a question mark.</source>
          <target state="translated">문자열에 Latin1이 아닌 문자가 포함되어 있으면 반환 된 바이트 배열이 정의되지 않습니다. 해당 문자는 표시되지 않거나 물음표로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f5489d5794ea2e23d016075fca73a404047ba04" translate="yes" xml:space="preserve">
          <source>The returned characteristic is invalid if this service instance's &lt;a href=&quot;qlowenergyservice#discoverDetails&quot;&gt;discoverDetails&lt;/a&gt;() was not yet called or there are no characteristics with a matching</source>
          <target state="translated">이 서비스 인스턴스의 &lt;a href=&quot;qlowenergyservice#discoverDetails&quot;&gt;discoverDetails&lt;/a&gt; ()가 아직 호출되지 않았거나 일치하는 특성이없는 경우 리턴 된 특성이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b43f0652dfbec7031b3665d54f18ee94a0162aa" translate="yes" xml:space="preserve">
          <source>The returned component's &lt;a href=&quot;qml-qtqml-component#status-prop&quot;&gt;Component::status&lt;/a&gt; property indicates whether the component was successfully created. If the status is &lt;code&gt;Component.Error&lt;/code&gt;, see &lt;a href=&quot;qml-qtqml-component#errorString-method&quot;&gt;Component::errorString()&lt;/a&gt; for an error description.</source>
          <target state="translated">반환 된 구성 요소의 &lt;a href=&quot;qml-qtqml-component#status-prop&quot;&gt;Component :: status&lt;/a&gt; 속성은 구성 요소가 성공적으로 생성되었는지 여부를 나타냅니다. 상태가 &lt;code&gt;Component.Error&lt;/code&gt; 인 경우 오류 설명 은 &lt;a href=&quot;qml-qtqml-component#errorString-method&quot;&gt;Component :: errorString ()&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb19260dd2ece339779576b644527870f6a9f404" translate="yes" xml:space="preserve">
          <source>The returned drop action may be one of:</source>
          <target state="translated">리턴 된 삭제 조치는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bbfbd8258bfec270c9a87b30b0203bde3002364" translate="yes" xml:space="preserve">
          <source>The returned editor widget should have &lt;a href=&quot;qt#FocusPolicy-enum&quot;&gt;Qt::StrongFocus&lt;/a&gt;; otherwise, &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent&lt;/a&gt;s received by the widget will propagate to the view. The view's background will shine through unless the editor paints its own background (e.g., with &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;setAutoFillBackground()&lt;/a&gt;).</source>
          <target state="translated">반환 된 에디터 위젯은 &lt;a href=&quot;qt#FocusPolicy-enum&quot;&gt;Qt :: StrongFocus&lt;/a&gt; ; 그렇지 않으면 위젯이 수신 한 &lt;a href=&quot;qmouseevent&quot;&gt;QMouseEvent가보기로&lt;/a&gt; 전파됩니다. 편집기가 자체 배경을 그리는 경우가 아니면 (예 : &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;setAutoFillBackground () 사용&lt;/a&gt; ) 뷰의 배경이 빛납니다 .</target>
        </trans-unit>
        <trans-unit id="8e2b2388bf0fae12217de205cb579676ccb5b804" translate="yes" xml:space="preserve">
          <source>The returned file path uses native directory separators.</source>
          <target state="translated">리턴 된 파일 경로는 기본 디렉토리 분리자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b4325ed035ad847a9365998cbb198861ea8eab18" translate="yes" xml:space="preserve">
          <source>The returned glyph will always be unhinted.</source>
          <target state="translated">반환 된 글리프는 항상 힌트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fea7d90f750454bdda0294ecf907f6aba765cd8e" translate="yes" xml:space="preserve">
          <source>The returned height is calculated using the size hints of the given</source>
          <target state="translated">반환 된 높이는 주어진 크기 힌트를 사용하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="832f8a8583a9ab1dc336904bee9125f1f4622981" translate="yes" xml:space="preserve">
          <source>The returned image has a format of premultiplied ARGB32 or RGB32. The latter is used only when internalTextureFormat() is set to &lt;code&gt;GL_RGB&lt;/code&gt;. Since Qt 5.2 the function will fall back to premultiplied RGBA8888 or RGBx8888 when reading to (A)RGB32 is not supported, and this includes OpenGL ES. Since Qt 5.4 an A2BGR30 image is returned if the internal format is RGB10_A2, and since Qt 5.12 a RGBA64 image is return if the internal format is RGBA16.</source>
          <target state="translated">반환 된 이미지는 미리 곱한 ARGB32 또는 RGB32 형식입니다. 후자는 internalTextureFormat ()이 &lt;code&gt;GL_RGB&lt;/code&gt; 로 설정된 경우에만 사용됩니다 . Qt 5.2부터이 기능은 (A) RGB32를 읽을 때 사전 곱셈 된 RGBA8888 또는 RGBx8888로 폴백되지 않으며 여기에는 OpenGL ES가 포함됩니다. Qt 5.4부터 내부 형식이 RGB10_A2이면 A2BGR30 이미지가 반환되고 Qt 5.12부터 내부 형식이 RGBA16이면 RGBA64 이미지가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4e89dca6b3163b9448ce49743b61f379a71629e7" translate="yes" xml:space="preserve">
          <source>The returned image has little-endian bit order (i.e. the image's format is &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage::Format_MonoLSB&lt;/a&gt;), which you can convert to big-endian (&lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage::Format_Mono&lt;/a&gt;) using the &lt;a href=&quot;qimage#convertToFormat&quot;&gt;convertToFormat&lt;/a&gt;() function.</source>
          <target state="translated">반환 된 이미지에는 리틀 엔디안 비트 순서가 있습니다 (예 : 이미지 형식은 &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage :: Format_MonoLSB&lt;/a&gt; ) . &lt;a href=&quot;qimage#convertToFormat&quot;&gt;convertToFormat&lt;/a&gt; () 함수를 사용하여 빅 엔디안 ( &lt;a href=&quot;qimage#Format-enum&quot;&gt;QImage :: Format_Mono&lt;/a&gt; )으로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="141130d059022302cc42e5e05fdd015f793a51fa" translate="yes" xml:space="preserve">
          <source>The returned image is copied from the position (</source>
          <target state="translated">반환 된 이미지는 위치 (</target>
        </trans-unit>
        <trans-unit id="30eb86ec66357f391fbc91f50348ab444956ade4" translate="yes" xml:space="preserve">
          <source>The returned image object has the following properties:</source>
          <target state="translated">반환 된 이미지 객체에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbbc46128ac52beb1ced9126afd4e2736bcddacb" translate="yes" xml:space="preserve">
          <source>The returned image will normally have the same {Image Formats}{format} as the original image. However, a complex transformation may result in an image where not all pixels are covered by the transformed pixels of the original image. In such cases, those background pixels will be assigned a transparent color value, and the transformed image will be given a format with an alpha channel, even if the orginal image did not have that.</source>
          <target state="translated">반환 된 이미지는 일반적으로 원본 이미지와 동일한 {이미지 형식} {format}을 갖습니다. 그러나 복잡한 변환으로 인해 모든 이미지가 원본 이미지의 변환 된 픽셀로 덮여있는 것은 아닙니다. 이러한 경우, 해당 배경 픽셀에는 투명한 색상 값이 할당되고 변환 된 이미지에는 원래 이미지에없는 경우에도 알파 채널 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="164234773bb868d9bae955c162d056b3d3c782e1" translate="yes" xml:space="preserve">
          <source>The returned interface may change as a result of a roaming process.</source>
          <target state="translated">로밍 프로세스로 인해 반환 된 인터페이스가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7378299f3bde5075b238fa130ab2baa5244c04e9" translate="yes" xml:space="preserve">
          <source>The returned layout item is no longer owned by the layout and should be either deleted or inserted to another layout. The widget</source>
          <target state="translated">반환 된 레이아웃 항목은 더 이상 레이아웃에서 소유하지 않으므로 다른 레이아웃에 삭제하거나 삽입해야합니다. 위젯</target>
        </trans-unit>
        <trans-unit id="feded503aa8fa15cc92409ebcdaff989538d3e34" translate="yes" xml:space="preserve">
          <source>The returned line has no trailing end-of-line characters (&quot;\n&quot; or &quot;\r\n&quot;), so calling &lt;a href=&quot;qstring#trimmed&quot;&gt;QString::trimmed&lt;/a&gt;() can be unnecessary.</source>
          <target state="translated">반환 된 줄에는 줄 끝 문자 ( &quot;\ n&quot;또는 &quot;\ r \ n&quot;)가 없으므로 &lt;a href=&quot;qstring#trimmed&quot;&gt;QString :: trimmed&lt;/a&gt; ()를 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ca20174e24190f9c4a414229d09de36c0614da1b" translate="yes" xml:space="preserve">
          <source>The returned list contains &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; types.</source>
          <target state="translated">리턴 된 목록에는 &lt;a href=&quot;qpointf&quot;&gt;QPointF&lt;/a&gt; 유형이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="ebcb41311cac61c36df4fa0d0b753b787347c4da" translate="yes" xml:space="preserve">
          <source>The returned list contains &lt;code&gt;point&lt;/code&gt; types.</source>
          <target state="translated">반환 된 목록에는 &lt;code&gt;point&lt;/code&gt; 유형이 포함 됩니다 .</target>
        </trans-unit>
        <trans-unit id="48eba80aee1d8a7be62b5f259fe2cbb73be86ff2" translate="yes" xml:space="preserve">
          <source>The returned list does not contain the states of possible nested state machines.</source>
          <target state="translated">리턴 된 목록에 가능한 중첩 상태 머신의 상태가 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bf59d78fcc3bafc2f0bbfd550b6d1ac43673f96" translate="yes" xml:space="preserve">
          <source>The returned list is empty if this service instance's &lt;a href=&quot;qlowenergyservice#discoverDetails&quot;&gt;discoverDetails&lt;/a&gt;() was not yet called or there are no known characteristics.</source>
          <target state="translated">이 서비스 인스턴스의 &lt;a href=&quot;qlowenergyservice#discoverDetails&quot;&gt;discoverDetails&lt;/a&gt; ()가 아직 호출되지 않았거나 알려진 특성이없는 경우 리턴 된 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ce0260122bb19b1a3170ddd91aaafd46f359829" translate="yes" xml:space="preserve">
          <source>The returned list is in order of frequency of usage, i.e. larger zones within a country are listed first.</source>
          <target state="translated">반환 된 목록은 사용 빈도 순서로 표시됩니다. 즉, 국가 내의 더 큰 영역이 먼저 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="c51363f64f11e96100392fa081ba286df74f93ed" translate="yes" xml:space="preserve">
          <source>The returned list is sorted alphabetically.</source>
          <target state="translated">반환 된 목록은 알파벳순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="6be49d396a3afde86daf4e80bfb2b7e3e8b8d6a6" translate="yes" xml:space="preserve">
          <source>The returned list of contact details is an &lt;a href=&quot;qtquick-modelviewsdata-cppmodels#qobjectlist-based-model&quot;&gt;object list&lt;/a&gt; and so can be used directly as a data model. For example, the following demonstrates how to display a list of contact phone numbers in a list view:</source>
          <target state="translated">리턴 된 연락처 세부 사항 목록은 &lt;a href=&quot;qtquick-modelviewsdata-cppmodels#qobjectlist-based-model&quot;&gt;오브젝트 목록&lt;/a&gt; 이므로 데이터 모델로 직접 사용할 수 있습니다. 예를 들어 다음은 연락처 전화 번호 목록을 목록보기로 표시하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="36ed9dc1e7d37ca0847cdc436ebb25f60fbe1028" translate="yes" xml:space="preserve">
          <source>The returned memory type will be both host visible and coherent. In addition, it will also be cached, if possible.</source>
          <target state="translated">반환 된 메모리 유형은 호스트 표시 및 코 히어 런트입니다. 또한 가능하면 캐시됩니다.</target>
        </trans-unit>
        <trans-unit id="95a6f7a55913c8a1b8f45379a2136e64f197bdc9" translate="yes" xml:space="preserve">
          <source>The returned name can only be retrieved if &lt;a href=&quot;qlowenergyservice#serviceUuid&quot;&gt;serviceUuid&lt;/a&gt;() is a &lt;a href=&quot;https://developer.bluetooth.org/gatt/services/Pages/ServicesHome.aspx&quot;&gt;well-known UUID&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qlowenergyservice#serviceUuid&quot;&gt;serviceUuid&lt;/a&gt; ()가 &lt;a href=&quot;https://developer.bluetooth.org/gatt/services/Pages/ServicesHome.aspx&quot;&gt;잘 알려진 UUID 인&lt;/a&gt; 경우에만 반환 된 이름을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc8a568a517c47ee2364fb4c848bab4acbfec446" translate="yes" xml:space="preserve">
          <source>The returned object contains the same information that is available to a delegate from the &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel&lt;/a&gt; attached as well as the model for that item. It has the properties:</source>
          <target state="translated">반환 된 개체에는 해당 항목의 모델뿐만 아니라 연결된 &lt;a href=&quot;qml-qtqml-models-delegatemodel&quot;&gt;DelegateModel&lt;/a&gt; 의 대리인이 사용할 수있는 동일한 정보가 포함 됩니다. 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5fbbb55a6dd6fd5b4a1987dcd4fc2fb5d444924" translate="yes" xml:space="preserve">
          <source>The returned object has &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; attributes with the given values.</source>
          <target state="translated">반환 된 객체는 주어진 값을 가진 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;width&lt;/code&gt; 및 &lt;code&gt;height&lt;/code&gt; 속성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0252e775bef90f6559e4329f5f7d084f8c2fdc9c" translate="yes" xml:space="preserve">
          <source>The returned object is owned by the &lt;a href=&quot;qsqlrelationaltablemodel&quot;&gt;QSqlRelationalTableModel&lt;/a&gt;.</source>
          <target state="translated">리턴 된 오브젝트는 &lt;a href=&quot;qsqlrelationaltablemodel&quot;&gt;QSqlRelationalTableModel&lt;/a&gt; 이 소유합니다 .</target>
        </trans-unit>
        <trans-unit id="a441b9087da856eca52da1cac141cc62d8320e05" translate="yes" xml:space="preserve">
          <source>The returned object is used to enumerate events to be delivered through a single &lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent&lt;/a&gt;. Touches are delivered to the window containing the &lt;a href=&quot;qml-qttest-testcase&quot;&gt;TestCase&lt;/a&gt; unless otherwise specified.</source>
          <target state="translated">리턴 된 오브젝트는 단일 &lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent를&lt;/a&gt; 통해 전달 될 이벤트를 열거하는 데 사용됩니다 . 별도로 지정하지 않는 한 터치는 &lt;a href=&quot;qml-qttest-testcase&quot;&gt;TestCase가&lt;/a&gt; 포함 된 창으로 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="8d777a830ad64e901584f1cb129e3c1cf1f44a32" translate="yes" xml:space="preserve">
          <source>The returned object is used to enumerate events to be delivered through a single &lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent&lt;/a&gt;. Touches are delivered to the window containing the &lt;a href=&quot;qml-testcase&quot;&gt;TestCase&lt;/a&gt; unless otherwise specified.</source>
          <target state="translated">리턴 된 오브젝트는 단일 &lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent를&lt;/a&gt; 통해 전달 될 이벤트를 열거하는 데 사용됩니다 . 별도로 지정하지 않는 한 터치는 &lt;a href=&quot;qml-testcase&quot;&gt;TestCase가&lt;/a&gt; 포함 된 창으로 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="720241c928a3f383cb0d27addb23684dc5945bc9" translate="yes" xml:space="preserve">
          <source>The returned object must be in an open state.</source>
          <target state="translated">리턴 된 오브젝트는 열린 상태 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8e52a90f6a3c27d77b9eb8843e81df1f19b4f713" translate="yes" xml:space="preserve">
          <source>The returned object should be checked using &lt;a href=&quot;qcamerainfo#isNull&quot;&gt;isNull&lt;/a&gt;() before being used, in case there is no default camera or no cameras at all.</source>
          <target state="translated">기본 카메라가 없거나 카메라가없는 경우 사용하기 전에 &lt;a href=&quot;qcamerainfo#isNull&quot;&gt;isNull&lt;/a&gt; ()을 사용하여 반환 된 객체를 확인해야 합니다.</target>
        </trans-unit>
        <trans-unit id="7bc5a848a389d2baba0766fcb4b0534110b2e95b" translate="yes" xml:space="preserve">
          <source>The returned path can be either absolute or relative (see &lt;a href=&quot;qdir#setPath&quot;&gt;setPath&lt;/a&gt;()).</source>
          <target state="translated">리턴 된 경로는 절대 또는 상대 경로 일 수 있습니다 ( &lt;a href=&quot;qdir#setPath&quot;&gt;setPath&lt;/a&gt; () 참조 ).</target>
        </trans-unit>
        <trans-unit id="769633be8be144cc8a13450667d24152b082866c" translate="yes" xml:space="preserve">
          <source>The returned path will be the first path from the following list which resolves to an existing file or directory:</source>
          <target state="translated">리턴 된 경로는 다음 목록에서 기존 파일 또는 디렉토리로 해석되는 첫 번째 경로입니다.</target>
        </trans-unit>
        <trans-unit id="f62d52156f8bac1d03191a9d739113a70ed7df4f" translate="yes" xml:space="preserve">
          <source>The returned pixmap is clipped to the current painter's device rectangle when</source>
          <target state="translated">반환 된 픽스맵은 현재 페인터의 장치 사각형에 잘립니다.</target>
        </trans-unit>
        <trans-unit id="88894c828a9d6b4191e458319d4827a044a3da4c" translate="yes" xml:space="preserve">
          <source>The returned route could be entirely different to the original route, especially if</source>
          <target state="translated">반환 된 경로는 원래 경로와 완전히 다를 수 있습니다. 특히</target>
        </trans-unit>
        <trans-unit id="0614fe096295df2e1b8739a5334569bc0752c5e4" translate="yes" xml:space="preserve">
          <source>The returned string is empty if the &lt;a href=&quot;qlowenergycharacteristic#uuid&quot;&gt;uuid&lt;/a&gt;() is unknown.</source>
          <target state="translated">&lt;a href=&quot;qlowenergycharacteristic#uuid&quot;&gt;uuid&lt;/a&gt; ()를 알 수 없으면 리턴 된 문자열이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d048f8643fad5ec3c6f869edc22e7bd2bb702108" translate="yes" xml:space="preserve">
          <source>The returned string is empty if the &lt;a href=&quot;qlowenergydescriptor#type&quot;&gt;type&lt;/a&gt;() is unknown.</source>
          <target state="translated">&lt;a href=&quot;qlowenergydescriptor#type&quot;&gt;유형&lt;/a&gt; ()을 알 수 없으면 리턴 된 문자열이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="433d7bcf16c661d4c4f1fdc31870adc559cd1d24" translate="yes" xml:space="preserve">
          <source>The returned string is in host byte order.</source>
          <target state="translated">반환 된 문자열은 호스트 바이트 순서입니다.</target>
        </trans-unit>
        <trans-unit id="06bc0d75a53caf819c54e1c7ccb9a39a114cde99" translate="yes" xml:space="preserve">
          <source>The returned string may be the same as the argument on some operating systems, for example on Unix.</source>
          <target state="translated">리턴 된 문자열은 일부 운영 체제 (예 : Unix)의 인수와 동일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec298240d345b2f32419052868e727985dc41b7a" translate="yes" xml:space="preserve">
          <source>The returned text does not include any rich text formatting.</source>
          <target state="translated">반환 된 텍스트에는 서식있는 텍스트 형식이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85aab7e47cbf17ad99121f384d45709b912a8044" translate="yes" xml:space="preserve">
          <source>The returned text will be formatted according the &lt;a href=&quot;qml-qtquick-textedit#textFormat-prop&quot;&gt;textFormat&lt;/a&gt; property.</source>
          <target state="translated">반환 된 텍스트는 &lt;a href=&quot;qml-qtquick-textedit#textFormat-prop&quot;&gt;textFormat&lt;/a&gt; 속성 에 따라 서식이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="76c765fe8bf5697d108a758ed993984c4d224647" translate="yes" xml:space="preserve">
          <source>The returned text will be formatted according to the &lt;a href=&quot;qml-qtquick-controls-textarea#textFormat-prop&quot;&gt;textFormat&lt;/a&gt; property.</source>
          <target state="translated">반환 된 텍스트는 &lt;a href=&quot;qml-qtquick-controls-textarea#textFormat-prop&quot;&gt;textFormat&lt;/a&gt; 에 따라 서식이 지정됩니다 속성 .</target>
        </trans-unit>
        <trans-unit id="cae2d3a314122edb530e1618f3b65f7ea8121672" translate="yes" xml:space="preserve">
          <source>The returned texture is owned by the buffer. The texture is only valid for as long as the buffer reference exists. The caller of this function must not delete the texture, and must keep a reference to the buffer for as long as the texture is being used.</source>
          <target state="translated">반환 된 텍스처는 버퍼가 소유합니다. 텍스처는 버퍼 참조가 존재하는 한 유효합니다. 이 함수의 호출자는 텍스처를 삭제하지 않아야하며 텍스처가 사용되는 동안 버퍼에 대한 참조를 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="bdd3ea43c1f60c3d3037c81e0061b2ebc558ca98" translate="yes" xml:space="preserve">
          <source>The returned texture will be using &lt;code&gt;GL_TEXTURE_2D&lt;/code&gt; as texture target and assumes that internal format is &lt;code&gt;GL_RGBA&lt;/code&gt;. Reimplement &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; to create textures with different parameters.</source>
          <target state="translated">반환 된 텍스처는 &lt;code&gt;GL_TEXTURE_2D&lt;/code&gt; 를 텍스처 대상 으로 사용 하며 내부 형식이 &lt;code&gt;GL_RGBA&lt;/code&gt; 라고 가정합니다 . &lt;a href=&quot;qsgtexture&quot;&gt;QSGTexture&lt;/a&gt; 를 다시 구현 하여 다른 매개 변수로 텍스처를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="aa1b90873bdb6d53a77bda69570c53d8cd82e89b" translate="yes" xml:space="preserve">
          <source>The returned value doesn't include the space required by &lt;a href=&quot;qwidget#setContentsMargins&quot;&gt;QWidget::setContentsMargins&lt;/a&gt;() or &lt;a href=&quot;qlayout#menuBar&quot;&gt;menuBar&lt;/a&gt;().</source>
          <target state="translated">반환 된 값에는 &lt;a href=&quot;qwidget#setContentsMargins&quot;&gt;QWidget :: setContentsMargins&lt;/a&gt; () 또는 &lt;a href=&quot;qlayout#menuBar&quot;&gt;menuBar&lt;/a&gt; ()에 필요한 공간이 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="92b5d6c220a31650c82bd7d4356451241e4aa90f" translate="yes" xml:space="preserve">
          <source>The returned value is composed of three or more parts, separated by dashes (&quot;-&quot;). They are:</source>
          <target state="translated">반환 된 값은 대시 ( &quot;-&quot;)로 구분 된 세 개 이상의 부분으로 구성됩니다. 그들은:</target>
        </trans-unit>
        <trans-unit id="d2749e92ce3e83af127167920f4f0933bd5c82dd" translate="yes" xml:space="preserve">
          <source>The returned value is undefined if one of the two parameters is invalid and the other isn't. However, two invalid timers are equal and thus this function will return false.</source>
          <target state="translated">두 매개 변수 중 하나가 유효하지 않고 다른 매개 변수가 유효하지 않으면 리턴 값이 정의되지 않습니다. 그러나 두 개의 유효하지 않은 타이머는 동일하므로이 함수는 false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b7d80460f267bb240ad59a28b850047c50297f71" translate="yes" xml:space="preserve">
          <source>The returned value may be different tha passed to &lt;a href=&quot;qaudioencodersettingscontrol#setAudioSettings&quot;&gt;QAudioEncoderSettingsControl::setAudioSettings&lt;/a&gt;() if the settings contains the default or undefined parameters. In this case if the undefined parameters are already resolved, they should be returned.</source>
          <target state="translated">설정에 기본 또는 정의되지 않은 매개 변수가 포함되어 있으면 반환 된 값이 &lt;a href=&quot;qaudioencodersettingscontrol#setAudioSettings&quot;&gt;QAudioEncoderSettingsControl :: setAudioSettings&lt;/a&gt; ()에 전달 될 수 있습니다 . 이 경우 정의되지 않은 매개 변수가 이미 해결 된 경우 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4ffb99b27c80a3b3e670145b72c691fb3de8d48" translate="yes" xml:space="preserve">
          <source>The returned value may be different tha passed to &lt;a href=&quot;qimageencodercontrol#setImageSettings&quot;&gt;QImageEncoderControl::setImageSettings&lt;/a&gt;() if the settings contains the default or undefined parameters. In this case if the undefined parameters are already resolved, they should be returned.</source>
          <target state="translated">설정에 기본 또는 정의되지 않은 매개 변수가 포함되어 있으면 반환 된 값이 &lt;a href=&quot;qimageencodercontrol#setImageSettings&quot;&gt;QImageEncoderControl :: setImageSettings&lt;/a&gt; ()에 전달 될 수 있습니다 . 이 경우 정의되지 않은 매개 변수가 이미 해결 된 경우 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="2ef4c4ba6cc867089192da80f9dd3bab60e509a2" translate="yes" xml:space="preserve">
          <source>The returned value may be different tha passed to &lt;a href=&quot;qvideoencodersettingscontrol#setVideoSettings&quot;&gt;QVideoEncoderSettingsControl::setVideoSettings&lt;/a&gt;() if the settings contains the default or undefined parameters. In this case if the undefined parameters are already resolved, they should be returned.</source>
          <target state="translated">설정에 기본 또는 정의되지 않은 매개 변수가 포함되어 있으면 반환 된 값이 &lt;a href=&quot;qvideoencodersettingscontrol#setVideoSettings&quot;&gt;QVideoEncoderSettingsControl :: setVideoSettings&lt;/a&gt; ()에 전달 될 수 있습니다 . 이 경우 정의되지 않은 매개 변수가 이미 해결 된 경우 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="58554ce03cad12c62c51fe46c16c2038d24024a0" translate="yes" xml:space="preserve">
          <source>The returned value may be partially complete and indistinguishable from a valid &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; even if the decoding failed. To determine if there was an error, check if &lt;a href=&quot;qcborstreamreader#lastError&quot;&gt;reader.lastError()&lt;/a&gt; is indicating an error condition. This function stops decoding immediately after the first error.</source>
          <target state="translated">리턴 된 값은 디코딩에 실패한 경우에도 부분적으로 완전하고 유효한 &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; 와 구별 할 수 없습니다 . 오류가 있는지 확인하려면 &lt;a href=&quot;qcborstreamreader#lastError&quot;&gt;reader.lastError ()&lt;/a&gt; 가 오류 조건을 나타내는 지 확인하십시오 . 이 기능은 첫 번째 오류 직후 디코딩을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="2efcf7382ef3f359faf0d74358cfabd999c1fe99" translate="yes" xml:space="preserve">
          <source>The returned value may be partially complete and indistinguishable from a valid &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; even if the decoding failed. To determine if there was an error, check if there was an error stored in</source>
          <target state="translated">리턴 된 값은 디코딩에 실패한 경우에도 부분적으로 완전하고 유효한 &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; 와 구별 할 수 없습니다 . 오류가 있는지 확인하려면에 저장된 오류가 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2c7f2c920201f8e2c60e32df874828cb8f50db00" translate="yes" xml:space="preserve">
          <source>The returned value represents the number of degrees you need to add to this line to make it have the same angle as the given</source>
          <target state="translated">반환 된 값은 주어진 각도와 동일하게하기 위해이 선에 추가해야하는 각도를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a33601549f3f84d9339ce6ecb91108f48617fe0c" translate="yes" xml:space="preserve">
          <source>The returned variant will be a &lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList&lt;/a&gt; if the document is a &lt;a href=&quot;qjsonarray&quot;&gt;QJsonArray&lt;/a&gt; and a &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; if the document is a &lt;a href=&quot;qjsonobject&quot;&gt;QJsonObject&lt;/a&gt;.</source>
          <target state="translated">반환 변형이 될 것입니다 &lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList&lt;/a&gt; 문서가있는 경우 &lt;a href=&quot;qjsonarray&quot;&gt;QJsonArray&lt;/a&gt; 과 &lt;a href=&quot;qvariant#QVariantMap-typedef&quot;&gt;QVariantMap&lt;/a&gt; 문서가있는 경우 &lt;a href=&quot;qjsonobject&quot;&gt;QJsonObject&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0af865e3a948efd9dc6e35fa5a5bff608faaabf0" translate="yes" xml:space="preserve">
          <source>The returned vector is not 0-terminated.</source>
          <target state="translated">반환 된 벡터는 0으로 끝나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6150585925edba6ac47ef98178ebe6ac8cc02fff" translate="yes" xml:space="preserve">
          <source>The returned vector is not \0'-terminated.</source>
          <target state="translated">반환 된 벡터는 \ 0'- 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a948af41ddaa8afb2808830abd79dd74e26c219" translate="yes" xml:space="preserve">
          <source>The returned vector of namespace declarations includes namespaces of the ancestors of</source>
          <target state="translated">반환 된 네임 스페이스 선언 벡터에는 조상의 네임 스페이스가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="77f0cc49cdc738436a61c4b64e42c2948c9f579e" translate="yes" xml:space="preserve">
          <source>The reverse axis is supported with a line, spline, and scatter series, as well as an area series with a cartesian chart. All axes of the same orientation attached to the same series must be reversed if one is reversed or the behavior is undefined.</source>
          <target state="translated">역축은 직교 차트가있는 영역 계열뿐만 아니라 선, 스플라인 및 분산 계열로 지원됩니다. 동일한 시리즈에 연결된 동일한 방향의 모든 축은 반전되거나 동작이 정의되지 않은 경우 반전되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7414d8a8805ed289f32a0472c2479dbb9bc262d5" translate="yes" xml:space="preserve">
          <source>The reverseProxy() function allows the &lt;a href=&quot;qremoteobjecthostbase#proxy&quot;&gt;proxy&lt;/a&gt;() functionality to be extended, in effect mirroring the proxy functionality in the &quot;reverse&quot; direction. These are distinct, because node communication is not symmetric, one side calls &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;enableRemoting&lt;/a&gt;() with a &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; object, the other side calls &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;acquire&lt;/a&gt;() to get a &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt;. Using &lt;a href=&quot;qremoteobjecthostbase#proxy&quot;&gt;proxy&lt;/a&gt;() allows you to &quot;observe&quot; objects on a target device remotely via acquire, but it does not allow off-target &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; objects to be acquired from the device's local:* network. That is where reverseProxy() comes in. If a proxyNode is created like so:</source>
          <target state="translated">reverseProxy () 함수를 사용하면 &lt;a href=&quot;qremoteobjecthostbase#proxy&quot;&gt;프록시&lt;/a&gt; 기능을 &quot;역방향&quot;방향으로 미러링하여 프록시 기능을 확장 할 수 있습니다. 노드 통신은 대칭이 아니기 때문에 한 쪽 은 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;Source&lt;/a&gt; 객체를 사용하여 &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;enableRemoting&lt;/a&gt; ()을 호출하고 다른 쪽 은 &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; 를 얻기 &lt;a href=&quot;qremoteobjectnode#acquire&quot;&gt;위해 획득&lt;/a&gt; ()을 호출합니다 . 사용 &lt;a href=&quot;qremoteobjecthostbase#proxy&quot;&gt;프록시은&lt;/a&gt; () 원격 획득을 통해 대상 장치의 개체를 &quot;관찰&quot;할 수 있지만, 그것은 대상의 오프 허용하지 않는 &lt;a href=&quot;qtremoteobjects-source#source&quot;&gt;소스&lt;/a&gt; 장치의 지역에서 취득 할 객체 : * 네트워크를. 여기에서 reverseProxy ()가 온다. proxyNode가 다음과 같이 생성되면 :</target>
        </trans-unit>
        <trans-unit id="b1abba55cbe6b589efac7f7cb1237a75b5af8472" translate="yes" xml:space="preserve">
          <source>The review's textual description of the place. It can be either rich (HTML based) text or plain text depending on the provider.</source>
          <target state="translated">장소에 대한 리뷰의 텍스트 설명. 공급자에 따라 서식있는 (HTML 기반) 텍스트 또는 일반 텍스트 일 ​​수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5877bb7986e1da8e8d542807a4ed0f6d17268ab6" translate="yes" xml:space="preserve">
          <source>The revision is guaranteed to increase when a document that is not modified is edited.</source>
          <target state="translated">수정되지 않은 문서를 편집하면 개정판이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="9e1534274eee65bbfbe8885a9db6d8c82a8a147e" translate="yes" xml:space="preserve">
          <source>The rich content of a place consists of items such as images, reviews and editorials. Potentially there may be many rich content items, so they are treated separately from the place details. They can be retrieved in a paged fashion via &lt;a href=&quot;qplacemanager#getPlaceContent&quot;&gt;QPlaceManager::getPlaceContent&lt;/a&gt;(). If necessary, the content may be assigned to a place so it can act as a convenient container.</source>
          <target state="translated">장소의 풍부한 콘텐츠는 이미지, 리뷰 및 편집과 같은 항목으로 구성됩니다. 리치 콘텐츠 항목이 많을 수 있으므로 장소 세부 정보와 별도로 처리됩니다. &lt;a href=&quot;qplacemanager#getPlaceContent&quot;&gt;QPlaceManager :: getPlaceContent&lt;/a&gt; () 를 통해 페이지 방식으로 검색 할 수 있습니다 . 필요한 경우 컨텐츠를 장소에 할당하여 편리한 컨테이너 역할을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6e644f6c802eab0141c6c7079b36bcd4364d61c" translate="yes" xml:space="preserve">
          <source>The rich content of a place is typically made available as paginated items. The ability to convert between &lt;a href=&quot;qplacecontent&quot;&gt;QPlaceContent&lt;/a&gt; and it's subclasses means that code which handles the mechanics of paging can be easily shared for each of the sub types.</source>
          <target state="translated">장소의 풍부한 콘텐츠는 일반적으로 페이지 매김 항목으로 제공됩니다. &lt;a href=&quot;qplacecontent&quot;&gt;QPlaceContent&lt;/a&gt; 간 변환 기능 와 서브 클래스 은 페이징 메커니즘을 처리하는 코드를 각 서브 타입마다 쉽게 공유 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="71eeb7940a77134ba7eb42717b1d1a828cfde341" translate="yes" xml:space="preserve">
          <source>The rich text support in Qt is designed to provide a fast, portable and efficient way to add reasonable online help facilities to applications, and to provide a basis for rich text editors. If you find the HTML support insufficient for your needs you may consider the use of Qt WebKit, which provides a full-featured web browser widget.</source>
          <target state="translated">Qt의 서식있는 텍스트 지원은 응용 프로그램에 합리적인 온라인 도움말 기능을 추가하고 서식있는 텍스트 편집기를위한 기반을 제공하는 빠르고 이식 가능하며 효율적인 방법을 제공하도록 설계되었습니다. 필요에 따라 HTML 지원이 충분하지 않다면 완전한 기능을 갖춘 웹 브라우저 위젯을 제공하는 Qt WebKit의 사용을 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99dd693df8cb2af02ac6bf5eed9c5017104f1e26" translate="yes" xml:space="preserve">
          <source>The right arrow of a &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; or a &lt;a href=&quot;qscrollbar&quot;&gt;QScrollBar&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 또는 &lt;a href=&quot;qscrollbar&quot;&gt;QScrollBar&lt;/a&gt; 의 오른쪽 화살표 .</target>
        </trans-unit>
        <trans-unit id="e93c6651e86eeefd3b1aad37e751cd59c753512c" translate="yes" xml:space="preserve">
          <source>The right bearing is the left-ward distance of the right-most pixel of the character from the logical origin of a subsequent character. This value is negative if the pixels of the character extend to the right of the width() of the character.</source>
          <target state="translated">오른쪽 방위는 후속 문자의 논리적 원점에서 문자의 가장 오른쪽 픽셀의 왼쪽 거리입니다. 문자의 픽셀이 문자의 width () 오른쪽으로 확장되면이 값은 음수입니다.</target>
        </trans-unit>
        <trans-unit id="ab2f8184239b88ea372c16f97f3223af4e1db729" translate="yes" xml:space="preserve">
          <source>The right button.</source>
          <target state="translated">오른쪽 버튼.</target>
        </trans-unit>
        <trans-unit id="c92d452ac412145262ffd0388a1b63087c1265bb" translate="yes" xml:space="preserve">
          <source>The right corner of a &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt;. For example, this control can be used to control the position the right corner widget in a &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; 의 오른쪽 모서리입니다 . 예를 &lt;a href=&quot;qtabwidget&quot;&gt;들어이&lt;/a&gt; 컨트롤을 사용하여 QTabWidget 의 오른쪽 모서리 위젯 위치를 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2641ce700fce54c0d0787283d24ebfa8378917e" translate="yes" xml:space="preserve">
          <source>The right delegate sits behind both &lt;a href=&quot;qml-qtquick-controls2-control#contentItem-prop&quot;&gt;contentItem&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-control#background-prop&quot;&gt;background&lt;/a&gt;. When the &lt;a href=&quot;qml-qtquick-controls2-swipedelegate&quot;&gt;SwipeDelegate&lt;/a&gt; is swiped to the left, this item will be gradually revealed.</source>
          <target state="translated">올바른 대리자는 &lt;a href=&quot;qml-qtquick-controls2-control#contentItem-prop&quot;&gt;contentItem&lt;/a&gt; 과 &lt;a href=&quot;qml-qtquick-controls2-control#background-prop&quot;&gt;background&lt;/a&gt; 뒤에 있습니다 . 때 &lt;a href=&quot;qml-qtquick-controls2-swipedelegate&quot;&gt;SwipeDelegate가&lt;/a&gt; 왼쪽으로 슬쩍되고,이 항목은 점차적으로 공개됩니다.</target>
        </trans-unit>
        <trans-unit id="6c3403d5fa0600fadf7ededcfcf6e8fb2fea832c" translate="yes" xml:space="preserve">
          <source>The right edge of the rectangle.</source>
          <target state="translated">사각형의 오른쪽 가장자리.</target>
        </trans-unit>
        <trans-unit id="d4a32f07aa5b04eb7a1cb80910fe44194e474029" translate="yes" xml:space="preserve">
          <source>The right edge of the window.</source>
          <target state="translated">창의 오른쪽 가장자리.</target>
        </trans-unit>
        <trans-unit id="e386084f091469109bde274f36109c53f659a146" translate="yes" xml:space="preserve">
          <source>The right edge.</source>
          <target state="translated">오른쪽 가장자리.</target>
        </trans-unit>
        <trans-unit id="ac9a398d2ac0d569742c133794702a43ee789d4e" translate="yes" xml:space="preserve">
          <source>The right glass frame margin. The default value is 0.</source>
          <target state="translated">오른쪽 유리 프레임 여백. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="4d9a8067fbe8080e2b12cd869da8957f073f8d60" translate="yes" xml:space="preserve">
          <source>The right margin.</source>
          <target state="translated">오른쪽 여백.</target>
        </trans-unit>
        <trans-unit id="3354152f4889baa8bfb0c866a1ec6aef216a05b2" translate="yes" xml:space="preserve">
          <source>The right most point of the vertical middle.</source>
          <target state="translated">수직 가운데 가장 오른쪽 지점.</target>
        </trans-unit>
        <trans-unit id="c04776204563369c3b69dbe2150d3fb4fbc6e507" translate="yes" xml:space="preserve">
          <source>The right side of a layout item.</source>
          <target state="translated">레이아웃 항목의 오른쪽</target>
        </trans-unit>
        <trans-unit id="eb6cae6d8142ad3c3f64738347654364ceaa7dd5" translate="yes" xml:space="preserve">
          <source>The right way is to create an instance of the derived class:</source>
          <target state="translated">올바른 방법은 파생 클래스의 인스턴스를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="441e73b39cd43aafcb464a4e90ad52d8d6a2b6c1" translate="yes" xml:space="preserve">
          <source>The right widget has the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_OpaquePaintEvent&lt;/a&gt; widget attribute set. This indicates that the widget will paint over its entire area with opaque colors. The widget's area will initially be</source>
          <target state="translated">오른쪽 위젯에는 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_OpaquePaintEvent&lt;/a&gt; 위젯 속성이 설정되어 있습니다. 이는 위젯이 전체 영역에 불투명 한 색상으로 페인트됨을 나타냅니다. 위젯 영역은 처음에</target>
        </trans-unit>
        <trans-unit id="431a5e0146296e30ca06fcca1492132bb2e6d70c" translate="yes" xml:space="preserve">
          <source>The role function should be reimplemented by all objects and describes the role of themselves and the children that do not provide accessible interfaces of their own.</source>
          <target state="translated">역할 기능은 모든 개체에 의해 다시 구현되어야하며 자신과 자신의 액세스 가능한 인터페이스를 제공하지 않는 자식의 역할을 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="f25dcf2aed1f16755548c0d9c63ff19306457664" translate="yes" xml:space="preserve">
          <source>The role indicates to the model which type of data is being referred to. Views can display the roles in different ways, so it is important to supply appropriate information for each role.</source>
          <target state="translated">역할은 참조되는 데이터 유형을 모델에 나타냅니다. 보기는 역할을 다른 방식으로 표시 할 수 있으므로 각 역할에 적절한 정보를 제공하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="22dec828a70c5c36f888ad8e68e1c2784f20c64f" translate="yes" xml:space="preserve">
          <source>The role is determined when constructing a &lt;a href=&quot;qlowenergycontroller&quot;&gt;QLowEnergyController&lt;/a&gt; instance using &lt;a href=&quot;qlowenergycontroller#createCentral&quot;&gt;createCentral&lt;/a&gt;() or &lt;a href=&quot;qlowenergycontroller#createPeripheral&quot;&gt;createPeripheral&lt;/a&gt;().</source>
          <target state="translated">구성 할 때 역할 판정 &lt;a href=&quot;qlowenergycontroller&quot;&gt;QLowEnergyController의&lt;/a&gt; 사용 예 &lt;a href=&quot;qlowenergycontroller#createCentral&quot;&gt;createCentral&lt;/a&gt; () 또는 &lt;a href=&quot;qlowenergycontroller#createPeripheral&quot;&gt;createPeripheral을&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="1ab83c42aa70dfc3f178a6450077f3c72fd75b45" translate="yes" xml:space="preserve">
          <source>The role is specified by &lt;a href=&quot;qmediaplayer#customAudioRole-prop&quot;&gt;QMediaPlayer::customAudioRole&lt;/a&gt;()</source>
          <target state="translated">역할은 &lt;a href=&quot;qmediaplayer#customAudioRole-prop&quot;&gt;QMediaPlayer :: customAudioRole&lt;/a&gt; ()에 의해 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="fff3a85dff21eb0434f1c01b0212dd6bb375b376" translate="yes" xml:space="preserve">
          <source>The role is undefined in this mode.</source>
          <target state="translated">이 모드에서는 역할이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de4dabc4aceec7a17dcad6f32bd3dec87320c866" translate="yes" xml:space="preserve">
          <source>The role is unknown or undefined</source>
          <target state="translated">알 수 없거나 정의되지 않은 역할</target>
        </trans-unit>
        <trans-unit id="f0667f0a1daba245040e5da6bdf7fc33120c1639" translate="yes" xml:space="preserve">
          <source>The role names are used by delegates to obtain data from list elements. Each role name is accessible in the delegate's scope, and refers to the corresponding role in the current element. Where a role name would be ambiguous to use, it can be accessed via the &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;model&lt;/a&gt; property (e.g., &lt;code&gt;model.cost&lt;/code&gt; instead of &lt;code&gt;cost&lt;/code&gt;).</source>
          <target state="translated">역할 이름은 목록 요소에서 데이터를 얻기 위해 대리자가 사용합니다. 각 역할 이름은 대리인의 범위에서 액세스 할 수 있으며 현재 요소의 해당 역할을 나타냅니다. 역할 이름이 사용하기 모호 할 것입니다 경우, 그것은을 통해 액세스 할 수 있습니다 &lt;a href=&quot;qml-qtquick-listview#model-prop&quot;&gt;모델의&lt;/a&gt; 특성 (예를 들어, &lt;code&gt;model.cost&lt;/code&gt; 대신 &lt;code&gt;cost&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5bf01b6e821bbd1f2d972f3ecfe679ea232eaefd" translate="yes" xml:space="preserve">
          <source>The roles of a &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass can be exposed to QML by reimplementing &lt;a href=&quot;qabstractitemmodel#roleNames&quot;&gt;QAbstractItemModel::roleNames&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 서브 클래스 의 역할은 &lt;a href=&quot;qabstractitemmodel#roleNames&quot;&gt;QAbstractItemModel :: roleNames&lt;/a&gt; 를 다시 구현하여 QML에 노출 될 수 있습니다. ()를 .</target>
        </trans-unit>
        <trans-unit id="55e22341648579319a1b15f2cc8a254db24cb0bb" translate="yes" xml:space="preserve">
          <source>The roles to make available for this model.</source>
          <target state="translated">이 모델에 사용 가능한 역할.</target>
        </trans-unit>
        <trans-unit id="61dce86b73d6f7898af5753b8cd2cf219fee9fa6" translate="yes" xml:space="preserve">
          <source>The root component, returned by this function, is not deleted when the &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; is destroyed. If you want to ensure that the root component is deleted, you should call &lt;a href=&quot;qpluginloader#unload&quot;&gt;unload&lt;/a&gt;() as soon you don't need to access the core component anymore. When the library is finally unloaded, the root component will automatically be deleted.</source>
          <target state="translated">이 함수에 의해 리턴 된 루트 구성 요소는 &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; 가 제거 될 때 삭제되지 않습니다 . 루트 구성 요소가 삭제 되도록하려면 더 이상 코어 구성 요소에 액세스 할 필요가없는 즉시 &lt;a href=&quot;qpluginloader#unload&quot;&gt;unload&lt;/a&gt; ()를 호출 해야합니다. 라이브러리가 마지막으로 언로드되면 루트 구성 요소가 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="ef4b85aba7adbfe8baa6a403ff1df394d696f7e0" translate="yes" xml:space="preserve">
          <source>The root context is automatically created by the &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine&lt;/a&gt;. Data that should be available to all QML component instances instantiated by the engine should be put in the root context.</source>
          <target state="translated">루트 컨텍스트는 &lt;a href=&quot;qqmlengine&quot;&gt;QQmlEngine에&lt;/a&gt; 의해 자동으로 작성됩니다 . 엔진이 인스턴스화 한 모든 QML 구성 요소 인스턴스에 사용 가능한 데이터는 루트 컨텍스트에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ce8fa64e8b6c10e17e3291f44e3c277035bfed53" translate="yes" xml:space="preserve">
          <source>The root directory</source>
          <target state="translated">루트 디렉토리</target>
        </trans-unit>
        <trans-unit id="10715cc533b45902fae92f01a85c7e0a78ff3058" translate="yes" xml:space="preserve">
          <source>The root entity of the 3D scene to be displayed.</source>
          <target state="translated">표시 할 3D 장면의 루트 엔티티입니다.</target>
        </trans-unit>
        <trans-unit id="afd24d8a4552be77772f15753c07df61b95ec4fa" translate="yes" xml:space="preserve">
          <source>The root item is returned by &lt;a href=&quot;qabstractitemview#rootIndex&quot;&gt;rootIndex&lt;/a&gt;(), and the current item by &lt;a href=&quot;qabstractitemview#currentIndex&quot;&gt;currentIndex&lt;/a&gt;(). To make sure that an item is visible use &lt;a href=&quot;qabstractitemview#scrollTo&quot;&gt;scrollTo&lt;/a&gt;().</source>
          <target state="translated">루트 항목은 &lt;a href=&quot;qabstractitemview#rootIndex&quot;&gt;rootIndex&lt;/a&gt; ()로, 현재 항목은 &lt;a href=&quot;qabstractitemview#currentIndex&quot;&gt;currentIndex&lt;/a&gt; () 로 반환됩니다 . 항목이 표시되도록하려면 &lt;a href=&quot;qabstractitemview#scrollTo&quot;&gt;scrollTo&lt;/a&gt; ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8491f7b1fced8b98a3f6dbc163d15e930eb773b6" translate="yes" xml:space="preserve">
          <source>The rotation angle held by &lt;a href=&quot;qpinchgesture#rotationAngle-prop&quot;&gt;rotationAngle&lt;/a&gt; changed.</source>
          <target state="translated">에 의해 유지 된 회전 각도 &lt;a href=&quot;qpinchgesture#rotationAngle-prop&quot;&gt;rotationAngle은&lt;/a&gt; 변화했다.</target>
        </trans-unit>
        <trans-unit id="67f668c99bc13d91d7212fc54d294f22102d84ba" translate="yes" xml:space="preserve">
          <source>The rotation is combined with the item's &lt;a href=&quot;qgraphicsitem#scale-1&quot;&gt;scale&lt;/a&gt;(), &lt;a href=&quot;qgraphicsitem#transform&quot;&gt;transform&lt;/a&gt;() and &lt;a href=&quot;qgraphicsitem#transformations&quot;&gt;transformations&lt;/a&gt;() to map the item's coordinate system to the parent item.</source>
          <target state="translated">로테이션은 아이템의 &lt;a href=&quot;qgraphicsitem#scale-1&quot;&gt;스케일&lt;/a&gt; 과 결합됩니다 (), &lt;a href=&quot;qgraphicsitem#transform&quot;&gt;변환&lt;/a&gt; () 및 &lt;a href=&quot;qgraphicsitem#transformations&quot;&gt;변환&lt;/a&gt; () 과 항목의 좌표계를 상위 항목에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="c958a2b31fad580e90e1b31d025e4331019813fe" translate="yes" xml:space="preserve">
          <source>The rotation of axis titles.</source>
          <target state="translated">축 제목의 회전입니다.</target>
        </trans-unit>
        <trans-unit id="2fa14774e8a5763ea484d10eb03caf0d35bf0377" translate="yes" xml:space="preserve">
          <source>The rotation of the pinch gesture in degrees, with positive values clockwise. It is 0 when the gesture begins. If &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt; is not null, this will be automatically applied to its &lt;a href=&quot;qml-qtquick-item#rotation-prop&quot;&gt;rotation&lt;/a&gt;. Otherwise, bindings can be used to do arbitrary things with this value.</source>
          <target state="translated">핀치 동작의 회전 (도)이며 양수 값은 시계 방향입니다. 제스처가 시작되면 0입니다. 만약&lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt; 이 null이 아닌&lt;a href=&quot;qml-qtquick-item#rotation-prop&quot;&gt; 회전에&lt;/a&gt; 자동으로 적용됩니다 . 그렇지 않으면 바인딩을 사용하여이 값으로 임의의 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96df25200a240c754afb66a3ca47d6d500279647" translate="yes" xml:space="preserve">
          <source>The rotation reading contains 3 angles, measured in degrees that define the orientation of the device in three-dimensional space. These angles are similar to yaw, pitch and roll but are defined using only right hand rotation with axes as defined by the right hand cartesian coordinate system.</source>
          <target state="translated">회전 판독 값에는 3 차원 공간에서 장치의 방향을 정의하는 각도로 측정 된 3 개의 각도가 포함됩니다. 이 각도는 요, 피치 및 롤과 유사하지만 오른쪽 직교 좌표계에 의해 정의 된 축을 사용하여 오른쪽 회전 만 사용하여 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="508cee5eca781f5d075bf89f8c387c1424a817dc" translate="yes" xml:space="preserve">
          <source>The rotation should be a normalized &lt;a href=&quot;qquaternion&quot;&gt;QQuaternion&lt;/a&gt;. For those series types that support item specific rotation, the rotations are multiplied together. &lt;a href=&quot;qbar3dseries&quot;&gt;QBar3DSeries&lt;/a&gt; ignores any rotation that is not around the y-axis. &lt;a href=&quot;qsurface3dseries&quot;&gt;QSurface3DSeries&lt;/a&gt; applies the rotation only to the selection pointer. Defaults to no rotation.</source>
          <target state="translated">회전은 정규화 된 &lt;a href=&quot;qquaternion&quot;&gt;QQuaternion&lt;/a&gt; 이어야합니다 . 품목별 회전을 지원하는 시리즈 유형의 경우 회전이 함께 곱해집니다. &lt;a href=&quot;qbar3dseries&quot;&gt;QBar3DSeries&lt;/a&gt; 는 y 축을 중심으로하지 않는 회전을 무시합니다.&lt;a href=&quot;qsurface3dseries&quot;&gt;QSurface3DSeries&lt;/a&gt; 는 선택 포인터에만 회전을 적용합니다. 기본적으로 회전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c7da522c2af8b072f1a7059f8e23d775861b6a6" translate="yes" xml:space="preserve">
          <source>The rotation transformation matrix is as follows:</source>
          <target state="translated">회전 변환 행렬은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0863b2a2f8259098d887d3d56f1c39cb1ff1f177" translate="yes" xml:space="preserve">
          <source>The route optimizations which should be considered during the planning of the route. Values can be combined with OR ('|') -operator.</source>
          <target state="translated">경로를 계획 할 때 고려해야 할 경로 최적화. 값은 OR ( '|')-연산자와 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b58e155e27805151dbf8b127492193b20fae239" translate="yes" xml:space="preserve">
          <source>The route query extra parameters. This property is read only. If the query is defined by the user, these can be set by using MapParameters. If the route query comes from the engine via signals, the query is intended to be read-only.</source>
          <target state="translated">경로 쿼리 추가 매개 변수 이 속성은 읽기 전용입니다. 사용자가 쿼리를 정의한 경우 MapParameters를 사용하여 쿼리를 설정할 수 있습니다. 경로 쿼리가 신호를 통해 엔진에서 오는 경우 쿼리는 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="3ec851f6be2b93558f46808414eebffc9eefed9d" translate="yes" xml:space="preserve">
          <source>The route segment will remain invalid until one of &lt;a href=&quot;qgeoroutesegment#setNextRouteSegment&quot;&gt;setNextRouteSegment&lt;/a&gt;(), &lt;a href=&quot;qgeoroutesegment#setTravelTime&quot;&gt;setTravelTime&lt;/a&gt;(), &lt;a href=&quot;qgeoroutesegment#setDistance&quot;&gt;setDistance&lt;/a&gt;(), &lt;a href=&quot;qgeoroutesegment#setPath&quot;&gt;setPath&lt;/a&gt;() or &lt;a href=&quot;qgeoroutesegment#setManeuver&quot;&gt;setManeuver&lt;/a&gt;() is called.</source>
          <target state="translated">경로 세그먼트는 &lt;a href=&quot;qgeoroutesegment#setNextRouteSegment&quot;&gt;setNextRouteSegment&lt;/a&gt; (), &lt;a href=&quot;qgeoroutesegment#setTravelTime&quot;&gt;setTravelTime&lt;/a&gt; (), &lt;a href=&quot;qgeoroutesegment#setDistance&quot;&gt;setDistance&lt;/a&gt; (), &lt;a href=&quot;qgeoroutesegment#setPath&quot;&gt;setPath&lt;/a&gt; () 또는&lt;a href=&quot;qgeoroutesegment#setManeuver&quot;&gt; setManeuver&lt;/a&gt; () .</target>
        </trans-unit>
        <trans-unit id="eb92271f25b0d3a94a078c822cabff6d4e27f685" translate="yes" xml:space="preserve">
          <source>The route will be optimized for someone who is driving a car</source>
          <target state="translated">경로는 자동차를 운전하는 사람에게 최적화됩니다</target>
        </trans-unit>
        <trans-unit id="134668c99e382d490a9c56bb45581ca3c59a29ec" translate="yes" xml:space="preserve">
          <source>The route will be optimized for someone who is driving a car.</source>
          <target state="translated">경로는 자동차를 운전하는 사람에게 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="dc7b10a911094dd10d2a4beddb2899d40d2cf46f" translate="yes" xml:space="preserve">
          <source>The route will be optimized for someone who is driving a truck</source>
          <target state="translated">경로는 트럭을 운전하는 사람에게 최적화됩니다</target>
        </trans-unit>
        <trans-unit id="c486c52bdbdb497a977fd98abfb192324c88c62c" translate="yes" xml:space="preserve">
          <source>The route will be optimized for someone who is driving a truck.</source>
          <target state="translated">경로는 트럭을 운전하는 사람에게 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="99786a233741a7fc720eeef5ea810bfc71c5fc52" translate="yes" xml:space="preserve">
          <source>The route will be optimized for someone who is making use of public transit.</source>
          <target state="translated">대중 교통을 이용하는 사람에게 최적의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="58f22fd4fa68b65b825a424171c319cceeab9d96" translate="yes" xml:space="preserve">
          <source>The route will be optimized for someone who is riding a bicycle</source>
          <target state="translated">자전거를 타는 사람에게 경로가 최적화됩니다</target>
        </trans-unit>
        <trans-unit id="612a0848de6048f41cc875962d036c7fa6f7a511" translate="yes" xml:space="preserve">
          <source>The route will be optimized for someone who is riding a bicycle.</source>
          <target state="translated">자전거를 타는 사람에게 경로가 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="fbdf64daac76a942f19a07c0f0522e601593bb35" translate="yes" xml:space="preserve">
          <source>The route will be optimized for someone who is walking</source>
          <target state="translated">경로는 걷는 사람에게 최적화됩니다</target>
        </trans-unit>
        <trans-unit id="62a336c3f08527b5555fa4ab2f87cb1e81b5f253" translate="yes" xml:space="preserve">
          <source>The route will be optimized for someone who is walking.</source>
          <target state="translated">경로는 걷는 사람에게 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="7a2d2e6db9fad3ee8be115c298ba1b0796bd6d95" translate="yes" xml:space="preserve">
          <source>The route will traverse the objects of</source>
          <target state="translated">경로는 객체를 통과합니다</target>
        </trans-unit>
        <trans-unit id="28ee81a61aef9a369fd6b17b494451b808400015" translate="yes" xml:space="preserve">
          <source>The routing manager that was used did not have a &lt;a href=&quot;qgeoroutingmanagerengine&quot;&gt;QGeoRoutingManagerEngine&lt;/a&gt; instance associated with it.</source>
          <target state="translated">사용 된 라우팅 관리자에 연관된 &lt;a href=&quot;qgeoroutingmanagerengine&quot;&gt;QGeoRoutingManagerEngine&lt;/a&gt; 인스턴스 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0413d096ad71615609e9563a59e7367f43afecc2" translate="yes" xml:space="preserve">
          <source>The row categories of the mapping. Only items with row role values that are found in this list are included when the data is resolved. The rows are ordered in the same order as they are in this list.</source>
          <target state="translated">매핑의 행 범주 이 목록에있는 행 역할 값이있는 항목 만 데이터가 분석 될 때 포함됩니다. 행은이 목록과 동일한 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="7a52624a0066c7b364d1e5ebd54f46aa016368e2" translate="yes" xml:space="preserve">
          <source>The row categories of the mapping. Only items with row roles that are found in this list are included when data is resolved. The rows are ordered in the same order as they are in this list.</source>
          <target state="translated">매핑의 행 범주 이 목록에서 찾은 행 역할이있는 항목 만 데이터가 분석 될 때 포함됩니다. 행은이 목록과 동일한 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="2ad49955354e3037174744967480f334e6432a74" translate="yes" xml:space="preserve">
          <source>The row of the model is used as the data source for the first box-and-whiskers item. The default value is -1 (invalid mapping).</source>
          <target state="translated">모델의 행은 첫 번째 상자 및 수염 항목의 데이터 소스로 사용됩니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="9aa53280bea7e48af37ae1b8a0c05edfd5c4c802" translate="yes" xml:space="preserve">
          <source>The row of the model is used as the data source for the last box-and-whiskers item. The default value is -1 (invalid mapping).</source>
          <target state="translated">모델의 행은 마지막 상자 및 수염 항목의 데이터 소스로 사용됩니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="ff87abe4fc465079f81d36d8aca87a1a0ef87438" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the close values of the candlestick items in the series. The default value is -1 (invalid mapping).</source>
          <target state="translated">시리즈에서 촛대 항목의 종가를 포함하는 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="5c76affccddf9954849096361336a91df00982b5" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the data for the first point of the series. The default value is 0.</source>
          <target state="translated">시리즈의 첫 번째 점에 대한 데이터를 포함하는 모델의 행입니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="9f512e2bc8eca4bc11bc36f34a6abe618904906a" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the first slice value. The default value is 0.</source>
          <target state="translated">첫 번째 슬라이스 값을 포함하는 모델의 행입니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="aebcd1e71101e4c41545703177e1ac68c0ae79bb" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the first values of the bar sets in the bar series. The default value is 0.</source>
          <target state="translated">막대 시리즈에서 막대 세트의 첫 번째 값을 포함하는 모델의 행입니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="c240f7cac4999a174b9089796641b7bd21b33250" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the first values of the box-and-whiskers items in the box plot series.</source>
          <target state="translated">상자 그림 시리즈의 상자 및 수염 항목의 첫 번째 값을 포함하는 모델의 행입니다.</target>
        </trans-unit>
        <trans-unit id="40f9fb2fb18c403b33711f21b40c729ebec25c41" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the high values of the candlestick items in the series. The default value is -1 (invalid mapping).</source>
          <target state="translated">시리즈에서 촛대 항목의 높은 값을 포함하는 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="e47e30cd321c8845cf679abeb78a192a7270ee79" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the low values of the candlestick items in the series. The default value is -1 (invalid mapping).</source>
          <target state="translated">시리즈에서 촛대 항목의 낮은 값을 포함하는 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="b3d9f1b25cc21bc9e3fe8697116b81a35da94ad3" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the open values of the candlestick items in the series. The default value is -1 (invalid mapping).</source>
          <target state="translated">시리즈에서 촛대 항목의 열린 값을 포함하는 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="5d56a5d3054a2a6792504dc2ce1fa34093fdf1f8" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the timestamp values of the candlestick items in the series. The default value is -1 (invalid mapping).</source>
          <target state="translated">시리즈의 촛대 항목의 타임 스탬프 값이 포함 된 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="62e02e86efc615ad60ac60d0f59e531665913514" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the x-coordinates of the data points. The default value is -1 (invalid mapping).</source>
          <target state="translated">데이터 포인트의 x 좌표를 포함하는 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="0cb76a7ecc158cb123f3b3eb3863913d3fac9b15" translate="yes" xml:space="preserve">
          <source>The row of the model that contains the y-coordinates of the data points.</source>
          <target state="translated">데이터 포인트의 y 좌표를 포함하는 모델의 행입니다.</target>
        </trans-unit>
        <trans-unit id="809ef3ba8c73439c1658a2b1ff459189c6c478ff" translate="yes" xml:space="preserve">
          <source>The row of the model that is kept in sync with the labels of the pie's slices. The default value is -1 (invalid mapping).</source>
          <target state="translated">파이 조각 레이블과 동기화 된 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="c600102117cd6f3ec23cab0d37046c8bcfe7bf0d" translate="yes" xml:space="preserve">
          <source>The row of the model that is kept in sync with the values of the pie's slices. The default value is -1 (invalid mapping).</source>
          <target state="translated">파이 조각 값과 동기화 된 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="f55282dc2f19b4400498aa6ad662ce1322eb9899" translate="yes" xml:space="preserve">
          <source>The row of the model that is used as the data source for the first item. The default value is -1 (invalid mapping).</source>
          <target state="translated">첫 번째 항목의 데이터 소스로 사용되는 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="0dd7ae797f5d899931d2cd1642f3ccffc4ed12ac" translate="yes" xml:space="preserve">
          <source>The row of the model that is used as the data source for the last bar set. The default value is -1 (invalid mapping).</source>
          <target state="translated">마지막 막대 세트의 데이터 소스로 사용되는 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="6532ffc25a7f6ead22b76882e52f82962a190031" translate="yes" xml:space="preserve">
          <source>The row of the model that is used as the data source for the last item. The default value is -1 (invalid mapping).</source>
          <target state="translated">마지막 항목의 데이터 소스로 사용되는 모델의 행입니다. 기본값은 -1 (잘못된 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="d0a16e35ef453542a3ceec92ddedcc4a65823edd" translate="yes" xml:space="preserve">
          <source>The rubber band is fixed to the point that was clicked and can be pulled both vertically and horizontally.</source>
          <target state="translated">고무 밴드는 클릭 한 지점에 고정되며 수직 및 수평으로 당길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68440a3c796de6fd632c72c3597b73413fecaf6c" translate="yes" xml:space="preserve">
          <source>The rubber band is locked to the size of the chart horizontally and can be pulled vertically to specify the zooming area.</source>
          <target state="translated">고무 밴드는 차트의 크기에 가로로 고정되며 세로로 당겨 확대 / 축소 영역을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb706785fe189ee4761e610d79cec8b143b7cd61" translate="yes" xml:space="preserve">
          <source>The rubber band is locked to the size of the chart vertically and can be pulled horizontally to specify the zooming area.</source>
          <target state="translated">고무줄은 세로로 차트 크기에 고정되며 가로로 당겨 확대 / 축소 영역을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3873f6fcea23dc7d8dc4f4951beb5c4a44a3891e" translate="yes" xml:space="preserve">
          <source>The ruby text for a part of the preedit string. There should be at most one ruby text set for every part of the preedit string. If several are specified for any character in the string the behaviour is undefined.</source>
          <target state="translated">사전 편집 문자열의 일부에 대한 루비 텍스트입니다. 사전 편집 문자열의 모든 부분에 대해 최대 하나의 루비 텍스트 세트가 있어야합니다. 문자열의 문자에 대해 여러 개가 지정되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9648179cac19289d44266d5fe1134a1d81d5cd2b" translate="yes" xml:space="preserve">
          <source>The rule of thumb for alignment is that a type is aligned to its natural boundary, which is the smallest power of 2 that is bigger than the type, unless that alignment is larger than the maximum useful alignment for the platform. For practical purposes, alignment larger than 2 * sizeof(void*) is only necessary for special hardware instructions (e.g., aligned SSE loads and stores on x86).</source>
          <target state="translated">정렬의 경험 법칙은 유형이 플랫폼의 최대 유용한 정렬보다 큰 경우를 제외하고 유형이 자연 경계에 정렬되어 유형보다 큰 2의 가장 작은 거듭 제곱 인 2보다 작습니다. 실제적인 목적으로, 2 * sizeof (void *)보다 큰 정렬은 특수 하드웨어 명령어 (예 : x86의 정렬 된 SSE로드 및 저장)에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="197ed0600473672604fcc1bbf3701ccaf70ff285" translate="yes" xml:space="preserve">
          <source>The rulers are defined as a number of pixels from the left edge of the &lt;a href=&quot;qml-qtquick-virtualkeyboard-traceinputarea#boundingBox-prop&quot;&gt;boundingBox&lt;/a&gt;.</source>
          <target state="translated">눈금자는 &lt;a href=&quot;qml-qtquick-virtualkeyboard-traceinputarea#boundingBox-prop&quot;&gt;boundingBox&lt;/a&gt; 의 왼쪽 가장자리에서 여러 픽셀로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="0ea6e7cd53e7f37a14a5263a577fb3db9d8565a3" translate="yes" xml:space="preserve">
          <source>The rulers are defined as a number of pixels from the left edge of the bounding box.</source>
          <target state="translated">눈금자는 경계 상자의 왼쪽 가장자리에서 여러 픽셀로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f469db00f31ce6fe1dc161f384d4b1d874ecfa0a" translate="yes" xml:space="preserve">
          <source>The rulers are defined as a number of pixels from the top edge of the &lt;a href=&quot;qml-qtquick-virtualkeyboard-traceinputarea#boundingBox-prop&quot;&gt;boundingBox&lt;/a&gt;.</source>
          <target state="translated">눈금자는 &lt;a href=&quot;qml-qtquick-virtualkeyboard-traceinputarea#boundingBox-prop&quot;&gt;boundingBox&lt;/a&gt; 의 위쪽 가장자리부터 여러 픽셀로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="5373271afcd293aa496865f69ac61fbf5306502d" translate="yes" xml:space="preserve">
          <source>The rulers are defined as a number of pixels from the top edge of the bounding box.</source>
          <target state="translated">눈금자는 경계 상자의 위쪽 가장자리부터 여러 픽셀로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="bcc2c020272fb5b3e89a31576620bac9e2eb052a" translate="yes" xml:space="preserve">
          <source>The rules themselves are not documented and are internal to Qt Linguist and &lt;code&gt;lrelease&lt;/code&gt;.</source>
          <target state="translated">규칙 자체는 문서화되지 않았으며 Qt Linguist 및 &lt;code&gt;lrelease&lt;/code&gt; 내부에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2f2065cd772a9f0d348b02c915161af0825c045" translate="yes" xml:space="preserve">
          <source>The run indicator of the server. &lt;code&gt;quint8&lt;/code&gt;</source>
          <target state="translated">서버의 실행 표시기 &lt;code&gt;quint8&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f914b2e0834ee85267f4121040d0a8dbadc594f" translate="yes" xml:space="preserve">
          <source>The running state of this state machine.</source>
          <target state="translated">이 상태 머신의 실행 상태입니다.</target>
        </trans-unit>
        <trans-unit id="73c31463433fad5f51bc996be59942648947e348" translate="yes" xml:space="preserve">
          <source>The same API definition file as was used on the source side, &lt;code&gt;SimpleSwitch.rep&lt;/code&gt;, is used for creating a &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;Replica&lt;/a&gt; header file using the &lt;a href=&quot;qtremoteobjects-repc#&quot;&gt;repc&lt;/a&gt; utility. Include the following line in your client side &lt;code&gt;.pro&lt;/code&gt; file, specifying a &lt;code&gt;.rep&lt;/code&gt; file input:</source>
          <target state="translated">소스 측에서 사용한 것과 동일한 API 정의 파일 인 &lt;code&gt;SimpleSwitch.rep&lt;/code&gt; 가 &lt;a href=&quot;qtremoteobjects-repc#&quot;&gt;repc&lt;/a&gt; 유틸리티를 사용하여 &lt;a href=&quot;qtremoteobjects-replica#replica&quot;&gt;복제본&lt;/a&gt; 헤더 파일 을 작성하는 데 사용됩니다 . &lt;code&gt;.rep&lt;/code&gt; 파일 입력을 지정 하여 클라이언트 측 &lt;code&gt;.pro&lt;/code&gt; 파일 에 다음 행을 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="76f36f94c78581353d5750602598e494004c29b0" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;qdragmoveevent#accept-1&quot;&gt;accept&lt;/a&gt;(), but also notifies that future moves will also be acceptable if they remain within the</source>
          <target state="translated">&lt;a href=&quot;qdragmoveevent#accept-1&quot;&gt;accept&lt;/a&gt; () 와 동일 하지만 향후 이동이</target>
        </trans-unit>
        <trans-unit id="d7cf1dc341f5b3f152b3a16f23040ab2474b2f00" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;qsysinfo#buildCpuArchitecture&quot;&gt;QSysInfo::buildCpuArchitecture&lt;/a&gt;(), such as &quot;arm&quot;, &quot;i386&quot;, &quot;mips&quot; or &quot;x86_64&quot;</source>
          <target state="translated">&quot;arm&quot;, &quot;i386&quot;, &quot;mips&quot;또는 &quot;x86_64&quot; 와 같은 &lt;a href=&quot;qsysinfo#buildCpuArchitecture&quot;&gt;QSysInfo :: buildCpuArchitecture&lt;/a&gt; () 와 동일</target>
        </trans-unit>
        <trans-unit id="d1d3180510bdf119de00ab3511549e3877881dd8" translate="yes" xml:space="preserve">
          <source>The same as an empty plain text. This is the default. Set by &lt;a href=&quot;qlabel#clear&quot;&gt;clear&lt;/a&gt;().</source>
          <target state="translated">빈 일반 텍스트와 동일합니다. 이것이 기본값입니다. &lt;a href=&quot;qlabel#clear&quot;&gt;clear&lt;/a&gt; ()로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d89a5a8d888dd83a0588a06ef20ff2cfe1fe8c8f" translate="yes" xml:space="preserve">
          <source>The same command with a</source>
          <target state="translated">와 같은 명령</target>
        </trans-unit>
        <trans-unit id="ed77ef30a35d4fda8eb92be90c40a88e84d8a5f0" translate="yes" xml:space="preserve">
          <source>The same example using this constructor:</source>
          <target state="translated">이 생성자를 사용하는 동일한 예제 :</target>
        </trans-unit>
        <trans-unit id="c3c2e446be7d95e0655d15386ba577d7ea22e888" translate="yes" xml:space="preserve">
          <source>The same mapping functions are available in the view, for mapping to and from the scene. &lt;a href=&quot;qgraphicsview#mapFromScene&quot;&gt;QGraphicsView::mapFromScene&lt;/a&gt;() and &lt;a href=&quot;qgraphicsview#mapToScene&quot;&gt;QGraphicsView::mapToScene&lt;/a&gt;(). To map from a view to an item, you first map to the scene, and then map from the scene to the item.</source>
          <target state="translated">장면과의 매핑을 위해 뷰에서 동일한 매핑 기능을 사용할 수 있습니다. &lt;a href=&quot;qgraphicsview#mapFromScene&quot;&gt;QGraphicsView :: mapFromScene&lt;/a&gt; () 및 &lt;a href=&quot;qgraphicsview#mapToScene&quot;&gt;QGraphicsView :: mapToScene&lt;/a&gt; (). 뷰에서 항목으로 매핑하려면 먼저 장면에 매핑 한 다음 장면에서 항목으로 매핑하십시오.</target>
        </trans-unit>
        <trans-unit id="689c04a9c128cbcc93772b41fb460dd25f991bed" translate="yes" xml:space="preserve">
          <source>The same may also be obtained by using &lt;a href=&quot;http://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution&quot;&gt;&lt;code&gt;std::uniform_real_distribution&lt;/code&gt;&lt;/a&gt; with parameters 0 and 1.</source>
          <target state="translated">매개 변수 0 및 1과 함께 &lt;a href=&quot;http://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution&quot;&gt; &lt;code&gt;std::uniform_real_distribution&lt;/code&gt; &lt;/a&gt; 을 사용하여 동일한 결과를 얻을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="502118c44438ca798e2ff9b00eb7e3be4260a758" translate="yes" xml:space="preserve">
          <source>The same menu may sometimes contain items that should not be included in the same exclusive group. Such cases are best handled using the &lt;a href=&quot;qml-qt-labs-platform-menuitem#group-prop&quot;&gt;group&lt;/a&gt; property.</source>
          <target state="translated">동일한 메뉴에 동일한 독점 그룹에 포함되지 않아야하는 항목이 포함되는 경우가 있습니다. 이러한 경우는 &lt;a href=&quot;qml-qt-labs-platform-menuitem#group-prop&quot;&gt;그룹&lt;/a&gt; 속성을 사용하여 처리하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="7c2735b67623f82115581b76f9c1876be8de8ca1" translate="yes" xml:space="preserve">
          <source>The same principle applies to any combination of view transitions. An added item may be moved before its add transition finishes, or a moved item may be removed before its moved transition finishes, and so on; so, the rule of thumb is that every transition should handle the same set of properties.</source>
          <target state="translated">뷰 전환의 모든 조합에 동일한 원칙이 적용됩니다. 추가 된 항목은 추가 전환이 완료되기 전에 이동되거나 이동 된 항목이 이동 된 전환이 완료되기 전에 제거 될 수 있습니다. 따라서 경험상 모든 전환은 동일한 속성 집합을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="db90f8ebc86d0fbe69fd25bd7d281c2379fd7bf5" translate="yes" xml:space="preserve">
          <source>The same principle applies to code that throws and catches exceptions. An exception that is not caught in the function that has locked the mutex has no way of unlocking the mutex before the exception is passed up the stack to the calling function.</source>
          <target state="translated">예외를 발생시키고 포착하는 코드에도 동일한 원칙이 적용됩니다. 뮤텍스를 잠근 함수에서 포착되지 않은 예외는 예외가 스택으로 호출 함수로 전달되기 전에 뮤텍스를 잠금 해제 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9ea08bd44a252c20dc3fbef732c8a3d96e515364" translate="yes" xml:space="preserve">
          <source>The same request can be created like this, if the values are known at compile time:</source>
          <target state="translated">컴파일 타임에 값을 알고 있으면 다음과 같이 동일한 요청을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65845e08bb3f8745879541c0cf1dcf0f78025bf1" translate="yes" xml:space="preserve">
          <source>The same response can be created like this, if the values are known at compile time:</source>
          <target state="translated">컴파일 타임에 값을 알고 있으면 다음과 같은 응답을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93ab2cf59b0be81dd39ceb3022c498100782e7bf" translate="yes" xml:space="preserve">
          <source>The same result may also be obtained by using &lt;a href=&quot;http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution&quot;&gt;&lt;code&gt;std::uniform_int_distribution&lt;/code&gt;&lt;/a&gt; with parameters</source>
          <target state="translated">매개 변수와 함께 &lt;a href=&quot;http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution&quot;&gt; &lt;code&gt;std::uniform_int_distribution&lt;/code&gt; &lt;/a&gt; 을 사용하여 동일한 결과를 얻을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="63c8f307946a8481640e8e713dad9d2f094e1689" translate="yes" xml:space="preserve">
          <source>The same sequence with &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt;.SelectWords will extend the selection start to a word boundary before or on position 5 and extend the selection end to a word boundary on or past position 9.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; .SelectWords 와 동일한 시퀀스 는 선택 시작을 위치 5 이전 또는 위치의 단어 경계까지 확장하고 선택 끝을 위치 9 또는 이전 위치의 단어 경계까지 확장합니다.</target>
        </trans-unit>
        <trans-unit id="2f82894d7a3953a0f95a636cc11ea5b707f97e2f" translate="yes" xml:space="preserve">
          <source>The same sequence with &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt;.SelectWords will extend the selection start to a word boundary before or on the 5th position, and extend the selection end to a word boundary on or past the 9th position.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; .SelectWords 와 동일한 시퀀스 는 선택 시작을 5 번째 위치 앞 또는 5 번째 단어 경계로 확장하고 선택 종료를 9 번째 위치 이상의 단어 경계까지 확장합니다.</target>
        </trans-unit>
        <trans-unit id="73ee08592813baa3ddd10c94cbc475cdb6cbdd6e" translate="yes" xml:space="preserve">
          <source>The same sequence with &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt;.SelectWords will extend the selection start to a word boundary before or on position 5 and extend the selection end to a word boundary on or past position 9.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; .SelectWords 와 동일한 시퀀스 는 선택 시작을 위치 5 이전 또는 위치의 단어 경계까지 확장하고 선택 끝을 위치 9 또는 이전 위치의 단어 경계까지 확장합니다.</target>
        </trans-unit>
        <trans-unit id="9649f666ecbc288b7fcde25e2cfb903f672d8479" translate="yes" xml:space="preserve">
          <source>The same source model cannot be added more than once.</source>
          <target state="translated">동일한 소스 모델을 두 번 이상 추가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b14906f76e6cac0863aed1adeef1ae3ee105c89c" translate="yes" xml:space="preserve">
          <source>The sample rate of the media's audio stream in hertz.</source>
          <target state="translated">미디어 오디오 스트림의 샘플 레이트 (Hz)입니다.</target>
        </trans-unit>
        <trans-unit id="c004320fe12132d06bcaaef6b100a114624cbd71" translate="yes" xml:space="preserve">
          <source>The sand brown theme.</source>
          <target state="translated">모래 갈색 테마.</target>
        </trans-unit>
        <trans-unit id="eb90dab91e4a427e363e2776b96d94b7b9dc474f" translate="yes" xml:space="preserve">
          <source>The satellite backend closed the connection, which happens for example in case the user is switching location services to off. This object becomes invalid and should be deleted. A new satellite source can be created by calling &lt;a href=&quot;qgeosatelliteinfosource#createDefaultSource&quot;&gt;createDefaultSource&lt;/a&gt;() later on.</source>
          <target state="translated">위성 백엔드는 연결을 닫았습니다. 예를 들어 사용자가 위치 서비스를 끄는 경우에 발생합니다. 이 개체는 유효하지 않으므로 삭제해야합니다. 나중에 &lt;a href=&quot;qgeosatelliteinfosource#createDefaultSource&quot;&gt;createDefaultSource&lt;/a&gt; () 를 호출하여 새 위성 소스를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de97c6331dd4609897984f24f93b5e04aa46edf5" translate="yes" xml:space="preserve">
          <source>The satellite identifier number can be used to identify a satellite inside the satellite system. For satellite system GPS the satellite identifier number represents the PRN (Pseudo-random noise) number. For satellite system GLONASS the satellite identifier number represents the slot number.</source>
          <target state="translated">위성 식별자 번호는 위성 시스템 내부의 위성을 식별하는 데 사용될 수 있습니다. 위성 시스템 GPS의 경우 위성 식별자 번호는 PRN (Pseudo-random noise) 번호를 나타냅니다. 위성 시스템 GLONASS의 경우 위성 식별자 번호는 슬롯 번호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3c535a32805edb07ef5d82ab251bf3af31d917c4" translate="yes" xml:space="preserve">
          <source>The saturation value from &lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; is combined with hue and lightness from source and written.</source>
          <target state="translated">&lt;a href=&quot;qml-qtgraphicaleffects-blend#foregroundSource-prop&quot;&gt;foregroundSource&lt;/a&gt; 의 채도 값은 소스의 색조 및 밝기와 결합되어 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="336e16642a0ac2b4436451d4eb0dcdc2857216b9" translate="yes" xml:space="preserve">
          <source>The saturation, value and alpha-channel values must be in the range 0-255, and the hue value must be greater than -1.</source>
          <target state="translated">채도, 값 및 알파 채널 값은 0-255 범위에 있어야하고 색조 값은 -1보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="8a8e4562655e8a25e62b6af104e52411f6468e83" translate="yes" xml:space="preserve">
          <source>The saving of a new place is performed as follows, we create a &lt;a href=&quot;qplace&quot;&gt;QPlace&lt;/a&gt; instance and populate it with information such as a name, address and coordinate. Once done we can invoke &lt;a href=&quot;qplacemanager#savePlace&quot;&gt;QPlaceManager::savePlace&lt;/a&gt;() to begin a save operation.</source>
          <target state="translated">새 장소 저장은 다음과 같이 수행됩니다. &lt;a href=&quot;qplace&quot;&gt;QPlace&lt;/a&gt; 인스턴스를 작성 하고 이름, 주소 및 좌표와 같은 정보로 채 웁니다. 완료되면 &lt;a href=&quot;qplacemanager#savePlace&quot;&gt;QPlaceManager :: savePlace&lt;/a&gt; ()를 호출 하여 저장 작업을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c97d4857ca70b69ce938acd178279e6a7b47fee2" translate="yes" xml:space="preserve">
          <source>The scale factor can be any real number; the default value is 1.0. If you set the factor to 0.0, the item will be collapsed to a single point. If you provide a negative value, the item will be flipped end for end around its origin.</source>
          <target state="translated">스케일 팩터는 임의의 실수 일 수 있습니다. 기본값은 1.0입니다. 계수를 0.0으로 설정하면 항목이 단일 지점으로 축소됩니다. 음수 값을 제공하면 항목이 원점을 기준으로 끝으로 뒤집 힙니다.</target>
        </trans-unit>
        <trans-unit id="472585844a5d9de56e7f99d368c2ce31f3753f74" translate="yes" xml:space="preserve">
          <source>The scale factor can be any real number; the default value is 1.0. If you set the factor to 0.0, the item will be collapsed to a single point. If you provide a negative value, the item will be flipped vertically around its origin.</source>
          <target state="translated">스케일 팩터는 임의의 실수 일 수 있습니다. 기본값은 1.0입니다. 계수를 0.0으로 설정하면 항목이 단일 지점으로 축소됩니다. 음수 값을 제공하면 항목이 원점을 기준으로 세로로 뒤집 힙니다.</target>
        </trans-unit>
        <trans-unit id="9e9d22c18eb346d18fb28e197c3f2e69d863a80d" translate="yes" xml:space="preserve">
          <source>The scale factor can be any real number; the default value is 1.0. If you set the factor to 0.0, the item will be collapsed to a single point. If you provide a negative value, the item will be mirrored horizontally around its origin.</source>
          <target state="translated">스케일 팩터는 임의의 실수 일 수 있습니다. 기본값은 1.0입니다. 계수를 0.0으로 설정하면 항목이 단일 지점으로 축소됩니다. 음수 값을 제공하면 항목이 원점을 기준으로 가로로 미러링됩니다.</target>
        </trans-unit>
        <trans-unit id="eae71440263f256ea4e1017f351adabfa84b96df" translate="yes" xml:space="preserve">
          <source>The scale factor held by &lt;a href=&quot;qpinchgesture#scaleFactor-prop&quot;&gt;scaleFactor&lt;/a&gt; changed.</source>
          <target state="translated">&lt;a href=&quot;qpinchgesture#scaleFactor-prop&quot;&gt;scaleFactor가&lt;/a&gt; 보유한 축척 비율이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="34ed232415f497f8913b753b9d23a391d6920863" translate="yes" xml:space="preserve">
          <source>The scale factor measures the scale factor associated with the distance between two of the user's inputs on a touch device.</source>
          <target state="translated">스케일 팩터는 터치 장치에서 사용자의 두 입력 사이의 거리와 관련된 스케일 팩터를 측정합니다.</target>
        </trans-unit>
        <trans-unit id="363177e71e677c481facf568afdb1da6621aee63" translate="yes" xml:space="preserve">
          <source>The scale factor that will automatically be set on the &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt; if it is not null. Otherwise, bindings can be used to do arbitrary things with this value. While the pinch gesture is being performed, it is continuously multiplied by &lt;a href=&quot;qml-qtquick-pinchhandler#activeScale-prop&quot;&gt;activeScale&lt;/a&gt;; after the gesture ends, it stays the same; and when the next pinch gesture begins, it begins to be multiplied by &lt;a href=&quot;qml-qtquick-pinchhandler#activeScale-prop&quot;&gt;activeScale&lt;/a&gt; again.</source>
          <target state="translated">&lt;a href=&quot;qmake-variable-reference#target&quot;&gt;대상&lt;/a&gt; 이 null이 아닌 경우 자동으로 설정되는 배율입니다 . 그렇지 않으면 바인딩을 사용하여이 값으로 임의의 작업을 수행 할 수 있습니다. 핀치 제스처가 수행되는 동안 지속적으로 &lt;a href=&quot;qml-qtquick-pinchhandler#activeScale-prop&quot;&gt;activeScale을&lt;/a&gt; 곱합니다 . 제스처가 끝난 후에도 동일하게 유지됩니다. 다음 핀치 동작이 시작되면 &lt;a href=&quot;qml-qtquick-pinchhandler#activeScale-prop&quot;&gt;activeScale에&lt;/a&gt; 다시 곱하기 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="bf4bfc20e85ba470419a97aa5fe173061299289e" translate="yes" xml:space="preserve">
          <source>The scale factor while the pinch gesture is being performed. It is 1.0 when the gesture begins, increases as the touchpoints are spread apart, and decreases as the touchpoints are brought together. If &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt; is not null, its &lt;a href=&quot;qml-qtquick-item#scale-prop&quot;&gt;scale&lt;/a&gt; will be automatically multiplied by this value. Otherwise, bindings can be used to do arbitrary things with this value.</source>
          <target state="translated">핀치 제스처가 수행되는 동안 스케일 팩터. 제스처가 시작될 때 1.0, 터치 포인트가 퍼짐에 따라 증가하고 터치 포인트가 결합되면 감소합니다. &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt; 이 null이 아닌 경우 해당 &lt;a href=&quot;qml-qtquick-item#scale-prop&quot;&gt;배율&lt;/a&gt; 에이 값이 자동으로 곱해집니다. 그렇지 않으면 바인딩을 사용하여이 값으로 임의의 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5db7d297367f73d1c9d08bad97a4cb18b33b2d71" translate="yes" xml:space="preserve">
          <source>The scale factors and skew factors are multiples; &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; are coordinate space units, just like the units in the translate(x,y) method.</source>
          <target state="translated">스케일 팩터와 스큐 팩터는 배수입니다. &lt;code&gt;e&lt;/code&gt; 와 &lt;code&gt;f&lt;/code&gt; 는 translate (x, y) 메소드의 단위와 마찬가지로 좌표 공간 단위입니다.</target>
        </trans-unit>
        <trans-unit id="0f5c04225339c7f3338af49c7202f1f65feeb539" translate="yes" xml:space="preserve">
          <source>The scale is combined with the item's &lt;a href=&quot;qgraphicsitem#rotation&quot;&gt;rotation&lt;/a&gt;(), &lt;a href=&quot;qgraphicsitem#transform&quot;&gt;transform&lt;/a&gt;() and &lt;a href=&quot;qgraphicsitem#transformations&quot;&gt;transformations&lt;/a&gt;() to map the item's coordinate system to the parent item.</source>
          <target state="translated">배율은 항목의 &lt;a href=&quot;qgraphicsitem#rotation&quot;&gt;회전&lt;/a&gt; (), &lt;a href=&quot;qgraphicsitem#transform&quot;&gt;변형&lt;/a&gt; () 및 &lt;a href=&quot;qgraphicsitem#transformations&quot;&gt;변형&lt;/a&gt; () 과 결합되어 항목의 좌표계를 상위 항목에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="b56984da3345c8ecf733ae626a9fdf1691f4282c" translate="yes" xml:space="preserve">
          <source>The scale of the values is meters per second squared.</source>
          <target state="translated">값의 스케일은 초당 미터 제곱입니다.</target>
        </trans-unit>
        <trans-unit id="1a8764ac25d198e6061ce469b8dddda96c557a4c" translate="yes" xml:space="preserve">
          <source>The scale of the values is meters per second squared. The axes are arranged as follows.</source>
          <target state="translated">값의 스케일은 초당 미터 제곱입니다. 축은 다음과 같이 배열됩니다.</target>
        </trans-unit>
        <trans-unit id="0ae9b746ed4f77a73866e0c9549cfc1a6f40f172" translate="yes" xml:space="preserve">
          <source>The scaled clip rect (or ROI, Region Of Interest) of the image. A handler that supports this option is expected to apply the provided clip rect (a &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;), after applying any scaling (ScaleSize) or regular clipping (ClipRect). If the handler does not support this option, &lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt; will apply the scaled clip rect after the image has been read.</source>
          <target state="translated">이미지의 스케일 된 클립 rect (또는 ROI, 관심 영역) 이 옵션을 지원하는 핸들러는 스케일링 (ScaleSize) 또는 일반 클리핑 (ClipRect) 을 적용한 후 제공된 클립 rect ( &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; )를 적용해야합니다. 핸들러가이 옵션을 지원하지 않으면 &lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt; 는 이미지를 읽은 후에 스케일링 된 클립 rect를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="548bcc721fa9ca778b98e1836c3b83be9772bd34" translate="yes" xml:space="preserve">
          <source>The scaled device pixel ratio for the device. This is identical to PdmDevicePixelRatio, except that the value is scaled by a constant factor in order to support paint devices with fractional scale factors. The constant scaling factor used is devicePixelRatioFScale(). This enum value has been introduced in Qt 5.6.</source>
          <target state="translated">장치의 스케일 된 장치 픽셀 비율입니다. 분수 스케일 팩터로 페인트 디바이스를 지원하기 위해 값이 일정한 팩터로 스케일링된다는 점을 제외하면 PdmDevicePixelRatio와 동일합니다. 사용되는 상수 스케일링 계수는 devicePixelRatioFScale ()입니다. 이 열거 형 값은 Qt 5.6에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="d3faa6bd62c1b514fa796ed9414a1952bb5685f3" translate="yes" xml:space="preserve">
          <source>The scaled size of the image. A handler that supports this option is expected to scale the image to the provided size (a &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt;), after applying any clip rect transformation (ClipRect). If the handler does not support this option, &lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt; will perform the scaling after the image has been read.</source>
          <target state="translated">이미지의 크기가 조정되었습니다. 이 옵션을 지원하는 핸들러는 클립 &lt;a href=&quot;qsize&quot;&gt;렉트&lt;/a&gt; 변환 (ClipRect)을 적용한 후 이미지를 제공된 크기 ( QSize )로 조정합니다. 핸들러가이 옵션을 지원하지 않으면 &lt;a href=&quot;qimagereader&quot;&gt;QImageReader&lt;/a&gt; 는 이미지를 읽은 후에 스케일링을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="492950a278feb99a774cb4025a606fd30204982d" translate="yes" xml:space="preserve">
          <source>The scaling factor for the X axis.</source>
          <target state="translated">X 축의 배율입니다.</target>
        </trans-unit>
        <trans-unit id="3a7eb990d9717a096b59f23c9f16c6e4b683c616" translate="yes" xml:space="preserve">
          <source>The scaling factor for the Y axis.</source>
          <target state="translated">Y 축의 배율입니다.</target>
        </trans-unit>
        <trans-unit id="89d8dcc47f8365825ea6126d81e398e4b7f2e12d" translate="yes" xml:space="preserve">
          <source>The scaling is needed for heights that include a fixed number of pixels, to scale them appropriately for printing.</source>
          <target state="translated">크기 조정은 고정 된 수의 픽셀을 포함하는 높이에 대해 인쇄에 맞게 크기를 조정하는 데 필요합니다.</target>
        </trans-unit>
        <trans-unit id="e477e58868476806857605cbc200accaea8db7a0" translate="yes" xml:space="preserve">
          <source>The scanline data is aligned on a 32-bit boundary.</source>
          <target state="translated">스캔 라인 데이터는 32 비트 경계에 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="10fb2f08157e21859c8a533abd5245d7ce06d450" translate="yes" xml:space="preserve">
          <source>The scanline data is as minimum 32-bit aligned. For 64-bit formats it follows the native alignment of 64-bit integers (64-bit for most platforms, but notably 32-bit on i386).</source>
          <target state="translated">스캔 라인 데이터는 최소 32 비트로 정렬됩니다. 64 비트 형식의 경우 64 비트 정수 (대부분의 플랫폼의 경우 64 비트, 특히 i386의 경우 32 비트)의 기본 정렬을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="046b8f5bdfe91a3545c5e4dcac152b7de3d7b8fa" translate="yes" xml:space="preserve">
          <source>The scatter data is displayed as a collection of points on the chart. For each point, two values are specified that determine its position on the horizontal axis and the vertical axis.</source>
          <target state="translated">산포 데이터는 차트에서 포인트 모음으로 표시됩니다. 각 점에 대해 가로 축과 세로 축에서의 위치를 ​​결정하는 두 개의 값이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="5899ce19dfb79b4e75e7bad3e5dcac9db8918e60" translate="yes" xml:space="preserve">
          <source>The scene can be rotated, zoomed into, and a bar can be selected to view its value, but no other interaction is included in this minimal code example. You can learn more by familiarizing yourself with the examples provided, like the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdatavisualization-bars-example.html#&quot;&gt;Bars Example&lt;/a&gt;.</source>
          <target state="translated">값을보기 위해 장면을 회전하고 확대하고 막대를 선택할 수 있지만이 최소 코드 예제에는 다른 상호 작용이 포함되어 있지 않습니다. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdatavisualization-bars-example.html#&quot;&gt;Bars Example&lt;/a&gt; 과 같이 제공된 예제를 숙지하여 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a040002c4ed1f762bcf304769897a99555b7a4e" translate="yes" xml:space="preserve">
          <source>The scene can be rotated, zoomed into, and a surface point can be selected to view its position, but no other interaction is included in this minimal code example. You can learn more by familiarizing yourself with the examples provided, like the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdatavisualization-surface-example.html#&quot;&gt;Surface Example&lt;/a&gt;.</source>
          <target state="translated">장면을 회전, 확대 및 표면 지점을 선택하여 위치를 볼 수 있지만이 최소 코드 예제에는 다른 상호 작용이 포함되어 있지 않습니다. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdatavisualization-surface-example.html#&quot;&gt;Surface 예제&lt;/a&gt; 와 같이 제공된 예제를 숙지하여 더 많은 것을 배울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f099ff566957fa8fd8303dc9e21d2e966784ce2" translate="yes" xml:space="preserve">
          <source>The scene can be rotated, zoomed into, and an item can be selected to view its position, but no other interaction is included in this minimal code example. You can learn more by familiarizing yourself with the examples provided, like the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdatavisualization-scatter-example.html#&quot;&gt;Scatter Example&lt;/a&gt;.</source>
          <target state="translated">장면을 회전하고 확대하고 항목을 선택하여 위치를 볼 수 있지만이 최소 코드 예제에는 다른 상호 작용이 포함되어 있지 않습니다. &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtdatavisualization-scatter-example.html#&quot;&gt;Scatter Example&lt;/a&gt; 과 같이 제공된 예제를 숙지하여 자세한 내용을 배울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29b647ef37c6189df4f409ff539a14e92ae58fd1" translate="yes" xml:space="preserve">
          <source>The scene graph API is very low-level and focuses on performance rather than convenience. Writing custom geometries and materials from scratch, even the most basic ones, requires a non-trivial amount of code. For this reason, the API includes a few convenience classes to make the most common custom nodes readily available.</source>
          <target state="translated">장면 그래프 API는 매우 저수준이며 편의성보다는 성능에 중점을 둡니다. 가장 기본적인 것부터 사용자 정의 형상과 재료를 처음부터 작성하려면 사소한 양의 코드가 필요합니다. 이러한 이유로 API에는 가장 일반적인 사용자 정의 노드를 쉽게 사용할 수 있도록 몇 가지 편의 클래스가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a109ea27b647ca47c2a3a4706848c73a5bae312" translate="yes" xml:space="preserve">
          <source>The scene graph can reorder geometry nodes to minimize state changes. The compare function is called during the sorting process so that the materials can be sorted to minimize state changes in each call to &lt;a href=&quot;qsgmaterialshader#updateState&quot;&gt;QSGMaterialShader::updateState&lt;/a&gt;().</source>
          <target state="translated">장면 그래프는 지오메트리 노드의 순서를 변경하여 상태 변경을 최소화 할 수 있습니다. &lt;a href=&quot;qsgmaterialshader#updateState&quot;&gt;QSGMaterialShader :: updateState&lt;/a&gt; () 에 대한 각 호출에서 상태 변경을 최소화하기 위해 재료를 정렬 할 수 있도록 정렬 프로세스 중에 비교 기능이 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="2120daa1fdfe82288b521446c5c16865ca7e0df2" translate="yes" xml:space="preserve">
          <source>The scene graph can support pseudo 3D and proper 3D primitives. For instance, one can implement a &quot;page curl&quot; effect using a &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect&lt;/a&gt; or implement a bumpmapped torus using &lt;a href=&quot;qsggeometry&quot;&gt;QSGGeometry&lt;/a&gt; and a custom material. While doing so, one needs to take into account that the default renderer already makes use of the depth buffer.</source>
          <target state="translated">장면 그래프는 의사 3D 및 적절한 3D 프리미티브를 지원할 수 있습니다. 예를 들어, &lt;a href=&quot;qml-qtquick-shadereffect&quot;&gt;ShaderEffect를&lt;/a&gt; 사용하여 &quot;페이지 말림&quot;효과를 구현하거나 &lt;a href=&quot;qsggeometry&quot;&gt;QSGGeometry&lt;/a&gt; 및 사용자 정의 재료를 사용하여 범프 맵 토러스를 구현할 수 있습니다. 그렇게하는 동안 기본 렌더러가 이미 깊이 버퍼를 사용하고 있음을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="20c6ae896d3efacaba5d7c616a85f4da8f591dab" translate="yes" xml:space="preserve">
          <source>The scene graph has support for a number of logging categories. These can be useful in tracking down both performance issues and bugs in addition to being helpful to Qt contributors.</source>
          <target state="translated">장면 그래프는 다양한 로깅 범주를 지원합니다. 이는 Qt 기고자에게 도움이 될뿐만 아니라 성능 문제와 버그를 모두 추적하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee9ae7c7f82c9ce0f40cbee52503934e26bac6bf" translate="yes" xml:space="preserve">
          <source>The scene graph is a graphical representation of the Item scene, an independent structure that contains enough information to render all the items. Once it has been set up, it can be manipulated and rendered independently of the state of the items. On many platforms, the scene graph will even be rendered on a dedicated render thread while the GUI thread is preparing the next frame's state.</source>
          <target state="translated">장면 그래프는 모든 항목을 렌더링하기에 충분한 정보를 포함하는 독립적 인 구조 인 항목 장면의 그래픽 표현입니다. 일단 설정되면 항목의 상태와 독립적으로 조작하고 렌더링 할 수 있습니다. 많은 플랫폼에서 GUI 스레드가 다음 프레임의 상태를 준비하는 동안 장면 그래프가 전용 렌더링 스레드에서 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="d754d68a40b205538b685a1e7734461aeffac133" translate="yes" xml:space="preserve">
          <source>The scene graph is a graphical representation of the Item scene. It can be thought of as a graphical deep copy, an independent structure that contains enough information to render all the items.</source>
          <target state="translated">장면 그래프는 항목 장면을 그래픽으로 표현한 것입니다. 모든 항목을 렌더링하기에 충분한 정보가 포함 된 독립 구조 인 그래픽 딥 카피로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="650bee5e0077db979fe6b32aee77d708c2ec0449" translate="yes" xml:space="preserve">
          <source>The scene graph is closely tied to Qt Quick 2.0 and can not be used stand-alone. The scene graph is managed and rendered by the &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; class and custom Item types can add their graphical primitives into the scene graph through a call to &lt;a href=&quot;qquickitem#updatePaintNode&quot;&gt;QQuickItem::updatePaintNode&lt;/a&gt;().</source>
          <target state="translated">장면 그래프는 Qt Quick 2.0과 밀접한 관련이 있으며 독립형으로 사용할 수 없습니다. 장면 그래프는 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 클래스에 의해 관리 및 렌더링되며 사용자 정의 항목 유형은 &lt;a href=&quot;qquickitem#updatePaintNode&quot;&gt;QQuickItem :: updatePaintNode&lt;/a&gt; ()를 호출하여 그래픽 프리미티브를 장면 그래프에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de4311cbb71c4dc37738c1867cc79db3eff8e98a" translate="yes" xml:space="preserve">
          <source>The scene graph is composed of a number of predefined node types, each serving a dedicated purpose. Although we refer to it as a scene graph, a more precise definition is node tree. The tree is built from &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; types in the QML scene and internally the scene is then processed by a renderer which draws the scene. The nodes themselves do &lt;b&gt;not&lt;/b&gt; contain any active drawing code nor virtual &lt;code&gt;paint()&lt;/code&gt; function.</source>
          <target state="translated">장면 그래프는 여러 가지 사전 정의 된 노드 유형으로 구성되며 각 노드는 전용 용도로 사용됩니다. 이것을 장면 그래프라고 부르지 만보다 정확한 정의는 노드 트리입니다. 트리는 QML 장면의 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 유형으로 빌드 되며 내부적으로 장면을 그리는 렌더러에서 장면을 처리합니다. 노드 자체 에는 활성 도면 코드 나 가상 &lt;code&gt;paint()&lt;/code&gt; 함수가 포함되어 있지 &lt;b&gt;않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="71ae958daf3ba9fb0794ed8d623a021330a76caf" translate="yes" xml:space="preserve">
          <source>The scene graph is invalidated; This can happen, for instance, if the window is hidden using &lt;a href=&quot;qwindow#hide&quot;&gt;QQuickWindow::hide&lt;/a&gt;(). If the item class implements a &lt;code&gt;slot&lt;/code&gt; named &lt;code&gt;invalidateSceneGraph()&lt;/code&gt;, this slot will be called on the rendering thread while the GUI thread is blocked. This is equivalent to connecting to &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;QQuickWindow::sceneGraphInvalidated&lt;/a&gt;(). The OpenGL context of this item's window will be bound when this slot is called. The only exception is if the native OpenGL has been destroyed outside Qt's control, for instance through &lt;code&gt;EGL_CONTEXT_LOST&lt;/code&gt;.</source>
          <target state="translated">장면 그래프가 무효화되었습니다. 예를 들어, &lt;a href=&quot;qwindow#hide&quot;&gt;QQuickWindow :: hide&lt;/a&gt; ()를 사용하여 창이 숨겨져있는 경우에 발생할 수 있습니다 . 항목 클래스가 &lt;code&gt;invalidateSceneGraph()&lt;/code&gt; 라는 &lt;code&gt;slot&lt;/code&gt; 구현하는 경우이 스레드는 GUI 스레드가 차단되는 동안 렌더링 스레드에서 호출됩니다. 이것은 &lt;a href=&quot;qquickwindow#sceneGraphInvalidated&quot;&gt;QQuickWindow :: sceneGraphInvalidated&lt;/a&gt; () 에 연결하는 것과 같습니다 . 이 슬롯이 호출되면이 항목 창의 OpenGL 컨텍스트가 바인딩됩니다. 유일한 예외는 네이티브 OpenGL이 Qt의 제어 외부에서 파괴 된 경우입니다 (예 : &lt;code&gt;EGL_CONTEXT_LOST&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="0797bae17b382355e23b495311b800fb60000003" translate="yes" xml:space="preserve">
          <source>The scene graph is rendered:</source>
          <target state="translated">장면 그래프가 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="f0ec912730456256572fad5bbf112ccc50414933" translate="yes" xml:space="preserve">
          <source>The scene graph nodes and resources are still released when the last &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; is deleted.</source>
          <target state="translated">씬 그래프 노드와 리소스는 마지막 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; 가 삭제 될 때 여전히 해제 됩니다.</target>
        </trans-unit>
        <trans-unit id="2d3f640f04bb7b5c91299c8576649bfe2370ffad" translate="yes" xml:space="preserve">
          <source>The scene graph nodes and resources can be released to free up graphics resources when the window is obscured, hidden or not rendering. When this happens is implementation specific.</source>
          <target state="translated">윈도우가 가려 지거나 숨겨 지거나 렌더링되지 않을 때 그래픽 리소스를 확보하기 위해 장면 그래프 노드 및 리소스를 해제 할 수 있습니다. 이런 일이 발생하면 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d97f8ea14853699ac8c6a057feafb3125e82003f" translate="yes" xml:space="preserve">
          <source>The scene graph nodes contains a mechanism to describe which parts of the scene has changed. This includes the combined matrices, accumulated opacity, changes to the node hierarchy, and so on. This information can be used for optimizations inside the scene graph renderer. For the renderer to properly render the nodes, it is important that users call &lt;a href=&quot;qsgnode#markDirty&quot;&gt;QSGNode::markDirty&lt;/a&gt;() with the correct flags when nodes are changed. Most of the functions on the node classes will implicitly call &lt;a href=&quot;qsgnode#markDirty&quot;&gt;markDirty&lt;/a&gt;(). For example, &lt;a href=&quot;qsgnode#appendChildNode&quot;&gt;QSGNode::appendChildNode&lt;/a&gt;() will call &lt;a href=&quot;qsgnode#markDirty&quot;&gt;markDirty&lt;/a&gt;() passing in &lt;a href=&quot;qsgnode#DirtyStateBit-enum&quot;&gt;QSGNode::DirtyNodeAdded&lt;/a&gt;.</source>
          <target state="translated">장면 그래프 노드에는 장면의 어떤 부분이 변경되었는지 설명하는 메커니즘이 포함되어 있습니다. 여기에는 결합 된 행렬, 누적 된 불투명도, 노드 계층 구조 변경 등이 포함됩니다. 이 정보는 장면 그래프 렌더러 내부의 최적화에 사용될 수 있습니다. 렌더러가 노드를 올바르게 렌더링하려면 노드가 변경 될 때 사용자 가 올바른 플래그로 &lt;a href=&quot;qsgnode#markDirty&quot;&gt;QSGNode :: markDirty&lt;/a&gt; ()를 호출 해야합니다. 노드 클래스의 대부분의 함수는 암시 적으로 &lt;a href=&quot;qsgnode#markDirty&quot;&gt;markDirty&lt;/a&gt; ()를 호출 합니다. 예를 들어, &lt;a href=&quot;qsgnode#appendChildNode&quot;&gt;QSGNode :: appendChildNode&lt;/a&gt; ()는 &lt;a href=&quot;qsgnode#DirtyStateBit-enum&quot;&gt;QSGNode :: DirtyNodeAdded를&lt;/a&gt; 전달하는 &lt;a href=&quot;qsgnode#markDirty&quot;&gt;markDirty&lt;/a&gt; ()를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="f5159374a0ef222171b09e544dd69bd5a533dfbf" translate="yes" xml:space="preserve">
          <source>The scene graph offers two methods for integrating OpenGL content: by calling OpenGL commands directly and by creating a textured node in the scene graph.</source>
          <target state="translated">장면 그래프는 OpenGL 컨텐츠를 통합하는 두 가지 방법을 제공합니다. OpenGL 명령을 직접 호출하고 장면 그래프에서 텍스처 노드를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="0730940a649c4a4bd872c62051369688c91d9e4c" translate="yes" xml:space="preserve">
          <source>The scene graph renderer in the D3D12 adaptation currently doesn't perform any batching. This is less of an issue, unlike OpenGL, because state changes don't present any problems in the first place. The simpler renderer logic can also lead to lower CPU overhead in some cases. The trade-offs between the various approaches are currently under research.</source>
          <target state="translated">D3D12 적응의 장면 그래프 렌더러는 현재 배치를 수행하지 않습니다. 상태 변경은 처음에는 아무런 문제가 없으므로 OpenGL과 달리 문제가되지 않습니다. 더 간단한 렌더러 로직은 경우에 따라 CPU 오버 헤드를 낮출 수도 있습니다. 다양한 접근법들 사이의 상충 관계는 현재 연구 중이다.</target>
        </trans-unit>
        <trans-unit id="32912754bebe83c7f023036ae323e182e9b11c87" translate="yes" xml:space="preserve">
          <source>The scene graph supports two types of antialiasing. By default, primitives such as rectangles and images will be antialiased by adding more vertices along the edge of the primitives so that the edges fade to transparent. We call this method</source>
          <target state="translated">장면 그래프는 두 가지 유형의 앤티 앨리어싱을 지원합니다. 기본적으로 사각형 및 이미지와 같은 기본 요소는 기본 요소의 가장자리를 따라 더 많은 정점을 추가하여 가장자리가 투명 해 지도록 앤티 앨리어싱됩니다. 우리는이 방법을 호출</target>
        </trans-unit>
        <trans-unit id="4ca5e18a8ee70f4cc8cb6f5cf84ec0a9f1390a88" translate="yes" xml:space="preserve">
          <source>The scene graph used for rendering in &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-qmlmodule.html&quot;&gt;QtQuick&lt;/a&gt; 2 allows highly dynamic, animated user interfaces to be rendered fluidly at 60 FPS. There are some things which can dramatically decrease rendering performance, however, and developers should be careful to avoid these pitfalls wherever possible.</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-qmlmodule.html&quot;&gt;QtQuick&lt;/a&gt; 2 에서 렌더링에 사용되는 장면 그래프를 통해 60FPS에서 매우 역동적 인 애니메이션 사용자 인터페이스를 유동적으로 렌더링 할 수 있습니다. 렌더링 성능을 크게 저하시킬 수있는 몇 가지 사항이 있지만 개발자는 가능한 한 이러한 함정을 피하도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="74bc8a578c58450a866ceb5169a1b666544d0fdb" translate="yes" xml:space="preserve">
          <source>The scene graph uses heuristics to figure out how large the atlas should be and what the size threshold for being entered into the atlas is. If different values are needed, it is possible to override them using the environment variables &lt;code&gt;QSG_ATLAS_WIDTH=[width]&lt;/code&gt;, &lt;code&gt;QSG_ATLAS_HEIGHT=[height]&lt;/code&gt; and &lt;code&gt;QSG_ATLAS_SIZE_LIMIT=[size]&lt;/code&gt;. Changing these values will mostly be interesting for platform vendors.</source>
          <target state="translated">장면 그래프는 휴리스틱을 사용하여 아틀라스의 크기와 아틀라스에 입력하기위한 크기 임계 값을 파악합니다. 다른 값이 필요한 경우 환경 변수 &lt;code&gt;QSG_ATLAS_WIDTH=[width]&lt;/code&gt; , &lt;code&gt;QSG_ATLAS_HEIGHT=[height]&lt;/code&gt; 및 &lt;code&gt;QSG_ATLAS_SIZE_LIMIT=[size]&lt;/code&gt; 를 사용하여 값을 대체 할 수 있습니다 . 이러한 값을 변경하는 것은 플랫폼 공급 업체에게 주로 흥미로운 일입니다.</target>
        </trans-unit>
        <trans-unit id="a21dc2b647ad1bebc75814899d5a687105e57f2a" translate="yes" xml:space="preserve">
          <source>The scene graph uses the OpenGL context and will both rely on and clobber its state. When mixing raw OpenGL commands with scene graph rendering, this function provides a convenient way of resetting the OpenGL context state back to its default values.</source>
          <target state="translated">장면 그래프는 OpenGL 컨텍스트를 사용하며 해당 상태에 의존하고 클로버합니다. 원시 OpenGL 명령을 장면 그래프 렌더링과 혼합 할 때이 함수는 OpenGL 컨텍스트 상태를 기본값으로 재설정하는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bd844a57ce83ff2ff678ae4e7cf8e850d9e3d250" translate="yes" xml:space="preserve">
          <source>The scene graph will often try to find materials that have the same or at least similar state so that these can be batched together inside the renderer, which gives better performance. To specify sortable material states, use &lt;a href=&quot;qsgsimplematerialshader#QSG_DECLARE_SIMPLE_COMPARABLE_SHADER&quot;&gt;QSG_DECLARE_SIMPLE_COMPARABLE_SHADER&lt;/a&gt; instead of &lt;a href=&quot;qsgsimplematerialshader#QSG_DECLARE_SIMPLE_SHADER&quot;&gt;QSG_DECLARE_SIMPLE_SHADER&lt;/a&gt;. The state struct must then also define the function:</source>
          <target state="translated">장면 그래프는 종종 렌더러 내에서 함께 배치되어 더 나은 성능을 제공 할 수 있도록 동일하거나 적어도 유사한 상태의 재질을 찾으려고합니다. 정렬 가능한 재료 상태를 지정하려면 &lt;a href=&quot;qsgsimplematerialshader#QSG_DECLARE_SIMPLE_COMPARABLE_SHADER&quot;&gt;QSG_DECLARE_SIMPLE_SHADER&lt;/a&gt; 대신 QSG_DECLARE_SIMPLE_COMPARABLE_SHADER 를 사용 &lt;a href=&quot;qsgsimplematerialshader#QSG_DECLARE_SIMPLE_SHADER&quot;&gt;하십시오&lt;/a&gt; . 상태 구조체는 다음 함수도 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="73d3765887e51113a92f7d13cf138f154f54195e" translate="yes" xml:space="preserve">
          <source>The scene point at the center of the view is used as the anchor.</source>
          <target state="translated">뷰 중앙의 장면 포인트가 앵커로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6d940fcd2d063c65edd14f6e3887e0e92ab6aad6" translate="yes" xml:space="preserve">
          <source>The scene position is the position in &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; coordinates if the &lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent&lt;/a&gt; is handled by a QGraphicsItem::touchEvent() reimplementation, and identical to the screen position for widgets.</source>
          <target state="translated">장면 위치는 &lt;a href=&quot;qtouchevent&quot;&gt;QTouchEvent&lt;/a&gt; 가 QGraphicsItem :: touchEvent () 재 구현에 의해 처리되고 위젯의 화면 위치와 동일한 경우 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 좌표의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="493ce714e7fd2d3d647c6a05bdb0abc209b0830c" translate="yes" xml:space="preserve">
          <source>The scene rectangle defines the extent of the scene, and in the view's case, this means the area of the scene that you can navigate using the scroll bars.</source>
          <target state="translated">장면 사각형은 장면의 범위를 정의하며 뷰의 경우 스크롤 막대를 사용하여 탐색 할 수있는 장면 영역을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ca8c30145c0f044229a1203a2eed333a9216a630" translate="yes" xml:space="preserve">
          <source>The scene rectangle defines the extent of the scene. It is primarily used by &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; to determine the view's default scrollable area, and by &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; to manage item indexing.</source>
          <target state="translated">장면 사각형은 장면의 범위를 정의합니다. 주로 &lt;a href=&quot;qgraphicsview&quot;&gt;QGraphicsView&lt;/a&gt; 에서보기의 기본 스크롤 가능 영역을 결정하고 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 에서 항목 인덱싱을 관리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="14e679e1910e0d48c0ece84eaa0dbc19143ad44a" translate="yes" xml:space="preserve">
          <source>The scene represents the base coordinate system for all its items. The scene coordinate system describes the position of each top-level item, and also forms the basis for all scene events delivered to the scene from the view. Each item on the scene has a scene position and bounding rectangle (&lt;a href=&quot;qgraphicsitem#scenePos&quot;&gt;QGraphicsItem::scenePos&lt;/a&gt;(), &lt;a href=&quot;qgraphicsitem#sceneBoundingRect&quot;&gt;QGraphicsItem::sceneBoundingRect&lt;/a&gt;()), in addition to its local item pos and bounding rectangle. The scene position describes the item's position in scene coordinates, and its scene bounding rect forms the basis for how &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; determines what areas of the scene have changed. Changes in the scene are communicated through the &lt;a href=&quot;qgraphicsscene#changed&quot;&gt;QGraphicsScene::changed&lt;/a&gt;() signal, and the argument is a list of scene rectangles.</source>
          <target state="translated">장면은 모든 항목의 기본 좌표계를 나타냅니다. 장면 좌표계는 각 최상위 항목의 위치를 ​​설명하고보기에서 장면으로 전달되는 모든 장면 이벤트의 기초를 형성합니다. 장면의 각 항목에는 로컬 항목 위치 및 경계 사각형 외에 장면 위치 및 경계 사각형 ( &lt;a href=&quot;qgraphicsitem#scenePos&quot;&gt;QGraphicsItem :: scenePos&lt;/a&gt; (), &lt;a href=&quot;qgraphicsitem#sceneBoundingRect&quot;&gt;QGraphicsItem :: sceneBoundingRect&lt;/a&gt; ())이 있습니다. 장면 위치는 장면 좌표에서 항목의 위치를 ​​설명하고 장면 경계 사각형은 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 이 장면의 어떤 영역이 변경되었는지를 결정 하는 기준을 형성합니다 . 장면의 변경 사항은 &lt;a href=&quot;qgraphicsscene#changed&quot;&gt;QGraphicsScene :: changed&lt;/a&gt; () 신호를 통해 전달되며 인수는 장면 사각형의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="faf265453acfa34c6e03d0501fbdb23a4e546b5d" translate="yes" xml:space="preserve">
          <source>The scene sends the event to the first &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; under the mouse cursor that accepts drops; a graphics item is set to accept drops with &lt;a href=&quot;qgraphicsitem#setAcceptDrops&quot;&gt;setAcceptDrops()&lt;/a&gt;.</source>
          <target state="translated">장면 은 드롭을 허용하는 마우스 커서 아래의 첫 번째 &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 으로 이벤트를 보냅니다 . 그래픽 항목은 &lt;a href=&quot;qgraphicsitem#setAcceptDrops&quot;&gt;setAcceptDrops ()를 사용&lt;/a&gt; 하여 드랍을 허용하도록 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="b90f80f12389caec0864fb23ccc5c35faf653fd2" translate="yes" xml:space="preserve">
          <source>The scene serves as a container for &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; objects. Items are added to the scene by calling &lt;a href=&quot;qgraphicsscene#addItem&quot;&gt;QGraphicsScene::addItem&lt;/a&gt;(), and then retrieved by calling one of the many item discovery functions. &lt;a href=&quot;qgraphicsscene#items&quot;&gt;QGraphicsScene::items&lt;/a&gt;() and its overloads return all items contained by or intersecting with a point, a rectangle, a polygon or a general vector path. &lt;a href=&quot;qgraphicsscene#itemAt&quot;&gt;QGraphicsScene::itemAt&lt;/a&gt;() returns the topmost item at a particular point. All item discovery functions return the items in descending stacking order (i.e., the first returned item is topmost, and the last item is bottom-most).</source>
          <target state="translated">장면은 &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; 객체 의 컨테이너 역할을 합니다. &lt;a href=&quot;qgraphicsscene#addItem&quot;&gt;QGraphicsScene :: addItem&lt;/a&gt; () 을 호출하여 장면에 항목을 추가 한 다음 많은 항목 검색 기능 중 하나를 호출하여 검색합니다. &lt;a href=&quot;qgraphicsscene#items&quot;&gt;QGraphicsScene :: items&lt;/a&gt; () 및 해당 과부하는 점, 사각형, 다각형 또는 일반 벡터 경로에 포함되거나 그와 교차하는 모든 항목을 반환합니다. &lt;a href=&quot;qgraphicsscene#itemAt&quot;&gt;QGraphicsScene :: itemAt&lt;/a&gt; ()는 특정 지점에서 최상위 항목을 반환합니다. 모든 항목 검색 기능은 항목을 내림차순으로 내림차순으로 반환합니다 (즉, 첫 번째로 반환 된 항목이 맨 위이고 마지막 항목이 맨 아래에 있음).</target>
        </trans-unit>
        <trans-unit id="feb5e420ae4b761c7f72b4e5dbb74bc87634de18" translate="yes" xml:space="preserve">
          <source>The scene's bounding rect is set by calling &lt;a href=&quot;qgraphicsscene#sceneRect-prop&quot;&gt;setSceneRect&lt;/a&gt;(). Items can be placed at any position on the scene, and the size of the scene is by default unlimited. The scene rect is used only for internal bookkeeping, maintaining the scene's item index. If the scene rect is unset, &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; will use the bounding area of all items, as returned by &lt;a href=&quot;qgraphicsscene#itemsBoundingRect&quot;&gt;itemsBoundingRect&lt;/a&gt;(), as the scene rect. However, &lt;a href=&quot;qgraphicsscene#itemsBoundingRect&quot;&gt;itemsBoundingRect&lt;/a&gt;() is a relatively time consuming function, as it operates by collecting positional information for every item on the scene. Because of this, you should always set the scene rect when operating on large scenes.</source>
          <target state="translated">장면의 경계 &lt;a href=&quot;qgraphicsscene#sceneRect-prop&quot;&gt;사각형은 setSceneRect&lt;/a&gt; () 를 호출하여 설정됩니다 . 항목은 장면의 어느 위치 에나 배치 할 수 있으며 장면의 크기는 기본적으로 무제한입니다. 장면 rect는 장면의 항목 인덱스를 유지하면서 내부 부기에만 사용됩니다. 장면 rect가 설정되어 있지 않으면 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 은 &lt;a href=&quot;qgraphicsscene#itemsBoundingRect&quot;&gt;itemsBoundingRect&lt;/a&gt; ()에 의해 반환 된 모든 항목의 경계 영역을 장면 rect로 사용합니다. 그러나 &lt;a href=&quot;qgraphicsscene#itemsBoundingRect&quot;&gt;itemsBoundingRect&lt;/a&gt; ()는 장면의 모든 항목에 대한 위치 정보를 수집하여 작동하므로 상대적으로 시간이 많이 걸리는 기능입니다. 이 때문에 큰 장면에서 작업 할 때는 항상 장면을 rect로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf44509ce4eff91ea4d1d9a0c82ce331c9190820" translate="yes" xml:space="preserve">
          <source>The scheme can also be empty, in which case the URL is interpreted as relative.</source>
          <target state="translated">스킴은 비어있을 수 있으며이 경우 URL은 상대로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="e6aaa5284a07d7e3032c5af3e0ce360264fefa0d" translate="yes" xml:space="preserve">
          <source>The scheme can only contain US-ASCII letters or digits, which means it cannot contain any character that would otherwise require encoding. Additionally, schemes are always returned in lowercase form.</source>
          <target state="translated">이 체계는 US-ASCII 문자 나 숫자 만 포함 할 수 있으므로 인코딩이 필요한 문자를 포함 할 수 없습니다. 또한 체계는 항상 소문자 형식으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4f936343d9419d2ee94994ec47eb20be29408955" translate="yes" xml:space="preserve">
          <source>The scheme describes the type (or protocol) of the URL. It's represented by one or more ASCII characters at the start the URL.</source>
          <target state="translated">체계는 URL의 유형 (또는 프로토콜)을 설명합니다. URL 시작시 하나 이상의 ASCII 문자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="55bb1521ab34a320795b09d7534d3fef0f762a54" translate="yes" xml:space="preserve">
          <source>The scheme is removed from the URL.</source>
          <target state="translated">URL에서 구성표가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="d88de68ed0ef54a66fcf408a9359ef0bf1ce3b98" translate="yes" xml:space="preserve">
          <source>The scope for customizing the painting behavior of standard Qt widgets, without resorting to subclassing, is slightly less than that possible for custom widgets. Usually, the desired appearance of a standard widget can be achieved by setting its &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;autoFillBackground&lt;/a&gt; property.</source>
          <target state="translated">서브 클래 싱에 의존하지 않고 표준 Qt 위젯의 페인팅 동작을 사용자 정의하는 범위는 사용자 정의 위젯에서 가능한 것보다 약간 작습니다. 일반적으로 &lt;a href=&quot;qwidget#autoFillBackground-prop&quot;&gt;autoFillBackground&lt;/a&gt; 속성 을 설정하여 표준 위젯의 원하는 모양을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c2d3c118939966273c2a57e29638f371d385719" translate="yes" xml:space="preserve">
          <source>The scope in the above snippet modifies the build target in each mode to ensure that the resulting targets have different names. Providing different names for targets ensures that one will not overwrite the other.</source>
          <target state="translated">위 스 니펫의 범위는 각 모드에서 빌드 대상을 수정하여 결과 대상이 다른 이름을 갖도록합니다. 대상에 다른 이름을 제공하면 한 대상이 다른 대상을 덮어 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1cf757056e0c0649131bcbcd5247e19be67fd4d1" translate="yes" xml:space="preserve">
          <source>The scope is &lt;a href=&quot;qsettings#Scope-enum&quot;&gt;QSettings::UserScope&lt;/a&gt; and the format is &lt;a href=&quot;qsettings#defaultFormat&quot;&gt;defaultFormat&lt;/a&gt;() (&lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings::NativeFormat&lt;/a&gt; by default). Use &lt;a href=&quot;qsettings#setDefaultFormat&quot;&gt;setDefaultFormat&lt;/a&gt;() before calling this constructor to change the default format used by this constructor.</source>
          <target state="translated">범위는 &lt;a href=&quot;qsettings#Scope-enum&quot;&gt;QSettings :: UserScope&lt;/a&gt; 이며 형식은 &lt;a href=&quot;qsettings#defaultFormat&quot;&gt;defaultFormat&lt;/a&gt; ()입니다 ( 기본적으로 &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings :: NativeFormat&lt;/a&gt; ). 이 생성자가 호출하기 전에 &lt;a href=&quot;qsettings#setDefaultFormat&quot;&gt;setDefaultFormat&lt;/a&gt; ()을 사용 하여이 생성자가 사용하는 기본 형식을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="e82b8abbaa5c8494f2cb29a0f4748e568ee59c76" translate="yes" xml:space="preserve">
          <source>The scope is set to &lt;a href=&quot;qsettings#Scope-enum&quot;&gt;QSettings::UserScope&lt;/a&gt;, and the format is set to &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings::NativeFormat&lt;/a&gt; (i.e. calling &lt;a href=&quot;qsettings#setDefaultFormat&quot;&gt;setDefaultFormat&lt;/a&gt;() before calling this constructor has no effect).</source>
          <target state="translated">범위는 &lt;a href=&quot;qsettings#Scope-enum&quot;&gt;QSettings :: UserScope&lt;/a&gt; 로 설정되고 형식은 &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings :: NativeFormat으로&lt;/a&gt; 설정됩니다 (즉, 이 생성자를 호출하기 전에 &lt;a href=&quot;qsettings#setDefaultFormat&quot;&gt;setDefaultFormat&lt;/a&gt; ()을 호출해도 효과가 없습니다).</target>
        </trans-unit>
        <trans-unit id="7468e7a6014216341825e17c83669985adb85d95" translate="yes" xml:space="preserve">
          <source>The screen is inherited from the parent.</source>
          <target state="translated">화면은 부모에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="97c635e02dec3e851595e6147c97f20f8dd4ed86" translate="yes" xml:space="preserve">
          <source>The screen orientation represents the physical orientation of the display. For example, the screen orientation of a mobile device will change based on how it is being held. A change to the orientation might or might not trigger a change to the primary orientation of the screen.</source>
          <target state="translated">화면 방향은 디스플레이의 물리적 방향을 나타냅니다. 예를 들어, 모바일 장치의 화면 방향은 개최 방법에 따라 변경됩니다. 방향을 변경하면 화면의 기본 방향이 변경되거나 트리거되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0433db79b0f7ea1e7269ab13c3208af1ab81f23c" translate="yes" xml:space="preserve">
          <source>The screen with which the window is associated.</source>
          <target state="translated">창이 연관된 화면.</target>
        </trans-unit>
        <trans-unit id="3bb3c3f495d57057a0c7e87148e895ec1b64f69d" translate="yes" xml:space="preserve">
          <source>The screen-occupation state of the window.</source>
          <target state="translated">창의 화면 점유 상태입니다.</target>
        </trans-unit>
        <trans-unit id="fe445e6fe630f99384b773302b09e136ca6a48dc" translate="yes" xml:space="preserve">
          <source>The screens orientation has changes (&lt;a href=&quot;qscreenorientationchangeevent&quot;&gt;QScreenOrientationChangeEvent&lt;/a&gt;).</source>
          <target state="translated">화면 방향이 변경되었습니다 ( &lt;a href=&quot;qscreenorientationchangeevent&quot;&gt;QScreenOrientationChangeEvent&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bd626704a3311b9efe2e898c51ecde0aa557e1ed" translate="yes" xml:space="preserve">
          <source>The screenshot below shows the breakdown of a basic user interface designed using a grid. The coordinates on the screenshot show the position of each widget within the grid.</source>
          <target state="translated">아래 스크린 샷은 그리드를 사용하여 설계된 기본 사용자 인터페이스의 분석을 보여줍니다. 스크린 샷의 좌표는 그리드 내 각 위젯의 위치를 ​​보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6c640b9d90bc351fb6570639fc92baf6e714f606" translate="yes" xml:space="preserve">
          <source>The screenshot on the left shows a plain &lt;a href=&quot;qsqltablemodel&quot;&gt;QSqlTableModel&lt;/a&gt; in a &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;. Foreign keys (&lt;code&gt;city&lt;/code&gt; and &lt;code&gt;country&lt;/code&gt;) aren't resolved to human-readable values. The screenshot on the right shows a &lt;a href=&quot;qsqlrelationaltablemodel&quot;&gt;QSqlRelationalTableModel&lt;/a&gt;, with foreign keys resolved into human-readable text strings.</source>
          <target state="translated">왼쪽 쇼의 스크린 샷 일반 &lt;a href=&quot;qsqltablemodel&quot;&gt;QSqlTableModel&lt;/a&gt; A의 &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt; . 외래 키 ( &lt;code&gt;city&lt;/code&gt; 및 &lt;code&gt;country&lt;/code&gt; )는 사람이 읽을 수있는 값으로 해석되지 않습니다. 오른쪽의 스크린 샷은 외래 키를 사람이 읽을 수있는 텍스트 문자열로 &lt;a href=&quot;qsqlrelationaltablemodel&quot;&gt;확인한 QSqlRelationalTableModel을&lt;/a&gt; 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="5c6bd966a06f6a2b55f66a745cf7dd9571a41f35" translate="yes" xml:space="preserve">
          <source>The script can execute code and is connected so that it can handle events</source>
          <target state="translated">스크립트는 코드를 실행할 수 있고 이벤트를 처리 할 수 ​​있도록 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="20c4a9f45dbea7c04b698f8d64d4c08b4a6fc5e4" translate="yes" xml:space="preserve">
          <source>The script can execute code, but does not yet handle events</source>
          <target state="translated">스크립트는 코드를 실행할 수 있지만 아직 이벤트를 처리하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="89f79789f606f654a461bf98c7d7662a724d58dd" translate="yes" xml:space="preserve">
          <source>The script code will be evaluated in the context of the global object.</source>
          <target state="translated">스크립트 코드는 전역 객체의 컨텍스트에서 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="8ca21b31af718151d11d0c7d0580239f959acf7b" translate="yes" xml:space="preserve">
          <source>The script engine used is determined from the file's extension. By default &quot;.js&quot; files are interpreted as JScript files, and &quot;.vbs&quot; and &quot;.dsm&quot; files are interpreted as VBScript. Additional script engines can be registered using &lt;a href=&quot;qaxscriptmanager#registerEngine&quot;&gt;registerEngine&lt;/a&gt;().</source>
          <target state="translated">사용 된 스크립트 엔진은 파일 확장자에 따라 결정됩니다. 기본적으로 &quot;.js&quot;파일은 JScript 파일로 해석되고 &quot;.vbs&quot;및 &quot;.dsm&quot;파일은 VBScript로 해석됩니다. &lt;a href=&quot;qaxscriptmanager#registerEngine&quot;&gt;registerEngine&lt;/a&gt; ()을 사용하여 추가 스크립트 엔진을 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01d48bc106daf312c26b8330f6da6701a25e22e4" translate="yes" xml:space="preserve">
          <source>The script engine will be used when loading files with the given</source>
          <target state="translated">주어진 파일을로드 할 때 스크립트 엔진이 사용됩니다</target>
        </trans-unit>
        <trans-unit id="52d511d98ad324361603795d979a18e2afbada60" translate="yes" xml:space="preserve">
          <source>The script has been closed.</source>
          <target state="translated">스크립트가 닫혔습니다.</target>
        </trans-unit>
        <trans-unit id="4b2f190fb55cfe75925623e58522a31af0f551cf" translate="yes" xml:space="preserve">
          <source>The script has been created, but not yet initialized</source>
          <target state="translated">스크립트가 작성되었지만 아직 초기화되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="50ea86efb19eeb4baf46fbce374b72fa267be8ff" translate="yes" xml:space="preserve">
          <source>The script has been initialized, but is not running</source>
          <target state="translated">스크립트가 초기화되었지만 실행되고 있지 않습니다</target>
        </trans-unit>
        <trans-unit id="6a93312b0c43268af263f87da3fb3a8b70c0c714" translate="yes" xml:space="preserve">
          <source>The script is loaded, but is not connected to event sources</source>
          <target state="translated">스크립트가로드되었지만 이벤트 소스에 연결되지 않았습니다</target>
        </trans-unit>
        <trans-unit id="e071d098280a0b3c3227958571040210bdd74547" translate="yes" xml:space="preserve">
          <source>The script provides &lt;a href=&quot;qaxscript#scriptEngine&quot;&gt;scriptEngine&lt;/a&gt;() provides feedback to the application through signals. The most important signal is the &lt;a href=&quot;qaxscript#error&quot;&gt;error&lt;/a&gt;() signal. Direct access to the &lt;a href=&quot;qaxscriptengine&quot;&gt;QAxScriptEngine&lt;/a&gt; is provided through the &lt;a href=&quot;qaxscript#scriptEngine&quot;&gt;scriptEngine&lt;/a&gt;() function.</source>
          <target state="translated">스크립트는 &lt;a href=&quot;qaxscript#scriptEngine&quot;&gt;scriptEngine&lt;/a&gt; ()을 제공하여 신호를 통해 애플리케이션에 피드백을 제공합니다. 가장 중요한 신호는 &lt;a href=&quot;qaxscript#error&quot;&gt;오류&lt;/a&gt; () 신호입니다. &lt;a href=&quot;qaxscriptengine&quot;&gt;QAxScriptEngine에&lt;/a&gt; 대한 직접 액세스 는 &lt;a href=&quot;qaxscript#scriptEngine&quot;&gt;scriptEngine&lt;/a&gt; () 함수를 통해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a9c3f3a69299b4715b39f0caddfe667d4bf188b" translate="yes" xml:space="preserve">
          <source>The script will be executed as soon as the document is created. This is not suitable for any DOM operation.</source>
          <target state="translated">문서가 생성 되 자마자 스크립트가 실행됩니다. 이것은 모든 DOM 작업에 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6514e1b825f4cbe96d69a069419ecaa4262c498e" translate="yes" xml:space="preserve">
          <source>The script will run as soon as the DOM is ready. This is equivalent to the &lt;code&gt;DOMContentLoaded&lt;/code&gt; event firing in JavaScript.</source>
          <target state="translated">DOM이 준비 되 자마자 스크립트가 실행됩니다. 이것은 JavaScript에서 &lt;code&gt;DOMContentLoaded&lt;/code&gt; 이벤트 발생 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e58d96605eabb6534beb4fbd671d63dda3ff8317" translate="yes" xml:space="preserve">
          <source>The script will run in the same</source>
          <target state="translated">스크립트는 동일하게 실행됩니다</target>
        </trans-unit>
        <trans-unit id="1dcb36c75d814f57c89a2fb24247f51d5c7d27fa" translate="yes" xml:space="preserve">
          <source>The script will run when the page load finishes, or 500 ms after the document is ready, whichever comes first.</source>
          <target state="translated">스크립트는 페이지로드가 완료 될 때 또는 문서가 준비된 후 500ms 중 빠른 시간에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="15026690856d93a3e48ff369ba1670acb146ec0a" translate="yes" xml:space="preserve">
          <source>The script will run when the page load finishes, or 500ms after the document is ready, whichever comes first.</source>
          <target state="translated">스크립트는 페이지로드가 완료 될 때 또는 문서가 준비된 후 500ms 중 빠른 시간에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f5b95dd2c907ac3cad6780ba37c72c7c34652bab" translate="yes" xml:space="preserve">
          <source>The scroll area is currently following the touch point or mouse.</source>
          <target state="translated">스크롤 영역이 현재 터치 포인트 또는 마우스를 따르고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a355063775512859b973385737c1a49c46579730" translate="yes" xml:space="preserve">
          <source>The scroll area is moving on it's own.</source>
          <target state="translated">스크롤 영역이 자체적으로 움직입니다.</target>
        </trans-unit>
        <trans-unit id="5c56f1d856db7f65871b759f2b727c6de0bbf1d6" translate="yes" xml:space="preserve">
          <source>The scroll area will adjust to its viewport the first time it is shown.</source>
          <target state="translated">스크롤 영역은 처음 표시 될 때 뷰포트에 맞게 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="4903a40c5e6e4739030e9eee6c35f3fdfbf0151a" translate="yes" xml:space="preserve">
          <source>The scroll area will always adjust to the viewport</source>
          <target state="translated">스크롤 영역은 항상 뷰포트에 맞게 조정됩니다</target>
        </trans-unit>
        <trans-unit id="cfe63ddce05b0d44242749c47cad18765de71999" translate="yes" xml:space="preserve">
          <source>The scroll area will behave like before - and not do any adjust.</source>
          <target state="translated">스크롤 영역은 이전과 같이 작동하며 조정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4575f7e8b6dbe7c72a22198fddcd9aba79688990" translate="yes" xml:space="preserve">
          <source>The scroll bar is always shown.</source>
          <target state="translated">스크롤 막대가 항상 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="32ea78c39c4af6aca1439aa5e2a81e7c5c145893" translate="yes" xml:space="preserve">
          <source>The scroll bar is horizontal.</source>
          <target state="translated">스크롤 바가 수평입니다.</target>
        </trans-unit>
        <trans-unit id="b1eae49ec44af155b6a56289bfb30944473e429a" translate="yes" xml:space="preserve">
          <source>The scroll bar is never shown.</source>
          <target state="translated">스크롤 막대는 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9866ddbea8bad9083492e2ee4813b104fac3102d" translate="yes" xml:space="preserve">
          <source>The scroll bar is only shown when the content is too large to fit.</source>
          <target state="translated">스크롤 막대는 내용이 너무 커서 적합하지 않은 경우에만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0847d6f35a7bbacb0918990830471a78b061c92c" translate="yes" xml:space="preserve">
          <source>The scroll bar widget will be resized to fit the scroll bar geometry for the current style. The following describes the case for scroll bar widgets on the horizontal scroll bar:</source>
          <target state="translated">스크롤 막대 위젯은 현재 스타일의 스크롤 막대 형상에 맞게 크기가 조정됩니다. 다음은 가로 스크롤 막대에서 스크롤 막대 위젯의 경우를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="75237c60b3c8e5d3c4ccd0cc8d5b4deddf37c8d2" translate="yes" xml:space="preserve">
          <source>The scroll bars and viewport should be updated whenever the viewport receives a resize event or the size of the contents changes. The viewport also needs to be updated when the scroll bars values change. The initial values of the scroll bars are often set when the area receives new contents.</source>
          <target state="translated">스크롤 막대와 뷰포트는 뷰포트가 resize 이벤트를 받거나 내용의 크기가 변경 될 때마다 업데이트되어야합니다. 스크롤 막대 값이 변경되면 뷰포트도 업데이트해야합니다. 스크롤 막대의 초기 값은 영역에 새 내용이 수신 될 때 종종 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b24198ff87497274345992cdc195fd152406da6a" translate="yes" xml:space="preserve">
          <source>The scroll bars appearance depends on the currently set &lt;a href=&quot;qt#ScrollBarPolicy-enum&quot;&gt;scroll bar policies&lt;/a&gt;. You can control the appearance of the scroll bars using the inherited functionality from &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt;.</source>
          <target state="translated">스크롤 막대 모양은 현재 설정된 &lt;a href=&quot;qt#ScrollBarPolicy-enum&quot;&gt;스크롤 막대 정책&lt;/a&gt; 에 따라 다릅니다 . &lt;a href=&quot;qabstractscrollarea&quot;&gt;QAbstractScrollArea&lt;/a&gt; 의 상속 된 기능을 사용하여 스크롤 막대의 모양을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4fde453d497daca3a94add05aa03065d82ce6ff0" translate="yes" xml:space="preserve">
          <source>The scroll event is sent to indicate that the receiver should be scrolled. Usually the receiver should be something visual like &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; or &lt;a href=&quot;qgraphicsobject&quot;&gt;QGraphicsObject&lt;/a&gt;.</source>
          <target state="translated">스크롤 이벤트는 수신자가 스크롤되어야 함을 표시하기 위해 전송됩니다. 일반적으로 수신자는 &lt;a href=&quot;qwidget&quot;&gt;QWidget&lt;/a&gt; 또는 &lt;a href=&quot;qgraphicsobject&quot;&gt;QGraphicsObject&lt;/a&gt; 와 같은 시각적이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="b0f14badd14a1c35bf3fce0719cedf62a246cdfc" translate="yes" xml:space="preserve">
          <source>The scroll prepare event is sent before scrolling (usually by &lt;a href=&quot;qscroller&quot;&gt;QScroller&lt;/a&gt;) is started. The object receiving this event should set &lt;a href=&quot;qscrollprepareevent#viewportSize&quot;&gt;viewportSize&lt;/a&gt;, maxContentPos and &lt;a href=&quot;qscrollprepareevent#contentPos&quot;&gt;contentPos&lt;/a&gt;. It also should accept this event to indicate that scrolling should be started.</source>
          <target state="translated">스크롤 준비 이벤트는 스크롤 (일반적으로 &lt;a href=&quot;qscroller&quot;&gt;QScroller에&lt;/a&gt; 의해 )이 시작 되기 전에 전송 됩니다. 이 이벤트를받는 객체는 &lt;a href=&quot;qscrollprepareevent#viewportSize&quot;&gt;viewportSize&lt;/a&gt; , maxContentPos 및 &lt;a href=&quot;qscrollprepareevent#contentPos&quot;&gt;contentPos를&lt;/a&gt; 설정해야합니다 . 또한 스크롤이 시작되어야 함을 나타 내기 위해이 이벤트를 승인해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f700b1eb3114f9a9d641cda15f14141d9037508" translate="yes" xml:space="preserve">
          <source>The scrollbar does not snap (default).</source>
          <target state="translated">스크롤바가 스냅되지 않습니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="6b0626ee102076ca6d64a3893d970337d17a6479" translate="yes" xml:space="preserve">
          <source>The scrollbar does not snap while being dragged, but only after released.</source>
          <target state="translated">스크롤하는 동안 스크롤 막대가 스냅되지 않고 해제 된 후에 만 ​​스냅됩니다.</target>
        </trans-unit>
        <trans-unit id="d75380a837ce180f1a298340c984b4310fdf47f6" translate="yes" xml:space="preserve">
          <source>The scrollbar snaps while dragged.</source>
          <target state="translated">스크롤하는 동안 스크롤바가 스냅됩니다.</target>
        </trans-unit>
        <trans-unit id="51ce25c06c1c593a4a769f455dab7076a7fb77ec" translate="yes" xml:space="preserve">
          <source>The scrolled QObjects receive a &lt;a href=&quot;qscrollprepareevent&quot;&gt;QScrollPrepareEvent&lt;/a&gt; whenever the scroller needs to update its geometry information and a &lt;a href=&quot;qscrollevent&quot;&gt;QScrollEvent&lt;/a&gt; whenever the content of the object should actually be scrolled.</source>
          <target state="translated">스크롤 된 QObject 는 스크롤러가 지오메트리 정보를 업데이트해야 할 때마다 &lt;a href=&quot;qscrollevent&quot;&gt;QScrollPrepareEvent&lt;/a&gt; 를, 오브젝트의 내용을 실제로 스크롤해야 할 때마다 &lt;a href=&quot;qscrollprepareevent&quot;&gt;QScrollEvent를&lt;/a&gt; 수신합니다 .</target>
        </trans-unit>
        <trans-unit id="324e1874c091307e6367cf335045e9ce10acf3bf" translate="yes" xml:space="preserve">
          <source>The scroller is not scrolling and nothing is pressed.</source>
          <target state="translated">스크롤러가 스크롤되지 않고 아무 것도 누르지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7b9aae289fa0070a75b6de69f7655c5f00497c58" translate="yes" xml:space="preserve">
          <source>The scroller is styled using the &lt;a href=&quot;#scroller-sub&quot;&gt;::scroller&lt;/a&gt;.</source>
          <target state="translated">스크롤러는 &lt;a href=&quot;#scroller-sub&quot;&gt;:: scroller를&lt;/a&gt; 사용하여 스타일이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f0f1eb7961c13beccd347f4326afd7b0470c121" translate="yes" xml:space="preserve">
          <source>The scroller of a &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; or &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 또는 &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; 의 스크롤러입니다 .</target>
        </trans-unit>
        <trans-unit id="838a9abf3e0559d9416bbb18f7f1bb9511052aab" translate="yes" xml:space="preserve">
          <source>The scroller uses the global &lt;a href=&quot;qabstractanimation&quot;&gt;QAbstractAnimation&lt;/a&gt; timer to generate its QScrollEvents. This can be changed with &lt;a href=&quot;qscrollerproperties#ScrollMetric-enum&quot;&gt;QScrollerProperties::FrameRate&lt;/a&gt; on a per-&lt;a href=&quot;qscroller&quot;&gt;QScroller&lt;/a&gt; basis.</source>
          <target state="translated">스크롤러는 글로벌 &lt;a href=&quot;qabstractanimation&quot;&gt;QAbstractAnimation&lt;/a&gt; 타이머를 사용하여 QScrollEvents를 생성합니다. 이것은 &lt;a href=&quot;qscroller&quot;&gt;QScroller&lt;/a&gt; 마다 &lt;a href=&quot;qscrollerproperties#ScrollMetric-enum&quot;&gt;QScrollerProperties :: FrameRate&lt;/a&gt; 를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6fc0ffd509cf4425b778a5c957aeed073a71ec82" translate="yes" xml:space="preserve">
          <source>The scrolling distance has changed (default).</source>
          <target state="translated">스크롤 거리가 변경되었습니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="e8c3dab5ba7a503e24afda15e7730d9d9e23ccc6" translate="yes" xml:space="preserve">
          <source>The scrolling phase of the event is specified by</source>
          <target state="translated">이벤트의 스크롤 단계는</target>
        </trans-unit>
        <trans-unit id="b2d4cbbda219e97ff86f0052fbe5db1ec4be9862" translate="yes" xml:space="preserve">
          <source>The scrolling speed is calculated so that the given position is reached after a platform-defined time span.</source>
          <target state="translated">스크롤 속도는 플랫폼 정의 시간 범위 이후에 주어진 위치에 도달하도록 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="7d5394e62c42d7ff2caac3ef14d704242a34237b" translate="yes" xml:space="preserve">
          <source>The scrolling speed will be calculated so that the given position will be reached after a platform-defined time span.</source>
          <target state="translated">플랫폼이 정의한 시간 범위 이후에 주어진 위치에 도달 할 수 있도록 스크롤 속도가 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="8293a08961d1041e7b535981b478f783e376ef05" translate="yes" xml:space="preserve">
          <source>The search begins from the</source>
          <target state="translated">검색은</target>
        </trans-unit>
        <trans-unit id="0e1ad895d07c4b12315a8ecff7ef2011d30af440" translate="yes" xml:space="preserve">
          <source>The search context can be of any type storable in a &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;. The value of the search context is not intended to be use directly by applications.</source>
          <target state="translated">검색 컨텍스트는 &lt;a href=&quot;qvariant&quot;&gt;QVariant에&lt;/a&gt; 저장 가능한 모든 유형이 될 수 있습니다 . 검색 컨텍스트의 값은 응용 프로그램에서 직접 사용하기위한 것이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e052c2a96cbd3152ed6f3500f906237cdec06482" translate="yes" xml:space="preserve">
          <source>The search context is used by backends to store additional search context related to the search request. Other relevant fields should also be filled in. For example, if the search context encodes a text search the search term should also be set with &lt;a href=&quot;qplacesearchrequest#setSearchTerm&quot;&gt;setSearchTerm&lt;/a&gt;(). The search context allows additional search context to be kept which is not directly accessible via the Qt Location API.</source>
          <target state="translated">검색 컨텍스트는 백엔드에서 검색 요청과 관련된 추가 검색 컨텍스트를 저장하는 데 사용됩니다. 다른 관련 필드도 채워야합니다. 예를 들어, 검색 컨텍스트가 텍스트 검색을 인코딩하는 경우 검색어도 &lt;a href=&quot;qplacesearchrequest#setSearchTerm&quot;&gt;setSearchTerm&lt;/a&gt; () 으로 설정해야합니다 . 검색 컨텍스트는 Qt Location API를 통해 직접 액세스 할 수없는 추가 검색 컨텍스트를 유지할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="0d1be2cef189b4f280fefc0190ebd5fef310a76b" translate="yes" xml:space="preserve">
          <source>The search is case sensitive.</source>
          <target state="translated">검색은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="6b48e60b739a4c5bb9b82a9c515daa0b37bd08d9" translate="yes" xml:space="preserve">
          <source>The search query has completed, and the results are available.</source>
          <target state="translated">검색 쿼리가 완료되었으며 결과를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd78e7a9db91c8ad3905ac232f4f1e42eb47f242" translate="yes" xml:space="preserve">
          <source>The search result contains a place.</source>
          <target state="translated">검색 결과에 장소가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1896452d88ae43200f3a1b7870d19e9341f357ba" translate="yes" xml:space="preserve">
          <source>The search result contains a proposed search which may be relevant.</source>
          <target state="translated">검색 결과에는 관련성이있는 제안 된 검색이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="74b27135226df0f3dbfacdae328e953263252ec1" translate="yes" xml:space="preserve">
          <source>The search starts at the given</source>
          <target state="translated">검색은 주어진 시간에 시작됩니다</target>
        </trans-unit>
        <trans-unit id="e59793a4f301c870c8c3877d2c82f1e7d5ee9df7" translate="yes" xml:space="preserve">
          <source>The search starts at the position of the given</source>
          <target state="translated">주어진 위치에서 검색이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="e1d1e306770aa84d0d6cd8e5b485ed3e3fcb7a22" translate="yes" xml:space="preserve">
          <source>The search starts at the position of the given from</source>
          <target state="translated">주어진 위치에서 검색이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="7e1859965d8cc3dfe950159c598201e11cfe2aad" translate="yes" xml:space="preserve">
          <source>The search term is contained in the item.</source>
          <target state="translated">검색어가 항목에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a68607b092250deb33062f4bb4fab806db740b9" translate="yes" xml:space="preserve">
          <source>The search term matches as a fixed string.</source>
          <target state="translated">검색어는 고정 문자열로 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7eddbbe6fd6f4140b5460652130cec013c4464b1" translate="yes" xml:space="preserve">
          <source>The search term matches as a regular expression.</source>
          <target state="translated">검색어는 정규식으로 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e0af5cee2d2358ed6e98cfda40e8248cd695e7b1" translate="yes" xml:space="preserve">
          <source>The search term matches exactly (default).</source>
          <target state="translated">검색어가 정확히 일치합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="15f25bd0eee60b1e205843af1497f5e6f8287adc" translate="yes" xml:space="preserve">
          <source>The search term matches the end of the item.</source>
          <target state="translated">검색어가 항목의 끝과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="5ede5b13d4e57852af12c88d235fb3f499a5473e" translate="yes" xml:space="preserve">
          <source>The search term matches the start of the item.</source>
          <target state="translated">검색어가 항목의 시작과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="189bfc317787eed62e871e365864407fc20166e3" translate="yes" xml:space="preserve">
          <source>The search term matches using wildcards.</source>
          <target state="translated">검색어는 와일드 카드를 사용하여 일치합니다.</target>
        </trans-unit>
        <trans-unit id="dc7f1f0ce3958a2c81484683200250e1dd5e6c96" translate="yes" xml:space="preserve">
          <source>The second &lt;code&gt;Text&lt;/code&gt; type uses an id to access the first's text directly. IDs are specified explicitly by the QML programmer so they always take precedence over other property names (except for those in the &lt;a href=&quot;#javascript-scope&quot;&gt;JavaScript Scope&lt;/a&gt;). For example, in the unlikely event that the binding's &lt;a href=&quot;#binding-scope-object&quot;&gt;scope object&lt;/a&gt; had a &lt;code&gt;titletype&lt;/code&gt; property in the previous example, the &lt;code&gt;titletype&lt;/code&gt; id would still take precedence.</source>
          <target state="translated">두 번째 &lt;code&gt;Text&lt;/code&gt; 유형은 id를 사용하여 첫 번째 텍스트에 직접 액세스합니다. ID는 QML 프로그래머가 명시 적으로 지정하므로 항상 다른 특성 이름보다 우선합니다 ( &lt;a href=&quot;#javascript-scope&quot;&gt;JavaScript 범위&lt;/a&gt; 의 경우 제외 ). 예를 들어, 이전 예제에서 바인딩의 &lt;a href=&quot;#binding-scope-object&quot;&gt;범위 객체&lt;/a&gt; 에 &lt;code&gt;titletype&lt;/code&gt; 속성 이있을 가능성은 거의 없지만 &lt;code&gt;titletype&lt;/code&gt; id가 여전히 우선합니다.</target>
        </trans-unit>
        <trans-unit id="a39e45ee5c671cba6edfa331bb40500f96721340" translate="yes" xml:space="preserve">
          <source>The second approach is to handle user events directly by reimplementing &lt;a href=&quot;qabstractitemdelegate#editorEvent&quot;&gt;editorEvent&lt;/a&gt;().</source>
          <target state="translated">두 번째 방법은 &lt;a href=&quot;qabstractitemdelegate#editorEvent&quot;&gt;editorEvent&lt;/a&gt; () 를 다시 구현하여 사용자 이벤트를 직접 처리하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="2cd4877ab7a6785fff7c1e32f81ef325568c8af5" translate="yes" xml:space="preserve">
          <source>The second argument is the name of the page being referenced. The second argument is actually optional, for example if you are using a topicref as a container for other topicrefs and maprefs. It is also optional if you want qdoc to find the page name for you by looking up the title in its internal data structure. It is recommended that you provide the second parameter if you know the page name.</source>
          <target state="translated">두 번째 인수는 참조중인 페이지의 이름입니다. 예를 들어, topicref를 다른 topicref 및 mapref의 컨테이너로 사용하는 경우 두 번째 인수는 실제로 선택 사항입니다. 내부 데이터 구조에서 제목을 찾아서 qdoc이 페이지 이름을 찾도록하려면 선택 사항입니다. 페이지 이름을 알고있는 경우 두 번째 매개 변수를 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0431539a45a3165b712decf353de082bef002c31" translate="yes" xml:space="preserve">
          <source>The second case is explained by example. Suppose you want to populate a list widget with the values of certain attributes from a set of result elements. You could write an &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; to return the set of elements, and then you would write the code to iterate over the result elements, get their attributes, and extract the desired string values. But the simpler way is to just augment your &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; to finding the desired attribute values. Then all you have to do is evaluate the &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; using the version of &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery::evaluateTo&lt;/a&gt;() that populates a &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt;, which you can send directly to your widget.</source>
          <target state="translated">두 번째 경우는 예를 들어 설명합니다. 결과 요소 세트의 특정 속성 값으로 목록 위젯을 채우려 고한다고 가정하십시오. &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 를 작성하여 요소 세트를 리턴 한 다음 결과 요소를 반복하고 해당 속성을 가져오고 원하는 문자열 값을 추출하는 코드를 작성할 수 있습니다. 그러나 가장 간단한 방법은 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 를 보강하여 원하는 속성 값을 찾는 것입니다. 그런 다음 &lt;a href=&quot;qstringlist&quot;&gt;QStringList&lt;/a&gt; 를 채우는 &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery :: evaluateTo&lt;/a&gt; () 버전을 사용 하여 &lt;a href=&quot;xmlprocessing#&quot;&gt;XQuery&lt;/a&gt; 를 평가하기 만하면 위젯에 직접 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe50d52a542c71e9f540338690eae571cd5d2eb2" translate="yes" xml:space="preserve">
          <source>The second element in the pair.</source>
          <target state="translated">쌍의 두 번째 요소.</target>
        </trans-unit>
        <trans-unit id="3496dceb93420817b0445619c900783688879a3d" translate="yes" xml:space="preserve">
          <source>The second element of the pair is of type &lt;a href=&quot;qcborvalue#qcborvalueref&quot;&gt;QCborValueRef&lt;/a&gt;, a helper class for &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt; and &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt;. When you get an object of type &lt;a href=&quot;qcborvalue#qcborvalueref&quot;&gt;QCborValueRef&lt;/a&gt;, you can use it as if it were a reference to a &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt;. If you assign to it, the assignment will apply to the element in the &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt; or &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt; from which you got the reference.</source>
          <target state="translated">쌍의 두 번째 요소는 &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt; 및 &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt; 의 헬퍼 클래스 인 &lt;a href=&quot;qcborvalue#qcborvalueref&quot;&gt;QCborValueRef&lt;/a&gt; 유형 입니다. 당신이 형식의 개체 얻을 때 &lt;a href=&quot;qcborvalue#qcborvalueref&quot;&gt;QCborValueRef을&lt;/a&gt; 그것의 참조 것처럼, 당신은 그것을 사용할 수 있습니다 &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; . 할당 하면 참조가있는 &lt;a href=&quot;qcborarray&quot;&gt;QCborArray&lt;/a&gt; 또는 &lt;a href=&quot;qcbormap&quot;&gt;QCborMap&lt;/a&gt; 의 요소에 할당이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d72f0d0aaa994652a39d632b9e45a7f0ba6ba41b" translate="yes" xml:space="preserve">
          <source>The second example illustrates using an existing &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt;, that is, a &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;.</source>
          <target state="translated">두 번째 예는 기존 &lt;a href=&quot;qml-qtquick-flickable&quot;&gt;Flickable&lt;/a&gt; 즉, &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView 사용을 보여&lt;/a&gt; 줍니다.</target>
        </trans-unit>
        <trans-unit id="0b461065a4323a4ecb95c639d6fe9ebeee8ef1d6" translate="yes" xml:space="preserve">
          <source>The second fastest way is to use the registered control's class name (with or without version number), e.g.</source>
          <target state="translated">두 번째로 빠른 방법은 등록 된 컨트롤의 클래스 이름 (버전 번호가 있거나없는)을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3da66080d17140c2fab826e189393d06a6bd6b0e" translate="yes" xml:space="preserve">
          <source>The second group of functions insert elements that provide structure to the document, and return the structure that was inserted:</source>
          <target state="translated">두 번째 함수 그룹은 문서에 구조를 제공하는 요소를 삽입하고 삽입 된 구조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9e96cb474c3063418c5d6ed6d9ff3475b7727935" translate="yes" xml:space="preserve">
          <source>The second is optional and is a map of property-value pairs that define initial any property values for the object. Property values specified by this argument are applied to the object before its creation is finalized, avoiding binding errors that may occur if particular properties must be initialized to enable other property bindings. Additionally, there are small performance benefits when compared to defining property values and bindings after the object is created.</source>
          <target state="translated">두 번째는 선택 사항이며 객체의 초기 속성 값을 정의하는 속성 값 쌍의 맵입니다. 이 인수로 지정된 특성 값은 다른 특성 바인딩을 사용하기 위해 특정 특성을 초기화해야하는 경우 발생할 수있는 바인딩 오류를 피하기 위해 작성이 완료되기 전에 오브젝트에 적용됩니다. 또한 객체를 만든 후 속성 값과 바인딩을 정의하는 것과 비교할 때 성능상의 이점이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="c8c36b64af97dce3172eadf6675b20f97b2c5179" translate="yes" xml:space="preserve">
          <source>The second is that &lt;a href=&quot;qplacemanager#compatiblePlace&quot;&gt;QPlaceManager::compatiblePlace&lt;/a&gt;() of the destination manager use the &lt;code&gt;x_provider&lt;/code&gt; attribute of the initial place and set an alternative identifier attribute of the place to be saved. The key of the alternative identifier attribute is &lt;code&gt;x_id_&amp;lt;provider&lt;/code&gt; name&amp;gt; and the text value is the identifier of the initial place. The &lt;code&gt;x_provider&lt;/code&gt; attribute should not be passed to the compatible place. When it is saved, the x_provider of the saved place is considered to be the destination manager.</source>
          <target state="translated">두 번째는 대상 관리자의 &lt;a href=&quot;qplacemanager#compatiblePlace&quot;&gt;QPlaceManager :: compatiblePlace&lt;/a&gt; ()가 초기 장소 의 &lt;code&gt;x_provider&lt;/code&gt; 속성을 사용하고 저장할 장소의 대체 식별자 속성을 설정한다는 것입니다. 대체 식별자 속성의 키는 &lt;code&gt;x_id_&amp;lt;provider&lt;/code&gt; 이름&amp;gt;이고 텍스트 값은 초기 장소의 식별자입니다. &lt;code&gt;x_provider&lt;/code&gt; 의 속성은 호환 장소에 전달되어서는 안된다. 저장되면 저장된 장소의 x_provider가 대상 관리자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="fe2d8a000c460caaa5da4716b8b77ac7219de156" translate="yes" xml:space="preserve">
          <source>The second is to use the overload that takes an index:</source>
          <target state="translated">두 번째는 인덱스를 사용하는 오버로드를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="294554ac2fe55547371f68a14c6864cd6f10bbfa" translate="yes" xml:space="preserve">
          <source>The second method is suitable if you want to minimize the size of your APK, and can be selected by opening the &lt;b&gt;Run&lt;/b&gt; settings of your project, expanding &lt;b&gt;Deploy Configurations&lt;/b&gt; and removing the tick from the &lt;b&gt;Use local Qt libraries&lt;/b&gt; check box. In this case, your application will have an external dependency called &lt;b&gt;Ministro&lt;/b&gt;. If a user downloads your application, and it is the first application on their device to depend on Ministro, they will be asked to install it before they can run your application. Ministro downloads Qt libraries from a repository of your choice. The repository URL can be set by editing the file</source>
          <target state="translated">두 번째 방법은 APK 크기를 최소화하려는 경우에 적합 하며 프로젝트의 설정 &lt;b&gt;실행&lt;/b&gt; 을 열고 &lt;b&gt;구성 배포를&lt;/b&gt; 확장 하고 &lt;b&gt;로컬 Qt 라이브러리 사용&lt;/b&gt; 확인란 에서 틱을 제거하여 선택할 수 있습니다 . 이 경우 응용 프로그램에는 &lt;b&gt;Ministro&lt;/b&gt; 라는 외부 종속성이 있습니다 . 사용자가 응용 프로그램을 다운로드하고 장치에서 Ministro에 의존하는 첫 번째 응용 프로그램 인 경우 응용 프로그램을 실행하기 전에 설치하라는 메시지가 표시됩니다. Ministro는 선택한 리포지토리에서 Qt 라이브러리를 다운로드합니다. 파일을 편집하여 저장소 URL을 설정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="edafaffe0431542bd4a4a52022cd359d51cc292c" translate="yes" xml:space="preserve">
          <source>The second notation allows you to append the contents of the variable to another value without separating the two with a space. For example, the following will ensure that the final executable will be given a name that includes the project template being used:</source>
          <target state="translated">두 번째 표기법을 사용하면 변수를 공백으로 구분하지 않고 변수의 내용을 다른 값에 추가 할 수 있습니다. 예를 들어, 다음은 최종 실행 파일에 사용중인 프로젝트 템플릿이 포함 된 이름이 지정되도록합니다.</target>
        </trans-unit>
        <trans-unit id="c87329295e3c1a0ad123bac3947e5fff6eb4d270" translate="yes" xml:space="preserve">
          <source>The second step after establishing the connection is to discover the services offered by the remote peripheral device. This process is started via &lt;a href=&quot;qlowenergycontroller#discoverServices&quot;&gt;discoverServices&lt;/a&gt;() and has finished once the &lt;a href=&quot;qlowenergycontroller#discoveryFinished&quot;&gt;discoveryFinished&lt;/a&gt;() signal has been emitted. The discovered services can be enumerated via &lt;a href=&quot;qlowenergycontroller#services&quot;&gt;services&lt;/a&gt;().</source>
          <target state="translated">연결을 설정 한 후 두 번째 단계는 원격 주변 장치가 제공하는 서비스를 검색하는 것입니다. 이 프로세스는 &lt;a href=&quot;qlowenergycontroller#discoverServices&quot;&gt;discoverServices&lt;/a&gt; () 를 통해 시작되며 &lt;a href=&quot;qlowenergycontroller#discoveryFinished&quot;&gt;discoveryFinished&lt;/a&gt; () 신호가 방출 되면 완료 됩니다. 발견 된 서비스는 &lt;a href=&quot;qlowenergycontroller#services&quot;&gt;서비스&lt;/a&gt; () 를 통해 열거 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1033068ed153771ffbdb06bb3ea0f6ee81f0f441" translate="yes" xml:space="preserve">
          <source>The second step in this process is to enable reading of this meta information in the applications that use the static library:</source>
          <target state="translated">이 프로세스의 두 번째 단계는 정적 라이브러리를 사용하는 애플리케이션에서이 메타 정보를 읽을 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e8ce564d8eb432f944e59d66cb8811cdb6a90b66" translate="yes" xml:space="preserve">
          <source>The second string matches &quot;Please write the &lt;u&gt;letter&lt;/u&gt;&quot;. The word 'letter' is also captured (because of the parentheses). We can see what text we've captured like this:</source>
          <target state="translated">두 번째 문자열은 &quot; &lt;u&gt;문자를&lt;/u&gt; 작성하십시오&quot;와 일치 합니다. 괄호 때문에 'letter'라는 단어도 캡처됩니다. 다음과 같이 캡처 한 텍스트를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="caf90f56e505f8b277902afacce829efcad41120" translate="yes" xml:space="preserve">
          <source>The second string matches '&lt;u&gt;This_is-OK&lt;/u&gt;'. We've used the character set abbreviation '\S' (non-whitespace) and the anchors to match strings which contain no whitespace.</source>
          <target state="translated">두 번째 문자열은 ' &lt;u&gt;This_is-OK&lt;/u&gt; ' 와 일치 합니다. 문자 세트 약어 '\ S'(공백이 아님)와 앵커를 사용하여 공백이없는 문자열을 일치 시켰습니다.</target>
        </trans-unit>
        <trans-unit id="fd075b1e98cbfba52846c1843ea4d75533f31a4a" translate="yes" xml:space="preserve">
          <source>The second user-defined button (see also &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveCustomButton2&lt;/a&gt;)</source>
          <target state="translated">두 번째 사용자 정의 버튼 ( &lt;a href=&quot;qwizard#WizardOption-enum&quot;&gt;HaveCustomButton2&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="1904d9fd0f2733c9490a8b70fdbb10fe88ed560e" translate="yes" xml:space="preserve">
          <source>The second view is given the selection model for the first view. Both views now operate on the same selection model, keeping both the data and the selected items synchronized.</source>
          <target state="translated">두 번째보기에는 첫 번째보기의 선택 모델이 제공됩니다. 이제 두보기가 동일한 선택 모델에서 작동하여 데이터와 선택한 항목이 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="8307d5622515c9e2c943cf66ee3d8cf29f2d804d" translate="yes" xml:space="preserve">
          <source>The second way is to create an empty &lt;a href=&quot;qboxset&quot;&gt;QBoxSet&lt;/a&gt; instance and specify the values using the &lt;a href=&quot;qboxset#setValue&quot;&gt;setValue&lt;/a&gt;() method.</source>
          <target state="translated">두 번째 방법은 빈 &lt;a href=&quot;qboxset&quot;&gt;QBoxSet&lt;/a&gt; 인스턴스 를 만들고 &lt;a href=&quot;qboxset#setValue&quot;&gt;setValue&lt;/a&gt; () 메소드를 사용하여 값을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f3a720f65730f86547c91ae28e16f9ae742b61aa" translate="yes" xml:space="preserve">
          <source>The second way is to create an empty &lt;a href=&quot;qml-qtcharts-boxset&quot;&gt;BoxSet&lt;/a&gt; instance and specify the values using the &lt;a href=&quot;qml-qtcharts-boxset#setValue-method&quot;&gt;setValue()&lt;/a&gt; method.</source>
          <target state="translated">두 번째 방법은 빈 &lt;a href=&quot;qml-qtcharts-boxset&quot;&gt;BoxSet&lt;/a&gt; 인스턴스 를 만들고 &lt;a href=&quot;qml-qtcharts-boxset#setValue-method&quot;&gt;setValue ()&lt;/a&gt; 메서드를 사용하여 값을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="06e6b0bab6c01909316270cb3bbb8502835df20a" translate="yes" xml:space="preserve">
          <source>The second way to create the button is good if you plan to use your rounded button in several places. It involves moving the code into its own QML file within your project.</source>
          <target state="translated">둥근 단추를 여러 곳에서 사용하려는 경우 단추를 만드는 두 번째 방법이 좋습니다. 코드를 프로젝트 내에서 자체 QML 파일로 옮기는 작업이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="53aacc9bcedf75f97ea19c680c21ef11fda036e3" translate="yes" xml:space="preserve">
          <source>The secondary viewport is used for drawing the 2D slice view in some visualizations. If it has not been explicitly set, it will be equal to &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt;. If &lt;a href=&quot;q3dscene#slicingActive-prop&quot;&gt;isSlicingActive&lt;/a&gt;() is &lt;code&gt;true&lt;/code&gt;, it will be equal to &lt;a href=&quot;q3dscene#viewport-prop&quot;&gt;viewport&lt;/a&gt;.</source>
          <target state="translated">보조 뷰포트는 일부 시각화에서 2D 슬라이스 뷰를 그리는 데 사용됩니다. 명시 적으로 설정되지 않은 경우 &lt;a href=&quot;qrect&quot;&gt;QRect와&lt;/a&gt; 같습니다 . 경우 &lt;a href=&quot;q3dscene#slicingActive-prop&quot;&gt;isSlicingActive은&lt;/a&gt; ()이다 &lt;code&gt;true&lt;/code&gt; , 같아야합니다 &lt;a href=&quot;q3dscene#viewport-prop&quot;&gt;뷰포트&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="024f9021eaf0bde9f987fc14d2dc5f23067b6023" translate="yes" xml:space="preserve">
          <source>The section is evaluated using the &lt;a href=&quot;qml-qtquick-listview#section.property-prop&quot;&gt;section&lt;/a&gt; properties.</source>
          <target state="translated">섹션은 &lt;a href=&quot;qml-qtquick-listview#section.property-prop&quot;&gt;섹션&lt;/a&gt; 속성을 사용하여 평가 됩니다.</target>
        </trans-unit>
        <trans-unit id="66eef1358f8d534fd435b0e6ac1f056857ad1225" translate="yes" xml:space="preserve">
          <source>The section of a &lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qheaderview&quot;&gt;QHeaderView&lt;/a&gt; 의 섹션입니다 .</target>
        </trans-unit>
        <trans-unit id="6ba63ee3baa45e8ffcce3452c4298b27431ee413" translate="yes" xml:space="preserve">
          <source>The section on &lt;a href=&quot;#qdoc-topics&quot;&gt;topic commands&lt;/a&gt; gives an overview on several other topic types.</source>
          <target state="translated">&lt;a href=&quot;#qdoc-topics&quot;&gt;주제 명령&lt;/a&gt; 섹션에서는 여러 가지 다른 주제 유형에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0507543e66104c274295ae601478ecc0fd4fc271" translate="yes" xml:space="preserve">
          <source>The security model of application scripting with JavaScript follows the same model as for C++ code: the user installs scripts to run that they trust in the same way as they install Qt applications.</source>
          <target state="translated">JavaScript를 사용한 응용 프로그램 스크립팅의 보안 모델은 C ++ 코드와 동일한 모델을 따릅니다. 사용자는 Qt 응용 프로그램을 설치할 때와 같은 방식으로 신뢰할 수있는 스크립트를 설치합니다.</target>
        </trans-unit>
        <trans-unit id="cfac5ae7af1be61bdbbe5a839a5c9b38275bb04f" translate="yes" xml:space="preserve">
          <source>The security parameters may be renegotiated between the two parties during or after the connection has been established. If such a change happens it is not reflected in the value of this flag.</source>
          <target state="translated">보안 매개 변수는 연결 중 또는 연결이 완료된 후 두 당사자간에 재협상 될 수 있습니다. 이러한 변경이 발생하면이 플래그의 값에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4fe95f34186c4ad1b9b9c1224a602a73163cde9" translate="yes" xml:space="preserve">
          <source>The seed data takes the form of one or more 32-bit words. The ideal seed size is approximately equal to the size of the &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; class itself. Due to mixing of the seed data, &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; cannot guarantee that distinct seeds will produce different sequences.</source>
          <target state="translated">시드 데이터는 하나 이상의 32 비트 워드 형태를 취합니다. 이상적인 시드 크기는 &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; 클래스 자체 의 크기와 거의 같습니다 . 시드 데이터의 혼합으로 인해 &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; 는 개별 시드가 다른 시퀀스를 생성 할 것이라고 보장 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cd93bbb2d77841eba21647ff8763f98ab6a66376" translate="yes" xml:space="preserve">
          <source>The seed is set in any newly created &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;. See &lt;a href=&quot;qhash#qhash&quot;&gt;qHash&lt;/a&gt; about how this seed is being used by &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt;.</source>
          <target state="translated">시드는 새로 생성 된 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash에&lt;/a&gt; 설정됩니다 . 참조 &lt;a href=&quot;qhash#qhash&quot;&gt;qHash을&lt;/a&gt; 이 씨에 의해 사용되는 방법에 대해 &lt;a href=&quot;qhash#qhash&quot;&gt;QHash&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43985e0138812050a29f9f9ec70db507a0f5a18c" translate="yes" xml:space="preserve">
          <source>The selected date can be set through &lt;a href=&quot;qml-qtquick-controls-calendar#selectedDate-prop&quot;&gt;selectedDate&lt;/a&gt;. A minimum and maximum date can be set through &lt;a href=&quot;qml-qtquick-controls-calendar#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls-calendar#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt;. The earliest minimum date that can be set is 1 January, 1 AD. The latest maximum date that can be set is 25 October, 275759 AD.</source>
          <target state="translated">선택한 날짜를 설정할 수 있습니다 &lt;a href=&quot;qml-qtquick-controls-calendar#selectedDate-prop&quot;&gt;되어 selectedDate&lt;/a&gt; . &lt;a href=&quot;qml-qtquick-controls-calendar#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls-calendar#maximumDate-prop&quot;&gt;maximumDate를&lt;/a&gt; 통해 최소 및 최대 날짜를 설정할 수 있습니다 . 설정할 수있는 가장 빠른 최소 날짜는 AD 1 월 1 일입니다. 설정할 수있는 최신 최대 날짜는 AD 275759 년 10 월 25 일입니다.</target>
        </trans-unit>
        <trans-unit id="bf969cacc7658bea3ee319fbfe2298015d19d4a1" translate="yes" xml:space="preserve">
          <source>The selected date is displayed using the format in the application's default locale.</source>
          <target state="translated">선택한 날짜는 응용 프로그램의 기본 로캘 형식을 사용하여 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b22d351cace32765dc201a46cbdfc45b0b31adca" translate="yes" xml:space="preserve">
          <source>The selected date must be within the date range specified by the &lt;a href=&quot;qcalendarwidget#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; and &lt;a href=&quot;qcalendarwidget#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; properties. By default, the selected date is the current date.</source>
          <target state="translated">선택한 날짜는 &lt;a href=&quot;qcalendarwidget#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; 및 &lt;a href=&quot;qcalendarwidget#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; 속성으로 지정된 날짜 범위 내에 있어야합니다 . 기본적으로 선택된 날짜는 현재 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="f7af228d7e9d6e0c92ee75b67f925d31853bf951" translate="yes" xml:space="preserve">
          <source>The selected items are indicated with the selection rectangle.</source>
          <target state="translated">선택한 항목은 선택 사각형으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="89f96d05df1124df8e76263bdddb941edbe5d500" translate="yes" xml:space="preserve">
          <source>The selected items are stored using ranges. Whenever you want to modify the selected items use &lt;a href=&quot;qitemselectionmodel#select&quot;&gt;select&lt;/a&gt;() and provide either a &lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt;, or a &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; and a &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;QItemSelectionModel::SelectionFlag&lt;/a&gt;.</source>
          <target state="translated">선택한 항목은 범위를 사용하여 저장됩니다. 선택한 항목을 수정할 때마다 &lt;a href=&quot;qitemselectionmodel#select&quot;&gt;select&lt;/a&gt; ()를 사용 하고 &lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt; 또는 &lt;a href=&quot;qmodelindex&quot;&gt;QModelIndex&lt;/a&gt; 및 &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;QItemSelectionModel :: SelectionFlag를 제공하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da8f5182b1a23ab3b6be2b12670b3bba25233b58" translate="yes" xml:space="preserve">
          <source>The selected items in a widget are read using the &lt;code&gt;selectedItems()&lt;/code&gt; function, providing a list of relevant items that can be iterated over. For example, we can find the sum of all the numeric values within a list of selected items with the following code:</source>
          <target state="translated">widget에서 선택된 항목은 &lt;code&gt;selectedItems()&lt;/code&gt; 함수를 사용하여 읽고 반복 할 수있는 관련 항목의 목록을 제공합니다. 예를 들어 다음 코드를 사용하여 선택한 항목 목록에서 모든 숫자 값의 합계를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea173bacd0142b549972732ae1638fdf19632b65" translate="yes" xml:space="preserve">
          <source>The selected series or &lt;code&gt;null&lt;/code&gt;. If &lt;a href=&quot;qabstract3dgraph#selectionMode-prop&quot;&gt;selectionMode&lt;/a&gt; has the &lt;code&gt;SelectionMultiSeries&lt;/code&gt; flag set, this property holds the series that owns the selected bar.</source>
          <target state="translated">선택한 시리즈 또는 &lt;code&gt;null&lt;/code&gt; . 경우 &lt;a href=&quot;qabstract3dgraph#selectionMode-prop&quot;&gt;의 selectionMode가&lt;/a&gt; 이 &lt;code&gt;SelectionMultiSeries&lt;/code&gt; 의 플래그가 설정이 속성은 선택한 막대를 소유하는 시리즈를 보유하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="f868c3e3563d31c44c121acc079893e8d3d64c07" translate="yes" xml:space="preserve">
          <source>The selected series or null.</source>
          <target state="translated">선택된 계열 또는 null</target>
        </trans-unit>
        <trans-unit id="a9545880f43af0ac871d8c1a86b6486de750864e" translate="yes" xml:space="preserve">
          <source>The selected series or null. If &lt;a href=&quot;qabstract3dgraph#selectionMode-prop&quot;&gt;selectionMode&lt;/a&gt; has the &lt;code&gt;SelectionMultiSeries&lt;/code&gt; flag set, this property holds the series which owns the selected point.</source>
          <target state="translated">선택된 계열 또는 null 경우 &lt;a href=&quot;qabstract3dgraph#selectionMode-prop&quot;&gt;의 selectionMode가&lt;/a&gt; 이 &lt;code&gt;SelectionMultiSeries&lt;/code&gt; 의 플래그 세트를,이 속성은 선택한 점을 소유하고있는 시리즈를 보유하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b28ca5b36879e7260535f1d3ef5c38209551953d" translate="yes" xml:space="preserve">
          <source>The selected state of items is set or unset, depending on several pre-defined modes - e.g., single selection, multiple selection, etc. - when the user interacts with the items.</source>
          <target state="translated">사용자가 항목과 상호 작용할 때 선택된 여러 상태 (예 : 단일 선택, 다중 선택 등)에 따라 선택한 항목 상태가 설정 또는 설정 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="027691232ac3acd28d7285bf31257cd20b02046d" translate="yes" xml:space="preserve">
          <source>The selected text color, used in selections.</source>
          <target state="translated">선택에 사용되는 선택된 텍스트 색상.</target>
        </trans-unit>
        <trans-unit id="e83c8e8372ab6d37b98e5af111064a0d9910b586" translate="yes" xml:space="preserve">
          <source>The selected text the context menu was created for.</source>
          <target state="translated">컨텍스트 메뉴가 작성된 선택된 텍스트</target>
        </trans-unit>
        <trans-unit id="225789d8c5ce64faf0c7e069a534d13563939653" translate="yes" xml:space="preserve">
          <source>The selection behavior is controlled by the &lt;a href=&quot;#show-decoration-selected-prop&quot;&gt;show-decoration-selected&lt;/a&gt; property.</source>
          <target state="translated">선택 동작은 &lt;a href=&quot;#show-decoration-selected-prop&quot;&gt;show-decoration-selected&lt;/a&gt; 속성에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4a0079a940310022d313275b65bbb7d46f3f991" translate="yes" xml:space="preserve">
          <source>The selection changes whenever an item is selected or unselected, a selection area is set, cleared or otherwise changed, if a preselected item is added to the scene, or if a selected item is removed from the scene.</source>
          <target state="translated">사전 선택 항목이 장면에 추가되거나 선택한 항목이 장면에서 제거되면 항목을 선택하거나 선택 해제 할 때마다 선택 영역이 선택되거나 선택 영역이 지워지거나 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b8f40d878bfa593698118bc046ab82655b3ecfe" translate="yes" xml:space="preserve">
          <source>The selection color.</source>
          <target state="translated">선택 색상.</target>
        </trans-unit>
        <trans-unit id="2d46c060788df668273e7f9fa27f0470e465e562" translate="yes" xml:space="preserve">
          <source>The selection has changed in a menu or item view.</source>
          <target state="translated">메뉴 또는 항목보기에서 선택이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="b31a1e6711396af52f0270dd2c216b969cdd7517" translate="yes" xml:space="preserve">
          <source>The selection is applied to the selection model using a command defined by a combination of &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;selection flags&lt;/a&gt;. In this case, the flags used cause the items recorded in the selection object to be included in the selection model, regardless of their previous state. The resulting selection is shown by the view.</source>
          <target state="translated">선택은 &lt;a href=&quot;qitemselectionmodel#SelectionFlag-enum&quot;&gt;선택 플래그&lt;/a&gt; 의 조합으로 정의 된 명령을 사용하여 선택 모델에 적용됩니다 . 이 경우, 사용 된 플래그는 이전 상태에 관계없이 선택 오브젝트에 기록 된 항목이 선택 모델에 포함되도록합니다. 결과 선택은보기로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="20f6a4e4bd2d333777c8dc67a250d5e2e66c0a89" translate="yes" xml:space="preserve">
          <source>The selection is asynchronous. If no certificate is selected and no copy of the object is kept alive, loading will continue without a certificate.</source>
          <target state="translated">선택은 비동기 적입니다. 인증서를 선택하지 않고 오브젝트 사본이 활성 상태로 유지되지 않으면 인증서없이로드가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="4b805fd90dbe641a21d0d2422b1a073f3d54071f" translate="yes" xml:space="preserve">
          <source>The selection mode specifies whether the selection is updated on a per character or a per word basis. If not specified the selection mode will default to &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt;.SelectCharacters.</source>
          <target state="translated">선택 모드는 선택이 문자 또는 단어 단위로 업데이트되는지 여부를 지정합니다. 지정하지 않으면 선택 모드는 기본적으로 &lt;a href=&quot;qml-qtquick-textedit&quot;&gt;TextEdit&lt;/a&gt; .SelectCharacters로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e7be275e6780f0e340db55cdd1b7818ad78044da" translate="yes" xml:space="preserve">
          <source>The selection mode specifies whether the selection is updated on a per character or a per word basis. If not specified the selection mode will default to &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt;.SelectCharacters.</source>
          <target state="translated">선택 모드는 선택이 문자 또는 단어 단위로 업데이트되는지 여부를 지정합니다. 지정하지 않으면 선택 모드는 기본적으로 &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; .SelectCharacters로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a3929f0953d3c6a993bcddafaf1b379ea22dbb86" translate="yes" xml:space="preserve">
          <source>The selection model emits signals to indicate changes in the selection. These notify other components about changes to both the selection as a whole and the currently focused item in the item model. We can connect the &lt;a href=&quot;qitemselectionmodel#selectionChanged&quot;&gt;selectionChanged()&lt;/a&gt; signal to a slot, and examine the items in the model that are selected or deselected when the selection changes. The slot is called with two &lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt; objects: one contains a list of indexes that correspond to newly selected items; the other contains indexes that correspond to newly deselected items.</source>
          <target state="translated">선택 모델은 선택의 변화를 나타내는 신호를 방출합니다. 이들은 전체 선택 항목과 현재 초점이있는 항목에 대한 변경 사항을 다른 구성 요소에 알려줍니다. &lt;a href=&quot;qitemselectionmodel#selectionChanged&quot;&gt;selectionChanged ()&lt;/a&gt; 신호를 슬롯에 연결하고 선택 이 변경 될 때 선택되거나 선택 해제 된 모델의 항목을 검사 할 수 있습니다. 슬롯은 두 개의 &lt;a href=&quot;qitemselection&quot;&gt;QItemSelection&lt;/a&gt; 오브젝트 로 호출 됩니다. 하나는 새로 선택된 항목에 해당하는 인덱스 목록을 포함합니다. 다른 하나는 새로 선택 해제 된 항목에 해당하는 색인을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9dc0e542db8937f936f1fbed256ddd6c742ed276" translate="yes" xml:space="preserve">
          <source>The selection model used in the item view classes provides a general description of selections based on the facilities of the model/view architecture. Although the standard classes for manipulating selections are sufficient for the item views provided, the selection model allows you to create specialized selection models to suit the requirements for your own item models and views.</source>
          <target state="translated">아이템 뷰 클래스에서 사용되는 선택 모델은 모델 / 뷰 아키텍처의 기능에 기반한 선택에 대한 일반적인 설명을 제공합니다. 선택 조작을위한 표준 클래스로 제공된 항목보기에 충분하지만 선택 모델을 사용하면 자체 항목 모델 및보기의 요구 사항에 맞게 특수한 선택 모델을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06ef40f5a02bf6f8a0eba1879414a96233579192" translate="yes" xml:space="preserve">
          <source>The selection of items can be modified using various operations that are defined by the selection flags. The selection that results from these operations may have a complex structure, but it is represented efficiently by the selection model. The use of different selection flags to manipulate the selected items is described when we examine how to update a selection.</source>
          <target state="translated">선택 플래그에 의해 정의 된 다양한 조작을 사용하여 항목 선택을 수정할 수 있습니다. 이러한 연산으로 인한 선택은 복잡한 구조를 가질 수 있지만 선택 모델로 효율적으로 표현됩니다. 선택된 항목을 조작하기 위해 다른 선택 플래그를 사용하는 것은 선택을 업데이트하는 방법을 검토 할 때 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="6d9536ffa403d2dc16ea8a7eeae41800f4acb59f" translate="yes" xml:space="preserve">
          <source>The selection of layouts at runtime is affected by the &lt;code&gt;QT_VIRTUALKEYBOARD_LAYOUT_PATH&lt;/code&gt; environment variable.</source>
          <target state="translated">런타임시 레이아웃 선택은 &lt;code&gt;QT_VIRTUALKEYBOARD_LAYOUT_PATH&lt;/code&gt; 환경 변수의 영향을받습니다 .</target>
        </trans-unit>
        <trans-unit id="b56fcd3712426022ab1b18efa5342ce09a25c8c9" translate="yes" xml:space="preserve">
          <source>The selection of the runtime style is affected by an environment variable QT_VIRTUALKEYBOARD_STYLE, which can be set to the name of the built-in style, e.g. &quot;retro&quot;, or any of the custom styles installed into the Styles directory:</source>
          <target state="translated">런타임 스타일 선택은 환경 변수 QT_VIRTUALKEYBOARD_STYLE의 영향을받습니다.이 변수는 내장 스타일의 이름 (예 : &quot;retro&quot;) 또는 스타일 디렉토리에 설치된 사용자 정의 스타일의 이름으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a1f38c0d0fe6497529229e1b0adfc656c0b1f84" translate="yes" xml:space="preserve">
          <source>The selection will be</source>
          <target state="translated">선택은</target>
        </trans-unit>
        <trans-unit id="b4f65db0dd7cfe52390c48f32b338226d7c61132" translate="yes" xml:space="preserve">
          <source>The sender object which is associated with this signal transition.</source>
          <target state="translated">이 신호 전환과 관련된 발신자 개체입니다.</target>
        </trans-unit>
        <trans-unit id="3d04bee3eba332307293f0be5fc2cb032b928b0f" translate="yes" xml:space="preserve">
          <source>The sensor data is delivered via &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; and its sub-classes.</source>
          <target state="translated">센서 데이터는 &lt;a href=&quot;qsensorreading&quot;&gt;QSensorReading&lt;/a&gt; 및 해당 서브 클래스 를 통해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="9aa520ce1bc9a7004e6f1824545f6a95fae3525f" translate="yes" xml:space="preserve">
          <source>The sensor does not take ownership of the filter. &lt;a href=&quot;qsensorfilter&quot;&gt;QSensorFilter&lt;/a&gt; will inform the sensor if it is destroyed.</source>
          <target state="translated">센서는 필터의 소유권을 갖지 않습니다. &lt;a href=&quot;qsensorfilter&quot;&gt;QSensorFilter&lt;/a&gt; 는 센서가 파손되면 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="2663833947a3a5cdf07f9534c8171a53b7702792" translate="yes" xml:space="preserve">
          <source>The sensor may fail to start for several reasons.</source>
          <target state="translated">여러 가지 이유로 센서가 시작되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="077dd2df099878f9d1bb9ec4ad1a2f7875639d60" translate="yes" xml:space="preserve">
          <source>The sensor reading can be found in the &lt;a href=&quot;qsensor#reading-prop&quot;&gt;QSensor::reading&lt;/a&gt; property. Note that the reading object is a volatile cache of the most recent sensor reading that has been received so the application should process the reading immediately or save the values somewhere for later processing.</source>
          <target state="translated">센서 판독 값은 &lt;a href=&quot;qsensor#reading-prop&quot;&gt;QSensor :: reading&lt;/a&gt; 특성 에서 찾을 수 있습니다 . 판독 개체는 가장 최근에 수신 된 센서 판독 값의 휘발성 캐시이므로 응용 프로그램에서 판독을 즉시 처리하거나 나중에 처리 할 수 ​​있도록 값을 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b3f459314e8c1506c401238363b10625e6efaaf" translate="yes" xml:space="preserve">
          <source>The sensor reports reflectance as a decimal fraction in the range of 0 - 1. That is, 0 indicates nothing was detected within the range of the sensor and 1 indicates the infra-red signal returned at the full power level that it was sent at.</source>
          <target state="translated">센서는 반사율을 0-1 범위의 소수로 표시합니다. 즉, 0은 센서 범위 내에서 아무것도 감지되지 않았 음을 나타내고 1은 전송 된 최대 전력 레벨에서 반환 된 적외선 신호를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ca9b979404e92d997a82408d6b792684f8e23f52" translate="yes" xml:space="preserve">
          <source>The sensor type.</source>
          <target state="translated">센서 타입.</target>
        </trans-unit>
        <trans-unit id="08d1d29ec8fa6d6c882bb37fa1e5575eaa027626" translate="yes" xml:space="preserve">
          <source>The separation of content and presentation is achieved by the use of a standard model interface provided by &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt;, a standard view interface provided by &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt;, and the use of model indexes that represent items of data in a general way. Views typically manage the overall layout of the data obtained from models. They may render individual items of data themselves, or use &lt;a href=&quot;#delegate-classes&quot;&gt;delegates&lt;/a&gt; to handle both rendering and editing features.</source>
          <target state="translated">증거의 분리에 의해 제공된 표준 모델 인터페이스의 사용에 의해 달성된다 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; 의해 제공된 표준보기 인터페이스 &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt; 하고 일반적인 방법으로 데이터의 항목을 나타내는 모델 인덱스의 용도. 뷰는 일반적으로 모델에서 얻은 데이터의 전체 레이아웃을 관리합니다. 개별 데이터 항목을 직접 렌더링하거나 &lt;a href=&quot;#delegate-classes&quot;&gt;대리자&lt;/a&gt; 를 사용하여 렌더링 및 편집 기능을 모두 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="fcccee6e0d426cdaaad9937e7b3b590baf27104f" translate="yes" xml:space="preserve">
          <source>The separation of functionality between the model/view components allows models to be created that can take advantage of existing views. This approach lets us present data from a variety of sources using standard graphical user interface components, such as &lt;a href=&quot;qlistview&quot;&gt;QListView&lt;/a&gt;, &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt;, and &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt;.</source>
          <target state="translated">모델 / 뷰 구성 요소 간 기능이 분리되어 기존 뷰를 활용할 수있는 모델을 작성할 수 있습니다. 이 접근 방식을 통해 &lt;a href=&quot;qlistview&quot;&gt;QListView&lt;/a&gt; , &lt;a href=&quot;qtableview&quot;&gt;QTableView&lt;/a&gt; 및 &lt;a href=&quot;qtreeview&quot;&gt;QTreeView&lt;/a&gt; 와 같은 표준 그래픽 사용자 인터페이스 구성 요소를 사용하여 다양한 소스의 데이터를 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b952964f7c7f9e08f10f4173253541c4ca090bb5" translate="yes" xml:space="preserve">
          <source>The separator between each column.</source>
          <target state="translated">각 열 사이의 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="1a78bf82482dcada129f191ca8dc2bdd9d5451af" translate="yes" xml:space="preserve">
          <source>The separator can be either underscore or a minus sign.</source>
          <target state="translated">구분 기호는 밑줄 또는 빼기 기호 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fabc1c4326c376d7254796f1e47aeebdc562fa0" translate="yes" xml:space="preserve">
          <source>The separator in a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; when using &lt;a href=&quot;qdockwidget&quot;&gt;QDockWidget&lt;/a&gt; is styled using the &lt;a href=&quot;#separator-sub&quot;&gt;::separator&lt;/a&gt; subcontrol.</source>
          <target state="translated">&lt;a href=&quot;qdockwidget&quot;&gt;QDockWidget을&lt;/a&gt; 사용할 때 &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; 의 구분 기호 는 &lt;a href=&quot;#separator-sub&quot;&gt;:: separator &lt;/a&gt;하위 컨트롤을 사용하여 스타일이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="77bddffcf82e9698d52ab1f4dfd22300d5286762" translate="yes" xml:space="preserve">
          <source>The separator in a toolbar.</source>
          <target state="translated">툴바의 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="1200fd769a6c9937943cc5bd9e55e22c0fe31673" translate="yes" xml:space="preserve">
          <source>The separator is styled using the &lt;a href=&quot;#separator-sub&quot;&gt;::separator&lt;/a&gt; subcontrol.</source>
          <target state="translated">구분 기호는 &lt;a href=&quot;#separator-sub&quot;&gt;:: separator&lt;/a&gt; 하위 컨트롤을 사용하여 스타일이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce103b06586aef114cc7759f9ba9b53004218ffe" translate="yes" xml:space="preserve">
          <source>The separator of a &lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; or in a &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qmenu&quot;&gt;QMenu&lt;/a&gt; 또는 &lt;a href=&quot;qmainwindow&quot;&gt;QMainWindow&lt;/a&gt; 의 구분자입니다 .</target>
        </trans-unit>
        <trans-unit id="34b0cb4eaa5149f5edba78439e54abac92919a27" translate="yes" xml:space="preserve">
          <source>The separator of a &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt; is styled using the &lt;a href=&quot;#separator-sub&quot;&gt;::separator&lt;/a&gt; subcontrol.</source>
          <target state="translated">&lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt; 의 구분 기호 는 &lt;a href=&quot;#separator-sub&quot;&gt;:: separator &lt;/a&gt;하위 컨트롤을 사용하여 스타일이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d22851eeaca036a75e6ea92e4001b0cb2e3d580e" translate="yes" xml:space="preserve">
          <source>The serial number of the screen.</source>
          <target state="translated">화면의 일련 번호입니다.</target>
        </trans-unit>
        <trans-unit id="8fac2cd35241ffd0009ed10eff8d5a816928cc58" translate="yes" xml:space="preserve">
          <source>The serialization format is a quint32 length specifier first, then</source>
          <target state="translated">직렬화 형식은 먼저 quint32 길이 지정자입니다.</target>
        </trans-unit>
        <trans-unit id="4efbc5570c1b0216ffd4f4c60ed8cee1621c47b0" translate="yes" xml:space="preserve">
          <source>The series</source>
          <target state="translated">시리즈</target>
        </trans-unit>
        <trans-unit id="0a18732ac71955e5d00856fd829e1ff25aba4339" translate="yes" xml:space="preserve">
          <source>The series assumes ownership of any proxy set to it and deletes any previously set proxy when a new one is added. The proxy cannot be null or set to another series.</source>
          <target state="translated">이 시리즈는 프록시 세트의 소유권을 가정하고 새 프록시가 추가되면 이전에 설정된 프록시를 삭제합니다. 프록시는 null이거나 다른 시리즈로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1ea217888f9f1129a122fd2ecf2aa2a6d063dbde" translate="yes" xml:space="preserve">
          <source>The series keeps track of the sum of all the slices it holds.</source>
          <target state="translated">시리즈는 보유하고있는 모든 슬라이스의 합계를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="c5ebd7f00d876c0ae6b96b81be4b517cac350332" translate="yes" xml:space="preserve">
          <source>The series name can be used in item label format with the tag &lt;code&gt;@seriesName&lt;/code&gt;.</source>
          <target state="translated">시리즈 이름은 &lt;code&gt;@seriesName&lt;/code&gt; 태그와 함께 항목 레이블 형식으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d36bad8cf642f8705a7c26e47ea64994381da674" translate="yes" xml:space="preserve">
          <source>The series name. It can be used in item label format with the tag &lt;code&gt;@seriesName&lt;/code&gt;.</source>
          <target state="translated">시리즈 이름. &lt;code&gt;@seriesName&lt;/code&gt; 태그를 사용하여 항목 레이블 형식으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c5a9b4e1eb65f890c8dbf501fdc3be00c3b9a901" translate="yes" xml:space="preserve">
          <source>The series of the graph. By default, this property contains an empty list. To set the series, either use the &lt;a href=&quot;qml-qtdatavisualization-bars3d#addSeries-method&quot;&gt;addSeries()&lt;/a&gt; function or define them as children of the graph.</source>
          <target state="translated">그래프의 시리즈. 기본적으로이 속성에는 빈 목록이 포함됩니다. 계열을 설정하려면 &lt;a href=&quot;qml-qtdatavisualization-bars3d#addSeries-method&quot;&gt;addSeries ()&lt;/a&gt; 함수를 사용하거나 그래프의 자식으로 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="186123839edf894db84cc5ecbbc5d359f5bd38ae" translate="yes" xml:space="preserve">
          <source>The series that is used by the mapper. All the data in the series is discarded when it is set to the mapper. When a new series is specified, the old series is disconnected (but it preserves its data).</source>
          <target state="translated">매퍼가 사용하는 시리즈입니다. 매퍼로 설정하면 계열의 모든 데이터가 삭제됩니다. 새 시리즈를 지정하면 이전 시리즈의 연결이 끊어 지지만 데이터는 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="2621e588ddf6f57fe34919656012f22b9411f199" translate="yes" xml:space="preserve">
          <source>The series this proxy is attached to.</source>
          <target state="translated">이 프록시가 첨부 된 시리즈입니다.</target>
        </trans-unit>
        <trans-unit id="2d1151d3c6cf747985723f167da67e90b8b2e138" translate="yes" xml:space="preserve">
          <source>The server answered the request with an error.</source>
          <target state="translated">서버가 오류로 요청에 응답했습니다.</target>
        </trans-unit>
        <trans-unit id="0bda6a51643ff3508ee838332a277c57cc0b0227" translate="yes" xml:space="preserve">
          <source>The server can create multiple instances of each exported class. This is the default. All instances will live in the same thread, and will share static resources.</source>
          <target state="translated">서버는 내 보낸 각 클래스의 인스턴스를 여러 개 만들 수 있습니다. 이것이 기본값입니다. 모든 인스턴스는 동일한 스레드에 있으며 정적 리소스를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="e23fea41beb82b97792beec3f181b1dee550750a" translate="yes" xml:space="preserve">
          <source>The server cannot perform the program function received in the query. This code is returned for an unsuccessful programming request. The client should request diagnostic or error information from the server.</source>
          <target state="translated">서버가 조회에서 수신 한 프로그램 기능을 수행 할 수 없습니다. 실패한 프로그래밍 요청에 대해이 코드가 리턴됩니다. 클라이언트는 서버에 진단 또는 오류 정보를 요청해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d0c4a40ec5b8789a3582d28229dda86e9c747ea" translate="yes" xml:space="preserve">
          <source>The server did not authorize access to the resource.</source>
          <target state="translated">서버가 자원에 대한 액세스 권한을 부여하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5f5ff42fc1b22da7df689ff990c4e79c952ff54b" translate="yes" xml:space="preserve">
          <source>The server does not export an implementation of a &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt;. Use the &lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt;() macro in one of the project's implementation files to instantiate and export a factory, or use the &lt;a href=&quot;qaxfactory#QAXFACTORY_DEFAULT&quot;&gt;QAXFACTORY_DEFAULT&lt;/a&gt;() macro to use the default factory.</source>
          <target state="translated">서버는 &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; 의 구현을 내 보내지 않습니다 . 사용 &lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt; 의 인스턴스를 생성하기위한 프로젝트의 실행 파일 중 하나에 () 매크로를하고 공장을 수출하거나 사용 &lt;a href=&quot;qaxfactory#QAXFACTORY_DEFAULT&quot;&gt;QAXFACTORY_DEFAULT&lt;/a&gt; 기본 팩토리를 사용하는 매크로를 ().</target>
        </trans-unit>
        <trans-unit id="dd528ffb322c8ea40bd4b7d6136912e32c25b357" translate="yes" xml:space="preserve">
          <source>The server does not have the requested data.</source>
          <target state="translated">서버에 요청 된 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="255040717b1cc12b6cb39df7905cacdf21bc33fc" translate="yes" xml:space="preserve">
          <source>The server exports more than one implementation of a &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt;, or exports the same implementation twice. If you use the default factory, the &lt;a href=&quot;qaxfactory#QAXFACTORY_DEFAULT&quot;&gt;QAXFACTORY_DEFAULT&lt;/a&gt;() macro must only be used once in the project. Use a custom &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; implementation and the &lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt;() macro if the server provides multiple ActiveX controls.</source>
          <target state="translated">서버는 둘 이상의 &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; 구현을 내보내 거나 동일한 구현을 두 번 내 보냅니다. 기본 팩토리를 사용하는 경우 &lt;a href=&quot;qaxfactory#QAXFACTORY_DEFAULT&quot;&gt;QAXFACTORY_DEFAULT&lt;/a&gt; () 매크로는 프로젝트에서 한 번만 사용해야합니다. 서버가 다중 ActiveX 제어를 제공하는 경우 사용자 정의 &lt;a href=&quot;qaxfactory&quot;&gt;QAxFactory&lt;/a&gt; 구현 및 &lt;a href=&quot;qaxfactory#QAXFACTORY_EXPORT&quot;&gt;QAXFACTORY_EXPORT&lt;/a&gt; () 매크로를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a3a61222425a0cabf7af540f372b9df2d56e20ec" translate="yes" xml:space="preserve">
          <source>The server has gone down.</source>
          <target state="translated">서버가 다운되었습니다.</target>
        </trans-unit>
        <trans-unit id="fa67b1b830836d429892537ee4aeaf311e833f2d" translate="yes" xml:space="preserve">
          <source>The server is engaged in processing a long duration program command.</source>
          <target state="translated">서버가 장기간 프로그램 명령을 처리하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0c5704ce5c0ea6138a655094b7df4a065c2ae89" translate="yes" xml:space="preserve">
          <source>The server is started automatically with</source>
          <target state="translated">서버는 다음과 같이 자동으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="0a97ca97e984ce1b9f5798975dc075c542be36e8" translate="yes" xml:space="preserve">
          <source>The server is stopped automatically when the main() function returns.</source>
          <target state="translated">main () 함수가 반환되면 서버가 자동으로 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="a0748992293b4aa402fec2d25888934f597f16f7" translate="yes" xml:space="preserve">
          <source>The server operates in non-secure mode (over ws)</source>
          <target state="translated">서버가 비보안 모드로 작동합니다 (ws 이상)</target>
        </trans-unit>
        <trans-unit id="fedd632d24527afc51edfd5b82774f432a945c7e" translate="yes" xml:space="preserve">
          <source>The server operates in secure mode (over wss)</source>
          <target state="translated">서버가 보안 모드 (wss 이상)에서 작동</target>
        </trans-unit>
        <trans-unit id="33d11424b3a5ad59d53563b86562ea1fbb5bf760" translate="yes" xml:space="preserve">
          <source>The server process can create only one instance of each exported class. COM starts a new process for each request. This is typically used in servers that export only one creatable class.</source>
          <target state="translated">서버 프로세스는 내 보낸 각 클래스의 인스턴스를 하나만 만들 수 있습니다. COM은 각 요청에 대해 새로운 프로세스를 시작합니다. 이것은 일반적으로 하나의 작성 가능 클래스 만 내보내는 서버에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1606fa13636bd90868689c2589e9c6f0e26579d6" translate="yes" xml:space="preserve">
          <source>The server's response to a token request provided no token identifier.</source>
          <target state="translated">토큰 요청에 대한 서버의 응답은 토큰 식별자를 제공하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5565f95a303296619425bf6d4afc96dd66a4663e" translate="yes" xml:space="preserve">
          <source>The server's response to a token request provided no token secret.</source>
          <target state="translated">토큰 요청에 대한 서버의 응답은 토큰 시크릿을 제공하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="67b4fc4ff7aaa7107d5a75b7b419c0cbe853573e" translate="yes" xml:space="preserve">
          <source>The service being bound is an isolated, external service. See &lt;a href=&quot;https://developer.android.com/reference/android/content/Context.html#BIND_EXTERNAL_SERVICE&quot;&gt;BIND_EXTERNAL_SERVICE&lt;/a&gt; documentation for more details.</source>
          <target state="translated">바인딩되는 서비스는 격리 된 외부 서비스입니다. 자세한 내용은 &lt;a href=&quot;https://developer.android.com/reference/android/content/Context.html#BIND_EXTERNAL_SERVICE&quot;&gt;BIND_EXTERNAL_SERVICE&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3e87a322c75a22e9d37b965dad70eafb0a3ab373" translate="yes" xml:space="preserve">
          <source>The service could not allocate resources required to function correctly.</source>
          <target state="translated">서비스가 올바르게 작동하는 데 필요한 자원을 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4c67d05c074bd5cce136c680c6e8d56b0ab1c0d5" translate="yes" xml:space="preserve">
          <source>The service details are being discovered.</source>
          <target state="translated">서비스 세부 사항이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="792a478eb56d5524d8a3f98c9b0c2a7408a98260" translate="yes" xml:space="preserve">
          <source>The service details are yet to be discovered by calling &lt;a href=&quot;qlowenergyservice#discoverDetails&quot;&gt;discoverDetails&lt;/a&gt;(). The only reliable pieces of information are its &lt;a href=&quot;qlowenergyservice#serviceUuid&quot;&gt;serviceUuid&lt;/a&gt;() and &lt;a href=&quot;qlowenergyservice#serviceName&quot;&gt;serviceName&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qlowenergyservice#discoverDetails&quot;&gt;discoverDetails&lt;/a&gt; () 를 호출하여 서비스 세부 사항을 아직 발견 할 수 없습니다 . 신뢰할 수있는 유일한 정보는 &lt;a href=&quot;qlowenergyservice#serviceUuid&quot;&gt;serviceUuid&lt;/a&gt; () 및 &lt;a href=&quot;qlowenergyservice#serviceName&quot;&gt;serviceName&lt;/a&gt; ()입니다.</target>
        </trans-unit>
        <trans-unit id="26177c9e14bded15574a12efed218e756974c43d" translate="yes" xml:space="preserve">
          <source>The service details have been discovered.</source>
          <target state="translated">서비스 세부 사항이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="ee02068568d9767f7ea30a14715582bd127856fa" translate="yes" xml:space="preserve">
          <source>The service discovery may find Bluetooth Low Energy services too if the target device is a combination of a classic and Low Energy device. Those devices are required to advertise their Low Energy services via SDP. If the target device only supports Bluetooth Low Energy services, it is likely to not advertise them via SDP. The &lt;a href=&quot;qlowenergycontroller&quot;&gt;QLowEnergyController&lt;/a&gt; class should be utilized to perform the service discovery on Low Energy devices.</source>
          <target state="translated">대상 장치가 클래식 장치와 저에너지 장치의 조합 인 경우 서비스 검색에서 Bluetooth 저에너지 서비스도 찾을 수 있습니다. 이러한 장치는 SDP를 통해 저에너지 서비스를 광고해야합니다. 대상 장치가 Bluetooth 저에너지 서비스 만 지원하는 경우 SDP를 통해 광고하지 않을 수 있습니다. &lt;a href=&quot;qlowenergycontroller&quot;&gt;QLowEnergyController의&lt;/a&gt; 클래스는 낮은 에너지 장치에서 서비스 검색을 수행하는 데 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="d772e68f67a4aebb2e167acd2199443215422dab" translate="yes" xml:space="preserve">
          <source>The service does not require any security.</source>
          <target state="translated">서비스에는 보안이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d86c51016ba95936bf86576e491d1612e29c3290" translate="yes" xml:space="preserve">
          <source>The service is a primary service.</source>
          <target state="translated">서비스는 기본 서비스입니다.</target>
        </trans-unit>
        <trans-unit id="05ef579646ea8f221322502f1cc0643037342a95" translate="yes" xml:space="preserve">
          <source>The service is a secondary service. Secondary services are included by other services to implement some higher-level functionality.</source>
          <target state="translated">서비스는 보조 서비스입니다. 보조 서비스는 다른 서비스에 포함되어 일부 고급 기능을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="89faeafc744b4873178ea74106d1a56dae401b43" translate="yes" xml:space="preserve">
          <source>The service is a top-level/primary service. If this type flag is not set, the service is considered to be a secondary service. Each service may be included by another service which is indicated by IncludedService.</source>
          <target state="translated">이 서비스는 최상위 / 기본 서비스입니다. 이 유형 플래그를 설정하지 않으면 서비스는 보조 서비스로 간주됩니다. 각 서비스는 IncludedService로 표시되는 다른 서비스에 의해 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce673f11a23e08f6c7334bc7dce2edf38a3fa382" translate="yes" xml:space="preserve">
          <source>The service is associated with a controller object in the &lt;a href=&quot;qlowenergycontroller#Role-enum&quot;&gt;peripheral role&lt;/a&gt;. Such service objects do not change their state. This value was introduced by Qt 5.7.</source>
          <target state="translated">서비스는 &lt;a href=&quot;qlowenergycontroller#Role-enum&quot;&gt;주변 장치 역할&lt;/a&gt; 의 컨트롤러 개체와 연결됩니다 . 이러한 서비스 개체는 상태를 변경하지 않습니다. 이 값은 Qt 5.7에 의해 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="bc7c4dda9bec3373cdb156a182002caae696efca" translate="yes" xml:space="preserve">
          <source>The service is included by another service. On some platforms, this flag cannot be determined until the service that includes the current service was discovered.</source>
          <target state="translated">이 서비스는 다른 서비스에 포함되어 있습니다. 일부 플랫폼에서는 현재 서비스를 포함하는 서비스가 발견 될 때까지이 플래그를 판별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="30bfb43aa1b7d9674beca69eee8ff711b5cc1ec6" translate="yes" xml:space="preserve">
          <source>The service is not ready for capture yet.</source>
          <target state="translated">서비스를 아직 캡처 할 준비가되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1f3d07c41db730eabacd627ed67b527a65917f77" translate="yes" xml:space="preserve">
          <source>The service is operating correctly.</source>
          <target state="translated">서비스가 올바르게 작동하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8cec4a2d0a5bd2b3a7cac1be2a4f7183085d5d0" translate="yes" xml:space="preserve">
          <source>The service is the preferred provider of a service.</source>
          <target state="translated">서비스는 선호하는 서비스 공급자입니다.</target>
        </trans-unit>
        <trans-unit id="ebdd5a3de5f5da296d2cb0550b413fafa6579c38" translate="yes" xml:space="preserve">
          <source>The service must wait for access to necessary resources.</source>
          <target state="translated">서비스는 필요한 리소스에 대한 액세스를 기다려야합니다.</target>
        </trans-unit>
        <trans-unit id="4ba5b05cb06443c3b64136f153f57ccfc9aad9f1" translate="yes" xml:space="preserve">
          <source>The service name and the name of the device offering the service. If the device name is empty the devices address will be used.</source>
          <target state="translated">서비스 이름 및 서비스를 제공하는 장치 이름 장치 이름이 비어 있으면 장치 주소가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1d58e997c9931b4b108ff4a165c0e62b3689cd14" translate="yes" xml:space="preserve">
          <source>The service or port was already registered</source>
          <target state="translated">서비스 또는 포트가 이미 등록되었습니다</target>
        </trans-unit>
        <trans-unit id="2381fd1417f6ddc1a661f2b928301b7f0c3dafc6" translate="yes" xml:space="preserve">
          <source>The service requested is invalid.</source>
          <target state="translated">요청한 서비스가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="235222d1fd5989167844ed444889c7252cfe42ce" translate="yes" xml:space="preserve">
          <source>The service requires authentication. Device must be paired, and the user is prompted on connection unless the device is Authorized-Paired.</source>
          <target state="translated">이 서비스에는 인증이 필요합니다. 장치가 페어링되어 있어야하며 장치에 인증 된 쌍이 아닌 경우 연결하라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="92d9f8f858352c90c5e33e899493a6e0247baa26" translate="yes" xml:space="preserve">
          <source>The service requires authorization by the user, unless the device is Authorized-Paired.</source>
          <target state="translated">장치가 Authorized-Paired가 아닌 한, 서비스는 사용자의 승인이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="71c91d4919fe9e874134eb7f01158ce33e74da3a" translate="yes" xml:space="preserve">
          <source>The service requires the communication link to be encrypted. This requires the device to be paired.</source>
          <target state="translated">이 서비스를 사용하려면 통신 링크를 암호화해야합니다. 이를 위해서는 장치를 페어링해야합니다.</target>
        </trans-unit>
        <trans-unit id="d676870c9d85bfea7dad07b7b7d696b9cc2b43f2" translate="yes" xml:space="preserve">
          <source>The service requires the communication link to be secure. Simple Pairing from Bluetooth 2.1 or greater is required. Legacy pairing is not permitted.</source>
          <target state="translated">서비스를 위해서는 통신 링크가 안전해야합니다. Bluetooth 2.1 이상의 단순 페어링이 필요합니다. 레거시 페어링은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="397ac55e1b59cd3ca21621fe5f4470e1a15f3ca9" translate="yes" xml:space="preserve">
          <source>The service supports generating directions in the following languages:</source>
          <target state="translated">이 서비스는 다음 언어로 길 찾기 생성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="11075fe1b77df5b4fbffc5e31c498087f1194f20" translate="yes" xml:space="preserve">
          <source>The service uses an unknown socket protocol.</source>
          <target state="translated">이 서비스는 알 수없는 소켓 프로토콜을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7e5c88bd5529f8ee8b7aa62ca01ae41eee595840" translate="yes" xml:space="preserve">
          <source>The service uses the L2CAP socket protocol. This protocol is not supported for direct socket connections on Android.</source>
          <target state="translated">서비스는 L2CAP 소켓 프로토콜을 사용합니다. 이 프로토콜은 Android의 직접 소켓 연결에는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="42248bdec29599de498b30666bbd90d7e03c2856" translate="yes" xml:space="preserve">
          <source>The service uses the RFCOMM socket protocol.</source>
          <target state="translated">이 서비스는 RFCOMM 소켓 프로토콜을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ff206d2bd1c9fc051297cbe23d738ef47be25e94" translate="yes" xml:space="preserve">
          <source>The services are called from state machines via the mechanism described in SCXML Specification - 6.4 &amp;lt;invoke&amp;gt;.</source>
          <target state="translated">서비스는 SCXML 사양-6.4 &amp;lt;invoke&amp;gt;에 설명 된 메커니즘을 통해 상태 머신에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8a3ec4c965bd91e04af7d87dc79d2ed9e0599531" translate="yes" xml:space="preserve">
          <source>The services are called from state machines via the mechanism described in SCXML Specification - 6.4 &amp;lt;invoke&amp;gt;. This class represents an actual instance of an invoked service.</source>
          <target state="translated">서비스는 SCXML 사양-6.4 &amp;lt;invoke&amp;gt;에 설명 된 메커니즘을 통해 상태 머신에서 호출됩니다. 이 클래스는 호출 된 서비스의 실제 인스턴스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c66d6877144949c52d9c8e0f20a8d563f9ea5d35" translate="yes" xml:space="preserve">
          <source>The services invoked by the state machine.</source>
          <target state="translated">상태 머신이 호출 한 서비스.</target>
        </trans-unit>
        <trans-unit id="2dfe96a256f52af4da0ec857aeef591a2d0f98f5" translate="yes" xml:space="preserve">
          <source>The session ID is used for message routing between parent and child state machines. If a state machine is started by an &lt;code&gt;&amp;lt;invoke&amp;gt;&lt;/code&gt; element, any event it sends will have the &lt;code&gt;invokeid&lt;/code&gt; field set to the session ID. The state machine will use the origin of an event (which is set by the</source>
          <target state="translated">세션 ID는 상위 및 하위 상태 시스템 간의 메시지 라우팅에 사용됩니다. 상태 머신이 &lt;code&gt;&amp;lt;invoke&amp;gt;&lt;/code&gt; 요소에 의해 시작 되면, 송신하는 모든 이벤트는 &lt;code&gt;invokeid&lt;/code&gt; 필드가 세션 ID로 설정됩니다. 상태 머신은 이벤트의 출처를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="58e1de06689e9fbfc2a3543e4fa89884cb5c942e" translate="yes" xml:space="preserve">
          <source>The session ID of the current state machine.</source>
          <target state="translated">현재 상태 머신의 세션 ID.</target>
        </trans-unit>
        <trans-unit id="9af515bb1f2e0859f9e341e15a8b526cf7c823d5" translate="yes" xml:space="preserve">
          <source>The session can be controlled via &lt;a href=&quot;qnetworksession#open&quot;&gt;open&lt;/a&gt;() and &lt;a href=&quot;qnetworksession#close&quot;&gt;close&lt;/a&gt;().</source>
          <target state="translated">세션은 &lt;a href=&quot;qnetworksession#open&quot;&gt;open&lt;/a&gt; () 및 &lt;a href=&quot;qnetworksession#close&quot;&gt;close&lt;/a&gt; () 를 통해 제어 할 수 있습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
