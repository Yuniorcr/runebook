<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="qt">
    <body>
      <group id="qt">
        <trans-unit id="a728e05c7bb01e2f38109329efc9e41910294e13" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, rendering is continuous and the value of the &lt;a href=&quot;qabstract3dgraph#currentFps-prop&quot;&gt;currentFps&lt;/a&gt; property is updated. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 렌더링이 계속되고 &lt;a href=&quot;qabstract3dgraph#currentFps-prop&quot;&gt;currentFps&lt;/a&gt; 속성 값 이 업데이트됩니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5e27a786e5847b4fde6942228b39a5d07998d54b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, smooth versions of predefined meshes set via the &lt;a href=&quot;qml-qtdatavisualization-abstract3dseries#mesh-prop&quot;&gt;mesh&lt;/a&gt; property are used. This property does not affect custom meshes used when the mesh is set to &lt;a href=&quot;qabstract3dseries#Mesh-enum&quot;&gt;Abstract3DSeries.MeshUserDefined&lt;/a&gt;. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 &lt;a href=&quot;qml-qtdatavisualization-abstract3dseries#mesh-prop&quot;&gt;mesh&lt;/a&gt; 속성을 통해 설정된 사전 정의 된 메쉬의 부드러운 버전 이 사용됩니다. 이 프로퍼티는 메시가 &lt;a href=&quot;qabstract3dseries#Mesh-enum&quot;&gt;Abstract3DSeries.MeshUserDefined&lt;/a&gt; 로 설정 될 때 사용되는 커스텀 메시에는 영향을 미치지 않습니다 . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3067b8f0b2bfcf1bf6060860f6095e570309b4fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, smooth versions set via the &lt;a href=&quot;qabstract3dseries#mesh-prop&quot;&gt;mesh&lt;/a&gt; property are used. This property does not affect custom meshes used when the mesh is set to &lt;a href=&quot;qabstract3dseries#Mesh-enum&quot;&gt;MeshUserDefined&lt;/a&gt;. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 &lt;a href=&quot;qabstract3dseries#mesh-prop&quot;&gt;mesh&lt;/a&gt; 속성을 통해 설정된 부드러운 버전 이 사용됩니다. 이 프로퍼티는 메시가 &lt;a href=&quot;qabstract3dseries#Mesh-enum&quot;&gt;MeshUserDefined&lt;/a&gt; 로 설정 될 때 사용되는 커스텀 메시에는 영향을 미치지 않습니다 . 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7f8bde4af579c6021f0aa07bd24b5dd12b9f051a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the Y-rotation of the camera is wrapped from minimum to maximum and from maximum to minimum. If &lt;code&gt;false&lt;/code&gt;, the Y-rotation of the camera is limited to the sector determined by the minimum and maximum values.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 카메라의 Y 회전이 최소에서 최대로, 최대에서 최소로 줄 바꿈됩니다. &lt;code&gt;false&lt;/code&gt; 인 경우 카메라의 Y 회전이 최소값과 최대 값으로 결정된 섹터로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="22ccf730e7268b7d470874f112d421bcdcd10779" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the Y-rotation of the camera is wrapped from minimum to maximum and from maximum to minimum. If &lt;code&gt;false&lt;/code&gt;, the Y-rotation of the camera is limited to the sector determined by the minimum and maximum values. Set to &lt;code&gt;true&lt;/code&gt; by default.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 카메라의 Y 회전이 최소에서 최대로, 최대에서 최소로 줄 바꿈됩니다. &lt;code&gt;false&lt;/code&gt; 인 경우 카메라의 Y 회전이 최소값과 최대 값으로 결정된 섹터로 제한됩니다. 기본적 으로 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="aab5ec13c808a251ce832f834097167754173208" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the animation will be played in reverse.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 애니메이션이 역방향으로 재생됩니다.</target>
        </trans-unit>
        <trans-unit id="e5713decdf59642b1b8d03d4057bfcb8c7d09e66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the animation will have no duration. Instead, the animation will advance one frame each time a frame is rendered to the screen. This synchronizes it with the painting rate as opposed to elapsed time.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 애니메이션이 지속 기간이 없습니다. 대신 애니메이션은 프레임이 화면에 렌더링 될 때마다 한 프레임 씩 전진합니다. 이렇게하면 경과 시간이 아닌 페인팅 속도와 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="baff7a64d06084da53082adbfb6396039e24fb10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the axis will be rendered in reverse, i.e. the positions of minimum and maximum values are swapped when the graph is rendered. This property doesn't affect the actual minimum and maximum values of the axis.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; 축이 그래프가 렌더링 될 때 교환되는 최소 및 최대 값의 반전, 즉 위치에 렌더링한다. 이 속성은 축의 실제 최소값과 최대 값에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db79b66112107eca4f1d0f83911af6bc0e5a57d3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the axis will be rendered in reverse. That is, the positions of the minimum and maximum values are swapped when the graph is rendered. This property does not affect the actual minimum and maximum values of the axis.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 축이 역방향으로 렌더링됩니다. 즉, 그래프를 렌더링 할 때 최소값과 최대 값의 위치가 바뀝니다. 이 속성은 축의 실제 최소값과 최대 값에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5a04afb515362749e37b33e6d3f412d17c3fabb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the horizontal axes are changed into polar axes. The x-axis becomes the angular axis and the z-axis becomes the radial axis. Polar mode is not available for bar graphs.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; , 수평 축 극성 축으로 변경됩니다. x 축은 각축이되고 z 축은 반 경축이됩니다. 막대 그래프에는 극좌표 모드를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8c988f1a392370005c1d94e44a51f713ffa4302e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the rendering is done continuously instead of on demand, and the value of the &lt;a href=&quot;qml-qtdatavisualization-abstractgraph3d#currentFps-prop&quot;&gt;currentFps&lt;/a&gt; property is updated. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 인 경우 요청시 대신 렌더링이 계속 수행되고 &lt;a href=&quot;qml-qtdatavisualization-abstractgraph3d#currentFps-prop&quot;&gt;currentFps&lt;/a&gt; 속성 값 이 업데이트됩니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="96bc61da784c95f837a934a084f60af29a8db1eb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the value of &lt;code&gt;0.0&lt;/code&gt; means that the bars are placed side-to-side, &lt;code&gt;1.0&lt;/code&gt; means that a space as wide as the thickness of one bar is left between the bars, and so on. Preset to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;true&lt;/code&gt; 의 값을 &lt;code&gt;0.0&lt;/code&gt; 바는 좌우에 배치되는 것을 의미 &lt;code&gt;1.0&lt;/code&gt; 즉 와이드 한 바의 두께는 바 사이에 남아있는 바와 같이, 등등과 같은 공간. 사전 설정은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="81d76750aeff5251d710ad68f5eb547c6e91b254" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the x-axis becomes the angular axis and the z-axis becomes the radial axis. Polar mode is not available for bar graphs.</source>
          <target state="translated">경우 &lt;code&gt;true&lt;/code&gt; x 축은 각 축 및 Z 축이 방사 축을하게된다. 막대 그래프에는 극좌표 모드를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="084d9b2cc31fb9e2970defd0d7f2d259f9d5554b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;url.examples&lt;/code&gt; is not defined, QDoc will output a list of example's files and images instead.</source>
          <target state="translated">&lt;code&gt;url.examples&lt;/code&gt; 가 정의되어 있지 않으면 QDoc 은 예제 파일 및 이미지 목록을 대신 출력합니다.</target>
        </trans-unit>
        <trans-unit id="cf51059d817654dee381051075e41b0cdd15592f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;viewfinder.minimumFrameRate&lt;/code&gt; is equal to &lt;code&gt;viewfinder.maximumFrameRate&lt;/code&gt;, the frame rate is fixed. If not, the actual frame rate fluctuates between the two values.</source>
          <target state="translated">경우 &lt;code&gt;viewfinder.minimumFrameRate&lt;/code&gt; 가 같은지 &lt;code&gt;viewfinder.maximumFrameRate&lt;/code&gt; , 프레임 레이트가 고정된다. 그렇지 않으면 실제 프레임 속도가 두 값 사이에서 변동합니다.</target>
        </trans-unit>
        <trans-unit id="f756295c6abd32656a0ab183f46f225868d1e6c4" translate="yes" xml:space="preserve">
          <source>If QCamera::FocusPointAuto or QCamera::FocusPointFaceDetection focus mode is selected this method returns the list of zones the camera is actually focused on.</source>
          <target state="translated">QCamera :: FocusPointAuto 또는 QCamera :: FocusPointFaceDetection 초점 모드를 선택한 경우이 방법은 카메라가 실제로 초점을 맞춘 영역 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="24571b07165e8a45c54f546ab986cfc74e1b3e09" translate="yes" xml:space="preserve">
          <source>If QDoc encounters both &lt;code&gt;exampledirs&lt;/code&gt; and &lt;code&gt;examples&lt;/code&gt;, it will look first in the &lt;code&gt;examples&lt;/code&gt; directory. QDoc will accept the first matching file it finds. QDoc will search in the directories specified, not in their subdirectories.</source>
          <target state="translated">QDoc이 &lt;code&gt;exampledirs&lt;/code&gt; 및 &lt;code&gt;examples&lt;/code&gt; 를 모두 발견 하면 &lt;code&gt;examples&lt;/code&gt; 디렉토리 에서 먼저 찾습니다 . QDoc은 찾은 첫 번째 일치 파일을 승인합니다. QDoc은 서브 디렉토리가 아닌 지정된 디렉토리에서 검색합니다.</target>
        </trans-unit>
        <trans-unit id="cc216c894f772a4e2b03cfcfb6ce13c6ea18bb0f" translate="yes" xml:space="preserve">
          <source>If QObjects are created within &lt;a href=&quot;qthread#run&quot;&gt;QThread::run&lt;/a&gt;(), they cannot become children of the &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; object because the &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; does not live in the thread that calls &lt;a href=&quot;qthread#run&quot;&gt;QThread::run&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qthread#run&quot;&gt;QThread :: run&lt;/a&gt; () 내에 QObject가 작성 되면 &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; 가 &lt;a href=&quot;qthread#run&quot;&gt;QThread :: run&lt;/a&gt; () 을 호출하는 스레드에 있지 않으므로 &lt;a href=&quot;qthread&quot;&gt;QThread&lt;/a&gt; 오브젝트의 하위가 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5aadec6bdc57a740633c545d82e63c5da47f89c8" translate="yes" xml:space="preserve">
          <source>If Qt Core is using the ICU libraries, they will be used to perform the transformation according to the rules of the current locale. Otherwise the conversion may be done in a platform-dependent manner, with &lt;a href=&quot;qstring#toLower&quot;&gt;QString::toLower&lt;/a&gt;() as a generic fallback.</source>
          <target state="translated">Qt Core가 ICU 라이브러리를 사용하는 경우 현재 로케일의 규칙에 따라 변환을 수행하는 데 사용됩니다. 그렇지 않으면 &lt;a href=&quot;qstring#toLower&quot;&gt;QString :: toLower&lt;/a&gt; ()를 일반적인 폴백 으로 사용하여 플랫폼에 따라 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc3101ba1214e4442d3416a224071a145b365fc8" translate="yes" xml:space="preserve">
          <source>If Qt Core is using the ICU libraries, they will be used to perform the transformation according to the rules of the current locale. Otherwise the conversion may be done in a platform-dependent manner, with &lt;a href=&quot;qstring#toUpper&quot;&gt;QString::toUpper&lt;/a&gt;() as a generic fallback.</source>
          <target state="translated">Qt Core가 ICU 라이브러리를 사용하는 경우 현재 로케일의 규칙에 따라 변환을 수행하는 데 사용됩니다. 그렇지 않으면 &lt;a href=&quot;qstring#toUpper&quot;&gt;QString :: toUpper&lt;/a&gt; ()를 일반적인 폴백 으로 사용하여 플랫폼에 따라 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e82746304ad395f3faa351a2994f79bfcae7f77" translate="yes" xml:space="preserve">
          <source>If Qt Location has been built before Qt WebEngine then this feature can be tested by using &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebengine-webenginewidgets-maps-example.html#&quot;&gt;Maps&lt;/a&gt; and allowing it to find the current position of the user. Note that on Windows an external GPS receiver must be connected to the application. For more information, see &lt;a href=&quot;qtpositioning-index&quot;&gt;Qt Positioning&lt;/a&gt;.</source>
          <target state="translated">Qt 위치가 Qt WebEngine 이전에 구축 된 경우이 기능은 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtwebengine-webenginewidgets-maps-example.html#&quot;&gt;맵&lt;/a&gt; 을 사용 하여 사용자의 현재 위치를 찾을 수 있도록 하여 테스트 할 수 있습니다 . Windows에서는 외부 GPS 수신기가 애플리케이션에 연결되어 있어야합니다. 자세한 내용은 &lt;a href=&quot;qtpositioning-index&quot;&gt;Qt 포지셔닝을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b291588f279617bfb08859dbb780cdec4428000e" translate="yes" xml:space="preserve">
          <source>If Qt does not support the given text encoding the driver will issue a warning message and connect to the database using UNICODE_FSS.</source>
          <target state="translated">Qt가 주어진 텍스트 인코딩을 지원하지 않으면 드라이버는 경고 메시지를 발행하고 UNICODE_FSS를 사용하여 데이터베이스에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="2e2ac015e055f14f3ef56305d18c4c9f4c309e4a" translate="yes" xml:space="preserve">
          <source>If Qt does not use fontconfig, you must either provide the path to the fonts with &lt;code&gt;QT_QPA_FONTDIR&lt;/code&gt;, or place the fonts under &lt;code&gt;&amp;lt;Qt-install-path&amp;gt;/lib/fonts&lt;/code&gt; which is the default font location.</source>
          <target state="translated">Qt가 fontconfig를 사용하지 않는 경우 &lt;code&gt;QT_QPA_FONTDIR&lt;/code&gt; 과 함께 글꼴에 대한 경로를 제공 하거나 기본 글꼴 위치 인 &lt;code&gt;&amp;lt;Qt-install-path&amp;gt;/lib/fonts&lt;/code&gt; 아래에 글꼴을 배치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2abdb487396ec887802d7b4650726670a8061525" translate="yes" xml:space="preserve">
          <source>If Qt is compiled with ICU support enabled, most codecs supported by ICU will also be available to the application.</source>
          <target state="translated">ICU 지원이 활성화 된 상태에서 Qt를 컴파일하면 ICU에서 지원하는 대부분의 코덱도 응용 프로그램에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2bb5da69476e15da6c17b9186b0cd35a2ef37c9" translate="yes" xml:space="preserve">
          <source>If Qt was configured for &lt;code&gt;xcb&lt;/code&gt;, the following &lt;code&gt;pkg-config&lt;/code&gt; files are also required:</source>
          <target state="translated">Qt가 &lt;code&gt;xcb&lt;/code&gt; 용으로 구성된 경우 다음 &lt;code&gt;pkg-config&lt;/code&gt; 파일도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8c8f33060420bcfa05b9683191ca7fdba87ce30e" translate="yes" xml:space="preserve">
          <source>If Return or Enter is pressed and the current text is valid (or can be &lt;a href=&quot;qvalidator#fixup&quot;&gt;made valid&lt;/a&gt; by the validator), the signal &lt;a href=&quot;qlineedit#returnPressed&quot;&gt;returnPressed&lt;/a&gt;() is emitted.</source>
          <target state="translated">Return 또는 Enter를 누르고 현재 텍스트가 유효한 경우 (또는 유효성 검사기에서 &lt;a href=&quot;qvalidator#fixup&quot;&gt;유효&lt;/a&gt; 할 수있는 경우) &lt;a href=&quot;qlineedit#returnPressed&quot;&gt;returnPressed&lt;/a&gt; () 신호 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e0241fa8fb8c12ad38f6c7d642b124c4220cd99f" translate="yes" xml:space="preserve">
          <source>If Sensors.conf specifies an identifier that is not registered, the system will fall back to the first registered identifier as the default.</source>
          <target state="translated">Sensors.conf가 등록되지 않은 식별자를 지정하면 시스템은 기본값으로 처음 등록 된 식별자로 폴백합니다.</target>
        </trans-unit>
        <trans-unit id="12baaa13797f4ebef13275de65895ae9742935eb" translate="yes" xml:space="preserve">
          <source>If T is &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, this class has the following additional members: &lt;a href=&quot;qstringlist#filter&quot;&gt;filter&lt;/a&gt;, &lt;a href=&quot;qstringlist#join&quot;&gt;join&lt;/a&gt;, &lt;a href=&quot;qstringlist#removeDuplicates&quot;&gt;removeDuplicates&lt;/a&gt;, &lt;a href=&quot;qstringlist#sort&quot;&gt;sort&lt;/a&gt;.</source>
          <target state="translated">T가 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; 인 경우 ,이 클래스에는 &lt;a href=&quot;qstringlist#filter&quot;&gt;filter&lt;/a&gt; , &lt;a href=&quot;qstringlist#join&quot;&gt;join&lt;/a&gt; , &lt;a href=&quot;qstringlist#removeDuplicates&quot;&gt;removeDuplicates&lt;/a&gt; , &lt;a href=&quot;qstringlist#sort&quot;&gt;sort&lt;/a&gt; 추가 멤버가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0c0db02ecc43c9e422114fcc4adcf9bccd7a727" translate="yes" xml:space="preserve">
          <source>If T is a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt;, this class has a couple more members that can be used. See the documentation for &lt;a href=&quot;qbytearraylist&quot;&gt;QByteArrayList&lt;/a&gt; for more information.</source>
          <target state="translated">T가 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 인 경우이 클래스에는 사용할 수있는 멤버가 몇 개 더 있습니다. 자세한 내용은 &lt;a href=&quot;qbytearraylist&quot;&gt;QByteArrayList&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0075ae9ec1676166fdbc7021633864722e9ce0b" translate="yes" xml:space="preserve">
          <source>If T is a pointer type, &lt;a href=&quot;qthreadstorage&quot;&gt;QThreadStorage&lt;/a&gt; takes ownership of the data (which must be created on the heap with &lt;code&gt;new&lt;/code&gt;) and deletes it when the thread exits, either normally or via termination.</source>
          <target state="translated">T가 포인터 유형 인 경우 &lt;a href=&quot;qthreadstorage&quot;&gt;QThreadStorage&lt;/a&gt; 는 데이터 소유권을 가져 오고 ( &lt;code&gt;new&lt;/code&gt; 로 힙에 작성해야 함 ) 스레드가 정상적으로 또는 종료를 통해 종료 될 때 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="a7e7126fd5bf7f11d5700a79c0222a8da5cbdb20" translate="yes" xml:space="preserve">
          <source>If T is a pointer type, &lt;a href=&quot;qthreadstorage&quot;&gt;QThreadStorage&lt;/a&gt; takes ownership of the data and deletes it automatically either when the thread exits (either normally or via termination) or when setLocalData() is called again.</source>
          <target state="translated">T가 포인터 유형 인 경우 &lt;a href=&quot;qthreadstorage&quot;&gt;QThreadStorage&lt;/a&gt; 는 데이터의 소유권을 가져와 스레드가 종료되거나 (정상 또는 종료를 통해) setLocalData ()가 다시 호출 될 때 자동으로 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="8149979cdec3d1d18d4402528def80cfc20edc55" translate="yes" xml:space="preserve">
          <source>If T is a pointer type, returns &lt;code&gt;true&lt;/code&gt; if the calling thread has non-zero data available.</source>
          <target state="translated">T가 포인터 유형 인 경우 호출 스레드에 사용 가능한 0이 아닌 데이터가 있으면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="58af0ac303cf5e6a76b291a33c239dfb54a9b20e" translate="yes" xml:space="preserve">
          <source>If T is a value type, returns whether the data has already been constructed by calling &lt;a href=&quot;qthreadstorage#setLocalData&quot;&gt;setLocalData&lt;/a&gt; or &lt;a href=&quot;qthreadstorage#localData&quot;&gt;localData&lt;/a&gt;.</source>
          <target state="translated">T가 값 유형 인 경우 &lt;a href=&quot;qthreadstorage#setLocalData&quot;&gt;setLocalData&lt;/a&gt; 또는 &lt;a href=&quot;qthreadstorage#localData&quot;&gt;localData&lt;/a&gt; 를 호출하여 데이터가 이미 구성되었는지 여부를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="852f95d50b54957d31ad0f96baf021c9aea6474b" translate="yes" xml:space="preserve">
          <source>If \printuntil is used without an argument, it expands to all the lines from the current position to the end of the quoted file.</source>
          <target state="translated">\ printuntil을 인수없이 사용하면 현재 위치에서 인용 된 파일의 끝까지 모든 행으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="562d6a085d036935dc458e97eb2b83b32b781d44" translate="yes" xml:space="preserve">
          <source>If a</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="7c6ac5b8019a29ae96bc86befbf8c32e00c00c70" translate="yes" xml:space="preserve">
          <source>If a &quot;What's This?&quot; window is showing, this destroys it.</source>
          <target state="translated">&quot;이게 뭐야?&quot; 창이 보이고, 이것은 그것을 파괴합니다.</target>
        </trans-unit>
        <trans-unit id="dd075131f6a1991469c3fc95bc52bb907172a9dc" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qabstractsocket&quot;&gt;QAbstractSocket&lt;/a&gt; or &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; has the &lt;a href=&quot;qnetworkproxy#ProxyType-enum&quot;&gt;QNetworkProxy::DefaultProxy&lt;/a&gt; type, then the &lt;a href=&quot;qnetworkproxy&quot;&gt;QNetworkProxy&lt;/a&gt; returned by this function is used.</source>
          <target state="translated">경우 &lt;a href=&quot;qabstractsocket&quot;&gt;QAbstractSocket&lt;/a&gt; 또는 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket이&lt;/a&gt; 이 &lt;a href=&quot;qnetworkproxy#ProxyType-enum&quot;&gt;QNetworkProxy :: DefaultProxy의&lt;/a&gt; 유형을 다음 &lt;a href=&quot;qnetworkproxy&quot;&gt;QNetworkProxy은&lt;/a&gt; 사용이 함수에 의해 반환.</target>
        </trans-unit>
        <trans-unit id="a35e102d13e09fbff85756a17a356c6f4067ad2b" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qabstractsocket&quot;&gt;QAbstractSocket&lt;/a&gt; or &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket&lt;/a&gt; has the &lt;a href=&quot;qnetworkproxy#ProxyType-enum&quot;&gt;QNetworkProxy::DefaultProxy&lt;/a&gt; type, then the &lt;a href=&quot;qnetworkproxy&quot;&gt;QNetworkProxy&lt;/a&gt; set with this function is used. If you want more flexibility in determining which proxy is used, use the &lt;a href=&quot;qnetworkproxyfactory&quot;&gt;QNetworkProxyFactory&lt;/a&gt; class.</source>
          <target state="translated">경우 &lt;a href=&quot;qabstractsocket&quot;&gt;QAbstractSocket&lt;/a&gt; 또는 &lt;a href=&quot;qtcpsocket&quot;&gt;QTcpSocket이&lt;/a&gt; 이 &lt;a href=&quot;qnetworkproxy#ProxyType-enum&quot;&gt;QNetworkProxy :: DefaultProxy의&lt;/a&gt; 유형을 다음 &lt;a href=&quot;qnetworkproxy&quot;&gt;QNetworkProxy의&lt;/a&gt; 이 기능 세트가 사용됩니다. 사용되는 프록시를보다 유연하게 결정하려면 &lt;a href=&quot;qnetworkproxyfactory&quot;&gt;QNetworkProxyFactory&lt;/a&gt; 클래스를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1452b1503b2363c2e94e4898175d29f11274064" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface&lt;/a&gt; implementation exists for the given</source>
          <target state="translated">경우 &lt;a href=&quot;qaccessibleinterface&quot;&gt;QAccessibleInterface의&lt;/a&gt; 구현은 주어진 존재</target>
        </trans-unit>
        <trans-unit id="a65e9fe9030eff7f2992c7e029ebf7bf762034a3" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt; object is constructed with the default constructor, it will use the default locale's settings.</source>
          <target state="translated">경우 &lt;a href=&quot;qlocale&quot;&gt;QLocale의&lt;/a&gt; 객체가 기본 생성자로 구성되어, 그것은 기본 로케일의 설정을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bc06112a7df859e32bd6a96127f0973d55c31a85" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; can play media is will implement &lt;a href=&quot;qmediaplayercontrol&quot;&gt;QMediaPlayerControl&lt;/a&gt;. This control provides a means to set the &lt;a href=&quot;qmediaplayercontrol#setMedia&quot;&gt;media&lt;/a&gt; to play, &lt;a href=&quot;qmediaplayercontrol#play&quot;&gt;start&lt;/a&gt;, &lt;a href=&quot;qmediaplayercontrol#pause&quot;&gt;pause&lt;/a&gt; and &lt;a href=&quot;qmediaplayercontrol#stop&quot;&gt;stop&lt;/a&gt; playback, &lt;a href=&quot;qmediaplayercontrol#setPosition&quot;&gt;seek&lt;/a&gt;, and control the &lt;a href=&quot;qmediaplayercontrol#setVolume&quot;&gt;volume&lt;/a&gt;. It also provides feedback on the &lt;a href=&quot;qmediaplayercontrol#duration&quot;&gt;duration&lt;/a&gt; of the media, the current &lt;a href=&quot;qmediaplayercontrol#position&quot;&gt;position&lt;/a&gt;, and &lt;a href=&quot;qmediaplayercontrol#bufferStatus&quot;&gt;buffering&lt;/a&gt; progress.</source>
          <target state="translated">&lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; 가 미디어를 재생할 수 있는 경우 QMediaPlayerControl 을 구현 &lt;a href=&quot;qmediaplayercontrol&quot;&gt;합니다&lt;/a&gt; . 이 컨트롤은 &lt;a href=&quot;qmediaplayercontrol#setMedia&quot;&gt;미디어&lt;/a&gt; 를 재생, &lt;a href=&quot;qmediaplayercontrol#play&quot;&gt;시작&lt;/a&gt; , &lt;a href=&quot;qmediaplayercontrol#pause&quot;&gt;일시 중지&lt;/a&gt; 및 재생 &lt;a href=&quot;qmediaplayercontrol#stop&quot;&gt;중지&lt;/a&gt; , &lt;a href=&quot;qmediaplayercontrol#setPosition&quot;&gt;탐색&lt;/a&gt; 및 &lt;a href=&quot;qmediaplayercontrol#setVolume&quot;&gt;볼륨&lt;/a&gt; 조절 을 설정하는 수단을 제공합니다 . 또한 미디어 &lt;a href=&quot;qmediaplayercontrol#duration&quot;&gt;지속 시간&lt;/a&gt; , 현재 &lt;a href=&quot;qmediaplayercontrol#position&quot;&gt;위치&lt;/a&gt; 및 &lt;a href=&quot;qmediaplayercontrol#bufferStatus&quot;&gt;버퍼링&lt;/a&gt; 진행 에 대한 피드백을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="061ae3c44892697a396132483880bd4c3f20f012" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; can provide read or write access to the meta-data of its current media it will implement &lt;a href=&quot;qmetadatareadercontrol&quot;&gt;QMetaDataReaderControl&lt;/a&gt;. This control provides functions for both retrieving and setting meta-data values. Meta-data may be addressed by the keys defined in the &lt;a href=&quot;qmediametadata&quot;&gt;QMediaMetaData&lt;/a&gt; namespace.</source>
          <target state="translated">&lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; 가 현재 미디어의 메타 데이터에 대한 읽기 또는 쓰기 액세스를 제공 할 수 있으면 QMetaDataReaderControl 을 구현 &lt;a href=&quot;qmetadatareadercontrol&quot;&gt;합니다&lt;/a&gt; . 이 컨트롤은 메타 데이터 값을 검색하고 설정하는 기능을 제공합니다. 메타 데이터는 &lt;a href=&quot;qmediametadata&quot;&gt;QMediaMetaData&lt;/a&gt; 네임 스페이스에 정의 된 키로 처리 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b520334097d92783d613ffca5ac7983b7488e5c" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; can provide write access to the meta-data of its current media it will implement &lt;a href=&quot;qmetadatawritercontrol&quot;&gt;QMetaDataWriterControl&lt;/a&gt;. This control provides functions for both retrieving and setting meta-data values. Meta-data may be addressed by the keys defined in the &lt;a href=&quot;qmediametadata&quot;&gt;QMediaMetaData&lt;/a&gt; namespace.</source>
          <target state="translated">&lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; 가 현재 미디어의 메타 데이터에 대한 쓰기 액세스를 제공 할 수 있으면 QMetaDataWriterControl 을 구현 &lt;a href=&quot;qmetadatawritercontrol&quot;&gt;합니다&lt;/a&gt; . 이 컨트롤은 메타 데이터 값을 검색하고 설정하는 기능을 제공합니다. 메타 데이터는 &lt;a href=&quot;qmediametadata&quot;&gt;QMediaMetaData&lt;/a&gt; 네임 스페이스에 정의 된 키로 처리 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90617722bd74ba2b32975ffaf9d4ea429f9afeec" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; can record media it will implement &lt;a href=&quot;qmediarecordercontrol&quot;&gt;QMediaRecorderControl&lt;/a&gt;. This control provides a means to set the &lt;a href=&quot;qmediarecordercontrol#outputLocation&quot;&gt;output location&lt;/a&gt;, and record, pause and stop recording via the &lt;a href=&quot;qmediarecordercontrol#setState&quot;&gt;setState&lt;/a&gt;() method. It also provides feedback on the &lt;a href=&quot;qmediarecordercontrol#duration&quot;&gt;duration&lt;/a&gt; of the recording.</source>
          <target state="translated">&lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; 가 미디어를 기록 할 수 있으면 QMediaRecorderControl 을 구현 &lt;a href=&quot;qmediarecordercontrol&quot;&gt;합니다&lt;/a&gt; . 이 컨트롤은 &lt;a href=&quot;qmediarecordercontrol#outputLocation&quot;&gt;출력 위치&lt;/a&gt; 를 설정 하고 &lt;a href=&quot;qmediarecordercontrol#setState&quot;&gt;setState&lt;/a&gt; () 메서드 를 통해 기록을 기록, 일시 중지 및 중지 하는 수단을 제공합니다 . 또한 녹음 &lt;a href=&quot;qmediarecordercontrol#duration&quot;&gt;시간&lt;/a&gt; 에 대한 피드백도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="be91987d3fe4fff10a495d63ab7b42bd651cc423" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; can tune an analog radio device it will implement &lt;a href=&quot;qradiotunercontrol&quot;&gt;QRadioTunerControl&lt;/a&gt;. This control provides a means to tune a radio device to a specific &lt;a href=&quot;qradiotunercontrol#setFrequency&quot;&gt;frequency&lt;/a&gt; as well as search &lt;a href=&quot;qradiotunercontrol#searchForward&quot;&gt;forwards&lt;/a&gt; and &lt;a href=&quot;qradiotunercontrol#searchBackward&quot;&gt;backwards&lt;/a&gt; for a signal.</source>
          <target state="translated">&lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; 가 아날로그 라디오 장치를 조정할 수 있으면 QRadioTunerControl 을 구현 &lt;a href=&quot;qradiotunercontrol&quot;&gt;합니다&lt;/a&gt; . 이 컨트롤은 특정의 조정에 무선 장치를위한 수단을 제공하는 &lt;a href=&quot;qradiotunercontrol#setFrequency&quot;&gt;주파수&lt;/a&gt; 아니라 검색으로 &lt;a href=&quot;qradiotunercontrol#searchForward&quot;&gt;앞쪽&lt;/a&gt; 및 &lt;a href=&quot;qradiotunercontrol#searchBackward&quot;&gt;뒤쪽&lt;/a&gt; 의 신호에 대한.</target>
        </trans-unit>
        <trans-unit id="73a24b2866e15a7893b98544523173df8b523c5c" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; supports audio roles it may implement &lt;a href=&quot;qcustomaudiorolecontrol&quot;&gt;QCustomAudioRoleControl&lt;/a&gt; in order to provide access to roles unknown to Qt.</source>
          <target state="translated">&lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; 가 오디오 역할을 지원 하는 경우 Qt에 알려지지 않은 역할에 대한 액세스를 제공하기 위해 &lt;a href=&quot;qcustomaudiorolecontrol&quot;&gt;QCustomAudioRoleControl&lt;/a&gt; 을 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e1f653380fbc3554065fa93e0cef2bd1a4f85aa" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; supports audio roles it will implement &lt;a href=&quot;qaudiorolecontrol&quot;&gt;QAudioRoleControl&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; 가 오디오 역할을 지원 하면 QAudioRoleControl 을 구현 &lt;a href=&quot;qaudiorolecontrol&quot;&gt;합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="399026aa84d89b6e3c668682085d0960865da8e4" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; supports encoding audio data it will implement &lt;a href=&quot;qaudioencodersettingscontrol&quot;&gt;QAudioEncoderSettingsControl&lt;/a&gt;. This control provides information about the limits of restricted audio encoder options and allows the selection of a set of audio encoder settings as specified in a &lt;a href=&quot;qaudioencodersettings&quot;&gt;QAudioEncoderSettings&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; 가 오디오 데이터 인코딩을 지원 하면 QAudioEncoderSettingsControl 을 구현 &lt;a href=&quot;qaudioencodersettingscontrol&quot;&gt;합니다&lt;/a&gt; . 이 컨트롤은 제한된 오디오 인코더 옵션의 한계에 대한 정보를 제공하며 &lt;a href=&quot;qaudioencodersettings&quot;&gt;QAudioEncoderSettings&lt;/a&gt; 객체에 지정된대로 오디오 인코더 설정 세트를 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e78da17c2033087b13541d14d58c986b66c3790" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; supports encoding image data it will implement &lt;a href=&quot;qimageencodercontrol&quot;&gt;QImageEncoderControl&lt;/a&gt;. This control allows to &lt;a href=&quot;qimageencodercontrol#setImageSettings&quot;&gt;set image encoding settings&lt;/a&gt; and provides functions for quering supported image &lt;a href=&quot;qimageencodercontrol#supportedImageCodecs&quot;&gt;codecs&lt;/a&gt; and &lt;a href=&quot;qimageencodercontrol#supportedResolutions&quot;&gt;resolutions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; 가 이미지 데이터 인코딩을 지원 하면 QImageEncoderControl 을 구현 &lt;a href=&quot;qimageencodercontrol&quot;&gt;합니다&lt;/a&gt; . 이 컨트롤을 사용하면 &lt;a href=&quot;qimageencodercontrol#setImageSettings&quot;&gt;이미지 인코딩 설정을 지정할 수&lt;/a&gt; 있으며 지원되는 이미지 &lt;a href=&quot;qimageencodercontrol#supportedImageCodecs&quot;&gt;코덱&lt;/a&gt; 및 &lt;a href=&quot;qimageencodercontrol#supportedResolutions&quot;&gt;해상도&lt;/a&gt; 를 quering하는 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="19886180a4c26758822fe2e22a2780e69f0b94cb" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; supports encoding video data it will implement &lt;a href=&quot;qvideoencodersettingscontrol&quot;&gt;QVideoEncoderSettingsControl&lt;/a&gt;. This control provides information about the limits of restricted video encoder options and allows the selection of a set of video encoder settings as specified in a &lt;a href=&quot;qvideoencodersettings&quot;&gt;QVideoEncoderSettings&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; 가 비디오 데이터 인코딩을 지원 하면 QVideoEncoderSettingsControl 을 구현 &lt;a href=&quot;qvideoencodersettingscontrol&quot;&gt;합니다&lt;/a&gt; . 이 컨트롤은 제한된 비디오 인코더 옵션의 한계에 대한 정보를 제공하고 &lt;a href=&quot;qvideoencodersettings&quot;&gt;QVideoEncoderSettings&lt;/a&gt; 객체에 지정된대로 비디오 인코더 설정 세트를 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7435851444f76fce5f2b114d946199150133324e" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; supports gapless playback it will implement &lt;a href=&quot;qmediagaplessplaybackcontrol&quot;&gt;QMediaGaplessPlaybackControl&lt;/a&gt;. This control provides a means to set the &lt;a href=&quot;qmediagaplessplaybackcontrol#setNextMedia&quot;&gt;next media&lt;/a&gt; or &lt;a href=&quot;qmediagaplessplaybackcontrol#setCrossfadeTime&quot;&gt;crossfade time&lt;/a&gt; for smooth transitions between tracks.</source>
          <target state="translated">&lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; 가 갭리스 재생을 지원 하면 QMediaGaplessPlaybackControl 을 구현 &lt;a href=&quot;qmediagaplessplaybackcontrol&quot;&gt;합니다&lt;/a&gt; . 이 컨트롤은 트랙 간의 부드러운 전환을 위해 &lt;a href=&quot;qmediagaplessplaybackcontrol#setNextMedia&quot;&gt;다음 미디어&lt;/a&gt; 또는 &lt;a href=&quot;qmediagaplessplaybackcontrol#setCrossfadeTime&quot;&gt;크로스 페이드 시간&lt;/a&gt; 을 설정하는 수단을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="4d44c21e007a0032e61104928da4bcf5a6d23582" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; supports writing encoded data it will implement &lt;a href=&quot;qmediacontainercontrol&quot;&gt;QMediaContainerControl&lt;/a&gt;. This control provides information about the output containers supported by a media service and allows one to be selected as the current output containers.</source>
          <target state="translated">&lt;a href=&quot;qmediaservice&quot;&gt;QMediaService&lt;/a&gt; 가 인코딩 된 데이터 쓰기를 지원 하면 QMediaContainerControl 을 구현 &lt;a href=&quot;qmediacontainercontrol&quot;&gt;합니다&lt;/a&gt; . 이 컨트롤은 미디어 서비스가 지원하는 출력 컨테이너에 대한 정보를 제공하고 현재 출력 컨테이너로 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ee1c996a3a96d29da4c8d5def5932129eb9894b" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qml-qtcharts-valueaxis&quot;&gt;ValueAxis&lt;/a&gt; type is used instead of a &lt;a href=&quot;qml-qtcharts-barcategoryaxis&quot;&gt;BarCategoryAxis&lt;/a&gt; type for the main bar axis, the bars are grouped around the index value of the category.</source>
          <target state="translated">경우 &lt;a href=&quot;qml-qtcharts-valueaxis&quot;&gt;ValueAxis의&lt;/a&gt; 유형이 대신 사용된다 &lt;a href=&quot;qml-qtcharts-barcategoryaxis&quot;&gt;BarCategoryAxis의&lt;/a&gt; 주 바 축 타입, 바는 카테고리의 인덱스 값 주위 그룹화된다.</target>
        </trans-unit>
        <trans-unit id="3d385bb963de38987e79bc3e32c427d6a2056c6c" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qml-qtquick-gridview#remove-signal&quot;&gt;remove&lt;/a&gt; transition has been specified, it will not be applied until delayRemove is returned to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;qml-qtquick-gridview#remove-signal&quot;&gt;제거&lt;/a&gt; 전환이 지정되어 delayRemove가 반환 될 때까지 적용되지 않습니다 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42410e547ea3a59c2401001ce2f701a4d97cbbc8" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qml-qtquick-listview#remove-signal&quot;&gt;remove&lt;/a&gt; transition has been specified, it will not be applied until delayRemove is returned to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;qml-qtquick-listview#remove-signal&quot;&gt;제거&lt;/a&gt; 전환이 지정되어 delayRemove가 반환 될 때까지 적용되지 않습니다 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77e964f50343556bdf23754fbb1e1335a04e8695" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; is placed within an item that filters child mouse events, such as Flickable, the mouse events may be stolen from the &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; if a gesture is recognized by the parent item, e.g. a flick gesture. If preventStealing is set to true, no item will steal the mouse events.</source>
          <target state="translated">경우 &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea는&lt;/a&gt; 같은 flickable 한 같은 필터 아동 마우스 이벤트는, 마우스 이벤트가 도난 될 수있는 항목 내에 배치되어 &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; 제스처가 상위 항목, 예를 들면 영화 제스처를 인식합니다. preventStealing이 true로 설정되면 항목이 마우스 이벤트를 훔치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a21634cfb9fb1470827601c73f3cdb526bbd7ce" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; overlaps with the area of other &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; items, you can choose to propagate &lt;code&gt;clicked&lt;/code&gt;, &lt;code&gt;doubleClicked&lt;/code&gt; and &lt;code&gt;pressAndHold&lt;/code&gt; events to these other items by setting &lt;a href=&quot;qml-qtquick-mousearea#propagateComposedEvents-prop&quot;&gt;propagateComposedEvents&lt;/a&gt; to true and rejecting events that should be propagated. See the &lt;a href=&quot;qml-qtquick-mousearea#propagateComposedEvents-prop&quot;&gt;propagateComposedEvents&lt;/a&gt; documentation for details.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; 가 다른 &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; 항목 의 영역과 겹치는 경우 &lt;a href=&quot;qml-qtquick-mousearea#propagateComposedEvents-prop&quot;&gt;propagateComposedEvents&lt;/a&gt; 를 true 로 설정하고 전파 해야하는 이벤트를 거부하여 &lt;code&gt;clicked&lt;/code&gt; , &lt;code&gt;doubleClicked&lt;/code&gt; 및 &lt;code&gt;pressAndHold&lt;/code&gt; 이벤트를 다른 항목에 전파하도록 선택할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;qml-qtquick-mousearea#propagateComposedEvents-prop&quot;&gt;propagateComposedEvents&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6215d82ebb69c6d9440a16146ca3b5c52e1f0bc2" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qml-qtquick-particles-particlegroup&quot;&gt;ParticleGroup&lt;/a&gt; element is not defined for a group, the group will function normally as if none of the transition properties were set.</source>
          <target state="translated">경우 &lt;a href=&quot;qml-qtquick-particles-particlegroup&quot;&gt;ParticleGroup의&lt;/a&gt; 요소 그룹에 대한 정의되지 않은 전이 특성 설정되어 있지 않은 경우로서,이 그룹은 정상적으로 작동된다.</target>
        </trans-unit>
        <trans-unit id="c87ae837c887d9bbe760a61c8da17357a02974cf" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qml-qtquick-pathview#pathItemCount-prop&quot;&gt;pathItemCount&lt;/a&gt; has been set, it is possible that some items may be instantiated, but not considered to be currently on the path. Usually, these items would be set invisible, for example:</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-pathview#pathItemCount-prop&quot;&gt;pathItemCount&lt;/a&gt; 가 설정된 경우 일부 항목이 인스턴스화 될 수 있지만 현재 경로에있는 것으로 간주되지 않을 수 있습니다. 일반적으로 이러한 항목은 다음과 같이 보이지 않게 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="16adb7770e2e57738ee531704424a03325211863" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qml-qtquick-pointerhandler&quot;&gt;PointerHandler&lt;/a&gt; is disabled, it will reject all events and no signals will be emitted.</source>
          <target state="translated">경우 &lt;a href=&quot;qml-qtquick-pointerhandler&quot;&gt;PointerHandler가&lt;/a&gt; 비활성화되어, 모든 이벤트를 거부하고 어떤 신호가 방출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74f82f1179aa599b0be710716e29d9a5a92c80f9" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qqmlnetworkaccessmanagerfactory&quot;&gt;QQmlNetworkAccessManagerFactory&lt;/a&gt; has been set and a QNetworkAccessManager has not yet been created, the &lt;a href=&quot;qqmlnetworkaccessmanagerfactory&quot;&gt;QQmlNetworkAccessManagerFactory&lt;/a&gt; will be used to create the QNetworkAccessManager; otherwise the returned QNetworkAccessManager will have no proxy or cache set.</source>
          <target state="translated">경우 &lt;a href=&quot;qqmlnetworkaccessmanagerfactory&quot;&gt;QQmlNetworkAccessManagerFactory가&lt;/a&gt; 된 세트를 가지고 있으며, QNetworkAccessManager가 아직 생성되지는 &lt;a href=&quot;qqmlnetworkaccessmanagerfactory&quot;&gt;QQmlNetworkAccessManagerFactory는&lt;/a&gt; QNetworkAccessManager을 만드는 데 사용됩니다; 그렇지 않으면 반환 된 QNetworkAccessManager에는 프록시 또는 캐시 세트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f19dca9b61cf098e69026f6c121f4d190c44d745" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow&lt;/a&gt; is the active window, the key event is delivered to it.</source>
          <target state="translated">경우 &lt;a href=&quot;qquickwindow&quot;&gt;QQuickWindow가&lt;/a&gt; 활성 창이다, 키 이벤트가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="38891016d54aedaece2a1ac7385ad0d44ee94320" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qssldiffiehellmanparameters&quot;&gt;QSslDiffieHellmanParameters&lt;/a&gt; object is not valid, you can use the &lt;a href=&quot;qssldiffiehellmanparameters#error&quot;&gt;error&lt;/a&gt;() method to determine what error prevented the object from being constructed.</source>
          <target state="translated">경우 &lt;a href=&quot;qssldiffiehellmanparameters&quot;&gt;QSslDiffieHellmanParameters의&lt;/a&gt; 객체가 유효하지 않습니다, 당신은 사용할 수 있습니다 &lt;a href=&quot;qssldiffiehellmanparameters#error&quot;&gt;오류가&lt;/a&gt; 건설되고에서 개체를 방지 어떤 오류를 확인하기 위해 () 메소드를.</target>
        </trans-unit>
        <trans-unit id="549567bdbfb0246f130a90365ef50535a695cd7b" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker&lt;/a&gt; is assigned to an entity with multiple children, an event will be triggered for each child entity that intersects the ray.</source>
          <target state="translated">경우 &lt;a href=&quot;qt3drender-qobjectpicker&quot;&gt;QObjectPicker가&lt;/a&gt; 여러 아이들과 함께 기업에 할당, 이벤트가 선을 교차하는 각 자식 엔터티에 대해 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="880d3d645240c092281c6896bcd6eaf0efef0910" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qtest#QVERIFY&quot;&gt;QVERIFY&lt;/a&gt;() or &lt;a href=&quot;qtest#QCOMPARE&quot;&gt;QCOMPARE&lt;/a&gt;() is marked as an expected failure, but passes instead, an unexpected pass (XPASS) is written to the test log.</source>
          <target state="translated">경우 &lt;a href=&quot;qtest#QVERIFY&quot;&gt;QVERIFY&lt;/a&gt; () 또는 &lt;a href=&quot;qtest#QCOMPARE&quot;&gt;QCOMPARE&lt;/a&gt; ()는 예상 실패로 표시 대신 전달되는 예기치 패스 (XPASS)는 테스트 로그에 기록된다.</target>
        </trans-unit>
        <trans-unit id="8a61352ccb25e25a0e7c278e6c81c738e00cfaf0" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qtquick-statesanimations-states#&quot;&gt;state change&lt;/a&gt; has a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt; that matches the same property as a Behavior, the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt; animation overrides the Behavior for that state change. For general advice on using Behaviors to animate state changes, see &lt;a href=&quot;qtquick-statesanimations-behaviors#&quot;&gt;Using Qt Quick Behaviors with States&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;qtquick-statesanimations-states#&quot;&gt;상태 변경이&lt;/a&gt; 가 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 비헤이비어와 같은 속성과 일치의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 애니메이션은 그 상태의 변화를위한 행동을 대체합니다. 상태 변경에 애니메이션을 적용하기 위해 동작을 사용하는 것에 대한 일반적인 조언은 상태 &lt;a href=&quot;qtquick-statesanimations-behaviors#&quot;&gt;와 함께 Qt 빠른 동작 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9752d0e7440c9b8d0708467bc1d52d0a3d4ef230" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qvalueaxis&quot;&gt;QValueAxis&lt;/a&gt; is used instead of &lt;a href=&quot;qbarcategoryaxis&quot;&gt;QBarCategoryAxis&lt;/a&gt; for the main bar axis, the bars are grouped around the index value of the category.</source>
          <target state="translated">경우 &lt;a href=&quot;qvalueaxis&quot;&gt;QValueAxis가&lt;/a&gt; 대신 사용된다 &lt;a href=&quot;qbarcategoryaxis&quot;&gt;QBarCategoryAxis&lt;/a&gt; 메인 축 바, 막대는 카테고리의 인덱스 값 주위 그룹화된다.</target>
        </trans-unit>
        <trans-unit id="932356b0c144fbc73097063e80e5c7a7ecd1eaba" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction&lt;/a&gt; is added for example to a &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt; then &lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction::createWidget&lt;/a&gt;() is called. Reimplementations of that function should create a new custom widget with the specified parent.</source>
          <target state="translated">경우 &lt;a href=&quot;qwidgetaction&quot;&gt;QWidgetAction가&lt;/a&gt; A를 예를 들어 추가 &lt;a href=&quot;qtoolbar&quot;&gt;QToolBar&lt;/a&gt; 다음 &lt;a href=&quot;qwidgetaction#createWidget&quot;&gt;QWidgetAction :: createWidget&lt;/a&gt; ()가 호출된다. 해당 함수를 다시 구현하면 지정된 상위를 가진 새로운 사용자 정의 위젯이 작성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c9c8d42199cdd29937be7168188b35d7590fe4a2" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Component{}&lt;/code&gt; object is defined and &lt;a href=&quot;qml-qtqml-component#createObject-method&quot;&gt;createObject()&lt;/a&gt; or &lt;a href=&quot;qml-qtqml-component#incubateObject-method&quot;&gt;incubateObject()&lt;/a&gt; is called on that object, the creation context is the context in which the &lt;code&gt;Component&lt;/code&gt; is defined</source>
          <target state="translated">경우 &lt;code&gt;Component{}&lt;/code&gt; 개체 정의와 &lt;a href=&quot;qml-qtqml-component#createObject-method&quot;&gt;CreateObject를 ()&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtqml-component#incubateObject-method&quot;&gt;incubateObject ()가&lt;/a&gt; 그 객체에 대한 호출은 생성 컨텍스트는 컨텍스트 인 &lt;code&gt;Component&lt;/code&gt; 정의는</target>
        </trans-unit>
        <trans-unit id="af82ee86f1e453105a7f26dfa928f14d24a5df7c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;mailto&lt;/code&gt; URL is specified, the user's e-mail client will be used to open a composer window containing the options specified in the URL, similar to the way &lt;code&gt;mailto&lt;/code&gt; links are handled by a Web browser.</source>
          <target state="translated">경우 &lt;code&gt;mailto&lt;/code&gt; URL을 지정, 사용자의 전자 메일 클라이언트 방식과 유사 URL에 지정된 옵션이 포함 된 작곡가 창을 여는 데 사용됩니다 &lt;code&gt;mailto&lt;/code&gt; 링크가 웹 브라우저에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e0f40a1e93a91154a4104bc2513f69e0482db6d4" translate="yes" xml:space="preserve">
          <source>If a C++ method has a parameter with a &lt;code&gt;QObject*&lt;/code&gt; type, the parameter value can be passed from QML using an object &lt;code&gt;id&lt;/code&gt; or a JavaScript &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; value that references the object.</source>
          <target state="translated">C ++ 메소드에 &lt;code&gt;QObject*&lt;/code&gt; 유형의 매개 변수가있는 경우, 오브젝트 &lt;code&gt;id&lt;/code&gt; 또는 오브젝트 를 참조 하는 JavaScript &lt;a href=&quot;qml-var&quot;&gt;var&lt;/a&gt; 값을 사용하여 QML에서 매개 변수 값을 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="847f98caf4b0f624d9e6b7dab988db884eb3dca6" translate="yes" xml:space="preserve">
          <source>If a Map is placed within an item that filters child mouse and touch events, such as Flickable, the mouse and touch events may be stolen from the &lt;a href=&quot;qml-qtlocation-mapgesturearea&quot;&gt;MapGestureArea&lt;/a&gt; if a gesture is recognized by the parent item, e.g. a flick gesture. If preventStealing is set to &lt;code&gt;true&lt;/code&gt;, no item will steal the mouse and touch events.</source>
          <target state="translated">Flickable과 같은 자식 마우스 및 터치 이벤트를 필터링하는 항목 내에지도를 배치 하면 제스처가 부모 항목 (예 : 제스처 제스처)에 의해 인식되는 경우 마우스 및 터치 이벤트가 &lt;a href=&quot;qml-qtlocation-mapgesturearea&quot;&gt;MapGestureArea&lt;/a&gt; 에서 도용 될 수 있습니다 . preventStealing이 &lt;code&gt;true&lt;/code&gt; 로 설정되면 항목이 마우스 및 터치 이벤트를 훔치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2483d60a0944d3a7de7856dc9f7e0acf98f42da" translate="yes" xml:space="preserve">
          <source>If a QML element has a custom property defined in QML, it becomes its own implicit type. This is explained in greater detail in an upcoming section. If multiple identical implicit types are defined inline in a component, some memory will be wasted. In that situation it is usually better to explicitly define a new component which can then be reused.</source>
          <target state="translated">QML 요소에 QML에 정의 된 사용자 정의 특성이 있으면 고유 한 내재 된 유형이됩니다. 이것은 다음 섹션에서 더 자세히 설명됩니다. 구성 요소에 여러 개의 동일한 암시 적 유형이 인라인으로 정의되면 일부 메모리가 낭비됩니다. 이러한 상황에서는 일반적으로 재사용 할 수있는 새 구성 요소를 명시 적으로 정의하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="556a645651685834426bf1eb219ed55a7cc69ffb" translate="yes" xml:space="preserve">
          <source>If a base URL has not been explicitly set, this method returns the application's current working directory.</source>
          <target state="translated">기본 URL이 명시 적으로 설정되지 않은 경우이 메소드는 응용 프로그램의 현재 작업 디렉토리를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5810c4baff349c86a7fb6168e8b5c65fb820f9bb" translate="yes" xml:space="preserve">
          <source>If a bounding rectangle is not required, create a &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; object without setting a preferred text width. The text will then occupy a single line.</source>
          <target state="translated">경계 사각형이 필요하지 않은 경우 기본 텍스트 너비를 설정하지 않고 &lt;a href=&quot;qstatictext&quot;&gt;QStaticText&lt;/a&gt; 객체를 만듭니다 . 그런 다음 텍스트는 한 줄을 차지합니다.</target>
        </trans-unit>
        <trans-unit id="227529f5f9f6cf9b67e9977da026881456ce6778" translate="yes" xml:space="preserve">
          <source>If a buddy has been set, the buddy mnemonic key is updated from the new text.</source>
          <target state="translated">친구가 설정되면 친구 니모닉 키가 새 텍스트에서 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="1a0ae9514a63dba2410466bb7a22cf4e5d40aef2" translate="yes" xml:space="preserve">
          <source>If a certificate error is raised while loading a web page, the &lt;a href=&quot;qml-qtwebengine-webengineview#certificateError-signal&quot;&gt;certificateError()&lt;/a&gt; signal is emitted. Certificate errors are handled by using the methods of the &lt;a href=&quot;qml-qtwebengine-webenginecertificateerror&quot;&gt;WebEngineCertificateError&lt;/a&gt; type.</source>
          <target state="translated">웹 페이지를로드하는 동안 인증서 오류가 발생하면 &lt;a href=&quot;qml-qtwebengine-webengineview#certificateError-signal&quot;&gt;certificateError ()&lt;/a&gt; 신호가 생성됩니다. 인증서 오류는 &lt;a href=&quot;qml-qtwebengine-webenginecertificateerror&quot;&gt;WebEngineCertificateError&lt;/a&gt; 유형 의 메소드를 사용하여 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="30b633239c5fe0c6351ad8adce1e9e4efc8fe5f8" translate="yes" xml:space="preserve">
          <source>If a characteristic is written using this mode, the peripheral shall send a write confirmation. If the operation is successful, the confirmation is emitted via the &lt;a href=&quot;qlowenergyservice#characteristicWritten&quot;&gt;characteristicWritten&lt;/a&gt;() signal. Otherwise the &lt;a href=&quot;qlowenergyservice#ServiceError-enum&quot;&gt;CharacteristicWriteError&lt;/a&gt; is emitted. A characteristic must have set the &lt;a href=&quot;qlowenergycharacteristic#PropertyType-enum&quot;&gt;QLowEnergyCharacteristic::Write&lt;/a&gt; property to support this write mode.</source>
          <target state="translated">이 모드를 사용하여 특성을 쓰면 주변 장치가 쓰기 확인을 보내야합니다. 동작이 성공적이면, 확인이 비아 출사 &lt;a href=&quot;qlowenergyservice#characteristicWritten&quot;&gt;characteristicWritten&lt;/a&gt; () 신호. 그렇지 않으면, &lt;a href=&quot;qlowenergyservice#ServiceError-enum&quot;&gt;특징 성 오류&lt;/a&gt; 가 발생합니다. 이 쓰기 모드를 지원 하려면 특성에 따라 &lt;a href=&quot;qlowenergycharacteristic#PropertyType-enum&quot;&gt;QLowEnergyCharacteristic :: Write&lt;/a&gt; 속성 이 설정되어 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="45c952c5c8d5025de227f6402e33a55b32f9ffb4" translate="yes" xml:space="preserve">
          <source>If a characteristic is written using this mode, the remote peripheral shall not send a write confirmation. The operation's success cannot be determined and the payload must not be longer than 20 bytes. A characteristic must have set the &lt;a href=&quot;qlowenergycharacteristic#PropertyType-enum&quot;&gt;QLowEnergyCharacteristic::WriteNoResponse&lt;/a&gt; property to support this write mode. Its adavantage is a quicker write operation as it may happen in between other device interactions.</source>
          <target state="translated">이 모드를 사용하여 특성을 쓰면 원격 주변 장치가 쓰기 확인을 보내지 않아야합니다. 작업의 성공 여부를 확인할 수 없으며 페이로드는 20 바이트를 넘지 않아야합니다. 특성은 이 쓰기 모드를 지원 하도록 &lt;a href=&quot;qlowenergycharacteristic#PropertyType-enum&quot;&gt;QLowEnergyCharacteristic :: WriteNoResponse&lt;/a&gt; 특성을 설정해야 합니다. 다른 장치 상호 작용간에 발생할 수있는 빠른 쓰기 작업입니다.</target>
        </trans-unit>
        <trans-unit id="9e331faeac7152c3fcdf0fa5543b3b72ccf29961" translate="yes" xml:space="preserve">
          <source>If a characteristic is written using this mode, the remote peripheral shall not send a write confirmation. The operation's success cannot be determined and the payload must not be longer than 8 bytes. A bond must exist between the two devices and the link must not be encrypted. A characteristic must have set the &lt;a href=&quot;qlowenergycharacteristic#PropertyType-enum&quot;&gt;QLowEnergyCharacteristic::WriteSigned&lt;/a&gt; property to support this write mode. This value was introduced in Qt 5.7 and is currently only supported on Android and on Linux with &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtbluetooth-attribution-bluez.html#&quot;&gt;BlueZ&lt;/a&gt; 5 and a kernel version 3.7 or newer.</source>
          <target state="translated">이 모드를 사용하여 특성을 쓰면 원격 주변 장치가 쓰기 확인을 보내지 않아야합니다. 작업의 성공 여부를 확인할 수 없으며 페이로드는 8 바이트를 넘지 않아야합니다. 두 장치 사이에 본드가 있어야하며 링크를 암호화해서는 안됩니다. 이 쓰기 모드를 지원 &lt;a href=&quot;qlowenergycharacteristic#PropertyType-enum&quot;&gt;하려면&lt;/a&gt; 특성에 따라 QLowEnergyCharacteristic :: WriteSigned 속성 이 설정되어 있어야 합니다. 이 값은 Qt 5.7에서 도입되었으며 현재 Android 및 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtbluetooth-attribution-bluez.html#&quot;&gt;BlueZ&lt;/a&gt; 5 및 커널 버전 3.7 이상이 설치된 Linux에서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd5be07a2d70dcff0ae5d03710a3e41e582301c7" translate="yes" xml:space="preserve">
          <source>If a chosen font does not include all the characters that need to be displayed, &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; will try to find the characters in the nearest equivalent fonts. When a &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; draws a character from a font the &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; will report whether or not it has the character; if it does not, &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; will draw an unfilled square.</source>
          <target state="translated">선택한 글꼴에 표시해야 할 모든 문자가 포함되어 있지 않으면 &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; 는 가장 가까운 해당 글꼴에서 문자를 찾으려고합니다. &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 가 글꼴에서 문자를 그릴 때 &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt; 는 해당 문자가 있는지 여부를보고합니다. 그렇지 않으면 &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 는 채워지지 않은 사각형을 그립니다.</target>
        </trans-unit>
        <trans-unit id="b32b42dac4a5df175709c3d6499113f958301018" translate="yes" xml:space="preserve">
          <source>If a client is currently connected and it has enabled notifications or indications for the characteristic, the respective information will be sent. If a device has enabled notifications or indications for the characteristic and that device is currently not connected, but a bond exists between it and the local device, then the notification or indication will be sent on the next reconnection.</source>
          <target state="translated">클라이언트가 현재 연결되어 있고 특성에 대한 알림 또는 표시를 활성화 한 경우 해당 정보가 전송됩니다. 장치가 특성에 대한 알림 또는 표시를 활성화하고 해당 장치가 현재 연결되어 있지 않지만 해당 장치와 로컬 장치 사이에 본드가있는 경우 다음에 다시 연결할 때 알림 또는 표시가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="7970922cae74c01fae7ad1f3ad029b5d6fdf1ded" translate="yes" xml:space="preserve">
          <source>If a color is specified, the provided image will be colorized with it.</source>
          <target state="translated">색상이 지정되면 제공된 이미지가 색상으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="34e82170c73c433f9afff848d75498019ec46832" translate="yes" xml:space="preserve">
          <source>If a command is set obsolete and the clean index is greater than or equal to the current command index, then the clean index will be reset when the command is deleted from the stack.</source>
          <target state="translated">명령이 더 이상 사용되지 않고 정리 색인이 현재 명령 색인보다 크거나 같으면 스택에서 명령을 삭제할 때 정리 색인이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="632568c94fcfdd6969f5057de49174ffa015cfe1" translate="yes" xml:space="preserve">
          <source>If a configuration state changes as a result of this update all existing &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration&lt;/a&gt; instances are updated automatically.</source>
          <target state="translated">이 업데이트로 인해 구성 상태가 변경되면 기존의 모든 &lt;a href=&quot;qnetworkconfiguration&quot;&gt;QNetworkConfiguration&lt;/a&gt; 인스턴스가 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="00977ba4c14a146dd39b46a997ec377dc60960a2" translate="yes" xml:space="preserve">
          <source>If a cookie already exists in the cookie jar, it will be overridden by those in</source>
          <target state="translated">쿠키 항아리에 쿠키가 이미 존재하는 경우 쿠키 항아리에 쿠키가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="8e9941b553378981a798179ceab66ee3a4b43d53" translate="yes" xml:space="preserve">
          <source>If a cookie with the same identifier already exists in the cookie jar, it will be overridden.</source>
          <target state="translated">동일한 식별자를 가진 쿠키가 쿠키 항아리에 이미 존재하는 경우이를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="84e18d07e8061f9a5b6cb2f60de1881e51d8ead5" translate="yes" xml:space="preserve">
          <source>If a cookie with the same identifier as</source>
          <target state="translated">동일한 식별자를 가진 쿠키가</target>
        </trans-unit>
        <trans-unit id="584f18a696b7dfa7aa94ae05461801d2019fb078" translate="yes" xml:space="preserve">
          <source>If a cursor is used to insert text without specifying a character format, the text will be given the character format used at that position in the document.</source>
          <target state="translated">문자 형식을 지정하지 않고 텍스트를 삽입하는 데 커서를 사용하는 경우 문서의 해당 위치에서 사용되는 문자 형식이 텍스트에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f5c2c927b7328d890b48d70550ec9f63fd5c4fd4" translate="yes" xml:space="preserve">
          <source>If a dedicated render thread is used, the GUI thread should be blocked for the duration of this call.</source>
          <target state="translated">전용 렌더링 스레드를 사용하는 경우이 호출 기간 동안 GUI 스레드를 차단해야합니다.</target>
        </trans-unit>
        <trans-unit id="4cd9fe08f39a62808db2fd6ccbcab76961ee977c" translate="yes" xml:space="preserve">
          <source>If a default prototype has been registered for the</source>
          <target state="translated">에 대한 기본 프로토 타입이 등록 된 경우</target>
        </trans-unit>
        <trans-unit id="cd0939f084c811030400247e036fe01ace361b25" translate="yes" xml:space="preserve">
          <source>If a different widget is currently grabbing keyboard input, that widget's grab is released first.</source>
          <target state="translated">다른 위젯이 현재 키보드 입력을 잡고있는 경우 해당 위젯의 그랩이 먼저 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="6b8ae1edceefdac372d6ef4691570042b60d9c79" translate="yes" xml:space="preserve">
          <source>If a document name ends with an anchor (for example, &quot;&lt;code&gt;#anchor&quot;&lt;/code&gt;), the text browser automatically scrolls to that position (using &lt;a href=&quot;qtextedit#scrollToAnchor&quot;&gt;scrollToAnchor&lt;/a&gt;()). When the user clicks on a hyperlink, the browser will call &lt;a href=&quot;qtextbrowser#source-prop&quot;&gt;setSource&lt;/a&gt;() itself with the link's &lt;code&gt;href&lt;/code&gt; value as argument. You can track the current source by connecting to the &lt;a href=&quot;qtextbrowser#sourceChanged&quot;&gt;sourceChanged&lt;/a&gt;() signal.</source>
          <target state="translated">문서 이름이 앵커로 끝나는 경우 (예 : &quot; &lt;code&gt;#anchor&quot;&lt;/code&gt; ), 텍스트 브라우저는 자동으로 해당 위치로 스크롤합니다 ( &lt;a href=&quot;qtextedit#scrollToAnchor&quot;&gt;scrollToAnchor&lt;/a&gt; () 사용). 사용자가 하이퍼 링크를 클릭하면 브라우저는 링크의 &lt;code&gt;href&lt;/code&gt; 값을 인수로 하여 &lt;a href=&quot;qtextbrowser#source-prop&quot;&gt;setSource&lt;/a&gt; () 자체를 호출 합니다. &lt;a href=&quot;qtextbrowser#sourceChanged&quot;&gt;sourceChanged&lt;/a&gt; () 신호 에 연결하여 현재 소스를 추적 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f55bf52e6f51a2641b4bb92bed5927de97d34108" translate="yes" xml:space="preserve">
          <source>If a family exists in several foundries, the returned name for that font is in the form &quot;family [foundry]&quot;. Examples: &quot;Times [Adobe]&quot;, &quot;Times [Cronyx]&quot;, &quot;Palatino&quot;.</source>
          <target state="translated">패밀리가 여러 파운드리에 존재하는 경우 해당 글꼴의 리턴 이름은 &quot;family [foundry]&quot;형식입니다. 예 : &quot;Times [Adobe]&quot;, &quot;Times [Cronyx]&quot;, &quot;Palatino&quot;.</target>
        </trans-unit>
        <trans-unit id="2ffb089b7ed2bacaadd840016ea77c686b888a71" translate="yes" xml:space="preserve">
          <source>If a field is empty, don't include it in the result.</source>
          <target state="translated">필드가 비어 있으면 결과에 포함하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="420ca8d5e64c7a1eea7b75befe4fc6af8a304475" translate="yes" xml:space="preserve">
          <source>If a field is empty, keep it in the result.</source>
          <target state="translated">필드가 비어 있으면 결과를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="72bc86cf06cfe5b885cc19500a8bcc6ff270bf7b" translate="yes" xml:space="preserve">
          <source>If a file already exists at the provided file path, it will be overwritten.</source>
          <target state="translated">제공된 파일 경로에 파일이 이미 있으면 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="42162e59b297b81b5c9b9226cf645e8d5b558b5f" translate="yes" xml:space="preserve">
          <source>If a file contains only a single animation, there is no need to specify the animationIndex or animationName. We simply use the one available animation.</source>
          <target state="translated">파일에 단일 애니메이션 만 포함 된 경우 animationIndex 또는 animationName을 지정할 필요가 없습니다. 사용 가능한 애니메이션 하나만 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="fef1db71c18145f4af4b50d6d3e5070db3d4be7d" translate="yes" xml:space="preserve">
          <source>If a file or directory cannot be removed, removeRecursively() keeps going and attempts to delete as many files and sub-directories as possible, then returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">파일이나 디렉토리를 제거 할 수없는 경우 removeRecursively ()는 계속 진행하여 가능한 한 많은 파일과 하위 디렉토리를 삭제하려고 시도한 다음 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9d756525b307805f60676aa277d0da87d37e549e" translate="yes" xml:space="preserve">
          <source>If a file with the name</source>
          <target state="translated">이름이있는 파일 인 경우</target>
        </trans-unit>
        <trans-unit id="327fef7dfb03d8451fe7bd7489aa55fd78cfeacc" translate="yes" xml:space="preserve">
          <source>If a filter has not been set, the default filter is &lt;a href=&quot;qdir#Filter-enum&quot;&gt;QDir::AllEntries&lt;/a&gt; | &lt;a href=&quot;qdir#Filter-enum&quot;&gt;QDir::NoDotAndDotDot&lt;/a&gt; | &lt;a href=&quot;qdir#Filter-enum&quot;&gt;QDir::AllDirs&lt;/a&gt;.</source>
          <target state="translated">필터가 설정되지 않은 경우 기본 필터는 &lt;a href=&quot;qdir#Filter-enum&quot;&gt;QDir :: AllEntries&lt;/a&gt; | &lt;a href=&quot;qdir#Filter-enum&quot;&gt;QDir :: NoDotAndDotDot&lt;/a&gt; | &lt;a href=&quot;qdir#Filter-enum&quot;&gt;QDir :: AllDirs&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="298fd082c87fa0a2176eba011cae6c727bbc09a0" translate="yes" xml:space="preserve">
          <source>If a given</source>
          <target state="translated">주어진 경우</target>
        </trans-unit>
        <trans-unit id="8cf3a1dbf4e8a17114f4f7a59e7dec996082c97f" translate="yes" xml:space="preserve">
          <source>If a group is set using &lt;a href=&quot;qsettings#beginGroup&quot;&gt;beginGroup&lt;/a&gt;(),</source>
          <target state="translated">&lt;a href=&quot;qsettings#beginGroup&quot;&gt;beginGroup&lt;/a&gt; ()을 사용하여 그룹을 설정하면</target>
        </trans-unit>
        <trans-unit id="e35f03c7e2e266ff29e2927aae8c518fadf9dc8e" translate="yes" xml:space="preserve">
          <source>If a group is set using &lt;a href=&quot;qsettings#beginGroup&quot;&gt;beginGroup&lt;/a&gt;(), only the keys in the group are returned, without the group prefix:</source>
          <target state="translated">&lt;a href=&quot;qsettings#beginGroup&quot;&gt;beginGroup&lt;/a&gt; ()을 사용하여 그룹을 설정 하면 그룹 접두어없이 그룹의 키만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fb59e76e793eab04c7d590e093dc65e5124c05b4" translate="yes" xml:space="preserve">
          <source>If a group is set using &lt;a href=&quot;qsettings#beginGroup&quot;&gt;beginGroup&lt;/a&gt;(), the behavior of most functions changes consequently. Groups can be set recursively.</source>
          <target state="translated">&lt;a href=&quot;qsettings#beginGroup&quot;&gt;beginGroup&lt;/a&gt; ()을 사용하여 그룹을 설정하면 대부분의 기능 동작이 변경됩니다. 그룹은 재귀 적으로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fbe5adbee0e4639871d41b3bfac62e6990531d1" translate="yes" xml:space="preserve">
          <source>If a group is set using &lt;a href=&quot;qsettings#beginGroup&quot;&gt;beginGroup&lt;/a&gt;(), the first-level keys in that group are returned, without the group prefix.</source>
          <target state="translated">&lt;a href=&quot;qsettings#beginGroup&quot;&gt;beginGroup&lt;/a&gt; ()을 사용하여 그룹을 설정 하면 그룹 접두사없이 해당 그룹의 첫 번째 수준 키가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9670e1103a24fe6713fa045ff0cd378ded52d58f" translate="yes" xml:space="preserve">
          <source>If a group is set using &lt;a href=&quot;qsettings#beginGroup&quot;&gt;beginGroup&lt;/a&gt;(), the top-level keys in that group are returned, without the group prefix:</source>
          <target state="translated">&lt;a href=&quot;qsettings#beginGroup&quot;&gt;beginGroup&lt;/a&gt; ()을 사용하여 그룹을 설정 하면 그룹 접두사없이 해당 그룹의 최상위 키가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8b8da60d564b3ad513cd9904b56ae9af8d5ebb19" translate="yes" xml:space="preserve">
          <source>If a high resolution version of the image exists (identified by the suffix &lt;code&gt;@2x&lt;/code&gt; on the base name), it is automatically loaded and added with the</source>
          <target state="translated">이미지의 고해상도 버전이 존재하는 경우 ( 기본 이름 의 접미사 &lt;code&gt;@2x&lt;/code&gt; 식별 ) 자동으로로드되고</target>
        </trans-unit>
        <trans-unit id="8f400be43e441fb2a63b34664b3fd63251d14db9" translate="yes" xml:space="preserve">
          <source>If a key cannot be found in the first location, the search goes on in the second location, and so on. This enables you to store system-wide or organization-wide settings and to override them on a per-user or per-application basis. To turn off this mechanism, call &lt;a href=&quot;qsettings#setFallbacksEnabled&quot;&gt;setFallbacksEnabled&lt;/a&gt;(false).</source>
          <target state="translated">첫 번째 위치에서 키를 찾을 수 없으면 두 번째 위치에서 검색이 계속됩니다. 이를 통해 시스템 전체 또는 조직 전체 설정을 저장하고 사용자 별 또는 응용 프로그램별로이를 재정의 할 수 있습니다. 이 메커니즘을 끄려면 &lt;a href=&quot;qsettings#setFallbacksEnabled&quot;&gt;setFallbacksEnabled&lt;/a&gt; (false)를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="bab32162fe4d4f26c362cc67dc894cae9494d192" translate="yes" xml:space="preserve">
          <source>If a label displays text, the indent applies to the left edge if &lt;a href=&quot;qlabel#alignment-prop&quot;&gt;alignment&lt;/a&gt;() is &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt::AlignLeft&lt;/a&gt;, to the right edge if &lt;a href=&quot;qlabel#alignment-prop&quot;&gt;alignment&lt;/a&gt;() is &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt::AlignRight&lt;/a&gt;, to the top edge if &lt;a href=&quot;qlabel#alignment-prop&quot;&gt;alignment&lt;/a&gt;() is &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt::AlignTop&lt;/a&gt;, and to the bottom edge if &lt;a href=&quot;qlabel#alignment-prop&quot;&gt;alignment&lt;/a&gt;() is &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt::AlignBottom&lt;/a&gt;.</source>
          <target state="translated">경우 레이블 텍스트를 표시하는 경우, 들여 쓰기는 왼쪽 가장자리에 적용 &lt;a href=&quot;qlabel#alignment-prop&quot;&gt;정렬&lt;/a&gt; ()는 &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt는 :: AlignLeft&lt;/a&gt; 경우 오른쪽 가장자리에 &lt;a href=&quot;qlabel#alignment-prop&quot;&gt;정렬&lt;/a&gt; ()는 &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt는 :: AlignRight&lt;/a&gt; 경우 위쪽 가장자리에 &lt;a href=&quot;qlabel#alignment-prop&quot;&gt;정렬&lt;/a&gt; ()는 &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt는이 :: AlignTop을 &lt;/a&gt;&lt;a href=&quot;qlabel#alignment-prop&quot;&gt;alignment&lt;/a&gt; ()가 &lt;a href=&quot;qt#AlignmentFlag-enum&quot;&gt;Qt :: AlignBottom 인&lt;/a&gt; 경우 하단 가장자리로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="6b4bc4bb2d3a5292b76135912322d7ae35582e97" translate="yes" xml:space="preserve">
          <source>If a larger number of touchpoints are in contact with the &lt;a href=&quot;qml-qtquick-multipointhandler#parent-prop&quot;&gt;parent&lt;/a&gt;, the required number of points will be chosen in the order that they are pressed, and the remaining points will be ignored.</source>
          <target state="translated">더 많은 터치 포인트가 &lt;a href=&quot;qml-qtquick-multipointhandler#parent-prop&quot;&gt;부모&lt;/a&gt; 와 접촉하는 경우 필요한 포인트 수는 누른 순서대로 선택되며 나머지 포인트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3036e33337d775e1d3a08fda40693447c8d87e1f" translate="yes" xml:space="preserve">
          <source>If a list contains only one element, we generally omit the square brackets.</source>
          <target state="translated">목록에 하나의 요소 만 포함 된 경우 일반적으로 대괄호는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="f76437a41a2b960e8683d59fa98661ca864cd446" translate="yes" xml:space="preserve">
          <source>If a match is attempted with an invalid &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt;, then the returned &lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt; object will be invalid as well (that is, its &lt;a href=&quot;qregularexpressionmatch#isValid&quot;&gt;isValid()&lt;/a&gt; function will return false). The same applies for attempting a global match.</source>
          <target state="translated">유효하지 않은 &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; 으로 일치를 시도 하면 리턴 된 &lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt; 오브젝트도 유효하지 않습니다 (즉, &lt;a href=&quot;qregularexpressionmatch#isValid&quot;&gt;isValid ()&lt;/a&gt; 함수는 false를 리턴 함). 글로벌 경기 시도에도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="46138ece73285f410a8ab239936c0a3ee0dc3438" translate="yes" xml:space="preserve">
          <source>If a match is successful, the (implicit) capturing group number 0 can be used to retrieve the substring matched by the entire pattern (see also the section about &lt;a href=&quot;qregularexpression#extracting-captured-substrings&quot;&gt;extracting captured substrings&lt;/a&gt;):</source>
          <target state="translated">일치하는 경우, (암시 적) 캡처 그룹 번호 0을 사용하여 전체 패턴과 일치하는 서브 스트링을 검색 할 수 있습니다 ( &lt;a href=&quot;qregularexpression#extracting-captured-substrings&quot;&gt;캡처 된 서브 스트링 추출&lt;/a&gt; 섹션 참조 ).</target>
        </trans-unit>
        <trans-unit id="e5f4ea3ee07aae7ee1d879c61c579319eee7563d" translate="yes" xml:space="preserve">
          <source>If a member function is also const-overloaded &lt;a href=&quot;qtglobal#qConstOverload&quot;&gt;qConstOverload&lt;/a&gt; and &lt;a href=&quot;qtglobal#qNonConstOverload&quot;&gt;qNonConstOverload&lt;/a&gt; need to be used.</source>
          <target state="translated">멤버 함수도 const-overload 된 경우 &lt;a href=&quot;qtglobal#qConstOverload&quot;&gt;qConstOverload&lt;/a&gt; 및 &lt;a href=&quot;qtglobal#qNonConstOverload&quot;&gt;qNonConstOverload를&lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9834eecc16dabf8bfc44182c2f5939bdf318fdcc" translate="yes" xml:space="preserve">
          <source>If a menu does not fit on the screen it lays itself out so that it does fit. It is style dependent what layout means (for example, on Windows it will use multiple columns).</source>
          <target state="translated">메뉴가 화면에 맞지 않으면 메뉴가 화면에 맞게 표시됩니다. 레이아웃의 의미에 따라 스타일이 달라집니다 (예 : Windows에서는 여러 열을 사용함).</target>
        </trans-unit>
        <trans-unit id="b0237086ee86031f65983b84fe2b1c555b1528b1" translate="yes" xml:space="preserve">
          <source>If a menu item is checkable, an &lt;a href=&quot;qml-qtquick-controls-exclusivegroup&quot;&gt;ExclusiveGroup&lt;/a&gt; can be attached to it. All the menu items sharing the same exclusive group, and by extension, any &lt;a href=&quot;qml-qtquick-controls-action&quot;&gt;Action&lt;/a&gt; sharing it, become mutually exclusive selectable, meaning that only the last checked menu item will actually be checked.</source>
          <target state="translated">메뉴 항목을 확인할 수 있으면 &lt;a href=&quot;qml-qtquick-controls-exclusivegroup&quot;&gt;ExclusiveGroup을 추가&lt;/a&gt; 할 수 있습니다. 동일한 배타적 그룹을 공유하는 모든 메뉴 항목과 확장하여 공유하는 모든 &lt;a href=&quot;qml-qtquick-controls-action&quot;&gt;동작&lt;/a&gt; 은 상호 배타적으로 선택할 수있게되므로 마지막으로 확인한 메뉴 항목 만 실제로 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="cdf5b4ecd42a547685dc141e19733b012c2004b2" translate="yes" xml:space="preserve">
          <source>If a message text is too long, it will be automatically truncated by &lt;a href=&quot;qopengldebuglogger&quot;&gt;QOpenGLDebugLogger&lt;/a&gt;.</source>
          <target state="translated">메시지 텍스트가 너무 길면 &lt;a href=&quot;qopengldebuglogger&quot;&gt;QOpenGLDebugLogger에&lt;/a&gt; 의해 자동으로 잘립니다 .</target>
        </trans-unit>
        <trans-unit id="a6fbf644dff9583f1f414c0991e691c2e8b04f4d" translate="yes" xml:space="preserve">
          <source>If a mid-line width greater than 0 is specified, an additional line is drawn for &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;Raised&lt;/a&gt; or &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;Sunken&lt;/a&gt;&lt;a href=&quot;qframe#Shape-enum&quot;&gt;Box&lt;/a&gt;, &lt;a href=&quot;qframe#Shape-enum&quot;&gt;HLine&lt;/a&gt;, and &lt;a href=&quot;qframe#Shape-enum&quot;&gt;VLine&lt;/a&gt; frames. The mid-color of the current color group is used for drawing middle lines.</source>
          <target state="translated">중간 선 너비가 0보다 큰 경우 &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;Raised&lt;/a&gt; 또는 &lt;a href=&quot;qframe#Shadow-enum&quot;&gt;Sunken &lt;/a&gt;&lt;a href=&quot;qframe#Shape-enum&quot;&gt;Box&lt;/a&gt; , &lt;a href=&quot;qframe#Shape-enum&quot;&gt;HLine&lt;/a&gt; 및 &lt;a href=&quot;qframe#Shape-enum&quot;&gt;VLine&lt;/a&gt; 프레임에 대해 추가 선이 그려집니다 . 현재 색상 그룹의 중간 색상은 중간 선을 그리는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8c9b54a15e009f0374b271f901d9b82b6e831f9b" translate="yes" xml:space="preserve">
          <source>If a multisample framebuffer object is used then the value returned from this function will be invalid.</source>
          <target state="translated">멀티 샘플 프레임 버퍼 객체를 사용하면이 함수에서 반환 된 값이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a8fbea91b869a1d81b290927bbc5cf19a82e9f7" translate="yes" xml:space="preserve">
          <source>If a multisample framebuffer object is used, then an empty vector is returned.</source>
          <target state="translated">다중 샘플 프레임 버퍼 객체를 사용하면 빈 벡터가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0859851e9a0e3a5d7ac48f4760c17fc01cfd1e0d" translate="yes" xml:space="preserve">
          <source>If a multisample framebuffer object is used, then there is no texture and the return value from this function will be invalid. Similarly, incomplete framebuffer objects will also return 0.</source>
          <target state="translated">멀티 샘플 프레임 버퍼 객체를 사용하는 경우 텍스처가없고이 함수의 반환 값이 유효하지 않습니다. 마찬가지로, 불완전한 프레임 버퍼 객체도 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d34a9f091c878bcc2ffb1fc657297f642aeecb86" translate="yes" xml:space="preserve">
          <source>If a negative value is specified, the camera will automatically determine an appropriate value.</source>
          <target state="translated">음수 값을 지정하면 카메라가 자동으로 적절한 값을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="eddb7a57d953884ad3f72dc93561e6653bbc7e9d" translate="yes" xml:space="preserve">
          <source>If a new &lt;a href=&quot;qqmlfileselector&quot;&gt;QQmlFileSelector&lt;/a&gt; is set on the engine, the old one will be replaced. Use &lt;a href=&quot;qqmlfileselector#get&quot;&gt;QQmlFileSelector::get&lt;/a&gt;() to query or use the existing instance.</source>
          <target state="translated">엔진에 새로운 &lt;a href=&quot;qqmlfileselector&quot;&gt;QQmlFileSelector&lt;/a&gt; 가 설정되어 있으면 기존 QQmlFileSelector 가 교체됩니다. 사용 &lt;a href=&quot;qqmlfileselector#get&quot;&gt;QQmlFileSelector는 :: 얻을&lt;/a&gt; () 쿼리 또는 기존 인스턴스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c0859215ec0f4eb2a23344fb742e91d60c98085a" translate="yes" xml:space="preserve">
          <source>If a new default &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; with a modified OpenGL profile has to be set, it should be set before the application instance is declared, to make sure that all created OpenGL contexts use the same OpenGL profile.</source>
          <target state="translated">수정 된 OpenGL 프로파일이 있는 새로운 기본 &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; 을 설정해야하는 경우, 작성된 모든 OpenGL 컨텍스트가 동일한 OpenGL 프로파일을 사용하도록 응용 프로그램 인스턴스를 선언하기 전에 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e22afc6d2a7a61dc6e6c74df5e4c096461328922" translate="yes" xml:space="preserve">
          <source>If a new item is replaced in the &lt;a href=&quot;qml-qtqml-models-delegatemodelgroup&quot;&gt;DelegateModelGroup&lt;/a&gt; onChanged() handler its insertion and replacement will be communicated to views as an atomic operation, creating the appearance that the model contents have not changed, or if the unresolved and model item are not adjacent that the previously unresolved item has simply moved.</source>
          <target state="translated">&lt;a href=&quot;qml-qtqml-models-delegatemodelgroup&quot;&gt;DelegateModelGroup&lt;/a&gt; onChanged () 핸들러 에서 새 항목이 교체되면 삽입 및 교체는 원자 적 조작으로보기에 전달되어 모델 컨텐츠가 변경되지 않은 것처럼 보이게하거나 해결되지 않은 모델 항목이 이전에 해결되지 않은 항목이 단순히 이동했습니다.</target>
        </trans-unit>
        <trans-unit id="fa8f8630e7fb7833571914468cbddf26c77822f0" translate="yes" xml:space="preserve">
          <source>If a new result set is available this function will return true. The query will be repositioned on an</source>
          <target state="translated">새로운 결과 세트가 사용 가능한 경우이 함수는 true를 리턴합니다. 쿼리는</target>
        </trans-unit>
        <trans-unit id="aea05eda839a63653e7000d13345c28e7d0c1d2f" translate="yes" xml:space="preserve">
          <source>If a node does not have a name, e.g., comment nodes, a null &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; is returned. QXmlNames must be created with the instance of &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; that is being used for evaluating queries using this &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel&lt;/a&gt;.</source>
          <target state="translated">노드에 이름이없는 경우 (예 : 주석 노드) 널 &lt;a href=&quot;qxmlname&quot;&gt;QXmlName&lt;/a&gt; 이 리턴됩니다. 이 &lt;a href=&quot;qabstractxmlnodemodel&quot;&gt;QAbstractXmlNodeModel을&lt;/a&gt; 사용하여 쿼리를 평가하는 데 사용되는 &lt;a href=&quot;qxmlquery&quot;&gt;QXmlQuery&lt;/a&gt; 인스턴스로 QXmlName 을 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3453fd92592fa0ab1def36e1c299dccd39770331" translate="yes" xml:space="preserve">
          <source>If a non-empty string is assigned to &lt;code&gt;text&lt;/code&gt;, then &lt;a href=&quot;qml-qtpositioning-address#isTextGenerated-prop&quot;&gt;isTextGenerated&lt;/a&gt; will be set to false and &lt;code&gt;text&lt;/code&gt; will always return the explicitly assigned string. Modifying address properties will not affect the &lt;code&gt;text&lt;/code&gt; property.</source>
          <target state="translated">비어 있지 않은 문자열에 할당 된 경우 &lt;code&gt;text&lt;/code&gt; , 다음 &lt;a href=&quot;qml-qtpositioning-address#isTextGenerated-prop&quot;&gt;isTextGenerated는&lt;/a&gt; false로 설정되고 &lt;code&gt;text&lt;/code&gt; 항상 명시 적으로 할당 된 문자열을 반환합니다. 주소 속성을 수정해도 &lt;code&gt;text&lt;/code&gt; 속성 에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ba51ef6d069f1c2b0a932bcc6b975796816f33ff" translate="yes" xml:space="preserve">
          <source>If a non-empty string is provided to &lt;a href=&quot;qgeoaddress#setText&quot;&gt;setText&lt;/a&gt;(), then &lt;a href=&quot;qgeoaddress#isTextGenerated&quot;&gt;isTextGenerated&lt;/a&gt;() will be set to false and text() will always return the explicitly assigned string. Calls to modify other elements such as &lt;a href=&quot;qgeoaddress#setStreet&quot;&gt;setStreet&lt;/a&gt;(), &lt;a href=&quot;qgeoaddress#setCity&quot;&gt;setCity&lt;/a&gt;() and so on will not affect the resultant string from text().</source>
          <target state="translated">비어 있지 않은 문자열이 &lt;a href=&quot;qgeoaddress#setText&quot;&gt;setText&lt;/a&gt; ()에 제공되면 &lt;a href=&quot;qgeoaddress#isTextGenerated&quot;&gt;isTextGenerated&lt;/a&gt; ()가 false로 설정되고 text ()는 항상 명시 적으로 지정된 문자열을 반환합니다. &lt;a href=&quot;qgeoaddress#setStreet&quot;&gt;setStreet&lt;/a&gt; (), &lt;a href=&quot;qgeoaddress#setCity&quot;&gt;setCity&lt;/a&gt; () 등과 같은 다른 요소를 수정하기위한 호출 은 text ()의 결과 문자열에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="234ea25aa0f59af11bf77ed55dd0bd3a82b30994" translate="yes" xml:space="preserve">
          <source>If a non-power-of-two</source>
          <target state="translated">2의 제곱이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="9559b075ec291a437e1bffc2cd61dafb70487aec" translate="yes" xml:space="preserve">
          <source>If a null certificate is returned, it can mean the SSL handshake failed, or it can mean the host you are connected to doesn't have a certificate, or it can mean there is no connection.</source>
          <target state="translated">null 인증서가 반환되면 SSL 핸드 셰이크가 실패했거나 연결된 호스트에 인증서가 없거나 연결이 없음을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a87e9b9995629325536fc77fc58748f87333dd6" translate="yes" xml:space="preserve">
          <source>If a null icon (&lt;a href=&quot;qicon#isNull&quot;&gt;QIcon::isNull&lt;/a&gt;()) is passed into this function, the icon of the action is cleared.</source>
          <target state="translated">널 아이콘 ( &lt;a href=&quot;qicon#isNull&quot;&gt;QIcon :: isNull&lt;/a&gt; ())이이 함수에 전달되면 조치 아이콘이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="9a73fcbcc6f49fb22af0965f90e013eea87c6438" translate="yes" xml:space="preserve">
          <source>If a null widget is specified, the event is sent to the action's parent.</source>
          <target state="translated">널 위젯이 지정되면 이벤트가 조치의 상위로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="fa19d5ca0d64cc04007dc9aba5ab05882de85238" translate="yes" xml:space="preserve">
          <source>If a parent item handles child events, it will receive hover move, drag move, and drop events as the cursor passes through its children, but it does not receive hover enter and hover leave, nor drag enter and drag leave events on behalf of its children.</source>
          <target state="translated">부모 항목이 자식 이벤트를 처리하는 경우 커서가 자식을 통과 할 때 호버 이동, 끌기 이동 및 놓기 이벤트가 수신되지만 마우스 오버 항목을 가리 키거나 마우스를 가져 가거나 이벤트 대신 끌어서 놓기 이벤트를 끌지 않습니다. 어린이.</target>
        </trans-unit>
        <trans-unit id="6e80f1a5778ee506ddbc56c1878be18a11e8b771" translate="yes" xml:space="preserve">
          <source>If a parse error occurs an empty NDEF message is returned.</source>
          <target state="translated">구문 분석 오류가 발생하면 빈 NDEF 메시지가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="78af170b0b6211596352f325e75340be51b4b1d8" translate="yes" xml:space="preserve">
          <source>If a parse error occurs, this function returns &lt;code&gt;false&lt;/code&gt; and the error message is placed in &lt;code&gt;*&lt;/code&gt;</source>
          <target state="translated">구문 분석 오류가 발생하면이 함수는 &lt;code&gt;false&lt;/code&gt; 를 반환 하고 오류 메시지는 &lt;code&gt;*&lt;/code&gt; 에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="48c008c8638dfdd9adf0e41e268bddee85b536c6" translate="yes" xml:space="preserve">
          <source>If a path specifies a directory, the &lt;a href=&quot;qfilesystemwatcher#directoryChanged&quot;&gt;directoryChanged&lt;/a&gt;() signal will be emitted when the path is modified or removed from disk; otherwise the &lt;a href=&quot;qfilesystemwatcher#fileChanged&quot;&gt;fileChanged&lt;/a&gt;() signal is emitted when the path is modified, renamed, or removed.</source>
          <target state="translated">경로가 디렉토리를 지정 하면 경로가 디스크에서 수정되거나 디스크에서 제거 될 때 &lt;a href=&quot;qfilesystemwatcher#directoryChanged&quot;&gt;directoryChanged&lt;/a&gt; () 신호가 생성됩니다. 그렇지 않으면 경로가 수정, 이름 변경 또는 제거 될 때 &lt;a href=&quot;qfilesystemwatcher#fileChanged&quot;&gt;fileChanged&lt;/a&gt; () 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eedb704835ae9cbbf2689b4b04433e02fe2c4077" translate="yes" xml:space="preserve">
          <source>If a platform doesn't support the source sensor, then the sensor cannot be emulated.</source>
          <target state="translated">플랫폼이 소스 센서를 지원하지 않으면 센서를 에뮬레이션 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="19affd57d28bc0f75b56f6b4b38403229f8cb3b3" translate="yes" xml:space="preserve">
          <source>If a plugin does not provide an engine the relevant function should return 0.</source>
          <target state="translated">플러그인이 엔진을 제공하지 않으면 관련 함수는 0을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="e97efc94bd905d4c3e2d3f882665e081625a56ca" translate="yes" xml:space="preserve">
          <source>If a problem occurs during this process, &lt;a href=&quot;qaudioinput#error&quot;&gt;error&lt;/a&gt;() returns &lt;a href=&quot;qaudio#Error-enum&quot;&gt;QAudio::OpenError&lt;/a&gt;, &lt;a href=&quot;qaudioinput#state&quot;&gt;state&lt;/a&gt;() returns &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio::StoppedState&lt;/a&gt; and the &lt;a href=&quot;qaudioinput#stateChanged&quot;&gt;stateChanged&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">이 프로세스 중에 문제가 발생하면 &lt;a href=&quot;qaudioinput#error&quot;&gt;error&lt;/a&gt; ()는 &lt;a href=&quot;qaudio#Error-enum&quot;&gt;QAudio :: OpenError를&lt;/a&gt; 반환 하고 &lt;a href=&quot;qaudioinput#state&quot;&gt;state&lt;/a&gt; ()는 &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio :: StoppedState를&lt;/a&gt; 반환 하고 &lt;a href=&quot;qaudioinput#stateChanged&quot;&gt;stateChanged&lt;/a&gt; () 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f2198e89451a23638fcca2bde12f05622c1761ce" translate="yes" xml:space="preserve">
          <source>If a problem occurs during this process, &lt;a href=&quot;qaudiooutput#error&quot;&gt;error&lt;/a&gt;() returns &lt;a href=&quot;qaudio#Error-enum&quot;&gt;QAudio::OpenError&lt;/a&gt;, &lt;a href=&quot;qaudiooutput#state&quot;&gt;state&lt;/a&gt;() returns &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio::StoppedState&lt;/a&gt; and the &lt;a href=&quot;qaudiooutput#stateChanged&quot;&gt;stateChanged&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">이 프로세스 중에 문제가 발생하면 &lt;a href=&quot;qaudiooutput#error&quot;&gt;error&lt;/a&gt; ()는 &lt;a href=&quot;qaudio#Error-enum&quot;&gt;QAudio :: OpenError를&lt;/a&gt; 반환 하고 &lt;a href=&quot;qaudiooutput#state&quot;&gt;state&lt;/a&gt; ()는 &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio :: StoppedState를&lt;/a&gt; 반환 하고 &lt;a href=&quot;qaudiooutput#stateChanged&quot;&gt;stateChanged&lt;/a&gt; () 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="699c60b0bdb4337f5cbadc83b20dc8a7a56cda0c" translate="yes" xml:space="preserve">
          <source>If a problem occurs with access to the information source then an &lt;a href=&quot;qgeopositioninfosource#error&quot;&gt;error()&lt;/a&gt; signal is emitted.</source>
          <target state="translated">정보 소스에 액세스 할 때 문제점이 발생하면 &lt;a href=&quot;qgeopositioninfosource#error&quot;&gt;error ()&lt;/a&gt; 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aaa023ce285142452c05436024120008e20a28bf" translate="yes" xml:space="preserve">
          <source>If a product query for &lt;b&gt;app&lt;/b&gt; fails, then either the trial has expired or the license is invalid. Your app should check for this product and react accordingly, for instance by showing a dialog to the user.</source>
          <target state="translated">&lt;b&gt;앱에&lt;/b&gt; 대한 제품 쿼리 가 실패하면 평가판이 만료되었거나 라이센스가 유효하지 않습니다. 앱은이 제품을 확인하고 예를 들어 사용자에게 대화 상자를 표시하여 적절히 반응해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7bae6386e7d00c53087e483a2ea6015c9051376" translate="yes" xml:space="preserve">
          <source>If a property is marked with a dirty flag, its current value can be retrieved using the corresponding get function:</source>
          <target state="translated">속성이 더티 플래그로 표시되면 해당 get 함수를 사용하여 현재 값을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="053e6fce5770a75affab0253ad1a25bfc98be2ca" translate="yes" xml:space="preserve">
          <source>If a property is not explicitly set, do not change the text format's property value.</source>
          <target state="translated">속성이 명시 적으로 설정되지 않은 경우 텍스트 형식의 속성 값을 변경하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="70c6c27416a7e283741a82ceb71dea6a3c7d6bb3" translate="yes" xml:space="preserve">
          <source>If a property is not explicitly set, override the text format's property with a default value.</source>
          <target state="translated">속성이 명시 적으로 설정되지 않은 경우 텍스트 형식의 속성을 기본값으로 재정의하십시오.</target>
        </trans-unit>
        <trans-unit id="5b9303bd341bc3d4cb763dcaeebbd1613d173e5e" translate="yes" xml:space="preserve">
          <source>If a rectangle with an invalid size is specified (the default), the entire widget is painted.</source>
          <target state="translated">잘못된 크기의 사각형이 지정되면 (기본값) 전체 위젯이 페인트됩니다.</target>
        </trans-unit>
        <trans-unit id="807c5f4050ab67dd8c9e8c630873b65f0d31ae05" translate="yes" xml:space="preserve">
          <source>If a relation's display column name is also used as a column name in the relational table, or if it is used as display column name in more than one relation it will be aliased. The alias is the relation's table name, display column name and a unique id joined by an underscore (e.g. tablename_columnname_id). &lt;a href=&quot;qsqlrecord#fieldName&quot;&gt;QSqlRecord::fieldName&lt;/a&gt;() will return the aliased column name. All occurrences of the duplicate display column name are aliased when duplication is detected, but no aliasing is done to the column names in the main table. The aliasing doesn't affect &lt;a href=&quot;qsqlrelation&quot;&gt;QSqlRelation&lt;/a&gt;, so &lt;a href=&quot;qsqlrelation#displayColumn&quot;&gt;QSqlRelation::displayColumn&lt;/a&gt;() will return the original display column name.</source>
          <target state="translated">관계의 표시 열 이름이 관계형 테이블에서 열 이름으로 사용되거나 둘 이상의 관계에서 표시 열 이름으로 사용되는 경우 별명이 지정됩니다. 별명은 관계의 테이블 이름, 표시 열 이름 및 밑줄로 결합 된 고유 ID입니다 (예 : tablename_columnname_id). &lt;a href=&quot;qsqlrecord#fieldName&quot;&gt;QSqlRecord :: fieldName&lt;/a&gt; ()은 별칭이 지정된 열 이름을 반환합니다. 중복 표시 열 이름의 모든 항목은 중복이 감지 될 때 별명이 지정되지만 기본 테이블의 열 이름에는 별명이 지정되지 않습니다. 앨리어싱은 &lt;a href=&quot;qsqlrelation&quot;&gt;QSqlRelation&lt;/a&gt; 에 영향을 미치지 않으므로 &lt;a href=&quot;qsqlrelation#displayColumn&quot;&gt;QSqlRelation :: displayColumn&lt;/a&gt; ()은 원래 표시 열 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cea6aa89ec0815fe1c4d9abb50f9e82d631d13d5" translate="yes" xml:space="preserve">
          <source>If a relational table contains keys that refer to non-existent rows in the referenced table, the rows containing the invalid keys will not be exposed through the model. The user or the database is responsible for keeping referential integrity.</source>
          <target state="translated">관계형 테이블에 참조 된 테이블에 존재하지 않는 행을 참조하는 키가 포함 된 경우, 유효하지 않은 키를 포함하는 행은 모델을 통해 노출되지 않습니다. 사용자 또는 데이터베이스는 참조 무결성을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="4631f50bec91911b440aa70a330c84d7f59ed4da" translate="yes" xml:space="preserve">
          <source>If a remove transition has been specified, it is applied after this signal is handled, providing that &lt;a href=&quot;qml-qtquick-gridview#delayRemove-attached-prop&quot;&gt;delayRemove&lt;/a&gt; is false.</source>
          <target state="translated">제거 전환이 지정된 경우 &lt;a href=&quot;qml-qtquick-gridview#delayRemove-attached-prop&quot;&gt;delayRemove&lt;/a&gt; 가 false 인 경우이 신호를 처리 한 후에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e2977bd13be0065ec5be50fb8349e0d33e95a781" translate="yes" xml:space="preserve">
          <source>If a remove transition has been specified, it is applied after this signal is handled, providing that &lt;a href=&quot;qml-qtquick-listview#delayRemove-attached-prop&quot;&gt;delayRemove&lt;/a&gt; is false.</source>
          <target state="translated">제거 전환이 지정된 경우 &lt;a href=&quot;qml-qtquick-listview#delayRemove-attached-prop&quot;&gt;delayRemove&lt;/a&gt; 가 false 인 경우이 신호를 처리 한 후에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d3623c03dc358c0d84164857409c1941e21ec4b" translate="yes" xml:space="preserve">
          <source>If a replica is instantiated but its node is not connected to the node that hosts the requested source (or that object lives in a host node process, but sharing/remoting has not been enabled for the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;), the Replica will still be created, but will remain uninitialized.</source>
          <target state="translated">복제본이 인스턴스화되었지만 해당 노드가 요청 된 소스를 호스트하는 노드에 연결되지 않았거나 (또는 ​​해당 개체가 호스트 노드 프로세스에 있지만 &lt;a href=&quot;qobject&quot;&gt;QObject에&lt;/a&gt; 대해 공유 / 원격이 활성화되지 않은 경우) 복제본은 여전히 ​​생성됩니다. 초기화되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d7ef45a3ff6f327a5e799d2b2bcc0ae07c57df01" translate="yes" xml:space="preserve">
          <source>If a script in the</source>
          <target state="translated">에 스크립트가</target>
        </trans-unit>
        <trans-unit id="5aec5b2f8a15ef464a970ef8fa3930f17301c95a" translate="yes" xml:space="preserve">
          <source>If a scroll area is used to display the contents of a widget that contains child widgets arranged in a layout, it is important to realize that the size policy of the layout will also determine the size of the widget. This is especially useful to know if you intend to dynamically change the contents of the layout. In such cases, setting the layout's &lt;a href=&quot;qlayout#sizeConstraint-prop&quot;&gt;size constraint&lt;/a&gt; property to one which provides constraints on the minimum and/or maximum size of the layout (e.g., &lt;a href=&quot;qlayout#SizeConstraint-enum&quot;&gt;QLayout::SetMinAndMaxSize&lt;/a&gt;) will cause the size of the scroll area to be updated whenever the contents of the layout changes.</source>
          <target state="translated">스크롤 영역을 사용하여 레이아웃에 배열 된 하위 위젯이 포함 된 위젯의 컨텐츠를 표시하는 경우 레이아웃의 크기 정책에 따라 위젯의 크기도 결정됩니다. 레이아웃의 내용을 동적으로 변경하려는 경우 특히 유용합니다. 이러한 경우 레이아웃의 &lt;a href=&quot;qlayout#sizeConstraint-prop&quot;&gt;크기 제한&lt;/a&gt; 속성을 레이아웃의 최소 및 / 또는 최대 크기에 대한 제한을 제공하는 속성으로 설정하면 (예 : &lt;a href=&quot;qlayout#SizeConstraint-enum&quot;&gt;QLayout :: SetMinAndMaxSize&lt;/a&gt; ) 스크롤 영역의 크기가 레이아웃 변경.</target>
        </trans-unit>
        <trans-unit id="26c0b78fa714df4aa5e9878f9e2a51824b784375" translate="yes" xml:space="preserve">
          <source>If a signal is connected to several slots, the slots are activated in the same order as the order the connection was made, when the signal is emitted</source>
          <target state="translated">신호가 여러 슬롯에 연결된 경우 신호가 방출 될 때 연결 순서와 동일한 순서로 슬롯이 활성화됩니다</target>
        </trans-unit>
        <trans-unit id="57c8641020622005b4d55877c977dbc47501b2e3" translate="yes" xml:space="preserve">
          <source>If a signal is connected to several slots, the slots are activated in the same order in which the connections were made, when the signal is emitted.</source>
          <target state="translated">신호가 여러 슬롯에 연결된 경우 신호가 방출 될 때 슬롯은 연결 순서와 동일한 순서로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="04f22255e1b5ccc7e3a171ad856b31bff4574a56" translate="yes" xml:space="preserve">
          <source>If a single license key for the control is not sufficient (ie. you want differnet developers to receive different license keys) you can specify an empty key to indicate that the control requires a license, and reimplement &lt;a href=&quot;qaxfactory#validateLicenseKey&quot;&gt;QAxFactory::validateLicenseKey&lt;/a&gt;() to verify that a license exists on the system (ie. through a license file).</source>
          <target state="translated">컨트롤에 대한 단일 라이센스 키가 충분하지 않은 경우 (즉, Differentnet 개발자가 다른 라이센스 키를 받도록하려면) 컨트롤에 라이센스가 필요함을 나타내는 빈 키를 지정하고 &lt;a href=&quot;qaxfactory#validateLicenseKey&quot;&gt;QAxFactory :: validateLicenseKey&lt;/a&gt; ()를 다시 구현 하여 다음을 확인하십시오. 라이센스가 시스템에 존재합니다 (예 : 라이센스 파일을 통해).</target>
        </trans-unit>
        <trans-unit id="75d2ab14bafd1f4921d136774b1e0cba9d058df2" translate="yes" xml:space="preserve">
          <source>If a size has been defined, the shape property can be used to affect a non-rectangular area.</source>
          <target state="translated">크기가 정의 된 경우 모양 속성을 사용하여 사각형이 아닌 영역에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10ce4b149c14bd1abea03913f5ac9f6804cc38c9" translate="yes" xml:space="preserve">
          <source>If a smaller number of touchpoints are in contact with the &lt;a href=&quot;qml-qtquick-multipointhandler#parent-prop&quot;&gt;parent&lt;/a&gt;, they will be ignored.</source>
          <target state="translated">더 적은 수의 터치 포인트가 &lt;a href=&quot;qml-qtquick-multipointhandler#parent-prop&quot;&gt;부모&lt;/a&gt; 와 접촉 하면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="975d2a0140cba2830028343d9517a097582e6d06" translate="yes" xml:space="preserve">
          <source>If a state change has a Transition that matches the same property as a &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;, the Transition animation overrides the &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt; for that state change.</source>
          <target state="translated">상태 변경에 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;동작&lt;/a&gt; 과 동일한 속성과 일치하는 전환이있는 경우 전환 애니메이션은 해당 상태 변경에 대한 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;동작&lt;/a&gt; 을 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="0f9c301c96ac8d7861138dfd6a50146295c056b6" translate="yes" xml:space="preserve">
          <source>If a state has property assignments, and the transition into the state has animations for the properties, the state can potentially be exited before the properties have been assigned to the values defines by the state. This is true in particular when there are transitions out from the state that do not depend on the &lt;a href=&quot;qstate#propertiesAssigned&quot;&gt;propertiesAssigned()&lt;/a&gt; signal, as described in the previous section.</source>
          <target state="translated">상태에 속성이 할당되어 있고 상태로의 전환에 속성에 대한 애니메이션이있는 경우 속성이 상태에 의해 정의 된 값에 할당되기 전에 상태가 종료 될 수 있습니다. 이는 이전 섹션에서 설명한 것처럼 &lt;a href=&quot;qstate#propertiesAssigned&quot;&gt;propertiesAssigned ()&lt;/a&gt; 신호 에 의존하지 않는 상태에서 전환이 발생하는 경우 특히 그렇습니다 .</target>
        </trans-unit>
        <trans-unit id="7c33373c0839af13f5d787e37da4d2446db68858" translate="yes" xml:space="preserve">
          <source>If a string is a prefix of an &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Acceptable&lt;/a&gt; string, it is considered &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Intermediate&lt;/a&gt;. For example, &quot;&quot; and &quot;A&quot; are &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Intermediate&lt;/a&gt; for the regexp &lt;b&gt;[A-Z][0-9]&lt;/b&gt; (whereas &quot;_&quot; would be &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Invalid&lt;/a&gt;).</source>
          <target state="translated">문자열이 &lt;a href=&quot;qvalidator#State-enum&quot;&gt;Acceptable&lt;/a&gt; 문자열 의 접두사 인 경우 &lt;a href=&quot;qvalidator#State-enum&quot;&gt;중간&lt;/a&gt; 으로 간주됩니다 . 예를 들어, &quot;&quot;및 &quot;A&quot;는 정규 표현식 &lt;b&gt;[AZ] [0-9]&lt;/b&gt; 에서 &lt;a href=&quot;qvalidator#State-enum&quot;&gt;중간&lt;/a&gt; 입니다 ( &quot;_&quot;는 &lt;a href=&quot;qvalidator#State-enum&quot;&gt;유효&lt;/a&gt; 하지 않음 ).&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="ab44fbf58ba8009f0ac17a5fae8bf0cebec9f2af" translate="yes" xml:space="preserve">
          <source>If a style is not right-to-left aware it will display items as if it were left-to-right</source>
          <target state="translated">스타일이 오른쪽에서 왼쪽으로 인식되지 않으면 왼쪽에서 오른쪽 인 것처럼 항목이 표시됩니다</target>
        </trans-unit>
        <trans-unit id="7d0eb30dea27d29c8f86c7adcba4dab93efc9799" translate="yes" xml:space="preserve">
          <source>If a surface fails to &lt;a href=&quot;qabstractvideosurface#start&quot;&gt;start&lt;/a&gt;(), or stops unexpectedly this function can be called to discover what error occurred.</source>
          <target state="translated">표면이 &lt;a href=&quot;qabstractvideosurface#start&quot;&gt;시작&lt;/a&gt; ()하지 않거나 예기치 않게 중지되면이 함수를 호출하여 어떤 오류가 발생했는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d5f37b53c330bbbec2acf5f9f3318d987443a98" translate="yes" xml:space="preserve">
          <source>If a text block is part of a list, it can also have a list format that is accessible with the listFormat() function.</source>
          <target state="translated">텍스트 블록이 목록의 일부인 경우 listFormat () 함수를 사용하여 액세스 할 수있는 목록 형식을 가질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aa67144618e83a9c53a8bd213b42d74ea19151e" translate="yes" xml:space="preserve">
          <source>If a text encoding is specified using the &lt;code&gt;meta&lt;/code&gt; tag, it is picked up by Qt::codecForHtml(). Likewise, if an encoding is specified to &lt;a href=&quot;qtextdocument#toHtml&quot;&gt;QTextDocument::toHtml&lt;/a&gt;(), the encoding is stored using a &lt;code&gt;meta&lt;/code&gt; tag, for example: &lt;code&gt;&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=EUC-JP&quot; /&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;meta&lt;/code&gt; 태그를 사용하여 텍스트 인코딩을 지정하면 Qt :: codecForHtml ()에 의해 선택됩니다. 마찬가지로 인코딩이 &lt;a href=&quot;qtextdocument#toHtml&quot;&gt;QTextDocument :: toHtml&lt;/a&gt; ()에 지정된 경우 인코딩은 &lt;code&gt;meta&lt;/code&gt; 태그를 사용하여 저장됩니다 ( 예 : &lt;code&gt;&amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=EUC-JP&quot; /&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5206a82b14ffa56732b79faa72115c3caf87be62" translate="yes" xml:space="preserve">
          <source>If a text has ben set using &lt;a href=&quot;qwizard#setButtonText&quot;&gt;setButtonText&lt;/a&gt;(), this text is returned.</source>
          <target state="translated">텍스트가 &lt;a href=&quot;qwizard#setButtonText&quot;&gt;setButtonText&lt;/a&gt; ()를 사용하여 설정된 경우이 텍스트가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="43fb3aaed1dc35b758fbe1ee6aa6be223ac9128a" translate="yes" xml:space="preserve">
          <source>If a text has ben set using &lt;a href=&quot;qwizardpage#setButtonText&quot;&gt;setButtonText&lt;/a&gt;(), this text is returned. Otherwise, if a text has been set using &lt;a href=&quot;qwizard#setButtonText&quot;&gt;QWizard::setButtonText&lt;/a&gt;(), this text is returned.</source>
          <target state="translated">텍스트가 &lt;a href=&quot;qwizardpage#setButtonText&quot;&gt;setButtonText&lt;/a&gt; ()를 사용하여 설정된 경우이 텍스트가 반환됩니다. 그렇지 않으면 &lt;a href=&quot;qwizard#setButtonText&quot;&gt;QWizard :: setButtonText&lt;/a&gt; ()를 사용하여 텍스트를 설정 한 경우이 텍스트가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d5713f8e4ace5e3a5647361ecf23c4b6a29aadfb" translate="yes" xml:space="preserve">
          <source>If a thread locks a resource but does not unlock it, the application may freeze because the resource will become permanently unavailable to other threads. This can happen, for example, if an exception is thrown and forces the current function to return without releasing its lock.</source>
          <target state="translated">스레드가 리소스를 잠그지 만 잠금을 해제하지 않으면 리소스가 다른 스레드에서 영구적으로 사용할 수 없게되므로 응용 프로그램이 중지 될 수 있습니다. 예를 들어, 예외가 발생하고 잠금을 해제하지 않고 현재 함수가 강제로 리턴되는 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9f9902edc3fed3bf18737665b8c8e6552098110" translate="yes" xml:space="preserve">
          <source>If a timeout occures during the handshake, the &lt;a href=&quot;qdtls#handshakeTimeout&quot;&gt;handshakeTimeout&lt;/a&gt;() signal is emitted. The application must call handleTimeout() to retransmit handshake messages; handleTimeout() returns &lt;code&gt;true&lt;/code&gt; if a timeout has occurred, false otherwise.</source>
          <target state="translated">핸드 셰이크 중에 시간 초과 가 발생 하면 &lt;a href=&quot;qdtls#handshakeTimeout&quot;&gt;handshakeTimeout&lt;/a&gt; () 신호가 발생합니다. 응용 프로그램은 악수 메시지를 재전송하려면 handleTimeout ()을 호출해야합니다. handleTimeout는 () 반환 &lt;code&gt;true&lt;/code&gt; 시간 초과가, 그렇지 않은 경우는 false 발생한 경우.</target>
        </trans-unit>
        <trans-unit id="a9243057d82c828ba58c4e4a839aa70bb9ee4f7f" translate="yes" xml:space="preserve">
          <source>If a title bar widget is set, &lt;a href=&quot;qdockwidget&quot;&gt;QDockWidget&lt;/a&gt; will not use native window decorations when it is floated.</source>
          <target state="translated">제목 표시 줄 위젯이 설정된 경우 &lt;a href=&quot;qdockwidget&quot;&gt;QDockWidget&lt;/a&gt; 은 부동 상태 일 때 기본 창 장식을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a949aad62db69551c66b376da72a04a59103a2dd" translate="yes" xml:space="preserve">
          <source>If a tool button has a default action, the action defines the following properties of the button:</source>
          <target state="translated">도구 버튼에 기본 동작이있는 경우이 동작은 다음과 같은 버튼 속성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f6e59cd38a8a52c8efedbcfb3d49f7454b604075" translate="yes" xml:space="preserve">
          <source>If a transaction is not finalized, it will be called again for the same transaction the next time the application starts up, providing another chance to store the data. The transaction for a consumable product has to be finalized before the product can be purchased again.</source>
          <target state="translated">트랜잭션이 완료되지 않으면 다음에 응용 프로그램을 시작할 때 동일한 트랜잭션에 대해 다시 호출되어 데이터를 저장할 수있는 또 다른 기회를 제공합니다. 소모품을 다시 구매하려면 소모품에 대한 트랜잭션을 마무리해야합니다.</target>
        </trans-unit>
        <trans-unit id="ca66d51761cb7d7fb74346d81a642fd80e6456fd" translate="yes" xml:space="preserve">
          <source>If a transaction is not finalized, the &lt;a href=&quot;qinappstore#transactionReady&quot;&gt;transactionReady() signal&lt;/a&gt; is emitted again for the same transaction the next time the product is registered, providing another chance to store the data. The transaction for a consumable product must be finalized before the product can be purchased again.</source>
          <target state="translated">트랜잭션이 완료되지 않으면 다음에 제품을 등록 할 때 동일한 트랜잭션에 대해 &lt;a href=&quot;qinappstore#transactionReady&quot;&gt;transactionReady () 신호&lt;/a&gt; 가 다시 생성되어 데이터를 저장할 수있는 또 다른 기회를 제공합니다. 소모품을 다시 구매하려면 소모품에 대한 트랜잭션을 완료해야합니다.</target>
        </trans-unit>
        <trans-unit id="1f524d615aa70e8fe8b6577609b439c9b3c0c1a9" translate="yes" xml:space="preserve">
          <source>If a transition has no target state, the transition may still be triggered, but this will not cause the state machine's configuration to change (i.e. the current state will not be exited and re-entered).</source>
          <target state="translated">전이에 대상 상태가없는 경우 전이가 여전히 트리거 될 수 있지만 이로 인해 상태 시스템의 구성이 변경되지 않습니다 (즉, 현재 상태가 종료되고 다시 입력되지 않음).</target>
        </trans-unit>
        <trans-unit id="6ab2eb4185db8dd40effe295da523e8c166f82aa" translate="yes" xml:space="preserve">
          <source>If a type is used in a queued connection without being registered, a warning will be printed at the console; for example:</source>
          <target state="translated">등록되지 않은 상태에서 대기중인 연결에 유형을 사용하면 콘솔에 경고가 인쇄됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cdb06e8c4faad33e3276e94d7e36a4698cc37926" translate="yes" xml:space="preserve">
          <source>If a user buys the downloadable content and later either installs the game on another device or uninstalls and reinstalls the game, you can provide a way to restore the purchase by calling &lt;a href=&quot;qinappstore#restorePurchases&quot;&gt;QInAppStore::restorePurchases&lt;/a&gt;(). Purchases must be restored in response to a user input, as it may present a password dialog on some platforms.</source>
          <target state="translated">사용자가 다운로드 가능한 콘텐츠를 구매 한 후 나중에 다른 장치에 게임을 설치하거나 게임을 제거했다가 다시 설치하는 경우 &lt;a href=&quot;qinappstore#restorePurchases&quot;&gt;QInAppStore :: restorePurchases&lt;/a&gt; ()를 호출하여 구매를 복원하는 방법을 제공 할 수 있습니다 . 일부 플랫폼에서는 비밀번호 대화 상자가 표시 될 수 있으므로 사용자 입력에 응답하여 구매를 복원해야합니다.</target>
        </trans-unit>
        <trans-unit id="a99427106661fa5ea8df817adf6f128a530c4587" translate="yes" xml:space="preserve">
          <source>If a user buys the downloadable content and later either installs the game on another device or uninstalls and reinstalls the game, you can provide a way to restore the purchase, such as the following button:</source>
          <target state="translated">사용자가 다운로드 가능한 콘텐츠를 구입 한 후 나중에 다른 장치에 게임을 설치하거나 게임을 제거한 후 다시 설치하는 경우 다음 버튼과 같이 구매를 복원하는 방법을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="def74d3834c111705746037099a77fcc745b25a1" translate="yes" xml:space="preserve">
          <source>If a valid model index is specified for the parent item when an index is requested using &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index()&lt;/a&gt;, the index returned refers to an item beneath that parent item in the model. The index obtained refers to a child of that item.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index ()를&lt;/a&gt; 사용하여 색인을 요청할 때 상위 항목에 유효한 모델 색인이 지정된 경우 리턴 된 색인은 모델에서 해당 상위 항목 아래의 항목을 참조합니다. 얻은 색인은 해당 항목의 하위 항목을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f83cb246c6173001d1b2bc2121a8f6b8a581d808" translate="yes" xml:space="preserve">
          <source>If a validator has been set, the value is &lt;code&gt;true&lt;/code&gt; only if the current text is acceptable to the validator as a final string (not as an intermediate string).</source>
          <target state="translated">유효성 검사기가 설정된 경우 현재 텍스트가 유효성 검사자에게 최종 문자열 (중간 문자열이 아닌)로 허용되는 경우에만 값이 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="65a635275707a70f3d56a0bad6a6e2783b053ed2" translate="yes" xml:space="preserve">
          <source>If a validator or input mask was set, this property will return &lt;code&gt;true&lt;/code&gt; if the current text satisfies the validator or mask as a final string (not as an intermediate string).</source>
          <target state="translated">유효성 검사기 또는 입력 마스크가 설정된 경우 현재 텍스트가 유효성 검사기 또는 마스크를 최종 문자열 (중간 문자열이 아닌)로 만족하면 이 속성이 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="cfaea09faec46c562f79eb5c19d4bf942d035cad" translate="yes" xml:space="preserve">
          <source>If a validator was set, this property will return &lt;code&gt;true&lt;/code&gt; if the current text satisfies the validator or mask as a final string (not as an intermediate string).</source>
          <target state="translated">유효성 검사기가 설정된 경우 현재 텍스트가 유효성 검사기 또는 마스크를 최종 문자열 (중간 문자열이 아닌)로 만족하면 이 속성이 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="953694a3255e1b5c6cfb2546a587a02c8aa40651" translate="yes" xml:space="preserve">
          <source>If a value other than &lt;code&gt;Fixed&lt;/code&gt; is specified, the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#pathanimation&quot;&gt;PathAnimation&lt;/a&gt; will rotate the item to achieve the specified orientation as it travels along the path.</source>
          <target state="translated">&lt;code&gt;Fixed&lt;/code&gt; 이외의 값을 지정하면 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#pathanimation&quot;&gt;PathAnimation&lt;/a&gt; 이 항목을 회전하여 경로를 따라 이동할 때 지정된 방향을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="2590ca170e20a5e9f3041cd08bef35b1a72ce80d" translate="yes" xml:space="preserve">
          <source>If a value with the wrong type is assigned, the error reported will point to the location of the property declaration, as opposed to the location where the property was assigned to. This slows down the development process by making it more difficult to track down errors.</source>
          <target state="translated">잘못된 유형의 값이 지정된 경우,보고 된 오류는 속성이 할당 된 위치가 아니라 속성 선언의 위치를 ​​가리 킵니다. 이로 인해 오류 추적이 더 어려워 져 개발 프로세스가 느려집니다.</target>
        </trans-unit>
        <trans-unit id="adb79330e8de08c8e9bef1ceb3d7e2bfb7d6dea8" translate="yes" xml:space="preserve">
          <source>If a video output has already been set on the media player the new surface will replace it.</source>
          <target state="translated">비디오 출력이 미디어 플레이어에 이미 설정된 경우 새 표면이이를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="a337aea801264cae266b813c4e9434e5e800bb4a" translate="yes" xml:space="preserve">
          <source>If a view specifies this generic displaced transition as well as a specific &lt;a href=&quot;qml-qtquick-gridview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-gridview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; transition, the more specific transition will be used instead of the generic displaced transition when the relevant operation occurs, providing that the more specific transition has not been disabled (by setting &lt;a href=&quot;qml-qtquick-transition#enabled-prop&quot;&gt;enabled&lt;/a&gt; to false). If it has indeed been disabled, the generic displaced transition is applied instead.</source>
          <target state="translated">뷰에서이 일반 변위 전이와 특정 &lt;a href=&quot;qml-qtquick-gridview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-gridview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-gridview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; 전이를 지정하는 경우 관련 작업이 발생할 때 일반 변위 전이 대신 더 구체적인 전이가 사용되어보다 특정한 전이가 비활성화되지 않습니다 ( &lt;a href=&quot;qml-qtquick-transition#enabled-prop&quot;&gt;enabled&lt;/a&gt; 를 false 로 설정 하여). 실제로 비활성화 된 경우 일반 변위 전환이 대신 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="755062afb1caa888c7e0d60c2f8969a0bdd50633" translate="yes" xml:space="preserve">
          <source>If a view specifies this generic displaced transition as well as a specific &lt;a href=&quot;qml-qtquick-listview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-listview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-listview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; transition, the more specific transition will be used instead of the generic displaced transition when the relevant operation occurs, providing that the more specific transition has not been disabled (by setting &lt;a href=&quot;qml-qtquick-transition#enabled-prop&quot;&gt;enabled&lt;/a&gt; to false). If it has indeed been disabled, the generic displaced transition is applied instead.</source>
          <target state="translated">뷰에서이 일반 변위 전이와 특정 &lt;a href=&quot;qml-qtquick-listview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-listview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-listview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; 전이를 지정하는 경우 관련 작업이 발생할 때 일반 변위 전이 대신 더 구체적인 전이가 사용되어보다 특정한 전이가 비활성화되지 않습니다 ( &lt;a href=&quot;qml-qtquick-transition#enabled-prop&quot;&gt;enabled&lt;/a&gt; 를 false 로 설정 하여). 실제로 비활성화 된 경우 일반 변위 전환이 대신 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6e8f7c921322ea0ba71b682846818cb687fb64ea" translate="yes" xml:space="preserve">
          <source>If a viewfinder has already been set on the camera the new surface will replace it.</source>
          <target state="translated">카메라에 뷰 파인더가 이미 설정되어 있으면 새 표면으로 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="22ea4c312e240c213cee16cb9f7d2705f9c7c9cf" translate="yes" xml:space="preserve">
          <source>If a web page contains two videos that are started in sequence, this signal gets emitted only once, for the first video to generate sound. After both videos are stopped, the signal is emitted upon the last sound generated. This means that the signal is emitted both when any kind of sound is generated and when everything is completely silent within a web page, regardless of the number of audio streams.</source>
          <target state="translated">웹 페이지에 순차적으로 시작된 두 개의 비디오가 포함 된 경우 첫 번째 비디오가 사운드를 생성하기 위해이 신호가 한 번만 방출됩니다. 두 비디오가 모두 정지 된 후 신호는 마지막으로 생성 된 사운드에서 방출됩니다. 이것은 모든 종류의 사운드가 생성 될 때와 오디오 스트림의 수에 관계없이 웹 페이지 내에서 모든 것이 완전히 침묵 할 때 신호가 방출됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d9ff2f210738dca9cf8a8aded0871c2100d4860a" translate="yes" xml:space="preserve">
          <source>If a widget has both the &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt::WA_OpaquePaintEvent&lt;/a&gt; widget attribute</source>
          <target state="translated">위젯에 &lt;a href=&quot;qt#WidgetAttribute-enum&quot;&gt;Qt :: WA_OpaquePaintEvent&lt;/a&gt; 위젯 속성 이 모두있는 경우</target>
        </trans-unit>
        <trans-unit id="c90269e219f094e46b020f11b95dd881a3ad1074" translate="yes" xml:space="preserve">
          <source>If a widget is already embedded by this proxy when this function is called, that widget will first be automatically unembedded. Passing 0 for the</source>
          <target state="translated">이 함수가 호출 될 때이 프록시에 의해 위젯이 이미 임베드 된 경우 해당 위젯은 먼저 자동으로 임베드됩니다. 에 0을 전달</target>
        </trans-unit>
        <trans-unit id="0c5c2ee8115411c103415877c45456ae4dbb197c" translate="yes" xml:space="preserve">
          <source>If a widget is already inside a &lt;a href=&quot;qsplitter&quot;&gt;QSplitter&lt;/a&gt; when &lt;a href=&quot;qsplitter#insertWidget&quot;&gt;insertWidget&lt;/a&gt;() or &lt;a href=&quot;qsplitter#addWidget&quot;&gt;addWidget&lt;/a&gt;() is called, it will move to the new position. This can be used to reorder widgets in the splitter later. You can use &lt;a href=&quot;qsplitter#indexOf&quot;&gt;indexOf&lt;/a&gt;(), &lt;a href=&quot;qsplitter#widget&quot;&gt;widget&lt;/a&gt;(), and &lt;a href=&quot;qsplitter#count&quot;&gt;count&lt;/a&gt;() to get access to the widgets inside the splitter.</source>
          <target state="translated">&lt;a href=&quot;qsplitter#insertWidget&quot;&gt;insertWidget&lt;/a&gt; () 또는 &lt;a href=&quot;qsplitter#addWidget&quot;&gt;addWidget&lt;/a&gt; ()을 호출 할 때 위젯이 이미 &lt;a href=&quot;qsplitter&quot;&gt;QSplitter&lt;/a&gt; 내부에 있으면 새 위치로 이동합니다. 나중에 스플리터에서 위젯을 재정렬하는 데 사용할 수 있습니다. 당신은 사용할 수 있습니다 &lt;a href=&quot;qsplitter#indexOf&quot;&gt;같이 IndexOf&lt;/a&gt; (), &lt;a href=&quot;qsplitter#widget&quot;&gt;위젯&lt;/a&gt; () 및 &lt;a href=&quot;qsplitter#count&quot;&gt;계산&lt;/a&gt; 스플리터 내부의 위젯에 액세스하려면 ().</target>
        </trans-unit>
        <trans-unit id="146c43193739f14c404eda3be0507d01214fcd80" translate="yes" xml:space="preserve">
          <source>If a widget is non-native (alien) and winId() is invoked on it, that widget will be provided a native handle.</source>
          <target state="translated">위젯이 비 네이티브 (외국인)이고 winId ()가 호출되면 해당 위젯에 기본 핸들이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6cb6f1f111b08fbe1885d4ee5988077dc0c1d0b4" translate="yes" xml:space="preserve">
          <source>If a worker script has the extension &quot;.js&quot; instead, then it is considered to contain plain JavaScript statements and it is run in non-strict mode.</source>
          <target state="translated">작업자 스크립트의 확장명이 &quot;.js&quot;인 경우 일반 JavaScript 문을 포함하는 것으로 간주되며 엄격하지 않은 모드로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ec10752a6ced1b198119e4dfcc5838eea4106bda" translate="yes" xml:space="preserve">
          <source>If a worker thread throws an exception that is not a subclass of &lt;a href=&quot;qexception&quot;&gt;QException&lt;/a&gt;, the Qt functions will throw a &lt;a href=&quot;qunhandledexception&quot;&gt;QUnhandledException&lt;/a&gt; on the receiver thread side.</source>
          <target state="translated">워커 스레드가 &lt;a href=&quot;qexception&quot;&gt;QException&lt;/a&gt; 의 서브 클래스가 아닌 예외를 발생 시키면 Qt 함수는 수신자 스레드 측 에서 &lt;a href=&quot;qunhandledexception&quot;&gt;QUnhandledException&lt;/a&gt; 을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="561aed68810e5f609d1e200c7dcb554e0cddbe79" translate="yes" xml:space="preserve">
          <source>If activeFocus is true, either this item is the one that currently receives keyboard input, or it is a &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope&lt;/a&gt; ancestor of the item that currently receives keyboard input.</source>
          <target state="translated">activeFocus가 true 인 경우이 항목은 현재 키보드 입력을받는 항목이거나 현재 키보드 입력을받는 항목 의 &lt;a href=&quot;qml-qtquick-focusscope&quot;&gt;FocusScope 상위&lt;/a&gt; 항목입니다.</target>
        </trans-unit>
        <trans-unit id="65ea73341c9beb190687e2159d0d22215bf1addd" translate="yes" xml:space="preserve">
          <source>If all commands complete successfully the &lt;a href=&quot;qnearfieldtarget#requestCompleted&quot;&gt;requestCompleted&lt;/a&gt;() signal will be emitted; otherwise the &lt;a href=&quot;qnearfieldtarget#error&quot;&gt;error&lt;/a&gt;() signal will be emitted. If a command fails succeeding commands from this call will not be processed.</source>
          <target state="translated">모든 명령이 성공적으로 완료되면 &lt;a href=&quot;qnearfieldtarget#requestCompleted&quot;&gt;requestCompleted&lt;/a&gt; () 신호가 생성됩니다. 그렇지 않으면 &lt;a href=&quot;qnearfieldtarget#error&quot;&gt;오류&lt;/a&gt; () 신호가 발생합니다. 명령이 실패하면이 호출에서 명령이 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="268af935db9444b22d2db0de103b4fbeb929fc0e" translate="yes" xml:space="preserve">
          <source>If all signals were disconnected from this object (e.g., the signal argument to &lt;a href=&quot;qobject#disconnect&quot;&gt;disconnect&lt;/a&gt;() was 0), disconnectNotify() is only called once, and the</source>
          <target state="translated">모든 객체가이 객체에서 연결이 끊어진 경우 (예 : &lt;a href=&quot;qobject#disconnect&quot;&gt;disconnect&lt;/a&gt; () 의 신호 인수 가 0 인 경우) disconnectNotify ()는 한 번만 호출되며</target>
        </trans-unit>
        <trans-unit id="a9492ab742af685306996e84fa71c882acbd01ba" translate="yes" xml:space="preserve">
          <source>If all sub-animations of &lt;a href=&quot;qml-qtquick-parallelanimation&quot;&gt;ParallelAnimation&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt; are Animator types, the &lt;a href=&quot;qml-qtquick-parallelanimation&quot;&gt;ParallelAnimation&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt; will also be treated as an Animator and be run on the scene graph's rendering thread when possible.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-parallelanimation&quot;&gt;ParallelAnimation&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt; 의 모든 하위 애니메이션 이 Animator 유형 인 경우 &lt;a href=&quot;qml-qtquick-parallelanimation&quot;&gt;ParallelAnimation&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-sequentialanimation&quot;&gt;SequentialAnimation&lt;/a&gt; 도 Animator로 처리되며 가능한 경우 장면 그래프의 렌더링 스레드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="078663a611a8d55bcc685cd8a13a80c93610b559" translate="yes" xml:space="preserve">
          <source>If all you need is a non-persistent memory-based structure, consider using &lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt;&amp;lt;&lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;&amp;gt; instead.</source>
          <target state="translated">비 영구적 인 메모리 기반 구조 만 &lt;a href=&quot;qvariant&quot;&gt;있으면 &lt;/a&gt;&lt;a href=&quot;qmap&quot;&gt;QMap&lt;/a&gt; &amp;lt; &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; , QVariant &amp;gt;을 대신 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="5825d9195ba0009f3bd84ffbdabefcbc2f9f909e" translate="yes" xml:space="preserve">
          <source>If all you need is to resolve a foreign key to a more human-friendly string, you can use &lt;a href=&quot;qsqlrelationaltablemodel&quot;&gt;QSqlRelationalTableModel&lt;/a&gt;. For best results, you should also use &lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt;, a delegate that provides combobox editors for editing foreign keys.</source>
          <target state="translated">외래 키를보다 인간 친화적 인 문자열로 해결하기 &lt;a href=&quot;qsqlrelationaltablemodel&quot;&gt;만하면 QSqlRelationalTableModel&lt;/a&gt; 을 사용할 수 있습니다 . 최상의 결과를 얻으려면 외래 키 편집을위한 콤보 박스 편집기를 제공하는 델리게이트 인 &lt;a href=&quot;qsqlrelationaldelegate&quot;&gt;QSqlRelationalDelegate&lt;/a&gt; 도 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="09ef24f246ae761385d5c60bcf9d536799fc4842" translate="yes" xml:space="preserve">
          <source>If all you want is to define a color, texture or gradient for the background, you can call &lt;a href=&quot;qgraphicsview#backgroundBrush-prop&quot;&gt;setBackgroundBrush&lt;/a&gt;() instead.</source>
          <target state="translated">원하는 배경의 색, 질감 또는 그라디언트를 정의하는 것 대신 &lt;a href=&quot;qgraphicsview#backgroundBrush-prop&quot;&gt;setBackgroundBrush&lt;/a&gt; ()를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84a8692c875cf40e469328dfd25b8e70a8005ffc" translate="yes" xml:space="preserve">
          <source>If all you want is to define a color, texture or gradient for the foreground, you can call &lt;a href=&quot;qgraphicsscene#foregroundBrush-prop&quot;&gt;setForegroundBrush&lt;/a&gt;() instead.</source>
          <target state="translated">전경의 색상, 질감 또는 그라디언트를 정의하기 &lt;a href=&quot;qgraphicsscene#foregroundBrush-prop&quot;&gt;만하면&lt;/a&gt; 대신 setForegroundBrush ()를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1881b77140e94dfcdd14584b2a4475506ac765b1" translate="yes" xml:space="preserve">
          <source>If all you want is to define a color, texture or gradient for the foreground, you can call &lt;a href=&quot;qgraphicsview#foregroundBrush-prop&quot;&gt;setForegroundBrush&lt;/a&gt;() instead.</source>
          <target state="translated">전경의 색상, 질감 또는 그라디언트를 정의하기 &lt;a href=&quot;qgraphicsview#foregroundBrush-prop&quot;&gt;만하면&lt;/a&gt; 대신 setForegroundBrush ()를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a15d37f773743f2eda649d5f17b976aaf5dba03" translate="yes" xml:space="preserve">
          <source>If all you want is to define a color, texture, or gradient for the background, you can call &lt;a href=&quot;qgraphicsscene#backgroundBrush-prop&quot;&gt;setBackgroundBrush&lt;/a&gt;() instead.</source>
          <target state="translated">원하는 배경의 색, 질감 또는 그라디언트를 정의하는 것이라면 대신 &lt;a href=&quot;qgraphicsscene#backgroundBrush-prop&quot;&gt;setBackgroundBrush&lt;/a&gt; ()를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="408231d83a92344913b30961708621f1da70c7c6" translate="yes" xml:space="preserve">
          <source>If all you want is to rotate or scale an item, you should call &lt;a href=&quot;qgraphicsitem#setRotation&quot;&gt;setRotation&lt;/a&gt;() or &lt;a href=&quot;qgraphicsitem#setScale&quot;&gt;setScale&lt;/a&gt;() instead. If you want to set an arbitrary transformation on an item, you can call &lt;a href=&quot;qgraphicsitem#setTransform&quot;&gt;setTransform&lt;/a&gt;().</source>
          <target state="translated">원하는 항목을 회전하거나 크기를 조정하는 &lt;a href=&quot;qgraphicsitem#setRotation&quot;&gt;것이라면 setRotation&lt;/a&gt; () 또는 &lt;a href=&quot;qgraphicsitem#setScale&quot;&gt;setScale&lt;/a&gt; ()을 대신 호출해야 합니다. 항목에 임의 변환을 설정하려면 &lt;a href=&quot;qgraphicsitem#setTransform&quot;&gt;setTransform&lt;/a&gt; ()을 호출하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="ad224005a6ef0d8aa7bf0e11f8a08fc66c88d3ff" translate="yes" xml:space="preserve">
          <source>If all you want is to store items inside other items, you can use any &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt; directly by passing a suitable parent to &lt;a href=&quot;qgraphicsitem#setParentItem&quot;&gt;setParentItem&lt;/a&gt;().</source>
          <target state="translated">원하는 항목을 다른 항목에 저장하는 것이라면 적절한 부모를 &lt;a href=&quot;qgraphicsitem#setParentItem&quot;&gt;setParentItem&lt;/a&gt; () 에 전달하여 &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem을&lt;/a&gt; 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1fc3210be626afa38e4770bf42583409e6cee135" translate="yes" xml:space="preserve">
          <source>If an</source>
          <target state="translated">만약에</target>
        </trans-unit>
        <trans-unit id="50cdd79ec61f950bb0a0d84a0bafb738de01dff8" translate="yes" xml:space="preserve">
          <source>If an action is checkable, an &lt;a href=&quot;qml-qtquick-controls-exclusivegroup&quot;&gt;ExclusiveGroup&lt;/a&gt; can be attached to it. All the actions sharing the same exclusive group become mutually exclusive selectable, meaning that only the last checked action will actually be checked.</source>
          <target state="translated">조치를 확인할 수있는 경우 &lt;a href=&quot;qml-qtquick-controls-exclusivegroup&quot;&gt;ExclusiveGroup&lt;/a&gt; 을 첨부 할 수 있습니다. 동일한 독점 그룹을 공유하는 모든 조치는 상호 배타적 선택이 가능하므로 마지막으로 확인 된 조치 만 실제로 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="761fea39cca19d47f358de83c67e997c353fef29" translate="yes" xml:space="preserve">
          <source>If an add transition is specified, it is applied immediately after this signal is handled.</source>
          <target state="translated">추가 전환이 지정되면이 신호가 처리 된 직후에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="66ae48125f4ec9aca13e4dbb097ba74fe85fbecb" translate="yes" xml:space="preserve">
          <source>If an affector has a defined size, then it will only affect particles within its size and position on screen.</source>
          <target state="translated">이펙터에 정의 된 크기가있는 경우 크기와 화면 위치에있는 입자에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="69d14880485f6bd77339ae470c0e9acd8db7d368" translate="yes" xml:space="preserve">
          <source>If an animation is started, &lt;a href=&quot;qml-qtwayland-compositor-waylandquickitem#bufferLocked-prop&quot;&gt;bufferLocked&lt;/a&gt; should be set to ensure the item keeps its content until the animation finishes</source>
          <target state="translated">애니메이션이 시작되면 애니메이션이 끝날 때까지 항목이 내용을 유지하도록 &lt;a href=&quot;qml-qtwayland-compositor-waylandquickitem#bufferLocked-prop&quot;&gt;bufferLocked&lt;/a&gt; 를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="400a25b5deb93741b30f8284f4de6e670ff1124f" translate="yes" xml:space="preserve">
          <source>If an animation is started, &lt;a href=&quot;qwaylandquickitem#bufferLocked-prop&quot;&gt;bufferLocked&lt;/a&gt; should be set to ensure the item keeps its content until the animation finishes</source>
          <target state="translated">애니메이션이 시작되면 애니메이션이 끝날 때까지 항목이 내용을 유지하도록 &lt;a href=&quot;qwaylandquickitem#bufferLocked-prop&quot;&gt;bufferLocked&lt;/a&gt; 를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="f34571f7ade2297c281d7019c6c85e78b8341b74" translate="yes" xml:space="preserve">
          <source>If an application needs information about notations and unparsed entities, it can implement this interface and register an instance with &lt;a href=&quot;qxmlreader#setDTDHandler&quot;&gt;QXmlReader::setDTDHandler&lt;/a&gt;().</source>
          <target state="translated">애플리케이션에 표기법 및 구문 분석되지 않은 엔티티에 대한 정보가 필요한 경우이 인터페이스를 구현하고 &lt;a href=&quot;qxmlreader#setDTDHandler&quot;&gt;QXmlReader :: setDTDHandler&lt;/a&gt; ()에 인스턴스를 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="948b6654fa7c40857712f6d83bc3909bfcd960b9" translate="yes" xml:space="preserve">
          <source>If an application needs to implement customized handling for external entities, it must implement this interface, i.e. &lt;a href=&quot;qxmlentityresolver#resolveEntity&quot;&gt;resolveEntity&lt;/a&gt;(), and register it with &lt;a href=&quot;qxmlreader#setEntityResolver&quot;&gt;QXmlReader::setEntityResolver&lt;/a&gt;().</source>
          <target state="translated">응용 프로그램이 외부 엔티티 처리를 사용자 정의 구현하려면 필요가있는 경우,이 인터페이스, 즉 구현해야하는 &lt;a href=&quot;qxmlentityresolver#resolveEntity&quot;&gt;것으로 resolveEntity을&lt;/a&gt; ()과에 등록 &lt;a href=&quot;qxmlreader#setEntityResolver&quot;&gt;QXmlReader :: setEntityResolver을&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="13c3b4cca152912ba30f98709cbfc2c4008b9a82" translate="yes" xml:space="preserve">
          <source>If an application needs true RNG data in bulk, it should use the operating system facilities (such as &lt;code&gt;/dev/random&lt;/code&gt; on Linux) directly and wait for entropy to become available. If the application requires PRNG engines of cryptographic quality but not of true randomness, &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator::system&lt;/a&gt;() may still be used (see section below).</source>
          <target state="translated">응용 프로그램에 실제 RNG 데이터가 대량으로 필요한 경우 운영 체제 기능 (예 : Linux의 &lt;code&gt;/dev/random&lt;/code&gt; )을 직접 사용하고 엔트로피를 사용할 수있을 때까지 기다려야합니다. 애플리케이션에 암호화 품질의 PRNG 엔진이 필요하지만 실제 무작위성이 아닌 경우 &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator :: system&lt;/a&gt; ()을 계속 사용할 수 있습니다 (아래 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="e4e823c58bf064ecdc2f69696205348cdae4a45a" translate="yes" xml:space="preserve">
          <source>If an application performs poorly, make sure that rendering is actually the bottleneck. Use a profiler! The environment variable &lt;code&gt;QSG_RENDER_TIMING=1&lt;/code&gt; will output a number of useful timing parameters which can be useful in pinpointing where a problem lies.</source>
          <target state="translated">응용 프로그램의 성능이 저하되면 렌더링이 실제로 병목 현상이 발생하는지 확인하십시오. 프로파일 러를 사용하십시오! 환경 변수 &lt;code&gt;QSG_RENDER_TIMING=1&lt;/code&gt; 은 문제가있는 위치를 정확히 찾아내는 데 유용한 여러 유용한 타이밍 매개 변수를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="89f4227e7009f796ab96460aa88371e8445ab545" translate="yes" xml:space="preserve">
          <source>If an application requests a name that is already owned, no queueing will be performed. The registeredService() call will simply fail. This is the default.</source>
          <target state="translated">응용 프로그램이 이미 소유 한 이름을 요청하면 대기열이 수행되지 않습니다. registeredService () 호출은 단순히 실패합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="f5137fbed5c07687d4e47a79af43fbf251e25694" translate="yes" xml:space="preserve">
          <source>If an application uses plugins or imports that depend on other modules, these modules have to be listed in the application's dependencies. This is because Qt Creator does not know ahead of time which imports or plugins your application will end up loading.</source>
          <target state="translated">응용 프로그램이 다른 모듈에 종속 된 플러그인 또는 가져 오기를 사용하는 경우 이러한 모듈은 응용 프로그램의 종속 항목에 나열되어야합니다. Qt Creator는 애플리케이션이 어떤 가져 오기 또는 플러그인을 미리로드하는지 알 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="898f0f4eec90720fe644b07d2af840155b34e806" translate="yes" xml:space="preserve">
          <source>If an assignment is made beyond the end of the byte array, the array is extended with &lt;a href=&quot;qbytearray#resize&quot;&gt;resize&lt;/a&gt;() before the assignment takes place.</source>
          <target state="translated">바이트 배열의 끝을 넘어서 할당하는 경우 할당이 발생하기 전에 배열의 &lt;a href=&quot;qbytearray#resize&quot;&gt;크기가&lt;/a&gt; ()로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="86ee1392fd045a2fe63af919ae27d1e18764fbe7" translate="yes" xml:space="preserve">
          <source>If an asterisk (&lt;code&gt;*&lt;/code&gt;) is appended to the name when the property is registered, the field is a</source>
          <target state="translated">속성이 등록 될 때 이름에 별표 ( &lt;code&gt;*&lt;/code&gt; )가 추가되면 필드는</target>
        </trans-unit>
        <trans-unit id="a7e2b90c0a8754f231cbe0c221acae69e47b4758" translate="yes" xml:space="preserve">
          <source>If an attribute is not intended to be readable by end users, the label field should be kept empty as an indicator of this fact.</source>
          <target state="translated">최종 사용자가 속성을 읽을 수없는 경우 레이블 필드는이 사실을 나타내는 지표로 비워 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="ba598016b5fa4e687b3297b5fbc756a9e310c3cf" translate="yes" xml:space="preserve">
          <source>If an axis is not given, a temporary default axis with no labels and an automatically adjusting range is created. This temporary axis is destroyed if another axis is explicitly set to the same orientation.</source>
          <target state="translated">축을 지정하지 않으면 레이블이없고 자동 조정 범위가있는 임시 기본 축이 작성됩니다. 다른 축이 명시 적으로 동일한 방향으로 설정되면이 임시 축이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f96860b6090c64b035a54e60d30439c8732b6ff0" translate="yes" xml:space="preserve">
          <source>If an axis is not given, a temporary default axis with no labels is created. This temporary axis is destroyed if another axis is explicitly set to the same orientation.</source>
          <target state="translated">축을 지정하지 않으면 레이블이없는 임시 기본 축이 생성됩니다. 다른 축이 명시 적으로 동일한 방향으로 설정되면이 임시 축이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="19bf9bb34a4444beaa44f37db5459318d6548443" translate="yes" xml:space="preserve">
          <source>If an early return is taken or an exception is thrown before the &lt;code&gt;sem.release()&lt;/code&gt; call is reached, the semaphore is not released, possibly preventing the thread waiting in the corresponding &lt;code&gt;sem.acquire()&lt;/code&gt; call from ever continuing execution.</source>
          <target state="translated">&lt;code&gt;sem.release()&lt;/code&gt; 호출에 도달 하기 전에 조기 리턴이 발생하거나 예외가 발생 하면 세마포어가 해제되지 않아 해당 &lt;code&gt;sem.acquire()&lt;/code&gt; 호출에서 대기중인 스레드 가 계속 실행 되지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04df73bda5e9287f3b0a53e8199e721ed5d4ea91" translate="yes" xml:space="preserve">
          <source>If an effect is disabled, the source will be rendered with as normal, with no interference from the effect. If the effect is enabled, the source will be rendered with the effect applied.</source>
          <target state="translated">효과가 비활성화되면 소스는 효과의 간섭없이 정상적으로 렌더링됩니다. 효과가 활성화되면 효과가 적용된 소스가 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="f032363142cdd29dff458057e62db96cf0b00aab" translate="yes" xml:space="preserve">
          <source>If an element of a web page requests to be shown in the fullscreen mode, &lt;a href=&quot;qwebenginepage#fullScreenRequested&quot;&gt;QWebEnginePage::fullScreenRequested&lt;/a&gt; will be emitted with an &lt;a href=&quot;qwebenginefullscreenrequest&quot;&gt;QWebEngineFullScreenRequest&lt;/a&gt; instance as an argument where &lt;a href=&quot;qwebenginefullscreenrequest#toggleOn&quot;&gt;toggleOn&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;. The signal handler needs to then either call &lt;a href=&quot;qwebenginefullscreenrequest#accept&quot;&gt;accept&lt;/a&gt;() or &lt;a href=&quot;qwebenginefullscreenrequest#reject&quot;&gt;reject&lt;/a&gt;().</source>
          <target state="translated">웹 페이지의 요소가 전체 화면 모드로 표시되도록 요청하면 &lt;a href=&quot;qwebenginepage#fullScreenRequested&quot;&gt;QWebEnginePage :: fullScreenRequested&lt;/a&gt; 가 &lt;a href=&quot;qwebenginefullscreenrequest&quot;&gt;QWebEngineFullScreenRequest&lt;/a&gt; 인스턴스 와 함께 &lt;a href=&quot;qwebenginefullscreenrequest#toggleOn&quot;&gt;toggleOn&lt;/a&gt; ()이 &lt;code&gt;true&lt;/code&gt; 를 반환 하는 인수로 생성 됩니다. 그런 다음 신호 처리기는 &lt;a href=&quot;qwebenginefullscreenrequest#accept&quot;&gt;accept&lt;/a&gt; () 또는 &lt;a href=&quot;qwebenginefullscreenrequest#reject&quot;&gt;reject&lt;/a&gt; ()를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0bc6c278797bfa998baaf7abeb4ae3adf7bcf80d" translate="yes" xml:space="preserve">
          <source>If an empty</source>
          <target state="translated">비어있는 경우</target>
        </trans-unit>
        <trans-unit id="72e60a7f12ddf1edd38429ac4860de2c300914ab" translate="yes" xml:space="preserve">
          <source>If an empty &lt;a href=&quot;qssldiffiehellmanparameters&quot;&gt;QSslDiffieHellmanParameters&lt;/a&gt; instance is set on a &lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration&lt;/a&gt; object, Diffie-Hellman negotiation will be disabled.</source>
          <target state="translated">빈 &lt;a href=&quot;qssldiffiehellmanparameters&quot;&gt;QSslDiffieHellmanParameters&lt;/a&gt; 인스턴스가 &lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration&lt;/a&gt; 오브젝트 에 설정 되면 Diffie-Hellman 협상이 사용 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="ed7c23ff6fe5b81f1487ed087477d30fe5161f4f" translate="yes" xml:space="preserve">
          <source>If an empty list is returned, it can mean the SSL handshake failed, or it can mean the host you are connected to doesn't have a certificate, or it can mean there is no connection.</source>
          <target state="translated">빈 목록이 반환되면 SSL 핸드 셰이크가 실패했거나 연결된 호스트에 인증서가 없거나 연결이 없음을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56543f8a39cc5f720081cd5045f2b520471a5df6" translate="yes" xml:space="preserve">
          <source>If an empty string is assigned to &lt;code&gt;text&lt;/code&gt;, then &lt;a href=&quot;qml-qtpositioning-address#isTextGenerated-prop&quot;&gt;isTextGenerated&lt;/a&gt; will be set to true and &lt;code&gt;text&lt;/code&gt; will return a string which is locally formatted according to &lt;a href=&quot;qml-qtpositioning-address#countryCode-prop&quot;&gt;countryCode&lt;/a&gt; and based on the properties of the address. Modifying the address properties such as &lt;a href=&quot;qml-qtpositioning-address#street-prop&quot;&gt;street&lt;/a&gt;, &lt;a href=&quot;qml-qtpositioning-address#city-prop&quot;&gt;city&lt;/a&gt; and so on may cause the contents of &lt;code&gt;text&lt;/code&gt; to change.</source>
          <target state="translated">빈 문자열이 할당되어있는 경우 &lt;code&gt;text&lt;/code&gt; , 다음 &lt;a href=&quot;qml-qtpositioning-address#isTextGenerated-prop&quot;&gt;isTextGenerated는&lt;/a&gt; 사실과로 설정됩니다 &lt;code&gt;text&lt;/code&gt; 로컬에 따라 포맷 된 문자열을 반환합니다 &lt;a href=&quot;qml-qtpositioning-address#countryCode-prop&quot;&gt;countryCode와&lt;/a&gt; 및 주소의 속성을 기반으로합니다. &lt;a href=&quot;qml-qtpositioning-address#street-prop&quot;&gt;street&lt;/a&gt; , &lt;a href=&quot;qml-qtpositioning-address#city-prop&quot;&gt;city&lt;/a&gt; 등과 같은 주소 속성을 수정하면 &lt;code&gt;text&lt;/code&gt; 내용이 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24c310b14c2380f607f3b50508ed877ebfeb9cbf" translate="yes" xml:space="preserve">
          <source>If an empty string is provided to &lt;a href=&quot;qgeoaddress#setText&quot;&gt;setText&lt;/a&gt;(), then &lt;a href=&quot;qgeoaddress#isTextGenerated&quot;&gt;isTextGenerated&lt;/a&gt;() will be set to true and text() will return a string which is locally formatted according to &lt;a href=&quot;qgeoaddress#countryCode&quot;&gt;countryCode&lt;/a&gt;() and based on the elements of the address such as street, city and so on. Because the text string is generated from the address elements, a sequence of calls such as text(), &lt;a href=&quot;qgeoaddress#setStreet&quot;&gt;setStreet&lt;/a&gt;(), text() may return different strings for each invocation of text().</source>
          <target state="translated">빈 문자열이 &lt;a href=&quot;qgeoaddress#setText&quot;&gt;setText&lt;/a&gt; ()에 제공되면 &lt;a href=&quot;qgeoaddress#isTextGenerated&quot;&gt;isTextGenerated&lt;/a&gt; ()가 true로 설정되고 text ()는 &lt;a href=&quot;qgeoaddress#countryCode&quot;&gt;countryCode&lt;/a&gt; () 에 따라 거리, 도시와 같은 주소 요소에 따라 로컬로 형식화 된 문자열을 반환합니다. 등등. 텍스트 문자열은 주소 요소에서 생성되므로 text (), &lt;a href=&quot;qgeoaddress#setStreet&quot;&gt;setStreet&lt;/a&gt; (), text () 와 같은 일련의 호출은 text ()를 호출 할 때마다 다른 문자열을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb255e7a683c43023e37d8294bc25e97465037c2" translate="yes" xml:space="preserve">
          <source>If an entry spans many lines, use a backslash at the end of every line but the last:</source>
          <target state="translated">항목이 여러 줄에 걸쳐있는 경우 모든 줄 끝에는 마지막에 백 슬래시를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3f5ca5f4637982b0b74e4dc0aa8d13237dfb8be0" translate="yes" xml:space="preserve">
          <source>If an error happened during writing, deletes the temporary file and returns &lt;code&gt;false&lt;/code&gt;. Otherwise, renames it to the final &lt;a href=&quot;qsavefile#fileName&quot;&gt;fileName&lt;/a&gt; and returns &lt;code&gt;true&lt;/code&gt; on success. Finally, closes the device.</source>
          <target state="translated">쓰는 동안 오류가 발생하면 임시 파일을 삭제하고 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 그렇지 않으면, 마지막으로 이름을 변경 &lt;a href=&quot;qsavefile#fileName&quot;&gt;fileName에&lt;/a&gt; 리턴 &lt;code&gt;true&lt;/code&gt; 성공. 마지막으로 장치를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="33804e3d08a1f4f5e6010d70546cd41348f9fd70" translate="yes" xml:space="preserve">
          <source>If an error is encountered, the machine will look for an &lt;a href=&quot;qml-qtqml-statemachine-state#errorState-prop&quot;&gt;errorState&lt;/a&gt;, and if one is available, it will enter this state. After the error state is entered, the type of the error can be retrieved with error(). The execution of the state graph will not stop when the error state is entered. If no error state applies to the erroneous state, the machine will stop executing and an error message will be printed to the console.</source>
          <target state="translated">오류가 발생하면 시스템은 &lt;a href=&quot;qml-qtqml-statemachine-state#errorState-prop&quot;&gt;errorState&lt;/a&gt; 를 찾고 사용 가능한 경우이 상태로 들어갑니다. 오류 상태가 입력되면 error ()를 사용하여 오류 유형을 검색 할 수 있습니다. 오류 상태가 입력되면 상태 그래프의 실행이 중지되지 않습니다. 오류 상태에 오류 상태가 적용되지 않으면 기기 실행이 중지되고 오류 메시지가 콘솔에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ec5eef8e29cb3a61bb2e01d84eb0fad867870f69" translate="yes" xml:space="preserve">
          <source>If an error is encountered, the machine will look for an &lt;a href=&quot;qstate#errorState&quot;&gt;error state&lt;/a&gt;, and if one is available, it will enter this state. The types of errors possible are described by the &lt;a href=&quot;qstatemachine#Error-enum&quot;&gt;Error&lt;/a&gt; enum. After the error state is entered, the type of the error can be retrieved with &lt;a href=&quot;qstatemachine#error&quot;&gt;error&lt;/a&gt;(). The execution of the state graph will not stop when the error state is entered. If no error state applies to the erroneous state, the machine will stop executing and an error message will be printed to the console.</source>
          <target state="translated">오류가 발생하면 머신은 &lt;a href=&quot;qstate#errorState&quot;&gt;오류 상태를&lt;/a&gt; 찾고 사용 가능한 경우이 상태로 들어갑니다. 가능한 에러 유형은 &lt;a href=&quot;qstatemachine#Error-enum&quot;&gt;Error&lt;/a&gt; 열거 형에 설명되어 있습니다. 오류 상태가되면 오류 유형으로 &lt;a href=&quot;qstatemachine#error&quot;&gt;오류&lt;/a&gt; ()를 검색 할 수 있습니다 . 오류 상태가 입력되면 상태 그래프의 실행이 중지되지 않습니다. 오류 상태에 오류 상태가 적용되지 않으면 기기 실행이 중지되고 오류 메시지가 콘솔에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="6e944103b05f2294f3725a2b79090ec0ee2cc9d6" translate="yes" xml:space="preserve">
          <source>If an error is sent, the return value and any output parameters from the called slot will be ignored by Qt D-Bus.</source>
          <target state="translated">에러가 전송되면 반환 된 값과 호출 된 슬롯의 출력 파라미터는 Qt D-Bus에 의해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="28256d05e60aab94c2e61cd345eb1d775bb272c0" translate="yes" xml:space="preserve">
          <source>If an error occurred during evaluation of the query, true is returned.</source>
          <target state="translated">쿼리 평가 중에 오류가 발생하면 true가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d237eb991eb13e678bcd34e563c5983a68509cac" translate="yes" xml:space="preserve">
          <source>If an error occurred within the application while saving its data, you may want to try &lt;a href=&quot;qsessionmanager#allowsErrorInteraction&quot;&gt;allowsErrorInteraction&lt;/a&gt;() instead.</source>
          <target state="translated">데이터를 저장하는 동안 응용 프로그램 내에서 오류가 발생한 경우, &lt;a href=&quot;qsessionmanager#allowsErrorInteraction&quot;&gt;allowErrorInteraction&lt;/a&gt; ()을 대신 시도 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd3a7d7d87cf61a3c7f19bf4761d3c6495d20125" translate="yes" xml:space="preserve">
          <source>If an error occurs at any point in time, &lt;a href=&quot;qserialport&quot;&gt;QSerialPort&lt;/a&gt; will emit the &lt;a href=&quot;qserialport#errorOccurred&quot;&gt;errorOccurred&lt;/a&gt;() signal. You can also call &lt;a href=&quot;qserialport#error-prop&quot;&gt;error&lt;/a&gt;() to find the type of error that occurred last.</source>
          <target state="translated">오류가 발생하면 &lt;a href=&quot;qserialport&quot;&gt;QSerialPort&lt;/a&gt; 는 &lt;a href=&quot;qserialport#errorOccurred&quot;&gt;errorOccurred&lt;/a&gt; () 신호를 방출합니다 . &lt;a href=&quot;qserialport#error-prop&quot;&gt;error&lt;/a&gt; ()를 호출 하여 마지막에 발생한 오류 유형을 찾을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c149b9cd8dfe6507b2571196d46ddafeda4d8af" translate="yes" xml:space="preserve">
          <source>If an error occurs during serialization, result is undefined unless the serializer is driven through a call to &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;QXmlQuery::evaluateTo&lt;/a&gt;().</source>
          <target state="translated">직렬화 중에 오류가 발생하면 직렬화 &lt;a href=&quot;qxmlquery#evaluateTo&quot;&gt;기가 QXmlQuery :: evaluateTo&lt;/a&gt; ()에 대한 호출을 통해 구동되지 않는 한 결과가 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fca7cb4366a8cc7f4928b31533ddef67bce1a2bc" translate="yes" xml:space="preserve">
          <source>If an error occurs during the evaluation, error messages are sent to &lt;a href=&quot;qxmlquery#messageHandler&quot;&gt;messageHandler&lt;/a&gt;() and &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">평가 중에 오류가 발생하면 오류 메시지가 &lt;a href=&quot;qxmlquery#messageHandler&quot;&gt;messageHandler&lt;/a&gt; () 로 전송 되고 &lt;code&gt;false&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a9b750dd87c1c6e54be93304c09e8628835ccd19" translate="yes" xml:space="preserve">
          <source>If an error occurs during the evaluation, error messages are sent to &lt;a href=&quot;qxmlquery#messageHandler&quot;&gt;messageHandler&lt;/a&gt;(), the content of</source>
          <target state="translated">평가 중에 오류가 발생하면 오류 메시지가 &lt;a href=&quot;qxmlquery#messageHandler&quot;&gt;messageHandler&lt;/a&gt; () 로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="fe65aab215498c2d506b1f79d6ae7b73500130b8" translate="yes" xml:space="preserve">
          <source>If an error occurs or if there are no more arguments to decode (i.e., we are at the end of the argument list), this function will return an invalid &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;.</source>
          <target state="translated">오류가 발생하거나 디코딩 할 인수가 더 이상없는 경우 (즉, 인수 목록의 끝에 있습니다)이 함수는 잘못된 &lt;a href=&quot;qvariant&quot;&gt;QVariant를&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1bef62105e65297a1293c008bac6ff468d1f5c65" translate="yes" xml:space="preserve">
          <source>If an error occurs while parsing, &lt;a href=&quot;qxmlstreamreader#atEnd&quot;&gt;atEnd&lt;/a&gt;() and &lt;a href=&quot;qxmlstreamreader#hasError&quot;&gt;hasError&lt;/a&gt;() return true, and &lt;a href=&quot;qxmlstreamreader#error&quot;&gt;error&lt;/a&gt;() returns the error that occurred. The functions &lt;a href=&quot;qxmlstreamreader#errorString&quot;&gt;errorString&lt;/a&gt;(), &lt;a href=&quot;qxmlstreamreader#lineNumber&quot;&gt;lineNumber&lt;/a&gt;(), &lt;a href=&quot;qxmlstreamreader#columnNumber&quot;&gt;columnNumber&lt;/a&gt;(), and &lt;a href=&quot;qxmlstreamreader#characterOffset&quot;&gt;characterOffset&lt;/a&gt;() are for constructing an appropriate error or warning message. To simplify application code, &lt;a href=&quot;qxmlstreamreader&quot;&gt;QXmlStreamReader&lt;/a&gt; contains a &lt;a href=&quot;qxmlstreamreader#raiseError&quot;&gt;raiseError&lt;/a&gt;() mechanism that lets you raise custom errors that trigger the same error handling described.</source>
          <target state="translated">구문 분석 중 오류가 발생하면 &lt;a href=&quot;qxmlstreamreader#atEnd&quot;&gt;atEnd&lt;/a&gt; () 및 &lt;a href=&quot;qxmlstreamreader#hasError&quot;&gt;hasError&lt;/a&gt; ()가 true를 리턴하고 &lt;a href=&quot;qxmlstreamreader#error&quot;&gt;error&lt;/a&gt; ()가 발생한 오류를 리턴합니다. &lt;a href=&quot;qxmlstreamreader#errorString&quot;&gt;errorString&lt;/a&gt; (), &lt;a href=&quot;qxmlstreamreader#lineNumber&quot;&gt;lineNumber&lt;/a&gt; (), &lt;a href=&quot;qxmlstreamreader#columnNumber&quot;&gt;columnNumber&lt;/a&gt; () 및 &lt;a href=&quot;qxmlstreamreader#characterOffset&quot;&gt;characterOffset&lt;/a&gt; () 함수 는 적절한 오류 또는 경고 메시지를 구성하기위한 것입니다. 응용 프로그램 코드를 단순화하기 위해 &lt;a href=&quot;qxmlstreamreader&quot;&gt;QXmlStreamReader&lt;/a&gt; 에는 &lt;a href=&quot;qxmlstreamreader#raiseError&quot;&gt;raiseError&lt;/a&gt; () 메커니즘이 포함되어있어 설명 된 것과 동일한 오류 처리를 트리거하는 사용자 지정 오류를 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb2df796c2a62ab55d8b9980af6a56dd92e7be3e" translate="yes" xml:space="preserve">
          <source>If an error occurs while writing to the underlying device, &lt;a href=&quot;qxmlstreamwriter#hasError&quot;&gt;hasError&lt;/a&gt;() starts returning true and subsequent writes are ignored.</source>
          <target state="translated">기본 장치에 쓰는 동안 오류가 발생하면 &lt;a href=&quot;qxmlstreamwriter#hasError&quot;&gt;hasError&lt;/a&gt; ()가 true를 반환하기 시작하고 후속 쓰기는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1e825178fa37f03b56e537ea1009d8ddbe199689" translate="yes" xml:space="preserve">
          <source>If an error occurs, &lt;a href=&quot;qlocalserver#serverError&quot;&gt;serverError&lt;/a&gt;() returns the type of error, and &lt;a href=&quot;qlocalserver#errorString&quot;&gt;errorString&lt;/a&gt;() can be called to get a human readable description of what happened.</source>
          <target state="translated">오류가 발생하면 &lt;a href=&quot;qlocalserver#serverError&quot;&gt;serverError&lt;/a&gt; ()가 오류 유형을 반환하고 &lt;a href=&quot;qlocalserver#errorString&quot;&gt;errorString&lt;/a&gt; ()을 호출하여 발생한 일에 대한 사람이 읽을 수있는 설명을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae8458c7e3d29b2d3a67af9c848c0fa3e9193c67" translate="yes" xml:space="preserve">
          <source>If an error occurs, &lt;a href=&quot;qnearfieldsharemanager#shareError&quot;&gt;shareError&lt;/a&gt;() returns the error type.</source>
          <target state="translated">오류가 발생하면 &lt;a href=&quot;qnearfieldsharemanager#shareError&quot;&gt;shareError&lt;/a&gt; ()가 오류 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="264ac1bad3a37bfae7dcaad3b4dd26f205af7b73" translate="yes" xml:space="preserve">
          <source>If an error occurs, &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec()&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;. The error is then available as &lt;a href=&quot;qsqlquery#lastError&quot;&gt;QSqlQuery::lastError&lt;/a&gt;().</source>
          <target state="translated">오류가 발생하면 &lt;a href=&quot;qsqlquery#exec-1&quot;&gt;exec ()&lt;/a&gt; 는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 그런 다음 오류는 &lt;a href=&quot;qsqlquery#lastError&quot;&gt;QSqlQuery :: lastError&lt;/a&gt; ()로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="6ec0def9188583a1c0cd436a9cbb50625b9c4a6c" translate="yes" xml:space="preserve">
          <source>If an error occurs, &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; emits the &lt;a href=&quot;qsslsocket#sslErrors&quot;&gt;sslErrors&lt;/a&gt;() signal. In this case, if no action is taken to ignore the error(s), the connection is dropped. To continue, despite the occurrence of an error, you can call &lt;a href=&quot;qsslsocket#ignoreSslErrors&quot;&gt;ignoreSslErrors&lt;/a&gt;(), either from within this slot after the error occurs, or any time after construction of the &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; and before the connection is attempted. This will allow &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; to ignore the errors it encounters when establishing the identity of the peer. Ignoring errors during an SSL handshake should be used with caution, since a fundamental characteristic of secure connections is that they should be established with a successful handshake.</source>
          <target state="translated">오류가 발생하면 &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 은 &lt;a href=&quot;qsslsocket#sslErrors&quot;&gt;sslErrors&lt;/a&gt; () 신호를 방출합니다 . 이 경우 오류를 무시하기위한 조치를 취하지 않으면 연결이 끊어집니다. 계속해서 오류가 발생하더라도 오류가 발생한 &lt;a href=&quot;qsslsocket#ignoreSslErrors&quot;&gt;후이&lt;/a&gt; 슬롯 내에서 또는 &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 생성 후 및 연결을 시도하기 전에 언제라도 ignoreSslErrors ()를 호출 할 수 있습니다 . 이를 통해 &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; 은 피어의 ID를 설정할 때 발생하는 오류를 무시할 수 있습니다. 보안 핸드 셰이크의 기본 특성은 성공적인 핸드 셰이크와 함께 설정해야한다는 점에서 SSL 핸드 셰이크 중 오류를 무시하는 것은주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="036a29b5ab803a638536be75b09c38d8e3fe0c04" translate="yes" xml:space="preserve">
          <source>If an error occurs, &lt;a href=&quot;qtcpserver#serverError&quot;&gt;serverError&lt;/a&gt;() returns the type of error, and &lt;a href=&quot;qtcpserver#errorString&quot;&gt;errorString&lt;/a&gt;() can be called to get a human readable description of what happened.</source>
          <target state="translated">오류가 발생하면 &lt;a href=&quot;qtcpserver#serverError&quot;&gt;serverError&lt;/a&gt; ()가 오류 유형을 반환하고 &lt;a href=&quot;qtcpserver#errorString&quot;&gt;errorString&lt;/a&gt; ()을 호출하여 발생한 일에 대한 사람이 읽을 수있는 설명을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3e7dd17ef00f8895843a87ee4e62e12f8869a4f" translate="yes" xml:space="preserve">
          <source>If an error occurs, &lt;a href=&quot;qwebsocketserver#serverError&quot;&gt;serverError&lt;/a&gt;() returns the type of error, and &lt;a href=&quot;qwebsocketserver#errorString&quot;&gt;errorString&lt;/a&gt;() can be called to get a human readable description of what happened.</source>
          <target state="translated">오류가 발생하면 &lt;a href=&quot;qwebsocketserver#serverError&quot;&gt;serverError&lt;/a&gt; ()가 오류 유형을 반환하고 &lt;a href=&quot;qwebsocketserver#errorString&quot;&gt;errorString&lt;/a&gt; ()을 호출하여 발생한 일에 대한 사람이 읽을 수있는 설명을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b6e36963d48ec6ace8b5573ad798a49e9c365c1" translate="yes" xml:space="preserve">
          <source>If an error occurs, error messages are printed with &lt;a href=&quot;#qWarning&quot;&gt;qWarning&lt;/a&gt;.</source>
          <target state="translated">오류가 발생하면 오류 메시지가 &lt;a href=&quot;#qWarning&quot;&gt;qWarning&lt;/a&gt; 과 함께 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="73a6794fd2c3af100a73fed94bef9b2a8051f4d4" translate="yes" xml:space="preserve">
          <source>If an error occurs, socketError() returns the type of error, and &lt;a href=&quot;qiodevice#errorString&quot;&gt;errorString&lt;/a&gt;() can be called to get a human readable description of what happened.</source>
          <target state="translated">오류가 발생하면 socketError ()가 오류 유형을 반환하고 &lt;a href=&quot;qiodevice#errorString&quot;&gt;errorString&lt;/a&gt; ()을 호출하여 발생한 일에 대한 사람이 읽을 수있는 설명을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f22bb9beab8066b7d8812a5f1f55e20f918d5b8" translate="yes" xml:space="preserve">
          <source>If an error occurs, the &lt;a href=&quot;qqmlapplicationengine#objectCreated&quot;&gt;objectCreated&lt;/a&gt; signal is emitted with a null pointer as parameter and error messages are printed with &lt;a href=&quot;#qWarning&quot;&gt;qWarning&lt;/a&gt;.</source>
          <target state="translated">오류가 발생하면 &lt;a href=&quot;qqmlapplicationengine#objectCreated&quot;&gt;objectCreated&lt;/a&gt; 신호가 매개 변수로 널 포인터와 함께 &lt;a href=&quot;#qWarning&quot;&gt;생성&lt;/a&gt; 되고 오류 메시지가 qWarning 과 함께 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="5f90ef7a5b0dc33dce6a5ad689c81e6adfbe664f" translate="yes" xml:space="preserve">
          <source>If an error occurs, the method should return 0 and (optionally) give a description of the error in</source>
          <target state="translated">오류가 발생하면 메소드는 0을 반환하고 선택적으로 오류에 대한 설명을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="5f70c1f48b94f512a9b2c5eebe0e65831784781f" translate="yes" xml:space="preserve">
          <source>If an error occurs, you can fetch the &lt;a href=&quot;qaudio#Error-enum&quot;&gt;error type&lt;/a&gt; with the &lt;a href=&quot;qaudiooutput#error&quot;&gt;error&lt;/a&gt;() function. Please see the &lt;a href=&quot;qaudio#Error-enum&quot;&gt;QAudio::Error&lt;/a&gt; enum for a description of the possible errors that are reported. When an error is encountered, the state changes to &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio::StoppedState&lt;/a&gt;. You can check for errors by connecting to the &lt;a href=&quot;qaudiooutput#stateChanged&quot;&gt;stateChanged&lt;/a&gt;() signal:</source>
          <target state="translated">오류가 발생 하면 &lt;a href=&quot;qaudiooutput#error&quot;&gt;error&lt;/a&gt; () 함수를 사용하여 오류 &lt;a href=&quot;qaudio#Error-enum&quot;&gt;유형&lt;/a&gt; 을 가져올 수 있습니다 . 보고되는 가능한 오류에 대한 설명은 &lt;a href=&quot;qaudio#Error-enum&quot;&gt;QAudio :: Error&lt;/a&gt; 열거 형을 참조하십시오 . 오류가 발생하면 상태가 &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio :: StoppedState로&lt;/a&gt; 변경됩니다 . &lt;a href=&quot;qaudiooutput#stateChanged&quot;&gt;stateChanged&lt;/a&gt; () 신호 에 연결하여 오류를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f466349be22111215713f0bd3b9ec57c2600be8" translate="yes" xml:space="preserve">
          <source>If an error should occur, you can fetch its reason with &lt;a href=&quot;qaudioinput#error&quot;&gt;error&lt;/a&gt;(). The possible error reasons are described by the &lt;a href=&quot;qaudio#Error-enum&quot;&gt;QAudio::Error&lt;/a&gt; enum. The &lt;a href=&quot;qaudioinput&quot;&gt;QAudioInput&lt;/a&gt; will enter the &lt;a href=&quot;qaudio#State-enum&quot;&gt;StoppedState&lt;/a&gt; when an error is encountered. Connect to the &lt;a href=&quot;qaudioinput#stateChanged&quot;&gt;stateChanged&lt;/a&gt;() signal to handle the error:</source>
          <target state="translated">오류가 발생하면 &lt;a href=&quot;qaudioinput#error&quot;&gt;오류&lt;/a&gt; () 와 함께 이유를 가져올 수 있습니다 . 가능한 오류 이유는 &lt;a href=&quot;qaudio#Error-enum&quot;&gt;QAudio :: Error&lt;/a&gt; 열거 형에 설명되어 있습니다. 오류가 발생 하면 &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudioInput&lt;/a&gt; 이 &lt;a href=&quot;qaudioinput&quot;&gt;StoppedState에&lt;/a&gt; 들어갑니다 . &lt;a href=&quot;qaudioinput#stateChanged&quot;&gt;stateChanged&lt;/a&gt; () 신호에 연결 하여 오류를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="973bd4eafdb38084daa2d6e21fc18ca80235c65a" translate="yes" xml:space="preserve">
          <source>If an error was detected, the error message should be printed to the standard error output and the application should return an exit code other than 0.</source>
          <target state="translated">오류가 감지되면 오류 메시지를 표준 오류 출력으로 인쇄해야하며 응용 프로그램은 0 이외의 종료 코드를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="59601913fc9e3c2ac3c19ce1498d2d2eaf80610d" translate="yes" xml:space="preserve">
          <source>If an explicit size is not specified for the Loader, the Loader is automatically resized to the size of the loaded item once the component is loaded.</source>
          <target state="translated">로더에 명시적인 크기가 지정되지 않은 경우, 구성 요소가로드되면 로더는로드 된 항목의 크기로 자동 크기 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="22ab88ca3a5a8291cc2d27c1ef70e8195db7b3e0" translate="yes" xml:space="preserve">
          <source>If an inline item is pushed, the item is temporarily re-parented into the &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt;. When the item is later popped off, it gets re-parented back to its original owner again. If, however, an item is pushed as a component or a URL, the actual item will be created as an item from that component. This happens automatically when the item is about to become the current item in the stack. Ownership of the item will then normally be taken by the &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt;, which will automatically destroy the item when it is later popped off. The component that declared the item, by contrast, remains in the ownership of the application and is not destroyed by the stack. This can be overridden by explicitly setting &lt;code&gt;destroyOnPop&lt;/code&gt; in the list of arguments given to push.</source>
          <target state="translated">인라인 항목을 푸시하면 해당 항목이 일시적으로 &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView&lt;/a&gt; 로 다시 설정 됩니다. 나중에 항목이 튀어 나오면 다시 원래 소유자에게 다시 양육됩니다. 그러나 항목을 구성 요소 또는 URL로 푸시하면 실제 항목은 해당 구성 요소의 항목으로 생성됩니다. 항목이 스택의 현재 항목이 되려고 할 때 자동으로 발생합니다. 아이템의 소유권은 일반적으로 &lt;a href=&quot;qml-qtquick-controls-stackview&quot;&gt;StackView에&lt;/a&gt; 의해 가져 오며 , 나중에 아이템이 튀어 나오면 아이템이 자동으로 파괴됩니다. 반대로 항목을 선언 한 구성 요소는 응용 프로그램의 소유권으로 유지되며 스택에 의해 손상되지 않습니다. push에 제공된 인수 목록에서 &lt;code&gt;destroyOnPop&lt;/code&gt; 을 명시 적으로 설정하여이를 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d288ead2d30e4a672aceaead197696a9c9d20036" translate="yes" xml:space="preserve">
          <source>If an instance of &lt;code&gt;MessageBoard&lt;/code&gt; was set as the context data for a file &lt;code&gt;MyItem.qml&lt;/code&gt;, then &lt;code&gt;MyItem.qml&lt;/code&gt; could invoke the two methods as shown in the examples below:</source>
          <target state="translated">&lt;code&gt;MessageBoard&lt;/code&gt; 의 인스턴스가 &lt;code&gt;MyItem.qml&lt;/code&gt; 파일의 컨텍스트 데이터로 설정된 경우 &lt;code&gt;MyItem.qml&lt;/code&gt; 은 아래 예와 같이 두 개의 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e86be9fc7ab9d01ede032017739a974703a8f746" translate="yes" xml:space="preserve">
          <source>If an instance of this class was &lt;a href=&quot;qtqml-cppintegration-contextproperties#&quot;&gt;set as a context property&lt;/a&gt; when loading a file named &lt;code&gt;MyItem.qml&lt;/code&gt; from C++:</source>
          <target state="translated">C ++에서 &lt;code&gt;MyItem.qml&lt;/code&gt; 이라는 파일을로드 할 때이 클래스의 인스턴스가 &lt;a href=&quot;qtqml-cppintegration-contextproperties#&quot;&gt;컨텍스트 특성&lt;/a&gt; 으로 설정된 경우 :</target>
        </trans-unit>
        <trans-unit id="c91b97cac6fb99b6f0b4e9f10fcd4a1d82f87319" translate="yes" xml:space="preserve">
          <source>If an invalid color is specified, the tab will use the &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; foreground role instead.</source>
          <target state="translated">유효하지 않은 색상이 지정되면 탭은 대신 &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; 포 그라운드 역할을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="46a97c78b9b9b80bcd86cfe7489430b17bc51c38" translate="yes" xml:space="preserve">
          <source>If an invalid model index is specified for the parent item when an index is requested using &lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index()&lt;/a&gt;, the index returned refers to a top-level item in the model.</source>
          <target state="translated">&lt;a href=&quot;qabstractitemmodel#index&quot;&gt;index ()를&lt;/a&gt; 사용하여 색인을 요청할 때 상위 항목에 대해 유효하지 않은 모델 색인이 지정된 경우 리턴 된 색인은 모델의 최상위 항목을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="e057be5f1311bf8549d872262d25dd5d0fd5d7f2" translate="yes" xml:space="preserve">
          <source>If an invalid network configuration is set, a network session will not be created. In this case network requests will be processed regardless, but may fail. For example:</source>
          <target state="translated">유효하지 않은 네트워크 구성이 설정되면 네트워크 세션이 생성되지 않습니다. 이 경우 네트워크 요청은 관계없이 처리되지만 실패 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a41d0284139f3c71e2790385c7c6b44bbf2b218" translate="yes" xml:space="preserve">
          <source>If an invokable member function returns a pointer to a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; or a subclass of &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; and it is invoked from QML, special ownership rules apply. See &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;Data Type Conversion Between QML and C++&lt;/a&gt; for more information.</source>
          <target state="translated">호출 가능한 멤버 함수에 대한 포인터를 반환하면 &lt;a href=&quot;qobject&quot;&gt;QObject를&lt;/a&gt; 또는 서브 클래스 &lt;a href=&quot;qobject&quot;&gt;QObject를을&lt;/a&gt; 그리고 그것은 QML에서 호출, 특수 소유권 규칙이 적용됩니다. 자세한 &lt;a href=&quot;qtqml-cppintegration-data&quot;&gt;정보는 QML과 C ++ 간의 데이터 유형 변환&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dda15a0a66f926c4811aa8665fca50e5fd191869" translate="yes" xml:space="preserve">
          <source>If an item accepts a mouse button, it will become the mouse grabber item when a mouse press event is delivered for that mouse button. However, if the item does not accept the button, &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; will forward the mouse events to the first item beneath it that does.</source>
          <target state="translated">항목이 마우스 버튼을 허용하면 해당 마우스 버튼에 대한 마우스 프레스 이벤트가 전달 될 때 마우스 그래버 항목이됩니다. 그러나 항목이 버튼을 수락하지 않으면 &lt;a href=&quot;qgraphicsscene&quot;&gt;QGraphicsScene&lt;/a&gt; 은 마우스 이벤트를 그 아래의 첫 번째 항목으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="2525bb9f51e172b5b4f74d9f79f390530a0ed092" translate="yes" xml:space="preserve">
          <source>If an item becomes invisible while grabbing the mouse, (i.e., while it is receiving mouse events,) it will automatically lose the mouse grab, and the grab is not regained by making the item visible again; it must receive a new mouse press to regain the mouse grab.</source>
          <target state="translated">마우스를 잡는 동안 (즉, 마우스 이벤트를 수신하는 동안) 아이템이 보이지 않게되면, 마우스 잡기를 자동으로 잃어 버리고 아이템을 다시 볼 수있게하여 잡기를 다시 얻지 못합니다. 마우스를 다시 잡으려면 새로운 마우스 프레스를 받아야합니다.</target>
        </trans-unit>
        <trans-unit id="a3b1fe47a0fdacc2035f1af4df9a92a3bf66850f" translate="yes" xml:space="preserve">
          <source>If an item does not accept the mouse button for a particular mouse event, the mouse event will not be delivered to the item and will be delivered to the next item in the item hierarchy instead.</source>
          <target state="translated">항목이 특정 마우스 이벤트에 대해 마우스 버튼을 허용하지 않으면 마우스 이벤트는 해당 항목으로 전달되지 않고 대신 항목 계층 구조의 다음 항목으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="db071a6c0a58530bf5281fabc634a745b6740794" translate="yes" xml:space="preserve">
          <source>If an item has a focus proxy, the focus proxy will receive input focus when the item gains input focus. The item itself will still have focus (i.e., &lt;a href=&quot;qgraphicsitem#hasFocus&quot;&gt;hasFocus&lt;/a&gt;() will return true), but only the focus proxy will receive the keyboard input.</source>
          <target state="translated">아이템에 포커스 프록시가있는 경우, 포커스 프록시는 아이템에 입력 포커스가있을 때 입력 포커스를받습니다. 항목 자체에는 여전히 포커스가 있지만 (즉, &lt;a href=&quot;qgraphicsitem#hasFocus&quot;&gt;hasFocus&lt;/a&gt; ()는 true를 반환 함) 포커스 프록시 만 키보드 입력을받습니다.</target>
        </trans-unit>
        <trans-unit id="88daf3a64dc215bf9c0f079f87f04cd2d1fb2dd8" translate="yes" xml:space="preserve">
          <source>If an item has child objects, &lt;a href=&quot;qabstractitemmodel#hasChildren&quot;&gt;hasChildren&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt; for the corresponding index.</source>
          <target state="translated">항목에 자식 개체가있는 경우 &lt;a href=&quot;qabstractitemmodel#hasChildren&quot;&gt;hasChildren&lt;/a&gt; () 은 해당 인덱스에 대해 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="c59dfc80bf29e089cf4d40254ee230dbe720eae3" translate="yes" xml:space="preserve">
          <source>If an item has timers or animations, consider pausing them on receiving the &lt;a href=&quot;qml-qtquick-tableview#pooled-signal&quot;&gt;TableView::pooled&lt;/a&gt; signal. That way you avoid using the CPU resources for items that are not visible. Likewise, if an item has resources that cannot be reused, they could be freed up.</source>
          <target state="translated">아이템에 타이머 또는 애니메이션이있는 경우 &lt;a href=&quot;qml-qtquick-tableview#pooled-signal&quot;&gt;TableView :: pooled&lt;/a&gt; 신호 를 수신 할 때 일시 중지하는 것이 좋습니다. 이렇게하면 보이지 않는 항목에 CPU 리소스를 사용하지 않아도됩니다. 마찬가지로, 재사용 할 수없는 자원이있는 항목이 있으면 해제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb1804210bbf18d00004f9cb77f4ad798cd31729" translate="yes" xml:space="preserve">
          <source>If an item is anchored with no spacing associated with the anchor, it will use the default spacing.</source>
          <target state="translated">앵커와 연결된 간격이없는 항목이 고정 된 경우 기본 간격이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eaf9f0e58b31ed3d20c46aef22c0b5e4d5bce8e8" translate="yes" xml:space="preserve">
          <source>If an item is displaced by multiple types of operations at the same time, it is not defined as to whether the &lt;a href=&quot;qml-qtquick-gridview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-gridview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; or removeDisplaced transition will be applied. Additionally, if it is not necessary to specify different transitions depending on whether an item is displaced by an add, move or remove operation, consider setting the &lt;a href=&quot;qml-qtquick-gridview#displaced-prop&quot;&gt;displaced&lt;/a&gt; property instead.</source>
          <target state="translated">항목이 여러 유형의 작업으로 동시에 대체되는 경우 &lt;a href=&quot;qml-qtquick-gridview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-gridview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; 또는 removeDisplaced 전환이 적용 되는지 여부에 대해서는 정의되지 않습니다 . 또한 항목이 추가, 이동 또는 제거 작업으로 대체되는지 여부에 따라 다른 전환을 지정할 필요가 없으면 &lt;a href=&quot;qml-qtquick-gridview#displaced-prop&quot;&gt;대체&lt;/a&gt; 속성을 대신 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="a01377c4d13a0e43d9dd5ccc563fc3e5ee3ee571" translate="yes" xml:space="preserve">
          <source>If an item is displaced by multiple types of operations at the same time, it is not defined as to whether the &lt;a href=&quot;qml-qtquick-gridview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt;, moveDisplaced or &lt;a href=&quot;qml-qtquick-gridview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; transition will be applied. Additionally, if it is not necessary to specify different transitions depending on whether an item is displaced by an add, move or remove operation, consider setting the &lt;a href=&quot;qml-qtquick-gridview#displaced-prop&quot;&gt;displaced&lt;/a&gt; property instead.</source>
          <target state="translated">항목이 여러 유형의 작업으로 동시에 대체되는 경우 &lt;a href=&quot;qml-qtquick-gridview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt; , moveDisplaced 또는 &lt;a href=&quot;qml-qtquick-gridview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; 전환이 적용 되는지 여부에 대해서는 정의되지 않습니다 . 또한 항목이 추가, 이동 또는 제거 작업으로 대체되는지 여부에 따라 다른 전환을 지정할 필요가 없으면 &lt;a href=&quot;qml-qtquick-gridview#displaced-prop&quot;&gt;대체&lt;/a&gt; 속성을 대신 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7147b624161bf99a005b5ffad51817624987ff4" translate="yes" xml:space="preserve">
          <source>If an item is displaced by multiple types of operations at the same time, it is not defined as to whether the &lt;a href=&quot;qml-qtquick-listview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-listview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; or removeDisplaced transition will be applied. Additionally, if it is not necessary to specify different transitions depending on whether an item is displaced by an add, move or remove operation, consider setting the &lt;a href=&quot;qml-qtquick-listview#displaced-prop&quot;&gt;displaced&lt;/a&gt; property instead.</source>
          <target state="translated">항목이 여러 유형의 작업으로 동시에 대체되는 경우 &lt;a href=&quot;qml-qtquick-listview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-listview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; 또는 removeDisplaced 전환이 적용 되는지 여부에 대해서는 정의되지 않습니다 . 또한 항목이 추가, 이동 또는 제거 작업으로 대체되는지 여부에 따라 다른 전환을 지정할 필요가 없으면 &lt;a href=&quot;qml-qtquick-listview#displaced-prop&quot;&gt;대체&lt;/a&gt; 속성을 대신 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6eef7ea0302788e44c6a55d4bc9bd122e914543" translate="yes" xml:space="preserve">
          <source>If an item is displaced by multiple types of operations at the same time, it is not defined as to whether the &lt;a href=&quot;qml-qtquick-listview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt;, moveDisplaced or &lt;a href=&quot;qml-qtquick-listview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; transition will be applied. Additionally, if it is not necessary to specify different transitions depending on whether an item is displaced by an add, move or remove operation, consider setting the &lt;a href=&quot;qml-qtquick-listview#displaced-prop&quot;&gt;displaced&lt;/a&gt; property instead.</source>
          <target state="translated">항목이 여러 유형의 작업으로 동시에 대체되는 경우 &lt;a href=&quot;qml-qtquick-listview#addDisplaced-prop&quot;&gt;addDisplaced&lt;/a&gt; , moveDisplaced 또는 &lt;a href=&quot;qml-qtquick-listview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; 전환이 적용 되는지 여부에 대해서는 정의되지 않습니다 . 또한 항목이 추가, 이동 또는 제거 작업으로 대체되는지 여부에 따라 다른 전환을 지정할 필요가 없으면 &lt;a href=&quot;qml-qtquick-listview#displaced-prop&quot;&gt;대체&lt;/a&gt; 속성을 대신 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="563f1177e8a89edda4dd1b75a04481dc196367a3" translate="yes" xml:space="preserve">
          <source>If an item is displaced by multiple types of operations at the same time, it is not defined as to whether the addDisplaced, &lt;a href=&quot;qml-qtquick-gridview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-gridview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; transition will be applied. Additionally, if it is not necessary to specify different transitions depending on whether an item is displaced by an add, move or remove operation, consider setting the &lt;a href=&quot;qml-qtquick-gridview#displaced-prop&quot;&gt;displaced&lt;/a&gt; property instead.</source>
          <target state="translated">항목이 여러 유형의 작업으로 동시에 대체되는 경우 addDisplaced, &lt;a href=&quot;qml-qtquick-gridview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-gridview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; 전환이 적용 되는지 여부에 대해서는 정의되지 않습니다 . 또한 항목이 추가, 이동 또는 제거 작업으로 대체되는지 여부에 따라 다른 전환을 지정할 필요가 없으면 &lt;a href=&quot;qml-qtquick-gridview#displaced-prop&quot;&gt;대체&lt;/a&gt; 속성을 대신 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5e6c9617795220ce7bb4b35837eb5d0d3fb1697" translate="yes" xml:space="preserve">
          <source>If an item is displaced by multiple types of operations at the same time, it is not defined as to whether the addDisplaced, &lt;a href=&quot;qml-qtquick-listview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-listview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; transition will be applied. Additionally, if it is not necessary to specify different transitions depending on whether an item is displaced by an add, move or remove operation, consider setting the &lt;a href=&quot;qml-qtquick-listview#displaced-prop&quot;&gt;displaced&lt;/a&gt; property instead.</source>
          <target state="translated">항목이 여러 유형의 작업으로 동시에 대체되는 경우 addDisplaced, &lt;a href=&quot;qml-qtquick-listview#moveDisplaced-prop&quot;&gt;moveDisplaced&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-listview#removeDisplaced-prop&quot;&gt;removeDisplaced&lt;/a&gt; 전환이 적용 되는지 여부에 대해서는 정의되지 않습니다 . 또한 항목이 추가, 이동 또는 제거 작업으로 대체되는지 여부에 따라 다른 전환을 지정할 필요가 없으면 &lt;a href=&quot;qml-qtquick-listview#displaced-prop&quot;&gt;대체&lt;/a&gt; 속성을 대신 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="a77ffbf3b69b3f9fcf01afb73d1f3076f5ab223d" translate="yes" xml:space="preserve">
          <source>If an item matched, the</source>
          <target state="translated">항목이 일치하면</target>
        </trans-unit>
        <trans-unit id="f0b4a4c5a210b9f75e49f4b52e3a9612ad378ce8" translate="yes" xml:space="preserve">
          <source>If an item within a Column is not &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;visible&lt;/a&gt;, or if it has a width or height of 0, the item will not be laid out and it will not be visible within the column. Also, since a Column automatically positions its children vertically, a child item within a Column should not set its &lt;a href=&quot;qml-qtquick-item#y-prop&quot;&gt;y&lt;/a&gt; position or vertically anchor itself using the &lt;a href=&quot;qml-qtquick-item#anchors.top-prop&quot;&gt;top&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-item#anchors.bottom-prop&quot;&gt;bottom&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-item#anchors.verticalCenter-prop&quot;&gt;anchors.verticalCenter&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-item#anchors.fill-prop&quot;&gt;fill&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-item#anchors.centerIn-prop&quot;&gt;centerIn&lt;/a&gt; anchors. If you need to perform these actions, consider positioning the items without the use of a Column.</source>
          <target state="translated">열 내의 항목이 &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;표시&lt;/a&gt; 되지 않거나 너비 또는 높이가 0 인 경우 항목이 배치되지 않고 열 내에 표시되지 않습니다. 열이 자동으로 아이를 수직에 배치 때문에, 기둥 내 자식 항목은 설정하지 않아야 &lt;a href=&quot;qml-qtquick-item#y-prop&quot;&gt;Y&lt;/a&gt; 위치 또는 수직으로 사용 자체를 고정 &lt;a href=&quot;qml-qtquick-item#anchors.top-prop&quot;&gt;상단&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-item#anchors.bottom-prop&quot;&gt;하단&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-item#anchors.verticalCenter-prop&quot;&gt;anchors.verticalCenter&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-item#anchors.fill-prop&quot;&gt;채우기&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-item#anchors.centerIn-prop&quot;&gt;centerIn의&lt;/a&gt; 앵커를. 이러한 작업을 수행해야하는 경우 열을 사용하지 않고 항목을 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="22ca940214679dd201251e43e5be4ca75f7f11e5" translate="yes" xml:space="preserve">
          <source>If an item within a Flow is not &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;visible&lt;/a&gt;, or if it has a width or height of 0, the item will not be laid out and it will not be visible within the Flow. Also, since a Flow automatically positions its children, a child item within a Flow should not set its &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-item#y-prop&quot;&gt;y&lt;/a&gt; positions or anchor itself with any of the &lt;a href=&quot;qml-qtquick-item#anchors-prop&quot;&gt;anchor&lt;/a&gt; properties.</source>
          <target state="translated">흐름 내의 항목이 &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;표시&lt;/a&gt; 되지 않거나 너비 또는 높이가 0 인 경우 항목이 배치되지 않고 흐름 내에 표시되지 않습니다. 또한 Flow는 자동으로 하위 항목을 배치하므로 Flow 내의 하위 항목은 &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-item#y-prop&quot;&gt;y&lt;/a&gt; 위치를 설정하거나 &lt;a href=&quot;qml-qtquick-item#anchors-prop&quot;&gt;앵커&lt;/a&gt; 속성으로 고정 되지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="b59e7f6d35b887903ba5a5ea3d910b34669a076f" translate="yes" xml:space="preserve">
          <source>If an item within a Grid is not &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;visible&lt;/a&gt;, or if it has a width or height of 0, the item will not be laid out and it will not be visible within the column. Also, since a Grid automatically positions its children, a child item within a Grid should not set its &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-item#y-prop&quot;&gt;y&lt;/a&gt; positions or anchor itself with any of the &lt;a href=&quot;qml-qtquick-item#anchors-prop&quot;&gt;anchor&lt;/a&gt; properties.</source>
          <target state="translated">그리드 내의 항목이 &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;표시&lt;/a&gt; 되지 않거나 너비 또는 높이가 0 인 경우 항목이 배치되지 않고 열 내에 표시되지 않습니다. 또한 Grid는 자동으로 자식을 배치하므로 Grid 내의 자식 항목은 &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-item#y-prop&quot;&gt;y&lt;/a&gt; 위치를 설정하거나 &lt;a href=&quot;qml-qtquick-item#anchors-prop&quot;&gt;앵커&lt;/a&gt; 속성으로 고정 하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="28ac00ed7a7788607ab521804713c06de879399a" translate="yes" xml:space="preserve">
          <source>If an item within a Row is not &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;visible&lt;/a&gt;, or if it has a width or height of 0, the item will not be laid out and it will not be visible within the row. Also, since a Row automatically positions its children horizontally, a child item within a Row should not set its &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; position or horizontally anchor itself using the &lt;a href=&quot;qml-qtquick-item#anchors.left-prop&quot;&gt;left&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-item#anchors.right-prop&quot;&gt;right&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-item#anchors.horizontalCenter-prop&quot;&gt;anchors.horizontalCenter&lt;/a&gt;, &lt;a href=&quot;qml-qtquick-item#anchors.fill-prop&quot;&gt;fill&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-item#anchors.centerIn-prop&quot;&gt;centerIn&lt;/a&gt; anchors. If you need to perform these actions, consider positioning the items without the use of a Row.</source>
          <target state="translated">행 내의 항목이 &lt;a href=&quot;qml-qtquick-item#visible-prop&quot;&gt;표시&lt;/a&gt; 되지 않거나 너비 또는 높이가 0 인 경우 항목이 배치되지 않고 행 내에 표시되지 않습니다. 또한 Row는 자동으로 자식을 수평으로 배치하므로 Row 내의 자식 항목 은 &lt;a href=&quot;qml-qtquick-item#anchors.left-prop&quot;&gt;left&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-item#anchors.right-prop&quot;&gt;right&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-item#anchors.horizontalCenter-prop&quot;&gt;anchors.horizontalCenter&lt;/a&gt; , &lt;a href=&quot;qml-qtquick-item#anchors.fill-prop&quot;&gt;fill&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-item#anchors.centerIn-prop&quot;&gt;centerIn&lt;/a&gt; 앵커를 사용하여 &lt;a href=&quot;qml-qtquick-item#x-prop&quot;&gt;x&lt;/a&gt; 위치를 설정 하거나 자체적으로 수평으로 고정 해서는 안됩니다 . 이러한 작업을 수행해야하는 경우 행을 사용하지 않고 항목을 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="a519eae81a73125ec24fca162ab9af46f636ab21" translate="yes" xml:space="preserve">
          <source>If an operation is not ongoing, invoking cancel() has no effect.</source>
          <target state="translated">작업이 진행 중이 아닌 경우 cancel () 호출은 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7f7dbd2e59ab39acd86db71993cc22f042bdae9" translate="yes" xml:space="preserve">
          <source>If an orientation and &lt;a href=&quot;qml-qtquick-pathanimation#endRotation-prop&quot;&gt;endRotation&lt;/a&gt; have been specified for the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#pathanimation&quot;&gt;PathAnimation&lt;/a&gt;, orientationExitDuration can be used to smoothly transition from the rotation given by the path orientation to the specified &lt;a href=&quot;qml-qtquick-pathanimation#endRotation-prop&quot;&gt;endRotation&lt;/a&gt;.</source>
          <target state="translated">배향하고 있으면 &lt;a href=&quot;qml-qtquick-pathanimation#endRotation-prop&quot;&gt;endRotation가&lt;/a&gt; 지정된 된 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#pathanimation&quot;&gt;PathAnimation&lt;/a&gt; , orientationExitDuration는 지정된 경로의 방향으로 소정의 회전에 원활하게 전환하는데 사용될 수 &lt;a href=&quot;qml-qtquick-pathanimation#endRotation-prop&quot;&gt;endRotation&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8910c3173edd273a2825d9067eafbd44eccabab" translate="yes" xml:space="preserve">
          <source>If an orientation has been specified for the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#pathanimation&quot;&gt;PathAnimation&lt;/a&gt;, and the path doesn't end with the item at the desired rotation, the endRotation property can be used to manually specify an end rotation.</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#pathanimation&quot;&gt;PathAnimation에&lt;/a&gt; 방향이 지정 되고 경로가 원하는 회전에서 항목으로 끝나지 않는 경우 endRotation 속성을 사용하여 끝 회전을 수동으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aace642d1deb2a5b01eccc48112aba47762fe3f" translate="yes" xml:space="preserve">
          <source>If an orientation has been specified for the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#pathanimation&quot;&gt;PathAnimation&lt;/a&gt;, and the starting rotation of the item does not match that given by the orientation, orientationEntryDuration can be used to smoothly transition from the item's starting rotation to the rotation given by the path orientation.</source>
          <target state="translated">&lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#pathanimation&quot;&gt;PathAnimation에&lt;/a&gt; 방향이 지정 되고 항목의 시작 회전이 방향에 지정된 회전과 일치하지 않으면 orientationEntryDuration을 사용하여 항목의 시작 회전에서 경로 방향에 의해 제공된 회전으로 부드럽게 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87b668c0d57c981ac3301a26d25a142c7bc7aeb7" translate="yes" xml:space="preserve">
          <source>If an origin manager does not supply a place id, it may be necessary to provide some other means of cross-referencing/matching. One approach might be to do so via the place coordinates, if the coordinate of a place in the origin manager is identical or close to a place in the destination manager, there is a high likelihood that they are the same place. In this case, the manager might implement &lt;a href=&quot;qplacemanager#matchingPlaces&quot;&gt;QPlaceManager::matchingPlaces&lt;/a&gt;() to accept a &lt;a href=&quot;qplacematchrequest&quot;&gt;QPlaceMatchRequest&lt;/a&gt; with a parameter key of 'proximity' and a parameter value of the distance two places must be in order to detect a match. for example if an origin place and destination place are within 50m of each other, they can be considered the same place.</source>
          <target state="translated">원산지 관리자가 장소 ID를 제공하지 않으면 다른 상호 참조 / 일치 방법을 제공해야 할 수도 있습니다. 원점 관리자의 장소 좌표가 목적지 관리자의 장소와 동일하거나 가까운 경우, 장소 좌표를 통해 한 가지 방법을 사용할 수 있습니다. 동일한 장소 일 가능성이 높습니다. 이 경우, 관리자는 &lt;a href=&quot;qplacemanager#matchingPlaces&quot;&gt;QPlaceManager :: matchingPlaces&lt;/a&gt; ()를 구현 하여 매개 변수 키 'proximity'와 일치를 감지하기 위해 두 위치가 있어야하는 거리의 매개 변수 값으로 &lt;a href=&quot;qplacematchrequest&quot;&gt;QPlaceMatchRequest&lt;/a&gt; 를 승인 할 수 있습니다. 예를 들어 출발지와 도착지가 서로 50m 이내 인 경우 동일한 장소로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5226b6eb5fdd39323807200970a6a478c4e8a2d8" translate="yes" xml:space="preserve">
          <source>If an unsupported parameter is specified the camera may fail to load, or the setting may be ignored.</source>
          <target state="translated">지원되지 않는 매개 변수를 지정하면 카메라가로드되지 않거나 설정이 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3646198c0f4ee74ff85857db4adf9d6c3a3ea807" translate="yes" xml:space="preserve">
          <source>If animating properties other than stroke and fill colors is a must, it is recommended to target systems providing &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; where the cost of property changes is smaller.</source>
          <target state="translated">획 및 칠 색상 이외의 속성에 애니메이션을 적용 &lt;code&gt;GL_NV_path_rendering&lt;/code&gt; 경우 속성 변경 비용이 적은 GL_NV_path_rendering을 제공하는 시스템을 대상으로 지정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ec1b2f4cb5e02b335838617f9e1a67357643f345" translate="yes" xml:space="preserve">
          <source>If another application already has the service name registered, attempt to replace it.</source>
          <target state="translated">다른 응용 프로그램에 이미 서비스 이름이 등록되어 있으면 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="887dbd073cc9c5d9c9fe95de56bae19f6b797a80" translate="yes" xml:space="preserve">
          <source>If another process (or another thread) has created the lock file already, this function will block until that process (or thread) releases it.</source>
          <target state="translated">다른 프로세스 (또는 다른 스레드)가 이미 잠금 파일을 작성한 경우이 기능은 해당 프로세스 (또는 스레드)가 잠금 파일을 해제 할 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="b7002c65508deebdef85cc972b8ef50457bd55d1" translate="yes" xml:space="preserve">
          <source>If another vertex array object is then bound you can later restore the set of state associated with this object by calling bind() on this object once again. This allows efficient changes between vertex data states in rendering functions.</source>
          <target state="translated">다른 정점 배열 객체가 바인딩 된 경우 나중에이 객체에서 bind ()를 다시 호출하여이 객체와 관련된 상태 세트를 복원 할 수 있습니다. 이를 통해 렌더링 함수에서 정점 데이터 상태를 효율적으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b52463c6b2ab39731c657da050bd5fad17d4b5f" translate="yes" xml:space="preserve">
          <source>If any error occurs when reading the image, &lt;a href=&quot;qimagereader#read&quot;&gt;read&lt;/a&gt;() will return a null &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt;. You can then call &lt;a href=&quot;qimagereader#error&quot;&gt;error&lt;/a&gt;() to find the type of error that occurred, or &lt;a href=&quot;qimagereader#errorString&quot;&gt;errorString&lt;/a&gt;() to get a human readable description of what went wrong.</source>
          <target state="translated">이미지를 &lt;a href=&quot;qimagereader#read&quot;&gt;읽을&lt;/a&gt; 때 오류가 발생하면 read ()는 null &lt;a href=&quot;qimage&quot;&gt;QImage를&lt;/a&gt; 반환합니다 . 그런 다음 &lt;a href=&quot;qimagereader#error&quot;&gt;error&lt;/a&gt; ()를 호출 하여 발생한 오류 유형을 찾거나 &lt;a href=&quot;qimagereader#errorString&quot;&gt;errorString&lt;/a&gt; ()을 통해 사람이 읽을 수있는 잘못된 설명을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68617e815d3e12a6dfcb29bebb22cb0781dd114b" translate="yes" xml:space="preserve">
          <source>If any error occurs when writing the image, &lt;a href=&quot;qimagewriter#write&quot;&gt;write&lt;/a&gt;() will return false. You can then call &lt;a href=&quot;qimagewriter#error&quot;&gt;error&lt;/a&gt;() to find the type of error that occurred, or &lt;a href=&quot;qimagewriter#errorString&quot;&gt;errorString&lt;/a&gt;() to get a human readable description of what went wrong.</source>
          <target state="translated">이미지를 &lt;a href=&quot;qimagewriter#write&quot;&gt;쓸&lt;/a&gt; 때 오류가 발생하면 write ()는 false를 반환합니다. 그런 다음 &lt;a href=&quot;qimagewriter#error&quot;&gt;error&lt;/a&gt; ()를 호출 하여 발생한 오류 유형을 찾거나 &lt;a href=&quot;qimagewriter#errorString&quot;&gt;errorString&lt;/a&gt; ()을 통해 사람이 읽을 수있는 잘못된 설명을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cc5a3d51ad5d41e8c6816f79dff4965021071c7" translate="yes" xml:space="preserve">
          <source>If any logical particle groups are specified here, then the affector will only be triggered if the particle being examined intersects with a particle of one of these groups.</source>
          <target state="translated">여기에 논리 입자 그룹이 지정되어 있으면 검사중인 입자가이 그룹 중 하나의 입자와 교차하는 경우에만 작동기가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="ce8aae18e6f006643443a6fa77d4e4b94eaecb42" translate="yes" xml:space="preserve">
          <source>If any of the widgets have stretch factors set to zero they will only get more space if no other widgets want the space. Of these, space is allocated to widgets with an &lt;a href=&quot;qsizepolicy#Policy-enum&quot;&gt;Expanding&lt;/a&gt; size policy first.</source>
          <target state="translated">위젯 중 신축 계수가 0으로 설정된 위젯은 다른 위젯이 공간을 원하지 않는 경우에만 더 많은 공간을 확보합니다. 이 중 공간 크기는 먼저 &lt;a href=&quot;qsizepolicy#Policy-enum&quot;&gt;확장&lt;/a&gt; 크기 정책을 사용하여 위젯에 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="cbca5be893568f75d0c9a0e73373842b05cb6e4e" translate="yes" xml:space="preserve">
          <source>If any of the widgets have stretch factors set, with a value greater than zero, then they are allocated space in proportion to their stretch factor (explained below).</source>
          <target state="translated">위젯 중 어떤 값에도 0보다 큰 신축 계수가 설정되어 있으면 신축 계수에 비례하여 공간이 할당됩니다 (아래 설명 참조).</target>
        </trans-unit>
        <trans-unit id="c2cee053a69d7b38ba4562aa2c7e6fcecab8b4ff" translate="yes" xml:space="preserve">
          <source>If applicable, &lt;a href=&quot;qqmlparserstatus#componentComplete&quot;&gt;QQmlParserStatus::componentComplete&lt;/a&gt;() is called on objects.</source>
          <target state="translated">해당되는 경우 &lt;a href=&quot;qqmlparserstatus#componentComplete&quot;&gt;QQmlParserStatus :: componentComplete&lt;/a&gt; ()가 객체에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4d6bdadabcfad5b636fb14748f6a098c298ebd14" translate="yes" xml:space="preserve">
          <source>If attributes are reported by &lt;a href=&quot;qxmlcontenthandler#startElement&quot;&gt;QXmlContentHandler::startElement&lt;/a&gt;() this class is used to pass the attribute values.</source>
          <target state="translated">&lt;a href=&quot;qxmlcontenthandler#startElement&quot;&gt;QXmlContentHandler :: startElement&lt;/a&gt; ()에 의해 속성이보고되면 이 클래스는 속성 값을 전달하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f5600755d0c6e340fa987d23251ec1a154c00eed" translate="yes" xml:space="preserve">
          <source>If auto-deletion is enabled, &lt;a href=&quot;qthreadpool&quot;&gt;QThreadPool&lt;/a&gt; will automatically delete this runnable after calling &lt;a href=&quot;qrunnable#run&quot;&gt;run&lt;/a&gt;(); otherwise, ownership remains with the application programmer.</source>
          <target state="translated">자동 삭제가 활성화 된 경우 &lt;a href=&quot;qthreadpool&quot;&gt;QThreadPool&lt;/a&gt; 은 &lt;a href=&quot;qrunnable#run&quot;&gt;run&lt;/a&gt; () 을 호출 한 후이 실행 가능 파일 을 자동으로 삭제합니다 . 그렇지 않으면 소유권은 응용 프로그램 프로그래머에게 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8d310d45ac49a7af5d801c302eb00208a29a379" translate="yes" xml:space="preserve">
          <source>If auto-exclusivity is enabled, checkable buttons that belong to the same parent item behave as if they were part of the same &lt;a href=&quot;qml-qtquick-controls2-buttongroup&quot;&gt;ButtonGroup&lt;/a&gt;. Only one button can be checked at any time; checking another button automatically unchecks the previously checked one.</source>
          <target state="translated">자동 배타성이 활성화 된 경우 동일한 상위 항목에 속하는 확인 가능한 버튼은 동일한 &lt;a href=&quot;qml-qtquick-controls2-buttongroup&quot;&gt;ButtonGroup의&lt;/a&gt; 일부인 것처럼 동작합니다 . 언제든지 하나의 버튼 만 확인할 수 있습니다. 다른 버튼을 확인하면 이전에 확인한 버튼이 자동으로 선택 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="27e3b6dc5e3be2da2755886906190ff75c2dfd9a" translate="yes" xml:space="preserve">
          <source>If auto-exclusivity is enabled, checkable buttons that belong to the same parent widget behave as if they were part of the same exclusive button group. In an exclusive button group, only one button can be checked at any time; checking another button automatically unchecks the previously checked one.</source>
          <target state="translated">자동 배타성이 활성화 된 경우 동일한 상위 위젯에 속하는 확인 가능한 버튼은 동일한 배타적 버튼 그룹의 일부인 것처럼 동작합니다. 단독 버튼 그룹에서는 언제든지 하나의 버튼 만 확인할 수 있습니다. 다른 버튼을 확인하면 이전에 확인한 버튼이 자동으로 선택 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="4b210a138caa1880abb1baa63c04ac8a174a31d4" translate="yes" xml:space="preserve">
          <source>If autoRepeat is enabled, then the &lt;a href=&quot;qabstractbutton#pressed&quot;&gt;pressed&lt;/a&gt;(), &lt;a href=&quot;qabstractbutton#released&quot;&gt;released&lt;/a&gt;(), and &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;clicked&lt;/a&gt;() signals are emitted at regular intervals when the button is down. autoRepeat is off by default. The initial delay and the repetition interval are defined in milliseconds by &lt;a href=&quot;qabstractbutton#autoRepeatDelay-prop&quot;&gt;autoRepeatDelay&lt;/a&gt; and &lt;a href=&quot;qabstractbutton#autoRepeatInterval-prop&quot;&gt;autoRepeatInterval&lt;/a&gt;.</source>
          <target state="translated">autoRepeat가 활성화 된 경우 버튼을 &lt;a href=&quot;qabstractbutton#pressed&quot;&gt;눌렀을 때 눌려진&lt;/a&gt; (), &lt;a href=&quot;qabstractbutton#released&quot;&gt;해제&lt;/a&gt; () 및 &lt;a href=&quot;qabstractbutton#clicked&quot;&gt;클릭 된&lt;/a&gt; () 신호가 일정한 간격으로 방출됩니다. autoRepeat는 기본적으로 해제되어 있습니다. 초기 지연 및 반복 간격은 &lt;a href=&quot;qabstractbutton#autoRepeatDelay-prop&quot;&gt;autoRepeatDelay&lt;/a&gt; 및 &lt;a href=&quot;qabstractbutton#autoRepeatInterval-prop&quot;&gt;autoRepeatInterval에&lt;/a&gt; 의해 밀리 초 단위로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0a16a9dee0562d5ec458526435092e26b9a2fed" translate="yes" xml:space="preserve">
          <source>If autoRotate is true, then the particle's rotation will be set so that it faces the direction of travel, plus any rotation from the rotation or &lt;a href=&quot;qml-qtquick-particles-particle#rotationVelocity-prop&quot;&gt;rotationVelocity&lt;/a&gt; properties.</source>
          <target state="translated">autoRotate가 true 인 경우 파티클의 회전은 이동 방향과 회전 또는 &lt;a href=&quot;qml-qtquick-particles-particle#rotationVelocity-prop&quot;&gt;rotationVelocity&lt;/a&gt; 속성 의 회전을 향하도록 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="3be588e591c5011e9be62bac7cd7ce2041b9dd9f" translate="yes" xml:space="preserve">
          <source>If available, the &lt;a href=&quot;qvideowidget&quot;&gt;QVideoWidget&lt;/a&gt; class can be used to view the video. As the life time of &lt;a href=&quot;qmediaplayer&quot;&gt;QMediaPlayer&lt;/a&gt; can be longer than the playback of one &lt;a href=&quot;qmediacontent&quot;&gt;QMediaContent&lt;/a&gt;, this property may change over time, the &lt;a href=&quot;qmediaplayer#videoAvailableChanged&quot;&gt;videoAvailableChanged&lt;/a&gt; signal can be used to monitor it's status.</source>
          <target state="translated">사용 가능한 경우 &lt;a href=&quot;qvideowidget&quot;&gt;QVideoWidget&lt;/a&gt; 클래스를 사용하여 비디오를 볼 수 있습니다. &lt;a href=&quot;qmediaplayer&quot;&gt;QMediaPlayer&lt;/a&gt; 의 수명 이 하나의 &lt;a href=&quot;qmediacontent&quot;&gt;QMediaContent&lt;/a&gt; 재생보다 길 수 있으므로이 속성은 시간이 지남에 따라 변경 될 수 있으며 &lt;a href=&quot;qmediaplayer#videoAvailableChanged&quot;&gt;videoAvailableChanged&lt;/a&gt; 신호를 사용하여 상태를 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edb2d684c66327c171add25153847052f7e6607a" translate="yes" xml:space="preserve">
          <source>If backend doesn't support applying this change in the active state, it will be stopped before the settings are changed and restarted after. Otherwise the backend should apply the change in the current state, with the camera status indicating the progress, if necessary.</source>
          <target state="translated">백엔드가 활성 상태에서이 변경 사항 적용을 지원하지 않으면 설정이 변경되기 전에 중지되고 이후에 다시 시작됩니다. 그렇지 않으면 백엔드가 현재 상태의 변경 사항을 적용해야하며 필요한 경우 카메라 상태가 진행률을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1309c3d128e1c32b3bd4eea411ded8a1eaf226d4" translate="yes" xml:space="preserve">
          <source>If binding from an activity, allow the target service's process importance to be raised based on whether the activity is visible to the user. See &lt;a href=&quot;https://developer.android.com/reference/android/content/Context.html#BIND_ADJUST_WITH_ACTIVITY&quot;&gt;BIND_ADJUST_WITH_ACTIVITY&lt;/a&gt; documentation for more details.</source>
          <target state="translated">활동에서 바인딩하는 경우 활동이 사용자에게 표시되는지 여부에 따라 대상 서비스의 프로세스 중요도를 높일 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://developer.android.com/reference/android/content/Context.html#BIND_ADJUST_WITH_ACTIVITY&quot;&gt;BIND_ADJUST_WITH_ACTIVITY&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a568013075f535888e2a5eb71b965d1b0804b520" translate="yes" xml:space="preserve">
          <source>If both</source>
          <target state="translated">둘 다</target>
        </trans-unit>
        <trans-unit id="5f30475e34b1e035521f6029aa858996bde69253" translate="yes" xml:space="preserve">
          <source>If both &lt;a href=&quot;qml-qtquick-layouts-layout#column-attached-prop&quot;&gt;column&lt;/a&gt; and this property are not set, it is up to the layout to assign a cell to the item.</source>
          <target state="translated">두 경우 &lt;a href=&quot;qml-qtquick-layouts-layout#column-attached-prop&quot;&gt;열&lt;/a&gt; 이 속성이 설정되지 않은, 그것은 항목에 셀을 할당 할 레이아웃까지입니다.</target>
        </trans-unit>
        <trans-unit id="7caf1a78d3f975a6dbdd689cef889189994acfc9" translate="yes" xml:space="preserve">
          <source>If both &lt;a href=&quot;qml-qtquick-layouts-layout#row-attached-prop&quot;&gt;row&lt;/a&gt; and this property are not set, it is up to the layout to assign a cell to the item.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-layouts-layout#row-attached-prop&quot;&gt;행&lt;/a&gt; 과이 속성이 모두 설정되지 않은 경우 셀을 항목에 할당하는 것은 레이아웃에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9443d82a60ca70bf09415f6f03dae0c01c444e6" translate="yes" xml:space="preserve">
          <source>If both &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel#source-prop&quot;&gt;source&lt;/a&gt; and &lt;code&gt;xml&lt;/code&gt; are set, &lt;code&gt;xml&lt;/code&gt; is used.</source>
          <target state="translated">두 경우 &lt;a href=&quot;qml-qtquick-xmllistmodel-xmllistmodel#source-prop&quot;&gt;소스&lt;/a&gt; 및 &lt;code&gt;xml&lt;/code&gt; 설정되어, &lt;code&gt;xml&lt;/code&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e5fa99ef8643e13ff83c9fd78c75e7d93341bae1" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;pointSize&lt;/code&gt; and a &lt;code&gt;pixelSize&lt;/code&gt; are specified, &lt;code&gt;pixelSize&lt;/code&gt; will be used.</source>
          <target state="translated">두 경우 &lt;code&gt;pointSize&lt;/code&gt; 와 &lt;code&gt;pixelSize&lt;/code&gt; 가 지정되어, &lt;code&gt;pixelSize&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="92a2e193299c1dfc9da123e8b7f3baf89a3a9f46" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;source&lt;/code&gt; and &lt;a href=&quot;xmlprocessing#xml&quot;&gt;xml&lt;/a&gt; are set, &lt;a href=&quot;xmlprocessing#xml&quot;&gt;xml&lt;/a&gt; is used.</source>
          <target state="translated">두 경우 &lt;code&gt;source&lt;/code&gt; 및 &lt;a href=&quot;xmlprocessing#xml&quot;&gt;XML이&lt;/a&gt; 설정되어, &lt;a href=&quot;xmlprocessing#xml&quot;&gt;XML이&lt;/a&gt; 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="48cba3422ebe21c2f3e1b20527de0ce981afe89b" translate="yes" xml:space="preserve">
          <source>If both a gradient and a color are specified, the gradient will be used.</source>
          <target state="translated">그라디언트와 색상이 모두 지정된 경우 그라디언트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c6dee2c0e7db87ff4604dbd1e8bba854e39931bc" translate="yes" xml:space="preserve">
          <source>If both a relative and absolute control position are specified for a control point's axis, the relative position will be used.</source>
          <target state="translated">제어점의 축에 대해 상대 및 절대 제어 위치가 모두 지정된 경우 상대 위치가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d47b355ba3f79fdb755b7d9110146c1c19ae41bb" translate="yes" xml:space="preserve">
          <source>If both a relative and absolute control position are specified for a single axis, the relative position will be used.</source>
          <target state="translated">단일 축에 대해 상대 및 절대 제어 위치가 모두 지정된 경우 상대 위치가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f5704bfed00f74d79876951317920586b1cd3d2e" translate="yes" xml:space="preserve">
          <source>If both a relative and absolute end position are specified for a single axis, the relative position will be used.</source>
          <target state="translated">단일 축에 상대 및 절대 끝 위치가 모두 지정된 경우 상대 위치가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="253bce1e65a0ba1ee24dad22a5b1e3d698789071" translate="yes" xml:space="preserve">
          <source>If both items have &lt;a href=&quot;qquickitem#activeFocusOnTab-prop&quot;&gt;activeFocusOnTab&lt;/a&gt; set to &lt;code&gt;true&lt;/code&gt;, this will also cause the tab focus order to change, with</source>
          <target state="translated">두 항목 모두 &lt;a href=&quot;qquickitem#activeFocusOnTab-prop&quot;&gt;activeFocusOnTab&lt;/a&gt; 이 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있으면 탭 포커스 순서가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="98d4c616939c29caadd6b0d1a38d5626a974117d" translate="yes" xml:space="preserve">
          <source>If both optional parameters</source>
          <target state="translated">두 옵션 매개 변수 모두</target>
        </trans-unit>
        <trans-unit id="a6260562a88c92d5431602f7c1245f1a2e378e88" translate="yes" xml:space="preserve">
          <source>If both output device and file name are specified, the output device will have precedence.</source>
          <target state="translated">출력 장치와 파일 이름이 모두 지정된 경우 출력 장치가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="f67595af56b043d937c7b884e0ab543ab8eec14a" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;headers&lt;/code&gt; and &lt;code&gt;headerdirs&lt;/code&gt; variables are defined, QDoc will read through both, first &lt;a href=&quot;#headers&quot;&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/a&gt; then &lt;code&gt;headerdirs&lt;/code&gt;.</source>
          <target state="translated">양쪽 경우 &lt;code&gt;headers&lt;/code&gt; 와 &lt;code&gt;headerdirs&lt;/code&gt; 변수가 정의된다 QDOC 모두 먼저 읽어 것이다 &lt;a href=&quot;#headers&quot;&gt; &lt;code&gt;headers&lt;/code&gt; &lt;/a&gt; 다음 &lt;code&gt;headerdirs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8527572e60f3d7efc620b73175ccae76f5787aca" translate="yes" xml:space="preserve">
          <source>If both the &lt;code&gt;sources&lt;/code&gt; and &lt;code&gt;sourcedirs&lt;/code&gt; variables are defined, QDoc will read through both, first &lt;a href=&quot;#sources&quot;&gt;&lt;code&gt;sources&lt;/code&gt;&lt;/a&gt; then &lt;code&gt;sourcedirs&lt;/code&gt;.</source>
          <target state="translated">양쪽 경우 &lt;code&gt;sources&lt;/code&gt; 및 &lt;code&gt;sourcedirs&lt;/code&gt; 변수가 정의되어 QDOC는 모두 먼저 읽어 것입니다 &lt;a href=&quot;#sources&quot;&gt; &lt;code&gt;sources&lt;/code&gt; &lt;/a&gt; 다음 &lt;code&gt;sourcedirs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0931321758c4b64b3f182223a58a348585653de" translate="yes" xml:space="preserve">
          <source>If both the old model and the old selection model do not have parents, or if their parents are long-lived objects, it may be preferable to call their &lt;a href=&quot;qobject#deleteLater&quot;&gt;deleteLater&lt;/a&gt;() functions to explicitly delete them.</source>
          <target state="translated">이전 모델과 이전 선택 모델 모두에 부모가 없거나 부모가 오래 지속되는 개체 인 경우 &lt;a href=&quot;qobject#deleteLater&quot;&gt;deleteLater&lt;/a&gt; () 함수를 호출 하여 명시 적으로 삭제하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3bf0bc3c22105940797c0584e03238cb366df382" translate="yes" xml:space="preserve">
          <source>If both the sourceSize.width and sourceSize.height are set the image will be scaled down to fit within the specified size (unless PreserveAspectCrop or PreserveAspectFit are used, then it will be scaled to match the optimal size for cropping/fitting), maintaining the image's aspect ratio. The actual size of the image after scaling is available via &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;Item::implicitWidth&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#implicitHeight-prop&quot;&gt;Item::implicitHeight&lt;/a&gt;.</source>
          <target state="translated">sourceSize.width 및 sourceSize.height가 둘 다 설정되어 있으면 PreserveAspectCrop 또는 PreserveAspectFit를 사용하지 않는 한 이미지가 지정된 크기에 맞게 축소됩니다 (자르기 / 맞춤에 대한 최적 크기에 맞게 크기가 조정 됨). 이미지의 종횡비. 크기 조정 후 이미지의 실제 크기는 &lt;a href=&quot;qml-qtquick-item#implicitWidth-prop&quot;&gt;Item :: implicitWidth&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-item#implicitHeight-prop&quot;&gt;Item :: implicitHeight&lt;/a&gt; 를 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee8009c658f480c37e71338ebd45f5279f8b9437" translate="yes" xml:space="preserve">
          <source>If both this property and the texture image are unset, a solid gray texture will be used.</source>
          <target state="translated">이 속성과 텍스처 이미지가 모두 설정되어 있지 않으면 회색 질감이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4f8bcbe62a68562752e51743a4770214a83da2e5" translate="yes" xml:space="preserve">
          <source>If building for iOS, and the &lt;code&gt;.plist&lt;/code&gt; file contains the key &lt;code&gt;NSPhotoLibraryUsageDescription&lt;/code&gt;, qmake will include an additional plugin to the build that adds photo access support (to, e.g., &lt;a href=&quot;qfiledialog#setDirectory&quot;&gt;QFile/QFileDialog&lt;/a&gt;). See Info.plist documentation from Apple for more information regarding this key.</source>
          <target state="translated">iOS 용으로 빌드하고 &lt;code&gt;.plist&lt;/code&gt; 파일에 &lt;code&gt;NSPhotoLibraryUsageDescription&lt;/code&gt; 키 가 포함 된 경우 qmake는 사진 액세스 지원 (예 : &lt;a href=&quot;qfiledialog#setDirectory&quot;&gt;QFile / QFileDialog 등&lt;/a&gt; ) 을 추가하는 빌드에 추가 플러그인을 포함합니다 . 이 키에 대한 자세한 내용은 Apple의 Info.plist 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b2a6b93a0b4674962b55a096d271c406cb506cc2" translate="yes" xml:space="preserve">
          <source>If called before &lt;a href=&quot;qaudioinput#start-1&quot;&gt;start&lt;/a&gt;(), returns platform default value. If called before &lt;a href=&quot;qaudioinput#start-1&quot;&gt;start&lt;/a&gt;() but &lt;a href=&quot;qaudioinput#setBufferSize&quot;&gt;setBufferSize&lt;/a&gt;() was called prior, returns value set by &lt;a href=&quot;qaudioinput#setBufferSize&quot;&gt;setBufferSize&lt;/a&gt;(). If called after &lt;a href=&quot;qaudioinput#start-1&quot;&gt;start&lt;/a&gt;(), returns the actual buffer size being used. This may not be what was set previously by &lt;a href=&quot;qaudioinput#setBufferSize&quot;&gt;setBufferSize&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qaudioinput#start-1&quot;&gt;start&lt;/a&gt; () 전에 호출되면 플랫폼 기본값을 반환합니다. &lt;a href=&quot;qaudioinput#start-1&quot;&gt;시작&lt;/a&gt; () 전에 호출 되었지만 &lt;a href=&quot;qaudioinput#setBufferSize&quot;&gt;setBufferSize&lt;/a&gt; ()가 이전에 호출 된 경우 &lt;a href=&quot;qaudioinput#setBufferSize&quot;&gt;setBufferSize&lt;/a&gt; ()에 의해 설정된 값을 리턴합니다 . &lt;a href=&quot;qaudioinput#start-1&quot;&gt;start&lt;/a&gt; () 이후에 호출되면 사용중인 실제 버퍼 크기를 반환합니다. 이전에 &lt;a href=&quot;qaudioinput#setBufferSize&quot;&gt;setBufferSize&lt;/a&gt; () 에서 설정 한 것이 아닐 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37e44e6e8d89b15598b8138a15c59083692a37cc" translate="yes" xml:space="preserve">
          <source>If called before &lt;a href=&quot;qaudiooutput#start-1&quot;&gt;start&lt;/a&gt;(), returns platform default value. If called before &lt;a href=&quot;qaudiooutput#start-1&quot;&gt;start&lt;/a&gt;() but &lt;a href=&quot;qaudiooutput#setBufferSize&quot;&gt;setBufferSize&lt;/a&gt;() was called prior, returns value set by &lt;a href=&quot;qaudiooutput#setBufferSize&quot;&gt;setBufferSize&lt;/a&gt;(). If called after &lt;a href=&quot;qaudiooutput#start-1&quot;&gt;start&lt;/a&gt;(), returns the actual buffer size being used. This may not be what was set previously by &lt;a href=&quot;qaudiooutput#setBufferSize&quot;&gt;setBufferSize&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qaudiooutput#start-1&quot;&gt;start&lt;/a&gt; () 전에 호출되면 플랫폼 기본값을 반환합니다. &lt;a href=&quot;qaudiooutput#start-1&quot;&gt;시작&lt;/a&gt; () 전에 호출 되었지만 &lt;a href=&quot;qaudiooutput#setBufferSize&quot;&gt;setBufferSize&lt;/a&gt; ()가 이전에 호출 된 경우 &lt;a href=&quot;qaudiooutput#setBufferSize&quot;&gt;setBufferSize&lt;/a&gt; ()에 의해 설정된 값을 리턴합니다 . &lt;a href=&quot;qaudiooutput#start-1&quot;&gt;start&lt;/a&gt; () 이후에 호출되면 사용중인 실제 버퍼 크기를 반환합니다. 이전에 &lt;a href=&quot;qaudiooutput#setBufferSize&quot;&gt;setBufferSize&lt;/a&gt; () 에서 설정 한 것이 아닐 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18f7dd3752cccfcac49ea63b3a59784c3c327e83" translate="yes" xml:space="preserve">
          <source>If called from a test function, the QSKIP() macro stops execution of the test without adding a failure to the test log. You can use it to skip tests that wouldn't make sense in the current configuration. The text</source>
          <target state="translated">테스트 함수에서 호출되면 QSKIP () 매크로는 테스트 로그에 실패를 추가하지 않고 테스트 실행을 중지합니다. 현재 구성에서 의미가없는 테스트를 건너 뛰는 데 사용할 수 있습니다. 텍스트</target>
        </trans-unit>
        <trans-unit id="f8558b40fb10030c1e232b0bf268311d02d5a134" translate="yes" xml:space="preserve">
          <source>If called from an _data function, the QSKIP() macro will stop execution of the _data function and will prevent execution of the associated test function.</source>
          <target state="translated">_data 함수에서 호출되면 QSKIP () 매크로는 _data 함수의 실행을 중지하고 연관된 테스트 함수의 실행을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="d34e76688c65c9ce162332ecbee9c9032f1d3e94" translate="yes" xml:space="preserve">
          <source>If called from initTestCase() or initTestCase_data(), the QSKIP() macro will skip all test and _data functions.</source>
          <target state="translated">initTestCase () 또는 initTestCase_data ()에서 호출 된 경우 QSKIP () 매크로는 모든 테스트 및 _data 함수를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="183f46fc9b1b88ba99ac513adb7d61b2e00099fa" translate="yes" xml:space="preserve">
          <source>If called from within a slot connected to the &lt;a href=&quot;qiodevice#bytesWritten&quot;&gt;bytesWritten&lt;/a&gt;() signal, &lt;a href=&quot;qiodevice#bytesWritten&quot;&gt;bytesWritten&lt;/a&gt;() will not be reemitted.</source>
          <target state="translated">&lt;a href=&quot;qiodevice#bytesWritten&quot;&gt;bytesWritten&lt;/a&gt; () 신호에 연결된 슬롯 내에서 호출 되면 &lt;a href=&quot;qiodevice#bytesWritten&quot;&gt;bytesWritten&lt;/a&gt; ()이 다시 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e139ca9778a890c137c6df57887e7a35793ae8a" translate="yes" xml:space="preserve">
          <source>If called from within a slot connected to the &lt;a href=&quot;qiodevice#readyRead&quot;&gt;readyRead&lt;/a&gt;() signal, &lt;a href=&quot;qiodevice#readyRead&quot;&gt;readyRead&lt;/a&gt;() will not be reemitted.</source>
          <target state="translated">&lt;a href=&quot;qiodevice#readyRead&quot;&gt;readyRead&lt;/a&gt; () 신호에 연결된 슬롯 내에서 호출 되면 &lt;a href=&quot;qiodevice#readyRead&quot;&gt;readyRead&lt;/a&gt; ()가 다시 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc24b50ab6bf67aa7599e8ffd4d50d334e39e5eb" translate="yes" xml:space="preserve">
          <source>If called in sequence or recursively, e.g., by one of the arranged items in response to being resized, this function will do nothing.</source>
          <target state="translated">예를 들어, 크기 조정에 응답하여 정렬 된 항목 중 하나에 의해 순차적으로 또는 재귀 적으로 호출되는 경우,이 기능은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89213a238a2cb606d0dc4b7fa08fbb887903dcf8" translate="yes" xml:space="preserve">
          <source>If called on an inner transaction, aborting is delegated to the outermost transaction, and subsequently started inner transactions are forced to fail.</source>
          <target state="translated">내부 트랜잭션에서 호출되면 중단이 가장 바깥 쪽 트랜잭션으로 위임되고 이후에 시작된 내부 트랜잭션이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="6e9d3c59a7006763cb17f9b3830680c4bb5b8b1c" translate="yes" xml:space="preserve">
          <source>If called on an inner transaction, committing will be postponed until the outermost commitTransaction(), &lt;a href=&quot;qdatastream#rollbackTransaction&quot;&gt;rollbackTransaction&lt;/a&gt;(), or &lt;a href=&quot;qdatastream#abortTransaction&quot;&gt;abortTransaction&lt;/a&gt;() call occurs.</source>
          <target state="translated">내부 트랜잭션에서 호출되면 가장 바깥 쪽 commitTransaction (), &lt;a href=&quot;qdatastream#rollbackTransaction&quot;&gt;rollbackTransaction&lt;/a&gt; () 또는 &lt;a href=&quot;qdatastream#abortTransaction&quot;&gt;abortTransaction&lt;/a&gt; () 호출이 발생할 때까지 커밋이 연기 됩니다.</target>
        </trans-unit>
        <trans-unit id="fe59847e05658b88a2554d62c8377119f971e6db" translate="yes" xml:space="preserve">
          <source>If called on an inner transaction, reverting is delegated to the outermost transaction, and subsequently started inner transactions are forced to fail.</source>
          <target state="translated">내부 트랜잭션에서 호출하면 되돌리기가 가장 바깥 쪽 트랜잭션으로 위임되고 이후에 시작된 내부 트랜잭션은 강제로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2bdd968d7bf941187d75253387801beb4a5a5a08" translate="yes" xml:space="preserve">
          <source>If camera supports fixed set of focus points, it should use the nearest supported focus point, and return the actual focus point with &lt;a href=&quot;qcamerafocuscontrol#focusZones&quot;&gt;QCameraFocusControl::focusZones&lt;/a&gt;().</source>
          <target state="translated">카메라가 고정 초점 포인트 세트를 지원하는 경우 가장 가까운 지원 포커스 포인트를 사용하고 &lt;a href=&quot;qcamerafocuscontrol#focusZones&quot;&gt;QCameraFocusControl :: focusZones&lt;/a&gt; ()를 사용하여 실제 포커스 포인트를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4523cc49caedd1e27386aa4aad5149b198264dc3" translate="yes" xml:space="preserve">
          <source>If canFetchMore() returns &lt;code&gt;true&lt;/code&gt;, the &lt;a href=&quot;qabstractitemmodel#fetchMore&quot;&gt;fetchMore&lt;/a&gt;() function should be called. This is the behavior of &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt;, for example.</source>
          <target state="translated">canFetchMore ()가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면 &lt;a href=&quot;qabstractitemmodel#fetchMore&quot;&gt;fetchMore&lt;/a&gt; () 함수를 호출해야합니다. 예를 들어 이것은 &lt;a href=&quot;qabstractitemview&quot;&gt;QAbstractItemView&lt;/a&gt; 의 동작입니다 .</target>
        </trans-unit>
        <trans-unit id="eb2432f76145b3a32c7eaa73f1af081fbccd13ad" translate="yes" xml:space="preserve">
          <source>If cell widget A is replaced with cell widget B, cell widget A will be deleted. For example, in the code snippet below, the &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; object will be deleted.</source>
          <target state="translated">셀 위젯 A가 셀 위젯 B로 바뀌면 셀 위젯 A가 삭제됩니다. 예를 들어 아래 코드 스 니펫에서 &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; 객체가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="63b5455fcd9238b6550e9b8f9097d5ebdc5bf9b8" translate="yes" xml:space="preserve">
          <source>If clipping is enabled, an item will clip its own painting, as well as the painting of its children, to its bounding rectangle.</source>
          <target state="translated">클리핑이 활성화 된 경우 항목은 자체 페인팅과 하위 페인팅을 경계 사각형에 클리핑합니다.</target>
        </trans-unit>
        <trans-unit id="233920261d9bbbb336bdcaaddceb4834236e40a0" translate="yes" xml:space="preserve">
          <source>If clipping is enabled, an item will clip its own painting, as well as the painting of its children, to its bounding rectangle. If you set clipping during an item's paint operation, remember to re-set it to prevent clipping the rest of your scene.</source>
          <target state="translated">클리핑이 활성화 된 경우 항목은 자체 페인팅과 하위 페인팅을 경계 사각형에 클리핑합니다. 항목의 페인트 작업 중에 클리핑을 설정 한 경우 나머지 장면이 클리핑되지 않도록 다시 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0bb2ac676e0e1fdf49453246baec2e2a0928e2c6" translate="yes" xml:space="preserve">
          <source>If commands were undone before</source>
          <target state="translated">이전에 명령을 취소 한 경우</target>
        </trans-unit>
        <trans-unit id="1fe851080b97c5f4762ebac99249309033aa4fd2" translate="yes" xml:space="preserve">
          <source>If creation of the texture view fails this function will return 0. If the function succeeds it will return a pointer to a new &lt;a href=&quot;qopengltexture&quot;&gt;QOpenGLTexture&lt;/a&gt; object that will return &lt;code&gt;true&lt;/code&gt; from its &lt;a href=&quot;qopengltexture#isTextureView&quot;&gt;isTextureView&lt;/a&gt;() function.</source>
          <target state="translated">텍스처 뷰 생성에 실패하면이 함수는 0을 반환합니다. 함수가 성공하면 &lt;a href=&quot;qopengltexture#isTextureView&quot;&gt;isTextureView&lt;/a&gt; () 함수 에서 &lt;code&gt;true&lt;/code&gt; 를 반환 하는 새로운 &lt;a href=&quot;qopengltexture&quot;&gt;QOpenGLTexture&lt;/a&gt; 객체에 대한 포인터를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="15a6dd0be52c74759044f271545514b3d4ff79e5" translate="yes" xml:space="preserve">
          <source>If custom layouts want special behaviour they can ignore to use this function, and implement their own behaviour.</source>
          <target state="translated">사용자 정의 레이아웃이 특수한 동작을 원하면이 기능을 사용하지 않고 자신의 동작을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e6b5606e3bc475a9f7ca2496b3c81f94c21323f" translate="yes" xml:space="preserve">
          <source>If defined, a link to the example project directory is generated at the end of each example documentation page. The &lt;code&gt;url.examples&lt;/code&gt; variable refers to the root directory of the examples related to this project; it can be a link to an online repository (starting with</source>
          <target state="translated">정의 된 경우 예제 프로젝트 디렉토리에 대한 링크는 각 예제 문서 페이지 끝에 생성됩니다. &lt;code&gt;url.examples&lt;/code&gt; 의 변수는이 프로젝트와 관련된 예제의 루트 디렉토리를 의미합니다; 온라인 저장소에 대한 링크 일 수 있습니다 (</target>
        </trans-unit>
        <trans-unit id="f00db5bc05b155be79e4a032099423e8695f6641" translate="yes" xml:space="preserve">
          <source>If defined, the value of this variable is used as a path to be prepended to the built shared library's &lt;code&gt;SONAME&lt;/code&gt; identifier. The &lt;code&gt;SONAME&lt;/code&gt; is the identifier that the dynamic linker will later use to reference the library. In general, this reference may be a library name or full library path. On &lt;a href=&quot;internationalization#macos&quot;&gt;macOS&lt;/a&gt;, iOS, tvOS, and watchOS, the path may be specified relatively using the following placeholders:</source>
          <target state="translated">정의 된 경우이 변수의 값은 빌드 된 공유 라이브러리의 &lt;code&gt;SONAME&lt;/code&gt; ID 앞에 추가 할 경로로 사용됩니다 . &lt;code&gt;SONAME&lt;/code&gt; 는 동적 링커 나중에 라이브러리를 참조하는 데 사용되는 식별자이다. 일반적으로이 참조는 라이브러리 이름 또는 전체 라이브러리 경로 일 수 있습니다. 에 &lt;a href=&quot;internationalization#macos&quot;&gt;맥 OS&lt;/a&gt; , 아이폰 OS, tvOS 및 watchOS 경로는 상대적으로 다음 자리 표시자를 사용하여 지정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0460837305394b382aee0d78c5a905162273723e" translate="yes" xml:space="preserve">
          <source>If designer is embedded in another program, one could to provide its own settings manager. The manager is used by the components of</source>
          <target state="translated">디자이너가 다른 프로그램에 포함 된 경우 자체 설정 관리자를 제공 할 수 있습니다. 관리자는 구성 요소에서 사용합니다</target>
        </trans-unit>
        <trans-unit id="b4a7e098c11504888295fcb496685cf40f86f523" translate="yes" xml:space="preserve">
          <source>If desired, the HLSL source code can be placed directly into the QML source, similarly to how its done with GLSL. The only difference in this case is the entry point name, which must be &lt;code&gt;main&lt;/code&gt; when using inline source strings.</source>
          <target state="translated">원하는 경우 HLSL 소스 코드를 GLSL을 사용한 방식과 유사하게 QML 소스에 직접 배치 할 수 있습니다. 이 경우 유일한 차이점은 시작점 이름이며 인라인 소스 문자열을 사용할 때 &lt;code&gt;main&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="21a29793a1e481ee91c77bc89f3649cf22bff43c" translate="yes" xml:space="preserve">
          <source>If double quotation marks are used to group the words, the search engine will search for an exact match of the quoted phrase.</source>
          <target state="translated">큰 따옴표를 사용하여 단어를 그룹화하면 검색 엔진이 인용 된 구문과 정확히 일치하는 항목을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="3ba53f98f6cd9baf7b11003f174e72ddb40a5ddc" translate="yes" xml:space="preserve">
          <source>If each &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; contains an array or map, the comparison is recursive to elements contained in them.</source>
          <target state="translated">각 &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; 에 배열 또는 맵이 포함되어 있으면 해당 배열에 포함 된 요소에 대해 비교가 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="5690484784958a51c8468b4c26e15de68622d1c8" translate="yes" xml:space="preserve">
          <source>If editing operations are not grouped, the document automatically records the individual operations so that they can be undone later. Grouping operations into larger packages can make editing more efficient both for the user and for the application, but care has to be taken not to group too many operations together as the user may want find-grained control over the undo process.</source>
          <target state="translated">편집 작업이 그룹화되지 않은 경우 문서는 나중에 취소 할 수 있도록 개별 작업을 자동으로 기록합니다. 작업을 더 큰 패키지로 그룹화하면 사용자와 응용 프로그램 모두에서보다 효율적으로 편집 할 수 있지만 사용자가 실행 취소 프로세스에 대한 세부적인 제어를 원할 수 있으므로 너무 많은 작업을 그룹화하지 않도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="09110ceb312edde4d747bc8c112a4b117106a1ca" translate="yes" xml:space="preserve">
          <source>If either</source>
          <target state="translated">어느 쪽이든</target>
        </trans-unit>
        <trans-unit id="824808c5f50489a3854e088aac4ea750131e9ce9" translate="yes" xml:space="preserve">
          <source>If either index is out of range, an empty list is returned.</source>
          <target state="translated">인덱스 중 하나가 범위를 벗어나면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c873cf0cd329238f4d2e1047a434d6bd4f637ec3" translate="yes" xml:space="preserve">
          <source>If either start or end is out of range, the selection is not changed.</source>
          <target state="translated">시작 또는 끝이 범위를 벗어나면 선택이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b44eedd7e90480e54638ad99bec6e704d7f97b27" translate="yes" xml:space="preserve">
          <source>If either the</source>
          <target state="translated">만약에</target>
        </trans-unit>
        <trans-unit id="1bcb0dec67f4b8a00c90374520bd4790f519760a" translate="yes" xml:space="preserve">
          <source>If elements refer to a name which does not have an explicit &lt;a href=&quot;qml-qtquick-particles-particlegroup&quot;&gt;ParticleGroup&lt;/a&gt; created, it will work normally (with no transitions specified for the group). If you do not need to assign duration based transitions to a group, you do not need to create a &lt;a href=&quot;qml-qtquick-particles-particlegroup&quot;&gt;ParticleGroup&lt;/a&gt; with that name (although you may).</source>
          <target state="translated">요소가 명시 적 &lt;a href=&quot;qml-qtquick-particles-particlegroup&quot;&gt;ParticleGroup이&lt;/a&gt; 생성 되지 않은 이름을 참조하면 정상적으로 작동합니다 (그룹에 대해 전환이 지정되지 않은 상태). 지속 시간 기반 전환을 그룹에 할당 할 필요가없는 경우 해당 이름 으로 &lt;a href=&quot;qml-qtquick-particles-particlegroup&quot;&gt;파티클&lt;/a&gt; 그룹을 만들 필요는 없습니다 (물론).</target>
        </trans-unit>
        <trans-unit id="80b9e83b5fda35c12842e123c0baed62f36113f9" translate="yes" xml:space="preserve">
          <source>If empty, it will affect all particles.</source>
          <target state="translated">비어 있으면 모든 입자에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="1f7dcb6c7582b13f59269a4424be94408ae5d3dd" translate="yes" xml:space="preserve">
          <source>If empty, it will paint the default particle group (&quot;&quot;).</source>
          <target state="translated">비어 있으면 기본 파티클 그룹 ( &quot;&quot;)을 페인트합니다.</target>
        </trans-unit>
        <trans-unit id="e97f704c286981ec3e01b97a7fc6201f935ca4b7" translate="yes" xml:space="preserve">
          <source>If empty, the option doesn't take a value.</source>
          <target state="translated">비어 있으면이 옵션은 값을 갖지 않습니다.</target>
        </trans-unit>
        <trans-unit id="326d044e9da46e7d58e32b15f63af0dee70a5571" translate="yes" xml:space="preserve">
          <source>If enabled (the default) the combo box draws itself inside a frame, otherwise the combo box draws itself without any frame.</source>
          <target state="translated">활성화 된 경우 (기본값) 콤보 상자가 프레임 내부에 그려집니다. 그렇지 않으면 콤보 상자가 프레임없이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="c6cb54b4804477cecb3c339696ff21909a688745" translate="yes" xml:space="preserve">
          <source>If enabled (the default) the line edit draws itself inside a frame, otherwise the line edit draws itself without any frame.</source>
          <target state="translated">활성화 된 경우 (기본값) 선 편집은 프레임 내부에 그려지며, 그렇지 않으면 선 편집은 프레임없이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="b0a1b99081b799c704c4cb0911e3ecc5c2bd7bd3" translate="yes" xml:space="preserve">
          <source>If enabled (the default) the spin box draws itself inside a frame, otherwise the spin box draws itself without any frame.</source>
          <target state="translated">활성화 된 경우 (기본값) 스핀 상자가 프레임 안에 그려집니다. 그렇지 않으면 스핀 상자가 프레임없이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="6491ab74e3d47aa3b1024aef291cd80e2282b350" translate="yes" xml:space="preserve">
          <source>If enabled is set to false, this affector will not affect any particles.</source>
          <target state="translated">enabled가 false로 설정되면이 영향자는 입자에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a098892864d06ca27e7337c6eb9e9dfb6793bbe9" translate="yes" xml:space="preserve">
          <source>If enabled the spin box will increase/decrease the value faster the longer you hold the button down.</source>
          <target state="translated">활성화 된 경우 스핀 상자는 버튼을 더 오래 누르고 있으면 값이 빠르게 증가 / 감소합니다.</target>
        </trans-unit>
        <trans-unit id="cf57ecbab79c1c4ddced20a0e915080a1730dce7" translate="yes" xml:space="preserve">
          <source>If enabled, CharData that consist of only whitespace characters are reported using &lt;a href=&quot;qxmlcontenthandler#characters&quot;&gt;QXmlContentHandler::characters&lt;/a&gt;(). If disabled, whitespace is silently discarded.</source>
          <target state="translated">사용 가능한 경우 공백 문자만으로 구성된 CharData는 &lt;a href=&quot;qxmlcontenthandler#characters&quot;&gt;QXmlContentHandler :: characters&lt;/a&gt; ()를 사용하여보고됩니다 . 비활성화하면 공백이 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="48a79ebe3d3712c8978448557ae9b90d9889a8f5" translate="yes" xml:space="preserve">
          <source>If enabled, namespaces are reported to the content handler.</source>
          <target state="translated">사용 가능한 경우 네임 스페이스가 컨텐츠 핸들러에보고됩니다.</target>
        </trans-unit>
        <trans-unit id="2b05bf74978662849358112f902c46830e9a6229" translate="yes" xml:space="preserve">
          <source>If enabled, the arrow can be oriented at any angle on the dial. If disabled, the arrow will be restricted to the upper part of the dial; if it is rotated into the space at the bottom of the dial, it will be clamped to the closest end of the valid range of values.</source>
          <target state="translated">활성화 된 경우 화살표는 다이얼의 어느 각도로도 향할 수 있습니다. 비활성화하면 화살표가 다이얼 상단으로 제한됩니다. 다이얼 하단의 공간으로 회전하면 유효한 값 범위의 가장 가까운 끝에 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="91ef754c2e005334e348aad6fd5dd87cb6936729" translate="yes" xml:space="preserve">
          <source>If enabled, the line edit displays a trailing</source>
          <target state="translated">활성화하면 라인 편집에 후행이 표시됩니다</target>
        </trans-unit>
        <trans-unit id="438f6b0808f198b8f2d93877eae63f1d1a5ea5a9" translate="yes" xml:space="preserve">
          <source>If enabled, the original prefixed names and attributes used for namespace declarations are reported.</source>
          <target state="translated">사용 가능한 경우 네임 스페이스 선언에 사용 된 원래 접두사 이름과 속성이보고됩니다.</target>
        </trans-unit>
        <trans-unit id="ceb02f7779c13d5427483107c09782bc8ae39641" translate="yes" xml:space="preserve">
          <source>If enabled, the parser reports QXmlContentHandler::startEntity() and QXmlContentHandler::endEntity() events, so character data might be reported in chunks. If disabled, the parser does not report these events, but silently substitutes the entities, and reports the character data in one chunk.</source>
          <target state="translated">사용 가능한 경우 구문 분석기는 QXmlContentHandler :: startEntity () 및 QXmlContentHandler :: endEntity () 이벤트를보고하므로 문자 데이터가 청크로보고 될 수 있습니다. 비활성화하면 구문 분석기는 이러한 이벤트를보고하지 않지만 엔티티를 자동으로 대체하고 문자 데이터를 한 청크로보고합니다.</target>
        </trans-unit>
        <trans-unit id="c9724288b6865038e90860c82b30b700ed144152" translate="yes" xml:space="preserve">
          <source>If enabled, this item will be destroyed when the &lt;code&gt;trace&lt;/code&gt; object is destroyed.</source>
          <target state="translated">사용 가능한 경우이 항목은 &lt;code&gt;trace&lt;/code&gt; 오브젝트가 소멸 될 때 소멸됩니다.</target>
        </trans-unit>
        <trans-unit id="651aae97b71b50a5b7a22265766a20a9e7d1926a" translate="yes" xml:space="preserve">
          <source>If enabled, this property will cause Qt to fill the background of the widget before invoking the &lt;a href=&quot;qgraphicswidget#paint&quot;&gt;paint&lt;/a&gt;() method. The color used is defined by the &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette::Window&lt;/a&gt; color role from the widget's &lt;a href=&quot;qpalette&quot;&gt;palette&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 경우,이 특성은 &lt;a href=&quot;qgraphicswidget#paint&quot;&gt;paint&lt;/a&gt; () 메소드를 호출하기 전에 Qt가 위젯의 배경을 채 웁니다 . 사용 된 색상은 위젯 &lt;a href=&quot;qpalette&quot;&gt;팔레트&lt;/a&gt; 의 &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette :: Window&lt;/a&gt; 색상 역할에 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="b360b157a490f504805c3d749caf596e38ba00ef" translate="yes" xml:space="preserve">
          <source>If enabled, this property will cause Qt to fill the background of the widget before invoking the paint event. The color used is defined by the &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette::Window&lt;/a&gt; color role from the widget's &lt;a href=&quot;qpalette&quot;&gt;palette&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 경우,이 특성은 페인트 이벤트를 호출하기 전에 Qt가 위젯의 배경을 채우도록합니다. 사용 된 색상은 위젯 &lt;a href=&quot;qpalette&quot;&gt;팔레트&lt;/a&gt; 의 &lt;a href=&quot;qpalette#ColorRole-enum&quot;&gt;QPalette :: Window&lt;/a&gt; 색상 역할에 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e531ace5ecac8ac32fb317304e1e41610445300" translate="yes" xml:space="preserve">
          <source>If enabled, this view is set to allow scene interaction. Otherwise, this view will not allow interaction, and any mouse or key events are ignored (i.e., it will act as a read-only view).</source>
          <target state="translated">사용 가능한 경우이보기는 장면 상호 작용을 허용하도록 설정됩니다. 그렇지 않으면이보기는 상호 작용을 허용하지 않으며 마우스 또는 키 이벤트는 무시됩니다 (즉, 읽기 전용보기로 작동).</target>
        </trans-unit>
        <trans-unit id="f77247fd4ef852bcf3177e0d80de4ac6ca19746f" translate="yes" xml:space="preserve">
          <source>If events are available, this function returns after processing them.</source>
          <target state="translated">이벤트가 사용 가능하면이 함수는 처리 후 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f4a0f66fa19937fe49520879a4605f0ac1431ad8" translate="yes" xml:space="preserve">
          <source>If exclusive is true, only one checkable action in the action group can ever be active at any time. If the user chooses another checkable action in the group, the one they chose becomes active and the one that was active becomes inactive.</source>
          <target state="translated">배타적이 true 인 경우 언제든지 조치 그룹에서 하나의 점검 가능한 조치 만 활성화 할 수 있습니다. 사용자가 그룹에서 다른 확인 가능한 작업을 선택하면 선택한 작업이 활성화되고 활성화 된 작업이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="ad318f678769f2ad5d9e99ca057dc269a4278a59" translate="yes" xml:space="preserve">
          <source>If explicit is set to true, any potential bindings will be interpreted as once-off assignments that occur when the state is entered.</source>
          <target state="translated">explicit가 true로 설정되면 잠재적 인 바인딩은 상태가 입력 될 때 발생하는 일회성 할당으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="1f5ac591b3e5e72040e1befcb3cf837bfdf4ccc5" translate="yes" xml:space="preserve">
          <source>If false is returned, a system error has occurred. Call &lt;a href=&quot;qsystemsemaphore#error&quot;&gt;error&lt;/a&gt;() to get a value of &lt;a href=&quot;qsystemsemaphore#SystemSemaphoreError-enum&quot;&gt;QSystemSemaphore::SystemSemaphoreError&lt;/a&gt; that indicates which error occurred.</source>
          <target state="translated">false가 리턴되면 시스템 오류가 발생한 것입니다. 발생한 오류를 나타내는 &lt;a href=&quot;qsystemsemaphore#SystemSemaphoreError-enum&quot;&gt;QSystemSemaphore :: SystemSemaphoreError&lt;/a&gt; 값을 얻으려면 &lt;a href=&quot;qsystemsemaphore#error&quot;&gt;error&lt;/a&gt; ()를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="25e21d5f12e9f077aefaedb0a6ac624f3eec1d2c" translate="yes" xml:space="preserve">
          <source>If false(default), then the value of magnitude and &lt;a href=&quot;qml-qtquick-particles-targetdirection#magnitudeVariation-prop&quot;&gt;magnitudeVariation&lt;/a&gt; shall be interpreted as pixels per second.</source>
          <target state="translated">false (기본값) 인 경우 크기 및 &lt;a href=&quot;qml-qtquick-particles-targetdirection#magnitudeVariation-prop&quot;&gt;크기&lt;/a&gt; 값은 초당 픽셀로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="524d4951e2a379db6da49840729d8979b98cf92b" translate="yes" xml:space="preserve">
          <source>If fill is true the ellipse is filled; otherwise it is just a border.</source>
          <target state="translated">채우기가 참이면 타원이 채워집니다. 그렇지 않으면 국경일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="9298d9c66595459b3fa45b9366d7657a9336a0ac" translate="yes" xml:space="preserve">
          <source>If filterMode is set to &lt;a href=&quot;qt#MatchFlag-enum&quot;&gt;Qt::MatchStartsWith&lt;/a&gt;, only those entries that start with the typed characters will be displayed. &lt;a href=&quot;qt#MatchFlag-enum&quot;&gt;Qt::MatchContains&lt;/a&gt; will display the entries that contain the typed characters, and &lt;a href=&quot;qt#MatchFlag-enum&quot;&gt;Qt::MatchEndsWith&lt;/a&gt; the ones that end with the typed characters.</source>
          <target state="translated">filterMode가 &lt;a href=&quot;qt#MatchFlag-enum&quot;&gt;Qt ::&lt;/a&gt; MatchStartsWith로 설정 되면 입력 한 문자로 시작하는 항목 만 표시됩니다. &lt;a href=&quot;qt#MatchFlag-enum&quot;&gt;Qt는 :: MatchContains는&lt;/a&gt; 입력 된 문자가 포함 된 항목을 표시하며, &lt;a href=&quot;qt#MatchFlag-enum&quot;&gt;Qt는 :: MatchEndsWith&lt;/a&gt; 사람 입력 된 문자와 그 끝을.</target>
        </trans-unit>
        <trans-unit id="f49e2c1b609e5eaa80023563550e2b8f59f55112" translate="yes" xml:space="preserve">
          <source>If five items were inserted in succession at index 0, the effect would be this:</source>
          <target state="translated">인덱스 0에서 5 개의 항목이 연속으로 삽입 된 경우 다음과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3f9affb9c37b214f1f830a80a31bc67283c8bec" translate="yes" xml:space="preserve">
          <source>If focus has never been in this window before and you know where focus should start out, call &lt;a href=&quot;qwidget#setFocus-1&quot;&gt;QWidget::setFocus&lt;/a&gt;() on the widget which should receive focus before you call &lt;a href=&quot;qwidget#show&quot;&gt;QWidget::show&lt;/a&gt;() it. If you don't, Qt will pick a suitable widget.</source>
          <target state="translated">포커스가이 창에 표시되지 않았으며 포커스가 시작되는 위치를 알고있는 경우 &lt;a href=&quot;qwidget#show&quot;&gt;QWidget :: show&lt;/a&gt; () 를 호출하기 전에 포커스를 받아야하는 위젯에서 &lt;a href=&quot;qwidget#setFocus-1&quot;&gt;QWidget :: setFocus&lt;/a&gt; ()를 호출 하십시오. 그렇지 않으면 Qt는 적절한 위젯을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="4e83aa17d9043e9e08ef5ec141bb7bff9d9d20a9" translate="yes" xml:space="preserve">
          <source>If for some reason we didn't want this restriction, we can set boundingItem to &lt;code&gt;null&lt;/code&gt;:</source>
          <target state="translated">어떤 이유로 든이 제한을 원하지 않으면 boundingItem을 &lt;code&gt;null&lt;/code&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="489bd4e442ceda8b38a63f0f0bb469de03df364d" translate="yes" xml:space="preserve">
          <source>If foreign windows are not supported or embedding the native window failed in the platform plugin, this function returns &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">외래 창을 지원하지 않거나 플랫폼 플러그인에서 기본 창을 포함하지 못하면이 함수는 &lt;code&gt;nullptr&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ad93adaaadb5f944d2de6bc479b69de5a7cb8372" translate="yes" xml:space="preserve">
          <source>If frameRate is valid then it will be used to calculate the duration of the frames. If not, and &lt;a href=&quot;qml-qtquick-sprite#frameDuration-prop&quot;&gt;frameDuration&lt;/a&gt; is valid , then &lt;a href=&quot;qml-qtquick-sprite#frameDuration-prop&quot;&gt;frameDuration&lt;/a&gt; will be used. Otherwise duration is used.</source>
          <target state="translated">frameRate가 유효하면 프레임 기간을 계산하는 데 사용됩니다. 그렇지 않은 경우 &lt;a href=&quot;qml-qtquick-sprite#frameDuration-prop&quot;&gt;frameDuration&lt;/a&gt; 이 유효하면 &lt;a href=&quot;qml-qtquick-sprite#frameDuration-prop&quot;&gt;frameDuration&lt;/a&gt; 이 사용됩니다. 그렇지 않으면 기간이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fd93e4035e10f5b28c4f801b4394ba95f2c8c303" translate="yes" xml:space="preserve">
          <source>If frameSync is set to true, it overrides all of duration, &lt;a href=&quot;qml-qtquick-sprite#frameRate-prop&quot;&gt;frameRate&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-sprite#frameDuration-prop&quot;&gt;frameDuration&lt;/a&gt;.</source>
          <target state="translated">frameSync가 true로 설정되면 모든 duration, &lt;a href=&quot;qml-qtquick-sprite#frameRate-prop&quot;&gt;frameRate&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-sprite#frameDuration-prop&quot;&gt;frameDuration을 대체&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="087f8c354fbf5c1718977be473c15c493eaf1403" translate="yes" xml:space="preserve">
          <source>If frameSync is set to true, it overrides both &lt;a href=&quot;qml-qtquick-animatedsprite#frameRate-prop&quot;&gt;frameRate&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-animatedsprite#frameDuration-prop&quot;&gt;frameDuration&lt;/a&gt;.</source>
          <target state="translated">frameSync가 true로 설정되면 &lt;a href=&quot;qml-qtquick-animatedsprite#frameRate-prop&quot;&gt;frameRate&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-animatedsprite#frameDuration-prop&quot;&gt;frameDuration을&lt;/a&gt; 모두 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="caa623c12faab06f930b15dcc56dbda4464ac8fb" translate="yes" xml:space="preserve">
          <source>If full page printing is enabled, the origin of the &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt;'s coordinate system coincides with the top-left corner of the paper itself. In this case, the &lt;a href=&quot;qpaintdevice#PaintDeviceMetric-enum&quot;&gt;device metrics&lt;/a&gt; will report the exact same dimensions as indicated by &lt;a href=&quot;qprinter#PaperSize-typedef&quot;&gt;PaperSize&lt;/a&gt;. It may not be possible to print on the entire physical page because of the printer's margins, so the application must account for the margins itself.</source>
          <target state="translated">전체 페이지 인쇄가 활성화 된 경우 &lt;a href=&quot;qprinter&quot;&gt;QPrinter&lt;/a&gt; 좌표계 의 원점 이 용지 자체의 왼쪽 위 모서리와 일치합니다. 이 경우 &lt;a href=&quot;qpaintdevice#PaintDeviceMetric-enum&quot;&gt;장치 메트릭&lt;/a&gt; 은 &lt;a href=&quot;qprinter#PaperSize-typedef&quot;&gt;PaperSize&lt;/a&gt; 로 표시된 것과 동일한 치수를보고 합니다 . 프린터 여백으로 인해 실제 페이지 전체에 인쇄하지 못할 수 있으므로 응용 프로그램에서 여백 자체를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="f2b03f5296ad1ca6d9948fba85fcce2fe447b0aa" translate="yes" xml:space="preserve">
          <source>If height and width are not explicitly set, Text will attempt to determine how much room is needed and set it accordingly. Unless &lt;a href=&quot;qml-qtquick-text#wrapMode-prop&quot;&gt;wrapMode&lt;/a&gt; is set, it will always prefer width to height (all text will be placed on a single line).</source>
          <target state="translated">높이와 너비가 명시 적으로 설정되지 않은 경우 텍스트는 필요한 공간을 결정하고 그에 따라 설정합니다. &lt;a href=&quot;qml-qtquick-text#wrapMode-prop&quot;&gt;wrapMode&lt;/a&gt; 를 설정 하지 않으면 항상 너비보다 높이를 선호합니다 (모든 텍스트는 한 줄에 배치됨).</target>
        </trans-unit>
        <trans-unit id="752c79b5d7a6ef8ed5608b45205926078dedb0c3" translate="yes" xml:space="preserve">
          <source>If in &lt;a href=&quot;qpagelayout#Mode-enum&quot;&gt;FullPageMode&lt;/a&gt; then any margin values will be accepted.</source>
          <target state="translated">에 만약 &lt;a href=&quot;qpagelayout#Mode-enum&quot;&gt;FullPageMode&lt;/a&gt; 어떤 여백 값이 허용됩니다 다음.</target>
        </trans-unit>
        <trans-unit id="04d9a28f71117c8b56e8006eac2d3369ac808edc" translate="yes" xml:space="preserve">
          <source>If in Full Page mode then no check is performed on the</source>
          <target state="translated">전체 페이지 모드 인 경우 검사를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e7c86e601fbd531b70dd067a2103d7d22679226" translate="yes" xml:space="preserve">
          <source>If in the default &lt;a href=&quot;qpagelayout#Mode-enum&quot;&gt;StandardMode&lt;/a&gt; then all the new margins must fall between the minimum margins set and the maximum margins allowed by the page size, otherwise the margins will not be set.</source>
          <target state="translated">기본 &lt;a href=&quot;qpagelayout#Mode-enum&quot;&gt;StandardMode&lt;/a&gt; 에서 모든 새 여백은 설정된 최소 여백과 페이지 크기에서 허용하는 최대 여백 사이에 있어야합니다. 그렇지 않으면 여백이 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0825d6bc190bcbdd46ac3622254e1a8a83a83775" translate="yes" xml:space="preserve">
          <source>If in the default &lt;a href=&quot;qpagelayout#Mode-enum&quot;&gt;StandardMode&lt;/a&gt; then the new margin must fall between the minimum margin set and the maximum margin allowed by the page size, otherwise the margin will not be set.</source>
          <target state="translated">기본 &lt;a href=&quot;qpagelayout#Mode-enum&quot;&gt;StandardMode&lt;/a&gt; 에서 새 여백은 페이지 크기에서 허용하는 최소 여백 세트와 최대 여백 사이에 있어야하며, 그렇지 않으면 여백이 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7a17b4ce6fd6122be637ad01c338d5db08a094e" translate="yes" xml:space="preserve">
          <source>If indent is negative, or if no indent has been set, the label computes the effective indent as follows: If &lt;a href=&quot;qframe#frameWidth-prop&quot;&gt;frameWidth&lt;/a&gt;() is 0, the effective indent becomes 0. If &lt;a href=&quot;qframe#frameWidth-prop&quot;&gt;frameWidth&lt;/a&gt;() is greater than 0, the effective indent becomes half the width of the &quot;x&quot; character of the widget's current &lt;a href=&quot;qwidget#font-prop&quot;&gt;font&lt;/a&gt;().</source>
          <target state="translated">들여 쓰기가 음수이거나 들여 쓰기가 설정되지 않은 경우 레이블은 다음과 같이 유효 들여 쓰기를 계산합니다. &lt;a href=&quot;qframe#frameWidth-prop&quot;&gt;frameWidth&lt;/a&gt; ()가 0이면 유효 들여 쓰기가 0이됩니다. &lt;a href=&quot;qframe#frameWidth-prop&quot;&gt;frameWidth&lt;/a&gt; ()가 0보다 크면 유효 들여 쓰기는 반이됩니다. 위젯 현재 &lt;a href=&quot;qwidget#font-prop&quot;&gt;글꼴&lt;/a&gt; 의 &quot;x&quot;문자 너비 ()</target>
        </trans-unit>
        <trans-unit id="3a74dbf6223cb36875baaf529cea1d95cb5c5910" translate="yes" xml:space="preserve">
          <source>If index widget A is replaced with index widget B, index widget A will be deleted. For example, in the code snippet below, the &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; object will be deleted.</source>
          <target state="translated">인덱스 위젯 A가 인덱스 위젯 B로 바뀌면 인덱스 위젯 A가 삭제됩니다. 예를 들어 아래 코드 스 니펫에서 &lt;a href=&quot;qlineedit&quot;&gt;QLineEdit&lt;/a&gt; 객체가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="a9d0b629c7c94b66d85e069f2f23bb5e6638a726" translate="yes" xml:space="preserve">
          <source>If inside the handler you decide that you can't open the requested URL, you can just call &lt;a href=&quot;qdesktopservices#openUrl&quot;&gt;QDesktopServices::openUrl&lt;/a&gt;() again with the same argument, and it will try to open the URL using the appropriate mechanism for the user's desktop environment.</source>
          <target state="translated">핸들러 내에서 요청 된 URL을 열 수 없다고 결정한 경우 동일한 인수로 &lt;a href=&quot;qdesktopservices#openUrl&quot;&gt;QDesktopServices :: openUrl&lt;/a&gt; ()을 다시 호출 하면 사용자 데스크탑 환경에 적합한 메커니즘을 사용하여 URL을 열려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="90d9dec32e7a0b38edcea370d2b4f5ce65487520" translate="yes" xml:space="preserve">
          <source>If instead the property had a type of &lt;a href=&quot;qqmlscriptstring&quot;&gt;QQmlScriptString&lt;/a&gt;, the script itself --</source>
          <target state="translated">대신 속성의 유형이 &lt;a href=&quot;qqmlscriptstring&quot;&gt;QQmlScriptString&lt;/a&gt; 이면 스크립트 자체는</target>
        </trans-unit>
        <trans-unit id="03e04ad01adf1eb2dcbf376fc5b5ff9895ccc1d7" translate="yes" xml:space="preserve">
          <source>If instead you give the two MouseAreas a parent-child relationship, moving the mouse into &lt;code&gt;mouseArea2&lt;/code&gt; from &lt;code&gt;mouseArea1&lt;/code&gt; will &lt;b&gt;not&lt;/b&gt; cause &lt;code&gt;mouseArea1&lt;/code&gt; to emit &lt;code&gt;exited&lt;/code&gt;. Instead, they will both be considered to be simultaneously hovered.</source>
          <target state="translated">대신 당신이에 마우스를 이동, 두 MouseAreas에게 부모 - 자식 관계를주는 경우에 &lt;code&gt;mouseArea2&lt;/code&gt; 에서 &lt;code&gt;mouseArea1&lt;/code&gt; 것 &lt;b&gt;없는&lt;/b&gt; 원인 &lt;code&gt;mouseArea1&lt;/code&gt; 는 방출 &lt;code&gt;exited&lt;/code&gt; . 대신, 둘 다 동시에 호버링 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="db679a0ebceefbdea2e6e16362366e0950d47fb0" translate="yes" xml:space="preserve">
          <source>If it does provide such objects, then for a given entity reference node, it may be that there is no entity node representing the referenced entity; but if such an entity exists, then the child list of the entity reference node is the same as that of the entity node. As with the entity node, all descendants of the entity reference are read-only.</source>
          <target state="translated">그것이 그러한 객체들을 제공한다면, 주어진 엔티티 참조 노드에 대해, 참조 된 엔티티를 나타내는 엔티티 노드가 없을 수있다; 그러나 그러한 엔티티가 존재하면 엔티티 참조 노드의 하위 목록은 엔티티 노드의 하위 목록과 동일합니다. 엔티티 노드와 마찬가지로 엔티티 참조의 모든 하위 항목은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="4e1f7139a60c70853332d7f705fbcba6499c7153" translate="yes" xml:space="preserve">
          <source>If it doesn't, QDoc will continue looking for a file called</source>
          <target state="translated">그렇지 않은 경우 QDoc은 계속해서라는 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="843bb53d66c31f95e49a3edf765fc26a2caacf67" translate="yes" xml:space="preserve">
          <source>If it has focus, a &lt;a href=&quot;qgraphicsitem#focusOutEvent&quot;&gt;focus out event&lt;/a&gt; is sent to this item to tell it that it is about to lose the focus.</source>
          <target state="translated">포커스가있는 경우 &lt;a href=&quot;qgraphicsitem#focusOutEvent&quot;&gt;포커스&lt;/a&gt; 를 잃을 것임을 알리기 위해 포커스 아웃 이벤트 가이 항목으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="46f7f5ea9acffa72cc5c1a24a339b1e02dff7854" translate="yes" xml:space="preserve">
          <source>If it is &lt;code&gt;true&lt;/code&gt;, the value of &lt;code&gt;0.0&lt;/code&gt; means that the bars are placed side-to-side, &lt;code&gt;1.0&lt;/code&gt; means that a space as wide as the thickness of one bar is left between the bars, and so on. Preset to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;true&lt;/code&gt; 의 값 &lt;code&gt;0.0&lt;/code&gt; 수단 바는 좌우에 배치되는 &lt;code&gt;1.0&lt;/code&gt; 수단이 넓은 한 바의 두께는 바 사이에 남아있는 바와 같이, 등등과 같은 공간. 사전 설정은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d4c87aa93b42f22216d9f5c815c1721e843df7a1" translate="yes" xml:space="preserve">
          <source>If it is declared within one Item but is assigned a different &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt;, it handles events within the bounds of the outer Item but manipulates the &lt;code&gt;target&lt;/code&gt; Item instead:</source>
          <target state="translated">하나의 Item 내에서 선언되었지만 다른 &lt;a href=&quot;qmake-variable-reference#target&quot;&gt;target&lt;/a&gt; 이 지정된 경우 외부 Item의 범위 내에서 이벤트를 처리하지만 대신 &lt;code&gt;target&lt;/code&gt; Item을 조작합니다 .</target>
        </trans-unit>
        <trans-unit id="573cb9416b457f477cc5cfd075df22daa55b30b5" translate="yes" xml:space="preserve">
          <source>If it is declared within one Item but is assigned a different &lt;a href=&quot;qml-qtquick-draghandler#target-prop&quot;&gt;target&lt;/a&gt;, then it handles events within the bounds of the &lt;a href=&quot;qml-qtquick-draghandler#parent-prop&quot;&gt;parent&lt;/a&gt; Item but manipulates the &lt;code&gt;target&lt;/code&gt; Item instead:</source>
          <target state="translated">하나의 Item 내에 선언되었지만 다른 &lt;a href=&quot;qml-qtquick-draghandler#target-prop&quot;&gt;target&lt;/a&gt; 이 할당 된 경우 &lt;a href=&quot;qml-qtquick-draghandler#parent-prop&quot;&gt;상위&lt;/a&gt; Item 의 범위 내에서 이벤트를 처리 하지만 대신 &lt;code&gt;target&lt;/code&gt; Item을 조작합니다 .</target>
        </trans-unit>
        <trans-unit id="23099486f3d02deae5e5447f5d4c101f6fa4636c" translate="yes" xml:space="preserve">
          <source>If it is desired to have a texture size different from that of the item, this is possible using &lt;a href=&quot;qml-qtquick-item#layer.textureSize-prop&quot;&gt;layer.textureSize&lt;/a&gt;. To render only a section of the item into the texture, use &lt;a href=&quot;qml-qtquick-item#layer.sourceRect-prop&quot;&gt;layer.sourceRect&lt;/a&gt;. It is also possible to specify &lt;a href=&quot;qml-qtquick-item#layer.sourceRect-prop&quot;&gt;layer.sourceRect&lt;/a&gt; so it extends beyond the bounds of the item. In this case, the exterior will be padded with transparent pixels.</source>
          <target state="translated">항목의 텍스처 크기와 다른 텍스처 크기를 원하는 경우 &lt;a href=&quot;qml-qtquick-item#layer.textureSize-prop&quot;&gt;layer.textureSize를&lt;/a&gt; 사용하여 가능합니다 . 항목의 &lt;a href=&quot;qml-qtquick-item#layer.sourceRect-prop&quot;&gt;일부만&lt;/a&gt; 텍스처에 렌더링하려면 layer.sourceRect를 사용 하십시오 . 항목의 범위를 넘어서 확장되도록 &lt;a href=&quot;qml-qtquick-item#layer.sourceRect-prop&quot;&gt;layer.sourceRect&lt;/a&gt; 를 지정할 수도 있습니다 . 이 경우 외부는 투명한 픽셀로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="41bf08bd50af6794b503f14b85f478eee39f0cd9" translate="yes" xml:space="preserve">
          <source>If it is known that many items will have children, reimplementing &lt;a href=&quot;qabstractitemmodel#hasChildren&quot;&gt;hasChildren()&lt;/a&gt; to unconditionally return &lt;code&gt;true&lt;/code&gt; is sometimes a useful approach to take. This ensures that each item can be later examined for children while making initial population of model data as fast as possible. The only disadvantage is that items without children may be displayed incorrectly in some views until the user attempts to view the non-existent child items.</source>
          <target state="translated">많은 항목에 자식이있는 것으로 알려진 경우 &lt;a href=&quot;qabstractitemmodel#hasChildren&quot;&gt;hasChildren ()&lt;/a&gt; 을 다시 구현 하여 무조건 &lt;code&gt;true&lt;/code&gt; 를 반환하는 것이 때로는 유용한 접근 방법입니다. 이를 통해 초기에 모델 데이터를 최대한 빨리 수집하면서 각 항목을 나중에 하위 항목에 대해 검사 할 수 있습니다. 유일한 단점은 사용자가 존재하지 않는 자식 항목을 보려고 시도 할 때까지 자식이없는 항목이 일부보기에서 잘못 표시 될 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="45370bf659ab830f281a0d4836bf371f4baac211" translate="yes" xml:space="preserve">
          <source>If it is necessary to block until the value is changed, something like the following is necessary.</source>
          <target state="translated">값이 변경 될 때까지 차단해야하는 경우 다음과 같은 것이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="015fd34faa6aaebbeb3d726618c36e7e145b09b0" translate="yes" xml:space="preserve">
          <source>If it is placed in a .qml file whose name begins with a capital letter, the file is recognized by the engine as a definition of a QML type. The top-level object declaration encapsulates the object tree that will be instantiated by the type.</source>
          <target state="translated">이름이 대문자로 시작하는 .qml 파일에있는 경우 엔진에서 파일을 QML 유형의 정의로 인식합니다. 최상위 수준 객체 선언은 유형별로 인스턴스화 될 객체 트리를 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="e92ced4a9894e3b2b70cb29796041c7d3a61b7f5" translate="yes" xml:space="preserve">
          <source>If it is possible to return to the &lt;code&gt;goalSprite&lt;/code&gt; from the starting point of the &lt;code&gt;goalSprite&lt;/code&gt;, it will continue to do so until &lt;code&gt;goalSprite&lt;/code&gt; is set to &lt;code&gt;&quot;&quot;&lt;/code&gt; or an unreachable state.</source>
          <target state="translated">그것이로 복귀 할 수 있다면 &lt;code&gt;goalSprite&lt;/code&gt; 의 시작 지점에서 &lt;code&gt;goalSprite&lt;/code&gt; 때까지 그렇게 할 것입니다 &lt;code&gt;goalSprite&lt;/code&gt; 이 설정되어 &lt;code&gt;&quot;&quot;&lt;/code&gt; 또는 연결할 수없는 상태입니다.</target>
        </trans-unit>
        <trans-unit id="a4f91762cb0f6bbc905fa00c2d75f90062c511e4" translate="yes" xml:space="preserve">
          <source>If it is the current tab.</source>
          <target state="translated">현재 탭인 경우</target>
        </trans-unit>
        <trans-unit id="27a90f96a8597d15403028dbfc419b4ffe5462fb" translate="yes" xml:space="preserve">
          <source>If it isn't connected, you need to call the constructor again.</source>
          <target state="translated">연결되어 있지 않으면 생성자를 다시 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="14ed2c99b53f0ea44395392c34d1009c25c22378" translate="yes" xml:space="preserve">
          <source>If it's impossible to stay within the given bounds, it prints outside.</source>
          <target state="translated">주어진 범위 내에서 머무를 수 없으면 외부에서 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="4e4d1291bb053f42fe1f4cccc5479554b48aa1a3" translate="yes" xml:space="preserve">
          <source>If it's the first time the static text is drawn, or if the static text, or the painter's font has been altered since the last time it was drawn, the text's layout has to be recalculated. On some paint engines, changing the matrix of the painter will also cause the layout to be recalculated. In particular, this will happen for any engine except for the OpenGL2 paint engine. Recalculating the layout will impose an overhead on the &lt;a href=&quot;qpainter#drawStaticText&quot;&gt;QPainter::drawStaticText&lt;/a&gt;() call where it occurs. To avoid this overhead in the paint event, you can call &lt;a href=&quot;qstatictext#prepare&quot;&gt;prepare&lt;/a&gt;() ahead of time to ensure that the layout is calculated.</source>
          <target state="translated">정적 텍스트가 처음으로 그려 지거나 정적 텍스트 또는 화가의 글꼴이 마지막으로 그려진 이후로 변경된 경우 텍스트의 레이아웃을 다시 계산해야합니다. 일부 페인트 엔진에서는 페인터의 매트릭스를 변경하면 레이아웃이 다시 계산됩니다. 특히 OpenGL2 페인트 엔진을 제외한 모든 엔진에서 발생합니다. 레이아웃을 다시 계산하면 &lt;a href=&quot;qpainter#drawStaticText&quot;&gt;QPainter :: drawStaticText&lt;/a&gt; () 호출 에 오버 헤드 가 발생합니다. 페인트 이벤트에서이 오버 헤드를 방지하려면 호출 할 수 있습니다 &lt;a href=&quot;qstatictext#prepare&quot;&gt;준비&lt;/a&gt; 레이아웃이 계산 될 수 있도록 사전에 ().</target>
        </trans-unit>
        <trans-unit id="ec0dbca65a07f6d508b521bf9c1afa091ab96585" translate="yes" xml:space="preserve">
          <source>If item is not &lt;code&gt;nullptr&lt;/code&gt;, and the scene does not currently have focus (i.e., &lt;a href=&quot;qgraphicsscene#hasFocus&quot;&gt;hasFocus&lt;/a&gt;() returns &lt;code&gt;false&lt;/code&gt;), this function will call &lt;a href=&quot;qgraphicsscene#setFocus&quot;&gt;setFocus&lt;/a&gt;() automatically.</source>
          <target state="translated">item이 &lt;code&gt;nullptr&lt;/code&gt; 아니고 장면에 현재 포커스가없는 경우 (즉, &lt;a href=&quot;qgraphicsscene#hasFocus&quot;&gt;hasFocus&lt;/a&gt; ()가 &lt;code&gt;false&lt;/code&gt; 를 반환하는 경우 )이 함수는 &lt;a href=&quot;qgraphicsscene#setFocus&quot;&gt;setFocus&lt;/a&gt; ()를 자동으로 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="baf10a3898fa77a9ac174d4ea8516df31b22de4b" translate="yes" xml:space="preserve">
          <source>If its value is &lt;code&gt;true&lt;/code&gt;, the selected data will overwrite the existing item data when dropped, while moving the data will clear the item. If its value is &lt;code&gt;false&lt;/code&gt;, the selected data will be inserted as a new item when the data is dropped. When the data is moved, the item is removed as well.</source>
          <target state="translated">값이 &lt;code&gt;true&lt;/code&gt; 이면 선택한 데이터가 삭제 될 때 기존 항목 데이터를 덮어 쓰지만 데이터를 이동하면 항목이 지워집니다. 값이 &lt;code&gt;false&lt;/code&gt; 이면 데이터를 삭제할 때 선택한 데이터가 새 항목으로 삽입됩니다. 데이터가 이동되면 항목도 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="011098c87bcc93b317a2811c27a5272cf7db4864" translate="yes" xml:space="preserve">
          <source>If keyboard tracking is disabled, the spinbox doesn't emit the valueChanged() signal while typing. It emits the signal later, when the return key is pressed, when keyboard focus is lost, or when other spinbox functionality is used, e.g. pressing an arrow key.</source>
          <target state="translated">키보드 추적이 비활성화되면 스핀 박스는 입력하는 동안 valueChanged () 신호를 방출하지 않습니다. 나중에 리턴 키를 누르거나 키보드 포커스를 잃었을 때 또는 화살표 키를 누르는 것과 같은 다른 스핀 박스 기능이 사용될 때 신호를 방출합니다.</target>
        </trans-unit>
        <trans-unit id="da12e9d51ed8571bf99d31dbf5460632d72c37a8" translate="yes" xml:space="preserve">
          <source>If keyboard tracking is enabled (the default), the spinbox emits the valueChanged() signal while the new value is being entered from the keyboard.</source>
          <target state="translated">키보드 추적이 활성화 된 경우 (기본값) 스핀 박스는 키보드에서 새 값을 입력하는 동안 valueChanged () 신호를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a72264bee2c874aab7eab90c5006e47d00fe5c50" translate="yes" xml:space="preserve">
          <source>If left empty, a default value will be used.</source>
          <target state="translated">비워두면 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ca8c569e6bee33b1993fa6f784dfc73fb2df8590" translate="yes" xml:space="preserve">
          <source>If limit is -1 the entire result set will be returned, otherwise at most limit results will be returned. The limit and &lt;a href=&quot;qml-qtlocation-geocodemodel#offset-prop&quot;&gt;offset&lt;/a&gt; results can be used together to implement paging.</source>
          <target state="translated">limit이 -1이면 전체 결과 집합이 반환되고, 그렇지 않으면 최대 제한 결과가 반환됩니다. 페이징을 구현하기 위해 한계 및 &lt;a href=&quot;qml-qtlocation-geocodemodel#offset-prop&quot;&gt;오프셋&lt;/a&gt; 결과를 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac8df27abc4a1eb214010aee8fa05a399a36394a" translate="yes" xml:space="preserve">
          <source>If list contains too few values, only width of the rest of the columns will not be modified.</source>
          <target state="translated">목록에 값이 너무 적 으면 나머지 열의 너비 만 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="207b53854ec6c85c1e32ee36ff5f9a947186160c" translate="yes" xml:space="preserve">
          <source>If listening is successful, we connect the `newConnection()` signal to the slot `onNewConnection()`. The `newConnection()` signal will be thrown whenever a new WebSocket client is connected to our server.</source>
          <target state="translated">청취가 성공하면`newConnection ()`신호를`onNewConnection ()`슬롯에 연결합니다. `newConnection ()`신호는 새로운 WebSocket 클라이언트가 서버에 연결될 때마다 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b543a966b55cf0735b81c5e5c90487c4a956756a" translate="yes" xml:space="preserve">
          <source>If logging have been started in &lt;a href=&quot;qopengldebuglogger#LoggingMode-enum&quot;&gt;SynchronousLogging&lt;/a&gt; mode, OpenGL guarantees that this signal will be emitted from the same thread the &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; has been bound to, and no concurrent invocations will ever happen.</source>
          <target state="translated">&lt;a href=&quot;qopengldebuglogger#LoggingMode-enum&quot;&gt;SynchronousLogging&lt;/a&gt; 모드 에서 로깅이 시작된 경우 OpenGL은이 신호가 &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; 가 바인딩 된 동일한 스레드에서 방출되고 동시 호출이 발생하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="65acef6dd5fb75c2c8b078598b5192c5d69c44c8" translate="yes" xml:space="preserve">
          <source>If matching the same regular expression against the subject string leads to a complete match, it is reported as usual:</source>
          <target state="translated">제목 문자열에 대해 동일한 정규식을 일치 시키면 완전히 일치하는 것으로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="60a223a3fabbda444b793a4028f97075342c4bdc" translate="yes" xml:space="preserve">
          <source>If meshName is a plain string, then only the sub-mesh matching that name, if present, will be loaded.</source>
          <target state="translated">meshName이 일반 문자열이면 해당 이름과 일치하는 하위 메시 만로드됩니다.</target>
        </trans-unit>
        <trans-unit id="f443e618422b1eca1a552cb9d6195deaefdcb144" translate="yes" xml:space="preserve">
          <source>If meshName is a regular expression, than all sub-meshes matching the expression will be loaded.</source>
          <target state="translated">meshName이 정규 표현식 인 경우 표현식과 일치하는 모든 하위 메시보다로드됩니다.</target>
        </trans-unit>
        <trans-unit id="81c3090e5be1e2a0c7aba73835a02b8d6386beef" translate="yes" xml:space="preserve">
          <source>If meshName is empty (the default), then the entire mesh is loaded.</source>
          <target state="translated">meshName이 비어 있으면 (기본값) 전체 메시가로드됩니다.</target>
        </trans-unit>
        <trans-unit id="15b92b86af540c5f8ca22554a15f087e86aaa78c" translate="yes" xml:space="preserve">
          <source>If minimum and maximum both are set to 0, the bar shows a busy indicator instead of a percentage of steps. This is useful, for example, when using QNetworkAccessManager to download items when they are unable to determine the size of the item being downloaded.</source>
          <target state="translated">최소값과 최대 값이 모두 0으로 설정되어 있으면 막대에 단계 비율 대신 통화 중 표시기가 나타납니다. 예를 들어 QNetworkAccessManager를 사용하여 다운로드중인 항목의 크기를 결정할 수 없을 때 항목을 다운로드 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="425ebeb37eb0fc7e2f636db06e164582e4756bcd" translate="yes" xml:space="preserve">
          <source>If minimum and maximum both are set to &lt;code&gt;0&lt;/code&gt;, the indicator shows up as a busy (indeterminate) indicator instead of a percentage of steps. This is useful when it is not possible to determine the number of steps.</source>
          <target state="translated">최소값과 최대 값이 모두 &lt;code&gt;0&lt;/code&gt; 으로 설정 되면 표시기는 단계 비율 대신 사용 중 (불확정) 표시기로 나타납니다. 단계 수를 결정할 수없는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e1455d0739f932f6a2768e24e17c501e325ee10d" translate="yes" xml:space="preserve">
          <source>If minimum size has not been explicitly specified on an item, the size is set to &lt;code&gt;0&lt;/code&gt;. If maximum size has not been explicitly specified on an item, the size is set to &lt;code&gt;Number.POSITIVE_INFINITY&lt;/code&gt;.</source>
          <target state="translated">항목에 최소 크기를 명시 적으로 지정하지 않은 경우 크기는 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 항목에 최대 크기를 명시 적으로 지정하지 않은 경우 크기는 &lt;code&gt;Number.POSITIVE_INFINITY&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2bc2275b20b1e44614c16314462c8ee38416e26e" translate="yes" xml:space="preserve">
          <source>If minimumPointCount and maximumPointCount are set to values larger than 1, the user will need to drag that many fingers in the same direction to start dragging. A multi-finger drag gesture can be detected independently of both a (default) single-finger &lt;a href=&quot;qml-qtquick-draghandler&quot;&gt;DragHandler&lt;/a&gt; and a &lt;a href=&quot;qml-qtquick-pinchhandler&quot;&gt;PinchHandler&lt;/a&gt; on the same Item, and thus can be used to adjust some other feature independently of the usual pinch behavior: for example adjust a tilt transformation, or adjust some other numeric value, if the &lt;code&gt;target&lt;/code&gt; is set to null. But if the &lt;code&gt;target&lt;/code&gt; is an Item, &lt;code&gt;centroid&lt;/code&gt; is the point at which the drag begins and to which the &lt;code&gt;target&lt;/code&gt; will be moved (subject to constraints).</source>
          <target state="translated">minimumPointCount 및 maximumPointCount가 1보다 큰 값으로 설정되면 사용자는 드래그를 시작하기 위해 많은 손가락을 같은 방향으로 드래그해야합니다. 멀티 손가락 드래그 동작은 독립적으로 모두 (기본)의 단일 손가락을 감지 할 수 &lt;a href=&quot;qml-qtquick-draghandler&quot;&gt;DragHandler&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-pinchhandler&quot;&gt;PinchHandler&lt;/a&gt; 예컨대 경사 조정 : 동일한 항목에 따라서 독립적으로 통상 핀치 동작의 다른 기능을 조절하는데 사용될 수있다 &lt;code&gt;target&lt;/code&gt; 이 null로 설정된 경우 변환 또는 다른 숫자 값을 조정하십시오 . 그러나 &lt;code&gt;target&lt;/code&gt; 이 Item 인 경우 &lt;code&gt;centroid&lt;/code&gt; 은 드래그가 시작되고 &lt;code&gt;target&lt;/code&gt; 이 이동 될 지점 입니다 (제약 조건에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="77c1a7be2686b9433ce0869634c4f0505320a39c" translate="yes" xml:space="preserve">
          <source>If mipmapping is enabled, additional memory will be allocated for the mipmap levels. The mipmap levels can be updated by binding the texture and calling glGenerateMipmap(). Mipmapping cannot be enabled for multisampled framebuffer objects.</source>
          <target state="translated">밉 매핑이 활성화되면 밉맵 레벨에 추가 메모리가 할당됩니다. 텍스처를 바인딩하고 glGenerateMipmap ()을 호출하여 밉맵 레벨을 업데이트 할 수 있습니다. 멀티 샘플링 된 프레임 버퍼 객체에는 밉 매핑을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4a2d6ba9952c87349b5460ea11523fd9b6f10a79" translate="yes" xml:space="preserve">
          <source>If mirrored is set to true, this will be mirrored along the y axis. The line will then go from (0,height) to (width, 0).</source>
          <target state="translated">mirrored가 true로 설정되면 y 축을 따라 미러링됩니다. 그런 다음 줄은 (0, height)에서 (width, 0)으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="5eb2424144d205b413d414763ac5a3328133242d" translate="yes" xml:space="preserve">
          <source>If more than one cookie with the same name is found, but with differing paths, the one with longer path is returned before the one with shorter path. In other words, this function returns cookies sorted decreasingly by path length.</source>
          <target state="translated">이름이 같지만 경로가 다른 쿠키가 두 개 이상있는 경우 경로가 긴 쿠키가 경로가 짧은 쿠키보다 먼저 반환됩니다. 즉,이 함수는 쿠키를 경로 길이별로 정렬하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b3f71d31792abac8e48f66b535b421fc49a06d11" translate="yes" xml:space="preserve">
          <source>If more than one default state has to be entered, or if the transition to the default state(s) has to be acted upon, the &lt;a href=&quot;qhistorystate#defaultTransition&quot;&gt;defaultTransition&lt;/a&gt; should be set instead. Note that the eventTest() method of that transition will never be called: the selection and execution of the transition is done automatically when entering the history state.</source>
          <target state="translated">기본 상태를 두 개 이상 입력하거나 기본 상태로 전환 해야하는 경우 &lt;a href=&quot;qhistorystate#defaultTransition&quot;&gt;defaultTransition&lt;/a&gt; 을 대신 설정해야합니다. 해당 전환의 eventTest () 메소드는 호출되지 않습니다. 전환 상태 선택시 전환 선택 및 실행이 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="0117eafaafa3e61e03276ef033374fec97523c5a" translate="yes" xml:space="preserve">
          <source>If more than one prefix is currently mapped to the same URI, this function makes an arbitrary selection; if you want all of the prefixes, use &lt;a href=&quot;qxmlnamespacesupport#prefixes&quot;&gt;prefixes&lt;/a&gt;() instead.</source>
          <target state="translated">둘 이상의 접두사가 현재 동일한 URI에 매핑되어 있으면이 함수는 임의로 선택합니다. 모든 접두사를 원하면 &lt;a href=&quot;qxmlnamespacesupport#prefixes&quot;&gt;접두사&lt;/a&gt; ()를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="513c35017c1c35fb6fc60a823b16e03f36e12678" translate="yes" xml:space="preserve">
          <source>If mouse tracking is disabled (the default), the widget only receives mouse move events when at least one mouse button is pressed while the mouse is being moved.</source>
          <target state="translated">마우스 추적을 사용하지 않으면 (기본값) 위젯은 마우스를 움직이는 동안 하나 이상의 마우스 버튼을 누를 때만 마우스 이동 이벤트를받습니다.</target>
        </trans-unit>
        <trans-unit id="b1ce62afa7de1b0470fefdd3315bd8b581d8e49b" translate="yes" xml:space="preserve">
          <source>If mouse tracking is enabled, the widget receives mouse move events even if no buttons are pressed.</source>
          <target state="translated">마우스 추적이 활성화 된 경우 버튼을 누르지 않아도 위젯은 마우스 이동 이벤트를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="ad331d3424b6858834e3e2d57d7d58c589ccdb8c" translate="yes" xml:space="preserve">
          <source>If mouse tracking is switched off, mouse move events only occur if a mouse button is pressed while the mouse is being moved. If mouse tracking is switched on, mouse move events occur even if no mouse button is pressed.</source>
          <target state="translated">마우스 추적이 꺼져 있으면 마우스 이동 중 마우스 버튼을 누른 경우에만 마우스 이동 이벤트가 발생합니다. 마우스 추적이 켜져 있으면 마우스 버튼을 누르지 않아도 마우스 이동 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="18bc5d30a968cd20446b763c753bbd4d1c15f8ef" translate="yes" xml:space="preserve">
          <source>If msec is -1, this function will not time out.</source>
          <target state="translated">msec가 -1이면이 기능이 시간 초과되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7264eb8c26b142470dad57a7df3ebf2c568772fd" translate="yes" xml:space="preserve">
          <source>If msecs is -1, this function will not time out.</source>
          <target state="translated">msecs가 -1이면이 기능이 시간 초과되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f65d7c4900de1b33a2ff517396af6ffb37a8a71c" translate="yes" xml:space="preserve">
          <source>If multiple Transitions are specified, only a single (best-matching) Transition will be applied for any particular state change. In the example above, when changing to &lt;code&gt;state1&lt;/code&gt;, the first transition will be used, rather than the more generic second transition.</source>
          <target state="translated">여러 개의 전환이 지정된 경우 특정 상태 변경에 단일 (최적의 일치) 전환 만 적용됩니다. 위의 예에서 &lt;code&gt;state1&lt;/code&gt; 로 변경 하면보다 일반적인 두 번째 전환 대신 첫 번째 전환이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e71053cd9a34a8d7dae361a31b39c6b32ccbd2ce" translate="yes" xml:space="preserve">
          <source>If multiple cameras are available, you can select which one to use by setting the &lt;a href=&quot;qml-qtmultimedia-camera#deviceId-prop&quot;&gt;deviceId&lt;/a&gt; property to a value from &lt;a href=&quot;qml-qtmultimedia-qtmultimedia#availableCameras-prop&quot;&gt;QtMultimedia.availableCameras&lt;/a&gt;. On a mobile device, you can conveniently switch between front-facing and back-facing cameras by setting the &lt;a href=&quot;qml-qtmultimedia-camera#position-prop&quot;&gt;position&lt;/a&gt; property.</source>
          <target state="translated">여러 대의 카메라를 사용할 수있는 경우, 당신은 설정하여 사용할 하나를 선택할 수 &lt;a href=&quot;qml-qtmultimedia-camera#deviceId-prop&quot;&gt;있는 DeviceID의&lt;/a&gt; 로부터의 값에 속성을 &lt;a href=&quot;qml-qtmultimedia-qtmultimedia#availableCameras-prop&quot;&gt;QtMultimedia.availableCameras&lt;/a&gt; . 모바일 장치에서는 &lt;a href=&quot;qml-qtmultimedia-camera#position-prop&quot;&gt;위치&lt;/a&gt; 속성 을 설정하여 전면 카메라와 후면 카메라를 편리하게 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c3a09e6f0ad50a93f9e3376b1516b8e64d799ae2" translate="yes" xml:space="preserve">
          <source>If multiple event filters are installed on a single object, the filter that was installed last is activated first.</source>
          <target state="translated">단일 이벤트에 여러 이벤트 필터가 설치된 경우 마지막에 설치된 필터가 먼저 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="4a0ef4bd001de07e1f7bad0f9b9cc22132099554" translate="yes" xml:space="preserve">
          <source>If multiple event filters are installed, the filter that was installed last is activated first.</source>
          <target state="translated">여러 이벤트 필터가 설치된 경우 마지막에 설치된 필터가 먼저 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="ad36e93e5d25ab836e1568b8689c13cd8b1146e3" translate="yes" xml:space="preserve">
          <source>If multiple items are added in rapid succession, without waiting for a previous transition to finish, this is the result:</source>
          <target state="translated">이전 전환이 완료 될 때까지 기다리지 않고 여러 항목이 빠르게 연속해서 추가되는 경우 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37f0a7f92c02454488c20ce169f8e4226cf32982" translate="yes" xml:space="preserve">
          <source>If multiple key roles are specified, the model only adds and reload items with a combined value of all key roles that is not already present in the model.</source>
          <target state="translated">여러 키 역할이 지정된 경우 모델에는 아직 모델에없는 모든 주요 역할의 값이 결합 된 항목 만 추가 및 다시로드됩니다.</target>
        </trans-unit>
        <trans-unit id="b750037b8a94f295f030e92dd8eead20b86c6b58" translate="yes" xml:space="preserve">
          <source>If multiple meta-data elements are changed, metaDataChanged(const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp;key, const &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; &amp;amp;value) signal is emitted for each of them with metaDataChanged() changed emitted once.</source>
          <target state="translated">여러 메타 데이터 요소가 변경되면 metaDataChanged ( )는 한 번 방출 된 metaDataChanged ()로 메타 데이터 변경 (const &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; &amp;amp; key, const &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; &amp;amp; value) 신호가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2b93c0eb6db0938f9830e7176ab95e2f55dcd11f" translate="yes" xml:space="preserve">
          <source>If multiple partial matches are found when matching (but no complete match), then the &lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt; object will report the first one that is found. For instance:</source>
          <target state="translated">일치 할 때 여러 부분 일치가 발견되면 (완전 일치는 없음) &lt;a href=&quot;qregularexpressionmatch&quot;&gt;QRegularExpressionMatch&lt;/a&gt; 오브젝트는 발견 된 첫 번째 일치 를보고합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="27cfff9d5e4e97835b833636ffbb4cc643e4b03b" translate="yes" xml:space="preserve">
          <source>If multiple plugins have the same</source>
          <target state="translated">여러 플러그인이 동일한 경우</target>
        </trans-unit>
        <trans-unit id="c6a7fd012b7541efe97c691252b5c323d4a7a361" translate="yes" xml:space="preserve">
          <source>If multiple results are returned by the reverse geocoding service backend they will be provided in order of specificity. This normally occurs if the backend is configured to reverse geocode across multiple levels of detail. As an example, some services will return address and coordinate pairs for the street address, the city, the state and the country.</source>
          <target state="translated">리버스 지오 코딩 서비스 백엔드에서 여러 결과가 반환되면 결과는 구체적 순서대로 제공됩니다. 백엔드가 여러 수준의 세부 정보에서 지오 코딩을 반전하도록 구성된 경우 일반적으로 발생합니다. 예를 들어 일부 서비스는 주소, 도시, 주 및 국가의 주소와 좌표 쌍을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ff31a0ad2d120e330c8b1484c6f7d1819120e4f5" translate="yes" xml:space="preserve">
          <source>If multiple states are specified, all must be descendants of the same parallel group state.</source>
          <target state="translated">여러 상태가 지정된 경우 모두 동일한 병렬 그룹 상태의 자손이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6cb4dfbfb1d14a53e3f41391b01c9d14285e4259" translate="yes" xml:space="preserve">
          <source>If multiple states are specified, they all must be descendants of the same parallel group state.</source>
          <target state="translated">여러 상태가 지정된 경우 모두 동일한 병렬 그룹 상태의 후손이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9d965f6483df4f213e1999961d6821117c44ade5" translate="yes" xml:space="preserve">
          <source>If multiple states in a group have &lt;code&gt;when&lt;/code&gt; clauses that evaluate to &lt;code&gt;true&lt;/code&gt; at the same time, the first matching state will be applied. For example, in the following snippet &lt;code&gt;state1&lt;/code&gt; will always be selected rather than &lt;code&gt;state2&lt;/code&gt; when sharedCondition becomes &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">그룹의 여러 상태에 동시에 &lt;code&gt;true&lt;/code&gt; 로 평가되는 &lt;code&gt;when&lt;/code&gt; 절이 있으면 첫 번째 일치 상태가 적용됩니다. 예를 들어, 다음 코드 조각에서 &lt;code&gt;state1&lt;/code&gt; 항상보다는 선택됩니다 &lt;code&gt;state2&lt;/code&gt; sharedCondition가 될 때 &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba629f19b30c661d39caab6cf1051f8d3500afa4" translate="yes" xml:space="preserve">
          <source>If multiple timers are running, the &lt;a href=&quot;qtimerevent#timerId&quot;&gt;QTimerEvent::timerId&lt;/a&gt;() can be used to find out which timer was activated.</source>
          <target state="translated">여러 타이머가 실행중인 경우 &lt;a href=&quot;qtimerevent#timerId&quot;&gt;QTimerEvent :: timerId&lt;/a&gt; ()를 사용하여 활성화 된 타이머를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="353b70a45cc64ad593eb9a468039e76f0201acf9" translate="yes" xml:space="preserve">
          <source>If necessary, &lt;code&gt;eglfs&lt;/code&gt; can be configured using the following environment variables:</source>
          <target state="translated">필요한 경우 다음 환경 변수를 사용하여 &lt;code&gt;eglfs&lt;/code&gt; 를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d05cb1fddcd9820af0724cde2396d014e2fa83a2" translate="yes" xml:space="preserve">
          <source>If necessary, eglfs can be configured via environment variables:</source>
          <target state="translated">필요한 경우 환경 변수를 통해 eglf를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c480c58072fec9e884a18d45555ce6c0be06772c" translate="yes" xml:space="preserve">
          <source>If needed the VAO can be temporarily unbound with the &lt;a href=&quot;qopenglvertexarrayobject-binder#release&quot;&gt;release&lt;/a&gt;() function and bound once more with &lt;a href=&quot;qopenglvertexarrayobject-binder#rebind&quot;&gt;rebind&lt;/a&gt;().</source>
          <target state="translated">필요한 경우 VAO는 &lt;a href=&quot;qopenglvertexarrayobject-binder#release&quot;&gt;release&lt;/a&gt; () 함수를 사용하여 일시적으로 언 바운드 하고 &lt;a href=&quot;qopenglvertexarrayobject-binder#rebind&quot;&gt;리 바인드&lt;/a&gt; ()를 사용 하여 한 번 더 바인딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54ae2cc094db037d7f6f335146b61cf2063367cf" translate="yes" xml:space="preserve">
          <source>If needed, logical OR can be expressed using the comma operator:</source>
          <target state="translated">필요한 경우 쉼표 연산자를 사용하여 논리 OR을 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaf7400dfb8ccdb44d01561e33e0944211ea0f17" translate="yes" xml:space="preserve">
          <source>If needed, the renderer can be completely replaced using the internal scene graph back-end API. This is mostly interesting for platform vendors who wish to take advantage of non-standard hardware features. For the majority of use cases, the default renderer will be sufficient.</source>
          <target state="translated">필요한 경우 내부 장면 그래프 백엔드 API를 사용하여 렌더러를 완전히 교체 할 수 있습니다. 이는 비표준 하드웨어 기능을 활용하려는 플랫폼 공급 업체에게 가장 흥미로운 기능입니다. 대부분의 사용 사례의 경우 기본 렌더러로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="eece5baf4dc90b9998581ff0556eb7c1bc4ad9ee" translate="yes" xml:space="preserve">
          <source>If neither a true RNG nor a cryptographically secure PRNG are required, applications should instead use PRNG engines like &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt;'s deterministic mode and those from the C++ Standard Library. &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator::system&lt;/a&gt;() can be used to seed those.</source>
          <target state="translated">실제 RNG 나 암호로 안전한 PRNG가 필요하지 않은 경우 애플리케이션은 &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; 의 결정 모드 및 C ++ 표준 라이브러리의 PRNG 엔진과 같은 PRNG 엔진을 대신 사용해야 합니다. &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator :: system&lt;/a&gt; ()을 사용하여 시드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9778f4776967dc160704ed966263ffd2a5be1eaf" translate="yes" xml:space="preserve">
          <source>If neither the language nor the country are found, &lt;a href=&quot;qlocale&quot;&gt;QLocale&lt;/a&gt; defaults to the default locale (see &lt;a href=&quot;qlocale#setDefault&quot;&gt;setDefault&lt;/a&gt;()).</source>
          <target state="translated">언어 나 국가를 찾을 수 &lt;a href=&quot;qlocale&quot;&gt;없으면 QLocale의&lt;/a&gt; 기본값은 기본 로캘입니다 ( &lt;a href=&quot;qlocale#setDefault&quot;&gt;setDefault&lt;/a&gt; () 참조 ).</target>
        </trans-unit>
        <trans-unit id="53350c2c3c8b28a4d3707eb2611cd38db930ba21" translate="yes" xml:space="preserve">
          <source>If nmeaSource has been set for a &lt;a href=&quot;qml-qtpositioning-positionsource&quot;&gt;PositionSource&lt;/a&gt; object, there is no way to revert back to non-file sources.</source>
          <target state="translated">&lt;a href=&quot;qml-qtpositioning-positionsource&quot;&gt;PositionSource&lt;/a&gt; 객체에 대해 nmeaSource가 설정된 경우 파일이 아닌 소스로 되돌릴 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="46d15914a8966b2144fb307d96a3896b83eea8f4" translate="yes" xml:space="preserve">
          <source>If no</source>
          <target state="translated">그렇지 않다면</target>
        </trans-unit>
        <trans-unit id="a88b25b6bd000adebc50dac5dd33ca8b0912150d" translate="yes" xml:space="preserve">
          <source>If no &lt;a href=&quot;q3dcamera#CameraPreset-enum&quot;&gt;CameraPreset&lt;/a&gt; value is set, &lt;a href=&quot;q3dcamera#CameraPreset-enum&quot;&gt;CameraPresetNone&lt;/a&gt; is used by default.</source>
          <target state="translated">&lt;a href=&quot;q3dcamera#CameraPreset-enum&quot;&gt;CameraPreset&lt;/a&gt; 값이 설정되어 있지 않으면 &lt;a href=&quot;q3dcamera#CameraPreset-enum&quot;&gt;CameraPresetNone&lt;/a&gt; 이 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="20cd30094dd3fc0d717e196262001389df33a28d" translate="yes" xml:space="preserve">
          <source>If no &lt;a href=&quot;qml-qtquick-intvalidator#locale-prop&quot;&gt;locale&lt;/a&gt; is set &lt;a href=&quot;qml-qtquick-intvalidator&quot;&gt;IntValidator&lt;/a&gt; uses the &lt;a href=&quot;qlocale#setDefault&quot;&gt;default locale&lt;/a&gt; to interpret the number and will accept locale specific digits, group separators, and positive and negative signs. In addition, &lt;a href=&quot;qml-qtquick-intvalidator&quot;&gt;IntValidator&lt;/a&gt; is always guaranteed to accept a number formatted according to the &quot;C&quot; locale.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-intvalidator#locale-prop&quot;&gt;로캘&lt;/a&gt; 이 설정 되지 않은 경우 &lt;a href=&quot;qml-qtquick-intvalidator&quot;&gt;IntValidator&lt;/a&gt; 는 &lt;a href=&quot;qlocale#setDefault&quot;&gt;기본 로캘&lt;/a&gt; 을 사용하여 숫자를 해석하고 로캘 별 숫자, 그룹 구분 기호 및 양수 및 음수 부호를 허용합니다. 또한 &lt;a href=&quot;qml-qtquick-intvalidator&quot;&gt;IntValidator&lt;/a&gt; 는 항상 &quot;C&quot;로캘에 따라 형식이 지정된 숫자를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="576c237e9ebdd7fced66e291ec7e07305ba5a529" translate="yes" xml:space="preserve">
          <source>If no &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; or an empty string is set, everything in the source model will be accepted.</source>
          <target state="translated">어떤 경우 &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; 또는 빈 문자열이 설정되지 않은 소스 모델의 모든 것이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f1f8d92c627ff32d243a667156fe4a5d1b8b955" translate="yes" xml:space="preserve">
          <source>If no &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; or an empty string is set, everything in the source model will be accepted.</source>
          <target state="translated">어떤 경우 &lt;a href=&quot;qregularexpression&quot;&gt;QRegularExpression&lt;/a&gt; 또는 빈 문자열이 설정되지 않은 소스 모델의 모든 것이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="47aa8cf397dc343800ccfb5224b080365aa4248c" translate="yes" xml:space="preserve">
          <source>If no Diffie-Hellman parameters have been set, the &lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration&lt;/a&gt; object defaults to using the 1024-bit MODP group from RFC 2409.</source>
          <target state="translated">Diffie-Hellman 매개 변수가 설정되지 않은 경우 &lt;a href=&quot;qsslconfiguration&quot;&gt;QSslConfiguration&lt;/a&gt; 오브젝트는 기본적으로 RFC 2409의 1024 비트 MODP 그룹을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="de6cd4825bb1cee3575896470783202606516613" translate="yes" xml:space="preserve">
          <source>If no XML declaration has been parsed, this function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">XML 선언이 구문 분석되지 않은 경우이 함수는 &lt;code&gt;false&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="faef744b92b2fdc0341709dd61d1556a8e0b8a77" translate="yes" xml:space="preserve">
          <source>If no application name is given, the &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; object will only access the organization-wide &lt;a href=&quot;qsettings#fallback-mechanism&quot;&gt;locations&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램 이름을 지정하지 않으면 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 객체는 조직 전체 &lt;a href=&quot;qsettings#fallback-mechanism&quot;&gt;위치&lt;/a&gt; 에만 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="ff14fad9a98ed7ba4cb8d60ff0206f2d0f478a96" translate="yes" xml:space="preserve">
          <source>If no argument is passed, all messages will be logged.</source>
          <target state="translated">인수가 전달되지 않으면 모든 메시지가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="35261865c4dcd9bade181a49eaab0e7e78844bdb" translate="yes" xml:space="preserve">
          <source>If no audio plugins are available, a fallback dummy backend will be used. This should print out warnings if this is the case when you try and use &lt;a href=&quot;qaudioinput&quot;&gt;QAudioInput&lt;/a&gt; or &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt;. To fix this problem, make sure the dependencies for the Qt plugins are installed on the system and reconfigure Qt (e.g. alsa-devel package on Linux), or create your own plugin with a default key to always override the dummy fallback. The easiest way to determine if you have only a dummy backend is to get a list of available audio devices.</source>
          <target state="translated">사용 가능한 오디오 플러그인이없는 경우 대체 더미 백엔드가 사용됩니다. &lt;a href=&quot;qaudioinput&quot;&gt;QAudioInput&lt;/a&gt; 또는 &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput을&lt;/a&gt; 사용하려고 할 때 경고가 표시됩니다 . 이 문제를 해결하려면 Qt 플러그인의 종속성이 시스템에 설치되어 있고 Qt (예 : Linux의 alsa-devel 패키지)를 재구성하거나 기본 키로 고유 한 플러그인을 작성하여 더미 폴백을 항상 재정의하십시오. 더미 백엔드 만 있는지 확인하는 가장 쉬운 방법은 사용 가능한 오디오 장치 목록을 얻는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5321f613472e00254d180a4fc05b0164116de042" translate="yes" xml:space="preserve">
          <source>If no axes are set explicitly to &lt;a href=&quot;q3dbars&quot;&gt;Q3DBars&lt;/a&gt;, temporary default axes with no labels are created. These default axes can be modified via axis accessors, but as soon any axis is set explicitly for the orientation, the default axis for that orientation is destroyed.</source>
          <target state="translated">축이 &lt;a href=&quot;q3dbars&quot;&gt;Q3DBars로&lt;/a&gt; 명시 적으로 설정 되지 않은 경우 레이블이없는 임시 기본 축이 작성됩니다. 이러한 기본 축은 축 접근자를 통해 수정할 수 있지만, 축이 방향에 대해 명시 적으로 설정되면 해당 방향의 기본 축이 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="2ebd086a3bfc8f4a21e18a494d12766f4ae1b17b" translate="yes" xml:space="preserve">
          <source>If no axes are set explicitly to &lt;a href=&quot;q3dscatter&quot;&gt;Q3DScatter&lt;/a&gt;, temporary default axes with no labels are created. These default axes can be modified via axis accessors, but as soon any axis is set explicitly for the orientation, the default axis for that orientation is destroyed.</source>
          <target state="translated">축이 명시 적으로 &lt;a href=&quot;q3dscatter&quot;&gt;Q3DScatter&lt;/a&gt; 로 설정 되지 않으면 레이블이없는 임시 기본 축이 작성됩니다. 이러한 기본 축은 축 접근자를 통해 수정할 수 있지만, 축이 방향에 대해 명시 적으로 설정되면 해당 방향의 기본 축이 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="0e5206fe4388fa4494ea22ed8f340b1481344880" translate="yes" xml:space="preserve">
          <source>If no axes are set explicitly to &lt;a href=&quot;q3dsurface&quot;&gt;Q3DSurface&lt;/a&gt;, temporary default axes with no labels are created. These default axes can be modified via axis accessors, but as soon any axis is set explicitly for the orientation, the default axis for that orientation is destroyed.</source>
          <target state="translated">축이 &lt;a href=&quot;q3dsurface&quot;&gt;Q3DSurface로&lt;/a&gt; 명시 적으로 설정 되지 않은 경우 레이블이없는 임시 기본 축이 작성됩니다. 이러한 기본 축은 축 접근자를 통해 수정할 수 있지만, 축이 방향에 대해 명시 적으로 설정되면 해당 방향의 기본 축이 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="d332b887e8f55f3941c7b91e48f4056b722533be" translate="yes" xml:space="preserve">
          <source>If no call to QQuickItem::updatePaintNode() result in actual scene graph changes, like &lt;a href=&quot;qsgnode#markDirty&quot;&gt;QSGNode::markDirty&lt;/a&gt;() or adding and removing nodes, then the underlying implementation may decide to not render the scene again as the visual outcome is identical.</source>
          <target state="translated">QQuickItem :: updatePaintNode ()를 호출하지 않으면 &lt;a href=&quot;qsgnode#markDirty&quot;&gt;QSGNode :: markDirty&lt;/a&gt; () 또는 노드 추가 및 제거와 같은 실제 장면 그래프 변경이 발생 하는 경우 시각적 구현이 동일하므로 기본 구현에서 장면을 다시 렌더링하지 않기로 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eea3cfabb2c79e1505623b30243e44817fd2225e" translate="yes" xml:space="preserve">
          <source>If no camera is available at the specified</source>
          <target state="translated">지정된 카메라를 사용할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="855a0ce74e0ba4f0df617857cdd9c70f21e80c72" translate="yes" xml:space="preserve">
          <source>If no camera with that</source>
          <target state="translated">카메라가 없으면</target>
        </trans-unit>
        <trans-unit id="9dbb4625466dd230bcd5e0d51b92b8f49b95b027" translate="yes" xml:space="preserve">
          <source>If no capable plugins or built-in handlers are found, each plugin is tested by inspecting the content of the data stream.</source>
          <target state="translated">사용 가능한 플러그인 또는 내장 핸들러가없는 경우 데이터 스트림의 컨텐츠를 검사하여 각 플러그인을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="7eae963dd7c12b3b183118060a854965aa670294" translate="yes" xml:space="preserve">
          <source>If no cursor has been set, or after a call to &lt;a href=&quot;qwindow#unsetCursor&quot;&gt;unsetCursor&lt;/a&gt;(), the parent window's cursor is used.</source>
          <target state="translated">커서가 설정되지 않았거나 &lt;a href=&quot;qwindow#unsetCursor&quot;&gt;unsetCursor&lt;/a&gt; ()를 호출 한 후에 는 부모 창의 커서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b9d24390c8262ea7308466c8f36e647506518a32" translate="yes" xml:space="preserve">
          <source>If no cursor has been set, or after a call to unsetCursor(), the parent's cursor is used.</source>
          <target state="translated">커서가 설정되지 않았거나 unsetCursor ()를 호출 한 후에는 부모의 커서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5b3026b682e70b28d58e0c458046b22bd753385d" translate="yes" xml:space="preserve">
          <source>If no cursor has been set, the cursor of the item beneath is used.</source>
          <target state="translated">커서가 설정되어 있지 않으면 아래 항목의 커서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="21df2d613061882b83412550c6f256e122a9c63a" translate="yes" xml:space="preserve">
          <source>If no cursor shape has been set this returns a cursor with the &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt::ArrowCursor&lt;/a&gt; shape, however another cursor shape may be displayed if an overlapping item has a valid cursor.</source>
          <target state="translated">커서 모양이 설정되어 있지 않으면 &lt;a href=&quot;qt#CursorShape-enum&quot;&gt;Qt :: ArrowCursor&lt;/a&gt; 모양 의 커서가 반환 되지만 겹치는 항목에 유효한 커서가 있으면 다른 커서 모양이 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="188b9bb1d59af57b2d8406d1891f4d1cd085adf2" translate="yes" xml:space="preserve">
          <source>If no data has been set, this will create a default constructed instance of type T.</source>
          <target state="translated">데이터가 설정되지 않은 경우, T 유형의 기본 생성 인스턴스가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="37093d13b03c4ef69f00b212a76bbe5e9054a17b" translate="yes" xml:space="preserve">
          <source>If no data proxy is set explicitly for the series, the series creates a default proxy. Setting another proxy will destroy the existing proxy and all data added to it.</source>
          <target state="translated">시리즈에 대해 데이터 프록시가 명시 적으로 설정되지 않은 경우 시리즈는 기본 프록시를 만듭니다. 다른 프록시를 설정하면 기존 프록시와 추가 된 모든 데이터가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="5856dcc40f4efa3dd839e2a141237dcc35272905" translate="yes" xml:space="preserve">
          <source>If no default format is set, &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings::NativeFormat&lt;/a&gt; is used. See the documentation for the &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; constructor you are using to see if that constructor will ignore this function.</source>
          <target state="translated">기본 형식이 설정되어 있지 않으면 &lt;a href=&quot;qsettings#Format-enum&quot;&gt;QSettings :: NativeFormat&lt;/a&gt; 이 사용됩니다. 해당 생성자가이 기능을 무시하는지 확인하려면 사용중인 &lt;a href=&quot;qsettings&quot;&gt;QSettings&lt;/a&gt; 생성자 의 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="de945630b038eb6470980946270a4f68bd2d6f6b" translate="yes" xml:space="preserve">
          <source>If no default value is specified, a default &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; is returned.</source>
          <target state="translated">기본값을 지정하지 않으면 기본 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="aa07379188c2dd8c867835a91837f848c038d1a7" translate="yes" xml:space="preserve">
          <source>If no destination address was associated with this datagram, this function returns -1.</source>
          <target state="translated">이 데이터 그램과 관련된 대상 주소가 없으면이 함수는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="af31daa471cfd43ee35522d4a64bade6cb857bec" translate="yes" xml:space="preserve">
          <source>If no destination address was set on this datagram, the returned object will report true to &lt;a href=&quot;qhostaddress#isNull&quot;&gt;QHostAddress::isNull&lt;/a&gt;().</source>
          <target state="translated">이 데이터 그램에 대상 주소가 설정되어 있지 않으면 반환 된 객체는 true를 &lt;a href=&quot;qhostaddress#isNull&quot;&gt;QHostAddress :: isNull&lt;/a&gt; () 에보고 합니다.</target>
        </trans-unit>
        <trans-unit id="cae8bfde49b2e56aa7d260723f26e6de7b997620" translate="yes" xml:space="preserve">
          <source>If no encoding is specified then no such meta information is generated.</source>
          <target state="translated">인코딩을 지정하지 않으면 해당 메타 정보가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0fb069cf808205f6b62832525be8c54e5b5d57d4" translate="yes" xml:space="preserve">
          <source>If no error has occurred this will return an empty string. It is possible that an error occurred which has no associated textual representation, in which case this will also return an empty string.</source>
          <target state="translated">오류가 발생하지 않으면 빈 문자열이 반환됩니다. 관련 텍스트 표현이없는 오류가 발생했을 수 있으며이 경우 빈 문자열도 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d43ef1cd654c1fb727cf0bbb8ae4fa189c0ad6cd" translate="yes" xml:space="preserve">
          <source>If no error has occurred, the string is empty.</source>
          <target state="translated">오류가 발생하지 않으면 문자열이 비어있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0e78998c4bddc2610642e223f387f90d408a1ccb" translate="yes" xml:space="preserve">
          <source>If no errors are present, an empty string is returned.</source>
          <target state="translated">오류가 없으면 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="79c7a6ea215cd19a5c348163231d45d9a3b72d00" translate="yes" xml:space="preserve">
          <source>If no event loop is running, events won't be delivered to the object. For example, if you create a &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt; object in a thread but never call &lt;a href=&quot;qthread#exec&quot;&gt;exec()&lt;/a&gt;, the &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt; will never emit its &lt;a href=&quot;qtimer#timeout&quot;&gt;timeout()&lt;/a&gt; signal. Calling &lt;a href=&quot;qobject#deleteLater&quot;&gt;deleteLater()&lt;/a&gt; won't work either. (These restrictions apply to the main thread as well.)</source>
          <target state="translated">이벤트 루프가 실행되고 있지 않으면 이벤트가 객체로 전달되지 않습니다. 예를 들어, 스레드에서 &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt; 객체 를 만들지 만 &lt;a href=&quot;qthread#exec&quot;&gt;exec ()를&lt;/a&gt; 호출하지 않으면 &lt;a href=&quot;qtimer&quot;&gt;QTimer&lt;/a&gt; 는 &lt;a href=&quot;qtimer#timeout&quot;&gt;timeout ()&lt;/a&gt; 신호를 방출하지 않습니다 . &lt;a href=&quot;qobject#deleteLater&quot;&gt;deleteLater ()&lt;/a&gt; 를 호출 해도 작동하지 않습니다. (이러한 제한 사항은 메인 스레드에도 적용됩니다.)</target>
        </trans-unit>
        <trans-unit id="e20b00f1d48c70a7c21e16f91e90f5abc3535c09" translate="yes" xml:space="preserve">
          <source>If no events are available, this function will wait until more are available and return after processing newly available events.</source>
          <target state="translated">사용 가능한 이벤트가없는 경우이 기능은 사용 가능한 추가 이벤트가있을 때까지 기다렸다가 새로 사용 가능한 이벤트를 처리 한 후 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="12c3a8bad98f18d80217cd88d6a2fed1348d6fd5" translate="yes" xml:space="preserve">
          <source>If no explicit background role is set, the widget inherts its parent widget's background role.</source>
          <target state="translated">명시 적 백그라운드 역할이 설정되지 않은 경우 위젯은 상위 위젯의 백그라운드 역할을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="20e3cefa21d1440421fa876858df13e7b07ee525" translate="yes" xml:space="preserve">
          <source>If no explicit foreground role is set, the function returns a role that contrasts with the background role.</source>
          <target state="translated">명시 적 포 그라운드 역할이 설정되지 않은 경우 함수는 백그라운드 역할과 대조되는 역할을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4004e793cd1c07b9c2a7c5013c5ef24591840f3b" translate="yes" xml:space="preserve">
          <source>If no feature weight has been specified for</source>
          <target state="translated">기능 중량을 지정하지 않은 경우</target>
        </trans-unit>
        <trans-unit id="4c819b6fdfc74213cb5a279dde7197240d3245be" translate="yes" xml:space="preserve">
          <source>If no file path is set, this property contains an empty string.</source>
          <target state="translated">파일 경로를 설정하지 않으면이 속성에 빈 문자열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e03643e53caecbf9b1d87dafce632e1d411c60b6" translate="yes" xml:space="preserve">
          <source>If no font exists on the system that can support the text, then special &quot;missing character&quot; boxes will be shown in its place.</source>
          <target state="translated">시스템에 텍스트를 지원할 수있는 글꼴이 없으면 특별한 &quot;누락 된 문자&quot;상자가 그 자리에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c916de102a556675d3997372eab745e3113fec7f" translate="yes" xml:space="preserve">
          <source>If no format has been set, Qt guesses the picture format before reading it. If a format is set the picture will only be read if it has that format.</source>
          <target state="translated">포맷이 설정되어 있지 않으면 Qt는 읽기 전에 그림 포맷을 추측합니다. 형식이 설정되어 있으면 해당 형식이있는 경우에만 그림을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="154302692b92ec413e1255873112c01fac5d15ff" translate="yes" xml:space="preserve">
          <source>If no full packet is received, this code restores the stream to the initial position, after which you need to wait for more data to arrive.</source>
          <target state="translated">전체 패킷이 수신되지 않으면이 코드는 스트림을 초기 위치로 복원 한 후 더 많은 데이터가 도착할 때까지 기다려야합니다.</target>
        </trans-unit>
        <trans-unit id="feb903b77e07ec10078534c602263fe58d38f726" translate="yes" xml:space="preserve">
          <source>If no handler is specified, the view will log the messages into a &lt;code&gt;js&lt;/code&gt;&lt;a href=&quot;qloggingcategory&quot;&gt;logging category&lt;/a&gt;.</source>
          <target state="translated">핸들러가 지정되지 않으면보기는 메시지를 &lt;code&gt;js&lt;/code&gt; &lt;a href=&quot;qloggingcategory&quot;&gt;logging category에 기록&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="bb3f449dd4ec08b2b15138185188005c4699fa42" translate="yes" xml:space="preserve">
          <source>If no horizontal alignment was specified, the function returns the default alignment for the given layout</source>
          <target state="translated">가로 맞춤이 지정되지 않은 경우 함수는 지정된 레이아웃에 대한 기본 맞춤을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d7cd127d8e936e3f0897ad93b570abd20807d023" translate="yes" xml:space="preserve">
          <source>If no icon is set by the sender, a null &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; is returned.</source>
          <target state="translated">발신자가 아이콘을 설정하지 않으면 null &lt;a href=&quot;qimage&quot;&gt;QImage&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b95876b6948c34db73f0dcd2e7dcd0eb80f4c148" translate="yes" xml:space="preserve">
          <source>If no implementation for the object's class is available, the function tries to find an implementation for the object's parent class, using the above strategy.</source>
          <target state="translated">객체 클래스에 대한 구현이없는 경우, 함수는 위 전략을 사용하여 객체의 상위 클래스에 대한 구현을 찾으려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="019484bb20240c8e074a3ab27dd602255fedbad9" translate="yes" xml:space="preserve">
          <source>If no index is supplied the data is appended to the model.</source>
          <target state="translated">인덱스가 제공되지 않으면 데이터가 모델에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4e98284a25a46d3fdc654932dec1712d52a1f6b1" translate="yes" xml:space="preserve">
          <source>If no instance has been allocated, &lt;code&gt;nullptr&lt;/code&gt; is returned.</source>
          <target state="translated">할당 된 인스턴스가 없으면 &lt;code&gt;nullptr&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6b711214f2f7cdb9d145f4c76ea5c87d5294909d" translate="yes" xml:space="preserve">
          <source>If no key roles have been specified, all existing model data is removed, and the model is rebuilt from scratch.</source>
          <target state="translated">키 역할을 지정하지 않으면 기존의 모든 모델 데이터가 제거되고 모델이 처음부터 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="ba2a46b0ee7f35ae9c971d449358e69925fec0ca" translate="yes" xml:space="preserve">
          <source>If no keys are listed the &lt;a href=&quot;qml-qtquick-droparea&quot;&gt;DropArea&lt;/a&gt; will accept events from any drag source, otherwise the drag source must have at least one compatible key.</source>
          <target state="translated">키가 나열되지 않으면 &lt;a href=&quot;qml-qtquick-droparea&quot;&gt;DropArea&lt;/a&gt; 는 모든 드래그 소스의 이벤트를 수락합니다. 그렇지 않으면 드래그 소스에 호환 가능한 키가 하나 이상 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6fc5c9a77a96e07c47d22936a2077844358fd86a" translate="yes" xml:space="preserve">
          <source>If no layout is currently managing this widget, &lt;a href=&quot;qgraphicswidget#layout&quot;&gt;layout&lt;/a&gt;() will return &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">어떤 레이아웃이 현재이 위젯을 관리하지 않는 경우, &lt;a href=&quot;qgraphicswidget#layout&quot;&gt;레이아웃&lt;/a&gt; () 반환합니다 &lt;code&gt;nullptr&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="83f871351439dde1ebee7e717c71c00230877bd3" translate="yes" xml:space="preserve">
          <source>If no limit was set this function will return -1.</source>
          <target state="translated">제한이 설정되지 않은 경우이 기능은 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b08bd2ac21fdd75a621409615e3444158b1c61f0" translate="yes" xml:space="preserve">
          <source>If no list is specified, or the sum of weights in the list is zero, then the sprite will repeat itself after completing.</source>
          <target state="translated">목록이 지정되지 않았거나 목록의 가중치 합계가 0이면 스프라이트는 완료된 후 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="6a4299e94fc48cfe4ea3bc4000536beab94b89a6" translate="yes" xml:space="preserve">
          <source>If no manager has been assigned to the icon, and the parameters do not contain the &lt;a href=&quot;qplaceicon#SingleUrl-var&quot;&gt;QPlaceIcon::SingleUrl&lt;/a&gt; key, a default constructed &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; is returned.</source>
          <target state="translated">아이콘에 관리자가 지정되지 않았고 매개 변수에 &lt;a href=&quot;qplaceicon#SingleUrl-var&quot;&gt;QPlaceIcon :: SingleUrl&lt;/a&gt; 키가 포함되어 있지 않으면 기본 구성된 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9322eadf009c192a6465c8ca2761b2c29d004c58" translate="yes" xml:space="preserve">
          <source>If no mask is set, inputMask() returns an empty string.</source>
          <target state="translated">마스크를 설정하지 않으면 inputMask ()는 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f5c502e8ed703c352838d282835deb20862fc6d" translate="yes" xml:space="preserve">
          <source>If no match is found, &lt;code&gt;-1&lt;/code&gt; is returned. The search is case sensitive.</source>
          <target state="translated">일치하는 것이 없으면 &lt;code&gt;-1&lt;/code&gt; 이 반환됩니다. 검색은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="0bc9f7961e37bc141d624270502130c09fcc5114" translate="yes" xml:space="preserve">
          <source>If no persistent model index equal to the given</source>
          <target state="translated">주어진 것과 동일한 영구 모델 색인이없는 경우</target>
        </trans-unit>
        <trans-unit id="bf4f342be49f5371d07c8d4d7f47cb8830a95df5" translate="yes" xml:space="preserve">
          <source>If no persistent model indexes equal to the indexes in the given</source>
          <target state="translated">주어진 인덱스와 동일한 영구 모델 인덱스가없는 경우</target>
        </trans-unit>
        <trans-unit id="628c43462c230555c453183e6e40b2aa144ba2c1" translate="yes" xml:space="preserve">
          <source>If no pixmap has been set this will return nullptr.</source>
          <target state="translated">pixmap이 설정되어 있지 않으면 nullptr을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f9701f3a67e310ca07c0b2c91ba30d087c3e1b83" translate="yes" xml:space="preserve">
          <source>If no plugin has been assigned to the icon, and the parameters do not contain the 'singleUrl' key, a default constructed URL is returned.</source>
          <target state="translated">아이콘에 플러그인이 지정되어 있지 않고 매개 변수에 'singleUrl'키가 포함되어 있지 않으면 기본 구성 URL이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0e2ad07072cc0a4e651a2a5754371ed22b24f72e" translate="yes" xml:space="preserve">
          <source>If no plugin matching</source>
          <target state="translated">플러그인이 일치하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="d8713b24f23198b52fafa2d42853b008b030dce0" translate="yes" xml:space="preserve">
          <source>If no plugin supports the image format, Qt's built-in handlers are checked based on either the optional format string, or the file name suffix.</source>
          <target state="translated">이미지 형식을 지원하는 플러그인이없는 경우 Qt의 내장 핸들러는 선택적 형식 문자열 또는 파일 이름 접미사를 기반으로 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="e9de8f3670f6727bf47c86842fed6506f9225aab" translate="yes" xml:space="preserve">
          <source>If no plugins could detect the image format based on data contents, each built-in image handler is tested by inspecting the contents.</source>
          <target state="translated">플러그인이 데이터 컨텐츠를 기반으로 이미지 형식을 감지 할 수없는 경우 각 내장 이미지 핸들러는 컨텐츠를 검사하여 테스트됩니다.</target>
        </trans-unit>
        <trans-unit id="ab59db10a6fddd56d82a88f48e984ce28c0300ac" translate="yes" xml:space="preserve">
          <source>If no prefix is set, prefix() returns an empty string.</source>
          <target state="translated">접두사가 설정되지 않으면 prefix ()는 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="625d74be4414ee9e28ad392f44e29581aa4ea291" translate="yes" xml:space="preserve">
          <source>If no previous event was delivered with information about this gesture (i.e., this gesture object contains information about the first movement in the gesture) then this property contains a zero size.</source>
          <target state="translated">이 제스처에 대한 정보가있는 이전 이벤트가 전달되지 않은 경우 (즉,이 제스처 객체는 제스처의 첫 번째 움직임에 대한 정보를 포함 함)이 속성은 크기가 0입니다.</target>
        </trans-unit>
        <trans-unit id="34f068fd664b373dfa1e9ea77f8f12a0c10bee2f" translate="yes" xml:space="preserve">
          <source>If no previous event was delivered with information about this gesture (i.e., this gesture object contains information about the first movement in the gesture) then this property contains zero.</source>
          <target state="translated">이 제스처에 대한 정보가있는 이전 이벤트가 전달되지 않은 경우 (즉,이 제스처 객체에는 제스처의 첫 번째 움직임에 대한 정보가 포함됨)이 속성에 0이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="176c29df90a533b0f3ccf7d7da471f0f52454318" translate="yes" xml:space="preserve">
          <source>If no protocol could be negotiated or the extension was not enabled, this function returns a &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; which is null.</source>
          <target state="translated">협상 할 수있는 프로토콜이 없거나 확장이 활성화되지 않은 경우이 함수는 &lt;a href=&quot;qbytearray&quot;&gt;널인 QByteArray&lt;/a&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d923553677d99d6ca86a9e38180df5992c4af7e3" translate="yes" xml:space="preserve">
          <source>If no reply is received within</source>
          <target state="translated">안에 응답이 없으면</target>
        </trans-unit>
        <trans-unit id="a5311b93ab74ba099fee7b06f5a3accc4174effd" translate="yes" xml:space="preserve">
          <source>If no sender address was associated with this datagram, this function returns -1.</source>
          <target state="translated">이 데이터 그램과 연결된 발신자 주소가 없으면이 함수는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d2a3c99a180dc0b00600cfd57a101ccbe0f011d3" translate="yes" xml:space="preserve">
          <source>If no sender address was set on this datagram, the returned object will report true to &lt;a href=&quot;qhostaddress#isNull&quot;&gt;QHostAddress::isNull&lt;/a&gt;().</source>
          <target state="translated">이 데이터 그램에 보낸 사람 주소가 설정되어 있지 않으면 반환 된 객체는 true를 &lt;a href=&quot;qhostaddress#isNull&quot;&gt;QHostAddress :: isNull&lt;/a&gt; () 에보고 합니다.</target>
        </trans-unit>
        <trans-unit id="89b77b56ac91f510077c97340442fb508f0a6217" translate="yes" xml:space="preserve">
          <source>If no size hint has been set, the item delegate will compute the size hint based on the item data.</source>
          <target state="translated">크기 힌트가 설정되지 않은 경우, 아이템 델리게이트는 아이템 데이터를 기반으로 크기 힌트를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="7a2fce843522be61a8572919935f53fee605226a" translate="yes" xml:space="preserve">
          <source>If no slot is connected to this signal, all origins will be accepted by default.</source>
          <target state="translated">이 신호에 슬롯이 연결되어 있지 않으면 기본적으로 모든 원점이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c0bcefe937f11494eb7628cbc61cd6386345c92d" translate="yes" xml:space="preserve">
          <source>If no special-value text is set, specialValueText() returns an empty string.</source>
          <target state="translated">특수 값 텍스트가 설정되지 않은 경우 specialValueText ()는 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c1b71e7a0d8f4cb19076097e6fe68ba2874dd715" translate="yes" xml:space="preserve">
          <source>If no stop points have been specified, a gradient of black at 0 to white at 1 is used.</source>
          <target state="translated">정지 점이 지정되지 않은 경우 0에서 검은 색에서 1에서 흰색의 기울기가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="245ef42823c910f6c44223f33e340d9f2d9c0720" translate="yes" xml:space="preserve">
          <source>If no style is assigned, or</source>
          <target state="translated">스타일이 지정되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="d7db6c8318f6598d6b7a049e3c407f53896ef80d" translate="yes" xml:space="preserve">
          <source>If no style is set, the widget uses the application's style, &lt;a href=&quot;qapplication#style&quot;&gt;QApplication::style&lt;/a&gt;() instead.</source>
          <target state="translated">스타일이 설정되지 않으면 위젯은 대신 애플리케이션의 스타일 인 &lt;a href=&quot;qapplication#style&quot;&gt;QApplication :: style&lt;/a&gt; ()을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8f32e42a327f2f7a0d75e39d52a43cd30bfe4638" translate="yes" xml:space="preserve">
          <source>If no style is specified, Qt will choose the most appropriate style for the user's platform or desktop environment.</source>
          <target state="translated">스타일을 지정하지 않으면 Qt는 사용자 플랫폼 또는 데스크탑 환경에 가장 적합한 스타일을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="8b98edccbb5052496a9d58804dc379ab77bdf14d" translate="yes" xml:space="preserve">
          <source>If no such device exists, the &lt;a href=&quot;qcamerainfo&quot;&gt;QCameraInfo&lt;/a&gt; object will be invalid and &lt;a href=&quot;qcamerainfo#isNull&quot;&gt;isNull&lt;/a&gt;() will return true.</source>
          <target state="translated">그러한 장치가 없으면 &lt;a href=&quot;qcamerainfo&quot;&gt;QCameraInfo&lt;/a&gt; 객체는 유효하지 않으며 &lt;a href=&quot;qcamerainfo#isNull&quot;&gt;isNull입니다&lt;/a&gt; ()이 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="536bed973aaef01d601595162bfb6f2d4303580b" translate="yes" xml:space="preserve">
          <source>If no such direct child exists, a &lt;a href=&quot;qdomnode#isNull&quot;&gt;null node&lt;/a&gt; is returned.</source>
          <target state="translated">그러한 직계 자식이 존재하지 않는 경우는 &lt;a href=&quot;qdomnode#isNull&quot;&gt;null 노드&lt;/a&gt; 가 돌려 주어집니다.</target>
        </trans-unit>
        <trans-unit id="02595d9af9fc299bd69f7013bcd2e46bc097bc8d" translate="yes" xml:space="preserve">
          <source>If no such node is available, a default constructed &lt;a href=&quot;qxmlnodemodelindex&quot;&gt;QXmlNodeModelIndex&lt;/a&gt; is returned.</source>
          <target state="translated">이러한 노드를 사용할 수 없으면 기본 생성 된 &lt;a href=&quot;qxmlnodemodelindex&quot;&gt;QXmlNodeModelIndex&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3698877d0b6f3ebbe8ed207fe97676032080b34d" translate="yes" xml:space="preserve">
          <source>If no such property exists, the returned variant is invalid.</source>
          <target state="translated">이러한 속성이 없으면 반환 된 변형이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51744a731af10cbf9d9a2d17d98df39d7dad045b" translate="yes" xml:space="preserve">
          <source>If no suffix is set, suffix() returns an empty string.</source>
          <target state="translated">접미사가 설정되지 않으면 suffix ()는 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d7e5291eee4708b1338aced294a2ef8565871d83" translate="yes" xml:space="preserve">
          <source>If no targets are specified all &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorChanges&lt;/a&gt; will be animated by the &lt;a href=&quot;qml-qtquick-anchoranimation&quot;&gt;AnchorAnimation&lt;/a&gt;.</source>
          <target state="translated">대상을 지정하지 않으면 &lt;a href=&quot;qml-qtquick-anchorchanges&quot;&gt;AnchorAnimation에&lt;/a&gt; 의해 모든 AnchorChanges에 애니메이션이 &lt;a href=&quot;qml-qtquick-anchoranimation&quot;&gt;적용&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="1022dceae1105b57d9fbf2099abff67d6f7a380d" translate="yes" xml:space="preserve">
          <source>If no text has been set this will return an empty string. Setting the text clears any previous content.</source>
          <target state="translated">텍스트를 설정하지 않으면 빈 문자열이 반환됩니다. 텍스트를 설정하면 이전 내용이 지워집니다.</target>
        </trans-unit>
        <trans-unit id="63ea2b9a9d8f2ce1d6a368804f858aedc1b61dd4" translate="yes" xml:space="preserve">
          <source>If no text is selected, deletes the character to the left of the text cursor and moves the cursor one position to the left. If any text is selected, the cursor is moved to the beginning of the selected text and the selected text is deleted.</source>
          <target state="translated">텍스트를 선택하지 않으면 텍스트 커서 왼쪽의 문자를 삭제하고 커서를 한 위치 왼쪽으로 이동합니다. 텍스트를 선택하면 커서가 선택한 텍스트의 시작 부분으로 이동하고 선택한 텍스트가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="27d7831f7c19a13d90255f17c4a8e42edca3fed9" translate="yes" xml:space="preserve">
          <source>If no text is selected, deletes the character to the right of the text cursor. If any text is selected, the cursor is moved to the beginning of the selected text and the selected text is deleted.</source>
          <target state="translated">텍스트를 선택하지 않으면 텍스트 커서 오른쪽의 문자를 삭제합니다. 텍스트를 선택하면 커서가 선택한 텍스트의 시작 부분으로 이동하고 선택한 텍스트가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="9e9c88ec0c04eedb33d789b4fc1c4578e490594e" translate="yes" xml:space="preserve">
          <source>If no threads are available at the time of calling, then this function does nothing and returns &lt;code&gt;false&lt;/code&gt;. Otherwise,</source>
          <target state="translated">호출 할 때 사용 가능한 스레드가 없으면이 함수는 아무 작업도 수행하지 않고 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 그렇지 않으면,</target>
        </trans-unit>
        <trans-unit id="ed71403e041bf6517183660ed91fecc463557bf4" translate="yes" xml:space="preserve">
          <source>If no value has been set for this key (or if the value has been cleared), an invalid &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; is returned.</source>
          <target state="translated">이 키에 값을 설정하지 않았거나 값을 지우면 유효하지 않은 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="33ab4d0fc31ddef40d47d7ed4737cc8cc2a9a863" translate="yes" xml:space="preserve">
          <source>If no value is explicitly set, the layout's horizontal spacing is inherited from the parent layout, or from the style settings for the parent widget.</source>
          <target state="translated">값을 명시 적으로 설정하지 않으면 레이아웃의 가로 간격이 부모 레이아웃 또는 부모 위젯의 스타일 설정에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="4f13f71d8fc858da15c8a5668fd2c41edf4fae99" translate="yes" xml:space="preserve">
          <source>If no value is explicitly set, the layout's spacing is inherited from the parent layout, or from the style settings for the parent widget.</source>
          <target state="translated">값을 명시 적으로 설정하지 않으면 레이아웃의 간격이 부모 레이아웃 또는 부모 위젯의 스타일 설정에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="a132946dc0c5c3d374269e80f18846822167d7b1" translate="yes" xml:space="preserve">
          <source>If no value is explicitly set, the layout's vertical spacing is inherited from the parent layout, or from the style settings for the parent widget.</source>
          <target state="translated">값을 명시 적으로 설정하지 않으면 레이아웃의 수직 간격이 부모 레이아웃 또는 부모 위젯의 스타일 설정에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="02a117657c4aeb7efbf8ad07c2448e84ee88bc49" translate="yes" xml:space="preserve">
          <source>If no widget in this application is currently grabbing the keyboard, &lt;code&gt;nullptr&lt;/code&gt; is returned.</source>
          <target state="translated">이 애플리케이션에서 현재 키보드를 잡고있는 위젯이 없으면 &lt;code&gt;nullptr&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5fd1f2fc0dd2292d7a355311baac88d4d64115a4" translate="yes" xml:space="preserve">
          <source>If no widget in this application is currently grabbing the mouse, &lt;code&gt;nullptr&lt;/code&gt; is returned.</source>
          <target state="translated">이 응용 프로그램에서 현재 마우스를 잡고있는 위젯이 없으면 &lt;code&gt;nullptr&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b8db83cfafd49c384b51b4ec4d37edf5c56998e1" translate="yes" xml:space="preserve">
          <source>If no widget is embedded,</source>
          <target state="translated">위젯이 포함되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="a8cda4ea0019b5389d8ba247ffe4f7d705d3fab2" translate="yes" xml:space="preserve">
          <source>If nodes change every frame, the &lt;a href=&quot;qsgnode#preprocess&quot;&gt;preprocess&lt;/a&gt;() function can be used to apply changes to a node for every frame it is rendered. The use of &lt;a href=&quot;qsgnode#preprocess&quot;&gt;preprocess&lt;/a&gt;() must be explicitly enabled by setting the &lt;a href=&quot;qsgnode#Flag-enum&quot;&gt;QSGNode::UsePreprocess&lt;/a&gt; flag on the node.</source>
          <target state="translated">노드가 모든 프레임을 변경하는 경우 &lt;a href=&quot;qsgnode#preprocess&quot;&gt;전처리&lt;/a&gt; () 함수를 사용하여 렌더링 된 모든 프레임에 대해 변경 사항을 노드에 적용 할 수 있습니다. &lt;a href=&quot;qsgnode#Flag-enum&quot;&gt;QSGNode :: UsePreprocess를&lt;/a&gt; 설정하여 &lt;a href=&quot;qsgnode#preprocess&quot;&gt;사전 프로세스&lt;/a&gt; () 사용을 명시 적으로 사용 가능하게해야합니다.노드 플래그를 합니다.</target>
        </trans-unit>
        <trans-unit id="72becb58c4a0533b46713e1fc0a3b3afd9a8121e" translate="yes" xml:space="preserve">
          <source>If non null audio</source>
          <target state="translated">널이 아닌 오디오</target>
        </trans-unit>
        <trans-unit id="ace507f77194627265ca30014a2016b4986a721b" translate="yes" xml:space="preserve">
          <source>If non null image</source>
          <target state="translated">null이 아닌 이미지</target>
        </trans-unit>
        <trans-unit id="23b129655abb03b08bd0553ada506e77c19309fd" translate="yes" xml:space="preserve">
          <source>If non null video</source>
          <target state="translated">null이 아닌 비디오 인 경우</target>
        </trans-unit>
        <trans-unit id="4472fe73a6b62991ff97baf9eee50fbc55de0af6" translate="yes" xml:space="preserve">
          <source>If non null viewfinder</source>
          <target state="translated">널이 아닌 뷰 파인더 인 경우</target>
        </trans-unit>
        <trans-unit id="1e77c0e4acb8536be15195bbd7110329e3ed1fff" translate="yes" xml:space="preserve">
          <source>If none of the above are available, the call to &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;QRemoteObjectHostBase::enableRemoting&lt;/a&gt;() will fail, returning false.</source>
          <target state="translated">위의 어느 것도 사용 가능하지 않으면 &lt;a href=&quot;qremoteobjecthostbase#enableRemoting&quot;&gt;QRemoteObjectHostBase :: enableRemoting&lt;/a&gt; () 호출 이 실패하고 false를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f196510ee34a29666495f228e37cb93d55973ae0" translate="yes" xml:space="preserve">
          <source>If none of the fields can grow and the form is resized, extra space is distributed according to the current &lt;a href=&quot;qformlayout#formAlignment-prop&quot;&gt;form alignment&lt;/a&gt;.</source>
          <target state="translated">필드가 커지지 않고 양식 크기가 조정되면 현재 &lt;a href=&quot;qformlayout#formAlignment-prop&quot;&gt;양식 정렬&lt;/a&gt; 에 따라 추가 공간이 분배됩니다 .</target>
        </trans-unit>
        <trans-unit id="7630e3e5dc38a7696c51672002869eeed56ddc18" translate="yes" xml:space="preserve">
          <source>If none of the stacks are active, or if the group is empty, this function does nothing.</source>
          <target state="translated">스택이 활성화되어 있지 않거나 그룹이 비어 있으면이 함수는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80054739a24a4e8a8da26524ec9f7b5c4ea2c241" translate="yes" xml:space="preserve">
          <source>If none of the stacks are active, or if the group is empty, this function returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">스택이 활성화되어 있지 않거나 그룹이 비어 있으면이 함수는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="1e9775bad321db7d0d80d75aa11257d8a55e228d" translate="yes" xml:space="preserve">
          <source>If none of the stacks are active, or if the group is empty, this function returns &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">스택이 활성화되어 있지 않거나 그룹이 비어 있으면이 함수는 &lt;code&gt;nullptr&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1860e1a136a75244df0047638437457ad6355c09" translate="yes" xml:space="preserve">
          <source>If none of the stacks are active, or if the group is empty, this function returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">스택이 활성화되어 있지 않거나 그룹이 비어 있으면이 함수는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="3ab5e71f904d0f25e276092d1853535be0f982a1" translate="yes" xml:space="preserve">
          <source>If none of the stacks are active, or if the group is empty, this function returns an empty string.</source>
          <target state="translated">스택이 활성화되어 있지 않거나 그룹이 비어 있으면이 함수는 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d17a6592c3c1de9ecac5012fac7c17dc8df70b42" translate="yes" xml:space="preserve">
          <source>If none of the translation files contain a translation for</source>
          <target state="translated">번역 파일에 번역이 포함되어 있지 않은 경우</target>
        </trans-unit>
        <trans-unit id="ba1b99f66aa16a7a48e775776688e74e6de2cc3e" translate="yes" xml:space="preserve">
          <source>If not all characters are used (e.g. if only part of a multi-byte encoding is at the end of the characters), the decoder remembers enough state to continue with the next call to this function.</source>
          <target state="translated">모든 문자가 사용되지 않는 경우 (예 : 멀티 바이트 인코딩의 일부만 문자 끝에있는 경우) 디코더는이 함수에 대한 다음 호출을 계속하기에 충분한 상태를 기억합니다.</target>
        </trans-unit>
        <trans-unit id="e9db738e1bfa867b8c40bb2a2243d996062c62f6" translate="yes" xml:space="preserve">
          <source>If not explicitly closed, the underlying file handle is left open when the &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; object is destroyed.</source>
          <target state="translated">명시 적으로 닫히지 않으면 &lt;a href=&quot;qfile&quot;&gt;QFile&lt;/a&gt; 오브젝트가 소멸 될 때 기본 파일 핸들이 열린 채로 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51d879c6007a4634fb34830152078e965d5d3af7" translate="yes" xml:space="preserve">
          <source>If not explicitly set -- or after reset -- the value follows &lt;code&gt;QStyleHints::mousePressAndHoldInterval&lt;/code&gt;.</source>
          <target state="translated">명시 적으로 설정하지 않거나 재설정 후 값은 &lt;code&gt;QStyleHints::mousePressAndHoldInterval&lt;/code&gt; 따릅니다. .</target>
        </trans-unit>
        <trans-unit id="f08ced0e912d71b8dcd3be94b6cfa8c49f6b1a1d" translate="yes" xml:space="preserve">
          <source>If not found, then if set the specified font family exists and can be used to represent the writing system in use, it will be selected.</source>
          <target state="translated">찾을 수없는 경우 지정된 글꼴 모음을 설정하고 사용중인 필기 시스템을 나타내는 데 사용할 수 있으면 해당 글꼴이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="a9e851dde4906f334cc2c05aecc619443d8ba228" translate="yes" xml:space="preserve">
          <source>If not set, qmake looks to see if the files to install actually exist. If these files don't exist, qmake doesn&amp;rsquo;t create the install rule. Use this config value if you need to install files that are generated as part of your build process, like HTML files created by qdoc.</source>
          <target state="translated">설정하지 않으면 qmake는 설치할 파일이 실제로 존재하는지 확인합니다. 이러한 파일이 없으면 qmake는 설치 규칙을 생성하지 않습니다. qdoc에 의해 작성된 HTML 파일과 같이 빌드 프로세스의 일부로 생성 된 파일을 설치해야하는 경우이 구성 값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4f0966e9bbb965aafd9ff4924563edc203f47cbf" translate="yes" xml:space="preserve">
          <source>If not set, the application display name defaults to the application name.</source>
          <target state="translated">설정하지 않으면 응용 프로그램 표시 이름이 기본적으로 응용 프로그램 이름으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="77290f530709b765c6ca19b2d1d50994f8281c8f" translate="yes" xml:space="preserve">
          <source>If not set, the application name defaults to the executable name (since 5.0).</source>
          <target state="translated">설정하지 않으면 응용 프로그램 이름의 기본값은 실행 파일 이름 (5.0 이후)입니다.</target>
        </trans-unit>
        <trans-unit id="a1623874466c2114fbbf334268c437dc6ea797b0" translate="yes" xml:space="preserve">
          <source>If not set, the application version defaults to a platform-specific value determined from the main application executable or package (since Qt 5.9):</source>
          <target state="translated">설정하지 않으면, 응용 프로그램 버전은 기본 응용 프로그램 실행 파일 또는 패키지 (Qt 5.9부터)에서 결정된 플랫폼 별 값으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9a70247a6445cf79cf1e6b89ba8cccc9b2015765" translate="yes" xml:space="preserve">
          <source>If not specified by the &lt;code&gt;&lt;a href=&quot;#cpp-ignoretokens&quot;&gt;Cpp.ignoretokens&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#cpp-ignoredirectives&quot;&gt;Cpp.ignoredirectives&lt;/a&gt;&lt;/code&gt; variables, non-standard constructs (typically macros) can result in erroneous documentation.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;#cpp-ignoretokens&quot;&gt;Cpp.ignoretokens&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;#cpp-ignoredirectives&quot;&gt;Cpp.ignoredirectives&lt;/a&gt;&lt;/code&gt; 에 의해 지정되지 않은 경우 변수에 비표준 구문 (일반적으로 매크로)으로 잘못된 문서가 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5571375e4729a2a790df745601e1b6de66c648f9" translate="yes" xml:space="preserve">
          <source>If not specified, the item will span one column and one row.</source>
          <target state="translated">지정하지 않으면 항목은 한 열과 한 행에 걸쳐 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ee272d3d0dc0fa7bee9de49c035d73dad926db7" translate="yes" xml:space="preserve">
          <source>If not using a compressed &lt;a href=&quot;qopengltexture#format&quot;&gt;format&lt;/a&gt;() then you should use &lt;a href=&quot;qopengltexture#setData&quot;&gt;setData&lt;/a&gt;() instead of this function.</source>
          <target state="translated">압축 &lt;a href=&quot;qopengltexture#format&quot;&gt;형식&lt;/a&gt; ()을 사용하지 않는 경우이 함수 대신 &lt;a href=&quot;qopengltexture#setData&quot;&gt;setData&lt;/a&gt; ()를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e301e2160ad8c9b9e892a13c44cdad0d557b9b5b" translate="yes" xml:space="preserve">
          <source>If not, a replacement font that supports the writing system is selected. The font matching algorithm will try to find the best match for all the properties set in the &lt;a href=&quot;qfont&quot;&gt;QFont&lt;/a&gt;. How this is done varies from platform to platform.</source>
          <target state="translated">그렇지 않으면 쓰기 시스템을 지원하는 대체 글꼴이 선택됩니다. 글꼴 일치 알고리즘은 &lt;a href=&quot;qfont&quot;&gt;QFont에&lt;/a&gt; 설정된 모든 속성에 가장 적합한 것을 찾으려고 시도합니다 . 이 작업을 수행하는 방법은 플랫폼마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="2adf270f50f3ce9c43890cbb7b3b019725ced287" translate="yes" xml:space="preserve">
          <source>If not, it tries the top-level widget containing</source>
          <target state="translated">그렇지 않은 경우 다음을 포함하는 최상위 위젯을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="1ab38a2644f881cc77a28c57f955edd721aacb45" translate="yes" xml:space="preserve">
          <source>If on the other hand you want to call two different error functions when the number overflows, simply connect the signal to two different slots. Qt will call both (in the order they were connected).</source>
          <target state="translated">반면에 숫자가 넘칠 때 두 가지 다른 오류 함수를 호출하려면 신호를 두 개의 다른 슬롯에 연결하면됩니다. Qt는 연결된 순서대로 두 가지를 모두 호출합니다.</target>
        </trans-unit>
        <trans-unit id="6f770e33d15e38de1616e5da766a5954b7e571f0" translate="yes" xml:space="preserve">
          <source>If once is set to true, this affector will only affect each particle once in their lifetimes. If the affector normally simulates a continuous effect over time, then it will simulate the effect of one second of time the one instant it affects the particle.</source>
          <target state="translated">한 번만 true로 설정하면이 이펙터는 수명 동안 한 번만 각 입자에 영향을줍니다. 이펙터가 일반적으로 시간이 지남에 따라 연속 효과를 시뮬레이션하는 경우, 입자에 영향을 미치는 순간 순간의 1 초 효과를 시뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="c8886ef9e8476cb17f5c02809bbd511d4d44aee0" translate="yes" xml:space="preserve">
          <source>If one needs to register objects which are not available when the component is created, use the imperative &lt;a href=&quot;qml-qtwebchannel-webchannel#registerObjects-method&quot;&gt;registerObjects&lt;/a&gt; method.</source>
          <target state="translated">컴포넌트를 작성할 때 사용할 수없는 오브젝트를 등록해야하는 경우 명령형 &lt;a href=&quot;qml-qtwebchannel-webchannel#registerObjects-method&quot;&gt;registerObjects&lt;/a&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="646c5f55b500340ba0f63527d2c1ca10c1f4a909" translate="yes" xml:space="preserve">
          <source>If one wants to use &lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; to draw to a different backend, one must subclass &lt;a href=&quot;qpaintengine&quot;&gt;QPaintEngine&lt;/a&gt; and reimplement all its virtual functions. The &lt;a href=&quot;qpaintengine&quot;&gt;QPaintEngine&lt;/a&gt; implementation is then made available by subclassing &lt;a href=&quot;qpaintdevice&quot;&gt;QPaintDevice&lt;/a&gt; and reimplementing the virtual function &lt;a href=&quot;qpaintdevice#paintEngine&quot;&gt;QPaintDevice::paintEngine&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qpainter&quot;&gt;QPainter&lt;/a&gt; 를 사용 하여 다른 백엔드로 그리려면 &lt;a href=&quot;qpaintengine&quot;&gt;QPaintEngine을&lt;/a&gt; 서브 클래 싱 하고 모든 가상 함수를 다시 구현 해야합니다 . 그러면 &lt;a href=&quot;qpaintengine&quot;&gt;QPaintDevice&lt;/a&gt; 를 서브 클래 &lt;a href=&quot;qpaintdevice&quot;&gt;싱&lt;/a&gt; 하고 가상 함수 &lt;a href=&quot;qpaintdevice#paintEngine&quot;&gt;QPaintDevice :: paintEngine을&lt;/a&gt; 다시 구현하여 QPaintEngine 구현을 사용할 수 있습니다. ()을 .</target>
        </trans-unit>
        <trans-unit id="eb8bd7b5db1b0598024e5aa516f6fcc76199ac68" translate="yes" xml:space="preserve">
          <source>If only a single item is used within a &lt;a href=&quot;qml-qtquick-controls2-groupbox&quot;&gt;GroupBox&lt;/a&gt;, it will resize to fit the implicit size of its contained item. This makes it particularly suitable for use together with layouts.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls2-groupbox&quot;&gt;GroupBox&lt;/a&gt; 내에서 단일 항목 만 사용하는 경우 포함 된 항목의 암시 적 크기에 맞게 크기가 조정됩니다. 따라서 레이아웃과 함께 사용하기에 특히 적합합니다.</target>
        </trans-unit>
        <trans-unit id="37474d12b73e53d708050506ef11cf0c0b0240ac" translate="yes" xml:space="preserve">
          <source>If only a single item is used within a &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt;, the content size is automatically calculated based on the implicit size of its contained item. However, if more than one item is used (or an implicit size is not provided), the &lt;a href=&quot;qml-qtquick-controls2-pane#contentWidth-prop&quot;&gt;contentWidth&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls2-pane#contentHeight-prop&quot;&gt;contentHeight&lt;/a&gt; properties must be set to the combined size of its contained items.</source>
          <target state="translated">하나의 품목 만 &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt; 포함 된 항목의 암시 적 크기를 기반으로 내용 크기가 자동으로 계산됩니다. 그러나 둘 이상의 항목을 사용하는 경우 (또는 암시 적 크기가 제공되지 않은 경우) &lt;a href=&quot;qml-qtquick-controls2-pane#contentWidth-prop&quot;&gt;contentWidth&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls2-pane#contentHeight-prop&quot;&gt;contentHeight&lt;/a&gt; 속성은 포함 된 항목의 결합 된 크기로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="b853f898231c3f13cdc3ee7d652abfdf6ebf0e96" translate="yes" xml:space="preserve">
          <source>If only a single item is used within a Frame, it will resize to fit the implicit size of its contained item. This makes it particularly suitable for use together with layouts.</source>
          <target state="translated">프레임 내에서 단일 항목 만 사용하는 경우 포함 된 항목의 암시 적 크기에 맞게 크기가 조정됩니다. 따라서 레이아웃과 함께 사용하기에 특히 적합합니다.</target>
        </trans-unit>
        <trans-unit id="b348e97aa87c588075333a3065f359c859cdc194" translate="yes" xml:space="preserve">
          <source>If only a single item is used within a Pane, it will resize to fit the implicit size of its contained item. This makes it particularly suitable for use together with layouts.</source>
          <target state="translated">창 내에서 단일 항목 만 사용하는 경우 포함 된 항목의 암시 적 크기에 맞게 크기가 조정됩니다. 따라서 레이아웃과 함께 사용하기에 특히 적합합니다.</target>
        </trans-unit>
        <trans-unit id="e2df0a56e18e809ae86761f53b7173055d4d8a1f" translate="yes" xml:space="preserve">
          <source>If only a single item is used within a Popup, it will resize to fit the implicit size of its contained item. This makes it particularly suitable for use together with layouts.</source>
          <target state="translated">팝업 내에서 단일 항목 만 사용하는 경우 포함 된 항목의 암시 적 크기에 맞게 크기가 조정됩니다. 따라서 레이아웃과 함께 사용하기에 특히 적합합니다.</target>
        </trans-unit>
        <trans-unit id="c8d7517964769751b54c3ff884dc7f5075e6064e" translate="yes" xml:space="preserve">
          <source>If only a single item is used within the &lt;a href=&quot;qml-qtquick-controls-statusbar&quot;&gt;StatusBar&lt;/a&gt;, it will resize to fit the implicitHeight of its contained item. This makes it particularly suitable for use together with layouts. Otherwise the height is platform dependent.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-statusbar&quot;&gt;StatusBar&lt;/a&gt; 내에서 단일 항목 만 사용하는 경우 포함 된 항목의 암시 적 높이에 맞게 크기가 조정됩니다. 따라서 레이아웃과 함께 사용하기에 특히 적합합니다. 그렇지 않으면 높이는 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="cf67a2a9561fecfdf3e91bda5c2fea61a40ebf86" translate="yes" xml:space="preserve">
          <source>If only a single item is used within the &lt;a href=&quot;qml-qtquick-controls-toolbar&quot;&gt;ToolBar&lt;/a&gt;, it will resize to fit the implicitHeight of its contained item. This makes it particularly suitable for use together with layouts. Otherwise the height is platform dependent.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-toolbar&quot;&gt;툴바&lt;/a&gt; 내에서 단일 항목 만 사용하는 경우 포함 된 항목의 암시 적 높이에 맞게 크기가 조정됩니다. 따라서 레이아웃과 함께 사용하기에 특히 적합합니다. 그렇지 않으면 높이는 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="323c527cece11c02ea8dd53543e158120ff1df00" translate="yes" xml:space="preserve">
          <source>If only one section is inserted,</source>
          <target state="translated">섹션이 하나만 삽입되면</target>
        </trans-unit>
        <trans-unit id="d7b9b3e0b2029af0483d8907528178c6c98fbb2f" translate="yes" xml:space="preserve">
          <source>If only one section is removed,</source>
          <target state="translated">섹션이 하나만 제거되면</target>
        </trans-unit>
        <trans-unit id="c58f42e356324ba5cc7a7389268e7be91c802f52" translate="yes" xml:space="preserve">
          <source>If only the place identifier is known, all other place data can fetched from the &lt;a href=&quot;location-places-qml#plugin&quot;&gt;Plugin&lt;/a&gt;.</source>
          <target state="translated">장소 식별자 만 알고 있으면 다른 모든 장소 데이터를 &lt;a href=&quot;location-places-qml#plugin&quot;&gt;플러그인&lt;/a&gt; 에서 가져올 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="c37b870bd6ea11da332a0c9bd35b6b32e4dc0078" translate="yes" xml:space="preserve">
          <source>If only unsupported language codes are specified via the &lt;a href=&quot;http://doc.qt.io/qt-5/qml-qtlocation-plugin.html#locales-prop&quot;&gt;locales&lt;/a&gt; property, the service returns the directions using the default language, English.</source>
          <target state="translated">&lt;a href=&quot;http://doc.qt.io/qt-5/qml-qtlocation-plugin.html#locales-prop&quot;&gt;locales&lt;/a&gt; 속성을 통해 지원되지 않는 언어 코드 만 지정된 경우 서비스는 기본 언어 인 영어를 사용하여 길 찾기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="769722f9601699f802700b4649bdda2d308f5b16" translate="yes" xml:space="preserve">
          <source>If other instances of &lt;a href=&quot;qlibrary&quot;&gt;QLibrary&lt;/a&gt; are using the same library, the call will fail, and unloading will only happen when every instance has called unload().</source>
          <target state="translated">&lt;a href=&quot;qlibrary&quot;&gt;QLibrary의&lt;/a&gt; 다른 인스턴스가 동일한 라이브러리를 사용하는 경우 호출이 실패하며 언로드는 모든 인스턴스가 unload ()를 호출 한 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bfac0fa7e1f9e6176a36ff3a47bb6cf046314d48" translate="yes" xml:space="preserve">
          <source>If other instances of &lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader&lt;/a&gt; are using the same plugin, the call will fail, and unloading will only happen when every instance has called unload().</source>
          <target state="translated">&lt;a href=&quot;qpluginloader&quot;&gt;QPluginLoader의&lt;/a&gt; 다른 인스턴스가 동일한 플러그인을 사용하는 경우 호출이 실패하며 언로드는 모든 인스턴스가 unload ()를 호출 한 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2eaca306b04b6485f56092c13d1d5ec062f18bfa" translate="yes" xml:space="preserve">
          <source>If parameter</source>
          <target state="translated">파라미터</target>
        </trans-unit>
        <trans-unit id="ae67662e6ff0995f09c95b721a33f7b1ac244ef6" translate="yes" xml:space="preserve">
          <source>If parsing is successful, the returned state machine can be initialized and started. If parsing fails, &lt;a href=&quot;qscxmlstatemachine#parseErrors-prop&quot;&gt;QScxmlStateMachine::parseErrors&lt;/a&gt;() can be used to retrieve a list of errors.</source>
          <target state="translated">구문 분석에 성공하면 반환 된 상태 시스템을 초기화하고 시작할 수 있습니다. 구문 분석에 실패하면 &lt;a href=&quot;qscxmlstatemachine#parseErrors-prop&quot;&gt;QScxmlStateMachine :: parseErrors&lt;/a&gt; ()를 사용하여 오류 목록을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1aabd552d35d3fde6b2dba8047aa480a76a0509" translate="yes" xml:space="preserve">
          <source>If paused is set to true, the particle system will not advance the simulation. When paused is set to false again, the simulation will resume from the same point it was paused.</source>
          <target state="translated">paused가 true로 설정되면 파티클 시스템은 시뮬레이션을 진행하지 않습니다. 일시 정지가 다시 거짓으로 설정되면 시뮬레이션은 일시 정지 된 지점에서 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="c8a13b5e6b870a928faaa5518ccf57903002bfec" translate="yes" xml:space="preserve">
          <source>If peer verification errors were ignored during the handshake, resumeHandshake() resumes and completes the handshake and returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">핸드 셰이크 중에 피어 검증 오류가 무시 된 경우 resumeHandshake ()는 핸드 셰이크를 재개하고 완료하고 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="755ea1ac99c8486c7fe196940e388748df2ce0c8" translate="yes" xml:space="preserve">
          <source>If plugins are built in a mode that is incompatible with</source>
          <target state="translated">플러그인이 호환되지 않는 모드로 빌드 된 경우</target>
        </trans-unit>
        <trans-unit id="82d3139f3aed8a1e9da4af07509cbfeae1963b0f" translate="yes" xml:space="preserve">
          <source>If positioning the</source>
          <target state="translated">포지셔닝</target>
        </trans-unit>
        <trans-unit id="59019c5a14a724419b846b35b476276f223d595e" translate="yes" xml:space="preserve">
          <source>If positioning the view at</source>
          <target state="translated">뷰를</target>
        </trans-unit>
        <trans-unit id="80c868afc8c0e32b440f61349507605f514b0349" translate="yes" xml:space="preserve">
          <source>If positioning the view at the index would cause empty space to be displayed at the beginning or end of the view, the view will be positioned at the boundary.</source>
          <target state="translated">뷰를 인덱스에 배치하면 뷰의 시작 또는 끝에 빈 공간이 표시되어 뷰가 경계에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="7a8faf58d6c550fa30b8db81afc2658f3e487ebf" translate="yes" xml:space="preserve">
          <source>If possible, &lt;a href=&quot;qml-qtmultimedia-camera#cameraState-prop&quot;&gt;cameraState&lt;/a&gt;, &lt;a href=&quot;qml-qtmultimedia-camera#captureMode-prop&quot;&gt;captureMode&lt;/a&gt;, &lt;a href=&quot;qml-qtmultimedia-camera#digitalZoom-prop&quot;&gt;digitalZoom&lt;/a&gt; and other camera parameters are preserved when changing the camera device.</source>
          <target state="translated">가능한 경우 &lt;a href=&quot;qml-qtmultimedia-camera#cameraState-prop&quot;&gt;cameraState&lt;/a&gt; , &lt;a href=&quot;qml-qtmultimedia-camera#captureMode-prop&quot;&gt;captureMode&lt;/a&gt; , &lt;a href=&quot;qml-qtmultimedia-camera#digitalZoom-prop&quot;&gt;digitalZoom&lt;/a&gt; 카메라 장치를 변경할 때 및 기타 카메라 매개 변수가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f98ee6841e4c9e89efaf68a7c0578e96b517a759" translate="yes" xml:space="preserve">
          <source>If possible, render text with hinting in both horizontal and vertical directions. The text will be altered to optimize legibility on the target device, but since the metrics will depend on the target size of the text, the positions of glyphs, line breaks, and other typographical detail will not scale, meaning that a text layout may look different on devices with different pixel densities.</source>
          <target state="translated">가능하면 텍스트를 가로 및 세로 방향으로 힌트로 렌더링하십시오. 대상 장치에서 가독성을 최적화하기 위해 텍스트가 변경되지만 메트릭은 텍스트의 대상 크기에 따라 달라 지므로 글리프, 줄 바꿈 및 기타 인쇄상의 세부 사항의 위치가 조정되지 않으므로 텍스트 레이아웃이 표시 될 수 있습니다. 픽셀 밀도가 다른 장치에서는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="83478c5c2d7924b549cefce719673469c74d4ed9" translate="yes" xml:space="preserve">
          <source>If possible, render text with no horizontal hinting, but align glyphs to the pixel grid in the vertical direction. The text will appear crisper on displays where the density is too low to give an accurate rendering of the glyphs. But since the horizontal metrics of the glyphs are unhinted, the text's layout will be scalable to higher density devices (such as printers) without impacting details such as line breaks.</source>
          <target state="translated">가능하면 가로 힌트없이 텍스트를 렌더링하되 그림 문자를 세로 방향으로 픽셀 격자에 맞 춥니 다. 밀도가 너무 낮아 글리프를 정확하게 렌더링 할 수없는 디스플레이에서는 텍스트가보다 선명하게 나타납니다. 그러나 글리프의 가로 메트릭을 사용하지 않기 때문에 줄 바꿈과 같은 세부 사항에 영향을주지 않고 텍스트 레이아웃을 프린터와 같은 고밀도 장치로 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9c32fb553c26aa279350badfc687bcc195f1685" translate="yes" xml:space="preserve">
          <source>If possible, render text without hinting the outlines of the glyphs. The text layout will be typographically accurate and scalable, using the same metrics as are used e.g. when printing.</source>
          <target state="translated">가능하면 글리프의 윤곽을 암시하지 않고 텍스트를 렌더링하십시오. 인쇄시 사용되는 것과 동일한 메트릭을 사용하여 텍스트 레이아웃이 인쇄 상 정확하고 확장 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f5e605d4852173dfb4d7968663feaa31d1776ab0" translate="yes" xml:space="preserve">
          <source>If possible, the device is truncated before it is opened. All earlier contents of the device are lost.</source>
          <target state="translated">가능하면 장치를 열기 전에 잘립니다. 장치의 모든 이전 내용이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="2739d0458fbd024b5ac2887503cfa400e89e82e8" translate="yes" xml:space="preserve">
          <source>If possible, use the &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; operator instead.</source>
          <target state="translated">가능하면 &lt;a href=&quot;qbytearray&quot;&gt;QByteArray&lt;/a&gt; 연산자를 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ec84b8c5d311b21ed5dbceda28479ca952bb7359" translate="yes" xml:space="preserve">
          <source>If possible, wrapping occurs at a word boundary; otherwise it will occur at the appropriate point on the line, even in the middle of a word.</source>
          <target state="translated">가능하면 단어 경계에서 줄 바꿈이 발생합니다. 그렇지 않으면 그것은 단어의 중간에도 라인의 적절한 지점에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1eee6cc1a4c6fb1521132b2be7e7f957a00b735c" translate="yes" xml:space="preserve">
          <source>If precision is not specified, the precision will be 2.</source>
          <target state="translated">정밀도를 지정하지 않으면 정밀도는 2가됩니다.</target>
        </trans-unit>
        <trans-unit id="bf5a5a1145b81cfaa6d6927e187339576a3cc606" translate="yes" xml:space="preserve">
          <source>If present() fails for any other reason the surface should immediately enter the stopped state and an &lt;a href=&quot;qabstractvideosurface#error&quot;&gt;error&lt;/a&gt;() value will be set.</source>
          <target state="translated">다른 이유로 present ()가 실패하면 표면이 즉시 정지 상태로 들어가야하며 &lt;a href=&quot;qabstractvideosurface#error&quot;&gt;오류&lt;/a&gt; () 값이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7f26abb8c4ebc9a709d55a0e5b46569e5bd38f78" translate="yes" xml:space="preserve">
          <source>If priority is Keys.AfterItem the order of key event processing is:</source>
          <target state="translated">우선 순위가 Keys.AfterItem 인 경우 키 이벤트 처리 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="53b04bee3e304035ae41bdfe29a84a3772127960" translate="yes" xml:space="preserve">
          <source>If propagateComposedEvents is set to true, then composed events will be automatically propagated to other MouseAreas in the same location in the scene. Each event is propagated to the next &lt;a href=&quot;qml-qtquick-mousearea#enabled-prop&quot;&gt;enabled&lt;/a&gt;&lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; beneath it in the stacking order, propagating down this visual hierarchy until a &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; accepts the event. Unlike &lt;code&gt;pressed&lt;/code&gt; events, composed events will not be automatically accepted if no handler is present.</source>
          <target state="translated">propagateComposedEvents가 true로 설정되면 작성된 이벤트가 장면의 같은 위치에있는 다른 MouseArea로 자동 전파됩니다. 각 이벤트는 다음 번 &lt;a href=&quot;qml-qtquick-mousearea#enabled-prop&quot;&gt;활성화 된 &lt;/a&gt;&lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; 아래에 쌓인 순서대로 전파되어 &lt;a href=&quot;qml-qtquick-mousearea&quot;&gt;MouseArea&lt;/a&gt; 가 이벤트를 승인 할 때까지이 시각적 계층 구조를 아래로 전파합니다 . &lt;code&gt;pressed&lt;/code&gt; 이벤트 와 달리 핸들러가 없으면 작성된 이벤트가 자동으로 승인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d0b981797d329646f6e7968989ce5627028d285" translate="yes" xml:space="preserve">
          <source>If qdoc is generating DITA XML, it will translate the commands to:</source>
          <target state="translated">qdoc이 DITA XML을 생성하는 경우 명령을 다음으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="da6e5847d4901b78305d2c4043cc5bf6557c5a54" translate="yes" xml:space="preserve">
          <source>If qdoc is generating HTML, it will translate these commands to:</source>
          <target state="translated">qdoc이 HTML을 생성하는 경우 다음 명령을 다음과 같이 변환합니다.</target>
        </trans-unit>
        <trans-unit id="6b0d3d91344c0633c387c3b0074725c4f1ff3f52" translate="yes" xml:space="preserve">
          <source>If qmake finds a &lt;code&gt;.qmake.cache&lt;/code&gt; file then it will process this file first before it processes the project file.</source>
          <target state="translated">qmake가 &lt;code&gt;.qmake.cache&lt;/code&gt; 파일을 찾으면 프로젝트 파일을 처리하기 전에이 파일을 먼저 처리합니다.</target>
        </trans-unit>
        <trans-unit id="f9f2bdb672595047c5aea8cdda7ba0191f6f857c" translate="yes" xml:space="preserve">
          <source>If radius is non-zero, the rectangle will be painted as a rounded rectangle, otherwise it will be painted as a normal rectangle. The same radius is used by all 4 corners; there is currently no way to specify different radii for different corners.</source>
          <target state="translated">반지름이 0이 아닌 경우 사각형은 둥근 사각형으로 표시되고, 그렇지 않으면 일반 사각형으로 표시됩니다. 4 개의 모퉁이에서 동일한 반지름이 사용됩니다. 현재 모서리마다 다른 반지름을 지정할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8c74a0ca8669c7c23d60d2ae89eecfbd3c64b6bf" translate="yes" xml:space="preserve">
          <source>If readOnly is set to &lt;code&gt;true&lt;/code&gt;, then user input will not affect the text. Any bindings or attempts to set the text property will still work, however.</source>
          <target state="translated">readOnly가 &lt;code&gt;true&lt;/code&gt; 로 설정된 경우 사용자 입력은 텍스트에 영향을 미치지 않습니다. 그러나 text 속성을 설정하거나 바인딩하려고해도 여전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="89ffe998d5401488f95b84ced54bf376e09caa94" translate="yes" xml:space="preserve">
          <source>If readOnly is set to true, then user input will not affect the text property. Any bindings or attempts to set the text property will still work.</source>
          <target state="translated">readOnly가 true로 설정되면 사용자 입력은 텍스트 특성에 영향을 미치지 않습니다. 텍스트 속성을 설정하거나 바인딩하려고해도 여전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="491aafe41b2d0588b14f233e69022e66cf999e92" translate="yes" xml:space="preserve">
          <source>If recording fails &lt;a href=&quot;qmediarecorder#error&quot;&gt;error&lt;/a&gt;() signal is emitted with recorder state being reset back to &lt;a href=&quot;qmediarecorder#State-enum&quot;&gt;QMediaRecorder::StoppedState&lt;/a&gt;.</source>
          <target state="translated">레코딩에 실패하면 레코더 상태가 &lt;a href=&quot;qmediarecorder#State-enum&quot;&gt;QMediaRecorder :: StoppedState&lt;/a&gt; 로 다시 설정되어 &lt;a href=&quot;qmediarecorder#error&quot;&gt;오류&lt;/a&gt; () 신호가 발생합니다. 합니다.</target>
        </trans-unit>
        <trans-unit id="b0b096a2577f54e614bb8ad4ad8d6a6a851c8221" translate="yes" xml:space="preserve">
          <source>If regular position updates are required, &lt;a href=&quot;qgeopositioninfosource#updateInterval-prop&quot;&gt;setUpdateInterval&lt;/a&gt;() can be used to specify how often these updates should be emitted. If no interval is specified, updates are simply provided whenever they are available. For example:</source>
          <target state="translated">정기적 인 위치 업데이트가 필요한 경우 &lt;a href=&quot;qgeopositioninfosource#updateInterval-prop&quot;&gt;setUpdateInterval&lt;/a&gt; ()을 사용하여 업데이트가 얼마나 자주 발생하는지 지정할 수 있습니다. 간격을 지정하지 않으면 업데이트가 제공 될 때마다 업데이트가 제공됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="353d0d2a6185e0e7422c4e97b8967d36e8628619" translate="yes" xml:space="preserve">
          <source>If regular satellite updates are required, &lt;a href=&quot;qgeosatelliteinfosource#updateInterval-prop&quot;&gt;setUpdateInterval&lt;/a&gt;() can be used to specify how often these updates should be emitted. If no interval is specified, updates are simply provided whenever they are available. For example:</source>
          <target state="translated">정기적 인 위성 업데이트가 필요한 경우 &lt;a href=&quot;qgeosatelliteinfosource#updateInterval-prop&quot;&gt;setUpdateInterval&lt;/a&gt; ()을 사용하여 업데이트가 얼마나 자주 발생하는지 지정할 수 있습니다. 간격을 지정하지 않으면 업데이트가 제공 될 때마다 업데이트가 제공됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3410cb0a8f63075c7d6e7f87786a291f479889c7" translate="yes" xml:space="preserve">
          <source>If rendering is shut down before</source>
          <target state="translated">렌더링이 전에 종료 된 경우</target>
        </trans-unit>
        <trans-unit id="f7c738a02680ae2b62935b8f53ad005ffd388830" translate="yes" xml:space="preserve">
          <source>If reply-&amp;gt;&lt;a href=&quot;qplacemanager#error&quot;&gt;error&lt;/a&gt;() equals &lt;a href=&quot;qplacereply#Error-enum&quot;&gt;QPlaceReply::NoError&lt;/a&gt; then the processing finished successfully.</source>
          <target state="translated">&lt;a href=&quot;qplacereply#Error-enum&quot;&gt;reply-&lt;/a&gt; &amp;gt; &lt;a href=&quot;qplacemanager#error&quot;&gt;error&lt;/a&gt; ()가 QPlaceReply :: NoError 와 같으면 처리가 성공적으로 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="123d756821a2cacc090586fb4c5069e7394150db" translate="yes" xml:space="preserve">
          <source>If reply-&amp;gt;&lt;a href=&quot;qplacemanagerengine#error&quot;&gt;error&lt;/a&gt;() equals &lt;a href=&quot;qplacereply#Error-enum&quot;&gt;QPlaceReply::NoError&lt;/a&gt; then the processing finished successfully.</source>
          <target state="translated">&lt;a href=&quot;qplacereply#Error-enum&quot;&gt;reply-&lt;/a&gt; &amp;gt; &lt;a href=&quot;qplacemanagerengine#error&quot;&gt;error&lt;/a&gt; ()가 QPlaceReply :: NoError 와 같으면 처리가 성공적으로 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="cb90b249c982b5d3eb9bae15d10caec2cb6f0152" translate="yes" xml:space="preserve">
          <source>If reply::error() equals &lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply::NoError&lt;/a&gt; then the processing finished successfully.</source>
          <target state="translated">reply :: error ()가 &lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply :: NoError&lt;/a&gt; 와 같으면 처리가 성공적으로 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="8d3131c0ad3396002f56d2c49836a556851c61ef" translate="yes" xml:space="preserve">
          <source>If reply::error() equals &lt;a href=&quot;qgeoroutereply#Error-enum&quot;&gt;QGeoRouteReply::NoError&lt;/a&gt; then the processing finished successfully.</source>
          <target state="translated">reply :: error ()가 &lt;a href=&quot;qgeoroutereply#Error-enum&quot;&gt;QGeoRouteReply :: NoError&lt;/a&gt; 와 같으면 처리가 성공적으로 완료된 것입니다.</target>
        </trans-unit>
        <trans-unit id="b7e4ba0dbeb916b86b3aeb37c8191d47dbd732b5" translate="yes" xml:space="preserve">
          <source>If rotation or shearing has been specified, this function returns the</source>
          <target state="translated">회전 또는 전단이 지정된 경우이 함수는</target>
        </trans-unit>
        <trans-unit id="ba97c915fb65a3fe65059e25aa2e946f5e87415e" translate="yes" xml:space="preserve">
          <source>If row &amp;lt; 0 or row + count &amp;gt; &lt;a href=&quot;qsqltablemodel#rowCount&quot;&gt;rowCount&lt;/a&gt;(), no action is taken and false is returned. Returns &lt;code&gt;true&lt;/code&gt; if all rows could be removed; otherwise returns &lt;code&gt;false&lt;/code&gt;. Detailed database error information can be retrieved using &lt;a href=&quot;qsqlquerymodel#lastError&quot;&gt;lastError&lt;/a&gt;().</source>
          <target state="translated">row &amp;lt;0 또는 row + count&amp;gt; &lt;a href=&quot;qsqltablemodel#rowCount&quot;&gt;rowCount&lt;/a&gt; ()이면 조치가 수행되지 않고 false가 리턴됩니다. 모든 행을 제거 할 수 있으면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . &lt;a href=&quot;qsqlquerymodel#lastError&quot;&gt;lastError&lt;/a&gt; ()를 사용하여 자세한 데이터베이스 오류 정보를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81108c72da3e4b331da76840b63c1025aea3d7ce" translate="yes" xml:space="preserve">
          <source>If rows are inserted into the array without calling &lt;a href=&quot;qbardataproxy#insertRow&quot;&gt;insertRow&lt;/a&gt;() or &lt;a href=&quot;qbardataproxy#insertRows&quot;&gt;insertRows&lt;/a&gt;(), this signal needs to be emitted to update the graph.</source>
          <target state="translated">&lt;a href=&quot;qbardataproxy#insertRow&quot;&gt;insertRow&lt;/a&gt; () 또는 &lt;a href=&quot;qbardataproxy#insertRows&quot;&gt;insertRows&lt;/a&gt; () 를 호출하지 않고 행을 배열에 삽입 하면 그래프를 업데이트하기 위해이 신호를 내 보내야 합니다.</target>
        </trans-unit>
        <trans-unit id="ca9a1f18b52b2b1cf87ec82bf41ccb3834fe61c0" translate="yes" xml:space="preserve">
          <source>If rows are inserted into the array without calling &lt;a href=&quot;qsurfacedataproxy#insertRow&quot;&gt;insertRow&lt;/a&gt;() or &lt;a href=&quot;qsurfacedataproxy#insertRows&quot;&gt;insertRows&lt;/a&gt;(), this signal needs to be emitted to update the graph.</source>
          <target state="translated">&lt;a href=&quot;qsurfacedataproxy#insertRow&quot;&gt;insertRow&lt;/a&gt; () 또는 &lt;a href=&quot;qsurfacedataproxy#insertRows&quot;&gt;insertRows&lt;/a&gt; () 를 호출하지 않고 행을 배열에 삽입 하면 그래프를 업데이트하기 위해이 신호를 내 보내야 합니다.</target>
        </trans-unit>
        <trans-unit id="9d4d30aea01d4a3159a668c035949c4e13d63e32" translate="yes" xml:space="preserve">
          <source>If running is set to false, the particle system will stop the simulation. All particles will be destroyed when the system is set to running again.</source>
          <target state="translated">running이 false로 설정되면 파티클 시스템은 시뮬레이션을 중지합니다. 시스템이 다시 실행되도록 설정되면 모든 입자가 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="1f8ae8efed68894c5c678e21ea95533a8b7278e3" translate="yes" xml:space="preserve">
          <source>If satellite information cannot be retrieved or some other form of timeout has occurred the &lt;a href=&quot;qgeosatelliteinfosource#satellitesInViewUpdated&quot;&gt;satellitesInViewUpdated&lt;/a&gt;() and &lt;a href=&quot;qgeosatelliteinfosource#satellitesInUseUpdated&quot;&gt;satellitesInUseUpdated&lt;/a&gt;() signals may be emitted with empty parameter lists.</source>
          <target state="translated">위성 정보를 검색 할 수 없거나 다른 형식의 시간 초과가 발생한 경우 &lt;a href=&quot;qgeosatelliteinfosource#satellitesInViewUpdated&quot;&gt;satellitesInViewUpdated&lt;/a&gt; () 및 &lt;a href=&quot;qgeosatelliteinfosource#satellitesInUseUpdated&quot;&gt;satellitesInUseUpdated&lt;/a&gt; () 신호가 빈 매개 변수 목록과 함께 방출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca82fb2bb4a13d8fd39931a1339ebb694d2d2993" translate="yes" xml:space="preserve">
          <source>If seeking is supported this property will be true; false otherwise. The status of this property may change across the life time of the &lt;a href=&quot;qmediaplayer&quot;&gt;QMediaPlayer&lt;/a&gt; object, use the &lt;a href=&quot;qmediaplayer#seekableChanged&quot;&gt;seekableChanged&lt;/a&gt; signal to monitor changes.</source>
          <target state="translated">탐색이 지원되는 경우이 속성은 true입니다. 그렇지 않으면 거짓. 이 속성의 상태는의 수명에 걸쳐 변경 될 수 있습니다 &lt;a href=&quot;qmediaplayer&quot;&gt;QMediaPlayer의&lt;/a&gt; 객체를 사용 &lt;a href=&quot;qmediaplayer#seekableChanged&quot;&gt;seekableChanged&lt;/a&gt; 모니터 변화에 신호를.</target>
        </trans-unit>
        <trans-unit id="bc90bed076157c060b2c458bf3a07fcf698982c5" translate="yes" xml:space="preserve">
          <source>If selectedDate is outside the range of &lt;a href=&quot;qml-qtquick-controls-calendar#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-controls-calendar#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt;, it will be clamped to be within that range.</source>
          <target state="translated">selectedDate가 &lt;a href=&quot;qml-qtquick-controls-calendar#minimumDate-prop&quot;&gt;minimumDate&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-controls-calendar#maximumDate-prop&quot;&gt;maximumDate&lt;/a&gt; 범위를 벗어나면 해당 범위 내에 있도록 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="80dfb2c4c1663bf22f8c79474e00bdc6eef78f39" translate="yes" xml:space="preserve">
          <source>If set explicitly the canvas will attempt to create a context of the named type after becoming available.</source>
          <target state="translated">명시 적으로 설정하면 캔버스는 사용 가능 해지면 이름이 지정된 유형의 컨텍스트를 작성하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="ab9deefa6e4193e6947a7b86a7c3af1d85db5420" translate="yes" xml:space="preserve">
          <source>If set particles will rotate at this velocity in degrees/second.</source>
          <target state="translated">설정된 파티클이이 속도로도 / 초로 회전합니다.</target>
        </trans-unit>
        <trans-unit id="bd5d8fad0db9447ea396f260226dbe80f1651d11" translate="yes" xml:space="preserve">
          <source>If set prior to populating the combo box, the pop-up view will not be affected and will show the first column (using this property's default value).</source>
          <target state="translated">콤보 상자를 채우기 전에 설정된 경우 팝업보기에는 영향을 미치지 않으며 첫 번째 열이 표시됩니다 (이 속성의 기본값 사용).</target>
        </trans-unit>
        <trans-unit id="37e9b9511a10912d7ce57f9ca5c6eadd0037defc" translate="yes" xml:space="preserve">
          <source>If set the &lt;a href=&quot;qml-qtquick-particles-imageparticle#rotationVelocity-prop&quot;&gt;rotationVelocity&lt;/a&gt; of individual particles will vary by up to this much between particles.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-particles-imageparticle#rotationVelocity-prop&quot;&gt;회전&lt;/a&gt; 을 설정하면 개별 파티클의 속도가 파티클 사이에서 최대만큼 달라집니다.</target>
        </trans-unit>
        <trans-unit id="8820a00c19aabb86211a86fb06e6883847078722" translate="yes" xml:space="preserve">
          <source>If set the image will be rotated by this many degrees before it is drawn.</source>
          <target state="translated">설정하면 이미지가 그려지기 전에이 각도만큼 회전됩니다.</target>
        </trans-unit>
        <trans-unit id="3f61f218054deafcf41be67e73ad6e9bf8cbc7fd" translate="yes" xml:space="preserve">
          <source>If set the rotation of individual particles will vary by up to this much between particles.</source>
          <target state="translated">설정하면 개별 입자의 회전이 입자마다 최대만큼 달라집니다.</target>
        </trans-unit>
        <trans-unit id="32259054dd21d2715beb1c106aa278bc6e0958c5" translate="yes" xml:space="preserve">
          <source>If set to 0, the dialog is always shown as soon as any progress is set. The default is 4000 milliseconds.</source>
          <target state="translated">0으로 설정하면 진행률이 설정되는 즉시 대화 상자가 표시됩니다. 기본값은 4000 밀리 초입니다.</target>
        </trans-unit>
        <trans-unit id="6aaee82f952166423472261967aacd5cf25ceb71" translate="yes" xml:space="preserve">
          <source>If set to &lt;a href=&quot;qt3danimation-qabstractclipanimator#Loops-enum&quot;&gt;QAbstractClipAnimator::Infinite&lt;/a&gt;, the animation will continuously repeat until it is explicitly stopped.</source>
          <target state="translated">&lt;a href=&quot;qt3danimation-qabstractclipanimator#Loops-enum&quot;&gt;QAbstractClipAnimator :: Infinite로&lt;/a&gt; 설정 하면 애니메이션이 명시 적으로 중지 될 때까지 계속 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="85e1a99124331495be0e5433168e6fc3e8a6ad3c" translate="yes" xml:space="preserve">
          <source>If set to &lt;a href=&quot;qt3drender-qabstractraycaster#RunMode-enum&quot;&gt;SingleShot&lt;/a&gt; (the default), when the component is enabled, a single ray casting test will be performed and the component will automatically disable itself.</source>
          <target state="translated">로 설정하면 &lt;a href=&quot;qt3drender-qabstractraycaster#RunMode-enum&quot;&gt;SINGLESHOT&lt;/a&gt; 구성 요소를 사용하는 경우 (기본값)은, 하나의 레이 캐스팅 테스트가 수행 될 구성 요소 자체가 자동으로 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="5ecbe55adfc88b8354fa193af0ed9f8406df2016" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;false&lt;/code&gt;, &lt;a href=&quot;qcustom3dlabel#backgroundColor-prop&quot;&gt;backgroundColor&lt;/a&gt;() has no effect. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">로 설정하면 &lt;code&gt;false&lt;/code&gt; , &lt;a href=&quot;qcustom3dlabel#backgroundColor-prop&quot;&gt;backgroundColor로는&lt;/a&gt; () 영향을주지 않습니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ab64c3b336ee31f65b5d1fea70a0cd4dc8842b80" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, &lt;a href=&quot;q3dbars#barSpacing-prop&quot;&gt;bar spacing&lt;/a&gt; will be correctly applied only to the X-axis. Preset to &lt;code&gt;false&lt;/code&gt; by default.</source>
          <target state="translated">로 설정하면 &lt;code&gt;true&lt;/code&gt; , &lt;a href=&quot;q3dbars#barSpacing-prop&quot;&gt;줄 간격은&lt;/a&gt; 제대로 만 X 축에 적용됩니다. 기본적 으로 &lt;code&gt;false&lt;/code&gt; 로 사전 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="38aa8cb490ec8909d67b7df03b16a3a91d055a09" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, the X-rotation of the camera is wrapped from minimum to maximum and from maximum to minimum. If set to &lt;code&gt;false&lt;/code&gt;, the X-rotation of the camera is limited to the sector determined by the minimum and maximum values.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 카메라의 X 회전이 최소에서 최대로, 최대에서 최소로 줄 바꿈됩니다. &lt;code&gt;false&lt;/code&gt; 로 설정 하면 카메라의 X 회전이 최소값과 최대 값으로 결정된 섹터로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="c051d84601a7ccd1ed6264764a3aefa5e8bb1077" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, the X-rotation of the camera is wrapped from minimum to maximum and from maximum to minimum. If set to &lt;code&gt;false&lt;/code&gt;, the X-rotation of the camera is limited to the sector determined by the minimum and maximum values. Set to &lt;code&gt;true&lt;/code&gt; by default.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 카메라의 X 회전이 최소에서 최대로, 최대에서 최소로 줄 바꿈됩니다. &lt;code&gt;false&lt;/code&gt; 로 설정 하면 카메라의 X 회전이 최소값과 최대 값으로 결정된 섹터로 제한됩니다. 기본적 으로 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="6b3e6c2ecf8fc80fd4705d15c6457b4f24c1148d" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, the background drop shadow effect is enabled. If set to &lt;code&gt;false&lt;/code&gt;, it is disabled.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 배경 그림자 효과가 활성화됩니다. &lt;code&gt;false&lt;/code&gt; 로 설정하면 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="00ad34efa5e3fe7097993cd715043e0271335f81" translate="yes" xml:space="preserve">
          <source>If set to &lt;code&gt;true&lt;/code&gt;, the user can use the keyboard to select the text even if the editor is read-only. If set to &lt;code&gt;false&lt;/code&gt;, the user cannot use the keyboard to select the text even if the editor is editable.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 편집기가 읽기 전용 인 경우에도 키보드를 사용하여 텍스트를 선택할 수 있습니다. &lt;code&gt;false&lt;/code&gt; 로 설정 하면 편집기를 편집 할 수있는 경우에도 키보드를 사용하여 텍스트를 선택할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="447481b63ae0494a6401f0ffb02f2f2f91a57a2f" translate="yes" xml:space="preserve">
          <source>If set to Animation.Infinite, the animation will continuously repeat until it is explicitly stopped - either by setting the &lt;code&gt;running&lt;/code&gt; property to false, or by calling the &lt;code&gt;stop()&lt;/code&gt; method.</source>
          <target state="translated">Animation.Infinite로 설정하면 &lt;code&gt;running&lt;/code&gt; 속성을 false 로 설정 하거나 &lt;code&gt;stop()&lt;/code&gt; 메서드를 호출하여 명시 적으로 중지 될 때까지 애니메이션이 계속 반복됩니다 .</target>
        </trans-unit>
        <trans-unit id="96b3b82d9351aa9c6834e55578c5d931fbb990dc" translate="yes" xml:space="preserve">
          <source>If set to Continuous, Compute command is executed everyframe. This is the default.</source>
          <target state="translated">연속으로 설정하면 계산 명령이 매 프레임마다 실행됩니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="6ada91d7208bf8ab4ad0f4c17abf13d090d41639" translate="yes" xml:space="preserve">
          <source>If set to Continuous, ray casting tests will be performed at every frame as long as the component is enabled.</source>
          <target state="translated">연속으로 설정하면 구성 요소가 활성화되어있는 한 모든 프레임에서 광선 주조 테스트가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="0a54094a494d3a0270f9f54d1e149514e3b9eff3" translate="yes" xml:space="preserve">
          <source>If set to Manual CompouteCommand is executed for a given number of frames and then the component disables itself.</source>
          <target state="translated">수동 CompouteCommand로 설정하면 주어진 수의 프레임에 대해 실행되고 구성 요소 자체가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="91bbcc50f09ad26c5bcc4353bdea863a2bd207e1" translate="yes" xml:space="preserve">
          <source>If set to NaN, this value will not be considered.</source>
          <target state="translated">NaN으로 설정하면이 값이 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d01121a2691e5c689f8195afcee2944f9d0dd21d" translate="yes" xml:space="preserve">
          <source>If set to QAbstractClipAnimator::Infinite, the animation will continuously repeat until it is explicitly stopped.</source>
          <target state="translated">QAbstractClipAnimator :: Infinite로 설정하면 애니메이션이 명시 적으로 중지 될 때까지 계속 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="bc5c75f1ab020242f68c777560bd68045a5e7911" translate="yes" xml:space="preserve">
          <source>If set to an empty string, the default path is restored.</source>
          <target state="translated">빈 문자열로 설정하면 기본 경로가 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="ea1e8f9e1f8a1375706046653e2fd7bc26c58192" translate="yes" xml:space="preserve">
          <source>If set to false, the emitter will cease emissions until it is set to true.</source>
          <target state="translated">false로 설정하면 이미 터는 true로 설정 될 때까지 방출을 중단합니다.</target>
        </trans-unit>
        <trans-unit id="0f4050f5b477c250974b1d4a63dc3ebfb0715e07" translate="yes" xml:space="preserve">
          <source>If set to null, no connection is made and any signal handlers are ignored until the target is not null.</source>
          <target state="translated">널로 설정되면, 연결이 작성되지 않으며 대상이 널이 될 때까지 신호 핸들러가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="66faa6bf806755b6fcb3a39de9e0ffa78434c45c" translate="yes" xml:space="preserve">
          <source>If set to the null string, the default path is restored.</source>
          <target state="translated">널 문자열로 설정하면 기본 경로가 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="ee4d1ee8b2c0f440ab18bcb15419f035818e6cff" translate="yes" xml:space="preserve">
          <source>If set to true then a rotation will be applied on top of the particles rotation, so that it faces the direction of travel. So to face away from the direction of travel, set autoRotation to true and rotation to 180.</source>
          <target state="translated">true로 설정하면 이동 방향을 향하도록 입자 회전 위에 회전이 적용됩니다. 따라서 이동 방향에서 멀어지게하려면 autoRotation을 true로 설정하고 회전을 180으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="17d7a93a769f7b3e0d3b117cefe7b1b4c1be063d" translate="yes" xml:space="preserve">
          <source>If set to true, reverses the sort order. The default is false.</source>
          <target state="translated">true로 설정하면 정렬 순서를 반대로 바꿉니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="2dc303846cc46bfd771fbdba3f48d0cb434f3036" translate="yes" xml:space="preserve">
          <source>If set to true, sprite particles will interpolate between sprite frames each rendered frame, making the sprites look smoother.</source>
          <target state="translated">true로 설정하면 스프라이트 입자는 렌더링 된 프레임마다 스프라이트 프레임 사이를 보간하여 스프라이트가 더 매끄럽게 보입니다.</target>
        </trans-unit>
        <trans-unit id="15587f4ab0da1bcc2b3b12f98641afe510f98e51" translate="yes" xml:space="preserve">
          <source>If set to true, starts the timer; otherwise stops the timer. For a non-repeating timer,</source>
          <target state="translated">true로 설정하면 타이머를 시작합니다. 그렇지 않으면 타이머를 중지합니다. 반복되지 않는 타이머의 경우</target>
        </trans-unit>
        <trans-unit id="717f5bfbd5599cd28972a015692cf3cd34f2de5f" translate="yes" xml:space="preserve">
          <source>If set to true, the plain text edit paints the palette background on the viewport area not covered by the text document. Otherwise, if set to false, it won't. The feature makes it possible for the user to visually distinguish between the area of the document, painted with the base color of the palette, and the empty area not covered by any document.</source>
          <target state="translated">true로 설정하면 일반 텍스트 편집은 텍스트 문서로 덮여 있지 않은 뷰포트 영역에 팔레트 배경을 그립니다. 그렇지 않으면 false로 설정하면 그렇지 않습니다. 이 기능을 통해 사용자는 팔레트의 기본 색상으로 칠해진 문서 영역과 문서에 포함되지 않은 빈 영역을 시각적으로 구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1a8e65a465f717de848e014ec767ca81303e741" translate="yes" xml:space="preserve">
          <source>If set to true, the plain text edit scrolls the document vertically to make the cursor visible at the center of the viewport. This also allows the text edit to scroll below the end of the document. Otherwise, if set to false, the plain text edit scrolls the smallest amount possible to ensure the cursor is visible. The same algorithm is applied to any new line appended through &lt;a href=&quot;qplaintextedit#appendPlainText&quot;&gt;appendPlainText&lt;/a&gt;().</source>
          <target state="translated">true로 설정하면 일반 텍스트 편집 기능이 문서를 세로로 스크롤하여 커서를 뷰포트 중앙에 표시합니다. 또한 텍스트 편집을 문서 끝 아래로 스크롤 할 수 있습니다. 그렇지 않으면 false로 설정하면 일반 텍스트 편집이 가능한 가장 적은 양을 스크롤하여 커서가 표시되도록합니다. &lt;a href=&quot;qplaintextedit#appendPlainText&quot;&gt;appendPlainText&lt;/a&gt; ()를 통해 추가 된 모든 줄에 동일한 알고리즘이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c4877184b1f5561a5d58031c9d85867ec7bd954c" translate="yes" xml:space="preserve">
          <source>If set to true, the sort is case sensitive. This property is true by default.</source>
          <target state="translated">true로 설정하면 정렬은 대소 문자를 구분합니다. 이 속성은 기본적으로 true입니다.</target>
        </trans-unit>
        <trans-unit id="f6ae784bc8ee3acbc8033099f059d5cb42b4cb36" translate="yes" xml:space="preserve">
          <source>If set, a cursor should be shown inside the preedit string at position start. The length variable determines whether the cursor is visible or not. If the length is 0 the cursor is invisible. If value is a &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; of type &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; this color will be used for rendering the cursor, otherwise the color of the surrounding text will be used. There should be at most one Cursor attribute per event. If several are specified the behaviour is undefined.</source>
          <target state="translated">설정된 경우 위치 시작시 사전 편집 문자열 안에 커서가 표시되어야합니다. 길이 변수는 커서의 표시 여부를 결정합니다. 길이가 0이면 커서가 보이지 않습니다. value가 &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; 유형 의 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 인 경우이 색상은 커서를 렌더링하는 데 사용되며 그렇지 않으면 주변 텍스트의 색상이 사용됩니다. 이벤트 당 최대 하나의 커서 속성이 있어야합니다. 여러 개를 지정하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5cbcc991d5d98d71362a37f0bf20a1d2d0824dfe" translate="yes" xml:space="preserve">
          <source>If set, the background determines the implicit size of the gauge.</source>
          <target state="translated">설정된 경우 배경은 게이지의 암시 적 크기를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="f7100cc7bb389b6b7a9e619886cf855478df4690" translate="yes" xml:space="preserve">
          <source>If set, the edit cursor should be moved to the specified position in the editor text contents. In contrast with &lt;code&gt;Cursor&lt;/code&gt;, this attribute does not work on the preedit text, but on the surrounding text. The cursor will be moved after the commit string has been committed, and the preedit string will be located at the new edit position. The start position specifies the new position and the length variable can be used to set a selection starting from that point. The value is unused.</source>
          <target state="translated">설정된 경우, 편집 커서는 편집기 텍스트 내용에서 지정된 위치로 이동해야합니다. &lt;code&gt;Cursor&lt;/code&gt; 와 달리이 속성은 사전 편집 텍스트가 아니라 주변 텍스트에서 작동합니다. 커밋 문자열이 커밋 된 후 커서가 이동하고 사전 편집 문자열이 새 편집 위치에 있습니다. 시작 위치는 새 위치를 지정하며 길이 변수는 해당 지점에서 시작하여 선택을 설정하는 데 사용될 수 있습니다. 값이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99300767a160b0cd09fe979673aaec40a8f8e4b1" translate="yes" xml:space="preserve">
          <source>If set, the spin box will display this text instead of a numeric value whenever the current value is equal to minimum(). Typical use is to indicate that this choice has a special (default) meaning.</source>
          <target state="translated">설정하면 스핀 상자에 현재 값이 minimum ()과 같을 때마다 숫자 값 대신이 텍스트가 표시됩니다. 일반적으로이 선택은 특별한 (기본값) 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0b90bc6d07bd028eb4d14318f8c1c7a4ef42a71e" translate="yes" xml:space="preserve">
          <source>If set, the typical Unix strip functionality is turned off and the debug information will remain in the binary.</source>
          <target state="translated">설정하면 일반적인 Unix 스트립 기능이 꺼지고 디버그 정보는 이진으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9550fdadf1f510286cf08666ebf79092d77a1af1" translate="yes" xml:space="preserve">
          <source>If set, this component will be used to display the foreground in this column, instead of the &lt;a href=&quot;qml-qtquick-controls-styles-tumblerstyle#columnForeground-prop&quot;&gt;columnForeground&lt;/a&gt; property in &lt;a href=&quot;qml-qtquick-controls-styles-tumblerstyle&quot;&gt;TumblerStyle&lt;/a&gt;.</source>
          <target state="translated">설정하는 경우,이 컴포넌트는 대신에,이 항목에 전경을 표시하는 데 사용한다 &lt;a href=&quot;qml-qtquick-controls-styles-tumblerstyle#columnForeground-prop&quot;&gt;columnForeground의&lt;/a&gt; 재산 &lt;a href=&quot;qml-qtquick-controls-styles-tumblerstyle&quot;&gt;TumblerStyle&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a843844bfe5de2c3078be45e83c896763d5a9af6" translate="yes" xml:space="preserve">
          <source>If set, this delegate will be used to display items in this column, instead of the &lt;a href=&quot;qml-qtquick-controls-styles-tumblerstyle#delegate-prop&quot;&gt;delegate&lt;/a&gt; property in &lt;a href=&quot;qml-qtquick-controls-styles-tumblerstyle&quot;&gt;TumblerStyle&lt;/a&gt;.</source>
          <target state="translated">설정된 경우이 대리자는 &lt;a href=&quot;qml-qtquick-controls-styles-tumblerstyle&quot;&gt;TumblerStyle&lt;/a&gt; 의 &lt;a href=&quot;qml-qtquick-controls-styles-tumblerstyle#delegate-prop&quot;&gt;대리자&lt;/a&gt; 속성 대신이 열에 항목을 표시하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa9b8c2235b895fcbea9084b90bede7efc5022f2" translate="yes" xml:space="preserve">
          <source>If set, this highlight will be used to display the highlight in this column, instead of the &lt;a href=&quot;qml-qtquick-controls-styles-tumblerstyle#highlight-prop&quot;&gt;highlight&lt;/a&gt; property in &lt;a href=&quot;qml-qtquick-controls-styles-tumblerstyle&quot;&gt;TumblerStyle&lt;/a&gt;.</source>
          <target state="translated">설정하면이 하이라이트는 &lt;a href=&quot;qml-qtquick-controls-styles-tumblerstyle&quot;&gt;TumblerStyle&lt;/a&gt; 의 &lt;a href=&quot;qml-qtquick-controls-styles-tumblerstyle#highlight-prop&quot;&gt;highlight&lt;/a&gt; 속성 대신이 열에 하이라이트를 표시하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="57cc8281151af62bf20df6a58787332281cf3f1e" translate="yes" xml:space="preserve">
          <source>If setUrlHandler() is used to set a new handler for a scheme which already has a handler, the existing handler is simply replaced with the new one. Since &lt;a href=&quot;qdesktopservices&quot;&gt;QDesktopServices&lt;/a&gt; does not take ownership of handlers, no objects are deleted when a handler is replaced.</source>
          <target state="translated">setUrlHandler ()를 사용하여 이미 핸들러가있는 스킴의 새 핸들러를 설정하면 기존 핸들러가 새 핸들러로 대체됩니다. 이후 &lt;a href=&quot;qdesktopservices&quot;&gt;QDesktopServices이&lt;/a&gt; 핸들러의 소유권을하지 않는 핸들러를 교체 할 때, 어떤 개체가 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1afd907849c64fd2fc3dc708bdd11f36ebe1d3ca" translate="yes" xml:space="preserve">
          <source>If setting the audio role is not supported, an empty list is returned.</source>
          <target state="translated">오디오 역할 설정이 지원되지 않으면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4f61b5c86e7f8d2e2dbce84ecf170444cc1c8ed2" translate="yes" xml:space="preserve">
          <source>If setting this property it must be set after the &lt;a href=&quot;qml-qtlocation-routemodel#plugin-prop&quot;&gt;plugin&lt;/a&gt; property is set.</source>
          <target state="translated">이 속성을 설정하면 &lt;a href=&quot;qml-qtlocation-routemodel#plugin-prop&quot;&gt;플러그인&lt;/a&gt; 후에 설정해야합니다 속성을 .</target>
        </trans-unit>
        <trans-unit id="cd41129295314cf59ed23c73d6b0db5915f35196" translate="yes" xml:space="preserve">
          <source>If setting this value to 'true' and using an Address or &lt;a href=&quot;qml-coordinate&quot;&gt;coordinate&lt;/a&gt; as the query, note that any change at all in the object's properties will trigger a new request to be sent. If you are adjusting many properties of the object whilst autoUpdate is enabled, this can generate large numbers of useless (and later discarded) requests.</source>
          <target state="translated">이 값을 'true'로 설정하고 주소 또는 &lt;a href=&quot;qml-coordinate&quot;&gt;좌표를&lt;/a&gt; 사용하는 경우 를 쿼리로 경우 개체 속성을 변경하면 새로운 요청이 전송됩니다. 자동 업데이트가 활성화 된 상태에서 객체의 여러 속성을 조정하는 경우 많은 수의 쓸모없는 (및 나중에 폐기 된) 요청이 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d350e369ee24645e392b6322b037ea234ff1c1b0" translate="yes" xml:space="preserve">
          <source>If setting this value to 'true', note that any change at all in the &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery&lt;/a&gt; object set in the &lt;a href=&quot;qml-qtlocation-routemodel#query-prop&quot;&gt;query&lt;/a&gt; property will trigger a new request to be sent. If you are adjusting many properties of the &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery&lt;/a&gt; with autoUpdate enabled, this can generate large numbers of useless (and later discarded) requests.</source>
          <target state="translated">이 값을 'true'로 설정하면 &lt;a href=&quot;qml-qtlocation-routemodel#query-prop&quot;&gt;query&lt;/a&gt; 속성에 설정된 &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery&lt;/a&gt; 객체가 변경 되면 새로운 요청이 전송됩니다. &lt;a href=&quot;qml-qtlocation-routequery&quot;&gt;RouteQuery의&lt;/a&gt; 많은 속성을 조정하는 경우 를 사용 많은 수의 쓸모없고 나중에 폐기 된 요청이 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc1fed6a2a8b0d2163c00b63ef3a942a5fb48d1e" translate="yes" xml:space="preserve">
          <source>If several categories are required, use several Settings objects, each with their own category:</source>
          <target state="translated">여러 범주가 필요한 경우 각각 고유 한 범주를 가진 여러 설정 개체를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="88087324b357253999698cc9b60d0a32564f4ccd" translate="yes" xml:space="preserve">
          <source>If several of the horizontal or several of the vertical alignment flags are set, the resulting alignment is undefined.</source>
          <target state="translated">수평 또는 수직 정렬 플래그가 여러 개 설정된 경우 결과 정렬이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="95280946521b2cff7179a8212bdb3e1e365abdf3" translate="yes" xml:space="preserve">
          <source>If several slots are connected to one signal, the slots will be executed one after the other, in the order they have been connected, when the signal is emitted.</source>
          <target state="translated">하나의 신호에 여러 개의 슬롯이 연결되어 있으면 신호가 방출 될 때 슬롯이 연결된 순서대로 슬롯이 차례로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d7a99c8ad663234a26b55dea1f7c11a72ed5b424" translate="yes" xml:space="preserve">
          <source>If some forms must be designed, but certain custom widgets are unavailble to the designer, we can substitute similar widgets to represent the missing widgets. For example, we might represent instances of a custom push button class, &lt;code&gt;MyPushButton&lt;/code&gt;, with instances of &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton&lt;/a&gt; and promote these to &lt;code&gt;MyPushButton&lt;/code&gt; so that &lt;a href=&quot;uic&quot;&gt;uic&lt;/a&gt; generates suitable code for this missing class.</source>
          <target state="translated">일부 양식을 설계해야하지만 특정 사용자 정의 위젯을 디자이너가 사용할 수없는 경우 유사한 위젯을 대체하여 누락 된 위젯을 나타낼 수 있습니다. 예를 들어, 우리는 사용자 정의 푸시 버튼 클래스의 인스턴스 나타낼 수 &lt;code&gt;MyPushButton&lt;/code&gt; 의 인스턴스로, &lt;a href=&quot;qpushbutton&quot;&gt;QPushButton을을&lt;/a&gt; 하고 이러한 촉진 &lt;code&gt;MyPushButton&lt;/code&gt; 있도록 &lt;a href=&quot;uic&quot;&gt;UIC&lt;/a&gt; 이 실종 클래스에 적합한 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1182043c6b0cdd549d314cf95123f600e725531c" translate="yes" xml:space="preserve">
          <source>If some other mouse button is pressed or the rubber band is disabled, the event is passed to &lt;a href=&quot;qgraphicsview#mousePressEvent&quot;&gt;QGraphicsView::mousePressEvent&lt;/a&gt;().</source>
          <target state="translated">다른 마우스 버튼을 누르거나 고무 밴드를 비활성화하면 이벤트가 &lt;a href=&quot;qgraphicsview#mousePressEvent&quot;&gt;QGraphicsView :: mousePressEvent&lt;/a&gt; ()로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e65772ba115a83af8ed5b44c112b3720d4cc8f2" translate="yes" xml:space="preserve">
          <source>If some parameters are not specified, or null settings are passed, the camera will choose default values.</source>
          <target state="translated">일부 매개 변수를 지정하지 않거나 null 설정을 전달하면 카메라가 기본값을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="70bec2ab80570f84cf112d9821cb10ed5cef9bc2" translate="yes" xml:space="preserve">
          <source>If some parameters are not specified, or null settings are passed, the encoder choose the default encoding parameters.</source>
          <target state="translated">일부 매개 변수가 지정되지 않거나 널 설정이 전달되면 인코더는 기본 인코딩 매개 변수를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="e5df8f6c549fe0e2aae6709bfcec7d2317850e21" translate="yes" xml:space="preserve">
          <source>If some parameters are not specified, or null settings are passed, the encoder will choose default encoding parameters, depending on media source properties.</source>
          <target state="translated">일부 매개 변수를 지정하지 않거나 null 설정을 전달하면 인코더는 미디어 소스 속성에 따라 기본 인코딩 매개 변수를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="b632b10890d9093d7aa05ab2d82bee7121d628c3" translate="yes" xml:space="preserve">
          <source>If some widgets are grouped in tabs, only one widget per group should be specified. Widgets not in the list might be changed to repect the constraints.</source>
          <target state="translated">일부 위젯이 탭으로 그룹화 된 경우 그룹당 하나의 위젯 만 지정해야합니다. 목록에없는 위젯은 제한 조건을 반영하도록 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12d1938e462b898a5c0b87428a67974c0157b02d" translate="yes" xml:space="preserve">
          <source>If someone doubleclicks on the scene, the scene will first receive a mouse press event, followed by a release event (i.e., a click), then a doubleclick event, and finally a release event. If the doubleclick event is delivered to a different item than the one that received the first press and release, it will be delivered as a press event. However, tripleclick events are not delivered as doubleclick events in this case.</source>
          <target state="translated">누군가 장면을 두 번 클릭하면 장면은 먼저 마우스 누름 이벤트를 수신 한 다음 릴리스 이벤트 (예 : 클릭), 이중 클릭 이벤트 및 마지막으로 릴리스 이벤트를 수신합니다. 더블 클릭 이벤트가 첫 번째 프레스 및 릴리스를받은 것과 다른 항목으로 전달되면 프레스 이벤트로 전달됩니다. 그러나이 경우 tripleclick 이벤트는 doubleclick 이벤트로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a61f9875229bf2fea732a74bc6759a9f4133d926" translate="yes" xml:space="preserve">
          <source>If specified before showing a window, will result in the window being shown on that screen, unless an explicit window position has been set. The value must be an element from the Qt.application.screens array.</source>
          <target state="translated">창을 표시하기 전에 지정하면 명시적인 창 위치가 설정되어 있지 않은 한 해당 화면에 창이 표시됩니다. 값은 Qt.application.screens 배열의 요소 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9e9a5c521704e412feac4db47f5810ca13fade99" translate="yes" xml:space="preserve">
          <source>If specified, this will take precedence over &lt;a href=&quot;qml-qtquick-particles-targetdirection#targetX-prop&quot;&gt;targetX&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-particles-targetdirection#targetY-prop&quot;&gt;targetY&lt;/a&gt;. The targeted point will be the center of the specified Item</source>
          <target state="translated">지정하면 &lt;a href=&quot;qml-qtquick-particles-targetdirection#targetX-prop&quot;&gt;targetX&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-particles-targetdirection#targetY-prop&quot;&gt;targetY&lt;/a&gt; 보다 우선 합니다. 대상 지점은 지정된 항목의 중심이됩니다</target>
        </trans-unit>
        <trans-unit id="02f44a0e479b9230e19afdb5fcd0fa5ddc196671" translate="yes" xml:space="preserve">
          <source>If style is zero, a desktop-dependant style will be assigned automatically.</source>
          <target state="translated">스타일이 0이면 데스크탑에 따라 달라지는 스타일이 자동으로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="8e484e0b833a4ea45a62e6a41ff5053ecc2ab297" translate="yes" xml:space="preserve">
          <source>If successful the player control will immediately enter the &lt;a href=&quot;qaudiodecoder#State-enum&quot;&gt;decoding&lt;/a&gt; state.</source>
          <target state="translated">성공하면 플레이어 컨트롤은 즉시 &lt;a href=&quot;qaudiodecoder#State-enum&quot;&gt;디코딩&lt;/a&gt; 상태로 들어갑니다 .</target>
        </trans-unit>
        <trans-unit id="859e1b7060ac75c72dbd02be21ec0df25cf26657" translate="yes" xml:space="preserve">
          <source>If successful the player control will immediately enter the &lt;a href=&quot;qaudiodecoder#State-enum&quot;&gt;stopped&lt;/a&gt; state.</source>
          <target state="translated">성공하면 플레이어 컨트롤은 즉시 &lt;a href=&quot;qaudiodecoder#State-enum&quot;&gt;정지&lt;/a&gt; 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="b5407528f5aa16469249735c22e74b1434388ffb" translate="yes" xml:space="preserve">
          <source>If successful the player control will immediately enter the &lt;a href=&quot;qmediaplayer#State-enum&quot;&gt;paused&lt;/a&gt; state.</source>
          <target state="translated">성공하면 플레이어 컨트롤이 즉시 &lt;a href=&quot;qmediaplayer#State-enum&quot;&gt;일시 정지&lt;/a&gt; 상태로 들어갑니다 .</target>
        </trans-unit>
        <trans-unit id="c78344a5b90fd1c36ce90b263e565b19aa402121" translate="yes" xml:space="preserve">
          <source>If successful the player control will immediately enter the &lt;a href=&quot;qmediaplayer#State-enum&quot;&gt;playing&lt;/a&gt; state.</source>
          <target state="translated">성공하면 플레이어 컨트롤이 즉시 &lt;a href=&quot;qmediaplayer#State-enum&quot;&gt;재생&lt;/a&gt; 상태로 들어갑니다 .</target>
        </trans-unit>
        <trans-unit id="422527a06447559de0cb407460e0e83f6ef1a599" translate="yes" xml:space="preserve">
          <source>If successful the player control will immediately enter the &lt;a href=&quot;qmediaplayer#State-enum&quot;&gt;stopped&lt;/a&gt; state.</source>
          <target state="translated">성공하면 플레이어 컨트롤은 즉시 &lt;a href=&quot;qmediaplayer#State-enum&quot;&gt;정지&lt;/a&gt; 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="710537000a5839b42d1bedc5edca3de3f3c05964" translate="yes" xml:space="preserve">
          <source>If successful, return true, otherwise return false.</source>
          <target state="translated">성공하면 true를, 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7fafee3cc3519c84e73c7e1fa69add3a583e3e36" translate="yes" xml:space="preserve">
          <source>If successful, the method returns an incubator, otherwise null. The incubator has the following properties:</source>
          <target state="translated">성공하면이 메소드는 인큐베이터를 리턴하고 그렇지 않으면 널을 리턴합니다. 인큐베이터에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5da36a9838dce73427e9e5cef3edfe33a354eb4b" translate="yes" xml:space="preserve">
          <source>If supplied, it will have the given &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt;</source>
          <target state="translated">제공된 경우 지정된 &lt;a href=&quot;qobject&quot;&gt;QObject를&lt;/a&gt; 갖습니다.</target>
        </trans-unit>
        <trans-unit id="bb274d4277c287afa989337e11702592c01310b8" translate="yes" xml:space="preserve">
          <source>If supported &lt;a href=&quot;qopengltexture&quot;&gt;QOpenGLTexture&lt;/a&gt; makes use of immutable texture storage.</source>
          <target state="translated">지원되는 경우 &lt;a href=&quot;qopengltexture&quot;&gt;QOpenGLTexture&lt;/a&gt; 는 불변 텍스처 저장을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="32acecf28acfcc368648e22685797b03bea872f5" translate="yes" xml:space="preserve">
          <source>If supported &lt;a href=&quot;qopengltexture&quot;&gt;QOpenGLTexture&lt;/a&gt; makes use of immutable texture storage. However, if immutable texture storage is not available, then the specified</source>
          <target state="translated">지원되는 경우 &lt;a href=&quot;qopengltexture&quot;&gt;QOpenGLTexture&lt;/a&gt; 는 불변 텍스처 저장을 사용합니다. 그러나 불변의 텍스처 스토리지를 사용할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="7cd89d4383a17885538acb0c6ff7a1bfc596cecc" translate="yes" xml:space="preserve">
          <source>If supported, this function returns the image format of the device</source>
          <target state="translated">지원되는 경우이 함수는 장치의 이미지 형식을 반환합니다</target>
        </trans-unit>
        <trans-unit id="3700156043c98bdcdedd8c3e4cc86bf22e24c8cc" translate="yes" xml:space="preserve">
          <source>If supported, this function returns the image format of the file</source>
          <target state="translated">지원되는 경우이 함수는 파일의 이미지 형식을 반환합니다</target>
        </trans-unit>
        <trans-unit id="f35c3cb138b031ca04b325b12836c2865b3aa239" translate="yes" xml:space="preserve">
          <source>If supportsGeocoding() returns false an &lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply::UnsupportedOptionError&lt;/a&gt; will occur.</source>
          <target state="translated">supportsGeocoding ()이 false를 반환하면 &lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply :: UnsupportedOptionError&lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="83815fd33f2c7e79f83fc5c9c50e54d383e33042" translate="yes" xml:space="preserve">
          <source>If supportsReverseGeocoding() returns false an &lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply::UnsupportedOptionError&lt;/a&gt; will occur.</source>
          <target state="translated">supportsReverseGeocoding ()이 false를 반환하면 &lt;a href=&quot;qgeocodereply#Error-enum&quot;&gt;QGeoCodeReply :: UnsupportedOptionError&lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7aa224130c78bdb51f337b83719591bbc6c0e56b" translate="yes" xml:space="preserve">
          <source>If supportsRouteUpdates() returns false an &lt;a href=&quot;qgeoroutereply#Error-enum&quot;&gt;QGeoRouteReply::UnsupportedOptionError&lt;/a&gt; will occur.</source>
          <target state="translated">supportsRouteUpdates ()가 false를 반환하면 &lt;a href=&quot;qgeoroutereply#Error-enum&quot;&gt;QGeoRouteReply :: UnsupportedOptionError&lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="58b280295bc3c05c05e845f898d4b642803dc270" translate="yes" xml:space="preserve">
          <source>If supportsRouteUpdates() returns true then the &lt;a href=&quot;qgeoroutingmanager&quot;&gt;QGeoRoutingManager&lt;/a&gt; supports updating route information based on position updates. This will cause the travel time and distance estimates to be updated, and any QGeoRouteSegments already traversed to be removed from the route.</source>
          <target state="translated">supportsRouteUpdates ()가 true를 반환하면 &lt;a href=&quot;qgeoroutingmanager&quot;&gt;QGeoRoutingManager&lt;/a&gt; 는 위치 업데이트를 기반으로 경로 정보 업데이트를 지원합니다. 이로 인해 이동 시간 및 거리 추정치가 업데이트되고 이미 통과 한 QGeoRouteSegments가 경로에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="cd6338c94d0a5cb89ffff4e332fe26cd31f810c4" translate="yes" xml:space="preserve">
          <source>If tablet tracking is disabled (the default), the widget only receives tablet move events when the stylus is in contact with the tablet, or at least one stylus button is pressed, while the stylus is being moved.</source>
          <target state="translated">태블릿 추적이 비활성화 된 경우 (기본값) 스타일러스가 태블릿과 접촉하거나 스타일러스가 이동하는 동안 하나 이상의 스타일러스 버튼을 누르면 위젯이 태블릿 이동 이벤트 만 수신합니다.</target>
        </trans-unit>
        <trans-unit id="eceb971a6a7c35daf1d68ef4889a82c05130622c" translate="yes" xml:space="preserve">
          <source>If tablet tracking is enabled, the widget receives tablet move events even while hovering in proximity. This is useful for monitoring position as well as the auxiliary properties such as rotation and tilt, and providing feedback in the UI.</source>
          <target state="translated">태블릿 추적이 활성화 된 경우 위젯은 가까이에있는 동안에도 태블릿 이동 이벤트를 수신합니다. 위치 및 회전 및 기울기와 같은 보조 속성을 모니터링하고 UI에서 피드백을 제공하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="447e8ba71cd3ff84c74d1e66414c2447862e9100" translate="yes" xml:space="preserve">
          <source>If tablet tracking is switched off, tablet move events only occur if the stylus is in contact with the tablet, or at least one stylus button is pressed, while the stylus is being moved. If tablet tracking is switched on, tablet move events occur even while the stylus is hovering in proximity of the tablet, with no buttons pressed.</source>
          <target state="translated">태블릿 추적이 꺼져있는 경우 스타일러스가 태블릿과 접촉하거나 스타일러스를 이동하는 동안 하나 이상의 스타일러스 버튼을 누른 경우에만 태블릿 이동 이벤트가 발생합니다. 태블릿 추적이 켜져 있으면 스타일러스가 태블릿 가까이에 있고 버튼을 누르지 않아도 태블릿 이동 이벤트가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="98fbebc84eeef34c3e50e5520965b08a0949730c" translate="yes" xml:space="preserve">
          <source>If that fails, it tries the &lt;a href=&quot;qapplication#activeWindow&quot;&gt;active window.&lt;/a&gt;</source>
          <target state="translated">실패하면 &lt;a href=&quot;qapplication#activeWindow&quot;&gt;활성 창을&lt;/a&gt; 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="1e7df36aeed1dd0835db0e2aa62ff299ebc08183" translate="yes" xml:space="preserve">
          <source>If that happens, first the operating system then &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; will fall back to Pseudo Random Number Generators of decreasing qualities (Qt's fallback generator being the simplest). Whether those generators are still of cryptographic quality is implementation-defined. Therefore, &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator::system&lt;/a&gt;() should not be used for high-frequency random number generation, lest the entropy pool become empty. As a rule of thumb, this class should not be called upon to generate more than a kilobyte per second of random data (note: this may vary from system to system).</source>
          <target state="translated">이 경우, 먼저 운영 체제에서 &lt;a href=&quot;qrandomgenerator&quot;&gt;QRandomGenerator&lt;/a&gt; 가 품질 이 떨어지는 의사 난수 생성기로 폴백합니다 (Qt의 폴백 생성기가 가장 단순함 ). 이러한 생성기가 여전히 암호화 품질인지 여부는 구현 정의됩니다. 따라서 엔트로피 풀이 비워지지 않도록 &lt;a href=&quot;qrandomgenerator#system&quot;&gt;QRandomGenerator :: system&lt;/a&gt; ()을 고주파 난수 생성에 사용해서는 안됩니다. 일반적으로이 클래스는 초당 킬로바이트 이상의 임의 데이터를 생성하도록 요청해서는 안됩니다 (참고 : 시스템마다 다를 수 있음).</target>
        </trans-unit>
        <trans-unit id="6064cf1af52687e0f96e8a01b7a0e6be1525b885" translate="yes" xml:space="preserve">
          <source>If that is not the case, an attempt is made to turn the string into a http:// or ftp:// URL. The latter in the case the string starts with 'ftp'. The result is then passed through &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt;'s tolerant parser, and in the case or success, a valid &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; is returned, or else a &lt;a href=&quot;qurl#QUrl&quot;&gt;QUrl&lt;/a&gt;().</source>
          <target state="translated">그렇지 않은 경우 문자열을 http : // 또는 ftp : // URL로 바꾸려고합니다. 후자는 문자열이 'ftp'로 시작합니다. 그런 다음 결과는 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 의 허용 가능한 구문 분석기를 통해 전달 되며, 성공 또는 성공한 경우 유효한 &lt;a href=&quot;qurl&quot;&gt;QUrl&lt;/a&gt; 이 리턴되거나 &lt;a href=&quot;qurl#QUrl&quot;&gt;QUrl&lt;/a&gt; () 이 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="3bde586d1fb59867c60f360fe99427ae76274e7b" translate="yes" xml:space="preserve">
          <source>If that is the case, then the following code is valid:</source>
          <target state="translated">이 경우 다음 코드가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="70f4d1cbb67cdc30beae88588e4fe9b94c31405e" translate="yes" xml:space="preserve">
          <source>If that worked, you should be able to find your application in Windows' start screen. To remove your application, use Windows' built-in way to uninstall applications (right-click or tap and hold the application and choose &lt;code&gt;Uninstall&lt;/code&gt;).</source>
          <target state="translated">그래도 문제가 해결되지 않으면 Windows 시작 화면에서 응용 프로그램을 찾을 수 있어야합니다. 응용 프로그램을 제거하려면 Windows의 기본 제공 방법을 사용하여 응용 프로그램을 제거하십시오 (응용 프로그램을 마우스 오른쪽 단추로 클릭하거나 길게 누르고 &lt;code&gt;Uninstall&lt;/code&gt; 선택 ).</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="39edb557a6c965ce9b2f57fe41679f15380cdd78" translate="yes" xml:space="preserve">
          <source>If the &quot;compute&quot; slot does not take exactly one &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;, one int and one double in the specified order, the call will fail.</source>
          <target state="translated">&quot;계산&quot;슬롯이 지정된 순서로 정확히 하나의 &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt; , 하나의 int 및 하나의 double을 취하지 않으면 호출이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="fef763c80f9a52304c958846ae57e2fad56750e5" translate="yes" xml:space="preserve">
          <source>If the &quot;new&quot; parent widget is the old parent widget, this function does nothing.</source>
          <target state="translated">&quot;새&quot;상위 위젯이 이전 상위 위젯 인 경우이 함수는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cea9baade05bb62152bca56b3ecceaac2d5ab90d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#coloranimation&quot;&gt;ColorAnimation&lt;/a&gt; is defined within a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;, this value defaults to the value defined in the end state of the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, or the value of the property change that triggered the &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#coloranimation&quot;&gt;ColorAnimation가&lt;/a&gt; 내에 정의되는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;동작&lt;/a&gt; 값이 디폴트 값은의 종료 상태에 정의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 또는 트리거 속성 변경 값 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;동작&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c57d83bf1af8eb8defd7ada9f2a4e84aba60a53" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#coloranimation&quot;&gt;ColorAnimation&lt;/a&gt; is defined within a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;, this value defaults to the value defined in the starting state of the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, or the current value of the property at the moment the &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt; is triggered.</source>
          <target state="translated">경우 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#coloranimation&quot;&gt;ColorAnimation가&lt;/a&gt; 내에서 정의되는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 이나 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;행동&lt;/a&gt; , 값이 값의 기본값은의 시작 상태에 정의 된 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; , 또는 순간에 속성의 현재 값 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;행동이&lt;/a&gt; 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="cd643e2175549d2a9aa76d048e7298bf86d1f69b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt; is defined within a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;, this value defaults to the value defined in the end state of the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, or the value of the property change that triggered the &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation가&lt;/a&gt; 내에 정의되는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;동작&lt;/a&gt; 값이 디폴트 값은의 종료 상태에 정의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 또는 트리거 속성 변경 값 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;동작&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e05c6ef7ca6695ae28fc825a17a91ff0f63aa827" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation&lt;/a&gt; is defined within a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;, this value defaults to the value defined in the starting state of the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, or the current value of the property at the moment the &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt; is triggered.</source>
          <target state="translated">경우 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qtquick-animation-example.html#propertyanimation&quot;&gt;PropertyAnimation가&lt;/a&gt; 내에서 정의되는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 이나 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;행동&lt;/a&gt; , 값이 값의 기본값은의 시작 상태에 정의 된 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; , 또는 순간에 속성의 현재 값 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;행동이&lt;/a&gt; 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="61e52a48ebaef33d7f0289d4b88a75d93335f9fe" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;location-places-qml#plugin&quot;&gt;Plugin&lt;/a&gt; cannot accommodate any of the preferred locales, the manager falls back to using a supported language that is backend specific.</source>
          <target state="translated">&lt;a href=&quot;location-places-qml#plugin&quot;&gt;플러그인&lt;/a&gt; 이 선호하는 로케일을 수용 할 수없는 경우, 관리자는 백엔드 별 지원 언어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a0eaa512128734e60dbfe2319432c18d5ea8ff5d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;location-places-qml#plugin&quot;&gt;Plugin&lt;/a&gt; supports it, categories can be created or removed. To create a new category construct a new Category object and set its properties, then invoke the &lt;a href=&quot;qml-qtlocation-category#save-method&quot;&gt;save()&lt;/a&gt; method.</source>
          <target state="translated">경우 &lt;a href=&quot;location-places-qml#plugin&quot;&gt;플러그인이&lt;/a&gt; 지원하는 카테고리가 생성 또는 제거 할 수 있습니다. 새 범주를 만들려면 새 Category 객체를 만들고 속성을 설정 한 다음 &lt;a href=&quot;qml-qtlocation-category#save-method&quot;&gt;save ()&lt;/a&gt; 메서드 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="32f3945bec4ea25ebe0db5f58d8d0b30d0974766" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;location-places-qml#plugin&quot;&gt;Plugin&lt;/a&gt; supports it, the Place type can be used to save a place. First create a new Place and set its properties:</source>
          <target state="translated">경우 &lt;a href=&quot;location-places-qml#plugin&quot;&gt;플러그인&lt;/a&gt; 을 지원 장소 유형은 장소를 저장하는 데 사용할 수 있습니다. 먼저 새 장소를 만들고 속성을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="f59ff483eb71e9e18fc226a9f8e979b7240ee0bd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;location-places-qml#plugin&quot;&gt;plugin&lt;/a&gt; property is not set or the plugin does not support mapping, this property is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;location-places-qml#plugin&quot;&gt;플러그인&lt;/a&gt; 속성이 설정되지 않았거나 플러그인 매핑을 지원하지 않습니다,이 속성은 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d1895fcff58a64fbd047970f3b9ceec677a0702" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qabstractvideobuffer#MapMode-enum&quot;&gt;MapMode&lt;/a&gt; included the &lt;a href=&quot;qabstractvideobuffer#MapMode-enum&quot;&gt;QAbstractVideoBuffer::WriteOnly&lt;/a&gt; flag this will persist the current content of the mapped memory to the video frame.</source>
          <target state="translated">&lt;a href=&quot;qabstractvideobuffer#MapMode-enum&quot;&gt;MapMode&lt;/a&gt; 에 &lt;a href=&quot;qabstractvideobuffer#MapMode-enum&quot;&gt;QAbstractVideoBuffer :: WriteOnly&lt;/a&gt; 플래그가 포함 된 경우 매핑 된 메모리의 현재 내용이 비디오 프레임에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="995d8d64289255fbd88afbb60cf183e6c4c7248b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qabstractvideobuffer#MapMode-enum&quot;&gt;MapMode&lt;/a&gt; included the &lt;code&gt;QAbstractVideoBuffer::WriteOnly&lt;/code&gt; flag this will write the current content of the mapped memory back to the video frame.</source>
          <target state="translated">&lt;a href=&quot;qabstractvideobuffer#MapMode-enum&quot;&gt;MapMode&lt;/a&gt; 에 &lt;code&gt;QAbstractVideoBuffer::WriteOnly&lt;/code&gt; 플래그가 포함 된 경우 매핑 된 메모리의 현재 내용이 비디오 프레임에 다시 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="b7f94b276b9dce8ae03cb763a8074574f87c379f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qaudioinput&quot;&gt;QAudioInput&lt;/a&gt; is able to access the system's audio device, &lt;a href=&quot;qaudioinput#state&quot;&gt;state&lt;/a&gt;() returns &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio::IdleState&lt;/a&gt;, &lt;a href=&quot;qaudioinput#error&quot;&gt;error&lt;/a&gt;() returns &lt;a href=&quot;qaudio#Error-enum&quot;&gt;QAudio::NoError&lt;/a&gt; and the &lt;a href=&quot;qaudioinput#stateChanged&quot;&gt;stateChanged&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">&lt;a href=&quot;qaudioinput&quot;&gt;QAudioInput&lt;/a&gt; 이 시스템의 오디오 장치에 액세스 할 수있는 경우 &lt;a href=&quot;qaudioinput#state&quot;&gt;state&lt;/a&gt; ()는 &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio :: IdleState를&lt;/a&gt; 반환 하고 &lt;a href=&quot;qaudioinput#error&quot;&gt;error&lt;/a&gt; ()는 &lt;a href=&quot;qaudio#Error-enum&quot;&gt;QAudio :: NoError를&lt;/a&gt; 반환 하며 &lt;a href=&quot;qaudioinput#stateChanged&quot;&gt;stateChanged&lt;/a&gt; () 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8bb843d610e3e1ede30a15b01798984e3f71c680" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qaudioinput&quot;&gt;QAudioInput&lt;/a&gt; is able to successfully get audio data, &lt;a href=&quot;qaudioinput#state&quot;&gt;state&lt;/a&gt;() returns either &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio::ActiveState&lt;/a&gt; or &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio::IdleState&lt;/a&gt;, &lt;a href=&quot;qaudioinput#error&quot;&gt;error&lt;/a&gt;() returns &lt;a href=&quot;qaudio#Error-enum&quot;&gt;QAudio::NoError&lt;/a&gt; and the &lt;a href=&quot;qaudioinput#stateChanged&quot;&gt;stateChanged&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">&lt;a href=&quot;qaudioinput&quot;&gt;QAudioInput&lt;/a&gt; 이 오디오 데이터를 성공적으로 가져올 수있는 경우 &lt;a href=&quot;qaudioinput#state&quot;&gt;state&lt;/a&gt; ()는 &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio :: ActiveState&lt;/a&gt; 또는 &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio :: IdleState를&lt;/a&gt; 반환 하고 &lt;a href=&quot;qaudioinput#error&quot;&gt;error&lt;/a&gt; ()는 &lt;a href=&quot;qaudio#Error-enum&quot;&gt;QAudio :: NoError를&lt;/a&gt; 반환 하고 &lt;a href=&quot;qaudioinput#stateChanged&quot;&gt;stateChanged&lt;/a&gt; () 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c4e06a8d0ade56fc9b2976dfae47a9eb02babd3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt; is able to access the system's audio device, &lt;a href=&quot;qaudiooutput#state&quot;&gt;state&lt;/a&gt;() returns &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio::IdleState&lt;/a&gt;, &lt;a href=&quot;qaudiooutput#error&quot;&gt;error&lt;/a&gt;() returns &lt;a href=&quot;qaudio#Error-enum&quot;&gt;QAudio::NoError&lt;/a&gt; and the &lt;a href=&quot;qaudiooutput#stateChanged&quot;&gt;stateChanged&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">&lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt; 이 시스템의 오디오 장치에 액세스 할 수있는 경우 &lt;a href=&quot;qaudiooutput#state&quot;&gt;state&lt;/a&gt; ()는 &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio :: IdleState를&lt;/a&gt; 리턴 하고 &lt;a href=&quot;qaudiooutput#error&quot;&gt;error&lt;/a&gt; ()는 &lt;a href=&quot;qaudio#Error-enum&quot;&gt;QAudio :: NoError를&lt;/a&gt; 리턴 하며 &lt;a href=&quot;qaudiooutput#stateChanged&quot;&gt;stateChanged&lt;/a&gt; () 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b65ed1ee70f314ca3df1888d87805acda3137187" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt; is able to successfully output audio data, &lt;a href=&quot;qaudiooutput#state&quot;&gt;state&lt;/a&gt;() returns &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio::ActiveState&lt;/a&gt;, &lt;a href=&quot;qaudiooutput#error&quot;&gt;error&lt;/a&gt;() returns &lt;a href=&quot;qaudio#Error-enum&quot;&gt;QAudio::NoError&lt;/a&gt; and the &lt;a href=&quot;qaudiooutput#stateChanged&quot;&gt;stateChanged&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">&lt;a href=&quot;qaudiooutput&quot;&gt;QAudioOutput&lt;/a&gt; 이 오디오 데이터를 성공적으로 출력 할 수있는 경우 &lt;a href=&quot;qaudiooutput#state&quot;&gt;state&lt;/a&gt; ()는 &lt;a href=&quot;qaudio#State-enum&quot;&gt;QAudio :: ActiveState를&lt;/a&gt; 반환 하고 &lt;a href=&quot;qaudiooutput#error&quot;&gt;error&lt;/a&gt; ()는 &lt;a href=&quot;qaudio#Error-enum&quot;&gt;QAudio :: NoError를&lt;/a&gt; 반환 하며 &lt;a href=&quot;qaudiooutput#stateChanged&quot;&gt;stateChanged&lt;/a&gt; () 신호가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b4b29df6d1ecf35a297df6442b54c450bf1db3a1" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qbluetoothserviceinfo#Protocol-enum&quot;&gt;Protocol&lt;/a&gt; is not supported on a platform, calling &lt;a href=&quot;qbluetoothsocket#connectToService&quot;&gt;connectToService&lt;/a&gt;() will emit a &lt;a href=&quot;qbluetoothsocket#SocketError-enum&quot;&gt;UnsupportedProtocolError&lt;/a&gt; error.</source>
          <target state="translated">플랫폼 에서 &lt;a href=&quot;qbluetoothserviceinfo#Protocol-enum&quot;&gt;프로토콜&lt;/a&gt; 이 지원되지 않으면 &lt;a href=&quot;qbluetoothsocket#connectToService&quot;&gt;connectToService&lt;/a&gt; ()를 호출 하면 &lt;a href=&quot;qbluetoothsocket#SocketError-enum&quot;&gt;UnsupportedProtocolError&lt;/a&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3edf74d52c22b2e64ad4ff77c966c0925faf31f9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qbluetoothserviceinfo#Protocol-enum&quot;&gt;QBluetoothServiceInfo::Protocol&lt;/a&gt; is not supported by a platform, &lt;a href=&quot;qbluetoothserver#listen&quot;&gt;listen&lt;/a&gt;() will return &lt;code&gt;false&lt;/code&gt;. Android and &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; only support RFCOMM for example.</source>
          <target state="translated">플랫폼 에서 &lt;a href=&quot;qbluetoothserviceinfo#Protocol-enum&quot;&gt;QBluetoothServiceInfo :: Protocol을&lt;/a&gt; 지원하지 않는 경우 , &lt;a href=&quot;qbluetoothserver#listen&quot;&gt;listen&lt;/a&gt; ()은 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다. 예를 들어 Android 및 &lt;a href=&quot;supported-platforms#winrt&quot;&gt;WinRT&lt;/a&gt; 는 RFCOMM 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7c58bda1740369b3e5339429aa0ef305171dcd94" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qboxlayout&quot;&gt;QBoxLayout&lt;/a&gt; is not the top-level layout (i.e. it is not managing all of the widget's area and children), you must add it to its parent layout before you can do anything with it. The normal way to add a layout is by calling parentLayout-&amp;gt;&lt;a href=&quot;qboxlayout#addLayout&quot;&gt;addLayout&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qboxlayout&quot;&gt;QBoxLayout&lt;/a&gt; 이 최상위 레이아웃이 아닌 경우 (즉, 모든 위젯 영역과 하위를 관리하지 않는 경우)이를 수행하기 전에 상위 레이아웃에 추가해야합니다. 레이아웃을 추가하는 일반적인 방법은 parentLayout-&amp;gt; &lt;a href=&quot;qboxlayout#addLayout&quot;&gt;addLayout&lt;/a&gt; () 을 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="594df039bb96eb35e8504de0a5ba227d27bca09f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qboxlayout&quot;&gt;QBoxLayout&lt;/a&gt;'s orientation is &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt::Horizontal&lt;/a&gt; the boxes are placed in a row, with suitable sizes. Each widget (or other box) will get at least its minimum size and at most its maximum size. Any excess space is shared according to the stretch factors (more about that below).</source>
          <target state="translated">는 IF &lt;a href=&quot;qboxlayout&quot;&gt;QBoxLayout&lt;/a&gt; 의 방향입니다 &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt는 : 수평&lt;/a&gt; 상자는 적당한 크기로, 행에 배치됩니다. 각 위젯 (또는 다른 상자)은 최소한 최소 크기와 최대 크기를 갖습니다. 초과 공간은 신축 계수 (아래에 대한 자세한 내용)에 따라 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="298039a28c24e2ac4e9f63a2c0de0f3aae3e0c41" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qboxlayout&quot;&gt;QBoxLayout&lt;/a&gt;'s orientation is &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt::Vertical&lt;/a&gt;, the boxes are placed in a column, again with suitable sizes.</source>
          <target state="translated">는 IF &lt;a href=&quot;qboxlayout&quot;&gt;QBoxLayout&lt;/a&gt; 의 방향입니다 &lt;a href=&quot;qt#Orientation-enum&quot;&gt;Qt는 : 수직&lt;/a&gt; , 상자는 다시 적당한 크기로, 열에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="722e54fbcf5fb4c6486499ea8626d0ffc74a883c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qcompleter#popup&quot;&gt;popup&lt;/a&gt;() is a &lt;a href=&quot;qlistview&quot;&gt;QListView&lt;/a&gt;, it is automatically setup to display this column.</source>
          <target state="translated">경우 &lt;a href=&quot;qcompleter#popup&quot;&gt;팝업&lt;/a&gt; ()가있다 &lt;a href=&quot;qlistview&quot;&gt;QListView는&lt;/a&gt; ,이 열을 표시하도록 설정은 자동입니다.</target>
        </trans-unit>
        <trans-unit id="67d9a434872e97e6aedcef8997a54a976d839d4a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;timeSpec&lt;/a&gt;() is &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::LocalTime&lt;/a&gt; and the resulting date and time fall in the Standard Time to Daylight-Saving Time transition hour then the result will be adjusted accordingly, i.e. if the transition is at 2am and the clock goes forward to 3am and the result falls between 2am and 3am then the result will be adjusted to fall after 3am.</source>
          <target state="translated">는 IF &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;을 timespec은&lt;/a&gt; ()이다 &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt는 :: 로컬 시간&lt;/a&gt; 과 일광 절약 시간 전이 시간, 결과는, 그에 따라 조정됩니다에 표준 시간의 결과 날짜와 시간 가을 즉 전환은 오전 2시에 있으며 시계가 오전 3시 앞으로가는 경우 결과는 오전 2시에서 오전 3시 사이에 있으며 결과는 오전 3시 이후에 떨어지도록 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="78ec7c0a6b5f19237669f97ee33fad86f2b063b6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;timeSpec&lt;/a&gt;() is &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::LocalTime&lt;/a&gt; or &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::TimeZone&lt;/a&gt; then the date and time are checked to see if they fall in the Standard Time to Daylight-Saving Time transition hour, i.e. if the transition is at 2am and the clock goes forward to 3am then the time from 02:00:00 to 02:59:59.999 is considered to be invalid.</source>
          <target state="translated">는 IF &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;을 timespec은&lt;/a&gt; ()이다 &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt는 :: 로컬 시간&lt;/a&gt; 또는 &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt는 :: 시간대는&lt;/a&gt; 다음 날짜 및 시간, 즉 시계가 간다 전환 새벽 2시되고있는 경우가 일광 절약 시간 전이 시간을 표준 시간에 빠져 있는지 점검 오전 3 시로 이동하면 02:00:00에서 02 : 59 : 59.999까지의 시간이 유효하지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="bd078436e757c578c7a5f048000a757a00b2b969" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;timeSpec&lt;/a&gt;() is &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::LocalTime&lt;/a&gt; then an instance of the current system time zone will be returned. Note however that if you copy this time zone the instance will not remain in sync if the system time zone changes.</source>
          <target state="translated">는 IF &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;을 timespec은&lt;/a&gt; ()이다 &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt는 :: 로컬 시간은&lt;/a&gt; 다음 현재 시스템 시간대의 인스턴스가 반환됩니다. 그러나이 시간대를 복사하면 시스템 시간대가 변경 되더라도 인스턴스가 동기화 상태를 유지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0de8846b0d37ee56f2b2c1203468d5e1a58791a0" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;timeSpec&lt;/a&gt;() is &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::LocalTime&lt;/a&gt; then the host system is queried for the correct abbreviation.</source>
          <target state="translated">는 IF &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;을 timespec은&lt;/a&gt; ()이다 &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt는 :: 로컬 시간&lt;/a&gt; 후, 호스트 시스템은 올바른 약자에 대한 쿼리됩니다.</target>
        </trans-unit>
        <trans-unit id="1185357a32ff3f16f954d328654856af5065290a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;timeSpec&lt;/a&gt;() is &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::LocalTime&lt;/a&gt; this will be the difference between the Local Time and UTC including any Daylight-Saving Offset.</source>
          <target state="translated">는 IF &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;을 timespec은&lt;/a&gt; ()이다 &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt는 :: 로컬 시간&lt;/a&gt; 이 오프셋 어떤 일광 절약 포함한 현지 시간과 UTC의 차이 일 것이다.</target>
        </trans-unit>
        <trans-unit id="7a6003d961d132ecfd5454246f23e45072c0dc8a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;timeSpec&lt;/a&gt;() is &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::OffsetFromUTC&lt;/a&gt; this will be in the format &quot;UTC[+-]00:00&quot;.</source>
          <target state="translated">는 IF &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;을 timespec은&lt;/a&gt; ()이다 &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt는 :: OffsetFromUTC&lt;/a&gt; 이는 형식으로 &quot;- 세계 협정시 00시 [+]&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d92d86cb0458dd5d81ea836719ac95f4d4e552fe" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;timeSpec&lt;/a&gt;() is &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::OffsetFromUTC&lt;/a&gt; this will be the value originally set.</source>
          <target state="translated">는 IF &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;을 timespec은&lt;/a&gt; ()이다 &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt는 :: OffsetFromUTC&lt;/a&gt; 이 원래 설정 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="717670371a83a1eb2fbbe832bcb5d5d36fa966dd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;timeSpec&lt;/a&gt;() is &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::TimeZone&lt;/a&gt; this will be the offset effective in the Time Zone including any Daylight-Saving Offset.</source>
          <target state="translated">는 IF &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;을 timespec은&lt;/a&gt; ()이다 &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt는 :: 시간대&lt;/a&gt; 이는 어떤 일광 절약 오프셋을 포함 시간대에 효과가 상쇄 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="fa3f30a67057ba500afc6891c4eb72a4eb3c031c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;timeSpec&lt;/a&gt;() is &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::UTC&lt;/a&gt; this will be &quot;UTC&quot;.</source>
          <target state="translated">는 IF &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;을 timespec은&lt;/a&gt; ()이다 &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt는 :: UTC&lt;/a&gt; 이 &quot;UTC&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="826cda9940d4b814f0965fea72373c8b1eb48926" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;timeSpec&lt;/a&gt;() is &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::UTC&lt;/a&gt; this will be 0.</source>
          <target state="translated">는 IF &lt;a href=&quot;qdatetime#timeSpec&quot;&gt;을 timespec은&lt;/a&gt; ()이다 &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt는 :: UTC&lt;/a&gt; 이 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="ca82830845aed68de1047d4bdbc79113cdc270fb" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qeventloop#ProcessEventsFlag-enum&quot;&gt;QEventLoop::WaitForMoreEvents&lt;/a&gt; flag is not set in</source>
          <target state="translated">&lt;a href=&quot;qeventloop#ProcessEventsFlag-enum&quot;&gt;QEventLoop :: WaitForMoreEvents&lt;/a&gt; 플래그가 설정되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="39e12fb6ba16e9c9efb1cfedbc26406f02a8d5a3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qeventloop#ProcessEventsFlag-enum&quot;&gt;QEventLoop::WaitForMoreEvents&lt;/a&gt; flag is set in</source>
          <target state="translated">는 IF &lt;a href=&quot;qeventloop#ProcessEventsFlag-enum&quot;&gt;QEventLoop :: WaitForMoreEvents의&lt;/a&gt; 플래그가 설정됩니다</target>
        </trans-unit>
        <trans-unit id="09a997fa78f7ad1d100d74ee2fdecba7123a9caf" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qgeoserviceprovider&quot;&gt;QGeoServiceProvider&lt;/a&gt; supports it, categories can be created and removed. This functionality is available in the &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; class.</source>
          <target state="translated">는 IF &lt;a href=&quot;qgeoserviceprovider&quot;&gt;QGeoServiceProvider가&lt;/a&gt; 지원하는 카테고리가 생성 및 제거 할 수 있습니다. 이 기능은 &lt;a href=&quot;qplacemanager&quot;&gt;QPlaceManager&lt;/a&gt; 클래스 에서 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="e9a279806616e7fc33eb625bee7f80ecee5948fc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qgraphicslayoutitem&quot;&gt;QGraphicsLayoutItem&lt;/a&gt; represents a &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem&lt;/a&gt;, and it wants to take advantage of the automatic reparenting capabilities of &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt; it should set this value. Note that if you delete</source>
          <target state="translated">는 IF &lt;a href=&quot;qgraphicslayoutitem&quot;&gt;QGraphicsLayoutItem는&lt;/a&gt; 대표 &lt;a href=&quot;qgraphicsitem&quot;&gt;QGraphicsItem을&lt;/a&gt; , 그리고 자동, 친의 기능을 활용하고자하는 &lt;a href=&quot;graphicsview#qgraphicslayout&quot;&gt;QGraphicsLayout&lt;/a&gt; 는이 값을 설정해야합니다. 삭제하면</target>
        </trans-unit>
        <trans-unit id="3b420145bc8348be537e64b606837672cd4b7338" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qgridlayout&quot;&gt;QGridLayout&lt;/a&gt; is not the top-level layout (i.e. does not manage all of the widget's area and children), you must add it to its parent layout when you create it, but before you do anything with it. The normal way to add a layout is by calling &lt;a href=&quot;qgridlayout#addLayout&quot;&gt;addLayout&lt;/a&gt;() on the parent layout.</source>
          <target state="translated">&lt;a href=&quot;qgridlayout&quot;&gt;QGridLayout&lt;/a&gt; 이 최상위 레벨 레이아웃이 아닌 경우 (즉, 모든 위젯 영역 및 하위를 관리하지는 않음)이를 작성할 때 상위 레이아웃에 추가해야합니다. 레이아웃을 추가하는 일반적인 방법 은 부모 레이아웃에서 &lt;a href=&quot;qgridlayout#addLayout&quot;&gt;addLayout&lt;/a&gt; ()을 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c4e8829d77e1fc392b6ebd81ad34cb35e73c82f8" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qinputmethodevent#commitString&quot;&gt;commitString&lt;/a&gt;() should replace parts of the of the text in the editor, &lt;a href=&quot;qinputmethodevent#replacementLength&quot;&gt;replacementLength&lt;/a&gt;() will contain the number of characters to be replaced. &lt;a href=&quot;qinputmethodevent#replacementStart&quot;&gt;replacementStart&lt;/a&gt;() contains the position at which characters are to be replaced relative from the start of the preedit string.</source>
          <target state="translated">&lt;a href=&quot;qinputmethodevent#commitString&quot;&gt;commitString&lt;/a&gt; ()이 편집기에서 텍스트의 일부를 대체 해야하는 경우 &lt;a href=&quot;qinputmethodevent#replacementLength&quot;&gt;replacementLength&lt;/a&gt; ()에는 대체 할 문자 수가 포함됩니다. &lt;a href=&quot;qinputmethodevent#replacementStart&quot;&gt;replacementStart&lt;/a&gt; ()는 사전 편집 문자열의 시작 부분에서 문자를 교체 할 위치를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="aef19a264151d360e0a29e1f573c44dd53768547" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qlabel&quot;&gt;QLabel&lt;/a&gt; is deleted in the meantime, the &lt;code&gt;label&lt;/code&gt; variable will hold &lt;code&gt;nullptr&lt;/code&gt; instead of an invalid address, and the last line will never be executed.</source>
          <target state="translated">경우 &lt;a href=&quot;qlabel&quot;&gt;QLabel가&lt;/a&gt; 그 동안 삭제되면, &lt;code&gt;label&lt;/code&gt; 변수를 개최한다 &lt;code&gt;nullptr&lt;/code&gt; 잘못된 주소 대신, 마지막 행은 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9368f33ef30c1886627039b1a476050716d5cfdb" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qmake-variable-reference#config&quot;&gt;CONFIG&lt;/a&gt; variable contains the &lt;code&gt;qt&lt;/code&gt; value, qmake's support for Qt applications is enabled. This makes it possible to fine-tune which of the Qt modules are used by your application. This is achieved with the &lt;a href=&quot;qmake-variable-reference#qt&quot;&gt;QT&lt;/a&gt; variable which can be used to declare the required extension modules. For example, we can enable the XML and network modules in the following way:</source>
          <target state="translated">는 IF &lt;a href=&quot;qmake-variable-reference#config&quot;&gt;구성&lt;/a&gt; 변수가 포함 &lt;code&gt;qt&lt;/code&gt; 값을, Qt는 응용 프로그램에 대한 qmake를 지원 사용할 수 있습니다. 이를 통해 응용 프로그램에서 사용되는 Qt 모듈을 미세 조정할 수 있습니다. 이는 필요한 확장 모듈을 선언하는 데 사용할 수있는 &lt;a href=&quot;qmake-variable-reference#qt&quot;&gt;QT&lt;/a&gt; 변수를 사용하여 수행됩니다. 예를 들어 다음과 같은 방식으로 XML 및 네트워크 모듈을 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2551ed9a3578b278afdad26efc320c00ff945252" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qmediatimeinterval#start&quot;&gt;start&lt;/a&gt;() time of the interval is greater than the &lt;a href=&quot;qmediatimeinterval#end&quot;&gt;end&lt;/a&gt;() time, then the returned interval has the start and end times swapped.</source>
          <target state="translated">간격 의 &lt;a href=&quot;qmediatimeinterval#start&quot;&gt;시작&lt;/a&gt; () 시간이 &lt;a href=&quot;qmediatimeinterval#end&quot;&gt;종료&lt;/a&gt; () 시간 보다 크면 리턴 된 간격에 시작 및 종료 시간이 교환됩니다.</target>
        </trans-unit>
        <trans-unit id="ab2f1b129d238eab9fa0120884e3499facd452e8" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qmessagebox#StandardButton-enum&quot;&gt;standard buttons&lt;/a&gt; are not flexible enough for your message box, you can use the &lt;a href=&quot;qmessagebox#addButton&quot;&gt;addButton&lt;/a&gt;() overload that takes a text and a &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;ButtonRole&lt;/a&gt; to add custom buttons. The &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;ButtonRole&lt;/a&gt; is used by &lt;a href=&quot;qmessagebox&quot;&gt;QMessageBox&lt;/a&gt; to determine the ordering of the buttons on screen (which varies according to the platform). You can test the value of &lt;a href=&quot;qmessagebox#clickedButton&quot;&gt;clickedButton&lt;/a&gt;() after calling &lt;a href=&quot;qmessagebox#exec&quot;&gt;exec&lt;/a&gt;(). For example,</source>
          <target state="translated">는 IF &lt;a href=&quot;qmessagebox#StandardButton-enum&quot;&gt;표준 버튼&lt;/a&gt; 메시지 상자 충분히 유연하지 않습니다, 당신은 사용할 수 있습니다 &lt;a href=&quot;qmessagebox#addButton&quot;&gt;addButton&lt;/a&gt; 텍스트와 소요 () 오버로드 &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;ButtonRole을&lt;/a&gt; 사용자 정의 버튼을 추가 할 수 있습니다. &lt;a href=&quot;qmessagebox#ButtonRole-enum&quot;&gt;ButtonRole는&lt;/a&gt; 에 의해 사용되는 &lt;a href=&quot;qmessagebox&quot;&gt;QMessageBox&lt;/a&gt; (플랫폼에 따라 다름) 화면과 버튼의 순서를 결정한다. &lt;a href=&quot;qmessagebox#exec&quot;&gt;exec&lt;/a&gt; ()를 호출 한 후 &lt;a href=&quot;qmessagebox#clickedButton&quot;&gt;clickedButton&lt;/a&gt; () 의 값을 테스트 할 수 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="72e84a942ad5137dc81a148ef1501eac8bce21e9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass&lt;/a&gt; defines a Parameter, it will be overridden by a Parameter with the same name if it exists in any of the Technique, Effect, Material, &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt;, &lt;a href=&quot;qml-qt3d-render-renderpassfilter&quot;&gt;RenderPassFilter&lt;/a&gt; associated with the pass at runtime. This still can be useful to define sane default values.</source>
          <target state="translated">는 IF &lt;a href=&quot;qml-qt3d-render-renderpass&quot;&gt;RenderPass이&lt;/a&gt; 매개 변수를 정의는 기술, 효과, 소재,의에 존재하는 경우, 동일한 이름의 매개 변수에 의해 무시됩니다 &lt;a href=&quot;qml-qt3d-render-techniquefilter&quot;&gt;TechniqueFilter&lt;/a&gt; , &lt;a href=&quot;qml-qt3d-render-renderpassfilter&quot;&gt;RenderPassFilter&lt;/a&gt; 런타임에 통과와 관련. 이것은 제정신 기본값을 정의하는 데 여전히 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c15c8be92ab6fa15bd7fc88ecce7e062ffe1a35c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtlocation-place#placeId-prop&quot;&gt;placeId&lt;/a&gt; property is set, the backend will update an existing place otherwise it will create a new place. On success the &lt;a href=&quot;qml-qtlocation-place#placeId-prop&quot;&gt;placeId&lt;/a&gt; property will be updated with the identifier of the newly saved place.</source>
          <target state="translated">는 IF &lt;a href=&quot;qml-qtlocation-place#placeId-prop&quot;&gt;placeId의&lt;/a&gt; 속성을 설정, 백엔드 그렇지 않으면 새로운 장소를 만듭니다 기존 장소를 업데이트합니다. 성공하면 &lt;a href=&quot;qml-qtlocation-place#placeId-prop&quot;&gt;placeId&lt;/a&gt; 속성이 새로 저장된 장소의 식별자로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="e75e01efe96e923ca8f3e6a294931357f8138d01" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtlocation-place#placeId-prop&quot;&gt;placeId&lt;/a&gt; property was previously empty, it will be assigned a valid value automatically during a successful save operation.</source>
          <target state="translated">는 IF &lt;a href=&quot;qml-qtlocation-place#placeId-prop&quot;&gt;placeId의&lt;/a&gt; 속성이 비어있는, 그것은 작동 저장 성공시 유효한 값이 자동으로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="aa483c5a186aa9660a0b2e2d5a1bb7b270644b04" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtmultimedia-audio#seekable-prop&quot;&gt;seekable&lt;/a&gt; property is true, seeks the current playback position to</source>
          <target state="translated">는 IF &lt;a href=&quot;qml-qtmultimedia-audio#seekable-prop&quot;&gt;시크&lt;/a&gt; 속성이 true, 현재 재생 위치를 찾고</target>
        </trans-unit>
        <trans-unit id="df47ded20f21e5d162225ae9db8ff836711c25ce" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtmultimedia-mediaplayer#seekable-prop&quot;&gt;seekable&lt;/a&gt; property is true, seeks the current playback position to</source>
          <target state="translated">는 IF &lt;a href=&quot;qml-qtmultimedia-mediaplayer#seekable-prop&quot;&gt;시크&lt;/a&gt; 속성이 true, 현재 재생 위치를 찾고</target>
        </trans-unit>
        <trans-unit id="7243a012f3e1c8b5a9c37d0d8b2a932dfc88c1e6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtmultimedia-video#seekable-prop&quot;&gt;seekable&lt;/a&gt; property is true, seeks the current playback position to</source>
          <target state="translated">는 IF &lt;a href=&quot;qml-qtmultimedia-video#seekable-prop&quot;&gt;시크&lt;/a&gt; 속성이 true, 현재 재생 위치를 찾고</target>
        </trans-unit>
        <trans-unit id="152e4faaaeccd7f875c626f3c8e7ace540a3d42e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtqml-models-delegatemodel#model-prop&quot;&gt;model&lt;/a&gt; is a &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel&lt;/a&gt; subclass, the delegate can also reference a &lt;code&gt;hasModelChildren&lt;/code&gt; property (optionally qualified by a</source>
          <target state="translated">경우] &lt;a href=&quot;qml-qtqml-models-delegatemodel#model-prop&quot;&gt;모델&lt;/a&gt; A는 &lt;a href=&quot;qabstractitemmodel&quot;&gt;QAbstractItemModel의&lt;/a&gt; 서브 대리인도 참조 할 수 &lt;code&gt;hasModelChildren&lt;/code&gt; 의 바이 임의로 정규화 (속성</target>
        </trans-unit>
        <trans-unit id="1635a445cfe7aaa5bdf8fd05ce31d0d056c94126" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-controls-textfield&quot;&gt;TextField&lt;/a&gt; has an input mask, the length will include mask characters and may differ from the length of the string returned by the &lt;a href=&quot;qml-qtquick-controls-textfield#text-prop&quot;&gt;text&lt;/a&gt; property.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-controls-textfield&quot;&gt;TextField&lt;/a&gt; 에 입력 마스크가있는 경우 길이에는 마스크 문자가 포함되며 &lt;a href=&quot;qml-qtquick-controls-textfield#text-prop&quot;&gt;text&lt;/a&gt; 속성에서 반환하는 문자열의 길이와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36f655dd854280a64ebc0a1cbd70350cf20cfa42" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-image&quot;&gt;Image&lt;/a&gt; object omitted the &lt;code&gt;root&lt;/code&gt; prefix, it would inadvertently access the unset &lt;code&gt;PathView.scale&lt;/code&gt; attached property on itself.</source>
          <target state="translated">는 IF &lt;a href=&quot;qml-qtquick-image&quot;&gt;이미지&lt;/a&gt; 오브젝트가 생략 된 &lt;code&gt;root&lt;/code&gt; 접두사, 그것은 실수로 해제에 액세스 할 &lt;code&gt;PathView.scale&lt;/code&gt; 자체에 연결된 속성을.</target>
        </trans-unit>
        <trans-unit id="2ab69095111fa0f97795730c77fd1cc7cde27aad" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-image#source-prop&quot;&gt;source&lt;/a&gt; URL indicates a non-existing local file or resource, the Image element attempts to auto-detect the file extension. If an existing file can be found by appending any of the supported image file extensions to the &lt;a href=&quot;qml-qtquick-image#source-prop&quot;&gt;source&lt;/a&gt; URL, then that file will be loaded.</source>
          <target state="translated">경우 &lt;a href=&quot;qml-qtquick-image#source-prop&quot;&gt;소스&lt;/a&gt; URL이 존재하지 않는 로컬 파일 또는 리소스에 이미지 요소 시도를 나타내는 파일 확장자를 자동 감지. 지원되는 이미지 파일 확장자를 &lt;a href=&quot;qml-qtquick-image#source-prop&quot;&gt;소스&lt;/a&gt; URL 에 추가하여 기존 파일을 찾을 수 있으면 해당 파일이로드됩니다.</target>
        </trans-unit>
        <trans-unit id="3e4d49b7735dbe6296163ffbe2c38fec234ab99b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-item#width-prop&quot;&gt;width&lt;/a&gt; and &lt;a href=&quot;qml-qtquick-item#height-prop&quot;&gt;height&lt;/a&gt; properties are not specified, the Image automatically uses the size of the loaded image. By default, specifying the width and height of the item causes the image to be scaled to that size. This behavior can be changed by setting the &lt;a href=&quot;qml-qtquick-image#fillMode-prop&quot;&gt;fillMode&lt;/a&gt; property, allowing the image to be stretched and tiled instead.</source>
          <target state="translated">경우 &lt;a href=&quot;qml-qtquick-item#width-prop&quot;&gt;너비&lt;/a&gt; 및 &lt;a href=&quot;qml-qtquick-item#height-prop&quot;&gt;높이&lt;/a&gt; 속성이 지정되지 않은, 이미지가 자동으로로드 된 이미지의 크기를 사용합니다. 기본적으로 항목의 너비와 높이를 지정하면 이미지가 해당 크기로 조정됩니다. &lt;a href=&quot;qml-qtquick-image#fillMode-prop&quot;&gt;fillMode&lt;/a&gt; 속성 을 설정 하여이 동작을 변경 하여 이미지를 늘이고 바둑판 식으로 배열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="003716147db025babba320aa8a17f95d1e40f0fb" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-layouts-gridlayout&quot;&gt;GridLayout&lt;/a&gt; is resized, all items in the layout will be rearranged. It is similar to the widget-based &lt;a href=&quot;qgridlayout&quot;&gt;QGridLayout&lt;/a&gt;. All visible children of the &lt;a href=&quot;qml-qtquick-layouts-gridlayout&quot;&gt;GridLayout&lt;/a&gt; element will belong to the layout. If you want a layout with just one row or one column, you can use the &lt;a href=&quot;qml-qtquick-layouts-rowlayout&quot;&gt;RowLayout&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-layouts-columnlayout&quot;&gt;ColumnLayout&lt;/a&gt;. These offer a bit more convenient API, and improve readability.</source>
          <target state="translated">는 IF &lt;a href=&quot;qml-qtquick-layouts-gridlayout&quot;&gt;GridLayout과는&lt;/a&gt; 크기를 조정, 레이아웃에있는 모든 항목을 재 배열됩니다. 위젯 기반 &lt;a href=&quot;qgridlayout&quot;&gt;QGridLayout&lt;/a&gt; 과 유사합니다 . &lt;a href=&quot;qml-qtquick-layouts-gridlayout&quot;&gt;GridLayout&lt;/a&gt; 요소 의 모든 보이는 자식은 레이아웃에 속합니다. 하나의 행 또는 하나의 열이있는 레이아웃을 원하는 경우 &lt;a href=&quot;qml-qtquick-layouts-rowlayout&quot;&gt;RowLayout&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-layouts-columnlayout&quot;&gt;ColumnLayout을&lt;/a&gt; 사용할 수 있습니다 . 이것들은 조금 더 편리한 API를 제공하고 가독성을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="5b0170bcfd25e40e1da00b8d0ba5c32d01017e06" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-layouts-gridlayout#columns-prop&quot;&gt;columns&lt;/a&gt; property is specified, it will be treated as a maximum limit of how many columns the layout can have, before the auto-positioning wraps back to the beginning of the next row. The &lt;a href=&quot;qml-qtquick-layouts-gridlayout#columns-prop&quot;&gt;columns&lt;/a&gt; property is only used when &lt;a href=&quot;qml-qtquick-layouts-gridlayout#flow-prop&quot;&gt;flow&lt;/a&gt; is &lt;code&gt;GridLayout.LeftToRight&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;qml-qtquick-layouts-gridlayout#columns-prop&quot;&gt;열&lt;/a&gt; 속성이 지정되어 자동 위치 랩은 다음 행의 시작 부분에 백업하기 전에, 그것은, 레이아웃이있을 수 있습니다 얼마나 많은 컬럼의 최대 한계로 처리됩니다. &lt;a href=&quot;qml-qtquick-layouts-gridlayout#columns-prop&quot;&gt;열&lt;/a&gt; 때 속성은 사용되는 &lt;a href=&quot;qml-qtquick-layouts-gridlayout#flow-prop&quot;&gt;흐름&lt;/a&gt; 이다 &lt;code&gt;GridLayout.LeftToRight&lt;/code&gt; 가 .</target>
        </trans-unit>
        <trans-unit id="216f47127aa4394a02f38e29c93fc0924b07aa47" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-loader#active-prop&quot;&gt;active&lt;/a&gt; property is &lt;code&gt;false&lt;/code&gt; at the time when this function is called, the given</source>
          <target state="translated">경우 &lt;a href=&quot;qml-qtquick-loader#active-prop&quot;&gt;활성&lt;/a&gt; 특성이 &lt;code&gt;false&lt;/code&gt; 이 함수가 호출 될 때, 주어진</target>
        </trans-unit>
        <trans-unit id="fecb4661ca8d297f88790434481613a6e41a8928" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-loader#source-prop&quot;&gt;source&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-loader#sourceComponent-prop&quot;&gt;sourceComponent&lt;/a&gt; changes, any previously instantiated items are destroyed. Setting &lt;a href=&quot;qml-qtquick-loader#source-prop&quot;&gt;source&lt;/a&gt; to an empty string or setting &lt;a href=&quot;qml-qtquick-loader#sourceComponent-prop&quot;&gt;sourceComponent&lt;/a&gt; to &lt;code&gt;undefined&lt;/code&gt; destroys the currently loaded object, freeing resources and leaving the Loader empty.</source>
          <target state="translated">경우 &lt;a href=&quot;qml-qtquick-loader#source-prop&quot;&gt;소스&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-loader#sourceComponent-prop&quot;&gt;sourceComponent이&lt;/a&gt; 변경 이전 인스턴스 항목이 파괴된다. 설정 &lt;a href=&quot;qml-qtquick-loader#source-prop&quot;&gt;소스를&lt;/a&gt; 빈 문자열 또는 설정 &lt;a href=&quot;qml-qtquick-loader#sourceComponent-prop&quot;&gt;sourceComponent을&lt;/a&gt; 에 &lt;code&gt;undefined&lt;/code&gt; 파괴 현재로드 된 객체를, 자원을 확보하고, 로더는 비워두고.</target>
        </trans-unit>
        <trans-unit id="328f889a8dc9c7ef2e3d8f37a54efad844e1a9fd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-mousearea#hoverEnabled-prop&quot;&gt;hoverEnabled&lt;/a&gt; property is false then these properties will only be valid while a button is pressed, and will remain valid as long as the button is held down even if the mouse is moved outside the area.</source>
          <target state="translated">는 IF &lt;a href=&quot;qml-qtquick-mousearea#hoverEnabled-prop&quot;&gt;hoverEnabled&lt;/a&gt; 속성이 false 인 버튼을 누르고있는 동안 다음 이러한 속성에만 유효하며, 버튼이 마우스가 영역 외부로 이동되는 경우에도 누르고있는만큼 유효합니다.</target>
        </trans-unit>
        <trans-unit id="88568b979df6f5a62d5ca69ea67e41b601f8d5bc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; is defined within a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;, this value defaults to the value defined in the end state of the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, or the value of the property change that triggered the &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation가&lt;/a&gt; 내에 정의되는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;동작&lt;/a&gt; 값이 디폴트 값은의 종료 상태에 정의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 또는 트리거 속성 변경 값 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;동작&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00fd47b9f721798c6485572d9a3e0143f84416dd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation&lt;/a&gt; is defined within a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;, this value defaults to the value defined in the starting state of the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, or the current value of the property at the moment the &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt; is triggered.</source>
          <target state="translated">경우 &lt;a href=&quot;qml-qtquick-numberanimation&quot;&gt;NumberAnimation가&lt;/a&gt; 내에서 정의되는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 이나 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;행동&lt;/a&gt; , 값이 값의 기본값은의 시작 상태에 정의 된 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; , 또는 순간에 속성의 현재 값 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;행동이&lt;/a&gt; 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="ffd97a952333bf737fe9503d3dbea14563c29617" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-parentanimation&quot;&gt;ParentAnimation&lt;/a&gt; is defined within a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, this value defaults to the value defined in the end state of the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;a href=&quot;qml-qtquick-parentanimation&quot;&gt;ParentAnimation가&lt;/a&gt; 내에 정의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;천이&lt;/a&gt; 값이 디폴트 값은의 종료 상태에 정의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="074c499d56e899161b539f8a383cb0ac42e39aaf" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-particles-particlegroup&quot;&gt;ParticleGroup&lt;/a&gt; is a direct child of a &lt;a href=&quot;qml-qtquick-particles-particlesystem&quot;&gt;ParticleSystem&lt;/a&gt;, it will automatically be associated with it.</source>
          <target state="translated">는 IF &lt;a href=&quot;qml-qtquick-particles-particlegroup&quot;&gt;ParticleGroup이&lt;/a&gt; 의 직접적인 자식 &lt;a href=&quot;qml-qtquick-particles-particlesystem&quot;&gt;파티클 시스템은&lt;/a&gt; , 그것은 자동으로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="73d627619913df3726af138861d42a5062abc3f9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-pathview#highlightRangeMode-prop&quot;&gt;highlightRangeMode&lt;/a&gt; is StrictlyEnforceRange then this property determines the speed that the items move along the path.</source>
          <target state="translated">경우] &lt;a href=&quot;qml-qtquick-pathview#highlightRangeMode-prop&quot;&gt;highlightRangeMode가&lt;/a&gt; StrictlyEnforceRange 인 다음이 속성은 항목이 경로를 따라 이동하는 속도를 결정한다.</target>
        </trans-unit>
        <trans-unit id="800a978ddac2f5dd1760b9158fc33e52cc0be72a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction&lt;/a&gt; is defined within a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;, this value defaults to the value defined in the end state of the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, or the value of the property change that triggered the &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;a href=&quot;qml-qtquick-propertyaction&quot;&gt;PropertyAction가&lt;/a&gt; 내에 정의되는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;동작&lt;/a&gt; 값이 디폴트 값은의 종료 상태에 정의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 또는 트리거 속성 변경 값 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;동작&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e1001c4fef4a1e5371e7469979adc85fe203692c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-repeater#model-prop&quot;&gt;model&lt;/a&gt; is a &lt;a href=&quot;qtquick-modelviewsdata-cppmodels#qstringlist-based-model&quot;&gt;string list&lt;/a&gt; or &lt;a href=&quot;qtquick-modelviewsdata-cppmodels#qobjectlist-based-model&quot;&gt;object list&lt;/a&gt;, the delegate is also exposed to a read-only &lt;code&gt;modelData&lt;/code&gt; property that holds the string or object data. For example:</source>
          <target state="translated">경우 &lt;a href=&quot;qml-qtquick-repeater#model-prop&quot;&gt;모델&lt;/a&gt; A는 &lt;a href=&quot;qtquick-modelviewsdata-cppmodels#qstringlist-based-model&quot;&gt;문자열 목록&lt;/a&gt; 또는 &lt;a href=&quot;qtquick-modelviewsdata-cppmodels#qobjectlist-based-model&quot;&gt;개체 목록이&lt;/a&gt; 대리자는 읽기 전용에 노출 &lt;code&gt;modelData&lt;/code&gt; 의 문자열 또는 개체 데이터를 보유 속성입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52a81d1156012735a9ee58e99ed02cf6963615a6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-repeater#model-prop&quot;&gt;model&lt;/a&gt; is a model object (such as a &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;ListModel&lt;/a&gt;) the delegate can access all model roles as named properties, in the same way that delegates do for view classes like &lt;a href=&quot;qml-qtquick-listview&quot;&gt;ListView&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;qml-qtquick-repeater#model-prop&quot;&gt;모델&lt;/a&gt; (예 : 같은 모델 객체 인 &lt;a href=&quot;qml-qtqml-models-listmodel&quot;&gt;의 ListModel를&lt;/a&gt; ) 대의원은 대의원이 같은 뷰 클래스를 위해 할 것과 같은 방식으로, 명명 된 속성 모든 모델 역할을 액세스 할 수 &lt;a href=&quot;qml-qtquick-listview&quot;&gt;있는 ListView&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81721e37209470aa936d098ecaecf05b391e17e1" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-rotationanimation&quot;&gt;RotationAnimation&lt;/a&gt; is defined within a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;, this value defaults to the value defined in the end state of the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, or the value of the property change that triggered the &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;a href=&quot;qml-qtquick-rotationanimation&quot;&gt;RotationAnimation가&lt;/a&gt; 내에 정의되는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;동작&lt;/a&gt; 값이 디폴트 값은의 종료 상태에 정의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 또는 트리거 속성 변경 값 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;동작&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f5bdd1d6aa759af0b956c01fc40c76779baae82" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-rotationanimation&quot;&gt;RotationAnimation&lt;/a&gt; is defined within a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;, this value defaults to the value defined in the starting state of the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, or the current value of the property at the moment the &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt; is triggered.</source>
          <target state="translated">는 IF &lt;a href=&quot;qml-qtquick-rotationanimation&quot;&gt;RotationAnimation이&lt;/a&gt; 내에서 정의되는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 이나 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;행동&lt;/a&gt; , 값이 값의 기본값은의 시작 상태에 정의 된 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; , 또는 순간에 속성의 현재 값 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;행동이&lt;/a&gt; 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="a7dd60b31e8c314c460e0d00de2373f5299ecb9b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-text#fontSizeMode-prop&quot;&gt;fontSizeMode&lt;/a&gt; is Text.FixedSize or the &lt;a href=&quot;qml-qtquick-text#font.pixelSize-prop&quot;&gt;font.pixelSize&lt;/a&gt; is -1 this property is ignored.</source>
          <target state="translated">는 IF &lt;a href=&quot;qml-qtquick-text#fontSizeMode-prop&quot;&gt;fontSizeMode이&lt;/a&gt; Text.FixedSize거나 &lt;a href=&quot;qml-qtquick-text#font.pixelSize-prop&quot;&gt;font.pixelSize는&lt;/a&gt; -1이 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="15d6db572151a8996385a346fa715f060e04b8d1" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-text#fontSizeMode-prop&quot;&gt;fontSizeMode&lt;/a&gt; is Text.FixedSize or the &lt;a href=&quot;qml-qtquick-text#font.pointSize-prop&quot;&gt;font.pointSize&lt;/a&gt; is -1 this property is ignored.</source>
          <target state="translated">는 IF &lt;a href=&quot;qml-qtquick-text#fontSizeMode-prop&quot;&gt;fontSizeMode이&lt;/a&gt; Text.FixedSize거나 &lt;a href=&quot;qml-qtquick-text#font.pointSize-prop&quot;&gt;font.pointSize는&lt;/a&gt; -1이 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="720040cb0e6e31bd38e3985112ccdb0c2d5646c6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; has an &lt;a href=&quot;qml-qtquick-textinput#inputMask-prop&quot;&gt;inputMask&lt;/a&gt; the length will include mask characters and may differ from the length of the string returned by the &lt;a href=&quot;qml-qtquick-textinput#text-prop&quot;&gt;text&lt;/a&gt; property.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; 에 &lt;a href=&quot;qml-qtquick-textinput#inputMask-prop&quot;&gt;inputMask&lt;/a&gt; 가 있으면 길이에 마스크 문자가 포함되며 &lt;a href=&quot;qml-qtquick-textinput#text-prop&quot;&gt;text&lt;/a&gt; 속성에서 반환하는 문자열의 길이와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc4a8672b67b9b81f0f13c592b45fd6054fadf10" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; has an &lt;a href=&quot;qml-qtquick-textinput#inputMask-prop&quot;&gt;inputMask&lt;/a&gt; the length will include mask characters.</source>
          <target state="translated">&lt;a href=&quot;qml-qtquick-textinput&quot;&gt;TextInput&lt;/a&gt; 에 &lt;a href=&quot;qml-qtquick-textinput#inputMask-prop&quot;&gt;inputMask&lt;/a&gt; 가 있으면 길이에 마스크 문자가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="494c96ccb50c6c8f11da9bd3e998d89349eca797" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-vector3danimation&quot;&gt;Vector3dAnimation&lt;/a&gt; is defined within a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;, this value defaults to the value defined in the end state of the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, or the value of the property change that triggered the &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;a href=&quot;qml-qtquick-vector3danimation&quot;&gt;Vector3dAnimation가&lt;/a&gt; 내에 정의되는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;동작&lt;/a&gt; 값이 디폴트 값은의 종료 상태에 정의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 또는 트리거 속성 변경 값 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;동작&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="851f42b8641b8ed00da021c5f83facaa72eecf5d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qml-qtquick-vector3danimation&quot;&gt;Vector3dAnimation&lt;/a&gt; is defined within a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;, this value defaults to the value defined in the starting state of the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, or the current value of the property at the moment the &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt; is triggered.</source>
          <target state="translated">경우 &lt;a href=&quot;qml-qtquick-vector3danimation&quot;&gt;Vector3dAnimation가&lt;/a&gt; 내에서 정의되는 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 이나 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;행동&lt;/a&gt; , 값이 값의 기본값은의 시작 상태에 정의 된 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; , 또는 순간에 속성의 현재 값 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;행동이&lt;/a&gt; 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="6b0a309ffdcd203032629a8b9c6b7058fd0a1122" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; that this &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue&lt;/a&gt; wraps has been deleted, this function returns &lt;code&gt;nullptr&lt;/code&gt; (i.e. it is possible for toQObject() to return &lt;code&gt;nullptr&lt;/code&gt; even when &lt;a href=&quot;qjsvalue#isQObject&quot;&gt;isQObject&lt;/a&gt;() returns true).</source>
          <target state="translated">이 &lt;a href=&quot;qjsvalue&quot;&gt;QJSValue가&lt;/a&gt; 랩핑 한 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 가 삭제 된 경우,이 함수는 &lt;code&gt;nullptr&lt;/code&gt; 을 리턴합니다 (즉, &lt;a href=&quot;qjsvalue#isQObject&quot;&gt;isQObject&lt;/a&gt; ()가 true를 리턴하는 경우 에도 toQObject ()가 &lt;code&gt;nullptr&lt;/code&gt; 을 리턴 할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="ac17d14f6994e27c9016ab4859b8db153b7d2eec" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qpagelayout#Mode-enum&quot;&gt;FullPageMode&lt;/a&gt; mode is set then the &lt;a href=&quot;qpagelayout#fullRect&quot;&gt;fullRect&lt;/a&gt;() is returned and the margins must be manually managed.</source>
          <target state="translated">는 IF &lt;a href=&quot;qpagelayout#Mode-enum&quot;&gt;FullPageMode의&lt;/a&gt; 모드가 다음 설정 &lt;a href=&quot;qpagelayout#fullRect&quot;&gt;fullRect을&lt;/a&gt; () 반환과 여백을 수동으로 관리해야합니다.</target>
        </trans-unit>
        <trans-unit id="479bd0c44562d6ecf7385ac721dc59d76791ddda" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qpagelayout#Mode-enum&quot;&gt;StandardMode&lt;/a&gt; mode is set then the existing margins will be clamped to the new</source>
          <target state="translated">는 IF &lt;a href=&quot;qpagelayout#Mode-enum&quot;&gt;StandardMode의&lt;/a&gt; 모드가 설정되어있는 기존의 마진이 새에 고정됩니다</target>
        </trans-unit>
        <trans-unit id="2ca4ea26fedd9f267c21f5863add552498a92d1f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; instance was obtained from a print device then the name used is that provided by the print device. Note that a print device may not support the current default locale language.</source>
          <target state="translated">&lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; 인스턴스가 인쇄 장치에서 얻은 경우 사용 된 이름은 인쇄 장치에서 제공 한 이름입니다. 인쇄 장치는 현재 기본 로케일 언어를 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="417fb68934dbdaca31378b73ee7364d0c75b7ed4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; is invalid then the &lt;a href=&quot;qpagesize#Unit-enum&quot;&gt;QPageSize::Unit&lt;/a&gt; will be invalid.</source>
          <target state="translated">&lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; 가 유효하지 않으면 &lt;a href=&quot;qpagesize#Unit-enum&quot;&gt;QPageSize :: Unit&lt;/a&gt; 이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2dda0133e4ea4d56ecb857181cb0f4f1527d99b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; is invalid then the &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; will be invalid.</source>
          <target state="translated">&lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; 가 유효하지 않으면 &lt;a href=&quot;qrect&quot;&gt;QRect&lt;/a&gt; 가 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aef68b3f4ab049ef8a8de35c736584f3d6312131" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; is invalid then the &lt;a href=&quot;qsize&quot;&gt;QSize&lt;/a&gt; will be invalid.</source>
          <target state="translated">는 IF &lt;a href=&quot;qpagesize&quot;&gt;QPageSize이&lt;/a&gt; 유효하지 않습니다 다음 &lt;a href=&quot;qsize&quot;&gt;QSize는&lt;/a&gt; 유효 할 것이다.</target>
        </trans-unit>
        <trans-unit id="38f5cf691fef3a26f36ab016b7d5fb78e650264a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; is invalid then the &lt;a href=&quot;qsizef&quot;&gt;QSizeF&lt;/a&gt; will be invalid.</source>
          <target state="translated">는 IF &lt;a href=&quot;qpagesize&quot;&gt;QPageSize이&lt;/a&gt; 유효하지 않습니다 다음 &lt;a href=&quot;qsizef&quot;&gt;QSizeF는&lt;/a&gt; 유효 할 것이다.</target>
        </trans-unit>
        <trans-unit id="29e8307594d70b48aaa50d6d9b9d103f3856acb3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; is invalid then the ID will be &lt;a href=&quot;qpagesize#PageSizeId-enum&quot;&gt;QPageSize::Custom&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;qpagesize&quot;&gt;QPageSize이&lt;/a&gt; 유효하지 않습니다 다음 ID가 될 것입니다 &lt;a href=&quot;qpagesize#PageSizeId-enum&quot;&gt;QPageSize :: 사용자 정의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="922911748c19edbc01651217ba81bbe4ef6709b3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; is invalid then the Windows ID will be 0.</source>
          <target state="translated">&lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; 가 유효하지 않으면 Windows ID는 0입니다.</target>
        </trans-unit>
        <trans-unit id="d5822deeb489834f54775bda7e9530603daba431" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; is invalid then the key will be an empty string.</source>
          <target state="translated">&lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; 가 유효하지 않으면 키는 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="40956f4392f38a195f6f9faf12554e6f6bba80e3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; is invalid then the key will be empty.</source>
          <target state="translated">&lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; 가 유효하지 않으면 키가 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4a140821b937a513bbd910a8ed78929dd99227e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; is invalid then the name will be an empty string.</source>
          <target state="translated">는 IF &lt;a href=&quot;qpagesize&quot;&gt;QPageSize이&lt;/a&gt; 유효하지 않습니다 다음 이름은 빈 문자열이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f32bf7d9a8d96a8e4da05228a84029725db818e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; is invalid then the name will be empty.</source>
          <target state="translated">&lt;a href=&quot;qpagesize&quot;&gt;QPageSize&lt;/a&gt; 가 유효하지 않으면 이름이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b00008c325ab522557179b5414fabc32908fa5ef" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qprocess&quot;&gt;QProcess&lt;/a&gt; object is already running a process, a warning may be printed at the console, and the existing process will continue running unaffected.</source>
          <target state="translated">는 IF &lt;a href=&quot;qprocess&quot;&gt;QProcess의&lt;/a&gt; 개체가 이미 프로세스를 실행하는 경고가 콘솔에 인쇄 될 수 있으며, 기존의 프로세스가 영향을받지 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="be68b9244bb209a560d35c2d5741c8c4c74bc69d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; with active focus accepts the key event, propagation stops. Otherwise the event is sent to the Item's parent until the event is accepted, or the root item is reached.</source>
          <target state="translated">활성 포커스가 있는 &lt;a href=&quot;qquickitem&quot;&gt;QQuickItem&lt;/a&gt; 이 키 이벤트를 승인하면 전파가 중지됩니다. 그렇지 않으면 이벤트가 수락되거나 루트 항목에 도달 할 때까지 이벤트가 항목의 부모에게 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="f18a7702065d1b88919111ae2826aed27858a792" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qregexp&quot;&gt;QRegExp&lt;/a&gt; is a wildcard expression (see &lt;a href=&quot;qregexp#setPatternSyntax&quot;&gt;setPatternSyntax&lt;/a&gt;()) and want to test a string against the whole wildcard expression, use &lt;a href=&quot;qregexp#exactMatch&quot;&gt;exactMatch&lt;/a&gt;() instead of this function.</source>
          <target state="translated">는 IF &lt;a href=&quot;qregexp&quot;&gt;QRegExp가&lt;/a&gt; 와일드 카드 표현이다 (참조 &lt;a href=&quot;qregexp#setPatternSyntax&quot;&gt;setPatternSyntax&lt;/a&gt; ()) 전체 와일드 카드 표현, 사용에 대한 문자열을 테스트 할 &lt;a href=&quot;qregexp#exactMatch&quot;&gt;완전 일치&lt;/a&gt; () 대신이 기능을.</target>
        </trans-unit>
        <trans-unit id="990953de2962e4cc1bbac8aabe8e47715471243a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qstackedlayout&quot;&gt;QStackedLayout&lt;/a&gt; is empty before this function is called, the given</source>
          <target state="translated">는 IF &lt;a href=&quot;qstackedlayout&quot;&gt;QStackedLayout가&lt;/a&gt; 이 함수를 호출하기 전에 비어있는, 주어진</target>
        </trans-unit>
        <trans-unit id="7b1c54c9b0e8d3e3389e717628b426912a4037d5" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qstackedwidget&quot;&gt;QStackedWidget&lt;/a&gt; is empty before this function is called,</source>
          <target state="translated">는 IF &lt;a href=&quot;qstackedwidget&quot;&gt;QStackedWidget가&lt;/a&gt; 이 함수를 호출하기 전에 비어,</target>
        </trans-unit>
        <trans-unit id="e39bb934074a66b081d414e93de3693ac7798954" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qstackedwidget&quot;&gt;QStackedWidget&lt;/a&gt; was empty before this function is called, the given</source>
          <target state="translated">는 IF &lt;a href=&quot;qstackedwidget&quot;&gt;QStackedWidget가&lt;/a&gt; 이 함수를 호출하기 전에 비어있는, 주어진</target>
        </trans-unit>
        <trans-unit id="932ab0fe56ffc7e645b6501b54ba6cbedd0e6562" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::TimeSpec&lt;/a&gt; is not &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::LocalTime&lt;/a&gt; or &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt::TimeZone&lt;/a&gt; then will always return false.</source>
          <target state="translated">경우 &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt는 ::을 timespec이&lt;/a&gt; 아닌 &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt는 :: 로컬 시간&lt;/a&gt; 또는 &lt;a href=&quot;qt#TimeSpec-enum&quot;&gt;Qt는 :: 시간대는&lt;/a&gt; 다음 항상 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bb57c33189467fb2cb5d9a39f758422a51ff1bd5" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass&lt;/a&gt; defines a &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt;, it will be overridden by a &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; with the same name if it exists in any of the &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt;, &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt;, &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt;, &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt;, &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt; associated with the pass at runtime. This still can be useful to define sane default values.</source>
          <target state="translated">는 IF &lt;a href=&quot;qt3drender-qrenderpass&quot;&gt;QRenderPass이&lt;/a&gt; 정의 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter를&lt;/a&gt; , 그것은 오버라이드 (override) 할 것이다 &lt;a href=&quot;qt3drender-qparameter&quot;&gt;QParameter&lt;/a&gt; 는의에 존재하는 경우 동일한 이름을 가진 &lt;a href=&quot;qt3drender-qtechnique&quot;&gt;QTechnique&lt;/a&gt; , &lt;a href=&quot;qt3drender-qeffect&quot;&gt;QEffect&lt;/a&gt; , &lt;a href=&quot;qt3drender-qmaterial&quot;&gt;QMaterial&lt;/a&gt; , &lt;a href=&quot;qt3drender-qtechniquefilter&quot;&gt;QTechniqueFilter&lt;/a&gt; , &lt;a href=&quot;qt3drender-qrenderpassfilter&quot;&gt;QRenderPassFilter&lt;/a&gt; 런타임에 통과와 관련. 이것은 제정신 기본값을 정의하는 데 여전히 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cdc5d678b0d3cb21c160b2f92a0e7bc7e801413" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qtabbar&quot;&gt;QTabBar&lt;/a&gt; was empty before this function is called, the inserted tab becomes the current tab.</source>
          <target state="translated">는 IF &lt;a href=&quot;qtabbar&quot;&gt;QTabBar가&lt;/a&gt; 이 함수를 호출하기 전에 비어, 삽입 탭이 현재 탭이됩니다.</target>
        </trans-unit>
        <trans-unit id="bf86f72ea7b09e62de555ffd44d624741ffd479f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget&lt;/a&gt; was empty before this function is called, the new page becomes the current page. Inserting a new tab at an index less than or equal to the current index will increment the current index, but keep the current page.</source>
          <target state="translated">는 IF &lt;a href=&quot;qtabwidget&quot;&gt;QTabWidget가&lt;/a&gt; 이 함수를 호출하기 전에 비어, 새 페이지는 현재 페이지가됩니다. 현재 색인보다 작거나 같은 색인에 새 탭을 삽입하면 현재 색인이 증가하지만 현재 페이지는 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="e3dd2b93bcd1c21a01101775eaf6c065e2a1ee5f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qtextcursor#anchor&quot;&gt;anchor&lt;/a&gt;() is kept where it is and the &lt;a href=&quot;qtextcursor#position&quot;&gt;position&lt;/a&gt;() is moved, the text in between will be selected.</source>
          <target state="translated">경우] &lt;a href=&quot;qtextcursor#anchor&quot;&gt;앵커&lt;/a&gt; 는 여기서 ()를 유지하고, &lt;a href=&quot;qtextcursor#position&quot;&gt;위치&lt;/a&gt; () 이동되고, 그 사이의 텍스트가 선택 될 것이다.</target>
        </trans-unit>
        <trans-unit id="b890e4b08be1e3d2511e149727b6098894fd2d1f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qtextcursor#position&quot;&gt;position&lt;/a&gt;() is at the start of a block, &lt;a href=&quot;qtextcursor#atBlockStart&quot;&gt;atBlockStart&lt;/a&gt;() returns &lt;code&gt;true&lt;/code&gt;; and if it is at the end of a block, &lt;a href=&quot;qtextcursor#atBlockEnd&quot;&gt;atBlockEnd&lt;/a&gt;() returns true. The format of the current character is returned by &lt;a href=&quot;qtextcursor#charFormat&quot;&gt;charFormat&lt;/a&gt;(), and the format of the current block is returned by &lt;a href=&quot;qtextcursor#blockFormat&quot;&gt;blockFormat&lt;/a&gt;().</source>
          <target state="translated">상기 중간 &lt;a href=&quot;qtextcursor#position&quot;&gt;위치&lt;/a&gt; () 블록의 시작입니다, &lt;a href=&quot;qtextcursor#atBlockStart&quot;&gt;atBlockStart는&lt;/a&gt; ()를 반환 &lt;code&gt;true&lt;/code&gt; ; 그리고 그것이 블록의 끝에 있다면, &lt;a href=&quot;qtextcursor#atBlockEnd&quot;&gt;atBlockEnd&lt;/a&gt; ()는 true를 반환합니다. 현재의 문자의 형식에 의해 반환 &lt;a href=&quot;qtextcursor#charFormat&quot;&gt;charFormat&lt;/a&gt; () 및 현재 블록의 포맷으로 리턴 &lt;a href=&quot;qtextcursor#blockFormat&quot;&gt;blockFormat&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="73fc2ba6364ffaa1a13ddfbc511d9cc29e954d7f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; is a child object of a &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; that has an invokable loadResource method such as &lt;a href=&quot;qtextedit&quot;&gt;QTextEdit&lt;/a&gt;, &lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt; or a &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; itself then the default implementation tries to retrieve the data from the parent.</source>
          <target state="translated">는 IF &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument이&lt;/a&gt; 의 자식 개체입니다 &lt;a href=&quot;qobject&quot;&gt;QObject를&lt;/a&gt; 등의 호출 가능한 loadResource 방법이있다 &lt;a href=&quot;qtextedit&quot;&gt;은 QTextEdit&lt;/a&gt; , &lt;a href=&quot;qtextbrowser&quot;&gt;QTextBrowser&lt;/a&gt; 또는 &lt;a href=&quot;qtextdocument&quot;&gt;QTextDocument&lt;/a&gt; 자체가 다음 기본 구현은 부모로부터 데이터를 검색하려고합니다.</target>
        </trans-unit>
        <trans-unit id="3e9d8dbe1e9f84c020efa7806688ad5a8353b26c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; has a menu, is &lt;a href=&quot;#menu-indicator-sub&quot;&gt;::menu-indicator&lt;/a&gt; subcontrol can be used to style the indicator. By default, the menu-indicator is positioned at the bottom right of the Padding rectangle of the widget.</source>
          <target state="translated">&lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; 에 메뉴가있는 경우 &lt;a href=&quot;#menu-indicator-sub&quot;&gt;:: menu-indicator &lt;/a&gt;하위 제어 를 사용하여 표시기의 스타일을 지정할 수 있습니다. 기본적으로 메뉴 표시기는 위젯의 패딩 사각형 오른쪽 아래에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c99ca325f153f5fa9646487fb9fe03e77e506ddb" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton&lt;/a&gt; is in &lt;a href=&quot;qtoolbutton#ToolButtonPopupMode-enum&quot;&gt;QToolButton::MenuButtonPopup&lt;/a&gt; mode, the &lt;a href=&quot;#menu-button-sub&quot;&gt;::menu-button&lt;/a&gt; subcontrol is used to draw the menu button. &lt;a href=&quot;#menu-arrow-sub&quot;&gt;::menu-arrow&lt;/a&gt; subcontrol is used to draw the menu arrow inside the menu-button. By default, it is positioned in the center of the Contents rectangle of the menu-button subcontrol.</source>
          <target state="translated">는 IF &lt;a href=&quot;qtoolbutton&quot;&gt;QToolButton가&lt;/a&gt; 에 &lt;a href=&quot;qtoolbutton#ToolButtonPopupMode-enum&quot;&gt;QToolButton :: MenuButtonPopup의&lt;/a&gt; 모드에서 &lt;a href=&quot;#menu-button-sub&quot;&gt;: 메뉴 버튼&lt;/a&gt; 서브 컨트롤은 메뉴 버튼을 그리는 데 사용됩니다. &lt;a href=&quot;#menu-arrow-sub&quot;&gt;:: menu-arrow&lt;/a&gt; 하위 컨트롤은 메뉴 버튼 안에 메뉴 화살표를 그리는 데 사용됩니다. 기본적으로 메뉴 단추 하위 제어의 목차 사각형 중앙에 위치합니다.</target>
        </trans-unit>
        <trans-unit id="0e18d3e3d03585b770e1b6a68a5e0320e26b5534" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qtquick-visualcanvas-adaptations#openvg&quot;&gt;OpenVG&lt;/a&gt; implementation uses EGL then &lt;a href=&quot;#qmake-incdir-egl&quot;&gt;QMAKE_INCDIR_EGL&lt;/a&gt; may also need to be set.</source>
          <target state="translated">&lt;a href=&quot;qtquick-visualcanvas-adaptations#openvg&quot;&gt;OpenVG&lt;/a&gt; 구현이 EGL을 사용 하는 경우 &lt;a href=&quot;#qmake-incdir-egl&quot;&gt;QMAKE_INCDIR_EGL&lt;/a&gt; 도 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="94569eba6dae6f5e99e88714cd1e112ad9c33355" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qtquick-visualcanvas-adaptations#openvg&quot;&gt;OpenVG&lt;/a&gt; implementation uses EGL, then &lt;a href=&quot;#qmake-libdir-egl&quot;&gt;QMAKE_LIBDIR_EGL&lt;/a&gt; may also need to be set.</source>
          <target state="translated">&lt;a href=&quot;qtquick-visualcanvas-adaptations#openvg&quot;&gt;OpenVG&lt;/a&gt; 구현이 EGL을 사용 하는 경우 &lt;a href=&quot;#qmake-libdir-egl&quot;&gt;QMAKE_LIBDIR_EGL&lt;/a&gt; 도 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="9625b038bf85f77a19fe419dcdd6e87e02fd35d3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qtquick-visualcanvas-adaptations#openvg&quot;&gt;OpenVG&lt;/a&gt; implementation uses EGL, then &lt;a href=&quot;#qmake-libs-egl&quot;&gt;QMAKE_LIBS_EGL&lt;/a&gt; may also need to be set.</source>
          <target state="translated">&lt;a href=&quot;qtquick-visualcanvas-adaptations#openvg&quot;&gt;OpenVG&lt;/a&gt; 구현이 EGL을 사용 하는 경우 &lt;a href=&quot;#qmake-libs-egl&quot;&gt;QMAKE_LIBS_EGL&lt;/a&gt; 도 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7d22a9f0682544c3b3828e664e9f288b9b83728" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; contains a pointer to a type derived from &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; then &lt;code&gt;T&lt;/code&gt; may be any &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; type. If the pointer stored in the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; can be &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt; to T, then that result is returned. Otherwise &lt;code&gt;nullptr&lt;/code&gt; is returned. Note that this only works for &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; subclasses which use the &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; macro.</source>
          <target state="translated">는 IF &lt;a href=&quot;qvariant&quot;&gt;QVariant가&lt;/a&gt; 에서 파생 된 유형에 대한 포인터가 포함되어 &lt;a href=&quot;qobject&quot;&gt;있는 QObject를&lt;/a&gt; 다음 &lt;code&gt;T&lt;/code&gt; 는 어떤 될 수 &lt;a href=&quot;qobject&quot;&gt;있는 QObject의&lt;/a&gt; 유형입니다. &lt;a href=&quot;qvariant&quot;&gt;QVariant에&lt;/a&gt; 저장된 포인터 가 &lt;a href=&quot;qobject#qobject_cast&quot;&gt;qobject_cast&lt;/a&gt; to T 일 수 있으면 해당 결과가 리턴됩니다. 그렇지 않으면 &lt;code&gt;nullptr&lt;/code&gt; 이 반환됩니다. 이것은 &lt;a href=&quot;qobject#Q_OBJECT&quot;&gt;Q_OBJECT&lt;/a&gt; 매크로 를 사용하는 &lt;a href=&quot;qobject&quot;&gt;QObject&lt;/a&gt; 서브 클래스 에서만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="57c023fbd0ac0ea1f145d034f2f85c13707a3725" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; contains a sequential container and &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList&lt;/a&gt;, the elements of the container will be converted into &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt;s and returned as a &lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;a href=&quot;qvariant&quot;&gt;QVariant가&lt;/a&gt; 순차 컨테이너를 포함하고, &lt;code&gt;T&lt;/code&gt; 는 이다 &lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList&lt;/a&gt; 용기의 요소로 변환한다 &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 들 및 반환 &lt;a href=&quot;qvariant#QVariantList-typedef&quot;&gt;QVariantList&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbc9ed75a5ddeee0a2184b22c91411d463209c95" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qvariant#type&quot;&gt;type&lt;/a&gt;() is &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType::QString&lt;/a&gt;, an invalid date will be returned if the string cannot be parsed as a &lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt::ISODate&lt;/a&gt; format date.</source>
          <target state="translated">는 IF &lt;a href=&quot;qvariant#type&quot;&gt;유형은&lt;/a&gt; ()이다 &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType :: QString&lt;/a&gt; , 문자열이로 해석 할 수없는 경우 잘못된 날짜가 반환됩니다 &lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt는 :: ISODate의&lt;/a&gt; 형식으로 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="f7af81be0d07bd597aaca04c1efca593f8e5d42b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qvariant#type&quot;&gt;type&lt;/a&gt;() is &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType::QString&lt;/a&gt;, an invalid date/time will be returned if the string cannot be parsed as a &lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt::ISODate&lt;/a&gt; format date/time.</source>
          <target state="translated">는 IF &lt;a href=&quot;qvariant#type&quot;&gt;유형은&lt;/a&gt; ()이다 &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType :: QString&lt;/a&gt; , 문자열이로 구문 분석 할 수없는 경우 유효하지 않은 날짜 / 시간이 반환됩니다 &lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt는 :: ISODate&lt;/a&gt; 형식 날짜 / 시간.</target>
        </trans-unit>
        <trans-unit id="71bb5a8292ff3e78c11225f9a5fad7e8f35fd62f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qvariant#type&quot;&gt;type&lt;/a&gt;() is &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType::QString&lt;/a&gt;, an invalid time will be returned if the string cannot be parsed as a &lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt::ISODate&lt;/a&gt; format time.</source>
          <target state="translated">는 IF &lt;a href=&quot;qvariant#type&quot;&gt;유형은&lt;/a&gt; ()이다 &lt;a href=&quot;qmetatype#Type-enum&quot;&gt;QMetaType :: QString&lt;/a&gt; , 문자열이로 해석 할 수없는 경우 유효하지 않은 시간이 반환됩니다 &lt;a href=&quot;qt#DateFormat-enum&quot;&gt;Qt는 :: ISODate의&lt;/a&gt; 형식 시간.</target>
        </trans-unit>
        <trans-unit id="ca41268ad228e2244f4d1959254c864df7708841" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qvariantanimation#startValue-prop&quot;&gt;startValue&lt;/a&gt; is not defined when the state of the animation changes from Stopped to Running, the current property value is used as the initial value for the animation.</source>
          <target state="translated">경우] &lt;a href=&quot;qvariantanimation#startValue-prop&quot;&gt;startValue는&lt;/a&gt; 실행을 멈추고, 애니메이션에서 변화의 상태는, 현재 속성 값이 애니메이션의 초기 값으로 사용될 때 정의되지 않는다.</target>
        </trans-unit>
        <trans-unit id="2c54b11af84dede8d0b0a6006dc95b712a8c17b1" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qxmlstreamreader#tokenType&quot;&gt;tokenType&lt;/a&gt;() is &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;DTD&lt;/a&gt;, this function returns the DTD's name. Otherwise an empty string is returned.</source>
          <target state="translated">는 IF &lt;a href=&quot;qxmlstreamreader#tokenType&quot;&gt;tokentype 매은&lt;/a&gt; ()이다 &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;DTD는&lt;/a&gt; 이 함수는 DTD의 이름을 반환합니다. 그렇지 않으면 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="95cffa69244b7b504ee5cd534fb1827666fbaa21" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qxmlstreamreader#tokenType&quot;&gt;tokenType&lt;/a&gt;() is &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;DTD&lt;/a&gt;, this function returns the DTD's notation declarations. Otherwise an empty vector is returned.</source>
          <target state="translated">는 IF &lt;a href=&quot;qxmlstreamreader#tokenType&quot;&gt;tokentype 매은&lt;/a&gt; ()이다 &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;DTD는&lt;/a&gt; 이 함수는 DTD의 표기법 선언을 반환합니다. 그렇지 않으면 빈 벡터가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="aabaa440ac2d787f0b18172205accc8c2fe2bcc3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qxmlstreamreader#tokenType&quot;&gt;tokenType&lt;/a&gt;() is &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;DTD&lt;/a&gt;, this function returns the DTD's public identifier. Otherwise an empty string is returned.</source>
          <target state="translated">는 IF &lt;a href=&quot;qxmlstreamreader#tokenType&quot;&gt;tokentype 매은&lt;/a&gt; ()이다 &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;DTD는&lt;/a&gt; 이 함수는 DTD의 공개 식별자를 반환한다. 그렇지 않으면 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="093602572d776d51ad71a3eb3548bbbfd2906748" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qxmlstreamreader#tokenType&quot;&gt;tokenType&lt;/a&gt;() is &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;DTD&lt;/a&gt;, this function returns the DTD's system identifier. Otherwise an empty string is returned.</source>
          <target state="translated">는 IF &lt;a href=&quot;qxmlstreamreader#tokenType&quot;&gt;tokentype 매은&lt;/a&gt; ()이다 &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;DTD는&lt;/a&gt; 이 함수는 DTD의 시스템 식별자를 반환합니다. 그렇지 않으면 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="917db187d0ae1212f0775b902d8bad1b90157431" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qxmlstreamreader#tokenType&quot;&gt;tokenType&lt;/a&gt;() is &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;DTD&lt;/a&gt;, this function returns the DTD's unparsed (external) entity declarations. Otherwise an empty vector is returned.</source>
          <target state="translated">는 IF &lt;a href=&quot;qxmlstreamreader#tokenType&quot;&gt;tokentype 매은&lt;/a&gt; ()이다 &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;DTD는&lt;/a&gt; 이 함수는 DTD의 구문 분석되지 않은 (외부) 엔티티 선언을 반환합니다. 그렇지 않으면 빈 벡터가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a2b89e94b3295c5d86b23bf708d001b618c794b7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qxmlstreamreader#tokenType&quot;&gt;tokenType&lt;/a&gt;() is &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;StartDocument&lt;/a&gt;, this function returns the encoding string as specified in the XML declaration. Otherwise an empty string is returned.</source>
          <target state="translated">는 IF &lt;a href=&quot;qxmlstreamreader#tokenType&quot;&gt;tokentype 매은&lt;/a&gt; ()이다 &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;있으며, StartDocument는&lt;/a&gt; ,이 기능은 XML 선언에 지정된 인코딩 문자열을 반환합니다. 그렇지 않으면 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="129562d6806a13e33fce4be5441d248f4074b3fe" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qxmlstreamreader#tokenType&quot;&gt;tokenType&lt;/a&gt;() is &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;StartDocument&lt;/a&gt;, this function returns the version string as specified in the XML declaration. Otherwise an empty string is returned.</source>
          <target state="translated">는 IF &lt;a href=&quot;qxmlstreamreader#tokenType&quot;&gt;tokentype 매은&lt;/a&gt; ()이다 &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;있으며, StartDocument는&lt;/a&gt; ,이 기능은 XML 선언에 지정된 버전 문자열을 반환합니다. 그렇지 않으면 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="43567294acc8b06b43df00e0e57e03b8a1f726c2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;qxmlstreamreader#tokenType&quot;&gt;tokenType&lt;/a&gt;() is &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;StartElement&lt;/a&gt;, this function returns the element's namespace declarations. Otherwise an empty vector is returned.</source>
          <target state="translated">는 IF &lt;a href=&quot;qxmlstreamreader#tokenType&quot;&gt;tokentype 매은&lt;/a&gt; ()이다 &lt;a href=&quot;qxmlstreamreader#TokenType-enum&quot;&gt;하는 startElement가&lt;/a&gt; 이 함수는 요소의 네임 스페이스 선언을 반환합니다. 그렇지 않으면 빈 벡터가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c4fc49cbe93d9d61cac473530062dc9a709791b8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GL_EXT_packed_depth_stencil&lt;/code&gt; extension is present, a combined depth and stencil buffer is attached. If the extension is not present, only a depth buffer is attached.</source>
          <target state="translated">경우] &lt;code&gt;GL_EXT_packed_depth_stencil&lt;/code&gt; 의 연장이 존재하는 결합 깊이와 스텐실 버퍼가 부착된다. 확장이 없으면 깊이 버퍼 만 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="600de86debac52ccae20e8cdc990223233cb18d9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;MessageBoard&lt;/code&gt; type was &lt;a href=&quot;qtqml-cppintegration-definetypes#registering-c-types-with-the-qml-type-system&quot;&gt;registered&lt;/a&gt; with the QML type system, then a &lt;code&gt;MessageBoard&lt;/code&gt; object declared in QML could receive the &lt;code&gt;newMessagePosted()&lt;/code&gt; signal using a signal handler named &lt;code&gt;onNewMessagePosted&lt;/code&gt;, and examine the &lt;code&gt;subject&lt;/code&gt; parameter value:</source>
          <target state="translated">경우] &lt;code&gt;MessageBoard&lt;/code&gt; 의 유형 하였다 &lt;a href=&quot;qtqml-cppintegration-definetypes#registering-c-types-with-the-qml-type-system&quot;&gt;등록&lt;/a&gt; QML 형 시스템, 다음 &lt;code&gt;MessageBoard&lt;/code&gt; 의 QML 선언 개체는 수신 할 수 &lt;code&gt;newMessagePosted()&lt;/code&gt; 라는 신호 처리기를 사용하여 신호를 &lt;code&gt;onNewMessagePosted&lt;/code&gt; 를 하고, 검사 &lt;code&gt;subject&lt;/code&gt; 파라미터 값 :</target>
        </trans-unit>
        <trans-unit id="2180ccad6d07be696255d41c224ad265bc24e5a4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;MessageBody&lt;/code&gt; type was also registered with the type system, it would be possible to assign &lt;code&gt;MessageBody&lt;/code&gt; to the &lt;code&gt;body&lt;/code&gt; property of a &lt;code&gt;Message&lt;/code&gt;, all from within QML code:</source>
          <target state="translated">는 IF &lt;code&gt;MessageBody&lt;/code&gt; 의 종류도 종류의 시스템에 등록 된, 할당 할 수있을 것 &lt;code&gt;MessageBody&lt;/code&gt; 을 받는 &lt;code&gt;body&lt;/code&gt; 의 특성 &lt;code&gt;Message&lt;/code&gt; , QML 코드 내에서 모든 :</target>
        </trans-unit>
        <trans-unit id="eecd9b2682e14d25ac9c6848168db423d265dfce" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;QT_FATAL_WARNINGS&lt;/code&gt; environment variable is set, &lt;a href=&quot;#qWarning&quot;&gt;qWarning&lt;/a&gt;() exits after printing the warning message. This makes it easy to obtain a backtrace in the debugger.</source>
          <target state="translated">는 IF &lt;code&gt;QT_FATAL_WARNINGS&lt;/code&gt; 의 환경 변수가 설정되어 &lt;a href=&quot;#qWarning&quot;&gt;qWarning&lt;/a&gt; 경고 메시지를 인쇄 한 후 () 종료. 이렇게하면 디버거에서 역 추적을 쉽게 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cddbc381c9ece1f0461f1856b619f45897a5681" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;QtQuick&lt;/code&gt; module has been imported, the following helper functions for creating objects of specific data types are also available for clients to use:</source>
          <target state="translated">는 IF &lt;code&gt;QtQuick&lt;/code&gt; 의 모듈을 가져온, 특정 데이터 유형의 객체를 생성하기위한 다음과 같은 헬퍼 함수도 사용하도록 클라이언트에 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8c083b0fc06657c12c704c77184201db13f05ae9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Rectangle&lt;/code&gt; type in the following example has active focus and the &lt;code&gt;A&lt;/code&gt; key is pressed, the event will not be propagated further. Upon pressing the &lt;code&gt;B&lt;/code&gt; key, the event will propagate to the root item and thus be ignored.</source>
          <target state="translated">경우 &lt;code&gt;Rectangle&lt;/code&gt; 다음 예에서와 유형이 활성화 초점을 가지고 있으며 &lt;code&gt;A&lt;/code&gt; 키를 누르면, 이벤트가 추가로 전파되지 않습니다. &lt;code&gt;B&lt;/code&gt; 키 를 누르면 이벤트가 루트 항목으로 전파되므로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f855a457a0aca24540a24935ce1ed48c71333ddb" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;author&lt;/code&gt; property was writable but did not have an associated NOTIFY signal, the &lt;code&gt;text&lt;/code&gt; value would be initialized with the initial value returned by &lt;code&gt;Message::author()&lt;/code&gt; but would not be updated with any later changes to this property. In addition, any attempts to bind to the property from QML will produce a runtime warning from the engine.</source>
          <target state="translated">는 IF &lt;code&gt;author&lt;/code&gt; 속성은 신호를 NOTIFY 쓸 수 있었다 그러나이 관련이 없었다의 &lt;code&gt;text&lt;/code&gt; 값에 의해 반환 된 초기 값으로 초기화 될 &lt;code&gt;Message::author()&lt;/code&gt; 하지만이 속성에 대한 이후 변경 내용으로 업데이트되지 않습니다. 또한 QML에서 속성에 바인딩하려고하면 엔진에서 런타임 경고가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="57d75f09d13f15f658cd613775cf09d541a6da22" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;fillStyle&lt;/code&gt; or &lt;a href=&quot;qml-qtquick-context2d#strokeStyle-prop&quot;&gt;strokeStyle&lt;/a&gt; is assigned many times in a loop, the last Qt.rgba() syntax should be chosen, as it has the best performance, because it's already a valid &lt;a href=&quot;qcolor&quot;&gt;QColor&lt;/a&gt; value, does not need to be parsed everytime.</source>
          <target state="translated">경우 &lt;code&gt;fillStyle&lt;/code&gt; 에서는 또는 &lt;a href=&quot;qml-qtquick-context2d#strokeStyle-prop&quot;&gt;strokeStyle가&lt;/a&gt; 루프에서 많은 시간을 할당은 최상의 성능을 가지고로 이미 유효한 때문에, 마지막 Qt.rgba () 구문은, 선택해야 &lt;a href=&quot;qcolor&quot;&gt;QColor의&lt;/a&gt; 구문 분석 매번 할 필요는 없습니다, 값.</target>
        </trans-unit>
        <trans-unit id="c25ae0fde423442960a3433b20bbbc46db8d15a2" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;height&lt;/code&gt; of the &lt;code&gt;Item&lt;/code&gt; changed after the &lt;code&gt;object-&amp;gt;setProperty(&quot;width&quot;, 500)&lt;/code&gt; call, the &lt;code&gt;width&lt;/code&gt; would be updated again, as the binding remains active. However, if the &lt;code&gt;height&lt;/code&gt; changes after the &lt;code&gt;QQmlProperty(object, &quot;width&quot;).write(500)&lt;/code&gt; call, the &lt;code&gt;width&lt;/code&gt; will not be changed, as the binding does not exist anymore.</source>
          <target state="translated">&lt;code&gt;object-&amp;gt;setProperty(&quot;width&quot;, 500)&lt;/code&gt; 호출 후 &lt;code&gt;Item&lt;/code&gt; 의 &lt;code&gt;height&lt;/code&gt; 가 변경된 경우 바인딩이 활성 상태로 유지 되므로 &lt;code&gt;width&lt;/code&gt; 가 다시 업데이트됩니다. 그러나 &lt;code&gt;height&lt;/code&gt; 애프터 변경 &lt;code&gt;QQmlProperty(object, &quot;width&quot;).write(500)&lt;/code&gt; 호출의 &lt;code&gt;width&lt;/code&gt; 변경되지 결합으로, 더 이상 존재하지 않는다.</target>
        </trans-unit>
        <trans-unit id="a47e0ee251303d4abf81407d0ad31e56bbbda67d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;properties&lt;/code&gt; to be pushed are specified, they will be copied into the item at loading time (in case of a component or URL), or when the item becomes the current item (in case of an inline item). The following example shows how this can be done:</source>
          <target state="translated">푸시 할 &lt;code&gt;properties&lt;/code&gt; 이 지정되면 로딩시 (구성 요소 또는 URL의 경우) 또는 항목이 현재 항목이 될 때 (인라인 항목의 경우) 항목에 복사됩니다. 다음 예제는이를 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="03ef164a05e3edb057814878b7d0f6327c06d316" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;thead&lt;/code&gt; tag is specified, it is used when printing tables that span multiple pages.</source>
          <target state="translated">경우 &lt;code&gt;thead&lt;/code&gt; 태그가 지정된 여러 페이지에 걸쳐 테이블을 인쇄 할 때, 그것은 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d21c52d7c9043ed66bf791cac8b54a5d9bc89548" translate="yes" xml:space="preserve">
          <source>If the ActiveX server is an executable, the following command line options are supported:</source>
          <target state="translated">ActiveX 서버가 실행 파일 인 경우 다음 명령 줄 옵션이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="2451d1d7b1140e3d251bb52949c3dcc95d8fe0c5" translate="yes" xml:space="preserve">
          <source>If the Animator is defined within a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;, this value defaults to the value defined in the end state of the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, or the value of the property change that triggered the &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;.</source>
          <target state="translated">애니메이터는 내에서 정의되면 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;동작&lt;/a&gt; 값이 디폴트 값은의 종료 상태에 정의 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;전환&lt;/a&gt; 또는 트리거 속성 변경 값 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;동작&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ace23a4d7152794f93e2868fe35c3b541276f2a" translate="yes" xml:space="preserve">
          <source>If the Animator is defined within a &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt;, this value defaults to the value defined in the starting state of the &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt;, or the current value of the property at the moment the &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt; is triggered.</source>
          <target state="translated">Animator가 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt; 내에 정의 된 경우이 값의 기본값은 &lt;a href=&quot;https://doc.qt.io/qt-5.13/qmlexampletoggleswitch.html#transition&quot;&gt;Transition&lt;/a&gt; 의 시작 상태에 정의 된 값 또는 &lt;a href=&quot;qml-qtquick-behavior&quot;&gt;Behavior&lt;/a&gt; 가 트리거되는 시점의 현재 속성 값입니다 .</target>
        </trans-unit>
        <trans-unit id="fcd67df4180e4d256a83f98655c3f5c853182e0f" translate="yes" xml:space="preserve">
          <source>If the COM object supports a MIME type then this function is called to initialize the COM object from the data</source>
          <target state="translated">COM 개체가 MIME 형식을 지원하는 경우이 함수는 데이터에서 COM 개체를 초기화하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a7da057d582f63e7a927fa2c7bb8a50b2f9cec23" translate="yes" xml:space="preserve">
          <source>If the COM object supports a MIME type then this function is called to store the COM object into</source>
          <target state="translated">COM 개체가 MIME 형식을 지원하는 경우이 함수는 COM 개체를 저장하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="73beaf203effe044ad469e3d593af920f7f7e382" translate="yes" xml:space="preserve">
          <source>If the COM object supports property notification, this signal gets emitted when the property called</source>
          <target state="translated">COM 개체가 속성 알림을 지원하는 경우이 신호는 속성이 호출 될 때 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="587eb95db0622152a6a069969f7c7dfb583b016f" translate="yes" xml:space="preserve">
          <source>If the Imagine style is imported in a QML file that is always loaded, the Imagine style must be deployed with the application in order to be able to run the application regardless of which style the application is run with. By using &lt;a href=&quot;qtquickcontrols2-fileselectors#&quot;&gt;file selectors&lt;/a&gt;, style-specific tweaks can be applied without creating a hard dependency to a style.</source>
          <target state="translated">Imagine 스타일을 항상로드되는 QML 파일로 가져 오는 경우, 응용 프로그램을 실행하는 스타일에 관계없이 응용 프로그램을 실행할 수 있으려면 Imagine 스타일을 응용 프로그램과 함께 배포해야합니다. &lt;a href=&quot;qtquickcontrols2-fileselectors#&quot;&gt;파일 선택기&lt;/a&gt; 를 사용 하면 스타일에 대한 엄격한 종속성을 만들지 않고도 스타일 별 조정을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cce3189c00dac47539ad474f4fc1f83cfbea8bed" translate="yes" xml:space="preserve">
          <source>If the Loader is inactive, changing the &lt;a href=&quot;qml-qtquick-loader#source-prop&quot;&gt;source&lt;/a&gt; or &lt;a href=&quot;qml-qtquick-loader#sourceComponent-prop&quot;&gt;sourceComponent&lt;/a&gt; will not cause the item to be instantiated until the Loader is made active.</source>
          <target state="translated">로더가 비활성 상태 인 경우 &lt;a href=&quot;qml-qtquick-loader#source-prop&quot;&gt;소스&lt;/a&gt; 또는 &lt;a href=&quot;qml-qtquick-loader#sourceComponent-prop&quot;&gt;sourceComponent를&lt;/a&gt; 변경 하면 로더가 활성화 될 때까지 항목이 인스턴스화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9a1d407c4634ecd2a77855944ae306fcf4ba1ae" translate="yes" xml:space="preserve">
          <source>If the Material style is imported in a QML file that is always loaded, the Material style must be deployed with the application in order to be able to run the application regardless of which style the application is run with. By using &lt;a href=&quot;qtquickcontrols2-fileselectors#&quot;&gt;file selectors&lt;/a&gt;, style-specific tweaks can be applied without creating a hard dependency to a style.</source>
          <target state="translated">재료 스타일을 항상로드되는 QML 파일로 가져 오는 경우, 응용 프로그램이 실행되는 스타일에 관계없이 응용 프로그램을 실행할 수 있으려면 응용 프로그램과 함께 재료 스타일을 배치해야합니다. &lt;a href=&quot;qtquickcontrols2-fileselectors#&quot;&gt;파일 선택기&lt;/a&gt; 를 사용 하면 스타일에 대한 엄격한 종속성을 만들지 않고도 스타일 별 조정을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="880686bb519b141e100184039df8f9e528676540" translate="yes" xml:space="preserve">
          <source>If the OpenGL &lt;a href=&quot;qtquick-visualcanvas-scenegraph#&quot;&gt;scene graph&lt;/a&gt; backend is in use, the file search the attempts the OpenGL texture file extensions first. If the search is unsuccessful, it attempts to search with the file extensions for the &lt;a href=&quot;qimagereader#supportedImageFormats&quot;&gt;conventional image file types&lt;/a&gt;. For example:</source>
          <target state="translated">OpenGL &lt;a href=&quot;qtquick-visualcanvas-scenegraph#&quot;&gt;장면 그래프&lt;/a&gt; 백엔드가 사용중인 경우 파일 검색은 먼저 OpenGL 텍스처 파일 확장자를 시도합니다. 검색에 실패하면 &lt;a href=&quot;qimagereader#supportedImageFormats&quot;&gt;기존 이미지 파일 형식&lt;/a&gt; 의 파일 확장자로 검색을 시도합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="97d2130e7318d6fb8e97bbc72b1da432f38b4f2f" translate="yes" xml:space="preserve">
          <source>If the OpenGL implementation on your system does not support the requested version of OpenGL context, then &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; will try to create the closest matching version. The actual created context properties can be queried using the &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat&lt;/a&gt; returned by the &lt;a href=&quot;qopenglcontext#format&quot;&gt;format&lt;/a&gt;() function. For example, if you request a context that supports OpenGL 4.3 Core profile but the driver and/or hardware only supports version 3.2 Core profile contexts then you will get a 3.2 Core profile context.</source>
          <target state="translated">시스템에서 OpenGL 구현이 요청 된 버전의 OpenGL 컨텍스트를 지원하지 않으면 &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; 는 가장 일치하는 버전을 작성하려고 시도합니다. 실제로 작성된 컨텍스트 특성은 &lt;a href=&quot;qopenglcontext#format&quot;&gt;format&lt;/a&gt; () 함수가 리턴 한 &lt;a href=&quot;qsurfaceformat&quot;&gt;QSurfaceFormat을&lt;/a&gt; 사용하여 조회 할 수 있습니다 . 예를 들어 OpenGL 4.3 Core 프로파일을 지원하는 컨텍스트를 요청하지만 드라이버 및 / 또는 하드웨어가 버전 3.2 Core 프로파일 컨텍스트 만 지원하는 경우 3.2 Core 프로파일 컨텍스트를 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="8d7121dcef2e5171c37556cface26d4fb49e0c68" translate="yes" xml:space="preserve">
          <source>If the OpenGL implementation uses EGL (most OpenGL/ES systems), then &lt;a href=&quot;#qmake-incdir-egl&quot;&gt;QMAKE_INCDIR_EGL&lt;/a&gt; may also need to be set.</source>
          <target state="translated">OpenGL 구현이 EGL (대부분의 OpenGL / ES 시스템)을 사용하는 경우 &lt;a href=&quot;#qmake-incdir-egl&quot;&gt;QMAKE_INCDIR_EGL&lt;/a&gt; 도 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff5a67f36eeaa10961a2219b877d2d23d36fa6fd" translate="yes" xml:space="preserve">
          <source>If the OpenGL implementation uses EGL (most OpenGL/ES systems), then &lt;a href=&quot;#qmake-libdir-egl&quot;&gt;QMAKE_LIBDIR_EGL&lt;/a&gt; may also need to be set.</source>
          <target state="translated">OpenGL 구현이 EGL (대부분의 OpenGL / ES 시스템)을 사용하는 경우 &lt;a href=&quot;#qmake-libdir-egl&quot;&gt;QMAKE_LIBDIR_EGL&lt;/a&gt; 도 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="007ce14ff096d43e4e7697d5e3b936aff86ab395" translate="yes" xml:space="preserve">
          <source>If the OpenGL implementation uses EGL (most OpenGL/ES systems), then &lt;a href=&quot;#qmake-libs-egl&quot;&gt;QMAKE_LIBS_EGL&lt;/a&gt; may also need to be set.</source>
          <target state="translated">OpenGL 구현이 EGL (대부분의 OpenGL / ES 시스템)을 사용하는 경우 &lt;a href=&quot;#qmake-libs-egl&quot;&gt;QMAKE_LIBS_EGL&lt;/a&gt; 도 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="365e361ce460f659bafaaa88529693b04fff31d9" translate="yes" xml:space="preserve">
          <source>If the QML is not defined until runtime, you can create a QML object from a string of QML using the &lt;a href=&quot;qml-qtqml-qt#createQmlObject-method&quot;&gt;Qt.createQmlObject()&lt;/a&gt; function, as in the following example:</source>
          <target state="translated">런타임까지 QML이 정의되지 않은 경우 다음 예와 같이 &lt;a href=&quot;qml-qtqml-qt#createQmlObject-method&quot;&gt;Qt.createQmlObject ()&lt;/a&gt; 함수를 사용하여 QML 문자열에서 QML 오브젝트를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c52942598866b253aafa767bb4261a31182946e7" translate="yes" xml:space="preserve">
          <source>If the QML item needs to receive signals from the context property, it can connect to them using the &lt;a href=&quot;qml-qtqml-connections&quot;&gt;Connections&lt;/a&gt; type. For example, if &lt;code&gt;ApplicationData&lt;/code&gt; has a signal named &lt;code&gt;dataChanged()&lt;/code&gt;, this signal can be connected to using an &lt;code&gt;onDataChanged&lt;/code&gt; handler within a &lt;a href=&quot;qml-qtqml-connections&quot;&gt;Connections&lt;/a&gt; object:</source>
          <target state="translated">QML 항목이 컨텍스트 특성에서 신호를 수신해야하는 경우 &lt;a href=&quot;qml-qtqml-connections&quot;&gt;연결&lt;/a&gt; 유형을 사용하여 연결할 수 있습니다 . 예를 들어 &lt;code&gt;ApplicationData&lt;/code&gt; 에 &lt;code&gt;dataChanged()&lt;/code&gt; 라는 신호가있는 경우이 신호는 &lt;a href=&quot;qml-qtqml-connections&quot;&gt;Connections&lt;/a&gt; 객체 내의 &lt;code&gt;onDataChanged&lt;/code&gt; 핸들러 를 사용하여 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3869c2293c2b4cba3d2eaa8c57db80f2cd047504" translate="yes" xml:space="preserve">
          <source>If the SSL handshake is successful, &lt;a href=&quot;qsslsocket&quot;&gt;QSslSocket&lt;/a&gt; emits &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;encrypted&lt;/a&gt;().</source>
          <target state="translated">SSL 데이터 &lt;a href=&quot;qsslsocket&quot;&gt;교환에&lt;/a&gt; 성공하면 QSslSocket 은 &lt;a href=&quot;qsslsocket#encrypted&quot;&gt;암호화 된&lt;/a&gt; ()을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f9112871aee14ae94421006ed8b3c09662b0a739" translate="yes" xml:space="preserve">
          <source>If the Timer is not running it will be started, otherwise it will be stopped, reset to initial state and started. The &lt;code&gt;running&lt;/code&gt; property will be true following a call to &lt;code&gt;restart()&lt;/code&gt;.</source>
          <target state="translated">타이머가 실행되고 있지 않으면 시작되고, 그렇지 않으면 중지되고 초기 상태로 재설정되어 시작됩니다. &lt;code&gt;running&lt;/code&gt; 속성을 호출 다음 중 하나에 해당 될 것입니다 &lt;code&gt;restart()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2e6888f0e2cc65277a0fac1bf33dc13a3b7b8e2" translate="yes" xml:space="preserve">
          <source>If the Timer is running and one of its properties is changed, the elapsed time will be reset. For example, if a Timer with interval of 1000ms has its</source>
          <target state="translated">타이머가 실행 중이고 해당 속성 중 하나가 변경되면 경과 시간이 재설정됩니다. 예를 들어 간격이 1000ms 인 타이머의 타이머가</target>
        </trans-unit>
        <trans-unit id="4411b7c422b558c9ae9b70b3f53e625bf31f81b9" translate="yes" xml:space="preserve">
          <source>If the URL contains more components (for example, a query string) after the example path, \1 can be used as a placeholder for the path:</source>
          <target state="translated">URL에 예제 경로 뒤에 추가 구성 요소 (예 : 쿼리 문자열)가 포함 된 경우 \ 1을 경로의 자리 표시 자로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f659afc989b66ba92782ea2a04546c51f55ee39" translate="yes" xml:space="preserve">
          <source>If the URL is a local file according to &lt;a href=&quot;qurl#isLocalFile&quot;&gt;isLocalFile&lt;/a&gt;() and contains no query or fragment, a local file path is returned.</source>
          <target state="translated">URL이 &lt;a href=&quot;qurl#isLocalFile&quot;&gt;isLocalFile&lt;/a&gt; () 에 따라 로컬 파일 이고 쿼리 나 조각이 포함되어 있지 않으면 로컬 파일 경로가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="36ee060e77a2c25fbac57eb717623bacd315b5bb" translate="yes" xml:space="preserve">
          <source>If the URL is a local file, this calls &lt;a href=&quot;qmimedatabase#mimeTypeForFile&quot;&gt;mimeTypeForFile&lt;/a&gt;.</source>
          <target state="translated">URL이 로컬 파일 인 경우 &lt;a href=&quot;qmimedatabase#mimeTypeForFile&quot;&gt;mimeTypeForFile을&lt;/a&gt; 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="dbb33236cf6cc560bbc8bc1babe0ae8afbba93a7" translate="yes" xml:space="preserve">
          <source>If the URL is a reference to a local file (i.e., the URL scheme is &quot;file&quot;) then it will be opened with a suitable application instead of a Web browser.</source>
          <target state="translated">URL이 로컬 파일에 대한 참조 인 경우 (예 : URL 스킴이 &quot;file&quot;) 웹 브라우저 대신 적절한 응용 프로그램으로 열립니다.</target>
        </trans-unit>
        <trans-unit id="c2dd5d75e9b1db5a965a86a3900c96f88e94f382" translate="yes" xml:space="preserve">
          <source>If the URL passed to &lt;a href=&quot;qqmlcomponent&quot;&gt;QQmlComponent&lt;/a&gt; is a network resource, or if the QML document references a network resource, the &lt;a href=&quot;qqmlcomponent&quot;&gt;QQmlComponent&lt;/a&gt; has to fetch the network data before it is able to create objects. In this case, the &lt;a href=&quot;qqmlcomponent&quot;&gt;QQmlComponent&lt;/a&gt; will have a &lt;a href=&quot;qqmlcomponent#Status-enum&quot;&gt;Loading&lt;/a&gt;&lt;a href=&quot;qqmlcomponent#status-prop&quot;&gt;status&lt;/a&gt;. An application will have to wait until the component is &lt;a href=&quot;qqmlcomponent#Status-enum&quot;&gt;Ready&lt;/a&gt; before calling &lt;a href=&quot;qqmlcomponent#create&quot;&gt;QQmlComponent::create&lt;/a&gt;().</source>
          <target state="translated">&lt;a href=&quot;qqmlcomponent&quot;&gt;QQmlComponent에&lt;/a&gt; 전달 된 URL 이 네트워크 자원이거나 QML 문서가 네트워크 자원을 참조하는 경우 &lt;a href=&quot;qqmlcomponent&quot;&gt;QQmlComponent&lt;/a&gt; 는 오브젝트를 작성하기 전에 네트워크 데이터를 페치해야합니다. 이 경우 &lt;a href=&quot;qqmlcomponent&quot;&gt;QQmlComponent&lt;/a&gt; 는 &lt;a href=&quot;qqmlcomponent#Status-enum&quot;&gt;Loading &lt;/a&gt;&lt;a href=&quot;qqmlcomponent#status-prop&quot;&gt;상태가&lt;/a&gt; 됩니다. &lt;a href=&quot;qqmlcomponent#create&quot;&gt;QQmlComponent :: create&lt;/a&gt; ()를 호출하기 전에 구성 요소가 &lt;a href=&quot;qqmlcomponent#Status-enum&quot;&gt;준비&lt;/a&gt; 될 때까지 애플리케이션이 대기해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3c1d0125f5f4ebf60d58a278d4306d87bd03b636" translate="yes" xml:space="preserve">
          <source>If the Universal style is imported in a QML file that is always loaded, the Universal style must be deployed with the application in order to be able to run the application regardless of which style the application is run with. By using &lt;a href=&quot;qtquickcontrols2-fileselectors#&quot;&gt;file selectors&lt;/a&gt;, style-specific tweaks can be applied without creating a hard dependency to a style.</source>
          <target state="translated">유니버설 스타일을 항상로드되는 QML 파일로 가져 오는 경우, 애플리케이션이 실행되는 스타일에 관계없이 애플리케이션을 실행할 수 있으려면 유니버설 스타일을 애플리케이션과 함께 배치해야합니다. &lt;a href=&quot;qtquickcontrols2-fileselectors#&quot;&gt;파일 선택기&lt;/a&gt; 를 사용 하면 스타일에 대한 엄격한 종속성을 만들지 않고도 스타일 별 조정을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36c24d01299c2c6244068f653391b307ae0b5104" translate="yes" xml:space="preserve">
          <source>If the \endlegalese command is omitted, QDoc will process the \legalese command but considers the rest of the documentation page as the license agreement.</source>
          <target state="translated">\ endlegalese 명령이 생략되면 QDoc은 \ legalese 명령을 처리하지만 나머지 문서 페이지는 라이센스 계약으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="58694bb09ffa0b189fafff98f57e6bb75452eb05" translate="yes" xml:space="preserve">
          <source>If the above conditions cannot be met, the ArcGIS Online subscription is the correct choice, as it gives applications full access to the ArcGIS platform.</source>
          <target state="translated">위의 조건을 충족 할 수없는 경우 ArcGIS Online 구독은 응용 프로그램이 ArcGIS 플랫폼에 완전히 액세스 할 수있게하므로 올바른 선택입니다.</target>
        </trans-unit>
        <trans-unit id="4b9e9bd0ef4ebe1ff5fb4802d298c09a24f64527" translate="yes" xml:space="preserve">
          <source>If the action is &lt;a href=&quot;qml-qtquick-controls-action#checkable-prop&quot;&gt;checkable&lt;/a&gt;, this property reflects its checked state. Defaults to &lt;code&gt;false&lt;/code&gt;. Its value is also false while &lt;a href=&quot;qml-qtquick-controls-action#checkable-prop&quot;&gt;checkable&lt;/a&gt; is false.</source>
          <target state="translated">조치가 점검 &lt;a href=&quot;qml-qtquick-controls-action#checkable-prop&quot;&gt;가능한&lt;/a&gt; 경우이 특성은 점검 된 상태를 반영합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다. &lt;a href=&quot;qml-qtquick-controls-action#checkable-prop&quot;&gt;검사 가능&lt;/a&gt; 이 false 인 동안 해당 값도 false입니다.</target>
        </trans-unit>
        <trans-unit id="d8c7cc1c88277c0cf9099b88e06b59c11e9f4bfa" translate="yes" xml:space="preserve">
          <source>If the action is added to a menu, the menu option will consist of the icon (if there is one), the text, and the shortcut (if there is one). If the text is not explicitly set in the constructor, or by using setText(), the action's description icon text will be used as text. There is no default text.</source>
          <target state="translated">작업이 메뉴에 추가되면 메뉴 옵션은 아이콘 (있는 경우), 텍스트 및 바로 가기 (있는 경우)로 구성됩니다. 생성자가 텍스트를 명시 적으로 설정하지 않거나 setText ()를 사용하면 액션의 설명 아이콘 텍스트가 텍스트로 사용됩니다. 기본 텍스트가 없습니다.</target>
        </trans-unit>
        <trans-unit id="45fbe1b53d6a84db721d801b845ffbf6cb081031" translate="yes" xml:space="preserve">
          <source>If the action is checkable,</source>
          <target state="translated">조치가 확인 가능한 경우</target>
        </trans-unit>
        <trans-unit id="c8b547b1f743518e9752cee3be27e99db0b2000b" translate="yes" xml:space="preserve">
          <source>If the action is removed from a container widget then &lt;a href=&quot;qwidgetaction#deleteWidget&quot;&gt;QWidgetAction::deleteWidget&lt;/a&gt;() is called with the previously created custom widget as argument. The default implementation hides the widget and deletes it using &lt;a href=&quot;qobject#deleteLater&quot;&gt;QObject::deleteLater&lt;/a&gt;().</source>
          <target state="translated">컨테이너 위젯에서 조치가 제거 되면 이전에 작성된 사용자 정의 위젯을 인수로 사용하여 &lt;a href=&quot;qwidgetaction#deleteWidget&quot;&gt;QWidgetAction :: deleteWidget&lt;/a&gt; ()이 호출됩니다. 기본 구현은 위젯을 숨기고 &lt;a href=&quot;qobject#deleteLater&quot;&gt;QObject :: deleteLater&lt;/a&gt; ()를 사용하여 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="f3e094d405e175530f134338a3d5de0e147dc0e7" translate="yes" xml:space="preserve">
          <source>If the angular distance between two consecutive points in a series is more than 180 degrees, any direct line connecting the two points becomes meaningless, and will not be drawn. Instead, a line will be drawn to and from the center of the chart. Therefore, the axis ranges must be chosen accordingly when displaying line, spline, or area series.</source>
          <target state="translated">연속 된 두 점 사이의 각도 거리가 180도를 초과하면 두 점을 연결하는 모든 직선이 의미가 없어져 그려지지 않습니다. 대신, 차트 중앙을 오가는 선이 그려집니다. 따라서 선, 스플라인 또는 영역 시리즈를 표시 할 때 축 범위를 적절하게 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="a73ac2317f2d4d6cde1666aaf871fc4385dc0ea0" translate="yes" xml:space="preserve">
          <source>If the animation is a parallel &lt;a href=&quot;qanimationgroup&quot;&gt;QAnimationGroup&lt;/a&gt;, the duration will be the longest duration of all its animations. If the animation is a sequential &lt;a href=&quot;qanimationgroup&quot;&gt;QAnimationGroup&lt;/a&gt;, the duration will be the sum of the duration of all its animations.</source>
          <target state="translated">애니메이션이 병렬 &lt;a href=&quot;qanimationgroup&quot;&gt;QAnimationGroup&lt;/a&gt; 인 경우 지속 시간은 모든 애니메이션의 가장 긴 지속 시간입니다. 애니메이션이 순차적 &lt;a href=&quot;qanimationgroup&quot;&gt;QAnimationGroup&lt;/a&gt; 이면 지속 ​​시간은 모든 애니메이션 지속 시간의 합입니다.</target>
        </trans-unit>
        <trans-unit id="ec3faacce6edc490060ffd9f68c6630bc2de0dc7" translate="yes" xml:space="preserve">
          <source>If the animation is already paused or not &lt;code&gt;running&lt;/code&gt;, calling this method has no effect. The &lt;code&gt;paused&lt;/code&gt; property will be true following a call to &lt;code&gt;pause()&lt;/code&gt;.</source>
          <target state="translated">애니메이션이 이미 일시 중지되었거나 &lt;code&gt;running&lt;/code&gt; 아닌 경우이 메서드를 호출해도 아무런 영향이 없습니다. &lt;code&gt;paused&lt;/code&gt; 속성을 호출 다음과 같은 사실이 될 것이다 &lt;code&gt;pause()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab62f01ffc3dbefa884c1b7055c73c8020f1b07b" translate="yes" xml:space="preserve">
          <source>If the animation is already running, calling this method has no effect. The &lt;code&gt;running&lt;/code&gt; property will be true following a call to &lt;code&gt;start()&lt;/code&gt;.</source>
          <target state="translated">애니메이션이 이미 실행중인 경우이 메서드를 호출해도 효과가 없습니다. &lt;code&gt;running&lt;/code&gt; 속성에 대한 호출 다음 중 하나에 해당 될 것입니다 &lt;code&gt;start()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2f2b16a386091ec932058076dfff0087bf60a67" translate="yes" xml:space="preserve">
          <source>If the animation is already running, this function does nothing.</source>
          <target state="translated">애니메이션이 이미 실행중인 경우이 기능은 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07b64b34984cc2a60502c4d7bd103c3aa19abf00" translate="yes" xml:space="preserve">
          <source>If the animation is currently stopped or has already reached the end, calling start() will rewind the animation and start again from the beginning. When the animation reaches the end, the animation will either stop, or if the loop level is more than 1, it will rewind and continue from the beginning.</source>
          <target state="translated">애니메이션이 현재 중지되었거나 이미 끝에 도달 한 경우 start ()를 호출하면 애니메이션이 되 감고 처음부터 다시 시작됩니다. 애니메이션이 끝에 도달하면 애니메이션이 중지되거나 루프 수준이 1보다 크면 되감기되어 처음부터 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="c13ae78771eb733faf8daee5faefdac4ad947321" translate="yes" xml:space="preserve">
          <source>If the animation is not paused or not &lt;code&gt;running&lt;/code&gt;, calling this method has no effect. The &lt;code&gt;paused&lt;/code&gt; property will be false following a call to &lt;code&gt;resume()&lt;/code&gt;.</source>
          <target state="translated">애니메이션이 일시 중지되지 않았거나 &lt;code&gt;running&lt;/code&gt; 있지 않으면 이 메서드를 호출해도 아무런 영향이 없습니다. &lt;code&gt;paused&lt;/code&gt; 속성을 호출 다음과 같은 잘못된 것 &lt;code&gt;resume()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1772d8d69db30a57d46d1d5b791bcee0b16b46a" translate="yes" xml:space="preserve">
          <source>If the animation is not running, calling this method has no effect. Both the &lt;code&gt;running&lt;/code&gt; and &lt;code&gt;paused&lt;/code&gt; properties will be false following a call to &lt;code&gt;stop()&lt;/code&gt;.</source>
          <target state="translated">애니메이션이 실행되고 있지 않으면이 메서드를 호출해도 아무런 영향이 없습니다. &lt;code&gt;stop()&lt;/code&gt; 호출 하면 &lt;code&gt;running&lt;/code&gt; 및 &lt;code&gt;paused&lt;/code&gt; 속성이 모두 false 입니다.</target>
        </trans-unit>
        <trans-unit id="7a5aeb336f108cfde5a73ce5eec1b4f394dcd14e" translate="yes" xml:space="preserve">
          <source>If the animation is not running, calling this method has no effect. The &lt;code&gt;running&lt;/code&gt; property will be false following a call to &lt;code&gt;complete()&lt;/code&gt;.</source>
          <target state="translated">애니메이션이 실행되고 있지 않으면이 메서드를 호출해도 아무런 영향이 없습니다. &lt;code&gt;running&lt;/code&gt; 속성을 호출 다음과 같은 잘못된 것 &lt;code&gt;complete()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="213ad672e547f37784eabbc9bc7adc3e67e66e02" translate="yes" xml:space="preserve">
          <source>If the animation properties changed, calling this method to reload the animation definations.</source>
          <target state="translated">애니메이션 속성이 변경된 경우이 메서드를 호출하여 애니메이션 정의를 다시로드하십시오.</target>
        </trans-unit>
        <trans-unit id="d7ff111f90354770ec0f19f41693c70b7777aeae" translate="yes" xml:space="preserve">
          <source>If the animation stops by itself after reaching the end (i.e., &lt;a href=&quot;qabstractanimation#currentLoopTime&quot;&gt;currentLoopTime&lt;/a&gt;() == &lt;a href=&quot;qabstractanimation#duration&quot;&gt;duration&lt;/a&gt;() and &lt;a href=&quot;qabstractanimation#currentLoop-prop&quot;&gt;currentLoop&lt;/a&gt;() &amp;gt; &lt;a href=&quot;qabstractanimation#loopCount-prop&quot;&gt;loopCount&lt;/a&gt;() - 1), the &lt;a href=&quot;qabstractanimation#finished&quot;&gt;finished&lt;/a&gt;() signal is emitted.</source>
          <target state="translated">끝 (예 : &lt;a href=&quot;qabstractanimation#currentLoopTime&quot;&gt;currentLoopTime&lt;/a&gt; () == &lt;a href=&quot;qabstractanimation#duration&quot;&gt;duration&lt;/a&gt; () 및 &lt;a href=&quot;qabstractanimation#currentLoop-prop&quot;&gt;currentLoop&lt;/a&gt; ()&amp;gt; &lt;a href=&quot;qabstractanimation#loopCount-prop&quot;&gt;loopCount&lt;/a&gt; ()-1) 에 도달 한 후 애니메이션 자체가 중지 되면 &lt;a href=&quot;qabstractanimation#finished&quot;&gt;완료된&lt;/a&gt; () 신호가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a24eddc7009a4e909fac30e4f8985f1950ebec8b" translate="yes" xml:space="preserve">
          <source>If the application can handle files that don't exist yet, it should pass the flag &lt;a href=&quot;qurl#UserInputResolutionOption-enum&quot;&gt;AssumeLocalFile&lt;/a&gt; in</source>
          <target state="translated">응용 프로그램에서 아직 존재하지 않는 파일을 처리 할 수 ​​있으면 &lt;a href=&quot;qurl#UserInputResolutionOption-enum&quot;&gt;AssumeLocalFile&lt;/a&gt; 플래그를 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="19112ce1ec27fc25656c3af926cbfb90c4a338cf" translate="yes" xml:space="preserve">
          <source>If the application changes its mind while saving, it can call cancelWriting(), which sets an error code so that &lt;a href=&quot;qsavefile#commit&quot;&gt;commit&lt;/a&gt;() will discard the temporary file.</source>
          <target state="translated">응용 프로그램이 저장하는 동안 마음이 바뀌면 cancelWriting ()을 호출하여 &lt;a href=&quot;qsavefile#commit&quot;&gt;commit&lt;/a&gt; ()이 임시 파일을 삭제 하도록 오류 코드를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="a78ca2f5e1da51f3197d9361a4b0c66044ea3059" translate="yes" xml:space="preserve">
          <source>If the application has been restored from an earlier session, this identifier is the same as it was in that previous session. The session identifier is guaranteed to be unique both for different applications and for different instances of the same application.</source>
          <target state="translated">응용 프로그램이 이전 세션에서 복원 된 경우이 식별자는 이전 세션에서와 동일합니다. 세션 식별자는 다른 응용 프로그램과 동일한 응용 프로그램의 다른 인스턴스에 대해 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="19e13ce8b8b1ddcf5b6792f170de693320389f09" translate="yes" xml:space="preserve">
          <source>If the application has been restored from an earlier session, this identifier is the same as it was in the earlier session.</source>
          <target state="translated">응용 프로그램이 이전 세션에서 복원 된 경우이 식별자는 이전 세션과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="61131594650cf5c60c4c9d5eea8a5d98d2375836" translate="yes" xml:space="preserve">
          <source>If the application has been restored from an earlier session, this key is the same as it was when the previous session ended.</source>
          <target state="translated">응용 프로그램이 이전 세션에서 복원 된 경우이 키는 이전 세션이 종료되었을 때와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="75145b02a29dd165daa8373e8f062449cfecce16" translate="yes" xml:space="preserve">
          <source>If the application intends to allow users to purchase products, it also needs to listen for the &lt;a href=&quot;qinappstore#transactionReady&quot;&gt;QInAppStore::transactionReady&lt;/a&gt;() signal to be notified when a transaction is pending.</source>
          <target state="translated">응용 프로그램에서 사용자가 제품을 구매할 수있게하려면 트랜잭션이 보류 중일 때 알림을받을 &lt;a href=&quot;qinappstore#transactionReady&quot;&gt;QInAppStore :: transactionReady&lt;/a&gt; () 신호를 수신해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f02d74c5dad21abdff91266fba2344ed58c9b10" translate="yes" xml:space="preserve">
          <source>If the application is in &lt;code&gt;WhatsThis&lt;/code&gt; mode the shortcut will not emit the signals, but will show the &quot;What's This?&quot; text instead.</source>
          <target state="translated">응용 프로그램이 &lt;code&gt;WhatsThis&lt;/code&gt; 모드 인 경우 바로 가기는 신호를 방출하지 않지만 &quot;What 's This?&quot;를 표시합니다. 대신 텍스트.</target>
        </trans-unit>
        <trans-unit id="8452440bda5fd3df4005e6157ad66d296cf97bb6" translate="yes" xml:space="preserve">
          <source>If the application is still running when the session is shut down, it wants to be restarted at the start of the next session.</source>
          <target state="translated">세션이 종료 될 때 응용 프로그램이 여전히 실행 중이면 다음 세션이 시작될 때 응용 프로그램을 다시 시작하려고합니다.</target>
        </trans-unit>
        <trans-unit id="d539813098901c7f9f4150e76338a1147a08bd0c" translate="yes" xml:space="preserve">
          <source>If the application is unable to write to the location specified by &lt;code&gt;location&lt;/code&gt; the &lt;a href=&quot;qml-qtmultimedia-cameracapture&quot;&gt;CameraCapture&lt;/a&gt; will emit an error. The most likely reasons for the application to be unable to write to a location is that the path is wrong and the location does not exists, or the application does not have write permission for that location.</source>
          <target state="translated">응용 프로그램에 의해 지정된 위치에 쓸 수없는 경우 &lt;code&gt;location&lt;/code&gt; &lt;a href=&quot;qml-qtmultimedia-cameracapture&quot;&gt;CameraCapture는&lt;/a&gt; 오류가 방출됩니다. 응용 프로그램이 위치에 쓸 수없는 가장 큰 이유는 경로가 잘못되어 해당 위치가 없거나 응용 프로그램에 해당 위치에 대한 쓰기 권한이 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="382a8d62bc3d46c06c84bd22a3496699fd886be5" translate="yes" xml:space="preserve">
          <source>If the application is uninstalled and subsequently reinstalled (or installed by the same user on a different device) you should provide a way to restore the previously purchased unlockable products in the external market place.</source>
          <target state="translated">응용 프로그램을 제거한 후 다시 설치하거나 동일한 사용자가 다른 장치에 설치 한 경우 이전에 구입 한 잠금 해제 가능한 제품을 외부 시장에서 복원 할 수있는 방법을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="654718941a80f92a2ba7c5f9cf9b7f1705aaac05" translate="yes" xml:space="preserve">
          <source>If the application is uninstalled and subsequently reinstalled (or installed by the same user on a different device), you must provide a way to restore the previously purchased unlockable products.</source>
          <target state="translated">응용 프로그램을 제거한 후 다시 설치하거나 동일한 사용자가 다른 장치에 설치 한 경우 이전에 구입 한 잠금 해제 가능한 제품을 복원 할 수있는 방법을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="6caae6c479676e34fb282a23e2e47776763a61c2" translate="yes" xml:space="preserve">
          <source>If the application needs to be informed of basic parsing events, it can implement this interface and activate it using &lt;a href=&quot;qxmlreader#setContentHandler&quot;&gt;QXmlReader::setContentHandler&lt;/a&gt;(). The reader can then report basic document-related events like the start and end of elements and character data through this interface.</source>
          <target state="translated">응용 프로그램에 기본 구문 분석 이벤트에 대한 정보가 필요한 경우이 인터페이스를 구현하고 &lt;a href=&quot;qxmlreader#setContentHandler&quot;&gt;QXmlReader :: setContentHandler&lt;/a&gt; ()를 사용하여 활성화 할 수 있습니다 . 그런 다음 독자는이 인터페이스를 통해 요소의 시작 및 끝 및 문자 데이터와 같은 기본 문서 관련 이벤트를보고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6a3f6df53ca1c4caeeba06ab9fddc33f6653515" translate="yes" xml:space="preserve">
          <source>If the argument contains spaces or other punctuation, enclose the argument in curly brackets.</source>
          <target state="translated">인수에 공백이나 다른 문장 부호가 있으면 인수를 중괄호로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="19c3d074a0f01647a5c297a03eb52eb6e47cd651" translate="yes" xml:space="preserve">
          <source>If the array is empty, this function returns a &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; containing an undefined value. For that reason, it is not possible with this function to tell apart the situation where the array is not large enough from the case where the array ends with an undefined value.</source>
          <target state="translated">배열이 비어 있으면이 함수는 정의되지 않은 값을 포함하는 &lt;a href=&quot;qcborvalue&quot;&gt;QCborValue&lt;/a&gt; 를 반환 합니다. 따라서이 함수를 사용하면 배열이 정의되지 않은 값으로 끝나는 경우와 배열이 충분히 크지 않은 상황을 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="98443c8aae77dcccbc818bdacd67789c3b570f92" translate="yes" xml:space="preserve">
          <source>If the array is smaller than</source>
          <target state="translated">배열이보다 작은 경우</target>
        </trans-unit>
        <trans-unit id="48cd30d0d04470542d073bc60120f9e379458c2f" translate="yes" xml:space="preserve">
          <source>If the associated controller object is in the &lt;a href=&quot;qlowenergycontroller#Role-enum&quot;&gt;central&lt;/a&gt; role, this signal is emitted when the value of</source>
          <target state="translated">연관된 제어기 오브젝트가 &lt;a href=&quot;qlowenergycontroller#Role-enum&quot;&gt;중심&lt;/a&gt; 역할에있는 경우이 신호는</target>
        </trans-unit>
        <trans-unit id="1a133b796a2e717bb6bc7de075b2da6c46dfe5f8" translate="yes" xml:space="preserve">
          <source>If the attachee item is not currently associated with any graphical surface, the properties are set to the values of the default surface format. When it becomes associated with a surface, all properties will update.</source>
          <target state="translated">부착물 항목이 현재 그래픽 표면과 연결되어 있지 않은 경우 속성은 기본 표면 형식의 값으로 설정됩니다. 지표면과 연관되면 모든 특성이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="eda07ac976affd9e4411f4ad3e957e44ce9a622c" translate="yes" xml:space="preserve">
          <source>If the attribute describes the position for the vertex, the</source>
          <target state="translated">속성이 정점의 위치를 ​​설명하는 경우</target>
        </trans-unit>
        <trans-unit id="76b2ff4b8973a440686f21404eddebebe7c03389" translate="yes" xml:space="preserve">
          <source>If the attribute is &quot;true&quot;, the value is not meant to be translated.</source>
          <target state="translated">속성이 &quot;true&quot;인 경우 값은 변환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8e49bc02b0244f374df93e6fad2d1f555944cce" translate="yes" xml:space="preserve">
          <source>If the author of CppType adds a &lt;code&gt;root&lt;/code&gt; property to CppType in a new version of their type definition, &lt;code&gt;root.x&lt;/code&gt; now resolves to a different value because &lt;code&gt;root&lt;/code&gt; is also the &lt;code&gt;id&lt;/code&gt; of the top level component. The author could specify that the new &lt;code&gt;root&lt;/code&gt; property is available from a specific minor version. This permits new properties and features to be added to existing types without breaking existing programs.</source>
          <target state="translated">CppType의 저자가 추가하는 경우 &lt;code&gt;root&lt;/code&gt; 자신의 유형 정의의 새 버전에 CppType에 속성을 &lt;code&gt;root.x&lt;/code&gt; 가 있기 때문에 지금은 다른 값으로 해결 &lt;code&gt;root&lt;/code&gt; 도 있습니다 &lt;code&gt;id&lt;/code&gt; 최고 수준의 구성 요소. 작성자 는 특정 부 버전에서 새 &lt;code&gt;root&lt;/code&gt; 속성을 사용할 수 있도록 지정할 수 있습니다. 이를 통해 기존 프로그램을 중단하지 않고 기존 유형에 새로운 특성 및 기능을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="866d8d479aed97743905191dce84ed5f7e5b245a" translate="yes" xml:space="preserve">
          <source>If the backend has lost its reference to the reading it can call this method to get the address.</source>
          <target state="translated">백엔드가 판독 값에 대한 참조를 잃어버린 경우이 메소드를 호출하여 주소를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8eca0d3518ec5d526af344dcbd53c4c8246fe1a" translate="yes" xml:space="preserve">
          <source>If the base is non-zero, the parent axis segment count will be ignored when the grid line and label positions are calculated. If you want the range to be divided into equal segments like a normal value axis, set this property value to zero.</source>
          <target state="translated">기준이 0이 아닌 경우 모눈 선 및 레이블 위치를 계산할 때 부모 축 세그먼트 개수가 무시됩니다. 범위를 일반 값 축과 같은 동일한 세그먼트로 나누려면이 속성 값을 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="5cbe4573061932df00aa9605e93f0eeaf4e94816" translate="yes" xml:space="preserve">
          <source>If the bearer type is &lt;a href=&quot;qnetworkconfiguration#BearerType-enum&quot;&gt;unknown&lt;/a&gt; the &lt;a href=&quot;qnetworkconfiguration#bearerTypeName&quot;&gt;bearerTypeName&lt;/a&gt;() function can be used to retrieve a textural type name for the bearer.</source>
          <target state="translated">베어러 유형을 &lt;a href=&quot;qnetworkconfiguration#BearerType-enum&quot;&gt;알 수없는&lt;/a&gt; 경우 &lt;a href=&quot;qnetworkconfiguration#bearerTypeName&quot;&gt;bearerTypeName&lt;/a&gt; () 함수를 사용하여 베어러의 텍스처 유형 이름을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46a0022e35075cbed766bb651df4db0a349f487c" translate="yes" xml:space="preserve">
          <source>If the block has no explicit direction set, it will resolve the direction from the blocks content. Returns either &lt;a href=&quot;qt#LayoutDirection-enum&quot;&gt;Qt::LeftToRight&lt;/a&gt; or &lt;a href=&quot;qt#LayoutDirection-enum&quot;&gt;Qt::RightToLeft&lt;/a&gt;.</source>
          <target state="translated">블록에 명시적인 방향이 설정되어 있지 않으면 블록 내용의 방향을 결정합니다. &lt;a href=&quot;qt#LayoutDirection-enum&quot;&gt;Qt :: LeftToRight&lt;/a&gt; 또는 &lt;a href=&quot;qt#LayoutDirection-enum&quot;&gt;Qt :: RightToLeft를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="3c285daddf26ab92ecdbca9bee75c3440c78f3a6" translate="yes" xml:space="preserve">
          <source>If the block represents a list item, returns the list that the item belongs to; otherwise returns &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">블록이 목록 항목을 나타내는 경우 항목이 속한 목록을 리턴합니다. 그렇지 않으면 &lt;code&gt;nullptr&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="adfeb7b4590f0fdbc88ced5c8080b16a1c1478c6" translate="yes" xml:space="preserve">
          <source>If the blue and the yellow widget are nested on the same level they will be resized such that the yellowWidget is twice as big as the blueWidget</source>
          <target state="translated">파란색과 노란색 위젯이 동일한 레벨에 중첩 된 경우 yellowWidget이 blueWidget의 두 배가되도록 크기가 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="0d69f494343718f0fe05d5313a7cd87d9c0b7ac9" translate="yes" xml:space="preserve">
          <source>If the browser supports WebAssembly, then Qt should run.</source>
          <target state="translated">브라우저가 WebAssembly를 지원하면 Qt를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="39f961c65cf911dbc7947b008521f91668661e85" translate="yes" xml:space="preserve">
          <source>If the buffer size is limited to a certain size, &lt;a href=&quot;qabstractsocket&quot;&gt;QAbstractSocket&lt;/a&gt; won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default.</source>
          <target state="translated">버퍼 크기가 특정 크기로 제한되면 &lt;a href=&quot;qabstractsocket&quot;&gt;QAbstractSocket&lt;/a&gt; 은이 크기 이상의 데이터를 버퍼링하지 않습니다. 예외적으로 버퍼 크기가 0이면 읽기 버퍼가 무제한이며 모든 수신 데이터가 버퍼링됨을 의미합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="bf22e5727fa0a684fe0df62ee2b8af9c7a086078" translate="yes" xml:space="preserve">
          <source>If the buffer size is limited to a certain size, &lt;a href=&quot;qlocalsocket&quot;&gt;QLocalSocket&lt;/a&gt; won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default.</source>
          <target state="translated">버퍼 크기가 특정 크기로 제한되면 &lt;a href=&quot;qlocalsocket&quot;&gt;QLocalSocket&lt;/a&gt; 은이 크기 이상의 데이터를 버퍼링하지 않습니다. 예외적으로 버퍼 크기가 0이면 읽기 버퍼가 무제한이며 모든 수신 데이터가 버퍼링됨을 의미합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="fa64aeec48c20dcf2d49a9352c10620fbbc1cb3a" translate="yes" xml:space="preserve">
          <source>If the buffer size is limited to a certain size, &lt;a href=&quot;qserialport&quot;&gt;QSerialPort&lt;/a&gt; will not buffer more than this size of data. The special case of a buffer size of &lt;code&gt;0&lt;/code&gt; means that the read buffer is unlimited and all incoming data is buffered. This is the default.</source>
          <target state="translated">버퍼 크기가 특정 크기로 제한되면 &lt;a href=&quot;qserialport&quot;&gt;QSerialPort&lt;/a&gt; 는이 크기 이상의 데이터를 버퍼링하지 않습니다. 버퍼 크기가 &lt;code&gt;0&lt;/code&gt; 인 특수한 경우 는 읽기 버퍼가 무제한이며 모든 수신 데이터가 버퍼링됨을 의미합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="8ab4d30cb62ff9c7747c8bc7a7b1eb630afe157b" translate="yes" xml:space="preserve">
          <source>If the buffer size is limited to a certain size, &lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt; won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default. This option is useful if you only read the data at certain points in time (for example, in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.</source>
          <target state="translated">버퍼 크기가 특정 크기로 제한되면 &lt;a href=&quot;qwebsocket&quot;&gt;QWebSocket&lt;/a&gt; 은이 크기 이상의 데이터를 버퍼링하지 않습니다. 예외적으로 버퍼 크기가 0이면 읽기 버퍼가 무제한이며 모든 수신 데이터가 버퍼링됨을 의미합니다. 이것이 기본값입니다. 이 옵션은 특정 시점 (예 : 실시간 스트리밍 애플리케이션)에서만 데이터를 읽거나 소켓이 너무 많은 데이터를 수신하지 않도록 보호하려는 경우 결국 애플리케이션이 부족해질 수 있습니다 기억의.</target>
        </trans-unit>
        <trans-unit id="c55314884668388c06dbb9517268d8a5b418aa7a" translate="yes" xml:space="preserve">
          <source>If the buffer was not mapped with read access, the contents of this buffer will initially be uninitialized.</source>
          <target state="translated">버퍼가 읽기 액세스로 맵핑되지 않은 경우이 버퍼의 컨텐츠는 초기에 초기화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f4745985a23852c82428e6a97e61ac2bc531a88" translate="yes" xml:space="preserve">
          <source>If the built-in validators aren't sufficient, you can subclass &lt;a href=&quot;qvalidator&quot;&gt;QValidator&lt;/a&gt;. The class has two virtual functions: &lt;a href=&quot;qvalidator#validate&quot;&gt;validate&lt;/a&gt;() and &lt;a href=&quot;qvalidator#fixup&quot;&gt;fixup&lt;/a&gt;().</source>
          <target state="translated">내장 된 유효성 검사기가 충분하지 않으면 &lt;a href=&quot;qvalidator&quot;&gt;QValidator&lt;/a&gt; 를 서브 클래스 화할 수 있습니다 . 이 클래스에는 &lt;a href=&quot;qvalidator#validate&quot;&gt;validate&lt;/a&gt; ()와 &lt;a href=&quot;qvalidator#fixup&quot;&gt;fixup&lt;/a&gt; () 이라는 두 가지 가상 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5aa7a0e6776a38e7bebdf6b08e3fb209fbb17c45" translate="yes" xml:space="preserve">
          <source>If the button has already been added, it is removed and added again with the new role.</source>
          <target state="translated">단추가 이미 추가 된 경우 단추가 제거되고 새 역할로 다시 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b63ebc9d1c5ec91f3fe7f811f066414e18532c59" translate="yes" xml:space="preserve">
          <source>If the button has no text, the text() function will return an empty string.</source>
          <target state="translated">버튼에 텍스트가 없으면 text () 함수는 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="71b84ee4ffa6717ec359df60579eb27838958834" translate="yes" xml:space="preserve">
          <source>If the button is a text button with a string containing an ampersand ('&amp;amp;'), &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton&lt;/a&gt; automatically creates a shortcut key. For example:</source>
          <target state="translated">버튼이 앰퍼샌드 ( '&amp;amp;')를 포함하는 문자열이있는 텍스트 버튼 인 경우 &lt;a href=&quot;qabstractbutton&quot;&gt;QAbstractButton은&lt;/a&gt; 자동으로 바로 가기 키를 만듭니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2162fddd59e8855061900635c394f0cdb6da29a7" translate="yes" xml:space="preserve">
          <source>If the button is checkable,</source>
          <target state="translated">버튼을 확인할 수 있으면</target>
        </trans-unit>
        <trans-unit id="330b7f7428a5232cd89e9079f6bd606639160cf0" translate="yes" xml:space="preserve">
          <source>If the button is not a member of any &lt;a href=&quot;qbuttongroup&quot;&gt;QButtonGroup&lt;/a&gt;, this function returns &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">버튼이 &lt;a href=&quot;qbuttongroup&quot;&gt;QButtonGroup&lt;/a&gt; 의 멤버가 아닌 경우 ,이 함수는 &lt;code&gt;nullptr&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="92446e8d511b3b7b59888b3a40e32595448d826b" translate="yes" xml:space="preserve">
          <source>If the byte array being appended to is not empty, a deep copy of the data is performed, taking &lt;a href=&quot;containers#linear-time&quot;&gt;linear time&lt;/a&gt;.</source>
          <target state="translated">추가되는 바이트 배열이 비어 있지 않으면 &lt;a href=&quot;containers#linear-time&quot;&gt;선형 시간&lt;/a&gt; 을 사용하여 데이터의 깊은 사본이 수행 됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8405494fd63e19f44b082aa8cf333535bb90d03" translate="yes" xml:space="preserve">
          <source>If the byte array being prepended to is not empty, a deep copy of the data is performed, taking &lt;a href=&quot;containers#linear-time&quot;&gt;linear time&lt;/a&gt;.</source>
          <target state="translated">앞에 추가되는 바이트 배열이 비어 있지 않으면 &lt;a href=&quot;containers#linear-time&quot;&gt;선형 시간&lt;/a&gt; 을 사용하여 데이터의 깊은 사본이 수행 됩니다 .</target>
        </trans-unit>
        <trans-unit id="47d6ac681ee5e69d47af35d2b81c3a13e006fe16" translate="yes" xml:space="preserve">
          <source>If the cache does not contains a cache item for the url then no action is taken.</source>
          <target state="translated">캐시에 URL에 대한 캐시 항목이 없으면 조치가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ba78c74e99d2812322bc20a627d698ae6baf718" translate="yes" xml:space="preserve">
          <source>If the cache is full then the item at the opposite end of the cache from where the new item is appended or prepended will be removed.</source>
          <target state="translated">캐시가 가득 찬 경우 새 항목이 추가되거나 추가되는 캐시의 반대쪽 끝에있는 항목이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="03f8a070ac93d07243ca625717415af5f0e5dd8e" translate="yes" xml:space="preserve">
          <source>If the calendar widget's &lt;a href=&quot;qcalendarwidget#dateEditEnabled-prop&quot;&gt;date edit is enabled&lt;/a&gt;, this property specifies the amount of time (in millseconds) that the date edit remains open after the most recent user input. Once this time has elapsed, the date specified in the date edit is accepted and the popup is closed.</source>
          <target state="translated">달력 위젯의 &lt;a href=&quot;qcalendarwidget#dateEditEnabled-prop&quot;&gt;날짜 편집이 사용 가능한&lt;/a&gt; 경우이 특성은 가장 최근의 사용자 입력 후에 날짜 편집이 열린 채로 유지되는 시간 (밀리 초)을 지정합니다. 이 시간이 경과하면 날짜 편집에 지정된 날짜가 승인되고 팝업이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="f72074b50b6ef6b231e155e8f73a50f555fb3a17" translate="yes" xml:space="preserve">
          <source>If the call succeeds, &lt;a href=&quot;qdbusabstractinterface#lastError&quot;&gt;lastError&lt;/a&gt;() will be cleared; otherwise, it will contain the error this call produced.</source>
          <target state="translated">호출이 성공하면 &lt;a href=&quot;qdbusabstractinterface#lastError&quot;&gt;lastError&lt;/a&gt; ()가 지워집니다. 그렇지 않으면이 호출에서 발생한 오류가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6bf6ff8712f27c8a44caf4e5da8b57e61a2ef9b6" translate="yes" xml:space="preserve">
          <source>If the call was successful the &lt;a href=&quot;qmodbusserver#dataWritten&quot;&gt;dataWritten&lt;/a&gt;() signal is emitted. Note that the signal is not emitted when</source>
          <target state="translated">호출이 성공하면 &lt;a href=&quot;qmodbusserver#dataWritten&quot;&gt;dataWritten&lt;/a&gt; () 신호가 발생합니다. 신호는 방출되지 않습니다</target>
        </trans-unit>
        <trans-unit id="4823792bf0096e540a9c89dfb504037d30bff5ae" translate="yes" xml:space="preserve">
          <source>If the call was successful the &lt;a href=&quot;qmodbusserver#dataWritten&quot;&gt;dataWritten&lt;/a&gt;() signal is emitted. Note that the signal is not emitted when the addressed register has not changed. This may happen when</source>
          <target state="translated">호출이 성공하면 &lt;a href=&quot;qmodbusserver#dataWritten&quot;&gt;dataWritten&lt;/a&gt; () 신호가 발생합니다. 어드레싱 된 레지스터가 변경되지 않은 경우 신호가 방출되지 않습니다. 이 때 발생할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f21859468db699913648d7d486f7d380941c3288" translate="yes" xml:space="preserve">
          <source>If the camera doesn't support keeping one of parameters between shots, the related lock state changes to &lt;a href=&quot;qcamera#LockStatus-enum&quot;&gt;QCamera::Unlocked&lt;/a&gt;.</source>
          <target state="translated">카메라가 샷간에 매개 변수 중 하나를 유지하는 것을 지원하지 않으면 관련 잠금 상태가 &lt;a href=&quot;qcamera#LockStatus-enum&quot;&gt;QCamera :: Unlocked로&lt;/a&gt; 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="510fe475f837d2c4b26e5d97c657908918a3d6c0" translate="yes" xml:space="preserve">
          <source>If the camera focus mode is set to use an autofocusing mode, this property controls the way the camera will select areas of the frame to use for autofocusing.</source>
          <target state="translated">카메라 초점 모드가 자동 초점 모드를 사용하도록 설정된 경우이 속성은 카메라가 자동 초점에 사용할 프레임 영역을 선택하는 방식을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="b6964e9f6f3019733fc393614d159fc0913839e5" translate="yes" xml:space="preserve">
          <source>If the camera is used to capture videos or images, the viewfinder resolution might be ignored if it conflicts with the capture resolution.</source>
          <target state="translated">카메라를 사용하여 비디오 또는 이미지를 캡처하는 경우 캡처 해상도와 충돌하면 뷰 파인더 해상도가 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c252432ba823711fac0d1b05c60a7fbcd478d8a" translate="yes" xml:space="preserve">
          <source>If the camera is used to capture videos or images, the viewfinder settings might be ignored if they conflict with the capture settings. You can check the actual viewfinder settings once the camera is in the &lt;code&gt;Camera.ActiveStatus&lt;/code&gt; status.</source>
          <target state="translated">카메라를 사용하여 비디오 또는 이미지를 캡처하는 경우 뷰 파인더 설정이 캡처 설정과 충돌하면 무시 될 수 있습니다. 카메라가에되면 당신은 실제 뷰 파인더 설정을 확인할 수 있습니다 &lt;code&gt;Camera.ActiveStatus&lt;/code&gt; 의 상태를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3f4e5fe2611ca2d0329d876013d7f77397290a1d" translate="yes" xml:space="preserve">
          <source>If the camera is used to capture videos or images, the viewfinder settings might be ignored if they conflict with the capture settings. You can check the actual viewfinder settings once the camera is in the &lt;code&gt;QCamera::ActiveStatus&lt;/code&gt; status.</source>
          <target state="translated">카메라를 사용하여 비디오 또는 이미지를 캡처하는 경우 뷰 파인더 설정이 캡처 설정과 충돌하면 무시 될 수 있습니다. 카메라가 &lt;code&gt;QCamera::ActiveStatus&lt;/code&gt; 상태에 있으면 실제 뷰 파인더 설정을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a8cc81bd8544bd70219ed543a50586968ec8d181" translate="yes" xml:space="preserve">
          <source>If the camera supports arbitrary ISO sensitivities within the supported range, *</source>
          <target state="translated">카메라가 지원되는 범위 내에서 임의의 ISO 감도를 지원하는 경우 *</target>
        </trans-unit>
        <trans-unit id="b40907928e4d65de7e7fc9d28336cb932bbb1223" translate="yes" xml:space="preserve">
          <source>If the camera supports arbitrary aperture values within the supported range, *</source>
          <target state="translated">카메라가 지원되는 범위 내에서 임의의 조리개 값을 지원하는 경우 *</target>
        </trans-unit>
        <trans-unit id="742595295fc8b5abeebdd54bfe4aeeceaa48c5f0" translate="yes" xml:space="preserve">
          <source>If the camera supports arbitrary exposure parameter value within the supported range, *</source>
          <target state="translated">카메라가 지원되는 범위 내에서 임의 노출 값을 지원하는 경우 *</target>
        </trans-unit>
        <trans-unit id="4cf78b0c8478275846f30793e73e28583df2a4b6" translate="yes" xml:space="preserve">
          <source>If the camera supports arbitrary shutter speed values within the supported range, *</source>
          <target state="translated">카메라가 지원되는 범위 내에서 임의의 셔터 속도 값을 지원하는 경우 *</target>
        </trans-unit>
        <trans-unit id="f4dc16672c96ad25755a371b9687a8d13c69a834" translate="yes" xml:space="preserve">
          <source>If the canvas is ready and there has been a successful call to &lt;a href=&quot;qml-qtquick-canvas#getContext-method&quot;&gt;getContext()&lt;/a&gt; or the &lt;a href=&quot;qml-qtquick-canvas#contextType-prop&quot;&gt;contextType&lt;/a&gt; property has been set with a supported context type, this property will contain the current drawing context, otherwise null.</source>
          <target state="translated">캔버스가 준비되었고 &lt;a href=&quot;qml-qtquick-canvas#getContext-method&quot;&gt;getContext ()&lt;/a&gt; 호출이 성공 했거나 &lt;a href=&quot;qml-qtquick-canvas#contextType-prop&quot;&gt;contextType&lt;/a&gt; 속성이 지원되는 컨텍스트 유형으로 설정된 경우이 속성에는 현재 드로잉 컨텍스트가 포함되며 그렇지 않으면 null입니다.</target>
        </trans-unit>
        <trans-unit id="d37fefe74944db5dc7244a4d8c28b3daacd5d18b" translate="yes" xml:space="preserve">
          <source>If the capture mode is changed while camera is active, it's recommended to change status to &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera::LoadedStatus&lt;/a&gt; and start activating the camera in the next event loop with the status changed to &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera::StartingStatus&lt;/a&gt;. This allows the capture settings to be applied before camera is started. Than change the status to QCamera::StartedStatus when the capture mode change is done.</source>
          <target state="translated">카메라가 활성화되어있는 동안 캡처 모드가 변경되면 상태를 &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera :: LoadedStatus&lt;/a&gt; 로 변경 하고 다음 이벤트 루프에서 상태를 &lt;a href=&quot;qcamera#Status-enum&quot;&gt;QCamera :: StartingStatus로&lt;/a&gt; 변경 한 상태에서 카메라를 활성화하는 것이 좋습니다 . 카메라를 시작하기 전에 캡처 설정을 적용 할 수 있습니다. 캡처 모드 변경이 완료되면 상태를 QCamera :: StartedStatus로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="2de3fb740c84d0ce8a444bb64b2eefbcdc2b5db6" translate="yes" xml:space="preserve">
          <source>If the categories need to be refreshed or reloaded, the &lt;a href=&quot;qplacemanager#initializeCategories&quot;&gt;initializeCategories&lt;/a&gt;() function may be called again.</source>
          <target state="translated">카테고리를 새로 고치거나 다시로드해야하는 경우 &lt;a href=&quot;qplacemanager#initializeCategories&quot;&gt;initializeCategories&lt;/a&gt; () 함수를 다시 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7040de3d43172c7bc21af20a30972a2f99386a6f" translate="yes" xml:space="preserve">
          <source>If the cell is already occupied, the</source>
          <target state="translated">셀이 이미 점유 된 경우</target>
        </trans-unit>
        <trans-unit id="76e9d54753559cd448778327e1b58f57fa57f806" translate="yes" xml:space="preserve">
          <source>If the centers of the two geo rectangles are separated by exactly 180.0 degrees then the width is set to 360.0 degrees with the leftmost longitude set to -180.0 degrees and the rightmost longitude set to 180.0 degrees. This is done to ensure that the result is independent of the order of the operands.</source>
          <target state="translated">두 지역 사각형의 중심이 정확히 180.0 도로 분리 된 경우 가장 왼쪽 경도는 -180.0 도로 설정되고 가장 오른쪽 경도는 180.0 도로 설정되어 너비는 360.0 도로 설정됩니다. 이는 결과가 피연산자의 순서와 무관하도록하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2d36020f8cde1b8c8875b3b635c01445a375b68f" translate="yes" xml:space="preserve">
          <source>If the change in height would cause the geo rectangle to cross a pole, the height is adjusted such that the geo rectangle only touches the pole.</source>
          <target state="translated">높이 변경으로 인해 지오 사각형이 극점을 교차하는 경우 지오 사각형이 극점에만 닿도록 높이가 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="8a5580568992a3379125911dae2c2c60e64ea29e" translate="yes" xml:space="preserve">
          <source>If the characteristic's &lt;a href=&quot;qlowenergycharacteristic#properties&quot;&gt;properties&lt;/a&gt;() permit writing of new values, the value can be updated using &lt;a href=&quot;qlowenergyservice#writeCharacteristic&quot;&gt;QLowEnergyService::writeCharacteristic&lt;/a&gt;().</source>
          <target state="translated">특성의 &lt;a href=&quot;qlowenergycharacteristic#properties&quot;&gt;특성&lt;/a&gt; ()으로 새 값을 쓸 수 있으면 &lt;a href=&quot;qlowenergyservice#writeCharacteristic&quot;&gt;QLowEnergyService :: writeCharacteristic&lt;/a&gt; ()을 사용하여 값을 업데이트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9261356d6470068847ceebd0aa6ba8d2f99484b" translate="yes" xml:space="preserve">
          <source>If the check box is checked,</source>
          <target state="translated">확인란을 선택하면</target>
        </trans-unit>
        <trans-unit id="2d9af1217049bb120cd68568b1b694f7aecd22b8" translate="yes" xml:space="preserve">
          <source>If the child has already been inserted somewhere else it won't be inserted again.</source>
          <target state="translated">아이가 이미 다른 곳에 삽입 된 경우 다시 삽입되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06a311cfe102a345f7a141ffd552aa31cc1c4c16" translate="yes" xml:space="preserve">
          <source>If the chosen transition stays in this group, another duration (+/- up to &lt;a href=&quot;qml-qtquick-particles-particlegroup#durationVariation-prop&quot;&gt;durationVariation&lt;/a&gt;) milliseconds will occur before another transition is attempted.</source>
          <target state="translated">선택한 전환이이 그룹에 머무르면 다른 전환을 시도하기 전에 다른 &lt;a href=&quot;qml-qtquick-particles-particlegroup#durationVariation-prop&quot;&gt;지속&lt;/a&gt; 기간 (+/- 최대 durationVariation ) 밀리 초가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="047a9df1d2f77f4949640019f857e18e185571ef" translate="yes" xml:space="preserve">
          <source>If the class declaration is found in the file &lt;code&gt;myclass.h&lt;/code&gt;, the moc output should be put in a file called &lt;code&gt;moc_myclass.cpp&lt;/code&gt;. This file should then be compiled as usual, resulting in an object file, e.g., &lt;code&gt;moc_myclass.obj&lt;/code&gt; on Windows. This object should then be included in the list of object files that are linked together in the final building phase of the program.</source>
          <target state="translated">클래스 선언이 &lt;code&gt;myclass.h&lt;/code&gt; 파일에 있으면 moc 출력을 &lt;code&gt;moc_myclass.cpp&lt;/code&gt; 파일에 넣어야 합니다. 그런 다음이 파일을 평소대로 컴파일 하여 Windows 에서 객체 파일 (예 : &lt;code&gt;moc_myclass.obj&lt;/code&gt; ) 을 생성해야합니다. 이 오브젝트는 프로그램의 최종 빌드 단계에서 함께 링크 된 오브젝트 파일 목록에 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1288e0ee4dd2f0b704620dba6cf67fdbdb429f40" translate="yes" xml:space="preserve">
          <source>If the class has no superclasses with class information, the offset is 0; otherwise the offset is the sum of all the class information items in the class's superclasses.</source>
          <target state="translated">클래스에 클래스 정보가있는 수퍼 클래스가없는 경우 오프셋은 0입니다. 그렇지 않으면 오프셋은 클래스의 수퍼 클래스에있는 모든 클래스 정보 항목의 합계입니다.</target>
        </trans-unit>
        <trans-unit id="2fcd4ae2276233bc95d0deffd34cfb7d51811d1d" translate="yes" xml:space="preserve">
          <source>If the class has no superclasses with enumerators, the offset is 0; otherwise the offset is the sum of all the enumerators in the class's superclasses.</source>
          <target state="translated">클래스에 열거자가있는 슈퍼 클래스가없는 경우 오프셋은 0입니다. 그렇지 않으면 오프셋은 클래스의 수퍼 클래스에있는 모든 열거 자의 합계입니다.</target>
        </trans-unit>
        <trans-unit id="fe5c4d79e2d93bd238d9e4ffa688d5d0f578c9d7" translate="yes" xml:space="preserve">
          <source>If the code is longer than one line and hence within a block, we use semicolons to indicate the end of each statement:</source>
          <target state="translated">코드가 한 줄보다 길어서 블록 내에 있으면 세미콜론을 사용하여 각 문의 끝을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e0329a0e8b6331d826375a49c35ddb78a4d1ecec" translate="yes" xml:space="preserve">
          <source>If the codec cannot be detected from the content provided,</source>
          <target state="translated">제공된 컨텐츠에서 코덱을 감지 할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="0f84b16eba35e0d4d1d7fd1793d46c38d5967e2a" translate="yes" xml:space="preserve">
          <source>If the codec cannot be detected from the content provided, this overload returns a Latin-1 &lt;a href=&quot;qtextcodec&quot;&gt;QTextCodec&lt;/a&gt;.</source>
          <target state="translated">제공된 컨텐츠에서 코덱을 감지 할 수없는 경우이 과부하는 Latin-1 &lt;a href=&quot;qtextcodec&quot;&gt;QTextCodec를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="fc625a2f58c240b7d6e3d2c6793d5cf89d1944ea" translate="yes" xml:space="preserve">
          <source>If the codec is registered as a character set in the &lt;a href=&quot;http://www.iana.org/assignments/character-sets/character-sets.xml#&quot;&gt;IANA character-sets encoding file&lt;/a&gt; this method should return the preferred mime name for the codec if defined, otherwise its name.</source>
          <target state="translated">코덱이 &lt;a href=&quot;http://www.iana.org/assignments/character-sets/character-sets.xml#&quot;&gt;IANA 문자 집합 인코딩 파일&lt;/a&gt; 에 문자 집합으로 등록 된 경우이 메서드는 정의 된 경우 코덱에 대해 선호하는 MIME 이름을 반환해야하며, 그렇지 않으면 해당 이름을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="566a92c3dfdf1c0f65c62c0d6807bc812fc61246" translate="yes" xml:space="preserve">
          <source>If the color table is expanded, all the extra colors will be set to transparent (i.e &lt;a href=&quot;qcolor#qRgba&quot;&gt;qRgba&lt;/a&gt;(0, 0, 0, 0)).</source>
          <target state="translated">색상 표가 확장되면 모든 추가 색상이 투명하게 설정됩니다 (예 : &lt;a href=&quot;qcolor#qRgba&quot;&gt;qRgba&lt;/a&gt; (0, 0, 0, 0)).</target>
        </trans-unit>
        <trans-unit id="48843dcbdfb5d0331719a0f538334d427aaf7c00" translate="yes" xml:space="preserve">
          <source>If the combo box is editable, the current text is the value displayed by the line edit. Otherwise, it is the value of the current item or an empty string if the combo box is empty or no current item is set.</source>
          <target state="translated">콤보 상자를 편집 할 수있는 경우 현재 텍스트는 줄 편집으로 표시되는 값입니다. 그렇지 않으면 현재 항목의 값이거나 콤보 상자가 비어 있거나 현재 항목이 설정되지 않은 경우 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="eb2e5ffc597240b4a481287162d6efa52f70d6dd" translate="yes" xml:space="preserve">
          <source>If the command is used within a table, you can also specify how many rows or columns the item should span.</source>
          <target state="translated">명령이 테이블 내에서 사용되는 경우 항목이 포함되어야하는 행 또는 열 수를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffb7c8642996d44b0ba3b94a3d3d67d82e10fa10" translate="yes" xml:space="preserve">
          <source>If the command supports compression this function must be overridden in the derived class to return the correct ID. The base implementation returns -1.</source>
          <target state="translated">명령이 압축을 지원하는 경우이 함수는 파생 된 클래스에서 재정의되어 올바른 ID를 반환해야합니다. 기본 구현은 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d5ee0f450552153750ad37d70d68622452433fb1" translate="yes" xml:space="preserve">
          <source>If the commit string should replace parts of the of the text in the editor,</source>
          <target state="translated">커밋 문자열이 편집기에서 텍스트의 일부를 대체해야하는 경우,</target>
        </trans-unit>
        <trans-unit id="24820c1629b905761c5ecf93d214da6995fa6045" translate="yes" xml:space="preserve">
          <source>If the compilation of a plugin succeeds but it cannot be loaded, make sure that the following requirements are met:</source>
          <target state="translated">플러그인 컴파일에 성공했지만로드 할 수없는 경우 다음 요구 사항이 충족되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d3ea874d7e7a00dedbcad6fc36359fb400165cd8" translate="yes" xml:space="preserve">
          <source>If the component's UUID is used the following patterns can be used to initialize the control on a remote machine, to initialize a licensed control or to connect to a running object:</source>
          <target state="translated">구성 요소의 UUID를 사용하는 경우 다음 패턴을 사용하여 원격 시스템에서 제어를 초기화하거나 라이센스가 부여 된 제어를 초기화하거나 실행중인 오브젝트에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02ee6de6a0821f1794b2e37f050bfed51034b615" translate="yes" xml:space="preserve">
          <source>If the connection to a host node is lost, the replica will transition to the invalid state. It will attempt to reconnect and will re-initialize if the connection is restored (this making sure all properties are current).</source>
          <target state="translated">호스트 노드에 대한 연결이 끊어지면 복제본이 유효하지 않은 상태로 전환됩니다. 연결이 복원되면 다시 연결을 시도하고 다시 초기화됩니다 (모든 속성이 최신 상태인지 확인).</target>
        </trans-unit>
        <trans-unit id="9d72bd3a1b21b03f01d95838141a1e26387ba9e7" translate="yes" xml:space="preserve">
          <source>If the contact patch is unknown, or the &lt;a href=&quot;qml-qtquick-pointerevent#device-prop&quot;&gt;device&lt;/a&gt; is not a touchscreen, these values will be zero.</source>
          <target state="translated">접촉 패치를 알 수 없거나 &lt;a href=&quot;qml-qtquick-pointerevent#device-prop&quot;&gt;장치&lt;/a&gt; 가 터치 스크린이 아닌 경우이 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="38f0414b85a01fe46be1c1aac0e68300cdd1dc82" translate="yes" xml:space="preserve">
          <source>If the contact patch is unknown, or the device is not a touchscreen, these values will be zero.</source>
          <target state="translated">접촉 패치를 알 수 없거나 장치가 터치 스크린이 아닌 경우이 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="ab70d6bef6c2dc2315b22c801a97d6625e98a143" translate="yes" xml:space="preserve">
          <source>If the contained pointer is &lt;code&gt;nullptr&lt;/code&gt; behavior is undefined.</source>
          <target state="translated">포함 된 포인터가 &lt;code&gt;nullptr&lt;/code&gt; 인 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4b671de3552a68b0fcb3419b3970944934b40fb" translate="yes" xml:space="preserve">
          <source>If the contained pointer is &lt;code&gt;nullptr&lt;/code&gt;, behavior is undefined.</source>
          <target state="translated">포함 된 포인터가 &lt;code&gt;nullptr&lt;/code&gt; 인 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8e5f8f352798385ab0fed9294fb595088a54da5" translate="yes" xml:space="preserve">
          <source>If the container format is not specified, the encoder will choose format, depending on media source properties and encoding settings selected.</source>
          <target state="translated">컨테이너 형식을 지정하지 않으면 인코더는 선택된 미디어 소스 속성 및 인코딩 설정에 따라 형식을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="a03e89042cf5befb4bc7b5b01a0034192c351af4" translate="yes" xml:space="preserve">
          <source>If the container in the &lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; does not support bi-directional iteration, calling this function leads to undefined results.</source>
          <target state="translated">&lt;a href=&quot;qvariant&quot;&gt;QVariant&lt;/a&gt; 의 컨테이너가 양방향 반복을 지원하지 않는 경우이 함수를 호출하면 정의되지 않은 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7cd208f557b2733ae0888d36597f102b8b4b3a60" translate="yes" xml:space="preserve">
          <source>If the content of the &lt;a href=&quot;qqmlscriptstring&quot;&gt;QQmlScriptString&lt;/a&gt; is a boolean literal, returns the boolean value and sets</source>
          <target state="translated">&lt;a href=&quot;qqmlscriptstring&quot;&gt;QQmlScriptString&lt;/a&gt; 의 내용이 부울 리터럴 인 경우 부울 값을 리턴하고</target>
        </trans-unit>
        <trans-unit id="bf2162bf359efe67e584b0aa3b929f7a5603e21e" translate="yes" xml:space="preserve">
          <source>If the content of the &lt;a href=&quot;qqmlscriptstring&quot;&gt;QQmlScriptString&lt;/a&gt; is a number literal, returns that number and sets</source>
          <target state="translated">&lt;a href=&quot;qqmlscriptstring&quot;&gt;QQmlScriptString&lt;/a&gt; 의 내용이 숫자 리터럴 인 경우 해당 숫자를 리턴하고</target>
        </trans-unit>
        <trans-unit id="ce232720f231759dc41f53fce2cbe318d50af654" translate="yes" xml:space="preserve">
          <source>If the content of the &lt;a href=&quot;qqmlscriptstring&quot;&gt;QQmlScriptString&lt;/a&gt; is a string literal, returns that string. Otherwise returns a null &lt;a href=&quot;qstring&quot;&gt;QString&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;qqmlscriptstring&quot;&gt;QQmlScriptString&lt;/a&gt; 의 내용이 문자열 리터럴 인 경우 해당 문자열을 리턴합니다. 그렇지 않으면 null &lt;a href=&quot;qstring&quot;&gt;QString을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e7895dec9304a117af6b0042adce3e8701a05443" translate="yes" xml:space="preserve">
          <source>If the content size is less than or equal to the size of the &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt;, it will not be flickable.</source>
          <target state="translated">내용 크기가 &lt;a href=&quot;qml-qtquick-controls2-scrollview&quot;&gt;ScrollView&lt;/a&gt; 크기보다 작거나 같으면 쓸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b63dc9138a530e029b429b6f139ef28aa57c6b9" translate="yes" xml:space="preserve">
          <source>If the contentItem has no implicit size and only one child, Pane will use the implicit size of that child. For example, in the following code, the Pane will assume the size of the Rectangle:</source>
          <target state="translated">contentItem에 암시 적 크기가없고 하나의 자식 만있는 경우 Pane은 해당 자식의 암시 적 크기를 사용합니다. 예를 들어 다음 코드에서 창은 사각형의 크기를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="17039b8264bd8a2c133344b6b9db2a85b3321bfd" translate="yes" xml:space="preserve">
          <source>If the context has not yet been created, the result is based on the requested format set via &lt;a href=&quot;qopenglcontext#setFormat&quot;&gt;setFormat&lt;/a&gt;().</source>
          <target state="translated">컨텍스트가 아직 작성되지 않은 경우 결과는 &lt;a href=&quot;qopenglcontext#setFormat&quot;&gt;setFormat&lt;/a&gt; ()을 통해 요청 된 형식 세트를 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="b983073855e985608b82238c731bbad8fbbe9e67" translate="yes" xml:space="preserve">
          <source>If the context is a media element, returns the URL of that media.</source>
          <target state="translated">컨텍스트가 미디어 요소 인 경우 해당 미디어의 URL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3911824085a133e8a2c6f1ae6e331c3f24e32c7" translate="yes" xml:space="preserve">
          <source>If the context is a word considered misspelled by the spell-checker, returns a list of suggested replacements for &lt;a href=&quot;qwebenginecontextmenudata#misspelledWord&quot;&gt;misspelledWord&lt;/a&gt;().</source>
          <target state="translated">문맥이 맞춤법 검사기에서 철자가 틀린 것으로 간주되는 단어 인 경우 &lt;a href=&quot;qwebenginecontextmenudata#misspelledWord&quot;&gt;misspelledWord&lt;/a&gt; ()의 대체 제안 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="af15438e95d8006a11c568b00115a16f7bed2aba" translate="yes" xml:space="preserve">
          <source>If the context is a word considered misspelled by the spell-checker, returns a list of suggested replacements.</source>
          <target state="translated">문맥이 맞춤법 검사기에서 철자가 틀린 것으로 간주되는 단어이면 제안 된 대체 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c4e43b4ef941c7c7d61f281dd5b98b344ca85f86" translate="yes" xml:space="preserve">
          <source>If the context is a word considered misspelled by the spell-checker, returns the misspelled word.</source>
          <target state="translated">문맥이 맞춤법 검사기에서 철자가 틀린 것으로 간주되는 단어 인 경우 철자가 틀린 단어를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6c9fca8ab26a2304aaf3a5b9047bf8929d23852a" translate="yes" xml:space="preserve">
          <source>If the context is temporarily not needed, such as when the application is not rendering, it can be useful to delete it in order to free resources. You can connect to the &lt;a href=&quot;qopenglcontext#aboutToBeDestroyed&quot;&gt;aboutToBeDestroyed&lt;/a&gt;() signal to clean up any resources that have been allocated with different ownership from the &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; itself.</source>
          <target state="translated">응용 프로그램이 렌더링되지 않을 때와 같이 컨텍스트가 일시적으로 필요하지 않은 경우 리소스를 확보하기 위해 컨텍스트를 삭제하는 것이 유용 할 수 있습니다. &lt;a href=&quot;qopenglcontext#aboutToBeDestroyed&quot;&gt;aboutToBeDestroyed&lt;/a&gt; () 신호에 연결 하여 &lt;a href=&quot;qopenglcontext&quot;&gt;QOpenGLContext&lt;/a&gt; 자체 와 다른 소유권으로 할당 된 모든 자원을 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efcda093907d473eaac067ba07f8f66072b74179" translate="yes" xml:space="preserve">
          <source>If the context type is not supported or the canvas has previously been requested to provide a different and incompatible context type, &lt;code&gt;null&lt;/code&gt; will be returned.</source>
          <target state="translated">컨텍스트 유형이 지원되지 않거나 캔버스가 이전에 다른 호환되지 않는 컨텍스트 유형을 제공하도록 요청한 경우 &lt;code&gt;null&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="eb95a22a20fc0e5e9d31ded1cbd557f9b469fa31" translate="yes" xml:space="preserve">
          <source>If the control needs to be initialized using custom data, call this function in your reimplementation of &lt;a href=&quot;qaxwidget#initialize&quot;&gt;initialize&lt;/a&gt;(). This function is not called by the default implementation of &lt;a href=&quot;qaxwidget#initialize&quot;&gt;initialize&lt;/a&gt;().</source>
          <target state="translated">사용자 지정 데이터를 사용하여 컨트롤을 초기화해야하는 경우 &lt;a href=&quot;qaxwidget#initialize&quot;&gt;initialize&lt;/a&gt; ()를 다시 구현할 때이 함수를 호출하십시오 . 이 함수는 &lt;a href=&quot;qaxwidget#initialize&quot;&gt;initialize&lt;/a&gt; () 의 기본 구현에 의해 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ba37a847cf793872b77b239cb1571e1d2adc2774" translate="yes" xml:space="preserve">
          <source>If the controller instance is not connected or the controller has performed the service discovery already this function will do nothing.</source>
          <target state="translated">컨트롤러 인스턴스가 연결되어 있지 않거나 컨트롤러가 서비스 검색을 이미 수행 한 경우이 기능은 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
