<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="86619db828880fcc9f3c53510073459e42884551" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.applications.inception_v3</source>
          <target state="translated">모듈 : tf.compat.v2.keras.applications.inception_v3</target>
        </trans-unit>
        <trans-unit id="5e4ebaae214ec3ebb9d2d45ec174c0f670c85652" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.applications.mobilenet</source>
          <target state="translated">모듈 : tf.compat.v2.keras.applications.mobilenet</target>
        </trans-unit>
        <trans-unit id="32df904e9995e6ed3b9712251c56dbbade6b24e0" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.applications.mobilenet_v2</source>
          <target state="translated">모듈 : tf.compat.v2.keras.applications.mobilenet_v2</target>
        </trans-unit>
        <trans-unit id="0742225e004d98a0050c5c00e1749e46bb60bd4b" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.applications.nasnet</source>
          <target state="translated">모듈 : tf.compat.v2.keras.applications.nasnet</target>
        </trans-unit>
        <trans-unit id="bb2715e0d3fc08e88ce4829899b80200bc98ac88" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.applications.resnet</source>
          <target state="translated">모듈 : tf.compat.v2.keras.applications.resnet</target>
        </trans-unit>
        <trans-unit id="5cb6d72ef448556f2a954b970aa4bf84050ce551" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.applications.resnet50</source>
          <target state="translated">모듈 : tf.compat.v2.keras.applications.resnet50</target>
        </trans-unit>
        <trans-unit id="b3dac39549923fe59fe24a5927e342083bcc9bcd" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.applications.resnet_v2</source>
          <target state="translated">모듈 : tf.compat.v2.keras.applications.resnet_v2</target>
        </trans-unit>
        <trans-unit id="42443e409ae11911e25f87045104b53a74cdbc73" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.applications.vgg16</source>
          <target state="translated">모듈 : tf.compat.v2.keras.applications.vgg16</target>
        </trans-unit>
        <trans-unit id="2ee0f6484cdf87e99bd7f957062d9d99242ea9cc" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.applications.vgg19</source>
          <target state="translated">모듈 : tf.compat.v2.keras.applications.vgg19</target>
        </trans-unit>
        <trans-unit id="ba615ed78eae827e4fb40f186e19ad933b29d070" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.applications.xception</source>
          <target state="translated">모듈 : tf.compat.v2.keras.applications.xception</target>
        </trans-unit>
        <trans-unit id="203b8c951506aacf11cd5a612d0fce681126aa96" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.backend</source>
          <target state="translated">모듈 : tf.compat.v2.keras.backend</target>
        </trans-unit>
        <trans-unit id="3a360c6d3063bed9c8b1b75658f69efb97677dfd" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.callbacks</source>
          <target state="translated">모듈 : tf.compat.v2.keras.callbacks</target>
        </trans-unit>
        <trans-unit id="e180e4f3fdc59f83187b0680b34c5248e73c5248" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.constraints</source>
          <target state="translated">모듈 : tf.compat.v2.keras.constraints</target>
        </trans-unit>
        <trans-unit id="79bfb0e3669873013a4c9ff8bbe1f14aa19c92ca" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.datasets</source>
          <target state="translated">모듈 : tf.compat.v2.keras.datasets</target>
        </trans-unit>
        <trans-unit id="d6b8b8aae3e936b4fefdbaf56a0cecadda937321" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.datasets.boston_housing</source>
          <target state="translated">모듈 : tf.compat.v2.keras.datasets.boston_housing</target>
        </trans-unit>
        <trans-unit id="b5afee1837ade873dec3e1ba96b76654fa98a788" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.datasets.cifar10</source>
          <target state="translated">모듈 : tf.compat.v2.keras.datasets.cifar10</target>
        </trans-unit>
        <trans-unit id="67332d5e7dab9837278cc092778773714a27d0eb" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.datasets.cifar100</source>
          <target state="translated">모듈 : tf.compat.v2.keras.datasets.cifar100</target>
        </trans-unit>
        <trans-unit id="7306c69a9f4018554b705d1f0cdbca619f189978" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.datasets.fashion_mnist</source>
          <target state="translated">모듈 : tf.compat.v2.keras.datasets.fashion_mnist</target>
        </trans-unit>
        <trans-unit id="d5aa0bccdb95112e394d57c018f090af56dbc4a3" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.datasets.imdb</source>
          <target state="translated">모듈 : tf.compat.v2.keras.datasets.imdb</target>
        </trans-unit>
        <trans-unit id="6c5ab43725a20860e694791613fa0c7e54d17dcf" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.datasets.mnist</source>
          <target state="translated">모듈 : tf.compat.v2.keras.datasets.mnist</target>
        </trans-unit>
        <trans-unit id="fe2db04b078a81df0a6b9fffb4bf33b192890b9f" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.datasets.reuters</source>
          <target state="translated">모듈 : tf.compat.v2.keras.datasets.reuters</target>
        </trans-unit>
        <trans-unit id="a2dccfba10860d034d28ceaee550dde1772e7e04" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.estimator</source>
          <target state="translated">모듈 : tf.compat.v2.keras.estimator</target>
        </trans-unit>
        <trans-unit id="bd1310ed8f3b5c47c262bb7897ce8e258e550f36" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.experimental</source>
          <target state="translated">모듈 : tf.compat.v2.keras.experimental</target>
        </trans-unit>
        <trans-unit id="aa81bf93cbe5f8e5b24870bf780824867f6dab4b" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.initializers</source>
          <target state="translated">모듈 : tf.compat.v2.keras.initializers</target>
        </trans-unit>
        <trans-unit id="d9814925aca7f45deddd5ee20574b42fb3fcdfa3" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.layers</source>
          <target state="translated">모듈 : tf.compat.v2.keras.layers</target>
        </trans-unit>
        <trans-unit id="ced2d8a74f92e92931e40a317e282e6081f11467" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.layers.experimental</source>
          <target state="translated">모듈 : tf.compat.v2.keras.layers.experimental</target>
        </trans-unit>
        <trans-unit id="0e3336a69ef7b50575b6d3ebc27b76a34145f2df" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.layers.experimental.preprocessing</source>
          <target state="translated">모듈 : tf.compat.v2.keras.layers.experimental.preprocessing</target>
        </trans-unit>
        <trans-unit id="ecebe9ff43ca3f1d42061a98d3ce1c512504b372" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.losses</source>
          <target state="translated">모듈 : tf.compat.v2.keras.losses</target>
        </trans-unit>
        <trans-unit id="b832576708078abdbc1d32ea16b1824ea94bbc10" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.metrics</source>
          <target state="translated">모듈 : tf.compat.v2.keras.metrics</target>
        </trans-unit>
        <trans-unit id="b497233e8eae8f34636b30c85e19bea02f28909f" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.mixed_precision</source>
          <target state="translated">모듈 : tf.compat.v2.keras.mixed_precision</target>
        </trans-unit>
        <trans-unit id="c1f0e27d23f97ba2853e1abb76c9d6986b637c1a" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.mixed_precision.experimental</source>
          <target state="translated">모듈 : tf.compat.v2.keras.mixed_precision.experimental</target>
        </trans-unit>
        <trans-unit id="59ba8bda992dfd5cac02353d847a0e537391e9a1" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.models</source>
          <target state="translated">모듈 : tf.compat.v2.keras.models</target>
        </trans-unit>
        <trans-unit id="82e8f6365979aa313229b4d90010142436a84fa8" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.optimizers</source>
          <target state="translated">모듈 : tf.compat.v2.keras.optimizers</target>
        </trans-unit>
        <trans-unit id="92908a2941b443a2dc9640af2c05623fe2c89633" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.optimizers.schedules</source>
          <target state="translated">모듈 : tf.compat.v2.keras.optimizers.schedules</target>
        </trans-unit>
        <trans-unit id="c0bef4ad7446ec2a6a0c3c0b12266c626e9448b5" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.preprocessing</source>
          <target state="translated">모듈 : tf.compat.v2.keras.preprocessing</target>
        </trans-unit>
        <trans-unit id="1f21dfed865050df1b47cded9188a9b875d57f67" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.preprocessing.image</source>
          <target state="translated">모듈 : tf.compat.v2.keras.preprocessing.image</target>
        </trans-unit>
        <trans-unit id="c717b890f8cd83c42d2c571598186e7f07169d9c" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.preprocessing.sequence</source>
          <target state="translated">모듈 : tf.compat.v2.keras.preprocessing.sequence</target>
        </trans-unit>
        <trans-unit id="d1a7c3a9d009b859c03d95af64d58432d84e5861" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.preprocessing.text</source>
          <target state="translated">모듈 : tf.compat.v2.keras.preprocessing.text</target>
        </trans-unit>
        <trans-unit id="7e238e324d1728f4dc837ceab3635510c1157235" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.regularizers</source>
          <target state="translated">모듈 : tf.compat.v2.keras.regularizers</target>
        </trans-unit>
        <trans-unit id="8814f952cd7e12bc1f6cc5392e8546789038c1cb" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.utils</source>
          <target state="translated">모듈 : tf.compat.v2.keras.utils</target>
        </trans-unit>
        <trans-unit id="85fd9e2e9a022acef526a32902edf04e46958c40" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.wrappers</source>
          <target state="translated">모듈 : tf.compat.v2.keras.wrappers</target>
        </trans-unit>
        <trans-unit id="252418539c6b85609cb833f32eed106955368e3b" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.keras.wrappers.scikit_learn</source>
          <target state="translated">모듈 : tf.compat.v2.keras.wrappers.scikit_learn</target>
        </trans-unit>
        <trans-unit id="2bdc17144883269ef16cccf802b015f81d54ddd0" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.linalg</source>
          <target state="translated">모듈 : tf.compat.v2.linalg</target>
        </trans-unit>
        <trans-unit id="edac456bd994d4af82fc55f20d7c0cf1e4e96cb6" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.lite</source>
          <target state="translated">모듈 : tf.compat.v2.lite</target>
        </trans-unit>
        <trans-unit id="44869555fdd123d33ad00e4e0918dead5adc47c4" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.lite.experimental</source>
          <target state="translated">모듈 : tf.compat.v2.lite.experimental</target>
        </trans-unit>
        <trans-unit id="13bc322ca86bbe8081bd1c62d705fc5f1322304a" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.lookup</source>
          <target state="translated">모듈 : tf.compat.v2.lookup</target>
        </trans-unit>
        <trans-unit id="dd8bba47d4b5dd78364778982d596f36801c0855" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.lookup.experimental</source>
          <target state="translated">모듈 : tf.compat.v2.lookup.experimental</target>
        </trans-unit>
        <trans-unit id="5d238dc1e04556d2eef3a1576a0240c3bbe5aa5f" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.math</source>
          <target state="translated">모듈 : tf.compat.v2.math</target>
        </trans-unit>
        <trans-unit id="d65e16bc1ccf54423ac1646f9b9729f3a1e4449e" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.mixed_precision</source>
          <target state="translated">모듈 : tf.compat.v2.mixed_precision</target>
        </trans-unit>
        <trans-unit id="cecf4bd69da95016ab2a4392173ab4782c68eb82" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.mixed_precision.experimental</source>
          <target state="translated">모듈 : tf.compat.v2.mixed_precision.experimental</target>
        </trans-unit>
        <trans-unit id="232c697a806d5fae839193681829215a3cca00ef" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.mlir</source>
          <target state="translated">모듈 : tf.compat.v2.mlir</target>
        </trans-unit>
        <trans-unit id="7d897c7fedf03ed2c57a2f99816f36d7d0a507c5" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.mlir.experimental</source>
          <target state="translated">모듈 : tf.compat.v2.mlir.experimental</target>
        </trans-unit>
        <trans-unit id="96c1296ff13bbb61b46505cd0d19a1cb8e0577c9" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.nest</source>
          <target state="translated">모듈 : tf.compat.v2.nest</target>
        </trans-unit>
        <trans-unit id="e3aa4b8c250920c139352a06c81723df70b9d0d3" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.nn</source>
          <target state="translated">모듈 : tf.compat.v2.nn</target>
        </trans-unit>
        <trans-unit id="2c053adb13955295e233750defff848c0335f17f" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.quantization</source>
          <target state="translated">모듈 : tf.compat.v2.quantization</target>
        </trans-unit>
        <trans-unit id="680aa23fc0c6752a3b63dc96cf9e4dd86a63145a" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.queue</source>
          <target state="translated">모듈 : tf.compat.v2.queue</target>
        </trans-unit>
        <trans-unit id="b94e97b4f6440ebe724fc0da91396d3ba10fd5d0" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.ragged</source>
          <target state="translated">모듈 : tf.compat.v2.ragged</target>
        </trans-unit>
        <trans-unit id="dff01c218413af70b4efe2e0e9f1346980547f2d" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.random</source>
          <target state="translated">모듈 : tf.compat.v2.random</target>
        </trans-unit>
        <trans-unit id="201d3e0d654ac228de0188dd7acbc84f88ea2841" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.random.experimental</source>
          <target state="translated">모듈 : tf.compat.v2.random.experimental</target>
        </trans-unit>
        <trans-unit id="09cec51443618e332011b8fcf7ba8638c0bb59d5" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.raw_ops</source>
          <target state="translated">모듈 : tf.compat.v2.raw_ops</target>
        </trans-unit>
        <trans-unit id="e6a2c45a4d5ecd2b1eac1d76c3981f81c03c9593" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.saved_model</source>
          <target state="translated">모듈 : tf.compat.v2.saved_model</target>
        </trans-unit>
        <trans-unit id="61d971f911898b4678a5b368625034667e19e4eb" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.sets</source>
          <target state="translated">모듈 : tf.compat.v2.sets</target>
        </trans-unit>
        <trans-unit id="cab2550168a63fb498d2cd24b3f7b4553099da35" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.signal</source>
          <target state="translated">모듈 : tf.compat.v2.signal</target>
        </trans-unit>
        <trans-unit id="7933d00354499bf46af8b5ac1e0c2b6e0f9a1012" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.sparse</source>
          <target state="translated">모듈 : tf.compat.v2.sparse</target>
        </trans-unit>
        <trans-unit id="b87cc1d4c2519bcbd31473c9f5cf80c5b37566cf" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.strings</source>
          <target state="translated">모듈 : tf.compat.v2.strings</target>
        </trans-unit>
        <trans-unit id="6e51184b3b3deeb71e30dec0c82d63317d3029a8" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.sysconfig</source>
          <target state="translated">모듈 : tf.compat.v2.sysconfig</target>
        </trans-unit>
        <trans-unit id="07a5623df8755e7e902db94169d2ad3c4352a0c4" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.test</source>
          <target state="translated">모듈 : tf.compat.v2.test</target>
        </trans-unit>
        <trans-unit id="a6fb2cb6e5bcca661f84b006431c16803a69cdb6" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.tpu</source>
          <target state="translated">모듈 : tf.compat.v2.tpu</target>
        </trans-unit>
        <trans-unit id="cd6274142dc487f38bd21f7dcc98446503b86442" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.tpu.experimental</source>
          <target state="translated">모듈 : tf.compat.v2.tpu.experimental</target>
        </trans-unit>
        <trans-unit id="52a69e5fe08a54fa022a3104c96a34ea5e8af804" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.train</source>
          <target state="translated">모듈 : tf.compat.v2.train</target>
        </trans-unit>
        <trans-unit id="63c73c88207e2ce20430f4f07145b9ee622da5db" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.train.experimental</source>
          <target state="translated">모듈 : tf.compat.v2.train.experimental</target>
        </trans-unit>
        <trans-unit id="c416758434ac9437a90544375ef6b61aa03df879" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.version</source>
          <target state="translated">모듈 : tf.compat.v2.version</target>
        </trans-unit>
        <trans-unit id="4575b93c4cdfc996d85e3827ebed941d17eed710" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.xla</source>
          <target state="translated">모듈 : tf.compat.v2.xla</target>
        </trans-unit>
        <trans-unit id="9173152f280ee81c678860e28203ab54fc1d7857" translate="yes" xml:space="preserve">
          <source>Module: tf.compat.v2.xla.experimental</source>
          <target state="translated">모듈 : tf.compat.v2.xla.experimental</target>
        </trans-unit>
        <trans-unit id="dde4906736734da274cee0aa9c428ce3773400af" translate="yes" xml:space="preserve">
          <source>Module: tf.config</source>
          <target state="translated">모듈 : tf.config</target>
        </trans-unit>
        <trans-unit id="91e833765bf7e4bdca2713b69d92ca8e006e5cd8" translate="yes" xml:space="preserve">
          <source>Module: tf.config.experimental</source>
          <target state="translated">모듈 : tf.config.experimental</target>
        </trans-unit>
        <trans-unit id="1dc089e7483cd0ae0a33e0009ce269c6581befb3" translate="yes" xml:space="preserve">
          <source>Module: tf.config.optimizer</source>
          <target state="translated">모듈 : tf.config.optimizer</target>
        </trans-unit>
        <trans-unit id="dc9ee30c314f0a7cf5dfc278a06247058468c1ff" translate="yes" xml:space="preserve">
          <source>Module: tf.config.threading</source>
          <target state="translated">모듈 : tf.config.threading</target>
        </trans-unit>
        <trans-unit id="5f8da812e13d36cca1f166939e6e2215a69f37f2" translate="yes" xml:space="preserve">
          <source>Module: tf.data</source>
          <target state="translated">모듈 : tf.data</target>
        </trans-unit>
        <trans-unit id="fd722c7cb464a75966193da502cdf399818983f3" translate="yes" xml:space="preserve">
          <source>Module: tf.data.experimental</source>
          <target state="translated">모듈 : tf.data.experimental</target>
        </trans-unit>
        <trans-unit id="766ad7e416c498b2ad45f1539479e87b2c8d5486" translate="yes" xml:space="preserve">
          <source>Module: tf.debugging</source>
          <target state="translated">모듈 : tf.debugging</target>
        </trans-unit>
        <trans-unit id="3662ca6d115266110ff416dcda122a5c8db354e5" translate="yes" xml:space="preserve">
          <source>Module: tf.debugging.experimental</source>
          <target state="translated">모듈 : tf.debugging.experimental</target>
        </trans-unit>
        <trans-unit id="42ab2d51c874a01a2731eae41227e706868def0c" translate="yes" xml:space="preserve">
          <source>Module: tf.distribute</source>
          <target state="translated">모듈 : tf.distribute</target>
        </trans-unit>
        <trans-unit id="2cbf726f148c56874af97f386b0b519d325d72df" translate="yes" xml:space="preserve">
          <source>Module: tf.distribute.cluster_resolver</source>
          <target state="translated">모듈 : tf.distribute.cluster_resolver</target>
        </trans-unit>
        <trans-unit id="70366e789bba19d6feb3d67b904cad32e1e7d9c4" translate="yes" xml:space="preserve">
          <source>Module: tf.distribute.experimental</source>
          <target state="translated">모듈 : tf.distribute.experimental</target>
        </trans-unit>
        <trans-unit id="281a9024b91d97c70d2db549561f82282a00df8d" translate="yes" xml:space="preserve">
          <source>Module: tf.dtypes</source>
          <target state="translated">모듈 : tf.dtypes</target>
        </trans-unit>
        <trans-unit id="38c88a2a2f5f6b2c20e9df570f34fa9654eee477" translate="yes" xml:space="preserve">
          <source>Module: tf.errors</source>
          <target state="translated">모듈 : tf.errors</target>
        </trans-unit>
        <trans-unit id="3bbc4967b6656ab968d00624174595595ccb50fd" translate="yes" xml:space="preserve">
          <source>Module: tf.estimator</source>
          <target state="translated">모듈 : tf.estimator</target>
        </trans-unit>
        <trans-unit id="2ae056df054efc4b23d29890bf7956f3e3b0a994" translate="yes" xml:space="preserve">
          <source>Module: tf.estimator.experimental</source>
          <target state="translated">모듈 : tf.estimator.experimental</target>
        </trans-unit>
        <trans-unit id="8d88340c9ef77961972c3661431612b1de354997" translate="yes" xml:space="preserve">
          <source>Module: tf.estimator.export</source>
          <target state="translated">모듈 : tf.estimator.export</target>
        </trans-unit>
        <trans-unit id="7f4186a4343e9fc2e13e2473f4ebb587d280b204" translate="yes" xml:space="preserve">
          <source>Module: tf.experimental</source>
          <target state="translated">모듈 : tf.experimental</target>
        </trans-unit>
        <trans-unit id="1927722bf45b4f025e40504d581575280527ab95" translate="yes" xml:space="preserve">
          <source>Module: tf.experimental.tensorrt</source>
          <target state="translated">모듈 : tf.experimental.tensorrt</target>
        </trans-unit>
        <trans-unit id="c98265df3417934b2a9662ce378c9445b0af3e55" translate="yes" xml:space="preserve">
          <source>Module: tf.feature_column</source>
          <target state="translated">모듈 : tf.feature_column</target>
        </trans-unit>
        <trans-unit id="8d551a79eeabc0ec2220a237168d1b3191533a4a" translate="yes" xml:space="preserve">
          <source>Module: tf.graph_util</source>
          <target state="translated">모듈 : tf.graph_util</target>
        </trans-unit>
        <trans-unit id="7c81f6aafc3be2a02e47c7e8a04aa42d6fbce37c" translate="yes" xml:space="preserve">
          <source>Module: tf.image</source>
          <target state="translated">모듈 : tf.image</target>
        </trans-unit>
        <trans-unit id="b560f84600bfafb56408243ffd6267af5ca37394" translate="yes" xml:space="preserve">
          <source>Module: tf.io</source>
          <target state="translated">모듈 : tf.io</target>
        </trans-unit>
        <trans-unit id="60e14ce155a4ec7de0d541d4788fc226feff1b6e" translate="yes" xml:space="preserve">
          <source>Module: tf.io.gfile</source>
          <target state="translated">모듈 : tf.io.gfile</target>
        </trans-unit>
        <trans-unit id="62b34493fbbb808c3c13a7d66697935a260c1d42" translate="yes" xml:space="preserve">
          <source>Module: tf.keras</source>
          <target state="translated">모듈 : tf.keras</target>
        </trans-unit>
        <trans-unit id="3a61a47190a2a94e7e078a9b9754db93d703db5f" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.activations</source>
          <target state="translated">모듈 : tf.keras.activations</target>
        </trans-unit>
        <trans-unit id="14b3200b3ce02f11e71deb01d53d00cdcb23be6b" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.applications</source>
          <target state="translated">모듈 : tf.keras.applications</target>
        </trans-unit>
        <trans-unit id="567859b8e6b20f15c063408009b9d3b1f59a397c" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.applications.densenet</source>
          <target state="translated">모듈 : tf.keras.applications.densenet</target>
        </trans-unit>
        <trans-unit id="5305b62aa6b9bda4e939c7bc78229c44f1a412fe" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.applications.imagenet_utils</source>
          <target state="translated">모듈 : tf.keras.applications.imagenet_utils</target>
        </trans-unit>
        <trans-unit id="474e492770d8f4ef84237ecf1ea769e5e8d33772" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.applications.inception_resnet_v2</source>
          <target state="translated">모듈 : tf.keras.applications.inception_resnet_v2</target>
        </trans-unit>
        <trans-unit id="88586f0164ef1713c98e0494dfb479e0f9ba2478" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.applications.inception_v3</source>
          <target state="translated">모듈 : tf.keras.applications.inception_v3</target>
        </trans-unit>
        <trans-unit id="906b95627638ee8b0ffafd30d0315073171396df" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.applications.mobilenet_v2</source>
          <target state="translated">모듈 : tf.keras.applications.mobilenet_v2</target>
        </trans-unit>
        <trans-unit id="1a1f15ca3b373b9ab951be4f17d1174c4245d269" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.applications.nasnet</source>
          <target state="translated">모듈 : tf.keras.applications.nasnet</target>
        </trans-unit>
        <trans-unit id="6e20ad5f8ef73ac960c70c5f444f5d63811ea18a" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.applications.resnet</source>
          <target state="translated">모듈 : tf.keras.applications.resnet</target>
        </trans-unit>
        <trans-unit id="23a827b62d4a35c11772230156a50c6de318c694" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.applications.resnet_v2</source>
          <target state="translated">모듈 : tf.keras.applications.resnet_v2</target>
        </trans-unit>
        <trans-unit id="de4f7df51d3bb0a535310ba3728c0a442cc6f9f5" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.backend</source>
          <target state="translated">모듈 : tf.keras.backend</target>
        </trans-unit>
        <trans-unit id="4606dd70d37e074e5c55431ef4b0509d92b55f47" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.callbacks</source>
          <target state="translated">모듈 : tf.keras.callbacks</target>
        </trans-unit>
        <trans-unit id="1713b2b7ca316d37827a0a64c6c166d066c1cdd0" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.constraints</source>
          <target state="translated">모듈 : tf.keras.constraints</target>
        </trans-unit>
        <trans-unit id="01a2f0667f9165efb48a4767505a1dc1238373e1" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.datasets</source>
          <target state="translated">모듈 : tf.keras.datasets</target>
        </trans-unit>
        <trans-unit id="9f2f6fcaccf555783797ccdc6e6cf6b2c10b69d2" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.datasets.boston_housing</source>
          <target state="translated">모듈 : tf.keras.datasets.boston_housing</target>
        </trans-unit>
        <trans-unit id="503eddfc1727595d16538481f430d553862ba952" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.datasets.cifar10</source>
          <target state="translated">모듈 : tf.keras.datasets.cifar10</target>
        </trans-unit>
        <trans-unit id="73006b80f912c388c804efbfaaac9316bda9b124" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.datasets.cifar100</source>
          <target state="translated">모듈 : tf.keras.datasets.cifar100</target>
        </trans-unit>
        <trans-unit id="35b228e67fefe320c4ab05851847b969ff8a6e30" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.datasets.fashion_mnist</source>
          <target state="translated">모듈 : tf.keras.datasets.fashion_mnist</target>
        </trans-unit>
        <trans-unit id="e5224aa650c87521ea851cae6a48ec70fa79b12c" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.datasets.imdb</source>
          <target state="translated">모듈 : tf.keras.datasets.imdb</target>
        </trans-unit>
        <trans-unit id="5bcee1b17559b0f2d444ff18b60c2ded6e985a41" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.datasets.mnist</source>
          <target state="translated">모듈 : tf.keras.datasets.mnist</target>
        </trans-unit>
        <trans-unit id="fc13a4aaab7a435576bb20a428a0e0e7625fa554" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.datasets.reuters</source>
          <target state="translated">모듈 : tf.keras.datasets.reuters</target>
        </trans-unit>
        <trans-unit id="ad48630c5fe4cf5ba85fd2c66797a28f3d8f6556" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.estimator</source>
          <target state="translated">모듈 : tf.keras.estimator</target>
        </trans-unit>
        <trans-unit id="56723e70ca1141c75ef1b9c5141c1b5a3862ff46" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.experimental</source>
          <target state="translated">모듈 : tf.keras.experimental</target>
        </trans-unit>
        <trans-unit id="9783f6eb284db2c02e9a0d2f14ca7d2502d050ec" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.initializers</source>
          <target state="translated">모듈 : tf.keras.initializers</target>
        </trans-unit>
        <trans-unit id="12efd5c1e51067f555a06ea02d3e4a8a3223e377" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.layers</source>
          <target state="translated">모듈 : tf.keras.layers</target>
        </trans-unit>
        <trans-unit id="339b46aac7dddeb665b5da5377a2fc3aad9a5a0f" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.layers.experimental</source>
          <target state="translated">모듈 : tf.keras.layers.experimental</target>
        </trans-unit>
        <trans-unit id="35902804ea971a2f79d6d663e15ebcfc7b1aad17" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.layers.experimental.preprocessing</source>
          <target state="translated">모듈 : tf.keras.layers.experimental.preprocessing</target>
        </trans-unit>
        <trans-unit id="8efb58457fdb8b0875e0187a3e4b6fcbdc3abe32" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.losses</source>
          <target state="translated">모듈 : tf.keras.losses</target>
        </trans-unit>
        <trans-unit id="40ee695cd0c0dd67629b279a1a5626b34d9d5d55" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.metrics</source>
          <target state="translated">모듈 : tf.keras.metrics</target>
        </trans-unit>
        <trans-unit id="22c8dc31d809601650ca9cde67298dbdf2500ff9" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.mixed_precision</source>
          <target state="translated">모듈 : tf.keras.mixed_precision</target>
        </trans-unit>
        <trans-unit id="7d27299723378d48344fe00475a965c6bc4e51db" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.mixed_precision.experimental</source>
          <target state="translated">모듈 : tf.keras.mixed_precision.experimental</target>
        </trans-unit>
        <trans-unit id="60ead6b4b5714de02be73a20b63c5e49f891a34e" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.models</source>
          <target state="translated">모듈 : tf.keras.models</target>
        </trans-unit>
        <trans-unit id="55b7358c3f927ca5891e368a85bbcecf0d4cb610" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.optimizers</source>
          <target state="translated">모듈 : tf.keras.optimizers</target>
        </trans-unit>
        <trans-unit id="a9038672f97393e68ee563dcc6b0ce88bd2ba073" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.optimizers.schedules</source>
          <target state="translated">모듈 : tf.keras.optimizers.schedules</target>
        </trans-unit>
        <trans-unit id="aad395d625636b1ef872968179c5f7201dce23b0" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.preprocessing</source>
          <target state="translated">모듈 : tf.keras.preprocessing</target>
        </trans-unit>
        <trans-unit id="985c9fe08beca20c3f19673219ee983ef85bbf5b" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.preprocessing.image</source>
          <target state="translated">모듈 : tf.keras.preprocessing.image</target>
        </trans-unit>
        <trans-unit id="7a37c9eb542efa46d06e38ce16310629718dbfd4" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.preprocessing.sequence</source>
          <target state="translated">모듈 : tf.keras.preprocessing.sequence</target>
        </trans-unit>
        <trans-unit id="6231d0a30a2a478fce71ccd348d0697bb487b201" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.preprocessing.text</source>
          <target state="translated">모듈 : tf.keras.preprocessing.text</target>
        </trans-unit>
        <trans-unit id="65dd6eef3c3cb5b8ff3b9fb60720def29e446377" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.regularizers</source>
          <target state="translated">모듈 : tf.keras.regularizers</target>
        </trans-unit>
        <trans-unit id="f1d72276ba6bf622712254ba3239064c96074e21" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.utils</source>
          <target state="translated">모듈 : tf.keras.utils</target>
        </trans-unit>
        <trans-unit id="3a9176ec0f4a64ee0c4aeb11a203cb57236d34e5" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.wrappers</source>
          <target state="translated">모듈 : tf.keras.wrappers</target>
        </trans-unit>
        <trans-unit id="19ae98ecc591cfb3c55c94054ca0253abb4a67ed" translate="yes" xml:space="preserve">
          <source>Module: tf.keras.wrappers.scikit_learn</source>
          <target state="translated">모듈 : tf.keras.wrappers.scikit_learn</target>
        </trans-unit>
        <trans-unit id="f6a09751cdd7d0ca683af8797af26a7da516a42c" translate="yes" xml:space="preserve">
          <source>Module: tf.linalg</source>
          <target state="translated">모듈 : tf.linalg</target>
        </trans-unit>
        <trans-unit id="c9a98410327b7ab6ebee6d6ad4068aa8a28fa219" translate="yes" xml:space="preserve">
          <source>Module: tf.lite</source>
          <target state="translated">모듈 : tf.lite</target>
        </trans-unit>
        <trans-unit id="5119440e4b0902a2f9e3bc15934d20e8ad9b7d81" translate="yes" xml:space="preserve">
          <source>Module: tf.lite.experimental</source>
          <target state="translated">모듈 : tf.lite.experimental</target>
        </trans-unit>
        <trans-unit id="7ca3916d05c9fbfbc0a145bbbf629cf4ae123a85" translate="yes" xml:space="preserve">
          <source>Module: tf.lookup</source>
          <target state="translated">모듈 : tf.lookup</target>
        </trans-unit>
        <trans-unit id="d84cbf6de1c45d2e6c747bf381aeec29a6a0b5d3" translate="yes" xml:space="preserve">
          <source>Module: tf.lookup.experimental</source>
          <target state="translated">모듈 : tf.lookup.experimental</target>
        </trans-unit>
        <trans-unit id="52d57dd79174188f7fe06b0687c3990243a79ff5" translate="yes" xml:space="preserve">
          <source>Module: tf.math</source>
          <target state="translated">모듈 : tf.math</target>
        </trans-unit>
        <trans-unit id="b66b43861572f13ac464893a79fdcf54e9b18de7" translate="yes" xml:space="preserve">
          <source>Module: tf.mixed_precision</source>
          <target state="translated">모듈 : tf.mixed_precision</target>
        </trans-unit>
        <trans-unit id="51e6e7b40c893c3bc63952e418a3440bf54f704f" translate="yes" xml:space="preserve">
          <source>Module: tf.mixed_precision.experimental</source>
          <target state="translated">모듈 : tf.mixed_precision.experimental</target>
        </trans-unit>
        <trans-unit id="75c1d0effa8b127f48fd78fc5bca665e58934c86" translate="yes" xml:space="preserve">
          <source>Module: tf.mlir</source>
          <target state="translated">모듈 : tf.mlir</target>
        </trans-unit>
        <trans-unit id="336b4a755085d14033d5449dddc58e38dfdbf7f6" translate="yes" xml:space="preserve">
          <source>Module: tf.mlir.experimental</source>
          <target state="translated">모듈 : tf.mlir.experimental</target>
        </trans-unit>
        <trans-unit id="51a9d8a37e17c143bd93aa0ccc757e06e1af7ade" translate="yes" xml:space="preserve">
          <source>Module: tf.nest</source>
          <target state="translated">모듈 : tf.nest</target>
        </trans-unit>
        <trans-unit id="308f774a13bc5bcd091757e998fb5dfaaa56d7e2" translate="yes" xml:space="preserve">
          <source>Module: tf.nn</source>
          <target state="translated">모듈 : tf.nn</target>
        </trans-unit>
        <trans-unit id="ff66cd137efc0b592837d7f382cda8d23a8c0458" translate="yes" xml:space="preserve">
          <source>Module: tf.quantization</source>
          <target state="translated">모듈 : tf.quantization</target>
        </trans-unit>
        <trans-unit id="a5d2f6a05dcf42c93a1f07948e678709b7cc0e8a" translate="yes" xml:space="preserve">
          <source>Module: tf.queue</source>
          <target state="translated">모듈 : tf.queue</target>
        </trans-unit>
        <trans-unit id="94ac524bcde758f5bfea5267b7b4c63e40c1d6f3" translate="yes" xml:space="preserve">
          <source>Module: tf.ragged</source>
          <target state="translated">모듈 : tf.ragged</target>
        </trans-unit>
        <trans-unit id="226d63c95bf2ae9b78aced830fec359e36584f39" translate="yes" xml:space="preserve">
          <source>Module: tf.random</source>
          <target state="translated">모듈 : tf.random</target>
        </trans-unit>
        <trans-unit id="1e0e97b20a3b3fa5545bb1e397b444ba7b0717cc" translate="yes" xml:space="preserve">
          <source>Module: tf.random.experimental</source>
          <target state="translated">모듈 : tf.random.experimental</target>
        </trans-unit>
        <trans-unit id="e333a461f8ee0f7824177b27fe5ce02567ee6bac" translate="yes" xml:space="preserve">
          <source>Module: tf.raw_ops</source>
          <target state="translated">모듈 : tf.raw_ops</target>
        </trans-unit>
        <trans-unit id="4d2720dd4551b2bb04c91df53a6f8f1ec743f39d" translate="yes" xml:space="preserve">
          <source>Module: tf.saved_model</source>
          <target state="translated">모듈 : tf.saved_model</target>
        </trans-unit>
        <trans-unit id="7fea0e8b66bfdf6f75962dca2a09e7ea39f49692" translate="yes" xml:space="preserve">
          <source>Module: tf.sets</source>
          <target state="translated">모듈 : tf.sets</target>
        </trans-unit>
        <trans-unit id="65ad550a8957e484267d822d2d8a9cda6c822225" translate="yes" xml:space="preserve">
          <source>Module: tf.signal</source>
          <target state="translated">모듈 : tf.signal</target>
        </trans-unit>
        <trans-unit id="807427894dd22d64865c126b6fc7c2578032f08a" translate="yes" xml:space="preserve">
          <source>Module: tf.sparse</source>
          <target state="translated">모듈 : tf.sparse</target>
        </trans-unit>
        <trans-unit id="5948e3907dac1b5644b5da46255b0cf41abc32c8" translate="yes" xml:space="preserve">
          <source>Module: tf.strings</source>
          <target state="translated">모듈 : tf.strings</target>
        </trans-unit>
        <trans-unit id="1a6f9cb1c84e11bb46d5c4383df1a28f7804aa69" translate="yes" xml:space="preserve">
          <source>Module: tf.summary</source>
          <target state="translated">모듈 : tf.summary</target>
        </trans-unit>
        <trans-unit id="b1c7577e5d0e367dd0ec3d0fe650c7ad6dc3802d" translate="yes" xml:space="preserve">
          <source>Module: tf.summary.experimental</source>
          <target state="translated">모듈 : tf.summary.experimental</target>
        </trans-unit>
        <trans-unit id="65d423b3ca5d7b85844cbf9b078f1f14f21b4c85" translate="yes" xml:space="preserve">
          <source>Module: tf.sysconfig</source>
          <target state="translated">모듈 : tf.sysconfig</target>
        </trans-unit>
        <trans-unit id="61f527c0dffced0aa9924d1494a52b8948a6a9a5" translate="yes" xml:space="preserve">
          <source>Module: tf.test</source>
          <target state="translated">모듈 : tf.test</target>
        </trans-unit>
        <trans-unit id="aee07cdc435c48724ac75e5ca0a4dd08092ac8a3" translate="yes" xml:space="preserve">
          <source>Module: tf.tpu</source>
          <target state="translated">모듈 : tf.tpu</target>
        </trans-unit>
        <trans-unit id="f40f06cd3dafa7bff6b8f933fbd23c9db48a3489" translate="yes" xml:space="preserve">
          <source>Module: tf.tpu.experimental</source>
          <target state="translated">모듈 : tf.tpu.experimental</target>
        </trans-unit>
        <trans-unit id="2511a0f8e062acd4fff1a29bd2c7cb37f191a85f" translate="yes" xml:space="preserve">
          <source>Module: tf.train</source>
          <target state="translated">모듈 : tf.train</target>
        </trans-unit>
        <trans-unit id="4cfc4bc046001b910fd7e9757e1d6791e4c7a836" translate="yes" xml:space="preserve">
          <source>Module: tf.train.experimental</source>
          <target state="translated">모듈 : tf.train.experimental</target>
        </trans-unit>
        <trans-unit id="e16b7d340e90a15775f83f89ac253213909d08ec" translate="yes" xml:space="preserve">
          <source>Module: tf.version</source>
          <target state="translated">모듈 : tf.version</target>
        </trans-unit>
        <trans-unit id="77c50e0c68b7601b4ca6968d9f5e444040af7025" translate="yes" xml:space="preserve">
          <source>Module: tf.xla</source>
          <target state="translated">모듈 : tf.xla</target>
        </trans-unit>
        <trans-unit id="806e6f0af5a535da0d1411d128810f02bc22ff67" translate="yes" xml:space="preserve">
          <source>Module: tf.xla.experimental</source>
          <target state="translated">모듈 : tf.xla.experimental</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="2d1217d8eb2ce02780571a3a5cce351f01e73a2a" translate="yes" xml:space="preserve">
          <source>Monitors the loss tensor and stops training if loss is NaN.</source>
          <target state="translated">손실 텐서를 모니터링하고 손실이 NaN 인 경우 훈련을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="08965269be31a1f77226663d4b16152886fa2985" translate="yes" xml:space="preserve">
          <source>More examples:</source>
          <target state="translated">더 많은 예 :</target>
        </trans-unit>
        <trans-unit id="7eca691c96a6c73420f0814fa97ed710f8916fb4" translate="yes" xml:space="preserve">
          <source>More formally, let</source>
          <target state="translated">더 공식적으로</target>
        </trans-unit>
        <trans-unit id="6df85f59a780af302cc4c65ad2ae971b93b79625" translate="yes" xml:space="preserve">
          <source>More information about SavedModel and signatures can be found here: https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/saved_model/README.md.</source>
          <target state="translated">저장된 모델 및 서명에 대한 자세한 정보는 https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/saved_model/README.md에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ecf714381162b0b5997018ef32b76d0a0ef35aa" translate="yes" xml:space="preserve">
          <source>More information about cuDNN can be found on the &lt;a href=&quot;https://developer.nvidia.com/cudnn&quot;&gt;NVIDIA developer website&lt;/a&gt;. Can only be run on GPU.</source>
          <target state="translated">cuDNN에 대한 자세한 내용은 &lt;a href=&quot;https://developer.nvidia.com/cudnn&quot;&gt;NVIDIA 개발자 웹 사이트&lt;/a&gt; 에서 찾을 수 있습니다 . GPU에서만 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d92fd499d38c58885410121b45e11028258bb7d" translate="yes" xml:space="preserve">
          <source>More precisely, where &lt;a href=&quot;reduce_logsumexp&quot;&gt;&lt;code&gt;tf.math.reduce_logsumexp&lt;/code&gt;&lt;/a&gt; uses the following trick:</source>
          <target state="translated">보다 정확하게는 &lt;a href=&quot;reduce_logsumexp&quot;&gt; &lt;code&gt;tf.math.reduce_logsumexp&lt;/code&gt; &lt;/a&gt; 는 다음과 같은 트릭을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4d39c130b6efea5237e9e9cf557b27d05adf32c9" translate="yes" xml:space="preserve">
          <source>More precisely: With probability &lt;code&gt;rate&lt;/code&gt; elements of &lt;code&gt;x&lt;/code&gt; are set to &lt;code&gt;0&lt;/code&gt;. The remaining elemenst are scaled up by &lt;code&gt;1.0 / (1 - rate)&lt;/code&gt;, so that the expected value is preserved.</source>
          <target state="translated">보다 정확하게 : 확률 &lt;code&gt;rate&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 의 요소는 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 나머지 elemenst는 &lt;code&gt;1.0 / (1 - rate)&lt;/code&gt; 씩 확장 되므로 예상 값이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0fd765d4b9a4d9102d8a4a364cc4e6758c048ff6" translate="yes" xml:space="preserve">
          <source>More specifically:</source>
          <target state="translated">더 구체적으로:</target>
        </trans-unit>
        <trans-unit id="460fa196449002a40abc9ebd910c8436ea57cd6c" translate="yes" xml:space="preserve">
          <source>More verbose logging is useful to enable when filing bug reports or doing more in-depth debugging.</source>
          <target state="translated">보다 자세한 로깅은 버그 보고서를 제출하거나보다 심도있는 디버깅을 수행 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f73ce5d4d78b2a64ac869595355a54d06eacb14f" translate="yes" xml:space="preserve">
          <source>Most &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; methods may only be executed in a cross-replica context, in a replica context you should use the API of the &lt;a href=&quot;replicacontext&quot;&gt;&lt;code&gt;tf.distribute.ReplicaContext&lt;/code&gt;&lt;/a&gt; object returned by this method instead.</source>
          <target state="translated">대부분의 &lt;a href=&quot;strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 메소드는 교차 복제 컨텍스트에서만 실행될 수 있으며, 복제 컨텍스트에서는 이 메소드가 리턴 한 &lt;a href=&quot;replicacontext&quot;&gt; &lt;code&gt;tf.distribute.ReplicaContext&lt;/code&gt; &lt;/a&gt; 오브젝트 의 API를 대신 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="7f7dd2612e3255c926b529275b877b094ddd3a59" translate="yes" xml:space="preserve">
          <source>Most dataset input pipelines should end with a call to &lt;code&gt;prefetch&lt;/code&gt;. This allows later elements to be prepared while the current element is being processed. This often improves latency and throughput, at the cost of using additional memory to store prefetched elements.</source>
          <target state="translated">대부분의 데이터 세트 입력 파이프 라인은 &lt;code&gt;prefetch&lt;/code&gt; 호출로 끝나야 합니다. 이를 통해 현재 요소가 처리되는 동안 이후 요소를 준비 할 수 있습니다. 이는 프리 페치 된 요소를 저장하기 위해 추가 메모리를 사용하는 비용으로 대기 시간 및 처리량을 종종 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="d29a735e0a5e68a47bd783dc12341f2f408ce6a1" translate="yes" xml:space="preserve">
          <source>Most users will also want to call &lt;a href=&quot;../train/create_global_step&quot;&gt;&lt;code&gt;tf.compat.v1.train.create_global_step&lt;/code&gt;&lt;/a&gt; which can happen before or after this function is called.</source>
          <target state="translated">대부분의 사용자는 이 함수를 호출하기 전이나 후에 발생할 수있는 &lt;a href=&quot;../train/create_global_step&quot;&gt; &lt;code&gt;tf.compat.v1.train.create_global_step&lt;/code&gt; &lt;/a&gt; 을 호출하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="b0eccc945bc9774c76c8755832329a850ce0ce3d" translate="yes" xml:space="preserve">
          <source>Mostly equivalent to numpy.linalg.norm. Not supported: ord &amp;lt;= 0, 2-norm for matrices, nuclear norm. Other differences: a) If axis is &lt;code&gt;None&lt;/code&gt;, treats the flattened &lt;code&gt;tensor&lt;/code&gt; as a vector regardless of rank. b) Explicitly supports 'euclidean' norm as the default, including for higher order tensors.</source>
          <target state="translated">대부분 numpy.linalg.norm과 같습니다. 지원되지 않음 : ord &amp;lt;= 0, 행렬의 경우 2- 노름, 핵 규범. 다른 차이점 : a) axis가 &lt;code&gt;None&lt;/code&gt; 이면 평면화 된 &lt;code&gt;tensor&lt;/code&gt; 를 순위와 상관없이 벡터로 처리합니다 . b) 고차 텐서를 포함하여 기본값으로 '유클리드'규범을 명시 적으로 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d6edca7a5606796b22a9f22f08c2d2b9f9851b51" translate="yes" xml:space="preserve">
          <source>Mostly equivalent to numpy.linalg.svd, except that * The order of output arguments here is &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; when &lt;code&gt;compute_uv&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, as opposed to &lt;code&gt;u&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, &lt;code&gt;v&lt;/code&gt; for numpy.linalg.svd. * full_matrices is &lt;code&gt;False&lt;/code&gt; by default as opposed to &lt;code&gt;True&lt;/code&gt; for numpy.linalg.svd. * tf.linalg.svd uses the standard definition of the SVD \(A = U \Sigma V^H\), such that the left singular vectors of &lt;code&gt;a&lt;/code&gt; are the columns of &lt;code&gt;u&lt;/code&gt;, while the right singular vectors of &lt;code&gt;a&lt;/code&gt; are the columns of &lt;code&gt;v&lt;/code&gt;. On the other hand, numpy.linalg.svd returns the adjoint \(V^H\) as the third output argument.</source>
          <target state="translated">numpy.linalg.svd의 &lt;code&gt;u&lt;/code&gt; , &lt;code&gt;s&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 와 달리 &lt;code&gt;compute_uv&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 출력 인수의 순서는 &lt;code&gt;s&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; , &lt;code&gt;v&lt;/code&gt; 입니다. numpy.linalg.svd의 경우 &lt;code&gt;True&lt;/code&gt; 와 반대로 full_matrices는 기본적으로 &lt;code&gt;False&lt;/code&gt; 입니다. * tf.linalg.svd는 SVD \의 표준 정의를 사용 (A = U \ 시그마 V ^ H \)의 좌 특이 벡터되도록, &lt;code&gt;a&lt;/code&gt; 의 컬럼이다 &lt;code&gt;u&lt;/code&gt; 는 우측 특이 벡터를 동시에, &lt;code&gt;a&lt;/code&gt; 열이 의 &lt;code&gt;v&lt;/code&gt; . 반면, numpy.linalg.svd는 인접한 \ (V ^ H \)를 세 번째 출력 인수로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bbd047da0be55151eb36335e2daf8007e4892af2" translate="yes" xml:space="preserve">
          <source>Much like Adam is essentially RMSprop with momentum, Nadam is Adam with Nesterov momentum.</source>
          <target state="translated">Adam은 기본적으로 운동량을 가진 RMSprop 인 것처럼 Nadam은 Nesterov 운동량을 가진 Adam입니다.</target>
        </trans-unit>
        <trans-unit id="25867a36c8cee72b523eb985d468821e9f148927" translate="yes" xml:space="preserve">
          <source>Multi-input usage:</source>
          <target state="translated">다중 입력 사용법 :</target>
        </trans-unit>
        <trans-unit id="d05322a9f3c047910c102b74c67ec9b4d7c8028b" translate="yes" xml:space="preserve">
          <source>Multi-label classification handles the case where each example may have zero or more associated labels, from a discrete set. This is distinct from &lt;code&gt;MultiClassHead&lt;/code&gt; which has exactly one label per example.</source>
          <target state="translated">다중 레이블 분류는 개별 예제에서 각 예제에 0 개 이상의 연관된 레이블이있는 경우를 처리합니다. 이것은 예제 당 정확히 하나의 레이블이있는 &lt;code&gt;MultiClassHead&lt;/code&gt; 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="3e6fa541d5398c3a673c1ac63d0c40e6406bb339" translate="yes" xml:space="preserve">
          <source>Multi-worker training with Estimator</source>
          <target state="translated">Estimator를 사용한 다중 작업자 교육</target>
        </trans-unit>
        <trans-unit id="4a5e1ae500bb7cdeea9988923f2efa5b06aaebe9" translate="yes" xml:space="preserve">
          <source>Multi-worker training with Keras</source>
          <target state="translated">Keras를 통한 다중 작업자 교육</target>
        </trans-unit>
        <trans-unit id="fa542a40b5540f372d928bad0d2990977695ad81" translate="yes" xml:space="preserve">
          <source>Multinomial distribution.</source>
          <target state="translated">다항 분포.</target>
        </trans-unit>
        <trans-unit id="0e18692bd370f834d92f369dcf0d15e10b60c738" translate="yes" xml:space="preserve">
          <source>Multiple Ragged Dimensions</source>
          <target state="translated">여러 개의 비정형 치수</target>
        </trans-unit>
        <trans-unit id="562992811ea87dc609a5aaa3da8e6225fc1e034b" translate="yes" xml:space="preserve">
          <source>Multiple calls to &lt;code&gt;control_dependencies()&lt;/code&gt; can be nested, and in that case a new &lt;code&gt;Operation&lt;/code&gt; will have control dependencies on the union of &lt;code&gt;control_inputs&lt;/code&gt; from all active contexts.</source>
          <target state="translated">&lt;code&gt;control_dependencies()&lt;/code&gt; 여러 호출을 중첩 할 수 있으며,이 경우 새 &lt;code&gt;Operation&lt;/code&gt; 에는 모든 활성 컨텍스트 의 &lt;code&gt;control_inputs&lt;/code&gt; 통합에 대한 제어 종속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="824c2fff609ec3d94874ba050f77d853d1d165a2" translate="yes" xml:space="preserve">
          <source>Multiplies 2 tensors (and/or variables) and returns a &lt;em&gt;tensor&lt;/em&gt;.</source>
          <target state="translated">곱 2 텐서 (및 / 또는 변수)와 리턴한다 &lt;em&gt;텐서&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d203061bc6d7cd80cb3cc679057951c296ee8aa4" translate="yes" xml:space="preserve">
          <source>Multiplies a scalar times a &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;IndexedSlices&lt;/code&gt; object.</source>
          <target state="translated">스칼라 곱하기 &lt;code&gt;Tensor&lt;/code&gt; 또는 &lt;code&gt;IndexedSlices&lt;/code&gt; 오브젝트를 곱 합니다.</target>
        </trans-unit>
        <trans-unit id="a27617a6cf526d8a5d4a069782ec117f36e5e98a" translate="yes" xml:space="preserve">
          <source>Multiplies matrix &lt;code&gt;a&lt;/code&gt; by matrix &lt;code&gt;b&lt;/code&gt;, producing &lt;code&gt;a&lt;/code&gt; * &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">행렬 &lt;code&gt;a&lt;/code&gt; 에 행렬 &lt;code&gt;b&lt;/code&gt; 를 곱하여 &lt;code&gt;a&lt;/code&gt; * &lt;code&gt;b&lt;/code&gt; 를 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="d2c82c98fa4cb4919387e141410545701b28bcb7" translate="yes" xml:space="preserve">
          <source>Multiplies matrix &lt;code&gt;a&lt;/code&gt; by vector &lt;code&gt;b&lt;/code&gt;, producing &lt;code&gt;a&lt;/code&gt; * &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">행렬 &lt;code&gt;a&lt;/code&gt; 에 벡터 &lt;code&gt;b&lt;/code&gt; 를 곱하여 &lt;code&gt;a&lt;/code&gt; * &lt;code&gt;b&lt;/code&gt; 를 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="d7fe462d932cc32436afe71eb8be4c2a382790ac" translate="yes" xml:space="preserve">
          <source>Multiplies sparse updates into a variable reference.</source>
          <target state="translated">희소 업데이트를 변수 참조에 곱합니다.</target>
        </trans-unit>
        <trans-unit id="f1dd3d0c16c907a98d4a8db0ba2dd37a67bb7f77" translate="yes" xml:space="preserve">
          <source>Multiplies the values in a tensor, alongside the specified axis.</source>
          <target state="translated">지정된 축과 함께 텐서의 값을 곱합니다.</target>
        </trans-unit>
        <trans-unit id="b3908189000ccde8c1b0543f0f63d22e39436f6b" translate="yes" xml:space="preserve">
          <source>Multiplies tridiagonal matrix by matrix.</source>
          <target state="translated">삼각 행렬에 행렬을 곱합니다.</target>
        </trans-unit>
        <trans-unit id="c9230895f1414212a457175d41d4c27592e4da88" translate="yes" xml:space="preserve">
          <source>Multiply SparseTensor (of rank 2) &quot;A&quot; by dense matrix &quot;B&quot;.</source>
          <target state="translated">SparseTensor (2 등급) &quot;A&quot;에 고밀도 매트릭스 &quot;B&quot;를 곱합니다.</target>
        </trans-unit>
        <trans-unit id="fde029073f5a60f4cb9396422627b162b7f0f0d2" translate="yes" xml:space="preserve">
          <source>Multiply matrix &quot;a&quot; by matrix &quot;b&quot;.</source>
          <target state="translated">행렬 &quot;a&quot;에 행렬 &quot;b&quot;를 곱하십시오.</target>
        </trans-unit>
        <trans-unit id="c2d1888d872bbe781f6582fc36890ae04953a5cf" translate="yes" xml:space="preserve">
          <source>Multiply this variable by &lt;a href=&quot;../../indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 변수에 &lt;a href=&quot;../../indexedslices&quot;&gt; &lt;code&gt;tf.IndexedSlices&lt;/code&gt; 를&lt;/a&gt; 곱하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e23a6d0ada7f1a33b06417960a582de3fe90fcb" translate="yes" xml:space="preserve">
          <source>Multiply this variable by &lt;a href=&quot;indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 변수에 &lt;a href=&quot;indexedslices&quot;&gt; &lt;code&gt;tf.IndexedSlices&lt;/code&gt; 를&lt;/a&gt; 곱하십시오 .</target>
        </trans-unit>
        <trans-unit id="fce0730f41e4926a271243e9d540e0468eb10cba" translate="yes" xml:space="preserve">
          <source>Multivalent categorical columns are not normalized. In other words the &lt;code&gt;sparse_combiner&lt;/code&gt; argument in the estimator constructor should be &quot;sum&quot;.</source>
          <target state="translated">다가 범주 열은 정규화되지 않습니다. 즉, 추정기 생성자 의 &lt;code&gt;sparse_combiner&lt;/code&gt; 인수는 &quot;sum&quot;이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3ef9edeb12e7bdb30fed6da3d9cad9ca56fc131d" translate="yes" xml:space="preserve">
          <source>Must be invoked in eager mode.</source>
          <target state="translated">열망 모드에서 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="a5bead550d70b3848380b69013e328ccadfac1c4" translate="yes" xml:space="preserve">
          <source>Must have &lt;code&gt;strides[0] = strides[3] = 1&lt;/code&gt;. For the most common case of the same horizontal and vertical strides, &lt;code&gt;strides = [1, stride, stride, 1]&lt;/code&gt;. If any value in &lt;code&gt;rate&lt;/code&gt; is greater than 1, we perform atrous depthwise convolution, in which case all values in the &lt;code&gt;strides&lt;/code&gt; tensor must be equal to 1.</source>
          <target state="translated">&lt;code&gt;strides[0] = strides[3] = 1&lt;/code&gt; 이어야 합니다. 동일한 수평 및 수직 보폭의 가장 일반적인 경우 &lt;code&gt;strides = [1, stride, stride, 1]&lt;/code&gt; 입니다. &lt;code&gt;rate&lt;/code&gt; 의 값 이 1보다 크면 깊이 깊이 컨볼 루션을 수행합니다.이 경우 &lt;code&gt;strides&lt;/code&gt; 텐서의 모든 값은 1과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="3f54286532c883373748b3609c3f73f3626e66f1" translate="yes" xml:space="preserve">
          <source>Must have &lt;code&gt;strides[0] = strides[3] = 1&lt;/code&gt;. For the most common case of the same horizontal and vertices strides, &lt;code&gt;strides = [1, stride, stride, 1]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;strides[0] = strides[3] = 1&lt;/code&gt; 이어야 합니다. 동일한 수평 및 정점 보폭의 가장 일반적인 경우 &lt;code&gt;strides = [1, stride, stride, 1]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bfccfdf0da7e16719add842526a9f32bdf0fb6a0" translate="yes" xml:space="preserve">
          <source>Mutable properties:</source>
          <target state="translated">가변 특성 :</target>
        </trans-unit>
        <trans-unit id="2db6d4239cd20837c3760914738b611e987aea46" translate="yes" xml:space="preserve">
          <source>N &lt;code&gt;gradient accumulators&lt;/code&gt;, one per variable to train. Gradients are pushed to them and the chief worker will wait until enough gradients are collected and then average them before applying to variables. The accumulator will drop all stale gradients (more details in the accumulator op).</source>
          <target state="translated">N 개의 &lt;code&gt;gradient accumulators&lt;/code&gt; , 훈련 할 변수 당 하나씩. 그라디언트가 푸시되고 수석 작업자는 충분한 그라디언트가 수집 될 때까지 기다린 다음 변수에 적용하기 전에 그라디언트를 평균합니다. 어큐뮬레이터는 모든 오래된 그라디언트를 떨어 뜨립니다 (어큐뮬레이터 op에 대한 자세한 내용 참조).</target>
        </trans-unit>
        <trans-unit id="a083ef5352b5d650b2a079357a1f2ade54e8efbf" translate="yes" xml:space="preserve">
          <source>N-D tensor with shape &lt;code&gt;[batch_size, timesteps, ...]&lt;/code&gt; or &lt;code&gt;[timesteps, batch_size, ...]&lt;/code&gt; when time_major is True.</source>
          <target state="translated">time_major가 True 일 때 모양이 &lt;code&gt;[batch_size, timesteps, ...]&lt;/code&gt; 또는 &lt;code&gt;[timesteps, batch_size, ...]&lt;/code&gt; ND 텐서 .</target>
        </trans-unit>
        <trans-unit id="fd6016f78695ef1a5b0efc9a3ba859d270928e9e" translate="yes" xml:space="preserve">
          <source>N-D tensor with shape: &lt;code&gt;(batch_size, ..., input_dim)&lt;/code&gt;. The most common situation would be a 2D input with shape &lt;code&gt;(batch_size, input_dim)&lt;/code&gt;.</source>
          <target state="translated">모양이 ND 텐서 : &lt;code&gt;(batch_size, ..., input_dim)&lt;/code&gt; . 가장 일반적인 상황은 shape &lt;code&gt;(batch_size, input_dim)&lt;/code&gt; 2D 입력입니다 .</target>
        </trans-unit>
        <trans-unit id="b1aad43f56084e08f9722f42e6a896ddf11136f4" translate="yes" xml:space="preserve">
          <source>N-D tensor with shape: &lt;code&gt;(batch_size, ..., units)&lt;/code&gt;. For instance, for a 2D input with shape &lt;code&gt;(batch_size, input_dim)&lt;/code&gt;, the output would have shape &lt;code&gt;(batch_size, units)&lt;/code&gt;.</source>
          <target state="translated">모양이있는 ND 텐서 : &lt;code&gt;(batch_size, ..., units)&lt;/code&gt; . 예를 들어 shape &lt;code&gt;(batch_size, input_dim)&lt;/code&gt; 인 2D 입력의 경우 출력은 shape &lt;code&gt;(batch_size, units)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="3bc35e77c4356443aaf21d56595cb19ef70a848b" translate="yes" xml:space="preserve">
          <source>N.B.: If &lt;code&gt;save_checkpoints_steps&lt;/code&gt; or &lt;code&gt;save_checkpoints_secs&lt;/code&gt; is set, &lt;code&gt;keep_checkpoint_max&lt;/code&gt; might need to be adjusted accordingly, especially in distributed training. For example, setting &lt;code&gt;save_checkpoints_secs&lt;/code&gt; as 60 without adjusting &lt;code&gt;keep_checkpoint_max&lt;/code&gt; (defaults to 5) leads to situation that checkpoint would be garbage collected after 5 minutes. In distributed training, the evaluation job starts asynchronously and might fail to load or find the checkpoint due to race condition.</source>
          <target state="translated">주의 : &lt;code&gt;save_checkpoints_steps&lt;/code&gt; 또는 &lt;code&gt;save_checkpoints_secs&lt;/code&gt; 가 설정된 경우 특히 분산 교육에서 &lt;code&gt;keep_checkpoint_max&lt;/code&gt; 를 적절히 조정해야 할 수 있습니다. 예를 들어 &lt;code&gt;keep_checkpoint_max&lt;/code&gt; (기본값은 5)를 조정하지 않고 &lt;code&gt;save_checkpoints_secs&lt;/code&gt; 를 60으로 설정 하면 5 분 후에 검사 점이 가비지 수집되는 상황이 발생합니다. 분산 교육에서 평가 작업은 비동기 적으로 시작되며 경쟁 조건으로 인해 검사 점을로드하거나 찾지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b30f636c1db14fd95b07c47ee096c9e7b2992dc" translate="yes" xml:space="preserve">
          <source>NASNet-A models for Keras.</source>
          <target state="translated">Keras 용 NASNet-A 모델.</target>
        </trans-unit>
        <trans-unit id="329be6cd697d977c9ec99cb5a8eb3c08e2e6a197" translate="yes" xml:space="preserve">
          <source>NB: The amount of time this method waits for the session is bounded by max_wait_secs. By default, this function will wait indefinitely.</source>
          <target state="translated">NB :이 메소드가 세션을 기다리는 시간은 max_wait_secs에 의해 제한됩니다. 기본적으로이 기능은 무기한 대기합니다.</target>
        </trans-unit>
        <trans-unit id="e53950c2b094f4e3159c13deb3697bdb6958726a" translate="yes" xml:space="preserve">
          <source>NCCL all-reduce implementation of CrossDeviceOps.</source>
          <target state="translated">NCCL은 CrossDeviceOps의 전체 축소 구현입니다.</target>
        </trans-unit>
        <trans-unit id="ef16280c8437524c7ebbab7dc8d561a3662ba768" translate="yes" xml:space="preserve">
          <source>NOTE &lt;a href=&quot;reverse&quot;&gt;&lt;code&gt;tf.reverse&lt;/code&gt;&lt;/a&gt; has now changed behavior in preparation for 1.0. &lt;code&gt;tf.reverse_v2&lt;/code&gt; is currently an alias that will be deprecated before TF 1.0.</source>
          <target state="translated">참고 &lt;a href=&quot;reverse&quot;&gt; &lt;code&gt;tf.reverse&lt;/code&gt; &lt;/a&gt; 는 이제 1.0 준비 과정에서 동작을 변경했습니다. &lt;code&gt;tf.reverse_v2&lt;/code&gt; 는 현재 TF 1.0 이전에 더 이상 사용되지 않는 별명입니다.</target>
        </trans-unit>
        <trans-unit id="96b4d2f86094a7ae0f46ccf88a4fb050ca38b073" translate="yes" xml:space="preserve">
          <source>NOTE(mrry): If we register &lt;strong&gt;getitem&lt;/strong&gt; as an overloaded operator, Python will valiantly attempt to iterate over the variable's Tensor from 0 to infinity. Declaring this method prevents this unintended behavior.</source>
          <target state="translated">참고 (미리) : &lt;strong&gt;getitem&lt;/strong&gt; 을 오버로드 된 연산자로 등록하면 Python은 변수의 Tensor를 0에서 무한대로 반복적으로 용감하게 시도합니다. 이 방법을 선언하면 의도하지 않은 동작이 방지됩니다.</target>
        </trans-unit>
        <trans-unit id="c3755a1d24438725e354f03134b93411d9bb33bd" translate="yes" xml:space="preserve">
          <source>NOTE(mrry): In normal circumstances, you should not need to construct a &lt;code&gt;DataType&lt;/code&gt; object directly. Instead, use the &lt;a href=&quot;as_dtype&quot;&gt;&lt;code&gt;tf.as_dtype()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">참고 (미리) : 일반적인 상황에서는 &lt;code&gt;DataType&lt;/code&gt; 객체를 직접 생성 할 필요가 없습니다 . 대신 &lt;a href=&quot;as_dtype&quot;&gt; &lt;code&gt;tf.as_dtype()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9dc6a3593a4e151bb413f36d6e9936e9b4062f05" translate="yes" xml:space="preserve">
          <source>NOTE(mrry): traceback.extract_stack eagerly retrieves the line of code for each stack frame using linecache, which results in an abundance of stat() calls. This implementation does not retrieve the code, and any consumer should apply _convert_stack to the result to obtain a traceback that can be formatted etc. using traceback methods.</source>
          <target state="translated">NOTE (미리) : traceback.extract_stack은 linecache를 사용하여 각 스택 프레임에 대한 코드 줄을 간절히 검색하므로 stat () 호출이 많이 발생합니다. 이 구현은 코드를 검색하지 않으며, 모든 소비자는 결과에 _convert_stack을 적용하여 역 추적 방법을 사용하여 형식을 지정할 수있는 역 추적을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="8c6abbe86b9a3dd54d847c73d2fcb02c7646f939" translate="yes" xml:space="preserve">
          <source>NOTE:</source>
          <target state="translated">NOTE:</target>
        </trans-unit>
        <trans-unit id="3616225191e3c898977be493d7426a0de5ac18e6" translate="yes" xml:space="preserve">
          <source>NOTE: &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are zero-indexed. &lt;code&gt;strides&lt;/code&gt; entries must be non-zero.</source>
          <target state="translated">참고 : &lt;code&gt;begin&lt;/code&gt; 과 &lt;code&gt;end&lt;/code&gt; 은 인덱스가 0입니다. &lt;code&gt;strides&lt;/code&gt; 항목은 0이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="7045712e8cad5b57d0508b61d04032562c6cb2f7" translate="yes" xml:space="preserve">
          <source>NOTE: Although the transformation creates a &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt;, the transformation must be the final &lt;code&gt;Dataset&lt;/code&gt; in the input pipeline.</source>
          <target state="translated">참고 : 변환이 &lt;a href=&quot;../dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; 을&lt;/a&gt; 생성하더라도 변환은 입력 파이프 라인 의 최종 &lt;code&gt;Dataset&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3f04427d92e52a05f96d958afb9cf2a5fce96d1a" translate="yes" xml:space="preserve">
          <source>NOTE: Currently, the user cannot add any more transformations to a distributed dataset.</source>
          <target state="translated">참고 : 현재 사용자는 분산 데이터 집합에 더 이상 변환을 추가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="56e88c91e01d7a1793225a810e0c446c7309d471" translate="yes" xml:space="preserve">
          <source>NOTE: For backwards compatibility, this method returns a list. If the given job was defined with a sparse set of task indices, the length of this list may not reflect the number of tasks defined in this job. Use the &lt;a href=&quot;clusterspec#num_tasks&quot;&gt;&lt;code&gt;tf.train.ClusterSpec.num_tasks&lt;/code&gt;&lt;/a&gt; method to find the number of tasks defined in a particular job.</source>
          <target state="translated">참고 : 이전 버전과의 호환성을 위해이 메서드는 목록을 반환합니다. 주어진 작업이 희소 한 작업 색인 세트로 정의 된 경우이 목록의 길이는이 작업에 정의 된 작업 수를 반영하지 않을 수 있습니다. &lt;a href=&quot;clusterspec#num_tasks&quot;&gt; &lt;code&gt;tf.train.ClusterSpec.num_tasks&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 특정 작업에 정의 된 태스크 수를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="83d2c9c851b7d2d7c844cd7135f938a898d81b53" translate="yes" xml:space="preserve">
          <source>NOTE: If &lt;code&gt;generator&lt;/code&gt; depends on mutable global variables or other external state, be aware that the runtime may invoke &lt;code&gt;generator&lt;/code&gt; multiple times (in order to support repeating the &lt;code&gt;Dataset&lt;/code&gt;) and at any time between the call to &lt;a href=&quot;../../../../data/dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt; and the production of the first element from the generator. Mutating global variables or external state can cause undefined behavior, and we recommend that you explicitly cache any external state in &lt;code&gt;generator&lt;/code&gt; before calling &lt;a href=&quot;../../../../data/dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 : 경우 &lt;code&gt;generator&lt;/code&gt; 가변 전역 변수 나 기타 외부 상태에 따라, 런타임이 호출 할 수 있음을 인식 &lt;code&gt;generator&lt;/code&gt; (반복 지원하기 위해 여러 번 &lt;code&gt;Dataset&lt;/code&gt; )과 호출 사이에 언제든지 &lt;a href=&quot;../../../../data/dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 및 생산 생성기의 첫 번째 요소 전역 변수 또는 외부 상태를 변경하면 정의되지 않은 동작이 발생할 수 있으므로 &lt;a href=&quot;../../../../data/dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 &lt;code&gt;generator&lt;/code&gt; 에서 외부 상태를 명시 적으로 캐시하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c17ac4a32fdbe745971e574b31777a99c3b8a992" translate="yes" xml:space="preserve">
          <source>NOTE: If &lt;code&gt;generator&lt;/code&gt; depends on mutable global variables or other external state, be aware that the runtime may invoke &lt;code&gt;generator&lt;/code&gt; multiple times (in order to support repeating the &lt;code&gt;Dataset&lt;/code&gt;) and at any time between the call to &lt;a href=&quot;../../../data/dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt; and the production of the first element from the generator. Mutating global variables or external state can cause undefined behavior, and we recommend that you explicitly cache any external state in &lt;code&gt;generator&lt;/code&gt; before calling &lt;a href=&quot;../../../data/dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 : 경우 &lt;code&gt;generator&lt;/code&gt; 가변 전역 변수 나 기타 외부 상태에 따라, 런타임이 호출 할 수 있음을 인식 &lt;code&gt;generator&lt;/code&gt; (반복 지원하기 위해 여러 번 &lt;code&gt;Dataset&lt;/code&gt; )과 호출 사이에 언제든지 &lt;a href=&quot;../../../data/dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 및 생산 생성기의 첫 번째 요소 전역 변수 또는 외부 상태를 변경하면 정의되지 않은 동작이 발생할 수 있으므로 &lt;a href=&quot;../../../data/dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 &lt;code&gt;generator&lt;/code&gt; 에서 외부 상태를 명시 적으로 캐시하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="10f1420e0dca2a52deb3aa6ef6240aabe5c810bf" translate="yes" xml:space="preserve">
          <source>NOTE: If &lt;code&gt;generator&lt;/code&gt; depends on mutable global variables or other external state, be aware that the runtime may invoke &lt;code&gt;generator&lt;/code&gt; multiple times (in order to support repeating the &lt;code&gt;Dataset&lt;/code&gt;) and at any time between the call to &lt;a href=&quot;../dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt; and the production of the first element from the generator. Mutating global variables or external state can cause undefined behavior, and we recommend that you explicitly cache any external state in &lt;code&gt;generator&lt;/code&gt; before calling &lt;a href=&quot;../dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 : 경우 &lt;code&gt;generator&lt;/code&gt; 가변 전역 변수 나 기타 외부 상태에 따라, 런타임이 호출 할 수 있음을 인식 &lt;code&gt;generator&lt;/code&gt; (반복 지원하기 위해 여러 번 &lt;code&gt;Dataset&lt;/code&gt; )과 호출 사이에 언제든지 &lt;a href=&quot;../dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 및 생산 생성기의 첫 번째 요소 전역 변수 또는 외부 상태를 변경하면 정의되지 않은 동작이 발생할 수 있으므로 &lt;a href=&quot;../dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 &lt;code&gt;generator&lt;/code&gt; 에서 외부 상태를 명시 적으로 캐시하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="b6d2276627b413ef99b740ac93ae825c0b27fc0a" translate="yes" xml:space="preserve">
          <source>NOTE: If &lt;code&gt;generator&lt;/code&gt; depends on mutable global variables or other external state, be aware that the runtime may invoke &lt;code&gt;generator&lt;/code&gt; multiple times (in order to support repeating the &lt;code&gt;Dataset&lt;/code&gt;) and at any time between the call to &lt;a href=&quot;dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt; and the production of the first element from the generator. Mutating global variables or external state can cause undefined behavior, and we recommend that you explicitly cache any external state in &lt;code&gt;generator&lt;/code&gt; before calling &lt;a href=&quot;dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 : 경우 &lt;code&gt;generator&lt;/code&gt; 가변 전역 변수 나 기타 외부 상태에 따라, 런타임이 호출 할 수 있음을 인식 &lt;code&gt;generator&lt;/code&gt; (반복 지원하기 위해 여러 번 &lt;code&gt;Dataset&lt;/code&gt; )과 호출 사이에 언제든지 &lt;a href=&quot;dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 및 생산 생성기의 첫 번째 요소 전역 변수 또는 외부 상태를 변경하면 정의되지 않은 동작이 발생할 수 있으므로 &lt;a href=&quot;dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 &lt;code&gt;generator&lt;/code&gt; 에서 외부 상태를 명시 적으로 캐시하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6b9cb830fb1aba495b51ee58fb852a6e93c4fd3c" translate="yes" xml:space="preserve">
          <source>NOTE: If this dataset is a function of global state (e.g. a random number generator), then different repetitions may produce different elements.</source>
          <target state="translated">참고 :이 데이터 세트가 전역 상태 (예 : 난수 생성기)의 함수 인 경우 다른 반복으로 인해 다른 요소가 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a3f57ec4be212445892ef82cad032bba6c1f951" translate="yes" xml:space="preserve">
          <source>NOTE: In TensorFlow 2.0, AutoGraph is automatically applied when using &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;. This module contains lower-level APIs for advanced use.</source>
          <target state="translated">참고 : TensorFlow 2.0에서 &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; 을&lt;/a&gt; 사용하면 AutoGraph가 자동으로 적용됩니다 . 이 모듈에는 고급 사용을위한 하위 레벨 API가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f240f4661deba5fe80a4a164dab4babe654538c0" translate="yes" xml:space="preserve">
          <source>NOTE: In TensorFlow 2.0, AutoGraph is automatically applied when using &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;. This module contains lower-level APIs for advanced use.</source>
          <target state="translated">참고 : TensorFlow 2.0에서 &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; 을&lt;/a&gt; 사용하면 AutoGraph가 자동으로 적용됩니다 . 이 모듈에는 고급 사용을위한 하위 레벨 API가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bfce4b170745e63142f9ddfec2414472a587003" translate="yes" xml:space="preserve">
          <source>NOTE: In eager mode, &lt;code&gt;computation&lt;/code&gt; will have &lt;code&gt;@tf.function&lt;/code&gt; semantics.</source>
          <target state="translated">참고 : 열망 모드에서 &lt;code&gt;computation&lt;/code&gt; 에는 &lt;code&gt;@tf.function&lt;/code&gt; 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7fda0f65c4494686dc1b872369c52d1aa3cd210" translate="yes" xml:space="preserve">
          <source>NOTE: In graph mode, to ensure that Assert executes, one usually attaches a dependency:</source>
          <target state="translated">참고 : 그래프 모드에서 Assert가 실행되도록하려면 일반적으로 종속성을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="1e1866295af5ffe36c310d38b9ab92ff7aff9206" translate="yes" xml:space="preserve">
          <source>NOTE: It is legitimate to call &lt;code&gt;Iterator.get_next()&lt;/code&gt; multiple times, e.g. when you are distributing different elements to multiple devices in a single step. However, a common pitfall arises when users call &lt;code&gt;Iterator.get_next()&lt;/code&gt; in each iteration of their training loop. &lt;code&gt;Iterator.get_next()&lt;/code&gt; adds ops to the graph, and executing each op allocates resources (including threads); as a consequence, invoking it in every iteration of a training loop causes slowdown and eventual resource exhaustion. To guard against this outcome, we log a warning when the number of uses crosses a fixed threshold of suspiciousness.</source>
          <target state="translated">참고 : 한 단계에서 여러 요소를 여러 장치에 배포 할 때와 같이 &lt;code&gt;Iterator.get_next()&lt;/code&gt; 여러 번 호출하는 것이 합법적 입니다. 그러나 사용자 가 학습 루프를 반복 할 때 마다 &lt;code&gt;Iterator.get_next()&lt;/code&gt; 를 호출하면 일반적인 함정이 발생 합니다. &lt;code&gt;Iterator.get_next()&lt;/code&gt; 는 그래프에 op를 추가하고 각 op를 실행하면 리소스 (스레드 포함)를 할당합니다. 결과적으로 훈련 루프를 반복 할 때마다 호출하면 속도가 느려지고 결국 리소스가 소진됩니다. 이러한 결과를 막기 위해 사용 횟수가 의심스러운 임계 값을 초과 할 때 경고를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="7023c08721fbd7fda8836f8ea1b83784ff6c62b2" translate="yes" xml:space="preserve">
          <source>NOTE: MLIR-Based TensorFlow Compiler is under active development and has missing features, please refrain from using. This API exists for development and testing only.</source>
          <target state="translated">참고 : MLIR 기반 TensorFlow 컴파일러는 현재 개발 중이며 누락 된 기능이 있으므로 사용을 자제하십시오. 이 API는 개발 및 테스트 용으로 만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="bf308e87b24a8a223b70e3706e19b171c98ffbe0" translate="yes" xml:space="preserve">
          <source>NOTE: MUST mirror the behavior of the C++ AppendFlagsIntoFile from https://github.com/gflags/gflags.</source>
          <target state="translated">참고 : https://github.com/gflags/gflags에서 C ++ AppendFlagsIntoFile의 동작을 미러링해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c56cdc96cd42f0a4d8b37d7d35b3a76756d542a" translate="yes" xml:space="preserve">
          <source>NOTE: MUST mirror the behavior of the C++ CommandlineFlagsIntoString from https://github.com/gflags/gflags.</source>
          <target state="translated">참고 : https://github.com/gflags/gflags에서 C ++ CommandlineFlagsIntoString의 동작을 미러링해야합니다.</target>
        </trans-unit>
        <trans-unit id="683847739697af93b0d15ac410a6e53485306ed7" translate="yes" xml:space="preserve">
          <source>NOTE: Prefer using the Tensor division operator or tf.divide which obey Python 3 division operator semantics.</source>
          <target state="translated">참고 : Python 3 나누기 연산자 의미를 따르는 Tensor 나누기 연산자 또는 tf.divide를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c0ad0a2f05ff98feecaf73439669929c69e4987f" translate="yes" xml:space="preserve">
          <source>NOTE: Prefer using the Tensor operator or tf.divide which obey Python division operator semantics.</source>
          <target state="translated">참고 : Python 나누기 연산자 의미를 따르는 Tensor 연산자 또는 tf.divide를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4cbb6a77026e9cb146e1edde53ce44fb21a35ce0" translate="yes" xml:space="preserve">
          <source>NOTE: Restarting training from saved &lt;code&gt;meta_graph&lt;/code&gt; only works if the device assignments have not changed.</source>
          <target state="translated">참고 : 저장된 &lt;code&gt;meta_graph&lt;/code&gt; 에서 훈련을 다시 시작 하면 장치 할당이 변경되지 않은 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="efa6d9d345e9a9207c5928e4a1ab9f0a189b4b04" translate="yes" xml:space="preserve">
          <source>NOTE: The context managers will always be exited without any error information. This is an unfortunate implementation detail due to some internals of how unittest runs tests.</source>
          <target state="translated">참고 : 컨텍스트 관리자는 항상 오류 정보없이 종료됩니다. 이것은 unittest가 테스트를 실행하는 방법에 대한 일부 내부 구조로 인해 불행한 구현 세부 사항입니다.</target>
        </trans-unit>
        <trans-unit id="996f3ec56e99068804b3b11dd656edb2925215d7" translate="yes" xml:space="preserve">
          <source>NOTE: The conversion functions will execute in order of priority, followed by order of registration. To ensure that a conversion function &lt;code&gt;F&lt;/code&gt; runs before another conversion function &lt;code&gt;G&lt;/code&gt;, ensure that &lt;code&gt;F&lt;/code&gt; is registered with a smaller priority than &lt;code&gt;G&lt;/code&gt;.</source>
          <target state="translated">참고 : 변환 기능은 우선 순위에 따라 등록 순서에 따라 실행됩니다. 변환 함수 &lt;code&gt;F&lt;/code&gt; 가 다른 변환 함수 &lt;code&gt;G&lt;/code&gt; 보다 먼저 실행 되도록하려면 &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;G&lt;/code&gt; 보다 우선 순위가 작은 것으로 등록되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a1284bfef15f833b77a1c83325c3bf163d03ccb" translate="yes" xml:space="preserve">
          <source>NOTE: The current implementation of &lt;a href=&quot;../../../../data/dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;../../../../numpy_function&quot;&gt;&lt;code&gt;tf.numpy_function&lt;/code&gt;&lt;/a&gt; and inherits the same constraints. In particular, it requires the &lt;code&gt;Dataset&lt;/code&gt;- and &lt;code&gt;Iterator&lt;/code&gt;-related operations to be placed on a device in the same process as the Python program that called &lt;a href=&quot;../../../../data/dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt;. The body of &lt;code&gt;generator&lt;/code&gt; will not be serialized in a &lt;code&gt;GraphDef&lt;/code&gt;, and you should not use this method if you need to serialize your model and restore it in a different environment.</source>
          <target state="translated">참고 : 현재 구현 &lt;a href=&quot;../../../../data/dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 사용 &lt;a href=&quot;../../../../numpy_function&quot;&gt; &lt;code&gt;tf.numpy_function&lt;/code&gt; 을&lt;/a&gt; 같은 제약 조건을 상속합니다. 특히, &lt;code&gt;Dataset&lt;/code&gt; 및 &lt;code&gt;Iterator&lt;/code&gt; 관련 작업은 &lt;a href=&quot;../../../../data/dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 라는 Python 프로그램과 동일한 프로세스에서 장치에 배치해야합니다 . &lt;code&gt;generator&lt;/code&gt; 본문은 &lt;code&gt;GraphDef&lt;/code&gt; 에서 직렬화 되지 않으며 모델을 직렬화하고 다른 환경에서 복원해야하는 경우이 방법을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="0ce30723353df28ded04090716887f0f65646338" translate="yes" xml:space="preserve">
          <source>NOTE: The current implementation of &lt;a href=&quot;../../../data/dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;../../../numpy_function&quot;&gt;&lt;code&gt;tf.numpy_function&lt;/code&gt;&lt;/a&gt; and inherits the same constraints. In particular, it requires the &lt;code&gt;Dataset&lt;/code&gt;- and &lt;code&gt;Iterator&lt;/code&gt;-related operations to be placed on a device in the same process as the Python program that called &lt;a href=&quot;../../../data/dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt;. The body of &lt;code&gt;generator&lt;/code&gt; will not be serialized in a &lt;code&gt;GraphDef&lt;/code&gt;, and you should not use this method if you need to serialize your model and restore it in a different environment.</source>
          <target state="translated">참고 : 현재 구현 &lt;a href=&quot;../../../data/dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 사용 &lt;a href=&quot;../../../numpy_function&quot;&gt; &lt;code&gt;tf.numpy_function&lt;/code&gt; 을&lt;/a&gt; 같은 제약 조건을 상속합니다. 특히, &lt;code&gt;Dataset&lt;/code&gt; 및 &lt;code&gt;Iterator&lt;/code&gt; 관련 작업은 &lt;a href=&quot;../../../data/dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 라는 Python 프로그램과 동일한 프로세스에서 장치에 배치해야합니다 . &lt;code&gt;generator&lt;/code&gt; 본문은 &lt;code&gt;GraphDef&lt;/code&gt; 에서 직렬화 되지 않으며 모델을 직렬화하고 다른 환경에서 복원해야하는 경우이 방법을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="9dc1c962a7f62c6d8ec9ddf837aee055cfc38042" translate="yes" xml:space="preserve">
          <source>NOTE: The current implementation of &lt;a href=&quot;../dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;../../numpy_function&quot;&gt;&lt;code&gt;tf.numpy_function&lt;/code&gt;&lt;/a&gt; and inherits the same constraints. In particular, it requires the &lt;code&gt;Dataset&lt;/code&gt;- and &lt;code&gt;Iterator&lt;/code&gt;-related operations to be placed on a device in the same process as the Python program that called &lt;a href=&quot;../dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt;. The body of &lt;code&gt;generator&lt;/code&gt; will not be serialized in a &lt;code&gt;GraphDef&lt;/code&gt;, and you should not use this method if you need to serialize your model and restore it in a different environment.</source>
          <target state="translated">참고 : 현재 구현 &lt;a href=&quot;../dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 사용 &lt;a href=&quot;../../numpy_function&quot;&gt; &lt;code&gt;tf.numpy_function&lt;/code&gt; 을&lt;/a&gt; 같은 제약 조건을 상속합니다. 특히, &lt;code&gt;Dataset&lt;/code&gt; 및 &lt;code&gt;Iterator&lt;/code&gt; 관련 작업은 &lt;a href=&quot;../dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 라는 Python 프로그램과 동일한 프로세스에서 장치에 배치해야합니다 . &lt;code&gt;generator&lt;/code&gt; 본문은 &lt;code&gt;GraphDef&lt;/code&gt; 에서 직렬화 되지 않으며 모델을 직렬화하고 다른 환경에서 복원해야하는 경우이 방법을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="ef3251a0d5af6f13bc8d97c66b6c26ad0b5983b1" translate="yes" xml:space="preserve">
          <source>NOTE: The current implementation of &lt;a href=&quot;dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;../numpy_function&quot;&gt;&lt;code&gt;tf.numpy_function&lt;/code&gt;&lt;/a&gt; and inherits the same constraints. In particular, it requires the &lt;code&gt;Dataset&lt;/code&gt;- and &lt;code&gt;Iterator&lt;/code&gt;-related operations to be placed on a device in the same process as the Python program that called &lt;a href=&quot;dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt;. The body of &lt;code&gt;generator&lt;/code&gt; will not be serialized in a &lt;code&gt;GraphDef&lt;/code&gt;, and you should not use this method if you need to serialize your model and restore it in a different environment.</source>
          <target state="translated">참고 : 현재 구현 &lt;a href=&quot;dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 사용 &lt;a href=&quot;../numpy_function&quot;&gt; &lt;code&gt;tf.numpy_function&lt;/code&gt; 을&lt;/a&gt; 같은 제약 조건을 상속합니다. 특히, &lt;code&gt;Dataset&lt;/code&gt; 및 &lt;code&gt;Iterator&lt;/code&gt; 관련 작업은 &lt;a href=&quot;dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 라는 Python 프로그램과 동일한 프로세스에서 장치에 배치해야합니다 . &lt;code&gt;generator&lt;/code&gt; 본문은 &lt;code&gt;GraphDef&lt;/code&gt; 에서 직렬화 되지 않으며 모델을 직렬화하고 다른 환경에서 복원해야하는 경우이 방법을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="8ff878ce6ae336084bc9e1b27ee6cdb321684acd" translate="yes" xml:space="preserve">
          <source>NOTE: The default behavior of this method is to return filenames in a non-deterministic random shuffled order. Pass a &lt;code&gt;seed&lt;/code&gt; or &lt;code&gt;shuffle=False&lt;/code&gt; to get results in a deterministic order.</source>
          <target state="translated">참고 :이 방법의 기본 동작은 파일 이름을 결정적이지 않은 임의 순서 순서대로 반환하는 것입니다. 패스 &lt;code&gt;seed&lt;/code&gt; 또는 &lt;code&gt;shuffle=False&lt;/code&gt; 결정적 순서로 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24ad263ff6825f62b2024bae8370843c8715b4ec" translate="yes" xml:space="preserve">
          <source>NOTE: The default graph is a property of the current thread. If you create a new thread, and wish to use the default graph in that thread, you must explicitly add a &lt;code&gt;with g.as_default():&lt;/code&gt; in that thread's function.</source>
          <target state="translated">참고 : 기본 그래프는 현재 스레드의 속성입니다. 새 스레드를 작성하고 해당 스레드에서 기본 그래프를 사용하려는 경우 해당 스레드 함수에서 &lt;code&gt;with g.as_default():&lt;/code&gt; 를 명시 적으로 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d95d78127ee2a7c8ba9bf73dbd7708d35d9d43b2" translate="yes" xml:space="preserve">
          <source>NOTE: The default graph is a property of the current thread. This function applies only to the current thread. Calling this function while a &lt;a href=&quot;session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;interactivesession&quot;&gt;&lt;code&gt;tf.compat.v1.InteractiveSession&lt;/code&gt;&lt;/a&gt; is active will result in undefined behavior. Using any previously created &lt;a href=&quot;../../operation&quot;&gt;&lt;code&gt;tf.Operation&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects after calling this function will result in undefined behavior. Raises: AssertionError: If this function is called within a nested graph.</source>
          <target state="translated">참고 : 기본 그래프는 현재 스레드의 속성입니다. 이 기능은 현재 스레드에만 적용됩니다. &lt;a href=&quot;session&quot;&gt; &lt;code&gt;tf.compat.v1.Session&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;interactivesession&quot;&gt; &lt;code&gt;tf.compat.v1.InteractiveSession&lt;/code&gt; &lt;/a&gt; 이 활성화 된 상태에서이 함수를 호출하면 정의되지 않은 동작이 발생합니다. 이 함수를 호출 한 후 이전에 생성 된 &lt;a href=&quot;../../operation&quot;&gt; &lt;code&gt;tf.Operation&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; 객체를 사용하면 정의되지 않은 동작이 발생합니다. 발생 : AssertionError :이 함수가 중첩 그래프 내에서 호출 된 경우.</target>
        </trans-unit>
        <trans-unit id="dd7a93678f86da193b39dcf8b3b1c3be378f8382" translate="yes" xml:space="preserve">
          <source>NOTE: The default session is a property of the current thread. If you create a new thread, and wish to use the default session in that thread, you must explicitly add a &lt;code&gt;with sess.as_default():&lt;/code&gt; in that thread's function.</source>
          <target state="translated">참고 : 기본 세션은 현재 스레드의 속성입니다. 새 스레드를 작성하고 해당 스레드에서 기본 세션을 사용하려면 해당 스레드의 함수에서 &lt;code&gt;with sess.as_default():&lt;/code&gt; 를 명시 적으로 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4baa89782dc8c888eebd2e10e436d541a7e7222b" translate="yes" xml:space="preserve">
          <source>NOTE: The directory and its contents will be recursively cleared before creation. This ensures that there is no pre-existing state.</source>
          <target state="translated">참고 : 디렉토리와 그 내용은 생성 전에 재귀 적으로 지워집니다. 이는 기존 상태가 없음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="f33812b825ed1f4a589cca82e95a10ebf6e3f7a4" translate="yes" xml:space="preserve">
          <source>NOTE: The order of elements yielded by this transformation is deterministic, as long as &lt;code&gt;map_func&lt;/code&gt; is a pure function. If &lt;code&gt;map_func&lt;/code&gt; contains any stateful operations, the order in which that state is accessed is undefined.</source>
          <target state="translated">참고 : &lt;code&gt;map_func&lt;/code&gt; 가 순수한 함수 인 한이 변환으로 생성 된 요소의 순서는 결정적 입니다. &lt;code&gt;map_func&lt;/code&gt; 에 상태 저장 작업이 포함 된 경우 해당 상태에 액세스하는 순서는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2eb6aa3cc50328f6f5589131571e8b6f8ff578c" translate="yes" xml:space="preserve">
          <source>NOTE: The order of the files returned is deterministic.</source>
          <target state="translated">참고 : 반환 된 파일의 순서는 결정적입니다.</target>
        </trans-unit>
        <trans-unit id="729538d9da4ffd659710e20715b4836a9e18734f" translate="yes" xml:space="preserve">
          <source>NOTE: This constructor validates the given &lt;code&gt;name&lt;/code&gt;. Valid scope names match one of the following regular expressions:</source>
          <target state="translated">참고 :이 생성자는 지정된 &lt;code&gt;name&lt;/code&gt; 유효성을 검사합니다 . 유효한 범위 이름은 다음 정규식 중 하나와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b6c05e852481b6aa8d8a5c62a532de2680ca2337" translate="yes" xml:space="preserve">
          <source>NOTE: This constructor validates the name of the &lt;code&gt;Operation&lt;/code&gt; (passed as &lt;code&gt;node_def.name&lt;/code&gt;). Valid &lt;code&gt;Operation&lt;/code&gt; names match the following regular expression:</source>
          <target state="translated">참고 :이 생성자는 &lt;code&gt;Operation&lt;/code&gt; 이름의 유효성을 검사합니다 ( &lt;code&gt;node_def.name&lt;/code&gt; 으로 전달 ). 유효한 &lt;code&gt;Operation&lt;/code&gt; 이름은 다음 정규식과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="da2fcb0e3008820bc83d67c4c47ec7579e199830" translate="yes" xml:space="preserve">
          <source>NOTE: This differs from &lt;a href=&quot;tensor#set_shape&quot;&gt;&lt;code&gt;Tensor.set_shape&lt;/code&gt;&lt;/a&gt; in that it sets the static shape of the resulting tensor and enforces it at runtime, raising an error if the tensor's runtime shape is incompatible with the specified shape. &lt;a href=&quot;tensor#set_shape&quot;&gt;&lt;code&gt;Tensor.set_shape&lt;/code&gt;&lt;/a&gt; sets the static shape of the tensor without enforcing it at runtime, which may result in inconsistencies between the statically-known shape of tensors and the runtime value of tensors.</source>
          <target state="translated">참고 : 이것은 &lt;a href=&quot;tensor#set_shape&quot;&gt; &lt;code&gt;Tensor.set_shape&lt;/code&gt; &lt;/a&gt; 와 다릅니다 . 결과 텐서의 정적 모양을 설정하고 런타임에 적용하여 텐서의 런타임 모양이 지정된 모양과 호환되지 않으면 오류가 발생한다는 점에서 다릅니다 . &lt;a href=&quot;tensor#set_shape&quot;&gt; &lt;code&gt;Tensor.set_shape&lt;/code&gt; &lt;/a&gt; 는 런타임에 강제로 텐서의 정적 모양을 설정하므로 정적으로 알려진 텐서 모양과 텐서의 런타임 값간에 불일치가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8710a149aad34772c8807c22293080935b4bfb4" translate="yes" xml:space="preserve">
          <source>NOTE: This function is obsolete and will be removed in 6 months. Please change your implementation to use &lt;code&gt;report_uninitialized_variables()&lt;/code&gt;.</source>
          <target state="translated">참고 :이 기능은 더 이상 사용되지 않으며 6 개월 후에 제거됩니다. &lt;code&gt;report_uninitialized_variables()&lt;/code&gt; 를 사용하도록 구현을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="8973611dbe3347bc91476e1fed5550c3db7f323d" translate="yes" xml:space="preserve">
          <source>NOTE: This is an escape hatch for existing uses of &lt;code&gt;filter&lt;/code&gt; that do not work with V2 functions. New uses are strongly discouraged and existing uses should migrate to &lt;code&gt;filter&lt;/code&gt; as this method will be removed in V2.</source>
          <target state="translated">참고 : 이것은 V2 기능에서 작동하지 않는 기존 &lt;code&gt;filter&lt;/code&gt; 사용을위한 탈출구 입니다. 이 방법은 V2에서 제거 되므로 새로운 용도는 사용하지 않는 것이 좋으며 기존 용도는 &lt;code&gt;filter&lt;/code&gt; 로 마이그레이션해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9c375eea5e94508c273735102f4bc69d276fde7c" translate="yes" xml:space="preserve">
          <source>NOTE: This is an escape hatch for existing uses of &lt;code&gt;map&lt;/code&gt; that do not work with V2 functions. New uses are strongly discouraged and existing uses should migrate to &lt;code&gt;map&lt;/code&gt; as this method will be removed in V2.</source>
          <target state="translated">참고 : V2 기능에서 작동하지 않는 기존 &lt;code&gt;map&lt;/code&gt; 사용을위한 탈출구 입니다. 이 방법은 V2에서 제거 되므로 새로운 용도는 사용하지 않는 것이 좋으며 기존 용도는 &lt;code&gt;map&lt;/code&gt; 로 마이그레이션해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1c464ca4e817e3d69d913a48d0265ab146368a4f" translate="yes" xml:space="preserve">
          <source>NOTE: This is an escape hatch for existing uses of &lt;code&gt;map_and_batch&lt;/code&gt; that do not work with V2 functions. New uses are strongly discouraged and existing uses should migrate to &lt;code&gt;map_and_batch&lt;/code&gt; as this method will not be removed in V2.</source>
          <target state="translated">참고 : V2 기능에서 작동하지 않는 &lt;code&gt;map_and_batch&lt;/code&gt; 의 기존 사용을위한 이스케이프 해치입니다 . 이 방법은 V2에서 제거되지 않으므로 새 용도는 사용 하지 않는 것이 &lt;code&gt;map_and_batch&lt;/code&gt; 기존 용도는 map_and_batch 로 마이그레이션해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fa46499d4cf0599cd6282c538d0aaae468f3bd91" translate="yes" xml:space="preserve">
          <source>NOTE: This is an experimental feature.</source>
          <target state="translated">참고 : 이것은 실험적인 기능입니다.</target>
        </trans-unit>
        <trans-unit id="c9903d34bfa5caeff689a3a18fefd7d2cd61afe4" translate="yes" xml:space="preserve">
          <source>NOTE: This is not the same as the &lt;code&gt;self.name_scope.name&lt;/code&gt; which includes parent module names.</source>
          <target state="translated">참고 : 이것은 상위 모듈 이름을 포함 하는 &lt;code&gt;self.name_scope.name&lt;/code&gt; 과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="d7dc3e032f53c199a0f604e1edc35f7cbcd055b1" translate="yes" xml:space="preserve">
          <source>NOTE: This method takes an argument that defines the structure of the value that would be contained in the returned &lt;code&gt;Optional&lt;/code&gt; if it had a value.</source>
          <target state="translated">참고 :이 메서드는 값이있는 경우 반환 된 &lt;code&gt;Optional&lt;/code&gt; 에 포함될 값의 구조를 정의하는 인수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="25fb85da18624797a3defa0d51095bf82f41fffc" translate="yes" xml:space="preserve">
          <source>NOTE: This modified program still works fine as a single program. The single program marks itself as the chief.</source>
          <target state="translated">참고 :이 수정 된 프로그램은 여전히 ​​단일 프로그램으로 작동합니다. 단일 프로그램은 스스로를 최고로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="2638e7baff5cec4b35bd96338994a8e0b5185b12" translate="yes" xml:space="preserve">
          <source>NOTE: This shape is not enforced at runtime. Setting incorrect shapes can result in inconsistencies between the statically-known graph and the runtime value of tensors. For runtime validation of the shape, use &lt;a href=&quot;ensure_shape&quot;&gt;&lt;code&gt;tf.ensure_shape&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">참고 :이 셰이프는 런타임에 적용되지 않습니다. 잘못된 모양을 설정하면 정적으로 알려진 그래프와 텐서의 런타임 값간에 불일치가 발생할 수 있습니다. 모양의 런타임 유효성 검사를 &lt;a href=&quot;ensure_shape&quot;&gt; &lt;code&gt;tf.ensure_shape&lt;/code&gt; &lt;/a&gt; 대신 tf.ensure_shape를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cd3ea3ff47dc681a1f1086660a0f3b033315c559" translate="yes" xml:space="preserve">
          <source>NOTE: This will zero-out the file. This ensures there is no pre-existing state. NOTE: If the file already exists, it will be made writable and overwritten.</source>
          <target state="translated">참고 : 이렇게하면 파일이 제거됩니다. 이렇게하면 기존 상태가 없습니다. 참고 : 파일이 이미 있으면 쓰기 가능하고 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="4fd629fd5aa77ce9bf3a720206387efce64814f3" translate="yes" xml:space="preserve">
          <source>NOTE: We use element names that are consistent with those used by the C++ command-line flag library, from https://github.com/gflags/gflags. We also use a few new elements (e.g.,</source>
          <target state="translated">참고 : 우리는 https://github.com/gflags/gflags의 C ++ 명령 행 플래그 라이브러리에서 사용하는 것과 일치하는 요소 이름을 사용합니다. 또한 몇 가지 새로운 요소 (예 :</target>
        </trans-unit>
        <trans-unit id="f054bd2415d59834c5afa4d8fb3a21b3323535bb" translate="yes" xml:space="preserve">
          <source>NOTE: in the docstrings of all DEFINE* functions, &quot;registers&quot; is short for &quot;creates a new flag and registers it&quot;.</source>
          <target state="translated">참고 : 모든 DEFINE * 함수의 docstring에서 &quot;registers&quot;는 &quot;새 플래그를 만들고 등록&quot;의 줄임말입니다.</target>
        </trans-unit>
        <trans-unit id="8bc4687dbd0f799253d60f4172ac9a2623210f34" translate="yes" xml:space="preserve">
          <source>NOTE: we use strings, and not the types.*Type constants because our flags can have more exotic types, e.g., 'comma separated list of strings', 'whitespace separated list of strings', etc.</source>
          <target state="translated">참고 : 유형이 아닌 문자열을 사용합니다. * 플래그는 '쉼표로 구분 된 문자열 목록', '공백으로 구분 된 문자열 목록'등과 같이보다 이국적인 유형을 가질 수 있으므로 유형 상수</target>
        </trans-unit>
        <trans-unit id="1104eefed6514b1f5cdaa6a29c1337f707ac335d" translate="yes" xml:space="preserve">
          <source>Name prepended to all ops created by this &lt;code&gt;Distribution&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;Distribution&lt;/code&gt; 생성 된 모든 작업 앞에 붙는 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="a7746578f84ffdc5775b6ba46fc11c99af24f55c" translate="yes" xml:space="preserve">
          <source>Name scope context manager.</source>
          <target state="translated">이름 범위 컨텍스트 관리자</target>
        </trans-unit>
        <trans-unit id="9f340ff6565652028b5a658440e8c4ba297b9762" translate="yes" xml:space="preserve">
          <source>Name-based &lt;a href=&quot;../compat/v1/train/saver&quot;&gt;&lt;code&gt;tf.compat.v1.train.Saver&lt;/code&gt;&lt;/a&gt; checkpoints from TensorFlow 1.x can be loaded using this method. Names are used to match variables. Re-encode name-based checkpoints using &lt;a href=&quot;checkpoint#save&quot;&gt;&lt;code&gt;tf.train.Checkpoint.save&lt;/code&gt;&lt;/a&gt; as soon as possible.</source>
          <target state="translated">이 방법을 사용하여 TensorFlow 1.x의 이름 기반 &lt;a href=&quot;../compat/v1/train/saver&quot;&gt; &lt;code&gt;tf.compat.v1.train.Saver&lt;/code&gt; &lt;/a&gt; 검사 점을로드 할 수 있습니다. 이름은 변수를 일치시키는 데 사용됩니다. &lt;a href=&quot;checkpoint#save&quot;&gt; &lt;code&gt;tf.train.Checkpoint.save&lt;/code&gt; &lt;/a&gt; 를 사용하여 가능한 빨리 이름 기반 검사 점을 다시 인코딩 하십시오.</target>
        </trans-unit>
        <trans-unit id="2a5eb5447e34cfda4ed5b878b12576d5e95aed0e" translate="yes" xml:space="preserve">
          <source>Name-based &lt;a href=&quot;saver&quot;&gt;&lt;code&gt;tf.compat.v1.train.Saver&lt;/code&gt;&lt;/a&gt; checkpoints can be loaded using this method. Names are used to match variables. No restore ops are created/run until &lt;code&gt;run_restore_ops()&lt;/code&gt; or &lt;code&gt;initialize_or_restore()&lt;/code&gt; are called on the returned status object when graph building, but there is restore-on-creation when executing eagerly. Re-encode name-based checkpoints using &lt;a href=&quot;../../../train/checkpoint#save&quot;&gt;&lt;code&gt;tf.train.Checkpoint.save&lt;/code&gt;&lt;/a&gt; as soon as possible.</source>
          <target state="translated">이름 기반 &lt;a href=&quot;saver&quot;&gt; &lt;code&gt;tf.compat.v1.train.Saver&lt;/code&gt; &lt;/a&gt; 검사 점은이 방법을 사용하여로드 할 수 있습니다. 이름은 변수를 일치시키는 데 사용됩니다. 그래프 작성시 리턴 된 상태 오브젝트에서 &lt;code&gt;run_restore_ops()&lt;/code&gt; 또는 &lt;code&gt;initialize_or_restore()&lt;/code&gt; 가 호출 될 때까지 복원 조작이 작성 / 실행되지 않지만 , 열심히 실행할 때 작성시 복원이 있습니다. &lt;a href=&quot;../../../train/checkpoint#save&quot;&gt; &lt;code&gt;tf.train.Checkpoint.save&lt;/code&gt; &lt;/a&gt; 를 사용하여 가능한 빨리 이름 기반 검사 점을 다시 인코딩 하십시오.</target>
        </trans-unit>
        <trans-unit id="28d5c9549dfad381de16f27e40b1abd9011bb761" translate="yes" xml:space="preserve">
          <source>Named outputs must be provided as a dict from string to &lt;code&gt;Tensor&lt;/code&gt;,</source>
          <target state="translated">명명 된 출력은 string에서 &lt;code&gt;Tensor&lt;/code&gt; 까지의 dict로 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c047751220a4a022bf8b34d1d07288536626e59e" translate="yes" xml:space="preserve">
          <source>Negative means, for every element &lt;code&gt;x[i]&lt;/code&gt; of &lt;code&gt;x&lt;/code&gt;, we have &lt;code&gt;x[i] &amp;lt; 0&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is empty this is trivially satisfied.</source>
          <target state="translated">네거티브 수단은, 각 요소에 대해 &lt;code&gt;x[i]&lt;/code&gt; 중 &lt;code&gt;x&lt;/code&gt; , 우리가 &lt;code&gt;x[i] &amp;lt; 0&lt;/code&gt; . 경우 &lt;code&gt;x&lt;/code&gt; 가 비어있는이 하찮게 만족된다.</target>
        </trans-unit>
        <trans-unit id="9997061cc1df2fc344d7b363fa6a6c8dbc975409" translate="yes" xml:space="preserve">
          <source>Neither &lt;code&gt;args&lt;/code&gt; nor &lt;code&gt;kwargs&lt;/code&gt; may contain per-replica values. If they contain mirrored values, they will be unwrapped before calling &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 나 크 &lt;code&gt;kwargs&lt;/code&gt; 모두 복제 본당 값을 포함 할 수 없습니다 . 미러링 된 값이 포함 된 경우 &lt;code&gt;fn&lt;/code&gt; 을 호출하기 전에 래핑되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9a9abf30cef4dff5ab30c1aa4c6cfcb04ec5d70" translate="yes" xml:space="preserve">
          <source>Nesting custom gradients can lead to unintuitive results. The default behavior does not correspond to n-th order derivatives. For example</source>
          <target state="translated">커스텀 그라디언트를 중첩하면 직관적이지 않은 결과가 발생할 수 있습니다. 기본 동작은 n 차 미분에 해당하지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="bbacaddc658debb06d141833d26e0cd44d13023a" translate="yes" xml:space="preserve">
          <source>Neural machine translation with attention</source>
          <target state="translated">신경망 기계 번역</target>
        </trans-unit>
        <trans-unit id="55d7fd8cd5468a225d03e756ead0c2dd940cb199" translate="yes" xml:space="preserve">
          <source>Neural style transfer</source>
          <target state="translated">신경 스타일 전송</target>
        </trans-unit>
        <trans-unit id="df3e49001e3d6ba6769a46b475ccd41b26b3e0de" translate="yes" xml:space="preserve">
          <source>Never learns to output repeated classes, as they are collapsed in the input labels before training.</source>
          <target state="translated">교육 전에 입력 레이블에서 축소 된 반복되는 클래스를 출력하는 방법을 배우지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0d8cee794ca609da92a448ad76164b7e16c75c36" translate="yes" xml:space="preserve">
          <source>New &lt;a href=&quot;options&quot;&gt;&lt;code&gt;tf.data.Options()&lt;/code&gt;&lt;/a&gt; object which is the result of merging self with the input &lt;a href=&quot;options&quot;&gt;&lt;code&gt;tf.data.Options&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력 &lt;a href=&quot;options&quot;&gt; &lt;code&gt;tf.data.Options&lt;/code&gt; &lt;/a&gt; 와 자체를 병합 한 결과 인 새로운 &lt;a href=&quot;options&quot;&gt; &lt;code&gt;tf.data.Options()&lt;/code&gt; &lt;/a&gt; 객체 .</target>
        </trans-unit>
        <trans-unit id="fe0226ce7bb4d26ccf6d7d0209ba867cc25146f1" translate="yes" xml:space="preserve">
          <source>Newlines are stripped from the output. See ReaderBase for supported methods.</source>
          <target state="translated">줄 바꿈은 출력에서 ​​제거됩니다. 지원되는 방법은 ReaderBase를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="458935459d7140127b19628c83fd2e4689e9e0ca" translate="yes" xml:space="preserve">
          <source>No operations should be added to the graph inside this scope, it should only be used when creating variables (some implementations work by changing variable creation, others work by using a tf.compat.v1.colocate_with() scope).</source>
          <target state="translated">이 범위 내에서 그래프에 연산을 추가해서는 안됩니다. 변수를 만들 때만 사용해야합니다 (일부 구현은 변수 생성을 변경하여 작동하고 다른 구현은 tf.compat.v1.colocate_with () 범위를 사용하여 작동).</target>
        </trans-unit>
        <trans-unit id="e4724ced8c9eb466bc6d5981fbe7b5105a2edce4" translate="yes" xml:space="preserve">
          <source>No validity checking is performed on the indices of &lt;code&gt;A&lt;/code&gt;. However, the following input format is recommended for optimal behavior:</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 인덱스에 대해서는 유효성 검사가 수행되지 않습니다 . 그러나 최적의 동작을 위해서는 다음 입력 형식이 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="11666704a84af89311580ed98c76fe597a2315b5" translate="yes" xml:space="preserve">
          <source>Nodes with task type &lt;code&gt;worker&lt;/code&gt; can have id 0, 1, 2. Nodes with task type &lt;code&gt;ps&lt;/code&gt; can have id, 0, 1. So, &lt;code&gt;task_id&lt;/code&gt; is not unique, but the pair (&lt;code&gt;task_type&lt;/code&gt;, &lt;code&gt;task_id&lt;/code&gt;) can uniquely determine a node in the cluster.</source>
          <target state="translated">작업 유형 &lt;code&gt;worker&lt;/code&gt; 가있는 노드 는 id 0, 1, 2 를 가질 수 있습니다. 작업 유형이 &lt;code&gt;ps&lt;/code&gt; 인 노드 는 id, 0, 1을 가질 수 있습니다. 따라서 &lt;code&gt;task_id&lt;/code&gt; 는 고유하지 않지만 쌍 ( &lt;code&gt;task_type&lt;/code&gt; , &lt;code&gt;task_id&lt;/code&gt; )은 클러스터에서 노드를 고유하게 판별 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="c979e6e5d3f4ead496e670d40a836151f1ab6c4f" translate="yes" xml:space="preserve">
          <source>Non-negative means, for every element &lt;code&gt;x[i]&lt;/code&gt; of &lt;code&gt;x&lt;/code&gt;, we have &lt;code&gt;x[i] &amp;gt;= 0&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is empty this is trivially satisfied.</source>
          <target state="translated">음이 아닌 수단은, 각 요소에 대해 &lt;code&gt;x[i]&lt;/code&gt; 중 &lt;code&gt;x&lt;/code&gt; , 우리가 &lt;code&gt;x[i] &amp;gt;= 0&lt;/code&gt; . 경우 &lt;code&gt;x&lt;/code&gt; 가 비어있는이 하찮게 만족된다.</target>
        </trans-unit>
        <trans-unit id="34c8973bf00e274f72e3e9d129db1bfd9504fc85" translate="yes" xml:space="preserve">
          <source>Non-numeric, unordered, and quantized types are not considered unsigned, and this function returns &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">숫자가 아닌, 순서가 지정되지 않은, 양자화 된 유형은 부호없는 것으로 간주되지 않으며이 함수는 &lt;code&gt;False&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ba8ab04a76afb8ed04a27bf3433d7f51df786e2c" translate="yes" xml:space="preserve">
          <source>Non-overlapping blocks of size &lt;code&gt;block_size x block size&lt;/code&gt; are rearranged into depth at each location.</source>
          <target state="translated">크기가 &lt;code&gt;block_size x block size&lt;/code&gt; 인 겹치지 않는 블록은 각 위치에서 깊이로 재 배열됩니다.</target>
        </trans-unit>
        <trans-unit id="9b52814376942be4a2e4ffe80f42e42f8bbec394" translate="yes" xml:space="preserve">
          <source>Non-overlapping blocks of size &lt;code&gt;block_size x block size&lt;/code&gt; in the height and width dimensions are rearranged into the batch dimension at each location.</source>
          <target state="translated">높이와 너비 치수가 &lt;code&gt;block_size x block size&lt;/code&gt; 인 겹치지 않는 블록은 각 위치에서 배치 치수로 재 배열됩니다.</target>
        </trans-unit>
        <trans-unit id="64df6f701202b39390bcf5e8b4c436903270eae0" translate="yes" xml:space="preserve">
          <source>Non-positive means, for every element &lt;code&gt;x[i]&lt;/code&gt; of &lt;code&gt;x&lt;/code&gt;, we have &lt;code&gt;x[i] &amp;lt;= 0&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is empty this is trivially satisfied.</source>
          <target state="translated">비 양성 수단은, 각 요소에 대해 &lt;code&gt;x[i]&lt;/code&gt; 중 &lt;code&gt;x&lt;/code&gt; , 우리가 &lt;code&gt;x[i] &amp;lt;= 0&lt;/code&gt; . 경우 &lt;code&gt;x&lt;/code&gt; 가 비어있는이 하찮게 만족된다.</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="14bbac7c58836e5b5a602a379b51110d6ae97db4" translate="yes" xml:space="preserve">
          <source>None of &lt;code&gt;Estimator&lt;/code&gt;'s methods can be overridden in subclasses (its constructor enforces this). Subclasses should use &lt;code&gt;model_fn&lt;/code&gt; to configure the base class, and may add methods implementing specialized functionality.</source>
          <target state="translated">&lt;code&gt;Estimator&lt;/code&gt; 의 메소드 중 어느 것도 서브 클래스에서 재정의 될 수 없습니다 (생성자가이를 강제 함). 서브 클래스는 &lt;code&gt;model_fn&lt;/code&gt; 을 사용하여 기본 클래스를 구성 해야하며 특수 기능을 구현하는 메소드를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adfb7662711b80f1013dedb7a61b85ad11154879" translate="yes" xml:space="preserve">
          <source>None or a &lt;code&gt;SessionRunArgs&lt;/code&gt; object.</source>
          <target state="translated">없음 또는 &lt;code&gt;SessionRunArgs&lt;/code&gt; 개체</target>
        </trans-unit>
        <trans-unit id="d8d92ebc4f96cf6d286ec1a11a06ca796351ea64" translate="yes" xml:space="preserve">
          <source>None or a tensor (or list of tensors, one per output tensor of the layer).</source>
          <target state="translated">없음 또는 텐서 (또는 레이어의 출력 텐 서당 하나의 텐서 목록).</target>
        </trans-unit>
        <trans-unit id="4a0fbd028589f38608b21906f558dd3f64e5ffa6" translate="yes" xml:space="preserve">
          <source>None when executing eagerly. During graph tracing this returns a TF operator that prints the specified inputs in the specified output stream or logging level. This operator will be automatically executed except inside of &lt;a href=&quot;compat/v1&quot;&gt;&lt;code&gt;tf.compat.v1&lt;/code&gt;&lt;/a&gt; graphs and sessions.</source>
          <target state="translated">열심히 실행할 때는 없음. 그래프 추적 중에 지정된 출력 스트림 또는 로깅 레벨에서 지정된 입력을 인쇄하는 TF 연산자를 리턴합니다. 이 연산자는 &lt;a href=&quot;compat/v1&quot;&gt; &lt;code&gt;tf.compat.v1&lt;/code&gt; &lt;/a&gt; 그래프 및 세션을 제외하고 자동으로 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="9a9707be07da6862114abd49d2570046d4810ca5" translate="yes" xml:space="preserve">
          <source>None.</source>
          <target state="translated">None.</target>
        </trans-unit>
        <trans-unit id="72a4bf1028692e704541b00acacece0a73ff9a0d" translate="yes" xml:space="preserve">
          <source>None: Switch to a system default.</source>
          <target state="translated">없음 : 시스템 기본값으로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="13c325d58f707f1ad1e369aa42ee653eda1ae052" translate="yes" xml:space="preserve">
          <source>None: sets the system default.</source>
          <target state="translated">없음 : 시스템 기본값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7547e1f1bfa737c51026448bbe37403315a54990" translate="yes" xml:space="preserve">
          <source>Normalization equations: Consider the intermediate activations (x) of a mini-batch of size (m):</source>
          <target state="translated">정규화 방정식 : 크기 (m)의 미니 배치의 중간 활성화 (x)를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="064324fb9ad9a7e601e5b04ac9bc9980e4416ae4" translate="yes" xml:space="preserve">
          <source>Normalize and scale inputs or activations. (Ioffe and Szegedy, 2014).</source>
          <target state="translated">입력 또는 활성화를 정규화하고 스케일링합니다. (Ioffe and Szegedy, 2014).</target>
        </trans-unit>
        <trans-unit id="3ddfbadcf1463f788dedd93859f2f59e781e0f26" translate="yes" xml:space="preserve">
          <source>Normalize the activations of the previous layer at each batch, i.e. applies a transformation that maintains the mean activation close to 0 and the activation standard deviation close to 1.</source>
          <target state="translated">각 배치에서 이전 레이어의 활성화를 정규화합니다. 즉 평균 활성화를 0에 가깝게 유지하고 활성화 표준 편차를 1에 가깝게 유지하는 변환을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="916f594677c93ac279cb0019816ce04eba385fec" translate="yes" xml:space="preserve">
          <source>Normalize the activations of the previous layer for each given example in a batch independently, rather than across a batch like Batch Normalization. i.e. applies a transformation that maintains the mean activation within each example close to 0 and the activation standard deviation close to 1.</source>
          <target state="translated">배치 정규화와 같은 배치를 통하지 않고 개별적으로 각 예에 대해 이전 레이어의 활성화를 배치로 정규화합니다. 즉, 각 예에서 평균 활성화를 0에 가깝고 활성화 표준 편차를 1에 가깝게 유지하는 변환을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="e58a6e978455eb49c7db072e10761ebfdcbc42d6" translate="yes" xml:space="preserve">
          <source>Normalized, scaled, offset tensor.</source>
          <target state="translated">정규화 된 스케일링 된 오프셋 텐서.</target>
        </trans-unit>
        <trans-unit id="5c4f815e6c91d4e73f820c37ba7f1bcee095c74a" translate="yes" xml:space="preserve">
          <source>Normalizes &lt;code&gt;tensor&lt;/code&gt; along dimension &lt;code&gt;axis&lt;/code&gt; using specified norm.</source>
          <target state="translated">지정된 규범을 사용하여 치수 &lt;code&gt;axis&lt;/code&gt; 따라 &lt;code&gt;tensor&lt;/code&gt; 를 정규화 합니다.</target>
        </trans-unit>
        <trans-unit id="aff38eeab4b14f7649f14f65c0b7825af7df202d" translate="yes" xml:space="preserve">
          <source>Normalizes a Numpy array.</source>
          <target state="translated">Numpy 배열을 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="c7b4d2f24bb4bf14315a15330bc468f30500a09f" translate="yes" xml:space="preserve">
          <source>Normalizes a tensor by &lt;code&gt;mean&lt;/code&gt; and &lt;code&gt;variance&lt;/code&gt;, and applies (optionally) a &lt;code&gt;scale&lt;/code&gt; \(\gamma\) to it, as well as an &lt;code&gt;offset&lt;/code&gt; \(\beta\):</source>
          <target state="translated">&lt;code&gt;mean&lt;/code&gt; 과 &lt;code&gt;variance&lt;/code&gt; 으로 텐서를 정규화하고 &lt;code&gt;offset&lt;/code&gt; \ (\ beta \) 뿐만 아니라 &lt;code&gt;scale&lt;/code&gt; \ (\ gamma \)를 적용합니다 (선택 사항 ).</target>
        </trans-unit>
        <trans-unit id="2308ef7fe7e52a90b654582b28aba02dc69d0986" translate="yes" xml:space="preserve">
          <source>Normalizes a tensor wrt the L2 norm alongside the specified axis.</source>
          <target state="translated">지정된 축과 함께 L2 규범을 사용하여 텐서를 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="c5bb725c2a1943788fbf0021b845c6ac5dd5243c" translate="yes" xml:space="preserve">
          <source>Normalizes along dimension &lt;code&gt;axis&lt;/code&gt; using an L2 norm.</source>
          <target state="translated">L2 규범을 사용하여 치수 &lt;code&gt;axis&lt;/code&gt; 따라 정규화합니다 .</target>
        </trans-unit>
        <trans-unit id="97edba55c7e8ea1e2ab91117f1f0bae959c27151" translate="yes" xml:space="preserve">
          <source>Normalizes along dimension &lt;code&gt;axis&lt;/code&gt; using an L2 norm. (deprecated arguments)</source>
          <target state="translated">L2 규범을 사용하여 치수 &lt;code&gt;axis&lt;/code&gt; 따라 정규화합니다 . (더 이상 사용되지 않는 인수)</target>
        </trans-unit>
        <trans-unit id="17303e7ba9d3afb7e4db135e192b17f1cf35f45d" translate="yes" xml:space="preserve">
          <source>Normally used together with 'scope' view.</source>
          <target state="translated">일반적으로 '스코프'보기와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e1dfda3ff8dc12277e03539152639a01ac561478" translate="yes" xml:space="preserve">
          <source>Normally, the module that calls the DEFINE_xxx functions claims the flag to be its key flag. This is undesirable for modules that define additional DEFINE_yyy functions with its own flag parsers and serializers, since that module will accidentally claim flags defined by DEFINE_yyy as its key flags. After calling this function, the module disclaims flag definitions thereafter, so the key flags will be correctly attributed to the caller of DEFINE_yyy.</source>
          <target state="translated">일반적으로 DEFINE_xxx 함수를 호출하는 모듈은 플래그를 키 플래그라고 주장합니다. 자체 플래그 파서 및 시리얼 라이저로 추가 DEFINE_yyy 함수를 정의하는 모듈에는 바람직하지 않습니다. 그 모듈은 실수로 DEFINE_yyy에 의해 정의 된 플래그를 키 플래그로 요구하기 때문입니다. 이 함수를 호출 한 후, 모듈은 이후에 플래그 정의를 거부하므로 키 플래그는 DEFINE_yyy의 호출자에게 올바르게 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="d56a188097b32e96166fb55a8afc1f964b4839b3" translate="yes" xml:space="preserve">
          <source>Not all Readers support being restored, so this can produce an Unimplemented error.</source>
          <target state="translated">모든 독자가 복원을 지원하는 것은 아니므로 구현되지 않은 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a82abb5f2cf27a5f3715b34b452bf30a6056cc5" translate="yes" xml:space="preserve">
          <source>Not all Readers support being serialized, so this can produce an Unimplemented error.</source>
          <target state="translated">모든 독자가 직렬화를 지원하지는 않으므로 구현되지 않은 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6363875392bd4c1ceda918196093dc232be1cab2" translate="yes" xml:space="preserve">
          <source>Not compatible with eager execution. To check for &lt;code&gt;Inf&lt;/code&gt;s and &lt;code&gt;NaN&lt;/code&gt;s under eager execution, call &lt;a href=&quot;../../debugging/enable_check_numerics&quot;&gt;&lt;code&gt;tf.debugging.enable_check_numerics()&lt;/code&gt;&lt;/a&gt; once before executing the checked operations.</source>
          <target state="translated">열망하는 실행과 호환되지 않습니다. &lt;a href=&quot;../../debugging/enable_check_numerics&quot;&gt; &lt;code&gt;tf.debugging.enable_check_numerics()&lt;/code&gt; &lt;/a&gt; 실행 상태에서 &lt;code&gt;Inf&lt;/code&gt; 및 &lt;code&gt;NaN&lt;/code&gt; 을 확인하려면 확인 된 작업을 실행하기 전에 tf.debugging.enable_check_numerics ()를 한 번 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9237eedc5589ecc6b8ee36e7cfb8a8fee3226e44" translate="yes" xml:space="preserve">
          <source>Not compatible with eager execution. To ingest data under eager execution, use the &lt;a href=&quot;../../../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; API instead.</source>
          <target state="translated">열망하는 실행과 호환되지 않습니다. 간절히 실행중인 데이터를 수집하려면 &lt;a href=&quot;../../../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt; API를 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ada071819daf1f780987786f85add4894c2abdf" translate="yes" xml:space="preserve">
          <source>Not compatible with eager execution. To write TensorBoard summaries under eager execution, use &lt;code&gt;tf.contrib.summary&lt;/code&gt; instead.</source>
          <target state="translated">열망하는 실행과 호환되지 않습니다. 간절히 실행중인 TensorBoard 요약을 작성하려면 대신 &lt;code&gt;tf.contrib.summary&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f5e998614be9275ecb64d014a6265aaaf223bc24" translate="yes" xml:space="preserve">
          <source>Not threadsafe.</source>
          <target state="translated">스레드 세이프가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="db7e90c0287dc26e08c3f25c9eb2d2b14f070fd1" translate="yes" xml:space="preserve">
          <source>Not well supported when graph building. From TensorFlow 1.x, &lt;a href=&quot;../compat/v1/enable_eager_execution&quot;&gt;&lt;code&gt;tf.compat.v1.enable_eager_execution()&lt;/code&gt;&lt;/a&gt; should run first. Calling tf.saved_model.save in a loop when graph building from TensorFlow 1.x will add new save operations to the default graph each iteration.</source>
          <target state="translated">그래프 작성시 잘 지원되지 않습니다. TensorFlow 1.x부터 &lt;a href=&quot;../compat/v1/enable_eager_execution&quot;&gt; &lt;code&gt;tf.compat.v1.enable_eager_execution()&lt;/code&gt; &lt;/a&gt; 이 먼저 실행되어야합니다. TensorFlow 1.x에서 그래프를 작성할 때 루프에서 tf.saved_model.save를 호출하면 매번 반복 할 때마다 기본 그래프에 새로운 저장 작업이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="cb184c4bb0651f62ca35c7a5b94ae490d249ae1d" translate="yes" xml:space="preserve">
          <source>Note here we derive &amp;amp; use a closed formula not present in the paper as follows:</source>
          <target state="translated">여기서 우리는 다음과 같이 종이에 존재하지 않는 닫힌 공식을 유도하고 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b2a909050364856639562bf47332b2d0870db232" translate="yes" xml:space="preserve">
          <source>Note in the case that &lt;code&gt;dilation_rate&lt;/code&gt; is not uniformly 1, specifying &quot;VALID&quot; padding is equivalent to specifying &lt;code&gt;padding = &quot;SAME&quot;&lt;/code&gt; with a filter_shape of &lt;code&gt;[1]*N&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dilation_rate&lt;/code&gt; 가 1이 아닌 경우 &quot;VALID&quot;패딩을 지정 하는 것은 &lt;code&gt;[1]*N&lt;/code&gt; 의 filter_shape 를 사용하여 &lt;code&gt;padding = &quot;SAME&quot;&lt;/code&gt; 를 지정하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="bbe33858c120c8bcc624c14b698f8958aefff666" translate="yes" xml:space="preserve">
          <source>Note internally this op reshapes and uses the underlying 2d operation.</source>
          <target state="translated">내부적으로이 작업이 재구성되고 기본 2D 작업을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4a26bc83d674c780bc68baa219aef1ce71e32c5a" translate="yes" xml:space="preserve">
          <source>Note on duality: The dilation of &lt;code&gt;input&lt;/code&gt; by the &lt;code&gt;filter&lt;/code&gt; is equal to the negation of the erosion of &lt;code&gt;-input&lt;/code&gt; by the reflected &lt;code&gt;filter&lt;/code&gt;.</source>
          <target state="translated">이중성에 참고의 팽창 &lt;code&gt;input&lt;/code&gt; 바이 &lt;code&gt;filter&lt;/code&gt; 의 침식 부정 같다 &lt;code&gt;-input&lt;/code&gt; 반사하여 &lt;code&gt;filter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="538256a5d774819d8174f664f11592327abdf052" translate="yes" xml:space="preserve">
          <source>Note on duality: The dilation of &lt;code&gt;input&lt;/code&gt; by the &lt;code&gt;filters&lt;/code&gt; is equal to the negation of the erosion of &lt;code&gt;-input&lt;/code&gt; by the reflected &lt;code&gt;filters&lt;/code&gt;.</source>
          <target state="translated">이중성에 참고 : 팽창의 &lt;code&gt;input&lt;/code&gt; 바이 &lt;code&gt;filters&lt;/code&gt; 의 침식 부정 같다 &lt;code&gt;-input&lt;/code&gt; 반사하여 &lt;code&gt;filters&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="509981eb2711e602b52010090ca68b6f7a3a9779" translate="yes" xml:space="preserve">
          <source>Note on passing external constants to RNNs: You can pass &quot;external&quot; constants to the cell using the &lt;code&gt;constants&lt;/code&gt; keyword argument of &lt;a href=&quot;rnn#__call__&quot;&gt;&lt;code&gt;RNN.&lt;strong&gt;call&lt;/strong&gt;&lt;/code&gt;&lt;/a&gt; (as well as &lt;a href=&quot;rnn#call&quot;&gt;&lt;code&gt;RNN.call&lt;/code&gt;&lt;/a&gt;) method. This requires that the &lt;code&gt;cell.call&lt;/code&gt; method accepts the same keyword argument &lt;code&gt;constants&lt;/code&gt;. Such constants can be used to condition the cell transformation on additional static inputs (not changing over time), a.k.a. an attention mechanism.</source>
          <target state="translated">RNN에 외부 상수 전달에 대한 참고 사항 : &lt;a href=&quot;rnn#__call__&quot;&gt; &lt;code&gt;RNN.&lt;strong&gt;call&lt;/strong&gt;&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;constants&lt;/code&gt; 키워드 인수를 사용하여 &quot;외부&quot;상수를 셀에 전달할 수 있습니다 . &lt;strong&gt;&lt;/strong&gt;&lt;a href=&quot;rnn#call&quot;&gt; &lt;code&gt;RNN.call&lt;/code&gt; &lt;/a&gt; 뿐만 아니라 &lt;strong&gt;call&lt;/strong&gt; 메소드. 이를 위해서는 &lt;code&gt;cell.call&lt;/code&gt; 메소드가 동일한 키워드 인수 &lt;code&gt;constants&lt;/code&gt; 허용 해야합니다 . 이러한 상수는주의 메커니즘으로 알려진 추가 정적 입력 (시간이 지나도 변하지 않음)에서 셀 변환을 조절하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="270d0bda224ad5af83ed8d483360479d2bba6ff4" translate="yes" xml:space="preserve">
          <source>Note on specifying the initial state of RNNs: You can specify the initial state of RNN layers symbolically by calling them with the keyword argument &lt;code&gt;initial_state&lt;/code&gt;. The value of &lt;code&gt;initial_state&lt;/code&gt; should be a tensor or list of tensors representing the initial state of the RNN layer.</source>
          <target state="translated">RNN의 초기 상태 지정에 대한 참고 사항 : 키워드 인수 &lt;code&gt;initial_state&lt;/code&gt; 로 호출하여 RNN 레이어의 초기 상태를 기호로 지정할 수 있습니다 . &lt;code&gt;initial_state&lt;/code&gt; 의 값은 RNN 계층의 초기 상태를 나타내는 텐서 또는 텐서 목록이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a20c526cc3c0884bce765b065839388631d91867" translate="yes" xml:space="preserve">
          <source>Note on supported columns: &lt;code&gt;linear_model&lt;/code&gt; treats categorical columns as &lt;code&gt;indicator_column&lt;/code&gt;s. To be specific, assume the input as &lt;code&gt;SparseTensor&lt;/code&gt; looks like:</source>
          <target state="translated">지원되는 열에 대한 참고 사항 : &lt;code&gt;linear_model&lt;/code&gt; 은 범주 열을 &lt;code&gt;indicator_column&lt;/code&gt; 으로 취급합니다 . 구체적으로, &lt;code&gt;SparseTensor&lt;/code&gt; 와 같은 입력을 다음과 같이 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="49ff5aa79e4a7608bb5495ed706a66a929042770" translate="yes" xml:space="preserve">
          <source>Note on using statefulness in RNNs: You can set RNN layers to be 'stateful', which means that the states computed for the samples in one batch will be reused as initial states for the samples in the next batch. This assumes a one-to-one mapping between samples in different successive batches.</source>
          <target state="translated">RNN에서 상태 저장 사용에 대한 참고 사항 : RNN 레이어를 '상태 저장'으로 설정할 수 있습니다. 즉, 한 배치에서 샘플에 대해 계산 된 상태는 다음 배치에서 샘플의 초기 상태로 재사용됩니다. 이는 서로 다른 연속 배치에서 샘플 간 일대일 매핑을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="72777dbfe4f2e5939c7704c40aca1c5dccec5d23" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;matmul&quot;&gt;&lt;code&gt;tf.matmul&lt;/code&gt;&lt;/a&gt; provides kwargs allowing for transpose of arguments. This is done with minimal cost, and is preferable to using this function. E.g.</source>
          <target state="translated">참고 &lt;a href=&quot;matmul&quot;&gt; &lt;code&gt;tf.matmul&lt;/code&gt; &lt;/a&gt; 은 인수를 전치 할 수 kwarg를 제공합니다. 이 작업은 최소한의 비용으로 수행되며이 기능을 사용하는 것이 좋습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="e568fc17bc710ccc123c49d3ba60116212a21197" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;tensor#__getitem__&quot;&gt;&lt;code&gt;tf.Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt;&lt;/a&gt; is typically a more pythonic way to perform slices, as it allows you to write &lt;code&gt;foo[3:7, :-2]&lt;/code&gt; instead of &lt;code&gt;tf.slice(foo, [3, 0], [4, foo.get_shape()[1]-2])&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;tensor#__getitem__&quot;&gt; &lt;code&gt;tf.Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt; &lt;/a&gt; 은 일반적으로 슬라이스를 수행하는 더 파이썬적인 방법으로, 대신 &lt;code&gt;foo[3:7, :-2]&lt;/code&gt; 를 쓸 수 있기 때문에 &lt;code&gt;tf.slice(foo, [3, 0], [4, foo.get_shape()[1]-2])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40ac51b571e44961669851b81a2bc8f6fff71e6a" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;A&lt;/code&gt; itself will not in general be circulant.</source>
          <target state="translated">참고 &lt;code&gt;A&lt;/code&gt; 자체가 일반적으로 순환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ec112c82a2c107126719b79f0120392dea4eeaa" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ForwardAccumulator&lt;/code&gt;s are always applied in the order their context managers were entered, so inner accumulators will not see JVP computation from outer accumulators. Take higher-order JVPs from outer accumulators:</source>
          <target state="translated">참고 &lt;code&gt;ForwardAccumulator&lt;/code&gt; 의 s는 항상 콘텍스트 관리자가 입력 한 순서로 적용되므로, 내부 축전지 외부로부터 축전지 JVP 계산을 볼 것이다. 외부 축 압기에서 고차 JVP를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a46da24c95f918ff32cd2978453114c08f12e928" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;alt&lt;/code&gt; should have the &lt;em&gt;same shape&lt;/em&gt; as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">주의 &lt;code&gt;alt&lt;/code&gt; 해야 &lt;em&gt;동일한 형태&lt;/em&gt; 로 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a58a5fccc21621a4cf80221dd59a80ac92faf70" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;apply()&lt;/code&gt; can be called multiple times. When eager execution is enabled each call to apply will update the variables once, so this needs to be called in a loop.</source>
          <target state="translated">주 &lt;code&gt;apply()&lt;/code&gt; 여러 번 호출 할 수 있습니다. 열성적인 실행이 활성화되면 적용 할 각 호출이 변수를 한 번 업데이트하므로 루프에서 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="50f6f8f321ec3b4a9cf9fab3a94eff9e934546e1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;cond&lt;/code&gt; calls &lt;code&gt;true_fn&lt;/code&gt; and &lt;code&gt;false_fn&lt;/code&gt;&lt;em&gt;exactly once&lt;/em&gt; (inside the call to &lt;code&gt;cond&lt;/code&gt;, and not at all during &lt;code&gt;Session.run()&lt;/code&gt;). &lt;code&gt;cond&lt;/code&gt; stitches together the graph fragments created during the &lt;code&gt;true_fn&lt;/code&gt; and &lt;code&gt;false_fn&lt;/code&gt; calls with some additional graph nodes to ensure that the right branch gets executed depending on the value of &lt;code&gt;pred&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;cond&lt;/code&gt; 통화 &lt;code&gt;true_fn&lt;/code&gt; 및 &lt;code&gt;false_fn&lt;/code&gt; &lt;em&gt;정확히 한 번만&lt;/em&gt; (호출 내부 &lt;code&gt;cond&lt;/code&gt; , 그리고 전혀 동안 &lt;code&gt;Session.run()&lt;/code&gt; ). &lt;code&gt;cond&lt;/code&gt; 는 &lt;code&gt;true_fn&lt;/code&gt; 및 &lt;code&gt;false_fn&lt;/code&gt; 호출 중에 생성 된 그래프 조각 을 일부 추가 그래프 노드와 함께 연결하여 다음의 값에 따라 올바른 분기가 실행되도록합니다. &lt;code&gt;pred&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c35116aab4ffda3f5b8febb9a2fbfcf9f98ca4b2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;onehot_labels&lt;/code&gt; and &lt;code&gt;logits&lt;/code&gt; must have the same shape, e.g. &lt;code&gt;[batch_size, num_classes]&lt;/code&gt;. The shape of &lt;code&gt;weights&lt;/code&gt; must be broadcastable to loss, whose shape is decided by the shape of &lt;code&gt;logits&lt;/code&gt;. In case the shape of &lt;code&gt;logits&lt;/code&gt; is &lt;code&gt;[batch_size, num_classes]&lt;/code&gt;, loss is a &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[batch_size]&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;onehot_labels&lt;/code&gt; 및 &lt;code&gt;logits&lt;/code&gt; 가 동일한 형상, 예 있어야 &lt;code&gt;[batch_size, num_classes]&lt;/code&gt; . 의 모양 &lt;code&gt;weights&lt;/code&gt; 그 모양의 모양에 의해 결정됩니다 손실에 캐스트 가능한해야합니다 &lt;code&gt;logits&lt;/code&gt; . &lt;code&gt;logits&lt;/code&gt; 의 모양 이 &lt;code&gt;[batch_size, num_classes]&lt;/code&gt; 경우 손실은 모양 의 &lt;code&gt;Tensor&lt;/code&gt; &lt;code&gt;[batch_size]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f1b99c871f303c6654c92ba2a6577333ec5e3056" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;output&lt;/code&gt; preserves the mask dimensions &lt;code&gt;a1...aA&lt;/code&gt;; this differs from &lt;a href=&quot;../boolean_mask&quot;&gt;&lt;code&gt;tf.boolean_mask&lt;/code&gt;&lt;/a&gt;, which flattens those dimensions.</source>
          <target state="translated">참고 &lt;code&gt;output&lt;/code&gt; 마스크 치수 유지 &lt;code&gt;a1...aA&lt;/code&gt; ; 이것은 &lt;a href=&quot;../boolean_mask&quot;&gt; &lt;code&gt;tf.boolean_mask&lt;/code&gt; &lt;/a&gt; 와 다릅니다. .</target>
        </trans-unit>
        <trans-unit id="b7f020afa36ab3da134530fec37d9ded2a125980" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;print_tensor&lt;/code&gt; returns a new tensor identical to &lt;code&gt;x&lt;/code&gt; which should be used in the following code. Otherwise the print operation is not taken into account during evaluation.</source>
          <target state="translated">참고 것을 &lt;code&gt;print_tensor&lt;/code&gt; 는 동일한 새로운 텐서 반환 &lt;code&gt;x&lt;/code&gt; 다음 코드를 사용해야합니다. 그렇지 않으면 평가 중에 인쇄 작업이 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5354d47dcf912a72d45acaff759032e08a161cbe" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;rt1&lt;/code&gt; only contains one ragged dimension (the innermost dimension). In contrast, if &lt;code&gt;from_row_splits&lt;/code&gt; is used to construct a similar &lt;code&gt;RaggedTensor&lt;/code&gt;, then that &lt;code&gt;RaggedTensor&lt;/code&gt; will have two ragged dimensions:</source>
          <target state="translated">참고 것을 &lt;code&gt;rt1&lt;/code&gt; 하나 개의 비정형 크기 (가장 안쪽 치수)가 포함되어 있습니다. 만약 반대로 &lt;code&gt;from_row_splits&lt;/code&gt; 는 유사한 구성하는데 사용된다 &lt;code&gt;RaggedTensor&lt;/code&gt; 를 , 그 &lt;code&gt;RaggedTensor&lt;/code&gt; 는 두 비정형 치수를 가질 것이다 :</target>
        </trans-unit>
        <trans-unit id="e5610ad5b9af5428acd48a2b3a48d463377d1dda" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;rt6&lt;/code&gt; only contains one ragged dimension (the innermost dimension). In contrast, if &lt;code&gt;from_row_splits&lt;/code&gt; is used to construct a similar &lt;code&gt;RaggedTensor&lt;/code&gt;, then that &lt;code&gt;RaggedTensor&lt;/code&gt; will have two ragged dimensions:</source>
          <target state="translated">참고 것을 &lt;code&gt;rt6&lt;/code&gt; 하나 개의 비정형 크기 (가장 안쪽 치수)가 포함되어 있습니다. 반대로 &lt;code&gt;from_row_splits&lt;/code&gt; 를 사용하여 유사한 &lt;code&gt;RaggedTensor&lt;/code&gt; 를 구성하는 경우 해당 &lt;code&gt;RaggedTensor&lt;/code&gt; 두 비정형 치수를 가질 것이다 :</target>
        </trans-unit>
        <trans-unit id="3dda3d3a3e15aed235eeed849a924d5cb03f30cb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;while_loop&lt;/code&gt; calls &lt;code&gt;cond&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt;&lt;em&gt;exactly once&lt;/em&gt; (inside the call to &lt;code&gt;while_loop&lt;/code&gt;, and not at all during &lt;code&gt;Session.run()&lt;/code&gt;). &lt;code&gt;while_loop&lt;/code&gt; stitches together the graph fragments created during the &lt;code&gt;cond&lt;/code&gt; and &lt;code&gt;body&lt;/code&gt; calls with some additional graph nodes to create the graph flow that repeats &lt;code&gt;body&lt;/code&gt; until &lt;code&gt;cond&lt;/code&gt; returns false.</source>
          <target state="translated">참고 것을 &lt;code&gt;while_loop&lt;/code&gt; 호출 &lt;code&gt;cond&lt;/code&gt; 과 &lt;code&gt;body&lt;/code&gt; &lt;em&gt;정확히 한 번만&lt;/em&gt; (호출하는 내부 &lt;code&gt;while_loop&lt;/code&gt; , 그리고 동안 전혀 &lt;code&gt;Session.run()&lt;/code&gt; ). &lt;code&gt;while_loop&lt;/code&gt; 는 &lt;code&gt;cond&lt;/code&gt; 및 &lt;code&gt;body&lt;/code&gt; 호출 중에 생성 된 그래프 조각 을 일부 추가 그래프 노드와 함께 연결하여 &lt;code&gt;cond&lt;/code&gt; 가 false를 반환 할 때까지 &lt;code&gt;body&lt;/code&gt; 를 반복하는 그래프 흐름을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="8d7fa6d4c7f23e3bd24a1c5fb86f12cf2aecce4b" translate="yes" xml:space="preserve">
          <source>Note that a RNN cell has: - a &lt;code&gt;call&lt;/code&gt; method. - a &lt;code&gt;state_size&lt;/code&gt; attribute. - a &lt;code&gt;output_size&lt;/code&gt; attribute. - a &lt;code&gt;get_initial_state&lt;/code&gt; method. See the documentation on &lt;a href=&quot;../../keras/layers/rnn&quot;&gt;&lt;code&gt;tf.keras.layers.RNN&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">RNN 셀에는 다음이 있습니다.- &lt;code&gt;call&lt;/code&gt; 방법. - &lt;code&gt;state_size&lt;/code&gt; 의 속성. - &lt;code&gt;output_size&lt;/code&gt; 의 속성. - &lt;code&gt;get_initial_state&lt;/code&gt; 방법. 자세한 내용은 &lt;a href=&quot;../../keras/layers/rnn&quot;&gt; &lt;code&gt;tf.keras.layers.RNN&lt;/code&gt; &lt;/a&gt; 의 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2598e6e6e3ed83c4641fe5b7584bdf58631bc1af" translate="yes" xml:space="preserve">
          <source>Note that a RNN cell is has: - a &lt;code&gt;call&lt;/code&gt; method. - a &lt;code&gt;state_size&lt;/code&gt; attribute. - a &lt;code&gt;output_size&lt;/code&gt; attribute. - a &lt;code&gt;get_initial_state&lt;/code&gt; method. See the documentation on &lt;a href=&quot;../../keras/layers/rnn&quot;&gt;&lt;code&gt;tf.keras.layers.RNN&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">RNN 셀은 다음과 같습니다.- &lt;code&gt;call&lt;/code&gt; 방법. - &lt;code&gt;state_size&lt;/code&gt; 의 속성. - &lt;code&gt;output_size&lt;/code&gt; 의 속성. - &lt;code&gt;get_initial_state&lt;/code&gt; 방법. 자세한 내용은 &lt;a href=&quot;../../keras/layers/rnn&quot;&gt; &lt;code&gt;tf.keras.layers.RNN&lt;/code&gt; &lt;/a&gt; 의 설명서 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3346ac203c551f5dee084a97a7117570693fae84" translate="yes" xml:space="preserve">
          <source>Note that a call to &lt;code&gt;sample()&lt;/code&gt; without arguments will generate a single sample.</source>
          <target state="translated">를 호출합니다 &lt;code&gt;sample()&lt;/code&gt; 인수없이이 하나의 샘플을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="364c0af0bec38c1bc33126a30320d7920e1cae9f" translate="yes" xml:space="preserve">
          <source>Note that a regular session installs itself as the default session when it is created in a &lt;code&gt;with&lt;/code&gt; statement. The common usage in non-interactive programs is to follow that pattern:</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 로 생성 될 때 일반 세션이 기본 세션으로 설치됩니다. 문 . 비 대화식 프로그램에서 일반적으로 사용되는 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7cf4d553e1b47318848fe5f52ae9a8683fb2afa1" translate="yes" xml:space="preserve">
          <source>Note that assignments currently do not support NumPy broadcasting semantics.</source>
          <target state="translated">할당은 현재 NumPy 브로드 캐스트 시맨틱을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f05ab6494191c495422b3d779843d05126cda1c" translate="yes" xml:space="preserve">
          <source>Note that at this time, subclassed models can only be saved using &lt;code&gt;serving_only=True&lt;/code&gt;.</source>
          <target state="translated">현재 서브 클래스 모델은 &lt;code&gt;serving_only=True&lt;/code&gt; 를 사용 해서 만 저장할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e77cb553dc0560db17d2e186e3bd42eaa1bf7dd3" translate="yes" xml:space="preserve">
          <source>Note that both &lt;code&gt;then_expression&lt;/code&gt; and &lt;code&gt;else_expression&lt;/code&gt; should be symbolic tensors of the &lt;em&gt;same shape&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;then_expression&lt;/code&gt; 과 &lt;code&gt;else_expression&lt;/code&gt; 은 모두 &lt;em&gt;같은 모양&lt;/em&gt; 의 기호 텐서 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="332486ee0645460b69c61fd87acb5e3c20435fe4" translate="yes" xml:space="preserve">
          <source>Note that by convention, all sparse ops preserve the canonical ordering along increasing dimension number. The only time ordering can be violated is during manual manipulation of the indices and values to add entries.</source>
          <target state="translated">관례에 따라 모든 희소 작업은 차원 번호가 증가함에 따라 정식 순서를 유지합니다. 순서를 위반할 수있는 유일한 시간은 항목을 추가하기 위해 인덱스와 값을 수동으로 조작하는 동안입니다.</target>
        </trans-unit>
        <trans-unit id="cdaefb21a24bd1dd8a5c3e809a7ec46b615166b8" translate="yes" xml:space="preserve">
          <source>Note that checkpoints saved due to &lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt; will not show up in this list (to avoid ever-growing filename lists).</source>
          <target state="translated">&lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt; 로 인해 검사 점이 저장되었습니다. 는 계속 증가하는 파일 이름 목록을 피하기 위해이 목록에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ea2bdfbd0a043277143ad28f235408aa46b132f" translate="yes" xml:space="preserve">
          <source>Note that collections are not sets, so it is possible to add a value to a collection several times.</source>
          <target state="translated">컬렉션은 설정되지 않으므로 컬렉션에 값을 여러 번 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba0fffcab7a08b358786725ddffcd0bb7d98dc79" translate="yes" xml:space="preserve">
          <source>Note that collections are not sets, so it is possible to add a value to a collection several times. This function makes sure that duplicates in &lt;code&gt;names&lt;/code&gt; are ignored, but it will not check for pre-existing membership of &lt;code&gt;value&lt;/code&gt; in any of the collections in &lt;code&gt;names&lt;/code&gt;.</source>
          <target state="translated">컬렉션은 설정되지 않으므로 컬렉션에 값을 여러 번 추가 할 수 있습니다. 이 함수는 &lt;code&gt;names&lt;/code&gt; 중복 이 무시되도록하지만 &lt;code&gt;names&lt;/code&gt; 의 컬렉션에서 기존 멤버쉽 &lt;code&gt;value&lt;/code&gt; 을 확인하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="801ba4cea6838bbd2e02399dea989d5f6a9fbb1e" translate="yes" xml:space="preserve">
          <source>Note that compared to &lt;a href=&quot;gradienttape#jacobian&quot;&gt;&lt;code&gt;GradientTape.jacobian&lt;/code&gt;&lt;/a&gt; which computes gradient of each output value w.r.t each input value, this function is useful when &lt;code&gt;target[i,...]&lt;/code&gt; is independent of &lt;code&gt;source[j,...]&lt;/code&gt; for &lt;code&gt;j != i&lt;/code&gt;. This assumption allows more efficient computation as compared to &lt;a href=&quot;gradienttape#jacobian&quot;&gt;&lt;code&gt;GradientTape.jacobian&lt;/code&gt;&lt;/a&gt;. The output, as well as intermediate activations, are lower dimensional and avoid a bunch of redundant zeros which would result in the jacobian computation given the independence assumption.</source>
          <target state="translated">각 입력 값으로 각 출력 값의 &lt;a href=&quot;gradienttape#jacobian&quot;&gt; &lt;code&gt;GradientTape.jacobian&lt;/code&gt; &lt;/a&gt; 를 계산 하는 GradientTape.jacobian 과 비교할 때이 함수는 &lt;code&gt;target[i,...]&lt;/code&gt; 이 &lt;code&gt;j != i&lt;/code&gt; 대해 &lt;code&gt;source[j,...]&lt;/code&gt; 와 독립적 일 때 유용합니다 . 이 가정은 &lt;a href=&quot;gradienttape#jacobian&quot;&gt; &lt;code&gt;GradientTape.jacobian&lt;/code&gt; &lt;/a&gt; 과 비교하여 더 효율적인 계산을 허용 합니다. 중간 활성화뿐만 아니라 출력도 차원이 낮고, 중복 가정을 피하여 독립 가정에서 야 코비안 계산을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4b852e27625d73d3d93735f5029a52efe498d4dc" translate="yes" xml:space="preserve">
          <source>Note that contrary to &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;feeds&lt;/code&gt; only specifies the graph elements. The tensors will be supplied by the subsequent &lt;code&gt;partial_run&lt;/code&gt; calls.</source>
          <target state="translated">반대는 할 수 있습니다 &lt;code&gt;run&lt;/code&gt; , &lt;code&gt;feeds&lt;/code&gt; 에만 그래프 요소를 지정합니다. 텐서는 후속 &lt;code&gt;partial_run&lt;/code&gt; 호출에 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="46a36ec8db81e609e755404715f4c85858c0cb57" translate="yes" xml:space="preserve">
          <source>Note that converting from floating point inputs to integer types may lead to over/underflow problems. Set saturate to &lt;code&gt;True&lt;/code&gt; to avoid such problem in problematic conversions. If enabled, saturation will clip the output into the allowed range before performing a potentially dangerous cast (and only before performing such a cast, i.e., when casting from a floating point to an integer type, and when casting from a signed to an unsigned type; &lt;code&gt;saturate&lt;/code&gt; has no effect on casts between floats, or on casts that increase the type's range).</source>
          <target state="translated">부동 소수점 입력에서 정수 유형으로 변환하면 오버 플로우 / 언더 플로우 문제가 발생할 수 있습니다. 문제가있는 변환에서 이러한 문제를 피하려면 포화를 &lt;code&gt;True&lt;/code&gt; 로 설정하십시오 . 활성화 된 경우 포화는 잠재적으로 위험한 캐스트를 수행하기 전에 (그리고 부동 소수점에서 정수 유형으로 캐스팅 할 때와 부호있는 유형에서 서명되지 않은 유형으로 캐스팅 할 때만) 캐스트를 수행하기 전에 출력을 허용 된 범위로 클리핑합니다. ; &lt;code&gt;saturate&lt;/code&gt; 플로트 사이 또는) 유형의 범위를 증가 캐스팅에 캐스트에 영향을 미치지 않는다.</target>
        </trans-unit>
        <trans-unit id="43089211f7d966bba1084d9b1cb2d624e46d32d4" translate="yes" xml:space="preserve">
          <source>Note that decimal places (from zero) are usually not the same as significant digits (measured from the most significant digit).</source>
          <target state="translated">소수점 이하 자릿수 (0부터)는 일반적으로 유효 자릿수 (가장 큰 자릿수에서 측정)와 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="025c1c19d885a0b6ebb4cbc90bf2628ba9802113" translate="yes" xml:space="preserve">
          <source>Note that even if eager execution is enabled, &lt;code&gt;Input&lt;/code&gt; produces a symbolic tensor (i.e. a placeholder). This symbolic tensor can be used with other TensorFlow ops, as such:</source>
          <target state="translated">열망하는 실행이 활성화 된 경우에도 &lt;code&gt;Input&lt;/code&gt; 은 기호 텐서 (즉 자리 표시 자)를 생성합니다. 이 기호 텐서는 다음과 같이 다른 TensorFlow op와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cb5eb3fbbdba794d252abb70bc5cc13d38eb40b" translate="yes" xml:space="preserve">
          <source>Note that even if the compute dtype is float16 or bfloat16, hardware devices may not do individual adds, multiplies, and other fundamental operations in [b]float16, but instead may do some of them in float32 for numeric stability. The compute dtype is the dtype of the inputs and outputs of the TensorFlow ops that the layer executes. Internally, many TensorFlow ops will do certain internal calculations in float32, or some other device-internal intermediate format with higher precision than [b]float16, to increase numeric stability.</source>
          <target state="translated">계산 dtype이 float16 또는 bfloat16이더라도 하드웨어 장치는 [b] float16에서 개별 덧셈, 곱하기 및 기타 기본 연산을 수행하지 않고 대신 숫자 안정성을 위해 float32에서 일부를 수행 할 수 있습니다. 계산 dtype은 레이어가 실행하는 TensorFlow op의 입력 및 출력의 dtype입니다. 내부적으로, 많은 TensorFlow op는 float32 또는 [b] float16보다 높은 정밀도를 가진 다른 장치 내부 중간 형식으로 특정 내부 계산을 수행하여 수치 안정성을 높입니다.</target>
        </trans-unit>
        <trans-unit id="70e19c346145c0fb6ad3ab3ebca758a0424b77a5" translate="yes" xml:space="preserve">
          <source>Note that execution:</source>
          <target state="translated">실행에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="b84e02044a808bbb932bde57bef7368168b23370" translate="yes" xml:space="preserve">
          <source>Note that for UTF-8, passing a replacement character expressible in 1 byte, such as ' ', will preserve string alignment to the source since invalid bytes will be replaced with a 1-byte replacement. For UTF-16-BE and UTF-16-LE, any 1 or 2 byte replacement character will preserve byte alignment to the source.</source>
          <target state="translated">UTF-8의 경우 ''와 같이 1 바이트로 표현 가능한 대체 문자를 전달하면 유효하지 않은 바이트가 1 바이트 대체로 대체되므로 소스에 대한 문자열 정렬이 유지됩니다. UTF-16-BE 및 UTF-16-LE의 경우 1 바이트 또는 2 바이트 대체 문자는 소스에 대한 바이트 정렬을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="158d7059f4ad1c1072885a9be9b7372ddbfa2d14" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;at_end&lt;/code&gt; is True, &lt;code&gt;tensors&lt;/code&gt; should not include any tensor whose evaluation produces a side effect such as consuming additional inputs.</source>
          <target state="translated">경우 참고 것을 &lt;code&gt;at_end&lt;/code&gt; 가 True 인, &lt;code&gt;tensors&lt;/code&gt; 그 평가 등의 추가 입력을 소비하는 등의 부작용을 생산하고있는 텐서를 포함하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="adf6de6b692d567d6bb0e8d441b44e6a714fe300" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;distance_metric=KMeansClustering.SQUARED_EUCLIDEAN_DISTANCE&lt;/code&gt;, this function returns the squared Euclidean distance while the corresponding sklearn function returns the Euclidean distance.</source>
          <target state="translated">경우 유의 &lt;code&gt;distance_metric=KMeansClustering.SQUARED_EUCLIDEAN_DISTANCE&lt;/code&gt; 대응 sklearn 함수는 유클리드 거리를 리턴하면서,이 기능은 제곱 유클리드 거리를 반환한다.</target>
        </trans-unit>
        <trans-unit id="0ae5427b502a43a2066640827fb2560fd6c5ea15" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;tensors&lt;/code&gt; contains a NumPy array, and eager execution is not enabled, the values will be embedded in the graph as one or more &lt;a href=&quot;../../../../constant&quot;&gt;&lt;code&gt;tf.constant&lt;/code&gt;&lt;/a&gt; operations. For large datasets (&amp;gt; 1 GB), this can waste memory and run into byte limits of graph serialization. If &lt;code&gt;tensors&lt;/code&gt; contains one or more large NumPy arrays, consider the alternative described in &lt;a href=&quot;https://tensorflow.org/guide/data#consuming_numpy_arrays&quot;&gt;this guide&lt;/a&gt;.</source>
          <target state="translated">경우 유의 &lt;code&gt;tensors&lt;/code&gt; NumPy와 배열을 포함하고 싶어하는 실행이 가능하지 않고, 값이 하나 이상의 같은 그래프에 매립한다 &lt;a href=&quot;../../../../constant&quot;&gt; &lt;code&gt;tf.constant&lt;/code&gt; &lt;/a&gt; 동작. 큰 데이터 세트 (&amp;gt; 1GB)의 경우 메모리가 낭비되고 그래프 직렬화의 바이트 한계에 도달 할 수 있습니다. 경우 &lt;code&gt;tensors&lt;/code&gt; 하나 또는 그 이상의 큰 NumPy와 배열을 포함에 설명 된 다른 생각 &lt;a href=&quot;https://tensorflow.org/guide/data#consuming_numpy_arrays&quot;&gt;이 가이드를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a60ee121bf53c2c9d25970a777d3c84e6e10575" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;tensors&lt;/code&gt; contains a NumPy array, and eager execution is not enabled, the values will be embedded in the graph as one or more &lt;a href=&quot;../../../constant&quot;&gt;&lt;code&gt;tf.constant&lt;/code&gt;&lt;/a&gt; operations. For large datasets (&amp;gt; 1 GB), this can waste memory and run into byte limits of graph serialization. If &lt;code&gt;tensors&lt;/code&gt; contains one or more large NumPy arrays, consider the alternative described in &lt;a href=&quot;https://tensorflow.org/guide/data#consuming_numpy_arrays&quot;&gt;this guide&lt;/a&gt;.</source>
          <target state="translated">경우 유의 &lt;code&gt;tensors&lt;/code&gt; NumPy와 배열을 포함하고 싶어하는 실행이 가능하지 않고, 값이 하나 이상의 같은 그래프에 매립한다 &lt;a href=&quot;../../../constant&quot;&gt; &lt;code&gt;tf.constant&lt;/code&gt; &lt;/a&gt; 동작. 큰 데이터 세트 (&amp;gt; 1GB)의 경우 메모리가 낭비되고 그래프 직렬화의 바이트 한계에 도달 할 수 있습니다. 경우 &lt;code&gt;tensors&lt;/code&gt; 하나 또는 그 이상의 큰 NumPy와 배열을 포함에 설명 된 다른 생각 &lt;a href=&quot;https://tensorflow.org/guide/data#consuming_numpy_arrays&quot;&gt;이 가이드를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6149cccad273c165e08d7e6144dee086ed6d8789" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;tensors&lt;/code&gt; contains a NumPy array, and eager execution is not enabled, the values will be embedded in the graph as one or more &lt;a href=&quot;../../constant&quot;&gt;&lt;code&gt;tf.constant&lt;/code&gt;&lt;/a&gt; operations. For large datasets (&amp;gt; 1 GB), this can waste memory and run into byte limits of graph serialization. If &lt;code&gt;tensors&lt;/code&gt; contains one or more large NumPy arrays, consider the alternative described in &lt;a href=&quot;https://tensorflow.org/guide/data#consuming_numpy_arrays&quot;&gt;this guide&lt;/a&gt;.</source>
          <target state="translated">경우 유의 &lt;code&gt;tensors&lt;/code&gt; NumPy와 배열을 포함하고 싶어하는 실행이 가능하지 않고, 값이 하나 이상의 같은 그래프에 매립한다 &lt;a href=&quot;../../constant&quot;&gt; &lt;code&gt;tf.constant&lt;/code&gt; &lt;/a&gt; 동작. 큰 데이터 세트 (&amp;gt; 1GB)의 경우 메모리가 낭비되고 그래프 직렬화의 바이트 한계에 도달 할 수 있습니다. 경우 &lt;code&gt;tensors&lt;/code&gt; 하나 또는 그 이상의 큰 NumPy와 배열을 포함에 설명 된 다른 생각 &lt;a href=&quot;https://tensorflow.org/guide/data#consuming_numpy_arrays&quot;&gt;이 가이드를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b140bc33ea5918eda9257d6a5eb4297dfff01508" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;tensors&lt;/code&gt; contains a NumPy array, and eager execution is not enabled, the values will be embedded in the graph as one or more &lt;a href=&quot;../constant&quot;&gt;&lt;code&gt;tf.constant&lt;/code&gt;&lt;/a&gt; operations. For large datasets (&amp;gt; 1 GB), this can waste memory and run into byte limits of graph serialization. If &lt;code&gt;tensors&lt;/code&gt; contains one or more large NumPy arrays, consider the alternative described in &lt;a href=&quot;https://tensorflow.org/guide/data#consuming_numpy_arrays&quot;&gt;this guide&lt;/a&gt;.</source>
          <target state="translated">경우 유의 &lt;code&gt;tensors&lt;/code&gt; NumPy와 배열을 포함하고 싶어하는 실행이 가능하지 않고, 값이 하나 이상의 같은 그래프에 매립한다 &lt;a href=&quot;../constant&quot;&gt; &lt;code&gt;tf.constant&lt;/code&gt; &lt;/a&gt; 동작. 큰 데이터 세트 (&amp;gt; 1GB)의 경우 메모리가 낭비되고 그래프 직렬화의 바이트 한계에 도달 할 수 있습니다. 경우 &lt;code&gt;tensors&lt;/code&gt; 하나 또는 그 이상의 큰 NumPy와 배열을 포함에 설명 된 다른 생각 &lt;a href=&quot;https://tensorflow.org/guide/data#consuming_numpy_arrays&quot;&gt;이 가이드를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00bb33e7f2f86bdf06a1e536c75f45eb309c3131" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;z = [u, v]&lt;/code&gt;, then \(Beta(z) = int_0^1 t^{u-1} (1 - t)^{v-1} dt\), which defines the traditional bivariate beta function.</source>
          <target state="translated">참고 경우 &lt;code&gt;z = [u, v]&lt;/code&gt; 다음 \ (베타 (z) = int_0 ^ 1 t ^ {U-1} (1 - t)는 ^ {V-1} DT를 \), 이는 기존의 변량 베타 정의 함수.</target>
        </trans-unit>
        <trans-unit id="7519284befce3224d8263f11a5b37ae2ea167867" translate="yes" xml:space="preserve">
          <source>Note that if no bounding box information is available, setting &lt;code&gt;use_image_if_no_bounding_boxes = True&lt;/code&gt; will assume there is a single implicit bounding box covering the whole image. If &lt;code&gt;use_image_if_no_bounding_boxes&lt;/code&gt; is false and no bounding boxes are supplied, an error is raised.</source>
          <target state="translated">사용 가능한 경계 상자 정보가없는 경우 &lt;code&gt;use_image_if_no_bounding_boxes = True&lt;/code&gt; 를 설정 하면 전체 이미지를 덮는 단일 암시 적 경계 상자가 있다고 가정합니다. 경우 &lt;code&gt;use_image_if_no_bounding_boxes&lt;/code&gt; 은 거짓이며, 더 경계 상자가 제공되지 않는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f74e716187681901232ad385acb6272f138a2835" translate="yes" xml:space="preserve">
          <source>Note that if no bounding box information is available, setting &lt;code&gt;use_image_if_no_bounding_boxes = true&lt;/code&gt; will assume there is a single implicit bounding box covering the whole image. If &lt;code&gt;use_image_if_no_bounding_boxes&lt;/code&gt; is false and no bounding boxes are supplied, an error is raised.</source>
          <target state="translated">사용 가능한 경계 상자 정보가없는 경우 &lt;code&gt;use_image_if_no_bounding_boxes = true&lt;/code&gt; 설정 하면 전체 이미지를 덮는 단일 암시 적 경계 상자가 있다고 가정합니다. 경우 &lt;code&gt;use_image_if_no_bounding_boxes&lt;/code&gt; 은 거짓이며, 더 경계 상자가 제공되지 않는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f2a58af8e763b1a3ca51fe9d410888f1b8bdb075" translate="yes" xml:space="preserve">
          <source>Note that if the decorated function uses &lt;code&gt;Variable&lt;/code&gt;s, the enclosing variable scope must be using &lt;code&gt;ResourceVariable&lt;/code&gt;s.</source>
          <target state="translated">데코 레이팅 된 함수가 &lt;code&gt;Variable&lt;/code&gt; 을 사용하는 경우, 둘러싸는 변수 범위는 &lt;code&gt;ResourceVariable&lt;/code&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="574f3094ad03b3573fefc33c555f5a8b34f72df2" translate="yes" xml:space="preserve">
          <source>Note that if the spectrum is not Hermitian, then this operator corresponds to a complex matrix with non-zero imaginary part. In this case, setting &lt;code&gt;input_output_dtype&lt;/code&gt; to a real type will forcibly cast the output to be real, resulting in incorrect results!</source>
          <target state="translated">스펙트럼이 에르 미트가 아닌 경우이 연산자는 0이 아닌 허수 부분을 가진 복소수 행렬에 해당합니다. 이 경우 &lt;code&gt;input_output_dtype&lt;/code&gt; 을 실제 형식으로 설정 하면 출력이 실제로 실제 형식으로 캐스팅되어 결과가 잘못됩니다!</target>
        </trans-unit>
        <trans-unit id="802c1e3c748f52b2e8502b92a2842c236d074065" translate="yes" xml:space="preserve">
          <source>Note that if you use the defun decorator, any non-TensorFlow Python code that you may have written in your function won't get executed. See &lt;code&gt;tf.contrib.eager.defun&lt;/code&gt; for more details. The recommendation would be to debug without defun but switch to defun to get performance benefits of running map_fn in parallel.</source>
          <target state="translated">defun 데코레이터를 사용하면 함수에 작성한 TensorFlow가 아닌 ​​Python 코드는 실행되지 않습니다. 자세한 내용은 &lt;code&gt;tf.contrib.eager.defun&lt;/code&gt; 을 참조하십시오. 권장 사항은 defun없이 디버깅하는 것이 좋지만 defun으로 전환하여 map_fn을 병렬로 실행하면 성능 이점을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d045237fce6313ee64e728627f02291e9b72a30" translate="yes" xml:space="preserve">
          <source>Note that in V2, is_dynamic_op=False is not supported, meaning TRT engines will be built only when the corresponding TRTEngineOp is executed. But we still provide a way to avoid the cost of building TRT engines during inference (see more below).</source>
          <target state="translated">V2에서는 is_dynamic_op = False가 지원되지 않습니다. 즉, 해당 TRTEngineOp가 실행될 때만 TRT 엔진이 빌드됩니다. 그러나 추론 중에 TRT 엔진을 구축하는 비용을 피할 수있는 방법을 여전히 제공하고 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="7aef98ded340bdef8c93dca85b3052da7ad45324" translate="yes" xml:space="preserve">
          <source>Note that in case of ties the identity of the return value is not guaranteed.</source>
          <target state="translated">관계가있는 경우 반환 값의 ID가 보장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb8d4e9baf7359bda9fbe89f7ba6b1626ffaa22e" translate="yes" xml:space="preserve">
          <source>Note that in current implementation &lt;code&gt;estimator.evaluate&lt;/code&gt; will be called multiple times. This means that evaluation graph (including eval_input_fn) will be re-created for each &lt;code&gt;evaluate&lt;/code&gt; call. &lt;code&gt;estimator.train&lt;/code&gt; will be called only once.</source>
          <target state="translated">현재 구현에서는 &lt;code&gt;estimator.evaluate&lt;/code&gt; 가 여러 번 호출됩니다. 즉, 평가 그래프 (eval_input_fn 포함)가 각 &lt;code&gt;evaluate&lt;/code&gt; 호출 에 대해 다시 작성됩니다 . &lt;code&gt;estimator.train&lt;/code&gt; 은 한 번만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2c874f4cdb32e3408a903d8be798db049f586c58" translate="yes" xml:space="preserve">
          <source>Note that in the dense implementation of this algorithm, variables and their corresponding accumulators (momentum, gradient moving average, square gradient moving average) will be updated even if the gradient is zero (i.e. accumulators will decay, momentum will be applied). The sparse implementation (used when the gradient is an &lt;code&gt;IndexedSlices&lt;/code&gt; object, typically because of &lt;a href=&quot;../../../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt; or an embedding lookup in the forward pass) will not update variable slices or their accumulators unless those slices were used in the forward pass (nor is there an &quot;eventual&quot; correction to account for these omitted updates). This leads to more efficient updates for large embedding lookup tables (where most of the slices are not accessed in a particular graph execution), but differs from the published algorithm.</source>
          <target state="translated">이 알고리즘의 조밀 한 구현에서, 그래디언트가 0이더라도 변수 및 해당 누산기 (모멘텀, 그래디언트 이동 평균, 제곱 그래디언트 이동 평균)가 업데이트됩니다 (즉, 누산기가 감쇠하고 운동량이 적용됨). 드문 구현 (그라디언트가 &lt;code&gt;IndexedSlices&lt;/code&gt; 객체 일 때 사용 되며 일반적으로 &lt;a href=&quot;../../../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; &lt;/a&gt;또는 정방향 패스에 임베드 된 조회)는 해당 슬라이스가 정방향 패스에 사용되지 않는 한 가변 슬라이스 또는 누산기를 업데이트하지 않습니다 (이러한 업데이트를 설명하기위한 &quot;최종&quot;수정 사항도 없음). 이로 인해 대규모 임베딩 조회 테이블 (특정 그래프 실행에서 대부분의 슬라이스에 액세스 할 수 없음)에 대한보다 효율적인 업데이트가 발생하지만 게시 된 알고리즘과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5addfb077cb90b2905455a6f6c3ac84c7a531720" translate="yes" xml:space="preserve">
          <source>Note that in the dense implementation of this algorithm, variables and their corresponding accumulators (momentum, gradient moving average, square gradient moving average) will be updated even if the gradient is zero (i.e. accumulators will decay, momentum will be applied). The sparse implementation (used when the gradient is an &lt;code&gt;IndexedSlices&lt;/code&gt; object, typically because of &lt;a href=&quot;../../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt; or an embedding lookup in the forward pass) will not update variable slices or their accumulators unless those slices were used in the forward pass (nor is there an &quot;eventual&quot; correction to account for these omitted updates). This leads to more efficient updates for large embedding lookup tables (where most of the slices are not accessed in a particular graph execution), but differs from the published algorithm.</source>
          <target state="translated">이 알고리즘의 조밀 한 구현에서, 그래디언트가 0이더라도 변수 및 해당 누산기 (모멘텀, 그래디언트 이동 평균, 제곱 그래디언트 이동 평균)가 업데이트됩니다 (즉, 누산기가 감쇠하고 운동량이 적용됨). 드문 구현 (그라디언트가 &lt;code&gt;IndexedSlices&lt;/code&gt; 객체 일 때 사용 되며 일반적으로 &lt;a href=&quot;../../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; &lt;/a&gt;또는 정방향 패스에 임베드 된 조회)는 해당 슬라이스가 정방향 패스에 사용되지 않는 한 가변 슬라이스 또는 누산기를 업데이트하지 않습니다 (이러한 업데이트를 설명하기위한 &quot;최종&quot;수정 사항도 없음). 이로 인해 대규모 임베딩 조회 테이블 (특정 그래프 실행에서 대부분의 슬라이스에 액세스 할 수 없음)에 대한보다 효율적인 업데이트가 발생하지만 게시 된 알고리즘과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="401f6f824f04da5bfe9a2a4ccf6ab0af933625b7" translate="yes" xml:space="preserve">
          <source>Note that in the dense version of this algorithm, &lt;code&gt;accumulation&lt;/code&gt; is updated and applied regardless of a gradient's value, whereas the sparse version (when the gradient is an &lt;code&gt;IndexedSlices&lt;/code&gt;, typically because of &lt;a href=&quot;../../../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt; or an embedding) only updates variable slices and corresponding &lt;code&gt;accumulation&lt;/code&gt; terms when that part of the variable was used in the forward pass.</source>
          <target state="translated">이 알고리즘의 조밀 한 버전에서 유의 &lt;code&gt;accumulation&lt;/code&gt; 업데이트되며 (구배가있을 때 희소 버전 반면 경사의 값에 관계없이 적용 &lt;code&gt;IndexedSlices&lt;/code&gt; 전형적으로 인해, &lt;a href=&quot;../../../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; &lt;/a&gt; 또는 매립) 만 가변 슬라이스를 갱신하고 해당 &lt;code&gt;accumulation&lt;/code&gt; 변수의 해당 부분이 정방향 패스에서 사용 된 용어.</target>
        </trans-unit>
        <trans-unit id="39c3d030be7ba2922cf8bbf68f2329852ffcf52e" translate="yes" xml:space="preserve">
          <source>Note that irrespective of the context in which &lt;code&gt;map_func&lt;/code&gt; is defined (eager vs. graph), tf.data traces the function and executes it as a graph. To use Python code inside of the function you have two options:</source>
          <target state="translated">&lt;code&gt;map_func&lt;/code&gt; 의 컨텍스트에 관계없이 가 정의 된 (열심 한 그래프)와 는 함수를 추적하고이를 그래프로 실행합니다. 함수 내에서 Python 코드를 사용하려면 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="81e2886f72c4b06507aed5644584dc1de37f32c4" translate="yes" xml:space="preserve">
          <source>Note that it is a negative quantity between -1 and 0, where 0 indicates orthogonality and values closer to -1 indicate greater similarity. This makes it usable as a loss function in a setting where you try to maximize the proximity between predictions and targets.</source>
          <target state="translated">-1과 0 사이의 음수입니다. 여기서 0은 직교성을 나타내고 -1에 가까운 값은 더 큰 유사성을 나타냅니다. 이를 통해 예측과 대상 간의 근접성을 최대화하려는 설정에서 손실 함수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c28e62cca57c3d102d22c561e1a4b87e1b5c1a28" translate="yes" xml:space="preserve">
          <source>Note that linear cosine decay is more aggressive than cosine decay and larger initial learning rates can typically be used.</source>
          <target state="translated">선형 코사인 붕괴는 코사인 붕괴보다 더 공격적이며 더 큰 초기 학습 속도가 일반적으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="960ca71d30cfa024c4186818fe683f8901541ddd" translate="yes" xml:space="preserve">
          <source>Note that namedtuples with identical name and fields are always considered to have the same shallow structure (even with &lt;code&gt;check_types=True&lt;/code&gt;). For instance, this code will print &lt;code&gt;True&lt;/code&gt;:</source>
          <target state="translated">동일한 이름과 필드를 가진 &lt;code&gt;check_types=True&lt;/code&gt; 은 항상 같은 얕은 구조를 갖는 것으로 간주됩니다 ( check_types = True 사용 ). 예를 들어이 코드는 &lt;code&gt;True&lt;/code&gt; 를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="b6a77bc75104df995d6f88f50b9882464033d84e" translate="yes" xml:space="preserve">
          <source>Note that near image edges the filtering kernel may be partially outside the image boundaries. For these pixels, only input pixels inside the image will be included in the filter sum, and the output value will be appropriately normalized.</source>
          <target state="translated">이미지 가장자리 근처에서는 필터링 커널이 이미지 경계 외부에있을 수 있습니다. 이러한 픽셀의 경우 이미지 내부의 입력 픽셀 만 필터 합계에 포함되며 출력 값이 적절하게 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="f681d0bb5b7658560521a3cd86f2ed01b6b2cf79" translate="yes" xml:space="preserve">
          <source>Note that on CPU, if an out of bound index is found, an error is returned. On GPU, if an out of bound index is found, a 0 is stored in the corresponding output value.</source>
          <target state="translated">CPU에서 범위를 벗어난 인덱스를 찾으면 오류가 반환됩니다. GPU에서 범위를 벗어난 인덱스를 찾으면 해당 출력 값에 0이 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="e924de5440ed92a5d655bd9edc466f27be84b709" translate="yes" xml:space="preserve">
          <source>Note that on CPU, if an out of bound index is found, an error is returned. On GPU, if an out of bound index is found, the index is ignored.</source>
          <target state="translated">CPU에서 범위를 벗어난 인덱스를 찾으면 오류가 반환됩니다. GPU에서 범위를 벗어난 인덱스를 찾으면 인덱스가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7bf2ca8e05c2d036783ef692d352b86293224b53" translate="yes" xml:space="preserve">
          <source>Note that only tensors with real or complex dtypes are differentiable.</source>
          <target state="translated">실제 또는 복잡한 dtype을 가진 텐서 만 구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dd4d12e28c131a4ef36edec1e2547ad8eef803c" translate="yes" xml:space="preserve">
          <source>Note that optimizations are only applied in graph mode, (within tf.function).</source>
          <target state="translated">최적화는 그래프 모드에서만 적용됩니다 (tf.function 내).</target>
        </trans-unit>
        <trans-unit id="adaa530ba8bea623bb180c32cb91cb7914b931fc" translate="yes" xml:space="preserve">
          <source>Note that optimizations are only applied in graph mode, (within tf.function). In addition, as these are experimental options, the list is subject to change.</source>
          <target state="translated">최적화는 그래프 모드에서만 적용됩니다 (tf.function 내). 또한 실험 옵션이므로 목록이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abd13efb9bf7159213cd4e7443c620dd130c44f3" translate="yes" xml:space="preserve">
          <source>Note that repeats are allowed in the input SparseTensor. This op is useful for converting &lt;code&gt;SparseTensor&lt;/code&gt;s into dense formats for compatibility with ops that expect dense tensors.</source>
          <target state="translated">입력 SparseTensor에서 반복이 허용됩니다. 이 op는 밀도가 높은 텐서가 필요한 op와의 호환성을 위해 &lt;code&gt;SparseTensor&lt;/code&gt; 를 밀도가 높은 형식으로 변환하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="ecc42f0caf8eca72001bc334e02efac9851163e1" translate="yes" xml:space="preserve">
          <source>Note that since the inputs are of shape &lt;code&gt;[batch_size, d0, ... dN]&lt;/code&gt;, the corresponding pairs are computed within each batch sample but not across samples within a batch. For example, if &lt;code&gt;predictions&lt;/code&gt; represents a batch of 16 grayscale images of dimension [batch_size, 100, 200], then the set of pairs is drawn from each image, but not across images.</source>
          <target state="translated">입력은 &lt;code&gt;[batch_size, d0, ... dN]&lt;/code&gt; 이므로 해당 쌍은 각 배치 샘플 내에서 계산되지만 배치 내 샘플 간에는 계산되지 않습니다. 예를 들어, &lt;code&gt;predictions&lt;/code&gt; 이 차원 [batch_size, 100, 200]의 16 개 그레이 스케일 이미지의 배치를 나타내는 경우 쌍 세트는 각 이미지에서 그려 지지만 이미지를 가로 지르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5db26b033faf30cbafe9cfea9a99401b7c132601" translate="yes" xml:space="preserve">
          <source>Note that the 'out of vocabulary' character is only used for words that were present in the training set but are not included because they're not making the &lt;code&gt;num_words&lt;/code&gt; cut here. Words that were not seen in the training set but are in the test set have simply been skipped.</source>
          <target state="translated">'어휘에서 벗어난'문자는 학습 세트에 존재했지만 여기 에서 &lt;code&gt;num_words&lt;/code&gt; 를 자르지 않기 때문에 포함되지 않은 단어에만 사용 됩니다. 훈련 세트에는 보이지 않았지만 시험 세트에있는 단어는 건너 뛰었습니다.</target>
        </trans-unit>
        <trans-unit id="6113ba4d508f3e53788a1f5665cfc593eba750e1" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;reuse&lt;/code&gt; flag is inherited: if we open a reusing scope, then all its sub-scopes become reusing as well.</source>
          <target state="translated">점을 유의 &lt;code&gt;reuse&lt;/code&gt; 우리가 재사용 범위를 열면, 모든 하위 범위뿐만 아니라 재사용 될 : 플래그가 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="8b3a746df435b568689ea2e75e40f139ff2e8b05" translate="yes" xml:space="preserve">
          <source>Note that the Laplace distribution can be thought of two exponential distributions spliced together &quot;back-to-back.&quot;</source>
          <target state="translated">Laplace 분포는 두 개의 지수 분포가 &quot;back-to-back&quot;으로 결합 된 것으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a327f673b782b592aab19565e55d4f259175c75" translate="yes" xml:space="preserve">
          <source>Note that the above mentioned behavior matches python's str.split.</source>
          <target state="translated">위에서 언급 한 동작은 파이썬의 str.split과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7dbf7b0210d50e915dc0b161e9a8111daa542dd5" translate="yes" xml:space="preserve">
          <source>Note that the batch version of this function, &lt;code&gt;tf.parse_sequence_example&lt;/code&gt;, is written for better memory efficiency and will be faster on large &lt;code&gt;SequenceExample&lt;/code&gt;s.</source>
          <target state="translated">이 함수의 배치 버전 인 &lt;code&gt;tf.parse_sequence_example&lt;/code&gt; 은 더 나은 메모리 효율성을 위해 작성되었으며 큰 &lt;code&gt;SequenceExample&lt;/code&gt; 에서 더 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="9e6d585d4dcdfce3574eb75d838a42e338b46f67" translate="yes" xml:space="preserve">
          <source>Note that the chief worker also does the model training job, similar to other non-chief training workers (see next paragraph). In addition to the model training, it manages some extra work, e.g., checkpoint saving and restoring, writing summaries, etc.</source>
          <target state="translated">최고 임직원은 다른 비 임원 직원과 유사하게 모델 훈련 업무를 수행한다 (다음 단락 참조). 모델 교육 외에도 검사 점 저장 및 복원, 요약 작성 등과 같은 추가 작업을 관리합니다.</target>
        </trans-unit>
        <trans-unit id="815d2135340cb3441d170536899a25d3e970ac75" translate="yes" xml:space="preserve">
          <source>Note that the function assumes that &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; are already unit-normalized.</source>
          <target state="translated">이 함수는 &lt;code&gt;predictions&lt;/code&gt; 및 &lt;code&gt;labels&lt;/code&gt; 가정합니다. 이 이미 단위 정규화 .</target>
        </trans-unit>
        <trans-unit id="f8e0bd078f9684315af3bfa48a956847252b6cbf" translate="yes" xml:space="preserve">
          <source>Note that the hash function may change from time to time. This functionality will be deprecated and it's recommended to use &lt;a href=&quot;to_hash_bucket_fast&quot;&gt;&lt;code&gt;tf.strings.to_hash_bucket_fast()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;to_hash_bucket_strong&quot;&gt;&lt;code&gt;tf.strings.to_hash_bucket_strong()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">해시 함수는 때때로 변경 될 수 있습니다. 이 기능은 더 이상 사용되지 않으며 &lt;a href=&quot;to_hash_bucket_fast&quot;&gt; &lt;code&gt;tf.strings.to_hash_bucket_fast()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;to_hash_bucket_strong&quot;&gt; &lt;code&gt;tf.strings.to_hash_bucket_strong()&lt;/code&gt; &lt;/a&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="9ad485251b1b8a5eee42170ad14d607d7705dfc3" translate="yes" xml:space="preserve">
          <source>Note that the hash function may change from time to time. This functionality will be deprecated and it's recommended to use &lt;code&gt;tf.string_to_hash_bucket_fast()&lt;/code&gt; or &lt;code&gt;tf.string_to_hash_bucket_strong()&lt;/code&gt;.</source>
          <target state="translated">해시 함수는 때때로 변경 될 수 있습니다. 이 기능은 더 이상 사용되지 않으며 &lt;code&gt;tf.string_to_hash_bucket_fast()&lt;/code&gt; 또는 &lt;code&gt;tf.string_to_hash_bucket_strong()&lt;/code&gt; 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="129d1a89f45603733de5852bdc538919f04fd58f" translate="yes" xml:space="preserve">
          <source>Note that the input may have empty columns at the end, with no effect on this op.</source>
          <target state="translated">입력의 끝에 빈 열이있을 수 있으며이 op에는 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8abe593be83ba37c636e73a6158bffecf3631b83" translate="yes" xml:space="preserve">
          <source>Note that the interface for &lt;code&gt;tf.tpu.experimental.embedding_column&lt;/code&gt; is different from that of &lt;a href=&quot;../../../../feature_column/embedding_column&quot;&gt;&lt;code&gt;tf.compat.v1.feature_column.embedding_column&lt;/code&gt;&lt;/a&gt;: The following arguments are NOT supported: &lt;code&gt;ckpt_to_load_from&lt;/code&gt;, &lt;code&gt;tensor_name_in_ckpt&lt;/code&gt;, &lt;code&gt;max_norm&lt;/code&gt; and &lt;code&gt;trainable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tf.tpu.experimental.embedding_column&lt;/code&gt; 의 인터페이스는 tf.compat.v1.feature_column.embedding_column 의 인터페이스 와 &lt;a href=&quot;../../../../feature_column/embedding_column&quot;&gt; &lt;code&gt;tf.compat.v1.feature_column.embedding_column&lt;/code&gt; &lt;/a&gt; . 다음 인수는 지원되지 않습니다. &lt;code&gt;ckpt_to_load_from&lt;/code&gt; , &lt;code&gt;tensor_name_in_ckpt&lt;/code&gt; , &lt;code&gt;max_norm&lt;/code&gt; 및 &lt;code&gt;trainable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcf780ffbcf5c45eca299de25e2e480df268ae01" translate="yes" xml:space="preserve">
          <source>Note that the interface for &lt;code&gt;tf.tpu.experimental.shared_embedding_columns&lt;/code&gt; is different from that of &lt;a href=&quot;../../feature_column/shared_embedding_columns&quot;&gt;&lt;code&gt;tf.compat.v1.feature_column.shared_embedding_columns&lt;/code&gt;&lt;/a&gt;: The following arguments are NOT supported: &lt;code&gt;ckpt_to_load_from&lt;/code&gt;, &lt;code&gt;tensor_name_in_ckpt&lt;/code&gt;, &lt;code&gt;max_norm&lt;/code&gt; and &lt;code&gt;trainable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tf.tpu.experimental.shared_embedding_columns&lt;/code&gt; 의 인터페이스는 tf.compat.v1.feature_column.shared_embedding_columns 의 인터페이스 와 &lt;a href=&quot;../../feature_column/shared_embedding_columns&quot;&gt; &lt;code&gt;tf.compat.v1.feature_column.shared_embedding_columns&lt;/code&gt; &lt;/a&gt; . 다음 인수는 지원되지 않습니다. &lt;code&gt;ckpt_to_load_from&lt;/code&gt; , &lt;code&gt;tensor_name_in_ckpt&lt;/code&gt; , &lt;code&gt;max_norm&lt;/code&gt; 및 &lt;code&gt;trainable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32d78207ce6eaaece77df7019a2f96d27da9a9f2" translate="yes" xml:space="preserve">
          <source>Note that the keyword arg name &quot;cuda_only&quot; is misleading (since routine will return true when a GPU device is available irrespective of whether TF was built with CUDA support or ROCm support. However no changes here because</source>
          <target state="translated">키워드 arg 이름 &quot;cuda_only&quot;는 오해의 소지가 있습니다. TF가 CUDA 지원으로 빌드되었는지 ROCm 지원으로 빌드되었는지에 관계없이 GPU 장치를 사용할 수 있으면 루틴이 true를 리턴하기 때문에 변경 사항은 없습니다.</target>
        </trans-unit>
        <trans-unit id="c0270125bc4993a0541d9fa512f3fe8c1a196a78" translate="yes" xml:space="preserve">
          <source>Note that the method does not load any data by itself. If the method returns &lt;code&gt;false&lt;/code&gt;, the export directory definitely does not contain a SavedModel. If the method returns &lt;code&gt;true&lt;/code&gt;, the export directory may contain a SavedModel but provides no guarantee that it can be loaded.</source>
          <target state="translated">이 메소드는 자체적으로 데이터를로드하지 않습니다. 메소드가 &lt;code&gt;false&lt;/code&gt; 를 리턴 하면 내보내기 디렉토리에 저장된 모델이 포함되지 않은 것입니다. 메소드가 &lt;code&gt;true&lt;/code&gt; 를 리턴 하면, 내보내기 디렉토리에 저장된 모델이 포함될 수 있지만로드 될 수 있다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f7264bc1d90f49c816d4917489736fdf408647f" translate="yes" xml:space="preserve">
          <source>Note that the possible labels are assumed to be &lt;code&gt;[0, 1, 2, 3, 4]&lt;/code&gt;, resulting in a 5x5 confusion matrix.</source>
          <target state="translated">가능한 레이블은 &lt;code&gt;[0, 1, 2, 3, 4]&lt;/code&gt; 로 가정하여 5x5 혼동 행렬을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="40c79f656225cda5e6e51f6ea16d3455c49922f1" translate="yes" xml:space="preserve">
          <source>Note that the queue runners collected in the graph key &lt;code&gt;QUEUE_RUNNERS&lt;/code&gt; are already started automatically when you create a session with the supervisor, so unless you have non-collected queue runners to start you do not need to call this explicitly.</source>
          <target state="translated">그래프 키 &lt;code&gt;QUEUE_RUNNERS&lt;/code&gt; 에서 수집 된 큐 러너 는 수퍼바이저와의 세션을 작성할 때 이미 자동으로 시작되므로 수집되지 않은 큐 러너가없는 경우이를 명시 적으로 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e317428edda1b83776dc82560d20fc661ed1b6c" translate="yes" xml:space="preserve">
          <source>Note that the receiver_tensors and receiver_tensor_alternatives arguments will be automatically converted to the dict representation in either case, because the SavedModel format requires each input &lt;code&gt;Tensor&lt;/code&gt; to have a name (provided by the dict key).</source>
          <target state="translated">SavedModel 형식은 각 입력 &lt;code&gt;Tensor&lt;/code&gt; 에 이름 (dict 키로 제공)이 있어야하므로 receiver_tensors 및 receiver_tensor_alternatives 인수는 두 경우 모두 자동으로 dict 표시로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="3fe6d1eafeae4c39f85dd9382c952d6ce0c0d5cf" translate="yes" xml:space="preserve">
          <source>Note that this can only be called after calling apply_gradients() which actually generates this queuerunner.</source>
          <target state="translated">실제로이 큐 러너를 생성하는 apply_gradients ()를 호출 한 후에 만 ​​호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5094d67f3d8892e018bb62aab3647e7a6f48b27" translate="yes" xml:space="preserve">
          <source>Note that this cell is not optimized for performance on GPU. Please use &lt;a href=&quot;cudnnlstm&quot;&gt;&lt;code&gt;tf.compat.v1.keras.layers.CuDNNLSTM&lt;/code&gt;&lt;/a&gt; for better performance on GPU.</source>
          <target state="translated">이 셀은 GPU의 성능에 최적화되어 있지 않습니다. GPU 성능을 향상 &lt;a href=&quot;cudnnlstm&quot;&gt; &lt;code&gt;tf.compat.v1.keras.layers.CuDNNLSTM&lt;/code&gt; &lt;/a&gt; 려면 tf.compat.v1.keras.layers.CuDNNLSTM 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="676d50925133445521758d01e690fca8975be084" translate="yes" xml:space="preserve">
          <source>Note that this cell is not optimized for performance. Please use &lt;code&gt;tf.contrib.cudnn_rnn.CudnnGRU&lt;/code&gt; for better performance on GPU, or &lt;code&gt;tf.contrib.rnn.GRUBlockCellV2&lt;/code&gt; for better performance on CPU.</source>
          <target state="translated">이 셀은 성능에 최적화되어 있지 않습니다. GPU 성능을 향상 &lt;code&gt;tf.contrib.cudnn_rnn.CudnnGRU&lt;/code&gt; 려면 tf.contrib.cudnn_rnn.CudnnGRU 를 사용 하고 CPU 성능을 향상 시키 &lt;code&gt;tf.contrib.rnn.GRUBlockCellV2&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eb201df3d2b5bfd572776e39fa9037413277cb8c" translate="yes" xml:space="preserve">
          <source>Note that this cell is not optimized for performance. Please use &lt;code&gt;tf.contrib.cudnn_rnn.CudnnLSTM&lt;/code&gt; for better performance on GPU, or &lt;code&gt;tf.contrib.rnn.LSTMBlockCell&lt;/code&gt; and &lt;code&gt;tf.contrib.rnn.LSTMBlockFusedCell&lt;/code&gt; for better performance on CPU.</source>
          <target state="translated">이 셀은 성능에 최적화되어 있지 않습니다. GPU에서 성능을 향상 &lt;code&gt;tf.contrib.cudnn_rnn.CudnnLSTM&lt;/code&gt; 려면 tf.contrib.cudnn_rnn.CudnnLSTM 를 사용 하거나 CPU 성능을 향상 시키 &lt;code&gt;tf.contrib.rnn.LSTMBlockCell&lt;/code&gt; 및 &lt;code&gt;tf.contrib.rnn.LSTMBlockFusedCell&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="83f3a3a4f4f4189819189a9354e97a10007b9dbd" translate="yes" xml:space="preserve">
          <source>Note that this cell is not optimized for performance. Please use &lt;code&gt;tf.contrib.cudnn_rnn.CudnnRNNTanh&lt;/code&gt; for better performance on GPU.</source>
          <target state="translated">이 셀은 성능에 최적화되어 있지 않습니다. GPU 성능을 향상 &lt;code&gt;tf.contrib.cudnn_rnn.CudnnRNNTanh&lt;/code&gt; 려면 tf.contrib.cudnn_rnn.CudnnRNNTanh 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="27964ccc16ae82fcd7d78d2911af33e20462ca9a" translate="yes" xml:space="preserve">
          <source>Note that this function is different from the corresponding one in sklearn which returns the negative sum.</source>
          <target state="translated">이 함수는 음의 합계를 반환하는 sklearn의 해당 기능과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ec2b844ffc0cde99c0b5406566187f053bcc143c" translate="yes" xml:space="preserve">
          <source>Note that this is different from &lt;code&gt;initialized_value()&lt;/code&gt; which runs the op that initializes the variable before returning its value. This method returns the tensor that is used by the op that initializes the variable.</source>
          <target state="translated">이는 값을 반환하기 전에 변수를 초기화하는 op를 실행하는 &lt;code&gt;initialized_value()&lt;/code&gt; 와 다릅니다 . 이 메소드는 변수를 초기화하는 op가 사용하는 텐서를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4269a0cb623feb3d775921dbf7f25dbea72e2e6a" translate="yes" xml:space="preserve">
          <source>Note that this is unrelated to the &lt;a href=&quot;graph#graph_def_versions&quot;&gt;&lt;code&gt;tf.Graph.graph_def_versions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;graph#graph_def_versions&quot;&gt; &lt;code&gt;tf.Graph.graph_def_versions&lt;/code&gt; &lt;/a&gt; 와 관련이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e4641dbf377897d7cafbc94dd8e7458b0ed9ea46" translate="yes" xml:space="preserve">
          <source>Note that this method performs no computation, and simply looks up a JVP that was already computed (unlike backprop using a &lt;a href=&quot;../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt;, where the computation happens on the call to &lt;code&gt;tape.gradient&lt;/code&gt;).</source>
          <target state="translated">참고이 방법은 어떤 연산을 수행하지 않고, 단지 (a 사용 backprop 달리 이미 계산 된 JVP을 보이는 것을 &lt;a href=&quot;../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt; 계산이 호출에 일어나는 &lt;code&gt;tape.gradient&lt;/code&gt; 을 ).</target>
        </trans-unit>
        <trans-unit id="0a411633494993285b2ca66ea033f5305ceb9ccd" translate="yes" xml:space="preserve">
          <source>Note that this op fingerprints the raw underlying buffer, and it does not fingerprint Tensor's metadata such as data type and/or shape. For example, the fingerprint values are invariant under reshapes and bitcasts as long as the batch dimension remain the same:</source>
          <target state="translated">이 op는 원시 기본 버퍼를 지문 처리하고 데이터 유형 및 / 또는 모양과 같은 Tensor의 메타 데이터를 지문 처리하지 않습니다. 예를 들어, 배치 차원이 동일하게 유지되는 한 지문 값은 변형 및 비트 캐스트에서 변하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9dba7b57bd500edaeb9bc0b8ab7f9a2c33f1255" translate="yes" xml:space="preserve">
          <source>Note that this op only supports floating point and complex dtypes, due to tf.sqrt only supporting these types.</source>
          <target state="translated">tf.sqrt는 이러한 유형 만 지원하기 때문에이 op는 부동 소수점 및 복잡한 dtype 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c0799a68acd5cc28b1a646b6509f272d67280d7d" translate="yes" xml:space="preserve">
          <source>Note that this op splits strings into bytes, not unicode characters. To split strings into unicode characters, use &lt;a href=&quot;unicode_split&quot;&gt;&lt;code&gt;tf.strings.unicode_split&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 op는 문자열을 유니 코드 문자가 아닌 바이트로 분할합니다. 문자열을 유니 코드 문자로 나누려면 &lt;a href=&quot;unicode_split&quot;&gt; &lt;code&gt;tf.strings.unicode_split&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e12d122ac6753337440a18a6a1d0aa802f8b84be" translate="yes" xml:space="preserve">
          <source>Note that this process modifies decorator_func.</source>
          <target state="translated">이 프로세스는 decorator_func를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="876236a77b480dcabe6632d74a00e2db650c95d7" translate="yes" xml:space="preserve">
          <source>Note that this routine only supports wildcard characters in the basename portion of the pattern, not in the directory portion. Note also that the order of filenames returned is deterministic.</source>
          <target state="translated">이 루틴은 디렉토리 부분이 아닌 패턴의 기본 이름 부분에서만 와일드 카드 문자를 지원합니다. 반환되는 파일 이름의 순서는 결정적입니다.</target>
        </trans-unit>
        <trans-unit id="f0d1946702052ea01b4b396d107d11992b78bac4" translate="yes" xml:space="preserve">
          <source>Note that this will set this session and the graph as global defaults.</source>
          <target state="translated">이렇게하면이 세션과 그래프가 전역 기본값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3be9b356e9054ff0eaea728af20417c9c659c12b" translate="yes" xml:space="preserve">
          <source>Note that to be serialized and deserialized, classes must implement the &lt;code&gt;get_config()&lt;/code&gt; method. Functions do not have this requirement.</source>
          <target state="translated">직렬화 및 역 직렬화하려면 클래스가 &lt;code&gt;get_config()&lt;/code&gt; 메소드를 . 기능에는이 요구 사항이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4a91f1f0560a4b9ed496da98bbfb0a9885720ad4" translate="yes" xml:space="preserve">
          <source>Note that up to and including version 1.0, it was allowed (though explicitly discouraged) to pass False to the reuse argument, yielding undocumented behaviour slightly different from None. Starting at 1.1.0 passing None and False as reuse has exactly the same effect.</source>
          <target state="translated">버전 1.0까지는 명시 적으로 권장하지는 않지만 재사용 인수에 False를 전달하여 문서화되지 않은 동작을 없음과 약간 다르게 만들었습니다. 1.1.0부터 재사용으로 None과 False를 전달하면 동일한 효과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="569aab2ab65e778fc24ba965c22ff099243998b7" translate="yes" xml:space="preserve">
          <source>Note that we provide a default version of &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; that is used when no other strategy is in scope, that provides the same API with reasonable default behavior.</source>
          <target state="translated">기본 버전의 &lt;a href=&quot;../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; 를&lt;/a&gt; 제공합니다. 다른 전략이 범위 내에 있지 않을 때 사용되는 을 제공하며, 동일한 기본 동작으로 동일한 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c752a62b7496ca1c5e19ed8c92074d65d7e426d0" translate="yes" xml:space="preserve">
          <source>Note that we provide a default version of &lt;a href=&quot;distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; that is used when no other strategy is in scope, that provides the same API with reasonable default behavior.</source>
          <target state="translated">기본 버전의 &lt;a href=&quot;distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; 를&lt;/a&gt; 제공합니다. 다른 전략이 범위 내에 있지 않을 때 사용되는 을 제공하며, 동일한 기본 동작으로 동일한 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="49df504efd1de90320b92bbd82907222413f3073" translate="yes" xml:space="preserve">
          <source>Note that when P_A == 0 the above calculation simplifies into</source>
          <target state="translated">P_A == 0 일 때 위의 계산은 다음과 같이 단순화됩니다.</target>
        </trans-unit>
        <trans-unit id="13a872977c3f70438c317712189bdc6190cf3b3e" translate="yes" xml:space="preserve">
          <source>Note that when the &lt;code&gt;window&lt;/code&gt; transformation is applied to a dataset of nested elements, it produces a dataset of nested windows.</source>
          <target state="translated">&lt;code&gt;window&lt;/code&gt; 있을 때 변형이 중첩 된 요소의 세트에 적용하고, 그 중첩 윈도우의 데이터 세트를 생성한다.</target>
        </trans-unit>
        <trans-unit id="1ed0aac11222ae873f11e5dc6c38c61ae3205a36" translate="yes" xml:space="preserve">
          <source>Note that when using models you should ensure that your variables exist when using &lt;code&gt;watch_accessed_variables=False&lt;/code&gt;. Otherwise it's quite easy to make your first iteration not have any gradients:</source>
          <target state="translated">모델을 사용할 때 &lt;code&gt;watch_accessed_variables=False&lt;/code&gt; 를 사용할 때 변수가 존재해야합니다. . 그렇지 않으면 첫 번째 반복에 그라디언트가 없도록하는 것이 매우 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="e220ac89835270e7612d3930a3852330a3191ee5" translate="yes" xml:space="preserve">
          <source>Note that you can manually set the global session via &lt;code&gt;K.set_session(sess)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;K.set_session(sess)&lt;/code&gt; 를 통해 글로벌 세션을 수동으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="35e829814838a40a87e9a64882348df552c61fff" translate="yes" xml:space="preserve">
          <source>Note that you must re-normalize by 1/(2n) to obtain an inverse if &lt;code&gt;norm&lt;/code&gt; is not &lt;code&gt;'ortho'&lt;/code&gt;. That is: &lt;code&gt;signal == idct(dct(signal)) * 0.5 / signal.shape[-1]&lt;/code&gt;. When &lt;code&gt;norm='ortho'&lt;/code&gt;, we have: &lt;code&gt;signal == idct(dct(signal, norm='ortho'), norm='ortho')&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;norm&lt;/code&gt; 이 &lt;code&gt;'ortho'&lt;/code&gt; 이 아닌 경우 역수를 얻으려면 1 / (2n)으로 다시 정규화해야합니다 . 즉, &lt;code&gt;signal == idct(dct(signal)) * 0.5 / signal.shape[-1]&lt;/code&gt; 입니다. 경우 &lt;code&gt;norm='ortho'&lt;/code&gt; , 우리가 : &lt;code&gt;signal == idct(dct(signal, norm='ortho'), norm='ortho')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="695160d316b33a7e2dd72201788c50694f5e52a1" translate="yes" xml:space="preserve">
          <source>Note that you still have to call the &lt;code&gt;save()&lt;/code&gt; method to save the model. Passing these arguments to the constructor will not save variables automatically for you.</source>
          <target state="translated">여전히 &lt;code&gt;save()&lt;/code&gt; 를 호출해야합니다.모델을 저장 메소드를 . 이러한 인수를 생성자에 전달하면 변수가 자동으로 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1299f149def6c9c56c9387e40d116ad83071db3f" translate="yes" xml:space="preserve">
          <source>Note that you will likely need to use &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; with the returned dataset to further distribute it with the strategy.</source>
          <target state="translated">전략과 함께 추가 분포를 얻으려면 &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; 데이터 세트와 함께 Experiment_distribute_dataset 을 사용해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f808324e8fca6d8d656dc7ad92ecdbee3860f1b" translate="yes" xml:space="preserve">
          <source>Note that you will likely need to use tf.distribute.Strategy.experimental_distribute_dataset with the returned dataset to further distribute it with the strategy.</source>
          <target state="translated">전략과 함께 추가 분배하려면 리턴 된 데이터 세트와 함께 tf.distribute.Strategy.experimental_distribute_dataset을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dc8bdbc21ffa96ba14f99f122f39d6ce850bbe4b" translate="yes" xml:space="preserve">
          <source>Note that your application's flags are still defined the usual way using absl.flags DEFINE_flag() type functions.</source>
          <target state="translated">응용 프로그램의 플래그는 여전히 absl.flags DEFINE_flag () 유형 함수를 사용하여 일반적인 방식으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="42533e28866644d24b25744a516d1f6960f87b1d" translate="yes" xml:space="preserve">
          <source>Note that, the args of &lt;code&gt;features&lt;/code&gt; and &lt;code&gt;mode&lt;/code&gt; are most likely not used, but some Head implementations may require them.</source>
          <target state="translated">&lt;code&gt;features&lt;/code&gt; 과 &lt;code&gt;mode&lt;/code&gt; 의 인수는 사용되지 않을 가능성이 높지만 일부 헤드 구현에는 필요합니다.</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">참고 :</target>
        </trans-unit>
        <trans-unit id="a06ae04ab8de10c8c7fb61efdc138663538e5ae8" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;'mixed_float16'&lt;/code&gt; policy will apply loss scaling by default in &lt;a href=&quot;../../model#fit&quot;&gt;&lt;code&gt;Model.fit&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../model#train_on_batch&quot;&gt;&lt;code&gt;Model.train_on_batch&lt;/code&gt;&lt;/a&gt;, and other training methods. If no such method is used (e.g., a custom training loop is used) and &lt;code&gt;'mixed_float16'&lt;/code&gt; is used, the loss scale must be manually applied. See &lt;a href=&quot;lossscaleoptimizer&quot;&gt;&lt;code&gt;tf.keras.mixed_precision.experimental.LossScaleOptimizer&lt;/code&gt;&lt;/a&gt; for details. For &lt;code&gt;'mixed_bfloat16'&lt;/code&gt;, no loss scaling is done and loss scaling never needs to be manually applied.</source>
          <target state="translated">메모 &lt;code&gt;'mixed_float16'&lt;/code&gt; 에서 기본적으로 손실 스케일링을 적용 할 정책 &lt;a href=&quot;../../model#fit&quot;&gt; &lt;code&gt;Model.fit&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../model#train_on_batch&quot;&gt; &lt;code&gt;Model.train_on_batch&lt;/code&gt; &lt;/a&gt; 및 기타 교육 방법을. 그러한 방법을 사용하지 않고 (예를 들어, 사용자 정의 트레이닝 루프가 사용됨) &lt;code&gt;'mixed_float16'&lt;/code&gt; 이 사용되는 경우 손실 스케일을 수동으로 적용해야합니다. 자세한 내용은 &lt;a href=&quot;lossscaleoptimizer&quot;&gt; &lt;code&gt;tf.keras.mixed_precision.experimental.LossScaleOptimizer&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. 들어 &lt;code&gt;'mixed_bfloat16'&lt;/code&gt; , 손실 스케일링은 수행되지 손실 스케일링은 결코 수동으로 적용 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="79b85dc8d51a6da6086679dde9574f6544327b4a" translate="yes" xml:space="preserve">
          <source>Note to Implementors: In addition to these abstract methods, you must also implement the task_type, task_id, and rpc_layer attributes. You may choose to implement them either as properties with getters or setters or directly set the attributes.</source>
          <target state="translated">구현 자 참고 사항 : 이러한 추상 메소드 외에도 task_type, task_id 및 rpc_layer 속성도 구현해야합니다. getter 또는 setter를 사용하여 속성으로 구현하거나 속성을 직접 설정하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c63f7b2e1fe52b70cb6e4024c044d873867e7b1" translate="yes" xml:space="preserve">
          <source>Note, above &lt;code&gt;P(a, x)&lt;/code&gt; (&lt;code&gt;Igamma&lt;/code&gt;) is the lower regularized complete Gamma function.</source>
          <target state="translated">위의 &lt;code&gt;P(a, x)&lt;/code&gt; ( &lt;code&gt;Igamma&lt;/code&gt; )는 정규화 된 하위 감마 함수입니다.</target>
        </trans-unit>
        <trans-unit id="de2540fadbae1eb6e760d4d7e7f13dc8a00af55b" translate="yes" xml:space="preserve">
          <source>Note, above &lt;code&gt;Q(a, x)&lt;/code&gt; (&lt;code&gt;Igammac&lt;/code&gt;) is the upper regularized complete Gamma function.</source>
          <target state="translated">위의 &lt;code&gt;Q(a, x)&lt;/code&gt; ( &lt;code&gt;Igammac&lt;/code&gt; )는 상위 정규화 된 전체 감마 함수입니다.</target>
        </trans-unit>
        <trans-unit id="81ae6a2ab2fd652b5b5c6e0c656f1aaca1c48948" translate="yes" xml:space="preserve">
          <source>Note, by default (unless a custom &lt;code&gt;dropout_state_filter&lt;/code&gt; is provided), the memory state (&lt;code&gt;c&lt;/code&gt; component of any &lt;code&gt;LSTMStateTuple&lt;/code&gt;) passing through a &lt;code&gt;DropoutWrapper&lt;/code&gt; is never modified. This behavior is described in the above article.</source>
          <target state="translated">참고 기본적으로 (사용자 지정하지 않는 한 &lt;code&gt;dropout_state_filter&lt;/code&gt; 가 제공됩니다), 메모리 상태 ( &lt;code&gt;c&lt;/code&gt; 어떤의 구성 요소 &lt;code&gt;LSTMStateTuple&lt;/code&gt; 통과) &lt;code&gt;DropoutWrapper&lt;/code&gt; 는 수정되지 않습니다. 이 동작은 위 기사에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="61353057d98afbcb05a7bdf960d064322ec004e6" translate="yes" xml:space="preserve">
          <source>Note, if &lt;code&gt;cell.output_size&lt;/code&gt; is a (possibly nested) tuple of integers or &lt;code&gt;TensorShape&lt;/code&gt; objects, then &lt;code&gt;outputs&lt;/code&gt; will be a tuple having the same structure as &lt;code&gt;cell.output_size&lt;/code&gt;, containing Tensors having shapes corresponding to the shape data in &lt;code&gt;cell.output_size&lt;/code&gt;.</source>
          <target state="translated">만약 참고 &lt;code&gt;cell.output_size&lt;/code&gt; 은 정수 또는 (아마도 중첩) 튜플 &lt;code&gt;TensorShape&lt;/code&gt; 의 개체는 다음 &lt;code&gt;outputs&lt;/code&gt; 튜플과 동일한 구조를 갖는 것이다 &lt;code&gt;cell.output_size&lt;/code&gt; 에서 상기 형상 데이터에 대응하는 형상을 갖는 텐서 함유 &lt;code&gt;cell.output_size&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="fa2d99a7e37b130d2bf017f7c652bbb40183becd" translate="yes" xml:space="preserve">
          <source>Note, once keras style has been set, it is set globally for the entire program and cannot be unset.</source>
          <target state="translated">keras 스타일이 설정되면 전체 프로그램에 대해 전체적으로 설정되며 설정을 해제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="03b559d2e1aefa68c92b87df3d6a56014c371f34" translate="yes" xml:space="preserve">
          <source>Note, preferably use &lt;code&gt;VarLenFeature&lt;/code&gt; (possibly in combination with a &lt;code&gt;SequenceExample&lt;/code&gt;) in order to parse out &lt;code&gt;SparseTensor&lt;/code&gt;s instead of &lt;code&gt;SparseFeature&lt;/code&gt; due to its simplicity.</source>
          <target state="translated">단순성으로 인해 &lt;code&gt;SparseFeature&lt;/code&gt; 대신 &lt;code&gt;SparseTensor&lt;/code&gt; 를 구문 분석 하려면 &lt;code&gt;VarLenFeature&lt;/code&gt; 를 사용 하십시오 ( &lt;code&gt;SequenceExample&lt;/code&gt; 예제 와 함께 사용 가능 ) .</target>
        </trans-unit>
        <trans-unit id="7b4548198a643d107f04994df0dd15e63e85cc8f" translate="yes" xml:space="preserve">
          <source>Note, that this is somewhat like builtin Python file I/O, but there are semantic differences to make it more efficient for some backing filesystems. For example, a write mode file will not be opened until the first write call (to minimize RPC invocations in network filesystems).</source>
          <target state="translated">이것은 내장 파이썬 파일 I / O와 다소 비슷하지만 일부 백업 파일 시스템에서 더 효율적으로 만드는 의미상의 차이점이 있습니다. 예를 들어, 쓰기 모드 파일은 네트워크 파일 시스템에서 RPC 호출을 최소화하기 위해 첫 번째 쓰기 호출까지 열리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="bd1a113245b76f772cbd5a8d732d7b5bbdccbba7" translate="yes" xml:space="preserve">
          <source>Notes (assuming we're getting a commandline of some sort as our input): --&amp;gt; For duplicate flags, the last one we hit should &quot;win&quot;. --&amp;gt; Since flags that appear later win, a flagfile's settings can be &quot;weak&quot; if the --flagfile comes at the beginning of the argument sequence, and it can be &quot;strong&quot; if the --flagfile comes at the end. --&amp;gt; A further &quot;--flagfile=</source>
          <target state="translated">참고 사항 (우리가 입력으로 일종의 명령 줄을 얻는다고 가정) :-&amp;gt; 중복 플래그의 경우, 우리가 마지막으로 쳤다는 것은 &quot;승리&quot;해야합니다. -&amp;gt; 나중에 나타나는 플래그가이기므로 --flagfile이 인수 시퀀스의 시작 부분에 오면 플래그 파일의 설정이 &quot;약&quot;할 수 있고 --flagfile이 끝에 오면 &quot;강&quot;할 수 있습니다. -&amp;gt; 추가 &quot;--flagfile =</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="13a8c93c592fc92e9aecac52a9be4b756c401a93" translate="yes" xml:space="preserve">
          <source>Notes: The parent directories need to exist. Use &lt;a href=&quot;../../../io/gfile/makedirs&quot;&gt;&lt;code&gt;tf.io.gfile.makedirs&lt;/code&gt;&lt;/a&gt; instead if there is the possibility that the parent dirs don't exist.</source>
          <target state="translated">참고 : 상위 디렉토리가 존재해야합니다. 부모 디렉토리가 존재하지 않을 가능성이있는 경우 &lt;a href=&quot;../../../io/gfile/makedirs&quot;&gt; &lt;code&gt;tf.io.gfile.makedirs&lt;/code&gt; 를&lt;/a&gt; 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="323fb8b8573630ac70581d8cdaf19bf54bdb5796" translate="yes" xml:space="preserve">
          <source>Notes: The parent directories need to exist. Use &lt;a href=&quot;makedirs&quot;&gt;&lt;code&gt;tf.io.gfile.makedirs&lt;/code&gt;&lt;/a&gt; instead if there is the possibility that the parent dirs don't exist.</source>
          <target state="translated">참고 : 상위 디렉토리가 존재해야합니다. 부모 디렉토리가 존재하지 않을 가능성이있는 경우 &lt;a href=&quot;makedirs&quot;&gt; &lt;code&gt;tf.io.gfile.makedirs&lt;/code&gt; 를&lt;/a&gt; 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b3f141ab87179d0755abc1d4da67f0c04e3ab7c" translate="yes" xml:space="preserve">
          <source>Nothing.</source>
          <target state="translated">Nothing.</target>
        </trans-unit>
        <trans-unit id="df411adcbc859409d5288ffe48789d187b06b316" translate="yes" xml:space="preserve">
          <source>Notice how this function avoids making a numpy array directly. This is because it is important to not hold actual numpy views to the data longer than necessary. If you do, then the interpreter can no longer be invoked, because it is possible the interpreter would resize and invalidate the referenced tensors. The NumPy API doesn't allow any mutability of the the underlying buffers.</source>
          <target state="translated">이 함수가 어떻게 numpy 배열을 직접 만들지 않도록주의하십시오. 실제 numpy보기를 필요한 것보다 오래 데이터에 보유하지 않는 것이 중요하기 때문입니다. 그렇게하면, 인터프리터가 참조 된 텐서의 크기를 조정하고 무효화 할 수 있기 때문에 인터프리터를 더 이상 호출 할 수 없습니다. NumPy API는 기본 버퍼의 변경 성을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d50c26e0e094319167ab9cf4ea2664a67497326" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;scale&lt;/code&gt; has semantics more similar to standard deviation than variance. However it is not actually the std. deviation; the Student's t-distribution std. dev. is &lt;code&gt;scale sqrt(df / (df - 2))&lt;/code&gt; when &lt;code&gt;df &amp;gt; 2&lt;/code&gt;.</source>
          <target state="translated">그 주목 &lt;code&gt;scale&lt;/code&gt; 분산에 비해 표준 편차에 더 유사한 의미를 가지고있다. 그러나 실제로 표준은 아닙니다. 일탈; 학생의 t- 분포 표준 dev. 인 &lt;code&gt;scale sqrt(df / (df - 2))&lt;/code&gt; 때 &lt;code&gt;df &amp;gt; 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="feaa006c7cb998d0daf98aa74c2dc0b3047ff5a1" translate="yes" xml:space="preserve">
          <source>NumPy advanced indexing is currently not supported.</source>
          <target state="translated">NumPy 고급 인덱싱은 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff1bed83b6ad2769b544f9574354263198f224c9" translate="yes" xml:space="preserve">
          <source>Number of accumulated gradients currently in accumulator.</source>
          <target state="translated">현재 어큐뮬레이터에 누적 된 그라디언트 수입니다.</target>
        </trans-unit>
        <trans-unit id="c28eef31422890e190a8a735bef2bbc3ca45dd3f" translate="yes" xml:space="preserve">
          <source>Number of batch in the Sequence.</source>
          <target state="translated">시퀀스의 배치 수입니다.</target>
        </trans-unit>
        <trans-unit id="88c84f9eed23b2738c86fe8c8df27a937f9b93b1" translate="yes" xml:space="preserve">
          <source>Number of gradients that have currently been aggregated in accumulator.</source>
          <target state="translated">현재 어큐뮬레이터에서 집계 된 그라디언트 수입니다.</target>
        </trans-unit>
        <trans-unit id="c294a32144f9624cbbda9c7a7085da61f5995d68" translate="yes" xml:space="preserve">
          <source>Number of parallel threads</source>
          <target state="translated">병렬 스레드 수</target>
        </trans-unit>
        <trans-unit id="273bc020e0834613612160f28f8fbeb43f04c1ba" translate="yes" xml:space="preserve">
          <source>Number of trials used to construct a sample.</source>
          <target state="translated">샘플을 구성하는 데 사용 된 시행 횟수</target>
        </trans-unit>
        <trans-unit id="991ad41f4eb1372ed8d8090d4cf371d4b165ad81" translate="yes" xml:space="preserve">
          <source>Numpy Compatibility</source>
          <target state="translated">너피 호환성</target>
        </trans-unit>
        <trans-unit id="30f1b2ab4e0ff2c9c870d869e66c9512f7e0f7b4" translate="yes" xml:space="preserve">
          <source>Numpy array - value of the tensor.</source>
          <target state="translated">Numpy array-텐서의 값.</target>
        </trans-unit>
        <trans-unit id="b1e2609b31e3d2e9ce0cf87ec3f24aa44820553d" translate="yes" xml:space="preserve">
          <source>Numpy array(s) of predictions.</source>
          <target state="translated">Numpy 배열 (들)의 예측.</target>
        </trans-unit>
        <trans-unit id="586425c3ed508309560dea818b51f3e5895cbc95" translate="yes" xml:space="preserve">
          <source>Numpy equivalent is &lt;code&gt;tensor[mask]&lt;/code&gt;.</source>
          <target state="translated">Numpy equivalent은 &lt;code&gt;tensor[mask]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c0bec7241f649c869673060c3e29bbf228431bab" translate="yes" xml:space="preserve">
          <source>Object of type &lt;code&gt;CustomObjectScope&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CustomObjectScope&lt;/code&gt; 유형의 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="88bc41dfbd4c0979d50c81310b3ae4670a2d1f30" translate="yes" xml:space="preserve">
          <source>Objects exported with &lt;a href=&quot;save&quot;&gt;&lt;code&gt;tf.saved_model.save&lt;/code&gt;&lt;/a&gt; additionally have trackable objects and functions assigned to attributes:</source>
          <target state="translated">&lt;a href=&quot;save&quot;&gt; &lt;code&gt;tf.saved_model.save&lt;/code&gt; 로&lt;/a&gt; 내 보낸 객체에는 추가로 추적 가능한 객체 및 기능이 속성에 할당되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbc1198baa525915f9df34e4b9a278a51a386960" translate="yes" xml:space="preserve">
          <source>Objects of this class are intended to be provided as the optimizer argument (though LinearSDCA objects do not implement the &lt;code&gt;tf.train.Optimizer&lt;/code&gt; interface) when creating &lt;a href=&quot;../linearclassifier&quot;&gt;&lt;code&gt;tf.estimator.LinearClassifier&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../linearregressor&quot;&gt;&lt;code&gt;tf.estimator.LinearRegressor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 클래스의 오브젝트는 &lt;a href=&quot;../linearclassifier&quot;&gt; &lt;code&gt;tf.estimator.LinearClassifier&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../linearregressor&quot;&gt; &lt;code&gt;tf.estimator.LinearRegressor&lt;/code&gt; 를&lt;/a&gt; 작성할 때 옵티 마이저 인수로 제공됩니다 (LinearSDCA 오브젝트는 &lt;code&gt;tf.train.Optimizer&lt;/code&gt; 인터페이스를 구현하지 않지만 ) .</target>
        </trans-unit>
        <trans-unit id="2fb98b5a16bdcac87f3ce98bd2305af9a9612446" translate="yes" xml:space="preserve">
          <source>Objects that are equal automatically fail.</source>
          <target state="translated">동일한 객체는 자동으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="e8c575aea4d9a7963448001e0b8e8eb341a2a2f6" translate="yes" xml:space="preserve">
          <source>Often is the number of classes, labels, or real values to be predicted. Typically, logits is of shape &lt;code&gt;[batch_size, logits_dimension]&lt;/code&gt;.</source>
          <target state="translated">종종 예측할 클래스, 레이블 또는 실제 값의 수입니다. 일반적으로 로짓의 형태는 &lt;code&gt;[batch_size, logits_dimension]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3e0252e164cdccd96d0caaa6a85c500f8d598fc4" translate="yes" xml:space="preserve">
          <source>Often, a numerical approximation can be used for &lt;code&gt;log_cdf(x)&lt;/code&gt; that yields a more accurate answer than simply taking the logarithm of the &lt;code&gt;cdf&lt;/code&gt; when &lt;code&gt;x &amp;lt;&amp;lt; -1&lt;/code&gt;.</source>
          <target state="translated">종종 &lt;code&gt;x &amp;lt;&amp;lt; -1&lt;/code&gt; 때 &lt;code&gt;cdf&lt;/code&gt; 의 로그를 취하는 것보다 더 정확한 대답을 산출하는 &lt;code&gt;log_cdf(x)&lt;/code&gt; 숫자 근사를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bda78bed7a0f6a710d158e631a2f115e70dd3122" translate="yes" xml:space="preserve">
          <source>On CPU, solution is computed via Gaussian elimination with or without partial pivoting, depending on &lt;code&gt;partial_pivoting&lt;/code&gt; parameter. On GPU, Nvidia's cuSPARSE library is used: https://docs.nvidia.com/cuda/cusparse/index.html#gtsv</source>
          <target state="translated">CPU에서 솔루션은 &lt;code&gt;partial_pivoting&lt;/code&gt; 매개 변수 에 따라 부분 피벗이 있거나없는 가우시안 제거를 통해 계산됩니다 . GPU에서는 Nvidia의 cuSPARSE 라이브러리가 사용됩니다 : https://docs.nvidia.com/cuda/cusparse/index.html#gtsv</target>
        </trans-unit>
        <trans-unit id="d157d43dbd1b25a38191a077845611dc4b587b8e" translate="yes" xml:space="preserve">
          <source>On CPU: Caller may use SparseTensor or dense padded labels but calling with a SparseTensor will be significantly faster.</source>
          <target state="translated">CPU : 발신자가 SparseTensor 또는 빽빽한 패딩 레이블을 사용할 수 있지만 SparseTensor를 사용하여 호출하는 것이 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="611a5e996806cb9084c625b66e4eba3b7f6146d3" translate="yes" xml:space="preserve">
          <source>On TPU and GPU: Only dense padded labels are supported.</source>
          <target state="translated">TPU 및 GPU : 밀도가 높은 패딩 레이블 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8e6956260fd255d4a418eb60548c30ae41f00092" translate="yes" xml:space="preserve">
          <source>On construction the &lt;code&gt;QueueRunner&lt;/code&gt; adds an op to close the queue. That op will be run if the enqueue ops raise exceptions.</source>
          <target state="translated">구성시 &lt;code&gt;QueueRunner&lt;/code&gt; 는 대기열을 닫는 op를 추가합니다. 대기열 운영팀이 예외를 제기하면 해당 운영 체제가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7f9810fcd997ace84c6ae88c8ae6fec9dddda47a" translate="yes" xml:space="preserve">
          <source>On the other hand, setting new_shape as [2, 3, 4] is also an error: The third dimension is smaller than the original shape &lt;a href=&quot;and%20an%0a%60invalidargumenterror%60%20will%20be%20raised&quot;&gt;2, 3, 5&lt;/a&gt;.</source>
          <target state="translated">반면에 new_shape를 [2, 3, 4]로 설정하면 오류가 발생합니다. 3 차원은 원래 모양 &lt;a href=&quot;and%20an%0a%60invalidargumenterror%60%20will%20be%20raised&quot;&gt;2, 3, 5&lt;/a&gt; 보다 작습니다 .</target>
        </trans-unit>
        <trans-unit id="786e5efaffd2535a0930a115dd35ea4e6cfb94d8" translate="yes" xml:space="preserve">
          <source>Once a visible &lt;a href=&quot;physicaldevice&quot;&gt;&lt;code&gt;tf.config.PhysicalDevice&lt;/code&gt;&lt;/a&gt; is initialized one or more &lt;a href=&quot;logicaldevice&quot;&gt;&lt;code&gt;tf.config.LogicalDevice&lt;/code&gt;&lt;/a&gt; objects are created. Use &lt;a href=&quot;set_visible_devices&quot;&gt;&lt;code&gt;tf.config.set_visible_devices&lt;/code&gt;&lt;/a&gt; to configure the visibility of a physical device and &lt;a href=&quot;set_logical_device_configuration&quot;&gt;&lt;code&gt;tf.config.set_logical_device_configuration&lt;/code&gt;&lt;/a&gt; to configure multiple &lt;a href=&quot;logicaldevice&quot;&gt;&lt;code&gt;tf.config.LogicalDevice&lt;/code&gt;&lt;/a&gt; objects for a &lt;a href=&quot;physicaldevice&quot;&gt;&lt;code&gt;tf.config.PhysicalDevice&lt;/code&gt;&lt;/a&gt;. This is useful when separation between models is needed or to simulate a multi-device environment.</source>
          <target state="translated">보이는 &lt;a href=&quot;physicaldevice&quot;&gt; &lt;code&gt;tf.config.PhysicalDevice&lt;/code&gt; &lt;/a&gt; 가 초기화 하나 이상의 &lt;a href=&quot;logicaldevice&quot;&gt; &lt;code&gt;tf.config.LogicalDevice&lt;/code&gt; &lt;/a&gt; 객체가 생성됩니다. &lt;a href=&quot;set_visible_devices&quot;&gt; &lt;code&gt;tf.config.set_visible_devices&lt;/code&gt; &lt;/a&gt; 를 사용 하여 물리적 장치의 가시성을 구성하고 &lt;a href=&quot;set_logical_device_configuration&quot;&gt; &lt;code&gt;tf.config.set_logical_device_configuration&lt;/code&gt; &lt;/a&gt; 을 사용 하여 &lt;a href=&quot;physicaldevice&quot;&gt; &lt;code&gt;tf.config.PhysicalDevice&lt;/code&gt; 에&lt;/a&gt; 대해 여러 &lt;a href=&quot;logicaldevice&quot;&gt; &lt;code&gt;tf.config.LogicalDevice&lt;/code&gt; &lt;/a&gt; 객체 를 구성 하십시오 . 모델 간 분리가 필요하거나 다중 장치 환경을 시뮬레이션 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a380a819e0abe835751488f0036f75ec2d80df15" translate="yes" xml:space="preserve">
          <source>Once enabled, the check-numerics mechanism can be disabled by using &lt;a href=&quot;disable_check_numerics&quot;&gt;&lt;code&gt;tf.debugging.disable_check_numerics()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">활성화되면 &lt;a href=&quot;disable_check_numerics&quot;&gt; &lt;code&gt;tf.debugging.disable_check_numerics()&lt;/code&gt; &lt;/a&gt; 를 사용하여 체크 숫자 메커니즘을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ee7ecde4cf0b08ac81928b426328e497121fde2" translate="yes" xml:space="preserve">
          <source>Once enabled, the dumping can be disabled with the corresponding &lt;code&gt;disable_dump_debug_info()&lt;/code&gt; method under the same Python namespace. Calling this method more than once with the same &lt;code&gt;dump_root&lt;/code&gt; is idempotent. Calling this method more than once with different &lt;code&gt;tensor_debug_mode&lt;/code&gt;s leads to a &lt;code&gt;ValueError&lt;/code&gt;. Calling this method more than once with different &lt;code&gt;circular_buffer_size&lt;/code&gt;s leads to a &lt;code&gt;ValueError&lt;/code&gt;. Calling this method with a different &lt;code&gt;dump_root&lt;/code&gt; abolishes the previously-enabled &lt;code&gt;dump_root&lt;/code&gt;.</source>
          <target state="translated">활성화되면 동일한 Python 네임 스페이스 에서 해당 &lt;code&gt;disable_dump_debug_info()&lt;/code&gt; 메소드를 사용하여 덤프를 비활성화 할 수 있습니다 . 동일한 방법으로이 메소드를 두 번 이상 호출 &lt;code&gt;dump_root&lt;/code&gt; i 등원 입니다. 이상의 다른와 한 번 이상이 메소드를 호출 &lt;code&gt;tensor_debug_mode&lt;/code&gt; A와의 리드 &lt;code&gt;ValueError&lt;/code&gt; . 이상의 다른와 한 번 이상이 메소드를 호출 &lt;code&gt;circular_buffer_size&lt;/code&gt; A와의 리드 &lt;code&gt;ValueError&lt;/code&gt; . 다른 &lt;code&gt;dump_root&lt;/code&gt; 로이 메소드를 호출 하면 이전에 사용 가능한 &lt;code&gt;dump_root&lt;/code&gt; 가 폐지 됩니다.</target>
        </trans-unit>
        <trans-unit id="46b621bf1b7b42205b3975360b4207fe02efd4d2" translate="yes" xml:space="preserve">
          <source>Once successful, the following actions are also triggered:</source>
          <target state="translated">성공하면 다음 작업도 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="fe96882ea18141ec51f448bd8ad39a29aba58073" translate="yes" xml:space="preserve">
          <source>Once the gradients have been computed, push them into gradient accumulators. Each accumulator will check the staleness and drop the stale.</source>
          <target state="translated">그라디언트가 계산되면 그라디언트 누산기로 밀어 넣습니다. 각 누산기는 부실을 확인하고 부실을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="46b705867e9bac681c91b44d28e06299c9cab993" translate="yes" xml:space="preserve">
          <source>Once you have a dataset, you can apply transformations to prepare the data for your model:</source>
          <target state="translated">데이터 세트가 있으면 변환을 적용하여 모델의 데이터를 준비 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fefdee3c3c28c0fc420023e879f567b73ea343d" translate="yes" xml:space="preserve">
          <source>One can set &lt;code&gt;use_tpu&lt;/code&gt; to &lt;code&gt;False&lt;/code&gt; for testing. All training, evaluation, and predict will be executed on CPU. &lt;code&gt;input_fn&lt;/code&gt; and &lt;code&gt;model_fn&lt;/code&gt; will receive &lt;code&gt;train_batch_size&lt;/code&gt; or &lt;code&gt;eval_batch_size&lt;/code&gt; unmodified as &lt;code&gt;params['batch_size']&lt;/code&gt;.</source>
          <target state="translated">테스트를 위해 &lt;code&gt;use_tpu&lt;/code&gt; 를 &lt;code&gt;False&lt;/code&gt; 로 설정할 수 있습니다 . 모든 교육, 평가 및 예측은 CPU에서 실행됩니다. &lt;code&gt;input_fn&lt;/code&gt; 및 &lt;code&gt;model_fn&lt;/code&gt; 는 수신처 &lt;code&gt;train_batch_size&lt;/code&gt; 을 하거나 &lt;code&gt;eval_batch_size&lt;/code&gt; 같은 변성 &lt;code&gt;params['batch_size']&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cdbd2be2e630d6c954854753e6a1795863db859" translate="yes" xml:space="preserve">
          <source>One example of this is when using TensorFlow's RNN classes with Keras Models or Networks. Because Keras models do not properly set variable scopes, users of RNNs may either accidentally share scopes between two different models, or get errors about variables that already exist.</source>
          <target state="translated">이에 대한 한 가지 예는 Keras 모델 또는 네트워크와 함께 TensorFlow의 RNN 클래스를 사용할 때입니다. Keras 모델은 변수 범위를 올바르게 설정하지 않기 때문에 RNN 사용자는 실수로 두 가지 다른 모델간에 범위를 공유하거나 이미 존재하는 변수에 대한 오류를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ee7c661e768665b00f9899c7bfa63c6f6693861" translate="yes" xml:space="preserve">
          <source>One might see performance advantages by batching &lt;code&gt;Example&lt;/code&gt; protos with &lt;code&gt;parse_example&lt;/code&gt; instead of using this function directly.</source>
          <target state="translated">이 함수를 직접 사용하는 대신 &lt;code&gt;Example&lt;/code&gt; &lt;code&gt;parse_example&lt;/code&gt; 를 parse_example 로 일괄 처리하여 성능 이점을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dab0cd7480ebf7f860f247acda7fcf14eb80268b" translate="yes" xml:space="preserve">
          <source>One of &lt;a href=&quot;../keras/losses/reduction&quot;&gt;&lt;code&gt;tf.losses.Reduction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../keras/losses/reduction&quot;&gt; &lt;code&gt;tf.losses.Reduction&lt;/code&gt; &lt;/a&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="9d878c19bfa2774c551f29410b41c12c25f72a3f" translate="yes" xml:space="preserve">
          <source>One reasonable value for &lt;code&gt;max_shard_bytes&lt;/code&gt; is &lt;code&gt;(64 &amp;lt;&amp;lt; 20) - 1&lt;/code&gt;, or almost &lt;code&gt;64MB&lt;/code&gt;, to keep below the protobuf byte limit.</source>
          <target state="translated">&lt;code&gt;max_shard_bytes&lt;/code&gt; 에 적합한 하나의 값 에 는 &lt;code&gt;(64 &amp;lt;&amp;lt; 20) - 1&lt;/code&gt; 또는 거의 &lt;code&gt;64MB&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="835e31555f7691800120ca12eb99164bb510fe2c" translate="yes" xml:space="preserve">
          <source>One-hot encodes a text into a list of word indexes of size n.</source>
          <target state="translated">One-hot은 텍스트를 n 크기의 단어 색인 목록으로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="334c28d7f95e6546b1f8527110248a36e83aca1b" translate="yes" xml:space="preserve">
          <source>Only accepts value typed tensors as inputs and rejects resource variable handles as input.</source>
          <target state="translated">값 유형 텐서 만 입력으로 허용하고 자원 변수 핸들을 입력으로 거부합니다.</target>
        </trans-unit>
        <trans-unit id="2c9a5a5a96ded8e32df86874f36ecf44968ba5d1" translate="yes" xml:space="preserve">
          <source>Only after all variables have been updated, increment the global step.</source>
          <target state="translated">모든 변수가 업데이트 된 후에 만 ​​전역 단계를 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="7f16d87add9a4d1b320177e1e3408f9f4905fd3b" translate="yes" xml:space="preserve">
          <source>Only after step 4, pushes &lt;code&gt;global_step&lt;/code&gt; in the &lt;code&gt;token_queue&lt;/code&gt;, once for each worker replica. The workers can now fetch the global step, use it to update its local_step variable and start the next batch. Please note that some workers can consume multiple minibatches, while some may not consume even one. This is because each worker fetches minibatches as long as a token exists. If one worker is stuck for some reason and does not consume a token, another worker can use it.</source>
          <target state="translated">4 단계 이후에만 &lt;code&gt;token_queue&lt;/code&gt; 에서 &lt;code&gt;global_step&lt;/code&gt; 을 푸시 합니다 . 을 각 작업자 복제본마다 한 번씩 합니다. 작업자는 이제 전역 단계를 페치하고이를 사용하여 local_step 변수를 업데이트하고 다음 배치를 시작할 수 있습니다. 일부 작업자는 여러 개의 미니 배치를 소비 할 수 있지만 일부 작업자는 한 번도 소비하지 않을 수도 있습니다. 이는 토큰이 존재하는 한 각 작업자가 미니 배치를 가져 오기 때문입니다. 한 근로자가 어떤 이유로 갇혀 있고 토큰을 소비하지 않으면 다른 근로자가 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="848aabde175071eb7d2973c6b997c576ce3f230e" translate="yes" xml:space="preserve">
          <source>Only applicable if the layer has exactly one inbound node, i.e. if it is connected to one incoming layer.</source>
          <target state="translated">계층에 정확히 하나의 인바운드 노드가있는 경우에만 적용됩니다 (예 : 하나의 수신 계층에 연결된 경우).</target>
        </trans-unit>
        <trans-unit id="f8ae9708c35c08dd3a91689c37a43a53d064c8a7" translate="yes" xml:space="preserve">
          <source>Only applicable if the layer has exactly one input, i.e. if it is connected to one incoming layer, or if all inputs have the same shape.</source>
          <target state="translated">레이어에 정확히 하나의 입력이있는 경우, 즉 하나의 입력 레이어에 연결되어 있거나 모든 입력의 모양이 동일한 경우에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="5f93f160e8a3cd13974c1d1d07ae49506b264c02" translate="yes" xml:space="preserve">
          <source>Only applicable if the layer has exactly one input, i.e. if it is connected to one incoming layer.</source>
          <target state="translated">레이어에 정확히 하나의 입력이있는 경우에만 적용됩니다 (예 : 하나의 들어오는 레이어에 연결된 경우).</target>
        </trans-unit>
        <trans-unit id="e1a00617e9118b765a5da4cea50f9eb37fc4a6d0" translate="yes" xml:space="preserve">
          <source>Only applicable if the layer has exactly one output, i.e. if it is connected to one incoming layer.</source>
          <target state="translated">레이어에 정확히 하나의 출력이있는 경우에만 적용됩니다 (예 : 하나의 수신 레이어에 연결된 경우).</target>
        </trans-unit>
        <trans-unit id="46aefa0a3c890bb9ab3d8dbd7a554536f18592f1" translate="yes" xml:space="preserve">
          <source>Only applicable if the layer has one output, or if all outputs have the same shape.</source>
          <target state="translated">레이어에 하나의 출력이 있거나 모든 출력의 모양이 동일한 경우에만 적용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e5d2f36053d80483c7c77e2dabe525d87a1b0a41" translate="yes" xml:space="preserve">
          <source>Only elements not equal to zero will be present in the result. The resulting &lt;code&gt;SparseTensor&lt;/code&gt; has the same dtype and shape as the input.</source>
          <target state="translated">결과가 0이 아닌 요소 만 나타납니다. 결과 &lt;code&gt;SparseTensor&lt;/code&gt; 는 입력과 동일한 dtype 및 모양을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="975a6cab99f4fc8794526ba91ae6b5de1a717063" translate="yes" xml:space="preserve">
          <source>Only exists for API compatibility with multi-backend Keras.</source>
          <target state="translated">다중 백엔드 Keras와의 API 호환성에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="3bd483022a6b771acac0ed0f19ce4356587336fa" translate="yes" xml:space="preserve">
          <source>Only required if &lt;code&gt;featurewise_center&lt;/code&gt; or &lt;code&gt;featurewise_std_normalization&lt;/code&gt; or &lt;code&gt;zca_whitening&lt;/code&gt; are set to True.</source>
          <target state="translated">&lt;code&gt;featurewise_center&lt;/code&gt; 또는 &lt;code&gt;featurewise_std_normalization&lt;/code&gt; 또는 &lt;code&gt;zca_whitening&lt;/code&gt; 인 경우에만 필요 이 True로 설정된 .</target>
        </trans-unit>
        <trans-unit id="a0deb9469624ef3de6a5fca8370a75f399e9abc5" translate="yes" xml:space="preserve">
          <source>Only show profiler nodes consuming no less than 'min_bytes'.</source>
          <target state="translated">'min_bytes'이상을 소비하는 프로파일 러 노드 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="3543223ca94b517ce1d79b980379a6e684dce160" translate="yes" xml:space="preserve">
          <source>Only show profiler nodes consuming no less than 'min_float_ops'.</source>
          <target state="translated">'min_float_ops'이상을 소비하는 프로파일 러 노드 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="ecaa035d4228cf192bd8636b6e1185b75d710286" translate="yes" xml:space="preserve">
          <source>Only show profiler nodes consuming no less than 'min_micros'.</source>
          <target state="translated">최소 'min_micros'를 소비하는 프로파일 러 노드 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="bfa200f6671cd877447f75d362b0d97739f37e0c" translate="yes" xml:space="preserve">
          <source>Only show profiler nodes holding no less than 'min_params' parameters.</source>
          <target state="translated">최소 'min_params'매개 변수를 보유한 프로파일 러 노드 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="d15204c8cdf25510527c9049aa608dcb8e11ebe4" translate="yes" xml:space="preserve">
          <source>Only show profiler nodes including no less than 'min_occurrence' graph nodes.</source>
          <target state="translated">최소 minococrence 그래프 노드를 포함한 프로파일 러 노드 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="45014a153ba2554cdda5fbff52db2fccc9a3d832" translate="yes" xml:space="preserve">
          <source>Only the properties in the following list are allowed to be replaced:</source>
          <target state="translated">다음 목록의 속성 만 교체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bf44bdfaaf8a75129eb96c14731b91e83dbe6b3" translate="yes" xml:space="preserve">
          <source>Only top &lt;code&gt;num_words-1&lt;/code&gt; most frequent words will be taken into account. Only words known by the tokenizer will be taken into account.</source>
          <target state="translated">최상위 &lt;code&gt;num_words-1&lt;/code&gt; 개의 가장 빈번한 단어 만 고려됩니다. 토크 나이저가 알고있는 단어 만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="6207cf0b1fcae2548ea275564b9d80af705e5075" translate="yes" xml:space="preserve">
          <source>Only topological loading (&lt;code&gt;by_name=False&lt;/code&gt;) is supported when loading weights from the TensorFlow format. Note that topological loading differs slightly between TensorFlow and HDF5 formats for user-defined classes inheriting from &lt;a href=&quot;../model&quot;&gt;&lt;code&gt;tf.keras.Model&lt;/code&gt;&lt;/a&gt;: HDF5 loads based on a flattened list of weights, while the TensorFlow format loads based on the object-local names of attributes to which layers are assigned in the &lt;code&gt;Model&lt;/code&gt;'s constructor.</source>
          <target state="translated">TensorFlow 형식에서 가중치를로드 할 때는 토폴로지로드 ( &lt;code&gt;by_name=False&lt;/code&gt; ) 만 지원됩니다. &lt;a href=&quot;../model&quot;&gt; &lt;code&gt;tf.keras.Model&lt;/code&gt; &lt;/a&gt; 에서 상속되는 사용자 정의 클래스의 경우 TensorFlow와 HDF5 형식간에 토폴로지로드가 약간 다릅니다 . &lt;code&gt;Model&lt;/code&gt; 에 레이어가 할당됩니다 의 생성자 .</target>
        </trans-unit>
        <trans-unit id="6b4fb8cd75e1cd47b418d479e0e5ffe20c3d8a51" translate="yes" xml:space="preserve">
          <source>Only topological loading (&lt;code&gt;by_name=False&lt;/code&gt;) is supported when loading weights from the TensorFlow format. Note that topological loading differs slightly between TensorFlow and HDF5 formats for user-defined classes inheriting from &lt;a href=&quot;model&quot;&gt;&lt;code&gt;tf.keras.Model&lt;/code&gt;&lt;/a&gt;: HDF5 loads based on a flattened list of weights, while the TensorFlow format loads based on the object-local names of attributes to which layers are assigned in the &lt;code&gt;Model&lt;/code&gt;'s constructor.</source>
          <target state="translated">TensorFlow 형식에서 가중치를로드 할 때는 토폴로지로드 ( &lt;code&gt;by_name=False&lt;/code&gt; ) 만 지원됩니다. &lt;a href=&quot;model&quot;&gt; &lt;code&gt;tf.keras.Model&lt;/code&gt; &lt;/a&gt; 에서 상속되는 사용자 정의 클래스의 경우 TensorFlow와 HDF5 형식간에 토폴로지로드가 약간 다릅니다 . &lt;code&gt;Model&lt;/code&gt; 의 생성자 에 레이어가 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="07c6635c2c9cb1a4a8d05f9319ab6dd4e5048d19" translate="yes" xml:space="preserve">
          <source>Only use for 2D matrices.</source>
          <target state="translated">2D 행렬에만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4b340c8b7563412570948f5811d2e0d1fcfc6fd6" translate="yes" xml:space="preserve">
          <source>Only used when &lt;code&gt;state_is_tuple=True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;state_is_tuple=True&lt;/code&gt; 인 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b15b2e628cec174a105574d79fe2f17a084d3986" translate="yes" xml:space="preserve">
          <source>Op raising &lt;code&gt;InvalidArgumentError&lt;/code&gt; unless &lt;code&gt;x&lt;/code&gt; has specified rank or higher. If static checks determine &lt;code&gt;x&lt;/code&gt; has correct rank, a &lt;code&gt;no_op&lt;/code&gt; is returned.</source>
          <target state="translated">제기 연산 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 을 하지 않는 &lt;code&gt;x&lt;/code&gt; 는 계급 이상을 지정했다. 정적 검사에서 &lt;code&gt;x&lt;/code&gt; 의 순위가 올바른 것으로 판단되면 &lt;code&gt;no_op&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="098f6e5bf7bdeda25821fc7d4a97c3d1e3084c0e" translate="yes" xml:space="preserve">
          <source>Op raising &lt;code&gt;InvalidArgumentError&lt;/code&gt; unless &lt;code&gt;x&lt;/code&gt; has specified rank or higher. If static checks determine &lt;code&gt;x&lt;/code&gt; has correct rank, a &lt;code&gt;no_op&lt;/code&gt; is returned. This can be used with &lt;a href=&quot;../control_dependencies&quot;&gt;&lt;code&gt;tf.control_dependencies&lt;/code&gt;&lt;/a&gt; inside of &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s to block followup computation until the check has executed.</source>
          <target state="translated">제기 연산 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 을 하지 않는 &lt;code&gt;x&lt;/code&gt; 는 계급 이상을 지정했다. 정적 검사에서 &lt;code&gt;x&lt;/code&gt; 의 순위가 올바른 것으로 판단되면 &lt;code&gt;no_op&lt;/code&gt; 가 반환됩니다. 이것은 &lt;a href=&quot;../control_dependencies&quot;&gt; &lt;code&gt;tf.control_dependencies&lt;/code&gt; &lt;/a&gt; 내부의 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 있습니다 체크가 실행될 때까지 S가 후속 계산을 차단.</target>
        </trans-unit>
        <trans-unit id="596890038d2f4619ff502aa203e2a4fe8fbc7d6b" translate="yes" xml:space="preserve">
          <source>Op raising &lt;code&gt;InvalidArgumentError&lt;/code&gt; unless &lt;code&gt;x&lt;/code&gt; has specified rank. If static checks determine &lt;code&gt;x&lt;/code&gt; has correct rank, a &lt;code&gt;no_op&lt;/code&gt; is returned.</source>
          <target state="translated">연산 모금 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 하지 않는 &lt;code&gt;x&lt;/code&gt; 순위를 지정하고 있습니다. 정적 검사에서 &lt;code&gt;x&lt;/code&gt; 의 순위가 올바른 것으로 판단되면 &lt;code&gt;no_op&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="06c195988461802db40ca52cef9448571d1118c6" translate="yes" xml:space="preserve">
          <source>Op raising &lt;code&gt;InvalidArgumentError&lt;/code&gt; unless &lt;code&gt;x&lt;/code&gt; has specified rank. If static checks determine &lt;code&gt;x&lt;/code&gt; has correct rank, a &lt;code&gt;no_op&lt;/code&gt; is returned. This can be used with &lt;a href=&quot;../control_dependencies&quot;&gt;&lt;code&gt;tf.control_dependencies&lt;/code&gt;&lt;/a&gt; inside of &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s to block followup computation until the check has executed.</source>
          <target state="translated">연산 모금 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 하지 않는 &lt;code&gt;x&lt;/code&gt; 순위를 지정하고 있습니다. 정적 검사에서 &lt;code&gt;x&lt;/code&gt; 의 순위가 올바른 것으로 판단되면 &lt;code&gt;no_op&lt;/code&gt; 가 반환됩니다. 이것은 함께 사용할 수 &lt;a href=&quot;../control_dependencies&quot;&gt; &lt;code&gt;tf.control_dependencies&lt;/code&gt; &lt;/a&gt; 내부 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 체크가 실행될 때까지 S가 후속 계산을 차단.</target>
        </trans-unit>
        <trans-unit id="e0d1d83d20389674f847577ddd6e9ef6a46070d2" translate="yes" xml:space="preserve">
          <source>Op raising &lt;code&gt;InvalidArgumentError&lt;/code&gt; unless &lt;code&gt;x&lt;/code&gt; is all negative. This can be used with &lt;a href=&quot;../control_dependencies&quot;&gt;&lt;code&gt;tf.control_dependencies&lt;/code&gt;&lt;/a&gt; inside of &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s to block followup computation until the check has executed.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 모두 음수가 아닌 경우 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 발생 이것은 함께 사용할 수 &lt;a href=&quot;../control_dependencies&quot;&gt; &lt;code&gt;tf.control_dependencies&lt;/code&gt; &lt;/a&gt; 내부 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 체크가 실행될 때까지 S가 후속 계산을 차단.</target>
        </trans-unit>
        <trans-unit id="ba1ee87854f8947ddd651440e36e379c615c1291" translate="yes" xml:space="preserve">
          <source>Op raising &lt;code&gt;InvalidArgumentError&lt;/code&gt; unless &lt;code&gt;x&lt;/code&gt; is all non-negative. This can be used with &lt;a href=&quot;../control_dependencies&quot;&gt;&lt;code&gt;tf.control_dependencies&lt;/code&gt;&lt;/a&gt; inside of &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s to block followup computation until the check has executed.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 모두 음수가 아닌 경우 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 발생 이것은 &lt;a href=&quot;../control_dependencies&quot;&gt; &lt;code&gt;tf.control_dependencies&lt;/code&gt; &lt;/a&gt; 내부의 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 있습니다 체크가 실행될 때까지 S가 후속 계산을 차단.</target>
        </trans-unit>
        <trans-unit id="361fa9e13cc2c8099b40d309ed5e8e66b0d24ae8" translate="yes" xml:space="preserve">
          <source>Op raising &lt;code&gt;InvalidArgumentError&lt;/code&gt; unless &lt;code&gt;x&lt;/code&gt; is all non-positive. This can be used with &lt;a href=&quot;../control_dependencies&quot;&gt;&lt;code&gt;tf.control_dependencies&lt;/code&gt;&lt;/a&gt; inside of &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s to block followup computation until the check has executed.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 모두 양수가 아닌 경우 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 발생 이것은 함께 사용할 수 &lt;a href=&quot;../control_dependencies&quot;&gt; &lt;code&gt;tf.control_dependencies&lt;/code&gt; &lt;/a&gt; 내부 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 체크가 실행될 때까지 S가 후속 계산을 차단.</target>
        </trans-unit>
        <trans-unit id="3dfb0fd99082882c62cc797dfaf0f9ab1227cbda" translate="yes" xml:space="preserve">
          <source>Op raising &lt;code&gt;InvalidArgumentError&lt;/code&gt; unless &lt;code&gt;x&lt;/code&gt; is all positive. This can be used with &lt;a href=&quot;../control_dependencies&quot;&gt;&lt;code&gt;tf.control_dependencies&lt;/code&gt;&lt;/a&gt; inside of &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s to block followup computation until the check has executed.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 모두 양수가 아닌 경우 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 발생 이것은 &lt;a href=&quot;../control_dependencies&quot;&gt; &lt;code&gt;tf.control_dependencies&lt;/code&gt; &lt;/a&gt; 내부의 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 있습니다 체크가 실행될 때까지 S가 후속 계산을 차단.</target>
        </trans-unit>
        <trans-unit id="2d6ccd9e38a5515f27f2a37371ad8f3c121c0c9a" translate="yes" xml:space="preserve">
          <source>Op raising &lt;code&gt;InvalidArgumentError&lt;/code&gt; unless all shape constraints are satisfied. If static checks determine all constraints are satisfied, a &lt;code&gt;no_op&lt;/code&gt; is returned.</source>
          <target state="translated">연산 모금 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 모든 형태의 제약 조건을 만족하지 않는. 정적 검사에서 모든 제약 조건이 충족되면 &lt;code&gt;no_op&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d7343d9c604bc27b934f3ca86d9e1cc4a5673860" translate="yes" xml:space="preserve">
          <source>Op raising &lt;code&gt;InvalidArgumentError&lt;/code&gt; unless rank of &lt;code&gt;x&lt;/code&gt; is in &lt;code&gt;ranks&lt;/code&gt;. If static checks determine &lt;code&gt;x&lt;/code&gt; has matching rank, a &lt;code&gt;no_op&lt;/code&gt; is returned.</source>
          <target state="translated">연산 모금 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 의 순위하지 않는 한 &lt;code&gt;x&lt;/code&gt; 에 &lt;code&gt;ranks&lt;/code&gt; . 정적 검사에서 &lt;code&gt;x&lt;/code&gt; 의 순위가 일치하면 &lt;code&gt;no_op&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="808751f20236ba9f4f46801b57a61e0d86834323" translate="yes" xml:space="preserve">
          <source>Op raising &lt;code&gt;InvalidArgumentError&lt;/code&gt; unless rank of &lt;code&gt;x&lt;/code&gt; is in &lt;code&gt;ranks&lt;/code&gt;. If static checks determine &lt;code&gt;x&lt;/code&gt; has matching rank, a &lt;code&gt;no_op&lt;/code&gt; is returned. This can be used with &lt;a href=&quot;../control_dependencies&quot;&gt;&lt;code&gt;tf.control_dependencies&lt;/code&gt;&lt;/a&gt; inside of &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s to block followup computation until the check has executed.</source>
          <target state="translated">연산 모금 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 의 순위하지 않는 한 &lt;code&gt;x&lt;/code&gt; 에 &lt;code&gt;ranks&lt;/code&gt; . 정적 검사에서 &lt;code&gt;x&lt;/code&gt; 의 순위가 일치하면 &lt;code&gt;no_op&lt;/code&gt; 가 반환됩니다. 이것은 함께 사용할 수 &lt;a href=&quot;../control_dependencies&quot;&gt; &lt;code&gt;tf.control_dependencies&lt;/code&gt; &lt;/a&gt; 내부 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 체크가 실행될 때까지 S가 후속 계산을 차단.</target>
        </trans-unit>
        <trans-unit id="6a19ee52efc0952940edf50fdbcbc099519f9e25" translate="yes" xml:space="preserve">
          <source>Op that implements the reader.</source>
          <target state="translated">독자를 구현하는 Op.</target>
        </trans-unit>
        <trans-unit id="1a11911596171403f2263a0a984a017e9748e964" translate="yes" xml:space="preserve">
          <source>Op that raises &lt;code&gt;InvalidArgumentError&lt;/code&gt; if &lt;code&gt;x != y&lt;/code&gt; is False.</source>
          <target state="translated">&lt;code&gt;x != y&lt;/code&gt; 가 False 인 경우 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 를 발생 시키는 Op .</target>
        </trans-unit>
        <trans-unit id="b2b19c558b3588adc05816f9473cfb88b38c582d" translate="yes" xml:space="preserve">
          <source>Op that raises &lt;code&gt;InvalidArgumentError&lt;/code&gt; if &lt;code&gt;x != y&lt;/code&gt; is ever False. This can be used with &lt;a href=&quot;../control_dependencies&quot;&gt;&lt;code&gt;tf.control_dependencies&lt;/code&gt;&lt;/a&gt; inside of &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s to block followup computation until the check has executed.</source>
          <target state="translated">&lt;code&gt;x != y&lt;/code&gt; 가 False 이면 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 를 발생 시키는 Op . 이것은 함께 사용할 수 &lt;a href=&quot;../control_dependencies&quot;&gt; &lt;code&gt;tf.control_dependencies&lt;/code&gt; &lt;/a&gt; 내부 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 체크가 실행될 때까지 S가 후속 계산을 차단.</target>
        </trans-unit>
        <trans-unit id="09f874893b2fc224a7dfd38cfb8c6a10d790a5fc" translate="yes" xml:space="preserve">
          <source>Op that raises &lt;code&gt;InvalidArgumentError&lt;/code&gt; if &lt;code&gt;x &amp;gt; 0&lt;/code&gt; is False.</source>
          <target state="translated">&lt;code&gt;x &amp;gt; 0&lt;/code&gt; 이 False 이면 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 를 발생 시키는 Op .</target>
        </trans-unit>
        <trans-unit id="464eabae7d7fa985507d2ba02ae595aa482df84f" translate="yes" xml:space="preserve">
          <source>Op that raises &lt;code&gt;InvalidArgumentError&lt;/code&gt; if &lt;code&gt;x &amp;gt; y&lt;/code&gt; is False.</source>
          <target state="translated">&lt;code&gt;x &amp;gt; y&lt;/code&gt; 가 False 인 경우 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 를 발생 시키는 Op .</target>
        </trans-unit>
        <trans-unit id="a5fd2c61b376adb0a0791130d5b81aa81aa2de96" translate="yes" xml:space="preserve">
          <source>Op that raises &lt;code&gt;InvalidArgumentError&lt;/code&gt; if &lt;code&gt;x &amp;gt; y&lt;/code&gt; is False. This can be used with &lt;a href=&quot;../control_dependencies&quot;&gt;&lt;code&gt;tf.control_dependencies&lt;/code&gt;&lt;/a&gt; inside of &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s to block followup computation until the check has executed.</source>
          <target state="translated">&lt;code&gt;x &amp;gt; y&lt;/code&gt; 가 False 인 경우 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 를 발생 시키는 Op . 이것은 함께 사용할 수 &lt;a href=&quot;../control_dependencies&quot;&gt; &lt;code&gt;tf.control_dependencies&lt;/code&gt; &lt;/a&gt; 내부 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 체크가 실행될 때까지 S가 후속 계산을 차단.</target>
        </trans-unit>
        <trans-unit id="ba327da79e6f24d205ecb9ef42082d3a9301bc60" translate="yes" xml:space="preserve">
          <source>Op that raises &lt;code&gt;InvalidArgumentError&lt;/code&gt; if &lt;code&gt;x &amp;gt;= 0&lt;/code&gt; is False.</source>
          <target state="translated">&lt;code&gt;x &amp;gt;= 0&lt;/code&gt; 이 False 이면 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 를 발생 시키는 Op .</target>
        </trans-unit>
        <trans-unit id="77076716bbb2b2e88130a5da704ae24948005fef" translate="yes" xml:space="preserve">
          <source>Op that raises &lt;code&gt;InvalidArgumentError&lt;/code&gt; if &lt;code&gt;x &amp;gt;= y&lt;/code&gt; is False.</source>
          <target state="translated">&lt;code&gt;x &amp;gt;= y&lt;/code&gt; 가 False 인 경우 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 를 발생 시키는 Op .</target>
        </trans-unit>
        <trans-unit id="6f532e09fec1098afc3963be64c488ced5dedaaa" translate="yes" xml:space="preserve">
          <source>Op that raises &lt;code&gt;InvalidArgumentError&lt;/code&gt; if &lt;code&gt;x &amp;gt;= y&lt;/code&gt; is False. This can be used with &lt;a href=&quot;../control_dependencies&quot;&gt;&lt;code&gt;tf.control_dependencies&lt;/code&gt;&lt;/a&gt; inside of &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s to block followup computation until the check has executed.</source>
          <target state="translated">&lt;code&gt;x &amp;gt;= y&lt;/code&gt; 가 False 인 경우 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 를 발생 시키는 Op . 이것은 함께 사용할 수 &lt;a href=&quot;../control_dependencies&quot;&gt; &lt;code&gt;tf.control_dependencies&lt;/code&gt; &lt;/a&gt; 내부 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 체크가 실행될 때까지 S가 후속 계산을 차단.</target>
        </trans-unit>
        <trans-unit id="cf7859f98feb3c9f7d25c16475ac1246fa3778f6" translate="yes" xml:space="preserve">
          <source>Op that raises &lt;code&gt;InvalidArgumentError&lt;/code&gt; if &lt;code&gt;x &amp;lt; 0&lt;/code&gt; is False.</source>
          <target state="translated">&lt;code&gt;x &amp;lt; 0&lt;/code&gt; 이 False 인 경우 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 를 발생 시키는 Op .</target>
        </trans-unit>
        <trans-unit id="d81689e7e8a76ba8fbdb2064e97ec101d0aacb7b" translate="yes" xml:space="preserve">
          <source>Op that raises &lt;code&gt;InvalidArgumentError&lt;/code&gt; if &lt;code&gt;x &amp;lt; y&lt;/code&gt; is False.</source>
          <target state="translated">&lt;code&gt;x &amp;lt; y&lt;/code&gt; 가 False 인 경우 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 를 발생 시키는 Op .</target>
        </trans-unit>
        <trans-unit id="f90ad3a5b249fd5537961700f1302053660222ef" translate="yes" xml:space="preserve">
          <source>Op that raises &lt;code&gt;InvalidArgumentError&lt;/code&gt; if &lt;code&gt;x &amp;lt; y&lt;/code&gt; is False. This can be used with &lt;a href=&quot;../control_dependencies&quot;&gt;&lt;code&gt;tf.control_dependencies&lt;/code&gt;&lt;/a&gt; inside of &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s to block followup computation until the check has executed.</source>
          <target state="translated">&lt;code&gt;x &amp;lt; y&lt;/code&gt; 가 False 인 경우 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 를 발생 시키는 Op . 이것은 함께 사용할 수 &lt;a href=&quot;../control_dependencies&quot;&gt; &lt;code&gt;tf.control_dependencies&lt;/code&gt; &lt;/a&gt; 내부 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 체크가 실행될 때까지 S가 후속 계산을 차단.</target>
        </trans-unit>
        <trans-unit id="9b37b28d7bb99c46c4d44ae58900d328ef7202b4" translate="yes" xml:space="preserve">
          <source>Op that raises &lt;code&gt;InvalidArgumentError&lt;/code&gt; if &lt;code&gt;x &amp;lt;= 0&lt;/code&gt; is False.</source>
          <target state="translated">&lt;code&gt;x &amp;lt;= 0&lt;/code&gt; 이 False 인 경우 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 를 발생 시키는 Op .</target>
        </trans-unit>
        <trans-unit id="e581b8c6f240dd46805d52f991c0d60e535f71a8" translate="yes" xml:space="preserve">
          <source>Op that raises &lt;code&gt;InvalidArgumentError&lt;/code&gt; if &lt;code&gt;x &amp;lt;= y&lt;/code&gt; is False.</source>
          <target state="translated">&lt;code&gt;x &amp;lt;= y&lt;/code&gt; 가 False 인 경우 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 를 발생 시키는 Op .</target>
        </trans-unit>
        <trans-unit id="3f13f20824ad6bdff284387f7172bc4de5602335" translate="yes" xml:space="preserve">
          <source>Op that raises &lt;code&gt;InvalidArgumentError&lt;/code&gt; if &lt;code&gt;x &amp;lt;= y&lt;/code&gt; is False. This can be used with &lt;a href=&quot;../control_dependencies&quot;&gt;&lt;code&gt;tf.control_dependencies&lt;/code&gt;&lt;/a&gt; inside of &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s to block followup computation until the check has executed.</source>
          <target state="translated">&lt;code&gt;x &amp;lt;= y&lt;/code&gt; 가 False 인 경우 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 를 발생 시키는 Op . 이것은 함께 사용할 수 &lt;a href=&quot;../control_dependencies&quot;&gt; &lt;code&gt;tf.control_dependencies&lt;/code&gt; &lt;/a&gt; 내부 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 체크가 실행될 때까지 S가 후속 계산을 차단.</target>
        </trans-unit>
        <trans-unit id="dbb4d55356cee9c6a8b5684a56bc7b91e0cbb757" translate="yes" xml:space="preserve">
          <source>Op that raises &lt;code&gt;InvalidArgumentError&lt;/code&gt; if &lt;code&gt;x == y&lt;/code&gt; is False.</source>
          <target state="translated">&lt;code&gt;x == y&lt;/code&gt; 가 False 인 경우 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 를 발생 시키는 Op .</target>
        </trans-unit>
        <trans-unit id="ea943b48081b9bd9676cd7cc43c9e94e29c96e1e" translate="yes" xml:space="preserve">
          <source>Op that raises &lt;code&gt;InvalidArgumentError&lt;/code&gt; if &lt;code&gt;x == y&lt;/code&gt; is False. This can be used with &lt;a href=&quot;../control_dependencies&quot;&gt;&lt;code&gt;tf.control_dependencies&lt;/code&gt;&lt;/a&gt; inside of &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s to block followup computation until the check has executed.</source>
          <target state="translated">&lt;code&gt;x == y&lt;/code&gt; 가 False 인 경우 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 를 발생 시키는 Op . 이것은 함께 사용할 수 &lt;a href=&quot;../control_dependencies&quot;&gt; &lt;code&gt;tf.control_dependencies&lt;/code&gt; &lt;/a&gt; 내부 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 체크가 실행될 때까지 S가 후속 계산을 차단.</target>
        </trans-unit>
        <trans-unit id="d53311e78cb142f3f9436e93d1606f9e6da6d210" translate="yes" xml:space="preserve">
          <source>Op that raises &lt;code&gt;InvalidArgumentError&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are not close enough.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 충분히 가까이 있지 않으면 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 를 발생 시키는 Op .</target>
        </trans-unit>
        <trans-unit id="72a4ae90a715348967138b3fcbd8685c54fa3a78" translate="yes" xml:space="preserve">
          <source>Op that raises &lt;code&gt;InvalidArgumentError&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are not close enough. This can be used with &lt;a href=&quot;../control_dependencies&quot;&gt;&lt;code&gt;tf.control_dependencies&lt;/code&gt;&lt;/a&gt; inside of &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s to block followup computation until the check has executed.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 충분히 가까이 있지 않으면 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 를 발생 시키는 Op . 이것은 함께 사용할 수 &lt;a href=&quot;../control_dependencies&quot;&gt; &lt;code&gt;tf.control_dependencies&lt;/code&gt; &lt;/a&gt; 내부 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 체크가 실행될 때까지 S가 후속 계산을 차단.</target>
        </trans-unit>
        <trans-unit id="52b08fd68d529008ade1eace0482c686f5187b77" translate="yes" xml:space="preserve">
          <source>Opens file &lt;code&gt;path&lt;/code&gt; and creates a &lt;code&gt;TFRecordWriter&lt;/code&gt; writing to it.</source>
          <target state="translated">파일 &lt;code&gt;path&lt;/code&gt; 를 &lt;code&gt;TFRecordWriter&lt;/code&gt; 쓰기를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="ef3134c526daef3feabac60d9bea2532557040bb" translate="yes" xml:space="preserve">
          <source>Operation that sets the accumulator's time step.</source>
          <target state="translated">누산기의 시간 단계를 설정하는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="b216bc043bf0865daa7a9f1e34fbf240fb88bb65" translate="yes" xml:space="preserve">
          <source>Operation was rejected because the system is not in a state to execute it.</source>
          <target state="translated">시스템이 시스템을 실행할 수있는 상태가 아니기 때문에 작업이 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="0fe833131379f7149f6f75890d7b60087f1ee397" translate="yes" xml:space="preserve">
          <source>Operations are recorded if they are executed within this context manager and at least one of their inputs is being &quot;watched&quot;.</source>
          <target state="translated">작업이이 컨텍스트 관리자 내에서 실행되고 입력 중 하나 이상이 &quot;감시&quot;되면 작업이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="452adcb0c5eb3c57c14e11658d9251a00c2c91a1" translate="yes" xml:space="preserve">
          <source>Operations executed while this context manager is active will not be recorded on the tape. This is useful for reducing the memory used by tracing all computations.</source>
          <target state="translated">이 컨텍스트 관리자가 활성화 된 동안 실행 된 조작은 테이프에 기록되지 않습니다. 이는 모든 계산을 추적하는 데 사용되는 메모리를 줄이는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2ec755af8320a82448a2a6b17f8ba178dc018416" translate="yes" xml:space="preserve">
          <source>Operations for linear algebra.</source>
          <target state="translated">선형 대수 연산.</target>
        </trans-unit>
        <trans-unit id="334df36539c6e4cce07013b66310e92bcf787d75" translate="yes" xml:space="preserve">
          <source>Operations for manipulating the binary representations of integers.</source>
          <target state="translated">정수의 이진 표현 조작 조작.</target>
        </trans-unit>
        <trans-unit id="f5bad7dc8a50fe4eebd66d7fa1ad13d16ed2c8ca" translate="yes" xml:space="preserve">
          <source>Operations for working with string Tensors.</source>
          <target state="translated">문자열 텐서로 작업하기위한 작업.</target>
        </trans-unit>
        <trans-unit id="abc751fc0c326ebea8001fb31e16b8d8b1721d43" translate="yes" xml:space="preserve">
          <source>Operations for writing summary data, for use in analysis and visualization.</source>
          <target state="translated">분석 및 시각화에 사용하기 위해 요약 데이터를 작성하는 작업</target>
        </trans-unit>
        <trans-unit id="4b1cbaf378acc35ccbcbc07e1f83af9ab385dbbc" translate="yes" xml:space="preserve">
          <source>Operations that rely on a random seed actually derive it from two seeds: the global and operation-level seeds. This sets the global seed.</source>
          <target state="translated">랜덤 시드에 의존하는 오퍼레이션은 실제로 글로벌 및 오퍼레이션 레벨 시드의 두 시드에서 파생됩니다. 이것은 글로벌 시드를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2658e3359b4262ab02a920e6c5dec7fa284414b3" translate="yes" xml:space="preserve">
          <source>Operations that rely on a random seed actually derive it from two seeds: the graph-level and operation-level seeds. This sets the graph-level seed.</source>
          <target state="translated">랜덤 시드에 의존하는 오퍼레이션은 실제로 그래프 레벨과 오퍼레이션 레벨 시드의 두 시드에서 파생됩니다. 그래프 레벨 시드를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3d146f13f4d8e62dbc36974460cb3b660a9b1243" translate="yes" xml:space="preserve">
          <source>Operator adding dropout to inputs and outputs of the given cell.</source>
          <target state="translated">주어진 셀의 입력과 출력에 드롭 아웃을 추가하는 연산자.</target>
        </trans-unit>
        <trans-unit id="7bbab9f36e30418243383f860fc5513a33528162" translate="yes" xml:space="preserve">
          <source>Operator properties deduced from the spectrum.</source>
          <target state="translated">스펙트럼에서 추론 된 오퍼레이터 특성.</target>
        </trans-unit>
        <trans-unit id="3385f7455d003dbc3d051edfc9c33774c251c0e5" translate="yes" xml:space="preserve">
          <source>Operator that ensures an RNNCell runs on a particular device.</source>
          <target state="translated">RNNCell이 특정 장치에서 실행되도록하는 연산자입니다.</target>
        </trans-unit>
        <trans-unit id="6301248b258d4f9a381794cda385e7cdd34b58d7" translate="yes" xml:space="preserve">
          <source>Operators for manipulating tensors.</source>
          <target state="translated">텐서를 조작하는 연산자.</target>
        </trans-unit>
        <trans-unit id="9ec35601b80aa19f3b4b7c5ddf43dd0a1d469e42" translate="yes" xml:space="preserve">
          <source>Operators that take advantage of special structure, while providing a consistent API to users.</source>
          <target state="translated">사용자에게 일관된 API를 제공하면서 특수한 구조를 이용하는 운영자</target>
        </trans-unit>
        <trans-unit id="ac3910e0eb9ec4f52f53e69e4274f28e10a5c4a5" translate="yes" xml:space="preserve">
          <source>Ops and objects returned from a &lt;code&gt;model_fn&lt;/code&gt; and passed to &lt;code&gt;TPUEstimator&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;model_fn&lt;/code&gt; 및 객체가 model_fn 에서 반환되어 TPUEstimator 로 전달되었습니다 &lt;code&gt;TPUEstimator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e84fa506f27d9e235c1dd3f9433ae633ce53833" translate="yes" xml:space="preserve">
          <source>Ops and objects returned from a &lt;code&gt;model_fn&lt;/code&gt; and passed to an &lt;code&gt;Estimator&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;model_fn&lt;/code&gt; 및 객체는 model_fn 에서 반환되어 &lt;code&gt;Estimator&lt;/code&gt; 로 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="40300876c268c41e58c76b564bf9d1e081234568" translate="yes" xml:space="preserve">
          <source>Ops related to Tensor Processing Units.</source>
          <target state="translated">텐서 처리 장치와 관련된 작전.</target>
        </trans-unit>
        <trans-unit id="5426d893d942b54b23899f742bab27b471bf0e32" translate="yes" xml:space="preserve">
          <source>Optimization parameters for Adagrad with TPU embeddings.</source>
          <target state="translated">TPU 임베딩을 사용한 Adagrad의 최적화 매개 변수.</target>
        </trans-unit>
        <trans-unit id="f512565257e0380650b3bc0fa1daf65251cf7470" translate="yes" xml:space="preserve">
          <source>Optimization parameters for Adagrad.</source>
          <target state="translated">Adagrad에 대한 최적화 매개 변수.</target>
        </trans-unit>
        <trans-unit id="cbb2549250e3290a52381b55fea9c5ae2823fe3c" translate="yes" xml:space="preserve">
          <source>Optimization parameters for Adam with TPU embeddings.</source>
          <target state="translated">TPU 임베딩이있는 Adam의 최적화 매개 변수.</target>
        </trans-unit>
        <trans-unit id="a43d3c78a674d5aa846145fee1f1da005db6a080" translate="yes" xml:space="preserve">
          <source>Optimization parameters for Adam.</source>
          <target state="translated">Adam의 최적화 매개 변수.</target>
        </trans-unit>
        <trans-unit id="867d697831ddd77fc7a7c3224735bac5910a9e0a" translate="yes" xml:space="preserve">
          <source>Optimization parameters for stochastic gradient descent for TPU embeddings.</source>
          <target state="translated">TPU 임베딩에 대한 확률 적 경사 하강에 대한 최적화 파라미터.</target>
        </trans-unit>
        <trans-unit id="13592d7ff798a59baabd3e82f73d38f0549d8e7d" translate="yes" xml:space="preserve">
          <source>Optimization parameters for stochastic gradient descent.</source>
          <target state="translated">확률 적 경사 하강에 대한 최적화 파라미터.</target>
        </trans-unit>
        <trans-unit id="38a277ebb3b736522bf69478e7a2188cbb37a6ae" translate="yes" xml:space="preserve">
          <source>Optimizer that implements the Adadelta algorithm.</source>
          <target state="translated">Adadelta 알고리즘을 구현하는 최적화 프로그램.</target>
        </trans-unit>
        <trans-unit id="228602481c7f2e8ba729c600e5efed58674b1fed" translate="yes" xml:space="preserve">
          <source>Optimizer that implements the Adagrad algorithm.</source>
          <target state="translated">Adagrad 알고리즘을 구현하는 최적화 프로그램.</target>
        </trans-unit>
        <trans-unit id="789cbde5dc49057407e9d1ed70e7ded6a7450f2d" translate="yes" xml:space="preserve">
          <source>Optimizer that implements the Adam algorithm.</source>
          <target state="translated">Adam 알고리즘을 구현하는 최적화 프로그램.</target>
        </trans-unit>
        <trans-unit id="c8794e9a41cd3b971d66476e5a3b1b251ef019f5" translate="yes" xml:space="preserve">
          <source>Optimizer that implements the Adamax algorithm.</source>
          <target state="translated">Adamax 알고리즘을 구현하는 최적화 프로그램.</target>
        </trans-unit>
        <trans-unit id="697c1368bc112191e0cc03d43870878745b0d2ba" translate="yes" xml:space="preserve">
          <source>Optimizer that implements the FTRL algorithm.</source>
          <target state="translated">FTRL 알고리즘을 구현하는 최적화 프로그램.</target>
        </trans-unit>
        <trans-unit id="ed9d476d0a7d49448991afea7571cbf4e700af52" translate="yes" xml:space="preserve">
          <source>Optimizer that implements the Momentum algorithm.</source>
          <target state="translated">모멘텀 알고리즘을 구현하는 최적화 프로그램.</target>
        </trans-unit>
        <trans-unit id="31b7076e799b416e0580c81190655c33e247eed7" translate="yes" xml:space="preserve">
          <source>Optimizer that implements the NAdam algorithm.</source>
          <target state="translated">NAdam 알고리즘을 구현하는 최적화 프로그램.</target>
        </trans-unit>
        <trans-unit id="6d5b5b1196bc3b128f28d763f02c2404ecd95a58" translate="yes" xml:space="preserve">
          <source>Optimizer that implements the Proximal Adagrad algorithm.</source>
          <target state="translated">Proximal Adagrad 알고리즘을 구현하는 최적화 프로그램.</target>
        </trans-unit>
        <trans-unit id="a3d453c733beca74a5f8203eff5967d046d0d9b4" translate="yes" xml:space="preserve">
          <source>Optimizer that implements the RMSProp algorithm.</source>
          <target state="translated">RMSProp 알고리즘을 구현하는 최적화 프로그램.</target>
        </trans-unit>
        <trans-unit id="36977c109aa83bcecbfac2cbcfdcd95a074b5ba0" translate="yes" xml:space="preserve">
          <source>Optimizer that implements the RMSprop algorithm.</source>
          <target state="translated">RMSprop 알고리즘을 구현하는 최적화 프로그램.</target>
        </trans-unit>
        <trans-unit id="5520e1fae29cfb2fdac0cb031d6697d8395de04a" translate="yes" xml:space="preserve">
          <source>Optimizer that implements the gradient descent algorithm.</source>
          <target state="translated">경사 하강 알고리즘을 구현하는 최적화 프로그램.</target>
        </trans-unit>
        <trans-unit id="a499daeedc601ee747fb3c542d345f02f8c35525" translate="yes" xml:space="preserve">
          <source>Optimizer that implements the proximal gradient descent algorithm.</source>
          <target state="translated">근위 경사 하강 알고리즘을 구현하는 최적화 프로그램.</target>
        </trans-unit>
        <trans-unit id="35756709959d376bb981bfeb576aab77c9979a59" translate="yes" xml:space="preserve">
          <source>Option Builder for Profiling API.</source>
          <target state="translated">프로파일 링 API 용 옵션 빌더.</target>
        </trans-unit>
        <trans-unit id="986cb69e5478bc33b6834663afe0c7b25ae14ce7" translate="yes" xml:space="preserve">
          <source>Optional &lt;a href=&quot;../../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; for evaluation.</source>
          <target state="translated">평가를위한 선택적 &lt;a href=&quot;../../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="41cbfe393a53582d133cd8e35ebd371a2dee49f4" translate="yes" xml:space="preserve">
          <source>Optional &lt;a href=&quot;../../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; for training.</source>
          <target state="translated">훈련을위한 선택적인 &lt;a href=&quot;../../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ce28161a073666ce7000ca9d585a27514f224cb" translate="yes" xml:space="preserve">
          <source>Optional &lt;a href=&quot;../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; for evaluation.</source>
          <target state="translated">평가를위한 선택적 &lt;a href=&quot;../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="acfde78a85ff6cc95839c0d5fe29210952e75e03" translate="yes" xml:space="preserve">
          <source>Optional &lt;a href=&quot;../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; for training.</source>
          <target state="translated">훈련을위한 선택적인 &lt;a href=&quot;../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19a4bff99e03cc997da4af3e46bde75a615c671d" translate="yes" xml:space="preserve">
          <source>Optional regularizer function for the output of this layer.</source>
          <target state="translated">이 레이어의 출력을위한 선택적 정규화 기능.</target>
        </trans-unit>
        <trans-unit id="f2523f4dd1ae30900caaf660f5bf2122a2ae1805" translate="yes" xml:space="preserve">
          <source>Optionally writes it to filename.</source>
          <target state="translated">선택적으로 파일 이름에 씁니다.</target>
        </trans-unit>
        <trans-unit id="79a83a8d22234adc2ac6cde80708fded13d8fa4c" translate="yes" xml:space="preserve">
          <source>Optionally, a normalizer function (or lambda) can be given. This will be called on every slice of data retrieved.</source>
          <target state="translated">선택적으로 노멀 라이저 기능 (또는 람다)이 제공 될 수 있습니다. 검색된 모든 데이터 조각에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e315d4a8731e77481f7905dbd6a2d484a8569ad1" translate="yes" xml:space="preserve">
          <source>Optionally, pass &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;tensor_dtype&lt;/code&gt; for shape and type checking, otherwise, these are inferred.</source>
          <target state="translated">선택적으로, &lt;code&gt;shape&lt;/code&gt; 및 &lt;code&gt;tensor_dtype&lt;/code&gt; 을 전달 하십시오. 모양 및 유형 검사를 위해 을 . 그렇지 않으면이를 추론합니다.</target>
        </trans-unit>
        <trans-unit id="678af0d4e07447d8b3a11706bc09d72ec249321b" translate="yes" xml:space="preserve">
          <source>Optionally, we allow callers to specify the task_type, and task_id, for if they want to target a specific TensorFlow process to query the number of accelerators. This is to support heterogenous environments, where the number of accelerators cores per host is different.</source>
          <target state="translated">선택적으로, 호출자가 특정 TensorFlow 프로세스를 대상으로하여 액셀러레이터 수를 쿼리하려는 경우 호출자가 task_type 및 task_id를 지정할 수 있습니다. 이는 호스트 당 가속기 코어 수가 다른 이기종 환경을 지원하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="475db5847691eb104de650ad05e4ac951995b1b3" translate="yes" xml:space="preserve">
          <source>Options for saving to SavedModel.</source>
          <target state="translated">SavedModel에 저장하기위한 옵션.</target>
        </trans-unit>
        <trans-unit id="d6427e4a463bcd04628d0ada2e0ec954a0ba2342" translate="yes" xml:space="preserve">
          <source>Options only effect TFRecordWriter when compression_type is not &lt;code&gt;None&lt;/code&gt;. Documentation, details, and defaults can be found in &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/lib/io/zlib_compression_options.h&quot;&gt;&lt;code&gt;zlib_compression_options.h&lt;/code&gt;&lt;/a&gt; and in the &lt;a href=&quot;http://www.zlib.net/manual.html&quot;&gt;zlib manual&lt;/a&gt;. Leaving an option as &lt;code&gt;None&lt;/code&gt; allows C++ to set a reasonable default.</source>
          <target state="translated">compression_type이 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우에만 옵션이 TFRecordWriter에 영향을줍니다 . 문서, 세부 사항 및 기본값은 &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/lib/io/zlib_compression_options.h&quot;&gt; &lt;code&gt;zlib_compression_options.h&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;http://www.zlib.net/manual.html&quot;&gt;zlib 매뉴얼&lt;/a&gt; 에서 찾을 수 있습니다 . 옵션을 &lt;code&gt;None&lt;/code&gt; 으로두면 C ++에서 적절한 기본값을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="537a0f6820a26091ed01e538358ddfb82e2f72a0" translate="yes" xml:space="preserve">
          <source>Options used for manipulating TFRecord files.</source>
          <target state="translated">TFRecord 파일 조작에 사용되는 옵션.</target>
        </trans-unit>
        <trans-unit id="db88aa6cb830fd3b062fef700be66ff819b6332a" translate="yes" xml:space="preserve">
          <source>Options used to profile float operations.</source>
          <target state="translated">부동 작업을 프로파일 링하는 데 사용되는 옵션.</target>
        </trans-unit>
        <trans-unit id="88887a79cbe617f9d5a3829c12afd3898d12b713" translate="yes" xml:space="preserve">
          <source>Options used to profile trainable variable parameters.</source>
          <target state="translated">학습 가능한 변수 매개 변수를 프로파일 링하는 데 사용되는 옵션.</target>
        </trans-unit>
        <trans-unit id="539bf8f885a2d4fa90c73bd6a7df14928d2a7f4b" translate="yes" xml:space="preserve">
          <source>Opts out of control flow v2.</source>
          <target state="translated">제어 흐름 v2를 선택 해제합니다.</target>
        </trans-unit>
        <trans-unit id="165798a51709f0e015f12bc0c42a8e24fd5dc6b7" translate="yes" xml:space="preserve">
          <source>Opts out of resource variables. (deprecated)</source>
          <target state="translated">자원 변수를 선택 해제합니다. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="9d2b9dcda3fb7156d6c1d877823195de211ade0a" translate="yes" xml:space="preserve">
          <source>Or, to remove specific size 1 dimensions:</source>
          <target state="translated">또는 특정 크기 1 치수를 제거하려면</target>
        </trans-unit>
        <trans-unit id="8e2451f0a5ee58ed76a81d985febb2e7cfdd99e6" translate="yes" xml:space="preserve">
          <source>Order the displayed profiler nodes based on a attribute.</source>
          <target state="translated">속성에 따라 표시된 프로파일 러 노드를 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="5fb529f0be8e20697731cd92c7b05bd097c0330b" translate="yes" xml:space="preserve">
          <source>Original paper: Wang, Zhou, Eero P. Simoncelli, and Alan C. Bovik. &quot;Multiscale structural similarity for image quality assessment.&quot; Signals, Systems and Computers, 2004.</source>
          <target state="translated">원본 : Wang, Zhou, Eero P. Simoncelli 및 Alan C. Bovik. &quot;이미지 품질 평가를위한 멀티 스케일 구조적 유사성.&quot; 신호, 시스템 및 컴퓨터, 2004.</target>
        </trans-unit>
        <trans-unit id="a78dd6a466e9fed6c3876adb70733c880a1ba7ec" translate="yes" xml:space="preserve">
          <source>Other Members</source>
          <target state="translated">다른 멤버들</target>
        </trans-unit>
        <trans-unit id="3192178575369721530aa9b513196932a2f2a179" translate="yes" xml:space="preserve">
          <source>Other arguments are not automatically casted for technical reasons, but this may change in a future minor release.</source>
          <target state="translated">다른 인수는 기술적 인 이유로 자동으로 전송되지는 않지만 향후 부 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ac3c9882a4b70189ad1bfa57e91f5a096b4d423" translate="yes" xml:space="preserve">
          <source>Other examples:</source>
          <target state="translated">다른 예 :</target>
        </trans-unit>
        <trans-unit id="a2b5c9541b97f831cc7ec96bc421fb3a1a503aa5" translate="yes" xml:space="preserve">
          <source>Otherwise a different dropout mask is applied at every time step.</source>
          <target state="translated">그렇지 않으면 매번 단계마다 다른 드롭 아웃 마스크가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a6a78864c03b57baa86e466bc1a8d4775d590fa" translate="yes" xml:space="preserve">
          <source>Otherwise this returns &lt;code&gt;fn(var, *args, **kwargs)&lt;/code&gt; colocated with &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면이 반환 &lt;code&gt;fn(var, *args, **kwargs)&lt;/code&gt; 함께 코 로케이션 &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d9bc18b21194155ea10d0ea79b6439d4c3e5a90" translate="yes" xml:space="preserve">
          <source>Otherwise,</source>
          <target state="translated">Otherwise,</target>
        </trans-unit>
        <trans-unit id="02f8d11c15aabd8b03db9f57d0e803f0b0478037" translate="yes" xml:space="preserve">
          <source>Otherwise, &quot;shape&quot; specifies the tensor's shape and the numpy array can not have more elements than what &quot;shape&quot; specifies.</source>
          <target state="translated">그렇지 않으면 &quot;shape&quot;는 텐서의 모양을 지정하고 numpy 배열은 &quot;shape&quot;가 지정한 것보다 많은 요소를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="62151ece22467a47c21e3b9ba26d5c77182e9559" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;M&lt;/code&gt; is treated as the number of diagonals for the matrix in the same batch (&lt;code&gt;M = k[1]-k[0]+1&lt;/code&gt;), and the output tensor is:</source>
          <target state="translated">그렇지 않으면, &lt;code&gt;M&lt;/code&gt; 은 동일한 배치 ( &lt;code&gt;M = k[1]-k[0]+1&lt;/code&gt; ) 에서 행렬의 대각선 수로 처리되며 출력 텐서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f310e5b730b8c6280abb76989919bbfc78fc51eb" translate="yes" xml:space="preserve">
          <source>Otherwise, if you are implementing a ClusterResolver that will only work in open-source TensorFlow, you do not need to implement this property.</source>
          <target state="translated">그렇지 않으면 오픈 소스 TensorFlow에서만 작동하는 ClusterResolver를 구현하는 경우이 특성을 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="efd8f73f99ac3ecf188709c3043d9fc7417ddd48" translate="yes" xml:space="preserve">
          <source>Otherwise, it follows: &lt;code&gt;f(x) = max_value&lt;/code&gt; for &lt;code&gt;x &amp;gt;= max_value&lt;/code&gt;, &lt;code&gt;f(x) = x&lt;/code&gt; for &lt;code&gt;threshold &amp;lt;= x &amp;lt; max_value&lt;/code&gt;, &lt;code&gt;f(x) = alpha * (x - threshold)&lt;/code&gt; otherwise.</source>
          <target state="translated">그렇지 않으면, 그것은 다음과 같다 : &lt;code&gt;f(x) = max_value&lt;/code&gt; 대한 &lt;code&gt;x &amp;gt;= max_value&lt;/code&gt; , &lt;code&gt;f(x) = x&lt;/code&gt; 에 대한 &lt;code&gt;threshold &amp;lt;= x &amp;lt; max_value&lt;/code&gt; , &lt;code&gt;f(x) = alpha * (x - threshold)&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="b4bbb0712712167bd33af5b3a5891d4689d133b2" translate="yes" xml:space="preserve">
          <source>Otherwise, it follows: &lt;code&gt;f(x) = max_value&lt;/code&gt; for &lt;code&gt;x &amp;gt;= max_value&lt;/code&gt;, &lt;code&gt;f(x) = x&lt;/code&gt; for &lt;code&gt;threshold &amp;lt;= x &amp;lt; max_value&lt;/code&gt;, &lt;code&gt;f(x) = negative_slope * (x - threshold)&lt;/code&gt; otherwise.</source>
          <target state="translated">그렇지 않으면, 그것은 다음과 같다 : &lt;code&gt;f(x) = max_value&lt;/code&gt; 대한 &lt;code&gt;x &amp;gt;= max_value&lt;/code&gt; , &lt;code&gt;f(x) = x&lt;/code&gt; 에 대한 &lt;code&gt;threshold &amp;lt;= x &amp;lt; max_value&lt;/code&gt; , &lt;code&gt;f(x) = negative_slope * (x - threshold)&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="8e7aacaffe75d2dbbbcd7f460de5f4fe2952e78a" translate="yes" xml:space="preserve">
          <source>Otherwise, it returns:</source>
          <target state="translated">그렇지 않으면 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ed51b1936fa692ecd8ba4a4eac38810299ce713c" translate="yes" xml:space="preserve">
          <source>Otherwise, the output tensor has rank &lt;code&gt;r&lt;/code&gt; with dimensions &lt;code&gt;[I, J, ..., L, num_diags, max_diag_len]&lt;/code&gt; with values:</source>
          <target state="translated">그렇지 않으면 출력 텐서의 값이 다음 과 같은 차원 &lt;code&gt;[I, J, ..., L, num_diags, max_diag_len]&lt;/code&gt; 순위 &lt;code&gt;r&lt;/code&gt; 을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="43c5911c1215d5cf93a298642e054ee904b2b5c1" translate="yes" xml:space="preserve">
          <source>Otherwise, use &lt;a href=&quot;strategy#scope&quot;&gt;&lt;code&gt;tf.distribute.Strategy.scope&lt;/code&gt;&lt;/a&gt; to specify that a strategy should be used when building an executing your model. (This puts you in the &quot;cross-replica context&quot; for this strategy, which means the strategy is put in control of things like variable placement.)</source>
          <target state="translated">그렇지 않으면 &lt;a href=&quot;strategy#scope&quot;&gt; &lt;code&gt;tf.distribute.Strategy.scope&lt;/code&gt; &lt;/a&gt; 를 사용하여 모델 실행을 빌드 할 때 전략을 사용 하도록 지정하십시오. (이로 인해이 전략에 대한 &quot;복제 복제 컨텍스트&quot;로 전환 할 수 있습니다. 이는 전략이 변수 배치와 같은 항목을 제어 함을 의미합니다.)</target>
        </trans-unit>
        <trans-unit id="9253e173b1bc501973e03f3abc4a14683009b6a8" translate="yes" xml:space="preserve">
          <source>Our Conv3D implements a form of cross-correlation.</source>
          <target state="translated">우리의 Conv3D는 상호 상관의 형태를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c820c1824b0d4014437c0f8234ea15ebb6a34191" translate="yes" xml:space="preserve">
          <source>Output mask tensor (potentially None) or list of output mask tensors.</source>
          <target state="translated">출력 마스크 텐서 (잠재적으로 없음) 또는 출력 마스크 텐서 목록.</target>
        </trans-unit>
        <trans-unit id="6152f9850ba1d45b5150190e0f533245bfd9605a" translate="yes" xml:space="preserve">
          <source>Output shape with &lt;code&gt;'SAME'&lt;/code&gt; padding is:</source>
          <target state="translated">&lt;code&gt;'SAME'&lt;/code&gt; 패딩을 사용한 출력 모양 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cfeda9dec84808da1f0fcb69bcd41eaa4ffe0df9" translate="yes" xml:space="preserve">
          <source>Output shape, as an integer shape tuple (or list of shape tuples, one tuple per output tensor).</source>
          <target state="translated">정수 모양 튜플 (또는 모양 튜플 목록, 출력 텐 서당 하나의 튜플)로 출력 모양.</target>
        </trans-unit>
        <trans-unit id="a9a24239108a80c9bd1ddee4d05e1d4434c62d89" translate="yes" xml:space="preserve">
          <source>Output shape:</source>
          <target state="translated">출력 형태 :</target>
        </trans-unit>
        <trans-unit id="15d6c297fac958e9c4e368c0a0d23d8b11b2bd61" translate="yes" xml:space="preserve">
          <source>Output strings (e.g. filenames) to a queue for an input pipeline. (deprecated)</source>
          <target state="translated">입력 파이프 라인의 대기열에 출력 문자열 (예 : 파일 이름). (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="2c0723dbf74f130716e7394bc11b3c2e3b26d9ff" translate="yes" xml:space="preserve">
          <source>Output tensor or list of output tensors.</source>
          <target state="translated">출력 텐서 또는 출력 텐서 목록.</target>
        </trans-unit>
        <trans-unit id="d0b2bf436e59c178c28e92f2f7de3a162823c53d" translate="yes" xml:space="preserve">
          <source>Output tensor(s).</source>
          <target state="translated">출력 텐서.</target>
        </trans-unit>
        <trans-unit id="808a4744a4b5ed84b4255cf762e6886f621ccd16" translate="yes" xml:space="preserve">
          <source>Output tensor.</source>
          <target state="translated">출력 텐서.</target>
        </trans-unit>
        <trans-unit id="b7e36ad229e03fb65f367301b05bc0bea6f36222" translate="yes" xml:space="preserve">
          <source>Output the rows of &lt;code&gt;input_tensor&lt;/code&gt; to a queue for an input pipeline. (deprecated)</source>
          <target state="translated">&lt;code&gt;input_tensor&lt;/code&gt; 의 행을 입력 파이프 라인의 큐에 출력합니다 . (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="1546fa0eff47e4dbe22051780f97b6c4a3c0f5b4" translate="yes" xml:space="preserve">
          <source>Output values as Numpy arrays.</source>
          <target state="translated">Numpy 배열로 값을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="aa498304d34c3c806042d023d0f6d381286ae0e9" translate="yes" xml:space="preserve">
          <source>Output will always be a list of tensors (potentially with 1 element).</source>
          <target state="translated">출력은 항상 텐서 목록입니다 (잠재적으로 1 요소 포함).</target>
        </trans-unit>
        <trans-unit id="459a4a6e69d232c86f9d33da550acb7bea4f199d" translate="yes" xml:space="preserve">
          <source>Output will be in the format of a flagfile.</source>
          <target state="translated">출력은 플래그 파일 형식입니다.</target>
        </trans-unit>
        <trans-unit id="84b894c5485df582ef7b778f6dd5481f19428c49" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;Summary&lt;/code&gt; protocol buffer containing a single scalar value.</source>
          <target state="translated">단일 스칼라 값을 포함 하는 &lt;code&gt;Summary&lt;/code&gt; 프로토콜 버퍼를 출력 합니다.</target>
        </trans-unit>
        <trans-unit id="9b4c117216a88cdb391e417cac827622c9e8ad4a" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;Summary&lt;/code&gt; protocol buffer with a histogram.</source>
          <target state="translated">히스토그램과 함께 &lt;code&gt;Summary&lt;/code&gt; 프로토콜 버퍼를 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="258b999b9895710d3f0c5d94be3215526bce5220" translate="yes" xml:space="preserve">
          <source>Outputs a &lt;code&gt;Summary&lt;/code&gt; protocol buffer with a serialized tensor.proto.</source>
          <target state="translated">직렬화 된 tensor.proto와 함께 &lt;code&gt;Summary&lt;/code&gt; 프로토콜 버퍼를 출력합니다 .</target>
        </trans-unit>
        <trans-unit id="5111142ad4bfa812cc22dc0ff4124c2a320ccb18" translate="yes" xml:space="preserve">
          <source>Outputs a copy of &lt;code&gt;images&lt;/code&gt; but draws on top of the pixels zero or more bounding boxes specified by the locations in &lt;code&gt;boxes&lt;/code&gt;. The coordinates of the each bounding box in &lt;code&gt;boxes&lt;/code&gt; are encoded as &lt;code&gt;[y_min, x_min, y_max, x_max]&lt;/code&gt;. The bounding box coordinates are floats in &lt;code&gt;[0.0, 1.0]&lt;/code&gt; relative to the width and height of the underlying image.</source>
          <target state="translated">의 사본 출력 &lt;code&gt;images&lt;/code&gt; 픽셀이 0 개 이상의 위치로 지정 상자 경계의하지만 위에 그립니다 &lt;code&gt;boxes&lt;/code&gt; . 각각의 경계 박스 좌표 &lt;code&gt;boxes&lt;/code&gt; 로 인코딩된다 &lt;code&gt;[y_min, x_min, y_max, x_max]&lt;/code&gt; . 경계 상자 좌표는 기본 이미지의 너비와 높이를 기준으로 &lt;code&gt;[0.0, 1.0]&lt;/code&gt; 으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="668631f3912c1e18efb54a7b560cc5d45ae6ec89" translate="yes" xml:space="preserve">
          <source>Outputs a tensor of the same &lt;code&gt;DType&lt;/code&gt; and rank as &lt;code&gt;images&lt;/code&gt;. The size of the last dimension of the output is 1, containing the Grayscale value of the pixels.</source>
          <target state="translated">상기와 동일한의 텐서 출력 &lt;code&gt;DType&lt;/code&gt; 으로하고 순위 &lt;code&gt;images&lt;/code&gt; . 출력의 마지막 차원의 크기는 1이며 픽셀의 회색조 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9bbebc3e5d5bcfded00e308c104f362ca49571b5" translate="yes" xml:space="preserve">
          <source>Outputs a tensor of the same &lt;code&gt;DType&lt;/code&gt; and rank as &lt;code&gt;images&lt;/code&gt;. The size of the last dimension of the output is 3, containing the RGB value of the pixels. The input images' last dimension must be size 1.</source>
          <target state="translated">상기와 동일한의 텐서 출력 &lt;code&gt;DType&lt;/code&gt; 으로하고 순위 &lt;code&gt;images&lt;/code&gt; . 출력의 마지막 차원의 크기는 3이며 픽셀의 RGB 값을 포함합니다. 입력 이미지의 마지막 치수는 크기 1이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c83fa41c7e40559f06112bd0323a249317a8dd6d" translate="yes" xml:space="preserve">
          <source>Outputs a tensor of the same shape as the &lt;code&gt;images&lt;/code&gt; tensor, containing the HSV value of the pixels. The output is only well defined if the value in &lt;code&gt;images&lt;/code&gt; are in &lt;code&gt;[0,1]&lt;/code&gt;.</source>
          <target state="translated">픽셀의 HSV 값을 포함하는 &lt;code&gt;images&lt;/code&gt; 텐서 와 동일한 모양의 텐서를 출력합니다 . &lt;code&gt;images&lt;/code&gt; 의 값 이 &lt;code&gt;[0,1]&lt;/code&gt; 에 있는 경우에만 출력이 잘 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="1cf5a3618984c2e07b3526444a772b72864c1227" translate="yes" xml:space="preserve">
          <source>Outputs a tensor of the same shape as the &lt;code&gt;images&lt;/code&gt; tensor, containing the RGB value of the pixels. The output is only well defined if the Y value in images are in [0,1], I value are in [-0.5957,0.5957] and Q value are in [-0.5226,0.5226].</source>
          <target state="translated">&lt;code&gt;images&lt;/code&gt; 와 같은 모양의 텐서를 출력합니다픽셀의 RGB 값을 포함하는 텐서 . 이미지의 Y 값이 [0,1]에 있고 I 값이 [-0.5957,0.5957]에 있고 Q 값이 [-0.5226,0.5226]에있는 경우에만 출력이 잘 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a86130d45595c9097071a1ba766b25f42cf3ef42" translate="yes" xml:space="preserve">
          <source>Outputs a tensor of the same shape as the &lt;code&gt;images&lt;/code&gt; tensor, containing the RGB value of the pixels. The output is only well defined if the Y value in images are in [0,1], U and V value are in [-0.5,0.5].</source>
          <target state="translated">픽셀의 RGB 값을 포함하는 &lt;code&gt;images&lt;/code&gt; 텐서 와 동일한 모양의 텐서를 출력합니다 . 이미지의 Y 값이 [0,1]에 있고 U 및 V 값이 [-0.5,0.5]에있는 경우에만 출력이 잘 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="76981549c7fec641d47750067ffb241e70ad0171" translate="yes" xml:space="preserve">
          <source>Outputs a tensor of the same shape as the &lt;code&gt;images&lt;/code&gt; tensor, containing the RGB value of the pixels. The output is only well defined if the value in &lt;code&gt;images&lt;/code&gt; are in &lt;code&gt;[0,1]&lt;/code&gt;.</source>
          <target state="translated">픽셀의 RGB 값을 포함하는 &lt;code&gt;images&lt;/code&gt; 텐서 와 동일한 모양의 텐서를 출력합니다 . &lt;code&gt;images&lt;/code&gt; 의 값 이 &lt;code&gt;[0,1]&lt;/code&gt; 에 있는 경우에만 출력이 잘 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="08581f37980a3d062bc9f295a7cfcac5d210fb61" translate="yes" xml:space="preserve">
          <source>Outputs a tensor of the same shape as the &lt;code&gt;images&lt;/code&gt; tensor, containing the YIQ value of the pixels. The output is only well defined if the value in images are in [0,1].</source>
          <target state="translated">픽셀의 YIQ 값을 포함하는 &lt;code&gt;images&lt;/code&gt; 텐서 와 동일한 모양의 텐서를 출력합니다 . 이미지의 값이 [0,1]에있는 경우에만 출력이 잘 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="4a4442350e397cbcce7054ea2ac6fd02fe315af9" translate="yes" xml:space="preserve">
          <source>Outputs a tensor of the same shape as the &lt;code&gt;images&lt;/code&gt; tensor, containing the YUV value of the pixels. The output is only well defined if the value in images are in [0,1].</source>
          <target state="translated">픽셀의 YUV 값을 포함하는 &lt;code&gt;images&lt;/code&gt; 텐서 와 동일한 모양의 텐서를 출력합니다 . 이미지의 값이 [0,1]에있는 경우에만 출력이 잘 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="5ade76775de4ea772e67da87c9ba5c3ece405c58" translate="yes" xml:space="preserve">
          <source>Outputs deterministic pseudorandom values from a normal distribution.</source>
          <target state="translated">정규 분포에서 결정적인 의사 난수 값을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="ee5cf5043bce3034a4a5e92e2857e44f2db9536a" translate="yes" xml:space="preserve">
          <source>Outputs deterministic pseudorandom values from a uniform distribution.</source>
          <target state="translated">균일 분포에서 결정적 의사 난수 값을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="c242af46ccb7de7ecb1298fe76f77d9bbdb78a9f" translate="yes" xml:space="preserve">
          <source>Outputs deterministic pseudorandom values, truncated normally distributed.</source>
          <target state="translated">정규 분포가 잘린 결정적 의사 난수 값을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="d0782526ab3b14806226c710829d1cb9c6f66e64" translate="yes" xml:space="preserve">
          <source>Outputs flag documentation in XML format.</source>
          <target state="translated">플래그 문서를 XML 형식으로 출력합니다.</target>
        </trans-unit>
        <trans-unit id="1fa399f632734f4b6a11e6ef1ada3a61297a9f3e" translate="yes" xml:space="preserve">
          <source>Outputs random values from a binomial distribution.</source>
          <target state="translated">이항 분포에서 임의의 값을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="ec63bf4485d414e6163c55ddc56a83296586ce72" translate="yes" xml:space="preserve">
          <source>Outputs random values from a normal distribution.</source>
          <target state="translated">정규 분포에서 임의의 값을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="084a30872a4a669f61e08fa9cbc6f3a9e6586693" translate="yes" xml:space="preserve">
          <source>Outputs random values from a truncated normal distribution.</source>
          <target state="translated">잘린 정규 분포에서 임의의 값을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="29c9347524deebd60dd0905d79aa277b84c0b951" translate="yes" xml:space="preserve">
          <source>Outputs random values from a uniform distribution.</source>
          <target state="translated">균일 분포에서 임의의 값을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="ed8c4f10852ab0e3efb30051d3c359f47a098992" translate="yes" xml:space="preserve">
          <source>Outputs repeated classes with blanks in between, but generally does not require the decoder to collapse/merge repeated classes.</source>
          <target state="translated">사이에 공백이있는 반복 클래스를 출력하지만 일반적으로 디코더가 반복 클래스를 축소 / 병합 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d31f8dc807bfc42417be1acab0b5f7fcf17bda9e" translate="yes" xml:space="preserve">
          <source>Outputs the contents of &lt;code&gt;image&lt;/code&gt; flipped along the height dimension.</source>
          <target state="translated">높이 치수를 따라 뒤집힌 &lt;code&gt;image&lt;/code&gt; 의 내용을 출력 합니다.</target>
        </trans-unit>
        <trans-unit id="b10c32ab16c8b48433a818f323677463605a5aa8" translate="yes" xml:space="preserve">
          <source>Outputs the contents of &lt;code&gt;image&lt;/code&gt; flipped along the width dimension.</source>
          <target state="translated">폭 치수를 따라 뒤집힌 &lt;code&gt;image&lt;/code&gt; 의 내용을 출력 합니다.</target>
        </trans-unit>
        <trans-unit id="952c97f90f049f06bcef60e45f9e85e97d71d218" translate="yes" xml:space="preserve">
          <source>Outside compilation should be called inside TPUReplicateContext. That is, &lt;code&gt;tf.tpu.outside_compilation()&lt;/code&gt; should be called inside a function that is passed to &lt;code&gt;tpu.split_compile_and_replicate()&lt;/code&gt; -- this is implied when outside compilation is invoked inside a function passed to TPUStrategy &lt;code&gt;experimental_run_v2()&lt;/code&gt;. If invoked outside of TPUReplicateContext, then this simply returns the result of &lt;code&gt;computation&lt;/code&gt;, and therefore, would be a no-op. Note that outside compilation is different from &lt;code&gt;tf.distribute.experimental.TPUStrategy.merge_call()&lt;/code&gt; as logic in outside compilation is replicated and executed separately for each replica. On the other hand, &lt;code&gt;merge_call()&lt;/code&gt; requires a &lt;code&gt;merge_fn&lt;/code&gt; to aggregate the inputs from different replicas and is executed only once.</source>
          <target state="translated">외부 컴파일은 TPUReplicateContext 내에서 호출해야합니다. 즉, &lt;code&gt;tf.tpu.outside_compilation()&lt;/code&gt; 에 전달되는 함수 내에서 호출해야 &lt;code&gt;tpu.split_compile_and_replicate()&lt;/code&gt; 외부 컴파일이 TPUStrategy의 전달 함수 내에서 호출 될 때이 암시 - &lt;code&gt;experimental_run_v2()&lt;/code&gt; . TPUReplicateContext 외부에서 호출 된 경우 단순히 &lt;code&gt;computation&lt;/code&gt; 결과를 리턴 하므로 작동하지 않습니다. 외부 컴파일의 논리가 각 복제본에 대해 개별적으로 복제되고 실행 &lt;code&gt;tf.distribute.experimental.TPUStrategy.merge_call()&lt;/code&gt; 외부 컴파일은 tf.distribute.experimental.TPUStrategy.merge_call () 과 다릅니다 . 반면에 &lt;code&gt;merge_call()&lt;/code&gt; 에는 &lt;code&gt;merge_fn&lt;/code&gt; 이 다른 복제본의 입력을 집계하고 한 번만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f984bbbabec17bab87670ed4d910a963c7d9cb28" translate="yes" xml:space="preserve">
          <source>Overfit and underfit</source>
          <target state="translated">과적 및 과적</target>
        </trans-unit>
        <trans-unit id="1b7c4b73b4e282fd39fe2dd1699c7021d30f7bbd" translate="yes" xml:space="preserve">
          <source>Overfitting: In order to avoid overfitting, it is recommended to set up the training &lt;code&gt;input_fn&lt;/code&gt; to shuffle the training data properly.</source>
          <target state="translated">과적 합 : 과적 합을 피하기 위해 훈련 데이터를 올바르게 섞을 수 있도록 훈련 &lt;code&gt;input_fn&lt;/code&gt; 을 설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ea7ebe71f80c18db8c5c627b2e3cfbe5beb8d34a" translate="yes" xml:space="preserve">
          <source>Overload for Tensor.&lt;strong&gt;getitem&lt;/strong&gt;.</source>
          <target state="translated">텐서 과부하. &lt;strong&gt;getitem&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="17ea8d1c1a13e516f7e8377406d02ac177af6484" translate="yes" xml:space="preserve">
          <source>Overrides the default adapt method to apply relevant preprocessing to the inputs before passing to the combiner.</source>
          <target state="translated">결합기에 전달하기 전에 입력에 관련 전처리를 적용하기 위해 기본 적응 방법을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="97c1ec3f4fd62592a53aa7f7d5c4006a5e2ce820" translate="yes" xml:space="preserve">
          <source>Overrides the shape for this variable.</source>
          <target state="translated">이 변수의 모양을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="c86ec867fff8ca5a27c91bfd42d1d98a0348f32d" translate="yes" xml:space="preserve">
          <source>Overriding this method is useful for subclass implementers.</source>
          <target state="translated">이 메소드를 재정의하면 서브 클래스 구현 자에게 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3f78a8b4cc13847389684d2c79251ec53e2ab06f" translate="yes" xml:space="preserve">
          <source>P represents a permutation matrix encoded as a list of indices each between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;M-1&lt;/code&gt;, inclusive. If P_mat denotes the permutation matrix corresponding to P, then the L, U and P satisfies P_mat * input = L * U.</source>
          <target state="translated">P는 각각 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;M-1&lt;/code&gt; 사이의 인덱스리스트로서 인코딩 된 순열 행렬을 나타낸다 . P_mat가 P에 대응하는 순열 행렬을 나타내면, L, U 및 P는 P_mat * 입력 = L * U를 만족시킨다.</target>
        </trans-unit>
        <trans-unit id="c603b603525a10df94e64bf31dbd3b4775811230" translate="yes" xml:space="preserve">
          <source>PNG-encode an image.</source>
          <target state="translated">이미지를 PNG로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="b3d47c033aba2ba1bed06450f77faeca66c2e765" translate="yes" xml:space="preserve">
          <source>Packs the list of tensors in &lt;code&gt;values&lt;/code&gt; into a tensor with rank one higher than each tensor in &lt;code&gt;values&lt;/code&gt;, by packing them along the &lt;code&gt;axis&lt;/code&gt; dimension. Given a list of length &lt;code&gt;N&lt;/code&gt; of tensors of shape &lt;code&gt;(A, B, C)&lt;/code&gt;;</source>
          <target state="translated">에서 텐서의리스트 팩 &lt;code&gt;values&lt;/code&gt; 순위에있는 각 텐서보다 하나 텐서에 &lt;code&gt;values&lt;/code&gt; 그들을 따라 포장하여 &lt;code&gt;axis&lt;/code&gt; 차원. 모양의 텐서 의 길이 &lt;code&gt;N&lt;/code&gt; 의 목록이 주어짐 &lt;code&gt;(A, B, C)&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="a61ebffec3ca5fb2b53ada1239c3d86c9bdd765a" translate="yes" xml:space="preserve">
          <source>Packs the list of tensors in &lt;code&gt;values&lt;/code&gt; into a tensor with rank one higher than each tensor in &lt;code&gt;values&lt;/code&gt;, by packing them along the first dimension. Given a list of length &lt;code&gt;N&lt;/code&gt; of tensors of shape &lt;code&gt;(A, B, C)&lt;/code&gt;; the &lt;code&gt;output&lt;/code&gt; tensor will have the shape &lt;code&gt;(N, A, B, C)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;values&lt;/code&gt; 의 텐서 목록을 첫 번째 차원을 따라 포장하여 &lt;code&gt;values&lt;/code&gt; 각 텐서보다 순위가 하나 높은 텐서로 묶습니다 . 모양의 텐서 의 길이 &lt;code&gt;N&lt;/code&gt; 의 목록이 주어짐 &lt;code&gt;(A, B, C)&lt;/code&gt; ; &lt;code&gt;output&lt;/code&gt; 텐서 형상 것이다 &lt;code&gt;(N, A, B, C)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b257bafbec1e6343fa42eac77dd3d7927c7bf57" translate="yes" xml:space="preserve">
          <source>Pad &lt;code&gt;image&lt;/code&gt; with zeros to the specified &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt;.</source>
          <target state="translated">패드 &lt;code&gt;image&lt;/code&gt; 지정된으로 제로와 &lt;code&gt;height&lt;/code&gt; 및 &lt;code&gt;width&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7c0215689fd7570e4013317a0b324f327a6c8b1" translate="yes" xml:space="preserve">
          <source>Pads 5D tensor with zeros along the depth, height, width dimensions.</source>
          <target state="translated">깊이, 높이, 너비 치수를 따라 0으로 채워진 5D 텐서를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="eca900e368882080d8b473fb9393c92e6b238c49" translate="yes" xml:space="preserve">
          <source>Pads a tensor.</source>
          <target state="translated">텐서를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="19c65569df0e485569bf7277ede4caaff2076749" translate="yes" xml:space="preserve">
          <source>Pads sequences to the same length.</source>
          <target state="translated">시퀀스를 같은 길이로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="03cc9b9ff08d605c15c34962c8fb96e90a0cbe94" translate="yes" xml:space="preserve">
          <source>Pads the 2nd and 3rd dimensions of a 4D tensor.</source>
          <target state="translated">4D 텐서의 2 차원 및 3 차원을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="30451e45a445c353da9d8976e896a8a73d46ebaf" translate="yes" xml:space="preserve">
          <source>Pads the middle dimension of a 3D tensor.</source>
          <target state="translated">3D 텐서의 중간 치수를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="cafe015cea917810504183c3f3755e2923bdd163" translate="yes" xml:space="preserve">
          <source>Pads these dimensions with respectively &quot;padding[0]&quot;, &quot;padding[1]&quot; and &quot;padding[2]&quot; zeros left and right.</source>
          <target state="translated">이 치수를 각각 &quot;padding [0]&quot;, &quot;padding [1]&quot;및 &quot;padding [2]&quot;로 좌우로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="ba2033addf18e9b79fd595d2cb00b981d51d008e" translate="yes" xml:space="preserve">
          <source>Pair of tensors (dy, dx) holding the vertical and horizontal image gradients (1-step finite difference).</source>
          <target state="translated">수직 및 수평 이미지 그라디언트를 유지하는 텐서 쌍 (dy, dx) (1 단계 유한 차분).</target>
        </trans-unit>
        <trans-unit id="0a77bea52ee03ba3cf375e16d331dffd31ba0563" translate="yes" xml:space="preserve">
          <source>Parallel map on the list of tensors unpacked from &lt;code&gt;elems&lt;/code&gt; on dimension 0.</source>
          <target state="translated">텐서의 목록에 병렬지도에서 압축 해제 &lt;code&gt;elems&lt;/code&gt; 차원 0에.</target>
        </trans-unit>
        <trans-unit id="def8ac8326c736c1762fb8107a7ba5fa4a8345ed" translate="yes" xml:space="preserve">
          <source>Parameter values leading to undefined statistics or distributions.</source>
          <target state="translated">통계 또는 분포가 정의되지 않은 모수 값.</target>
        </trans-unit>
        <trans-unit id="7df541106a23472877991b6b4fb89f0ad11c8df3" translate="yes" xml:space="preserve">
          <source>Parametric Rectified Linear Unit.</source>
          <target state="translated">파라 메트릭 정류 선형 단위.</target>
        </trans-unit>
        <trans-unit id="acacbd25ff73eb4b8950645091b1a2fb7531ed14" translate="yes" xml:space="preserve">
          <source>Parse a &lt;code&gt;DeviceSpec&lt;/code&gt; name into its components.</source>
          <target state="translated">&lt;code&gt;DeviceSpec&lt;/code&gt; 이름을 해당 구성 요소로 구문 분석하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a354f5ed898ef75d52f25eb44e9c6a2dbdd061a" translate="yes" xml:space="preserve">
          <source>Parsed value may be bounded to a given upper and lower bound.</source>
          <target state="translated">파싱 ​​된 값은 주어진 상한 및 하한으로 제한 될 수있다.</target>
        </trans-unit>
        <trans-unit id="55bb920dde4c75e60fb727b68b525c47e1e314d5" translate="yes" xml:space="preserve">
          <source>Parser for a comma-separated list of strings.</source>
          <target state="translated">쉼표로 구분 된 문자열 목록의 구문 분석기입니다.</target>
        </trans-unit>
        <trans-unit id="8da293265a711dbab137d5900f207fa1f2d4d6c8" translate="yes" xml:space="preserve">
          <source>Parser for a whitespace-separated list of strings.</source>
          <target state="translated">공백으로 구분 된 문자열 목록을위한 파서입니다.</target>
        </trans-unit>
        <trans-unit id="f4ec27b2b8218acc5e8fb47368c0311def655e7f" translate="yes" xml:space="preserve">
          <source>Parser of a string enum value (a string value from a given set).</source>
          <target state="translated">문자열 열거 형 값의 파서 (주어진 세트의 문자열 값)</target>
        </trans-unit>
        <trans-unit id="666f2db27697481c5144debd0528eb62c4c27fc6" translate="yes" xml:space="preserve">
          <source>Parser of an Enum class member.</source>
          <target state="translated">Enum 클래스 멤버의 파서</target>
        </trans-unit>
        <trans-unit id="23705e4b83ef8e598c6f5d87bc4d13b00d034fb9" translate="yes" xml:space="preserve">
          <source>Parser of an integer value.</source>
          <target state="translated">정수 값의 파서.</target>
        </trans-unit>
        <trans-unit id="e93d461060844d7f5b00135bcee9acbd4bf75bb4" translate="yes" xml:space="preserve">
          <source>Parser of boolean values.</source>
          <target state="translated">부울 값의 파서.</target>
        </trans-unit>
        <trans-unit id="e7abdbfdc94770405fe4a29279585fae4ba29a00" translate="yes" xml:space="preserve">
          <source>Parser of floating point values.</source>
          <target state="translated">부동 소수점 값 파서</target>
        </trans-unit>
        <trans-unit id="7454c741c41841ce88a39e24df061717106e7a7c" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;Example&lt;/code&gt; protos into a &lt;code&gt;dict&lt;/code&gt; of tensors.</source>
          <target state="translated">&lt;code&gt;Example&lt;/code&gt; pros를 텐서 의 &lt;code&gt;dict&lt;/code&gt; 로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="382edcba1a256d62e4e05248add77639491bdee5" translate="yes" xml:space="preserve">
          <source>Parses a JSON model configuration file and returns a model instance.</source>
          <target state="translated">JSON 모델 구성 파일을 구문 분석하고 모델 인스턴스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4ba700383a7d3f81a5dc6695953faae04cf01309" translate="yes" xml:space="preserve">
          <source>Parses a JSON tokenizer configuration file and returns a</source>
          <target state="translated">JSON 토크 나이저 구성 파일을 구문 분석하고</target>
        </trans-unit>
        <trans-unit id="05becb678d41db332eabbaf7d7db7a0cc0aff9e0" translate="yes" xml:space="preserve">
          <source>Parses a batch of &lt;code&gt;SequenceExample&lt;/code&gt; protos.</source>
          <target state="translated">일련의 &lt;code&gt;SequenceExample&lt;/code&gt; 프로토 타입을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="89639b79103f59776ee71d8eae1479be068714f3" translate="yes" xml:space="preserve">
          <source>Parses a number of serialized &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/example/example.proto&quot;&gt;&lt;code&gt;Example&lt;/code&gt;&lt;/a&gt; protos given in &lt;code&gt;serialized&lt;/code&gt;. We refer to &lt;code&gt;serialized&lt;/code&gt; as a batch with &lt;code&gt;batch_size&lt;/code&gt; many entries of individual &lt;code&gt;Example&lt;/code&gt; protos.</source>
          <target state="translated">연재의 숫자 구문 분석 &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/example/example.proto&quot;&gt; &lt;code&gt;Example&lt;/code&gt; &lt;/a&gt; 에서 주어진 PROTOS &lt;code&gt;serialized&lt;/code&gt; . 개별 &lt;code&gt;Example&lt;/code&gt; 프로토 의 여러 항목이 &lt;code&gt;batch_size&lt;/code&gt; 인 배치 로 &lt;code&gt;serialized&lt;/code&gt; 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0fe6a74d0c057cd81def9f1d072d1cf8df8de1cd" translate="yes" xml:space="preserve">
          <source>Parses a number of serialized &lt;code&gt;Example&lt;/code&gt; protos given in &lt;code&gt;serialized&lt;/code&gt;. We refer to &lt;code&gt;serialized&lt;/code&gt; as a batch with &lt;code&gt;batch_size&lt;/code&gt; many entries of individual &lt;code&gt;Example&lt;/code&gt; protos.</source>
          <target state="translated">연재의 숫자 구문 분석 &lt;code&gt;Example&lt;/code&gt; 에서 주어진 PROTOS &lt;code&gt;serialized&lt;/code&gt; . 개별 &lt;code&gt;Example&lt;/code&gt; 프로토 의 여러 항목이 &lt;code&gt;batch_size&lt;/code&gt; 인 배치 로 &lt;code&gt;serialized&lt;/code&gt; 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="124043c4b5d010f3d3724d6013100c09250d0e93" translate="yes" xml:space="preserve">
          <source>Parses a single &lt;code&gt;Example&lt;/code&gt; proto.</source>
          <target state="translated">단일 &lt;code&gt;Example&lt;/code&gt; 프로토콜을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="992f064cb3093b3ca55d617bcdf6d7d74ea4aeee" translate="yes" xml:space="preserve">
          <source>Parses a single &lt;code&gt;SequenceExample&lt;/code&gt; proto.</source>
          <target state="translated">단일 &lt;code&gt;SequenceExample&lt;/code&gt; 프로토콜을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="018707eb7364c89d5fc13d1b7c5516ba266195af" translate="yes" xml:space="preserve">
          <source>Parses a single serialized &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/example/example.proto&quot;&gt;&lt;code&gt;SequenceExample&lt;/code&gt;&lt;/a&gt; proto given in &lt;code&gt;serialized&lt;/code&gt;.</source>
          <target state="translated">하나의 직렬화 된 구문 분석 &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/example/example.proto&quot;&gt; &lt;code&gt;SequenceExample&lt;/code&gt; 의&lt;/a&gt; 주어진 프로토 &lt;code&gt;serialized&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ea007a196bc26f930d784bb7afa3d70de1dddf9" translate="yes" xml:space="preserve">
          <source>Parses a vector of serialized &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/example/example.proto&quot;&gt;&lt;code&gt;SequenceExample&lt;/code&gt;&lt;/a&gt; protos given in &lt;code&gt;serialized&lt;/code&gt;.</source>
          <target state="translated">연재의 벡터 구문 분석 &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/example/example.proto&quot;&gt; &lt;code&gt;SequenceExample&lt;/code&gt; 의&lt;/a&gt; 주어진 PROTOS &lt;code&gt;serialized&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7f97a8d5b44b861cb188ab43b29050c98a85c0b" translate="yes" xml:space="preserve">
          <source>Parses a yaml model configuration file and returns a model instance.</source>
          <target state="translated">yaml 모델 구성 파일을 구문 분석하고 모델 인스턴스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9ea18454c03169edeecc171cf8161677a428da1d" translate="yes" xml:space="preserve">
          <source>Parses argument as comma-separated list of strings.</source>
          <target state="translated">인수를 쉼표로 구분 된 문자열 목록으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="4ef7ad1b3cbe943f2f294bbe16f4212b11883827" translate="yes" xml:space="preserve">
          <source>Parses argument as whitespace-separated list of strings.</source>
          <target state="translated">인수를 공백으로 구분 된 문자열 목록으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="a203d9b850783ae30a3b6868f86b8cb6b9fe84a1" translate="yes" xml:space="preserve">
          <source>Parses flags from argv; stores parsed flags into this FlagValues object.</source>
          <target state="translated">argv에서 플래그를 구문 분석합니다. 구문 분석 된 플래그를이 FlagValues ​​객체에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="9ebb16a61dcc07727d0bb5210c58744c98d0ce86" translate="yes" xml:space="preserve">
          <source>Parses one or more arguments with the installed parser.</source>
          <target state="translated">설치된 파서를 사용하여 하나 이상의 인수를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="ec314dc834d23af5860312b604879d2394ea5a5c" translate="yes" xml:space="preserve">
          <source>Parses string and sets flag value.</source>
          <target state="translated">문자열을 구문 분석하고 플래그 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b0c567f1070a0f35eb961bbbf3292e62eca12cd9" translate="yes" xml:space="preserve">
          <source>Parses the string argument and returns the native value.</source>
          <target state="translated">문자열 인수를 구문 분석하고 기본 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1aaa660749bcea759264357e9b26e5669a47d98e" translate="yes" xml:space="preserve">
          <source>Partitioner to allocate minimum size per slice.</source>
          <target state="translated">슬라이스 당 최소 크기를 할당하는 파티 셔너.</target>
        </trans-unit>
        <trans-unit id="639836ff576582ce66b19858583c1ef11bddb145" translate="yes" xml:space="preserve">
          <source>Partitioner to specify a fixed number of shards along given axis.</source>
          <target state="translated">주어진 축을 따라 고정 된 수의 샤드를 지정하는 파티 셔너.</target>
        </trans-unit>
        <trans-unit id="8e2eb665cd45fc06ac2a4e507bedfb7fad10b2de" translate="yes" xml:space="preserve">
          <source>Partitions &lt;code&gt;data&lt;/code&gt; into &lt;code&gt;num_partitions&lt;/code&gt; tensors using indices from &lt;code&gt;partitions&lt;/code&gt;.</source>
          <target state="translated">파티션의 인덱스를 사용하여 &lt;code&gt;data&lt;/code&gt; 를 &lt;code&gt;num_partitions&lt;/code&gt; 텐서로 &lt;code&gt;partitions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d446aae1ecd79d972964f8b5d0e5b655bac17985" translate="yes" xml:space="preserve">
          <source>Parts of the bounding box may fall outside the image.</source>
          <target state="translated">경계 상자의 일부가 이미지 외부에 떨어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56a7796db4b1b5588c8958efddb6ca8b85c5ffb7" translate="yes" xml:space="preserve">
          <source>Pass &quot;library_filename&quot; to a platform-specific mechanism for dynamically loading a library. The rules for determining the exact location of the library are platform-specific and are not documented here. When the library is loaded, ops and kernels registered in the library via the &lt;code&gt;REGISTER_*&lt;/code&gt; macros are made available in the TensorFlow process. Note that ops with the same name as an existing op are rejected and not registered with the process.</source>
          <target state="translated">라이브러리를 동적으로로드하기 위해 &quot;library_filename&quot;을 플랫폼 별 메커니즘으로 전달하십시오. 라이브러리의 정확한 위치를 결정하기위한 규칙은 플랫폼별로 다르며 여기에 설명되어 있지 않습니다. 라이브러리가로드되면 &lt;code&gt;REGISTER_*&lt;/code&gt; 매크로 를 통해 라이브러리에 등록 된 op 및 커널을 TensorFlow 프로세스에서 사용할 수 있습니다. 기존 op와 이름이 같은 op는 거부되고 프로세스에 등록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="047872f94d02ef0590758cf7f445a1e6c35b92a6" translate="yes" xml:space="preserve">
          <source>Pass &lt;code&gt;library_filename&lt;/code&gt; to a platform-specific mechanism for dynamically loading a library. The rules for determining the exact location of the library are platform-specific and are not documented here.</source>
          <target state="translated">패스 &lt;code&gt;library_filename&lt;/code&gt; 을 동적 라이브러리를로드하기위한 플랫폼 별 메커니즘. 라이브러리의 정확한 위치를 결정하기위한 규칙은 플랫폼별로 다르며 여기에 설명되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="780f8fa333fec07941f4fe68692890c6374b0e0c" translate="yes" xml:space="preserve">
          <source>Pass this class to &lt;code&gt;tf.estimator.tpu.TPUEstimator&lt;/code&gt; via the &lt;code&gt;embedding_config_spec&lt;/code&gt; parameter. At minimum you need to specify &lt;code&gt;feature_columns&lt;/code&gt; and &lt;code&gt;optimization_parameters&lt;/code&gt;. The feature columns passed should be created with some combination of &lt;code&gt;tf.tpu.experimental.embedding_column&lt;/code&gt; and &lt;code&gt;tf.tpu.experimental.shared_embedding_columns&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;embedding_config_spec&lt;/code&gt; 매개 변수 를 &lt;code&gt;tf.estimator.tpu.TPUEstimator&lt;/code&gt; 클래스를 tf.estimator.tpu.TPUEstimator에 전달하십시오 . 최소한 &lt;code&gt;feature_columns&lt;/code&gt; 및 &lt;code&gt;optimization_parameters&lt;/code&gt; 를 지정해야합니다 . 전달 된 기능 열은 &lt;code&gt;tf.tpu.experimental.embedding_column&lt;/code&gt; 과 &lt;code&gt;tf.tpu.experimental.shared_embedding_columns&lt;/code&gt; 조합으로 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ade90148ab6b8949a3fb2b6ffa4d0393eb16345e" translate="yes" xml:space="preserve">
          <source>Pass this to &lt;code&gt;embedding_column&lt;/code&gt; or &lt;code&gt;indicator_column&lt;/code&gt; to convert sequence categorical data into dense representation for input to sequence NN, such as RNN.</source>
          <target state="translated">이것을 RPG와 같은 시퀀스 NN에 입력하기 위해 시퀀스 범주 형 데이터를 조밀 한 표현으로 변환 하려면 &lt;code&gt;embedding_column&lt;/code&gt; 또는 &lt;code&gt;indicator_column&lt;/code&gt; 에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="b36f8dc9837b09fa8fbf4d18a29d8e0246873db5" translate="yes" xml:space="preserve">
          <source>Pass this to &lt;code&gt;tf.estimator.tpu.experimental.EmbeddingConfigSpec&lt;/code&gt; via the &lt;code&gt;optimization_parameters&lt;/code&gt; argument to set the optimizer and its parameters. See the documentation for &lt;code&gt;tf.estimator.tpu.experimental.EmbeddingConfigSpec&lt;/code&gt; for more details.</source>
          <target state="translated">이 전달 &lt;code&gt;tf.estimator.tpu.experimental.EmbeddingConfigSpec&lt;/code&gt; 비아 &lt;code&gt;optimization_parameters&lt;/code&gt; 의 최적화 및 해당 매개 변수를 설정하는 인수입니다. 자세한 내용은 &lt;code&gt;tf.estimator.tpu.experimental.EmbeddingConfigSpec&lt;/code&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="081c7cedd4c37b3e7f6ee44a6d00495c6d815a3d" translate="yes" xml:space="preserve">
          <source>Path to the downloaded file</source>
          <target state="translated">다운로드 한 파일의 경로</target>
        </trans-unit>
        <trans-unit id="df72add6f49542180d93fc552269326d74a0af39" translate="yes" xml:space="preserve">
          <source>Peephole connections allow the gates to utilize the previous internal state as well as the previous hidden state (which is what LSTMCell is limited to). This allows PeepholeLSTMCell to better learn precise timings over LSTMCell.</source>
          <target state="translated">틈 구멍 연결을 통해 게이트는 이전의 숨겨진 상태뿐만 아니라 이전의 내부 상태 (LSTMCell로 제한됨)를 활용할 수 있습니다. 이를 통해 PeepholeLSTMCell은 LSTMCell에 대한 정확한 타이밍을 더 잘 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="870e6a439b75eca5baa52bba5d5492701a355c78" translate="yes" xml:space="preserve">
          <source>Perform the KL registration.</source>
          <target state="translated">KL 등록을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="20e0d98d211f2321283436030f098fc8cb11921a" translate="yes" xml:space="preserve">
          <source>Performance contract</source>
          <target state="translated">성능 계약</target>
        </trans-unit>
        <trans-unit id="0d07fcd99e776cfc7585d951dd0aa3386bd3641d" translate="yes" xml:space="preserve">
          <source>Performing arithmetic operations in float16 takes advantage of specialized processing units, such as NVIDIA Tensor Cores for much higher arithmetic throughput. However, due to the smaller representable range, performing the entire training with float16 can result in gradient underflow, that is, small gradient values becoming zeroes. Instead, performing only select arithmetic operations in float16 results in higher throughput and decreased training time when using compatible hardware accelerators while also reducing memory usage, typically without sacrificing model accuracy.</source>
          <target state="translated">float16에서 산술 연산을 수행하면 훨씬 높은 산술 처리량을 위해 NVIDIA Tensor Core와 같은 특수 처리 장치를 활용합니다. 그러나 표현 가능한 범위가 더 작기 때문에 float16으로 전체 훈련을 수행하면 기울기 언더 플로가 발생할 수 있습니다. 즉, 작은 기울기 값이 0이됩니다. 대신 float16에서 선택한 산술 연산 만 수행하면 호환되는 하드웨어 가속기를 사용할 때 처리량이 높아지고 훈련 시간이 줄어들고 일반적으로 모델 정확도를 유지하면서 메모리 사용이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="25732d626fde48625e07cdabc3d83fbfcfe23397" translate="yes" xml:space="preserve">
          <source>Performs &lt;code&gt;op&lt;/code&gt; on the space-to-batch representation of &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; 의 space-to-batch 표현에 대해 &lt;code&gt;op&lt;/code&gt; 를 수행 합니다 .</target>
        </trans-unit>
        <trans-unit id="e44b24a79d05b50d012be9675365fdc9ca912648" translate="yes" xml:space="preserve">
          <source>Performs Gamma Correction on the input image.</source>
          <target state="translated">입력 이미지에서 감마 보정을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="fd9b4411de67f2bf4f4a29452c648c0e7eef20d9" translate="yes" xml:space="preserve">
          <source>Performs a &lt;a href=&quot;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;broadcast&lt;/a&gt; with the arguments and then an element-wise equality comparison, returning a Tensor of boolean values.</source>
          <target state="translated">인수와 함께 &lt;a href=&quot;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;브로드 캐스트&lt;/a&gt; 를 수행 한 다음 요소 별 동등 비교를 수행하여 부울 값의 텐서를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6361e5d3e09097fafa46751e38dbd7f7eea007be" translate="yes" xml:space="preserve">
          <source>Performs a &lt;a href=&quot;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;broadcast&lt;/a&gt; with the arguments and then an element-wise inequality comparison, returning a Tensor of boolean values.</source>
          <target state="translated">인수 로 &lt;a href=&quot;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;브로드 캐스트&lt;/a&gt; 를 수행 한 다음 요소 별 부등식 비교를 수행하여 부울 값의 텐서를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fe41e194cfcd4c012450d5d68e33075599325707" translate="yes" xml:space="preserve">
          <source>Performs a brightness shift.</source>
          <target state="translated">밝기 이동을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d69bb21796aef3caa6a8c7cd56c48cd24a3f8d16" translate="yes" xml:space="preserve">
          <source>Performs a channel shift.</source>
          <target state="translated">채널 이동을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b65a936dab42b7aff029f8f32c05198150d07016" translate="yes" xml:space="preserve">
          <source>Performs a depthwise convolution that acts separately on channels followed by a pointwise convolution that mixes channels. Note that this is separability between dimensions &lt;code&gt;[1, 2]&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt;, not spatial separability between dimensions &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">채널에서 개별적으로 작동하는 깊이 컨벌루션을 수행 한 다음 채널을 혼합하는 포인트 컨벌루션을 수행합니다. 이는 차원 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;2&lt;/code&gt; 사이의 공간적 분리 성이 아니라 차원 &lt;code&gt;[1, 2]&lt;/code&gt; 와 &lt;code&gt;3&lt;/code&gt; 사이의 분리 성 입니다.</target>
        </trans-unit>
        <trans-unit id="4de0228525072efd89b946b5680e4d5192bab98a" translate="yes" xml:space="preserve">
          <source>Performs a logical shift for unsigned integer types, and an arithmetic shift for signed integer types.</source>
          <target state="translated">부호없는 정수 유형에 대한 논리 이동 및 부호있는 정수 유형에 대한 산술 이동을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3ab1ad4abc47740a4a8056ab64216429ae50e3e7" translate="yes" xml:space="preserve">
          <source>Performs a random brightness shift.</source>
          <target state="translated">임의의 밝기 이동을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8fd2e1b40896fbc87f59613fe6045b2272379d40" translate="yes" xml:space="preserve">
          <source>Performs a random channel shift.</source>
          <target state="translated">임의의 채널 이동을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="fbabf9c859f61455ba40ddc150fa0534fb7943a7" translate="yes" xml:space="preserve">
          <source>Performs a random rotation of a Numpy image tensor.</source>
          <target state="translated">Numpy 이미지 텐서의 임의 회전을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="16b3b646cb88be60b72d1ae840875e7c7127ca08" translate="yes" xml:space="preserve">
          <source>Performs a random spatial shear of a Numpy image tensor.</source>
          <target state="translated">Numpy 이미지 텐서의 무작위 공간 전단을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="fae1e993fd3b22e95e77e8369af5a3c3b633afb5" translate="yes" xml:space="preserve">
          <source>Performs a random spatial shift of a Numpy image tensor.</source>
          <target state="translated">Numpy 이미지 텐서의 임의의 공간 이동을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9e23affa8c43f41939ca6e69ac7ff678ac2e8a88" translate="yes" xml:space="preserve">
          <source>Performs a random spatial zoom of a Numpy image tensor.</source>
          <target state="translated">Numpy 이미지 텐서의 임의의 공간 줌을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="37a6819994179461bcded406eeb280611d19f0ea" translate="yes" xml:space="preserve">
          <source>Performs a safe reciprocal operation, element wise.</source>
          <target state="translated">요소 단위로 안전한 왕복 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ec320a06a18400dd9a5f740cbce86afccdf8abf9" translate="yes" xml:space="preserve">
          <source>Performs a safe saturating cast of &lt;code&gt;value&lt;/code&gt; to &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; 에 안전한 포화 캐스트 &lt;code&gt;value&lt;/code&gt; 을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="57878755e134eeac2a80c6038fce00d877dc3842" translate="yes" xml:space="preserve">
          <source>Performs a union on underlying ClusterResolvers.</source>
          <target state="translated">기본 ClusterResolvers에서 통합을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="fedbaa43ec05fbb3307aa0ef670fd22dc8a29074" translate="yes" xml:space="preserve">
          <source>Performs algorithmically equivalent operation to tf.image.non_max_suppression, with the addition of an optional parameter which zero-pads the output to be of size &lt;code&gt;max_output_size&lt;/code&gt;. The output of this operation is a tuple containing the set of integers indexing into the input collection of bounding boxes representing the selected boxes and the number of valid indices in the index set. The bounding box coordinates corresponding to the selected indices can then be obtained using the &lt;a href=&quot;../slice&quot;&gt;&lt;code&gt;tf.slice&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt; operations. For example:</source>
          <target state="translated">tf.image.non_max_suppression과 알고리즘 적으로 동등한 연산을 수행하며, 출력을 크기가 &lt;code&gt;max_output_size&lt;/code&gt; 인 0으로 채우는 선택적 매개 변수를 추가 합니다. 이 연산의 출력은 선택된 상자를 나타내는 바운딩 박스의 입력 모음에 대한 정수 세트와 색인 세트의 유효한 인덱스 수를 포함하는 튜플입니다. 선택된 인덱스에 해당하는 바운딩 박스 좌표는 &lt;a href=&quot;../slice&quot;&gt; &lt;code&gt;tf.slice&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; &lt;/a&gt; 연산을 사용하여 얻을 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="13f2343621d1503be2d119b3b8f22618866e3ccd" translate="yes" xml:space="preserve">
          <source>Performs an N-D pooling operation.</source>
          <target state="translated">ND 풀링 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="cde33529ed2d6dc3cb9ab2f927e4b9cddfe1ef7d" translate="yes" xml:space="preserve">
          <source>Performs beam search decoding on the logits given in input.</source>
          <target state="translated">입력에 주어진 로짓에서 빔 검색 디코딩을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c768efdeaade19f443a09337878978bc13682466" translate="yes" xml:space="preserve">
          <source>Performs fractional average pooling on the input.</source>
          <target state="translated">입력에서 분수 평균 풀링을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="bf2e80bd9c48795b799164beea692c84bf544cc9" translate="yes" xml:space="preserve">
          <source>Performs fractional average pooling on the input. (deprecated)</source>
          <target state="translated">입력에서 분수 평균 풀링을 수행합니다. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="6d92ac8296d307c335cb81822245dfcd743a827a" translate="yes" xml:space="preserve">
          <source>Performs fractional max pooling on the input.</source>
          <target state="translated">입력에서 분수 최대 풀링을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="72164b195c8c9d3652b8b6156a1769dd5f2df761" translate="yes" xml:space="preserve">
          <source>Performs fractional max pooling on the input. (deprecated)</source>
          <target state="translated">입력에서 분수 최대 풀링을 수행합니다. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="b760b1063d3f822c2fb236c1de45332fddbbb750" translate="yes" xml:space="preserve">
          <source>Performs fully dynamic unrolling of &lt;code&gt;inputs&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;inputs&lt;/code&gt; 완전 동적 언 롤링을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="e0f37095b1fe23e5a26e5088d9362133126197b7" translate="yes" xml:space="preserve">
          <source>Performs greedy decoding on the logits given in input (best path).</source>
          <target state="translated">입력 (최상의 경로)에 주어진 로짓에서 욕심 많은 디코딩을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="20a862edfe93a1a6505779641e84002ff66376ee" translate="yes" xml:space="preserve">
          <source>Performs max pooling on the input and outputs both max values and indices.</source>
          <target state="translated">입력에서 최대 풀링을 수행하고 최대 값과 인덱스를 모두 출력합니다.</target>
        </trans-unit>
        <trans-unit id="7e9177928e73aa1ef3e46a69dff7d4af5c0a3025" translate="yes" xml:space="preserve">
          <source>Performs the average pooling on the input.</source>
          <target state="translated">입력에 대한 평균 풀링을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7bf26f511b2687eea661a622930a1297f71024d7" translate="yes" xml:space="preserve">
          <source>Performs the avg pooling on the input.</source>
          <target state="translated">입력에서 평균 풀링을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b3ff16e7bbe6c6d65be7503047797d8c75c47e2e" translate="yes" xml:space="preserve">
          <source>Performs the max pooling on the input.</source>
          <target state="translated">입력에서 최대 풀링을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a7f01b79feaff9d24cb81f18ac5cefac4663b79c" translate="yes" xml:space="preserve">
          <source>Permute dimensions of &lt;code&gt;reshaped&lt;/code&gt; to produce &lt;code&gt;permuted&lt;/code&gt; of shape [batch / prod(block_shape),</source>
          <target state="translated">&lt;code&gt;reshaped&lt;/code&gt; 이 변형 된 모양 을 만들기 위해 모양 이 변형 &lt;code&gt;permuted&lt;/code&gt; 모양 [배치 / 생산물 (block_shape),</target>
        </trans-unit>
        <trans-unit id="55b7a32226c6a5a6200b51e29ab8eebe66273e08" translate="yes" xml:space="preserve">
          <source>Permute dimensions of &lt;code&gt;reshaped&lt;/code&gt; to produce &lt;code&gt;permuted&lt;/code&gt; of shape [batch / prod(block_shape), input_shape[1], block_shape[0], ..., input_shape[M], block_shape[M-1], input_shape[M+1], ..., input_shape[N-1]]</source>
          <target state="translated">치수의 변경하다 &lt;code&gt;reshaped&lt;/code&gt; 생성하는 &lt;code&gt;permuted&lt;/code&gt; 의 형상 [일괄 / 자극 (block_shape) input_shape [1] block_shape [0], ..., input_shape [M] block_shape [M-1] input_shape [M + 1] ..., 입력 _ 형태 [N-1]]</target>
        </trans-unit>
        <trans-unit id="d858af7309e0eb51ac8ea072f4b64695965b9ad7" translate="yes" xml:space="preserve">
          <source>Permute dimensions of &lt;code&gt;reshaped_padded&lt;/code&gt; to produce &lt;code&gt;permuted_reshaped_padded&lt;/code&gt; of shape:</source>
          <target state="translated">&lt;code&gt;reshaped_padded&lt;/code&gt; 이 &lt;code&gt;permuted_reshaped_padded&lt;/code&gt; 를 생성하기 위해 reshaped_padded의 permute 치수 :</target>
        </trans-unit>
        <trans-unit id="1c2ccd6ece6c1729c2562e4135603c11b1c11360" translate="yes" xml:space="preserve">
          <source>Permutes axes in a tensor.</source>
          <target state="translated">텐서에서 축을 치환합니다.</target>
        </trans-unit>
        <trans-unit id="4e20c7bb87d6020885abe6a5ce527a02825fdb0c" translate="yes" xml:space="preserve">
          <source>Permutes the dimensions according to &lt;code&gt;perm&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;perm&lt;/code&gt; 에 따라 치수를 치환합니다 .</target>
        </trans-unit>
        <trans-unit id="526c4c0280957385523ae940241ea0b054842a08" translate="yes" xml:space="preserve">
          <source>Permutes the dimensions of the input according to a given pattern.</source>
          <target state="translated">주어진 패턴에 따라 입력 치수를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="703bcac271da40ae872c757aa6076b85a5bc65ec" translate="yes" xml:space="preserve">
          <source>Perturb a &lt;code&gt;LinearOperator&lt;/code&gt; with a rank &lt;code&gt;K&lt;/code&gt; update.</source>
          <target state="translated">등급 &lt;code&gt;K&lt;/code&gt; 업데이트로 LinearOperator를 &lt;code&gt;LinearOperator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23bc80357c4722dfdf0c91694807718874555f49" translate="yes" xml:space="preserve">
          <source>Physical devices are hardware devices present on the host machine. By default all discovered CPU and GPU devices are considered visible.</source>
          <target state="translated">물리적 장치는 호스트 시스템에 존재하는 하드웨어 장치입니다. 기본적으로 검색된 모든 CPU 및 GPU 장치는 표시되는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e3965d47342d2002b31c98148f78bab8345bef86" translate="yes" xml:space="preserve">
          <source>Piecewise constant from boundaries and interval values.</source>
          <target state="translated">경계 및 간격 값에서 조각 별 상수입니다.</target>
        </trans-unit>
        <trans-unit id="8ef57d28e73677c96993fd2b8445c1eec249cdff" translate="yes" xml:space="preserve">
          <source>Pitfalls</source>
          <target state="translated">Pitfalls</target>
        </trans-unit>
        <trans-unit id="3d6b297653a1304d918a745285ef35a65c95367c" translate="yes" xml:space="preserve">
          <source>Pix2Pix</source>
          <target state="translated">Pix2Pix</target>
        </trans-unit>
        <trans-unit id="334022626faf3c331cbc4e40efd252256d919b5d" translate="yes" xml:space="preserve">
          <source>Placeholders are not compatible with eager execution.</source>
          <target state="translated">자리 표시자는 열망하는 실행과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b238d4e9c2efe26555902b7a27653edccaa3390" translate="yes" xml:space="preserve">
          <source>Please note that &lt;code&gt;np.mean&lt;/code&gt; has a &lt;code&gt;dtype&lt;/code&gt; parameter that could be used to specify the output type. By default this is &lt;code&gt;dtype=float64&lt;/code&gt;. On the other hand, &lt;a href=&quot;../../math/reduce_mean&quot;&gt;&lt;code&gt;tf.reduce_mean&lt;/code&gt;&lt;/a&gt; has an aggressive type inference from &lt;code&gt;input_tensor&lt;/code&gt;, for example:</source>
          <target state="translated">있습니다 &lt;code&gt;np.mean&lt;/code&gt; 이 가 &lt;code&gt;dtype&lt;/code&gt; 출력 형식을 지정하는 데 사용할 수있는 매개 변수를. 기본적으로 이것은 &lt;code&gt;dtype=float64&lt;/code&gt; 입니다. 반면에 &lt;a href=&quot;../../math/reduce_mean&quot;&gt; &lt;code&gt;tf.reduce_mean&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;input_tensor&lt;/code&gt; 에서 공격적인 유형 유추를 갖 습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="417e707e636edd35d8f981e1d2299b15aefed816" translate="yes" xml:space="preserve">
          <source>Please note that &lt;code&gt;np.mean&lt;/code&gt; has a &lt;code&gt;dtype&lt;/code&gt; parameter that could be used to specify the output type. By default this is &lt;code&gt;dtype=float64&lt;/code&gt;. On the other hand, &lt;a href=&quot;reduce_mean&quot;&gt;&lt;code&gt;tf.reduce_mean&lt;/code&gt;&lt;/a&gt; has an aggressive type inference from &lt;code&gt;input_tensor&lt;/code&gt;, for example:</source>
          <target state="translated">있습니다 &lt;code&gt;np.mean&lt;/code&gt; 이 가 &lt;code&gt;dtype&lt;/code&gt; 출력 형식을 지정하는 데 사용할 수있는 매개 변수를. 기본적으로 이것은 &lt;code&gt;dtype=float64&lt;/code&gt; 입니다. 반면에 &lt;a href=&quot;reduce_mean&quot;&gt; &lt;code&gt;tf.reduce_mean&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;input_tensor&lt;/code&gt; 에서 공격적인 유형 유추를 갖 습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="992d22e05c116d7730924c12aad4185a4a7856e1" translate="yes" xml:space="preserve">
          <source>Please note that &lt;code&gt;np.std&lt;/code&gt; has a &lt;code&gt;dtype&lt;/code&gt; parameter that could be used to specify the output type. By default this is &lt;code&gt;dtype=float64&lt;/code&gt;. On the other hand, &lt;code&gt;tf.reduce_std&lt;/code&gt; has an aggressive type inference from &lt;code&gt;input_tensor&lt;/code&gt;,</source>
          <target state="translated">있습니다 &lt;code&gt;np.std&lt;/code&gt; 이 가 &lt;code&gt;dtype&lt;/code&gt; 출력 형식을 지정하는 데 사용할 수있는 매개 변수를. 기본적으로 이것은 &lt;code&gt;dtype=float64&lt;/code&gt; 입니다. 한편, &lt;code&gt;tf.reduce_std&lt;/code&gt; 가 에서 공격적인 타입 추론을 갖는다 &lt;code&gt;input_tensor&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="7c793a1ddf3c7631d365fe6ab8ffa9c96b0d2a1e" translate="yes" xml:space="preserve">
          <source>Please note that &lt;code&gt;np.var&lt;/code&gt; has a &lt;code&gt;dtype&lt;/code&gt; parameter that could be used to specify the output type. By default this is &lt;code&gt;dtype=float64&lt;/code&gt;. On the other hand, &lt;code&gt;tf.reduce_variance&lt;/code&gt; has an aggressive type inference from &lt;code&gt;input_tensor&lt;/code&gt;,</source>
          <target state="translated">있습니다 &lt;code&gt;np.var&lt;/code&gt; 이 가 &lt;code&gt;dtype&lt;/code&gt; 출력 형식을 지정하는 데 사용할 수있는 매개 변수를. 기본적으로 이것은 &lt;code&gt;dtype=float64&lt;/code&gt; 입니다. 반면에 &lt;code&gt;tf.reduce_variance&lt;/code&gt; 에는 &lt;code&gt;input_tensor&lt;/code&gt; 로부터 공격적인 유형 유추가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6139d4a074934a86490e854b98d8cc4a4611d008" translate="yes" xml:space="preserve">
          <source>Please note that interleaving two predict outputs does not work. See: &lt;a href=&quot;https://github.com/tensorflow/tensorflow/issues/20506#issuecomment-422208517&quot;&gt;issue/20506&lt;/a&gt;</source>
          <target state="translated">두 개의 예측 출력 인터리빙은 작동하지 않습니다. 참조 : &lt;a href=&quot;https://github.com/tensorflow/tensorflow/issues/20506#issuecomment-422208517&quot;&gt;issue / 20506&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b1f3cbf92a097f48efc56315ad4f799324d88055" translate="yes" xml:space="preserve">
          <source>Please note that this utility is not recommended for distributed settings. For distributed settings, please use &lt;a href=&quot;monitoredsession&quot;&gt;&lt;code&gt;tf.compat.v1.train.MonitoredSession&lt;/code&gt;&lt;/a&gt;. The differences between &lt;code&gt;MonitoredSession&lt;/code&gt; and &lt;code&gt;SingularMonitoredSession&lt;/code&gt; are:</source>
          <target state="translated">이 유틸리티는 분산 설정에 권장되지 않습니다. 분산 설정의 경우 &lt;a href=&quot;monitoredsession&quot;&gt; &lt;code&gt;tf.compat.v1.train.MonitoredSession&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 . &lt;code&gt;MonitoredSession&lt;/code&gt; 과 &lt;code&gt;SingularMonitoredSession&lt;/code&gt; 의 차이점 은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ead30ce4b56c11d63c21621c6b779c31384d98d1" translate="yes" xml:space="preserve">
          <source>Please see https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/g3doc/profile_model_architecture.md on the caveats of calculating float operations.</source>
          <target state="translated">플로트 연산 계산에 대한 https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/g3doc/profile_model_architecture.md를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="deb18334d62b7a7ce55c831338adba20ccf7d11d" translate="yes" xml:space="preserve">
          <source>Please see https://www.tensorflow.org/tutorials/distribute/custom_training for more details on this.</source>
          <target state="translated">이에 대한 자세한 내용은 https://www.tensorflow.org/tutorials/distribute/custom_training을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8458b0bc54972ae3149edcd32c9ccb674e55da60" translate="yes" xml:space="preserve">
          <source>Please see the &lt;a href=&quot;https://www.tensorflow.org/tutorials/distribute/custom_training&quot;&gt;custom training guide&lt;/a&gt; # pylint: disable=line-too-long for more details on this.</source>
          <target state="translated">이에 대한 자세한 내용은 &lt;a href=&quot;https://www.tensorflow.org/tutorials/distribute/custom_training&quot;&gt;맞춤형 교육 안내서&lt;/a&gt; # pylint : disable = line-too-long을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="63ac0426055926a95d4b7bcc8879d356e9bb8948" translate="yes" xml:space="preserve">
          <source>Please see the DistributeOptions.auto_shard_policy documentation for more information on each type of autosharding.</source>
          <target state="translated">각 자동 샤딩 유형에 대한 자세한 내용은 DistributeOptions.auto_shard_policy 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7164f2138719c681550eff4bb79ab53536e9f88f" translate="yes" xml:space="preserve">
          <source>Please see the definition of these values in TPUConfig.</source>
          <target state="translated">TPUConfig에서이 값의 정의를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1643c9b4527d79d2e664514fae756c738787d371" translate="yes" xml:space="preserve">
          <source>Please use &lt;a href=&quot;../../config/experimental_run_functions_eagerly&quot;&gt;&lt;code&gt;tf.config.experimental_run_functions_eagerly(True)&lt;/code&gt;&lt;/a&gt; to execute this function eagerly for debugging or profiling.</source>
          <target state="translated">디버깅 또는 프로파일 링을 위해이 기능을 열심히 실행 하려면 &lt;a href=&quot;../../config/experimental_run_functions_eagerly&quot;&gt; &lt;code&gt;tf.config.experimental_run_functions_eagerly(True)&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae2ce53536aea6d05cdc28f967b3cc9c3648947c" translate="yes" xml:space="preserve">
          <source>Please use &lt;a href=&quot;../../quantization/quantize&quot;&gt;&lt;code&gt;tf.quantization.quantize&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">사용하십시오 &lt;a href=&quot;../../quantization/quantize&quot;&gt; &lt;code&gt;tf.quantization.quantize&lt;/code&gt; 을&lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="1ada6b4962a968ec4f4463a8d75601fa2db5285e" translate="yes" xml:space="preserve">
          <source>Policies are constructed by passing a string to the constructor, e.g. &lt;code&gt;tf.keras.mixed_precision.experimental.Policy('float32')&lt;/code&gt;. The string determines the compute and variable dtypes. It can be one of the following:</source>
          <target state="translated">정책은 생성자에 문자열을 전달하여 구성됩니다 &lt;code&gt;tf.keras.mixed_precision.experimental.Policy('float32')&lt;/code&gt; 예 : tf.keras.mixed_precision.experimental.Policy ( 'float32')) . 문자열은 계산 및 변수 dtype을 결정합니다. 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2899f52a455f323440dff1c80f69c0c5bb41e6a" translate="yes" xml:space="preserve">
          <source>Positive means, for every element &lt;code&gt;x[i]&lt;/code&gt; of &lt;code&gt;x&lt;/code&gt;, we have &lt;code&gt;x[i] &amp;gt; 0&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is empty this is trivially satisfied.</source>
          <target state="translated">긍정적 수단은, 각 요소에 대해 &lt;code&gt;x[i]&lt;/code&gt; 중 &lt;code&gt;x&lt;/code&gt; , 우리가 &lt;code&gt;x[i] &amp;gt; 0&lt;/code&gt; . 경우 &lt;code&gt;x&lt;/code&gt; 가 비어있는이 하찮게 만족된다.</target>
        </trans-unit>
        <trans-unit id="090f38b6c85f4157eded89d0516470bcd9d6eb53" translate="yes" xml:space="preserve">
          <source>Potentially Ragged Tensors</source>
          <target state="translated">비정형 텐서</target>
        </trans-unit>
        <trans-unit id="7709fbb19ad75f33b82632f2df40c0d2a5149b1f" translate="yes" xml:space="preserve">
          <source>Pre-padding is the default.</source>
          <target state="translated">프리 패딩이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="7fa92f92b07bcf0156f7cc1cfb3023496a121e00" translate="yes" xml:space="preserve">
          <source>Precision = TP / (TP + FP) = TP / P</source>
          <target state="translated">정밀도 = TP / (TP + FP) = TP / P</target>
        </trans-unit>
        <trans-unit id="064f5973109d48c6d6c916eeb227ce7697198751" translate="yes" xml:space="preserve">
          <source>Precision slope = dTP / dP = (TP_B - TP_A) / (P_B - P_A) = (TP - TP_A) / (P - P_A) Precision = (TP_A + slope * (P - P_A)) / P</source>
          <target state="translated">정밀 기울기 = dTP / dP = (TP_B-TP_A) / (P_B-P_A) = (TP-TP_A) / (P-P_A) 정밀도 = (TP_A + 기울기 * (P-P_A)) / P</target>
        </trans-unit>
        <trans-unit id="837276742aa90209dde3b4eef07d8e7ab26731ef" translate="yes" xml:space="preserve">
          <source>Prediction</source>
          <target state="translated">Prediction</target>
        </trans-unit>
        <trans-unit id="69bee21d8977cc3c5001451cd196ff1b38a4e5ff" translate="yes" xml:space="preserve">
          <source>Prediction on TPU is an experimental feature to support large batch inference. It is not designed for latency-critical system. In addition, due to some usability issues, for prediction with small dataset, CPU &lt;code&gt;.predict&lt;/code&gt;, i.e., creating a new &lt;code&gt;TPUEstimator&lt;/code&gt; instance with &lt;code&gt;use_tpu=False&lt;/code&gt;, might be more convenient.</source>
          <target state="translated">TPU에 대한 예측은 큰 배치 추론을 지원하는 실험적인 기능입니다. 대기 시간이 중요한 시스템을 위해 설계되지 않았습니다. 또한, 때문에 일부 사용성 문제, 작은 데이터 세트의 CPU와 예측에 &lt;code&gt;.predict&lt;/code&gt; 새로운 창조, 즉, &lt;code&gt;TPUEstimator&lt;/code&gt; 의 와 인스턴스를 &lt;code&gt;use_tpu=False&lt;/code&gt; 더 편리 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3696da6d811762d728c7953287ef4404ab01dc40" translate="yes" xml:space="preserve">
          <source>Prefer to use the &lt;a href=&quot;deviceassignment#build&quot;&gt;&lt;code&gt;DeviceAssignment.build()&lt;/code&gt;&lt;/a&gt; helper to construct a &lt;code&gt;DeviceAssignment&lt;/code&gt;; it is easier if less flexible than constructing a &lt;code&gt;DeviceAssignment&lt;/code&gt; directly.</source>
          <target state="translated">&lt;a href=&quot;deviceassignment#build&quot;&gt; &lt;code&gt;DeviceAssignment.build()&lt;/code&gt; &lt;/a&gt; 도우미 를 사용하여 DeviceAssignment 를 구성하는 것이 &lt;code&gt;DeviceAssignment&lt;/code&gt; . 유연성이 &lt;code&gt;DeviceAssignment&lt;/code&gt; 직접 구성하는 것보다 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="1d66879a264e4b09fa279b16336c84cfd9a0a698" translate="yes" xml:space="preserve">
          <source>Prefix for the statistics recorded as counter.</source>
          <target state="translated">카운터로 기록 된 통계의 접두사.</target>
        </trans-unit>
        <trans-unit id="29ed417ebc6db623f150307f55e7a9c1b1e39822" translate="yes" xml:space="preserve">
          <source>Prefix to prepend all statistics recorded for the input &lt;code&gt;dataset&lt;/code&gt; with.</source>
          <target state="translated">입력 &lt;code&gt;dataset&lt;/code&gt; 대해 기록 된 모든 통계를 앞에 추가하는 접두사 입니다.</target>
        </trans-unit>
        <trans-unit id="4d60067c50e0ed10e08c63b1fc685380e5b9b5cc" translate="yes" xml:space="preserve">
          <source>Premade Estimators</source>
          <target state="translated">사전 제작 견적 도구</target>
        </trans-unit>
        <trans-unit id="3928341f18b91e77a03f8408e4b41e6aef0b9185" translate="yes" xml:space="preserve">
          <source>Preserves cached row-partitioning tensors such as &lt;code&gt;self.cached_nrows&lt;/code&gt; and &lt;code&gt;self.cached_value_rowids&lt;/code&gt; if they have values.</source>
          <target state="translated">&lt;code&gt;self.cached_nrows&lt;/code&gt; 및 &lt;code&gt;self.cached_value_rowids&lt;/code&gt; 와 같은 캐시 된 행 분할 텐서에 값이있는 경우이를 보존 합니다.</target>
        </trans-unit>
        <trans-unit id="fb18c31010d4e85397d1c379156a7785406e4219" translate="yes" xml:space="preserve">
          <source>Primary symbols</source>
          <target state="translated">기본 기호</target>
        </trans-unit>
        <trans-unit id="318743f5dcb56f11aeb985f7c83ce4048f29b7d7" translate="yes" xml:space="preserve">
          <source>Print the result to a file.</source>
          <target state="translated">결과를 파일로 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="c72f17290b42271bf278810cb72e46e79a702bd4" translate="yes" xml:space="preserve">
          <source>Print the result to stdout.</source>
          <target state="translated">stdout에 결과를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="91320d025c92ec3981c1e04aadf893aa23746f75" translate="yes" xml:space="preserve">
          <source>Print the specified inputs.</source>
          <target state="translated">지정된 입력을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="fc6734c965e0428fc2dfa8066eec156826ba83ee" translate="yes" xml:space="preserve">
          <source>Prints &lt;code&gt;message&lt;/code&gt; and the tensor value when evaluated.</source>
          <target state="translated">평가시 &lt;code&gt;message&lt;/code&gt; 및 텐서 값을 인쇄 합니다 .</target>
        </trans-unit>
        <trans-unit id="263b79eaf1f54cd0cfe894be5aa0a3a57cd3fd12" translate="yes" xml:space="preserve">
          <source>Prints a list of tensors. (deprecated)</source>
          <target state="translated">텐서 목록을 인쇄합니다. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="9708c484f080d3f2dc8bb4c9a6ca307244db9b8e" translate="yes" xml:space="preserve">
          <source>Prints a string summary of the network.</source>
          <target state="translated">네트워크의 문자열 요약을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="64f570c9307ea2236bf2f5e136948b3c029a4049" translate="yes" xml:space="preserve">
          <source>Prints the given tensors every N local steps, every N seconds, or at end.</source>
          <target state="translated">N 개의 로컬 스텝마다, N 초마다 또는 끝에 지정된 텐서를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2370a04675661821486ca077514ad0c853ae65c1" translate="yes" xml:space="preserve">
          <source>Probability density/mass function.</source>
          <target state="translated">확률 밀도 / 질량 함수.</target>
        </trans-unit>
        <trans-unit id="65dee904c6c6511b9ba9bc33fa16a0aae1a3fee5" translate="yes" xml:space="preserve">
          <source>Probability of a &lt;code&gt;1&lt;/code&gt; outcome (vs &lt;code&gt;0&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 결과의 확률 (vs &lt;code&gt;0&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1ad6723e82328becf0711a7a954917d95af7c989" translate="yes" xml:space="preserve">
          <source>Probability of drawing a &lt;code&gt;1&lt;/code&gt; in that coordinate.</source>
          <target state="translated">해당 좌표에서 &lt;code&gt;1&lt;/code&gt; 을 그릴 가능성 .</target>
        </trans-unit>
        <trans-unit id="62dce6915c8984a2750a9509c2ef59f6546fdb42" translate="yes" xml:space="preserve">
          <source>Process the gradients as you wish.</source>
          <target state="translated">원하는대로 그라디언트를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="be7e5a4441aa475557a960dd665c6e8eead7eafa" translate="yes" xml:space="preserve">
          <source>Processes command line args, but also allow args to be read from file.</source>
          <target state="translated">명령 행 인수를 처리하지만 파일에서 인수를 읽을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="68ccc2489abc68b56d3dbbf85c0d1ae466652171" translate="yes" xml:space="preserve">
          <source>Processing gradients before applying them.</source>
          <target state="translated">그라디언트를 적용하기 전에 처리합니다.</target>
        </trans-unit>
        <trans-unit id="856a710f9626583b82c9b1b6f10cffc1f44ba38a" translate="yes" xml:space="preserve">
          <source>Produce a string tensor that encodes the state of a reader.</source>
          <target state="translated">리더의 상태를 인코딩하는 문자열 텐서를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="3c789aeae1afa6effbbb12a4cf605e6f5ebf42c2" translate="yes" xml:space="preserve">
          <source>Produces a slice of each &lt;code&gt;Tensor&lt;/code&gt; in &lt;code&gt;tensor_list&lt;/code&gt;. (deprecated)</source>
          <target state="translated">&lt;code&gt;tensor_list&lt;/code&gt; 에서 각 &lt;code&gt;Tensor&lt;/code&gt; 의 슬라이스를 생성 합니다. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="0e0b0ffdbe50055f1d975f7713a7edc9b955d6da" translate="yes" xml:space="preserve">
          <source>Produces the average pool of the input tensor for quantized types.</source>
          <target state="translated">양자화 된 유형에 대한 입력 텐서의 평균 풀을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ead7134e50b76e6568d388b3d7b87b6f8d15ad24" translate="yes" xml:space="preserve">
          <source>Produces the integers from 0 to limit-1 in a queue. (deprecated)</source>
          <target state="translated">큐에서 0부터 limit-1까지의 정수를 생성합니다. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="896a9922194a2d3bcc27031372e2bcc5fbcde215" translate="yes" xml:space="preserve">
          <source>Produces the max pool of the input tensor for quantized types.</source>
          <target state="translated">양자화 된 유형에 대한 입력 텐서의 최대 풀을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2e7c030184570702d4290300aec2c10a20492737" translate="yes" xml:space="preserve">
          <source>Profile model.</source>
          <target state="translated">프로필 모델.</target>
        </trans-unit>
        <trans-unit id="ef2ce2498974fa71ba595f7e153df1bdc89fe3b0" translate="yes" xml:space="preserve">
          <source>Profile the statistics of graph nodes, organized by dataflow graph.</source>
          <target state="translated">데이터 흐름 그래프로 구성된 그래프 노드의 통계를 프로파일하십시오.</target>
        </trans-unit>
        <trans-unit id="6ad93e8ea3dd4860171fa509a0fa20429af069a9" translate="yes" xml:space="preserve">
          <source>Profile the statistics of graph nodes, organized by name scope.</source>
          <target state="translated">이름 범위별로 구성된 그래프 노드의 통계를 프로파일하십시오.</target>
        </trans-unit>
        <trans-unit id="3d22915b81a506333dad215a53012f220963b93b" translate="yes" xml:space="preserve">
          <source>Profile the statistics of the Operation types (e.g. MatMul, Conv2D).</source>
          <target state="translated">작업 유형 통계 (예 : MatMul, Conv2D)를 프로파일하십시오.</target>
        </trans-unit>
        <trans-unit id="de3e4ccfd72e92ec1579f3f37968ab38f5f39ab9" translate="yes" xml:space="preserve">
          <source>Profile the statistics of the Python codes.</source>
          <target state="translated">파이썬 코드의 통계를 프로파일하십시오.</target>
        </trans-unit>
        <trans-unit id="fc9950474d5c22fd0d9c32ffa8ebccd6ba5b27f0" translate="yes" xml:space="preserve">
          <source>ProfileProto binary string.</source>
          <target state="translated">ProfileProto 이진 문자열.</target>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Properties</target>
        </trans-unit>
        <trans-unit id="351f56a6fefd5127c90506d3e91990f1d7631787" translate="yes" xml:space="preserve">
          <source>Properties:</source>
          <target state="translated">Properties:</target>
        </trans-unit>
        <trans-unit id="0ba66b164c5ba93bb09d6feca80fa0446144a93c" translate="yes" xml:space="preserve">
          <source>Provides a scope that changes to &lt;code&gt;_GLOBAL_CUSTOM_OBJECTS&lt;/code&gt; cannot escape.</source>
          <target state="translated">&lt;code&gt;_GLOBAL_CUSTOM_OBJECTS&lt;/code&gt; 로 변경하면 이스케이프 할 수없는 범위를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="ae152a276b18a3765da598672ccf60c3f3a6be83" translate="yes" xml:space="preserve">
          <source>Provides a scope within which the learning phase is equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">학습 단계가 &lt;code&gt;value&lt;/code&gt; 동일한 범위를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="006118437d9945c76794f1a8e46138eaf7551f96" translate="yes" xml:space="preserve">
          <source>Provides information about original request to &lt;code&gt;Session.Run()&lt;/code&gt; function. SessionRunHook objects can stop the loop by calling &lt;code&gt;request_stop()&lt;/code&gt; of &lt;code&gt;run_context&lt;/code&gt;. In the future we may use this object to add more information about run without changing the Hook API.</source>
          <target state="translated">원래 요청에 대한 정보를 &lt;code&gt;Session.Run()&lt;/code&gt; 함수 에 제공합니다 . SessionRunHook 객체는 &lt;code&gt;run_context&lt;/code&gt; 의 &lt;code&gt;request_stop()&lt;/code&gt; 을 호출하여 루프를 중지 할 수 있습니다 . 앞으로이 API를 사용하여 Hook API를 변경하지 않고 실행에 대한 추가 정보를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d70107170ac1240f5eda1865b975bf4542373d84" translate="yes" xml:space="preserve">
          <source>Provides information about the &lt;code&gt;session.run()&lt;/code&gt; call being made.</source>
          <target state="translated">&lt;code&gt;session.run()&lt;/code&gt; 호출에 대한 정보를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="d63ddebd0ebe2a819b1df4691f51014895e18dbc" translate="yes" xml:space="preserve">
          <source>Provides internal support for saving variables as slices of a larger variable. This API is not public and is subject to change.</source>
          <target state="translated">변수를 더 큰 변수의 조각으로 저장하기위한 내부 지원을 제공합니다. 이 API는 공개되지 않으며 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16bb6a29ce5c0e1c86ceaaf072c62042c3292e5e" translate="yes" xml:space="preserve">
          <source>Provides the time since epoch in seconds.</source>
          <target state="translated">에포크 이후 시간 (초)을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5cbeb1b81080b7cfc0d70f787d933331d2505ea6" translate="yes" xml:space="preserve">
          <source>Providing &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; allows use of a slice of the dataset.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 과 &lt;code&gt;end&lt;/code&gt; 제공 하면 데이터 집합 조각을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a40a086f30be24913cea266e427879754305e19a" translate="yes" xml:space="preserve">
          <source>Prunes away boxes that have high intersection-over-union (IOU) overlap with previously selected boxes. Bounding boxes are supplied as &lt;code&gt;[y1, x1, y2, x2]&lt;/code&gt;, where &lt;code&gt;(y1, x1)&lt;/code&gt; and &lt;code&gt;(y2, x2)&lt;/code&gt; are the coordinates of any diagonal pair of box corners and the coordinates can be provided as normalized (i.e., lying in the interval &lt;code&gt;[0, 1]&lt;/code&gt;) or absolute. Note that this algorithm is agnostic to where the origin is in the coordinate system. Note that this algorithm is invariant to orthogonal transformations and translations of the coordinate system; thus translating or reflections of the coordinate system result in the same boxes being selected by the algorithm. The output of this operation is a set of integers indexing into the input collection of bounding boxes representing the selected boxes. The bounding box coordinates corresponding to the selected indices can then be obtained using the &lt;a href=&quot;../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt; operation. For example:</source>
          <target state="translated">높은 IOU (교집합 교차)가있는 상자를 이전에 선택한 상자와 겹치십시오. 경계 상자는 &lt;code&gt;[y1, x1, y2, x2]&lt;/code&gt; 로 제공되며, 여기서 &lt;code&gt;(y1, x1)&lt;/code&gt; 및 &lt;code&gt;(y2, x2)&lt;/code&gt; 는 상자 모서리의 대각선 쌍의 좌표이며 좌표는 정규화 된대로 제공 할 수 있습니다 (예 : 간격 &lt;code&gt;[0, 1]&lt;/code&gt; ) 또는 절대입니다. 이 알고리즘은 원점이 좌표계에있는 위치와 무관합니다. 이 알고리즘은 좌표계의 직교 변환 및 변환에 변하지 않습니다. 따라서 좌표계의 변환 또는 반사는 알고리즘에 의해 동일한 박스가 선택되게한다. 이 작업의 결과는 선택한 상자를 나타내는 경계 상자의 입력 모음에 인덱싱 된 정수 집합입니다. 선택된 인덱스에 해당하는 바운딩 박스 좌표는 &lt;a href=&quot;../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; &lt;/a&gt; 연산을 사용하여 얻을 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="71c156c7183f107c4a7b461bec2f34711a57e645" translate="yes" xml:space="preserve">
          <source>Prunes away boxes that have high overlap with previously selected boxes. N-by-n overlap values are supplied as square matrix. The output of this operation is a set of integers indexing into the input collection of bounding boxes representing the selected boxes. The bounding box coordinates corresponding to the selected indices can then be obtained using the &lt;a href=&quot;../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt; operation. For example:</source>
          <target state="translated">이전에 선택한 상자와 겹치는 상자를 제거합니다. nxn 오버랩 값은 정사각 행렬로 제공됩니다. 이 작업의 결과는 선택한 상자를 나타내는 경계 상자의 입력 모음에 인덱싱 된 정수 집합입니다. 선택된 인덱스에 해당하는 바운딩 박스 좌표는 &lt;a href=&quot;../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; &lt;/a&gt; 연산을 사용하여 얻을 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="765b9285b097f660ff0d5d3c7334df3fcc3f7ac2" translate="yes" xml:space="preserve">
          <source>Prunes out nodes that aren't needed for inference. (deprecated)</source>
          <target state="translated">추론에 필요하지 않은 노드를 제거합니다. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="a1e368bcdd9e3ad64f80172f6605fff557c816ac" translate="yes" xml:space="preserve">
          <source>Pseudocode:</source>
          <target state="translated">Pseudocode:</target>
        </trans-unit>
        <trans-unit id="e621921e0a123f07a0a6c36aa4425da00d2de4e9" translate="yes" xml:space="preserve">
          <source>Public API for tf.audio namespace.</source>
          <target state="translated">tf.audio 네임 스페이스를위한 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="6985dcda04083ecf4eab2b186725d1a03e5576f5" translate="yes" xml:space="preserve">
          <source>Public API for tf.autodiff namespace.</source>
          <target state="translated">tf.autodiff 네임 스페이스의 공용 API</target>
        </trans-unit>
        <trans-unit id="dca39937cfd49cf9ff5aadd000a33d3b3f9d2f66" translate="yes" xml:space="preserve">
          <source>Public API for tf.autograph.experimental namespace.</source>
          <target state="translated">tf.autograph.experimental 네임 스페이스에 대한 공용 API</target>
        </trans-unit>
        <trans-unit id="7d25c1e410cf6d5e064ce1b9fc4d2a8c8304f943" translate="yes" xml:space="preserve">
          <source>Public API for tf.config namespace.</source>
          <target state="translated">tf.config 네임 스페이스의 공개 API</target>
        </trans-unit>
        <trans-unit id="199c5d1d133d890fb40b4d56d8de0bf2310a493d" translate="yes" xml:space="preserve">
          <source>Public API for tf.config.experimental namespace.</source>
          <target state="translated">tf.config.experimental 네임 스페이스의 공용 API</target>
        </trans-unit>
        <trans-unit id="571be23534cac9cd204b3e6f4197218042d15e62" translate="yes" xml:space="preserve">
          <source>Public API for tf.config.optimizer namespace.</source>
          <target state="translated">tf.config.optimizer 네임 스페이스의 공개 API</target>
        </trans-unit>
        <trans-unit id="8769c0bc6b93fe48f9501765bb192143e2368302" translate="yes" xml:space="preserve">
          <source>Public API for tf.config.threading namespace.</source>
          <target state="translated">tf.config.threading 네임 스페이스에 대한 공용 API</target>
        </trans-unit>
        <trans-unit id="a78023780ef42264dca8405af9484c507aaaba25" translate="yes" xml:space="preserve">
          <source>Public API for tf.debugging namespace.</source>
          <target state="translated">tf.debugging 네임 스페이스에 대한 공용 API</target>
        </trans-unit>
        <trans-unit id="0878a45518d3487d07ea797e543b64c6a169a678" translate="yes" xml:space="preserve">
          <source>Public API for tf.debugging.experimental namespace.</source>
          <target state="translated">tf.debugging.experimental 네임 스페이스에 대한 공개 API</target>
        </trans-unit>
        <trans-unit id="e7e81f3d18e0944ad46f98178fb59285d2b0c5c1" translate="yes" xml:space="preserve">
          <source>Public API for tf.dtypes namespace.</source>
          <target state="translated">tf.dtypes 네임 스페이스에 대한 공용 API</target>
        </trans-unit>
        <trans-unit id="a3e29bf467fc678888e3cfe155fa990db3f7da3d" translate="yes" xml:space="preserve">
          <source>Public API for tf.estimator.experimental namespace.</source>
          <target state="translated">tf.estimator.experimental 네임 스페이스의 공용 API</target>
        </trans-unit>
        <trans-unit id="bcf5ce196c353189e7dce530617e5629381abae1" translate="yes" xml:space="preserve">
          <source>Public API for tf.estimator.tpu namespace.</source>
          <target state="translated">tf.estimator.tpu 네임 스페이스에 대한 공용 API</target>
        </trans-unit>
        <trans-unit id="135f3095219d86ddc412d829a4adb0d000eb4008" translate="yes" xml:space="preserve">
          <source>Public API for tf.estimator.tpu.experimental namespace.</source>
          <target state="translated">tf.estimator.tpu.experimental 네임 스페이스의 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="d894de7386e4c4c03395ef90a656344ad1fa2ed4" translate="yes" xml:space="preserve">
          <source>Public API for tf.experimental namespace.</source>
          <target state="translated">tf.experimental 네임 스페이스의 공개 API</target>
        </trans-unit>
        <trans-unit id="d00a9d3bbca3d078d60ba606911fc4c238e188ff" translate="yes" xml:space="preserve">
          <source>Public API for tf.experimental.tensorrt namespace.</source>
          <target state="translated">tf.experimental.tensorrt 네임 스페이스에 대한 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="bc1285119e3846ee9aec1233ccd2bcfc164322ba" translate="yes" xml:space="preserve">
          <source>Public API for tf.feature_column namespace.</source>
          <target state="translated">tf.feature_column 네임 스페이스의 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="f4801408c40bf090c9e25a74f6e4a585c7caaf10" translate="yes" xml:space="preserve">
          <source>Public API for tf.initializers namespace.</source>
          <target state="translated">tf.initializers 네임 스페이스에 대한 공용 API</target>
        </trans-unit>
        <trans-unit id="161f4ba3e3fea6357a904bf3dcb1485dcdb4828f" translate="yes" xml:space="preserve">
          <source>Public API for tf.io namespace.</source>
          <target state="translated">tf.io 네임 스페이스에 대한 공개 API.</target>
        </trans-unit>
        <trans-unit id="1440b81d11699ed58a65bfd5a50c2b918e9e39a4" translate="yes" xml:space="preserve">
          <source>Public API for tf.io.gfile namespace.</source>
          <target state="translated">tf.io.gfile 네임 스페이스에 대한 공개 API</target>
        </trans-unit>
        <trans-unit id="717b97456c3f5125d37ffdbbfe8fa0f58c6a1b8d" translate="yes" xml:space="preserve">
          <source>Public API for tf.keras.applications.resnet50 namespace.</source>
          <target state="translated">tf.keras.applications.resnet50 네임 스페이스에 대한 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="7f1538afef3cc2315288cbb084f972724a979a95" translate="yes" xml:space="preserve">
          <source>Public API for tf.keras.datasets namespace.</source>
          <target state="translated">tf.keras.datasets 네임 스페이스의 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="46d827163597f82cf5732268e0f28a3377a91c0a" translate="yes" xml:space="preserve">
          <source>Public API for tf.keras.experimental namespace.</source>
          <target state="translated">tf.keras.experimental 네임 스페이스에 대한 공용 API</target>
        </trans-unit>
        <trans-unit id="2d8dac1b13537d22c9f3827a7930a361877fa39e" translate="yes" xml:space="preserve">
          <source>Public API for tf.keras.layers.experimental namespace.</source>
          <target state="translated">tf.keras.layers.experimental 네임 스페이스의 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="e1e3d05d78fa61851e9530586a77210c758d4546" translate="yes" xml:space="preserve">
          <source>Public API for tf.keras.layers.experimental.preprocessing namespace.</source>
          <target state="translated">tf.keras.layers.experimental.preprocessing 네임 스페이스의 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="9848852250496356a5462a5631f95f46c2b08b22" translate="yes" xml:space="preserve">
          <source>Public API for tf.keras.mixed_precision namespace.</source>
          <target state="translated">tf.keras.mixed_precision 네임 스페이스의 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="16b1e3fec4d86bdcb0aee302d9e668da7a262a99" translate="yes" xml:space="preserve">
          <source>Public API for tf.keras.mixed_precision.experimental namespace.</source>
          <target state="translated">tf.keras.mixed_precision.experimental 네임 스페이스의 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="df8d82f00c3e90893fbea9b3dc118acc04a2f0a9" translate="yes" xml:space="preserve">
          <source>Public API for tf.keras.optimizers.schedules namespace.</source>
          <target state="translated">tf.keras.optimizers.schedules 네임 스페이스에 대한 공용 API</target>
        </trans-unit>
        <trans-unit id="38b57b49369f8e9a092801041f1b572ce52e2410" translate="yes" xml:space="preserve">
          <source>Public API for tf.keras.utils namespace.</source>
          <target state="translated">tf.keras.utils 네임 스페이스의 공용 API</target>
        </trans-unit>
        <trans-unit id="0a962947cb05f5860f07b6593c27c93477765a7b" translate="yes" xml:space="preserve">
          <source>Public API for tf.keras.wrappers namespace.</source>
          <target state="translated">tf.keras.wrappers 네임 스페이스의 공용 API</target>
        </trans-unit>
        <trans-unit id="ff9f353434e0d80aee415c16def56cdae771e0fa" translate="yes" xml:space="preserve">
          <source>Public API for tf.layers namespace.</source>
          <target state="translated">tf.layers 네임 스페이스를위한 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="b8dd6ee80fa6a1a4cb39e7e90621ee23c9ebf3ca" translate="yes" xml:space="preserve">
          <source>Public API for tf.layers.experimental namespace.</source>
          <target state="translated">tf.layers.experimental 네임 스페이스에 대한 공용 API</target>
        </trans-unit>
        <trans-unit id="89a379d13b10ebd67b9008b039d4a5cde160dcce" translate="yes" xml:space="preserve">
          <source>Public API for tf.lite namespace.</source>
          <target state="translated">tf.lite 네임 스페이스를위한 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="53b08b156484ccccc4344ecf716b387a398fb5a2" translate="yes" xml:space="preserve">
          <source>Public API for tf.lite.constants namespace.</source>
          <target state="translated">tf.lite.constants 네임 스페이스에 대한 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="94176a1a2f44318177a4fd6a4bfd1fa88c664368" translate="yes" xml:space="preserve">
          <source>Public API for tf.lite.experimental namespace.</source>
          <target state="translated">tf.lite.experimental 네임 스페이스의 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="20f0e0b2147735d0d09e43ca1892be54f01f1db1" translate="yes" xml:space="preserve">
          <source>Public API for tf.lite.experimental.nn namespace.</source>
          <target state="translated">tf.lite.experimental.nn 네임 스페이스의 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="13c2aa7c571bb2cc2854d88209197394c02081ba" translate="yes" xml:space="preserve">
          <source>Public API for tf.lookup namespace.</source>
          <target state="translated">tf.lookup 네임 스페이스의 공용 API</target>
        </trans-unit>
        <trans-unit id="9b324a29c7abfbcc4ddbbfce3cb85e552fe8286c" translate="yes" xml:space="preserve">
          <source>Public API for tf.lookup.experimental namespace.</source>
          <target state="translated">tf.lookup.experimental 네임 스페이스의 공용 API</target>
        </trans-unit>
        <trans-unit id="92cbc28b13f51b754518b6a8dde6026062618c47" translate="yes" xml:space="preserve">
          <source>Public API for tf.mixed_precision namespace.</source>
          <target state="translated">tf.mixed_precision 네임 스페이스에 대한 공용 API</target>
        </trans-unit>
        <trans-unit id="fd2af371deebcb6a0acb498114b8c22532dad6ba" translate="yes" xml:space="preserve">
          <source>Public API for tf.mixed_precision.experimental namespace.</source>
          <target state="translated">tf.mixed_precision.experimental 네임 스페이스의 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="08627e1db55976dea614c5ac52f74e729e207664" translate="yes" xml:space="preserve">
          <source>Public API for tf.mlir namespace.</source>
          <target state="translated">tf.mlir 네임 스페이스의 공용 API</target>
        </trans-unit>
        <trans-unit id="7c0c8909a8d00d884f64d4b848b859a85a10bfe7" translate="yes" xml:space="preserve">
          <source>Public API for tf.mlir.experimental namespace.</source>
          <target state="translated">tf.mlir.experimental 네임 스페이스의 공용 API</target>
        </trans-unit>
        <trans-unit id="db55082b85b9c3647f843d4df302bf358bf66a42" translate="yes" xml:space="preserve">
          <source>Public API for tf.nest namespace.</source>
          <target state="translated">tf.nest 네임 스페이스에 대한 공개 API.</target>
        </trans-unit>
        <trans-unit id="3bb1dc96eb44efbd4180a3bc79e3cc4e020521e9" translate="yes" xml:space="preserve">
          <source>Public API for tf.profiler namespace.</source>
          <target state="translated">tf.profiler 네임 스페이스의 공용 API</target>
        </trans-unit>
        <trans-unit id="05ee3c23933809d8f00604358068444947f7d29f" translate="yes" xml:space="preserve">
          <source>Public API for tf.quantization namespace.</source>
          <target state="translated">tf.quantization 네임 스페이스의 공용 API</target>
        </trans-unit>
        <trans-unit id="ae76a9dc749424885863913ac8625ad201dab774" translate="yes" xml:space="preserve">
          <source>Public API for tf.queue namespace.</source>
          <target state="translated">tf.queue 네임 스페이스에 대한 공개 API.</target>
        </trans-unit>
        <trans-unit id="146fdfccf6828c1fbf62e6d42342aeb4c475c278" translate="yes" xml:space="preserve">
          <source>Public API for tf.random namespace.</source>
          <target state="translated">tf.random 네임 스페이스의 공용 API</target>
        </trans-unit>
        <trans-unit id="2cbaa718583c57b416db250d6022b71333c9c3a7" translate="yes" xml:space="preserve">
          <source>Public API for tf.random.experimental namespace.</source>
          <target state="translated">tf.random.experimental 네임 스페이스에 대한 공용 API</target>
        </trans-unit>
        <trans-unit id="a590625c30c9755354b800bbb3ca6a424bde149e" translate="yes" xml:space="preserve">
          <source>Public API for tf.raw_ops namespace.</source>
          <target state="translated">tf.raw_ops 네임 스페이스의 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="da04e354419f69a0369a9ee9752f00d2855edc16" translate="yes" xml:space="preserve">
          <source>Public API for tf.saved_model namespace.</source>
          <target state="translated">tf.saved_model 네임 스페이스에 대한 공용 API</target>
        </trans-unit>
        <trans-unit id="9a1417b57e0ad6103caa1b014cdf8906289030ee" translate="yes" xml:space="preserve">
          <source>Public API for tf.saved_model.experimental namespace.</source>
          <target state="translated">tf.saved_model.experimental 네임 스페이스의 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="fa0d49d50c28b68e111ddb5a401f461ae7e8871e" translate="yes" xml:space="preserve">
          <source>Public API for tf.spectral namespace.</source>
          <target state="translated">tf.spectral 네임 스페이스에 대한 공용 API</target>
        </trans-unit>
        <trans-unit id="99943c43fe9c26ea0e55143b54e0b3866e604b00" translate="yes" xml:space="preserve">
          <source>Public API for tf.summary.experimental namespace.</source>
          <target state="translated">tf.summary.experimental 네임 스페이스에 대한 공용 API</target>
        </trans-unit>
        <trans-unit id="09c7ab309e3e5b21db6349fae7e9875650b1d36f" translate="yes" xml:space="preserve">
          <source>Public API for tf.tpu.experimental namespace.</source>
          <target state="translated">tf.tpu.experimental 네임 스페이스에 대한 공개 API</target>
        </trans-unit>
        <trans-unit id="87fca713c144e11b2a6a368a5f67d0357217c5d6" translate="yes" xml:space="preserve">
          <source>Public API for tf.train.experimental namespace.</source>
          <target state="translated">tf.train.experimental 네임 스페이스의 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="24e3d1135aa981ce26b9dd6d3fbfe35fb9c9d3bf" translate="yes" xml:space="preserve">
          <source>Public API for tf.train.queue_runner namespace.</source>
          <target state="translated">tf.train.queue_runner 네임 스페이스에 대한 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="abaaf7d8e4f6c51ca21f240810257d321c5d2793" translate="yes" xml:space="preserve">
          <source>Public API for tf.user_ops namespace.</source>
          <target state="translated">tf.user_ops 네임 스페이스의 퍼블릭 API.</target>
        </trans-unit>
        <trans-unit id="cfb92c89cb53e04c459a11c046bcd2bc308a458f" translate="yes" xml:space="preserve">
          <source>Public API for tf.version namespace.</source>
          <target state="translated">tf.version 네임 스페이스의 공개 API</target>
        </trans-unit>
        <trans-unit id="421722a728515dd9d97eb55931c38685942e1b09" translate="yes" xml:space="preserve">
          <source>Public API for tf.xla namespace.</source>
          <target state="translated">tf.xla 네임 스페이스에 대한 공개 API</target>
        </trans-unit>
        <trans-unit id="750fff145461df375542ee51a37de21f98a0b2a0" translate="yes" xml:space="preserve">
          <source>Public API for tf.xla.experimental namespace.</source>
          <target state="translated">tf.xla.experimental 네임 스페이스에 대한 공용 API</target>
        </trans-unit>
        <trans-unit id="dd530e0dae2cc75ede8b142df153852b9561a8ba" translate="yes" xml:space="preserve">
          <source>Publicly accessible method for determining the current backend.</source>
          <target state="translated">현재 백엔드를 결정하기 위해 공개적으로 액세스 가능한 방법.</target>
        </trans-unit>
        <trans-unit id="2475701b49c6a4c56f3e05da71ec74afd7a11fca" translate="yes" xml:space="preserve">
          <source>Python 2 and 3</source>
          <target state="translated">파이썬 2와 3</target>
        </trans-unit>
        <trans-unit id="e33ad0a39e1919b7258c3e6c8e0f708e15c8adae" translate="yes" xml:space="preserve">
          <source>Python &lt;code&gt;bool&lt;/code&gt; describing behavior when a stat is undefined.</source>
          <target state="translated">스탯이 정의되지 않은 경우 파이썬 &lt;code&gt;bool&lt;/code&gt; 동작을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d4bcbf7fe8cda04487afed1715073c79dae11ae0" translate="yes" xml:space="preserve">
          <source>Python &lt;code&gt;bool&lt;/code&gt; indicating possibly expensive checks are enabled.</source>
          <target state="translated">아마도 비싼 검사가 가능 &lt;code&gt;bool&lt;/code&gt; 나타내는 파이썬 부울 .</target>
        </trans-unit>
        <trans-unit id="78b82cf14a257cb5e2f88a1a2b5fed924d2aa4b8" translate="yes" xml:space="preserve">
          <source>Python &lt;code&gt;integer&lt;/code&gt;.</source>
          <target state="translated">파이썬 &lt;code&gt;integer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a05ca8b5daea68f6003f88b8e194b4fb48d4030" translate="yes" xml:space="preserve">
          <source>Python bool; if &lt;code&gt;True&lt;/code&gt; the TensorArray can grow dynamically.</source>
          <target state="translated">파이썬 부울; 경우 &lt;code&gt;True&lt;/code&gt; TensorArray 동적으로 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17b50a5cbe813d49f8facdaa9666ed00030d4551" translate="yes" xml:space="preserve">
          <source>Python dictionary.</source>
          <target state="translated">파이썬 사전.</target>
        </trans-unit>
        <trans-unit id="fc8c480c05768904f16d54cabe3d12fe434d42d9" translate="yes" xml:space="preserve">
          <source>Python functions for directly manipulating TFRecord-formatted files.</source>
          <target state="translated">TFRecord 형식의 파일을 직접 조작하기위한 Python 함수</target>
        </trans-unit>
        <trans-unit id="9ed5483a9a63274c076822627b8380e64dc0aa98" translate="yes" xml:space="preserve">
          <source>Python integer, or None if the tensor rank is undefined.</source>
          <target state="translated">Python 정수 또는 텐서 순위가 ​​정의되지 않은 경우 None입니다.</target>
        </trans-unit>
        <trans-unit id="ad76baa590950e7fd5f36426f7698844a8eb01af" translate="yes" xml:space="preserve">
          <source>Python numerical arguments should only be used when they take few distinct values, such as hyperparameters like the number of layers in a neural network.</source>
          <target state="translated">파이썬 수치 인수는 신경망의 레이어 수와 같은 하이퍼 파라미터와 같이 별개의 값을 거의 사용하지 않는 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d80d467d7de716042d1ea937402254243119c44" translate="yes" xml:space="preserve">
          <source>Python2 Compatibility</source>
          <target state="translated">Python2 호환성</target>
        </trans-unit>
        <trans-unit id="0635e275dc8f5a579d303113893735d6a2423d13" translate="yes" xml:space="preserve">
          <source>Quantile function. Aka &quot;inverse cdf&quot; or &quot;percent point function&quot;.</source>
          <target state="translated">Quantile 기능. 일명 &quot;역 cdf&quot;또는 &quot;백분율 함수&quot;.</target>
        </trans-unit>
        <trans-unit id="3b03b2625336c702eef541b64c6263f6982757a7" translate="yes" xml:space="preserve">
          <source>Quantization is called fake since the output is still in floating point.</source>
          <target state="translated">출력이 여전히 부동 소수점에 있기 때문에 양자화를 가짜라고합니다.</target>
        </trans-unit>
        <trans-unit id="0ae38d6b0dd638c5950bf5a817fc108aa2ddb100" translate="yes" xml:space="preserve">
          <source>Quantize the 'input' tensor of type float to 'output' tensor of type 'T'.</source>
          <target state="translated">float 유형의 'input'텐서를 'T'유형의 'output'텐서로 수량화하십시오.</target>
        </trans-unit>
        <trans-unit id="3ae11653f6030d8c44bb8ba496a25e7c50a657ac" translate="yes" xml:space="preserve">
          <source>Quantizes then dequantizes a tensor.</source>
          <target state="translated">텐서를 양자화 한 다음 양자화합니다.</target>
        </trans-unit>
        <trans-unit id="cd1a01e766e73806e7f1deb9b803b49b992051db" translate="yes" xml:space="preserve">
          <source>QueueRunners are not compatible with eager execution. Instead, please use &lt;a href=&quot;../../../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; to get data into your model.</source>
          <target state="translated">QueueRunner는 열망하는 실행과 호환되지 않습니다. 대신, &lt;a href=&quot;../../../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt; 를 사용 하여 데이터를 모델로 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="f2e16776529ec20e7ab9880048db6446f999b28a" translate="yes" xml:space="preserve">
          <source>Queues are a convenient TensorFlow mechanism to compute tensors asynchronously using multiple threads. For example in the canonical 'Input Reader' setup one set of threads generates filenames in a queue; a second set of threads read records from the files, processes them, and enqueues tensors on a second queue; a third set of threads dequeues these input records to construct batches and runs them through training operations.</source>
          <target state="translated">큐는 여러 스레드를 사용하여 비동기 적으로 텐서를 계산하는 편리한 TensorFlow 메커니즘입니다. 예를 들어 표준 '입력 리더'설정에서 하나의 스레드 세트가 대기열에 파일 이름을 생성합니다. 제 2 스레드 세트는 파일로부터 레코드를 읽고, 처리하고, 제 2 큐에 텐서를 큐잉하고; 세 번째 스레드 세트는 이러한 입력 레코드를 큐에서 제거하여 배치를 구성하고이를 훈련 작업을 통해 실행합니다.</target>
        </trans-unit>
        <trans-unit id="1742c084ada33668bc9c277ea9c4c6548a7c704e" translate="yes" xml:space="preserve">
          <source>Queues are not compatible with eager execution. To ingest data when eager execution is enabled, use the &lt;a href=&quot;../../../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; API.</source>
          <target state="translated">큐는 열망하는 실행과 호환되지 않습니다. 열망하는 실행이 활성화 된 경우 데이터를 수집하려면 &lt;a href=&quot;../../../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt; API를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f478dcc53daf61b3b48ee35fa4c1da6822da711" translate="yes" xml:space="preserve">
          <source>RFC 4180 format is expected for the CSV records. (https://tools.ietf.org/html/rfc4180) Note that we allow leading and trailing spaces with int or float field.</source>
          <target state="translated">CSV 레코드에는 RFC 4180 형식이 필요합니다. (https://tools.ietf.org/html/rfc4180) int 또는 float 필드를 사용하여 선행 및 후행 공백을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="31442f7d075565e096ca320749812a82d7932483" translate="yes" xml:space="preserve">
          <source>RNN cell composed sequentially of multiple simple cells.</source>
          <target state="translated">RNN 셀은 여러 개의 간단한 셀로 순차적으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="8ffd14bb271a3402d66695d560d27e2af773d6fc" translate="yes" xml:space="preserve">
          <source>RNN that accepts a state saver for time-truncated RNN calculation. (deprecated)</source>
          <target state="translated">RNN 계산을 위해 상태 보호기를 허용하는 RNN. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="bd2c34b20ca59db3a6440066fbffd8c1187ee1b4" translate="yes" xml:space="preserve">
          <source>RNNCell wrapper that ensures cell inputs are added to the outputs.</source>
          <target state="translated">셀 입력이 출력에 추가되도록하는 RNNCell 랩퍼.</target>
        </trans-unit>
        <trans-unit id="aa5ee495e246a9d4a049acbca904000403e5fa55" translate="yes" xml:space="preserve">
          <source>Ragged Tensors.</source>
          <target state="translated">비정형 텐서.</target>
        </trans-unit>
        <trans-unit id="9df8e83edbc3a7baecb751992f609d264501bd3b" translate="yes" xml:space="preserve">
          <source>Ragged tensors</source>
          <target state="translated">비정형 텐서</target>
        </trans-unit>
        <trans-unit id="02a5419401d210fc6cfe07793f457cdc48b3b588" translate="yes" xml:space="preserve">
          <source>Raised if there is a flag naming conflict.</source>
          <target state="translated">플래그 명명 충돌이있는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b2d3e64b7cf2a4ba230ba51fca3bf982c6e792a5" translate="yes" xml:space="preserve">
          <source>Raised when a deadline expires before an operation could complete.</source>
          <target state="translated">작업이 완료되기 전에 최종 기한이 만료되면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f35d3b28902e6af5a71becef5a3e027b976d8dcf" translate="yes" xml:space="preserve">
          <source>Raised when a flag is unrecognized.</source>
          <target state="translated">플래그가 인식되지 않을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3e34deebb30b5ba82fd1285a32163176714333e8" translate="yes" xml:space="preserve">
          <source>Raised when a flag name conflicts with FlagValues methods.</source>
          <target state="translated">플래그 이름이 FlagValues ​​메소드와 충돌 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1f5bc090792b5a1c5005c5f6ea3c3476c4158875" translate="yes" xml:space="preserve">
          <source>Raised when a requested entity (e.g., a file or directory) was not found.</source>
          <target state="translated">요청 된 엔티티 (예 : 파일 또는 디렉토리)를 찾을 수 없을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="02ba9549d2176523e5c3ced9903cb39bfda66f34" translate="yes" xml:space="preserve">
          <source>Raised when accessing the flag value from unparsed FlagValues.</source>
          <target state="translated">구문 분석되지 않은 FlagValue에서 플래그 값에 액세스 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0ae67ae659d4f9c87107299d6982f1b560efbbcd" translate="yes" xml:space="preserve">
          <source>Raised when an entity that we attempted to create already exists.</source>
          <target state="translated">우리가 만들려고 한 엔티티가 이미 존재할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f06e6887f7b287d17b44c4cff6fc385f5a863dc3" translate="yes" xml:space="preserve">
          <source>Raised when an operation has not been implemented.</source>
          <target state="translated">작업이 구현되지 않은 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f63d446c39b0a3fa40e4468187e7d519ee6e0745" translate="yes" xml:space="preserve">
          <source>Raised when an operation iterates past the valid input range.</source>
          <target state="translated">작업이 유효한 입력 범위를 초과 할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="da2516468163e92478b102f199e3f659bb5d5ff5" translate="yes" xml:space="preserve">
          <source>Raised when an operation or step is cancelled.</source>
          <target state="translated">작업 또는 단계가 취소되면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="15f257ed5cb87fae74794ffaae5b8d3332c37291" translate="yes" xml:space="preserve">
          <source>Raised when an operation receives an invalid argument.</source>
          <target state="translated">작업이 잘못된 인수를 받으면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="78664ee08378e46c140d1654d705e084e0d423d2" translate="yes" xml:space="preserve">
          <source>Raised when flag validator constraint is not satisfied.</source>
          <target state="translated">플래그 유효성 검사기 제약 조건이 충족되지 않으면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="64518a998948d4fb4b3c525adbeae88332436ffb" translate="yes" xml:space="preserve">
          <source>Raised when flagfile fails to open.</source>
          <target state="translated">플래그 파일이 열리지 않으면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="69922c371e88bf1f7ef5cd9000995bbd577147c5" translate="yes" xml:space="preserve">
          <source>Raised when the caller does not have permission to run an operation.</source>
          <target state="translated">호출자에게 작업을 실행할 권한이 없을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1bcc79886554f3612aa7c3044b1209c9f1f0ab4d" translate="yes" xml:space="preserve">
          <source>Raised when the flag command line argument is illegal.</source>
          <target state="translated">플래그 명령 행 인수가 유효하지 않은 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a0d94d1d7fe4f59c631af3fb575ee3f072d2c47c" translate="yes" xml:space="preserve">
          <source>Raised when the runtime is currently unavailable.</source>
          <target state="translated">런타임을 현재 사용할 수 없을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="935ffefb4b7946fee3346a057661a07fc35b28fd" translate="yes" xml:space="preserve">
          <source>Raised when the system experiences an internal error.</source>
          <target state="translated">시스템에 내부 오류가 발생하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0824f9ce8ee6a9a61d37123916020f8fba459f6f" translate="yes" xml:space="preserve">
          <source>Raised when unrecoverable data loss or corruption is encountered.</source>
          <target state="translated">복구 할 수없는 데이터 손실 또는 손상이 발생하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c36d9458e0d1baae7403b5ce642a78b09e4acc7f" translate="yes" xml:space="preserve">
          <source>Raises</source>
          <target state="translated">Raises</target>
        </trans-unit>
        <trans-unit id="f9a16ac72ef6c9d7c400331bb394067bba770be3" translate="yes" xml:space="preserve">
          <source>Raises AssertionError if a and b are not equal dictionaries.</source>
          <target state="translated">a와 b가 같은 사전이 아닌 경우 AssertionError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="ed9da2b877dfe8a9c867607689612de5885bf471" translate="yes" xml:space="preserve">
          <source>Raises TypeError: if &lt;code&gt;dataset&lt;/code&gt; is not a &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt;. TypeError: if the elements produced by the dataset are not scalar strings.</source>
          <target state="translated">형식 오류가 발생시킵니다 : 경우 &lt;code&gt;dataset&lt;/code&gt; 하지 않은 것입니다 &lt;a href=&quot;../dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; . TypeError : 데이터 집합에서 생성 된 요소가 스칼라 문자열이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="a67d89a4ce0cf4a0f8d774ca23677a079bcf1f56" translate="yes" xml:space="preserve">
          <source>Raises an exception if &lt;code&gt;other&lt;/code&gt; is not compatible with this Dimension.</source>
          <target state="translated">&lt;code&gt;other&lt;/code&gt; 차원이이 차원과 호환되지 않으면 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="099b34a9797a27a7db554e95bb1e5b7c483d426a" translate="yes" xml:space="preserve">
          <source>Raises an exception if &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; do not have compatible ranks.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 과 &lt;code&gt;other&lt;/code&gt; 등급이 호환되지 않으면 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="4e637fcd7c60ccc3e5e8a18f36c4b26334e89e87" translate="yes" xml:space="preserve">
          <source>Raises an exception if &lt;code&gt;self&lt;/code&gt; is not compatible with the given &lt;code&gt;rank&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 주어진 &lt;code&gt;rank&lt;/code&gt; 와 호환되지 않으면 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="f95c1f0958622be62008a71a7a1ae373c867275c" translate="yes" xml:space="preserve">
          <source>Raises an exception if &lt;code&gt;self&lt;/code&gt; is not fully defined in every dimension.</source>
          <target state="translated">모든 차원에서 &lt;code&gt;self&lt;/code&gt; 가 완전히 정의되지 않은 경우 예외가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="c3e67f892b85ce98e5bf19974ec6165f164e3b3c" translate="yes" xml:space="preserve">
          <source>Raises exception if &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; do not represent the same shape.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 과 &lt;code&gt;other&lt;/code&gt; 이 같은 모양을 나타내지 않으면 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="e0eb5268f437200e3ca42ec2d178bdfb80e8e252" translate="yes" xml:space="preserve">
          <source>Raises:</source>
          <target state="translated">Raises:</target>
        </trans-unit>
        <trans-unit id="64da9921d6b5e3126a2d4d767aec2d0a4c8006e3" translate="yes" xml:space="preserve">
          <source>Raises: ValueError if called with incompatible shapes.</source>
          <target state="translated">호환되지 않는 모양으로 호출 된 경우 ValueError</target>
        </trans-unit>
        <trans-unit id="63bab5a3619f2bf89e17c0703ceb049db4811309" translate="yes" xml:space="preserve">
          <source>Raises: ValueError: &lt;code&gt;axis&lt;/code&gt; is neither 0 or 1.</source>
          <target state="translated">발생합니다 : ValueError : &lt;code&gt;axis&lt;/code&gt; 이 0 또는 1이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3f0ede75276426d213c95185f57fff7351ba0c77" translate="yes" xml:space="preserve">
          <source>Raises: ValueError: if the shape inference fails.</source>
          <target state="translated">발생합니다 : ValueError : 모양 유추에 실패한 경우.</target>
        </trans-unit>
        <trans-unit id="66f55b5afb8cd6a93b5180e7b572fe50d943b337" translate="yes" xml:space="preserve">
          <source>Raises: ValueError: if there are more writers than specified.</source>
          <target state="translated">발생 : ValueError : 지정된 것보다 많은 작성자가있는 경우.</target>
        </trans-unit>
        <trans-unit id="0c6eab1f53c119ddc5d528a760b4050c34c732d4" translate="yes" xml:space="preserve">
          <source>Random number generation</source>
          <target state="translated">난수 생성</target>
        </trans-unit>
        <trans-unit id="d7d8d905a619dfcb98083660ada6bac0c32ebaaf" translate="yes" xml:space="preserve">
          <source>Random-number generator.</source>
          <target state="translated">난수 생성기.</target>
        </trans-unit>
        <trans-unit id="e4d7a547bb12c287bc9083185947a2402d77fbba" translate="yes" xml:space="preserve">
          <source>RandomNormal instance.</source>
          <target state="translated">RandomNormal 인스턴스.</target>
        </trans-unit>
        <trans-unit id="6c09ada8e86215312971bfd1b8ae691b57521693" translate="yes" xml:space="preserve">
          <source>Randomly changes jpeg encoding quality for inducing jpeg noise.</source>
          <target state="translated">JPEG 노이즈를 유도하기 위해 JPEG 인코딩 품질을 임의로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="8d027ff04ec3184dc67b9da7f1e79fab0e178a41" translate="yes" xml:space="preserve">
          <source>Randomly crops a tensor to a given size.</source>
          <target state="translated">주어진 크기로 텐서를 무작위로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="dc093733be12bcd7aedcf02917a08032d237428d" translate="yes" xml:space="preserve">
          <source>Randomly flip a single image.</source>
          <target state="translated">단일 이미지를 임의로 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="5f0be3270b7de1e6d4a1d7b529742127c54459cf" translate="yes" xml:space="preserve">
          <source>Randomly flip an image horizontally (left to right).</source>
          <target state="translated">이미지를 좌우로 무작위로 뒤집습니다 (왼쪽에서 오른쪽으로).</target>
        </trans-unit>
        <trans-unit id="0f624c88d8d6470dcb910e0fe43f975452fc14ea" translate="yes" xml:space="preserve">
          <source>Randomly flip multiple images.</source>
          <target state="translated">여러 이미지를 임의로 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="14f808e1ed65da818399464f55e822d7438a1b71" translate="yes" xml:space="preserve">
          <source>Randomly flips an image vertically (upside down).</source>
          <target state="translated">이미지를 임의로 수직으로 뒤집습니다 (거꾸로).</target>
        </trans-unit>
        <trans-unit id="f85e2f51067ecee6529ba3eb3e42b379423d299b" translate="yes" xml:space="preserve">
          <source>Randomly shuffles a tensor along its first dimension.</source>
          <target state="translated">첫 번째 치수를 따라 임의로 텐서를 섞습니다.</target>
        </trans-unit>
        <trans-unit id="dc0cbbf0d473db47ebfd70b7f9dd8c6c220d47c4" translate="yes" xml:space="preserve">
          <source>Randomly shuffles the elements of this dataset.</source>
          <target state="translated">이 데이터 세트의 요소를 임의로 섞습니다.</target>
        </trans-unit>
        <trans-unit id="151798cbdc40731d64c085a4789a6aac1b36b427" translate="yes" xml:space="preserve">
          <source>Rank (in the sense of tensors) of matrix corresponding to this operator.</source>
          <target state="translated">이 연산자에 해당하는 행렬의 순위 (텐서 의미)입니다.</target>
        </trans-unit>
        <trans-unit id="9beaa97411f31931aab7bfe4dde832a190e17b96" translate="yes" xml:space="preserve">
          <source>Rate parameter.</source>
          <target state="translated">요율 매개 변수.</target>
        </trans-unit>
        <trans-unit id="7bb99667b41dfb582d22b4513e3c372351e27796" translate="yes" xml:space="preserve">
          <source>Read &lt;a href=&quot;https://tensorflow.org/api_docs/python/tf/math#Segmentation&quot;&gt;the section on segmentation&lt;/a&gt; for an explanation of segments.</source>
          <target state="translated">&lt;a href=&quot;https://tensorflow.org/api_docs/python/tf/math#Segmentation&quot;&gt;세그먼트&lt;/a&gt; 에 대한 설명은 세그먼트에 대한 섹션을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="36f39358547cff710506e19ec1a07d3389f917fe" translate="yes" xml:space="preserve">
          <source>Read &lt;a href=&quot;https://www.tensorflow.org/versions/r2.0/api_docs/python/tf/math#about_segmentation&quot;&gt;the section on segmentation&lt;/a&gt; for an explanation of segments.</source>
          <target state="translated">&lt;a href=&quot;https://www.tensorflow.org/versions/r2.0/api_docs/python/tf/math#about_segmentation&quot;&gt;세그먼트&lt;/a&gt; 에 대한 설명은 세그먼트에 대한 섹션을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="44ed69b4f2171954ccc6b57657687d5d5e341309" translate="yes" xml:space="preserve">
          <source>Read more about Skipgram in this gnomic paper by Mikolov et al.: &lt;a href=&quot;http://arxiv.org/pdf/1301.3781v3.pdf&quot;&gt;Efficient Estimation of Word Representations in Vector Space&lt;/a&gt;</source>
          <target state="translated">Mikolov et al .: &lt;a href=&quot;http://arxiv.org/pdf/1301.3781v3.pdf&quot;&gt;Vector Space에서 단어 표현의 효율적인 추정&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab93aab779af709c10ce5b45fa8fcf440ba905cd" translate="yes" xml:space="preserve">
          <source>Read more at https://www.tensorflow.org/guide/extend/architecture</source>
          <target state="translated">https://www.tensorflow.org/guide/extend/architecture에서 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="8966353927d79cebf41b0c5d833b1bebdd4bbcab" translate="yes" xml:space="preserve">
          <source>Read the value at location &lt;code&gt;index&lt;/code&gt; in the TensorArray.</source>
          <target state="translated">TensorArray 에서 위치 &lt;code&gt;index&lt;/code&gt; 의 값을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="02cb2660356658c21155a3545cc459a0618eb12a" translate="yes" xml:space="preserve">
          <source>Read-only properties: name: The name of the layer (string). dtype: Default dtype of the layer's weights (default of &lt;code&gt;None&lt;/code&gt; means use the type of the first input). trainable_variables: List of trainable variables. non_trainable_variables: List of non-trainable variables. variables: List of all variables of this layer, trainable and non-trainable. updates: List of update ops of this layer. losses: List of losses added by this layer. trainable_weights: List of variables to be included in backprop. non_trainable_weights: List of variables that should not be included in backprop. weights: The concatenation of the lists trainable_weights and non_trainable_weights (in this order).</source>
          <target state="translated">읽기 전용 속성 : name : 레이어 이름 (문자열). dtype : 레이어 가중치의 기본 dtype입니다 (기본값 &lt;code&gt;None&lt;/code&gt; 은 첫 번째 입력 유형을 사용함을 의미합니다). trainable_variables : 학습 가능한 변수 목록. non_trainable_variables : 훈련 불가능 변수 목록. 변수 :이 계층의 모든 변수 목록 (훈련 가능 및 훈련 불가능). 업데이트 :이 계층의 업데이트 작업 목록입니다. loss :이 계층에 의해 추가 된 손실 목록. trainable_weights : 백프로 프에 포함될 변수 목록. non_trainable_weights : 백프로 프에 포함되어서는 안되는 변수 목록. 가중치 : trainable_weights 및 non_trainable_weights 목록의 연결 (순서대로)</target>
        </trans-unit>
        <trans-unit id="17e75bcdc8e06928b4da6fa7a4955c72999c3da7" translate="yes" xml:space="preserve">
          <source>Read-only properties: name: The name of the layer (string). dtype: The dtype of the layer's computations and weights. If mixed precision is used with a &lt;a href=&quot;../mixed_precision/experimental/policy&quot;&gt;&lt;code&gt;tf.keras.mixed_precision.experimental.Policy&lt;/code&gt;&lt;/a&gt;, this is instead just the dtype of the layer's weights, as the computations are done in a different dtype. updates: List of update ops of this layer. losses: List of losses added by this layer. trainable_weights: List of variables to be included in backprop. non_trainable_weights: List of variables that should not be included in backprop. weights: The concatenation of the lists trainable_weights and non_trainable_weights (in this order).</source>
          <target state="translated">읽기 전용 속성 : name : 레이어 이름 (문자열). dtype : 레이어 계산 및 가중치의 dtype입니다. 혼합 정밀도가 &lt;a href=&quot;../mixed_precision/experimental/policy&quot;&gt; &lt;code&gt;tf.keras.mixed_precision.experimental.Policy&lt;/code&gt; &lt;/a&gt; 와 함께 사용되는 경우 계산은 다른 dtype에서 수행되므로 레이어 가중치의 dtype입니다. 업데이트 :이 계층의 업데이트 작업 목록입니다. loss :이 계층에 의해 추가 된 손실 목록. trainable_weights : 백프로 프에 포함될 변수 목록. non_trainable_weights : 백프로 프에 포함되어서는 안되는 변수 목록. 가중치 : trainable_weights 및 non_trainable_weights 목록의 연결 (순서대로)</target>
        </trans-unit>
        <trans-unit id="a61c4f92531eda7ccfbe13aaf7074519b753b5bd" translate="yes" xml:space="preserve">
          <source>Readahead files not implemented; simply returns given path.</source>
          <target state="translated">Readahead 파일이 구현되지 않았습니다. 주어진 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9dcbdc5517e434bdfe2d5eb7d2765fd47be3ed50" translate="yes" xml:space="preserve">
          <source>Readers are not compatible with eager execution. Instead, please use &lt;a href=&quot;../../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; to get data into your model.</source>
          <target state="translated">독자는 열망하는 실행과 호환되지 않습니다. 대신, &lt;a href=&quot;../../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt; 를 사용 하여 데이터를 모델로 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="5e7d19d02e158869ddbebeda20b648d628ee5911" translate="yes" xml:space="preserve">
          <source>Reads CSV files into a dataset, where each element is a (features, labels) tuple that corresponds to a batch of CSV rows. The features dictionary maps feature column names to &lt;code&gt;Tensor&lt;/code&gt;s containing the corresponding feature data, and labels is a &lt;code&gt;Tensor&lt;/code&gt; containing the batch's label data.</source>
          <target state="translated">CSV 파일을 데이터 세트로 읽습니다. 여기서 각 요소는 일련의 CSV 행에 해당하는 (기능, 레이블) 튜플입니다. 기능 사전은 기능 열 이름을 해당 기능 데이터가 포함 된 &lt;code&gt;Tensor&lt;/code&gt; 에 맵핑 하고 레이블은 배치의 레이블 데이터가 포함 된 &lt;code&gt;Tensor&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="58d86b97a7b246fc939469e2d8fe5b8ae2eb3b2c" translate="yes" xml:space="preserve">
          <source>Reads CSV files into a dataset.</source>
          <target state="translated">CSV 파일을 데이터 세트로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="e1a5a364b8ba9f0d10ad50b5109800350e1064c4" translate="yes" xml:space="preserve">
          <source>Reads and outputs the entire contents of the input filename.</source>
          <target state="translated">입력 파일 이름의 전체 내용을 읽고 출력합니다.</target>
        </trans-unit>
        <trans-unit id="ceee15a0f442f3c41ef088635bac9a0c1f7d4193" translate="yes" xml:space="preserve">
          <source>Reads the next line from the file. Leaves the '\n' at the end.</source>
          <target state="translated">파일에서 다음 줄을 읽습니다. 끝에 '\ n'을 남깁니다.</target>
        </trans-unit>
        <trans-unit id="f2f28f8966a9a36d7d20080250311492ecae3fd7" translate="yes" xml:space="preserve">
          <source>Reads the value of a variable.</source>
          <target state="translated">변수의 값을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="81675ca7fddc8f659b51898578c9a5c684ae1549" translate="yes" xml:space="preserve">
          <source>Real-valued fast Fourier transform.</source>
          <target state="translated">진정한 고속 푸리에 변환.</target>
        </trans-unit>
        <trans-unit id="eea2df8ac2bb85a68b87dccd35351eef5237d72a" translate="yes" xml:space="preserve">
          <source>Rearranges (permutes) data from batch into blocks of spatial data, followed by cropping. This is the reverse transformation of SpaceToBatch. More specifically, this op outputs a copy of the input tensor where values from the &lt;code&gt;batch&lt;/code&gt; dimension are moved in spatial blocks to the &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; dimensions, followed by cropping along the &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; dimensions.</source>
          <target state="translated">배치에서 공간 데이터 블록으로 데이터를 재 배열 (순열) 한 다음 잘라냅니다. 이것은 SpaceToBatch의 역변환입니다. 구체적으로는,이 연산은 입력의 값 텐서의 카피 출력 &lt;code&gt;batch&lt;/code&gt; 치수는 공간을 블록으로 이동 &lt;code&gt;height&lt;/code&gt; 및 &lt;code&gt;width&lt;/code&gt; 치수는 다음에 따라 잘라내어 &lt;code&gt;height&lt;/code&gt; 및 &lt;code&gt;width&lt;/code&gt; 치수.</target>
        </trans-unit>
        <trans-unit id="6a75f08be773e063aee00d3a38d7ca8690bdc215" translate="yes" xml:space="preserve">
          <source>Rearranges blocks of spatial data, into depth. More specifically, this op outputs a copy of the input tensor where values from the &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; dimensions are moved to the &lt;code&gt;depth&lt;/code&gt; dimension. The attr &lt;code&gt;block_size&lt;/code&gt; indicates the input block size.</source>
          <target state="translated">공간 데이터 블록을 깊이로 재 배열합니다. 보다 구체적으로,이 op는 &lt;code&gt;height&lt;/code&gt; 및 &lt;code&gt;width&lt;/code&gt; 치수 의 값 이 &lt;code&gt;depth&lt;/code&gt; 치수 로 이동 되는 입력 텐서의 사본을 출력 합니다. attr &lt;code&gt;block_size&lt;/code&gt; 는 입력 블록 크기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="338cce58d5eb23fb57650627ce326ba5e68dc2fb" translate="yes" xml:space="preserve">
          <source>Rearranges data from depth into blocks of spatial data. This is the reverse transformation of SpaceToDepth. More specifically, this op outputs a copy of the input tensor where values from the &lt;code&gt;depth&lt;/code&gt; dimension are moved in spatial blocks to the &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; dimensions. The attr &lt;code&gt;block_size&lt;/code&gt; indicates the input block size and how the data is moved.</source>
          <target state="translated">깊이에서 공간 데이터 블록으로 데이터를 재정렬합니다. 이것은 SpaceToDepth의 역변환입니다. 보다 구체적으로,이 op는 &lt;code&gt;depth&lt;/code&gt; 차원의 값 이 공간 블록에서 &lt;code&gt;height&lt;/code&gt; 및 &lt;code&gt;width&lt;/code&gt; 차원 으로 이동 되는 입력 텐서의 사본을 출력 합니다. attr &lt;code&gt;block_size&lt;/code&gt; 는 입력 블록 크기와 데이터 이동 방법을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ca53dd1845505323452481c167fd690bc4b2cd20" translate="yes" xml:space="preserve">
          <source>Reasonable values for &lt;code&gt;decay&lt;/code&gt; are close to 1.0, typically in the multiple-nines range: 0.999, 0.9999, etc.</source>
          <target state="translated">&lt;code&gt;decay&lt;/code&gt; 합리적인 값은 1.0에 가깝습니다. 일반적으로 0.999, 0.9999 등의 배수 아홉 범위입니다.</target>
        </trans-unit>
        <trans-unit id="a8f09725017867b7413aa04d3e8170b0442af991" translate="yes" xml:space="preserve">
          <source>Recommended usage:</source>
          <target state="translated">권장 사용법 :</target>
        </trans-unit>
        <trans-unit id="2d40a3d4b23c33dba91182fa7193e3bc8d084647" translate="yes" xml:space="preserve">
          <source>Recommended:</source>
          <target state="translated">Recommended:</target>
        </trans-unit>
        <trans-unit id="0858cfed23eb0d3a195ae64a7ddfb0141e2e7c5a" translate="yes" xml:space="preserve">
          <source>Reconstructs a signal from a framed representation.</source>
          <target state="translated">프레임 표현에서 신호를 재구성합니다.</target>
        </trans-unit>
        <trans-unit id="5b2d7646abb703ab25663c89425f84ea266a427c" translate="yes" xml:space="preserve">
          <source>Record operations for automatic differentiation.</source>
          <target state="translated">자동 차별화를위한 기록 작업.</target>
        </trans-unit>
        <trans-unit id="c53343697c5db816b66bc005051d63fbf0cf9bc2" translate="yes" xml:space="preserve">
          <source>Record the full path to the asset.</source>
          <target state="translated">자산의 전체 경로를 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="121cabacb59bd358fbc34af2baed3e09272cd7da" translate="yes" xml:space="preserve">
          <source>Records the latency of producing each element of the input dataset.</source>
          <target state="translated">입력 데이터 세트의 각 요소를 생성하는 대기 시간을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="1f65944af649fb7b101ae2b7f78e2ccc1a5fcbbc" translate="yes" xml:space="preserve">
          <source>Records the module that defines a specific flag.</source>
          <target state="translated">특정 플래그를 정의하는 모듈을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="c4f99594cf2d0db27044c7589bcfa5d1589097de" translate="yes" xml:space="preserve">
          <source>Records the number of bytes produced by each element of the input dataset.</source>
          <target state="translated">입력 데이터 세트의 각 요소에서 생성 된 바이트 수를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="eb3fd2693632a80f6ab651de647c3772183fd99a" translate="yes" xml:space="preserve">
          <source>Recovers the internal saver state after a crash.</source>
          <target state="translated">충돌 후 내부 보호기 상태를 복구합니다.</target>
        </trans-unit>
        <trans-unit id="3c3fe92060378df6fc0c0619c59c0a5fd4166d6f" translate="yes" xml:space="preserve">
          <source>Recreates a Graph saved in a &lt;code&gt;MetaGraphDef&lt;/code&gt; proto.</source>
          <target state="translated">&lt;code&gt;MetaGraphDef&lt;/code&gt; 프로토 타입에 저장된 그래프를 재생성합니다 .</target>
        </trans-unit>
        <trans-unit id="c862e7427eac42aa3c06b898d6b077375e8b86e1" translate="yes" xml:space="preserve">
          <source>Rectified Linear Unit activation function.</source>
          <target state="translated">정류 선형 유닛 활성화 기능.</target>
        </trans-unit>
        <trans-unit id="ba709a9e2232a86b22af235a759b19c4998555ba" translate="yes" xml:space="preserve">
          <source>Rectified linear unit.</source>
          <target state="translated">정류 된 선형 단위.</target>
        </trans-unit>
        <trans-unit id="d18425438cb3938f31c468d487e641745f2e7cec" translate="yes" xml:space="preserve">
          <source>Recurrent Neural Networks (RNN) with Keras</source>
          <target state="translated">Keras를 사용한 반복적 인 신경망 (RNN)</target>
        </trans-unit>
        <trans-unit id="520085b15bf2b7bf075147f0a78d8d43c2f285c2" translate="yes" xml:space="preserve">
          <source>Recursive directory tree generator for directories.</source>
          <target state="translated">디렉토리의 재귀 디렉토리 트리 생성기.</target>
        </trans-unit>
        <trans-unit id="c12a034607ac15db7dca3770211122295202a3ec" translate="yes" xml:space="preserve">
          <source>Reduce &lt;code&gt;per_replica_value&lt;/code&gt; to &lt;code&gt;destinations&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;per_replica_value&lt;/code&gt; 를 &lt;code&gt;destinations&lt;/code&gt; 줄 입니다 .</target>
        </trans-unit>
        <trans-unit id="9ab3281eeca5bea20af9dbb1ac4dcdf614eadf2b" translate="yes" xml:space="preserve">
          <source>Reduce &lt;code&gt;value&lt;/code&gt; across replicas.</source>
          <target state="translated">복제본 전체의 &lt;code&gt;value&lt;/code&gt; 를 줄 입니다.</target>
        </trans-unit>
        <trans-unit id="a601cb7ccef08b333eee77d0428a7d939504d07d" translate="yes" xml:space="preserve">
          <source>Reduce PerReplica objects in a batch.</source>
          <target state="translated">PerReplica 객체를 일괄 적으로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="963e809fe39c7b647b6cc83db942c6f84abea642" translate="yes" xml:space="preserve">
          <source>Reduce each first element in &lt;code&gt;value_destination_pairs&lt;/code&gt; to each second element which indicates the destinations.</source>
          <target state="translated">&lt;code&gt;value_destination_pairs&lt;/code&gt; 의 각 첫 번째 요소를 대상을 나타내는 각 두 번째 요소로 줄 입니다.</target>
        </trans-unit>
        <trans-unit id="1158e9c16a20015082a4123eb4d2c6a51474c844" translate="yes" xml:space="preserve">
          <source>Reduce elems using fn to combine them from left to right.</source>
          <target state="translated">fn을 사용하여 왼쪽에서 오른쪽으로 결합하는 요소를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="90b8ba517f0e0a53b6ef5551b1dcf391961c68a0" translate="yes" xml:space="preserve">
          <source>Reduce elems using fn to combine them from right to left.</source>
          <target state="translated">fn을 사용하여 오른쪽에서 왼쪽으로 결합하는 요소를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="740c8acdc623bb40d8470ec72e7c359f99f4428f" translate="yes" xml:space="preserve">
          <source>Reduce learning rate when a metric has stopped improving.</source>
          <target state="translated">메트릭 개선이 중단되면 학습 속도를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="8662c3b063fbb9c4dc03b1b2a4269246143d14fa" translate="yes" xml:space="preserve">
          <source>Reduces &lt;code&gt;input&lt;/code&gt; along the dimensions given in &lt;code&gt;axis&lt;/code&gt;. Unless &lt;code&gt;keepdims&lt;/code&gt; is true, the rank of the tensor is reduced by 1 for each entry in &lt;code&gt;axis&lt;/code&gt;. If &lt;code&gt;keepdims&lt;/code&gt; is true, the reduced dimensions are retained with length 1.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 에 지정된 치수를 따라 &lt;code&gt;input&lt;/code&gt; 을 줄 입니다. &lt;code&gt;keepdims&lt;/code&gt; 가 true가 아닌 한 , 텐서의 순위는 &lt;code&gt;axis&lt;/code&gt; 의 각 항목마다 1 씩 줄어 듭니다 . 경우 &lt;code&gt;keepdims&lt;/code&gt; 는 사실, 감소 된 치수는 길이가 1로 유지된다.</target>
        </trans-unit>
        <trans-unit id="224d86f0a80ce274a2a0ad741b23ff7344d8022a" translate="yes" xml:space="preserve">
          <source>Reduces &lt;code&gt;input_tensor&lt;/code&gt; along the dimensions given in &lt;code&gt;axis&lt;/code&gt;. Unless &lt;code&gt;keepdims&lt;/code&gt; is true, the rank of the tensor is reduced by 1 for each entry in &lt;code&gt;axis&lt;/code&gt;. If &lt;code&gt;keepdims&lt;/code&gt; is true, the reduced dimensions are retained with length 1.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 에 지정된 치수를 따라 &lt;code&gt;input_tensor&lt;/code&gt; 를 줄 입니다. &lt;code&gt;keepdims&lt;/code&gt; 가 true가 아닌 한 , 텐서의 순위는 &lt;code&gt;axis&lt;/code&gt; 의 각 항목마다 1 씩 줄어 듭니다 . 경우 &lt;code&gt;keepdims&lt;/code&gt; 는 사실, 감소 된 치수는 길이가 1로 유지된다.</target>
        </trans-unit>
        <trans-unit id="5a1976e22d95ac2a748fbc7cd67b19d774bd09fd" translate="yes" xml:space="preserve">
          <source>Reduces &lt;code&gt;sp_input&lt;/code&gt; along the dimensions given in &lt;code&gt;axis&lt;/code&gt;. Unless &lt;code&gt;keepdims&lt;/code&gt; is true, the rank of the tensor is reduced by 1 for each entry in &lt;code&gt;axis&lt;/code&gt;. If &lt;code&gt;keepdims&lt;/code&gt; is true, the reduced dimensions are retained with length 1.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 에 지정된 치수를 따라 &lt;code&gt;sp_input&lt;/code&gt; 을 줄 입니다. &lt;code&gt;keepdims&lt;/code&gt; 가 true가 아닌 한 , 텐서의 순위는 &lt;code&gt;axis&lt;/code&gt; 의 각 항목마다 1 씩 줄어 듭니다 . 경우 &lt;code&gt;keepdims&lt;/code&gt; 는 사실, 감소 된 치수는 길이가 1로 유지된다.</target>
        </trans-unit>
        <trans-unit id="70cdc3698dad551c97f3c27f75672c79bf735119" translate="yes" xml:space="preserve">
          <source>Reduces &lt;code&gt;sp_input&lt;/code&gt; along the dimensions given in &lt;code&gt;reduction_axes&lt;/code&gt;. Unless &lt;code&gt;keepdims&lt;/code&gt; is true, the rank of the tensor is reduced by 1 for each entry in &lt;code&gt;reduction_axes&lt;/code&gt;. If &lt;code&gt;keepdims&lt;/code&gt; is true, the reduced dimensions are retained with length 1.</source>
          <target state="translated">&lt;code&gt;reduction_axes&lt;/code&gt; 에 지정된 치수를 따라 &lt;code&gt;sp_input&lt;/code&gt; 을 줄 입니다. &lt;code&gt;keepdims&lt;/code&gt; 가 true가 아닌 한 , 텐서의 순위는 &lt;code&gt;reduction_axes&lt;/code&gt; 의 각 항목마다 1 씩 줄어 듭니다 . 경우 &lt;code&gt;keepdims&lt;/code&gt; 는 사실, 감소 된 치수는 길이가 1로 유지된다.</target>
        </trans-unit>
        <trans-unit id="33f6f42469b274e2162f75f436b2ac7bd5c58ff6" translate="yes" xml:space="preserve">
          <source>Reduces sparse updates into a variable reference using the &lt;code&gt;max&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;max&lt;/code&gt; 연산을 사용하여 희소 업데이트를 변수 참조로 줄 입니다.</target>
        </trans-unit>
        <trans-unit id="a98876ad2d7ca4ab81bfa5e519e1343c8042b034" translate="yes" xml:space="preserve">
          <source>Reduces sparse updates into a variable reference using the &lt;code&gt;min&lt;/code&gt; operation.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 작업을 사용하여 희소 업데이트를 변수 참조로 줄 입니다.</target>
        </trans-unit>
        <trans-unit id="6b273f86e8ed9a1278cd5bff4d9e0c947c9a0c72" translate="yes" xml:space="preserve">
          <source>Reduces the input dataset to a single element.</source>
          <target state="translated">입력 데이터 세트를 단일 요소로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="d21001c5a6e1ca202205fcd6dfa6f9693e259a38" translate="yes" xml:space="preserve">
          <source>Reduction using NCCL all-reduce.</source>
          <target state="translated">NCCL all-reduce를 사용한 감소.</target>
        </trans-unit>
        <trans-unit id="399750940819b016ea67de39bca09a952716425c" translate="yes" xml:space="preserve">
          <source>Reduction using hierarchical copy all-reduce.</source>
          <target state="translated">계층 적 복사 전체 축소를 사용한 축소.</target>
        </trans-unit>
        <trans-unit id="bd76760173b50b831dfa3133348395306ec3471b" translate="yes" xml:space="preserve">
          <source>Reductions and all-reduce: A &lt;em&gt;reduction&lt;/em&gt; is some method of aggregating multiple values into one value, like &quot;sum&quot; or &quot;mean&quot;. If a strategy is doing sync training, we will perform a reduction on the gradients to a parameter from all replicas before applying the update. &lt;em&gt;All-reduce&lt;/em&gt; is an algorithm for performing a reduction on values from multiple devices and making the result available on all of those devices.</source>
          <target state="translated">축소 및 전체 축소 : &lt;em&gt;축소&lt;/em&gt; 는 &quot;sum&quot;또는 &quot;mean&quot;과 같이 여러 값을 하나의 값으로 집계하는 방법입니다. 전략이 동기화 훈련을 수행하는 경우 업데이트를 적용하기 전에 모든 복제본의 매개 변수에 대한 그라디언트 감소를 수행합니다. &lt;em&gt;All-reduce&lt;/em&gt; 는 여러 장치에서 값을 줄이고 그 모든 장치에서 결과를 사용할 수 있도록하는 알고리즘입니다.</target>
        </trans-unit>
        <trans-unit id="a83ad9a9c471fb61ecd5cff9d5e7f3b3bc06d9bb" translate="yes" xml:space="preserve">
          <source>Reductions and scans (like: &lt;a href=&quot;../../math/reduce_mean&quot;&gt;&lt;code&gt;tf.math.reduce_mean&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../math/cumsum&quot;&gt;&lt;code&gt;tf.math.cumsum&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">축소 및 스캔 (예 : &lt;a href=&quot;../../math/reduce_mean&quot;&gt; &lt;code&gt;tf.math.reduce_mean&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../math/cumsum&quot;&gt; &lt;code&gt;tf.math.cumsum&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="413a9bc44f59a9e282d5f81a1b0a18eba3c7136d" translate="yes" xml:space="preserve">
          <source>Reductions and scans (like: &lt;a href=&quot;math/reduce_mean&quot;&gt;&lt;code&gt;tf.math.reduce_mean&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;math/cumsum&quot;&gt;&lt;code&gt;tf.math.cumsum&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">축소 및 스캔 (예 : &lt;a href=&quot;math/reduce_mean&quot;&gt; &lt;code&gt;tf.math.reduce_mean&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;math/cumsum&quot;&gt; &lt;code&gt;tf.math.cumsum&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
