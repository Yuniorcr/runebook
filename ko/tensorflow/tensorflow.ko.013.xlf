<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="57d58f90f76ee45df3897014c28953c74f48340a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;predictions&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of arbitrary shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a5def2f3e316de276c8c9e42d1d45bbc0bb1f80" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;predictions&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of prediction results for semantic labels, whose shape is [batch size] and type &lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt;. The tensor will be flattened if its rank &amp;gt; 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12653f32ba55bbc868eaef9906e34b07492cc9a9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;predictions&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of the same shape as &lt;code&gt;labels&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ec041666f8e27930276106a67afe8ca51415ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;predictions&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt;. A &lt;code&gt;batch_size&lt;/code&gt; x &lt;code&gt;classes&lt;/code&gt; tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0575cad802558981335640bf981ba4fd3729e0ff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;predictions&lt;/code&gt;&lt;/b&gt;: A float &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01b3998c5a7d6d9aa7c837f9893f389fa5c2d8e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;predictions&lt;/code&gt;&lt;/b&gt;: A floating point &lt;code&gt;Tensor&lt;/code&gt; of arbitrary shape and whose values are in the range &lt;code&gt;[0, 1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="625d20b5955c1012b13eb3d8fc3e15b12ea2fbf0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;predictions&lt;/code&gt;&lt;/b&gt;: A tensor of shape &lt;code&gt;(batch_size, classes)&lt;/code&gt; and type &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2e41a8d0b465c124e588567fe722d43b57e165" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;predictions&lt;/code&gt;&lt;/b&gt;: An arbitrary matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa15baf1361edf8430763667cad8af94f163ca8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;predictions&lt;/code&gt;&lt;/b&gt;: Float &lt;code&gt;Tensor&lt;/code&gt; with shape [D1, ... DN, num_classes] where N &amp;gt;= 1. Commonly, N=1 and &lt;code&gt;predictions&lt;/code&gt; has shape [batch size, num_classes]. The final dimension contains the logit values for each class. [D1, ... DN] must match &lt;code&gt;labels&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cd77aeaf51208ec47ce2fa78273508360f08de6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;predictions&lt;/code&gt;&lt;/b&gt;: Float &lt;code&gt;Tensor&lt;/code&gt; with shape [D1, ... DN, num_classes] where N &amp;gt;= 1. Commonly, N=1 and predictions has shape [batch size, num_classes]. The final dimension contains the logit values for each class. [D1, ... DN] must match &lt;code&gt;labels&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bd4e57626d7be399d01489bcbdc62b5ba4ff327" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;predictions&lt;/code&gt;&lt;/b&gt;: Predictions &lt;code&gt;Tensor&lt;/code&gt; or dict of &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4b1c50f29ea70bbfccc58af46df547df66e7df" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;predictions&lt;/code&gt;&lt;/b&gt;: The predicted outputs, a tensor of size &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt; where N+1 is the total number of dimensions in &lt;code&gt;predictions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77d9db8cfe2b553c4010cfe2eb83637e338a1e34" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;predictions&lt;/code&gt;&lt;/b&gt;: The predicted outputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50fbd3cc9d892f5bef0c178d96637a90c1541cdf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;predictions&lt;/code&gt;&lt;/b&gt;: The predicted values, a &lt;code&gt;Tensor&lt;/code&gt; of any shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ddd2b69d60ba288fbbeb2831c51383ab1f87ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;predictions&lt;/code&gt;&lt;/b&gt;: The predicted values, a &lt;code&gt;Tensor&lt;/code&gt; of arbitrary dimensions. Will be cast to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b5acd57cc56dfffb628741bce50f4504024877" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;predictions_idx&lt;/code&gt;&lt;/b&gt;: Integer &lt;code&gt;Tensor&lt;/code&gt; with shape [D1, ... DN, k] where N &amp;gt;= 1. Commonly, N=1 and predictions has shape [batch size, k]. The final dimension contains the top &lt;code&gt;k&lt;/code&gt; predicted class indices. [D1, ... DN] must match &lt;code&gt;labels&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fcd0ddbafaca03b7b827098ed1581d8febec4a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;preds&lt;/code&gt;&lt;/b&gt;: array-like, shape &lt;code&gt;(n_samples,)&lt;/code&gt; Class predictions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2058e9f048f7753a666d8847409491ab8913e76" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;preds&lt;/code&gt;&lt;/b&gt;: array-like, shape &lt;code&gt;(n_samples,)&lt;/code&gt; Predictions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d5ebc012fae328790187940d8d04ef1ab1bd73" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;preferred_dtype&lt;/code&gt;&lt;/b&gt;: Optional element type for the returned tensor, used when dtype is None. In some cases, a caller may not have a dtype in mind when converting to a tensor, so preferred_dtype can be used as a soft preference. If the conversion to &lt;code&gt;preferred_dtype&lt;/code&gt; is not possible, this argument has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a169c53c72b9e449fd6b917712365f44b1e7d00" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;prefetch_buffer_size&lt;/code&gt;&lt;/b&gt;: An int specifying the number of feature batches to prefetch for performance improvement. Recommended value is the number of batches consumed per training step. Defaults to auto-tune.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d208b2a7fea062fc83319f473445901aa7a2001" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;prefetch_buffer_size&lt;/code&gt;&lt;/b&gt;: Number of feature batches to prefetch in order to improve performance. Recommended value is the number of batches consumed per training step. Defaults to auto-tune.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9491a2003aaf7fb9291df1aada57efb5c364bb0a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;prefetch_input_elements&lt;/code&gt;&lt;/b&gt;: The number of input elements to transform to iterators before they are needed for interleaving.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f565a5f82fc2a294c566840bf480c9919100d2b9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;prefix&lt;/code&gt;&lt;/b&gt;: A sequence expected at the beginning of the whole parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8778c29131b499879f3c4ae1476655bad9d48302" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;prefix&lt;/code&gt;&lt;/b&gt;: String prefix to index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d2e3ad8060e4c8c23a7c4fdcf8ae8997d48b1a0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;prefix&lt;/code&gt;&lt;/b&gt;: str, per-line output prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c56e2087637a4145932d4a5cf2ebfacf79effa7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;preprocess_collapse_repeated&lt;/code&gt;&lt;/b&gt;: Boolean. Default: False. If True, repeated labels are collapsed prior to the CTC calculation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70dc2c084cf93610b8809ac500a21ec7f467190e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;preprocessing_function&lt;/code&gt;&lt;/b&gt;: function that will be applied on each input. The function will run after the image is resized and augmented. The function should take one argument: one image (Numpy tensor with rank 3), and should output a Numpy tensor with the same shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a3f1fb46e617d5a350f8ff3364cd2275c8748f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;preserve_aspect_ratio&lt;/code&gt;&lt;/b&gt;: Whether to preserve the aspect ratio. If this is set, then &lt;code&gt;images&lt;/code&gt; will be resized to a size that fits in &lt;code&gt;size&lt;/code&gt; while preserving the aspect ratio of the original image. Scales up the image if &lt;code&gt;size&lt;/code&gt; is bigger than the current size of the &lt;code&gt;image&lt;/code&gt;. Defaults to False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33b2ba6f977ad4b16607bbeff5471bc5af01a978" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;preserve_short_sequences&lt;/code&gt;&lt;/b&gt;: If true, then ensure that at least one ngram is generated for each input sequence. In particular, if an input sequence is shorter than &lt;code&gt;min(ngram_width) + 2*pad_width&lt;/code&gt;, then generate a single ngram containing the entire sequence. If false, then no ngrams are generated for these short input sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e127d62b0361a748f03443ecb0391069814212b9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;previous_target&lt;/code&gt;&lt;/b&gt;: Callable that needs to be replaced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d010f8bd59a30369ea71cec547cb16bab345202a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;primals&lt;/code&gt;&lt;/b&gt;: A tensor or nested structure of tensors to watch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8835b8f74bcf4cd75755d2900c80a96af5370e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;primals&lt;/code&gt;&lt;/b&gt;: A watched Tensor or structure of Tensors to fetch the JVPs for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204eebcd95014ab89db5cacc776da773ee620df8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;print_fn&lt;/code&gt;&lt;/b&gt;: Print function to use. Defaults to &lt;code&gt;print&lt;/code&gt;. It will be called on each line of the summary. You can set it to a custom function in order to capture the string summary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d916014fe75b0b32e972a29facc226a245310965" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;priority&lt;/code&gt;&lt;/b&gt;: Optional integer that indicates the priority for applying this conversion function. Conversion functions with smaller priority values run earlier than conversion functions with larger priority values. Defaults to 100.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d555ca4788ed170556c9f6e9fa86725cddfa542" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;prob&lt;/code&gt;&lt;/b&gt;: a &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;sample_shape(x) + self.batch_shape&lt;/code&gt; with values of type &lt;code&gt;self.dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3b96420cfd3a136898404da0ff43481b6ac8a7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;proba&lt;/code&gt;&lt;/b&gt;: array-like, shape &lt;code&gt;(n_samples, n_outputs)&lt;/code&gt; Class probability estimates. In the case of binary classification, to match the scikit-learn API, will return an array of shape &lt;code&gt;(n_samples, 2)&lt;/code&gt; (instead of &lt;code&gt;(n_sample, 1)&lt;/code&gt; as in Keras).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8186d639b08501edc6f7eced47735fe9f89ecf82" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;probs&lt;/code&gt;&lt;/b&gt;: A 0/1-D Tensor or Python value. The probability of success for the binomial distribution. Must be broadcastable with the leftmost dimension defined by &lt;code&gt;shape&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3441bc72cb09c3b9126bc84fc72cde521b9e9a3e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;probs&lt;/code&gt;&lt;/b&gt;: An N-D &lt;code&gt;Tensor&lt;/code&gt; representing the probability of a &lt;code&gt;1&lt;/code&gt; event. Each entry in the &lt;code&gt;Tensor&lt;/code&gt; parameterizes an independent Bernoulli distribution. Only one of &lt;code&gt;logits&lt;/code&gt; or &lt;code&gt;probs&lt;/code&gt; should be passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="131e262c2de98080cf1341b13d2c6783b8f6144f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;probs&lt;/code&gt;&lt;/b&gt;: An N-D &lt;code&gt;Tensor&lt;/code&gt;, &lt;code&gt;N &amp;gt;= 1&lt;/code&gt;, representing the probabilities of a set of Categorical distributions. The first &lt;code&gt;N - 1&lt;/code&gt; dimensions index into a batch of independent distributions and the last dimension represents a vector of probabilities for each class. Only one of &lt;code&gt;logits&lt;/code&gt; or &lt;code&gt;probs&lt;/code&gt; should be passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df4f9e5262c9bb0eb0f95cc34679c965b91cba37" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;probs&lt;/code&gt;&lt;/b&gt;: Positive floating point tensor with shape broadcastable to &lt;code&gt;[N1,..., Nm, K]&lt;/code&gt;&lt;code&gt;m &amp;gt;= 0&lt;/code&gt; and same dtype as &lt;code&gt;total_count&lt;/code&gt;. Defines this as a batch of &lt;code&gt;N1 x ... x Nm&lt;/code&gt; different &lt;code&gt;K&lt;/code&gt; class Multinomial distributions. &lt;code&gt;probs&lt;/code&gt;'s components in the last portion of its shape should sum to &lt;code&gt;1&lt;/code&gt;. Only one of &lt;code&gt;logits&lt;/code&gt; or &lt;code&gt;probs&lt;/code&gt; should be passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="847d30138b9c923d89ba440a279e0e6e7583557e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;producer_op_list&lt;/code&gt;&lt;/b&gt;: (Optional.) An &lt;code&gt;OpList&lt;/code&gt; proto with the (possibly stripped) list of &lt;code&gt;OpDef&lt;/code&gt;s used by the producer of the graph. If provided, unrecognized attrs for ops in &lt;code&gt;graph_def&lt;/code&gt; that have their default value according to &lt;code&gt;producer_op_list&lt;/code&gt; will be removed. This will allow some more &lt;code&gt;GraphDef&lt;/code&gt;s produced by later binaries to be accepted by earlier binaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd6cf3ea50a86e36d49090cf004d6efcdc7f3c4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;profile_batch&lt;/code&gt;&lt;/b&gt;: Profile the batch to sample compute characteristics. By default, it will profile the second batch. Set profile_batch=0 to disable profiling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51996a48bde3577efc51083fa51778cb189ad109" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;profile_batch&lt;/code&gt;&lt;/b&gt;: Profile the batch to sample compute characteristics. By default, it will profile the second batch. Set profile_batch=0 to disable profiling. Must run in TensorFlow eager mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fb5a0d0af4310ed385a01f4d6ecbac9dbbcb11" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;profiler&lt;/code&gt;&lt;/b&gt;: If True, enables the advanced profiler. Enabling profiler implicitly enables the graph collection. The profiler may incur a high memory overhead. The default is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9885a99ee236e3b54f0c6388a757f2d7f30fe24e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;profiler_outdir&lt;/code&gt;&lt;/b&gt;: Output directory for profiler. It is required when profiler is enabled when trace was started. Otherwise, it is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a80e781a72ee138c94993944903825239e614c0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;progressive&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;bool&lt;/code&gt;. Defaults to &lt;code&gt;False&lt;/code&gt;. If True, create a JPEG that loads progressively (coarse to fine).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0abb22c7be10a664647d1d7affecb16743b24a75" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;proj_clip&lt;/code&gt;&lt;/b&gt;: (optional) A float value. If &lt;code&gt;num_proj &amp;gt; 0&lt;/code&gt; and &lt;code&gt;proj_clip&lt;/code&gt; is provided, then the projected values are clipped elementwise to within &lt;code&gt;[-proj_clip, proj_clip]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b2fe8b8b4021ca0ba5978a86809c0a034e2889c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;project&lt;/code&gt;&lt;/b&gt;: Name of the GCE project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05505a3b17997c5741a4940cc49dc6559a011350" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;project&lt;/code&gt;&lt;/b&gt;: Name of the GCP project containing Cloud TPUs. If omitted or empty, we will try to discover the project name of the GCE VM from the GCE metadata service.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d52a194c81e94f299e9fad4d5c198d2b52ca5eec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;protected_nodes&lt;/code&gt;&lt;/b&gt;: An optional list of names of nodes to be kept unconditionally. This is for example useful to preserve Identity output nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa76749ad212e39af390f910a1f7bc46d177f90e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;protocol&lt;/code&gt;&lt;/b&gt;: (Optional.) Specifies the protocol to be used by the server. Acceptable values include &lt;code&gt;&quot;grpc&quot;, &quot;grpc+verbs&quot;&lt;/code&gt;. Defaults to the value in &lt;code&gt;server_or_cluster_def&lt;/code&gt;, if specified. Otherwise defaults to &lt;code&gt;&quot;grpc&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f215c5cc15e751135728806640225a896b5338af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;protocol&lt;/code&gt;&lt;/b&gt;: An optional argument which specifies the protocol used when starting server. &lt;code&gt;None&lt;/code&gt; means default to grpc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b0f1b16994401bc7766495be738bc98c0cf109" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;protocol&lt;/code&gt;&lt;/b&gt;: Communication protocol. Allowed values are documented in the documentation of &lt;a href=&quot;../distribute/server&quot;&gt;&lt;code&gt;tf.distribute.Server&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="871818f03dde22b42d15bc3501185f503b69cf0b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;protocol&lt;/code&gt;&lt;/b&gt;: The communication protocol, such as &lt;code&gt;&quot;grpc&quot;&lt;/code&gt;. If unspecified, will use the default from &lt;code&gt;python/platform/remote_utils.py&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93bf66ac215fe13d5fa057cc9d4ecc17b6f116a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;pruning_mode&lt;/code&gt;&lt;/b&gt;: one of 'none', 'pre', 'post' to indicate no pruning, pre- pruning (do not split a node if not enough gain is observed) and post pruning (build the tree up to a max depth and then prune branches with negative gain). For pre and post pruning, you MUST provide tree_complexity &amp;gt;0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a50f7caedb4be3582357e3e90e55621e8ab4e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ps_config&lt;/code&gt;&lt;/b&gt;: (optional) &lt;code&gt;tf.ConfigProto&lt;/code&gt; to initialize PS servers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e86231474b3e7fb8d5c3c78ce0705675e8ed5355" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ps_device&lt;/code&gt;&lt;/b&gt;: String. Device of the &lt;code&gt;ps&lt;/code&gt; job. If empty no &lt;code&gt;ps&lt;/code&gt; job is used. Defaults to &lt;code&gt;ps&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77643d0ee2acddf3656fa029b536109dd3b39fef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ps_ops&lt;/code&gt;&lt;/b&gt;: List of strings representing &lt;code&gt;Operation&lt;/code&gt; types that need to be placed on &lt;code&gt;ps&lt;/code&gt; devices. If &lt;code&gt;None&lt;/code&gt;, defaults to &lt;code&gt;STANDARD_PS_OPS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00cb01025b50465ffc3108ccff1919ab570301ce" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ps_strategy&lt;/code&gt;&lt;/b&gt;: A callable invoked for every ps &lt;code&gt;Operation&lt;/code&gt; (i.e. matched by &lt;code&gt;ps_ops&lt;/code&gt;), that takes the &lt;code&gt;Operation&lt;/code&gt; and returns the ps task index to use. If &lt;code&gt;None&lt;/code&gt;, defaults to a round-robin strategy across all &lt;code&gt;ps&lt;/code&gt; devices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="567855550d8452c2ba6c51dc36cc18ee7120ae20" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ps_tasks&lt;/code&gt;&lt;/b&gt;: Number of tasks in the &lt;code&gt;ps&lt;/code&gt; job. Ignored if &lt;code&gt;cluster&lt;/code&gt; is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b2cd44905054e511afed36acd29ef66340f73f4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;pseudo_random&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;bool&lt;/code&gt;. Defaults to &lt;code&gt;False&lt;/code&gt;. When set to &lt;code&gt;True&lt;/code&gt;, generates the pooling sequence in a pseudorandom fashion, otherwise, in a random fashion. Check paper &lt;a href=&quot;http://arxiv.org/abs/1412.6071&quot;&gt;Benjamin Graham, Fractional Max-Pooling&lt;/a&gt; for difference between pseudorandom and random.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d53f70e49bcb81af0293d03c8b0bf33aee596e9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;pylist&lt;/code&gt;&lt;/b&gt;: A nested &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt; or &lt;code&gt;np.ndarray&lt;/code&gt;. Any nested element that is not a &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;tuple&lt;/code&gt; must be a scalar value compatible with &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="094d01fe4052ca6b856659271107d5a1ad0f8504" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;pylist&lt;/code&gt;&lt;/b&gt;: A nested &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt; or &lt;code&gt;np.ndarray&lt;/code&gt;. Any nested element that is not a &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;tuple&lt;/code&gt; or &lt;code&gt;np.ndarray&lt;/code&gt; must be a scalar value compatible with &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7f4b282b4bfbc9179b3382f379a0acbea82e1c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;q&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Has the same type as &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c75c81b672549378230b54e2310a0b748ba22ff2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;q&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must have the same type as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f7d720746ab0e5869667063e78c9e2759f716d7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;QueueRunner&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc7d66d77117ffdcf34579115e308110c7e7d2a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;quality&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;int&lt;/code&gt;. Defaults to &lt;code&gt;95&lt;/code&gt;. Quality of the compression from 0 to 100 (higher is better and slower).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f978ae83a3166df1818ceb407db5f536b19e6529" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;quantile&lt;/code&gt;&lt;/b&gt;: a &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;sample_shape(x) + self.batch_shape&lt;/code&gt; with values of type &lt;code&gt;self.dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ed865803318020ee09ad61328035232f819137" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;quantile_sketch_epsilon&lt;/code&gt;&lt;/b&gt;: float between 0 and 1. Error bound for quantile computation. This is only used for float feature columns, and the number of buckets generated per float feature is 1/quantile_sketch_epsilon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16fdbb570148cf1d9dc16caa205b894f6ad26446" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;quantized_input_stats&lt;/code&gt;&lt;/b&gt;: Dict of strings representing input tensor names mapped to tuple of floats representing the mean and standard deviation of the training data (e.g., {&quot;foo&quot; : (0., 1.)}). Only need if &lt;code&gt;inference_input_type&lt;/code&gt; is &lt;code&gt;QUANTIZED_UINT8&lt;/code&gt;. real_input_value = (quantized_input_value - mean_value) / std_dev_value. (default {})</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e35e1733c54d2ac128cbc45fb6687a77f173f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;query&lt;/code&gt;&lt;/b&gt;: A 0-D &lt;a href=&quot;../../../../../tf#string&quot;&gt;&lt;code&gt;tf.string&lt;/code&gt;&lt;/a&gt; tensor containing the SQL query to execute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644ce3e13cac0967b20c1c651f2c82a7d765c027" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;query&lt;/code&gt;&lt;/b&gt;: A 0-D &lt;a href=&quot;../../../tf#string&quot;&gt;&lt;code&gt;tf.string&lt;/code&gt;&lt;/a&gt; tensor containing the SQL query to execute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed34bd1ecfa0f7d17fb0a4e35ed423f8d4a10f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;queue&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Queue&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4f60d438a656d334fa79818eaea11257221b250" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;queue&lt;/code&gt;&lt;/b&gt;: A Queue or a mutable string Tensor representing a handle to a Queue, with string work items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a89ed9d66054f1e6b60b1b104cba47191515e32" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;queue_capacity&lt;/code&gt;&lt;/b&gt;: Integer, size of queue to accumulate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de950e18734a820db7aec5e5613e3936224d3ab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;queue_capacity&lt;/code&gt;&lt;/b&gt;: int, size of the read queue. If &lt;code&gt;None&lt;/code&gt;, it will be set roughly to the size of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bda9de89c109fea248788547ff4a9a31893a8de" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;queue_closed_exception_types&lt;/code&gt;&lt;/b&gt;: Optional tuple of Exception types that indicate that the queue has been closed when raised during an enqueue operation. Defaults to &lt;code&gt;(tf.errors.OutOfRangeError,)&lt;/code&gt;. Another common case includes &lt;code&gt;(tf.errors.OutOfRangeError, tf.errors.CancelledError)&lt;/code&gt;, when some of the enqueue ops may dequeue from other Queues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2284a39c5e681ce0a28f4078643b7b44d81af1b0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;queue_ref&lt;/code&gt;&lt;/b&gt;: The queue reference, i.e. the output of the queue op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bad0d69cd9083b7ff7411476bd057ae4598a9d6b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;queue_runner_def&lt;/code&gt;&lt;/b&gt;: Optional &lt;code&gt;QueueRunnerDef&lt;/code&gt; protocol buffer. If specified, recreates the QueueRunner from its contents. &lt;code&gt;queue_runner_def&lt;/code&gt; and the other arguments are mutually exclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb60644e535270f7490c58b1a3e92ae3f32a92aa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;queue_runners&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;QueueRunners&lt;/code&gt;. If not specified, we'll use the list of queue runners gathered in the graph under the key &lt;code&gt;GraphKeys.QUEUE_RUNNERS&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0435a263e872dd6cc7a13d617dd91c08561ad2e6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;queues&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;QueueBase&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4b8920213a7e319198f825f4f3a32c860c5563b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;r&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Has the same type as &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67361d16f47f5eed52cbca3e57b172354e55c5ed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ragged&lt;/code&gt;&lt;/b&gt;: A boolean specifying whether the placeholder to be created is ragged. Only one of 'ragged' and 'sparse' can be True. In this case, values of 'None' in the 'shape' argument represent ragged dimensions. For more information about RaggedTensors, see https://www.tensorflow.org/guide/ragged_tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb40305e14093a8264e294f786fef71e01c98e6c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ragged&lt;/code&gt;&lt;/b&gt;: Boolean, whether the placeholder created is meant to be ragged. In this case, values of 'None' in the 'shape' argument represent ragged dimensions. For more information about RaggedTensors, see https://www.tensorflow.org/guide/ragged_tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43481f7c96b69884471da9bef8ece838be9f87f1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ragged&lt;/code&gt;&lt;/b&gt;: Boolean, whether the placeholder should have a ragged type. In this case, values of 'None' in the 'shape' argument represent ragged dimensions. For more information about RaggedTensors, see this &lt;a href=&quot;https://www.tensorflow.org/guide/ragged_tensors&quot;&gt;guide&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f22767bd2fde4114491d189250aacd0f887187" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ragged_rank&lt;/code&gt;&lt;/b&gt;: An integer specifying the ragged rank of the returned &lt;code&gt;RaggedTensor&lt;/code&gt;. Must be nonnegative and less than &lt;code&gt;K&lt;/code&gt;. Defaults to &lt;code&gt;max(0, K - 1)&lt;/code&gt; if &lt;code&gt;inner_shape&lt;/code&gt; is not specified. Defaults to `max(0, K</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4ee2ed81f5a41cd8aac6bcb4b8ad0c2876e2064" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ragged_rank&lt;/code&gt;&lt;/b&gt;: An integer specifying the ragged rank of the returned &lt;code&gt;RaggedTensorValue&lt;/code&gt;. Must be nonnegative and less than &lt;code&gt;K&lt;/code&gt;. Defaults to &lt;code&gt;max(0, K - 1)&lt;/code&gt; if &lt;code&gt;inner_shape&lt;/code&gt; is not specified. Defaults to `max(0, K</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d26fb9f0523bee7f3283518ee7c0a8d266539f9a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ragged_rank&lt;/code&gt;&lt;/b&gt;: Integer specifying the ragged rank for the returned &lt;code&gt;RaggedTensor&lt;/code&gt;. Must be greater than zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b4406b0861b44e3fa4f7217456ca892cf4e63d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ragged_rank&lt;/code&gt;&lt;/b&gt;: Python integer, the ragged rank of the RaggedTensor to be described. Defaults to &lt;code&gt;shape.ndims - 1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e861696a5a871e0b6e4212d0ccabf58255d4dda" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ragged_rank&lt;/code&gt;&lt;/b&gt;: The ragged rank for the &lt;code&gt;RaggedTensor&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7960896a89c4002140d693a8f16699524328a4a8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;random_seed&lt;/code&gt;&lt;/b&gt;: Initial seed for workers, will be incremented by one for each worker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df322f77de92bac05e42bb329e73ea326c5e41b6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;range_given&lt;/code&gt;&lt;/b&gt;: If true use &lt;code&gt;input_min&lt;/code&gt; and &lt;code&gt;input_max&lt;/code&gt; for the range of the input, otherwise determine min and max from the input &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="892a7b655e631a921fc062419fb9201dfb799ace" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;range_max&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;int&lt;/code&gt;. The number of possible classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e52e386d997b2d3a10d4e7163e0b2bc58225418" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rank&lt;/code&gt;&lt;/b&gt;: (optional) Python int, the rank of the &lt;code&gt;SparseTensor&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="908ac5a4e577dfec83ac6522c3d383b6d50d157b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rank&lt;/code&gt;&lt;/b&gt;: An integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd7afaafbd4875c830aa69556c1bafeaa51b8f81" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rank&lt;/code&gt;&lt;/b&gt;: Scalar &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24dac1a70a23aff9838e0c23694e0b58aaa125a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rank&lt;/code&gt;&lt;/b&gt;: Scalar integer &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="653ac2df29ff279e6884f19110beed7f35fd3a3c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rankdir&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;rankdir&lt;/code&gt; argument passed to PyDot, a string specifying the format of the plot: 'TB' creates a vertical plot; 'LR' creates a horizontal plot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f887cb50bcf5c16339e5fd4412142e058fd6625" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ranks&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Iterable&lt;/code&gt; of scalar &lt;code&gt;Tensor&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="877aed852b77af7b7628f6e3f6d369ba14368513" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ranks&lt;/code&gt;&lt;/b&gt;: Iterable of scalar &lt;code&gt;Tensor&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f093bed99df32de74cc60e707c0c281e36411de7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/b&gt;: 1-D of size 2. The dilation rate in which we sample input values across the &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; dimensions in atrous convolution. If it is greater than 1, then all values of strides must be 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc30c01a58c1328a5aed42050b43013dea31dbb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/b&gt;: A positive int32. The stride with which we sample input values across the &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; dimensions. Equivalently, the rate by which we upsample the filter values by inserting zeros across the &lt;code&gt;height&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; dimensions. In the literature, the same parameter is sometimes called &lt;code&gt;input stride&lt;/code&gt; or &lt;code&gt;dilation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="195629e5b7780d01fe593d82968512876986e7cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/b&gt;: A scalar &lt;code&gt;Tensor&lt;/code&gt; with the same type as &lt;code&gt;x&lt;/code&gt;. The probability that each element of &lt;code&gt;x&lt;/code&gt; is discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6312030902208604c9baa39e6cbe7e199da2b02f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/b&gt;: A scalar &lt;code&gt;Tensor&lt;/code&gt; with the same type as x. The probability that each element is dropped. For example, setting rate=0.1 would drop 10% of input elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da17b90b39109449298d32c1797ef5d2f8f6c6ab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/b&gt;: Float between 0 and 1. Fraction of the input units to drop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66d6c5b209f5d1e41da8022ca0a3451ce565675c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/b&gt;: Float, drop probability (as with &lt;code&gt;Dropout&lt;/code&gt;). The multiplicative noise will have standard deviation &lt;code&gt;sqrt(rate / (1 - rate))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="154c803b4ec76244c0aa947635435b4a30f35b3e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/b&gt;: Floating point tensor, equivalent to &lt;code&gt;1 / mean&lt;/code&gt;. Must contain only positive values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b09878c6fc20d545e933e607453b4741414bb41" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/b&gt;: Floating point tensor, the inverse scale params of the distribution(s). Must contain only positive values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd67f29f241b2cdf1e08b9cbc1247191af4f06a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/b&gt;: The dropout rate, between 0 and 1. E.g. &lt;code&gt;rate=0.1&lt;/code&gt; would drop out 10% of input units.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81191b00652f584b6714c8b6c08de91b8ed0890e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/b&gt;: float, drop probability (as with &lt;code&gt;Dropout&lt;/code&gt;). The multiplicative noise will have standard deviation &lt;code&gt;sqrt(rate / (1 - rate))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c8c1fd378a5768b45d8e35924b5ecc1bb784e09" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/b&gt;: rate for enforcing the constraint: weights will be rescaled to yield &lt;code&gt;(1 - rate) * norm + rate * norm.clip(min_value, max_value)&lt;/code&gt;. Effectively, this means that rate=1.0 stands for strict enforcement of the constraint, while rate&amp;lt;1.0 means that weights will be rescaled at each step to slowly move towards a value inside the desired interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9741611c67e7991dd1f53b5e505304795f5ef8e3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rates&lt;/code&gt;&lt;/b&gt;: A 1-D Tensor of length 4. Must be: &lt;code&gt;[1, rate_rows, rate_cols, 1]&lt;/code&gt;. This is the input stride, specifying how far two consecutive patch samples are in the input. Equivalent to extracting patches with &lt;code&gt;patch_sizes_eff = patch_sizes + (patch_sizes - 1) * (rates - 1)&lt;/code&gt;, followed by subsampling them spatially by a factor of &lt;code&gt;rates&lt;/code&gt;. This is equivalent to &lt;code&gt;rate&lt;/code&gt; in dilated (a.k.a. Atrous) convolutions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17056a782e5507dc7e12ed719901dd3f9e9a6103" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rates&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;&amp;gt;= 4&lt;/code&gt;. 1-D of length 4. The input stride for atrous morphological dilation. Must be: &lt;code&gt;[1, rate_height, rate_width, 1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed360006e5351c624669764f5273a38569962ce" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rates&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;&amp;gt;= 4&lt;/code&gt;. Must be: &lt;code&gt;[1, rate_rows, rate_cols, 1]&lt;/code&gt;. This is the input stride, specifying how far two consecutive patch samples are in the input. Equivalent to extracting patches with &lt;code&gt;patch_sizes_eff = patch_sizes + (patch_sizes - 1) * (rates - 1)&lt;/code&gt;, followed by subsampling them spatially by a factor of &lt;code&gt;rates&lt;/code&gt;. This is equivalent to &lt;code&gt;rate&lt;/code&gt; in dilated (a.k.a. Atrous) convolutions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01faf04e9932c5fce68214640104e9f057bbab6b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rates&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;&amp;gt;= 4&lt;/code&gt;. The input stride for atrous morphological dilation. Must be: &lt;code&gt;[1, rate_height, rate_width, 1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5ed732c86871792f0f9221d445457324435aa67" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ratio&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;int&lt;/code&gt;. Defaults to &lt;code&gt;1&lt;/code&gt;. Downscaling ratio.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0abc59b2ba5b87eab5f36f276f65a07cec99b63a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rcond&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; of small singular value cutoffs. Singular values smaller (in modulus) than &lt;code&gt;rcond&lt;/code&gt; * largest_singular_value (again, in modulus) are set to zero. Must broadcast against &lt;code&gt;tf.shape(a)[:-2]&lt;/code&gt;. Default value: &lt;code&gt;10. * max(num_rows, num_cols) * np.finfo(a.dtype).eps&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39998e7ad7d8de84fd36bace9bfd268f55fab3ab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;read_value&lt;/code&gt;&lt;/b&gt;: if True, will return something which evaluates to the new value of the variable; if False will return the assign op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06eae26f1d9865ca54382150e805013ab2dfccff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reader&lt;/code&gt;&lt;/b&gt;: A function or class that can be called with a &lt;code&gt;filenames&lt;/code&gt; tensor and (optional) &lt;code&gt;reader_args&lt;/code&gt; and returns a &lt;code&gt;Dataset&lt;/code&gt; of &lt;code&gt;Example&lt;/code&gt; tensors. Defaults to &lt;a href=&quot;../../../../data/tfrecorddataset&quot;&gt;&lt;code&gt;tf.data.TFRecordDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91ad106c6d9e02cd99cc766ee173e1da9110e60" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reader&lt;/code&gt;&lt;/b&gt;: A function or class that can be called with a &lt;code&gt;filenames&lt;/code&gt; tensor and (optional) &lt;code&gt;reader_args&lt;/code&gt; and returns a &lt;code&gt;Dataset&lt;/code&gt; of &lt;code&gt;Example&lt;/code&gt; tensors. Defaults to &lt;a href=&quot;../tfrecorddataset&quot;&gt;&lt;code&gt;tf.data.TFRecordDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19e7965407829468bcf84e76f89b7e41af68a7b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reader_args&lt;/code&gt;&lt;/b&gt;: Additional arguments to pass to the reader class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6b3ff3fd688274fecbc954ee26eeef9d0fc74f0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reader_num_threads&lt;/code&gt;&lt;/b&gt;: Number of threads used to read &lt;code&gt;Example&lt;/code&gt; records. If &amp;gt;1, the results will be interleaved. Defaults to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5c737a9372fab6fc0afb59a2ea8cecc1420f33" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reader_ref&lt;/code&gt;&lt;/b&gt;: The operation that implements the reader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b37a701fea43ba4559742de3309b96ffa22c22de" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ready_for_local_init_op&lt;/code&gt;&lt;/b&gt;: 1-D string &lt;code&gt;Tensor&lt;/code&gt;. This tensor is evaluated by supervisors in &lt;code&gt;prepare_or_wait_for_session()&lt;/code&gt; to check if the model is ready to run the local_init_op. The model is considered ready if it returns an empty array. Defaults to &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;None&lt;/code&gt;, the model is not checked for readiness before running local_init_op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88807a37b3570cb88195db1a5f15e9cabf46f201" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ready_for_local_init_op&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;Operation&lt;/code&gt; to check if the model is ready to run local_init_op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06979981362fed2f565ad256bb3eca4446b7423c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ready_for_local_init_op&lt;/code&gt;&lt;/b&gt;: Optional op to verify that the global variables are initialized and &lt;code&gt;local_init_op&lt;/code&gt; can be run. Must return an empty 1D string tensor when the global variables are initialized, or a non-empty 1D string tensor listing the names of the non-initialized global variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d6ba88b97e5b1c29d26dcc8dacec77a9358d5d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ready_op&lt;/code&gt;&lt;/b&gt;: 1-D string &lt;code&gt;Tensor&lt;/code&gt;. This tensor is evaluated by supervisors in &lt;code&gt;prepare_or_wait_for_session()&lt;/code&gt; to check if the model is ready to use. The model is considered ready if it returns an empty array. Defaults to the tensor returned from &lt;a href=&quot;../report_uninitialized_variables&quot;&gt;&lt;code&gt;tf.compat.v1.report_uninitialized_variables()&lt;/code&gt;&lt;/a&gt; If &lt;code&gt;None&lt;/code&gt;, the model is not checked for readiness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="395c8ea4a865918a35bbabd857d28bd924f90668" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ready_op&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;Operation&lt;/code&gt; to check if the model is initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42b870aa62e7026233aa13adaa19561216a1fd39" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ready_op&lt;/code&gt;&lt;/b&gt;: Optional op to verify that the variables are initialized. Must return an empty 1D string tensor when the variables are initialized, or a non-empty 1D string tensor listing the names of the non-initialized variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9aeabc598bc04ad753c440b1b7149282a2ce8ad" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;real&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b770623d6534598f5eafefeebdd48a2a0b6ff3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;recall&lt;/code&gt;&lt;/b&gt;: A float &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[len(thresholds)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa76a7f8f69bf29f15547de07d218e9c38d4f966" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;recall&lt;/code&gt;&lt;/b&gt;: A scalar value in range &lt;code&gt;[0, 1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36685d17690dd4398d17fe758dde4ddc73f54ff9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;recall&lt;/code&gt;&lt;/b&gt;: Scalar &lt;code&gt;float64&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; with the value of &lt;code&gt;true_positives&lt;/code&gt; divided by the sum of &lt;code&gt;true_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75fb453372bfde16388f3915874e54fd61506abe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;recall&lt;/code&gt;&lt;/b&gt;: Scalar float &lt;code&gt;Tensor&lt;/code&gt; with the value of &lt;code&gt;true_positives&lt;/code&gt; divided by the sum of &lt;code&gt;true_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b616fa585b592fa9d73541eaf43e839ad8c287" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;receiver_tensors&lt;/code&gt;&lt;/b&gt;: a &lt;code&gt;Tensor&lt;/code&gt;, or a dict of string to &lt;code&gt;Tensor&lt;/code&gt;, specifying input nodes that will be fed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74254706c86d0c254481da80616da916dce8c5f1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;record&lt;/code&gt;&lt;/b&gt;: str</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186255f0824805155c5644e4f5eabaca03d122b4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;record_bytes&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar representing the number of bytes in each record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1556473c1877bffc52b0a47c4ce14a5defa0bbe2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;record_bytes&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar representing the number of bytes in each record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3224f8c11d9f6ddceca94f5248d9cc386c457b00" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;record_bytes&lt;/code&gt;&lt;/b&gt;: An int.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d14f03e6c37898f583c01849fd31f0d59812458d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;record_defaults&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;Tensor&lt;/code&gt; objects with specific types. Acceptable types are &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;. One tensor per column of the input record, with either a scalar default value for that column or an empty vector if the column is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b22af98c72e1e7e43990cdf9ebbe9550154376b6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;record_defaults&lt;/code&gt;&lt;/b&gt;: A list of default values for the CSV fields. Each item in the list is either a valid CSV &lt;code&gt;DType&lt;/code&gt; (float32, float64, int32, int64, string), or a &lt;code&gt;Tensor&lt;/code&gt; object with one of the above types. One per column of CSV data, with either a scalar &lt;code&gt;Tensor&lt;/code&gt; default value for the column if it is optional, or &lt;code&gt;DType&lt;/code&gt; or empty &lt;code&gt;Tensor&lt;/code&gt; if required. If both this and &lt;code&gt;select_columns&lt;/code&gt; are specified, these must have the same lengths, and &lt;code&gt;column_defaults&lt;/code&gt; is assumed to be sorted in order of increasing column index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6abe1a9e6bdde951093e66baa1150aa5f3b5a54e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;records&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. Each string is a record/row in the csv and all records should have the same format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b79e56e78b656f9c9be5b0e8e61c66c22994fdae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;recovery_wait_secs&lt;/code&gt;&lt;/b&gt;: Number of seconds between checks that the model is ready. Used by supervisors when waiting for a chief supervisor to initialize or restore the model. Defaults to 30 seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a4908c600b5e85655ede381e441149ef124116e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;recovery_wait_secs&lt;/code&gt;&lt;/b&gt;: Seconds between checks for the model to be ready.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f6fce2c90a67786121374f8c6816bfb918806e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;recurrent_activation&lt;/code&gt;&lt;/b&gt;: Activation function to use for the recurrent step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86045cf20451d5ef88f3934ffb24225a8bf828fd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;recurrent_activation&lt;/code&gt;&lt;/b&gt;: Activation function to use for the recurrent step. Default: hard sigmoid (&lt;code&gt;hard_sigmoid&lt;/code&gt;). If you pass &lt;code&gt;None&lt;/code&gt;, no activation is applied (ie. &quot;linear&quot; activation: &lt;code&gt;a(x) = x&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baef8e4328507bbc05fdd4571ea672d30a1ab3d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;recurrent_activation&lt;/code&gt;&lt;/b&gt;: Activation function to use for the recurrent step. Default: sigmoid (&lt;code&gt;sigmoid&lt;/code&gt;). If you pass &lt;code&gt;None&lt;/code&gt;, no activation is applied (ie. &quot;linear&quot; activation: &lt;code&gt;a(x) = x&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06b3a240a42e721af1575a56e4017a895d756640" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;recurrent_constraint&lt;/code&gt;&lt;/b&gt;: Constraint function applied to the &lt;code&gt;recurrent_kernel&lt;/code&gt; weights matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a9453d9c36083b8fa244ae341fac9e4514bf927" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;recurrent_constraint&lt;/code&gt;&lt;/b&gt;: Constraint function applied to the &lt;code&gt;recurrent_kernel&lt;/code&gt; weights matrix. Default: &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3f427cad5cfc377bdf878e11e27e253d2b4c400" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;recurrent_dropout&lt;/code&gt;&lt;/b&gt;: Float between 0 and 1. Fraction of the units to drop for the linear transformation of the recurrent state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca084edd4bccea2006c196e00d6ddb4c48435cff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;recurrent_dropout&lt;/code&gt;&lt;/b&gt;: Float between 0 and 1. Fraction of the units to drop for the linear transformation of the recurrent state. Default: 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65ae855b2d77f8c982c5a4babbec08941fae728" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;recurrent_initializer&lt;/code&gt;&lt;/b&gt;: Initializer for the &lt;code&gt;recurrent_kernel&lt;/code&gt; weights matrix, used for the linear transformation of the recurrent state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="587efe5203ab0105026928b7451782e2ac3239be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;recurrent_initializer&lt;/code&gt;&lt;/b&gt;: Initializer for the &lt;code&gt;recurrent_kernel&lt;/code&gt; weights matrix, used for the linear transformation of the recurrent state. Default: &lt;code&gt;orthogonal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99499cc530dc496fd6f0340173428d7e2b964d3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;recurrent_regularizer&lt;/code&gt;&lt;/b&gt;: Regularizer function applied to the &lt;code&gt;recurrent_kernel&lt;/code&gt; weights matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95381115b30b7be2e0a74d26bfc39014adf1f923" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;recurrent_regularizer&lt;/code&gt;&lt;/b&gt;: Regularizer function applied to the &lt;code&gt;recurrent_kernel&lt;/code&gt; weights matrix. Default: &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b8cfc769de67848fed80eeb3bc5c9f34a0e768" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;recursive&lt;/code&gt;&lt;/b&gt;: Whether to recursively convert any functions that the converted function may call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffaca5c1b4663c45d0ef55d3855b53642ed841a2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduce_func&lt;/code&gt;&lt;/b&gt;: A function mapping a key and a dataset of up to &lt;code&gt;window_size&lt;/code&gt; consecutive elements matching that key to another dataset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b7aa420e67b5690b1a66949a387853687e3d0ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduce_func&lt;/code&gt;&lt;/b&gt;: A function that maps &lt;code&gt;(old_state, input_element)&lt;/code&gt; to &lt;code&gt;new_state&lt;/code&gt;. It must take two arguments and return a new element The structure of &lt;code&gt;new_state&lt;/code&gt; must match the structure of &lt;code&gt;initial_state&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244eacb93b0c7b9bb5f778ee5b4ad937a1e6fb44" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduce_op&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../../distribute/reduceop&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp&lt;/code&gt;&lt;/a&gt; value specifying how values should be combined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a067464ac22bcdac41c6784a43ad69a4d7d5696" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduce_op&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../distribute/reduceop&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp&lt;/code&gt;&lt;/a&gt; value specifying how values should be combined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15c52fb73f52b6c75610b12325405c32eb39ebd1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduce_op&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../reduceop&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp&lt;/code&gt;&lt;/a&gt; value specifying how values should be combined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="211fb7ba018d75dbd70d7281da91432079cf9711" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduce_op&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;reduceop&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp&lt;/code&gt;&lt;/a&gt; value specifying how values should be combined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6cf30252cdb7a4cb292a3faf73bf53435e29ed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduce_op&lt;/code&gt;&lt;/b&gt;: An instance &lt;a href=&quot;reduceop&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp&lt;/code&gt;&lt;/a&gt; that indicates of how per_replica_value will be reduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5184b90d0254de5568de2932aa84b54dc6445b53" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduce_op&lt;/code&gt;&lt;/b&gt;: An instance of &lt;a href=&quot;reduceop&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp&lt;/code&gt;&lt;/a&gt; that indicates how per_replica_value will be reduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02b8941ec1e7a8c95193b89c74a196c6eca50507" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduce_op&lt;/code&gt;&lt;/b&gt;: An instance of &lt;a href=&quot;reduceop&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp&lt;/code&gt;&lt;/a&gt; that indicates how the &lt;code&gt;per_replica_value&lt;/code&gt; will be reduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11bbf51c0a2a7d3acc5e0bfd440f516dfce1b413" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduce_op&lt;/code&gt;&lt;/b&gt;: Reduction type, an instance of &lt;a href=&quot;../../../distribute/reduceop&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437aa74c1ecb96c219de2277566b4b994f40149a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduce_op&lt;/code&gt;&lt;/b&gt;: Reduction type, an instance of &lt;a href=&quot;reduceop&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp&lt;/code&gt;&lt;/a&gt; enum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="838922e4ad3af38a78e8bddb8e177c713e5f29c8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduce_to_device&lt;/code&gt;&lt;/b&gt;: the intermediate device to reduce to. If None, reduce to the first device in &lt;code&gt;destinations&lt;/code&gt; of the &lt;code&gt;reduce()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69a9ec0c6baf4512d094373c6c61c38d6e997c53" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reducer&lt;/code&gt;&lt;/b&gt;: An instance of &lt;code&gt;Reducer&lt;/code&gt;, which captures the reduction logic using the &lt;code&gt;init_func&lt;/code&gt;, &lt;code&gt;reduce_func&lt;/code&gt;, and &lt;code&gt;finalize_func&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e22e415d667c40712e85d528d01b9dec0aeca377" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduction&lt;/code&gt;&lt;/b&gt;: (Optional) Type of &lt;a href=&quot;reduction&quot;&gt;&lt;code&gt;tf.keras.losses.Reduction&lt;/code&gt;&lt;/a&gt; to apply to loss. Default value is &lt;code&gt;AUTO&lt;/code&gt;. &lt;code&gt;AUTO&lt;/code&gt; indicates that the reduction option will be determined by the usage context. For almost all cases this defaults to &lt;code&gt;SUM_OVER_BATCH_SIZE&lt;/code&gt;. When used with &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;, outside of built-in training loops such as &lt;a href=&quot;../../keras&quot;&gt;&lt;code&gt;tf.keras&lt;/code&gt;&lt;/a&gt;&lt;code&gt;compile&lt;/code&gt; and &lt;code&gt;fit&lt;/code&gt;, using &lt;code&gt;AUTO&lt;/code&gt; or &lt;code&gt;SUM_OVER_BATCH_SIZE&lt;/code&gt; will raise an error. Please see https://www.tensorflow.org/tutorials/distribute/custom_training for more details on this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="123ae2900a0083495a3624d464e6469b8582c2c2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduction&lt;/code&gt;&lt;/b&gt;: The reduction to apply to the shard losses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d536102a8160451e8174b4f252f6d1a03146dea0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduction&lt;/code&gt;&lt;/b&gt;: Type of reduction to apply to loss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5483971bbb61ef07c520c6823e94eb1fb7704304" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduction_axes&lt;/code&gt;&lt;/b&gt;: Deprecated name of &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c801f9d5b2dc35c998caf87f81c484e826e0f96" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduction_axes&lt;/code&gt;&lt;/b&gt;: Deprecated name of axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21cc2a840a4966ee28aec8fc8807f61b41db1438" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduction_axes&lt;/code&gt;&lt;/b&gt;: iterable of integers, axes over which to normalize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13605c005e24c5775f60c9dab98388893a3bf960" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduction_indices&lt;/code&gt;&lt;/b&gt;: The old (deprecated) name for axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feae645b1235eb331b374c4d735a1b9f42e5f5d9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reduction_type&lt;/code&gt;&lt;/b&gt;: Reduction type to use when taking the gradient.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a100b4656b711438ff490e8c7cb57014a1a759fc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Variable&lt;/code&gt; to scatter onto.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b19e83d781fcefea1202651555a6c62d07514b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Variable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a5c8af97f91a82577e82496d99c1284aafeacc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/b&gt;: A Variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8c86d87df2a58a4f9e610f7e160e8348ad14645" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/b&gt;: A Variable. Must be one of the following types: &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. Should be from a scalar &lt;code&gt;Variable&lt;/code&gt; node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f45d18cb8e70b685c3e229a330243eb21e5f3c20" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/b&gt;: A mutable &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;qint8&lt;/code&gt;, &lt;code&gt;quint8&lt;/code&gt;, &lt;code&gt;qint32&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;. A mutable Tensor. Should be from a Variable node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27891a8af7e698ef071918fa73819f0feaa0a15" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/b&gt;: A mutable &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;qint8&lt;/code&gt;, &lt;code&gt;quint8&lt;/code&gt;, &lt;code&gt;qint32&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;. Should be from a &lt;code&gt;Variable&lt;/code&gt; node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86448f40471786964c56c324a3f6b7f9be5d51db" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/b&gt;: A mutable &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;, &lt;code&gt;qint8&lt;/code&gt;, &lt;code&gt;quint8&lt;/code&gt;, &lt;code&gt;qint32&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;. Should be from a &lt;code&gt;Variable&lt;/code&gt; node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42407c8bd01455b73ec69cb551b6195079fbd717" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/b&gt;: A mutable &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. Should be from a &lt;code&gt;Variable&lt;/code&gt; node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af69a5b152ec4328057534a1bb9b7d1c5dce29da" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/b&gt;: A mutable &lt;code&gt;Tensor&lt;/code&gt;. Should be from a &lt;code&gt;Variable&lt;/code&gt; node. May be uninitialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72777f218ae6d09d5364c114333994f638c775e8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reference&lt;/code&gt;&lt;/b&gt;: A tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cced6d60110eff0bf3bb059a61e0b02a49dcea8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reflection_axis&lt;/code&gt;&lt;/b&gt;: Shape &lt;code&gt;[B1,...,Bb, N]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; with &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;&lt;code&gt;N &amp;gt;= 0&lt;/code&gt;. The vector defining the hyperplane to reflect about. Allowed dtypes: &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edea66b4b7b9e98d2d27c85d85f634b12500fe9f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;regexes&lt;/code&gt;&lt;/b&gt;: List of regular expression byte strings that match success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f1eb2fb25049f18d07cca7bdf0efbe902c8a0d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;regexes&lt;/code&gt;&lt;/b&gt;: The regular expressions we want to match against str. See &quot;Notes&quot; above for detailed notes on how this is interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce61f8faa8214bbd26fe6dc59650f79f5664d74" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;regexes&lt;/code&gt;&lt;/b&gt;: the list of regular expression strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de82f371514626ef1e51ef20c7bc5fa3f18fff89" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;regularization_loss&lt;/code&gt;&lt;/b&gt;: Regularization loss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87fbc48102bfee8d5652da21234a9ada8a517bed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;regularization_losses&lt;/code&gt;&lt;/b&gt;: A list of additional scalar losses to be added to the training and evaluation loss, such as regularization losses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70dc1de5f7af14ba305729910ab3894890dec133" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;regularization_losses&lt;/code&gt;&lt;/b&gt;: A list of additional scalar losses to be added to the training loss, such as regularization losses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="527d541d97a5050d8e59d7dcd00023290fb0964c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;regularization_losses&lt;/code&gt;&lt;/b&gt;: A list of additional scalar losses to be added to the training loss, such as regularization losses. These losses are usually expressed as a batch average, so for best results, in each head, users need to use the default &lt;code&gt;loss_reduction=SUM_OVER_BATCH_SIZE&lt;/code&gt; to avoid scaling errors. Compared to the regularization losses for each head, this loss is to regularize the merged loss of all heads in multi head, and will be added to the overall training loss of multi head.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd2a485f397c5d3bb59ef8e7896c42f74e072b1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;regularizer&lt;/code&gt;&lt;/b&gt;: A (Tensor -&amp;gt; Tensor or None) function; the result of applying it on a newly created variable will be added to the collection &lt;code&gt;tf.GraphKeys.REGULARIZATION_LOSSES&lt;/code&gt; and can be used for regularization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155f4285d2cc4f5fae760f8fb68e482ad7cbbf32" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;regularizer&lt;/code&gt;&lt;/b&gt;: Regularizer instance (callable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e08544d201ac3238daef72720730ae2609addddb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;regularizer&lt;/code&gt;&lt;/b&gt;: default regularizer for variables within this scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883e0412c9c3dc1f62f3c24e73081cac0f2cdb9a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;regularizer&lt;/code&gt;&lt;/b&gt;: default regularizer passed to get_variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ab201f35954f53f04efb98990b6fb05c573425d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;relative_path&lt;/code&gt;&lt;/b&gt;: a path relative to tensorflow root. e.g. &quot;core/platform&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="646c0ead55d52bf0fd07521bc371f481b1b14b40" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;relative_tolerance&lt;/code&gt;&lt;/b&gt;: A relative tolerance of change in the loss between iterations. Stops learning if the loss changes less than this amount. This may not work correctly if &lt;code&gt;use_mini_batch=True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ffeff42448427258597800c2675b03d146b5bc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;remote_host&lt;/code&gt;&lt;/b&gt;: a single or a list the remote server addr in host-port format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d4c7571b8d9d2be29153589fd7ddfcaa6583f79" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;remove_accidental_hits&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;bool&lt;/code&gt;. Whether to remove &quot;accidental hits&quot; where a sampled class equals one of the target classes. If set to &lt;code&gt;True&lt;/code&gt;, this is a &quot;Sampled Logistic&quot; loss instead of NCE, and we are learning to generate log-odds instead of log probabilities. See our &lt;a href=&quot;https://www.tensorflow.org/extras/candidate_sampling.pdf&quot;&gt;Candidate Sampling Algorithms Reference&lt;/a&gt;. Default is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24ac18d052ee3000377fdac92d3815b4021ebcb5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;remove_accidental_hits&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;bool&lt;/code&gt;. whether to remove &quot;accidental hits&quot; where a sampled class equals one of the target classes. Default is True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9623ccdb78715f6dc9c8c6bd19fceba635315eb9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;renorm&lt;/code&gt;&lt;/b&gt;: Whether to use Batch Renormalization (https://arxiv.org/abs/1702.03275). This adds extra variables during training. The inference is the same for either value of this parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c1fca85eddec51ffc63b53b37cfc9fc0e5457b3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;renorm_clipping&lt;/code&gt;&lt;/b&gt;: A dictionary that may map keys 'rmax', 'rmin', 'dmax' to scalar &lt;code&gt;Tensors&lt;/code&gt; used to clip the renorm correction. The correction &lt;code&gt;(r, d)&lt;/code&gt; is used as &lt;code&gt;corrected_value = normalized_value * r + d&lt;/code&gt;, with &lt;code&gt;r&lt;/code&gt; clipped to [rmin, rmax], and &lt;code&gt;d&lt;/code&gt; to [-dmax, dmax]. Missing rmax, rmin, dmax are set to inf, 0, inf, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcfe997950adc2c7678f13284153d33c09cbaa99" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;renorm_momentum&lt;/code&gt;&lt;/b&gt;: Momentum used to update the moving means and standard deviations with renorm. Unlike &lt;code&gt;momentum&lt;/code&gt;, this affects training and should be neither too small (which would add noise) nor too large (which would give stale estimates). Note that &lt;code&gt;momentum&lt;/code&gt; is still applied to get the means and variances for inference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a023a82d149b2a1287f088767f1233517dafc95f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reorder_across_fake_quant&lt;/code&gt;&lt;/b&gt;: Boolean indicating whether to reorder FakeQuant nodes in unexpected locations. Used when the location of the FakeQuant nodes is preventing graph transformations necessary to convert the graph. Results in a graph that differs from the quantized training graph, potentially causing differing arithmetic behavior. (default False)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c53e1724ffea5b3a28bfb0cadce8203cd0c9737" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rep&lt;/code&gt;&lt;/b&gt;: Python integer, number of times to repeat.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b7d103509adb15d63184dee9f55d40ea71a4c4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reparameterization_type&lt;/code&gt;&lt;/b&gt;: Instance of &lt;code&gt;ReparameterizationType&lt;/code&gt;. If &lt;a href=&quot;https://www.tensorflow.org/probability/api_docs/python/tfp/distributions#FULLY_REPARAMETERIZED&quot;&gt;&lt;code&gt;distributions.FULLY_REPARAMETERIZED&lt;/code&gt;&lt;/a&gt;, this &lt;code&gt;Distribution&lt;/code&gt; can be reparameterized in terms of some standard distribution with a function whose Jacobian is constant for the support of the standard distribution. If &lt;a href=&quot;https://www.tensorflow.org/probability/api_docs/python/tfp/distributions#NOT_REPARAMETERIZED&quot;&gt;&lt;code&gt;distributions.NOT_REPARAMETERIZED&lt;/code&gt;&lt;/a&gt;, then no such reparameterization is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bb6678d0d0509c6c06d4b6bc30bb37caaf3e4c2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;repeats&lt;/code&gt;&lt;/b&gt;: An 1-D &lt;code&gt;int&lt;/code&gt; Tensor. The number of repetitions for each element. repeats is broadcasted to fit the shape of the given axis. &lt;code&gt;len(repeats)&lt;/code&gt; must equal &lt;code&gt;input.shape[axis]&lt;/code&gt; if axis is not None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c4ef2e00ed8b2ba461be70e8e47282b8d3adad" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;replace_control_characters&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;bool&lt;/code&gt;. Defaults to &lt;code&gt;False&lt;/code&gt;. Whether to replace the C0 control characters (00-1F) with the &lt;code&gt;replacement_char&lt;/code&gt;. Default is false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1092fbd3fe7a1e097927332b00c3841383be2701" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;replace_control_characters&lt;/code&gt;&lt;/b&gt;: Whether to replace the C0 control characters &lt;code&gt;(U+0000 - U+001F)&lt;/code&gt; with the &lt;code&gt;replacement_char&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="017d87e5c214c331d92a60ae5e9b816da0717f5e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;replace_global&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;bool&lt;/code&gt;, if &lt;code&gt;True&lt;/code&gt; replace all non-overlapping matches, else replace only the first match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="088f148a2df650f41a8fb540e0a6160b7b74b9be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;replacement_char&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;int&lt;/code&gt;. Defaults to &lt;code&gt;65533&lt;/code&gt;. The replacement character codepoint to be used in place of any invalid formatting in the input when &lt;code&gt;errors='replace'&lt;/code&gt;. Any valid unicode codepoint may be used. The default value is the default unicode replacement character is 0xFFFD or U+65533.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc260bcfc978af52e3fbfdad99d88fd12749336" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;replacement_char&lt;/code&gt;&lt;/b&gt;: The replacement character codepoint to be used in place of any invalid input when &lt;code&gt;errors='replace'&lt;/code&gt;. Any valid unicode codepoint may be used. The default value is the default unicode replacement character which is 0xFFFD (U+65533).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19846a676140c8b6ef1670cfbf4b7f45dcb711e9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;replacement_char&lt;/code&gt;&lt;/b&gt;: The replacement codepoint to be used in place of invalid substrings in &lt;code&gt;input&lt;/code&gt; when &lt;code&gt;errors='replace'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a52586601f4806420b6f190713eca665a4edd502" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;replacement_char&lt;/code&gt;&lt;/b&gt;: The replacement codepoint to be used in place of invalid substrings in &lt;code&gt;input&lt;/code&gt; when &lt;code&gt;errors='replace'&lt;/code&gt;; and in place of C0 control characters in &lt;code&gt;input&lt;/code&gt; when &lt;code&gt;replace_control_characters=True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7c2afdb01dccb457d8b4d7c08ee1837be13e51" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;replica&lt;/code&gt;&lt;/b&gt;: int. Optional replica index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a49dd555845c5772ddaf9b13c2c3385b63909a16" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;replicas_to_aggregate&lt;/code&gt;&lt;/b&gt;: number of replicas to aggregate for each variable update.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e867588c0e7f02bd5c282e70e6db5e91ff4bee6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;replication_mode&lt;/code&gt;&lt;/b&gt;: an enum value of &lt;a href=&quot;../../../../distribute/inputreplicationmode&quot;&gt;&lt;code&gt;tf.distribute.InputReplicationMode&lt;/code&gt;&lt;/a&gt;. Only &lt;code&gt;PER_WORKER&lt;/code&gt; is supported currently, which means there will be a single call to &lt;code&gt;input_fn&lt;/code&gt; per worker. Replicas will dequeue from the local &lt;a href=&quot;../../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; on their worker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96027064e27365359c7d8b629b10889343fec8f1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;replication_mode&lt;/code&gt;&lt;/b&gt;: an enum value of &lt;a href=&quot;../../../distribute/inputreplicationmode&quot;&gt;&lt;code&gt;tf.distribute.InputReplicationMode&lt;/code&gt;&lt;/a&gt;. Only &lt;code&gt;PER_WORKER&lt;/code&gt; is supported currently, which means there will be a single call to &lt;code&gt;input_fn&lt;/code&gt; per worker. Replicas will dequeue from the local &lt;a href=&quot;../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; on their worker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc26604a5bd1486deadd524ba51a6e50c75cd31" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;representative_dataset&lt;/code&gt;&lt;/b&gt;: A representative dataset that can be used to generate input and output samples for the model. The converter can use the dataset to evaluate different optimizations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362840239879226869f4e422b57fd83040387d71" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;required&lt;/code&gt;&lt;/b&gt;: bool. If true, exactly one flag must be True. Otherwise, at most one flag can be True, and it is valid for all flags to be False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51a4fe73c81902747e5f349f839fe35b0971c22b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;required&lt;/code&gt;&lt;/b&gt;: bool. If true, exactly one of the flags must have a value other than None. Otherwise, at most one of the flags can have a value other than None, and it is valid for all of the flags to be None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c54d9af392621f5eb8b6dbbaa300d845e0a125" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;res&lt;/code&gt;&lt;/b&gt;: dictionary containing variables in both &lt;code&gt;sk_params&lt;/code&gt; and &lt;code&gt;fn&lt;/code&gt;'s arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edf472ae5cdc60b299a64d7d615fc3097b49169a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rescale&lt;/code&gt;&lt;/b&gt;: rescaling factor. Defaults to None. If None or 0, no rescaling is applied, otherwise we multiply the data by the value provided (after applying all other transformations).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7879f4bc1079c90968103eac8941981863cd73e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reset_after&lt;/code&gt;&lt;/b&gt;: GRU convention (whether to apply reset gate after or before matrix multiplication). False = &quot;before&quot; (default), True = &quot;after&quot; (CuDNN compatible).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c080dca12cdb48edbe3fb02b1afa9091b750f5d5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reset_after&lt;/code&gt;&lt;/b&gt;: GRU convention (whether to apply reset gate after or before matrix multiplication). False = &quot;before&quot;, True = &quot;after&quot; (default and CuDNN compatible).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0c5f222736547097967b7db6ee18e3ce32c4288" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reset_metrics&lt;/code&gt;&lt;/b&gt;: If &lt;code&gt;True&lt;/code&gt;, the metrics returned will be only for this batch. If &lt;code&gt;False&lt;/code&gt;, the metrics will be statefully accumulated across batches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91ec40a3d429b929215e7cd844eebe2c2cffa6a6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reset_state&lt;/code&gt;&lt;/b&gt;: Optional argument specifying whether to clear the state of the layer at the start of the call to &lt;code&gt;adapt&lt;/code&gt;, or whether to start from the existing state. Subclasses may choose to throw if reset_state is set to 'False'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e33ea91b6c7315bf93c7a831d0a66720c9a4fe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reset_state&lt;/code&gt;&lt;/b&gt;: Optional argument specifying whether to clear the state of the layer at the start of the call to &lt;code&gt;adapt&lt;/code&gt;, or whether to start from the existing state. This argument may not be relevant to all preprocessing layers: a subclass of PreprocessingLayer may choose to throw if 'reset_state' is set to False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8010ffbcbd7db2980d897f54cf66a761eb1809f9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reset_state&lt;/code&gt;&lt;/b&gt;: Optional argument specifying whether to clear the state of the layer at the start of the call to &lt;code&gt;adapt&lt;/code&gt;. This must be True for this layer, which does not support repeated calls to &lt;code&gt;adapt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d486d490aa8de789669fdf8d75d52fa1ef13e377" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reshape&lt;/code&gt;&lt;/b&gt;: If &lt;code&gt;True&lt;/code&gt;, allows restoring parameters from a checkpoint where the variables have a different shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa9dfb95baa9496f30a285e77011daf5e7997d7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reshuffle_each_iteration&lt;/code&gt;&lt;/b&gt;: (Optional.) A boolean, which if true indicates that the dataset should be pseudorandomly reshuffled each time it is iterated over. (Defaults to &lt;code&gt;True&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c969bd27bd05ead02e2e880051dcb936cd7a72fd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;residual_fn&lt;/code&gt;&lt;/b&gt;: (Optional) The function to map raw cell inputs and raw cell outputs to the actual cell outputs of the residual network. Defaults to calling nest.map_structure on (lambda i, o: i + o), inputs and outputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b54cfa364768f4557bb960c32eb1e77bd28d481" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;restore_best_weights&lt;/code&gt;&lt;/b&gt;: Whether to restore model weights from the epoch with the best value of the monitored quantity. If False, the model weights obtained at the last step of training are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89dd6aa7a6b40dc9e347bf521531bcc9b44cc093" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;restore_op_name&lt;/code&gt;&lt;/b&gt;: Name of the op to use to restore the graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ed3dad602b0af10cf6f58b84592fbae93dfe38" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;restore_sequentially&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Bool&lt;/code&gt;, which if true, causes restore of different variables to happen sequentially within each device. This can lower memory usage when restoring very large models.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f26b2499af09c245d4f2782eb3388f95f4dd37d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/b&gt;: The tensor type for the result: one of &lt;code&gt;&quot;RaggedTensor&quot;&lt;/code&gt; or &lt;code&gt;&quot;SparseTensor&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d972915648e2ffde6d5e9bf87164ebeeb40352" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;results&lt;/code&gt;&lt;/b&gt;: The return values from &lt;code&gt;Session.run()&lt;/code&gt; corresponding to the fetches attribute returned in the RunArgs. Note that this has the same shape as the RunArgs fetches. For example: fetches = global_step_tensor =&amp;gt; results = nparray(int) fetches = [train_op, summary_op, global_step_tensor] =&amp;gt; results = [None, nparray(string), nparray(int)] fetches = {'step': global_step_tensor, 'summ': summary_op} =&amp;gt; results = {'step': nparray(int), 'summ': nparray(string)}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a084b96673ad2c8db61736d77d88c439e859b7ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;return_elements&lt;/code&gt;&lt;/b&gt;: A list of strings containing operation names in &lt;code&gt;graph_def&lt;/code&gt; that will be returned as &lt;code&gt;Operation&lt;/code&gt; objects; and/or tensor names in &lt;code&gt;graph_def&lt;/code&gt; that will be returned as &lt;code&gt;Tensor&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6f861c6e5d2c55288e1f9cfeb7e5c5e3c16e2b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;return_same_structure&lt;/code&gt;&lt;/b&gt;: If True, output has same structure as &lt;code&gt;loop_vars&lt;/code&gt;. If eager execution is enabled, this is ignored (and always treated as True).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8dd98a5d69d55b7d2d8efd5a40a83e71dee2c29" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;return_sequences&lt;/code&gt;&lt;/b&gt;: A boolean indicating whether to return the last output in the output sequence, or the full sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8c1db57db4fc33ce18a097ad6034abd37cdd81" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;return_sequences&lt;/code&gt;&lt;/b&gt;: A boolean indicating whether to return the last output in the output sequence, or the full sequence. Note that if True, &lt;code&gt;weight_column&lt;/code&gt; must be None or a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6417028b17c6734d0acb58f8cab5f078158eae27" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;return_sequences&lt;/code&gt;&lt;/b&gt;: Boolean (default &lt;code&gt;False&lt;/code&gt;). Whether to return the last output in the output sequence, or the full sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a070719d56da7624812c49b56d16cd28117b01f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;return_sequences&lt;/code&gt;&lt;/b&gt;: Boolean. Whether to return the last output in the output sequence, or the full sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c57d82b881243c3647b7001c4e6a13e9c85d11" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;return_sequences&lt;/code&gt;&lt;/b&gt;: Boolean. Whether to return the last output in the output sequence, or the full sequence. Default: &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f655d75f57c78ce6f9bf5d8706ef5bc4c4d6bea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;return_sequences&lt;/code&gt;&lt;/b&gt;: Boolean. Whether to return the last output. in the output sequence, or the full sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25dd47bd6d38cacf3117ebb0c6a5507a8fe1cbc9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;return_sequences&lt;/code&gt;&lt;/b&gt;: Boolean. Whether to return the last output. in the output sequence, or the full sequence. Default: &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a538f74c205b1986c9b354f8f04ca331334c213" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;return_state&lt;/code&gt;&lt;/b&gt;: Boolean (default &lt;code&gt;False&lt;/code&gt;). Whether to return the last state in addition to the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff35233d75b03df9760b39cf62355f8a8869d33" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;return_state&lt;/code&gt;&lt;/b&gt;: Boolean. Whether to return the last state in addition to the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd7789a35b4587f4be80bb45a30f98060898819c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;return_state&lt;/code&gt;&lt;/b&gt;: Boolean. Whether to return the last state in addition to the output. Default: &lt;code&gt;False&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa791e7ef1848e7ca573746697ded8120a88e8c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;return_state&lt;/code&gt;&lt;/b&gt;: Boolean. Whether to return the last state in addition to the output. Default: &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a32718ed7e9a80591900a234ad2afbb64136864d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reuse&lt;/code&gt;&lt;/b&gt;: (optional) Python boolean describing whether to reuse variables in an existing scope. If not &lt;code&gt;True&lt;/code&gt;, and the existing scope already has the given variables, an error is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6002581c3a74116d44e6325e7b64b7bd69f55286" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reuse&lt;/code&gt;&lt;/b&gt;: (optional) Python boolean describing whether to reuse variables in an existing scope. Raises an error if not &lt;code&gt;True&lt;/code&gt; and the existing scope already has the given variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a68ceac7d2675019da576c71cb9c6b9b3e41b27" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reuse&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;True&lt;/code&gt;, None, or tf.compat.v1.AUTO_REUSE; if &lt;code&gt;True&lt;/code&gt;, we go into reuse mode for this scope as well as all sub-scopes; if tf.compat.v1.AUTO_REUSE, we create variables if they do not exist, and return them otherwise; if None, we inherit the parent scope's reuse flag. When eager execution is enabled, new variables are always created unless an EagerVariableStore or template is currently active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41950a022cd3e610bf3b74aedf3700086b514cb8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reuse&lt;/code&gt;&lt;/b&gt;: Boolean or &lt;code&gt;None&lt;/code&gt;; if &lt;code&gt;True&lt;/code&gt; and name is set, it would reuse previously created variables. if &lt;code&gt;False&lt;/code&gt; it will create new variables. if &lt;code&gt;None&lt;/code&gt;, it would inherit the parent scope reuse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="280da40f9bb3bd3dd9f192320a49021b3402f824" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reuse&lt;/code&gt;&lt;/b&gt;: Boolean, None, or tf.compat.v1.AUTO_REUSE, setting the reuse in get_variable. When eager execution is enabled this argument is always forced to be False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="067c802d35c8c442c3cde80cc147caf39da09c8c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reuse&lt;/code&gt;&lt;/b&gt;: Boolean, whether to reuse the weights of a previous layer by the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1312a51784ccbdf3cb60308d58d89bc317a42707" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/b&gt;: (optional) True scans the tensor last to first (instead of first to last).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742ae35d372f0efb2c27f803ceebd40eaf09c8cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;bool&lt;/code&gt; (default: False).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04dac41e03b0afca80e010718289cc6ff1f93cb1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;reverse&lt;/code&gt;&lt;/b&gt;: If &lt;code&gt;True&lt;/code&gt;, performs the cumulative log-sum-exp in the reverse direction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59dfcc711c6e57ac9ecc0ea727cc51c285e51fe5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rewrite&lt;/code&gt;&lt;/b&gt;: string or scalar string &lt;code&gt;Tensor&lt;/code&gt;, value to use in match replacement, supports backslash-escaped digits (\1 to \9) can be to insert text matching corresponding parenthesized group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78e5c73c18a56770db16f46c26decd21b13b17b2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rho&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; or a floating point value. The decay rate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de82072d6ede3c7bff682b63de45548b6ac52ee8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rho&lt;/code&gt;&lt;/b&gt;: Discounting factor for the history/coming gradient</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbeeaf55dd4b38dd014c1e48442ed4aff7fcd1b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rhs&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[..., M, K]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c16a9b8e7024f645f6543fc0d0b75cbe065f47d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rhs&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; with same &lt;code&gt;dtype&lt;/code&gt; as this operator and compatible shape. &lt;code&gt;rhs&lt;/code&gt; is treated like a [batch] matrix meaning for every set of leading dimensions, the last two dimensions defines a matrix. See class docstring for definition of compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d21b64d9609ed52256509857d17f2f9963701d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rhs&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; with same &lt;code&gt;dtype&lt;/code&gt; as this operator. &lt;code&gt;rhs&lt;/code&gt; is treated like a [batch] vector meaning for every set of leading dimensions, the last dimension defines a vector. See class docstring for definition of compatibility regarding batch dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="897c81ffc537780dedc1b4663c6f7b32602520d2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rhs&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of shape [..., M, N] and with the same dtype as &lt;code&gt;diagonals&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5407c9ab1e200b8a591ae95223ca2f822a61a778" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rhs&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of shape [..., M] or [..., M, K] and with the same dtype as &lt;code&gt;diagonals&lt;/code&gt;. Note that if the shape of &lt;code&gt;rhs&lt;/code&gt; and/or &lt;code&gt;diags&lt;/code&gt; isn't known statically, &lt;code&gt;rhs&lt;/code&gt; will be treated as a matrix rather than a vector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c611ba1c43c6fd2040eda60e2fa486a0ce5e719" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rhs&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;, same type as &lt;code&gt;chol&lt;/code&gt;, shape is &lt;code&gt;[..., M, K]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fd61f895e4d874972e1c982084331337d9b8b11" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rhs&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must have the same type as &lt;code&gt;matrix&lt;/code&gt;. Shape is &lt;code&gt;[..., M, K]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff8eb08a3eabecb6421e4e36e0156bcead81797f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rhs&lt;/code&gt;&lt;/b&gt;: Matrix-shaped float &lt;code&gt;Tensor&lt;/code&gt; representing targets for which to solve; &lt;code&gt;A X = RHS&lt;/code&gt;. To handle vector cases, use: &lt;code&gt;lu_solve(..., rhs[..., tf.newaxis])[..., 0]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5547a2c6029878fe7f39affbd31aec9e0fad72" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rnn_cell_fn&lt;/code&gt;&lt;/b&gt;: A function that returns a RNN cell instance that will be used to construct the RNN. If set, &lt;code&gt;units&lt;/code&gt; and &lt;code&gt;cell_type&lt;/code&gt; cannot be set. This is for advanced users who need additional customization beyond &lt;code&gt;units&lt;/code&gt; and &lt;code&gt;cell_type&lt;/code&gt;. Note that &lt;a href=&quot;../../keras/layers/stackedrnncells&quot;&gt;&lt;code&gt;tf.keras.layers.StackedRNNCells&lt;/code&gt;&lt;/a&gt; is needed for stacked RNNs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e782fdacc57edc96753c1ef3bc9dc0042c77ef3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;roi_probabilities&lt;/code&gt;&lt;/b&gt;: scores of the roi boxes in the rois tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef87035d649d912bf37945c8a192beabcac857a4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rois&lt;/code&gt;&lt;/b&gt;: Region of interest boxes sorted by their scores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a50ebbb2697771b56ec479d05fe497a68f4ea4c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;root&lt;/code&gt;&lt;/b&gt;: String; root url of the target server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a5de9b37907ddba311f8a58bbf7bb4ec89242a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;root_mean_squared_error&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; representing the current mean, the value of &lt;code&gt;total&lt;/code&gt; divided by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450235af853701481727520717cc5022524cb11f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rotation_range&lt;/code&gt;&lt;/b&gt;: Int. Degree range for random rotations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="064e43fa073713de3f079c8d1ad5d3e94cefb24f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;round_mode&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;string&lt;/code&gt; from: &lt;code&gt;&quot;HALF_AWAY_FROM_ZERO&quot;, &quot;HALF_TO_EVEN&quot;&lt;/code&gt;. Defaults to &lt;code&gt;&quot;HALF_AWAY_FROM_ZERO&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d840268480bb24c64eded51cb927ba6da591db48" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;round_mode&lt;/code&gt;&lt;/b&gt;: Rounding mode when rounding from float values to quantized ones. one of ['HALF_TO_EVEN', 'HALF_UP']</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ff991b3483b1ed0699a1c70a9e07f0332ee290" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;row&lt;/code&gt;&lt;/b&gt;: Shape &lt;code&gt;[B1,...,Bb, N]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; with &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;&lt;code&gt;N &amp;gt;= 0&lt;/code&gt;. The first row of the operator. Allowed dtypes: &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;. Note that the first entry of &lt;code&gt;row&lt;/code&gt; is assumed to be the same as the first entry of &lt;code&gt;col&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="929750bb0008fe963687affaeb8a7799f6bba53e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;row_lengths&lt;/code&gt;&lt;/b&gt;: A 1-D integer tensor with shape &lt;code&gt;[nrows]&lt;/code&gt;. Must be nonnegative. &lt;code&gt;sum(row_lengths)&lt;/code&gt; must be &lt;code&gt;nvals&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69cbd110967834cb9229e47d6fdb6b9f942ffe92" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;row_limits&lt;/code&gt;&lt;/b&gt;: A 1-D integer tensor with shape &lt;code&gt;[nrows]&lt;/code&gt;. Must be sorted in ascending order. If &lt;code&gt;nrows&amp;gt;0&lt;/code&gt;, then &lt;code&gt;row_limits[-1]&lt;/code&gt; must be &lt;code&gt;nvals&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="232d49644bfae20b040e7c95afa22b0df1e31d57" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;row_shape&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; vector tensor-like object representing the equivalent dense shape of a row in the resulting &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt;. Each element of this dataset must have the same rank as &lt;code&gt;row_shape&lt;/code&gt;, and must have size less than or equal to &lt;code&gt;row_shape&lt;/code&gt; in each dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="686f747b3409b6ec94422663a0c9d129b4887b0d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;row_splits&lt;/code&gt;&lt;/b&gt;: A 1-D int32 or int64 numpy array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="671aafb1df12a1f60575b89040fa0143d557f0bd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;row_splits&lt;/code&gt;&lt;/b&gt;: A 1-D integer tensor with shape &lt;code&gt;[nrows+1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c02e7632eda7423004254933d8ad6eb3b093a6dd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;row_splits&lt;/code&gt;&lt;/b&gt;: A 1-D integer tensor with shape &lt;code&gt;[nrows+1]&lt;/code&gt;. Must not be empty, and must be sorted in ascending order. &lt;code&gt;row_splits[0]&lt;/code&gt; must be zero and &lt;code&gt;row_splits[-1]&lt;/code&gt; must be &lt;code&gt;nvals&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cee86cfc42da71cc549b807e8164d684d89a1aa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;row_splits_dtype&lt;/code&gt;&lt;/b&gt;: (Optional.) Data type for the row-partitioning tensor(s). One of &lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt;. Defaults to &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f968cbbaa0f3095b4ed3bcc9466255a11bb8c7b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;row_splits_dtype&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;dtype&lt;/code&gt; for the RaggedTensor's &lt;code&gt;row_splits&lt;/code&gt; tensor. One of &lt;a href=&quot;../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f15780f81f3b9500edaf46f009d2d1991e3be72" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;row_splits_dtype&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;dtype&lt;/code&gt; for the returned &lt;code&gt;RaggedTensor&lt;/code&gt;'s &lt;code&gt;row_splits&lt;/code&gt; tensor. One of &lt;a href=&quot;../../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b54291cf0b25e1fc0d4b27687b326c8d10f62144" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;row_splits_dtype&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;dtype&lt;/code&gt; for the returned &lt;code&gt;RaggedTensor&lt;/code&gt;'s &lt;code&gt;row_splits&lt;/code&gt; tensor. One of &lt;a href=&quot;../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f885d91d3f6c0925da168773aea2563ddf2f83d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;row_splits_dtype&lt;/code&gt;&lt;/b&gt;: The dtype that should be used for the &lt;code&gt;row_splits&lt;/code&gt; of any new ragged tensors. Existing &lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt; elements do not have their row_splits dtype changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c8aa14112df981007e8bfb3d134f58004f4f223" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;row_splits_dtype&lt;/code&gt;&lt;/b&gt;: data type for the constructed &lt;code&gt;RaggedTensor&lt;/code&gt;'s row_splits. One of &lt;a href=&quot;../../../../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47d155b3b493ab0fff3b59c53667f5cba524926f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;row_splits_dtype&lt;/code&gt;&lt;/b&gt;: data type for the constructed &lt;code&gt;RaggedTensor&lt;/code&gt;'s row_splits. One of &lt;a href=&quot;../../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4a84dd69fe8073900b6848e601988edb189857" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;row_splits_dtype&lt;/code&gt;&lt;/b&gt;: data type for the constructed &lt;code&gt;RaggedTensorValue&lt;/code&gt;'s row_splits. One of &lt;code&gt;numpy.int32&lt;/code&gt; or &lt;code&gt;numpy.int64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2b6731646f6901624491ae4d70833c61ad9989f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;row_starts&lt;/code&gt;&lt;/b&gt;: A 1-D integer tensor with shape &lt;code&gt;[nrows]&lt;/code&gt;. Must be nonnegative and sorted in ascending order. If &lt;code&gt;nrows&amp;gt;0&lt;/code&gt;, then &lt;code&gt;row_starts[0]&lt;/code&gt; must be zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4f9e39c236e4ec8bf2dc8c1582a647522c6dc5d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rpc_layer&lt;/code&gt;&lt;/b&gt;: (Optional) Overrides the default RPC protocol TensorFlow uses to communicate across nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee62434a57b7ea4f2cab7a83c25d1d932188117" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rpc_layer&lt;/code&gt;&lt;/b&gt;: (Optional) The RPC layer TensorFlow should use to communicate between tasks in Kubernetes. Defaults to 'grpc'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19bcae7a3addb824605448c9713e27fee1353acc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rpc_layer&lt;/code&gt;&lt;/b&gt;: (Optional) The RPC protocol for the given cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6d36a4ccca294a5ea4df8fe2a8918ac527f45c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rpc_layer&lt;/code&gt;&lt;/b&gt;: (Optional) The RPC used by distributed TensorFlow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4febdb0dbdee7c2f47a840a668c9b3398b30556" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rpc_layer&lt;/code&gt;&lt;/b&gt;: (Optional) The protocol TensorFlow uses to communicate between nodes. Defaults to 'grpc'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfb2e6965b311199d677091f5985fe547f561a4a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rpc_layer&lt;/code&gt;&lt;/b&gt;: (Optional, string) The RPC protocol TensorFlow should use to communicate with TPUs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="297201d3e1c0cc30a5c3a5c226840a776601742b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rpc_layer&lt;/code&gt;&lt;/b&gt;: (String, optional) Overrides and sets the protocol over which TensorFlow nodes communicate with each other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62d1b43747341b384157f358b0a3e68dae6d7c65" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rpc_layer&lt;/code&gt;&lt;/b&gt;: (String, optional) Overrides the rpc layer TensorFlow uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b3d0d9e420a3df36ca74e553df8efce6b4e9a8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rpc_layer&lt;/code&gt;&lt;/b&gt;: The RPC layer TensorFlow should use to communicate across instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac59d6fbb94396b207ed2b3ae62fb96749570db" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rtol&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt;. Same &lt;code&gt;dtype&lt;/code&gt; as, and broadcastable to, &lt;code&gt;x&lt;/code&gt;. The relative tolerance. Default is &lt;code&gt;10 * eps&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d9f13f32951e03caa550479bf711a6c3d049340" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;rtol&lt;/code&gt;&lt;/b&gt;: relative tolerance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1957f3b02e68bf14d3e2a3a014742ed690482cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;run_context&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;SessionRunContext&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97149083be13ec742d1de72d0799d7825df12326" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;run_eagerly&lt;/code&gt;&lt;/b&gt;: Boolean. Whether to run functions eagerly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d388c056dcff7d03141d10c14b82278c76943e9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;run_every_secs&lt;/code&gt;&lt;/b&gt;: If specified, calls &lt;code&gt;should_stop_fn&lt;/code&gt; at an interval of &lt;code&gt;run_every_secs&lt;/code&gt; seconds. Defaults to 60 seconds. Either this or &lt;code&gt;run_every_steps&lt;/code&gt; must be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d379b2f502535324fcb17a6c2691c3229d802736" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;run_every_steps&lt;/code&gt;&lt;/b&gt;: If specified, calls &lt;code&gt;should_stop_fn&lt;/code&gt; every &lt;code&gt;run_every_steps&lt;/code&gt; steps. Either this or &lt;code&gt;run_every_secs&lt;/code&gt; must be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b092cfa7c9faa6b34890df930d3f9fde5a50a5d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;run_meta&lt;/code&gt;&lt;/b&gt;: (Optional) RunMetadata proto that helps flops computation using run time shape information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166a82073338c20e4041dd70051e2426b2037957" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;run_meta&lt;/code&gt;&lt;/b&gt;: RunMetadata proto that contains statistics of a session run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51dc801d81d4a6617f86dbd3e86df228119a62da" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;run_meta&lt;/code&gt;&lt;/b&gt;: optional tensorflow.RunMetadata proto. It is necessary to to support run time information profiling, such as time and memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362e19ccb0dfdd249586e7a1bf0fc592014945d7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;run_metadata&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;RunMetadata&lt;/code&gt; from the &lt;code&gt;Session.run()&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ab566ccd3d8cf57caf59e055239c2121de4d725" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;run_metadata&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;RunMetadata&lt;/code&gt; protobuf object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b2a16164230228bb1b7c9887834fb32f5ef385" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;run_metadata&lt;/code&gt;&lt;/b&gt;: A [&lt;code&gt;RunMetadata&lt;/code&gt;] protocol buffer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d7423269678cb89fecac9c77b1245d42ec2da94" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;run_metadata&lt;/code&gt;&lt;/b&gt;: Same as &lt;code&gt;tf.Session.run()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ce1a526130cb927699cec772ea3ffd12c3f0f98" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;run_values&lt;/code&gt;&lt;/b&gt;: A SessionRunValues object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9fc13a93d0e3e96c4467e20e944e8828ca24d1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;run_with_hooks_fn&lt;/code&gt;&lt;/b&gt;: A function for running fetches and hooks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daa71d9b5e29c891002672e73b26d98816745313" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;s&lt;/code&gt;&lt;/b&gt;: Singular values. Shape is &lt;code&gt;[..., P]&lt;/code&gt;. The values are sorted in reverse order of magnitude, so s[..., 0] is the largest value, s[..., 1] is the second largest, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84373ee842c8868eff05ac0b9548afc29bba1c65" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sample_rate&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1019709f5754e23518fdd7f9a211cfc5cb598827" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sample_rate&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;int32&lt;/code&gt;. Scalar containing the sample frequency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4da4fccf687c0233a9f164882c85079f2c0a82c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sample_rate&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;int&lt;/code&gt; or rank-0 &lt;code&gt;int32&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; that represents the sample rate, in Hz. Must be positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8838fa71ee2985f37b77bcc0ce2207b616fab5af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sample_rate&lt;/code&gt;&lt;/b&gt;: An integer or float &lt;code&gt;Tensor&lt;/code&gt;. Samples per second of the input signal used to create the spectrogram. Used to figure out the frequencies corresponding to each spectrogram bin, which dictates how they are mapped into the mel scale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c400fe8c3dc6b4938bceca12678f522747a6ce" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sample_shape&lt;/code&gt;&lt;/b&gt;: 0D or 1D &lt;code&gt;int32&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;. Shape of the generated samples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9800b1b8d973f28c521d4f267c48be42a972af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sample_shape&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; or python list/tuple. Desired shape of a call to &lt;code&gt;sample()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de4f305d59deb647f1e3b43cad1dfa8b1d494358" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sample_shape&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;TensorShape&lt;/code&gt; or python list/tuple. Desired shape of a call to &lt;code&gt;sample()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d2117978d40e13640bd46d4aa6ce46a1a2d051" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sample_weight&lt;/code&gt;&lt;/b&gt;: Numpy array of sample weights.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b75deccfbbc62f71e1f6129236eeda231a6d9412" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sample_weight&lt;/code&gt;&lt;/b&gt;: Optional &lt;code&gt;sample_weight&lt;/code&gt; acts as a coefficient for the loss. If a scalar is provided, then the loss is simply scaled by the given value. If &lt;code&gt;sample_weight&lt;/code&gt; is a tensor of size &lt;code&gt;[batch_size]&lt;/code&gt;, then the total loss for each sample of the batch is rescaled by the corresponding element in the &lt;code&gt;sample_weight&lt;/code&gt; vector. If the shape of &lt;code&gt;sample_weight&lt;/code&gt; is &lt;code&gt;[batch_size, d0, .. dN-1]&lt;/code&gt; (or can be broadcasted to this shape), then each loss element of &lt;code&gt;y_pred&lt;/code&gt; is scaled by the corresponding value of &lt;code&gt;sample_weight&lt;/code&gt;. (Note on&lt;code&gt;dN-1&lt;/code&gt;: all loss functions reduce by 1 dimension, usually axis=-1.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb5b4d6791688c183da5d70264b26287cedb641e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sample_weight&lt;/code&gt;&lt;/b&gt;: Optional Numpy array of weights for the test samples, used for weighting the loss function. You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape &lt;code&gt;(samples, sequence_length)&lt;/code&gt;, to apply a different weight to every timestep of every sample. In this case you should make sure to specify &lt;code&gt;sample_weight_mode=&quot;temporal&quot;&lt;/code&gt; in &lt;code&gt;compile()&lt;/code&gt;. This argument is not supported when &lt;code&gt;x&lt;/code&gt; is a dataset, instead pass sample weights as the third element of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0e85d14c67a30bf6725bcaf0ee6a1295751d70d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sample_weight&lt;/code&gt;&lt;/b&gt;: Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape &lt;code&gt;(samples, sequence_length)&lt;/code&gt;, to apply a different weight to every timestep of every sample. In this case you should make sure to specify &lt;code&gt;sample_weight_mode=&quot;temporal&quot;&lt;/code&gt; in &lt;code&gt;compile()&lt;/code&gt;. This argument is not supported when &lt;code&gt;x&lt;/code&gt; is a dataset, generator, or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instance, instead provide the sample_weights as the third element of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1b0795cf86daca7c226185e44cb64c113a6e7d5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sample_weight&lt;/code&gt;&lt;/b&gt;: Optional Numpy array of weights for the training samples, used for weighting the loss function (during training only). You can either pass a flat (1D) Numpy array with the same length as the input samples (1:1 mapping between weights and samples), or in the case of temporal data, you can pass a 2D array with shape &lt;code&gt;(samples, sequence_length)&lt;/code&gt;, to apply a different weight to every timestep of every sample. In this case you should make sure to specify &lt;code&gt;sample_weight_mode=&quot;temporal&quot;&lt;/code&gt; in &lt;code&gt;compile()&lt;/code&gt;. This argument is not supported when &lt;code&gt;x&lt;/code&gt; is a dataset, generator, or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instance, instead provide the sample_weights as the third element of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4328333ee904af66708524c041d5298cb2ccaea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sample_weight&lt;/code&gt;&lt;/b&gt;: Optional array of the same length as x, containing weights to apply to the model's loss for each sample. In the case of temporal data, you can pass a 2D array with shape (samples, sequence_length), to apply a different weight to every timestep of every sample. In this case you should make sure to specify sample_weight_mode=&quot;temporal&quot; in compile(). This argument is not supported when &lt;code&gt;x&lt;/code&gt; is a dataset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7395f2b1d505ee9ba3829d3a21e14c77fd0af472" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sample_weight&lt;/code&gt;&lt;/b&gt;: Optional weighting for each example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="208562d8406de59a232082f132482272e2e91755" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sample_weight&lt;/code&gt;&lt;/b&gt;: Optional weighting of each example. Defaults to 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37378c225b84b836e5a23179eec1caf09a0811d9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sample_weight&lt;/code&gt;&lt;/b&gt;: Optional weighting of each example. Defaults to 1. Can be a &lt;code&gt;Tensor&lt;/code&gt; whose rank is either 0, or the same rank as &lt;code&gt;y_true&lt;/code&gt;, and must be broadcastable to &lt;code&gt;y_true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c741c6b754dc872aff6a5c2577bcff58ca22bf75" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sample_weight_mode&lt;/code&gt;&lt;/b&gt;: If you need to do timestep-wise sample weighting (2D weights), set this to &lt;code&gt;&quot;temporal&quot;&lt;/code&gt;. &lt;code&gt;None&lt;/code&gt; defaults to sample-wise weights (1D). If the model has multiple outputs, you can use a different &lt;code&gt;sample_weight_mode&lt;/code&gt; on each output by passing a dictionary or a list of modes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03561f959f476358be8811a57d19bedacb019c62" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sampled_candidates&lt;/code&gt;&lt;/b&gt;: A tensor of type &lt;code&gt;int64&lt;/code&gt; and shape &lt;code&gt;[num_sampled]&lt;/code&gt;. The sampled classes, either with possible duplicates (&lt;code&gt;unique=False&lt;/code&gt;) or all unique (&lt;code&gt;unique=True&lt;/code&gt;). In either case, &lt;code&gt;sampled_candidates&lt;/code&gt; is independent of the true classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a25b465357ab4426ca888cfdc16fe61a6a466a7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sampled_candidates&lt;/code&gt;&lt;/b&gt;: A tensor of type &lt;code&gt;int64&lt;/code&gt; and shape &lt;code&gt;[num_sampled]&lt;/code&gt;. The sampled classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644e87047ee310f7ced8de4dafbc9bba855af111" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sampled_candidates&lt;/code&gt;&lt;/b&gt;: A tensor of type &lt;code&gt;int64&lt;/code&gt; and shape &lt;code&gt;[num_sampled]&lt;/code&gt;. The sampled_candidates output of CandidateSampler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80ebdcdb726c5246c4958199ef7cb0f3fc5b8031" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sampled_candidates&lt;/code&gt;&lt;/b&gt;: A tensor of type &lt;code&gt;int64&lt;/code&gt; and shape &lt;code&gt;[num_sampled]&lt;/code&gt;. This operation deterministically returns the entire range &lt;code&gt;[0, num_sampled]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0941d9bb1d14e1547609936defc3ae53f9772f5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sampled_expected_count&lt;/code&gt;&lt;/b&gt;: A tensor of type &lt;code&gt;float&lt;/code&gt;. Same shape as &lt;code&gt;sampled_candidates&lt;/code&gt;. The expected counts under the sampling distribution of each of &lt;code&gt;sampled_candidates&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855eabe5e89ed36e91abc9cf6c4d17e0df78588c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sampled_expected_count&lt;/code&gt;&lt;/b&gt;: A tensor of type &lt;code&gt;float&lt;/code&gt;. Same shape as &lt;code&gt;sampled_candidates&lt;/code&gt;. The expected counts under the sampling distribution of each of &lt;code&gt;sampled_candidates&lt;/code&gt;. All returned values are 1.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a89d4801252bdb147e793184df634854cd1be010" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sampled_values&lt;/code&gt;&lt;/b&gt;: a tuple of (&lt;code&gt;sampled_candidates&lt;/code&gt;, &lt;code&gt;true_expected_count&lt;/code&gt;, &lt;code&gt;sampled_expected_count&lt;/code&gt;) returned by a &lt;code&gt;*_candidate_sampler&lt;/code&gt; function. (if None, we default to &lt;code&gt;log_uniform_candidate_sampler&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8041fc8a1e6e0e0b26a6d374e5125aa6603a96f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;samples&lt;/code&gt;&lt;/b&gt;: A Tensor of the specified shape filled with random binomial values. For each i, each samples[i, ...] is an independent draw from the binomial distribution on counts[i] trials with probability of success probs[i].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e77df572b0759d6ee03dd56e00765ded3e22a87f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;samples&lt;/code&gt;&lt;/b&gt;: a &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;tf.concat([shape, tf.shape(alpha + beta)], axis=0)&lt;/code&gt; with values of type &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d195c0ef712620996793123356c60fa98951926" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;samples&lt;/code&gt;&lt;/b&gt;: a &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;tf.concat([shape, tf.shape(lam)], axis=0)&lt;/code&gt; with values of type &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf3d4fbc0a7354b06799c207173aef46f784a29" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;samples&lt;/code&gt;&lt;/b&gt;: a &lt;code&gt;Tensor&lt;/code&gt; with prepended dimensions &lt;code&gt;sample_shape&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8197713368abc31bde34dd62fe26039c44c64f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;samplewise_center&lt;/code&gt;&lt;/b&gt;: Boolean. Set each sample mean to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a7d03a6d66d1966325d162a92e9d7b5efaeae5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;samplewise_std_normalization&lt;/code&gt;&lt;/b&gt;: Boolean. Divide each input by its std.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f901eb3a1520e2b1a317c2e8cec3bc9b8ef63a8a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sanitize&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;bool&lt;/code&gt;. Defaults to &lt;code&gt;False&lt;/code&gt;. Whether to sanitize the result or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9db13baacbe546a772c5ea15123780e77f44330e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;satisfying&lt;/code&gt;&lt;/b&gt;: paddings[i, 0] = base_paddings[i, 0]. 0 &amp;lt;= paddings[i, 1] - base_paddings[i, 1] &amp;lt; block_shape&lt;a href=&quot;input_shape%5bi%5d%20+%20paddings%5bi,%200%5d%20+%20paddings%5bi,%201%5d&quot;&gt;i&lt;/a&gt; % block_shape[i] == 0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ac10adb167aa40058cf45a9355d670f6055a8f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;saturate&lt;/code&gt;&lt;/b&gt;: If &lt;code&gt;True&lt;/code&gt;, clip the input before casting (if necessary).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6693cd55f3205c9077c86bf1d5b396052b438fc9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;saturation_factor&lt;/code&gt;&lt;/b&gt;: float. Factor to multiply the saturation by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43f306597877fdc22f484590792ea1aed8f8280d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_best_only&lt;/code&gt;&lt;/b&gt;: if &lt;code&gt;save_best_only=True&lt;/code&gt;, the latest best model according to the quantity monitored will not be overwritten. If &lt;code&gt;filepath&lt;/code&gt; doesn't contain formatting options like &lt;code&gt;{epoch}&lt;/code&gt; then &lt;code&gt;filepath&lt;/code&gt; will be overwritten by each new better model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b84b8714cb1a7dae25712975d45408a9ceb8ec3a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_checkpoint_secs&lt;/code&gt;&lt;/b&gt;: The frequency, in seconds, that a checkpoint is saved using a default checkpoint saver. If both &lt;code&gt;save_checkpoint_steps&lt;/code&gt; and &lt;code&gt;save_checkpoint_secs&lt;/code&gt; are set to &lt;code&gt;None&lt;/code&gt;, then the default checkpoint saver isn't used. If both are provided, then only &lt;code&gt;save_checkpoint_secs&lt;/code&gt; is used. Default 600.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb1f9d74df51bc122a88afd41abd1c8b9205d1b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_checkpoint_steps&lt;/code&gt;&lt;/b&gt;: The frequency, in number of global steps, that a checkpoint is saved using a default checkpoint saver. If both &lt;code&gt;save_checkpoint_steps&lt;/code&gt; and &lt;code&gt;save_checkpoint_secs&lt;/code&gt; are set to &lt;code&gt;None&lt;/code&gt;, then the default checkpoint saver isn't used. If both are provided, then only &lt;code&gt;save_checkpoint_secs&lt;/code&gt; is used. Default not enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baba876b037743ba451374647d53b442f5ef11a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_checkpoints_secs&lt;/code&gt;&lt;/b&gt;: Save checkpoints every this many seconds. Can not be specified with &lt;code&gt;save_checkpoints_steps&lt;/code&gt;. Defaults to 600 seconds if both &lt;code&gt;save_checkpoints_steps&lt;/code&gt; and &lt;code&gt;save_checkpoints_secs&lt;/code&gt; are not set in constructor. If both &lt;code&gt;save_checkpoints_steps&lt;/code&gt; and &lt;code&gt;save_checkpoints_secs&lt;/code&gt; are &lt;code&gt;None&lt;/code&gt;, then checkpoints are disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0f13014b486c097a0348e498b91c1c7af26a706" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_checkpoints_steps&lt;/code&gt;&lt;/b&gt;: Save checkpoints every this many steps. Can not be specified with &lt;code&gt;save_checkpoints_secs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ec6dc71473f9118a0c13b9ed78ad0a2f23104f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_counter&lt;/code&gt;&lt;/b&gt;: Incremented when &lt;code&gt;save()&lt;/code&gt; is called. Used to number checkpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db9df0c72b1fdda305d2c22306d5f96f4fa92046" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_debug_info&lt;/code&gt;&lt;/b&gt;: Boolean indicating whether debug information is saved. If True, then a debug/saved_model_debug_info.pb file will be written with the contents of a GraphDebugInfo binary protocol buffer containing stack trace information for all ops and functions that are saved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f745d47e52df18125b4e9cc3e5d75ac5578b5399" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_debug_info&lt;/code&gt;&lt;/b&gt;: If &lt;code&gt;True&lt;/code&gt;, save the GraphDebugInfo to a separate file, which in the same directory of filename and with &lt;code&gt;_debug&lt;/code&gt; added before the file extend.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a18279f5a250148b0e43b09ddf9d82971d0db7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_debug_info&lt;/code&gt;&lt;/b&gt;: If &lt;code&gt;True&lt;/code&gt;, save the GraphDebugInfo to a separate file, which in the same directory of filename and with &lt;code&gt;_debug&lt;/code&gt; added before the file extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef87e51f89db95c804b8cf851a5d58559a8fce60" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_debug_info&lt;/code&gt;&lt;/b&gt;: If &lt;code&gt;True&lt;/code&gt;, save the GraphDebugInfo to a separate file, which in the same directory of save_path and with &lt;code&gt;_debug&lt;/code&gt; added before the file extension. This is only enabled when &lt;code&gt;write_meta_graph&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd28dabf9e5c4a144b818386136e7c0b0ab5578e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_dir&lt;/code&gt;&lt;/b&gt;: Directory where the model was saved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8caed4cf373a3a5938fef795647986b6967ba3a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_format&lt;/code&gt;&lt;/b&gt;: Either 'tf' or 'h5', indicating whether to save the model to Tensorflow SavedModel or HDF5. Defaults to 'tf' in TF 2.X, and 'h5' in TF 1.X.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710d725b211fd1e2ef64cc4b218a7f5e29653163" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_format&lt;/code&gt;&lt;/b&gt;: Either 'tf' or 'h5'. A &lt;code&gt;filepath&lt;/code&gt; ending in '.h5' or '.keras' will default to HDF5 if &lt;code&gt;save_format&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;. Otherwise &lt;code&gt;None&lt;/code&gt; defaults to 'tf'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a841f8e4f51080fc356134071e7c0bfcc7e318e3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_format&lt;/code&gt;&lt;/b&gt;: Format to use for saving sample images (if &lt;code&gt;save_to_dir&lt;/code&gt; is set).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985cff6687d6f17978381e73b2613964ef43bc49" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_freq&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;'epoch'&lt;/code&gt; or integer. When using &lt;code&gt;'epoch'&lt;/code&gt;, the callback saves the model after each epoch. When using integer, the callback saves the model at end of a batch at which this many samples have been seen since last saving. Note that if the saving isn't aligned to epochs, the monitored metric may potentially be less reliable (it could reflect as little as 1 batch, since the metrics get reset every epoch). Defaults to &lt;code&gt;'epoch'&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b7a5c57352ed6a61b453d88096af9ca76a89f4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_graph_def&lt;/code&gt;&lt;/b&gt;: Whether to save the GraphDef and MetaGraphDef to &lt;code&gt;checkpoint_dir&lt;/code&gt;. The GraphDef is saved after the session is created as &lt;code&gt;graph.pbtxt&lt;/code&gt;. MetaGraphDefs are saved out for every checkpoint as &lt;code&gt;model.ckpt-*.meta&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a1ee20cb990c0ad8a665663cce81be2801d0af7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_model_secs&lt;/code&gt;&lt;/b&gt;: Number of seconds between the creation of model checkpoints. Defaults to 600 seconds. Pass 0 to disable checkpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b67fc44636cc9070fda7c4aff664857ca5d0e9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_path&lt;/code&gt;&lt;/b&gt;: Path where parameters were previously saved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ce68bf2da0e9de6c97ea13195279cab8517abd7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_path&lt;/code&gt;&lt;/b&gt;: String. Prefix of filenames created for the checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbdba3dd11a70e3dcacf478c8b7af0d752fdec0b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_path&lt;/code&gt;&lt;/b&gt;: The path to the checkpoint, as returned by &lt;code&gt;save&lt;/code&gt; or &lt;a href=&quot;../../../train/latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt;&lt;/a&gt;. If None (as when there is no latest checkpoint for &lt;a href=&quot;../../../train/latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt;&lt;/a&gt; to return), returns an object which may run initializers for objects in the dependency graph. If the checkpoint was written by the name-based &lt;a href=&quot;saver&quot;&gt;&lt;code&gt;tf.compat.v1.train.Saver&lt;/code&gt;&lt;/a&gt;, names are used to match variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46299aa4ba995a10ba441e0d0e6dcd8cc1df852e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_path&lt;/code&gt;&lt;/b&gt;: The path to the checkpoint, as returned by &lt;code&gt;save&lt;/code&gt; or &lt;a href=&quot;latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt;&lt;/a&gt;. If None (as when there is no latest checkpoint for &lt;a href=&quot;latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt;&lt;/a&gt; to return), returns an object which may run initializers for objects in the dependency graph. If the checkpoint was written by the name-based &lt;a href=&quot;../compat/v1/train/saver&quot;&gt;&lt;code&gt;tf.compat.v1.train.Saver&lt;/code&gt;&lt;/a&gt;, names are used to match variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd161dda439c016ce041abcb3e3aa85bab3907f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_prefix&lt;/code&gt;&lt;/b&gt;: String prefix to use for saving sample images (if &lt;code&gt;save_to_dir&lt;/code&gt; is set).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2078c4f8543d89e04e15f977df43360745f3aece" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_relative_paths&lt;/code&gt;&lt;/b&gt;: If &lt;code&gt;True&lt;/code&gt;, will write relative paths to the checkpoint state file. This is needed if the user wants to copy the checkpoint directory and reload from the copied directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51073c3b9f8dd0d2d09652007d18fe17a8cc57d7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_secs&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;float&lt;/code&gt;, save profile traces every N seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15832bf4b615d0904c909ab52eec64c40dd2dbcb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_secs&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;int&lt;/code&gt;, save every N secs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2712977d22b49507b5b8944f71a6a68b3ce96a49" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_secs&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;int&lt;/code&gt;, save summaries every N seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3602b77728d4498ccc296d7891e25541e8eb805c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_slice_info_def&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;SaveSliceInfoDef&lt;/code&gt; protocol buffer. If not &lt;code&gt;None&lt;/code&gt;, recreates the SaveSliceInfo object its contents. &lt;code&gt;save_slice_info_def&lt;/code&gt; and other arguments are mutually exclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da455321fa5315e4483c0879d4690f73f135a9fe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_steps&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;int&lt;/code&gt;, save every N steps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ece3217f50785d3ca25519cb6dad74c58afdd94" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_steps&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;int&lt;/code&gt;, save profile traces every N steps. Exactly one of &lt;code&gt;save_secs&lt;/code&gt; and &lt;code&gt;save_steps&lt;/code&gt; should be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af893b5e376d34bf9b93523999c0bd550d8cbdf6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_steps&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;int&lt;/code&gt;, save summaries every N steps. Exactly one of &lt;code&gt;save_secs&lt;/code&gt; and &lt;code&gt;save_steps&lt;/code&gt; should be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e11bc4a64266d9669a150f8589a6f66cd5822117" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_summaries_secs&lt;/code&gt;&lt;/b&gt;: Number of seconds between the computation of summaries for the event log. Defaults to 120 seconds. Pass 0 to disable summaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de389f26123be12aee9ed9623dadfe8d1825b34" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_summaries_secs&lt;/code&gt;&lt;/b&gt;: The frequency, in secs, that the summaries are written to disk using a default summary saver. If both &lt;code&gt;save_summaries_steps&lt;/code&gt; and &lt;code&gt;save_summaries_secs&lt;/code&gt; are set to &lt;code&gt;None&lt;/code&gt;, then the default summary saver isn't used. Default not enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e784804fd89f1a006ef5c800452950347e430510" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_summaries_steps&lt;/code&gt;&lt;/b&gt;: The frequency, in number of global steps, that the summaries are written to disk using a default summary saver. If both &lt;code&gt;save_summaries_steps&lt;/code&gt; and &lt;code&gt;save_summaries_secs&lt;/code&gt; are set to &lt;code&gt;None&lt;/code&gt;, then the default summary saver isn't used. Default 100.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bed75ddca9cd3e5c08387d3c9523fb5ef5384425" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_summary_steps&lt;/code&gt;&lt;/b&gt;: Save summaries every this many steps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61511824057240c53f01c2afa260d8f0cee54e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_to_dir&lt;/code&gt;&lt;/b&gt;: Optional directory where to save the pictures being yielded, in a viewable format. This is useful for visualizing the random transformations being applied, for debugging purposes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e8dc86e8c518b5b336c970ca9a0af63c26f628" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;save_weights_only&lt;/code&gt;&lt;/b&gt;: if True, then only the model's weights will be saved (&lt;code&gt;model.save_weights(filepath)&lt;/code&gt;), else the full model is saved (&lt;code&gt;model.save(filepath)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbf02b6422b6a61b384b866b7bf7d57011a80ffc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;saved_model_dir&lt;/code&gt;&lt;/b&gt;: SavedModel directory to convert.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6992d7f261f49406f617ccc3a9301301dcd099bf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;saved_model_path&lt;/code&gt;&lt;/b&gt;: a string specifying the path to an existing SavedModel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542fe334215725a79e02ce60d8bff662f430bbe2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;saved_model_path&lt;/code&gt;&lt;/b&gt;: a string specifying the path to the SavedModel directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d76db1146cf9b4ec1f695f95e4a9100a644b37a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;saver&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Saver&lt;/code&gt; object, used for saving.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5846af6aa49e29f1aea9c61984851f795316c667" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;saver&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Saver&lt;/code&gt; object used to restore a model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa334e0077a8f79054c8f67e184059161d9da85e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;saver&lt;/code&gt;&lt;/b&gt;: A Saver object. Used by chief supervisors if a &lt;code&gt;logdir&lt;/code&gt; was specified. Defaults to the saved returned by Saver(). If &lt;code&gt;None&lt;/code&gt;, the model is not saved automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99742363432cd48ae7baad2bbd8850e96b84398c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;saver&lt;/code&gt;&lt;/b&gt;: An instance of tf.compat.v1.train.Saver that will be used to export the metagraph and save variables. If None, a sharded Saver that restores all variables will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f70aa01ce18183d05e31f6061696ef2e9ffbdfe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;saver&lt;/code&gt;&lt;/b&gt;: An instance of tf.compat.v1.train.Saver that will be used to export the metagraph. If None, a sharded Saver that restores all variables will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105b40ad34f4fe079d8499df8b26c3e9c0495788" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;saver&lt;/code&gt;&lt;/b&gt;: Optional &lt;a href=&quot;saver&quot;&gt;&lt;code&gt;tf.compat.v1.train.Saver&lt;/code&gt;&lt;/a&gt; object to use to save and restore variables. May also be a &lt;a href=&quot;../../../train/checkpoint&quot;&gt;&lt;code&gt;tf.train.Checkpoint&lt;/code&gt;&lt;/a&gt; object, in which case object-based checkpoints are saved. This will also load some object-based checkpoints saved from elsewhere, but that loading may be fragile since it uses fixed keys rather than performing a full graph-based match. For example if a variable has two paths from the &lt;code&gt;Checkpoint&lt;/code&gt; object because two &lt;code&gt;Model&lt;/code&gt; objects share the &lt;code&gt;Layer&lt;/code&gt; object that owns it, removing one &lt;code&gt;Model&lt;/code&gt; may change the keys and break checkpoint loading through this API, whereas a graph-based match would match the variable through the other &lt;code&gt;Model&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8890d1212ca5ef2d4ef0bf44dfc562c66dd96b1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;saver_def&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;SaverDef&lt;/code&gt; protocol buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c106e314c05bde1b5125a74bbaa0afe45a3a4d1c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;saver_def&lt;/code&gt;&lt;/b&gt;: Optional &lt;code&gt;SaverDef&lt;/code&gt; proto to use instead of running the builder. This is only useful for specialty code that wants to recreate a &lt;code&gt;Saver&lt;/code&gt; object for a previously built &lt;code&gt;Graph&lt;/code&gt; that had a &lt;code&gt;Saver&lt;/code&gt;. The &lt;code&gt;saver_def&lt;/code&gt; proto should be the one returned by the &lt;code&gt;as_saver_def()&lt;/code&gt; call of the &lt;code&gt;Saver&lt;/code&gt; that was created for that &lt;code&gt;Graph&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577979937457f1e0c1a1e6663022f788ce9fd8d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;saver_def&lt;/code&gt;&lt;/b&gt;: a &lt;code&gt;SaverDef&lt;/code&gt; protocol buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e1abcf53cbca8dac6623256702c88f02991f386" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;saving_listeners&lt;/code&gt;&lt;/b&gt;: list of &lt;code&gt;CheckpointSaverListener&lt;/code&gt; objects. Used for callbacks that run immediately before or after checkpoint savings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a66eb7faceef0290812abb1f6874965ee0a2ea48" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scaffold&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Scaffold&lt;/code&gt; to get summary_op if it's not provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ad8ca39f92c9b8020abaf5a3a9989b980bd14fb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scaffold&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Scaffold&lt;/code&gt;, use to get saver object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec032e628377b1e720d764c4a34c44082e2c21f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scaffold&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Scaffold&lt;/code&gt; used for gathering or building supportive ops. If not specified a default one is created. It's used to finalize the graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa4f0e428d71d61b5a764d0690f6438d67e4126" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scaffold&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Scaffold&lt;/code&gt; used for gathering or building supportive ops. If not specified, a default one is created. It's used to finalize the graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f70ea5f8c67a2c0330cd16f3503b858bfae2071d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scaffold&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;tf.train.Scaffold&lt;/code&gt; object that can be used to set initialization, saver, and more to be used in training.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e63b5b921645f10041be6830bf309820b4cdc0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scalar&lt;/code&gt;&lt;/b&gt;: A 0-D scalar &lt;code&gt;Tensor&lt;/code&gt;. Must have known shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a33a3a4fa523f4720c8abd19ca7c53b52e4fe8cb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scale&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of 1 dimension for scaling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a5d57c1fcba8a9d25f6c9a44d75221a6064994e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scale&lt;/code&gt;&lt;/b&gt;: A scale &lt;code&gt;Tensor&lt;/code&gt;, often denoted \(\gamma\) in equations, or &lt;code&gt;None&lt;/code&gt;. If present, the scale is applied to the normalized tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432be9eaebc4f140dbe552d55b9d4399b5e8cc4e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scale&lt;/code&gt;&lt;/b&gt;: Float, standard deviation of the normal distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb634594f6406bf1b8c63a9bd980fa2e1eea24f9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scale&lt;/code&gt;&lt;/b&gt;: Floating point tensor; the stddevs of the distribution(s). Must contain only positive values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3b5aed086c3fb537736c5866d1079c59a6b6de5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scale&lt;/code&gt;&lt;/b&gt;: Floating-point &lt;code&gt;Tensor&lt;/code&gt;. The scaling factor(s) for the distribution(s). Note that &lt;code&gt;scale&lt;/code&gt; is not technically the standard deviation of this distribution but has semantics more similar to standard deviation than variance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b6cfd3aef1963c3ed1e276955e8d974defdd25" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scale&lt;/code&gt;&lt;/b&gt;: If True, multiply by &lt;code&gt;gamma&lt;/code&gt;. If False, &lt;code&gt;gamma&lt;/code&gt; is not used. When the next layer is linear (also e.g. &lt;a href=&quot;../../../../nn/relu&quot;&gt;&lt;code&gt;nn.relu&lt;/code&gt;&lt;/a&gt;), this can be disabled since the scaling will be done by the next layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b852ba63bdb8c0bcda9230b75ef9f34c5fa6803f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scale&lt;/code&gt;&lt;/b&gt;: If True, multiply by &lt;code&gt;gamma&lt;/code&gt;. If False, &lt;code&gt;gamma&lt;/code&gt; is not used. When the next layer is linear (also e.g. &lt;a href=&quot;../../../nn/relu&quot;&gt;&lt;code&gt;nn.relu&lt;/code&gt;&lt;/a&gt;), this can be disabled since the scaling can be done by the next layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfcdb475730afdec9a5cc02777d2c816598777b9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scale&lt;/code&gt;&lt;/b&gt;: If True, multiply by &lt;code&gt;gamma&lt;/code&gt;. If False, &lt;code&gt;gamma&lt;/code&gt; is not used. When the next layer is linear (also e.g. &lt;a href=&quot;../../nn/relu&quot;&gt;&lt;code&gt;nn.relu&lt;/code&gt;&lt;/a&gt;), this can be disabled since the scaling will be done by the next layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9b2e94cc542349ea29124923cb6ae9df6433f0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scale&lt;/code&gt;&lt;/b&gt;: Positive floating point tensor which characterizes the spread of the distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bd519a14f723de76abc3f5d4d2f2f72bc3c58bc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scale&lt;/code&gt;&lt;/b&gt;: Scaling factor (positive float).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d717b5cf0fb0b849f3ebfbb53bf8b599e11df48" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scale&lt;/code&gt;&lt;/b&gt;: Whether to rescale image values to be within &lt;code&gt;[0, 255]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3215520f111654e940edb97f2400f57046fe854" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scale_after_normalization&lt;/code&gt;&lt;/b&gt;: A bool indicating whether the resulted tensor needs to be multiplied with gamma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c90426126ae08d2838fd45eea5d3601f5d07600" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scan_func&lt;/code&gt;&lt;/b&gt;: A function that maps &lt;code&gt;(old_state, input_element)&lt;/code&gt; to &lt;code&gt;(new_state, output_element). It must take two arguments and return a pair of nested structures of tensors. The&lt;/code&gt;new_state&lt;code&gt;must match the structure of&lt;/code&gt;initial_state`.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6eeb85d67a816c5b7e967456b5344b68d58e8ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;schedule&lt;/code&gt;&lt;/b&gt;: a function that takes an epoch index as input (integer, indexed from 0) and returns a new learning rate as output (float).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c176117b50ad815552eca061899602d63b365206" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scientific&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;bool&lt;/code&gt;. Defaults to &lt;code&gt;False&lt;/code&gt;. Use scientific notation for floating point numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="801e7ff4aaf3b2c90dbe233d9c428ad4063c3956" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/b&gt;: (Optional.) A string. If supplied, the resulting list is filtered to include only items whose &lt;code&gt;name&lt;/code&gt; attribute matches &lt;code&gt;scope&lt;/code&gt; using &lt;code&gt;re.match&lt;/code&gt;. Items without a &lt;code&gt;name&lt;/code&gt; attribute are never returned if a scope is supplied. The choice of &lt;code&gt;re.match&lt;/code&gt; means that a &lt;code&gt;scope&lt;/code&gt; without special tokens filters by prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56b29e68f9e45181d2e1ea65de28d8b553035fc4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/b&gt;: (Optional.) If supplied, the resulting list is filtered to include only items whose &lt;code&gt;name&lt;/code&gt; attribute matches using &lt;code&gt;re.match&lt;/code&gt;. Items without a &lt;code&gt;name&lt;/code&gt; attribute are never returned if a scope is supplied and the choice or &lt;code&gt;re.match&lt;/code&gt; means that a &lt;code&gt;scope&lt;/code&gt; without special tokens filters by prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e61fbe57e3ce4e6bc761610f4d4f251851ed8c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/b&gt;: An optional scope name for filtering the losses to return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204dba21f0874e16ace96813544b886881473f8e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/b&gt;: An optional scope name for filtering the losses to return. Note that this filters the losses added with &lt;code&gt;tf.add_loss()&lt;/code&gt; as well as the regularization losses to that scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09c55478e7aafd21551d5f3d12b4534c21f5c030" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/b&gt;: Optional scope used to filter the summary ops, using &lt;code&gt;re.match&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="087ca5284e796fe38d1272d9989f182e88350ef0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/b&gt;: The scope for the operations performed in computing the loss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3312032eb9d338ecccad15d4e5f57efcd2f498f1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/b&gt;: VariableScope for the created subgraph; defaults to &quot;bidirectional_rnn&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166c0cce7ee33d383ab1ef24904b3b3f5b642d82" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/b&gt;: VariableScope for the created subgraph; defaults to &quot;rnn&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff3e2515b1c978d05313d61800c6332e7141cb27" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/b&gt;: the scope for the operations performed in computing the loss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ffa8162b3b59f067bdbc7c59488e635ae13ea4b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;score&lt;/code&gt;&lt;/b&gt;: float Mean accuracy of predictions on &lt;code&gt;x&lt;/code&gt; wrt. &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb53881d75b2d9773636a400f74479123859e211" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;score_threshold&lt;/code&gt;&lt;/b&gt;: A float representing the threshold for deciding when to remove boxes based on score.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30679632c2c51abcf0a3b500f4d22846868d5b9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scores&lt;/code&gt;&lt;/b&gt;: A 1-D float &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[num_boxes]&lt;/code&gt; representing a single score corresponding to each box (each row of boxes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55bd9bb20d8037f1ab4a32437e16c068540a81d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scores&lt;/code&gt;&lt;/b&gt;: A 3-D float &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[batch_size, num_boxes, num_classes]&lt;/code&gt; representing a single score corresponding to each box (each row of boxes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6132c327c4047a21a3706516773da726058e800f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scores&lt;/code&gt;&lt;/b&gt;: A float &lt;code&gt;Tensor&lt;/code&gt; giving scores (sometimes but not always interpretable as probabilities) for each class. May be &lt;code&gt;None&lt;/code&gt;, but only if &lt;code&gt;classes&lt;/code&gt; is set. Interpretation varies-- see class doc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b91c61d22be9db219c47601c117b4f70591f237" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;scores&lt;/code&gt;&lt;/b&gt;: a float &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b1aa5f87cbee368396c509eb101544883f2edf5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;second&lt;/code&gt;&lt;/b&gt;: A string containing JSON to decode and compare to first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="338a8578cc9398d766811993fa69dbb8819f73e3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed2&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;int&lt;/code&gt;. Defaults to &lt;code&gt;0&lt;/code&gt;. A second seed to avoid seed collision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a269da81dee62f2c86e7989ab94d5fd2f9775ba2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed2&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;int&lt;/code&gt;. Deprecated; use &lt;code&gt;fractional_avg_pool_v2&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ad1e5484a6eb5e53fbfa1e2ac622620b0281b0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed2&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;int&lt;/code&gt;. Deprecated; use &lt;code&gt;fractional_max_pool_v2&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f5d987b3f24abadd673113bc458c1f26578f6e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: (Optional.) A &lt;a href=&quot;../../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the random seed that will be used to create the distribution. See &lt;a href=&quot;../../set_random_seed&quot;&gt;&lt;code&gt;tf.compat.v1.set_random_seed&lt;/code&gt;&lt;/a&gt; for behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea08307c70a6b907d4db037185f5165ec945550" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: (Optional.) A &lt;a href=&quot;../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the random seed that will be used to create the distribution. See &lt;a href=&quot;../set_random_seed&quot;&gt;&lt;code&gt;tf.compat.v1.set_random_seed&lt;/code&gt;&lt;/a&gt; for behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd32d647f84d1e3d7c602c1ce1d83b030148d3ee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: (Optional.) A &lt;a href=&quot;../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the random seed that will be used to create the distribution. See &lt;a href=&quot;../../compat/v1/set_random_seed&quot;&gt;&lt;code&gt;tf.compat.v1.set_random_seed&lt;/code&gt;&lt;/a&gt; for behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="288cc03d06e873cbdbe978c96cecfa31c2e022b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: (Optional.) A &lt;a href=&quot;../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the random seed that will be used to create the distribution. See &lt;a href=&quot;../compat/v1/set_random_seed&quot;&gt;&lt;code&gt;tf.compat.v1.set_random_seed&lt;/code&gt;&lt;/a&gt; for behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ff6b3e6b252c53be79ecb9f93f7121c5a14fa43" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: (Optional.) An integer. The seed to use if &lt;code&gt;shuffle&lt;/code&gt; is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef1062e562e23c7b6e939a5db20876f16db9950e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: (Optional.) Python integer seed for the resampler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27e46a91aa3ee1923d02f34b121107d69a9bff0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: (optional) integer, the randomness seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb95102c4b09efd45c8a2de6aba8313f093c0716" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: A Python integer to use as random seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97080c26eac554f04490958eee7e7ef94251e02c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: A Python integer. Used in combination with &lt;a href=&quot;set_seed&quot;&gt;&lt;code&gt;tf.random.set_seed&lt;/code&gt;&lt;/a&gt; to create a reproducible sequence of tensors across multiple calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7430720c9073ac7ef55bcca973858142ce87a425" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: A Python integer. Used to create a random seed for the distribution. See &lt;a href=&quot;../compat/v1/set_random_seed&quot;&gt;&lt;code&gt;tf.compat.v1.set_random_seed&lt;/code&gt;&lt;/a&gt; for behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0abb9f53e49caca8fcf15f0ac451c1fb27d28b85" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: A Python integer. Used to create a random seed for the distribution. See &lt;a href=&quot;set_random_seed&quot;&gt;&lt;code&gt;tf.compat.v1.set_random_seed&lt;/code&gt;&lt;/a&gt; for behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe7989d0590b576c83d30c17fbf0822c2f16237" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: A Python integer. Used to create a random seed for the distributions. See &lt;a href=&quot;../compat/v1/set_random_seed&quot;&gt;&lt;code&gt;tf.compat.v1.set_random_seed&lt;/code&gt;&lt;/a&gt; for behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46bc4741b2411be5c7b51d09a29b0160191e807c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: A Python integer. Used to create a random seed for the distributions. See &lt;a href=&quot;set_random_seed&quot;&gt;&lt;code&gt;tf.compat.v1.set_random_seed&lt;/code&gt;&lt;/a&gt; for behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="053080e6996004c30f182eea8b7353332451bcb5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: A Python integer. Used to create a random seed. See &lt;a href=&quot;../compat/v1/set_random_seed&quot;&gt;&lt;code&gt;tf.compat.v1.set_random_seed&lt;/code&gt;&lt;/a&gt; for behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b3a12bb8471e36d562561aea0bb9650a92debe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: A Python integer. Used to create random seeds. See &lt;a href=&quot;../../../random/set_seed&quot;&gt;&lt;code&gt;tf.random.set_seed&lt;/code&gt;&lt;/a&gt; for behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1e02d57cda9335dc172403b890073779781b844" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: A Python integer. Used to create random seeds. See &lt;a href=&quot;../../compat/v1/set_random_seed&quot;&gt;&lt;code&gt;tf.compat.v1.set_random_seed&lt;/code&gt;&lt;/a&gt; for behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="458001a2f754cfb280af81670e908b25fef607f4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: A Python integer. Used to create random seeds. See &lt;a href=&quot;../../set_random_seed&quot;&gt;&lt;code&gt;tf.compat.v1.set_random_seed&lt;/code&gt;&lt;/a&gt; for behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ea6e0551096bf498e3350f7f30cdda310a7e99c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: A Python integer. Used to create random seeds. See &lt;a href=&quot;../random/set_seed&quot;&gt;&lt;code&gt;tf.random.set_seed&lt;/code&gt;&lt;/a&gt; for behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb2ada9c2128e7a24c8ddbeadcd135531f0500c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: A Python integer. Used to create random seeds. See &lt;a href=&quot;../set_random_seed&quot;&gt;&lt;code&gt;tf.compat.v1.set_random_seed&lt;/code&gt;&lt;/a&gt;. for behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8c0132604f70dc3f960477be3779d51db0dd660" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: A Python integer. Used to create random seeds. See &lt;a href=&quot;compat/v1/set_random_seed&quot;&gt;&lt;code&gt;tf.compat.v1.set_random_seed&lt;/code&gt;&lt;/a&gt; for behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91a490a49b088b62e89a7d3e2ee03cae3c6c9fa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: A Python integer. Used to create random seeds. See &lt;a href=&quot;set_random_seed&quot;&gt;&lt;code&gt;tf.compat.v1.set_random_seed&lt;/code&gt;&lt;/a&gt; for behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93e90b2116a2a0e96eed9a74d0d6eb127da6e47" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: A Python integer. Used to seed the random generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4253a2ec85920de5b2166c7b479a5f1efb82e4d8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: A shape [2] integer Tensor of seeds to the random number generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3896440ebed2854c31e11eaacf875e05e8cb8115" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;int&lt;/code&gt;. An operation-specific seed. Default is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685719daf5c0c79ab94fe0360b462ee3d8adbf76" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: An integer (optional). Seed used if shuffle == True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c4f798a1e7aad6c535adc8c90662adae98d4ccf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: An operation-specific seed. It will be used in conjunction with the graph-level seed to determine the real seeds that will be used in this operation. Please see the documentation of set_random_seed for its interaction with the graph-level random seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="772c48ae33d6e20b05c2c946f2f0676b7d9429e2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;int&lt;/code&gt;. Defaults to &lt;code&gt;0&lt;/code&gt;. If &lt;code&gt;seed&lt;/code&gt; is set to non-zero, the random number generator is seeded by the given &lt;code&gt;seed&lt;/code&gt;. Otherwise, it is seeded by a random seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec52955775602fbb2ed5df87d0b7793a7fbae26" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;int&lt;/code&gt;. Defaults to &lt;code&gt;0&lt;/code&gt;. If either &lt;code&gt;seed&lt;/code&gt; or &lt;code&gt;seed2&lt;/code&gt; are set to non-zero, the random number generator is seeded by the given &lt;code&gt;seed&lt;/code&gt;. Otherwise, it is seeded by a random seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6d7a42af1af811f90511b4e1ffb618ccf2dcc87" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;int&lt;/code&gt;. Defaults to &lt;code&gt;0&lt;/code&gt;. If set to be non-zero, the random number generator is seeded by the given seed. Otherwise it is seeded by a random seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8e1bda500f75c6fd88231cdad89f8965d5716a4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: Integer, random seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a41519ca91b3a5a5b3a45acef6fb1888085f297" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: Python integer seed for RNG</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d31f05990b6e2f2d59bd700039743db873de4fd0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: Python integer. Seed for PRNG used to initialize centers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7283560e0d8562ee6acfe6a9a5e6145e5910e03a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: Python integer. Used to create a random seed. See &lt;a href=&quot;../compat/v1/set_random_seed&quot;&gt;&lt;code&gt;tf.compat.v1.set_random_seed&lt;/code&gt;&lt;/a&gt; for behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205a6c6004b721e071b948633892a2196dd36951" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: Random seed for data shuffling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94318bdbfe86158c4f3e5d371898b2ae8fa01cdb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: Random seed for shuffling the data before computing the test split.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a602b62f2c9233ebfc86bcb1733d4e01540281c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: Seed for the random shuffling within the queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e539af64fa00f006de74286b34de271eaae7209d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: an integer or 1-D tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a67dbda8d5fd7e90d1f3f2a3d701042079fb14c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bebceeb05d8c255c5e6838e38a73ba9901aa0291" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: random seed for candidate sampling. Default to None, which doesn't set the op-level random seed for candidate sampling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018ea6316a9ef748dfa07ed323430cc3d44761fe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: random seed for sample shuffling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31dba30b4d2fe8b53470ce067e7207626e83ba91" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: random seed to ensure determinism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b6b11b025b8179c205429d3dc62b96d5ebfad5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: the new seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f54a9e27849a7b9ba1d13b15806ce6da35d2ab3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seed&lt;/code&gt;&lt;/b&gt;: the seed for the RNG.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7f42598d30c87d0020b3935f6eec19fe1345f1e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;segment_ids&lt;/code&gt;&lt;/b&gt;: A 1-D &lt;code&gt;Tensor&lt;/code&gt; with indices into the output &lt;code&gt;Tensor&lt;/code&gt;. Values should be sorted and can be repeated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1ae8a142fb8985ae1c7598011b034f007381e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;segment_ids&lt;/code&gt;&lt;/b&gt;: A 1-D integer Tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d1d93d097a47ace043b88e45b537363f20218b5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;segment_ids&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. A 1-D tensor whose size is equal to the size of &lt;code&gt;data&lt;/code&gt;'s first dimension. Values should be sorted and can be repeated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db3d84af9d310bf8b5ba3d97f53539f69612b6e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;segment_ids&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. A tensor whose shape is a prefix of &lt;code&gt;data.shape&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b99214c71b08a7b1d6927194043685300eff4bf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;segment_ids&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. A tensor whose shape is a prefix of data.shape. Negative segment ids are not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93e8d097e7c858d788d82cc964fdba88ae291bc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;segment_ids&lt;/code&gt;&lt;/b&gt;: An integer tensor whose shape is a prefix of &lt;code&gt;data.shape&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ffee46c38a991b476c2e78fe1ca9ca2896acbb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;select_cols&lt;/code&gt;&lt;/b&gt;: (Optional.) A sorted list of column indices to select from the input data. If specified, only this subset of columns will be parsed. Defaults to parsing all columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9cf868d4474705a0257220a38b4b0fa86923664" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;select_cols&lt;/code&gt;&lt;/b&gt;: Optional sorted list of column indices to select. If specified, only this subset of columns will be parsed and returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5121f6d7bfe74063847b6be3984e95331133b860" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;select_columns&lt;/code&gt;&lt;/b&gt;: An optional list of integer indices or string column names, that specifies a subset of columns of CSV data to select. If column names are provided, these must correspond to names provided in &lt;code&gt;column_names&lt;/code&gt; or inferred from the file header lines. When this argument is specified, only a subset of CSV columns will be parsed and returned, corresponding to the columns specified. Using this results in faster parsing and lower memory usage. If both this and &lt;code&gt;column_defaults&lt;/code&gt; are specified, these must have the same lengths, and &lt;code&gt;column_defaults&lt;/code&gt; is assumed to be sorted in order of increasing column index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe993b8f53af1e3240411fc98ed85ca245f9eab3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;selected_indices&lt;/code&gt;&lt;/b&gt;: A 1-D integer &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[M]&lt;/code&gt; representing the selected indices from the boxes tensor, where &lt;code&gt;M &amp;lt;= max_output_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ee810be9f0cdacc412f1ecf2083949fd704ee4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;selected_indices&lt;/code&gt;&lt;/b&gt;: A 1-D integer &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[M]&lt;/code&gt; representing the selected indices from the overlaps tensor, where &lt;code&gt;M &amp;lt;= max_output_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17143dbdf7b4ba85eb650e6b0f869e6fcf8cd41e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;selected_scores&lt;/code&gt;&lt;/b&gt;: A 1-D float tensor of shape &lt;code&gt;[M]&lt;/code&gt; representing the corresponding scores for each selected box, where &lt;code&gt;M &amp;lt;= max_output_size&lt;/code&gt;. Scores only differ from corresponding input scores when using Soft NMS (i.e. when &lt;code&gt;soft_nms_sigma&amp;gt;0&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0421013b8d91223de60192e29f9300c548d0b700" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;self&lt;/code&gt;&lt;/b&gt;: The RaggedTensor to slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a591420e352c0eb601327be0ec33fbdb2b1fddb3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;send_as_json&lt;/code&gt;&lt;/b&gt;: Boolean; whether the request should be sent as application/json.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db226af6a52fe65dbe73d67f2bd5408eb975b822" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sensitivity&lt;/code&gt;&lt;/b&gt;: A scalar &lt;code&gt;Tensor&lt;/code&gt; representing the sensitivity at the given &lt;code&gt;specificity&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="deaee22d3e336d8656b2d5f8a2ebc95b674acbe9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sensitivity&lt;/code&gt;&lt;/b&gt;: A scalar value in range &lt;code&gt;[0, 1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46547bad979c082a23d812d4ba6f2b8732cdd70c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sep&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;0-D&lt;/code&gt; string &lt;code&gt;Tensor&lt;/code&gt;, the delimiter character, the string should be length 0 or 1. Default is ' '.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f96e1265ccadab64ffea7ee9ddaf1b2e4ec5fc9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sep&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;0-D&lt;/code&gt; string &lt;code&gt;Tensor&lt;/code&gt;, the delimiter character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a8334936d109c9d7d9ac26e03610f0356aa3dbb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sep&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;0-D&lt;/code&gt; string &lt;code&gt;Tensor&lt;/code&gt;, the delimiter string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6c5973a2c6bbbf9fc8b36b6244a9e5bec3e188e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sep&lt;/code&gt;&lt;/b&gt;: The string to use to separate the inputs. Defaults to &quot; &quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6408185b67cd752f38d1ca24d21cba03b6139f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;separate_compiled_gradients&lt;/code&gt;&lt;/b&gt;: If true put each gradient subgraph into a separate compilation scope. This gives fine-grained control over which portions of the graph will be compiled as a single unit. Compiling gradients separately may yield better performance for some graphs. The scope is named based on the scope of the forward computation as well as the name of the gradients. As a result, the gradients will be compiled in a scope that is separate from both the forward computation, and from other gradients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aafb1609b51bfa1a4b6c2608873e3e2c1de69aa0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;separator&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;string&lt;/code&gt;. Defaults to &lt;code&gt;&quot;&quot;&lt;/code&gt;. The separator to use when joining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74289df95378673b6063cb314c39084e5b409e17" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;separator&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;string&lt;/code&gt;. Defaults to &lt;code&gt;&quot;&quot;&lt;/code&gt;. string, an optional join separator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b1ade70f529e7598d2e6cbb50990b1ffb37e6b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;separator&lt;/code&gt;&lt;/b&gt;: The separator string used between ngram elements. Must be a string constant, not a Tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03dc718ea552670f1eb7cc2a492ce8495a0f20f3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;separator&lt;/code&gt;&lt;/b&gt;: a string added between each string being joined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f807e4bfdb21c28ed93847251a86f34c31c217cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;separator&lt;/code&gt;&lt;/b&gt;: string used to separate elements in the csv file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="236988f5bfb82fe98c51e5a4ae7e7f969ce28428" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seq1&lt;/code&gt;&lt;/b&gt;: The first sequence to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ad6f7c22dee185eba7fc125042623c0330cca2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seq2&lt;/code&gt;&lt;/b&gt;: The second sequence to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8be70e8f7cd9d8043828b06a9df3e1ec33ba907" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seq&lt;/code&gt;&lt;/b&gt;: an input sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="572a334af60218433aed3d19d70315b61a2e816b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seq_length&lt;/code&gt;&lt;/b&gt;: Tensor of shape [batch], sequence length of each batch element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6a339831eca025e97f42afea6968aa4ae13111" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;seq_type&lt;/code&gt;&lt;/b&gt;: The expected datatype of the sequences, or None if no datatype should be enforced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05decdb2839efab7d5bcffcaaee2ddb309d159df" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sequence&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;tf.keras.utils.data_utils.Sequence&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8cec8383d8c43e1033cf66667013b756a849001" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sequence_feature_columns&lt;/code&gt;&lt;/b&gt;: An iterable containing the &lt;code&gt;FeatureColumn&lt;/code&gt;s that represent sequential input. All items in the set should either be sequence columns (e.g. &lt;code&gt;sequence_numeric_column&lt;/code&gt;) or constructed from one (e.g. &lt;code&gt;embedding_column&lt;/code&gt; with &lt;code&gt;sequence_categorical_column_*&lt;/code&gt; as input).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dab66cfed768fc34a53bc68cd001ddb89eae4b4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sequence_features&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;dict&lt;/code&gt; mapping feature keys to &lt;code&gt;FixedLenSequenceFeature&lt;/code&gt; or &lt;code&gt;VarLenFeature&lt;/code&gt; or &lt;code&gt;RaggedFeature&lt;/code&gt; values. These features are associated with data within the &lt;code&gt;FeatureList&lt;/code&gt; section of the &lt;code&gt;SequenceExample&lt;/code&gt; proto.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfcb199461c3de8d280b016a768483f5759c61bc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sequence_length&lt;/code&gt;&lt;/b&gt;: (optional) An int32/int64 vector size [batch_size]. See the documentation for rnn() for more details about sequence_length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f85c1496e3e00d800fa72feef9f948d7a20720" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sequence_length&lt;/code&gt;&lt;/b&gt;: (optional) An int32/int64 vector sized &lt;code&gt;[batch_size]&lt;/code&gt;. Used to copy-through state and zero-out outputs when past a batch element's sequence length. So it's more for performance than correctness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699b0bcd6c71e11d7c34f76c606f17f256a1615c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sequence_length&lt;/code&gt;&lt;/b&gt;: (optional) An int32/int64 vector sized &lt;code&gt;[batch_size]&lt;/code&gt;. Used to copy-through state and zero-out outputs when past a batch element's sequence length. This parameter enables users to extract the last valid state and properly padded outputs, so it is provided for correctness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf6c3916a4638f9e60d6148ceaff8ddf1778963" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sequence_length&lt;/code&gt;&lt;/b&gt;: (optional) An int32/int64 vector, size &lt;code&gt;[batch_size]&lt;/code&gt;, containing the actual lengths for each of the sequences in the batch. If not provided, all batch entries are assumed to be full sequences; and time reversal is applied from time &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;max_time&lt;/code&gt; for each sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="095f2ce39329cbb056c958e4e8d7114580711c2a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sequence_length&lt;/code&gt;&lt;/b&gt;: (optional) An int32/int64 vector, size &lt;code&gt;[batch_size]&lt;/code&gt;, containing the actual lengths for each of the sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f283b64c470a4b4fd045151b0e5432420406cb52" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sequence_length&lt;/code&gt;&lt;/b&gt;: 1-D &lt;code&gt;int32&lt;/code&gt; vector containing sequence lengths, having size &lt;code&gt;[batch_size]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e65865c064d393f76c995c7681220ac225870e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sequence_length&lt;/code&gt;&lt;/b&gt;: 1-D &lt;code&gt;int32&lt;/code&gt; vector, size &lt;code&gt;[batch_size]&lt;/code&gt;. The sequence lengths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf7e75e76d3ded160213eeb65a9b93c176697bce" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sequence_length&lt;/code&gt;&lt;/b&gt;: Specifies the length of each sequence in inputs. An int32 or int64 vector (tensor) size &lt;code&gt;[batch_size]&lt;/code&gt;, values in &lt;code&gt;[0, T)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdcea61bf74626a349c6453fc98cc099b9966c05" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sequence_mask&lt;/code&gt;&lt;/b&gt;: A string with the name of the sequence mask tensor. If &lt;code&gt;sequence_mask&lt;/code&gt; is in the features dictionary, the provided tensor is used, otherwise the sequence mask is computed from the length of sequential features. The sequence mask is used in evaluation and training mode to aggregate loss and metrics computation while excluding padding steps. It is also added to the predictions dictionary in prediction mode to indicate which steps are padding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a624e0b81cde174cb83e9b52dc68a47e2a59200" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;serialized&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. A scalar string containing a serialized TensorProto proto.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3881879d8fd0a15f3c742bb5cc72ded1b1bfa6f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;serialized&lt;/code&gt;&lt;/b&gt;: A scalar (0-D Tensor) of type string, a single binary serialized &lt;code&gt;SequenceExample&lt;/code&gt; proto.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c760b8cba59ae73672c880c87db0a067ffb53557" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;serialized&lt;/code&gt;&lt;/b&gt;: A scalar string Tensor, a single serialized Example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="047a0e7159b266580dac91954650686adc5c937a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;serialized&lt;/code&gt;&lt;/b&gt;: A vector (1-D Tensor) of strings, a batch of binary serialized &lt;code&gt;Example&lt;/code&gt; protos.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390e9dce879b6219fe646ec6cfdb50b643be0a5b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;serialized&lt;/code&gt;&lt;/b&gt;: A vector (1-D Tensor) of type string containing binary serialized &lt;code&gt;SequenceExample&lt;/code&gt; protos.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc69cf0d680b1ea0d94b75b7c3f7985664667e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;serialized_sparse&lt;/code&gt;&lt;/b&gt;: 2-D &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; of shape &lt;code&gt;[N, 3]&lt;/code&gt;. The serialized and packed &lt;code&gt;SparseTensor&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2828d06c12c9e701eba9b42f14d77e79036b017" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;serializer&lt;/code&gt;&lt;/b&gt;: ArgumentSerializer, the flag serializer instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1fffbcf56e783a5a0ff9ebf54c88eef72600461" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;server_or_cluster_def&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../train/serverdef&quot;&gt;&lt;code&gt;tf.train.ServerDef&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../train/clusterdef&quot;&gt;&lt;code&gt;tf.train.ClusterDef&lt;/code&gt;&lt;/a&gt; protocol buffer, or a &lt;a href=&quot;../train/clusterspec&quot;&gt;&lt;code&gt;tf.train.ClusterSpec&lt;/code&gt;&lt;/a&gt; object, describing the server to be created and/or the cluster of which it is a member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3c1089121560991bed481b2bf453956cc910e8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;service&lt;/code&gt;&lt;/b&gt;: The GCE API object returned by the googleapiclient.discovery function. (Default: discovery.build('compute', 'v1')). If you specify a custom service object, then the credentials parameter will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f0b9b95f6afc4665a864ae7e61ba8064649cd2b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;service&lt;/code&gt;&lt;/b&gt;: The GCE API object returned by the googleapiclient.discovery function. If you specify a custom service object, then the credentials parameter will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56aeb9fc862be23f0bf1098c75b16abc9b11b344" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;serving_input_receiver_fn&lt;/code&gt;&lt;/b&gt;: A function that takes no argument and returns a &lt;a href=&quot;../../../../estimator/export/servinginputreceiver&quot;&gt;&lt;code&gt;tf.estimator.export.ServingInputReceiver&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../../estimator/export/tensorservinginputreceiver&quot;&gt;&lt;code&gt;tf.estimator.export.TensorServingInputReceiver&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aac0306533fa77b5dbef7b8c3ef684f9a258487" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;serving_input_receiver_fn&lt;/code&gt;&lt;/b&gt;: A function that takes no argument and returns a &lt;a href=&quot;../../../estimator/export/servinginputreceiver&quot;&gt;&lt;code&gt;tf.estimator.export.ServingInputReceiver&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../estimator/export/tensorservinginputreceiver&quot;&gt;&lt;code&gt;tf.estimator.export.TensorServingInputReceiver&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab7a38033faeae201355127529460e60a100b06e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;serving_input_receiver_fn&lt;/code&gt;&lt;/b&gt;: A function that takes no argument and returns a &lt;a href=&quot;../export/servinginputreceiver&quot;&gt;&lt;code&gt;tf.estimator.export.ServingInputReceiver&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../export/tensorservinginputreceiver&quot;&gt;&lt;code&gt;tf.estimator.export.TensorServingInputReceiver&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcaa8a7c0ef7d6612d44b5827a30117e51f112eb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;serving_input_receiver_fn&lt;/code&gt;&lt;/b&gt;: A function that takes no argument and returns a &lt;a href=&quot;export/servinginputreceiver&quot;&gt;&lt;code&gt;tf.estimator.export.ServingInputReceiver&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;export/tensorservinginputreceiver&quot;&gt;&lt;code&gt;tf.estimator.export.TensorServingInputReceiver&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc0752b1424aaf09523fa6590a4679f33f1f043d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;serving_input_receiver_fn&lt;/code&gt;&lt;/b&gt;: a function that takes no arguments and returns a &lt;code&gt;ServingInputReceiver&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef96e4a260829df9b33d0de833d8a0624ee9154" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;serving_only&lt;/code&gt;&lt;/b&gt;: bool, &lt;code&gt;False&lt;/code&gt; by default. When this is true, only the prediction graph is saved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad006cc5684ffb2532c5cc12d7da5a90878bbbba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sess&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Session&lt;/code&gt; object to use for timing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec609d88d628c9ab470fcb1bd95d39c3aa5ec7e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sess&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Session&lt;/code&gt; used to run the queue ops. Defaults to the default session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47546a110550e7799f45dc02df7ab07debc3d6ed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sess&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Session&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264710485346e44322e03555282ce26d6bbbd8f0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sess&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Session&lt;/code&gt; to use to restore the parameters. None in eager mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e3d62ecd0c5c24547b4f5f20c23c48b8b2b5f27" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sess&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Session&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821a4bea2e487edbba26ba5c1295b246afbbb9b3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sess&lt;/code&gt;&lt;/b&gt;: A Session to use to save the variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2e1bb63f3ce9aeae8df14a43f64a13197352252" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sess&lt;/code&gt;&lt;/b&gt;: A Session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d45036824f0a2264de9a629ccbec9a1396a8e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sess&lt;/code&gt;&lt;/b&gt;: A TensorFlow &lt;code&gt;Session&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab8da913cdd79ad01506bf70435eceab7b8b6179" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sess&lt;/code&gt;&lt;/b&gt;: Active TensorFlow session containing the variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7f9cff620f82c7cc34e0aaa6c5e855752f0ec9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sess&lt;/code&gt;&lt;/b&gt;: TensorFlow Session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8863563d796f1fbcf853ba5b9eb02f4ff0c24188" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sess&lt;/code&gt;&lt;/b&gt;: The TensorFlow session from which to save the meta graph and variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1382088bc14854160ef063d6fe38e9942e67c505" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sess&lt;/code&gt;&lt;/b&gt;: The TensorFlow session to restore the variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f6379fdb428b5c301ecbe063fbba47b177b96d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session&lt;/code&gt;&lt;/b&gt;: (Optional.) The &lt;code&gt;Session&lt;/code&gt; to be used to evaluate this sparse tensor. If none, the default session will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9bcafd5fe0ff95cc53f9fa82e2f51259c3b83e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session&lt;/code&gt;&lt;/b&gt;: (Optional.) The &lt;code&gt;Session&lt;/code&gt; to be used to evaluate this tensor. If none, the default session will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d861155a3b7ed545e5dce86c3fcff99e335d42df" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session&lt;/code&gt;&lt;/b&gt;: (Optional.) The &lt;code&gt;Session&lt;/code&gt; to be used to run to this operation. If none, the default session will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20430b206c52a0870f2424640e785d314b1162ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session&lt;/code&gt;&lt;/b&gt;: (TensorFlow v1.x graph execution only) A session used for initialization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5688d115eb218c7f361314edd535ff8d585bba4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; object. See details above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24b57198eafc68e4805092e270b27df7f95ab40c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session&lt;/code&gt;&lt;/b&gt;: A TF Session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="710f2a8d2c4e3550719889f35a500cd7b939f1b2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session&lt;/code&gt;&lt;/b&gt;: A TensorFlow Session that has been created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="841125be256131f9229304e360b4871d851efafc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session&lt;/code&gt;&lt;/b&gt;: A TensorFlow Session that will be soon closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318257dc95ba716d3fb8e8d94a2b21d83e90a9c7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session&lt;/code&gt;&lt;/b&gt;: A TensorFlow session that contains the graph to convert.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b51792a41985a0034de658a47baaf9be7cd558" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session&lt;/code&gt;&lt;/b&gt;: An instance of &lt;a href=&quot;../../session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="948382819f047813197613132a99bb3432aceeac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session&lt;/code&gt;&lt;/b&gt;: So this method can call &lt;code&gt;tf.Session.run&lt;/code&gt;. This defaults to &lt;a href=&quot;../get_default_session&quot;&gt;&lt;code&gt;tf.compat.v1.get_default_session&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3949f22d322bc1b72194156de35002a1068de2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session&lt;/code&gt;&lt;/b&gt;: The TensorFlow session from which to save the meta graph and variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfb041793bf314ea858b9b623e8d50c775434740" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session&lt;/code&gt;&lt;/b&gt;: The session to evaluate variables in. Ignored when executing eagerly. If not provided when graph building, the default session is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451c6f989296a231406842094f615b405c1a09e8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session&lt;/code&gt;&lt;/b&gt;: The session to use to evaluate this variable. If none, the default session is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61dd511c9abe9b0706b48d46c940dd2b44034d65" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session_config&lt;/code&gt;&lt;/b&gt;: a ConfigProto used to set session parameters, or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3cb3c750dabb563d453ad2f9bbd08fb642c27b2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session_creation_timeout_secs&lt;/code&gt;&lt;/b&gt;: Max time workers should wait for a session to become available (on initialization or when recovering a session) with MonitoredTrainingSession. Defaults to 7200 seconds, but users may want to set a lower value to detect problems with variable / session (re)-initialization more quickly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8061f3cce5323be2240431b0bbfa66a6459d4cee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session_creator&lt;/code&gt;&lt;/b&gt;: A factory object to create session. Typically a &lt;code&gt;ChiefSessionCreator&lt;/code&gt; or a &lt;code&gt;WorkerSessionCreator&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e13b5fad4e99aaeb4a85e1929e4d4bf69b91217c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session_creator&lt;/code&gt;&lt;/b&gt;: A factory object to create session. Typically a &lt;code&gt;ChiefSessionCreator&lt;/code&gt; which is the default one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d42cc97f334c9cc470052cb1f991403bc3abd9ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session_log&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;SessionLog&lt;/code&gt; protocol buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8d967741c978937b1dca09e37186ac5368fa74" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;session_manager&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;SessionManager&lt;/code&gt;, which manages Session creation and recovery. If it is &lt;code&gt;None&lt;/code&gt;, a default &lt;code&gt;SessionManager&lt;/code&gt; will be created with the set of arguments passed in for backwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a96a74a587fc93ff7e2cbba90683ec57c11c610d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;set1&lt;/code&gt;&lt;/b&gt;: The first set to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7849ff417ea22d4dbc9787a45487e3a86dde35f3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;set2&lt;/code&gt;&lt;/b&gt;: The second set to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0510cfaf71eb84d92f39704eaea179323bc0e25a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: (optional) The shape of this variable. If None, the shape of &lt;code&gt;initial_value&lt;/code&gt; will be used. When setting this argument to &lt;a href=&quot;../../tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape(None)&lt;/code&gt;&lt;/a&gt; (representing an unspecified shape), the variable can be assigned with values of different shapes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c0d34b6c97338b5f28aadf11319468f9344a66" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: (optional) The shape of this variable. If None, the shape of &lt;code&gt;initial_value&lt;/code&gt; will be used. When setting this argument to &lt;a href=&quot;tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape(None)&lt;/code&gt;&lt;/a&gt; (representing an unspecified shape), the variable can be assigned with values of different shapes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0723cd8913c4b6975e65ec63ff9399088fb28ccc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: A 1-D (vector) int64 &lt;code&gt;Tensor&lt;/code&gt; specifying the new dense shape of the represented &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32d6782667ff6f9f2085211f203af7151519e7cf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: A 1-D integer Tensor or Python array. The shape of the output samples to be drawn per &quot;rate&quot;-parameterized distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e9b8acd426703e2c421c3a2dc02af42b4bc9e4b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: A 1-D integer Tensor or Python array. The shape of the output samples to be drawn per alpha/beta-parameterized distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b49606ebd4bc14ad03ff884bc7794f89229406c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: A 1-D integer Tensor or Python array. The shape of the output tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7630986477b66da6a17d0e22896526659f0e6bd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; or list of &lt;code&gt;int&lt;/code&gt;s. The (possibly partial) shape of the tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6944f26f63408abe118610d529c34ac286c757" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. An 1-D &lt;code&gt;int&lt;/code&gt; Tensor. The shape of the desired output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1791e6240b692bfd717a904e538977517b14628" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. Defines the shape of the output tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d2894917cc9506ca2275aff7033a6a9071ad616" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must have the same type as &lt;code&gt;indices&lt;/code&gt;. 1-D. The shape of the resulting tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0570cb9b51e3d883c78b9699856aaba6b8b0ae52" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;TensorShape&lt;/code&gt; representing the shape of this tensor, a &lt;code&gt;TensorShapeProto&lt;/code&gt;, a list, a tuple, or None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69abe3b107986e7e0e7895bb695a590524c2a9fb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;list&lt;/code&gt; of integers, a &lt;code&gt;tuple&lt;/code&gt; of integers, or a 1-D &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ae47ea471d434e8cb282039eca22d68dd4a3737" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: A TensorShape instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81090b2879784b18ab9c789ea67c2551e7f751c4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: A shape tuple (integers), not including the batch size. For instance, &lt;code&gt;shape=(32,)&lt;/code&gt; indicates that the expected input will be batches of 32-dimensional vectors. Elements of this tuple can be None; 'None' elements represent dimensions where the shape is not known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="846d4e10bc85daa41a7b01c27959af1486f1e162" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: A tuple of integers, the shape of tensor to create.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f2dbe67d40386f0368be21dce4df0b05698437" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: An iterable of integers specifies the shape of the &lt;code&gt;Tensor&lt;/code&gt;. An integer can be given which means a single dimension &lt;code&gt;Tensor&lt;/code&gt; with given width. The &lt;code&gt;Tensor&lt;/code&gt; representing the column will have the shape of [batch_size] + &lt;code&gt;shape&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08c3b40924d9653dcabdc9b66db5808d5ead34c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: Expected shape of elements of &lt;code&gt;inputs&lt;/code&gt; (optional). Also controls the output shape of this op, which may affect type inference in other ops. A value of &lt;code&gt;None&lt;/code&gt; means &quot;infer the input shape from the shapes in &lt;code&gt;inputs&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a56614032c0eb78ddeba763208d4d6fa5184be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: List of integers representing the dimensions of tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef076517cfa043741b9acf109882a7e62bd6a25f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: List of integers. The shape of the full variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70911190f9d81b60cb1446ebdb222c8abb63ebc1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: Optional dimensions of resulting tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e17b31a29bc22dbbb7086e44797f65007652fd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: Shape of input data for dimension 2 and higher. First dimension is of variable length &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="913a2b1163206e9c1f0706bd05c9825850eb29c4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: Shape of input data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab279eacab36e03e0e00c1c160e04567485aeda" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: Shape of the accumulated gradients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c518c4e695d4f26072212eae32770a354766e719" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: Shape of the new or existing variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83641c699a864336e7323e9401d6f3e4e722289" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: Shape of the placeholder (integer tuple, may include &lt;code&gt;None&lt;/code&gt; entries).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea24f203ab96062c491a1e7f4ea4b3e770749f57" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: Shape of the tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92fe707a2e64801a85ec3d07f419841b7de0af8f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: Shape tuple, expected shape of the input (may include None for unchecked axes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66aebb4d67e43c05dcca385d522cbc8078198851" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: Target shape tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14712afdbe6c7b05e363d8eaca3692cc7163345f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: The dense shape of the &lt;code&gt;IndexedSlices&lt;/code&gt;, or &lt;code&gt;None&lt;/code&gt; to allow any dense shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d2851cfa9cbfe209af75535a1eb16a2e3e3ada" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: The dense shape of the &lt;code&gt;SparseTensor&lt;/code&gt;, or &lt;code&gt;None&lt;/code&gt; to allow any dense shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="654de44e20ebfab90160d6a63b1a9e8959bd3d75" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: The shape of the RaggedTensor, or &lt;code&gt;None&lt;/code&gt; to allow any shape. If a shape is specified, then all ragged dimensions must have size &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef4c8360a3f2a78b663caef74e22cd6a0594e0b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: The shape of the input data per sequence id. E.g. if &lt;code&gt;shape=(2,)&lt;/code&gt;, each example must contain &lt;code&gt;2 * sequence_length&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639e3b684277f95f0e037a1cb1a29819c20c1caa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: The shape of the resulting dense tensor. In particular, &lt;code&gt;result.shape[i]&lt;/code&gt; is &lt;code&gt;shape[i]&lt;/code&gt; (if &lt;code&gt;shape[i]&lt;/code&gt; is not None), or &lt;code&gt;self.bounding_shape(i)&lt;/code&gt; (otherwise).&lt;code&gt;shape.rank&lt;/code&gt; must be &lt;code&gt;None&lt;/code&gt; or equal to &lt;code&gt;self.rank&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c3cc77271138711ee22ee6ff2e581e90c3e60e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: The shape of the tensor to be fed (optional). If the shape is not specified, you can feed a sparse tensor of any shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bf427f43a7c8a0c4df8efdfde730cec75abb882" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: The shape of the tensor to be fed (optional). If the shape is not specified, you can feed a tensor of any shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9e3515b7099f7e730c30a04b63a2fd9e8f4503" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: Tuple of integers, shape of returned Keras variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e36a0d615655a8035ce9f8aeefc833e9fb6702" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: Tuple or list of integers, shape of returned Keras variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde9da5c2c21693d9435352c1e1bd5573709f29e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: Value convertible to &lt;a href=&quot;tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt;. The shape of the tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ecbaedf147bf66181fac5beaa91c53755434c24" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: Variable shape. Defaults to scalar if unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d81621ead7e3adeb617733fb6a8faa27315e795d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: the &lt;code&gt;TensorShape&lt;/code&gt; representing the overridden shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c712e072ea963a444503986b0092b31a2337b3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/b&gt;: the shape of the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba74e3fea7685efaec769f8ef7aa7a49daf167d1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape_invariants&lt;/code&gt;&lt;/b&gt;: The shape invariants for the loop variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6731e7625bb8b627c8921fd9479a063ebc5bd265" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape_x&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;TensorShape&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6377692917d06bcbb269cd15e81e56bf13bc24ce" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape_x&lt;/code&gt;&lt;/b&gt;: A rank 1 integer &lt;code&gt;Tensor&lt;/code&gt;, representing the shape of x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21fe22cf589a472569af663d63b949fc3a75f42b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape_y&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;TensorShape&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dddaa9be4e054f3cec5e11673ec4cab3f9444a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shape_y&lt;/code&gt;&lt;/b&gt;: A rank 1 integer &lt;code&gt;Tensor&lt;/code&gt;, representing the shape of y.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b0fbc526667bc8999ea746b02c2d851c10af6b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shapes&lt;/code&gt;&lt;/b&gt;: (Optional) The shapes for each example. Defaults to the inferred shapes for &lt;code&gt;tensor_list&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8784e850bc375a58519b327701c45bc545edddb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shapes&lt;/code&gt;&lt;/b&gt;: (Optional) The shapes for each example. Defaults to the inferred shapes for &lt;code&gt;tensor_list_list[i]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eecc75b2d8ed25714418ef932e8fa195ec53a88a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shapes&lt;/code&gt;&lt;/b&gt;: (Optional) The shapes for each example. Defaults to the inferred shapes for &lt;code&gt;tensors&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3929a3104c66ef2642bf8de60cbe7559ecd7e214" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shapes&lt;/code&gt;&lt;/b&gt;: (Optional) The shapes for each example. Defaults to the inferred shapes for &lt;code&gt;tensors_list[i]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c714509a6edc3e3629931f0d605844d367ffb7b9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shapes&lt;/code&gt;&lt;/b&gt;: (Optional.) A list of fully-defined &lt;code&gt;TensorShape&lt;/code&gt; objects with the same length as &lt;code&gt;dtypes&lt;/code&gt;, or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a83849f0ad15aeffe4b9c4ffd1ff7a63e7387597" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shapes&lt;/code&gt;&lt;/b&gt;: (Optional.) A list of fully-defined &lt;code&gt;TensorShape&lt;/code&gt; objects, with the same length as &lt;code&gt;types&lt;/code&gt;, or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4a325cabe67135366dd24e0968b268933de73a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shapes&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;TensorShape&lt;/code&gt; objects, with the same length as &lt;code&gt;dtypes&lt;/code&gt;. Any dimension in the &lt;code&gt;TensorShape&lt;/code&gt; containing value &lt;code&gt;None&lt;/code&gt; is dynamic and allows values to be enqueued with variable size in that dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acad23b60af10a71812c98c3711fc0c04fad064f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shapes&lt;/code&gt;&lt;/b&gt;: Constraints on the shapes of tensors in an element: A list of shape tuples or None. This list is the same length as dtypes. If the shape of any tensors in the element are constrained, all must be; shapes can be None if the shapes should not be constrained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58f9c61046a548b403d902e8514266cd3194de18" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shapes&lt;/code&gt;&lt;/b&gt;: dictionary with (&lt;code&gt;Tensor&lt;/code&gt; to shape) items. A shape must be an iterable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8896e29b1c30f3af4a0513a45fcf144ffca3fdd1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shard&lt;/code&gt;&lt;/b&gt;: A sampler can be used to sample from a subset of the original range in order to speed up the whole computation through parallelism. This parameter (together with &lt;code&gt;num_shards&lt;/code&gt;) indicates the particular partition number of the operation, when partitioning is being used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfbbd0afaab946d1f29d2728fb1b9b0ca5bd620a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sharded&lt;/code&gt;&lt;/b&gt;: If &lt;code&gt;True&lt;/code&gt;, shard the checkpoints, one per device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e94585385d95778ec4e0d99310ea29d91317b89a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shared_axes&lt;/code&gt;&lt;/b&gt;: The axes along which to share learnable parameters for the activation function. For example, if the incoming feature maps are from a 2D convolution with output shape &lt;code&gt;(batch, height, width, channels)&lt;/code&gt;, and you wish to share parameters across space so that each filter only has one set of parameters, set &lt;code&gt;shared_axes=[1, 2]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584bd7a329dc076f8a159a8918594e4b85148784" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shared_embedding_collection_name&lt;/code&gt;&lt;/b&gt;: Optional collective name of these columns. If not given, a reasonable name will be chosen based on the names of &lt;code&gt;categorical_columns&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9914a6e5eef7869a5b3417fef78bcf56aaf89beb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shared_embedding_collection_name&lt;/code&gt;&lt;/b&gt;: Optional name of the collection where shared embedding weights are added. If not given, a reasonable name will be chosen based on the names of &lt;code&gt;categorical_columns&lt;/code&gt;. This is also used in &lt;code&gt;variable_scope&lt;/code&gt; when creating shared embedding weights.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cbcb42ea4abf078840600e968bbe8f7419172f8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shared_name&lt;/code&gt;&lt;/b&gt;: (Optional) If set, this queue will be shared under the given name across multiple sessions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3896f54df4ea14b25878c33f2d5136133902bf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shared_name&lt;/code&gt;&lt;/b&gt;: (Optional). If set, this queue will be shared under the given name across multiple sessions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d83ddefade2cde7c1b5a39a75c2ed8b071e61d0d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shared_name&lt;/code&gt;&lt;/b&gt;: (Optional.) If non-empty, the returned iterator will be shared under the given name across multiple sessions that share the same devices (e.g. when using a remote server).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f50326d6a133fd59a1a76e249073b354df22fef4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shared_name&lt;/code&gt;&lt;/b&gt;: (Optional.) If non-empty, this iterator will be shared under the given name across multiple sessions that share the same devices (e.g. when using a remote server).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f329886c9f5c137772c9a6a26dd87349c2c27831" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shared_name&lt;/code&gt;&lt;/b&gt;: (Optional.) If non-empty, this queue will be shared under the given name across multiple sessions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e45aca145fd4456e49c827435eb7f8ba1c279109" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shared_name&lt;/code&gt;&lt;/b&gt;: (Optional.) If set, this queue will be shared under the given name across multiple sessions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b65c7e35f45c8616b355dd14b9fddd05221ca8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shared_name&lt;/code&gt;&lt;/b&gt;: (optional). If set, this queue will be shared under the given name across multiple sessions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb74d31bd08b7f9159503c7bc7c16354ca432ba4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shared_name&lt;/code&gt;&lt;/b&gt;: (optional). If set, this queue will be shared under the given name across multiple sessions. All sessions open to the device which has this queue will be able to access it via the shared_name. Using this in a distributed setting means each name will only be seen by one of the sessions which has access to this operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50478ef2bfd9e7275d1990baceb5b174f9bc151b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shared_name&lt;/code&gt;&lt;/b&gt;: Optional. If non-empty, this accumulator will be shared under the given name across multiple sessions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a80c7754f5b7fe5f593172bbc634b55b48d68fc1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shear_range&lt;/code&gt;&lt;/b&gt;: Float. Shear Intensity (Shear angle in counter-clockwise direction in degrees)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1716c40ffe5740bf272cc54a2ec00e27b6187a01" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shift&lt;/code&gt;&lt;/b&gt;: (Optional.) A &lt;a href=&quot;../../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the forward shift of the sliding window in each iteration. Defaults to &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61dce9a80ef10891abe7a440e1126d586898403" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shift&lt;/code&gt;&lt;/b&gt;: (Optional.) A &lt;a href=&quot;../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the forward shift of the sliding window in each iteration. Defaults to &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8e52a8433f2bd47494e315f944c2a063dadcc2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shift&lt;/code&gt;&lt;/b&gt;: (Optional.) A &lt;a href=&quot;../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the forward shift of the sliding window in each iteration. Defaults to &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe82625e6e5366994ef033b19ffe491fbdf7d677" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shift&lt;/code&gt;&lt;/b&gt;: (Optional.) A &lt;a href=&quot;../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the forward shift of the sliding window in each iteration. Defaults to &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ece90cbe0b30815e712e094ff05416877ae10c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shift&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; containing the value by which the data is shifted for numerical stability, or &lt;code&gt;None&lt;/code&gt; if no shift was performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ecbd8f2d80221f13600a332d943b4a1b8e307c4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shift&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; containing the value by which to shift the data for numerical stability, or &lt;code&gt;None&lt;/code&gt; if no shift is to be performed. A shift close to the true mean provides the most numerically stable results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fbd9c779b6164b61c40fe32598507abb80303c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shift&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. Dimension must be 0-D or 1-D. &lt;code&gt;shift[i]&lt;/code&gt; specifies the number of places by which elements are shifted positively (towards larger indices) along the dimension specified by &lt;code&gt;axis[i]&lt;/code&gt;. Negative shifts will roll the elements in the opposite direction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fb6d9f0f6cf850c3f218c16ff2c03526279609" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shift&lt;/code&gt;&lt;/b&gt;: Not used in the current implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="668c3916c77a2ba0f9e5908912e6b929048d9b12" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shift&lt;/code&gt;&lt;/b&gt;: Not used in the current implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ba0f205e982c935f76153caddf2f90a0aa37a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shortest&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;bool&lt;/code&gt;. Defaults to &lt;code&gt;False&lt;/code&gt;. Use shortest representation (either scientific or standard) for floating point numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2632953b5f195af5834f337cd8c89d0bcf6a3f56" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;should_apply_gradients&lt;/code&gt;&lt;/b&gt;: Either a bool or a scalar boolean tensor. If False, the caller should skip applying &lt;code&gt;grads&lt;/code&gt; to the variables this step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9beed07565308993efc68133c739e0f6e86aea82" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;should_recover&lt;/code&gt;&lt;/b&gt;: A bool. Indicates whether to recover from &lt;code&gt;AbortedError&lt;/code&gt; and &lt;code&gt;UnavailableError&lt;/code&gt; or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d5c37de0950e46d83e95d2b5172058544dd5059" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;should_stop_fn&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;callable&lt;/code&gt;, function that takes no arguments and returns a &lt;code&gt;bool&lt;/code&gt;. If the function returns &lt;code&gt;True&lt;/code&gt;, stopping will be initiated by the chief.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be459f5e0bf0c2e792017d6267e3df82dc91293" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;show_dataflow&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;bool&lt;/code&gt;, if True, add flow events to the trace connecting producers and consumers of tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5088039ed4ff0f5220de9977e4339411778e2661" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;show_layer_names&lt;/code&gt;&lt;/b&gt;: whether to display layer names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c5732e51771d59c5efeba3665d3996be7ab3004" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;show_memory&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;bool&lt;/code&gt;, if True, add object snapshot events to the trace showing the sizes and lifetimes of tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a806d8898355db40833e38a6899241190ec05c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;show_name_regexes&lt;/code&gt;&lt;/b&gt;: list of node names regexes to display.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de44a833da260bd1515a0ac8bc878e51455953eb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;show_shapes&lt;/code&gt;&lt;/b&gt;: whether to display shape information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="919124c0eb5d28a576babbc8f81b24232f6db7f8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shrink_axis_mask&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;int32&lt;/code&gt; mask.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2736d0e8b8999c0f89e8f5408595b3390bcb346b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/b&gt;: (Optional.) A boolean. If true, the rows are randomly shuffled within each epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbd0f23e7ff8c8bde92158e2a9edf56ea851d831" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/b&gt;: (Optional.) If &lt;code&gt;True&lt;/code&gt;, the file names will be shuffled randomly. Defaults to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a664b22bc52814eff41a774de731b6c659c60e5d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/b&gt;: A bool that indicates whether the input should be shuffled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff09baabd03971e83a6d164fe73f740f317130f5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/b&gt;: A boolean, indicates whether the input should be shuffled. Defaults to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5941889a3c0e3d466629ffb9da06deb69a019006" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/b&gt;: Boolean (whether to shuffle the training data before each epoch) or str (for 'batch'). 'batch' is a special option for dealing with the limitations of HDF5 data; it shuffles in batch-sized chunks. Has no effect when &lt;code&gt;steps_per_epoch&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ec7727ad5a9fa2caa95a6fb9aabdd7b472999ed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/b&gt;: Boolean, if True shuffles the queue. Avoid shuffle at prediction time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04ee2205f53a62aba4bb1038e15710e39676e4e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/b&gt;: Boolean, whether to shuffle the data between epochs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70121503f9f35f0fc125e596d204816c963c52fe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/b&gt;: Boolean. If true, the integers are randomly shuffled within each epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0049a0d15eb9e937cf803c19a3d208482d70f415" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/b&gt;: Boolean. If true, the strings are randomly shuffled within each epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0030fbc72450a77a9a04bed48316649f7657b99a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/b&gt;: bool, whether to read the records in random order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91bf3581190d34fe4ad6742466cc87a89f93adc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/b&gt;: whether to shuffle the data at the beginning of each epoch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ff4b524c92a68dbf290afe6efefc11c38a3bfa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shuffle_buffer_size&lt;/code&gt;&lt;/b&gt;: Buffer size of the ShuffleDataset. A large capacity ensures better shuffling but would increase memory usage and startup time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7feb84e0b5d5d0a234ba26e59e51f5de6985be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shuffle_buffer_size&lt;/code&gt;&lt;/b&gt;: Buffer size to use for shuffling. A large buffer size ensures better shuffling, but increases memory usage and startup time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f95b23dce161bd011439beeef42cfbac7e268a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;shuffle_seed&lt;/code&gt;&lt;/b&gt;: Randomization seed to use for shuffling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19125600ff42a953b1693f352af831959e50aa15" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;side&lt;/code&gt;&lt;/b&gt;: 'left' or 'right'; 'left' corresponds to lower_bound and 'right' to upper_bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5b907917b56fa4fb676528291b9c0d2c237f98" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sign&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Has the same type as &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b22dcc8f0904b9166bd75b184f5a6644f8aa09" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;[..., samples, ...]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;. The rank and dimensions may be unknown. Rank must be at least 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e620c13abe046cacf9760f25d17beddb458aea15" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/b&gt;: A [..., frames, frame_length] &lt;code&gt;Tensor&lt;/code&gt;. All dimensions may be unknown, and rank must be at least 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c41fcf67f1b68114916c90e2745d5c2a14bfc29f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;signals&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;[..., samples]&lt;/code&gt;&lt;code&gt;float32&lt;/code&gt;/&lt;code&gt;float64&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; of real-valued signals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2cc7a2347b212559a0e60d0b506f0d2f54fb94" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;signature&lt;/code&gt;&lt;/b&gt;: the placeholder and python arguments to be passed to the wrapped function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b649eb0ee58922d240fa3b724b908b24be07ee4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;signature_def_map&lt;/code&gt;&lt;/b&gt;: The map of signature def map to add to the meta graph def.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bafa6b13c616c9aad45ebb290b8b2edb223e486e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;signature_def_map&lt;/code&gt;&lt;/b&gt;: The map of signature defs to be added to the meta graph def.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dfe7d07bdf7c75d22c9ac94f68114a43c46ce8a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;signature_key&lt;/code&gt;&lt;/b&gt;: Key identifying SignatureDef containing inputs and outputs. (default DEFAULT_SERVING_SIGNATURE_DEF_KEY)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fac71eed9659ca1901f377c4073e109a7c752a7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;signature_keys&lt;/code&gt;&lt;/b&gt;: List of keys identifying SignatureDef containing inputs and outputs. Elements should not be duplicated. By default the &lt;code&gt;signatures&lt;/code&gt; attribute of the MetaGraphdef is used. (default saved_model.signatures)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57c1bb9b8d1c3825bada0e71c7ad9746e5e01917" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;signatures&lt;/code&gt;&lt;/b&gt;: Optional, either a &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; with an input signature specified or the result of &lt;code&gt;f.get_concrete_function&lt;/code&gt; on a &lt;code&gt;@tf.function&lt;/code&gt;-decorated function &lt;code&gt;f&lt;/code&gt;, in which case &lt;code&gt;f&lt;/code&gt; will be used to generate a signature for the SavedModel under the default serving signature key. &lt;code&gt;signatures&lt;/code&gt; may also be a dictionary, in which case it maps from signature keys to either &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; instances with input signatures or concrete functions. The keys of such a dictionary may be arbitrary strings, but will typically be from the &lt;code&gt;tf.saved_model.signature_constants&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4cd5280705f42820206af3428b07bd8b5c007a7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;signatures&lt;/code&gt;&lt;/b&gt;: Signatures to save with the SavedModel. Applicable to the 'tf' format only. Please see the &lt;code&gt;signatures&lt;/code&gt; argument in &lt;a href=&quot;../../saved_model/save&quot;&gt;&lt;code&gt;tf.saved_model.save&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2761a9fa59c99b42cb0213c9fa44826e63769a81" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;signatures&lt;/code&gt;&lt;/b&gt;: Signatures to save with the SavedModel. Applicable to the 'tf' format only. Please see the &lt;code&gt;signatures&lt;/code&gt; argument in &lt;a href=&quot;../saved_model/save&quot;&gt;&lt;code&gt;tf.saved_model.save&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b6c92a70b5dfddd175a59161e715f492f06599c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;signed_input&lt;/code&gt;&lt;/b&gt;: True if the quantization is signed or unsigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f76780184bd11668cdd4ec1ff4092e3434ef8a3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;size&lt;/code&gt;&lt;/b&gt;: (optional) int32 scalar &lt;code&gt;Tensor&lt;/code&gt;: the size of the TensorArray. Required if handle is not provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a041ac8467382d78efc39d2a4ac8cb108a85f6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;size&lt;/code&gt;&lt;/b&gt;: 1-D tensor with size the rank of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e844b8bbd4585a935968e892a1f36e4fd2b4dd92" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;size&lt;/code&gt;&lt;/b&gt;: 1-D. tensor represents the size of the slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee618bc75feacf060b85850cbc0034514046062" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;size&lt;/code&gt;&lt;/b&gt;: A 1-D int32 Tensor of 2 elements: &lt;code&gt;new_height, new_width&lt;/code&gt;. The new size for the images.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37685634b0e4702fc8951d0bb9d55d738355ee03" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;size&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the number of elements of the input dataset to combine into a window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b2093b7e06f4dd2c1777a547fbd083490f2a6e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;size&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the number of elements of the input dataset to combine into a window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bf8843f9ed9ddbd32554ace2549122a5f2f92c0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;size&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the number of elements of the input dataset to combine into a window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005472fbee6f2700cd4751af451d936de9e194fa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;size&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the number of elements of the input dataset to combine into a window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93eed66f7a267bd31d7cbc0c53928d1b8dce5e48" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;size&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;int32&lt;/code&gt;. A 1-D tensor of 2 elements containing the size of the glimpses to extract. The glimpse height must be specified first, following by the glimpse width.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c818842fd6afd639d78fbbc6d4160c712665ec5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;size&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Has the same type as &lt;code&gt;image_size&lt;/code&gt;. 1-D, containing &lt;code&gt;[target_height, target_width, -1]&lt;/code&gt;. Provide as input to &lt;a href=&quot;../../../slice&quot;&gt;&lt;code&gt;tf.slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31765038dcbc9218dd7e79dddf1ec29118ab1c41" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;size&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Has the same type as &lt;code&gt;image_size&lt;/code&gt;. 1-D, containing &lt;code&gt;[target_height, target_width, -1]&lt;/code&gt;. Provide as input to &lt;a href=&quot;../slice&quot;&gt;&lt;code&gt;tf.slice&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="600b9b61bfbd5aba797c9d0870dc9cbce218bab2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;size&lt;/code&gt;&lt;/b&gt;: A Python int or list thereof specifying the dense shape. Should be a list if and only if &lt;code&gt;index_key&lt;/code&gt; is a list. In that case the list must be equal to the length of &lt;code&gt;index_key&lt;/code&gt;. Each for each entry &lt;code&gt;i&lt;/code&gt; all values in the &lt;code&gt;index_key&lt;/code&gt;[i] feature must be in &lt;code&gt;[0, size[i])&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8da8b75250695e86fadd5fb16a71565109ff129" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;size&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da03736ec775f528366f40ba9dd515d371faf824" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;size&lt;/code&gt;&lt;/b&gt;: Int, or tuple of 2 integers. The upsampling factors for rows and columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf360bd72d9aeca17a7ce46e1ef5b6e610beee4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;size&lt;/code&gt;&lt;/b&gt;: Int, or tuple of 3 integers. The upsampling factors for dim1, dim2 and dim3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa95d42c3ac25e8c03ee643f305248e15746fab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;size&lt;/code&gt;&lt;/b&gt;: Integer, number of rows/columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e11c44d0224abab1f440f8b996a505b0dff987b5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;size&lt;/code&gt;&lt;/b&gt;: Integer. Upsampling factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0357efc352b28ec6e4425d87c5516c1452a9e5c4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sizes&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b299ecc3060164f10f9f018c3e69a3fba65d1301" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sizes&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;int32&lt;/code&gt;. Tensor of int32 with shape &lt;code&gt;[batch_shape, len(field_names)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9883c023c9207e21c4b2b711b9fe977959b07d16" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sizes&lt;/code&gt;&lt;/b&gt;: The size of the extracted patches. Must be [1, size_rows, size_cols, 1].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54bb8e0fc68df571c4a4b29f159cd73737e62046" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;skip_empty&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;bool&lt;/code&gt;. If &lt;code&gt;True&lt;/code&gt;, skip the empty strings from the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b1976336e89db03167d53683bddad854313356c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;skip_header_lines&lt;/code&gt;&lt;/b&gt;: An optional int. Defaults to 0. Number of lines to skip from the beginning of every file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acbd21b3e04545f00ad0e4b92b577f56c3325330" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;skip_mismatch&lt;/code&gt;&lt;/b&gt;: Boolean, whether to skip loading of layers where there is a mismatch in the number of weights, or a mismatch in the shape of the weight (only valid when &lt;code&gt;by_name=True&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac3bdf1d859d2f090b46214c9e7a91ebfce8238" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;skip_top&lt;/code&gt;&lt;/b&gt;: skip the top N most frequently occurring words (which may not be informative).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8c8972ed906b3a670717614939482d6cd992bc4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;slice_spec&lt;/code&gt;&lt;/b&gt;: The arguments to &lt;a href=&quot;../../tensor#__getitem__&quot;&gt;&lt;code&gt;Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71168bf63d7a8f77a2cefe50742e4c56aeee920c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;slice_spec&lt;/code&gt;&lt;/b&gt;: The arguments to &lt;a href=&quot;tensor#__getitem__&quot;&gt;&lt;code&gt;Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812ed57976958b4329db0b609766b1ba53f9514f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;slice_spec&lt;/code&gt;&lt;/b&gt;: The arguments to Tensor.&lt;strong&gt;getitem&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7023b724a8175a09bed50d24ec77466c2cedead8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;slicing&lt;/code&gt;&lt;/b&gt;: List of integers. How to partition the variable. Must be of the same length as &lt;code&gt;shape&lt;/code&gt;. Each value indicate how many slices to create in the corresponding dimension. Presently only one of the values can be more than 1; that is, the variable can only be sliced along one dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7470c0166a657910bf98f7373c018bd7c0b9296b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sloppy&lt;/code&gt;&lt;/b&gt;: If &lt;code&gt;True&lt;/code&gt;, reading performance will be improved at the cost of non-deterministic ordering. If &lt;code&gt;False&lt;/code&gt;, the order of elements produced is deterministic prior to shuffling (elements are still randomized if &lt;code&gt;shuffle=True&lt;/code&gt;. Note that if the seed is set, then order of elements after shuffling is deterministic). Defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="397af7ecb35ee62aecb32f81f77eadf024c3f007" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sloppy&lt;/code&gt;&lt;/b&gt;: If false, elements are produced in deterministic order. Otherwise, the implementation is allowed, for the sake of expediency, to produce elements in a non-deterministic order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24855e03e74b59abd84d624e14fc27994efa9fe9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sloppy_ordering&lt;/code&gt;&lt;/b&gt;: If &lt;code&gt;True&lt;/code&gt;, reading performance will be improved at the cost of non-deterministic ordering. If &lt;code&gt;False&lt;/code&gt;, the order of elements produced is deterministic prior to shuffling (elements are still randomized if &lt;code&gt;shuffle=True&lt;/code&gt;. Note that if the seed is set, then order of elements after shuffling is deterministic). Defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da1bc270d7f0f5bd6cb9c4da0167fd9e77b028cb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;soft_nms_sigma&lt;/code&gt;&lt;/b&gt;: A scalar float representing the Soft NMS sigma parameter; See Bodla et al, https://arxiv.org/abs/1704.04503). When &lt;code&gt;soft_nms_sigma=0.0&lt;/code&gt; (which is default), we fall back to standard (hard) NMS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6691c6e04714b00221929a0ff0c7c947f523d223" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sorted&lt;/code&gt;&lt;/b&gt;: If true the resulting &lt;code&gt;k&lt;/code&gt; elements will be sorted by the values in descending order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a88e6e5f41d9faeddb895bece239b1bf59bfe1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sorted_sequence&lt;/code&gt;&lt;/b&gt;: N-D &lt;code&gt;Tensor&lt;/code&gt; containing a sorted sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ddc9ff01e45da3755fd0a8660a2e470b675ada" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;source&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;1-D&lt;/code&gt; string &lt;code&gt;Tensor&lt;/code&gt;, the strings to split.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9a5045c93716e2df3936c2dd6f339256882a0d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;source&lt;/code&gt;&lt;/b&gt;: A tensor with rank 2 or higher and with shape [b, x1, ..., x_m].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663ff5a06db60051c3ed4e93fc62a9a4dc3a52f1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;source&lt;/code&gt;&lt;/b&gt;: alias for &quot;input&quot; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99dfcf128ca537df2b9dc3cf71ba56491a4861f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;source_column&lt;/code&gt;&lt;/b&gt;: A one-dimensional dense column which is generated with &lt;code&gt;numeric_column&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf2e9358f6d8d207bee7c3889430505d6d757d82" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;source_device&lt;/code&gt;&lt;/b&gt;: The original device on which &lt;code&gt;input_dataset&lt;/code&gt; will be placed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4f1d2a533524ac3f6c76c48024d7c3fb32984cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sources&lt;/code&gt;&lt;/b&gt;: a list or nested structure of Tensors or Variables. &lt;code&gt;target&lt;/code&gt; will be differentiated against elements in &lt;code&gt;sources&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="731fb9feeb057b9281c4d2d3edff5d15b273be04" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_a&lt;/code&gt;&lt;/b&gt;: SparseTensor A, of rank 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea9a537609d76a1dd6c8a7dee4d06329e9948315" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_a&lt;/code&gt;&lt;/b&gt;: a &lt;code&gt;SparseTensor&lt;/code&gt; operand whose dtype is real, and indices lexicographically ordered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b70ba83a7cc25c59f4b9fecb417e6a37714408" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_b&lt;/code&gt;&lt;/b&gt;: the other &lt;code&gt;SparseTensor&lt;/code&gt; operand with the same requirements (and the same shape).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a14b5f66320be4cedd7482faf608f38b6f13c96" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_ids&lt;/code&gt;&lt;/b&gt;: A single &lt;code&gt;SparseTensor&lt;/code&gt; with &lt;code&gt;values&lt;/code&gt; property of type &lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt; or a Python list of such &lt;code&gt;SparseTensor&lt;/code&gt;s or a list thereof.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a4a11ff4bdab1c91db4f0bb16ae9600570e343" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_ids&lt;/code&gt;&lt;/b&gt;: N x M &lt;code&gt;SparseTensor&lt;/code&gt; of int64 ids where N is typically batch size and M is arbitrary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19b0c15fc52decc5a082a1b4382922f4e8905ef4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_indices&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;int64&lt;/code&gt;. 2-D. &lt;code&gt;N x R&lt;/code&gt; matrix with the indices of non-empty values in a SparseTensor, possibly not in canonical ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc0a97971b150be7dd768d8fb97a127d6659b079" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;SparseTensor&lt;/code&gt; with &lt;code&gt;values&lt;/code&gt; property of type &lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52cd9860cc61c0f7a746b6def50f573c8d2613e2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;SparseTensor&lt;/code&gt; with shape &lt;code&gt;[N, M]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faa7e3be3b91c154e9fa8c250974ed78e75d7245" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2339d85301d97e53958e7c3bd7b711ef06ec788" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_input&lt;/code&gt;&lt;/b&gt;: N-D &lt;code&gt;SparseTensor&lt;/code&gt;, where &lt;code&gt;N &amp;gt;= 2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61573f7cb67bcf6c388c6773082b865afc8b79d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_input&lt;/code&gt;&lt;/b&gt;: The &lt;code&gt;SparseTensor&lt;/code&gt; to split.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102fbc947d950b13e307a927bc5787279a650b7b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_input&lt;/code&gt;&lt;/b&gt;: The SparseTensor to reduce. Should have numeric type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbc34d2b28f40a973b9a901d6e9813d4727b196d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_input&lt;/code&gt;&lt;/b&gt;: The input &lt;code&gt;SparseTensor&lt;/code&gt; with &lt;code&gt;N&lt;/code&gt; non-empty elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9bcca749071c0cc38e642c2f59436956ac79f90" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_input&lt;/code&gt;&lt;/b&gt;: The input &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2d221c98e5280b609b781118da79aa2abe9c6f8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_input&lt;/code&gt;&lt;/b&gt;: The input rank &lt;code&gt;R&lt;/code&gt;&lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16546cd6243e17c78a1609653b3f77f38539ec27" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_inputs&lt;/code&gt;&lt;/b&gt;: List of &lt;code&gt;SparseTensor&lt;/code&gt; to concatenate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8e17d3ed0b0951177a206589f24496e4d781340" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_ordered_output&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;SparseTensor&lt;/code&gt; with shape &lt;code&gt;[N, M]&lt;/code&gt;, and with all empty rows filled in with &lt;code&gt;default_value&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fb22d74b67903ed9c6932288e9257c14a865d5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_shape&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;int64&lt;/code&gt;. 1-D. Shape of the input SparseTensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0cc6c5121ca9ae05ae943c1def39aec185d9511" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_values&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;SparseTensor&lt;/code&gt; of any type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c5551b1101d3290fba241f38eb45d641e63261" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_values&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;qint8&lt;/code&gt;, &lt;code&gt;quint8&lt;/code&gt;, &lt;code&gt;qint32&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;. 1-D. &lt;code&gt;N&lt;/code&gt; non-empty values corresponding to &lt;code&gt;sp_indices&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844d99cee424b6b76cdb249202fb1a9ff2fe2b99" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sp_weights&lt;/code&gt;&lt;/b&gt;: either a &lt;code&gt;SparseTensor&lt;/code&gt; of float / double weights, or &lt;code&gt;None&lt;/code&gt; to indicate all weights should be taken to be 1. If specified, &lt;code&gt;sp_weights&lt;/code&gt; must have exactly the same shape and indices as &lt;code&gt;sp_ids&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0517d39fe509553b910b7ba5470bde637b700695" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/b&gt;: A boolean specifying whether the placeholder to be created is sparse. Only one of 'ragged' and 'sparse' can be True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c410829ec24c8eb217f2015766c8c70951e98d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/b&gt;: Boolean, whether the placeholder created is meant to be sparse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6f27f8c539c06ace045bd72da07e2876f30eb71" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse&lt;/code&gt;&lt;/b&gt;: Boolean, whether the placeholder should have a sparse type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4131248272b4ae8e7ec613a88c1bdeed74f10607" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_combiner&lt;/code&gt;&lt;/b&gt;: A string specifying how to reduce if a categorical column is multivalent. Except &lt;code&gt;numeric_column&lt;/code&gt;, almost all columns passed to &lt;code&gt;linear_model&lt;/code&gt; are considered as categorical columns. It combines each categorical column independently. Currently &quot;mean&quot;, &quot;sqrtn&quot; and &quot;sum&quot; are supported, with &quot;sum&quot; the default for linear model. &quot;sqrtn&quot; often achieves good accuracy, in particular with bag-of-words columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bb02e70529ba2d9b35cd8b1ed22e90f3454dd28" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_combiner&lt;/code&gt;&lt;/b&gt;: A string specifying how to reduce if a categorical column is multivalent. One of &quot;mean&quot;, &quot;sqrtn&quot;, and &quot;sum&quot; -- these are effectively different ways to do example-level normalization, which can be useful for bag-of-words features. for more details, see &lt;code&gt;tf.feature_column.linear_model&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3c7074b6ae292d95dd6fab8e13fe170f8bf5e62" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_combiner&lt;/code&gt;&lt;/b&gt;: A string specifying how to reduce if a categorical column is multivalent. One of &quot;mean&quot;, &quot;sqrtn&quot;, and &quot;sum&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89782e4356d5698311914be7d5c2a7fcbedb3fee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_delta&lt;/code&gt;&lt;/b&gt;: &lt;a href=&quot;../../indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; to be added to this variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e775594e25fe9f1dd8a2d1eff2a7635ae0e965" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_delta&lt;/code&gt;&lt;/b&gt;: &lt;a href=&quot;../../indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; to be assigned to this variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc05076d19c310e4e41070b64ec5dcf1311b6f3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_delta&lt;/code&gt;&lt;/b&gt;: &lt;a href=&quot;../../indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; to be subtracted from this variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e147fbbd751a445f606ce8c70599dd4471ac7b3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_delta&lt;/code&gt;&lt;/b&gt;: &lt;a href=&quot;../../indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; to divide this variable by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0586c4ed5be3d51ca0d03a26b53981f9fb13ae8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_delta&lt;/code&gt;&lt;/b&gt;: &lt;a href=&quot;../../indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; to multiply this variable by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97caed96bd6acdc5bde74b50b1549a267104f5d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_delta&lt;/code&gt;&lt;/b&gt;: &lt;a href=&quot;../../indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; to use as an argument of max with this variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ee873cd6e9cdf7cb5f18e863b1bb9ff887d317" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_delta&lt;/code&gt;&lt;/b&gt;: &lt;a href=&quot;../../indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; to use as an argument of min with this variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bef25138dae1a17cd26eda65c6c4647b01a7bbc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_delta&lt;/code&gt;&lt;/b&gt;: &lt;a href=&quot;indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; to be added to this variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07dbeb8068c3c15e8e05f394215bcfc6cfec28a8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_delta&lt;/code&gt;&lt;/b&gt;: &lt;a href=&quot;indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; to be assigned to this variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7102391131fb0967ae53793b0d162537cfc06d2d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_delta&lt;/code&gt;&lt;/b&gt;: &lt;a href=&quot;indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; to be subtracted from this variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05a71f28b9a9ea2e48b44a31c1ea283adcfb02c5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_delta&lt;/code&gt;&lt;/b&gt;: &lt;a href=&quot;indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; to divide this variable by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="596f4c8b91633c305542c3c819b0ef3eee9a53db" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_delta&lt;/code&gt;&lt;/b&gt;: &lt;a href=&quot;indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; to multiply this variable by.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4aa6761c2f03eaa7ad118ce0186cf3768f65c90" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_delta&lt;/code&gt;&lt;/b&gt;: &lt;a href=&quot;indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; to use as an argument of max with this variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02235790ed68bebb9fb594eac3897d6671fe9121" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_delta&lt;/code&gt;&lt;/b&gt;: &lt;a href=&quot;indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; to use as an argument of min with this variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c314ad467eb3642f577098f856ac4e3fd96c8d71" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_example_indices&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;Tensor&lt;/code&gt; objects with type &lt;code&gt;int64&lt;/code&gt;. a list of vectors which contain example indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e67d5f0d54379b10cf5a15e51d32c6878134fc4b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_feature_indices&lt;/code&gt;&lt;/b&gt;: A list with the same length as &lt;code&gt;sparse_example_indices&lt;/code&gt; of &lt;code&gt;Tensor&lt;/code&gt; objects with type &lt;code&gt;int64&lt;/code&gt;. a list of vectors which contain feature indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe122408622e74471347df4e35b9f14363c0242f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_feature_values&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;Tensor&lt;/code&gt; objects with type &lt;code&gt;float32&lt;/code&gt;. a list of vectors which contains feature value associated with each feature group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b37dddf9e47f331750a5084e1853fd5567eba6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_ids&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;SparseTensor&lt;/code&gt; of shape &lt;code&gt;[d_0, d_1, ..., d_n]&lt;/code&gt; containing the ids. &lt;code&gt;d_0&lt;/code&gt; is typically batch size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6676e64293e2c09bd338e12b6c7975786e075d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_indices&lt;/code&gt;&lt;/b&gt;: A 0-D, 1-D, or 2-D &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt;. &lt;code&gt;sparse_indices[i]&lt;/code&gt; contains the complete index where &lt;code&gt;sparse_values[i]&lt;/code&gt; will be placed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd73849be7aa555c967153bf344863d61f15899" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_indices&lt;/code&gt;&lt;/b&gt;: A list with the same length as &lt;code&gt;sparse_example_indices&lt;/code&gt; of &lt;code&gt;Tensor&lt;/code&gt; objects with type &lt;code&gt;int64&lt;/code&gt;. a list of vectors where each value is the indices which has corresponding weights in sparse_weights. This field maybe omitted for the dense approach.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17fe9f3b0e143dc239eb1a800590599e6523ad17" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_tensor&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f80704643f3812a1ddcb062ac4f07ea0910666b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_tensor&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10a1e33a2b9bd7f73be7214822836db5a39148a8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_values&lt;/code&gt;&lt;/b&gt;: A 0-D or 1-D &lt;code&gt;Tensor&lt;/code&gt;. Values corresponding to each row of &lt;code&gt;sparse_indices&lt;/code&gt;, or a scalar value to be used for all sparse indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a939277cc7c4bc90ae1013016f352f0dc931140" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_weights&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;SparseTensor&lt;/code&gt; of same shape as &lt;code&gt;sparse_ids&lt;/code&gt;, containing float weights corresponding to &lt;code&gt;sparse_ids&lt;/code&gt;, or &lt;code&gt;None&lt;/code&gt; if all weights are be assumed to be 1.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c64f34860ef4fe447cb9df64ee9e44bf25a5c34a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sparse_weights&lt;/code&gt;&lt;/b&gt;: A list with the same length as &lt;code&gt;sparse_example_indices&lt;/code&gt; of &lt;code&gt;Tensor&lt;/code&gt; objects with type &lt;code&gt;float32&lt;/code&gt;. a list of vectors where each value is the weight associated with a sparse feature group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="170b9e6d1d66a2990cfe1950dc811f5cc5b24e2f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;spatial_dims&lt;/code&gt;&lt;/b&gt;: Monotonically increasing sequence of &lt;code&gt;num_spatial_dims&lt;/code&gt; integers (which are &amp;gt;= 1) specifying the spatial dimensions of &lt;code&gt;input&lt;/code&gt; and output. Defaults to: &lt;code&gt;range(1, num_spatial_dims+1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="263e3eee858475c8195d7eaea4ec6904b1a7a384" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;spec&lt;/code&gt;&lt;/b&gt;: a string of the form /job:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a09b21d5bfeb23c01c96c6140bc734e527e6fe17" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;spec&lt;/code&gt;&lt;/b&gt;: an optional string of the form /job:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50722176b745d1d988ec1f6d07eb83ad1bfec6d8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;spec_or_tensor&lt;/code&gt;&lt;/b&gt;: A tf.TensorSpec or a tf.Tensor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a4478dce4f1a9b1266f299c06520715bec9f7f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;specificity&lt;/code&gt;&lt;/b&gt;: A scalar &lt;code&gt;Tensor&lt;/code&gt; representing the specificity at the given &lt;code&gt;sensitivity&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="572de401669de2f622ba5ba3e3a2aa25aedf8995" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;specificity&lt;/code&gt;&lt;/b&gt;: A scalar value in range &lt;code&gt;[0, 1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30337c999014cd30b9d3185f9702ca5b496365c4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;spectrum&lt;/code&gt;&lt;/b&gt;: Shape &lt;code&gt;[B1,...,Bb, N]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;. Allowed dtypes: &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;. Type can be different than &lt;code&gt;input_output_dtype&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5c2dc6f4a05aa2b0ced26851790b1f1dd8a824a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;split&lt;/code&gt;&lt;/b&gt;: Optional specification for splitting the input text. Values can be None (no splitting), 'whitespace' (split on ASCII whitespace), or a Callable. The default is 'whitespace'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53dec3fae483c72b39fc9fb5bfc7b09cb3d34fc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;split&lt;/code&gt;&lt;/b&gt;: Optional specification for splitting the input text. Values can be None (no splitting), SPLIT_ON_WHITESPACE (split on ASCII whitespace), or a Callable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4975e6a02b470819bc693390f68b5934a605c2b4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;split_dim&lt;/code&gt;&lt;/b&gt;: Deprecated old name for axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a77ae337f26798ab42347d20758b4b174a8525d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;splits&lt;/code&gt;&lt;/b&gt;: A sorted 1-D integer Tensor. &lt;code&gt;splits[0]&lt;/code&gt; must be zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f3f52a122d74de07965c3854fd9004f820610d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;squeeze_dims&lt;/code&gt;&lt;/b&gt;: Deprecated keyword argument that is now axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a95772aca48b9712f9fe4e35d1b933adb70b0912" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;src&lt;/code&gt;&lt;/b&gt;: string, name of the file whose contents need to be copied</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e1385b3e8a25335b4ba1818c14890ddb8ca9090" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;src&lt;/code&gt;&lt;/b&gt;: string, pathname for a file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="080861a1b83637ce823387772c9f771d4d75926c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;st_input&lt;/code&gt;&lt;/b&gt;: The sparse tensor to convert. Must have rank 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84df6e470f7682d83858a264a45cd748bd7f4ee5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stable&lt;/code&gt;&lt;/b&gt;: If True, equal elements in the original tensor will not be re-ordered in the returned order. Unstable sort is not yet implemented, but will eventually be the default for performance reasons. If you require a stable order, pass &lt;code&gt;stable=True&lt;/code&gt; for forwards compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bb0bd8619c1c9cffa0948b65077de129c4ddeac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stack_height_limit&lt;/code&gt;&lt;/b&gt;: Limit to the height of the printed stack trace. Applicable only to ops in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s (graphs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b0d5cc3a7f465d48f81d2369b6346b291ae60a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;staircase&lt;/code&gt;&lt;/b&gt;: Boolean. If &lt;code&gt;True&lt;/code&gt; decay the learning rate at discrete intervals</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628c9c1041de48b955412f864d813638d5434f01" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;staircase&lt;/code&gt;&lt;/b&gt;: Whether to apply decay in a discrete staircase, as opposed to continuous, fashion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cffa1b4f35a5ecef329854db4ed5eab1d23517d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;standardize&lt;/code&gt;&lt;/b&gt;: Optional specification for standardization to apply to the input text. Values can be None (no standardization), 'lower_and_strip_punctuation' (lowercase and remove punctuation) or a Callable. Default is 'lower_and_strip_punctuation'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d8b1667274aee689a6f637511996dd78481e121" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;standardize&lt;/code&gt;&lt;/b&gt;: Optional specification for standardization to apply to the input text. Values can be None (no standardization), LOWER_AND_STRIP_PUNCTUATION (lowercase and remove punctuation) or a Callable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d7ea6fe237d63fd80b99fe7f893661030ce785" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;start&lt;/code&gt;&lt;/b&gt;: (Optional.) Boolean, indicating whether to start the server after creating it. Defaults to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b43e5db54dc2345101669815a310be0bc6ae42" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;start&lt;/code&gt;&lt;/b&gt;: (Optional.) The starting value for the counter. Defaults to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b6947fec77c3b045275aeb20bfd5ea66b7e709" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;start&lt;/code&gt;&lt;/b&gt;: 1-D. tensor represents the start of the slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46736c1f412db81fc28ff6b03051ba46f14ca3c8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;start&lt;/code&gt;&lt;/b&gt;: A 0-D &lt;code&gt;Tensor&lt;/code&gt; (scalar). Acts as first entry in the range if &lt;code&gt;limit&lt;/code&gt; is not None; otherwise, acts as range limit and first entry defaults to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad331319769ebac64c8c5c389cc39462163cc35" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;start&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the start value for enumeration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c457512470055450461223832f634d03ca58a66" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;start&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the start value for enumeration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870e4d4528c7b60b0fbc685f60758524f2ae35e2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;start&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the start value for enumeration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f327bbbbc2bbc0118cab06af8b4ea5de008edde" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;start&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the start value for enumeration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8ade49b877648cfdecef528cff80b4bbbfac30c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;start&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;. 0-D tensor. First entry in the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73ed49f9975e5db17af12952979ee4ee6091c494" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;start&lt;/code&gt;&lt;/b&gt;: Boolean. If &lt;code&gt;True&lt;/code&gt; starts the threads. If &lt;code&gt;False&lt;/code&gt; the caller must call the &lt;code&gt;start()&lt;/code&gt; method of the returned threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d3acbe482272ac5ad3a8e1bfeaa74ce95898ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;start&lt;/code&gt;&lt;/b&gt;: Set to &lt;code&gt;False&lt;/code&gt; to only create the threads, not start them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c97ff66850afc7d9c8b4c9952b647de31607693" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;start&lt;/code&gt;&lt;/b&gt;: Start value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6b05c158188a02ec636825aaec3594df3813b77" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;start&lt;/code&gt;&lt;/b&gt;: int, start of desired slice of the specified dataset</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799fd941e4057466a1214a4ce794ae5c5288936d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;start_char&lt;/code&gt;&lt;/b&gt;: The start of a sequence will be marked with this character. Set to 1 because 0 is usually the padding character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f633aaf1068472652113efe5c163bf5d767f5235" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;start_delay_secs&lt;/code&gt;&lt;/b&gt;: Int. Start evaluating after waiting for this many seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f66932a677e5f5ce8a66dfbd2ad7441fcaac9d37" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;start_name_regexes&lt;/code&gt;&lt;/b&gt;: list of node name regexes to start displaying.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ae696068208fb7db37a5928cd76810e5bb2fb1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;start_standard_services&lt;/code&gt;&lt;/b&gt;: Whether to start the standard services and the queue runners.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32a40f93436579f16047767c8f4c4707d8bbf558" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;start_standard_services&lt;/code&gt;&lt;/b&gt;: Whether to start the standard services, such as checkpoint, summary and step counter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f7cb911b8c6ec628c3aee5d85c2827582bc6eba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;starts&lt;/code&gt;&lt;/b&gt;: Vector or scalar &lt;code&gt;Tensor&lt;/code&gt;. Specifies the first entry for each range if &lt;code&gt;limits&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;; otherwise, specifies the range limits, and the first entries default to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f0cf61e4cc5443e4977e21da456449bcd99a51" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;state&lt;/code&gt;&lt;/b&gt;: A string Tensor. Result of a SerializeState of a Reader with matching type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4af7fb480729fa9b6cc5fdcf2b61006eef0faea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;state&lt;/code&gt;&lt;/b&gt;: The final state. If &lt;code&gt;cell.state_size&lt;/code&gt; is an int, this will be shaped &lt;code&gt;[batch_size, cell.state_size]&lt;/code&gt;. If it is a &lt;code&gt;TensorShape&lt;/code&gt;, this will be shaped &lt;code&gt;[batch_size] + cell.state_size&lt;/code&gt;. If it is a (possibly nested) tuple of ints or &lt;code&gt;TensorShape&lt;/code&gt;, this will be a tuple having the corresponding shapes. If cells are &lt;code&gt;LSTMCells&lt;/code&gt;&lt;code&gt;state&lt;/code&gt; will be a tuple containing a &lt;code&gt;LSTMStateTuple&lt;/code&gt; for each cell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ca4a7eb06f01a41ed7b8b7048be9943356f6ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;state&lt;/code&gt;&lt;/b&gt;: True, False or None. None restores the default behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f635e4d5ad3880ad7c1642a2255987e60e38b56c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;state&lt;/code&gt;&lt;/b&gt;: a vector of dtype STATE_TYPE representing the initial state of the RNG, whose length and semantics are algorithm-specific.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a6ea0084a6dc69ef8130106abe6e337279bd26f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;state&lt;/code&gt;&lt;/b&gt;: the new state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f620f328e39697ef2fc03eb9b28192575a1fe20f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;state_is_tuple&lt;/code&gt;&lt;/b&gt;: If True, accepted and returned states are 2-tuples of the &lt;code&gt;c_state&lt;/code&gt; and &lt;code&gt;m_state&lt;/code&gt;. If False, they are concatenated along the column axis. The latter behavior will soon be deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e234a6b95754ed9c981f43286de8ddc64f4d93e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;state_is_tuple&lt;/code&gt;&lt;/b&gt;: If True, accepted and returned states are 2-tuples of the &lt;code&gt;c_state&lt;/code&gt; and &lt;code&gt;m_state&lt;/code&gt;. If False, they are concatenated along the column axis. This latter behavior will soon be deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef6e13e7be06e636f8899b4c8203949c80632c8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;state_is_tuple&lt;/code&gt;&lt;/b&gt;: If True, accepted and returned states are n-tuples, where &lt;code&gt;n = len(cells)&lt;/code&gt;. If False, the states are all concatenated along the column axis. This latter behavior will soon be deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77227c3f67df6c677776d143f3dca013eff34f7e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;state_keep_prob&lt;/code&gt;&lt;/b&gt;: unit Tensor or float between 0 and 1, output keep probability; if it is constant and 1, no output dropout will be added. State dropout is performed on the outgoing states of the cell. &lt;strong&gt;Note&lt;/strong&gt; the state components to which dropout is applied when &lt;code&gt;state_keep_prob&lt;/code&gt; is in &lt;code&gt;(0, 1)&lt;/code&gt; are also determined by the argument &lt;code&gt;dropout_state_filter_visitor&lt;/code&gt; (e.g. by default dropout is never applied to the &lt;code&gt;c&lt;/code&gt; component of an &lt;code&gt;LSTMStateTuple&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0510da750bfddc6250f78e44ef4a5b2127025c78" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;state_name&lt;/code&gt;&lt;/b&gt;: Python string or tuple of strings. The name to use with the state_saver. If the cell returns tuples of states (i.e., &lt;code&gt;cell.state_size&lt;/code&gt; is a tuple) then &lt;code&gt;state_name&lt;/code&gt; should be a tuple of strings having the same length as &lt;code&gt;cell.state_size&lt;/code&gt;. Otherwise it should be a single string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e338d22554153b6820a254c310485994c141c7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;state_saver&lt;/code&gt;&lt;/b&gt;: A state saver object with methods &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;save_state&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dde860ef80721b929dc52ce6e83cafb8381a3ab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stateful&lt;/code&gt;&lt;/b&gt;: (Boolean.) If True, the function should be considered stateful. If a function is stateless, when given the same input it will return the same output and have no observable side effects. Optimizations such as common subexpression elimination are only performed on stateless operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="400412d505030e908eb68ac2b93db2f2d2b697b9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stateful&lt;/code&gt;&lt;/b&gt;: Boolean (default &lt;code&gt;False&lt;/code&gt;). If True, the last state for each sample at index i in a batch will be used as initial state for the sample of index i in the following batch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fbef131a904e03953fdc8f284bab876521aeebd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stateful&lt;/code&gt;&lt;/b&gt;: Boolean (default False). If True, the last state for each sample at index i in a batch will be used as initial state for the sample of index i in the following batch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8428aa48630641257f1e04185b0dbd7e0c5d677f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stateful_metrics&lt;/code&gt;&lt;/b&gt;: Iterable of string names of metrics that should &lt;em&gt;not&lt;/em&gt; be averaged over an epoch. Metrics in this list will be logged as-is in &lt;code&gt;on_epoch_end&lt;/code&gt;. All others will be averaged in &lt;code&gt;on_epoch_end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae173298e3185230426ac33b0f076f26c6d4dd2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stateful_metrics&lt;/code&gt;&lt;/b&gt;: Iterable of string names of metrics that should &lt;em&gt;not&lt;/em&gt; be averaged over an epoch. Metrics in this list will be logged as-is. All others will be averaged over time (e.g. loss, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aacdec07b8947a4758d8b4d01891a3cce69cd7e4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stateful_metrics&lt;/code&gt;&lt;/b&gt;: Iterable of string names of metrics that should &lt;em&gt;not&lt;/em&gt; be averaged over time. Metrics in this list will be displayed as-is. All others will be averaged by the progbar before display.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524bea35ffb0a5181e4f533308c85dbfb3978bc5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;states&lt;/code&gt;&lt;/b&gt;: A 2D tensor with shape of &lt;code&gt;[batch, units]&lt;/code&gt;, which is the state from the previous time step. For timestep 0, the initial state provided by user will be feed to cell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f7d1936480ddfea7f06d5898ab3f3b1d7c83cc6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;states&lt;/code&gt;&lt;/b&gt;: List of 2 tensors that corresponding to the cell's units. Both of them have shape &lt;code&gt;[batch, units]&lt;/code&gt;, the first tensor is the memory state from previous time step, the second tesnor is the carry state from previous time step. For timestep 0, the initial state provided by user will be feed to cell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8112812840d22c3b8879e1d344831524e22f1e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;states&lt;/code&gt;&lt;/b&gt;: List of state tensors corresponding to the previous timestep.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe2d00bec4d978b1b3afaadd69873b0224b1382" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stddev&lt;/code&gt;&lt;/b&gt;: A 0-D Tensor or Python value of type &lt;code&gt;dtype&lt;/code&gt;. The standard deviation of the normal distribution, before truncation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="635026d0331e4892ce3abd7c5fea3af110939ab8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stddev&lt;/code&gt;&lt;/b&gt;: A 0-D Tensor or Python value of type &lt;code&gt;dtype&lt;/code&gt;. The standard deviation of the normal distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd024fafdab329ec3596766f02bb93a8be1ba75b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stddev&lt;/code&gt;&lt;/b&gt;: A Tensor or Python value of type &lt;code&gt;dtype&lt;/code&gt;, broadcastable with &lt;code&gt;mean&lt;/code&gt;. The standard deviation of the normal distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e60cb388916eb2622a2999affc2652d9ba6e9465" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stddev&lt;/code&gt;&lt;/b&gt;: A float, standard deviation of the normal distribution to draw samples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793530eba8f4d874c2cf81735cc17dd265431ea0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stddev&lt;/code&gt;&lt;/b&gt;: Float, standard deviation of the noise distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bddc60b4bffa69146c323bbc3985bd1dffc01a25" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stddev&lt;/code&gt;&lt;/b&gt;: Floating-point &lt;code&gt;Tensor&lt;/code&gt; with shape identical to &lt;code&gt;batch_shape + event_shape&lt;/code&gt;, i.e., the same shape as &lt;code&gt;self.mean()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d4bfa546199480c25fd41ecdc81493aaab2b0b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stddev&lt;/code&gt;&lt;/b&gt;: Standard deviation of the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a826a69b5bc01cc1344bafba0d79808f10dc3ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stddev&lt;/code&gt;&lt;/b&gt;: a python scalar or a scalar tensor. Standard deviation of the random values to generate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3870e2c522364f3cf05eaa60c6907542a44c7f15" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stddev&lt;/code&gt;&lt;/b&gt;: a python scalar or a scalar tensor. Standard deviation of the random values to generate. Defaults to 0.05.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368ed1472bc409e4ac3074e689f6054ba5736daf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;step&lt;/code&gt;&lt;/b&gt;: (Optional.) The step size for the counter. Defaults to 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09599e0c9b669fd85e74d6a837299aedc518e39" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;step&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;int64&lt;/code&gt;-castable default step value, or None to unset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="081b00ef050c8bf21a56249076168b9fe9f0d7f9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;step&lt;/code&gt;&lt;/b&gt;: Difference between two successive values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018146b76cadbf9e355b605d2b4dcd111a46cf35" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;step&lt;/code&gt;&lt;/b&gt;: Explicit &lt;code&gt;int64&lt;/code&gt;-castable monotonic step value for this summary. If omitted, this defaults to &lt;a href=&quot;experimental/get_step&quot;&gt;&lt;code&gt;tf.summary.experimental.get_step()&lt;/code&gt;&lt;/a&gt;, which must not be None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97401e9bb7405f14f57f1e57bf40f2f7c5b08c1e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;step&lt;/code&gt;&lt;/b&gt;: Explicit &lt;code&gt;int64&lt;/code&gt;-castable monotonic step value for this summary. If omitted, this defaults to &lt;a href=&quot;get_step&quot;&gt;&lt;code&gt;tf.summary.experimental.get_step()&lt;/code&gt;&lt;/a&gt;, which must not be None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce5b78275c93d5d5776697fe3dac157aa81d7a49" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;step&lt;/code&gt;&lt;/b&gt;: The current step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ec7f206c0324072da35e91f9c1b0ade45687ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;step&lt;/code&gt;&lt;/b&gt;: Training step to trigger on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8830da286204021f29a32295de661245d56f02c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;step&lt;/code&gt;&lt;/b&gt;: When multiple steps of profiles are available, select which step's profile to use. If -1, use average of all available steps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3230400d0a6f52fbcc5f95cfee1cd4d9ee4b0e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;step&lt;/code&gt;&lt;/b&gt;: int, An id used to group one or more different &lt;code&gt;run_meta&lt;/code&gt; together. When profiling with the profile_xxx APIs, user can use the &lt;code&gt;step&lt;/code&gt; id in the &lt;code&gt;options&lt;/code&gt; to profile these &lt;code&gt;run_meta&lt;/code&gt; together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6c78222aa31dbe42a7390c6598df498cb85b4ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;step_fn&lt;/code&gt;&lt;/b&gt;: A function or a method with a single argument of type &lt;code&gt;StepContext&lt;/code&gt;. The function may use methods of the argument to perform computations with access to a raw session. The returned value of the &lt;code&gt;step_fn&lt;/code&gt; will be returned from &lt;code&gt;run_step_fn&lt;/code&gt;, unless a stop is requested. In that case, the next &lt;code&gt;should_stop&lt;/code&gt; call will return True. Example usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd4d665c0c98162b5192617ff2cab6c14fd3af0b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;step_function&lt;/code&gt;&lt;/b&gt;: RNN step function. Args; input; Tensor with shape &lt;code&gt;(samples, ...)&lt;/code&gt; (no time dimension), representing input for the batch of samples at a certain time step. states; List of tensors. Returns; output; Tensor with shape &lt;code&gt;(samples, output_dim)&lt;/code&gt; (no time dimension). new_states; List of tensors, same length and shapes as 'states'. The first state in the list must be the output tensor at the previous timestep.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1dfd0bfa0ebf425504909c4bbb32c78341dbf9a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;steps&lt;/code&gt;&lt;/b&gt;: Equivalent to the &lt;code&gt;steps&lt;/code&gt; arg to &lt;code&gt;estimator.evaluate&lt;/code&gt;. Number of steps for which to evaluate model. If &lt;code&gt;None&lt;/code&gt;, evaluates until &lt;code&gt;input_fn&lt;/code&gt; raises an end-of-input exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5873385681a3fd1cdb05cdc8a63ce5151663030b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;steps&lt;/code&gt;&lt;/b&gt;: Int. Positive number of steps for which to evaluate model. If &lt;code&gt;None&lt;/code&gt;, evaluates until &lt;code&gt;input_fn&lt;/code&gt; raises an end-of-input exception. See &lt;a href=&quot;../compat/v1/estimator/estimator#evaluate&quot;&gt;&lt;code&gt;Estimator.evaluate&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bfadb35d3c305ada7a0aa711b6bf0f4911ed763" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;steps&lt;/code&gt;&lt;/b&gt;: Integer or &lt;code&gt;None&lt;/code&gt;. Total number of steps (batches of samples) before declaring the evaluation round finished. Ignored with the default value of &lt;code&gt;None&lt;/code&gt;. If x is a &lt;a href=&quot;../../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; dataset and &lt;code&gt;steps&lt;/code&gt; is None, 'evaluate' will run until the dataset is exhausted. This argument is not supported with array inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10422e02305bc4ac742ac441cd43bddded63794" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;steps&lt;/code&gt;&lt;/b&gt;: Integer or &lt;code&gt;None&lt;/code&gt;. Total number of steps (batches of samples) before declaring the evaluation round finished. Ignored with the default value of &lt;code&gt;None&lt;/code&gt;. If x is a &lt;a href=&quot;../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; dataset and &lt;code&gt;steps&lt;/code&gt; is None, 'evaluate' will run until the dataset is exhausted. This argument is not supported with array inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b24a8c7f8055bcde355c59e6397840ffd00c48" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;steps&lt;/code&gt;&lt;/b&gt;: Number of steps for which to evaluate model. If &lt;code&gt;None&lt;/code&gt;, evaluates until &lt;code&gt;input_fn&lt;/code&gt; raises an end-of-input exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49022bf717641b8a705cd9963037500dc77b84f6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;steps&lt;/code&gt;&lt;/b&gt;: Number of steps for which to train the model. If &lt;code&gt;None&lt;/code&gt;, train forever or train until &lt;code&gt;input_fn&lt;/code&gt; generates the &lt;code&gt;tf.errors.OutOfRange&lt;/code&gt; error or &lt;code&gt;StopIteration&lt;/code&gt; exception. &lt;code&gt;steps&lt;/code&gt; works incrementally. If you call two times &lt;code&gt;train(steps=10)&lt;/code&gt; then training occurs in total 20 steps. If &lt;code&gt;OutOfRange&lt;/code&gt; or &lt;code&gt;StopIteration&lt;/code&gt; occurs in the middle, training stops before 20 steps. If you don't want to have incremental behavior please set &lt;code&gt;max_steps&lt;/code&gt; instead. If set, &lt;code&gt;max_steps&lt;/code&gt; must be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e3cd9d8e98c6298c9e5672ac464d246ef0a1299" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;steps&lt;/code&gt;&lt;/b&gt;: Total number of steps (batches of samples) before declaring the prediction round finished. Ignored with the default value of &lt;code&gt;None&lt;/code&gt;. If x is a &lt;a href=&quot;../../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; dataset and &lt;code&gt;steps&lt;/code&gt; is None, &lt;code&gt;predict&lt;/code&gt; will run until the input dataset is exhausted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8230d5b21d7c30c450adf9bc82e6d04cb1c48671" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;steps&lt;/code&gt;&lt;/b&gt;: Total number of steps (batches of samples) before declaring the prediction round finished. Ignored with the default value of &lt;code&gt;None&lt;/code&gt;. If x is a &lt;a href=&quot;../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; dataset and &lt;code&gt;steps&lt;/code&gt; is None, &lt;code&gt;predict&lt;/code&gt; will run until the input dataset is exhausted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="408c3af2403e0c64e9c4559d340874304560a84c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;steps_per_epoch&lt;/code&gt;&lt;/b&gt;: Integer or &lt;code&gt;None&lt;/code&gt;. Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default &lt;code&gt;None&lt;/code&gt; is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a &lt;a href=&quot;../../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. This argument is not supported with array inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90530356c02d44e6cddb74ab20781a9fde1701ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;steps_per_epoch&lt;/code&gt;&lt;/b&gt;: Integer or &lt;code&gt;None&lt;/code&gt;. Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default &lt;code&gt;None&lt;/code&gt; is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a &lt;a href=&quot;../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. This argument is not supported with array inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e13811053ad68fb53df9ec82d395e1443ee76277" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;steps_per_run&lt;/code&gt;&lt;/b&gt;: Number of steps to run on device before returning to the host. Note that this can have side-effects on performance, hooks, metrics, summaries etc. This parameter is only used when Distribution Strategy is used with estimator or keras.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc72dec425570b23b8b087c9a71d56d02ebc967a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stfts&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;complex64&lt;/code&gt;/&lt;code&gt;complex128&lt;/code&gt;&lt;code&gt;[..., frames, fft_unique_bins]&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; of STFT bins representing a batch of &lt;code&gt;fft_length&lt;/code&gt;-point STFTs where &lt;code&gt;fft_unique_bins&lt;/code&gt; is &lt;code&gt;fft_length // 2 + 1&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f600b7641bfe601a516bb72fceecb5b54e4897bb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must have the same type as &lt;code&gt;start&lt;/code&gt;. 0-D tensor. Last entry in the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="309707518a3ec9dfaf5c48703b2b28388f36fb59" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/b&gt;: Stop value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd3f54a81e17cecd2410e0eaf6ac4c62c372d7c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stop_grace_period_secs&lt;/code&gt;&lt;/b&gt;: Number of seconds given to threads to stop after &lt;code&gt;close()&lt;/code&gt; has been called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb8d9e1e872d0ecf9b08eeb441f4dfcb28dcefa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stop_grace_period_secs&lt;/code&gt;&lt;/b&gt;: Number of seconds given to threads to stop after &lt;code&gt;request_stop()&lt;/code&gt; has been called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d842f00243a08b1587de42e96fd26fbc4c255f5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stop_grace_secs&lt;/code&gt;&lt;/b&gt;: Grace period, in seconds, given to running threads to stop when &lt;code&gt;stop()&lt;/code&gt; is called. Defaults to 120 seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3641398312a6d52e56048e06aa70134d4ec1ebfa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stop_gradients&lt;/code&gt;&lt;/b&gt;: Optional. A &lt;code&gt;Tensor&lt;/code&gt; or list of tensors not to differentiate through.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b706b192c5b3a1f046428c9cfd7af215ecde44f9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;store_memory_usage&lt;/code&gt;&lt;/b&gt;: Boolean, whether to run an extra untimed iteration, calculate memory usage, and store that in extras fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbbd08c4e97b5087124026b8accae0ffe6dfbadf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;store_trace&lt;/code&gt;&lt;/b&gt;: Boolean, whether to run an extra untimed iteration and store the trace of iteration in returned extras. The trace will be stored as a string in Google Chrome trace format in the extras field &quot;full_trace_chrome_format&quot;. Note that trace will not be stored in test_log_pb2.TestResults proto.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b03d29ecb6a4d777dfa5a20ac6ee0bb9c2cd24e0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strategy&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; object or None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d99c3742341b116367517a92fbe476f9d265b1b0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stream&lt;/code&gt;&lt;/b&gt;: The stream whose writes should be captured. This stream must have a file descriptor, support writing via using that file descriptor, and must have a &lt;code&gt;.flush()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1b26fdb75b8bbf7d428b1e51d22a09af46677b3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strict&lt;/code&gt;&lt;/b&gt;: A boolean that enables/disables 'strict' mode; see above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a96cd603e50cc33069cbe06c36ee9f409164866f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stride&lt;/code&gt;&lt;/b&gt;: (Optional.) A &lt;a href=&quot;../../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the stride of the input elements in the sliding window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685958214362685274d09def71cf1693cc32e9d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stride&lt;/code&gt;&lt;/b&gt;: (Optional.) A &lt;a href=&quot;../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the stride of the input elements in the sliding window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35be8ec19bb5a98815e3b92761015ef2aeb35bfe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stride&lt;/code&gt;&lt;/b&gt;: (Optional.) A &lt;a href=&quot;../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the stride of the input elements in the sliding window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c4bbfc086df03dfb6585d1aa5e99770ece172ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stride&lt;/code&gt;&lt;/b&gt;: (Optional.) A &lt;a href=&quot;../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the stride of the input elements in the sliding window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09ae05248f2b7df066e720b2527f11b24ccbd0a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;stride&lt;/code&gt;&lt;/b&gt;: An int or list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt;. The number of entries by which the filter is moved right at each step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbbeb692409ae35bd80dd7923525fd2ef815511f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: 1-D of size 4. The stride of the sliding window for each dimension of &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="490fb3d89f5f08543eb6b8be952ea6fc9f447ece" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: 1-D of size 4. The strides for the depthwise convolution for each dimension of &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3942809da447cf69f299863b4b078590a3c38ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: A 1-D Tensor of length 4. How far the centers of two consecutive patches are in the images. Must be: &lt;code&gt;[1, stride_rows, stride_cols, 1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec25043a8b45f4acac68b1f4b6b8291565fd17f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;&amp;gt;= 4&lt;/code&gt;. 1-D of length 4. The stride of the sliding window for each dimension of the input tensor. Must be: &lt;code&gt;[1, stride_height, stride_width, 1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7f81aaa13540ae8eeef48091a9bbdb644f6e3b6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;&amp;gt;= 4&lt;/code&gt;. How far the centers of two consecutive patches are in the images. Must be: &lt;code&gt;[1, stride_rows, stride_cols, 1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d0a0d6605943914eecbc14ef864641f877a4605" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;&amp;gt;= 4&lt;/code&gt;. The stride of the sliding window for each dimension of the input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63c8b85a6d7b193975af29224f499aeb654d870" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;&amp;gt;= 4&lt;/code&gt;. The stride of the sliding window for each dimension of the input tensor. Must be: &lt;code&gt;[1, stride_height, stride_width, 1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e9c06f8daa12ee1456f3da40a70cb40db5b111c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;&amp;gt;= 5&lt;/code&gt;. 1-D of length 5. How far the centers of two consecutive patches are in &lt;code&gt;input&lt;/code&gt;. Must be: &lt;code&gt;[1, stride_planes, stride_rows, stride_cols, 1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a0823be830425c70f127d0ce18bfd8f3df7f33" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;&amp;gt;= 5&lt;/code&gt;. 1-D tensor of length 5. The stride of the sliding window for each dimension of &lt;code&gt;input&lt;/code&gt;. Must have &lt;code&gt;strides[0] = strides[4] = 1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d776a4b3bc7544b2dcc670f51ea094ee87d7e436" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt;. 1-D of length 4. The stride of the sliding window for each dimension of &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9335c9e6ef5344a8d4c83b9ac016a046433042c3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt;. The stride of the sliding window for each dimension of the input of the convolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c78bede09e60ef367405b6493e182acd35a8aec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt;. The stride of the sliding window for each dimension of the input of the convolution. Must be in the same order as the dimension specified with format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dfdb8296a99b102c4156f9b54a1ffe9da096936" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt;. The stride of the sliding window for each dimension of the input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a55342d32b7d95fc253a29b51a89aea3b8ab7c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt;. The stride of the sliding window for each dimension of the input tensor. The length must be 4 to match the number of dimensions of the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de831e635c6c488742e86a532863d36400f41e2b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: A list of ints. The stride of the sliding window for each dimension of the input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c6d47d30d444ce41fce4796fb16c55f4f64c2b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: A single integer specifying the strides of the convolution. Specifying any &lt;code&gt;stride&lt;/code&gt; value != 1 is incompatible with specifying any &lt;code&gt;dilation_rate&lt;/code&gt; value != 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96e7f0ad5d1390028535b7d07cdb4929336c846" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: A tuple or list of 2 positive integers specifying the strides of the convolution. Can be a single integer to specify the same value for all spatial dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45bf8db306af26106f9b503c3a4df9af1a8751e2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: A tuple or list of 2 positive integers specifying the strides of the convolution. Can be a single integer to specify the same value for all spatial dimensions. Specifying any &lt;code&gt;stride&lt;/code&gt; value != 1 is incompatible with specifying any &lt;code&gt;dilation_rate&lt;/code&gt; value != 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7933af7b32e1680045a474700878eb28c2c1b718" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: A tuple or list of 3 positive integers specifying the strides of the convolution. Can be a single integer to specify the same value for all spatial dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0c8691fbc52fda6e2c4175964539f44f251f57b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c4c8234112e550afc8b7da7f1e330bdd4f713b6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An int or list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt;. The number of entries by which the filter is moved right at each step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83bc0bafc013539460b512d24face05978a3f8fa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An int or list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt;. The stride of the sliding window for each dimension of the input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffef75b7f25280e9237196f74fb8f9cfdf0546bc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An int or list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt;. The stride of the sliding window for each dimension of &lt;code&gt;input&lt;/code&gt;. If a single value is given it is replicated in the &lt;code&gt;H&lt;/code&gt; and &lt;code&gt;W&lt;/code&gt; dimension. By default the &lt;code&gt;N&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; dimensions are set to 0. The dimension order is determined by the value of &lt;code&gt;data_format&lt;/code&gt;, see below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c871521c815487e757ee0d7bd3bd175e4f6bbe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An int or list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt;. The stride of the sliding window for each dimension of &lt;code&gt;input&lt;/code&gt;. If a single value is given it is replicated in the &lt;code&gt;H&lt;/code&gt; and &lt;code&gt;W&lt;/code&gt; dimension. By default the &lt;code&gt;N&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; dimensions are set to 1. The dimension order is determined by the value of &lt;code&gt;data_format&lt;/code&gt;, see below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca0c1ec54abbe812aa75634ce4cf782771bc1ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An int or list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt;. The stride of the sliding window for each dimension of the input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1bdd017d343e4b2378e3293efca8dbb5c325f9d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An int or list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; or &lt;code&gt;5&lt;/code&gt;. The stride of the sliding window for each dimension of &lt;code&gt;input&lt;/code&gt;. If a single value is given it is replicated in the &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt; and &lt;code&gt;W&lt;/code&gt; dimension. By default the &lt;code&gt;N&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; dimensions are set to 0. The dimension order is determined by the value of &lt;code&gt;data_format&lt;/code&gt;, see below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8341c74f456970e63e88422c9f1601f489e045" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An int or list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; or &lt;code&gt;5&lt;/code&gt;. The stride of the sliding window for each dimension of the input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9c2d7a3742c39735ebabc1095d9a3bbd600df75" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An int or list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt; or &lt;code&gt;N+2&lt;/code&gt;. The stride of the sliding window for each dimension of &lt;code&gt;input&lt;/code&gt;. If a single value is given it is replicated in the spatial dimensions. By default the &lt;code&gt;N&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt; dimensions are set to 0. The dimension order is determined by the value of &lt;code&gt;data_format&lt;/code&gt;, see below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7da19fd6c097009f241652d1fd7e90e8d2dcf28e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An int or list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt; or &lt;code&gt;N+2&lt;/code&gt;. The stride of the sliding window for each dimension of the input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffc5c6a28ed43284b0f8184e411065270f234490" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An integer or tuple/list of 2 integers, specifying the strides of the convolution along the height and width. Can be a single integer to specify the same value for all spatial dimensions. Specifying any stride value != 1 is incompatible with specifying any &lt;code&gt;dilation_rate&lt;/code&gt; value != 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed10d8f7c3a41953bbb52334e660664bc7621fd5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An integer or tuple/list of 2 integers, specifying the strides of the convolution along the width and height. Can be a single integer to specify the same value for all spatial dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e1c3ca26de20753f01704d4e9f5a20099f8837" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An integer or tuple/list of 2 integers, specifying the strides of the pooling operation. Can be a single integer to specify the same value for all spatial dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56dee1b0ed75be90f9089b041b7e1f8f3192d10" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An integer or tuple/list of 3 integers, specifying the strides of the convolution along each spatial dimension. Can be a single integer to specify the same value for all spatial dimensions. Specifying any stride value != 1 is incompatible with specifying any &lt;code&gt;dilation_rate&lt;/code&gt; value != 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49cb04389e52b59d1eaf8fe23ca2bd87dffd33c6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An integer or tuple/list of 3 integers, specifying the strides of the convolution along the depth, height and width. Can be a single integer to specify the same value for all spatial dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cdf1018682f55c190655e63d1d61368037519fc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An integer or tuple/list of 3 integers, specifying the strides of the convolution along the depth, height and width. Can be a single integer to specify the same value for all spatial dimensions. Specifying any stride value != 1 is incompatible with specifying any &lt;code&gt;dilation_rate&lt;/code&gt; value != 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1456efd9e5453e40ad73515afc670a79f2fee85c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An integer or tuple/list of 3 integers, specifying the strides of the pooling operation. Can be a single integer to specify the same value for all spatial dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556dd8a838e1108e293b5112e02d0cec8f233415" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An integer or tuple/list of a single integer, specifying the stride length of the convolution. Specifying any stride value != 1 is incompatible with specifying any &lt;code&gt;dilation_rate&lt;/code&gt; value != 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050ce7f3faf50da2ee2572263b434811bbdad74e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An integer or tuple/list of a single integer, specifying the strides of the pooling operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282bd1b6b41231bf8fa3008bffd0e5efd975daa9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: An integer or tuple/list of n integers, specifying the strides of the convolution. Specifying any stride value != 1 is incompatible with specifying any &lt;code&gt;dilation_rate&lt;/code&gt; value != 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="535998be7f15edf98e481358d5d2c48274c3e3f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: Integer, or None. Factor by which to downscale. E.g. 2 will halve the input. If None, it will default to &lt;code&gt;pool_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a070cd9cefb46edbb544eaa769b8b5cc59ee1e6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: Integer, tuple of 2 integers, or None. Strides values. If None, it will default to &lt;code&gt;pool_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41593aca4364c89fc0a7d8a37b6e8471d739b003" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: Optional. Sequence of N ints &amp;gt;= 1. Defaults to [1]*N. If any value of strides is &amp;gt; 1, then all values of dilation_rate must be 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872c57a83543d136458c418e8b10cdb044e33fea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: Optional. Sequence of N ints &amp;gt;= 1. Specifies the output stride. Defaults to [1]*N. If any value of strides is &amp;gt; 1, then all values of dilation_rate must be 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeb3c751af22ef85464e39a53dff849be61fea55" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: a tuple of 2 integers, specifying the strides of the convolution along the width and height.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2faa8a7072cb65261a22480ca18890f9de6c2d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: a tuple of a single integer, specifying the stride length of the convolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2d0cca82e890fce564f0b7dae2e14453a5d4111" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: stride integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be51950b51b192deebfed469f2b5483f7a28c1b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: strides tuple (length 2).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6322f3942225f0d177a36e9e6828f24415a9b4e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: strides tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70f7f7ac12916273aa82949fdb6fbc57e9b85a6f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: tuple of 2 integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9d416e634a9044dfaadcf2e238e271cd6eda2ad" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: tuple of 3 integers, or None. Strides values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6684cd5679f9590b13c405c7a00f50900ffc58" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/b&gt;: tuple of 3 integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9c5c0dc030a420d016f773d72b840a899a495d4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;string_handle&lt;/code&gt;&lt;/b&gt;: A scalar &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; of type &lt;a href=&quot;../../../../tf#string&quot;&gt;&lt;code&gt;tf.string&lt;/code&gt;&lt;/a&gt; that evaluates to a handle produced by the &lt;code&gt;Iterator.string_handle()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d3625515e049f7d9b041770b09420c8c5d3e20c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;string_tensor&lt;/code&gt;&lt;/b&gt;: A 1-D string tensor with the strings to produce.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd95295915a2eb433876e675ab6b0a510482eab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;string_tensor&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15bc6a1edff782dc15dd82a1ffa7dc99aa7fcbf7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strings&lt;/code&gt;&lt;/b&gt;: A list of strings, such as [ 'fox', 'dog' ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a47178622bb418f501c2e9a552303e5930f4962" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strip_default_attrs&lt;/code&gt;&lt;/b&gt;: Boolean. If &lt;code&gt;True&lt;/code&gt;, default-valued attributes will be removed from the &lt;code&gt;NodeDef&lt;/code&gt;s. For a detailed guide, see &lt;a href=&quot;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/saved_model/README.md#stripping-default-valued-attributes&quot;&gt;Stripping Default-Valued Attributes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28158fc366d67784ba47768fc34cf316b03759fe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;strip_default_attrs&lt;/code&gt;&lt;/b&gt;: Boolean. If &lt;code&gt;True&lt;/code&gt;, default-valued attributes will be removed from the NodeDefs. For a detailed guide, see &lt;a href=&quot;https://github.com/tensorflow/tensorflow/blob/master/tensorflow/python/saved_model/README.md#stripping-default-valued-attributes&quot;&gt;Stripping Default-Valued Attributes&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78650bb7c5ee14ef581851f215acb1a0d7c2a001" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;structure&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;tf.data.experimental.Structure&lt;/code&gt; object representing the structure of each element in the dataset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c280cb7c75fcb0b539ad10460f0e130dbcae30a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;structure&lt;/code&gt;&lt;/b&gt;: Nested structure, whose structure is given by nested lists, tuples, and dicts. Note: numpy arrays and strings are considered scalars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f4602efd47272e2154bddef300be00ca527f468" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;structure&lt;/code&gt;&lt;/b&gt;: an arbitrarily nested structure or a scalar object. Note, numpy arrays are considered scalars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5b1766bbb86a534761a95af276b2530dc15035f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;subgraph&lt;/code&gt;&lt;/b&gt;: whether to return a &lt;code&gt;pydot.Cluster&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3495763767c25dacef2ec7a12ddadf2033fa66a2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;subsequence&lt;/code&gt;&lt;/b&gt;: the list we hope will be a subsequence of container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224f181e34e49ef35e012e0dfdaa3945bfbd4042" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;subsequence&lt;/code&gt;&lt;/b&gt;: the list we hope will be an exact subsequence of container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6336d6aa0d77f8709f3de54d47c2991465c88b67" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;subset&lt;/code&gt;&lt;/b&gt;: Subset of data (&lt;code&gt;&quot;training&quot;&lt;/code&gt; or &lt;code&gt;&quot;validation&quot;&lt;/code&gt;) if validation_split is set in ImageDataGenerator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb13624b93be7f43c909b097007c3c1549a6a82" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;sum_inside_sqrt&lt;/code&gt;&lt;/b&gt;: This improves training speed. Please see &lt;code&gt;optimization_parameters.proto&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ff3a0f562f3ee2f5dbfc6ec5caefd198183b67" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;summarize&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;int&lt;/code&gt;. Defaults to &lt;code&gt;3&lt;/code&gt;. When formatting the tensors, show the first and last &lt;code&gt;summarize&lt;/code&gt; entries of each tensor dimension (recursively). If set to -1, all elements of the tensor will be shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad2b2a54a941ebb72abec58e7e197165be5e2cb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;summarize&lt;/code&gt;&lt;/b&gt;: Only print this many entries of each tensor. If None, then a maximum of 3 elements are printed per input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe38751524b07c1527cde4bba36598c6bba772a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;summarize&lt;/code&gt;&lt;/b&gt;: Print this many entries of each tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2555fa4c1c45990c0404445e8e0be94ea4825f57" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;summarize&lt;/code&gt;&lt;/b&gt;: Print this many entries of the tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181d0ab6698752d3a860640aee8990608bfbafb0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;summarize&lt;/code&gt;&lt;/b&gt;: The first and last &lt;code&gt;summarize&lt;/code&gt; elements within each dimension are recursively printed per Tensor. If None, then the first 3 and last 3 elements of each dimension are printed for each tensor. If set to -1, it will print all elements of every tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0138c78bf751e109e621d664cb67b031e708bd4a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;summary&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Summary&lt;/code&gt; protocol buffer, optionally serialized as a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d98f3b5661dcd77a457fdbe33ae4416d4eabfb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;summary&lt;/code&gt;&lt;/b&gt;: A Summary proto, or a string holding a serialized summary proto.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b9ff23f79541b5a3c61647b05dfe1971bb2f77" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;summary_description&lt;/code&gt;&lt;/b&gt;: A long description of the summary sequence. Markdown is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e6dc9d554719a809dc4ea9a9de18d27a44506f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;summary_dir&lt;/code&gt;&lt;/b&gt;: A string. Optional path to a directory where to save summaries. If None, checkpoint_dir is used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="648d9f2e5879c16f327447284e6915d7e2764514" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;summary_metadata&lt;/code&gt;&lt;/b&gt;: Optional SummaryMetadata proto (which describes which plugins may use the summary value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee9a9e994161cc17d6f0a0ca1947da5b39f5bef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;summary_name&lt;/code&gt;&lt;/b&gt;: (Optional.) If set, a scalar summary for the current queue size will be generated, using this name as part of the tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80a616d0226a296ccf7060c254473558ac8cf993" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;summary_op&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; containing the serialized &lt;code&gt;Summary&lt;/code&gt; protocol buffer or a list of &lt;code&gt;Tensor&lt;/code&gt;. They are most likely an output by TF summary methods like &lt;a href=&quot;../compat/v1/summary/scalar&quot;&gt;&lt;code&gt;tf.compat.v1.summary.scalar&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../compat/v1/summary/merge_all&quot;&gt;&lt;code&gt;tf.compat.v1.summary.merge_all&lt;/code&gt;&lt;/a&gt;. It can be passed in as one tensor; if more than one, they must be passed in as a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86200a2d81c102bc220189eea2d3cdd52a7427e0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;summary_op&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;Operation&lt;/code&gt; that returns a Summary for the event logs. Used by chief supervisors if a &lt;code&gt;logdir&lt;/code&gt; was specified. Defaults to the operation returned from summary.merge_all(). If &lt;code&gt;None&lt;/code&gt;, summaries are not computed automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5987ac66d2356d44e64f40f2f9f4c4b0040f1d66" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;summary_op&lt;/code&gt;&lt;/b&gt;: Optional op to gather all summaries. Must return a scalar string tensor containing a serialized &lt;code&gt;Summary&lt;/code&gt; proto.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="466108329e01a292696c36df236381dd46e94154" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;summary_writer&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;SummaryWriter&lt;/code&gt; to use or &lt;code&gt;USE_DEFAULT&lt;/code&gt;. Can be &lt;code&gt;None&lt;/code&gt; to indicate that no summaries should be written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1841343cf6788811ddace655dafc42640ea8c806" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;summary_writer&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;SummaryWriter&lt;/code&gt;. If &lt;code&gt;None&lt;/code&gt; and an &lt;code&gt;output_dir&lt;/code&gt; was passed, one will be created accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bafcfd61597f8ee06b5a7db28647557e722cc353" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;summation_method&lt;/code&gt;&lt;/b&gt;: (Optional) Specifies the Riemann summation method used (https://en.wikipedia.org/wiki/Riemann_sum): 'interpolation' [default], applies mid-point summation scheme for &lt;code&gt;ROC&lt;/code&gt;. For PR-AUC, interpolates (true/false) positives but not the ratio that is precision (see Davis &amp;amp; Goadrich 2006 for details); 'minoring' that applies left summation for increasing intervals and right summation for decreasing intervals; 'majoring' that does the opposite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b941f22673928a8fa66591f557e826f8112157db" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;summation_method&lt;/code&gt;&lt;/b&gt;: Specifies the Riemann summation method used (https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that applies the trapezoidal rule; 'careful_interpolation', a variant of it differing only by a more correct interpolation scheme for PR-AUC - interpolating (true/false) positives but not the ratio that is precision; 'minoring' that applies left summation for increasing intervals and right summation for decreasing intervals; 'majoring' that does the opposite. Note that 'careful_interpolation' is strictly preferred to 'trapezoidal' (to be deprecated soon) as it applies the same method for ROC, and a better one (see Davis &amp;amp; Goadrich 2006 for details) for the PR curve.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b699877ee5f96161759d4f5be657ee3a836b6bd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;supervisor&lt;/code&gt;&lt;/b&gt;: &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;tf.compat.v1.train.Supervisor&lt;/code&gt;&lt;/a&gt; to run the training services.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f5fc0b113c45f0e4716e34dc9ac4791af823da" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;supported_ops&lt;/code&gt;&lt;/b&gt;: Experimental flag, subject to change. Set of OpsSet options supported by the device. (default set([OpsSet.TFLITE_BUILTINS]))</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a848928493fbd7a6698e8a721583af7cd7ca03" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;supported_types&lt;/code&gt;&lt;/b&gt;: List of types for constant values on the target device. Supported values are types exported by lite.constants. Frequently, an optimization choice is driven by the most compact (i.e. smallest) type in this list (default [constants.FLOAT])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b005637b79c6f67cd66c38f57dbfe1b9896929" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;supports_serialize&lt;/code&gt;&lt;/b&gt;: True if the reader implementation can serialize its state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e9fb80fda8caa5e36470e69158c3ebc03666546" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;swap_memory&lt;/code&gt;&lt;/b&gt;: (optional) True enables GPU-CPU memory swapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037d773c9661f4549ccf0539c301da5fd8955e19" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;swap_memory&lt;/code&gt;&lt;/b&gt;: Transparently swap the tensors produced in forward inference but needed for back prop from GPU to CPU. This allows training RNNs which would typically not fit on a single GPU, with very minimal (or no) performance penalty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e67407ec407d16ba8dab12394c9e80d6fadf70e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;swap_memory&lt;/code&gt;&lt;/b&gt;: Whether GPU-CPU memory swap is enabled for this loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="126bf1aa11205c50dde2a95ed07449bcebc6731f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;symmetric_l1_regularization&lt;/code&gt;&lt;/b&gt;: A float value, must be greater than or equal to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67536f42b5b39f789bdc754d686ba8c46cb13191" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;symmetric_l2_regularization&lt;/code&gt;&lt;/b&gt;: A float value, must be greater than zero and should typically be greater than 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="952ac07c9bb8f4af136399ac62c52a789a1d5395" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;synchronization&lt;/code&gt;&lt;/b&gt;: Indicates when a distributed a variable will be aggregated. Accepted values are constants defined in the class &lt;a href=&quot;../../variablesynchronization&quot;&gt;&lt;code&gt;tf.VariableSynchronization&lt;/code&gt;&lt;/a&gt;. By default the synchronization is set to &lt;code&gt;AUTO&lt;/code&gt; and the current &lt;code&gt;DistributionStrategy&lt;/code&gt; chooses when to synchronize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf7eb13437c2d0f3bc94a99fb61767923bc01ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;synchronization&lt;/code&gt;&lt;/b&gt;: Indicates when a distributed a variable will be aggregated. Accepted values are constants defined in the class &lt;a href=&quot;../../variablesynchronization&quot;&gt;&lt;code&gt;tf.VariableSynchronization&lt;/code&gt;&lt;/a&gt;. By default the synchronization is set to &lt;code&gt;AUTO&lt;/code&gt; and the current &lt;code&gt;DistributionStrategy&lt;/code&gt; chooses when to synchronize. If &lt;code&gt;synchronization&lt;/code&gt; is set to &lt;code&gt;ON_READ&lt;/code&gt;, &lt;code&gt;trainable&lt;/code&gt; must not be set to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450f39e7b71360cf3e590606d4d4b81d13770d07" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;synchronization&lt;/code&gt;&lt;/b&gt;: Indicates when a distributed a variable will be aggregated. Accepted values are constants defined in the class &lt;a href=&quot;variablesynchronization&quot;&gt;&lt;code&gt;tf.VariableSynchronization&lt;/code&gt;&lt;/a&gt;. By default the synchronization is set to &lt;code&gt;AUTO&lt;/code&gt; and the current &lt;code&gt;DistributionStrategy&lt;/code&gt; chooses when to synchronize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d766657862b9c27db9c0efb1a5ff4cb6aa2f645" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;t&lt;/code&gt;&lt;/b&gt;: A 4D input Tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="669be23b7c6023a0da07720b62cbcd17370d945e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;t&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;IndexedSlices&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="986b07f6f6c3d42570a703e953eb42b9eef6faba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;t&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a2dfddf7d3d3360cf251a2aaa4b95905748f32" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;t&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;. Typically 2-D, but may have any dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d56b0776650157979a2b4c0657b113b19a0a838e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;t&lt;/code&gt;&lt;/b&gt;: Tensor to check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81e4a56f07ce4917d7abb3446ac83e792691a20" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;t_list&lt;/code&gt;&lt;/b&gt;: A tuple or list of mixed &lt;code&gt;Tensors&lt;/code&gt;, &lt;code&gt;IndexedSlices&lt;/code&gt;, or None.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
