<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="efe8535805cc99b8dadefa6965a39db17d4d3041" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph&lt;/code&gt;&lt;/b&gt;: Optional graph to use during the returned session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45238f05a2eceb88b5cbaa5c1d23e9f086363381" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph&lt;/code&gt;&lt;/b&gt;: The &lt;code&gt;Graph&lt;/code&gt; that the model will use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="321f8f4ea8421c5ce32eed49c069a493e14b844a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph&lt;/code&gt;&lt;/b&gt;: The &lt;code&gt;Graph&lt;/code&gt; to export. If &lt;code&gt;None&lt;/code&gt;, use the default graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b190758fb158ec6cd07c4fbf79609780af031ff8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph&lt;/code&gt;&lt;/b&gt;: The graph in which to create the global step tensor. If missing, use default graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="223a031234d6af1194e8fdaf25f09263902f8cc2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph&lt;/code&gt;&lt;/b&gt;: The graph to find the global step in. If missing, use default graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44f4f61de8e117cc592be89f1e3ec1fe32a3acd1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph&lt;/code&gt;&lt;/b&gt;: The tf.Graph in which tensors are looked up. If None, the current default graph is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dacebb9fdbc7b89518147ffc1ad0caab3abf056" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph&lt;/code&gt;&lt;/b&gt;: tf.Graph. If None and eager execution is not enabled, use default graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="558222102a816d933f1ce566708c103bc8e7a8ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph_def&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;GraphDef&lt;/code&gt; protocol buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea153c92aa5b34f1ec0c86862d6212bab5491f1e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph_def&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;GraphDef&lt;/code&gt; proto containing operations to be imported into the default graph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2996c5dfacdd5dacc71ffe14ba951e93960297ee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph_def&lt;/code&gt;&lt;/b&gt;: A graph def that we should convert.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74629b60a10a6c6f0609800569db4da837646753" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph_def&lt;/code&gt;&lt;/b&gt;: A graph_pb2.GraphDef proto.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ebb786bace2b9a18a59c9f50c8eae439745dc49" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph_def&lt;/code&gt;&lt;/b&gt;: An object of type graph_pb2.GraphDef or a textual proto representation of a valid GraphDef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9c4c7fe042ca29328b28ac3d3ed214fb58ce07e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph_def&lt;/code&gt;&lt;/b&gt;: DEPRECATED. Use the &lt;code&gt;graph&lt;/code&gt; parameter instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8b24c163bd41a1d29e4382e6104626be0d66a9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph_def&lt;/code&gt;&lt;/b&gt;: DEPRECATED: Use the &lt;code&gt;graph&lt;/code&gt; argument instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa3bbf968a25e9a7f22c6cf83ef255e0aef7292" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph_def&lt;/code&gt;&lt;/b&gt;: Frozen TensorFlow GraphDef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03fa80248dc80ff99659250aae78c5d2cf3a3ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph_def_file&lt;/code&gt;&lt;/b&gt;: Full filepath of file containing frozen GraphDef.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1afd9d03627b3473a53082d6fd79c0abf486eaf1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph_or_graph_def&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Graph&lt;/code&gt; or a &lt;code&gt;GraphDef&lt;/code&gt; protocol buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfeb55ca7e2edc0e6d4436b1afd2f143597f2f73" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph_parents&lt;/code&gt;&lt;/b&gt;: (Deprecated) Python list of graph prerequisites of this &lt;code&gt;LinearOperator&lt;/code&gt; Typically tensors that are passed during initialization</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7655c2157bf680479b81478e438f6c95536218d2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;graph_parents&lt;/code&gt;&lt;/b&gt;: Python &lt;code&gt;list&lt;/code&gt; of graph prerequisites of this &lt;code&gt;Distribution&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fa96b0f1575ea258cab64ada069089d584e27a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;greedy&lt;/code&gt;&lt;/b&gt;: perform much faster best-path search if &lt;code&gt;true&lt;/code&gt;. This does not use a dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab1ceef802c9a87e0ea11735948449bd9d5979a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;group&lt;/code&gt;&lt;/b&gt;: Boolean. Defaults to True. If False, the return value will be unwrapped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5fc8bf1b7069368c8b5f8125e9f054e64d8ec5d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;group_assignment&lt;/code&gt;&lt;/b&gt;: Optional 2d int32 lists with shape [num_groups, num_replicas_per_group] which describles how to apply optimizer to subgroups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4166e5619bc0fde46681f09a88696e565950ef3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;group_assignment&lt;/code&gt;&lt;/b&gt;: Optional 2d int32 lists with shape [num_groups, num_replicas_per_group]. &lt;code&gt;group_assignment[i]&lt;/code&gt; represents the replica ids in the ith subgroup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d57a140928c8fbe5cccdac562df9585cb7065f3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;half_atol&lt;/code&gt;&lt;/b&gt;: absolute tolerance for float16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a568c4a4c2c58c603e61b32a60cb5cf13c852be" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;half_rtol&lt;/code&gt;&lt;/b&gt;: relative tolerance for float16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75277ca104063c129a26f7ce6cd25db11752073a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;handle&lt;/code&gt;&lt;/b&gt;: (optional) A &lt;code&gt;Tensor&lt;/code&gt; handle to an existing TensorArray. If this is set, tensor_array_name should be None. Only supported in graph mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7ee4904d3e91a53f090a51801f5c99bea83499" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;handle&lt;/code&gt;&lt;/b&gt;: A handle for a sequence of partial runs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8efb2743d0829622b928cab328b8efa05059bdb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;handle&lt;/code&gt;&lt;/b&gt;: The string representation of a persistent tensor handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f4c21ef41b7b09c52dde4194fac7baa4803ddac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;hash_algorithm&lt;/code&gt;&lt;/b&gt;: Select the hash algorithm to verify the file. options are 'md5', 'sha256', and 'auto'. The default 'auto' detects the hash algorithm in use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="066332b73415b9f111b0e438c44805462a2d8830" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;hash_bucket_size&lt;/code&gt;&lt;/b&gt;: An int &amp;gt; 1. The number of buckets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c16ee4aa8559ee7883b4f8a10c96958068f676a9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;hash_key&lt;/code&gt;&lt;/b&gt;: Integer hash_key that will be used by the &lt;code&gt;FingerprintCat64&lt;/code&gt; function. If not given, will use a default key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbfd44eb59f5b05e30abe510e688b58968a29601" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;hash_key&lt;/code&gt;&lt;/b&gt;: Specify the hash_key that will be used by the &lt;code&gt;FingerprintCat64&lt;/code&gt; function to combine the crosses fingerprints on SparseCrossOp (optional).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed66b3d33564a845fc0fe211bf5129e9452fac06" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;hash_table_shared_name&lt;/code&gt;&lt;/b&gt;: boolean determining whether to ignore randomized shared_names that appear in HashTableV2 op defs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4e4e6f9de199663c096f847685a2acf4cd8e4d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;head&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Head&lt;/code&gt; instance constructed with a method such as &lt;a href=&quot;multilabelhead&quot;&gt;&lt;code&gt;tf.estimator.MultiLabelHead&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="989e217d89f9b89c4225e229876d3f7bccdd91b9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;head&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Head&lt;/code&gt; instance. This specifies the model's output and loss function to be optimized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec0f60d796e41556adfa6381e685ab2fcedd162" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;head&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;_Head&lt;/code&gt; instance constructed with a method such as &lt;code&gt;tf.contrib.estimator.multi_label_head&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6385a878317b948442e5a8f272f35137ed1633a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;head&lt;/code&gt;&lt;/b&gt;: the &lt;code&gt;Head&lt;/code&gt; instance defined for Estimator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d72e42fd5d35a626cd965d818ec2e733909f703e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;head_weights&lt;/code&gt;&lt;/b&gt;: Optional list of weights, same length as &lt;code&gt;heads&lt;/code&gt;. Used when merging losses to calculate the weighted sum of losses from each head. If &lt;code&gt;None&lt;/code&gt;, all losses are weighted equally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="affd3e88ee944e441ccc251c560c436fbaac01f4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;header&lt;/code&gt;&lt;/b&gt;: (Optional.) A &lt;a href=&quot;../../../../../tf#bool&quot;&gt;&lt;code&gt;tf.bool&lt;/code&gt;&lt;/a&gt; scalar indicating whether the CSV file(s) have header line(s) that should be skipped when parsing. Defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db97ce928da13deaa4baab565fd39aacc75519cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;header&lt;/code&gt;&lt;/b&gt;: (Optional.) A &lt;a href=&quot;../../../tf#bool&quot;&gt;&lt;code&gt;tf.bool&lt;/code&gt;&lt;/a&gt; scalar indicating whether the CSV file(s) have header line(s) that should be skipped when parsing. Defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2c16b96fa360527829f7d086f6e31a16b122b7a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;header&lt;/code&gt;&lt;/b&gt;: A bool that indicates whether the first rows of provided CSV files correspond to header lines with column names, and should not be included in the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e823ec79f01ecc9c2ea6db6780ed27937069b9b5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;header_bytes&lt;/code&gt;&lt;/b&gt;: (Optional.) A &lt;a href=&quot;../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar representing the number of bytes to skip at the start of a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b50c1b7194e13d3b72214ea2d0041da5e61759ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;header_bytes&lt;/code&gt;&lt;/b&gt;: (Optional.) A &lt;a href=&quot;../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar representing the number of bytes to skip at the start of a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b16535bae17a79ffc7577f84c57568984fb269f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;header_bytes&lt;/code&gt;&lt;/b&gt;: An optional int. Defaults to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2de4aea5b65e59c0ce23afc19268793c5398d3d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;headers&lt;/code&gt;&lt;/b&gt;: Dictionary; optional custom HTTP headers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28468eb6a07aba1e8ae13af5191ab54c142cff9c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;heads&lt;/code&gt;&lt;/b&gt;: List or tuple of &lt;code&gt;Head&lt;/code&gt; instances. All heads must have &lt;code&gt;name&lt;/code&gt; specified. The first head in the list is the default used at serving time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d8f06d189af3f5f7dbaceafeda83c78ce65e2c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;height_factor&lt;/code&gt;&lt;/b&gt;: Positive integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02ef81f38030d1ec4a6e442b099a6b0b92641cce" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;height_shift_range&lt;/code&gt;&lt;/b&gt;: Float, 1-D array-like or int</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a921c6d7060e01235e1008562d88e9f95a12f1e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;help&lt;/code&gt;&lt;/b&gt;: str, the help message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="244f400646c52d22d978bde6643df0a36c4d0b6a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;hidden_units&lt;/code&gt;&lt;/b&gt;: Iterable of integer number of hidden units per layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9642a405b0e0710312cbeece7a1e06667163360" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;hidden_units&lt;/code&gt;&lt;/b&gt;: Iterable of number hidden units per layer. All layers are fully connected. Ex. &lt;code&gt;[64, 32]&lt;/code&gt; means first layer has 64 nodes and second one has 32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="864bbeab0cccf24699c7a8126a78731b306c026f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;hide_name_regexes&lt;/code&gt;&lt;/b&gt;: list of node_names regexes that should be hidden.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="094b0ea3450afdbf7b73c79c116098d842a6de97" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;high&lt;/code&gt;&lt;/b&gt;: Float, upper boundary of the output interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dcb07d176a87e02f1d885c10f8d804ccff96d23" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;high&lt;/code&gt;&lt;/b&gt;: Floating point tensor, upper boundary of the output interval. Must have &lt;code&gt;low &amp;lt; high&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3c99f22cec922b686ba9fe591566070f5973b5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;histogram_freq&lt;/code&gt;&lt;/b&gt;: frequency (in epochs) at which to compute activation and weight histograms for the layers of the model. If set to 0, histograms won't be computed. Validation data (or split) must be specified for histogram visualizations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21adff74cf1be382243594dcb22c9a6edffaa87a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;history&lt;/code&gt;&lt;/b&gt;: object details about the training history at each epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1a9feda046085a66c98ddb32749e49c712a6913" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;hooks&lt;/code&gt;&lt;/b&gt;: An iterable of `SessionRunHook' objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9068e0e1d7274ce4d29f70ca373a3273afba7270" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;hooks&lt;/code&gt;&lt;/b&gt;: Equivalent to the &lt;code&gt;hooks&lt;/code&gt; arg to &lt;code&gt;estimator.evaluate&lt;/code&gt;. List of &lt;code&gt;SessionRunHook&lt;/code&gt; subclass instances. Used for callbacks inside the evaluation call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f6403616538127caba90f550b8e1c76e62e447" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;hooks&lt;/code&gt;&lt;/b&gt;: Iterable of &lt;code&gt;tf.train.SessionRunHook&lt;/code&gt; objects to run during evaluation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5240aafea677d90f0a29d62eaa02927f80d5d7cb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;hooks&lt;/code&gt;&lt;/b&gt;: Iterable of &lt;code&gt;tf.train.SessionRunHook&lt;/code&gt; objects to run on all workers (including chief) during training.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd67df199f0c072b6c2ca55e39fc1763b48241b5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;hooks&lt;/code&gt;&lt;/b&gt;: List of &lt;code&gt;tf.train.SessionRunHook&lt;/code&gt; subclass instances. Used for callbacks inside the evaluation call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26d5ee51f5043cf5bcc23dcd2ccded398951b4c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;hooks&lt;/code&gt;&lt;/b&gt;: List of &lt;code&gt;tf.train.SessionRunHook&lt;/code&gt; subclass instances. Used for callbacks inside the prediction call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe25109c88884a14b73533309d0218fb76c864f2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;hooks&lt;/code&gt;&lt;/b&gt;: List of &lt;code&gt;tf.train.SessionRunHook&lt;/code&gt; subclass instances. Used for callbacks inside the training loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e12ec5c221e378c06497b922bf115170f76e74d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;hooks&lt;/code&gt;&lt;/b&gt;: Optional list of &lt;code&gt;SessionRunHook&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a33c29141bb6668cc2e31679ebcd29ed420e90dd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;hop_bytes&lt;/code&gt;&lt;/b&gt;: An optional int. Defaults to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee7ae240d4cf4cf61884b0bc398c49cc69d03d7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;horizontal_flip&lt;/code&gt;&lt;/b&gt;: Boolean. Randomly flip inputs horizontally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29067f38216a6b85b45768dcc1f60947ef69407" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;hypothesis&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;SparseTensor&lt;/code&gt; containing hypothesis sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb50b9a9eafa38c085ec6689964c8c94ef12f35" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;identifier&lt;/code&gt;&lt;/b&gt;: Function or string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="869b89e4429571d5baaa710bc9ffc5ec99cfc16d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;identifier&lt;/code&gt;&lt;/b&gt;: Optimizer identifier, one of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be0be0f5d0e2029426597a95385f857703bda667" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ids&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;int64&lt;/code&gt; and shape &lt;code&gt;[num_accidental_hits]&lt;/code&gt;. Values indicate positions in &lt;code&gt;sampled_candidates&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03a1c4e6dafae31961a0a07fe6fe4a8555beefb7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ids&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; or a 'RaggedTensor' with type &lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt; containing the ids to be looked up in &lt;code&gt;params&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff6d0f84cb7757b14bb2d1eabc6cd5ccd03cb224" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ids&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; with type &lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt; containing the ids to be looked up in &lt;code&gt;params&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a4b499fa3c8c35d84f3fc3c7adb756fb0fe74dd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;idx&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;out_idx&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5db5ace5ccd2639b738f84311cccd5da30d8beb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ignore_errors&lt;/code&gt;&lt;/b&gt;: (Optional.) If &lt;code&gt;True&lt;/code&gt;, ignores errors with CSV file parsing, such as malformed data or empty lines, and moves on to the next valid CSV record. Otherwise, the dataset raises an error and stops processing when encountering any invalid records. Defaults to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6014952a50b431b4080fa5fa2fb556bc42a129b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ignore_existing&lt;/code&gt;&lt;/b&gt;: If true, only applies colocation of this op within the context, rather than applying all colocation properties on the stack. If &lt;code&gt;op&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, this value must be &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f693336d140517bdb683d54d5925ab4fda3641c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ignore_live_threads&lt;/code&gt;&lt;/b&gt;: If &lt;code&gt;False&lt;/code&gt;, raises an error if any of the threads are still alive after &lt;code&gt;stop_grace_period_secs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71c663e4f4691aa2c8ca296531ecc64a859b53a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ignore_live_threads&lt;/code&gt;&lt;/b&gt;: If &lt;code&gt;True&lt;/code&gt; ignores threads that remain running after a grace period when joining threads via the coordinator, instead of raising a RuntimeError.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db7adb1ac2e787dfd4e14fe65ec046205049ef5f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ignore_longer_outputs_than_inputs&lt;/code&gt;&lt;/b&gt;: Boolean. Default: False. If True, sequences with longer outputs than inputs will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="350695f59cfee73016f0c59986667e1a06eb870a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;imag&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must have the same type as &lt;code&gt;real&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb3ac04a699ee74e9d40e285c18efc050d4d0269" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;image&lt;/code&gt;&lt;/b&gt;: 3D image. Size of the last dimension must be 1 or 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3493f4f6b3df476f7e49f4c6fabd7e254666575b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;image&lt;/code&gt;&lt;/b&gt;: 3D image. Size of the last dimension must be None, 1 or 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b95d3438ca05dd6c4d4e55fd2f6bed88d4067729" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;image&lt;/code&gt;&lt;/b&gt;: 4-D Tensor of shape &lt;code&gt;[batch, height, width, channels]&lt;/code&gt; or 3-D Tensor of shape &lt;code&gt;[height, width, channels]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aed655f640425bf5c3e47ef8be0651048930834a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;image&lt;/code&gt;&lt;/b&gt;: A 4-D tensor of shape &lt;code&gt;[batch, image_height, image_width, depth]&lt;/code&gt;. Both &lt;code&gt;image_height&lt;/code&gt; and &lt;code&gt;image_width&lt;/code&gt; need to be positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57bc84439d5e797b223d40a95ad9a2a1a4e6c249" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;image&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;uint8&lt;/code&gt;. 3-D with shape &lt;code&gt;[height, width, channels]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca6ca9bb70be6292e8a0c59eae42eb91576260b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;image&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;. A 4-D tensor of shape &lt;code&gt;[batch, image_height, image_width, depth]&lt;/code&gt;. Both &lt;code&gt;image_height&lt;/code&gt; and &lt;code&gt;image_width&lt;/code&gt; need to be positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="842c93d707e2b5d1511ad09f01c98a7bfd66edab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;image&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;. 3-D with shape &lt;code&gt;[height, width, channels]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bff92ed5a9f0d8a9b431f201f0d3c5609b80c480" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;image&lt;/code&gt;&lt;/b&gt;: An image or images to adjust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a69fe56415655cea4d6b902e60d6526c8a746574" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;image&lt;/code&gt;&lt;/b&gt;: An image tensor with 3 or more dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f809ab2b5610afd21fdbb7f6cbb423dd44624541" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;image&lt;/code&gt;&lt;/b&gt;: An image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="902b7355ee4486ae456515f9293432aec2faa87b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;image&lt;/code&gt;&lt;/b&gt;: An n-D Tensor with at least 3 dimensions, the last 3 of which are the dimensions of each image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a93600d8f7f190a7628b30ba8fe09d9382a828e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;image&lt;/code&gt;&lt;/b&gt;: Either a 3-D float Tensor of shape [height, width, depth], or a 4-D Tensor of shape [batch_size, height, width, depth].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785e9634a6c809393fb186cea9f92c7ab3f00e7d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;image&lt;/code&gt;&lt;/b&gt;: Image tensor with shape [batch_size, h, w, d] and type float32 or float64. The image(s) must be 2x2 or larger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77c24b41c53c8cb69e5f0048dac5b1675e54d9d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;image&lt;/code&gt;&lt;/b&gt;: RGB image or images to adjust.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c83c1e7b821eeed9a0c4425803b7e598be9afa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;image&lt;/code&gt;&lt;/b&gt;: RGB image or images. Size of the last dimension must be 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44fcdb598281e67c1a8432096fc8db950a2aa3c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;image&lt;/code&gt;&lt;/b&gt;: Tensor with shape [batch_size, h, w, d].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f09e4aec11bd683d8a11f70da9bd8821d0096fd8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;image_data_generator&lt;/code&gt;&lt;/b&gt;: Instance of &lt;code&gt;ImageDataGenerator&lt;/code&gt; to use for random transformations and normalization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a20d645422adcb5f99f39b6de7f2a32cc9d1e2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;image_size&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. 1-D, containing &lt;code&gt;[height, width, channels]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeddc2181ab13af7ba695f15d656ffe4cee69b0d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;images&lt;/code&gt;&lt;/b&gt;: 2-D or higher rank. Image data to convert. Last dimension must be size 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9227998520d021b004d89de00c826a0e5568b206" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;images&lt;/code&gt;&lt;/b&gt;: 4-D Tensor of shape &lt;code&gt;[batch, height, width, channels]&lt;/code&gt; or 3-D Tensor of shape &lt;code&gt;[height, width, channels]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7435446c13d7c9278ceeed1eefe03e047e3439e9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;images&lt;/code&gt;&lt;/b&gt;: A 4-D Tensor with shape `[batch, in_rows, in_cols, depth]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3bfe4eac04bbe18f3367a8e274cf98de9542c31" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;images&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;. 4-D Tensor with shape &lt;code&gt;[batch, in_rows, in_cols, depth]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c89a3504630166cc40f862c0ddb2f97bd7c3d9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;images&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;. 4-D with shape &lt;code&gt;[batch, height, width, depth]&lt;/code&gt;. A batch of images.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8bc3397bde4befc1ec5610a92843258e27f8da9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;images&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;. 1-D or higher rank. HSV data to convert. Last dimension must be size 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccacaf0dc53f3f6ec8c285593900fc8f6ca20036" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;images&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;. 1-D or higher rank. RGB data to convert. Last dimension must be size 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d082e89f3784afd9db0702c5d0d4cbc6b617cb1d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;images&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;. 4-D with shape &lt;code&gt;[batch, height, width, channels]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e94b812c0ec386ab1082f8f10cf9e312952f0989" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;images&lt;/code&gt;&lt;/b&gt;: Images to adjust. At least 3-D.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8b41d4f318bb00429338fb2248bb177755d3b7e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;images&lt;/code&gt;&lt;/b&gt;: The Grayscale tensor to convert. Last dimension must be size 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256aaab780e208d4e8d5b0ce821ddbaf019475d4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;images&lt;/code&gt;&lt;/b&gt;: The RGB tensor to convert. Last dimension must have size 3 and should contain RGB values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e48668ecb0706fdceb718189d88b64c7ac92ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;images&lt;/code&gt;&lt;/b&gt;: tensor with the same shape as &lt;code&gt;images&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2752fb7f8f4eb82bbfb7bbe825090561a0ca86f6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;img1&lt;/code&gt;&lt;/b&gt;: First image batch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abaf8abf089af94485757899201a6d3eaf492cf4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;img2&lt;/code&gt;&lt;/b&gt;: Second image batch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf82c54c34a04de8cd6f2f5a43075c3ee0dd0a1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;img2&lt;/code&gt;&lt;/b&gt;: Second image batch. Must have the same rank as img1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb1ca0ed2d76821ca1f2b197e4d5974a05c47e39" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;img&lt;/code&gt;&lt;/b&gt;: PIL Image instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3ca872312267f4bbbb7a575c496efd49102df08" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;implementation&lt;/code&gt;&lt;/b&gt;: Implementation mode, either 1 or 2. Mode 1 will structure its operations as a larger number of smaller dot products and additions, whereas mode 2 (default) will batch them into fewer, larger operations. These modes will have different performance profiles on different hardware and for different applications. Default: 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6909331b9927c23f65a046b546d9d3c6cce188d8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;implementation&lt;/code&gt;&lt;/b&gt;: Implementation mode, either 1 or 2. Mode 1 will structure its operations as a larger number of smaller dot products and additions, whereas mode 2 will batch them into fewer, larger operations. These modes will have different performance profiles on different hardware and for different applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94153a3902073ce84410b00c95c4710e63e77f5c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;implementation&lt;/code&gt;&lt;/b&gt;: Implementation mode, either 1 or 2. Mode 1 will structure its operations as a larger number of smaller dot products and additions, whereas mode 2 will batch them into fewer, larger operations. These modes will have different performance profiles on different hardware and for different applications. Default: 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8579e176beb34d94c22ea1887bcfbc34704dcc6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;implementation&lt;/code&gt;&lt;/b&gt;: implementation mode, either &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, or &lt;code&gt;3&lt;/code&gt;. &lt;code&gt;1&lt;/code&gt; loops over input spatial locations to perform the forward pass. It is memory-efficient but performs a lot of (small) ops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0e9dd27262ea55ca1d6bfe182b9fa1d0ef81a44" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;import_scope&lt;/code&gt;&lt;/b&gt;: If not None, names in &lt;code&gt;tensor_info&lt;/code&gt; are prefixed with this string before lookup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eddfa11fd920576a5fbc6bd32aee636163b210f8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;import_scope&lt;/code&gt;&lt;/b&gt;: Optional &lt;code&gt;string&lt;/code&gt; -- if specified, prepend this string followed by '/' to all loaded tensor names. This scope is applied to tensor instances loaded into the passed session, but it is &lt;em&gt;not&lt;/em&gt; written through to the static &lt;code&gt;MetaGraphDef&lt;/code&gt; protocol buffer that is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42a92f40302642bd523cd2ee20859948ab6c84ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;import_scope&lt;/code&gt;&lt;/b&gt;: Optional &lt;code&gt;string&lt;/code&gt;. Name scope to add to the &lt;code&gt;Variable.&lt;/code&gt; Only used when initializing from protocol buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="190d61a7756eeb09f71418ac3a0a499988039855" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;import_scope&lt;/code&gt;&lt;/b&gt;: Optional &lt;code&gt;string&lt;/code&gt;. Name scope to add. Only used when initializing from protocol buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8eddea35bd48f606623a0afeb986335d25bd3d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;import_scope&lt;/code&gt;&lt;/b&gt;: Optional &lt;code&gt;string&lt;/code&gt;. Name scope to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa6d93f369c60e4d1cf0edce0855073b845306a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;in_order&lt;/code&gt;&lt;/b&gt;: bool, Traverse in order if True, post order if False. Errors that happen while listing directories are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14f9dfd3bcbbcdd23e115735fc6a41f471fa4f11" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;include_batch_in_index&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;bool&lt;/code&gt;. Defaults to &lt;code&gt;False&lt;/code&gt;. Whether to include batch dimension in flattened index of &lt;code&gt;argmax&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a54a5338684012290f61e882253f0e3c859e313c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;include_batch_in_index&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;boolean&lt;/code&gt;. Defaults to &lt;code&gt;False&lt;/code&gt;. Whether to include batch dimension in flattened index of &lt;code&gt;argmax&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361ed5c58fa5b6a5f2b8dd09ca7b36870edec901" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;include_optimizer&lt;/code&gt;&lt;/b&gt;: If True, save optimizer's state together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb3690981ad25cc98426cfaff05b6390025fdbd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;include_special_flags&lt;/code&gt;&lt;/b&gt;: bool, whether to include description of SPECIAL_FLAGS, i.e. --flagfile and --undefok.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3557d7cd023774fcc48b72241198cac825caffae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;increment&lt;/code&gt;&lt;/b&gt;: A tensor of same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ccc6d547a6cf3d563b1baabb27c1e11739451b6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;increment_period&lt;/code&gt;&lt;/b&gt;: Increases loss scale every &lt;code&gt;increment_period&lt;/code&gt; consecutive steps that finite gradients are encountered. If a nonfinite gradient is encountered, the count is reset back to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1977b87126cc3ee9941b6faa3a029956a91be8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indent&lt;/code&gt;&lt;/b&gt;: str, indent for all but first line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fcac3285121d16212491c133692b3f48291c408" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indentation&lt;/code&gt;&lt;/b&gt;: Deprecated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b038a9209a4715dff80d83fc4b808da0142f77e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;index&lt;/code&gt;&lt;/b&gt;: 0-D. int32 tensor with the index to read from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9162d4b155ec372d668b1a078471688e2295813e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;index&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the worker index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df022eb2bd26c71d632b2ac698e00322917caa72" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;index&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the worker index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8ce53e87560f7f71e18eeab31b4252629a745f9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;index&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the worker index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5079047332e772d209c28eac0e8e1887ec877f5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;index&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, representing the worker index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19fe7643209318ca05c25d4913fce9caa8d90c5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;index&lt;/code&gt;&lt;/b&gt;: An integer index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43227c0d3539f693d62ec841d132b5f1f1a116d9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;index&lt;/code&gt;&lt;/b&gt;: An integer scalar tensor that determines the input that gets selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da438248415d904eabe3bf2efebda4d924cc584" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;index&lt;/code&gt;&lt;/b&gt;: Integer, index of layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f091dc7b587971f310645124a9cb2a62dab9fd3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;index&lt;/code&gt;&lt;/b&gt;: position of the batch in the Sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c0346c2c1ddbc49ff69f5c232046db99f6de7d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;index_from&lt;/code&gt;&lt;/b&gt;: index actual words with this index and higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e391287d4e85123b3e8fd96b061f083c2e9b5688" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;index_key&lt;/code&gt;&lt;/b&gt;: A single string name or a list of string names of index features. For each key the underlying feature's type must be &lt;code&gt;int64&lt;/code&gt; and its length must always match that of the &lt;code&gt;value_key&lt;/code&gt; feature. To represent &lt;code&gt;SparseTensor&lt;/code&gt;s with a &lt;code&gt;dense_shape&lt;/code&gt; of &lt;code&gt;rank&lt;/code&gt; higher than 1 a list of length &lt;code&gt;rank&lt;/code&gt; should be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfffb1b68b669c89dd6b9584506c87ed8239571e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;index_override&lt;/code&gt;&lt;/b&gt;: Specify what input/output index should this be in the final stub. i.e. add(arg0, index=1); add(arg1, index=0) will make the final stub be as stub_func(inputs[arg1, arg0], outputs=[]) rather than the default call order based ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3324a17e2958c497e74c97a5011e1e276baeafa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/b&gt;: A 1-D &lt;code&gt;Tensor&lt;/code&gt; with indices into &lt;code&gt;data&lt;/code&gt;. Has same rank as &lt;code&gt;segment_ids&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428e2dc7b58ca9e7796b6d0f0cdcedb74420a2ad" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/b&gt;: A 2-D int64 tensor of shape &lt;code&gt;[N, ndims]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c008a7e94f9fe9a40921bfca5a92a664cc0a8e4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;1-D&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; taking values in &lt;code&gt;[0, max_value)&lt;/code&gt;. If the &lt;code&gt;TensorArray&lt;/code&gt; is not dynamic, &lt;code&gt;max_value=size()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cb7374dcebb0df337402ec0f15750cbfa22ab7a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7aed957762c6480a9591f4b1d8b09f44ae2d3ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;int32&lt;/code&gt; and shape &lt;code&gt;[num_accidental_hits]&lt;/code&gt;. Values indicate rows in &lt;code&gt;true_classes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865c686bbf5c343f77ae939e580f01e59d83c58d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. A tensor of indices into ref.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba3d08e3c93bba8d21ba9fe9f5895cfe9a61e22" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. A tensor of indices into the first dimension of &lt;code&gt;ref&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="778fe4431fe80929e23b70e7a01a58913bc86b22" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. An 0-D or 1-D &lt;code&gt;int&lt;/code&gt; Tensor whose elements are indices into the flattened version of an array of dimensions dims.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b99370099b4fad780e7561cf390a0341c8015c7f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. Index tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="671c4d45a6825acbb87425932fa9674264ca5870" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/b&gt;: A list of at least 1 &lt;code&gt;Tensor&lt;/code&gt; objects with type &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6eb5fafaf34935f06c1933a4268958ceb0edeec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/b&gt;: An integer tensor of indices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4634c1eec0bd53c4db279e9492e6a8526fe9ff8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/b&gt;: Tensor containing indices as described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6805cab2f97cb21360a953087dbbccdf62425900" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/b&gt;: The index &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;. Must be in range &lt;code&gt;[0, params.shape[axis])&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01b31dc5e7f08f61088d7a1c362d5b52891288c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/b&gt;: The indices of &lt;code&gt;values&lt;/code&gt; within the last dimension of &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05fce196e3477cf60bc97a3f2c3c5df9268ad25" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/b&gt;: The indices to be used in the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="156450b611b0c4dba10a5db0b286e0bd696d5568" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/b&gt;: nD integer tensor of shape &lt;code&gt;(batch_size, dim1, dim2, ... dim(n-1))&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfa679820343ba3b39a36ef7be9a4627b3b61bab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indices_dtype&lt;/code&gt;&lt;/b&gt;: &lt;a href=&quot;dtypes/dtype&quot;&gt;&lt;code&gt;tf.DType&lt;/code&gt;&lt;/a&gt; of the &lt;code&gt;indices&lt;/code&gt; in the &lt;code&gt;IndexedSlices&lt;/code&gt;. One of &lt;a href=&quot;../tf#int32&quot;&gt;&lt;code&gt;tf.int32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad03ffe10d5569e5f9064d4c21c0ea37c729f63a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;indices_shape&lt;/code&gt;&lt;/b&gt;: The shape of the &lt;code&gt;indices&lt;/code&gt; component, which indicates how many slices are in the &lt;code&gt;IndexedSlices&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ca3838dd441440fe285ae20d2c014052a2777a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;infeed_queue&lt;/code&gt;&lt;/b&gt;: If not &lt;code&gt;None&lt;/code&gt;, the &lt;code&gt;InfeedQueue&lt;/code&gt; from which to append a tuple of arguments as inputs to &lt;code&gt;computation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16f7c538af30a6ef30ab0c8cee13729b23d15115" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;infeed_queue&lt;/code&gt;&lt;/b&gt;: If not &lt;code&gt;None&lt;/code&gt;, the &lt;code&gt;InfeedQueue&lt;/code&gt; from which to append a tuple of arguments as inputs to computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10b4ff62e62efdc95a18f3a63aa74dca275ad369" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;infeed_queue&lt;/code&gt;&lt;/b&gt;: If not &lt;code&gt;None&lt;/code&gt;, the &lt;code&gt;InfeedQueue&lt;/code&gt; to use to augment the inputs of &lt;code&gt;computation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b10afbd8ed8fce314f5fe77c6356adf7685288a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;infer_shape&lt;/code&gt;&lt;/b&gt;: (optional) False disables tests for consistent output shapes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="789d271ebccbe5ea12ee69afd4e1d03c14452760" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;infer_shape&lt;/code&gt;&lt;/b&gt;: (optional, default: True) If True, shape inference is enabled. In this case, all elements must have the same shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4521337300e5076d811a7d0b06f4c522d0bfe886" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;infer_shape&lt;/code&gt;&lt;/b&gt;: Whether shape inference is enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dddbf17bccee71b2f5ed052c658e35e9ae015a9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inference_input_type&lt;/code&gt;&lt;/b&gt;: Target data type of real-number input arrays. Allows for a different type for input arrays. If an integer type is provided and &lt;code&gt;optimizations&lt;/code&gt; are not used, &lt;code&gt;quantized_inputs_stats&lt;/code&gt; must be provided. If &lt;code&gt;inference_type&lt;/code&gt; is tf.uint8, signaling conversion to a fully quantized model from a quantization-aware trained input model, then &lt;code&gt;inference_input_type&lt;/code&gt; defaults to tf.uint8. In all other cases, &lt;code&gt;inference_input_type&lt;/code&gt; defaults to tf.float32. Must be &lt;code&gt;{tf.float32, tf.uint8, tf.int8}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e3f43c7f3b4ebd44f266502366e54294091145" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inference_output_type&lt;/code&gt;&lt;/b&gt;: Target data type of real-number output arrays. Allows for a different type for output arrays. If &lt;code&gt;inference_type&lt;/code&gt; is tf.uint8, signaling conversion to a fully quantized model from a quantization-aware trained output model, then &lt;code&gt;inference_output_type&lt;/code&gt; defaults to tf.uint8. In all other cases, &lt;code&gt;inference_output_type&lt;/code&gt; must be tf.float32, an error will be thrown otherwise. Must be &lt;code&gt;{tf.float32, tf.uint8, tf.int8}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce969f6efa4733c9bcb8a293d66d3c0189986302" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inference_type&lt;/code&gt;&lt;/b&gt;: Target data type of real-number arrays in the output file. Must be &lt;code&gt;{tf.float32, tf.uint8}&lt;/code&gt;. If &lt;code&gt;optimzations&lt;/code&gt; are provided, this parameter is ignored. (default tf.float32)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a302f290c14f051bd5fa4b6dfbaaa680fd12b849" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;init_feed_dict&lt;/code&gt;&lt;/b&gt;: A dictionary that maps &lt;code&gt;Tensor&lt;/code&gt; objects to feed values. This feed dictionary will be used when &lt;code&gt;init_op&lt;/code&gt; is evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe906a3a5b0a0826d6dcf3a80e5cbfd9abc5209e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;init_feed_dict&lt;/code&gt;&lt;/b&gt;: Optional dictionary that maps &lt;code&gt;Tensor&lt;/code&gt; objects to feed values. This feed dictionary is passed to the session &lt;code&gt;run()&lt;/code&gt; call when running the init op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853b08663afb21e4b0008ab92bed8a8639e04338" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;init_feed_dict&lt;/code&gt;&lt;/b&gt;: Optional session feed dictionary to use when running the init_op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2cb49ad93541b51787c863ea45d5db538c8060" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;init_fn&lt;/code&gt;&lt;/b&gt;: Optional callable used to initialize the model. Called after the optional &lt;code&gt;init_op&lt;/code&gt; is called. The callable must accept one argument, the session being initialized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6168cdb42c82642226f4b9f3fd6ed884b1280272" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;init_fn&lt;/code&gt;&lt;/b&gt;: Optional function to use to initialize the model after running the init_op. Will be called as &lt;code&gt;init_fn(scaffold, session)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab58792cf22489b58df7fdd20e90aa870aedac13" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;init_op&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Operation&lt;/code&gt;. Used by chief supervisors to initialize the model when it can not be recovered. Defaults to an &lt;code&gt;Operation&lt;/code&gt; that initializes all global variables. If &lt;code&gt;None&lt;/code&gt;, no initialization is done automatically unless you pass a value for &lt;code&gt;init_fn&lt;/code&gt;, see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e48c2468f46083de0269efdfed72ab755c5c33" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;init_op&lt;/code&gt;&lt;/b&gt;: Op or group of ops to execute when the graph is loaded. Note that when the init_op is specified it is run after the restore op at load-time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9da48b47802fd895f41f13d4cd7a772e255c65" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;init_op&lt;/code&gt;&lt;/b&gt;: Optional &lt;code&gt;Operation&lt;/code&gt; used to initialize the model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d6fea369603af9a0bd42c93a8f36bc5246d61e7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;init_op&lt;/code&gt;&lt;/b&gt;: Optional op for initializing variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5dddb9999688f9293ab3e8ecc6859a3bb32cfc8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;init_targets&lt;/code&gt;&lt;/b&gt;: list of targets to run to initialize model params.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768df0a8711b416c568873d136f28e4935adc582" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_accumulator&lt;/code&gt;&lt;/b&gt;: initial accumulator for Adagrad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fbd86db496a96532812c14df122e24f990705f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_accumulator_value&lt;/code&gt;&lt;/b&gt;: A floating point value. Starting value for the accumulators, must be non-negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210e24443770194259f167e839fc1102db67f19c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_accumulator_value&lt;/code&gt;&lt;/b&gt;: A floating point value. Starting value for the accumulators, must be positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa7fbbaaf9e68f59c4fe4b552b894ce3c79cf120" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_accumulator_value&lt;/code&gt;&lt;/b&gt;: The starting value for accumulators. Only zero or positive values are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c965ce652eb9e6133aedb86a2798437558f45f96" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_clusters&lt;/code&gt;&lt;/b&gt;: Specifies how the initial cluster centers are chosen. One of the following: * a tensor or numpy array with the initial cluster centers. * a callable &lt;code&gt;f(inputs, k)&lt;/code&gt; that selects and returns up to &lt;code&gt;k&lt;/code&gt; centers from an input batch. &lt;code&gt;f&lt;/code&gt; is free to return any number of centers from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;k&lt;/code&gt;. It will be invoked on successive input batches as necessary until all &lt;code&gt;num_clusters&lt;/code&gt; centers are chosen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90135f66405d09d36ed13e252d0fb0d87e8e077f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_dist&lt;/code&gt;&lt;/b&gt;: (Optional.) A floating point type tensor, shaped &lt;code&gt;[num_classes]&lt;/code&gt;. If not provided, the true class distribution is estimated live in a streaming fashion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a79a24a770a4b18585934904eb458af0fd77b60a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_epoch&lt;/code&gt;&lt;/b&gt;: Integer. Epoch at which to start training (useful for resuming a previous training run).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98be17f0b311d90afd5337eb14d06c9edaaa1afd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_gradient_squared_accumulator_value&lt;/code&gt;&lt;/b&gt;: A floating point value. Starting value for the accumulators, must be positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59bbec1b491ee73b17b50498954f0a7e0ffa7aae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_infeed_sleep_secs&lt;/code&gt;&lt;/b&gt;: The number of seconds the infeed thread should wait before enqueueing the first batch. This helps avoid timeouts for models that require a long compilation time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d30d65190bcbbc9cdba95e765684e0060780dc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_learning_rate&lt;/code&gt;&lt;/b&gt;: A scalar &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt; Tensor or a Python number. The initial learning rate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4908f4a686a376a755f2fa2d276e229459355816" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_learning_rate&lt;/code&gt;&lt;/b&gt;: A scalar &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; or a Python number. The initial learning rate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd9a82d476fe6e0881bd0fddc64729f67e9cc97d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_loop_values&lt;/code&gt;&lt;/b&gt;: (Optional) Initial values to be passed into the loop that runs &lt;code&gt;fn&lt;/code&gt;. Defaults to &lt;code&gt;None&lt;/code&gt;. # TODO(priyag): Remove initial_loop_values argument when we have a mechanism to infer the outputs of &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062629721f69abf268488bc6ea85a28b1e027dd8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_loss_scale&lt;/code&gt;&lt;/b&gt;: A Python float. The loss scale to use at the beginning. It's better to start this at a very high number, because a loss scale that is too high gets lowered far more quickly than a loss scale that is too low gets raised. The default is 2 ** 15, which is approximately half the maximum float16 value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c0794849438dfb2091f0fda1c542b5a28794355" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_num_buckets&lt;/code&gt;&lt;/b&gt;: the initial number of buckets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="414e05e087029e98b8a0835a47147d5e50d212db" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_state&lt;/code&gt;&lt;/b&gt;: (optional) An initial state for the RNN. If &lt;code&gt;cell.state_size&lt;/code&gt; is an integer, this must be a &lt;code&gt;Tensor&lt;/code&gt; of appropriate type and shape &lt;code&gt;[batch_size, cell.state_size]&lt;/code&gt;. If &lt;code&gt;cell.state_size&lt;/code&gt; is a tuple, this should be a tuple of tensors having shapes &lt;code&gt;[batch_size, s] for s in cell.state_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f8ae8d99dda766a9dde619c31116ba999e61685" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_state&lt;/code&gt;&lt;/b&gt;: A nested structure of tensors, representing the initial state of the accumulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47e2fb3f082ba37f06b0d824902d124ac820f193" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_state&lt;/code&gt;&lt;/b&gt;: An element representing the initial state of the transformation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1ca07831a1f10f86b1d6917a295caa97525e373" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_state&lt;/code&gt;&lt;/b&gt;: List of initial state tensors to be passed to the first call of the cell (optional, defaults to &lt;code&gt;None&lt;/code&gt; which causes creation of zero-filled initial state tensors).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9403e87cc85cf6004afc91d06e1b5432d0af558" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_state&lt;/code&gt;&lt;/b&gt;: List of initial state tensors to be passed to the first call of the cell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9bf0b9c7eb0ec7ca6dc3f984ddecd57259997e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_state_bw&lt;/code&gt;&lt;/b&gt;: (optional) Same as for &lt;code&gt;initial_state_fw&lt;/code&gt;, but using the corresponding properties of &lt;code&gt;cell_bw&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42dcb87ef0bf1669641109835623c48a70a866af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_state_fw&lt;/code&gt;&lt;/b&gt;: (optional) An initial state for the forward RNN. This must be a tensor of appropriate type and shape &lt;code&gt;[batch_size, cell_fw.state_size]&lt;/code&gt;. If &lt;code&gt;cell_fw.state_size&lt;/code&gt; is a tuple, this should be a tuple of tensors having shapes &lt;code&gt;[batch_size, s] for s in cell_fw.state_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca34f4631beb382efd9c3977f30358a8e361963" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_states&lt;/code&gt;&lt;/b&gt;: Tensor with shape &lt;code&gt;(samples, state_size)&lt;/code&gt; (no time dimension), containing the initial values for the states used in the step function. In the case that state_size is in a nested shape, the shape of initial_states will also follow the nested structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d7db049c9f42ba99b39e911195aae3075149ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_value&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;, or Python object convertible to a &lt;code&gt;Tensor&lt;/code&gt;, which is the initial value for the Variable. The initial value must have a shape specified unless &lt;code&gt;validate_shape&lt;/code&gt; is set to False. Can also be a callable with no argument that returns the initial value when called. In that case, &lt;code&gt;dtype&lt;/code&gt; must be specified. (Note that initializer functions from init_ops.py must first be bound to a shape before being used here.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be60b7627250bdeff9de38ec32ee55ba36b24184" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initial_variance&lt;/code&gt;&lt;/b&gt;: initial variance for the noise. See computation above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="943d0713bd16c2757760a4890a1c1543bd677a73" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initializer&lt;/code&gt;&lt;/b&gt;: (optional) A tensor or (possibly nested) sequence of tensors, as the initial value for the accumulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe441142ea3cb49097c0e5b7e7afa58940c05939" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initializer&lt;/code&gt;&lt;/b&gt;: (optional) A tensor or (possibly nested) sequence of tensors, initial value for the accumulator, and the expected output type of &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="019a8ec850213966ec3da709783171d828278a1c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initializer&lt;/code&gt;&lt;/b&gt;: (optional) The initializer to use for the weight and projection matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d86898a00e40299f86c6c5dfc1c2590d59e460b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initializer&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../operation&quot;&gt;&lt;code&gt;tf.Operation&lt;/code&gt;&lt;/a&gt; that should be run to initialize this iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f19f6b9f25e086927854063b10b45ec1eba0ee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initializer&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;shape&lt;/code&gt; or a variable initializer function. If a function, it will be called once for each slice, passing the shape and data type of the slice as parameters. The function must return a tensor with the same shape as the slice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8668651806284b7bb4282d60d615b0b9e9d9a280" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initializer&lt;/code&gt;&lt;/b&gt;: A TableInitializerBase object that contains the data used to initialize the table. If None, then we only use out-of-vocab buckets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3413b33cd33820303915b9cce50fe0f5830ac2e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initializer&lt;/code&gt;&lt;/b&gt;: A variable initializer function to be used in embedding variable initialization. If not specified, defaults to &lt;a href=&quot;../../truncated_normal_initializer&quot;&gt;&lt;code&gt;tf.compat.v1.truncated_normal_initializer&lt;/code&gt;&lt;/a&gt; with mean &lt;code&gt;0.0&lt;/code&gt; and standard deviation &lt;code&gt;1/sqrt(dimension)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1f9ecb6320397122c9a91eeecd8145fe57c877" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initializer&lt;/code&gt;&lt;/b&gt;: A variable initializer function to be used in embedding variable initialization. If not specified, defaults to &lt;code&gt;tf.truncated_normal_initializer&lt;/code&gt; with mean &lt;code&gt;0.0&lt;/code&gt; and standard deviation &lt;code&gt;1/sqrt(dimension)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9fe75f0c838a0d1f23927b7072755201ce87045" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initializer&lt;/code&gt;&lt;/b&gt;: A variable initializer function to be used in embedding variable initialization. If not specified, defaults to &lt;code&gt;truncated_normal_initializer&lt;/code&gt; with mean &lt;code&gt;0.0&lt;/code&gt; and standard deviation &lt;code&gt;1/sqrt(dimension)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d50b0a82c4c94821763e81c14358d7140ae168" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initializer&lt;/code&gt;&lt;/b&gt;: Initializer for the variable if one is created. Can either be an initializer object or a Tensor. If it's a Tensor, its shape must be known unless validate_shape is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ebcf25dfb12e9ef4251cb565fa9cb79ac4810bf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initializer&lt;/code&gt;&lt;/b&gt;: Initializer instance (callable).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ac8e9f349c098ad8231ce7dab68cfc47434d93" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initializer&lt;/code&gt;&lt;/b&gt;: The first value used (&lt;code&gt;elems[-1]&lt;/code&gt; in case of None)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ed62ce34d7da728888583a69313d4ddde91e3f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initializer&lt;/code&gt;&lt;/b&gt;: The first value used (&lt;code&gt;elems[0]&lt;/code&gt; in case of None)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa979e7d3ed381a863ce3edcc90477e70b086cc5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initializer&lt;/code&gt;&lt;/b&gt;: The table initializer to use. See &lt;code&gt;HashTable&lt;/code&gt; kernel for supported key and value types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3f942ae4ce29c93755f0449dbd6e54d1c941b50" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initializer&lt;/code&gt;&lt;/b&gt;: default initializer for variables within this scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d857f797e1ab14d6f3fe9e40949c070764ab1d2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;initializer&lt;/code&gt;&lt;/b&gt;: default initializer passed to get_variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a66c411b352aae9eac5a5ac223b8bc4d9b6bad5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inner_axis&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;int&lt;/code&gt;: The last dimension in the range of dimensions to merge. May be negative if &lt;code&gt;self.shape.rank&lt;/code&gt; is statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df24fe4817c3a4e3df41efe8d036e5c1f356166e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inner_shape&lt;/code&gt;&lt;/b&gt;: A tuple of integers specifying the shape for individual inner values in the returned &lt;code&gt;RaggedTensor&lt;/code&gt;. Defaults to &lt;code&gt;()&lt;/code&gt; if &lt;code&gt;ragged_rank&lt;/code&gt; is not specified. If &lt;code&gt;ragged_rank&lt;/code&gt; is specified, then a default is chosen based on the contents of &lt;code&gt;pylist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84c0a09e4fa6347f0a6d915e259e67fd9f54f584" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inner_shape&lt;/code&gt;&lt;/b&gt;: A tuple of integers specifying the shape for individual inner values in the returned &lt;code&gt;RaggedTensorValue&lt;/code&gt;. Defaults to &lt;code&gt;()&lt;/code&gt; if &lt;code&gt;ragged_rank&lt;/code&gt; is not specified. If &lt;code&gt;ragged_rank&lt;/code&gt; is specified, then a default is chosen based on the contents of &lt;code&gt;pylist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2924860902a77cb1364a94c61fbdb15757299d54" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inp&lt;/code&gt;&lt;/b&gt;: A list of &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de07475be9d87d84c33b48ca3f3fc26b34e684c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inp&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;Tensor&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0165320278fe077f0402b9ada41c19a776457e0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: 1-D or higher &lt;code&gt;Tensor&lt;/code&gt; with last dimension at least &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8b4099e19b622b6ea0468260e733a3a6401c142" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: 4-D &lt;code&gt;Tensor&lt;/code&gt; with shape according to &lt;code&gt;data_format&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d06a5c1069a55aa0ef662c48fcc482778c2549f3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: 4-D with shape according to &lt;code&gt;data_format&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec483e44877bebf64fbb4062dee05b9b06e7576f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A 3-D &lt;code&gt;Tensor&lt;/code&gt; of the format specified by &lt;code&gt;data_format&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f04d919e78d00e0b3b3c3e8ce989855953b8c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A 3-D &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float&lt;/code&gt; and shape &lt;code&gt;[batch, in_width, in_channels]&lt;/code&gt; for &lt;code&gt;NWC&lt;/code&gt; data format or &lt;code&gt;[batch, in_channels, in_width]&lt;/code&gt; for &lt;code&gt;NCW&lt;/code&gt; data format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515c365a73ac45a329e13d0ecf7e6e694a0e6545" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A 3D &lt;code&gt;Tensor&lt;/code&gt;. Must be of type &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, or &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36eae3d79bc5bc6d4714eed3d1fa93481b87f35a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A 4-D &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[batch, height, width, channels]&lt;/code&gt; and type &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;qint8&lt;/code&gt;, &lt;code&gt;quint8&lt;/code&gt;, or &lt;code&gt;qint32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e8516ea37c5177bb514f1aa5192ca796532664" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A 4-D &lt;code&gt;Tensor&lt;/code&gt; of the format specified by &lt;code&gt;data_format&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d04aa5f6dcc0fa1c2574053273d88536bfe314ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A 4-D &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float&lt;/code&gt; and shape &lt;code&gt;[batch, height, width, in_channels]&lt;/code&gt; for &lt;code&gt;NHWC&lt;/code&gt; data format or &lt;code&gt;[batch, in_channels, height, width]&lt;/code&gt; for &lt;code&gt;NCHW&lt;/code&gt; data format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c91ada234862c5089eaa22175a6df584d4e17971" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A 4D input Tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc2f4456edcda0ad96c34934deeb08106a40bd47" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A 5-D &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[batch, height, width, channels]&lt;/code&gt; and type &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;qint8&lt;/code&gt;, &lt;code&gt;quint8&lt;/code&gt;, or &lt;code&gt;qint32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77db1f418e22dc8f1d84cf87285e35f8318f4bc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A 5-D &lt;code&gt;Tensor&lt;/code&gt; of the format specified by &lt;code&gt;data_format&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef9a2421bebea26a7b9122aedac7190ef0714907" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A 5-D &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float&lt;/code&gt; and shape &lt;code&gt;[batch, height, width, in_channels]&lt;/code&gt; for &lt;code&gt;NHWC&lt;/code&gt; data format or &lt;code&gt;[batch, in_channels, height, width]&lt;/code&gt; for &lt;code&gt;NCHW&lt;/code&gt; data format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2fbf41d7de23f708b34b9388e07a026f51251aa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd0abfc8b1e936cc5a59ec33156466a289f86fce" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt;. A 4-D float tensor of shape &lt;code&gt;[batch_size, height, width, channels]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79925d70a6656cc2a6036e9f1c19d3f7c422ddf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;int32&lt;/code&gt;. A Tensor of int32 Unicode code points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ee7b32e074bdfc88fd954487f844a9b9755dfe0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a177f0f7fa4fd48f15523d3f5fb05800f4cd24" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. A string &lt;code&gt;Tensor&lt;/code&gt; of any shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79141335f7e64b4911354c84545274c2718f222c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. A string tensor of the text to be processed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e930ef13c941a7cdbcdf625201f8db774df0c529" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. Base64 strings to decode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b644f746c245267b21f92b40350e405851261fc3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. Strings to be encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea23878ac83039687bc717c5e132199c33e2c5d6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. Tensor of strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03d8c7494300031d3f8d1d13ade4ba6f13dad43" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. The string for which to compute the length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1a40d5f6ba5558fa889b3838acd502ba3455fcd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. The strings to assign a hash bucket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d3204e32c270e79c93d39ada8f771c6b5314e62" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. The text to be processed. Can have any shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="193c5292dfd545dfb137f11ae65202da0e8d093e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. vector of strings to compute fingerprints on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c21eec90163f90a1e99b77cfa214ff8e3581086" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b852a12a8676008b3615cd1525f002c88800ea70" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; to quantize and dequantize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2946f8f5f1b89c4c05a56fc9e9753665a76a9cb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; with &lt;code&gt;rank k &amp;gt;= 2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d6ef35562c6ef2f18109d5d6e7e152db470f76" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; with rank &lt;code&gt;k + 1&lt;/code&gt;, where &lt;code&gt;k &amp;gt;= 1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d3d7f78b55df87b45c3dcf9a9a960136d131c0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dec467d24b0cbaf78df792d0cf57df3733aea05" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. 1-D or higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce4140b0e38a7530116f4587902cb29616fdc80" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. 4-D tensor with shape &lt;code&gt;[batch*block_size*block_size, height_pad/block_size, width_pad/block_size, depth]&lt;/code&gt;. Note that the batch size of the input tensor must be divisible by &lt;code&gt;block_size * block_size&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f33dc5865ca90c8da742108c75d6ddee7b0421ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. 4-D with shape &lt;code&gt;[batch, height, width, depth]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7046b32eb8e2d0f6b8a847d3567525f8327e9583" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. A Tensor to broadcast.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e992cb11440352caee2cadc5037e28fcf17600f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, or &lt;code&gt;complex128&lt;/code&gt; with shape &lt;code&gt;[..., M, M]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d557b6ed05d33ec92949e68176aa6e752b4c2b3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;. Rank k tensor where k is even and not zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1846432c3006488955bd154a0c7d8b6e65c5c86d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;, &lt;code&gt;qint8&lt;/code&gt;, &lt;code&gt;quint8&lt;/code&gt;, &lt;code&gt;qint16&lt;/code&gt;, &lt;code&gt;quint16&lt;/code&gt;, &lt;code&gt;qint32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b571d2e12b05ca471500db2cd7be7b713399f9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;. A complex tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e42c0b425ec9be569d5c42fa6a413194e94600fd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;. Shape is &lt;code&gt;[..., M, M]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6618f9586ef38dbd933b66209e2d2ca5c6daa30d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;qint8&lt;/code&gt;, &lt;code&gt;quint8&lt;/code&gt;, &lt;code&gt;qint32&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463eab92e20ab3506c05545f7589880bb7584106" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;. 4-D with shape &lt;code&gt;[batch, height, width, channels]&lt;/code&gt;. Input to pool over.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a2a2254668d0d9c33516d9e4b711552c93fdbc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;. 4-D with shape &lt;code&gt;[batch, in_height, in_width, depth]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7a6f40b9feca4d157935b1c5706937756da5016" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;uint8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;uint16&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;uint32&lt;/code&gt;, &lt;code&gt;uint64&lt;/code&gt;. 5-D Tensor with shape &lt;code&gt;[batch, in_planes, in_rows, in_cols, depth]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb33a210a4efd50909b82fe4206b0fd03a98513" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;. A float32 tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efba4abfcf2ef6b11282df8edd05c66e5c5dc15" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;. A tensor of shape &lt;code&gt;[..., M, M]&lt;/code&gt; whose inner-most 2 dimensions form matrices of size &lt;code&gt;[M, M]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3355280a54402ec0d0fa32c4315ab0f623e49b9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;. A tensor of shape &lt;code&gt;[..., M, N]&lt;/code&gt; whose inner-most 2 dimensions form matrices of size &lt;code&gt;[M, N]&lt;/code&gt;. Let &lt;code&gt;P&lt;/code&gt; be the minimum of &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed92c2cfd994dfc550b515786fd311ee3db2eb21" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;. Shape is &lt;code&gt;[..., M, M]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96fa1180fd2dacecb176ac9562c0864863cb6281" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d745b3f609e71db87780520edf646c708fb3ef2b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db5c59049c688b8a8e2704b2fed3df36aab872a8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;. 4-D with shape &lt;code&gt;[batch, in_height, in_width, in_channels]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a416a929a25863002edae741ab473effacad7555" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;. 4-D with shape based on &lt;code&gt;data_format&lt;/code&gt;. For example, if &lt;code&gt;data_format&lt;/code&gt; is 'NHWC' then &lt;code&gt;input&lt;/code&gt; is a 4-D &lt;code&gt;[batch, in_height, in_width, in_channels]&lt;/code&gt; tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ae7b1fffdd75f7eb68c71640036d77758803eb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;. A 4-D tensor. The dimension order is interpreted according to the value of &lt;code&gt;data_format&lt;/code&gt;, see below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22e345cbe2efd207855424d323b32d105234dd7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;. Shape &lt;code&gt;[batch, depth, rows, cols, in_channels]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="070b14b8a0e2ed2bff1f5c72d2b00a29b74155ef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;. Shape &lt;code&gt;[batch, in_depth, in_height, in_width, in_channels]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb1366412fba4574a1d2ca3b2c341a42ed2225e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;. 4-D.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1377f8abbdd142bed407ca42d1184a98b0b27e6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;. Shape is &lt;code&gt;[..., M, M]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec65699b6cf196a4c3c501f39383cb7bd150f5d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;. Shape is &lt;code&gt;[N, M, M]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e4db8014d28022b3b737714956859c091e3196" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;int16&lt;/code&gt;, &lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3336f5c2f51331eb3a9ec8f4781080065e6e9bd8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;qint8&lt;/code&gt;, &lt;code&gt;quint8&lt;/code&gt;, &lt;code&gt;qint32&lt;/code&gt;, &lt;code&gt;qint16&lt;/code&gt;, &lt;code&gt;quint16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba1fd61c7afbd91297ac4bf2e82c80a8d785855a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;qint8&lt;/code&gt;, &lt;code&gt;quint8&lt;/code&gt;, &lt;code&gt;qint32&lt;/code&gt;, &lt;code&gt;qint16&lt;/code&gt;, &lt;code&gt;quint16&lt;/code&gt;. 4-D with shape &lt;code&gt;[batch, height, width, channels]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0882fbc0a029716cfdbfa4aec36031f8b6962349" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;qint8&lt;/code&gt;, &lt;code&gt;quint8&lt;/code&gt;, &lt;code&gt;qint32&lt;/code&gt;, &lt;code&gt;qint16&lt;/code&gt;, &lt;code&gt;quint16&lt;/code&gt;. The 4D (batch x rows x cols x depth) Tensor to MaxReduce over.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a5020c6c2647c11490403257a2cf8eb852ff064" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must have numeric type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3699995c4b42b988ecfa0c6fc8b56309ec8b3a42" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. N-D with shape &lt;code&gt;input_shape = [batch] + spatial_shape + remaining_shape&lt;/code&gt;, where spatial_shape has &lt;code&gt;M&lt;/code&gt; dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02b5ab5c5f8b26ff2af3c07f60da3de510b05ee5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. N-D with shape &lt;code&gt;input_shape = [batch] + spatial_shape + remaining_shape&lt;/code&gt;, where spatial_shape has M dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfaf968b2649df5c5206e5fb69d1935d32e6adbd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Rank &lt;code&gt;k&lt;/code&gt; tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b314aa43ba16b695040d0ff0f6e1a11d661cb454" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. The &lt;code&gt;input&lt;/code&gt; to squeeze.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9717b382b8da76cd7a6c520a2ccb0c61d9af1eaa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. The default value to produce when output is not fed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f032ba8940470b1d9d01f4c7d615392ee065220f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;[..., samples]&lt;/code&gt;&lt;code&gt;float32&lt;/code&gt;/&lt;code&gt;float64&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; containing the signals to take the DCT of.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24b464cd234b4456772b51af704fe5a803322531" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;Tensor&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629139ad58cdf7bc674bf0ba35bc1c7af458d093" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A list of at least 1 &lt;code&gt;Tensor&lt;/code&gt; object with the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c0d38ec399bacec4daaa60dfdc01621c2c2a42" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A string &lt;code&gt;Tensor&lt;/code&gt; of rank &lt;code&gt;N&lt;/code&gt;, the strings to split. If &lt;code&gt;rank(input)&lt;/code&gt; is not known statically, then it is assumed to be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9972c78e02009332356632d31b2a027beaf190d8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: A string &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;RaggedTensor&lt;/code&gt;: the strings to split. Must have a statically known rank (&lt;code&gt;N&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6da5c8f9724ecfd67151251895e2f083adaa4e9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: Alias for t.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65c719c435abec7b9652b0e5b5445f980c560236" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: Alias for value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f20527fe25822fc11aeac0acce3c8b9687bd308c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: Alias of value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77c39735f141723693e68cac8358ef20b726110" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: An (N+2)-D &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;, of shape &lt;code&gt;[batch_size] + input_spatial_shape + [in_channels]&lt;/code&gt; if data_format does not start with &quot;NC&quot; (default), or &lt;code&gt;[batch_size, in_channels] + input_spatial_shape&lt;/code&gt; if data_format starts with &quot;NC&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb19e26e4abf61534508d50e385d57179b7a040" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;N+1&lt;/code&gt; dimensional potentially ragged integer tensor with shape &lt;code&gt;[D1...DN, num_chars]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3acd35f1eba567ac19605fb47609613cb18114ac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;N&lt;/code&gt; dimensional potentially ragged &lt;code&gt;string&lt;/code&gt; tensor with shape &lt;code&gt;[D1...DN]&lt;/code&gt;. &lt;code&gt;N&lt;/code&gt; must be statically known.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d73f231557eda7886977d79b252988ea84e8e9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;N&lt;/code&gt;-dimensional Tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87304398d355d9485d26bd9f8237d11628093dfc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: An N+2 dimensional &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[batch_size] + input_spatial_shape + [in_channels]&lt;/code&gt; if data_format does not start with &quot;NC&quot; (default), or &lt;code&gt;[batch_size, in_channels] + input_spatial_shape&lt;/code&gt; if data_format starts with &quot;NC&quot;. It must be one of the following types: &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;bfloat16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d287a307a2a8e4a0654404ff968a68913abca3ef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: Overrides input_tensor. For compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96ef8358eefe149aac56cb613e87feb4691b2cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: Tensor of rank &amp;gt; max(spatial_dims).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02fb8733e139ca82dc5cea4245434c1996126abd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: Tensor of rank N+2, of shape &lt;code&gt;[batch_size] + input_spatial_shape + [num_channels]&lt;/code&gt; if &lt;code&gt;data_format&lt;/code&gt; does not start with &quot;NC&quot; (default), or &lt;code&gt;[batch_size, num_channels] + input_spatial_shape&lt;/code&gt; if data_format starts with &quot;NC&quot;. Pooling happens over the spatial dimensions only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f0f97eaa1725f793336b0138c400087da468eb7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: Tensor of rank N+2, of shape &lt;code&gt;[batch_size] + input_spatial_shape + [num_channels]&lt;/code&gt; if data_format does not start with &quot;NC&quot; (default), or &lt;code&gt;[batch_size, num_channels] + input_spatial_shape&lt;/code&gt; if data_format starts with &quot;NC&quot;. Pooling happens over the spatial dimensions only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="167e695d39e06d1182ed7d44c576eb3c5d1faffb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: The tensor to reduce. Should be of numeric type, &lt;code&gt;bool&lt;/code&gt;, or &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3acedd821eab45507e638936b070a28b9cb2bd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input&lt;/code&gt;&lt;/b&gt;: string &lt;code&gt;Tensor&lt;/code&gt;, the source strings to process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6622c42106289cb5c44c7e972df0312293acd75c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c79ff650fd7986cbcf1e55285e14f4bdb5a530e7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_&lt;/code&gt;&lt;/b&gt;: A tensor passed through this op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dfd13d81da3c2773359098859c439b1cee317a2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_arrays&lt;/code&gt;&lt;/b&gt;: List of input tensors to freeze graph with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a2167042a9883e4fa5a61893631962e0a5e6c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_arrays&lt;/code&gt;&lt;/b&gt;: List of input tensors to freeze graph with. Uses input arrays from SignatureDef when none are provided. (default None)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74f690dd7d2a7b3e80f954fe234c0ce904fd7121" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_arrays_with_shape&lt;/code&gt;&lt;/b&gt;: Tuple of strings representing input tensor names and list of integers representing input shapes (e.g., [(&quot;foo&quot; : [1, 16, 16, 3])]). Use only when graph cannot be loaded into TensorFlow and when &lt;code&gt;input_tensors&lt;/code&gt; and &lt;code&gt;output_tensors&lt;/code&gt; are None. (default None)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be44b5f68b05ff30dffdbc9af64c6d34b875acae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_buffer_size&lt;/code&gt;&lt;/b&gt;: int or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01af408eaf5c8ddff27fdc2c96c95e2db6b91e9c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_bytes&lt;/code&gt;&lt;/b&gt;: Each element of the input Tensor is converted to an array of bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb3f2c802e196e70f573b0fd9abc5b66d3c9e4d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_data&lt;/code&gt;&lt;/b&gt;: Input data (i.e. often &lt;code&gt;sess.graph_def&lt;/code&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="552eca9a9346e2f261fde27219ee28edce530dd5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_dim&lt;/code&gt;&lt;/b&gt;: int &amp;gt; 0. Size of the vocabulary, i.e. maximum integer index + 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9818b46b164c98e7959ef8094c09cc8a6afcc653" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_encoding&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;string&lt;/code&gt;. Text encoding of the input strings. This is any of the encodings supported by ICU ucnv algorithmic converters. Examples: &lt;code&gt;&quot;UTF-16&quot;, &quot;US ASCII&quot;, &quot;UTF-8&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681b9f5463bab1ac52d8cbeee9d410848ea0f585" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_encoding&lt;/code&gt;&lt;/b&gt;: String name for the unicode encoding that should be used to decode each string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e115d6c6720496a34db50255fe22b9e14b90ee86" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_fn&lt;/code&gt;&lt;/b&gt;: A function taking a &lt;a href=&quot;../../../../distribute/inputcontext&quot;&gt;&lt;code&gt;tf.distribute.InputContext&lt;/code&gt;&lt;/a&gt; object and returning a &lt;a href=&quot;../../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21723f300c7aff33e03d0835598725ef43cf65ff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_fn&lt;/code&gt;&lt;/b&gt;: A function taking a &lt;a href=&quot;../../../distribute/inputcontext&quot;&gt;&lt;code&gt;tf.distribute.InputContext&lt;/code&gt;&lt;/a&gt; object and returning a &lt;a href=&quot;../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed3f02aeae748620bcd02aff69e9360051dd92c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_fn&lt;/code&gt;&lt;/b&gt;: A function that constructs the features. Prediction continues until &lt;code&gt;input_fn&lt;/code&gt; raises an end-of-input exception (&lt;a href=&quot;../../../../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;StopIteration&lt;/code&gt;). See &lt;a href=&quot;https://tensorflow.org/guide/premade_estimators#create_input_functions&quot;&gt;Premade Estimators&lt;/a&gt; for more information. The function should construct and return one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf0832feca712917033772401fde103ab820770" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_fn&lt;/code&gt;&lt;/b&gt;: A function that constructs the features. Prediction continues until &lt;code&gt;input_fn&lt;/code&gt; raises an end-of-input exception (&lt;a href=&quot;../../../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;StopIteration&lt;/code&gt;). See &lt;a href=&quot;https://tensorflow.org/guide/premade_estimators#create_input_functions&quot;&gt;Premade Estimators&lt;/a&gt; for more information. The function should construct and return one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1afbf5a9a99fc89fa05bd0584db75df858e017e4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_fn&lt;/code&gt;&lt;/b&gt;: A function that constructs the features. Prediction continues until &lt;code&gt;input_fn&lt;/code&gt; raises an end-of-input exception (&lt;a href=&quot;../../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;StopIteration&lt;/code&gt;). See &lt;a href=&quot;https://tensorflow.org/guide/premade_estimators#create_input_functions&quot;&gt;Premade Estimators&lt;/a&gt; for more information. The function should construct and return one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9114b228fc4fbf58388244d5b6c9c7c44cf02a4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_fn&lt;/code&gt;&lt;/b&gt;: A function that constructs the features. Prediction continues until &lt;code&gt;input_fn&lt;/code&gt; raises an end-of-input exception (&lt;a href=&quot;../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;StopIteration&lt;/code&gt;). See &lt;a href=&quot;https://tensorflow.org/guide/premade_estimators#create_input_functions&quot;&gt;Premade Estimators&lt;/a&gt; for more information. The function should construct and return one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b06c935925a9342379a05498779fd62934f8b3f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_fn&lt;/code&gt;&lt;/b&gt;: A function that constructs the input data for evaluation. See &lt;a href=&quot;https://tensorflow.org/guide/premade_estimators#create_input_functions&quot;&gt;Premade Estimators&lt;/a&gt; for more information. The function should construct and return one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a7273ee4b654caa8eeeaa3742bdf774046b2c1f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_fn&lt;/code&gt;&lt;/b&gt;: A function that constructs the input data for evaluation. See &lt;a href=&quot;https://tensorflow.org/guide/premade_estimators#create_input_functions&quot;&gt;Premade Estimators&lt;/a&gt; for more information. The function should construct and return one of the following: * A &lt;a href=&quot;../../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; object: Outputs of &lt;code&gt;Dataset&lt;/code&gt; object must be a tuple &lt;code&gt;(features, labels)&lt;/code&gt; with same constraints as below. * A tuple &lt;code&gt;(features, labels)&lt;/code&gt;: Where &lt;code&gt;features&lt;/code&gt; is a &lt;a href=&quot;../../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or a dictionary of string feature name to &lt;code&gt;Tensor&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; or a dictionary of string label name to &lt;code&gt;Tensor&lt;/code&gt;. Both &lt;code&gt;features&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; are consumed by &lt;code&gt;model_fn&lt;/code&gt;. They should satisfy the expectation of &lt;code&gt;model_fn&lt;/code&gt; from inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="739bd9cdb1fb88a7b66b94d22df1d52ad8b906ef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_fn&lt;/code&gt;&lt;/b&gt;: A function that constructs the input data for evaluation. See &lt;a href=&quot;https://tensorflow.org/guide/premade_estimators#create_input_functions&quot;&gt;Premade Estimators&lt;/a&gt; for more information. The function should construct and return one of the following: * A &lt;a href=&quot;../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; object: Outputs of &lt;code&gt;Dataset&lt;/code&gt; object must be a tuple &lt;code&gt;(features, labels)&lt;/code&gt; with same constraints as below. * A tuple &lt;code&gt;(features, labels)&lt;/code&gt;: Where &lt;code&gt;features&lt;/code&gt; is a &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or a dictionary of string feature name to &lt;code&gt;Tensor&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; or a dictionary of string label name to &lt;code&gt;Tensor&lt;/code&gt;. Both &lt;code&gt;features&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; are consumed by &lt;code&gt;model_fn&lt;/code&gt;. They should satisfy the expectation of &lt;code&gt;model_fn&lt;/code&gt; from inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae61723992cd7239b1cd3199514cab3156deed42" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_fn&lt;/code&gt;&lt;/b&gt;: A function that constructs the input data for evaluation. See &lt;a href=&quot;https://tensorflow.org/guide/premade_estimators#create_input_functions&quot;&gt;Premade Estimators&lt;/a&gt; for more information. The function should construct and return one of the following: * A &lt;a href=&quot;../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; object: Outputs of &lt;code&gt;Dataset&lt;/code&gt; object must be a tuple &lt;code&gt;(features, labels)&lt;/code&gt; with same constraints as below. * A tuple &lt;code&gt;(features, labels)&lt;/code&gt;: Where &lt;code&gt;features&lt;/code&gt; is a &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or a dictionary of string feature name to &lt;code&gt;Tensor&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; or a dictionary of string label name to &lt;code&gt;Tensor&lt;/code&gt;. Both &lt;code&gt;features&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; are consumed by &lt;code&gt;model_fn&lt;/code&gt;. They should satisfy the expectation of &lt;code&gt;model_fn&lt;/code&gt; from inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13848c5a5207575ec6c5dfaf0a039c079ecee1e3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_fn&lt;/code&gt;&lt;/b&gt;: A function that constructs the input data for evaluation. See &lt;a href=&quot;https://tensorflow.org/guide/premade_estimators#create_input_functions&quot;&gt;Premade Estimators&lt;/a&gt; for more information. The function should construct and return one of the following: * A &lt;a href=&quot;../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; object: Outputs of &lt;code&gt;Dataset&lt;/code&gt; object must be a tuple &lt;code&gt;(features, labels)&lt;/code&gt; with same constraints as below. * A tuple &lt;code&gt;(features, labels)&lt;/code&gt;: Where &lt;code&gt;features&lt;/code&gt; is a &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or a dictionary of string feature name to &lt;code&gt;Tensor&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; or a dictionary of string label name to &lt;code&gt;Tensor&lt;/code&gt;. Both &lt;code&gt;features&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; are consumed by &lt;code&gt;model_fn&lt;/code&gt;. They should satisfy the expectation of &lt;code&gt;model_fn&lt;/code&gt; from inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022924c93d837cdbbd08e03f27d01ee6222aa85e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_fn&lt;/code&gt;&lt;/b&gt;: A function that provides input data for predicting as minibatches. See &lt;a href=&quot;https://tensorflow.org/guide/premade_estimators#create_input_functions&quot;&gt;Premade Estimators&lt;/a&gt; for more information. The function should construct and return one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="784b25c0ca3c213f2c87a9a9f1ebef1fcebe98bf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_fn&lt;/code&gt;&lt;/b&gt;: A function that provides input data for training as minibatches. See &lt;a href=&quot;https://tensorflow.org/guide/premade_estimators#create_input_functions&quot;&gt;Premade Estimators&lt;/a&gt; for more information. The function should construct and return one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f42811bd54a70d77f777f0028f1761bc80affea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_fn&lt;/code&gt;&lt;/b&gt;: Equivalent to the &lt;code&gt;input_fn&lt;/code&gt; arg to &lt;code&gt;estimator.evaluate&lt;/code&gt;. A function that constructs the input data for evaluation. See &lt;a href=&quot;https://tensorflow.org/guide/premade_estimators#create_input_functions&quot;&gt;Creating input functions&lt;/a&gt; for more information. The function should construct and return one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b218752d351b9431ae1edc917ce2df921c0407f6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_fn&lt;/code&gt;&lt;/b&gt;: Input points. See &lt;a href=&quot;../../../../estimator/estimator#evaluate&quot;&gt;&lt;code&gt;tf.estimator.Estimator.evaluate&lt;/code&gt;&lt;/a&gt;. Only one batch is retrieved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7684ad4d77d5378a41ff4fbd26aa516450490f25" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_fn&lt;/code&gt;&lt;/b&gt;: Input points. See &lt;a href=&quot;../../../../estimator/estimator#predict&quot;&gt;&lt;code&gt;tf.estimator.Estimator.predict&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd6421a9ff34540689010af9abb952834a4bfb4a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_fn&lt;/code&gt;&lt;/b&gt;: a generator function that yields input data as a list or tuple, which will be used to execute the converted signature to generate TRT engines. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d9608230e9a974eb5cea193407876271dfab84b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_gen&lt;/code&gt;&lt;/b&gt;: an input generator that can be used to generate input samples for the model. This must be a callable object that returns an object that supports the &lt;code&gt;iter()&lt;/code&gt; protocol (e.g. a generator function). The elements generated must have same type and shape as inputs to the model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3732972b824baca8e10c1095d0329a604a9ad99e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_graph&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;GraphDef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1909fc71d81a29da1c66dd4bc201ae2e50b776e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_graph&lt;/code&gt;&lt;/b&gt;: Model to analyze and prune.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc19a2bd207b8d5ac5f7ae090d8469be8d9ba99" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_graph_def&lt;/code&gt;&lt;/b&gt;: GraphDef object holding the network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a820d2315863b5e9420faa0a08eb297c0a511e61" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_index&lt;/code&gt;&lt;/b&gt;: Tensor index of input to set. This value can be gotten from the 'index' field in get_input_details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c03680bcd8a8b7d8a9e14e7358fb4e56668f29" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_iterator&lt;/code&gt;&lt;/b&gt;: (Optional) input iterator from which the inputs are taken.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d13f270ac4df1a89d8a6e7c889559c1c7c42f131" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_keep_prob&lt;/code&gt;&lt;/b&gt;: unit Tensor or float between 0 and 1, input keep probability; if it is constant and 1, no input dropout will be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="485b55b141c76d3ea8b9fb11d55e70fb6da64736" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_layer_partitioner&lt;/code&gt;&lt;/b&gt;: Partitioner for input layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9b8f095e69646d2503235d3c36df7eab2abc91" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_length&lt;/code&gt;&lt;/b&gt;: An integer or a 1-D Tensor, depending on whether the time dimension is fixed-length or not. In case of variable length input, it is used for masking in case there's no mask specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691257a501109b400734ddead43d9160937dad3e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_length&lt;/code&gt;&lt;/b&gt;: Length of input sequences, when it is constant. This argument is required if you are going to connect &lt;code&gt;Flatten&lt;/code&gt; then &lt;code&gt;Dense&lt;/code&gt; layers upstream (without it, the shape of the dense outputs cannot be computed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b34f0c8120a3532ca46f8217ab4a7215051eb9a7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_length&lt;/code&gt;&lt;/b&gt;: tensor &lt;code&gt;(samples, )&lt;/code&gt; containing the sequence length for each batch item in &lt;code&gt;y_pred&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a24420a1ec1fd01a361557df84d337cd17f2849" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_length&lt;/code&gt;&lt;/b&gt;: tensor &lt;code&gt;(samples, 1)&lt;/code&gt; containing the sequence length for each batch item in &lt;code&gt;y_pred&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30aac239a050e26bc1fa2189daf8a8cea76a371a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_map&lt;/code&gt;&lt;/b&gt;: A dictionary mapping input names (as strings) in &lt;code&gt;graph_def&lt;/code&gt; to &lt;code&gt;Tensor&lt;/code&gt; objects. The values of the named input tensors in the imported graph will be re-mapped to the respective &lt;code&gt;Tensor&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a714334e0c62629f11218f46e1b4ca8c84dde84f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_max&lt;/code&gt;&lt;/b&gt;: If range_given=True, the maximum input value that needs to be represented in the quantized representation. If axis is specified, this should be a vector of maximum values for each slice along axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a694387cf0bca6ce0d2bd30434931cb2aa338a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_maxes&lt;/code&gt;&lt;/b&gt;: A list with the same length as &lt;code&gt;values&lt;/code&gt; of &lt;code&gt;Tensor&lt;/code&gt; objects with type &lt;code&gt;float32&lt;/code&gt;. The maximum scalar values for each of the input tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e711d594bb1ea87fd2db39733c13b0fca98be8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_min&lt;/code&gt;&lt;/b&gt;: If range_given=True, the minimum input value, that needs to be represented in the quantized representation. If axis is specified, this should be a vector of minimum values for each slice along axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b311abcee4e6827c8d7a71e154e696b816657519" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_mins&lt;/code&gt;&lt;/b&gt;: A list with the same length as &lt;code&gt;values&lt;/code&gt; of &lt;code&gt;Tensor&lt;/code&gt; objects with type &lt;code&gt;float32&lt;/code&gt;. The minimum scalar values for each of the input tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe893884488ded5c54b01db3b6b818ff58920c5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_output_dtype&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;dtype&lt;/code&gt; for input/output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5da816d5368c68a746ca91afcd88255cc7f86f97" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_partition_dims&lt;/code&gt;&lt;/b&gt;: A nested list to describe the partition dims for all the tensors from input_fn(). The structure of input_partition_dims must match the structure of &lt;code&gt;features&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; from input_fn(). The total number of partitions must match &lt;code&gt;num_cores_per_replica&lt;/code&gt;. For example, if input_fn() returns two tensors: images with shape [N, H, W, C] and labels [N]. input_partition_dims = [[1, 2, 2, 1], None] will split the images to 4 pieces and feed into 4 TPU cores. labels tensor are directly broadcasted to all the TPU cores since the partition dims is &lt;code&gt;None&lt;/code&gt;. Current limitations: This feature is only supported with the PER_HOST_V2 input mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="632d13b0adc014f7c532006ffd221e6d970c1446" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_pipeline_id&lt;/code&gt;&lt;/b&gt;: the current input pipeline id, should be an int in [0,&lt;code&gt;num_input_pipelines&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="305816db5a8ed9d20ed37b153b31a65d9df41ca6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_receiver_fn_map&lt;/code&gt;&lt;/b&gt;: dict of &lt;a href=&quot;../../../../estimator/modekeys&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;input_receiver_fn&lt;/code&gt; mappings, where the &lt;code&gt;input_receiver_fn&lt;/code&gt; is a function that takes no arguments and returns the appropriate subclass of &lt;code&gt;InputReceiver&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="680fe0d2c2eb0ae75012f260ff8c2cfffedb6939" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_receiver_fn_map&lt;/code&gt;&lt;/b&gt;: dict of &lt;a href=&quot;../../../estimator/modekeys&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;input_receiver_fn&lt;/code&gt; mappings, where the &lt;code&gt;input_receiver_fn&lt;/code&gt; is a function that takes no arguments and returns the appropriate subclass of &lt;code&gt;InputReceiver&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66c2f9d309fae4e482c9f55bac3521768832ffc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_receiver_fn_map&lt;/code&gt;&lt;/b&gt;: dict of &lt;a href=&quot;../modekeys&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;input_receiver_fn&lt;/code&gt; mappings, where the &lt;code&gt;input_receiver_fn&lt;/code&gt; is a function that takes no arguments and returns the appropriate subclass of &lt;code&gt;InputReceiver&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba5fd02d86b45424dcaa89e9d34e4114a0a3aea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_receiver_fn_map&lt;/code&gt;&lt;/b&gt;: dict of &lt;a href=&quot;modekeys&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;input_receiver_fn&lt;/code&gt; mappings, where the &lt;code&gt;input_receiver_fn&lt;/code&gt; is a function that takes no arguments and returns the appropriate subclass of &lt;code&gt;InputReceiver&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2afaef9168ac2ff1e3eb062404de36cef87bf243" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_saved_model_dir&lt;/code&gt;&lt;/b&gt;: the directory to load the SavedModel which contains the input graph to transforms. Used only when input_graph_def is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f28f84a5dfc3bf13bd3ddc686a34e96a34a2502d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_saved_model_signature_key&lt;/code&gt;&lt;/b&gt;: the key of the signature to optimize the graph for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0364abac561a2e42624026172069a7e455a74d55" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_saved_model_tags&lt;/code&gt;&lt;/b&gt;: list of tags to load the SavedModel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1f7b4a26baf7af0fe118a051c9b3b7528f2f91a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_shape&lt;/code&gt;&lt;/b&gt;: Instance of &lt;code&gt;TensorShape&lt;/code&gt;, or list of instances of &lt;code&gt;TensorShape&lt;/code&gt; if the layer expects a list of inputs (one instance per input).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c890c418ed39a6a4e37af6ea07b0f13bd9e75cd8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_shape&lt;/code&gt;&lt;/b&gt;: Shape tuple (not including the batch axis), or &lt;code&gt;TensorShape&lt;/code&gt; instance (not including the batch axis).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e141f7991bfe79ed4506147e66a4f1907134776" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_shape&lt;/code&gt;&lt;/b&gt;: Shape tuple (tuple of integers) or list of shape tuples (one per output tensor of the layer). Shape tuples can include None for free dimensions, instead of an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeed6da3d16bb0b827db8ce67e88f8d090d9550b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_shape&lt;/code&gt;&lt;/b&gt;: int32 Tensor of shape [N].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f9ce92abffa5a2c65d318c687bd189c57da7935" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_shapes&lt;/code&gt;&lt;/b&gt;: Dict of strings representing input tensor names to list of integers representing input shapes (e.g., {&quot;foo&quot; : [1, 16, 16, 3]}). Automatically determined when input shapes is None (e.g., {&quot;foo&quot; : None}). (default None)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8695c12ba7bbb70a1d87f4e924e34bc4f046c24e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_shard_axes&lt;/code&gt;&lt;/b&gt;: A list of dimensions along which to shard &lt;code&gt;inputs&lt;/code&gt;, or &lt;code&gt;None&lt;/code&gt;. &lt;code&gt;None&lt;/code&gt; means &quot;shard all inputs along dimension 0&quot;. If not &lt;code&gt;None&lt;/code&gt;, there must be one dimension per input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f57a5c5d1c367fc5773492e4dc8cf0a0026e313" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_signature&lt;/code&gt;&lt;/b&gt;: A possibly nested sequence of &lt;a href=&quot;../../../../tensorspec&quot;&gt;&lt;code&gt;tf.TensorSpec&lt;/code&gt;&lt;/a&gt; objects, used to specify the expected model inputs. See &lt;a href=&quot;../../../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84cec33b4c2bb6cab27c7c5a79276f18265b3686" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_signature&lt;/code&gt;&lt;/b&gt;: A possibly nested sequence of &lt;a href=&quot;tensorspec&quot;&gt;&lt;code&gt;tf.TensorSpec&lt;/code&gt;&lt;/a&gt; objects specifying the shapes and dtypes of the Tensors that will be supplied to this function. If &lt;code&gt;None&lt;/code&gt;, a separate function is instantiated for each inferred input signature. If input_signature is specified, every input to &lt;code&gt;func&lt;/code&gt; must be a &lt;code&gt;Tensor&lt;/code&gt;, and &lt;code&gt;func&lt;/code&gt; cannot accept &lt;code&gt;**kwargs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56227106d64f6d129a2143bd896d67bfa8d473fd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_signature&lt;/code&gt;&lt;/b&gt;: Single TensorSpec or nested structure of TensorSpec objects, describing a candidate input for the layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="985f561c246987714c1298afff78cc033ded944b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_size&lt;/code&gt;&lt;/b&gt;: (optional) (possibly nested tuple of) &lt;code&gt;TensorShape&lt;/code&gt; objects containing the depth(s) of the input tensors expected to be passed in to the &lt;code&gt;DropoutWrapper&lt;/code&gt;. Required and used &lt;strong&gt;iff&lt;/strong&gt;&lt;code&gt;variational_recurrent = True&lt;/code&gt; and &lt;code&gt;input_keep_prob &amp;lt; 1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85607e6bc93b560d015e9784a488ff1f7375def6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_sizes&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;int32&lt;/code&gt;. An integer vector representing the shape of &lt;code&gt;input&lt;/code&gt;, based on &lt;code&gt;data_format&lt;/code&gt;. For example, if &lt;code&gt;data_format&lt;/code&gt; is 'NHWC' then &lt;code&gt;input&lt;/code&gt; is a 4-D &lt;code&gt;[batch, height, width, channels]&lt;/code&gt; tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e09fc92a6cf8f9b5ae9e5d4a68bcea0c2f69c109" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_sizes&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;int32&lt;/code&gt;. An integer vector representing the shape of &lt;code&gt;input&lt;/code&gt;, where &lt;code&gt;input&lt;/code&gt; is a 4-D &lt;code&gt;[batch, height, width, channels]&lt;/code&gt; tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b953bf6d4371b85f0a9a7702f142844ace8007a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_spec&lt;/code&gt;&lt;/b&gt;: Optional (list of) &lt;code&gt;InputSpec&lt;/code&gt; object(s) specifying the constraints on inputs that can be accepted by the layer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df4dfddd942a6386664453124efafe4730b44804" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_tensor&lt;/code&gt;&lt;/b&gt;: A tensor with the rows to produce. Must be at least one-dimensional. Must either have a fully-defined shape, or &lt;code&gt;element_shape&lt;/code&gt; must be defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d5dd88f7c13296ed61345f856c8b1779c96396d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_tensor&lt;/code&gt;&lt;/b&gt;: Optional tensor to use as layer input instead of creating a placeholder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8388acfb4d9018a72c5d08f3c13a530f71ba23d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_tensor&lt;/code&gt;&lt;/b&gt;: The boolean tensor to reduce.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30439345de76ec0871bca508b8870ba6c0a8ef55" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_tensor&lt;/code&gt;&lt;/b&gt;: The tensor to reduce. Should be of numeric type, &lt;code&gt;bool&lt;/code&gt;, or &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77075ab827d288cd719cf73215c9631471127f16" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_tensor&lt;/code&gt;&lt;/b&gt;: The tensor to reduce. Should have numeric type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b9af961e425aa23c978137b7d80fef2997847ff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_tensor&lt;/code&gt;&lt;/b&gt;: The tensor to reduce. Should have real numeric type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c96882a1c67bc6c7b1f1af09956f9fd4d03e93" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_tensors&lt;/code&gt;&lt;/b&gt;: List of input tensors. Type and shape are computed using &lt;code&gt;foo.shape&lt;/code&gt; and &lt;code&gt;foo.dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ea11df2dd8ce66998ffd0c01653e4afc093c369" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_tensors&lt;/code&gt;&lt;/b&gt;: optional list of input tensors or InputLayer objects to build the model upon. If not provided, placeholders will be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92245df6d7c80236ca1ff34789376ee5d3ebe6b0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_types&lt;/code&gt;&lt;/b&gt;: (Optional.) A list of &lt;code&gt;DType&lt;/code&gt;s that will be the types of the tensors that the operation consumes. By default, uses the base &lt;code&gt;DType&lt;/code&gt; of each input in &lt;code&gt;inputs&lt;/code&gt;. Operations that expect reference-typed inputs must specify &lt;code&gt;input_types&lt;/code&gt; explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4b81a1e12a28abd8cd3325a6de04f9cc0a6717" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;input_types&lt;/code&gt;&lt;/b&gt;: List of &lt;code&gt;DType&lt;/code&gt; objects representing the types of the tensors accepted by the &lt;code&gt;Operation&lt;/code&gt;. By default uses &lt;code&gt;[x.dtype.base_dtype for x in inputs]&lt;/code&gt;. Operations that expect reference-typed inputs must specify these explicitly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8444bc0396754d8d165b8777bb046e8b333013b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: 3-D &lt;code&gt;float&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; sized &lt;code&gt;[max_time, batch_size, num_classes]&lt;/code&gt;. The logits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30955e1e3f30255ad0c27063286cf7a68e9a837" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: 3-D &lt;code&gt;float&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;, size &lt;code&gt;[max_time x batch_size x num_classes]&lt;/code&gt;. The logits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="149a7f7675ab7216f1de726faa8dcd1fa90b9cb5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: 3-D &lt;code&gt;float&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;, size &lt;code&gt;[max_time, batch_size, num_classes]&lt;/code&gt;. The logits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b2a06836ea0ef15778259308b56f2fb2c2eda3e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: 3-D &lt;code&gt;float&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;. If time_major == False, this will be a &lt;code&gt;Tensor&lt;/code&gt; shaped: &lt;code&gt;[batch_size, max_time, num_classes]&lt;/code&gt;. If time_major == True (default), this will be a &lt;code&gt;Tensor&lt;/code&gt; shaped: &lt;code&gt;[max_time, batch_size, num_classes]&lt;/code&gt;. The logits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de02ea5d91ae3c7a80211c3e470e760f7d81dbda" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: 3D tensor with shape: (batch_size, steps, input_dim) if data_format is &quot;channels_last&quot; or (batch_size, input_dim, steps) if data_format is &quot;channels_first&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9004a9924d68b0ac95a917a530847dab22e929" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: 4D tensor with shape: (batch_size, filters, new_rows, new_cols) if data_format='channels_first' or 4D tensor with shape: (batch_size, new_rows, new_cols, filters) if data_format='channels_last'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afbabda7a9995a146861ed58aac53f8b3cfc712d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A 2D tensor, with shape of &lt;code&gt;[batch, feature]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77510f0e5b63f282e933d75e32e77023a6537c1d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A 2D tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f26397b014b02d187bb8caf9569aeaf6546a79" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A 3D tensor with shape &lt;code&gt;[batch, timesteps, feature]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca243e93cb40f697fea183cf53ed3bb5fa3ffe1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A 3D tensor, with shape &lt;code&gt;[batch, timesteps, feature]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d07932e18b450fc247a27fcf065e25994d3f59f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A 3D tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c80e9b22cf7285339ca18e33235816fce6cadf26" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A 4D tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee48b5b068ac7397f3c322f1987108f8b5054e3f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A 5D tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da8b1bda12a6e33a7c770c872d978518d7f0a36d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../tf#string&quot;&gt;&lt;code&gt;tf.string&lt;/code&gt;&lt;/a&gt; tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7af5441ffae491c6350b5fb1f3d6f945b7a55e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../tf#string&quot;&gt;&lt;code&gt;tf.string&lt;/code&gt;&lt;/a&gt; tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b4df551119cc8daf5c896c6beb08fd3476c5e3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[batch_size, dim]&lt;/code&gt;. The forward activations of the input network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81434c2b80eb9b0073929be6b1831565b25f1b6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0d7106a9ae2d76d87b3f741c8f0814eb142816" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt;. Values passed as inputs to the FakeQuantWithMinMaxArgs operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5467a962c0d9084f8a55f2052d7a37765bc67eb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt;. Values passed as inputs to the FakeQuantWithMinMaxVars operation, shape same as &lt;code&gt;gradients&lt;/code&gt;. min, max: Quantization interval, floats of shape &lt;code&gt;[d]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6acf211857175d69dade1ccd041a0a07378bd173" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt;. Values passed as inputs to the FakeQuantWithMinMaxVars operation. min, max: Quantization interval, scalar floats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd5c1541b04d0e1a29c68fb12c7b2d2f9f17959" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. The input to be joined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb4a8342394528545dabb961a91b9074704d7f3c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A length T list of inputs, each a &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[batch_size, input_size]&lt;/code&gt;, or a nested tuple of such elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56228ff5ca196b452ab5548116ff5c95675c56ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A length T list of inputs, each a &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[batch_size, input_size]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="635820f05ff7b93317f8849e590664d073f81772" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A length T list of inputs, each a tensor of shape [batch_size, input_size], or a nested tuple of such elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9311a35821968141f1c70d1de5488f0f1c99ac70" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A list of &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; objects, each with same shape and type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a6f435f42e3b03e94e09744e91299e5526d664" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;Tensor&lt;/code&gt; objects that will be inputs to the &lt;code&gt;Operation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8852a5b0d4c838fdcb06a949704da8d0c239dfe3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;Tensor&lt;/code&gt; objects, each with same shape and type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed643e04410c4709df9b8190e393543831024e1a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;Tensor&lt;/code&gt; objects, or a single Tensor. The list of tensors to format into the template string. If a solitary tensor is passed in, the input tensor will automatically be wrapped as a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ad95e5ac3a03522dac20d41200c23ede700a576" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;string&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; objects containing serialized &lt;code&gt;Summary&lt;/code&gt; protocol buffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d073e60d0136e62407c435cffa8d03fb6094946c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A list of at least 1 &lt;code&gt;Tensor&lt;/code&gt; objects with type &lt;code&gt;string&lt;/code&gt;. A list of string tensors. The tensors must all have the same shape, or be scalars. Scalars may be mixed in; these will be broadcast to the shape of non-scalar inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8c70e662ed8910c080df23cc754fcb73cf05e83" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A list of input tensors or &lt;code&gt;None&lt;/code&gt; (equivalent to an empty list). Each input can be a nested structure containing values that are convertible to tensors. Note that passing an N-dimension list of compatible values will result in a N-dimention list of scalar tensors rather than a single Rank-N tensors. If you need different behavior, convert part of inputs to tensors with &lt;a href=&quot;../../../convert_to_tensor&quot;&gt;&lt;code&gt;tf.convert_to_tensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0eabd6ee6297f83f4ca3ad15863f118a555c04" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A list of input tensors or None (equivalent to an empty list). Each input tensor has a corresponding shard axes, given by &lt;code&gt;input_shard_axes&lt;/code&gt;, which must have size divisible by &lt;code&gt;num_shards&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74bdccc5e43f8c7178931076cd2bb6b6c784038c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A list of input tensors or None (equivalent to an empty list). The 0-th dimension of each Tensor must have size divisible by &lt;code&gt;num_shards&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8c99bd948d0f5290f1b74bf3bb28c87301efdd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A list of inputs or &lt;code&gt;None&lt;/code&gt; (equivalent to an empty list). Each input can be a nested structure containing values that are convertible to tensors. Note that passing an N-dimension list of compatible values will result in a N-dimension list of scalar tensors rather than a single Rank-N tensors. If you need different behavior, convert part of inputs to tensors with &lt;a href=&quot;../../convert_to_tensor&quot;&gt;&lt;code&gt;tf.convert_to_tensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf56016449ab40673c3f8ff147cdfc1900e8184" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: A list of lists of input tensors or &lt;code&gt;None&lt;/code&gt; (equivalent to &lt;code&gt;[[]]&lt;/code&gt;), indexed by &lt;code&gt;[replica_num][input_num]&lt;/code&gt;. All replicas must have the same number of inputs. Each input can be a nested structure containing values that are convertible to tensors. Note that passing an N-dimension list of compatible values will result in a N-dimension list of scalar tensors rather than a single Rank-N tensors. If you need different behavior, convert part of inputs to tensors with &lt;a href=&quot;../../../convert_to_tensor&quot;&gt;&lt;code&gt;tf.convert_to_tensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7adb76a79e9f58ffb3a567beeaf426c433ea4fa7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: An iterable of &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a022b3e1cfb84750b452b59395b7fb644ae35d25" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: Deprecated, will be automatically inferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b31694e36ab292299bf47dc312d159f436a0938" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: Ignored when executing eagerly. If anything other than None is passed, it signals the losses are conditional on some of the layer's inputs, and thus they should only be run where these inputs are available. This is the case for activity regularization losses, for instance. If &lt;code&gt;None&lt;/code&gt; is passed, the losses are assumed to be unconditional, and will apply across all dataflows of the layer (e.g. weight regularization losses).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2abacdc9bf9f71cffb64fe1e4934788f12779f42" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: Input tensor (of any rank).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40bb1ef62f9948aa2dae06ef3ab395773709448e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: Input tensor or list/tuple of input tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b49918d506f9556f75f606f572db620bf3eb7507" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: Input tensor, or list/tuple of input tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa65cd26086da32d732cb52678f00754d90f7aa0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: Input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b0c62227969b4f5a9e95efe9c866aa6b8a1c7f4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: Inputs of the SignatureDef defined as a proto map of string to tensor info.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e82c737b6e318b87af69363188a33d761a222b1f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: List of placeholder tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2b825a16c98867225f40daefbc7412d0aad924" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: List of the following tensors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b0e295016ce6a22b920007cc658d0aecd4805e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: Tensor input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="814347e9982d91b954208900bfa480086b74183d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: Tensor of temporal data of shape &lt;code&gt;(samples, time, ...)&lt;/code&gt; (at least 3D), or nested tensors, and each of which has shape &lt;code&gt;(samples, time, ...)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e582d78b98dc38753ee8d8c7d1193d906a41778a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: Tensor or list of tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f09f18474e15f1b293781cdc36b38a51e7fb346b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: The RNN inputs. If &lt;code&gt;time_major == False&lt;/code&gt; (default), this must be a &lt;code&gt;Tensor&lt;/code&gt; of shape: &lt;code&gt;[batch_size, max_time, ...]&lt;/code&gt;, or a nested tuple of such elements. If &lt;code&gt;time_major == True&lt;/code&gt;, this must be a &lt;code&gt;Tensor&lt;/code&gt; of shape: &lt;code&gt;[max_time, batch_size, ...]&lt;/code&gt;, or a nested tuple of such elements. This may also be a (possibly nested) tuple of Tensors satisfying this property. The first two dimensions must match across all the inputs, but otherwise the ranks and other shape components may differ. In this case, input to &lt;code&gt;cell&lt;/code&gt; at each time-step will replicate the structure of these tuples, except for the time dimension (from which the time is taken). The input to &lt;code&gt;cell&lt;/code&gt; at each time step will be a &lt;code&gt;Tensor&lt;/code&gt; or (possibly nested) tuple of Tensors each with dimensions &lt;code&gt;[batch_size, ...]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1608ce7e22a1e2990bf8272d1ea4b691b8ba98e6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: The RNN inputs. If time_major == False (default), this must be a tensor of shape: &lt;code&gt;[batch_size, max_time, ...]&lt;/code&gt;, or a nested tuple of such elements. If time_major == True, this must be a tensor of shape: &lt;code&gt;[max_time, batch_size, ...]&lt;/code&gt;, or a nested tuple of such elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49fecc9fccce36519ff8bf3fd397c8b482a6aaa3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: The tensor over which to pool. Must have rank 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e00f5b98ba983ad0329f5b47df33692b7e5c754c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: The tensor over which to pool. Must have rank 4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ac1f1cfad3dac768ef165112ce3313701d8142" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: The tensor over which to pool. Must have rank 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5249237aa50c7ae8606c52498b3cae7a850075a5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: dict mapping string input names to tensors. These are added to the SignatureDef as the inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb20ca53adeb6860943dee5157fef69a56b31d8a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: dict of string to &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a3d0563ba9834f41af01867290d1c6ad47703c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: input tensor(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe13aacbf66ecb41b5df243442e1465ced3827b1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inputs&lt;/code&gt;&lt;/b&gt;: list of &lt;code&gt;Tensor&lt;/code&gt; objects. The inputs to this &lt;code&gt;Operation&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff86740abf0431e02b55a35add859112f00d1260" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;instance_group&lt;/code&gt;&lt;/b&gt;: Name of the GCE instance group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7121629e2be1ad31dfba9e789b2da9f00a21f171" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;internal&lt;/code&gt;&lt;/b&gt;: True if the constructor is being called by one of the factory methods. If false, an exception will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5b33bb66e6ca47458fd2a6508ec561d1671241" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;interpolation&lt;/code&gt;&lt;/b&gt;: A string, one of &lt;code&gt;nearest&lt;/code&gt; or &lt;code&gt;bilinear&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94fcc63134551f5b616255185a6e6cdbaf561644" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;interpolation&lt;/code&gt;&lt;/b&gt;: Interpolation method used to resample the image if the target size is different from that of the loaded image. Supported methods are &quot;nearest&quot;, &quot;bilinear&quot;, and &quot;bicubic&quot;. If PIL version 1.1.3 or newer is installed, &quot;lanczos&quot; is also supported. If PIL version 3.4.0 or newer is installed, &quot;box&quot; and &quot;hamming&quot; are also supported. By default, &quot;nearest&quot; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ea9c87cbc22129b6a9df30b146f74e15ceb556" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;interval&lt;/code&gt;&lt;/b&gt;: Minimum visual progress update interval (in seconds).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dbcc8ef251d70d68880fcaec3b6ff0ffb7af315" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inv_x&lt;/code&gt;&lt;/b&gt;: The matrix_inv, i.e., &lt;code&gt;tf.matrix_inverse(tf.linalg.lu_reconstruct(lu, perm))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a10a95e55e1e45b48729c94e0ad4704b230b269" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;inverse_link_fn&lt;/code&gt;&lt;/b&gt;: Optional inverse link function, also known as 'mean function'. Defaults to identity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20f74362728c8a7a44294d482947cb0a79aa1f40" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;iou_threshold&lt;/code&gt;&lt;/b&gt;: A float representing the threshold for deciding whether boxes overlap too much with respect to IOU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2cac3a624b034cab0f28bb170fee32035ce5732" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_chief&lt;/code&gt;&lt;/b&gt;: If &lt;code&gt;True&lt;/code&gt;, it will take care of initialization and recovery the underlying TensorFlow session. If &lt;code&gt;False&lt;/code&gt;, it will wait on a chief to initialize or recover the TensorFlow session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca8d99acb802d5d0c800c80fab0a43a0595f3fc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_chief&lt;/code&gt;&lt;/b&gt;: If True, create a chief supervisor in charge of initializing and restoring the model. If False, create a supervisor that relies on a chief supervisor for inits and restore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04a5391c422bfebf925df28b8344efcb9263f426" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_diag_update_positive&lt;/code&gt;&lt;/b&gt;: Python &lt;code&gt;bool&lt;/code&gt;. If &lt;code&gt;True&lt;/code&gt;, expect &lt;code&gt;diag_update &amp;gt; 0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e5c37b4e60b676ab1d258703678508e1b3c7378" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_non_singular&lt;/code&gt;&lt;/b&gt;: Expect that this operator is non-singular.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb810cfe456cfbde50ff9435bbbe29b3f5de319a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_non_singular&lt;/code&gt;&lt;/b&gt;: Expect that this operator is non-singular. Default is &lt;code&gt;None&lt;/code&gt;, unless &lt;code&gt;is_positive_definite&lt;/code&gt; is auto-set to be &lt;code&gt;True&lt;/code&gt; (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b13e174a4114a4480d48e74138beface916053c4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_non_singular&lt;/code&gt;&lt;/b&gt;: Expect that this operator is non-singular. This operator is non-singular if and only if its diagonal elements are all non-zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efeef65ed10ba2e27e6eef7067b0f25144f26e3a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_positive_definite&lt;/code&gt;&lt;/b&gt;: Expect that this operator is positive definite, meaning the quadratic form &lt;code&gt;x^H A x&lt;/code&gt; has positive real part for all nonzero &lt;code&gt;x&lt;/code&gt;. Note that we do not require the operator to be self-adjoint to be positive-definite. See: https://en.wikipedia.org/wiki/Positive-definite_matrix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21278b33545a3097dc79a963a380f4d0c11eb40d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_positive_definite&lt;/code&gt;&lt;/b&gt;: Expect that this operator is positive definite, meaning the quadratic form &lt;code&gt;x^H A x&lt;/code&gt; has positive real part for all nonzero &lt;code&gt;x&lt;/code&gt;. Note that we do not require the operator to be self-adjoint to be positive-definite. See: https://en.wikipedia.org/wiki/Positive-definite_matrix#Extension_for_non-symmetric_matrices</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34af64ad432b0afdb145a3facf94ee9aef16940c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_positive_definite&lt;/code&gt;&lt;/b&gt;: Expect that this operator is positive definite, meaning the quadratic form &lt;code&gt;x^H A x&lt;/code&gt; has positive real part for all nonzero &lt;code&gt;x&lt;/code&gt;. Note that we do not require the operator to be self-adjoint to be positive-definite. See: https://en.wikipedia.org/wiki/Positive-definite_matrix#Extension_for_non-symmetric_matrices This is autoset to false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6e91cb6d08274bbc6aefbe2ea75b4b59ee3839" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_positive_definite&lt;/code&gt;&lt;/b&gt;: Expect that this operator is positive definite, meaning the real part of all eigenvalues is positive. We do not require the operator to be self-adjoint to be positive-definite. See: https://en.wikipedia.org/wiki/Positive-definite_matrix #Extension_for_non_symmetric_matrices</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcfed99748a5ef784ac75b9b020e114be9cbe730" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_positive_definite&lt;/code&gt;&lt;/b&gt;: Expect that this operator is positive definite. Default is &lt;code&gt;None&lt;/code&gt;, unless &lt;code&gt;base_operator&lt;/code&gt; is positive-definite &lt;code&gt;v = None&lt;/code&gt; (meaning &lt;code&gt;u=v&lt;/code&gt;), and &lt;code&gt;is_diag_update_positive&lt;/code&gt;, in which case this defaults to &lt;code&gt;True&lt;/code&gt;. Note that we say an operator is positive definite when the quadratic form &lt;code&gt;x^H A x&lt;/code&gt; has positive real part for all nonzero &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff9311deeb6a723ce2382a05ee1e6c9582ff84bb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_scalar_batch&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;bool&lt;/code&gt; scalar &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f7358f2abd3904913bfc567b7c84aecc9ee880f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_scalar_event&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;bool&lt;/code&gt; scalar &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e585e85e3c1dd8b5dd1efb3a2d4be3d023965af" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_self_adjoint&lt;/code&gt;&lt;/b&gt;: Expect that this operator is equal to its hermitian transpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd5810f2870caffa35bc3e63ac468739ad0a5368" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_self_adjoint&lt;/code&gt;&lt;/b&gt;: Expect that this operator is equal to its hermitian transpose. Default is &lt;code&gt;None&lt;/code&gt;, unless &lt;code&gt;base_operator&lt;/code&gt; is self-adjoint and &lt;code&gt;v = None&lt;/code&gt; (meaning &lt;code&gt;u=v&lt;/code&gt;), in which case this defaults to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad9894a100f45f76deeae6a0d769472e5b05c024" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_self_adjoint&lt;/code&gt;&lt;/b&gt;: Expect that this operator is equal to its hermitian transpose. If &lt;code&gt;diag.dtype&lt;/code&gt; is real, this is auto-set to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c04c7cc6dcf3985c395338edfa861944207fc55" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_self_adjoint&lt;/code&gt;&lt;/b&gt;: Expect that this operator is equal to its hermitian transpose. If &lt;code&gt;dtype&lt;/code&gt; is real, this is equivalent to being symmetric.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eef3796766f7d6dfc46776dcbf7bb51f8e99203" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_self_adjoint&lt;/code&gt;&lt;/b&gt;: Expect that this operator is equal to its hermitian transpose. If &lt;code&gt;spectrum&lt;/code&gt; is real, this will always be true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186c69ad485d789c99e3984113bf9d9e7ab57134" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_self_adjoint&lt;/code&gt;&lt;/b&gt;: Expect that this operator is equal to its hermitian transpose. This is autoset to true</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e16b5d28476c319a145fd4f1dcc6feb011c92db5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_self_adjoint&lt;/code&gt;&lt;/b&gt;: Expect that this operator is equal to its hermitian transpose. This operator is self-adjoint only if it is diagonal with real-valued diagonal entries. In this case it is advised to use &lt;code&gt;LinearOperatorDiag&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d7a6d7b9187997bef9f59970767567d656f637e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_square&lt;/code&gt;&lt;/b&gt;: Expect that this operator acts like square [batch] matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5cb74062cc0e3f7ade22f5fd156ce6c3c5b810d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_square&lt;/code&gt;&lt;/b&gt;: Expect that this operator acts like square [batch] matrices. This is autoset to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="748b11381a9c928a814ea34f6fba68989c97518a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_square&lt;/code&gt;&lt;/b&gt;: Expect that this operator acts like square [batch] matrices. This is true by default, and will raise a &lt;code&gt;ValueError&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556c51c3211551ecdd2cfc41401d67f5b4029759" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_the_final_export&lt;/code&gt;&lt;/b&gt;: This boolean is True when this is an export in the end of training. It is False for the intermediate exports during the training. When passing &lt;code&gt;Exporter&lt;/code&gt; to &lt;a href=&quot;train_and_evaluate&quot;&gt;&lt;code&gt;tf.estimator.train_and_evaluate&lt;/code&gt;&lt;/a&gt;&lt;code&gt;is_the_final_export&lt;/code&gt; is always False if &lt;a href=&quot;trainspec#max_steps&quot;&gt;&lt;code&gt;TrainSpec.max_steps&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c568f31207af3576a5216b82577960decc749096" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_training&lt;/code&gt;&lt;/b&gt;: A bool value to specify if the operation is used for training or inference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44e16a00d19a58848f57c86080602c6a8ff44429" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;is_true&lt;/code&gt;&lt;/b&gt;: If true, only account statistics of nodes eventually displayed by the outputs. Otherwise, a node's statistics are accounted by its parents as long as it's types match 'account_type_regexes', even if it is hidden from the output, say, by hide_name_regexes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abcda6f0a22f50c06f8429089c45dd89f3a2022" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;iterations&lt;/code&gt;&lt;/b&gt;: (Optional) Number of iterations that &lt;code&gt;fn&lt;/code&gt; should be run. Defaults to 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d018c7d461b8f52a42e2fa39cd84380ec452666a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;iterations_per_loop&lt;/code&gt;&lt;/b&gt;: This is the number of train steps running in TPU system before returning to CPU host for each &lt;code&gt;Session.run&lt;/code&gt;. This means global step is increased &lt;code&gt;iterations_per_loop&lt;/code&gt; times in one &lt;code&gt;Session.run&lt;/code&gt;. It is recommended to be set as number of global steps for next checkpoint. Note that in evaluation don't use this value, instead we run total eval &lt;code&gt;steps&lt;/code&gt; on TPU for a single &lt;code&gt;Session.run&lt;/code&gt;. [Experimental]: &lt;code&gt;iterations_per_loop&lt;/code&gt; can be specified as a time interval. To specify N seconds in one &lt;code&gt;Session.run&lt;/code&gt;, one can specify it as &lt;code&gt;Ns&lt;/code&gt; and substitute the N with the N with the number of desired seconds. Alternatively, the unit of time can also be specified in minutes or hours, e.g. &lt;code&gt;3600s&lt;/code&gt; or &lt;code&gt;60m&lt;/code&gt; or &lt;code&gt;1h&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="848b3e891b34c347d20c948334861fb2af43a0f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;iterator&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../compat/v1/data/iterator&quot;&gt;&lt;code&gt;tf.compat.v1.data.Iterator&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e757551f85dce78791ecd1241b7b266522bad57" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;iterator&lt;/code&gt;&lt;/b&gt;: Iterator of a dataset that represents the input for &lt;code&gt;fn&lt;/code&gt;. The caller is responsible for initializing the iterator as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a6424723b679e647f14fcd48393be20c648baad" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;iterator&lt;/code&gt;&lt;/b&gt;: Iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc15aa99605b7c0b0c211c0727a284b6e0b1129" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;iterator_resource&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../../tf#resource&quot;&gt;&lt;code&gt;tf.resource&lt;/code&gt;&lt;/a&gt; scalar &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; representing the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8680d82a084cca43c40f2f04c3fc009b4ce17a83" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;iters&lt;/code&gt;&lt;/b&gt;: (optional) How many iterations were run</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b68ddb11cdd39b9ee89838c1a610df9c9677424" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;job&lt;/code&gt;&lt;/b&gt;: The job (the XXX in TensorFlow device specification /job:XXX) that contains the TPU devices that will be initialized. If job=None it is assumed there is only one job in the TensorFlow flock, and an error will be returned if this assumption does not hold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c24b07a583d4139a02af6c5519beea6a4e6810ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;job&lt;/code&gt;&lt;/b&gt;: The job (the XXX in TensorFlow device specification /job:XXX) that contains the TPU devices that will be shutdown. If job=None it is assumed there is only one job in the TensorFlow flock, and an error will be returned if this assumption does not hold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9749e73aaf879cb0b7ff13415b37593cc9392c1a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;job&lt;/code&gt;&lt;/b&gt;: string. Optional job name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d23f78777158f2076263a65b37befb09b8fab06" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;job_name&lt;/code&gt;&lt;/b&gt;: (Optional.) Specifies the name of the job of which the server is a member. Defaults to the value in &lt;code&gt;server_or_cluster_def&lt;/code&gt;, if specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b19394de525d3d3117abfed69cccb8308425948e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;job_name&lt;/code&gt;&lt;/b&gt;: Name of the TensorFlow job the TPUs belong to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4fba133dfa66deeef6561df8a792074e9077c9c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;job_name&lt;/code&gt;&lt;/b&gt;: The job name under which the new server will be accessible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17a4773aeba8e63f577771bc42fd5f78906b1869" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;job_name&lt;/code&gt;&lt;/b&gt;: The name of the local job.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d5baacbc4e47ea5930fd753bfd1effd41c1e9ea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;job_name&lt;/code&gt;&lt;/b&gt;: The string name of a job in this cluster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0122843d3d22b0ec33365dfba329823c7b40819" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;job_to_label_mapping&lt;/code&gt;&lt;/b&gt;: A mapping of TensorFlow jobs to label selectors. This allows users to specify many TensorFlow jobs in one Cluster Resolver, and each job can have pods belong with different label selectors. For example, a sample mapping might be</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7f8bdb532a13d53387a8119fd1cba14fdb23084" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;jobs&lt;/code&gt;&lt;/b&gt;: Dictionary with job names as key and number of tasks in the job as value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef17d7107c1841e60d3fb87068c5b0a765ea62e6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;jpeg_quality&lt;/code&gt;&lt;/b&gt;: Python int or Tensor of type int32. jpeg encoding quality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1623b2c950daf52cca24ceb9f980204398eeab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;json_examples&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. Each string is a JSON object serialized according to the JSON mapping of the Example proto.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f90931119391a020edb49b7c9a3fca574139ab9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;json_string&lt;/code&gt;&lt;/b&gt;: JSON string encoding a model configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b934232b7b05543a5d1ae3b8f1bd69c7dc7ef382" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;k1&lt;/code&gt;&lt;/b&gt;: Default value 0.01</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c70ea953abd18718621f64085074f64f730278c7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;k2&lt;/code&gt;&lt;/b&gt;: Default value 0.03 (SSIM is less sensitivity to K2 for lower values, so it would be better if we taken the values in range of 0&amp;lt; K2 &amp;lt;0.4).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e940b1150145433281be9de76ee1a9840bafd6cf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;k&lt;/code&gt;&lt;/b&gt;: (Optional) Number of top elements to look at for computing accuracy. Defaults to 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a11da7781e71c2fc0fb351701a9b9f7f1c6432" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;k&lt;/code&gt;&lt;/b&gt;: 0-D &lt;code&gt;int32&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;. Number of top elements to look for along the last dimension (along each row for matrices).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b1bbf9f40cf5933faf0e283865fe7420367e1ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;k&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;int&lt;/code&gt;, number of top elements to consider.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a72cd812e86abc3cee73e7683049b8522149a8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;k&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;int&lt;/code&gt;. Number of top elements to look at for computing precision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ecf1016723bc39aaca037bf23275e347015eb6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;k&lt;/code&gt;&lt;/b&gt;: Diagonal offset(s). Positive value means superdiagonal, 0 refers to the main diagonal, and negative value means subdiagonals. &lt;code&gt;k&lt;/code&gt; can be a single integer (for a single diagonal) or a pair of integers specifying the low and high ends of a matrix band. &lt;code&gt;k[0]&lt;/code&gt; must not be larger than &lt;code&gt;k[1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812c7861ca238ac06549dd5338e2c397acb90fea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;k&lt;/code&gt;&lt;/b&gt;: Integer, k for @k metric.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dda8ab28d690ed5a059ccd407c09dce63e0a7272" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;k&lt;/code&gt;&lt;/b&gt;: Integer, k for @k metric. Only used for the default op name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec601d19d2f58cb3bf9ad7230765cde7a0269179" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;k&lt;/code&gt;&lt;/b&gt;: Integer, k for @k metric. This will calculate an average precision for range &lt;code&gt;[1,k]&lt;/code&gt;, as documented above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d207c52235ec31d51d6a35cc09ca93b2559facf2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt;&lt;/b&gt;: How often to keep checkpoints. Defaults to 10,000 hours.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb620ab818559595de465b46b6b5c6e2593e1c3a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt;&lt;/b&gt;: Number of hours between each checkpoint to be saved. The default value of 10,000 hours effectively disables the feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad4f986bfbc3d95215d278adbd2b6c90b047abe" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt;&lt;/b&gt;: Upon removal from the active set, a checkpoint will be preserved if it has been at least &lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt; since the last preserved checkpoint. The default setting of &lt;code&gt;None&lt;/code&gt; does not preserve any checkpoints in this way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2641feea9ad0d567fa906a0852b67b8150b15c1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keep_checkpoint_max&lt;/code&gt;&lt;/b&gt;: The maximum number of recent checkpoint files to keep. As new files are created, older files are deleted. If &lt;code&gt;None&lt;/code&gt; or 0, all checkpoint files are kept. Defaults to 5 (that is, the 5 most recent checkpoint files are kept.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c6b780ca85a728ec9ef4d6d960cd3ba83d4ede" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keep_dims&lt;/code&gt;&lt;/b&gt;: Deprecated alias for &lt;code&gt;keepdims&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62292e80ee45984a61f2387cbda1e1b65db92cc7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keep_dims&lt;/code&gt;&lt;/b&gt;: Produce moments with the same dimensionality as the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c9f1906de7da8acaf665bce4750a1aa3f3db5f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keep_dims&lt;/code&gt;&lt;/b&gt;: produce moments with the same dimensionality as the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e64fd89f62f5aa5c7f6c39223f7b0b393251a2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keep_dims&lt;/code&gt;&lt;/b&gt;: produce statistics with the same dimensionality as the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1b592a1ee46c79d85a443ffdcd941e8d2df6743" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keep_input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;bool&lt;/code&gt; Tensor. This tensor controls whether the input is added to the queue or not. If it is a scalar and evaluates &lt;code&gt;True&lt;/code&gt;, then &lt;code&gt;tensors&lt;/code&gt; are all added to the queue. If it is a vector and &lt;code&gt;enqueue_many&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then each example is added to the queue only if the corresponding value in &lt;code&gt;keep_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;. This tensor essentially acts as a filtering mechanism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3807283569051c8145124c1d7cfafca5e21d901" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keep_prob&lt;/code&gt;&lt;/b&gt;: (deprecated) A deprecated alias for &lt;code&gt;(1-rate)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450ce8e6a7e4f49d1135f8bd61fc546d2a5e7a27" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keepdims&lt;/code&gt;&lt;/b&gt;: A boolean, whether to keep the dimensions or not. If &lt;code&gt;keepdims&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the rank of the tensor is reduced by 1 for each entry in &lt;code&gt;axis&lt;/code&gt;. If &lt;code&gt;keepdims&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, the reduced dimensions are retained with length 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6bbaf2ab68e53def821997ee8c29ab87c2b05f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keepdims&lt;/code&gt;&lt;/b&gt;: A boolean, whether to keep the dimensions or not. If &lt;code&gt;keepdims&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the rank of the tensor is reduced by 1. If &lt;code&gt;keepdims&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, the reduced dimension is retained with length 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b66e04ddda6c0f436ae5b13526530bd25e0e505" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keepdims&lt;/code&gt;&lt;/b&gt;: Alias for keep_dims.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa3ed93242e120c73c3de0a8993f6ed2c751836e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keepdims&lt;/code&gt;&lt;/b&gt;: Alias of keep_dims.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c3bde3fb17860f1eedefd018827b7ca294608b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keepdims&lt;/code&gt;&lt;/b&gt;: Alias to keep_dims.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f8cd0806e5a18a9c76434fa382d1d5fd8e56548" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keepdims&lt;/code&gt;&lt;/b&gt;: If True, the axis indicated in &lt;code&gt;axis&lt;/code&gt; are kept with size 1. Otherwise, the dimensions in &lt;code&gt;axis&lt;/code&gt; are removed from the output shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d58e092ee3241dd5d6245180590ad3acc549b101" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keepdims&lt;/code&gt;&lt;/b&gt;: If true, retain reduced dimensions with length 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca38e7bdbc61db6009fca9dc2c6602fe304289c4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keepdims&lt;/code&gt;&lt;/b&gt;: If true, retains reduced dimensions with length 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88be27380021c2a403b94f8eb3bd1943a360c7f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keepdims&lt;/code&gt;&lt;/b&gt;: Produce moments with the same dimensionality as the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70863ffd1f806e0ebc0fe976c6f0e28b05e94b70" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keepdims&lt;/code&gt;&lt;/b&gt;: produce moments with the same dimensionality as the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e31c8eb77827931fea1268cbdca7374f6e69b26" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keepdims&lt;/code&gt;&lt;/b&gt;: produce statistics with the same dimensionality as the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9550607d9be526796a26ec945e0c30bcf5d1ad2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keepdims&lt;/code&gt;&lt;/b&gt;: whether the drop or broadcast the reduction axes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb1bd756eeae3665b1c3bb6fbe1b448ac8af49d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keras_model&lt;/code&gt;&lt;/b&gt;: A compiled Keras model object. This argument is mutually exclusive with &lt;code&gt;keras_model_path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f09d196079189edae2c257c8fdc3ecaa3d72280b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keras_model_path&lt;/code&gt;&lt;/b&gt;: Path to a compiled Keras model saved on disk, in HDF5 format, which can be generated with the &lt;code&gt;save()&lt;/code&gt; method of a Keras model. This argument is mutually exclusive with &lt;code&gt;keras_model&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab6d6918beed9822bff8338d342c8ec2172605c0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must have the same type as &lt;code&gt;value&lt;/code&gt;. 3-D with shape &lt;code&gt;[kernel_height, kernel_width, depth]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c973d3b6436301e6eb92d0ab7f42d6b1f41f586a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel&lt;/code&gt;&lt;/b&gt;: Weight matrix (TensorFlow variable or tensor).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35024a7b67b74c3421513c1792d831e51c4f6a59" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel&lt;/code&gt;&lt;/b&gt;: kernel tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cc8f99b1dd39a7336e171202cba66c398f64885" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel&lt;/code&gt;&lt;/b&gt;: the unshared weight for convolution, with shape (output_items, feature_dim, filters).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd47d1ce078f5ee1efb84b26a7fd7475d9a66b4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel&lt;/code&gt;&lt;/b&gt;: the unshared weight for convolution, with shape (output_length, feature_dim, filters).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc5cb250dfaf55f7db612c2c0db7d842adab9ade" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_constraint&lt;/code&gt;&lt;/b&gt;: An optional projection function to be applied to the kernel after being updated by an &lt;code&gt;Optimizer&lt;/code&gt; (e.g. used to implement norm constraints or value constraints for layer weights). The function must take as input the unprojected variable and must return the projected variable (which must have the same shape). Constraints are not safe to use when doing asynchronous distributed training.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6991ad5b79da26c25b6ae7400eef1707c88bc67f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_constraint&lt;/code&gt;&lt;/b&gt;: Constraint function applied to the &lt;code&gt;kernel&lt;/code&gt; weights matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e616efbb61a0999b58d86ba12a9c0d8042cf542" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_constraint&lt;/code&gt;&lt;/b&gt;: Constraint function applied to the &lt;code&gt;kernel&lt;/code&gt; weights matrix. Default: &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba3ba086763f3e311abdc60f10054c598ee0c68" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_constraint&lt;/code&gt;&lt;/b&gt;: Constraint function applied to the kernel matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2e014d63b322cef5dcb92cc7483b8fdfd53314" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_constraint&lt;/code&gt;&lt;/b&gt;: Constraint function for the kernel matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adb161e935ed64b9c191c2c0d2366babde571e5b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_constraint&lt;/code&gt;&lt;/b&gt;: Optional projection function to be applied to the kernel after being updated by an &lt;code&gt;Optimizer&lt;/code&gt; (e.g. used to implement norm constraints or value constraints for layer weights). The function must take as input the unprojected variable and must return the projected variable (which must have the same shape). Constraints are not safe to use when doing asynchronous distributed training.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3059be7168ebfc26e13f277bea614aa404e3911" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_initializer&lt;/code&gt;&lt;/b&gt;: (optional) The initializer to use for the weight and projection matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edbf9c9e53c8226e09cc2d7785a1e1990efd923f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_initializer&lt;/code&gt;&lt;/b&gt;: An initializer for the convolution kernel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2114b7c04727330f418898a7d1e55f2ffebec157" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_initializer&lt;/code&gt;&lt;/b&gt;: Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8833cbbb3ef069787792b98b2602642521613b74" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_initializer&lt;/code&gt;&lt;/b&gt;: Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrix, used for the linear transformation of the inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="466ef22376b305e395b52f6fc9487213623cc103" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_initializer&lt;/code&gt;&lt;/b&gt;: Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrix, used for the linear transformation of the inputs. Default: &lt;code&gt;glorot_uniform&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f573e86abd5f9a40595efb82ab5555a1906139a8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_initializer&lt;/code&gt;&lt;/b&gt;: Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrix, used for the linear transformation of the inputs..</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7afefe2f18b3fff93966ff210adc230e75c5e77f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_initializer&lt;/code&gt;&lt;/b&gt;: Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e92794a5f2e4dab58daccb2974e1f351265a60d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_initializer&lt;/code&gt;&lt;/b&gt;: Initializer function for the weight matrix. If &lt;code&gt;None&lt;/code&gt; (default), weights are initialized using the default initializer used by &lt;a href=&quot;../get_variable&quot;&gt;&lt;code&gt;tf.compat.v1.get_variable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4bbb0f590fb0e6a431fbb7d9ca2450d2d1a6c3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_initializer&lt;/code&gt;&lt;/b&gt;: Initializer instance (or name) for the kernel matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463e42cec35f3eb2dadf69bc540a19c8aff3901b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_regularizer&lt;/code&gt;&lt;/b&gt;: Optional regularizer for the convolution kernel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="691f941a0d88bfd9350abb101091f5491258559f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_regularizer&lt;/code&gt;&lt;/b&gt;: Regularizer function applied to the &lt;code&gt;kernel&lt;/code&gt; weights matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9f4cb8e76ffa1c1f4b387645c083ffb98d83f8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_regularizer&lt;/code&gt;&lt;/b&gt;: Regularizer function applied to the &lt;code&gt;kernel&lt;/code&gt; weights matrix. Default: &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4f09a29a739d74839afa305815df7090bd7139" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_regularizer&lt;/code&gt;&lt;/b&gt;: Regularizer function for the weight matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb936819c14bbb20893fd9363cbfce72853b7469" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_regularizer&lt;/code&gt;&lt;/b&gt;: Regularizer instance for the kernel matrix (callable)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56a45865d15a552cdd1fcbbefce7be5d30783232" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_regularizer&lt;/code&gt;&lt;/b&gt;: regularizer for kernel vectors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89551a9520bcbb1ffafcba2d7f902781200a0291" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_size&lt;/code&gt;&lt;/b&gt;: A single integer specifying the spatial dimensions of the filters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c76fc313320792e7f8be17fadc0dee0587f8864" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_size&lt;/code&gt;&lt;/b&gt;: A tuple or list of 2 integers specifying the spatial dimensions of the filters. Can be a single integer to specify the same value for all spatial dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6ee4318876a37e8cc33518ab91af7b9896b919" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_size&lt;/code&gt;&lt;/b&gt;: A tuple or list of 2 positive integers specifying the spatial dimensions of the filters. Can be a single integer to specify the same value for all spatial dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b28e7e30bfeac7a6296b4e95463237b401d2ee86" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_size&lt;/code&gt;&lt;/b&gt;: A tuple or list of 3 positive integers specifying the spatial dimensions of the filters. Can be a single integer to specify the same value for all spatial dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8250492304ef959797711d88c45f8a4fd106223" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_size&lt;/code&gt;&lt;/b&gt;: An integer or tuple/list of 2 integers, specifying the height and width of the 2D convolution window. Can be a single integer to specify the same value for all spatial dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7221edf62110418b868827d7f0fc852009c4626" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_size&lt;/code&gt;&lt;/b&gt;: An integer or tuple/list of 2 integers, specifying the width and height of the 2D convolution window. Can be a single integer to specify the same value for all spatial dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b28964bde95803b1abbbbeeb4f56fc8f445d1db3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_size&lt;/code&gt;&lt;/b&gt;: An integer or tuple/list of 3 integers, specifying the depth, height and width of the 3D convolution window. Can be a single integer to specify the same value for all spatial dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07851115eefed15d449c9bf775c6497b591738c4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_size&lt;/code&gt;&lt;/b&gt;: An integer or tuple/list of a single integer, specifying the length of the 1D convolution window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0413764743b6ba3ffea5eb3fadf03b85cdb19203" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_size&lt;/code&gt;&lt;/b&gt;: An integer or tuple/list of n integers, specifying the dimensions of the convolution window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be41957963d2a915b1861844f10a093874524515" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_size&lt;/code&gt;&lt;/b&gt;: a tuple of 2 integers, specifying the width and height of the 2D convolution window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a40c26ff4a71b88806dbb5899229a7c8f1ac8520" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kernel_size&lt;/code&gt;&lt;/b&gt;: a tuple of a single integer, specifying the length of the 1D convolution window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92407d525939f32171079e74fecec2e3ef56ff0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;key&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;GraphKey&lt;/code&gt; used to collect the summaries. Defaults to &lt;code&gt;GraphKeys.SUMMARIES&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f56dd8fe8d5fa1c84d0884f11bc34faf45e6b35b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;key&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt;. The key used to seed the hash function, passed as a list of two uint64 elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa0c8a022c0b31f9cbbcb6a3f33fc7c859f632a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;key&lt;/code&gt;&lt;/b&gt;: A string scalar Tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29972907971a5fcd3a4f72610fdc383d13c38c60" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;key&lt;/code&gt;&lt;/b&gt;: A unique string identifying the input feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="426ac4fa08f5107a88869e2606bac2262275f40f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;key&lt;/code&gt;&lt;/b&gt;: A unique string identifying the input feature. It is used as the column name and the dictionary key for feature parsing configs, feature &lt;code&gt;Tensor&lt;/code&gt; objects, and feature columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a9fad675b19f2b98e981b3e9926d6ac9b204ef" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;key&lt;/code&gt;&lt;/b&gt;: A unique string identifying the input features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b3591afa5d962df6d2499182dc107818479727" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;key&lt;/code&gt;&lt;/b&gt;: If &lt;code&gt;key&lt;/code&gt; is an integer, returns the dimension at that index; otherwise if &lt;code&gt;key&lt;/code&gt; is a slice, returns a TensorShape whose dimensions are those selected by the slice from &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2299ba40de4d2c4ce69b1cfea84b6e055fedac92" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;key&lt;/code&gt;&lt;/b&gt;: Indicates which piece of the RaggedTensor to return, using standard Python semantics (e.g., negative values index from the end). &lt;code&gt;key&lt;/code&gt; may have any of the following types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3292e4b954759999f6ee2cb41ffc5ab78a6760f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;key&lt;/code&gt;&lt;/b&gt;: The key for the collection. For example, the &lt;code&gt;GraphKeys&lt;/code&gt; class contains many standard names for collections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c84bdaca072fe556e24d38fdddfaeaf1098f8a7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;key&lt;/code&gt;&lt;/b&gt;: the key for the RNG, a scalar of type STATE_TYPE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d59b7f4d5b4b9859455db7a65f8dbb4e2ab55bf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;key&lt;/code&gt;&lt;/b&gt;: the new key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af3025966caae03e6065061cdd8895309c3db868" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;key_dtype&lt;/code&gt;&lt;/b&gt;: The &lt;code&gt;key&lt;/code&gt; data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e713ecd5c65a1182e9f925ee68053f0e5c585ad1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;key_dtype&lt;/code&gt;&lt;/b&gt;: The &lt;code&gt;keys&lt;/code&gt; data type. Used when &lt;code&gt;keys&lt;/code&gt; is a python array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc67fa7d22f91a7d71407d7a21e7a70d8840651d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;key_dtype&lt;/code&gt;&lt;/b&gt;: the type of the key tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ac2326190048d55974ba5a4ac38c6abadb1f911" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;key_func&lt;/code&gt;&lt;/b&gt;: A function mapping a nested structure of tensors (having shapes and types defined by &lt;code&gt;self.output_shapes&lt;/code&gt; and &lt;code&gt;self.output_types&lt;/code&gt;) to a scalar &lt;a href=&quot;../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt; tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ba6114891d6e9470007a91e2045829ae5703953" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;key_index&lt;/code&gt;&lt;/b&gt;: the index that represents information of a line to get the table 'key' values from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="169fb721e93b1c960c2098c4d9ae22025239609f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/b&gt;: A 1-D string Tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055a902e75bb80682bf9d0236e9b96453e230e1d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;string&lt;/code&gt; for prediction keys. Defaults to &lt;code&gt;None&lt;/code&gt;, meaning if not specified, predictions will be created for all the pre-defined valid keys in the head.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39171d21b908fa4b7b55b01b9767c3f81d218945" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/b&gt;: An iterable identifying the features to be crossed. Each element can be either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb07e904bc5b144aa931f9e5d4be9689fa7f0471" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/b&gt;: Keys to insert. Can be a tensor of any shape. Must match the table's key type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2430a7da952c593010dc9e912c63b79c431997f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/b&gt;: Keys to look up. Can be a tensor of any shape. Must match the table's key_dtype.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e5d3572c2ccc59fed279d9f68e6212566a5622" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/b&gt;: Keys to look up. May be either a &lt;code&gt;SparseTensor&lt;/code&gt; or dense &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bba11bef357a90eff61a9dab78f50282ca68387" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/b&gt;: Keys to remove. Can be a tensor of any shape. Must match the table's key type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5880c5469604993b7167f3c4ed6b02a396795a36" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/b&gt;: The tensor for the keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e22632371a5dac8bd427655bb94d7a0e1899b804" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/b&gt;: a list of prediction keys. Key can be either the class variable of prediction_keys.PredictionKeys or its string value, such as: prediction_keys.PredictionKeys.LOGITS or 'logits'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa95f959ee17bee8d3fb0ce7ba566c9a4564216e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/b&gt;: a list or tuple of prediction keys. Each key can be either the class variable of prediction_keys.PredictionKeys or its string value, such as: prediction_keys.PredictionKeys.CLASSES or 'classes'. If not specified, it will return the predictions for all valid keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e5ebc16481e23ccb5d6ade0f9d04e5f4d9cddb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;keyword_required&lt;/code&gt;&lt;/b&gt;: Python 2 standin for * (temporary for argument reorder)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30215cab0ed306715487a0f82ea129ece5235b17" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kl_divergence&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;self.dtype&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; with shape &lt;code&gt;[B1, ..., Bn]&lt;/code&gt; representing &lt;code&gt;n&lt;/code&gt; different calculations of the Kullback-Leibler divergence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c8b38577e5c5ae8872499b6a006161dd686d25" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kl_fn&lt;/code&gt;&lt;/b&gt;: The function to use for the KL divergence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eba7b38fabeacf54d0c52d359355cece95bc5daf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kmeans_plus_plus_num_retries&lt;/code&gt;&lt;/b&gt;: For each point that is sampled during kmeans++ initialization, this parameter specifies the number of additional points to draw from the current distribution before selecting the best. If a negative value is specified, a heuristic is used to sample &lt;code&gt;O(log(num_to_sample))&lt;/code&gt; additional points. Used only if &lt;code&gt;initial_clusters=KMeansClustering.KMEANS_PLUS_PLUS_INIT&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3f76f5e048282b6203d021738f43683b599258b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;known_only&lt;/code&gt;&lt;/b&gt;: bool, if True, parse and remove known flags; return the rest untouched. Unknown flags specified by --undefok are not returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1ceab77b0c05fae3f58bb887e0c8862559916f1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ksize&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;&amp;gt;= 4&lt;/code&gt;. The size of the window for each dimension of the input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6823923be4f1e2b22ab205908f8c18b0a5293e03" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ksize&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt;. The size of the window for each dimension of the input tensor. The length must be 4 to match the number of dimensions of the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc99cc675613eb72d5cfc7dcbbef4823c5ed342d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ksize&lt;/code&gt;&lt;/b&gt;: An int or list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt;. The size of the window for each dimension of the input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc213dc9386002f5b7020f8abb34e545940280e1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ksize&lt;/code&gt;&lt;/b&gt;: An int or list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt;. The size of the window for each dimension of the input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96706a4e102d28596411777349a6842fbba2d2ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ksize&lt;/code&gt;&lt;/b&gt;: An int or list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; or &lt;code&gt;5&lt;/code&gt;. The size of the window for each dimension of the input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5197c9a931901b041120750a962f6bd49a9ecb9c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ksize&lt;/code&gt;&lt;/b&gt;: An int or list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt; or &lt;code&gt;N+2&lt;/code&gt;. The size of the window for each dimension of the input tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a92aafa7c2ab7194942906757dec36ed13b270e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ksizes&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;&amp;gt;= 4&lt;/code&gt;. The size of the sliding window for each dimension of &lt;code&gt;images&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a36fa370325d2452ef6f9df73671ba0711e75d6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;ksizes&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;ints&lt;/code&gt; that has length &lt;code&gt;&amp;gt;= 5&lt;/code&gt;. The size of the sliding window for each dimension of &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e00a0db189d17ab0be8c4708a6879f9673eb1d75" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kwargs&lt;/code&gt;&lt;/b&gt;: (Optional) Keyword arguments to &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cc16612b224cb32fdb89096a9b9c912a4ff66f5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kwargs&lt;/code&gt;&lt;/b&gt;: A dictionary of keyword arguments for the target invocation. Defaults to {}.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0b78ecc7b65dbc8144ca4d02e1ba219ab2f7920" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kwargs&lt;/code&gt;&lt;/b&gt;: Dict with keyword arguments for &lt;code&gt;fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97077e8022b7ba64d53d9367a1081754a476120e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kwargs&lt;/code&gt;&lt;/b&gt;: Dict with keyword arguments to pass to &lt;code&gt;fn()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="843c1d355fe676ec2b36224cacb8083b57c2154b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kwargs&lt;/code&gt;&lt;/b&gt;: Dict with keyword per-thread arguments for &lt;code&gt;merge_fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c21af4f479451465328ea27eea9faee99778de9f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kwargs&lt;/code&gt;&lt;/b&gt;: Extra kwargs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b4011fca3ed35509895d1a12259b0a6ce9a5f95" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kwargs&lt;/code&gt;&lt;/b&gt;: Optional keyword arguments passed to &lt;code&gt;train_step_fn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6564179bc9b9bb0725f5159fe6d54b8b57e5ef68" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;kwargs&lt;/code&gt;&lt;/b&gt;: Optional keyword arguments to pass to &lt;code&gt;target&lt;/code&gt; when calling it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7115f33d2ba930c35308332a996b5f4f64c171fb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;l1&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;float&lt;/code&gt;. Symmetric l1 regularization strength.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b4ab9ae1f647437b6f8817f8373bc136e509b1b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;l1&lt;/code&gt;&lt;/b&gt;: Float; L1 regularization factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="866d3211deec67501320f1d74586d2416b20255e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;l1&lt;/code&gt;&lt;/b&gt;: L1 regularization factor (positive float).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4bb2146a17e987d3267d4fc89b0dbf99bb227a6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;l1_regularization&lt;/code&gt;&lt;/b&gt;: regularization multiplier applied to the absolute weights of the tree leafs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50dbb0295796f5a4c75564b444f261f6ffba0294" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;l1_regularization_strength&lt;/code&gt;&lt;/b&gt;: A float value, must be greater than or equal to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b88644a3ac7755aac44fd2aa4f4e7d5e9ba6d4b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;l2&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;float&lt;/code&gt;. Symmetric l2 regularization strength.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae07fd2ae53fb8752e29f5f53b719a79d9c80dee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;l2&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;float&lt;/code&gt;. Symmetric l2 regularization strength. Should be a positive float.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0379002361e18a516a243e483d392940edff3abd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;l2&lt;/code&gt;&lt;/b&gt;: Float; L2 regularization factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e5b8801032f361536b92c802234075ba53eafc3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;l2&lt;/code&gt;&lt;/b&gt;: L2 regularization factor (positive float).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca7076f2f17adb4222bbe3f222d824ad506bb98" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;l2_regularization&lt;/code&gt;&lt;/b&gt;: regularization multiplier applied to the square weights of the tree leafs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b8fc960b5fd1b2e0d1ff84593ec8e24137d1201" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;l2_regularization_strength&lt;/code&gt;&lt;/b&gt;: A float value, must be greater than or equal to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72169a447c043b657ef2bd4b07f9881f5ddf9adf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;l2_regularizer&lt;/code&gt;&lt;/b&gt;: 0-D &lt;code&gt;double&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt;. Ignored if &lt;code&gt;fast=False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ab2473ea5d2fee53b1cb2580da01c4e7e32c73" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;l2_shrinkage_regularization_strength&lt;/code&gt;&lt;/b&gt;: A float value, must be greater than or equal to zero. This differs from L2 above in that the L2 above is a stabilization penalty, whereas this L2 shrinkage is a magnitude penalty. The FTRL formulation can be written as: w_{t+1} = argmin&lt;em&gt;w(\hat{g}&lt;/em&gt;{1:t}w + L1&lt;em&gt;||w||_1 + L2&lt;/em&gt;||w||_2^2), where \hat{g} = g + (2&lt;em&gt;L2_shrinkage&lt;/em&gt;w), and g is the gradient of the loss function w.r.t. the weights w. Specifically, in the absence of L1 regularization, it is equivalent to the following update rule: w_{t+1} = w_t - lr_t / (1 + 2&lt;em&gt;L2&lt;/em&gt;lr_t) * g_t - 2&lt;em&gt;L2_shrinkage&lt;/em&gt;lr_t / (1 + 2&lt;em&gt;L2&lt;/em&gt;lr_t) * w_t where lr_t is the learning rate at t. When input is sparse shrinkage will only happen on the active weights.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b7dd95b927d956a59c4cc734aa018acf86feb83" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;l2_shrinkage_regularization_strength&lt;/code&gt;&lt;/b&gt;: A float value, must be greater than or equal to zero. This differs from L2 above in that the L2 above is a stabilization penalty, whereas this L2 shrinkage is a magnitude penalty. The FTRL formulation can be written as: w_{t+1} = argmin&lt;em&gt;w(\hat{g}&lt;/em&gt;{1:t}w + L1&lt;em&gt;||w||_1 + L2&lt;/em&gt;||w||_2^2), where \hat{g} = g + (2&lt;em&gt;L2_shrinkage&lt;/em&gt;w), and g is the gradient of the loss function w.r.t. the weights w. Specifically, in the absence of L1 regularization, it is equivalent to the following update rule: w_{t+1} = w_t - lr_t / (1 + 2&lt;em&gt;L2&lt;/em&gt;lr_t) * g_t - 2&lt;em&gt;L2_shrinkage&lt;/em&gt;lr_t / (1 + 2&lt;em&gt;L2&lt;/em&gt;lr_t) * w_t where lr_t is the learning rate at t. When input is sparse shrinkage will only happen on the active weights.\</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dea3e27fb5948d1887b6c8db90c37bef0e6bdea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;l&lt;/code&gt;&lt;/b&gt;: Float; L1 regularization factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0162ba9bd038880524d3fda42f0c1611a85d846c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;l&lt;/code&gt;&lt;/b&gt;: Float; L2 regularization factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a05c222a689353f0139ac63c3b72d702baf153a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_default&lt;/code&gt;&lt;/b&gt;: used as label if label_key does not exist in given tf.Example. An example usage: let's say &lt;code&gt;label_key&lt;/code&gt; is 'clicked' and tf.Example contains clicked data only for positive examples in following format &lt;code&gt;key:clicked, value:1&lt;/code&gt;. This means that if there is no data with key 'clicked' it should count as negative example by setting &lt;code&gt;label_deafault=0&lt;/code&gt;. Type of this value should be compatible with &lt;code&gt;label_dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f8d3e477f9423ce8782d6cc4840d0aab8745511" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_default&lt;/code&gt;&lt;/b&gt;: used as label if label_key does not exist in given tf.Example. By default default_value is none, which means &lt;code&gt;tf.parse_example&lt;/code&gt; will error out if there is any missing label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a34ad626c37b68eb001400272c2780e838f069c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_dimension&lt;/code&gt;&lt;/b&gt;: Number of regression labels per example. This is the size of the last dimension of the labels &lt;code&gt;Tensor&lt;/code&gt; (typically, this has shape &lt;code&gt;[batch_size, label_dimension]&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="849a8551e7611ac2f4d63b6f6a5b0e7944924815" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_dimension&lt;/code&gt;&lt;/b&gt;: Number of regression targets per example. Multi-dimensional support is not yet implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3832aa635a4e2c36e007ec792acadd1efab859b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_dimension&lt;/code&gt;&lt;/b&gt;: Number of regression targets per example. This is the size of the last dimension of the labels and logits &lt;code&gt;Tensor&lt;/code&gt; objects (typically, these have shape &lt;code&gt;[batch_size, label_dimension]&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0677d30d3b9ff082f4a4c59ddef2aa891dd49c09" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_dtype&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;tf.dtype&lt;/code&gt; identifies the type of labels. By default it is &lt;a href=&quot;../../../../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6402e72a6cf38cc515aaa9dc2b0939235dd1bab7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_dtype&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;tf.dtype&lt;/code&gt; identifies the type of labels. By default it is &lt;a href=&quot;../../../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;. If user defines a &lt;code&gt;label_vocabulary&lt;/code&gt;, this should be set as &lt;a href=&quot;../../../../tf#string&quot;&gt;&lt;code&gt;tf.string&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;../../../../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt; labels are only supported for binary classification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72806213dd7506270416d4c15f1554f649ce26c7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_dtype&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;tf.dtype&lt;/code&gt; identifies the type of labels. By default it is &lt;a href=&quot;../../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4510b06497197e27f23d15ec99c415b03051eb2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_dtype&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;tf.dtype&lt;/code&gt; identifies the type of labels. By default it is &lt;a href=&quot;../../tf#int64&quot;&gt;&lt;code&gt;tf.int64&lt;/code&gt;&lt;/a&gt;. If user defines a &lt;code&gt;label_vocabulary&lt;/code&gt;, this should be set as &lt;a href=&quot;../../tf#string&quot;&gt;&lt;code&gt;tf.string&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;../../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt; labels are only supported for binary classification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="084bb2e6c78018077797e0c35f590100b68c0add" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_key&lt;/code&gt;&lt;/b&gt;: (Optional) A string corresponding to the key labels are stored in &lt;code&gt;tf.Examples&lt;/code&gt;. If provided, it must be one of the &lt;code&gt;features&lt;/code&gt; key, otherwise results in &lt;code&gt;ValueError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac5d0d70d74587fca6b05a4f1ceebaf9d3f2dcb7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_key&lt;/code&gt;&lt;/b&gt;: A string identifying the label. It means tf.Example stores labels with this key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1fbb1afcabcea1c283f8ab5a342450f7894784d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_length&lt;/code&gt;&lt;/b&gt;: tensor &lt;code&gt;(samples, 1)&lt;/code&gt; containing the sequence length for each batch item in &lt;code&gt;y_true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18db635a698f671bcabf80a05e4bf7bb5eb5ba9d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_length&lt;/code&gt;&lt;/b&gt;: tensor of shape [batch_size], None if labels is SparseTensor Length of reference label sequence in labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6625a6f44e7addeebe7862cdf8a16848faf11f03" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_lengths&lt;/code&gt;&lt;/b&gt;: length of the labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360eb555591642f01fd64450f471f1a8399f1f37" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_mode&lt;/code&gt;&lt;/b&gt;: one of &quot;fine&quot;, &quot;coarse&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21d2494bd58f35a7e66f2a5fabe28806e57ec2e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_name&lt;/code&gt;&lt;/b&gt;: A optional string corresponding to the label column. If provided, the data for this column is returned as a separate &lt;code&gt;Tensor&lt;/code&gt; from the features dictionary, so that the dataset complies with the format expected by a &lt;code&gt;tf.Estimator.train&lt;/code&gt; or &lt;code&gt;tf.Estimator.evaluate&lt;/code&gt; input function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4bc82384507a074c873991aef3e3392d3e82814" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_smoothing&lt;/code&gt;&lt;/b&gt;: (Optional) Float in [0, 1]. When &amp;gt; 0, label values are smoothed, meaning the confidence on label values are relaxed. e.g. &lt;code&gt;label_smoothing=0.2&lt;/code&gt; means that we will use a value of &lt;code&gt;0.1&lt;/code&gt; for label &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;0.9&lt;/code&gt; for label &lt;code&gt;1&lt;/code&gt;&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc72736124a77f4e8deaab66fe788753dce3edf4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_smoothing&lt;/code&gt;&lt;/b&gt;: Float in [0, 1]. If &amp;gt; &lt;code&gt;0&lt;/code&gt; then smooth the labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da64fd705dca790d4ac5e4cc2663fa6c704009c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_smoothing&lt;/code&gt;&lt;/b&gt;: Float in [0, 1]. When &amp;gt; 0, label values are smoothed, meaning the confidence on label values are relaxed. e.g. &lt;code&gt;label_smoothing=0.2&lt;/code&gt; means that we will use a value of &lt;code&gt;0.1&lt;/code&gt; for label &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;0.9&lt;/code&gt; for label &lt;code&gt;1&lt;/code&gt;&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8edc48935241b74eba4c13b34bb66a608d0e43b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_smoothing&lt;/code&gt;&lt;/b&gt;: Float in [0, 1]. When 0, no smoothing occurs. When &amp;gt; 0, we compute the loss between the predicted labels and a smoothed version of the true labels, where the smoothing squeezes the labels towards 0.5. Larger values of &lt;code&gt;label_smoothing&lt;/code&gt; correspond to heavier smoothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19fc013dfe4c00be296d3aac8a0e259684144c29" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_smoothing&lt;/code&gt;&lt;/b&gt;: If greater than 0 then smooth the labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a6c49d79ec3f38d1309b8e27be038f61e4dc94" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_smoothing&lt;/code&gt;&lt;/b&gt;: If greater than &lt;code&gt;0&lt;/code&gt; then smooth the labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd2adf899660e48468bf63060b2ea9cdbe18aee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_vocabulary&lt;/code&gt;&lt;/b&gt;: A list of strings represents possible label values. If given, labels must be string type and have any value in &lt;code&gt;label_vocabulary&lt;/code&gt;. If it is not given, that means labels are already encoded as integer or float within [0, 1] for &lt;code&gt;n_classes=2&lt;/code&gt; and encoded as integer values in {0, 1,..., n_classes-1} for &lt;code&gt;n_classes&lt;/code&gt;&amp;gt;2 . Also there will be errors if vocabulary is not provided and labels are string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068e038cc165175d58b1a3fb0a480a767f050166" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_vocabulary&lt;/code&gt;&lt;/b&gt;: A list of strings represents possible label values. If it is not given, that means labels are already encoded as integer within [0, n_classes) or multi-hot Tensor. If given, labels must be SparseTensor &lt;code&gt;string&lt;/code&gt; type and have any value in &lt;code&gt;label_vocabulary&lt;/code&gt;. Also there will be errors if vocabulary is not provided and labels are string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4051f87a9278a86f07e883251873ec6e58dbede5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_vocabulary&lt;/code&gt;&lt;/b&gt;: A list or tuple of strings representing possible label values. If it is not given, that means labels are already encoded as an integer within [0, n_classes). If given, labels must be of string type and have any value in &lt;code&gt;label_vocabulary&lt;/code&gt;. Note that errors will be raised if &lt;code&gt;label_vocabulary&lt;/code&gt; is not provided but labels are strings. If both &lt;code&gt;n_classes&lt;/code&gt; and &lt;code&gt;label_vocabulary&lt;/code&gt; are provided, &lt;code&gt;label_vocabulary&lt;/code&gt; should contain exactly &lt;code&gt;n_classes&lt;/code&gt; items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d7720786e2aa31e9b0a12255334b89dddcde1ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_vocabulary&lt;/code&gt;&lt;/b&gt;: A list or tuple of strings representing possible label values. If it is not given, that means labels are already encoded within [0, 1]. If given, labels must be string type and have any value in &lt;code&gt;label_vocabulary&lt;/code&gt;. Note that errors will be raised if &lt;code&gt;label_vocabulary&lt;/code&gt; is not provided but labels are strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1ca5999edead5f3a15279bacc271fd32f5446a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_vocabulary&lt;/code&gt;&lt;/b&gt;: Optional list of strings with size &lt;code&gt;[n_classes]&lt;/code&gt; defining the label vocabulary. Only supported for &lt;code&gt;n_classes&lt;/code&gt; &amp;gt; 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd2ba47a5bd64f1e51800bc9628ddccbe0090129" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;label_weights&lt;/code&gt;&lt;/b&gt;: (optional) list, array, or tensor of non-negative weights used to compute AUCs for multilabel data. When &lt;code&gt;multi_label&lt;/code&gt; is True, the weights are applied to the individual label AUCs when they are averaged to produce the multi-label AUC. When it's False, they are used to weight the individual label predictions in computing the confusion matrix on the flattened data. Note that this is unlike class_weights in that class_weights weights the example depending on the value of its label, whereas label_weights depends only on the index of that label before flattening; therefore &lt;code&gt;label_weights&lt;/code&gt; should not be used for multi-class data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b63ea8b0e05408bf552449705e9fc3ccecb662" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: 1-D &lt;code&gt;Tensor&lt;/code&gt; of real labels for the classification task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea0bfbefa14c5ac09e70a019987802ae9ea3a37" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[d_0, d_1, ..., d_{r-1}]&lt;/code&gt; (where &lt;code&gt;r&lt;/code&gt; is rank of &lt;code&gt;labels&lt;/code&gt; and result) and dtype &lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt;. Each entry in &lt;code&gt;labels&lt;/code&gt; must be an index in &lt;code&gt;[0, num_classes)&lt;/code&gt;. Other values will raise an exception when this op is run on CPU, and return &lt;code&gt;NaN&lt;/code&gt; for corresponding loss and gradient rows on GPU.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246252757466ddb8688a4becbc6e8543b2e3bd53" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; whose shape matches 'predictions'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e97bd689955fdb185d5c0afd58b5a375c586a7f0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;int64&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; with shape [D1, ... DN, num_labels] or [D1, ... DN], where the latter implies num_labels=1. N &amp;gt;= 1 and num_labels is the number of target classes for the associated prediction. Commonly, N=1 and &lt;code&gt;labels&lt;/code&gt; has shape [batch_size, num_labels]. [D1, ... DN] must match &lt;code&gt;predictions&lt;/code&gt;. Values should be in range [0, num_classes), where num_classes is the last dimension of &lt;code&gt;predictions&lt;/code&gt;. Values outside this range always count towards &lt;code&gt;false_negative_at_&amp;lt;k&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c86feaae825115f6d05fef1f426974543d63ee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;int64&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; with shape [D1, ... DN, num_labels] or [D1, ... DN], where the latter implies num_labels=1. N &amp;gt;= 1 and num_labels is the number of target classes for the associated prediction. Commonly, N=1 and &lt;code&gt;labels&lt;/code&gt; has shape [batch_size, num_labels]. [D1, ... DN] must match &lt;code&gt;predictions&lt;/code&gt;. Values should be in range [0, num_classes), where num_classes is the last dimension of &lt;code&gt;predictions&lt;/code&gt;. Values outside this range are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0376904bc5975b05a64ec79dc612ba98959f61fa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of arbitrary shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d76669785e149cc2db5d3ee594c21f044f8a91" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of ground truth labels with shape [batch size] and of type &lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt;. The tensor will be flattened if its rank &amp;gt; 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf43e61c4e3d625ba3aafdeaaff518a61e9cb83" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of the same shape as &lt;code&gt;predictions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f987b03407b0852c6e5b5052f92b1885ad35d6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of the same type and shape as &lt;code&gt;logits&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f4abb7ac5b4d38c03ae415bbab205bf5b74f1c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;int64&lt;/code&gt; and shape &lt;code&gt;[batch_size, num_true]&lt;/code&gt;. The target classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f7b56720a4c45cdf45fd4080fd5925d92006bb9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;int64&lt;/code&gt; and shape &lt;code&gt;[batch_size, num_true]&lt;/code&gt;. The target classes. Note that this format differs from the &lt;code&gt;labels&lt;/code&gt; argument of &lt;a href=&quot;../../../nn/softmax_cross_entropy_with_logits&quot;&gt;&lt;code&gt;nn.softmax_cross_entropy_with_logits&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd298b269459d413f3070a1adf87997f60989481" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;int64&lt;/code&gt; and shape &lt;code&gt;[batch_size, num_true]&lt;/code&gt;. The target classes. Note that this format differs from the &lt;code&gt;labels&lt;/code&gt; argument of &lt;a href=&quot;softmax_cross_entropy_with_logits&quot;&gt;&lt;code&gt;nn.softmax_cross_entropy_with_logits&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7081324205625e90e8e172b69d4cdffd6d9b3dd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; whose shape matches &lt;code&gt;predictions&lt;/code&gt;. Will be cast to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc5ea724a29ad40fb1ddac31300452311f31187" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;int32&lt;/code&gt;&lt;code&gt;SparseTensor&lt;/code&gt;. &lt;code&gt;labels.indices[i, :] == [b, t]&lt;/code&gt; means &lt;code&gt;labels.values[i]&lt;/code&gt; stores the id for (batch b, time t). &lt;code&gt;labels.values[i]&lt;/code&gt; must take on values in &lt;code&gt;[0, num_labels)&lt;/code&gt;. See &lt;code&gt;core/ops/ctc_ops.cc&lt;/code&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="439b7f6d63177e0971ce099f5541abfd866f01f5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: Each vector along the class dimension should hold a valid probability distribution e.g. for the case in which labels are of shape &lt;code&gt;[batch_size, num_classes]&lt;/code&gt;, each row of &lt;code&gt;labels[i]&lt;/code&gt; must be a valid probability distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2766529c1d68d3b3890d1a2cfc60b57d04c7b134" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: Input &lt;code&gt;dict&lt;/code&gt; keyed by head name. For each head, the label value can be integer or string &lt;code&gt;Tensor&lt;/code&gt; with shape matching its corresponding &lt;code&gt;logits&lt;/code&gt;.&lt;code&gt;labels&lt;/code&gt; is a required argument when &lt;code&gt;mode&lt;/code&gt; equals &lt;code&gt;TRAIN&lt;/code&gt; or &lt;code&gt;EVAL&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18050dab7d4d0ebfe00eab663bac2a4230708f57" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: Labels &lt;code&gt;Tensor&lt;/code&gt;, or &lt;code&gt;dict&lt;/code&gt; mapping string label names to &lt;code&gt;Tensor&lt;/code&gt; objects of the label values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61cd0c22d5061aa95e69518347f805466a16fb55" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: Tensor of shape [batch, max value in seq_length]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcf8e8d1525c7f3f0520e3166aafe9cf879b236d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: The ground truth output tensor, same dimensions as 'predictions'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01ece0734a7536c65959a6e5fa081c18c89bc0ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: The ground truth output tensor, whose shape must match the shape of &lt;code&gt;predictions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff9289726848041c01216f5fd243f20de986fca2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: The ground truth output tensor. Its shape should match the shape of logits. The values of the tensor are expected to be 0.0 or 1.0. Internally the {0,1} labels are converted to {-1,1} when calculating the hinge loss.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b53f550b447b6b61a76c1125e251ab5bed38d7c3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: The ground truth values, a &lt;code&gt;Tensor&lt;/code&gt; whose dimensions must match &lt;code&gt;predictions&lt;/code&gt;. Will be cast to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed960b58bed78fea86b9b550f6d0efa7c9103f01" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: The ground truth values, a &lt;code&gt;Tensor&lt;/code&gt; whose shape matches &lt;code&gt;predictions&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6b7bb6f32ecd2db26329b33f504b120b0b675f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: a dict of string to &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece05fc1c8f4c5153ed261403fb8bb809c81c961" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: dense CTC labels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3637aa4541c5fe8d2d77e7859ead0cd7e6969697" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: tensor of shape [batch_size, max_label_length] padded with 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c29c97b41f86d941918e9582cc1296dbc0d876c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;labels&lt;/code&gt;&lt;/b&gt;: tensor of shape [batch_size, max_label_seq_length] or SparseTensor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0e8a7ad8ab7bcce630bb8c0c0defdefa444b3f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lam&lt;/code&gt;&lt;/b&gt;: A Tensor or Python value or N-D array of type &lt;code&gt;dtype&lt;/code&gt;. &lt;code&gt;lam&lt;/code&gt; provides the rate parameter(s) describing the poisson distribution(s) to sample.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea3bf9c00c42c4261ded04491b4d67b4f2be99e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lanczos3&lt;/code&gt;&lt;/b&gt;: &lt;a href=&quot;https://en.wikipedia.org/wiki/Lanczos_resampling&quot;&gt;Lanczos kernel&lt;/a&gt; with radius 3. High-quality practical filter but may have some ringing especially on synthetic images.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd87d0408fc3ce73b44a6beff2c6405a3f5a8822" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lanczos5&lt;/code&gt;&lt;/b&gt;: &lt;a href=&quot;https://en.wikipedia.org/wiki/Lanczos_resampling&quot;&gt;Lanczos kernel&lt;/a&gt; with radius 5. Very-high-quality filter but may have stronger ringing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e055b2897d5bf8c894b18c821a3d82576c6c10" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;last_checkpoints&lt;/code&gt;&lt;/b&gt;: A list of checkpoint filenames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18096d788a87651ba6d89721b6e24e59c7776005" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;last_checkpoints_with_time&lt;/code&gt;&lt;/b&gt;: A list of tuples of checkpoint filenames and timestamps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed6e2590727d3631510f7f29a98bc7bf9807a962" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;last_preserved_timestamp&lt;/code&gt;&lt;/b&gt;: A float, indicating the number of seconds since the Epoch when the last preserved checkpoint was written, e.g. due to a &lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt; parameter (see &lt;a href=&quot;../../../train/checkpointmanager&quot;&gt;&lt;code&gt;tf.train.CheckpointManager&lt;/code&gt;&lt;/a&gt; for an implementation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb41a5397731185891814b281fc626e464d691f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;last_step&lt;/code&gt;&lt;/b&gt;: Step after which to stop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78912e61b794321a2e0bc304cc0299f6f12378d2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;latest_filename&lt;/code&gt;&lt;/b&gt;: Optional name for the protocol buffer file that contains the list of most recent checkpoint filenames. See the corresponding argument to &lt;code&gt;Saver.save()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d592d37a1c288817ded4ef3e2599cceae38d02cc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;latest_filename&lt;/code&gt;&lt;/b&gt;: Optional name for the protocol buffer file that will contains the list of most recent checkpoints. That file, kept in the same directory as the checkpoint files, is automatically managed by the saver to keep track of recent checkpoints. Defaults to 'checkpoint'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b4d4ba5067e35a431c4ac8e10fd9c4dfb73d13b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;latest_filename&lt;/code&gt;&lt;/b&gt;: Optional name of the checkpoint file. Default to 'checkpoint'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5863ce6c2aadfee11c338ebca31d5e36741741f4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;layer&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Recurrent&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e684ab54bd629aba1b9441b692a4990f188388" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;layer&lt;/code&gt;&lt;/b&gt;: Origin layer of the tensor. Will be determined via tensor._keras_history if not provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad9024b22283f401dbdd103fcf88e95a254b09e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;layer&lt;/code&gt;&lt;/b&gt;: The layer to be wrapped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e72fbf2d6b031934a99e9cf8cf558f0474e04264" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;layer&lt;/code&gt;&lt;/b&gt;: a layer instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91c5d27de55e815aa85cf9c0025c472c0445c24f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;layer&lt;/code&gt;&lt;/b&gt;: layer instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9ac311ecde818ddd90da3b0afb7dd20954ac187" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;layers&lt;/code&gt;&lt;/b&gt;: list of layers to add to the model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb3a63b18c7a5cb228d1765a78fd0c89207d5ac8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lazy_adam&lt;/code&gt;&lt;/b&gt;: Use lazy Adam instead of Adam. Lazy Adam trains faster. Please see &lt;code&gt;optimization_parameters.proto&lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a9425912e8972d7e2c2608a6140a6bbdb3215d1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;learning_rate&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; or a floating point value. The learning rate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c49cebf26f05e704a9bcc42c1946407365e0de9e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;learning_rate&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; or a floating point value. The learning rate. To match the exact form in the original paper use 1.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c9e4cb48b7d20d2271b5114b83faa8c1300e7a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;learning_rate&lt;/code&gt;&lt;/b&gt;: A Tensor or a floating point value. The learning rate to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9fcb8b69ff3934dc2691ae0a4637d590c3a0d8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;learning_rate&lt;/code&gt;&lt;/b&gt;: A Tensor or a floating point value. The learning rate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e321a9347c0d593c8b1ef9fdc480c9507ccc8145" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;learning_rate&lt;/code&gt;&lt;/b&gt;: A float value or a constant float &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c6c18c9701aa5351812d964a3d390c7b0d43f1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;learning_rate&lt;/code&gt;&lt;/b&gt;: A scalar &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt; Tensor or a Python number. The initial learning rate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1979a2a90903b605c42e1bd58b2108fd234afec8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;learning_rate&lt;/code&gt;&lt;/b&gt;: A scalar &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; or a Python number. The initial learning rate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd09a96eb850cf5851ebcb914b894fde8437d171" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;learning_rate&lt;/code&gt;&lt;/b&gt;: a floating point value. The learning rate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e29bff5276d0f18e4f0c3c79e10e019b40556e2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;learning_rate&lt;/code&gt;&lt;/b&gt;: float hyperparameter &amp;gt;= 0. Learning rate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be160b793bfd2c39ae3dda3bb7dab687cdff44ab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;learning_rate&lt;/code&gt;&lt;/b&gt;: shrinkage parameter to be used when a tree added to the model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8294f52ec7272db155c72eaef0bf765b15c2cccb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;learning_rate&lt;/code&gt;&lt;/b&gt;: used for updating embedding table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b6809b93913de47c1ae2ef179a8f609d54c0c51" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;learning_rate_fn&lt;/code&gt;&lt;/b&gt;: A function that takes global step and returns learning rate for the embedding table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c2836016dbdbb19dea7b411b28a90ad13c31944" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;learning_rate_power&lt;/code&gt;&lt;/b&gt;: A float value, must be less or equal to zero. Controls how the learning rate decreases during training. Use zero for a fixed learning rate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72bd85f417d87d6967341871e4ae7ce8c0b8f6ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;learning_rate_power&lt;/code&gt;&lt;/b&gt;: A float value, must be less or equal to zero. Controls how the learning rate decreases during training. Use zero for a fixed learning rate. See section 3.1 in the &lt;a href=&quot;https://www.eecs.tufts.edu/%7Edsculley/papers/ad-click-prediction.pdf&quot;&gt;paper&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac7bf44c33780af16b2cbcfc338bb987f273890" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;legacy_init_op&lt;/code&gt;&lt;/b&gt;: Legacy support for op or group of ops to execute after the restore op upon a load.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac3c036d21ed316bdbe281d218485f0d227fa30" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;len&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must have the same type as &lt;code&gt;pos&lt;/code&gt;. Scalar defining the number of characters to include in each substring</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="553d637601e60117c8607cc6be2ab4a4b7443e6c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;length&lt;/code&gt;&lt;/b&gt;: int, maximum length of a line, includes indentation. If this is None then use get_help_width()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5474ee9f42e01f5b669b8a319c2475c4c5aa1542" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lengths&lt;/code&gt;&lt;/b&gt;: An optional set of row lengths, specified using a 1-D integer &lt;code&gt;Tensor&lt;/code&gt; whose length is equal to &lt;code&gt;tensor.shape[0]&lt;/code&gt; (the number of rows in &lt;code&gt;tensor&lt;/code&gt;). If specified, then &lt;code&gt;output[row]&lt;/code&gt; will contain &lt;code&gt;tensor[row][:lengths[row]]&lt;/code&gt;. Negative lengths are treated as zero. You may optionally pass a list or tuple of lengths to this argument, which will be used as nested row lengths to construct a ragged tensor with multiple ragged dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6befe3b8ee29b2dc578ea04819f21a498b12aac4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lengths&lt;/code&gt;&lt;/b&gt;: integer tensor, all its values &amp;lt;= maxlen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="702538f606190182c68089c8406f3ab12cead101" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;level&lt;/code&gt;&lt;/b&gt;: Hierarchical level of the Ophint node, a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25f1783de4f036bc4ca5e23e904d35bd743a4d0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;level&lt;/code&gt;&lt;/b&gt;: OpHint level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="715309d7702acf09650abc2672bfbdd19fe1a83d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;level&lt;/code&gt;&lt;/b&gt;: The level at which to log.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91b4e904e75766ed850b033f683a3f7242c5c0d1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;level&lt;/code&gt;&lt;/b&gt;: fraction of the entries in the tensor that will be set to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa99875a3dd4197cb3931e09876e7a35e4fa13f5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;level&lt;/code&gt;&lt;/b&gt;: int, the verbosity level; larger values specify increased verbosity; 0 means no logging. When reporting bugs, it is recommended to set this value to a larger number, like 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ded50ee494f0e57b726d28ae8e422eb0d45f5caa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;library&lt;/code&gt;&lt;/b&gt;: Name of shared library containing the &lt;a href=&quot;https://www.tensorflow.org/lite/performance/delegates&quot;&gt;TfLiteDelegate&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0794d27ebec451fe7fb7a0cc76a23fd551fd692" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;library_filename&lt;/code&gt;&lt;/b&gt;: Path to the plugin. Relative or absolute filesystem path to a dynamic library file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac7b115816f8eab6572c238ede600147e5cfdfca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;library_location&lt;/code&gt;&lt;/b&gt;: Path to the plugin or the folder of plugins. Relative or absolute filesystem path to a dynamic library file or folder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f51889263172796e2a69fbb6048918560ba7db" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;limit&lt;/code&gt;&lt;/b&gt;: A 0-D &lt;code&gt;Tensor&lt;/code&gt; (scalar). Upper limit of sequence, exclusive. If None, defaults to the value of &lt;code&gt;start&lt;/code&gt; while the first entry of the range defaults to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c187261b285fa48cefe4cc7b1866742d0f1879" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;limit&lt;/code&gt;&lt;/b&gt;: A limit on the number of frames to return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1638fc063ba5ce6d8839079c7a6ba635294727f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;limit&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;int&lt;/code&gt;. If incrementing ref would bring it above limit, instead generates an 'OutOfRange' error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="715e2ee453ba6c93437899144da680cb177c8869" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;limit&lt;/code&gt;&lt;/b&gt;: An int32 scalar tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a732e858f942e9835f1c7106330d170323495db5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;limit&lt;/code&gt;&lt;/b&gt;: value at which incrementing the variable raises an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a5404b896176ca2d23beb989fe1f59469c3a7b9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;limits&lt;/code&gt;&lt;/b&gt;: Vector or scalar &lt;code&gt;Tensor&lt;/code&gt;. Specifies the exclusive upper limits for each range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf7f301ad5f5a17d2c605fb4fa3f9717b16df709" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;line_length&lt;/code&gt;&lt;/b&gt;: Total length of printed lines (e.g. set this to adapt the display to different terminal window sizes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cddd2933fd688db8abe4aa0461a94a4b72fdcd1a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;linear_feature_columns&lt;/code&gt;&lt;/b&gt;: An iterable containing all the feature columns used by linear part of the model. All items in the set must be instances of classes derived from &lt;code&gt;FeatureColumn&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d157eb96ab4155e4557f7c16371233bcc4b6318" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;linear_model&lt;/code&gt;&lt;/b&gt;: a premade LinearModel, its output must match the output of the dnn model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb17dbd3d7d6d04c921055bf0e0f938e6eef92bc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;linear_name&lt;/code&gt;&lt;/b&gt;: The suffix for the variable that keeps the linear gradient accumulator. If not present, defaults to name + &quot;_1&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550a8eacd018420d4fa8dfb5d94dab1cbcce97bf" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;linear_optimizer&lt;/code&gt;&lt;/b&gt;: An instance of &lt;code&gt;tf.keras.optimizers.*&lt;/code&gt; used to apply gradients to the linear part of the model. Can also be a string (one of 'Adagrad', 'Adam', 'Ftrl', 'RMSProp', 'SGD'), or callable. Defaults to FTRL optimizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cee6ceb5bc2ed56abdf421b32a0371d8f285af6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;linear_sparse_combiner&lt;/code&gt;&lt;/b&gt;: A string specifying how to reduce the linear model if a categorical column is multivalent. One of &quot;mean&quot;, &quot;sqrtn&quot;, and &quot;sum&quot; -- these are effectively different ways to do example-level normalization, which can be useful for bag-of-words features. For more details, see &lt;code&gt;tf.feature_column.linear_model&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77d7d938dd2944116ef1a9e15dbda9d7a97fd0d1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;list1&lt;/code&gt;&lt;/b&gt;: The first list to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="639c27c84c3f846eedf388080b67bd50083e4e1f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;list2&lt;/code&gt;&lt;/b&gt;: The second list to compare.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1227cd9a8c29a62ac1a6a70b20e598943e7de9ba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;list_clipped&lt;/code&gt;&lt;/b&gt;: A list of &lt;code&gt;Tensors&lt;/code&gt; of the same type as &lt;code&gt;list_t&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="915015d67a1a2c067cf911442a7e11382de6a087" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;listeners&lt;/code&gt;&lt;/b&gt;: List of &lt;code&gt;CheckpointSaverListener&lt;/code&gt; subclass instances. Used for callbacks that run immediately before or after this hook saves the checkpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f8b4463942325589bc267a8cc61a89378e6fbcd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;little_endian&lt;/code&gt;&lt;/b&gt;: Whether the &lt;code&gt;input_bytes&lt;/code&gt; data is in little-endian format. Data will be converted into host byte order if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="596d27ecf8e75ab290ec2e4363252c4caddeecba" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loc&lt;/code&gt;&lt;/b&gt;: Floating point tensor which characterizes the location (center) of the distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85de9c7d3be21fbe94a1aed7ddbee304901d15a7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loc&lt;/code&gt;&lt;/b&gt;: Floating point tensor; the means of the distribution(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9dca7332c577c99e621988facac53a0f8560a0b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loc&lt;/code&gt;&lt;/b&gt;: Floating-point &lt;code&gt;Tensor&lt;/code&gt;. The mean(s) of the distribution(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1ed25f185d245adf508867c15864e87039af00e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;local_init_feed_dict&lt;/code&gt;&lt;/b&gt;: Optional session feed dictionary to use when running the local_init_op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="499d95ac423310b373ecb9fa6e49b7e7f1432a3a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;local_init_op&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Operation&lt;/code&gt;. Used by all supervisors to run initializations that should run for every new supervisor instance. By default these are table initializers and initializers for local variables. If &lt;code&gt;None&lt;/code&gt;, no further per supervisor-instance initialization is done automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173d42a2da3eaa778a66ff120af8a655ec06a574" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;local_init_op&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;Operation&lt;/code&gt; run immediately after session creation. Usually used to initialize tables and local variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c2b1475fccdaa39e3a1137ac962b84876484dfa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;local_init_op&lt;/code&gt;&lt;/b&gt;: Optional op to initialize local variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af528195319fa3f686ab1f3b71d241b61cce3b4d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;local_init_run_options&lt;/code&gt;&lt;/b&gt;: RunOptions to be passed as the SessionManager local_init_run_options parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df7f9e7db718cad9648040b4d08ebd837dbd7d61" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;local_init_run_options&lt;/code&gt;&lt;/b&gt;: RunOptions to be passed to session.run when executing the local_init_op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa41ba8ad75477112fee349c5d84b5627f3f5111" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;local_step&lt;/code&gt;&lt;/b&gt;: Time step at which the gradient was computed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="634db288e7796619f6c8eccf67d9c17b38caea24" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;log_abs_determinant&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Has the same type as &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2197ce3204450e78841b88442a9baf6e0303e3e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;log_dir&lt;/code&gt;&lt;/b&gt;: directory to write the log file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e0a3d8fc7d0dc79653a07ee30ef01c0c78c86d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;log_dir&lt;/code&gt;&lt;/b&gt;: the path of the directory where to save the log files to be parsed by TensorBoard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ece1a265c3be04b027b8826ea5bf1f846911473" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;log_input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3774f67d769f3453067dd504a83b9f81235ce33a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;log_mel_spectrograms&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;[..., num_mel_bins]&lt;/code&gt;&lt;code&gt;float32&lt;/code&gt;/&lt;code&gt;float64&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; of log-magnitude mel-scale spectrograms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d09a19f4059787bf6c1b7bbae3f6dd4b6fe0e269" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;log_prob&lt;/code&gt;&lt;/b&gt;: a &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;sample_shape(x) + self.batch_shape&lt;/code&gt; with values of type &lt;code&gt;self.dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="386986b7275c37d979bde62d4bc23612a4569af3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;log_probability&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;float&lt;/code&gt; matrix &lt;code&gt;(batch_size x top_paths)&lt;/code&gt; containing sequence log-probabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d54459e65e84eeb32ec9d623f7f3e7f430f309" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;log_probability&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;float&lt;/code&gt; matrix &lt;code&gt;[batch_size, top_paths]&lt;/code&gt; containing sequence log-probabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="844fc8be7c37b2b73da66070863427457627e995" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;log_step_count_steps&lt;/code&gt;&lt;/b&gt;: The frequency, in number of global steps, that the global step and the loss will be logged during training. Also controls the frequency that the global steps / s will be logged (and written to summary) during training.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4791398c41433465a6c51f6cc04cd8c6176f58c2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;log_step_count_steps&lt;/code&gt;&lt;/b&gt;: The frequency, in number of global steps, that the global step/sec is logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93650aeaefc311ca50523ee2d4449ba90d84fbb5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logcdf&lt;/code&gt;&lt;/b&gt;: a &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;sample_shape(x) + self.batch_shape&lt;/code&gt; with values of type &lt;code&gt;self.dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36b0897a81cbcc790ccd0c65b1ad2bf84799b575" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logdir&lt;/code&gt;&lt;/b&gt;: A string. Directory where event file will be written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f67bfff17c05e4640eb32c2f98fe3322b3e69b0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logdir&lt;/code&gt;&lt;/b&gt;: A string. Optional path to a directory where to checkpoint the model and log events for the visualizer. Used by chief supervisors. The directory will be created if it does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7421981906fc65e3f93583a550840c321d03b830" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logdir&lt;/code&gt;&lt;/b&gt;: Directory where to write the graph. This can refer to remote filesystems, such as Google Cloud Storage (GCS).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c635a9de6be447a33962711ba4739400d008fb74" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logdir&lt;/code&gt;&lt;/b&gt;: a string specifying the directory in which to write an event file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfac471038b36309d4ef3043c8214bcee49b93c6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logdir&lt;/code&gt;&lt;/b&gt;: str, name of the directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f280cc60c2cd276f6d76faeb19bd4555d0fb9301" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logical_core&lt;/code&gt;&lt;/b&gt;: An integer, identifying a logical core.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6046c89588d4fdb0343b1a880794bdb72473c41" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logical_devices&lt;/code&gt;&lt;/b&gt;: (optional) List of &lt;a href=&quot;logicaldeviceconfiguration&quot;&gt;&lt;code&gt;tf.config.LogicalDeviceConfiguration&lt;/code&gt;&lt;/a&gt; objects to allocate for the specified &lt;code&gt;PhysicalDevice&lt;/code&gt;. If None, the default configuration will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29712c6122bc07ee02b23181acbd4fd920333b6d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logit_fn&lt;/code&gt;&lt;/b&gt;: A logit_fn as defined above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a00720b18a1ee5987a241663e17804a3a598b8e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logit_length&lt;/code&gt;&lt;/b&gt;: tensor of shape [batch_size] Length of input sequence in logits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83dc168782946f44c3f049919301caf0629a9233" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: 2-D Tensor with shape &lt;code&gt;[batch_size, num_classes]&lt;/code&gt;. Each slice &lt;code&gt;[i, :]&lt;/code&gt; represents the unnormalized log-probabilities for all classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0242a90d9cc0aa4535de54eaca9ae006505976ee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe78d972d7b2e0130cc2790b13f9e12e5efe94e2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: A non-empty &lt;code&gt;Tensor&lt;/code&gt;, or an object whose type has a registered &lt;code&gt;Tensor&lt;/code&gt; conversion function. Must be one of the following types: &lt;code&gt;half&lt;/code&gt;,&lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;. See also &lt;code&gt;convert_to_tensor&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="873ef8d6af64b2e271c2a43b16ddf47278311490" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: A non-empty &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb3503d261fc1e789db59b738af3ad501f83237" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: Alias for inputs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c0cd2ef187180b490029465663b534cc9253c2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: An N-D &lt;code&gt;Tensor&lt;/code&gt; representing the log-odds of a &lt;code&gt;1&lt;/code&gt; event. Each entry in the &lt;code&gt;Tensor&lt;/code&gt; parametrizes an independent Bernoulli distribution where the probability of an event is sigmoid(logits). Only one of &lt;code&gt;logits&lt;/code&gt; or &lt;code&gt;probs&lt;/code&gt; should be passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3984201a0d3ac55fc87f2bcb9ccd3ff0f2008ee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: An N-D &lt;code&gt;Tensor&lt;/code&gt;, &lt;code&gt;N &amp;gt;= 1&lt;/code&gt;, representing the log probabilities of a set of Categorical distributions. The first &lt;code&gt;N - 1&lt;/code&gt; dimensions index into a batch of independent distributions and the last dimension represents a vector of logits for each class. Only one of &lt;code&gt;logits&lt;/code&gt; or &lt;code&gt;probs&lt;/code&gt; should be passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b0c454144d93ab9c0ca79ee736de20386eb2f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: Float &lt;code&gt;[batch_size, num_classes]&lt;/code&gt; logits outputs of the network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f1d1c3ee6ee3655f4f00c5337c9f1ed222a67c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: Floating point tensor representing unnormalized log-probabilities of a positive event with shape broadcastable to &lt;code&gt;[N1,..., Nm, K]&lt;/code&gt;&lt;code&gt;m &amp;gt;= 0&lt;/code&gt;, and the same dtype as &lt;code&gt;total_count&lt;/code&gt;. Defines this as a batch of &lt;code&gt;N1 x ... x Nm&lt;/code&gt; different &lt;code&gt;K&lt;/code&gt; class Multinomial distributions. Only one of &lt;code&gt;logits&lt;/code&gt; or &lt;code&gt;probs&lt;/code&gt; should be passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eadc8f437c8217865587e78c2e00fa57754b6b92" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: Input &lt;code&gt;dict&lt;/code&gt; keyed by head name, or logits &lt;code&gt;Tensor&lt;/code&gt; with shape &lt;code&gt;[D0, D1, ... DN, logits_dimension]&lt;/code&gt;. For many applications, the &lt;code&gt;Tensor&lt;/code&gt; shape is &lt;code&gt;[batch_size, logits_dimension]&lt;/code&gt;. If logits is a &lt;code&gt;Tensor&lt;/code&gt;, it will split the &lt;code&gt;Tensor&lt;/code&gt; along the last dimension and distribute it appropriately among the heads. Check &lt;code&gt;MultiHead&lt;/code&gt; for examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a1168df25109959d19b80be235b933ec801c1d9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: Logits &lt;code&gt;Tensor&lt;/code&gt; to be used by the head.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56aa3aa9dcb38920b6cf9b63952e276bc263e32d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: Logits &lt;code&gt;Tensor&lt;/code&gt; to be used for loss construction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e46810ceadb79a555858696f2aa787de3c39052" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: Logits &lt;code&gt;Tensor&lt;/code&gt; to be used for prediction construction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e8e68a19cbf2d54b8fb24871a363ddf527deb11" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: Logits outputs of the network.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc1dbc9664bf11a0dc56ebd4fd775e5f03290f55" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: Per-label activations (typically a linear output) of shape &lt;code&gt;[d_0, d_1, ..., d_{r-1}, num_classes]&lt;/code&gt; and dtype &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, or &lt;code&gt;float64&lt;/code&gt;. These activation energies are interpreted as unnormalized log probabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcb26003cba3c92fcbd7c107b50ad5305a934e11" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: Per-label activations, typically a linear output. These activation energies are interpreted as unnormalized log probabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3837bade4d0d7237ab90e89de751242bfedd4675" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: The logits, a float tensor. Note that logits are assumed to be unbounded and 0-centered. A value &amp;gt; 0 (resp. &amp;lt; 0) is considered a positive (resp. negative) binary prediction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb17dc72e0aded86bdae61768d3cc8a312bfdcf8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: Unscaled log probabilities of shape &lt;code&gt;[d_0, d_1, ..., d_{r-1}, num_classes]&lt;/code&gt; and dtype &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f701c710f0ac9463c20e725e20d4da546e61e15d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: Unscaled log probabilities of shape &lt;code&gt;[d_0, d_1, ..., d_{r-1}, num_classes]&lt;/code&gt; and dtype &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, or &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ce14be4df4ab518e3f0d9e018d2d455c6511f8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: Unscaled log probabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9495741277a55a08fbfed6398940a523245795" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: logits &lt;code&gt;Tensor&lt;/code&gt; to be used for metrics update.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7862003f4d17a590d00de7d4a712bd8972290c4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: logits &lt;code&gt;Tensor&lt;/code&gt; with shape &lt;code&gt;[D0, D1, ... DN, logits_dimension]&lt;/code&gt;. For many applications, the shape is &lt;code&gt;[batch_size, logits_dimension]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eee0829253e1bd5afc5f8db4b52ec58d50d1a6e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits&lt;/code&gt;&lt;/b&gt;: tensor of shape [frames, batch_size, num_labels], if logits_time_major == False, shape is [batch_size, frames, num_labels].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4fdb6da5481ab4c52d78fb324f2773cceb0aa4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logits_time_major&lt;/code&gt;&lt;/b&gt;: (optional) If True (default), logits is shaped [time, batch, logits]. If False, shape is [batch, time, logits]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d04824d484bd9ab8025e75fbddfd811de359494d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logs&lt;/code&gt;&lt;/b&gt;: dict, metric results for this training epoch, and for the validation epoch if validation is performed. Validation result keys are prefixed with &lt;code&gt;val_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db8b9a9564849ede1f78d161bfbba3cfca6a6e2" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logs&lt;/code&gt;&lt;/b&gt;: dict. Currently no data is passed to this argument for this method but that may change in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0120d43afb7afa3da89f80269fa8cc5016b49a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logs&lt;/code&gt;&lt;/b&gt;: dict. Has keys &lt;code&gt;batch&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt; representing the current batch number and the size of the batch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="908cdb4ba304bd058c3b2d2128dce8120b0c951d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;logs&lt;/code&gt;&lt;/b&gt;: dict. Metric results for this batch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f45ba3d73d8fa39313ec09e3e9e51810bb54bc7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lookup_key_dtype&lt;/code&gt;&lt;/b&gt;: Data type of keys passed to &lt;code&gt;lookup&lt;/code&gt;. Defaults to &lt;code&gt;initializer.key_dtype&lt;/code&gt; if &lt;code&gt;initializer&lt;/code&gt; is specified, otherwise &lt;a href=&quot;../../../../tf#string&quot;&gt;&lt;code&gt;tf.string&lt;/code&gt;&lt;/a&gt;. Must be string or integer, and must be castable to &lt;code&gt;initializer.key_dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ae226bb057fdad388c495b5ce023c76fcdeb6de" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lookup_key_dtype&lt;/code&gt;&lt;/b&gt;: Data type of keys passed to &lt;code&gt;lookup&lt;/code&gt;. Defaults to &lt;code&gt;initializer.key_dtype&lt;/code&gt; if &lt;code&gt;initializer&lt;/code&gt; is specified, otherwise &lt;a href=&quot;../../tf#string&quot;&gt;&lt;code&gt;tf.string&lt;/code&gt;&lt;/a&gt;. Must be string or integer, and must be castable to &lt;code&gt;initializer.key_dtype&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46168e6dfe0aef945eb10636561cdef67666ade9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loop_fn&lt;/code&gt;&lt;/b&gt;: A callable that takes inputs &lt;code&gt;(time, cell_output, cell_state, loop_state)&lt;/code&gt; and returns the tuple &lt;code&gt;(finished, next_input, next_cell_state, emit_output, next_loop_state)&lt;/code&gt;. Here &lt;code&gt;time&lt;/code&gt; is an int32 scalar &lt;code&gt;Tensor&lt;/code&gt;, &lt;code&gt;cell_output&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; or (possibly nested) tuple of tensors as determined by &lt;code&gt;cell.output_size&lt;/code&gt;, and &lt;code&gt;cell_state&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; or (possibly nested) tuple of tensors, as determined by the &lt;code&gt;loop_fn&lt;/code&gt; on its first call (and should match &lt;code&gt;cell.state_size&lt;/code&gt;). The outputs are: &lt;code&gt;finished&lt;/code&gt;, a boolean &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[batch_size]&lt;/code&gt;, &lt;code&gt;next_input&lt;/code&gt;: the next input to feed to &lt;code&gt;cell&lt;/code&gt;, &lt;code&gt;next_cell_state&lt;/code&gt;: the next state to feed to &lt;code&gt;cell&lt;/code&gt;, and &lt;code&gt;emit_output&lt;/code&gt;: the output to store for this iteration. Note that &lt;code&gt;emit_output&lt;/code&gt; should be a &lt;code&gt;Tensor&lt;/code&gt; or (possibly nested) tuple of tensors which is aggregated in the &lt;code&gt;emit_ta&lt;/code&gt; inside the &lt;code&gt;while_loop&lt;/code&gt;. For the first call to &lt;code&gt;loop_fn&lt;/code&gt;, the &lt;code&gt;emit_output&lt;/code&gt; corresponds to the &lt;code&gt;emit_structure&lt;/code&gt; which is then used to determine the size of the &lt;code&gt;zero_tensor&lt;/code&gt; for the &lt;code&gt;emit_ta&lt;/code&gt; (defaults to &lt;code&gt;cell.output_size&lt;/code&gt;). For the subsequent calls to the &lt;code&gt;loop_fn&lt;/code&gt;, the &lt;code&gt;emit_output&lt;/code&gt; corresponds to the actual output tensor that is to be aggregated in the &lt;code&gt;emit_ta&lt;/code&gt;. The parameter &lt;code&gt;cell_state&lt;/code&gt; and output &lt;code&gt;next_cell_state&lt;/code&gt; may be either a single or (possibly nested) tuple of tensors. The parameter &lt;code&gt;loop_state&lt;/code&gt; and output &lt;code&gt;next_loop_state&lt;/code&gt; may be either a single or (possibly nested) tuple of &lt;code&gt;Tensor&lt;/code&gt; and &lt;code&gt;TensorArray&lt;/code&gt; objects. This last parameter may be ignored by &lt;code&gt;loop_fn&lt;/code&gt; and the return value may be &lt;code&gt;None&lt;/code&gt;. If it is not &lt;code&gt;None&lt;/code&gt;, then the &lt;code&gt;loop_state&lt;/code&gt; will be propagated through the RNN loop, for use purely by &lt;code&gt;loop_fn&lt;/code&gt; to keep track of its own state. The &lt;code&gt;next_loop_state&lt;/code&gt; parameter returned may be &lt;code&gt;None&lt;/code&gt;. The first call to &lt;code&gt;loop_fn&lt;/code&gt; will be &lt;code&gt;time = 0&lt;/code&gt;, &lt;code&gt;cell_output = None&lt;/code&gt;, &lt;code&gt;cell_state = None&lt;/code&gt;, and &lt;code&gt;loop_state = None&lt;/code&gt;. For this call: The &lt;code&gt;next_cell_state&lt;/code&gt; value should be the value with which to initialize the cell's state. It may be a final state from a previous RNN or it may be the output of &lt;code&gt;cell.zero_state()&lt;/code&gt;. It should be a (possibly nested) tuple structure of tensors. If &lt;code&gt;cell.state_size&lt;/code&gt; is an integer, this must be a &lt;code&gt;Tensor&lt;/code&gt; of appropriate type and shape &lt;code&gt;[batch_size, cell.state_size]&lt;/code&gt;. If &lt;code&gt;cell.state_size&lt;/code&gt; is a &lt;code&gt;TensorShape&lt;/code&gt;, this must be a &lt;code&gt;Tensor&lt;/code&gt; of appropriate type and shape &lt;code&gt;[batch_size] + cell.state_size&lt;/code&gt;. If &lt;code&gt;cell.state_size&lt;/code&gt; is a (possibly nested) tuple of ints or &lt;code&gt;TensorShape&lt;/code&gt;, this will be a tuple having the corresponding shapes. The &lt;code&gt;emit_output&lt;/code&gt; value may be either &lt;code&gt;None&lt;/code&gt; or a (possibly nested) tuple structure of tensors, e.g., &lt;code&gt;(tf.zeros(shape_0, dtype=dtype_0), tf.zeros(shape_1, dtype=dtype_1))&lt;/code&gt;. If this first &lt;code&gt;emit_output&lt;/code&gt; return value is &lt;code&gt;None&lt;/code&gt;, then the &lt;code&gt;emit_ta&lt;/code&gt; result of &lt;code&gt;raw_rnn&lt;/code&gt; will have the same structure and dtypes as &lt;code&gt;cell.output_size&lt;/code&gt;. Otherwise &lt;code&gt;emit_ta&lt;/code&gt; will have the same structure, shapes (prepended with a &lt;code&gt;batch_size&lt;/code&gt; dimension), and dtypes as &lt;code&gt;emit_output&lt;/code&gt;. The actual values returned for &lt;code&gt;emit_output&lt;/code&gt; at this initializing call are ignored. Note, this emit structure must be consistent across all time steps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c2115c10c8f3865fea6715c0a70bf9cf8bb0763" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loop_vars&lt;/code&gt;&lt;/b&gt;: A (possibly nested) tuple, namedtuple or list of numpy array, &lt;code&gt;Tensor&lt;/code&gt;, and &lt;code&gt;TensorArray&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1276ebb30025ebd96fd38054fc2712e3ede8bfde" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; containing the value to minimize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390d594f682e72ba1b1049ba42338dc9cddd78ec" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss&lt;/code&gt;&lt;/b&gt;: A Tensor containing the value to minimize or a callable taking no arguments which returns the value to minimize. When eager execution is enabled it must be a callable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76af9891d6bcc3c2b778c776d120ab1c97065a7b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss&lt;/code&gt;&lt;/b&gt;: A Tensor containing the value to minimize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dce00cea6b17d42bd60f3d41d6f22d3f153c7d6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss&lt;/code&gt;&lt;/b&gt;: A callable taking no arguments which returns the value to minimize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a63478a31713d8217de872df7155d7a6643296c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss&lt;/code&gt;&lt;/b&gt;: A loss &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0e806a383414b3314ddfd2a7dd522bf7df7a2c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss&lt;/code&gt;&lt;/b&gt;: Loss tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d4521027f3569be2a78432c95735ea5338962fb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss&lt;/code&gt;&lt;/b&gt;: Scalar tensor to minimize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6323cd874fd1c523bcf052a53690afa1c735bcc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss&lt;/code&gt;&lt;/b&gt;: String (name of objective function), objective function or &lt;a href=&quot;../losses/loss&quot;&gt;&lt;code&gt;tf.keras.losses.Loss&lt;/code&gt;&lt;/a&gt; instance. See &lt;a href=&quot;../losses&quot;&gt;&lt;code&gt;tf.keras.losses&lt;/code&gt;&lt;/a&gt;. An objective function is any callable with the signature &lt;code&gt;scalar_loss = fn(y_true, y_pred)&lt;/code&gt;. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f105f8495ac36ce87f1854594613f5e6df68351c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss&lt;/code&gt;&lt;/b&gt;: String (name of objective function), objective function or &lt;a href=&quot;losses/loss&quot;&gt;&lt;code&gt;tf.keras.losses.Loss&lt;/code&gt;&lt;/a&gt; instance. See &lt;a href=&quot;losses&quot;&gt;&lt;code&gt;tf.keras.losses&lt;/code&gt;&lt;/a&gt;. An objective function is any callable with the signature &lt;code&gt;scalar_loss = fn(y_true, y_pred)&lt;/code&gt;. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd40959d4d5172186cf531ca2dc2551565fa3da4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss&lt;/code&gt;&lt;/b&gt;: The loss, which will be multiplied by the loss scale. Can either be a tensor or a callable returning a tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25635356fe8ca240474aafba10fb2ab1b9df1526" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss&lt;/code&gt;&lt;/b&gt;: Training loss &lt;code&gt;Tensor&lt;/code&gt;. Must be either scalar, or with shape &lt;code&gt;[1]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a1e828804989191106eb768f52b30f46e97336" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss&lt;/code&gt;&lt;/b&gt;: tensor of shape [batch_size], negative log probabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155db6477763baa79d2e9a7b58947e65899eb5b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_collection&lt;/code&gt;&lt;/b&gt;: Optional collection to add the loss to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1826a6c18187e3cf1f844bbb03a75d1b3670804f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_collection&lt;/code&gt;&lt;/b&gt;: Optional losses collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f582f15705fecc120bb30b620872dfe21551133e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_collection&lt;/code&gt;&lt;/b&gt;: collection to which the loss will be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17641af665901e5fa0d26469b64cd03db6db53fb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_collection&lt;/code&gt;&lt;/b&gt;: collection to which this loss will be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a051fbd3e3863453ebb48ad629a22456fcc76cd9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_collection&lt;/code&gt;&lt;/b&gt;: the loss will be added to these collections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995ea89e40e19de3f3f43a34180f2a5b9d6938f6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_fn&lt;/code&gt;&lt;/b&gt;: Optional loss function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7571125bc474a227b2942a0a070a4e1440faa5a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_fn&lt;/code&gt;&lt;/b&gt;: Optional loss function. Defaults to &lt;code&gt;mean_squared_error&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb4d0a10e94a1a164fb3cbf39b68071d49247687" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_reduction&lt;/code&gt;&lt;/b&gt;: One of &lt;a href=&quot;../../keras/losses/reduction&quot;&gt;&lt;code&gt;tf.losses.Reduction&lt;/code&gt;&lt;/a&gt; except &lt;code&gt;NONE&lt;/code&gt;. Describes how to reduce training loss over batch. Defaults to &lt;code&gt;SUM_OVER_BATCH_SIZE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd85e01b5bba62a698a948c5e63352f3a499ae4d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_reduction&lt;/code&gt;&lt;/b&gt;: One of &lt;a href=&quot;../keras/losses/reduction&quot;&gt;&lt;code&gt;tf.losses.Reduction&lt;/code&gt;&lt;/a&gt; except &lt;code&gt;NONE&lt;/code&gt;. Decides how to reduce training loss over batch and label dimension. Defaults to &lt;code&gt;SUM_OVER_BATCH_SIZE&lt;/code&gt;, namely weighted sum of losses divided by &lt;code&gt;batch size * label_dimension&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6453c598a9175f42e45f05e7329f83291a2a923a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_reduction&lt;/code&gt;&lt;/b&gt;: One of &lt;a href=&quot;../keras/losses/reduction&quot;&gt;&lt;code&gt;tf.losses.Reduction&lt;/code&gt;&lt;/a&gt; except &lt;code&gt;NONE&lt;/code&gt;. Decides how to reduce training loss over batch. Defaults to &lt;code&gt;SUM_OVER_BATCH_SIZE&lt;/code&gt;, namely weighted sum of losses divided by &lt;code&gt;batch size * label_dimension&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9710861e0c9780deb18d7cfa4e5652cbcd9634f8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_reduction&lt;/code&gt;&lt;/b&gt;: One of &lt;a href=&quot;../keras/losses/reduction&quot;&gt;&lt;code&gt;tf.losses.Reduction&lt;/code&gt;&lt;/a&gt; except &lt;code&gt;NONE&lt;/code&gt;. Decides how to reduce training loss over batch. Defaults to &lt;code&gt;SUM_OVER_BATCH_SIZE&lt;/code&gt;, namely weighted sum of losses divided by batch size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15ab2c8b9bdcced1a975fa5c6ab9b228eb4a34d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_reduction&lt;/code&gt;&lt;/b&gt;: One of &lt;a href=&quot;../keras/losses/reduction&quot;&gt;&lt;code&gt;tf.losses.Reduction&lt;/code&gt;&lt;/a&gt; except &lt;code&gt;NONE&lt;/code&gt;. Describes how to reduce training loss over batch. Defaults to &lt;code&gt;SUM&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419e5db521e9947d0a1188a4b410afec38f437c9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_reduction&lt;/code&gt;&lt;/b&gt;: One of &lt;a href=&quot;../keras/losses/reduction&quot;&gt;&lt;code&gt;tf.losses.Reduction&lt;/code&gt;&lt;/a&gt; except &lt;code&gt;NONE&lt;/code&gt;. Describes how to reduce training loss over batch. Defaults to &lt;code&gt;SUM_OVER_BATCH_SIZE&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8de72b133d40af21ce70bcabf6a46eae44c43637" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_scale&lt;/code&gt;&lt;/b&gt;: A &lt;a href=&quot;../../../mixed_precision/experimental/lossscale&quot;&gt;&lt;code&gt;tf.mixed_precision.experimental.LossScale&lt;/code&gt;&lt;/a&gt;, an int (which uses a &lt;code&gt;FixedLossScale&lt;/code&gt;), or the string &quot;dynamic&quot; (which uses a &lt;code&gt;DynamicLossScale&lt;/code&gt;). Defaults to using no loss scaling unless &lt;code&gt;name&lt;/code&gt; is &quot;mixed_float16&quot;, in which case this defaults to &quot;dynamic&quot;. Only &lt;a href=&quot;../../model&quot;&gt;&lt;code&gt;tf.keras.Model&lt;/code&gt;&lt;/a&gt;s, not layers, use the loss scale, and it is only used during &lt;a href=&quot;../../model#fit&quot;&gt;&lt;code&gt;Model.fit&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../model#train_on_batch&quot;&gt;&lt;code&gt;Model.train_on_batch&lt;/code&gt;&lt;/a&gt;, and other similar methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf704e6085f5d8293b4495b6fb4bb620ace37f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_scale&lt;/code&gt;&lt;/b&gt;: Either an int/float, the string &lt;code&gt;&quot;dynamic&quot;&lt;/code&gt;, or an instance of a &lt;a href=&quot;../../../../mixed_precision/experimental/lossscale&quot;&gt;&lt;code&gt;tf.mixed_precision.experimental.LossScale&lt;/code&gt;&lt;/a&gt;. The loss scale to use. It is recommended to keep this as its default value of &lt;code&gt;&quot;dynamic&quot;&lt;/code&gt;, which will adjust the scaling automatically to prevent &lt;code&gt;Inf&lt;/code&gt; or &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cadf3b6e1abf5612ea936e0eb8c95db307739e64" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_scale&lt;/code&gt;&lt;/b&gt;: Either an int/float, the string &lt;code&gt;&quot;dynamic&quot;&lt;/code&gt;, or an instance of a &lt;a href=&quot;../../mixed_precision/experimental/lossscale&quot;&gt;&lt;code&gt;tf.mixed_precision.experimental.LossScale&lt;/code&gt;&lt;/a&gt;. The loss scale to use. It is recommended to keep this as its default value of &lt;code&gt;&quot;dynamic&quot;&lt;/code&gt;, which will adjust the scaling automatically to prevent &lt;code&gt;Inf&lt;/code&gt; or &lt;code&gt;NaN&lt;/code&gt; values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39016cc57469d906b9480c6608d4764a7f051901" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_scale&lt;/code&gt;&lt;/b&gt;: The loss scale to scale the loss and gradients. This can either be an int/float to use a fixed loss scale, the string &quot;dynamic&quot; to use dynamic loss scaling, or an instance of a LossScale. The string &quot;dynamic&quot; equivalent to passing &lt;code&gt;DynamicLossScale()&lt;/code&gt;, and passing an int/float is equivalent to passing a FixedLossScale with the given loss scale.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07974311d4ee3293d832b4a048806eb344a5fcb0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_scale_value&lt;/code&gt;&lt;/b&gt;: A Python float. Its ideal value varies depending on models to run. Choosing a too small loss_scale might affect model quality; a too big loss_scale might cause inf or nan. There is no single right loss_scale to apply. There is no harm choosing a relatively big number as long as no nan or inf is encountered in training.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d34ecb52caa950891eb8b4000431050c3d2bcd5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_tensor&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt;, the loss tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5d1594257d4b69c155db074ac81a7c755076c5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_type&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;string&lt;/code&gt; from: &lt;code&gt;&quot;logistic_loss&quot;, &quot;squared_loss&quot;, &quot;hinge_loss&quot;, &quot;smooth_hinge_loss&quot;, &quot;poisson_loss&quot;&lt;/code&gt;. Type of the primal loss. Currently SdcaSolver supports logistic, squared and hinge losses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92aac277b6c9f689d68ef594676d741d75835fb8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;loss_weights&lt;/code&gt;&lt;/b&gt;: Optional list or dictionary specifying scalar coefficients (Python floats) to weight the loss contributions of different model outputs. The loss value that will be minimized by the model will then be the &lt;em&gt;weighted sum&lt;/em&gt; of all individual losses, weighted by the &lt;code&gt;loss_weights&lt;/code&gt; coefficients. If a list, it is expected to have a 1:1 mapping to the model's outputs. If a tensor, it is expected to map output names (strings) to scalar coefficients.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a012e4c4d53798c8d3805464bd8794e27d722a71" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;losses&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[batch_size, d1, ... dN]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a9e7ec47e2354be07ee7a1062a5bfc16ccde07" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;losses&lt;/code&gt;&lt;/b&gt;: Loss tensor, or list/tuple of tensors. Rather than tensors, losses may also be zero-argument callables which create a loss tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9496f87f557348444cad60a955216854e16764d3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;low&lt;/code&gt;&lt;/b&gt;: Float, lower boundary of the output interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94813cee1f37a3e0ec49c5e1b7024d6aae289c4f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;low&lt;/code&gt;&lt;/b&gt;: Floating point tensor, lower boundary of the output interval. Must have &lt;code&gt;low &amp;lt; high&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a0d68f6504699c2e8773dae9a6b588ddffac644" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lower&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;bool&lt;/code&gt;. Defaults to &lt;code&gt;True&lt;/code&gt;. Boolean indicating whether the innermost matrices in &lt;code&gt;matrix&lt;/code&gt; are lower or upper triangular.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1865948f4d401a0a872817bc250a9f9c5cf9a113" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lower&lt;/code&gt;&lt;/b&gt;: float. Lower bound for the random contrast factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="470f8ce056e8228dc13c474c99d6d41d53a1a324" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lower&lt;/code&gt;&lt;/b&gt;: float. Lower bound for the random saturation factor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7173083571aed2f471b74155ae5cd41aa70c221f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lower_bound&lt;/code&gt;&lt;/b&gt;: float, min value of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e88a057ba80b9cebff47f5aaaa2ad62431349f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lower_bound&lt;/code&gt;&lt;/b&gt;: float, min values of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592621bf35688dff1fca9a84514bf5fd1a70d11d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lower_bound&lt;/code&gt;&lt;/b&gt;: int, min value of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d39563b2fb69e8bed8cce4d88b84ada891a28bd4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lower_bound&lt;/code&gt;&lt;/b&gt;: int, min values of the flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e85091844043f111c49c446fc54f2c46359f7b86" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lower_bound&lt;/code&gt;&lt;/b&gt;: lower bound of the range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc93bb086791130c78374d2b434ebc197c44687" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lower_edge_hertz&lt;/code&gt;&lt;/b&gt;: Python float. Lower bound on the frequencies to be included in the mel spectrum. This corresponds to the lower edge of the lowest triangular band.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df55d5a178a6f5f4dc46656baf0575fa324559ab" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lower_upper&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;lu&lt;/code&gt; as returned by &lt;a href=&quot;lu&quot;&gt;&lt;code&gt;tf.linalg.lu&lt;/code&gt;&lt;/a&gt;, i.e., if &lt;code&gt;matmul(P, matmul(L, U)) = X&lt;/code&gt; then &lt;code&gt;lower_upper = L + U - eye&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30172db0996fb4a5222383e32b7e5b79c9d0ded0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;lu&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Has the same type as &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64741807f453499e599c3b8ddf20bd7925daa371" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;m&lt;/code&gt;&lt;/b&gt;: A 1D mean Tensor with size matching the last dimension of t. This is the first output from tf.nn.moments, or a saved moving average thereof.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b92d0f8dac244d51ae3e0ba9fe6c6c757a7a4e87" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;m&lt;/code&gt;&lt;/b&gt;: the maximum norm for the incoming weights.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d8b2a69b253926b1a079030a6081966bb2609b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;m_mul&lt;/code&gt;&lt;/b&gt;: A scalar &lt;code&gt;float32&lt;/code&gt; or &lt;code&gt;float64&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; or a Python number. Used to derive the initial learning rate of the i-th period:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e78c1230aaa878e3f08aae6e1b1826b4ce8d27c8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;make_master_device_default&lt;/code&gt;&lt;/b&gt;: If True and a cluster resolver is passed, will automatically enter the master task device scope, which indicates the master becomes the default device to run ops. It won't do anything if a cluster spec is passed. Will throw an error if the caller is currently already in some device scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab1d6525b1b068f4d0444e2994189074c0ea2e0e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;manager&lt;/code&gt;&lt;/b&gt;: The context manager to enter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d973d197eafc40a78893b8980e203885cba30dda" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;map_func&lt;/code&gt;&lt;/b&gt;: A function mapping a dataset element to a dataset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f7abdfabcf41ec3a806bbff04e46a8e734e5a9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;map_func&lt;/code&gt;&lt;/b&gt;: A function mapping a dataset element to another dataset element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2370a23bdb2a28467bf7ccd1b770206454e3c64c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;map_func&lt;/code&gt;&lt;/b&gt;: A function mapping a nested structure of tensors (having shapes and types defined by &lt;code&gt;self.output_shapes&lt;/code&gt; and &lt;code&gt;self.output_types&lt;/code&gt;) to another nested structure of tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc13dab0d3a135c4d496fae018ff8a4ae29c0e4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;map_func&lt;/code&gt;&lt;/b&gt;: A function mapping a nested structure of tensors to a &lt;code&gt;Dataset&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e566ffd7e944edaf32012284e3c8da6a105895d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;map_func&lt;/code&gt;&lt;/b&gt;: A function mapping a nested structure of tensors to another nested structure of tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2052f16d00085c2bae43ff63e927315e53ffc34" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mark_as_used&lt;/code&gt;&lt;/b&gt;: Whether to mark this name as being used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc5d6a945fc27444cb0b6bce91e895e15b2bf2a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/b&gt;: A potentially ragged boolean tensor. &lt;code&gt;mask&lt;/code&gt;'s shape must be a prefix of &lt;code&gt;data&lt;/code&gt;'s shape. &lt;code&gt;rank(mask)&lt;/code&gt; must be known statically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c11b26f82d6dee15df5a1bba531226ec2de4529" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/b&gt;: Binary tensor of shape &lt;code&gt;(batch_size, steps)&lt;/code&gt; indicating whether a given step should be masked (excluded from the average).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65032ffb466fe88ae841d8302468d0691925f0e3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/b&gt;: Binary tensor of shape &lt;code&gt;(samples, timesteps)&lt;/code&gt; indicating whether a given timestep should be masked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4393fb5d63619a92879fc81bd9931cb5242417f7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/b&gt;: Binary tensor of shape &lt;code&gt;(samples, timesteps)&lt;/code&gt; indicating whether a given timestep should be masked. This argument is passed to the wrapped layer (only if the layer supports this argument).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2cf47f8275f8c8bcae7bcb81e532b196f51e8b5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/b&gt;: Binary tensor of shape &lt;code&gt;[batch, timesteps]&lt;/code&gt; indicating whether a given timestep should be masked (optional, defaults to &lt;code&gt;None&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8845fe78e983eb9c96d6057e0e438ec5b8eff26d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/b&gt;: Binary tensor of shape &lt;code&gt;[batch, timesteps]&lt;/code&gt; indicating whether a given timestep should be masked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ef952293c136b40bbc1025beac73657ab6438d4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/b&gt;: Binary tensor of shape &lt;code&gt;[batch_size, timesteps]&lt;/code&gt; indicating whether a given timestep should be masked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e9e9d97c87b6f89323ec9eb10e8c0868b53ac9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/b&gt;: Binary tensor of shape &lt;code&gt;[samples, timesteps]&lt;/code&gt; indicating whether a given timestep should be masked (optional, defaults to &lt;code&gt;None&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bcd8a09e1ed7d8503fbdc80030d9c22094b32ee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/b&gt;: Binary tensor with shape &lt;code&gt;(samples, time, 1)&lt;/code&gt;, with a zero for every element that is masked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a698adba0cf584bdb42d5984ccc204ae80430932" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/b&gt;: Either None (indicating no masking) or a callable with the same signature as the &lt;code&gt;compute_mask&lt;/code&gt; layer method, or a tensor that will be returned as output mask regardless what the input is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8711f96b6cc651f08a34485cab06d481f8445976" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/b&gt;: K-D boolean tensor, K &amp;lt;= N and K must be known statically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="722bd966eb6defa89806c6ea393d9336769e5ccd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/b&gt;: List of the following tensors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf8fbb1b1e39203964ddb979224880be3b6b471" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/b&gt;: Tensor or list of tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51673f2887769f2c7825e6a59733db0cc3c02e6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mask_indices&lt;/code&gt;&lt;/b&gt;: Indices of elements to mask.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90bdd8b29ca6b4da009b7f44fbf094390203851a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mask_zero&lt;/code&gt;&lt;/b&gt;: Whether or not the input value 0 is a special &quot;padding&quot; value that should be masked out. This is useful when using recurrent layers which may take variable length input. If this is &lt;code&gt;True&lt;/code&gt; then all subsequent layers in the model need to support masking or an exception will be raised. If mask_zero is set to True, as a consequence, index 0 cannot be used in the vocabulary (input_dim should equal size of vocabulary + 1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b71f7857e70dd6ca09d724e226e87d50671f56fa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;master&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;String&lt;/code&gt; representation of the TensorFlow master to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c307fd40f1d1b395c3736df0e61dd32790303156" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;master&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;String&lt;/code&gt; the TensorFlow master to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03720f1bd085d9cd70414afbf222852408a4b356" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;master&lt;/code&gt;&lt;/b&gt;: Master to use to create the training session. Defaults to &lt;code&gt;&quot;&quot;&lt;/code&gt; which causes the session to be created in the local process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c73fdf69899c98600bf5107a9a98fe679618125a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;master&lt;/code&gt;&lt;/b&gt;: a string. The address of the master to use for training.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a24c5f491e24ba4516f521fded9fc0226353c4d9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;master&lt;/code&gt;&lt;/b&gt;: name of the TensorFlow master to use. See the &lt;a href=&quot;../session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; constructor for how this is interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd87d0c63fe379e46f0de3397440b83e24dbc3a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mat&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; with same &lt;code&gt;dtype&lt;/code&gt; and shape broadcastable to &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1d8a290046adb7738b1006ee5384bf66a88cf9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[..., M, N]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d95a8b81ebefebb5e44bb14f6b2ebf98d2f1dd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, or &lt;code&gt;complex128&lt;/code&gt; with shape &lt;code&gt;[..., M, M]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb19d409febf15bbf8a59799b52dc1da62d528fc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt;. Must be one of the following types: &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;half&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;. Shape is &lt;code&gt;[..., M, M]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c21cab5a621fdf9ed513dd8aaea309d7c769b6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/b&gt;: Shape &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; with &lt;code&gt;b &amp;gt;= 0&lt;/code&gt;, &lt;code&gt;M, N &amp;gt;= 0&lt;/code&gt;. Allowed dtypes: &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef0f94abce7a391747251efe9f826b125b54901" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;matrix_rank&lt;/code&gt;&lt;/b&gt;: (Batch of) &lt;code&gt;int32&lt;/code&gt; scalars representing the number of non-zero singular values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d0387e28f94fb3bd5dd7338c98ec1be202915ea" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510759f33008a72ba19d34122fe327dfde17e652" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;float&lt;/code&gt;. Defaults to &lt;code&gt;6&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d230b8ab36136fa70eeae0db011b6f2174017b20" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_activations&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382145f00d65cb9d708a3620404948b535db5c81" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_attempts&lt;/code&gt;&lt;/b&gt;: An optional &lt;code&gt;int&lt;/code&gt;. Defaults to &lt;code&gt;100&lt;/code&gt;. Number of attempts at generating a cropped region of the image of the specified constraints. After &lt;code&gt;max_attempts&lt;/code&gt; failures, return the entire image.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c080a5e540894dca7b872bc6299c15ebd52d6c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_batch_size&lt;/code&gt;&lt;/b&gt;: Batch sizes will never be bigger than this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2652f518c88bc88a10671bf54c77821fbdaf8815" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_delta&lt;/code&gt;&lt;/b&gt;: float, must be non-negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7b5bceb434e18a656277721a7cc6b09f223b268" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_delta&lt;/code&gt;&lt;/b&gt;: float. Maximum value for the random delta.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09ff327678964d7cd84b5fa9cd4edbad7e963cc9" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_depth&lt;/code&gt;&lt;/b&gt;: Maximum depth of the data structure to display.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62426ea559759fb6a75e55b0f5227c8f92998d5a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_depth&lt;/code&gt;&lt;/b&gt;: maximum depth of the tree to grow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26f54e5b6ee94a2326222b83f35623b985f470ca" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_enqueued_batches&lt;/code&gt;&lt;/b&gt;: The maximum depth of the batch queue. Defaults to 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af289c6941851ab523b73fb4852b4c7febd87794" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_features&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt;. The float value that the highest quantized value represents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7321330e6a5665a045424b7faee0cba0ce21828" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_filter&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt;. The float value that the highest quantized filter value represents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6982c8441e17ab1ea1589e90a37d276c426e54" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_input&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt;. The float value that the highest quantized input value represents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e03c0b1ed24002e0ba3522d9e6aae5a0ce58ca5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_jpeg_quality&lt;/code&gt;&lt;/b&gt;: Maximum jpeg encoding quality to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b006d95d2a803f21cc7cf6d35557d65a835d672" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_ndim&lt;/code&gt;&lt;/b&gt;: Integer, maximum rank of the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9c5f69e0ecb63a9c634408aff01e05edffc7c2c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_norm&lt;/code&gt;&lt;/b&gt;: If not &lt;code&gt;None&lt;/code&gt;, all embeddings are l2-normalized to max_norm before combining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce36f3ab262294154e7ce9bb62a0f417dbcbce67" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_norm&lt;/code&gt;&lt;/b&gt;: If not &lt;code&gt;None&lt;/code&gt;, each embedding is clipped if its l2-norm is larger than this value, before combining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dcd31e14b436013f76dc6c5f44ee883b4868cc1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_norm&lt;/code&gt;&lt;/b&gt;: If not &lt;code&gt;None&lt;/code&gt;, each embedding is clipped if its l2-norm is larger than this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ffe4af0040e2cb856a7a7167bbddf08e6cbbad" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_norm&lt;/code&gt;&lt;/b&gt;: If not &lt;code&gt;None&lt;/code&gt;, embedding values are l2-normalized to this value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6717d6e6e2387cbd8aa84454fd2aae35172705b5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_output&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bd2f44753f4bc7461c8487a358320883968fac5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_output_size&lt;/code&gt;&lt;/b&gt;: A scalar integer &lt;code&gt;Tensor&lt;/code&gt; representing the maximum number of boxes to be selected by non max suppression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4036897e21775460a05cb9bd8a9ced5b8adcea60" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_output_size_per_class&lt;/code&gt;&lt;/b&gt;: A scalar integer &lt;code&gt;Tensor&lt;/code&gt; representing the maximum number of boxes to be selected by non max suppression per class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a121a621709bdc952b72f6babeabaa7f100dfb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_outputs&lt;/code&gt;&lt;/b&gt;: Optional &lt;code&gt;int&lt;/code&gt; or rank-0 integer &lt;code&gt;Tensor&lt;/code&gt;. At most this many audio clips will be emitted at each step. When more than &lt;code&gt;max_outputs&lt;/code&gt; many clips are provided, the first &lt;code&gt;max_outputs&lt;/code&gt; many clips will be used and the rest silently discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f07d6ee829812f766ef76ce6fcdb587a9d5e8e79" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_outputs&lt;/code&gt;&lt;/b&gt;: Optional &lt;code&gt;int&lt;/code&gt; or rank-0 integer &lt;code&gt;Tensor&lt;/code&gt;. At most this many images will be emitted at each step. When more than &lt;code&gt;max_outputs&lt;/code&gt; many images are provided, the first &lt;code&gt;max_outputs&lt;/code&gt; many images will be used and the rest silently discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6f76f220097327bc3faae490bf9933fd7e7deb" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_partitions&lt;/code&gt;&lt;/b&gt;: Upper bound on the number of partitions. Defaults to 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a938eaba27a32e49955f86f5185a7e8065fb9965" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_queue&lt;/code&gt;&lt;/b&gt;: Integer. Size of the queue for pending events and summaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ec3be6f6717ca454f65b771730535d983bd921" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_queue&lt;/code&gt;&lt;/b&gt;: the largest number of summaries to keep in a queue; will flush once the queue gets bigger than this. Defaults to 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d0db60ae343ec67edd9e57adcf404b62464a741" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_queue_size&lt;/code&gt;&lt;/b&gt;: Integer. Used for generator or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; input only. Maximum size for the generator queue. If unspecified, &lt;code&gt;max_queue_size&lt;/code&gt; will default to 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a1a3d92996af895add445bf7402373f69586e08" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_queue_size&lt;/code&gt;&lt;/b&gt;: Integer. Used for generator or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; input only. Maximum size for the generator queue. If unspecified, &lt;code&gt;max_queue_size&lt;/code&gt; will default to 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874905aa7d9e7bdf37c90481eaa0d215c0d1412e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_queue_size&lt;/code&gt;&lt;/b&gt;: queue size (when full, workers could block on &lt;code&gt;put()&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="358586f7f81f61788660a8d85e75160fd0c112ed" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_range&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt;. The maximum scalar value possibly produced for the input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="995d5660df7843a152ec0298bc7d96370404f9ae" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_range&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt;. The maximum value of the quantization range. This value may be adjusted by the op depending on other parameters. The adjusted value is written to &lt;code&gt;output_max&lt;/code&gt;. If the &lt;code&gt;axis&lt;/code&gt; attribute is specified, this must be a 1-D tensor whose size matches the &lt;code&gt;axis&lt;/code&gt; dimension of the input and output tensors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c1a041c56b4d75a5e94b5e229a2a2bff7da842" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_sequence_length&lt;/code&gt;&lt;/b&gt;: An non-negative integer specifying the max sequence length. Any sequence shorter then this will be padded with 0 embeddings and any sequence longer will be truncated. This must be positive for sequence features and 0 for non-sequence features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="055ab7f4b708c6ed0553fa65171469231f551aac" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_sequence_lengths&lt;/code&gt;&lt;/b&gt;: An list of non-negative integers, either None or empty or the same length as the argument categorical_columns. Entries corresponding to non-sequence columns must be 0 and entries corresponding to sequence columns specify the max sequence length for the column. Any sequence shorter then this will be padded with 0 embeddings and any sequence longer will be truncated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc0d62268ed4c870847c7796aaf1cbefda2c536f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_shard_bytes&lt;/code&gt;&lt;/b&gt;: The maximum size any given shard is allowed to be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81162bcdcd250c6bf7f06ae0c280dbd3c199fe73" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_shards&lt;/code&gt;&lt;/b&gt;: The maximum number of shards in int created taking precedence over &lt;code&gt;max_shard_bytes&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a2f997c931bf0a7624d091f23dd32375ac89362" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_steps&lt;/code&gt;&lt;/b&gt;: Int. Positive number of total steps for which to train model. If &lt;code&gt;None&lt;/code&gt;, train forever. The training &lt;code&gt;input_fn&lt;/code&gt; is not expected to generate &lt;code&gt;OutOfRangeError&lt;/code&gt; or &lt;code&gt;StopIteration&lt;/code&gt; exceptions. See the &lt;code&gt;train_and_evaluate&lt;/code&gt; stop condition section for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="521947f8a654ad50240f72dc0c7678db3083fab6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_steps&lt;/code&gt;&lt;/b&gt;: Number of total steps for which to train model. If &lt;code&gt;None&lt;/code&gt;, train forever or train until &lt;code&gt;input_fn&lt;/code&gt; generates the &lt;code&gt;tf.errors.OutOfRange&lt;/code&gt; error or &lt;code&gt;StopIteration&lt;/code&gt; exception. If set, &lt;code&gt;steps&lt;/code&gt; must be &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;OutOfRange&lt;/code&gt; or &lt;code&gt;StopIteration&lt;/code&gt; occurs in the middle, training stops before &lt;code&gt;max_steps&lt;/code&gt; steps. Two calls to &lt;code&gt;train(steps=100)&lt;/code&gt; means 200 training iterations. On the other hand, two calls to &lt;code&gt;train(max_steps=100)&lt;/code&gt; means that the second call will not do any iteration since first call did all 100 steps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5a03380e613cc85fb2ce529e122a469a6c86e3" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_steps_without_decrease&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;int&lt;/code&gt;, maximum number of training steps with no decrease in the given metric.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7d4eddac7033381862a1b5ad4138856ff08fe49" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_steps_without_increase&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;int&lt;/code&gt;, maximum number of training steps with no increase in the given metric.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2a0dd74e56f28130ce9041a1a21339f267351b8" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_to_keep&lt;/code&gt;&lt;/b&gt;: An integer, the number of checkpoints to keep. Unless preserved by &lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt;, checkpoints will be deleted from the active set, oldest first, until only &lt;code&gt;max_to_keep&lt;/code&gt; checkpoints remain. If &lt;code&gt;None&lt;/code&gt;, no checkpoints are deleted and everything stays in the active set. Note that &lt;code&gt;max_to_keep=None&lt;/code&gt; will keep all checkpoint paths in memory and in the checkpoint state protocol buffer on disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62d9c819deb61219c17fd5e4710625fad0e15cfa" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_to_keep&lt;/code&gt;&lt;/b&gt;: Maximum number of recent checkpoints to keep. Defaults to 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ee0f0821c7dea24eff98c607ba6511ec298cb6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_tokens&lt;/code&gt;&lt;/b&gt;: The maximum size of the vocabulary for this layer. If None, there is no cap on the size of the vocabulary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ce9b5c507ea1bf8d7ee2896833f1728af16b2a4" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_total_size&lt;/code&gt;&lt;/b&gt;: A scalar representing maximum number of boxes retained over all classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e35ee3239c8d929d5ee8f9a1c066c3a634b4566" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_val&lt;/code&gt;&lt;/b&gt;: The dynamic range of the images (i.e., the difference between the maximum the and minimum allowed values).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0721d6cefe1a7335625489ae291cdd1e3233cd40" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_value&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b53741d585dc2f78e639749648473f2ec031b809" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_value&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;float&lt;/code&gt; that sets the saturation threshold (the largest value the function will return).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c2d55ac8bf35f63e06004179a635227605a383a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_value&lt;/code&gt;&lt;/b&gt;: Float &amp;gt;= 0. Maximum activation value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f614340a814dd5ed49e674d7a7313b6787769ba0" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_value&lt;/code&gt;&lt;/b&gt;: Python float, integer, or tensor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7082840414eb2bd291581e317feae2a43507e46f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_value&lt;/code&gt;&lt;/b&gt;: float. Saturation threshold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e3e11496a275810aaa98b770512a5ee4bda961" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_value&lt;/code&gt;&lt;/b&gt;: the maximum norm for the incoming weights.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf20894e1010b3b2f44010684f3d2327a4354e37" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_wait_secs&lt;/code&gt;&lt;/b&gt;: Maximum time to wait for checkpoints to become available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b51372241357e4e7341a9f94284080398a3c3cb1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_wait_secs&lt;/code&gt;&lt;/b&gt;: Maximum time to wait for the session to become available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85d8e88be47590aab38c166f7f930a7a02da8779" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;max_wait_secs&lt;/code&gt;&lt;/b&gt;: Maximum time workers should wait for the session to become available. This should be kept relatively short to help detect incorrect code, but sometimes may need to be increased if the chief takes a while to start up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a8358a0ebec1bf0cfad8e7009c7c0f0579dd358" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;maximum_iterations&lt;/code&gt;&lt;/b&gt;: Optional maximum number of iterations of the while loop to run. If provided, the &lt;code&gt;cond&lt;/code&gt; output is AND-ed with an additional condition ensuring the number of iterations executed is no greater than &lt;code&gt;maximum_iterations&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e70efe1f5ae02a9ce7648866625c81de2652ab1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;maximum_shapes&lt;/code&gt;&lt;/b&gt;: A nested structure of tf.TensorShape representing the shape to which the respective component of each input element in each replica should be padded. Any unknown dimensions (e.g. tf.compat.v1.Dimension(None) in a tf.TensorShape or -1 in a tensor-like object) will be padded to the maximum size of that dimension over all replicas. The structure of &lt;code&gt;maximum_shapes&lt;/code&gt; needs to be the same as &lt;code&gt;inputs[0]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce4d5093dcd64733bb03b91d638d4cfce12e0324" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;maxlen&lt;/code&gt;&lt;/b&gt;: scalar integer tensor, size of last dimension of returned tensor. Default is the maximum value in &lt;code&gt;lengths&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf7adda1ba4b545014e2f06e05dcc1716aefd94" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;maxlen&lt;/code&gt;&lt;/b&gt;: sequences longer than this will be filtered out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f47594b943249ff41a4775aecc3df0b7e6ff7e02" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;maxlen&lt;/code&gt;&lt;/b&gt;: truncate sequences after this length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdaf1c385f99a733bc334d148aa4e01d9ccddf15" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;maxlength&lt;/code&gt;&lt;/b&gt;: If given, skips values in &lt;code&gt;arr&lt;/code&gt; that are equal or greater than &lt;code&gt;maxlength&lt;/code&gt;, ensuring that the output has length at most &lt;code&gt;maxlength&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8becde7e64a3e83dc0549ca33267f08e3be19386" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;maxsplit&lt;/code&gt;&lt;/b&gt;: An &lt;code&gt;int&lt;/code&gt;. If &lt;code&gt;maxsplit &amp;gt; 0&lt;/code&gt;, limit of the split of the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc048c154293788904a853f2c9f74b10962cc362" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;maxval&lt;/code&gt;&lt;/b&gt;: A 0-D Tensor or Python value of type &lt;code&gt;dtype&lt;/code&gt;. The upper bound on the range of random values to generate. Defaults to 1 if &lt;code&gt;dtype&lt;/code&gt; is floating point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9352f7ce7a11a87c0f3a0e2803cab95786eab21f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;maxval&lt;/code&gt;&lt;/b&gt;: A Tensor or Python value of type &lt;code&gt;dtype&lt;/code&gt;, broadcastable with &lt;code&gt;minval&lt;/code&gt;. The upper bound on the range of random values to generate (exclusive). Defaults to 1 if &lt;code&gt;dtype&lt;/code&gt; is floating point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0863588545ad3226c954920cf57dc43d2c634369" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;maxval&lt;/code&gt;&lt;/b&gt;: A float, upper boundary of the uniform distribution to draw samples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e385f77ea3461616aa82fed56b6711f94caefc" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;maxval&lt;/code&gt;&lt;/b&gt;: A python scalar or a scalar tensor. Upper bound of the range of random values to generate. Defaults to 0.05.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79cd43a70411fb3a24a3b8c0eeefad3d4bd30337" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;maxval&lt;/code&gt;&lt;/b&gt;: A python scalar or a scalar tensor. Upper bound of the range of random values to generate. Defaults to 1 for float types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8180bdb78f51badd1ff977419ceb9758beb4f5ee" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;maybe_tf_decorator&lt;/code&gt;&lt;/b&gt;: Any callable object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d2e4a735255486b57e617f4a6872dcd8a70bb7f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mbs&lt;/code&gt;&lt;/b&gt;: (optional) The number of megabytes moved by this op, used to calculate the ops throughput.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead056eedfb95ee283abc22ddc7624c73829b976" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;md5_hash&lt;/code&gt;&lt;/b&gt;: Deprecated in favor of 'file_hash'. md5 hash of the file for verification</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb2fbb7873f5e2f23400b243385010fa5cac71e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/b&gt;: A 0-D Tensor or Python value of type &lt;code&gt;dtype&lt;/code&gt;. The mean of the normal distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34459ac4b86f4c2d73ad32aa28ea1759487be9b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/b&gt;: A 0-D Tensor or Python value of type &lt;code&gt;dtype&lt;/code&gt;. The mean of the truncated normal distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206f32911a36f3e2051cb6fa0de1084536cab63c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/b&gt;: A 1D mean Tensor with size matching the last dimension of t. This is the first output from tf.nn.moments, or a saved moving average thereof.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb9dd38e64aabe4c77b2183ba37f37a7bacf3e4b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of 1 dimension for population mean used for inference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcfe3b7f2c8f9e6f76631e48867546a945b92b97" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; representing the current mean, the value of &lt;code&gt;total&lt;/code&gt; divided by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcdb6fa881ab6ebef6e8717802ea21558b085c95" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/b&gt;: A Tensor or Python value of type &lt;code&gt;dtype&lt;/code&gt;, broadcastable with &lt;code&gt;stddev&lt;/code&gt;. The mean of the normal distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2f449f387240a30f4fff0a064084d61d7c6e58b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/b&gt;: A float &lt;code&gt;Tensor&lt;/code&gt; representing the current mean, the value of &lt;code&gt;total&lt;/code&gt; divided by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81f3ed314080af00c09e4b8c8f3c6dbf5fe225b7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/b&gt;: A float, mean of the normal distribution to draw samples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c52f4cad8c6098a1104613d6717d0e5d2db818" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/b&gt;: A mean &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9365a7b2f0b5e880e2193b0bb4ed055b29b0e290" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/b&gt;: Alias for m.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c5c963e044ef39a27e6520818bf41c9714a36d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/b&gt;: Float, mean of the normal distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be5f6571129ce7b31d6d6e2c707d45c5482f6c44" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/b&gt;: Mean of batch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33db8a7fe93c72e76eaaa61d79fb1264a8bc6c3c" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/b&gt;: Mean of the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f15819f86e9e3b4b9e2387fbe432080f92291158" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/b&gt;: a python scalar or a scalar tensor. Mean of the random values to generate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd97d6de84f3deb5b0a6e8359006fc09fdc6828" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/b&gt;: a python scalar or a scalar tensor. Mean of the random values to generate. Defaults to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c7c70719d05fcc9e4a0d455b0b250edc0f014b" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean_absolute_error&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; representing the current mean, the value of &lt;code&gt;total&lt;/code&gt; divided by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd44d0190fa02368acf46497e4efbcaebf3da82e" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean_accuracy&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; representing the mean per class accuracy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c1aca137c7994dfbcc41227e120bfb047df138d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean_average_precision&lt;/code&gt;&lt;/b&gt;: Scalar &lt;code&gt;float64&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; with the mean average precision values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf93eab244ada05c59dadb8163000da63d339ff" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean_distance&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; representing the current mean, the value of &lt;code&gt;total&lt;/code&gt; divided by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccaf2452e3f07513a8b3cd10037dc3c7edcca536" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean_iou&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; representing the mean intersection-over-union.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b32ca8cff86dd309827c2ffcdaf9dffe3e34ab7" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean_relative_error&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; representing the current mean, the value of &lt;code&gt;total&lt;/code&gt; divided by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2d6ebe9bd80f9ffc1c78fbde41bfd6b170e82f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean_squared_error&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; representing the current mean, the value of &lt;code&gt;total&lt;/code&gt; divided by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e4ffd4be737c4c5009de293c2fd4544ab86306f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mean_ss&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;Tensor&lt;/code&gt; containing the mean sufficient statistics: the (possibly shifted) sum of the elements to average over.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4202265f524d8077b1fbdd1000dd44b8f584d06f" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;mem_level&lt;/code&gt;&lt;/b&gt;: 1 to 9, or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c65cdf4e4e63300839aeff3375a949e76f1bc1d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;memory_limit&lt;/code&gt;&lt;/b&gt;: (optional) Maximum memory (in MB) to allocate on the virtual device. Currently only supported for GPUs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbd7c01d5f5483d9ca5178707a9e6fe35006a943" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;memory_limit&lt;/code&gt;&lt;/b&gt;: The maximum amount of memory available on the device. Note: depending on the device, it is possible the usable memory could be substantially less.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ba4699c6dee835e171b2437ca32ea4b679304d6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;merge_devices&lt;/code&gt;&lt;/b&gt;: &lt;code&gt;Boolean&lt;/code&gt;. If &lt;code&gt;True&lt;/code&gt;, merges or only sets a device if the device constraint is completely unset. merges device specification rather than overriding them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c306473bd26871ceb7167d013788669aacaf5a6" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;merge_fn&lt;/code&gt;&lt;/b&gt;: Function that joins arguments from threads that are given as PerReplica. It accepts &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; object as the first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6866b944991038e82c546e91632fe58440db9768" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;merge_mode&lt;/code&gt;&lt;/b&gt;: Mode by which outputs of the forward and backward RNNs will be combined. One of {'sum', 'mul', 'concat', 'ave', None}. If None, the outputs will not be combined, they will be returned as a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492a491c93604cc45683de8a5775b27e279f5396" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;merge_repeated&lt;/code&gt;&lt;/b&gt;: Boolean. Default: True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb31e3fb09c65d5657173db13c425354a015cf1" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;message&lt;/code&gt;&lt;/b&gt;: A &lt;code&gt;string&lt;/code&gt;. Prefix of the error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2965726b584218f5be43e348b3b2dece24f199a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;message&lt;/code&gt;&lt;/b&gt;: A string to prefix to the default message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34bfe238ff6f71e45f24e9b24b99108a71cff941" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;code&gt;message&lt;/code&gt;&lt;/b&gt;: A string, prefix of the error message.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
