<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="redux">
    <body>
      <group id="redux">
        <trans-unit id="30d4829117610e90feb15aaa2afa4a03b8acf085" translate="yes" xml:space="preserve">
          <source>#1024: Proposal: Declarative reducers</source>
          <target state="translated"># 1024 : 제안 : 선언적 감속기</target>
        </trans-unit>
        <trans-unit id="4b615433f4ff0d26c5fa5b193e0e7d0cc3e80d05" translate="yes" xml:space="preserve">
          <source>#1051: Shortcomings of the current applyMiddleware and composing createStore</source>
          <target state="translated"># 1051 : 현재 applyMiddleware의 단점 및 작성 createStore</target>
        </trans-unit>
        <trans-unit id="03e1f9116a8ad70c48d717384dff4c3d9ed0b8d4" translate="yes" xml:space="preserve">
          <source>#1057: subscribe listener can get action param?</source>
          <target state="translated"># 1057 : 구독 청취자가 액션 매개 변수를 얻을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="4bc2d46618e57ca5f5cd58ca24a444b2e3962cbd" translate="yes" xml:space="preserve">
          <source>#1098: Using Redux in reusable React component</source>
          <target state="translated"># 1098 : 재사용 가능한 React 컴포넌트에서 Redux 사용</target>
        </trans-unit>
        <trans-unit id="1172766c55389d23293c28bd580351638a8b05bb" translate="yes" xml:space="preserve">
          <source>#1139: An alternative side effect model based on generators and sagas</source>
          <target state="translated"># 1139 : 발전기와 사 가스를 기반으로 한 대체 부작용 모델</target>
        </trans-unit>
        <trans-unit id="277db1c86685b6e2ab3da794c5499c7fdcf8c74e" translate="yes" xml:space="preserve">
          <source>#1165: Where to put business logic / validation?</source>
          <target state="translated"># 1165 : 비즈니스 로직 / 검증 장소는 어디입니까?</target>
        </trans-unit>
        <trans-unit id="05a3cbd838b24d5f189d009b179a62c97ae2d04c" translate="yes" xml:space="preserve">
          <source>#1167: Reducer without switch</source>
          <target state="translated"># 1167 : 스위치없는 감속기</target>
        </trans-unit>
        <trans-unit id="f13afaff66dc7b23e3b11883862fef5f53054aed" translate="yes" xml:space="preserve">
          <source>#1171: Recommendations for best practices regarding action-creators, reducers, and selectors</source>
          <target state="translated"># 1171 : 액션 생성기, 감속기 및 선택기에 관한 모범 사례 권장 사항</target>
        </trans-unit>
        <trans-unit id="66dd37b1d3975be52ce9c12bd63d02993da859c1" translate="yes" xml:space="preserve">
          <source>#1176: Redux+React with only stateless components</source>
          <target state="translated"># 1176 : 상태 비 저장 구성 요소 만있는 Redux + React</target>
        </trans-unit>
        <trans-unit id="2ed8de88174cb4015a9a40feb1eb36d44bdfc115" translate="yes" xml:space="preserve">
          <source>#1185: Question: Should I use immutable data structures?</source>
          <target state="translated"># 1185 : 질문 : 불변 데이터 구조를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="36502c2af1991f87b5ec953b1ce29619a393fcb7" translate="yes" xml:space="preserve">
          <source>#1248: Is it ok and possible to store a react component in a reducer?</source>
          <target state="translated"># 1248 : 리액터에 반응 성분을 저장할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="882566f27d0e15811a3d2222e5b3e7be9f37c3e6" translate="yes" xml:space="preserve">
          <source>#1255: Normalizr usage with nested objects in React/Redux</source>
          <target state="translated"># 1255 : React / Redux에서 중첩 된 객체의 Normalizr 사용법</target>
        </trans-unit>
        <trans-unit id="df2442136b9e5a150b1df77be37dfaf76f081455" translate="yes" xml:space="preserve">
          <source>#125: Strategy for avoiding cascading renders</source>
          <target state="translated"># 125 : 계단식 렌더링 방지 전략</target>
        </trans-unit>
        <trans-unit id="d37bec3c108aab23faa29d1d3ccc744b38e02030" translate="yes" xml:space="preserve">
          <source>#1262: Immutable data + bad performance</source>
          <target state="translated"># 1262 : 불변 데이터 + 성능 저하</target>
        </trans-unit>
        <trans-unit id="9be52b6008b5e36ca13d546156068f2e0681de57" translate="yes" xml:space="preserve">
          <source>#1269: Add tree view example</source>
          <target state="translated"># 1269 : 트리 뷰 추가 예제</target>
        </trans-unit>
        <trans-unit id="9fbe916b0a42eeb4f1b8b1ce74cfca5a8c904167" translate="yes" xml:space="preserve">
          <source>#1279: Have any suggestions for where to put a Map Component in Flux?</source>
          <target state="translated"># 1279 : 플럭스에서 맵 컴포넌트를 어디에 두어야하는지 제안이 있습니까?</target>
        </trans-unit>
        <trans-unit id="bbdbf83cd3a993497d417bb7aaf52383244a21b5" translate="yes" xml:space="preserve">
          <source>#1287: How to choose between Redux's store and React's state?</source>
          <target state="translated"># 1287 : Redux의 상점과 React의 상태 중에서 선택하는 방법?</target>
        </trans-unit>
        <trans-unit id="e852f115018d5807316e922246599c080b0e9503" translate="yes" xml:space="preserve">
          <source>#1300: Redux is great but major feature is missing</source>
          <target state="translated"># 1300 : Redux는 훌륭하지만 주요 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="679eeec344129ad16e78231797b18b81de9a1726" translate="yes" xml:space="preserve">
          <source>#1303: Redux Performance with Large Store and frequent updates</source>
          <target state="translated"># 1303 : 대규모 저장소 및 빈번한 업데이트를 통한 Redux 성능</target>
        </trans-unit>
        <trans-unit id="e40ad0efcf8cdfb74359b9dcaaf30ad0e5d65061" translate="yes" xml:space="preserve">
          <source>#1346: Is it bad practice to just have a 'stores' directory?</source>
          <target state="translated"># 1346 : 단지 'stores'디렉토리를 갖는 것이 나쁜 습관입니까?</target>
        </trans-unit>
        <trans-unit id="076aa3253e92bf9223eb24af002f0bbe44e75f44" translate="yes" xml:space="preserve">
          <source>#1385: What are the disadvantages of storing all your state in a single immutable atom?</source>
          <target state="translated"># 1385 : 모든 상태를 단일 불변 원자에 저장하면 어떤 단점이 있습니까?</target>
        </trans-unit>
        <trans-unit id="fd76865437e3ee0e6eaa04e445cee157feda0101" translate="yes" xml:space="preserve">
          <source>#1390: Component Loading</source>
          <target state="translated"># 1390 : 컴포넌트 로딩</target>
        </trans-unit>
        <trans-unit id="926fcdba9fb2889fc5ab58719f3a2fe43b8cefa6" translate="yes" xml:space="preserve">
          <source>#1400: Is passing top-level state object to branch reducer an anti-pattern?</source>
          <target state="translated"># 1400 : 최상위 상태 객체를 분기 감속기로 전달하는 것이 안티 패턴입니까?</target>
        </trans-unit>
        <trans-unit id="aec86494988d387006d280e6de7e36c662cc84df" translate="yes" xml:space="preserve">
          <source>#1407: Just sharing a great base class</source>
          <target state="translated"># 1407 : 훌륭한 기본 수업 공유</target>
        </trans-unit>
        <trans-unit id="e34f2137559dfc202961ddb79fca5d33772da57e" translate="yes" xml:space="preserve">
          <source>#159: Investigate using Redux for pseudo-local component state</source>
          <target state="translated"># 159 : 의사 로컬 구성 요소 상태에 Redux를 사용하여 조사</target>
        </trans-unit>
        <trans-unit id="533d7a7280b4ebb1710db8562d8d14ac793fb437" translate="yes" xml:space="preserve">
          <source>#1751: Performance issues with large collections</source>
          <target state="translated"># 1751 : 대규모 컬렉션의 성능 문제</target>
        </trans-unit>
        <trans-unit id="6f36989dd4b17b3997aaf72ac822de75218cc1ba" translate="yes" xml:space="preserve">
          <source>#1793: React Elements in Redux State</source>
          <target state="translated"># 1793 : Redux 상태의 요소 반응</target>
        </trans-unit>
        <trans-unit id="e0ded754edd99b8eb3c5dbc5f56be7e245c5cfff" translate="yes" xml:space="preserve">
          <source>#1813: Use a loop to support dispatching arrays</source>
          <target state="translated"># 1813 : 배열 디스패치를 ​​지원하기 위해 루프를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="6cbd9dbf9bd45f23169fcf1b9cac28e3ed46577e" translate="yes" xml:space="preserve">
          <source>#1816: Component connected to state with &lt;code&gt;mapStateToProps&lt;/code&gt;</source>
          <target state="translated"># 1816 : &lt;code&gt;mapStateToProps&lt;/code&gt; 로 상태에 연결된 구성 요소</target>
        </trans-unit>
        <trans-unit id="1f4db3c5c28aaed5936c26bc809377a941220207" translate="yes" xml:space="preserve">
          <source>#1824: Normalising state and garbage collection</source>
          <target state="translated"># 1824 : 정규화 상태 및 가비지 수집</target>
        </trans-unit>
        <trans-unit id="a295c20bf7be400de7f0b760d0ab71f013297048" translate="yes" xml:space="preserve">
          <source>#1948: Is getMappedItems an anti-pattern in mapStateToProps?</source>
          <target state="translated"># 1948 : getStateappedItems가 mapStateToProps의 안티 패턴입니까?</target>
        </trans-unit>
        <trans-unit id="bd83ae1e93d8c72cc8d0d72bed074df91fdb5711" translate="yes" xml:space="preserve">
          <source>#291: Trying to put API calls in the right place</source>
          <target state="translated"># 291 : 올바른 위치에 API 호출을 시도</target>
        </trans-unit>
        <trans-unit id="13e0c71a2076886c367dfe6a54f48c62f34d629f" translate="yes" xml:space="preserve">
          <source>#300: Potential connect() optimization</source>
          <target state="translated"># 300 : 잠재적 인 connect () 최적화</target>
        </trans-unit>
        <trans-unit id="5cca150f0353618d865ab736549a024eaf25e9b6" translate="yes" xml:space="preserve">
          <source>#303: subscribe API with state as an argument</source>
          <target state="translated"># 303 : 상태를 인수로하여 API 구독</target>
        </trans-unit>
        <trans-unit id="347d6847f32071d342aaec6151006d6975576724" translate="yes" xml:space="preserve">
          <source>#310: Who uses Redux?</source>
          <target state="translated"># 310 : 누가 Redux를 사용합니까?</target>
        </trans-unit>
        <trans-unit id="7a857746379c5bd1fd15069f90a6730fd9d8c03f" translate="yes" xml:space="preserve">
          <source>#316: How to create nested reducers?</source>
          <target state="translated"># 316 : 중첩 감속기를 만드는 방법?</target>
        </trans-unit>
        <trans-unit id="241aa7e523baa3daf169c16235be0831a07cca24" translate="yes" xml:space="preserve">
          <source>#384: Recommend that Action constants be named in the past tense</source>
          <target state="translated"># 384 : 과거 시제에서 동작 상수의 이름을 지정할 것을 권장합니다</target>
        </trans-unit>
        <trans-unit id="1b1eee56ce67b7a61408324df972292a71042952" translate="yes" xml:space="preserve">
          <source>#419: Recommended usage of connect</source>
          <target state="translated"># 419 : 연결 권장 사용법</target>
        </trans-unit>
        <trans-unit id="2935aef53d71adace83e50c33214eaca426a95e9" translate="yes" xml:space="preserve">
          <source>#454: Handling big states in reducer</source>
          <target state="translated"># 454 : 리듀서에서 큰 상태 처리</target>
        </trans-unit>
        <trans-unit id="b0699a6d49cd70e922b35198761a2a07c83e5a3d" translate="yes" xml:space="preserve">
          <source>#455: Modeling side effects</source>
          <target state="translated"># 455 : 모델링 부작용</target>
        </trans-unit>
        <trans-unit id="772964529153c4d154180791f6cbd68a862db7bc" translate="yes" xml:space="preserve">
          <source>#533: Simpler introduction to async action creators</source>
          <target state="translated"># 533 : 비동기 액션 제작자에 대한 간단한 소개</target>
        </trans-unit>
        <trans-unit id="ebec8f05fa20d12e79e8cd586923a111d387212c" translate="yes" xml:space="preserve">
          <source>#542: Idea: batching actions</source>
          <target state="translated"># 542 : 아이디어 : 배치 작업</target>
        </trans-unit>
        <trans-unit id="83c9c3ac3d68aab87e326de2f2c865ef2276a101" translate="yes" xml:space="preserve">
          <source>#569: Proposal: API for explicit side effects</source>
          <target state="translated"># 569 : 제안 : 명시 적 부작용을위한 API</target>
        </trans-unit>
        <trans-unit id="d9d6fe14a99ccdaf8dc393654376b48c92963a25" translate="yes" xml:space="preserve">
          <source>#580: Is it possible to get action and state in store.subscribe?</source>
          <target state="translated"># 580 : store.subscribe에서 조치와 상태를 얻을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="cd9c0a060e7d71bfba68ba623da0d23c2d2537f5" translate="yes" xml:space="preserve">
          <source>#597: Valid to dispatch multiple actions from an event handler?</source>
          <target state="translated"># 597 : 이벤트 핸들러에서 여러 작업을 전달할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="995165a4900367cea544bc6a5f22ed8ee0144461" translate="yes" xml:space="preserve">
          <source>#601: A concern on combineReducers, when an action is related to multiple reducers</source>
          <target state="translated"># 601 : 액션이 여러 감속기와 관련 될 때 combineReducers에 대한 우려</target>
        </trans-unit>
        <trans-unit id="c91700ab890c5f08a2647bb350f68184b32a47f9" translate="yes" xml:space="preserve">
          <source>#628: Solution for simple action creation with less boilerplate</source>
          <target state="translated"># 628 : 상용구가 적은 간단한 액션 제작 솔루션</target>
        </trans-unit>
        <trans-unit id="be6cef416c1c4ce452dcbd4fff0470556c4b9881" translate="yes" xml:space="preserve">
          <source>#756: container vs component?</source>
          <target state="translated"># 756 : 컨테이너와 컴포넌트?</target>
        </trans-unit>
        <trans-unit id="21340ba20a259634064d57cf626624fa2d15391a" translate="yes" xml:space="preserve">
          <source>#758: Why can't state be mutated?</source>
          <target state="translated"># 758 : 왜 상태를 변경할 수 없습니까?</target>
        </trans-unit>
        <trans-unit id="69c184b8b56c254a2d2a7ccf4adc774a774fe33d" translate="yes" xml:space="preserve">
          <source>#815: Working with Data Structures</source>
          <target state="translated"># 815 : 데이터 구조 작업</target>
        </trans-unit>
        <trans-unit id="44ded1489a6f088808483a04ff55a1208ffe9541" translate="yes" xml:space="preserve">
          <source>#839: Emphasize defining selectors alongside reducers</source>
          <target state="translated"># 839 : 감속기와 함께 선택기 정의 강조</target>
        </trans-unit>
        <trans-unit id="20452e871be0ef029dee99c519ace41f4725804e" translate="yes" xml:space="preserve">
          <source>#883: take away the huge switch block</source>
          <target state="translated"># 883 : 거대한 스위치 블록을 빼앗아</target>
        </trans-unit>
        <trans-unit id="2f094ae5359226b707fd44e5f2a280f7467e4726" translate="yes" xml:space="preserve">
          <source>#911: Batching actions</source>
          <target state="translated"># 911 : 배치 작업</target>
        </trans-unit>
        <trans-unit id="a26f477aae1edf0347eb6f7ffa53f8db84ef966f" translate="yes" xml:space="preserve">
          <source>#912: Proposal: action filter utility</source>
          <target state="translated"># 912 : 제안 : 액션 필터 유틸리티</target>
        </trans-unit>
        <trans-unit id="37e67540fe79d19b36724130f44d7607e8859b33" translate="yes" xml:space="preserve">
          <source>#922: Proposal: add subscribe to middleware API</source>
          <target state="translated"># 922 : 제안 : 미들웨어 API 구독 추가</target>
        </trans-unit>
        <trans-unit id="5501fbbcf1d607aa36fc7ed852657153c5e12ddf" translate="yes" xml:space="preserve">
          <source>#943: Reducer querying</source>
          <target state="translated"># 943 : 리듀서 쿼리</target>
        </trans-unit>
        <trans-unit id="680e2a0ba15353fa00a6904ce08286dab08d5d1e" translate="yes" xml:space="preserve">
          <source>#946: Best way to update related state fields with split reducers?</source>
          <target state="translated"># 946 : 분할 감속기로 관련 상태 필드를 업데이트하는 가장 좋은 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="578d4af46b83796b576f50939eeddbe2b86f09a5" translate="yes" xml:space="preserve">
          <source>#959: Multiple actions one dispatch?</source>
          <target state="translated"># 959 : 여러 작업이 한 번 발송됩니까?</target>
        </trans-unit>
        <trans-unit id="7d53170003985aba57c3cbb54042a1048dbe5904" translate="yes" xml:space="preserve">
          <source>#994: How to cut the boilerplate when updating nested entities?</source>
          <target state="translated"># 994 : 중첩 된 엔티티를 업데이트 할 때 상용구를 자르는 방법?</target>
        </trans-unit>
        <trans-unit id="bf535818991eda0fe486afd20e7daa2d14518b95" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2015&amp;ndash;2017 Dan Abramov</source>
          <target state="translated">&amp;copy; 2015&amp;ndash;2017 댄 아브라모프</target>
        </trans-unit>
        <trans-unit id="ed6b7f639f884be7fcd9fb980e496b6c33d5d3e1" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Come for the name hype. Stay for the rock solid fundamentals. (Thanks, and great job @dan_abramov and @eggheadio!)&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;이름 과대 광고를 위해 오십시오. 견고한 기초를 유지하십시오. (감사합니다. @dan_abramov와 @eggheadio!)&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="df384f33284e21430b07f18596d262ec19ba170f" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Ducks&amp;rdquo;: similar to domain style, but explicitly tying together actions and reducers, often by defining them in the same file</source>
          <target state="translated">&quot;오리&quot;: 도메인 스타일과 비슷하지만 종종 같은 파일에 정의하여 액션과 리듀서를 명시 적으로 연결</target>
        </trans-unit>
        <trans-unit id="5150dc5211c6d06fcaf7e065f841bb023696c70e" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Great course on egghead.io by @dan_abramov - instead of just showing you how to use #redux, it also shows how and why redux was built!&amp;rdquo;</source>
          <target state="translated">&quot;@dan_abramov의 egghead.io의 훌륭한 코스 &amp;ndash; #redux 사용법을 보여주는 대신 redux가 어떻게 그리고 왜 만들어 졌는지 보여줍니다!&quot;</target>
        </trans-unit>
        <trans-unit id="0e3d7e088d7386301b6520d1c80203336070f21a" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;I asked for comments on Redux in FB's internal JS discussion group, and it was universally praised. Really awesome work.&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;FB의 내부 JS 토론 그룹에서 Redux에 대한 의견을 요청했으며 보편적으로 칭찬을 받았습니다. 정말 대단한 일입니다.&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="805734d014075effe4c9f9a252eb9def2a6db8e5" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;It's cool that you are inventing a better Flux by not doing Flux at all.&amp;rdquo;</source>
          <target state="translated">&quot;Flux를 전혀 사용하지 않음으로써 더 나은 Flux를 발명하는 것이 좋습니다.&quot;</target>
        </trans-unit>
        <trans-unit id="d3596109d016ac6d1e24cf6ef8b5eb8a444a3f3a" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Love what you're doing with Redux&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;Rux로하는 일을 사랑하십시오&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="938ed1352f0e24ad85ff59d880eeac5332693aad" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Plowing through @dan_abramov 'Getting Started with Redux' - its amazing how much simpler concepts get with video.&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;@dan_abramov 'Redux 시작하기'를 통해 쟁기질하는 것-비디오를 통해 더 간단한 개념을 얻는 놀라운 방법입니다.&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="aa28d7323e70567c92735260eea7a08b3567882e" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;This series of videos on Redux by @dan_abramov is repeatedly blowing my mind - gunna do some serious refactoring&amp;rdquo;</source>
          <target state="translated">&quot;@dan_abramov의 Redux 비디오 시리즈는 반복적으로 제 마음을 불고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bbdab09b1bad7d1411229e6706b9074b9acbc26" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;This video series on Redux by @dan_abramov on @eggheadio is spectacular!&amp;rdquo;</source>
          <target state="translated">&quot;@eggheadio의 @dan_abramov의 Redux 비디오 시리즈는 훌륭합니다!&quot;</target>
        </trans-unit>
        <trans-unit id="28f716d4a6d6d1dd6c2816b0a3468596f9af7981" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;store&quot;&gt;&lt;em&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/em&gt;&lt;/a&gt;): An object that holds the complete state of your app. The only way to change its state is by &lt;a href=&quot;store#dispatch&quot;&gt;dispatching actions&lt;/a&gt;. You may also &lt;a href=&quot;store#subscribe&quot;&gt;subscribe&lt;/a&gt; to the changes to its state to update the UI.</source>
          <target state="translated">( &lt;a href=&quot;store&quot;&gt;&lt;em&gt; &lt;code&gt;Store&lt;/code&gt; &lt;/em&gt;&lt;/a&gt; ) : 앱의 완전한 상태를 유지하는 객체입니다. 상태를 변경하는 유일한 방법은 &lt;a href=&quot;store#dispatch&quot;&gt;작업&lt;/a&gt; 을 전달하는 것 입니다. UI를 업데이트하기 위해 상태 변경 사항에 &lt;a href=&quot;store#subscribe&quot;&gt;가입&lt;/a&gt; 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecee604ad68b289f8d3c800340d2c2c4d94ec4db" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt; or &lt;em&gt;Object&lt;/em&gt;): An object mimicking the original object, but with each function immediately dispatching the action returned by the corresponding action creator. If you passed a function as &lt;code&gt;actionCreators&lt;/code&gt;, the return value will also be a single function.</source>
          <target state="translated">( &lt;em&gt;함수&lt;/em&gt; 또는 &lt;em&gt;객체&lt;/em&gt; ) : 원래 객체를 모방 한 객체이지만 각 함수는 해당 액션 작성자가 반환 한 액션을 즉시 전달합니다. 함수를 &lt;code&gt;actionCreators&lt;/code&gt; 로 전달 하면 반환 값도 단일 함수가됩니다.</target>
        </trans-unit>
        <trans-unit id="0fb3da3936f993327ba39a8dd43015351fe83823" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt;) A store enhancer that applies the given middleware. The store enhancer signature is &lt;code&gt;createStore =&amp;gt; createStore'&lt;/code&gt; but the easiest way to apply it is to pass it to &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt; as the last &lt;code&gt;enhancer&lt;/code&gt; argument.</source>
          <target state="translated">( &lt;em&gt;기능&lt;/em&gt; ) 주어진 미들웨어를 적용하는 상점 향상 기. 상점 인핸서 서명은 &lt;code&gt;createStore =&amp;gt; createStore'&lt;/code&gt; 이지만이를 적용하는 가장 쉬운 방법 은 마지막 &lt;code&gt;enhancer&lt;/code&gt; 인수 로 &lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt; 에 전달하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="7f6b6bfc4538002cddbd1fd5e4e370dff6c9c1be" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt;): A function that unsubscribes the change listener.</source>
          <target state="translated">( &lt;em&gt;함수&lt;/em&gt; ) : 변경 리스너를 구독 취소하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="e6c10b5a4481c57b2d2f9edfc1c63be79f798472" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt;): A reducer that invokes every reducer inside the &lt;code&gt;reducers&lt;/code&gt; object, and constructs a state object with the same shape.</source>
          <target state="translated">( &lt;em&gt;기능&lt;/em&gt; ) : &lt;code&gt;reducers&lt;/code&gt; 객체 내부의 모든 감속기를 호출하고 모양이 동일한 상태 객체를 구성하는 감속기</target>
        </trans-unit>
        <trans-unit id="389d55a260500f16717ac0d3a94350b27cba66e0" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;Function&lt;/em&gt;): The final function obtained by composing the given functions from right to left.</source>
          <target state="translated">( &lt;em&gt;기능&lt;/em&gt; ) : 주어진 기능을 오른쪽에서 왼쪽으로 구성하여 얻은 최종 기능입니다.</target>
        </trans-unit>
        <trans-unit id="b6cbf2c01213c134b40ec8c3596771ac0fe718c7" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;arguments&lt;/em&gt;): The functions to compose. Each function is expected to accept a single parameter. Its return value will be provided as an argument to the function standing to the left, and so on. The exception is the right-most argument which can accept multiple parameters, as it will provide the signature for the resulting composed function.</source>
          <target state="translated">( &lt;em&gt;arguments&lt;/em&gt; ) : 작성할 함수입니다. 각 함수는 단일 매개 변수를 허용해야합니다. 반환 값은 왼쪽에 서있는 함수에 대한 인수로 제공됩니다. 결과적으로 작성된 기능에 대한 서명을 제공하므로 여러 매개 변수를 허용 할 수있는 가장 오른쪽 인수는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="5016311decd476dac1c440e0e52c02e0e3d85575" translate="yes" xml:space="preserve">
          <source>(Don't worry, &lt;a href=&quot;https://twitter.com/jingc/status/616608251463909376&quot;&gt;Flux creators&lt;/a&gt;&lt;a href=&quot;https://twitter.com/fisherwebdev/status/616286955693682688&quot;&gt;approve of it&lt;/a&gt;, if that's all you wanted to know.)</source>
          <target state="translated">( &lt;a href=&quot;https://twitter.com/jingc/status/616608251463909376&quot;&gt;Flux 제작자들이&lt;/a&gt; 당신이 알고 싶은 모든 것이면 &lt;a href=&quot;https://twitter.com/fisherwebdev/status/616286955693682688&quot;&gt;승인합니다&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="d324236cbf7b2c5b411e6901ceaf0426c57a961e" translate="yes" xml:space="preserve">
          <source>(If you're looking for a WordPress framework, check out &lt;a href=&quot;https://reduxframework.com/&quot;&gt;Redux Framework&lt;/a&gt;.)</source>
          <target state="translated">(WordPress 프레임 워크를 찾고 있다면 &lt;a href=&quot;https://reduxframework.com/&quot;&gt;Redux Framework를&lt;/a&gt; 확인하십시오 .)</target>
        </trans-unit>
        <trans-unit id="edae0b5981e0002b30818364c8a1389176fcb0ee" translate="yes" xml:space="preserve">
          <source>(Object&lt;sup&gt;&amp;dagger;&lt;/sup&gt;): The dispatched action (see notes).</source>
          <target state="translated">(Object &lt;sup&gt;&amp;dagger;&lt;/sup&gt; ) : 디스패치 된 작업 (참고 사항 참조).</target>
        </trans-unit>
        <trans-unit id="b0be13084aba8adc3d7b205aaf4e927e25fa0408" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#middleware&quot;&gt;Middleware&lt;/a&gt; wraps the base dispatch function. It allows the dispatch function to handle &lt;a href=&quot;#async-action&quot;&gt;async actions&lt;/a&gt; in addition to actions. Middleware may transform, delay, ignore, or otherwise interpret actions or async actions before passing them to the next middleware. See below for more information.</source>
          <target state="translated">&lt;a href=&quot;#middleware&quot;&gt;미들웨어&lt;/a&gt; 는 기본 디스패치 기능을 랩핑합니다. 디스패치 기능이 &lt;a href=&quot;#async-action&quot;&gt;조치&lt;/a&gt; 외에 비동기 조치 를 처리 할 수 있습니다. 미들웨어는 다음 미들웨어로 전달하기 전에 조치 또는 비동기 조치를 변환, 지연, 무시 또는 해석 할 수 있습니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="107b3ce80a3c02523b93e5b4d695a60fd20c2f63" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../glossary#middleware&quot;&gt;Middleware&lt;/a&gt; lets you inject custom logic that interprets every action object before it is dispatched. Async actions are the most common use case for middleware.</source>
          <target state="translated">&lt;a href=&quot;../glossary#middleware&quot;&gt;미들웨어를&lt;/a&gt; 사용하면 모든 조치 오브젝트가 전달되기 전에 해석하는 사용자 정의 논리를 삽입 할 수 있습니다. 비동기 작업은 미들웨어의 가장 일반적인 사용 사례입니다.</target>
        </trans-unit>
        <trans-unit id="fd07de91063da45b75bbcacd8cd309f14a69d740" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;../glossary#reducer&quot;&gt;Reducers&lt;/a&gt; capture &amp;ldquo;the essence&amp;rdquo; of Flux Stores, so it's possible to gradually migrate an existing Flux project towards Redux, whether you are using &lt;a href=&quot;http://github.com/acdlite/flummox&quot;&gt;Flummox&lt;/a&gt;, &lt;a href=&quot;http://github.com/goatslacker/alt&quot;&gt;Alt&lt;/a&gt;, &lt;a href=&quot;https://github.com/facebook/flux&quot;&gt;traditional Flux&lt;/a&gt;, or any other Flux library.</source>
          <target state="translated">&lt;a href=&quot;../glossary#reducer&quot;&gt;감속기&lt;/a&gt; 는 Flux Stores의 &quot;본질&quot;을 캡처하므로 &lt;a href=&quot;http://github.com/acdlite/flummox&quot;&gt;Flummox&lt;/a&gt; , &lt;a href=&quot;http://github.com/goatslacker/alt&quot;&gt;Alt&lt;/a&gt; , &lt;a href=&quot;https://github.com/facebook/flux&quot;&gt;Traditional Flux&lt;/a&gt; 또는 기타 Flux 라이브러리를 사용하든 기존 Flux 프로젝트를 Redux로 점차 마이그레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bb64b4bed7a97c418523d4ffdb6288fb015adc1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;actions&quot;&gt;Actions&lt;/a&gt; describe the fact that &lt;em&gt;something happened&lt;/em&gt;, but don't specify how the application's state changes in response. This is the job of reducers.</source>
          <target state="translated">&lt;a href=&quot;actions&quot;&gt;동작&lt;/a&gt; 은 &lt;em&gt;무언가가 발생&lt;/em&gt; 했다는 사실을 설명 하지만 응용 프로그램의 상태가 응답으로 어떻게 변경되는지는 지정하지 않습니다. 이것은 감속기의 일입니다.</target>
        </trans-unit>
        <trans-unit id="a8dfe31e2797d17be898c68c93f8a46cba6d9313" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;advanced/asyncactions.md&quot;&gt;Async action creators&lt;/a&gt; such as &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; have access to the entire state through &lt;code&gt;getState()&lt;/code&gt;. An action creator can retrieve additional data from the state and put it in an action, so that each reducer has enough information to update its own state slice.</source>
          <target state="translated">&lt;a href=&quot;advanced/asyncactions.md&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; 와 같은 비동기 작업 생성자 는 &lt;code&gt;getState()&lt;/code&gt; 통해 전체 상태에 액세스 할 수 있습니다 . 조치 작성자는 상태에서 추가 데이터를 검색하여 조치에 넣을 수 있으므로 각 감속기에는 자체 상태 슬라이스를 업데이트하기에 충분한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b5742965a8a7e105526f64e826619bea7901c44" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;&lt;/a&gt; is the base dispatch function described above.</source>
          <target state="translated">&lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch(action)&lt;/code&gt; &lt;/a&gt; 은 위에서 설명한 기본 발송 기능입니다.</target>
        </trans-unit>
        <trans-unit id="a233ff3ae6a630832e9d6e12074eca1e882d9857" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;api/store#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; returns the current state of the store.</source>
          <target state="translated">&lt;a href=&quot;api/store#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt; 는 상점의 현재 상태를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dc71ff1690cdf43dbe0920fa906f24d0396f18eb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;api/store#replaceReducer&quot;&gt;&lt;code&gt;replaceReducer(nextReducer)&lt;/code&gt;&lt;/a&gt; can be used to implement hot reloading and code splitting. Most likely you won't use it.</source>
          <target state="translated">&lt;a href=&quot;api/store#replaceReducer&quot;&gt; &lt;code&gt;replaceReducer(nextReducer)&lt;/code&gt; &lt;/a&gt; 를 사용하여 핫 리로딩 및 코드 분할을 구현할 수 있습니다. 아마 당신은 그것을 사용하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="3233aa220cb3c100f9d6ac87a89259afc4cae6e6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;api/store#subscribe&quot;&gt;&lt;code&gt;subscribe(listener)&lt;/code&gt;&lt;/a&gt; registers a function to be called on state changes.</source>
          <target state="translated">&lt;a href=&quot;api/store#subscribe&quot;&gt; &lt;code&gt;subscribe(listener)&lt;/code&gt; &lt;/a&gt; 는 상태 변경시 호출 할 함수를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="67aa063cda369295b907b7e537689d94e06b2f62" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;examples&quot;&gt;Official Examples&lt;/a&gt; &amp;mdash; A few official examples covering different Redux techniques</source>
          <target state="translated">&lt;a href=&quot;examples&quot;&gt;공식 사례&lt;/a&gt; &amp;mdash; 다른 Redux 기술을 다루는 공식 사례</target>
        </trans-unit>
        <trans-unit id="2181ce81664ba928672afb23b8a32ab80e213e8a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;: Enzyme is a JavaScript Testing utility for React that makes it easier to assert, manipulate, and traverse your React Components' output.</source>
          <target state="translated">&lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt; : Enzyme은 React의 JavaScript 테스트 유틸리티로 React Components의 출력을보다 쉽게 ​​주장, 조작 및 트래버스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="326058ae349999870d6aced66c0de2b764c93797" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;Shallow rendering&lt;/a&gt;: Shallow rendering lets you instantiate a component and effectively get the result of its &lt;code&gt;render&lt;/code&gt; method just a single level deep instead of rendering components recursively to a DOM. Shallow rendering is useful for unit tests, where you test a particular component only, and importantly not its children. This also means that changing a child component won't affect the tests for the parent component. Testing a component and all its children can be accomplished with &lt;a href=&quot;http://airbnb.io/enzyme/docs/api/mount.html&quot;&gt;Enzyme's &lt;code&gt;mount()&lt;/code&gt; method&lt;/a&gt;, aka full DOM rendering.</source>
          <target state="translated">&lt;a href=&quot;http://airbnb.io/enzyme/docs/api/shallow.html&quot;&gt;얕은 렌더링&lt;/a&gt; : 얕은 렌더링을 사용하면 구성 요소를 인스턴스화하고 구성 요소를 재귀 적으로 DOM에 렌더링하는 대신 단일 수준의 깊이로 &lt;code&gt;render&lt;/code&gt; 방법 의 결과를 효과적으로 얻을 수 있습니다 . 얕은 렌더링은 특정 구성 요소 만 테스트하며 하위 구성 요소는 테스트하지 않는 단위 테스트에 유용합니다. 이는 하위 구성 요소를 변경해도 상위 구성 요소의 테스트에 영향을 미치지 않음을 의미합니다. 전체 DOM 렌더링 과 같은 &lt;a href=&quot;http://airbnb.io/enzyme/docs/api/mount.html&quot;&gt;Enzyme의 &lt;code&gt;mount()&lt;/code&gt; 메서드를 사용&lt;/a&gt; 하여 구성 요소와 모든 하위 항목을 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="61241f2e9ceb67ae4dfccf7cc9ca1f400093495e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://camsong.github.io/redux-in-chinese/&quot;&gt;中文文档&lt;/a&gt; &amp;mdash; Chinese</source>
          <target state="translated">&lt;a href=&quot;http://camsong.github.io/redux-in-chinese/&quot;&gt;中文 文档&lt;/a&gt; &amp;mdash; 중국어</target>
        </trans-unit>
        <trans-unit id="77565bb24c563c6df104040d230310edcfb00145" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://elm-lang.org/&quot;&gt;Elm&lt;/a&gt; is a functional programming language inspired by Haskell and created by &lt;a href=&quot;https://twitter.com/czaplic&quot;&gt;Evan Czaplicki&lt;/a&gt;. It enforces &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;a &amp;ldquo;model view update&amp;rdquo; architecture&lt;/a&gt;, where the update has the following signature: &lt;code&gt;(action, state) =&amp;gt; state&lt;/code&gt;. Elm &amp;ldquo;updaters&amp;rdquo; serve the same purpose as reducers in Redux.</source>
          <target state="translated">&lt;a href=&quot;http://elm-lang.org/&quot;&gt;Elm&lt;/a&gt; 은 Haskell에서 영감을 얻어 &lt;a href=&quot;https://twitter.com/czaplic&quot;&gt;Evan Czaplicki가&lt;/a&gt; 만든 기능 프로그래밍 언어 입니다. 업데이트는 &lt;code&gt;(action, state) =&amp;gt; state&lt;/code&gt; 서명이 &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;있는 &quot;모델보기 업데이트&quot;아키텍처를&lt;/a&gt; 시행 합니다 . Elm&amp;ldquo;갱신 자&amp;rdquo;는 Redux의 감속기와 같은 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="23d2c2107aca181c46e778f07e56614a8133b8c1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://es.redux.js.org/&quot;&gt;Redux en Espa&amp;ntilde;ol&lt;/a&gt; - Spanish</source>
          <target state="translated">&lt;a href=&quot;http://es.redux.js.org/&quot;&gt;Redux en Espa&amp;ntilde;ol-&lt;/a&gt; 스페인어</target>
        </trans-unit>
        <trans-unit id="ff86a93740e76f0a9a588dfc7edd94627d0b6065" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://facebook.github.io/react/docs/test-utils.html&quot;&gt;React Test Utils&lt;/a&gt;: Test Utilities for React. Used by Enzyme.</source>
          <target state="translated">&lt;a href=&quot;http://facebook.github.io/react/docs/test-utils.html&quot;&gt;테스트 유틸리티 활용&lt;/a&gt; : 테스트 유틸리티 테스트 Enzyme에서 ​​사용합니다.</target>
        </trans-unit>
        <trans-unit id="fa318edcedf300020034617867e41d3d7d461c6b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://github.com/gaearon/redux-devtools&quot;&gt;Redux DevTools&lt;/a&gt; &amp;mdash; An action logger with time travel UI, hot reloading and error handling for the reducers, &lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;first demoed at React Europe&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://github.com/gaearon/redux-devtools&quot;&gt;Redux DevTools&lt;/a&gt; &amp;mdash; 시간 여행 UI, 리 &lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;로더에&lt;/a&gt; 대한 핫 리로딩 및 오류 처리 기능을 갖춘 액션 로거, React Europe에서 처음 시연</target>
        </trans-unit>
        <trans-unit id="8169d6309556697be51098425caaa8733bba177f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; &amp;mdash; The easiest way to write async action creators</source>
          <target state="translated">&lt;a href=&quot;http://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; &amp;mdash; 비동기 액션 제작자를 작성하는 가장 쉬운 방법</target>
        </trans-unit>
        <trans-unit id="f27a8933220f7b51407b0697067eeebc832de481" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/&quot;&gt;Turning the database inside-out&lt;/a&gt; for blowing my mind;</source>
          <target state="translated">&lt;a href=&quot;http://www.confluent.io/blog/turning-the-database-inside-out-with-apache-samza/&quot;&gt;&lt;/a&gt;내 마음을 날려 버리기 위해 데이터베이스를 뒤집어 놓는다.</target>
        </trans-unit>
        <trans-unit id="32b2722ca06d7e3809116a97bf38d37832bcb0ce" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://youtube.com/watch?v=xsSnOQynTHs&quot;&gt;Live React: Hot Reloading and Time Travel&lt;/a&gt; &amp;mdash; See how constraints enforced by Redux make hot reloading with time travel easy</source>
          <target state="translated">&lt;a href=&quot;http://youtube.com/watch?v=xsSnOQynTHs&quot;&gt;라이브 리 액트 : 핫 리로딩 및 타임 트래블&lt;/a&gt; &amp;mdash; Redux가 적용하는 제약 조건이 타임 트래블 과 함께 핫 리로딩을 쉽게 만드는 방법보기</target>
        </trans-unit>
        <trans-unit id="5bc316623c9deb9e9034f7d23637072db15a0f28" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/a&gt; is a part of ES6, but is not implemented by most browsers yet. You'll need to either use a polyfill, a &lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-transform-object-assign&quot;&gt;Babel plugin&lt;/a&gt;, or a helper from another library like &lt;a href=&quot;https://lodash.com/docs#assign&quot;&gt;&lt;code&gt;_.assign()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign()&lt;/code&gt; &lt;/a&gt; 은 ES6의 일부이지만 아직 대부분의 브라우저에서 구현되지 않았습니다. polyfill,&lt;a href=&quot;https://www.npmjs.com/package/babel-plugin-transform-object-assign&quot;&gt; Babel 플러그인&lt;/a&gt; 또는&lt;a href=&quot;https://lodash.com/docs#assign&quot;&gt; &lt;code&gt;_.assign()&lt;/code&gt; &lt;/a&gt; 과 같은 다른 라이브러리의 도우미를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="32bee8f422e4c2ab236c312da17a9c38cac75683" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Getting Started with Redux&lt;/a&gt; is a video course consisting of 30 videos narrated by Dan Abramov, author of Redux. It is designed to complement the &amp;ldquo;Basics&amp;rdquo; part of the docs while bringing additional insights about immutability, testing, Redux best practices, and using Redux with React. &lt;strong&gt;This course is free and will always be.&lt;/strong&gt;</source>
          <target state="translated">&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Redux 시작하기는 Redux의&lt;/a&gt; 저자 Dan Abramov가 30 개의 비디오로 구성된 비디오 코스입니다. 이 문서는 문서의 &quot;기본&quot;부분을 보완하면서 불변성, 테스트, Redux 모범 사례 및 Reux와 함께 Redux 사용에 대한 추가 정보를 제공합니다. &lt;strong&gt;이 과정은 무료이며 항상 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2950e131e272fe84d311faa920bbd6acbf06f7a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/immutable-js&quot;&gt;Immutable&lt;/a&gt; is a JavaScript library implementing persistent data structures. It is performant and has an idiomatic JavaScript API.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/immutable-js&quot;&gt;불변&lt;/a&gt; 은 영구적 인 데이터 구조를 구현하는 JavaScript 라이브러리입니다. 성능이 뛰어나고 관용적 인 JavaScript API가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5833afba76ada5ae020425be0bb3df43c4f7430" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/ForbesLindesay/redux-optimist&quot;&gt;redux-optimist&lt;/a&gt; &amp;mdash; Optimistically apply actions that can be later committed or reverted</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ForbesLindesay/redux-optimist&quot;&gt;redux-optimist&lt;/a&gt; &amp;mdash; 나중에 커밋하거나 되돌릴 수있는 작업을 낙관적으로 적용</target>
        </trans-unit>
        <trans-unit id="246e34aae7982e56bc50e3cae1f0ce328818b50c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt; is a superb way to manage the complexity of asynchronous apps. In fact &lt;a href=&quot;http://cycle.js.org&quot;&gt;there is an effort to create a library that models human-computer interaction as interdependent observables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt; 는 비동기 앱의 복잡성을 관리하는 최상의 방법입니다. 실제로 &lt;a href=&quot;http://cycle.js.org&quot;&gt;인간과 컴퓨터의 상호 작용을 상호 의존적 인 관찰 가능으로 모델링하는 라이브러리를 만들려는 노력이 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc1628bafccfa550b14477fdcb8a2880af27d670" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/Yomguithereal/baobab&quot;&gt;Baobab&lt;/a&gt; is another popular library implementing immutable API for updating plain JavaScript objects. While you can use it with Redux, there is little benefit in using them together.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Yomguithereal/baobab&quot;&gt;Baobab&lt;/a&gt; 은 일반 JavaScript 객체를 업데이트하기 위해 변경 불가능한 API를 구현하는 인기있는 또 다른 라이브러리입니다. Redux와 함께 사용할 수 있지만 함께 사용하면 이점이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="ca68c66f6b4c6a980738b0b474b7797724c475ae" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/flummox&quot;&gt;Flummox&lt;/a&gt; for teaching me to approach Flux without boilerplate or singletons;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/flummox&quot;&gt;상용구나&lt;/a&gt; 싱글 톤없이 플럭스에 접근하도록 가르치는 Flummox ;</target>
        </trans-unit>
        <trans-unit id="462c24fee4dc0ea20edf2fb2bcab21199e928183" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; &amp;mdash; A human-friendly standard for Flux action objects</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; &amp;mdash; 플럭스 액션 객체를위한 인간 친화적 인 표준</target>
        </trans-unit>
        <trans-unit id="d6681847f5ac1aebff1682d6668c0423aa44ef28" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt; &amp;mdash; Reduces the boilerplate in writing reducers and action creators</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt; &amp;mdash; 리듀서 및 액션 제작자를 작성하는 데있어 상용구를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="e21d89989e6407db8130754d1c8cc4ea48c320c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; &amp;mdash; &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;FSA&lt;/a&gt;-compliant promise middleware</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; &amp;mdash; &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;FSA&lt;/a&gt; 호환 약속 미들웨어</target>
        </trans-unit>
        <trans-unit id="adc32c5ec0e57af144b709327c464173a6558f7a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/acdlite/redux-transducers&quot;&gt;redux-transducers&lt;/a&gt; &amp;mdash; Transducer utilities for Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/redux-transducers&quot;&gt;redux-transducers&lt;/a&gt; &amp;mdash; Redux 용 변환기 유틸리티</target>
        </trans-unit>
        <trans-unit id="635f1546df5dc27cea670f0285cbf50019b2608f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/alexkuz/redux-devtools-inspector&quot;&gt;Inspector&lt;/a&gt; &amp;mdash; A custom monitor for Redux DevTools that lets you filter actions, inspect diffs, and pin deep paths in the state to observe their changes</source>
          <target state="translated">&lt;a href=&quot;https://github.com/alexkuz/redux-devtools-inspector&quot;&gt;Inspector&lt;/a&gt; &amp;mdash; Redux DevTools 용 사용자 정의 모니터로, 동작을 필터링하고, diff를 검사하고, 상태에서 딥 경로를 고정하여 변경 사항을 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5392440f66a0b62817730b32d7e87386d20ed41e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/andrewngu/sound-redux&quot;&gt;SoundRedux&lt;/a&gt; &amp;mdash; A SoundCloud client built with Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/andrewngu/sound-redux&quot;&gt;SoundRedux&lt;/a&gt; &amp;mdash; Redux로 구축 된 SoundCloud 클라이언트</target>
        </trans-unit>
        <trans-unit id="671366abacb074ef67f4cf3094e172cad3c7de19" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/apollostack/apollo-client&quot;&gt;apollo-client&lt;/a&gt; &amp;mdash; A simple caching client for any GraphQL server and UI framework built on top of Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/apollostack/apollo-client&quot;&gt;apollo-client&lt;/a&gt; &amp;mdash; Redux 위에 구축 된 모든 GraphQL 서버 및 UI 프레임 워크를위한 간단한 캐싱 클라이언트</target>
        </trans-unit>
        <trans-unit id="9e948c295aecd2de19653c56dd37e6164bc205c0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/arnaudbenard/redux-mock-store&quot;&gt;redux-mock-store&lt;/a&gt; &amp;mdash; Mock redux store for testing your app</source>
          <target state="translated">&lt;a href=&quot;https://github.com/arnaudbenard/redux-mock-store&quot;&gt;redux-mock-store&lt;/a&gt; &amp;mdash; 앱 테스트를위한 모의 redux store</target>
        </trans-unit>
        <trans-unit id="7a572eea1e304e2b4d1765dc1dd8e7e6d040fb4a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/bvaughn/redux-devtools-filterable-log-monitor/&quot;&gt;Filterable Log Monitor&lt;/a&gt; &amp;mdash; Filterable tree view monitor for Redux DevTools</source>
          <target state="translated">&lt;a href=&quot;https://github.com/bvaughn/redux-devtools-filterable-log-monitor/&quot;&gt;필터링 가능한 로그 모니터&lt;/a&gt; &amp;mdash; Redux DevTools에 대한 필터링 가능한 트리 뷰 모니터</target>
        </trans-unit>
        <trans-unit id="738b91de5b474d6632d5e4c6ca13f26cbbbfe538" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/calesce/redux-slider-monitor&quot;&gt;Slider Monitor&lt;/a&gt; &amp;mdash; A custom monitor for Redux DevTools to replay recorded Redux actions</source>
          <target state="translated">&lt;a href=&quot;https://github.com/calesce/redux-slider-monitor&quot;&gt;슬라이더 모니터&lt;/a&gt; &amp;mdash; Redux DevTools가 기록 된 Redux 작업을 재생하기위한 사용자 지정 모니터</target>
        </trans-unit>
        <trans-unit id="a6b82050d15ff636cab86ab964babce485a0a59e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/cerebral/redux-action-tree&quot;&gt;redux-action-tree&lt;/a&gt; &amp;mdash; Composable Cerebral-style signals for Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/cerebral/redux-action-tree&quot;&gt;redux-action-tree&lt;/a&gt; &amp;mdash; Redux 용 컴포저 블 뇌 스타일 신호</target>
        </trans-unit>
        <trans-unit id="c3cb45ad1ce1a52403984ab13791a016bacbef87" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/chentsulin/redux&quot;&gt;繁體中文文件&lt;/a&gt; &amp;mdash; Traditional Chinese</source>
          <target state="translated">&lt;a href=&quot;https://github.com/chentsulin/redux&quot;&gt;繁體 中文 文件&lt;/a&gt; &amp;ndash; 중국어 번체</target>
        </trans-unit>
        <trans-unit id="7237f437351893c36e43e30f1a66cf47ac72460d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/cyclejs-community/redux-cycles&quot;&gt;redux-cycles&lt;/a&gt; &amp;mdash; Handle Redux async actions using Cycle.js</source>
          <target state="translated">&lt;a href=&quot;https://github.com/cyclejs-community/redux-cycles&quot;&gt;redux-cycles&lt;/a&gt; &amp;mdash; Cycle.js를 사용하여 Redux 비동기 작업 처리</target>
        </trans-unit>
        <trans-unit id="4d850aef967058fa2b6d38c9b44bb6100d7ef473" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/cyclejs/cycle-core&quot;&gt;Cycle&lt;/a&gt; for showing how often a function is the best tool;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/cyclejs/cycle-core&quot;&gt;&lt;/a&gt;함수가 가장 좋은 도구 인 빈도를 보여 주기 위한 주기 .</target>
        </trans-unit>
        <trans-unit id="b646bb52b5ada7949ead74ceb015522a73c82f52" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/davidkpiano/react-redux-form&quot;&gt;react-redux-form&lt;/a&gt; &amp;mdash; Create forms easily in React with Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/davidkpiano/react-redux-form&quot;&gt;react-redux-form&lt;/a&gt; &amp;mdash; Redux를 사용하여 React에서 양식을 쉽게 작성</target>
        </trans-unit>
        <trans-unit id="9b485a9343cd81ce214624d7ee75dd8b5f957f28" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/dmitry-zaets/redux-actions-assertions&quot;&gt;redux-actions-assertions&lt;/a&gt; &amp;mdash; Assertions for Redux actions testing</source>
          <target state="translated">&lt;a href=&quot;https://github.com/dmitry-zaets/redux-actions-assertions&quot;&gt;redux-actions-assertions&lt;/a&gt; &amp;mdash; Redux 조치 테스트를위한 어설 션</target>
        </trans-unit>
        <trans-unit id="33d0704f90d9fc9bec2f6289de5455def009259f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/ekosz/redux-falcor&quot;&gt;redux-falcor&lt;/a&gt; &amp;mdash; Falcor</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ekosz/redux-falcor&quot;&gt;redux-falcor&lt;/a&gt; &amp;mdash; 팔 코르</target>
        </trans-unit>
        <trans-unit id="b7052bc5ca61cda06f2e818249aab92d0c11f8df" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/erikras/ducks-modular-redux&quot;&gt;Ducks: Redux Reducer Bundles&lt;/a&gt; &amp;mdash; A proposal for bundling reducers, action types and actions</source>
          <target state="translated">&lt;a href=&quot;https://github.com/erikras/ducks-modular-redux&quot;&gt;Ducks : Redux Reducer Bundles&lt;/a&gt; &amp;mdash; 리듀서, 액션 유형 및 액션 번들링 제안</target>
        </trans-unit>
        <trans-unit id="5ad64f1b1acf59b7989610892266e94fa9a6e64b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/erikras/redux-form&quot;&gt;redux-form&lt;/a&gt; &amp;mdash; Keep React form state in Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/erikras/redux-form&quot;&gt;redux-form&lt;/a&gt; &amp;mdash; Redux에서 반응 양식 상태 유지</target>
        </trans-unit>
        <trans-unit id="e0a49ddf7651bd6d746fee97f180340c5c22b41b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial&quot;&gt;The Elm Architecture&lt;/a&gt; for a great intro to modeling state updates with reducers;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial&quot;&gt;&lt;/a&gt;감속기를 사용하여 상태 업데이트를 모델링하는 방법을 소개하는 Elm 아키텍처</target>
        </trans-unit>
        <trans-unit id="be4545fd7b6adf364efdbb91002ae394c5e58615" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/faassen/reselect&quot;&gt;reselect&lt;/a&gt; &amp;mdash; Efficient derived data selectors inspired by NuclearJS</source>
          <target state="translated">&lt;a href=&quot;https://github.com/faassen/reselect&quot;&gt;reselect&lt;/a&gt; &amp;mdash; NuclearJS에서 영감을 얻은 효율적인 파생 데이터 선택기</target>
        </trans-unit>
        <trans-unit id="7708a46f9be2f564980d4e5bda78b4c5d35dc9de" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/facebook/react&quot;&gt;React&lt;/a&gt; for the pragmatic innovation.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/facebook/react&quot;&gt;반응&lt;/a&gt; 실용적인 혁신.</target>
        </trans-unit>
        <trans-unit id="5a476b863690c612db3b916dce5198f075291ef2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/fcomb/redux-logger&quot;&gt;redux-logger&lt;/a&gt; &amp;mdash; Log every Redux action and the next state</source>
          <target state="translated">&lt;a href=&quot;https://github.com/fcomb/redux-logger&quot;&gt;redux-logger&lt;/a&gt; &amp;mdash; 모든 Redux 작업과 다음 상태를 기록합니다</target>
        </trans-unit>
        <trans-unit id="2168fa4ca440f276c71b288e63a7bd560f0d0edb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; &amp;mdash; React</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; &amp;mdash; 반응</target>
        </trans-unit>
        <trans-unit id="49be928336c3ea70b586e1e0221f5209809256da" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gaearon/redux-devtools-dock-monitor&quot;&gt;Dock Monitor&lt;/a&gt; &amp;mdash; A resizable and movable dock for Redux DevTools monitors</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gaearon/redux-devtools-dock-monitor&quot;&gt;도크 모니터&lt;/a&gt; &amp;mdash; Redux DevTools 모니터 용 크기 조정 및 이동 가능한 도크</target>
        </trans-unit>
        <trans-unit id="77e5d33e4cdf47037c30e1ca512f37cfeb999700" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gaearon/redux-devtools-log-monitor&quot;&gt;Log Monitor&lt;/a&gt; &amp;mdash; The default monitor for Redux DevTools with a tree view</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gaearon/redux-devtools-log-monitor&quot;&gt;로그 모니터&lt;/a&gt; &amp;mdash; 트리보기가있는 Redux DevTools의 기본 모니터</target>
        </trans-unit>
        <trans-unit id="c54d5349a1205ea2a9b173fd0057e9c134ab4d2d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Thunk middleware&lt;/a&gt; isn't the only way to orchestrate asynchronous actions in Redux:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;&lt;/a&gt;Redux에서 썽크 미들웨어 가 비동기 작업을 조정하는 유일한 방법은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7a086cebb6f586cfe6a594cda767089a867b08af" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gajus/canonical-reducer-composition&quot;&gt;Canonical Reducer Composition&lt;/a&gt; &amp;mdash; An opinionated standard for nested reducer composition</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gajus/canonical-reducer-composition&quot;&gt;정식 감속기 구성&lt;/a&gt; &amp;mdash; 중첩 된 감속기 구성에 대한 의견이 많은 표준</target>
        </trans-unit>
        <trans-unit id="e745d89480c38f6937d9c622112c47d79aaa31e4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gajus/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt; &amp;mdash; Used to create an equivalent function of Redux &lt;code&gt;combineReducers&lt;/code&gt; that works with &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable.js&lt;/a&gt; state.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gajus/redux-immutable&quot;&gt;redux-immutable&lt;/a&gt; &amp;mdash; &lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;Immutable.js&lt;/a&gt; 상태 와 작동하는 Redux &lt;code&gt;combineReducers&lt;/code&gt; 와 동등한 기능을 만드는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c52fcd9623ac00993923a629ce837ba45e51c0e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/gcanti/redux-tcomb&quot;&gt;redux-tcomb&lt;/a&gt; &amp;mdash; Immutable and type-checked state and actions for Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gcanti/redux-tcomb&quot;&gt;redux-tcomb&lt;/a&gt; &amp;mdash; Redux에 대한 변경 불가능한 유형 검사 상태 및 작업</target>
        </trans-unit>
        <trans-unit id="af81282584d63bf8638d0e9e5cc4817051b43838" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/johanneslumpe/redux-history-transitions&quot;&gt;redux-history-transitions&lt;/a&gt; &amp;mdash; History transitions based on arbitrary actions</source>
          <target state="translated">&lt;a href=&quot;https://github.com/johanneslumpe/redux-history-transitions&quot;&gt;redux-history-transitions&lt;/a&gt; &amp;mdash; 임의의 행동에 기반한 역사 전환</target>
        </trans-unit>
        <trans-unit id="4ec6e8ad705f1aceaf230c55020882fad996b178" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/leoasis/redux-immutable-state-invariant&quot;&gt;redux-immutable-state-invariant&lt;/a&gt; &amp;mdash; Warns about state mutations in development</source>
          <target state="translated">&lt;a href=&quot;https://github.com/leoasis/redux-immutable-state-invariant&quot;&gt;redux-immutable-state-invariant&lt;/a&gt; &amp;mdash; 개발중인 상태 돌연변이에 대해 경고</target>
        </trans-unit>
        <trans-unit id="7905dff698bee7543c15da2228433d7b1d6a338f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/markdalgleish/redial&quot;&gt;redial&lt;/a&gt; &amp;mdash; Universal data fetching and route lifecycle management for React that works great with Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/markdalgleish/redial&quot;&gt;재 다이얼&lt;/a&gt; &amp;mdash; Redux와 잘 작동하는 React의 범용 데이터 페치 및 라우트 수명주기 관리</target>
        </trans-unit>
        <trans-unit id="b9e9eaeab55b0c8cd498c9f208fca819c29ea328" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/markdalgleish/redux-analytics&quot;&gt;redux-analytics&lt;/a&gt; &amp;mdash; Analytics middleware for Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/markdalgleish/redux-analytics&quot;&gt;redux-analytics&lt;/a&gt; &amp;mdash; Redux 용 분석 미들웨어</target>
        </trans-unit>
        <trans-unit id="76bd67d8f88905517eed83dafa3047921d206f66" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/markerikson/react-redux-links&quot;&gt;React-Redux Links&lt;/a&gt; is a curated list of high-quality articles, tutorials, and related content for React, Redux, ES6, and more.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/markerikson/react-redux-links&quot;&gt;React-Redux Links&lt;/a&gt; 는 React, Redux, ES6 등을위한 고품질 기사, 튜토리얼 및 관련 컨텐츠의 선별 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="7458fee6ef27b6ea44de14b58a088b3d484787c5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Ecosystem Links&lt;/a&gt; is a categorized collection of Redux-related libraries, addons, and utilities.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Ecosystem Links&lt;/a&gt; 는 Redux 관련 라이브러리, 애드온 및 유틸리티의 분류 된 모음입니다.</target>
        </trans-unit>
        <trans-unit id="5c521f74e329344dfada627572d0439c5ce27980" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/mattkrick/redux-optimistic-ui&quot;&gt;redux-optimistic-ui&lt;/a&gt; &amp;mdash; A reducer enhancer to enable type-agnostic optimistic updates</source>
          <target state="translated">&lt;a href=&quot;https://github.com/mattkrick/redux-optimistic-ui&quot;&gt;redux-optimistic-ui&lt;/a&gt; &amp;mdash; 유형에 관계없이 낙관적 업데이트를 지원하는 감속기 향상 기</target>
        </trans-unit>
        <trans-unit id="09a22d71db7bc4a31e59f65f17a1c4390b8be913" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/mohebifar/grafgiti&quot;&gt;grafgiti&lt;/a&gt; &amp;mdash; Create graffiti on your GitHub contributions wall</source>
          <target state="translated">&lt;a href=&quot;https://github.com/mohebifar/grafgiti&quot;&gt;grafgiti&lt;/a&gt; &amp;mdash; GitHub 기여 벽에 낙서를 만듭니다</target>
        </trans-unit>
        <trans-unit id="fcdd90fbe1bce5cda821db0cbb40e37a05bb4838" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/omcljs/om&quot;&gt;Om&lt;/a&gt; for popularizing the idea of a single state atom;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/omcljs/om&quot;&gt;&lt;/a&gt;단일 상태 원자의 아이디어를 대중화하기위한 옴 ;</target>
        </trans-unit>
        <trans-unit id="126f6dcd5981219780c79f04dab128927a0c526e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/omnidan/redux-ignore&quot;&gt;redux-ignore&lt;/a&gt; &amp;mdash; Ignore redux actions by array or filter function</source>
          <target state="translated">&lt;a href=&quot;https://github.com/omnidan/redux-ignore&quot;&gt;redux-ignore&lt;/a&gt; &amp;mdash; 배열 또는 필터 기능으로 redux 동작을 무시합니다</target>
        </trans-unit>
        <trans-unit id="522c27cd295aa2f0b11343353b70bfe170950f50" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/omnidan/redux-recycle&quot;&gt;redux-recycle&lt;/a&gt; &amp;mdash; Reset the redux state on certain actions</source>
          <target state="translated">&lt;a href=&quot;https://github.com/omnidan/redux-recycle&quot;&gt;redux-recycle&lt;/a&gt; &amp;mdash; 특정 작업에서 redux 상태를 재설정합니다</target>
        </trans-unit>
        <trans-unit id="6e04e334289a63c7eb319c457b7a701b7a18d175" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;redux-undo&lt;/a&gt; &amp;mdash; Effortless undo/redo and action history for your reducers</source>
          <target state="translated">&lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;redux-undo&lt;/a&gt; &amp;mdash; 감속기에 대한 간편한 실행 취소 / 다시 실행 및 작업 기록</target>
        </trans-unit>
        <trans-unit id="1b6afe4d71b345b389ea720ccf3e22bb58ff5fe1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/optimizely/nuclear-js&quot;&gt;NuclearJS&lt;/a&gt; for proving this architecture can be performant;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/optimizely/nuclear-js&quot;&gt;&lt;/a&gt;이 아키텍처를 증명하는 NuclearJS 는 성능이 우수합니다.</target>
        </trans-unit>
        <trans-unit id="55a0eceb1b164ebfa98d862358a8699dd0e2f1b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt; &amp;mdash; Normalize nested API responses for easier consumption by the reducers</source>
          <target state="translated">&lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt; &amp;mdash; 리듀서가 더 쉽게 소비 할 수 있도록 중첩 된 API 응답을 표준화합니다.</target>
        </trans-unit>
        <trans-unit id="65f9399982e1960cfde9ce2d4776f97eff213665" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/pauldijou/redux-act&quot;&gt;redux-act&lt;/a&gt; &amp;mdash; An opinionated library for making reducers and action creators</source>
          <target state="translated">&lt;a href=&quot;https://github.com/pauldijou/redux-act&quot;&gt;redux-act&lt;/a&gt; &amp;mdash; 리듀서와 액션 제작자를 만드는 의견이 많은 라이브러리</target>
        </trans-unit>
        <trans-unit id="e142b1d7524dc9418bc9105b107102a2fd757747" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/peter-mouland/react-lego&quot;&gt;React-lego&lt;/a&gt; &amp;mdash; How to plug into React, one block at a time.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/peter-mouland/react-lego&quot;&gt;React-lego&lt;/a&gt; &amp;mdash; 한 번에 한 블록 씩 React에 연결하는 방법.</target>
        </trans-unit>
        <trans-unit id="1a7170877b7e65113318685e20beab1c145c3d9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/raisemarketplace/redux-loop&quot;&gt;redux-loop&lt;/a&gt; &amp;mdash; Sequence effects purely and naturally by returning them from your reducers</source>
          <target state="translated">&lt;a href=&quot;https://github.com/raisemarketplace/redux-loop&quot;&gt;redux-loop&lt;/a&gt; &amp;mdash; 감속기에서 효과를 반환하여 순수하고 자연스럽게 시퀀스 효과</target>
        </trans-unit>
        <trans-unit id="61e82f58dea0ceacdd0d73fa2c46474f99faa32f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/rajdee/redux-in-russian&quot;&gt;Redux in Russian&lt;/a&gt; &amp;mdash; Russian</source>
          <target state="translated">&lt;a href=&quot;https://github.com/rajdee/redux-in-russian&quot;&gt;러시아어로 Redux&lt;/a&gt; &amp;mdash; 러시아어</target>
        </trans-unit>
        <trans-unit id="911ae2c57d05e9d855f2f55ff67275735c340d15" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React bindings&lt;/a&gt; are not included in Redux by default. You need to install them explicitly:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;반응 바인딩&lt;/a&gt; 은 기본적으로 Redux에 포함되지 않습니다. 명시 적으로 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="668aa71ef061f4bf5fb388597bd4ba6608d4c54b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/reactjs/react-router-redux&quot;&gt;react-router-redux&lt;/a&gt; &amp;mdash; Ruthlessly simple bindings to keep React Router and Redux in sync</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/react-router-redux&quot;&gt;react-router-redux&lt;/a&gt; &amp;mdash; 리 액트 라우터와 Redux를 동기화하기 위해 무자비하게 간단한 바인딩</target>
        </trans-unit>
        <trans-unit id="27c27d0e05c340bb3f9aef884df7dc33cd70121a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;Reselect&lt;/a&gt; is a simple library for creating memoized, composable &lt;strong&gt;selector&lt;/strong&gt; functions. Reselect selectors can be used to efficiently compute derived data from the Redux store.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;재 선택&lt;/a&gt; 은 작성 가능한 작성 가능한 &lt;strong&gt;선택기&lt;/strong&gt; 함수 를 작성하기위한 간단한 라이브러리입니다 . 재 선택 선택기를 사용하여 Redux 저장소에서 파생 된 데이터를 효율적으로 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ba8f921a9c78cafaacaa6ee8c5f98b20c97a3b5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/redbooth/backbone-redux&quot;&gt;backbone-redux&lt;/a&gt; &amp;mdash; Backbone</source>
          <target state="translated">&lt;a href=&quot;https://github.com/redbooth/backbone-redux&quot;&gt;백본 redux&lt;/a&gt; &amp;mdash; 백본</target>
        </trans-unit>
        <trans-unit id="b77488ca5a784aa384877c247d815112efb36766" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/redux-observable/redux-observable/&quot;&gt;redux-observable&lt;/a&gt; &amp;mdash; RxJS middleware for action side effects using &quot;Epics&quot;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/redux-observable/redux-observable/&quot;&gt;redux-observable&lt;/a&gt; &amp;mdash; &quot;Epics&quot;를 사용한 액션 부작용을위한 RxJS 미들웨어</target>
        </trans-unit>
        <trans-unit id="828ba846080beeaf8593a911bc08a82eae111e4c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/remojansen/redux-bootstrap&quot;&gt;redux-bootstrap&lt;/a&gt; &amp;mdash; Bootstrapping function for Redux applications</source>
          <target state="translated">&lt;a href=&quot;https://github.com/remojansen/redux-bootstrap&quot;&gt;redux-bootstrap&lt;/a&gt; &amp;mdash; Redux 애플리케이션을위한 부트 스트랩 기능</target>
        </trans-unit>
        <trans-unit id="6b7feaf455447814c0b1409ee14b19a53959a4aa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/romseguy/redux-devtools-chart-monitor&quot;&gt;Chart Monitor&lt;/a&gt; &amp;mdash; A chart monitor for Redux DevTools</source>
          <target state="translated">&lt;a href=&quot;https://github.com/romseguy/redux-devtools-chart-monitor&quot;&gt;차트 모니터&lt;/a&gt; &amp;mdash; Redux DevTools의 차트 모니터</target>
        </trans-unit>
        <trans-unit id="60a2a8fab7f2253f7754f7fddd44616ca6818b07" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/salsita/redux-side-effects&quot;&gt;redux-side-effects&lt;/a&gt; &amp;mdash; Utilize Generators for declarative yielding of side effects from your pure reducers</source>
          <target state="translated">&lt;a href=&quot;https://github.com/salsita/redux-side-effects&quot;&gt;redux-side-effects-&lt;/a&gt; 순수한 리듀서로부터 부작용을 선언적으로 생성하기 위해 제너레이터를 활용</target>
        </trans-unit>
        <trans-unit id="7ff5b0a547b627bfa68c17e7844cedfb2ed89258" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/samiskin/redux-electron-store&quot;&gt;redux-electron-store&lt;/a&gt; &amp;mdash; Store enhancers that synchronize Redux stores across Electron processes</source>
          <target state="translated">&lt;a href=&quot;https://github.com/samiskin/redux-electron-store&quot;&gt;redux-electron-store&lt;/a&gt; &amp;mdash; 전자 프로세스에서 Redux 저장소를 동기화하는 저장소 향상 기</target>
        </trans-unit>
        <trans-unit id="ead5dd38514e378fce4086ebe8dd69902a5b98c2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/socialtables/redux-unhandled-action&quot;&gt;redux-unhandled-action&lt;/a&gt; &amp;mdash; Warns about actions that produced no state changes in development</source>
          <target state="translated">&lt;a href=&quot;https://github.com/socialtables/redux-unhandled-action&quot;&gt;redux-unhandled-action&lt;/a&gt; &amp;mdash; 개발시 상태가 변경 되지 않은 동작 에 대해 경고합니다.</target>
        </trans-unit>
        <trans-unit id="bf95415084cc2980fc6fc410238771c666d7e934" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/svrcekmichal/redux-axios-middleware&quot;&gt;redux-axios-middleware&lt;/a&gt; &amp;mdash; Redux middleware for fetching data with axios HTTP client</source>
          <target state="translated">&lt;a href=&quot;https://github.com/svrcekmichal/redux-axios-middleware&quot;&gt;redux-axios-middleware&lt;/a&gt; &amp;mdash; axios HTTP 클라이언트로 데이터를 가져 오기위한 Redux 미들웨어</target>
        </trans-unit>
        <trans-unit id="488dc9a66e0ee669bd6c2836ade49d817496c75f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/tappleby/redux-batched-subscribe&quot;&gt;redux-batched-subscribe&lt;/a&gt; &amp;mdash; Customize batching and debouncing calls to the store subscribers</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tappleby/redux-batched-subscribe&quot;&gt;redux-batched-subscribe&lt;/a&gt; &amp;mdash; 상점 가입자에 대한 일괄 처리 및 수신 거부 통화를 사용자 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d62d13ae7d772ba57c13adb46a8d192d8b354469" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/threepointone/disto&quot;&gt;disto&lt;/a&gt; for a proof of concept of hot reloadable Stores;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/threepointone/disto&quot;&gt;&lt;/a&gt;핫 리로드 가능한 상점의 개념 증명을 위해 디스토 ;</target>
        </trans-unit>
        <trans-unit id="912430794c537f9a04fb5544fe58c82ee48c26e3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/toranb/ember-redux&quot;&gt;ember-redux&lt;/a&gt; - Ember.js</source>
          <target state="translated">&lt;a href=&quot;https://github.com/toranb/ember-redux&quot;&gt;ember-redux&lt;/a&gt; -Ember.js</target>
        </trans-unit>
        <trans-unit id="c2212eb90d319aca256b12839bd5d9dcd2540c5d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/treasure-data/redux-search&quot;&gt;redux-search&lt;/a&gt; &amp;mdash; Automatically index resources in a web worker and search them without blocking</source>
          <target state="translated">&lt;a href=&quot;https://github.com/treasure-data/redux-search&quot;&gt;redux-search&lt;/a&gt; &amp;mdash; 웹 워커에서 자동으로 리소스를 색인화하고 차단하지 않고 검색</target>
        </trans-unit>
        <trans-unit id="3e82c33a3fc3f5c23b3991ac9deca81f6412a661" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/troch/deku-redux&quot;&gt;deku-redux&lt;/a&gt; &amp;mdash; Deku</source>
          <target state="translated">&lt;a href=&quot;https://github.com/troch/deku-redux&quot;&gt;deku-redux&lt;/a&gt; &amp;mdash; 데쿠</target>
        </trans-unit>
        <trans-unit id="99aa71b3cf414c2d077d231fe32a1a8b772e1744" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/tshelburne/redux-batched-actions&quot;&gt;redux-batched-actions&lt;/a&gt; &amp;mdash; Dispatch several actions with a single subscriber notification</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tshelburne/redux-batched-actions&quot;&gt;redux-batched-actions&lt;/a&gt; &amp;mdash; 단일 가입자 알림으로 여러 작업 전달</target>
        </trans-unit>
        <trans-unit id="8d1f69116287116136f16831edea2d4b75387cad" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/tur-nr/polymer-redux&quot;&gt;polymer-redux&lt;/a&gt; - Polymer</source>
          <target state="translated">&lt;a href=&quot;https://github.com/tur-nr/polymer-redux&quot;&gt;폴리머 레 덕스&lt;/a&gt; -폴리머</target>
        </trans-unit>
        <trans-unit id="f9e8533e56143915a47d6d3230814c97d167fc30" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/wbuchwalter/ng-redux&quot;&gt;ng-redux&lt;/a&gt; &amp;mdash; Angular</source>
          <target state="translated">&lt;a href=&quot;https://github.com/wbuchwalter/ng-redux&quot;&gt;ng-redux&lt;/a&gt; &amp;mdash; 각도</target>
        </trans-unit>
        <trans-unit id="1adb84ec0d3fedd9d8140dcfd21cfdaba981e57e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/wbuchwalter/ng2-redux&quot;&gt;ng2-redux&lt;/a&gt; &amp;mdash; Angular 2</source>
          <target state="translated">&lt;a href=&quot;https://github.com/wbuchwalter/ng2-redux&quot;&gt;ng2-redux&lt;/a&gt; &amp;mdash; 각도 2</target>
        </trans-unit>
        <trans-unit id="dd42afd688fd3993d131ac58c470db0ca64d0ed6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/weo-edu/redux-gen&quot;&gt;redux-gen&lt;/a&gt; &amp;mdash; Generator middleware for Redux</source>
          <target state="translated">&lt;a href=&quot;https://github.com/weo-edu/redux-gen&quot;&gt;redux-gen&lt;/a&gt; &amp;mdash; Redux 용 생성기 미들웨어</target>
        </trans-unit>
        <trans-unit id="cebbfc649b40e0fa8771d195a93b9007758c40f2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/whetstone/redux-devtools-diff-monitor&quot;&gt;Diff Monitor&lt;/a&gt; &amp;mdash; A monitor for Redux Devtools that diffs the Redux store mutations between actions</source>
          <target state="translated">&lt;a href=&quot;https://github.com/whetstone/redux-devtools-diff-monitor&quot;&gt;Diff Monitor (Diff 모니터)&lt;/a&gt; &amp;mdash; 동작 사이의 Redux 저장소 돌연변이를 다른 Redux Devtools에 대한 모니터</target>
        </trans-unit>
        <trans-unit id="884a589c3e5de51191487d1c59f1e5b7ee3a0166" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt; is an extensive list of Redux-related repositories.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt; 는 Redux 관련 리포지토리의 광범위한 목록입니다.</target>
        </trans-unit>
        <trans-unit id="fce41d2fa6e7a2ae377463a862099fc7ee043817" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/yelouafi/redux-saga&quot;&gt;redux-saga&lt;/a&gt; &amp;mdash; An alternative side effect model for Redux apps</source>
          <target state="translated">&lt;a href=&quot;https://github.com/yelouafi/redux-saga&quot;&gt;redux-saga&lt;/a&gt; &amp;mdash; Redux 앱의 대체 부작용 모델</target>
        </trans-unit>
        <trans-unit id="542f399508a2cf17f958319802f4280895a81ac0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/zalmoxisus/redux-devtools-extension&quot;&gt;Redux DevTools Extension&lt;/a&gt; &amp;mdash; A Chrome extension wrapping Redux DevTools and providing additional functionality</source>
          <target state="translated">&lt;a href=&quot;https://github.com/zalmoxisus/redux-devtools-extension&quot;&gt;Redux DevTools Extension&lt;/a&gt; &amp;mdash; Redux DevTools를 감싸고 추가 기능을 제공하는 Chrome 확장</target>
        </trans-unit>
        <trans-unit id="bff1493331d9a72ee214aa8584a7e46f854bd6c8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/zalmoxisus/redux-devtools-filter-actions&quot;&gt;Filter Actions&lt;/a&gt; &amp;mdash; Redux DevTools composable monitor with the ability to filter actions</source>
          <target state="translated">&lt;a href=&quot;https://github.com/zalmoxisus/redux-devtools-filter-actions&quot;&gt;필터 작업&lt;/a&gt; &amp;mdash; 작업 을 필터링하는 기능이있는 Redux DevTools 컴포저 블 모니터</target>
        </trans-unit>
        <trans-unit id="610aadc45610fd3178ec1a4d0f1659f86c3a4382" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://twitter.com/fisherwebdev/status/616278911886884864&quot;&gt;Yes&lt;/a&gt;, and &lt;a href=&quot;https://twitter.com/andrestaltz/status/616270755605708800&quot;&gt;no&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://twitter.com/fisherwebdev/status/616278911886884864&quot;&gt;예&lt;/a&gt; 와 &lt;a href=&quot;https://twitter.com/andrestaltz/status/616270755605708800&quot;&gt;아니오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="281d252a27e2a0e50333c0c16988433e3ea99926" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://webpack.js.org/concepts/hot-module-replacement/&quot;&gt;Webpack&lt;/a&gt; for Hot Module Replacement;</source>
          <target state="translated">&lt;a href=&quot;https://webpack.js.org/concepts/hot-module-replacement/&quot;&gt;&lt;/a&gt;핫 모듈 교체 용 웹팩 ;</target>
        </trans-unit>
        <trans-unit id="d362f1adc4636a71a99777bb9d42676751de79ab" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.smashingmagazine.com/2016/09/how-to-scale-react-applications/&quot;&gt;How to Scale React Applications&lt;/a&gt; (accompanying talk: &lt;a href=&quot;https://vimeo.com/168648012&quot;&gt;Scaling React Applications&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://www.smashingmagazine.com/2016/09/how-to-scale-react-applications/&quot;&gt;반응 응용 프로그램의 규모를 &lt;/a&gt;&lt;a href=&quot;https://vimeo.com/168648012&quot;&gt;조정 &lt;/a&gt;하는 방법 (토킹 : 반응 응용 프로그램 크기 조정 )</target>
        </trans-unit>
        <trans-unit id="8f14c153057f3e5ff2c682e211890c3c01452d71" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=j-kj2qwJa_E&quot;&gt;Developing ClojureScript with Figwheel&lt;/a&gt; for convincing me that re-evaluation should &amp;ldquo;just work&amp;rdquo;;</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=j-kj2qwJa_E&quot;&gt;&lt;/a&gt;재평가가 &quot;그냥 작동&quot;해야한다는 확신 을주기 위해 Figwheel을 사용하여 ClojureScript 개발 ;</target>
        </trans-unit>
        <trans-unit id="06d62e70b9137a15eb36c4bfaf278d14decfd6a4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=okdC5gcD-dM&quot;&gt;Redux: Simplifying Application State&lt;/a&gt; &amp;mdash; An intro to Redux architecture</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=okdC5gcD-dM&quot;&gt;Redux : 애플리케이션 상태 단순화&lt;/a&gt; &amp;mdash; Redux 아키텍처 소개</target>
        </trans-unit>
        <trans-unit id="ad10d1cb466100f8a4ae95925886bfea9a5588ad" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://www.youtube.com/watch?v=qUlRpybs7_c&quot;&gt;Cleaning the Tar: Using React within the Firefox Developer Tools&lt;/a&gt; &amp;mdash; Learn how to gradually migrate existing MVC applications to Redux</source>
          <target state="translated">&lt;a href=&quot;https://www.youtube.com/watch?v=qUlRpybs7_c&quot;&gt;Tar 정리 : Firefox 개발자 도구 내에서 React 사용&lt;/a&gt; &amp;mdash; 기존 MVC 애플리케이션을 점차적으로 Redux로 마이그레이션하는 방법에 대해 알아보십시오</target>
        </trans-unit>
        <trans-unit id="1b737ab7c1094f632e450d8432a9c9e16474bd23" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#async&quot;&gt;Async&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/async&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/async&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#async&quot;&gt;비동기&lt;/a&gt; ( &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/async&quot;&gt;소스&lt;/a&gt; , &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/async&quot;&gt;샌드 박스&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="34453405ef6fc18e6e87655693ec2a2bb89f30b0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#counter&quot;&gt;Counter&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/counter&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#counter&quot;&gt;카운터&lt;/a&gt; ( &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;소스&lt;/a&gt; , &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/counter&quot;&gt;샌드 박스&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="42b547e4f69fe31aac6b4dafd6e1ff2c05b103e3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#counter-vanilla&quot;&gt;Counter Vanilla&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#counter-vanilla&quot;&gt;카운터 바닐라&lt;/a&gt; ( &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter-vanilla&quot;&gt;소스&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="59a364d666ad866f057b55528bf8003b6e7a3980" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#real-world&quot;&gt;Real World&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/real-world&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/real-world&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#real-world&quot;&gt;실제 세계&lt;/a&gt; ( &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/real-world&quot;&gt;소스&lt;/a&gt; , &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/real-world&quot;&gt;샌드 박스&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="96efe2982c4c1669ba1a120bc8297246cc6203f9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#shopping-cart&quot;&gt;Shopping Cart&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#shopping-cart&quot;&gt;쇼핑 카트&lt;/a&gt; ( &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;소스&lt;/a&gt; , &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/shopping-cart&quot;&gt;샌드 박스&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="8eca3dbaee744d35d31909fa899561a59637eca0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#todomvc&quot;&gt;TodoMVC&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todomvc&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todomvc&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#todomvc&quot;&gt;TodoMVC&lt;/a&gt; ( &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todomvc&quot;&gt;소스&lt;/a&gt; , &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todomvc&quot;&gt;샌드 박스&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="57e7c6464db15c19011138bab173c2e287d2a6fe" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#todos&quot;&gt;Todos&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#todos&quot;&gt;할 일&lt;/a&gt; ( &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;source&lt;/a&gt; , &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos&quot;&gt;sandbox&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1ed13dde4ab11bda58a26439a12403c10a6ca595" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#todos-with-undo&quot;&gt;Todos with Undo&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#todos-with-undo&quot;&gt;실행 취소가있는 작업 관리&lt;/a&gt; ( &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;source&lt;/a&gt; , &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;sandbox&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="99bbfebce7fe9d012028712df4b3acc2554bdba1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#tree-view&quot;&gt;Tree View&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/tree-view&quot;&gt;source&lt;/a&gt;, &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/tree-view&quot;&gt;sandbox&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#tree-view&quot;&gt;트리 뷰&lt;/a&gt; ( &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/tree-view&quot;&gt;소스&lt;/a&gt; , &lt;a href=&quot;https://codesandbox.io/s/github/reactjs/redux/tree/master/examples/tree-view&quot;&gt;샌드 박스&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="87f056bfcb955f7740e3c0f64a948b832302b714" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;introduction/examples#universal&quot;&gt;Universal&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/universal&quot;&gt;source&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;introduction/examples#universal&quot;&gt;범용&lt;/a&gt; ( &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/universal&quot;&gt;소스&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="7c38888890f5f4205fd2f24afd87133d7819484f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;patrons&quot;&gt;See the full list of Redux patrons.&lt;/a&gt;, as well as the always-growing list of &lt;a href=&quot;https://github.com/reactjs/redux/issues/310&quot;&gt;people and companies that use Redux&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;patrons&quot;&gt;Redux 후원자의 전체 목록을 참조하십시오. &lt;/a&gt;&lt;a href=&quot;https://github.com/reactjs/redux/issues/310&quot;&gt;Redux를 사용하는 사람과 회사의&lt;/a&gt; 목록은 항상 증가 하고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e873131fc93496281859118adf805655ac8f12d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;...middleware&lt;/code&gt; (&lt;em&gt;arguments&lt;/em&gt;): Functions that conform to the Redux &lt;em&gt;middleware API&lt;/em&gt;. Each middleware receives &lt;a href=&quot;store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;store#getState&quot;&gt;&lt;code&gt;getState&lt;/code&gt;&lt;/a&gt; functions as named arguments, and returns a function. That function will be given the &lt;code&gt;next&lt;/code&gt; middleware's dispatch method, and is expected to return a function of &lt;code&gt;action&lt;/code&gt; calling &lt;code&gt;next(action)&lt;/code&gt; with a potentially different argument, or at a different time, or maybe not calling it at all. The last middleware in the chain will receive the real store's &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; method as the &lt;code&gt;next&lt;/code&gt; parameter, thus ending the chain. So, the middleware signature is &lt;code&gt;({ getState, dispatch }) =&amp;gt; next =&amp;gt; action&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;...middleware&lt;/code&gt; ( &lt;em&gt;인수&lt;/em&gt; ) : Redux &lt;em&gt;미들웨어 API&lt;/em&gt; 를 준수하는 &lt;em&gt;함수&lt;/em&gt; . 각 미들웨어는 &lt;a href=&quot;store&quot;&gt; &lt;code&gt;Store&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;store#getState&quot;&gt; &lt;code&gt;getState&lt;/code&gt; &lt;/a&gt; 함수를 명명 된 인수로 수신 하고 함수를 리턴합니다. 이 함수는 주어진 것이다 &lt;code&gt;next&lt;/code&gt; 미들웨어의 발송 방법을, 그리고 함수 반환 할 것으로 예상된다 &lt;code&gt;action&lt;/code&gt; 호출 &lt;code&gt;next(action)&lt;/code&gt; 잠재적으로 다른 인수, 또는 다른 시간에, 또는 어쩌면 전혀를 호출하지. 체인의 마지막 미들웨어 는 &lt;code&gt;next&lt;/code&gt; 과 같이 실제 상점의 &lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 방법을 수신합니다.체인을 종료합니다. 따라서 미들웨어 서명은 &lt;code&gt;({ getState, dispatch }) =&amp;gt; next =&amp;gt; action&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a14c94077eedb0b2bbe472c3d6a0d0b3e627f008" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;action&lt;/code&gt; (&lt;em&gt;Object&lt;/em&gt;&lt;sup&gt;&amp;dagger;&lt;/sup&gt;): A plain object describing the change that makes sense for your application. Actions are the only way to get data into the store, so any data, whether from the UI events, network callbacks, or other sources such as WebSockets needs to eventually be dispatched as actions. Actions must have a &lt;code&gt;type&lt;/code&gt; field that indicates the type of action being performed. Types can be defined as constants and imported from another module. It's better to use strings for &lt;code&gt;type&lt;/code&gt; than &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;Symbols&lt;/a&gt; because strings are serializable. Other than &lt;code&gt;type&lt;/code&gt;, the structure of an action object is really up to you. If you're interested, check out &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux Standard Action&lt;/a&gt; for recommendations on how actions could be constructed.</source>
          <target state="translated">&lt;code&gt;action&lt;/code&gt; ( &lt;em&gt;Object &lt;/em&gt;&lt;sup&gt;&amp;dagger;&lt;/sup&gt; ) : 응용 프로그램에 적합한 변경 사항을 설명하는 일반 개체입니다. 조치는 상점으로 데이터를 가져 오는 유일한 방법이므로 UI ​​이벤트, 네트워크 콜백 또는 WebSockets와 같은 기타 소스의 데이터를 조치로 전달해야합니다. 조치에는 수행중인 조치 유형을 나타내는 &lt;code&gt;type&lt;/code&gt; 필드가 있어야합니다 . 유형을 상수로 정의하고 다른 모듈에서 가져올 수 있습니다. 문자열은 직렬화 가능하므로 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;기호&lt;/a&gt; 보다 &lt;code&gt;type&lt;/code&gt; 문자열을 사용하는 것이 좋습니다 . &lt;code&gt;type&lt;/code&gt; 이외 의 액션 객체의 구조는 실제로 당신에게 달려 있습니다. 관심이 있다면 &lt;a href=&quot;https://github.com/acdlite/flux-standard-action&quot;&gt;Flux 표준 액션을&lt;/a&gt; 확인하십시오. 조치 구성 방법에 대한 권장 사항</target>
        </trans-unit>
        <trans-unit id="1f9170163c0ef5281c7dbedc853c03ad10d33e30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;actionCreators&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt; or &lt;em&gt;Object&lt;/em&gt;): An &lt;a href=&quot;../glossary#action-creator&quot;&gt;action creator&lt;/a&gt;, or an object whose values are action creators.</source>
          <target state="translated">&lt;code&gt;actionCreators&lt;/code&gt; ( &lt;em&gt;Function&lt;/em&gt; 또는 &lt;em&gt;Object&lt;/em&gt; ) : &lt;a href=&quot;../glossary#action-creator&quot;&gt;액션 생성자&lt;/a&gt; 또는 값이 액션 생성자 인 객체.</target>
        </trans-unit>
        <trans-unit id="3bd26650aa014fa2c77d3b47529964816520f847" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineReducers&lt;/code&gt; iterates through each of these key/value pairs. For each iteration, it:</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 는 이러한 각 키 / 값 쌍을 반복합니다. 각 반복마다 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c4c91341660edf136591696dc683b24608c892dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineReducers&lt;/code&gt; makes working with this style of structure easier by taking a &lt;code&gt;reducers&lt;/code&gt; argument that&amp;rsquo;s defined as a hash table comprising a set of key/value pairs, where each key is the name of a state slice, and the corresponding value is the reducer function that will act on it.</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 는 일련의 키 / 값 쌍으로 구성된 해시 테이블로 정의 된 &lt;code&gt;reducers&lt;/code&gt; 인수를 사용하여 이러한 스타일의 구조를보다 쉽게 ​​작업 할 수 있습니다 . 여기서 각 키는 상태 슬라이스의 이름이고 해당 값은 그것에 행동하십시오.</target>
        </trans-unit>
        <trans-unit id="4cb7dfb9552a2aace784e7bb958b5e547adeb025" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineReducers&lt;/code&gt; takes an object full of slice reducer functions, and creates a function that outputs a corresponding state object with the same keys. This means that if no preloaded state is provided to &lt;code&gt;createStore&lt;/code&gt;, the naming of the keys in the input slice reducer object will define the naming of the keys in the output state object. The correlation between these names is not always apparent, especially when using ES6 features such as default module exports and object literal shorthands.</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 는 슬라이스 감속기 기능으로 가득 찬 객체를 가져 와서 동일한 키로 해당 상태 객체를 출력하는 함수를 만듭니다. 즉 , &lt;code&gt;createStore&lt;/code&gt; 에 사전로드 된 상태가 제공되지 않으면 입력 슬라이스 감속기 객체의 키 이름이 출력 상태 객체의 키 이름을 정의합니다. 특히 기본 모듈 내보내기 및 객체 리터럴 축약과 같은 ES6 기능을 사용할 때 이러한 이름 간의 상관 관계가 항상 명확하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="1afff2e083a32e71d2b99b63e31beee97a7bf5a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;combineReducers&lt;/code&gt; will then return this new root state object to the store. The new object will have the same values as the current root state object, but because it's a different object, it will cause the store to be updated, which will ultimately cause all connected components to be re-rendered unnecessarily.</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 는이 새로운 루트 상태 객체를 상점에 반환합니다. 새 객체는 현재 루트 상태 객체와 동일한 값을 가지지 만, 객체가 다르기 때문에 저장소가 업데이트되어 연결된 모든 구성 요소가 불필요하게 다시 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="3d31c37d476a705be9d16ab99876f6f29a2911bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;completed: boolean&lt;/code&gt; is whether todo should appear crossed out.</source>
          <target state="translated">&lt;code&gt;completed: boolean&lt;/code&gt; 은 할 일이 교차로 표시되어야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="f87ab9b4028e9a3e848f1e21390753d01e0de961" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dispatch&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt;): A &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function available on the &lt;a href=&quot;store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;code&gt;dispatch&lt;/code&gt; ( &lt;em&gt;Function&lt;/em&gt; ) : &lt;a href=&quot;store&quot;&gt; &lt;code&gt;Store&lt;/code&gt; &lt;/a&gt; 인스턴스 에서 사용 가능한 &lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 기능 입니다.</target>
        </trans-unit>
        <trans-unit id="a6065950184dca89f8adacb36f987e88b944855d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filter: string&lt;/code&gt; is the visibility filter it represents.</source>
          <target state="translated">&lt;code&gt;filter: string&lt;/code&gt; 은 그것이 나타내는 가시성 필터입니다.</target>
        </trans-unit>
        <trans-unit id="9c642488e3cbd80e5e05acd841612af9ec636679" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;listener&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt;): The callback to be invoked any time an action has been dispatched, and the state tree might have changed. You may call &lt;a href=&quot;#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; inside this callback to read the current state tree. It is reasonable to expect that the store's reducer is a pure function, so you may compare references to some deep path in the state tree to learn whether its value has changed.</source>
          <target state="translated">&lt;code&gt;listener&lt;/code&gt; ( &lt;em&gt;Function&lt;/em&gt; ) : 액션이 디스패치 될 때마다 호출되는 콜백이며 상태 트리가 변경되었을 수 있습니다. 이 콜백 안에서 &lt;a href=&quot;#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt; 호출 하여 현재 상태 트리를 읽을 수 있습니다 . 상점의 리듀서가 순수한 기능이라고 기대하는 것이 합리적이므로 상태 트리의 일부 딥 경로와 참조를 비교하여 값이 변경되었는지 여부를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60274854b8fc4c1adc45a0ccb85c9a471e84a06a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onClick()&lt;/code&gt; is a callback to invoke when a todo is clicked.</source>
          <target state="translated">&lt;code&gt;onClick()&lt;/code&gt; 은 할 일을 클릭 할 때 호출 할 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="3cabc66d0691eba5e97140d97c5af0c9e8160ca5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onClick()&lt;/code&gt; is a callback to invoke when link is clicked.</source>
          <target state="translated">&lt;code&gt;onClick()&lt;/code&gt; 은 링크를 클릭 할 때 호출 할 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="041c016fc6813b17f1192148484f830acd43af01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onTodoClick(id: number)&lt;/code&gt; is a callback to invoke when a todo is clicked.</source>
          <target state="translated">&lt;code&gt;onTodoClick(id: number)&lt;/code&gt; 은 할 일을 클릭 할 때 호출되는 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="fbcbab3611a4b8e613b2b4cd09f9c1e9fb3baffe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt; property is an object with every param specified in the url. &lt;em&gt;e.g: &lt;code&gt;params&lt;/code&gt; will be equal to &lt;code&gt;{ filter: 'SHOW_COMPLETED' }&lt;/code&gt; if we are navigating to &lt;code&gt;localhost:3000/SHOW_COMPLETED&lt;/code&gt;. We can now read the URL from &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; 속성은 URL에 지정된 모든 매개 변수가있는 객체입니다. &lt;em&gt;예 : &lt;code&gt;localhost:3000/SHOW_COMPLETED&lt;/code&gt; 로 이동하는 경우 &lt;code&gt;params&lt;/code&gt; 는 &lt;code&gt;{ filter: 'SHOW_COMPLETED' }&lt;/code&gt; 와 같습니다 . 이제 &lt;code&gt;&amp;lt;App /&amp;gt;&lt;/code&gt; 에서 URL을 읽을 수 있습니다 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57c2d7b03d06140fe6460c00b3e6ecceb3671905" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;props&lt;/code&gt; can be passed to &lt;code&gt;getVisibleTodos&lt;/code&gt; from &lt;code&gt;mapStateToProps&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;props&lt;/code&gt; 전달 될 수 &lt;code&gt;getVisibleTodos&lt;/code&gt; 에서 &lt;code&gt;mapStateToProps&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="10c4b65f91bd45a4fc2fd57806ac6f36f1219c00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react-router&lt;/code&gt; is available on npm . This guides assumes you are using &lt;code&gt;react-router@^2.7.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;react-router&lt;/code&gt; 는 npm에서 사용할 수 있습니다. 이 안내서에서는 &lt;code&gt;react-router@^2.7.0&lt;/code&gt; 을 사용한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="a1634dcd7c4b99901d4395c7f2e41abeb6383d21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reducer&lt;/code&gt; (&lt;em&gt;Function&lt;/em&gt;) The next reducer for the store to use.</source>
          <target state="translated">&lt;code&gt;reducer&lt;/code&gt; ( &lt;em&gt;기능&lt;/em&gt; ) 상점에서 사용할 다음 리듀서.</target>
        </trans-unit>
        <trans-unit id="7c54c07a7b5f3ced1e0ad2afedb5ec66a8340b8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reducer&lt;/code&gt;&lt;em&gt;(Function)&lt;/em&gt;: A &lt;a href=&quot;../glossary#reducer&quot;&gt;reducing function&lt;/a&gt; that returns the next &lt;a href=&quot;../glossary#state&quot;&gt;state tree&lt;/a&gt;, given the current state tree and an &lt;a href=&quot;../glossary#action&quot;&gt;action&lt;/a&gt; to handle.</source>
          <target state="translated">&lt;code&gt;reducer&lt;/code&gt; &lt;em&gt;(함수)&lt;/em&gt; : 현재 상태 트리와 처리 할 &lt;a href=&quot;../glossary#action&quot;&gt;조치&lt;/a&gt; 가 주어지면 다음 &lt;a href=&quot;../glossary#state&quot;&gt;상태 트리&lt;/a&gt; 를 반환 하는 &lt;a href=&quot;../glossary#reducer&quot;&gt;축소 함수&lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="d247728fbc49f91b9cff3325a75f4fc504af79e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reducers&lt;/code&gt; (&lt;em&gt;Object&lt;/em&gt;): An object whose values correspond to different reducing functions that need to be combined into one. See the notes below for some rules every passed reducer must follow.</source>
          <target state="translated">&lt;code&gt;reducers&lt;/code&gt; ( &lt;em&gt;Object&lt;/em&gt; ) : 값을 하나로 결합해야하는 다른 축소 기능에 해당하는 값을 갖는 객체입니다. 통과 된 모든 감속기가 따라야하는 규칙에 대해서는 아래 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="071297430dead4ef02608be9950bc0295007dab6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;text: string&lt;/code&gt; is the text to show.</source>
          <target state="translated">&lt;code&gt;text: string&lt;/code&gt; 은 표시 할 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="6601fc4649e95805e9085e851baecfbd9ca422e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toJS()&lt;/code&gt; is an expensive function and negates the purpose of using Immutable.JS. Avoid its use.</source>
          <target state="translated">&lt;code&gt;toJS()&lt;/code&gt; 는 값 비싼 함수이며 Immutable.JS를 사용하는 목적을 무시 합니다. 사용을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="dd5ee50dffe4060b939c67419ae23402ff2acb67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;todos: Array&lt;/code&gt; is an array of todo items with &lt;code&gt;{ id, text, completed }&lt;/code&gt; shape.</source>
          <target state="translated">&lt;code&gt;todos: Array&lt;/code&gt; 은 &lt;code&gt;{ id, text, completed }&lt;/code&gt; 모양을 가진 할 일 항목의 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="52137cb27c8b0fda0f705acc5c2ab7d8fc83ac69" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(any)&lt;/em&gt;: The current state tree of your application.</source>
          <target state="translated">&lt;em&gt;(any)&lt;/em&gt; : 응용 프로그램의 현재 상태 트리</target>
        </trans-unit>
        <trans-unit id="546eefda4ace04ce1c70ef03ebe11baee59caa52" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;App state&lt;/em&gt;: data that is specific to the application's behavior (such as &quot;Todo #5 is currently selected&quot;, or &quot;there is a request in progress to fetch Todos&quot;)</source>
          <target state="translated">&lt;em&gt;응용 프로그램 상태&lt;/em&gt; : 응용 프로그램 동작과 관련된 데이터 (예 : &quot;Todo # 5가 현재 선택되어 있거나&quot;또는 &quot;Todos를 가져 오기 위해 진행중인 요청이 있습니다&quot;)</target>
        </trans-unit>
        <trans-unit id="c8b84d5c7e9792f8e68b0e853bd33475fc3cf76b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do not put API calls into reducers.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;리듀서에 API 호출을 넣지 마십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7b7c7ebbf9d9f5dafd8f0eb2d9dee6e376c7e325" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Domain data&lt;/em&gt;: data that the application needs to show, use, or modify (such as &quot;all of the Todos retrieved from the server&quot;)</source>
          <target state="translated">&lt;em&gt;도메인 데이터&lt;/em&gt; : 응용 프로그램이 표시, 사용 또는 수정해야하는 데이터 (예 : &quot;서버에서 검색된 모든 작업 관리&quot;)</target>
        </trans-unit>
        <trans-unit id="103bdb5aaf028813664904c0a9712c441ff4dc83" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;In addition, using &lt;code&gt;toJS&lt;/code&gt; in a Higher Order Component should not cause much, if any, performance degradation, as the component will only be called when the connected component&amp;rsquo;s props change. As with any performance issue, conduct performance checks first before deciding what to optimise.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;또한 상위 컴포넌트에서 &lt;code&gt;toJS&lt;/code&gt; 를 사용 하면 연결된 컴포넌트의 소품이 변경 될 때만 컴포넌트가 호출되므로 성능 저하가 발생하지 않아야합니다. 성능 문제와 마찬가지로, 최적화 대상을 결정하기 전에 먼저 성능 점검을 수행하십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29f56da89fe63f5b0fdf50e9b3857e6d4e807205" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Reducers whose initial state is populated using &lt;code&gt;preloadedState&lt;/code&gt; will &lt;strong&gt;still need to provide a default value&lt;/strong&gt; to handle when passed a &lt;code&gt;state&lt;/code&gt; of &lt;code&gt;undefined&lt;/code&gt;. All reducers are passed &lt;code&gt;undefined&lt;/code&gt; on initialization, so they should be written such that when given &lt;code&gt;undefined&lt;/code&gt;, some value should be returned. This can be any non-&lt;code&gt;undefined&lt;/code&gt; value; there's no need to duplicate the section of &lt;code&gt;preloadedState&lt;/code&gt; here as the default.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : &lt;code&gt;preloadedState&lt;/code&gt; 를 사용하여 초기 상태가 채워진 감속기 는 &lt;strong&gt;여전히 &lt;/strong&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;code&gt;state&lt;/code&gt; 를 전달할 때 처리 할 &lt;strong&gt;기본값을 제공해야합니다&lt;/strong&gt; . 모든 리듀서는 초기화시 &lt;code&gt;undefined&lt;/code&gt; 로 전달 되므로 &lt;code&gt;undefined&lt;/code&gt; 를 지정 하면 일부 값이 반환 되도록 작성 해야합니다. 이것은 &lt;code&gt;undefined&lt;/code&gt; 값일 수 있습니다 . &lt;code&gt;preloadedState&lt;/code&gt; 섹션을 기본값 으로 복제 할 필요가 없습니다 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29ccd8f599d654d3c1988dcb7203039733cc9621" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: if your app requires high performance, you may need to avoid &lt;code&gt;toJS()&lt;/code&gt; altogether, and so will have to use Immutable.JS in your dumb components. However, for most apps this will not be the case, and the benefits of keeping Immutable.JS out of your dumb components (maintainability, portability and easier testing) will far outweigh any perceived performance improvements of keeping it in.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : 앱에 고성능이 필요한 경우 &lt;code&gt;toJS()&lt;/code&gt; 를 피해야 할 수도 있으므로 바보 구성 요소에 Immutable.JS를 사용해야합니다. 그러나 대부분의 앱에서는 그렇지 않으며, 멍청한 구성 요소 (유지 관리, 이식성 및 쉬운 테스트)에서 Immutable.JS를 유지하면 얻을 수있는 성능 향상보다 훨씬 뛰어납니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5abce7fc4fc891211f9c2137610c7e67cd852170" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;React Router Redux&lt;/em&gt; creates a binding between your redux app and react-router and it keeps them in sync. Without this binding, you will not be able to rewind the actions with Time Travel. Unless you need this, React Router and Redux can operate completely apart.</source>
          <target state="translated">&lt;em&gt;React Router Redux&lt;/em&gt; 는 redux 앱과 반응 라우터 사이에 바인딩을 생성하여 동기화 상태를 유지합니다. 이 바인딩이 없으면 Time Travel으로 작업을 되 감을 수 없습니다. 이것이 필요하지 않으면 React Router와 Redux는 완전히 분리되어 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db05ad144fe5ebf42ad286bef8f68f32d9f005f6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Redux Router&lt;/em&gt; is an experimental library, it lets you keep entirely the state of your URL inside your redux store. It has the same API with React Router API but has a smaller community support than react-router.</source>
          <target state="translated">&lt;em&gt;Redux Router&lt;/em&gt; 는 실험용 라이브러리이므로 URL의 상태를 전적으로 redux 저장소에 유지할 수 있습니다. React Router API와 동일한 API를 가지고 있지만 반응 라우터보다 작은 커뮤니티 지원이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f76be52041957c10fa3ece1ff9a6500b8a7f3130" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;State&lt;/em&gt; (also called the &lt;em&gt;state tree&lt;/em&gt;) is a broad term, but in the Redux API it usually refers to the single state value that is managed by the store and returned by &lt;a href=&quot;api/store#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt;. It represents the entire state of a Redux application, which is often a deeply nested object.</source>
          <target state="translated">&lt;em&gt;State&lt;/em&gt; ( &lt;em&gt;상태 트리&lt;/em&gt; 라고도 함 )는 광범위한 용어이지만 Redux API에서는 일반적으로 상점에서 관리하고 &lt;a href=&quot;api/store#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt; 반환하는 단일 상태 값을 나타냅니다 . Redux 응용 프로그램의 전체 상태를 나타내며 종종 중첩 된 객체입니다.</target>
        </trans-unit>
        <trans-unit id="85e8d43be73f1edbce45221c84c8c093b0749d2c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;UI state&lt;/em&gt;: data that represents how the UI is currently displayed (such as &quot;The EditTodo modal dialog is currently open&quot;)</source>
          <target state="translated">&lt;em&gt;UI 상태&lt;/em&gt; : UI가 현재 표시되는 방식을 나타내는 데이터 (예 : &quot;EditTodo 모달 대화 상자가 현재 열려 있습니다&quot;)</target>
        </trans-unit>
        <trans-unit id="3bf81a4c713219d00d15e705d738b32facd1c3ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt; Discussions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; Discussions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9845432ee2811761e6bcff4526db436968becae2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://egghead.io/courses/building-react-applications-with-idiomatic-redux&quot;&gt;Part 2: Building React Applications with Idiomatic Redux&lt;/a&gt; (27 free videos)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://egghead.io/courses/building-react-applications-with-idiomatic-redux&quot;&gt;2 부 : 관용 Redux를 사용한 반응 형 응용 프로그램 빌드&lt;/a&gt; (27 개의 무료 비디오)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dfdd52a88d7f6ae78b01e354f352bfb2f0dff656" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Getting Started with Redux&lt;/a&gt;&lt;/strong&gt; &amp;mdash; Learn the basics of Redux directly from its creator (30 free videos)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Redux 시작하기&lt;/a&gt;&lt;/strong&gt; &amp;mdash; 제작자로부터 직접 Redux의 기본 사항을 배웁니다 (30 개의 무료 비디오)</target>
        </trans-unit>
        <trans-unit id="1235adb50ceb12211d0e304f950e2cb2539aca3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;Part 1: Getting Started with Redux&lt;/a&gt; (30 free videos)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://egghead.io/series/getting-started-with-redux&quot;&gt;1 부 : Redux 시작하기&lt;/a&gt; (30 개의 무료 비디오)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="65008044925d251beee2e760bdbf7d352cad495e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://learnredux.com&quot;&gt;Learn Redux&lt;/a&gt;&lt;/strong&gt; &amp;mdash; Build a simple photo app that will simplify the core ideas behind Redux, React Router and React.js</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://learnredux.com&quot;&gt;Redux 알아보기&lt;/a&gt;&lt;/strong&gt; &amp;mdash; Redux, React Router 및 React.js의 핵심 아이디어를 단순화하는 간단한 사진 앱을 구축하십시오.</target>
        </trans-unit>
        <trans-unit id="7f4ac2e2def8c3f5a536a05b0329a56f22f7adbd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367&quot;&gt;You Might Not Need Redux&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367&quot;&gt;Redux가 필요하지 않을 수 있습니다&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="46d385341a00466471baf6bf0402c35cb513b738" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;AddTodo&lt;/code&gt;&lt;/strong&gt; is an input field with an &amp;ldquo;Add&amp;rdquo; button</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;AddTodo&lt;/code&gt; &lt;/strong&gt; 는&amp;ldquo;추가&amp;rdquo;버튼이있는 입력 필드입니다</target>
        </trans-unit>
        <trans-unit id="628abe199572c722710292d70c1925abc91676dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;App&lt;/code&gt;&lt;/strong&gt; is the root component that renders everything else.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;App&lt;/code&gt; &lt;/strong&gt; 은 다른 모든 것을 렌더링하는 루트 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="0d7b3701bac16523885d284f75957faf7ea4389c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;FilterLink&lt;/code&gt;&lt;/strong&gt; gets the current visibility filter and renders a &lt;code&gt;Link&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;FilterLink&lt;/code&gt; &lt;/strong&gt; 는 현재 가시성 필터를 가져 와서 &lt;code&gt;Link&lt;/code&gt; 를 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="a71acf6c031a4f24eed213eed02c5416da7ab1dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Footer&lt;/code&gt;&lt;/strong&gt; is where we let the user change currently visible todos.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Footer&lt;/code&gt; &lt;/strong&gt; 은 사용자가 현재 볼 수있는 할 일을 변경할 수있는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="5e4d8ed2a6c4ce299050d24a32e6f7c64862715e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/strong&gt; is a link with a callback.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Link&lt;/code&gt; &lt;/strong&gt; 는 콜백이있는 링크입니다.</target>
        </trans-unit>
        <trans-unit id="c81649898f991e4665328250d8eea26cc2edbc98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Todo&lt;/code&gt;&lt;/strong&gt; is a single todo item.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Todo&lt;/code&gt; &lt;/strong&gt; 일은 하나의 할일 항목입니다.</target>
        </trans-unit>
        <trans-unit id="e2f96f74e7301539bacf1f9c6bd718980a2d9daf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;TodoList&lt;/code&gt;&lt;/strong&gt; is a list showing visible todos.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;TodoList&lt;/code&gt; &lt;/strong&gt; 는 보이는&lt;strong&gt; 할일을&lt;/strong&gt; 보여주는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="72ec9d638aa6d81f7ef6d2682f120d0fd13ab2a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;VisibleTodoList&lt;/code&gt;&lt;/strong&gt; filters the todos according to the current visibility filter and renders a &lt;code&gt;TodoList&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;VisibleTodoList&lt;/code&gt; &lt;/strong&gt; 는 현재 가시성 필터에 따라 할 일을 필터링하고 &lt;code&gt;TodoList&lt;/code&gt; 를 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="b7d0712239a704041ee112eaeba6a14ab513b61e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Using local component state is fine&lt;/em&gt;&lt;/strong&gt;. As a developer, it is &lt;em&gt;your&lt;/em&gt; job to determine what kinds of state make up your application, and where each piece of state should live. Find a balance that works for you, and go with it.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;로컬 구성 요소 상태를 사용하는 것이&lt;/em&gt;&lt;/strong&gt; 좋습니다. 개발자는어떤 종류의 상태가 애플리케이션을 구성하고 각 상태가 어디에 위치해야하는지 결정하는것이&lt;em&gt; 귀하의&lt;/em&gt; 임무입니다. 당신에게 맞는 균형을 찾아서 가십시오.</target>
        </trans-unit>
        <trans-unit id="5889d668f635907ed9dfa122cde5a199a20be785" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;case function&lt;/em&gt;&lt;/strong&gt;: a function that is being used to handle the update logic for a specific action. This may actually be a reducer function, or it may require other parameters to do its work properly.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;case function&lt;/em&gt;&lt;/strong&gt; : 특정 조치에 대한 업데이트 논리를 처리하는 데 사용되는 함수입니다. 실제로 감속기 기능 일 수도 있고 올바르게 작동하려면 다른 매개 변수가 필요할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6e0dfdc33c924359812aab966fcb011eaef8e7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;higher-order reducer&lt;/em&gt;&lt;/strong&gt;: a function that takes a reducer function as an argument, and/or returns a new reducer function as a result (such as &lt;code&gt;combineReducers&lt;/code&gt;, or &lt;code&gt;redux-undo&lt;/code&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;고차 감속기&lt;/em&gt;&lt;/strong&gt; : 감속기 함수를 인수로 사용하거나 새로운 감속기 함수를 결과로 반환하는 함수 (예 : &lt;code&gt;combineReducers&lt;/code&gt; 또는 &lt;code&gt;redux-undo&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="401ed42d073adeb6ecd950168ad981e271a2b5a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;reducer&lt;/em&gt;&lt;/strong&gt;: any function with the signature &lt;code&gt;(state, action) -&amp;gt; newState&lt;/code&gt; (ie, any function that &lt;em&gt;could&lt;/em&gt; be used as an argument to &lt;code&gt;Array.prototype.reduce&lt;/code&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;reducer&lt;/em&gt;&lt;/strong&gt; : 서명이있는 함수 &lt;code&gt;(state, action) -&amp;gt; newState&lt;/code&gt; (즉, &lt;code&gt;Array.prototype.reduce&lt;/code&gt; 의 인수로 사용할&lt;em&gt; 수&lt;/em&gt; 있는함수)</target>
        </trans-unit>
        <trans-unit id="f9b0e566a3672de250a1434def164d63af6cba98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;root reducer&lt;/em&gt;&lt;/strong&gt;: the reducer function that is actually passed as the first argument to &lt;code&gt;createStore&lt;/code&gt;. This is the only part of the reducer logic that &lt;em&gt;must&lt;/em&gt; have the &lt;code&gt;(state, action) -&amp;gt; newState&lt;/code&gt; signature.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;루트 리듀서&lt;/em&gt;&lt;/strong&gt; : 실제로 &lt;code&gt;createStore&lt;/code&gt; 에 첫 번째 인수로 전달되는 리듀서 함수. 이 감속기 로직의 일부에 불과&lt;em&gt; 합니다&lt;/em&gt; 이 &lt;code&gt;(state, action) -&amp;gt; newState&lt;/code&gt; 서명.</target>
        </trans-unit>
        <trans-unit id="0a64e360c4d5878942159990e891828399749146" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;slice reducer&lt;/em&gt;&lt;/strong&gt;: a reducer that is being used to handle updates to one specific slice of the state tree, usually done by passing it to &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;슬라이스 감속기&lt;/em&gt;&lt;/strong&gt; : 상태 트리의 특정 특정 슬라이스에 대한 업데이트를 처리하는 데 사용되는 감속기이며, 일반적으로 &lt;code&gt;combineReducers&lt;/code&gt; 에 전달하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2551e86cf6417db6bf5798c49bdf5292397b5d4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Action creators&lt;/strong&gt; are exactly that&amp;mdash;functions that create actions. It's easy to conflate the terms &amp;ldquo;action&amp;rdquo; and &amp;ldquo;action creator,&amp;rdquo; so do your best to use the proper term.</source>
          <target state="translated">&lt;strong&gt;액션 제작자&lt;/strong&gt; 는 바로 &lt;strong&gt;액션&lt;/strong&gt; 을 만드는 기능입니다. &quot;action&quot;과 &quot;action creator&quot;라는 용어를 쉽게 혼동 할 수 있으므로 올바른 용어를 사용하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1da8e22fc9c738da2f9e48212ed18a6dba30b50c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Actions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Actions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19d9668859b20c765c85260461deb4090e7c90c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Actions&lt;/strong&gt; are payloads of information that send data from your application to your store. They are the &lt;em&gt;only&lt;/em&gt; source of information for the store. You send them to the store using &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;조치&lt;/strong&gt; 는 애플리케이션에서 상점으로 데이터를 보내는 정보의 페이로드입니다. 그들은있는 &lt;em&gt;유일한&lt;/em&gt; 상점에 대한 정보의 소스. &lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch()&lt;/code&gt; &lt;/a&gt; 사용하여 상점으로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="ec2a8e7b602c9f54e206267bc8541a8f186454fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Also read:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;또한 읽어보십시오 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39113b04f672edb3817c5d406408774e2e082af0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An action informing the reducers that the request began.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;리듀서에게 요청이 시작되었음을 알리는 조치.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="994001ceb8ce97cddf25a8c05987ea9c83e99a47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An action informing the reducers that the request failed.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;리듀서에게 요청이 실패했음을 알리는 조치입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7648023b0f97bbd162694c4bb9ebb7f2898c3bca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;An action informing the reducers that the request finished successfully.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;리듀서에게 요청이 성공적으로 완료되었음을 알리는 작업.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="990d6bce9d1a24f59b9efaf18dc81a2290c580f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Articles&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Articles&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e169e5d7d50b4c65d5eb45d17d2193a3d3fe48c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But there is a problem!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그러나 문제가 있습니다!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="69b54c7910d861b8a3eca842a30a66fd0932de39" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Chrome Extension&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;크롬 확장&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80cf8bc624de85df678b42470029fc4d69f07a66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Code Structure&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;코드 구조&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3318cdef256aecde044aa8d93fc255bf75f49a52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Discussion&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Discussion&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="41fc516c487bc5c3b496e3bd45dc251647980f5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Discussions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Discussions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9a56caeef5914fb0e23b98d65cf00abd25d9b22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Documentation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Documentation&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce3f4a409dc0c67054a7e806ad3eecf69f742f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c3d140c8e464f134cec3b0eebd38bf683f55d62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Examples&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Examples&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c28df48234b0e1020c84b073dd49644f35f59ab0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Finally, you can write your own middleware.&lt;/strong&gt; Let's say you want to generalize the pattern above and describe your async action creators like this instead:</source>
          <target state="translated">&lt;strong&gt;마지막으로 자신 만의 미들웨어를 작성할 수 있습니다. &lt;/strong&gt;위의 패턴을 일반화하고 대신 비동기 액션 생성자를 설명한다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="e850b9ecbb25492de24c73963c25bba203a9b8f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;General&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;General&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a426959f751e24e2f5918ae148f99e35ec8ec248" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Gists&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Gists&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b835ddfaad1c3b1909f0f1f8838c00992cdebd9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If the &lt;code&gt;mapStateToProps&lt;/code&gt; argument supplied to &lt;code&gt;connect&lt;/code&gt; returns a function instead of an object, it will be used to create an individual &lt;code&gt;mapStateToProps&lt;/code&gt; function for each instance of the container.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;는 IF &lt;code&gt;mapStateToProps&lt;/code&gt; 인수에 공급 &lt;code&gt;connect&lt;/code&gt; 객체 대신 반환하는 함수를, 개인 만드는 데 사용됩니다 &lt;code&gt;mapStateToProps&lt;/code&gt; 이 컨테이너의 각 인스턴스에 대해 작동합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3529f38f1732dd9f8dde4fa1c2954e730482cd3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Immutable Data&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;불변의 데이터&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f813b4dc0b9eb9217d5b61ec52b5ac9f1ef177d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In general, &lt;code&gt;preloadedState&lt;/code&gt; wins over the state specified by the reducer. This lets reducers specify initial data that makes sense &lt;em&gt;to them&lt;/em&gt; as default arguments, but also allows loading existing data (fully or partially) when you're hydrating the store from some persistent storage or the server.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;일반적으로 &lt;code&gt;preloadedState&lt;/code&gt; 는 감속기에 의해 지정된 상태보다 우선합니다. 이를 통해 리듀서 는 기본 인수로 의미 &lt;em&gt;가있는&lt;/em&gt; 초기 데이터를 지정할 수 있지만 일부 영구 스토리지 또는 서버에서 상점을 수화 할 때 기존 데이터를 완전히 또는 부분적으로로드 할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="630d2928116ed006d43b0e103005e502467a2bd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Concepts&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;주요 개념&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="177d318924b7fa70e3cefd19afe9a19a2e28bd31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key concepts&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;주요 개념&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="af40680dea48a4f1aadecc6d0a580f293be76302" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Learn Redux from its creator:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;제작자로부터 Redux를 배우십시오 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="24d8f44e0ff187836ea30a46af3fa4eae82a5814" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Libraries&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Libraries&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="40f69f52a2524079b625a242912cdd7403598e0d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Middleware lets us write more expressive, potentially async action creators.&lt;/strong&gt; It lets us dispatch something other than plain objects, and interprets the values. For example, middleware can &amp;ldquo;catch&amp;rdquo; dispatched Promises and turn them into a pair of request and success/failure actions.</source>
          <target state="translated">&lt;strong&gt;미들웨어를 사용하면보다 표현력 있고 잠재적으로 비동기적인 액션 제작자를 작성할 수 있습니다. &lt;/strong&gt;일반 객체 이외의 것을 전달하고 값을 해석 할 수 있습니다. 예를 들어 미들웨어는 디스패치 된 약속을 &quot;잡아&quot;요청 및 성공 / 실패 조치 쌍으로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8714d9061814fc6644471ebf65e80673c74fbf2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Miscellaneous&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Miscellaneous&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9aba37422ce93d442e229cdf88aefd1289e7a0ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that each of these reducers is managing its own part of the global state. The &lt;code&gt;state&lt;/code&gt; parameter is different for every reducer, and corresponds to the part of the state it manages.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 감속기 각각은 글로벌 상태의 자체 부분을 관리합니다. &lt;code&gt;state&lt;/code&gt; 파라미터마다 감속기 다르고,이 관리 상태의 일부분에 대응한다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="428baf6d60cd9f08dad452710b2d0853a0611819" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this example is deliberately written in a verbose style in order to illustrate the concepts and the process of refactoring, rather than perfectly concise code.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 예제는 코드를 완벽하게 간결하게하지 않고 개념과 리팩토링 프로세스를 설명하기 위해 의도적으로 장황하게 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="5cbd86caa1de0f5ed851d50bc59d467e542c9b43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Organizing State&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;조직 상태&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="48bf5499e3ac63560ca0e0106a29021adb072bfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Performance&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5467c8d8afabc0b3e1dae4c2485529c53412f57a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;React Redux&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;리덕스 반응&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6a646a6010d9b1f0d5fd5b00988f7164e7d8f806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reading List&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;읽기 목록&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="f87ea91cacfbae403f6d54b8d0956ef3fc4100f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reading list&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;읽기 목록&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="026e47e10ea129bc5e718a865b1c71228f70d1f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reducers&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Reducers&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="463c2d07ea9bf2ad77b66d873753301b6924a007" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Redux doesn't care &lt;em&gt;how&lt;/em&gt; you store the state&amp;mdash;it can be a plain object, an Immutable object, or anything else.&lt;/strong&gt; You'll probably want a (de)serialization mechanism for writing universal apps and hydrating their state from the server, but other than that, you can use any data storage library &lt;em&gt;as long as it supports immutability&lt;/em&gt;. For example, it doesn't make sense to use Backbone for Redux state, because Backbone models are mutable.</source>
          <target state="translated">&lt;strong&gt;Redux는 상태를 저장하는 &lt;em&gt;방법에&lt;/em&gt; 신경 쓰지 않습니다 . 일반 객체, 불변 객체 또는 기타 다른 객체가 될 수 있습니다. &lt;/strong&gt;범용 앱을 작성하고 서버에서 상태를 수화하기위한 (직렬화) 직렬화 메커니즘을 원할 것입니다. 그러나 그 외에는 &lt;em&gt;불변성을 지원&lt;/em&gt; 하는 한 모든 데이터 스토리지 라이브러리 &lt;em&gt;를&lt;/em&gt; 사용할 수 있습니다 . 예를 들어, 백본 모델은 변경 가능하므로 Redux 상태에 백본을 사용하는 것은 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f99c682875e5330991bcf2249db3e897d5de6b10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Store Setup&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;매장 설정&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6adf27317bc0760c4fef5a11f3e4243d9c2dea6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &lt;a href=&quot;../glossary#state&quot;&gt;state&lt;/a&gt; of your whole application is stored in an object tree within a single &lt;a href=&quot;../glossary#store&quot;&gt;store&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;전체 응용 프로그램 의 &lt;a href=&quot;../glossary#state&quot;&gt;상태&lt;/a&gt; 는 단일 &lt;a href=&quot;../glossary#store&quot;&gt;저장소&lt;/a&gt; 내의 개체 트리에 저장 됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4155b94bfe17bf25fe0157204c773ff981821e3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Redux store calls the reducer function you gave it.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Redux 스토어는 사용자가 제공 한 감속기 기능을 호출합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3830df7c81157ba8c707d873fd73f6f0cdb0f81e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Redux store saves the complete state tree returned by the root reducer.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Redux 저장소는 루트 리듀서가 반환 한 전체 상태 트리를 저장합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f7aa48ecb73dff1c83c59ee1b15f802da34287b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The only way to change the state is to emit an &lt;a href=&quot;../glossary#action&quot;&gt;action&lt;/a&gt;, an object describing what happened.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;상태를 변경하는 유일한 방법은 발생한 일을 설명하는 객체 인 &lt;a href=&quot;../glossary#action&quot;&gt;action&lt;/a&gt; 을 내보내는 것입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b9c9a991ab2ae928e8e00868d0eba489d79e40a9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The root reducer may combine the output of multiple reducers into a single state tree.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;루트 리듀서는 여러 리듀서의 출력을 단일 상태 트리로 결합 할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6e49059d9b4193d453aca3973e78f45f15c2c3d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is exactly what Redux middleware looks like.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이것이 바로 Redux 미들웨어의 모습입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76be9cf756727c3afc31669a1734af0a6b6997c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To specify how the state tree is transformed by actions, you write pure &lt;a href=&quot;../glossary#reducer&quot;&gt;reducers&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;조치에 의해 상태 트리가 변환되는 방법을 지정하려면 순수 &lt;a href=&quot;../glossary#reducer&quot;&gt;리듀서&lt;/a&gt; 를 작성하십시오 .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5ef565370cf3245efa7f66d5b780fcb67eebf3a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using Immutable.JS with Redux&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Redux와 함께 Immutable.JS 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="581be5c9a50c413f04d51268170098e3b7d44abb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Video&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Video&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e7086101439d0140de8af057ae87cdfb81255c2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We don't mutate the &lt;code&gt;state&lt;/code&gt;.&lt;/strong&gt; We create a copy with &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign()&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;Object.assign(state, { visibilityFilter: action.filter })&lt;/code&gt; is also wrong: it will mutate the first argument. You &lt;strong&gt;must&lt;/strong&gt; supply an empty object as the first parameter. You can also enable the &lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt; to write &lt;code&gt;{ ...state, ...newState }&lt;/code&gt; instead.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;state&lt;/code&gt; 를 변경하지 않습니다 . &lt;/strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign()&lt;/code&gt; &lt;/a&gt; 사용하여 복사본을 만듭니다 . &lt;code&gt;Object.assign(state, { visibilityFilter: action.filter })&lt;/code&gt; 도 잘못되었습니다. 첫 번째 인수를 변경합니다. 당신은 &lt;strong&gt;있어야합니다&lt;/strong&gt; 첫 번째 매개 변수로 빈 객체를 제공합니다. 또한 &lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;객체 스프레드 연산자 제안서&lt;/a&gt; 가 &lt;code&gt;{ ...state, ...newState }&lt;/code&gt; 를 작성하도록 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ee5f2fe633882a55b56c42023653a1999e34048" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;We return the previous &lt;code&gt;state&lt;/code&gt; in the &lt;code&gt;default&lt;/code&gt; case.&lt;/strong&gt; It's important to return the previous &lt;code&gt;state&lt;/code&gt; for any unknown action.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;default&lt;/code&gt; &lt;code&gt;state&lt;/code&gt; 에서는 이전 상태 를 반환합니다 . &lt;/strong&gt;알려지지 않은 조치에 대해 이전 &lt;code&gt;state&lt;/code&gt; 를 리턴하는 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="e435f9e093dd6f82c9230b9232861cf3d23f3321" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You call&lt;/strong&gt;&lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch(action)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch(action)&lt;/code&gt; &lt;/a&gt;&lt;strong&gt; 호출&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="3f4e7a77e49b844e6d09e31eed53faed808efc94" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&amp;dagger;&lt;/sup&gt; The &amp;ldquo;vanilla&amp;rdquo; store implementation you get by calling &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; only supports plain object actions and hands them immediately to the reducer.</source>
          <target state="translated">&lt;sup&gt;&amp;dagger; &lt;/sup&gt;&lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; &lt;/a&gt; 를 호출하여 얻을 수있는 &quot;vanilla&quot;저장소 구현 은 일반 개체 작업 만 지원하고이를 감속기로 즉시 전달합니다.</target>
        </trans-unit>
        <trans-unit id="70c279ff6853909cda37bddfb350ceef56e21365" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;dispatching function&lt;/em&gt; (or simply &lt;em&gt;dispatch function&lt;/em&gt;) is a function that accepts an action or an &lt;a href=&quot;#async-action&quot;&gt;async action&lt;/a&gt;; it then may or may not dispatch one or more actions to the store.</source>
          <target state="translated">&lt;em&gt;디스패치 기능&lt;/em&gt; (또는 단순히 &lt;em&gt;디스패치 기능&lt;/em&gt; ) 동작 또는 허용하는 기능이다 &lt;a href=&quot;#async-action&quot;&gt;비동기 작업&lt;/a&gt; ; 그런 다음 하나 이상의 조치를 상점에 디스패치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec526b8fa830efd01fb591e76b77adf20e29497" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;reducer enhancer&lt;/em&gt; (or a &lt;em&gt;higher order reducer&lt;/em&gt;) is a function that takes a reducer, and returns a new reducer that is able to handle new actions, or to hold more state, delegating control to the inner reducer for the actions it doesn't understand. This isn't a new pattern&amp;mdash;technically, &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; is also a reducer enhancer because it takes reducers and returns a new reducer.</source>
          <target state="translated">&lt;em&gt;감속기 증강&lt;/em&gt; (또는 &lt;em&gt;고차 감속기는&lt;/em&gt; ) 감속기를 취하는 함수이며, 새로운 액션을 처리하기 위해, 또는 그렇지 않은 행동에 대한 내부 감속기로 제어를 위임 더 많은 상태를 유지 할 수있는 새로운 감속기를 반환 이해하다. 이것은 새로운 패턴이 아닙니다. 기술적으로도, &lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt; 는 감속기를 가져 와서 새로운 감속기를 반환하기 때문에 감속기입니다.</target>
        </trans-unit>
        <trans-unit id="54f6e31c957bc32bf7205d27b105533b64b11e59" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;reducer&lt;/em&gt; (also called a &lt;em&gt;reducing function&lt;/em&gt;) is a function that accepts an accumulation and a value and returns a new accumulation. They are used to reduce a collection of values down to a single value.</source>
          <target state="translated">&lt;em&gt;감속기&lt;/em&gt; (도 불리는 &lt;em&gt;감소 함수&lt;/em&gt; )를 축적 값을 받아 새로운 축적을 반환하는 함수이다. 이들은 값 모음을 단일 값으로 줄이는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9eba9d63a46e1040299343c1cba8ee39cab099e4" translate="yes" xml:space="preserve">
          <source>A Better File Structure for React/Redux Applications</source>
          <target state="translated">React / Redux 애플리케이션을위한보다 나은 파일 구조</target>
        </trans-unit>
        <trans-unit id="bd0db97b3caad08800e67bceba3655a16a4f42cb" translate="yes" xml:space="preserve">
          <source>A Case for setState</source>
          <target state="translated">setState의 경우</target>
        </trans-unit>
        <trans-unit id="58c12a94fc1ee1fe47d7abe792ff5a9b7def031d" translate="yes" xml:space="preserve">
          <source>A Deep Dive into React Perf Debugging</source>
          <target state="translated">성능 디버깅 디버깅에 대한 심층 분석</target>
        </trans-unit>
        <trans-unit id="0c5b0d4140e816f05523e9bb1e2dcd4ec9a913dc" translate="yes" xml:space="preserve">
          <source>A Note for Flux Users</source>
          <target state="translated">플럭스 사용자를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="779923a9da175253b9122887cfa0972c4cb74e6e" translate="yes" xml:space="preserve">
          <source>A Note on Mixing ES6 Modules and CommonJS</source>
          <target state="translated">ES6 모듈과 CommonJS 혼합에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="db41c4cd245302803e94359aaa69cba0b0f06284" translate="yes" xml:space="preserve">
          <source>A Redux state usually has a plain Javascript object as the top of the state tree. (It is certainly possible to have another type of data instead, such as a single number, an array, or a specialized data structure, but most libraries assume that the top-level value is a plain object.) The most common way to organize data within that top-level object is to further divide data into sub-trees, where each top-level key represents some &quot;domain&quot; or &quot;slice&quot; of related data. For example, a basic Todo app's state might look like:</source>
          <target state="translated">Redux 상태에는 일반적으로 상태 트리의 맨 위에 일반 Javascript 객체가 있습니다. (단일 숫자, 배열 또는 특수한 데이터 구조와 같은 다른 유형의 데이터를 대신 사용할 수는 있지만 대부분의 라이브러리는 최상위 값이 일반 객체라고 가정합니다.) 해당 최상위 개체 내의 데이터는 하위 트리로 데이터를 추가로 분할하는 것입니다. 여기서 각 최상위 키는 관련 데이터의 &quot;도메인&quot;또는 &quot;슬라이스&quot;를 나타냅니다. 예를 들어, 기본 Todo 앱의 상태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c95746f061e18147c8c2a55d13555d7725bb143b" translate="yes" xml:space="preserve">
          <source>A better usage might look like:</source>
          <target state="translated">더 나은 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b48f874d11bc5b272adec4dc58721d09af5d10c0" translate="yes" xml:space="preserve">
          <source>A cartoon intro to Redux</source>
          <target state="translated">Redux에 대한 만화 소개</target>
        </trans-unit>
        <trans-unit id="e9bf7de4be37a17f5d19505f713bd1be6f33e3ac" translate="yes" xml:space="preserve">
          <source>A deep dive into Clojure&amp;rsquo;s data structures</source>
          <target state="translated">Clojure의 데이터 구조에 대해 자세히 알아보기</target>
        </trans-unit>
        <trans-unit id="0451b576bd71ffbe13c32dc53912051fc439260e" translate="yes" xml:space="preserve">
          <source>A different useful transformation that comes to my mind is reporting JavaScript errors in production. The global &lt;code&gt;window.onerror&lt;/code&gt; event is not reliable because it doesn't provide stack information in some older browsers, which is crucial to understand why an error is happening.</source>
          <target state="translated">내 생각에 다른 유용한 변형은 프로덕션에서 JavaScript 오류를보고하는 것입니다. 전역 &lt;code&gt;window.onerror&lt;/code&gt; 이벤트는 일부 구형 브라우저에서 스택 정보를 제공하지 않기 때문에 신뢰할 수 없습니다. 이는 오류가 발생하는 이유를 이해하는 데 중요합니다.</target>
        </trans-unit>
        <trans-unit id="1e4484c12f25bb46be91193117c01544958d6300" translate="yes" xml:space="preserve">
          <source>A good first step might be to break out a utility function to return a new object with updated fields. There's also a repeated pattern with trying to update a specific item in an array that we could extract to a function:</source>
          <target state="translated">좋은 첫 번째 단계는 업데이트 된 필드가있는 새 객체를 반환하기 위해 유틸리티 함수를 분리하는 것입니다. 함수에서 추출 할 수있는 배열의 특정 항목을 업데이트하려고 시도하는 반복 된 패턴도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9a086635bdf1493f65c3720a831f2e56113ebce" translate="yes" xml:space="preserve">
          <source>A list of many immutable update utilities can be found in the &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links/blob/master/immutable-data.md#immutable-update-utilities&quot;&gt;Immutable Data#Immutable Update Utilities&lt;/a&gt; section of the &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Addons Catalog&lt;/a&gt;.</source>
          <target state="translated">많은 불변 업데이트 유틸리티의 목록은 &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Addons Catalog&lt;/a&gt; 의 &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links/blob/master/immutable-data.md#immutable-update-utilities&quot;&gt;불변 데이터 # 불변 업데이트 유틸리티&lt;/a&gt; 섹션 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c5180d4d6c3b37f40d01a33af1b0f3baa180c07" translate="yes" xml:space="preserve">
          <source>A memoized selector can itself be an input-selector to another memoized selector. Here is &lt;code&gt;getVisibleTodos&lt;/code&gt; being used as an input-selector to a selector that further filters the todos by keyword:</source>
          <target state="translated">메모 선택기는 자체적으로 다른 메모 선택기에 대한 입력 선택 기일 수 있습니다. 다음은 키워드로 할 일을 추가로 필터링하는 선택기에 대한 입력 선택기로 사용되는 &lt;code&gt;getVisibleTodos&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="1715344fa5f33e240f9d1d585beffe859e05b0df" translate="yes" xml:space="preserve">
          <source>A middleware is a higher-order function that composes a &lt;a href=&quot;#dispatching-function&quot;&gt;dispatch function&lt;/a&gt; to return a new dispatch function. It often turns &lt;a href=&quot;#async-action&quot;&gt;async actions&lt;/a&gt; into actions.</source>
          <target state="translated">미들웨어는 새로운 디스패치 함수를 리턴 하기 위해 &lt;a href=&quot;#dispatching-function&quot;&gt;디스패치 함수&lt;/a&gt; 를 구성하는 고차 함수입니다 . 종종 &lt;a href=&quot;#async-action&quot;&gt;비동기 동작&lt;/a&gt; 을 동작 으로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="81b81652bf02ff7bf772129a812fc4e04bf51ded" translate="yes" xml:space="preserve">
          <source>A nice thing about React components is that they are usually small and only rely on their props. That makes them easy to test.</source>
          <target state="translated">React 컴포넌트의 좋은 점은 보통 컴포넌트가 작고 소품에만 의존한다는 것입니다. 따라서 테스트하기가 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="66c5775c8d40ff721fc8d112637246b185d62e5b" translate="yes" xml:space="preserve">
          <source>A popular convention is to name reducers after the state slices they manage, so you can use ES6 property shorthand notation: &lt;code&gt;combineReducers({ counter, todos })&lt;/code&gt;. This is equivalent to writing &lt;code&gt;combineReducers({ counter: counter, todos: todos })&lt;/code&gt;.</source>
          <target state="translated">널리 사용되는 규칙은 리듀서가 관리하는 상태 조각 다음에 이름을 지정하는 것입니다. 따라서 ES6 속성 속기 표기법 &lt;code&gt;combineReducers({ counter, todos })&lt;/code&gt; 있습니다. 이것은 &lt;code&gt;combineReducers({ counter: counter, todos: todos })&lt;/code&gt; 를 쓰는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6142fea1802b9d891098496555324f048dfc4ab1" translate="yes" xml:space="preserve">
          <source>A reducer enhancer that combines other reducers might look like this:</source>
          <target state="translated">다른 감속기를 결합한 감속기 향상 기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85855b61915007bb41ecf73529b533adae4a769a" translate="yes" xml:space="preserve">
          <source>A reducer enhancer that doesn't do anything looks like this:</source>
          <target state="translated">아무것도하지 않는 감속기 향상 기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e2848c8d31433a5257b89be2c33d6bbc13ce44e" translate="yes" xml:space="preserve">
          <source>A reducer should return the new state after applying the action to the previous state, and that's the behavior tested below.</source>
          <target state="translated">동작을 이전 상태에 적용한 후 감속기가 새 상태를 반환해야합니다. 이것이 아래 테스트 된 동작입니다.</target>
        </trans-unit>
        <trans-unit id="ce6bc5c6b208bc72c706a97b8ea7f4de3a455d2c" translate="yes" xml:space="preserve">
          <source>A selector created with &lt;code&gt;createSelector&lt;/code&gt; only returns the cached value when its set of arguments is the same as its previous set of arguments. If we alternate between rendering &lt;code&gt;&amp;lt;VisibleTodoList listId=&quot;1&quot; /&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;VisibleTodoList listId=&quot;2&quot; /&amp;gt;&lt;/code&gt;, the shared selector will alternate between receiving &lt;code&gt;{listId: 1}&lt;/code&gt; and &lt;code&gt;{listId: 2}&lt;/code&gt; as its &lt;code&gt;props&lt;/code&gt; argument. This will cause the arguments to be different on each call, so the selector will always recompute instead of returning the cached value. We'll see how to overcome this limitation in the next section.</source>
          <target state="translated">&lt;code&gt;createSelector&lt;/code&gt; 로 작성된 선택기 는 인수 세트가 이전 인수 세트와 동일한 경우에만 캐시 된 값을 리턴합니다. &lt;code&gt;&amp;lt;VisibleTodoList listId=&quot;1&quot; /&amp;gt;&lt;/code&gt; 렌더링 과 &lt;code&gt;&amp;lt;VisibleTodoList listId=&quot;2&quot; /&amp;gt;&lt;/code&gt; 렌더링을 번갈아 가면 공유 선택기는 &lt;code&gt;props&lt;/code&gt; 인수 로 &lt;code&gt;{listId: 1}&lt;/code&gt; 과 &lt;code&gt;{listId: 2}&lt;/code&gt; 를 번갈아 가면서 번갈아 표시 합니다. 이렇게하면 호출마다 인수가 달라 지므로 선택기는 캐시 된 값을 반환하는 대신 항상 다시 계산합니다. 다음 섹션에서이 제한을 극복하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="d7fdd19e31d4aa5c08f59368d084b0cdd3afe5c5" translate="yes" xml:space="preserve">
          <source>A shallow equality check is therefore as simple (and as fast) as &lt;code&gt;a === b&lt;/code&gt;, whereas a deep equality check involves a recursive traversal through the properties of two objects, comparing the value of each property at each step.</source>
          <target state="translated">따라서 얕은 동등성 검사는 &lt;code&gt;a === b&lt;/code&gt; 만큼 간단하고 빠릅니다 . 반면, 동등성 검사는 두 단계의 속성을 통한 재귀 순회를 포함하여 각 단계에서 각 속성의 값을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="8bba7fd75614daa0e3f257e0f35cbfa400838a5b" translate="yes" xml:space="preserve">
          <source>A store creator is a function that creates a Redux store. Like with dispatching function, we must distinguish the base store creator, &lt;a href=&quot;api/createstore&quot;&gt;&lt;code&gt;createStore(reducer, preloadedState)&lt;/code&gt;&lt;/a&gt; exported from the Redux package, from store creators that are returned from the store enhancers.</source>
          <target state="translated">상점 작성자는 Redux 상점을 작성하는 기능입니다. 디스패치 기능과 마찬가지로 , Redux 패키지에서 내 보낸 기본 상점 작성자 인 &lt;a href=&quot;api/createstore&quot;&gt; &lt;code&gt;createStore(reducer, preloadedState)&lt;/code&gt; &lt;/a&gt; 와 상점 인핸서에서 리턴 된 상점 작성자를 구별해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0498b8c765baf0d793d01093c2d3938c7acad2d2" translate="yes" xml:space="preserve">
          <source>A store enhancer is a higher-order function that composes a store creator to return a new, enhanced store creator. This is similar to middleware in that it allows you to alter the store interface in a composable way.</source>
          <target state="translated">상점 개량제는 상점 작성기를 작성하여 새롭고 향상된 상점 작성기를 리턴하는 고차 함수입니다. 이는 상점 인터페이스를 컴포저 블 방식으로 변경할 수 있다는 점에서 미들웨어와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="80ff26cb12d9ecc5ea599ca905718232908db10a" translate="yes" xml:space="preserve">
          <source>A store holds the whole &lt;a href=&quot;../glossary#state&quot;&gt;state tree&lt;/a&gt; of your application.</source>
          <target state="translated">상점은 애플리케이션 의 전체 &lt;a href=&quot;../glossary#state&quot;&gt;상태 트리&lt;/a&gt; 를 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="db90563ef06aad2359ba2b820d66958cfae253aa" translate="yes" xml:space="preserve">
          <source>A store is an object that holds the application's state tree.</source>
          <target state="translated">저장소는 응용 프로그램의 상태 트리를 보유하는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="8139366b65a6efd49fd2de96e65c9cf4f80822d2" translate="yes" xml:space="preserve">
          <source>A store is not a class. It's just an object with a few methods on it.</source>
          <target state="translated">상점은 수업이 아닙니다. 몇 가지 방법이있는 객체 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="1dd2226f91b259d8b3ba9075e912f9f1b756eb73" translate="yes" xml:space="preserve">
          <source>A third approach would be to use the reducer generated by &lt;code&gt;combineReducers&lt;/code&gt; to handle the &quot;simple&quot; cases where each slice reducer can update itself independently, but also use another reducer to handle the &quot;special&quot; cases where data needs to be shared across slices. Then, a wrapping function could call both of those reducers in turn to generate the final result:</source>
          <target state="translated">세 번째 방법은 &lt;code&gt;combineReducers&lt;/code&gt; 에 의해 생성 된 리듀서를 사용하여 각 슬라이스 리듀서가 독립적으로 업데이트 될 수있는 &quot;단순한&quot;사례를 처리하고 다른 리듀서를 사용하여 데이터가 슬라이스간에 공유되어야하는 &quot;특별한&quot;사례를 처리하는 것입니다. 그런 다음 줄 바꿈 함수는 두 감속기를 모두 호출하여 최종 결과를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a29a2d5178bbb1dcd22edfd2b4d56832e62a760" translate="yes" xml:space="preserve">
          <source>A typical app's state shape might look roughly like:</source>
          <target state="translated">일반적인 앱의 상태 모양은 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dd7f5eb9f1f3f2372ac3b7d3fc72f9fa655d209b" translate="yes" xml:space="preserve">
          <source>A typical application will likely have a mixture of relational data and non-relational data. While there is no single rule for exactly how those different types of data should be organized, one common pattern is to put the relational &quot;tables&quot; under a common parent key, such as &quot;entities&quot;. A state structure using this approach might look like:</source>
          <target state="translated">일반적인 응용 프로그램에는 관계형 데이터와 비 관계형 데이터가 혼합되어있을 수 있습니다. 서로 다른 유형의 데이터를 구성하는 방법에 대한 단일 규칙은 없지만 공통적 인 패턴 중 하나는 관계형 &quot;테이블&quot;을 &quot;엔터티&quot;와 같은 공통 상위 키 아래에 두는 것입니다. 이 접근법을 사용하는 상태 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="b276f94cd8d0e74a21de6e5939b8c10ca9a975d6" translate="yes" xml:space="preserve">
          <source>API Reference</source>
          <target state="translated">API 참조</target>
        </trans-unit>
        <trans-unit id="f0682f7888392082612529e79e90a8568fdf278b" translate="yes" xml:space="preserve">
          <source>API: React-Redux&amp;rsquo;s connect function and &lt;code&gt;mapStateToProps&lt;/code&gt;</source>
          <target state="translated">API : React-Redux의 연결 기능 및 &lt;code&gt;mapStateToProps&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01b79cd36dd33f71f26f84428e7993c489d7d7b4" translate="yes" xml:space="preserve">
          <source>API: Store</source>
          <target state="translated">API : 상점</target>
        </trans-unit>
        <trans-unit id="e0c9492b063857505209dc57c11cd7626823a1e5" translate="yes" xml:space="preserve">
          <source>API: applyMiddleware</source>
          <target state="translated">API : applyMiddleware</target>
        </trans-unit>
        <trans-unit id="933d49b5bdf3528c648138b4bc997b3bd1ee051d" translate="yes" xml:space="preserve">
          <source>API: combineReducers</source>
          <target state="translated">API : combineReducers</target>
        </trans-unit>
        <trans-unit id="3e2257d3cbebe55ab5120cd90126477209348170" translate="yes" xml:space="preserve">
          <source>Accessing React Props in Selectors</source>
          <target state="translated">선택기에서 반응 소품에 액세스</target>
        </trans-unit>
        <trans-unit id="7b3702d1af5b6f51067a97e15b727d6bb1e395e0" translate="yes" xml:space="preserve">
          <source>Accidental Object Mutation</source>
          <target state="translated">우연한 객체 돌연변이</target>
        </trans-unit>
        <trans-unit id="a3bcac5b1b8316670488ac51d4cfe888b1904b8d" translate="yes" xml:space="preserve">
          <source>Accidentally mutating or modifying your state directly is by far the most common reason why components do not re-render after an action has been dispatched. Redux expects that your reducers will update their state &amp;ldquo;immutably&amp;rdquo;, which effectively means always making copies of your data, and applying your changes to the copies. If you return the same object from a reducer, Redux assumes that nothing has been changed, even if you made changes to its contents. Similarly, React Redux tries to improve performance by doing shallow equality reference checks on incoming props in &lt;code&gt;shouldComponentUpdate&lt;/code&gt;, and if all references are the same, returns &lt;code&gt;false&lt;/code&gt; to skip actually updating your original component.</source>
          <target state="translated">실수로 상태를 직접 변경하거나 수정 한 것은 액션이 전달 된 후 컴포넌트가 다시 렌더링되지 않는 가장 일반적인 이유입니다. Redux는 리듀서가 상태를 &quot;불변으로&quot;업데이트 할 것으로 예상합니다. 이는 항상 데이터 사본을 만들고 사본에 변경 사항을 적용하는 것을 의미합니다. 감속기에서 동일한 객체를 반환하면 Redux는 내용을 변경하더라도 변경된 내용이 없다고 가정합니다. 마찬가지로 React Redux는 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 에서 들어오는 소품에 대해 얕은 동등 참조 검사를 수행하여 성능을 개선하려고 시도하고 모든 참조가 동일하면 원래 구성 요소를 실제로 업데이트하지 않고 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ededef69001678f2e3f055f1fda34f301acb3bdc" translate="yes" xml:space="preserve">
          <source>Accordingly, &lt;code&gt;combineReducers&lt;/code&gt; will not set its &lt;code&gt;hasChanged&lt;/code&gt; flag, even though the state has changed. If none of the other reducers return a new, updated state slice, the &lt;code&gt;hasChanged&lt;/code&gt; flag will remain set to false, causing &lt;code&gt;combineReducers&lt;/code&gt; to return the &lt;em&gt;existing&lt;/em&gt; root state object.</source>
          <target state="translated">따라서 &lt;code&gt;combineReducers&lt;/code&gt; 는 상태가 변경 되었어도 &lt;code&gt;hasChanged&lt;/code&gt; 플래그를 설정하지 않습니다 . 다른 리듀서가 업데이트 된 새로운 상태 슬라이스를 반환하지 않으면 &lt;code&gt;hasChanged&lt;/code&gt; 플래그가 false로 유지되어 &lt;code&gt;combineReducers&lt;/code&gt; 가 &lt;em&gt;기존&lt;/em&gt; 루트 상태 객체 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4a9938fccff603464933303296454dffcb6d16f1" translate="yes" xml:space="preserve">
          <source>Accordingly, calling &lt;code&gt;toJS()&lt;/code&gt; twice, for example, and assigning the result to two different variables will cause an equality check on those two variables to fail, even though the object values themselves haven&amp;rsquo;t changed.</source>
          <target state="translated">따라서 예를 들어 &lt;code&gt;toJS()&lt;/code&gt; 두 번 호출 하고 결과를 두 개의 다른 변수에 할당하면 객체 값 자체가 변경되지 않았더라도 두 변수에 대한 동등 검사가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="97c89a4d6630adeb18fa12ba9976a31413fe293e" translate="yes" xml:space="preserve">
          <source>Action</source>
          <target state="translated">Action</target>
        </trans-unit>
        <trans-unit id="240f485623391e5c1075e5725ad30c67ed287ffe" translate="yes" xml:space="preserve">
          <source>Action Creator</source>
          <target state="translated">액션 크리에이터</target>
        </trans-unit>
        <trans-unit id="41b6c7e08efa20fb3393d8ac535f3d3c740a070d" translate="yes" xml:space="preserve">
          <source>Action Creators</source>
          <target state="translated">액션 크리에이터</target>
        </trans-unit>
        <trans-unit id="0ec85940f13d4f2b78e391b686bbb091564ba03e" translate="yes" xml:space="preserve">
          <source>Action Creators and Constants</source>
          <target state="translated">액션 제작자와 상수</target>
        </trans-unit>
        <trans-unit id="a119c0a9e7c1a3dda7791541c11f9924b37c7992" translate="yes" xml:space="preserve">
          <source>Action creators can also be asynchronous and have side-effects. You can read about &lt;a href=&quot;../advanced/asyncactions&quot;&gt;async actions&lt;/a&gt; in the &lt;a href=&quot;../advanced/index&quot;&gt;advanced tutorial&lt;/a&gt; to learn how to handle AJAX responses and compose action creators into async control flow. Don't skip ahead to async actions until you've completed the basics tutorial, as it covers other important concepts that are prerequisite for the advanced tutorial and async actions.</source>
          <target state="translated">액션 제작자는 비동기식이며 부작용이있을 수 있습니다. &lt;a href=&quot;../advanced/index&quot;&gt;고급 학습서&lt;/a&gt; 에서 &lt;a href=&quot;../advanced/asyncactions&quot;&gt;비동기 조치&lt;/a&gt; 에 대해 읽고 AJAX 응답을 처리하고 조치 작성자를 비동기 제어 플로우로 작성하는 방법을 배울 수 있습니다. 기본 학습서를 완료 할 때까지 고급 학습 및 비동기 작업에 필요한 다른 중요한 개념을 다루므로 비동기 작업으로 넘어 가지 마십시오.</target>
        </trans-unit>
        <trans-unit id="38b2a78d2a362985ab2383462db85f699d11a8bc" translate="yes" xml:space="preserve">
          <source>Action creators have often been criticized as boilerplate. Well, you don't have to write them! &lt;strong&gt;You can use object literals if you feel this better suits your project.&lt;/strong&gt; There are, however, some benefits for writing action creators you should know about.</source>
          <target state="translated">액션 제작자는 종종 상용구로 비난을받습니다. 글쎄, 당신은 그들을 쓸 필요가 없습니다! &lt;strong&gt;이것이 프로젝트에 더 적합하다고 생각되면 객체 리터럴을 사용할 수 있습니다. &lt;/strong&gt;그러나 알아야 할 액션 제작자를 작성하면 몇 가지 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3cd636a585b20c40ac2df5ffb403e83cb2eef51" translate="yes" xml:space="preserve">
          <source>Actions</source>
          <target state="translated">Actions</target>
        </trans-unit>
        <trans-unit id="e8ae9384ae9248e5ddbc032e08b2557629723918" translate="yes" xml:space="preserve">
          <source>Actions are plain JavaScript objects. Actions must have a &lt;code&gt;type&lt;/code&gt; property that indicates the type of action being performed. Types should typically be defined as string constants. Once your app is large enough, you may want to move them into a separate module.</source>
          <target state="translated">액션은 일반 JavaScript 객체입니다. 작업에는 수행중인 작업 유형을 나타내는 &lt;code&gt;type&lt;/code&gt; 속성이 있어야합니다 . 유형은 일반적으로 문자열 상수로 정의해야합니다. 앱이 충분히 크면 별도의 모듈로 옮기고 싶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29c6835b1a6b3824f0c14c55211c697ec783ced1" translate="yes" xml:space="preserve">
          <source>Actions are plain objects describing what happened in the app, and serve as the sole way to describe an intention to mutate the data. It's important that &lt;strong&gt;actions being objects you have to dispatch is not boilerplate, but one of the &lt;a href=&quot;../introduction/threeprinciples&quot;&gt;fundamental design choices&lt;/a&gt; of Redux&lt;/strong&gt;.</source>
          <target state="translated">액션은 앱에서 발생한 일을 설명하는 평범한 객체이며 데이터를 변경하려는 의도를 설명하는 유일한 방법입니다. &lt;strong&gt;디스패치해야하는 객체가&lt;a href=&quot;../introduction/threeprinciples&quot;&gt;&lt;/a&gt;&lt;/strong&gt; 되는 &lt;strong&gt;작업은 상용구가 아니라 &lt;/strong&gt;&lt;strong&gt;Redux &lt;/strong&gt;&lt;strong&gt;의 &lt;/strong&gt;&lt;strong&gt;기본 디자인 선택&lt;/strong&gt;&lt;strong&gt; 중 하나 &lt;/strong&gt;&lt;strong&gt;여야&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7d61d75382f4f34d26d503abba6068279c8ea603" translate="yes" xml:space="preserve">
          <source>Actions look like this:</source>
          <target state="translated">동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59ec7f0f4e16258c3a0d1d14cd731f00efda02b1" translate="yes" xml:space="preserve">
          <source>Actions must have a &lt;code&gt;type&lt;/code&gt; field that indicates the type of action being performed. Types can be defined as constants and imported from another module. It's better to use strings for &lt;code&gt;type&lt;/code&gt; than &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;Symbols&lt;/a&gt; because strings are serializable.</source>
          <target state="translated">조치에는 수행중인 조치 유형을 나타내는 &lt;code&gt;type&lt;/code&gt; 필드가 있어야합니다 . 유형을 상수로 정의하고 다른 모듈에서 가져올 수 있습니다. 문자열은 직렬화 가능하므로 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;기호&lt;/a&gt; 보다 &lt;code&gt;type&lt;/code&gt; 문자열을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="88de3a2870fc9eb038ea75c3422acc4a151defa3" translate="yes" xml:space="preserve">
          <source>Adding the Buttons</source>
          <target state="translated">버튼 추가</target>
        </trans-unit>
        <trans-unit id="c737672ab2cc3d4caaa793fa73dc88d6e8d45119" translate="yes" xml:space="preserve">
          <source>Additionally, as we are using ES6 and JSX syntax, we will need to compile with &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; (see &lt;a href=&quot;https://github.com/babel/example-node-server&quot;&gt;this example of a Node Server with Babel&lt;/a&gt;) and the &lt;a href=&quot;https://babeljs.io/docs/plugins/preset-react/&quot;&gt;React preset&lt;/a&gt;.</source>
          <target state="translated">또한 ES6 및 JSX 구문을 사용하므로 &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; ( Babel &lt;a href=&quot;https://github.com/babel/example-node-server&quot;&gt;이있는 노드 서버 예제&lt;/a&gt; 참조 ) 및 &lt;a href=&quot;https://babeljs.io/docs/plugins/preset-react/&quot;&gt;React 사전 설정&lt;/a&gt; 으로 컴파일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="18596de4375fc946c5b097f81e74982a60e9c894" translate="yes" xml:space="preserve">
          <source>Adds a change listener. It will be called any time an action is dispatched, and some part of the state tree may potentially have changed. You may then call &lt;a href=&quot;#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt; to read the current state tree inside the callback.</source>
          <target state="translated">변경 리스너를 추가합니다. 액션이 전달 될 때마다 호출되며 상태 트리의 일부가 변경되었을 수 있습니다. 그런 다음 &lt;a href=&quot;#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 콜백 내의 현재 상태 트리를 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d064726954a17487f94e931f5b157b733ec22ed" translate="yes" xml:space="preserve">
          <source>Advanced</source>
          <target state="translated">Advanced</target>
        </trans-unit>
        <trans-unit id="16857f7bab141f13aed36aec58498499bddb6833" translate="yes" xml:space="preserve">
          <source>Advanced: Async Actions</source>
          <target state="translated">고급 : 비동기 작업</target>
        </trans-unit>
        <trans-unit id="025dce227eca0ed35e21358aac9e6536fedf70ed" translate="yes" xml:space="preserve">
          <source>Advanced: Async Flow</source>
          <target state="translated">고급 : 비동기 흐름</target>
        </trans-unit>
        <trans-unit id="35f20532e3af1b93336b6e71dbaacd3a2435abd0" translate="yes" xml:space="preserve">
          <source>Advanced: Middleware</source>
          <target state="translated">고급 : 미들웨어</target>
        </trans-unit>
        <trans-unit id="25069391f8b74b286f02804c1347be029afe7715" translate="yes" xml:space="preserve">
          <source>After passing it once to &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware(...middlewares)&lt;/code&gt;&lt;/a&gt;, you can write all your API-calling action creators the same way:</source>
          <target state="translated">&lt;a href=&quot;../api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware(...middlewares)&lt;/code&gt; &lt;/a&gt; 한 번 전달한 후 모든 API 호출 액션 생성자를 같은 방식으로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53e43e635db37f09dab8f6423d79953c28e59e8e" translate="yes" xml:space="preserve">
          <source>After the iterations have completed, &lt;code&gt;combineReducers&lt;/code&gt; will check the state of the &lt;code&gt;hasChanged&lt;/code&gt; flag. If it&amp;rsquo;s true, the newly-constructed state object will be returned. If it&amp;rsquo;s false, the &lt;em&gt;current&lt;/em&gt; state object is returned.</source>
          <target state="translated">반복이 완료된 후 &lt;code&gt;combineReducers&lt;/code&gt; 는 &lt;code&gt;hasChanged&lt;/code&gt; 플래그 의 상태를 점검합니다 . 참이면 새로 구성된 상태 객체가 반환됩니다. False이면 &lt;em&gt;현재&lt;/em&gt; 상태 개체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fc595812793ab6bb9b28c25bb6e33f011754ef4a" translate="yes" xml:space="preserve">
          <source>Again, it's important to understand that Redux reducers are &lt;em&gt;just&lt;/em&gt; functions. While &lt;code&gt;combineReducers&lt;/code&gt; is useful, it's just one tool in the toolbox. Functions can contain conditional logic other than switch statements, functions can be composed to wrap each other, and functions can call other functions. Maybe you need one of your slice reducers to be able to reset its state, and to only respond to specific actions overall. You could do:</source>
          <target state="translated">다시, Redux 감속기는 &lt;em&gt;단지&lt;/em&gt; 기능 이라는 것을 이해하는 것이 중요 합니다. &lt;code&gt;combineReducers&lt;/code&gt; 가 유용 하지만 도구 상자에있는 도구 중 하나 일뿐입니다. 함수는 switch 문 이외의 조건부 논리를 포함 할 수 있으며, 서로를 감싸도록 함수를 구성 할 수 있으며, 함수는 다른 함수를 호출 할 수 있습니다. 상태를 재설정하고 전체적으로 특정 작업에만 응답하려면 슬라이스 감속기 중 하나가 필요할 수 있습니다. 당신은 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b948d24fd1c5855cef6418255f90cedfe918ce37" translate="yes" xml:space="preserve">
          <source>Again, this is just a mock API, so we use &lt;code&gt;setTimeout&lt;/code&gt; to simulate a network request that takes 500 milliseconds to respond (this should be much faster with a real world API). We pass in a callback that returns a random number asynchronously. If you're using a Promise-based API client, then you would issue this callback in your &lt;code&gt;then&lt;/code&gt; handler.</source>
          <target state="translated">다시 말하지만 이것은 모의 API 일 뿐이므로 &lt;code&gt;setTimeout&lt;/code&gt; 을 사용 하여 응답하는 데 500 밀리 초가 걸리는 네트워크 요청을 시뮬레이션 합니다 (실제 API 로는 훨씬 빠릅니다). 임의의 숫자를 비동기 적으로 반환하는 콜백을 전달합니다. Promise 기반 API 클라이언트를 사용하는 경우 &lt;code&gt;then&lt;/code&gt; 핸들러 에서이 콜백을 발행 합니다.</target>
        </trans-unit>
        <trans-unit id="79aa101c36a75c4f0aa52bd08ce3b2d8cdc7f9d8" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; does is generate a function that calls your reducers &lt;strong&gt;with the slices of state selected according to their keys&lt;/strong&gt;, and combining their results into a single object again. &lt;a href=&quot;https://github.com/reactjs/redux/issues/428#issuecomment-129223274&quot;&gt;It's not magic.&lt;/a&gt; And like other reducers, &lt;code&gt;combineReducers()&lt;/code&gt; does not create a new object if all of the reducers provided to it do not change state.</source>
          <target state="translated">모든 &lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt; 는 &lt;strong&gt;키에 따라 선택된 상태 조각으로&lt;/strong&gt; 감속기를 호출 하고 결과를 단일 객체로 다시 결합 하는 함수를 생성 합니다. &lt;a href=&quot;https://github.com/reactjs/redux/issues/428#issuecomment-129223274&quot;&gt;마법이 아닙니다. &lt;/a&gt;다른 리듀서와 마찬가지로, &lt;code&gt;combineReducers()&lt;/code&gt; 는 제공된 모든 리듀서가 상태를 변경하지 않으면 새 객체를 만들지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbeeac1b96757e9c7e7b9ce98e03b49b2143629c" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;compose&lt;/code&gt; does is let you write deeply nested function transformations without the rightward drift of the code. Don't give it too much credit!</source>
          <target state="translated">모든 &lt;code&gt;compose&lt;/code&gt; 은 코드의 오른쪽 드리프트없이 깊이 중첩 된 함수 변환을 작성할 수있게합니다. 너무 많은 신용을주지 마십시오!</target>
        </trans-unit>
        <trans-unit id="9352846dec2290d9ee10aeb06144a932791349b8" translate="yes" xml:space="preserve">
          <source>All container components need access to the Redux store so they can subscribe to it. One option would be to pass it as a prop to every container component. However it gets tedious, as you have to wire &lt;code&gt;store&lt;/code&gt; even through presentational components just because they happen to render a container deep in the component tree.</source>
          <target state="translated">모든 컨테이너 구성 요소는 Redux 저장소에 액세스해야 가입 할 수 있습니다. 한 가지 옵션은 모든 컨테이너 구성 요소에 소품으로 전달하는 것입니다. 그러나 구성 요소 트리에서 컨테이너를 깊게 렌더링하기 때문에 프레젠테이션 구성 요소를 통해 &lt;code&gt;store&lt;/code&gt; 를 연결해야하기 때문에 지루 합니다.</target>
        </trans-unit>
        <trans-unit id="4ff23711ae579d38170f51f062fe9549d4a371f8" translate="yes" xml:space="preserve">
          <source>Allows access to state via &lt;a href=&quot;../api/store#getState&quot;&gt;&lt;code&gt;getState()&lt;/code&gt;&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;../api/store#getState&quot;&gt; &lt;code&gt;getState()&lt;/code&gt; &lt;/a&gt; 를 통해 상태에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a12034e563003a9eca9331500b3b60b340ce34f" translate="yes" xml:space="preserve">
          <source>Allows state to be updated via &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;dispatch(action)&lt;/code&gt; &lt;/a&gt; 를 통해 상태를 업데이트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fc5484ef3a628ddd51e1319c03088024b0016ab" translate="yes" xml:space="preserve">
          <source>Almost all examples have a corresponding CodeSandbox sandbox. This is an interactive version of the code that you can play with online.</source>
          <target state="translated">거의 모든 예제에는 해당하는 CodeSandbox 샌드 박스가 있습니다. 온라인에서 재생할 수있는 코드의 대화식 버전입니다.</target>
        </trans-unit>
        <trans-unit id="65a555920679381ca5e42f41dbd1af93c1e69228" translate="yes" xml:space="preserve">
          <source>Along this chapter, we will be using the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;Todos&lt;/a&gt; example. We recommend you to clone it while reading this chapter.</source>
          <target state="translated">이 장과 함께 &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos&quot;&gt;Todos&lt;/a&gt; 예제를 사용할 것입니다. 이 장을 읽는 동안 복제하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9166c2a546b7eba6781eda1ddb48ac422e9c9900" translate="yes" xml:space="preserve">
          <source>Also keep an eye out for nested state objects that need to be deeply copied. Both &lt;code&gt;_.extend&lt;/code&gt; and &lt;code&gt;Object.assign&lt;/code&gt; make a shallow copy of the state. See &lt;a href=&quot;recipes/reducers/immutableupdatepatterns#updating-nested-objects&quot;&gt;Updating Nested Objects&lt;/a&gt; for suggestions on how to deal with nested state objects.</source>
          <target state="translated">또한 깊이 복사해야하는 중첩 된 상태 객체를 주시하십시오. 두 &lt;code&gt;_.extend&lt;/code&gt; 및 &lt;code&gt;Object.assign&lt;/code&gt; 은 국가의 얕은 복사를합니다. 중첩 된 상태 객체를 처리하는 방법에 대한 제안은 &lt;a href=&quot;recipes/reducers/immutableupdatepatterns#updating-nested-objects&quot;&gt;중첩 된 객체 업데이트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d280006e11c722e08ab0ef3901f105ba1f89c495" translate="yes" xml:space="preserve">
          <source>Also, the resulting names are a bit odd. It's generally not a good practice to actually include words like &quot;reducer&quot; in your state key names - the keys should simply reflect the domain or type of data they hold. This means we should either explicitly specify the names of the keys in the slice reducer object to define the keys in the output state object, or carefully rename the variables for the imported slice reducers to set up the keys when using the shorthand object literal syntax.</source>
          <target state="translated">또한 결과 이름은 약간 이상합니다. 일반적으로 상태 키 이름에 &quot;reducer&quot;와 같은 단어를 실제로 포함시키는 것은 좋은 방법이 아닙니다. 키는 단순히 도메인이나 데이터 유형을 반영해야합니다. 즉, 출력 상태 객체에서 키를 정의하기 위해 슬라이스 감속기 객체의 키 이름을 명시 적으로 지정하거나, 단축 객체 리터럴 구문을 사용할 때 가져온 슬라이스 감속기의 변수 이름을 신중하게 변경하여 키를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a92743996305e4fee546be1bf5a260da6bb485c9" translate="yes" xml:space="preserve">
          <source>Also, while &lt;code&gt;combineReducers&lt;/code&gt; is the one reducer utility function that's built into Redux, there's a wide variety of third-party reducer utilities that have published for reuse. The &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Addons Catalog&lt;/a&gt; lists many of the third-party utilities that are available. Or, if none of the published utilities solve your use case, you can always write a function yourself that does just exactly what you need.</source>
          <target state="translated">또한 &lt;code&gt;combineReducers&lt;/code&gt; 는 Redux에 내장 된 하나의 감속기 유틸리티 기능이지만 재사용을 위해 게시 된 다양한 타사 감속기 유틸리티가 있습니다. &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;돌아 오는 부가 기능 카탈로그&lt;/a&gt; 사용할 수있는 타사 유틸리티의 많은 목록. 또는 게시 된 유틸리티 중 어느 것도 사용 사례를 해결하지 못하면 항상 필요한 것을 정확하게 수행하는 함수를 직접 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf8b3627c269aa139cc46adb58b39f1f40a3959a" translate="yes" xml:space="preserve">
          <source>Alternatively, you can create a &lt;strong&gt;bound action creator&lt;/strong&gt; that automatically dispatches:</source>
          <target state="translated">또는 다음 을 자동으로 전달 하는 &lt;strong&gt;바인딩 된 액션 생성자&lt;/strong&gt; 를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d168d8850f955b7e9e3d0a064ebea1d8ecaae72" translate="yes" xml:space="preserve">
          <source>Although powerful, Immutable.JS needs to be used carefully, as it comes with issues of its own. Note, however, that all of these issues can be overcome quite easily with careful coding.</source>
          <target state="translated">강력하지만 Immutable.JS는 자체 문제가 있으므로 신중하게 사용해야합니다. 그러나 이러한 모든 문제는 신중한 코딩으로 쉽게 극복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d209720249965a438eaa6d74c36ac6d53a3230a" translate="yes" xml:space="preserve">
          <source>Although the final result in this example is noticeably longer than the original version, this is primarily due to the extraction of the utility functions, the addition of comments, and some deliberate verbosity for the sake of clarity, such as separate return statements. Looking at each function individually, the amount of responsibility is now smaller, and the intent is hopefully clearer. Also, in a real application, these functions would probably then be split into separate files such as &lt;code&gt;reducerUtilities.js&lt;/code&gt;, &lt;code&gt;visibilityReducer.js&lt;/code&gt;, &lt;code&gt;todosReducer.js&lt;/code&gt;, and &lt;code&gt;rootReducer.js&lt;/code&gt;.</source>
          <target state="translated">이 예제의 최종 결과는 원래 버전보다 눈에 띄게 길지만, 주로 유틸리티 함수 추출, 주석 추가 및 별도의 리턴 명령문과 같은 명확성을 위해 의도적으로 자세한 표시 때문입니다. 각 기능을 개별적으로 살펴보면 책임의 양이 줄어들었고 의도는 더 명확 해졌습니다. 또한, 실제 응용 프로그램에서 이러한 기능은 아마 다음과 같은 별도의 파일로 분할 할 것 &lt;code&gt;reducerUtilities.js&lt;/code&gt; , &lt;code&gt;visibilityReducer.js&lt;/code&gt; , &lt;code&gt;todosReducer.js&lt;/code&gt; 및 &lt;code&gt;rootReducer.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11420cf980650fbffa2655206c7e7f0d6f693730" translate="yes" xml:space="preserve">
          <source>Always.</source>
          <target state="translated">Always.</target>
        </trans-unit>
        <trans-unit id="ae42e396c07650791a08d3bbeb56dcf9d4f16480" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;actions&quot;&gt;action&lt;/a&gt; is a plain object describing &lt;em&gt;what happened&lt;/em&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;actions&quot;&gt;조치를&lt;/a&gt; 설명하는 일반 객체입니다 &lt;em&gt;무슨 일이 있었는지&lt;/em&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e3348883e6b709273b1588a140f0ad640ffa7901" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;action creator&lt;/em&gt; is, quite simply, a function that creates an action. Do not confuse the two terms&amp;mdash;again, an action is a payload of information, and an action creator is a factory that creates an action.</source>
          <target state="translated">&lt;em&gt;행동 작성자는&lt;/em&gt; 매우 간단하게 작업을 생성하는 기능입니다. 두 가지 용어를 혼동하지 마십시오. 액션은 정보의 페이로드이고 액션 작성자는 액션을 만드는 팩토리입니다.</target>
        </trans-unit>
        <trans-unit id="7dbd2dc1e57dbf1a690c626bcf14369d4d0f24ee" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;action&lt;/em&gt; is a plain object that represents an intention to change the state. Actions are the only way to get data into the store. Any data, whether from UI events, network callbacks, or other sources such as WebSockets needs to eventually be dispatched as actions.</source>
          <target state="translated">&lt;em&gt;조치는&lt;/em&gt; 상태를 변경하는 의도를 나타내는 일반 개체입니다. 작업은 데이터를 저장소로 가져 오는 유일한 방법입니다. UI 이벤트, 네트워크 콜백 또는 WebSocket과 같은 다른 소스의 데이터는 결국 작업으로 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5753c579ec0c6f7a4e01deb683ed860b056f3db7" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;async action&lt;/em&gt; is a value that is sent to a dispatching function, but is not yet ready for consumption by the reducer. It will be transformed by &lt;a href=&quot;#middleware&quot;&gt;middleware&lt;/a&gt; into an action (or a series of actions) before being sent to the base &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; function. Async actions may have different types, depending on the middleware you use. They are often asynchronous primitives, like a Promise or a thunk, which are not passed to the reducer immediately, but trigger action dispatches once an operation has completed.</source>
          <target state="translated">&lt;em&gt;비동기 작업이&lt;/em&gt; 디 스팟 기능으로 전송되는 값이지만, 아직 감속기에 의해 소비를위한 준비가되지 않았습니다. 기본 &lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 함수 로 전송되기 전에 &lt;a href=&quot;#middleware&quot;&gt;미들웨어&lt;/a&gt; 에 의해 조치 (또는 일련의 조치)로 변환됩니다 . 사용하는 미들웨어에 따라 비동기 조치의 유형이 다를 수 있습니다. 이들은 종종 약속 또는 썽크와 같은 비동기 프리미티브로, 리듀서에 즉시 전달되지 않지만 작업이 완료되면 액션 디스패치를 ​​트리거합니다.</target>
        </trans-unit>
        <trans-unit id="7059ea52b9fe7cd64e9c1eb12fbae0e27f1fbf10" translate="yes" xml:space="preserve">
          <source>An Introduction to Reasonably Pure Functional Programming</source>
          <target state="translated">합리적으로 순수한 기능적 프로그래밍 소개</target>
        </trans-unit>
        <trans-unit id="027aa8fd687cde00ad56b360989176d53d8f5088" translate="yes" xml:space="preserve">
          <source>An alternative approach is to use the &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;object spread syntax&lt;/a&gt; proposed for the next versions of JavaScript which lets you use the spread (&lt;code&gt;...&lt;/code&gt;) operator to copy enumerable properties from one object to another in a more succinct way. The object spread operator is conceptually similar to the ES6 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;array spread operator&lt;/a&gt;. We can simplify the &lt;code&gt;todoApp&lt;/code&gt; example above by using the object spread syntax:</source>
          <target state="translated">다른 방법은 다음 버전의 JavaScript에 대해 제안 된 &lt;a href=&quot;https://github.com/sebmarkbage/ecmascript-rest-spread&quot;&gt;객체 스프레드 구문&lt;/a&gt; 을 사용하여 스프레드 ( &lt;code&gt;...&lt;/code&gt; ) 연산자를 사용하여 열거 가능한 속성을 한 객체에서 다른 객체로 간결하게 복사 할 수 있습니다 . 객체 확산 연산자는 개념적으로 ES6 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;배열 확산 연산자&lt;/a&gt; 와 유사합니다 . 객체 스프레드 구문을 사용하여 위 의 &lt;code&gt;todoApp&lt;/code&gt; 예제를 단순화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9140efa7e4fd077860c74984e025f41073161a33" translate="yes" xml:space="preserve">
          <source>An example of a normalized state structure for the blog example above might look like:</source>
          <target state="translated">위의 블로그 예제에 대한 정규화 된 상태 구조의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f5f4aca90e751fb4943bf0f75cdcb58b3045de7" translate="yes" xml:space="preserve">
          <source>And further yet:</source>
          <target state="translated">그리고 아직 :</target>
        </trans-unit>
        <trans-unit id="042ece2a59b966fa0a3746efb8c09215e767bd18" translate="yes" xml:space="preserve">
          <source>And if you need both:</source>
          <target state="translated">그리고 둘 다 필요한 경우 :</target>
        </trans-unit>
        <trans-unit id="b9796d47a0c430111a17f97990051bc1f0bd25b7" translate="yes" xml:space="preserve">
          <source>And many, many more! The Redux Addons Catalog has &lt;strong&gt;&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links/blob/master/apps-and-examples.md&quot;&gt;a list of Redux-based applications and examples&lt;/a&gt;&lt;/strong&gt; that points to a variety of actual applications, large and small.</source>
          <target state="translated">그리고 훨씬 더! Redux Addons Catalog에는 크고 작은 다양한 실제 응용 프로그램을 가리키는 &lt;strong&gt;&lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links/blob/master/apps-and-examples.md&quot;&gt;Redux 기반 응용 프로그램 및 예제 목록이&lt;/a&gt;&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="38147ba676724ae6f61a0d7f338d7350e8929314" translate="yes" xml:space="preserve">
          <source>And that's it! That is all we need to do to implement server side rendering.</source>
          <target state="translated">그리고 그게 다야! 이것이 서버 측 렌더링을 구현하기 위해해야 ​​할 전부입니다.</target>
        </trans-unit>
        <trans-unit id="0f36f5dbc061dc0b41ff32b3fcf5454dd4737242" translate="yes" xml:space="preserve">
          <source>And this is how you would use it in your Smart Component:</source>
          <target state="translated">그리고 이것이 스마트 구성 요소에서 사용하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7821f53eb6540ced1a441c7c8a5afc57915f7472" translate="yes" xml:space="preserve">
          <source>And we write another reducer that manages the complete state of our app by calling those two reducers for the corresponding state keys:</source>
          <target state="translated">그리고 해당 상태 키에 대해 두 개의 감속기를 호출하여 앱의 전체 상태를 관리하는 다른 감속기를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="035d8336ff091d8317b65369c8f7a5fba5c1e1a6" translate="yes" xml:space="preserve">
          <source>Andr&amp;eacute; Staltz, creator of Cycle</source>
          <target state="translated">사이클 제작자 Andr&amp;eacute; Staltz</target>
        </trans-unit>
        <trans-unit id="e87d12fc4df56487f9cea8c793885037c6bb50fc" translate="yes" xml:space="preserve">
          <source>Angular 2 &amp;mdash; Introduction to Redux</source>
          <target state="translated">Angular 2 &amp;mdash; Redux 소개</target>
        </trans-unit>
        <trans-unit id="bc3e9743695c2147abea82ed6210c9b8769e1aff" translate="yes" xml:space="preserve">
          <source>Another alternative to the &quot;shared-slice updates&quot; issue would be to simply put more data into the action. This is easily accomplished using thunk functions or a similar approach, per this example:</source>
          <target state="translated">&quot;공유 슬라이스 업데이트&quot;문제에 대한 다른 대안은 단순히 더 많은 데이터를 작업에 넣는 것입니다. 이 예제에 따라 썽크 함수 또는 유사한 접근 방식을 사용하여 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54508f8783d239a03fbfc708d7eb0721cdb09e88" translate="yes" xml:space="preserve">
          <source>Another common version of this error looks like this:</source>
          <target state="translated">이 오류의 다른 일반적인 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab7d294fca6f772f407a0c0a76df3b9678dec13a" translate="yes" xml:space="preserve">
          <source>Another important difference from Flux is that &lt;strong&gt;Redux assumes you never mutate your data&lt;/strong&gt;. You can use plain objects and arrays for your state just fine, but mutating them inside the reducers is strongly discouraged. You should always return a new object, which is easy with the &lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt;, or with a library like &lt;a href=&quot;https://facebook.github.io/immutable-js&quot;&gt;Immutable&lt;/a&gt;.</source>
          <target state="translated">Flux &lt;strong&gt;와의&lt;/strong&gt; 또 다른 중요한 차이점은 &lt;strong&gt;Redux는 데이터를 절대로 변경하지 않는다고 가정&lt;/strong&gt; 한다는 것 입니다. 상태에 맞는 일반 객체와 배열을 사용할 수는 있지만 감속기 내에서 변형하면 권장하지 않습니다. 항상 &lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;객체 스프레드 연산자 제안&lt;/a&gt; 또는 &lt;a href=&quot;https://facebook.github.io/immutable-js&quot;&gt;Immutable&lt;/a&gt; 과 같은 라이브러리를 사용하여 쉽게 새 객체를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="327dd80631e264f16ad2cae2c1d1c364a6353cd0" translate="yes" xml:space="preserve">
          <source>Another variation on this is to use Redux-ORM as an abstraction layer within a single case reducer:</source>
          <target state="translated">이에 대한 또 다른 변형은 단일 사례 감속기 내에서 Redux-ORM을 추상화 계층으로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6dca810c72389e39d7ae3adc87f949b161cb67aa" translate="yes" xml:space="preserve">
          <source>Any meaningful web app needs to execute complex logic, usually including asynchronous work such as making AJAX requests. That code is no longer purely a function of its inputs, and the interactions with the outside world are known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29&quot;&gt;&amp;ldquo;side effects&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">의미있는 웹 앱은 일반적으로 AJAX 요청과 같은 비동기 작업을 포함하여 복잡한 논리를 실행해야합니다. 이 코드는 더 이상 순수하게 입력의 기능이 아니며 외부 세계와의 상호 작용을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29&quot;&gt;&quot;부작용&quot;이라고합니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17a95b9c7d131a13dd7681ee829c7309078b3577" translate="yes" xml:space="preserve">
          <source>Any reducer passed to &lt;code&gt;combineReducers&lt;/code&gt; must satisfy these rules:</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 전달 된 모든 감속기는 다음 규칙을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="6fdbb15360b3088d82f5dfe1a14a15d468cb58cd" translate="yes" xml:space="preserve">
          <source>Any references to individual items should be done by storing the item's ID.</source>
          <target state="translated">개별 품목에 대한 언급은 품목 ID를 저장하여 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="206a7715eef6f00c93aebc49d2e9182d87517249" translate="yes" xml:space="preserve">
          <source>Apollo Client: GraphQL with React and Redux</source>
          <target state="translated">아폴로 클라이언트 : React와 Redux를 갖춘 GraphQL</target>
        </trans-unit>
        <trans-unit id="9005318bff4ea7c0d752cddae4ff458b6e1a0913" translate="yes" xml:space="preserve">
          <source>Are there any larger, &amp;ldquo;real&amp;rdquo; Redux projects?</source>
          <target state="translated">더 큰&amp;ldquo;실제&amp;rdquo;Redux 프로젝트가 있습니까?</target>
        </trans-unit>
        <trans-unit id="cc44e7f8ef0dbd0f0399aed6b078549d32a1bc08" translate="yes" xml:space="preserve">
          <source>Are written</source>
          <target state="translated">작성되었습니다</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="49daae7bc3193b4ffbf057d1ce571f648d334335" translate="yes" xml:space="preserve">
          <source>Arrays of IDs should be used to indicate ordering.</source>
          <target state="translated">순서를 나타 내기 위해 ID 배열을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="678560a52b48d8df9cc01483f2c09d287f1730ed" translate="yes" xml:space="preserve">
          <source>As an application grows, common patterns in reducer logic will start to emerge. You may find several parts of your reducer logic doing the same kinds of work for different types of data, and want to reduce duplication by reusing the same common logic for each data type. Or, you may want to have multiple &quot;instances&quot; of a certain type of data being handled in the store. However, the global structure of a Redux store comes with some trade-offs: it makes it easy to track the overall state of an application, but can also make it harder to &quot;target&quot; actions that need to update a specific piece of state, particularly if you are using &lt;code&gt;combineReducers&lt;/code&gt;.</source>
          <target state="translated">애플리케이션이 성장함에 따라 감속기 로직의 공통 패턴이 등장하기 시작합니다. 서로 다른 유형의 데이터에 대해 동일한 종류의 작업을 수행하는 감속기 논리의 여러 부분을 찾을 수 있으며 각 데이터 유형에 대해 동일한 공통 논리를 재사용하여 중복을 줄이려고 할 수 있습니다. 또는 특정 유형의 데이터에 대한 여러 &quot;인스턴스&quot;를 상점에서 처리하려고 할 수 있습니다. 그러나 Redux 스토어의 글로벌 구조에는 몇 가지 장단점이 있습니다. 즉, 애플리케이션의 전체 상태를 쉽게 추적 할 수 있지만 특정 상태를 업데이트해야하는 작업을 &quot;타겟팅&quot;하기가 어려워 질 수 있습니다. 특히 당신이 &lt;code&gt;combineReducers&lt;/code&gt; 를 사용하는 경우 .</target>
        </trans-unit>
        <trans-unit id="7b8dfe1588c786f88cd39b5e2f752576b7bb0f10" translate="yes" xml:space="preserve">
          <source>As an example, let's say that we want to track multiple counters in our application, named A, B, and C. We define our initial &lt;code&gt;counter&lt;/code&gt; reducer, and we use &lt;code&gt;combineReducers&lt;/code&gt; to set up our state:</source>
          <target state="translated">예를 들어, 응용 프로그램에서 A, B 및 C라는 여러 카운터를 추적하려고한다고 가정합니다. 초기 &lt;code&gt;counter&lt;/code&gt; 감속기를 정의하고 &lt;code&gt;combineReducers&lt;/code&gt; 를 사용 하여 상태를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="709fd50216cd72e5e5a781b80b45c62c308c61de" translate="yes" xml:space="preserve">
          <source>As defined in &lt;a href=&quot;splittingreducerlogic&quot;&gt;Splitting Reducer Logic&lt;/a&gt;, a &lt;em&gt;higher-order reducer&lt;/em&gt; is a function that takes a reducer function as an argument, and/or returns a new reducer function as a result. It can also be viewed as a &quot;reducer factory&quot;. &lt;code&gt;combineReducers&lt;/code&gt; is one example of a higher-order reducer. We can use this pattern to create specialized versions of our own reducer functions, with each version only responding to specific actions.</source>
          <target state="translated">항에 &lt;a href=&quot;splittingreducerlogic&quot;&gt;분할 감속기 로직&lt;/a&gt; 하는 &lt;em&gt;고차 감속기&lt;/em&gt; 인수로 감속 기능을 얻어, 및 / 또는 결과로 새로운 감속기 함수를 리턴하는 함수이다. &quot;감소 기 공장&quot;으로 볼 수도 있습니다. &lt;code&gt;combineReducers&lt;/code&gt; 는 고차 감속기의 한 예입니다. 이 패턴을 사용하여 자체 감속기 기능의 특수 버전을 만들 수 있으며 각 버전은 특정 작업에만 응답합니다.</target>
        </trans-unit>
        <trans-unit id="fef475fd072b3bead2a85a3d7e365ffb13bfaca5" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;../../basics/reducers&quot;&gt;Reducers&lt;/a&gt;, a Redux reducer function:</source>
          <target state="translated">설명 된 바와 같이 &lt;a href=&quot;../../basics/reducers&quot;&gt;기어&lt;/a&gt; 하는 감속기 돌아 오는 기능 :</target>
        </trans-unit>
        <trans-unit id="ef35726a994739e304113b383deb26575f5ff1ba" translate="yes" xml:space="preserve">
          <source>As for architecture, anecdotal evidence is that Redux works well for varying project and team sizes. Redux is currently used by hundreds of companies and thousands of developers, with several hundred thousand monthly installations from NPM. One developer reported:</source>
          <target state="translated">아키텍처와 관련하여 일화적인 증거는 Redux가 다양한 프로젝트 및 팀 규모에 적합하다는 것입니다. Redux는 현재 수백 개의 회사와 수천 명의 개발자가 사용하고 있으며 NPM에서 매달 수십만 건을 설치합니다. 한 개발자가보고했습니다 :</target>
        </trans-unit>
        <trans-unit id="e814716838438ec84d1615becea35368a2e66458" translate="yes" xml:space="preserve">
          <source>As if this wasn't bad enough, consider the &lt;strong&gt;new requirements becoming common in front-end product development&lt;/strong&gt;. As developers, we are expected to handle optimistic updates, server-side rendering, fetching data before performing route transitions, and so on. We find ourselves trying to manage a complexity that we have never had to deal with before, and we inevitably ask the question: &lt;a href=&quot;http://www.quirksmode.org/blog/archives/2015/07/stop_pushing_th.html&quot;&gt;is it time to give up?&lt;/a&gt; The answer is &lt;em&gt;no&lt;/em&gt;.</source>
          <target state="translated">이것이 나쁘지 않은 것처럼 &lt;strong&gt;프런트 엔드 제품 개발에서 새로운 요구 사항이 일반화되는&lt;/strong&gt; 것을 고려하십시오 . 개발자는 낙관적 업데이트, 서버 측 렌더링, 경로 전환을 수행하기 전에 데이터 페치 등을 처리해야합니다. 우리는 이전에 다룰 필요가 없었던 복잡성을 관리하려고 노력하고 있으며 필연적으로 질문을합니다. &lt;a href=&quot;http://www.quirksmode.org/blog/archives/2015/07/stop_pushing_th.html&quot;&gt;포기할 시간입니까? &lt;/a&gt;대답은 ' &lt;em&gt;아니요'&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fbb977642e09fe68de908d000ae815bd23c6664f" translate="yes" xml:space="preserve">
          <source>As it continues through the iterations, &lt;code&gt;combineReducers&lt;/code&gt; will construct a new state object with the state slices returned from each reducer. This new state object may or may not be different from the current state object. It is here that &lt;code&gt;combineReducers&lt;/code&gt; uses shallow equality checking to determine whether the state has changed.</source>
          <target state="translated">반복이 계속 진행 &lt;code&gt;combineReducers&lt;/code&gt; 는 각 리듀서에서 반환 된 상태 슬라이스로 새로운 상태 객체를 생성합니다. 이 새로운 상태 객체는 현재 상태 객체와 다를 수도 있고 다를 수도 있습니다. 그것은 것을 여기 &lt;code&gt;combineReducers&lt;/code&gt; 이 상태가 변경되었는지 여부를 결정하기 위해 얕은 평등 검사를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c31c6475cbfd62456b208b3c6e1e67d8fcfdab31" translate="yes" xml:space="preserve">
          <source>As it turns out, there's a useful utility called &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;reduce-reducers&lt;/a&gt; that can make that process easier. It simply takes multiple reducers and runs &lt;code&gt;reduce()&lt;/code&gt; on them, passing the intermediate state values to the next reducer in line:</source>
          <target state="translated">결과적으로 프로세스를 쉽게 할 수있는 &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;Reduce-Reducers&lt;/a&gt; 라는 유용한 유틸리티 가 있습니다. 단순히 여러 개의 감속기를 가져 와서 &lt;code&gt;reduce()&lt;/code&gt; 를 실행 하여 중간 상태 값을 다음 감속기로 줄에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="7abf8ce0941afdd199232022cabbf076e6057848" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;normalizingstateshape&quot;&gt;Normalizing State Shape&lt;/a&gt;, the Normalizr library is frequently used to transform nested response data into a normalized shape suitable for integration into the store. However, that doesn't address the issue of executing further updates to that normalized data as it's being used elsewhere in the application. There are a variety of different approaches that you can use, based on your own preference. We'll use the example of adding a new Comment to a Post.</source>
          <target state="translated">&lt;a href=&quot;normalizingstateshape&quot;&gt;Normalizing State Shape&lt;/a&gt; 에서 언급했듯이 Normalizr 라이브러리는 중첩 응답 데이터를 상점에 통합하기에 적합한 표준화 된 형태로 변환하는 데 자주 사용됩니다. 그러나 이는 응용 프로그램의 다른 곳에서 사용되는 정규화 된 데이터에 대한 추가 업데이트 실행 문제를 해결하지 못합니다. 자신의 취향에 따라 사용할 수있는 다양한 접근 방식이 있습니다. Post에 새로운 Comment를 추가하는 예제를 사용할 것입니다.</target>
        </trans-unit>
        <trans-unit id="e4b60f1e31e4c57161fb7758305113397c7a5c3a" translate="yes" xml:space="preserve">
          <source>As our last step, we can now use Redux's built-in &lt;code&gt;combineReducers&lt;/code&gt; utility to handle the &quot;slice-of-state&quot; logic for our top-level app reducer. Here's the final result:</source>
          <target state="translated">마지막 단계로 이제 Redux의 기본 제공 &lt;code&gt;combineReducers&lt;/code&gt; 유틸리티를 사용하여 최상위 앱 리듀서에 대한 &quot;상태 슬라이스&quot;논리를 처리 할 수 ​​있습니다. 최종 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc4496173ef998c4da8d0db366e9bb7a00db7fcd" translate="yes" xml:space="preserve">
          <source>As such, a shallow equality check of the props object returned from repeated calls to &lt;code&gt;mapStateToProps&lt;/code&gt; would always fail, as a new object would be returned each time.</source>
          <target state="translated">따라서 &lt;code&gt;mapStateToProps&lt;/code&gt; 새 객체가 반환 될 때마다 mapStateToProps에 대한 반복 호출에서 반환 된 props 객체의 얕은 동등성 검사 는 항상 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1cf23dc07f110dd0af0f0a020f2623e1f59b9566" translate="yes" xml:space="preserve">
          <source>As such, even though the values of that new object have not changed, the wrapped component will always be re-rendered,</source>
          <target state="translated">따라서 새 객체의 값이 변경되지 않아도 래핑 된 구성 요소는 항상 다시 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="a041a5b277767ea9c2a31b986eec75aca67d859c" translate="yes" xml:space="preserve">
          <source>As the requirements for JavaScript single-page applications have become increasingly complicated, &lt;strong&gt;our code must manage more state than ever before&lt;/strong&gt;. This state can include server responses and cached data, as well as locally created data that has not yet been persisted to the server. UI state is also increasing in complexity, as we need to manage active routes, selected tabs, spinners, pagination controls, and so on.</source>
          <target state="translated">JavaScript 단일 페이지 응용 프로그램에 대한 요구 사항이 점점 복잡해지면서 &lt;strong&gt;코드는 그 어느 때보 다 많은 상태를 관리해야합니다&lt;/strong&gt; . 이 상태에는 서버 응답 및 캐시 된 데이터뿐만 아니라 아직 서버에 유지되지 않은 로컬로 작성된 데이터가 포함될 수 있습니다. 활성 경로, 선택된 탭, 스피너, 페이지 매김 컨트롤 등을 관리해야하므로 UI ​​상태도 점점 복잡해지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a14d76fefd06040ae416dab582f026209ce57474" translate="yes" xml:space="preserve">
          <source>As we&amp;rsquo;ve seen, the values in the mutable object returned by the selector function may have changed, but the object itself has not, and shallow equality checking only compares the objects themselves, not their values.</source>
          <target state="translated">보시다시피, 셀렉터 함수에 의해 반환되는 변경 가능한 객체의 값은 변경되었을 수 있지만 객체 자체는 변경되지 않았으며 얕은 동등성 검사는 값이 아닌 객체 자체 만 비교합니다.</target>
        </trans-unit>
        <trans-unit id="81dc352109a60e2a91dd724ab47b76ebe7decc71" translate="yes" xml:space="preserve">
          <source>As with several other questions, it is &lt;em&gt;possible&lt;/em&gt; to create multiple distinct Redux stores in a page, but the intended pattern is to have only a single store. Having a single store enables using the Redux DevTools, makes persisting and rehydrating data simpler, and simplifies the subscription logic.</source>
          <target state="translated">몇 가지 다른 질문과 마찬가지로 페이지에서 여러 개의 고유 한 Redux 저장소를 생성 할 &lt;em&gt;수&lt;/em&gt; 있지만 의도 한 패턴은 단일 저장소 만 갖는 것입니다. 단일 저장소가 있으면 Redux DevTools를 사용할 수 있고 데이터 유지 및 재수 화가 단순 해지고 가입 논리가 간소화됩니다.</target>
        </trans-unit>
        <trans-unit id="c02308c61548a99934707da188eb85ef748a5cb4" translate="yes" xml:space="preserve">
          <source>As with state, serializable actions enable several of Redux's defining features, such as time travel debugging, and recording and replaying actions. Using something like a &lt;code&gt;Symbol&lt;/code&gt; for the &lt;code&gt;type&lt;/code&gt; value or using &lt;code&gt;instanceof&lt;/code&gt; checks for actions themselves would break that. Strings are serializable and easily self-descriptive, and so are a better choice. Note that it &lt;em&gt;is&lt;/em&gt; okay to use Symbols, Promises, or other non-serializable values in an action if the action is intended for use by middleware. Actions only need to be serializable by the time they actually reach the store and are passed to the reducers.</source>
          <target state="translated">상태와 마찬가지로 직렬화 가능한 작업을 통해 시간 여행 디버깅, 기록 및 재생 작업과 같은 Redux의 여러 정의 기능을 사용할 수 있습니다. 유사한 것을 사용하여 &lt;code&gt;Symbol&lt;/code&gt; 에 대한 &lt;code&gt;type&lt;/code&gt; 값 또는 사용 &lt;code&gt;instanceof&lt;/code&gt; 를 자체가 휴식 할 행동에 대한 검사를. 문자열은 직렬화 가능하고 쉽게 설명 할 수 있으므로 더 나은 선택입니다. 이 참고 &lt;em&gt;인&lt;/em&gt; 액션이 미들웨어를 사용하기위한 것입니다 경우 작업에 사용되는 기호, 약속, 또는 다른 비 직렬화 값 괜찮아. 조치는 실제로 상점에 도달하여 감속기로 전달 될 때까지 직렬화 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="25d90438423a5d564145ee745315cbd04ef8f5d9" translate="yes" xml:space="preserve">
          <source>As you rewrite your Stores, you will find that you need to avoid certain Flux anti-patterns such as fetching API inside the Store, or triggering actions inside the Stores. Your Flux code will be easier to follow once you port it to be based on reducers!</source>
          <target state="translated">상점을 다시 작성할 때 상점 내부에서 API를 가져 오거나 상점 내부에서 조치를 트리거하는 것과 같은 특정 Flux 안티 패턴을 피해야한다는 것을 알게 될 것입니다. 감속기를 기반으로 포팅하면 Flux 코드를 쉽게 따라갈 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="42a2c484c73d6daa09647c6197ccf515d0e0786e" translate="yes" xml:space="preserve">
          <source>As your app grows more complex, you'll want to split your &lt;a href=&quot;../glossary#reducer&quot;&gt;reducing function&lt;/a&gt; into separate functions, each managing independent parts of the &lt;a href=&quot;../glossary#state&quot;&gt;state&lt;/a&gt;.</source>
          <target state="translated">앱이 더욱 복잡 해짐에 따라 &lt;a href=&quot;../glossary#reducer&quot;&gt;축소 함수&lt;/a&gt; 를 개별 함수로 분리 하여 각 &lt;a href=&quot;../glossary#state&quot;&gt;상태의&lt;/a&gt; 독립적 인 부분을 관리 하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="1cff388be99f52b685be17cb7f6b80f2a1084bc0" translate="yes" xml:space="preserve">
          <source>Ask around on the &lt;strong&gt;#redux&lt;/strong&gt;&lt;a href=&quot;http://reactiflux.com/&quot;&gt;Reactiflux&lt;/a&gt; Discord channel, or &lt;a href=&quot;https://github.com/reactjs/redux/issues&quot;&gt;create an issue&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;#redux &lt;/strong&gt;&lt;a href=&quot;http://reactiflux.com/&quot;&gt;Reactiflux&lt;/a&gt; Discord 채널 에 대해 문의 하거나 &lt;a href=&quot;https://github.com/reactjs/redux/issues&quot;&gt;문제를 만드십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd90ea9965306b973ad750889f0a4b9e3769518a" translate="yes" xml:space="preserve">
          <source>Associating items in relationships</source>
          <target state="translated">관계에서 항목 연관</target>
        </trans-unit>
        <trans-unit id="f243e92a1117cab31114a44424d26658eeb2d079" translate="yes" xml:space="preserve">
          <source>Assuming actual changes need to occur, it needs to create new objects and arrays with the updated data and return those</source>
          <target state="translated">실제 변경이 필요하다고 가정하면 업데이트 된 데이터를 사용하여 새 객체와 배열을 만들어 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="db37f55867798c63094a75db06886660e91436bf" translate="yes" xml:space="preserve">
          <source>Async</source>
          <target state="translated">Async</target>
        </trans-unit>
        <trans-unit id="90722b7f9d2e813acdd905ce6a728ce981a33ec4" translate="yes" xml:space="preserve">
          <source>Async Action</source>
          <target state="translated">비동기 동작</target>
        </trans-unit>
        <trans-unit id="167b050aac66ff4723e2e1e409f28704074758c3" translate="yes" xml:space="preserve">
          <source>Async Action Creators</source>
          <target state="translated">비동기 액션 제작자</target>
        </trans-unit>
        <trans-unit id="91eebc38df11fd82beeb837efd263578c88fd532" translate="yes" xml:space="preserve">
          <source>Async Actions</source>
          <target state="translated">비동기 동작</target>
        </trans-unit>
        <trans-unit id="27f1c859609130246bfcce156061b4ffce4ac287" translate="yes" xml:space="preserve">
          <source>Async Flow</source>
          <target state="translated">비동기 흐름</target>
        </trans-unit>
        <trans-unit id="19c040239385214a8e17389f47ba7d20d7ef489c" translate="yes" xml:space="preserve">
          <source>Async State Fetching</source>
          <target state="translated">비동기 상태 가져 오기</target>
        </trans-unit>
        <trans-unit id="886ac17e24bc12f98154c913a55fad29ab13e686" translate="yes" xml:space="preserve">
          <source>Async action creators are especially convenient for server rendering. You can create a store, dispatch a single async action creator that dispatches other async action creators to fetch data for a whole section of your app, and only render after the Promise it returns, completes. Then your store will already be hydrated with the state you need before rendering.</source>
          <target state="translated">비동기 액션 생성기는 특히 서버 렌더링에 편리합니다. 스토어를 생성하고 다른 비동기 액션 생성자를 디스패치하는 단일 비동기 액션 생성자를 디스패치하여 앱의 전체 섹션에 대한 데이터를 가져오고 반환 약속이 완료된 후에 만 ​​렌더링 할 수 있습니다. 그러면 상점은 렌더링 전에 필요한 상태로 이미 수화됩니다.</target>
        </trans-unit>
        <trans-unit id="b1b1c578f34b8d9eb909781b58a2f94d6f371c68" translate="yes" xml:space="preserve">
          <source>Asynchronous middleware like &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; or &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; wraps the store's &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; method and allows you to dispatch something other than actions, for example, functions or Promises. Any middleware you use can then interpret anything you dispatch, and in turn, can pass actions to the next middleware in the chain. For example, a Promise middleware can intercept Promises and dispatch a pair of begin/end actions asynchronously in response to each Promise.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; 와 같은 비동기 미들웨어 는 상점의 &lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 메소드를 랩핑하고 함수 또는 약속과 같은 조치 이외의 것을 디스패치 할 수 있습니다. 그런 다음 사용하는 모든 미들웨어는 전달한 모든 것을 해석 할 수 있으며, 체인의 다음 미들웨어에 조치를 전달할 수 있습니다. 예를 들어, Promise 미들웨어는 약속을 가로 채고 각 약속에 대한 응답으로 한 쌍의 시작 / 종료 조치를 비동기식으로 발송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eb0dcef5fba599c316c78c309f567d83281170d" translate="yes" xml:space="preserve">
          <source>At its core, Redux is really a fairly simple design pattern: all your &quot;write&quot; logic goes into a single function, and the only way to run that logic is to give Redux a plain object that describes something that has happened. The Redux store calls that write logic function and passes in the current state tree and the descriptive object, the write logic function returns some new state tree, and the Redux store notifies any subscribers that the state tree has changed.</source>
          <target state="translated">핵심적으로, Redux는 실제로 매우 단순한 디자인 패턴입니다. 모든 &quot;쓰기&quot;로직이 단일 기능으로 들어가고 해당 로직을 실행하는 유일한 방법은 Redux에 발생한 일을 설명하는 일반 객체를 제공하는 것입니다. Redux 저장소는 해당 논리 쓰기 기능을 호출하고 현재 상태 트리 및 설명 객체를 전달하고, 논리 쓰기 기능은 새로운 상태 트리를 반환하며, Redux 저장소는 가입자에게 상태 트리가 변경되었음을 알립니다.</target>
        </trans-unit>
        <trans-unit id="30c55c70af3e1a8f861110d1c7eecd86c69c1d55" translate="yes" xml:space="preserve">
          <source>Attempt #1: Logging Manually</source>
          <target state="translated">시도 # 1 : 수동 로깅</target>
        </trans-unit>
        <trans-unit id="cf041cf27718908810ead0d2f91d0171d49b9b85" translate="yes" xml:space="preserve">
          <source>Attempt #2: Wrapping Dispatch</source>
          <target state="translated">시도 # 2 : 랩핑 디스패치</target>
        </trans-unit>
        <trans-unit id="77db9a04efffdb3012b23e3322da962156c4a860" translate="yes" xml:space="preserve">
          <source>Attempt #3: Monkeypatching Dispatch</source>
          <target state="translated">시도 # 3 : 몽키 패칭 발송</target>
        </trans-unit>
        <trans-unit id="2f2148510a51d59cf3a8e564eed4a0c3c1d86f5f" translate="yes" xml:space="preserve">
          <source>Attempt #4: Hiding Monkeypatching</source>
          <target state="translated">시도 # 4 : 원숭이 패칭 숨기기</target>
        </trans-unit>
        <trans-unit id="ca2cc7378629716a29578d9874dd2b25fc5a8c9d" translate="yes" xml:space="preserve">
          <source>Attempt #5: Removing Monkeypatching</source>
          <target state="translated">시도 # 5 : 몽키 패칭 제거</target>
        </trans-unit>
        <trans-unit id="73546da71df70edaa82a5330e2ce70fd8845ff54" translate="yes" xml:space="preserve">
          <source>Attempt #6: Na&amp;iuml;vely Applying the Middleware</source>
          <target state="translated">시도 # 6 : 미들웨어를 순진하게 적용</target>
        </trans-unit>
        <trans-unit id="5678d8ff8964be781758624218ca67e6eccfdd1b" translate="yes" xml:space="preserve">
          <source>Authentication is essential to any real application. When going about authentication you must keep in mind that nothing changes with how you should organize your application and you should implement authentication in the same way you would any other feature. It is relatively straightforward:</source>
          <target state="translated">실제 응용 프로그램에는 인증이 필수적입니다. 인증을 수행 할 때는 응용 프로그램을 구성하는 방법에 아무런 변화가 없으며 다른 기능과 동일한 방식으로 인증을 구현해야합니다. 비교적 간단합니다.</target>
        </trans-unit>
        <trans-unit id="9566fa2885d46ca757c9af88ac84f85bb1d56e51" translate="yes" xml:space="preserve">
          <source>Authentication with JWT by Auth0</source>
          <target state="translated">Auth0에 의한 JWT 인증</target>
        </trans-unit>
        <trans-unit id="122e59e628a93b853a47af4cfa8433a11386c564" translate="yes" xml:space="preserve">
          <source>Avoiding Accidental Complexity When Structuring Your App State</source>
          <target state="translated">앱 상태를 구조화 할 때 우연한 복잡성 방지</target>
        </trans-unit>
        <trans-unit id="3e81d3aaff1562199dada2cff7c06a38e4c2294f" translate="yes" xml:space="preserve">
          <source>Avoiding functions and statements that mutate state</source>
          <target state="translated">상태를 변경하는 함수 및 문장 피하기</target>
        </trans-unit>
        <trans-unit id="9aae17642d53cdbcf10d6748c5122f8d3443a256" translate="yes" xml:space="preserve">
          <source>Aware of Redux</source>
          <target state="translated">Redux의 인식</target>
        </trans-unit>
        <trans-unit id="9410a51d85ad489b23f91e3413ee16c00a3aada5" translate="yes" xml:space="preserve">
          <source>Backbone's model layer is quite different from Redux, so we don't suggest mixing them. If possible, it is best that you rewrite your app's model layer from scratch instead of connecting Backbone to Redux. However, if a rewrite is not feasible, you may use &lt;a href=&quot;https://github.com/redbooth/backbone-redux&quot;&gt;backbone-redux&lt;/a&gt; to migrate gradually, and keep the Redux store in sync with Backbone models and collections.</source>
          <target state="translated">백본의 모델 레이어는 Redux와는 매우 다르므로 혼합하지 않는 것이 좋습니다. 가능하면 Backbone을 Redux에 연결하는 대신 앱의 모델 계층을 처음부터 다시 작성하는 것이 가장 좋습니다. 그러나 다시 쓰기를 실행할 수없는 경우 &lt;a href=&quot;https://github.com/redbooth/backbone-redux&quot;&gt;백본 redux&lt;/a&gt; 를 사용 하여 점진적으로 마이그레이션하고 Redux 저장소를 백본 모델 및 컬렉션과 동기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed27f94322cfd2585f69fd4faaf883777c565fb1" translate="yes" xml:space="preserve">
          <source>Baobab</source>
          <target state="translated">Baobab</target>
        </trans-unit>
        <trans-unit id="22e42af3c93af18697862c91d897419ff315b287" translate="yes" xml:space="preserve">
          <source>Basic Reducer Structure</source>
          <target state="translated">기본 감속기 구조</target>
        </trans-unit>
        <trans-unit id="9f6c9bee78e234130cb00e796115605ccb9c9356" translate="yes" xml:space="preserve">
          <source>Basic Reducer Structure and State Shape</source>
          <target state="translated">기본 감속기 구조 및 상태 모양</target>
        </trans-unit>
        <trans-unit id="48ecb36ff00519ea4d9111bf2ac2c38ce3e8ee19" translate="yes" xml:space="preserve">
          <source>Basic State Shape</source>
          <target state="translated">기본 상태 모양</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="67b560207b812ce235458b82ba3b3eea9cb85612" translate="yes" xml:space="preserve">
          <source>Basics: Reducers</source>
          <target state="translated">기본 사항 : 감속기</target>
        </trans-unit>
        <trans-unit id="a2961743fb82ac508ead6cd89af32cac336e899e" translate="yes" xml:space="preserve">
          <source>Basics: Store</source>
          <target state="translated">기본 사항 : 상점</target>
        </trans-unit>
        <trans-unit id="ea6b5a053fcc90c8ddd2441e52e91ec4ca304fa6" translate="yes" xml:space="preserve">
          <source>Basics: Usage with React</source>
          <target state="translated">기본 사항 : React와 함께 사용</target>
        </trans-unit>
        <trans-unit id="ef57ae03011c7a88309c71ac3de4cd66803fca0f" translate="yes" xml:space="preserve">
          <source>Be aware that any &lt;code&gt;fetch&lt;/code&gt; polyfill assumes a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt; polyfill is already present. The easiest way to ensure you have a Promise polyfill is to enable Babel's ES6 polyfill in your entry point before any other code runs:</source>
          <target state="translated">어떤 것을주의 &lt;code&gt;fetch&lt;/code&gt; polyfill 가정 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;약속&lt;/a&gt; polyfill가 이미 존재합니다. Promise 폴리 필을 확보하는 가장 쉬운 방법은 다른 코드가 실행되기 전에 진입 점에서 Babel의 ES6 폴리 필을 활성화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8836be1ed6d14271d3616086c1165b69f0c93f5a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;combineReducers&lt;/code&gt; expects an object, we can put all top-level reducers into a separate file, &lt;code&gt;export&lt;/code&gt; each reducer function, and use &lt;code&gt;import * as reducers&lt;/code&gt; to get them as an object with their names as the keys:</source>
          <target state="translated">&lt;code&gt;combineReducers&lt;/code&gt; 는 객체를 기대 하기 때문에 모든 최상위 레벨 리듀서를 별도의 파일에 넣고 각 리듀서 함수를 &lt;code&gt;export&lt;/code&gt; &lt;code&gt;import * as reducers&lt;/code&gt; 로 사용하여 이름이 키인 객체로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e147dcc69ce5b11254e20a3d4069c3882333d6b2" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;import *&lt;/code&gt; is still new syntax, we don't use it anymore in the documentation to avoid &lt;a href=&quot;https://github.com/reactjs/redux/issues/428#issuecomment-129223274&quot;&gt;confusion&lt;/a&gt;, but you may encounter it in some community examples.</source>
          <target state="translated">때문에 &lt;code&gt;import *&lt;/code&gt; 새 구문은 여전히, 우리는 피하기로 문서에서 더 이상 사용하지 않는 &lt;a href=&quot;https://github.com/reactjs/redux/issues/428#issuecomment-129223274&quot;&gt;혼란&lt;/a&gt; ,하지만 당신은 몇 가지 사회 예제에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aaded217a4fa5a0be4aafbaa6515cc015511e79a" translate="yes" xml:space="preserve">
          <source>Because APIs frequently send back data in a nested form, that data needs to be transformed into a normalized shape before it can be included in the state tree. The &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;Normalizr&lt;/a&gt; library is usually used for this task. You can define schema types and relations, feed the schema and the response data to Normalizr, and it will output a normalized transformation of the response. That output can then be included in an action and used to update the store. See the Normalizr documentation for more details on its usage.</source>
          <target state="translated">API는 자주 중첩 형식으로 데이터를 다시 전송하므로 해당 데이터는 상태 트리에 포함되기 전에 정규화 된 형태로 변환해야합니다. &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;Normalizr의&lt;/a&gt; 라이브러리는 일반적으로이 작업에 사용됩니다. 스키마 유형 및 관계를 정의하고 스키마 및 응답 데이터를 Normalizr에 제공하면 응답의 정규화 된 변환이 출력됩니다. 그런 다음 해당 출력을 조치에 포함시키고 상점을 업데이트하는 데 사용할 수 있습니다. 사용법에 대한 자세한 내용은 Normalizr 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="36a6dc2449dbb96d53ee9fa9e5275f29a7f8733e" translate="yes" xml:space="preserve">
          <source>Because React-Redux performs a shallow check on the root state object to determine if its wrapped components need re-rendering or not, it will not be able to detect the state mutation, and so will not trigger a re-rendering.</source>
          <target state="translated">React-Redux는 루트 상태 객체에 대해 얕은 점검을 수행하여 래핑 된 구성 요소의 재 렌더링이 필요한지 여부를 판별하므로 상태 돌연변이를 감지 할 수 없으므로 재 렌더링을 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b4a1ac2348c56cde050b358a3589a1c8f14e121" translate="yes" xml:space="preserve">
          <source>Because a store is not an instance, but rather a plain-object collection of functions, copies can be easily created and modified without mutating the original store. There is an example in &lt;a href=&quot;api/compose&quot;&gt;&lt;code&gt;compose&lt;/code&gt;&lt;/a&gt; documentation demonstrating that.</source>
          <target state="translated">상점은 인스턴스가 아니라 일반 오브젝트 기능 콜렉션이므로 원래 상점을 변경하지 않고 사본을 쉽게 작성하고 수정할 수 있습니다. &lt;a href=&quot;api/compose&quot;&gt; &lt;code&gt;compose&lt;/code&gt; &lt;/a&gt; 설명서 에는이를 보여주는 예가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efed700df65d7fe9ccdceab1e7043b1b623a8ecf" translate="yes" xml:space="preserve">
          <source>Because each item is only defined in one place, we don't have to try to make changes in multiple places if that item is updated.</source>
          <target state="translated">각 항목은 한 곳에서만 정의되므로 해당 항목이 업데이트 된 경우 여러 곳을 변경하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="a5b2b72f48655aebb62d18b4c1e639b210169092" translate="yes" xml:space="preserve">
          <source>Because it is cumbersome to apply functions to &lt;code&gt;createStore()&lt;/code&gt; before using it, &lt;code&gt;createStore()&lt;/code&gt; accepts an optional last argument to specify such functions.</source>
          <target state="translated">&lt;code&gt;createStore()&lt;/code&gt; 함수를 사용하기 전에 함수를 적용하는 것은 번거롭기 때문에 &lt;code&gt;createStore()&lt;/code&gt; 는 이러한 함수를 지정하기 위해 선택적 마지막 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="7374d49a3a0384818d249cff5d9279f55237ab50" translate="yes" xml:space="preserve">
          <source>Because most of the Redux code you write are functions, and many of them are pure, they are easy to test without mocking.</source>
          <target state="translated">작성하는 대부분의 Redux 코드는 함수이고 대부분 순수하기 때문에 조롱하지 않고 쉽게 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2db4769be19da76af1b03eaa76cbae8155e656b" translate="yes" xml:space="preserve">
          <source>Because of these rules, it's important that the following core concepts are fully understood before moving on to other specific techniques for organizing Redux reducers:</source>
          <target state="translated">이러한 규칙으로 인해 Redux 감속기를 구성하기위한 다른 특정 기술로 넘어 가기 전에 다음 핵심 개념을 완전히 이해하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="1a3e08abcf6f4447aa880f7591ce54acac1d67d8" translate="yes" xml:space="preserve">
          <source>Because of this, the recommended approach to managing relational or nested data in a Redux store is to treat a portion of your store as if it were a database, and keep that data in a &lt;em&gt;normalized&lt;/em&gt; form.</source>
          <target state="translated">이 때문에 Redux 스토어에서 관계형 또는 중첩 데이터를 관리하는 데 권장되는 방법은 스토어의 일부를 데이터베이스 인 것처럼 취급하고 해당 데이터를 &lt;em&gt;정규화 된&lt;/em&gt; 형식으로 유지하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="2f6e614f93198c638fa57d23714abc7c8a4c5fe3" translate="yes" xml:space="preserve">
          <source>Because the client side executes ongoing code, it can start with an empty initial state and obtain any necessary state on demand and over time. On the server side, rendering is synchronous and we only get one shot to render our view. We need to be able to compile our initial state during the request, which will have to react to input and obtain external state (such as that from an API or database).</source>
          <target state="translated">클라이언트 측은 진행중인 코드를 실행하기 때문에 비어있는 초기 상태로 시작하여 요청시 및 시간에 따라 필요한 상태를 얻을 수 있습니다. 서버 측에서 렌더링은 동기식이며 뷰를 렌더링하기 위해 한 번만 촬영합니다. 요청 중에 초기 상태를 컴파일 할 수 있어야하며, 입력에 반응하고 외부 상태 (예 : API 또는 데이터베이스의 상태)를 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="4dad2f7397c12d16dc5080663b0fb4ff158a875b" translate="yes" xml:space="preserve">
          <source>Because the data from B's slice is already in the action, the parent reducer doesn't have to do anything special to make that data available to &lt;code&gt;sliceReducerA&lt;/code&gt;.</source>
          <target state="translated">B 슬라이스의 데이터가 이미 작업 중이므로 부모 감속기는 해당 데이터를 &lt;code&gt;sliceReducerA&lt;/code&gt; 에 사용할 수 있도록하기 위해 특별한 작업을 수행하지 않아도됩니다 .</target>
        </trans-unit>
        <trans-unit id="800eb8a2fa295362af6cbe9bc4b63ea94371aa6a" translate="yes" xml:space="preserve">
          <source>Because the store represents the core of your application, you should &lt;strong&gt;define your state shape in terms of your domain data and app state, not your UI component tree&lt;/strong&gt;. As an example, a shape of &lt;code&gt;state.leftPane.todoList.todos&lt;/code&gt; would be a bad idea, because the idea of &quot;todos&quot; is central to the whole application, not just a single part of the UI. The &lt;code&gt;todos&lt;/code&gt; slice should be at the top of the state tree instead.</source>
          <target state="translated">스토어는 애플리케이션의 핵심을 나타내 &lt;strong&gt;므로 UI ​​구성 요소 트리가 아닌 도메인 데이터 및 앱 상태 측면에서 상태 형태를 정의&lt;/strong&gt; 해야 &lt;strong&gt;합니다&lt;/strong&gt; . 예를 들어, &quot;todos&quot;라는 아이디어는 UI의 한 부분 만이 아니라 전체 응용 프로그램의 중심이기 때문에 &lt;code&gt;state.leftPane.todoList.todos&lt;/code&gt; 의 모양은 나쁜 생각입니다. &lt;code&gt;todos&lt;/code&gt; 조각 대신 상태 트리의 맨 위에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="67eccbeca2c6be1c80e66072cbdb7d5d3d171333" translate="yes" xml:space="preserve">
          <source>Because this pattern is so common, Redux provides the &lt;code&gt;combineReducers&lt;/code&gt; utility to implement that behavior. It is an example of a &lt;em&gt;higher-order reducer&lt;/em&gt;, which takes an object full of slice reducer functions, and returns a new reducer function.</source>
          <target state="translated">이 패턴은 매우 일반적이기 때문에 Redux는 그 동작을 구현하기 위해 &lt;code&gt;combineReducers&lt;/code&gt; 유틸리티를 제공합니다 . 슬라이스 리듀서 함수로 가득 찬 객체를 가져 와서 새로운 리듀서 함수를 반환하는 &lt;em&gt;고차 리듀서&lt;/em&gt; 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="18cc4aaf99d902742f5080c22e4e5772ca05908e" translate="yes" xml:space="preserve">
          <source>Because we call &lt;code&gt;res.send()&lt;/code&gt; inside of the callback, the server will hold open the connection and won't send any data until that callback executes. You'll notice a 500ms delay is now added to each server request as a result of our new API call. A more advanced usage would handle errors in the API gracefully, such as a bad response or timeout.</source>
          <target state="translated">콜백 내에서 &lt;code&gt;res.send()&lt;/code&gt; 호출하기 때문에 서버는 연결을 열어두고 콜백이 실행될 때까지 데이터를 보내지 않습니다. 새 API 호출의 결과로 각 서버 요청에 500ms 지연이 추가되었습니다. 고급 사용법은 잘못된 응답 또는 시간 초과와 같은 API의 오류를 정상적으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="caa8ca1f396e8cbad0408af4d219889981520bc2" translate="yes" xml:space="preserve">
          <source>Because we have introduced more code that relies on user generated content (UGC) and input, we have increased our attack surface area for our application. It is important for any application that you ensure your input is properly sanitized to prevent things like cross-site scripting (XSS) attacks or code injections.</source>
          <target state="translated">UGC (User Generated Content) 및 입력에 의존하는 더 많은 코드를 도입 했으므로 애플리케이션의 공격 영역이 늘어났습니다. XSS (Cross-Site Scripting) 공격이나 코드 삽입과 같은 것을 방지하기 위해 모든 응용 프로그램에서 입력이 제대로 위생 처리되도록하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="89b5658d0d258fae8a0f70dae9f8f133bd91b874" translate="yes" xml:space="preserve">
          <source>Because we want to update a specific item in the array without resorting to mutations, we have to create a new array with the same items except the item at the index. If you find yourself often writing such operations, it's a good idea to use a helper like &lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt;, &lt;a href=&quot;https://github.com/substantial/updeep&quot;&gt;updeep&lt;/a&gt;, or even a library like &lt;a href=&quot;http://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt; that has native support for deep updates. Just remember to never assign to anything inside the &lt;code&gt;state&lt;/code&gt; unless you clone it first.</source>
          <target state="translated">돌연변이에 의존하지 않고 배열의 특정 항목을 업데이트하려고하므로 인덱스의 항목을 제외하고 동일한 항목으로 새 배열을 만들어야합니다. 이러한 작업을 자주 작성하는 경우 &lt;a href=&quot;https://github.com/kolodny/immutability-helper&quot;&gt;immutability-helper&lt;/a&gt; , &lt;a href=&quot;https://github.com/substantial/updeep&quot;&gt;updeep&lt;/a&gt; 또는 깊은 업데이트를 기본적으로 지원하는 &lt;a href=&quot;http://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt; 같은 라이브러리 를 사용하는 것이 좋습니다 . 먼저 복제하지 않는 한 &lt;code&gt;state&lt;/code&gt; 내부에 아무것도 할당하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="455e818de94ba32708285358e0d09ee9d740229c" translate="yes" xml:space="preserve">
          <source>Because we're treating a portion of our Redux store as a &quot;database&quot;, many of the principles of database design also apply here as well. For example, if we have a many-to-many relationship, we can model that using an intermediate table that stores the IDs of the corresponding items (often known as a &quot;join table&quot; or an &quot;associative table&quot;). For consistency, we would probably also want to use the same &lt;code&gt;byId&lt;/code&gt; and &lt;code&gt;allIds&lt;/code&gt; approach that we used for the actual item tables, like this:</source>
          <target state="translated">Redux 저장소의 일부를 &quot;데이터베이스&quot;로 취급하기 때문에 데이터베이스 디자인의 많은 원칙들도 여기에 적용됩니다. 예를 들어 다 대 다 관계가있는 경우 해당 항목의 ID를 저장하는 중간 테이블 (종종 &quot;조인 테이블&quot;또는 &quot;연관 테이블&quot;이라고 함)을 사용하여 모델링 할 수 있습니다. 일관성을 유지 하기 위해 실제 항목 테이블에 사용한 것과 동일한 &lt;code&gt;byId&lt;/code&gt; 및 &lt;code&gt;allIds&lt;/code&gt; 접근 방식 을 사용하려고 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1304b4245c2ff85f0675fea297cb7677812a916" translate="yes" xml:space="preserve">
          <source>Because writing immutable update code can become tedious, there are a number of utility libraries that try to abstract out the process. These libraries vary in APIs and usage, but all try to provide a shorter and more succinct way of writing these updates. Some, like &lt;a href=&quot;https://github.com/debitoor/dot-prop-immutable&quot;&gt;dot-prop-immutable&lt;/a&gt;, take string paths for commands:</source>
          <target state="translated">변경 불가능한 업데이트 코드 작성은 지루할 수 있으므로 프로세스를 추상화하려는 여러 유틸리티 라이브러리가 있습니다. 이 라이브러리는 API와 사용법이 다양하지만 모두이 업데이트를 작성하는 더 짧고 간결한 방법을 제공하려고합니다. &lt;a href=&quot;https://github.com/debitoor/dot-prop-immutable&quot;&gt;dot-prop-immutable&lt;/a&gt; 과 같은 일부 명령에는 문자열 경로가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9d3e7f54e625439ca3447fdc7a9117ae5fab1524" translate="yes" xml:space="preserve">
          <source>Because you must access your data via Immutable.JS&amp;rsquo;s own &lt;code&gt;get()&lt;/code&gt; and &lt;code&gt;getIn()&lt;/code&gt; methods, you can no longer use JavaScript&amp;rsquo;s destructuring operator (or the proposed Object spread operator), making your code more verbose.</source>
          <target state="translated">Immutable.JS 자체 &lt;code&gt;get()&lt;/code&gt; 및 &lt;code&gt;getIn()&lt;/code&gt; 메소드 를 통해 데이터에 액세스해야하므로 더 이상 JavaScript의 소멸 연산자 (또는 제안 된 Object spread 연산자)를 사용할 수 없으므로 코드가 더 장황 해집니다.</target>
        </trans-unit>
        <trans-unit id="1437822723995215deb0d2e2fac29d0d0f12fcf2" translate="yes" xml:space="preserve">
          <source>Before Proceeding Further</source>
          <target state="translated">더 진행하기 전에</target>
        </trans-unit>
        <trans-unit id="8d6d48764a855d1815031363486f3cea75e828c9" translate="yes" xml:space="preserve">
          <source>Before creating a UI for our todo app, we will take a detour to see &lt;a href=&quot;dataflow&quot;&gt;how the data flows in a Redux application&lt;/a&gt;.</source>
          <target state="translated">todo 앱용 UI를 만들기 전에 &lt;a href=&quot;dataflow&quot;&gt;Redux 애플리케이션에서 데이터가 어떻게 흐르는 지 알아&lt;/a&gt; 보기 위해 우회를 합니다 .</target>
        </trans-unit>
        <trans-unit id="4e97a45859979361b3d87b280bcc08eee9084a8f" translate="yes" xml:space="preserve">
          <source>Before going into the details of dispatching actions together with network requests, we will write the reducers for the actions we defined above.</source>
          <target state="translated">네트워크 요청과 함께 작업 디스패치에 대한 세부 정보로 이동하기 전에 위에서 정의한 작업에 대한 감속기를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="89cb49f87c14fc3ef664ffd5fd8fb507d546a513" translate="yes" xml:space="preserve">
          <source>Before integrating React Router, we need to configure our development server. Indeed, our development server may be unaware of the declared routes in React Router configuration. For example, if you access &lt;code&gt;/todos&lt;/code&gt; and refresh, your development server needs to be instructed to serve &lt;code&gt;index.html&lt;/code&gt; because it is a single-page app. Here's how to enable this with popular development servers.</source>
          <target state="translated">React Router를 통합하기 전에 개발 서버를 구성해야합니다. 실제로 개발 서버는 React Router 구성에서 선언 된 경로를 인식하지 못할 수 있습니다. 예를 들어, &lt;code&gt;/todos&lt;/code&gt; 에 액세스 하고 새로 고치면 개발 서버 는 단일 페이지 앱이므로 &lt;code&gt;index.html&lt;/code&gt; 을 제공하도록 지시해야 합니다. 널리 사용되는 개발 서버에서이를 활성화하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f29fca44a9a66689242d9b6ac45e9273f69c5781" translate="yes" xml:space="preserve">
          <source>Before proceeding, make sure you have worked through the &lt;a href=&quot;../basics/index&quot;&gt;basics tutorial&lt;/a&gt; and understand &lt;a href=&quot;../basics/reducers&quot;&gt;reducer composition&lt;/a&gt; well. This recipe will build on top of the example described in the &lt;a href=&quot;../basics/index&quot;&gt;basics tutorial&lt;/a&gt;.</source>
          <target state="translated">계속하기 전에 &lt;a href=&quot;../basics/index&quot;&gt;기본 학습서&lt;/a&gt; 를 수행하고 &lt;a href=&quot;../basics/reducers&quot;&gt;감속기 구성을&lt;/a&gt; 잘 이해 했는지 확인하십시오 . 이 레시피는 &lt;a href=&quot;../basics/index&quot;&gt;기본 학습서에&lt;/a&gt; 설명 된 예제 위에 빌드됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7d28bda5a65bfffaaaaaeb2efbace54d5ae5ed7" translate="yes" xml:space="preserve">
          <source>Below is a sub-app's root connected component. As usual, it can render more components, connected or not, as children. Usually we'd render it in &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; and be done with it.</source>
          <target state="translated">아래는 하위 앱의 루트 연결 구성 요소입니다. 일반적으로 연결 여부에 관계없이 더 많은 구성 요소를 자식으로 렌더링 할 수 있습니다. 일반적으로 &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; 에서 렌더링하고 완료합니다.</target>
        </trans-unit>
        <trans-unit id="2e9f60bf8e76871398ccbe5dae2fb65d17f44468" translate="yes" xml:space="preserve">
          <source>Below our imports, let's use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6 Object Destructuring&lt;/a&gt; to declare &lt;code&gt;SHOW_ALL&lt;/code&gt;:</source>
          <target state="translated">가져 오기 아래에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;ES6 Object Destructuring&lt;/a&gt; 을 사용 하여 &lt;code&gt;SHOW_ALL&lt;/code&gt; 을 선언 하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="f1091ed2655d47790d04e490d5a912d61726fb58" translate="yes" xml:space="preserve">
          <source>Beyond &lt;code&gt;combineReducers&lt;/code&gt;</source>
          <target state="translated">넘어 &lt;code&gt;combineReducers&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b9a230925015b13c4b708f594107fd333941631" translate="yes" xml:space="preserve">
          <source>Beyond combineReducers</source>
          <target state="translated">결합을 넘어서</target>
        </trans-unit>
        <trans-unit id="edb5455f2581d21229bb831350698f3307569b49" translate="yes" xml:space="preserve">
          <source>Beyond that, Redux does not really care how you actually structure your logic inside that reducer function, as long as it obeys those basic rules. This is both a source of freedom and a source of confusion. However, there are a number of common patterns that are widely used when writing reducers, as well as a number of related topics and concepts to be aware of. As an application grows, these patterns play a crucial role in managing reducer code complexity, handling real-world data, and optimizing UI performance.</source>
          <target state="translated">그 외에도 Redux는 기본 규칙을 준수하는 한 리듀서 기능 내에서 실제로 논리를 구성하는 방법을 실제로 신경 쓰지 않습니다. 이것은 자유의 근원이자 혼란의 근원입니다. 그러나 감속기를 작성할 때 널리 사용되는 여러 가지 공통 패턴과 알아야 할 여러 관련 주제 및 개념이 있습니다. 애플리케이션이 성장함에 따라 이러한 패턴은 리듀서 코드 복잡성을 관리하고 실제 데이터를 처리하며 UI 성능을 최적화하는 데 중요한 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="71ce0037a118cd7c3ccf4f303af279bf29aedd37" translate="yes" xml:space="preserve">
          <source>Bill Fisher, author of Flux documentation</source>
          <target state="translated">Flux 문서 작성자 Bill Fisher</target>
        </trans-unit>
        <trans-unit id="967382f86044b6efc91dfee8f4e2b4ed941211cd" translate="yes" xml:space="preserve">
          <source>Bindings</source>
          <target state="translated">Bindings</target>
        </trans-unit>
        <trans-unit id="5d13d6793ab60c41828ba3fe82788c57381b56b3" translate="yes" xml:space="preserve">
          <source>Both Redux and React-Redux employ &lt;a href=&quot;#shallow-and-deep-equality-checking&quot;&gt;shallow equality checking&lt;/a&gt;. In particular:</source>
          <target state="translated">Redux와 React-Redux는 &lt;a href=&quot;#shallow-and-deep-equality-checking&quot;&gt;모두 얕은 동등성 검사를 사용&lt;/a&gt; 합니다. 특히:</target>
        </trans-unit>
        <trans-unit id="58fcb9748d292f2d6edabc1dd2871e078a69f72c" translate="yes" xml:space="preserve">
          <source>Breaking down a complex process into smaller, more understandable parts is usually described with the term &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://stackoverflow.com/questions/947874/what-is-functional-decomposition&quot;&gt;functional decomposition&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;. This term and concept can be applied generically to any code. However, in Redux it is &lt;em&gt;very&lt;/em&gt; common to structure reducer logic using approach #3, where update logic is delegated to other functions based on slice of state. Redux refers to this concept as &lt;strong&gt;&lt;em&gt;reducer composition&lt;/em&gt;&lt;/strong&gt;, and it is by far the most widely-used approach to structuring reducer logic. In fact, it's so common that Redux includes a utility function called &lt;a href=&quot;../../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt;, which specifically abstracts the process of delegating work to other reducer functions based on slices of state. However, it's important to note that it is not the &lt;em&gt;only&lt;/em&gt; pattern that can be used. In fact, it's entirely possible to use all three approaches for splitting up logic into functions, and usually a good idea as well. The &lt;a href=&quot;refactoringreducersexample&quot;&gt;Refactoring Reducers&lt;/a&gt; section shows some examples of this in action.</source>
          <target state="translated">복잡한 프로세스를 더 작고 이해하기 쉬운 부분으로 나누는 것은 일반적으로 &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://stackoverflow.com/questions/947874/what-is-functional-decomposition&quot;&gt;기능 분해&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; 라는 용어로 설명됩니다 . 이 용어와 개념은 모든 코드에 일반적으로 적용될 수 있습니다. 그러나 Redux에서는 접근 방식 # 3을 사용하여 감속기 로직을 ​​구성 하는 것이 &lt;em&gt;매우&lt;/em&gt; 일반적입니다. Redux는이 개념을 &lt;strong&gt;&lt;em&gt;리듀서 구성이라고&lt;/em&gt;&lt;/strong&gt; 하며, 리듀서 로직을 구성하는 데 가장 널리 사용되는 방법입니다. 실제로, Redux에는 &lt;a href=&quot;../../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt; 라는 유틸리티 함수가 포함되어있어 매우 일반적입니다 .이 함수는 상태 조각에 따라 다른 리듀서 함수에 작업을 위임하는 프로세스를 구체적으로 추상화합니다. 그러나 그것이 아니라는 점에 유의하는 것이 중요합니다.&lt;em&gt;&lt;/em&gt;사용할 수있는 패턴 &lt;em&gt;만 &lt;/em&gt;사실, 논리를 함수로 분할하기 위해 세 가지 접근 방식을 모두 사용할 수 있으며 일반적으로 좋은 생각입니다. &lt;a href=&quot;refactoringreducersexample&quot;&gt;리팩토링 기어&lt;/a&gt; 부분은 행동이 몇 가지 예를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="d1a2bc21cb4d822c367054d8beedc9e473cb922f" translate="yes" xml:space="preserve">
          <source>Breaks object references, causing poor performance</source>
          <target state="translated">객체 참조를 중단하여 성능 저하</target>
        </trans-unit>
        <trans-unit id="2ef955a1c06a7555c0b9124c858d0b7015c595f2" translate="yes" xml:space="preserve">
          <source>Build an Image Gallery Using Redux Saga</source>
          <target state="translated">Redux Saga를 사용하여 이미지 갤러리 구축</target>
        </trans-unit>
        <trans-unit id="044820df0cc9603893652b00eab09f2633843854" translate="yes" xml:space="preserve">
          <source>Building Efficient UI with React and Redux</source>
          <target state="translated">React와 Redux로 효율적인 UI 구축</target>
        </trans-unit>
        <trans-unit id="52676a6b3cadf32f94e36a184ab697e39fb7e4cf" translate="yes" xml:space="preserve">
          <source>Building an Undo and Redo functionality into an app has traditionally required conscious effort from the developer. It is not an easy problem with classical MVC frameworks because you need to keep track of every past state by cloning all relevant models. In addition, you need to be mindful of the undo stack because the user-initiated changes should be undoable.</source>
          <target state="translated">실행 취소 및 다시 실행 기능을 앱에 빌드하려면 전통적으로 개발자의 의식적인 노력이 필요했습니다. 모든 관련 모델을 복제하여 모든 과거 상태를 추적해야하므로 클래식 MVC 프레임 워크에서는 쉬운 문제가 아닙니다. 또한 사용자가 시작한 변경 사항을 취소 할 수 있어야하므로 실행 취소 스택에주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="5216ed259778329413571d3d5d7a100b3609532a" translate="yes" xml:space="preserve">
          <source>But the result is pretty vanilla. It essentially renders a static view from dynamic code. What we need to do next is build an initial state dynamically to allow that rendered view to be dynamic.</source>
          <target state="translated">그러나 결과는 꽤 바닐라입니다. 기본적으로 동적 코드에서 정적 뷰를 렌더링합니다. 다음에해야 할 일은 렌더링 된 뷰가 동적이되도록 초기 상태를 동적으로 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c6630c4ba113b66e638acb13afa2a0da5838bc4c" translate="yes" xml:space="preserve">
          <source>But there's also a different way to enable chaining. The middleware could accept the &lt;code&gt;next()&lt;/code&gt; dispatch function as a parameter instead of reading it from the &lt;code&gt;store&lt;/code&gt; instance.</source>
          <target state="translated">그러나 체인을 활성화하는 다른 방법도 있습니다. 미들웨어는 &lt;code&gt;next()&lt;/code&gt; 디스패치 함수를 &lt;code&gt;store&lt;/code&gt; 인스턴스 에서 읽는 대신 매개 변수로 승인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dee896ae234e12cac8b3cbc6f4a57f568f7c5f7" translate="yes" xml:space="preserve">
          <source>By assuming the wrapped component is pure, it need only check whether the root state object or the values returned from &lt;code&gt;mapStateToProps&lt;/code&gt; have changed. If they haven&amp;rsquo;t, the wrapped component does not need re-rendering.</source>
          <target state="translated">랩핑 된 컴포넌트가 순수하다고 가정하면 루트 상태 오브젝트 또는 &lt;code&gt;mapStateToProps&lt;/code&gt; 에서 리턴 된 값 이 변경 되었는지 여부 만 확인하면됩니다 . 그렇지 않은 경우 래핑 된 구성 요소는 다시 렌더링 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c04d1941187625b0fce5ba887317fb2d3821a0a2" translate="yes" xml:space="preserve">
          <source>By convention, the top-level state is an object or some other key-value collection like a Map, but technically it can be any type. Still, you should do your best to keep the state serializable. Don't put anything inside it that you can't easily turn into JSON.</source>
          <target state="translated">일반적으로 최상위 상태는 객체 또는지도와 같은 다른 키-값 모음이지만 기술적으로는 모든 유형이 될 수 있습니다. 여전히 상태를 직렬화 할 수 있도록 최선을 다해야합니다. JSON으로 쉽게 전환 할 수없는 내용을 넣지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ee52434982b2c6a75c2a9dc316e303887dd2c213" translate="yes" xml:space="preserve">
          <source>By converting Immutable.JS objects to plain JavaScript values within a HOC, we achieve Dumb Component portability, but without the performance hits of using &lt;code&gt;toJS()&lt;/code&gt; in the Smart Component.</source>
          <target state="translated">HOC 내에서 Immutable.JS 객체를 일반 JavaScript 값으로 변환함으로써, 우리는 Dumb Component 이식성을 달성하지만 Smart Component에서 &lt;code&gt;toJS()&lt;/code&gt; 를 사용하는 성능에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="14c208d300198acc2bee9f79ece564c973b4032d" translate="yes" xml:space="preserve">
          <source>By hand</source>
          <target state="translated">손으로</target>
        </trans-unit>
        <trans-unit id="678ffdd0e7329a441eacb0cada63caaeb00de544" translate="yes" xml:space="preserve">
          <source>Call non-pure functions, e.g. &lt;code&gt;Date.now()&lt;/code&gt; or &lt;code&gt;Math.random()&lt;/code&gt;.</source>
          <target state="translated">순수하지 않은 함수 (예 : &lt;code&gt;Date.now()&lt;/code&gt; 또는 &lt;code&gt;Math.random()&lt;/code&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="514ecbbb081ae5bb804b5d148470b70893486e4e" translate="yes" xml:space="preserve">
          <source>Calling an action creator only produces an action, but does not dispatch it. You need to call the store's &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; function to actually cause the mutation. Sometimes we say &lt;em&gt;bound action creators&lt;/em&gt; to mean functions that call an action creator and immediately dispatch its result to a specific store instance.</source>
          <target state="translated">액션 생성자를 호출하면 액션 만 생성되지만 전달하지는 않습니다. 실제로 돌연변이를 일으키려면 상점의 &lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 함수 를 호출해야합니다 . 때때로 우리는 &lt;em&gt;활동 작성자&lt;/em&gt; 를 &lt;em&gt;조치 작성자&lt;/em&gt; 를 호출하고 결과를 특정 상점 인스턴스로 즉시 발송하는 함수를 의미 한다고 말합니다 .</target>
        </trans-unit>
        <trans-unit id="cc88550e4ec686048f4441cff525112f12fef17b" translate="yes" xml:space="preserve">
          <source>Can I put functions, promises, or other non-serializable items in my store state?</source>
          <target state="translated">상점 상태에 기능, 약속 또는 기타 직렬화 불가능 항목을 넣을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="bc9efb799599b448719604b39fc5d1dd267fac1f" translate="yes" xml:space="preserve">
          <source>Can Redux be considered a &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt; implementation?</source>
          <target state="translated">Redux를 &lt;a href=&quot;https://facebook.github.io/flux/&quot;&gt;Flux&lt;/a&gt; 구현 으로 간주 할 수 있습니까 ?</target>
        </trans-unit>
        <trans-unit id="3c8f18450288bb51e46e5292d22da2305a2ead78" translate="yes" xml:space="preserve">
          <source>Can Redux only be used with React?</source>
          <target state="translated">Redux는 React에서만 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="ac9b06faebbc4bb435ce5bb7eca38ff4df6ae262" translate="yes" xml:space="preserve">
          <source>Can or should I create multiple stores? Can I import my store directly, and use it in components myself?</source>
          <target state="translated">여러 상점을 작성할 수 있습니까? 상점을 직접 가져 와서 구성 요소에서 직접 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="afc46e42066f8c38a155fdc1d793218fd0742077" translate="yes" xml:space="preserve">
          <source>Certain immutable operations, such as an Array filter, will always return a new object, even if the values themselves have not changed.</source>
          <target state="translated">배열 필터와 같은 특정 변경 불가능한 작업은 값 자체가 변경되지 않은 경우에도 항상 새 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9c74fb571984d7f3e781ea8b013e5f74bcd16389" translate="yes" xml:space="preserve">
          <source>Change Log</source>
          <target state="translated">변경 로그</target>
        </trans-unit>
        <trans-unit id="77d62200bb4808e2c757f43ffc9e34e38db2f83c" translate="yes" xml:space="preserve">
          <source>Changes are made with pure functions</source>
          <target state="translated">순수한 기능으로 변경</target>
        </trans-unit>
        <trans-unit id="a7e5e5888a0251d8e42a2303b77a969291cfff57" translate="yes" xml:space="preserve">
          <source>Chat log: React/Redux perf - single connection vs many connections</source>
          <target state="translated">채팅 로그 : React / Redux perf-단일 연결 대 많은 연결</target>
        </trans-unit>
        <trans-unit id="02882aae8c97d845e545938dbe2741732079d319" translate="yes" xml:space="preserve">
          <source>Chat log: React/Redux perf - updating a 10K-item Todo list</source>
          <target state="translated">채팅 로그 : React / Redux perf-10K 항목 할일 목록 업데이트</target>
        </trans-unit>
        <trans-unit id="590f1d62228e7b6962e715956c59522b152fc9a5" translate="yes" xml:space="preserve">
          <source>Check out &lt;a href=&quot;exampleredditapi&quot;&gt;the full source code for the async example&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;exampleredditapi&quot;&gt;비동기 예제에 대한 전체 소스 코드를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ca51c480d481c131ddccd6e3c2ee749821089b7" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;official documentation&lt;/a&gt; of Reselect as well as its &lt;a href=&quot;https://github.com/reactjs/reselect#faq&quot;&gt;FAQ&lt;/a&gt;. Most Redux projects start using Reselect when they have performance problems because of too many derived computations and wasted re-renders, so make sure you are familiar with it before you build something big. It can also be useful to study &lt;a href=&quot;https://github.com/reactjs/reselect/blob/master/src/index.js&quot;&gt;its source code&lt;/a&gt; so you don't think it's magic.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/reselect#faq&quot;&gt;FAQ&lt;/a&gt; 와 함께 Reselect 의 &lt;a href=&quot;https://github.com/reactjs/reselect&quot;&gt;공식 문서&lt;/a&gt; 를 확인하십시오 . 대부분의 Redux 프로젝트는 너무 많은 파생 계산으로 인해 성능 문제가 발생하고 다시 렌더링을 낭비 할 때 Reselect를 사용하기 시작합니다. 따라서 큰 것을 만들기 전에 잘 알고 있어야합니다. 또한 &lt;a href=&quot;https://github.com/reactjs/reselect/blob/master/src/index.js&quot;&gt;소스 코드&lt;/a&gt; 를 연구 하는 것이 유용 하므로 마술이라고 생각하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7064940db7a1d0a8ad078f4933ca03bdf4384538" translate="yes" xml:space="preserve">
          <source>Choosing whether to use a single action type with flags, or multiple action types, is up to you. It's a convention you need to decide with your team. Multiple types leave less room for a mistake, but this is not an issue if you generate action creators and reducers with a helper library like &lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt;.</source>
          <target state="translated">플래그와 함께 단일 조치 유형을 사용할지 또는 여러 조치 유형을 사용할지 선택하는 것은 전적으로 사용자의 몫입니다. 팀과 함께 결정해야하는 규칙입니다. 다중 유형은 실수의 여지가 적지 만, &lt;a href=&quot;https://github.com/acdlite/redux-actions&quot;&gt;redux-actions&lt;/a&gt; 와 같은 헬퍼 라이브러리를 사용하여 조치 작성자와 감속기를 생성하는 경우에는 문제가되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a35b138959cf52724c7ecc764f2581e2505e1033" translate="yes" xml:space="preserve">
          <source>Chris Dhanaraj</source>
          <target state="translated">크리스 다나 라즈</target>
        </trans-unit>
        <trans-unit id="4da30b8b6589341c1c5097e2b6d732339256659a" translate="yes" xml:space="preserve">
          <source>Clear the &lt;code&gt;future&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;future&lt;/code&gt; 맑게하십시오 .</target>
        </trans-unit>
        <trans-unit id="794ceaaa1771a4243afa4d673ab5434968292b2a" translate="yes" xml:space="preserve">
          <source>Cloning Objects in JavaScript</source>
          <target state="translated">JavaScript에서 객체 복제</target>
        </trans-unit>
        <trans-unit id="9d6b5f970ace9ba53ad9e45c0384561f1183fe5b" translate="yes" xml:space="preserve">
          <source>Code Structure</source>
          <target state="translated">코드 구조</target>
        </trans-unit>
        <trans-unit id="7a44af612fdee0de4619ce06d349d983c763c717" translate="yes" xml:space="preserve">
          <source>Combined Reducers</source>
          <target state="translated">결합 감속기</target>
        </trans-unit>
        <trans-unit id="138eb4fb8cbab09f3102a4bdc497d150d119b26b" translate="yes" xml:space="preserve">
          <source>Combining Reducers by Slice</source>
          <target state="translated">슬라이스로 감속기 결합</target>
        </trans-unit>
        <trans-unit id="58fca950b17f3d83e4dea581789d811359b5f26a" translate="yes" xml:space="preserve">
          <source>Common Mistake #1: New variables that point to the same objects</source>
          <target state="translated">일반적인 실수 # 1 : 동일한 객체를 가리키는 새로운 변수</target>
        </trans-unit>
        <trans-unit id="9bac9c6f37df3c3c4497667d13578b5087f6d70e" translate="yes" xml:space="preserve">
          <source>Common Mistake #2: Only making a shallow copy of one level</source>
          <target state="translated">일반적인 실수 # 2 : 한 수준의 얕은 사본 만 만들기</target>
        </trans-unit>
        <trans-unit id="5f3d6c44bf5df710ea25006914bb1e40d2ecbb97" translate="yes" xml:space="preserve">
          <source>Common Redux misconception: you need to deeply clone the state. Reality: if something inside doesn't change, keep its reference the same!</source>
          <target state="translated">일반적인 Redux 오해 : 상태를 깊게 복제해야합니다. 현실 : 내부의 내용이 바뀌지 않으면 참조를 동일하게 유지하십시오!</target>
        </trans-unit>
        <trans-unit id="1b43008657b57fe78508382a4b9fb02fb7841e4e" translate="yes" xml:space="preserve">
          <source>Community Conventions</source>
          <target state="translated">커뮤니티 컨벤션</target>
        </trans-unit>
        <trans-unit id="6ba5570bcfc57cb0bf4fe0a9702c06fc5228b4ab" translate="yes" xml:space="preserve">
          <source>Complementary Packages</source>
          <target state="translated">보완 패키지</target>
        </trans-unit>
        <trans-unit id="9289473eeedaee09d76c8cf1b6994d8550debf46" translate="yes" xml:space="preserve">
          <source>Components</source>
          <target state="translated">Components</target>
        </trans-unit>
        <trans-unit id="32506a4d4827f751f805be2f6a54fe8754849b64" translate="yes" xml:space="preserve">
          <source>Components will both re-render when they shouldn&amp;rsquo;t, and refuse to render when they should, and tracking down the bug causing the rendering issue is hard, as the component rendering incorrectly is not necessarily the one whose properties are being accidentally mutated.</source>
          <target state="translated">구성 요소는 렌더링하지 않아야 할 때 다시 렌더링하고 렌더링을 거부하며 렌더링 문제를 일으키는 버그를 추적하는 것은 어렵습니다. 구성 요소 렌더링이 잘못되어 속성이 실수로 변경되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="837b57a8ec5e9af95ffd6545daebb1d24962188f" translate="yes" xml:space="preserve">
          <source>Composes functions from right to left.</source>
          <target state="translated">오른쪽에서 왼쪽으로 기능을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="8e0c107b8e98df1c854ed1c7dcb3a98dc7c2ca76" translate="yes" xml:space="preserve">
          <source>Composing Selectors</source>
          <target state="translated">구성 선택기</target>
        </trans-unit>
        <trans-unit id="f0d42401ef57fab1331c6965711b20a87c5ddbf4" translate="yes" xml:space="preserve">
          <source>Computing Derived Data</source>
          <target state="translated">파생 데이터 계산</target>
        </trans-unit>
        <trans-unit id="7daf13b1f60fb4af3d6921cd3bc4aced67ab5a7a" translate="yes" xml:space="preserve">
          <source>Configuring Express</source>
          <target state="translated">Express 구성</target>
        </trans-unit>
        <trans-unit id="67a9e1acb14192d9b8d0b21f21976859dd578df3" translate="yes" xml:space="preserve">
          <source>Configuring WebpackDevServer</source>
          <target state="translated">WebpackDevServer 구성</target>
        </trans-unit>
        <trans-unit id="fde5035ac1fcc8de232b7bed3503337cd6eb9f66" translate="yes" xml:space="preserve">
          <source>Configuring the Fallback URL</source>
          <target state="translated">대체 URL 구성</target>
        </trans-unit>
        <trans-unit id="87a9853dc1b73b96e2f86ff4c803e9204d6d4b12" translate="yes" xml:space="preserve">
          <source>Connected Components</source>
          <target state="translated">연결된 컴포넌트</target>
        </trans-unit>
        <trans-unit id="8e80b5ae124a108d4cae25b4b8f529572912388e" translate="yes" xml:space="preserve">
          <source>Connecting React Router with Redux App</source>
          <target state="translated">Redux 앱과 반응 라우터 연결</target>
        </trans-unit>
        <trans-unit id="a6a0e3b241efd3e93742236b45d8493d0e6fee30" translate="yes" xml:space="preserve">
          <source>Connecting a Selector to the Redux Store</source>
          <target state="translated">선택기를 Redux Store에 연결</target>
        </trans-unit>
        <trans-unit id="87209e0d1e9b53b5fe4772baab86c7a792f26231" translate="yes" xml:space="preserve">
          <source>Connecting to UI</source>
          <target state="translated">UI에 연결</target>
        </trans-unit>
        <trans-unit id="9a52a37a64378cb1a98da0406ef6404fd0218774" translate="yes" xml:space="preserve">
          <source>Consequently, the state object will look like this:</source>
          <target state="translated">결과적으로 상태 객체는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b825bc561f6b5b1f75c29d0f875286a593d7b365" translate="yes" xml:space="preserve">
          <source>Consider the case of a &amp;ldquo;big&amp;rdquo; app (contained in a &lt;code&gt;&amp;lt;BigApp&amp;gt;&lt;/code&gt; component) that embeds smaller &amp;ldquo;sub-apps&amp;rdquo; (contained in &lt;code&gt;&amp;lt;SubApp&amp;gt;&lt;/code&gt; components):</source>
          <target state="translated">작은 &quot;서브 앱&quot;( &lt;code&gt;&amp;lt;SubApp&amp;gt;&lt;/code&gt; 서브 앱 &lt;code&gt;&amp;lt;BigApp&amp;gt;&lt;/code&gt; 컴포넌트에 포함)을 포함하는 &quot;빅&quot;앱 ( &amp;lt;빅앱&amp;gt; 컴포넌트에 포함) 의 경우를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="66b9b7c93fb54ebed199da9fee98590876d2817b" translate="yes" xml:space="preserve">
          <source>Consider the code above rewritten with &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk로&lt;/a&gt; 다시 작성된 위의 코드를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ca273c094d939aa568e917155d75b414ea13292" translate="yes" xml:space="preserve">
          <source>Consider the following &lt;code&gt;App&lt;/code&gt; component:</source>
          <target state="translated">다음 &lt;code&gt;App&lt;/code&gt; 구성 요소를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="70e99e62d50531f0a2f738cbf8aa0173b646e44a" translate="yes" xml:space="preserve">
          <source>Consider this Flux store:</source>
          <target state="translated">이 Flux 상점을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4f9f7bad9d1734680439f0676a170b5a673dfd79" translate="yes" xml:space="preserve">
          <source>Container Components</source>
          <target state="translated">컨테이너 구성 요소</target>
        </trans-unit>
        <trans-unit id="d0dfb089b89fb29b825328110a2e11b4f94fb034" translate="yes" xml:space="preserve">
          <source>Conversely, in this next example (below), the component will &lt;em&gt;always&lt;/em&gt; re-render, as the value of &lt;code&gt;todos&lt;/code&gt; is always a new object, regardless of whether or not its values change:</source>
          <target state="translated">반대로이 다음 예 (아래)에서는 &lt;code&gt;todos&lt;/code&gt; 값이 값 변경 여부에 관계없이 항상 새 객체이므로 구성 요소가 &lt;em&gt;항상&lt;/em&gt; 다시 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="29636c1eb55c51788d0bfe80405463c52281956d" translate="yes" xml:space="preserve">
          <source>Converting an Immutable.JS object to a JavaScript object using &lt;code&gt;toJS()&lt;/code&gt; will return a new object every time. If you do this in &lt;code&gt;mapStateToProps&lt;/code&gt;, you will cause the component to believe that the object has changed every time the state tree changes, and so trigger an unnecessary re-render.</source>
          <target state="translated">&lt;code&gt;toJS()&lt;/code&gt; 를 사용하여 Immutable.JS 객체를 JavaScript 객체로 변환하면 매번 새 객체가 반환됩니다. &lt;code&gt;mapStateToProps&lt;/code&gt; 에서이 작업을 수행 하면 구성 요소가 상태 트리가 변경 될 때마다 객체가 변경되었다고 믿게되므로 불필요한 다시 렌더링이 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="93a1d53292581775a7aefd7eb2070e8afcd74765" translate="yes" xml:space="preserve">
          <source>Copying objects using functions like &lt;code&gt;Object.assign()&lt;/code&gt; or &lt;code&gt;_.extend()&lt;/code&gt;, and array functions such as &lt;code&gt;slice()&lt;/code&gt; and &lt;code&gt;concat()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Object.assign()&lt;/code&gt; 또는 &lt;code&gt;_.extend()&lt;/code&gt; 같은 함수와 &lt;code&gt;slice()&lt;/code&gt; 및 &lt;code&gt;concat()&lt;/code&gt; 같은 배열 함수를 사용하여 객체 복사</target>
        </trans-unit>
        <trans-unit id="c872753511d558c4ce512746cf585786dd025a3c" translate="yes" xml:space="preserve">
          <source>Core Concepts</source>
          <target state="translated">핵심 개념</target>
        </trans-unit>
        <trans-unit id="ef8e6e4e0586b33e3404668e2c83565be91e5463" translate="yes" xml:space="preserve">
          <source>Correct Approach: Copying All Levels of Nested Data</source>
          <target state="translated">올바른 접근 방법 : 모든 수준의 중첩 데이터 복사</target>
        </trans-unit>
        <trans-unit id="f4018045cfb458b2734d2b09cf762c2567878c41" translate="yes" xml:space="preserve">
          <source>Counter</source>
          <target state="translated">Counter</target>
        </trans-unit>
        <trans-unit id="ee249667a9d59781bd41e030d27e2c1188c37ed0" translate="yes" xml:space="preserve">
          <source>Counter Vanilla</source>
          <target state="translated">바닐라 카운터</target>
        </trans-unit>
        <trans-unit id="626a2643ba405040e97390410d4230e265e4259f" translate="yes" xml:space="preserve">
          <source>Create a function called &lt;code&gt;createFluxStore(reducer)&lt;/code&gt; that creates a Flux store compatible with your existing app from a reducer function. Internally it might look similar to &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://github.com/reactjs/redux/blob/master/src/createStore.js&quot;&gt;source&lt;/a&gt;) implementation from Redux. Its dispatch handler should just call the &lt;code&gt;reducer&lt;/code&gt; for any action, store the next state, and emit change.</source>
          <target state="translated">감속기 함수에서 기존 앱과 호환되는 Flux 저장소를 만드는 &lt;code&gt;createFluxStore(reducer)&lt;/code&gt; 라는 함수 를 만듭니다. 내부적으로 는 Redux의 &lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://github.com/reactjs/redux/blob/master/src/createStore.js&quot;&gt;source&lt;/a&gt; ) 구현 과 유사 할 수 있습니다 . 디스패치 핸들러는 모든 액션에 대해 &lt;code&gt;reducer&lt;/code&gt; 를 호출 하고 다음 상태를 저장하고 변경을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="f00d5c6bc58d02ae5cd2c0877a6310c7f5c5ba39" translate="yes" xml:space="preserve">
          <source>Create a reducer that returns the next state for each possible authentication case (&lt;code&gt;LOGIN_SUCCESS&lt;/code&gt;, &lt;code&gt;LOGIN_FAILURE&lt;/code&gt;, etc).</source>
          <target state="translated">가능한 각 인증 사례 ( &lt;code&gt;LOGIN_SUCCESS&lt;/code&gt; , &lt;code&gt;LOGIN_FAILURE&lt;/code&gt; 등) 에 대해 다음 상태를 반환하는 감속기를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="8eda9a696d062cf8392d53f7f2f71e67915d36d6" translate="yes" xml:space="preserve">
          <source>Create action constants for &lt;code&gt;LOGIN_SUCCESS&lt;/code&gt;, &lt;code&gt;LOGIN_FAILURE&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;code&gt;LOGIN_SUCCESS&lt;/code&gt; , &lt;code&gt;LOGIN_FAILURE&lt;/code&gt; 등에 대한 액션 상수를 생성하십시오 .</target>
        </trans-unit>
        <trans-unit id="324a3f11e3a6b0488c13a615c4cc2fb9250a827e" translate="yes" xml:space="preserve">
          <source>Create action creators that take in credentials, a flag that signifies whether authentication succeeded, a token, or an error message as the payload.</source>
          <target state="translated">자격 증명, 인증 성공 여부를 나타내는 플래그, 토큰 또는 오류 메시지를 페이로드로 사용하는 작업 작성자를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f4da47671463db87fe5e42276d8cdd320a2a393a" translate="yes" xml:space="preserve">
          <source>Create an async action creator with Redux Thunk middleware or any middleware you see fit to fire a network request to an API that returns a token if the credentials are valid. Then save the token in the local storage or show a response to the user if it failed. You can perform these side effects from the action creators you wrote in the previous step.</source>
          <target state="translated">Redux Thunk 미들웨어 또는 자격 증명이 유효한 경우 토큰을 반환하는 API에 대한 네트워크 요청을 발생시키기에 적합한 미들웨어를 사용하여 비동기 조치 작성자를 작성하십시오. 그런 다음 토큰을 로컬 스토리지에 저장하거나 실패한 경우 사용자에게 응답을 표시하십시오. 이전 단계에서 작성한 조치 작성자로부터 이러한 부작용을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e918651270b4a8e2572409f93c5b24f05fb8646" translate="yes" xml:space="preserve">
          <source>Create the tree using Immutable.JS&amp;rsquo;s &lt;code&gt;fromJS()&lt;/code&gt; function.</source>
          <target state="translated">Immutable.JS의 &lt;code&gt;fromJS()&lt;/code&gt; 함수를 사용하여 트리를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="f9f8eb3701e2ecf3db6a0a48de0c67b288bcb04f" translate="yes" xml:space="preserve">
          <source>Creates a Redux &lt;a href=&quot;store&quot;&gt;store&lt;/a&gt; that holds the complete state tree of your app.</source>
          <target state="translated">앱의 완전한 상태 트리를 보유 하는 Redux &lt;a href=&quot;store&quot;&gt;저장소&lt;/a&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e2d02ebd7a04879d6977b29605f7193c5cf5707d" translate="yes" xml:space="preserve">
          <source>Creating a Memoized Selector</source>
          <target state="translated">메모 된 선택기 만들기</target>
        </trans-unit>
        <trans-unit id="d2bc225ae0a45426787680231ada8a6f564133c3" translate="yes" xml:space="preserve">
          <source>Currently, the todo list is not filtered even after the URL changed. This is because we are filtering from &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;'s &lt;code&gt;mapStateToProps()&lt;/code&gt; is still bound to the &lt;code&gt;state&lt;/code&gt; and not to the URL. &lt;code&gt;mapStateToProps&lt;/code&gt; has an optional second argument &lt;code&gt;ownProps&lt;/code&gt; that is an object with every props passed to &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt;</source>
          <target state="translated">현재 할 일 목록은 URL이 변경된 후에도 필터링되지 않습니다. 우리가에서 필터링되기 때문이다 &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt; 의 &lt;code&gt;mapStateToProps()&lt;/code&gt; 여전히 바인딩 된 &lt;code&gt;state&lt;/code&gt; 가 아닌 URL에. &lt;code&gt;mapStateToProps&lt;/code&gt; 에는 모든 소품이 &lt;code&gt;&amp;lt;VisibleTodoList /&amp;gt;&lt;/code&gt; 에 전달 된 객체 인 선택적 두 번째 인수 &lt;code&gt;ownProps&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c61307a6709c8c66ca641e98184dcc9259bd594" translate="yes" xml:space="preserve">
          <source>Customizing Behavior with Higher-Order Reducers</source>
          <target state="translated">더 높은 순서의 감속기로 동작 사용자 정의</target>
        </trans-unit>
        <trans-unit id="60b543bfaaf4e1677077510d003f94bafdf0c999" translate="yes" xml:space="preserve">
          <source>Dan</source>
          <target state="translated">Dan</target>
        </trans-unit>
        <trans-unit id="d3ef9a304a148420eba3a55c129f2235b1f9e1ec" translate="yes" xml:space="preserve">
          <source>Data Flow</source>
          <target state="translated">데이터 흐름</target>
        </trans-unit>
        <trans-unit id="bb55896eb93bcb68cbc23ed6fae3b63100404b9f" translate="yes" xml:space="preserve">
          <source>Data encapsulated in an Immutable.JS object is never mutated. A new copy is always returned. This contrasts with JavaScript, in which some operations do not mutate your data (e.g. some Array methods, including map, filter, concat, forEach, etc.), but some do (Array&amp;rsquo;s pop, push, splice, etc.).</source>
          <target state="translated">Immutable.JS 객체에 캡슐화 된 데이터는 절대로 변경되지 않습니다. 새로운 사본이 항상 반환됩니다. 이는 일부 작업 (예 :지도, 필터, 연결, forEach 등을 포함한 일부 Array 메서드)이 아닌 일부 작업 (배열의 팝, 푸시, 스플 라이스 등)을 수행하는 JavaScript와 대조됩니다.</target>
        </trans-unit>
        <trans-unit id="7593569c991b58f5d6a41f860519f79c89ac7d64" translate="yes" xml:space="preserve">
          <source>Data with IDs, nesting, or relationships should generally be stored in a &amp;ldquo;normalized&amp;rdquo; fashion: each object should be stored once, keyed by ID, and other objects that reference it should only store the ID rather than a copy of the entire object. It may help to think of parts of your store as a database, with individual &amp;ldquo;tables&amp;rdquo; per item type. Libraries such as &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt; and &lt;a href=&quot;https://github.com/tommikaikkonen/redux-orm&quot;&gt;redux-orm&lt;/a&gt; can provide help and abstractions in managing normalized data.</source>
          <target state="translated">ID, 중첩 또는 관계가있는 데이터는 일반적으로 &quot;정규화 된&quot;방식으로 저장해야합니다. 각 객체는 한 번 저장하고 ID별로 키를 입력해야하며이를 참조하는 다른 객체는 전체 객체의 복사본이 아니라 ID 만 저장해야합니다. 상점 유형을 품목 유형별로 개별&amp;ldquo;테이블&amp;rdquo;이있는 데이터베이스로 생각하면 도움이 될 수 있습니다. &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/tommikaikkonen/redux-orm&quot;&gt;redux-orm&lt;/a&gt; 과 같은 라이브러리는 표준화 된 데이터를 관리하는 데 도움과 추상화를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65fce8bd8c421447a1dd474490698e1a12d0c27c" translate="yes" xml:space="preserve">
          <source>Database Design: Many-to-Many</source>
          <target state="translated">데이터베이스 설계 : 다 대다</target>
        </trans-unit>
        <trans-unit id="1fa63f66a3e39dbf462410620328fa6a5c9da175" translate="yes" xml:space="preserve">
          <source>Database Normalization in Simple English</source>
          <target state="translated">간단한 영어로 데이터베이스 표준화</target>
        </trans-unit>
        <trans-unit id="32877593ffc83fe4317187fc6ecc5223533036b1" translate="yes" xml:space="preserve">
          <source>Database structure and organization</source>
          <target state="translated">데이터베이스 구조 및 구성</target>
        </trans-unit>
        <trans-unit id="6e6caf1f8d03433b6b3dbc198392d72cd0763d04" translate="yes" xml:space="preserve">
          <source>Defining State Shape</source>
          <target state="translated">상태 모양 정의</target>
        </trans-unit>
        <trans-unit id="49314fcc5d1e120d1d0902f4474a5db8b799f9b6" translate="yes" xml:space="preserve">
          <source>Defining a new variable does &lt;em&gt;not&lt;/em&gt; create a new actual object - it only creates another reference to the same object. An example of this error would be:</source>
          <target state="translated">새로운 변수를 정의한다고 해서 새로운 실제 객체가 생성되는 것은 &lt;em&gt;아니며&lt;/em&gt; 동일한 객체에 대한 다른 참조 만 생성합니다. 이 오류의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bd4da65ee5f20805d0bb44ddd368a4514e6d0453" translate="yes" xml:space="preserve">
          <source>Defining reducer initial state</source>
          <target state="translated">감속기 초기 상태 정의</target>
        </trans-unit>
        <trans-unit id="9f78359ef1da5a7d707b4be19086cd7ea706ec2f" translate="yes" xml:space="preserve">
          <source>Delegating update responsibility by slice of state (&lt;em&gt;reducer composition&lt;/em&gt;)</source>
          <target state="translated">상태 별 슬라이스에 따른 업데이트 책임 위임 ( &lt;em&gt;감속기 구성&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="1296d584b1abd6003d9e6416a0989753f553b128" translate="yes" xml:space="preserve">
          <source>Designing Component Hierarchy</source>
          <target state="translated">컴포넌트 계층 설계</target>
        </trans-unit>
        <trans-unit id="e6f93012b13a7122f93f6b433f36e83f1b2dfb67" translate="yes" xml:space="preserve">
          <source>Designing Container Components</source>
          <target state="translated">컨테이너 구성 요소 설계</target>
        </trans-unit>
        <trans-unit id="7810471483b121e68f2ab23125107a8e8d67064c" translate="yes" xml:space="preserve">
          <source>Designing Other Components</source>
          <target state="translated">다른 구성 요소 설계</target>
        </trans-unit>
        <trans-unit id="095ba0b64724cee5424170abe9d2369a1356993a" translate="yes" xml:space="preserve">
          <source>Designing Presentational Components</source>
          <target state="translated">프리젠 테이션 컴포넌트 설계</target>
        </trans-unit>
        <trans-unit id="f307d5da7a84124c96764da2d65924d5f68585cd" translate="yes" xml:space="preserve">
          <source>Designing a Normalized State</source>
          <target state="translated">정규화 된 상태 설계</target>
        </trans-unit>
        <trans-unit id="99b64b8cd5e20eb2ba80ed64b203752e415148ae" translate="yes" xml:space="preserve">
          <source>Designing the Algorithm</source>
          <target state="translated">알고리즘 설계</target>
        </trans-unit>
        <trans-unit id="b35f6f1ba63bafce6306862fed8e4ab702901f90" translate="yes" xml:space="preserve">
          <source>Designing the State Shape</source>
          <target state="translated">상태 모양 디자인</target>
        </trans-unit>
        <trans-unit id="c6c55bbe367ca8fb0838485f031ff1f37f152f0b" translate="yes" xml:space="preserve">
          <source>DevTools</source>
          <target state="translated">DevTools</target>
        </trans-unit>
        <trans-unit id="f2384c55c1021ace4ef6037926b470b0095b309e" translate="yes" xml:space="preserve">
          <source>DevTools Monitors</source>
          <target state="translated">DevTools 모니터</target>
        </trans-unit>
        <trans-unit id="4ed5637154269fe9a6be1732f927c29a0887441d" translate="yes" xml:space="preserve">
          <source>Developer Experience</source>
          <target state="translated">개발자 경험</target>
        </trans-unit>
        <trans-unit id="1972dacb696b8fcf81bb0f74e9d8f176d7b71600" translate="yes" xml:space="preserve">
          <source>Difficult to Debug</source>
          <target state="translated">디버깅하기 어려움</target>
        </trans-unit>
        <trans-unit id="8d5353aaf7c5188baebbcacaf0df24469e5eb208" translate="yes" xml:space="preserve">
          <source>Difficult to interoperate with</source>
          <target state="translated">상호 운용이 어려움</target>
        </trans-unit>
        <trans-unit id="8fb937b602b4f2ef21c7fab00ac15de3b3ba49ea" translate="yes" xml:space="preserve">
          <source>Discussion</source>
          <target state="translated">Discussion</target>
        </trans-unit>
        <trans-unit id="ba63f5884c366cac612c111e65bfbc1bb0d9c688" translate="yes" xml:space="preserve">
          <source>Dispatch Redux actions</source>
          <target state="translated">디스패치 작업 전달</target>
        </trans-unit>
        <trans-unit id="6a79a9e77ebead14cffe5188d0410f1e586d1501" translate="yes" xml:space="preserve">
          <source>Dispatches an action. This is the only way to trigger a state change.</source>
          <target state="translated">액션을 전달합니다. 이것이 상태 변경을 트리거하는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="c5de1b3bf84cda5dd071c256e4397b905445d1ed" translate="yes" xml:space="preserve">
          <source>Dispatching Actions</source>
          <target state="translated">파견 조치</target>
        </trans-unit>
        <trans-unit id="ee258d3de8054840d9dbb2c1e3c54e55b09089fd" translate="yes" xml:space="preserve">
          <source>Dispatching Function</source>
          <target state="translated">파견 기능</target>
        </trans-unit>
        <trans-unit id="2940c23366cfc9866cf0dedabc5e7de427363110" translate="yes" xml:space="preserve">
          <source>Dispatching async actions is no different from dispatching synchronous actions, so we won't discuss this in detail. See &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Usage with React&lt;/a&gt; for an introduction into using Redux from React components. See &lt;a href=&quot;exampleredditapi&quot;&gt;Example: Reddit API&lt;/a&gt; for the complete source code discussed in this example.</source>
          <target state="translated">비동기 작업을 전달하는 것은 동기 작업을 전달하는 것과 다르지 않으므로 이에 대해서는 자세히 설명하지 않습니다. React 컴포넌트에서 Redux 사용에 대한 소개 &lt;a href=&quot;../basics/usagewithreact&quot;&gt;는 React와 함께 사용을&lt;/a&gt; 참조하십시오 . 이 예제에서 설명한 전체 소스 코드는 &lt;a href=&quot;exampleredditapi&quot;&gt;예 : Reddit API&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d068c8a57b05988a99ec9db89530ed96daebd1f4" translate="yes" xml:space="preserve">
          <source>Do I have to deep-clone my state in a reducer? Isn't copying my state going to be slow?</source>
          <target state="translated">감속기에서 상태를 딥 복제해야합니까? 내 상태를 복사하는 것이 느리지 않습니까?</target>
        </trans-unit>
        <trans-unit id="caa79d0829b0d4f0c975b203f736245e67eda1ac" translate="yes" xml:space="preserve">
          <source>Do I have to put all my state into Redux? Should I ever use React's &lt;code&gt;setState()&lt;/code&gt;?</source>
          <target state="translated">모든 주를 Redux에 넣어야합니까? React의 &lt;code&gt;setState()&lt;/code&gt; 사용해야 합니까?</target>
        </trans-unit>
        <trans-unit id="3636bc59ec04bd17d42ee7274e5e3eb724ddb4f2" translate="yes" xml:space="preserve">
          <source>Do I have to put all my state into Redux? Should I ever use React's setState()?</source>
          <target state="translated">모든 주를 Redux에 넣어야합니까? React의 setState ()를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="7486a68c2117f403c3ca95e7a147f4be8fdc9437" translate="yes" xml:space="preserve">
          <source>Do I have to use Immutable.JS?</source>
          <target state="translated">Immutable.JS를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="4e019a0f0b682311d1ef5e7b44aa30ef9a7eb403" translate="yes" xml:space="preserve">
          <source>Do I have to use the &lt;code&gt;switch&lt;/code&gt; statement to handle actions?</source>
          <target state="translated">작업을 처리 하려면 &lt;code&gt;switch&lt;/code&gt; 문을 사용해야 합니까?</target>
        </trans-unit>
        <trans-unit id="5b739025b617dfa813fa405e23c0277f969c273f" translate="yes" xml:space="preserve">
          <source>Do I have to use the switch statement to handle actions?</source>
          <target state="translated">작업을 처리하려면 switch 문을 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="04dfaeca86278099773342d666073f6978321758" translate="yes" xml:space="preserve">
          <source>Do I need to have a particular build tool to use Redux?</source>
          <target state="translated">Redux를 사용하려면 특정 빌드 도구가 필요합니까?</target>
        </trans-unit>
        <trans-unit id="9b60ee4844578949ccecf13536855592c60fe12e" translate="yes" xml:space="preserve">
          <source>Do not, however, use Immutable.JS in your dumb components.</source>
          <target state="translated">그러나 바보 같은 구성 요소에는 Immutable.JS를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4a8b5e6217f9ee788c8250a9d130537eb4c43e5f" translate="yes" xml:space="preserve">
          <source>Do other parts of the application care about this data?</source>
          <target state="translated">응용 프로그램의 다른 부분이이 데이터를 관리합니까?</target>
        </trans-unit>
        <trans-unit id="88c60268b9a702d1f66d359ec783eeff4c903f73" translate="yes" xml:space="preserve">
          <source>Do you need to be able to create further derived data based on this original data?</source>
          <target state="translated">이 원본 데이터를 기반으로 추가 파생 데이터를 작성할 수 있어야합니까?</target>
        </trans-unit>
        <trans-unit id="4a7b10f54d6c1236b3c9f64a98cb069e05bfcec5" translate="yes" xml:space="preserve">
          <source>Do you want to cache the data (ie, use what's in state if it's already there instead of re-requesting it)?</source>
          <target state="translated">데이터를 캐시하고 싶습니까 (예 : 데이터를 다시 요청하는 대신 상태가있는 경우 사용)?</target>
        </trans-unit>
        <trans-unit id="5cfcf7555c4a87f604bf343228e431e941928a19" translate="yes" xml:space="preserve">
          <source>Docs: Async Actions</source>
          <target state="translated">문서 : 비동기 작업</target>
        </trans-unit>
        <trans-unit id="9e9cf3221a30246219863f1d2366e36cb580debc" translate="yes" xml:space="preserve">
          <source>Documentation</source>
          <target state="translated">Documentation</target>
        </trans-unit>
        <trans-unit id="8181fac4ec0bea3cecb41f787698bf543db5208d" translate="yes" xml:space="preserve">
          <source>Does it make sense to use Redux together with RxJS? Sure! They work great together. For example, it is easy to expose a Redux store as an observable:</source>
          <target state="translated">RuxJS와 함께 Redux를 사용하는 것이 합리적입니까? 확실한! 그들은 함께 잘 작동합니다. 예를 들어 Redux 저장소를 관찰 가능 항목으로 쉽게 노출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1305d9a919be6e6f9ecdeed5c7f2f2e478ed670" translate="yes" xml:space="preserve">
          <source>Does not &lt;em&gt;call non-pure functions&lt;/em&gt; (like &lt;code&gt;Date.now&lt;/code&gt; or &lt;code&gt;Math.random&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;순수&lt;/em&gt; 하지 &lt;em&gt;않은 함수&lt;/em&gt; (예 : &lt;code&gt;Date.now&lt;/code&gt; 또는 &lt;code&gt;Math.random&lt;/code&gt; )를 &lt;em&gt;호출하지&lt;/em&gt; 않습니다 .</target>
        </trans-unit>
        <trans-unit id="308816fda77ecb92fa0de1e1d751c4e3693e8be6" translate="yes" xml:space="preserve">
          <source>Does not &lt;em&gt;mutate&lt;/em&gt; its arguments. If the reducer updates state, it should not &lt;em&gt;modify&lt;/em&gt; the &lt;strong&gt;existing&lt;/strong&gt; state object in-place. Instead, it should generate a &lt;strong&gt;new&lt;/strong&gt; object containing the necessary changes. The same approach should be used for any sub-objects within state that the reducer updates.</source>
          <target state="translated">인수를 &lt;em&gt;변경&lt;/em&gt; 하지 않습니다 . 리듀서가 상태를 업데이트 하면 &lt;strong&gt;기존&lt;/strong&gt; 상태 개체를 제자리에서 &lt;em&gt;수정&lt;/em&gt; 해서는 안됩니다 . 대신 필요한 변경 사항이 포함 된 &lt;strong&gt;새&lt;/strong&gt; 개체를 생성해야합니다 . 리듀서가 업데이트 된 상태의 하위 오브젝트에 대해 동일한 접근 방식을 사용해야합니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e22b1d9946b43200b9db286efe37087e730da043" translate="yes" xml:space="preserve">
          <source>Does not &lt;em&gt;perform side effects&lt;/em&gt; (such as calling API's or modifying non-local objects or variables).</source>
          <target state="translated">&lt;em&gt;부작용&lt;/em&gt; (예 : API 호출 또는 로컬이 아닌 객체 또는 변수 수정)을 &lt;em&gt;수행&lt;/em&gt; 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="901adbd801774ee77110f7fe930f88786af2ec3e" translate="yes" xml:space="preserve">
          <source>Does shallow equality checking with a mutable object cause problems with Redux?</source>
          <target state="translated">가변 객체를 사용한 얕은 동등성 검사로 Redux에 문제가 발생합니까?</target>
        </trans-unit>
        <trans-unit id="acbce74552f0dc7776acd620559f6ae39660da73" translate="yes" xml:space="preserve">
          <source>Doing a shallow copy of the top level is &lt;em&gt;not&lt;/em&gt; sufficient - the &lt;code&gt;nestedState&lt;/code&gt; object should be copied as well.</source>
          <target state="translated">최상위 레벨의 얕은 사본은 충분 &lt;em&gt;하지 않습니다&lt;/em&gt; . &lt;code&gt;nestedState&lt;/code&gt; 객체도 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd72a551e03c242c187b72b86ec827595d6e90b6" translate="yes" xml:space="preserve">
          <source>Domain-style: separate folders per feature or domain, possibly with sub-folders per file type</source>
          <target state="translated">도메인 스타일 : 기능 또는 도메인별로 별도의 폴더 (파일 유형별로 하위 폴더가있을 수 있음)</target>
        </trans-unit>
        <trans-unit id="2b32a297d0fa3a03eb8b498f0629572a9c1acda3" translate="yes" xml:space="preserve">
          <source>Don't be fooled by all the fancy talk about reducers, middleware, store enhancers&amp;mdash;Redux is incredibly simple. If you've ever built a Flux application, you will feel right at home. If you're new to Flux, it's easy too!</source>
          <target state="translated">감속기, 미들웨어, 매장 향상에 대한 모든 멋진 이야기에 속지 마십시오. Redux는 매우 간단합니다. Flux 애플리케이션을 구축 한 적이 있다면 집에있는 것처럼 느낄 것입니다. Flux를 처음 사용하는 경우에도 간단합니다!</target>
        </trans-unit>
        <trans-unit id="e60dca1e1c4e8a1060f3f909eb0e179e31b4080d" translate="yes" xml:space="preserve">
          <source>Don't create more than one store in an application! Instead, use &lt;a href=&quot;combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; to create a single root reducer out of many.</source>
          <target state="translated">응용 프로그램에서 둘 이상의 상점을 작성하지 마십시오! 대신 &lt;a href=&quot;combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt; 를 사용하여 많은 것에서 단일 루트 감속기를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="dffae83d98e05f1f4c0b98f460a952b65b10e233" translate="yes" xml:space="preserve">
          <source>Don't forget to call &lt;a href=&quot;api/store#dispatch&quot;&gt;&lt;code&gt;dispatch(action)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;api/store#dispatch&quot;&gt; &lt;code&gt;dispatch(action)&lt;/code&gt; &lt;/a&gt; 잊지 마십시오</target>
        </trans-unit>
        <trans-unit id="495284d10f80785f137d2b0ebaf638b1a961c65d" translate="yes" xml:space="preserve">
          <source>ES5 (CommonJS)</source>
          <target state="translated">ES5 (CommonJS)</target>
        </trans-unit>
        <trans-unit id="745ddb845c45ed0aef6da5a7c40b9250b9a325e0" translate="yes" xml:space="preserve">
          <source>ES5 (UMD build)</source>
          <target state="translated">ES5 (UMD 빌드)</target>
        </trans-unit>
        <trans-unit id="f340712260381d35a53813a65d261137ac25e7e6" translate="yes" xml:space="preserve">
          <source>ES6</source>
          <target state="translated">ES6</target>
        </trans-unit>
        <trans-unit id="ce35c00a38ecfe2f4b7ca71185bfb3dae5d5f370" translate="yes" xml:space="preserve">
          <source>Each &quot;data table&quot; should store the individual items in an object, with the IDs of the items as keys and the items themselves as the values.</source>
          <target state="translated">각 &quot;데이터 테이블&quot;은 항목의 ID를 키로, 항목 자체를 값으로 사용하여 개별 항목을 객체에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="789740bc75be7ca6e2b1e0c1d3adb891edb730c5" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;VisibleTodoList&lt;/code&gt; container should select a different slice of the state depending on the value of the &lt;code&gt;listId&lt;/code&gt; prop, so let's modify &lt;code&gt;getVisibilityFilter&lt;/code&gt; and &lt;code&gt;getTodos&lt;/code&gt; to accept a props argument:</source>
          <target state="translated">각 &lt;code&gt;VisibleTodoList&lt;/code&gt; 컨테이너는 &lt;code&gt;listId&lt;/code&gt; prop 의 값에 따라 다른 상태 조각을 선택해야 하므로 props 인수를 허용 하도록 &lt;code&gt;getVisibilityFilter&lt;/code&gt; 및 &lt;code&gt;getTodos&lt;/code&gt; 를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca9118903269eef24fd5dbfa80396b4917cc79e2" translate="yes" xml:space="preserve">
          <source>Each function below is a valid Redux middleware. They are not equally useful, but at least they are equally fun.</source>
          <target state="translated">아래의 각 기능은 유효한 Redux 미들웨어입니다. 그들은 똑같이 유용하지는 않지만 적어도 똑같이 재미 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aef125e7da3027756ffee796bf82b1ad655ceee" translate="yes" xml:space="preserve">
          <source>Each of these two moments usually require a change in the application state; to do that, you need to dispatch normal actions that will be processed by reducers synchronously. Usually, for any API request you'll want to dispatch at least three different kinds of actions:</source>
          <target state="translated">이 두 순간 각각은 일반적으로 응용 프로그램 상태를 변경해야합니다. 그러기 위해서는 감속기에서 동 기적으로 처리 할 일반 작업을 전달해야합니다. 일반적으로 모든 API 요청에 대해 적어도 세 가지 종류의 작업을 전달하려고합니다.</target>
        </trans-unit>
        <trans-unit id="b94061bea8551ce9cef03e7d29d9b7bc74bb6280" translate="yes" xml:space="preserve">
          <source>Each time React-Redux&amp;rsquo;s &lt;code&gt;connect&lt;/code&gt; function is called, it will perform a shallow equality check on its stored reference to the root state object, and the current root state object passed to it from the store. If the check passes, the root state object has not been updated, and so there is no need to re-render the component, or even call &lt;code&gt;mapStateToProps&lt;/code&gt;.</source>
          <target state="translated">React-Redux의 &lt;code&gt;connect&lt;/code&gt; 함수가 호출 될 때마다, 루트 상태 오브젝트에 대한 저장된 참조 및 상점에서 전달 된 현재 루트 상태 오브젝트에 대해 얕은 동등성 검사를 수행합니다. 검사가 통과하면 루트 상태 객체가 업데이트되지 않으므로 구성 요소를 다시 렌더링하거나 &lt;code&gt;mapStateToProps&lt;/code&gt; 를 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8ac62ddd16da80245d0cc537482a69476b215083" translate="yes" xml:space="preserve">
          <source>Each type of data gets its own &quot;table&quot; in the state.</source>
          <target state="translated">각 유형의 데이터는 상태에서 자체 &quot;테이블&quot;을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="73f0d5e4c1ae9f4f2cda609ae918e95f2ac644be" translate="yes" xml:space="preserve">
          <source>Earlier documentation suggested the use of the ES6 &lt;code&gt;import * as reducers&lt;/code&gt; syntax to obtain the reducers object. This was the source of a lot of confusion, which is why we now recommend exporting a single reducer obtained using &lt;code&gt;combineReducers()&lt;/code&gt; from &lt;code&gt;reducers/index.js&lt;/code&gt; instead. An example is included below.</source>
          <target state="translated">이전 문서 에서는 리듀서 객체를 얻기 위해 ES6 &lt;code&gt;import * as reducers&lt;/code&gt; 구문으로 사용하는 것이 좋습니다. 이것은 많은 혼란의 원인이 &lt;code&gt;combineReducers()&lt;/code&gt; &lt;code&gt;reducers/index.js&lt;/code&gt; 에서 combineReducers () 를 사용하여 얻은 단일 감속기를 내보내는 것이 좋습니다 . 아래에 예가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="67ebf8c054640eac7707617ac6e4bacc793e0e77" translate="yes" xml:space="preserve">
          <source>Early Redux documentation advised that you should only have a few connected components near the top of your component tree. However, time and experience has shown that that generally requires a few components to know too much about the data requirements of all their descendants, and forces them to pass down a confusing number of props.</source>
          <target state="translated">초기 Redux 설명서에서는 구성 요소 트리의 맨 위에 몇 개의 연결된 구성 요소 만 있어야한다고 조언했습니다. 그러나 시간과 경험에 따르면 일반적으로 모든 자손의 데이터 요구 사항에 대해 너무 많은 것을 알기 위해 몇 가지 구성 요소가 필요하며 혼란스러운 수의 소품을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f12cdfc5423f3f8f4b141824700661516b50d41" translate="yes" xml:space="preserve">
          <source>Ecosystem</source>
          <target state="translated">Ecosystem</target>
        </trans-unit>
        <trans-unit id="80499668424a593b571c96afb7bfa53680db9225" translate="yes" xml:space="preserve">
          <source>Eddie Zaneski</source>
          <target state="translated">에디 자네 스키</target>
        </trans-unit>
        <trans-unit id="c78c0f2575bc2cbbd58e1c8e6bfbabc097fdacf8" translate="yes" xml:space="preserve">
          <source>Egghead.io: Redux: Implementing combineReducers() from Scratch</source>
          <target state="translated">Egghead.io : Redux : 스크래치에서 combineReducers () 구현</target>
        </trans-unit>
        <trans-unit id="a5bfc7a7b3d59e7e7fc34f2665c9e5ecf3f615b6" translate="yes" xml:space="preserve">
          <source>Elm</source>
          <target state="translated">Elm</target>
        </trans-unit>
        <trans-unit id="b0e68be5c4150141a8b181ac2f45237a837582b3" translate="yes" xml:space="preserve">
          <source>Emphasizing &amp;ldquo;one container component at the top&amp;rdquo; in Redux examples was a mistake. Don't take this as a maxim. Try to keep your presentation components separate. Create container components by connecting them when it's convenient. Whenever you feel like you're duplicating code in parent components to provide data for same kinds of children, time to extract a container. Generally as soon as you feel a parent knows too much about &amp;ldquo;personal&amp;rdquo; data or actions of its children, time to extract a container.</source>
          <target state="translated">Redux 예제에서 &quot;상단에 하나의 컨테이너 구성 요소&quot;를 강조하는 것은 실수였습니다. 이것을 최대로 생각하지 마십시오. 프리젠 테이션 컴포넌트를 별도로 유지하십시오. 편리한 경우 컨테이너 구성 요소를 연결하여 작성하십시오. 동일한 종류의 자식에 대한 데이터를 제공하기 위해 부모 구성 요소에서 코드를 복제하는 것처럼 느껴질 때마다 컨테이너를 추출 할 시간입니다. 일반적으로 부모가 자녀의 &quot;개인적인&quot;데이터 나 행동에 대해 너무 많이 알고 있다고 느끼면 컨테이너를 추출 할 시간입니다.</target>
        </trans-unit>
        <trans-unit id="7c1a0998563346ad2e48c38b39741bb352b08e65" translate="yes" xml:space="preserve">
          <source>Encapsulating and centralizing commonly used pieces of code is a key concept in programming. While it is certainly possible to manually create action objects everywhere, and write each &lt;code&gt;type&lt;/code&gt; value by hand, defining reusable constants makes maintaining code easier. If you put constants in a separate file, you can &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-import&quot;&gt;check your &lt;code&gt;import&lt;/code&gt; statements against typos&lt;/a&gt; so you can't accidentally use the wrong string.</source>
          <target state="translated">일반적으로 사용되는 코드를 캡슐화하고 중앙 집중화하는 것이 프로그래밍의 핵심 개념입니다. 어디에서나 수동으로 액션 객체를 생성하고 각 &lt;code&gt;type&lt;/code&gt; 값 을 직접 작성할 수 있지만 재사용 가능한 상수를 정의하면 코드를 쉽게 유지할 수 있습니다. 당신은 별도의 파일에 상수를 넣어 경우, 당신은 할 수 &lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-import&quot;&gt;귀하의 확인 &lt;code&gt;import&lt;/code&gt; 오타에 대한 문을&lt;/a&gt; 실수로 잘못된 문자열을 사용할 수 있도록.</target>
        </trans-unit>
        <trans-unit id="5b2f465254c1894a55c4eae9816aef0a576c3b88" translate="yes" xml:space="preserve">
          <source>Encapsulating the Redux State Tree</source>
          <target state="translated">Redux 상태 트리 캡슐화</target>
        </trans-unit>
        <trans-unit id="fd530f3fb4530f659965d7db1794f6c9a3831280" translate="yes" xml:space="preserve">
          <source>Enforcing that every change is described as an action lets us have a clear understanding of what&amp;rsquo;s going on in the app. If something changed, we know why it changed. Actions are like breadcrumbs of what has happened. Finally, to tie state and actions together, we write a function called a reducer. Again, nothing magical about it&amp;mdash;it&amp;rsquo;s just a function that takes state and action as arguments, and returns the next state of the app. It would be hard to write such a function for a big app, so we write smaller functions managing parts of the state:</source>
          <target state="translated">모든 변경 사항을 동작으로 설명하면 앱에서 진행되는 작업을 명확하게 이해할 수 있습니다. 무언가가 바뀌면 왜 바뀌 었는지 알 수 있습니다. 행동은 일어난 일의 빵 부스러기와 같습니다. 마지막으로 상태와 동작을 연결하기 위해 감속기라는 함수를 작성합니다. 다시 말하지만, 마술은 아닙니다. 상태와 동작을 인수로 사용하여 앱의 다음 상태를 반환하는 함수일뿐입니다. 큰 앱에는 이러한 함수를 작성하기가 어려우므로 상태의 일부를 관리하는 작은 함수를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="465e88db20c49fa14df715ad3c0631b26ca590c4" translate="yes" xml:space="preserve">
          <source>Enhancers</source>
          <target state="translated">Enhancers</target>
        </trans-unit>
        <trans-unit id="a88e7a573b0a77f73eb1f2a5e5b8de48275a7af8" translate="yes" xml:space="preserve">
          <source>Entry Point</source>
          <target state="translated">진입 지점</target>
        </trans-unit>
        <trans-unit id="1552f36ee13c5c4910ec207795eb05b9e58ae679" translate="yes" xml:space="preserve">
          <source>Even though the array might contain the exact same object references each time, the array itself is a different reference, so the shallow equality check fails and React Redux would re-render the wrapped component.</source>
          <target state="translated">배열에 매번 똑같은 객체 참조가 포함될 수 있지만 배열 자체는 다른 참조이므로 얕은 동등성 검사에 실패하고 React Redux는 래핑 된 구성 요소를 다시 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="b6a853804467e62df08fd20ca2def253cd121c2e" translate="yes" xml:space="preserve">
          <source>Ever wondered what &lt;code&gt;applyMiddleware&lt;/code&gt; itself is? It ought to be an extension mechanism more powerful than the middleware itself. Indeed, &lt;code&gt;applyMiddleware&lt;/code&gt; is an example of the most powerful Redux extension mechanism called &lt;a href=&quot;../glossary#store-enhancer&quot;&gt;store enhancers&lt;/a&gt;. It is highly unlikely you'll ever want to write a store enhancer yourself. Another example of a store enhancer is &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt;. Middleware is less powerful than a store enhancer, but it is easier to write.</source>
          <target state="translated">&lt;code&gt;applyMiddleware&lt;/code&gt; 자체가 무엇인지 궁금한 적이 있습니까? 미들웨어보다 강력한 확장 메커니즘이어야합니다. 실제로 &lt;code&gt;applyMiddleware&lt;/code&gt; 는 &lt;a href=&quot;../glossary#store-enhancer&quot;&gt;store enhancers&lt;/a&gt; 라는 가장 강력한 Redux 확장 메커니즘의 예입니다 . 상점 개량제를 직접 작성하고 싶지는 않을 것입니다. 상점 확장 프로그램의 다른 예는 &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt; 입니다. 미들웨어는 상점 확장 프로그램보다 강력하지 않지만 작성하기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="fc61f5aead67e5d9613283a1a13842ab6b6cf6dd" translate="yes" xml:space="preserve">
          <source>Every function described above is a top-level export. You can import any of them like this:</source>
          <target state="translated">위에서 설명한 모든 기능은 최상위 수준 내보내기입니다. 다음과 같이 가져올 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f5ee7559d25a08d85f86a3eafc206977946b6a08" translate="yes" xml:space="preserve">
          <source>Every release, along with the migration instructions, is documented on the Github &lt;a href=&quot;https://github.com/reactjs/redux/releases&quot;&gt;Releases&lt;/a&gt; page.</source>
          <target state="translated">마이그레이션 지침과 함께 모든 릴리스는 Github &lt;a href=&quot;https://github.com/reactjs/redux/releases&quot;&gt;릴리스&lt;/a&gt; 페이지에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="e3199316bf69a183958e485b0e3d61bc9694e2fb" translate="yes" xml:space="preserve">
          <source>Example Apps</source>
          <target state="translated">앱 예</target>
        </trans-unit>
        <trans-unit id="29f523dd5956d4673cb690577c1f546426cc73cb" translate="yes" xml:space="preserve">
          <source>Example: Custom Logger Middleware</source>
          <target state="translated">예 : 사용자 정의 로거 미들웨어</target>
        </trans-unit>
        <trans-unit id="2624afd8c460d6518734431bfb5d77b64cd9d60b" translate="yes" xml:space="preserve">
          <source>Example: Reddit API</source>
          <target state="translated">예 : Reddit API</target>
        </trans-unit>
        <trans-unit id="cfa9b551b74932054b2efb6c627693e8d27f541a" translate="yes" xml:space="preserve">
          <source>Example: Todo List</source>
          <target state="translated">예 : 할일 목록</target>
        </trans-unit>
        <trans-unit id="76a4c17cabc25fb419d3b53e5dbaa4dd4a5664bd" translate="yes" xml:space="preserve">
          <source>Example: Using Thunk Middleware for Async Actions</source>
          <target state="translated">예 : 비동기 작업에 썽크 미들웨어 사용</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="5f96798ae5ca58a4c6c508043f2d289c9f41fbff" translate="yes" xml:space="preserve">
          <source>Examples: Real World example</source>
          <target state="translated">예 : 실제 예</target>
        </trans-unit>
        <trans-unit id="4a0cf0d774ed2b3b87b2898557f897bfef233151" translate="yes" xml:space="preserve">
          <source>Examples: Tree View</source>
          <target state="translated">예 : 트리 뷰</target>
        </trans-unit>
        <trans-unit id="032263383a22a1454a019ce94b7dce90ebcad1e2" translate="yes" xml:space="preserve">
          <source>Exploring Redux Middleware</source>
          <target state="translated">Redux 미들웨어 살펴보기</target>
        </trans-unit>
        <trans-unit id="b171f7143f21268e520b74f4f5ead4fcb82ce831" translate="yes" xml:space="preserve">
          <source>Extracting Case Reducers</source>
          <target state="translated">케이스 감속기 추출</target>
        </trans-unit>
        <trans-unit id="1be76799495bdf5c930a8ddd44f5e9d6d64c47cb" translate="yes" xml:space="preserve">
          <source>Extracting Utility Functions</source>
          <target state="translated">유틸리티 기능 추출</target>
        </trans-unit>
        <trans-unit id="03688ba6aa340b87549088aa5739944cb6b1dc73" translate="yes" xml:space="preserve">
          <source>FAQ</source>
          <target state="translated">FAQ</target>
        </trans-unit>
        <trans-unit id="e38e4017ee383168752e8a33c5d6022a9a406df4" translate="yes" xml:space="preserve">
          <source>FAQ: Actions - &quot;1:1 mapping between reducers and actions?&quot;</source>
          <target state="translated">FAQ : 조치- &quot;1 : 1 감속기와 조치 사이의 맵핑?&quot;</target>
        </trans-unit>
        <trans-unit id="df7e17066220bc43c820094351b4e2c42bbba769" translate="yes" xml:space="preserve">
          <source>FAQ: Immutable Data</source>
          <target state="translated">FAQ : 불변 데이터</target>
        </trans-unit>
        <trans-unit id="7a41b860bf1ee467edbac48fd846ae33b759b787" translate="yes" xml:space="preserve">
          <source>FAQ: Performance - Reducing Update Events</source>
          <target state="translated">FAQ : 성능-업데이트 이벤트 감소</target>
        </trans-unit>
        <trans-unit id="ee0854a17ba3e0b5e9e9e1c578ac31d5ab4c9027" translate="yes" xml:space="preserve">
          <source>FAQ: Performance - Scaling</source>
          <target state="translated">FAQ : 성능-스케일링</target>
        </trans-unit>
        <trans-unit id="a3ab661908a8748685e7811083bdaf66ba18c68b" translate="yes" xml:space="preserve">
          <source>Finally, Redux provides a utility called &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; that does the same boilerplate logic that the &lt;code&gt;todoApp&lt;/code&gt; above currently does. With its help, we can rewrite &lt;code&gt;todoApp&lt;/code&gt; like this:</source>
          <target state="translated">마지막으로 Redux는 현재 &lt;code&gt;todoApp&lt;/code&gt; 과 동일한 상용구 로직을 수행하는 &lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt; 라는 유틸리티를 제공합니다 . 도움을 &lt;code&gt;todoApp&lt;/code&gt; 과 같이 todoApp 을 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0d847a6b9dee3deeeb8620787402b3a6277cb077" translate="yes" xml:space="preserve">
          <source>Finally, how do we use the synchronous action creators we &lt;a href=&quot;#synchronous-action-creators&quot;&gt;defined earlier&lt;/a&gt; together with network requests? The standard way to do it with Redux is to use the &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk middleware&lt;/a&gt;. It comes in a separate package called &lt;code&gt;redux-thunk&lt;/code&gt;. We'll explain how middleware works in general &lt;a href=&quot;middleware&quot;&gt;later&lt;/a&gt;; for now, there is just one important thing you need to know: by using this specific middleware, an action creator can return a function instead of an action object. This way, the action creator becomes a &lt;a href=&quot;https://en.wikipedia.org/wiki/Thunk&quot;&gt;thunk&lt;/a&gt;.</source>
          <target state="translated">마지막으로 &lt;a href=&quot;#synchronous-action-creators&quot;&gt;이전에 정의한&lt;/a&gt; 동기 동작 생성자 를 네트워크 요청과 함께 어떻게 사용합니까? Redux를 사용하는 표준 방법은 &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk 미들웨어&lt;/a&gt; 를 사용하는 것 입니다. &lt;code&gt;redux-thunk&lt;/code&gt; 라는 별도의 패키지로 제공됩니다 . 우리는 &lt;a href=&quot;middleware&quot;&gt;나중에&lt;/a&gt; 미들웨어가 어떻게 작동하는지 설명 할 것이다 ; 지금 당장 알아야 할 중요한 사항이 하나 있습니다.이 특정 미들웨어를 사용하여 활동 작성자는 활동 오브젝트 대신 함수를 리턴 할 수 있습니다. 이런 식으로 액션 크리에이터는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Thunk&quot;&gt;썽크가&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="efe6ba28d43370e1a707260f9b15d1702f3f2d3e" translate="yes" xml:space="preserve">
          <source>Finally, if the user performs an action (e.g. decrement the counter) while we're in the middle of the undo stack, we're going to discard the existing future:</source>
          <target state="translated">마지막으로, 실행 취소 스택의 중간에있는 동안 사용자가 작업을 수행하면 (예 : 카운터 감소) 기존의 미래를 폐기합니다.</target>
        </trans-unit>
        <trans-unit id="11194f10e6abbfaba6e4a214b87b681a0b877527" translate="yes" xml:space="preserve">
          <source>Finally, the implementation of the &lt;code&gt;TOGGLE_TODO&lt;/code&gt; handler shouldn't come as a complete surprise:</source>
          <target state="translated">마지막으로 &lt;code&gt;TOGGLE_TODO&lt;/code&gt; 처리기 의 구현은 놀라운 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d36e5836f13cd173c594e9d1ae569e82cd4fcdf5" translate="yes" xml:space="preserve">
          <source>Finally, to update objects, you'll need something like &lt;code&gt;_.extend&lt;/code&gt; from Underscore, or better, an &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt;&lt;code&gt;Object.assign&lt;/code&gt;&lt;/a&gt; polyfill.</source>
          <target state="translated">마지막으로 객체를 업데이트하려면 Underscore의 &lt;code&gt;_.extend&lt;/code&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign&quot;&gt; &lt;code&gt;Object.assign&lt;/code&gt; &lt;/a&gt; 폴리 필 과 같은 것이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="199eca41911960b98af69aa50c0333310e9f9b48" translate="yes" xml:space="preserve">
          <source>Finally, we create the &lt;code&gt;VisibleTodoList&lt;/code&gt; by calling &lt;code&gt;connect()&lt;/code&gt; and passing these two functions:</source>
          <target state="translated">마지막으로 &lt;code&gt;connect()&lt;/code&gt; 를 호출 하고 다음 두 함수를 전달 하여 &lt;code&gt;VisibleTodoList&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="ca381bfbf08ee78348d1eccdc53ec800366da008" translate="yes" xml:space="preserve">
          <source>Finally, we'll add one more action type for changing the currently visible todos.</source>
          <target state="translated">마지막으로, 현재 보이는 할일을 변경하기위한 액션 유형을 하나 더 추가 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="905199d1f6693b173b187362217e8ceaf7447b9d" translate="yes" xml:space="preserve">
          <source>Finally, when the network request comes through, we will dispatch &lt;code&gt;RECEIVE_POSTS&lt;/code&gt;:</source>
          <target state="translated">마지막으로 네트워크 요청이 발생하면 &lt;code&gt;RECEIVE_POSTS&lt;/code&gt; 를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="0d68b76ad804092f57e99c9239a27fd692ed5c9b" translate="yes" xml:space="preserve">
          <source>Finally, you might want to begin using some Redux idioms like middleware to further simplify your asynchronous code.</source>
          <target state="translated">마지막으로, 미들웨어와 같은 일부 Redux 관용구를 사용하여 비동기 코드를 더욱 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="909dbfd3043edaf382cc7e5528d1f59884ba5ee8" translate="yes" xml:space="preserve">
          <source>Find the balance between these two extremes, and you will master Redux.</source>
          <target state="translated">이 두 극단의 균형을 찾으면 Redux를 마스터하게됩니다.</target>
        </trans-unit>
        <trans-unit id="6f07a78d30b7ff474926fd0dc8957f55aa822b17" translate="yes" xml:space="preserve">
          <source>Find the rest of the container components defined below:</source>
          <target state="translated">아래에 정의 된 나머지 컨테이너 구성 요소를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="4f6506477b8650e1de1bd943b9bd705e36a074e2" translate="yes" xml:space="preserve">
          <source>Finding &lt;code&gt;state&lt;/code&gt;'s place with React and Redux</source>
          <target state="translated">React와 Redux로 &lt;code&gt;state&lt;/code&gt; 장소 찾기</target>
        </trans-unit>
        <trans-unit id="73d1849effa55d228df19c7e131b0d22e859600d" translate="yes" xml:space="preserve">
          <source>Finished reading the article? Let's recount their differences:</source>
          <target state="translated">기사를 다 읽었습니까? 차이점을 다시 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="083f5d4f5390de8b339a7e0d1bcbede9836be5c8" translate="yes" xml:space="preserve">
          <source>Firefox's new debugger</source>
          <target state="translated">Firefox의 새로운 디버거</target>
        </trans-unit>
        <trans-unit id="bac6033d8edd65bf451fde639fbb2062cd288167" translate="yes" xml:space="preserve">
          <source>First Attempt: Writing a Reducer</source>
          <target state="translated">첫 번째 시도 : 감속기 작성</target>
        </trans-unit>
        <trans-unit id="a63efbd7ad3629ab9570dc20eea84696652d1fe6" translate="yes" xml:space="preserve">
          <source>First and foremost, &lt;code&gt;combineReducers&lt;/code&gt; is simply &lt;strong&gt;a utility function to simplify the most common use case when writing Redux reducers&lt;/strong&gt;. You are &lt;em&gt;not&lt;/em&gt; required to use it in your own application, and it does &lt;em&gt;not&lt;/em&gt; handle every possible scenario. It is entirely possible to write reducer logic without using it, and it is quite common to need to write custom reducer logic for cases that &lt;code&gt;combineReducer&lt;/code&gt; does not handle. (See &lt;a href=&quot;beyondcombinereducers&quot;&gt;Beyond &lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; for examples and suggestions.)</source>
          <target state="translated">무엇보다도 &lt;code&gt;combineReducers&lt;/code&gt; 는 &lt;strong&gt;Redux 감속기를 작성할 때 가장 일반적인 사용 사례를 단순화하는 유틸리티 기능&lt;/strong&gt; 입니다. 자신의 응용 프로그램에서 사용할 필요 는 &lt;em&gt;없으며&lt;/em&gt; 가능한 모든 시나리오를 처리 하지는 &lt;em&gt;않습니다&lt;/em&gt; . 리듀서 로직을 사용하지 않고 작성하는 것은 전적으로 가능하며, &lt;code&gt;combineReducer&lt;/code&gt; 가 처리하지 않는 경우에는 커스텀 리듀서 로직을 작성해야하는 것이 일반적 입니다. (참조 &lt;a href=&quot;beyondcombinereducers&quot;&gt;너머의 &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt; 사례 및 제안합니다.)</target>
        </trans-unit>
        <trans-unit id="928aade909ab97ef47ad692458ac7b1733155f4f" translate="yes" xml:space="preserve">
          <source>First and foremost, it's important to understand that your entire application really only has &lt;strong&gt;one single reducer function&lt;/strong&gt;: the function that you've passed into &lt;code&gt;createStore&lt;/code&gt; as the first argument. That one single reducer function ultimately needs to do several things:</source>
          <target state="translated">가장 먼저, 전체 응용 프로그램에는 실제로 &lt;strong&gt;하나의 감속기 함수&lt;/strong&gt; , 즉 &lt;code&gt;createStore&lt;/code&gt; 에 첫 번째 인수로 전달한 함수 가 &lt;strong&gt;하나만&lt;/strong&gt; 있다는 것을 이해하는 것이 중요합니다 . 하나의 감속기 기능은 궁극적으로 여러 가지 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b3ce87bff6a9cf7a60a80fd1b3760fbe7caf2c7" translate="yes" xml:space="preserve">
          <source>First let's consider a case where you have a single reducer. Say you don't use &lt;code&gt;combineReducers()&lt;/code&gt;.</source>
          <target state="translated">먼저 감속기가 하나 인 경우를 생각해 봅시다. &lt;code&gt;combineReducers()&lt;/code&gt; 사용하지 않는다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7060a8772c7ed50446a754b52b327f7921592892" translate="yes" xml:space="preserve">
          <source>First of all, you need to run</source>
          <target state="translated">우선, 당신은 실행해야합니다</target>
        </trans-unit>
        <trans-unit id="fced756f7f0c570facc991f413283a69b01ef80e" translate="yes" xml:space="preserve">
          <source>First we will need to import &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; from React Router. Here's how to do it:</source>
          <target state="translated">먼저 React Router에서 &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; 를 가져와야 합니다. 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="928541190af20f02ef3132ea1dc14770650e0586" translate="yes" xml:space="preserve">
          <source>First, create a new container component called &lt;code&gt;UndoRedo&lt;/code&gt; for these buttons. We won't bother to split the presentational part into a separate file because it is very small:</source>
          <target state="translated">&lt;code&gt;UndoRedo&lt;/code&gt; 버튼에 대해 UndoRedo 라는 새 컨테이너 구성 요소를 만듭니다 . 프리젠 테이션 파트는 매우 작기 때문에 별도의 파일로 분할하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="066e50b38844dd1b5b820eb86ad656704f58e5eb" translate="yes" xml:space="preserve">
          <source>First, in terms of raw memory usage, Redux is no different than any other JavaScript library. The only difference is that all the various object references are nested together into one tree, instead of maybe saved in various independent model instances such as in Backbone. Second, a typical Redux app would probably have somewhat &lt;em&gt;less&lt;/em&gt; memory usage than an equivalent Backbone app because Redux encourages use of plain JavaScript objects and arrays rather than creating instances of Models and Collections. Finally, Redux only holds onto a single state tree reference at a time. Objects that are no longer referenced in that tree will be garbage collected, as usual.</source>
          <target state="translated">첫째, 원시 메모리 사용 측면에서 Redux는 다른 JavaScript 라이브러리와 다르지 않습니다. 유일한 차이점은 모든 다양한 객체 참조가 Backbone과 같은 다양한 독립적 인 모델 인스턴스에 저장되는 대신 하나의 트리에 함께 중첩된다는 것입니다. 둘째, Redux 는 모델 및 컬렉션 인스턴스를 만드는 대신 일반 JavaScript 객체 및 배열을 사용하도록 권장하기 때문에 일반적인 Redux 앱은 동등한 Backbone 앱보다 메모리 사용량 이 다소 &lt;em&gt;적을&lt;/em&gt; 것입니다 . 마지막으로 Redux는 한 번에 하나의 상태 트리 참조 만 유지합니다. 해당 트리에서 더 이상 참조되지 않는 객체는 평상시처럼 가비지 수집됩니다.</target>
        </trans-unit>
        <trans-unit id="147db38719fb360e8ff8a98d1999647a14de68aa" translate="yes" xml:space="preserve">
          <source>First, let's define some actions.</source>
          <target state="translated">먼저 몇 가지 동작을 정의 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="d50b1a37307b503b16d51ae5983d1f25a15405ee" translate="yes" xml:space="preserve">
          <source>First, we will install &lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt;. Enzyme uses the &lt;a href=&quot;https://facebook.github.io/react/docs/test-utils.html&quot;&gt;React Test Utilities&lt;/a&gt; underneath, but is more convenient, readable, and powerful.</source>
          <target state="translated">먼저 &lt;a href=&quot;http://airbnb.io/enzyme/&quot;&gt;Enzyme&lt;/a&gt; 을 설치 합니다. Enzyme은 아래 의 &lt;a href=&quot;https://facebook.github.io/react/docs/test-utils.html&quot;&gt;React Test Utilities를&lt;/a&gt; 사용 하지만보다 편리하고 읽기 쉽고 강력합니다.</target>
        </trans-unit>
        <trans-unit id="b752ccff5aae9d198427fafe188894e7b4c4185f" translate="yes" xml:space="preserve">
          <source>First, we'll need a middleware function. This is similar to the real &lt;a href=&quot;https://github.com/gaearon/redux-thunk/blob/master/src/index.js&quot;&gt;redux-thunk&lt;/a&gt;.</source>
          <target state="translated">먼저 미들웨어 기능이 필요합니다. 이것은 실제 &lt;a href=&quot;https://github.com/gaearon/redux-thunk/blob/master/src/index.js&quot;&gt;redux-thunk&lt;/a&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="889e1c2f5289eea716835fde0adffaefad64d56f" translate="yes" xml:space="preserve">
          <source>Flux</source>
          <target state="translated">Flux</target>
        </trans-unit>
        <trans-unit id="2a436f0a330413dcad542ab5cfe9f14d15c70a1e" translate="yes" xml:space="preserve">
          <source>Following in the steps of &lt;a href=&quot;http://facebook.github.io/flux&quot;&gt;Flux&lt;/a&gt;, &lt;a href=&quot;http://martinfowler.com/bliki/CQRS.html&quot;&gt;CQRS&lt;/a&gt;, and &lt;a href=&quot;http://martinfowler.com/eaaDev/EventSourcing.html&quot;&gt;Event Sourcing&lt;/a&gt;, &lt;strong&gt;Redux attempts to make state mutations predictable&lt;/strong&gt; by imposing certain restrictions on how and when updates can happen. These restrictions are reflected in the &lt;a href=&quot;threeprinciples&quot;&gt;three principles&lt;/a&gt; of Redux.</source>
          <target state="translated">의 단계에 따라 &lt;a href=&quot;http://facebook.github.io/flux&quot;&gt;플럭스&lt;/a&gt; , &lt;a href=&quot;http://martinfowler.com/bliki/CQRS.html&quot;&gt;CQRS&lt;/a&gt; 및 &lt;a href=&quot;http://martinfowler.com/eaaDev/EventSourcing.html&quot;&gt;이벤트 소싱&lt;/a&gt; , &lt;strong&gt;상태 변이를 예측하게 돌아 오는 시도&lt;/strong&gt; 업데이트가 일어날 수있는 방법과시기에 특정 제한을 부과하여. 이러한 제한은 Redux 의 &lt;a href=&quot;threeprinciples&quot;&gt;세 가지 원칙&lt;/a&gt; 에 반영됩니다 .</target>
        </trans-unit>
        <trans-unit id="cac52571ae4d35859cbf2d2ebb033839ab2f50f8" translate="yes" xml:space="preserve">
          <source>For Offline docs, please see: &lt;a href=&quot;http://devdocs.io/redux/&quot;&gt;devdocs&lt;/a&gt;</source>
          <target state="translated">오프라인 문서의 경우 &lt;a href=&quot;http://devdocs.io/redux/&quot;&gt;devdocs&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3da99abcd0c1ecdf884964d566bca5697a74e01e" translate="yes" xml:space="preserve">
          <source>For PDF, ePub, and MOBI exports for offline reading, and instructions on how to create them, please see: &lt;a href=&quot;https://github.com/paulkogel/redux-offline-docs&quot;&gt;paulkogel/redux-offline-docs&lt;/a&gt;.</source>
          <target state="translated">오프라인 읽기 용 PDF, ePub 및 MOBI 내보내기 및이를 작성하는 방법에 대한 지시 사항은 &lt;a href=&quot;https://github.com/paulkogel/redux-offline-docs&quot;&gt;paulkogel / redux-offline-docs&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1569bd4eacec55d8eceb1c2595d3b535c8d3d3cf" translate="yes" xml:space="preserve">
          <source>For React Redux, &lt;code&gt;connect&lt;/code&gt; checks to see if the props returned from a &lt;code&gt;mapStateToProps&lt;/code&gt; function have changed in order to determine if a component needs to update. To improve performance, &lt;code&gt;connect&lt;/code&gt; takes some shortcuts that rely on the state being immutable, and uses shallow reference equality checks to detect changes. This means that &lt;strong&gt;changes made to objects and arrays by direct mutation will not be detected, and components will not re-render&lt;/strong&gt;.</source>
          <target state="translated">React Redux의 경우, &lt;code&gt;connect&lt;/code&gt; 는 구성 요소를 업데이트 &lt;code&gt;mapStateToProps&lt;/code&gt; 판별하기 위해 mapStateToProps 함수 에서 리턴 된 prop 이 변경되었는지 확인합니다. 성능을 향상시키기 위해 &lt;code&gt;connect&lt;/code&gt; 는 변경 불가능한 상태에 의존하는 일부 단축키를 사용하고 얕은 참조 동등성 검사를 사용하여 변경을 감지합니다. 이는 &lt;strong&gt;직접 돌연변이에 의해 객체와 배열에 대한 변경 사항이 감지되지 않고 구성 요소가 다시 렌더링되지 않음을 의미&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="3c36a66a555508cc950b3f16c937117a95df81ef" translate="yes" xml:space="preserve">
          <source>For a Redux app, your entire state tree should be an Immutable.JS object, with no plain JavaScript objects used at all.</source>
          <target state="translated">Redux 앱의 경우 전체 상태 트리는 일반 JavaScript 객체가 전혀 사용되지 않는 Immutable.JS 객체 여야합니다.</target>
        </trans-unit>
        <trans-unit id="373c63c01af4767c75ccf47739d4a3ed95ce0716" translate="yes" xml:space="preserve">
          <source>For an extensive list of everything related to Redux, we recommend &lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt;. It contains examples, boilerplates, middleware, utility libraries, and more. &lt;a href=&quot;https://github.com/markerikson/react-redux-links&quot;&gt;React/Redux Links&lt;/a&gt; contains tutorials and other useful resources for anyone learning React or Redux, and &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Ecosystem Links&lt;/a&gt; lists many Redux-related libraries and addons.</source>
          <target state="translated">Redux와 관련된 모든 목록을 보려면 &lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux를&lt;/a&gt; 권장 합니다. 예제, 상용구, 미들웨어, 유틸리티 라이브러리 등이 포함되어 있습니다. &lt;a href=&quot;https://github.com/markerikson/react-redux-links&quot;&gt;React / Redux Links&lt;/a&gt; 에는 React 또는 Redux를 배우는 사람을위한 튜토리얼 및 기타 유용한 리소스가 포함되어 있으며 &lt;a href=&quot;https://github.com/markerikson/redux-ecosystem-links&quot;&gt;Redux Ecosystem Links&lt;/a&gt; 에는 많은 Redux 관련 라이브러리 및 애드온이 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b99470d4a1567b0670d5920564c85b87e32721b" translate="yes" xml:space="preserve">
          <source>For any action that is not recognized, it must return the &lt;code&gt;state&lt;/code&gt; given to it as the first argument.</source>
          <target state="translated">인식되지 않은 조치에 대해서는 주어진 &lt;code&gt;state&lt;/code&gt; 를 첫 번째 인수로 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="28c64b95d623e1af01c5fa554a02283a92526e40" translate="yes" xml:space="preserve">
          <source>For any meaningful application, putting &lt;em&gt;all&lt;/em&gt; your update logic into a single reducer function is quickly going to become unmaintainable. While there's no single rule for how long a function should be, it's generally agreed that functions should be relatively short and ideally only do one specific thing. Because of this, it's good programming practice to take pieces of code that are very long or do many different things, and break them into smaller pieces that are easier to understand.</source>
          <target state="translated">의미있는 응용 프로그램의 경우 &lt;em&gt;모든&lt;/em&gt; 업데이트 논리를 단일 감속기 기능에 배치하는 것은 빠르게 유지 관리 할 수 ​​없게됩니다. 함수의 길이에 대한 단일 규칙은 없지만, 일반적으로 함수는 상대적으로 짧고 이상적으로는 하나의 특정 작업 만 수행해야한다는 데 동의합니다. 이 때문에 매우 긴 코드 조각을 사용하거나 여러 가지 다른 작업을 수행하고 이해하기 쉬운 작은 조각으로 나누는 것이 좋은 프로그래밍 관행입니다.</target>
        </trans-unit>
        <trans-unit id="2ce91fabee949d5ba66d92e41ee08124438c9737" translate="yes" xml:space="preserve">
          <source>For async action creators using &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; or other middleware, it's best to completely mock the Redux store for tests. You can apply the middleware to a mock store using &lt;a href=&quot;https://github.com/arnaudbenard/redux-mock-store&quot;&gt;redux-mock-store&lt;/a&gt;. You can also use &lt;a href=&quot;https://github.com/pgte/nock&quot;&gt;nock&lt;/a&gt; to mock the HTTP requests.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;Redux Thunk&lt;/a&gt; 또는 기타 미들웨어를 사용하는 비동기 조치 작성자 의 경우 테스트를 위해 Redux 저장소를 완전히 조롱하는 것이 가장 좋습니다. &lt;a href=&quot;https://github.com/arnaudbenard/redux-mock-store&quot;&gt;redux-mock-store를&lt;/a&gt; 사용하여 미들웨어를 mock 상점에 적용 할 수 있습니다 . &lt;a href=&quot;https://github.com/pgte/nock&quot;&gt;nock&lt;/a&gt; 을 사용 하여 HTTP 요청을 조롱 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fd7c213802a3dd8c216e494ed4fd0e167b08890" translate="yes" xml:space="preserve">
          <source>For clarity, these terms will be used to distinguish between different types of functions and different use cases:</source>
          <target state="translated">명확하게하기 위해이 용어들은 다른 유형의 기능과 다른 사용 사례를 구별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="264e5e569126bec0eceb43b84e1205a13c4b6e76" translate="yes" xml:space="preserve">
          <source>For convenience, you can also pass a single function as the first argument, and get a function in return.</source>
          <target state="translated">편의상 단일 함수를 첫 번째 인수로 전달하고 함수를 반환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a90bf7f5a9bb0b7bee51eca7178498d0496d1d7b" translate="yes" xml:space="preserve">
          <source>For copying very large objects, &lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;plain JavaScript can be over 100 times slower&lt;/a&gt; than an optimized immutable library.</source>
          <target state="translated">매우 큰 객체를 복사하는 경우 &lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;일반 JavaScript&lt;/a&gt; 는 최적화 된 불변 라이브러리보다 100 배 이상 느릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7525b69cd07a6f2ad0ac830aafa7a477337193ed" translate="yes" xml:space="preserve">
          <source>For every list of items, you'll want to store &lt;code&gt;isFetching&lt;/code&gt; to show a spinner, &lt;code&gt;didInvalidate&lt;/code&gt; so you can later toggle it when the data is stale, &lt;code&gt;lastUpdated&lt;/code&gt; so you know when it was fetched the last time, and the &lt;code&gt;items&lt;/code&gt; themselves. In a real app, you'll also want to store pagination state like &lt;code&gt;fetchedPageCount&lt;/code&gt; and &lt;code&gt;nextPageUrl&lt;/code&gt;.</source>
          <target state="translated">항목의 모든 목록을 저장하려는 것이다 &lt;code&gt;isFetching&lt;/code&gt; 스피너를 보여주기 위해, &lt;code&gt;didInvalidate&lt;/code&gt; 데이터가 오래된 경우에 당신은 토글, 나중에 할 수 있습니다 &lt;code&gt;lastUpdated&lt;/code&gt; 는 당신은 가져 왔을 마지막으로, 그리고 알 수 있도록 &lt;code&gt;items&lt;/code&gt; 자체. 실제 앱에서는 &lt;code&gt;fetchedPageCount&lt;/code&gt; 및 &lt;code&gt;nextPageUrl&lt;/code&gt; 과 같은 페이지 매김 상태를 저장하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="cd5da791bf1d292d4b08f432961ce1f7ce752416" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk&lt;/a&gt; lets the action creators invert control by dispatching functions. They would receive &lt;a href=&quot;store#dispatch&quot;&gt;&lt;code&gt;dispatch&lt;/code&gt;&lt;/a&gt; as an argument and may call it asynchronously. Such functions are called &lt;em&gt;thunks&lt;/em&gt;. Another example of middleware is &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt;. It lets you dispatch a &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt; async action, and dispatches a normal action when the Promise resolves.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;https://github.com/gaearon/redux-thunk&quot;&gt;redux-thunk를&lt;/a&gt; 사용하면 액션 작성자가 함수를 전달하여 제어를 반전시킬 수 있습니다. 그들은 &lt;a href=&quot;store#dispatch&quot;&gt; &lt;code&gt;dispatch&lt;/code&gt; &lt;/a&gt; 을 인수로 받아 비동기 적으로 호출 할 수 있습니다. 이러한 기능을 &lt;em&gt;썽크&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . 미들웨어의 다른 예는 &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; 입니다. 그것은 당신이 파견 할 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;약속을&lt;/a&gt; 행동 비동기 및 정상 동작 할 때 약속의 결의를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="c10a32bf34bb234c4f4d4ea0c462233658b63285" translate="yes" xml:space="preserve">
          <source>For example, a reducer like this is wrong because it mutates the state:</source>
          <target state="translated">예를 들어, 이와 같은 감속기는 상태를 변경하기 때문에 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="bc9e2d4355c30145cce077b91c60d63448e5aed4" translate="yes" xml:space="preserve">
          <source>For example, instead of &lt;code&gt;myObj.prop1.prop2.prop3&lt;/code&gt;, you would use &lt;code&gt;myImmutableMap.getIn([&amp;lsquo;prop1&amp;rsquo;, &amp;lsquo;prop2&amp;rsquo;, &amp;lsquo;prop3&amp;rsquo;])&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 대신 &lt;code&gt;myObj.prop1.prop2.prop3&lt;/code&gt; , 다음을 사용 &lt;code&gt;myImmutableMap.getIn([&amp;lsquo;prop1&amp;rsquo;, &amp;lsquo;prop2&amp;rsquo;, &amp;lsquo;prop3&amp;rsquo;])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8910597d94358b44fab63079f57037fc6eedac16" translate="yes" xml:space="preserve">
          <source>For example, instead of calling &lt;code&gt;dispatch&lt;/code&gt; with an object literal:</source>
          <target state="translated">예를 들어 객체 리터럴로 &lt;code&gt;dispatch&lt;/code&gt; 를 호출하는 대신 :</target>
        </trans-unit>
        <trans-unit id="36409b0b5da0fd93351cad56b27c2cc459ec9cbc" translate="yes" xml:space="preserve">
          <source>For example, the following &lt;code&gt;mapStateToProps&lt;/code&gt; function will never trigger a re-render:</source>
          <target state="translated">예를 들어 다음 &lt;code&gt;mapStateToProps&lt;/code&gt; 함수는 다시 렌더링을 트리거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="405aef87040b2f5fe3183ef8ee7aaa8b9e2f3921" translate="yes" xml:space="preserve">
          <source>For example, the following will always trigger a re-render:</source>
          <target state="translated">예를 들어 다음은 항상 다시 렌더링을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="43b08550f3233d89fd265c7a809fdb23fce5207d" translate="yes" xml:space="preserve">
          <source>For example, the state shape of a counter app might look like this:</source>
          <target state="translated">예를 들어, 카운터 앱의 상태 모양은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4676e5ae615d02cd767e41c0d9c575c5c5363047" translate="yes" xml:space="preserve">
          <source>For example, you will no longer be able to reference an object&amp;rsquo;s properties through standard JavaScript dot or bracket notation. Instead, you must reference them via Immutable.JS&amp;rsquo;s &lt;code&gt;get()&lt;/code&gt; or &lt;code&gt;getIn()&lt;/code&gt; methods, which use an awkward syntax that accesses properties via an array of strings, each of which represents a property key.</source>
          <target state="translated">예를 들어, 표준 JavaScript 도트 또는 괄호 표기법을 통해 더 이상 객체의 속성을 참조 할 수 없습니다. 대신 Immutable.JS의 &lt;code&gt;get()&lt;/code&gt; 또는 &lt;code&gt;getIn()&lt;/code&gt; 메소드 를 통해이를 참조해야합니다.이 메소드는 문자열 배열을 통해 특성에 액세스하는 어색한 구문을 사용하며 각각은 특성 키를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="12b6ef57734c544f1e210f261517935088c63d17" translate="yes" xml:space="preserve">
          <source>For non-connected components, you may want to check what props are being passed in. A common issue is having a parent component re-bind a callback inside its render function, like &lt;code&gt;&amp;lt;Child onClick={this.handleClick.bind(this)} /&amp;gt;&lt;/code&gt;. That creates a new function reference every time the parent re-renders. It's generally good practice to only bind callbacks once in the parent component's constructor.</source>
          <target state="translated">연결되지 않은 구성 요소의 경우 전달되는 소품을 확인하고 싶을 수 있습니다. 일반적인 문제는 부모 구성 요소가 &lt;code&gt;&amp;lt;Child onClick={this.handleClick.bind(this)} /&amp;gt;&lt;/code&gt; 와 같이 렌더링 함수 내에 콜백을 다시 바인딩하는 것입니다. } /&amp;gt; . 부모가 다시 렌더링 할 때마다 새로운 함수 참조가 생성됩니다. 일반적으로 부모 구성 요소의 생성자에서 콜백을 한 번만 바인딩하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f37294e7b86a5fec1ad730201ca1b51e170da12c" translate="yes" xml:space="preserve">
          <source>For our example, we'll imagine there is an external datastore that contains the counter's initial value (Counter As A Service, or CaaS). We'll make a mock call over to them and build our initial state from the result. We'll start by building out our API call:</source>
          <target state="translated">이 예에서는 카운터의 초기 값 (Counter As A Service 또는 CaaS)을 포함하는 외부 데이터 스토어가 있다고 가정합니다. 우리는 그들에게 모의 전화를 걸고 결과에서 초기 상태를 구축 할 것입니다. API 호출을 구축하는 것으로 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="995f52d4ef9a4c2e7bfadd425b73b546c07eadfc" translate="yes" xml:space="preserve">
          <source>For our simplistic example, coercing our input into a number is sufficiently secure. If you're handling more complex input, such as freeform text, then you should run that input through an appropriate sanitization function, such as &lt;a href=&quot;https://www.npmjs.com/package/validator&quot;&gt;validator.js&lt;/a&gt;.</source>
          <target state="translated">간단한 예를 들어, 입력을 숫자로 강제 변환하는 것은 충분히 안전합니다. 자유형 텍스트와 같이보다 복잡한 입력을 처리하는 경우 &lt;a href=&quot;https://www.npmjs.com/package/validator&quot;&gt;validator.js&lt;/a&gt; 와 같은 적절한 살균 기능을 통해 해당 입력을 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7396dc033a9d17308dac01b1e6d7aa01bc7866e7" translate="yes" xml:space="preserve">
          <source>For our todo app, we want to store two different things:</source>
          <target state="translated">할 일 앱의 경우 두 가지 다른 것을 저장하려고합니다.</target>
        </trans-unit>
        <trans-unit id="b88fefd81c01717012ff82bfc5ac24328d967a87" translate="yes" xml:space="preserve">
          <source>For this example, we'll be using &lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt; as a simple web server. We also need to install the React bindings for Redux, since they are not included in Redux by default.</source>
          <target state="translated">이 예에서는 &lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt; 를 간단한 웹 서버로 사용 합니다. 또한 Redux에는 Reux 바인딩이 기본적으로 포함되어 있지 않기 때문에 Reux 바인딩을 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="f714199c4cde247b055dd1036923fa69c491b814" translate="yes" xml:space="preserve">
          <source>For time traveling, the Redux DevTools expect that replaying recorded actions would output a state value, but not change anything else. &lt;strong&gt;Side effects like mutation or asynchronous behavior will cause time travel to alter behavior between steps, breaking the application&lt;/strong&gt;.</source>
          <target state="translated">시간 여행의 경우 Redux DevTools는 기록 된 조치를 재생하면 상태 값이 출력되지만 다른 것은 변경하지 않을 것으로 예상합니다. &lt;strong&gt;돌연변이 또는 비동기 행동과 같은 부작용으로 인해 시간 이동으로 인해 단계 간 동작이 변경되어 응용 프로그램이 중단 될 수&lt;/strong&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d1154ea57349682fcc3f891e405a8a167837c09" translate="yes" xml:space="preserve">
          <source>For universal apps that run on the server, create a store instance with every request so that they are isolated. Dispatch a few data fetching actions to a store instance and wait for them to complete before rendering the app on the server.</source>
          <target state="translated">서버에서 실행되는 범용 앱의 경우 격리 될 수 있도록 모든 요청마다 상점 인스턴스를 작성하십시오. 몇 가지 데이터 페치 조치를 상점 인스턴스에 전달하고 서버에서 앱을 렌더링하기 전에 완료 될 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="92c80d0eb6a19f502dd39ce9e0007f6cec7683d4" translate="yes" xml:space="preserve">
          <source>Four Strategies for Organizing Code</source>
          <target state="translated">코드 구성을위한 4 가지 전략</target>
        </trans-unit>
        <trans-unit id="76682a747378edf323eb6fca480334e44800121b" translate="yes" xml:space="preserve">
          <source>Frequently, yes. There are various tradeoffs and opinions to consider, but there are many good reasons to use Immutable.JS. Do not underestimate the difficulty of trying to track down a property of your state tree that has been inadvertently mutated.</source>
          <target state="translated">그렇습니다. 고려해야 할 다양한 상충 관계와 의견이 있지만 Immutable.JS를 사용해야하는 많은 이유가 있습니다. 실수로 변형 된 상태 트리의 속성을 추적하는 데 어려움을 과소 평가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="46dc46fc099af2967e7cb377eb917390bbe8d91f" translate="yes" xml:space="preserve">
          <source>From Backbone</source>
          <target state="translated">백본에서</target>
        </trans-unit>
        <trans-unit id="3f765f89e7e86977403237359a10b70b8245b636" translate="yes" xml:space="preserve">
          <source>From Flux</source>
          <target state="translated">플럭스에서</target>
        </trans-unit>
        <trans-unit id="bfbacf3ec560ee96572c8e953a6aff0a1a3667b3" translate="yes" xml:space="preserve">
          <source>From Flux to Redux: Async Actions the easy way</source>
          <target state="translated">플럭스에서 Redux로 : 비동기 액션은 쉬운 방법</target>
        </trans-unit>
        <trans-unit id="75482a47184505a4b6fae82571885f1d4ef06ba7" translate="yes" xml:space="preserve">
          <source>From the very beginning, we need to stress that Redux has no relation to React. You can write Redux apps with React, Angular, Ember, jQuery, or vanilla JavaScript.</source>
          <target state="translated">처음부터 Redux는 React와 관련이 없다는 것을 강조해야합니다. React, Angular, Ember, jQuery 또는 vanilla JavaScript로 Redux 앱을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="224f84dc1c16ed87eb23acbffde43619f014060d" translate="yes" xml:space="preserve">
          <source>Full-Stack Redux Tutorial</source>
          <target state="translated">풀 스택 Redux 튜토리얼</target>
        </trans-unit>
        <trans-unit id="3823c3e33f7c5c6aab3e4cafa98d3b53883fbcdd" translate="yes" xml:space="preserve">
          <source>Functions for handling a specific update case, which often need parameters other than the typical &lt;code&gt;(state, action)&lt;/code&gt; pair</source>
          <target state="translated">일반적 &lt;code&gt;(state, action)&lt;/code&gt; 쌍 이외의 매개 변수가 필요한 특정 업데이트 사례를 처리하는 기능</target>
        </trans-unit>
        <trans-unit id="881a7f4ab6d6cdbe058390dcfebb91eedae46fb5" translate="yes" xml:space="preserve">
          <source>Functions which handle &lt;em&gt;all&lt;/em&gt; updates for a given slice of state. These functions do generally have the typical &lt;code&gt;(state, action)&lt;/code&gt; parameter signature</source>
          <target state="translated">주어진 상태 조각에 대한 &lt;em&gt;모든&lt;/em&gt; 업데이트를 처리 &lt;em&gt;하는&lt;/em&gt; 함수 . 이 함수들은 일반적으로 전형적인 &lt;code&gt;(state, action)&lt;/code&gt; 파라미터 서명을 가지고 있습니다</target>
        </trans-unit>
        <trans-unit id="669174087b9bbb07e556f8eda6679016d67b42c9" translate="yes" xml:space="preserve">
          <source>Further Information</source>
          <target state="translated">추가 정보</target>
        </trans-unit>
        <trans-unit id="285d7a1408b289b80750e52c797a605ffba295ee" translate="yes" xml:space="preserve">
          <source>Further Suggestions</source>
          <target state="translated">추가 제안</target>
        </trans-unit>
        <trans-unit id="ec2268c82bc8b73813924087eddf93b3d9fbf05d" translate="yes" xml:space="preserve">
          <source>Further information</source>
          <target state="translated">추가 정보</target>
        </trans-unit>
        <trans-unit id="7d69e595b386dcd4b71cc9ff73b11b2154e10dd8" translate="yes" xml:space="preserve">
          <source>Furthermore, you can add additional layers of security by sanitizing your state output. &lt;code&gt;JSON.stringify&lt;/code&gt; can be subject to script injections. To counter this, you can scrub the JSON string of HTML tags and other dangerous characters. This can be done with either a simple text replacement on the string, e.g. &lt;code&gt;JSON.stringify(state).replace(/&amp;lt;/g, '\\u003c')&lt;/code&gt;, or via more sophisticated libraries such as &lt;a href=&quot;https://github.com/yahoo/serialize-javascript&quot;&gt;serialize-javascript&lt;/a&gt;.</source>
          <target state="translated">또한 상태 출력을 삭제하여 보안 계층을 추가 할 수 있습니다. &lt;code&gt;JSON.stringify&lt;/code&gt; 는 스크립트 삽입에 영향을받을 수 있습니다. 이를 방지하기 위해 JSON 문자열의 HTML 태그 및 기타 위험한 문자를 제거 할 수 있습니다. 이는 문자열에서 간단한 텍스트 대체 &lt;code&gt;JSON.stringify(state).replace(/&amp;lt;/g, '\\u003c')&lt;/code&gt; 예 : JSON.stringify (state) .replace (/ &amp;lt;/ g, '\\ u003c') 또는 &lt;a href=&quot;https://github.com/yahoo/serialize-javascript&quot;&gt;serialize-javascript&lt;/a&gt; 와 같은보다 정교한 라이브러리를 통해 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="c4692b39bf633417d53521cb512f44dbc259440a" translate="yes" xml:space="preserve">
          <source>Generating Action Creators</source>
          <target state="translated">액션 생성기 생성</target>
        </trans-unit>
        <trans-unit id="179c9a970856be2ac8a72de045cb7b6d6b4b6c90" translate="yes" xml:space="preserve">
          <source>Generating Reducers</source>
          <target state="translated">감속기 생성</target>
        </trans-unit>
        <trans-unit id="46c1ccf8c4dcce798c8264f04e642d8a0159063d" translate="yes" xml:space="preserve">
          <source>Getting Started with React, Redux, and Immutable</source>
          <target state="translated">React, Redux 및 Immutable 시작하기</target>
        </trans-unit>
        <trans-unit id="3185ff60f7a746675039a0e069131de1e5f61876" translate="yes" xml:space="preserve">
          <source>Gist: Breaking out of Redux paradigm to isolate apps</source>
          <target state="translated">요점 : 앱을 분리하기위한 Redux 패러다임 탈피</target>
        </trans-unit>
        <trans-unit id="10ae5196eb35af7600e4766e0ded323420cfe70a" translate="yes" xml:space="preserve">
          <source>Gist: Redux-Thunk examples</source>
          <target state="translated">요지 : Redux-Thunk 예제</target>
        </trans-unit>
        <trans-unit id="244ed27647275ec13c3db28bb136d4743fa6b213" translate="yes" xml:space="preserve">
          <source>Gist: state mutations</source>
          <target state="translated">요지 : 상태 돌연변이</target>
        </trans-unit>
        <trans-unit id="8f8269375bc0d8516c14e2645a941c5fefb4b9c0" translate="yes" xml:space="preserve">
          <source>Given this middleware we just wrote:</source>
          <target state="translated">우리는이 미들웨어를 방금 썼습니다 :</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="6236cf415b3887e7fa20a5499f765aa16f7720ff" translate="yes" xml:space="preserve">
          <source>Guaranteed immutability</source>
          <target state="translated">불변성 보장</target>
        </trans-unit>
        <trans-unit id="229bbdd56d74f7206cf36e6c06a296b111d18641" translate="yes" xml:space="preserve">
          <source>HN: Is there any huge web application built using Redux?</source>
          <target state="translated">HN : Redux를 사용하여 구축 된 거대한 웹 애플리케이션이 있습니까?</target>
        </trans-unit>
        <trans-unit id="74133e32e5bca2a26d927cd61a1825ca6cda78f2" translate="yes" xml:space="preserve">
          <source>Handcrafting an Isomorphic Redux Application (With Love)</source>
          <target state="translated">동형 리덕스 응용 프로그램 제작 (사랑)</target>
        </trans-unit>
        <trans-unit id="cc392181cc37736073babefa3f6b0cbb53acb816" translate="yes" xml:space="preserve">
          <source>Handles unregistering of listeners via the function returned by &lt;a href=&quot;../api/store#subscribe&quot;&gt;&lt;code&gt;subscribe(listener)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../api/store#subscribe&quot;&gt; &lt;code&gt;subscribe(listener)&lt;/code&gt; &lt;/a&gt; 반환 한 함수를 통해 리스너 등록 해제를 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="c7d811048186a91e33bc9331b69a6d594a01ea8e" translate="yes" xml:space="preserve">
          <source>Handling Actions</source>
          <target state="translated">취급 조치</target>
        </trans-unit>
        <trans-unit id="3b7e8e8b24ce8d7679b9a35675bb0a5a7fc840b3" translate="yes" xml:space="preserve">
          <source>Handling More Actions</source>
          <target state="translated">추가 조치 처리</target>
        </trans-unit>
        <trans-unit id="953d7b032c3bd0ac312412488e804519480a1aca" translate="yes" xml:space="preserve">
          <source>Handling Other Actions</source>
          <target state="translated">다른 행동 취급</target>
        </trans-unit>
        <trans-unit id="b97703fb2d2356eb6114659a0c343d14449211c9" translate="yes" xml:space="preserve">
          <source>Handling Redo</source>
          <target state="translated">재실행 처리</target>
        </trans-unit>
        <trans-unit id="f326b5a21b8a49169e4839d3f63669543242d741" translate="yes" xml:space="preserve">
          <source>Handling Undo</source>
          <target state="translated">실행 취소</target>
        </trans-unit>
        <trans-unit id="988ce2e99df35e16eb481b727e182b8b8087a2b5" translate="yes" xml:space="preserve">
          <source>Handling the Request</source>
          <target state="translated">요청 처리</target>
        </trans-unit>
        <trans-unit id="2e05fe2ae332d92f70e77aaf42eb727d3dd91277" translate="yes" xml:space="preserve">
          <source>Here is an &lt;code&gt;App&lt;/code&gt; component that renders three &lt;code&gt;VisibleTodoList&lt;/code&gt; components, each of which has a &lt;code&gt;listId&lt;/code&gt; prop:</source>
          <target state="translated">다음은 3 개의 &lt;code&gt;VisibleTodoList&lt;/code&gt; 컴포넌트를 렌더링 하는 &lt;code&gt;App&lt;/code&gt; 컴포넌트입니다 . 각 컴포넌트에는 &lt;code&gt;listId&lt;/code&gt; prop가 있습니다.</target>
        </trans-unit>
        <trans-unit id="23ae030423c3a4339c6c0b04d05978042792f95c" translate="yes" xml:space="preserve">
          <source>Here is an example of such a HOC:</source>
          <target state="translated">이러한 HOC의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8446f01d6be3b14bffe6480fb53ea4f664e0a65d" translate="yes" xml:space="preserve">
          <source>Here is our code so far. It is rather verbose:</source>
          <target state="translated">지금까지의 코드는 다음과 같습니다. 오히려 장황하다 :</target>
        </trans-unit>
        <trans-unit id="01a60734010e587fd0830a7e888c7853a46bf0c7" translate="yes" xml:space="preserve">
          <source>Here's an example action which represents adding a new todo item:</source>
          <target state="translated">다음은 새 할 일 항목 추가를 나타내는 동작 예입니다.</target>
        </trans-unit>
        <trans-unit id="58052dece84922788386c735487e1b86cccdad36" translate="yes" xml:space="preserve">
          <source>Here's an example of how use of ES6 object literal shorthand with &lt;code&gt;combineReducers&lt;/code&gt; can define the state shape:</source>
          <target state="translated">다음은 &lt;code&gt;combineReducers&lt;/code&gt; 와 함께 ES6 객체 리터럴 속기를 사용하여 상태 모양을 정의하는 방법에 대한 예입니다 .</target>
        </trans-unit>
        <trans-unit id="2070c6c8e07ed8692f85545a5ee98fc311bf9af4" translate="yes" xml:space="preserve">
          <source>Here's how &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; works. Let's say you have two reducers, one for a list of todos, and another for the currently selected filter setting:</source>
          <target state="translated">&lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt; 작동 방식은 다음과 같습니다 . 두 개의 감속기가 있는데, 하나는 할 일 목록 용이고 다른 하나는 현재 선택된 필터 설정에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="184bf60ef71f5a65467a6a7e96127cd713b7a9bf" translate="yes" xml:space="preserve">
          <source>Here's how to apply it to a Redux store:</source>
          <target state="translated">Redux 스토어에 적용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c90015c747ff3bb6a4ca0fc41c0c7d1de4924c13" translate="yes" xml:space="preserve">
          <source>Here's what the state shape for our &amp;ldquo;Reddit headlines&amp;rdquo; app might look like:</source>
          <target state="translated">&quot;Reddit 헤드 라인&quot;앱의 상태 모양은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3e2ce3154db89332ee8e9029cbb43d7deffada1" translate="yes" xml:space="preserve">
          <source>Here, we assume that you understand reducer composition with &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt;, as described in the &lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;Splitting Reducers&lt;/a&gt; section on the &lt;a href=&quot;../basics/index&quot;&gt;basics guide&lt;/a&gt;. If you don't, please &lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;read it first&lt;/a&gt;.</source>
          <target state="translated">여기서는 &lt;a href=&quot;../basics/index&quot;&gt;기본 안내서&lt;/a&gt; 의 &lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;Splitting Reducers&lt;/a&gt; 섹션에 설명 된대로 &lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt; 하여 Reducer 구성을 이해한다고 가정합니다 . 그렇지 않은 경우 &lt;a href=&quot;../basics/reducers#splitting-reducers&quot;&gt;먼저 읽으십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="47fb358d9a27b7f7c208a41f405f09df333fd295" translate="yes" xml:space="preserve">
          <source>High Performance Redux Apps</source>
          <target state="translated">고성능 Redux 앱</target>
        </trans-unit>
        <trans-unit id="7a6176fc50b39dc51f67828e874d1a9c381927a9" translate="yes" xml:space="preserve">
          <source>High-Performance Redux</source>
          <target state="translated">고성능 Redux</target>
        </trans-unit>
        <trans-unit id="e0aade7f036690bfbe818641db114550adf02045" translate="yes" xml:space="preserve">
          <source>Higher order reducers</source>
          <target state="translated">고차 감속기</target>
        </trans-unit>
        <trans-unit id="661e90fbdb35e42cd0f11c03ad2413796fd99f73" translate="yes" xml:space="preserve">
          <source>Holds application state;</source>
          <target state="translated">응용 프로그램 상태를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="70558178e9ca9037c4306a5560966893b2ba1623" translate="yes" xml:space="preserve">
          <source>How can I implement authentication in Redux?</source>
          <target state="translated">Redux에서 인증을 어떻게 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="cbbe1f27c0ff1e15f55cf992eaea12f8ad35811b" translate="yes" xml:space="preserve">
          <source>How can I reduce the number of store update events?</source>
          <target state="translated">상점 업데이트 이벤트 수를 줄이려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="fb6d20f2240e1c560f741e78debd31b4eea339de" translate="yes" xml:space="preserve">
          <source>How can I represent &amp;ldquo;side effects&amp;rdquo; such as AJAX calls? Why do we need things like &amp;ldquo;action creators&amp;rdquo;, &amp;ldquo;thunks&amp;rdquo;, and &amp;ldquo;middleware&amp;rdquo; to do async behavior?</source>
          <target state="translated">AJAX 호출과 같은 &quot;부작용&quot;을 어떻게 나타낼 수 있습니까? 비동기 동작을 수행하기 위해&amp;ldquo;액션 제작자&amp;rdquo;,&amp;ldquo;썽크&amp;rdquo;및&amp;ldquo;미들웨어&amp;rdquo;와 같은 것들이 필요한 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8281d5ee1ef4deaaed00468f7711255feaa03216" translate="yes" xml:space="preserve">
          <source>How can I speed up my &lt;code&gt;mapStateToProps&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;mapStateToProps&lt;/code&gt; 속도를 어떻게 높일 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="341af2b298ee968641c89dc8fc39d6a76071ec0f" translate="yes" xml:space="preserve">
          <source>How can I speed up my mapStateToProps?</source>
          <target state="translated">mapStateToProps 속도를 어떻게 높일 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="074c1f363f6a663f824f52ea0c32767c57407e9c" translate="yes" xml:space="preserve">
          <source>How can immutability in &lt;code&gt;mapStateToProps&lt;/code&gt; cause components to render unnecessarily?</source>
          <target state="translated">&lt;code&gt;mapStateToProps&lt;/code&gt; 의 불변성으로 인해 구성 요소가 불필요하게 렌더링 되는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="b224cf4298710c4b3d505de8354cfc9ba8c010d0" translate="yes" xml:space="preserve">
          <source>How can immutability in mapStateToProps cause components to render unnecessarily?</source>
          <target state="translated">mapStateToProps의 불변성으로 인해 구성 요소가 불필요하게 렌더링되는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="2afd69541aac46a2c40250df385736019b6c57fc" translate="yes" xml:space="preserve">
          <source>How can immutability in your reducers cause components to render unnecessarily?</source>
          <target state="translated">감속기의 불변성으로 인해 구성 요소가 불필요하게 렌더링되는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="03c2da4eb5dd93b3bf52e21145059bf09d5e25b4" translate="yes" xml:space="preserve">
          <source>How do I organize nested or duplicate data in my state?</source>
          <target state="translated">내 주에서 내포되거나 중복 된 데이터를 어떻게 구성합니까?</target>
        </trans-unit>
        <trans-unit id="f37efe0864de2a013d86c02169f816af32cb5f56" translate="yes" xml:space="preserve">
          <source>How do I share state between two reducers? Do I have to use &lt;code&gt;combineReducers&lt;/code&gt;?</source>
          <target state="translated">두 감속기간에 상태를 공유하려면 어떻게합니까? &lt;code&gt;combineReducers&lt;/code&gt; 를 사용해야 합니까 ?</target>
        </trans-unit>
        <trans-unit id="2a2bb6943dc8bbb29ceaf8280fcfbee59990be7f" translate="yes" xml:space="preserve">
          <source>How do I share state between two reducers? Do I have to use combineReducers?</source>
          <target state="translated">두 감속기간에 상태를 공유하려면 어떻게합니까? combineReducers를 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="39a19a487dfb8b0307ebc780f2d744e66346a60f" translate="yes" xml:space="preserve">
          <source>How do I subscribe to only a portion of the state? Can I get the dispatched action as part of the subscription?</source>
          <target state="translated">주의 일부만 구독하려면 어떻게합니까? 구독의 일부로 발송 된 작업을받을 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="970d13e8ba247d72a23a1227b9eb76ab329d86fd" translate="yes" xml:space="preserve">
          <source>How do Shallow and Deep Equality Checking differ?</source>
          <target state="translated">얕은 심도 평등 검사는 어떻게 다릅니 까?</target>
        </trans-unit>
        <trans-unit id="28c2d5d8451c047bc1a0f4cecf88ad6567282a2d" translate="yes" xml:space="preserve">
          <source>How do shallow and deep equality checking differ?</source>
          <target state="translated">얕고 깊은 평등 검사는 어떻게 다릅니 까?</target>
        </trans-unit>
        <trans-unit id="26ccec8f1ac279469a0f68091311d50666024b89" translate="yes" xml:space="preserve">
          <source>How do we actually delegate the control over the &lt;code&gt;present&lt;/code&gt; state to a custom reducer?</source>
          <target state="translated">실제로 &lt;code&gt;present&lt;/code&gt; 상태에 대한 제어권을 커스텀 리듀서에 어떻게 위임 합니까?</target>
        </trans-unit>
        <trans-unit id="fff3cc86a8e920d14e4b6d08ec84a36cf3ae1884" translate="yes" xml:space="preserve">
          <source>How do we approach this with Redux?</source>
          <target state="translated">Redux로 어떻게 접근합니까?</target>
        </trans-unit>
        <trans-unit id="30c14f55ced4d84011da65e3315eb866d4d9ce19" translate="yes" xml:space="preserve">
          <source>How do we include the Redux Thunk middleware in the dispatch mechanism? We use the &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt; store enhancer from Redux, as shown below:</source>
          <target state="translated">디스패치 메커니즘에 Redux Thunk 미들웨어를 어떻게 포함합니까? 다음과 같이 Redux 의 &lt;a href=&quot;../api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt; 스토어 인핸서를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="8959099626f271882311c3c243bbfdda634b6be4" translate="yes" xml:space="preserve">
          <source>How does &lt;code&gt;combineReducers&lt;/code&gt; use shallow equality checking?</source>
          <target state="translated">어떻게 &lt;code&gt;combineReducers&lt;/code&gt; 는 얕은 평등 검사를 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="e264f190d3a7100ff16f8e0b792baf3242dd0158" translate="yes" xml:space="preserve">
          <source>How does React-Redux use shallow equality checking to determine whether a component needs re-rendering?</source>
          <target state="translated">React-Redux는 얕은 평등 검사를 사용하여 구성 요소를 다시 렌더링해야하는지 여부를 어떻게 결정합니까?</target>
        </trans-unit>
        <trans-unit id="13f4f9bb8ec7adca1dffda3a094e04eb9bf81ce9" translate="yes" xml:space="preserve">
          <source>How does React-Redux use shallow equality checking?</source>
          <target state="translated">React-Redux는 얕은 평등 검사를 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="b5cc6209f66bc3c55e7f41aa1d6494bbd46dc8e9" translate="yes" xml:space="preserve">
          <source>How does Redux use shallow equality checking?</source>
          <target state="translated">Redux는 얕은 동등성 검사를 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="96952132f67badca2ba5bab5e41044f8fb225996" translate="yes" xml:space="preserve">
          <source>How does immutability enable a shallow check to detect object mutations?</source>
          <target state="translated">불변성이 얕은 검사를 통해 객체 돌연변이를 어떻게 감지합니까?</target>
        </trans-unit>
        <trans-unit id="258f5cf42a9d12d463ef4f13ff6a4e2964d9748d" translate="yes" xml:space="preserve">
          <source>How putting too much logic in action creators could affect debugging</source>
          <target state="translated">액션 제작자에 너무 많은 로직을 배치하면 디버깅에 영향을 줄 수있는 방법</target>
        </trans-unit>
        <trans-unit id="a4c23c5f78cdee9be5d0a8aa246f623d02051202" translate="yes" xml:space="preserve">
          <source>How should I split my logic between reducers and action creators? Where should my &amp;ldquo;business logic&amp;rdquo; go?</source>
          <target state="translated">리듀서와 액션 제작자간에 논리를 어떻게 분리해야합니까? &quot;비즈니스 로직&quot;은 어디로 가야합니까?</target>
        </trans-unit>
        <trans-unit id="844c750f088f6ec26d17f13bffa791aa0381caa4" translate="yes" xml:space="preserve">
          <source>How things look (markup, styles)</source>
          <target state="translated">물건 모양 (마크 업, 스타일)</target>
        </trans-unit>
        <trans-unit id="c4042ce0bd829dee86f5f8db37a02e8a871f8f88" translate="yes" xml:space="preserve">
          <source>How things work (data fetching, state updates)</source>
          <target state="translated">작동 방식 (데이터 가져 오기, 상태 업데이트)</target>
        </trans-unit>
        <trans-unit id="fa346393f4fb3e9654b9c58c84d9e7de2aec74bf" translate="yes" xml:space="preserve">
          <source>How to Scale React Applications</source>
          <target state="translated">반응 응용 프로그램을 확장하는 방법</target>
        </trans-unit>
        <trans-unit id="47937596549577004fa72bfb56667e643c361800" translate="yes" xml:space="preserve">
          <source>How to handle state in React: the missing FAQ</source>
          <target state="translated">React에서 상태를 처리하는 방법 : 누락 된 FAQ</target>
        </trans-unit>
        <trans-unit id="49dee5bfff40b97a93bb5e0172be4f4d25ffb4f5" translate="yes" xml:space="preserve">
          <source>How to think in terms of combining functions</source>
          <target state="translated">기능 결합 측면에서 생각하는 방법</target>
        </trans-unit>
        <trans-unit id="5a44fd27737b51871064dcba886fdf85182ed8ca" translate="yes" xml:space="preserve">
          <source>How well does Redux &amp;ldquo;scale&amp;rdquo; in terms of performance and architecture?</source>
          <target state="translated">Redux는 성능과 아키텍처 측면에서 얼마나 잘 확장됩니까?</target>
        </trans-unit>
        <trans-unit id="d5049bfb2117becfff285cdc67dde0f10a6d2171" translate="yes" xml:space="preserve">
          <source>How you structure the root reducer is completely up to you. Redux ships with a &lt;a href=&quot;../api/combinereducers&quot;&gt;&lt;code&gt;combineReducers()&lt;/code&gt;&lt;/a&gt; helper function, useful for &amp;ldquo;splitting&amp;rdquo; the root reducer into separate functions that each manage one branch of the state tree.</source>
          <target state="translated">루트 리듀서를 구성하는 방법은 전적으로 귀하에게 달려 있습니다. Redux 는 루트 리듀서를 각각 상태 트리의 한 분기를 관리하는 별도의 함수로 &quot;분할&quot;할 수 있는 &lt;a href=&quot;../api/combinereducers&quot;&gt; &lt;code&gt;combineReducers()&lt;/code&gt; &lt;/a&gt; 도우미 함수 와 함께 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d072600a3b53bb4cfed12bc142b48432221674c" translate="yes" xml:space="preserve">
          <source>However, creating new stores shouldn't be your first instinct, especially if you come from a Flux background. Try reducer composition first, and only use multiple stores if it doesn't solve your problem.</source>
          <target state="translated">그러나 새로운 매장을 만드는 것이 첫 번째 본능이되어서는 안됩니다. 특히 Flux 배경을 가지고 있다면 더욱 그렇습니다. 감속기 구성을 먼저 시도하고 문제가 해결되지 않으면 여러 상점 만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="27352aa59f7116a388d254a03cb3ffe5f2f70e56" translate="yes" xml:space="preserve">
          <source>However, even if you happen to have many different reducer functions composed together, and even with deeply nested state, reducer speed is unlikely to be a problem. JavaScript engines are capable of running a very large number of function calls per second, and most of your reducers are probably just using a &lt;code&gt;switch&lt;/code&gt; statement and returning the existing state by default in response to most actions.</source>
          <target state="translated">그러나 여러 가지 감속기 기능이 함께 구성되어 있고 깊이 중첩 된 상태에서도 감속기 속도는 문제가되지 않습니다. JavaScript 엔진은 초당 매우 많은 함수 호출을 실행할 수 있으며 대부분의 감속기는 아마도 &lt;code&gt;switch&lt;/code&gt; 문을 사용하고 대부분의 작업에 대한 응답으로 기본적으로 기존 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="209c7d1b896b9b48924c44438236581d9ba02ccc" translate="yes" xml:space="preserve">
          <source>However, guaranteeing immutability with JavaScript is difficult, and it can be easy to mutate an object accidentally, causing bugs in your app that are extremely difficult to locate. For this reason, using an immutable update utility library such as Immutable.JS can significantly improve the reliability of your app, and make your app&amp;rsquo;s development much easier.</source>
          <target state="translated">그러나 JavaScript를 사용하여 불변성을 보장하는 것은 어렵고 실수로 객체를 쉽게 변형하여 앱에서 찾기가 매우 어려운 버그를 유발할 수 있습니다. 따라서 Immutable.JS와 같은 변경 불가능한 업데이트 유틸리티 라이브러리를 사용하면 앱의 안정성이 크게 향상되고 앱 개발이 훨씬 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="007edd469aeadd3134e72ff280534f419b360c63" translate="yes" xml:space="preserve">
          <source>However, if you wrap &lt;a href=&quot;createstore&quot;&gt;&lt;code&gt;createStore&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware&lt;/code&gt;&lt;/a&gt;, the middleware can interpret actions differently, and provide support for dispatching &lt;a href=&quot;../glossary#async-action&quot;&gt;async actions&lt;/a&gt;. Async actions are usually asynchronous primitives like Promises, Observables, or thunks.</source>
          <target state="translated">그러나 &lt;a href=&quot;applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware&lt;/code&gt; 로&lt;/a&gt;&lt;a href=&quot;createstore&quot;&gt; &lt;code&gt;createStore&lt;/code&gt; &lt;/a&gt; 를 랩핑 하면 미들웨어가 조치를 다르게 해석하고 &lt;a href=&quot;../glossary#async-action&quot;&gt;비동기 조치&lt;/a&gt; 발송을 지원할 수 있습니다. 비동기 작업은 일반적으로 약속, 관찰 가능 또는 썽크와 같은 비동기 기본 형식입니다.</target>
        </trans-unit>
        <trans-unit id="ef6ac0b7fe7b68443642555f387d0a08b371f125" translate="yes" xml:space="preserve">
          <source>However, in our Redux App we will still need &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt;. &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; is the higher-order component provided by React Redux that lets you bind Redux to React (see &lt;a href=&quot;../basics/usagewithreact&quot;&gt;Usage with React&lt;/a&gt;).</source>
          <target state="translated">그러나 Redux 앱에는 여전히 &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; 가 필요합니다 . &lt;code&gt;&amp;lt;Provider /&amp;gt;&lt;/code&gt; 는 Reux Redux에서 제공하는 상위 구성 요소로 Redux를 React에 바인딩 할 수 있습니다 ( &lt;a href=&quot;../basics/usagewithreact&quot;&gt;React와 함께 사용&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0bf708fc8c3314c936b8e0786f74c3d98798623d" translate="yes" xml:space="preserve">
          <source>However, it is important that we keep logging and crash reporting separate. Ideally we want them to be different modules, potentially in different packages. Otherwise we can't have an ecosystem of such utilities. (Hint: we're slowly getting to what middleware is!)</source>
          <target state="translated">그러나 로깅과 충돌보고를 별도로 유지하는 것이 중요합니다. 이상적으로는 다른 모듈, 잠재적으로 다른 패키지가되기를 원합니다. 그렇지 않으면 우리는 그러한 유틸리티의 생태계를 가질 수 없습니다. (힌트 : 우리는 미들웨어가 무엇인지 천천히 알고 있습니다!)</target>
        </trans-unit>
        <trans-unit id="9d31965c3ec47c4faba43c57bec50a234ddcbc5a" translate="yes" xml:space="preserve">
          <source>However, it is still monkeypatching.</source>
          <target state="translated">그러나 여전히 원숭이 패치입니다.</target>
        </trans-unit>
        <trans-unit id="b97da1c31078988cc6aa942ce9cf7c26c29a6edc" translate="yes" xml:space="preserve">
          <source>However, it's also important to understand that using Redux comes with tradeoffs. It's not designed to be the shortest or fastest way to write code. It's intended to help answer the question &quot;When did a certain slice of state change, and where did the data come from?&quot;, with predictable behavior. It does so by asking you to follow specific constraints in your application: store your application's state as plain data, describe changes as plain objects, and handle those changes with pure functions that apply updates immutably. This is often the source of complaints about &quot;boilerplate&quot;. These constraints require effort on the part of a developer, but also open up a number of additional possibilities (such as store persistence and synchronization).</source>
          <target state="translated">그러나 Redux를 사용하면 장단점이 있음을 이해해야합니다. 코드를 작성하는 가장 짧거나 빠른 방법이 아닙니다. 예측 가능한 동작으로 &quot;특정 상태 조각은 언제 변경되었으며 데이터는 어디서 왔습니까?&quot;라는 질문에 대한 답변을 제공하기위한 것입니다. 응용 프로그램의 특정 제약 조건을 따르도록 요청하여 응용 프로그램의 상태를 일반 데이터로 저장하고 변경 사항을 일반 객체로 설명하며 변경 사항을 불변으로 적용하는 순수한 함수로 변경 사항을 처리하도록 요청합니다. 이것은 종종 &quot;boilerplate&quot;에 대한 불만의 원인입니다. 이러한 제약 조건에는 개발자의 노력이 필요하지만 저장소 지속성 및 동기화와 같은 여러 가지 추가 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="83c39c3a93928d93c157bb221e087802a4b99e7d" translate="yes" xml:space="preserve">
          <source>However, remember that the key is that the &lt;em&gt;original in-memory reference&lt;/em&gt; is not modified. &lt;strong&gt;As long as we make a copy first, we can safely mutate the copy&lt;/strong&gt;. Note that this is true for both arrays and objects, but nested values still must be updated using the same rules.</source>
          <target state="translated">그러나 핵심은 &lt;em&gt;원래 메모리 내 참조&lt;/em&gt; 가 수정되지 않는다는 것입니다. &lt;strong&gt;복사본을 먼저 만드는 한 복사본을 안전하게 변경할 수 있습니다&lt;/strong&gt; . 이는 배열과 객체 모두에 해당하지만 중첩 된 값은 여전히 ​​동일한 규칙을 사용하여 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9b3dc33e56385563b9249f48fd1c5fc362f06f4" translate="yes" xml:space="preserve">
          <source>However, shallow checking will not work if your data encapsulated within an Immutable.JS object is itself an object. This is because Immutable.JS&amp;rsquo;s &lt;code&gt;toJS()&lt;/code&gt; method, which returns the data contained within an Immutable.JS object as a JavaScript value, will create a new object every time it&amp;rsquo;s called, and so break the reference with the encapsulated data.</source>
          <target state="translated">그러나 Immutable.JS 객체 내에 캡슐화 된 데이터가 자체 객체 인 경우 얕은 검사가 작동하지 않습니다. Immutable.JS 객체에 포함 된 데이터를 JavaScript 값으로 반환하는 Immutable.JS의 &lt;code&gt;toJS()&lt;/code&gt; 메서드는 호출 될 때마다 새 객체를 생성하므로 캡슐화 된 데이터와의 참조를 끊기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b519a9362c1955561b3e4941334f49ea0df524a1" translate="yes" xml:space="preserve">
          <source>However, this quickly gets repetitive because different components request data from the same API endpoints. Moreover, we want to reuse some of this logic (e.g., early exit when there is cached data available) from many components.</source>
          <target state="translated">그러나 서로 다른 구성 요소가 동일한 API 끝점에서 데이터를 요청하기 때문에이 과정이 빠르게 반복됩니다. 또한, 많은 컴포넌트에서이 로직의 일부 (예 : 캐시 된 데이터가있을 때 조기 종료)를 재사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="eb8c9304fae62928333a51a2b537a686e6b3a79a" translate="yes" xml:space="preserve">
          <source>However, we don't have to call &lt;code&gt;ReactDOM.render(&amp;lt;Provider&amp;gt;&amp;lt;App /&amp;gt;&amp;lt;/Provider&amp;gt;)&lt;/code&gt; if we're interested in hiding the fact that the sub-app component is a Redux app.</source>
          <target state="translated">그러나 하위 응용 프로그램 구성 요소가 Redux 응용 프로그램이라는 사실을 숨기려면 &lt;code&gt;ReactDOM.render(&amp;lt;Provider&amp;gt;&amp;lt;App /&amp;gt;&amp;lt;/Provider&amp;gt;)&lt;/code&gt; 를 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="30c62654e7682bc0051c67f69252368a8aa8daf0" translate="yes" xml:space="preserve">
          <source>However, when you import it, you're actually holding the wrapper component returned by &lt;code&gt;connect()&lt;/code&gt;, and not the &lt;code&gt;App&lt;/code&gt; component itself. If you want to test its interaction with Redux, this is good news: you can wrap it in a &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store&quot;&gt;&lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt;&lt;/a&gt; with a store created specifically for this unit test. But sometimes you want to test just the rendering of the component, without a Redux store.</source>
          <target state="translated">그러나 가져올 때 실제로 는 &lt;code&gt;App&lt;/code&gt; 구성 요소가 아니라 &lt;code&gt;connect()&lt;/code&gt; 에서 반환 한 래퍼 구성 요소를 보유하고 있습니다. Redux와의 상호 작용을 테스트하려는 경우 좋은 소식입니다. 이 단위 테스트를 위해 특별히 만든 저장소 를 사용하여 &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store&quot;&gt; &lt;code&gt;&amp;lt;Provider&amp;gt;&lt;/code&gt; &lt;/a&gt; 에 래핑 할 수 있습니다 . 그러나 때로는 Redux 저장소없이 구성 요소의 렌더링 만 테스트하려고합니다.</target>
        </trans-unit>
        <trans-unit id="b34092e543dd93b03e651093a3d7a3b5a60f9550" translate="yes" xml:space="preserve">
          <source>However, you &lt;em&gt;do&lt;/em&gt; need to create a copied and updated object for each level of nesting that is affected. Although that shouldn't be particularly expensive, it's another good reason why you should keep your state normalized and shallow if possible.</source>
          <target state="translated">그러나 &lt;em&gt;않는&lt;/em&gt; 영향을 중첩의 각 수준에 대한 복사 및 업데이트 객체를 생성해야합니다. 비용이 많이 들지는 않지만 가능하면 상태를 정상화하고 얕게 유지해야하는 또 다른 이유입니다.</target>
        </trans-unit>
        <trans-unit id="637b51ba07484e27e5e6b55d068f2f69a042cefb" translate="yes" xml:space="preserve">
          <source>I see the following presentational components and their props emerge from this brief:</source>
          <target state="translated">다음과 같은 프레젠테이션 구성 요소와 해당 소품이이 개요에서 나온 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc27465fc6ceedd55291ea4f132c806be70591bb" translate="yes" xml:space="preserve">
          <source>I would like to amend this: don't use Redux until you have problems with vanilla React.</source>
          <target state="translated">바닐라 리 액트에 문제가 생길 때까지 Redux를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ad18fcf9dd2ee8a9f5ea170593bb2c6bee68d60d" translate="yes" xml:space="preserve">
          <source>I wrote Redux while working on my React Europe talk called &lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;&amp;ldquo;Hot Reloading with Time Travel&amp;rdquo;&lt;/a&gt;. My goal was to create a state management library with minimal API but completely predictable behavior, so it is possible to implement logging, hot reloading, time travel, universal apps, record and replay, without any buy-in from the developer.</source>
          <target state="translated">Redux는 &lt;a href=&quot;https://www.youtube.com/watch?v=xsSnOQynTHs&quot;&gt;&quot;Reacting with Time Travel&quot;&lt;/a&gt; 이라는 React Europe 강의를 진행하면서 글을 썼습니다 . 저의 목표는 최소한의 API로 완벽하게 예측 가능한 동작으로 상태 관리 라이브러리를 만드는 것이므로 개발자의 구매없이 로깅, 핫 리로딩, 시간 여행, 범용 앱, 기록 및 재생을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="618b7ca25386b5f5436f346c2ed5051a72f4a73a" translate="yes" xml:space="preserve">
          <source>Idiomatic Redux: Normalizing the State Shape</source>
          <target state="translated">관용적 Redux : 상태 모양 정규화</target>
        </trans-unit>
        <trans-unit id="fe91fe24d5f9dd8e770fad3a725bc0cec34aab62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;applyMiddlewareByMonkeypatching&lt;/code&gt; doesn't assign &lt;code&gt;store.dispatch&lt;/code&gt; immediately after processing the first middleware, &lt;code&gt;store.dispatch&lt;/code&gt; will keep pointing to the original &lt;code&gt;dispatch&lt;/code&gt; function. Then the second middleware will also be bound to the original &lt;code&gt;dispatch&lt;/code&gt; function.</source>
          <target state="translated">경우 &lt;code&gt;applyMiddlewareByMonkeypatching&lt;/code&gt; 가 되지 할당하지 &lt;code&gt;store.dispatch&lt;/code&gt; 을 처음 미들웨어를 처리 한 후 즉시, &lt;code&gt;store.dispatch&lt;/code&gt; 는 원래 가리키는 유지할 &lt;code&gt;dispatch&lt;/code&gt; 기능. 그런 다음 두 번째 미들웨어도 원래 &lt;code&gt;dispatch&lt;/code&gt; 기능에 바인드됩니다 .</target>
        </trans-unit>
        <trans-unit id="35f456ed22b65b432754496a635957ff1170346a" translate="yes" xml:space="preserve">
          <source>If a Redux reducer directly mutates, and returns, the state object passed into it, the values of the root state object will change, but the object itself will not.</source>
          <target state="translated">Redux 감속기가 전달 된 상태 객체를 직접 변경하고 반환하면 루트 상태 객체의 값은 변경되지만 객체 자체는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a08f5491a0b259f6b66f794074ee1e3a74e48f7" translate="yes" xml:space="preserve">
          <source>If a reducer needs to know data from another slice of state, the state tree shape may need to be reorganized so that a single reducer is handling more of the data.</source>
          <target state="translated">리듀서가 다른 상태 슬라이스의 데이터를 알아야하는 경우 단일 리듀서가 더 많은 데이터를 처리 할 수 ​​있도록 상태 트리 모양을 재구성해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9faa62e0446c64c2b5f25f17a54da0f020cabc00" translate="yes" xml:space="preserve">
          <source>If an action creator needs to read the current state, perform an API call, or cause a side effect, like a routing transition, it should return an &lt;a href=&quot;#async-action&quot;&gt;async action&lt;/a&gt; instead of an action.</source>
          <target state="translated">조치 작성자가 현재 상태를 읽거나 API 호출을 수행하거나 라우팅 전이와 같은 부작용을 유발해야하는 경우 &lt;a href=&quot;#async-action&quot;&gt;조치&lt;/a&gt; 대신 비동기 조치 를 리턴해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e288fd9913bf6a8a74842392c22a2dd0b95c7906" translate="yes" xml:space="preserve">
          <source>If an object is immutable, any changes that need to be made to it within a function must be made to a &lt;em&gt;copy&lt;/em&gt; of the object.</source>
          <target state="translated">객체가 불변 인 경우, 함수 내에서 객체를 변경해야 할 경우 객체 의 &lt;em&gt;사본&lt;/em&gt; 을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e3b9f89d6838d129b565fe3186a16b253684268" translate="yes" xml:space="preserve">
          <source>If it does, the shallow equality check that &lt;code&gt;combineReducers&lt;/code&gt; performs will always pass, as the values of the state slice returned by the reducer may have been mutated, but the object itself has not - it&amp;rsquo;s still the same object that was passed to the reducer.</source>
          <target state="translated">만약 그렇다면 , reducer에 의해 리턴 된 state slice의 값이 변경되었을 수 있기 때문에 &lt;code&gt;combineReducers&lt;/code&gt; 가 수행 하는 얕은 동등성 검사 는 항상 통과 할 것입니다. 그러나 객체 자체는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecb66a4049905816e9b1a9b102420a18f13b1512" translate="yes" xml:space="preserve">
          <source>If logging and crash reporting are separate utilities, they might look like this:</source>
          <target state="translated">로깅 및 충돌보고가 별도의 유틸리티 인 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d10f3d1de6596be190d60a9a58973fddf0a134c" translate="yes" xml:space="preserve">
          <source>If no changes are needed, it should return the existing state as-is.</source>
          <target state="translated">변경이 필요하지 않으면 기존 상태를 그대로 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf9ad27c90229a42dd677eb94e9afe7a27ff90c9" translate="yes" xml:space="preserve">
          <source>If one of the values of the props object returned from &lt;code&gt;mapStateToProps&lt;/code&gt; is an object that persists across calls to &lt;code&gt;connect&lt;/code&gt; (such as, potentially, the root state object), yet is directly mutated and returned by a selector function, React-Redux will not be able to detect the mutation, and so will not trigger a re-render of the wrapped component.</source>
          <target state="translated">&lt;code&gt;mapStateToProps&lt;/code&gt; 에서 리턴 된 props 오브젝트의 값 중 하나가 &lt;code&gt;connect&lt;/code&gt; 호출 (예 : 잠재적으로 루트 상태 오브젝트) 을 통해 지속 되지만 선택기 함수에 의해 직접 변경되고 리턴되는 오브젝트 인 경우 React-Redux는 돌연변이를 검출 할 수 있고, 따라서 랩핑 된 구성 요소의 재 렌더링을 유발하지 않을 것이다.</target>
        </trans-unit>
        <trans-unit id="d5d728b3f7c8756b0e1d6727b86ff4b7f986fb4b" translate="yes" xml:space="preserve">
          <source>If such an operation is used as a selector function in &lt;code&gt;mapStateToProps&lt;/code&gt;, the shallow equality check that React-Redux performs on each value in the props object that&amp;rsquo;s returned will always fail, as the selector is returning a new object each time.</source>
          <target state="translated">이러한 작업이 &lt;code&gt;mapStateToProps&lt;/code&gt; 에서 선택기 함수로 사용되는 경우 선택기 가 매번 새 객체를 반환하므로 반환되는 props 객체의 각 값에 대해 React-Redux가 수행하는 얕은 동등성 검사는 항상 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c5ceb90dff402277125291134484216343d65527" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;state&lt;/code&gt; given to it is &lt;code&gt;undefined&lt;/code&gt;, it must return the initial state for this specific reducer. According to the previous rule, the initial state must not be &lt;code&gt;undefined&lt;/code&gt; either. It is handy to specify it with ES6 optional arguments syntax, but you can also explicitly check the first argument for being &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;state&lt;/code&gt; 그에게 주어진이되어 &lt;code&gt;undefined&lt;/code&gt; ,이 특정 감속기의 초기 상태를 반환해야합니다. 이전 규칙에 따르면 초기 상태도 &lt;code&gt;undefined&lt;/code&gt; 되지 않아야 합니다. ES6 선택적 인수 구문으로 지정하는 것이 편리하지만 &lt;code&gt;undefined&lt;/code&gt; 인 첫 번째 인수를 명시 적으로 확인할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54a886e11c2cb542f0ecf3d252296e52fe4603bb" translate="yes" xml:space="preserve">
          <source>If the check fails, however, the root state object &lt;em&gt;has&lt;/em&gt; been updated, and so &lt;code&gt;connect&lt;/code&gt; will call &lt;code&gt;mapStateToProps&lt;/code&gt;to see if the props for the wrapped component have been updated.</source>
          <target state="translated">그러나 확인에 실패하면 루트 상태 객체 &lt;em&gt;가&lt;/em&gt; 업데이트되었으므로 &lt;code&gt;connect&lt;/code&gt; 는 &lt;code&gt;mapStateToProps&lt;/code&gt; 를 호출 하여 랩핑 된 구성 요소의 prop이 업데이트되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7ddbf9b8aa21e91694b18c1515d700c56e251753" translate="yes" xml:space="preserve">
          <source>If the shallow equality check fails between the new values returned from &lt;code&gt;mapStateToProps&lt;/code&gt; and the previous values that React-Redux kept a reference to, then a re-rendering of the component will be triggered.</source>
          <target state="translated">&lt;code&gt;mapStateToProps&lt;/code&gt; 에서 반환 된 새 값 과 React-Redux가 참조를 유지 한 이전 값 간에 얕은 동등성 검사에 실패 하면 구성 요소의 다시 렌더링이 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="dc5775e4e8ec131359e210f027aac76d6574f7fe" translate="yes" xml:space="preserve">
          <source>If these functions are published as separate modules, we can later use them to patch our store:</source>
          <target state="translated">이러한 기능이 별도의 모듈로 게시 된 경우 나중에 해당 기능을 사용하여 상점을 패치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88d3eb0d142a4003073ed1cec6a2f5fd9c278548" translate="yes" xml:space="preserve">
          <source>If two different variables reference the same immutable object, then a simple equality check of the two variables is enough to determine that they are equal, and that the object they both reference is unchanged. The equality check never has to check the values of any of the object&amp;rsquo;s properties, as it is, of course, immutable.</source>
          <target state="translated">두 개의 서로 다른 변수가 동일한 불변 개체를 참조하는 경우 두 변수에 대한 간단한 동등 검사만으로도 같은지 여부와 둘 다 참조하는 개체가 변경되지 않은 것으로 확인할 수 있습니다. 동등성 검사는 물론 객체 속성의 값을 그대로 변경할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e8ff3107eee34b9cab68e06d253a65fa91028026" translate="yes" xml:space="preserve">
          <source>If we call &lt;code&gt;createStore&lt;/code&gt; without the &lt;code&gt;preloadedState&lt;/code&gt;, it's going to initialize the &lt;code&gt;state&lt;/code&gt; to &lt;code&gt;{}&lt;/code&gt;. Therefore, &lt;code&gt;state.a&lt;/code&gt; and &lt;code&gt;state.b&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; by the time it calls &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; reducers. &lt;strong&gt;Both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; reducers will receive &lt;code&gt;undefined&lt;/code&gt; as &lt;em&gt;their&lt;/em&gt; &lt;code&gt;state&lt;/code&gt; arguments, and if they specify default &lt;code&gt;state&lt;/code&gt; values, those will be returned.&lt;/strong&gt; This is how the combined reducer returns a &lt;code&gt;{ a: 'lol', b: 'wat' }&lt;/code&gt; state object on the first invocation.</source>
          <target state="translated">&lt;code&gt;preloadedState&lt;/code&gt; 없이 &lt;code&gt;createStore&lt;/code&gt; 를 호출 하면 &lt;code&gt;state&lt;/code&gt; 를 &lt;code&gt;{}&lt;/code&gt; (으) 로 초기화합니다 . 따라서 &lt;code&gt;state.a&lt;/code&gt; 및 &lt;code&gt;state.b&lt;/code&gt; 는 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 리듀서를 호출 할 때 &lt;code&gt;undefined&lt;/code&gt; . &lt;strong&gt;두 &lt;/strong&gt;&lt;strong&gt;와 &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;b&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 감속기 받게됩니다 &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;undefined&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 으로 &lt;/strong&gt;&lt;strong&gt;&lt;em&gt;자신의 &lt;/em&gt;&lt;/strong&gt;&lt;strong&gt; &lt;code&gt;state&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 인수, 그들은 기본적으로 지정하면 &lt;/strong&gt;&lt;strong&gt; &lt;code&gt;state&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 값을, 그 반환됩니다. &lt;/strong&gt;이것이 결합 감속기가 &lt;code&gt;{ a: 'lol', b: 'wat' }&lt;/code&gt; 반환하는 방법입니다.&lt;strong&gt; &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt; &lt;/strong&gt; 첫 번째 호출에서 상태 객체.</target>
        </trans-unit>
        <trans-unit id="8df247b3c417208103f01c75fc35280be43fc622" translate="yes" xml:space="preserve">
          <source>If we have a nested tree of slice reducers, each slice reducer will need to know how to respond to this action appropriately. We will need to include all the relevant data in the action. We need to update the correct Post object with the comment's ID, create a new Comment object using that ID as a key, and include the Comment's ID in the list of all Comment IDs. Here's how the pieces for this might fit together:</source>
          <target state="translated">슬라이스 리듀서의 중첩 트리가있는 경우 각 슬라이스 리듀서는이 조치에 적절하게 대응하는 방법을 알아야합니다. 조치에 모든 관련 데이터를 포함시켜야합니다. 주석의 ID로 올바른 Post 오브젝트를 업데이트하고 해당 ID를 키로 사용하여 새 Comment 오브젝트를 작성하고 모든 Comment ID 목록에 주석 ID를 포함시켜야합니다. 이것에 대한 조각이 어떻게 맞을 수 있는지 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb9835b5068457c01cd0ee22c6f2d1f319535710" translate="yes" xml:space="preserve">
          <source>If we pass &lt;code&gt;makeMapStateToProps&lt;/code&gt; to &lt;code&gt;connect&lt;/code&gt;, each instance of the &lt;code&gt;VisibleTodosList&lt;/code&gt; container will get its own &lt;code&gt;mapStateToProps&lt;/code&gt; function with a private &lt;code&gt;getVisibleTodos&lt;/code&gt; selector. Memoization will now work correctly regardless of the render order of the &lt;code&gt;VisibleTodoList&lt;/code&gt; containers.</source>
          <target state="translated">&lt;code&gt;makeMapStateToProps&lt;/code&gt; 를 전달 하여 &lt;code&gt;connect&lt;/code&gt; 하면 &lt;code&gt;VisibleTodosList&lt;/code&gt; 컨테이너 의 각 인스턴스 는 전용 &lt;code&gt;getVisibleTodos&lt;/code&gt; 선택기를 사용하여 자체 &lt;code&gt;mapStateToProps&lt;/code&gt; 함수를 가져옵니다 . &lt;code&gt;VisibleTodoList&lt;/code&gt; 컨테이너 의 렌더링 순서에 관계없이 메모가 올바르게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="e5f7ebaf8e95ed592e947bea2433fe217182ccf7" translate="yes" xml:space="preserve">
          <source>If we wanted to implement Undo and Redo in such an app, we'd need to store more state so we can answer the following questions:</source>
          <target state="translated">이러한 앱에서 Undo 및 Redo를 구현하려면 다음과 같은 질문에 대답 할 수 있도록 더 많은 상태를 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e391178bee157d67e539832bad15008f2621985" translate="yes" xml:space="preserve">
          <source>If you actually are concerned about reducer performance, you can use a utility such as &lt;a href=&quot;https://github.com/omnidan/redux-ignore&quot;&gt;redux-ignore&lt;/a&gt; or &lt;a href=&quot;https://github.com/chrisdavies/reduxr-scoped-reducer&quot;&gt;reduxr-scoped-reducer&lt;/a&gt; to ensure that only certain reducers listen to specific actions. You can also use &lt;a href=&quot;https://github.com/michaelcontento/redux-log-slow-reducers&quot;&gt;redux-log-slow-reducers&lt;/a&gt; to do some performance benchmarking.</source>
          <target state="translated">실제로 감속기 성능이 걱정되는 경우 &lt;a href=&quot;https://github.com/omnidan/redux-ignore&quot;&gt;redux-ignore&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/chrisdavies/reduxr-scoped-reducer&quot;&gt;reduxr-scoped-reducer&lt;/a&gt; 와 같은 유틸리티를 사용하여 특정 감속기 만 특정 작업을 수신 할 수 있습니다. &lt;a href=&quot;https://github.com/michaelcontento/redux-log-slow-reducers&quot;&gt;redux-log-slow-reducers&lt;/a&gt; 를 사용하여 성능 벤치마킹을 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="199562b5deb45f1013629dc76cd0a79e09f79a5f" translate="yes" xml:space="preserve">
          <source>If you are okay with things like persistence and time-travel debugging potentially not working as intended, then you are totally welcome to put non-serializable items into your Redux store. Ultimately, it's &lt;em&gt;your&lt;/em&gt; application, and how you implement it is up to you. As with many other things about Redux, just be sure you understand what tradeoffs are involved.</source>
          <target state="translated">지속성 및 시간 이동 디버깅과 같은 작업이 의도 한대로 작동하지 않을 수 있으면 직렬화 할 수없는 항목을 Redux 저장소에 넣는 것이 좋습니다. 궁극적으로, 그것은 &lt;em&gt;당신의&lt;/em&gt; 응용 프로그램이며 , 그것을 구현하는 방법은 당신에게 달려 있습니다. Redux에 대한 다른 많은 것들과 마찬가지로, 어떤 트레이드 오프가 포함되는지 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="932e447c8721986d2617272ec0cb57f8fa838b1b" translate="yes" xml:space="preserve">
          <source>If you are serving your &lt;code&gt;index.html&lt;/code&gt; from Express:</source>
          <target state="translated">Express에서 &lt;code&gt;index.html&lt;/code&gt; 을 제공하는 경우 :</target>
        </trans-unit>
        <trans-unit id="f7e044138df780189a8da20f4e5abaa151739142" translate="yes" xml:space="preserve">
          <source>If you are serving your &lt;code&gt;index.html&lt;/code&gt; from WebpackDevServer: You can add to your webpack.config.dev.js:</source>
          <target state="translated">WebpackDevServer에서 &lt;code&gt;index.html&lt;/code&gt; 을 제공하는 경우 : webpack.config.dev.js에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c971a979a1e736d56294d1498dc9977ed0a0326" translate="yes" xml:space="preserve">
          <source>If you are using &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;, you can call selectors as regular functions inside &lt;code&gt;mapStateToProps()&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux를&lt;/a&gt; 사용하는 경우 &lt;code&gt;mapStateToProps()&lt;/code&gt; 내에서 선택기를 일반 함수로 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b429d41b92c2a713e5a488236e816823364d7151" translate="yes" xml:space="preserve">
          <source>If you are using Create React App, you won't need to configure a fallback URL, it is automatically done.</source>
          <target state="translated">React 앱 생성을 사용하는 경우 대체 URL을 구성 할 필요가 없으며 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a2bbb0e9ddb72ba973272562f236d089b4f6c651" translate="yes" xml:space="preserve">
          <source>If you are using ES6 in your application source, but write your tests in ES5, you should know that Babel handles the interchangeable use of ES6 &lt;code&gt;import&lt;/code&gt; and CommonJS &lt;code&gt;require&lt;/code&gt; through its &lt;a href=&quot;http://babeljs.io/docs/usage/modules/#interop&quot;&gt;interop&lt;/a&gt; capability to run two module formats side-by-side, but the behavior is &lt;a href=&quot;https://github.com/babel/babel/issues/2047&quot;&gt;slightly different&lt;/a&gt;. If you add a second export beside your default export, you can no longer import the default using &lt;code&gt;require('./App')&lt;/code&gt;. Instead you have to use &lt;code&gt;require('./App').default&lt;/code&gt;.</source>
          <target state="translated">애플리케이션 소스에서 ES6을 사용하고 있지만 ES5에서 테스트를 작성하는 경우 Babel은 ES6 &lt;code&gt;import&lt;/code&gt; 의 상호 교환 가능한 사용을 처리 하고 CommonJS &lt;code&gt;require&lt;/code&gt; 두 가지 모듈 형식을 나란히 실행하기 위해 &lt;a href=&quot;http://babeljs.io/docs/usage/modules/#interop&quot;&gt;interop&lt;/a&gt; 기능을 통해 요구 하지만 동작은 입니다 &lt;a href=&quot;https://github.com/babel/babel/issues/2047&quot;&gt;약간 다릅니다&lt;/a&gt; . 기본 내보내기 옆에 두 번째 내보내기를 추가하면 &lt;code&gt;require('./App')&lt;/code&gt; 을 사용하여 더 이상 기본값을 가져올 수 없습니다 . 대신 &lt;code&gt;require('./App').default&lt;/code&gt; 를 사용해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="036337c885ec3cef3b7191a050a9577f4c076991" translate="yes" xml:space="preserve">
          <source>If you attempt to call &lt;code&gt;dispatch&lt;/code&gt; from inside the &lt;a href=&quot;../glossary#reducer&quot;&gt;reducer&lt;/a&gt;, it will throw with an error saying &amp;ldquo;Reducers may not dispatch actions.&amp;rdquo; This is similar to &amp;ldquo;Cannot dispatch in a middle of dispatch&amp;rdquo; error in Flux, but doesn't cause the problems associated with it. In Flux, a dispatch is forbidden while Stores are handling the action and emitting updates. This is unfortunate because it makes it impossible to dispatch actions from component lifecycle hooks or other benign places.</source>
          <target state="translated">&lt;a href=&quot;../glossary#reducer&quot;&gt;리듀서&lt;/a&gt; 내부에서 &lt;code&gt;dispatch&lt;/code&gt; 를 호출하려고하면 &quot;Reducers가 조치를 디스패치하지 못할 수 있습니다&quot;라는 오류와 함께 오류가 발생합니다. 이는 Flux의 &quot;중간 디스패치 중 디스패치 할 수 없음&quot;오류와 유사하지만 이와 관련된 문제는 발생하지 않습니다. Flux에서는 상점이 조치를 처리하고 업데이트를 내보내는 동안 디스패치가 금지됩니다. 구성 요소 수명주기 후크 또는 다른 양성 위치에서 작업을 디스패치 할 수 없기 때문에 유감입니다.</target>
        </trans-unit>
        <trans-unit id="a8a26433b9beefd0c99622c27b6f8d2d577a33f8" translate="yes" xml:space="preserve">
          <source>If you define an action creator, calling it will &lt;em&gt;not&lt;/em&gt; automatically dispatch the action. For example, this code will do nothing:</source>
          <target state="translated">액션 생성자를 정의하면 호출자 가 액션을 자동으로 전달 &lt;em&gt;하지 않습니다&lt;/em&gt; . 예를 들어이 코드는 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30875373163ba2a0b61d1b93ce3b8577d3f0b61f" translate="yes" xml:space="preserve">
          <source>If you do not provide your own &lt;code&gt;mapDispatchToProps&lt;/code&gt; function when calling &lt;code&gt;connect()&lt;/code&gt;, React Redux will provide a default version, which simply returns the &lt;code&gt;dispatch&lt;/code&gt; function as a prop. That means that if you &lt;em&gt;do&lt;/em&gt; provide your own function, &lt;code&gt;dispatch&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; automatically provided. If you still want it available as a prop, you need to explicitly return it yourself in your &lt;code&gt;mapDispatchToProps&lt;/code&gt; implementation.</source>
          <target state="translated">&lt;code&gt;connect()&lt;/code&gt; 호출 할 때 자체 &lt;code&gt;mapDispatchToProps&lt;/code&gt; 함수를 제공하지 않으면 React Redux는 기본 버전을 제공하며, 이는 단순히 &lt;code&gt;dispatch&lt;/code&gt; 함수를 prop로 반환합니다 . 당신이 경우에 것을 의미 &lt;em&gt;할&lt;/em&gt; 자신의 기능을 제공, &lt;code&gt;dispatch&lt;/code&gt; 되어 &lt;em&gt;있지&lt;/em&gt; 자동으로 제공. 여전히 소품으로 사용할 수있게하려면 &lt;code&gt;mapDispatchToProps&lt;/code&gt; 구현 에서 직접 명시 적으로 반환해야합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9737b1fd992921039384e8e5be9f5b18af16860f" translate="yes" xml:space="preserve">
          <source>If you don't use a module bundler, it's also fine. The &lt;code&gt;redux&lt;/code&gt; npm package includes precompiled production and development &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; builds in the &lt;a href=&quot;https://unpkg.com/redux/dist/&quot;&gt;&lt;code&gt;dist&lt;/code&gt; folder&lt;/a&gt;. They can be used directly without a bundler and are thus compatible with many popular JavaScript module loaders and environments. For example, you can drop a UMD build as a &lt;a href=&quot;https://unpkg.com/redux/dist/redux.js&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag&lt;/a&gt; on the page, or &lt;a href=&quot;https://github.com/reactjs/redux/pull/1181#issuecomment-167361975&quot;&gt;tell Bower to install it&lt;/a&gt;. The UMD builds make Redux available as a &lt;code&gt;window.Redux&lt;/code&gt; global variable.</source>
          <target state="translated">모듈 번 들러를 사용하지 않으면 괜찮습니다. &lt;code&gt;redux&lt;/code&gt; NPM 패키지는 미리 컴파일 된 생산을 포함하고 개발 &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD는&lt;/a&gt; 빌드 &lt;a href=&quot;https://unpkg.com/redux/dist/&quot;&gt; &lt;code&gt;dist&lt;/code&gt; 폴더&lt;/a&gt; . 번 들러없이 직접 사용할 수 있으므로 널리 사용되는 많은 JavaScript 모듈 로더 및 환경과 호환됩니다. 예를 들어, UMD 빌드를 페이지에서 &lt;a href=&quot;https://unpkg.com/redux/dist/redux.js&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그&lt;/a&gt; 로 삭제 하거나 &lt;a href=&quot;https://github.com/reactjs/redux/pull/1181#issuecomment-167361975&quot;&gt;Bower에게 설치하도록 지시 할 수 있습니다&lt;/a&gt; . UMD는로 돌아 오는 사용할 수 있도록 빌드 &lt;code&gt;window.Redux&lt;/code&gt; 전역 변수.</target>
        </trans-unit>
        <trans-unit id="4cd567ddaa1825598645d89fa68d6db13748ff49" translate="yes" xml:space="preserve">
          <source>If you don't use npm, you may grab the latest UMD build from unpkg (either a &lt;a href=&quot;https://unpkg.com/react-redux@latest/dist/react-redux.js&quot;&gt;development&lt;/a&gt; or a &lt;a href=&quot;https://unpkg.com/react-redux@latest/dist/react-redux.min.js&quot;&gt;production&lt;/a&gt; build). The UMD build exports a global called &lt;code&gt;window.ReactRedux&lt;/code&gt; if you add it to your page via a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag.</source>
          <target state="translated">npm을 사용하지 않으면 unpkg ( &lt;a href=&quot;https://unpkg.com/react-redux@latest/dist/react-redux.js&quot;&gt;개발&lt;/a&gt; 또는 &lt;a href=&quot;https://unpkg.com/react-redux@latest/dist/react-redux.min.js&quot;&gt;프로덕션&lt;/a&gt; 빌드) 에서 최신 UMD 빌드를 가져올 수 있습니다. UMD 빌드 는 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 를 통해 페이지에 추가 할 경우 전역이라는 &lt;code&gt;window.ReactRedux&lt;/code&gt; 를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="8cc59110c4fe5748abe56530a6ab2f4825ec53fe" translate="yes" xml:space="preserve">
          <source>If you enjoyed my course, consider supporting Egghead by &lt;a href=&quot;https://egghead.io/pricing&quot;&gt;buying a subscription&lt;/a&gt;. Subscribers have access to the source code for the example in every one of my videos, as well as to tons of advanced lessons on other topics, including JavaScript in depth, React, Angular, and more. Many &lt;a href=&quot;https://egghead.io/instructors&quot;&gt;Egghead instructors&lt;/a&gt; are also open source library authors, so buying a subscription is a nice way to thank them for the work that they've done.</source>
          <target state="translated">내 과정을 즐겼다면 &lt;a href=&quot;https://egghead.io/pricing&quot;&gt;구독&lt;/a&gt; 을 구매하여 Egghead 지원을 고려하십시오 . 구독자는 내 모든 동영상에서 예제의 소스 코드에 액세스 할 수있을뿐만 아니라 깊이있는 JavaScript, React, Angular 등의 다른 주제에 대한 수많은 고급 수업에 액세스 할 수 있습니다. 많은 &lt;a href=&quot;https://egghead.io/instructors&quot;&gt;Egghead 강사&lt;/a&gt; 들도 오픈 소스 라이브러리 작성자이므로 구독을 구입하면 그들이 한 일에 대해 감사하는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="75a385f2b719ab2caac4808cd62fba207c8acd6d" translate="yes" xml:space="preserve">
          <source>If you figure it out, &lt;a href=&quot;https://github.com/reactjs/redux/edit/master/docs/Troubleshooting.md&quot;&gt;edit this document&lt;/a&gt; as a courtesy to the next person having the same problem.</source>
          <target state="translated">이해하면 같은 문제가있는 다음 사람을 &lt;a href=&quot;https://github.com/reactjs/redux/edit/master/docs/Troubleshooting.md&quot;&gt;위해이 문서&lt;/a&gt; 를 편집하십시오 .</target>
        </trans-unit>
        <trans-unit id="35c54f24f34f6294fae047991edc9eee543297c8" translate="yes" xml:space="preserve">
          <source>If you have nested entities, or if you let users edit received entities, you should keep them separately in the state as if it was a database. In pagination information, you would only refer to them by their IDs. This lets you always keep them up to date. The &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; shows this approach, together with &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt; to normalize the nested API responses. With this approach, your state might look like this:</source>
          <target state="translated">중첩 된 엔터티가 있거나 사용자가 수신 된 엔터티를 편집하도록 허용 한 경우 데이터베이스 인 것처럼 상태를 별도로 유지해야합니다. 페이지 매김 정보에서는 ID로만 참조합니다. 이를 통해 항상 최신 상태로 유지할 수 있습니다. &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;실제 예제&lt;/a&gt; 와 함께,이 방법을 보여줍니다 &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr&lt;/a&gt; 중첩 된 API 응답을 정상화 할 수 있습니다. 이 접근 방식을 사용하면 주가 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f8b6dfa0ebcbb78dc0a91f22c821a3a280371e2" translate="yes" xml:space="preserve">
          <source>If you make a typo when importing an action constant, you will get &lt;code&gt;undefined&lt;/code&gt;. Redux will immediately throw when dispatching such an action, and you'll find the mistake sooner.</source>
          <target state="translated">액션 상수를 가져올 때 오타를 만들면 &lt;code&gt;undefined&lt;/code&gt; 가 나타납니다 . 그러한 행동을 파견 할 때 Redux는 즉시 던지고 실수를 더 빨리 발견하게됩니다.</target>
        </trans-unit>
        <trans-unit id="73befc0dc9f970460cd3aed6b1aca8d76525c521" translate="yes" xml:space="preserve">
          <source>If you use ES5, instead of &lt;code&gt;import * as&lt;/code&gt; syntax you can just pass &lt;code&gt;require('./TodoActionCreators')&lt;/code&gt; to &lt;code&gt;bindActionCreators&lt;/code&gt; as the first argument. The only thing it cares about is that the values of the &lt;code&gt;actionCreators&lt;/code&gt; arguments are functions. The module system doesn't matter.</source>
          <target state="translated">당신이 ES5를 사용하는 경우, 대신 &lt;code&gt;import * as&lt;/code&gt; 구문을 그냥 통과 할 수있다 &lt;code&gt;require('./TodoActionCreators')&lt;/code&gt; 에 &lt;code&gt;bindActionCreators&lt;/code&gt; 첫 번째 인수로합니다. 그것이 관심을 갖는 유일한 것은 &lt;code&gt;actionCreators&lt;/code&gt; 인수 의 값 이 함수라는 것입니다. 모듈 시스템은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4df0e81af972f49797fdb77dbfa3675c8af338b1" translate="yes" xml:space="preserve">
          <source>If you use React, note that you can improve performance of multiple synchronous dispatches by wrapping them in &lt;code&gt;ReactDOM.unstable_batchedUpdates()&lt;/code&gt;, but this API is experimental and may be removed in any React release so don't rely on it too heavily. Take a look at &lt;a href=&quot;https://github.com/tshelburne/redux-batched-actions&quot;&gt;redux-batched-actions&lt;/a&gt; (a higher-order reducer that lets you dispatch several actions as if it was one and &amp;ldquo;unpack&amp;rdquo; them in the reducer), &lt;a href=&quot;https://github.com/tappleby/redux-batched-subscribe&quot;&gt;redux-batched-subscribe&lt;/a&gt; (a store enhancer that lets you debounce subscriber calls for multiple dispatches), or &lt;a href=&quot;https://github.com/manaflair/redux-batch&quot;&gt;redux-batch&lt;/a&gt; (a store enhancer that handles dispatching an array of actions with a single subscriber notification).</source>
          <target state="translated">React를 사용하는 경우 &lt;code&gt;ReactDOM.unstable_batchedUpdates()&lt;/code&gt; 로 래핑하여 여러 동기 디스패치의 성능을 향상시킬 수 있지만이 API는 실험적이며 모든 React 릴리스에서 제거 될 수 있으므로 너무 의존하지 마십시오. 한 번 봐 가지고 &lt;a href=&quot;https://github.com/tshelburne/redux-batched-actions&quot;&gt;REDUX - 일괄-행동&lt;/a&gt; , (그 하나는 감속기 그들 &quot;압축 풀기&quot;인 것처럼 여러 작업을 파견 할 수있는 고차원 감속기) &lt;a href=&quot;https://github.com/tappleby/redux-batched-subscribe&quot;&gt;REDUX - 일괄 처리가 구독&lt;/a&gt; (가입자 디 바운스를 할 수있는 저장 증강을 여러 디스패치에 대한 호출) 또는 &lt;a href=&quot;https://github.com/manaflair/redux-batch&quot;&gt;redux-batch&lt;/a&gt; (단일 가입자 알림으로 일련의 작업 디스패치를 ​​처리하는 저장소 향상 기).</target>
        </trans-unit>
        <trans-unit id="9271dc344ed7ad99882268b8d2eb8bf8888f3412" translate="yes" xml:space="preserve">
          <source>If you use a library like &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt;, you might be using &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;higher-order components&lt;/a&gt; like &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt;. This lets you inject Redux state into a regular React component.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; 와 같은 라이브러리를 사용하는 경우 &lt;a href=&quot;https://github.com/reactjs/react-redux/blob/master/docs/api.md#connectmapstatetoprops-mapdispatchtoprops-mergeprops-options&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; 와 같은 &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;상위 컴포넌트를&lt;/a&gt; 사용 중일 수 있습니다 . 이를 통해 Redux 상태를 일반 React 컴포넌트에 주입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cd635904f7059bfcd20e75164dcce6a3c6db39b" translate="yes" xml:space="preserve">
          <source>If you use other store enhancers in addition to &lt;code&gt;applyMiddleware&lt;/code&gt;, make sure to put &lt;code&gt;applyMiddleware&lt;/code&gt; before them in the composition chain because the middleware is potentially asynchronous. For example, it should go before &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt; because otherwise the DevTools won't see the raw actions emitted by the Promise middleware and such.</source>
          <target state="translated">&lt;code&gt;applyMiddleware&lt;/code&gt; 외에 다른 상점 향상 기를 사용하는 경우 미들웨어는 잠재적으로 비동기 &lt;code&gt;applyMiddleware&lt;/code&gt; 컴포지션 체인에서 applyMiddleware 를 배치 해야합니다. 예를 들어, DevTools는 Promise 미들웨어 등에서 생성 된 원시 작업을 볼 수 없으므로 &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt; 보다 먼저 진행되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5b994687ed5da06c8ff7d250360e547dbe6399b8" translate="yes" xml:space="preserve">
          <source>If you use something like &lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt;, you might also want to express your data fetching dependencies as static &lt;code&gt;fetchData()&lt;/code&gt; methods on your route handler components. They may return &lt;a href=&quot;../advanced/asyncactions&quot;&gt;async actions&lt;/a&gt;, so that your &lt;code&gt;handleRender&lt;/code&gt; function can match the route to the route handler component classes, dispatch &lt;code&gt;fetchData()&lt;/code&gt; result for each of them, and render only after the Promises have resolved. This way the specific API calls required for different routes are colocated with the route handler component definitions. You can also use the same technique on the client side to prevent the router from switching the page until its data has been loaded.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/reactjs/react-router&quot;&gt;React Router&lt;/a&gt; 와 같은 것을 사용하는 경우 데이터 가져 오기 종속성을 라우트 핸들러 구성 요소에서 정적 &lt;code&gt;fetchData()&lt;/code&gt; 메소드 로 표현할 수도 있습니다 . 그들은 반환 할 수 있습니다 &lt;a href=&quot;../advanced/asyncactions&quot;&gt;작업을 비동기&lt;/a&gt; 당신 그래서, &lt;code&gt;handleRender&lt;/code&gt; 의 파견, 함수는 경로 처리기 구성 요소 클래스 경로를 일치시킬 수 있습니다 &lt;code&gt;fetchData()&lt;/code&gt; 그들 각각에 대한 결과를, 그리고 약속이 해결 한 후에 만 렌더링합니다. 이렇게하면 다른 경로에 필요한 특정 API 호출이 경로 핸들러 구성 요소 정의와 함께 배치됩니다. 또한 클라이언트 측에서 동일한 기술을 사용하여 데이터가로드 될 때까지 라우터가 페이지를 전환하지 못하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f28ac508cdd88eefae0fc560e0d0772276239bef" translate="yes" xml:space="preserve">
          <source>If you want to conditionally apply a middleware, make sure to only import it when it's needed:</source>
          <target state="translated">미들웨어를 조건부로 적용하려면 필요할 때만 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="3e7d35f34c8cafb2605b96694ac400ffa75f61c6" translate="yes" xml:space="preserve">
          <source>If you're already familiar with the basic concepts and have previously completed this tutorial, don't forget to check out &lt;a href=&quot;../advanced/asyncflow&quot;&gt;async flow&lt;/a&gt; in the &lt;a href=&quot;../advanced/index&quot;&gt;advanced tutorial&lt;/a&gt; to learn how middleware transforms &lt;a href=&quot;../advanced/asyncactions&quot;&gt;async actions&lt;/a&gt; before they reach the reducer.</source>
          <target state="translated">이미 기본 개념에 익숙하고이 학습서를 완료 한 경우, &lt;a href=&quot;../advanced/index&quot;&gt;고급 학습서&lt;/a&gt; 에서 &lt;a href=&quot;../advanced/asyncflow&quot;&gt;비동기 플로우&lt;/a&gt; 를 확인하여 미들웨어가 &lt;a href=&quot;../advanced/asyncactions&quot;&gt;비동기 조치에&lt;/a&gt; 도달하기 전에 비동기 조치 를 변환하는 방법을 학습하는 것을 잊지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="816a6eef450003d62c904a3bd887b32f4e650f73" translate="yes" xml:space="preserve">
          <source>If you're coming from Flux, there is a single important difference you need to understand. Redux doesn't have a Dispatcher or support many stores. &lt;strong&gt;Instead, there is just a single store with a single root &lt;a href=&quot;../glossary#reducer&quot;&gt;reducing function&lt;/a&gt;.&lt;/strong&gt; As your app grows, instead of adding stores, you split the root reducer into smaller reducers independently operating on the different parts of the state tree. You can use a helper like &lt;a href=&quot;combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt; to combine them. This is similar to how there is just one root component in a React app, but it is composed out of many small components.</source>
          <target state="translated">Flux에서 오면 이해해야 할 중요한 차이점이 하나 있습니다. Redux에는 디스패처가 없거나 많은 상점을 지원합니다. &lt;strong&gt;대신, 단일 루트 &lt;a href=&quot;../glossary#reducer&quot;&gt;감소 기능을&lt;/a&gt; 가진 단일 저장소가 있습니다 .&lt;/strong&gt; 앱이 커지면 스토어를 추가하는 대신 루트 리듀서를 상태 트리의 다른 부분에서 독립적으로 작동하는 더 작은 리듀서로 분할합니다. &lt;a href=&quot;combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt; 와 같은 도우미를 사용 하여 결합 할 수 있습니다. 이것은 React 앱에 루트 구성 요소가 하나만있는 방법과 비슷하지만 많은 작은 구성 요소로 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="428736da48a00e318f6b5e97ec36e76a4fb9754a" translate="yes" xml:space="preserve">
          <source>If you're coming from Flux, there is a single important difference you need to understand. Redux doesn't have a Dispatcher or support many stores. Instead, there is just a single store with a single root reducing function. As your app grows, instead of adding stores, you split the root reducer into smaller reducers independently operating on the different parts of the state tree. This is exactly like how there is just one root component in a React app, but it is composed out of many small components.</source>
          <target state="translated">Flux에서 오면 이해해야 할 중요한 차이점이 하나 있습니다. Redux에는 디스패처가 없거나 많은 상점을 지원합니다. 대신, 단일 루트 감소 기능을 가진 단일 저장소가 있습니다. 앱이 커지면 스토어를 추가하는 대신 루트 리듀서를 상태 트리의 다른 부분에서 독립적으로 작동하는 더 작은 리듀서로 분할합니다. 이것은 React 앱에 하나의 루트 구성 요소가있는 것과 정확히 같지만 많은 작은 구성 요소로 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0cc9c7c3b559caffbbd11ca7ac8b9023f058297" translate="yes" xml:space="preserve">
          <source>If you're in doubt, check out the Redux source code (there isn't much going on there), as well as its ecosystem (for example, &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;the developer tools&lt;/a&gt;). If you don't care too much about it and want to go with the reactive data flow all the way, you might want to explore something like &lt;a href=&quot;http://cycle.js.org&quot;&gt;Cycle&lt;/a&gt; instead, or even combine it with Redux. Let us know how it goes!</source>
          <target state="translated">확실하지 않은 경우 Redux 소스 코드 (많은 것은 없지만)와 생태계 (예 : &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;개발자 도구&lt;/a&gt; )를 확인하십시오. 너무 신경 쓰지 않고 반응 형 데이터 흐름을 원한다면 &lt;a href=&quot;http://cycle.js.org&quot;&gt;Cycle&lt;/a&gt; 과 같은 것을 탐색 하거나 Redux와 결합 할 수도 있습니다. 어떻게 진행되는지 알려주세요!</target>
        </trans-unit>
        <trans-unit id="7a3ca8f9048bbc67b3c079811024df3868485a73" translate="yes" xml:space="preserve">
          <source>If you're just learning React, you should probably focus on thinking in React first, then look at Redux once you better understand React and how Redux might fit into your application.</source>
          <target state="translated">React를 배우는 것이라면 React에서 먼저 생각하고 React를 이해하고 Redux가 응용 프로그램에 어떻게 적용되는지 잘 이해하고 나면 Redux를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="56294c132212d734163e82c754555af03986a8f4" translate="yes" xml:space="preserve">
          <source>If you're new to the NPM ecosystem and have troubles getting a project up and running, or aren't sure where to paste the gist above, check out &lt;a href=&quot;https://github.com/jackielii/simplest-redux-example&quot;&gt;simplest-redux-example&lt;/a&gt; that uses Redux together with React and Browserify.</source>
          <target state="translated">NPM 생태계를 처음 사용하고 프로젝트를 시작하고 실행하는 데 문제가 있거나 위의 요점을 붙여 넣을 위치가 확실하지 않은 경우 Redux를 React 및 Browserify와 함께 사용 하는 &lt;a href=&quot;https://github.com/jackielii/simplest-redux-example&quot;&gt;가장 간단한 redux 예제&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d0d749eb693db3084a30e822fa61e81b13144b8" translate="yes" xml:space="preserve">
          <source>If you're not, you can &lt;a href=&quot;https://unpkg.com/redux/&quot;&gt;access these files on unpkg&lt;/a&gt;, download them, or point your package manager to them.</source>
          <target state="translated">그렇지 않은 경우 &lt;a href=&quot;https://unpkg.com/redux/&quot;&gt;unpkg&lt;/a&gt; 에서 이러한 파일에 액세스 하거나 다운로드하거나 패키지 관리자를 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89793009075a44d386caea025880b6492221229c" translate="yes" xml:space="preserve">
          <source>If you're somewhere deep in the component hierarchy, it is cumbersome to pass the store down manually. This is why &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; lets you use a &lt;code&gt;connect&lt;/code&gt;&lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;higher-order component&lt;/a&gt; that will, apart from subscribing you to a Redux store, inject &lt;code&gt;dispatch&lt;/code&gt; into your component's props.</source>
          <target state="translated">구성 요소 계층의 어느 곳에라도 저장소를 수동으로 전달하는 것은 번거로운 작업입니다. 따라서 &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux를&lt;/a&gt; 사용하면 Redux 스토어에 가입하지 않고 구성 요소 소품에 &lt;code&gt;dispatch&lt;/code&gt; 를 주입하는 &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;상위 구성 요소 &lt;/a&gt; &lt;code&gt;connect&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9847b990c2956da3cc4e51d7455ae0fd5c2d3799" translate="yes" xml:space="preserve">
          <source>If you're still not convinced, read &lt;a href=&quot;../introduction/motivation&quot;&gt;Motivation&lt;/a&gt; and &lt;a href=&quot;https://medium.com/@dan_abramov/the-case-for-flux-379b7d1982c6&quot;&gt;The Case for Flux&lt;/a&gt; for a compelling argument in favor of unidirectional data flow. Although &lt;a href=&quot;../introduction/priorart&quot;&gt;Redux is not exactly Flux&lt;/a&gt;, it shares the same key benefits.</source>
          <target state="translated">여전히 확신이 없다면, 단방향 데이터 흐름을 선호하는 강력한 논쟁에 대해서는 &lt;a href=&quot;../introduction/motivation&quot;&gt;동기 부여&lt;/a&gt; 및 &lt;a href=&quot;https://medium.com/@dan_abramov/the-case-for-flux-379b7d1982c6&quot;&gt;플럭스 사례를&lt;/a&gt; 읽어보십시오 . 하지만 &lt;a href=&quot;../introduction/priorart&quot;&gt;돌아 오는 정확히 플럭스 아닌&lt;/a&gt; , 같은 키의 장점을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="5c63a9398fd378c51f8bf9e677e8aa928203398f" translate="yes" xml:space="preserve">
          <source>If you're using &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; or similar bindings, you likely won't have direct access to the store instance in your components. For the next few paragraphs, just assume you pass the store down explicitly.</source>
          <target state="translated">당신이 사용하는 경우 &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;반응-REDUX&lt;/a&gt; 또는 유사한 바인딩을, 당신은 가능성이 컴포넌트에 저장 인스턴스에 직접 액세스 할 수 없습니다. 다음 몇 단락의 경우 상점을 명시 적으로 전달한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="01cdd0731454ffd1d20cd96f11a3d32664207b62" translate="yes" xml:space="preserve">
          <source>If your Backbone codebase is too big for a quick rewrite or you don't want to manage interactions between store and models, use &lt;a href=&quot;https://github.com/naugtur/backbone-redux-migrator&quot;&gt;backbone-redux-migrator&lt;/a&gt; to help your two codebases coexist while keeping healthy separation. Once your rewrite finishes, Backbone code can be discarded and your Redux application can work on its own once you configure router.</source>
          <target state="translated">백본 코드베이스가 너무 빨리 재 작성하기에 너무 크거나 상점과 모델 간의 상호 작용을 관리하지 않으려면 &lt;a href=&quot;https://github.com/naugtur/backbone-redux-migrator&quot;&gt;백본 -redux-migrator&lt;/a&gt; 를 사용하여 두 코드베이스가 공존하면서 건강한 분리를 유지하십시오. 다시 쓰기가 완료되면 백본 코드를 버리고 라우터를 구성한 후에 Redux 애플리케이션을 자체적으로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe98ef98166939af239eed6b2d81cd88bea35531" translate="yes" xml:space="preserve">
          <source>If your head boiled from reading the above section, imagine what it was like to write it. This section is meant to be a relaxation for you and me, and will help get your gears turning.</source>
          <target state="translated">위의 섹션을 읽은 후 머리가 끓었다면 글을 쓰는 것이 어땠는지 상상해보십시오. 이 섹션은 여러분과 저를위한 휴식이며, 기어를 돌리는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="5a439ce92e30ef4f0c974a7c73870d7c4912681d" translate="yes" xml:space="preserve">
          <source>If your state is a plain object, make sure you never mutate it! For example, instead of returning something like &lt;code&gt;Object.assign(state, newData)&lt;/code&gt; from your reducers, return &lt;code&gt;Object.assign({}, state, newData)&lt;/code&gt;. This way you don't override the previous &lt;code&gt;state&lt;/code&gt;. You can also write &lt;code&gt;return { ...state, ...newData }&lt;/code&gt; if you enable the &lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt;.</source>
          <target state="translated">상태가 일반 객체 인 경우 절대로 변경하지 마십시오. 예를 들어 감속기에서 &lt;code&gt;Object.assign(state, newData)&lt;/code&gt; 와 같은 것을 반환하는 대신 &lt;code&gt;Object.assign({}, state, newData)&lt;/code&gt; 반환하십시오 . 이렇게하면 이전 &lt;code&gt;state&lt;/code&gt; 재정의하지 않습니다 . &lt;a href=&quot;../recipes/usingobjectspreadoperator&quot;&gt;object spread operator proposal&lt;/a&gt; 을 활성화하면 &lt;code&gt;return { ...state, ...newData }&lt;/code&gt; 쓸 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6373833358e0059931cc766a20497e267d0055c4" translate="yes" xml:space="preserve">
          <source>Imagine your app&amp;rsquo;s state is described as a plain object. For example, the state of a todo app might look like this:</source>
          <target state="translated">앱의 상태가 평범한 객체라고 설명한다고 상상해보십시오. 예를 들어, 할 일 앱의 상태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d512cb13653145d5f418624490cb11a59c20835" translate="yes" xml:space="preserve">
          <source>Immutability can bring increased performance to your app, and leads to simpler programming and debugging, as data that never changes is easier to reason about than data that is free to be changed arbitrarily throughout your app.</source>
          <target state="translated">변경 불가능한 데이터는 앱 전체에서 임의로 변경할 수있는 데이터보다 추론하기 쉬운 데이터이므로 변경 불가능한 경우 앱 성능이 향상되고 프로그래밍 및 디버깅이 간단 해집니다.</target>
        </trans-unit>
        <trans-unit id="7748d3ba70c7e8503005d5183b42db995cf3479a" translate="yes" xml:space="preserve">
          <source>Immutability is what lets &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux&lt;/a&gt; efficiently subscribe to fine-grained updates of your state. It also enables great developer experience features such as time travel with &lt;a href=&quot;http://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools&lt;/a&gt;.</source>
          <target state="translated">불변성은 &lt;a href=&quot;https://github.com/gaearon/react-redux&quot;&gt;react-redux가&lt;/a&gt; 상태의 세분화 된 업데이트를 효율적으로 구독 할 수있게 합니다. 또한 &lt;a href=&quot;http://github.com/gaearon/redux-devtools&quot;&gt;redux-devtools를&lt;/a&gt; 통한 시간 여행과 같은 훌륭한 개발자 경험 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="6e5a32a1bd41d5b21404f176ae361427aff05142" translate="yes" xml:space="preserve">
          <source>Immutable</source>
          <target state="translated">Immutable</target>
        </trans-unit>
        <trans-unit id="674da9972545b8a3d30b18b2b631a253089574ce" translate="yes" xml:space="preserve">
          <source>Immutable Data Management</source>
          <target state="translated">불변 데이터 관리</target>
        </trans-unit>
        <trans-unit id="f194c27186d4d976f210a867f1b7493fc5734e87" translate="yes" xml:space="preserve">
          <source>Immutable Data Structures and JavaScript</source>
          <target state="translated">불변 데이터 구조 및 JavaScript</target>
        </trans-unit>
        <trans-unit id="3f337e1757211d31f0134ce96582c18a500ad82d" translate="yes" xml:space="preserve">
          <source>Immutable Data from Scratch</source>
          <target state="translated">스크래치에서 변경 불가능한 데이터</target>
        </trans-unit>
        <trans-unit id="e69f6aa84f66db9f8ef96ac695cc3f24fae1dc21" translate="yes" xml:space="preserve">
          <source>Immutable Data using ES6 and Beyond</source>
          <target state="translated">ES6 이상을 사용하는 불변 데이터</target>
        </trans-unit>
        <trans-unit id="cda456672d3ee4fa81f3ddcd2803e3ee0a8d4c04" translate="yes" xml:space="preserve">
          <source>Immutable Javascript using ES6 and beyond</source>
          <target state="translated">ES6 이상을 사용하는 불변 Javascript</target>
        </trans-unit>
        <trans-unit id="973175b7f3b4ff6e4efbc6ead54d53aad1a95619" translate="yes" xml:space="preserve">
          <source>Immutable Object Formatter</source>
          <target state="translated">불변의 객체 포매터</target>
        </trans-unit>
        <trans-unit id="d8acc5408d603ab59b3c9faed6a7e6bc40e90b10" translate="yes" xml:space="preserve">
          <source>Immutable Update Patterns</source>
          <target state="translated">불변 업데이트 패턴</target>
        </trans-unit>
        <trans-unit id="7453da6cbc7da4258fe3287ac0a6c8690fe9793c" translate="yes" xml:space="preserve">
          <source>Immutable Update Patterns for ES6</source>
          <target state="translated">ES6의 불변 업데이트 패턴</target>
        </trans-unit>
        <trans-unit id="33ff07243fabffc0f9f1077cf8800e362ccb5eaa" translate="yes" xml:space="preserve">
          <source>Immutable Update Utility Libraries</source>
          <target state="translated">불변 업데이트 유틸리티 라이브러리</target>
        </trans-unit>
        <trans-unit id="5bd90f13857bde1d7e445ee9ceeba04700668e97" translate="yes" xml:space="preserve">
          <source>Immutable and most similar libraries are orthogonal to Redux. Feel free to use them together!</source>
          <target state="translated">변경 불가능하고 가장 유사한 라이브러리는 Redux와 직교합니다. 함께 사용하십시오!</target>
        </trans-unit>
        <trans-unit id="ea78c55982bab7f948fd4ba6bc2bd11c80ae37ff" translate="yes" xml:space="preserve">
          <source>Immutable data management ultimately makes data handling safer.</source>
          <target state="translated">불변 데이터 관리는 궁극적으로 데이터 처리를보다 안전하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="12e9a327a00ad002de1d25ee12aec93959806cd7" translate="yes" xml:space="preserve">
          <source>Immutable-focused libraries such as Immutable.JS have been designed to overcome the issues with immutability inherent within JavaScript, providing all the benefits of immutability with the performance your app requires.</source>
          <target state="translated">Immutable.JS와 같은 불변성 중심 라이브러리는 JavaScript에 내재 된 불변성과 관련된 문제를 극복하고 앱에 필요한 성능으로 불변성의 모든 이점을 제공하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="4e6fbec38c5ba31d45e4cbd8958dc74112ebd4b2" translate="yes" xml:space="preserve">
          <source>Immutable.JS avoids this by &lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;cleverly sharing data structures&lt;/a&gt; under the surface, minimizing the need to copy data. It also enables complex chains of operations to be carried out without creating unnecessary (and costly) cloned intermediate data that will quickly be thrown away.</source>
          <target state="translated">Immutable.JS는 표면 아래에서 &lt;a href=&quot;https://medium.com/@dtinth/immutable-js-persistent-data-structures-and-structural-sharing-6d163fbd73d2#.z1g1ofrsi&quot;&gt;데이터 구조&lt;/a&gt; 를 영리하게 공유하여 데이터 를 복사 할 필요성을 최소화함으로써이를 방지합니다. 또한 신속하게 폐기 될 불필요하고 비용이 많이 드는 복제 된 중간 데이터를 만들지 않고도 복잡한 작업 체인을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4bca118ae44915dde169b1e2c52c2a3216d820a" translate="yes" xml:space="preserve">
          <source>Immutable.JS can provide significant reliability and performance improvements to your app, but it must be used correctly. If you choose to use Immutable.JS (and remember, you are not required to, and there are other immutable libraries you can use), follow these opinionated best practices, and you&amp;rsquo;ll be able to get the most out of it, without tripping up on any of the issues it can potentially cause.</source>
          <target state="translated">Immutable.JS는 앱의 안정성과 성능을 크게 향상시킬 수 있지만 올바르게 사용해야합니다. Immutable.JS를 사용하기로 선택한 경우 (필요하지는 않으며 사용할 수있는 다른 불변 라이브러리가 있음) 이러한 의견이있는 모범 사례를 따르면 최대한 활용할 수 있습니다. 잠재적으로 발생할 수있는 모든 문제에 대한 트립</target>
        </trans-unit>
        <trans-unit id="20c874460a6804e3b2c27f9b25a6746d6bfb6f9b" translate="yes" xml:space="preserve">
          <source>Immutable.JS does a lot work behind the scenes to optimize performance. This is the key to its power, as using immutable data structures can involve a lot of expensive copying. In particular, immutably manipulating large, complex data sets, such as a nested Redux state tree, can generate many intermediate copies of objects, which consume memory and slow down performance as the browser&amp;rsquo;s garbage collector fights to clean things up.</source>
          <target state="translated">Immutable.JS는 성능을 최적화하기 위해 많은 작업을 수행합니다. 변경 불가능한 데이터 구조를 사용하면 많은 비용이 드는 복사가 수반 될 수 있으므로 이것이 가장 중요한 기능입니다. 특히, 중첩 된 Redux 상태 트리와 같이 크고 복잡한 데이터 세트를 불변으로 조작하면 많은 중간 객체 사본이 생성 될 수 있으며, 이는 브라우저의 가비지 수집기가 일을 정리하기 위해 싸울 때 메모리를 소비하고 성능을 저하시킵니다.</target>
        </trans-unit>
        <trans-unit id="6cc90700452643c9a9c0e8f4b109806ca1907669" translate="yes" xml:space="preserve">
          <source>Immutable.JS objects, such as &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;List&lt;/code&gt;, etc., can be difficult to debug, as inspecting such an object will reveal an entire nested hierarchy of Immutable.JS-specific properties that you don&amp;rsquo;t care about, while your actual data that you do care about is encapsulated several layers deep.</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;List&lt;/code&gt; 등과 같은 Immutable.JS 객체는 실제 데이터를 사용하는 동안 신경 쓰지 않는 Immutable.JS 관련 속성의 전체 중첩 계층 구조를 나타내므로 디버그하기가 어려울 수 있습니다. 당신이 걱정하는 것은 여러 층의 깊이로 캡슐화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b728994e17e8c21ef4849874d50ee39e9635a6f5" translate="yes" xml:space="preserve">
          <source>Immutable.JS provides a rich set of immutable objects to encapsulate your data (e.g. Maps, Lists, Sets, Records, etc.), and an extensive set of methods to manipulate it, including methods to sort, filter, and group the data, reverse it, flatten it, and create subsets.</source>
          <target state="translated">Immutable.JS는 데이터 (예 :지도, 목록, 세트, ​​레코드 등)를 캡슐화 할 수있는 다양한 불변 객체 세트와 데이터를 정렬, 필터링 및 그룹화하는 방법을 포함하여 데이터를 조작하는 광범위한 메소드를 제공합니다. 그것을 뒤집고 납작하게 만들고 부분 집합을 만듭니다</target>
        </trans-unit>
        <trans-unit id="8d99c53713fdd9ecf08a9eeb1a70e8a2964a5cf1" translate="yes" xml:space="preserve">
          <source>Immutable.JS was designed to provide immutability in a performant manner in an effort to overcome the limitations of immutability with JavaScript. Its principle advantages include:</source>
          <target state="translated">Immutable.JS는 JavaScript로 불변성의 한계를 극복하기 위해 수행 가능한 방식으로 불변성을 제공하도록 설계되었습니다. 주요 장점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b492caa1430f9e67bef5127ef78bb8219dbd86c" translate="yes" xml:space="preserve">
          <source>Immutable.JS works best for collections of data, and the larger the better. It can be slow when your data comprises lots of small, simple JavaScript objects, with each comprising a few keys of primitive values.</source>
          <target state="translated">Immutable.JS는 데이터 수집에 가장 적합하며 클수록 좋습니다. 데이터가 작고 간단한 JavaScript 객체를 많이 포함 할 때 속도가 느릴 수 있으며 각 객체에는 몇 가지 기본 값 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fed6b895cf747a93a21ea8add3ba23effdc034a" translate="yes" xml:space="preserve">
          <source>Immutable.js - Immutable Collections for JavaScript</source>
          <target state="translated">Immutable.js-JavaScript를위한 불변 컬렉션</target>
        </trans-unit>
        <trans-unit id="50598f7dc9386f9779647be8fdfdf65fd92fe212" translate="yes" xml:space="preserve">
          <source>Immutable.js, persistent data structures and structural sharing</source>
          <target state="translated">Immutable.js, 지속적인 데이터 구조 및 구조 공유</target>
        </trans-unit>
        <trans-unit id="fd7e1350aad385c556192ea311d3f9f4440b4840" translate="yes" xml:space="preserve">
          <source>ImmutableJS: worth the price?</source>
          <target state="translated">불변의 JS : 가격 대비 가치가 있는가?</target>
        </trans-unit>
        <trans-unit id="879b24a430b9ab1f4e8c76b4dfa0887fc3c04d07" translate="yes" xml:space="preserve">
          <source>Immutably updating objects and arrays safely</source>
          <target state="translated">객체와 배열을 안전하게 업데이트</target>
        </trans-unit>
        <trans-unit id="f37f816825de6623c275fae3ddf78ea2ec8ca471" translate="yes" xml:space="preserve">
          <source>Immutably updating state generally means making shallow copies, not deep copies. Shallow copies are much faster than deep copies, because fewer objects and fields have to be copied, and it effectively comes down to moving some pointers around.</source>
          <target state="translated">변경 불가능한 상태는 일반적으로 깊은 사본이 아닌 얕은 사본을 만드는 것을 의미합니다. 얕은 복사본은 딥 복사본보다 훨씬 빠릅니다. 적은 수의 개체와 필드를 복사해야하기 때문에 일부 포인터를 움직일 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="0a6446305b39453eb5282988df8de2320a57875d" translate="yes" xml:space="preserve">
          <source>Implementing Components</source>
          <target state="translated">컴포넌트 구현</target>
        </trans-unit>
        <trans-unit id="56aeb896976173293390de95c9507133f3d2e7e4" translate="yes" xml:space="preserve">
          <source>Implementing Container Components</source>
          <target state="translated">컨테이너 구성 요소 구현</target>
        </trans-unit>
        <trans-unit id="43492db8e2cb0ccb4f69d638a38af639d790168e" translate="yes" xml:space="preserve">
          <source>Implementing Other Components</source>
          <target state="translated">다른 구성 요소 구현</target>
        </trans-unit>
        <trans-unit id="a1c1c997da2a03119d1777770189d8c530547e28" translate="yes" xml:space="preserve">
          <source>Implementing Presentational Components</source>
          <target state="translated">프리젠 테이션 컴포넌트 구현</target>
        </trans-unit>
        <trans-unit id="3c7e5554c6cc65b0860b475288581cda33e0f76b" translate="yes" xml:space="preserve">
          <source>Implementing Undo History</source>
          <target state="translated">실행 취소 기록 구현</target>
        </trans-unit>
        <trans-unit id="90ab5ed3bb3e27748d586ad9b9b11e2ab9efaaf8" translate="yes" xml:space="preserve">
          <source>Importing</source>
          <target state="translated">Importing</target>
        </trans-unit>
        <trans-unit id="461dfd2a69948b84d92969ac1b9fc39ee72ff9b8" translate="yes" xml:space="preserve">
          <source>Improving React and Redux Perf with Reselect</source>
          <target state="translated">재 선택으로 반응 및 Redux 성능 개선</target>
        </trans-unit>
        <trans-unit id="1e6ff2f3e12ce6aab10b9bec9cab6d60b64497ea" translate="yes" xml:space="preserve">
          <source>Improving React and Redux Performance with Reselect</source>
          <target state="translated">재 선택으로 반응 및 리 덕트 성능 향상</target>
        </trans-unit>
        <trans-unit id="831e8524a43e2feb49c2742ea27fbb2612cd63b9" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://facebook.github.io/flux&quot;&gt;traditional Flux&lt;/a&gt;, action creators often trigger a dispatch when invoked, like so:</source>
          <target state="translated">에서 &lt;a href=&quot;http://facebook.github.io/flux&quot;&gt;기존의 플럭스&lt;/a&gt; , 호출과 같이 할 때, 액션 제작자는 종종 파견 트리거 :</target>
        </trans-unit>
        <trans-unit id="40dceb766db3717cd4f328d563428fe98260c2e5" translate="yes" xml:space="preserve">
          <source>In Depth</source>
          <target state="translated">깊이에서</target>
        </trans-unit>
        <trans-unit id="75d1fa6c5616fe360b5c666020ecae8fe2e73764" translate="yes" xml:space="preserve">
          <source>In Flux, it is traditionally thought that you would define every action type as a string constant:</source>
          <target state="translated">Flux에서는 전통적으로 모든 액션 유형을 문자열 상수로 정의한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="c614b1de37c0649d85e4de6785709030fe57b0ee" translate="yes" xml:space="preserve">
          <source>In Redux action creators simply return an action:</source>
          <target state="translated">Redux 액션 제작자는 단순히 액션을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="13d908827ee0f85cbdbc48b6e6b0f4b0ba7e1ede" translate="yes" xml:space="preserve">
          <source>In Redux this is &lt;em&gt;not&lt;/em&gt; the case.</source>
          <target state="translated">Redux에서는 &lt;em&gt;그렇지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fb7413db62de4f3ba71879e02b2f0337a6068408" translate="yes" xml:space="preserve">
          <source>In Redux, action creators are functions which return plain objects. When testing action creators we want to test whether the correct action creator was called and also whether the right action was returned.</source>
          <target state="translated">Redux에서 액션 생성자는 일반 객체를 반환하는 함수입니다. 조치 작성자를 테스트 할 때 올바른 조치 작성자가 호출되었는지와 올바른 조치가 리턴되었는지 테스트하려고합니다.</target>
        </trans-unit>
        <trans-unit id="f0927ace523de150037e069de9e99b9a0427c743" translate="yes" xml:space="preserve">
          <source>In Redux, all the application state is stored as a single object. It's a good idea to think of its shape before writing any code. What's the minimal representation of your app's state as an object?</source>
          <target state="translated">Redux에서는 모든 응용 프로그램 상태가 단일 객체로 저장됩니다. 코드를 작성하기 전에 모양을 생각하는 것이 좋습니다. 앱 상태를 객체로 최소로 표현한 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="b8579ec417a0f350980bbd379e3d451d4be5f432" translate="yes" xml:space="preserve">
          <source>In Redux, subscriptions are called after the root reducer has returned the new state, so you &lt;em&gt;may&lt;/em&gt; dispatch in the subscription listeners. You are only disallowed to dispatch inside the reducers because they must have no side effects. If you want to cause a side effect in response to an action, the right place to do this is in the potentially async &lt;a href=&quot;../glossary#action-creator&quot;&gt;action creator&lt;/a&gt;.</source>
          <target state="translated">루트 감속기가 새로운 상태를 반환 한 후 당신이 그렇게 돌아 오는에, 구독,라고 &lt;em&gt;할 수있다&lt;/em&gt; 가입 리스너에 전달합니다. 리듀서는 부작용이 없어야 만 리듀서 내부로 발송할 수 없습니다. 조치에 대한 응답으로 부작용을 일으키려면 적절한 &lt;a href=&quot;../glossary#action-creator&quot;&gt;조치를 취하는&lt;/a&gt; 것이 잠재적 인 비동기 조치 작성기 입니다.</target>
        </trans-unit>
        <trans-unit id="025a5c8609578dcf3fbad95a8468e74d10860635" translate="yes" xml:space="preserve">
          <source>In Redux, the accumulated value is the state object, and the values being accumulated are actions. Reducers calculate a new state given the previous state and an action. They must be &lt;em&gt;pure functions&lt;/em&gt;&amp;mdash;functions that return the exact same output for given inputs. They should also be free of side-effects. This is what enables exciting features like hot reloading and time travel.</source>
          <target state="translated">Redux에서 누적 값은 상태 객체이고 누적되는 값은 동작입니다. 감속기는 이전 상태와 동작이 주어지면 새 상태를 계산합니다. 주어진 함수에 대해 정확히 동일한 출력을 반환하는 함수 인 &lt;em&gt;순수한 함수&lt;/em&gt; 여야합니다 . 또한 부작용이 없어야합니다. 이것이 바로 핫 리로딩 및 시간 여행과 같은 흥미로운 기능을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="d9e26ebe19ef325c1ead334671d67cb972dd9b0b" translate="yes" xml:space="preserve">
          <source>In a React app, usually you would wrap &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; in &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; so that when the URL changes, &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; will match a branch of its routes, and render their configured components. &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; is used to declaratively map routes to your application's component hierarchy. You would declare in &lt;code&gt;path&lt;/code&gt; the path used in the URL and in &lt;code&gt;component&lt;/code&gt; the single component to be rendered when the route matches the URL.</source>
          <target state="translated">React 앱에서는 일반적으로 &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; 에서 &amp;lt;Route /&amp;gt; 를 래핑 하여 URL이 변경 될 때 &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; 가 해당 경로의 분기와 일치하고 구성된 구성 요소를 렌더링합니다. &lt;code&gt;&amp;lt;Route /&amp;gt;&lt;/code&gt; 는 응용 프로그램의 구성 요소 계층에 경로를 선언적으로 매핑하는 데 사용됩니다. 경로에서 URL에 사용되는 &lt;code&gt;path&lt;/code&gt; 선언하고 경로 에서 URL과 일치 할 때 렌더링 할 단일 구성 요소를 &lt;code&gt;component&lt;/code&gt; 에 선언 합니다.</target>
        </trans-unit>
        <trans-unit id="552d20c35b7a19e38fbb041cf812c68e0d31ccf1" translate="yes" xml:space="preserve">
          <source>In a more complex app, you're going to want different entities to reference each other. We suggest that you keep your state as normalized as possible, without any nesting. Keep every entity in an object stored with an ID as a key, and use IDs to reference it from other entities, or lists. Think of the app's state as a database. This approach is described in &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr's&lt;/a&gt; documentation in detail. For example, keeping &lt;code&gt;todosById: { id -&amp;gt; todo }&lt;/code&gt; and &lt;code&gt;todos: array&amp;lt;id&amp;gt;&lt;/code&gt; inside the state would be a better idea in a real app, but we're keeping the example simple.</source>
          <target state="translated">좀 더 복잡한 앱에서는 서로 다른 엔티티가 서로를 참조하기를 원할 것입니다. 중첩없이 가능한 한 상태를 정상화 상태로 유지하는 것이 좋습니다. ID로 키로 저장된 객체의 모든 엔티티를 키로 ​​유지하고 ID를 사용하여 다른 엔티티 또는 목록에서 참조하십시오. 앱의 상태를 데이터베이스로 생각하십시오. 이 접근법은 &lt;a href=&quot;https://github.com/paularmstrong/normalizr&quot;&gt;normalizr의&lt;/a&gt; 문서에 자세히 설명되어 있습니다. 예를 들어, 실제 애플리케이션에서는 &lt;code&gt;todosById: { id -&amp;gt; todo }&lt;/code&gt; 및 &lt;code&gt;todos: array&amp;lt;id&amp;gt;&lt;/code&gt; 를 상태로 유지하는 것이 더 좋은 아이디어이지만, 예제를 단순하게 유지합니다.</target>
        </trans-unit>
        <trans-unit id="0f7529398006305ace4f3aedcbda960fbff2edf9" translate="yes" xml:space="preserve">
          <source>In a real app, you'd also want to dispatch an action on request failure. We won't implement error handling in this tutorial, but the &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; shows one of the possible approaches.</source>
          <target state="translated">실제 앱에서는 요청 실패시 작업을 전달하려고합니다. 이 자습서에서는 오류 처리를 구현하지 않지만 &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;실제 예제&lt;/a&gt; 는 가능한 방법 중 하나 를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="dc5515a15d4d57aff8873c1659dd4ea00cfc4cf6" translate="yes" xml:space="preserve">
          <source>In a unit test, you would normally import the &lt;code&gt;App&lt;/code&gt; component like this:</source>
          <target state="translated">단위 테스트에서는 일반적으로 다음과 같이 &lt;code&gt;App&lt;/code&gt; 구성 요소를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="73d7d394023da3e8367ec8a78e584be34cff3bc0" translate="yes" xml:space="preserve">
          <source>In addition to reading the state, container components can dispatch actions. In a similar fashion, you can define a function called &lt;code&gt;mapDispatchToProps()&lt;/code&gt; that receives the &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; method and returns callback props that you want to inject into the presentational component. For example, we want the &lt;code&gt;VisibleTodoList&lt;/code&gt; to inject a prop called &lt;code&gt;onTodoClick&lt;/code&gt; into the &lt;code&gt;TodoList&lt;/code&gt; component, and we want &lt;code&gt;onTodoClick&lt;/code&gt; to dispatch a &lt;code&gt;TOGGLE_TODO&lt;/code&gt; action:</source>
          <target state="translated">상태를 읽는 것 외에도 컨테이너 구성 요소는 작업을 전달할 수 있습니다. 비슷한 방식으로 &lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 메서드 를 수신 하고 프레젠테이션 구성 요소에 삽입하려는 콜백 소품을 반환 하는 &lt;code&gt;mapDispatchToProps()&lt;/code&gt; 라는 함수를 정의 할 수 있습니다 . 예를 들어, 우리는 원하는 &lt;code&gt;VisibleTodoList&lt;/code&gt; 이 라는 소품 주입 &lt;code&gt;onTodoClick&lt;/code&gt; 로 &lt;code&gt;TodoList&lt;/code&gt; 구성 요소를, 그리고 우리가 원하는 &lt;code&gt;onTodoClick&lt;/code&gt; 가 발송하는 &lt;code&gt;TOGGLE_TODO&lt;/code&gt; 의 조치를 :</target>
        </trans-unit>
        <trans-unit id="43300067fd4f93325fe0edeb1855206b18b46712" translate="yes" xml:space="preserve">
          <source>In contrast, immutable libraries such as Immutable.JS can employ sophisticated optimization techniques such as &lt;a href=&quot;http://www.slideshare.net/mohitthatte/a-deep-dive-into-clojures-data-structures-euroclojure-2015&quot;&gt;structural sharing&lt;/a&gt; , which effectively returns a new object that reuses much of the existing object being copied from.</source>
          <target state="translated">반대로 Immutable.JS와 같은 불변 라이브러리는 &lt;a href=&quot;http://www.slideshare.net/mohitthatte/a-deep-dive-into-clojures-data-structures-euroclojure-2015&quot;&gt;구조 공유&lt;/a&gt; 와 같은 정교한 최적화 기술을 사용할 수 있으며 , 이는 복사중인 기존 객체의 많은 부분을 재사용하는 새 객체를 효과적으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="29ff2a8b0f9d11d36b350ca4a91fa734773c9d7a" translate="yes" xml:space="preserve">
          <source>In fact, benchmarks have shown that more connected components generally leads to better performance than fewer connected components.</source>
          <target state="translated">실제로 벤치 마크 결과, 연결된 컴포넌트가 많을수록 연결된 컴포넌트가 적을 때보 다 성능이 향상되는 것으로 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="99060159575d5e17d9887f3b127903e3ce8600c6" translate="yes" xml:space="preserve">
          <source>In general, Redux suggests that code with side effects should be part of the action creation process. While that logic &lt;em&gt;can&lt;/em&gt; be performed inside of a UI component, it generally makes sense to extract that logic into a reusable function so that the same logic can be called from multiple places&amp;mdash;in other words, an action creator function.</source>
          <target state="translated">일반적으로 Redux는 부작용이있는 코드가 활동 작성 프로세스의 일부 여야한다고 제안합니다. 이 로직 &lt;em&gt;은&lt;/em&gt; UI 구성 요소 내에서 수행 &lt;em&gt;할 수&lt;/em&gt; 있지만 일반적으로 해당 로직을 재사용 가능한 함수로 추출하여 동일한 로직을 여러 위치 (즉, 액션 생성기 함수)에서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e2c413ba873419804cdd854ba00b2ace6bb914c" translate="yes" xml:space="preserve">
          <source>In general, ask if these actions are related but independent, or should actually be represented as one action. Do what makes sense for your own situation but try to balance the readability of reducers with readability of the action log. For example, an action that includes the whole new state tree would make your reducer a one-liner, but the downside is now you have no history of &lt;em&gt;why&lt;/em&gt; the changes are happening, so debugging gets really difficult. On the other hand, if you emit actions in a loop to keep them granular, it's a sign that you might want to introduce a new action type that is handled in a different way.</source>
          <target state="translated">일반적으로 이러한 조치가 관련이 있지만 독립적인지 또는 실제로 하나의 조치로 표시되어야하는지 묻습니다. 자신의 상황에 맞는 것을 수행하되 리듀서의 가독성과 작업 로그의 가독성을 균형있게 유지하십시오. 예를 들어, 완전히 새로운 상태 트리를 포함하는 액션은 리듀서를 하나의 라이너로 만들지 만, 단점은 이제 변경이 발생한 &lt;em&gt;이유에&lt;/em&gt; 대한 기록이 없기 때문에 디버깅이 실제로 어려워집니다. 반면에, 세부적으로 유지하기 위해 루프에서 조치를 수행하는 경우 다른 방식으로 처리되는 새 조치 유형을 도입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d9ba084eaa1fa2c8e34fad4286a77182f2d2144" translate="yes" xml:space="preserve">
          <source>In general, it looks like this:</source>
          <target state="translated">일반적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f22c2593249db901262ae0d0b5a9dc7e8b78af5" translate="yes" xml:space="preserve">
          <source>In general, remember that reducers are just functions&amp;mdash;you can organize them and subdivide them any way you want, and you are encouraged to break them down into smaller, reusable functions (&amp;ldquo;reducer composition&amp;rdquo;). While you do so, you may pass a custom third argument from a parent reducer if a child reducer needs additional data to calculate its next state. You just need to make sure that together they follow the basic rules of reducers: &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt;, and update state immutably rather than mutating it directly.</source>
          <target state="translated">일반적으로 리듀서는 단지 기능 일뿐입니다. 리듀서는 원하는 방식으로 구성하고 세분화 할 수 있으며 더 작고 재사용 가능한 기능 ( &quot;감축 기 구성&quot;)으로 분류하는 것이 좋습니다. 그렇게하는 동안 자식 감속기가 다음 상태를 계산하기 위해 추가 데이터가 필요한 경우 부모 감속기에서 사용자 지정 세 번째 인수를 전달할 수 있습니다. 함께 리듀서의 기본 규칙 &lt;code&gt;(state, action) =&amp;gt; newState&lt;/code&gt; 상태를 직접 변경하지 않고 불변으로 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="d63121f6c921270caadcee04ea945bd0333108c2" translate="yes" xml:space="preserve">
          <source>In general, try to find a balance between understandable data flow and areas of responsibility with your components.</source>
          <target state="translated">일반적으로 이해 가능한 데이터 흐름과 구성 요소의 책임 영역간에 균형을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="51c2fa7138486d88b5fa18d2475648afe59d02ed" translate="yes" xml:space="preserve">
          <source>In general, use Redux when you have reasonable amounts of data changing over time, you need a single source of truth, and you find that approaches like keeping everything in a top-level React component's state are no longer sufficient.</source>
          <target state="translated">일반적으로 시간이 지남에 따라 합리적인 양의 데이터가 변경되고 단일 소스가 필요하고 최상위 React 구성 요소의 상태를 유지하는 것과 같은 접근 방식으로는 더 이상 충분하지 않은 경우 Redux를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="55c79e3652fe883445e9b3cd96eb5f575b10fb17" translate="yes" xml:space="preserve">
          <source>In order to be able to test the App component itself without having to deal with the decorator, we recommend you to also export the undecorated component:</source>
          <target state="translated">데코레이터를 처리하지 않고도 앱 구성 요소 자체를 테스트하려면 데코 레이팅되지 않은 구성 요소도 내보내는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6c1a7092fe1aea25b944efebbf5658054ed3643a" translate="yes" xml:space="preserve">
          <source>In order to share a selector across multiple &lt;code&gt;VisibleTodoList&lt;/code&gt; components &lt;strong&gt;and&lt;/strong&gt; retain memoization, each instance of the component needs its own private copy of the selector.</source>
          <target state="translated">여러 걸쳐 선택기를 공유하기 위해 &lt;code&gt;VisibleTodoList&lt;/code&gt; 의 구성 요소 &lt;strong&gt;및&lt;/strong&gt; 메모이 제이션을 유지, 구성 요소의 각 인스턴스는 선택의 자체 전용 사본이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ff57866679ccf8351cc1283dd5651be401dbe088" translate="yes" xml:space="preserve">
          <source>In our example, we take a rudimentary approach to security. When we obtain the parameters from the request, we use &lt;code&gt;parseInt&lt;/code&gt; on the &lt;code&gt;counter&lt;/code&gt; parameter to ensure this value is a number. If we did not do this, you could easily get dangerous data into the rendered HTML by providing a script tag in the request. That might look like this: &lt;code&gt;?counter=&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt;doSomethingBad();&amp;lt;/script&amp;gt;&lt;/code&gt;</source>
          <target state="translated">이 예에서는 보안에 대한 기본적인 접근 방식을 취합니다. 요청에서 매개 변수를 가져올 때 &lt;code&gt;counter&lt;/code&gt; 매개 변수 에 &lt;code&gt;parseInt&lt;/code&gt; 를 사용하여이 값이 숫자인지 확인합니다. 이 작업을 수행하지 않으면 요청에 스크립트 태그를 제공하여 렌더링 된 HTML에 위험한 데이터를 쉽게 가져올 수 있습니다. 다음과 같이 보일 수 있습니다. &lt;code&gt;?counter=&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt;doSomethingBad();&amp;lt;/script&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a45d519ec7092557332a21b4f95c7890f59d8c28" translate="yes" xml:space="preserve">
          <source>In particular, immutability in the context of a Web app enables sophisticated change detection techniques to be implemented simply and cheaply, ensuring the computationally expensive process of updating the DOM occurs only when it absolutely has to (a cornerstone of React&amp;rsquo;s performance improvements over other libraries).</source>
          <target state="translated">특히, 웹 앱의 맥락에서 불변성은 정교한 변경 감지 기술을 간단하고 저렴하게 구현할 수있게하여 DOM을 업데이트하는 계산 비용이 많이 드는 프로세스가 반드시 필요한 경우에만 발생하도록합니다 (다른 라이브러리에 비해 React의 성능 향상의 초석) .</target>
        </trans-unit>
        <trans-unit id="3ea8b1a13105717d19bf6d13ca29baf9d351fc73" translate="yes" xml:space="preserve">
          <source>In some cases, you will need to modify the &lt;code&gt;create&lt;/code&gt; function to use different mock implementations of &lt;code&gt;getState&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;.</source>
          <target state="translated">경우에 따라 &lt;code&gt;getState&lt;/code&gt; 및 &lt;code&gt;next&lt;/code&gt; 의 다른 모의 구현을 사용 하도록 &lt;code&gt;create&lt;/code&gt; 함수를 수정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9a560778ff92a1d751e213c0779836fe6174dc6b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;../basics/index&quot;&gt;basics guide&lt;/a&gt;, we built a simple todo application. It was fully synchronous. Every time an action was dispatched, the state was updated immediately.</source>
          <target state="translated">에서 &lt;a href=&quot;../basics/index&quot;&gt;기본 안내서&lt;/a&gt; , 우리는 간단한 할 일 응용 프로그램을 만들었습니다. 완전히 동기화되었습니다. 작업이 발송 될 때마다 상태가 즉시 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="9d35265d513681e328e0eff05e802f8cb476ce9d" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;../basics/index&quot;&gt;basics walkthrough&lt;/a&gt;, we explored how to structure a simple Redux application. In this walkthrough, we will explore how AJAX and routing fit into the picture.</source>
          <target state="translated">에서 &lt;a href=&quot;../basics/index&quot;&gt;기본이 둘러 보지&lt;/a&gt; , 우리는 간단한 돌아 오는 응용 프로그램을 구성하는 방법을 탐구. 이 연습에서는 AJAX 및 라우팅이 그림에 어떻게 적용되는지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="c7465b6d942c4e067cd6e80afe069da00300c514" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;mapStateToProps&lt;/code&gt; calls &lt;code&gt;getVisibleTodos&lt;/code&gt; to calculate &lt;code&gt;todos&lt;/code&gt;. This works great, but there is a drawback: &lt;code&gt;todos&lt;/code&gt; is calculated every time the component is updated. If the state tree is large, or the calculation expensive, repeating the calculation on every update may cause performance problems. Reselect can help to avoid these unnecessary recalculations.</source>
          <target state="translated">위 예제에서 &lt;code&gt;mapStateToProps&lt;/code&gt; 는 &lt;code&gt;getVisibleTodos&lt;/code&gt; 를 호출 하여 &lt;code&gt;todos&lt;/code&gt; 를 계산 합니다. 이 방법은 훌륭하지만 단점 이 있습니다. 구성 요소를 업데이트 &lt;code&gt;todos&lt;/code&gt; 때마다 할 일 이 계산됩니다. 상태 트리가 크거나 계산이 비싼 경우 모든 업데이트에서 계산을 반복하면 성능 문제가 발생할 수 있습니다. 다시 선택하면 이러한 불필요한 재 계산을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74b79c0e319782fa1b2ce1286be0efeb546c9fb7" translate="yes" xml:space="preserve">
          <source>In the app itself, you would still import it normally:</source>
          <target state="translated">앱 자체에서는 여전히 정상적으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="37f755748aa6d0df9f0a90fd85dea6dc752d6246" translate="yes" xml:space="preserve">
          <source>In the end, Redux is just a tool. It's a great tool, and there's some great reasons to use it, but there's also reasons you might not want to use it. Make informed decisions about your tools, and understand the tradeoffs involved in each decision.</source>
          <target state="translated">결국, Redux는 도구 일뿐입니다. 훌륭한 도구이며 사용해야 할 몇 가지 이유가 있지만 사용하지 않으려는 이유도 있습니다. 도구에 대한 정보에 근거한 결정을 내리고 각 결정과 관련된 장단점을 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="26a5d759ba12e2ce01d8df1300b5865e8a1aceec" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;getVisibilityFilter&lt;/code&gt; and &lt;code&gt;getTodos&lt;/code&gt; are input-selectors. They are created as ordinary non-memoized selector functions because they do not transform the data they select. &lt;code&gt;getVisibleTodos&lt;/code&gt; on the other hand is a memoized selector. It takes &lt;code&gt;getVisibilityFilter&lt;/code&gt; and &lt;code&gt;getTodos&lt;/code&gt; as input-selectors, and a transform function that calculates the filtered todos list.</source>
          <target state="translated">위의 예에서 &lt;code&gt;getVisibilityFilter&lt;/code&gt; 및 &lt;code&gt;getTodos&lt;/code&gt; 는 입력 선택기입니다. 선택한 데이터를 변환하지 않기 때문에 메모리가없는 일반적인 선택기 함수로 작성됩니다. 반면에 &lt;code&gt;getVisibleTodos&lt;/code&gt; 는 메모리 화 된 선택기입니다. 이 얻어 &lt;code&gt;getVisibilityFilter&lt;/code&gt; 및 &lt;code&gt;getTodos&lt;/code&gt; 를 입력 선택기로하고 계산 목록 일하러 여과하는 변환 함수.</target>
        </trans-unit>
        <trans-unit id="afd7412498e7c4b8984657c38f0316bc34913128" translate="yes" xml:space="preserve">
          <source>In the example below &lt;code&gt;makeMapStateToProps&lt;/code&gt; creates a new &lt;code&gt;getVisibleTodos&lt;/code&gt; selector, and returns a &lt;code&gt;mapStateToProps&lt;/code&gt; function that has exclusive access to the new selector:</source>
          <target state="translated">아래 예제에서 &lt;code&gt;makeMapStateToProps&lt;/code&gt; 는 새 &lt;code&gt;getVisibleTodos&lt;/code&gt; 선택기를 작성하고 새 선택기에 독점적으로 액세스 할 수 있는 &lt;code&gt;mapStateToProps&lt;/code&gt; 함수를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="02549e5da1d96280abf9f8af834de7e02b0480e3" translate="yes" xml:space="preserve">
          <source>In the example below, if &lt;code&gt;state.todos&lt;/code&gt; and the value returned from &lt;code&gt;getVisibleTodos()&lt;/code&gt; do not change on successive calls to &lt;code&gt;connect&lt;/code&gt;, then the component will not re-render .</source>
          <target state="translated">아래 예제에서, &lt;code&gt;state.todos&lt;/code&gt; 와 &lt;code&gt;getVisibleTodos()&lt;/code&gt; 에서 리턴 된 값 이 &lt;code&gt;connect&lt;/code&gt; 을위한 연속 호출에서 변경 되지 않으면 컴포넌트는 다시 렌더링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74ee9c48a9c85ce991273312632d3dd6b926ea53" translate="yes" xml:space="preserve">
          <source>In the first part of this recipe, we will explain the underlying concepts that make Undo and Redo possible to implement in a generic way.</source>
          <target state="translated">이 레시피의 첫 번째 부분에서는 Undo 및 Redo를 일반적인 방식으로 구현할 수있는 기본 개념을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b2243bc74f11442cdf674f937bd6d1c08c6272ae" translate="yes" xml:space="preserve">
          <source>In the following recipe, we are going to look at how to set up server-side rendering. We'll use the simplistic &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;Counter app&lt;/a&gt; as a guide and show how the server can render state ahead of time based on the request.</source>
          <target state="translated">다음 레시피에서는 서버 측 렌더링을 설정하는 방법을 살펴 보겠습니다. 간단한 &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/counter&quot;&gt;카운터 앱&lt;/a&gt; 을 가이드로 사용하고 요청에 따라 서버가 상태를 미리 렌더링하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c5cd11df4343550d7d4e43af17f049e566352685" translate="yes" xml:space="preserve">
          <source>In the previous sections, we defined the &lt;a href=&quot;actions&quot;&gt;actions&lt;/a&gt; that represent the facts about &amp;ldquo;what happened&amp;rdquo; and the &lt;a href=&quot;reducers&quot;&gt;reducers&lt;/a&gt; that update the state according to those actions.</source>
          <target state="translated">이전 섹션에서는 &amp;ldquo;무슨 일이 있었는지&amp;rdquo;에 대한 사실을 나타내는 &lt;a href=&quot;actions&quot;&gt;조치&lt;/a&gt; 와 해당 조치에 따라 상태를 업데이트하는 &lt;a href=&quot;reducers&quot;&gt;감속기&lt;/a&gt; 를 정의했습니다 .</target>
        </trans-unit>
        <trans-unit id="e93726cac65849e4d12ae302dc65296290899ed8" translate="yes" xml:space="preserve">
          <source>In the second part of this recipe, we will show how to use &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt; package that provides this functionality out of the box.</source>
          <target state="translated">이 레시피의 두 번째 부분 에서는이 기능을 즉시 제공 하는 &lt;a href=&quot;https://github.com/omnidan/redux-undo&quot;&gt;Redux Undo&lt;/a&gt; 패키지 를 사용하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="faa485784e2157411990893a973a8bd333ffb697" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;state&lt;/code&gt; was specified so it didn't fall back to &lt;code&gt;{}&lt;/code&gt;. It was an object with &lt;code&gt;a&lt;/code&gt; field equal to &lt;code&gt;'horse'&lt;/code&gt;, but without the &lt;code&gt;b&lt;/code&gt; field. This is why the &lt;code&gt;a&lt;/code&gt; reducer received &lt;code&gt;'horse'&lt;/code&gt; as its &lt;code&gt;state&lt;/code&gt; and gladly returned it, but the &lt;code&gt;b&lt;/code&gt; reducer received &lt;code&gt;undefined&lt;/code&gt; as its &lt;code&gt;state&lt;/code&gt; and thus returned &lt;em&gt;its idea&lt;/em&gt; of the default &lt;code&gt;state&lt;/code&gt; (in our example, &lt;code&gt;'wat'&lt;/code&gt;). This is how we get &lt;code&gt;{ a: 'horse', b: 'wat' }&lt;/code&gt; in return.</source>
          <target state="translated">이 경우 &lt;code&gt;state&lt;/code&gt; 는 &lt;code&gt;{}&lt;/code&gt; 으로 돌아 가지 않도록 지정되었습니다 . 이것은와 개체였다 필드는 동일한 &lt;code&gt;'horse'&lt;/code&gt; 하지만 않고 &lt;code&gt;b&lt;/code&gt; 필드. 왜 '이다 감속기받은 &lt;code&gt;'horse'&lt;/code&gt; 은 같은 &lt;code&gt;state&lt;/code&gt; 기꺼이 그것을 반환하지만, &lt;code&gt;b&lt;/code&gt; 감속기가 수신 &lt;code&gt;undefined&lt;/code&gt; 그 같은 &lt;code&gt;state&lt;/code&gt; 따라서 반환 &lt;em&gt;의 아이디어를&lt;/em&gt; 기본의 &lt;code&gt;state&lt;/code&gt; (우리의 예에서 &lt;code&gt;'wat'&lt;/code&gt; ). 이것이 우리가 &lt;code&gt;{ a: 'horse', b: 'wat' }&lt;/code&gt; 을 얻는 방법 입니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f092b4bf36ca89a0195ff54516fa10e82e7e403d" translate="yes" xml:space="preserve">
          <source>In this code, there are two interesting parts:</source>
          <target state="translated">이 코드에는 두 가지 흥미로운 부분이 있습니다.</target>
        </trans-unit>
        <trans-unit id="71ff63357cd40c92d16604f3aa798bf1944dff1e" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;todos&lt;/code&gt; and &lt;code&gt;visibilityFilter&lt;/code&gt; are both top-level keys in the state, and each represents a &quot;slice&quot; of data for some particular concept.</source>
          <target state="translated">이 예에서 &lt;code&gt;todos&lt;/code&gt; 및 &lt;code&gt;visibilityFilter&lt;/code&gt; 필터 는 상태의 최상위 키이며 각각 특정 개념에 대한 데이터의 &quot;슬라이스&quot;를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="76b5dc7b5ea1bc39335dc8d9e264ade04c2338c5" translate="yes" xml:space="preserve">
          <source>In this example, we store the received items together with the pagination information. However, this approach won't work well if you have nested entities referencing each other, or if you let the user edit items. Imagine the user wants to edit a fetched post, but this post is duplicated in several places in the state tree. This would be really painful to implement.</source>
          <target state="translated">이 예에서는 수신 된 항목을 페이지 매김 정보와 함께 저장합니다. 그러나 중첩 된 엔터티가 서로를 참조하거나 사용자가 항목을 편집 할 수있게하면이 방법이 제대로 작동하지 않습니다. 사용자가 가져온 게시물을 편집하려고하지만이 게시물이 상태 트리의 여러 위치에 복제되었다고 가정합니다. 구현하기가 정말 힘들 것입니다.</target>
        </trans-unit>
        <trans-unit id="d38453f2982934a0e4a9ceb3c56a5bc2171aeeca" translate="yes" xml:space="preserve">
          <source>In this guide, we will build a different, asynchronous application. It will use the Reddit API to show the current headlines for a selected subreddit. How does asynchronicity fit into Redux flow?</source>
          <target state="translated">이 가이드에서는 다른 비동기 응용 프로그램을 작성합니다. Reddit API를 사용하여 선택된 하위 레딧에 대한 현재 헤드 라인을 표시합니다. 비 동시성은 Redux 흐름에 어떻게 맞습니까?</target>
        </trans-unit>
        <trans-unit id="6560c487884e558589c10deb770162dd33a72a4b" translate="yes" xml:space="preserve">
          <source>In this guide, we won't normalize entities, but it's something you should consider for a more dynamic application.</source>
          <target state="translated">이 가이드에서는 엔터티를 정규화하지는 않지만보다 동적 인 응용 프로그램에서는 고려해야 할 사항입니다.</target>
        </trans-unit>
        <trans-unit id="5a84d91992fe1ee4ade8af66d135912f74026aac" translate="yes" xml:space="preserve">
          <source>In this guide, we'll walk through the process of creating a simple Todo app.</source>
          <target state="translated">이 가이드에서는 간단한 Todo 앱을 만드는 과정을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="7a3264d98279777fdf4abb2ddc1f6f9425eb13ec" translate="yes" xml:space="preserve">
          <source>In this part of the recipe, you will learn how to make the &lt;a href=&quot;../basics/exampletodolist&quot;&gt;Todo List example&lt;/a&gt; undoable. You can find the full source of this recipe in the &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;&lt;code&gt;todos-with-undo&lt;/code&gt; example that comes with Redux&lt;/a&gt;.</source>
          <target state="translated">레시피의이 부분에서는 &lt;a href=&quot;../basics/exampletodolist&quot;&gt;Todo List 예제를&lt;/a&gt; 실행 취소 하는 방법을 배우게됩니다 . &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/examples/todos-with-undo&quot;&gt;Redux와 함께 제공&lt;/a&gt; 되는 &lt;code&gt;todos-with-undo&lt;/code&gt; 예제 에서이 레시피의 전체 소스를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="584304393b0ea6955cb4308163835ca022286a68" translate="yes" xml:space="preserve">
          <source>Influences</source>
          <target state="translated">Influences</target>
        </trans-unit>
        <trans-unit id="de155c1609b33aab2a421d885b10f58302427667" translate="yes" xml:space="preserve">
          <source>Initial Reducer</source>
          <target state="translated">초기 감속기</target>
        </trans-unit>
        <trans-unit id="13ff8f213c0a10779a370cddf8f0fc33be27fbc0" translate="yes" xml:space="preserve">
          <source>Initializing State</source>
          <target state="translated">초기화 상태</target>
        </trans-unit>
        <trans-unit id="a5ff420ada3c0a5605a30920772184b34ab3a629" translate="yes" xml:space="preserve">
          <source>Inject Initial Component HTML and State</source>
          <target state="translated">초기 구성 요소 HTML 및 상태 삽입</target>
        </trans-unit>
        <trans-unit id="3d86177949674f0d3d6f94fa38a597fbce828a69" translate="yes" xml:space="preserve">
          <source>Insert the &lt;code&gt;present&lt;/code&gt; at the end of the &lt;code&gt;past&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;past&lt;/code&gt; 의 끝에 &lt;code&gt;present&lt;/code&gt; 을 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="bcab0294df72cd75ef5a6d54589ea4dce06c352f" translate="yes" xml:space="preserve">
          <source>Insert the old &lt;code&gt;present&lt;/code&gt; state at the &lt;em&gt;beginning&lt;/em&gt; of the &lt;code&gt;future&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;future&lt;/code&gt; 의 &lt;em&gt;시작 부분&lt;/em&gt; 에 이전 &lt;code&gt;present&lt;/code&gt; 상태를 삽입하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1ec847a17c9bdb6126cb0938660b383ecf56d95" translate="yes" xml:space="preserve">
          <source>Insert the old &lt;code&gt;present&lt;/code&gt; state at the &lt;em&gt;end&lt;/em&gt; of the &lt;code&gt;past&lt;/code&gt;.</source>
          <target state="translated">이전 삽입 &lt;code&gt;present&lt;/code&gt; 상기 상태를 &lt;em&gt;말&lt;/em&gt; 의 &lt;code&gt;past&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d83e33670ddd1909319192f3e6c17aaca9a84645" translate="yes" xml:space="preserve">
          <source>Inserting and Removing Items in Arrays</source>
          <target state="translated">배열에 항목 삽입 및 제거</target>
        </trans-unit>
        <trans-unit id="b0907ce47d7d9097da0f4a803702823b572700f6" translate="yes" xml:space="preserve">
          <source>Install Packages</source>
          <target state="translated">패키지 설치</target>
        </trans-unit>
        <trans-unit id="6a3270b4b51ff970f769df9e395c358dbef395d0" translate="yes" xml:space="preserve">
          <source>Install the &lt;a href=&quot;https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog&quot;&gt;Immutable Object Formatter&lt;/a&gt; , and inspect your Immutable.JS data without seeing the noise of Immutable.JS's own object properties.</source>
          <target state="translated">&lt;a href=&quot;https://chrome.google.com/webstore/detail/immutablejs-object-format/hgldghadipiblonfkkicmgcbbijnpeog&quot;&gt;Immutable Object Formatter를&lt;/a&gt; 설치하고 Immutable.JS 자체 객체 속성의 노이즈를 보지 않고 Immutable.JS 데이터를 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="a2b7d6ff7d322426c52bf0336937cb1f5f83cc7e" translate="yes" xml:space="preserve">
          <source>Installing React Redux</source>
          <target state="translated">React Redux 설치</target>
        </trans-unit>
        <trans-unit id="919e9c6771a9e147109378578b2ca429689f31e8" translate="yes" xml:space="preserve">
          <source>Installing React Router</source>
          <target state="translated">리 액트 라우터 설치</target>
        </trans-unit>
        <trans-unit id="d01c0e156f524f6033babf6a65fdfe5fbe227c04" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;applyMiddlewareByMonkeypatching()&lt;/code&gt;, we could write &lt;code&gt;applyMiddleware()&lt;/code&gt; that first obtains the final, fully wrapped &lt;code&gt;dispatch()&lt;/code&gt; function, and returns a copy of the store using it:</source>
          <target state="translated">&lt;code&gt;applyMiddlewareByMonkeypatching()&lt;/code&gt; 대신에 완전히 래핑 된 최종 &lt;code&gt;dispatch()&lt;/code&gt; 함수 를 먼저 &lt;code&gt;applyMiddleware()&lt;/code&gt; 를 작성 하여이를 사용하여 저장소의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="19d59912d07b0c1523625f9aa8c4564aa281316e" translate="yes" xml:space="preserve">
          <source>Instead of mutating the state directly, you specify the mutations you want to happen with plain objects called &lt;em&gt;actions&lt;/em&gt;. Then you write a special function called a &lt;em&gt;reducer&lt;/em&gt; to decide how every action transforms the entire application's state.</source>
          <target state="translated">상태를 직접 변경하는 대신 &lt;em&gt;actions&lt;/em&gt; 이라는 일반 객체로 발생하는 돌연변이를 지정합니다 . 그런 다음 &lt;em&gt;리듀서&lt;/em&gt; 라는 특수 함수를 작성하여 모든 조치가 전체 애플리케이션의 상태를 변환하는 방법을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="7cc634e20909b40b70243f5387f4971fcef12462" translate="yes" xml:space="preserve">
          <source>Instead, to actually initiate a dispatch, pass the result to the &lt;code&gt;dispatch()&lt;/code&gt; function:</source>
          <target state="translated">대신 실제로 디스패치를 ​​시작하려면 그 결과를 &lt;code&gt;dispatch()&lt;/code&gt; 함수에 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8b4700d865a6bc3050b6238ea39ea11326ddf5b" translate="yes" xml:space="preserve">
          <source>Integrating Data with React Native</source>
          <target state="translated">React Native와 데이터 통합</target>
        </trans-unit>
        <trans-unit id="e94ff5f5157ce93e1e54097b202ed106931426a0" translate="yes" xml:space="preserve">
          <source>Internally, it uses &lt;a href=&quot;https://github.com/github/fetch&quot;&gt;&lt;code&gt;whatwg-fetch&lt;/code&gt; polyfill&lt;/a&gt; on the client, and &lt;a href=&quot;https://github.com/bitinn/node-fetch&quot;&gt;&lt;code&gt;node-fetch&lt;/code&gt;&lt;/a&gt; on the server, so you won't need to change API calls if you change your app to be &lt;a href=&quot;https://medium.com/@mjackson/universal-javascript-4761051b7ae9&quot;&gt;universal&lt;/a&gt;.</source>
          <target state="translated">내부적으로 클라이언트에서 &lt;a href=&quot;https://github.com/github/fetch&quot;&gt; &lt;code&gt;whatwg-fetch&lt;/code&gt; polyfill&lt;/a&gt; 과 서버에서 &lt;a href=&quot;https://github.com/bitinn/node-fetch&quot;&gt; &lt;code&gt;node-fetch&lt;/code&gt; &lt;/a&gt; 를 사용하므로 앱을 &lt;a href=&quot;https://medium.com/@mjackson/universal-javascript-4761051b7ae9&quot;&gt;universal로&lt;/a&gt; 변경하면 API 호출을 변경할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="8a6f1a995da229b02edaf632a5ace565c8ee09ce" translate="yes" xml:space="preserve">
          <source>Introduction to Immutable.js and Functional Programming Concepts</source>
          <target state="translated">Immutable.js 소개 및 함수형 프로그래밍 개념</target>
        </trans-unit>
        <trans-unit id="07b5b8bcb22926ae89618f485d25977d251671eb" translate="yes" xml:space="preserve">
          <source>Introduction: Examples</source>
          <target state="translated">소개 : 예</target>
        </trans-unit>
        <trans-unit id="4209082024c9cd9683fea7a0702e849132c096c7" translate="yes" xml:space="preserve">
          <source>Introduction: Motivation</source>
          <target state="translated">소개 : 동기</target>
        </trans-unit>
        <trans-unit id="7833c7c1e348dea95d2da014ccfe35f763549815" translate="yes" xml:space="preserve">
          <source>Invoke callbacks from props</source>
          <target state="translated">소품에서 콜백 불러 오기</target>
        </trans-unit>
        <trans-unit id="7b224be093f507de08ead59d030ff9b7f95ab8d1" translate="yes" xml:space="preserve">
          <source>Is Immutable.JS worth the effort?</source>
          <target state="translated">Immutable.JS는 그만한 가치가 있습니까?</target>
        </trans-unit>
        <trans-unit id="da302071395dfdf468568428a985f282b79b0804" translate="yes" xml:space="preserve">
          <source>Is Using Immutable.JS worth the effort?</source>
          <target state="translated">Immutable.JS를 사용하는 것이 그만한 가치가 있습니까?</target>
        </trans-unit>
        <trans-unit id="03b995ff411e93b919b4cdc03f6d0002c9968e7f" translate="yes" xml:space="preserve">
          <source>Is it OK to have more than one middleware chain in my store enhancer? What is the difference between &lt;code&gt;next&lt;/code&gt; and &lt;code&gt;dispatch&lt;/code&gt; in a middleware function?</source>
          <target state="translated">내 상점 개선 프로그램에 둘 이상의 미들웨어 체인이있는 것이 괜찮습니까? 미들웨어 함수에서 &lt;code&gt;next&lt;/code&gt; 와 &lt;code&gt;dispatch&lt;/code&gt; 의 차이점은 무엇입니까 ?</target>
        </trans-unit>
        <trans-unit id="f5a28ea665464bd96297075646b171f933e455eb" translate="yes" xml:space="preserve">
          <source>Is it OK to have more than one middleware chain in my store enhancer? What is the difference between next and dispatch in a middleware function?</source>
          <target state="translated">내 상점 개선 프로그램에 둘 이상의 미들웨어 체인이있는 것이 괜찮습니까? 미들웨어 함수에서 next와 dispatch의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c9383cd73080d3bf5501f85e4702d23a4e04ad13" translate="yes" xml:space="preserve">
          <source>Is the same data being used to drive multiple components?</source>
          <target state="translated">여러 구성 요소를 구동하는 데 동일한 데이터가 사용됩니까?</target>
        </trans-unit>
        <trans-unit id="da4741570a3bb3f7779f15075dab9fd931487a3a" translate="yes" xml:space="preserve">
          <source>Is there a way to make it easier to comprehend? It seems like &lt;code&gt;todos&lt;/code&gt; and &lt;code&gt;visibilityFilter&lt;/code&gt; are updated completely independently. Sometimes state fields depend on one another and more consideration is required, but in our case we can easily split updating &lt;code&gt;todos&lt;/code&gt; into a separate function:</source>
          <target state="translated">이해하기 쉽게 만드는 방법이 있습니까? &lt;code&gt;todos&lt;/code&gt; 일과 &lt;code&gt;visibilityFilter&lt;/code&gt; 필터 가 완전히 독립적으로 업데이트되는 것처럼 보입니다 . 때때로 상태 필드는 서로 의존하며 더 많은 고려가 필요하지만 우리의 경우 업데이트 &lt;code&gt;todos&lt;/code&gt; 을 별도의 함수로 쉽게 나눌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7e83fd15d92fbc9418b683c0d9790a7c6248751" translate="yes" xml:space="preserve">
          <source>Is there always a one-to-one mapping between reducers and actions?</source>
          <target state="translated">감속기와 동작 사이에 항상 일대일 매핑이 있습니까?</target>
        </trans-unit>
        <trans-unit id="84984bdef5380f48f6df27ee47064798ca74e062" translate="yes" xml:space="preserve">
          <source>Is there anything left to undo or redo?</source>
          <target state="translated">실행 취소 또는 다시 실행할 항목이 있습니까?</target>
        </trans-unit>
        <trans-unit id="f289628c32a4808458fe68440054d194866e8e5c" translate="yes" xml:space="preserve">
          <source>Is there value to you in being able to restore this state to a given point in time (ie, time travel debugging)?</source>
          <target state="translated">이 상태를 주어진 시점 (즉, 시간 여행 디버깅)으로 복원 할 수있는 가치가 있습니까?</target>
        </trans-unit>
        <trans-unit id="ea4cec2a5adc22a33671afe8c2442bda5e76ae5a" translate="yes" xml:space="preserve">
          <source>Isolating Redux Sub-Apps</source>
          <target state="translated">Redux 하위 앱 격리</target>
        </trans-unit>
        <trans-unit id="ce286d263926cfdb1859da7cb4876ed9e5c9ba84" translate="yes" xml:space="preserve">
          <source>Isolating Subapps</source>
          <target state="translated">서브 앱 분리</target>
        </trans-unit>
        <trans-unit id="b03cd03c1cbbbb49e2d53831a74d4f4cbf478570" translate="yes" xml:space="preserve">
          <source>Isolating a Redux app as a component in a bigger application, in which case you might want to create a store per root component instance.</source>
          <target state="translated">더 큰 응용 프로그램에서 Redux 앱을 구성 요소로 격리하면 루트 구성 요소 인스턴스 당 저장소를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e2da235921f2dc98b67a3405af6d4d8b66644a3" translate="yes" xml:space="preserve">
          <source>It detects a change by keeping a reference to the root state object, and a reference to &lt;em&gt;each value&lt;/em&gt; in the props object that's returned from the &lt;code&gt;mapStateToProps&lt;/code&gt; function.</source>
          <target state="translated">루트 상태 객체에 대한 참조와 &lt;code&gt;mapStateToProps&lt;/code&gt; 함수 에서 반환 된 props 객체의 &lt;em&gt;각 값&lt;/em&gt; 에 대한 참조를 유지하여 변경을 감지 합니다.</target>
        </trans-unit>
        <trans-unit id="0678b386548901ffe5796fba691a7dd7a055517b" translate="yes" xml:space="preserve">
          <source>It does a bit of trickery to make sure that if you call &lt;code&gt;store.dispatch(action)&lt;/code&gt; from your middleware instead of &lt;code&gt;next(action)&lt;/code&gt;, the action will actually travel the whole middleware chain again, including the current middleware. This is useful for asynchronous middleware, as we have seen &lt;a href=&quot;asyncactions&quot;&gt;previously&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;next(action)&lt;/code&gt; 대신 미들웨어에서 &lt;code&gt;store.dispatch(action)&lt;/code&gt; 을 호출 하면 현재 미들웨어를 포함하여 실제로 미들웨어 체인 전체를 다시 이동시키는 지 확인하는 것은 약간의 속임수 입니다. 이것은 &lt;a href=&quot;asyncactions&quot;&gt;앞에서&lt;/a&gt; 본 것처럼 비동기 미들웨어에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="c838975ff8bc1485249cfc27d4ffd7a7c7eba961" translate="yes" xml:space="preserve">
          <source>It does not require a build system or a view framework and exists to show the raw Redux API used with ES5.</source>
          <target state="translated">빌드 시스템이나 뷰 프레임 워크가 필요하지 않으며 ES5와 함께 사용되는 원시 Redux API를 보여주기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="72186694410e16c516c9d596656e81807bdc0ee2" translate="yes" xml:space="preserve">
          <source>It does so because the props object is actually a hash of prop names and their values (or selector functions that are used to retrieve or generate the values), such as in this example:</source>
          <target state="translated">props 객체는 실제로 다음 예제와 같이 prop 이름과 해당 값 (또는 값을 검색하거나 생성하는 데 사용되는 선택기 함수)의 해시이기 때문에 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd40f9379225350f73c28d7d8b350321206fccb5" translate="yes" xml:space="preserve">
          <source>It does this by performing a shallow equality check on each value within the object individually, and will only trigger a re-render if one of those checks fails.</source>
          <target state="translated">객체의 각 값에 대해 개별적으로 얕은 동등성 검사를 수행하여이를 수행하며, 이러한 검사 중 하나가 실패하는 경우에만 다시 렌더링을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="cc8c262fccc1fd13b37e15839544d8f0e42b7f17" translate="yes" xml:space="preserve">
          <source>It doesn't work because your action creator is just a function that &lt;em&gt;returns&lt;/em&gt; an action. It is up to you to actually dispatch it. We can't bind your action creators to a particular Store instance during the definition because apps that render on the server need a separate Redux store for every request.</source>
          <target state="translated">액션 크리에이터는 액션을 &lt;em&gt;반환&lt;/em&gt; 하는 함수이기 때문에 작동하지 않습니다 . 실제로 파견하는 것은 당신에게 달려 있습니다. 서버에서 렌더링하는 앱은 모든 요청에 ​​대해 별도의 Redux 스토어가 필요하기 때문에 정의 중에 액션 생성자를 특정 스토어 인스턴스에 바인딩 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="50bdebff8f75748e8eb5b1028b6f9e739d1e11eb" translate="yes" xml:space="preserve">
          <source>It helps keep the naming consistent because all action types are gathered in a single place.</source>
          <target state="translated">모든 조치 유형이 한 곳에 모이기 때문에 이름의 일관성을 유지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="79e39e70b7c42af694874a6eb695630593111193" translate="yes" xml:space="preserve">
          <source>It helps you write applications that behave consistently, run in different environments (client, server, and native), and are easy to test. On top of that, it provides a great developer experience, such as &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;live code editing combined with a time traveling debugger&lt;/a&gt;.</source>
          <target state="translated">일관성있게 동작하고 다른 환경 (클라이언트, 서버 및 기본)에서 실행되며 테스트하기 쉬운 응용 프로그램을 작성하는 데 도움이됩니다. 또한 &lt;a href=&quot;https://github.com/gaearon/redux-devtools&quot;&gt;시간 이동 디버거와 결합 된 라이브 코드 편집과&lt;/a&gt; 같은 훌륭한 개발자 경험을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="94502169236559f86f242ead05d16d88d3912a58" translate="yes" xml:space="preserve">
          <source>It is a common convention that actions have a constant type that helps reducers (or Stores in Flux) identify them. We recommend that you use strings and not &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;Symbols&lt;/a&gt; for action types, because strings are serializable, and by using Symbols you make recording and replaying harder than it needs to be.</source>
          <target state="translated">리듀서 (또는 플럭스의 스토어)에서 액션을 식별하는 데 도움이되는 상수 유형이 액션에있는 것이 일반적인 규칙입니다. 문자열은 직렬화 가능하고 기호를 사용하면 기록 및 재생을 필요 이상으로 어렵게 만들므로 동작 유형에 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol&quot;&gt;기호&lt;/a&gt; 가 아닌 문자열을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="61c76ff225751e91aabc5dfc794a50b75a44444c" translate="yes" xml:space="preserve">
          <source>It is a low-level API. Most likely, instead of using it directly, you'll use React (or other) bindings. If you commonly use the callback as a hook to react to state changes, you might want to &lt;a href=&quot;https://github.com/reactjs/redux/issues/303#issuecomment-125184409&quot;&gt;write a custom &lt;code&gt;observeStore&lt;/code&gt; utility&lt;/a&gt;. The &lt;code&gt;Store&lt;/code&gt; is also an &lt;a href=&quot;https://github.com/zenparsing/es-observable&quot;&gt;&lt;code&gt;Observable&lt;/code&gt;&lt;/a&gt;, so you can &lt;code&gt;subscribe&lt;/code&gt; to changes with libraries like &lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt;.</source>
          <target state="translated">저수준 API입니다. 대부분 직접 사용하는 대신 React (또는 다른) 바인딩을 사용합니다. 상태 변경에 반응하기 위해 일반적으로 콜백을 후크로 사용하는 경우 &lt;a href=&quot;https://github.com/reactjs/redux/issues/303#issuecomment-125184409&quot;&gt;사용자 지정 &lt;code&gt;observeStore&lt;/code&gt; 유틸리티&lt;/a&gt; 를 작성할 수 있습니다 . &lt;code&gt;Store&lt;/code&gt; 또한이다 &lt;a href=&quot;https://github.com/zenparsing/es-observable&quot;&gt; &lt;code&gt;Observable&lt;/code&gt; &lt;/a&gt; 당신이 할 수 있도록 &lt;code&gt;subscribe&lt;/code&gt; 등의 라이브러리와 변화에 &lt;a href=&quot;https://github.com/ReactiveX/RxJS&quot;&gt;RxJS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b86f7926b42042d8d9540bde7f55a9d1fbef0e9" translate="yes" xml:space="preserve">
          <source>It is also possible to do the reverse and migrate from Redux to any of these libraries following the same steps.</source>
          <target state="translated">동일한 단계에 따라 역순으로 Redux에서 이러한 라이브러리로 마이그레이션 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f367ba512c5331d9b1a4dc415838a8c2dbcc6d80" translate="yes" xml:space="preserve">
          <source>It is also up to us whether to keep a single top-level history:</source>
          <target state="translated">단일 최상위 기록을 유지할지 여부는 우리에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="837f9f9a88a29e4f25a6eaa8ea75e703183100af" translate="yes" xml:space="preserve">
          <source>It is an advanced API. You might need this if your app implements code splitting, and you want to load some of the reducers dynamically. You might also need this if you implement a hot reloading mechanism for Redux.</source>
          <target state="translated">고급 API입니다. 앱이 코드 분할을 구현하고 일부 리듀서를 동적으로로드하려는 경우에 필요할 수 있습니다. Redux에 대한 핫 리로드 메커니즘을 구현하는 경우에도 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79971d102866cc7813eb74dfec64bdc730b286c2" translate="yes" xml:space="preserve">
          <source>It is another common convention that, instead of creating action objects inline in the places where you dispatch the actions, you would create functions generating them.</source>
          <target state="translated">액션을 디스패치하는 장소에 액션 객체를 인라인으로 만드는 대신,이를 생성하는 함수를 만드는 것이 일반적인 관례입니다.</target>
        </trans-unit>
        <trans-unit id="249542e851b7d943285bfc44e6d5f0e85e9977ed" translate="yes" xml:space="preserve">
          <source>It is equal to the last value returned by the store's reducer.</source>
          <target state="translated">상점 리듀서가 리턴 한 마지막 값과 같습니다.</target>
        </trans-unit>
        <trans-unit id="312b7c808648f4df7cabafd144e579400360a08e" translate="yes" xml:space="preserve">
          <source>It is essential to chaining middleware!</source>
          <target state="translated">미들웨어를 연결하는 데 필수적입니다!</target>
        </trans-unit>
        <trans-unit id="dda50451faae254a9269dbf26176ea6006fc9b9e" translate="yes" xml:space="preserve">
          <source>It is highly recommended that you only put plain serializable objects, arrays, and primitives into your store. It's &lt;em&gt;technically&lt;/em&gt; possible to insert non-serializable items into the store, but doing so can break the ability to persist and rehydrate the contents of a store, as well as interfere with time-travel debugging.</source>
          <target state="translated">일반 직렬화 가능 오브젝트, 배열 및 기본 요소 만 상점에 배치하는 것이 좋습니다. 그건 &lt;em&gt;기술적으로&lt;/em&gt; 가게에 직렬화 항목을 삽입 할 수 있지만, 물론 시간 여행 디버깅 방해로, 지속 및 상점의 내용을 재수 할 수있는 능력을 깰 수 있도록하고.</target>
        </trans-unit>
        <trans-unit id="0d99f22665bd7c5155d03f21570bcb486fa6b3cf" translate="yes" xml:space="preserve">
          <source>It is important for it to be separate from &lt;code&gt;SELECT_SUBREDDIT&lt;/code&gt; or &lt;code&gt;INVALIDATE_SUBREDDIT&lt;/code&gt;. While they may occur one after another, as the app grows more complex, you might want to fetch some data independently of the user action (for example, to prefetch the most popular subreddits, or to refresh stale data once in a while). You may also want to fetch in response to a route change, so it's not wise to couple fetching to some particular UI event early on.</source>
          <target state="translated">&lt;code&gt;SELECT_SUBREDDIT&lt;/code&gt; 또는 &lt;code&gt;INVALIDATE_SUBREDDIT&lt;/code&gt; 와 분리하는 것이 중요합니다 . 앱이 점점 복잡 해짐에 따라 하나씩 발생할 수 있지만 사용자 작업과 독립적으로 일부 데이터를 가져오고 싶을 수 있습니다 (예 : 가장 인기있는 하위 레딧을 미리 가져 오거나 오래된 데이터를 한 번에 새로 고치기 위해). 경로 변경에 대한 응답으로 가져 오기를 원할 수도 있습니다. 따라서 가져 오기를 특정 UI 이벤트에 일찍 연결하는 것은 현명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22e208a1f7d32f64abf692053d9b4ade71eacca6" translate="yes" xml:space="preserve">
          <source>It is reasonable to suggest that our state shape should change to answer these questions:</source>
          <target state="translated">다음 질문에 답하기 위해 주 형태가 변경되어야한다고 제안하는 것이 합리적입니다.</target>
        </trans-unit>
        <trans-unit id="2826728cd3002c85132f865368ccf2dfda1f035c" translate="yes" xml:space="preserve">
          <source>It is tempting to modify the &lt;code&gt;state&lt;/code&gt; or &lt;code&gt;action&lt;/code&gt; passed to you by Redux. Don't do this!</source>
          <target state="translated">Redux가 전달한 &lt;code&gt;state&lt;/code&gt; 나 &lt;code&gt;action&lt;/code&gt; 을 수정 하려고합니다. 이러지 마!</target>
        </trans-unit>
        <trans-unit id="d8e2ea8d61178d3cf1c5299a500dca66ebcdf724" translate="yes" xml:space="preserve">
          <source>It is tiny (2kB, including dependencies).</source>
          <target state="translated">작습니다 (종속성을 포함하여 2kB).</target>
        </trans-unit>
        <trans-unit id="c1c823da484f24ab1a299266700f4f493b22a5d4" translate="yes" xml:space="preserve">
          <source>It is up to you to choose the conventions for your project. You may start by using inline strings, and later transition to constants, and maybe later group them into a single file. Redux does not have any opinion here, so use your best judgment.</source>
          <target state="translated">프로젝트에 대한 규칙을 선택하는 것은 당신에게 달려 있습니다. 인라인 문자열을 사용하여 시작한 다음 나중에 상수로 전환하여 나중에 단일 파일로 그룹화 할 수 있습니다. Redux는 여기에 의견이 없으므로 최선의 판단을하십시오.</target>
        </trans-unit>
        <trans-unit id="05093663f45944f4c69e8ddf69de181df8a06f66" translate="yes" xml:space="preserve">
          <source>It is up to you to choose the state format. You can use plain objects or something like &lt;a href=&quot;http://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt;. If you're not sure, start with plain objects.</source>
          <target state="translated">상태 형식을 선택하는 것은 사용자의 책임입니다. 일반 객체 또는 &lt;a href=&quot;http://facebook.github.io/immutable-js/&quot;&gt;Immutable&lt;/a&gt; 과 같은 것을 사용할 수 있습니다 . 확실하지 않은 경우 일반 개체로 시작하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
