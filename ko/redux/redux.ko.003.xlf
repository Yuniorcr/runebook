<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="redux">
    <body>
      <group id="redux">
        <trans-unit id="ebedd29e20c0b181d70ffe15f5988d119d67516f" translate="yes" xml:space="preserve">
          <source>You can call &lt;a href=&quot;../api/store#dispatch&quot;&gt;&lt;code&gt;store.dispatch(action)&lt;/code&gt;&lt;/a&gt; from anywhere in your app, including components and XHR callbacks, or even at scheduled intervals.</source>
          <target state="translated">구성 요소 및 XHR 콜백을 포함하여 앱의 어느 곳에서나 예약 된 간격으로 &lt;a href=&quot;../api/store#dispatch&quot;&gt; &lt;code&gt;store.dispatch(action)&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="870b3b70e7feab01dc48305e33a3f7b71d9e003a" translate="yes" xml:space="preserve">
          <source>You can control state key names by using different keys for the reducers in the passed object. For example, you may call &lt;code&gt;combineReducers({ todos: myTodosReducer, counter: myCounterReducer })&lt;/code&gt; for the state shape to be &lt;code&gt;{ todos, counter }&lt;/code&gt;.</source>
          <target state="translated">전달 된 객체의 리듀서에 다른 키를 사용하여 상태 키 이름을 제어 할 수 있습니다. 예를 들어 상태 모양이 &lt;code&gt;{ todos, counter }&lt;/code&gt; &lt;code&gt;combineReducers({ todos: myTodosReducer, counter: myCounterReducer })&lt;/code&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84b80aff840c6b3c2cb0814711f2e90fb9add9aa" translate="yes" xml:space="preserve">
          <source>You can even write a custom middleware to describe calls to your API, like the &lt;a href=&quot;../introduction/examples#real-world&quot;&gt;real world example&lt;/a&gt; does.</source>
          <target state="translated">&lt;a href=&quot;../introduction/examples#real-world&quot;&gt;실제 예제&lt;/a&gt; 처럼 API에 대한 호출을 설명하는 사용자 정의 미들웨어를 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bcfc87ae98655e6e4c23b31a5690541a13ff642" translate="yes" xml:space="preserve">
          <source>You can extract logging into a function:</source>
          <target state="translated">함수에 로깅을 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1306a831686a52c567f5d3446dae27226d983c27" translate="yes" xml:space="preserve">
          <source>You can find more examples in &lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/xgrommx/awesome-redux&quot;&gt;Awesome Redux&lt;/a&gt; 에서 더 많은 예제를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1db4cdd68a98570c03ba8a576e981e8641ef738b" translate="yes" xml:space="preserve">
          <source>You can find the official logo &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/logo&quot;&gt;on GitHub&lt;/a&gt;.</source>
          <target state="translated">공식 로고 &lt;a href=&quot;https://github.com/reactjs/redux/tree/master/logo&quot;&gt;는 GitHub에서&lt;/a&gt; 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8fb1259c8d739932d68e05103d65deeafc4b13b1" translate="yes" xml:space="preserve">
          <source>You can see how this causes the state held by the store to change:</source>
          <target state="translated">이로 인해 상점이 보유한 상태가 어떻게 변경되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4eddcb9e81b002608a7bf4ef875c82738729233" translate="yes" xml:space="preserve">
          <source>You can set up your build tool of choice (Webpack, Browserify, etc.) to compile a bundle file into &lt;code&gt;static/bundle.js&lt;/code&gt;.</source>
          <target state="translated">번들 파일을 &lt;code&gt;static/bundle.js&lt;/code&gt; 로 컴파일하도록 선택한 빌드 도구 (Webpack, Browserify 등)를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23310ba75752c6caee4c2c18e21c9fe454bf81a2" translate="yes" xml:space="preserve">
          <source>You can then pass &lt;code&gt;dispatch&lt;/code&gt; down to other components manually, if you want to.</source>
          <target state="translated">그런 다음 원하는 경우 &lt;code&gt;dispatch&lt;/code&gt; 를 다른 구성 요소로 수동으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f95f737abcdb30e78aa13a25f5076e2ef6dc3676" translate="yes" xml:space="preserve">
          <source>You can then use it everywhere instead of &lt;code&gt;store.dispatch()&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;store.dispatch()&lt;/code&gt; 대신 어디서나 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bfbaa58ba5417a98c5d0d32b5ce14eba1d4e2fef" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; or &lt;a href=&quot;https://github.com/pburtchaell/redux-promise-middleware&quot;&gt;redux-promise-middleware&lt;/a&gt; to dispatch Promises instead of functions.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/acdlite/redux-promise&quot;&gt;redux-promise&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/pburtchaell/redux-promise-middleware&quot;&gt;redux-promise-middleware&lt;/a&gt; 를 사용하여 기능 대신 약속을 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d98266f375d43672febffb46f3ed5355675dc5b" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;https://github.com/redux-observable/redux-observable&quot;&gt;redux-observable&lt;/a&gt; to dispatch Observables.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/redux-observable/redux-observable&quot;&gt;redux-observable&lt;/a&gt; 을 사용하여 Observable을 발송할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d9c266f69d53ba1763af2ada1d6653210151773" translate="yes" xml:space="preserve">
          <source>You can use Redux together with &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt;, or with any other view library.</source>
          <target state="translated">Redux를 &lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; 또는 다른 뷰 라이브러리와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28d3cd95f0d488448a63a6b338cb50068a95d5d9" translate="yes" xml:space="preserve">
          <source>You can use it at all levels of your reducer structure, not just to create the root reducer. It's very common to have multiple combined reducers in various places, which are composed together to create the root reducer.</source>
          <target state="translated">루트 감속기를 만드는 것이 아니라 모든 수준의 감속기 구조에서 사용할 수 있습니다. 루트 리듀서를 만들기 위해 함께 구성된 여러 장소에 여러 개의 결합 감속기를 갖는 것이 매우 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="490b5a07e2c5aad3ad0c9fd7a27a52665898f60e" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://github.com/lelandrichardson/redux-pack&quot;&gt;redux-pack&lt;/a&gt; middleware to dispatch promise-based asynchronous actions.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/lelandrichardson/redux-pack&quot;&gt;redux-pack&lt;/a&gt; 미들웨어를 사용하여 약속 기반 비동기 조치를 디스패치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df0e299c97c2207cdace456ccd47c72d8b63f087" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://github.com/yelouafi/redux-saga/&quot;&gt;redux-saga&lt;/a&gt; middleware to build more complex asynchronous actions.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/yelouafi/redux-saga/&quot;&gt;redux-saga&lt;/a&gt; 미들웨어를 사용하여보다 복잡한 비동기 조치를 빌드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2be61aa399225330ac3c7c8f8b6d9263d4b58435" translate="yes" xml:space="preserve">
          <source>You cannot mutate an immutable object; instead, you must mutate a copy of it, leaving the original intact.</source>
          <target state="translated">불변의 객체는 변경할 수 없습니다. 대신 원본을 그대로두고 복사본을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="9002cfc3dd43f6e0951811e8e815e8e77752e185" translate="yes" xml:space="preserve">
          <source>You could also give them different keys, or call functions differently. These two ways to write a combined reducer are equivalent:</source>
          <target state="translated">그들에게 다른 키를 주거나 기능을 다르게 호출 할 수도 있습니다. 결합 감속기를 작성하는이 두 가지 방법은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1be388744a3e109fec6dfea1a28f5eb27d9ed9a9" translate="yes" xml:space="preserve">
          <source>You could even go as far as to make a generic filtering higher-order reducer:</source>
          <target state="translated">일반 필터링을 고차 리듀서로 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e73413f8379bbd8e9bb56a500c7eb3c5f375e13" translate="yes" xml:space="preserve">
          <source>You do not need to use Immutable.JS with Redux. Plain JavaScript, if written correctly, is perfectly capable of providing immutability without having to use an immutable-focused library.</source>
          <target state="translated">Redux와 함께 Immutable.JS를 사용할 필요는 없습니다. 일반 JavaScript는 올바르게 작성된 경우 불변 중심 라이브러리를 사용하지 않고도 불변성을 완벽하게 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9581e0ed51066ff103253aa77beee1d1478416ea" translate="yes" xml:space="preserve">
          <source>You don't have to define action type constants in a separate file, or even to define them at all. For a small project, it might be easier to just use string literals for action types. However, there are some benefits to explicitly declaring constants in larger codebases. Read &lt;a href=&quot;../recipes/reducingboilerplate&quot;&gt;Reducing Boilerplate&lt;/a&gt; for more practical tips on keeping your codebase clean.</source>
          <target state="translated">별도의 파일에서 활동 유형 상수를 정의하거나 전혀 정의하지 않아도됩니다. 소규모 프로젝트의 경우 작업 유형에 문자열 리터럴을 사용하는 것이 더 쉬울 수 있습니다. 그러나 더 큰 코드베이스에서 상수를 명시 적으로 선언하면 몇 가지 이점이 있습니다. 코드베이스를 깨끗하게 유지하는 데 대한 실용적인 팁을 보려면 &lt;a href=&quot;../recipes/reducingboilerplate&quot;&gt;보일러 플레이트 줄이기를&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="199448d814bc5e9584035a52d2115857f50dad49" translate="yes" xml:space="preserve">
          <source>You have two reducers:</source>
          <target state="translated">두 개의 감속기가 있습니다.</target>
        </trans-unit>
        <trans-unit id="192eb5ae977897417943647ddbcb6a6f3d4104d2" translate="yes" xml:space="preserve">
          <source>You may call &lt;a href=&quot;#dispatch&quot;&gt;&lt;code&gt;dispatch()&lt;/code&gt;&lt;/a&gt; from a change listener, with the following caveats:</source>
          <target state="translated">다음과 같은 경고를 사용하여 변경 리스너에서 &lt;a href=&quot;#dispatch&quot;&gt; &lt;code&gt;dispatch()&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ebca9d5f96869ed296e545e937054edc0f8c94d" translate="yes" xml:space="preserve">
          <source>You may call &lt;code&gt;combineReducers&lt;/code&gt; at any level of the reducer hierarchy. It doesn't have to happen at the top. In fact you may use it again to split the child reducers that get too complicated into independent grandchildren, and so on.</source>
          <target state="translated">리듀서 계층의 모든 레벨에서 &lt;code&gt;combineReducers&lt;/code&gt; 를 호출 할 수 있습니다 . 맨 위에서 일어날 필요는 없습니다. 실제로 너무 복잡한 아동 감속기를 독립 손자 등으로 나누는 데 다시 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3644afb1fd9b1feb972c2dc856f2ca012f2fd6b3" translate="yes" xml:space="preserve">
          <source>You may enhance &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;../api/applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt;. It is not required, but it lets you &lt;a href=&quot;asyncactions&quot;&gt;express asynchronous actions in a convenient way&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../api/applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt; 를 향상시킬 수 있습니다 . 필수는 아니지만 &lt;a href=&quot;asyncactions&quot;&gt;편리한 방식으로 비동기 작업&lt;/a&gt; 을 표현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d912b7407f7325b0f1291dd95c400a5024e9614d" translate="yes" xml:space="preserve">
          <source>You may need to write some custom functions for handling some of these actions. This may require replacing &lt;code&gt;combineReducers&lt;/code&gt; with your own top-level reducer function. You can also use a utility such as &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;reduce-reducers&lt;/a&gt; to run &lt;code&gt;combineReducers&lt;/code&gt; to handle most actions, but also run a more specialized reducer for specific actions that cross state slices.</source>
          <target state="translated">이러한 조치 중 일부를 처리하기 위해 일부 사용자 정의 함수를 작성해야 할 수도 있습니다. 이로 인해 &lt;code&gt;combineReducers&lt;/code&gt; 를 고유 한 최상위 감속기 기능으로 교체해야 할 수도 있습니다. &lt;a href=&quot;https://github.com/acdlite/reduce-reducers&quot;&gt;reduce-reducers&lt;/a&gt; 와 같은 유틸리티를 사용하여 &lt;code&gt;combineReducers&lt;/code&gt; 를 실행 하여 대부분의 작업을 처리 할 수 ​​있지만 상태 조각을 가로 지르는 특정 작업에 대해보다 전문화 된 Reducer를 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="09059cc37b1193dbc15c30252c07daa76e286f64" translate="yes" xml:space="preserve">
          <source>You may optionally specify the initial state as the second argument to &lt;a href=&quot;../api/createstore&quot;&gt;&lt;code&gt;createStore()&lt;/code&gt;&lt;/a&gt;. This is useful for hydrating the state of the client to match the state of a Redux application running on the server.</source>
          <target state="translated">선택적으로 초기 상태를 &lt;a href=&quot;../api/createstore&quot;&gt; &lt;code&gt;createStore()&lt;/code&gt; &lt;/a&gt; 의 두 번째 인수로 지정할 수 있습니다 . 이는 서버에서 실행중인 Redux 애플리케이션의 상태와 일치하도록 클라이언트의 상태를 수화시키는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3ee0e53b45fb2fa831d9c837168e8230281cd9d8" translate="yes" xml:space="preserve">
          <source>You may use a dedicated &lt;code&gt;status&lt;/code&gt; field in your actions:</source>
          <target state="translated">작업에 전용 &lt;code&gt;status&lt;/code&gt; 필드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db87382954c55c5d2ee83adf7f38146a50266b8e" translate="yes" xml:space="preserve">
          <source>You may want to read &lt;a href=&quot;../advanced/asyncactions&quot;&gt;Async Actions&lt;/a&gt; to learn more about expressing asynchronous flow in Redux with async primitives such as Promises and thunks. Keep in mind that anything you learn there can also be applied to universal rendering.</source>
          <target state="translated">약속 및 썽크와 같은 비동기 기본 요소를 사용하여 Redux에서 비동기 플로우를 표시하는 방법에 대해 자세히 알아 보려면 &lt;a href=&quot;../advanced/asyncactions&quot;&gt;비동기 조치&lt;/a&gt; 를 읽으십시오 . 여기서 배우는 것은 보편적 인 렌더링에도 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec6c69e4ca4e0cce6a488148dc045be49daaf6a8" translate="yes" xml:space="preserve">
          <source>You may wrap one or more reducers in &lt;code&gt;undoable&lt;/code&gt; at any level of the reducer composition hierarchy. We choose to wrap &lt;code&gt;todos&lt;/code&gt; instead of the top-level combined reducer so that changes to &lt;code&gt;visibilityFilter&lt;/code&gt; are not reflected in the undo history.</source>
          <target state="translated">리듀서 구성 계층의 모든 수준 에서 하나 이상의 리듀서를 &lt;code&gt;undoable&lt;/code&gt; 할 수없는 상태로 래핑 할 수 있습니다 . &lt;code&gt;visibilityFilter&lt;/code&gt; 변경 사항 이 실행 취소 기록에 반영되지 않도록 최상위 결합 감속기 대신 &lt;code&gt;todos&lt;/code&gt; 을 래핑하도록 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="b5dbd93add81c61b1e16815b79f40079a123eba8" translate="yes" xml:space="preserve">
          <source>You might ask: why don't we bind the action creators to the store instance right away, like in classical Flux? The problem is that this won't work well with universal apps that need to render on the server. Most likely you want to have a separate store instance per request so you can prepare them with different data, but binding action creators during their definition means you're stuck with a single store instance for all requests.</source>
          <target state="translated">클래식 Flux처럼 액션 제작자를 스토어 인스턴스에 즉시 바인딩하지 않는 이유는 무엇입니까? 문제는 이것이 서버에서 렌더링해야하는 범용 앱에서 제대로 작동하지 않는다는 것입니다. 대부분의 경우 요청마다 별도의 상점 인스턴스를 갖고 싶어서 다른 데이터로 준비 할 수 있지만 정의 중에 조치 작성자를 바인딩하면 모든 요청에 ​​대해 단일 상점 인스턴스가 붙어 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2896f8f64f8c4e00e8362d43f027ff694ea34032" translate="yes" xml:space="preserve">
          <source>You might be familiar with &lt;a href=&quot;https://en.wikipedia.org/wiki/Higher-order_function&quot;&gt;higher order functions&lt;/a&gt;. If you use React, you might be familiar with &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;higher order components&lt;/a&gt;. Here is a variation on the same pattern, applied to reducers.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Higher-order_function&quot;&gt;고차 함수에&lt;/a&gt; 익숙 할 것 입니다. React를 사용하면 &lt;a href=&quot;https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750&quot;&gt;고차 컴포넌트에&lt;/a&gt; 익숙 할 수 있습니다 . 다음은 감속기에 적용되는 동일한 패턴의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="fc80378efa78f4250982b149969a4e4206388634" translate="yes" xml:space="preserve">
          <source>You might have heard that Redux was influenced by &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm Architecture&lt;/a&gt;. It shouldn't come as a surprise that this example is very similar to &lt;a href=&quot;http://package.elm-lang.org/packages/TheSeamau5/elm-undo-redo/2.0.0&quot;&gt;elm-undo-redo package&lt;/a&gt;.</source>
          <target state="translated">Redux가 &lt;a href=&quot;https://github.com/evancz/elm-architecture-tutorial/&quot;&gt;Elm Architecture의&lt;/a&gt; 영향을 받았다고 들었을 것입니다 . 이 예제가 &lt;a href=&quot;http://package.elm-lang.org/packages/TheSeamau5/elm-undo-redo/2.0.0&quot;&gt;elm-undo-redo package&lt;/a&gt; 와 매우 유사하다는 것은 놀라운 일이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="be8f897b9ef506870651387b41362b89ab366329" translate="yes" xml:space="preserve">
          <source>You might want to use it to apply several &lt;a href=&quot;../glossary#store-enhancer&quot;&gt;store enhancers&lt;/a&gt; in a row.</source>
          <target state="translated">이를 사용하여 여러 &lt;a href=&quot;../glossary#store-enhancer&quot;&gt;상점 향상&lt;/a&gt; 기를 연속 으로 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb8edb49caaa697733e02d643699b140e0476f6b" translate="yes" xml:space="preserve">
          <source>You might write an action creator in a separate file, and import it into your component:</source>
          <target state="translated">별도의 파일에 조치 작성자를 작성하여 컴포넌트로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5012c361d888ca9c67b230342b72327b08a9b0ab" translate="yes" xml:space="preserve">
          <source>You never see this, of course - the data you give to an Immutable.JS object is never mutated. Rather, it&amp;rsquo;s the &lt;em&gt;intermediate&lt;/em&gt; data generated within Immutable.JS from a chained sequence of method calls that is free to be mutated. You therefore get all the benefits of immutable data structures with none (or very little) of the potential performance hits.</source>
          <target state="translated">물론 이것을 볼 수는 없습니다-Immutable.JS 객체에 제공하는 데이터는 절대로 변경되지 않습니다. 오히려 Immutable.JS 내에서 생성 된 &lt;em&gt;중간&lt;/em&gt; 데이터이며 자유롭게 변경할 수있는 일련의 메소드 호출 시퀀스에서 생성됩니다. 따라서 잠재적 인 성능 저하가 거의 없거나 전혀없는 불변 데이터 구조의 모든 이점을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="536f6105b2c796a51f197bb3552df6076809a08a" translate="yes" xml:space="preserve">
          <source>You will need to wrap the reducer you wish to enhance with &lt;code&gt;undoable&lt;/code&gt; function. For example, if you exported a &lt;code&gt;todos&lt;/code&gt; reducer from a dedicated file, you will want to change it to export the result of calling &lt;code&gt;undoable()&lt;/code&gt; with the reducer you wrote:</source>
          <target state="translated">&lt;code&gt;undoable&lt;/code&gt; 기능 으로 강화하려는 감속기를 포장해야 합니다. 예를 들어, 전용 파일에서 &lt;code&gt;todos&lt;/code&gt; Reducer 를 내 보낸 경우 , 작성한 Reducer를 사용하여 &lt;code&gt;undoable()&lt;/code&gt; 호출 결과를 내보내도록이를 변경하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="0d71f702363520e8d52cd5cf66c6865dbac24253" translate="yes" xml:space="preserve">
          <source>You will probably want to remove the hash from the URL (e.g: &lt;code&gt;http://localhost:3000/#/?_k=4sbb0i&lt;/code&gt;). For doing this, you will need to also import &lt;code&gt;browserHistory&lt;/code&gt; from React Router:</source>
          <target state="translated">URL에서 해시를 제거하고 싶을 것입니다 (예 : &lt;code&gt;http://localhost:3000/#/?_k=4sbb0i&lt;/code&gt; ). 이를 위해 React Router에서 &lt;code&gt;browserHistory&lt;/code&gt; 도 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="847e7a43a897e6825651ba6a7171789bd4f8c993" translate="yes" xml:space="preserve">
          <source>You will use &lt;code&gt;connect()&lt;/code&gt; from &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;React Redux&lt;/a&gt; to generate a container component. To determine whether to enable Undo and Redo buttons, you can check &lt;code&gt;state.todos.past.length&lt;/code&gt; and &lt;code&gt;state.todos.future.length&lt;/code&gt;. You won't need to write action creators for performing undo and redo because Redux Undo already provides them:</source>
          <target state="translated">당신은 사용할 &lt;code&gt;connect()&lt;/code&gt; 에서이 &lt;a href=&quot;https://github.com/reactjs/react-redux&quot;&gt;돌아 오는 반응&lt;/a&gt; 컨테이너 구성 요소를 생성 할 수 있습니다. 실행 취소 및 다시 실행 버튼을 사용할지 여부를 결정하기 위해 &lt;code&gt;state.todos.past.length&lt;/code&gt; 및 &lt;code&gt;state.todos.future.length&lt;/code&gt; 를 확인할 수 있습니다 . Redux Undo가 이미 제공하기 때문에 실행 취소 및 재실행을 수행하기 위해 활동 작성자를 작성할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ced3f60087b9c7dc7b64e901bea63d5a41a88099" translate="yes" xml:space="preserve">
          <source>You would only use the named export for tests.</source>
          <target state="translated">테스트에는 명명 된 내보내기 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f002654c7b958bdea2528eaaa9c1e1ce5d2cfe9d" translate="yes" xml:space="preserve">
          <source>You'll know when you need Flux. If you aren't sure if you need it, you don't need it.</source>
          <target state="translated">플럭스가 필요할 때 알게 될 것입니다. 필요한지 확실하지 않으면 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e4884b4000a8d2ac41ed531bf7a37bd6a9faaa2" translate="yes" xml:space="preserve">
          <source>You'll often find that you need to store some data, as well as some UI state, in the state tree. This is fine, but try to keep the data separate from the UI state.</source>
          <target state="translated">상태 트리에 일부 데이터와 UI 상태를 저장해야하는 경우가 종종 있습니다. 이것은 좋지만 데이터를 UI 상태와 별도로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="483dc0e6baee4af78f1c3f12ab8f28dda9a34453" translate="yes" xml:space="preserve">
          <source>You've seen middleware in action in the &lt;a href=&quot;asyncactions&quot;&gt;Async Actions&lt;/a&gt; example. If you've used server-side libraries like &lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt; and &lt;a href=&quot;http://koajs.com/&quot;&gt;Koa&lt;/a&gt;, you were also probably already familiar with the concept of &lt;em&gt;middleware&lt;/em&gt;. In these frameworks, middleware is some code you can put between the framework receiving a request, and the framework generating a response. For example, Express or Koa middleware may add CORS headers, logging, compression, and more. The best feature of middleware is that it's composable in a chain. You can use multiple independent third-party middleware in a single project.</source>
          <target state="translated">&lt;a href=&quot;asyncactions&quot;&gt;비동기 작업&lt;/a&gt; 예제 에서 미들웨어가 작동하는 것을 보았습니다 . &lt;a href=&quot;http://expressjs.com/&quot;&gt;Express&lt;/a&gt; 및 &lt;a href=&quot;http://koajs.com/&quot;&gt;Koa&lt;/a&gt; 와 같은 서버 측 라이브러리를 사용한 경우 이미 &lt;em&gt;미들웨어&lt;/em&gt; 개념에 익숙했을 것입니다 . 이러한 프레임 워크에서 미들웨어는 요청을 수신하는 프레임 워크와 응답을 생성하는 프레임 워크 사이에 넣을 수있는 일부 코드입니다. 예를 들어 Express 또는 Koa 미들웨어는 CORS 헤더, 로깅, 압축 등을 추가 할 수 있습니다. 미들웨어의 가장 큰 특징은 체인으로 구성 할 수 있다는 것입니다. 단일 프로젝트에서 여러 개의 독립적 인 타사 미들웨어를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7028f3891ebf7e4827d5eaddfa0e16584b0b4466" translate="yes" xml:space="preserve">
          <source>Your dumb components should be pure; that is, they should produce the same output given the same input, and have no external dependencies. If you pass such a component an Immutable.JS object as a prop, you make it dependent upon Immutable.JS to extract the prop&amp;rsquo;s value and otherwise manipulate it.</source>
          <target state="translated">바보 같은 구성 요소는 순수해야합니다. 즉, 동일한 입력이 주어지면 동일한 출력을 생성해야하며 외부 종속성이 없어야합니다. 그러한 컴포넌트를 Immutable.JS 객체를 소품으로 전달하는 경우 Immutable.JS에 의존하여 소품의 값을 추출하고 그렇지 않으면 조작합니다.</target>
        </trans-unit>
        <trans-unit id="395dd2fb0c94aec217ae48791e24ace04816fc89" translate="yes" xml:space="preserve">
          <source>Your process will look like this:</source>
          <target state="translated">프로세스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b13a159884d03a53c5b0abbb9540e28b3419ef7" translate="yes" xml:space="preserve">
          <source>Your selectors should return Immutable.JS objects</source>
          <target state="translated">선택기는 Immutable.JS 객체를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="281e35c0465b8b3d761e36f053ead41086e72367" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;enhancer&lt;/code&gt;] &lt;em&gt;(Function)&lt;/em&gt;: The store enhancer. You may optionally specify it to enhance the store with third-party capabilities such as middleware, time travel, persistence, etc. The only store enhancer that ships with Redux is &lt;a href=&quot;applymiddleware&quot;&gt;&lt;code&gt;applyMiddleware()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">[ &lt;code&gt;enhancer&lt;/code&gt; ] &lt;em&gt;(기능)&lt;/em&gt; : 상점 인핸서. 미들웨어, 시간 여행, 지속성 등과 같은 써드 파티 기능으로 상점을 향상 시키도록 선택적으로 지정할 수 있습니다. Redux와 함께 제공되는 유일한 상점 향상제는 &lt;a href=&quot;applymiddleware&quot;&gt; &lt;code&gt;applyMiddleware()&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="87286375e4668a58823fba92d2b07b7a44fc0be4" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;preloadedState&lt;/code&gt;] &lt;em&gt;(any)&lt;/em&gt;: The initial state. You may optionally specify it to hydrate the state from the server in universal apps, or to restore a previously serialized user session. If you produced &lt;code&gt;reducer&lt;/code&gt; with &lt;a href=&quot;combinereducers&quot;&gt;&lt;code&gt;combineReducers&lt;/code&gt;&lt;/a&gt;, this must be a plain object with the same shape as the keys passed to it. Otherwise, you are free to pass anything that your &lt;code&gt;reducer&lt;/code&gt; can understand.</source>
          <target state="translated">[ &lt;code&gt;preloadedState&lt;/code&gt; ] &lt;em&gt;(any)&lt;/em&gt; : 초기 상태입니다. 선택적으로 범용 앱의 서버에서 상태를 수화하거나 이전에 직렬화 된 사용자 세션을 복원하도록 지정할 수 있습니다. 당신이 생산 된 경우 &lt;code&gt;reducer&lt;/code&gt; 와 &lt;a href=&quot;combinereducers&quot;&gt; &lt;code&gt;combineReducers&lt;/code&gt; &lt;/a&gt; ,이 전달 된 키와 같은 모양으로 일반 객체 여야합니다. 그렇지 않으면 &lt;code&gt;reducer&lt;/code&gt; 가 이해할 수있는 모든 것을 자유롭게 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c70c7e915a4a2b3601daa15f9ed309a470505e50" translate="yes" xml:space="preserve">
          <source>and configure it to use ES2015 features in &lt;code&gt;.babelrc&lt;/code&gt;:</source>
          <target state="translated">.babelrc에서 &lt;code&gt;.babelrc&lt;/code&gt; 기능을 사용하도록 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd3ab734b4fb4c62257230890e59143d0e998962" translate="yes" xml:space="preserve">
          <source>and pass it to the &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; in order to remove the hash from the URL:</source>
          <target state="translated">URL에서 해시를 제거하려면 &lt;code&gt;&amp;lt;Router /&amp;gt;&lt;/code&gt; 에 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f432ecbf9e6a7a5c1f170d992e60626ab120d96" translate="yes" xml:space="preserve">
          <source>and run &lt;code&gt;npm test&lt;/code&gt; to run it once, or &lt;code&gt;npm run test:watch&lt;/code&gt; to test on every file change.</source>
          <target state="translated">및 실행 &lt;code&gt;npm test&lt;/code&gt; 한 번 실행하거나하는 &lt;code&gt;npm run test:watch&lt;/code&gt; 시험에 모든 파일 변경에.</target>
        </trans-unit>
        <trans-unit id="f81edf81cd89734f8439987c58e09f5451875a46" translate="yes" xml:space="preserve">
          <source>and then pass the state along to the client.</source>
          <target state="translated">그런 다음 상태를 클라이언트에게 전달합니다.</target>
        </trans-unit>
        <trans-unit id="f3894228d526596c3cf53c57bbed5aae8b11537a" translate="yes" xml:space="preserve">
          <source>applyMiddleware()</source>
          <target state="translated">applyMiddleware()</target>
        </trans-unit>
        <trans-unit id="b6ad41cdd6bf4c2b18169a773d483861384cd204" translate="yes" xml:space="preserve">
          <source>applyMiddleware(...middleware)</source>
          <target state="translated">applyMiddleware(...middleware)</target>
        </trans-unit>
        <trans-unit id="7fedb9730abc492e1bcf1596264f044b04661aab" translate="yes" xml:space="preserve">
          <source>applyMiddleware(...middlewares)</source>
          <target state="translated">applyMiddleware(...middlewares)</target>
        </trans-unit>
        <trans-unit id="3f5c37526331395762baf88047f99e6d8b619f94" translate="yes" xml:space="preserve">
          <source>bindActionCreators()</source>
          <target state="translated">bindActionCreators()</target>
        </trans-unit>
        <trans-unit id="88e632a0686333c0fcc1b71ebd9b524a2ddd992d" translate="yes" xml:space="preserve">
          <source>bindActionCreators(actionCreators, dispatch)</source>
          <target state="translated">bindActionCreators (actionCreators, 디스패치)</target>
        </trans-unit>
        <trans-unit id="3042d6bd02c4ca7273effadee7e63bf42bed16c9" translate="yes" xml:space="preserve">
          <source>calls the appropriate reducer and passes it the slice;</source>
          <target state="translated">적절한 감속기를 호출하고 슬라이스를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="c3cf4ce11b3b5577a3871fe5b3cd80587b04a46c" translate="yes" xml:space="preserve">
          <source>can be tested like:</source>
          <target state="translated">다음과 같이 테스트 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="991b9417df7c9c174211ba006b7edc0195725286" translate="yes" xml:space="preserve">
          <source>combineReducers()</source>
          <target state="translated">combineReducers()</target>
        </trans-unit>
        <trans-unit id="50f164696008c84fbdf8d8f93fe6bbfa9b14e143" translate="yes" xml:space="preserve">
          <source>combineReducers(reducers)</source>
          <target state="translated">combineReducers(reducers)</target>
        </trans-unit>
        <trans-unit id="c8dc852570744e8e3067cca75ce9fe7af17afec8" translate="yes" xml:space="preserve">
          <source>compose()</source>
          <target state="translated">compose()</target>
        </trans-unit>
        <trans-unit id="5745a141fb4592e3d9eb885924e51235574f61c6" translate="yes" xml:space="preserve">
          <source>compose(...functions)</source>
          <target state="translated">compose(...functions)</target>
        </trans-unit>
        <trans-unit id="112d9f2631778cd8a08a4296c2ccbf312712f2b3" translate="yes" xml:space="preserve">
          <source>cpsubrian: React decorators for redux/react-router/immutable &amp;lsquo;smart&amp;rsquo; components</source>
          <target state="translated">cpsubrian : redux / react-router / immutable 'smart'컴포넌트를위한 React 데코레이터</target>
        </trans-unit>
        <trans-unit id="94ba045109577a1f4ae2fedc6ca6e16e7cec8d37" translate="yes" xml:space="preserve">
          <source>create a fresh, new Redux store instance on every request;</source>
          <target state="translated">모든 요청마다 새로운 Redux 스토어 인스턴스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b44915cfa2285ca11f257a840e99d4d3f28fc3a7" translate="yes" xml:space="preserve">
          <source>createStore()</source>
          <target state="translated">createStore()</target>
        </trans-unit>
        <trans-unit id="6ab01e2a484c9683cca2393d2ba3c93180699ee0" translate="yes" xml:space="preserve">
          <source>createStore(reducer, [preloadedState], [enhancer])</source>
          <target state="translated">createStore (reducer, [preloadedState], [enhancer])</target>
        </trans-unit>
        <trans-unit id="8fa33131b6a660bc8d77fd4bb48a66d021301526" translate="yes" xml:space="preserve">
          <source>creates a reference to the current state slice referred to by each key;</source>
          <target state="translated">각 키가 참조하는 현재 상태 슬라이스에 대한 참조를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="e3a4682977bb863d850d9eae5d719e2585e731e5" translate="yes" xml:space="preserve">
          <source>creates a reference to the possibly-mutated state slice that's returned by the reducer.</source>
          <target state="translated">리듀서에 의해 리턴 될 가능성이있는 상태 슬라이스에 대한 참조를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="280c1cc5f52574880ff013357b30094632bcbd78" translate="yes" xml:space="preserve">
          <source>dispatch(action)</source>
          <target state="translated">dispatch(action)</target>
        </trans-unit>
        <trans-unit id="b6e86cff86751f0236e17d84f44ac6dc44060213" translate="yes" xml:space="preserve">
          <source>for scale, we have ~500 action types, ~400 reducer cases, ~150 components, 5 middlewares, ~200 actions, ~2300 tests</source>
          <target state="translated">규모에는 ~ 500 개의 액션 유형, ~ 400 개의 리듀서 케이스, ~ 150 개의 구성 요소, 5 개의 미들웨어, ~ 200 개의 액션, ~ 2300 개의 테스트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fe375f56e9a0fa7dc88b61b3c4b3425c5636e79" translate="yes" xml:space="preserve">
          <source>getState()</source>
          <target state="translated">getState()</target>
        </trans-unit>
        <trans-unit id="5cffe5ee80305aeabc52048276f1acf872533639" translate="yes" xml:space="preserve">
          <source>is equivalent to this:</source>
          <target state="translated">이것과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="1c0bbc97bd6780fb3baf83d4730c736904a39e76" translate="yes" xml:space="preserve">
          <source>optionally dispatch some actions;</source>
          <target state="translated">선택적으로 일부 작업을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="e7916345e570f1bcf19d018b0792a5db68935506" translate="yes" xml:space="preserve">
          <source>pull the state out of store;</source>
          <target state="translated">상태를 상점에서 꺼내십시오.</target>
        </trans-unit>
        <trans-unit id="71ad63d785b9b9fdb536fac77ce747b9c5a69bc1" translate="yes" xml:space="preserve">
          <source>react-redux-jwt-auth-example</source>
          <target state="translated">react-redux-jwt-auth-example</target>
        </trans-unit>
        <trans-unit id="52295e92a7867dd2bf6e329dcebd064d09c14653" translate="yes" xml:space="preserve">
          <source>redux-immutable</source>
          <target state="translated">redux-immutable</target>
        </trans-unit>
        <trans-unit id="a88f184d5bfff1ab2b78bc41b8b30999ba677a10" translate="yes" xml:space="preserve">
          <source>replaceReducer(nextReducer)</source>
          <target state="translated">replaceReducer(nextReducer)</target>
        </trans-unit>
        <trans-unit id="9a9bbe4119c43d2a84a043196b4690c761b01d0a" translate="yes" xml:space="preserve">
          <source>subscribe(listener)</source>
          <target state="translated">subscribe(listener)</target>
        </trans-unit>
        <trans-unit id="26c8253fda7262249d6aacde189c2d069461b383" translate="yes" xml:space="preserve">
          <source>the keys &lt;code&gt;todos&lt;/code&gt; and &lt;code&gt;counter&lt;/code&gt; each refer to a separate state slice;</source>
          <target state="translated">키 &lt;code&gt;todos&lt;/code&gt; 과 &lt;code&gt;counter&lt;/code&gt; 각각은 별도의 상태 슬라이스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="afd2b6bf0fb616dda82e8ec1df11d135e0adf003" translate="yes" xml:space="preserve">
          <source>the values &lt;code&gt;myTodosReducer&lt;/code&gt; and &lt;code&gt;myCounterReducer&lt;/code&gt; are reducer functions, with each acting on the state slice identified by the respective key.</source>
          <target state="translated">&lt;code&gt;myTodosReducer&lt;/code&gt; 및 &lt;code&gt;myCounterReducer&lt;/code&gt; 값 은 각각의 키로 식별 된 상태 슬라이스에 각각 작용하는 감속기 함수입니다.</target>
        </trans-unit>
        <trans-unit id="365862a50c0682caa8baa6f30edca76e3e5f81ed" translate="yes" xml:space="preserve">
          <source>where:</source>
          <target state="translated">where:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
