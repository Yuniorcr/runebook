<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="07f99178b48153ac4d4332687d20d728a7c8bfd4" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2012-2019 Microsoft</source>
          <target state="translated">&amp;copy; 2012-2019 Microsoft</target>
        </trans-unit>
        <trans-unit id="3eb191ccf7512349b3d99757bc9535f48ae81c17" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Defaulted declarations&amp;rdquo; allow initializers that reference the declared name in the left side of a logical or:</source>
          <target state="translated">&amp;ldquo;Defaulted declarations&amp;rdquo; allow initializers that reference the declared name in the left side of a logical or:</target>
        </trans-unit>
        <trans-unit id="f1fdafe04dd11ea1809cd2cc0c324b66f3a11b35" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;Do&amp;rdquo;s and &amp;ldquo;Don&amp;rsquo;t&amp;rdquo;s</source>
          <target state="translated">&amp;ldquo;Do&amp;rdquo;s and &amp;ldquo;Don&amp;rsquo;t&amp;rdquo;s</target>
        </trans-unit>
        <trans-unit id="73d479e429a32f573b7b23a67a8995da08eed47d" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;classic&amp;rsquo; - module resolution rules used by pre 1.6 TypeScript compiler</source>
          <target state="translated">&amp;lsquo;classic&amp;rsquo; - module resolution rules used by pre 1.6 TypeScript compiler</target>
        </trans-unit>
        <trans-unit id="61c51288c27e2cc818fba1bd491d412143391547" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;node&amp;rsquo; - node-like module resolution</source>
          <target state="translated">&amp;lsquo;node&amp;rsquo; - node-like module resolution</target>
        </trans-unit>
        <trans-unit id="4547d63b41d1c75d2e1b5085da19d735e8dc595e" translate="yes" xml:space="preserve">
          <source>&amp;lsquo;package.json&amp;rsquo; has &lt;strong&gt;&amp;lsquo;types&amp;rsquo;&lt;/strong&gt; field &amp;lsquo;./lib/typescript.d.ts&amp;rsquo; that references &amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;.</source>
          <target state="translated">&amp;lsquo;package.json&amp;rsquo; has &lt;strong&gt;&amp;lsquo;types&amp;rsquo;&lt;/strong&gt; field &amp;lsquo;./lib/typescript.d.ts&amp;rsquo; that references &amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;.</target>
        </trans-unit>
        <trans-unit id="ee44c32e65bc4a9d7773f18d0e20e44810833a3f" translate="yes" xml:space="preserve">
          <source>&amp;lt;amd-dependency /&amp;gt;</source>
          <target state="translated">&amp;lt;amd-dependency /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="934f0cd8be7ed1f9b7b8079909795f738f732556" translate="yes" xml:space="preserve">
          <source>&amp;lt;amd-module /&amp;gt;</source>
          <target state="translated">&amp;lt;amd-module /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="cd4898dc828f34abf0dca9dabec02736d522eceb" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference lib=&amp;quot;...&amp;quot; /&amp;gt;</source>
          <target state="translated">&amp;lt;reference lib=&amp;quot;...&amp;quot; /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="62141bcfe5cfcd51fc1a320d36520899bc9edd5f" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference no-default-lib=&amp;quot;true&amp;quot;/&amp;gt;</source>
          <target state="translated">&amp;lt;reference no-default-lib=&amp;quot;true&amp;quot;/&amp;gt;</target>
        </trans-unit>
        <trans-unit id="21029c886af7dc459626422aa0c5b6ca11e413cb" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference path=&amp;quot;...&amp;quot; /&amp;gt;</source>
          <target state="translated">&amp;lt;reference path=&amp;quot;...&amp;quot; /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="120613f8d21d190c622bf610b91d69083361e489" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference types=&amp;quot;...&amp;quot; /&amp;gt;</source>
          <target state="translated">&amp;lt;reference types=&amp;quot;...&amp;quot; /&amp;gt;</target>
        </trans-unit>
        <trans-unit id="105733a69ca97c742b5246c8891283fb75ef628c" translate="yes" xml:space="preserve">
          <source>&amp;lt;reference&amp;gt;-ing a module</source>
          <target state="translated">&amp;lt;reference&amp;gt;-ing a module</target>
        </trans-unit>
        <trans-unit id="ccfac08210ff156925b259cf9224a7d62ab98fc8" translate="yes" xml:space="preserve">
          <source>(More) Recursive Type Aliases</source>
          <target state="translated">(More) Recursive Type Aliases</target>
        </trans-unit>
        <trans-unit id="32b244b1f4cdc07410d73db6d8271fb3aede63b0" translate="yes" xml:space="preserve">
          <source>*Note: You can specify the JSX factory function to use when targeting react JSX emit with &lt;code&gt;--jsxFactory&lt;/code&gt; option (defaults to &lt;code&gt;React.createElement&lt;/code&gt;)</source>
          <target state="translated">*Note: You can specify the JSX factory function to use when targeting react JSX emit with &lt;code&gt;--jsxFactory&lt;/code&gt; option (defaults to &lt;code&gt;React.createElement&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="bcac7464521b8c19a2372c739f6dc9e9ab7dfc80" translate="yes" xml:space="preserve">
          <source>.babelrc</source>
          <target state="translated">.babelrc</target>
        </trans-unit>
        <trans-unit id="bdbc9a553b902daccdcb974134663c5cbb048999" translate="yes" xml:space="preserve">
          <source>1 - greeting: Mandatory string</source>
          <target state="translated">1-인사말 : 필수 문자열</target>
        </trans-unit>
        <trans-unit id="13d790ef091c0d678928628f711d3a342ed79fdc" translate="yes" xml:space="preserve">
          <source>2 - duration: Optional length of time (in milliseconds)</source>
          <target state="translated">2-지속 시간 : 선택적 시간 길이 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="ecb356c6c25d42fb0b2006e35569ce371868ed08" translate="yes" xml:space="preserve">
          <source>3 - color: Optional string, e.g. &amp;lsquo;#ff00ff&amp;rsquo;</source>
          <target state="translated">3-색상 : 선택적 문자열 (예 : '# ff00ff'</target>
        </trans-unit>
        <trans-unit id="dd1f243849fa29b29355c96a02e0cba354d5a774" translate="yes" xml:space="preserve">
          <source>3.7 API Changes</source>
          <target state="translated">3.7 API 변경</target>
        </trans-unit>
        <trans-unit id="c2dbed9bb17a5c2fdd2db0b9dd5844f947a20c89" translate="yes" xml:space="preserve">
          <source>3.7 Breaking Changes</source>
          <target state="translated">3.7 주요 변경 사항</target>
        </trans-unit>
        <trans-unit id="f9d8d7d93cd113005d851de63f1e7f8b91e504d4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;As mentioned above&lt;/a&gt;, TypeScript 3.7 emits &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors in &lt;code&gt;.d.ts&lt;/code&gt; files which can cause breaking changes for consumers on older versions of TypeScript like 3.5 and prior. TypeScript 3.6 users will not be impacted, since that version was future-proofed for this feature.</source>
          <target state="translated">&lt;a href=&quot;#the-usedefineforclassfields-flag-and-the-declare-property-modifier&quot;&gt;위에서 언급했듯이&lt;/a&gt; TypeScript 3.7은 &lt;code&gt;.d.ts&lt;/code&gt; 파일 에 &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; 접근 자를 내 보냅니다 . 3.5 및 이전 버전과 같은 이전 버전의 TypeScript에서는 소비자에게 변경 사항을 적용 할 수 있습니다. 해당 버전은이 기능에 대해 향후 보장되므로 TypeScript 3.6 사용자에게는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b4fbbd23ecf68cc6d9a635cad72158cb53c80a0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects&quot;&gt;ES2015 also introduced &amp;ldquo;Generators&amp;rdquo;&lt;/a&gt;, which are functions that can be used to yield partial computation results via the &lt;code&gt;Iterator&lt;/code&gt; interface and the &lt;code&gt;yield&lt;/code&gt; keyword. Generators can also internally delegate calls to another iterable through &lt;code&gt;yield *&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-generatorfunction-objects&quot;&gt;ES2015는 또한 &lt;/a&gt; &lt;code&gt;Iterator&lt;/code&gt; 인터페이스와 &lt;code&gt;yield&lt;/code&gt; 키워드 를 통해 부분 계산 결과를 산출하는 데 사용할 수있는 함수 인 &quot;Generators&quot;를 도입했습니다 . 또한 생성기는 &lt;code&gt;yield *&lt;/code&gt; 를 통해 호출을 다른 iterable에 내부적으로 위임 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="55463e892e31113c861aadf5f93e77a57de6240a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-iteration&quot;&gt;ES2015 introduced &lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;, which is an object that exposes three methods, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;return&lt;/code&gt;, and &lt;code&gt;throw&lt;/code&gt;, as per the following interface:</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-iteration&quot;&gt;ES2015 &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; 는 다음 인터페이스에 따라 &lt;code&gt;next&lt;/code&gt; , &lt;code&gt;return&lt;/code&gt; 및 &lt;code&gt;throw&lt;/code&gt; 세 가지 메소드를 노출하는 객체 인 Iterator를 도입했습니다 .</target>
        </trans-unit>
        <trans-unit id="12aa33cea9b5a79c35ec84291696eb4b59f9da1e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/jsx/&quot;&gt;JSX&lt;/a&gt; is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, though the semantics of that transformation are implementation-specific. JSX rose to popularity with the &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; framework, but has since seen other implementations as well. TypeScript supports embedding, type checking, and compiling JSX directly to JavaScript.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/jsx/&quot;&gt;JSX&lt;/a&gt; 는 임베드 가능한 XML 유사 구문입니다. 변환의 의미는 구현에 따라 다르지만 유효한 JavaScript로 변환되어야합니다. JSX는 &lt;a href=&quot;https://reactjs.org/&quot;&gt;React&lt;/a&gt; 프레임 워크 로 인기를 얻었 지만 이후 다른 구현도 보았습니다. TypeScript는 포함, 유형 검사 및 JSX를 JavaScript로 직접 컴파일하는 것을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="4ef2642d51385f769ab651c082c9dff225d74fc2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33627&quot;&gt;Types in &lt;code&gt;lib.dom.d.ts&lt;/code&gt; have been updated&lt;/a&gt;. These changes are largely correctness changes related to nullability, but impact will ultimately depend on your codebase.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33627&quot;&gt; &lt;code&gt;lib.dom.d.ts&lt;/code&gt; 의 유형 이 업데이트되었습니다&lt;/a&gt; . 이러한 변경 사항은 주로 null 허용 여부와 관련된 정확성 변경이지만 영향은 궁극적으로 코드베이스에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="0495fdef653ac880036cca0814e7297d71236b4d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD modules&lt;/a&gt; check for the existence of a module loader environment. This is an easy-to-spot pattern that looks something like this:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD 모듈&lt;/a&gt; 은 모듈 로더 환경이 있는지 확인합니다. 이것은 다음과 같이 보이는 스팟 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="6fd7f9a4260cf4f7a8c5026d67e5c95d711d16e5" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;&lt;a href=&quot;#table-of-contents&quot;&gt;↥ back to top&lt;/a&gt;&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;a href=&quot;#table-of-contents&quot;&gt;↥ back to top&lt;/a&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fdbdf4e1369a70ccce916824139e46a9847d97a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;*&quot;&lt;/code&gt;: meaning the same name unchanged, so map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;*&quot;&lt;/code&gt;: meaning the same name unchanged, so map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c73a6525d7eaa4824134e5210d19e488e565b563" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;generated/*&quot;&lt;/code&gt; meaning the module name with an appended prefix &amp;ldquo;generated&amp;rdquo;, so map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/generated/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;generated/*&quot;&lt;/code&gt; meaning the module name with an appended prefix &amp;ldquo;generated&amp;rdquo;, so map &lt;code&gt;&amp;lt;moduleName&amp;gt;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;lt;baseUrl&amp;gt;/generated/&amp;lt;moduleName&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c85a37d09c2e1af4c5f31661b285d4d1e16f641" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;noImplicitAny&quot;&lt;/code&gt; is good idea whenever you&amp;rsquo;re writing new code &amp;mdash; you can make sure that you don&amp;rsquo;t write any untyped code by mistake. &lt;code&gt;&quot;compileOnSave&quot;&lt;/code&gt; makes it easy to update your code in a running web app.</source>
          <target state="translated">&lt;code&gt;&quot;noImplicitAny&quot;&lt;/code&gt; is good idea whenever you&amp;rsquo;re writing new code &amp;mdash; you can make sure that you don&amp;rsquo;t write any untyped code by mistake. &lt;code&gt;&quot;compileOnSave&quot;&lt;/code&gt; makes it easy to update your code in a running web app.</target>
        </trans-unit>
        <trans-unit id="fe58c3912d521e0998db0d63686a8a2d31499624" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; specify a list of &lt;em&gt;roots&lt;/em&gt; whose contents are expected to merge at run-time. So following our example, the &lt;code&gt;tsconfig.json&lt;/code&gt; file should look like:</source>
          <target state="translated">&lt;code&gt;&quot;rootDirs&quot;&lt;/code&gt; specify a list of &lt;em&gt;roots&lt;/em&gt; whose contents are expected to merge at run-time. So following our example, the &lt;code&gt;tsconfig.json&lt;/code&gt; file should look like:</target>
        </trans-unit>
        <trans-unit id="c7c3c22aa0fd78209c6c0e383e2528e7c6b4250d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;**/&lt;/code&gt; recursively matches any subdirectory</source>
          <target state="translated">&lt;code&gt;**/&lt;/code&gt; recursively matches any subdirectory</target>
        </trans-unit>
        <trans-unit id="5ff5a342935b5b9c3dc600fb9b3b727885179683" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;*&lt;/code&gt; matches zero or more characters (excluding directory separators)</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; matches zero or more characters (excluding directory separators)</target>
        </trans-unit>
        <trans-unit id="8eb69c784cbac9dae7012fa8bd2d7bd07b8c923b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; binary operators with constant enum expressions as operands</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; binary operators with constant enum expressions as operands</target>
        </trans-unit>
        <trans-unit id="7bc75f886336759e26741a1a438d89e2625db989" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--clean&lt;/code&gt;: Deletes the outputs of the specified projects (may be combined with &lt;code&gt;--dry&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;--clean&lt;/code&gt;: Deletes the outputs of the specified projects (may be combined with &lt;code&gt;--dry&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="d48e3154b28f82f1a4769c7208b3f989fff9e7b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--declaration&lt;/code&gt; and &lt;code&gt;--allowJs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--declaration&lt;/code&gt; and &lt;code&gt;--allowJs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fed49d4e6bfaaf71c24b3551301b4023896fbba9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--declarationDir&lt;/code&gt; allows for generating declaration files in a different location than JavaScript files.</source>
          <target state="translated">&lt;code&gt;--declarationDir&lt;/code&gt; allows for generating declaration files in a different location than JavaScript files.</target>
        </trans-unit>
        <trans-unit id="3a925ebadad3dc034212a013d96a8d028eec0d77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--dry&lt;/code&gt;: Shows what would be done but doesn&amp;rsquo;t actually build anything</source>
          <target state="translated">&lt;code&gt;--dry&lt;/code&gt;: Shows what would be done but doesn&amp;rsquo;t actually build anything</target>
        </trans-unit>
        <trans-unit id="391e7b99672708dcc5a82b9ab142640e75686d43" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--emitDeclarationOnly&lt;/code&gt; allows for &lt;em&gt;only&lt;/em&gt; generating declaration files; &lt;code&gt;.js&lt;/code&gt;/&lt;code&gt;.jsx&lt;/code&gt; output generation will be skipped with this flag. The flag is useful when the &lt;code&gt;.js&lt;/code&gt; output generation is handled by a different transpiler like Babel.</source>
          <target state="translated">&lt;code&gt;--emitDeclarationOnly&lt;/code&gt; allows for &lt;em&gt;only&lt;/em&gt; generating declaration files; &lt;code&gt;.js&lt;/code&gt;/&lt;code&gt;.jsx&lt;/code&gt; output generation will be skipped with this flag. The flag is useful when the &lt;code&gt;.js&lt;/code&gt; output generation is handled by a different transpiler like Babel.</target>
        </trans-unit>
        <trans-unit id="e68274530cc65ca1af4f49f4f5cff04720ac0248" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--emitDecoratorMetadata&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;--emitDecoratorMetadata&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="9fb3da74ef87ed6a6c5cc462731d82c9d0c65e88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--experimentalDecorators&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;--experimentalDecorators&lt;/code&gt;&lt;sup&gt;[1]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="d5a457b35b9491157c629e0302940182ccb5e23a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--force&lt;/code&gt;: Act as if all projects are out of date</source>
          <target state="translated">&lt;code&gt;--force&lt;/code&gt;: Act as if all projects are out of date</target>
        </trans-unit>
        <trans-unit id="89e0256ea12246cd1a53115a0051e97b7166b303" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--incremental&lt;/code&gt; improvements</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; improvements</target>
        </trans-unit>
        <trans-unit id="e2680bfd978e11406b01f962d148789dcac08317" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--init&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--init&lt;/code&gt; command line option</target>
        </trans-unit>
        <trans-unit id="99720ca96a5b0e0056f6395f275543d0ff913fad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--inlineSourceMap&lt;/code&gt; and &lt;code&gt;inlineSources&lt;/code&gt; command line options</source>
          <target state="translated">&lt;code&gt;--inlineSourceMap&lt;/code&gt; and &lt;code&gt;inlineSources&lt;/code&gt; command line options</target>
        </trans-unit>
        <trans-unit id="3c3e1a02d6406f9e0f2c99dcba3493dd92f9d8a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--inlineSourceMap&lt;/code&gt; causes source map files to be written inline in the generated &lt;code&gt;.js&lt;/code&gt; files instead of in a independent &lt;code&gt;.js.map&lt;/code&gt; file. &lt;code&gt;--inlineSources&lt;/code&gt; allows for additionally inlining the source &lt;code&gt;.ts&lt;/code&gt; file into the &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;--inlineSourceMap&lt;/code&gt; causes source map files to be written inline in the generated &lt;code&gt;.js&lt;/code&gt; files instead of in a independent &lt;code&gt;.js.map&lt;/code&gt; file. &lt;code&gt;--inlineSources&lt;/code&gt; allows for additionally inlining the source &lt;code&gt;.ts&lt;/code&gt; file into the &lt;code&gt;.js&lt;/code&gt; file.</target>
        </trans-unit>
        <trans-unit id="b5f213a09ff50e9dce71ecec1b24aff3aec8683c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--newLine&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--newLine&lt;/code&gt; command line option</target>
        </trans-unit>
        <trans-unit id="458f3a7228c6223004510906f46ddc5c2a2fd92d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--noEmitHelpers&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--noEmitHelpers&lt;/code&gt; command line option</target>
        </trans-unit>
        <trans-unit id="0312bee1e756b333574619a9dfc0a5e51d922e3b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--pretty&lt;/code&gt; output by default</source>
          <target state="translated">&lt;code&gt;--pretty&lt;/code&gt; output by default</target>
        </trans-unit>
        <trans-unit id="4cacd6ae5c910b5d011312b91818b43c8dbca3da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--rootDir&lt;/code&gt; command line option</source>
          <target state="translated">&lt;code&gt;--rootDir&lt;/code&gt; command line option</target>
        </trans-unit>
        <trans-unit id="ed17502152114f93d8a25c9ca4ba3c08cc11bea3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--rootDir&lt;/code&gt; specifies the input directory to be mirrored in output instead of computing it.</source>
          <target state="translated">&lt;code&gt;--rootDir&lt;/code&gt; specifies the input directory to be mirrored in output instead of computing it.</target>
        </trans-unit>
        <trans-unit id="ce69107c4ebefc8f6c4b27a523e9c10b6bac6045" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--strictNullChecks&lt;/code&gt; switches to a new strict null checking mode.</source>
          <target state="translated">&lt;code&gt;--strictNullChecks&lt;/code&gt; switches to a new strict null checking mode.</target>
        </trans-unit>
        <trans-unit id="0e169771b2b9f04c32856782076ccdc93237e692" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--target ESNext&lt;/code&gt; targets latest supported &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES proposed features&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;--target ESNext&lt;/code&gt; targets latest supported &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES proposed features&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="77f5b91bdc31f6e92780c04a56ba964c398b7284" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--traceResolution&lt;/code&gt; offers a handy way to understand how modules have been resolved by the compiler.</source>
          <target state="translated">&lt;code&gt;--traceResolution&lt;/code&gt; offers a handy way to understand how modules have been resolved by the compiler.</target>
        </trans-unit>
        <trans-unit id="73f407030ac0547dfee747a39b87fbd94ad60948" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--verbose&lt;/code&gt;: Prints out verbose logging to explain what&amp;rsquo;s going on (may be combined with any other flag)</source>
          <target state="translated">&lt;code&gt;--verbose&lt;/code&gt;: Prints out verbose logging to explain what&amp;rsquo;s going on (may be combined with any other flag)</target>
        </trans-unit>
        <trans-unit id="51fc8c433aeda1db44c3bcf0bd26afcf1442b203" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--watch&lt;/code&gt; implementation of the compiler relies on &lt;code&gt;fs.watch&lt;/code&gt; and &lt;code&gt;fs.watchFile&lt;/code&gt; provided by node, both of these methods have pros and cons.</source>
          <target state="translated">&lt;code&gt;--watch&lt;/code&gt; implementation of the compiler relies on &lt;code&gt;fs.watch&lt;/code&gt; and &lt;code&gt;fs.watchFile&lt;/code&gt; provided by node, both of these methods have pros and cons.</target>
        </trans-unit>
        <trans-unit id="38362bf60068a8fc03024f53bf3a560d68cb7a68" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;--watch&lt;/code&gt;: Watch mode (may not be combined with any flag except &lt;code&gt;--verbose&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;--watch&lt;/code&gt;: Watch mode (may not be combined with any flag except &lt;code&gt;--verbose&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="e3f3b3fa6bf342d93e8863e2d8e9e6b14addae36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-noEmitOnError&lt;/code&gt; commandline option</source>
          <target state="translated">&lt;code&gt;-noEmitOnError&lt;/code&gt; commandline option</target>
        </trans-unit>
        <trans-unit id="327baae57d533178e63d7b713f4cf4788b983059" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.js&lt;/code&gt; files are now allowed as input to &lt;code&gt;tsc&lt;/code&gt;. The TypeScript compiler checks the input &lt;code&gt;.js&lt;/code&gt; files for syntax errors, and emits valid output based on the &lt;code&gt;--target&lt;/code&gt; and &lt;code&gt;--module&lt;/code&gt; flags. The output can be combined with other &lt;code&gt;.ts&lt;/code&gt; files as well. Source maps are still generated for &lt;code&gt;.js&lt;/code&gt; files just like with &lt;code&gt;.ts&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; files are now allowed as input to &lt;code&gt;tsc&lt;/code&gt;. The TypeScript compiler checks the input &lt;code&gt;.js&lt;/code&gt; files for syntax errors, and emits valid output based on the &lt;code&gt;--target&lt;/code&gt; and &lt;code&gt;--module&lt;/code&gt; flags. The output can be combined with other &lt;code&gt;.ts&lt;/code&gt; files as well. Source maps are still generated for &lt;code&gt;.js&lt;/code&gt; files just like with &lt;code&gt;.ts&lt;/code&gt; files.</target>
        </trans-unit>
        <trans-unit id="03a3fca2c804aa362f9ea852d9bc2750659b10c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;.js&lt;/code&gt; files are still checked to ensure that they only include standard ECMAScript features; type annotations are only allowed in &lt;code&gt;.ts&lt;/code&gt; files and are flagged as errors in &lt;code&gt;.js&lt;/code&gt; files. JSDoc comments can be used to add some type information to your JavaScript code, see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript&quot;&gt;JSDoc Support documentation&lt;/a&gt; for more details about the supported JSDoc constructs.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; files are still checked to ensure that they only include standard ECMAScript features; type annotations are only allowed in &lt;code&gt;.ts&lt;/code&gt; files and are flagged as errors in &lt;code&gt;.js&lt;/code&gt; files. JSDoc comments can be used to add some type information to your JavaScript code, see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript&quot;&gt;JSDoc Support documentation&lt;/a&gt; for more details about the supported JSDoc constructs.</target>
        </trans-unit>
        <trans-unit id="90ab280d51b93fdaebf109f5c00c1bac5af53c79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;// @ts-nocheck&lt;/code&gt; in TypeScript Files</source>
          <target state="translated">&lt;code&gt;// @ts-nocheck&lt;/code&gt; in TypeScript Files</target>
        </trans-unit>
        <trans-unit id="ccc749b3637aaa4c3979a2d33edcfc503506cc3f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; informs the compiler about a non-TS module dependency that needs to be injected in the resulting module&amp;rsquo;s require call.</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; informs the compiler about a non-TS module dependency that needs to be injected in the resulting module&amp;rsquo;s require call.</target>
        </trans-unit>
        <trans-unit id="7288e5b9a9753f562fe49deb813afdbf0087fb3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; informs the compiler about a non-TS module dependency that needs to be injected in the resulting module&amp;rsquo;s require call; however, there was no way to consume this module in the TS code.</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;amd-dependency path=&quot;x&quot; /&amp;gt;&lt;/code&gt; informs the compiler about a non-TS module dependency that needs to be injected in the resulting module&amp;rsquo;s require call; however, there was no way to consume this module in the TS code.</target>
        </trans-unit>
        <trans-unit id="9eece5866a10ade200011770d30646176a0b7c17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;reference lib=&quot;...&quot; /&amp;gt;&lt;/code&gt; reference directives</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;reference lib=&quot;...&quot; /&amp;gt;&lt;/code&gt; reference directives</target>
        </trans-unit>
        <trans-unit id="68be6d84b0a2fdf1d5f2d8454eb02fa9cc63bc19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt;-ing a module</source>
          <target state="translated">&lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt;-ing a module</target>
        </trans-unit>
        <trans-unit id="091d09657c7b31c654b189dcd1f225f1a0ec984a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</target>
        </trans-unit>
        <trans-unit id="20ea10290a23b3740565e936d91702057ff37372" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</target>
        </trans-unit>
        <trans-unit id="9df7b034b6621c779b27d7c4dc7f558da205013a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</target>
        </trans-unit>
        <trans-unit id="4296e7cb4bf2356c30d2093a8e9404e55c92de63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</target>
        </trans-unit>
        <trans-unit id="ef30e25aeff39df1c13b00397846be84602cf411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</target>
        </trans-unit>
        <trans-unit id="98c853cb66dcb5dc8bcd3d05b08df126aa012e02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; property)</target>
        </trans-unit>
        <trans-unit id="5253ab85bf2484b7491317cdace822fde2760762" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</source>
          <target state="translated">&lt;code&gt;/root/src/node_modules/moduleB/package.json&lt;/code&gt; (if it specifies a &lt;code&gt;&quot;types&quot;&lt;/code&gt; property)</target>
        </trans-unit>
        <trans-unit id="69dd5451af8cbefbfd16c53fcdb71cc3040ab929" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?&lt;/code&gt; matches any one character (excluding directory separators)</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; matches any one character (excluding directory separators)</target>
        </trans-unit>
        <trans-unit id="510d9eec82bb462d81447db0531174b45f1b80bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@callback&lt;/code&gt; is similar to &lt;code&gt;@typedef&lt;/code&gt;, but it specifies a function type instead of an object type:</source>
          <target state="translated">&lt;code&gt;@callback&lt;/code&gt; is similar to &lt;code&gt;@typedef&lt;/code&gt;, but it specifies a function type instead of an object type:</target>
        </trans-unit>
        <trans-unit id="15e4ec66e698eca8fcacc4aef3b4a8740b21ad83" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@class&lt;/code&gt; (or &lt;code&gt;@constructor&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@class&lt;/code&gt; (or &lt;code&gt;@constructor&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="a9cd9b641abd25c6590bb4318e0d96edab2387c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@extends&lt;/code&gt; (or &lt;code&gt;@augments&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@extends&lt;/code&gt; (or &lt;code&gt;@augments&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="1b149f9a357b0a3ec024cce9f5c3dc2328ec70cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; (or &lt;code&gt;@arg&lt;/code&gt; or &lt;code&gt;@argument&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; (or &lt;code&gt;@arg&lt;/code&gt; or &lt;code&gt;@argument&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="f17c616498694e2538a5c3a14034458ed215aaf0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; allows a similar syntax for one-off type specifications. Note that the nested property names must be prefixed with the name of the parameter:</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; allows a similar syntax for one-off type specifications. Note that the nested property names must be prefixed with the name of the parameter:</target>
        </trans-unit>
        <trans-unit id="dd0e55fe627686baab0559a9cdef55576fc8bd55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; and &lt;code&gt;@returns&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; and &lt;code&gt;@returns&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7336752ac090f78d34c3d11b1ab23f55bc10fd2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@param&lt;/code&gt; uses the same type syntax as &lt;code&gt;@type&lt;/code&gt;, but adds a parameter name. The parameter may also be declared optional by surrounding the name with square brackets:</source>
          <target state="translated">&lt;code&gt;@param&lt;/code&gt; uses the same type syntax as &lt;code&gt;@type&lt;/code&gt;, but adds a parameter name. The parameter may also be declared optional by surrounding the name with square brackets:</target>
        </trans-unit>
        <trans-unit id="58bf6cf80df0aa9192ae7829c488911d16a03ac6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@returns&lt;/code&gt; (or &lt;code&gt;@return&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;@returns&lt;/code&gt; (or &lt;code&gt;@return&lt;/code&gt;)</target>
        </trans-unit>
        <trans-unit id="e9b067c8654340c958784799626e7b4c6447e4ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@type&lt;/code&gt; can specify a union type &amp;mdash; for example, something can be either a string or a boolean.</source>
          <target state="translated">&lt;code&gt;@type&lt;/code&gt; can specify a union type &amp;mdash; for example, something can be either a string or a boolean.</target>
        </trans-unit>
        <trans-unit id="6370c9d00688eca8044b474975739ec7c282690c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@typedef&lt;/code&gt; may be used to define complex types. Similar syntax works with &lt;code&gt;@param&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@typedef&lt;/code&gt; may be used to define complex types. Similar syntax works with &lt;code&gt;@param&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="5d98ac31d277f8f7a055ef6892de9b33cd522d19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@typedef&lt;/code&gt;, &lt;code&gt;@callback&lt;/code&gt;, and &lt;code&gt;@param&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@typedef&lt;/code&gt;, &lt;code&gt;@callback&lt;/code&gt;, and &lt;code&gt;@param&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ea9a050b838e7b222925bd33fe2491686e61638" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@types&lt;/code&gt;, &lt;code&gt;typeRoots&lt;/code&gt; and &lt;code&gt;types&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@types&lt;/code&gt;, &lt;code&gt;typeRoots&lt;/code&gt; and &lt;code&gt;types&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50cd5cdee6eaf1adbc6e1a7075eb9ed268b7c53d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AMD&lt;/code&gt;, &lt;code&gt;CommonJs&lt;/code&gt;, &lt;code&gt;UMD&lt;/code&gt;, &lt;code&gt;System&lt;/code&gt; or &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;AMD&lt;/code&gt; , &lt;code&gt;CommonJs&lt;/code&gt; , &lt;code&gt;UMD&lt;/code&gt; , &lt;code&gt;System&lt;/code&gt; 또는 &lt;code&gt;ES6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0dd47ffe31f15f736868359790118558f4c90d54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CRLF&lt;/code&gt; or &lt;code&gt;LF&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;CRLF&lt;/code&gt; 또는 &lt;code&gt;LF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e18a27ec845bd07bc4bd92bd5a9491158c764b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Classic&lt;/code&gt; or &lt;code&gt;Node&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Classic&lt;/code&gt; 또는 &lt;code&gt;Node&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a55b3dc1847df4cc22875b738b3f0488ec130264" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ES3&lt;/code&gt;, &lt;code&gt;ES5&lt;/code&gt;, or &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ES3&lt;/code&gt; , &lt;code&gt;ES5&lt;/code&gt; 또는 &lt;code&gt;ES6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1c84b65c2899e07c2577094ba71268f82bb4348" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Exclude&amp;lt;T, U&amp;gt;&lt;/code&gt; &amp;ndash; Exclude from &lt;code&gt;T&lt;/code&gt; those types that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Exclude&amp;lt;T, U&amp;gt;&lt;/code&gt; -에서 제외 &lt;code&gt;T&lt;/code&gt; 에 할당 할 수 있습니다 그 유형 &lt;code&gt;U&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="37b118234127720a534c99dc56aab386dafc6292" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Extract&amp;lt;T, U&amp;gt;&lt;/code&gt; &amp;ndash; Extract from &lt;code&gt;T&lt;/code&gt; those types that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Extract&amp;lt;T, U&amp;gt;&lt;/code&gt; -에서 추출 &lt;code&gt;T&lt;/code&gt; 에 할당 할 수 있습니다 그 유형 &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="731cd2078eec18fd1721cd773e8793bd578bbbb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;InstanceType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Obtain the instance type of a constructor function type.</source>
          <target state="translated">&lt;code&gt;InstanceType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; 생성자 함수 유형의 인스턴스 유형을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9f4f46cf1c3e00a0668406b1af262c9ac954f250" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MapToPromise&lt;/code&gt; takes a type &lt;code&gt;T&lt;/code&gt;, and when that type is a tuple like &lt;code&gt;Coordinate&lt;/code&gt;, only the numeric properties are converted. In &lt;code&gt;[number, number]&lt;/code&gt;, there are two numerically named properties: &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. When given a tuple like that, &lt;code&gt;MapToPromise&lt;/code&gt; will create a new tuple where the &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; properties are &lt;code&gt;Promise&lt;/code&gt;s of the original type. So the resulting type &lt;code&gt;PromiseCoordinate&lt;/code&gt; ends up with the type &lt;code&gt;[Promise&amp;lt;number&amp;gt;, Promise&amp;lt;number&amp;gt;]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MapToPromise&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 유형을 사용하며 해당 유형이 &lt;code&gt;Coordinate&lt;/code&gt; 와 같은 튜플 인 경우 숫자 속성 만 변환됩니다. 에서는 &lt;code&gt;[number, number]&lt;/code&gt; : 두 숫자라는 성질이있다 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; . 이와 같은 튜플이 주어지면 &lt;code&gt;MapToPromise&lt;/code&gt; 는 &lt;code&gt;0&lt;/code&gt; 및 &lt;code&gt;1&lt;/code&gt; 속성이 원래 유형의 &lt;code&gt;Promise&lt;/code&gt; 인 새 튜플을 만듭니다 . 따라서 결과 유형 &lt;code&gt;PromiseCoordinate&lt;/code&gt; 는 &lt;code&gt;[Promise&amp;lt;number&amp;gt;, Promise&amp;lt;number&amp;gt;]&lt;/code&gt; 유형으로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="3876e328c2a892ca260659a39ae1af62fabdd14a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Microsoft.TypeScript.Compiler&lt;/code&gt;: Tools only (&lt;code&gt;tsc.exe&lt;/code&gt;, &lt;code&gt;lib.d.ts&lt;/code&gt;, etc.) .</source>
          <target state="translated">&lt;code&gt;Microsoft.TypeScript.Compiler&lt;/code&gt; : 도구 만 ( &lt;code&gt;tsc.exe&lt;/code&gt; , &lt;code&gt;lib.d.ts&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="50b10a71485a17634b805b9bf6d4a114d9b8719e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt;: Tools as above, as well as MSBuild tasks and targets (&lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt;, &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt;, etc.)</source>
          <target state="translated">&lt;code&gt;Microsoft.TypeScript.MSBuild&lt;/code&gt; : 위와 같은 도구와 MSBuild 작업 및 대상 ( &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; , &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="754f9ca6c2a9d6b75591a792a94899f3972d0dcd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NonNullable&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Exclude &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NonNullable&amp;lt;T&amp;gt;&lt;/code&gt; - 제외 &lt;code&gt;null&lt;/code&gt; 하고 &lt;code&gt;undefined&lt;/code&gt; 에서 &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcae45288d3d0341f00e5f0a0c1e04f55875a283" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt; and &lt;code&gt;Object&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Boolean&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; 및 &lt;code&gt;Object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e7ab4b2b1efc56a0da6b2f789333b4eeca92f504" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.defineProperty&lt;/code&gt; declarations in JavaScript</source>
          <target state="translated">&lt;code&gt;Object.defineProperty&lt;/code&gt; JavaScript의 Object.defineProperty 선언</target>
        </trans-unit>
        <trans-unit id="516acae2c43a860256900e06b27f3de21816c8f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Partial&lt;/code&gt; and &lt;code&gt;Readonly&lt;/code&gt;, as described earlier, are very useful constructs. You can use them to describe some common JS routines like:</source>
          <target state="translated">&lt;code&gt;Partial&lt;/code&gt; 앞에서 설명한 것처럼 Partial 및 &lt;code&gt;Readonly&lt;/code&gt; 는 매우 유용한 구성입니다. 이를 사용하여 다음과 같은 일반적인 JS 루틴을 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c5fb5be503d3cc99bc3891aa2f666671d256ce9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Partial&lt;/code&gt;, &lt;code&gt;Readonly&lt;/code&gt;, &lt;code&gt;Record&lt;/code&gt;, and &lt;code&gt;Pick&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Partial&lt;/code&gt; , &lt;code&gt;Readonly&lt;/code&gt; , &lt;code&gt;Record&lt;/code&gt; 및 &lt;code&gt;Pick&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b9dce20c8a5593c22349b662be93f751022e541" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Readonly&lt;/code&gt;, &lt;code&gt;Partial&lt;/code&gt; and &lt;code&gt;Pick&lt;/code&gt; are homomorphic whereas &lt;code&gt;Record&lt;/code&gt; is not. One clue that &lt;code&gt;Record&lt;/code&gt; is not homomorphic is that it doesn&amp;rsquo;t take an input type to copy properties from:</source>
          <target state="translated">&lt;code&gt;Readonly&lt;/code&gt; , &lt;code&gt;Partial&lt;/code&gt; 및 &lt;code&gt;Pick&lt;/code&gt; 은 동형이지만 &lt;code&gt;Record&lt;/code&gt; 는 그렇지 않습니다. &lt;code&gt;Record&lt;/code&gt; 가 동형이 아닌 한 가지 단서는 속성을 복사하기 위해 입력 유형을 사용하지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e7f09457e713627cb3ff92a240363946a791f063" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ReturnType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; Obtain the return type of a function type.</source>
          <target state="translated">&lt;code&gt;ReturnType&amp;lt;T&amp;gt;&lt;/code&gt; &amp;ndash; 함수 유형의 반환 유형을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="77a86605355daf9f91784a6e95367936d4e082b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abstract&lt;/code&gt; classes and methods</source>
          <target state="translated">&lt;code&gt;abstract&lt;/code&gt; 클래스와 메소드</target>
        </trans-unit>
        <trans-unit id="6b9f50e030bc7a5ce9cb5b43dfb74328d401c7c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;any&lt;/code&gt;, &lt;code&gt;Object&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; , &lt;code&gt;Object&lt;/code&gt; 및 &lt;code&gt;{}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7ed5d892c6e6d7a97395e1de27bc299c07f918b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;asserts condition&lt;/code&gt; says that whatever gets passed into the &lt;code&gt;condition&lt;/code&gt; parameter must be true if the &lt;code&gt;assert&lt;/code&gt; returns (because otherwise it would throw an error). That means that for the rest of the scope, that condition must be truthy. As an example, using this assertion function means we &lt;em&gt;do&lt;/em&gt; catch our original &lt;code&gt;yell&lt;/code&gt; example.</source>
          <target state="translated">&lt;code&gt;asserts condition&lt;/code&gt; 은 &lt;code&gt;assert&lt;/code&gt; 가 리턴 되면 &lt;code&gt;condition&lt;/code&gt; 매개 변수 로 전달되는 모든 것이 참이어야 한다고 말합니다 (그렇지 않으면 오류가 발생 함). 그것은 나머지 범위에 대해 그 조건이 진실해야 함을 의미합니다. 예를 들어,이 주장 기능 수단을 사용하여 우리가 &lt;em&gt;할&lt;/em&gt; 우리의 원래 잡을 &lt;code&gt;yell&lt;/code&gt; 예.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d81ac1481d5d350948454eb43f231d3dccd6195" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt; support in ES6 targets (Node v4+)</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; ES6 대상에서 비동기 / 지원 &lt;code&gt;await&lt;/code&gt; (노드 v4 +)</target>
        </trans-unit>
        <trans-unit id="05b0a7f614edcf50ca6da583f1bb124c1000c419" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compose&lt;/code&gt; takes two other functions:</source>
          <target state="translated">&lt;code&gt;compose&lt;/code&gt; 는 다른 두 가지 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a6f6815f367db078217340961910eed3f0c7f8e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;compose&lt;/code&gt; then returns a function which feeds its argument through &lt;code&gt;f&lt;/code&gt; and then &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;compose&lt;/code&gt; 그런 다음 compose 는 &lt;code&gt;f&lt;/code&gt; 와 &lt;code&gt;g&lt;/code&gt; 를 통해 인수를 제공하는 함수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cb41a6e05b71eb6e7a7f237a3f9d9323ff52b694" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs/base.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;configs/base.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="f321739617311f53c301a43c80e999c6085eb60a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const enum&lt;/code&gt; (completely inlined enums)</source>
          <target state="translated">&lt;code&gt;const enum&lt;/code&gt; (완전히 인라인 된 열거 형)</target>
        </trans-unit>
        <trans-unit id="7e3ba5db3958314705ea44cd88cec272faaabfcb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; assertions</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 어설 션</target>
        </trans-unit>
        <trans-unit id="012e49b5b90ab3812ce5d5459abd13d8a1d9c849" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 선언</target>
        </trans-unit>
        <trans-unit id="fe167491a7d42fefa52129b16e1e621a2c31788a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; declarations are another way of declaring variables.</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 선언은 변수를 선언하는 또 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f88c4d09927f47dc36c60e05f8c607beb8cd93c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; enums</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 열거 형</target>
        </trans-unit>
        <trans-unit id="70efaa5f183560f377cb84a1789fe0834b27d50e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;const&lt;/code&gt; is only available when targeting ECMAScript 6 (&lt;code&gt;--target ES6&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;const&lt;/code&gt; 는 ECMAScript 6 ( &lt;code&gt;--target ES6&lt;/code&gt; )을 대상으로하는 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01ad1e1356fede9b7c214d93508aae720dfa9cb1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declaration&lt;/code&gt; must be turned on</source>
          <target state="translated">&lt;code&gt;declaration&lt;/code&gt; 이 켜져 있어야합니다</target>
        </trans-unit>
        <trans-unit id="1401dfdf98b767d48685797471067283cd20a8d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;declarationMap&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;declarationMap&lt;/code&gt;s</target>
        </trans-unit>
        <trans-unit id="70f1caf45465e3b2f9b33169a10a4b2656de7399" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; exports are really handy. For instance, a library like jQuery might have a default export of &lt;code&gt;jQuery&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt;, which we&amp;rsquo;d probably also import under the name &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;jQuery&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 내보내기는 정말 편리합니다. 예를 들어, jQuery와 같은 라이브러리는 &lt;code&gt;jQuery&lt;/code&gt; 또는 &lt;code&gt;$&lt;/code&gt; 의 기본 내보내기를 가질 수 있으며 &lt;code&gt;$&lt;/code&gt; 또는 &lt;code&gt;jQuery&lt;/code&gt; 라는 이름으로 가져올 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30f55dfa5aca95ffd4b7a09bd7b9cc8eb2fadbc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt; exports can also be just values:</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 내보내기는 값일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc8b5fd9f825e6be680dd3514510f69b4616113c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exclude&lt;/code&gt; property support in tsconfig.json</source>
          <target state="translated">&lt;code&gt;exclude&lt;/code&gt; tsconfig.json에서 특성 지원 제외</target>
        </trans-unit>
        <trans-unit id="4c9db716df5a416c78cae480a101fb21ea1e7a5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export *&lt;/code&gt; can be used to re-export all exports of another module. This is useful for creating modules that aggregate the exports of several other modules.</source>
          <target state="translated">&lt;code&gt;export *&lt;/code&gt; 는 다른 모듈의 모든 내보내기를 다시 내보내는 데 사용할 수 있습니다. 이는 여러 다른 모듈의 내보내기를 집계하는 모듈을 작성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6e636e798459cbffd9da7324b94596ca1840bafd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;export =&lt;/code&gt; and &lt;code&gt;import = require()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;export =&lt;/code&gt; 및 &lt;code&gt;import = require()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3d288a4c439ec79c9f01ed90667a909f760945ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extends&lt;/code&gt; is a new top-level property in &lt;code&gt;tsconfig.json&lt;/code&gt; (alongside &lt;code&gt;compilerOptions&lt;/code&gt;, &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt;, and &lt;code&gt;exclude&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 는 &lt;code&gt;tsconfig.json&lt;/code&gt; 의 새로운 최상위 속성입니다 ( &lt;code&gt;compilerOptions&lt;/code&gt; , &lt;code&gt;files&lt;/code&gt; , &lt;code&gt;include&lt;/code&gt; 및 &lt;code&gt;exclude&lt;/code&gt; 와 함께 ).</target>
        </trans-unit>
        <trans-unit id="9840158488dc62fdaa3cb62b51c0e8858b5791cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;f&lt;/code&gt; which takes some argument (of type &lt;code&gt;A&lt;/code&gt;) and returns a value of type &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 형 의 인수를 취해 &lt;code&gt;B&lt;/code&gt; 형의 값을 돌려줍니다</target>
        </trans-unit>
        <trans-unit id="f44df04333c301a58f9a4eb14df232200a4137e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;files&lt;/code&gt;, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; from the inheriting config file &lt;em&gt;overwrite&lt;/em&gt; those from the base config file.</source>
          <target state="translated">&lt;code&gt;files&lt;/code&gt; , &lt;code&gt;include&lt;/code&gt; 및 &lt;code&gt;exclude&lt;/code&gt; 상속하는 config 파일에서 &lt;em&gt;덮어 쓰기&lt;/em&gt; 의 기본 설정 파일에서 그.</target>
        </trans-unit>
        <trans-unit id="dbea6b2144138c02935bdf65a3a5978cc7d89931" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; loops over an iterable object, invoking the &lt;code&gt;Symbol.iterator&lt;/code&gt; property on the object. Here is a simple &lt;code&gt;for..of&lt;/code&gt; loop on an array:</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; 는 반복 가능한 객체를 반복 하여 객체 에서 &lt;code&gt;Symbol.iterator&lt;/code&gt; 속성을 호출 합니다. 다음은 배열 의 간단한 &lt;code&gt;for..of&lt;/code&gt; 루프입니다.</target>
        </trans-unit>
        <trans-unit id="e95fe318c23178a301fc252f057ad04a9fae6f4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; statements</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; 문</target>
        </trans-unit>
        <trans-unit id="12a8de33c0d1e331511a9ec2641ee2219e3cc903" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; statements, Array Destructuring, and Spread elements in Array, Call, and New expressions support &lt;code&gt;Symbol.iterator&lt;/code&gt; in ES5/E3 if available when using &lt;code&gt;--downlevelIteration&lt;/code&gt;, but can be used on an Array even if it does not define &lt;code&gt;Symbol.iterator&lt;/code&gt; at run time or design time.</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; 문, 배열 Destructuring 및 배열에 확산 요소, 전화, 그리고 새로운 표현을 지원 &lt;code&gt;Symbol.iterator&lt;/code&gt; 를 사용할 때 가능한 경우 ES5 / E3에서 &lt;code&gt;--downlevelIteration&lt;/code&gt; 을 하지만 정의하지 않는 경우에도 배열에서 사용할 수있는 &lt;code&gt;Symbol.iterator&lt;/code&gt; 런타임 또는 디자인 타임에 .iterator</target>
        </trans-unit>
        <trans-unit id="8fb526d1bc7349c8b0a3895b057b40322758bab4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for..of&lt;/code&gt; vs. &lt;code&gt;for..in&lt;/code&gt; statements</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; 대 &lt;code&gt;for..in&lt;/code&gt; 문</target>
        </trans-unit>
        <trans-unit id="8cf252545f201f3e3088e9c25cd8f91ad011a692" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fs.watch&lt;/code&gt; uses file system events to notify the changes in the file/directory. But this is OS dependent and the notification is not completely reliable and does not work as expected on many OS. Also there could be limit on number of watches that can be created, eg. linux and we could exhaust it pretty quickly with programs that include large number of files. But because this uses file system events, there is not much CPU cycle involved. Compiler typically uses &lt;code&gt;fs.watch&lt;/code&gt; to watch directories (eg. source directories included by config file, directories in which module resolution failed etc) These can handle the missing precision in notifying about the changes. But recursive watching is supported on only Windows and OSX. That means we need something to replace the recursive nature on other OS.</source>
          <target state="translated">&lt;code&gt;fs.watch&lt;/code&gt; 는 파일 시스템 이벤트를 사용하여 파일 / 디렉토리의 변경 사항을 알립니다. 그러나 이것은 OS에 따라 다르며 알림이 완전히 신뢰할 수 없으며 많은 OS에서 예상대로 작동하지 않습니다. 또한 만들 수있는 시계 수에 제한이있을 수 있습니다. 리눅스와 우리는 많은 파일을 포함하는 프로그램으로 꽤 빨리 고갈시킬 수 있습니다. 그러나 이것은 파일 시스템 이벤트를 사용하기 때문에 CPU주기가 많지 않습니다. 컴파일러는 일반적으로 &lt;code&gt;fs.watch&lt;/code&gt; 를 사용 하여 디렉토리 (예 : 구성 파일에 포함 된 소스 디렉토리, 모듈 확인에 실패한 디렉토리 등)를 감시합니다. 이들은 변경 사항을 알리는 데 누락 된 정밀도를 처리 할 수 ​​있습니다. 그러나 재귀 시청은 Windows 및 OSX에서만 지원됩니다. 즉, 다른 OS의 재귀 적 특성을 대체 할 무언가가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ea889051fa717ee536ad67479b6a78c0ea9610ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fs.watchFile&lt;/code&gt; uses polling and thus involves CPU cycles. But this is the most reliable mechanism to get the update on the status of file/directory. Compiler typically uses &lt;code&gt;fs.watchFile&lt;/code&gt; to watch source files, config files and missing files (missing file references) that means the CPU usage depends on number of files in the program.</source>
          <target state="translated">&lt;code&gt;fs.watchFile&lt;/code&gt; 은 폴링을 사용하므로 CPU주기를 포함합니다. 그러나 이것은 파일 / 디렉토리의 상태를 업데이트 할 수있는 가장 안정적인 메커니즘입니다. 컴파일러는 일반적으로 &lt;code&gt;fs.watchFile&lt;/code&gt; 을 사용 하여 소스 파일, 구성 파일 및 누락 된 파일 (파일 참조 누락)을 감시합니다. 즉, CPU 사용량은 프로그램의 파일 수에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d942c2a8b235d3c8b1abcc6b3de3eb5cad957fd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;g&lt;/code&gt; which takes an argument of type &lt;code&gt;B&lt;/code&gt; (the type &lt;code&gt;f&lt;/code&gt; returned), and returns a value of type &lt;code&gt;C&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; 는 &lt;code&gt;B&lt;/code&gt; 유형의 인수 ( &lt;code&gt;f&lt;/code&gt; 가 리턴 된 유형)를 취하고 &lt;code&gt;C&lt;/code&gt; 유형의 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6ff0b88d92dd631bb6081ce9db31f440e26b7928" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; Accessors Are Allowed in Ambient Contexts</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 접근 자 주위 컨텍스트에서 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e49e1b432c62fc73ee50890c56c8ca86ec135992" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import.meta&lt;/code&gt; Support in SystemJS</source>
          <target state="translated">&lt;code&gt;import.meta&lt;/code&gt; 지원</target>
        </trans-unit>
        <trans-unit id="0481e74e61bd0bd88c8e2325d45f8276eb589abf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import.meta&lt;/code&gt; is only allowed when targeting &lt;code&gt;ESNext&lt;/code&gt; modules and ECMAScript targets.</source>
          <target state="translated">&lt;code&gt;import.meta&lt;/code&gt; 는 &lt;code&gt;ESNext&lt;/code&gt; 모듈 및 ECMAScript 대상을 대상으로 하는 경우에만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="24678ed6edc307f778f38669f8a75994d68cb176" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import&lt;/code&gt; types</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="2bfe1d5b2564298c1ad9951a1d511481192d2cc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instanceof&lt;/code&gt; type guards</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; 가드</target>
        </trans-unit>
        <trans-unit id="e96fbdf33bebac7a069682e69d1fd6d5b58e1236" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof Car&lt;/code&gt; is completely interchangeable with &lt;code&gt;'manufacturer' | 'model' | 'year'&lt;/code&gt;. The difference is that if you add another property to &lt;code&gt;Car&lt;/code&gt;, say &lt;code&gt;ownersAddress: string&lt;/code&gt;, then &lt;code&gt;keyof Car&lt;/code&gt; will automatically update to be &lt;code&gt;'manufacturer' | 'model' | 'year' | 'ownersAddress'&lt;/code&gt;. And you can use &lt;code&gt;keyof&lt;/code&gt; in generic contexts like &lt;code&gt;pluck&lt;/code&gt;, where you can&amp;rsquo;t possibly know the property names ahead of time. That means the compiler will check that you pass the right set of property names to &lt;code&gt;pluck&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;keyof Car&lt;/code&gt; 는 &lt;code&gt;'manufacturer' | 'model' | 'year'&lt;/code&gt; 와 완전히 호환됩니다 | '모델'| '년' . 차이점은 또 다른 속성을 추가하는 경우이다 &lt;code&gt;Car&lt;/code&gt; 말 &lt;code&gt;ownersAddress: string&lt;/code&gt; 다음 &lt;code&gt;keyof Car&lt;/code&gt; 자동으로 업데이트됩니다 &lt;code&gt;'manufacturer' | 'model' | 'year' | 'ownersAddress'&lt;/code&gt; 입니다. 그리고 당신은 사용할 수 있습니다 &lt;code&gt;keyof&lt;/code&gt; 같은 일반적인 상황에서 &lt;code&gt;pluck&lt;/code&gt; 당신이 가능하게 미리의 속성 이름을 알 수 없습니다. 즉 컴파일러가 올바른 속성 이름 집합을 &lt;code&gt;pluck&lt;/code&gt; 에 전달 했는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="1987a917ef43df8bddaa16f892f8677d58abfb2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof X&lt;/code&gt; is a union of the literal types representing string-like, number-like, and symbol-like properties.</source>
          <target state="translated">&lt;code&gt;keyof X&lt;/code&gt; 는 문자열과 숫자, 기호와 같은 속성을 나타내는 리터럴 유형의 합집합입니다.</target>
        </trans-unit>
        <trans-unit id="07209544abdfdc296d7eca721bd91539c66f16c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof&lt;/code&gt; and &lt;code&gt;T[K]&lt;/code&gt; interact with index signatures. An index signature parameter type must be &amp;lsquo;string&amp;rsquo; or &amp;lsquo;number&amp;rsquo;. If you have a type with a string index signature, &lt;code&gt;keyof T&lt;/code&gt; will be &lt;code&gt;string | number&lt;/code&gt; (and not just &lt;code&gt;string&lt;/code&gt;, since in JavaScript you can access an object property either by using strings (&lt;code&gt;object['42'&lt;/code&gt;]) or numbers (&lt;code&gt;object[42]&lt;/code&gt;)). And &lt;code&gt;T[string]&lt;/code&gt; is just the type of the index signature:</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; 및 &lt;code&gt;T[K]&lt;/code&gt; 는 인덱스 서명과 상호 작용합니다. 색인 서명 매개 변수 유형은 'string'또는 'number'여야합니다. 문자열 색인 서명이있는 유형이있는 경우 &lt;code&gt;keyof T&lt;/code&gt; 는 &lt;code&gt;string | number&lt;/code&gt; 자바 스크립트에서는 문자열 ( &lt;code&gt;object['42'&lt;/code&gt; ]) 또는 숫자 ( &lt;code&gt;object[42]&lt;/code&gt; ) 를 사용하여 객체 속성에 액세스 할 수 있으므로 &lt;code&gt;string&lt;/code&gt; 뿐만 아니라 number 입니다. 그리고 &lt;code&gt;T[string]&lt;/code&gt; 은 인덱스 서명의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="23a74989aac5ff67841f237ba8439fe200c4f59e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyof&lt;/code&gt; and Lookup Types</source>
          <target state="translated">&lt;code&gt;keyof&lt;/code&gt; 및 조회 유형</target>
        </trans-unit>
        <trans-unit id="7587ea139b16cb3066fc1193552ad0a697db99ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; are two relatively new types of variable declarations in JavaScript. &lt;a href=&quot;basic-types#a-note-about-let&quot;&gt;As we mentioned earlier&lt;/a&gt;, &lt;code&gt;let&lt;/code&gt; is similar to &lt;code&gt;var&lt;/code&gt; in some respects, but allows users to avoid some of the common &amp;ldquo;gotchas&amp;rdquo; that users run into in JavaScript. &lt;code&gt;const&lt;/code&gt; is an augmentation of &lt;code&gt;let&lt;/code&gt; in that it prevents re-assignment to a variable.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 과 &lt;code&gt;const&lt;/code&gt; 는 JavaScript에서 비교적 새로운 두 가지 유형의 변수 선언입니다. &lt;a href=&quot;basic-types#a-note-about-let&quot;&gt;우리는 앞에서 언급 한 바와 같이&lt;/a&gt; , &lt;code&gt;let&lt;/code&gt; 유사하다 &lt;code&gt;var&lt;/code&gt; 어떤면에서, 그러나 사용자는 사용자가 자바 스크립트로 실행하는 것이 일반적인 &quot;개는&quot;의 일부를 피할 수 있습니다. &lt;code&gt;const&lt;/code&gt; 는 변수에 대한 재 할당을 방지한다는 점에서 &lt;code&gt;let&lt;/code&gt; 의 기능을 보강 한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="578f076915b9987c6c3b4ff784a24189b7365213" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; support</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 지원</target>
        </trans-unit>
        <trans-unit id="6b776172d356ffcb9dd1ee020b2f44b56c7785dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 선언 하자</target>
        </trans-unit>
        <trans-unit id="644591ecf7a7ac1044c0183c3798f150809bbe15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; declarations have drastically different behavior when declared as part of a loop. Rather than just introducing a new environment to the loop itself, these declarations sort of create a new scope &lt;em&gt;per iteration&lt;/em&gt;. Since this is what we were doing anyway with our IIFE, we can change our old &lt;code&gt;setTimeout&lt;/code&gt; example to just use a &lt;code&gt;let&lt;/code&gt; declaration.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 루프의 한 부분으로 선언 한 선언이 크게 다른 행동이있다. 루프 자체에 새로운 환경을 도입하는 대신 이러한 선언 &lt;em&gt;은 반복마다&lt;/em&gt; 새로운 범위를 만듭니다 . 이것이 IIFE를 사용하여 수행 한 작업이므로 &lt;code&gt;let&lt;/code&gt; 선언 만 사용하도록 이전 &lt;code&gt;setTimeout&lt;/code&gt; 예제를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f152c0c11e8b4f18e296dd980a05bfe53992b15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; is only available when targeting ECMAScript 6 (&lt;code&gt;--target ES6&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 은 ECMAScript 6 ( &lt;code&gt;--target ES6&lt;/code&gt; )을 대상으로하는 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2604695bf1219c913e9ce6e43a919233bb300fd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt; vs. &lt;code&gt;const&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 대 &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47597d61bef00139bb68777625c718cfe83c7a37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, and &lt;code&gt;var&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; , &lt;code&gt;const&lt;/code&gt; 및 &lt;code&gt;var&lt;/code&gt; 선언</target>
        </trans-unit>
        <trans-unit id="a829bf2451c18e9c8300170bf81a48d5c7a14e26" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module === &quot;system&quot;&lt;/code&gt; or &lt;code&gt;--esModuleInterop&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;module === &quot;system&quot;&lt;/code&gt; 또는 &lt;code&gt;--esModuleInterop&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8aedd5acf8ab96c5aa7b3783ab936c10a1ae4b90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;namespace&lt;/code&gt; keyword</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; 키워드</target>
        </trans-unit>
        <trans-unit id="3757c64ba702c0e95ec29c43f6b3bcbac2dfaf79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;never&lt;/code&gt; is a subtype of and assignable to every type.</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 모든 유형의 하위 유형이며 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dbf0fffc126fe6f7ef6fe8bd69ac432fc59ec7cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new.target&lt;/code&gt; also comes in handy for writing constructable functions, for example:</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; 은 다음과 같이 구성 가능한 함수를 작성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="38f8af0872a567ae1498db2400c8725c6f67981a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new.target&lt;/code&gt; comes in handy when &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; or &lt;code&gt;__proto__&lt;/code&gt; needs to be set in a class constructor. One such use case is inheriting from &lt;code&gt;Error&lt;/code&gt; in NodeJS v4 and higher.</source>
          <target state="translated">&lt;code&gt;new.target&lt;/code&gt; 은 클래스 생성자에서 &lt;code&gt;Object.setPrototypeOf&lt;/code&gt; 또는 &lt;code&gt;__proto__&lt;/code&gt; 를 설정해야 할 때 유용합니다 . 이러한 사용 사례 중 하나 는 NodeJS v4 이상의 &lt;code&gt;Error&lt;/code&gt; 에서 상속 된 것 입니다.</target>
        </trans-unit>
        <trans-unit id="c23e511cadd633529e9b1516004a6ec203d2f65d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt; which is helpful if you never want to forget a &lt;code&gt;break&lt;/code&gt; statement between &lt;code&gt;case&lt;/code&gt;s in a &lt;code&gt;switch&lt;/code&gt; block.</source>
          <target state="translated">&lt;code&gt;noFallthroughCasesInSwitch&lt;/code&gt; 는 &lt;code&gt;switch&lt;/code&gt; 블록 에서 &lt;code&gt;case&lt;/code&gt; 사이 의 &lt;code&gt;break&lt;/code&gt; 문 을 잊지 않으려는 경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="17b5ef3461c6310cbfb2829b36fa9f54629275f7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noImplicitAny&lt;/code&gt; : Raise error on expressions and declarations with an implied &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;noImplicitAny&lt;/code&gt; : 묵시적인 &lt;code&gt;any&lt;/code&gt; 유형의 표현식 및 선언에서 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="8b684ebe24425d0ae00fe5f4dd392279dd756e18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noImplicitReturns&lt;/code&gt; which prevents you from forgetting to return at the end of a function.</source>
          <target state="translated">&lt;code&gt;noImplicitReturns&lt;/code&gt; 는 함수의 끝에서 리턴하는 것을 잊어 버리지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="e88ad4b11b76f0b52388960f7fb144596753b33f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; is a type that represents the non-primitive type, i.e. anything that is not &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;bigint&lt;/code&gt;, &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 는 기본이 아닌 형식, 즉 &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;bigint&lt;/code&gt; , &lt;code&gt;symbol&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 가 아닌 형식을 나타내는 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="26b459667b63171c9a2bfca987e324fd67266a33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="a1c2b17b7aa15d4b6c554df6d3c6079bd7ea6b62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onEmitOnError&lt;/code&gt; : Do not emit outputs if any errors were reported.</source>
          <target state="translated">&lt;code&gt;onEmitOnError&lt;/code&gt; : 오류가보고 된 경우 출력을 방출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d36f089a00eed6e2a38161e562ca2eadbc3a0ba3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;paths&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;paths&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7271647d356fdf53e4881a83f2b3d24088d1ce22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pet is Fish&lt;/code&gt; is our type predicate in this example. A predicate takes the form &lt;code&gt;parameterName is Type&lt;/code&gt;, where &lt;code&gt;parameterName&lt;/code&gt; must be the name of a parameter from the current function signature.</source>
          <target state="translated">&lt;code&gt;pet is Fish&lt;/code&gt; 는이 예제에서 유형 술어입니다. 술어는 &lt;code&gt;parameterName is Type&lt;/code&gt; 형식을 취합니다 . 여기서 &lt;code&gt;parameterName&lt;/code&gt; 은 현재 함수 서명의 매개 변수 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d591a35ea43b09e97945e00e88029db5bb27c2b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prepend&lt;/code&gt; with &lt;code&gt;outFile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;prepend&lt;/code&gt; 로 &lt;code&gt;outFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f48ad12a1bd9b139a251683c44c9c037d0781daa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;react&lt;/code&gt;, &lt;code&gt;react-native&lt;/code&gt;, &lt;code&gt;preserve&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;react&lt;/code&gt; , &lt;code&gt;react-native&lt;/code&gt; , &lt;code&gt;preserve&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="265f731b05abd126578741df3ef1317127023ebd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readonly&lt;/code&gt; mapped type modifiers and &lt;code&gt;readonly&lt;/code&gt; arrays</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 매핑 유형 수정 자 및 &lt;code&gt;readonly&lt;/code&gt; 배열</target>
        </trans-unit>
        <trans-unit id="0a72bebc41b3c89da2f3cb186861c5375dc8d827" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 튜플</target>
        </trans-unit>
        <trans-unit id="8f3d715459a937e9292de095a19bf986d41e03e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readonly&lt;/code&gt; vs &lt;code&gt;const&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 대 &lt;code&gt;const&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="204249cb0d243afb180412fa55d150953da5fecd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rootDirs&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;rootDirs&lt;/code&gt;&lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="4c4934c028db6c4d82b88f32de53708b229fb87e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sourceMap&lt;/code&gt; : Generates corresponding &lt;code&gt;.map&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;sourceMap&lt;/code&gt; : 해당 &lt;code&gt;.map&lt;/code&gt; 파일을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="d0b7403357a0651ddeff1c1122a8b2bb08ffe8e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strictNullChecks&lt;/code&gt; is disabled</source>
          <target state="translated">&lt;code&gt;strictNullChecks&lt;/code&gt; 가 비활성화되었습니다</target>
        </trans-unit>
        <trans-unit id="8dbbf233507908fb7d0aaad278a5681b3a14a678" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;symbol&lt;/code&gt; values are created by calling the &lt;code&gt;Symbol&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;symbol&lt;/code&gt; 생성자 는 &lt;code&gt;Symbol&lt;/code&gt; 생성자 를 호출하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="df548ecfe43e1bd5edc74f5f9d9e11e7c489fabb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;target&lt;/code&gt; : Specify ECMAScript target version.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; : ECMAScript 대상 버전을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="41807fdfe0d78a471df79e23ac828c29a48b1df2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this is T&lt;/code&gt; is now valid return type annotation for methods in classes and interfaces. When used in a type narowing position (e.g. &lt;code&gt;if&lt;/code&gt; statement), the type of the call expression target object would be narrowed to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this is T&lt;/code&gt; 클래스와 인터페이스의 메소드에 유효한 리턴 유형 주석 인 T 입니다. 유형 탐색 위치 (예 : &lt;code&gt;if&lt;/code&gt; 문) 에서 사용될 경우 호출 표현식 대상 객체의 유형은 &lt;code&gt;T&lt;/code&gt; 로 좁아집니다 .</target>
        </trans-unit>
        <trans-unit id="a25fe4991728ca46519e506de1d8f666a6c8b7fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this: void&lt;/code&gt; means that &lt;code&gt;addClickListener&lt;/code&gt; expects &lt;code&gt;onclick&lt;/code&gt; to be a function that does not require a &lt;code&gt;this&lt;/code&gt; type.</source>
          <target state="translated">&lt;code&gt;this: void&lt;/code&gt; 는 &lt;code&gt;addClickListener&lt;/code&gt; 가 &lt;code&gt;onclick&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; 유형을 필요로하지 않는 함수일 것으로 예상 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="a9953e41bed91beb356ec58e55940c473593811e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this: void&lt;/code&gt; means that &lt;code&gt;addClickListener&lt;/code&gt; expects &lt;code&gt;onclick&lt;/code&gt; to be a function that does not require a &lt;code&gt;this&lt;/code&gt; type. Second, annotate your calling code with &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;this: void&lt;/code&gt; 는 &lt;code&gt;addClickListener&lt;/code&gt; 가 &lt;code&gt;onclick&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; 유형을 필요로하지 않는 함수일 것으로 예상 함을 의미합니다 . 둘째, 다음과 &lt;code&gt;this&lt;/code&gt; 호출 코드에 주석을 답니다 .</target>
        </trans-unit>
        <trans-unit id="239502a5db9c22853dabbf84a0a02ea54ae32760" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; and arrow functions</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 화살표 기능</target>
        </trans-unit>
        <trans-unit id="f6b4a05163d3be8c272019de111de564106390bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; parameters</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 매개 변수</target>
        </trans-unit>
        <trans-unit id="9ba826b0f4b51964bc2dcb2689ad5e6718b4d812" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt; parameters in callbacks</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 콜백 의이 매개 변수</target>
        </trans-unit>
        <trans-unit id="76a17c6a78a4a91182cb755f2d1f82d0e8352047" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt;-based type guards</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 유형의 경비원</target>
        </trans-unit>
        <trans-unit id="80d7365686580943b61bcc0680fdd9fefd9bb9d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this&lt;/code&gt;-typing</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt;-typing</target>
        </trans-unit>
        <trans-unit id="a5626b5c92a5a1772a40e47f83129a6cdaba494c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; if &lt;code&gt;composite&lt;/code&gt; is on, &lt;code&gt;false&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; &lt;code&gt;composite&lt;/code&gt; 가 켜져 있으면 true 이고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="15a6e88c2494ea9288969156547c6f6523ee7397" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; unless piping to another program or redirecting output to a file</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 다른 프로그램으로 파이핑하거나 출력을 파일로 리디렉션하지 않는 한 true</target>
        </trans-unit>
        <trans-unit id="5827602d127a01fcf210389ba5b4073a09f73f65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc -b&lt;/code&gt; Commandline</source>
          <target state="translated">&lt;code&gt;tsc -b&lt;/code&gt; 명령 줄</target>
        </trans-unit>
        <trans-unit id="5fbf7438323e3bbf152cf8686704d6a9b92eda48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc -w&lt;/code&gt; can&amp;rsquo;t run on multiple config files at once</source>
          <target state="translated">&lt;code&gt;tsc -w&lt;/code&gt; 는 여러 구성 파일에서 한 번에 실행할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="147a626c1d03568f0d86b81b12aca475f5e24705" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc&lt;/code&gt; will only ever use existing files on disk to do this process, so it&amp;rsquo;s possible to create a project where a correct output file can&amp;rsquo;t be generated because some project&amp;rsquo;s output would be present more than once in the resulting file. For example:</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; 는 디스크에있는 기존 파일 만 사용하여이 프로세스를 수행하므로 일부 프로젝트의 출력이 결과 파일에 두 번 이상 존재하므로 올바른 출력 파일을 생성 할 수없는 프로젝트를 작성할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="98564db040acf2bf7b395e1d0a36df38b4a8402f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsc&lt;/code&gt;, the TypeScript compiler, supports a new flag called &lt;code&gt;--showConfig&lt;/code&gt;. When running &lt;code&gt;tsc --showConfig&lt;/code&gt;, TypeScript will calculate the effective &lt;code&gt;tsconfig.json&lt;/code&gt; (after calculating options inherited from the &lt;code&gt;extends&lt;/code&gt; field) and print that out. This can be useful for diagnosing configuration issues in general.</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; , 타이프 스크립트 컴파일러,라는 새로운 플래그를 지원 &lt;code&gt;--showConfig&lt;/code&gt; 을 . &lt;code&gt;tsc --showConfig&lt;/code&gt; 를 실행하면 TypeScript는 효과적인 &lt;code&gt;tsconfig.json&lt;/code&gt; 을 계산하고 ( &lt;code&gt;extends&lt;/code&gt; 필드 에서 상속 된 옵션을 계산 한 후 )이를 인쇄합니다. 일반적으로 구성 문제를 진단하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54a7f5e8734c14fa7d0a8d6777c5b5ac6fa8ca44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; files have a new top-level property, &lt;code&gt;references&lt;/code&gt;. It&amp;rsquo;s an array of objects that specifies projects to reference:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 파일에는 새로운 최상위 속성 인 &lt;code&gt;references&lt;/code&gt; 있습니다. 참조 할 프로젝트를 지정하는 객체 배열입니다.</target>
        </trans-unit>
        <trans-unit id="c8d62e6e595e456c5e9270cc34e832ead6a38881" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; inheritance via Node.js packages</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; Node.js 패키지를 통한 tsconfig.json 상속</target>
        </trans-unit>
        <trans-unit id="e2d6ff9ec9b1c03f6c4865dd1b1475c13329c97c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt; turns a folder into a &amp;ldquo;project&amp;rdquo;. Without specifying any &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt; entries, all files in the folder containing the &lt;code&gt;tsconfig.json&lt;/code&gt; and all its sub-directories are included in your compilation. If you want to exclude some of the files use &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt;, if you would rather specify all the files instead of letting the compiler look them up, use &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 은 폴더를&amp;ldquo;프로젝트&amp;rdquo;로 바꿉니다. &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt; 또는 &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt; 항목을 지정하지 않으면 &lt;code&gt;tsconfig.json&lt;/code&gt; 이 포함 된 폴더의 모든 파일 및 모든 해당 서브 디렉토리가 컴파일에 포함됩니다. 일부 파일을 제외하려면 &lt;code&gt;&amp;ldquo;exclude&amp;rdquo;&lt;/code&gt; 사용 하고, 컴파일러가 파일을 찾도록하는 대신 모든 파일을 지정하려면 &lt;code&gt;&amp;ldquo;files&amp;rdquo;&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="44461f86b394f4690605fa32353147f0c499cba8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="dce89073ea61332463e4bc7ffcd226cfebb38fb7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tsconfig.nostrictnull.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tsconfig.nostrictnull.json&lt;/code&gt;:</target>
        </trans-unit>
        <trans-unit id="802c612cac10d8e06122f662232f3d40cbb16c55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typeof&lt;/code&gt; type guards</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 유형 가드</target>
        </trans-unit>
        <trans-unit id="ba1416688590a42ec8a707493a8a76f4bafb32ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;typesVersions&lt;/code&gt; can support multiple fields where each field name is specified by the range to match on.</source>
          <target state="translated">&lt;code&gt;typesVersions&lt;/code&gt; 는 각 필드 이름이 일치하는 범위로 지정되는 여러 필드를 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16c59fd04173482af55d5dc102886aa00a3441e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; declarations</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 선언</target>
        </trans-unit>
        <trans-unit id="ab9085fb15ab9e328c2c89a7b70fa880194687cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var&lt;/code&gt; declarations have some odd scoping rules for those used to other languages. Take the following example:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 선언에는 다른 언어에 사용되는 것에 대한 이상한 범위 지정 규칙이 있습니다. 다음 예제를 보자.</target>
        </trans-unit>
        <trans-unit id="e6f91793a72a6bf2a9f9865634b43e9fe9ffea71" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;void&lt;/code&gt; is a little like the opposite of &lt;code&gt;any&lt;/code&gt;: the absence of having any type at all. You may commonly see this as the return type of functions that do not return a value:</source>
          <target state="translated">&lt;code&gt;void&lt;/code&gt; 약간의 양처럼 &lt;code&gt;any&lt;/code&gt; 전혀 어떠한 형태를 갖는 부재 :. 일반적으로 이것을 값을 반환하지 않는 반환 유형의 함수로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5162ce142c852c721ea4c2f90dcd96e468cd2c12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;y&lt;/code&gt; would have the type &lt;code&gt;any&lt;/code&gt;. This meant the program would type-check, but you could technically do anything with &lt;code&gt;y&lt;/code&gt;, such as the following:</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 는 &lt;code&gt;any&lt;/code&gt; 유형을 갖습니다 . 이것은 프로그램이 유형을 검사한다는 것을 의미했지만 기술적 으로 다음과 같이 &lt;code&gt;y&lt;/code&gt; 로 무엇이든 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27cc4133a65e863977268415e96540e32efacbaa" translate="yes" xml:space="preserve">
          <source>&lt;del&gt;&lt;code&gt;--out&lt;/code&gt;&lt;/del&gt;</source>
          <target state="translated">&lt;del&gt;&lt;code&gt;--out&lt;/code&gt;&lt;/del&gt;</target>
        </trans-unit>
        <trans-unit id="c1b2e33284cd8b33b99364f12379b80c308e775f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(common root directory is computed from the list of input files)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(common root directory is computed from the list of input files)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="67f8a82845ea83174fddc0273791def9f3791ba2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(platform specific)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(platform specific)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bcd153da1f3527d871cddfa9877fa2d91c2500ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;instanceof&lt;/code&gt; type guards&lt;/em&gt; are a way of narrowing types using their constructor function. For instance, let&amp;rsquo;s borrow our industrial string-padder example from earlier:</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;instanceof&lt;/code&gt; type guard&lt;/em&gt; 는 생성자 함수를 사용하여 유형을 좁히는 방법입니다. 예를 들어, 산업 스트링 패더 예제를 이전부터 빌려 봅시다.</target>
        </trans-unit>
        <trans-unit id="5c97a851324ff9563ea3a21efd2d3c3c258c8c52" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Any compiler option&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;모든 컴파일러 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6848663f06841c4836ef827c8d46d2b7df3d9e2e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Class Decorators&lt;/em&gt; are applied for the class.</source>
          <target state="translated">&lt;em&gt;수업 데코레이터&lt;/em&gt; 가 &lt;em&gt;수업&lt;/em&gt; 에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="46261c91e2d02cefcc599506ebcf0fdd9241cca2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Code&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Code&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b095cf5579d916d24a5da3d12744c26e407ebcb8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Configure the TypeScript compiler&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;TypeScript 컴파일러 구성&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="116f39d7e603ae15f6176b14608384bdd2f4ccc5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Declaration&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Declaration&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3144417886ddc6e09e0cb50372c04d88ab6ff96c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; depend on the npm type declaration package if it doesn&amp;rsquo;t package its declaration files.</source>
          <target state="translated">&lt;em&gt;음주&lt;/em&gt; 가 선언 파일을 패키징하지 않는 경우 NPM 형 선언 패키지에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="a89db8b7cceca187803f1966f48b0b78dc6807c5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; sort overloads by putting the more general signatures after more specific signatures:</source>
          <target state="translated">&lt;em&gt;수행&lt;/em&gt; 보다 구체적인 서명 후 더 일반적인 서명을 넣어 정렬 오버로드 :</target>
        </trans-unit>
        <trans-unit id="74d4dbaa7a29534baf764d9d7745b59ff457b95c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; instead.</source>
          <target state="translated">&lt;em&gt;수행&lt;/em&gt; 사용 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="a8abf42191e985fd38d25cbfd61b4478044adfc0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use optional parameters whenever possible:</source>
          <target state="translated">&lt;em&gt;마&lt;/em&gt; 가능한 선택적 매개 변수를 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="e34280b76cbb108a56a72b557e087d65bbfca383" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use the return type &lt;code&gt;void&lt;/code&gt; for callbacks whose value will be ignored:</source>
          <target state="translated">&lt;em&gt;마&lt;/em&gt; 반환 형식의 사용 &lt;code&gt;void&lt;/code&gt; 값이 무시됩니다 콜백을 :</target>
        </trans-unit>
        <trans-unit id="c2582d04d57e5a9ca2606283a30a617ee529f638" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use the types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, and &lt;code&gt;symbol&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;마&lt;/em&gt; 종류의 사용 &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; 및 &lt;code&gt;symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03ab3ac84230901f9c46e90452077394873671fb" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; use union types whenever possible:</source>
          <target state="translated">&lt;em&gt;수행&lt;/em&gt; 가능한 사용 조합 유형 :</target>
        </trans-unit>
        <trans-unit id="be31bfe1264c4f25766db39e5b90a9fb18fca142" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; write a single overload using the maximum arity:</source>
          <target state="translated">&lt;em&gt;수행&lt;/em&gt; 의 최대 인수에 대응을 사용하여 하나의 과부하를 쓰기 :</target>
        </trans-unit>
        <trans-unit id="c1a8d257a217b5e0fad55b648d1b6493b9aaa989" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Do&lt;/em&gt; write callback parameters as non-optional:</source>
          <target state="translated">&lt;em&gt;수행&lt;/em&gt; 이 아닌 선택 사항으로 쓰기 콜백 매개 변수를 :</target>
        </trans-unit>
        <trans-unit id="2abc499e9803a9aa8309f8b0e08bf314ad4f3e5a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Documentation&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Documentation&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb8f02b3c9fe34b16e4d7281860a58ffb5f1258c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; combine it with yours, keep each in their own file.</source>
          <target state="translated">&lt;em&gt;당신&lt;/em&gt; 과 그것을 결합 &lt;em&gt;하지 말고&lt;/em&gt; 각각 자신의 파일에 보관하십시오.</target>
        </trans-unit>
        <trans-unit id="55046e05caf1c72e4c96a87b22fa2202c7225227" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; copy the declarations in your package either.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;패키지의 선언도 복사 &lt;em&gt;하지 마십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f2dfadd00649442a356417e47981d6fcfedbf53f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; ever have a generic type which doesn&amp;rsquo;t use its type parameter. See more details in &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---&quot;&gt;TypeScript FAQ page&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;하지 마십시오&lt;/em&gt; 사상 형식 매개 변수를 사용하지 않는 일반적인 유형이있다. 자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#why-doesnt-type-inference-work-on-this-interface-interface-foot---&quot;&gt;TypeScript FAQ 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aab2c6da00dd5473019faeda9ef13e58ed031a8a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; ever use the types &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Boolean&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, or &lt;code&gt;Object&lt;/code&gt; These types refer to non-primitive boxed objects that are almost never used appropriately in JavaScript code.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt; &lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Boolean&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; 또는 &lt;code&gt;Object&lt;/code&gt; 유형을 사용 &lt;em&gt;하지 마십시오.&lt;/em&gt; 이 유형은 JavaScript 코드에서 거의 사용되지 않는 기본이 아닌 박스형 객체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9fe264f4ba7251b442af48a3b5b9c4e1b135dfc4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; put more general overloads before more specific overloads:</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;보다 구체적인 과부하가 걸리기 전에 일반적인 과부하를 넣지 &lt;em&gt;마십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a603d4de241274517e1f16e58ef6ec739c4ebf0c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; in your declaration files.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;선언 파일에 &lt;code&gt;/// &amp;lt;reference path=&quot;...&quot; /&amp;gt;&lt;/code&gt; 를 사용 &lt;em&gt;하지 마십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1399216a9d6759d0027db5ae960ecaf5e803541f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use optional parameters in callbacks unless you really mean it:</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;실제로 의미하지 않는 한 콜백에 선택적 매개 변수를 사용 &lt;em&gt;하지 마십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9d00344d385328c471e2760c0b3a980265f52fa1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; use the return type &lt;code&gt;any&lt;/code&gt; for callbacks whose value will be ignored:</source>
          <target state="translated">&lt;em&gt;하지 마십시오&lt;/em&gt; 반환을 사용하여 입력 한 &lt;code&gt;any&lt;/code&gt; 값이 무시됩니다 콜백 :</target>
        </trans-unit>
        <trans-unit id="7e23e9a1b88c2a712c6058479b769bb4d1ec3dfd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write overloads that differ by type in only one argument position:</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;하나의 인수 위치에서만 유형에 따라 다른 과부하를 &lt;em&gt;쓰지 마십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c0e439fdd1e71a139adb43b822a3f2aaba28d521" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write separate overloads that differ only on callback arity:</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;콜백 arity에서만 다른 별도의 오버로드를 작성 &lt;em&gt;하지 마십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="247c5c1a979d3fed5d8cc62a706484f0933fae19" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Don&amp;rsquo;t&lt;/em&gt; write several overloads that differ only in trailing parameters:</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;후행 매개 변수에서만 다른 여러 과부하를 쓰지 &lt;em&gt;마십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7a458b0d98bbea39bc5c4fb3afb6e88d1dfd11e4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;First some ES2016 terminology:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;먼저 몇 가지 ES2016 용어 :&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e33a7ce58f99afe193351513fce2adb5fa23fa05" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Global Plugin&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;글로벌 플러그인&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42b74d2886feeb2bcc628ab0ed5f0f2c95a4fcba" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Global-modifying Modules&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;글로벌 수정 모듈&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3dcead9d078d5e6cb9c2a8d1954d8f1acb7bcdd9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MSBuild only option&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MSBuild 전용 옵션&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5859e547903805656a797e0b51e85d7408c824b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Module Plugin&lt;/em&gt; or &lt;em&gt;UMD Plugin&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;모듈 플러그인&lt;/em&gt; 또는 &lt;em&gt;UMD 플러그인&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d05eb70e7bf87cec96374f03c7bbd7c1a2dc4450" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Module resolution&lt;/em&gt; is the process the compiler uses to figure out what an import refers to. Consider an import statement like &lt;code&gt;import { a } from &quot;moduleA&quot;&lt;/code&gt;; in order to check any use of &lt;code&gt;a&lt;/code&gt;, the compiler needs to know exactly what it represents, and will need to check its definition &lt;code&gt;moduleA&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;모듈 확인&lt;/em&gt; 은 컴파일러가 가져 오기가 참조하는 것을 파악하기 위해 사용하는 프로세스입니다. &lt;code&gt;import { a } from &quot;moduleA&quot;&lt;/code&gt; 와 같은 import 문을 고려하십시오 . 의 사용 확인하기 위해 &lt;code&gt;a&lt;/code&gt; , 컴파일러가 나타내는 정확히 알 필요가있다, 그 정의 확인해야합니다 &lt;code&gt;moduleA&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="58e6a2ccb2d8f44ed1c3e778056f2950ed113c53" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Not supported in MSBuild&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MSBuild에서 지원되지 않습니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9dac7371112f6ec5085b3b87e625a9052b4ee6a7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: Currently TypeScript support in jspm is in 0.16beta&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : jspm에서 현재 TypeScript 지원은 0.16beta입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8cb755d2229785263aed32055f1123709bd7654" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt; are applied for the constructor.</source>
          <target state="translated">&lt;em&gt;매개 변수 데코레이터&lt;/em&gt; 가 생성자에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="796db20a306e9b2dd3935de4aee308956682ef88" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt;, followed by &lt;em&gt;Method&lt;/em&gt;, &lt;em&gt;Accessor&lt;/em&gt;, or &lt;em&gt;Property Decorators&lt;/em&gt; are applied for each instance member.</source>
          <target state="translated">&lt;em&gt;파라미터 장식&lt;/em&gt; 이어서, &lt;em&gt;방법&lt;/em&gt; , &lt;em&gt;액세스 장치&lt;/em&gt; , 또는 &lt;em&gt;속성 장식은&lt;/em&gt; 각 인스턴스 부재에 적용된다.</target>
        </trans-unit>
        <trans-unit id="5479469c16116549f61eeafcc9902b8ba05b63e1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Parameter Decorators&lt;/em&gt;, followed by &lt;em&gt;Method&lt;/em&gt;, &lt;em&gt;Accessor&lt;/em&gt;, or &lt;em&gt;Property Decorators&lt;/em&gt; are applied for each static member.</source>
          <target state="translated">&lt;em&gt;파라미터 장식&lt;/em&gt; 이어서, &lt;em&gt;방법&lt;/em&gt; , &lt;em&gt;액세스 장치&lt;/em&gt; , 또는 &lt;em&gt;속성 장식은&lt;/em&gt; 각 고정 부재에 적용된다.</target>
        </trans-unit>
        <trans-unit id="5e31e103a79ad520b2c48fac19a5feaa38b4da57" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Rest parameters&lt;/em&gt; are treated as a boundless number of optional parameters. When passing arguments for a rest parameter, you can use as many as you want; you can even pass none. The compiler will build an array of the arguments passed in with the name given after the ellipsis (&lt;code&gt;...&lt;/code&gt;), allowing you to use it in your function.</source>
          <target state="translated">&lt;em&gt;나머지 매개 변수&lt;/em&gt; 는 무한한 수의 선택적 매개 &lt;em&gt;변수&lt;/em&gt; 로 취급됩니다. rest 매개 변수에 인수를 전달할 때 원하는만큼 사용할 수 있습니다. 당신은 아무 것도 통과 할 수 없습니다. 컴파일러는 생략 부호 ( &lt;code&gt;...&lt;/code&gt; ) 뒤에 주어진 이름으로 전달 된 인수 배열을 빌드 하여 함수에서 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="384a6b578c237d923ecb9829216306571810a612" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Set up NPM&lt;/em&gt; #</source>
          <target state="translated">&lt;em&gt;NPM&lt;/em&gt; 번호 &lt;em&gt;설정&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="00ac1e66f3bd63d151ee5473a7360afdc8a5dfb6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Set up gulp&lt;/em&gt; #</source>
          <target state="translated">&lt;em&gt;꿀꺽 꿀꺽&lt;/em&gt; # &lt;em&gt;설정&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="04dd4e00bd479a6cea3c982c3959ab8a78ce6226" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Type assertions&lt;/em&gt; are a way to tell the compiler &amp;ldquo;trust me, I know what I&amp;rsquo;m doing.&amp;rdquo; A type assertion is like a type cast in other languages, but performs no special checking or restructuring of data. It has no runtime impact, and is used purely by the compiler. TypeScript assumes that you, the programmer, have performed any special checks that you need.</source>
          <target state="translated">&lt;em&gt;타입 어설 션&lt;/em&gt; 은 컴파일러에게&amp;ldquo;내가 뭘하는지 알고있다&amp;rdquo;고 말해주는 방법이다. 형식 어설 션은 다른 언어로 된 형식 캐스트와 유사하지만 데이터의 특별한 검사 또는 재구성을 수행하지 않습니다. 런타임에 영향을 미치지 않으며 컴파일러가 순수하게 사용합니다. TypeScript는 프로그래머가 필요한 특수 검사를 수행했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="9b530738f60a429e40a0da7cd4905304cf2dcd24" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;UMD&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;UMD&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55ac475adb38e0b57582081a72d1746f55ded573" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: It&amp;rsquo;s always legal for a callback to disregard a parameter, so there&amp;rsquo;s no need for the shorter overload. Providing a shorter callback first allows incorrectly-typed functions to be passed in because they match the first overload.</source>
          <target state="translated">&lt;em&gt;이유&lt;/em&gt; : 콜백이 매개 변수를 무시하는 것이 항상 합법적이므로 더 짧은 과부하가 필요하지 않습니다. 짧은 콜백을 먼저 제공하면 첫 번째 오버로드와 일치하기 때문에 잘못 입력 된 함수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bba95ff529a6d0256d8f93bf5b1f76f42a078259" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: This is important for people who are &amp;ldquo;passing through&amp;rdquo; a value to your function:</source>
          <target state="translated">&lt;em&gt;이유&lt;/em&gt; : 이것은 귀하의 기능에 가치를 &quot;통과시키는&quot;사람들에게 중요합니다 :</target>
        </trans-unit>
        <trans-unit id="049ec47dfa02534ad24ffb14e28f3f5229781764" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: This is important for two reasons.</source>
          <target state="translated">&lt;em&gt;이유&lt;/em&gt; : 두 가지 이유로 중요합니다.</target>
        </trans-unit>
        <trans-unit id="62327515a94c59f6d707eb154b79f5e5dbfb2a4f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: TypeScript chooses the &lt;em&gt;first matching overload&lt;/em&gt; when resolving function calls. When an earlier overload is &amp;ldquo;more general&amp;rdquo; than a later one, the later one is effectively hidden and cannot be called.</source>
          <target state="translated">&lt;em&gt;이유&lt;/em&gt; : TypeScript는 함수 호출을 해결할 때 &lt;em&gt;첫 번째로 일치하는 오버로드를&lt;/em&gt; 선택 합니다. 이전의 과부하가 이후의 과부하보다 &quot;일반적인&quot;경우, 나중에 과부하가 효과적으로 숨겨져 호출 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="22083a1e79f664f58fd53b8457712dc488debc77" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Why&lt;/em&gt;: Using &lt;code&gt;void&lt;/code&gt; is safer because it prevents you from accidentally using the return value of &lt;code&gt;x&lt;/code&gt; in an unchecked way:</source>
          <target state="translated">&lt;em&gt;이유&lt;/em&gt; : &lt;code&gt;void&lt;/code&gt; 를 사용하면 실수로 &lt;code&gt;x&lt;/code&gt; 의 반환 값을 검사하지 않은 방식으로 사용하지 못하므로 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="eb00c2127ec65942b8f8eaef0ef31ccfcc660872" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;automatic&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;automatic&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b6df984511379d608600ad56856c6b7c90da664d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A note about terminology:&lt;/strong&gt; It&amp;rsquo;s important to note that in TypeScript 1.5, the nomenclature has changed. &amp;ldquo;Internal modules&amp;rdquo; are now &amp;ldquo;namespaces&amp;rdquo;. &amp;ldquo;External modules&amp;rdquo; are now simply &amp;ldquo;modules&amp;rdquo;, as to align with &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015&lt;/a&gt;&amp;rsquo;s terminology, (namely that &lt;code&gt;module X {&lt;/code&gt; is equivalent to the now-preferred &lt;code&gt;namespace X {&lt;/code&gt;).</source>
          <target state="translated">&lt;strong&gt;용어에 대한 참고 사항 :&lt;/strong&gt; TypeScript 1.5에서는 명명법이 변경되었습니다. &amp;ldquo;내부 모듈&amp;rdquo;은 이제&amp;ldquo;네임 스페이스&amp;rdquo;입니다. &quot;외부 모듈&quot;은 이제 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015&lt;/a&gt; 의 용어 와 일치하도록 간단히 &quot;모듈&quot;입니다 (즉, 해당 &lt;code&gt;module X {&lt;/code&gt; 는 현재 선호되는 &lt;code&gt;namespace X {&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cb823f67a7cbb8600c4f0350f1c2ad73fe2d021a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;After&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;After&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="156a1437d0d6c924eb6ca12562027ff2587f6045" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Before&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Before&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="83af59348af09abe07910fb748be25518e341a5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Command Line&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;커맨드 라인&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="2dd8a1d40fc5fe437da8ffe7085dd47f6e01c64d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this directive has been deprecated. Use &lt;code&gt;import &quot;moduleName&quot;;&lt;/code&gt; statements instead.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 지시문은 더 이상 사용되지 않습니다. &lt;code&gt;import &quot;moduleName&quot;;&lt;/code&gt; 사용하십시오 . 대신 진술.</target>
        </trans-unit>
        <trans-unit id="98dca272af4b4983e9681bcffd62a12fd4abd3d3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Usage&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="87244e77c6f80d6ca60d4ab90f5e3a2c23bfbfb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tsconfig.json&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;tsconfig.json&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="a30a3cb060aed8b038da2f590d07d1fab7bd3b38" translate="yes" xml:space="preserve">
          <source>&lt;sup id=&quot;ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/sup&gt; More specifically, homomorphic mapped types like in the above form.</source>
          <target state="translated">&lt;sup id=&quot;ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/sup&gt; More specifically, homomorphic mapped types like in the above form.</target>
        </trans-unit>
        <trans-unit id="18ae02156418abf2a28f0ac9092105d374823167" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;[1]&lt;/sup&gt; These options are experimental.</source>
          <target state="translated">&lt;sup&gt;[1]&lt;/sup&gt; These options are experimental.</target>
        </trans-unit>
        <trans-unit id="fa0447115a5c58a31c601fe3ecaf85a07da3a091" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;[2]&lt;/sup&gt; These options are only allowed in &lt;code&gt;tsconfig.json&lt;/code&gt;, and not through command-line switches.</source>
          <target state="translated">&lt;sup&gt;[2]&lt;/sup&gt; These options are only allowed in &lt;code&gt;tsconfig.json&lt;/code&gt;, and not through command-line switches.</target>
        </trans-unit>
        <trans-unit id="e1e2f277649e29a892f6243a1e9f85f91b903aeb" translate="yes" xml:space="preserve">
          <source>======== Module name &amp;lsquo;typescript&amp;rsquo; was &lt;strong&gt;successfully resolved&lt;/strong&gt; to &amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;. ========</source>
          <target state="translated">======== Module name &amp;lsquo;typescript&amp;rsquo; was &lt;strong&gt;successfully resolved&lt;/strong&gt; to &amp;lsquo;node_modules/typescript/lib/typescript.d.ts&amp;rsquo;. ========</target>
        </trans-unit>
        <trans-unit id="54948ed17588662885addef180b7ef879ed0c37c" translate="yes" xml:space="preserve">
          <source>======== Resolving module &lt;strong&gt;&amp;lsquo;typescript&amp;rsquo;&lt;/strong&gt; from &lt;strong&gt;&amp;lsquo;src/app.ts&amp;rsquo;&lt;/strong&gt;. ========</source>
          <target state="translated">======== Resolving module &lt;strong&gt;&amp;lsquo;typescript&amp;rsquo;&lt;/strong&gt; from &lt;strong&gt;&amp;lsquo;src/app.ts&amp;rsquo;&lt;/strong&gt;. ========</target>
        </trans-unit>
        <trans-unit id="d49ecc37e0ee034f2827da1fd607d32080808c90" translate="yes" xml:space="preserve">
          <source>@constructor</source>
          <target state="translated">@constructor</target>
        </trans-unit>
        <trans-unit id="1730f10972219035ab2f682b1ce4cece7df226d6" translate="yes" xml:space="preserve">
          <source>@extends</source>
          <target state="translated">@extends</target>
        </trans-unit>
        <trans-unit id="105f935c3c4b1ccfdad76f831916ed4a4587adbf" translate="yes" xml:space="preserve">
          <source>@param and @returns</source>
          <target state="translated">@param and @returns</target>
        </trans-unit>
        <trans-unit id="8ebf6ae3de6f1ca37540e2051a2b384cfa72a27f" translate="yes" xml:space="preserve">
          <source>@template</source>
          <target state="translated">@template</target>
        </trans-unit>
        <trans-unit id="ea9188bc22500c51ab1af4eb545fa93a9a0c4799" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;bare import&amp;rdquo; can be used to import a module only for its side-effects.</source>
          <target state="translated">&amp;ldquo;베어 임포트&amp;rdquo;는 부작용에 대해서만 모듈을 임포트하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ab96675e2c97989bb0f021cb50b90f4796d5235" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;// @ts-ignore&lt;/code&gt; comment suppresses all errors that originate on the following line. It is recommended practice to have the remainder of the comment following &lt;code&gt;@ts-ignore&lt;/code&gt; explain which error is being suppressed.</source>
          <target state="translated">&lt;code&gt;// @ts-ignore&lt;/code&gt; 코멘트는 다음과 같은 줄에 발생한 모든 오류를 억제한다. &lt;code&gt;@ts-ignore&lt;/code&gt; 다음에 주석의 나머지 부분에 어떤 오류가 억제되는지 설명하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6e0e525ad905e4c93bcdef14ca8854c2dbd392a9" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;class&lt;/code&gt; declaration</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 선언</target>
        </trans-unit>
        <trans-unit id="9321961f59ed7aa165b175642715594e39b66e6f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;function&lt;/code&gt; declaration</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; 선언</target>
        </trans-unit>
        <trans-unit id="cc5d6828693e8c2d48344e83137c9a8290909b26" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;namespace&lt;/code&gt; declaration can be used to add new types, values, and namespaces in any way which does not create a conflict.</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; 선언은 충돌을 생성하지 않는 방법으로 새로운 유형, 값 및 네임 스페이스를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dffc5c56bad813471caa1b06219f7ff387e0027" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;namespace&lt;/code&gt; or &lt;code&gt;module&lt;/code&gt; declaration which contains a value</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; 또는 &lt;code&gt;module&lt;/code&gt; 값을 포함 선언</target>
        </trans-unit>
        <trans-unit id="6f40f5525adb3d03f58f4422b7d66754c7565a18" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsconfig.json&lt;/code&gt; file can inherit configurations from another file using the &lt;code&gt;extends&lt;/code&gt; property.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 의 파일을 사용하여 다른 파일에서 구성을 상속 할 수 &lt;code&gt;extends&lt;/code&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="bac130cd7375d2fa70c0cad6b27e7077fed8791a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;tsconfig.json&lt;/code&gt; file is permitted to be completely empty, which compiles all files included by default (as described above) with the default compiler options.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 의 파일이 기본 컴파일러 옵션 (전술 한 바와 같이) 기본적으로 포함 된 모든 파일을 컴파일하는, 완전히 비어로 허용된다.</target>
        </trans-unit>
        <trans-unit id="2f15ae1c31705135e881325aff5e8a346aec850a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Class Decorator&lt;/em&gt; is declared just before a class declaration. The class decorator is applied to the constructor of the class and can be used to observe, modify, or replace a class definition. A class decorator cannot be used in a declaration file, or in any other ambient context (such as on a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">&lt;em&gt;클래스 실내 장식은&lt;/em&gt; 단지 클래스 선언하기 전에 선언된다. 클래스 데코레이터는 클래스의 생성자에 적용되며 클래스 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다. 클래스 데코레이터는 선언 파일이나 다른 주변 컨텍스트 (예 : &lt;code&gt;declare&lt;/code&gt; 클래스) 에서 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="739e90613eeebc5ddc5aad4956b450c569d06044" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Decorator&lt;/em&gt; is a special kind of declaration that can be attached to a &lt;a href=&quot;#class-decorators&quot;&gt;class declaration&lt;/a&gt;, &lt;a href=&quot;#method-decorators&quot;&gt;method&lt;/a&gt;, &lt;a href=&quot;#accessor-decorators&quot;&gt;accessor&lt;/a&gt;, &lt;a href=&quot;#property-decorators&quot;&gt;property&lt;/a&gt;, or &lt;a href=&quot;#parameter-decorators&quot;&gt;parameter&lt;/a&gt;. Decorators use the form &lt;code&gt;@expression&lt;/code&gt;, where &lt;code&gt;expression&lt;/code&gt; must evaluate to a function that will be called at runtime with information about the decorated declaration.</source>
          <target state="translated">&lt;em&gt;실내 장식은&lt;/em&gt; A를 부착 할 수 선언의 특별한 종류의 &lt;a href=&quot;#class-decorators&quot;&gt;클래스 선언&lt;/a&gt; , &lt;a href=&quot;#method-decorators&quot;&gt;방법&lt;/a&gt; , &lt;a href=&quot;#accessor-decorators&quot;&gt;접근&lt;/a&gt; , &lt;a href=&quot;#property-decorators&quot;&gt;재산&lt;/a&gt; , 또는 &lt;a href=&quot;#parameter-decorators&quot;&gt;매개 변수&lt;/a&gt; . 데코레이터는 &lt;code&gt;@expression&lt;/code&gt; 형식을 사용합니다 . 여기서 &lt;code&gt;expression&lt;/code&gt; 은 데코레이션 된 선언에 대한 정보와 함께 런타임에 호출 될 함수로 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9d56f6c32829ea8275bf6ee5b435cef5ea1f700d" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Method Decorator&lt;/em&gt; is declared just before a method declaration. The decorator is applied to the &lt;em&gt;Property Descriptor&lt;/em&gt; for the method, and can be used to observe, modify, or replace a method definition. A method decorator cannot be used in a declaration file, on an overload, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">&lt;em&gt;방법 실내 장식은&lt;/em&gt; 단지 메소드 선언하기 전에 선언된다. 데코레이터는 메소드 의 &lt;em&gt;특성 설명자&lt;/em&gt; 에 적용되며 메소드 정의를 관찰, 수정 또는 대체하는 데 사용할 수 있습니다. 메소드 데코레이터는 선언 파일, 오버로드 또는 기타 주변 환경 (예 : &lt;code&gt;declare&lt;/code&gt; 클래스)에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fccf751dfd4d98326bc686f6800698c46d17f29f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Parameter Decorator&lt;/em&gt; is declared just before a parameter declaration. The parameter decorator is applied to the function for a class constructor or method declaration. A parameter decorator cannot be used in a declaration file, an overload, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">&lt;em&gt;매개 변수 데코레이터는&lt;/em&gt; 단지 매개 변수 선언하기 전에 선언된다. 매개 변수 데코레이터는 클래스 생성자 또는 메소드 선언의 함수에 적용됩니다. 매개 변수 데코레이터는 선언 파일, 오버로드 또는 다른 주변 컨텍스트 (예 : &lt;code&gt;declare&lt;/code&gt; 클래스)에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9d07f771fa09284a877bbd7b7a8c2200cc1db787" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;Property Decorator&lt;/em&gt; is declared just before a property declaration. A property decorator cannot be used in a declaration file, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">&lt;em&gt;재산권 실내 장식은&lt;/em&gt; 단지 속성 선언하기 전에 선언된다. 속성 데코레이터는 선언 파일이나 다른 주변 컨텍스트 (예 : &lt;code&gt;declare&lt;/code&gt; 클래스) 에서 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5f6b5887333ec599f15cdbb7f6b7e41fb24767d5" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;UMD&lt;/em&gt; module is one that can &lt;em&gt;either&lt;/em&gt; be used as module (through an import), or as a global (when run in an environment without a module loader). Many popular libraries, such as &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;, are written this way. For example, in Node.js or using RequireJS, you would write:</source>
          <target state="translated">&lt;em&gt;UMD의&lt;/em&gt; 모듈은 가능 하나 &lt;em&gt;하나&lt;/em&gt; (가져 오기를 통해) 모듈로서 사용되거나, (a 모듈 로더없는 환경에서 실행하면) 전역있다. &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt; 와 같은 많은 인기있는 라이브러리 가 이런 식으로 작성되었습니다. 예를 들어 Node.js 또는 RequireJS를 사용하면 다음과 같이 작성합니다.</target>
        </trans-unit>
        <trans-unit id="2e831c596f2ba69b8fe1db558042cf1c087c1093" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;discriminant property type guard&lt;/em&gt; is an expression of the form &lt;code&gt;x.p == v&lt;/code&gt;, &lt;code&gt;x.p === v&lt;/code&gt;, &lt;code&gt;x.p != v&lt;/code&gt;, or &lt;code&gt;x.p !== v&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; are a property and an expression of a string literal type or a union of string literal types. The discriminant property type guard narrows the type of &lt;code&gt;x&lt;/code&gt; to those constituent types of &lt;code&gt;x&lt;/code&gt; that have a discriminant property &lt;code&gt;p&lt;/code&gt; with one of the possible values of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;판별 속성 유형 가드&lt;/em&gt; 형식의 표현이다 &lt;code&gt;x.p == v&lt;/code&gt; , &lt;code&gt;x.p === v&lt;/code&gt; , &lt;code&gt;x.p != v&lt;/code&gt; 또는 &lt;code&gt;x.p !== v&lt;/code&gt; , 여기서 &lt;code&gt;p&lt;/code&gt; 및 &lt;code&gt;v&lt;/code&gt; 특성 및 문자열 리터 형의 발현 또는 문자열 리터럴 유형의 결합 판별 속성 유형 가드 유형 좁아 &lt;code&gt;x&lt;/code&gt; 의 해당 구성 유형 &lt;code&gt;x&lt;/code&gt; 판별 속성이 &lt;code&gt;p&lt;/code&gt; 의 가능한 값 중 하나와 &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5af1a45bc532371f09945859192093e4e8e7412f" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;global plugin&lt;/em&gt; is global code that changes the shape of some global. As with &lt;em&gt;global-modifying modules&lt;/em&gt;, these raise the possibility of runtime conflict.</source>
          <target state="translated">&lt;em&gt;글로벌 플러그인은&lt;/em&gt; 일부 글로벌의 모양을 변경 글로벌 코드입니다. &lt;em&gt;전역 수정 모듈&lt;/em&gt; 과 마찬가지로 런타임 충돌 가능성이 높아집니다.</target>
        </trans-unit>
        <trans-unit id="2cc8c7dc8fcaba1930b06da38f845e8f6f69fa81" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;global-modifying module&lt;/em&gt; alters existing values in the global scope when they are imported. For example, there might exist a library which adds new members to &lt;code&gt;String.prototype&lt;/code&gt; when imported. This pattern is somewhat dangerous due to the possibility of runtime conflicts, but we can still write a declaration file for it.</source>
          <target state="translated">&lt;em&gt;글로벌 개량 모듈&lt;/em&gt; 전역 값을 기존 달라져들은 가져올 때. 예를 들어 가져올 때 &lt;code&gt;String.prototype&lt;/code&gt; 에 새 멤버를 추가하는 라이브러리가있을 수 있습니다 . 이 패턴은 런타임 충돌 가능성으로 인해 다소 위험하지만 여전히 선언 파일을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="feba008bb2bcd964cfc399bbc4dcc4618c8ee5e2" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;global&lt;/em&gt; library is one that can be accessed from the global scope (i.e. without using any form of &lt;code&gt;import&lt;/code&gt;). Many libraries simply expose one or more global variables for use. For example, if you were using &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, the &lt;code&gt;$&lt;/code&gt; variable can be used by simply referring to it:</source>
          <target state="translated">&lt;em&gt;글로벌&lt;/em&gt; 라이브러리 (즉, 어떤 형태의 사용하지 않고 세계적인 범위에서 액세스 할 수있는 하나입니다 &lt;code&gt;import&lt;/code&gt; ). 많은 라이브러리는 사용하기 위해 하나 이상의 전역 변수를 노출합니다. 예를 들어, &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; 를 사용 하는 경우 &lt;code&gt;$&lt;/code&gt; 변수는 간단히 참조하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2289bfc724a5518dc15e4cf5caddd6815845abb" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;module plugin&lt;/em&gt; changes the shape of another module (either UMD or module). For example, in Moment.js, &lt;code&gt;moment-range&lt;/code&gt; adds a new &lt;code&gt;range&lt;/code&gt; method to the &lt;code&gt;moment&lt;/code&gt; object.</source>
          <target state="translated">&lt;em&gt;모듈 플러그는&lt;/em&gt; 다른 모듈 (UMD 또는 모듈 중 하나)의 형상을 변화시킨다. 예를 들어 Moment.js에서 &lt;code&gt;moment-range&lt;/code&gt; 는 &lt;code&gt;moment&lt;/code&gt; 객체에 새로운 &lt;code&gt;range&lt;/code&gt; 메서드를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="36ef51072168e8fd07bcbf75e20f6fc4027a24cd" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;relative import&lt;/em&gt; is one that starts with &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;./&lt;/code&gt; or &lt;code&gt;../&lt;/code&gt;. Some examples include:</source>
          <target state="translated">&lt;em&gt;상대 가져 오기&lt;/em&gt; 시작이다 &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;./&lt;/code&gt; 또는 &lt;code&gt;../&lt;/code&gt; . 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b0f2d1642b6ff9d5026c5e25f91e02a415f34ce" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;mixin class&lt;/strong&gt; is a class declaration or expression that &lt;code&gt;extends&lt;/code&gt; an expression of a type parameter type. The following rules apply to mixin class declarations:</source>
          <target state="translated">&lt;strong&gt;믹스 인 클래스는&lt;/strong&gt; 클래스 선언 또는 표현 &lt;code&gt;extends&lt;/code&gt; 타입 파라미터 유형의 표현. 다음 규칙은 mixin 클래스 선언에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="bc78810f3bf6a5a9528d8023bc05c6167ef7eaf5" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;mixin constructor type&lt;/strong&gt; refers to a type that has a single construct signature with a single rest argument of type &lt;code&gt;any[]&lt;/code&gt; and an object-like return type. For example, given an object-like type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;new (...args: any[]) =&amp;gt; X&lt;/code&gt; is a mixin constructor type with an instance type &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;믹스 인 생성자 타입은&lt;/strong&gt; 타입의 단일 나머지 인자 단일 구조체 서명 갖는 형태를 의미 &lt;code&gt;any[]&lt;/code&gt; 와 같은 객체 리턴 타입. 예를 들어, 입력 물체를 부여 &lt;code&gt;X&lt;/code&gt; , &lt;code&gt;new (...args: any[]) =&amp;gt; X&lt;/code&gt; 인스턴스 타입와 믹스 인 생성자 타입 &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e3913101a43966f2ccebcc4061aa10428b79384" translate="yes" xml:space="preserve">
          <source>A Boolean value indicating that an object should be flattened to its array elements by Array.prototype.concat.</source>
          <target state="translated">Array.prototype.concat에 의해 객체가 배열 요소로 병합되어야 함을 나타내는 부울 값입니다.</target>
        </trans-unit>
        <trans-unit id="b6e0c2d8bf86efa81f30b4c26580fc67ebbeb4fa" translate="yes" xml:space="preserve">
          <source>A Note on Soundness</source>
          <target state="translated">건전성에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="1fed6c2698af466cd828f08e21a3d01c917783df" translate="yes" xml:space="preserve">
          <source>A String value that is used in the creation of the default string description of an object. Called by the built-in method &lt;code&gt;Object.prototype.toString&lt;/code&gt;.</source>
          <target state="translated">객체의 기본 문자열 설명을 만드는 데 사용되는 문자열 값입니다. 내장 메소드 &lt;code&gt;Object.prototype.toString&lt;/code&gt; 에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="7ef0b6dff4f7313a8976b0f0d521140ee41e223c" translate="yes" xml:space="preserve">
          <source>A build step will copy the files in &lt;code&gt;/src/views&lt;/code&gt; and &lt;code&gt;/generated/templates/views&lt;/code&gt; to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as &lt;code&gt;&quot;./template&quot;&lt;/code&gt;.</source>
          <target state="translated">빌드 단계는 &lt;code&gt;/src/views&lt;/code&gt; 및 &lt;code&gt;/generated/templates/views&lt;/code&gt; 의 파일을 출력의 동일한 디렉토리로 복사합니다 . 런타임시보기는 템플리트가 옆에 존재할 것으로 예상 할 수 있으므로 상대 이름을 &lt;code&gt;&quot;./template&quot;&lt;/code&gt; 으로 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="5e30e8a952193f7d1df77a0d6d1fd7f212ffd28d" translate="yes" xml:space="preserve">
          <source>A call to a generic function uses the arguments to infer the type parameters. Sometimes this process fails to infer any types, mainly because of lack of inference sources; in these cases, the type parameters will default to &lt;code&gt;any&lt;/code&gt;. For example:</source>
          <target state="translated">일반 함수에 대한 호출은 인수를 사용하여 유형 매개 변수를 유추합니다. 때때로이 프로세스는 주로 추론 소스가 없기 때문에 모든 유형을 추론하지 못합니다. 이 경우 유형 매개 변수는 기본적으로 &lt;code&gt;any&lt;/code&gt; 로 설정됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8884cee9c569ba73051b4c3340106f32892db818" translate="yes" xml:space="preserve">
          <source>A class constructor may be marked &lt;code&gt;private&lt;/code&gt; or &lt;code&gt;protected&lt;/code&gt;. A class with private constructor cannot be instantiated outside the class body, and cannot be extended. A class with protected constructor cannot be instantiated outside the class body, but can be extended.</source>
          <target state="translated">클래스 생성자는 &lt;code&gt;private&lt;/code&gt; 또는 &lt;code&gt;protected&lt;/code&gt; 로 표시 될 수 있습니다 . 전용 생성자가있는 클래스는 클래스 본문 외부에서 인스턴스화 할 수 없으며 확장 할 수 없습니다. 보호 생성자가있는 클래스는 클래스 본문 외부에서 인스턴스화 할 수 없지만 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="714c30cc5bf310cba2527f465ba3e4937c25903e" translate="yes" xml:space="preserve">
          <source>A class declaration (&lt;code&gt;class C { }&lt;/code&gt;)</source>
          <target state="translated">클래스 선언 ( &lt;code&gt;class C { }&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1596db92a712b48a7d481d2882462ab7d550ed38" translate="yes" xml:space="preserve">
          <source>A class or interface declaration that merges with an existing class or interface declaration may introduce a default for an existing type parameter.</source>
          <target state="translated">기존 클래스 또는 인터페이스 선언과 병합되는 클래스 또는 인터페이스 선언은 기존 유형 매개 변수의 기본값을 도입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe8ffa4d7e2dafe57b8f8b2aa2642caf1ac898fd" translate="yes" xml:space="preserve">
          <source>A class or interface declaration that merges with an existing class or interface declaration may introduce a new type parameter as long as it specifies a default.</source>
          <target state="translated">기존 클래스 또는 인터페이스 선언과 병합되는 클래스 또는 인터페이스 선언은 기본값을 지정하는 한 새 유형 매개 변수를 도입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e50811af3fd1732eb86ab44223050144ba8d75bb" translate="yes" xml:space="preserve">
          <source>A common and dangerous error is to forget to invoke a function, especially if the function has zero arguments or is named in a way that implies it might be a property rather than a function.</source>
          <target state="translated">일반적이고 위험한 오류는 함수를 호출하지 않는 것입니다. 특히 함수에 인수가 없거나 함수가 아닌 속성 일 수있는 방식으로 이름이 지정된 경우에 특히 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="804ef8425f60cc16494a3ecb8868620fc1d13254" translate="yes" xml:space="preserve">
          <source>A common mistake is to try to use the &lt;code&gt;/// &amp;lt;reference ... /&amp;gt;&lt;/code&gt; syntax to refer to a module file, rather than using an &lt;code&gt;import&lt;/code&gt; statement. To understand the distinction, we first need to understand how the compiler can locate the type information for a module based on the path of an &lt;code&gt;import&lt;/code&gt; (e.g. the &lt;code&gt;...&lt;/code&gt; in &lt;code&gt;import x from &quot;...&quot;;&lt;/code&gt;, &lt;code&gt;import x = require(&quot;...&quot;);&lt;/code&gt;, etc.) path.</source>
          <target state="translated">일반적인 실수는 &lt;code&gt;import&lt;/code&gt; 문을 사용하지 않고 &lt;code&gt;/// &amp;lt;reference ... /&amp;gt;&lt;/code&gt; 구문을 사용하여 모듈 파일을 참조하는 것 입니다. 차이를 이해하기 위해서, 우리는 먼저 필요 컴파일러가의 경로에 따라 모듈에 대한 형식 정보를 찾을 수있는 방법을 이해하기 위해 &lt;code&gt;import&lt;/code&gt; 예를 들어 ( &lt;code&gt;...&lt;/code&gt; 에서 &lt;code&gt;import x from &quot;...&quot;;&lt;/code&gt; , &lt;code&gt;import x = require(&quot;...&quot;);&lt;/code&gt; 등) 경로.</target>
        </trans-unit>
        <trans-unit id="dd6d372643d97ce6592522ce945c126f9d03b1c9" translate="yes" xml:space="preserve">
          <source>A common pattern in JavaScript is to use &lt;code&gt;typeof&lt;/code&gt; or &lt;code&gt;instanceof&lt;/code&gt; to examine the type of an expression at runtime. TypeScript now understands these conditions and will change type inference accordingly when used in an &lt;code&gt;if&lt;/code&gt; block.</source>
          <target state="translated">JavaScript의 일반적인 패턴은 &lt;code&gt;typeof&lt;/code&gt; 또는 &lt;code&gt;instanceof&lt;/code&gt; 를 사용 하여 런타임시 표현식의 유형을 검사하는 것입니다. TypeScript는 이제 이러한 조건을 이해하고 &lt;code&gt;if&lt;/code&gt; 블록 에서 사용될 때 유형 유추를 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="7d4ced30fbc2cc726d8b092795387c4127143776" translate="yes" xml:space="preserve">
          <source>A common task is to take an existing type and make each of its properties optional:</source>
          <target state="translated">일반적인 작업은 기존 유형을 사용하여 각 속성을 선택적으로 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f3a0349d4a486bbf82efbf586f7757d0e2680533" translate="yes" xml:space="preserve">
          <source>A common work around is to use an IIFE - an Immediately Invoked Function Expression - to capture &lt;code&gt;i&lt;/code&gt; at each iteration:</source>
          <target state="translated">일반적인 해결 방법은 IIFE (즉시 호출 된 함수 표현식)를 사용하여 각 반복에서 &lt;code&gt;i&lt;/code&gt; 를 캡처하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="80959b7998a3c5a6f92da1dbaffb14e14087102c" translate="yes" xml:space="preserve">
          <source>A conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt; is either &lt;em&gt;resolved&lt;/em&gt; to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or &lt;em&gt;deferred&lt;/em&gt; because the condition depends on one or more type variables. When &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;U&lt;/code&gt; contains type variables, whether to resolve to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or to defer, is determined by whether or not the type system has enough information to conclude that &lt;code&gt;T&lt;/code&gt; is always assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">조건부 유형 &lt;code&gt;T extends U ? X : Y&lt;/code&gt; 중입니다 &lt;em&gt;해결&lt;/em&gt; 에 &lt;code&gt;X&lt;/code&gt; 또는 &lt;code&gt;Y&lt;/code&gt; , 또는 &lt;em&gt;연기&lt;/em&gt; 조건이 하나 개 이상의 유형의 변수에 의존하기 때문에. 때 &lt;code&gt;T&lt;/code&gt; 또는 &lt;code&gt;U&lt;/code&gt; 가 있는지 여부에 해결하는 형태 변수가 포함 &lt;code&gt;X&lt;/code&gt; 또는 &lt;code&gt;Y&lt;/code&gt; 를 , 또는 연기, 타입 시스템이 있다는 결론을 내릴 수있는 충분한 정보가 있는지 여부에 따라 정해집니다 &lt;code&gt;T&lt;/code&gt; 는 항상에 할당 할 &lt;code&gt;U&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="a3ca32ef30629a0ef6871441758cc40ce1b420bb" translate="yes" xml:space="preserve">
          <source>A conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt; is either &lt;em&gt;resolved&lt;/em&gt; to &lt;code&gt;X&lt;/code&gt; or &lt;code&gt;Y&lt;/code&gt;, or &lt;em&gt;deferred&lt;/em&gt; because the condition depends on one or more type variables. Whether to resolve or defer is determined as follows:</source>
          <target state="translated">조건부 유형 &lt;code&gt;T extends U ? X : Y&lt;/code&gt; 중입니다 &lt;em&gt;해결&lt;/em&gt; 에 &lt;code&gt;X&lt;/code&gt; 또는 &lt;code&gt;Y&lt;/code&gt; , 또는 &lt;em&gt;연기&lt;/em&gt; 조건이 하나 개 이상의 유형의 변수에 의존하기 때문에. 해결 또는 연기 여부는 다음과 같이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="dcd55e1e2d504c4f5bd31948eb3ce7aa0ce3cb13" translate="yes" xml:space="preserve">
          <source>A constructor may also be marked &lt;code&gt;protected&lt;/code&gt;. This means that the class cannot be instantiated outside of its containing class, but can be extended. For example,</source>
          <target state="translated">생성자는 &lt;code&gt;protected&lt;/code&gt; 로 표시 될 수도 있습니다 . 이것은 클래스를 포함하는 클래스 외부에서 인스턴스화 할 수 없지만 확장 할 수 있음을 의미합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="cadb83f444b2961a4d934d5f3d490b70e4dd1268" translate="yes" xml:space="preserve">
          <source>A couple of limitations</source>
          <target state="translated">몇 가지 한계</target>
        </trans-unit>
        <trans-unit id="a24cf92f2108f7fc6dfb574930ec5df83db3eb0b" translate="yes" xml:space="preserve">
          <source>A couple of things to note about accessors:</source>
          <target state="translated">접근 자에 대해 참고할 사항 :</target>
        </trans-unit>
        <trans-unit id="e092fc815a872b9563a100f8c02b2d0d350825ab" translate="yes" xml:space="preserve">
          <source>A decorator is:</source>
          <target state="translated">데코레이터는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4f1b6da91369927675bbf031b2ce4d5a731e97d7" translate="yes" xml:space="preserve">
          <source>A destructuring declaration introduces one or more named variables and initializes them with values extracted from properties of an object or elements of an array.</source>
          <target state="translated">소멸 선언은 하나 이상의 명명 된 변수를 도입하고 객체의 속성 또는 배열의 요소에서 추출 된 값으로 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="bba8a48bfe00ec663b6ebb1eceade9d3fff1e679" translate="yes" xml:space="preserve">
          <source>A file whose only top-level declaration is &lt;code&gt;export namespace Foo { ... }&lt;/code&gt; (remove &lt;code&gt;Foo&lt;/code&gt; and move everything &amp;lsquo;up&amp;rsquo; a level)</source>
          <target state="translated">최상위 선언 만 &lt;code&gt;export namespace Foo { ... }&lt;/code&gt; ( &lt;code&gt;Foo&lt;/code&gt; 를 제거 하고 모든 레벨을 '위로'이동)</target>
        </trans-unit>
        <trans-unit id="1dc68bdd4f9a61f11fcf8696eedfc299f303d8bd" translate="yes" xml:space="preserve">
          <source>A function valued property that is the constructor function that is used to create derived objects.</source>
          <target state="translated">파생 개체를 만드는 데 사용되는 생성자 함수 인 함수 값 속성입니다.</target>
        </trans-unit>
        <trans-unit id="83ddd76ccda8c0cc52ac61d7fddcd8fcbe5f3cba" translate="yes" xml:space="preserve">
          <source>A function whose body has a reference to the &lt;code&gt;arguments&lt;/code&gt; reference is implicitly considered to have a var-arg parameter (i.e. &lt;code&gt;(...arg: any[]) =&amp;gt; any&lt;/code&gt;). Use JSDoc var-arg syntax to specify the type of the arguments.</source>
          <target state="translated">본문에 &lt;code&gt;arguments&lt;/code&gt; 참조에 대한 참조가 있는 함수 는 내재적으로 var-arg 매개 변수가있는 것으로 간주됩니다 (예 : &lt;code&gt;(...arg: any[]) =&amp;gt; any&lt;/code&gt; ). JSDoc var-arg 구문을 사용하여 인수 유형을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="0ea0b4e5327f594259519fd62a19b6890ab37c08" translate="yes" xml:space="preserve">
          <source>A function&amp;rsquo;s type has the same two parts: the type of the arguments and the return type. When writing out the whole function type, both parts are required. We write out the parameter types just like a parameter list, giving each parameter a name and a type. This name is just to help with readability. We could have instead written:</source>
          <target state="translated">함수의 타입은 인자의 타입과 리턴 타입의 두 부분이 동일합니다. 전체 기능 유형을 작성할 때 두 부분이 모두 필요합니다. 매개 변수 유형과 마찬가지로 매개 변수 유형을 작성하여 각 매개 변수에 이름과 유형을 지정합니다. 이 이름은 가독성을 돕기위한 것입니다. 대신 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6091230201a03184d43d1bf3ecad6c4e357aa7e8" translate="yes" xml:space="preserve">
          <source>A generator function can have a return type annotation, just like a function. The annotation represents the type of the generator returned by the function. Here is an example:</source>
          <target state="translated">생성기 함수는 함수와 마찬가지로 반환 유형 주석을 가질 수 있습니다. 주석은 함수가 반환 한 생성기 유형을 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3058f8f1fd4d84d69ca0c3d8c31e05fc06865a11" translate="yes" xml:space="preserve">
          <source>A generator function with no type annotation can have the type annotation inferred. So in the following case, the type will be inferred from the yield statements:</source>
          <target state="translated">타입 주석이없는 생성기 함수는 타입 주석을 유추 할 수 있습니다. 따라서 다음의 경우 유형은 yield 문에서 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="c6e63dbd0af2ae2aa5dc876191453fa9346622e3" translate="yes" xml:space="preserve">
          <source>A generic class has a similar shape to a generic interface. Generic classes have a generic type parameter list in angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;) following the name of the class.</source>
          <target state="translated">제네릭 클래스는 제네릭 인터페이스와 모양이 비슷합니다. 제네릭 클래스에는 클래스 이름 뒤에 꺾쇠 괄호 ( &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; ) 로 제네릭 형식 매개 변수 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="96453b7ccf72e8b01e41461635fa60edbe83b5ea" translate="yes" xml:space="preserve">
          <source>A generic parameter default follows the following rules:</source>
          <target state="translated">일반 매개 변수 기본값은 다음 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="d6264a6174402b53e580cc927dfee79a2d86c4b7" translate="yes" xml:space="preserve">
          <source>A handy feature of enums is that you can also go from a numeric value to the name of that value in the enum. For example, if we had the value &lt;code&gt;2&lt;/code&gt; but weren&amp;rsquo;t sure what that mapped to in the &lt;code&gt;Color&lt;/code&gt; enum above, we could look up the corresponding name:</source>
          <target state="translated">열거 형의 편리한 기능은 숫자 형 값에서 열거 형의 해당 값 이름으로 이동할 수도 있다는 것입니다. 예를 들어, 값이 &lt;code&gt;2&lt;/code&gt; 이지만 위 의 &lt;code&gt;Color&lt;/code&gt; 열거 형 에 매핑 된 것이 확실하지 않은 경우 해당 이름을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a3d8efbbf391dd508c0f59ddc90ddfd5e9cb8ce" translate="yes" xml:space="preserve">
          <source>A helpful addition to the standard set of datatypes from JavaScript is the &lt;code&gt;enum&lt;/code&gt;. As in languages like C#, an enum is a way of giving more friendly names to sets of numeric values.</source>
          <target state="translated">JavaScript의 표준 데이터 유형 집합에 유용한 추가 기능은 &lt;code&gt;enum&lt;/code&gt; 입니다. C #과 같은 언어에서와 같이 열거 형은 숫자 값 집합에 더 친숙한 이름을 부여하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ae627315bc177e68b8b178eb3fe934f925ae5a99" translate="yes" xml:space="preserve">
          <source>A key feature of modules in TypeScript is that two different modules will never contribute names to the same scope. Because the consumer of a module decides what name to assign it, there&amp;rsquo;s no need to proactively wrap up the exported symbols in a namespace.</source>
          <target state="translated">TypeScript에서 모듈의 주요 기능은 서로 다른 두 모듈이 동일한 범위에 이름을 제공하지 않는다는 것입니다. 모듈 소비자는 어떤 이름을 할당할지 결정하기 때문에 네임 스페이스에서 내 보낸 심볼을 사전에 마무리 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="10dfd449e653eb5c28991f082b6ab993db0f38fc" translate="yes" xml:space="preserve">
          <source>A library can consist of multiple modules, such as</source>
          <target state="translated">라이브러리는 다음과 같은 여러 모듈로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="408eb52ef9fae5ded272c34e2fb8532daf7f4ceb" translate="yes" xml:space="preserve">
          <source>A long-awaited feature is smart incremental builds for TypeScript projects. In 3.0 you can use the &lt;code&gt;--build&lt;/code&gt; flag with &lt;code&gt;tsc&lt;/code&gt;. This is effectively a new entry point for &lt;code&gt;tsc&lt;/code&gt; that behaves more like a build orchestrator than a simple compiler.</source>
          <target state="translated">오랫동안 기다려온 기능은 TypeScript 프로젝트를위한 스마트 한 증분 빌드입니다. 3.0에서는 &lt;code&gt;tsc&lt;/code&gt; 와 함께 &lt;code&gt;--build&lt;/code&gt; 플래그를 사용할 수 있습니다 . 이것은 사실상 간단한 컴파일러보다 빌드 오케 스트레이터처럼 동작 하는 &lt;code&gt;tsc&lt;/code&gt; 의 새로운 진입 점입니다 .</target>
        </trans-unit>
        <trans-unit id="bf50654387dec069aed329536e7230529d81996c" translate="yes" xml:space="preserve">
          <source>A major part of software engineering is building components that not only have well-defined and consistent APIs, but are also reusable. Components that are capable of working on the data of today as well as the data of tomorrow will give you the most flexible capabilities for building up large software systems.</source>
          <target state="translated">소프트웨어 엔지니어링의 주요 부분은 잘 정의되고 일관된 API가있을뿐 아니라 재사용 할 수있는 구성 요소를 구축하는 것입니다. 오늘날의 데이터와 미래의 데이터를 처리 할 수있는 구성 요소는 대규모 소프트웨어 시스템을 구축 할 수있는 가장 유연한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d9bcb6811c5b2878897a2775d961f00651e45117" translate="yes" xml:space="preserve">
          <source>A mapped type &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; permits any &lt;code&gt;K&lt;/code&gt; assignable to &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target state="translated">매핑 된 유형 &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; 는 모든 &lt;code&gt;K&lt;/code&gt; 를 &lt;code&gt;string | number | symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29451e8b78ccc3f4b9ac772135d8ff18632a054a" translate="yes" xml:space="preserve">
          <source>A method that converts an object to a corresponding primitive value. Called by the &lt;code&gt;ToPrimitive&lt;/code&gt; abstract operation.</source>
          <target state="translated">객체를 해당 프리미티브 값으로 변환하는 메서드입니다. &lt;code&gt;ToPrimitive&lt;/code&gt; 추상 연산에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="116f6b876af45833882c2bd0e4ed75e7920c3f86" translate="yes" xml:space="preserve">
          <source>A method that determines if a constructor object recognizes an object as one of the constructor&amp;rsquo;s instances. Called by the semantics of the instanceof operator.</source>
          <target state="translated">생성자 객체가 객체를 생성자의 인스턴스 중 하나로 인식하는지 여부를 결정하는 메서드입니다. instanceof 연산자의 시맨틱에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="790df4f5d480d1c7b853c049c80823994596880d" translate="yes" xml:space="preserve">
          <source>A method that returns the default iterator for an object. Called by the semantics of the for-of statement.</source>
          <target state="translated">객체의 기본 반복자를 반환하는 메서드입니다. 진술 문의 의미론에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="db447b4ab93c0844fc4e212f82c10b11c2a634ec" translate="yes" xml:space="preserve">
          <source>A modifier with no &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; prefix is the same as a modifier with a &lt;code&gt;+&lt;/code&gt; prefix. So, the &lt;code&gt;ReadonlyPartial&amp;lt;T&amp;gt;&lt;/code&gt; type above corresponds to</source>
          <target state="translated">아니오 개질제 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 프리픽스가 갖는 개질제와 동일 &lt;code&gt;+&lt;/code&gt; 의 접두사. 따라서 위 의 &lt;code&gt;ReadonlyPartial&amp;lt;T&amp;gt;&lt;/code&gt; 유형은</target>
        </trans-unit>
        <trans-unit id="3dbeca90d263824170468112465310c954b28b6b" translate="yes" xml:space="preserve">
          <source>A module name will be computed for each module based on its relative location to &lt;code&gt;rootDir&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rootDir&lt;/code&gt; 에 대한 상대 위치를 기반으로 각 모듈에 대해 모듈 이름이 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="8fcfc7285f1ba3d870a6928e1733a7273fde019a" translate="yes" xml:space="preserve">
          <source>A more advanced example uses the prototype property to infer and constrain relationships between the constructor function and the instance side of class types.</source>
          <target state="translated">고급 예제에서는 prototype 속성을 사용하여 생성자 함수와 클래스 유형의 인스턴스 측 간의 관계를 유추하고 제한합니다.</target>
        </trans-unit>
        <trans-unit id="51dd9695c995c08645a93f5859af50c64ef61af8" translate="yes" xml:space="preserve">
          <source>A more common error that this feature catches is adding a newline after a &lt;code&gt;return&lt;/code&gt; statement:</source>
          <target state="translated">이 기능이 포착하는 더 일반적인 오류는 &lt;code&gt;return&lt;/code&gt; 문 다음에 줄 바꿈을 추가하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="02309890136fe9803436c2b1bde34201107f663d" translate="yes" xml:space="preserve">
          <source>A namespace &lt;code&gt;X&lt;/code&gt; (because the &lt;code&gt;namespace&lt;/code&gt; declaration contains a type, &lt;code&gt;Y&lt;/code&gt;)</source>
          <target state="translated">네임 스페이스 &lt;code&gt;X&lt;/code&gt; ( &lt;code&gt;namespace&lt;/code&gt; 선언에 유형 &lt;code&gt;Y&lt;/code&gt; 가 포함 되므로 )</target>
        </trans-unit>
        <trans-unit id="7ae465077e189312db19e43d1c7bdbb04e391e9f" translate="yes" xml:space="preserve">
          <source>A namespace &lt;code&gt;Z&lt;/code&gt;</source>
          <target state="translated">네임 스페이스 &lt;code&gt;Z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77bbec5ff2f5cfc37ba667daafc8343e4c27cc4d" translate="yes" xml:space="preserve">
          <source>A namespace import (i.e. &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt;) is now correctly flagged as uncallable. Calling it will result in an error.</source>
          <target state="translated">네임 스페이스 가져 오기 (즉 &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt; )가 호출 할 수없는 것으로 올바르게 플래그 지정되었습니다. 호출하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2830a5f5ce7dd5eaff83de00bb84188237d5ac6f" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;!&lt;/code&gt; post-fix expression operator may be used to assert that its operand is non-null and non-undefined in contexts where the type checker is unable to conclude that fact. Specifically, the operation &lt;code&gt;x!&lt;/code&gt; produces a value of the type of &lt;code&gt;x&lt;/code&gt; with &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; excluded. Similar to type assertions of the forms &lt;code&gt;&amp;lt;T&amp;gt;x&lt;/code&gt; and &lt;code&gt;x as T&lt;/code&gt;, the &lt;code&gt;!&lt;/code&gt; non-null assertion operator is simply removed in the emitted JavaScript code.</source>
          <target state="translated">새로운 &lt;code&gt;!&lt;/code&gt; post-fix expression operator는 타입 체커가 그 사실을 결론 지을 수없는 상황에서 피연산자가 널이 아니며 정의되지 않았 음을 주장하기 위해 사용될 수있다. 구체적으로, 연산 &lt;code&gt;x!&lt;/code&gt; 의 형식의 값 생성 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 가 배제한다. 형태의 유사한 유형 주장하는 &lt;code&gt;&amp;lt;T&amp;gt;x&lt;/code&gt; 및 &lt;code&gt;x as T&lt;/code&gt; 상기 &lt;code&gt;!&lt;/code&gt; 널이 아닌 어설 션 연산자는 생성 된 JavaScript 코드에서 간단히 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2655be7a46ceb733d0fd15d66bae85ebe5cb1eb1" translate="yes" xml:space="preserve">
          <source>A new flag is also added in TypeScript 2.0 to flag all uses of &lt;code&gt;this&lt;/code&gt; in functions without an explicit type annotation.</source>
          <target state="translated">TypeScript 2.0에 새로운 플래그가 추가되어 명시적인 타입 주석없이 함수 &lt;code&gt;this&lt;/code&gt; 플래그의 모든 사용을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="9ce3e808c856b4c4b90bbc578b4afa30e7e8a218" translate="yes" xml:space="preserve">
          <source>A new syntax for &lt;code&gt;ReadonlyArray&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;ReadonlyArray&lt;/code&gt; 의 새로운 구문</target>
        </trans-unit>
        <trans-unit id="4571ad9d84c9c7959037752a1b8faca40bbe10a7" translate="yes" xml:space="preserve">
          <source>A nightly build from the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/tree/master&quot;&gt;TypeScript&amp;rsquo;s &lt;code&gt;master&lt;/code&gt;&lt;/a&gt; branch is published by midnight PST to NPM and NuGet. Here is how you can get it and use it with your tools.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Microsoft/TypeScript/tree/master&quot;&gt;TypeScript의 &lt;code&gt;master&lt;/code&gt; &lt;/a&gt; 브랜치 에서 야간 빌드는 자정 PST에 의해 NPM 및 NuGet에 게시됩니다. 다음은 도구를 사용하여 사용하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="03a025aabca041d8656b9b41a0f1be5a93ff1fe1" translate="yes" xml:space="preserve">
          <source>A non-relative import can be resolved relative to &lt;code&gt;baseUrl&lt;/code&gt;, or through path mapping, which we&amp;rsquo;ll cover below. They can also resolve to &lt;a href=&quot;modules#ambient-modules&quot;&gt;ambient module declarations&lt;/a&gt;. Use non-relative paths when importing any of your external dependencies.</source>
          <target state="translated">상대가 아닌 가져 오기는 &lt;code&gt;baseUrl&lt;/code&gt; 과 관련하여 또는 경로 매핑을 통해 해결할 수 있습니다 . 또한 &lt;a href=&quot;modules#ambient-modules&quot;&gt;주변 모듈 선언으로&lt;/a&gt; 해결할 수 있습니다 . 외부 종속성을 가져올 때 상대 경로가 아닌 경로를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="036c7405ac8596f3f842074ad7095463b1af061e" translate="yes" xml:space="preserve">
          <source>A non-relative import to &lt;code&gt;moduleB&lt;/code&gt; such as &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt;, in a source file &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt;, would result in attempting the following locations for locating &lt;code&gt;&quot;moduleB&quot;&lt;/code&gt;:</source>
          <target state="translated">에 비 상대 수입 &lt;code&gt;moduleB&lt;/code&gt; 같은 &lt;code&gt;import { b } from &quot;moduleB&quot;&lt;/code&gt; 소스 파일에서, &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt; 는 , 위치의 다음 위치 시도 될 것 &lt;code&gt;&quot;moduleB&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="908464f8d4f6e5d96a7983c65456609769299d87" translate="yes" xml:space="preserve">
          <source>A note about &amp;lsquo;let&amp;rsquo;</source>
          <target state="translated">'let'에 대한 메모</target>
        </trans-unit>
        <trans-unit id="bfe7c80c1a11cfefa188943b94c8dce4cafd7212" translate="yes" xml:space="preserve">
          <source>A note about &lt;code&gt;let&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="34d8d6a247e4459c0dd02162269341b98212407d" translate="yes" xml:space="preserve">
          <source>A partial version of it would be:</source>
          <target state="translated">그것의 부분 버전은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0dc358ce5550ca2f28f0b4972670dc958c4e4327" translate="yes" xml:space="preserve">
          <source>A polymorphic &lt;code&gt;this&lt;/code&gt; type represents a type that is the &lt;em&gt;subtype&lt;/em&gt; of the containing class or interface. This is called &lt;em&gt;F&lt;/em&gt;-bounded polymorphism. This makes hierarchical fluent interfaces much easier to express, for example. Take a simple calculator that returns &lt;code&gt;this&lt;/code&gt; after each operation:</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 유형 의 다형성 은 포함하는 클래스 또는 인터페이스 의 &lt;em&gt;하위 유형&lt;/em&gt; 인 유형을 나타냅니다 . 이것을 &lt;em&gt;F&lt;/em&gt; 경계 다형성 이라고 합니다. 예를 들어, 계층 적으로 유창한 인터페이스를 표현하기가 훨씬 쉽습니다. 각 작업 후에 &lt;code&gt;this&lt;/code&gt; 반환하는 간단한 계산기를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4bfc09c2ed20b76aa6a3b9cc810f2a50f0733568" translate="yes" xml:space="preserve">
          <source>A project source layout sometimes does not match that of the output. Usually a set of build steps result in generating the final output. These include compiling &lt;code&gt;.ts&lt;/code&gt; files into &lt;code&gt;.js&lt;/code&gt;, and copying dependencies from different source locations to a single output location. The net result is that modules at runtime may have different names than the source files containing their definitions. Or module paths in the final output may not match their corresponding source file paths at compile time.</source>
          <target state="translated">프로젝트 소스 레이아웃이 출력 레이아웃과 일치하지 않는 경우가 있습니다. 일반적으로 일련의 빌드 단계는 최종 출력을 생성합니다. 여기에는 &lt;code&gt;.ts&lt;/code&gt; 파일을 &lt;code&gt;.js&lt;/code&gt; 로 컴파일 하고 다른 소스 위치에서 단일 출력 위치로 종속성을 복사 하는 작업이 포함 됩니다. 결과적으로 런타임시 모듈의 정의가 들어있는 소스 파일과 이름이 다를 수 있습니다. 또는 최종 출력의 모듈 경로가 컴파일 타임에 해당 소스 파일 경로와 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="282c27706098563c877f1ff268884923d740e395" translate="yes" xml:space="preserve">
          <source>A property access or a function call produces a compile-time error if the object or function is of a type that includes &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. However, type guards are extended to support non-null and non-undefined checks.</source>
          <target state="translated">객체 또는 함수가 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 를 포함하는 유형 인 경우 속성 액세스 또는 함수 호출로 컴파일 타임 오류가 발생합니다 . 그러나 유형 가드는 널이 아닌 정의되지 않은 검사를 지원하도록 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="59344ab2361c175ea781e369233d17a3ef1173a2" translate="yes" xml:space="preserve">
          <source>A property declared with a &lt;code&gt;get&lt;/code&gt; accessor and no &lt;code&gt;set&lt;/code&gt; accessor is considered read-only.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 접근 자와 함께 선언되고 &lt;code&gt;set&lt;/code&gt; 접근자가 없는 속성은 읽기 전용으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b689c46a292974d609ea79412658e0ee92a02aed" translate="yes" xml:space="preserve">
          <source>A property or index signature can now be declared with the &lt;code&gt;readonly&lt;/code&gt; modifier is considered read-only.</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 수정자를 사용하여 속성 또는 인덱스 서명을 선언 할 수 있으며 이제 읽기 전용 으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="3d52bcb9c5e9671606eed7fffb194263c9890a7a" translate="yes" xml:space="preserve">
          <source>A regular expression method that matches the regular expression against a string. Called by the &lt;code&gt;String.prototype.match&lt;/code&gt; method.</source>
          <target state="translated">정규식을 문자열과 비교하는 정규식 메소드입니다. &lt;code&gt;String.prototype.match&lt;/code&gt; 메소드에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="9cd6edb9d65460dc36b50f0399530c31b1e87d57" translate="yes" xml:space="preserve">
          <source>A regular expression method that replaces matched substrings of a string. Called by the &lt;code&gt;String.prototype.replace&lt;/code&gt; method.</source>
          <target state="translated">일치하는 문자열의 하위 문자열을 대체하는 정규식 메소드입니다. &lt;code&gt;String.prototype.replace&lt;/code&gt; 메소드에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="58d5cbe9a0d4a216822033b575ab84161f890fd4" translate="yes" xml:space="preserve">
          <source>A regular expression method that returns the index within a string that matches the regular expression. Called by the &lt;code&gt;String.prototype.search&lt;/code&gt; method.</source>
          <target state="translated">정규식과 일치하는 문자열 내에서 인덱스를 반환하는 정규식 메서드입니다. &lt;code&gt;String.prototype.search&lt;/code&gt; 메소드에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="38d40fad27af50b9cfc4c1b7935edd018faa338e" translate="yes" xml:space="preserve">
          <source>A regular expression method that splits a string at the indices that match the regular expression. Called by the &lt;code&gt;String.prototype.split&lt;/code&gt; method.</source>
          <target state="translated">정규식과 일치하는 인덱스에서 문자열을 분할하는 정규식 메서드입니다. &lt;code&gt;String.prototype.split&lt;/code&gt; 메소드에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc17888ce2ecd41d7b6b0d5fb3a3670f069072bf" translate="yes" xml:space="preserve">
          <source>A relative import is resolved relative to the importing file and &lt;em&gt;cannot&lt;/em&gt; resolve to an ambient module declaration. You should use relative imports for your own modules that are guaranteed to maintain their relative location at runtime.</source>
          <target state="translated">상대 가져 오기는 가져 오기 파일을 기준으로 해결되며 앰비언트 모듈 선언으로 해결할 &lt;em&gt;수 없습니다&lt;/em&gt; . 런타임시 상대 위치를 유지하려면 자신의 모듈에 대해 상대 가져 오기를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="28de4947ee9f22a7989c024ed424c3f367678816" translate="yes" xml:space="preserve">
          <source>A relative import will be resolved relative to the importing file. So &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; in source file &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt; would result in the following lookups:</source>
          <target state="translated">가져 오기 파일을 기준으로 상대 가져 오기가 해결됩니다. 그래서 &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; 소스 파일에 &lt;code&gt;/root/src/folder/A.ts&lt;/code&gt; 는 다음과 같은 조회가 발생할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="d9edb5186e2748078674706a60a9cf32f84d1333" translate="yes" xml:space="preserve">
          <source>A rest parameter is permitted to have a generic type that is constrained to an array type, and type inference can infer tuple types for such generic rest parameters. This enables higher-order capturing and spreading of partial parameter lists:</source>
          <target state="translated">rest 매개 변수는 배열 유형으로 제한되는 일반 유형을 가질 수 있으며 유형 유추는 이러한 일반 rest 매개 변수에 대한 튜플 유형을 유추 할 수 있습니다. 이를 통해 부분 매개 변수 목록의 고차 캡처 및 확산이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="cf7553b7e9850da0e4309ead9e8788fc38bf0c98" translate="yes" xml:space="preserve">
          <source>A simple rule to follow is to only declare types &lt;em&gt;namespaced&lt;/em&gt; by whatever global variable the library defines. For example, if the library defines the global value &amp;lsquo;cats&amp;rsquo;, you should write</source>
          <target state="translated">따라야 할 간단한 규칙 은 라이브러리가 정의한 전역 변수로 &lt;em&gt;네임 스페이스&lt;/em&gt; 가 지정된 유형 만 선언 하는 것입니다. 예를 들어, 라이브러리가 글로벌 값 'cats'를 정의하면 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="70f69678357ce810ac7be6d3a7871e410f98bb81" translate="yes" xml:space="preserve">
          <source>A triple-slash reference path is resolved relative to the containing file, if unrooted.</source>
          <target state="translated">루트가없는 경우 삼중 슬래시 참조 경로는 포함 파일을 기준으로 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="353474e46afb00c48588800a3c6d0c5342041035" translate="yes" xml:space="preserve">
          <source>A tsconfig.json file that doesn&amp;rsquo;t specify a files property (and therefore implicitly references all *.ts files in all subdirectories) can now contain an exclude property that specifies a list of files and/or directories to exclude from the compilation. The exclude property must be an array of strings that each specify a file or folder name relative to the location of the tsconfig.json file. For example:</source>
          <target state="translated">files 속성을 지정하지 않는 tsconfig.json 파일 (따라서 모든 하위 디렉토리의 모든 * .ts 파일을 암시 적으로 참조)에는 컴파일에서 제외 할 파일 및 / 또는 디렉토리 목록을 지정하는 exclude 속성이 포함될 수 있습니다. exclude 특성은 각각 tsconfig.json 파일의 위치를 ​​기준으로 파일 또는 폴더 이름을 지정하는 문자열 배열이어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="df0d20ca9dd32bdd7425a8bf1f2869e727193b73" translate="yes" xml:space="preserve">
          <source>A tuple type permits an element to be omitted if it has a postfix &lt;code&gt;?&lt;/code&gt; modifier on its type and all elements to the right of it also have &lt;code&gt;?&lt;/code&gt; modifiers.</source>
          <target state="translated">튜플 형식은 요소에 접미사 &lt;code&gt;?&lt;/code&gt; 가 있으면 생략 할 수 있습니다 . 그것의 타입과 그것의 오른쪽에있는 모든 요소에도 수정자가 &lt;code&gt;?&lt;/code&gt; 수정 자.</target>
        </trans-unit>
        <trans-unit id="c0fda59c87a9ce8c6218af973a8a318d8c48726a" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;C&lt;/code&gt; in the &lt;code&gt;X.Z&lt;/code&gt; namespace</source>
          <target state="translated">A 형 &lt;code&gt;C&lt;/code&gt; 에서 &lt;code&gt;X.Z&lt;/code&gt; 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="8b8cb0beae34b84268f8712bb01776f705387774" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 형</target>
        </trans-unit>
        <trans-unit id="882188abb4f22a21291e791a69d7bc7153c6ea49" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;Y&lt;/code&gt; in the &lt;code&gt;X&lt;/code&gt; namespace</source>
          <target state="translated">A 형 &lt;code&gt;Y&lt;/code&gt; 에서 &lt;code&gt;X&lt;/code&gt; 의 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="74378f84a7232e7c818036a1aa4f8e790357dad0" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;Z&lt;/code&gt; in the &lt;code&gt;X&lt;/code&gt; namespace (the instance shape of the class)</source>
          <target state="translated">A 형 &lt;code&gt;Z&lt;/code&gt; 에서 &lt;code&gt;X&lt;/code&gt; 의 네임 스페이스 (클래스의 인스턴스 모양)</target>
        </trans-unit>
        <trans-unit id="c1687cc1f239d5cbfef8dd21147b9dd24d76a0c8" translate="yes" xml:space="preserve">
          <source>A type alias declaration (&lt;code&gt;type sn = number | string;&lt;/code&gt;)</source>
          <target state="translated">타입 별칭 선언 ( &lt;code&gt;type sn = number | string;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="bf4c2689d169ce1d458db13d7d40fdbf2f6b6244" translate="yes" xml:space="preserve">
          <source>A type alias that takes the union of those types &amp;mdash; the &lt;em&gt;union&lt;/em&gt;.</source>
          <target state="translated">이러한 유형의 조합을 소요 유형 별칭 - &lt;em&gt;조합&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5f2efd539d70b51bc5ae0611e5b848813a9078c1" translate="yes" xml:space="preserve">
          <source>A type can include an index signature to explicitly indicate that excess properties are permitted:</source>
          <target state="translated">유형에는 초과 특성이 허용됨을 명시 적으로 나타내는 색인 서명이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22c383b7f56821c1f9a53cd7d2c78316dfd7e93b" translate="yes" xml:space="preserve">
          <source>A type guard for a dotted name has no effect following an assignment to any part of the dotted name. For example, a type guard for &lt;code&gt;x.y.z&lt;/code&gt; will have no effect following an assignment to &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;x.y&lt;/code&gt;, or &lt;code&gt;x.y.z&lt;/code&gt;.</source>
          <target state="translated">점으로 구분 된 이름에 대한 유형 보호는 점으로 구분 된 이름의 일부에 할당 된 후에도 적용되지 않습니다. 예를 들어, &lt;code&gt;x.y.z&lt;/code&gt; 대한 type guard는 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;x.y&lt;/code&gt; 또는 &lt;code&gt;x.y.z&lt;/code&gt; 대한 할당 후에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3a377432dffa8ea7066844e2455d6987bca2958f" translate="yes" xml:space="preserve">
          <source>A type parameter is deemed optional if it has a default.</source>
          <target state="translated">유형 매개 변수는 기본값이있는 경우 선택 사항으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0d14b0d6b21fc7288313f91b187510fabde9b646" translate="yes" xml:space="preserve">
          <source>A types package is a folder with a file called &lt;code&gt;index.d.ts&lt;/code&gt; or a folder with a &lt;code&gt;package.json&lt;/code&gt; that has a &lt;code&gt;types&lt;/code&gt; field.</source>
          <target state="translated">유형 패키지는 &lt;code&gt;index.d.ts&lt;/code&gt; 라는 파일이있는 폴더 또는 &lt;code&gt;types&lt;/code&gt; 필드 가있는 &lt;code&gt;package.json&lt;/code&gt; 이 있는 폴더입니다 .</target>
        </trans-unit>
        <trans-unit id="14d41e9733c26726f7735bdd4c4e805ad6e0b738" translate="yes" xml:space="preserve">
          <source>A union type describes a value that can be one of several types. We use the vertical bar (&lt;code&gt;|&lt;/code&gt;) to separate each type, so &lt;code&gt;number | string | boolean&lt;/code&gt; is the type of a value that can be a &lt;code&gt;number&lt;/code&gt;, a &lt;code&gt;string&lt;/code&gt;, or a &lt;code&gt;boolean&lt;/code&gt;.</source>
          <target state="translated">공용체 유형은 여러 유형 중 하나 일 수있는 값을 설명합니다. 수직 막대 ( &lt;code&gt;|&lt;/code&gt; )를 사용하여 각 유형을 구분하므로 &lt;code&gt;number | string | boolean&lt;/code&gt; 은 &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; 또는 &lt;code&gt;boolean&lt;/code&gt; 일 수있는 값의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="77032b55ce2cb4248190b5e5184e5e0b38ee393b" translate="yes" xml:space="preserve">
          <source>A user could express &lt;code&gt;2 * 5 + 1&lt;/code&gt; as</source>
          <target state="translated">사용자는 다음 과 같이 &lt;code&gt;2 * 5 + 1&lt;/code&gt; 을 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="199d562e0a71e63f245aa31f49c36513d849c222" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;C&lt;/code&gt; that is a property of the &lt;code&gt;X.Z&lt;/code&gt; value</source>
          <target state="translated">&lt;code&gt;X.Z&lt;/code&gt; 값 의 속성 인 값 &lt;code&gt;C&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21e079e6071fdb5e16a79cbbbac36f7c59e77e29" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;X&lt;/code&gt; (because the &lt;code&gt;namespace&lt;/code&gt; declaration contains a value, &lt;code&gt;Z&lt;/code&gt;)</source>
          <target state="translated">값 &lt;code&gt;X&lt;/code&gt; ( &lt;code&gt;namespace&lt;/code&gt; 선언에 값 &lt;code&gt;Z&lt;/code&gt; 가 포함 되므로 )</target>
        </trans-unit>
        <trans-unit id="72326d369b07efe650b4c687b18320a6555b7a1a" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;Y&lt;/code&gt; (of type &lt;code&gt;number&lt;/code&gt;) that is a property of the &lt;code&gt;X&lt;/code&gt; value</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 값 의 속성 인 값 &lt;code&gt;Y&lt;/code&gt; (유형 &lt;code&gt;number&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2db8707fec6d748cc12ab97735dc5f33a19182c2" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;Z&lt;/code&gt; that is a property of the &lt;code&gt;X&lt;/code&gt; value</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 값 의 속성 인 값 &lt;code&gt;Z&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03ce9a077fea19a3768255595563e3f325b99287" translate="yes" xml:space="preserve">
          <source>A value &lt;code&gt;Z&lt;/code&gt; that is a property of the &lt;code&gt;X&lt;/code&gt; value (the constructor function of the class)</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 값 의 속성 인 값 &lt;code&gt;Z&lt;/code&gt; (클래스의 생성자 함수)</target>
        </trans-unit>
        <trans-unit id="2ac5e8f9f24c7489cdb9a76f63355463e38d2ed2" translate="yes" xml:space="preserve">
          <source>A variable declared with no type annotation and an initial value of &lt;code&gt;[]&lt;/code&gt; is considered an implicit &lt;code&gt;any[]&lt;/code&gt; variable. However, each subsequent &lt;code&gt;x.push(value)&lt;/code&gt;, &lt;code&gt;x.unshift(value)&lt;/code&gt; or &lt;code&gt;x[n] = value&lt;/code&gt; operation &lt;em&gt;evolves&lt;/em&gt; the type of the variable in accordance with what elements are added to it.</source>
          <target state="translated">형식 주석없이 선언되고 초기 값 &lt;code&gt;[]&lt;/code&gt; 은 (는) 암시적인 &lt;code&gt;any[]&lt;/code&gt; 변수로 간주됩니다 . 그러나 각 후속 &lt;code&gt;x.push(value)&lt;/code&gt; , &lt;code&gt;x.unshift(value)&lt;/code&gt; 또는 &lt;code&gt;x[n] = value&lt;/code&gt; 연산 은 추가 된 요소에 따라 변수 유형을 &lt;em&gt;발전&lt;/em&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="70d19e4c7a5fa9d0f738254cc159113f3fd200b2" translate="yes" xml:space="preserve">
          <source>AMD / RequireJS SimpleModule.js</source>
          <target state="translated">AMD / RequireJS SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="d64764987e4f302df4936aa982040ba263c5581e" translate="yes" xml:space="preserve">
          <source>AMD Module names</source>
          <target state="translated">AMD 모듈 이름</target>
        </trans-unit>
        <trans-unit id="b4e985e77edef4f93404d5e6768643dd9e768f9b" translate="yes" xml:space="preserve">
          <source>AMD-dependency optional names</source>
          <target state="translated">AMD 종속 옵션 이름</target>
        </trans-unit>
        <trans-unit id="62845d0d9af23cbc1eec333eb2ecfd163d55a726" translate="yes" xml:space="preserve">
          <source>API Changes</source>
          <target state="translated">API 변경</target>
        </trans-unit>
        <trans-unit id="512a3dad0b0ce90df79e253450f20d82200891c0" translate="yes" xml:space="preserve">
          <source>APIs to Support &lt;code&gt;--build&lt;/code&gt; and &lt;code&gt;--incremental&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--build&lt;/code&gt; 및 &lt;code&gt;--incremental&lt;/code&gt; 을 지원하는 API</target>
        </trans-unit>
        <trans-unit id="f34de1e75f36d287ab4c87ba0a5a432c79f048d4" translate="yes" xml:space="preserve">
          <source>ASP.NET Core</source>
          <target state="translated">ASP.NET 코어</target>
        </trans-unit>
        <trans-unit id="366e9dcb2473f425157fef0b4dc8e68450d4a527" translate="yes" xml:space="preserve">
          <source>ASP.NET Core + TypeScript</source>
          <target state="translated">ASP.NET Core + TypeScript</target>
        </trans-unit>
        <trans-unit id="fd2bfb743d58034cf4f2ef0407bda4991e6e266a" translate="yes" xml:space="preserve">
          <source>ASP.NET Core: Add TypeScript</source>
          <target state="translated">ASP.NET Core : TypeScript 추가</target>
        </trans-unit>
        <trans-unit id="26ca92c515719697094cd865e18cbd056f86e90b" translate="yes" xml:space="preserve">
          <source>ASP.NET Core: Setup</source>
          <target state="translated">ASP.NET 코어 : 설정</target>
        </trans-unit>
        <trans-unit id="8462d6e971391c5728bd5c55cd114f6c45225c83" translate="yes" xml:space="preserve">
          <source>Above, all inferences for &lt;code&gt;T&lt;/code&gt; originate in contravariant positions, and we therefore infer the &lt;em&gt;best common subtype&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt;. This contrasts with inferences from covariant positions, where we infer the &lt;em&gt;best common supertype&lt;/em&gt;.</source>
          <target state="translated">위에서 &lt;code&gt;T&lt;/code&gt; 에 대한 모든 추론 은 반 변형 위치에서 시작되므로 &lt;code&gt;T&lt;/code&gt; 에 대한 &lt;em&gt;가장 일반적인 하위 유형&lt;/em&gt; 을 유추합니다 . 이것은 우리가 &lt;em&gt;가장 일반적인 수퍼 타입&lt;/em&gt; 을 추론하는 공변량 위치로부터의 추론과 대조된다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d99c638eab09eef692bca448341109f58d65928f" translate="yes" xml:space="preserve">
          <source>Above, we have a &lt;code&gt;StringArray&lt;/code&gt; interface that has an index signature. This index signature states that when a &lt;code&gt;StringArray&lt;/code&gt; is indexed with a &lt;code&gt;number&lt;/code&gt;, it will return a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">위에는 인덱스 서명 이있는 &lt;code&gt;StringArray&lt;/code&gt; 인터페이스가 있습니다. 이 인덱스 서명은 &lt;code&gt;StringArray&lt;/code&gt; 가 &lt;code&gt;number&lt;/code&gt; 로 색인화 되면 &lt;code&gt;string&lt;/code&gt; 을 리턴한다는 것을 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="29268223f69d326a5adbf22aa200f48337d3383a" translate="yes" xml:space="preserve">
          <source>Above, we have a numeric enum where &lt;code&gt;Up&lt;/code&gt; is initialized with &lt;code&gt;1&lt;/code&gt;. All of the following members are auto-incremented from that point on. In other words, &lt;code&gt;Direction.Up&lt;/code&gt; has the value &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;Down&lt;/code&gt; has &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;Left&lt;/code&gt; has &lt;code&gt;3&lt;/code&gt;, and &lt;code&gt;Right&lt;/code&gt; has &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">위의 &lt;code&gt;Up&lt;/code&gt; 은 &lt;code&gt;1&lt;/code&gt; 로 초기화 되는 숫자 열거 형이 있습니다. 그 시점부터 다음 멤버가 모두 자동 증가됩니다. 즉, &lt;code&gt;Direction.Up&lt;/code&gt; 의 값은 &lt;code&gt;1&lt;/code&gt; 이고, &lt;code&gt;Down&lt;/code&gt; 의 값 은 &lt;code&gt;2&lt;/code&gt; 이고, &lt;code&gt;Left&lt;/code&gt; 의 값 은 &lt;code&gt;3&lt;/code&gt; 이고, &lt;code&gt;Right&lt;/code&gt; 의 값 은 &lt;code&gt;4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="af4c6101610761ea26e2cfbf041a94da323abdcc" translate="yes" xml:space="preserve">
          <source>Abstract Classes</source>
          <target state="translated">추상 클래스</target>
        </trans-unit>
        <trans-unit id="92d2d55c032fde11e5fb12992c8af2dbab612b6c" translate="yes" xml:space="preserve">
          <source>Abstract classes are base classes from which other classes may be derived. They may not be instantiated directly. Unlike an interface, an abstract class may contain implementation details for its members. The &lt;code&gt;abstract&lt;/code&gt; keyword is used to define abstract classes as well as abstract methods within an abstract class.</source>
          <target state="translated">추상 클래스는 다른 클래스가 파생 될 수있는 기본 클래스입니다. 직접 인스턴스화 할 수 없습니다. 인터페이스와 달리 추상 클래스에는 멤버에 대한 구현 세부 정보가 포함될 수 있습니다. &lt;code&gt;abstract&lt;/code&gt; 키워드는 추상 클래스에서 추상 클래스뿐만 아니라 추상적 인 방법을 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="90c7ee5a4b4ef6e67fa95b9c12e51b21561cd41f" translate="yes" xml:space="preserve">
          <source>Abstract properties and accessors</source>
          <target state="translated">추상 속성 및 접근 자</target>
        </trans-unit>
        <trans-unit id="bc1eac0b05aa68bdf95d2d14137e5c9213052598" translate="yes" xml:space="preserve">
          <source>Accept JavaScript files as inputs (with &lt;code&gt;allowJs&lt;/code&gt;).</source>
          <target state="translated">JavaScript 파일을 입력으로 허용하십시오 ( &lt;code&gt;allowJs&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="f52e0a010fa39d93f5775a9f132d6deb5746c842" translate="yes" xml:space="preserve">
          <source>Accessing an element outside the set of known indices fails with an error:</source>
          <target state="translated">알려진 인덱스 집합 외부의 요소에 액세스하면 오류가 발생하여 실패합니다.</target>
        </trans-unit>
        <trans-unit id="9211673b68532807a6d2c852f45d3d0a3786afaf" translate="yes" xml:space="preserve">
          <source>Accessor Decorators</source>
          <target state="translated">접근 자 데코레이터</target>
        </trans-unit>
        <trans-unit id="f5b0e226ed894764db92e76b6c1f1203c0b805bb" translate="yes" xml:space="preserve">
          <source>Accessors</source>
          <target state="translated">Accessors</target>
        </trans-unit>
        <trans-unit id="ba917141f6a1280321df068fb903677e998c5655" translate="yes" xml:space="preserve">
          <source>Add TypeScript</source>
          <target state="translated">TypeScript 추가</target>
        </trans-unit>
        <trans-unit id="03f2f0c4f330f17bca1624a3a414eba729371bb6" translate="yes" xml:space="preserve">
          <source>Add TypeScript code</source>
          <target state="translated">TypeScript 코드 추가</target>
        </trans-unit>
        <trans-unit id="2826bcb0cd82d31aa891fcd966fb1d7028f4f052" translate="yes" xml:space="preserve">
          <source>Add a TypeScript configuration file</source>
          <target state="translated">TypeScript 구성 파일 추가</target>
        </trans-unit>
        <trans-unit id="d15c277560e45ee3069031db7b1443def54bf1e5" translate="yes" xml:space="preserve">
          <source>Add an index signature to the weak type (i.e. &lt;code&gt;[propName: string]: {}&lt;/code&gt;).</source>
          <target state="translated">약한 유형 (예 : &lt;code&gt;[propName: string]: {}&lt;/code&gt; )에 색인 서명을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="d86f6887abf355322f84124fc796c5eca75b3b63" translate="yes" xml:space="preserve">
          <source>Add example code</source>
          <target state="translated">예제 코드 추가</target>
        </trans-unit>
        <trans-unit id="030eb6eab9d9ce5260b44edf17a0969d1e22a783" translate="yes" xml:space="preserve">
          <source>Add modules to the code</source>
          <target state="translated">코드에 모듈 추가</target>
        </trans-unit>
        <trans-unit id="0897ccd0a932866daaf546a1ee6c09bc49494aa1" translate="yes" xml:space="preserve">
          <source>Add the following code to the &lt;code&gt;app.ts&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;app.ts&lt;/code&gt; 파일에 다음 코드를 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="3d2583d632f0a677d9ba11848beebe77e200bfeb" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;tsconfig.json&lt;/code&gt; file in a directory indicates that the directory is the root of a TypeScript project. The tsconfig.json file specifies the root files and the compiler options required to compile the project. A project is compiled in one of the following ways:</source>
          <target state="translated">디렉토리에 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일을 추가 하면 디렉토리가 TypeScript 프로젝트의 루트임을 나타냅니다. tsconfig.json 파일은 프로젝트를 컴파일하는 데 필요한 루트 파일 및 컴파일러 옵션을 지정합니다. 프로젝트는 다음 방법 중 하나로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="7dbea2ea77887f1c86da0aa25a3f25ac23ead618" translate="yes" xml:space="preserve">
          <source>Adding using a &lt;code&gt;namespace&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; 사용하여 추가</target>
        </trans-unit>
        <trans-unit id="51ec7e9fd3e27aeb0e50a50e1368f25d547f3a58" translate="yes" xml:space="preserve">
          <source>Adding using an &lt;code&gt;interface&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;interface&lt;/code&gt; 사용하여 추가</target>
        </trans-unit>
        <trans-unit id="b365969c1cff42268e57d78eee550841c3962e45" translate="yes" xml:space="preserve">
          <source>Additional module resolution flags</source>
          <target state="translated">추가 모듈 확인 플래그</target>
        </trans-unit>
        <trans-unit id="5bc0373dbdf9447ae6c7d80c2c34b8dc3091badc" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450&quot;&gt;another caveat&lt;/a&gt; of this new functionality is that due to certain limitations, &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; can&amp;rsquo;t yet fully model generic functions or functions that have overloads. When using these methods on a generic function, type parameters will be substituted with the empty object type (&lt;code&gt;{}&lt;/code&gt;), and when used on a function with overloads, only the last overload will ever be modeled.</source>
          <target state="translated">또한 이 새로운 기능의 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/27028#issuecomment-429334450&quot;&gt;또 다른 단점&lt;/a&gt; 은 특정 제한으로 인해 &lt;code&gt;bind&lt;/code&gt; , &lt;code&gt;call&lt;/code&gt; 및 &lt;code&gt;apply&lt;/code&gt; 가 오버로드가있는 일반 함수 나 함수를 아직 완전히 모델링 할 수 없다는 것입니다. 일반 함수에서 이러한 메소드를 사용하는 경우 유형 매개 변수는 빈 오브젝트 유형 ( &lt;code&gt;{}&lt;/code&gt; ) 으로 대체 되며 과부하가있는 함수에 사용될 경우 마지막 과부하 만 모델링됩니다.</target>
        </trans-unit>
        <trans-unit id="c8c07f0e3695aef1b4eb4f9692657a313d0394be" translate="yes" xml:space="preserve">
          <source>Additionally, generators just assumed the type of &lt;code&gt;yield&lt;/code&gt; was always &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">또한 발전기는 &lt;code&gt;yield&lt;/code&gt; 유형 이 항상 &lt;code&gt;any&lt;/code&gt; 라고 가정했습니다 .</target>
        </trans-unit>
        <trans-unit id="9897d524bc1adaf827ec23a4f3fb80edccd67b36" translate="yes" xml:space="preserve">
          <source>Additionally, the &lt;code&gt;JSX.IntrinsicAttributes&lt;/code&gt; interface can be used to specify extra properties used by the JSX framework which are not generally used by the components&amp;rsquo; props or arguments - for instance &lt;code&gt;key&lt;/code&gt; in React. Specializing further, the generic &lt;code&gt;JSX.IntrinsicClassAttributes&amp;lt;T&amp;gt;&lt;/code&gt; type may also be used to specify the same kind of extra attributes just for class components (and not Function Components). In this type, the generic parameter corresponds to the class instance type. In React, this is used to allow the &lt;code&gt;ref&lt;/code&gt; attribute of type &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt;. Generally speaking, all of the properties on these interfaces should be optional, unless you intend that users of your JSX framework need to provide some attribute on every tag.</source>
          <target state="translated">또한 &lt;code&gt;JSX.IntrinsicAttributes&lt;/code&gt; 인터페이스를 사용하면 JSX 프레임 워크에서 사용하는 추가 속성 (예 : React의 &lt;code&gt;key&lt;/code&gt; 와 같이 구성 요소의 소품 또는 인수에 의해 일반적으로 사용되지 않는)을 지정할 수 있습니다 . 더 나아가서, 일반 &lt;code&gt;JSX.IntrinsicClassAttributes&amp;lt;T&amp;gt;&lt;/code&gt; 타입은 클래스 컴포넌트 (함수 컴포넌트가 아닌)에 대해서만 동일한 종류의 추가 속성을 지정하는 데 사용될 수 있습니다. 이 유형에서 일반 매개 변수는 클래스 인스턴스 유형에 해당합니다. React에서 &lt;code&gt;Ref&amp;lt;T&amp;gt;&lt;/code&gt; 유형 의 &lt;code&gt;ref&lt;/code&gt; 속성 을 허용하는 데 사용됩니다.. 일반적으로 JSX 프레임 워크 사용자가 모든 태그에 일부 속성을 제공해야하는 경우가 아니라면 이러한 인터페이스의 모든 특성은 선택 사항이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b91aefeee6c1829819327d9dfe82ea027b26c097" translate="yes" xml:space="preserve">
          <source>Additionally, to preserve compatibility with existing build workflows, &lt;code&gt;tsc&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; automatically build dependencies unless invoked with the &lt;code&gt;--build&lt;/code&gt; switch. Let&amp;rsquo;s learn more about &lt;code&gt;--build&lt;/code&gt;.</source>
          <target state="translated">또한 기존 빌드 워크 플로우와의 호환성을 유지하기 위해 &lt;code&gt;tsc&lt;/code&gt; 는 &lt;code&gt;--build&lt;/code&gt; 스위치를 사용 하지 않으면 자동으로 종속성을 빌드 &lt;em&gt;하지 않습니다&lt;/em&gt; . &lt;code&gt;--build&lt;/code&gt; 에 대해 더 배워 봅시다 .</target>
        </trans-unit>
        <trans-unit id="aeb5aba76318fd8538ec6382a2c356952caebc47" translate="yes" xml:space="preserve">
          <source>Adjustments in module resolution logic</source>
          <target state="translated">모듈 확인 로직 조정</target>
        </trans-unit>
        <trans-unit id="051f9a673eec5b48c922324c96f3a02ca352b664" translate="yes" xml:space="preserve">
          <source>Advanced Combinations</source>
          <target state="translated">고급 조합</target>
        </trans-unit>
        <trans-unit id="af1b06d1c8791683bf16e52630b903baefea447c" translate="yes" xml:space="preserve">
          <source>Advanced Techniques</source>
          <target state="translated">고급 기술</target>
        </trans-unit>
        <trans-unit id="0d7049ed333121f6ad65eac902c5a2d1cec948e8" translate="yes" xml:space="preserve">
          <source>Advanced Topics</source>
          <target state="translated">고급 주제</target>
        </trans-unit>
        <trans-unit id="ae95896c3a125d9a5e8ed95928ac9721dd8d3752" translate="yes" xml:space="preserve">
          <source>Advanced Types</source>
          <target state="translated">고급 유형</target>
        </trans-unit>
        <trans-unit id="54113ef438de5a4b862decfc768acf29d440c666" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;bundle&lt;/code&gt; we use &lt;code&gt;source&lt;/code&gt; (our alias for vinyl-source-stream) to name our output bundle &lt;code&gt;bundle.js&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bundle&lt;/code&gt; 을 호출 한 후 &lt;code&gt;source&lt;/code&gt; (비닐 소스 스트림의 별명)를 사용하여 출력 번들 이름을 &lt;code&gt;bundle.js&lt;/code&gt; 로 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="90f00e5874f2361b655fbe3423460af4e2465d08" translate="yes" xml:space="preserve">
          <source>After that, you&amp;rsquo;ll be able to import lodash with no issues, and get accurate completions.</source>
          <target state="translated">그런 다음 문제없이 lodash를 가져 와서 정확하게 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06c3fc331ac388b23fddf0085ca5e76cb6b8d9ba" translate="yes" xml:space="preserve">
          <source>After you should see an &lt;code&gt;npm&lt;/code&gt; folder in your solution explorer</source>
          <target state="translated">솔루션 탐색기에 &lt;code&gt;npm&lt;/code&gt; 폴더 가 표시되면</target>
        </trans-unit>
        <trans-unit id="b4510f26185d545e1f9aaebb5b614087f1eb1769" translate="yes" xml:space="preserve">
          <source>Again, being explicit, the following things create values:</source>
          <target state="translated">다시 말하지만, 다음과 같은 것들이 가치를 창출합니다.</target>
        </trans-unit>
        <trans-unit id="5eae1c48b28511e25caa33f05cb9d4dfab638b20" translate="yes" xml:space="preserve">
          <source>Again, the above code is equivalent to the following.</source>
          <target state="translated">다시, 위 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1bf3fd22ac6a36d88878ca8d53a1d82c01a94dc2" translate="yes" xml:space="preserve">
          <source>Again, we&amp;rsquo;ve used &lt;code&gt;Bar&lt;/code&gt; as both a type and a value here. Note that we didn&amp;rsquo;t have to declare the &lt;code&gt;Bar&lt;/code&gt; value as being of the &lt;code&gt;Bar&lt;/code&gt; type &amp;ndash; they&amp;rsquo;re independent.</source>
          <target state="translated">여기서도 &lt;code&gt;Bar&lt;/code&gt; 를 유형과 값으로 모두 사용 했습니다. &lt;code&gt;Bar&lt;/code&gt; 값을 &lt;code&gt;Bar&lt;/code&gt; 유형 으로 선언 할 필요는 없습니다 . 독립형입니다.</target>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes" xml:space="preserve">
          <source>Aliases</source>
          <target state="translated">Aliases</target>
        </trans-unit>
        <trans-unit id="3cb27e3d6bbfd0f085fdbe02b42dec5e1744a340" translate="yes" xml:space="preserve">
          <source>Aliasing doesn&amp;rsquo;t actually create a new type - it creates a new &lt;em&gt;name&lt;/em&gt; to refer to that type. Aliasing a primitive is not terribly useful, though it can be used as a form of documentation.</source>
          <target state="translated">앨리어싱은 실제로 새 유형을 만들지 않습니다 . 해당 유형을 참조하기 위해 새 &lt;em&gt;이름&lt;/em&gt; 을 만듭니다 . 프리미티브 앨리어싱은 문서 형태로 사용될 수 있지만별로 유용하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d6c399afd60c09e251a03e83d9bc9a1c384d822" translate="yes" xml:space="preserve">
          <source>All dependencies are managed by npm. Make sure all the declaration packages you depend on are marked appropriately in the &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; section in your &lt;code&gt;package.json&lt;/code&gt;. For example, imagine we authored a package that used Browserify and TypeScript.</source>
          <target state="translated">모든 종속성은 npm에 의해 관리됩니다. 의존하는 모든 선언 패키지가 &lt;code&gt;package.json&lt;/code&gt; 의 &lt;code&gt;&quot;dependencies&quot;&lt;/code&gt; 섹션에 적절하게 표시되어 있는지 확인하십시오 . 예를 들어 Browserify 및 TypeScript를 사용하는 패키지를 작성했다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="45d806df121ff13261ffaf919876e11a01813f29" translate="yes" xml:space="preserve">
          <source>All implementation files must be matched by an &lt;code&gt;include&lt;/code&gt; pattern or listed in the &lt;code&gt;files&lt;/code&gt; array. If this constraint is violated, &lt;code&gt;tsc&lt;/code&gt; will inform you which files weren&amp;rsquo;t specified</source>
          <target state="translated">모든 구현 파일은 &lt;code&gt;include&lt;/code&gt; 패턴 과 일치 하거나 &lt;code&gt;files&lt;/code&gt; 배열에 나열되어야합니다 . 이 제한 조건을 위반하면, &lt;code&gt;tsc&lt;/code&gt; 는 지정되지 않은 파일을 알려줍니다</target>
        </trans-unit>
        <trans-unit id="1cd3b6e7826e2d43235c94e25c6703e5515d96cd" translate="yes" xml:space="preserve">
          <source>All imports from a shorthand module will have the &lt;code&gt;any&lt;/code&gt; type.</source>
          <target state="translated">속기 모듈에서 가져온 &lt;code&gt;any&lt;/code&gt; 유형 은 모든 유형 을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="1a0df7a5916e9a8c72882caaac651848e0eeba01" translate="yes" xml:space="preserve">
          <source>All imports from a shorthand module will have the any type.</source>
          <target state="translated">속기 모듈에서 가져온 모든 유형은 모든 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="fee6f3b1a8be543040dd1ce13fd64e1e346a330f" translate="yes" xml:space="preserve">
          <source>All imports to any module under &lt;code&gt;myLibrary&lt;/code&gt; would be considered to have the type &lt;code&gt;any&lt;/code&gt; by the compiler; thus, shutting down any checking on the shapes or types of these modules.</source>
          <target state="translated">아래의 모든 모듈의 모든 수입 &lt;code&gt;myLibrary&lt;/code&gt; 유형 것으로 간주 될 수 &lt;code&gt;any&lt;/code&gt; 컴파일러에 의해을; 따라서 이러한 모듈의 모양이나 유형에 대한 점검을 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="f57b961e5b675a38b262426fe4a67078aecb1477" translate="yes" xml:space="preserve">
          <source>All of the following are red flags for module structuring. Double-check that you&amp;rsquo;re not trying to namespace your external modules if any of these apply to your files:</source>
          <target state="translated">다음은 모두 모듈 구조화를위한 위험 신호입니다. 다음 중 하나라도 파일에 적용되는 경우 외부 모듈의 네임 스페이스를 만들지 않는지 다시 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5f48504d51c20fbd89324cd74339cdb9e81a6c89" translate="yes" xml:space="preserve">
          <source>All relative paths found in the configuration file will be resolved relative to the configuration file they originated in.</source>
          <target state="translated">구성 파일에서 찾은 모든 상대 경로는 원래 구성 파일과 관련하여 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="315057eae22d62b0d6ed2f001a47c88ccf49ba08" translate="yes" xml:space="preserve">
          <source>All the strictness flags (including just &lt;code&gt;strict&lt;/code&gt;)</source>
          <target state="translated">모든 엄격 플래그 ( &lt;code&gt;strict&lt;/code&gt; 포함 )</target>
        </trans-unit>
        <trans-unit id="11378de3ed9317ae1cc9f1d37c886e6088970d68" translate="yes" xml:space="preserve">
          <source>AllValidators.ts</source>
          <target state="translated">AllValidators.ts</target>
        </trans-unit>
        <trans-unit id="a20b06e157c57d9a78b57caf9d2b542ef2e984fd" translate="yes" xml:space="preserve">
          <source>Allow JavaScript files to be compiled.</source>
          <target state="translated">JavaScript 파일을 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="817e523690a2903bd65bba96f5e1a75cd990d338" translate="yes" xml:space="preserve">
          <source>Allow accessing UMD globals from modules.</source>
          <target state="translated">모듈에서 UMD 글로벌에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe8c273574466d1f1e8e48a9866bca1049e958da" translate="yes" xml:space="preserve">
          <source>Allow captured &lt;code&gt;let&lt;/code&gt;/&lt;code&gt;const&lt;/code&gt; in loops</source>
          <target state="translated">루프에서 캡처 된 &lt;code&gt;let&lt;/code&gt; / &lt;code&gt;const&lt;/code&gt; 허용</target>
        </trans-unit>
        <trans-unit id="0313de72619ba05b9f37beba9bc65ea42f27f39d" translate="yes" xml:space="preserve">
          <source>Allow comments in tsconfig.json</source>
          <target state="translated">tsconfig.json에서 주석 허용</target>
        </trans-unit>
        <trans-unit id="243a0709c425e1dcc854b129a4e90d01a36f16eb" translate="yes" xml:space="preserve">
          <source>Allow default imports from modules with no default export. This does not affect code emit, just typechecking.</source>
          <target state="translated">기본 내보내기가없는 모듈에서 기본 가져 오기를 허용합니다. 이것은 코드 방출에 영향을 미치지 않으며 형식 검사에만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="2fe77e2c3c1c895a9de9714c2ee0a698b6a26f2c" translate="yes" xml:space="preserve">
          <source>Allow duplicate identifiers across declarations</source>
          <target state="translated">선언에서 중복 식별자 허용</target>
        </trans-unit>
        <trans-unit id="c3d79af7df869c57746cb28085bd6d2457c5fb38" translate="yes" xml:space="preserve">
          <source>Allowed Values</source>
          <target state="translated">허용되는 값</target>
        </trans-unit>
        <trans-unit id="13463866162e9452fc9466d99aed31c7a984ccdc" translate="yes" xml:space="preserve">
          <source>Along with setting &lt;code&gt;--strict&lt;/code&gt; on by default, &lt;code&gt;tsc --init&lt;/code&gt; has an enhanced output. Default &lt;code&gt;tsconfig.json&lt;/code&gt; files generated by &lt;code&gt;tsc --init&lt;/code&gt; now include a set of the common compiler options along with their descriptions commented out. Just un-comment the configuration you like to set to get the desired behavior; we hope the new output simplifies the setting up new projects and keeps configuration files readable as projects grow.</source>
          <target state="translated">설정과 함께 &lt;code&gt;--strict&lt;/code&gt; , 기본적으로에 &lt;code&gt;tsc --init&lt;/code&gt; 향상된 출력을 가지고있다. &lt;code&gt;tsc --init&lt;/code&gt; 에 의해 생성 된 기본 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일 에는 이제 설명과 함께 공통 컴파일러 옵션 세트가 포함됩니다. 원하는 동작을 얻기 위해 설정하려는 구성의 주석을 해제하십시오. 우리는 새로운 결과물이 새로운 프로젝트 설정을 단순화하고 프로젝트가 증가함에 따라 구성 파일을 읽을 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="000392e9a54edfab5429407c52d48703930eb447" translate="yes" xml:space="preserve">
          <source>Along with traditional OO hierarchies, another popular way of building up classes from reusable components is to build them by combining simpler partial classes. You may be familiar with the idea of mixins or traits for languages like Scala, and the pattern has also reached some popularity in the JavaScript community.</source>
          <target state="translated">전통적인 OO 계층과 함께 재사용 가능한 구성 요소에서 클래스를 구성하는 또 다른 일반적인 방법은 간단한 부분 클래스를 결합하여 클래스를 작성하는 것입니다. 스칼라와 같은 언어에 대한 믹스 인 또는 특성에 대한 개념에 익숙 할 수 있으며 패턴은 JavaScript 커뮤니티에서 어느 정도 인기를 얻었습니다.</target>
        </trans-unit>
        <trans-unit id="d76c0268868384341c5ebe547b3dfcde453c7e8e" translate="yes" xml:space="preserve">
          <source>Also functions that are only called within their own bodies are considered unused.</source>
          <target state="translated">자신의 몸 안에서만 호출되는 함수는 사용되지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="540904303a257559b0aeb7e9b92f1cd1b53941db" translate="yes" xml:space="preserve">
          <source>Also important to note is that &lt;code&gt;bigint&lt;/code&gt;s produce a new string when using the &lt;code&gt;typeof&lt;/code&gt; operator: the string &lt;code&gt;&quot;bigint&quot;&lt;/code&gt;. Thus, TypeScript correctly narrows using &lt;code&gt;typeof&lt;/code&gt; as you&amp;rsquo;d expect.</source>
          <target state="translated">또한 참고로 중요한 점이다 &lt;code&gt;bigint&lt;/code&gt; 사용하는 경우의 새로운 문자열을 생성 &lt;code&gt;typeof&lt;/code&gt; 문자열 : 운영자 &lt;code&gt;&quot;bigint&quot;&lt;/code&gt; . 따라서 TypeScript는 예상대로 &lt;code&gt;typeof&lt;/code&gt; 를 사용하여 올바르게 좁 힙니다 .</target>
        </trans-unit>
        <trans-unit id="fdd80e664a9b3ce76fb4d4f379a35bae6ecbe4f1" translate="yes" xml:space="preserve">
          <source>Also note that if your main declaration file is named &lt;code&gt;index.d.ts&lt;/code&gt; and lives at the root of the package (next to &lt;code&gt;index.js&lt;/code&gt;) you do not need to mark the &lt;code&gt;&quot;types&quot;&lt;/code&gt; property, though it is advisable to do so.</source>
          <target state="translated">또한 기본 선언 파일의 이름이 &lt;code&gt;index.d.ts&lt;/code&gt; 이고 패키지의 루트 ( &lt;code&gt;index.js&lt;/code&gt; 옆 )에있는 경우 &lt;code&gt;&quot;types&quot;&lt;/code&gt; 속성 을 표시 할 필요 는 없지만 그렇게하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1b4972f01952c5c6e56d36346995929543d00951" translate="yes" xml:space="preserve">
          <source>Also note that when passing &lt;code&gt;--skipDefaultLibCheck&lt;/code&gt;, the compiler will only skip checking files with &lt;code&gt;/// &amp;lt;reference no-default-lib=&quot;true&quot;/&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--skipDefaultLibCheck&lt;/code&gt; 를 전달할 때 컴파일러는 &lt;code&gt;/// &amp;lt;reference no-default-lib=&quot;true&quot;/&amp;gt;&lt;/code&gt; 파일 검사 만 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="6107d072614a65187bd05ede831a6df1fe3accb4" translate="yes" xml:space="preserve">
          <source>Also of note, the use of &lt;code&gt;public&lt;/code&gt; on arguments to the constructor is a shorthand that allows us to automatically create properties with that name.</source>
          <target state="translated">또한 생성자에 대한 인수 에 &lt;code&gt;public&lt;/code&gt; 을 사용 하면 해당 이름으로 속성을 자동으로 만들 수있는 축약 형입니다.</target>
        </trans-unit>
        <trans-unit id="cffaed40200024bd111a6ac8089de97648f831c1" translate="yes" xml:space="preserve">
          <source>Also see our wiki page on &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file&quot;&gt;using a custom language service file&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Dev-Mode-in-Visual-Studio#using-a-custom-language-service-file&quot;&gt;사용자 정의 언어 서비스 파일 사용&lt;/a&gt; 에 대한 위키 페이지도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="776519898394bb463eff6e30826aacacc1c3da0d" translate="yes" xml:space="preserve">
          <source>Also, a nightly NuGet package to match the &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/07/27/introducing-typescript-nightlies.aspx&quot;&gt;nightly npm package&lt;/a&gt; is available on &lt;a href=&quot;https://myget.org&quot;&gt;myget&lt;/a&gt;:</source>
          <target state="translated">또한 &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/07/27/introducing-typescript-nightlies.aspx&quot;&gt;야간 npm 패키지&lt;/a&gt; 와 일치하는 야간 NuGet 패키지 는 &lt;a href=&quot;https://myget.org&quot;&gt;myget에서&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92083d2d24448d6d4118e25e1f3cea32d46ea66c" translate="yes" xml:space="preserve">
          <source>Alternatively, we can use per-file compilation (the default) to emit one JavaScript file for each input file. If multiple JS files get produced, we&amp;rsquo;ll need to use &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags on our webpage to load each emitted file in the appropriate order, for example:</source>
          <target state="translated">또는 파일 별 컴파일 (기본값)을 사용하여 각 입력 파일에 대해 하나의 JavaScript 파일을 생성 할 수 있습니다. 여러 JS 파일이 생성되는 경우 웹 페이지에서 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 를 사용 하여 방출 된 각 파일을 적절한 순서로로드해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d4887b96a506ca1d0dee1e635003357f0a6d33ea" translate="yes" xml:space="preserve">
          <source>Alternatively, you can just say &lt;code&gt;options&lt;/code&gt; has the type &lt;code&gt;any&lt;/code&gt; which is the easiest thing to do, but which will benefit you the least.</source>
          <target state="translated">양자 택일로, 당신은 말할 단지 수 있습니다 &lt;code&gt;options&lt;/code&gt; 유형이 &lt;code&gt;any&lt;/code&gt; 할 수있는 쉬운 일이지만, 당신에게 가장 도움이되는.</target>
        </trans-unit>
        <trans-unit id="43606c68a4c7cf72a0b682885c31d5f52ead2334" translate="yes" xml:space="preserve">
          <source>Alternatives:</source>
          <target state="translated">Alternatives:</target>
        </trans-unit>
        <trans-unit id="8b0c73776c390d3a5733d04f89fdf034e34ec53e" translate="yes" xml:space="preserve">
          <source>Although JavaScript modules do not support merging, you can patch existing objects by importing and then updating them. Let&amp;rsquo;s look at a toy Observable example:</source>
          <target state="translated">JavaScript 모듈은 병합을 지원하지 않지만 기존 객체를 가져오고 업데이트하여 패치 할 수 있습니다. 장난감 Observable 예제를 보자 :</target>
        </trans-unit>
        <trans-unit id="dee099122cb78c5739b4f82dcc4924480f635a80" translate="yes" xml:space="preserve">
          <source>Ambient Classes and Functions Can Merge</source>
          <target state="translated">주변 클래스 및 함수가 병합 될 수 있음</target>
        </trans-unit>
        <trans-unit id="6b6f848cded8d022fa12717b22d3680a848ad354" translate="yes" xml:space="preserve">
          <source>Ambient Modules</source>
          <target state="translated">주변 모듈</target>
        </trans-unit>
        <trans-unit id="4a2667f9b3defd3ff5b3a3b96ac30b540f477156" translate="yes" xml:space="preserve">
          <source>Ambient Namespaces</source>
          <target state="translated">주변 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="072993bc8b201bfe9df293be81dcb3aa09bada66" translate="yes" xml:space="preserve">
          <source>Ambient enums</source>
          <target state="translated">주변 열거 형</target>
        </trans-unit>
        <trans-unit id="13d6b6f06f272969887a807bdfd8080d800b8ed3" translate="yes" xml:space="preserve">
          <source>Ambient enums are used to describe the shape of already existing enum types.</source>
          <target state="translated">앰비언트 열거 형은 기존의 열거 형 유형의 모양을 설명하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="66df472a2808c10e6e2267da8ee23d33589aa345" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;enum&lt;/code&gt; declaration</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 선언</target>
        </trans-unit>
        <trans-unit id="96131132b1fece4018da08fbe5ae8cdc0f0bbe7c" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;import&lt;/code&gt; declaration which refers to a type</source>
          <target state="translated">유형을 참조 하는 &lt;code&gt;import&lt;/code&gt; 선언</target>
        </trans-unit>
        <trans-unit id="9e546120c9b08c182111a543340edaa52f8faa73" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;import&lt;/code&gt; declaration which refers to a value</source>
          <target state="translated">값을 참조 하는 &lt;code&gt;import&lt;/code&gt; 선언</target>
        </trans-unit>
        <trans-unit id="9c85d60a22bfc72f8be52c9d3473a14b494ef936" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;Accessor Decorator&lt;/em&gt; is declared just before an accessor declaration. The accessor decorator is applied to the &lt;em&gt;Property Descriptor&lt;/em&gt; for the accessor and can be used to observe, modify, or replace an accessor&amp;rsquo;s definitions. An accessor decorator cannot be used in a declaration file, or in any other ambient context (such as in a &lt;code&gt;declare&lt;/code&gt; class).</source>
          <target state="translated">접근 자 &lt;em&gt;데코레이터&lt;/em&gt; 는 접근 자 선언 직전에 선언됩니다. 접근 자 데코레이터는 접근 자의 &lt;em&gt;속성 설명자&lt;/em&gt; 에 적용되며 접근 자의 정의를 관찰, 수정 또는 교체하는 데 사용할 수 있습니다. 접근 자 데코레이터는 선언 파일이나 다른 주변 컨텍스트 (예 : &lt;code&gt;declare&lt;/code&gt; 클래스) 에서 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="637fccf99e1ca3360a8e160638d580b112623960" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;async function&lt;/em&gt; is a function or method that has been prefixed with the &lt;code&gt;async&lt;/code&gt; modifier. This modifier informs the compiler that function body transposition is required, and that the keyword &lt;code&gt;await&lt;/code&gt; should be treated as a unary expression instead of an identifier. An &lt;em&gt;Async Function&lt;/em&gt; must provide a return type annotation that points to a compatible &lt;code&gt;Promise&lt;/code&gt; type. Return type inference can only be used if there is a globally defined, compatible &lt;code&gt;Promise&lt;/code&gt; type.</source>
          <target state="translated">&lt;em&gt;비동기 함수&lt;/em&gt; 접두사 된 기능이나 방법 &lt;code&gt;async&lt;/code&gt; 개질제. 이 수정자는 함수 본문 전치가 필요하며 키워드 &lt;code&gt;await&lt;/code&gt; 는 식별자 대신 단항 표현식으로 처리되어야 함을 컴파일러에 알립니다 . &lt;em&gt;비동기 함수&lt;/em&gt; 반환 유형 주석을 제공해야합니다 호환되는 포인트 그 &lt;code&gt;Promise&lt;/code&gt; 유형입니다. 반환 형식 유추는 전역 적으로 정의되고 호환 가능한 &lt;code&gt;Promise&lt;/code&gt; 형식 이있는 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0c5ee8216b1102dc214045b20531cb28dca3422" translate="yes" xml:space="preserve">
          <source>An Example Project</source>
          <target state="translated">예제 프로젝트</target>
        </trans-unit>
        <trans-unit id="08a8a8bcfbc30a10a37d2f8c0745492817b04bd8" translate="yes" xml:space="preserve">
          <source>An IIFE returning a function, class or empty object literal, is also recognized as a namespace:</source>
          <target state="translated">함수, 클래스 또는 빈 객체 리터럴을 반환하는 IIFE도 네임 스페이스로 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="4b482032e9b848d1769fffddba6728c3f513e97d" translate="yes" xml:space="preserve">
          <source>An Object whose own property names are property names that are excluded from the &amp;lsquo;with&amp;rsquo; environment bindings of the associated objects.</source>
          <target state="translated">고유 한 속성 이름이 연결된 개체의 'with'환경 바인딩에서 제외 된 속성 이름 인 개체입니다.</target>
        </trans-unit>
        <trans-unit id="9346f4c4433fdb2ea0b41faaa1f055ba9e22c515" translate="yes" xml:space="preserve">
          <source>An abstract class can declare abstract properties and/or accessors. Any sub class will need to declare the abstract properties or be marked as abstract. Abstract properties cannot have an initializer. Abstract accessors cannot have bodies.</source>
          <target state="translated">추상 클래스는 추상 속성 및 / 또는 접근자를 선언 할 수 있습니다. 모든 하위 클래스는 추상 속성을 선언하거나 추상으로 표시해야합니다. 추상 속성은 이니셜 라이저를 가질 수 없습니다. 추상 접근자는 본문을 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c01bf8fd95c1254c73cd6a7e1bf75eab586904fa" translate="yes" xml:space="preserve">
          <source>An entity accessed through an ES2015 namespace import is considered read-only (e.g. &lt;code&gt;foo.x&lt;/code&gt; is read-only when &lt;code&gt;foo&lt;/code&gt; is declared as &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt;).</source>
          <target state="translated">ES2015 네임 스페이스를 가져 오기를 통해 액세스 엔티티 (예 : 읽기 전용으로 간주됩니다 &lt;code&gt;foo.x&lt;/code&gt; 읽기 전용 인 경우 &lt;code&gt;foo&lt;/code&gt; 는이 같은 선언 &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="42ee76cce09b6dda0af497e582271e9daeb1fa9e" translate="yes" xml:space="preserve">
          <source>An entity declared in an &lt;code&gt;import&lt;/code&gt; statement is considered read-only.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 문에 선언 된 엔터티는 읽기 전용으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="010036a4ed3e6887f0a662f6e45e32f749a00f87" translate="yes" xml:space="preserve">
          <source>An enum declaration (&lt;code&gt;enum E { A, B, C }&lt;/code&gt;)</source>
          <target state="translated">열거 형 선언 ( &lt;code&gt;enum E { A, B, C }&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3a85dd24cd070fb5512fd0ef92b9518fceb29e8c" translate="yes" xml:space="preserve">
          <source>An export default declaration specifies an expression that becomes the default export of a module:</source>
          <target state="translated">내보내기 기본 선언은 모듈의 기본 내보내기가되는 표현식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1dbd631e886efac25134c1822d5fc8c0a3f82701" translate="yes" xml:space="preserve">
          <source>An import to a module with no declaration file will still be flagged as an error under &lt;code&gt;--noImplicitAny&lt;/code&gt;.</source>
          <target state="translated">선언 파일이없는 모듈로의 가져 오기는 여전히 &lt;code&gt;--noImplicitAny&lt;/code&gt; 에서 오류로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="4089846541ea3f66ca0b3aa8324eb27446bfa87c" translate="yes" xml:space="preserve">
          <source>An important rule is that &lt;code&gt;export&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt; declarations export or import &lt;em&gt;all meanings&lt;/em&gt; of their targets.</source>
          <target state="translated">중요한 규칙은 &lt;code&gt;export&lt;/code&gt; 및 &lt;code&gt;import&lt;/code&gt; 선언 이 대상의 &lt;em&gt;모든 의미&lt;/em&gt; 를 내보내거나 가져 오는 &lt;em&gt;것&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9829bd2aaefcc0a918548bdfb97be8f7716b574b" translate="yes" xml:space="preserve">
          <source>An index type &lt;code&gt;keyof T&lt;/code&gt; for some type &lt;code&gt;T&lt;/code&gt; is a subtype of &lt;code&gt;string | number | symbol&lt;/code&gt;.</source>
          <target state="translated">인덱스 유형 &lt;code&gt;keyof T&lt;/code&gt; 어떤 종류의 &lt;code&gt;T&lt;/code&gt; 는 의 하위 유형입니다 &lt;code&gt;string | number | symbol&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3dee51effab23215f94b19b5e6ce849dbbb11b" translate="yes" xml:space="preserve">
          <source>An interface can extend multiple interfaces, creating a combination of all of the interfaces.</source>
          <target state="translated">인터페이스는 여러 인터페이스를 확장하여 모든 인터페이스의 조합을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dfb2cf00eea3daab08c8ac76409915d529976bc" translate="yes" xml:space="preserve">
          <source>An interface declaration (&lt;code&gt;interface I { x: number[]; }&lt;/code&gt;)</source>
          <target state="translated">인터페이스 선언 ( &lt;code&gt;interface I { x: number[]; }&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="051272f0126c6f4c635d623e56a437da25ba082a" translate="yes" xml:space="preserve">
          <source>An intersection type combines multiple types into one. This allows you to add together existing types to get a single type that has all the features you need. For example, &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; is a &lt;code&gt;Person&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Serializable&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;Loggable&lt;/code&gt;. That means an object of this type will have all members of all three types.</source>
          <target state="translated">교차 유형은 여러 유형을 하나로 결합합니다. 이를 통해 기존 유형을 추가하여 필요한 모든 기능을 갖춘 단일 유형을 얻을 수 있습니다. 예를 들어 &lt;code&gt;Person &amp;amp; Serializable &amp;amp; Loggable&lt;/code&gt; 은 &lt;code&gt;Person&lt;/code&gt; &lt;em&gt;and &lt;/em&gt; &lt;code&gt;Serializable&lt;/code&gt; &lt;em&gt;and &lt;/em&gt; &lt;code&gt;Loggable&lt;/code&gt; 입니다. 즉,이 유형의 개체는 세 가지 유형의 모든 멤버를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="99cc1cc22b07e8cafd4c0a4ab5a6f60816a8100b" translate="yes" xml:space="preserve">
          <source>An object is deemed iterable if it has an implementation for the &lt;a href=&quot;symbols#symboliterator&quot;&gt;&lt;code&gt;Symbol.iterator&lt;/code&gt;&lt;/a&gt; property. Some built-in types like &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Int32Array&lt;/code&gt;, &lt;code&gt;Uint32Array&lt;/code&gt;, etc. have their &lt;code&gt;Symbol.iterator&lt;/code&gt; property already implemented. &lt;code&gt;Symbol.iterator&lt;/code&gt; function on an object is responsible for returning the list of values to iterate on.</source>
          <target state="translated">&lt;a href=&quot;symbols#symboliterator&quot;&gt; &lt;code&gt;Symbol.iterator&lt;/code&gt; &lt;/a&gt; 속성에 대한 구현이있는 객체는 반복 가능한 것으로 간주 됩니다. &lt;code&gt;Array&lt;/code&gt; , &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Int32Array&lt;/code&gt; , &lt;code&gt;Uint32Array&lt;/code&gt; 등과 같은 일부 내장 유형 에는 이미 &lt;code&gt;Symbol.iterator&lt;/code&gt; 속성이 구현되어 있습니다. 객체의 &lt;code&gt;Symbol.iterator&lt;/code&gt; 함수는 반복 할 값 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f02b61e8ec8b6f2bec26f2bedf23c11ecf77a29" translate="yes" xml:space="preserve">
          <source>An object literal type is now assignable to a type with an index signature if all known properties in the object literal are assignable to that index signature. This makes it possible to pass a variable that was initialized with an object literal as parameter to a function that expects a map or dictionary:</source>
          <target state="translated">객체 리터럴의 알려진 모든 속성을 해당 인덱스 서명에 할당 할 수있는 경우 객체 리터럴 유형을 인덱스 서명이있는 유형에 할당 할 수 있습니다. 이를 통해 객체 리터럴로 초기화 된 변수를 매개 변수로 맵 또는 사전이 필요한 함수에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cb8cf874c7b3539ef5e517ffab6e8f6b9569d43" translate="yes" xml:space="preserve">
          <source>An object that supports async iteration is said to be &amp;ldquo;iterable&amp;rdquo; if it has a &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; method that returns an &lt;code&gt;AsyncIterator&lt;/code&gt; object.</source>
          <target state="translated">객체가 반복 비동기 지원은이 경우 &quot;반복 가능&quot;이라고되어 &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; 의 방법이 다시 표시 &lt;code&gt;AsyncIterator&lt;/code&gt; 의 개체를.</target>
        </trans-unit>
        <trans-unit id="a8447e71f06bf05be69e3922802bfe818075f229" translate="yes" xml:space="preserve">
          <source>An operand is considered nullable if the type of the operand is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; or a union type that includes &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. Note that the union type case only only occurs in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode because &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; disappear from unions in classic type checking mode.</source>
          <target state="translated">피연산자의 유형 인 경우 피연산자는 널 간주 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 또는 포함하는 연합 형 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; . 통합 유형 대 / 소문자 는 클래식 유형 검사 모드의 공용체에서 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 가 사라지기 때문에 &lt;code&gt;--strictNullChecks&lt;/code&gt; 모드 에서만 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="e1d5ca7f2497f214678abf18ecf2b51c0278100b" translate="yes" xml:space="preserve">
          <source>An unspecified type argument in JSDoc defaults to any:</source>
          <target state="translated">JSDoc에서 지정되지 않은 유형 인수는 기본적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9add44f9c257c0dbb7eebf6fe551aa600ac3c7bf" translate="yes" xml:space="preserve">
          <source>And help in Japanese:</source>
          <target state="translated">일본어로 도와주세요 :</target>
        </trans-unit>
        <trans-unit id="44c2dac2f30e99536de68e97cb2b18f2d5db2533" translate="yes" xml:space="preserve">
          <source>And just like type predicate signatures, these assertion signatures are incredibly expressive. We can express some fairly sophisticated ideas with these.</source>
          <target state="translated">유형 술어 서명과 마찬가지로 이러한 어설 션 서명은 엄청나게 표현 적입니다. 우리는 이것으로 상당히 정교한 아이디어를 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5f7abc94bd4652b1940c01f38e4cdba6a7de10d" translate="yes" xml:space="preserve">
          <source>And results in</source>
          <target state="translated">그리고 결과</target>
        </trans-unit>
        <trans-unit id="524218ceeaedc01c8daaf35729b043a8754e652f" translate="yes" xml:space="preserve">
          <source>And the other is the &lt;code&gt;as&lt;/code&gt;-syntax:</source>
          <target state="translated">그리고 다른 하나는이다 &lt;code&gt;as&lt;/code&gt; - 구문 :</target>
        </trans-unit>
        <trans-unit id="7683ba2ccf1b61a19dd6dd9bbbf3a532801e3252" translate="yes" xml:space="preserve">
          <source>And to use it:</source>
          <target state="translated">그리고 그것을 사용하려면 :</target>
        </trans-unit>
        <trans-unit id="a379f1e77206b5fa5615fc791f830626638ff5b9" translate="yes" xml:space="preserve">
          <source>And usage would be:</source>
          <target state="translated">그리고 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="955c6169edfe74a318e323004916b98e713d7add" translate="yes" xml:space="preserve">
          <source>And with parameters to a function:</source>
          <target state="translated">그리고 함수에 대한 매개 변수와 함께 :</target>
        </trans-unit>
        <trans-unit id="cce043e3a6fddbda09013e27b4641adddde08990" translate="yes" xml:space="preserve">
          <source>And, for pre-ES2015 code, it can be used to simulate static methods:</source>
          <target state="translated">ES2015 이전 코드의 경우 정적 메소드를 시뮬레이션하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e0355996ea2c36fc48cd0c3c40221f8808eb765" translate="yes" xml:space="preserve">
          <source>Another ECMAScript 2015 feature that TypeScript has is destructuring. For a complete reference, see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;the article on the Mozilla Developer Network&lt;/a&gt;. In this section, we&amp;rsquo;ll give a short overview.</source>
          <target state="translated">TypeScript가 가지고있는 또 다른 ECMAScript 2015 기능은 파괴입니다. 자세한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;내용은 Mozilla Developer Network 기사를&lt;/a&gt; 참조하십시오 . 이 섹션에서는 간단한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f1a7f2f6380d7122bad959764252b9e24c79240a" translate="yes" xml:space="preserve">
          <source>Another distinction is that &lt;code&gt;for..in&lt;/code&gt; operates on any object; it serves as a way to inspect properties on this object. &lt;code&gt;for..of&lt;/code&gt; on the other hand, is mainly interested in values of iterable objects. Built-in objects like &lt;code&gt;Map&lt;/code&gt; and &lt;code&gt;Set&lt;/code&gt; implement &lt;code&gt;Symbol.iterator&lt;/code&gt; property allowing access to stored values.</source>
          <target state="translated">또 다른 차이점은 &lt;code&gt;for..in&lt;/code&gt; 은 모든 객체에서 작동 한다는 것입니다 . 이 객체의 속성을 검사하는 방법으로 사용됩니다. &lt;code&gt;for..of&lt;/code&gt; 에 for..of 는 반복 가능한 객체의 값에 주로 관심이 있습니다. &lt;code&gt;Map&lt;/code&gt; 및 &lt;code&gt;Set&lt;/code&gt; 과 같은 내장 객체는 저장된 값에 액세스 할 수있는 &lt;code&gt;Symbol.iterator&lt;/code&gt; 속성을 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="80278db3392e36b25471320c2c5c53b5cfd9afc0" translate="yes" xml:space="preserve">
          <source>Another example would be the &lt;code&gt;TypeName&lt;/code&gt; type alias, which uses nested conditional types:</source>
          <target state="translated">또 다른 예 는 중첩 조건부 유형을 사용 하는 &lt;code&gt;TypeName&lt;/code&gt; 유형 별명입니다.</target>
        </trans-unit>
        <trans-unit id="59923c5b5918e19407ea7e824fe9454f6b96dd6d" translate="yes" xml:space="preserve">
          <source>Another fundamental part of creating programs in JavaScript for webpages and servers alike is working with textual data. As in other languages, we use the type &lt;code&gt;string&lt;/code&gt; to refer to these textual datatypes. Just like JavaScript, TypeScript also uses double quotes (&lt;code&gt;&quot;&lt;/code&gt;) or single quotes (&lt;code&gt;'&lt;/code&gt;) to surround string data.</source>
          <target state="translated">웹 페이지 및 서버를 위해 JavaScript로 프로그램을 작성하는 또 다른 기본 부분은 텍스트 데이터 작업입니다. 다른 언어와 마찬가지로 유형 &lt;code&gt;string&lt;/code&gt; 을 사용하여 이러한 텍스트 데이터 유형을 참조합니다. JavaScript와 마찬가지로 TypeScript는 큰 따옴표 ( &lt;code&gt;&quot;&lt;/code&gt; ) 또는 작은 따옴표 ( &lt;code&gt;'&lt;/code&gt; )를 사용하여 문자열 데이터를 묶습니다 .</target>
        </trans-unit>
        <trans-unit id="e22e08f461a07d2394e4b0372b16fbe2608c33ae" translate="yes" xml:space="preserve">
          <source>Another good practice is to have a &amp;ldquo;solution&amp;rdquo; &lt;code&gt;tsconfig.json&lt;/code&gt; file that simply has &lt;code&gt;references&lt;/code&gt; to all of your leaf-node projects and sets &lt;code&gt;files&lt;/code&gt; to an empty array (otherwise the solution file will cause double compilation of files). Note that starting with 3.0, it is no longer an error to have an empty &lt;code&gt;files&lt;/code&gt; array if you have at least one &lt;code&gt;reference&lt;/code&gt; in a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">또 다른 좋은 방법은 단순히 모든 리프 노드 프로젝트에 &lt;code&gt;references&lt;/code&gt; 를 갖고 &lt;code&gt;files&lt;/code&gt; 을 빈 배열로 설정 하는 &quot;솔루션&quot; &lt;code&gt;tsconfig.json&lt;/code&gt; 파일을 갖는 것입니다 (그렇지 않으면 솔루션 파일이 파일의 이중 컴파일을 유발 함). 3.0부터 시작 하여 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일 에 하나 이상의 &lt;code&gt;reference&lt;/code&gt; 가있는 경우 빈 &lt;code&gt;files&lt;/code&gt; 배열 을 갖는 것은 더 이상 오류가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="bd3ed357192d33940721ba58d1e4e4f234af944b" translate="yes" xml:space="preserve">
          <source>Another property of block-scoped variables is that they can&amp;rsquo;t be read or written to before they&amp;rsquo;re actually declared. While these variables are &amp;ldquo;present&amp;rdquo; throughout their scope, all points up until their declaration are part of their &lt;em&gt;temporal dead zone&lt;/em&gt;. This is just a sophisticated way of saying you can&amp;rsquo;t access them before the &lt;code&gt;let&lt;/code&gt; statement, and luckily TypeScript will let you know that.</source>
          <target state="translated">블록 범위 변수의 또 다른 속성은 실제로 선언되기 전에 읽거나 쓸 수 없다는 것입니다. 이러한 변수는 전체 범위에 걸쳐 &quot;존재&quot;하지만 선언까지의 모든 포인트는 &lt;em&gt;일시적인 데드 존의&lt;/em&gt; 일부입니다 . 이것은 &lt;code&gt;let&lt;/code&gt; 문 전에 액세스 할 수 없다는 정교한 방법 이며 운 좋게도 TypeScript가 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="6536ca406ade59e49db35f06a2bc4ae98274b219" translate="yes" xml:space="preserve">
          <source>Another simple way is to use class expressions:</source>
          <target state="translated">또 다른 간단한 방법은 클래스 표현식을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eb0433a2f2345ca65e0ca8af5f86b17a73375f6b" translate="yes" xml:space="preserve">
          <source>Another thing to keep in mind is that &lt;code&gt;const&lt;/code&gt; contexts don&amp;rsquo;t immediately convert an expression to be fully immutable.</source>
          <target state="translated">명심해야 할 또 다른 사항은 &lt;code&gt;const&lt;/code&gt; 컨텍스트가 표현식을 완전히 변경할 수없는 것으로 즉시 변환하지는 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a0272d130e56f355222a749eeba841dae92661ec" translate="yes" xml:space="preserve">
          <source>Another way that you can simplify working with namespaces is to use &lt;code&gt;import q = x.y.z&lt;/code&gt; to create shorter names for commonly-used objects. Not to be confused with the &lt;code&gt;import x = require(&quot;name&quot;)&lt;/code&gt; syntax used to load modules, this syntax simply creates an alias for the specified symbol. You can use these sorts of imports (commonly referred to as aliases) for any kind of identifier, including objects created from module imports.</source>
          <target state="translated">네임 스페이스 작업을 단순화 할 수있는 또 다른 방법은 &lt;code&gt;import q = x.y.z&lt;/code&gt; 를 사용하여 일반적으로 사용되는 객체의 짧은 이름을 만드는 것입니다. 모듈을로드하는 데 사용되는 &lt;code&gt;import x = require(&quot;name&quot;)&lt;/code&gt; 구문 과 혼동하지 마십시오 .이 구문은 단순히 지정된 기호의 별명을 작성합니다. 모듈 가져 오기에서 생성 된 객체를 포함하여 모든 종류의 식별자에 이러한 종류의 가져 오기 (일반적으로 별칭이라고 함)를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad06f386aa38881eb01e3e498f2167a151b8b1e6" translate="yes" xml:space="preserve">
          <source>Another way to describe the example is that the type &lt;code&gt;(x: T) =&amp;gt; void&lt;/code&gt; is &lt;em&gt;bivariant&lt;/em&gt; (i.e. covariant &lt;em&gt;or&lt;/em&gt; contravariant) for &lt;code&gt;T&lt;/code&gt; in default type checking mode, but &lt;em&gt;contravariant&lt;/em&gt; for &lt;code&gt;T&lt;/code&gt; in strict function types mode.</source>
          <target state="translated">예를 설명하는 또 다른 방법 은 기본 유형 검사 모드에서 &lt;code&gt;(x: T) =&amp;gt; void&lt;/code&gt; 의 유형 (x : T) =&amp;gt; void 가 &lt;code&gt;T&lt;/code&gt; 에 대한 &lt;em&gt;이변 량&lt;/em&gt; (즉, 공변량 &lt;em&gt;또는&lt;/em&gt; 반 변형) 이지만 엄격한 함수 유형 모드에서 &lt;code&gt;T&lt;/code&gt; 에 대한 &lt;em&gt;반 변형&lt;/em&gt; 입니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="322444d3bb52c341f429ca0454f292dc242f315b" translate="yes" xml:space="preserve">
          <source>Any</source>
          <target state="translated">Any</target>
        </trans-unit>
        <trans-unit id="5d5c745343bd6b12cb5e63f20e6477505f1a8f8f" translate="yes" xml:space="preserve">
          <source>Any declaration (such as a variable, function, class, type alias, or interface) can be exported by adding the &lt;code&gt;export&lt;/code&gt; keyword.</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; 키워드 를 추가하여 모든 선언 (예 : 변수, 함수, 클래스, 유형 별명 또는 인터페이스)을 내보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="874ba9764ea4968c93711ccd48458d3687016ab7" translate="yes" xml:space="preserve">
          <source>Any files that are referenced by files included via the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are also included. Similarly, if a file &lt;code&gt;B.ts&lt;/code&gt; is referenced by another file &lt;code&gt;A.ts&lt;/code&gt;, then &lt;code&gt;B.ts&lt;/code&gt; cannot be excluded unless the referencing file &lt;code&gt;A.ts&lt;/code&gt; is also specified in the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; list.</source>
          <target state="translated">&lt;code&gt;&quot;files&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 속성을 통해 포함 된 파일이 참조하는 모든 파일 도 포함됩니다. 파일 경우 마찬가지로, &lt;code&gt;B.ts&lt;/code&gt; 이 다른 파일에 의해 참조되는 &lt;code&gt;A.ts&lt;/code&gt; , 다음 &lt;code&gt;B.ts&lt;/code&gt; 가 참조하는 파일을 제외하고 배제 할 수 없다 &lt;code&gt;A.ts&lt;/code&gt; 은 또한에 지정된 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 목록입니다.</target>
        </trans-unit>
        <trans-unit id="58d3fbb8847e7adc33f00a67766bcf84d23be884" translate="yes" xml:space="preserve">
          <source>Any optional parameters must follow required parameters. Had we wanted to make the first name optional, rather than the last name, we would need to change the order of parameters in the function, putting the first name last in the list.</source>
          <target state="translated">선택적 매개 변수는 필수 매개 변수를 따라야합니다. 이름이 아닌 이름을 선택 사항으로 만들려면 함수에서 매개 변수의 순서를 변경하여 이름을 성을 목록에 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="71f5a252552c3c04d4828a9b0a56671420fcd2c6" translate="yes" xml:space="preserve">
          <source>Any other import is considered &lt;strong&gt;non-relative&lt;/strong&gt;. Some examples include:</source>
          <target state="translated">다른 수입품은 &lt;strong&gt;상대적이지 않은&lt;/strong&gt; 것으로 간주됩니다 . 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f54cc3c33db9d0cc0052e3d3a5370d1f5fb94ee9" translate="yes" xml:space="preserve">
          <source>Any time &lt;code&gt;isFish&lt;/code&gt; is called with some variable, TypeScript will &lt;em&gt;narrow&lt;/em&gt; that variable to that specific type if the original type is compatible.</source>
          <target state="translated">&lt;code&gt;isFish&lt;/code&gt; 가 일부 변수와 함께 호출 될 때마다 TypeScript 는 원래 유형이 호환되는 경우 해당 변수를 특정 유형으로 &lt;em&gt;좁 힙니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3bab2aa131866dfb42803d6fff4f7d0f0c52622a" translate="yes" xml:space="preserve">
          <source>Any variable, parameter or property that is initialized with null or undefined will have type any, even if strict null checks is turned on. Any variable, parameter or property that is initialized with [] will have type any[], even if strict null checks is turned on. The only exception is for properties that have multiple initializers as described above.</source>
          <target state="translated">null 또는 undefined로 초기화 된 변수, 매개 변수 또는 속성은 엄격한 null 검사가 설정되어 있어도 유형이 any입니다. 엄격한 null 검사가 설정되어 있어도 []로 초기화 된 모든 변수, 매개 변수 또는 속성은 any [] 형식입니다. 위에서 설명한대로 이니셜 라이저가 여러 개인 속성은 예외입니다.</target>
        </trans-unit>
        <trans-unit id="2e2c98bb415f3297c0331ba25fa80d4c29b187e3" translate="yes" xml:space="preserve">
          <source>Anywhere a greeting is expected, you can provide a &lt;code&gt;string&lt;/code&gt;, a function returning a &lt;code&gt;string&lt;/code&gt;, or a &lt;code&gt;Greeter&lt;/code&gt; instance.</source>
          <target state="translated">인사말이 필요한 곳이면 어디든 &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; 을 반환하는 함수 또는 &lt;code&gt;Greeter&lt;/code&gt; 인스턴스를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2721bd2d72a316000ef90a03336789e7221fe00" translate="yes" xml:space="preserve">
          <source>Apache Cordova Apps still have the existing limitation of a single &lt;code&gt;tsconfig.json&lt;/code&gt; file, which must be in either the root or the &lt;code&gt;scripts&lt;/code&gt; folder.</source>
          <target state="translated">Apache Cordova Apps에는 여전히 단일 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일 의 기존 제한 사항이 있으며 이는 루트 또는 &lt;code&gt;scripts&lt;/code&gt; 폴더에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="a72aa9f35599ef319f4bdce587da34e4ef96d8ee" translate="yes" xml:space="preserve">
          <source>App.ts</source>
          <target state="translated">App.ts</target>
        </trans-unit>
        <trans-unit id="f6775dc00da9c4ef2c019649d89650724f0bc81f" translate="yes" xml:space="preserve">
          <source>Applying the &lt;a href=&quot;https://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;principle of least privilege&lt;/a&gt;, all declarations other than those you plan to modify should use &lt;code&gt;const&lt;/code&gt;. The rationale is that if a variable didn&amp;rsquo;t need to get written to, others working on the same codebase shouldn&amp;rsquo;t automatically be able to write to the object, and will need to consider whether they really need to reassign to the variable. Using &lt;code&gt;const&lt;/code&gt; also makes code more predictable when reasoning about flow of data.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Principle_of_least_privilege&quot;&gt;최소 권한 원칙을&lt;/a&gt; 적용 할 때 수정하려는 선언 이외의 모든 선언은 &lt;code&gt;const&lt;/code&gt; 를 사용해야합니다 . 근거는 변수를 쓸 필요가 없다면 같은 코드베이스에서 작업하는 다른 사람들은 자동으로 객체에 쓸 수 없어야하며 변수에 실제로 재 할당해야하는지 고려해야한다는 것입니다. &lt;code&gt;const&lt;/code&gt; 를 사용하면 데이터 흐름을 추론 할 때 코드를보다 예측 가능하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="5b19a51e973f07fb33a1f0b3290dd21625155468" translate="yes" xml:space="preserve">
          <source>Array destructuring</source>
          <target state="translated">배열 파괴</target>
        </trans-unit>
        <trans-unit id="f5851b2384facd082dae02e6048cf9a0298dc5eb" translate="yes" xml:space="preserve">
          <source>As a heads up, when using &lt;code&gt;strictNullChecks&lt;/code&gt;, your dependencies may need to be updated to use &lt;code&gt;strictNullChecks&lt;/code&gt; as well.</source>
          <target state="translated">결과적으로 &lt;code&gt;strictNullChecks&lt;/code&gt; 를 사용할 때 &lt;code&gt;strictNullChecks&lt;/code&gt; 를 사용하도록 종속성 을 업데이트해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d3e12e810f587516dce0ec17be3db602fa8d496" translate="yes" xml:space="preserve">
          <source>As a nice bonus, this can also reduce the memory and runtime footprint of the compiler and language service by avoiding loading &lt;code&gt;.d.ts&lt;/code&gt; files from duplicate packages.</source>
          <target state="translated">좋은 보너스로, 이는 중복 패키지에서 &lt;code&gt;.d.ts&lt;/code&gt; 파일을 로드하지 않도록하여 컴파일러 및 언어 서비스의 메모리 및 런타임 풋 프린트를 줄일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba3d749ddb3000672893220ada4f38c622aabbb5" translate="yes" xml:space="preserve">
          <source>As a note: we encourage the use of &lt;code&gt;--strictNullChecks&lt;/code&gt; when possible, but for the purposes of this handbook, we will assume it is turned off.</source>
          <target state="translated">참고 : 가능하면 &lt;code&gt;--strictNullChecks&lt;/code&gt; 를 사용하는 것이 좋지만이 핸드북에서는이 기능이 꺼져 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="977dbb0a6075f870e0e4b082c7e83acf8cacfabb" translate="yes" xml:space="preserve">
          <source>As a result, TypeScript 3.2 considers the &lt;code&gt;error&lt;/code&gt; property in the following example to be a discriminant, whereas before it wouldn&amp;rsquo;t since &lt;code&gt;Error&lt;/code&gt; isn&amp;rsquo;t a singleton type. Thanks to this, narrowing works correctly in the body of the &lt;code&gt;unwrap&lt;/code&gt; function.</source>
          <target state="translated">결과적으로 TypeScript 3.2 는 다음 예제 의 &lt;code&gt;error&lt;/code&gt; 속성을 판별하는 것으로 간주 하지만 &lt;code&gt;Error&lt;/code&gt; 가 싱글 톤 형식이 아니기 전에는 그렇지 않습니다 . 이로 인해 &lt;code&gt;unwrap&lt;/code&gt; 기능 본문에서 축소가 올바르게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="368d21349de8cec5ff1bdfc7896830a65df05b5c" translate="yes" xml:space="preserve">
          <source>As a result, users can write getters and setters in ambient contexts in TypeScript 3.6.</source>
          <target state="translated">결과적으로 사용자는 TypeScript 3.6의 주변 컨텍스트에서 게터 및 세터를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7895ee4a93d7fa1bb09b06ce0af1d11a32158318" translate="yes" xml:space="preserve">
          <source>As an alternative to individual imports, a namespace import can be used to import an entire module:</source>
          <target state="translated">개별 가져 오기 대신 네임 스페이스 가져 오기를 사용하여 전체 모듈을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fa46177b5c4d16d6b6bc058d8b30ad17e80456e" translate="yes" xml:space="preserve">
          <source>As an example of new errors you might spot as a result:</source>
          <target state="translated">새로운 오류의 예로는 다음과 같은 결과가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a43f82802df7af1b9c148a7744a7e8b03aeeec58" translate="yes" xml:space="preserve">
          <source>As an example of some types that are immediately resolved, we can take a look at the following example:</source>
          <target state="translated">즉시 해결되는 일부 유형의 예로 다음 예를 살펴볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5d1fff48d37907013a550ea65a80338a2731aa0" translate="yes" xml:space="preserve">
          <source>As an example, consider the need to escape a string that contains the character &amp;lsquo;𠮷&amp;rsquo;. In UTF-16/UCS2, &amp;lsquo;𠮷&amp;rsquo; is represented as a surrogate pair, meaning that it&amp;rsquo;s encoded using a pair of 16-bit code units of values, specifically &lt;code&gt;0xD842&lt;/code&gt; and &lt;code&gt;0xDFB7&lt;/code&gt;. Previously this meant that you&amp;rsquo;d have to escape the codepoint as &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt;. This has the major downside that it&amp;rsquo;s difficult to discern two independent characters from a surrogate pair.</source>
          <target state="translated">예를 들어, 문자 '𠮷'가 포함 된 문자열을 이스케이프해야한다고 가정하십시오. UTF-16 / UCS2에서 '𠮷'은 서로 게이트 쌍으로 표시됩니다. 즉 16 비트 코드 단위 값, 특히 &lt;code&gt;0xD842&lt;/code&gt; 및 &lt;code&gt;0xDFB7&lt;/code&gt; 쌍을 사용하여 인코딩됩니다 . 이전에는 코드 포인트를 &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt; 로 이스케이프해야했습니다 . 이것은 대리 쌍에서 두 개의 독립적 인 캐릭터를 식별하기가 어렵다는 주요 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cef5c14af957c7ec054d83d89e6e1099bf750eb" translate="yes" xml:space="preserve">
          <source>As an example, getting the declarations for a library like lodash takes nothing more than the following command</source>
          <target state="translated">예를 들어 lodash와 같은 라이브러리에 대한 선언을 얻는 것은 다음 명령 이상을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57cdcd63d828e3b22ca9083f5b988b61d9d275fa" translate="yes" xml:space="preserve">
          <source>As an example, on many Unix-like systems, the standard output stream is accessible by the file &lt;code&gt;/dev/stdout&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 많은 유닉스 계열 시스템에서 &lt;code&gt;/dev/stdout&lt;/code&gt; 파일로 표준 출력 스트림에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04db06e8634e811fc030ab034631e6269dc8b211" translate="yes" xml:space="preserve">
          <source>As an example, the following code snippet</source>
          <target state="translated">예를 들어, 다음 코드 스 니펫</target>
        </trans-unit>
        <trans-unit id="5b7043bfc26c1ba1d57755926f65d96698dcbdc6" translate="yes" xml:space="preserve">
          <source>As an example, we can pipe our emitted JavaScript into a pretty printer like &lt;a href=&quot;https://www.npmjs.com/package/pretty-js&quot;&gt;pretty-js&lt;/a&gt;:</source>
          <target state="translated">예를 들어, 방출 된 JavaScript를 &lt;a href=&quot;https://www.npmjs.com/package/pretty-js&quot;&gt;pretty-js&lt;/a&gt; 와 같은 예쁜 프린터로 파이프 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6acab1badefe292ebd417e66a3c779d99e6f3970" translate="yes" xml:space="preserve">
          <source>As discussed earlier, the compiler can visit files outside the current folder when resolving a module. This can be hard when diagnosing why a module is not resolved, or is resolved to an incorrect definition. Enabling the compiler module resolution tracing using &lt;code&gt;--traceResolution&lt;/code&gt; provides insight in what happened during the module resolution process.</source>
          <target state="translated">앞에서 설명한 것처럼 컴파일러는 모듈을 확인할 때 현재 폴더 외부의 파일을 방문 할 수 있습니다. 모듈이 해석되지 않은 이유 또는 잘못된 정의로 해석되는 경우 진단하기가 어려울 수 있습니다. &lt;code&gt;--traceResolution&lt;/code&gt; 을 사용하여 컴파일러 모듈 확인 추적을 활성화하면 모듈 확인 프로세스 중에 발생한 상황에 대한 통찰력이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5fd062263fc01b5e1d46bab04d2fc86323793b16" translate="yes" xml:space="preserve">
          <source>As in JavaScript, all numbers in TypeScript are floating point values. These floating point numbers get the type &lt;code&gt;number&lt;/code&gt;. In addition to hexadecimal and decimal literals, TypeScript also supports binary and octal literals introduced in ECMAScript 2015.</source>
          <target state="translated">JavaScript에서와 같이 TypeScript의 모든 숫자는 부동 소수점 값입니다. 이 부동 소수점 숫자는 형 얻을 &lt;code&gt;number&lt;/code&gt; . 16 진수 및 10 진수 리터럴 외에도 TypeScript는 ECMAScript 2015에 도입 된 2 진수 및 8 진수 리터럴도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1bd66e26a872b778f91b4e166644723ee3f84de0" translate="yes" xml:space="preserve">
          <source>As long as the parameter types line up, it&amp;rsquo;s considered a valid type for the function, regardless of the names you give the parameters in the function type.</source>
          <target state="translated">매개 변수 유형이 정렬되는 한 함수 유형의 매개 변수 이름에 관계없이 함수에 유효한 유형으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="840af689a0703390b87203932fb9e888f4976db7" translate="yes" xml:space="preserve">
          <source>As mentioned above, TypeScript now errors when functions appear to be uncalled within &lt;code&gt;if&lt;/code&gt; statement conditions. An error is issued when a function type is checked in &lt;code&gt;if&lt;/code&gt; conditions unless any of the following apply:</source>
          <target state="translated">위에서 언급했듯이 &lt;code&gt;if&lt;/code&gt; 문 조건 내에서 함수가 호출되지 않은 것으로 표시되면 TypeScript에서 오류가 발생합니다 . 기능 유형이 체크인 할 때 오류가 발행되는 &lt;code&gt;if&lt;/code&gt; 다음 중 하나가 적용되지 않는 조건 :</target>
        </trans-unit>
        <trans-unit id="2a5c086b08f5e14213b1e066b50db36d669f8f91" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;enums#union-enums-and-enum-member-types&quot;&gt;our section on enums&lt;/a&gt;, enum members have types when every member is literal-initialized.</source>
          <target state="translated">&lt;a href=&quot;enums#union-enums-and-enum-member-types&quot;&gt;enums 섹션에서&lt;/a&gt; 언급했듯이 enum 멤버는 모든 멤버가 리터럴 초기화 될 때 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="ef133c43f210eb19ff5fbc570648cdd98a773f66" translate="yes" xml:space="preserve">
          <source>As our application grows, we&amp;rsquo;ll want to split the code across multiple files to make it easier to maintain.</source>
          <target state="translated">애플리케이션이 성장함에 따라 코드를 여러 파일로 분할하여 유지 관리하기가 더 쉬울 것입니다.</target>
        </trans-unit>
        <trans-unit id="a1bb7cf0157b073ec01dbb6472be74930da9d121" translate="yes" xml:space="preserve">
          <source>As part of the work for assertion signatures, TypeScript needed to encode more about where and which functions were being called. This gave us the opportunity to expand support for another class of functions: functions that return &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">어설 션 서명 작업의 일환으로 TypeScript는 호출 된 위치와 함수에 대해 더 많이 인코딩해야했습니다. 돌아 오지 기능이 우리에게 기능의 다른 클래스에 대한 지원을 확대 할 수있는 기회 준 &lt;code&gt;never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="390fe60664424f4e52cb8b9bdf97c3dba17b9a17" translate="yes" xml:space="preserve">
          <source>As specified in ECMAScript, mixing &lt;code&gt;number&lt;/code&gt;s and &lt;code&gt;bigint&lt;/code&gt;s in arithmetic operations is an error. You&amp;rsquo;ll have to explicitly convert values to &lt;code&gt;BigInt&lt;/code&gt;s.</source>
          <target state="translated">ECMAScript에 지정된대로 산술 연산에서 &lt;code&gt;number&lt;/code&gt; s와 &lt;code&gt;bigint&lt;/code&gt; s를 혼합 하는 것은 오류입니다. 명시 적으로 값을 &lt;code&gt;BigInt&lt;/code&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6b12aa1f9da2310999311b7475d8a9700fd525f1" translate="yes" xml:space="preserve">
          <source>As such, the following steps are performed when evaluating multiple decorators on a single declaration in TypeScript:</source>
          <target state="translated">따라서 TypeScript의 단일 선언에서 여러 데코레이터를 평가할 때 다음 단계가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7c6bf56e61f5837d2d137d88d1a894bdddcce94e" translate="yes" xml:space="preserve">
          <source>As the name suggests, the component is defined as a JavaScript function where its first argument is a &lt;code&gt;props&lt;/code&gt; object. TS enforces that its return type must be assignable to &lt;code&gt;JSX.Element&lt;/code&gt;.</source>
          <target state="translated">이름에서 알 수 있듯이 구성 요소는 첫 번째 인수가 &lt;code&gt;props&lt;/code&gt; 객체 인 JavaScript 함수로 정의됩니다 . TS는 반환 유형을 &lt;code&gt;JSX.Element&lt;/code&gt; 에 할당 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f3ca06e4caafd2fed96f322e77c268ce050caf98" translate="yes" xml:space="preserve">
          <source>As we add more validators, we&amp;rsquo;re going to want to have some kind of organization scheme so that we can keep track of our types and not worry about name collisions with other objects. Instead of putting lots of different names into the global namespace, let&amp;rsquo;s wrap up our objects into a namespace.</source>
          <target state="translated">더 많은 유효성 검사기를 추가함에 따라 유형을 추적하고 다른 개체와의 이름 충돌에 대해 걱정할 수 없도록 일종의 조직 체계를 원할 것입니다. 전역 네임 스페이스에 많은 다른 이름을 넣는 대신 객체를 네임 스페이스로 마무리하겠습니다.</target>
        </trans-unit>
        <trans-unit id="f8a201a25fd7790f05a2ecb442c622ccca689a7b" translate="yes" xml:space="preserve">
          <source>As we covered in &lt;a href=&quot;classes&quot;&gt;our section on classes&lt;/a&gt;, a class has two sides to its type: the static side and the instance side. Generic classes are only generic over their instance side rather than their static side, so when working with classes, static members can not use the class&amp;rsquo;s type parameter.</source>
          <target state="translated">&lt;a href=&quot;classes&quot;&gt;클래스 섹션에서&lt;/a&gt; 다룬 것처럼 클래스에는 정적 측면과 인스턴스 측면의 두 가지 측면이 있습니다. 제네릭 클래스는 정적 쪽이 아닌 인스턴스 쪽에서 만 제네릭이므로 클래스 작업시 정적 멤버는 클래스의 type 매개 변수를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e39977ca24b8e7d4979279054a3ddcd2072307e9" translate="yes" xml:space="preserve">
          <source>As we improve the playground and the website, &lt;a href=&quot;https://github.com/microsoft/TypeScript-Website/&quot;&gt;we welcome feedback and pull requests on GitHub&lt;/a&gt;!</source>
          <target state="translated">우리는 운동장과 웹 사이트를 개선함에 따라 &lt;a href=&quot;https://github.com/microsoft/TypeScript-Website/&quot;&gt;GitHub에 대한 피드백과 풀 요청을 환영합니다&lt;/a&gt; !</target>
        </trans-unit>
        <trans-unit id="5e0926e0c8d61335ab6e159abc80a290ccf182a2" translate="yes" xml:space="preserve">
          <source>As we mentioned earlier, interfaces can describe the rich types present in real world JavaScript. Because of JavaScript&amp;rsquo;s dynamic and flexible nature, you may occasionally encounter an object that works as a combination of some of the types described above.</source>
          <target state="translated">앞에서 언급했듯이 인터페이스는 실제 JavaScript에 존재하는 다양한 유형을 설명 할 수 있습니다. JavaScript의 동적이고 유연한 특성으로 인해 위에서 설명한 일부 유형의 조합으로 작동하는 객체가 종종 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e667d5c6d0aea6aea249141e0079b9aabfe0e442" translate="yes" xml:space="preserve">
          <source>As we mentioned, BigInt support is only available for the &lt;code&gt;esnext&lt;/code&gt; target. It may not be obvious, but because BigInts have different behavior for mathematical operators like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, etc., providing functionality for older targets where the feature doesn&amp;rsquo;t exist (like &lt;code&gt;es2017&lt;/code&gt; and below) would involve rewriting each of these operations. TypeScript would need to dispatch to the correct behavior depending on the type, and so every addition, string concatenation, multiplication, etc. would involve a function call.</source>
          <target state="translated">앞에서 언급했듯이 BigInt 지원은 &lt;code&gt;esnext&lt;/code&gt; 대상 에서만 사용할 수 있습니다 . 분명하지는 않지만 BigInts는 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 등과 같은 수학 연산자에 대해 다른 동작을 가지 &lt;code&gt;es2017&lt;/code&gt; 및 아래와 같이 기능이 존재하지 않는 이전 대상에 기능을 제공 하면 이러한 각 작업을 다시 작성해야합니다. . TypeScript는 유형에 따라 올바른 동작으로 전달해야하므로 모든 추가, 문자열 연결, 곱하기 등에는 함수 호출이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0bec2ed7fb7091a8ef64c32bc287724bfc0cce55" translate="yes" xml:space="preserve">
          <source>As we mentioned, type aliases can act sort of like interfaces; however, there are some subtle differences.</source>
          <target state="translated">앞에서 언급했듯이 타입 별칭은 일종의 인터페이스처럼 작동 할 수 있습니다. 그러나 약간의 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c55f71cd30e6435a112a945f64ecb9e401e4684b" translate="yes" xml:space="preserve">
          <source>As we said in the previous section, a class declaration creates two things: a type representing instances of the class and a constructor function. Because classes create types, you can use them in the same places you would be able to use interfaces.</source>
          <target state="translated">이전 섹션에서 언급했듯이 클래스 선언은 클래스 인스턴스를 나타내는 유형과 생성자 함수라는 두 가지를 만듭니다. 클래스는 유형을 작성하므로 인터페이스를 사용할 수있는 동일한 위치에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eca7c3fc0aeea895ca68482e3282da249688fb4f" translate="yes" xml:space="preserve">
          <source>As with Generators, Async Generators can only be function declarations, function expressions, or methods of classes or object literals. Arrow functions cannot be Async Generators. Async Generators require a valid, global &lt;code&gt;Promise&lt;/code&gt; implementation (either native or an ES2015-compatible polyfill), in addition to a valid &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; reference (either a native symbol or a shim).</source>
          <target state="translated">생성기와 마찬가지로 비동기 생성기는 함수 선언, 함수 표현식 또는 클래스 또는 객체 리터럴의 메소드 만 될 수 있습니다. 화살표 함수는 비동기 생성기가 될 수 없습니다. 비동기 생성기 는 유효한 &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; 참조 (기본 심볼 또는 shim) 외에 유효한 글로벌 &lt;code&gt;Promise&lt;/code&gt; 구현 (네이티브 또는 ES2015 호환 폴리 필)이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="e4960adc215b4ac881e5c35568584f22fd6212eb" translate="yes" xml:space="preserve">
          <source>As with arrays, you can destructure the rest of the tuple with &lt;code&gt;...&lt;/code&gt;, to get a shorter tuple:</source>
          <target state="translated">배열과 마찬가지로 더 짧은 튜플을 얻기 위해 &lt;code&gt;...&lt;/code&gt; 으로 나머지 튜플의 구조를 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c88c0ca9b6b6b4f95fa0f5e0a3945111347bb7f" translate="yes" xml:space="preserve">
          <source>As with assertion functions, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;read up more at the same pull request&lt;/a&gt;.</source>
          <target state="translated">어설 션 함수와 마찬가지로 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32695&quot;&gt;동일한 풀 요청에서 더 많은 내용을 읽을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40ebe0449790b742a22a4412bec079981f0005a3" translate="yes" xml:space="preserve">
          <source>As with global modules, you might see these examples in the documentation of a UMD module, so be sure to check the code or documentation.</source>
          <target state="translated">글로벌 모듈과 마찬가지로 UMD 모듈 문서에서이 예제를 볼 수 있으므로 코드 또는 문서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0705018bf7b343a8a49c9a07104949e0fe3a4e7a" translate="yes" xml:space="preserve">
          <source>As with types, you probably already understand what a value is. Values are runtime names that we can reference in expressions. For example &lt;code&gt;let x = 5;&lt;/code&gt; creates a value called &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">유형과 마찬가지로 값이 무엇인지 이미 알고있을 것입니다. 값은 표현식에서 참조 할 수있는 런타임 이름입니다. 예를 들어 &lt;code&gt;let x = 5;&lt;/code&gt; &lt;code&gt;x&lt;/code&gt; 라는 값을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e1a48f4680185d0a1c25499af1056b570588fb64" translate="yes" xml:space="preserve">
          <source>As you might&amp;rsquo;ve figured out, we just declared a variable named &lt;code&gt;a&lt;/code&gt; with the value &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">알다시피, 우리 는 값이 &lt;code&gt;10&lt;/code&gt; 인 &lt;code&gt;a&lt;/code&gt; 라는 변수를 선언했습니다 .</target>
        </trans-unit>
        <trans-unit id="72457daa6f50ff48a819ba7cfab041aeb483b454" translate="yes" xml:space="preserve">
          <source>As you type on the boxes you should see the message appear/change!</source>
          <target state="translated">상자에 입력하면 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="bc4a6547aa8a5fff93868acf4c855dc352b78b55" translate="yes" xml:space="preserve">
          <source>Ask the file named &lt;code&gt;/root/src/moduleB.js&lt;/code&gt;, if it exists.</source>
          <target state="translated">&lt;code&gt;/root/src/moduleB.js&lt;/code&gt; 파일이 있으면 요청하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae145f96f9923e53fbb6e9f3f9610452236976e4" translate="yes" xml:space="preserve">
          <source>Ask the folder &lt;code&gt;/root/src/moduleB&lt;/code&gt; if it contains a file named &lt;code&gt;index.js&lt;/code&gt;. That file is implicitly considered that folder&amp;rsquo;s &amp;ldquo;main&amp;rdquo; module.</source>
          <target state="translated">&lt;code&gt;index.js&lt;/code&gt; 파일이 포함되어 있으면 &lt;code&gt;/root/src/moduleB&lt;/code&gt; 폴더를 요청하십시오 . 이 파일은 해당 폴더의 &quot;기본&quot;모듈로 암시 적으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8b89fe51a739705208f8a298ea55bb588950f3b6" translate="yes" xml:space="preserve">
          <source>Ask the folder &lt;code&gt;/root/src/moduleB&lt;/code&gt; if it contains a file named &lt;code&gt;package.json&lt;/code&gt; that specifies a &lt;code&gt;&quot;main&quot;&lt;/code&gt; module. In our example, if Node.js found the file &lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; containing &lt;code&gt;{ &quot;main&quot;: &quot;lib/mainModule.js&quot; }&lt;/code&gt;, then Node.js will refer to &lt;code&gt;/root/src/moduleB/lib/mainModule.js&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;main&quot;&lt;/code&gt; 모듈 을 지정하는 &lt;code&gt;package.json&lt;/code&gt; 이라는 파일이 포함되어 있으면 &lt;code&gt;/root/src/moduleB&lt;/code&gt; 폴더에 문의하십시오 . 이 예에서 Node.js 가 &lt;code&gt;{ &quot;main&quot;: &quot;lib/mainModule.js&quot; }&lt;/code&gt; 포함하는 &lt;code&gt;/root/src/moduleB/package.json&lt;/code&gt; 파일을 찾은 경우 Node.js 는 &lt;code&gt;/root/src/moduleB/lib/mainModule.js&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b89f9c9a7b547e368f3dab7225883398658593d9" translate="yes" xml:space="preserve">
          <source>Assertion Functions</source>
          <target state="translated">어설 션 함수</target>
        </trans-unit>
        <trans-unit id="98c46e5ab2ffec3f635dbcdf5bc83e5353066495" translate="yes" xml:space="preserve">
          <source>Assertions in JavaScript are often used to guard against improper types being passed in. For example,</source>
          <target state="translated">JavaScript의 어설 션은 종종 부적절한 유형이 전달되는 것을 막기 위해 사용됩니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="d8da00b586664722cbf919d60c3a4ea73823442f" translate="yes" xml:space="preserve">
          <source>Assigned-before-use checking</source>
          <target state="translated">사용 전 할당 검사</target>
        </trans-unit>
        <trans-unit id="3a3dd9c1b7f42e306408c3dfe2c8989c03230b2e" translate="yes" xml:space="preserve">
          <source>Assignment to union types works very intuitively &amp;ndash; anything you could assign to one of the union type&amp;rsquo;s members is assignable to the union:</source>
          <target state="translated">Union 유형에 할당하는 것은 매우 직관적으로 작동합니다. Union 유형의 멤버 중 하나에 할당 할 수있는 모든 항목을 Union에 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes" xml:space="preserve">
          <source>Assignments</source>
          <target state="translated">Assignments</target>
        </trans-unit>
        <trans-unit id="f204f370193bea63fc30347377344ab8d15db4a7" translate="yes" xml:space="preserve">
          <source>Assignments at the top-level should behave the same way; in other words, a &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;const&lt;/code&gt; declaration is not required.</source>
          <target state="translated">최상위 수준의 과제는 같은 방식으로 작동해야합니다. 즉, &lt;code&gt;var&lt;/code&gt; 또는 &lt;code&gt;const&lt;/code&gt; 선언이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62de5df53249972bb9af1fc4eb134121b22de084" translate="yes" xml:space="preserve">
          <source>Assignments to &lt;code&gt;exports&lt;/code&gt; or &lt;code&gt;module.exports&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;exports&lt;/code&gt; 또는 &lt;code&gt;module.exports&lt;/code&gt; 할당</target>
        </trans-unit>
        <trans-unit id="f7a3538682165ab749b99e78129248b3c38f0d9b" translate="yes" xml:space="preserve">
          <source>Assignments to properties of &lt;code&gt;window&lt;/code&gt; or &lt;code&gt;global&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;window&lt;/code&gt; 또는 &lt;code&gt;global&lt;/code&gt; 속성에 할당</target>
        </trans-unit>
        <trans-unit id="58799777e41ae1e8d930adcb89c0780ba66e38d5" translate="yes" xml:space="preserve">
          <source>Assume that each of these modules exports an array of strings. For example &lt;code&gt;./zh/messages&lt;/code&gt; might contain:</source>
          <target state="translated">이러한 각 모듈이 문자열 배열을 내보내는 것으로 가정하십시오. 예를 들어 &lt;code&gt;./zh/messages&lt;/code&gt; 에는 다음이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e528328da4f68ed5eb912249e43e3e2e00accde0" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;__dirname&lt;/code&gt; is always available on &lt;code&gt;import.meta&lt;/code&gt;, the declaration would be done through reopening &lt;code&gt;ImportMeta&lt;/code&gt; interface:</source>
          <target state="translated">&lt;code&gt;__dirname&lt;/code&gt; 을 항상 사용할 수 있다고 가정하면 &lt;code&gt;ImportMeta&lt;/code&gt; 인터페이스 를 다시 &lt;code&gt;import.meta&lt;/code&gt; 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="63c86e37952421654714f44ff0a3e0b511f5f15f" translate="yes" xml:space="preserve">
          <source>Assumptions that DOM primitives like &lt;code&gt;document&lt;/code&gt; or &lt;code&gt;window&lt;/code&gt; exist</source>
          <target state="translated">&lt;code&gt;document&lt;/code&gt; 나 &lt;code&gt;window&lt;/code&gt; 와 같은 DOM 프리미티브 가 존재 한다고 가정</target>
        </trans-unit>
        <trans-unit id="4fb1a430a57e52b71176eabf0a0a52ccef1c8fac" translate="yes" xml:space="preserve">
          <source>Astute readers will notice that, for example, &lt;code&gt;class&lt;/code&gt; appeared in both the &lt;em&gt;type&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; lists. The declaration &lt;code&gt;class C { }&lt;/code&gt; creates two things: a &lt;em&gt;type&lt;/em&gt;&lt;code&gt;C&lt;/code&gt; which refers to the instance shape of the class, and a &lt;em&gt;value&lt;/em&gt;&lt;code&gt;C&lt;/code&gt; which refers to the constructor function of the class. Enum declarations behave similarly.</source>
          <target state="translated">예를 들어, &lt;code&gt;class&lt;/code&gt; 는 &lt;em&gt;유형&lt;/em&gt; 및 &lt;em&gt;값&lt;/em&gt; 목록 에 모두 나타납니다 . 선언 &lt;code&gt;class C { }&lt;/code&gt; A : 두가지 생성 &lt;em&gt;형 &lt;/em&gt; &lt;code&gt;C&lt;/code&gt; 클래스의 인스턴스의 형태를 의미하고, &lt;em&gt;값 &lt;/em&gt; &lt;code&gt;C&lt;/code&gt; 클래스의 생성자 함수를 의미한다. 열거 형 선언도 비슷하게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="6bd2a8a7dd2324b3dfc1a250fed0f9daa6541f3a" translate="yes" xml:space="preserve">
          <source>Async Generators</source>
          <target state="translated">비동기 생성기</target>
        </trans-unit>
        <trans-unit id="3c1b53675cb58d1ec8542ffe7447c2dc8ed8d373" translate="yes" xml:space="preserve">
          <source>Async Iteration</source>
          <target state="translated">비동기 반복</target>
        </trans-unit>
        <trans-unit id="fec7372c392b06a860ac46991a72a2226276fba1" translate="yes" xml:space="preserve">
          <source>Async iterators</source>
          <target state="translated">비동기 반복자</target>
        </trans-unit>
        <trans-unit id="5bec73a232efba048470ae0342c82f3228e1af2d" translate="yes" xml:space="preserve">
          <source>At its core, optional chaining lets us write code where TypeScript can immediately stop running some expressions if we run into a &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. The star of the show in optional chaining is the new &lt;code&gt;?.&lt;/code&gt; operator for &lt;em&gt;optional property accesses&lt;/em&gt;. When we write code like</source>
          <target state="translated">핵심적으로 선택적 체인을 사용하면 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 가 발생하면 TypeScript가 일부 표현식 실행을 즉시 중지 할 수있는 코드를 작성할 수 있습니다 . 옵션 체인의 쇼 스타는 새로운 &lt;code&gt;?.&lt;/code&gt; &lt;em&gt;선택적 속성 액세스를&lt;/em&gt; 위한 연산자 . 우리가 같은 코드를 작성할 때</target>
        </trans-unit>
        <trans-unit id="d1167ef7e58858fe2a166efd826d59d4d9cd2ba5" translate="yes" xml:space="preserve">
          <source>At the command line, run the TypeScript compiler:</source>
          <target state="translated">명령 행에서 TypeScript 컴파일러를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e78da82abc219a055bfa736ddf690eb4d03a6708" translate="yes" xml:space="preserve">
          <source>At this point, if you try running &lt;code&gt;tsc&lt;/code&gt; at the root of your project, you should see output files in the &lt;code&gt;built&lt;/code&gt; directory. The layout of files in &lt;code&gt;built&lt;/code&gt; should look identical to the layout of &lt;code&gt;src&lt;/code&gt;. You should now have TypeScript working with your project.</source>
          <target state="translated">이 시점에서 프로젝트 루트에서 &lt;code&gt;tsc&lt;/code&gt; 를 실행하려고 하면 &lt;code&gt;built&lt;/code&gt; 디렉토리 에 출력 파일이 표시 됩니다. &lt;code&gt;built&lt;/code&gt; 파일 의 레이아웃은 &lt;code&gt;src&lt;/code&gt; 의 레이아웃과 동일해야합니다 . 이제 프로젝트에서 TypeScript가 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="378f484fcf34a8ed1dd8027e59916eb7638d8ea5" translate="yes" xml:space="preserve">
          <source>At this point, the compiler will ask &amp;ldquo;what&amp;rsquo;s the shape of &lt;code&gt;moduleA&lt;/code&gt;?&amp;rdquo; While this sounds straightforward, &lt;code&gt;moduleA&lt;/code&gt; could be defined in one of your own &lt;code&gt;.ts&lt;/code&gt;/&lt;code&gt;.tsx&lt;/code&gt; files, or in a &lt;code&gt;.d.ts&lt;/code&gt; that your code depends on.</source>
          <target state="translated">이 시점에서 컴파일러는&amp;ldquo; &lt;code&gt;moduleA&lt;/code&gt; 의 모양은 무엇 입니까?&amp;rdquo;라고 묻습니다 . 이것이 간단하게 들리지만 &lt;code&gt;moduleA&lt;/code&gt; 는 자신의 &lt;code&gt;.ts&lt;/code&gt; / &lt;code&gt;.tsx&lt;/code&gt; 파일 중 하나 또는 코드가 의존 하는 &lt;code&gt;.d.ts&lt;/code&gt; 에 정의 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed32a39d243798f06b391e5f95f8515b64a1895b" translate="yes" xml:space="preserve">
          <source>At this point, you&amp;rsquo;re probably ready to start using TypeScript files. The first step is to rename one of your &lt;code&gt;.js&lt;/code&gt; files to &lt;code&gt;.ts&lt;/code&gt;. If your file uses JSX, you&amp;rsquo;ll need to rename it to &lt;code&gt;.tsx&lt;/code&gt;.</source>
          <target state="translated">이제 TypeScript 파일을 사용할 수 있습니다. 첫 번째 단계는 &lt;code&gt;.js&lt;/code&gt; 파일 중 하나의 이름 을 &lt;code&gt;.ts&lt;/code&gt; 로 바꾸는 것입니다 . 파일이 JSX를 사용하는 경우 파일 이름을 &lt;code&gt;.tsx&lt;/code&gt; 로 바꾸어야 합니다.</target>
        </trans-unit>
        <trans-unit id="6e7ccc595171e95a7eb1f834393506196fbc0ea1" translate="yes" xml:space="preserve">
          <source>Attribute type checking</source>
          <target state="translated">속성 유형 확인</target>
        </trans-unit>
        <trans-unit id="1cfeae50596a1c82d93481a9895a732d259c70b1" translate="yes" xml:space="preserve">
          <source>Augmenting global/module scope from modules</source>
          <target state="translated">모듈에서 글로벌 / 모듈 범위 확대</target>
        </trans-unit>
        <trans-unit id="78d9210af9045d4fe60bdb145dcc8d78ae6da80c" translate="yes" xml:space="preserve">
          <source>Automatically set to PreferredUILang value</source>
          <target state="translated">PreferredUILang 값으로 자동 설정</target>
        </trans-unit>
        <trans-unit id="f3bf8dee016caf43ae3970fbea5f976d54898ed9" translate="yes" xml:space="preserve">
          <source>Babel</source>
          <target state="translated">Babel</target>
        </trans-unit>
        <trans-unit id="adcde08c76f527a1993685af5dc553eeaf5a112d" translate="yes" xml:space="preserve">
          <source>Babel is a hugely flexible compiler that converts ES2015 and beyond into ES5 and ES3. This lets you add extensive and customized transformations that TypeScript doesn&amp;rsquo;t support.</source>
          <target state="translated">Babel은 ES2015 이상을 ES5 및 ES3로 변환하는 매우 유연한 컴파일러입니다. 이렇게하면 TypeScript에서 지원하지 않는 광범위하고 사용자 정의 된 변환을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aca918fb61ddb9faae466290b72a8013b7e396e6" translate="yes" xml:space="preserve">
          <source>Babel&amp;rsquo;s ES5 output should be very similar to TypeScript&amp;rsquo;s output for such a simple script.</source>
          <target state="translated">Babel의 ES5 출력은 이러한 간단한 스크립트에 대한 TypeScript의 출력과 매우 유사해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ad5cf24690d2882eba4d3f2b0e0a8bf277990a5" translate="yes" xml:space="preserve">
          <source>Back when TypeScript implemented public class fields, we assumed to the best of our abilities that the following code</source>
          <target state="translated">TypeScript가 퍼블릭 클래스 필드를 구현했을 때, 우리는 다음 코드를 최대한 활용했다고 가정했습니다.</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="c2fd3a989facf50da271d674c14207aa8ad92548" translate="yes" xml:space="preserve">
          <source>Bare Import</source>
          <target state="translated">베어 임포트</target>
        </trans-unit>
        <trans-unit id="1dbd61f556fe3f920e0c1bc1a21ce34dd73099d6" translate="yes" xml:space="preserve">
          <source>Base URL</source>
          <target state="translated">기본 URL</target>
        </trans-unit>
        <trans-unit id="172793b0e3b408efe74b0d9f46aaf934fcd5496f" translate="yes" xml:space="preserve">
          <source>Base directory to resolve non-relative module names. See &lt;a href=&quot;module-resolution#base-url&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">상대적이지 않은 모듈 이름을 해결하기위한 기본 디렉토리. 자세한 내용은 &lt;a href=&quot;module-resolution#base-url&quot;&gt;모듈 확인 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="30c8a7205576c1623baf3a7cfcb0a92c99932a66" translate="yes" xml:space="preserve">
          <source>Based on the fact that the above function is being assigned to &lt;code&gt;Window.onscroll&lt;/code&gt;, Typescript knows that &lt;code&gt;uiEvent&lt;/code&gt; is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/UIEvent&quot;&gt;UIEvent&lt;/a&gt;, and not a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MouseEvent&lt;/a&gt; like the previous example. &lt;code&gt;UIEvent&lt;/code&gt; objects contain no &lt;code&gt;button&lt;/code&gt; property, and so Typescript will throw an error.</source>
          <target state="translated">위의 함수가 &lt;code&gt;Window.onscroll&lt;/code&gt; 에 할당되고 있다는 사실을 기반으로 Typescript는 &lt;code&gt;uiEvent&lt;/code&gt; 가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/UIEvent&quot;&gt;UIEvent&lt;/a&gt; 이며 이전 예제와 같은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;MouseEvent&lt;/a&gt; 가 아니라는 것을 알고 있습니다. &lt;code&gt;UIEvent&lt;/code&gt; 객체에는 &lt;code&gt;button&lt;/code&gt; 속성이 없으므로 Typescript에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5eab8fc3ffa32aa796174a77104a420884806a36" translate="yes" xml:space="preserve">
          <source>Basic Concepts</source>
          <target state="translated">기본 개념</target>
        </trans-unit>
        <trans-unit id="7519044f052a17daead9b75e1d213e160e8c8476" translate="yes" xml:space="preserve">
          <source>Basic Gruntfile.js</source>
          <target state="translated">기본 Gruntfile.js</target>
        </trans-unit>
        <trans-unit id="0683d71248dcbb6ef209d3946391b3451983e5b6" translate="yes" xml:space="preserve">
          <source>Basic Types</source>
          <target state="translated">기본 유형</target>
        </trans-unit>
        <trans-unit id="bf61ba3f6509ba114cc8faf2b40e8e71ed35a95e" translate="yes" xml:space="preserve">
          <source>Basic Types: Any</source>
          <target state="translated">기본 유형 : 모두</target>
        </trans-unit>
        <trans-unit id="d61d7e43d7dc9242055a885bc7b2bde15bb723db" translate="yes" xml:space="preserve">
          <source>Basic Types: Array</source>
          <target state="translated">기본 유형 : 배열</target>
        </trans-unit>
        <trans-unit id="ed07881f050cc30ef0327d36d1271fbb6c104615" translate="yes" xml:space="preserve">
          <source>Basic Types: Enum</source>
          <target state="translated">기본 유형 : 열거 형</target>
        </trans-unit>
        <trans-unit id="243307eb146b441d38c323662afa7897483a957d" translate="yes" xml:space="preserve">
          <source>Basic Types: Never</source>
          <target state="translated">기본 유형 : Never</target>
        </trans-unit>
        <trans-unit id="682c83570d93e651a69c5cc3c77d360b30490fae" translate="yes" xml:space="preserve">
          <source>Basic Types: Tuple</source>
          <target state="translated">기본 유형 : 튜플</target>
        </trans-unit>
        <trans-unit id="58a2993e94f23073b254c35171c856f14023d41f" translate="yes" xml:space="preserve">
          <source>Basic Types: Void</source>
          <target state="translated">기본 유형 : 무효</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="61d56735d306d59953f3983c85541271068dbd2d" translate="yes" xml:space="preserve">
          <source>Basic gulpfile.js</source>
          <target state="translated">기본 gulpfile.js</target>
        </trans-unit>
        <trans-unit id="cb3a8802da5b3164771a468d78ff7995a249f08a" translate="yes" xml:space="preserve">
          <source>Basic usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="412b5f9fcb13b09d7c79dbb054f0b03a03299e53" translate="yes" xml:space="preserve">
          <source>Basic webpack.config.js when using Webpack 1</source>
          <target state="translated">Webpack 1 사용시 기본 webpack.config.js</target>
        </trans-unit>
        <trans-unit id="4eb989b59b1f0bb11bab44b3981ea2961cb73436" translate="yes" xml:space="preserve">
          <source>Basic webpack.config.js when using Webpack 2</source>
          <target state="translated">Webpack 2 사용시 기본 webpack.config.js</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="74f706e43bf557f0281375454415863443ab6f79" translate="yes" xml:space="preserve">
          <source>Be sure to read the &lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;footnote &amp;ldquo;The Impact of ES6 on Module Call Signatures&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#the-impact-of-es6-on-module-plugins&quot;&gt;&quot;모듈 호출 서명에 대한 ES6의 영향&quot;각주&lt;/a&gt; 를 읽으십시오</target>
        </trans-unit>
        <trans-unit id="9079f4cebe690d974b574d363d2382dfc53aa88d" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;https://en.wikipedia.org/wiki/Open/closed_principle&quot;&gt;an ideal property of software is being open to extension&lt;/a&gt;, you should always use an interface over a type alias if possible.</source>
          <target state="translated">때문에 &lt;a href=&quot;https://en.wikipedia.org/wiki/Open/closed_principle&quot;&gt;소프트웨어의 이상적인 속성 확장에 개방되고&lt;/a&gt; , 당신은 항상 타입 별칭 가능한 경우를 통해 인터페이스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5334136ac4ebd83a783dcba6f8148dc9c2a1da75" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Dog&lt;/code&gt; extends the functionality from &lt;code&gt;Animal&lt;/code&gt;, we were able to create an instance of &lt;code&gt;Dog&lt;/code&gt; that could both &lt;code&gt;bark()&lt;/code&gt; and &lt;code&gt;move()&lt;/code&gt;.</source>
          <target state="translated">때문에 &lt;code&gt;Dog&lt;/code&gt; 에서 기능 확장 &lt;code&gt;Animal&lt;/code&gt; , 우리의 인스턴스를 만들 수 있었다 &lt;code&gt;Dog&lt;/code&gt; 수를 모두 &lt;code&gt;bark()&lt;/code&gt; 및 &lt;code&gt;move()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d60995ae598e05ed025f86ab90ffdb0762aef9f1" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;createClock&lt;/code&gt;&amp;rsquo;s first parameter is of type &lt;code&gt;ClockConstructor&lt;/code&gt;, in &lt;code&gt;createClock(AnalogClock, 7, 32)&lt;/code&gt;, it checks that &lt;code&gt;AnalogClock&lt;/code&gt; has the correct constructor signature.</source>
          <target state="translated">때문에 &lt;code&gt;createClock&lt;/code&gt; 최초의 파라미터 타입이다 &lt;code&gt;ClockConstructor&lt;/code&gt; 에 &lt;code&gt;createClock(AnalogClock, 7, 32)&lt;/code&gt; , 그것을 확인하는 것이 &lt;code&gt;AnalogClock&lt;/code&gt; 는 올바른 생성자 서명을 갖는다.</target>
        </trans-unit>
        <trans-unit id="fc9360e6a9694db19840df20dcd21ab49ff88f74" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;haveMuscles&lt;/code&gt; is not exported, only the &lt;code&gt;animalsHaveMuscles&lt;/code&gt; function that shares the same un-merged namespace can see the symbol. The &lt;code&gt;doAnimalsHaveMuscles&lt;/code&gt; function, even though it&amp;rsquo;s part of the merged &lt;code&gt;Animal&lt;/code&gt; namespace can not see this un-exported member.</source>
          <target state="translated">&lt;code&gt;haveMuscles&lt;/code&gt; 는 내 보내지 않기 때문에 병합되지 않은 동일한 네임 스페이스를 공유하는 &lt;code&gt;animalsHaveMuscles&lt;/code&gt; 함수 만 심볼을 볼 수 있습니다. &lt;code&gt;doAnimalsHaveMuscles&lt;/code&gt; 은 의 그것의 일부가 합병에도 불구하고, 기능 &lt;code&gt;Animal&lt;/code&gt; 이름 공간이 내 보내지 않은 구성원을 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="889f24f65391ea32e9fe866488efa3356b72acf4" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;never&lt;/code&gt; is a subtype of every type, it is always omitted from union types and it is ignored in function return type inference as long as there are other types being returned.</source>
          <target state="translated">때문에 &lt;code&gt;never&lt;/code&gt; 모든 유형의 하위 유형입니다, 그것은 항상 노동 조합 유형의 생략과 긴 반환되는 다른 유형이 있기 때문에 같은 함수 반환 형식 유추에서 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b3b5c5e8091b38c11351f7ff855704d831cd693e" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;never&lt;/code&gt; is assignable to every type, a function returning &lt;code&gt;never&lt;/code&gt; can be used when a callback returning a more specific type is required:</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 모든 타입에 할당 할 수 없기 때문에 ,보다 특정한 타입을 반환하는 콜백이 필요할 때는 &lt;code&gt;never&lt;/code&gt; 반환하는 함수를 사용할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="860ec81e43c9b6e92f6dbbf8cdf9b9d2197d4f6a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;onClickGood&lt;/code&gt; specifies its &lt;code&gt;this&lt;/code&gt; type as &lt;code&gt;void&lt;/code&gt;, it is legal to pass to &lt;code&gt;addClickListener&lt;/code&gt;. Of course, this also means that it can&amp;rsquo;t use &lt;code&gt;this.info&lt;/code&gt;. If you want both then you&amp;rsquo;ll have to use an arrow function:</source>
          <target state="translated">때문에 &lt;code&gt;onClickGood&lt;/code&gt; 은 그 지정 &lt;code&gt;this&lt;/code&gt; 같은 유형의 &lt;code&gt;void&lt;/code&gt; ,에 전달할 법적 &lt;code&gt;addClickListener&lt;/code&gt; . 물론 이것은 &lt;code&gt;this.info&lt;/code&gt; 를 사용할 수 없다는 것을 의미합니다 . 둘 다 원한다면 화살표 기능을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="153757f182ba0912b5361e2742146aeb4241a619" translate="yes" xml:space="preserve">
          <source>Because TypeScript is a structural type system, type parameters only affect the resulting type when consumed as part of the type of a member. For example,</source>
          <target state="translated">TypeScript는 구조적 유형 시스템이므로 유형 매개 변수는 멤버 유형의 일부로 소비 될 때 결과 유형에만 영향을줍니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="a031100a59ee4b651a08813917a85230e2c2bcaf" translate="yes" xml:space="preserve">
          <source>Because TypeScript used to infer the type &lt;code&gt;BasicCalculator&lt;/code&gt; for each method in &lt;code&gt;BasicCalculator&lt;/code&gt; that returned &lt;code&gt;this&lt;/code&gt;, the type system would forget that it had &lt;code&gt;ScientificCalculator&lt;/code&gt; whenever using a &lt;code&gt;BasicCalculator&lt;/code&gt; method.</source>
          <target state="translated">TypeScript 는 &lt;code&gt;this&lt;/code&gt; 를 반환 한 &lt;code&gt;BasicCalculator&lt;/code&gt; 의 각 메소드에 대해 &lt;code&gt;BasicCalculator&lt;/code&gt; 유형을 유추하는 데 사용 되었기 때문에 유형 시스템은 &lt;code&gt;BasicCalculator&lt;/code&gt; 메소드를 사용할 때마다 &lt;code&gt;ScientificCalculator&lt;/code&gt; 를 가지고 있다는 사실을 잊었습니다 .</target>
        </trans-unit>
        <trans-unit id="b3b1d39859ec43b815d699d91662781b5301f06b" translate="yes" xml:space="preserve">
          <source>Because a Function Component is simply a JavaScript function, function overloads may be used here as well:</source>
          <target state="translated">함수 구성 요소는 단순히 JavaScript 함수이므로 함수 오버로드도 여기에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="346e805975d898d144111246435e10f969746b37" translate="yes" xml:space="preserve">
          <source>Because dependent projects make use of &lt;code&gt;.d.ts&lt;/code&gt; files that are built from their dependencies, you&amp;rsquo;ll either have to check in certain build outputs &lt;em&gt;or&lt;/em&gt; build a project after cloning it before you can navigate the project in an editor without seeing spurious errors. We&amp;rsquo;re working on a behind-the-scenes .d.ts generation process that should be able to mitigate this, but for now we recommend informing developers that they should build after cloning.</source>
          <target state="translated">종속 프로젝트 는 해당 종속 항목으로 빌드 된 &lt;code&gt;.d.ts&lt;/code&gt; 파일을 사용하기 때문에 특정 빌드 출력을 확인 &lt;em&gt;하거나&lt;/em&gt; 복제 한 후 프로젝트를 빌드해야 의심스러운 오류없이 편집기에서 프로젝트를 탐색 할 수 있습니다. 우리는이를 완화 할 수있는 무대 뒤에서 생성되는 .d.ts 생성 프로세스를 개발하고 있지만 현재로서는 개발자에게 복제 후 빌드하도록 지시하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="83ecbcc6afccbb397b118fab2ee6414e3c837482" translate="yes" xml:space="preserve">
          <source>Because each &lt;code&gt;unique symbol&lt;/code&gt; has a completely separate identity, no two &lt;code&gt;unique symbol&lt;/code&gt; types are assignable or comparable to each other.</source>
          <target state="translated">각각의 &lt;code&gt;unique symbol&lt;/code&gt; 은 완전히 별개의 아이덴티티를 가지 므로 , 두 개의 &lt;code&gt;unique symbol&lt;/code&gt; 유형이 서로 할당되거나 비교 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ce7c5c8de643b44139d21f506a256a1fa4c079dd" translate="yes" xml:space="preserve">
          <source>Because interfaces (and other object types) introduce a level of indirection and their full structure doesn&amp;rsquo;t need to be eagerly built out, TypeScript has no problem working with this structure.</source>
          <target state="translated">인터페이스 (및 기타 객체 유형)에 간접적 인 수준이 도입되고 전체 구조를 간절히 구축 할 필요가 없으므로 TypeScript는이 구조를 사용하는 데 아무런 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f30f185f6397eb98d238c4bebb2ebc5adf9430be" translate="yes" xml:space="preserve">
          <source>Because it&amp;rsquo;s usually easy to turn a global library into a UMD library, very few popular libraries are still written in the global style. However, libraries that are small and require the DOM (or have &lt;em&gt;no&lt;/em&gt; dependencies) may still be global.</source>
          <target state="translated">일반적으로 글로벌 라이브러리를 UMD 라이브러리로 쉽게 전환 할 수 있기 때문에 여전히 글로벌 스타일로 작성된 인기 라이브러리는 거의 없습니다. 그러나 크기가 작고 DOM이 필요하거나 종속성 이 &lt;em&gt;없는&lt;/em&gt; 라이브러리 는 여전히 전역적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8323beb09423cac98a2130445e161c576b080307" translate="yes" xml:space="preserve">
          <source>Because of that, they are now included by default in the standard library.</source>
          <target state="translated">이로 인해 이제 표준 라이브러리에 기본적으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="78c12007f3b8d8a541217ea17e828d1c39d86708" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;switch&lt;/code&gt; is no longer exhaustive, TypeScript is aware that the function could sometimes return &lt;code&gt;undefined&lt;/code&gt;. If you have an explicit return type &lt;code&gt;number&lt;/code&gt;, then you will get an error that the return type is actually &lt;code&gt;number | undefined&lt;/code&gt;. However, this method is quite subtle and, besides, &lt;code&gt;--strictNullChecks&lt;/code&gt; does not always work with old code.</source>
          <target state="translated">&lt;code&gt;switch&lt;/code&gt; 가 더 이상 완전하지 않기 때문에 TypeScript는 함수가 때때로 &lt;code&gt;undefined&lt;/code&gt; 를 반환 할 수 있음을 알고 있습니다. 명시적인 반환 유형 &lt;code&gt;number&lt;/code&gt; 가있는 경우 반환 유형이 실제로 &lt;code&gt;number | undefined&lt;/code&gt; 라는 오류가 발생합니다. undefined . 그러나이 방법은 매우 미묘하며 &lt;code&gt;--strictNullChecks&lt;/code&gt; 는 항상 이전 코드에서 작동하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="cef956693dc6ba68c2dd1bf8874b51293ed083ef" translate="yes" xml:space="preserve">
          <source>Because the best common type has to be chosen from the provided candidate types, there are some cases where types share a common structure, but no one type is the super type of all candidate types. For example:</source>
          <target state="translated">제공된 공통 유형에서 최상의 공통 유형을 선택해야하기 때문에 유형이 공통 구조를 공유하는 경우가 있지만 어떤 유형도 모든 후보 유형의 수퍼 유형이 아닙니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="61eeffa792a60ab404349a9470da23f0926e8080" translate="yes" xml:space="preserve">
          <source>Because the generic function is now constrained, it will no longer work over any and all types:</source>
          <target state="translated">이제 일반 함수가 제한되었으므로 더 이상 모든 유형에서 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2aaed882fdf6dc6a4a05e269679bc56b985060ef" translate="yes" xml:space="preserve">
          <source>Because these two types of value-based elements are indistinguishable from each other in a JSX expression, first TS tries to resolve the expression as a Function Component using overload resolution. If the process succeeds, then TS finishes resolving the expression to its declaration. If the value fails to resolve as a Function Component, TS will then try to resolve it as a class component. If that fails, TS will report an error.</source>
          <target state="translated">이 두 가지 유형의 값 기반 요소는 JSX 표현식에서 서로 구별 할 수 없으므로 첫 번째 TS는 과부하 해결을 사용하여 표현식을 함수 구성 요소로 해석하려고합니다. 프로세스가 성공하면 TS는 선언을 식으로 해석합니다. 값이 함수 구성 요소로 해석되지 않으면 TS는이를 클래스 구성 요소로 해석하려고 시도합니다. 실패하면 TS가 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="1803d91fbdbc9a61174b895ce63bd9e9db8a1a69" translate="yes" xml:space="preserve">
          <source>Because we&amp;rsquo;ve captured &lt;code&gt;city&lt;/code&gt; from within its environment, we&amp;rsquo;re still able to access it despite the fact that the &lt;code&gt;if&lt;/code&gt; block finished executing.</source>
          <target state="translated">우리는 환경 내에서 &lt;code&gt;city&lt;/code&gt; 를 점령했기 때문에 &lt;code&gt;if&lt;/code&gt; 블록의 실행이 완료 되었음에도 불구하고 도시에 계속 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d29eaff4a22709cf598b50d66101efbf59839265" translate="yes" xml:space="preserve">
          <source>Before ES2015, Javascript used constructor functions instead of classes. The compiler supports this pattern and understands constructor functions as equivalent to ES2015 classes. The property inference rules described above work exactly the same way.</source>
          <target state="translated">ES2015 이전에는 Javascript가 클래스 대신 생성자 함수를 사용했습니다. 컴파일러는이 패턴을 지원하고 ES2015 클래스와 동등한 생성자 함수를 이해합니다. 위에서 설명한 속성 유추 규칙은 정확히 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5da503870a40cc51e10eea3a3855e0636fb12368" translate="yes" xml:space="preserve">
          <source>Before TypeScript 2.0, a module identifier was always assumed to be extension-less; for instance, given an import as &lt;code&gt;import d from &quot;./moduleA.js&quot;&lt;/code&gt;, the compiler looked up the definition of &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; in &lt;code&gt;./moduleA.js.ts&lt;/code&gt; or &lt;code&gt;./moduleA.js.d.ts&lt;/code&gt;. This made it hard to use bundling/loading tools like &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt; that expect URI&amp;rsquo;s in their module identifier.</source>
          <target state="translated">TypeScript 2.0 이전에는 모듈 식별자가 항상 확장이없는 것으로 가정했습니다. 예를 들어 &lt;code&gt;import d from &quot;./moduleA.js&quot;&lt;/code&gt; 로 가져 오기를 수행 하면 컴파일러는 &lt;code&gt;./moduleA.js.ts&lt;/code&gt; 또는 &lt;code&gt;./moduleA.js.d.ts&lt;/code&gt; 에서 &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; 의 정의를 검색했습니다 . 이로 인해 모듈 식별자에 URI가 &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;필요한 SystemJS&lt;/a&gt; 와 같은 번들링 / 로딩 도구를 사용하기가 어려웠습니다 .</target>
        </trans-unit>
        <trans-unit id="7118581b77027e58723abfe83ca47073c2beca97" translate="yes" xml:space="preserve">
          <source>Before we get to Browserify, let&amp;rsquo;s build our code out and add modules to the mix. This is the structure you&amp;rsquo;re more likely to use for a real app.</source>
          <target state="translated">Browserify를 시작하기 전에 코드를 작성하고 믹스에 모듈을 추가하겠습니다. 실제 앱에 사용하기 쉬운 구조입니다.</target>
        </trans-unit>
        <trans-unit id="d3fafb80e647f5908678c0a1365fa6a9b3b25a53" translate="yes" xml:space="preserve">
          <source>Bellow both &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; will be marked as unused, because their values are never &lt;em&gt;read&lt;/em&gt;. Previously TypeScript would only check whether their values were &lt;em&gt;referenced&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;m&lt;/code&gt; 모두 벨로우즈 값을 &lt;em&gt;읽지&lt;/em&gt; 않기 때문에 미사용으로 표시됩니다 . 이전에 TypeScript는 해당 값이 &lt;em&gt;참조&lt;/em&gt; 되었는지 여부 만 확인했습니다 .</target>
        </trans-unit>
        <trans-unit id="b1593ec79184963de3c26cd55f6cd6ff5fde3164" translate="yes" xml:space="preserve">
          <source>Below, we&amp;rsquo;ve consolidated the Validator implementations used in previous examples to only export a single named export from each module.</source>
          <target state="translated">아래에서는 이전 예제에서 사용 된 Validator 구현을 통합하여 각 모듈에서 하나의 명명 된 내보내기 만 내보냈습니다.</target>
        </trans-unit>
        <trans-unit id="23b1b090e17cb993e2e92ba109a6404125e1c084" translate="yes" xml:space="preserve">
          <source>Best common type</source>
          <target state="translated">가장 일반적인 유형</target>
        </trans-unit>
        <trans-unit id="73f4d62437edf5f4e4d12a007397acc1aef2efe1" translate="yes" xml:space="preserve">
          <source>Better Module Visibility Rules</source>
          <target state="translated">더 나은 모듈 가시성 규칙</target>
        </trans-unit>
        <trans-unit id="24fe9a5afd90b3567ffa5a70e33cace7ce8a2cd6" translate="yes" xml:space="preserve">
          <source>Better Support for &lt;code&gt;never&lt;/code&gt;-Returning Functions</source>
          <target state="translated">&lt;code&gt;never&lt;/code&gt; 반환 기능에 대한 향상된 지원</target>
        </trans-unit>
        <trans-unit id="21657adf3906ba19a9fc0bf5880e4ab0670a6b78" translate="yes" xml:space="preserve">
          <source>Better Type Inference</source>
          <target state="translated">더 나은 타입 추론</target>
        </trans-unit>
        <trans-unit id="7d2959d47c022c161218042546a51da5d892926e" translate="yes" xml:space="preserve">
          <source>Better Unicode Support for Identifiers</source>
          <target state="translated">식별자에 대한 더 나은 유니 코드 지원</target>
        </trans-unit>
        <trans-unit id="9a0ba3945bacbf9283dac7172d7a127f0967cb4d" translate="yes" xml:space="preserve">
          <source>Better checking for &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt; in operands of expressions</source>
          <target state="translated">피연산자에서 &lt;code&gt;null&lt;/code&gt; / &lt;code&gt;undefined&lt;/code&gt; 를 더 잘 검사</target>
        </trans-unit>
        <trans-unit id="1edbfa311bc15bdb82e37657789378148ae24f62" translate="yes" xml:space="preserve">
          <source>Better handling for namespace patterns in &lt;code&gt;.js&lt;/code&gt; files</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; 파일 에서 네임 스페이스 패턴 처리 개선</target>
        </trans-unit>
        <trans-unit id="1459fb8ee8a9e746ee1ec8bc34a675600de96aa9" translate="yes" xml:space="preserve">
          <source>Better inference for literal types</source>
          <target state="translated">리터럴 유형에 대한 더 나은 추론</target>
        </trans-unit>
        <trans-unit id="948f70e8d9053f46439ba57d043632fa6e5a5de4" translate="yes" xml:space="preserve">
          <source>BigInt</source>
          <target state="translated">BigInt</target>
        </trans-unit>
        <trans-unit id="288d51c5150441fed0b9e86f5152123e527ee75c" translate="yes" xml:space="preserve">
          <source>BigInt support in TypeScript introduces a new primitive type called the &lt;code&gt;bigint&lt;/code&gt; (all lowercase). You can get a &lt;code&gt;bigint&lt;/code&gt; by calling the &lt;code&gt;BigInt()&lt;/code&gt; function or by writing out a BigInt literal by adding an &lt;code&gt;n&lt;/code&gt; to the end of any integer numeric literal:</source>
          <target state="translated">TypeScript에서 BigInt 지원은 &lt;code&gt;bigint&lt;/code&gt; (모두 소문자) 라는 새로운 기본 유형을 도입합니다 . &lt;code&gt;BigInt()&lt;/code&gt; 함수 를 호출 하거나 정수 숫자 리터럴의 끝에 &lt;code&gt;n&lt;/code&gt; 을 추가하여 BigInt 리터럴을 작성 하여 &lt;code&gt;bigint&lt;/code&gt; 를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="554ca025eac7b2c84da4d87e6d9f6fd09932aeac" translate="yes" xml:space="preserve">
          <source>BigInts are part of an upcoming proposal in ECMAScript that allow us to model theoretically arbitrarily large integers. TypeScript 3.2 brings type-checking for BigInts, as well as support for emitting BigInt literals when targeting &lt;code&gt;esnext&lt;/code&gt;.</source>
          <target state="translated">BigInts는 이론적으로 임의로 큰 정수를 모델링 할 수있는 ECMAScript의 향후 제안의 일부입니다. 타이프 3.2 타겟팅 할 때의 BIGINT 리터럴을 방출 BigInts 종류별 검사뿐만 아니라 지원을 제공 &lt;code&gt;esnext&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="680e45e0d9641fb72fe09a5f60291f49ec52f51b" translate="yes" xml:space="preserve">
          <source>Block scoped</source>
          <target state="translated">범위가 지정된 블록</target>
        </trans-unit>
        <trans-unit id="6a8c3370d98498723b46771881ba81defd0dc40c" translate="yes" xml:space="preserve">
          <source>Block-scoped variable capturing</source>
          <target state="translated">블록 범위의 변수 캡처</target>
        </trans-unit>
        <trans-unit id="a849fb31e66cbf4e00c81e17be0f996cdee6ecbd" translate="yes" xml:space="preserve">
          <source>Block-scoping</source>
          <target state="translated">Block-scoping</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="a34e54cea707257c0130f46138224a1c1962a392" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;for..of&lt;/code&gt; and &lt;code&gt;for..in&lt;/code&gt; statements iterate over lists; the values iterated on are different though, &lt;code&gt;for..in&lt;/code&gt; returns a list of &lt;em&gt;keys&lt;/em&gt; on the object being iterated, whereas &lt;code&gt;for..of&lt;/code&gt; returns a list of &lt;em&gt;values&lt;/em&gt; of the numeric properties of the object being iterated.</source>
          <target state="translated">&lt;code&gt;for..of&lt;/code&gt; 및 &lt;code&gt;for..in&lt;/code&gt; 문 모두 목록을 반복합니다. 반복되는 값은 다르지만 &lt;code&gt;for..in&lt;/code&gt; 은 반복되는 객체 의 &lt;em&gt;키&lt;/em&gt; 목록을 반환하고 &lt;code&gt;for..of&lt;/code&gt; 는 반복되는 객체 의 숫자 속성 &lt;em&gt;값&lt;/em&gt; 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="883409a532b5058d1cc5b8f4b490cb78e4d78575" translate="yes" xml:space="preserve">
          <source>Both CommonJS and AMD generally have the concept of an &lt;code&gt;exports&lt;/code&gt; object which contains all exports from a module.</source>
          <target state="translated">CommonJS와 AMD는 일반적으로 모듈의 모든 내보내기를 포함 하는 &lt;code&gt;exports&lt;/code&gt; 오브젝트 개념을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e51d223984b330914b72e271341f74aef8d2cd0b" translate="yes" xml:space="preserve">
          <source>Both of these dependencies will let TypeScript and webpack play well together. ts-loader helps Webpack compile your TypeScript code using the TypeScript&amp;rsquo;s standard configuration file named &lt;code&gt;tsconfig.json&lt;/code&gt;. source-map-loader uses any sourcemap outputs from TypeScript to inform webpack when generating &lt;em&gt;its own&lt;/em&gt; sourcemaps. This will allow you to debug your final output file as if you were debugging your original TypeScript source code.</source>
          <target state="translated">이 두 가지 의존성 모두 TypeScript와 웹팩을 함께 사용할 수 있습니다. ts-loader는 Typepack의 표준 구성 파일 &lt;code&gt;tsconfig.json&lt;/code&gt; 을 사용하여 Webpack이 TypeScript 코드를 컴파일하도록 도와줍니다 . sourcemap 로더를 생성 할 때 웹팩 알려 타이프에서 모든 sourcemap 출력을 사용하여 &lt;em&gt;자체&lt;/em&gt; sourcemaps한다. 이렇게하면 원본 TypeScript 소스 코드를 디버깅하는 것처럼 최종 출력 파일을 디버깅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f6f50fe6a684e36f2680d1b1f0d995148104f1b" translate="yes" xml:space="preserve">
          <source>Breaking Changes</source>
          <target state="translated">주요 변경 사항</target>
        </trans-unit>
        <trans-unit id="b27e195ce4797e99f5340bc74096020036597226" translate="yes" xml:space="preserve">
          <source>Broadly speaking, the way you &lt;em&gt;structure&lt;/em&gt; your declaration file depends on how the library is consumed. There are many ways of offering a library for consumption in JavaScript, and you&amp;rsquo;ll need to write your declaration file to match it. This guide covers how to identify common library patterns, and how to write declaration files which correspond to that pattern.</source>
          <target state="translated">일반적으로 선언 파일 을 &lt;em&gt;구성&lt;/em&gt; 하는 방법은 라이브러리 사용 방식에 따라 다릅니다. JavaScript에서 사용할 라이브러리를 제공하는 방법에는 여러 가지가 있으며, 선언 파일을 작성하여 일치시켜야합니다. 이 안내서는 일반적인 라이브러리 패턴을 식별하는 방법과 해당 패턴에 해당하는 선언 파일을 작성하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ed81754147c265a661af47b5f96c56bae653c0d7" translate="yes" xml:space="preserve">
          <source>Browserify</source>
          <target state="translated">Browserify</target>
        </trans-unit>
        <trans-unit id="edcb28a656230c4acfe867a59a63fd0995d0aef6" translate="yes" xml:space="preserve">
          <source>Build Mode for TypeScript</source>
          <target state="translated">TypeScript의 빌드 모드</target>
        </trans-unit>
        <trans-unit id="97e7d70d841f68a4ff5d6072efb212e8b37ee112" translate="yes" xml:space="preserve">
          <source>Build mode (see below) will automatically build the referenced project if needed</source>
          <target state="translated">필요한 경우 빌드 모드 (아래 참조)가 참조 된 프로젝트를 자동으로 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="9a92faaf499ddda5acb18453d8927f47fed81460" translate="yes" xml:space="preserve">
          <source>Build out-of-date projects in the correct order</source>
          <target state="translated">올바른 순서로 오래된 프로젝트를 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="2764e7dc64a6afa8f6572a70be9cc2ef88d207b2" translate="yes" xml:space="preserve">
          <source>Build tools</source>
          <target state="translated">빌드 도구</target>
        </trans-unit>
        <trans-unit id="75ec9400efe849c1db62787034008d1f92c2c91f" translate="yes" xml:space="preserve">
          <source>Build-Free Editing with Project References</source>
          <target state="translated">프로젝트 참조를 사용한 빌드없는 편집</target>
        </trans-unit>
        <trans-unit id="4af30b251537bff0e947429ed6b58b4a863bc66d" translate="yes" xml:space="preserve">
          <source>Building on that work, the new &lt;code&gt;Generator&lt;/code&gt; type is an &lt;code&gt;Iterator&lt;/code&gt; that always has both the &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;throw&lt;/code&gt; methods present, and is also iterable.</source>
          <target state="translated">이 작업을 기반으로하는 새로운 &lt;code&gt;Generator&lt;/code&gt; 유형은 항상 &lt;code&gt;return&lt;/code&gt; 및 &lt;code&gt;throw&lt;/code&gt; 메소드 가 모두 존재하고 반복 가능한 &lt;code&gt;Iterator&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="7a2e862f607c464ec5aa4c11cde1137378e9c2a2" translate="yes" xml:space="preserve">
          <source>Building your first TypeScript file</source>
          <target state="translated">첫 번째 TypeScript 파일 작성</target>
        </trans-unit>
        <trans-unit id="03b24ded4facb2cf945d4c05f6eb1ab851a39a94" translate="yes" xml:space="preserve">
          <source>Builds this project and all of its dependencies specified by &lt;a href=&quot;project-references&quot;&gt;Project References&lt;/a&gt;. Note that this flag is not compatible with others on this page. See more &lt;a href=&quot;project-references&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">이 프로젝트와 &lt;a href=&quot;project-references&quot;&gt;Project References에&lt;/a&gt; 의해 지정된 모든 종속성을 빌드합니다 . 이 플래그는이 페이지의 다른 플래그와 호환되지 않습니다. &lt;a href=&quot;project-references&quot;&gt;여기&lt;/a&gt; 더 참조</target>
        </trans-unit>
        <trans-unit id="343555e3e4e0ac83e26882ec6baa2142ba94e980" translate="yes" xml:space="preserve">
          <source>Built-in &lt;em&gt;lib&lt;/em&gt; files are referenced in the same fashion as the &lt;code&gt;&quot;lib&quot;&lt;/code&gt; compiler option in &lt;em&gt;tsconfig.json&lt;/em&gt; (e.g. use &lt;code&gt;lib=&quot;es2015&quot;&lt;/code&gt; and not &lt;code&gt;lib=&quot;lib.es2015.d.ts&quot;&lt;/code&gt;, etc.).</source>
          <target state="translated">내장 된 &lt;em&gt;lib&lt;/em&gt; 파일은 &lt;em&gt;tsconfig.json&lt;/em&gt; 의 &lt;code&gt;&quot;lib&quot;&lt;/code&gt; 컴파일러 옵션 과 같은 방식으로 참조됩니다 (예 : &lt;code&gt;lib=&quot;es2015&quot;&lt;/code&gt; 등이 아닌 &lt;code&gt;lib=&quot;lib.es2015.d.ts&quot;&lt;/code&gt; ).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="baf48ef674c1f3f27e6a46bcb471b4b64069504c" translate="yes" xml:space="preserve">
          <source>Built-in Combinations</source>
          <target state="translated">내장 조합</target>
        </trans-unit>
        <trans-unit id="f915eb393ecd85cb63e15dffe8826e1553f8b829" translate="yes" xml:space="preserve">
          <source>But &lt;em&gt;not&lt;/em&gt;</source>
          <target state="translated">그러나 &lt;em&gt;아닙니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1b2b6d682a32e9471d3d56044de293812fad6102" translate="yes" xml:space="preserve">
          <source>But as an example of a place where conditional types are deferred - where they stick around instead of picking a branch - would be in the following:</source>
          <target state="translated">그러나 조건부 유형이 지연되는 지점의 예를 들어 분기를 선택하는 대신 고정되는 위치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7399465efb16f2292f334ce116d2782df394ded" translate="yes" xml:space="preserve">
          <source>But it&amp;rsquo;s more useful to have a general version.</source>
          <target state="translated">그러나 일반 버전을 사용하는 것이 더 유용합니다.</target>
        </trans-unit>
        <trans-unit id="52aa7f7d640381262f44bf2422e0184ae5802614" translate="yes" xml:space="preserve">
          <source>But specifying defaults is more common for parameters, and getting defaults right with destructuring can be tricky. First of all, you need to remember to put the pattern before the default value.</source>
          <target state="translated">그러나 기본값을 지정하는 것이 매개 변수에 더 일반적이며, 구조화를 통해 기본값을 올바르게 설정하는 것은 까다로울 수 있습니다. 우선, 패턴을 기본값보다 먼저 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5085629431a212a779f2b5de79ca5c3f88994593" translate="yes" xml:space="preserve">
          <source>But workaround of introducing the interface wasn&amp;rsquo;t intuitive for users. And in principle there really wasn&amp;rsquo;t anything wrong with the original version of &lt;code&gt;ValueOrArray&lt;/code&gt; that used &lt;code&gt;Array&lt;/code&gt; directly. If the compiler was a little bit &amp;ldquo;lazier&amp;rdquo; and only calculated the type arguments to &lt;code&gt;Array&lt;/code&gt; when necessary, then TypeScript could express these correctly.</source>
          <target state="translated">그러나 인터페이스 도입에 대한 해결 방법은 사용자에게는 직관적이지 않았습니다. 그리고 원칙적으로 &lt;code&gt;Array&lt;/code&gt; 를 직접 사용 하는 원래 버전의 &lt;code&gt;ValueOrArray&lt;/code&gt; 에는 아무런 문제가 없었습니다 . 컴파일러가 &quot;게으르다&quot;고 필요할 때 &lt;code&gt;Array&lt;/code&gt; 대한 형식 인수 만 계산하면 TypeScript가이를 올바르게 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4960285f41cfd516633e4d60d8fcdf547d96a1af" translate="yes" xml:space="preserve">
          <source>By Example</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="56013fe0821df629b3c4ad53f4b6924be246e572" translate="yes" xml:space="preserve">
          <source>By Example: Classes</source>
          <target state="translated">예를 들어 : 클래스</target>
        </trans-unit>
        <trans-unit id="6b36dc2d84d25fdd51b964cd61bedec7d9e60902" translate="yes" xml:space="preserve">
          <source>By Example: Global Functions</source>
          <target state="translated">예를 들어 : 전역 함수</target>
        </trans-unit>
        <trans-unit id="3744ba63d2d3cc6574aaf71d98c1674b39508a8a" translate="yes" xml:space="preserve">
          <source>By Example: Global Variables</source>
          <target state="translated">예를 들어 : 전역 변수</target>
        </trans-unit>
        <trans-unit id="eea9b1c9ef5abea178ee5d4cd53163ad4f035d14" translate="yes" xml:space="preserve">
          <source>By Example: Objects with Properties</source>
          <target state="translated">예 : 속성이있는 객체</target>
        </trans-unit>
        <trans-unit id="74283c34f93d05517451768bcffe2038c4e7a212" translate="yes" xml:space="preserve">
          <source>By Example: Organizing Types</source>
          <target state="translated">예 : 유형 구성</target>
        </trans-unit>
        <trans-unit id="786404ba943c8314507c329a9d6f9d54f3179127" translate="yes" xml:space="preserve">
          <source>By Example: Overloaded Functions</source>
          <target state="translated">예를 들어 : 오버로드 된 함수</target>
        </trans-unit>
        <trans-unit id="c20e92aa75ef55f57a42b723ab0f280766d7b7fe" translate="yes" xml:space="preserve">
          <source>By Example: Reusable Types (Interfaces)</source>
          <target state="translated">예 : 재사용 가능한 유형 (인터페이스)</target>
        </trans-unit>
        <trans-unit id="7a1f49420a7b27a3ee7b0e838fa3b2dbec6f81a8" translate="yes" xml:space="preserve">
          <source>By Example: Reusable Types (Type Aliases)</source>
          <target state="translated">예 : 재사용 가능한 유형 (유형 별명)</target>
        </trans-unit>
        <trans-unit id="a082a066e7a09d6b1c6e75f3176d5a38819ca5b2" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are subtypes of all other types. That means you can assign &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; to something like &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 는 다른 모든 유형의 하위 유형입니다. 즉, &lt;code&gt;null&lt;/code&gt; 과 &lt;code&gt;undefined&lt;/code&gt; 를 &lt;code&gt;number&lt;/code&gt; 와 같은 것으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88529c44919e2de860ade6d72375e6a6ee709e4e" translate="yes" xml:space="preserve">
          <source>By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules like a bundlers (e.g. &lt;code&gt;r.js&lt;/code&gt;).</source>
          <target state="translated">기본적으로 AMD 모듈은 익명으로 생성됩니다. 다른 도구를 사용하여 &lt;code&gt;r.js&lt;/code&gt; (예 : r.js ) 와 같은 결과 모듈을 처리 할 때 문제가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c715e4fe44b99c0302712a9e167af08e84c2d13" translate="yes" xml:space="preserve">
          <source>By default AMD modules are generated anonymous. This can lead to problems when other tools are used to process the resulting modules, such as bundlers (e.g. &lt;code&gt;r.js&lt;/code&gt;).</source>
          <target state="translated">기본적으로 AMD 모듈은 익명으로 생성됩니다. 이로 인해 &lt;code&gt;r.js&lt;/code&gt; (예 : r.js ) 와 같은 다른 모듈을 사용하여 결과 모듈을 처리 할 때 문제가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4d87e4e57028fc486e676c2ecdd8c6471f91d0c" translate="yes" xml:space="preserve">
          <source>By default all &lt;em&gt;visible&lt;/em&gt; &amp;ldquo;&lt;code&gt;@types&lt;/code&gt;&amp;rdquo; packages are included in your compilation. Packages in &lt;code&gt;node_modules/@types&lt;/code&gt; of any enclosing folder are considered &lt;em&gt;visible&lt;/em&gt;; specifically, that means packages within &lt;code&gt;./node_modules/@types/&lt;/code&gt;, &lt;code&gt;../node_modules/@types/&lt;/code&gt;, &lt;code&gt;../../node_modules/@types/&lt;/code&gt;, and so on.</source>
          <target state="translated">기본적으로 &lt;em&gt;보이는&lt;/em&gt; 모든 &quot; &lt;code&gt;@types&lt;/code&gt; &quot;패키지가 컴파일에 포함됩니다. &lt;code&gt;node_modules/@types&lt;/code&gt; 클로징 폴더의 node_modules / @ types 패키지는 &lt;em&gt;표시&lt;/em&gt; 되는 것으로 간주됩니다 . 즉, &lt;code&gt;./node_modules/@types/&lt;/code&gt; , &lt;code&gt;../node_modules/@types/&lt;/code&gt; , &lt;code&gt;../../node_modules/@types/&lt;/code&gt; 등의 패키지를 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="e369ee47538940ad2b625bd062454fb84b462ef8" translate="yes" xml:space="preserve">
          <source>By default the TypeScript compiler does not report any errors in .js files including using &lt;code&gt;--allowJs&lt;/code&gt;. With TypeScript 2.3 type-checking errors can also be reported in &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--checkJs&lt;/code&gt;.</source>
          <target state="translated">기본적으로 TypeScript 컴파일러는 &lt;code&gt;--allowJs&lt;/code&gt; 사용을 포함하여 .js 파일의 오류를보고하지 않습니다 . 타이프 라이터로 2.3 유형 검사 오류는보고 할 수 &lt;code&gt;.js&lt;/code&gt; 와 파일 &lt;code&gt;--checkJs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4e6fef05048e1036967e644248934ab3290242b" translate="yes" xml:space="preserve">
          <source>By default the output new line character is &lt;code&gt;\r\n&lt;/code&gt; on Windows based systems and &lt;code&gt;\n&lt;/code&gt; on *nix based systems. &lt;code&gt;--newLine&lt;/code&gt; command line flag allows overriding this behavior and specifying the new line character to be used in generated output files.</source>
          <target state="translated">기본적으로 출력 줄 바꾸기 문자는 Windows 기반 시스템에서 &lt;code&gt;\r\n&lt;/code&gt; 이고 * nix 기반 시스템에서 &lt;code&gt;\n&lt;/code&gt; 입니다. &lt;code&gt;--newLine&lt;/code&gt; 명령 줄 플래그를 사용하면이 동작을 재정의하고 생성 된 출력 파일에 사용할 줄 바꾸기 문자를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b8dc7f5bdcc1f900ed0076c9443382574f8ede2" translate="yes" xml:space="preserve">
          <source>By default the result of a JSX expression is typed as &lt;code&gt;any&lt;/code&gt;. You can customize the type by specifying the &lt;code&gt;JSX.Element&lt;/code&gt; interface. However, it is not possible to retrieve type information about the element, attributes or children of the JSX from this interface. It is a black box.</source>
          <target state="translated">기본적으로 JSX 식의 결과로 입력되어 &lt;code&gt;any&lt;/code&gt; . &lt;code&gt;JSX.Element&lt;/code&gt; 인터페이스 를 지정하여 유형을 사용자 정의 할 수 있습니다 . 그러나이 인터페이스에서 JSX의 요소, 속성 또는 하위에 대한 유형 정보를 검색 할 수 없습니다. 블랙 박스입니다.</target>
        </trans-unit>
        <trans-unit id="ab2b32ff0e315d45d6fc02e2a6cbedac511ef9df" translate="yes" xml:space="preserve">
          <source>By default the type of &lt;code&gt;this&lt;/code&gt; inside a function is &lt;code&gt;any&lt;/code&gt;. Starting with TypeScript 2.0, you can provide an explicit &lt;code&gt;this&lt;/code&gt; parameter. &lt;code&gt;this&lt;/code&gt; parameters are fake parameters that come first in the parameter list of a function:</source>
          <target state="translated">기본적 으로 함수 내 &lt;code&gt;this&lt;/code&gt; 유형 은 &lt;code&gt;any&lt;/code&gt; 입니다. TypeScript 2.0부터 명시적인 &lt;code&gt;this&lt;/code&gt; 매개 변수를 제공 할 수 있습니다 . &lt;code&gt;this&lt;/code&gt; 매개 변수는 함수의 매개 변수 목록에서 가장 먼저 나오는 가짜 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="b1b20c9a3a0cc7d25cfbb8affbd8cc2de8f4531f" translate="yes" xml:space="preserve">
          <source>By default with these settings, when we run &lt;code&gt;tsc&lt;/code&gt;, TypeScript will look for a file called &lt;code&gt;.tsbuildinfo&lt;/code&gt; in the output directory (&lt;code&gt;./lib&lt;/code&gt;). If &lt;code&gt;./lib/.tsbuildinfo&lt;/code&gt; doesn&amp;rsquo;t exist, it&amp;rsquo;ll be generated. But if it does, &lt;code&gt;tsc&lt;/code&gt; will try to use that file to incrementally type-check and update our output files.</source>
          <target state="translated">이러한 설정으로 기본적으로 &lt;code&gt;tsc&lt;/code&gt; 를 실행 하면 TypeScript는 출력 디렉토리 ( &lt;code&gt;./lib&lt;/code&gt; ) 에서 &lt;code&gt;.tsbuildinfo&lt;/code&gt; 라는 파일을 찾습니다 . 경우 &lt;code&gt;./lib/.tsbuildinfo&lt;/code&gt; 이 존재하지 않는, 그것은 생성됩니다. 그러나 만약 그렇다면, &lt;code&gt;tsc&lt;/code&gt; 는 그 파일을 사용하여 출력 파일을 점진적으로 타입 검사하고 업데이트하려고 시도 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="978c0bcb7dd8270885bef9e6f191062a2f183d1b" translate="yes" xml:space="preserve">
          <source>By default, TypeScript assumes that &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are in the domain of every type. That means anything declared with the type &lt;code&gt;number&lt;/code&gt; could be &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. Since &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are such a frequent source of bugs in JavaScript and TypeScript, TypeScript has the &lt;code&gt;strictNullChecks&lt;/code&gt; option to spare you the stress of worrying about these issues.</source>
          <target state="translated">기본적으로 TypeScript는 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 가 모든 유형의 도메인에 있다고 가정합니다 . 즉, 유형 &lt;code&gt;number&lt;/code&gt; 선언 된 것은 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 일 수 있습니다 . 때문에 &lt;code&gt;null&lt;/code&gt; 와 &lt;code&gt;undefined&lt;/code&gt; 자바 스크립트와 타이프 라이터 버그의 이러한 자주 원천, 타이프 라이터는이 &lt;code&gt;strictNullChecks&lt;/code&gt; 의 이러한 문제에 대한 걱정의 당신에게 스트레스를 절약하는 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="d2a8ae67117a0b9e1048859af200beff97bdb1a4" translate="yes" xml:space="preserve">
          <source>By default, enums begin numbering their members starting at &lt;code&gt;0&lt;/code&gt;. You can change this by manually setting the value of one of its members. For example, we can start the previous example at &lt;code&gt;1&lt;/code&gt; instead of &lt;code&gt;0&lt;/code&gt;:</source>
          <target state="translated">기본적으로 열거 형은 &lt;code&gt;0&lt;/code&gt; 부터 시작하여 멤버의 번호를 지정합니다 . 멤버 중 하나의 값을 수동으로 설정하여이를 변경할 수 있습니다. 예를 들어 이전 예제를 &lt;code&gt;0&lt;/code&gt; 대신 &lt;code&gt;1&lt;/code&gt; 에서 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="132e01557f70ffea3b32aeb9180827e17d27b06d" translate="yes" xml:space="preserve">
          <source>By doing this, you can greatly improve build times, enforce logical separation between components, and organize your code in new and better ways.</source>
          <target state="translated">이렇게하면 빌드 시간을 크게 향상시키고 구성 요소 간 논리적 분리를 시행하며 새롭고 더 나은 방법으로 코드를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="692f9bb4646bcb36f65c5f7ab233f8f2764f0cb4" translate="yes" xml:space="preserve">
          <source>By installing TypeScript&amp;rsquo;s Visual Studio plugins</source>
          <target state="translated">TypeScript의 Visual Studio 플러그인을 설치함으로써</target>
        </trans-unit>
        <trans-unit id="86eb4b62601e3e81ff1dca5cc4e6dbdc4a89a2c0" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files and a -project (or just -p) command line option that specifies the path of a directory containing a tsconfig.json file.</source>
          <target state="translated">입력 파일없이 tsc를 호출하고 tsconfig.json 파일을 포함하는 디렉토리의 경로를 지정하는 -project (또는 단지 -p) 명령 행 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ad9887b67e7c7119b9c0b607afc13f555d0df339" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files and a &lt;code&gt;--project&lt;/code&gt; (or just &lt;code&gt;-p&lt;/code&gt;) command line option that specifies the path of a directory containing a &lt;code&gt;tsconfig.json&lt;/code&gt; file, or a path to a valid &lt;code&gt;.json&lt;/code&gt; file containing the configurations.</source>
          <target state="translated">입력 파일없이 tsc를 호출 하고 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일을 포함하는 디렉토리 의 경로 또는 구성을 포함 하는 유효한 &lt;code&gt;.json&lt;/code&gt; 파일 의 경로를 지정 하는 &lt;code&gt;--project&lt;/code&gt; (또는 그냥 &lt;code&gt;-p&lt;/code&gt; ) 명령 행 옵션을 사용 하여.</target>
        </trans-unit>
        <trans-unit id="3c63c6b34aecd8a89f4657217a7bc97d993bf39e" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files, in which case the compiler searches for the &lt;code&gt;tsconfig.json&lt;/code&gt; file starting in the current directory and continuing up the parent directory chain.</source>
          <target state="translated">입력 파일없이 tsc를 호출하면 컴파일러 는 현재 디렉토리에서 시작하여 상위 디렉토리 체인을 계속 하여 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="e89553a08b737777f431dc9d9801f1465f3a4fb2" translate="yes" xml:space="preserve">
          <source>By invoking tsc with no input files, in which case the compiler searches for the tsconfig.json file starting in the current directory and continuing up the parent directory chain.</source>
          <target state="translated">입력 파일없이 tsc를 호출하면 컴파일러는 현재 디렉토리에서 시작하여 상위 디렉토리 체인을 계속하여 tsconfig.json 파일을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="79537a92f4047372fecdfd37460ca2a8188a29b0" translate="yes" xml:space="preserve">
          <source>By just passing the &lt;code&gt;--pretty&lt;/code&gt; command line option, TypeScript gives more colorful output with context about where things are going wrong.</source>
          <target state="translated">&lt;code&gt;--pretty&lt;/code&gt; 명령 줄 옵션을 전달하면 TypeScript는 상황이 잘못되는 상황에 대한보다 다채로운 출력을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e52ec44ebc49650e959b28d0b5dbe4cdf8ee0312" translate="yes" xml:space="preserve">
          <source>By leveraging &lt;code&gt;rootDirs&lt;/code&gt; we can inform the compiler of this mapping and thereby allow it to safely resolve &lt;code&gt;./#{locale}/messages&lt;/code&gt;, even though the directory will never exist. For example, with the following &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;rootDirs&lt;/code&gt; 를 활용 하여 컴파일러에이 매핑을 &lt;code&gt;./#{locale}/messages&lt;/code&gt; 디렉토리가 존재하지 않더라도 ./#{locale}/messages 를 안전하게 해석 할 수 있습니다. 예를 들어, 다음 &lt;code&gt;tsconfig.json&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a6554ec42c2340c5fe50c2d315a5a222a594fab" translate="yes" xml:space="preserve">
          <source>By now you&amp;rsquo;ve figured out that &lt;code&gt;var&lt;/code&gt; has some problems, which is precisely why &lt;code&gt;let&lt;/code&gt; statements were introduced. Apart from the keyword used, &lt;code&gt;let&lt;/code&gt; statements are written the same way &lt;code&gt;var&lt;/code&gt; statements are.</source>
          <target state="translated">지금까지 &lt;code&gt;var&lt;/code&gt; 에 몇 가지 문제 가 있음을 알아 냈습니다 . 이것이 바로 &lt;code&gt;let&lt;/code&gt; 문이 도입 된 이유 입니다. 별도로 사용되는 키워드에서, &lt;code&gt;let&lt;/code&gt; 문이 같은 방식으로 작성됩니다 &lt;code&gt;var&lt;/code&gt; 에 문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8cb72c1385357bc15ce05b98a7efaf15553d757" translate="yes" xml:space="preserve">
          <source>By reading this guide, you&amp;rsquo;ll have the tools to write complex definition files that expose a friendly API surface. This guide focuses on module (or UMD) libraries because the options here are more varied.</source>
          <target state="translated">이 안내서를 읽으면 친숙한 API 표면을 노출하는 복잡한 정의 파일을 작성하는 도구가 제공됩니다. 이 가이드는 옵션이 다양하기 때문에 모듈 (또는 UMD) 라이브러리에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="411c4003c83ae27481aabc4631e018c37321d319" translate="yes" xml:space="preserve">
          <source>By separating into multiple projects, you can greatly improve the speed of typechecking and compiling, reduce memory usage when using an editor, and improve enforcement of the logical groupings of your program.</source>
          <target state="translated">여러 프로젝트로 분리하여 유형 검사 및 컴파일 속도를 크게 향상시키고 편집기 사용시 메모리 사용량을 줄이며 프로그램의 논리적 그룹 적용을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3214b1c0cea1d0e9f41edbd469679a29258a29b8" translate="yes" xml:space="preserve">
          <source>By the way, note that whereas some languages (e.g. C# and Scala) require variance annotations (&lt;code&gt;out&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt; or &lt;code&gt;+&lt;/code&gt;/&lt;code&gt;-&lt;/code&gt;), variance emerges naturally from the actual use of a type parameter within a generic type due to TypeScript&amp;rsquo;s structural type system.</source>
          <target state="translated">그런데 일부 언어 (예 : C # 및 스칼라)에는 분산 주석 ( &lt;code&gt;out&lt;/code&gt; / &lt;code&gt;in&lt;/code&gt; 또는 &lt;code&gt;+&lt;/code&gt; / &lt;code&gt;-&lt;/code&gt; )이 필요하지만 TypeScript의 구조적 유형 시스템으로 인해 일반 유형 내에서 유형 매개 변수를 실제로 사용하면 차이가 자연스럽게 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ff2ff01863822bd01179d80d30eb7f560237e6bf" translate="yes" xml:space="preserve">
          <source>Cache tagged template objects in modules</source>
          <target state="translated">태그가 지정된 템플릿 객체를 모듈에 캐시</target>
        </trans-unit>
        <trans-unit id="3ca09b900f387b256b85a63942148d4d37afb51a" translate="yes" xml:space="preserve">
          <source>Calculator.ts</source>
          <target state="translated">Calculator.ts</target>
        </trans-unit>
        <trans-unit id="401d915f4e82bf6c954f6cd72e5e9f45a0aa5cb6" translate="yes" xml:space="preserve">
          <source>Callback Types</source>
          <target state="translated">콜백 유형</target>
        </trans-unit>
        <trans-unit id="fafd26147b30637f1273073910f82f95e1d409ec" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;showHello&lt;/code&gt; calls &lt;code&gt;sayHello&lt;/code&gt; to change the paragraph&amp;rsquo;s text. Now change your gulpfile to the following:</source>
          <target state="translated">호출 &lt;code&gt;showHello&lt;/code&gt; 는 호출 &lt;code&gt;sayHello&lt;/code&gt; 단락의 텍스트를 변경할 수 있습니다. 이제 gulpfile을 다음과 같이 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="b5a615e5088a07823ba43f480f4662c6c1a80354" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;define(...)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;define(...)&lt;/code&gt; 호출 (...)</target>
        </trans-unit>
        <trans-unit id="54ab62e91bddb3f6354c13e8b487593b38248ac3" translate="yes" xml:space="preserve">
          <source>Can be used in a non-module file &lt;code&gt;global-script.ts&lt;/code&gt;:</source>
          <target state="translated">비 모듈 파일 &lt;code&gt;global-script.ts&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4380ba68d466c9670378cbd5fc0514cb1373ac15" translate="yes" xml:space="preserve">
          <source>Case clause fall-throughs</source>
          <target state="translated">사례 조항 실패</target>
        </trans-unit>
        <trans-unit id="e7500c883cdd17fa4172ea83911ebf91a32625de" translate="yes" xml:space="preserve">
          <source>Casts</source>
          <target state="translated">Casts</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="3b3bc5f42ea5021b780ab4b12ba77a349aaacc40" translate="yes" xml:space="preserve">
          <source>Caveats for Project References</source>
          <target state="translated">프로젝트 참조를위한주의 사항</target>
        </trans-unit>
        <trans-unit id="1c2ce6c0623a19e14dbf0dfa2aff6c6b8a60ed59" translate="yes" xml:space="preserve">
          <source>Certain targets may include a polyfill or BigInt-like runtime object. For those purposes you may want to add &lt;code&gt;esnext.bigint&lt;/code&gt; to the &lt;code&gt;lib&lt;/code&gt; setting in your compiler options.</source>
          <target state="translated">특정 대상에는 폴리 필 또는 BigInt와 유사한 런타임 객체가 포함될 수 있습니다. 이러한 목적으로 컴파일러 옵션 의 &lt;code&gt;lib&lt;/code&gt; 설정에 &lt;code&gt;esnext.bigint&lt;/code&gt; 를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d793fe93a13b689ec59340423e9412ead64313c" translate="yes" xml:space="preserve">
          <source>Changes include:</source>
          <target state="translated">변경 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3e20420d40f382739b91cf88de0439e6594790f" translate="yes" xml:space="preserve">
          <source>Changes to &lt;code&gt;@types/React&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@types/React&lt;/code&gt; 변경</target>
        </trans-unit>
        <trans-unit id="8221b7b528304e76abf18d987bda46c6ee653964" translate="yes" xml:space="preserve">
          <source>Changing just the &lt;em&gt;internals&lt;/em&gt; in the implementation files required &lt;em&gt;typechecking&lt;/em&gt; the tests again, even though this wouldn&amp;rsquo;t ever cause new errors</source>
          <target state="translated">단지 변경 &lt;em&gt;내부를&lt;/em&gt; 구현 파일에 필요한 &lt;em&gt;유형 검사&lt;/em&gt; 이 이제까지 새로운 오류가 발생하지 않을지라도, 다시 테스트를</target>
        </trans-unit>
        <trans-unit id="e5d9c66f05e816b7f1607245dc26fd6d3d736699" translate="yes" xml:space="preserve">
          <source>Changing just the tests required typechecking the implementation again, even if nothing changed</source>
          <target state="translated">변경 사항이 없어도 테스트를 변경하여 구현 유형을 다시 확인해야했습니다.</target>
        </trans-unit>
        <trans-unit id="2d270f4e0779e7abe44cf1c7ade9171d4da1e226" translate="yes" xml:space="preserve">
          <source>Checks for, or usage of, module loaders like &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;define&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; 또는 &lt;code&gt;define&lt;/code&gt; 과 같은 모듈 로더의 점검 또는 사용</target>
        </trans-unit>
        <trans-unit id="e9de74e418fac1f9142ff12fe9c9f76d1ed611d6" translate="yes" xml:space="preserve">
          <source>Children Type Checking</source>
          <target state="translated">어린이 유형 확인</target>
        </trans-unit>
        <trans-unit id="2afdd953eb19ed2481028f5c1801be583a951e01" translate="yes" xml:space="preserve">
          <source>Choose &lt;strong&gt;File&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;파일을&lt;/strong&gt; 선택하십시오&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7a0d9877ea63ee92b17d066ea8709fa9a3bb445" translate="yes" xml:space="preserve">
          <source>Choose &lt;strong&gt;New Project&lt;/strong&gt; (Ctrl + Shift + N)</source>
          <target state="translated">&lt;strong&gt;새 프로젝트&lt;/strong&gt; 선택 (Ctrl + Shift + N)</target>
        </trans-unit>
        <trans-unit id="1fd5281fc9dbfe31531daf20b8c332f350b4edfb" translate="yes" xml:space="preserve">
          <source>Choosing a value of &amp;ldquo;insert&amp;rdquo; or &amp;ldquo;remove&amp;rdquo; also affects the format of auto-imports, extracted types, and other generated code provided by TypeScript services. Leaving the setting on its default value of &amp;ldquo;ignore&amp;rdquo; makes generated code match the semicolon preference detected in the current file.</source>
          <target state="translated">&quot;삽입&quot;또는 &quot;제거&quot;값을 선택하면 자동 가져 오기, 추출 된 유형 및 TypeScript 서비스에서 제공하는 기타 생성 된 코드의 형식에도 영향을줍니다. 설정을 기본값 인 &quot;무시&quot;로 유지하면 생성 된 코드가 현재 파일에서 감지 된 세미콜론 기본 설정과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="78bc86498e55d8a5d31b0d503b4da787d8e95ab6" translate="yes" xml:space="preserve">
          <source>Circularity between configuration files is not allowed.</source>
          <target state="translated">구성 파일 간의 순환은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="41ff354b2b330bd1f8a0587675e43cb32a731f33" translate="yes" xml:space="preserve">
          <source>Class</source>
          <target state="translated">Class</target>
        </trans-unit>
        <trans-unit id="c0951e6f10fd3da585b65324801b21d429796cf4" translate="yes" xml:space="preserve">
          <source>Class Component</source>
          <target state="translated">클래스 구성 요소</target>
        </trans-unit>
        <trans-unit id="ed903b055db990734f20c5294ee8b8fe9164b593" translate="yes" xml:space="preserve">
          <source>Class Decorators</source>
          <target state="translated">클래스 데코레이터</target>
        </trans-unit>
        <trans-unit id="114686c97766613a29d4825a44b3554d85c66bb1" translate="yes" xml:space="preserve">
          <source>Class Field Mitigations</source>
          <target state="translated">클래스 필드 완화</target>
        </trans-unit>
        <trans-unit id="970423396db9a5db3ab146030f36eab03c9bccf9" translate="yes" xml:space="preserve">
          <source>Class Types</source>
          <target state="translated">수업 종류</target>
        </trans-unit>
        <trans-unit id="17339556e7ad7709847a75274febd591296e07e1" translate="yes" xml:space="preserve">
          <source>Class expressions</source>
          <target state="translated">클래스 표현</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>
        </trans-unit>
        <trans-unit id="a84d6a1a8b04f068d6de8792f2128d31b00ac8e8" translate="yes" xml:space="preserve">
          <source>Classes and function declarations can be authored directly as default exports. Default export class and function declaration names are optional.</source>
          <target state="translated">클래스 및 함수 선언은 기본 내보내기로 직접 작성할 수 있습니다. 기본 내보내기 클래스 및 함수 선언 이름은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="d45b7fb00541f6a8767f301189945313b46aa644" translate="yes" xml:space="preserve">
          <source>Classes are namespaces in &lt;code&gt;.js&lt;/code&gt; files. This can be used to nest classes, for example:</source>
          <target state="translated">클래스는 &lt;code&gt;.js&lt;/code&gt; 파일의 네임 스페이스입니다 . 예를 들어 클래스를 중첩하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b983fc3a70e6b758f289e140144ef55d05f6582" translate="yes" xml:space="preserve">
          <source>Classes work similarly to object literal types and interfaces with one exception: they have both a static and an instance type. When comparing two objects of a class type, only members of the instance are compared. Static members and constructors do not affect compatibility.</source>
          <target state="translated">클래스는 객체 리터럴 유형 및 인터페이스와 비슷하게 작동하지만 한 가지 예외는 정적 유형과 인스턴스 유형입니다. 클래스 유형의 두 객체를 비교할 때는 인스턴스 멤버 만 비교됩니다. 정적 멤버와 생성자는 호환성에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eb3e378460b98ee4b6e31c2d2b4b1e98ab972d3c" translate="yes" xml:space="preserve">
          <source>Classes, functions, and object literals are namespaces</source>
          <target state="translated">클래스, 함수 및 객체 리터럴은 네임 스페이스입니다.</target>
        </trans-unit>
        <trans-unit id="130cd7fe33343e419f107596f21d6c9f9d976849" translate="yes" xml:space="preserve">
          <source>Classic</source>
          <target state="translated">Classic</target>
        </trans-unit>
        <trans-unit id="f6c75e6aaeff53723e2a1e6793923cd37ed98551" translate="yes" xml:space="preserve">
          <source>Cleaner output in &lt;code&gt;--watch&lt;/code&gt; mode</source>
          <target state="translated">- &lt;code&gt;--watch&lt;/code&gt; 모드 에서 보다 깨끗한 출력</target>
        </trans-unit>
        <trans-unit id="33f49daf62d5f581a04097acf72f7a587d200db2" translate="yes" xml:space="preserve">
          <source>Code Generation for Modules</source>
          <target state="translated">모듈을위한 코드 생성</target>
        </trans-unit>
        <trans-unit id="5aef28f388cc2b6d39bbacf158f6b9e94711ece9" translate="yes" xml:space="preserve">
          <source>Code generation</source>
          <target state="translated">코드 생성</target>
        </trans-unit>
        <trans-unit id="87b36e1c52e858cb2c770a584f49971497c4d447" translate="yes" xml:space="preserve">
          <source>Code that&amp;rsquo;s impacted by the class fields change can get around the issue by converting field initializers to assignments in constructor bodies.</source>
          <target state="translated">클래스 필드 변경에 영향을받는 코드는 필드 이니셜 라이저를 생성자 본문의 할당으로 변환하여 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d618575aa117c6b80915c9311258252626feb94" translate="yes" xml:space="preserve">
          <source>Colorization of JSX code in VS 2015</source>
          <target state="translated">VS 2015의 JSX 코드 채색</target>
        </trans-unit>
        <trans-unit id="fb53519c43ebafe25dcbd0027128dc98a8b8ab12" translate="yes" xml:space="preserve">
          <source>Comma-separated list of strings</source>
          <target state="translated">쉼표로 구분 된 문자열 목록</target>
        </trans-unit>
        <trans-unit id="1f955b144e5934e2a13c8a6e25bf74ab9af19e8c" translate="yes" xml:space="preserve">
          <source>Common Questions</source>
          <target state="translated">일반적인 질문</target>
        </trans-unit>
        <trans-unit id="095e91de81638c9fb4d8559305b99b20bbe45f1b" translate="yes" xml:space="preserve">
          <source>CommonJS / Node SimpleModule.js</source>
          <target state="translated">CommonJS / 노드 SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="bda542b3ab64c958c7a9092f48843c2d942bdc34" translate="yes" xml:space="preserve">
          <source>CommonJS modules are supported</source>
          <target state="translated">CommonJS 모듈이 지원됩니다</target>
        </trans-unit>
        <trans-unit id="49c7d204d4bf5859f005b121118317373b38a4db" translate="yes" xml:space="preserve">
          <source>CommonJS/Node.js-style imports of the form &lt;code&gt;var fs = require(&quot;fs&quot;);&lt;/code&gt;</source>
          <target state="translated">형식 형식의 CommonJS / Node.js 스타일 가져 오기 &lt;code&gt;var fs = require(&quot;fs&quot;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fcf7acb84f79d901460975c5fdc7458a15a93f19" translate="yes" xml:space="preserve">
          <source>Comparing two functions</source>
          <target state="translated">두 기능 비교</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="d6b8ebf2c598d92ddec51164751b02621841cd23" translate="yes" xml:space="preserve">
          <source>Compile a project given a valid configuration file.</source>
          <target state="translated">유효한 구성 파일이 지정된 프로젝트를 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="bc74f0ec68df0086c27ed702abf06db93a06c411" translate="yes" xml:space="preserve">
          <source>Compiled with:</source>
          <target state="translated">로 컴파일 :</target>
        </trans-unit>
        <trans-unit id="34dce96703c9facc673665ace0f6e41d2baf12d1" translate="yes" xml:space="preserve">
          <source>Compiler Option</source>
          <target state="translated">컴파일러 옵션</target>
        </trans-unit>
        <trans-unit id="f05a88eb5583088cfb5f3af23ae435a9c43d6850" translate="yes" xml:space="preserve">
          <source>Compiler Options</source>
          <target state="translated">컴파일러 옵션</target>
        </trans-unit>
        <trans-unit id="819847cb3aeaa240fbb932fa94d563cc19eec903" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild</source>
          <target state="translated">MSBuild의 컴파일러 옵션</target>
        </trans-unit>
        <trans-unit id="e90bb90e5e03ec7e90a57bd240d9219ac649a200" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild: Mappings</source>
          <target state="translated">MSBuild의 컴파일러 옵션 : 매핑</target>
        </trans-unit>
        <trans-unit id="4e625c081c57011a6a742bfd97d6371d46e1c009" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild: ToolsVersion</source>
          <target state="translated">MSBuild의 컴파일러 옵션 : ToolsVersion</target>
        </trans-unit>
        <trans-unit id="c90111a236cc10e2295d1a4cb78fc2a7200d0283" translate="yes" xml:space="preserve">
          <source>Compiler Options in MSBuild: TypeScriptCompileBlocked</source>
          <target state="translated">MSBuild의 컴파일러 옵션 : TypeScriptCompileBlocked</target>
        </trans-unit>
        <trans-unit id="630ca760deb5ffc09b9902125668d2e2290de0ec" translate="yes" xml:space="preserve">
          <source>Compiler options can be specified using MSBuild properties within an MSBuild project.</source>
          <target state="translated">컴파일러 옵션은 MSBuild 프로젝트 내의 MSBuild 속성을 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93e477a43886859b1bbfebb3d31cc0e1afe3973d" translate="yes" xml:space="preserve">
          <source>Compiler options specified on the command line override those specified in the &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">명령 행에 지정된 컴파일러 옵션은 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일에 지정된 옵션을 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="121ebc6937d17411ed69a6c37b96c6c30daba6d8" translate="yes" xml:space="preserve">
          <source>Compiler supports configuring how to watch files and directories using the environment variables.</source>
          <target state="translated">컴파일러는 환경 변수를 사용하여 파일 및 디렉토리를 감시하는 방법 구성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="25e701e70295cdeed377c2a897dc9eb65d813980" translate="yes" xml:space="preserve">
          <source>Compiles to exactly:</source>
          <target state="translated">정확히 컴파일</target>
        </trans-unit>
        <trans-unit id="e358939ee8802319ad1e9d8583fade153122cd2d" translate="yes" xml:space="preserve">
          <source>Compiling &lt;code&gt;app.ts&lt;/code&gt; using &lt;code&gt;--noResolve&lt;/code&gt; should result in:</source>
          <target state="translated">&lt;code&gt;app.ts&lt;/code&gt; 사용하여 &lt;code&gt;--noResolve&lt;/code&gt; 컴파일 하면 다음 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f9f6b87f27d7b70599485207ca9ad09ebb893c0b" translate="yes" xml:space="preserve">
          <source>Compiling and running the output should result in the correct behavior on an ES3/ES5 engine.</source>
          <target state="translated">출력을 컴파일하고 실행하면 ES3 / ES5 엔진에서 올바르게 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="45ad9c5360eb345b6e3abac1b97c83060143ba82" translate="yes" xml:space="preserve">
          <source>Compiling your code</source>
          <target state="translated">코드 컴파일</target>
        </trans-unit>
        <trans-unit id="3049a2659da50c034aba15cbcd7a9e1060cf134b" translate="yes" xml:space="preserve">
          <source>Composite projects</source>
          <target state="translated">복합 프로젝트</target>
        </trans-unit>
        <trans-unit id="ca5e00120498b815c12de59fd45e93f8086a8bfc" translate="yes" xml:space="preserve">
          <source>Composition</source>
          <target state="translated">Composition</target>
        </trans-unit>
        <trans-unit id="83cafe53ded70f2997ef3800657948653907c039" translate="yes" xml:space="preserve">
          <source>Computed and constant members</source>
          <target state="translated">계산 및 상수 멤버</target>
        </trans-unit>
        <trans-unit id="38e65524c92dd7a22334161d17dd8cd47bc733c7" translate="yes" xml:space="preserve">
          <source>Computed properties</source>
          <target state="translated">계산 된 속성</target>
        </trans-unit>
        <trans-unit id="9428f1236d3847420fd8cb9cd0a04ad850ff601f" translate="yes" xml:space="preserve">
          <source>Concatenate &lt;code&gt;AMD&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt; modules with &lt;code&gt;--outFile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--outFile&lt;/code&gt; 을 사용 하여 &lt;code&gt;AMD&lt;/code&gt; 와 &lt;code&gt;System&lt;/code&gt; 모듈 연결</target>
        </trans-unit>
        <trans-unit id="3b5e0753cd9e20392bcaed52137c783d4a9ddd51" translate="yes" xml:space="preserve">
          <source>Concatenate and emit output to single file. The order of concatenation is determined by the list of files passed to the compiler on the command line along with triple-slash references and imports. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out-&quot;&gt;output file order documentation&lt;/a&gt; for more details.</source>
          <target state="translated">하나의 파일로 연결하여 출력합니다. 연결 순서는 트리플 슬래시 참조 및 가져 오기와 함께 명령 행에서 컴파일러에 전달 된 파일 목록에 의해 결정됩니다. 자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/FAQ#how-do-i-control-file-ordering-in-combined-output---out-&quot;&gt;출력 파일 순서 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8d387732801bd4a6ea409c7bad5379547b3bde5c" translate="yes" xml:space="preserve">
          <source>Conceptually, you might consider the type &lt;code&gt;[number, string]&lt;/code&gt; to be equivalent to the following declaration of &lt;code&gt;NumStrTuple&lt;/code&gt;:</source>
          <target state="translated">개념적으로, &lt;code&gt;[number, string]&lt;/code&gt; 유형 이 다음 &lt;code&gt;NumStrTuple&lt;/code&gt; 선언과 동등한 것으로 간주 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc5885783b19275de55be53a8442d9638f3760ca" translate="yes" xml:space="preserve">
          <source>Conditional Types</source>
          <target state="translated">조건부 유형</target>
        </trans-unit>
        <trans-unit id="18754d6645b008e9cccf73f1f4d972ff5e83d7ff" translate="yes" xml:space="preserve">
          <source>Conditional types are particularly useful when combined with mapped types:</source>
          <target state="translated">조건부 유형은 매핑 된 유형과 결합 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a91f85c89a26e57f7343ae39715ed71a281561e2" translate="yes" xml:space="preserve">
          <source>Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:</source>
          <target state="translated">조건부 유형은 순서대로 평가되는 일련의 패턴 일치를 형성하기 위해 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8e0afa63b781a425483833f9aa183ceaf9ab905" translate="yes" xml:space="preserve">
          <source>Conditional types in which the checked type is a naked type parameter are called &lt;em&gt;distributive conditional types&lt;/em&gt;. Distributive conditional types are automatically distributed over union types during instantiation. For example, an instantiation of &lt;code&gt;T extends U ? X : Y&lt;/code&gt; with the type argument &lt;code&gt;A | B | C&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt; is resolved as &lt;code&gt;(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)&lt;/code&gt;.</source>
          <target state="translated">확인 된 유형이 기본 유형 매개 변수 인 &lt;em&gt;조건부 유형을 분배 조건부 유형&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 분배 조건부 유형은 인스턴스화 중에 유니온 유형에 자동으로 분배됩니다. 예를 들어, &lt;code&gt;T extends U ? X : Y&lt;/code&gt; 의 인스턴스화는 U? 유형 인수가 &lt;code&gt;A | B | C&lt;/code&gt; X : Y | B | &lt;code&gt;T&lt;/code&gt; 에 대한 C 는 &lt;code&gt;(A extends U ? X : Y) | (B extends U ? X : Y) | (C extends U ? X : Y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0df65b2f0f0c2d6eb36f5ad9bffffc45bb73cf7" translate="yes" xml:space="preserve">
          <source>Configuration inheritance</source>
          <target state="translated">구성 상속</target>
        </trans-unit>
        <trans-unit id="0cf99561f068c66c86d1639cb9577f23d61bf6ef" translate="yes" xml:space="preserve">
          <source>Configuration inheritance with &lt;code&gt;extends&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;extends&lt;/code&gt; 구성 상속</target>
        </trans-unit>
        <trans-unit id="ced1a4e9ff8bc70735fabd8ba078581258e51943" translate="yes" xml:space="preserve">
          <source>Configuring Watch</source>
          <target state="translated">시계 구성</target>
        </trans-unit>
        <trans-unit id="1dc951f746dfbc3c750c7470abaf09a1940d201f" translate="yes" xml:space="preserve">
          <source>Configuring Watch: Background</source>
          <target state="translated">시계 구성 : 배경</target>
        </trans-unit>
        <trans-unit id="cfdfb6d0adf0c6f64224be19c2696050ea66bf86" translate="yes" xml:space="preserve">
          <source>Configuring directory watching using environment variable &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt;</source>
          <target state="translated">환경 변수 &lt;code&gt;TSC_WATCHDIRECTORY&lt;/code&gt; 를 사용하여 디렉토리 감시 구성</target>
        </trans-unit>
        <trans-unit id="f22e46f20a3414bdd5ff21017ac41439569be928" translate="yes" xml:space="preserve">
          <source>Configuring file watching using environment variable &lt;code&gt;TSC_WATCHFILE&lt;/code&gt;</source>
          <target state="translated">환경 변수 &lt;code&gt;TSC_WATCHFILE&lt;/code&gt; 을 사용하여 파일 감시 구성</target>
        </trans-unit>
        <trans-unit id="17d698cd217deceb13be84ca6f6626fed1b6ab6f" translate="yes" xml:space="preserve">
          <source>Confusingly, the colon here does &lt;em&gt;not&lt;/em&gt; indicate the type. The type, if you specify it, still needs to be written after the entire destructuring:</source>
          <target state="translated">혼란스럽게도 여기서 콜론 은 유형을 나타내지 &lt;em&gt;않습니다&lt;/em&gt; . 유형을 지정하는 경우 전체 파괴 후에도 유형을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="89f0f2bf53179367a5dd94383df864d838cb31c8" translate="yes" xml:space="preserve">
          <source>Congrats you&amp;rsquo;ve built your own .NET Core project with a TypeScript frontend.</source>
          <target state="translated">TypeScript 프런트 엔드를 사용하여 자체 .NET Core 프로젝트를 빌드 한 것을 축하합니다.</target>
        </trans-unit>
        <trans-unit id="941a22f7b9c2d7277c983fd34ff491234fe4dbe8" translate="yes" xml:space="preserve">
          <source>Consider a function that creates a new &lt;code&gt;HTMLElement&lt;/code&gt;, calling it with no arguments generates a &lt;code&gt;Div&lt;/code&gt;; you can optionally pass a list of children as well. Previously you would have to define it as:</source>
          <target state="translated">새로운 생성하는 기능 고려 &lt;code&gt;HTMLElement&lt;/code&gt; 인수로 호출하는 것은 생성 &lt;code&gt;Div&lt;/code&gt; ; 선택적으로 하위 목록도 전달할 수 있습니다. 이전에는 다음과 같이 정의해야했습니다.</target>
        </trans-unit>
        <trans-unit id="9a93950d7261d2e851d7f697ab5cb3ac7485af4e" translate="yes" xml:space="preserve">
          <source>Consider a simple calculator implementation defined in module &lt;code&gt;Calculator.ts&lt;/code&gt;. The module also exports a helper function to test the calculator functionality by passing a list of input strings and writing the result at the end.</source>
          <target state="translated">&lt;code&gt;Calculator.ts&lt;/code&gt; 모듈에 정의 된 간단한 계산기 구현을 고려하십시오 . 이 모듈은 또한 입력 문자열 목록을 전달하고 끝에 결과를 작성하여 계산기 기능을 테스트하기위한 도우미 기능을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="64b47866222baeccb4c64149b4ef01b8e0a587f3" translate="yes" xml:space="preserve">
          <source>Consider an internationalization scenario where a build tool automatically generates locale specific bundles by interpolating a special path token, say &lt;code&gt;#{locale}&lt;/code&gt;, as part of a relative module path such as &lt;code&gt;./#{locale}/messages&lt;/code&gt;. In this hypothetical setup the tool enumerates supported locales, mapping the abstracted path into &lt;code&gt;./zh/messages&lt;/code&gt;, &lt;code&gt;./de/messages&lt;/code&gt;, and so forth.</source>
          <target state="translated">빌드 도구 가 &lt;code&gt;./#{locale}/messages&lt;/code&gt; 와 같은 상대 모듈 경로의 일부로 특수 경로 토큰 (예 : &lt;code&gt;#{locale}&lt;/code&gt; ) 을 보간하여 로케일 특정 번들을 자동으로 생성하는 국제화 시나리오를 고려하십시오 . 이 가상 설정에서이 도구는 지원되는 로캘을 열거하고 추상화 된 경로를 &lt;code&gt;./zh/messages&lt;/code&gt; , &lt;code&gt;./de/messages&lt;/code&gt; 등에 매핑합니다 .</target>
        </trans-unit>
        <trans-unit id="e51d52c45ed3cf02e41cacc5bac70bcc7582c3f8" translate="yes" xml:space="preserve">
          <source>Consider the following example in which &lt;code&gt;Animal&lt;/code&gt; is the supertype of &lt;code&gt;Dog&lt;/code&gt; and &lt;code&gt;Cat&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Animal&lt;/code&gt; 이 &lt;code&gt;Dog&lt;/code&gt; 및 &lt;code&gt;Cat&lt;/code&gt; 의 상위 유형 인 다음 예를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="75e291169a2ebb63c935a5de7382990c0513d618" translate="yes" xml:space="preserve">
          <source>Consider:</source>
          <target state="translated">Consider:</target>
        </trans-unit>
        <trans-unit id="56d0232c998d778ef55ad35e83c8072f0d14ad7f" translate="yes" xml:space="preserve">
          <source>Const</source>
          <target state="translated">Const</target>
        </trans-unit>
        <trans-unit id="3a99b4ee5816a7cb6e3ef98324d960dc2e81d981" translate="yes" xml:space="preserve">
          <source>Const enums can only use constant enum expressions and unlike regular enums they are completely removed during compilation. Const enum members are inlined at use sites. This is possible since const enums cannot have computed members.</source>
          <target state="translated">Const 열거 형은 상수 열거 형 식만 사용할 수 있으며 일반 열거 형과 달리 컴파일 중에 완전히 제거됩니다. Const enum 멤버는 사용 사이트에 인라인되어 있습니다. const 열거 형에 계산 멤버를 가질 수 없으므로 가능합니다.</target>
        </trans-unit>
        <trans-unit id="fb4e962186bdd37258f8b448774e2dcc2ffcf28a" translate="yes" xml:space="preserve">
          <source>Constant-named properties</source>
          <target state="translated">상수 속성</target>
        </trans-unit>
        <trans-unit id="52e68a873a2be3470675b9ee933b98d781ae7fef" translate="yes" xml:space="preserve">
          <source>Constraints</source>
          <target state="translated">Constraints</target>
        </trans-unit>
        <trans-unit id="d14be1865dab7ff31185f4ebfd1097f17695a8ad" translate="yes" xml:space="preserve">
          <source>Constructor functions</source>
          <target state="translated">생성자 함수</target>
        </trans-unit>
        <trans-unit id="b457798406732b22f251fa45881744c1f45d717e" translate="yes" xml:space="preserve">
          <source>Constructor functions are equivalent to classes</source>
          <target state="translated">생성자 함수는 클래스와 같습니다.</target>
        </trans-unit>
        <trans-unit id="b78d1b6cb187422161c01ee1e5d55ae78d30cf52" translate="yes" xml:space="preserve">
          <source>ConstructorParameters&amp;lt;T&amp;gt;</source>
          <target state="translated">ConstructorParameters&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="da51e1fa96b8ea9420b5fa91983ad6d946a019bc" translate="yes" xml:space="preserve">
          <source>Constructs a tuple type of the types of the parameters of a function type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">함수 유형 &lt;code&gt;T&lt;/code&gt; 의 매개 변수 유형의 튜플 유형을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="d79c41aef449a13b15632406dd45cb3296e79353" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 를 제외하여 형식을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="8d9a660daa90148f4ac3004bd45d9aa896dbca1c" translate="yes" xml:space="preserve">
          <source>Constructs a type by excluding from &lt;code&gt;T&lt;/code&gt; all properties that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">에서 제외하여 유형 구축 &lt;code&gt;T&lt;/code&gt; 에 할당 할 수 있습니다 모든 속성 &lt;code&gt;U&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="534a3be9726f529289895ca42ccc7f72d9c3024c" translate="yes" xml:space="preserve">
          <source>Constructs a type by extracting from &lt;code&gt;T&lt;/code&gt; all properties that are assignable to &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;U&lt;/code&gt; 로 할당 가능한 모든 속성을 추출하여 형식을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="3e405f5b40b51987ceb9ba1254eee89e3f48777c" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking all properties from &lt;code&gt;T&lt;/code&gt; and then removing &lt;code&gt;K&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 에서 모든 속성을 선택한 다음 &lt;code&gt;K&lt;/code&gt; 를 제거 하여 형식을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="13581efb3c161daf55efaa641c95a2937e6fa92d" translate="yes" xml:space="preserve">
          <source>Constructs a type by picking the set of properties &lt;code&gt;K&lt;/code&gt; from &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">속성 집합 &lt;code&gt;K&lt;/code&gt; 에서 &lt;code&gt;T&lt;/code&gt; 를 선택하여 유형을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="9fa9c5cf9d32c720825d39df29969f2f2dfdb044" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of all properties of &lt;code&gt;T&lt;/code&gt; set to required.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 모든 속성이 필수로 설정된 유형으로 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="8af78f1563236125ebb587f0510bfdfbb33bcfd1" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the instance type of a constructor function type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">생성자 함수 유형 &lt;code&gt;T&lt;/code&gt; 의 인스턴스 유형으로 구성된 유형을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="67178f246747dfdb076d24fd6fe244d35eea9de7" translate="yes" xml:space="preserve">
          <source>Constructs a type consisting of the return type of function &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;T&lt;/code&gt; 의 반환 유형으로 구성된 유형을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="b92a41e86aee02470adc5b04c55124c13aaff3f2" translate="yes" xml:space="preserve">
          <source>Constructs a type with a set of properties &lt;code&gt;K&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt;. This utility can be used to map the properties of a type to another type.</source>
          <target state="translated">유형 &lt;code&gt;T&lt;/code&gt; 의 특성 &lt;code&gt;K&lt;/code&gt; 세트로 유형을 구성합니다 . 이 유틸리티를 사용하여 유형의 속성을 다른 유형에 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87140e5d46947bf6adcacabd45f115a7d1fa950d" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;T&lt;/code&gt; set to &lt;code&gt;readonly&lt;/code&gt;, meaning the properties of the constructed type cannot be reassigned.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 모든 속성이 &lt;code&gt;readonly&lt;/code&gt; 로 설정된 유형을 생성합니다 . 즉, 생성 된 유형의 속성을 재 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6638ebe736931ecdde61f721cb96423f589cf127" translate="yes" xml:space="preserve">
          <source>Constructs a type with all properties of &lt;code&gt;T&lt;/code&gt; set to optional. This utility will return a type that represents all subsets of a given type.</source>
          <target state="translated">&lt;code&gt;T&lt;/code&gt; 의 모든 속성이 선택 사항으로 설정된 유형을 구성합니다 . 이 유틸리티는 주어진 유형의 모든 하위 집합을 나타내는 유형을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0cd2ae0ee1c90002e81a2a4c5b16f430d5eb5d5d" translate="yes" xml:space="preserve">
          <source>Consumer.ts</source>
          <target state="translated">Consumer.ts</target>
        </trans-unit>
        <trans-unit id="19643388856c2476ec9508c66a7a7a22828effd3" translate="yes" xml:space="preserve">
          <source>Consumers of your module should have as little friction as possible when using things that you export. Adding too many levels of nesting tends to be cumbersome, so think carefully about how you want to structure things.</source>
          <target state="translated">수출하는 물건을 사용할 때 모듈 소비자는 가능한 한 마찰이 적어야합니다. 너무 많은 중첩 수준을 추가하면 성가신 경향이 있으므로 구조를 어떻게 구성하고 싶은지 신중하게 생각하십시오.</target>
        </trans-unit>
        <trans-unit id="9e33338e8781d70a603018c5dde7772e8b7ed456" translate="yes" xml:space="preserve">
          <source>Consuming</source>
          <target state="translated">Consuming</target>
        </trans-unit>
        <trans-unit id="1e2af544c5c4ac1500ff8f4ed22cff22ab2d98d9" translate="yes" xml:space="preserve">
          <source>Consuming Dependencies</source>
          <target state="translated">소비 종속성</target>
        </trans-unit>
        <trans-unit id="47a106946fb54af2e98e522133b69f05659ad46a" translate="yes" xml:space="preserve">
          <source>Consumption</source>
          <target state="translated">Consumption</target>
        </trans-unit>
        <trans-unit id="43d406bfbbaf7c88699230d3aef03ec04c451529" translate="yes" xml:space="preserve">
          <source>Consumption: Consuming</source>
          <target state="translated">소비 : 소비</target>
        </trans-unit>
        <trans-unit id="a38855f0870542b992b5fff7c96208a8884a3edf" translate="yes" xml:space="preserve">
          <source>Consumption: Downloading</source>
          <target state="translated">소비 : 다운로드</target>
        </trans-unit>
        <trans-unit id="83a031c3bd99a755d80e5f7da09ef9648fc64a91" translate="yes" xml:space="preserve">
          <source>Consumption: Searching</source>
          <target state="translated">소비 : 검색</target>
        </trans-unit>
        <trans-unit id="345009d8692863e53f52a509ffa69fac9f8c1193" translate="yes" xml:space="preserve">
          <source>Contextual Typing</source>
          <target state="translated">상황 별 타이핑</target>
        </trans-unit>
        <trans-unit id="3890ff4bf80a096d2b98096a8e255fb1438bedf3" translate="yes" xml:space="preserve">
          <source>Contextual typing applies in many cases. Common cases include arguments to function calls, right hand sides of assignments, type assertions, members of object and array literals, and return statements. The contextual type also acts as a candidate type in best common type. For example:</source>
          <target state="translated">상황 별 타이핑은 많은 경우에 적용됩니다. 일반적인 경우에는 함수 호출에 대한 인수, 할당의 오른쪽, 형식 어설 션, 개체 및 배열 리터럴, return 문이 있습니다. 문맥 유형은 또한 가장 일반적인 유형의 후보 유형으로 작동합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8991bf4cd6fcd903e6d8843735f575800e222a1b" translate="yes" xml:space="preserve">
          <source>Control flow analysis errors</source>
          <target state="translated">제어 흐름 분석 오류</target>
        </trans-unit>
        <trans-unit id="26b790f356c8f06689edb0506cd42e89fdf6a448" translate="yes" xml:space="preserve">
          <source>Control flow based type analysis</source>
          <target state="translated">제어 흐름 기반 유형 분석</target>
        </trans-unit>
        <trans-unit id="5608c55cda3285cb7a6c58d2a3953e2990e12df3" translate="yes" xml:space="preserve">
          <source>Control flow based type analysis is particularly relevant in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode because nullable types are represented using union types:</source>
          <target state="translated">제어 가능한 흐름 기반 형식 분석은 nullable 형식이 공용체 형식을 사용하여 표시되므로 &lt;code&gt;--strictNullChecks&lt;/code&gt; 모드 에서 특히 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="676622699467dc4bbf4104746ce06f96c9893b26" translate="yes" xml:space="preserve">
          <source>Conversely when importing:</source>
          <target state="translated">반대로 가져올 때 :</target>
        </trans-unit>
        <trans-unit id="19762d1065d05ceddeccf92411a8f237f298697e" translate="yes" xml:space="preserve">
          <source>Correctly finding &lt;code&gt;moduleA&lt;/code&gt; as it was passed on the command-line.</source>
          <target state="translated">명령 행에 &lt;code&gt;moduleA&lt;/code&gt; 가 전달 될 때 올바르게 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="cebcad9c0d7aa9b4035b16adbfe6b459f9f243ec" translate="yes" xml:space="preserve">
          <source>Corresponding changes to add &lt;code&gt;LibraryManagedAttributes&lt;/code&gt; definition to the &lt;code&gt;JSX&lt;/code&gt; namespace in &lt;code&gt;@types/React&lt;/code&gt; are still needed. Keep in mind that there are some limitations.</source>
          <target state="translated">&lt;code&gt;@types/React&lt;/code&gt; 의 &lt;code&gt;JSX&lt;/code&gt; 네임 스페이스에 &lt;code&gt;LibraryManagedAttributes&lt;/code&gt; 정의 를 추가하기위한 해당 변경 이 여전히 필요합니다. 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4152f39c03c0eb9e811b3dbb568be8c9505d1aa" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;gulpfile.js&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;gulpfile.js&lt;/code&gt; 만들기</target>
        </trans-unit>
        <trans-unit id="3021179bd177130f09b3a8316daec30a4b2b93d6" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;webpack.config.js&lt;/code&gt; file at the root of the project directory.</source>
          <target state="translated">프로젝트 디렉토리의 루트에 &lt;code&gt;webpack.config.js&lt;/code&gt; 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="03be7fc935f815567fa5a4bac79cc78db732e8e0" translate="yes" xml:space="preserve">
          <source>Create a file called &lt;code&gt;src/greet.ts&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;src/greet.ts&lt;/code&gt; 라는 파일을 만듭니다 :</target>
        </trans-unit>
        <trans-unit id="a9ff776f31b78475f53c7d5b1e090dd761e922f3" translate="yes" xml:space="preserve">
          <source>Create a file in &lt;code&gt;src&lt;/code&gt; named &lt;code&gt;index.html&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;src&lt;/code&gt; 에 &lt;code&gt;index.html&lt;/code&gt; 이라는 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="325cf797263cfffdce479b5e173823121f9d4d73" translate="yes" xml:space="preserve">
          <source>Create a new project</source>
          <target state="translated">새로운 프로젝트 만들기</target>
        </trans-unit>
        <trans-unit id="79b403f57bb09e035ae3515269845b15ce38bd27" translate="yes" xml:space="preserve">
          <source>Create a page</source>
          <target state="translated">페이지 만들기</target>
        </trans-unit>
        <trans-unit id="647abbb31ccf904ba3c2c45c79357305334edf70" translate="yes" xml:space="preserve">
          <source>Create a webpack configuration file</source>
          <target state="translated">웹팩 구성 파일 작성</target>
        </trans-unit>
        <trans-unit id="2f4329f654175ad323032c9448bb383b6b11a42c" translate="yes" xml:space="preserve">
          <source>Currently &lt;code&gt;useDefineForClassFields&lt;/code&gt; is only available when targeting ES5 and upwards, since &lt;code&gt;Object.defineProperty&lt;/code&gt; doesn&amp;rsquo;t exist in ES3. To achieve similar checking for issues, you can create a seperate project that targets ES5 and uses &lt;code&gt;--noEmit&lt;/code&gt; to avoid a full build.</source>
          <target state="translated">ES3에는 &lt;code&gt;Object.defineProperty&lt;/code&gt; 가 없으므로 ES5 이상을 대상으로하는 경우에만 현재 &lt;code&gt;useDefineForClassFields&lt;/code&gt; 를 사용할 수 있습니다 . 유사한 문제 검사를 수행하기 위해 ES5를 대상으로하고 &lt;code&gt;--noEmit&lt;/code&gt; 을 사용 하여 전체 빌드를 피하는 별도의 프로젝트를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9cd15468b55ecfe136f817794b0238725c3ba6b" translate="yes" xml:space="preserve">
          <source>Custom JSX factories using &lt;code&gt;--reactNamespace&lt;/code&gt;</source>
          <target state="translated">사용하여 사용자 정의 JSX 공장 &lt;code&gt;--reactNamespace&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="13be717a73cc5b208ba90837f91718dbedc0e5c7" translate="yes" xml:space="preserve">
          <source>D3.d.ts (simplified excerpt)</source>
          <target state="translated">D3.d.ts (간단한 발췌)</target>
        </trans-unit>
        <trans-unit id="6be0205f470d4c7a15a776fec93f63444a3c1da3" translate="yes" xml:space="preserve">
          <source>DEPRECATED. Use &lt;code&gt;--jsxFactory&lt;/code&gt; instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 &lt;code&gt;--jsxFactory&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5799536cf1759401f5d741ea6f17c63a6dec9bbc" translate="yes" xml:space="preserve">
          <source>DEPRECATED. Use &lt;code&gt;--outFile&lt;/code&gt; instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 &lt;code&gt;--outFile&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="59b53d5c8edc70418359a1b34ceac44b0e0760de" translate="yes" xml:space="preserve">
          <source>DEPRECATED. Use &lt;code&gt;--skipLibCheck&lt;/code&gt; instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 &lt;code&gt;--skipLibCheck&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c8569d62477c3f3a8139ad175f1b65dec4c78eb" translate="yes" xml:space="preserve">
          <source>DOM Changes</source>
          <target state="translated">DOM 변경</target>
        </trans-unit>
        <trans-unit id="bd604d99e75e45d38bc7ac8fc714cde0097d901f" translate="yes" xml:space="preserve">
          <source>Debug</source>
          <target state="translated">Debug</target>
        </trans-unit>
        <trans-unit id="2f52e43b6882a3466f1d969c1cb1001473303ede" translate="yes" xml:space="preserve">
          <source>Declaration Files</source>
          <target state="translated">선언 파일</target>
        </trans-unit>
        <trans-unit id="dddf315bf8c952c79983330b50ceb284d3027070" translate="yes" xml:space="preserve">
          <source>Declaration Merging</source>
          <target state="translated">선언 병합</target>
        </trans-unit>
        <trans-unit id="2b8121a4da07765109d3a1ebd4396566febe4c31" translate="yes" xml:space="preserve">
          <source>Declaration Type</source>
          <target state="translated">선언 유형</target>
        </trans-unit>
        <trans-unit id="b9b846963186dedc9a34aab11fab9a0a092e2d1b" translate="yes" xml:space="preserve">
          <source>Declarations</source>
          <target state="translated">Declarations</target>
        </trans-unit>
        <trans-unit id="dc141dc5502f9e0e32e0ce70ae020fbf031bce6e" translate="yes" xml:space="preserve">
          <source>Declarations are &lt;em&gt;always&lt;/em&gt; initialized to &lt;code&gt;undefined&lt;/code&gt;, even if they have no initializer.</source>
          <target state="translated">이니셜 라이저 가없는 경우에도 선언은 &lt;em&gt;항상 &lt;/em&gt; &lt;code&gt;undefined&lt;/code&gt; 로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="f41d762770bc6126d4d1fc990ef90759d58eb809" translate="yes" xml:space="preserve">
          <source>Declarations are initialized with &lt;code&gt;Object.defineProperty&lt;/code&gt;.</source>
          <target state="translated">선언은 &lt;code&gt;Object.defineProperty&lt;/code&gt; 로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="6fcdb4b2cc50995c39a00cc184737f3ebc0aa6de" translate="yes" xml:space="preserve">
          <source>Declarations like &lt;code&gt;import * as a from 'b';&lt;/code&gt; or &lt;code&gt;export c;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;import * as a from 'b';&lt;/code&gt; 같은 선언 ; 또는 &lt;code&gt;export c;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="347802d3a4b4ece7d3a20faf11435d4ac3181083" translate="yes" xml:space="preserve">
          <source>Declare the properties if they really do exist.</source>
          <target state="translated">속성이 실제로 존재하면 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="0d6cb4979eadd458a450c7ab965139630dc251e6" translate="yes" xml:space="preserve">
          <source>Declaring a variable in JavaScript has always traditionally been done with the &lt;code&gt;var&lt;/code&gt; keyword.</source>
          <target state="translated">JavaScript에서 변수 선언은 항상 전통적으로 &lt;code&gt;var&lt;/code&gt; 키워드를 사용하여 수행되었습니다 .</target>
        </trans-unit>
        <trans-unit id="45c3eb65b36120d75303dd4d19ce72e6c44591cc" translate="yes" xml:space="preserve">
          <source>Declaring variables of type &lt;code&gt;void&lt;/code&gt; is not useful because you can only assign &lt;code&gt;null&lt;/code&gt; (only if &lt;code&gt;--strictNullChecks&lt;/code&gt; is not specified, see next section) or &lt;code&gt;undefined&lt;/code&gt; to them:</source>
          <target state="translated">형의 변수 선언 &lt;code&gt;void&lt;/code&gt; 만 할당 할 수 있기 때문에 유용하지 않다 &lt;code&gt;null&lt;/code&gt; (경우에만 &lt;code&gt;--strictNullChecks&lt;/code&gt; 가 지정되지 않은, 다음 섹션 참조) 또는 &lt;code&gt;undefined&lt;/code&gt; 그들에게 :</target>
        </trans-unit>
        <trans-unit id="c9d80403b6c6762d3135cc4b0364ef0ded8f2e39" translate="yes" xml:space="preserve">
          <source>Decorator Composition</source>
          <target state="translated">데코레이터 구성</target>
        </trans-unit>
        <trans-unit id="94dcd3c584c6cd82aa44ce93304239e663bb5afb" translate="yes" xml:space="preserve">
          <source>Decorator Evaluation</source>
          <target state="translated">데코레이터 평가</target>
        </trans-unit>
        <trans-unit id="bc8d0308046fee6336b61acda5e70c000a657952" translate="yes" xml:space="preserve">
          <source>Decorator Factories</source>
          <target state="translated">데코레이터 공장</target>
        </trans-unit>
        <trans-unit id="a2e23b650a15e5c693ca1445133d5ee60d9d20b4" translate="yes" xml:space="preserve">
          <source>Decorators</source>
          <target state="translated">Decorators</target>
        </trans-unit>
        <trans-unit id="ef21caee016081351dbb5463efe6ee7af49ce158" translate="yes" xml:space="preserve">
          <source>Decorators &lt;code&gt;readonly&lt;/code&gt; and &lt;code&gt;enumerable(false)&lt;/code&gt; will be applied to the property &lt;code&gt;method&lt;/code&gt; before it is installed on class &lt;code&gt;C&lt;/code&gt;. This allows the decorator to change the implementation, and in this case, augment the descriptor to be writable: false and enumerable: false.</source>
          <target state="translated">데코레이터 &lt;code&gt;readonly&lt;/code&gt; 및 &lt;code&gt;enumerable(false)&lt;/code&gt; 은 클래스 &lt;code&gt;C&lt;/code&gt; 에 설치되기 전에 속성 &lt;code&gt;method&lt;/code&gt; 적용됩니다 . 이를 통해 데코레이터는 구현을 변경할 수 있으며,이 경우 디스크립터를 쓰기 가능 (false 및 enumerable : false)으로 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a0adc2fcd71ed541d9efa8c14c5ad593144b45d" translate="yes" xml:space="preserve">
          <source>Decorators are now allowed when targeting ES3. TypeScript 1.7 removes the ES5-specific use of &lt;code&gt;reduceRight&lt;/code&gt; from the &lt;code&gt;__decorate&lt;/code&gt; helper. The changes also inline calls &lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt; and &lt;code&gt;Object.defineProperty&lt;/code&gt; in a backwards-compatible fashion that allows for a to clean up the emit for ES5 and later by removing various repetitive calls to the aforementioned &lt;code&gt;Object&lt;/code&gt; methods.</source>
          <target state="translated">ES3를 타겟팅 할 때 데코레이터가 허용됩니다. 타이프 라이터 1.7 제거합니다의 ES5 특정 사용 &lt;code&gt;reduceRight&lt;/code&gt; 로부터 &lt;code&gt;__decorate&lt;/code&gt; 도우미. 또한 인라인 변경은 이전 버전과 호환되는 방식으로 &lt;code&gt;Object.getOwnPropertyDescriptor&lt;/code&gt; 및 &lt;code&gt;Object.defineProperty&lt;/code&gt; 를 인라인 호출 하여 나중에 언급 된 &lt;code&gt;Object&lt;/code&gt; 메소드 에 대한 다양한 반복 호출을 제거하여 ES5에 대한 이미 터를 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab1c2fe01ec5b2e45d64dd5c8c5b343bff75cd10" translate="yes" xml:space="preserve">
          <source>Deduplicated and redirected packages</source>
          <target state="translated">중복 제거 및 리디렉션 된 패키지</target>
        </trans-unit>
        <trans-unit id="c34129b088d5dff9241ab7abdee9bb553051e041" translate="yes" xml:space="preserve">
          <source>Deep Dive</source>
          <target state="translated">심해 잠수</target>
        </trans-unit>
        <trans-unit id="8f606bc9715586c081faee92e0f2cbb0b58c9865" translate="yes" xml:space="preserve">
          <source>Deep Dive: Advanced Combinations</source>
          <target state="translated">딥 다이브 : 고급 조합</target>
        </trans-unit>
        <trans-unit id="8dce9edac26c50b7afe597930a0e4d53c87e0151" translate="yes" xml:space="preserve">
          <source>Deep Dive: Definition File Theory: A Deep Dive</source>
          <target state="translated">딥 다이브 : 정의 파일 이론 : 딥 다이브</target>
        </trans-unit>
        <trans-unit id="df3520f4ddd89ba26396acae5290727ff5fa15a2" translate="yes" xml:space="preserve">
          <source>Deep Dive: Using with export = or import</source>
          <target state="translated">딥 다이브 : export = 또는 import와 함께 사용</target>
        </trans-unit>
        <trans-unit id="808d7dca8a74d84af27a2d6602c3d786de45fe1e" translate="yes" xml:space="preserve">
          <source>Default</source>
          <target state="translated">Default</target>
        </trans-unit>
        <trans-unit id="1dcd95e322dde1a1ed9488f1a9be1d85f6302d4a" translate="yes" xml:space="preserve">
          <source>Default Export</source>
          <target state="translated">기본 내보내기</target>
        </trans-unit>
        <trans-unit id="967dd37853ad5171b91867584cc350ce812dd723" translate="yes" xml:space="preserve">
          <source>Default exports</source>
          <target state="translated">기본 수출</target>
        </trans-unit>
        <trans-unit id="6c547e1ab7ad80d7eb94ac89b9475cb2f4ad47cf" translate="yes" xml:space="preserve">
          <source>Default exports also cannot be augmented, only named exports (since you need to augment an export by its exported name, and &lt;code&gt;default&lt;/code&gt; is a reserved word - see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14080&quot;&gt;#14080&lt;/a&gt; for details)</source>
          <target state="translated">기본 내보내기는 또한 이름 지정된 내보내기 만 기능 보강 할 수 없습니다 (내 보낸 이름으로 내보내기 기능을 보강해야하고 &lt;code&gt;default&lt;/code&gt; 은 예약어이므로 세부 사항 은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14080&quot;&gt;# 14080&lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="aaafa95b77c94d35023aa4c831339a5f6888b4bd" translate="yes" xml:space="preserve">
          <source>Default imports to CommonJS/AMD/UMD are now allowed (e.g. &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt;), and should work as expected.</source>
          <target state="translated">CommonJS / AMD / UMD 로의 기본 가져 오기가 이제 허용되며 (예 : &lt;code&gt;import fs from &quot;fs&quot;&lt;/code&gt; ) 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ca5a7e29bf0dd24fa5da97c8a78bd7b6478ae9da" translate="yes" xml:space="preserve">
          <source>Default types for a type parameter must satisfy the constraint for the type parameter, if it exists.</source>
          <target state="translated">유형 매개 변수의 기본 유형은 유형 매개 변수 (있는 경우)의 제한 조건을 충족시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="e034cbbe2b8762f796d4892d08bbfed1145d3ef8" translate="yes" xml:space="preserve">
          <source>Default values</source>
          <target state="translated">기본값</target>
        </trans-unit>
        <trans-unit id="373c6cd274b89a3c2582c933d56ada3fedbd82e3" translate="yes" xml:space="preserve">
          <source>Default values let you specify a default value in case a property is undefined:</source>
          <target state="translated">기본값을 사용하면 속성이 정의되지 않은 경우 기본값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1bceef18898234e393aee21da6ed7ad228f35ee" translate="yes" xml:space="preserve">
          <source>Default-initialized parameters that come after all required parameters are treated as optional, and just like optional parameters, can be omitted when calling their respective function. This means optional parameters and trailing default parameters will share commonality in their types, so both</source>
          <target state="translated">모든 필수 매개 변수 뒤에 오는 기본 초기화 매개 변수는 선택적으로 처리되며 선택적 매개 변수와 마찬가지로 해당 함수를 호출 할 때 생략 할 수 있습니다. 이는 선택적 매개 변수와 후행 기본 매개 변수가 해당 유형에서 공통성을 공유하므로 둘 다</target>
        </trans-unit>
        <trans-unit id="fd59cfb04075f034cef59cd0fa42daf1eb79992e" translate="yes" xml:space="preserve">
          <source>Defaulted declarations</source>
          <target state="translated">기본 선언</target>
        </trans-unit>
        <trans-unit id="abc6fc711e9d8d97a334f473c6d8d10ccc6870a3" translate="yes" xml:space="preserve">
          <source>Definite Assignment Assertions</source>
          <target state="translated">명확한 할당 어설 션</target>
        </trans-unit>
        <trans-unit id="4cf6455d1dfb8e1b31ee9a23f39f86c7d9682067" translate="yes" xml:space="preserve">
          <source>Definition File Theory: A Deep Dive</source>
          <target state="translated">정의 파일 이론 : 심층 분석</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="a5295ab13650a7fc6f7e3962a265606df1d7d936" translate="yes" xml:space="preserve">
          <source>Dependencies on Global Libraries</source>
          <target state="translated">글로벌 라이브러리에 대한 의존성</target>
        </trans-unit>
        <trans-unit id="6067defa2476905bfad8665adf2145c0c736a17f" translate="yes" xml:space="preserve">
          <source>Dependencies on Modules</source>
          <target state="translated">모듈에 대한 의존성</target>
        </trans-unit>
        <trans-unit id="30e045eae2e7599477b456a7f9a5428b685bf5aa" translate="yes" xml:space="preserve">
          <source>Dependencies on UMD libraries</source>
          <target state="translated">UMD 라이브러리에 대한 종속성</target>
        </trans-unit>
        <trans-unit id="b6e13e2a33f9902dfc93501c0d9a6a0bb02f3d22" translate="yes" xml:space="preserve">
          <source>Depending on the module target specified during compilation, the compiler will generate appropriate code for Node.js (&lt;a href=&quot;http://wiki.commonjs.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt;), require.js (&lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD&lt;/a&gt;), &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt;, &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt;, or &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-modules&quot;&gt;ECMAScript 2015 native modules&lt;/a&gt; (ES6) module-loading systems. For more information on what the &lt;code&gt;define&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;register&lt;/code&gt; calls in the generated code do, consult the documentation for each module loader.</source>
          <target state="translated">컴파일 중에 지정된 모듈 대상에 따라 컴파일러는 Node.js ( &lt;a href=&quot;http://wiki.commonjs.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; ), require.js ( &lt;a href=&quot;https://github.com/amdjs/amdjs-api/wiki/AMD&quot;&gt;AMD&lt;/a&gt; ), &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;UMD&lt;/a&gt; , &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;SystemJS&lt;/a&gt; 또는 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-modules&quot;&gt;ECMAScript 2015 기본 모듈&lt;/a&gt; (ES6) 모듈 로딩 시스템에 적합한 코드를 생성 합니다. 생성 된 코드에서 &lt;code&gt;define&lt;/code&gt; , &lt;code&gt;require&lt;/code&gt; 및 &lt;code&gt;register&lt;/code&gt; 호출이 수행하는 작업 에 대한 자세한 정보 는 각 모듈 로더의 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="3e9c954b8528b960f8219e88a4099c898d44449d" translate="yes" xml:space="preserve">
          <source>Despite its appearance, the &lt;code&gt;readonly&lt;/code&gt; type modifier can only be used for syntax on array types and tuple types. It is not a general-purpose type operator.</source>
          <target state="translated">모양에도 불구하고 &lt;code&gt;readonly&lt;/code&gt; 유형 수정자는 배열 유형 및 튜플 유형의 구문에만 사용할 수 있습니다. 범용 타입 연산자가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="077ef6bb7e9ca7a81dc6c9028d61cccdb0c255dd" translate="yes" xml:space="preserve">
          <source>Destructuring</source>
          <target state="translated">Destructuring</target>
        </trans-unit>
        <trans-unit id="b44f48048febb0c759b20a351a087cf970585895" translate="yes" xml:space="preserve">
          <source>Destructuring also works in function declarations. For simple cases this is straightforward:</source>
          <target state="translated">파괴는 함수 선언에서도 작동합니다. 간단한 경우에는이 방법이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="c10db471f87802e009d06682868c12eb36cc956b" translate="yes" xml:space="preserve">
          <source>Destructuring declarations also works for extracting values from arrays:</source>
          <target state="translated">배열 선언은 배열에서 값을 추출하는데도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aae36bb7ef10a1d27e89e1a1e5cab353c1f39861" translate="yes" xml:space="preserve">
          <source>Destructuring in declarations and assignments</source>
          <target state="translated">선언과 과제의 파괴</target>
        </trans-unit>
        <trans-unit id="30ec4f69e7cfb0ff17a5b214356b9461fa3e35ea" translate="yes" xml:space="preserve">
          <source>Destructuring patterns can also be used in regular assignment expressions. For instance, swapping two variables can be written as a single destructuring assignment:</source>
          <target state="translated">파괴적인 패턴은 정규 할당 표현식에서도 사용될 수 있습니다. 예를 들어, 두 변수를 바꾸는 것은 단일 파괴 할당으로 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b42315aeb1e4c4a5777df9a8f177e68cf09a45e0" translate="yes" xml:space="preserve">
          <source>Destructuring works with already-declared variables as well:</source>
          <target state="translated">파괴는 이미 선언 된 변수와도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="93207507957b31ebda343db069ec516064c2e248" translate="yes" xml:space="preserve">
          <source>Detect if they are up-to-date</source>
          <target state="translated">그들이 최신인지 감지</target>
        </trans-unit>
        <trans-unit id="bec760709f148364d8b2d7249cf252878131b36c" translate="yes" xml:space="preserve">
          <source>Determine how modules get resolved. Either &lt;code&gt;&quot;Node&quot;&lt;/code&gt; for Node.js/io.js style resolution, or &lt;code&gt;&quot;Classic&quot;&lt;/code&gt;. See &lt;a href=&quot;module-resolution&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">모듈이 어떻게 해결되는지 결정하십시오. 어느 쪽의 &lt;code&gt;&quot;Node&quot;&lt;/code&gt; Node.js를위한은 / 스타일 해상도, 또는 io.js &lt;code&gt;&quot;Classic&quot;&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;module-resolution&quot;&gt;모듈 확인 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f4dff229f34e808acb097e68696d3c3718ad33a9" translate="yes" xml:space="preserve">
          <source>Difference between the static and instance sides of classes</source>
          <target state="translated">클래스의 정적 측면과 인스턴스 측면의 차이점</target>
        </trans-unit>
        <trans-unit id="369d22e8ba9dcb70fad4ac90845eb7df1bdf8234" translate="yes" xml:space="preserve">
          <source>Different places in the language use one of the two compatibility mechanisms, depending on the situation. For practical purposes, type compatibility is dictated by assignment compatibility, even in the cases of the &lt;code&gt;implements&lt;/code&gt; and &lt;code&gt;extends&lt;/code&gt; clauses.</source>
          <target state="translated">언어에 따라 상황에 따라 두 가지 호환성 메커니즘 중 하나가 사용됩니다. 실제적인 목적으로 &lt;code&gt;implements&lt;/code&gt; 및 &lt;code&gt;extends&lt;/code&gt; 절의 경우에도 할당 호환성에 따라 형식 호환성이 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3bd0e1c1cd621e6fbcc274e9d250ab1db3c03d9" translate="yes" xml:space="preserve">
          <source>Disable bivariant parameter checking for function types.</source>
          <target state="translated">함수 유형에 대한 이변 량 파라미터 검사를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="0d5492f8c219bc96eb3e1f985831cc36749273fc" translate="yes" xml:space="preserve">
          <source>Disable size limitation on JavaScript project.</source>
          <target state="translated">JavaScript 프로젝트에서 크기 제한을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="c0d6cff3c670100d6c4947847436586c9f909a0c" translate="yes" xml:space="preserve">
          <source>Disable strict checking of generic signatures in function types.</source>
          <target state="translated">함수 유형에서 일반 서명의 엄격한 검사를 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="fc94ad5a04140e86aa8535c4085feefac81708ef" translate="yes" xml:space="preserve">
          <source>Disallow inconsistently-cased references to the same file.</source>
          <target state="translated">동일한 파일에 대해 일관되지 않은 참조를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca07b6b5d34354414804d10f0627d23afc021014" translate="yes" xml:space="preserve">
          <source>Disallowed Merges</source>
          <target state="translated">허용되지 않는 병합</target>
        </trans-unit>
        <trans-unit id="6e50354a241d00dc8de3bce0c769ecd4f5445e88" translate="yes" xml:space="preserve">
          <source>Discriminated Unions</source>
          <target state="translated">차별적 노동 조합</target>
        </trans-unit>
        <trans-unit id="8f4eecd214b9b9b6bc1adea133960de053499fa9" translate="yes" xml:space="preserve">
          <source>Distributive conditional types</source>
          <target state="translated">분배 조건부 유형</target>
        </trans-unit>
        <trans-unit id="5528e62826cea5c6ba5ef36621e1eb9d42697e3e" translate="yes" xml:space="preserve">
          <source>Do &lt;em&gt;not&lt;/em&gt; use a &lt;code&gt;/// &amp;lt;reference&lt;/code&gt; directive to declare a dependency to a UMD library!</source>
          <target state="translated">마 &lt;em&gt;되지&lt;/em&gt; 용도 &lt;code&gt;/// &amp;lt;reference&lt;/code&gt; UMD 라이브러리에 종속성을 선언하는 지침을!</target>
        </trans-unit>
        <trans-unit id="008b4d242c76d59d51967dc8ca342e5c9c0171f2" translate="yes" xml:space="preserve">
          <source>Do not add triple-slash references or module import targets to the list of compiled files.</source>
          <target state="translated">트리플 슬래시 참조 또는 모듈 가져 오기 대상을 컴파일 된 파일 목록에 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bbda7eadbbdea2540dfa2471e3343bfd9af51dfa" translate="yes" xml:space="preserve">
          <source>Do not emit &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; directives in module output.</source>
          <target state="translated">모듈 출력에서 &lt;code&gt;&quot;use strict&quot;&lt;/code&gt; 지시문을 방출하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="f59925b0be84543d3516bc127648bdda000f9a36" translate="yes" xml:space="preserve">
          <source>Do not emit outputs if any errors were reported.</source>
          <target state="translated">오류가보고 된 경우 출력을 방출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8813a3a637738cb30116f3e3de2e596160d664a4" translate="yes" xml:space="preserve">
          <source>Do not emit outputs.</source>
          <target state="translated">출력을 방출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2b4aecc96dbac4010750a03d9cdf681cad5a2782" translate="yes" xml:space="preserve">
          <source>Do not erase const enum declarations in generated code. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html#94-constant-enum-declarations&quot;&gt;const enums documentation&lt;/a&gt; for more details.</source>
          <target state="translated">생성 된 코드에서 const 열거 선언을 지우지 마십시오. 자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html#94-constant-enum-declarations&quot;&gt;const enums 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3ca81886d5434cef3d191c1781471a917134a9cf" translate="yes" xml:space="preserve">
          <source>Do not generate custom helper functions like &lt;code&gt;__extends&lt;/code&gt; in compiled output.</source>
          <target state="translated">컴파일 된 출력에서 &lt;code&gt;__extends&lt;/code&gt; 와 같은 사용자 정의 도우미 함수를 생성하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="f47ae1f25d416955ab5b35ad58b6d952ed341297" translate="yes" xml:space="preserve">
          <source>Do not include the default library file (&lt;code&gt;lib.d.ts&lt;/code&gt;).</source>
          <target state="translated">기본 라이브러리 파일 ( &lt;code&gt;lib.d.ts&lt;/code&gt; )을 포함하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="0d8700379392a841b4a989a2aedc6ee39cc22535" translate="yes" xml:space="preserve">
          <source>Do not report errors on unreachable code.</source>
          <target state="translated">도달 할 수없는 코드에 대한 오류를보고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e15fbdc059493fca2d963af5c43ecf0c0d7a9902" translate="yes" xml:space="preserve">
          <source>Do not report errors on unused labels.</source>
          <target state="translated">사용하지 않은 라벨에 오류를보고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="566fc4907f5c0c600bf0a19df75cc66685e5a833" translate="yes" xml:space="preserve">
          <source>Do not resolve symlinks to their real path; treat a symlinked file like a real one.</source>
          <target state="translated">심볼릭 링크를 실제 경로로 해결하지 마십시오. 심볼릭 링크 된 파일을 실제 파일처럼 취급하십시오.</target>
        </trans-unit>
        <trans-unit id="f7c490d4d3e51d3eaf23f688f0c04328a2f1e119" translate="yes" xml:space="preserve">
          <source>Do not truncate error messages.</source>
          <target state="translated">오류 메시지를 자르지 마십시오.</target>
        </trans-unit>
        <trans-unit id="de81d23a68639d446e1d87128f4ef58b96239449" translate="yes" xml:space="preserve">
          <source>Do not use namespaces in modules</source>
          <target state="translated">모듈에서 네임 스페이스를 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="9c1bd4c5b18a5e7128a31d98a66a29dfc33c9ab2" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts</source>
          <target state="translated">하지 말아야 할 것</target>
        </trans-unit>
        <trans-unit id="719ef97fc832b36afac23fa78d5c08cea2bf6141" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Generics</source>
          <target state="translated">해야 할 것과하지 말아야 할 것 : Generics</target>
        </trans-unit>
        <trans-unit id="a51c5dd50f698ff95f77e37efad482a71ac91486" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Optional Parameters in Callbacks</source>
          <target state="translated">해야 할 것과하지 말아야 할 것 : 콜백의 선택적 파라미터</target>
        </trans-unit>
        <trans-unit id="2db0d779491e142ea96422450aabb72ea9596eb7" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Ordering</source>
          <target state="translated">하지 말아야 할 것 : 주문</target>
        </trans-unit>
        <trans-unit id="7d768f81a860ccede1d11160fcbc58466d96e618" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Overloads and Callbacks</source>
          <target state="translated">해야 할 것과하지 말아야 할 것 : 과부하와 콜백</target>
        </trans-unit>
        <trans-unit id="7b5ad4c0d887c26ae55bb8c0b3d5849755f0038c" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Return Types of Callbacks</source>
          <target state="translated">해야 할 것과하지 말아야 할 것 : 반환 유형의 콜백</target>
        </trans-unit>
        <trans-unit id="77f700abeac2aeb953e0842c2152d024b8f203e3" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Use Optional Parameters</source>
          <target state="translated">해야 할 것과하지 말아야 할 것 : 선택적 매개 변수 사용</target>
        </trans-unit>
        <trans-unit id="ade57914de371d49ae2e67dcf398d7ca7cd0c7e5" translate="yes" xml:space="preserve">
          <source>Do&amp;#x27;s &amp;amp; Don&amp;#x27;ts: Use Union Types</source>
          <target state="translated">해야 할 것과하지 말아야 할 것 : 유니온 타입 사용</target>
        </trans-unit>
        <trans-unit id="bbfd2cbcdd441b33e2a5bbad3336a20b3defd13a" translate="yes" xml:space="preserve">
          <source>Do's and Don'ts</source>
          <target state="translated">해야 할 것과하지 말아야 할 것</target>
        </trans-unit>
        <trans-unit id="acc9e9cd405cd7ed7a8fcb091e91a562cac25433" translate="yes" xml:space="preserve">
          <source>Documentation describing how to &lt;code&gt;require&lt;/code&gt; or import the library</source>
          <target state="translated">라이브러리 를 &lt;code&gt;require&lt;/code&gt; 하거나 가져 오는 방법을 설명하는 문서</target>
        </trans-unit>
        <trans-unit id="3bbfdc360214d58c7cb91ac8521019e85f36e4d8" translate="yes" xml:space="preserve">
          <source>Documentation for UMD libraries will also often demonstrate a &amp;ldquo;Using in Node.js&amp;rdquo; example showing &lt;code&gt;require&lt;/code&gt;, and a &amp;ldquo;Using in the browser&amp;rdquo; example showing using a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag to load the script.</source>
          <target state="translated">UMD 라이브러리에 대한 설명서는 종종 &lt;code&gt;require&lt;/code&gt; 를 보여주는&amp;ldquo;Node.js에서 사용&amp;rdquo;예제 와 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 를로드하기 위해 &amp;lt;script&amp;gt; 태그를 사용하는&amp;ldquo;브라우저에서 사용&amp;rdquo;예제를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="24a9672278fb4d7400c1863d3b7c6f36d8ac8ae1" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t be intimidated by the number of steps here - TypeScript is still only jumping up directories twice at steps (9) and (17). This is really no more complex than what Node.js itself is doing.</source>
          <target state="translated">단계 수에 겁 먹지 마십시오-TypeScript는 여전히 단계 (9)와 (17)에서 디렉토리를 두 ​​번만 뛰어 넘습니다. 이것은 Node.js 자체가하는 것보다 더 복잡하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c8722b1128de0f74ea224044ed5056ae0d0f337" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t worry about ordering the files you pass on the commandline - &lt;code&gt;tsc&lt;/code&gt; will re-order them if needed so that dependencies are always built first.</source>
          <target state="translated">명령 행에서 전달한 파일의 순서에 대해 걱정하지 마십시오. &lt;code&gt;tsc&lt;/code&gt; 는 필요할 경우 파일 순서를 변경하여 종속성이 항상 먼저 작성되도록합니다.</target>
        </trans-unit>
        <trans-unit id="c119e0650ca90fa2b62e09ff44c7b5ae64f45581" translate="yes" xml:space="preserve">
          <source>Dotted names in type guards</source>
          <target state="translated">타입 가드의 점선 이름</target>
        </trans-unit>
        <trans-unit id="ccdea752338ea9ee00074218ee9537a9bfdb03c3" translate="yes" xml:space="preserve">
          <source>Dotted property for types with string index signatures</source>
          <target state="translated">문자열 인덱스 서명이있는 유형의 점선 속성</target>
        </trans-unit>
        <trans-unit id="e035b7411ed359c6cdcd7655c199afa4eea32876" translate="yes" xml:space="preserve">
          <source>Downlevel Async Functions</source>
          <target state="translated">하위 비동기 기능</target>
        </trans-unit>
        <trans-unit id="d5cabcaa6a9d5f4be82b1397ad3c7fd26169c044" translate="yes" xml:space="preserve">
          <source>Download the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/scripts/VSDevMode.ps1&quot;&gt;VSDevMode.ps1&lt;/a&gt; script.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/scripts/VSDevMode.ps1&quot;&gt;VSDevMode.ps1&lt;/a&gt; 스크립트를 다운로드하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b4592f9ae45a647155e857c8bbbe5e38c83f01e" translate="yes" xml:space="preserve">
          <source>Downloading</source>
          <target state="translated">Downloading</target>
        </trans-unit>
        <trans-unit id="984d20c7f5194c7c76c4882260c3e8e0fde40023" translate="yes" xml:space="preserve">
          <source>Due to a bug, the following construct was previously allowed in TypeScript:</source>
          <target state="translated">버그로 인해 TypeScript에서 이전에 다음과 같은 구문이 허용되었습니다.</target>
        </trans-unit>
        <trans-unit id="3c5d9cd03387fb41a856eb94a3f12c1e7c45d2c1" translate="yes" xml:space="preserve">
          <source>Duo</source>
          <target state="translated">Duo</target>
        </trans-unit>
        <trans-unit id="39a8e581f6169ec0a9b5700af7954883b503baa0" translate="yes" xml:space="preserve">
          <source>During type argument inference in TypeScript 3.4, for a call to a generic function that returns a function type, TypeScript &lt;em&gt;will&lt;/em&gt;, as appropriate, propagate type parameters from generic function arguments onto the resulting function type.</source>
          <target state="translated">TypeScript 3.4에서 형식 인수를 유추하는 동안 함수 형식을 반환하는 일반 함수를 호출하기 위해 TypeScript &lt;em&gt;는&lt;/em&gt; 적절하게 일반 함수 인수의 형식 매개 변수를 결과 함수 형식으로 전파합니다.</target>
        </trans-unit>
        <trans-unit id="d9d2b88aa61f766d2be10ae43782a97a76b6067a" translate="yes" xml:space="preserve">
          <source>Dynamic &lt;code&gt;import&lt;/code&gt; expressions are a new feature and part of ECMAScript that allows users to asynchronously request a module at any arbitrary point in your program.</source>
          <target state="translated">동적 &lt;code&gt;import&lt;/code&gt; 표현식은 사용자가 프로그램의 임의의 지점에서 비동기 적으로 모듈을 요청할 수있는 ECMAScript의 새로운 기능이며 일부입니다.</target>
        </trans-unit>
        <trans-unit id="d3eb3dff1f243ca444cd0f21c8fa73f06b676b18" translate="yes" xml:space="preserve">
          <source>Dynamic Import Expressions</source>
          <target state="translated">동적 가져 오기 표현식</target>
        </trans-unit>
        <trans-unit id="65d07d2547264048b907ca688317344223d5a0bb" translate="yes" xml:space="preserve">
          <source>Dynamic Module Loading in Node.js</source>
          <target state="translated">Node.js에서 동적 모듈로드</target>
        </trans-unit>
        <trans-unit id="728508cddb478117297b77baabcf7bb4bfc6cd00" translate="yes" xml:space="preserve">
          <source>ECMAScript 2015 (also known as ES2015, ECMAScript 6, and ES6), CommonJS, and RequireJS have similar notions of &lt;em&gt;importing&lt;/em&gt; a &lt;em&gt;module&lt;/em&gt;. In JavaScript CommonJS (Node.js), for example, you would write</source>
          <target state="translated">ECMAScript를 2,015은 CommonJS (또한, ES2015, ECMAScript를 6, ES6라고도 함), 및 RequireJS는 유사한 개념이 &lt;em&gt;가져 &lt;/em&gt;&lt;em&gt;모듈&lt;/em&gt; . 예를 들어 JavaScript CommonJS (Node.js)에서는 다음과 같이 작성합니다.</target>
        </trans-unit>
        <trans-unit id="f85cdebb2ea7d4e839607ea71d7d48e0db5d1567" translate="yes" xml:space="preserve">
          <source>ES2015 does not have a means for declaring properties on classes. Properties are dynamically assigned, just like object literals.</source>
          <target state="translated">ES2015에는 클래스에서 속성을 선언하는 수단이 없습니다. 객체 리터럴과 마찬가지로 속성이 동적으로 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="8f11e274662541f2c8e0e3cb8196626ffc1b7d1e" translate="yes" xml:space="preserve">
          <source>ES6 &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; declarations are now supported when targeting ES3 and ES5.</source>
          <target state="translated">ES6는 &lt;code&gt;let&lt;/code&gt; 와 &lt;code&gt;const&lt;/code&gt; 를 ES3와 ES5을 대상으로 할 때 선언이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="f9d8a7611370241de60b894de016326924a7a9e7" translate="yes" xml:space="preserve">
          <source>ES6 Modules</source>
          <target state="translated">ES6 모듈</target>
        </trans-unit>
        <trans-unit id="e2acc8bb5a67f66241c722af8d11c013fb591c49" translate="yes" xml:space="preserve">
          <source>ES6 generators</source>
          <target state="translated">ES6 발전기</target>
        </trans-unit>
        <trans-unit id="ed61ecf2ad6576a5906a380e425433052f29a51a" translate="yes" xml:space="preserve">
          <source>ES6 introduces escapes that allow users to represent a Unicode codepoint using just a single escape.</source>
          <target state="translated">ES6에는 사용자가 단일 이스케이프를 사용하여 유니 코드 코드 포인트를 나타낼 수있는 이스케이프 기능이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="facf2ab431b3ab3e7ec6da17f65766fba3092531" translate="yes" xml:space="preserve">
          <source>ES7 exponentiation operator</source>
          <target state="translated">ES7 지수 연산자</target>
        </trans-unit>
        <trans-unit id="df1c0c4164faa864b6980e867e23ee2da1e921b7" translate="yes" xml:space="preserve">
          <source>Each enum member has a value associated with it which can be either &lt;em&gt;constant&lt;/em&gt; or &lt;em&gt;computed&lt;/em&gt;. An enum member is considered constant if:</source>
          <target state="translated">각 열거 형 멤버에는 &lt;em&gt;상수&lt;/em&gt; 또는 &lt;em&gt;계산&lt;/em&gt; 가능한 값이 있습니다 . 다음과 같은 경우 열거 형 멤버는 상수로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="5e4c52e3c0a22643b225662844bb284bc77facc8" translate="yes" xml:space="preserve">
          <source>Each module can optionally export a &lt;code&gt;default&lt;/code&gt; export. Default exports are marked with the keyword &lt;code&gt;default&lt;/code&gt;; and there can only be one &lt;code&gt;default&lt;/code&gt; export per module. &lt;code&gt;default&lt;/code&gt; exports are imported using a different import form.</source>
          <target state="translated">각 모듈은 선택적으로 &lt;code&gt;default&lt;/code&gt; 내보내기를 내보낼 수 있습니다. 기본 내보내기는 키워드 &lt;code&gt;default&lt;/code&gt; 로 표시됩니다 . 모듈 당 하나의 &lt;code&gt;default&lt;/code&gt; 내보내기 만 가능 합니다. &lt;code&gt;default&lt;/code&gt; 내보내기는 다른 가져 오기 양식을 사용하여 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1854fec7a183b17dc9b4b01211c91e48aea1794a" translate="yes" xml:space="preserve">
          <source>Each of these declaration forms creates a new type name.</source>
          <target state="translated">이러한 각 선언 양식은 새로운 유형 이름을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b86f360c4781ee31be3d35dcc610cf923afd132b" translate="yes" xml:space="preserve">
          <source>Each type of major library structuring pattern has a corresponding file in the &lt;a href=&quot;templates&quot;&gt;Templates&lt;/a&gt; section. You can start with these templates to help you get going faster.</source>
          <target state="translated">각 유형의 주요 라이브러리 구조화 패턴은 &lt;a href=&quot;templates&quot;&gt;템플리트&lt;/a&gt; 섹션 에 해당 파일이 있습니다. 이 템플릿으로 시작하여 더 빠르게 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e038538a33dfc2af3364ce4ef765b965c2e718a" translate="yes" xml:space="preserve">
          <source>Early Benefits</source>
          <target state="translated">조기 혜택</target>
        </trans-unit>
        <trans-unit id="ffd303c2b780c5345fb91f72058772c5f0edd26f" translate="yes" xml:space="preserve">
          <source>Editors like Visual Studio and Visual Studio Code can automatically apply quick fixes, refactorings, and other transformations like automatically importing values from other modules. These transformations are powered by TypeScript, and older versions of TypeScript unconditionally added semicolons to the end of every statement; unfortunately, this disagreed with many users&amp;rsquo; style guidelines, and many users were displeased with the editor inserting semicolons.</source>
          <target state="translated">Visual Studio 및 Visual Studio Code와 같은 편집자는 빠른 수정, 리팩토링 및 다른 모듈에서 값을 자동으로 가져 오기와 같은 기타 변환을 자동으로 적용 할 수 있습니다. 이러한 변환은 TypeScript에 의해 구동되며 이전 버전의 TypeScript는 모든 명령문 끝에 무조건 세미콜론을 추가했습니다. 불행히도, 이것은 많은 사용자의 스타일 가이드 라인에 동의하지 않았으며 많은 사용자들이 세미콜론을 삽입하는 에디터에 불만을 나타 냈습니다.</target>
        </trans-unit>
        <trans-unit id="ab2fc66180c7c3d32691e8c42f8df3300e931653" translate="yes" xml:space="preserve">
          <source>Either the constructor function of the class for a static member, or the prototype of the class for an instance member.</source>
          <target state="translated">정적 멤버에 대한 클래스의 생성자 함수 또는 인스턴스 멤버에 대한 클래스의 프로토 타입입니다.</target>
        </trans-unit>
        <trans-unit id="0871854bfc9d5eb95db51d532c4a4da986a587e1" translate="yes" xml:space="preserve">
          <source>Elements in the array binding pattern that have no match in the array literal are required to have a default value in the array binding pattern and are automatically added to the array literal type.</source>
          <target state="translated">배열 리터럴에서 일치하지 않는 배열 바인딩 패턴의 요소는 배열 바인딩 패턴에서 기본값을 가져야하며 배열 리터럴 유형에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d77d85d60ae04f1f62d384d542f348cbe2876ff0" translate="yes" xml:space="preserve">
          <source>Embedding Expressions</source>
          <target state="translated">식 내장</target>
        </trans-unit>
        <trans-unit id="596bc3c5e7f94b3b0596259252b4462615ba5b98" translate="yes" xml:space="preserve">
          <source>Emit &lt;code&gt;__importStar&lt;/code&gt; and &lt;code&gt;__importDefault&lt;/code&gt; helpers for runtime babel ecosystem compatibility and enable &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; for typesystem compatibility.</source>
          <target state="translated">방출 &lt;code&gt;__importStar&lt;/code&gt; 및 &lt;code&gt;__importDefault&lt;/code&gt; 런타임 바벨 에코 시스템과의 호환성을 위해 헬퍼 및 활성화 &lt;code&gt;--allowSyntheticDefaultImports&lt;/code&gt; 자료형 체계 호환성을.</target>
        </trans-unit>
        <trans-unit id="10fd7d2a0af6ba17c8a5d6662cb400314be7d895" translate="yes" xml:space="preserve">
          <source>Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files.</source>
          <target state="translated">출력 파일의 시작 부분에서 UTF-8 바이트 순서 표시 (BOM)를 방출하십시오.</target>
        </trans-unit>
        <trans-unit id="53b14d1fa9901ab52b3d302030734ec92bfda008" translate="yes" xml:space="preserve">
          <source>Emit a single file with source maps instead of having a separate file.</source>
          <target state="translated">별도의 파일 대신 소스 맵이있는 단일 파일을 방출하십시오.</target>
        </trans-unit>
        <trans-unit id="87aee0db862567627436ed01449478f0361912f7" translate="yes" xml:space="preserve">
          <source>Emit all of the output files in &lt;code&gt;built&lt;/code&gt; (with &lt;code&gt;outDir&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;built&lt;/code&gt; 모든 출력 파일을 작성하십시오 ( &lt;code&gt;outDir&lt;/code&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="6ac823149db4776d1721774a8881dd70ce3fbb97" translate="yes" xml:space="preserve">
          <source>Emit class fields with ECMAScript-standard semantics.</source>
          <target state="translated">ECMAScript 표준 시맨틱으로 클래스 필드를 방출합니다.</target>
        </trans-unit>
        <trans-unit id="41ad8902099d4f51e2a118572dcabdcda9aa3360" translate="yes" xml:space="preserve">
          <source>Emit design-type metadata for decorated declarations in source. See &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2577&quot;&gt;issue #2577&lt;/a&gt; for details.</source>
          <target state="translated">소스에서 장식 된 선언에 대한 디자인 유형 메타 데이터를 방출합니다. 자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2577&quot;&gt;문제 # 2577&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca3085fd048897dd750ce3fb153c2e815abe1acf" translate="yes" xml:space="preserve">
          <source>Emit the source alongside the sourcemaps within a single file; requires &lt;code&gt;--inlineSourceMap&lt;/code&gt; or &lt;code&gt;--sourceMap&lt;/code&gt; to be set.</source>
          <target state="translated">단일 파일 내에서 소스 맵과 함께 소스를 방출하십시오. 필요 &lt;code&gt;--inlineSourceMap&lt;/code&gt; 또는 &lt;code&gt;--sourceMap&lt;/code&gt; 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="07885f70bcc0b163283a8d21b81002971b80cbe8" translate="yes" xml:space="preserve">
          <source>Enable all strict type checking options.</source>
          <target state="translated">모든 엄격한 유형 검사 옵션을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="f3f87c2518fb86141f76c027d8adadd8fdd9cf78" translate="yes" xml:space="preserve">
          <source>Enable incremental compilation by reading/writing information from prior compilations to a file on disk. This file is controlled by the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target state="translated">이전 컴파일에서 디스크의 파일로 정보를 읽거나 써서 증분 컴파일을 활성화합니다. 이 파일은 &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; 플래그에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="29470d5b922e340851c6d198cc824890a7ae92da" translate="yes" xml:space="preserve">
          <source>Enable stricter checking of the &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; methods on functions.</source>
          <target state="translated">&lt;code&gt;bind&lt;/code&gt; , &lt;code&gt;call&lt;/code&gt; 및 &lt;code&gt;apply&lt;/code&gt; 메소드의 기능을 보다 엄격하게 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91f7049440bfb40ca1c47e9547370380c5c3f2e9" translate="yes" xml:space="preserve">
          <source>Enable the &lt;code&gt;jsx&lt;/code&gt; option</source>
          <target state="translated">활성화 &lt;code&gt;jsx&lt;/code&gt; 옵션을</target>
        </trans-unit>
        <trans-unit id="da566f675009da0e991b7854614c23e919fa5b97" translate="yes" xml:space="preserve">
          <source>Enables experimental support for ES decorators.</source>
          <target state="translated">ES 데코레이터를 실험적으로 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4ba38450ee027bba050ddc6f6958b0dc5a751f2" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;--declarationMap&lt;/code&gt; alongside &lt;code&gt;--declaration&lt;/code&gt; causes the compiler to emit &lt;code&gt;.d.ts.map&lt;/code&gt; files alongside the output &lt;code&gt;.d.ts&lt;/code&gt; files. Language Services can also now understand these map files, and uses them to map declaration-file based definition locations to their original source, when available.</source>
          <target state="translated">사용 &lt;code&gt;--declarationMap&lt;/code&gt; 함께 &lt;code&gt;--declaration&lt;/code&gt; 것은 방출하는 컴파일러의 원인 &lt;code&gt;.d.ts.map&lt;/code&gt; 출력과 함께 파일을 &lt;code&gt;.d.ts&lt;/code&gt; 의 파일을. 언어 서비스는 이제 이러한 맵 파일을 이해하고이를 사용하여 선언 파일 기반 정의 위치를 ​​사용 가능한 경우 원래 소스에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="72c9407930092256221610ac7ab395e789b77dfa" translate="yes" xml:space="preserve">
          <source>Enabling &lt;code&gt;--strict&lt;/code&gt; enables &lt;code&gt;--noImplicitAny&lt;/code&gt;, &lt;code&gt;--noImplicitThis&lt;/code&gt;, &lt;code&gt;--alwaysStrict&lt;/code&gt;, &lt;code&gt;--strictBindCallApply&lt;/code&gt;, &lt;code&gt;--strictNullChecks&lt;/code&gt;, &lt;code&gt;--strictFunctionTypes&lt;/code&gt; and &lt;code&gt;--strictPropertyInitialization&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--strict&lt;/code&gt; 를 활성화 하면 &lt;code&gt;--noImplicitAny&lt;/code&gt; , &lt;code&gt;--noImplicitThis&lt;/code&gt; , &lt;code&gt;--alwaysStrict&lt;/code&gt; , &lt;code&gt;--strictBindCallApply&lt;/code&gt; , &lt;code&gt;--strictNullChecks&lt;/code&gt; , &lt;code&gt;--strictFunctionTypes&lt;/code&gt; 및 &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; 이 활성화 됩니다.</target>
        </trans-unit>
        <trans-unit id="0c09f58749451934cce8c0be5ef42b0d3dbd75b5" translate="yes" xml:space="preserve">
          <source>Enhanced &lt;code&gt;--init&lt;/code&gt; output</source>
          <target state="translated">강화 된 &lt;code&gt;--init&lt;/code&gt; 출력</target>
        </trans-unit>
        <trans-unit id="c5a806eb89f7dea65ab700be49a0d4d559514188" translate="yes" xml:space="preserve">
          <source>Ensure TypeScript can determine where to find the outputs of the referenced project to compile project.</source>
          <target state="translated">TypeScript가 프로젝트를 컴파일하기 위해 참조 된 프로젝트의 출력을 찾을 위치를 결정할 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="90ebaa427f44ae4c263b34e0e48d73b34fd5b03c" translate="yes" xml:space="preserve">
          <source>Ensure non-undefined class properties are initialized in the constructor. This option requires &lt;code&gt;--strictNullChecks&lt;/code&gt; be enabled in order to take effect.</source>
          <target state="translated">정의되지 않은 클래스 속성이 생성자에서 초기화되었는지 확인하십시오. 이 옵션을 적용하려면 &lt;code&gt;--strictNullChecks&lt;/code&gt; 를 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="63b63149cd444d6b9da7fe416ce289557f10a9e7" translate="yes" xml:space="preserve">
          <source>Enter Index Type Query or &lt;code&gt;keyof&lt;/code&gt;; An indexed type query &lt;code&gt;keyof T&lt;/code&gt; yields the type of permitted property names for &lt;code&gt;T&lt;/code&gt;. A &lt;code&gt;keyof T&lt;/code&gt; type is considered a subtype of &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">색인 유형 조회 또는 &lt;code&gt;keyof&lt;/code&gt; 를 입력하십시오 . 인덱싱 된 유형의 쿼리 &lt;code&gt;keyof T&lt;/code&gt; 허용 속성 이름의 유형 산출 &lt;code&gt;T&lt;/code&gt; 를 . &lt;code&gt;keyof T&lt;/code&gt; 의 유형의 하위 유형으로 간주됩니다 &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20588ae8e5c269292d35f9dfffa8f2eb3fd3c259" translate="yes" xml:space="preserve">
          <source>Enum</source>
          <target state="translated">Enum</target>
        </trans-unit>
        <trans-unit id="04dd4dbb8815c963d82df0161b050d4d9dafeb1d" translate="yes" xml:space="preserve">
          <source>Enum Member Types</source>
          <target state="translated">열거 형 멤버 유형</target>
        </trans-unit>
        <trans-unit id="f3104dd45718e6d1ac6a03b91ae67193ae8361f0" translate="yes" xml:space="preserve">
          <source>Enums</source>
          <target state="translated">Enums</target>
        </trans-unit>
        <trans-unit id="f0e0e96cf6626f01df64dec457720adc8996018c" translate="yes" xml:space="preserve">
          <source>Enums allow us to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.</source>
          <target state="translated">열거 형을 사용하면 명명 된 상수 집합을 정의 할 수 있습니다. 열거 형을 사용하면 의도를보다 쉽게 ​​문서화하거나 고유 한 사례를 만들 수 있습니다. TypeScript는 숫자 및 문자열 기반 열거 형을 모두 제공합니다.</target>
        </trans-unit>
        <trans-unit id="446bd29a002c17497b41b96657fcf40bf1d514a6" translate="yes" xml:space="preserve">
          <source>Enums are compatible with numbers, and numbers are compatible with enums. Enum values from different enum types are considered incompatible. For example,</source>
          <target state="translated">열거 형은 숫자와 호환되며 숫자는 열거 형과 호환됩니다. 다른 열거 형 유형의 열거 형 값은 호환되지 않는 것으로 간주됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="9611d38688bf1d99ca887b354676cea9ac16e83d" translate="yes" xml:space="preserve">
          <source>Enums are real objects that exist at runtime. For example, the following enum</source>
          <target state="translated">열거 형은 런타임에 존재하는 실제 객체입니다. 예를 들어 다음 열거 형</target>
        </trans-unit>
        <trans-unit id="aa2b9875683168f991703bdf2407bc70e31110ed" translate="yes" xml:space="preserve">
          <source>Enums are very useful, but some programs don&amp;rsquo;t actually need the generated code and would benefit from simply inlining all instances of enum members with their numeric equivalents. The new &lt;code&gt;const enum&lt;/code&gt; declaration works just like a regular &lt;code&gt;enum&lt;/code&gt; for type safety, but erases completely at compile time.</source>
          <target state="translated">열거 형은 매우 유용하지만 일부 프로그램에는 실제로 생성 된 코드가 필요하지 않으며 열거 형 멤버의 모든 인스턴스를 숫자로 등가로 간단히 인라인하면 이점이 있습니다. 새로운 &lt;code&gt;const enum&lt;/code&gt; 선언은 형식 안전성을위한 일반 &lt;code&gt;enum&lt;/code&gt; 과 동일하게 작동 하지만 컴파일 타임에 완전히 지워집니다.</target>
        </trans-unit>
        <trans-unit id="1efbfb0dab275f1ef5a349fd19a692fb55ff662d" translate="yes" xml:space="preserve">
          <source>Enums at compile time</source>
          <target state="translated">컴파일 타임에 열거 형</target>
        </trans-unit>
        <trans-unit id="91ebfc95d6553fab6dcdd9b37826083250ec08fa" translate="yes" xml:space="preserve">
          <source>Enums at runtime</source>
          <target state="translated">런타임에 열거 형</target>
        </trans-unit>
        <trans-unit id="d12be1b5b741cc430eaddee58fc5792da5e03257" translate="yes" xml:space="preserve">
          <source>Error for not finding &lt;code&gt;moduleB&lt;/code&gt; as it was not passed.</source>
          <target state="translated">&lt;code&gt;moduleB&lt;/code&gt; 가 전달 되지 않아 찾지 못했습니다 .</target>
        </trans-unit>
        <trans-unit id="5dbdd5b8b6b60bfdc1de358cfd5636ff3b41ecfd" translate="yes" xml:space="preserve">
          <source>Error messages in Russian:</source>
          <target state="translated">러시아어 오류 메시지 :</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="6f19afca75f8b76cf43de3568bc8609dc8d889e8" translate="yes" xml:space="preserve">
          <source>Errors in .js files with &lt;code&gt;--checkJs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--checkJs&lt;/code&gt; 가 있는 .js 파일의 오류</target>
        </trans-unit>
        <trans-unit id="ff7513853508e7c6e3aa07908df2a450a026eb88" translate="yes" xml:space="preserve">
          <source>Evaluation</source>
          <target state="translated">Evaluation</target>
        </trans-unit>
        <trans-unit id="c4995d18bbd28ef5b42bb49d1ba1191de1d44e61" translate="yes" xml:space="preserve">
          <source>Even at this point you can get some great benefits from TypeScript understanding your project. If you open up an editor like &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;VS Code&lt;/a&gt; or &lt;a href=&quot;https://visualstudio.com&quot;&gt;Visual Studio&lt;/a&gt;, you&amp;rsquo;ll see that you can often get some tooling support like completion. You can also catch certain bugs with options like:</source>
          <target state="translated">이 시점에서도 프로젝트를 이해하는 TypeScript의 이점을 얻을 수 있습니다. &lt;a href=&quot;https://code.visualstudio.com&quot;&gt;VS Code&lt;/a&gt; 또는 &lt;a href=&quot;https://visualstudio.com&quot;&gt;Visual Studio&lt;/a&gt; 와 같은 편집기를 열면 완료와 같은 일부 툴링 지원을받을 수 있음을 알 수 있습니다. 다음과 같은 옵션으로 특정 버그를 잡을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="30bbcbc5524ea12d314a912290ed9ada676d698e" translate="yes" xml:space="preserve">
          <source>Even better, TypeScript will warn you when you make this mistake if you pass the &lt;code&gt;--noImplicitThis&lt;/code&gt; flag to the compiler. It will point out that &lt;code&gt;this&lt;/code&gt; in &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; is of type &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">더 좋은 점은 &lt;code&gt;--noImplicitThis&lt;/code&gt; 플래그를 컴파일러에 전달하면이 실수를 할 때 TypeScript가 경고합니다 . 또한 지적 할 &lt;code&gt;this&lt;/code&gt; 에 &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; 형이고 &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="173ad8610f22a569603ffb0f1d0d6365bdf43e93" translate="yes" xml:space="preserve">
          <source>Even though Enums are real objects that exist at runtime, the &lt;code&gt;keyof&lt;/code&gt; keyword works differently than you might expect for typical objects. Instead, use &lt;code&gt;keyof typeof&lt;/code&gt; to get a Type that represents all Enum keys as strings.</source>
          <target state="translated">열거 형은 런타임에 존재하는 실제 객체이지만 &lt;code&gt;keyof&lt;/code&gt; 키워드는 일반적인 객체와 다르게 작동합니다. 대신 &lt;code&gt;keyof typeof&lt;/code&gt; 를 사용 하여 모든 Enum 키를 문자열로 나타내는 Type을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="fce516d03ed65b851ebf38e0525aa5bb18cc7fca" translate="yes" xml:space="preserve">
          <source>Every time the compiler sees a relative module import in a subfolder of one of the &lt;code&gt;rootDirs&lt;/code&gt;, it will attempt to look for this import in each of the entries of &lt;code&gt;rootDirs&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 하나의 하위 폴더에 상대 모듈 가져 오기를 볼 때마다 &lt;code&gt;rootDirs&lt;/code&gt; 는 , 그것의 각 항목이 수입을 찾기 위해 시도합니다 &lt;code&gt;rootDirs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="7db0747c7372815c3b79f00827a669c7a4dff2d2" translate="yes" xml:space="preserve">
          <source>Example &lt;code&gt;tsconfig.json&lt;/code&gt; files:</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 파일 예 :</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="d90ae2c05a80c11c94b6d08fd48a89595af4e49d" translate="yes" xml:space="preserve">
          <source>Examples of Global Libraries</source>
          <target state="translated">글로벌 라이브러리의 예</target>
        </trans-unit>
        <trans-unit id="816ee629d75640df7d32cc7a04c198a2ba361b71" translate="yes" xml:space="preserve">
          <source>Examples of Modular Libraries</source>
          <target state="translated">모듈 식 라이브러리의 예</target>
        </trans-unit>
        <trans-unit id="d278e672973bdd09840c8aa311736e998691e0d6" translate="yes" xml:space="preserve">
          <source>Examples of UMD libraries</source>
          <target state="translated">UMD 라이브러리의 예</target>
        </trans-unit>
        <trans-unit id="713425259fb0fd114e02f534a62ae30601cda2b7" translate="yes" xml:space="preserve">
          <source>Excess Property Checks</source>
          <target state="translated">초과 자산 점검</target>
        </trans-unit>
        <trans-unit id="547cac401b8bdafefb3c93432b560b402f27bd52" translate="yes" xml:space="preserve">
          <source>Exclude&amp;lt;T,U&amp;gt;</source>
          <target state="translated">Exclude&amp;lt;T,U&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e6d793aeaefda145ae379cd867a6553a054c4ae4" translate="yes" xml:space="preserve">
          <source>Execute Babel from the command line</source>
          <target state="translated">명령 행에서 Babel 실행</target>
        </trans-unit>
        <trans-unit id="36e4946cdd24644aa9627cc6ffbfecf2fb7124a0" translate="yes" xml:space="preserve">
          <source>Exhaustiveness checking</source>
          <target state="translated">철저한 검사</target>
        </trans-unit>
        <trans-unit id="be111b001bea1086e5ed60f0def95e565522aa10" translate="yes" xml:space="preserve">
          <source>Expansion of rest parameters with tuple types into discrete parameters.</source>
          <target state="translated">튜플 유형의 나머지 매개 변수를 이산 매개 변수로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="0f747d8df97d89385abfc342525e23104fc53d2b" translate="yes" xml:space="preserve">
          <source>Expansion of spread expressions with tuple types into discrete arguments.</source>
          <target state="translated">튜플 형식의 스프레드 식을 이산 형 인수로 확장</target>
        </trans-unit>
        <trans-unit id="eb541c0761ac733bf3e3daebf487a743c08ec49f" translate="yes" xml:space="preserve">
          <source>Experimental support for &lt;code&gt;async&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;async&lt;/code&gt; 함수에 대한 실험적 지원</target>
        </trans-unit>
        <trans-unit id="c2368c03d9c425fa5b1b554196b18d9b35543814" translate="yes" xml:space="preserve">
          <source>Explicit types on &lt;code&gt;defaultProps&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;defaultProps&lt;/code&gt; 의 명시 적 유형</target>
        </trans-unit>
        <trans-unit id="7038922b5a5d6db45da593914421a491587b2f7f" translate="yes" xml:space="preserve">
          <source>Explicitly list imported names</source>
          <target state="translated">가져온 이름을 명시 적으로 나열</target>
        </trans-unit>
        <trans-unit id="f3e4fadb9e370a1e2c0c622c01fc8c77daf93a2c" translate="yes" xml:space="preserve">
          <source>Export</source>
          <target state="translated">Export</target>
        </trans-unit>
        <trans-unit id="ee287a51eb5e0d85cc359b2e80f44c061f51aae0" translate="yes" xml:space="preserve">
          <source>Export Declarations</source>
          <target state="translated">수출 신고</target>
        </trans-unit>
        <trans-unit id="3eb5fdc5e694d39f19fe4b7038742fba0274b196" translate="yes" xml:space="preserve">
          <source>Export as close to top-level as possible</source>
          <target state="translated">가능한 한 최상위 수준에 가깝게 내보내기</target>
        </trans-unit>
        <trans-unit id="d426e470cf0b8e87df60e791d67c0cc7797da09b" translate="yes" xml:space="preserve">
          <source>Export statements</source>
          <target state="translated">수출 명세서</target>
        </trans-unit>
        <trans-unit id="b321b13d568f9f33b7a4846fbc6a9d7e3b9d6029" translate="yes" xml:space="preserve">
          <source>Export statements are handy when exports need to be renamed for consumers, so the above example can be written as:</source>
          <target state="translated">내보내기 명령문은 소비자의 내보내기 이름을 바꿔야 할 때 편리하므로 위 예제를 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3b534c8bf9a0c462bc4987c3561321862fa8572" translate="yes" xml:space="preserve">
          <source>Exporting a declaration</source>
          <target state="translated">선언 내보내기</target>
        </trans-unit>
        <trans-unit id="20ed777374ec9c640b886c9f9410bc59fc7a8afa" translate="yes" xml:space="preserve">
          <source>Exporting a namespace from your module is an example of adding too many layers of nesting. While namespaces sometime have their uses, they add an extra level of indirection when using modules. This can quickly become a pain point for users, and is usually unnecessary.</source>
          <target state="translated">모듈에서 네임 스페이스를 내보내는 것은 너무 많은 중첩 레이어를 추가하는 예입니다. 네임 스페이스는 때때로 사용되지만 모듈을 사용할 때 추가 수준의 간접 성을 추가합니다. 이것은 사용자에게 빨리 고통의 원인이 될 수 있으며 일반적으로 불필요합니다.</target>
        </trans-unit>
        <trans-unit id="33b0e248cae60e2ac77c9d292f495d69dfef3e27" translate="yes" xml:space="preserve">
          <source>Exporting from Modules</source>
          <target state="translated">모듈에서 내보내기</target>
        </trans-unit>
        <trans-unit id="79421f7ea94b7e0cba104ffc2178605b08987de2" translate="yes" xml:space="preserve">
          <source>Expression operators</source>
          <target state="translated">식 연산자</target>
        </trans-unit>
        <trans-unit id="e03a0c147ab3a0e6973bff36e8c810e9858d8a41" translate="yes" xml:space="preserve">
          <source>Expression operators permit operand types to include &lt;code&gt;null&lt;/code&gt; and/or &lt;code&gt;undefined&lt;/code&gt; but always produce values of non-null and non-undefined types.</source>
          <target state="translated">식 연산자는 피연산자 유형에 &lt;code&gt;null&lt;/code&gt; 및 / 또는 &lt;code&gt;undefined&lt;/code&gt; 가 포함되도록 허용 하지만 항상 null이 아닌 유형과 정의되지 않은 유형의 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dcabbc390e17d15f91473972556065a69ff821df" translate="yes" xml:space="preserve">
          <source>Extending Classes</source>
          <target state="translated">수업 연장</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
