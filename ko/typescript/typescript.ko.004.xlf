<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="71107e6f11d3d9498db10524c3f3c164f19e9415" translate="yes" xml:space="preserve">
          <source>TypeScript 2.6 support suppressing errors in .js files using &lt;code&gt;// @ts-ignore&lt;/code&gt; comments placed above the offending lines.</source>
          <target state="translated">TypeScript 2.6 은 문제의 행 위에 &lt;code&gt;// @ts-ignore&lt;/code&gt; 주석을 사용하여 .js 파일에서 오류 억제를 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="bef45e6468d0c0a17f09c30d2b82dd8a05124a51" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7</source>
          <target state="translated">TypeScript 2.7</target>
        </trans-unit>
        <trans-unit id="79e7e447b60909166288dcf8cb72e27e89f7cec5" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 adds support for declaring const-named properties on types including ECMAScript symbols.</source>
          <target state="translated">TypeScript 2.7은 ECMAScript 기호를 포함하여 유형에 대한 const-named 속성 선언을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a51783c99c59b3257833940324affc2689b71a24" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 also introduced &lt;code&gt;--watch&lt;/code&gt; mode builds via a new incremental &amp;ldquo;builder&amp;rdquo; API. In a similar vein, the entire idea is that this mode only re-checks and re-emits changed files or files whose dependencies might impact type-checking. You can think of this as optimizing &lt;em&gt;intra&lt;/em&gt;-project builds.</source>
          <target state="translated">TypeScript 2.7은 또한 새로운 증분&amp;ldquo;빌더&amp;rdquo;API를 통해 &lt;code&gt;--watch&lt;/code&gt; 모드 빌드를 도입 했습니다 . 비슷한 맥락에서,이 모드 전체는이 모드가 의존성 유형 검사에 영향을 줄 수있는 변경된 파일 또는 파일 만 재확인하고 재 방출한다는 것입니다. 이를 프로젝트 &lt;em&gt;내&lt;/em&gt; 빌드 최적화로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="162b6515dd83712cce22c0f4cc8d254c9b33661b" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 brings support for &lt;a href=&quot;https://github.com/tc39/proposal-numeric-separator&quot;&gt;ES Numeric Separators&lt;/a&gt;. Numeric literals can now be separated into segments using &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">TypeScript 2.7은 &lt;a href=&quot;https://github.com/tc39/proposal-numeric-separator&quot;&gt;ES Numeric Separators를&lt;/a&gt; 지원합니다 . 숫자 리터럴은 이제 &lt;code&gt;_&lt;/code&gt; 를 사용하여 세그먼트로 분리 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af59c15c50945a988e8dab909a898e4259657c00" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 improves the handling of structurally identical classes in union types and &lt;code&gt;instanceof&lt;/code&gt; expressions:</source>
          <target state="translated">TypeScript 2.7은 공용체 유형 및 &lt;code&gt;instanceof&lt;/code&gt; 표현식 에서 구조적으로 동일한 클래스의 처리를 향상시킵니다 .</target>
        </trans-unit>
        <trans-unit id="91f038aff687710c549846983751034fac966226" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 improves type inference for multiple object literals occurring in the same context. When multiple object literal types contribute to a union type, we now &lt;em&gt;normalize&lt;/em&gt; the object literal types such that all properties are present in each constituent of the union type.</source>
          <target state="translated">TypeScript 2.7은 동일한 컨텍스트에서 발생하는 여러 개체 리터럴에 대한 형식 유추를 향상시킵니다. 여러 객체 리터럴 유형이 공용체 유형에 기여하는 경우 이제 모든 특성이 통합 유형의 각 구성 요소에 존재하도록 객체 리터럴 유형을 &lt;em&gt;정규화&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6ab94d5588595f01a47bea04f5db381bcbb5dba9" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 introduces a new flag called &lt;code&gt;--strictPropertyInitialization&lt;/code&gt;. This flag performs checks to ensure that each instance property of a class gets initialized in the constructor body, or by a property initializer. For example</source>
          <target state="translated">TypeScript 2.7에는 &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; 이라는 새로운 플래그가 도입되었습니다 . 이 플래그는 클래스의 각 인스턴스 속성이 생성자 본문 또는 속성 이니셜 라이저에서 초기화되는지 확인합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="50a1f4f6bc66299bafe27e7f60a3413972205937" translate="yes" xml:space="preserve">
          <source>TypeScript 2.7 updates CommonJS/AMD/UMD module emit to synthesize namespace records based on the presence of an &lt;code&gt;__esModule&lt;/code&gt; indicator under &lt;code&gt;--esModuleInterop&lt;/code&gt;. The change brings the generated output from TypeScript closer to that generated by Babel.</source>
          <target state="translated">TypeScript 2.7은 CommonJS / AMD / UMD 모듈이 &lt;code&gt;__esModule&lt;/code&gt; 아래에 &lt;code&gt;--esModuleInterop&lt;/code&gt; 표시기 의 존재에 따라 네임 스페이스 레코드를 합성하도록 업데이트합니다 . 이 변경으로 TypeScript에서 생성 된 출력이 Babel에서 생성 된 출력에 더 가깝게됩니다.</target>
        </trans-unit>
        <trans-unit id="4e42d10f15cd2510b82037d64e9dbecd5c11e732" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8</source>
          <target state="translated">TypeScript 2.8</target>
        </trans-unit>
        <trans-unit id="3b84208a266962375c246ada5aa0bd123c9cfe9e" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 adds several predefined conditional types to &lt;code&gt;lib.d.ts&lt;/code&gt;:</source>
          <target state="translated">TypeScript 2.8은 사전 정의 된 여러 조건 유형을 &lt;code&gt;lib.d.ts&lt;/code&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="c5e0ed8e368b2f12d192ed317481ad4102d428b8" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 adds support for a per-file configurable JSX factory name using &lt;code&gt;@jsx dom&lt;/code&gt; pragma. JSX factory can be configured for a compilation using &lt;code&gt;--jsxFactory&lt;/code&gt; (default is &lt;code&gt;React.createElement&lt;/code&gt;). With TypeScript 2.8 you can override this on a per-file-basis by adding a comment to the beginning of the file.</source>
          <target state="translated">TypeScript 2.8은 &lt;code&gt;@jsx dom&lt;/code&gt; pragma를 사용하여 파일별로 구성 가능한 JSX 팩토리 이름에 대한 지원을 추가합니다 . JSX 공장 사용하여 컴파일을 구성 할 수 있습니다 &lt;code&gt;--jsxFactory&lt;/code&gt; 을 (기본값은 &lt;code&gt;React.createElement&lt;/code&gt; ). TypeScript 2.8을 사용하면 파일 시작 부분에 주석을 추가하여 파일 단위로이를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f6ad1955b40525b81ee6b350e3efda1dca7803e" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 adds support for understanding more namespace patterns in &lt;code&gt;.js&lt;/code&gt; files. Empty object literals declarations on top level, just like functions and classes, are now recognized as as namespace declarations in JavaScript.</source>
          <target state="translated">TypeScript 2.8은 &lt;code&gt;.js&lt;/code&gt; 파일 에서 더 많은 네임 스페이스 패턴을 이해하기위한 지원을 추가 합니다. 함수 및 클래스와 마찬가지로 최상위 수준의 빈 객체 리터럴 선언은 이제 JavaScript에서 네임 스페이스 선언으로 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="f9e15ad123318d14a1567d61a8eb9b88ec3f14c9" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 adds the ability for a mapped type to either add or remove a particular modifier. Specifically, a &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; property modifier in a mapped type can now be prefixed with either &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; to indicate that the modifier should be added or removed.</source>
          <target state="translated">TypeScript 2.8은 매핑 된 유형이 특정 수정자를 추가하거나 제거하는 기능을 추가합니다. 특히 &lt;code&gt;readonly&lt;/code&gt; 또는 &lt;code&gt;?&lt;/code&gt; 매핑 된 유형의 속성 수정 자 앞에 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 를 붙여 수정자를 추가하거나 제거해야 함을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccbc7d666b3ba41052f2f21dcaf1e812e9bac36a" translate="yes" xml:space="preserve">
          <source>TypeScript 2.8 introduces &lt;em&gt;conditional types&lt;/em&gt; which add the ability to express non-uniform type mappings. A conditional type selects one of two possible types based on a condition expressed as a type relationship test:</source>
          <target state="translated">TypeScript 2.8에는 비 균일 형식 매핑을 표현하는 기능이 추가 된 &lt;em&gt;조건부 형식&lt;/em&gt; 이 도입되었습니다 . 조건부 유형은 유형 관계 테스트로 표현 된 조건에 따라 두 가지 가능한 유형 중 하나를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="38d22337c31f40538f05a1b3be32d35d5d040ad3" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9</source>
          <target state="translated">TypeScript 2.9</target>
        </trans-unit>
        <trans-unit id="79a8a3cdfaf2e7ea5b694163b786814a57e8ccbe" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9 adds support for &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named properties in index types and mapped types. Previously, the &lt;code&gt;keyof&lt;/code&gt; operator and mapped types only supported &lt;code&gt;string&lt;/code&gt; named properties.</source>
          <target state="translated">TypeScript 2.9는 인덱스 유형 및 매핑 된 유형의 &lt;code&gt;number&lt;/code&gt; 및 &lt;code&gt;symbol&lt;/code&gt; 명명 속성에 대한 지원을 추가합니다 . 이전에는 &lt;code&gt;keyof&lt;/code&gt; 연산자와 매핑 된 유형 만 속성으로 명명 된 &lt;code&gt;string&lt;/code&gt; 만 지원했습니다 .</target>
        </trans-unit>
        <trans-unit id="f3af31e687b53bc6028a7656648578f8526d1535" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9 allows passing generic type arguments to tagged template strings.</source>
          <target state="translated">TypeScript 2.9에서는 일반 형식 인수를 태그가 지정된 템플릿 문자열에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c576ebab33996a3a7642529b1b3cf098557fad0c" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9 and earlier didn&amp;rsquo;t leverage &lt;a href=&quot;https://reactjs.org/docs/typechecking-with-proptypes.html#default-prop-values&quot;&gt;React &lt;code&gt;defaultProps&lt;/code&gt;&lt;/a&gt; declarations inside JSX components. Users would often have to declare properties optional and use non-null assertions inside of &lt;code&gt;render&lt;/code&gt;, or they&amp;rsquo;d use type-assertions to fix up the type of the component before exporting it.</source>
          <target state="translated">TypeScript 2.9 및 이전 버전은 JSX 구성 요소 내에서 &lt;a href=&quot;https://reactjs.org/docs/typechecking-with-proptypes.html#default-prop-values&quot;&gt;React &lt;code&gt;defaultProps&lt;/code&gt; &lt;/a&gt; 선언을 사용 하지 않았습니다 . 사용자는 속성을 선택적으로 선언하고 &lt;code&gt;render&lt;/code&gt; 내에서 null이 아닌 어설 션을 사용해야하거나 구성 요소를 내보내기 전에 구성 요소의 형식을 수정하기 위해 형식 어설 션을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="54d0224b3f561c10aa0b8f9cc4af3cf6fc0acd70" translate="yes" xml:space="preserve">
          <source>TypeScript 2.9 introduces support for &lt;code&gt;import.meta&lt;/code&gt;, a new meta-property as described by the current &lt;a href=&quot;https://github.com/tc39/proposal-import-meta&quot;&gt;TC39 proposal&lt;/a&gt;.</source>
          <target state="translated">TypeScript 2.9 에는 현재 &lt;a href=&quot;https://github.com/tc39/proposal-import-meta&quot;&gt;TC39 제안서에&lt;/a&gt; 설명 된대로 새로운 메타 속성 인 &lt;code&gt;import.meta&lt;/code&gt; 에 대한 지원이 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ff47669d6e3d77ab534a2150af62bcea4228ce7e" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0</source>
          <target state="translated">TypeScript 3.0</target>
        </trans-unit>
        <trans-unit id="1b5495b8f8bb8ada5fe9aabb083f17ca19955412" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 adds support for a new type alias in the &lt;code&gt;JSX&lt;/code&gt; namespace called &lt;code&gt;LibraryManagedAttributes&lt;/code&gt;. This helper type defines a transformation on the component&amp;rsquo;s &lt;code&gt;Props&lt;/code&gt; type, before using to check a JSX expression targeting it; thus allowing customization like: how conflicts between provided props and inferred props are handled, how inferences are mapped, how optionality is handled, and how inferences from differing places should be combined.</source>
          <target state="translated">타이프 3.0은 새로운 유형의 별명에 대한 지원을 추가 &lt;code&gt;JSX&lt;/code&gt; 의 네임 스페이스라는 &lt;code&gt;LibraryManagedAttributes&lt;/code&gt; . 이 헬퍼 유형은 컴포넌트를 대상으로하는 JSX 표현식을 확인하기 위해 사용하기 전에 컴포넌트의 &lt;code&gt;Props&lt;/code&gt; 유형 에 대한 변환을 정의 합니다. 따라서 제공된 소품과 유추 된 소품 사이의 충돌을 처리하는 방법, 추론을 매핑하는 방법, 선택성을 처리하는 방법 및 다른 장소의 추론을 결합하는 방법과 같은 사용자 정의가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="898331749799c0ae0af6a27a2c4a2bf1b9107b53" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 adds support to multiple new capabilities to interact with function parameter lists as tuple types. TypeScript 3.0 adds support for:</source>
          <target state="translated">TypeScript 3.0은 여러 새로운 기능에 대한 지원을 추가하여 튜플 유형으로 함수 매개 변수 목록과 상호 작용합니다. TypeScript 3.0은 다음에 대한 지원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="24d0fe89da15fd3c400693e525d5250f550dd57a" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 also introduces a new mode for tsc, the &lt;code&gt;--build&lt;/code&gt; flag, that works hand-in-hand with project references to enable faster TypeScript builds.</source>
          <target state="translated">TypeScript 3.0은 프로젝트 빌드와 함께 작동하여 더 빠른 TypeScript 빌드를 가능하게 하는 tsc의 새로운 모드 인 &lt;code&gt;--build&lt;/code&gt; 플래그 를 도입했습니다 .</target>
        </trans-unit>
        <trans-unit id="76ebacc06303039a717759a1bc81f839c55d819c" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 introduced a new feature for structuring builds called &amp;ldquo;composite projects&amp;rdquo;. Part of the goal here was to ensure users could break up large projects into smaller parts that build quickly and preserve project structure, without compromising the existing TypeScript experience. Thanks to composite projects, TypeScript can use &lt;code&gt;--build&lt;/code&gt; mode to recompile only the set of projects and dependencies. You can think of this as optimizing &lt;em&gt;inter&lt;/em&gt;-project builds.</source>
          <target state="translated">TypeScript 3.0에는 &quot;복합 프로젝트&quot;라는 빌드 구조를위한 새로운 기능이 도입되었습니다. 여기서 목표의 일부는 사용자가 기존 TypeScript 환경을 손상시키지 않으면 서 큰 프로젝트를 더 작은 부분으로 분할하여 신속하게 빌드하고 프로젝트 구조를 보존 할 수 있도록하는 것입니다. 복합 프로젝트 덕분에 TypeScript는 &lt;code&gt;--build&lt;/code&gt; 모드를 사용 하여 프로젝트 및 종속성 세트 만 다시 컴파일 할 수 있습니다 . 이를 프로젝트 &lt;em&gt;간&lt;/em&gt; 빌드 최적화라고 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12be550f3be8a1f6da19a996860414de543a9312" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 introduced support for referencing other and building them incrementally using the &lt;code&gt;--build&lt;/code&gt; flag. Additionally, TypeScript 3.4 introduced the &lt;code&gt;--incremental&lt;/code&gt; flag for saving information about previous compilations to only rebuild certain files. These flags were incredibly useful for structuring projects more flexibly and speeding builds up. Unfortunately, using these flags didn&amp;rsquo;t work with 3rd party build tools like Gulp and Webpack. TypeScript 3.6 now exposes two sets of APIs to operate on project references and incremental program building.</source>
          <target state="translated">TypeScript 3.0은 &lt;code&gt;--build&lt;/code&gt; 플래그를 사용하여 다른 것을 참조하고 점진적으로 빌드하는 기능을 지원합니다 . 또한 TypeScript 3.4에는 특정 파일 만 다시 작성하기 위해 이전 컴파일에 대한 정보를 저장 하는 &lt;code&gt;--incremental&lt;/code&gt; 플래그가 도입되었습니다 . 이 플래그는 프로젝트를보다 유연하게 구성하고 빌드 속도를 높이는 데 매우 유용했습니다. 불행히도 이러한 플래그를 사용하면 Gulp 및 Webpack과 같은 타사 빌드 도구에서 작동하지 않았습니다. TypeScript 3.6은 이제 프로젝트 참조 및 증분 프로그램 빌드에서 작동 할 두 개의 API 세트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ef2e2b53b736d1c6d2b067c0b85011c12a528c2f" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 introduces a new concept of project references. Project references allow TypeScript projects to depend on other TypeScript projects - specifically, allowing &lt;code&gt;tsconfig.json&lt;/code&gt; files to reference other &lt;code&gt;tsconfig.json&lt;/code&gt; files. Specifying these dependencies makes it easier to split your code into smaller projects, since it gives TypeScript (and tools around it) a way to understand build ordering and output structure.</source>
          <target state="translated">TypeScript 3.0에는 새로운 개념의 프로젝트 참조가 도입되었습니다. 프로젝트 참조를 통해 TypeScript 프로젝트는 다른 TypeScript 프로젝트에 의존 할 수 있습니다. 특히 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일이 다른 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일 을 참조 할 수 있습니다. 이러한 종속성을 지정하면 TypeScript (및 그 주위의 도구)에 빌드 순서 및 출력 구조를 이해할 수있는 방법이 제공되므로 코드를 더 작은 프로젝트로 쉽게 분할 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="303ce39af16c9af3efeedd99c02704afd6f021df" translate="yes" xml:space="preserve">
          <source>TypeScript 3.0 introduces a new top type &lt;code&gt;unknown&lt;/code&gt;. &lt;code&gt;unknown&lt;/code&gt; is the type-safe counterpart of &lt;code&gt;any&lt;/code&gt;. Anything is assignable to &lt;code&gt;unknown&lt;/code&gt;, but &lt;code&gt;unknown&lt;/code&gt; isn&amp;rsquo;t assignable to anything but itself and &lt;code&gt;any&lt;/code&gt; without a type assertion or a control flow based narrowing. Likewise, no operations are permitted on an &lt;code&gt;unknown&lt;/code&gt; without first asserting or narrowing to a more specific type.</source>
          <target state="translated">TypeScript 3.0에는 &lt;code&gt;unknown&lt;/code&gt; 새로운 최상위 유형이 도입되었습니다 . &lt;code&gt;unknown&lt;/code&gt; 의 형태 보증 대응입니다 &lt;code&gt;any&lt;/code&gt; . 뭐든에 할당 할 것입니다 &lt;code&gt;unknown&lt;/code&gt; ,하지만 &lt;code&gt;unknown&lt;/code&gt; 아무것도에 할당 할 것이 아니라 자신과 &lt;code&gt;any&lt;/code&gt; 종류의 주장 또는 제어 흐름을 기반으로 축소하지 않고. 마찬가지로, 보다 구체적인 유형을 먼저 주장하거나 좁히지 않으면 &lt;code&gt;unknown&lt;/code&gt; 없는 작업이 허용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7978444d69de42e59647fdd6e697c61c835aefcc" translate="yes" xml:space="preserve">
          <source>TypeScript 3.1</source>
          <target state="translated">TypeScript 3.1</target>
        </trans-unit>
        <trans-unit id="277efbe36e840571109f3bbb5578c95d9d3c2d0f" translate="yes" xml:space="preserve">
          <source>TypeScript 3.1 brings the ability to define properties on function declarations and &lt;code&gt;const&lt;/code&gt;-declared functions, simply by assigning to properties on these functions in the same scope. This allows us to write canonical JavaScript code without resorting to &lt;code&gt;namespace&lt;/code&gt; hacks. For example:</source>
          <target state="translated">TypeScript 3.1은 단순히 동일한 범위에서 이러한 함수의 속성에 할당하여 함수 선언 및 &lt;code&gt;const&lt;/code&gt; 선언 함수에 대한 속성을 정의하는 기능을 제공합니다 . 이를 통해 &lt;code&gt;namespace&lt;/code&gt; 해킹에 의존하지 않고 표준 JavaScript 코드를 작성할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b9f00fd1052d436127e4de48e371112ca1399051" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2</source>
          <target state="translated">TypeScript 3.2</target>
        </trans-unit>
        <trans-unit id="1bd9c97a859cbb3246a80b48f6fdb33c3666de34" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2 also allows destructuring a rest binding from a generic variable. This is achieved by using the predefined &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Exclude&lt;/code&gt; helper types from &lt;code&gt;lib.d.ts&lt;/code&gt;, and using the generic type in question as well as the names of the other bindings in the destructuring pattern.</source>
          <target state="translated">TypeScript 3.2를 사용하면 일반 변수에서 나머지 바인딩을 제거 할 수도 있습니다. 이것은 &lt;code&gt;lib.d.ts&lt;/code&gt; 에서 사전 정의 된 &lt;code&gt;Pick&lt;/code&gt; 및 &lt;code&gt;Exclude&lt;/code&gt; 헬퍼 유형을 사용하고 해당 일반 유형과 파괴 패턴의 다른 바인딩 이름을 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="32739636ab98224be8b965eab8472c294e08c8bd" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2 introduces a new &lt;code&gt;--strictBindCallApply&lt;/code&gt; compiler option (in the &lt;code&gt;--strict&lt;/code&gt; family of options) with which the &lt;code&gt;bind&lt;/code&gt;, &lt;code&gt;call&lt;/code&gt;, and &lt;code&gt;apply&lt;/code&gt; methods on function objects are strongly typed and strictly checked.</source>
          <target state="translated">타이프 라이터 3.2을 소개합니다 새로운 &lt;code&gt;--strictBindCallApply&lt;/code&gt; 합니다 (에서 컴파일러 옵션 &lt;code&gt;--strict&lt;/code&gt; 옵션 세대) 어느와 &lt;code&gt;bind&lt;/code&gt; , &lt;code&gt;call&lt;/code&gt; 및 &lt;code&gt;apply&lt;/code&gt; 함수 객체의 메소드가 강력하게 형식화하고 엄격하게 검사합니다.</target>
        </trans-unit>
        <trans-unit id="b0c6e2bed7992d15f04fd899cadd250b20a960e6" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2 makes narrowing easier by relaxing rules for what it considers a discriminant property. Common properties of unions are now considered discriminants as long as they contain &lt;em&gt;some&lt;/em&gt; singleton type (e.g. a string literal, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;), and they contain no generics.</source>
          <target state="translated">TypeScript 3.2는 판별 속성으로 간주되는 규칙을 완화하여 좁히기가 더 쉬워집니다. 여기에 포함으로 노동 조합의 일반적인 특성은 이제 긴으로 판별 식을 고려하는 &lt;em&gt;일부&lt;/em&gt; 싱글 타입 (예를 들어, 문자열 리터럴, &lt;code&gt;null&lt;/code&gt; , 또는 &lt;code&gt;undefined&lt;/code&gt; ), 그들은 어떤 제네릭을 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a26700dbb32ecd2b75ac980f07316d21f373a07" translate="yes" xml:space="preserve">
          <source>TypeScript 3.2 now resolves &lt;code&gt;tsconfig.json&lt;/code&gt;s from &lt;code&gt;node_modules&lt;/code&gt;. When using a bare path for the &lt;code&gt;&quot;extends&quot;&lt;/code&gt; field in &lt;code&gt;tsconfig.json&lt;/code&gt;, TypeScript will dive into &lt;code&gt;node_modules&lt;/code&gt; packages for us.</source>
          <target state="translated">타이프 라이터 3.2 지금 해결 &lt;code&gt;tsconfig.json&lt;/code&gt; 에서들 &lt;code&gt;node_modules&lt;/code&gt; . &lt;code&gt;tsconfig.json&lt;/code&gt; 의 &lt;code&gt;&quot;extends&quot;&lt;/code&gt; 필드에 베어 경로를 사용하면 TypeScript가 &lt;code&gt;node_modules&lt;/code&gt; 우리를 위해 node_modules 패키지 합니다.</target>
        </trans-unit>
        <trans-unit id="cfd2b961db2e8cd46070f763e5c724b34d770631" translate="yes" xml:space="preserve">
          <source>TypeScript 3.3</source>
          <target state="translated">TypeScript 3.3</target>
        </trans-unit>
        <trans-unit id="151f809570316cd705748f077714354101e09c3c" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4</source>
          <target state="translated">TypeScript 3.4</target>
        </trans-unit>
        <trans-unit id="289b2ef5b5dba27b6f9d27a73f1f934655330ac2" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 also introduces new support for &lt;code&gt;readonly&lt;/code&gt; tuples. We can prefix any tuple type with the &lt;code&gt;readonly&lt;/code&gt; keyword to make it a &lt;code&gt;readonly&lt;/code&gt; tuple, much like we now can with array shorthand syntax. As you might expect, unlike ordinary tuples whose slots could be written to, &lt;code&gt;readonly&lt;/code&gt; tuples only permit reading from those positions.</source>
          <target state="translated">TypeScript 3.4에는 &lt;code&gt;readonly&lt;/code&gt; 튜플에 대한 새로운 지원도 도입되었습니다 . 튜플 유형 앞에 &lt;code&gt;readonly&lt;/code&gt; 키워드를 &lt;code&gt;readonly&lt;/code&gt; 튜플 로 만들 수 있습니다. 예상대로 슬롯을 쓸 수있는 일반 튜플과 달리 &lt;code&gt;readonly&lt;/code&gt; 튜플은 해당 위치에서 허용합니다.</target>
        </trans-unit>
        <trans-unit id="d5ae4e4e2dd524eb742ca067c90d1124fa510b9b" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 can now produce generic function types when inference from other generic functions produces free type variables for inferences. This means many function composition patterns now work better in 3.4.</source>
          <target state="translated">TypeScript 3.4는 이제 다른 일반 함수에서 유추하여 자유 형식 변수를 유추 할 때 일반 함수 유형을 생성 할 수 있습니다. 이는 많은 기능 구성 패턴이 3.4에서 더 잘 작동 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="bf09bd81476b0409b652aa37d69d0d04e6689320" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 introduces a new construct for literal values called &lt;em&gt;&lt;code&gt;const&lt;/code&gt;&lt;/em&gt; assertions. Its syntax is a type assertion with &lt;code&gt;const&lt;/code&gt; in place of the type name (e.g. &lt;code&gt;123 as const&lt;/code&gt;). When we construct new literal expressions with &lt;code&gt;const&lt;/code&gt; assertions, we can signal to the language that</source>
          <target state="translated">TypeScript 3.4에는 &lt;em&gt; &lt;code&gt;const&lt;/code&gt; &lt;/em&gt; 어설 션 이라는 리터럴 값에 대한 새로운 구성이 도입되었습니다 . 구문은 형식 이름 대신 &lt;code&gt;const&lt;/code&gt; 를 사용 하는 형식 명제입니다 (예 : &lt;code&gt;123 as const&lt;/code&gt; ). &lt;code&gt;const&lt;/code&gt; 어설 션을 사용 하여 새로운 리터럴 표현식을 만들 때 언어에 신호를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d6b24572a67a82fae359fdfff1468ec35fb0de9" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 introduces a new flag called &lt;code&gt;--incremental&lt;/code&gt; which tells TypeScript to save information about the project graph from the last compilation. The next time TypeScript is invoked with &lt;code&gt;--incremental&lt;/code&gt;, it will use that information to detect the least costly way to type-check and emit changes to your project.</source>
          <target state="translated">3.4 소개합니다 타이프 라이터라는 새로운 플래그 &lt;code&gt;--incremental&lt;/code&gt; 타이프를 알려줍니다 마지막 편집에서 프로젝트 그래프에 대한 정보를 저장합니다. 다음에 --incremental을 사용하여 &lt;code&gt;--incremental&lt;/code&gt; 호출 할 때 하면 해당 정보를 사용하여 가장 값 비싼 방식으로 프로젝트를 확인하고 변경 내용을 프로젝트에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ac5af210d9695056d6101c62263f01f5967d4e08" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 introduces a new syntax for &lt;code&gt;ReadonlyArray&lt;/code&gt; using a new &lt;code&gt;readonly&lt;/code&gt; modifier for array types.</source>
          <target state="translated">TypeScript 3.4는 배열 유형에 새로운 &lt;code&gt;readonly&lt;/code&gt; 수정자를 사용하여 &lt;code&gt;ReadonlyArray&lt;/code&gt; 에 대한 새로운 구문을 도입했습니다 .</target>
        </trans-unit>
        <trans-unit id="12a10c24cba59cb68af585f1698de8ae3445244e" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 introduces support for type-checking ECMAScript&amp;rsquo;s new &lt;code&gt;globalThis&lt;/code&gt; - a global variable that, well, refers to the global scope. Unlike the above solutions, &lt;code&gt;globalThis&lt;/code&gt; provides a standard way for accessing the global scope which can be used across different environments.</source>
          <target state="translated">TypeScript 3.4는 ECMAScript의 새로운 &lt;code&gt;globalThis&lt;/code&gt; 를 확인하는 형식 검사를 지원합니다 . 이는 전역 범위를 나타내는 전역 변수입니다. 위의 솔루션과 달리 &lt;code&gt;globalThis&lt;/code&gt; 은 다양한 환경에서 사용할 수있는 글로벌 범위에 액세스하는 표준 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f91b4dd92032cff1d431b2484ffb02c538b2840a" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 makes it a little bit easier to use read-only array-like types.</source>
          <target state="translated">TypeScript 3.4를 사용하면 읽기 전용 배열과 비슷한 유형을 조금 더 쉽게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ab9e17f2ce04fc3d04ccc515b149cf9aa3aa203" translate="yes" xml:space="preserve">
          <source>TypeScript 3.4 produces the type</source>
          <target state="translated">TypeScript 3.4는 유형을 생성합니다</target>
        </trans-unit>
        <trans-unit id="10f518faa467d8e0e2925a31d9b4b672b9c2e19b" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5</source>
          <target state="translated">TypeScript 3.5</target>
        </trans-unit>
        <trans-unit id="359b79f7544026e6404a7f5dc527aa3cfdbf0be7" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 contains certain optimizations over TypeScript 3.4 for type-checking more efficiently. These improvements are significantly more pronounced in editor scenarios where type-checking drives operations like code completion lists.</source>
          <target state="translated">TypeScript 3.5에는 형식 검사를보다 효율적으로 수행하기 위해 TypeScript 3.4에 대한 특정 최적화가 포함되어 있습니다. 이러한 개선 사항은 형식 확인이 코드 완성 목록과 같은 작업을 수행하는 편집기 시나리오에서 훨씬 더 두드러집니다.</target>
        </trans-unit>
        <trans-unit id="a6938b07665eedd653729021d3cce39e74883c08" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 generalizes this behavior to work on constructor functions as well.</source>
          <target state="translated">TypeScript 3.5는 생성자 함수에서도 작동하도록이 동작을 일반화합니다.</target>
        </trans-unit>
        <trans-unit id="a73d70bff8d5fc727c0bd14cb107e1c1b473750e" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 improves on 3.4&amp;rsquo;s &lt;code&gt;--incremental&lt;/code&gt; build mode, by saving information about how the state of the world was calculated - compiler settings, why files were looked up, where files were found, etc. In scenarios involving hundreds of projects using TypeScript&amp;rsquo;s project references in &lt;code&gt;--build&lt;/code&gt; mode, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/31101&quot;&gt;we&amp;rsquo;ve found that the amount of time rebuilding can be reduced by as much as 68% compared to TypeScript 3.4&lt;/a&gt;!</source>
          <target state="translated">TypeScript 3.5는 세계 상태 계산 방식-컴파일러 설정, 파일 검색 이유, 파일 위치 등의 정보를 저장 하여 3.4의 &lt;code&gt;--incremental&lt;/code&gt; 빌드 모드를 개선합니다 . TypeScript를 사용하여 수백 개의 프로젝트가 관련된 시나리오 &lt;code&gt;--build&lt;/code&gt; 모드의 프로젝트 참조에서 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/31101&quot;&gt;TypeScript 3.4에 비해 재 구축 시간을 68 % 줄일 수 있음을 발견했습니다&lt;/a&gt; !</target>
        </trans-unit>
        <trans-unit id="8870d39de72c9538f7b989e9c665dcecc3f792f4" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 introduces several optimizations around type-checking and incremental builds.</source>
          <target state="translated">TypeScript 3.5는 유형 검사 및 증분 빌드에 대한 여러 최적화를 소개합니다.</target>
        </trans-unit>
        <trans-unit id="a67354830dc88bba666b8a01f15200fc520abe67" translate="yes" xml:space="preserve">
          <source>TypeScript 3.5 introduces the new &lt;code&gt;Omit&lt;/code&gt; helper type, which creates a new type with some properties dropped from the original.</source>
          <target state="translated">TypeScript 3.5에는 새로운 &lt;code&gt;Omit&lt;/code&gt; 도우미 유형이 도입 되어 일부 속성이 원본에서 삭제 된 새로운 유형을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="860169965c68715ea7e25ddf2b4ae280a663fdd6" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6</source>
          <target state="translated">TypeScript 3.6</target>
        </trans-unit>
        <trans-unit id="43040204a5b205b20ce117e9abeba80afa37f954" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 contains better support for Unicode characters in identifiers when emitting to ES2015 and later targets.</source>
          <target state="translated">TypeScript 3.6에는 ES2015 이상 대상으로 방출 할 때 식별자에서 유니 코드 문자를 더 잘 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bd36d48e4d1462dffb6c3c392323087bb23fcc1d" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 introduces a new &lt;code&gt;__spreadArrays&lt;/code&gt; helper to accurately model what happens in ECMAScript 2015 in older targets outside of &lt;code&gt;--downlevelIteration&lt;/code&gt;. &lt;code&gt;__spreadArrays&lt;/code&gt; is also available in &lt;a href=&quot;https://github.com/Microsoft/tslib/&quot;&gt;tslib&lt;/a&gt;.</source>
          <target state="translated">타이프는 3.6 소개하고 새로운 &lt;code&gt;__spreadArrays&lt;/code&gt; 을 정확하게에 도우미가 외부의 이전 대상에서 ECMAScript를 2015 년에 무슨 일 모델 &lt;code&gt;--downlevelIteration&lt;/code&gt; . &lt;code&gt;__spreadArrays&lt;/code&gt; 는 도 번역되어 있습니다 &lt;a href=&quot;https://github.com/Microsoft/tslib/&quot;&gt;tslib&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33cd49dc97acf9b88dbc38ffefb886129306a9c4" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 introduces some improvements for when &lt;code&gt;Promise&lt;/code&gt;s are mis-handled.</source>
          <target state="translated">TypeScript 3.6에는 &lt;code&gt;Promise&lt;/code&gt; 가 잘못 처리 될 때 일부 개선 된 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="74c9e7c03722726e70a2ffe1f76f8a558869d112" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 introduces stricter checking for iterators and generator functions. In earlier versions, users of generators had no way to differentiate whether a value was yielded or returned from a generator.</source>
          <target state="translated">TypeScript 3.6에는 반복기 및 생성기 기능에 대한 엄격한 검사가 도입되었습니다. 이전 버전에서는 생성기 사용자가 값을 생성했는지 또는 생성기에서 반환했는지 구분할 방법이 없었습니다.</target>
        </trans-unit>
        <trans-unit id="81aa3de148cf46d845b3cd5b3e434a89e256c4c6" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 is now a bit smarter about looking at your existing imports before deciding on how to auto-import other modules. You can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32684&quot;&gt;see more details in the original pull request here&lt;/a&gt;.</source>
          <target state="translated">TypeScript 3.6은 이제 다른 모듈을 자동으로 가져 오는 방법을 결정하기 전에 기존 가져 오기를 살펴 보는 데 조금 더 현명합니다. 당신은 할 수 있습니다 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32684&quot;&gt;여기에 원래 풀 요청에서 자세한 내용을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="314b10ba05a1161535cb19963756c6c11ff953ee" translate="yes" xml:space="preserve">
          <source>TypeScript 3.6 supports transforming &lt;code&gt;import.meta&lt;/code&gt; to &lt;code&gt;context.meta&lt;/code&gt; when your &lt;code&gt;module&lt;/code&gt; target is set to &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">TypeScript 3.6은 &lt;code&gt;module&lt;/code&gt; 대상이 &lt;code&gt;system&lt;/code&gt; 으로 설정된 경우 &lt;code&gt;import.meta&lt;/code&gt; 를 &lt;code&gt;context.meta&lt;/code&gt; 로 변환 하는 것을 지원 합니다 .</target>
        </trans-unit>
        <trans-unit id="5f7ed4364cfc54d058bc3677d8dbecd5e3827aa5" translate="yes" xml:space="preserve">
          <source>TypeScript 3.7</source>
          <target state="translated">TypeScript 3.7</target>
        </trans-unit>
        <trans-unit id="27083dbf128c773c5403938ac6b066e57d56ab6a" translate="yes" xml:space="preserve">
          <source>TypeScript 3.7 allows us to add &lt;code&gt;// @ts-nocheck&lt;/code&gt; comments to the top of TypeScript files to disable semantic checks. Historically this comment was only respected in JavaScript source files in the presence of &lt;code&gt;checkJs&lt;/code&gt;, but we&amp;rsquo;ve expanded support to TypeScript files to make migrations easier for all users.</source>
          <target state="translated">TypeScript 3.7을 사용하면 시맨틱 검사를 비활성화 하기 위해 &lt;code&gt;// @ts-nocheck&lt;/code&gt; 주석을 TypeScript 파일의 맨 위에 추가 할 수 있습니다 . 역사적으로이 주석은 &lt;code&gt;checkJs&lt;/code&gt; 있는 JavaScript 소스 파일에서만 존중 되었지만 모든 사용자가 쉽게 마이그레이션 할 수 있도록 TypeScript 파일에 대한 지원을 확장했습니다.</target>
        </trans-unit>
        <trans-unit id="79e6c0e6d51157bb20e26a7e863eb63b56787312" translate="yes" xml:space="preserve">
          <source>TypeScript Documentation</source>
          <target state="translated">TypeScript 설명서</target>
        </trans-unit>
        <trans-unit id="403fb75c6290c33e1ee26eea036308b48aa46bfe" translate="yes" xml:space="preserve">
          <source>TypeScript Version: If you installed with npm: &lt;code&gt;/usr/local/lib/node_modules/typescript/lib&lt;/code&gt;</source>
          <target state="translated">TypeScript 버전 : npm과 함께 설치 한 경우 : &lt;code&gt;/usr/local/lib/node_modules/typescript/lib&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9bf97b3981273152e80b422491273038dfba6f7" translate="yes" xml:space="preserve">
          <source>TypeScript Version: If you installed with npm: &lt;code&gt;C:\Users\USERNAME\AppData\Roaming\npm\node_modules\typescript\lib&lt;/code&gt;</source>
          <target state="translated">TypeScript 버전 : npm과 함께 설치 한 경우 : &lt;code&gt;C:\Users\USERNAME\AppData\Roaming\npm\node_modules\typescript\lib&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9786e84531c7e9e6709c98099bfd87c8dde49dc4" translate="yes" xml:space="preserve">
          <source>TypeScript adds a new triple-slash-reference directive (&lt;code&gt;/// &amp;lt;reference lib=&quot;name&quot; /&amp;gt;&lt;/code&gt;), allowing a file to explicitly include an existing built-in &lt;em&gt;lib&lt;/em&gt; file.</source>
          <target state="translated">TypeScript는 새로운 삼중 슬래시 참조 지시문 ( &lt;code&gt;/// &amp;lt;reference lib=&quot;name&quot; /&amp;gt;&lt;/code&gt; )을 추가하여 파일에 기존의 내장 &lt;em&gt;lib&lt;/em&gt; 파일 을 명시 적으로 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="627afeb35305a2b7b628a49f47ad27ec0e7523cd" translate="yes" xml:space="preserve">
          <source>TypeScript also has numeric literal types.</source>
          <target state="translated">TypeScript에는 숫자 리터럴 유형도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f845ee328e4da8982a9cb87a1d1fe60de76cba85" translate="yes" xml:space="preserve">
          <source>TypeScript can reports errors for fall-through cases in switch statement where the case clause is non-empty. This check is turned &lt;em&gt;off&lt;/em&gt; by default, and can be enabled using &lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt;.</source>
          <target state="translated">TypeScript는 case 절이 비어 있지 않은 switch 문에서 대체 사례에 대한 오류를보고 할 수 있습니다. 이 검사는 기본적 으로 &lt;em&gt;해제&lt;/em&gt; 되어 있으며 &lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt; 를 사용하여 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3883e486fe04d1f7d13e0ad9f1b9eb0d552664b9" translate="yes" xml:space="preserve">
          <source>TypeScript comes with a &lt;code&gt;ReadonlyArray&amp;lt;T&amp;gt;&lt;/code&gt; type that is the same as &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; with all mutating methods removed, so you can make sure you don&amp;rsquo;t change your arrays after creation:</source>
          <target state="translated">TypeScript에는 모든 mutating 메서드가 제거 된 &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; 와 동일한 &lt;code&gt;ReadonlyArray&amp;lt;T&amp;gt;&lt;/code&gt; 유형이 제공 되므로 생성 후 배열을 변경하지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c46782ad571ccfa1375c328c08d6d8a52aae9f4e" translate="yes" xml:space="preserve">
          <source>TypeScript comes with certain checks to give you more safety and analysis of your program. Once you&amp;rsquo;ve converted your codebase to TypeScript, you can start enabling these checks for greater safety.</source>
          <target state="translated">TypeScript에는 프로그램을보다 안전하고 분석하기 위해 특정 검사가 제공됩니다. 코드베이스를 TypeScript로 변환하면 안전성을 높이기 위해 이러한 검사를 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="982bd44a5cc8b5512117571aef28b0ebcb320b22" translate="yes" xml:space="preserve">
          <source>TypeScript decorators are based on the &lt;a href=&quot;https://github.com/wycats/javascript-decorators&quot;&gt;ES7 decorator proposal&lt;/a&gt;.</source>
          <target state="translated">TypeScript 데코레이터는 &lt;a href=&quot;https://github.com/wycats/javascript-decorators&quot;&gt;ES7 데코레이터 제안을&lt;/a&gt; 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="250cd79d3d3268a25a6551d40fbaae96eebab0e3" translate="yes" xml:space="preserve">
          <source>TypeScript did not have a type that represents the non-primitive type, i.e. any thing that is not &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;symbol&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;. Enter the new &lt;code&gt;object&lt;/code&gt; type.</source>
          <target state="translated">TypeScript에는 기본이 아닌 유형, 즉 &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;boolean&lt;/code&gt; , &lt;code&gt;symbol&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 가 아닌 유형을 나타내는 유형이 없습니다 . 새 &lt;code&gt;object&lt;/code&gt; 유형을 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="fada45685495c730f9a9cc2a93bbb49026908546" translate="yes" xml:space="preserve">
          <source>TypeScript doesn&amp;rsquo;t exist in a vacuum. It was built with the JavaScript ecosystem in mind, and a lot of JavaScript exists today. Converting a JavaScript codebase over to TypeScript is, while somewhat tedious, usually not challenging. In this tutorial, we&amp;rsquo;re going to look at how you might start out. We assume you&amp;rsquo;ve read enough of the handbook to write new TypeScript code.</source>
          <target state="translated">TypeScript가 진공 상태에 없습니다. JavaScript 생태계를 염두에두고 구축되었으며 오늘날 많은 JavaScript가 존재합니다. JavaScript 코드베이스를 TypeScript로 변환하는 것은 다소 지루하지만 일반적으로 어렵지 않습니다. 이 자습서에서는 시작 방법을 살펴 보겠습니다. 새로운 TypeScript 코드를 작성하기에 충분한 핸드북을 읽었다 고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="1c8cdf286fbbcc4e7b49af3039a27393efcafa25" translate="yes" xml:space="preserve">
          <source>TypeScript files will start out in your &lt;code&gt;src&lt;/code&gt; folder, run through the TypeScript compiler and end up in &lt;code&gt;dist&lt;/code&gt;.</source>
          <target state="translated">TypeScript 파일은 &lt;code&gt;src&lt;/code&gt; 폴더 에서 시작 하여 TypeScript 컴파일러를 통해 실행되고 &lt;code&gt;dist&lt;/code&gt; 로 끝납니다 .</target>
        </trans-unit>
        <trans-unit id="59c18fee8487cdeda3b2f34b4ca8e8a543f5cab1" translate="yes" xml:space="preserve">
          <source>TypeScript files will start out in your &lt;code&gt;src&lt;/code&gt; folder, run through the TypeScript compiler, then webpack, and end up in a &lt;code&gt;main.js&lt;/code&gt; file in &lt;code&gt;dist&lt;/code&gt;. Any components that we write will go in the &lt;code&gt;src/components&lt;/code&gt; folder.</source>
          <target state="translated">TypeScript 파일은 &lt;code&gt;src&lt;/code&gt; 폴더 에서 시작 하여 TypeScript 컴파일러를 통해 실행 한 다음 webpack을 거쳐 &lt;code&gt;dist&lt;/code&gt; 의 &lt;code&gt;main.js&lt;/code&gt; 파일로 끝납니다 . 우리가 작성하는 모든 구성 요소는 &lt;code&gt;src/components&lt;/code&gt; 폴더에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a367ff679df04f05c3c34e6560229bdc2557a732" translate="yes" xml:space="preserve">
          <source>TypeScript has always compared parameters in a bivariant way. There are a number of reasons for this, but by-and-large this was not been a huge issue for our users until we saw some of the adverse effects it had with &lt;code&gt;Promise&lt;/code&gt;s and &lt;code&gt;Observable&lt;/code&gt;s.</source>
          <target state="translated">TypeScript는 항상 이변 량 방식으로 매개 변수를 비교했습니다. 여기에는 여러 가지 이유가 있지만, &lt;code&gt;Promise&lt;/code&gt; 및 &lt;code&gt;Observable&lt;/code&gt; 의 부작용을 볼 때까지는 사용자에게 큰 문제가되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="db02a42b5c74e823760580106f119d33d32acab0" translate="yes" xml:space="preserve">
          <source>TypeScript has traditionally been overly strict about how you can import modules. This was to avoid typos and prevent users from using modules incorrectly.</source>
          <target state="translated">TypeScript는 전통적으로 모듈을 가져 오는 방법에 대해 지나치게 엄격했습니다. 이는 오타를 피하고 사용자가 모듈을 잘못 사용하지 못하게하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b5b5002b156ed20abcb2373b3f1a34e30ef133d5" translate="yes" xml:space="preserve">
          <source>TypeScript has two special types, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;, that have the values null and undefined respectively. We mentioned these briefly in &lt;a href=&quot;basic-types&quot;&gt;the Basic Types section&lt;/a&gt;. By default, the type checker considers &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; assignable to anything. Effectively, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are valid values of every type. That means it&amp;rsquo;s not possible to &lt;em&gt;stop&lt;/em&gt; them from being assigned to any type, even when you would like to prevent it. The inventor of &lt;code&gt;null&lt;/code&gt;, Tony Hoare, calls this his &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_pointer#History&quot;&gt;&amp;ldquo;billion dollar mistake&amp;rdquo;&lt;/a&gt;.</source>
          <target state="translated">TypeScript에는 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 의 두 가지 특수 유형 이 있으며 각각 null 및 undefined 값을 갖습니다. 우리는 이것을 &lt;a href=&quot;basic-types&quot;&gt;기본 유형 섹션&lt;/a&gt; 에서 간단히 언급했습니다 . 기본적으로 형식 검사기는 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 할당 할 수있는 것으로 간주 합니다. 사실상, &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 는 모든 유형의 유효한 값입니다. 즉,이 수는 없습니다 &lt;em&gt;중지&lt;/em&gt; 당신이 그것을 방지하고자하는 경우에도, 모든 유형에 할당되는 것을. &lt;code&gt;null&lt;/code&gt; 발명가 인 Tony Hoare는 이것을 &lt;a href=&quot;https://en.wikipedia.org/wiki/Null_pointer#History&quot;&gt;&quot;십억 달러의 실수&quot;라고&lt;/a&gt; 부릅니다 .</target>
        </trans-unit>
        <trans-unit id="75fc1f90351ac73e35a5f3f576d18314c46dc6c2" translate="yes" xml:space="preserve">
          <source>TypeScript has two special types, Null and Undefined, that have the values &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; respectively. Previously it was not possible to explicitly name these types, but &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; may now be used as type names regardless of type checking mode.</source>
          <target state="translated">TypeScript에는 Null과 Undefined라는 두 가지 특수 유형이 있으며 각각 &lt;code&gt;null&lt;/code&gt; 과 &lt;code&gt;undefined&lt;/code&gt; 값을 갖습니다 . 이전에는 이러한 유형의 이름을 명시 적으로 지정할 수 없었지만 이제 유형 검사 모드에 관계없이 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 를 유형 이름으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="669ae0c383f0ebc9a1b71a33795f2fba316ff636" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes</source>
          <target state="translated">5 분 안에 TypeScript</target>
        </trans-unit>
        <trans-unit id="452bd92ef7047873dae5fa9a26760186598678c6" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Building your first TypeScript file</source>
          <target state="translated">5 분 안에 TypeScript : 첫 번째 TypeScript 파일 작성</target>
        </trans-unit>
        <trans-unit id="cfe56778efe914c509395d743856f638e0b2dc80" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Classes</source>
          <target state="translated">5 분 안에 TypeScript : 클래스</target>
        </trans-unit>
        <trans-unit id="66f6d1b030c2c31817cfd629aeaf4e9f8e001440" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Compiling your code</source>
          <target state="translated">5 분 안에 TypeScript : 코드 컴파일</target>
        </trans-unit>
        <trans-unit id="64b3883005157157bc3e05fd1909ad05a7782093" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Installing TypeScript</source>
          <target state="translated">5 분 안에 TypeScript : TypeScript 설치</target>
        </trans-unit>
        <trans-unit id="679437aa54596d7921f489403e44c2b30fef5aed" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Interfaces</source>
          <target state="translated">5 분 안에 TypeScript : 인터페이스</target>
        </trans-unit>
        <trans-unit id="520fec1d849d26fa3641ec76d5fda0df2e56b07e" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Running your TypeScript web app</source>
          <target state="translated">5 분 안에 TypeScript : TypeScript 웹 앱 실행</target>
        </trans-unit>
        <trans-unit id="6a574132fb48839d07c1e73530345fd9189655e2" translate="yes" xml:space="preserve">
          <source>TypeScript in 5 minutes: Type annotations</source>
          <target state="translated">5 분 안에 TypeScript : 타입 주석</target>
        </trans-unit>
        <trans-unit id="fa27fdf7da61b594edc2419147ebeb6293bab089" translate="yes" xml:space="preserve">
          <source>TypeScript includes experimental support for emitting certain types of metadata for declarations that have decorators. To enable this experimental support, you must set the &lt;code&gt;emitDecoratorMetadata&lt;/code&gt; compiler option either on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">TypeScript에는 데코레이터가있는 선언에 대해 특정 유형의 메타 데이터를 내보내는 실험적인 지원이 포함됩니다. 이 실험 지원을 사용하려면 명령 행 또는 &lt;code&gt;tsconfig.json&lt;/code&gt; 에서 &lt;code&gt;emitDecoratorMetadata&lt;/code&gt; 컴파일러 옵션을 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="65097970997af32f38424bf7e3969825b3d282b6" translate="yes" xml:space="preserve">
          <source>TypeScript injects a handful of helper functions such as &lt;code&gt;__extends&lt;/code&gt; for inheritance, &lt;code&gt;__assign&lt;/code&gt; for spread operator in object literals and JSX elements, and &lt;code&gt;__awaiter&lt;/code&gt; for async functions.</source>
          <target state="translated">TypeScript 는 상속을 위한 &lt;code&gt;__assign&lt;/code&gt; , 객체 리터럴 및 JSX 요소의 스프레드 연산자를 위한 &lt;code&gt;__awaiter&lt;/code&gt; , 비동기 함수를위한 &lt;code&gt;__extends&lt;/code&gt; 와 같은 소수의 도우미 함수를 주입 합니다.</target>
        </trans-unit>
        <trans-unit id="4865203c87f3f94d8f8566ed718390d0119234fb" translate="yes" xml:space="preserve">
          <source>TypeScript is a structural type system. When we compare two different types, regardless of where they came from, if the types of all members are compatible, then we say the types themselves are compatible.</source>
          <target state="translated">TypeScript는 구조적 유형 시스템입니다. 출처에 관계없이 두 가지 유형을 비교할 때 모든 구성원의 유형이 호환 가능하면 유형 자체가 호환 가능하다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="9e5933fe400768d081ab73894e4f792a102e8c04" translate="yes" xml:space="preserve">
          <source>TypeScript is now smart enough to detect whether your file uses semicolons when applying these sorts of edits. If your file generally lacks semicolons, TypeScript won&amp;rsquo;t add one.</source>
          <target state="translated">TypeScript는 이제 이러한 종류의 편집을 적용 할 때 파일에서 세미콜론을 사용하는지 여부를 감지 할 수있을 정도로 똑똑합니다. 파일에 일반적으로 세미콜론이 없으면 TypeScript는 세미콜론을 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c0716da88bf8553ba341ae10829c8d80565f07b2" translate="yes" xml:space="preserve">
          <source>TypeScript might compile this down to something like the the following JavaScript:</source>
          <target state="translated">TypeScript는 이것을 다음 JavaScript와 같이 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32fed70cd34feef29d0649f498d61da78cbda0ab" translate="yes" xml:space="preserve">
          <source>TypeScript now only strictly enforces the visibility of types in modules if the &lt;code&gt;--declaration&lt;/code&gt; flag is provided. This is very useful for Angular scenarios, for example:</source>
          <target state="translated">경우 타이프 라이터는 이제 엄격 모듈 타입의 가시성을 적용 &lt;code&gt;--declaration&lt;/code&gt; 의 플래그가 제공됩니다. 이것은 Angular 시나리오에 매우 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf627cab04633b795ac087dea296a4bdb609bc4d" translate="yes" xml:space="preserve">
          <source>TypeScript now supports &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;Function components&lt;/a&gt;. These are lightweight components that easily compose other components:</source>
          <target state="translated">TypeScript는 이제 &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;기능 구성 요소를&lt;/a&gt; 지원합니다 . 이들은 다른 구성 요소를 쉽게 구성하는 경량 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="52d1c2115b1983ad21a42bf4d3fb47956062ab0c" translate="yes" xml:space="preserve">
          <source>TypeScript now supports ES6 template strings. These are an easy way to embed arbitrary expressions in strings:</source>
          <target state="translated">TypeScript는 이제 ES6 템플릿 문자열을 지원합니다. 다음은 문자열에 임의의 표현식을 포함시키는 쉬운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="dca2d3b95767ef524c8d3421355c36053ab3819a" translate="yes" xml:space="preserve">
          <source>TypeScript now supports asynchronous functions for engines that have native support for ES6 generators, e.g. Node v4 and above. Asynchronous functions are prefixed with the &lt;code&gt;async&lt;/code&gt; keyword; &lt;code&gt;await&lt;/code&gt; suspends the execution until an asynchronous function return promise is fulfilled and unwraps the value from the &lt;code&gt;Promise&lt;/code&gt; returned.</source>
          <target state="translated">TypeScript는 이제 ES6 생성기 (예 : Node v4 이상)를 기본적으로 지원하는 엔진의 비동기 기능을 지원합니다. 비동기 함수는 &lt;code&gt;async&lt;/code&gt; 키워드 로 시작 합니다. &lt;code&gt;await&lt;/code&gt; 는 비동기 함수 리턴 약속이 이행 될 때까지 실행을 일시 중단하고 리턴 된 &lt;code&gt;Promise&lt;/code&gt; 에서 값을 랩 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="0e7958ec88d9f0faef067488c643d885da64e7bf" translate="yes" xml:space="preserve">
          <source>TypeScript now tries to unify type parameters when comparing two single-signature types. As a result, you&amp;rsquo;ll get stricter checks when relating two generic signatures, and may catch some bugs.</source>
          <target state="translated">TypeScript는 이제 두 개의 단일 서명 유형을 비교할 때 유형 매개 변수를 통합하려고 시도합니다. 결과적으로 두 개의 일반 서명과 관련하여 더 엄격한 검사를 받고 일부 버그를 발견 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d62273ee78dee44c5da22f4945f26ce4659fc27f" translate="yes" xml:space="preserve">
          <source>TypeScript provides several utility types to facilitate common type transformations. These utilities are available globally.</source>
          <target state="translated">TypeScript는 일반적인 유형 변환을 용이하게하기 위해 몇 가지 유틸리티 유형을 제공합니다. 이 유틸리티는 전 세계적으로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="988860fc02a853b3a27d2af5425c58bd62c2eceb" translate="yes" xml:space="preserve">
          <source>TypeScript resolves signature compatibility by seeing if any signature of the target can be invoked with the arguments of the source, &lt;em&gt;and extraneous arguments are allowed&lt;/em&gt;. This code, for example, exposes a bug only when the signature is correctly written using optional parameters:</source>
          <target state="translated">TypeScript는 소스의 인수로 대상의 서명을 호출 할 수 있고 &lt;em&gt;외부 인수가 허용&lt;/em&gt; 되는지 확인하여 서명 호환성을 해결합니다 . 예를 들어이 코드는 선택적 매개 변수를 사용하여 서명이 올바르게 작성된 경우에만 버그를 노출합니다.</target>
        </trans-unit>
        <trans-unit id="8a0c2fdfc90997d639e7e23066198c7742ba74d7" translate="yes" xml:space="preserve">
          <source>TypeScript ships with three JSX modes: &lt;code&gt;preserve&lt;/code&gt;, &lt;code&gt;react&lt;/code&gt;, and &lt;code&gt;react-native&lt;/code&gt;. These modes only affect the emit stage - type checking is unaffected. The &lt;code&gt;preserve&lt;/code&gt; mode will keep the JSX as part of the output to be further consumed by another transform step (e.g. &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;). Additionally the output will have a &lt;code&gt;.jsx&lt;/code&gt; file extension. The &lt;code&gt;react&lt;/code&gt; mode will emit &lt;code&gt;React.createElement&lt;/code&gt;, does not need to go through a JSX transformation before use, and the output will have a &lt;code&gt;.js&lt;/code&gt; file extension. The &lt;code&gt;react-native&lt;/code&gt; mode is the equivalent of &lt;code&gt;preserve&lt;/code&gt; in that it keeps all JSX, but the output will instead have a &lt;code&gt;.js&lt;/code&gt; file extension.</source>
          <target state="translated">TypeScript에는 3 가지 JSX 모드가 있습니다 : &lt;code&gt;preserve&lt;/code&gt; , &lt;code&gt;react&lt;/code&gt; , &lt;code&gt;react-native&lt;/code&gt; . 이 모드는 방출 단계에만 영향을 미치며 유형 검사는 영향을받지 않습니다. &lt;code&gt;preserve&lt;/code&gt; 출력의 일부로 JSX을 유지할 모드 또 다른 변환 단계 (예에 의해 소비 될 &lt;a href=&quot;https://babeljs.io/&quot;&gt;바벨&lt;/a&gt; ). 또한 출력의 파일 확장자 는 &lt;code&gt;.jsx&lt;/code&gt; 입니다 . &lt;code&gt;react&lt;/code&gt; 방출합니다 모드 &lt;code&gt;React.createElement&lt;/code&gt; 는 사용하기 전에 JSX 변환을 통해 갈 필요하지 않으며, 출력은 것 &lt;code&gt;.js&lt;/code&gt; 파일 확장자를. 는 &lt;code&gt;react-native&lt;/code&gt; 모드의 것과 동일 &lt;code&gt;preserve&lt;/code&gt; 모든 JSX를 유지하지만 출력은 &lt;code&gt;.js&lt;/code&gt; 파일 확장자 를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="f2cd47e8e27537ecdbea6c76c0813851141bdf88" translate="yes" xml:space="preserve">
          <source>TypeScript ships with two JSX modes: &lt;code&gt;preserve&lt;/code&gt; and &lt;code&gt;react&lt;/code&gt;.</source>
          <target state="translated">TypeScript에는 두 가지 JSX 모드 ( &lt;code&gt;preserve&lt;/code&gt; 및 &lt;code&gt;react&lt;/code&gt; )가 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="a68cb065a26c6d898de1ad77c499a5380c7336c0" translate="yes" xml:space="preserve">
          <source>TypeScript supports getters/setters as a way of intercepting accesses to a member of an object. This gives you a way of having finer-grained control over how a member is accessed on each object.</source>
          <target state="translated">TypeScript는 객체 멤버에 대한 액세스를 가로채는 방법으로 getter / setter를 지원합니다. 이를 통해 각 개체에서 멤버에 액세스하는 방법을보다 세밀하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b66debd096de5790d32615c82aeae20dd89c1b00" translate="yes" xml:space="preserve">
          <source>TypeScript treats a namespace import (i.e. &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt;) for a CommonJS/AMD/UMD module as equivalent to &lt;code&gt;const foo = require(&quot;foo&quot;)&lt;/code&gt;.Things are simple here, but they don&amp;rsquo;t work out if the primary object being imported is a primitive or a class or a function. ECMAScript spec stipulates that a namespace record is a plain object, and that a namespace import (&lt;code&gt;foo&lt;/code&gt; in the example above) is not callable, though allowed by TypeScript</source>
          <target state="translated">TypeScript는 CommonJS / AMD / UMD 모듈에 대한 네임 스페이스 가져 오기 (즉 &lt;code&gt;import * as foo from &quot;foo&quot;&lt;/code&gt; )를 &lt;code&gt;const foo = require(&quot;foo&quot;)&lt;/code&gt; 와 동일하게 처리합니다. 임포트되는 1 차 오브젝트는 기본 요소 또는 클래스 또는 함수입니다. ECMAScript는 네임 스페이스 레코드가 일반 객체이고 네임 스페이스 가져 오기 ( 위 예제에서 &lt;code&gt;foo&lt;/code&gt; )를 호출 할 수는 없지만 TypeScript에서 허용한다고 명시합니다.</target>
        </trans-unit>
        <trans-unit id="190d779979c1c225024b4faf8c71539ad6be2768" translate="yes" xml:space="preserve">
          <source>TypeScript used the &lt;code&gt;module&lt;/code&gt; keyword to define both &amp;ldquo;internal modules&amp;rdquo; and &amp;ldquo;external modules&amp;rdquo;; this has been a bit of confusion for developers new to TypeScript. &amp;ldquo;Internal modules&amp;rdquo; are closer to what most people would call a namespace; likewise, &amp;ldquo;external modules&amp;rdquo; in JS speak really just are modules now.</source>
          <target state="translated">TypeScript는 &lt;code&gt;module&lt;/code&gt; 키워드를 사용하여&amp;ldquo;내부 모듈&amp;rdquo;과&amp;ldquo;외부 모듈&amp;rdquo;을 모두 정의했습니다. TypeScript를 처음 사용하는 개발자에게는 약간의 혼란이있었습니다. &amp;ldquo;내부 모듈&amp;rdquo;은 대부분의 사람들이 네임 스페이스라고 부르는 것에 더 가깝습니다. 마찬가지로 JS의 &quot;외부 모듈&quot;은 실제로 모듈 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="1b58b6b726ed6ef37d5ab19f3e08450acedef197" translate="yes" xml:space="preserve">
          <source>TypeScript uses a file called &lt;code&gt;tsconfig.json&lt;/code&gt; for managing your project&amp;rsquo;s options, such as which files you want to include, and what sorts of checking you want to perform. Let&amp;rsquo;s create a bare-bones one for our project:</source>
          <target state="translated">TypeScript는 &lt;code&gt;tsconfig.json&lt;/code&gt; 이라는 파일을 사용합니다. 포함 할 파일 및 수행 할 검사 종류와 같은 프로젝트 옵션을 관리합니다. 프로젝트를위한 핵심적인 것을 만들어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="f56d1e973d936e7e25808ece950aef4bac63d378" translate="yes" xml:space="preserve">
          <source>TypeScript uses the &lt;a href=&quot;http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components&quot;&gt;same convention that React does&lt;/a&gt; for distinguishing between these. An intrinsic element always begins with a lowercase letter, and a value-based element always begins with an uppercase letter.</source>
          <target state="translated">TypeScript는 &lt;a href=&quot;http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components&quot;&gt;React&lt;/a&gt; 와 구별하기 위해 React와 동일한 규칙을 사용합니다 . 내장 요소는 항상 소문자로 시작하고 값 기반 요소는 항상 대문자로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="a94cd2357ef6caf93ae4025491d6f6435c0dfc38" translate="yes" xml:space="preserve">
          <source>TypeScript will also now compute enum values when possible:</source>
          <target state="translated">TypeScript는 이제 가능한 경우 열거 형 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="363493eaf871474aebe9c026f44b9b57be878dd1" translate="yes" xml:space="preserve">
          <source>TypeScript will also warn about unreachable code and labels, which you can disable with &lt;code&gt;allowUnreachableCode&lt;/code&gt; and &lt;code&gt;allowUnusedLabels&lt;/code&gt; respectively.</source>
          <target state="translated">TypeScript는 도달 할 수없는 코드 및 레이블에 대해서도 경고하며, &lt;code&gt;allowUnreachableCode&lt;/code&gt; 및 &lt;code&gt;allowUnusedLabels&lt;/code&gt; 로 각각 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8a61643ec3271fd661861cae15f39927b074e83" translate="yes" xml:space="preserve">
          <source>TypeScript will mimic the Node.js run-time resolution strategy in order to locate definition files for modules at compile-time. To accomplish this, TypeScript overlays the TypeScript source file extensions (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and &lt;code&gt;.d.ts&lt;/code&gt;) over Node&amp;rsquo;s resolution logic. TypeScript will also use a field in &lt;code&gt;package.json&lt;/code&gt; named &lt;code&gt;&quot;types&quot;&lt;/code&gt; to mirror the purpose of &lt;code&gt;&quot;main&quot;&lt;/code&gt; - the compiler will use it to find the &amp;ldquo;main&amp;rdquo; definition file to consult.</source>
          <target state="translated">TypeScript는 컴파일 타임에 모듈의 정의 파일을 찾기 위해 Node.js 런타임 해결 전략을 모방합니다. 이를 위해 TypeScript는 TypeScript 소스 파일 확장자 ( &lt;code&gt;.ts&lt;/code&gt; , &lt;code&gt;.tsx&lt;/code&gt; 및 &lt;code&gt;.d.ts&lt;/code&gt; )를 노드의 해상도 로직에 오버레이합니다 . TypeScript는 &lt;code&gt;package.json&lt;/code&gt; 에서 &lt;code&gt;&quot;types&quot;&lt;/code&gt; 라는 필드를 사용하여 &lt;code&gt;&quot;main&quot;&lt;/code&gt; 의 목적을 반영합니다 . 컴파일러는이 필드를 사용하여 참조 할 &quot;main&quot;정의 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="d20fd8b3bcedf7d11d40c55cf087585df77e7708" translate="yes" xml:space="preserve">
          <source>TypeScript will say that you can&amp;rsquo;t assign to &lt;code&gt;color&lt;/code&gt; and &lt;code&gt;volume&lt;/code&gt; because it first figured out the type of &lt;code&gt;options&lt;/code&gt; as &lt;code&gt;{}&lt;/code&gt; which doesn&amp;rsquo;t have any properties. If you instead moved the declarations into the object literal themselves, you&amp;rsquo;d get no errors:</source>
          <target state="translated">TypeScript는 처음에 &lt;code&gt;options&lt;/code&gt; 유형을 &lt;code&gt;{}&lt;/code&gt; 로 알아 냈기 때문에 &lt;code&gt;color&lt;/code&gt; 및 &lt;code&gt;volume&lt;/code&gt; 할당 할 수 없다고 말합니다. 어떤 속성을 가지고 있지 않는. 대신 선언을 객체 리터럴 자체로 옮긴 경우 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd367b77df54efafc687e3d2bce712bf9f604879" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s &lt;code&gt;--pretty&lt;/code&gt; flag can make error messages easier to read and manage. &lt;code&gt;--pretty&lt;/code&gt; now uses colors for file names, diagnostic codes, and line numbers. File names and positions are now also formatted to allow navigation in common terminals (e.g. Visual Studio Code terminal).</source>
          <target state="translated">TypeScript의 &lt;code&gt;--pretty&lt;/code&gt; 플래그를 사용하면 오류 메시지를보다 쉽게 ​​읽고 관리 할 수 ​​있습니다. &lt;code&gt;--pretty&lt;/code&gt; 이제 파일 이름, 진단 코드 및 줄 번호에 색상을 사용합니다. 파일 이름과 위치도 이제 공통 터미널 (예 : Visual Studio Code 터미널)에서 탐색 할 수 있도록 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="82367d5505123220713eb9aa76910332cb1314fc" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s &lt;code&gt;--watch&lt;/code&gt; mode now clears the screen after a re-compilation is requested.</source>
          <target state="translated">TypeScript의 &lt;code&gt;--watch&lt;/code&gt; 모드는 이제 재 컴파일이 요청 된 후 화면을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="e240610ed534bc76d20bc7bebb7e8fd4ee492fe3" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s built-in formatter now supports semicolon insertion and removal at locations where a trailing semicolon is optional due to JavaScript&amp;rsquo;s automatic semicolon insertion (ASI) rules. The setting is available now in &lt;a href=&quot;https://code.visualstudio.com/insiders/&quot;&gt;Visual Studio Code Insiders&lt;/a&gt;, and will be available in Visual Studio 16.4 Preview 2 in the Tools Options menu.</source>
          <target state="translated">TypeScript의 내장 포맷터는 이제 JavaScript의 자동 세미콜론 삽입 (ASI) 규칙으로 인해 후행 세미콜론이 선택적인 위치에서 세미콜론 삽입 및 제거를 지원합니다. 이 설정은 이제 &lt;a href=&quot;https://code.visualstudio.com/insiders/&quot;&gt;Visual Studio Code Insiders&lt;/a&gt; 에서 사용할 수 있습니다 에서 사용할 수 있으며 도구 옵션 메뉴의 Visual Studio 16.4 Preview 2에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08c6179dcf1375ce19533b773a6b25765f412389" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s project references provide us with an easy way to break codebases up to give us faster compiles. Unfortunately, editing a project whose dependencies hadn&amp;rsquo;t been built (or whose output was out of date) meant that the editing experience wouldn&amp;rsquo;t work well.</source>
          <target state="translated">TypeScript의 프로젝트 참조는 더 빠른 컴파일을 위해 코드베이스를 분리하는 쉬운 방법을 제공합니다. 불행하게도, 종속성이 빌드되지 않았거나 출력이 오래된 프로젝트를 편집하면 편집 환경이 제대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e33dd464f3004daae495bfbf61b1d8f4515a8bc" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s structural type system was designed based on how JavaScript code is typically written. Because JavaScript widely uses anonymous objects like function expressions and object literals, it&amp;rsquo;s much more natural to represent the kinds of relationships found in JavaScript libraries with a structural type system instead of a nominal one.</source>
          <target state="translated">TypeScript의 구조적 유형 시스템은 JavaScript 코드가 일반적으로 작성되는 방식에 따라 설계되었습니다. JavaScript는 함수 표현식 및 객체 리터럴과 같은 익명 객체를 광범위하게 사용하기 때문에 JavaScript 라이브러리에서 발견되는 종류의 관계를 명목 형이 아닌 구조적 유형 시스템으로 나타내는 것이 훨씬 더 자연 스럽습니다.</target>
        </trans-unit>
        <trans-unit id="bb4cd132d17765763f4ec7ad513fe8c0ba6e5307" translate="yes" xml:space="preserve">
          <source>TypeScript&amp;rsquo;s type system allows certain operations that can&amp;rsquo;t be known at compile-time to be safe. When a type system has this property, it is said to not be &amp;ldquo;sound&amp;rdquo;. The places where TypeScript allows unsound behavior were carefully considered, and throughout this document we&amp;rsquo;ll explain where these happen and the motivating scenarios behind them.</source>
          <target state="translated">TypeScript의 유형 시스템은 컴파일 타임에 알 수없는 특정 작업이 안전하도록합니다. 형식 시스템에이 속성이 있으면 &quot;소리&quot;가 아니라고합니다. TypeScript에서 소리없는 동작을 허용하는 위치를 신중하게 고려했으며이 문서 전체에서 이러한 동작이 발생하는 위치와 그 뒤의 동기 부여 시나리오에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="349e8ba90638f01a95ebe613d90e5ffbcee9736b" translate="yes" xml:space="preserve">
          <source>TypeScript, like JavaScript, allows you to work with arrays of values. Array types can be written in one of two ways. In the first, you use the type of the elements followed by &lt;code&gt;[]&lt;/code&gt; to denote an array of that element type:</source>
          <target state="translated">JavaScript와 마찬가지로 TypeScript를 사용하면 값 배열로 작업 할 수 있습니다. 배열 유형은 두 가지 방법 중 하나로 쓸 수 있습니다. 첫 번째로, 요소 유형 다음에 &lt;code&gt;[]&lt;/code&gt; 를 사용하여 해당 요소 유형의 배열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4ad04619aba3f2f4ed81caa26fedf4a7d7810729" translate="yes" xml:space="preserve">
          <source>TypeScript-Preview</source>
          <target state="translated">TypeScript-Preview</target>
        </trans-unit>
        <trans-unit id="41d9bbe35312804100303ce4556c7c954c09e309" translate="yes" xml:space="preserve">
          <source>TypeScriptAdditionalFlags</source>
          <target state="translated">TypeScriptAdditionalFlags</target>
        </trans-unit>
        <trans-unit id="7b5fe2a5e0980eb4438ba0537940cad4dba1cbf4" translate="yes" xml:space="preserve">
          <source>TypeScriptAllowSyntheticDefaultImports</source>
          <target state="translated">TypeScriptAllowSyntheticDefaultImports</target>
        </trans-unit>
        <trans-unit id="a94bfbe88239bd8121e18f907e172dde0a5dee8d" translate="yes" xml:space="preserve">
          <source>TypeScriptAllowUnreachableCode</source>
          <target state="translated">TypeScriptAllowUnreachableCode</target>
        </trans-unit>
        <trans-unit id="a57b98365d2468c29049e5c8c8ee824604a3fdb7" translate="yes" xml:space="preserve">
          <source>TypeScriptAllowUnusedLabels</source>
          <target state="translated">TypeScriptAllowUnusedLabels</target>
        </trans-unit>
        <trans-unit id="52c7a27301fde259e8f6bb99fc56cb8133f9b303" translate="yes" xml:space="preserve">
          <source>TypeScriptAlwaysStrict</source>
          <target state="translated">TypeScriptAlwaysStrict</target>
        </trans-unit>
        <trans-unit id="2ed81307b38a7333d37096546abf4a0b57b93c74" translate="yes" xml:space="preserve">
          <source>TypeScriptBaseUrl</source>
          <target state="translated">TypeScriptBaseUrl</target>
        </trans-unit>
        <trans-unit id="77f797b2abb4954f5643abb4b5b80d59868c9236" translate="yes" xml:space="preserve">
          <source>TypeScriptCharset</source>
          <target state="translated">TypeScriptCharset</target>
        </trans-unit>
        <trans-unit id="107cd94d243e6194c069f50feafef3b1230a7556" translate="yes" xml:space="preserve">
          <source>TypeScriptCompileBlocked</source>
          <target state="translated">TypeScriptCompileBlocked</target>
        </trans-unit>
        <trans-unit id="7acf8c8a12467f8aca42a0fb5a3ef1f764482e71" translate="yes" xml:space="preserve">
          <source>TypeScriptDeclarationDir</source>
          <target state="translated">TypeScriptDeclarationDir</target>
        </trans-unit>
        <trans-unit id="4a2236f58ea00d2b0bb17b6cea7aca0c8a68c053" translate="yes" xml:space="preserve">
          <source>TypeScriptESModuleInterop</source>
          <target state="translated">TypeScriptESModuleInterop</target>
        </trans-unit>
        <trans-unit id="55c811b895566e510d35f99a3a36ec8a3177f330" translate="yes" xml:space="preserve">
          <source>TypeScriptEmitBOM</source>
          <target state="translated">TypeScriptEmitBOM</target>
        </trans-unit>
        <trans-unit id="b2959142651db2ba36f7a76acb1a7cd0464dd2f0" translate="yes" xml:space="preserve">
          <source>TypeScriptEmitDeclarationOnly</source>
          <target state="translated">TypeScriptEmitDeclarationOnly</target>
        </trans-unit>
        <trans-unit id="17656226f24afbbb0494dc47d1fdf5cb6aec6e7e" translate="yes" xml:space="preserve">
          <source>TypeScriptEmitDecoratorMetadata</source>
          <target state="translated">TypeScriptEmitDecoratorMetadata</target>
        </trans-unit>
        <trans-unit id="f1a24003307b278d63a345cf4646070ee3538d81" translate="yes" xml:space="preserve">
          <source>TypeScriptExperimentalAsyncFunctions</source>
          <target state="translated">TypeScriptExperimentalAsyncFunctions</target>
        </trans-unit>
        <trans-unit id="f178eb0d68749f84390526fcfcf73643580199b8" translate="yes" xml:space="preserve">
          <source>TypeScriptExperimentalDecorators</source>
          <target state="translated">TypeScriptExperimentalDecorators</target>
        </trans-unit>
        <trans-unit id="227102f3c5d5c0c4fe35d5a94e14769df56ea3ea" translate="yes" xml:space="preserve">
          <source>TypeScriptForceConsistentCasingInFileNames</source>
          <target state="translated">TypeScriptForceConsistentCasingInFileNames</target>
        </trans-unit>
        <trans-unit id="e8221bda0f5ae2cb80b553adafbf9c7d7eb1ff79" translate="yes" xml:space="preserve">
          <source>TypeScriptGeneratesDeclarations</source>
          <target state="translated">TypeScriptGeneratesDeclarations</target>
        </trans-unit>
        <trans-unit id="12faa091e4a57a36c933420258af4a9f60dccc85" translate="yes" xml:space="preserve">
          <source>TypeScriptImportHelpers</source>
          <target state="translated">TypeScriptImportHelpers</target>
        </trans-unit>
        <trans-unit id="ee1203ba67f873be0ddd284d0922dc4eaed56181" translate="yes" xml:space="preserve">
          <source>TypeScriptInlineSourceMap</source>
          <target state="translated">TypeScriptInlineSourceMap</target>
        </trans-unit>
        <trans-unit id="388355e20cca01322235dfa01c312ca0d6781b5a" translate="yes" xml:space="preserve">
          <source>TypeScriptInlineSources</source>
          <target state="translated">TypeScriptInlineSources</target>
        </trans-unit>
        <trans-unit id="d77acf48160dec4408ea9726aa2e65d9aca96302" translate="yes" xml:space="preserve">
          <source>TypeScriptIsolatedModules</source>
          <target state="translated">TypeScriptIsolatedModules</target>
        </trans-unit>
        <trans-unit id="956314972e52b72d9e36530ee0a4e72a92acae0b" translate="yes" xml:space="preserve">
          <source>TypeScriptJSXEmit</source>
          <target state="translated">TypeScriptJSXEmit</target>
        </trans-unit>
        <trans-unit id="a67c071d130c25aefdb45b19dfa130ff6bb485ad" translate="yes" xml:space="preserve">
          <source>TypeScriptJSXFactory</source>
          <target state="translated">TypeScriptJSXFactory</target>
        </trans-unit>
        <trans-unit id="4552cc5179a4f2f2d43bbca69cfe48ae1d8a59ca" translate="yes" xml:space="preserve">
          <source>TypeScriptLib</source>
          <target state="translated">TypeScriptLib</target>
        </trans-unit>
        <trans-unit id="0572909efb507dda301b9d8012fab7e5de772948" translate="yes" xml:space="preserve">
          <source>TypeScriptMapRoot</source>
          <target state="translated">TypeScriptMapRoot</target>
        </trans-unit>
        <trans-unit id="dc7b169788198faee3555056c08f9f57327e0a3f" translate="yes" xml:space="preserve">
          <source>TypeScriptModuleKind</source>
          <target state="translated">TypeScriptModuleKind</target>
        </trans-unit>
        <trans-unit id="421c0ae622f44c1602b14f2b708d2cca0d2934ce" translate="yes" xml:space="preserve">
          <source>TypeScriptModuleResolution</source>
          <target state="translated">TypeScriptModuleResolution</target>
        </trans-unit>
        <trans-unit id="35fa542971e052e37cc4839000b5258adf72a14c" translate="yes" xml:space="preserve">
          <source>TypeScriptNewLine</source>
          <target state="translated">TypeScriptNewLine</target>
        </trans-unit>
        <trans-unit id="fc2a8ef1565c45f435f3d5ef342d1c6dae60cbb5" translate="yes" xml:space="preserve">
          <source>TypeScriptNoEmitHelpers</source>
          <target state="translated">TypeScriptNoEmitHelpers</target>
        </trans-unit>
        <trans-unit id="e36e19ff5e1f6a8202b09c668028ec57276c68b9" translate="yes" xml:space="preserve">
          <source>TypeScriptNoEmitOnError</source>
          <target state="translated">TypeScriptNoEmitOnError</target>
        </trans-unit>
        <trans-unit id="5b756225451ecee18834373559b43fedcb96fba8" translate="yes" xml:space="preserve">
          <source>TypeScriptNoFallthroughCasesInSwitch</source>
          <target state="translated">TypeScriptNoFallthroughCasesInSwitch</target>
        </trans-unit>
        <trans-unit id="d92e432f5565e45efa98aec9e0c61f938d26c756" translate="yes" xml:space="preserve">
          <source>TypeScriptNoImplicitAny</source>
          <target state="translated">TypeScriptNoImplicitAny</target>
        </trans-unit>
        <trans-unit id="1c9c8201c130add485ca511eb79ea6e375bc4375" translate="yes" xml:space="preserve">
          <source>TypeScriptNoImplicitReturns</source>
          <target state="translated">TypeScriptNoImplicitReturns</target>
        </trans-unit>
        <trans-unit id="3f55bf3dfa28bf03f3b28f94aa19817851b78cae" translate="yes" xml:space="preserve">
          <source>TypeScriptNoImplicitThis</source>
          <target state="translated">TypeScriptNoImplicitThis</target>
        </trans-unit>
        <trans-unit id="6f256f510247fb48347ab1a84a79bfdc18f35187" translate="yes" xml:space="preserve">
          <source>TypeScriptNoImplicitUseStrict</source>
          <target state="translated">TypeScriptNoImplicitUseStrict</target>
        </trans-unit>
        <trans-unit id="8bd63af2b503b90aadf320b0938c7cc2e9e1080f" translate="yes" xml:space="preserve">
          <source>TypeScriptNoLib</source>
          <target state="translated">TypeScriptNoLib</target>
        </trans-unit>
        <trans-unit id="aba68b0d2bfe600c1b7505f9cf090259fafedf3a" translate="yes" xml:space="preserve">
          <source>TypeScriptNoResolve</source>
          <target state="translated">TypeScriptNoResolve</target>
        </trans-unit>
        <trans-unit id="362c0511319630974131db1f54ca0f8546597ce7" translate="yes" xml:space="preserve">
          <source>TypeScriptNoStrictGenericChecks</source>
          <target state="translated">TypeScriptNoStrictGenericChecks</target>
        </trans-unit>
        <trans-unit id="dfa69886ed42a2dc63f9a0eab77d8450ce96b009" translate="yes" xml:space="preserve">
          <source>TypeScriptNoUnusedLocals</source>
          <target state="translated">TypeScriptNoUnusedLocals</target>
        </trans-unit>
        <trans-unit id="cefd9f6aa4a0ee3b0be73fb43be3ecc77bfe22df" translate="yes" xml:space="preserve">
          <source>TypeScriptNoUnusedParameters</source>
          <target state="translated">TypeScriptNoUnusedParameters</target>
        </trans-unit>
        <trans-unit id="6565a78c53fe02fdb81995bb6c6ec68f1f0ea3bd" translate="yes" xml:space="preserve">
          <source>TypeScriptOutDir</source>
          <target state="translated">TypeScriptOutDir</target>
        </trans-unit>
        <trans-unit id="b14c0569c9dd07bb52cefa5e53a9ee362f59b00f" translate="yes" xml:space="preserve">
          <source>TypeScriptOutFile</source>
          <target state="translated">TypeScriptOutFile</target>
        </trans-unit>
        <trans-unit id="644b7783acc77f0caa187daf9c367ba62b739548" translate="yes" xml:space="preserve">
          <source>TypeScriptPreserveConstEnums</source>
          <target state="translated">TypeScriptPreserveConstEnums</target>
        </trans-unit>
        <trans-unit id="44c9e768eb6070e00bdba352e27ce7e68b24160f" translate="yes" xml:space="preserve">
          <source>TypeScriptPreserveSymlinks</source>
          <target state="translated">TypeScriptPreserveSymlinks</target>
        </trans-unit>
        <trans-unit id="4130284b0addaca5f98609c12c577055315ad705" translate="yes" xml:space="preserve">
          <source>TypeScriptReactNamespace</source>
          <target state="translated">TypeScriptReactNamespace</target>
        </trans-unit>
        <trans-unit id="373f7134beec8752f28917f8c2d07c6972a8eda7" translate="yes" xml:space="preserve">
          <source>TypeScriptRemoveComments</source>
          <target state="translated">TypeScriptRemoveComments</target>
        </trans-unit>
        <trans-unit id="72de35523759783c4427070755e0bb5453621f68" translate="yes" xml:space="preserve">
          <source>TypeScriptRootDir</source>
          <target state="translated">TypeScriptRootDir</target>
        </trans-unit>
        <trans-unit id="6aa743721c9942df651b926d8a6b9d1d8b06dee1" translate="yes" xml:space="preserve">
          <source>TypeScriptSkipDefaultLibCheck</source>
          <target state="translated">TypeScriptSkipDefaultLibCheck</target>
        </trans-unit>
        <trans-unit id="8bfb0bbce64d6d061521026129b6afc021fdb739" translate="yes" xml:space="preserve">
          <source>TypeScriptSkipLibCheck</source>
          <target state="translated">TypeScriptSkipLibCheck</target>
        </trans-unit>
        <trans-unit id="11cea9751a4427f602e3999e641567437522451c" translate="yes" xml:space="preserve">
          <source>TypeScriptSourceMap</source>
          <target state="translated">TypeScriptSourceMap</target>
        </trans-unit>
        <trans-unit id="981b0099a78995ed3e09e63f3468ae20d833111d" translate="yes" xml:space="preserve">
          <source>TypeScriptSourceRoot</source>
          <target state="translated">TypeScriptSourceRoot</target>
        </trans-unit>
        <trans-unit id="144320f2ae79b3129b36ee19ddeac0b49fefd1cb" translate="yes" xml:space="preserve">
          <source>TypeScriptStrict</source>
          <target state="translated">TypeScriptStrict</target>
        </trans-unit>
        <trans-unit id="dd87b21546d155f9fa69bfbdc72090ba951be0b1" translate="yes" xml:space="preserve">
          <source>TypeScriptStrictFunctionTypes</source>
          <target state="translated">TypeScriptStrictFunctionTypes</target>
        </trans-unit>
        <trans-unit id="a6d54bf19b0c132487ec76f847985482640ea044" translate="yes" xml:space="preserve">
          <source>TypeScriptStrictNullChecks</source>
          <target state="translated">TypeScriptStrictNullChecks</target>
        </trans-unit>
        <trans-unit id="102ce2e8221cdb409f6a7a01055c5b3f52db3b57" translate="yes" xml:space="preserve">
          <source>TypeScriptStrictPropertyInitialization</source>
          <target state="translated">TypeScriptStrictPropertyInitialization</target>
        </trans-unit>
        <trans-unit id="565bf41241b63a69256bebd7801f835b429830df" translate="yes" xml:space="preserve">
          <source>TypeScriptStripInternal</source>
          <target state="translated">TypeScriptStripInternal</target>
        </trans-unit>
        <trans-unit id="558de0db52b8fdbbfefba7315f0e5b368e1bccc8" translate="yes" xml:space="preserve">
          <source>TypeScriptSuppressExcessPropertyErrors</source>
          <target state="translated">TypeScriptSuppressExcessPropertyErrors</target>
        </trans-unit>
        <trans-unit id="321f13b1fb2371cd5951fbfd893bddec800abf02" translate="yes" xml:space="preserve">
          <source>TypeScriptSuppressImplicitAnyIndexErrors</source>
          <target state="translated">TypeScriptSuppressImplicitAnyIndexErrors</target>
        </trans-unit>
        <trans-unit id="1df2c0c33e87134f7b9585a2fc5c306565947b0c" translate="yes" xml:space="preserve">
          <source>TypeScriptTarget</source>
          <target state="translated">TypeScriptTarget</target>
        </trans-unit>
        <trans-unit id="71d1dceb1918725eab2477bf3bc8195ca94011da" translate="yes" xml:space="preserve">
          <source>TypeScriptUseDefineForClassFields</source>
          <target state="translated">TypeScriptUseDefineForClassFields</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="34915d42cc54d52a01ea82c5bdce2991a6ef1cbb" translate="yes" xml:space="preserve">
          <source>Types can exist in &lt;em&gt;namespaces&lt;/em&gt;. For example, if we have the declaration &lt;code&gt;let x: A.B.C&lt;/code&gt;, we say that the type &lt;code&gt;C&lt;/code&gt; comes from the &lt;code&gt;A.B&lt;/code&gt; namespace.</source>
          <target state="translated">&lt;em&gt;네임 스페이스&lt;/em&gt; 에는 유형이 존재할 수 있습니다 . 예를 들어, &lt;code&gt;let x: A.B.C&lt;/code&gt; 선언이 있으면 &lt;code&gt;C&lt;/code&gt; 유형 이 &lt;code&gt;A.B&lt;/code&gt; 네임 스페이스 에서 나온다고 합니다.</target>
        </trans-unit>
        <trans-unit id="4983c5239614810aa77447dfbec17bd7041d4202" translate="yes" xml:space="preserve">
          <source>Types that have a common, singleton type property &amp;mdash; the &lt;em&gt;discriminant&lt;/em&gt;.</source>
          <target state="translated">일반적인 싱글 톤 유형 속성 인 &lt;em&gt;판별&lt;/em&gt; 유형을 갖는 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="ab7315f529976c1e9046634d7f86b088c404171a" translate="yes" xml:space="preserve">
          <source>Types with a string index signature can be indexed using the &lt;code&gt;[]&lt;/code&gt; notation, but were not allowed to use the &lt;code&gt;.&lt;/code&gt;. Starting with TypeScript 2.2 using either should be allowed.</source>
          <target state="translated">문자열 색인 서명이있는 유형은 &lt;code&gt;[]&lt;/code&gt; 표기법을 사용하여 색인을 생성 할 수 있지만을 (를) 사용할 수 없습니다 &lt;code&gt;.&lt;/code&gt; . TypeScript 2.2로 시작하는 것이 허용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="eefc11c2a4fd735c4e7783f6bcfa193306bfe237" translate="yes" xml:space="preserve">
          <source>Typescript borrows cast syntax from Closure. This lets you cast types to other types by adding a &lt;code&gt;@type&lt;/code&gt; tag before any parenthesized expression.</source>
          <target state="translated">Typescript는 Closure에서 캐스트 구문을 빌립니다. 이렇게하면 &lt;code&gt;@type&lt;/code&gt; 을 추가하여 다른 유형으로 유형을 캐스트 할 수 있습니다 괄호 표현식 앞에 태그를 .</target>
        </trans-unit>
        <trans-unit id="4c9358fb040ac0e3e60567763fe2b8b87185ed9b" translate="yes" xml:space="preserve">
          <source>Typescript is smart enough to infer the type of things in other contexts as well:</source>
          <target state="translated">Typescript는 다른 상황에서도 사물의 유형을 유추 할 수있을만큼 똑똑합니다.</target>
        </trans-unit>
        <trans-unit id="aa237f14744bf9c080f4239d70330d26fd6782a1" translate="yes" xml:space="preserve">
          <source>Typically, exporting from a module involves adding properties to a value like &lt;code&gt;exports&lt;/code&gt; or &lt;code&gt;module.exports&lt;/code&gt;. TypeScript allows you to use top-level export statements. For instance, if you exported a function like so:</source>
          <target state="translated">일반적으로 모듈에서 내보내려면 &lt;code&gt;exports&lt;/code&gt; 또는 &lt;code&gt;module.exports&lt;/code&gt; 와 같은 값에 속성을 추가해야합니다 . TypeScript를 사용하면 최상위 내보내기 문을 사용할 수 있습니다. 예를 들어, 다음과 같이 함수를 내 보낸 경우 :</target>
        </trans-unit>
        <trans-unit id="c2df529fd52e531e7ccfbb71ef147f00c590c161" translate="yes" xml:space="preserve">
          <source>Typing the function</source>
          <target state="translated">기능 입력</target>
        </trans-unit>
        <trans-unit id="1184391d4660ab61ecb650550cc662801a4ad10e" translate="yes" xml:space="preserve">
          <source>UMD SimpleModule.js</source>
          <target state="translated">UMD SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="afb3e96e84eea2d4709a70ab3751ff0f583aa243" translate="yes" xml:space="preserve">
          <source>UMD modules</source>
          <target state="translated">UMD 모듈</target>
        </trans-unit>
        <trans-unit id="bf3e09cfd260f3d9900f06488088b667722b7926" translate="yes" xml:space="preserve">
          <source>Uglify</source>
          <target state="translated">Uglify</target>
        </trans-unit>
        <trans-unit id="0a5bbb787c318135c5901c5f8fb697634bd5bb32" translate="yes" xml:space="preserve">
          <source>Uglify compacts your code so that it takes less time to download.</source>
          <target state="translated">Uglify는 코드를 압축하여 다운로드 시간이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="ae386e47ac367ccb8dc289004083400a638ccbc5" translate="yes" xml:space="preserve">
          <source>Ultimately the goal of TypeScript is to type existing JavaScript constructs in the least disruptive way. For that reason, TypeScript 3.7 introduces a new concept called &amp;ldquo;assertion signatures&amp;rdquo; which model these assertion functions.</source>
          <target state="translated">궁극적으로 TypeScript의 목표는 기존 JavaScript 구문을 가장 방해가되지 않는 방식으로 입력하는 것입니다. 이러한 이유로 TypeScript 3.7에는 이러한 어설 션 함수를 모델링하는 &quot;어설 션 서명&quot;이라는 새로운 개념이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="4339e741945b9652bb1d49489e6a98543eef7bb2" translate="yes" xml:space="preserve">
          <source>Uncalled Function Checks</source>
          <target state="translated">호출되지 않은 기능 검사</target>
        </trans-unit>
        <trans-unit id="180b1f03e6992ccd4fc623bfa5063f77a58ada25" translate="yes" xml:space="preserve">
          <source>Unconditional calls to &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;define&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; 하거나 &lt;code&gt;define&lt;/code&gt; 하기위한 무조건 호출</target>
        </trans-unit>
        <trans-unit id="b497122fd6b99841feeae2f0b3528acf90c34986" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--strictFunctionTypes&lt;/code&gt; function type parameter positions are checked &lt;em&gt;contravariantly&lt;/em&gt; instead of &lt;em&gt;bivariantly&lt;/em&gt;. For some background on what variance means for function types check out &lt;a href=&quot;https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance&quot;&gt;What are covariance and contravariance?&lt;/a&gt;.</source>
          <target state="translated">아래 &lt;code&gt;--strictFunctionTypes&lt;/code&gt; 기능 유형 매개 변수의 위치를 체크 &lt;em&gt;contravariantly&lt;/em&gt; 대신 &lt;em&gt;bivariantly&lt;/em&gt; . 함수 유형에 대한 분산의 의미에 대한 배경 지식을 확인하십시오. &lt;a href=&quot;https://www.stephanboyer.com/post/132/what-are-covariance-and-contravariance&quot;&gt;공분산 및 반 분산이란 무엇입니까? &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2346be489fd11bd810e990b096f9680008f047bd" translate="yes" xml:space="preserve">
          <source>Under &lt;code&gt;--strictFunctionTypes&lt;/code&gt; the first assignment is still permitted if &lt;code&gt;compare&lt;/code&gt; was declared as a method. Effectively, &lt;code&gt;T&lt;/code&gt; is bivariant in &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; because it is used only in method parameter positions.</source>
          <target state="translated">아래 &lt;code&gt;--strictFunctionTypes&lt;/code&gt; 경우 첫 번째 과제는 여전히 허용 &lt;code&gt;compare&lt;/code&gt; 하는 방법으로 선언했다. 효과적으로, &lt;code&gt;T&lt;/code&gt; 는 분석법 파라미터 위치에서만 사용되기 때문에 &lt;code&gt;Comparer&amp;lt;T&amp;gt;&lt;/code&gt; 에서 이변 량입니다 .</target>
        </trans-unit>
        <trans-unit id="33054f0cbee74c9f788ca4bd77541c3e143d3d3f" translate="yes" xml:space="preserve">
          <source>Under the new &lt;code&gt;--esModuleInterop&lt;/code&gt; these two issues should be addressed:</source>
          <target state="translated">새로운 &lt;code&gt;--esModuleInterop&lt;/code&gt; 에서이 두 가지 문제를 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="128561d89ec896d82327b08129ac6710b805e301" translate="yes" xml:space="preserve">
          <source>Understanding &lt;code&gt;private&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;private&lt;/code&gt; 이해</target>
        </trans-unit>
        <trans-unit id="54219e3d20bedb021463636f2132089eb4de56ba" translate="yes" xml:space="preserve">
          <source>Understanding &lt;code&gt;protected&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;protected&lt;/code&gt; 이해</target>
        </trans-unit>
        <trans-unit id="e23e9d7d02cff72c54df81048c1a4380b98b0319" translate="yes" xml:space="preserve">
          <source>Understanding private</source>
          <target state="translated">개인 이해</target>
        </trans-unit>
        <trans-unit id="95841ad8022df544f75a9cb58504b9e361799465" translate="yes" xml:space="preserve">
          <source>Understanding protected</source>
          <target state="translated">보호 이해</target>
        </trans-unit>
        <trans-unit id="ce277cc9234cfe2b86b777dd92906ff2f86a4ffc" translate="yes" xml:space="preserve">
          <source>Understanding the sample</source>
          <target state="translated">샘플 이해</target>
        </trans-unit>
        <trans-unit id="b8046695cbb07b887254bfc5fba8b62777baab42" translate="yes" xml:space="preserve">
          <source>Understanding what is created with each declaration will help you understand what is merged when you perform a declaration merge.</source>
          <target state="translated">각 선언으로 생성 된 내용을 이해하면 선언 병합을 수행 할 때 병합 된 내용을 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="b6d31265a9d2bb701584804cfe2084c1e863a4e3" translate="yes" xml:space="preserve">
          <source>Unfortunately in TypeScript these checks could never be properly encoded. For loosely-typed code this meant TypeScript was checking less, and for slightly conservative code it often forced users to use type assertions.</source>
          <target state="translated">불행히도 TypeScript에서는 이러한 검사를 제대로 인코딩 할 수 없습니다. 느슨하게 형식화 된 코드의 경우 이것은 TypeScript가 검사를 줄였으며 약간 보수적 인 코드의 경우 종종 사용자가 형식 어설 션을 사용하도록 강요했습니다.</target>
        </trans-unit>
        <trans-unit id="f5ac25ede763c83433a3b880f5f3fc5c401f7ac2" translate="yes" xml:space="preserve">
          <source>Unfortunately, &lt;code&gt;--declaration&lt;/code&gt; didn&amp;rsquo;t work with the &lt;code&gt;--allowJs&lt;/code&gt; flag which allows mixing TypeScript and JavaScript input files. This was a frustrating limitation because it meant users couldn&amp;rsquo;t use the &lt;code&gt;--declaration&lt;/code&gt; flag when migrating codebases, even if they were JSDoc-annotated. TypeScript 3.7 changes that, and allows the two options to be used together!</source>
          <target state="translated">불행히도 &lt;code&gt;--declaration&lt;/code&gt; 은 TypeScript와 JavaScript 입력 파일을 혼합 할 수 있는 &lt;code&gt;--allowJs&lt;/code&gt; 플래그 와 함께 작동하지 않았습니다 . 이는 JSDoc 어노테이션이 있어도 사용자가 코드베이스를 마이그레이션 할 때 &lt;code&gt;--declaration&lt;/code&gt; 플래그를 사용할 수 없기 때문에 실망스러운 제한이었습니다 . TypeScript 3.7에서는이를 변경하여 두 옵션을 함께 사용할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="90407376a294ed45dab6024b8ace72b1f1a4f495" translate="yes" xml:space="preserve">
          <source>Unfortunately, mapped types like the &lt;code&gt;Readonly&lt;/code&gt; utility type were effectively no-ops on array and tuple types.</source>
          <target state="translated">불행히도, &lt;code&gt;Readonly&lt;/code&gt; 유틸리티 유형과 같은 매핑 된 유형 은 실제로 어레이 및 튜플 유형에서 작동하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c9f9b24434ff80b111bededc5c17e2eb1610c1fc" translate="yes" xml:space="preserve">
          <source>Unfortunately, the type of &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; is still &lt;code&gt;any&lt;/code&gt;. That&amp;rsquo;s because &lt;code&gt;this&lt;/code&gt; comes from the function expression inside the object literal. To fix this, you can provide an explicit &lt;code&gt;this&lt;/code&gt; parameter. &lt;code&gt;this&lt;/code&gt; parameters are fake parameters that come first in the parameter list of a function:</source>
          <target state="translated">불행하게도, 유형 &lt;code&gt;this.suits[pickedSuit]&lt;/code&gt; 아직 &lt;code&gt;any&lt;/code&gt; . 때문 &lt;code&gt;this&lt;/code&gt; 객체 리터럴 내부의 함수식에서 온다. 이를 해결하기 위해 명시적인 &lt;code&gt;this&lt;/code&gt; 매개 변수를 제공 할 수 있습니다 . &lt;code&gt;this&lt;/code&gt; 매개 변수는 함수의 매개 변수 목록에서 가장 먼저 나오는 가짜 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="e53ce54f63b88cf452ded6201871a14783c0be8e" translate="yes" xml:space="preserve">
          <source>Unfortunately, this means that constructor functions that are also callable cannot use &lt;code&gt;@constructor&lt;/code&gt;.</source>
          <target state="translated">불행히도 이것은 호출 가능한 생성자 함수가 &lt;code&gt;@constructor&lt;/code&gt; 를 사용할 수 없음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="da9748783613337de4d74ee2abacadcb4e991578" translate="yes" xml:space="preserve">
          <source>Unfortunately, while this seemed to be the direction that the proposal moved towards in its earlier days, there is an extremely strong chance that public class fields will be standardized differently. Instead, the original code sample might need to de-sugar to something closer to the following:</source>
          <target state="translated">안타깝게도 이것이 제안이 초기에 진행된 방향 인 것처럼 보였지만 공공 수업 분야가 다르게 표준화 될 가능성은 매우 높습니다. 대신 원래 코드 샘플은 다음에 더 가까운 것으로 설탕을 제거해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b582e2c337ad84d8772f97cd78414fbed01f687b" translate="yes" xml:space="preserve">
          <source>Unicode codepoint escapes in strings</source>
          <target state="translated">문자열에서 유니 코드 코드 포인트 이스케이프</target>
        </trans-unit>
        <trans-unit id="468ccd5bcf72e4958742b43ae3e09374a05c2b83" translate="yes" xml:space="preserve">
          <source>Union Types</source>
          <target state="translated">연합 유형</target>
        </trans-unit>
        <trans-unit id="b7ed90cee7078e9ede776e2d455827cd6c390d7b" translate="yes" xml:space="preserve">
          <source>Union enums and enum member types</source>
          <target state="translated">유니온 열거 형 및 열거 형 멤버 유형</target>
        </trans-unit>
        <trans-unit id="aba2f05474229fdcd9d1da33808bf8c11dd33d17" translate="yes" xml:space="preserve">
          <source>Union type subtype reduction only removes a class type if it is a subclass of &lt;em&gt;and&lt;/em&gt; derives from another class type in the union.</source>
          <target state="translated">그것의 서브 클래스 인 경우 연합 유형의 하위 유형의 감소는 클래스 타입을 제거 &lt;em&gt;하고&lt;/em&gt; 노조의 또 다른 클래스 유형에서 파생가.</target>
        </trans-unit>
        <trans-unit id="2697f04d1c34bc0fd003a5d4f2f248be3c9842cb" translate="yes" xml:space="preserve">
          <source>Union types</source>
          <target state="translated">연합 유형</target>
        </trans-unit>
        <trans-unit id="56de4c1005168da2654053cbc54188220ab6bb4f" translate="yes" xml:space="preserve">
          <source>Union types also allow for better type inference in arrays and other places where you might have multiple kinds of values in a collection:</source>
          <target state="translated">유니온 타입은 또한 배열과 컬렉션에 여러 종류의 값이있을 수있는 다른 장소에서 더 나은 타입 유추를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="3e7108953bcfc1c7c0311e2518816a93bc306b40" translate="yes" xml:space="preserve">
          <source>Union types are a powerful way to express a value that can be one of several types. For example, you might have an API for running a program that takes a commandline as either a &lt;code&gt;string&lt;/code&gt;, a &lt;code&gt;string[]&lt;/code&gt; or a function that returns a &lt;code&gt;string&lt;/code&gt;. You can now write:</source>
          <target state="translated">유니온 유형은 여러 유형 중 하나 일 수있는 값을 표현하는 강력한 방법입니다. 예를 들어, 명령 행을 &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;string[]&lt;/code&gt; 또는 &lt;code&gt;string&lt;/code&gt; 을 리턴하는 함수 로 사용하는 프로그램을 실행하기위한 API가있을 수 있습니다 . 이제 쓸 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="70635a04ab9351bca09c5621dffee8f76929cc2c" translate="yes" xml:space="preserve">
          <source>Union types are an advanced topic that we&amp;rsquo;ll cover in a later chapter.</source>
          <target state="translated">유니언 유형은 이후 장에서 다룰 고급 주제입니다.</target>
        </trans-unit>
        <trans-unit id="3fa5955704db38dbb3e16e34ca92691e9ea2bbf5" translate="yes" xml:space="preserve">
          <source>Union types are closely related to intersection types, but they are used very differently. Occasionally, you&amp;rsquo;ll run into a library that expects a parameter to be either a &lt;code&gt;number&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;. For instance, take the following function:</source>
          <target state="translated">유니언 유형은 교차 유형과 밀접한 관련이 있지만 매우 다르게 사용됩니다. 때로는 매개 변수가 &lt;code&gt;number&lt;/code&gt; 또는 &lt;code&gt;string&lt;/code&gt; 될 것으로 예상되는 라이브러리가 실행됩니다 . 예를 들어 다음 기능을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="cd921c2ea01c32f5a34e452b767384ff1f31852e" translate="yes" xml:space="preserve">
          <source>Union types are useful for modeling situations when values can overlap in the types they can take on. What happens when we need to know specifically whether we have a &lt;code&gt;Fish&lt;/code&gt;? A common idiom in JavaScript to differentiate between two possible values is to check for the presence of a member. As we mentioned, you can only access members that are guaranteed to be in all the constituents of a union type.</source>
          <target state="translated">결합 유형은 값이 취할 수있는 유형에서 값이 겹칠 수있는 상황을 모델링하는 데 유용합니다. &lt;code&gt;Fish&lt;/code&gt; 가 있는지 구체적으로 알아야 할 때 어떻게됩니까 ? 두 가지 가능한 값을 구별하기위한 JavaScript의 일반적인 관용구는 멤버가 있는지 확인하는 것입니다. 앞에서 언급했듯이 공용체 유형의 모든 구성 요소에 속하는 멤버에만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4d68a0298812ddd887befc8ebd536a465311e12" translate="yes" xml:space="preserve">
          <source>Union types can be a bit tricky here, but it just takes a bit of intuition to get used to. If a value has the type &lt;code&gt;A | B&lt;/code&gt;, we only know for &lt;em&gt;certain&lt;/em&gt; that it has members that both &lt;code&gt;A&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;B&lt;/code&gt; have. In this example, &lt;code&gt;Bird&lt;/code&gt; has a member named &lt;code&gt;fly&lt;/code&gt;. We can&amp;rsquo;t be sure whether a variable typed as &lt;code&gt;Bird | Fish&lt;/code&gt; has a &lt;code&gt;fly&lt;/code&gt; method. If the variable is really a &lt;code&gt;Fish&lt;/code&gt; at runtime, then calling &lt;code&gt;pet.fly()&lt;/code&gt; will fail.</source>
          <target state="translated">유니온 유형은 여기에서 약간 까다로울 수 있지만 익숙해지기 위해서는 약간의 직관이 필요합니다. 값의 유형이 &lt;code&gt;A | B&lt;/code&gt; , 우리 는 &lt;code&gt;A&lt;/code&gt; &lt;em&gt;와 &lt;/em&gt; &lt;code&gt;B&lt;/code&gt; 모두 멤버가 있다는 것을 &lt;em&gt;확실히&lt;/em&gt; 알고 있습니다. 이 예에서 &lt;code&gt;Bird&lt;/code&gt; 에는 &lt;code&gt;fly&lt;/code&gt; 이라는 멤버가 있습니다 . 변수가 &lt;code&gt;Bird | Fish&lt;/code&gt; 에는 &lt;code&gt;fly&lt;/code&gt; 방법이 있습니다. 변수가 런타임에 실제로 &lt;code&gt;Fish&lt;/code&gt; 인 경우 &lt;code&gt;pet.fly()&lt;/code&gt; 호출 이 실패합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ece8b3c6faf7510538396ff92255b9fc5deb4014" translate="yes" xml:space="preserve">
          <source>Unless you take specific measures to avoid it, the internal state of a &lt;code&gt;const&lt;/code&gt; variable is still modifiable. Fortunately, TypeScript allows you to specify that members of an object are &lt;code&gt;readonly&lt;/code&gt;. The &lt;a href=&quot;interfaces&quot;&gt;chapter on Interfaces&lt;/a&gt; has the details.</source>
          <target state="translated">이를 피하기 위해 특정 조치를 취하지 않으면 &lt;code&gt;const&lt;/code&gt; 변수 의 내부 상태 는 여전히 수정 가능합니다. 다행히 TypeScript를 사용하면 객체의 멤버가 &lt;code&gt;readonly&lt;/code&gt; 임을 지정할 수 있습니다 . &lt;a href=&quot;interfaces&quot;&gt;인터페이스에 장&lt;/a&gt; 세부 사항을 가지고있다.</target>
        </trans-unit>
        <trans-unit id="c861cf88ebb1a5b494f6992b73222db7fff28246" translate="yes" xml:space="preserve">
          <source>Unless you&amp;rsquo;re really trying to take advantage of JavaScript&amp;rsquo;s runtime behavior in a clever way, it&amp;rsquo;s advised that you don&amp;rsquo;t do this.</source>
          <target state="translated">현명하게 JavaScript의 런타임 동작을 활용하려고하지 않는 한,이 작업을 수행하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1a1461542d00d5010806839c20e64aa1678fdff5" translate="yes" xml:space="preserve">
          <source>Unlike JSDoc&amp;rsquo;s type system, Typescript only allows you to mark types as containing null or not. There is no explicit non-nullability &amp;ndash; if strictNullChecks is on, then &lt;code&gt;number&lt;/code&gt; is not nullable. If it is off, then &lt;code&gt;number&lt;/code&gt; is nullable.</source>
          <target state="translated">JSDoc의 형식 시스템과 달리 Typescript를 사용하면 형식을 null을 포함하거나 포함하지 않는 것으로 표시 할 수 있습니다. 명시적인 nullable이 아닙니다 &amp;ndash; strictNullChecks가 켜져 있으면 &lt;code&gt;number&lt;/code&gt; 는 null을 허용하지 않습니다. 꺼져 있으면 &lt;code&gt;number&lt;/code&gt; 는 nullable입니다.</target>
        </trans-unit>
        <trans-unit id="51985852906766cae660d6a12174c73de43d98b6" translate="yes" xml:space="preserve">
          <source>Unlike plain optional parameters, default-initialized parameters don&amp;rsquo;t &lt;em&gt;need&lt;/em&gt; to occur after required parameters. If a default-initialized parameter comes before a required parameter, users need to explicitly pass &lt;code&gt;undefined&lt;/code&gt; to get the default initialized value. For example, we could write our last example with only a default initializer on &lt;code&gt;firstName&lt;/code&gt;:</source>
          <target state="translated">일반 선택적 매개 변수와 달리 기본 초기화 매개 변수는 필수 매개 변수 다음에 발생할 &lt;em&gt;필요&lt;/em&gt; 가 없습니다 . 기본 초기화 매개 변수가 필수 매개 변수보다 앞에 오면 사용자 는 기본 초기화 값을 얻기 위해 &lt;code&gt;undefined&lt;/code&gt; 를 명시 적으로 전달해야 합니다. 예를 들어 &lt;code&gt;firstName&lt;/code&gt; 에 기본 이니셜 라이저 만 사용하여 마지막 예제를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b497f9d0d5c2c4f2547035f0fcd80ba5746c84a" translate="yes" xml:space="preserve">
          <source>Unreachable code</source>
          <target state="translated">도달 할 수없는 코드</target>
        </trans-unit>
        <trans-unit id="1d0500c74b8aa49d1d2f3d7c0b7c86b3a9d2a921" translate="yes" xml:space="preserve">
          <source>Unspecified type parameters default to &lt;code&gt;any&lt;/code&gt;</source>
          <target state="translated">지정되지 않은 유형 매개 변수의 기본값은 &lt;code&gt;any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1948c97816d203ebc2f90700d76faedc4fbbccfe" translate="yes" xml:space="preserve">
          <source>Untyped imports</source>
          <target state="translated">형식화되지 않은 수입</target>
        </trans-unit>
        <trans-unit id="42a377f570d337b6d69100d6ff55ff5b9e97a424" translate="yes" xml:space="preserve">
          <source>Unused labels</source>
          <target state="translated">사용하지 않은 라벨</target>
        </trans-unit>
        <trans-unit id="950c29b1f717e4fff1d2a159fa44b64e58240c0f" translate="yes" xml:space="preserve">
          <source>Unused labels are also flagged. Just like unreachable code checks, these are turned on by default; use &lt;code&gt;--allowUnusedLabels&lt;/code&gt; to stop reporting these errors.</source>
          <target state="translated">사용하지 않은 레이블도 표시됩니다. 연결할 수없는 코드 확인과 마찬가지로 기본적으로 설정되어 있습니다. 이러한 오류보고를 중지 하려면 &lt;code&gt;--allowUnusedLabels&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ea5ca14dc52b9bd423f61c07136cde4865d6a52" translate="yes" xml:space="preserve">
          <source>Up to this point, we&amp;rsquo;ve only talked about the &lt;em&gt;instance&lt;/em&gt; members of the class, those that show up on the object when it&amp;rsquo;s instantiated. We can also create &lt;em&gt;static&lt;/em&gt; members of a class, those that are visible on the class itself rather than on the instances. In this example, we use &lt;code&gt;static&lt;/code&gt; on the origin, as it&amp;rsquo;s a general value for all grids. Each instance accesses this value through prepending the name of the class. Similarly to prepending &lt;code&gt;this.&lt;/code&gt; in front of instance accesses, here we prepend &lt;code&gt;Grid.&lt;/code&gt; in front of static accesses.</source>
          <target state="translated">지금까지는 인스턴스화 될 때 객체에 표시되는 클래스 의 &lt;em&gt;인스턴스&lt;/em&gt; 멤버에 대해서만 이야기 했습니다. 또한 인스턴스가 아닌 클래스 자체에서 볼 수있는 클래스의 &lt;em&gt;정적&lt;/em&gt; 멤버를 만들 수도 있습니다 . 이 예제에서는 모든 그리드에 대한 일반 값이므로 원점에 &lt;code&gt;static&lt;/code&gt; 을 사용 합니다. 각 인스턴스는 클래스 이름을 앞에 추가하여이 값에 액세스합니다. &lt;code&gt;this.&lt;/code&gt; 추가 하는 것과 비슷 합니다. 인스턴스 액세스 앞에 &lt;code&gt;Grid.&lt;/code&gt; 를 추가 합니다. 정적 액세스 앞에.</target>
        </trans-unit>
        <trans-unit id="ad67feee99a0f439a0e27027c5ea3dcbcf7ff3d4" translate="yes" xml:space="preserve">
          <source>Update &lt;code&gt;.vscode/settings.json&lt;/code&gt; with the following:</source>
          <target state="translated">&lt;code&gt;.vscode/settings.json&lt;/code&gt; 을 다음과 같이 업데이트 하십시오.</target>
        </trans-unit>
        <trans-unit id="0c453d2caa8ecb4d47c7c21d916dd5de2c9571a9" translate="yes" xml:space="preserve">
          <source>Update project file to include locally installed &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt; (at the top) and &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; (at the bottom) files:</source>
          <target state="translated">로컬로 설치된 &lt;code&gt;Microsoft.TypeScript.Default.props&lt;/code&gt; (맨 위) 및 &lt;code&gt;Microsoft.TypeScript.targets&lt;/code&gt; (맨 아래) 파일 을 포함하도록 프로젝트 파일을 업데이트 하십시오.</target>
        </trans-unit>
        <trans-unit id="61ef22d6991101f4978ea02b3e277ed08f8a02ed" translate="yes" xml:space="preserve">
          <source>Update the &lt;code&gt;Settings - User&lt;/code&gt; file with the following:</source>
          <target state="translated">&lt;code&gt;Settings - User&lt;/code&gt; 파일을 다음으로 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b2b612f6daeee72c04fac6bf2b62e95619d91d9" translate="yes" xml:space="preserve">
          <source>Updating your IDE to use the nightly builds</source>
          <target state="translated">야간 빌드를 사용하도록 IDE 업데이트</target>
        </trans-unit>
        <trans-unit id="4dc2e4b6eb759a2e235283631204f80eaa19dc57" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;templates/module-class-d-ts&quot;&gt;&lt;code&gt;module-class.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;constructed&lt;/em&gt; using &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 를 사용하여 모듈을 &lt;em&gt;구성&lt;/em&gt; 할 수 있으면 &lt;a href=&quot;templates/module-class-d-ts&quot;&gt; &lt;code&gt;module-class.d.ts&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dcb83b510816e0232e4eea4a6e8821858e1d88cf" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;templates/module-function-d-ts&quot;&gt;&lt;code&gt;module-function.d.ts&lt;/code&gt;&lt;/a&gt; if your module can be &lt;em&gt;called&lt;/em&gt; like a function:</source>
          <target state="translated">&lt;a href=&quot;templates/module-function-d-ts&quot;&gt; &lt;code&gt;module-function.d.ts&lt;/code&gt; &lt;/a&gt; 처럼 &lt;em&gt;호출&lt;/em&gt; 할 수 있으면 module-function.d.ts를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9135ad666eb865ef0f03b22c777b4833dda580f4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;--pretty false&lt;/code&gt; on the command line or set &lt;code&gt;&quot;pretty&quot;: false&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt; to disable &lt;code&gt;--pretty&lt;/code&gt; output.</source>
          <target state="translated">명령 행에서 &lt;code&gt;--pretty false&lt;/code&gt; 를 사용 하거나 &lt;code&gt;tsconfig.json&lt;/code&gt; 에서 &lt;code&gt;&quot;pretty&quot;: false&lt;/code&gt; 를 설정하여 &lt;code&gt;--pretty&lt;/code&gt; 출력 을 비활성화 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d777cba827da4d9bd0a80b90d7cc7d35bc7eb763" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;declare class&lt;/code&gt; to describe a class or class-like object. Classes can have properties and methods as well as a constructor.</source>
          <target state="translated">사용 &lt;code&gt;declare class&lt;/code&gt; 클래스 또는 객체 클래스처럼을 설명 할 수 있습니다. 클래스는 생성자뿐만 아니라 속성과 메서드를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d25646e3d1c96527dec663a49cd97e0a677f024" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;declare function&lt;/code&gt; to declare functions.</source>
          <target state="translated">&lt;code&gt;declare function&lt;/code&gt; 를 선언 하려면 선언 함수 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc5e87631ffbf23b795c1170d5135c6525f91882" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;declare namespace&lt;/code&gt; to describe types or values accessed by dotted notation.</source>
          <target state="translated">점으로 구분 된 표기법으로 액세스 한 유형 또는 값을 설명 하려면 &lt;code&gt;declare namespace&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="646cf6b60f19ec39b9a348c993659c06af5ff17e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;declare var&lt;/code&gt; to declare variables. If the variable is read-only, you can use &lt;code&gt;declare const&lt;/code&gt;. You can also use &lt;code&gt;declare let&lt;/code&gt; if the variable is block-scoped.</source>
          <target state="translated">변수를 선언 하려면 &lt;code&gt;declare var&lt;/code&gt; 을 사용하십시오 . 변수가 읽기 전용 인 경우 &lt;code&gt;declare const&lt;/code&gt; 사용할 수 있습니다 . 변수가 블록 범위이면, &lt;code&gt;declare let&lt;/code&gt; 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc7b733452effbd68c17f48699824b764aa4d5c8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fs.watch&lt;/code&gt; to watch directories and child directories</source>
          <target state="translated">&lt;code&gt;fs.watch&lt;/code&gt; 를 사용 하여 디렉토리 및 하위 디렉토리를 감시 하십시오</target>
        </trans-unit>
        <trans-unit id="a20558d88b96350c2a6617d2a8806bb939c26e75" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fs.watch&lt;/code&gt; which uses file system events (but might not be accurate on different OS) to get the notifications for the file changes/creation/deletion. Note that few OS eg. linux has limit on number of watches and failing to create watcher using &lt;code&gt;fs.watch&lt;/code&gt; will result it in creating using &lt;code&gt;fs.watchFile&lt;/code&gt;</source>
          <target state="translated">사용 &lt;code&gt;fs.watch&lt;/code&gt; 파일 시스템 이벤트를 사용 (하지만 서로 다른 OS에 정확하지 않을 수 있습니다) 파일 변경 / 생성 / 삭제에 대한 알림을받을 수 있습니다. 예를 들어 OS는 거의 없습니다. 리눅스는 시계 수에 제한이 있으며 &lt;code&gt;fs.watch&lt;/code&gt; 를 사용하여 감시자를 만들지 않으면 fs.watchFile 을 사용하여 감시자 가 생성됩니다 &lt;code&gt;fs.watchFile&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b8a0ecc46b3020c85d683ef9e7bfc225a06e140d" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fs.watchFile&lt;/code&gt; but use different polling intervals for source files, config files and missing files</source>
          <target state="translated">&lt;code&gt;fs.watchFile&lt;/code&gt; 을 사용 하되 소스 파일, 구성 파일 및 누락 된 파일에 대해 다른 폴링 간격을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d9b3f25a00b42d34692eae633c97a930b3ef45c2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;fs.watchFile&lt;/code&gt; to watch the directories and child directories which is a polling watch (consuming CPU cycles)</source>
          <target state="translated">&lt;code&gt;fs.watchFile&lt;/code&gt; 을 사용 하여 폴링 감시인 디렉토리 및 하위 디렉토리를 봅니다 (CPU주기 소비).</target>
        </trans-unit>
        <trans-unit id="b82d02e810b66cfc5287f1002d1703389ec9f322" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;static defaultProps: Pick&amp;lt;Props, &quot;name&quot;&amp;gt;;&lt;/code&gt; as an explicit type annotation instead, or do not add a type annotation as done in the example above.</source>
          <target state="translated">&lt;code&gt;static defaultProps: Pick&amp;lt;Props, &quot;name&quot;&amp;gt;;&lt;/code&gt; 사용하십시오 . Pick &amp;lt;Props, &quot;name&quot;&amp;gt;; 대신 명시 적 형식 주석으로 사용하거나 위 예에서와 같이 형식 주석을 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c797e1ab4188af4e8f2f348f9d4813348e879b0b" translate="yes" xml:space="preserve">
          <source>Use JSDoc &lt;code&gt;@augments&lt;/code&gt; to specify the types explicitly. for instance:</source>
          <target state="translated">JSDoc &lt;code&gt;@augments&lt;/code&gt; 를 사용하여 유형을 명시 적으로 지정하십시오. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="26914e7e48730258a108abb453430cd3518851d2" translate="yes" xml:space="preserve">
          <source>Use Optional Parameters</source>
          <target state="translated">선택적 매개 변수 사용</target>
        </trans-unit>
        <trans-unit id="1f551ab7cd042c6186f08b5016c6fbb015348adf" translate="yes" xml:space="preserve">
          <source>Use Union Types</source>
          <target state="translated">조합 유형 사용</target>
        </trans-unit>
        <trans-unit id="c6e9ca22aa2af3128ca0dfccc6ca984b9a53e2f4" translate="yes" xml:space="preserve">
          <source>Use a dynamic queue where in the frequently modified files will be polled at shorter interval and the files unchanged will be polled less frequently</source>
          <target state="translated">자주 수정되는 파일에서 짧은 간격으로 폴링되고 변경되지 않은 파일은 덜 자주 폴링되는 동적 큐를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b6bcaab1110f17c72658c24deb9f410172d12ea7" translate="yes" xml:space="preserve">
          <source>Use a type assertion (i.e. &lt;code&gt;opts as Options&lt;/code&gt;).</source>
          <target state="translated">유형 명제를 사용하십시오 (예 &lt;code&gt;opts as Options&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c373f04992cf46cf315a11d0cfd773d124512011" translate="yes" xml:space="preserve">
          <source>Use an &lt;code&gt;interface&lt;/code&gt; to define a type with properties.</source>
          <target state="translated">&lt;code&gt;interface&lt;/code&gt; 를 사용하여 속성이있는 유형을 정의 하십시오 .</target>
        </trans-unit>
        <trans-unit id="de6bf5682731fffe8d17a1a2893ad0e0e875fbd9" translate="yes" xml:space="preserve">
          <source>Use comma or multiple tags to declare multiple type parameters:</source>
          <target state="translated">쉼표 또는 여러 태그를 사용하여 여러 유형 매개 변수를 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="813eb2c164fdf97484adee07af475b49c979cbf5" translate="yes" xml:space="preserve">
          <source>Use destructuring with care. As the previous example demonstrates, anything but the simplest destructuring expression is confusing. This is especially true with deeply nested destructuring, which gets &lt;em&gt;really&lt;/em&gt; hard to understand even without piling on renaming, default values, and type annotations. Try to keep destructuring expressions small and simple. You can always write the assignments that destructuring would generate yourself.</source>
          <target state="translated">조심해서 파괴를 사용하십시오. 앞의 예제에서 알 수 있듯이 가장 간단한 파괴 표현 이외의 것은 혼란 스럽습니다. 이 가져 중첩 destructuring, 특히 사실 &lt;em&gt;정말&lt;/em&gt; 도, 이름 바꾸기 기본 값 및 유형 약어에 말뚝 박기없이 이해하기 어렵다. 파괴적인 표현을 작고 단순하게 유지하십시오. 당신은 항상 파괴가 스스로 생성하는 과제를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84ca1d512ea34e66413a09bf03aea43da1cd5e61" translate="yes" xml:space="preserve">
          <source>Use dynamic polling queue to poll changes to the directory and child directories.</source>
          <target state="translated">동적 폴링 큐를 사용하여 디렉토리 및 하위 디렉토리에 대한 변경 사항을 폴링하십시오.</target>
        </trans-unit>
        <trans-unit id="476bd570b1cb323c844b457111807cf0bfe14c03" translate="yes" xml:space="preserve">
          <source>Use namespaces to organize types.</source>
          <target state="translated">네임 스페이스를 사용하여 유형을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="a7fb2226e7d1637c125b100d2ae8ebe1ff2bbb66" translate="yes" xml:space="preserve">
          <source>Use returned values from super calls as &amp;lsquo;this&amp;rsquo;</source>
          <target state="translated">슈퍼 콜에서 반환 된 값을 'this'로 사용</target>
        </trans-unit>
        <trans-unit id="cec0cfa03e45ca3f1d25fc09af8034cc6ba3a098" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;templates/global-modifying-module-d-ts&quot;&gt;&lt;code&gt;global-modifying-module.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="translated">&lt;a href=&quot;templates/global-modifying-module-d-ts&quot;&gt; &lt;code&gt;global-modifying-module.d.ts&lt;/code&gt; &lt;/a&gt; 템플릿을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="467a1132d18100a2fea14dea179fb807cc8c9786" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;templates/global-plugin-d-ts&quot;&gt;&lt;code&gt;global-plugin.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="translated">&lt;a href=&quot;templates/global-plugin-d-ts&quot;&gt; &lt;code&gt;global-plugin.d.ts&lt;/code&gt; &lt;/a&gt; 템플리트를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ded88ccc850f489f2c1db682f66acc6ce6e89c02" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt;&lt;code&gt;module-plugin.d.ts&lt;/code&gt;&lt;/a&gt; template.</source>
          <target state="translated">&lt;a href=&quot;templates/module-plugin-d-ts&quot;&gt; &lt;code&gt;module-plugin.d.ts&lt;/code&gt; &lt;/a&gt; 템플릿을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d00f93f8ed19c310af833f02b233f61189f29867" translate="yes" xml:space="preserve">
          <source>Use the namespace import pattern if you&amp;rsquo;re importing a large number of things</source>
          <target state="translated">많은 것을 가져 오는 경우 네임 스페이스 가져 오기 패턴을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="181dfdffa543aacf139786370fa1942354e5e0e8" translate="yes" xml:space="preserve">
          <source>Use the specified end of line sequence to be used when emitting files: &lt;code&gt;&quot;crlf&quot;&lt;/code&gt; (windows) or &lt;code&gt;&quot;lf&quot;&lt;/code&gt; (unix).&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;&quot;crlf&quot;&lt;/code&gt; (windows) 또는 &lt;code&gt;&quot;lf&quot;&lt;/code&gt; (unix) 파일을 방출 할 때 사용할 지정된 줄 끝 시퀀스를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c5dbc74cf020a727ea7578eaadc331456e2cdd0" translate="yes" xml:space="preserve">
          <source>Use these directives only when you&amp;rsquo;re authoring a &lt;code&gt;d.ts&lt;/code&gt; file by hand.</source>
          <target state="translated">&lt;code&gt;d.ts&lt;/code&gt; 파일을 직접 작성하는 경우에만 이러한 지시문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c9eac17e15f70b4957575dc44afd54e3e8ed5d8" translate="yes" xml:space="preserve">
          <source>Use your best judgement, and if applicable, consult the matter with the rest of your team.</source>
          <target state="translated">최선의 판단을 내리고 해당되는 경우 나머지 팀과 문제를 상담하십시오.</target>
        </trans-unit>
        <trans-unit id="49e789822c27891d496e2d1c824f3137fc0a60e8" translate="yes" xml:space="preserve">
          <source>User Combinations</source>
          <target state="translated">사용자 조합</target>
        </trans-unit>
        <trans-unit id="6db409b39dc46fb85822ac1924c1fb876244cc1a" translate="yes" xml:space="preserve">
          <source>User-Defined Type Guards</source>
          <target state="translated">사용자 정의 타입 가드</target>
        </trans-unit>
        <trans-unit id="d8895e69c18f832a3dc18dc0b25ac0287a552c83" translate="yes" xml:space="preserve">
          <source>User-defined type guard functions</source>
          <target state="translated">사용자 정의 타입 가드 기능</target>
        </trans-unit>
        <trans-unit id="865aa2eab27a2eebc9f8c1b7ee2b45dba99a5722" translate="yes" xml:space="preserve">
          <source>Users can now declare any augmentations that they want to make, or that any other consumers already have made, to an existing module. Module augmentations look like plain old ambient module declarations (i.e. the &lt;code&gt;declare module &quot;foo&quot; { }&lt;/code&gt; syntax), and are directly nested either your own modules, or in another top level ambient external module.</source>
          <target state="translated">사용자는 이제 기존 모듈에 대해 만들거나 다른 소비자가 이미 작성한 기능 보강을 선언 할 수 있습니다. 모듈 기능 보강은 일반 앰비언트 모듈 선언 (예 : &lt;code&gt;declare module &quot;foo&quot; { }&lt;/code&gt; 구문) 처럼 보이며 , 자신의 모듈 또는 다른 최상위 앰비언트 외부 모듈에 직접 중첩됩니다.</target>
        </trans-unit>
        <trans-unit id="b92638c4a093946ffe782b9c6ea843146edd2d04" translate="yes" xml:space="preserve">
          <source>Users can now ensure that the type system will catch such errors. Here&amp;rsquo;s our new &lt;code&gt;AnimationOptions&lt;/code&gt; using string literal types:</source>
          <target state="translated">사용자는 이제 유형 시스템이 이러한 오류를 포착 할 수 있습니다. 문자열 리터럴 유형을 사용하는 새로운 &lt;code&gt;AnimationOptions&lt;/code&gt; 는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="971fc6da1fad26d48864984a1a77ed97685d4f3a" translate="yes" xml:space="preserve">
          <source>Users using newer versions of TS, will see a prompt to upgrade their project on first load.</source>
          <target state="translated">최신 버전의 TS를 사용하는 사용자에게는 처음로드시 프로젝트를 업그레이드하라는 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="076baa79ca77082f0ca2b3320f7136b88d1a143c" translate="yes" xml:space="preserve">
          <source>Using &amp;lsquo;rootDirs&amp;rsquo;, you can inform the compiler of the &lt;em&gt;roots&lt;/em&gt; making up this &amp;ldquo;virtual&amp;rdquo; directory; and thus the compiler can resolve relative modules imports within these &amp;ldquo;virtual&amp;rdquo; directories &lt;em&gt;as if&lt;/em&gt; were merged together in one directory.</source>
          <target state="translated">'rootDirs'를 사용하면 이 &quot;가상&quot;디렉토리를 구성 하는 &lt;em&gt;루트&lt;/em&gt; 를 컴파일러에 알릴 수 있습니다 . 따라서 컴파일러는 &lt;em&gt;마치&lt;/em&gt; 하나의 디렉토리에 병합 된 &lt;em&gt;것처럼&lt;/em&gt; 이러한&amp;ldquo;가상&amp;rdquo;디렉토리 내의 상대 모듈 가져 오기를 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c907fc236b5576ec4b9496e0b00bbfb71e593bd" translate="yes" xml:space="preserve">
          <source>Using --noResolve</source>
          <target state="translated">--noResolve 사용</target>
        </trans-unit>
        <trans-unit id="fea016f48554330486c9c94e60974382dcd30124" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; also allow for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another.</source>
          <target state="translated">&lt;code&gt;&quot;paths&quot;&lt;/code&gt; 사용하면 여러 폴백 위치를 포함하여보다 정교한 매핑이 가능합니다. 한 위치에서 일부 모듈 만 사용 가능하고 나머지는 다른 위치에있는 프로젝트 구성을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="42ba4227d3af5762437561f59f30ce6a1e5f2260" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&quot;paths&quot;&lt;/code&gt; also allows for more sophisticated mappings including multiple fall back locations. Consider a project configuration where only some modules are available in one location, and the rest are in another. A build step would put them all together in one place. The project layout may look like:</source>
          <target state="translated">사용 &lt;code&gt;&quot;paths&quot;&lt;/code&gt; 여러 가을 다시 위치를 포함하는보다 정교한 매핑 수 있습니다. 한 위치에서 일부 모듈 만 사용 가능하고 나머지는 다른 위치에있는 프로젝트 구성을 고려하십시오. 빌드 단계는 그것들을 모두 한 곳에 모을 것입니다. 프로젝트 레이아웃은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="06cd012e6c788da38d72b27da1a7bbf3bef7051d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;--noResolve&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--noResolve&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="8afa8edba85ebf100416b76304f95c6450f3141c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; to one of the files in a compilation is equivalent to compiling with &lt;code&gt;--lib es2017.string&lt;/code&gt;.</source>
          <target state="translated">사용 &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; 컴파일에있는 파일 중 하나를 사용하여 컴파일에 해당 &lt;code&gt;--lib es2017.string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e4933f2a2e7814cc135c9b1388e792cdd66475c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;from&lt;/code&gt; clause a module can copy the exports of a given module to the current module without introducing local names.</source>
          <target state="translated">&lt;code&gt;from&lt;/code&gt; 절을 사용 하면 모듈은 로컬 이름을 도입하지 않고 지정된 모듈의 내보내기를 현재 모듈로 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37a797ad92e300fcb869331595d2c4e343d74dfd" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;import(&quot;mod&quot;)&lt;/code&gt; in a type annotation allows for reaching in a module and accessing its exported declaration without importing it.</source>
          <target state="translated">사용 &lt;code&gt;import(&quot;mod&quot;)&lt;/code&gt; 유형 약어로하는 것은 모듈에 도달하고 수입없이 수출 선언에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72074f269aec1329aae7105fabf958e05d5c07ed" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;instanceof&lt;/code&gt; with classes and union types:</source>
          <target state="translated">클래스 및 공용체 유형과 함께 &lt;code&gt;instanceof&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="3148c33827558727523c9ea9ec8a97850719dfe8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;typeof&lt;/code&gt; to test a variable:</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; 를 사용 하여 변수 테스트하기 :</target>
        </trans-unit>
        <trans-unit id="3512c5d8c5a6f92bc7eb3bc3316fb1091e9fc207" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;typeof&lt;/code&gt; with union types and &lt;code&gt;else&lt;/code&gt;:</source>
          <target state="translated">공용체 유형 및 &lt;code&gt;else&lt;/code&gt; 와 함께 &lt;code&gt;typeof&lt;/code&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="4d577340ac4bb94fb9a7eb6e17e1355af2faee1e" translate="yes" xml:space="preserve">
          <source>Using API</source>
          <target state="translated">API 사용</target>
        </trans-unit>
        <trans-unit id="aea338f92c90962e364abdd73770a9a8e0a22f76" translate="yes" xml:space="preserve">
          <source>Using Class Types in Generics</source>
          <target state="translated">제네릭에서 클래스 유형 사용</target>
        </trans-unit>
        <trans-unit id="43300137282de05306e305d02f5a4e3a4a8e2d0d" translate="yes" xml:space="preserve">
          <source>Using Command Line Interface</source>
          <target state="translated">명령 행 인터페이스 사용</target>
        </trans-unit>
        <trans-unit id="8b74d8a06cce7b65888ba4e8c7818fe0688bd9a8" translate="yes" xml:space="preserve">
          <source>Using Modules</source>
          <target state="translated">모듈 사용</target>
        </trans-unit>
        <trans-unit id="c5dfdd934dc02ab2c210cf3f3003872dcd3d25e6" translate="yes" xml:space="preserve">
          <source>Using Namespaces</source>
          <target state="translated">네임 스페이스 사용</target>
        </trans-unit>
        <trans-unit id="2340df0448163b853367fed9720dff6a29c60ae1" translate="yes" xml:space="preserve">
          <source>Using NuGet with MSBuild</source>
          <target state="translated">MSBuild와 함께 NuGet 사용</target>
        </trans-unit>
        <trans-unit id="547f3d366f6ba6dbebb442ff52e5209ac22bfe3d" translate="yes" xml:space="preserve">
          <source>Using React</source>
          <target state="translated">반응 사용</target>
        </trans-unit>
        <trans-unit id="d7491bb32b4d14f757fef9c824559f69f7177e06" translate="yes" xml:space="preserve">
          <source>Using Type Guards, you can easily work with a variable of a union type:</source>
          <target state="translated">Type Guard를 사용하면 공용체 유형의 변수로 쉽게 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eccd06efc2831f9179398ffcb9ce80cec01c9e63" translate="yes" xml:space="preserve">
          <source>Using Type Parameters in Generic Constraints</source>
          <target state="translated">일반 제약 조건에서 형식 매개 변수 사용</target>
        </trans-unit>
        <trans-unit id="ba60f8a349037067c0634dc31a0ac923864cdd8c" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;baseUrl&lt;/code&gt; is a common practice in applications using AMD module loaders where modules are &amp;ldquo;deployed&amp;rdquo; to a single folder at run-time. All module imports with non-relative names are assumed to be relative to the &lt;code&gt;baseUrl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;baseUrl&lt;/code&gt; 을 사용하는 것은 모듈이 런타임에 단일 폴더에 &quot;배포&quot;되는 AMD 모듈 로더를 사용하는 응용 프로그램에서 일반적입니다. 상대 이름이 아닌 모든 모듈 가져 오기는 &lt;code&gt;baseUrl&lt;/code&gt; 과 관련이 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="eb2a81ce273392d8c282cd088fcd0585336e4cfd" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;baseUrl&lt;/code&gt; is a common practice in applications using AMD module loaders where modules are &amp;ldquo;deployed&amp;rdquo; to a single folder at run-time. The sources of these modules can live in different directories, but a build script will put them all together.</source>
          <target state="translated">&lt;code&gt;baseUrl&lt;/code&gt; 을 사용하는 것은 모듈이 런타임에 단일 폴더에 &quot;배포&quot;되는 AMD 모듈 로더를 사용하는 응용 프로그램에서 일반적입니다. 이 모듈의 소스는 다른 디렉토리에있을 수 있지만 빌드 스크립트는 이들을 모두 모아 놓을 것입니다.</target>
        </trans-unit>
        <trans-unit id="b5e01fea434d511ae7f89196d33d7e8c07fa0679" translate="yes" xml:space="preserve">
          <source>Using a class as an interface</source>
          <target state="translated">클래스를 인터페이스로 사용</target>
        </trans-unit>
        <trans-unit id="b21dff09db83d498fc08fa858a2c6f95c4bc7857" translate="yes" xml:space="preserve">
          <source>Using an enum is simple: just access any member as a property off of the enum itself, and declare types using the name of the enum:</source>
          <target state="translated">열거 형을 사용하는 것은 간단합니다. 열거 형 자체에서 속성으로 모든 멤버에 액세스하고 열거 형의 이름을 사용하여 유형을 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="e8cff08e29703580b7ac86809f0f79615642a204" translate="yes" xml:space="preserve">
          <source>Using npm</source>
          <target state="translated">npm 사용</target>
        </trans-unit>
        <trans-unit id="f97748b0bee558e2605da416afdbef74fd01695b" translate="yes" xml:space="preserve">
          <source>Using other JSX frameworks</source>
          <target state="translated">다른 JSX 프레임 워크 사용</target>
        </trans-unit>
        <trans-unit id="5c78cf487464fa0e7c06524cc2aed76314129a78" translate="yes" xml:space="preserve">
          <source>Using target &lt;code&gt;--target ES2016&lt;/code&gt; will instruct the compiler not to transform ES2016-specific features, e.g. &lt;code&gt;**&lt;/code&gt; operator.</source>
          <target state="translated">target &lt;code&gt;--target ES2016&lt;/code&gt; 을 사용하면 컴파일러가 ES2016 관련 기능 (예 : &lt;code&gt;**&lt;/code&gt; 연산자) 을 변환하지 않도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="c2bbd5627cb0ada9bd95ef8d96473ec05f861c62" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property</source>
          <target state="translated">은 Using &lt;code&gt;&quot;files&quot;&lt;/code&gt; 재산</target>
        </trans-unit>
        <trans-unit id="dd019ddcfa9a356cc6a71911adc51d98cc08a82d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&quot;include&quot;&lt;/code&gt; and &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; properties</source>
          <target state="translated">은 Using &lt;code&gt;&quot;include&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 속성을</target>
        </trans-unit>
        <trans-unit id="1f9ecf041c00e73da91e933f322f297654272ffc" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;in&lt;/code&gt; operator</source>
          <target state="translated">사용 &lt;code&gt;in&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="05695053496c73d09b9080abbb8ddbcec5718d22" translate="yes" xml:space="preserve">
          <source>Using this ability, &lt;code&gt;lib.d.ts&lt;/code&gt; now has a new &lt;code&gt;Required&amp;lt;T&amp;gt;&lt;/code&gt; type. This type strips &lt;code&gt;?&lt;/code&gt; modifiers from all properties of &lt;code&gt;T&lt;/code&gt;, thus making all properties required.</source>
          <target state="translated">이 기능을 사용하여 &lt;code&gt;lib.d.ts&lt;/code&gt; 는 이제 새로운 &lt;code&gt;Required&amp;lt;T&amp;gt;&lt;/code&gt; 유형을 갖습니다 . 이 유형은 제거 &lt;code&gt;?&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; 의 모든 속성에서 수정 자 이므로 모든 속성이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6f3cf80ca63760070e6103046db8653a28ce64e1" translate="yes" xml:space="preserve">
          <source>Using tsconfig.json</source>
          <target state="translated">tsconfig.json 사용</target>
        </trans-unit>
        <trans-unit id="e3ff1e8a9c36f6f4750c05884c5f542d5a46249b" translate="yes" xml:space="preserve">
          <source>Using type predicates</source>
          <target state="translated">유형 술어 사용</target>
        </trans-unit>
        <trans-unit id="3601427971630988ad2755ef28a7717d757f3df8" translate="yes" xml:space="preserve">
          <source>Using with &lt;code&gt;export =&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;export =&lt;/code&gt; 또는 &lt;code&gt;import&lt;/code&gt; 와 함께 사용</target>
        </trans-unit>
        <trans-unit id="aba045b792a727f53d493f5cc2d4bbe68e26bbc6" translate="yes" xml:space="preserve">
          <source>Utility Types</source>
          <target state="translated">유틸리티 유형</target>
        </trans-unit>
        <trans-unit id="afdf32ce970b80477ef67d464ba5d9d15cfb327c" translate="yes" xml:space="preserve">
          <source>Validation.ts</source>
          <target state="translated">Validation.ts</target>
        </trans-unit>
        <trans-unit id="524163f0faa0530bac2b1baaeb887189c9c73216" translate="yes" xml:space="preserve">
          <source>Validators in a single file</source>
          <target state="translated">단일 파일의 유효성 검사기</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="5a0535139a31a774a3c9068d34adc7058d5bf642" translate="yes" xml:space="preserve">
          <source>Value of &lt;em&gt;baseUrl&lt;/em&gt; is determined as either:</source>
          <target state="translated">&lt;em&gt;baseUrl의&lt;/em&gt; 값 은 다음 중 하나로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="577084450a5e984b5f6966940c5dcc148307a726" translate="yes" xml:space="preserve">
          <source>Value-based elements</source>
          <target state="translated">가치 기반 요소</target>
        </trans-unit>
        <trans-unit id="3f2f78c89fa82d18f5843ae8eee30d072a82336b" translate="yes" xml:space="preserve">
          <source>Value-based elements are simply looked up by identifiers that are in scope.</source>
          <target state="translated">값 기반 요소는 범위 내에있는 식별자로 간단하게 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="d79ccf393d6a199b4ad9ea5944ca607bfd113cf4" translate="yes" xml:space="preserve">
          <source>Var-args parameter declaration inferred from use of &lt;code&gt;arguments&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;arguments&lt;/code&gt; 사용으로 유추 된 Var-args 매개 변수 선언</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="532e17316f9909fba79f94428471eb6888d1b255" translate="yes" xml:space="preserve">
          <source>Variable Declarations</source>
          <target state="translated">변수 선언</target>
        </trans-unit>
        <trans-unit id="b3912d587e9569bb7bfd495613a05ef2130c8e37" translate="yes" xml:space="preserve">
          <source>Variable capturing quirks</source>
          <target state="translated">가변 캡처 단점</target>
        </trans-unit>
        <trans-unit id="7c09718bb5da0232e2044986eb3a280f493f26a9" translate="yes" xml:space="preserve">
          <source>Variables declared in a &lt;code&gt;catch&lt;/code&gt; clause also have similar scoping rules.</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 절에 선언 된 변수 에도 유사한 범위 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b11bd74b68068c8cda414d69c145cdd12377e1bb" translate="yes" xml:space="preserve">
          <source>Version selection with &lt;code&gt;typesVersions&lt;/code&gt;</source>
          <target state="translated">와 버전 선택 &lt;code&gt;typesVersions&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4133624045854a306b02e62768cbf604af93f40f" translate="yes" xml:space="preserve">
          <source>Via npm (the Node.js package manager)</source>
          <target state="translated">npm을 통해 (Node.js 패키지 관리자)</target>
        </trans-unit>
        <trans-unit id="bbef03a29ac970d4beb2f168015277f559e746e0" translate="yes" xml:space="preserve">
          <source>Virtual Directories with &lt;code&gt;rootDirs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rootDirs&lt;/code&gt; 가있는 가상 디렉토리</target>
        </trans-unit>
        <trans-unit id="fd7f9c3ff1ebf06a17bf0502aaa043bb8f017fe6" translate="yes" xml:space="preserve">
          <source>Visual Studio 2013 and 2015</source>
          <target state="translated">Visual Studio 2013 및 2015</target>
        </trans-unit>
        <trans-unit id="023fa801554be0ffd9cb5b6327c0e269a7154d1a" translate="yes" xml:space="preserve">
          <source>Visual Studio 2015 and Visual Studio 2013 Update 2 include TypeScript by default. If you didn&amp;rsquo;t install TypeScript with Visual Studio, you can still &lt;a href=&quot;https://www.typescriptlang.org/#download-links&quot;&gt;download it&lt;/a&gt;.</source>
          <target state="translated">Visual Studio 2015 및 Visual Studio 2013 업데이트 2에는 기본적으로 TypeScript가 포함되어 있습니다. Visual Studio와 함께 TypeScript를 설치하지 않은 경우 계속 &lt;a href=&quot;https://www.typescriptlang.org/#download-links&quot;&gt;다운로드&lt;/a&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="353b01045c518e21b3e08d0cee10940ef65c683f" translate="yes" xml:space="preserve">
          <source>Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript by default. If you didn&amp;rsquo;t install TypeScript with Visual Studio, you can still &lt;a href=&quot;https://www.typescriptlang.org/#download-links&quot;&gt;download it&lt;/a&gt;.</source>
          <target state="translated">Visual Studio 2017 및 Visual Studio 2015 업데이트 3에는 기본적으로 TypeScript가 포함되어 있습니다. Visual Studio와 함께 TypeScript를 설치하지 않은 경우 계속 &lt;a href=&quot;https://www.typescriptlang.org/#download-links&quot;&gt;다운로드&lt;/a&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="423f1f3d80c4d824ca917e13649a5c584a13ec87" translate="yes" xml:space="preserve">
          <source>Visual Studio Code</source>
          <target state="translated">비주얼 스튜디오 코드</target>
        </trans-unit>
        <trans-unit id="a54600c66809939b059f9682e260da90c5cc8595" translate="yes" xml:space="preserve">
          <source>Visual Studio should start installing gulp and del as soon as you save the file. If not, right-click package.json and then Restore Packages.</source>
          <target state="translated">Visual Studio는 파일을 저장하자마자 gulp 및 del 설치를 시작해야합니다. 그렇지 않은 경우 package.json을 마우스 오른쪽 단추로 클릭 한 후 패키지 복원을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="207c7c00630b836d3afb46848bdb24a92023331d" translate="yes" xml:space="preserve">
          <source>Void</source>
          <target state="translated">Void</target>
        </trans-unit>
        <trans-unit id="369e965336691b4254b406f11997b3fb8754eafe" translate="yes" xml:space="preserve">
          <source>Watchify</source>
          <target state="translated">Watchify</target>
        </trans-unit>
        <trans-unit id="4306cbf1196af02448fb51c54f07ce1e5c41ddbb" translate="yes" xml:space="preserve">
          <source>Watchify starts gulp and keeps it running, incrementally compiling whenever you save a file. This lets you keep an edit-save-refresh cycle going in the browser.</source>
          <target state="translated">Watchify는 꿀꺽 꿀꺽을 시작하고 계속 실행하면서 파일을 저장할 때마다 점차적으로 컴파일됩니다. 이를 통해 브라우저에서 편집 저장 새로 고침주기를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e4ac287a7b8a6ec87dd3885f171fdb1cb26939c" translate="yes" xml:space="preserve">
          <source>Watchify, Babel, and Uglify</source>
          <target state="translated">Watchify, Babel 및 Uglify</target>
        </trans-unit>
        <trans-unit id="f89058c451cdea76e04b5f0c00e5ff23bd62a1b8" translate="yes" xml:space="preserve">
          <source>We added two overload signatures to &lt;code&gt;myCoolFunction&lt;/code&gt;. The first checks states that &lt;code&gt;myCoolFunction&lt;/code&gt; takes a function (which takes a &lt;code&gt;number&lt;/code&gt;), and then a list of &lt;code&gt;number&lt;/code&gt;s. The second one says that it will take a function as well, and then uses a rest parameter (&lt;code&gt;...nums&lt;/code&gt;) to state that any number of arguments after that need to be &lt;code&gt;number&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;myCoolFunction&lt;/code&gt; 에 두 개의 과부하 서명을 추가 했습니다 . 상기 제 1 점검 상태 &lt;code&gt;myCoolFunction&lt;/code&gt; 은 (a 취하는 함수 얻어 &lt;code&gt;number&lt;/code&gt; ), 다음의리스트 &lt;code&gt;number&lt;/code&gt; 들. 두 번째는 함수를 취한 다음 rest 매개 변수 ( &lt;code&gt;...nums&lt;/code&gt; )를 사용하여 그 이후의 많은 인수가 &lt;code&gt;number&lt;/code&gt; s 이어야 함을 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="906c596e0e9e46a347b462739c927291c09ad640" translate="yes" xml:space="preserve">
          <source>We also disable the project properties page when you add a &lt;code&gt;tsconfig.json&lt;/code&gt; file. This means that all configuration changes have to be made in the &lt;code&gt;tsconfig.json&lt;/code&gt; file itself.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 파일 을 추가 할 때 프로젝트 속성 페이지도 비활성화 합니다. 이것은 모든 구성 변경이 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일 자체 에서 이루어져야 함을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="fce7ec51558a4620670481cd3447782aedb45ad7" translate="yes" xml:space="preserve">
          <source>We also need to have TypeScript target ES2015. Babel will then produce ES5 from the ES2015 code that TypeScript emits. Let&amp;rsquo;s modify &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">또한 ES2015를 대상으로하는 TypeScript가 필요합니다. 그러면 Babel은 TypeScript가 생성하는 ES2015 코드에서 ES5를 생성합니다. &lt;code&gt;tsconfig.json&lt;/code&gt; 을 수정하자 :</target>
        </trans-unit>
        <trans-unit id="eca6da16584407722c05c582e9312d4b12506c7e" translate="yes" xml:space="preserve">
          <source>We assume that you&amp;rsquo;re already using &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; with &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt;.</source>
          <target state="translated">이미 &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;npm&lt;/a&gt; 과 함께 &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; 를 사용하고 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="dccbace9aee63165dc6770bfacb34962fe498a76" translate="yes" xml:space="preserve">
          <source>We call declarations that don&amp;rsquo;t define an implementation &amp;ldquo;ambient&amp;rdquo;. Typically these are defined in &lt;code&gt;.d.ts&lt;/code&gt; files. If you&amp;rsquo;re familiar with C/C++, you can think of these as &lt;code&gt;.h&lt;/code&gt; files. Let&amp;rsquo;s look at a few examples.</source>
          <target state="translated">구현을 &quot;앰비언트&quot;로 정의하지 않는 선언을 호출합니다. 일반적으로 이들은 &lt;code&gt;.d.ts&lt;/code&gt; 파일에 정의되어 있습니다. C / C ++에 익숙하다면이를 &lt;code&gt;.h&lt;/code&gt; 파일 로 생각할 수 있습니다. 몇 가지 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="92c076044fe3078a3a2d956ae660fa0b4723354a" translate="yes" xml:space="preserve">
          <source>We call declarations that don&amp;rsquo;t define an implementation &amp;ldquo;ambient&amp;rdquo;. Typically, these are defined in &lt;code&gt;.d.ts&lt;/code&gt; files. If you&amp;rsquo;re familiar with C/C++, you can think of these as &lt;code&gt;.h&lt;/code&gt; files. Let&amp;rsquo;s look at a few examples.</source>
          <target state="translated">구현을 &quot;앰비언트&quot;로 정의하지 않는 선언을 호출합니다. 일반적으로 이들은 &lt;code&gt;.d.ts&lt;/code&gt; 파일에 정의되어 있습니다. C / C ++에 익숙하다면이를 &lt;code&gt;.h&lt;/code&gt; 파일 로 생각할 수 있습니다. 몇 가지 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="d7554b9ee0145ef5796d9b34e5b993a1e04de397" translate="yes" xml:space="preserve">
          <source>We called &lt;code&gt;watchedBrowserify.on('log', fancy_log);&lt;/code&gt; to log to the console.</source>
          <target state="translated">우리는 &lt;code&gt;watchedBrowserify.on('log', fancy_log);&lt;/code&gt; 콘솔에 로그인합니다.</target>
        </trans-unit>
        <trans-unit id="5dedc9b8f5d0ca8dda8092dbf79a3b7121e6221e" translate="yes" xml:space="preserve">
          <source>We called &lt;code&gt;watchedBrowserify.on('update', bundle);&lt;/code&gt; so that Browserify will run the &lt;code&gt;bundle&lt;/code&gt; function every time one of your TypeScript files changes.</source>
          <target state="translated">우리는 &lt;code&gt;watchedBrowserify.on('update', bundle);&lt;/code&gt; BrowserScript는 TypeScript 파일 중 하나가 변경 될 때마다 &lt;code&gt;bundle&lt;/code&gt; 기능 을 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="d78c8a7db971a258629029d93d5ac32c8f9a6480" translate="yes" xml:space="preserve">
          <source>We can add additional members to an &lt;code&gt;interface&lt;/code&gt; with another &lt;code&gt;interface&lt;/code&gt; declaration:</source>
          <target state="translated">다른 &lt;code&gt;interface&lt;/code&gt; 선언으로 &lt;code&gt;interface&lt;/code&gt; 멤버를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72346222530ba2a9b0966af45f7d0245b45ebadb" translate="yes" xml:space="preserve">
          <source>We can add types to each of the parameters and then to the function itself to add a return type. TypeScript can figure the return type out by looking at the return statements, so we can also optionally leave this off in many cases.</source>
          <target state="translated">각 매개 변수에 유형을 추가 한 다음 함수 자체에 리턴 유형을 추가 할 수 있습니다. TypeScript는 return 문을보고 반환 유형을 파악할 수 있으므로 많은 경우에 옵션을 생략 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ffa5dba257543828c847bbd33acb3e1bdc1db72" translate="yes" xml:space="preserve">
          <source>We can also declare a variable inside of a function:</source>
          <target state="translated">함수 안에서 변수를 선언 할 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="661d963b4beb85aa27dfba66adb8817f5f2d18c5" translate="yes" xml:space="preserve">
          <source>We can also explicitly give type information to the function&amp;rsquo;s argument to override any contextual type:</source>
          <target state="translated">또한 컨텍스트 정보 유형을 재정의하기 위해 함수의 인수에 유형 정보를 명시 적으로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaa8774bff1b83856163130bd5db5fa1d1e6c687" translate="yes" xml:space="preserve">
          <source>We can also have a type alias refer to itself in a property:</source>
          <target state="translated">속성에서 타입 별칭이 자신을 참조하도록 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a869a9aafbfef91521e95e5db94bb387cae93e3a" translate="yes" xml:space="preserve">
          <source>We can also write the generic type as a call signature of an object literal type:</source>
          <target state="translated">제네릭 형식을 객체 리터럴 형식의 호출 서명으로 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="658e04fc9fb0e75106204a24f2c9d06bdf8f78c2" translate="yes" xml:space="preserve">
          <source>We can alternatively write the sample example this way:</source>
          <target state="translated">대안으로 샘플 예제를 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff36204ad2dc388ad3938b7f629d5c14ff6e7faf" translate="yes" xml:space="preserve">
          <source>We can define the &lt;code&gt;@configurable&lt;/code&gt; decorator using the following function declaration:</source>
          <target state="translated">다음 함수 선언을 사용하여 &lt;code&gt;@configurable&lt;/code&gt; 데코레이터를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82bc383c0b279737360de0b5872e4eaf53cabffa" translate="yes" xml:space="preserve">
          <source>We can define the &lt;code&gt;@enumerable&lt;/code&gt; decorator using the following function declaration:</source>
          <target state="translated">다음 함수 선언을 사용하여 &lt;code&gt;@enumerable&lt;/code&gt; 데코레이터를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7089db4e18a0f27d1d43d048ff6a50fbd3dce944" translate="yes" xml:space="preserve">
          <source>We can define the &lt;code&gt;@sealed&lt;/code&gt; decorator using the following function declaration:</source>
          <target state="translated">다음 함수 선언을 사용하여 &lt;code&gt;@sealed&lt;/code&gt; 데코레이터를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12d89086425b5ee284135e15deb90e23ed2590c7" translate="yes" xml:space="preserve">
          <source>We can fix this by making sure the function is bound to the correct &lt;code&gt;this&lt;/code&gt; before we return the function to be used later. This way, regardless of how it&amp;rsquo;s later used, it will still be able to see the original &lt;code&gt;deck&lt;/code&gt; object. To do this, we change the function expression to use the ECMAScript 6 arrow syntax. Arrow functions capture the &lt;code&gt;this&lt;/code&gt; where the function is created rather than where it is invoked:</source>
          <target state="translated">우리는 확인 기능이 올바른에 바인딩하여이 문제를 해결할 수 &lt;code&gt;this&lt;/code&gt; 우리가 나중에 사용할 수 있도록 기능을 반환하기 전에. 이렇게하면 나중에 사용하는 방법에 관계없이 원본 &lt;code&gt;deck&lt;/code&gt; 객체 를 계속 볼 수 있습니다 . 이를 위해 ECMAScript 6 화살표 구문을 사용하도록 함수 표현식을 변경합니다. 화살표 함수 는 함수가 호출되는 것이 아니라 함수가 생성 된 위치 에서 &lt;code&gt;this&lt;/code&gt; 캡처합니다 .</target>
        </trans-unit>
        <trans-unit id="c6ea0d2b6b5f45da1e1324a08cfc0e11b786897c" translate="yes" xml:space="preserve">
          <source>We can see this in action in the following example:</source>
          <target state="translated">다음 예제에서이를 실제로 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65140ca83fcc5d0530859c1beb185464ff42f37a" translate="yes" xml:space="preserve">
          <source>We can see this more clearly in this example:</source>
          <target state="translated">이 예제에서 더 명확하게 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee21326f232b62bacd8134f20c57de98fb355244" translate="yes" xml:space="preserve">
          <source>We can then define the &lt;code&gt;@format&lt;/code&gt; decorator and &lt;code&gt;getFormat&lt;/code&gt; functions using the following function declarations:</source>
          <target state="translated">다음 함수 선언을 사용하여 &lt;code&gt;@format&lt;/code&gt; 데코레이터 및 &lt;code&gt;getFormat&lt;/code&gt; 함수 를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd3c3bda45ff67c029de2e2368aec01e7ef3a4eb" translate="yes" xml:space="preserve">
          <source>We can then define the &lt;code&gt;@required&lt;/code&gt; and &lt;code&gt;@validate&lt;/code&gt; decorators using the following function declarations:</source>
          <target state="translated">다음 함수 선언을 사용하여 &lt;code&gt;@required&lt;/code&gt; 및 &lt;code&gt;@validate&lt;/code&gt; 데코레이터 를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db549ad2d4eebb5605913a990e51c4ee29c07c32" translate="yes" xml:space="preserve">
          <source>We can use this information to record metadata about the property, as in the following example:</source>
          <target state="translated">이 정보를 사용하여 다음 예와 같이 속성에 대한 메타 데이터를 기록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea01d2c138e3b5218d8e1d52564f033747bdd0ce" translate="yes" xml:space="preserve">
          <source>We can write a decorator factory in the following fashion:</source>
          <target state="translated">우리는 다음과 같은 방식으로 데코레이터 팩토리를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="171a94c1fd6a31b533d269529646e906879fde4e" translate="yes" xml:space="preserve">
          <source>We can write the same example again, this time using an interface to describe the requirement of having the &lt;code&gt;label&lt;/code&gt; property that is a string:</source>
          <target state="translated">동일한 예제를 다시 작성할 수 있습니다. 이번에는 인터페이스를 사용하여 문자열 속성 인 &lt;code&gt;label&lt;/code&gt; 속성이 있어야한다는 요구 사항을 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="d0f35bfcf99e7f68867547c0414c1be9551ec721" translate="yes" xml:space="preserve">
          <source>We could also add a namespaced type to a class:</source>
          <target state="translated">네임 스페이스 유형을 클래스에 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1593c28383f7f19b9f300464de36e13bda32294" translate="yes" xml:space="preserve">
          <source>We could also have used a different name for the generic type parameter in the type, so long as the number of type variables and how the type variables are used line up.</source>
          <target state="translated">타입 변수의 수와 타입 변수가 사용되는 방식에 따라 타입의 제네릭 형식 매개 변수에 다른 이름을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="13a79655a0f6dc78edf29c467dcf807b7ee04905" translate="yes" xml:space="preserve">
          <source>We just imported our &lt;code&gt;Hello&lt;/code&gt; component into &lt;code&gt;index.tsx&lt;/code&gt;. Notice that unlike with &lt;code&gt;&quot;react&quot;&lt;/code&gt; or &lt;code&gt;&quot;react-dom&quot;&lt;/code&gt;, we used a &lt;em&gt;relative path&lt;/em&gt; to &lt;code&gt;Hello.tsx&lt;/code&gt; - this is important. If we hadn&amp;rsquo;t, TypeScript would&amp;rsquo;ve instead tried looking in our &lt;code&gt;node_modules&lt;/code&gt; folder.</source>
          <target state="translated">&lt;code&gt;Hello&lt;/code&gt; 컴포넌트를 &lt;code&gt;index.tsx&lt;/code&gt; 로 가져 왔습니다 . &lt;code&gt;&quot;react&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;react-dom&quot;&lt;/code&gt; 과 달리 &lt;code&gt;Hello.tsx&lt;/code&gt; 에 대한 &lt;em&gt;상대 경로&lt;/em&gt; 를 사용했습니다 . 이것은 중요합니다. 그렇지 않은 경우 TypeScript는 대신 &lt;code&gt;node_modules&lt;/code&gt; 폴더를 찾아 보았습니다 .</target>
        </trans-unit>
        <trans-unit id="e3b6c237e5c56a0727a6cedbb2962b0899558457" translate="yes" xml:space="preserve">
          <source>We may need to describe the type of variables that we do not know when we are writing an application. These values may come from dynamic content, e.g. from the user or a 3rd party library. In these cases, we want to opt-out of type checking and let the values pass through compile-time checks. To do so, we label these with the &lt;code&gt;any&lt;/code&gt; type:</source>
          <target state="translated">응용 프로그램을 작성할 때 모르는 변수 유형을 설명해야 할 수도 있습니다. 이러한 값은 동적 콘텐츠, 예를 들어 사용자 또는 타사 라이브러리에서 제공 될 수 있습니다. 이러한 경우 유형 검사를 옵트 아웃하고 값이 컴파일 타임 검사를 통과하도록합니다. 이를 위해 &lt;code&gt;any&lt;/code&gt; 유형으로 레이블을 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="7e0b762a7d5b6b35f90cd8500631ccf9ab22b8c1" translate="yes" xml:space="preserve">
          <source>We need to setup NPM so that JavaScript packages can be downloaded. Right click on the project and select &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;NPM Configuration File&lt;/strong&gt; and use the default name of &lt;code&gt;package.json&lt;/code&gt;.</source>
          <target state="translated">JavaScript 패키지를 다운로드 할 수 있도록 NPM을 설정해야합니다. 프로젝트를 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;새 항목을&lt;/strong&gt; 선택하십시오 . 그런 다음 &lt;strong&gt;NPM 구성 파일을&lt;/strong&gt; 선택 하고 기본 이름 &lt;code&gt;package.json&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ebc466c22e7712a5cff2da5cf89c0cc81b64e2a7" translate="yes" xml:space="preserve">
          <source>We owe a big thanks to GitHub user &lt;a href=&quot;https://github.com/jwbay&quot;&gt;@jwbay&lt;/a&gt; who took the initiative to create a &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32802&quot;&gt;proof-of-concept&lt;/a&gt; and iterated to provide us with with &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33178&quot;&gt;the current version&lt;/a&gt;.</source>
          <target state="translated">우리는 GitHub 사용자 &lt;a href=&quot;https://github.com/jwbay&quot;&gt;@jwbay&lt;/a&gt; 에게 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32802&quot;&gt;개념 증명&lt;/a&gt; 을 만들기 위해 주도권을 잡고 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33178&quot;&gt;현재 버전&lt;/a&gt; 을 제공하기 위해 반복 해 주셔서 감사합니다 .</target>
        </trans-unit>
        <trans-unit id="894e0a020d31c47096948e05d4d7e1a77b0f6785" translate="yes" xml:space="preserve">
          <source>We owe a large thanks to community members &lt;a href=&quot;https://github.com/Kingwl&quot;&gt;Wenlu Wang&lt;/a&gt; and &lt;a href=&quot;https://github.com/dragomirtitian&quot;&gt;Titian Cernicova Dragomir&lt;/a&gt; for implementing this feature! For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32883&quot;&gt;check out their pull request&lt;/a&gt; and &lt;a href=&quot;https://github.com/tc39/proposal-nullish-coalescing/&quot;&gt;the nullish coalescing proposal repository&lt;/a&gt;.</source>
          <target state="translated">이 기능을 구현 한 데 대해 커뮤니티 회원 인 &lt;a href=&quot;https://github.com/Kingwl&quot;&gt;Wenlu Wang&lt;/a&gt; 과 &lt;a href=&quot;https://github.com/dragomirtitian&quot;&gt;Titian Cernicova Dragomir&lt;/a&gt; 에게 큰 감사를드립니다 ! 자세한 내용은 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32883&quot;&gt;풀 요청&lt;/a&gt; 과 &lt;a href=&quot;https://github.com/tc39/proposal-nullish-coalescing/&quot;&gt;Nullish 통합 제안 저장소를 확인하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2be98474a5452e0a16847898535c758700d80e71" translate="yes" xml:space="preserve">
          <source>We say that this version of the &lt;code&gt;identity&lt;/code&gt; function is generic, as it works over a range of types. Unlike using &lt;code&gt;any&lt;/code&gt;, it&amp;rsquo;s also just as precise (ie, it doesn&amp;rsquo;t lose any information) as the first &lt;code&gt;identity&lt;/code&gt; function that used numbers for the argument and return type.</source>
          <target state="translated">우리는이 버전의 &lt;code&gt;identity&lt;/code&gt; 함수가 다양한 유형에 걸쳐 작동하기 때문에 일반적 이라고 말합니다 . &lt;code&gt;any&lt;/code&gt; 를 사용 하는 것과 달리 인수 및 반환 유형에 숫자를 사용한 첫 번째 &lt;code&gt;identity&lt;/code&gt; 함수 만큼 정확합니다 (즉, 정보를 잃지 않습니다) .</target>
        </trans-unit>
        <trans-unit id="b6da2cbd96b3e75b9187d15de475de9ac9b10faa" translate="yes" xml:space="preserve">
          <source>We strongly encourage users to try the &lt;code&gt;useDefineForClassFields&lt;/code&gt; flag and report back on our issue tracker or in the comments below. This includes feedback on difficulty of adopting the flag so we can understand how we can make migration easier.</source>
          <target state="translated">사용자는 &lt;code&gt;useDefineForClassFields&lt;/code&gt; 플래그 를 사용해보고 이슈 트래커 또는 아래 의견에 다시보고 할 것을 적극 권장 합니다. 여기에는 플래그 채택의 어려움에 대한 피드백이 포함되므로 마이그레이션을보다 쉽게 ​​수행 할 수있는 방법을 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7a2b84a24b11f7b028b0dbae7870221e6b866b5" translate="yes" xml:space="preserve">
          <source>We understand that a ton of monochrome output can be a little difficult on the eyes. Colors can help discern where a message starts and ends, and these visual clues are important when error output gets overwhelming.</source>
          <target state="translated">우리는 많은 흑백 출력이 눈에 약간 어려울 수 있음을 이해합니다. 색상은 메시지 시작 및 종료 위치를 식별하는 데 도움이되며 이러한 시각적 단서는 오류 출력이 압도적 일 때 중요합니다.</target>
        </trans-unit>
        <trans-unit id="9c538d5dd6bb04252a1e101d363501930cb1f96c" translate="yes" xml:space="preserve">
          <source>We used a &lt;code&gt;.ts&lt;/code&gt; extension, but this code is just JavaScript. You could have copy/pasted this straight out of an existing JavaScript app.</source>
          <target state="translated">우리는 사용 &lt;code&gt;.ts&lt;/code&gt; 확장을하지만,이 코드는 자바 스크립트 단지입니다. 기존 JavaScript 앱에서 바로 복사하여 붙여 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5123383e9966536bbcb7f101d2b7d8f6a074dca8" translate="yes" xml:space="preserve">
          <source>We would like the compiler to tell us when we don&amp;rsquo;t cover all variants of the discriminated union. For example, if we add &lt;code&gt;Triangle&lt;/code&gt; to &lt;code&gt;Shape&lt;/code&gt;, we need to update &lt;code&gt;area&lt;/code&gt; as well:</source>
          <target state="translated">우리는 차별 조합의 모든 변형을 다루지 않을 때 컴파일러가 우리에게 알려주기를 원합니다. 예를 들어, &lt;code&gt;Shape&lt;/code&gt; 에 &lt;code&gt;Triangle&lt;/code&gt; 을 추가하면 &lt;code&gt;area&lt;/code&gt; 도 업데이트해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9c5b24b66e133e695b5340a53b29a9a03a4588c0" translate="yes" xml:space="preserve">
          <source>We wrapped our &lt;code&gt;browserify&lt;/code&gt; instance in a call to &lt;code&gt;watchify&lt;/code&gt;, and then held on to the result.</source>
          <target state="translated">우리는 우리의 포장 &lt;code&gt;browserify&lt;/code&gt; 의 호출에 인스턴스를 &lt;code&gt;watchify&lt;/code&gt; 하고 결과에 개최.</target>
        </trans-unit>
        <trans-unit id="b6077b883e1d7e622df4d40c8eae3398ce7b9837" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;d like to extend a huge thanks to &lt;a href=&quot;https://github.com/calebsander&quot;&gt;Caleb Sander&lt;/a&gt; for all the work on this feature. We&amp;rsquo;re grateful for the contribution, and we&amp;rsquo;re sure our users are too!</source>
          <target state="translated">이 기능에 대한 모든 작업에 대해 &lt;a href=&quot;https://github.com/calebsander&quot;&gt;Caleb Sander&lt;/a&gt; 에게 큰 감사를 전합니다. 우리는 기여에 감사하며, 우리의 사용자들도 확신합니다!</target>
        </trans-unit>
        <trans-unit id="2955af2348407c162d10bf22c8f15b1a2bc20810" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll also need a page to display our &lt;code&gt;Hello&lt;/code&gt; component. Create a file at the root of &lt;code&gt;proj&lt;/code&gt; named &lt;code&gt;index.html&lt;/code&gt; with the following contents:</source>
          <target state="translated">&lt;code&gt;Hello&lt;/code&gt; 컴포넌트 를 표시 할 페이지도 필요합니다 . &lt;code&gt;proj&lt;/code&gt; 의 루트에 &lt;code&gt;index.html&lt;/code&gt; 이라는 파일을 다음 내용으로 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="eb0e5a7f6725b7d626b76e36ae307b3fc402a1e2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll discuss index signatures in a bit, but here we&amp;rsquo;re saying a &lt;code&gt;SquareConfig&lt;/code&gt; can have any number of properties, and as long as they aren&amp;rsquo;t &lt;code&gt;color&lt;/code&gt; or &lt;code&gt;width&lt;/code&gt;, their types don&amp;rsquo;t matter.</source>
          <target state="translated">인덱스 시그니처에 대해서는 조금 설명하지만 여기서는 &lt;code&gt;SquareConfig&lt;/code&gt; 가 여러 속성을 가질 수 있으며 &lt;code&gt;color&lt;/code&gt; 이나 &lt;code&gt;width&lt;/code&gt; 가 아닌 한 유형은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a2f59b32ace790506f0abdad902dd97d8982882" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll first start off with numeric enums, which are probably more familiar if you&amp;rsquo;re coming from other languages. An enum can be defined using the &lt;code&gt;enum&lt;/code&gt; keyword.</source>
          <target state="translated">먼저 숫자 열거 형으로 시작하겠습니다. 다른 언어에서 온 경우 더 익숙 할 것입니다. &lt;code&gt;enum&lt;/code&gt; 키워드를 사용하여 열거 형을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19448f8bcee986b6f99112a504f95247ef4c159e" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll start with Watchify to provide background compilation:</source>
          <target state="translated">백그라운드 컴파일을 제공하기 위해 Watchify로 시작할 것입니다.</target>
        </trans-unit>
        <trans-unit id="0b37518565138e9254324247a79b02efcfc6deef" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re also creating another value that we call the &lt;em&gt;constructor function&lt;/em&gt;. This is the function that is called when we &lt;code&gt;new&lt;/code&gt; up instances of the class. To see what this looks like in practice, let&amp;rsquo;s take a look at the JavaScript created by the above example:</source>
          <target state="translated">또한 &lt;em&gt;생성자 함수&lt;/em&gt; 라는 다른 값을 만들고 &lt;em&gt;있습니다&lt;/em&gt; . 이것은 클래스의 인스턴스를 &lt;code&gt;new&lt;/code&gt; 만들 때 호출되는 함수입니다 . 실제로 이것이 어떻게 보이는지 확인하려면 위 예제에서 만든 JavaScript를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7aff8cf77620ede7bc7d3e8d39158810b0f689b3" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re also including two other utility types as well: &lt;code&gt;Record&lt;/code&gt; and &lt;code&gt;Pick&lt;/code&gt;.</source>
          <target state="translated">또한 두 가지 유틸리티 유형 인 &lt;code&gt;Record&lt;/code&gt; 및 &lt;code&gt;Pick&lt;/code&gt; 도 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="6f3e9714b389303e76259f45a7e8e4a3371445cb" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re also introducing a new mode for &lt;code&gt;tsc&lt;/code&gt;, the &lt;code&gt;--build&lt;/code&gt; flag, that works hand in hand with project references to enable faster TypeScript builds.</source>
          <target state="translated">우리는 또한의 새로운 모드를 도입하고 &lt;code&gt;tsc&lt;/code&gt; 의 &lt;code&gt;--build&lt;/code&gt; 프로젝트 참조와 손에 작품을 손으로 빠르게 타이프 빌드를 활성화하는 것으로, 플래그.</target>
        </trans-unit>
        <trans-unit id="0a856c3b5c5d0b1b8b27ac26776fabf8b60ed0f0" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve also added support for &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14479&quot;&gt;declaration source maps&lt;/a&gt;. If you enable &lt;code&gt;--declarationMap&lt;/code&gt;, you&amp;rsquo;ll be able to use editor features like &amp;ldquo;Go to Definition&amp;rdquo; and Rename to transparently navigate and edit code across project boundaries in supported editors.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/14479&quot;&gt;선언 소스 맵에&lt;/a&gt; 대한 지원도 추가했습니다 . &lt;code&gt;--declarationMap&lt;/code&gt; 을 활성화 하면&amp;ldquo;Go to Definition&amp;rdquo;및 Rename과 같은 편집기 기능을 사용하여 지원되는 편집기에서 프로젝트 경계를 넘어 코드를 투명하게 탐색하고 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8e13c786c22514d18489b8a515cda5e549982a7" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve now added a type variable &lt;code&gt;T&lt;/code&gt; to the identity function. This &lt;code&gt;T&lt;/code&gt; allows us to capture the type the user provides (e.g. &lt;code&gt;number&lt;/code&gt;), so that we can use that information later. Here, we use &lt;code&gt;T&lt;/code&gt; again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.</source>
          <target state="translated">식별 함수에 타입 변수 &lt;code&gt;T&lt;/code&gt; 를 추가했습니다 . 이 &lt;code&gt;T&lt;/code&gt; 를 사용하면 사용자가 제공 한 유형 (예 : &lt;code&gt;number&lt;/code&gt; ) 을 캡처하여 나중에 해당 정보를 사용할 수 있습니다. 여기서는 &lt;code&gt;T&lt;/code&gt; 를 반환 형식으로 다시 사용 합니다. 검사 결과, 인자와 리턴 타입에 같은 타입이 사용 된 것을 볼 수 있습니다. 이를 통해 해당 유형 정보를 함수의 한쪽과 다른쪽으로 트래 피킹 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d422ede737ddc07ca03c94e0a0c10b9d58412d1" translate="yes" xml:space="preserve">
          <source>Weak Type Detection</source>
          <target state="translated">약한 유형 감지</target>
        </trans-unit>
        <trans-unit id="642803d03826095e048310e6f6fdb2336f081224" translate="yes" xml:space="preserve">
          <source>Webpack</source>
          <target state="translated">Webpack</target>
        </trans-unit>
        <trans-unit id="c81830d8b730ad2fae90f8032a7776f8b0e39714" translate="yes" xml:space="preserve">
          <source>Webpack integration is pretty simple. You can use &lt;code&gt;awesome-typescript-loader&lt;/code&gt;, a TypeScript loader, combined with &lt;code&gt;source-map-loader&lt;/code&gt; for easier debugging. Simply run</source>
          <target state="translated">웹팩 통합은 매우 간단합니다. 당신이 사용할 수있는 &lt;code&gt;awesome-typescript-loader&lt;/code&gt; 와 함께, 타이프 로더, &lt;code&gt;source-map-loader&lt;/code&gt; 쉽게 디버깅. 간단히 실행</target>
        </trans-unit>
        <trans-unit id="0f41141dbd3f1cbecbaad98cf3de708ecdf41b9b" translate="yes" xml:space="preserve">
          <source>Webpack is a tool that will bundle your code and optionally all of its dependencies into a single &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">Webpack은 코드와 선택적으로 모든 종속성을 단일 &lt;code&gt;.js&lt;/code&gt; 파일 로 묶는 도구입니다 .</target>
        </trans-unit>
        <trans-unit id="7901ed28bacfe5bf0d524efc7190b1e5a54f7326" translate="yes" xml:space="preserve">
          <source>Webpack will eventually generate the &lt;code&gt;dist&lt;/code&gt; directory for us.</source>
          <target state="translated">Webpack은 결국 우리를 위해 &lt;code&gt;dist&lt;/code&gt; 디렉토리를 생성 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="39db66a63832d879643a9c74c80d078ce3a9abfa" translate="yes" xml:space="preserve">
          <source>Weeding out Errors</source>
          <target state="translated">오류 제거</target>
        </trans-unit>
        <trans-unit id="e97ac55d12c65e8ccc90515dafcb06d1bbf38e6c" translate="yes" xml:space="preserve">
          <source>Well-known Symbols</source>
          <target state="translated">잘 알려진 기호</target>
        </trans-unit>
        <trans-unit id="b453e4894b5221614db3412183873d5d5a3d6fc9" translate="yes" xml:space="preserve">
          <source>What if we want to also log the length of the argument &lt;code&gt;arg&lt;/code&gt; to the console with each call? We might be tempted to write this:</source>
          <target state="translated">각 호출마다 인수 &lt;code&gt;arg&lt;/code&gt; 의 길이를 콘솔에 기록하려면 어떻게해야 합니까? 우리는 이것을 쓰고 싶을 것입니다 :</target>
        </trans-unit>
        <trans-unit id="45fda52dea40ed49a1af31b0fc06e0a0f19b734d" translate="yes" xml:space="preserve">
          <source>What if we&amp;rsquo;re not running in TypeScript 3.1 in this example? Well, if none of the fields in &lt;code&gt;typesVersions&lt;/code&gt; get matched, TypeScript falls back to the &lt;code&gt;types&lt;/code&gt; field, so here TypeScript 3.0 and earlier will be redirected to &lt;code&gt;[...]/node_modules/package-name/index.d.ts&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 TypeScript 3.1을 실행하지 않으면 어떻게됩니까? &lt;code&gt;typesVersions&lt;/code&gt; 의 필드 가 일치 하지 않으면 TypeScript는 &lt;code&gt;types&lt;/code&gt; 필드로 돌아가 므로 TypeScript 3.0 이하 버전은 &lt;code&gt;[...]/node_modules/package-name/index.d.ts&lt;/code&gt; 로 리디렉션 됩니다.</target>
        </trans-unit>
        <trans-unit id="6349e923db276196bacfe2471e600626fa732ab4" translate="yes" xml:space="preserve">
          <source>What is a Project Reference?</source>
          <target state="translated">프로젝트 참조 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="59beb27768eff0de85903d679ab600335df3cfc4" translate="yes" xml:space="preserve">
          <source>What is supported in my version of Visual Studio?</source>
          <target state="translated">내 Visual Studio 버전에서 지원되는 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6ebc3fc3da860ce67243a9d91e606b84eda07cf2" translate="yes" xml:space="preserve">
          <source>What these two boil down to is that mixing properties with accessors is going to cause issues, and so will re-declaring properties with no initializers.</source>
          <target state="translated">이 두 가지 단점은 속성과 접근자를 혼합하면 문제가 발생하므로 초기화 프로그램없이 속성을 다시 선언한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d5327b36090577d46345fd56199590737f1090b4" translate="yes" xml:space="preserve">
          <source>What&amp;#x27;s New</source>
          <target state="translated">새로운 소식</target>
        </trans-unit>
        <trans-unit id="b19f846e4de2aa633d8a22d53f27123620724843" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;@sealed&lt;/code&gt; is executed, it will seal both the constructor and its prototype.</source>
          <target state="translated">&lt;code&gt;@sealed&lt;/code&gt; 가 실행 되면 생성자와 프로토 타입이 모두 봉인됩니다.</target>
        </trans-unit>
        <trans-unit id="030f0dfcec29d2c5288e91c918593dc6c753cec6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;localStorage.volume&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, the page will set the volume to &lt;code&gt;0.5&lt;/code&gt; which is unintended. &lt;code&gt;??&lt;/code&gt; avoids some unintended behavior from &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; being treated as falsy values.</source>
          <target state="translated">&lt;code&gt;localStorage.volume&lt;/code&gt; 이 &lt;code&gt;0&lt;/code&gt; 으로 설정 되면 페이지 가 의도하지 않은 볼륨을 &lt;code&gt;0.5&lt;/code&gt; 로 설정합니다 . &lt;code&gt;??&lt;/code&gt; &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;NaN&lt;/code&gt; 및 &lt;code&gt;&quot;&quot;&lt;/code&gt; 의 의도하지 않은 동작이 잘못된 값으로 처리되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="f8cdcfeef8004c101022b373d173e5e67f254a91" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;outFile&lt;/code&gt; is used, the build information file&amp;rsquo;s name will be based on the output file&amp;rsquo;s name. As an example, if our output JavaScript file is &lt;code&gt;./output/foo.js&lt;/code&gt;, then under the &lt;code&gt;--incremental&lt;/code&gt; flag, TypeScript will generate the file &lt;code&gt;./output/foo.tsbuildinfo&lt;/code&gt;. As above, this can be controlled with the &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; flag.</source>
          <target state="translated">때 &lt;code&gt;outFile&lt;/code&gt; 사용하는 빌드 정보 파일의 이름은 출력 파일의 이름을 기반으로합니다. 우리의 출력 자바 스크립트 파일 인 경우 예를 들어, &lt;code&gt;./output/foo.js&lt;/code&gt; 를 다음에서 &lt;code&gt;--incremental&lt;/code&gt; 플래그, 타이프 스크립트는 파일이 생성됩니다 &lt;code&gt;./output/foo.tsbuildinfo&lt;/code&gt; 을 . 위와 같이 &lt;code&gt;--tsBuildInfoFile&lt;/code&gt; 플래그 로 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f520248f652ff2167281b35bfd68546d3ba6914b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;strictNullChecks&lt;/code&gt; is enabled, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; get their own types called &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; respectively. Whenever anything is &lt;em&gt;possibly&lt;/em&gt;&lt;code&gt;null&lt;/code&gt;, you can use a union type with the original type. So for instance, if something could be a &lt;code&gt;number&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt;, you&amp;rsquo;d write the type out as &lt;code&gt;number | null&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;strictNullChecks&lt;/code&gt; 가 활성화되어 &lt;code&gt;null&lt;/code&gt; 하고 &lt;code&gt;undefined&lt;/code&gt; 얻을 자신의 유형이라고 &lt;code&gt;null&lt;/code&gt; 하고 &lt;code&gt;undefined&lt;/code&gt; 각각. &lt;code&gt;null&lt;/code&gt; 이 &lt;em&gt;될&lt;/em&gt; 때마다 원래 유형과 결합 유형을 사용할 수 있습니다. 예를 들어, 무언가가 &lt;code&gt;number&lt;/code&gt; 이거나 &lt;code&gt;null&lt;/code&gt; 인 경우 유형을 &lt;code&gt;number | null&lt;/code&gt; 널 (null) .</target>
        </trans-unit>
        <trans-unit id="5bbf9f8fcdd1b99e48e1893b7a75fd930f81e35d" translate="yes" xml:space="preserve">
          <source>When Javascript classes extend a generic base class, there is nowhere to specify what the type parameter should be. The &lt;code&gt;@extends&lt;/code&gt; tag provides a place for that type parameter:</source>
          <target state="translated">Javascript 클래스가 일반 기본 클래스를 확장하면 type 매개 변수를 지정해야 할 곳이 없습니다. &lt;code&gt;@extends&lt;/code&gt; 의 태그는 해당 유형의 매개 변수에 대한 장소를 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="ac8c176e99ff6882e6b0d9b7305bf530d1b1a588" translate="yes" xml:space="preserve">
          <source>When a function call includes a spread expression of a tuple type as the last argument, the spread expression corresponds to a sequence of discrete arguments of the tuple element types.</source>
          <target state="translated">함수 호출에 마지막 인수로 튜플 유형의 스프레드 표현식이 포함 된 경우, 스프레드 표현식은 튜플 요소 유형의 개별 인수 시퀀스에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="9c33bce0f75302f0d6e1a7e860836fefe8f472c2" translate="yes" xml:space="preserve">
          <source>When a function has a rest parameter, it is treated as if it were an infinite series of optional parameters.</source>
          <target state="translated">함수에 rest 매개 변수가 있으면 무한한 일련의 선택적 매개 변수 인 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="fd713400776c7d40925b3ed1ecacc3ed2345c946" translate="yes" xml:space="preserve">
          <source>When a function has overloads, each overload in the source type must be matched by a compatible signature on the target type. This ensures that the target function can be called in all the same situations as the source function.</source>
          <target state="translated">함수에 과부하가있는 경우 소스 유형의 각 과부하는 대상 유형의 호환 가능한 서명과 일치해야합니다. 이를 통해 소스 함수와 동일한 상황에서 대상 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5607cf867fc582d411cd22588c4ee37feb393557" translate="yes" xml:space="preserve">
          <source>When a member is marked &lt;code&gt;private&lt;/code&gt;, it cannot be accessed from outside of its containing class. For example:</source>
          <target state="translated">멤버가 &lt;code&gt;private&lt;/code&gt; 으로 표시되면 포함 클래스 외부에서 액세스 할 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="584d36e45bec249f6c98a43c17d122b7fd42bae9" translate="yes" xml:space="preserve">
          <source>When a rest parameter has a tuple type, the tuple type is expanded into a sequence of discrete parameters. For example the following two declarations are equivalent:</source>
          <target state="translated">나머지 매개 변수가 튜플 유형 인 경우 튜플 유형은 일련의 개별 매개 변수로 확장됩니다. 예를 들어 다음 두 선언은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="564e9e469a41360585db50dc07312fe0e7a957af" translate="yes" xml:space="preserve">
          <source>When a type inference is made from several expressions, the types of those expressions are used to calculate a &amp;ldquo;best common type&amp;rdquo;. For example,</source>
          <target state="translated">여러 표현식에서 유형 유추가 이루어질 때 해당 표현식의 유형은 &quot;최고의 공통 유형&quot;을 계산하는 데 사용됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="5b460fc1b0afb2a95c11c3857f5c3f8edcb0a57d" translate="yes" xml:space="preserve">
          <source>When a variable is declared using &lt;code&gt;let&lt;/code&gt;, it uses what some call &lt;em&gt;lexical-scoping&lt;/em&gt; or &lt;em&gt;block-scoping&lt;/em&gt;. Unlike variables declared with &lt;code&gt;var&lt;/code&gt; whose scopes leak out to their containing function, block-scoped variables are not visible outside of their nearest containing block or &lt;code&gt;for&lt;/code&gt;-loop.</source>
          <target state="translated">변수가 사용하여 선언하면 &lt;code&gt;let&lt;/code&gt; , 그것을 사용하는 것 일부 통화 &lt;em&gt;어휘 범위 지정&lt;/em&gt; 또는 &lt;em&gt;블록 범위 지정&lt;/em&gt; . 스코프가 포함하는 함수로 범위가 누출 되는 &lt;code&gt;var&lt;/code&gt; 로 선언 된 변수와 달리 블록 범위 변수는 가장 가까운 포함 블록 또는 &lt;code&gt;for&lt;/code&gt; 루프 외부에 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e90a72104ebe8868314228d24725924c08766c5b" translate="yes" xml:space="preserve">
          <source>When accessing an element with a known index, the correct type is retrieved:</source>
          <target state="translated">알려진 인덱스가있는 요소에 액세스하면 올바른 유형이 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="d43b1825ee2b2cb0d745c365143986923701b4d7" translate="yes" xml:space="preserve">
          <source>When all members in an enum have literal enum values, some special semantics come to play.</source>
          <target state="translated">열거 형의 모든 멤버가 리터럴 열거 형 값을 가지면 일부 특수 의미론이 재생됩니다.</target>
        </trans-unit>
        <trans-unit id="84234191fb7cb5a1d6647ae5bcd64e2e66fdf73e" translate="yes" xml:space="preserve">
          <source>When an array literal is contextually typed by the implied type of an array binding pattern:</source>
          <target state="translated">배열 리터럴이 내포 된 배열 바인딩 패턴 유형에 의해 문맥 상으로 유형화되는 경우 :</target>
        </trans-unit>
        <trans-unit id="6db5ea81f7f1151fab25e118bfe8501e1c5b8304" translate="yes" xml:space="preserve">
          <source>When an interface type extends a class type it inherits the members of the class but not their implementations. It is as if the interface had declared all of the members of the class without providing an implementation. Interfaces inherit even the private and protected members of a base class. This means that when you create an interface that extends a class with private or protected members, that interface type can only be implemented by that class or a subclass of it.</source>
          <target state="translated">인터페이스 유형이 클래스 유형을 확장하면 클래스 유형을 상속하지만 해당 구현은 상속하지 않습니다. 마치 인터페이스가 구현을 제공하지 않고 클래스의 모든 멤버를 선언 한 것처럼 보입니다. 인터페이스는 기본 클래스의 개인 및 보호 멤버를 상속합니다. 이는 개인 또는 보호 된 멤버로 클래스를 확장하는 인터페이스를 작성할 때 해당 인터페이스 유형은 해당 클래스 또는 서브 클래스로만 구현 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5744d6fdcbf8dc3476727393bac3b4cddf93ada3" translate="yes" xml:space="preserve">
          <source>When an object literal is contextually typed by the implied type of an object binding pattern:</source>
          <target state="translated">묵시적 유형의 객체 바인딩 패턴에 의해 객체 리터럴이 문맥 상으로 유형화되는 경우 :</target>
        </trans-unit>
        <trans-unit id="be88d1b03a9be5d8830da895b57d21e37b131ee9" translate="yes" xml:space="preserve">
          <source>When an object with a numeric index signature of type &lt;code&gt;T&lt;/code&gt; (such as an array) is indexed by a &lt;code&gt;for..in&lt;/code&gt; variable of a containing &lt;code&gt;for..in&lt;/code&gt; statement for an object &lt;em&gt;with&lt;/em&gt; a numeric index signature and &lt;em&gt;without&lt;/em&gt; a string index signature (again such as an array), the value produced is of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">배열과 같은 유형 &lt;code&gt;T&lt;/code&gt; 의 숫자 인덱스 서명이 있는 개체 &lt;em&gt;가&lt;/em&gt; 숫자 인덱스 서명이 있고 문자열 인덱스 서명이 &lt;em&gt;없는&lt;/em&gt; 개체에 대한 포함 &lt;code&gt;for..in&lt;/code&gt; 문의 &lt;code&gt;for..in&lt;/code&gt; 변수에 의해 인덱스 &lt;em&gt;될&lt;/em&gt; 때 배열과 같은) 생성 된 값은 &lt;code&gt;T&lt;/code&gt; 유형 입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6a191b524d20c2c29223783fb417af58e807f338" translate="yes" xml:space="preserve">
          <source>When calling this function, TypeScript will try to figure out the types of &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt; through a process called &lt;em&gt;type argument inference&lt;/em&gt;. This inference process usually works pretty well:</source>
          <target state="translated">이 함수를 호출하면 TypeScript는 &lt;em&gt;type argument 추론&lt;/em&gt; 이라는 프로세스를 통해 &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 의 유형을 파악하려고 시도합니다 . 이 추론 프로세스는 일반적으로 꽤 잘 작동합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a79acd611da5588e33a3cd349e2f634dc5e04388" translate="yes" xml:space="preserve">
          <source>When comparing functions for compatibility, optional and required parameters are interchangeable. Extra optional parameters of the source type are not an error, and optional parameters of the target type without corresponding parameters in the source type are not an error.</source>
          <target state="translated">호환성을 위해 기능을 비교할 때 선택적 매개 변수와 필수 매개 변수를 상호 교환 할 수 있습니다. 소스 유형의 추가 선택적 매개 변수는 오류가 아니며 소스 유형에 해당 매개 변수가없는 대상 유형의 선택적 매개 변수는 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="03084317d53b13f20dd727e5c86474664f6cced3" translate="yes" xml:space="preserve">
          <source>When comparing the types of function parameters, assignment succeeds if either the source parameter is assignable to the target parameter, or vice versa. This is unsound because a caller might end up being given a function that takes a more specialized type, but invokes the function with a less specialized type. In practice, this sort of error is rare, and allowing this enables many common JavaScript patterns. A brief example:</source>
          <target state="translated">함수 매개 변수의 유형을 비교할 때 소스 매개 변수를 대상 매개 변수에 지정하거나 그 반대로 지정하면 지정이 성공합니다. 호출자에게 더 특수화 된 유형을 사용하지만 덜 특수한 유형으로 함수를 호출하는 함수가 제공 될 수 있으므로 이는 좋지 않습니다. 실제로 이러한 종류의 오류는 드물며이를 허용하면 많은 공통 JavaScript 패턴이 가능합니다. 간단한 예 :</target>
        </trans-unit>
        <trans-unit id="e381f7d0b16f43f925b00a27f8c4e30f5d16099b" translate="yes" xml:space="preserve">
          <source>When compiled in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, optional properties and methods automatically have &lt;code&gt;undefined&lt;/code&gt; included in their type. Thus, the &lt;code&gt;b&lt;/code&gt; property above is of type &lt;code&gt;number | undefined&lt;/code&gt; and the &lt;code&gt;g&lt;/code&gt; method above is of type &lt;code&gt;(() =&amp;gt; number) | undefined&lt;/code&gt;. Type guards can be used to strip away the &lt;code&gt;undefined&lt;/code&gt; part of the type:</source>
          <target state="translated">&lt;code&gt;--strictNullChecks&lt;/code&gt; 모드 에서 컴파일 할 때 선택적 속성 및 메서드 는 해당 유형에 &lt;code&gt;undefined&lt;/code&gt; 자동으로 포함됩니다. 따라서 위 의 &lt;code&gt;b&lt;/code&gt; 속성은 &lt;code&gt;number | undefined&lt;/code&gt; 이고 위 의 &lt;code&gt;g&lt;/code&gt; 메소드는 &lt;code&gt;(() =&amp;gt; number) | undefined&lt;/code&gt; . 타입 가드는 타입의 &lt;code&gt;undefined&lt;/code&gt; 부분 을 제거하는데 사용될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5bbcd2d4cb15d58c0854ed82d657d8c796031edd" translate="yes" xml:space="preserve">
          <source>When compiled, each module will become a separate &lt;code&gt;.js&lt;/code&gt; file. As with reference tags, the compiler will follow &lt;code&gt;import&lt;/code&gt; statements to compile dependent files.</source>
          <target state="translated">컴파일되면 각 모듈은 별도의 &lt;code&gt;.js&lt;/code&gt; 파일이됩니다. 참조 태그와 마찬가지로 컴파일러는 &lt;code&gt;import&lt;/code&gt; 문을 따라 종속 파일을 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="751fdd8e03ce07c29b56146fecc9f825067cb792" translate="yes" xml:space="preserve">
          <source>When compiling to pre-ES6 targets, the string is decomposed:</source>
          <target state="translated">ES6 이전 대상으로 컴파일 할 때 문자열이 분해됩니다.</target>
        </trans-unit>
        <trans-unit id="4156655ae276c8b3ed96d041dfc8baeba1797652" translate="yes" xml:space="preserve">
          <source>When creating factories in TypeScript using generics, it is necessary to refer to class types by their constructor functions. For example,</source>
          <target state="translated">제네릭을 사용하여 TypeScript에서 팩토리를 만들 때는 생성자 함수로 클래스 유형을 참조해야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="f2a561b2561570486c65edf072423fc080bd866b" translate="yes" xml:space="preserve">
          <source>When enabled, as long as the &lt;code&gt;reflect-metadata&lt;/code&gt; library has been imported, additional design-time type information will be exposed at runtime.</source>
          <target state="translated">활성화되면 &lt;code&gt;reflect-metadata&lt;/code&gt; 라이브러리를 가져 오는 동안 추가 디자인 타임 유형 정보가 런타임에 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="7c2be8d3bddd72617c23414391cc48bc565dfaa5" translate="yes" xml:space="preserve">
          <source>When exporting a module using &lt;code&gt;export =&lt;/code&gt;, TypeScript-specific &lt;code&gt;import module = require(&quot;module&quot;)&lt;/code&gt; must be used to import the module.</source>
          <target state="translated">&lt;code&gt;export =&lt;/code&gt; 를 사용하여 모듈을 내보내는 경우 TypeScript 관련 &lt;code&gt;import module = require(&quot;module&quot;)&lt;/code&gt; 를 사용하여 모듈을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="06ca5da26932f2433c3883f2ba92d649c8f8ac14" translate="yes" xml:space="preserve">
          <source>When first moving to a module-based organization, a common tendency is to wrap exports in an additional layer of namespaces. Modules have their own scope, and only exported declarations are visible from outside the module. With this in mind, namespace provide very little, if any, value when working with modules.</source>
          <target state="translated">모듈 기반 조직으로 처음 이동할 때 공통적 인 경향은 추가 네임 스페이스 계층에서 내보내기를 래핑하는 것입니다. 모듈에는 자체 범위가 있으며 내 보낸 선언 만 모듈 외부에서 볼 수 있습니다. 이를 염두에두고 네임 스페이스는 모듈을 사용할 때 가치가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="e0cbb0349fc79c96ec431ec47e8f342090438ecb" translate="yes" xml:space="preserve">
          <source>When importing using the &lt;code&gt;Node&lt;/code&gt; module resolution strategy in TypeScript 2.5, the compiler will now check whether files originate from &amp;ldquo;identical&amp;rdquo; packages. If a file originates from a package with a &lt;code&gt;package.json&lt;/code&gt; containing the same &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;version&lt;/code&gt; fields as a previously encountered package, then TypeScript will redirect itself to the top-most package. This helps resolve problems where two packages might contain identical declarations of classes, but which contain &lt;code&gt;private&lt;/code&gt; members that cause them to be structurally incompatible.</source>
          <target state="translated">TypeScript 2.5에서 &lt;code&gt;Node&lt;/code&gt; 모듈 확인 전략을 사용하여 가져 오면 컴파일러는 파일이 &quot;동일한&quot;패키지에서 시작되었는지 여부를 확인합니다. 파일 이 이전에 발견 된 패키지 와 동일한 &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;version&lt;/code&gt; 필드를 포함 하는 &lt;code&gt;package.json&lt;/code&gt; 이 있는 패키지에서 시작된 경우 TypeScript는 자신을 최상위 패키지로 리디렉션합니다. 이렇게하면 두 패키지에 동일한 클래스 선언이 포함되어 있지만 구조적으로 호환되지 않는 &lt;code&gt;private&lt;/code&gt; 구성원 이 포함 된 문제를 해결하는 데 도움이됩니다 .</target>
        </trans-unit>
        <trans-unit id="e53d751bb35ec11bb8d50707759e0855efc875fb" translate="yes" xml:space="preserve">
          <source>When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the &lt;em&gt;last&lt;/em&gt; signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.</source>
          <target state="translated">여러 호출 서명이있는 유형 (예 : 오버로드 된 함수의 유형)에서 유추 할 때는 &lt;em&gt;마지막&lt;/em&gt; 서명 (아마도 가장 관용적 인 경우) 에서 유추됩니다 . 인수 유형 목록을 기반으로 과부하 해결을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c0e5d12e818f1a128405e0dcf37599e5124ab4c5" translate="yes" xml:space="preserve">
          <source>When input files are specified on the command line, &lt;code&gt;tsconfig.json&lt;/code&gt; files are ignored.</source>
          <target state="translated">명령 행에 입력 파일이 지정되면 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c7dbba16b050a53843a9368cb4cf7aacd6cb532e" translate="yes" xml:space="preserve">
          <source>When install is complete, rebuild!</source>
          <target state="translated">설치가 완료되면 다시 빌드하십시오!</target>
        </trans-unit>
        <trans-unit id="9030ab49af527527a3048a47ea128f0c0c219027" translate="yes" xml:space="preserve">
          <source>When interacting with 3rd-party JavaScript, you may need to use patterns like the above to fully describe the shape of the type.</source>
          <target state="translated">타사 JavaScript와 상호 작용할 때 유형의 모양을 완전히 설명하기 위해 위와 같은 패턴을 사용해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6164dc5fed96c16868282dad3b94f86d550f8593" translate="yes" xml:space="preserve">
          <source>When looking at the code of a global library, you&amp;rsquo;ll usually see:</source>
          <target state="translated">전역 라이브러리의 코드를 볼 때 일반적으로 다음을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b922be38a1d8a16178d415d54259031e8aa4f6f" translate="yes" xml:space="preserve">
          <source>When multiple decorators apply to a single declaration, their evaluation is similar to &lt;a href=&quot;http://en.wikipedia.org/wiki/Function_composition&quot;&gt;function composition in mathematics&lt;/a&gt;. In this model, when composing functions &lt;em&gt;f&lt;/em&gt; and &lt;em&gt;g&lt;/em&gt;, the resulting composite (&lt;em&gt;f&lt;/em&gt; ∘ &lt;em&gt;g&lt;/em&gt;)(&lt;em&gt;x&lt;/em&gt;) is equivalent to &lt;em&gt;f&lt;/em&gt;(&lt;em&gt;g&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;)).</source>
          <target state="translated">여러 데코레이터가 단일 선언에 적용되는 경우 평가는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Function_composition&quot;&gt;수학의 함수 구성&lt;/a&gt; 과 유사합니다 . 이 모델에서 함수 &lt;em&gt;f&lt;/em&gt; 및 &lt;em&gt;g를&lt;/em&gt; 구성 할 때 결과 합성 ( &lt;em&gt;f&lt;/em&gt; ∘ &lt;em&gt;g&lt;/em&gt; ) ( &lt;em&gt;x&lt;/em&gt; )은 &lt;em&gt;f&lt;/em&gt; ( &lt;em&gt;g&lt;/em&gt; ( &lt;em&gt;x&lt;/em&gt; ))와 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f6f6092ccbf1d0a9294c7e4c282859a027ca09d" translate="yes" xml:space="preserve">
          <source>When no best common type is found, the resulting inference is the union array type, &lt;code&gt;(Rhino | Elephant | Snake)[]&lt;/code&gt;.</source>
          <target state="translated">가장 일반적인 유형이 발견되지 않으면 결과 배열은 유니온 배열 유형 &lt;code&gt;(Rhino | Elephant | Snake)[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="577abe4bb126beb561a8efdcb48a28392a4a75af" translate="yes" xml:space="preserve">
          <source>When obtaining the construct signatures of an intersection type that contains mixin constructor types, the mixin construct signatures are discarded and their instance types are mixed into the return types of the other construct signatures in the intersection type. For example, the intersection type &lt;code&gt;{ new(...args: any[]) =&amp;gt; A } &amp;amp; { new(s: string) =&amp;gt; B }&lt;/code&gt; has a single construct signature &lt;code&gt;new(s: string) =&amp;gt; A &amp;amp; B&lt;/code&gt;.</source>
          <target state="translated">mixin 생성자 유형을 포함하는 교차 유형의 구성 시그니처를 확보 할 때 mixin 구성 시그니처는 삭제되고 해당 인스턴스 유형은 교차 유형에서 다른 구성 시그니처의 리턴 유형으로 혼합됩니다. 예를 들어, 교차 유형 &lt;code&gt;{ new(...args: any[]) =&amp;gt; A } &amp;amp; { new(s: string) =&amp;gt; B }&lt;/code&gt; 에는 단일 구문 서명 &lt;code&gt;new(s: string) =&amp;gt; A &amp;amp; B&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5037d7b746e687be44f9da9ad23e7dc846aba52" translate="yes" xml:space="preserve">
          <source>When reading from a union type, you can see any properties that are shared by them:</source>
          <target state="translated">공용체 유형에서 읽을 때 공유 유형을 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35582d74eec1d631b57c2de10a47c90c793d3dde" translate="yes" xml:space="preserve">
          <source>When relating the type of &lt;code&gt;map&lt;/code&gt; in TS 2.4, the language will check whether each parameter is a callback type, and if so, it will ensure that those parameters are checked in a contravariant manner with respect to the current relation.</source>
          <target state="translated">TS 2.4에서 &lt;code&gt;map&lt;/code&gt; 유형과 관련하여 언어는 각 매개 변수가 콜백 유형인지 확인하고, 그렇다면 해당 매개 변수가 현재 관계와 관련하여 반 변형 방식으로 확인되도록합니다.</target>
        </trans-unit>
        <trans-unit id="1ff10b12f6a9033fbc10cf950cc0ed31b94b4a4d" translate="yes" xml:space="preserve">
          <source>When specifying a greeting, you must pass a &lt;code&gt;GreetingSettings&lt;/code&gt; object. This object has the following properties:</source>
          <target state="translated">인사말을 지정할 때 &lt;code&gt;GreetingSettings&lt;/code&gt; 개체를 전달해야 합니다. 이 객체에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="43988d6b430a774a26861955cc54fd9c702d0452" translate="yes" xml:space="preserve">
          <source>When specifying type arguments, you are only required to specify type arguments for the required type parameters. Unspecified type parameters will resolve to their default types.</source>
          <target state="translated">형식 인수를 지정할 때는 필수 형식 매개 변수에 형식 인수 만 지정하면됩니다. 지정되지 않은 유형 매개 변수는 기본 유형으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="1ebe929f8f784ba5280922a50ab6e379d8859057" translate="yes" xml:space="preserve">
          <source>When targeting ES3/ES5, the following code</source>
          <target state="translated">ES3 / ES5를 타겟팅 할 때 다음 코드</target>
        </trans-unit>
        <trans-unit id="156025a3f40907ffeac72e030a3a730a1deebeb1" translate="yes" xml:space="preserve">
          <source>When targeting an ECMAScipt 2015-compliant engine, the compiler will generate &lt;code&gt;for..of&lt;/code&gt; loops to target the built-in iterator implementation in the engine.</source>
          <target state="translated">ECMAScipt 2015 호환 엔진 을 대상으로하는 경우 컴파일러는 엔진에 내장 된 반복기 구현을 대상으로하는 &lt;code&gt;for..of&lt;/code&gt; 루프를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="81f1ae5ab6877859c51c53b6981d29f05adff0a6" translate="yes" xml:space="preserve">
          <source>When targeting an ES5 or ES3-compliant engine, iterators are only allowed on values of &lt;code&gt;Array&lt;/code&gt; type. It is an error to use &lt;code&gt;for..of&lt;/code&gt; loops on non-Array values, even if these non-Array values implement the &lt;code&gt;Symbol.iterator&lt;/code&gt; property.</source>
          <target state="translated">ES5 또는 ES3 호환 엔진을 대상으로하는 경우 반복자는 &lt;code&gt;Array&lt;/code&gt; 유형의 값에만 허용됩니다 . 비 배열 값이 &lt;code&gt;Symbol.iterator&lt;/code&gt; 속성을 구현하더라도 비 배열 값에 &lt;code&gt;for..of&lt;/code&gt; 루프 를 사용하면 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="2fff15c1d3e5e5f2e18f1d4a6ac9350c4a78b3f2" translate="yes" xml:space="preserve">
          <source>When tuple types are inferred for rest parameters, optional parameters in the source become optional tuple elements in the inferred type.</source>
          <target state="translated">나머지 매개 변수에 대해 튜플 유형이 유추되는 경우 소스의 선택적 매개 변수는 유추 된 유형의 선택적 튜플 요소가됩니다.</target>
        </trans-unit>
        <trans-unit id="75737547c96987306eebfed378fbd115f0634d72" translate="yes" xml:space="preserve">
          <source>When using Node module resolution in TypeScript 3.1, when TypeScript cracks open a &lt;code&gt;package.json&lt;/code&gt; file to figure out which files it needs to read, it first looks at a new field called &lt;code&gt;typesVersions&lt;/code&gt;. A &lt;code&gt;package.json&lt;/code&gt; with a &lt;code&gt;typesVersions&lt;/code&gt; field might look like this:</source>
          <target state="translated">TypeScript 3.1에서 Node 모듈 확인을 사용할 때 TypeScript가 &lt;code&gt;package.json&lt;/code&gt; 파일을 열면 어떤 파일을 읽어야하는지 파악할 때 먼저 &lt;code&gt;typesVersions&lt;/code&gt; 라는 새 필드를 확인 합니다. &lt;code&gt;package.json&lt;/code&gt; A를 &lt;code&gt;typesVersions&lt;/code&gt; 의 필드는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="4850716ae612670ae2d56349b6a2660a6446e72a" translate="yes" xml:space="preserve">
          <source>When we do, the compiler will give us an error that we&amp;rsquo;re using the &lt;code&gt;.length&lt;/code&gt; member of &lt;code&gt;arg&lt;/code&gt;, but nowhere have we said that &lt;code&gt;arg&lt;/code&gt; has this member. Remember, we said earlier that these type variables stand in for any and all types, so someone using this function could have passed in a &lt;code&gt;number&lt;/code&gt; instead, which does not have a &lt;code&gt;.length&lt;/code&gt; member.</source>
          <target state="translated">우리가 할 때 컴파일러는 우리에게 &lt;code&gt;arg&lt;/code&gt; 의 &lt;code&gt;.length&lt;/code&gt; 멤버를 사용하고 있다는 오류를 줄 것입니다. 그러나 아무 것도 &lt;code&gt;arg&lt;/code&gt; 에이 멤버 가 있다고 말한 적이 없습니다 . 이전에 이러한 유형 변수는 모든 유형 에 적용 &lt;code&gt;.length&lt;/code&gt; 함수를 사용하는 사람 은 .length 멤버 가없는 &lt;code&gt;number&lt;/code&gt; 대신 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="217dd70751ec70c2507f34daeb4f28f27ba30001" translate="yes" xml:space="preserve">
          <source>When we first touched on the idea of variable capturing with &lt;code&gt;var&lt;/code&gt; declaration, we briefly went into how variables act once captured. To give a better intuition of this, each time a scope is run, it creates an &amp;ldquo;environment&amp;rdquo; of variables. That environment and its captured variables can exist even after everything within its scope has finished executing.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 선언을 사용 하여 변수 캡처라는 개념을 처음 만났을 때 변수가 일단 캡처되면 어떻게 작동하는지 간략히 살펴 보았습니다. 이를보다 잘 이해하기 위해 범위가 실행될 때마다 변수의 &quot;환경&quot;이 생성됩니다. 해당 환경 및 캡처 된 변수는 해당 범위 내의 모든 항목이 실행 된 후에도 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ff7f4efa05e217597245c432a821c2527e220ab" translate="yes" xml:space="preserve">
          <source>When working with classes and interfaces, it helps to keep in mind that a class has &lt;em&gt;two&lt;/em&gt; types: the type of the static side and the type of the instance side. You may notice that if you create an interface with a construct signature and try to create a class that implements this interface you get an error:</source>
          <target state="translated">클래스와 인터페이스로 작업 할 때 클래스에는 &lt;em&gt;두&lt;/em&gt; 가지 유형, 즉 정적 측 유형과 인스턴스 측 유형 이 있음을 명심해야합니다 . 구문 서명이있는 인터페이스를 만들고이 인터페이스를 구현하는 클래스를 만들려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="59ca9320ae741734ed0a3e6c543e8c5deef3ad35" translate="yes" xml:space="preserve">
          <source>When writing in JavaScript files (using &lt;code&gt;allowJs&lt;/code&gt;), TypeScript now recognizes declarations that use &lt;code&gt;Object.defineProperty&lt;/code&gt;. This means you&amp;rsquo;ll get better completions, and stronger type-checking when enabling type-checking in JavaScript files (by turning on the &lt;code&gt;checkJs&lt;/code&gt; option or adding a &lt;code&gt;// @ts-check&lt;/code&gt; comment to the top of your file).</source>
          <target state="translated">JavaScript 파일로 작성할 때 ( &lt;code&gt;allowJs&lt;/code&gt; 사용 ) TypeScript는 이제 &lt;code&gt;Object.defineProperty&lt;/code&gt; 를 사용하는 선언을 인식 합니다. 즉, JavaScript 파일에서 유형 검사를 활성화 할 때 ( &lt;code&gt;checkJs&lt;/code&gt; 옵션을 켜 거나 &lt;code&gt;// @ts-check&lt;/code&gt; 주석을 파일 맨 위에 추가하여) 더 나은 완성도를 달성하고 유형 검사를 강화할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec5f993452425d2ee4ab0f5de68ed85198028eec" translate="yes" xml:space="preserve">
          <source>When you begin to use generics, you&amp;rsquo;ll notice that when you create generic functions like &lt;code&gt;identity&lt;/code&gt;, the compiler will enforce that you use any generically typed parameters in the body of the function correctly. That is, that you actually treat these parameters as if they could be any and all types.</source>
          <target state="translated">제네릭을 사용하기 시작하면 &lt;code&gt;identity&lt;/code&gt; 와 같은 제네릭 함수를 만들 때 컴파일러는 함수 본문에 제네릭 형식 매개 변수를 올바르게 사용하도록 강제합니다. 즉, 실제로는 이러한 매개 변수를 모든 유형이 될 수있는 것처럼 취급합니다.</target>
        </trans-unit>
        <trans-unit id="bb76a0dfbc0b927a30bc60fb3308eae1c0c32030" translate="yes" xml:space="preserve">
          <source>When you declare a class in TypeScript, you are actually creating multiple declarations at the same time. The first is the type of the &lt;em&gt;instance&lt;/em&gt; of the class.</source>
          <target state="translated">TypeScript에서 클래스를 선언하면 실제로 여러 선언을 동시에 만듭니다. 첫 번째는 클래스 &lt;em&gt;인스턴스&lt;/em&gt; 의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="cbca5cdf2d57a23f367d0a1514252e4f2c75c7b6" translate="yes" xml:space="preserve">
          <source>When you reference a project, new things happen:</source>
          <target state="translated">프로젝트를 참조하면 새로운 일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="34a19e5b1b2f656dfeb0df790e074ddaa8c1d34a" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;this&lt;/code&gt; keyword outside of classes, it has the type &lt;code&gt;any&lt;/code&gt; by default. For instance, imagine a &lt;code&gt;Point&lt;/code&gt; class, and imagine a function that we wish to add as a method:</source>
          <target state="translated">클래스 외부 에서 &lt;code&gt;this&lt;/code&gt; 키워드 를 사용하면 기본적으로 &lt;code&gt;any&lt;/code&gt; 유형이 있습니다. 예를 들어 &lt;code&gt;Point&lt;/code&gt; 클래스를 상상하고 메소드로 추가하려는 함수를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="7e741bc3dcef0123eeda11543758853be2aac149" translate="yes" xml:space="preserve">
          <source>Where:</source>
          <target state="translated">Where:</target>
        </trans-unit>
        <trans-unit id="962849684c80963bf61b9a409447ab660d400c45" translate="yes" xml:space="preserve">
          <source>Which in turn can be imported using default imports:</source>
          <target state="translated">기본 가져 오기를 사용하여 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf6447c6242e379fc5cad3f436eb54be60f4dba3" translate="yes" xml:space="preserve">
          <source>Which leads us to writing our first generic interface. Let&amp;rsquo;s take the object literal from the previous example and move it to an interface:</source>
          <target state="translated">첫 번째 일반 인터페이스를 작성하게됩니다. 이전 예제에서 객체 리터럴을 가져 와서 인터페이스로 옮깁니다.</target>
        </trans-unit>
        <trans-unit id="70bd03441762cc2b325aef1bac1f313f2d0e16b5" translate="yes" xml:space="preserve">
          <source>Which translates to:</source>
          <target state="translated">다음과 같이 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="acfe760aa187d990362b3f4c61beb430484ea0d1" translate="yes" xml:space="preserve">
          <source>Which would print this output to the console:</source>
          <target state="translated">이 출력을 콘솔에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="53ebf7ccbab25bb66042f79bfb51a8652406a52d" translate="yes" xml:space="preserve">
          <source>While ECMAScript exports are often a better way of providing this functionality, this new support allows code written in this style to &amp;ldquo;just work&amp;rdquo; TypeScript. Additionally, this approach for property declarations allows us to express common patterns like &lt;code&gt;defaultProps&lt;/code&gt; and &lt;code&gt;propTypes&lt;/code&gt; on React function components (formerly known as SFCs).</source>
          <target state="translated">ECMAScript 내보내기는 종종이 기능을 제공하는 더 좋은 방법이지만,이 새로운 지원을 통해이 스타일로 작성된 코드는 TypeScript를 &quot;작동&quot;할 수 있습니다. 또한 속성 선언에 대한 이러한 접근 방식을 통해 React 함수 구성 요소 (이전의 SFC)에서 &lt;code&gt;defaultProps&lt;/code&gt; 및 &lt;code&gt;propTypes&lt;/code&gt; 와 같은 공통 패턴을 표현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fad58bbb4ff5e3b9b95e4764b17888edf69eef4d" translate="yes" xml:space="preserve">
          <source>While TypeScript 3.7 isn&amp;rsquo;t changing any existing emit by default, we&amp;rsquo;ve been rolling out changes incrementally to help users mitigate potential future breakage. We&amp;rsquo;ve provided a new flag called &lt;code&gt;useDefineForClassFields&lt;/code&gt; to enable this emit mode with some new checking logic.</source>
          <target state="translated">TypeScript 3.7은 기본적으로 기존 방출을 변경하지 않지만 사용자가 향후 파손 가능성을 완화 할 수 있도록 변경 사항을 점진적으로 롤아웃했습니다. 우리는 &lt;code&gt;useDefineForClassFields&lt;/code&gt; 라는 새로운 플래그를 제공하여 새로운 검사 로직으로이 방출 모드를 활성화했습니다.</target>
        </trans-unit>
        <trans-unit id="f56a592c618616410fc71f4bbabb49d78514f411" translate="yes" xml:space="preserve">
          <source>While allowing people to randomly set &lt;code&gt;fullName&lt;/code&gt; directly is pretty handy, we may also want enforce some constraints when &lt;code&gt;fullName&lt;/code&gt; is set.</source>
          <target state="translated">사람들이 임의로 &lt;code&gt;fullName&lt;/code&gt; 을 직접 설정할 수있게하는 것이 매우 편리하지만 &lt;code&gt;fullName&lt;/code&gt; 이 설정 될 때 일부 제약 조건을 적용 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="636d4d19d4405d30263f2aa95da0f2c2a734da53" translate="yes" xml:space="preserve">
          <source>While comparing primitive types and object types is relatively straightforward, the question of what kinds of functions should be considered compatible is a bit more involved. Let&amp;rsquo;s start with a basic example of two functions that differ only in their parameter lists:</source>
          <target state="translated">프리미티브 유형과 객체 유형을 비교하는 것은 비교적 간단하지만, 어떤 유형의 함수가 호환되어야하는지에 대한 문제는 조금 더 복잡합니다. 매개 변수 목록에서만 다른 두 가지 기능의 기본 예부터 시작해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="03a5fd4e6d293c6d495eff753858affb70025397" translate="yes" xml:space="preserve">
          <source>While it&amp;rsquo;s good practice to use &lt;code&gt;ReadonlyArray&lt;/code&gt; over &lt;code&gt;Array&lt;/code&gt; when no mutation is intended, it&amp;rsquo;s often been a pain given that arrays have a nicer syntax. Specifically, &lt;code&gt;number[]&lt;/code&gt; is a shorthand version of &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt;, just as &lt;code&gt;Date[]&lt;/code&gt; is a shorthand for &lt;code&gt;Array&amp;lt;Date&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">그것을 사용하는 것이 좋습니다이지만 &lt;code&gt;ReadonlyArray&lt;/code&gt; 를 통해 &lt;code&gt;Array&lt;/code&gt; 에는 돌연변이가 구성되지 않은 경우가 종종 배열이 더 좋은 구문을 가지고 주어진 고통이었다. 구체적으로, &lt;code&gt;number[]&lt;/code&gt; 는 &lt;code&gt;Date[]&lt;/code&gt; 가 &lt;code&gt;Array&amp;lt;Date&amp;gt;&lt;/code&gt; 의 축약 형인 것처럼 &lt;code&gt;Array&amp;lt;number&amp;gt;&lt;/code&gt; 의 축약 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="2c74aaa3335f7bff7bf6990f82abec0b22352a01" translate="yes" xml:space="preserve">
          <source>While not a breakage per se, opting in to the &lt;code&gt;useDefineForClassFields&lt;/code&gt; flag can cause breakage when:</source>
          <target state="translated">파손 자체는 &lt;code&gt;useDefineForClassFields&lt;/code&gt; 과 같은 경우 useDefineForClassFields 플래그를 선택하면 파손이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebbe87035da271030af0d806842f81f2cc35cc3b" translate="yes" xml:space="preserve">
          <source>While not strictly a language change, nightly builds are now available by installing with the following command:</source>
          <target state="translated">언어 변경은 아니지만 다음 명령으로 설치하면 야간 빌드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3360869251a9b9ea8953b44e203398f6f81cb993" translate="yes" xml:space="preserve">
          <source>While string enums don&amp;rsquo;t have auto-incrementing behavior, string enums have the benefit that they &amp;ldquo;serialize&amp;rdquo; well. In other words, if you were debugging and had to read the runtime value of a numeric enum, the value is often opaque - it doesn&amp;rsquo;t convey any useful meaning on its own (though &lt;a href=&quot;#enums-at-runtime&quot;&gt;reverse mapping&lt;/a&gt; can often help), string enums allow you to give a meaningful and readable value when your code runs, independent of the name of the enum member itself.</source>
          <target state="translated">문자열 열거 형은 자동 증가 동작이 없지만 문자열 열거 형은 &quot;직렬화&quot;하는 이점이 있습니다. 다시 말해, 디버깅 중이고 숫자 열거 형의 런타임 값을 읽어야하는 경우 값이 불투명 한 경우가 많습니다. 자체적으로 유용한 의미를 전달하지는 않습니다 ( &lt;a href=&quot;#enums-at-runtime&quot;&gt;역 맵핑&lt;/a&gt; 이 종종 도움이 될 수 있음). 문자열 열거 형을 사용하면 열거 형 멤버 자체의 이름과 관계없이 코드가 실행될 때 의미 있고 읽기 쉬운 값을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f4c063d2ee2675e04f30864acccf31e9c245c672" translate="yes" xml:space="preserve">
          <source>While string index signatures are a powerful way to describe the &amp;ldquo;dictionary&amp;rdquo; pattern, they also enforce that all properties match their return type. This is because a string index declares that &lt;code&gt;obj.property&lt;/code&gt; is also available as &lt;code&gt;obj[&quot;property&quot;]&lt;/code&gt;. In the following example, &lt;code&gt;name&lt;/code&gt;&amp;rsquo;s type does not match the string index&amp;rsquo;s type, and the type checker gives an error:</source>
          <target state="translated">문자열 인덱스 서명은 &quot;사전&quot;패턴을 설명하는 강력한 방법이지만 모든 속성이 반환 유형과 일치하도록 강제합니다. 문자열 인덱스는 &lt;code&gt;obj.property&lt;/code&gt; 를 &lt;code&gt;obj[&quot;property&quot;]&lt;/code&gt; 로도 사용할 수 있다고 선언하기 때문 입니다. 다음 예에서 &lt;code&gt;name&lt;/code&gt; 유형은 문자열 색인 유형과 일치하지 않으며 유형 검사기는 오류를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="205fbdc2b0eb96d4c083fa10d1cf873197618502" translate="yes" xml:space="preserve">
          <source>While using &lt;code&gt;any&lt;/code&gt; is certainly generic in that it will cause the function to accept any and all types for the type of &lt;code&gt;arg&lt;/code&gt;, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned.</source>
          <target state="translated">함수를 사용하면 &lt;code&gt;arg&lt;/code&gt; 유형에 대해 모든 유형을 받아 들일 수 있다는 점에서 &lt;code&gt;any&lt;/code&gt; 를 사용 하는 것이 일반적 이지만 , 실제로 함수가 반환 될 때 해당 유형이 무엇인지에 대한 정보는 손실됩니다. 우리가 숫자를 전달하면 우리가 가진 유일한 정보는 모든 유형이 반환 될 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3773d499a43f196d119753de15012adfe413581f" translate="yes" xml:space="preserve">
          <source>While you might imagine close interaction between &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;bigint&lt;/code&gt;, the two are separate domains.</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; 와 &lt;code&gt;bigint&lt;/code&gt; 사이의 밀접한 상호 작용을 상상할 수 있지만 두 도메인은 별도의 도메인입니다.</target>
        </trans-unit>
        <trans-unit id="7942bdf53c9b517b254a399642caadffcd723ac5" translate="yes" xml:space="preserve">
          <source>Why does a module in the exclude list still get picked up by the compiler?</source>
          <target state="translated">제외 목록의 모듈이 여전히 컴파일러에 의해 선택되는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="dd7392a9f697967405bb99a3337ee2df7f8bb374" translate="yes" xml:space="preserve">
          <source>Wildcard character in module names</source>
          <target state="translated">모듈 이름의 와일드 카드 문자</target>
        </trans-unit>
        <trans-unit id="90ff022ca86ce297643ad53057127508fda59a21" translate="yes" xml:space="preserve">
          <source>Wildcard module declarations</source>
          <target state="translated">와일드 카드 모듈 선언</target>
        </trans-unit>
        <trans-unit id="e1deac0ee95462765acc0e4d19e587e5b367dac8" translate="yes" xml:space="preserve">
          <source>Wildcard module names can be even more useful when migrating from an un-typed code base. Combined with Shorthand ambient module declarations, a set of modules can be easily declared as &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">와일드 카드 모듈 이름은 유형이 지정되지 않은 코드베이스에서 마이그레이션 할 때 더욱 유용 할 수 있습니다. 속기 주변 모듈 선언과 결합하여 모듈 집합을 &lt;code&gt;any&lt;/code&gt; 로 쉽게 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="294ac8947e55f645c50e17c1f027a18712e8f38f" translate="yes" xml:space="preserve">
          <source>Will generate the following JavaScript output:</source>
          <target state="translated">다음과 같은 JavaScript 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="49659e5a07d9ec9ddbc5ea2cded9dfed86235252" translate="yes" xml:space="preserve">
          <source>Will generate:</source>
          <target state="translated">다음을 생성합니다 :</target>
        </trans-unit>
        <trans-unit id="74eea0f1c70b52371bc0816bb556d0f8780652ce" translate="yes" xml:space="preserve">
          <source>Will produce a &lt;code&gt;.d.ts&lt;/code&gt; file like</source>
          <target state="translated">다음 과 같은 &lt;code&gt;.d.ts&lt;/code&gt; 파일을 생성합니다</target>
        </trans-unit>
        <trans-unit id="8dc5830cdd248d481961de84dd0f5250619d9bd8" translate="yes" xml:space="preserve">
          <source>Will result in assigning the name &lt;code&gt;NamedModule&lt;/code&gt; to the module as part of calling the AMD &lt;code&gt;define&lt;/code&gt;:</source>
          <target state="translated">AMD &lt;code&gt;define&lt;/code&gt; 호출의 일부로 &lt;code&gt;NamedModule&lt;/code&gt; 이라는 이름 을 모듈 에 할당합니다 :</target>
        </trans-unit>
        <trans-unit id="13740d4f0b7aedad3ff699e83aa212feeaefbb89" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--downlevelIteration&lt;/code&gt;, the compiler uses new type check and emit behavior that attempts to call a &lt;code&gt;[Symbol.iterator]()&lt;/code&gt; method on the iterated object if it is found, and creates a synthetic array iterator over the object if it is not.</source>
          <target state="translated">함께 &lt;code&gt;--downlevelIteration&lt;/code&gt; 컴파일러 시도가 호출하는 것이 새로운 종류의 검사 및 발광 동작 사용 &lt;code&gt;[Symbol.iterator]()&lt;/code&gt; 가 발견되면 반복되는 객체의 메소드를, 그렇지 않은 경우에는 오브젝트 위로 합성 배열 반복자를 생성한다.</target>
        </trans-unit>
        <trans-unit id="0baf96b645c93694808d46132810c65e4ff0d180" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--esModuleInterop&lt;/code&gt; two new helpers are generated &lt;code&gt;__importStar&lt;/code&gt; and &lt;code&gt;__importDefault&lt;/code&gt; for import &lt;code&gt;*&lt;/code&gt; and import &lt;code&gt;default&lt;/code&gt; respectively. For instance input like:</source>
          <target state="translated">&lt;code&gt;--esModuleInterop&lt;/code&gt; 을 사용하면 import &lt;code&gt;*&lt;/code&gt; 및 import &lt;code&gt;default&lt;/code&gt; 에 대해 각각 두 개의 새로운 도우미 &lt;code&gt;__importStar&lt;/code&gt; 및 &lt;code&gt;__importDefault&lt;/code&gt; 가 생성 됩니다. 예를 들어 다음과 같은 입력 :</target>
        </trans-unit>
        <trans-unit id="3da68912666fd5861031d156bf5a2c7082eb8729" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt;, this example will trigger an error:</source>
          <target state="translated">&lt;code&gt;--noFallthroughCasesInSwitch&lt;/code&gt; 를 사용하면 이 예제는 오류를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="f2e90c030cc7f4b83e2a77c542e137b8a0ccca5d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--strictNullChecks&lt;/code&gt;, an optional parameter automatically adds &lt;code&gt;| undefined&lt;/code&gt;:</source>
          <target state="translated">함께 &lt;code&gt;--strictNullChecks&lt;/code&gt; , 선택적 매개 변수가 자동으로 추가 &lt;code&gt;| undefined&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="32a499399a274aac8c9b26572f194ee6506912c8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;@constructor&lt;/code&gt;, &lt;code&gt;this&lt;/code&gt; is checked inside the constructor function &lt;code&gt;C&lt;/code&gt;, so you will get suggestions for the &lt;code&gt;initialize&lt;/code&gt; method and an error if you pass it a number. You will also get an error if you call &lt;code&gt;C&lt;/code&gt; instead of constructing it.</source>
          <target state="translated">로 &lt;code&gt;@constructor&lt;/code&gt; , &lt;code&gt;this&lt;/code&gt; 생성자 함수 내에서 체크 &lt;code&gt;C&lt;/code&gt; 당신이 제안 얻을 것이다, 그래서 &lt;code&gt;initialize&lt;/code&gt; 당신이 그것을 숫자 전달하면 방법 및 오류입니다. &lt;code&gt;C&lt;/code&gt; 를 구성하는 대신 C 를 호출하면 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="b1ea5d91d6887a555bb6f2794a07c5714e99ed42" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;import&lt;/code&gt; types available, many of the visibility errors reported during declaration file generation can be handled by the compiler without the need to change the input.</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 유형을 사용 하면 선언 파일 생성 중에보고 된 많은 가시성 오류를 입력을 변경할 필요없이 컴파일러가 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="f84d42cb295076793894c8acadb047e99a4e746a" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;object&lt;/code&gt; type, APIs like &lt;code&gt;Object.create&lt;/code&gt; can be better represented. For example:</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 유형을 사용하면 &lt;code&gt;Object.create&lt;/code&gt; 와 같은 API를 더 잘 표현할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5fa847821456a4401d0546fcc0d18f6208406246" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;this&lt;/code&gt; annotated, you make it explicit that &lt;code&gt;onClickBad&lt;/code&gt; must be called on an instance of &lt;code&gt;Handler&lt;/code&gt;. Then TypeScript will detect that &lt;code&gt;addClickListener&lt;/code&gt; requires a function that has &lt;code&gt;this: void&lt;/code&gt;. To fix the error, change the type of &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">로 &lt;code&gt;this&lt;/code&gt; 주석, 당신은 명시 적 있는지 확인 &lt;code&gt;onClickBad&lt;/code&gt; 이 인스턴스에서 호출해야합니다 &lt;code&gt;Handler&lt;/code&gt; . 그런 다음 TypeScript는 &lt;code&gt;addClickListener&lt;/code&gt; 에 &lt;code&gt;this: void&lt;/code&gt; 함수가 필요 하다는 것을 감지합니다 . 오류를 해결하려면, 유형 변경 &lt;code&gt;this&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="275d348200c6c9320565561ab80694a7f189a460" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;var&lt;/code&gt; declarations, we mentioned that it didn&amp;rsquo;t matter how many times you declared your variables; you just got one.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 선언을 사용하면 변수를 몇 번 선언했는지는 중요하지 않습니다. 당신은 하나를 얻었다.</target>
        </trans-unit>
        <trans-unit id="c9b5a6af6e81107e965d92874d8f98c54b8d5351" translate="yes" xml:space="preserve">
          <source>With ES6&amp;rsquo;s codepoint escapes, you can cleanly represent that exact character in strings and template strings with a single escape: &lt;code&gt;&quot;\u{20bb7}&quot;&lt;/code&gt;. TypeScript will emit the string in ES3/ES5 as &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt;.</source>
          <target state="translated">ES6의 코드 포인트 이스케이프를 사용하면 단일 이스케이프를 사용하여 문자열 및 템플릿 문자열에서 정확한 문자를 명확하게 표현할 수 있습니다 : &lt;code&gt;&quot;\u{20bb7}&quot;&lt;/code&gt; . TypeScript는 ES3 / ES5에서 &lt;code&gt;&quot;\uD842\uDFB7&quot;&lt;/code&gt; 로 문자열을 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="a3fe0d7c3c1bcf18bd50d0141170db310dc43d9e" translate="yes" xml:space="preserve">
          <source>With TypeScript 1.6, type aliases can be generic. For example:</source>
          <target state="translated">TypeScript 1.6을 사용하면 유형 별칭이 일반적 일 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="460f7c766e92b496f73d02d4ccf0cc4d7ee440b6" translate="yes" xml:space="preserve">
          <source>With TypeScript 1.8 it becomes possible for a type parameter constraint to reference type parameters from the same type parameter list. Previously this was an error. This capability is usually referred to as &lt;a href=&quot;https://en.wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification&quot;&gt;F-Bounded Polymorphism&lt;/a&gt;.</source>
          <target state="translated">TypeScript 1.8을 사용하면 형식 매개 변수 제약 조건이 동일한 형식 매개 변수 목록에서 형식 매개 변수를 참조 할 수 있습니다. 이전에는 오류였습니다. 이 기능은 일반적으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Bounded_quantification#F-bounded_quantification&quot;&gt;F-Bounded Polymorphism&lt;/a&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="10bf274b692b3bbc5a7692bb92ffc8f07852abb4" translate="yes" xml:space="preserve">
          <source>With TypeScript 1.8, JSX tags are now classified and colorized in Visual Studio 2015.</source>
          <target state="translated">TypeScript 1.8을 사용하면 이제 JSX 태그가 Visual Studio 2015에서 분류되고 색상이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="c62a9b4ded80d831595f6cf41c707a66d7b472df" translate="yes" xml:space="preserve">
          <source>With TypeScript 1.8, we&amp;rsquo;ve introduced string literal types. These types are written the same way string literals are, but in type positions.</source>
          <target state="translated">TypeScript 1.8에서는 문자열 리터럴 유형이 도입되었습니다. 이러한 유형은 문자열 리터럴과 같은 방식으로 작성되지만 유형 위치에 있습니다.</target>
        </trans-unit>
        <trans-unit id="cafdb66c7fc578df947b8db9b1207f3133582261" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.0, the compiler will look up definition of &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; in &lt;code&gt;./moduleA.ts&lt;/code&gt; or &lt;code&gt;./moduleA.d.t&lt;/code&gt;.</source>
          <target state="translated">TypeScript 2.0을 사용하면 컴파일러는 &lt;code&gt;./moduleA.ts&lt;/code&gt; 또는 &lt;code&gt;./moduleA.d.t&lt;/code&gt; 에서 &lt;code&gt;&quot;moduleA.js&quot;&lt;/code&gt; 의 정의를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="d4f9f7cdd4003c7ab1f53ac08b77e405631b7232" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.1, instead of just choosing &lt;code&gt;any&lt;/code&gt;, TypeScript will infer types based on what you end up assigning later on.</source>
          <target state="translated">TypeScript 2.1에서는을 선택 &lt;code&gt;any&lt;/code&gt; 대신 TypeScript에서 나중에 할당 한 내용에 따라 유형을 유추합니다.</target>
        </trans-unit>
        <trans-unit id="9277e32824b441ad62cb76d21644b7bd58f69e2f" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.1, you can import a JavaScript module without needing a type declaration. A type declaration (such as &lt;code&gt;declare module &quot;foo&quot; { ... }&lt;/code&gt; or &lt;code&gt;node_modules/@types/foo&lt;/code&gt;) still takes priority if it exists.</source>
          <target state="translated">TypeScript 2.1을 사용하면 형식 선언없이 JavaScript 모듈을 가져올 수 있습니다. 유형 선언 (예 : &lt;code&gt;declare module &quot;foo&quot; { ... }&lt;/code&gt; 또는 &lt;code&gt;node_modules/@types/foo&lt;/code&gt; )은 여전히 ​​존재하는 경우 우선 순위를 갖 습니다.</target>
        </trans-unit>
        <trans-unit id="fbf94ecb57bb0f01e4f682c5fcfc23891843f05c" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.8 &lt;code&gt;keyof&lt;/code&gt; applied to an intersection type is transformed to a union of &lt;code&gt;keyof&lt;/code&gt; applied to each intersection constituent. In other words, types of the form &lt;code&gt;keyof (A &amp;amp; B)&lt;/code&gt; are transformed to be &lt;code&gt;keyof A | keyof B&lt;/code&gt;. This change should address inconsistencies with inference from &lt;code&gt;keyof&lt;/code&gt; expressions.</source>
          <target state="translated">타이프 2.8 &lt;code&gt;keyof&lt;/code&gt; 의 조합으로 변환하는 교차 형인가 &lt;code&gt;keyof&lt;/code&gt; 각 교차로의 구성에 적용. 즉, 폼의 종류 &lt;code&gt;keyof (A &amp;amp; B)&lt;/code&gt; 되도록 변환된다 &lt;code&gt;keyof A | keyof B&lt;/code&gt; . 이 변경 사항은 &lt;code&gt;keyof&lt;/code&gt; expression의 추론으로 불일치를 해결해야합니다 .</target>
        </trans-unit>
        <trans-unit id="799099f20671837db4b655a12286097f02ebcd18" translate="yes" xml:space="preserve">
          <source>With TypeScript 2.9, no errors are reported, and now the generated file looks like:</source>
          <target state="translated">TypeScript 2.9에서는 오류가보고되지 않으며 이제 생성 된 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d61e7a4d8ea1ab6a29d0ab09e04c9367f5313f2f" translate="yes" xml:space="preserve">
          <source>With TypeScript being a superset of JavaScript, the language naturally supports &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. Here we&amp;rsquo;ll elaborate more on these new declarations and why they&amp;rsquo;re preferable to &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">TypeScript는 JavaScript의 상위 집합이므로 자연스럽게 &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 를 지원합니다 . 여기서는 이러한 새로운 선언과 &lt;code&gt;var&lt;/code&gt; 보다 선호되는 이유에 대해 자세히 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="82f558e3e809cb29cfb2ac66cc2514576d7422f4" translate="yes" xml:space="preserve">
          <source>With definite assignment assertions, we can assert that &lt;code&gt;x&lt;/code&gt; is really assigned by appending an &lt;code&gt;!&lt;/code&gt; to its declaration:</source>
          <target state="translated">명확한 할당 어설 션을 사용 하면 &lt;code&gt;!&lt;/code&gt; 를 추가하여 &lt;code&gt;x&lt;/code&gt; 가 실제로 할당 되었다고 주장 할 수 있습니다 . 그 선언에 :</target>
        </trans-unit>
        <trans-unit id="1b9ea4bd3d43c0f24f8d1235be222ef088964840" translate="yes" xml:space="preserve">
          <source>With generic parameter defaults we can reduce it to:</source>
          <target state="translated">일반 매개 변수 기본값을 사용하면 다음과 같이 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="285525d91c532d67502baa5d535e42948f1fec46" translate="yes" xml:space="preserve">
          <source>With index types, you can get the compiler to check code that uses dynamic property names. For example, a common JavaScript pattern is to pick a subset of properties from an object:</source>
          <target state="translated">인덱스 유형을 사용하면 컴파일러가 동적 속성 이름을 사용하는 코드를 확인하도록 할 수 있습니다. 예를 들어 일반적인 JavaScript 패턴은 객체에서 속성의 하위 집합을 선택하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="16dcd92f3ae6feec4cfbb7198eb7027566939a02" translate="yes" xml:space="preserve">
          <source>With more &lt;code&gt;tsconfig.json&lt;/code&gt; files, you&amp;rsquo;ll usually want to use &lt;a href=&quot;tsconfig-json&quot;&gt;Configuration file inheritance&lt;/a&gt; to centralize your common compiler options. This way you can change a setting in one file rather than having to edit multiple files.</source>
          <target state="translated">더 많은 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일이 있으면 일반적으로 &lt;a href=&quot;tsconfig-json&quot;&gt;구성 파일 상속&lt;/a&gt; 을 사용 하여 공통 컴파일러 옵션을 중앙 집중화 하려고합니다 . 이렇게하면 여러 파일을 편집하지 않고 한 파일에서 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc980dcbd81da3823a44dd1638ddc07a1ed0b4b4" translate="yes" xml:space="preserve">
          <source>With the introduction of Classes in TypeScript and ES6, there now exist certain scenarios that require additional features to support annotating or modifying classes and class members. Decorators provide a way to add both annotations and a meta-programming syntax for class declarations and members. Decorators are a &lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot;&gt;stage 2 proposal&lt;/a&gt; for JavaScript and are available as an experimental feature of TypeScript.</source>
          <target state="translated">TypeScript 및 ES6에 클래스가 도입됨에 따라 이제 클래스 및 클래스 멤버에 주석을 달거나 수정하기 위해 추가 기능이 필요한 특정 시나리오가 있습니다. 데코레이터는 클래스 선언과 멤버에 대한 주석과 메타 프로그래밍 구문을 모두 추가 할 수있는 방법을 제공합니다. 데코레이터는 JavaScript에 대한 &lt;a href=&quot;https://github.com/tc39/proposal-decorators&quot;&gt;2 단계 제안&lt;/a&gt; 이며 TypeScript의 실험 기능으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f8c7c6883f9c76d8e00e3e2c0ffe4b6a8b55fa95" translate="yes" xml:space="preserve">
          <source>With these features it becomes possible to strongly type a number of higher-order functions that transform functions and their parameter lists.</source>
          <target state="translated">이러한 기능을 사용하면 함수 및 해당 매개 변수 목록을 변환하는 여러 고차 함수를 강력하게 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="433e4f23f467e7ae0dc8cfdd04d371137cd886c1" translate="yes" xml:space="preserve">
          <source>With this change, the overloads now give us type checked calls to the &lt;code&gt;pickCard&lt;/code&gt; function.</source>
          <target state="translated">이 변경으로 과부하는 이제 &lt;code&gt;pickCard&lt;/code&gt; 함수 에 대한 유형 검사 호출을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="50288405a714a4c057a990453fc548fab19c0a86" translate="yes" xml:space="preserve">
          <source>With union types able to represent a wide range of type scenarios, we&amp;rsquo;ve decided to improve the strictness of certain generic calls. Previously, code like this would (surprisingly) compile without error:</source>
          <target state="translated">통합 유형이 광범위한 유형 시나리오를 나타낼 수 있으므로 특정 일반 호출의 엄격 성을 개선하기로 결정했습니다. 이전에는 다음과 같은 코드가 놀랍게도 오류없이 컴파일되었습니다.</target>
        </trans-unit>
        <trans-unit id="4aaf334cc02fe3036ee03973d99bc9627c8d8c34" translate="yes" xml:space="preserve">
          <source>With union types, you can now specify the desired behavior at both the function declaration site and the call site:</source>
          <target state="translated">공용체 유형을 사용하면 함수 선언 사이트와 호출 사이트 모두에서 원하는 동작을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1faa6ed78c77561690bfff2329835e7f699fad40" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;Control&lt;/code&gt; class it is possible to access the &lt;code&gt;state&lt;/code&gt; private member through an instance of &lt;code&gt;SelectableControl&lt;/code&gt;. Effectively, a &lt;code&gt;SelectableControl&lt;/code&gt; acts like a &lt;code&gt;Control&lt;/code&gt; that is known to have a &lt;code&gt;select&lt;/code&gt; method. The &lt;code&gt;Button&lt;/code&gt; and &lt;code&gt;TextBox&lt;/code&gt; classes are subtypes of &lt;code&gt;SelectableControl&lt;/code&gt; (because they both inherit from &lt;code&gt;Control&lt;/code&gt; and have a &lt;code&gt;select&lt;/code&gt; method), but the &lt;code&gt;Image&lt;/code&gt; and &lt;code&gt;Location&lt;/code&gt; classes are not.</source>
          <target state="translated">&lt;code&gt;Control&lt;/code&gt; 클래스 내에서 &lt;code&gt;SelectableControl&lt;/code&gt; 인스턴스를 통해 &lt;code&gt;state&lt;/code&gt; 개인 멤버 에 액세스 할 수 있습니다 . 효과적으로 &lt;code&gt;SelectableControl&lt;/code&gt; 은 &lt;code&gt;select&lt;/code&gt; 메서드 가있는 것으로 알려진 &lt;code&gt;Control&lt;/code&gt; 처럼 작동 합니다. &lt;code&gt;Button&lt;/code&gt; 및 &lt;code&gt;TextBox&lt;/code&gt; 클래스의 서브 타입이다 &lt;code&gt;SelectableControl&lt;/code&gt; (에서 그들 때문에 모두 상속 &lt;code&gt;Control&lt;/code&gt; 하고있는 &lt;code&gt;select&lt;/code&gt; 방법)하지만, &lt;code&gt;Image&lt;/code&gt; 및 &lt;code&gt;Location&lt;/code&gt; 클래스는 없습니다.</target>
        </trans-unit>
        <trans-unit id="11991f5f3539f8365b2755a33096a790d376c466" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;extends&lt;/code&gt; clause of a conditional type, it is now possible to have &lt;code&gt;infer&lt;/code&gt; declarations that introduce a type variable to be inferred. Such inferred type variables may be referenced in the true branch of the conditional type. It is possible to have multiple &lt;code&gt;infer&lt;/code&gt; locations for the same type variable.</source>
          <target state="translated">조건부 유형 의 &lt;code&gt;extends&lt;/code&gt; 절 내에서 유추 될 유형 변수를 도입하는 &lt;code&gt;infer&lt;/code&gt; 선언 을 가질 수 있습니다. 이러한 유추 된 유형 변수는 조건부 유형의 실제 분기에서 참조 될 수 있습니다. 동일한 유형 변수에 대해 여러 개의 &lt;code&gt;infer&lt;/code&gt; 위치 를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="025d407dde53ca8d56d3a7b67f8687df35d8b119" translate="yes" xml:space="preserve">
          <source>Within the same block duplicate definitions are still disallowed.</source>
          <target state="translated">동일한 블록 내에서 중복 정의는 여전히 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="244687c671b9bf5c3bf00c75ac23daf9254dabd2" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;this&lt;/code&gt; types, &lt;code&gt;ScientificCalculator&lt;/code&gt; would not have been able to extend &lt;code&gt;BasicCalculator&lt;/code&gt; and keep the fluent interface. &lt;code&gt;multiply&lt;/code&gt; would have returned &lt;code&gt;BasicCalculator&lt;/code&gt;, which doesn&amp;rsquo;t have the &lt;code&gt;sin&lt;/code&gt; method. However, with &lt;code&gt;this&lt;/code&gt; types, &lt;code&gt;multiply&lt;/code&gt; returns &lt;code&gt;this&lt;/code&gt;, which is &lt;code&gt;ScientificCalculator&lt;/code&gt; here.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 유형 이 없으면 &lt;code&gt;ScientificCalculator&lt;/code&gt; 는 &lt;code&gt;BasicCalculator&lt;/code&gt; 를 확장 하고 유창한 인터페이스를 유지할 수 없었습니다 . &lt;code&gt;multiply&lt;/code&gt; 반환 것 &lt;code&gt;BasicCalculator&lt;/code&gt; 이없는, &lt;code&gt;sin&lt;/code&gt; 방법을. 그러나으로 &lt;code&gt;this&lt;/code&gt; 유형의 &lt;code&gt;multiply&lt;/code&gt; 리턴 &lt;code&gt;this&lt;/code&gt; 되는, &lt;code&gt;ScientificCalculator&lt;/code&gt; 는 여기.</target>
        </trans-unit>
        <trans-unit id="4e062851d9b41c2fc52e761a5a5db277213a8a79" translate="yes" xml:space="preserve">
          <source>Without generics, we would either have to give the identity function a specific type:</source>
          <target state="translated">제네릭이 없으면 identity 함수에 특정 유형을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f67c21f22ceab8ce26ba774a06869c3e5ea9d49" translate="yes" xml:space="preserve">
          <source>Working with Generic Type Variables</source>
          <target state="translated">제네릭 형식 변수 작업</target>
        </trans-unit>
        <trans-unit id="5dec7390553f0c8e11febdec62abeb23d870ba14" translate="yes" xml:space="preserve">
          <source>Working with Other JavaScript Libraries</source>
          <target state="translated">다른 JavaScript 라이브러리로 작업</target>
        </trans-unit>
        <trans-unit id="944e87083d9fc0d208f24e3ca6004e001d6ee8c0" translate="yes" xml:space="preserve">
          <source>Write a HTML page</source>
          <target state="translated">HTML 페이지 작성</target>
        </trans-unit>
        <trans-unit id="9a3206c5e21cfc9c171ea878cfc1acee74565cd8" translate="yes" xml:space="preserve">
          <source>Write a simple example</source>
          <target state="translated">간단한 예를 작성하십시오</target>
        </trans-unit>
        <trans-unit id="e885a108400a007a39fa103119566542fbe5da72" translate="yes" xml:space="preserve">
          <source>Write some code</source>
          <target state="translated">일부 코드 작성</target>
        </trans-unit>
        <trans-unit id="efab40cfd729fdef6a3321a502f603a5fd3d1efd" translate="yes" xml:space="preserve">
          <source>Write-only references now flagged as unused</source>
          <target state="translated">쓰기 전용 참조가 이제 사용되지 않은 것으로 플래그 지정됨</target>
        </trans-unit>
        <trans-unit id="1f09dbf6607d2b3a3fef434b06897c0d44094e34" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; directive atop every generated file.</source>
          <target state="translated">&lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; 씁니다 . 생성 된 모든 파일 위에 지시문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="caefe3ddb12a11eef5e5aa559be74af44b08a512" translate="yes" xml:space="preserve">
          <source>Writing a Configuration File</source>
          <target state="translated">구성 파일 작성</target>
        </trans-unit>
        <trans-unit id="8d3bf80dd76a472762dc04013242f325f5d4630a" translate="yes" xml:space="preserve">
          <source>Writing the function type</source>
          <target state="translated">함수 타입 작성</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="124e1188da963d3aaab4e295c7a108fbd2a41dd4" translate="yes" xml:space="preserve">
          <source>You &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; see:</source>
          <target state="translated">당신 &lt;em&gt;은&lt;/em&gt; 볼 수 &lt;em&gt;없습니다&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="a0826b2d3de77311d09a836d3625c330fde392d4" translate="yes" xml:space="preserve">
          <source>You also need to include &lt;code&gt;esnext&lt;/code&gt; in your &lt;code&gt;--lib&lt;/code&gt; option, to get the &lt;code&gt;AsyncIterator&lt;/code&gt; declaration if you do not already have it.</source>
          <target state="translated">당신은 또한 포함 할 필요가 &lt;code&gt;esnext&lt;/code&gt; 당신에 &lt;code&gt;--lib&lt;/code&gt; 얻기 위해, 옵션 &lt;code&gt;AsyncIterator&lt;/code&gt; 의 당신이 이미없는 경우 선언.</target>
        </trans-unit>
        <trans-unit id="62d178984134105b099386ca1a8bdc43d115ba87" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29435&quot;&gt;see more details in the pull request&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29435&quot;&gt;풀 요청에서 자세한 내용을 볼&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4fc0ff3454e62e27b1d1616762b98ba9e340784f" translate="yes" xml:space="preserve">
          <source>You can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32028&quot;&gt;read up more about this change by reading up on its pull request&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32028&quot;&gt;끌어 오기 요청을 읽으면이 변경 사항에 대해 자세히 읽을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f2d37b1f71e5cef3cd269ee2fede52081b3627c" translate="yes" xml:space="preserve">
          <source>You can also add declarations to the global scope from inside a module:</source>
          <target state="translated">모듈 내부에서 전역 범위에 선언을 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa5e7508cbf31286f90d3fa92778943caff41bbb" translate="yes" xml:space="preserve">
          <source>You can also create nested namespaces in one declaration:</source>
          <target state="translated">하나의 선언으로 중첩 네임 스페이스를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9e0636992c973f4dd8a12b1aab83b4e3dc21c83" translate="yes" xml:space="preserve">
          <source>You can also describe methods in an interface that are implemented in the class, as we do with &lt;code&gt;setTime&lt;/code&gt; in the below example:</source>
          <target state="translated">아래 예제에서 &lt;code&gt;setTime&lt;/code&gt; 을 사용하는 것처럼 클래스에 구현 된 인터페이스에서 메소드를 설명 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10881a4ac29a88d1e8e385325bacc892d71cbc57" translate="yes" xml:space="preserve">
          <source>You can also destructure objects:</source>
          <target state="translated">객체를 구조 해제 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f263658c8957170383fc6acd098a9e253a17a6eb" translate="yes" xml:space="preserve">
          <source>You can also enable prepending the output of a dependency using the &lt;code&gt;prepend&lt;/code&gt; option in a reference:</source>
          <target state="translated">참조에서 &lt;code&gt;prepend&lt;/code&gt; 옵션을 사용하여 종속성 출력 앞에 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a3ee9c0b30719b4ec3010d9b67f41513948956a" translate="yes" xml:space="preserve">
          <source>You can also give different names to properties:</source>
          <target state="translated">속성에 다른 이름을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa56c11bed0da0fe19acfcb08f266a5ef3e86db8" translate="yes" xml:space="preserve">
          <source>You can also import declarations from other files using import types. This syntax is Typescript-specific and differs from the JSDoc standard:</source>
          <target state="translated">가져 오기 유형을 사용하여 다른 파일에서 선언을 가져올 수도 있습니다. 이 구문은 Typescript에 따라 다르며 JSDoc 표준과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="dca8a7aa37da66a7e0661bda41e830a52a5189ae" translate="yes" xml:space="preserve">
          <source>You can also override existing properties and add new ones:</source>
          <target state="translated">기존 속성을 재정의하고 새 속성을 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e783edc2ccbd9e24ba2f903e758def00265edb8b" translate="yes" xml:space="preserve">
          <source>You can also run into errors with &lt;code&gt;this&lt;/code&gt; in callbacks, when you pass functions to a library that will later call them. Because the library that calls your callback will call it like a normal function, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt;. With some work you can use &lt;code&gt;this&lt;/code&gt; parameters to prevent errors with callbacks too. First, the library author needs to annotate the callback type with &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">나중에 콜백 할 함수를 라이브러리에 전달할 때 콜백에서 &lt;code&gt;this&lt;/code&gt; 인해 오류가 발생할 수 있습니다 . 콜백을 호출 라이브러리가 일반 함수처럼 호출하기 때문에 &lt;code&gt;this&lt;/code&gt; 될 것입니다 &lt;code&gt;undefined&lt;/code&gt; . 일부 작업에서는 &lt;code&gt;this&lt;/code&gt; 매개 변수를 사용 하여 콜백 오류를 방지 할 수 있습니다 . 먼저 라이브러리 작성자는 다음 과 &lt;code&gt;this&lt;/code&gt; 콜백 유형에 주석을 달아야합니다 .</target>
        </trans-unit>
        <trans-unit id="8bc617eb0b3c708d101d575cea082665b2e4c486" translate="yes" xml:space="preserve">
          <source>You can also specify a type constraint before the type parameter name. Only the first type parameter in a list is constrained:</source>
          <target state="translated">유형 매개 변수 이름 앞에 유형 제한 조건을 지정할 수도 있습니다. 목록의 첫 번째 유형 매개 변수 만 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="d00d3142af394bb2294c1c64058dcebe2e496a01" translate="yes" xml:space="preserve">
          <source>You can also specify object literal types. For example, an object with properties &amp;lsquo;a&amp;rsquo; (string) and &amp;lsquo;b&amp;rsquo; (number) uses the following syntax:</source>
          <target state="translated">객체 리터럴 유형을 지정할 수도 있습니다. 예를 들어 속성이 'a'(문자열) 및 'b'(숫자) 인 객체는 다음 구문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fe8328cdac7d502c96b86354aece870f05fd04b3" translate="yes" xml:space="preserve">
          <source>You can also spread objects:</source>
          <target state="translated">객체를 펼칠 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1908bbe93e9847a90199e01d70ec2bf4ba120262" translate="yes" xml:space="preserve">
          <source>You can also update your IDE to use the nightly drop. First you will need to install the package through npm. You can either install the npm package globally or to a local &lt;code&gt;node_modules&lt;/code&gt; folder.</source>
          <target state="translated">야간 드롭을 사용하도록 IDE를 업데이트 할 수도 있습니다. 먼저 npm을 통해 패키지를 설치해야합니다. npm 패키지를 전체적으로 또는 로컬 &lt;code&gt;node_modules&lt;/code&gt; 폴더에 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2fd769df0df5d6f0aa6315e5bbbcccdf2351c2f6" translate="yes" xml:space="preserve">
          <source>You can also use &lt;em&gt;template strings&lt;/em&gt;, which can span multiple lines and have embedded expressions. These strings are surrounded by the backtick/backquote (&lt;code&gt;`&lt;/code&gt;) character, and embedded expressions are of the form &lt;code&gt;${ expr }&lt;/code&gt;.</source>
          <target state="translated">여러 줄에 걸쳐 있고 포함 된 표현식을 가질 수있는 &lt;em&gt;템플릿 문자열&lt;/em&gt; 을 사용할 수도 있습니다 . 이 문자열은 역 따옴표 / 역 따옴표 ( &lt;code&gt;`&lt;/code&gt; ) 문자로 묶여 있으며 포함 된 표현식은 &lt;code&gt;${ expr }&lt;/code&gt; 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="f55dd36012d4dbcf4dacc5832f2294fe2f575c7c" translate="yes" xml:space="preserve">
          <source>You can assign an object literal directly to the prototype property. Individual prototype assignments still work too:</source>
          <target state="translated">프로토 타입 속성에 직접 객체 리터럴을 할당 할 수 있습니다. 개별 프로토 타입 할당도 여전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8c16422cd5326d69a5eb84cd5f6aae392dfed484" translate="yes" xml:space="preserve">
          <source>You can call the function &lt;code&gt;greet&lt;/code&gt; with a string to show a greeting to the user.</source>
          <target state="translated">문자열로 &lt;code&gt;greet&lt;/code&gt; 함수를 호출 하여 사용자에게 인사말을 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a7ff571453a3f2b2057590cf96aa4493691af9b" translate="yes" xml:space="preserve">
          <source>You can combine singleton types, union types, type guards, and type aliases to build an advanced pattern called &lt;em&gt;discriminated unions&lt;/em&gt;, also known as &lt;em&gt;tagged unions&lt;/em&gt; or &lt;em&gt;algebraic data types&lt;/em&gt;. Discriminated unions are useful in functional programming. Some languages automatically discriminate unions for you; TypeScript instead builds on JavaScript patterns as they exist today. There are three ingredients:</source>
          <target state="translated">싱글 톤 유형, 조합 유형, 유형 가드 및 유형 별명을 &lt;em&gt;결합&lt;/em&gt; 하여 &lt;em&gt;태그가있는 조합&lt;/em&gt; 또는 &lt;em&gt;대수 데이터 유형&lt;/em&gt; 이라고하는 &lt;em&gt;구별 된 조합&lt;/em&gt; 이라는 고급 패턴을 작성할 수 &lt;em&gt;있습니다&lt;/em&gt; . 차별적 노동 조합은 기능적 프로그래밍에 유용하다. 일부 언어는 자동으로 노조를 차별합니다. 대신 TypeScript는 오늘날 존재하는 JavaScript 패턴을 기반으로합니다. 세 가지 성분이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d357850b01dac1eeac6457b17d7ca5319c972ef" translate="yes" xml:space="preserve">
          <source>You can construct a &lt;code&gt;Point&lt;/code&gt; by assigning an object literal. After the assignment, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; can&amp;rsquo;t be changed.</source>
          <target state="translated">객체 리터럴을 할당하여 &lt;code&gt;Point&lt;/code&gt; 를 구성 할 수 있습니다 . 할당 후에는 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4fb6b2a81bd2b7aaa5985f5e53a25640c10196cd" translate="yes" xml:space="preserve">
          <source>You can create a greeter by instantiating the &lt;code&gt;Greeter&lt;/code&gt; object, or create a customized greeter by extending from it.</source>
          <target state="translated">&lt;code&gt;Greeter&lt;/code&gt; 객체 를 인스턴스화하여 인사말을 작성하거나 확장하여 사용자 정의 된 인사말을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75665cb8837cc0487308ee22852413c93f1fc259" translate="yes" xml:space="preserve">
          <source>You can create a variable for the remaining items in a list using the syntax &lt;code&gt;...&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;...&lt;/code&gt; 구문을 사용하여 목록의 나머지 항목에 대한 변수를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8460f1444f4aa17633ac5c787a8314796932f6a5" translate="yes" xml:space="preserve">
          <source>You can create a variable for the remaining items in an object using the syntax &lt;code&gt;...&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;...&lt;/code&gt; 구문을 사용하여 객체의 나머지 항목에 대한 변수를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="671e7dc200d0c80a25936e430c7090352f3d72ae" translate="yes" xml:space="preserve">
          <source>You can declare a type parameter that is constrained by another type parameter. For example, here we&amp;rsquo;d like to get a property from an object given its name. We&amp;rsquo;d like to ensure that we&amp;rsquo;re not accidentally grabbing a property that does not exist on the &lt;code&gt;obj&lt;/code&gt;, so we&amp;rsquo;ll place a constraint between the two types:</source>
          <target state="translated">다른 유형 매개 변수로 제한되는 유형 매개 변수를 선언 할 수 있습니다. 예를 들어, 여기 이름이 지정된 객체에서 속성을 가져 오려고합니다. 실수로 &lt;code&gt;obj&lt;/code&gt; 에 존재하지 않는 속성을 가져 오지 않도록하기 위해 두 가지 유형 사이에 제약 조건을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="f192a3654a48e7ea0a0cc0a370781ac7a446e607" translate="yes" xml:space="preserve">
          <source>You can declare generic types with the &lt;code&gt;@template&lt;/code&gt; tag:</source>
          <target state="translated">&lt;code&gt;@template&lt;/code&gt; 태그를 사용하여 제네릭 형식을 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="578813d014f5da6ccea41bacd872a0d259c87786" translate="yes" xml:space="preserve">
          <source>You can find more documentation on baseUrl in &lt;a href=&quot;http://requirejs.org/docs/api.html#config-baseUrl&quot;&gt;RequireJS&lt;/a&gt; and &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#baseurl&quot;&gt;SystemJS&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;http://requirejs.org/docs/api.html#config-baseUrl&quot;&gt;RequireJS&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/config-api.html#baseurl&quot;&gt;SystemJS&lt;/a&gt; 문서 에서 baseUrl에 대한 추가 문서를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ba620983de41a7ef95236f421d1dc97955b1aa9" translate="yes" xml:space="preserve">
          <source>You can find the full list of supported JSDoc patterns &lt;a href=&quot;#supported-jsdoc&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">지원되는 JSDoc 패턴의 전체 목록은 &lt;a href=&quot;#supported-jsdoc&quot;&gt;아래에서&lt;/a&gt; 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f608f667f472aa22cebd5f33fb938554db51b9e" translate="yes" xml:space="preserve">
          <source>You can fully understand how to make any shape of definition by understanding some key concepts of how TypeScript works.</source>
          <target state="translated">TypeScript의 작동 방식에 대한 몇 가지 주요 개념을 이해하면 모든 형태의 정의를 만드는 방법을 완전히 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffbbf130c4a666890a749997011788aa15e53216" translate="yes" xml:space="preserve">
          <source>You can have TypeScript raise errors when this happens via the compiler flag &lt;code&gt;strictFunctionTypes&lt;/code&gt;.</source>
          <target state="translated">컴파일러 플래그 &lt;code&gt;strictFunctionTypes&lt;/code&gt; 를 통해 이러한 상황이 발생하면 TypeScript에서 오류를 발생시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7cf81fd3fe04126a6e45600ef8b2c4d2d493009" translate="yes" xml:space="preserve">
          <source>You can install this library via npm:</source>
          <target state="translated">npm을 통해이 라이브러리를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="947cee68bd128ad7579db636c222ec6f612e50a8" translate="yes" xml:space="preserve">
          <source>You can learn more about &lt;code&gt;tsconfig.json&lt;/code&gt; files &lt;a href=&quot;tsconfig-json&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 파일 에 대한 자세한 내용은 &lt;a href=&quot;tsconfig-json&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0002bbb784dd22adfca99735cd3bee016fc7bc2f" translate="yes" xml:space="preserve">
          <source>You can learn more about configuring webpack &lt;a href=&quot;https://webpack.js.org/concepts&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">웹팩 구성에 대한 자세한 내용은 &lt;a href=&quot;https://webpack.js.org/concepts&quot;&gt;여기를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2acea5010ea541a31bcbc5992b38da22bdf966f2" translate="yes" xml:space="preserve">
          <source>You can make properties readonly by using the &lt;code&gt;readonly&lt;/code&gt; keyword. Readonly properties must be initialized at their declaration or in the constructor.</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 키워드 를 사용하여 속성을 읽기 전용으로 만들 수 있습니다 . 읽기 전용 속성은 선언 또는 생성자에서 초기화해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ac33330400d5a0e5b89b577a3c10f0de7e4e12f" translate="yes" xml:space="preserve">
          <source>You can now define an &lt;em&gt;alias&lt;/em&gt; for a type using the &lt;code&gt;type&lt;/code&gt; keyword:</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; 키워드를 사용하여 유형 의 &lt;em&gt;별칭&lt;/em&gt; 을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e434657788b8ddc40cdc0edab54832db855ade3" translate="yes" xml:space="preserve">
          <source>You can pass any of the three allowed strings, but any other string will give the error</source>
          <target state="translated">허용되는 세 문자열 중 하나를 전달할 수 있지만 다른 문자열은 오류를 발생시킵니다</target>
        </trans-unit>
        <trans-unit id="d470740bd26919fb50f6301789d422e287938cf6" translate="yes" xml:space="preserve">
          <source>You can provide &lt;code&gt;tsc -b&lt;/code&gt; with multiple config file paths (e.g. &lt;code&gt;tsc -b src test&lt;/code&gt;). Just like &lt;code&gt;tsc -p&lt;/code&gt;, specifying the config file name itself is unnecessary if it&amp;rsquo;s named &lt;code&gt;tsconfig.json&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tsc -b&lt;/code&gt; 에 여러 구성 파일 경로를 제공 할 수 있습니다 (예 : &lt;code&gt;tsc -b src test&lt;/code&gt; ). &lt;code&gt;tsc -p&lt;/code&gt; 와 마찬가지로 이름이 &lt;code&gt;tsconfig.json&lt;/code&gt; 인 경우 구성 파일 이름 자체를 지정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1f0c4b0cf188a255ee3afb8b2ea5e76910a20990" translate="yes" xml:space="preserve">
          <source>You can read more about the process in Node.js documentation on &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders&quot;&gt;loading modules from &lt;code&gt;node_modules&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders&quot;&gt; &lt;code&gt;node_modules&lt;/code&gt; &lt;/a&gt; 에서 모듈 을 로드 하는 방법에 대한 Node.js 문서의 프로세스에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01c1237490875a34de9e3a6f34ec2e6bab8560cf" translate="yes" xml:space="preserve">
          <source>You can read more about this in Node.js documentation on &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_file_modules&quot;&gt;file modules&lt;/a&gt; and &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_folders_as_modules&quot;&gt;folder modules&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://nodejs.org/api/modules.html#modules_file_modules&quot;&gt;파일 모듈&lt;/a&gt; 및 &lt;a href=&quot;https://nodejs.org/api/modules.html#modules_folders_as_modules&quot;&gt;폴더 모듈&lt;/a&gt; 에 대한 Node.js 문서에서 이에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecd3a208f74e578df2b2a2fa60c227e643c4ba88" translate="yes" xml:space="preserve">
          <source>You can read the type of &lt;code&gt;loggingIdentity&lt;/code&gt; as &amp;ldquo;the generic function &lt;code&gt;loggingIdentity&lt;/code&gt; takes a type parameter &lt;code&gt;T&lt;/code&gt;, and an argument &lt;code&gt;arg&lt;/code&gt; which is an array of &lt;code&gt;T&lt;/code&gt;s, and returns an array of &lt;code&gt;T&lt;/code&gt;s.&amp;rdquo; If we passed in an array of numbers, we&amp;rsquo;d get an array of numbers back out, as &lt;code&gt;T&lt;/code&gt; would bind to &lt;code&gt;number&lt;/code&gt;. This allows us to use our generic type variable &lt;code&gt;T&lt;/code&gt; as part of the types we&amp;rsquo;re working with, rather than the whole type, giving us greater flexibility.</source>
          <target state="translated">당신의 유형을 읽을 수 &lt;code&gt;loggingIdentity&lt;/code&gt; 을 &quot;일반 기능으로 &lt;code&gt;loggingIdentity&lt;/code&gt; 이 매개 변수 유형 소요 &lt;code&gt;T&lt;/code&gt; 및 인수 &lt;code&gt;arg&lt;/code&gt; 의 배열입니다 &lt;code&gt;T&lt;/code&gt; 의, 반환의 배열 &lt;code&gt;T&lt;/code&gt; 들.&quot; 숫자 배열을 전달하면 &lt;code&gt;T&lt;/code&gt; 가 &lt;code&gt;number&lt;/code&gt; 에 바인딩 되므로 숫자 배열을 다시 얻습니다 . 이를 통해 일반 유형 변수 &lt;code&gt;T&lt;/code&gt; 를 전체 유형이 아닌 작업중인 유형의 일부로 사용할 수 있어 유연성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="4219455f5a7b401b488cbe6f3cc25db24a4f9204" translate="yes" xml:space="preserve">
          <source>You can see an example of using Webpack in our &lt;a href=&quot;react-&amp;amp;-webpack&quot;&gt;tutorial on React and Webpack&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;react-&amp;amp;-webpack&quot;&gt;React 및 Webpack 튜토리얼에서&lt;/a&gt; Webpack 사용 예를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="522afc6f6129110c8704aded05f62e148f7fcfe8" translate="yes" xml:space="preserve">
          <source>You can see these patterns in the TypeScript repo - see &lt;code&gt;src/tsconfig_base.json&lt;/code&gt;, &lt;code&gt;src/tsconfig.json&lt;/code&gt;, and &lt;code&gt;src/tsc/tsconfig.json&lt;/code&gt; as key examples.</source>
          <target state="translated">TypeScript 저장소에서 이러한 패턴을 볼 수 있습니다 ( &lt;code&gt;src/tsconfig_base.json&lt;/code&gt; , &lt;code&gt;src/tsconfig.json&lt;/code&gt; 및 &lt;code&gt;src/tsc/tsconfig.json&lt;/code&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="342e97c124555c4631ae12805973e016d0bd72c0" translate="yes" xml:space="preserve">
          <source>You can skip checking some files by adding &lt;code&gt;// @ts-nocheck&lt;/code&gt; comment to them; conversely you can choose to check only a few &lt;code&gt;.js&lt;/code&gt; files by adding &lt;code&gt;// @ts-check&lt;/code&gt; comment to them without setting &lt;code&gt;--checkJs&lt;/code&gt;. You can also ignore errors on specific lines by adding &lt;code&gt;// @ts-ignore&lt;/code&gt; on the preceding line.</source>
          <target state="translated">&lt;code&gt;// @ts-nocheck&lt;/code&gt; 주석을 추가하여 일부 파일 확인을 건너 뛸 수 있습니다 . 반대로 &lt;code&gt;--checkJs&lt;/code&gt; 를 설정하지 않고 &lt;code&gt;// @ts-check&lt;/code&gt; 주석을 추가 하여 몇 개의 &lt;code&gt;.js&lt;/code&gt; 파일 만 검사하도록 선택할 수 있습니다 . &lt;code&gt;// @ts-ignore&lt;/code&gt; 를 추가하여 특정 줄의 오류를 무시할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="964c60dd8551d7582983d7537470492d6195db2c" translate="yes" xml:space="preserve">
          <source>You can skip checking some files by adding a &lt;code&gt;// @ts-nocheck&lt;/code&gt; comment to them; conversely, you can choose to check only a few &lt;code&gt;.js&lt;/code&gt; files by adding a &lt;code&gt;// @ts-check&lt;/code&gt; comment to them without setting &lt;code&gt;--checkJs&lt;/code&gt;. You can also ignore errors on specific lines by adding &lt;code&gt;// @ts-ignore&lt;/code&gt; on the preceding line. Note that if you have a &lt;code&gt;tsconfig.json&lt;/code&gt;, JS checking will respect strict flags like &lt;code&gt;noImplicitAny&lt;/code&gt;, &lt;code&gt;strictNullChecks&lt;/code&gt;, etc. However, because of the relative looseness of JS checking, combining strict flags with it may be surprising.</source>
          <target state="translated">&lt;code&gt;// @ts-nocheck&lt;/code&gt; 주석을 추가하여 일부 파일 확인을 건너 뛸 수 있습니다 . 반대로 &lt;code&gt;--checkJs&lt;/code&gt; 를 설정하지 않고 &lt;code&gt;// @ts-check&lt;/code&gt; 주석을 추가하여 몇 개의 &lt;code&gt;.js&lt;/code&gt; 파일 만 검사하도록 선택할 수 있습니다 . &lt;code&gt;// @ts-ignore&lt;/code&gt; 를 추가하여 특정 줄의 오류를 무시할 수도 있습니다 . &lt;code&gt;tsconfig.json&lt;/code&gt; 이있는 경우 JS 검사는 &lt;code&gt;noImplicitAny&lt;/code&gt; , &lt;code&gt;strictNullChecks&lt;/code&gt; 등과 같은 엄격한 플래그를 존중합니다 . 그러나 JS 검사의 상대적 느슨 함 때문에 엄격한 플래그를 결합하는 것은 놀라운 일입니다.</target>
        </trans-unit>
        <trans-unit id="a94719f47d299841e6e51ceee5706dcecbbee79d" translate="yes" xml:space="preserve">
          <source>You can specify any number of config files:</source>
          <target state="translated">여러 구성 파일을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49e57a0ea093e19313c1e384f922d69417882b6c" translate="yes" xml:space="preserve">
          <source>You can specify array types using a variety of syntaxes:</source>
          <target state="translated">다양한 구문을 사용하여 배열 유형을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34efcdea59af77ca626a5d378a5a510fc13373a4" translate="yes" xml:space="preserve">
          <source>You can specify function types using either Typescript or Closure syntax:</source>
          <target state="translated">Typescript 또는 Closure 구문을 사용하여 함수 유형을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa7d6f924eeeb484fecdc0bbd17378d7530144b6" translate="yes" xml:space="preserve">
          <source>You can specify map-like and array-like objects using string and number index signatures, using either standard JSDoc syntax or Typescript syntax.</source>
          <target state="translated">표준 JSDoc 구문 또는 Typescript 구문을 사용하여 문자열 및 숫자 인덱스 서명을 사용하여 맵 유사 및 배열 유사 오브젝트를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5b4c27e6b170dfa095f022ece8aad3250bbb88a" translate="yes" xml:space="preserve">
          <source>You can specify the type of &lt;em&gt;children&lt;/em&gt; like any other attribute. This will override the default type from, eg the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;React typings&lt;/a&gt; if you use them.</source>
          <target state="translated">다른 속성과 마찬가지로 &lt;em&gt;하위&lt;/em&gt; 유형을 지정할 수 있습니다 . 예를 들어 &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/react&quot;&gt;React 타이핑&lt;/a&gt; 을 사용하는 경우 기본 유형이 무시 됩니다.</target>
        </trans-unit>
        <trans-unit id="e37fd121d8b3692df1ee3680ad29d96a4b8894ae" translate="yes" xml:space="preserve">
          <source>You can specify this mode using either the &lt;code&gt;--jsx&lt;/code&gt; command line flag or the corresponding option in your &lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.json&lt;/a&gt; file.</source>
          <target state="translated">&lt;code&gt;--jsx&lt;/code&gt; 명령 행 플래그 또는 &lt;a href=&quot;tsconfig-json&quot;&gt;tsconfig.json&lt;/a&gt; 파일 의 해당 옵션을 사용하여이 모드를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b65236d6747127a47949cb8a9fb216884384fd47" translate="yes" xml:space="preserve">
          <source>You can think of this as TypeScript &amp;ldquo;toughening up&amp;rdquo; the weak guarantees of these types to catch what would otherwise be silent bugs.</source>
          <target state="translated">이 유형을 사소한 버그가 무엇인지 파악하기 위해 이러한 유형의 약한 보증을 &quot;강화&quot;하는 TypeScript라고 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5097622074f85132325f78b68e79fba79fe3f621" translate="yes" xml:space="preserve">
          <source>You can think of this feature - the &lt;code&gt;??&lt;/code&gt; operator - as a way to &amp;ldquo;fall back&amp;rdquo; to a default value when dealing with &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;. When we write code like</source>
          <target state="translated">이 기능을 생각할 수 있습니다- &lt;code&gt;??&lt;/code&gt; operator- &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 를 처리 할 때 기본값으로&amp;ldquo;폴백&amp;rdquo;하는 방법 . 우리가 같은 코드를 작성할 때</target>
        </trans-unit>
        <trans-unit id="e2b715cffb2277991c0db4c0b6b9e109955e0bcf" translate="yes" xml:space="preserve">
          <source>You can use a type alias to make a shorthand for a type:</source>
          <target state="translated">유형 별명을 사용하여 유형을 속기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="391c1498a82ae1b3dc563cb57e6b7cbe9562f400" translate="yes" xml:space="preserve">
          <source>You can use either &lt;code&gt;object&lt;/code&gt; or &lt;code&gt;Object&lt;/code&gt; on the first line.</source>
          <target state="translated">첫 번째 줄에서 &lt;code&gt;object&lt;/code&gt; 또는 &lt;code&gt;Object&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="446759c7e9287dd9b2744b78bd72e945161fa89b" translate="yes" xml:space="preserve">
          <source>You can use the &amp;ldquo;@type&amp;rdquo; tag and reference a type name (either primitive, defined in a TypeScript declaration, or in a JSDoc &amp;ldquo;@typedef&amp;rdquo; tag). You can use any Typescript type, and most JSDoc types.</source>
          <target state="translated">&quot;@type&quot;태그를 사용하고 유형 이름 (기본, TypeScript 선언에 정의 된 JSDoc &quot;@typedef&quot;태그)을 참조 할 수 있습니다. 모든 Typescript 유형과 대부분의 JSDoc 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6a45fbb2d4cb410ac9052a3f0018033b37e3130" translate="yes" xml:space="preserve">
          <source>You can use this pattern with other parts of the type system to get type-safe lookups.</source>
          <target state="translated">이 패턴을 유형 시스템의 다른 부분과 함께 사용하여 유형 안전 조회를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4df1f23ca2dd7c39f8e49a4cc5f4fc6278b9486d" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t declare new top-level declarations in the augmentation &amp;ndash; just patches to existing declarations.</source>
          <target state="translated">기능 보강에서 새로운 최상위 선언을 선언 할 수 없으며 기존 선언에 패치 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="61e3055df49675bbb87854f15fad0bf01e0d93c4" translate="yes" xml:space="preserve">
          <source>You can&amp;rsquo;t set &lt;code&gt;myArray[2]&lt;/code&gt; because the index signature is readonly.</source>
          <target state="translated">인덱스 서명은 읽기 전용이므로 &lt;code&gt;myArray[2]&lt;/code&gt; 설정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c7e14e65723450d9d571a4aeb121d26c5a7c7c1f" translate="yes" xml:space="preserve">
          <source>You could also define the type of &lt;code&gt;options&lt;/code&gt; and add a type assertion on the object literal.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 유형을 정의 하고 객체 리터럴에 유형 어설 션을 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10223649f26ed1ba254c71d5968c360f3987e66e" translate="yes" xml:space="preserve">
          <source>You could argue that this program is correctly typed, since the &lt;code&gt;width&lt;/code&gt; properties are compatible, there&amp;rsquo;s no &lt;code&gt;color&lt;/code&gt; property present, and the extra &lt;code&gt;colour&lt;/code&gt; property is insignificant.</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; 속성이 호환되고 &lt;code&gt;color&lt;/code&gt; 속성이 없으며 추가 &lt;code&gt;colour&lt;/code&gt; 속성이 중요하지 않기 때문에이 프로그램이 올바르게 입력되었다고 주장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="453e1d8a491394744db85218dccb0ae80c5b3442" translate="yes" xml:space="preserve">
          <source>You could use multiple tsconfig files to solve &lt;em&gt;some&lt;/em&gt; of those problems, but new ones would appear:</source>
          <target state="translated">여러 tsconfig 파일을 사용 하여 이러한 문제 &lt;em&gt;중 일부&lt;/em&gt; 를 해결할 수 있지만 새로운 문제가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="783ca79e34aba59fadb024fdf75ec796a34f288d" translate="yes" xml:space="preserve">
          <source>You may already be familiar with this style of type from other languages. In the next section, we&amp;rsquo;ll cover how you can create your own generic types like &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">다른 언어의이 유형에 이미 익숙 할 것입니다. 다음 섹션에서는 &lt;code&gt;Array&amp;lt;T&amp;gt;&lt;/code&gt; 와 같은 고유 한 제네릭 형식을 만드는 방법을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="0e224facb474f21f90e2b2be7d6c67fc9a0105ac" translate="yes" xml:space="preserve">
          <source>You may be wondering why we allow &amp;lsquo;discarding&amp;rsquo; parameters like in the example &lt;code&gt;y = x&lt;/code&gt;. The reason for this assignment to be allowed is that ignoring extra function parameters is actually quite common in JavaScript. For example, &lt;code&gt;Array#forEach&lt;/code&gt; provides three parameters to the callback function: the array element, its index, and the containing array. Nevertheless, it&amp;rsquo;s very useful to provide a callback that only uses the first parameter:</source>
          <target state="translated">&lt;code&gt;y = x&lt;/code&gt; 예제와 같이 왜 '삭제'매개 변수를 허용하는지 궁금 할 것 입니다. 이 할당이 허용되는 이유는 추가 함수 매개 변수를 무시하는 것이 실제로 JavaScript에서 매우 일반적이기 때문입니다. 예를 들어 &lt;code&gt;Array#forEach&lt;/code&gt; 는 콜백 함수에 배열 요소, 인덱스 및 포함 배열의 세 가지 매개 변수를 제공합니다. 그럼에도 불구하고 첫 번째 매개 변수 만 사용하는 콜백을 제공하는 것이 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6203b314b9679b4e6a450edc94780928a6921225" translate="yes" xml:space="preserve">
          <source>You may need to restart VS for the red squiggly lines below &lt;code&gt;UseDefaultFiles&lt;/code&gt; and &lt;code&gt;UseStaticFiles&lt;/code&gt; to disappear.</source>
          <target state="translated">&lt;code&gt;UseDefaultFiles&lt;/code&gt; 및 &lt;code&gt;UseStaticFiles&lt;/code&gt; 아래의 빨간색 구불 구불 한 줄 이 사라지도록 VS를 다시 시작해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d0a6344f0b1a26e856b642628201bf4d2566c8e" translate="yes" xml:space="preserve">
          <source>You may still mark a member &lt;code&gt;public&lt;/code&gt; explicitly. We could have written the &lt;code&gt;Animal&lt;/code&gt; class from the previous section in the following way:</source>
          <target state="translated">회원을 명시 적으로 &lt;code&gt;public&lt;/code&gt; 표시 할 수 있습니다 . 이전 섹션에서 &lt;code&gt;Animal&lt;/code&gt; 클래스를 다음과 같은 방식으로 작성할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="ddc16c019974ce3ac91057cddfe1e72a32d707b7" translate="yes" xml:space="preserve">
          <source>You may&amp;rsquo;ve noticed that so far, we&amp;rsquo;ve been using the &lt;code&gt;let&lt;/code&gt; keyword instead of JavaScript&amp;rsquo;s &lt;code&gt;var&lt;/code&gt; keyword which you might be more familiar with. The &lt;code&gt;let&lt;/code&gt; keyword was introduced to JavaScript in ES2015 and is now considered the standard because it&amp;rsquo;s safer than &lt;code&gt;var&lt;/code&gt;. We&amp;rsquo;ll discuss the details later, but many common problems in JavaScript are alleviated by using &lt;code&gt;let&lt;/code&gt;, so you should use it instead of &lt;code&gt;var&lt;/code&gt; whenever possible.</source>
          <target state="translated">지금까지는 친숙한 JavaScript의 &lt;code&gt;var&lt;/code&gt; 키워드 대신 &lt;code&gt;let&lt;/code&gt; 키워드를 사용하고 있습니다. &lt;code&gt;let&lt;/code&gt; 키워드는 ES2015에 자바 스크립트에 도입하고보다 안전 때문에 이제 표준으로 간주됩니다 &lt;code&gt;var&lt;/code&gt; . 나중에 자세한 내용을 설명하지만 &lt;code&gt;let&lt;/code&gt; 을 사용하면 JavaScript의 많은 일반적인 문제가 완화 되므로 가능할 때마다 &lt;code&gt;var&lt;/code&gt; 대신 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c6ca7fd5f06b5916404ff0286e5a8b87e56d87ec" translate="yes" xml:space="preserve">
          <source>You might also be running some intermediate steps on your JavaScript, such as bundling or using another transpiler like Babel. In this case, you might already have a folder structure like this set up.</source>
          <target state="translated">번들링 또는 Babel과 같은 다른 변환기를 사용하는 것과 같이 JavaScript에서 일부 중간 단계를 실행 중일 수도 있습니다. 이 경우이 설정과 같은 폴더 구조가 이미있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77d12568f27dbc483de4e3aa9461fb0fdafcd3b7" translate="yes" xml:space="preserve">
          <source>You might be tempted to use &lt;code&gt;Object&lt;/code&gt; or &lt;code&gt;{}&lt;/code&gt; to say that a value can have any property on it because &lt;code&gt;Object&lt;/code&gt; is, for most purposes, the most general type. However &lt;strong&gt;&lt;code&gt;any&lt;/code&gt; is actually the type you want to use&lt;/strong&gt; in those situations, since it&amp;rsquo;s the most &lt;em&gt;flexible&lt;/em&gt; type.</source>
          <target state="translated">당신은 사용에 유혹 할 수있는 &lt;code&gt;Object&lt;/code&gt; 또는 &lt;code&gt;{}&lt;/code&gt; 때문에 값이 그것에 어떤 속성을 가질 수 있다는 말을 &lt;code&gt;Object&lt;/code&gt; 대부분의 목적으로, 가장 일반적인 유형. 그러나 &lt;strong&gt; &lt;code&gt;any&lt;/code&gt; 실제로 당신이 사용하고자하는 유형&lt;/strong&gt; 이 가장이기 때문에, 이러한 상황에서 &lt;em&gt;유연한&lt;/em&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="902577569221e3d57d91dd10a280916026992b82" translate="yes" xml:space="preserve">
          <source>You might be wondering about that &lt;code&gt;externals&lt;/code&gt; field. We want to avoid bundling all of React into the same file, since this increases compilation time and browsers will typically be able to cache a library if it doesn&amp;rsquo;t change.</source>
          <target state="translated">당신은 그 &lt;code&gt;externals&lt;/code&gt; 분야 에 대해 궁금 할 것 입니다. 컴파일 시간이 증가하고 브라우저가 라이브러리를 변경하지 않으면 일반적으로 라이브러리를 캐시 할 수 있기 때문에 모든 React를 동일한 파일에 묶지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3787c905bb80e813db582cc0b39b9469c3749297" translate="yes" xml:space="preserve">
          <source>You might find yourself using &lt;code&gt;?.&lt;/code&gt; to replace a lot of code that performs repetitive nullish checks using the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;?.&lt;/code&gt; 사용하여 자신을 찾을 수 있습니다 . &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 연산자를 사용하여 반복적 인 nullish 검사를 수행하는 많은 코드를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="453b06c204a19fa2060d497fe42b9d6b893f9b0c" translate="yes" xml:space="preserve">
          <source>You might have previously written that like so:</source>
          <target state="translated">이전에 다음과 같이 작성했을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="79ec33e56a8b7eaeb4d65dc92383b5f0d769696d" translate="yes" xml:space="preserve">
          <source>You might have some more build steps in your pipeline. Perhaps you concatenate something to each of your files. Each build tool is different, but we&amp;rsquo;ll do our best to cover the gist of things.</source>
          <target state="translated">파이프 라인에 빌드 단계가 더있을 수 있습니다. 아마도 각 파일에 무언가를 연결했을 것입니다. 각 빌드 도구는 다르지만 요점을 다루기 위해 최선을 다할 것입니다.</target>
        </trans-unit>
        <trans-unit id="4d2749eb8b0574a3a2922dc523ce38ed21997148" translate="yes" xml:space="preserve">
          <source>You might see documentation like this:</source>
          <target state="translated">다음과 같은 문서가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ebbdb79f43467b01f07e5bf9e813b83bf4b06f2" translate="yes" xml:space="preserve">
          <source>You might start out getting a bunch of errors like &lt;code&gt;Cannot find name 'require'.&lt;/code&gt;, and &lt;code&gt;Cannot find name 'define'.&lt;/code&gt;. In these cases, it&amp;rsquo;s likely that you&amp;rsquo;re using modules. While you can just convince TypeScript that these exist by writing out</source>
          <target state="translated">&lt;code&gt;Cannot find name 'require'.&lt;/code&gt; 와 같은 많은 오류가 발생하기 시작할 수 있습니다 . , &lt;code&gt;Cannot find name 'define'.&lt;/code&gt; . 이 경우 모듈을 사용하고있을 가능성이 있습니다. TypeScript를 작성하여 이것이 존재한다는 것을 확신시킬 수는 있지만</target>
        </trans-unit>
        <trans-unit id="a98f3b8ccf34fbf5eb87c6d57b621277a9a767e5" translate="yes" xml:space="preserve">
          <source>You no longer need to either explicitly declare &lt;code&gt;ref&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; or &lt;code&gt;extend React.Props&lt;/code&gt;</source>
          <target state="translated">더 이상 명시 적으로 &lt;code&gt;ref&lt;/code&gt; 와 &lt;code&gt;key&lt;/code&gt; 를 선언 하거나 &lt;code&gt;extend React.Props&lt;/code&gt; 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5bcfb9bf7e9a5a70d6661bc4978c8808ff85beea" translate="yes" xml:space="preserve">
          <source>You will mostly see intersection types used for mixins and other concepts that don&amp;rsquo;t fit in the classic object-oriented mold. (There are a lot of these in JavaScript!) Here&amp;rsquo;s a simple example that shows how to create a mixin:</source>
          <target state="translated">대부분 믹스 인 및 클래식 객체 지향 금형에 맞지 않는 다른 개념에 사용되는 교차 유형을 볼 수 있습니다. (자바 스크립트에는 이것들이 많이 있습니다!) 다음은 믹스 인을 만드는 방법을 보여주는 간단한 예입니다 :</target>
        </trans-unit>
        <trans-unit id="d538693b1e7a8713fd015bc6f34e84e12105e70c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll be given a series of prompts. You can use the defaults except for your entry point. For your entry point, use &lt;code&gt;./dist/main.js&lt;/code&gt;. You can always go back and change these in the &lt;code&gt;package.json&lt;/code&gt; file that&amp;rsquo;s been generated for you.</source>
          <target state="translated">일련의 프롬프트가 표시됩니다. 진입 점을 제외하고 기본값을 사용할 수 있습니다. 진입 점으로 &lt;code&gt;./dist/main.js&lt;/code&gt; 를 사용 하십시오 . 언제든지 돌아가서 생성 된 &lt;code&gt;package.json&lt;/code&gt; 파일 에서이를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="639d21bc62abc7441d41597c046101c12fe57e01" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll notice that in the class when we refer to one of the members of the class we prepend &lt;code&gt;this.&lt;/code&gt;. This denotes that it&amp;rsquo;s a member access.</source>
          <target state="translated">수업에서 우리가 수업의 구성원 중 하나를 언급 할 때 우리가 &lt;code&gt;this.&lt;/code&gt; 덧붙인다는 것을 알 수 있습니다. . 이것은 회원 액세스임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="96310a35cd7703a91b61529ec989ae56b9f242ba" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll see examples that look like this:</source>
          <target state="translated">다음과 같은 예가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="82f270d2ae21cc7300335c3380e8b45bcd31b76c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll sometimes find yourself calling a function with too many/few arguments. Typically, this is a bug, but in some cases, you might have declared a function that uses the &lt;code&gt;arguments&lt;/code&gt; object instead of writing out any parameters:</source>
          <target state="translated">때로는 너무 많은 인수가있는 함수를 호출하는 것을 알게 될 것입니다. 일반적으로 이것은 버그이지만 일부 경우 매개 변수를 작성하는 대신 &lt;code&gt;arguments&lt;/code&gt; 객체 를 사용하는 함수를 선언했을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20cb63d917861135d9d38ee4daf7eae6a3aead46" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll typically see modular libraries include one of these lines in their documentation:</source>
          <target state="translated">일반적으로 모듈 식 라이브러리에는 설명서에 다음 줄 중 하나가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9d443a11ab3a7c14d4920d4c70eef21109fe48c" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll usually see guidance in the documentation of a global library of how to use the library in an HTML script tag:</source>
          <target state="translated">일반적으로 HTML 스크립트 태그에서 라이브러리를 사용하는 방법에 대한 글로벌 라이브러리 문서에서 지침을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dffae8ffc86fe15706e64a3a387cd0d95f60fa7" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ll want to bring your TypeScript files together - both the code you&amp;rsquo;ll be writing as well as any necessary declaration files.</source>
          <target state="translated">작성하려는 코드와 필요한 선언 파일 모두 TypeScript 파일을 함께 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="947d14a2174247c5b66d9b89b8d5cbb14d3c55b1" translate="yes" xml:space="preserve">
          <source>Your declaration files should thus be</source>
          <target state="translated">따라서 신고 파일은</target>
        </trans-unit>
        <trans-unit id="440ddccd9fb08c957f616ff6766040aab7a385dd" translate="yes" xml:space="preserve">
          <source>ZipCodeValidator.ts</source>
          <target state="translated">ZipCodeValidator.ts</target>
        </trans-unit>
        <trans-unit id="103388cf7ca274b241718ae87f010b3c451a1308" translate="yes" xml:space="preserve">
          <source>a literal enum expression (basically a string literal or a numeric literal)</source>
          <target state="translated">리터럴 열거 형 표현식 (기본적으로 문자열 리터럴 또는 숫자 리터럴)</target>
        </trans-unit>
        <trans-unit id="2c353e97b94a39673f6777646c09f2fc9ba56cf1" translate="yes" xml:space="preserve">
          <source>a parenthesized constant enum expression</source>
          <target state="translated">괄호로 묶인 상수 열거 형 표현식</target>
        </trans-unit>
        <trans-unit id="6f264047eeed3d46fe957e11ffb9269c2a50015e" translate="yes" xml:space="preserve">
          <source>a reference to previously defined constant enum member (which can originate from a different enum)</source>
          <target state="translated">이전에 정의 된 상수 열거 형 멤버에 대한 참조 (다른 열거 형에서 발생할 수 있음)</target>
        </trans-unit>
        <trans-unit id="c528b1c807d172a8f416db6731cf13e39f6f146c" translate="yes" xml:space="preserve">
          <source>a unary minus applied to any numeric literal (e.g. &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;-100&lt;/code&gt;)</source>
          <target state="translated">임의의 숫자 리터럴에 적용된 단항 빼기 (예 : &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;-100&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="442d3d9c923419455d4cda7f945720f15e70bc16" translate="yes" xml:space="preserve">
          <source>amdModule.js</source>
          <target state="translated">amdModule.js</target>
        </trans-unit>
        <trans-unit id="bd7d452e38c7164a50e08e9fa4635c29c0daaa0b" translate="yes" xml:space="preserve">
          <source>amdModule.ts</source>
          <target state="translated">amdModule.ts</target>
        </trans-unit>
        <trans-unit id="d28fdf8d5aa89ce199b0e06ebcd80f424c23a2d8" translate="yes" xml:space="preserve">
          <source>an expression</source>
          <target state="translated">표현</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="2f7e39bb1317b9d8b35bfd3478e54eeafbdfcc2b" translate="yes" xml:space="preserve">
          <source>and as expected, this will print out</source>
          <target state="translated">예상대로 인쇄됩니다</target>
        </trans-unit>
        <trans-unit id="5a1d8e9654b07127c7e5e0c08c9afa232068f17f" translate="yes" xml:space="preserve">
          <source>and merge in options from the following into your &lt;code&gt;webpack.config.js&lt;/code&gt; file:</source>
          <target state="translated">다음 옵션을 &lt;code&gt;webpack.config.js&lt;/code&gt; 파일 로 병합 하십시오.</target>
        </trans-unit>
        <trans-unit id="23fcd315817eba480bb49d04295a2aed7b06de1d" translate="yes" xml:space="preserve">
          <source>and optionally returns a property descriptor to install on the target object</source>
          <target state="translated">선택적으로 대상 객체에 설치할 속성 설명자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="70d4ff6caac47a36ba7af0fb07acabf9735a878b" translate="yes" xml:space="preserve">
          <source>and we can also access those same variables within other functions:</source>
          <target state="translated">다른 함수 내에서 동일한 변수에 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="14539c18332daf6c00ef5a5fb87c44bcec15c080" translate="yes" xml:space="preserve">
          <source>any numeric literal (e.g. &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;100&lt;/code&gt;)</source>
          <target state="translated">임의의 숫자 리터럴 (예 : &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;100&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d4fc9c2ab5d3af99646bec10e59c8eeb1d9814d0" translate="yes" xml:space="preserve">
          <source>any string literal (e.g. &lt;code&gt;&quot;foo&quot;&lt;/code&gt;, &lt;code&gt;&quot;bar&lt;/code&gt;, &lt;code&gt;&quot;baz&quot;&lt;/code&gt;)</source>
          <target state="translated">문자열 리터럴 (예 : &lt;code&gt;&quot;foo&quot;&lt;/code&gt; , &lt;code&gt;&quot;bar&lt;/code&gt; , &lt;code&gt;&quot;baz&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="94012cbdbf0e0cf94a72971e951224b4fef1ce18" translate="yes" xml:space="preserve">
          <source>app.ts</source>
          <target state="translated">app.ts</target>
        </trans-unit>
        <trans-unit id="90e0d93d8b273dfcd00bd87849d5d11bf6a1ff97" translate="yes" xml:space="preserve">
          <source>array literals become &lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target state="translated">배열 리터럴은 &lt;code&gt;readonly&lt;/code&gt; 튜플이됩니다</target>
        </trans-unit>
        <trans-unit id="850ad5d4afbea97738fa95acd1da7e607bd530cc" translate="yes" xml:space="preserve">
          <source>at compile time</source>
          <target state="translated">컴파일 타임에</target>
        </trans-unit>
        <trans-unit id="ea0880f5346592a44bf582fa485ad5c011fc5cda" translate="yes" xml:space="preserve">
          <source>at runtime</source>
          <target state="translated">런타임에</target>
        </trans-unit>
        <trans-unit id="864ec6413a2ca497c9c6969ef6b7506903f57beb" translate="yes" xml:space="preserve">
          <source>awesome-typescript-loader</source>
          <target state="translated">awesome-typescript-loader</target>
        </trans-unit>
        <trans-unit id="48647474b89fa8f56ed6bda0f8148a17b51b97bd" translate="yes" xml:space="preserve">
          <source>boolean</source>
          <target state="translated">boolean</target>
        </trans-unit>
        <trans-unit id="ba69ef3aa7bab274d4a266a6dcb623595c1d29fe" translate="yes" xml:space="preserve">
          <source>bundling with your npm package, or</source>
          <target state="translated">npm 패키지와 함께 번들로 제공되거나</target>
        </trans-unit>
        <trans-unit id="231393efbaac44c960b4ab365234afea0360d138" translate="yes" xml:space="preserve">
          <source>cache module resolution</source>
          <target state="translated">캐시 모듈 확인</target>
        </trans-unit>
        <trans-unit id="30fdfe9db20efa1fbadcfb48f8e2224b604a7625" translate="yes" xml:space="preserve">
          <source>cache settings calculated from &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 에서 계산 된 캐시 설정</target>
        </trans-unit>
        <trans-unit id="fb02f65cfddd8df81baf783711476ad11f820af3" translate="yes" xml:space="preserve">
          <source>can actually be passed around to functions</source>
          <target state="translated">실제로 함수에 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1628f3e3fa5143b8a4026ed6fba31449a9455f0b" translate="yes" xml:space="preserve">
          <source>can be rewritten as the following array literal</source>
          <target state="translated">다음 배열 리터럴로 다시 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3d83e025c075f2d6dbf66e81628a8d397f050ac" translate="yes" xml:space="preserve">
          <source>can finally be rewritten without helper interfaces.</source>
          <target state="translated">마지막으로 도우미 인터페이스없이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e40f6b5c83d4e391396b982f962d9261185c5bc7" translate="yes" xml:space="preserve">
          <source>const declarations</source>
          <target state="translated">const 선언</target>
        </trans-unit>
        <trans-unit id="6d43229f086c7e1519152492bb976fdefa4cd26f" translate="yes" xml:space="preserve">
          <source>declarations.d.ts</source>
          <target state="translated">declarations.d.ts</target>
        </trans-unit>
        <trans-unit id="2c78b75bf2045753edca089f4a8b164e61897b5b" translate="yes" xml:space="preserve">
          <source>default (no value specified)</source>
          <target state="translated">기본값 (값이 지정되지 않음)</target>
        </trans-unit>
        <trans-unit id="eaa6f0ed9db98407e1677119423605d0592c8193" translate="yes" xml:space="preserve">
          <source>doesn&amp;rsquo;t stop the division or &lt;code&gt;someComputation()&lt;/code&gt; call from occurring. It&amp;rsquo;s equivalent to</source>
          <target state="translated">division 또는 &lt;code&gt;someComputation()&lt;/code&gt; 호출이 발생하는 것을 막지 않습니다 . 그것은 동등하다</target>
        </trans-unit>
        <trans-unit id="be65d27ae088a0e03fd8e1331d90b01649464cb6" translate="yes" xml:space="preserve">
          <source>dom</source>
          <target state="translated">dom</target>
        </trans-unit>
        <trans-unit id="44b226e39304e9a0605138651ed370e25b549357" translate="yes" xml:space="preserve">
          <source>dramaticWelcome.ts</source>
          <target state="translated">dramaticWelcome.ts</target>
        </trans-unit>
        <trans-unit id="c0c3d909b5b29bd46a7edf52931b97737d5d1ace" translate="yes" xml:space="preserve">
          <source>emits as:</source>
          <target state="translated">다음과 같이 방출됩니다 :</target>
        </trans-unit>
        <trans-unit id="3c5fff4d0016b644ab9720bf2113d69e16ee0db5" translate="yes" xml:space="preserve">
          <source>es2015.collection</source>
          <target state="translated">es2015.collection</target>
        </trans-unit>
        <trans-unit id="77452a908deffdbe4e25c0322f6fc17a39206ee1" translate="yes" xml:space="preserve">
          <source>es2015.core</source>
          <target state="translated">es2015.core</target>
        </trans-unit>
        <trans-unit id="4860f22d1763b9179816b962767983a680787ab3" translate="yes" xml:space="preserve">
          <source>es2015.generator</source>
          <target state="translated">es2015.generator</target>
        </trans-unit>
        <trans-unit id="a55fcf72537ff6199c436b9f28cfe5f307a1cc8d" translate="yes" xml:space="preserve">
          <source>es2015.iterable</source>
          <target state="translated">es2015.iterable</target>
        </trans-unit>
        <trans-unit id="455275f9b321b188ad0398ce86c78e923eb8b72b" translate="yes" xml:space="preserve">
          <source>es2015.promise</source>
          <target state="translated">es2015.promise</target>
        </trans-unit>
        <trans-unit id="ec95b856e9e47298430b5eb6799d9d8096bc4095" translate="yes" xml:space="preserve">
          <source>es2015.proxy</source>
          <target state="translated">es2015.proxy</target>
        </trans-unit>
        <trans-unit id="e6a8c5db65e11ddb62cc5fade31b70004048dc2c" translate="yes" xml:space="preserve">
          <source>es2015.reflect</source>
          <target state="translated">es2015.reflect</target>
        </trans-unit>
        <trans-unit id="de3c65e6af009d778471d8136d3c826fe99099be" translate="yes" xml:space="preserve">
          <source>es2015.symbol</source>
          <target state="translated">es2015.symbol</target>
        </trans-unit>
        <trans-unit id="671a9cd26cd3ffb3ef770f5b5b32cdcb27809d42" translate="yes" xml:space="preserve">
          <source>es2015.symbol.wellknown</source>
          <target state="translated">es2015.symbol.wellknown</target>
        </trans-unit>
        <trans-unit id="139a6dc78bee16dab8bae5ac789d730b614b917b" translate="yes" xml:space="preserve">
          <source>es2016</source>
          <target state="translated">es2016</target>
        </trans-unit>
        <trans-unit id="cd9583a356098ba3a4b81fc650ae36d83d670a5d" translate="yes" xml:space="preserve">
          <source>es2016.array.include</source>
          <target state="translated">es2016.array.include</target>
        </trans-unit>
        <trans-unit id="911015d28bbfae967ffe9225bd0fbdb225773f33" translate="yes" xml:space="preserve">
          <source>es2017</source>
          <target state="translated">es2017</target>
        </trans-unit>
        <trans-unit id="70890fd881ddc0e6b5672ad7751679f721fb15d1" translate="yes" xml:space="preserve">
          <source>es2017.object</source>
          <target state="translated">es2017.object</target>
        </trans-unit>
        <trans-unit id="5c6dbbf6f5b69fd02229a5a287b71af3d57a3f79" translate="yes" xml:space="preserve">
          <source>es2017.sharedmemory</source>
          <target state="translated">es2017.sharedmemory</target>
        </trans-unit>
        <trans-unit id="04fd367a754d12acaf37607d62e169a42efc8e2f" translate="yes" xml:space="preserve">
          <source>es5</source>
          <target state="translated">es5</target>
        </trans-unit>
        <trans-unit id="616df35d1ecf30f8712a0292c2c5a1d0030a5cf2" translate="yes" xml:space="preserve">
          <source>es6 / es2015</source>
          <target state="translated">es6 / es2015</target>
        </trans-unit>
        <trans-unit id="dfb1e3d26774a3a7d06095ec73fbb40447cd1e68" translate="yes" xml:space="preserve">
          <source>export = and import = require()</source>
          <target state="translated">내보내기 = 및 가져 오기 = require ()</target>
        </trans-unit>
        <trans-unit id="552fc8d9cfca0ff2b5ed367c413c5cc38420bb95" translate="yes" xml:space="preserve">
          <source>folders whose combined content represent the structure of the project at runtime. See &lt;a href=&quot;module-resolution#virtual-directories-with-rootdirs&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">결합 된 컨텐츠가 런타임시 프로젝트의 구조를 나타내는 폴더. 자세한 내용은 &lt;a href=&quot;module-resolution#virtual-directories-with-rootdirs&quot;&gt;모듈 확인 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c6111b4c03a562ccddbf99c1de8d5cfee0039f5a" translate="yes" xml:space="preserve">
          <source>for...of statements</source>
          <target state="translated">성명서</target>
        </trans-unit>
        <trans-unit id="31f79b8f38a6b1aee4464af7bf6e58995fdcc55c" translate="yes" xml:space="preserve">
          <source>for..of support</source>
          <target state="translated">지원을 위해</target>
        </trans-unit>
        <trans-unit id="e777919351daf00b0d9ef805e8c06560be596a16" translate="yes" xml:space="preserve">
          <source>from anywhere - even modules - using the new &lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; flag.</source>
          <target state="translated">새로운 &lt;code&gt;--allowUmdGlobalAccess&lt;/code&gt; 플래그를 사용하여 어디서나 모듈까지</target>
        </trans-unit>
        <trans-unit id="02e504f321a2bfc777ca2c589c79d3282bfcd3db" translate="yes" xml:space="preserve">
          <source>global-modifying-module.d.ts</source>
          <target state="translated">global-modifying-module.d.ts</target>
        </trans-unit>
        <trans-unit id="1c82bf83ced9d75b8f0bbc6b62ddb9a6a3e330d2" translate="yes" xml:space="preserve">
          <source>global-plugin.d.ts</source>
          <target state="translated">global-plugin.d.ts</target>
        </trans-unit>
        <trans-unit id="9e56f9776b89753df86ad753aa1b6340af717ac6" translate="yes" xml:space="preserve">
          <source>global.d.ts</source>
          <target state="translated">global.d.ts</target>
        </trans-unit>
        <trans-unit id="5f34c3ce3807ecd43ae9b35d36315839a3e5594d" translate="yes" xml:space="preserve">
          <source>has the effect of turning on all strict options &lt;em&gt;except&lt;/em&gt; the &lt;code&gt;--noImplicitThis&lt;/code&gt; option. Using this scheme it is possible to express configurations consisting of &lt;em&gt;all&lt;/em&gt; strict options except some explicitly listed options. In other words, it is now possible to default to the highest level of type safety but opt out of certain checks.</source>
          <target state="translated">모든 엄격한 옵션을 켜기의 효과가 &lt;em&gt;제외 &lt;/em&gt; &lt;code&gt;--noImplicitThis&lt;/code&gt; 옵션을 선택합니다. 이 체계를 사용하면 명시 적으로 나열된 일부 옵션을 제외한 &lt;em&gt;모든&lt;/em&gt; 엄격한 옵션 으로 구성된 구성을 표현할 수 있습니다. 다시 말해, 기본적으로 최고 수준의 안전 유형으로 기본 설정을 할 수 있지만 특정 검사를 선택 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18591991497d2b68bd0eed89efdaf2451fa493b5" translate="yes" xml:space="preserve">
          <source>hasInstance</source>
          <target state="translated">hasInstance</target>
        </trans-unit>
        <trans-unit id="afa300ec2e6f442ad1c924d6f087f775ceb41f89" translate="yes" xml:space="preserve">
          <source>import &amp;lsquo;folder1/file2&amp;rsquo;:</source>
          <target state="translated">'folder1 / file2'가져 오기 :</target>
        </trans-unit>
        <trans-unit id="4125832cdf0f8431153bb560626b190459d5c951" translate="yes" xml:space="preserve">
          <source>import &amp;lsquo;folder2/file3&amp;rsquo;:</source>
          <target state="translated">'folder2 / file3'가져 오기 :</target>
        </trans-unit>
        <trans-unit id="e7269327a2c540547ce437cbdb0983490aab1d82" translate="yes" xml:space="preserve">
          <source>import types can also be used in type alias declarations:</source>
          <target state="translated">가져 오기 유형은 유형 별명 선언에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a817954644dc1a42aab49b25d28ed9e711dcb1" translate="yes" xml:space="preserve">
          <source>import types can be used to get the type of a value from a module if you don&amp;rsquo;t know the type, or if it has a large type that is annoying to type:</source>
          <target state="translated">임포트 타입은 타입을 모르거나 타입을 성가 시게하는 큰 타입이있는 경우 모듈에서 값의 타입을 얻는 데 사용될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="35c8cb4be244289fb285290d143c9526ef63af36" translate="yes" xml:space="preserve">
          <source>imports can also be renamed</source>
          <target state="translated">수입품의 이름도 바꿀 수 있습니다</target>
        </trans-unit>
        <trans-unit id="6aea52bc45b38b909da565c5529f2a9c7f8db0a4" translate="yes" xml:space="preserve">
          <source>in generated code will become</source>
          <target state="translated">생성 된 코드에서</target>
        </trans-unit>
        <trans-unit id="f47c6df49b203143e91cc678af85198bdcdaf295" translate="yes" xml:space="preserve">
          <source>in that order.</source>
          <target state="translated">그와 같은 순서로.</target>
        </trans-unit>
        <trans-unit id="84ce34d804a3c874e85689e05ad0b489ab140173" translate="yes" xml:space="preserve">
          <source>inject helpers in &lt;em&gt;every&lt;/em&gt; file that needs them, or</source>
          <target state="translated">필요한 &lt;em&gt;모든&lt;/em&gt; 파일에 도우미를 삽입 하거나</target>
        </trans-unit>
        <trans-unit id="468d96f12443b97ac97eca3d629ee0a54fe0a6df" translate="yes" xml:space="preserve">
          <source>instanceof type guards</source>
          <target state="translated">인스턴스 가드</target>
        </trans-unit>
        <trans-unit id="a92d74a79d6425b54c23f524c3bf077b2f9b9a03" translate="yes" xml:space="preserve">
          <source>instead of needing to use</source>
          <target state="translated">사용할 필요없이</target>
        </trans-unit>
        <trans-unit id="6b0d333fa91b7256720d61e3b723f862f3e9cd6a" translate="yes" xml:space="preserve">
          <source>is compiled to:</source>
          <target state="translated">다음으로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5036323301c49fea1149a5e0032dddf37a7db574" translate="yes" xml:space="preserve">
          <source>isConcatSpreadable</source>
          <target state="translated">isConcatSpreadable</target>
        </trans-unit>
        <trans-unit id="a565530bf0e070a5e111b87a562d444b5f4fc91c" translate="yes" xml:space="preserve">
          <source>it&amp;rsquo;s better to get rid of those calls and use TypeScript syntax for imports.</source>
          <target state="translated">이러한 호출을 제거하고 가져 오기에 TypeScript 구문을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bef4aaaa11015ef79d88f3701f4c69ad690eb4c7" translate="yes" xml:space="preserve">
          <source>iterator</source>
          <target state="translated">iterator</target>
        </trans-unit>
        <trans-unit id="e01628c208ee1a02b76e949e6aeeb32ef20336c1" translate="yes" xml:space="preserve">
          <source>let declarations</source>
          <target state="translated">선언하자</target>
        </trans-unit>
        <trans-unit id="fe1ea68213afb7afeac6a8fbb4b87a0022fb14d9" translate="yes" xml:space="preserve">
          <source>math-lib.d.ts</source>
          <target state="translated">math-lib.d.ts</target>
        </trans-unit>
        <trans-unit id="96975c0a90b39fef6b95655c8d4a16937cf164bb" translate="yes" xml:space="preserve">
          <source>module-class.d.ts</source>
          <target state="translated">module-class.d.ts</target>
        </trans-unit>
        <trans-unit id="c2bc7a720a2efaefa00955db0d49e95c55f87036" translate="yes" xml:space="preserve">
          <source>module-function.d.ts</source>
          <target state="translated">module-function.d.ts</target>
        </trans-unit>
        <trans-unit id="468f83c6a2befacff3854111aef39df278df3af2" translate="yes" xml:space="preserve">
          <source>module-plugin.d.ts</source>
          <target state="translated">module-plugin.d.ts</target>
        </trans-unit>
        <trans-unit id="98c512330f2e92d9ee7c96f3f93fbc2bae3712f3" translate="yes" xml:space="preserve">
          <source>module.d.ts</source>
          <target state="translated">module.d.ts</target>
        </trans-unit>
        <trans-unit id="07776d76368c781786ef37f37f876736d04e819a" translate="yes" xml:space="preserve">
          <source>no helpers at all with &lt;code&gt;--noEmitHelpers&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--noEmitHelpers&lt;/code&gt; 를 사용하는 도우미는 전혀 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a16b029d0076e4fd3820aa4c6802762d030bf62a" translate="yes" xml:space="preserve">
          <source>no literal types in that expression should be widened (e.g. no going from &lt;code&gt;&quot;hello&quot;&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt;)</source>
          <target state="translated">해당 표현식에서 리터럴 유형을 확장하지 않아야합니다 (예 : &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 에서 &lt;code&gt;string&lt;/code&gt; 으로 이동하지 않음 )</target>
        </trans-unit>
        <trans-unit id="c1c065b723cc9c76bd65782fc2825c04eeea0d14" translate="yes" xml:space="preserve">
          <source>node.d.ts (simplified excerpt)</source>
          <target state="translated">node.d.ts (간단한 발췌)</target>
        </trans-unit>
        <trans-unit id="f6996c043b2b5e1cab7ecdea026dc230caadc8f0" translate="yes" xml:space="preserve">
          <source>null, undefined, and empty array initializers are of type any or any[]</source>
          <target state="translated">null, undefined 및 빈 배열 이니셜 라이저는 any 또는 any [] 형식입니다.</target>
        </trans-unit>
        <trans-unit id="2aedd1e807766ef33fa75af2358a22cd131cb1b8" translate="yes" xml:space="preserve">
          <source>object literals get &lt;code&gt;readonly&lt;/code&gt; properties</source>
          <target state="translated">객체 리터럴은 &lt;code&gt;readonly&lt;/code&gt; 속성을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="0ebf848d70837166207cdc336c60ac98e13285c0" translate="yes" xml:space="preserve">
          <source>one of the &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt; unary operators applied to constant enum expression</source>
          <target state="translated">상수 열거 형 표현식에 적용되는 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; 단항 연산자 중 하나</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="c5e4a4a8dfa19245aa2006b23ea5c10fb66c04c5" translate="yes" xml:space="preserve">
          <source>or if you&amp;rsquo;re not using modules, you can just use the global variable &lt;code&gt;_&lt;/code&gt;.</source>
          <target state="translated">또는 모듈을 사용하지 않는 경우 전역 변수 &lt;code&gt;_&lt;/code&gt; 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98658dbce77e0b4aea26c71003da55e305bd7c92" translate="yes" xml:space="preserve">
          <source>or like this:</source>
          <target state="translated">또는 이와 같이 :</target>
        </trans-unit>
        <trans-unit id="7984dbe379bf690e91f1ee949c3912e39cb8fa5a" translate="yes" xml:space="preserve">
          <source>or the following RequireJS/AMD code:</source>
          <target state="translated">또는 다음 RequireJS / AMD 코드 :</target>
        </trans-unit>
        <trans-unit id="6bf95a9eb65b12b201e76e1107475e703367cc8f" translate="yes" xml:space="preserve">
          <source>overriding an accessor in a derived class with a property declaration</source>
          <target state="translated">속성 선언으로 파생 클래스의 접근자를 재정의</target>
        </trans-unit>
        <trans-unit id="7030d0b2f71b999ff89a343de08c414af32fc93a" translate="yes" xml:space="preserve">
          <source>package.json</source>
          <target state="translated">package.json</target>
        </trans-unit>
        <trans-unit id="c633d046a28eea1c30dc77a917920638149eff4b" translate="yes" xml:space="preserve">
          <source>pattern &amp;lsquo;*&amp;rsquo; is matched and wildcard captures the whole module name</source>
          <target state="translated">패턴 '*'가 일치하고 와일드 카드는 전체 모듈 이름을 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="e46d31b8d8def12ff7fd2aeb2cd33c6ff0c682de" translate="yes" xml:space="preserve">
          <source>publishing to the &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types organization&lt;/a&gt; on npm.</source>
          <target state="translated">npm 의 &lt;a href=&quot;https://www.npmjs.com/~types&quot;&gt;@types 조직&lt;/a&gt; 에 게시</target>
        </trans-unit>
        <trans-unit id="e964e4b7b09edd9e4bc1f9f94275bbd20db64a86" translate="yes" xml:space="preserve">
          <source>qualified name</source>
          <target state="translated">정규화 된 이름</target>
        </trans-unit>
        <trans-unit id="84cd3707c3c1a76a0deb0eb06b96bf43c03e7942" translate="yes" xml:space="preserve">
          <source>re-declaring a property declaration with no initializer</source>
          <target state="translated">이니셜 라이저없이 속성 선언을 다시 선언</target>
        </trans-unit>
        <trans-unit id="3cacc7bfac0a382c669a884c953d0401a689785d" translate="yes" xml:space="preserve">
          <source>replace</source>
          <target state="translated">replace</target>
        </trans-unit>
        <trans-unit id="0de436ef775b25d8c1ce125d994a572c0b2f2a2d" translate="yes" xml:space="preserve">
          <source>result of substitution is non-relative name - combine it with &lt;em&gt;baseUrl&lt;/em&gt; -&amp;gt; &lt;code&gt;projectRoot/folder1/file2.ts&lt;/code&gt;.</source>
          <target state="translated">대체의 결과가 아닌 상대 이름 -와 결합 &lt;em&gt;base을&lt;/em&gt; &amp;gt; - &lt;code&gt;projectRoot/folder1/file2.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0955b111882fc9165c9f9e7f313ec9ed19312361" translate="yes" xml:space="preserve">
          <source>result of substitution is non-relative name - combine it with &lt;em&gt;baseUrl&lt;/em&gt; -&amp;gt; &lt;code&gt;projectRoot/folder2/file3.ts&lt;/code&gt;.</source>
          <target state="translated">대체의 결과가 아닌 상대 이름 -와 결합 &lt;em&gt;base을&lt;/em&gt; &amp;gt; - &lt;code&gt;projectRoot/folder2/file3.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99a3fa984143a41fb76ddb33b09c3bebfb48dac5" translate="yes" xml:space="preserve">
          <source>result of substitution is non-relative name - combine it with &lt;em&gt;baseUrl&lt;/em&gt; -&amp;gt; &lt;code&gt;projectRoot/generated/folder2/file3.ts&lt;/code&gt;.</source>
          <target state="translated">치환 결과 것은 아닌 상대 이름 -와 결합 &lt;em&gt;base을&lt;/em&gt; &amp;gt; - &lt;code&gt;projectRoot/generated/folder2/file3.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc76e9f0c0006e8f919e0c515c66dbba3982f785" translate="yes" xml:space="preserve">
          <source>root</source>
          <target state="translated">root</target>
        </trans-unit>
        <trans-unit id="4ea4a4256b62dc47fa7b744f94891091f4b0bc89" translate="yes" xml:space="preserve">
          <source>scripthost</source>
          <target state="translated">scripthost</target>
        </trans-unit>
        <trans-unit id="3559d7accf00360971961ca18989adc0614089c0" translate="yes" xml:space="preserve">
          <source>search</source>
          <target state="translated">search</target>
        </trans-unit>
        <trans-unit id="3f6125de305b05426b600528f29a8bd1bf5a7f90" translate="yes" xml:space="preserve">
          <source>second substitution &amp;lsquo;generated/*&amp;rsquo; -&amp;gt; &lt;code&gt;generated/folder2/file3&lt;/code&gt;</source>
          <target state="translated">두 번째 대체 'generated / *'-&amp;gt; &lt;code&gt;generated/folder2/file3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf941d149e57be2f6cef984faf977e7b577e5a91" translate="yes" xml:space="preserve">
          <source>share the same type &lt;code&gt;(firstName: string, lastName?: string) =&amp;gt; string&lt;/code&gt;. The default value of &lt;code&gt;lastName&lt;/code&gt; disappears in the type, only leaving behind the fact that the parameter is optional.</source>
          <target state="translated">동일한 유형을 공유하십시오 &lt;code&gt;(firstName: string, lastName?: string) =&amp;gt; string&lt;/code&gt; . &lt;code&gt;lastName&lt;/code&gt; 의 기본값 은 유형에서 사라지고 매개 변수가 선택적이라는 사실 만 남습니다.</target>
        </trans-unit>
        <trans-unit id="035294d01dde5efc18c757c726816c26af51f939" translate="yes" xml:space="preserve">
          <source>species</source>
          <target state="translated">species</target>
        </trans-unit>
        <trans-unit id="ecb252044b5ea0f679ee78ec1a12904739e2904d" translate="yes" xml:space="preserve">
          <source>string</source>
          <target state="translated">string</target>
        </trans-unit>
        <trans-unit id="cc99c74e82294d1b43025090d9e1d0556327a660" translate="yes" xml:space="preserve">
          <source>that evaluates to a function</source>
          <target state="translated">함수로 평가되는</target>
        </trans-unit>
        <trans-unit id="410790749f881beaeb38631c106e13750a965f34" translate="yes" xml:space="preserve">
          <source>that takes the target, name, and property descriptor as arguments</source>
          <target state="translated">대상, 이름 및 속성 설명자를 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0e856eda57d6466543d1e599198fd48d9b2d470f" translate="yes" xml:space="preserve">
          <source>the checked value comes from an optional property</source>
          <target state="translated">확인 된 값은 선택적 속성에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4320cad8649a09684716eeb91069e55dbef76092" translate="yes" xml:space="preserve">
          <source>the function is later called within the body of the &lt;code&gt;if&lt;/code&gt;</source>
          <target state="translated">함수는 나중에 &lt;code&gt;if&lt;/code&gt; 의 본문 내에서 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="0eb972a2af54927fb29feb3fb4a88f8a08079e74" translate="yes" xml:space="preserve">
          <source>the type of the function&amp;rsquo;s &lt;code&gt;prototype&lt;/code&gt; property if its type is not &lt;code&gt;any&lt;/code&gt;</source>
          <target state="translated">함수의 유형의 &lt;code&gt;prototype&lt;/code&gt; 의 형식이 아닌 경우 재산 &lt;code&gt;any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46fd581054ba0a939bf5545d6288d6fbc83e5bb7" translate="yes" xml:space="preserve">
          <source>the union of types returned by that type&amp;rsquo;s construct signatures</source>
          <target state="translated">해당 형식의 생성자 서명에 의해 반환 된 형식의 공용체</target>
        </trans-unit>
        <trans-unit id="73941296c536b59a9dbd4de92d48a59f407991b3" translate="yes" xml:space="preserve">
          <source>then you would write the following TypeScript code:</source>
          <target state="translated">그런 다음 다음 TypeScript 코드를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="a4bbbe8ef59f52f36231746a023fe1851d9d226c" translate="yes" xml:space="preserve">
          <source>this and arrow functions</source>
          <target state="translated">이 화살표 기능</target>
        </trans-unit>
        <trans-unit id="c3f72c68c2b9e85be2eb32e46ad8b4b8c7c65b47" translate="yes" xml:space="preserve">
          <source>this is a new way to say that the value &lt;code&gt;foo&lt;/code&gt; will be used when it&amp;rsquo;s &amp;ldquo;present&amp;rdquo;; but when it&amp;rsquo;s &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, calculate &lt;code&gt;bar()&lt;/code&gt; in its place.</source>
          <target state="translated">이것은 &lt;code&gt;foo&lt;/code&gt; 값 이&amp;ldquo;존재할 때&amp;rdquo;사용될 것이라고 말하는 새로운 방법입니다 . 그러나 &lt;code&gt;null&lt;/code&gt; 이거나 &lt;code&gt;undefined&lt;/code&gt; 인 경우 그 자리에서 &lt;code&gt;bar()&lt;/code&gt; 를 계산하십시오 .</target>
        </trans-unit>
        <trans-unit id="d69f1db0e1ea5e4ca2dd4f8fc47cde3bcb24021d" translate="yes" xml:space="preserve">
          <source>this is a way of saying that when &lt;code&gt;foo&lt;/code&gt; is defined, &lt;code&gt;foo.bar.baz()&lt;/code&gt; will be computed; but when &lt;code&gt;foo&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, stop what we&amp;rsquo;re doing and just return &lt;code&gt;undefined&lt;/code&gt;.&amp;rdquo;</source>
          <target state="translated">이것은 &lt;code&gt;foo&lt;/code&gt; 가 정의 될 때 &lt;code&gt;foo.bar.baz()&lt;/code&gt; 가 계산 될 것이라고 말하는 방법입니다 . 하지만 &lt;code&gt;foo&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 이거나 &lt;code&gt;undefined&lt;/code&gt; 인 경우 수행중인 작업을 중지하고 &lt;code&gt;undefined&lt;/code&gt; 를 반환하면 됩니다.&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="ee936e1581e97020e1f572b89ea32250a874ec97" translate="yes" xml:space="preserve">
          <source>this parameters</source>
          <target state="translated">이 매개 변수</target>
        </trans-unit>
        <trans-unit id="e12e5f0923f00b722f074d1422f64a9f845de377" translate="yes" xml:space="preserve">
          <source>to your proj file. This will enable automatic incremental build as well as cleaning.</source>
          <target state="translated">proj 파일에. 그러면 자동 증분 빌드와 청소가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7e5c6264588378e69d51645936191ab10add5e93" translate="yes" xml:space="preserve">
          <source>toPrimitive</source>
          <target state="translated">toPrimitive</target>
        </trans-unit>
        <trans-unit id="e2762bc4a7de1aada1593ee4242bbf2686f8446e" translate="yes" xml:space="preserve">
          <source>toStringTag</source>
          <target state="translated">toStringTag</target>
        </trans-unit>
        <trans-unit id="15903df5ef6a72c1c46835f09e09e97181bf4905" translate="yes" xml:space="preserve">
          <source>took other generic functions as arguments, like so:</source>
          <target state="translated">다른 일반 함수를 인수로 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="30b826e9a560741abbb6ab6ebbd8adb6e7480e65" translate="yes" xml:space="preserve">
          <source>try first substitution in the list: &amp;lsquo;*&amp;rsquo; -&amp;gt; &lt;code&gt;folder1/file2&lt;/code&gt;</source>
          <target state="translated">목록에서 첫 번째 대체를 시도하십시오 : '*'-&amp;gt; &lt;code&gt;folder1/file2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8af6d2c2f91e249ac51918e9913c40c803abd33a" translate="yes" xml:space="preserve">
          <source>try first substitution in the list: &amp;lsquo;*&amp;rsquo; -&amp;gt; &lt;code&gt;folder2/file3&lt;/code&gt;</source>
          <target state="translated">목록에서 첫 번째 대체를 시도하십시오 : '*'-&amp;gt; &lt;code&gt;folder2/file3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="62a9b1027af305cf651dc37867f95e2771be3b70" translate="yes" xml:space="preserve">
          <source>tsc &amp;ndash;module system</source>
          <target state="translated">tsc &amp;ndash; 모듈 시스템</target>
        </trans-unit>
        <trans-unit id="fff4bd3c7cb18ddafa0cf9c3cbe164beb57343e4" translate="yes" xml:space="preserve">
          <source>tsc &amp;ndash;module umd</source>
          <target state="translated">tsc &amp;ndash; 모듈 umd</target>
        </trans-unit>
        <trans-unit id="61ebb9fd6e8cf9082658121d5d81e297791dacd0" translate="yes" xml:space="preserve">
          <source>tsconfig.json</source>
          <target state="translated">tsconfig.json</target>
        </trans-unit>
        <trans-unit id="276bd1a6a434b41b4d95db5e0d8549df1186c2c8" translate="yes" xml:space="preserve">
          <source>tsconfig.json: @types, typeRoots and types</source>
          <target state="translated">tsconfig.json : @types, typeRoots 및 유형</target>
        </trans-unit>
        <trans-unit id="a8998d2dc8a77e20af5c5a28175b6d8951a02cff" translate="yes" xml:space="preserve">
          <source>tsconfig.json: Configuration inheritance with extends</source>
          <target state="translated">tsconfig.json : 확장을 사용한 구성 상속</target>
        </trans-unit>
        <trans-unit id="49e70783d507bff0c00f2e231d4cf0f0c8f532cc" translate="yes" xml:space="preserve">
          <source>tsconfig.json: Details</source>
          <target state="translated">tsconfig.json : 세부 사항</target>
        </trans-unit>
        <trans-unit id="6122fb987f7fd90d7dc18652ca78d161fe544643" translate="yes" xml:space="preserve">
          <source>tsconfig.json: Schema</source>
          <target state="translated">tsconfig.json : 스키마</target>
        </trans-unit>
        <trans-unit id="689bc8e3544a7ddf4369a2913de3f221a9332817" translate="yes" xml:space="preserve">
          <source>tsconfig.json: Using tsconfig.json</source>
          <target state="translated">tsconfig.json : tsconfig.json 사용</target>
        </trans-unit>
        <trans-unit id="f0986fe288c02a83341b9817dadd43458c8e78a1" translate="yes" xml:space="preserve">
          <source>tsconfig.json: compileOnSave</source>
          <target state="translated">tsconfig.json : compileOnSave</target>
        </trans-unit>
        <trans-unit id="76e7d2c9d6a40c98553f221e62c309f440e26de7" translate="yes" xml:space="preserve">
          <source>typeof type guards</source>
          <target state="translated">가드 종류</target>
        </trans-unit>
        <trans-unit id="7d000ae7bc64f9b26659458ead894e1de3ad1436" translate="yes" xml:space="preserve">
          <source>unscopables</source>
          <target state="translated">unscopables</target>
        </trans-unit>
        <trans-unit id="eceda2b511cd73d8db8f6a944bf2fd8f597d29e5" translate="yes" xml:space="preserve">
          <source>value of &lt;em&gt;baseUrl&lt;/em&gt; command line argument (if given path is relative, it is computed based on current directory)</source>
          <target state="translated">&lt;em&gt;baseUrl&lt;/em&gt; 명령 행 인수의 값 (주어진 경로가 상대적이면 현재 디렉토리를 기반으로 계산 됨)</target>
        </trans-unit>
        <trans-unit id="5f30936558ce9791e34d7bc35fc21d5cfe35d104" translate="yes" xml:space="preserve">
          <source>value of &lt;em&gt;baseUrl&lt;/em&gt; property in &amp;lsquo;tsconfig.json&amp;rsquo; (if given path is relative, it is computed based on the location of &amp;lsquo;tsconfig.json&amp;rsquo;)</source>
          <target state="translated">'tsconfig.json' 의 &lt;em&gt;baseUrl&lt;/em&gt; 특성 값 (주어진 경로가 상대 경로 인 경우 'tsconfig.json'의 위치에 따라 계산 됨)</target>
        </trans-unit>
        <trans-unit id="0839e97c8a1e4f4d897468c821b41e5eaa185529" translate="yes" xml:space="preserve">
          <source>var declarations</source>
          <target state="translated">var 선언</target>
        </trans-unit>
        <trans-unit id="4499ccc1d0e0ade805a0533654e442fececc138f" translate="yes" xml:space="preserve">
          <source>webworker</source>
          <target state="translated">webworker</target>
        </trans-unit>
        <trans-unit id="f3328fe3edbd69bd908391fb6014b6af5d608edf" translate="yes" xml:space="preserve">
          <source>whereas in a vanilla browser environment you would write:</source>
          <target state="translated">반면 바닐라 브라우저 환경에서는 다음과 같이 작성합니다.</target>
        </trans-unit>
        <trans-unit id="860bafefa2519ed66049a3ea261ac65589b10afe" translate="yes" xml:space="preserve">
          <source>which is slightly different. &lt;code&gt;Array(5)&lt;/code&gt; produces an array with a length of 5, but with no defined property slots.</source>
          <target state="translated">약간 다릅니다. &lt;code&gt;Array(5)&lt;/code&gt; 는 길이가 5이지만 정의 된 속성 슬롯이없는 배열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a6c55dcf0293a1f122e26943ea0663055b97bae3" translate="yes" xml:space="preserve">
          <source>will be emitted as</source>
          <target state="translated">로 방출됩니다</target>
        </trans-unit>
        <trans-unit id="f46edc0fbe0327e0efa900cc749f913bd1a80f9e" translate="yes" xml:space="preserve">
          <source>will be emitted as:</source>
          <target state="translated">다음과 같이 방출됩니다 :</target>
        </trans-unit>
        <trans-unit id="8e20f36a2661ddaf13f4755da40c2807ae79d25e" translate="yes" xml:space="preserve">
          <source>will be generated as:</source>
          <target state="translated">다음과 같이 생성됩니다 :</target>
        </trans-unit>
        <trans-unit id="2771d3b1186a1a3778a1a5e3fbd8b308e69ea2be" translate="yes" xml:space="preserve">
          <source>will be transformed into the following &lt;code&gt;.d.ts&lt;/code&gt; file:</source>
          <target state="translated">다음 &lt;code&gt;.d.ts&lt;/code&gt; 파일 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="634d1e09320e1570c335f877722f67a9fdf91968" translate="yes" xml:space="preserve">
          <source>with Mapped types, &lt;code&gt;PartialPerson&lt;/code&gt; can be written as a generalized transformation on the type &lt;code&gt;Person&lt;/code&gt; as:</source>
          <target state="translated">매핑 된 유형을 사용하면 &lt;code&gt;PartialPerson&lt;/code&gt; 을 &lt;code&gt;Person&lt;/code&gt; 유형에서 다음과 같이 일반화 된 변환으로 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f36243ad4ea12acc4ebf39712e5d614768a0b9fa" translate="yes" xml:space="preserve">
          <source>would be equivalent to a similar assignment within a constructor body.</source>
          <target state="translated">생성자 본문 내의 유사한 할당과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="49471e5d2c6c36dd9d328715969ae37fb8083886" translate="yes" xml:space="preserve">
          <source>you could write that out as the following:</source>
          <target state="translated">다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f59273a98347ed94aa5e63df10048950733e7712" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;&quot;ES2016&quot;&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;&quot;ES2016&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a40de54cb8eb456071ddd614bd9f40c54327f41d" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;&quot;ES2017&quot;&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;&quot;ES2017&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f89cc3c29cb665fa25606f58e1f98ff9b626d8b6" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;&quot;ES2018&quot;&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;&quot;ES2018&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f30a1214ce2a0b2580cf271a08656b8e90d700a" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;&quot;ES2019&quot;&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;&quot;ES2019&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47c62ac10a4e5b6c10f9f224b1e0c279b3da2b58" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;&quot;ES2020&quot;&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;&quot;ES2020&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9fe0b45017dd07d79a42743156565f74166c803d" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;&quot;ES3&quot;&lt;/code&gt; (default)</source>
          <target state="translated">► &lt;code&gt;&quot;ES3&quot;&lt;/code&gt; (기본값)</target>
        </trans-unit>
        <trans-unit id="4a34795d0f52d8627a7ec5625a55045ffb89d7b7" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;&quot;ES5&quot;&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;&quot;ES5&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8353801bfcf5cd79ca98d4a774cf1525b9099cb" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;&quot;ES6&quot;&lt;/code&gt; and &lt;code&gt;&quot;ES2015&quot;&lt;/code&gt; values may be used when targeting &lt;code&gt;&quot;ES5&quot;&lt;/code&gt; or lower.</source>
          <target state="translated">► &lt;code&gt;&quot;ES6&quot;&lt;/code&gt; &lt;code&gt;&quot;ES5&quot;&lt;/code&gt; 이하를 타겟팅 할 때 &quot;ES6&quot; 및 &lt;code&gt;&quot;ES2015&quot;&lt;/code&gt; 값을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="22e296cadc43597f012d962e8f215881066d8d5a" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;&quot;ES6&quot;&lt;/code&gt;/&lt;code&gt;&quot;ES2015&quot;&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;&quot;ES6&quot;&lt;/code&gt; / &lt;code&gt;&quot;ES2015&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="047dae9d8977c7474a051fab3035bb18cdee25a7" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="84c3e9b824cec124f9a334707c8a2b9f460359d7" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;DOM.Iterable&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;DOM.Iterable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5da450217b3988083f83848bce88ea3c0db00bfa" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;DOM&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;DOM&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71641a4e3e65d9565ae285bfe5db1b08f249d527" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2015.Collection&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015.Collection&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ccab9e33c3ac66ca1dd886021b7283638741de9" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2015.Core&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015.Core&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d4486602759448f6e0380d9560516b0053176db8" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2015.Generator&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015.Generator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0385ae39bb3546c48e96e8f720a220fba48631ff" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2015.Iterable&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015.Iterable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d5171b5df1d691451f9abdc41d74e1bcf3c2cac9" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2015.Promise&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015.Promise&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="496aa0d98970bebeb2de723fb450beee1791314d" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2015.Proxy&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015.Proxy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5aa0ee38b852f3bdb04109824a177f7e3d3d6386" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2015.Reflect&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015.Reflect&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="112847064b33c2ad0e58bd6929c57aa54e65b08f" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2015.Symbol.WellKnown&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015.Symbol.WellKnown&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8044dac1e33a7520ef3f7267ab13ffb018873f04" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2015.Symbol&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015.Symbol&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="debc8254100406c5b68cd5702db34e72209e2f8d" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2015&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2015&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78126259e0963688ebb08f36a73d6c799b073eec" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2016.Array.Include&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2016.Array.Include&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e9a7ec10d0799c7a3562b7bbb313750b7a289db" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2016&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2016&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a665a55ca393bb2b96c73c5e204e2aef365467cd" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2017.Intl&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2017.Intl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8eaaf2137eaa25170c70ba6286e2d33a38fed7b2" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2017.SharedMemory&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2017.SharedMemory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d17cc488545495baaa08dc61e669b6ddf908f5b7" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2017.String&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2017.String&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bdb646c3bedbcc29d8be079d57fe5ac3a60ea079" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2017.TypedArrays&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2017.TypedArrays&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="218a64ec3941de7aa91db9c205e1758ec508c6dd" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2017.object&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2017.object&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12e6badb0024de3123266d40221edae5660ea99e" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2017&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2017&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3074fab26a5e8d10900ec2d6d1eac19c6549c9ac" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2018.Intl&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2018.Intl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="844e0de281a761a5d92adac4e473d8eb93d6019e" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2018.Promise&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2018.Promise&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0761ef5b4729a2ef5d15a9a058729752fea1133c" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2018.RegExp&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2018.RegExp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f57fe015079a86ed931fe29d12ebca670336e37" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES2018&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES2018&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c53f2e0cec43a786e37978cbdeed0943a7737d81" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES5&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES5&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3c9b000aa4d3de66e7fd3aa6b44859fdcd4f7a4" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES6&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4c27add263135ed08f5caf37050bac935c7b692" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ES7&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ES7&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d15b1612ad531e0a4b75b9e54f4adcd7c3c12c42" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ESNext.Array&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ESNext.Array&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8dff6beee12a2b287f35eab806bdb12a6be847fa" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ESNext.AsyncIterable&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ESNext.AsyncIterable&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a5fa85e735a190cd054468ff644c46914ff3674" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ESNext.Intl&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ESNext.Intl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df412653808d06029700eb4304fb7614577752bb" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ESNext.Symbol&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ESNext.Symbol&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a1663a21aa10900239c2ae707fb3128d4eb2eb6c" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ESNext&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ESNext&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6584792a54e8be52a8f0764a167be7103b57f075" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;ScriptHost&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;ScriptHost&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e94b9e04cb8b1657f6c51540bd4e392f524e23ca" translate="yes" xml:space="preserve">
          <source>► &lt;code&gt;WebWorker&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;WebWorker&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="048dc6e23b9b641360a0028bca639bba6cc9378f" translate="yes" xml:space="preserve">
          <source>► Czech: &lt;code&gt;cs&lt;/code&gt;</source>
          <target state="translated">► 체코 어 : &lt;code&gt;cs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71f77828941d25c5ac040a5a040581f80b6166b6" translate="yes" xml:space="preserve">
          <source>► English (US): &lt;code&gt;en&lt;/code&gt;</source>
          <target state="translated">► 영어 (미국) : &lt;code&gt;en&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="34d60307389f13e914979ca86d4c55fb798d063a" translate="yes" xml:space="preserve">
          <source>► For &lt;code&gt;--target ES5&lt;/code&gt;: &lt;code&gt;DOM,ES5,ScriptHost&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;--target ES5&lt;/code&gt; 의 경우 : &lt;code&gt;DOM,ES5,ScriptHost&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="705f262e39e23028473369800bface249c036bc4" translate="yes" xml:space="preserve">
          <source>► For &lt;code&gt;--target ES6&lt;/code&gt;: &lt;code&gt;DOM,ES6,DOM.Iterable,ScriptHost&lt;/code&gt;</source>
          <target state="translated">► &lt;code&gt;--target ES6&lt;/code&gt; 의 경우 : &lt;code&gt;DOM,ES6,DOM.Iterable,ScriptHost&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9befa02c3588bb3adb57741308a907a417ffb48" translate="yes" xml:space="preserve">
          <source>► French: &lt;code&gt;fr&lt;/code&gt;</source>
          <target state="translated">► 프랑스어 : &lt;code&gt;fr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f363eac4c80ca485f6ef894da55b93819cc82a9" translate="yes" xml:space="preserve">
          <source>► German: &lt;code&gt;de&lt;/code&gt;</source>
          <target state="translated">► 독일어 : &lt;code&gt;de&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07c1d6e417eec863289b4c3a383eed1cf747da60" translate="yes" xml:space="preserve">
          <source>► Italian: &lt;code&gt;it&lt;/code&gt;</source>
          <target state="translated">► 이탈리아어 : &lt;code&gt;it&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="953321065891c804824f20c999c4524003717550" translate="yes" xml:space="preserve">
          <source>► Japanese: &lt;code&gt;ja&lt;/code&gt;</source>
          <target state="translated">► 일본어 : &lt;code&gt;ja&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7f9c395abbce8017dc3cd8d4a435483e66ae7a69" translate="yes" xml:space="preserve">
          <source>► Korean: &lt;code&gt;ko&lt;/code&gt;</source>
          <target state="translated">► 한국어 : &lt;code&gt;ko&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f7879eed2ae7c8be2c64ee7adbfa4e2dc1475f8" translate="yes" xml:space="preserve">
          <source>► Only &lt;code&gt;&quot;AMD&quot;&lt;/code&gt; and &lt;code&gt;&quot;System&quot;&lt;/code&gt; can be used in conjunction with &lt;code&gt;--outFile&lt;/code&gt;.</source>
          <target state="translated">► &lt;code&gt;&quot;AMD&quot;&lt;/code&gt; &lt;code&gt;--outFile&lt;/code&gt; &lt;code&gt;&quot;System&quot;&lt;/code&gt; 과 함께 &quot;AMD&quot; 및 &quot;System&quot;만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="333d90759221353a8acd3bf17a36dac6afed796f" translate="yes" xml:space="preserve">
          <source>► Polish: &lt;code&gt;pl&lt;/code&gt;</source>
          <target state="translated">► 폴란드어 : &lt;code&gt;pl&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51f366bfbd6e88e5b63d40f9a7d63a7487000fb5" translate="yes" xml:space="preserve">
          <source>► Portuguese(Brazil): &lt;code&gt;pt-BR&lt;/code&gt;</source>
          <target state="translated">► 포르투갈어 (브라질) : &lt;code&gt;pt-BR&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="449b0bf7aea26b130bc83417a80f42ebcb84e8aa" translate="yes" xml:space="preserve">
          <source>► Russian: &lt;code&gt;ru&lt;/code&gt;</source>
          <target state="translated">► 러시아어 : &lt;code&gt;ru&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d31f80bee83c17d3ffbb6a6553b8204f0de8c1f" translate="yes" xml:space="preserve">
          <source>► Simplified Chinese: &lt;code&gt;zh-CN&lt;/code&gt;</source>
          <target state="translated">► 중국어 간체 : &lt;code&gt;zh-CN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fd8652669d33790313d668b077beb663ad641b2" translate="yes" xml:space="preserve">
          <source>► Spanish: &lt;code&gt;es&lt;/code&gt;</source>
          <target state="translated">► 스페인어 : &lt;code&gt;es&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="78fa8f5dcdcac9d793bf90012a070be47765d3e0" translate="yes" xml:space="preserve">
          <source>► Traditional Chinese: &lt;code&gt;zh-TW&lt;/code&gt;</source>
          <target state="translated">► 중국어 번체 : &lt;code&gt;zh-TW&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e808ba97d84c3ea43476d7234bfb3dd8344f418b" translate="yes" xml:space="preserve">
          <source>► Turkish: &lt;code&gt;tr&lt;/code&gt;</source>
          <target state="translated">► 터키어 : &lt;code&gt;tr&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
