<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="typescript">
    <body>
      <group id="typescript">
        <trans-unit id="464d90ddf01b4a7d7fb2059732ea18c0a56423b4" translate="yes" xml:space="preserve">
          <source>Extending Interfaces</source>
          <target state="translated">인터페이스 확장</target>
        </trans-unit>
        <trans-unit id="70c729194ffb9f8bd9ec475f03a3057bb1e60a4e" translate="yes" xml:space="preserve">
          <source>Extending expressions</source>
          <target state="translated">식 확장</target>
        </trans-unit>
        <trans-unit id="a3843d37d93289eadbc1958c41f1c13c309bbf8e" translate="yes" xml:space="preserve">
          <source>Extract&amp;lt;T,U&amp;gt;</source>
          <target state="translated">Extract&amp;lt;T,U&amp;gt;</target>
        </trans-unit>
        <trans-unit id="515872ad64c38522409e00410e68ba6e32a29116" translate="yes" xml:space="preserve">
          <source>Extracts the type of the &lt;code&gt;this&lt;/code&gt; parameter of a function type, or &lt;code&gt;unknown&lt;/code&gt; if the function type has no &lt;code&gt;this&lt;/code&gt; parameter.</source>
          <target state="translated">추출물의 유형 &lt;code&gt;this&lt;/code&gt; 함수 유형의 매개 변수 또는 &lt;code&gt;unknown&lt;/code&gt; 함수 타입이없는 경우 &lt;code&gt;this&lt;/code&gt; 매개 변수를.</target>
        </trans-unit>
        <trans-unit id="5580687121fcfefa146981fb36d296bc3f0de348" translate="yes" xml:space="preserve">
          <source>Factories</source>
          <target state="translated">Factories</target>
        </trans-unit>
        <trans-unit id="bead528d19950f71ea30380d09df640a3d7210ca" translate="yes" xml:space="preserve">
          <source>Factory Functions</source>
          <target state="translated">공장 기능</target>
        </trans-unit>
        <trans-unit id="4a32e2f9caf4e668d29618328e51a2647e2d967d" translate="yes" xml:space="preserve">
          <source>Faster &lt;code&gt;tsc --watch&lt;/code&gt;</source>
          <target state="translated">빠른 &lt;code&gt;tsc --watch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbdafc5050207465ed19f95ed57e21102e2c0067" translate="yes" xml:space="preserve">
          <source>Faster subsequent builds with the &lt;code&gt;--incremental&lt;/code&gt; flag</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; 플래그로 더 빠른 후속 빌드</target>
        </trans-unit>
        <trans-unit id="a29227a71e68767de435c445f3ac1547081655fc" translate="yes" xml:space="preserve">
          <source>Feedback from our community, as well as our own experience, has shown us that leveraging the newest TypeScript features while also accommodating users on the older versions are difficult. TypeScript introduces a new feature called &lt;code&gt;typesVersions&lt;/code&gt; to help accommodate these scenarios.</source>
          <target state="translated">우리의 경험과 커뮤니티의 의견에 따르면 최신 TypeScript 기능을 활용하는 동시에 이전 버전의 사용자를 수용하는 것이 어렵다는 것을 알 수 있습니다. TypeScript에는 이러한 시나리오를 수용하는 데 도움이되는 &lt;code&gt;typesVersions&lt;/code&gt; 라는 새로운 기능이 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6748207b859ccfa7f82ac49d731d1b27113a3b98" translate="yes" xml:space="preserve">
          <source>File does not exist, move to the second substitution</source>
          <target state="translated">파일이 존재하지 않습니다. 두 번째 대체로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="0fe8300347a5d2fe3f7b4e21e6708ddf628f2eeb" translate="yes" xml:space="preserve">
          <source>File exists. Done.</source>
          <target state="translated">파일이 존재. 끝난.</target>
        </trans-unit>
        <trans-unit id="1214946f7d95ef7612951c5654019274eb30d8ea" translate="yes" xml:space="preserve">
          <source>File path</source>
          <target state="translated">파일 경로</target>
        </trans-unit>
        <trans-unit id="f1b26fa5a34d56fb3e3920fe7c3dc4952d2ae44c" translate="yes" xml:space="preserve">
          <source>Files in &lt;code&gt;src/views&lt;/code&gt; are user code for some UI controls. Files in &lt;code&gt;generated/templates&lt;/code&gt; are UI template binding code auto-generated by a template generator as part of the build. A build step will copy the files in &lt;code&gt;/src/views&lt;/code&gt; and &lt;code&gt;/generated/templates/views&lt;/code&gt; to the same directory in the output. At run-time, a view can expect its template to exist next to it, and thus should import it using a relative name as &lt;code&gt;&quot;./template&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;src/views&lt;/code&gt; 의 파일은 일부 UI 컨트롤의 사용자 코드입니다. 의 파일 &lt;code&gt;generated/templates&lt;/code&gt; UI 템플릿 바인딩 코드가 빌드의 일부로 템플릿 생성기로 자동 생성됩니다. 빌드 단계는 &lt;code&gt;/src/views&lt;/code&gt; 및 &lt;code&gt;/generated/templates/views&lt;/code&gt; 의 파일을 출력의 동일한 디렉토리로 복사합니다 . 런타임시보기는 템플리트가 옆에 존재할 것으로 예상 할 수 있으므로 상대 이름을 &lt;code&gt;&quot;./template&quot;&lt;/code&gt; 으로 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="944999053b7485f3f5c651758da5734b4f1b2630" translate="yes" xml:space="preserve">
          <source>Files included using &lt;code&gt;&quot;include&quot;&lt;/code&gt; can be filtered using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. However, files included explicitly using the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property are always included regardless of &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;. The &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property defaults to excluding the &lt;code&gt;node_modules&lt;/code&gt;, &lt;code&gt;bower_components&lt;/code&gt;, &lt;code&gt;jspm_packages&lt;/code&gt; and &lt;code&gt;&amp;lt;outDir&amp;gt;&lt;/code&gt; directories when not specified.</source>
          <target state="translated">&lt;code&gt;&quot;include&quot;&lt;/code&gt; 를 사용하여 포함 된 파일 은 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 속성을 사용하여 필터링 할 수 있습니다 . 그러나 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 특성을 사용하여 명시 적으로 포함 된 파일 은 항상 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 에 관계없이 포함 됩니다. &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 제외에 속성 기본값 &lt;code&gt;node_modules&lt;/code&gt; , &lt;code&gt;bower_components&lt;/code&gt; , &lt;code&gt;jspm_packages&lt;/code&gt; 은 및 &lt;code&gt;&amp;lt;outDir&amp;gt;&lt;/code&gt; 디렉토리를 지정하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="c86be6e064d368e35d514286147756e446d3864b" translate="yes" xml:space="preserve">
          <source>Files included using &lt;code&gt;&quot;include&quot;&lt;/code&gt; can be filtered using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. However, files included explicitly using the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property are always included regardless of &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;. The &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property defaults to excluding the &lt;code&gt;node_modules&lt;/code&gt;, &lt;code&gt;bower_components&lt;/code&gt;, and &lt;code&gt;jspm_packages&lt;/code&gt; directories when not specified.</source>
          <target state="translated">&lt;code&gt;&quot;include&quot;&lt;/code&gt; 를 사용하여 포함 된 파일 은 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 속성을 사용하여 필터링 할 수 있습니다 . 그러나 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 특성을 사용하여 명시 적으로 포함 된 파일 은 항상 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 에 관계없이 포함 됩니다. &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 제외에 속성 기본값을 &lt;code&gt;node_modules&lt;/code&gt; , &lt;code&gt;bower_components&lt;/code&gt; 및 &lt;code&gt;jspm_packages&lt;/code&gt; 의 지정되지 않은 경우 디렉토리.</target>
        </trans-unit>
        <trans-unit id="a0de52ada9537ab464bb6d45e97f86eaaff6bac8" translate="yes" xml:space="preserve">
          <source>Final result</source>
          <target state="translated">최종 결과</target>
        </trans-unit>
        <trans-unit id="c716a5f69a835c7b207ef913676c36b3f4cf7fe7" translate="yes" xml:space="preserve">
          <source>Finally, ES2015 introduced the &lt;code&gt;for..of&lt;/code&gt; statement as a means of iterating over an iterable. Similarly, the Async Iteration proposal introduces the &lt;code&gt;for..await..of&lt;/code&gt; statement to iterate over an async iterable:</source>
          <target state="translated">마지막으로 ES2015는 &lt;code&gt;for..of&lt;/code&gt; 문을 iterable을 반복하는 수단으로 소개했습니다 . 마찬가지로 비동기 반복 제안에서는 비동기 반복 가능을 반복하기 위해 &lt;code&gt;for..await..of&lt;/code&gt; 문을 도입합니다 .</target>
        </trans-unit>
        <trans-unit id="7d78a77f9353986a905d8c074f3df1efad103d2d" translate="yes" xml:space="preserve">
          <source>Finally, add &lt;code&gt;src/greet.ts&lt;/code&gt; to &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">마지막으로, &lt;code&gt;src/greet.ts&lt;/code&gt; 를 &lt;code&gt;tsconfig.json&lt;/code&gt; 에 추가하십시오 :</target>
        </trans-unit>
        <trans-unit id="48e51bf84514484baa2e7212c0375ccee83ffca6" translate="yes" xml:space="preserve">
          <source>Finally, if the compiler could not resolve the module, it will log an error. In this case, the error would be something like &lt;code&gt;error TS2307: Cannot find module 'moduleA'.&lt;/code&gt;</source>
          <target state="translated">마지막으로 컴파일러에서 모듈을 확인할 수 없으면 오류가 기록됩니다. 이 경우 &lt;code&gt;error TS2307: Cannot find module 'moduleA'.&lt;/code&gt; 와 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c70f3dc4718552bbb66574b06291ac4442a2ee94" translate="yes" xml:space="preserve">
          <source>Finally, if your target is ES5 or ES3, you&amp;rsquo;ll also need to set the &lt;code&gt;--downlevelIterators&lt;/code&gt; flag.</source>
          <target state="translated">마지막으로 대상이 ES5 또는 ES3 인 경우 &lt;code&gt;--downlevelIterators&lt;/code&gt; 플래그도 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="625382271b526d5909aa39a000a69074afb94c9c" translate="yes" xml:space="preserve">
          <source>Finally, let&amp;rsquo;s extend the example one last time with classes. TypeScript supports new features in JavaScript, like support for class-based object-oriented programming.</source>
          <target state="translated">마지막으로 클래스를 사용하여 예제를 마지막으로 확장 해 봅시다. TypeScript는 클래스 기반 객체 지향 프로그래밍 지원과 같은 JavaScript의 새로운 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c6b76794e34c66667cc7c06423ff09561a2db9b4" translate="yes" xml:space="preserve">
          <source>Finally, we could perform many different merges using &lt;code&gt;namespace&lt;/code&gt; declarations. This isn&amp;rsquo;t a particularly realistic example, but shows all sorts of interesting behavior:</source>
          <target state="translated">마지막으로 &lt;code&gt;namespace&lt;/code&gt; 선언을 사용하여 다양한 병합을 수행 할 수 있습니다. 이것은 특히 현실적인 예는 아니지만 모든 종류의 흥미로운 동작을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2a1cbf967f1f59d7ed905556a7ba174d0d91c432" translate="yes" xml:space="preserve">
          <source>Finally, we mix our mixins into the class implementation.</source>
          <target state="translated">마지막으로 믹스 인을 클래스 구현에 혼합합니다.</target>
        </trans-unit>
        <trans-unit id="5d24682490796967f2d44a64ea932e79d1b2fb40" translate="yes" xml:space="preserve">
          <source>Finally, you can make index signatures &lt;code&gt;readonly&lt;/code&gt; in order to prevent assignment to their indices:</source>
          <target state="translated">마지막으로 인덱스에 할당되지 않도록 인덱스 서명을 &lt;code&gt;readonly&lt;/code&gt; 으로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36f4ab4ec74314f1c6473ad2b642469fa92db24a" translate="yes" xml:space="preserve">
          <source>Find all referenced projects</source>
          <target state="translated">참조 된 모든 프로젝트 찾기</target>
        </trans-unit>
        <trans-unit id="f36d6416266be79de49dbd1cd5564e2c29d74695" translate="yes" xml:space="preserve">
          <source>Find and Install Declaration Files</source>
          <target state="translated">선언 파일 찾기 및 설치</target>
        </trans-unit>
        <trans-unit id="107a7b9e0a62d571bcbb1e3e04401f38fb4be3c9" translate="yes" xml:space="preserve">
          <source>Finished with that step? Great! You&amp;rsquo;ve successfully migrated a file from JavaScript to TypeScript!</source>
          <target state="translated">그 단계로 끝났습니까? 큰! JavaScript에서 TypeScript로 파일을 성공적으로 마이그레이션했습니다!</target>
        </trans-unit>
        <trans-unit id="c8bb450db4ab929fdfadf7c4e435fbd8ded8de50" translate="yes" xml:space="preserve">
          <source>First ensure Webpack is installed.</source>
          <target state="translated">먼저 Webpack이 설치되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3df868c33500281a256aa0f7044d7222e49fa905" translate="yes" xml:space="preserve">
          <source>First install Babelify and the Babel preset for ES2015. Like Uglify, Babelify mangles code, so we&amp;rsquo;ll need vinyl-buffer and gulp-sourcemaps. By default Babelify will only process files with extensions of &lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.es&lt;/code&gt;, &lt;code&gt;.es6&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; so we need to add the &lt;code&gt;.ts&lt;/code&gt; extension as an option to Babelify.</source>
          <target state="translated">먼저 ES2015에 대한 Babelify 및 Babel 사전 설정을 설치하십시오. Uglify와 마찬가지로 Babelify는 맹글 코드를 작성하므로 비닐 버퍼와 펄프 소스 맵이 필요합니다. 기본적으로 Babelify는 확장자가 &lt;code&gt;.js&lt;/code&gt; , &lt;code&gt;.es&lt;/code&gt; , &lt;code&gt;.es6&lt;/code&gt; 및 &lt;code&gt;.jsx&lt;/code&gt; 인 파일 만 처리 하므로 Babelify의 옵션으로 &lt;code&gt;.ts&lt;/code&gt; 확장자 를 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="735b0c16eaf95bad801406a590783a07bff54840" translate="yes" xml:space="preserve">
          <source>First install Uglify. Since the point of Uglify is to mangle your code, we also need to install vinyl-buffer and gulp-sourcemaps to keep sourcemaps working.</source>
          <target state="translated">먼저 Uglify를 설치하십시오. Uglify의 요점은 코드를 엉망으로 만드는 것이므로 소스 맵이 계속 작동하도록 비닐 버퍼와 gulp-sourcemap을 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="89e20ebbee86fab209c76b802ba242b064d21b1b" translate="yes" xml:space="preserve">
          <source>First of all, they&amp;rsquo;re important because they allow TypeScript to type-check against other projects without re-checking the original source code. They&amp;rsquo;re also important because they allow TypeScript to interoperate with existing JavaScript libraries that weren&amp;rsquo;t built with TypeScript in mind. Finally, a benefit that is often underappreciated: both TypeScript &lt;em&gt;and&lt;/em&gt; JavaScript users can benefit from these files when using editors powered by TypeScript to get things like better auto-completion.</source>
          <target state="translated">우선, 원본 소스 코드를 다시 확인하지 않고도 TypeScript가 다른 프로젝트에 대해 유형 검사를 할 수 있기 때문에 중요합니다. TypeScript가 TypeScript를 염두에두고 구축되지 않은 기존 JavaScript 라이브러리와 상호 운용 될 수 있도록하기 때문에 중요합니다. 마지막으로, 종종 과소 평가되는 이점 : TypeScript &lt;em&gt;및&lt;/em&gt; JavaScript 사용자는 TypeScript 기반의 편집기를 사용하여 더 나은 자동 완성과 같은 작업을 수행 할 때 이러한 파일을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8618e8a440e50c5a75000139af77b5f2c4300871" translate="yes" xml:space="preserve">
          <source>First some terminology</source>
          <target state="translated">먼저 몇 가지 용어</target>
        </trans-unit>
        <trans-unit id="99290d59716a55c82e8b063db8bf7f05e1a4b00b" translate="yes" xml:space="preserve">
          <source>First steps</source>
          <target state="translated">첫 단계</target>
        </trans-unit>
        <trans-unit id="8336905fe9b50c35195d1e701772f27af4d34cab" translate="yes" xml:space="preserve">
          <source>First we declare the interfaces we will union. Each interface has a &lt;code&gt;kind&lt;/code&gt; property with a different string literal type. The &lt;code&gt;kind&lt;/code&gt; property is called the &lt;em&gt;discriminant&lt;/em&gt; or &lt;em&gt;tag&lt;/em&gt;. The other properties are specific to each interface. Notice that the interfaces are currently unrelated. Let&amp;rsquo;s put them into a union:</source>
          <target state="translated">먼저 통합 할 인터페이스를 선언합니다. 각 인터페이스에는 다른 문자열 리터럴 유형 의 &lt;code&gt;kind&lt;/code&gt; 속성이 있습니다. &lt;code&gt;kind&lt;/code&gt; 속성은이라고 &lt;em&gt;판별&lt;/em&gt; 또는 &lt;em&gt;태그&lt;/em&gt; . 다른 속성은 각 인터페이스에 따라 다릅니다. 인터페이스는 현재 관련이 없습니다. 그것들을 노동 조합에 넣자 :</target>
        </trans-unit>
        <trans-unit id="a34ce699f43cedcd3aa6a4d39d183ca5e70a6e0b" translate="yes" xml:space="preserve">
          <source>First we need to tell TypeScript how to build. Right click on &lt;code&gt;scripts&lt;/code&gt; and click &lt;strong&gt;New Item&lt;/strong&gt;. Then choose &lt;strong&gt;TypeScript Configuration File&lt;/strong&gt; and use the default name of &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">먼저 TypeScript에 빌드 방법을 알려줘야합니다. &lt;code&gt;scripts&lt;/code&gt; 마우스 오른쪽 단추로 클릭하고 &lt;strong&gt;새 항목을&lt;/strong&gt; 클릭하십시오 . 그런 다음 &lt;strong&gt;TypeScript Configuration File을&lt;/strong&gt; 선택 하고 기본 이름 인 &lt;code&gt;tsconfig.json&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2dfb573ed967d8c6c17580ed779ecdccc14311ef" translate="yes" xml:space="preserve">
          <source>First, accessors require you to set the compiler to output ECMAScript 5 or higher. Downleveling to ECMAScript 3 is not supported. Second, accessors with a &lt;code&gt;get&lt;/code&gt; and no &lt;code&gt;set&lt;/code&gt; are automatically inferred to be &lt;code&gt;readonly&lt;/code&gt;. This is helpful when generating a &lt;code&gt;.d.ts&lt;/code&gt; file from your code, because users of your property can see that they can&amp;rsquo;t change it.</source>
          <target state="translated">먼저 접근자는 ECMAScript 5 이상을 출력하도록 컴파일러를 설정해야합니다. ECMAScript 3 로의 다운 레벨링은 지원되지 않습니다. 둘째, &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 이 없는 접근 자는 자동으로 &lt;code&gt;readonly&lt;/code&gt; 으로 유추됩니다 . 속성의 사용자가 파일을 변경할 수 없다는 것을 알 수 있기 때문에 코드에서 &lt;code&gt;.d.ts&lt;/code&gt; 파일을 생성 할 때 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="2f1af0e65e7f250987a6b875f7a585e406660a62" translate="yes" xml:space="preserve">
          <source>First, given types &lt;code&gt;T'&lt;/code&gt; and &lt;code&gt;U'&lt;/code&gt; that are instantiations of &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; where all occurrences of type parameters are replaced with &lt;code&gt;any&lt;/code&gt;, if &lt;code&gt;T'&lt;/code&gt; is not assignable to &lt;code&gt;U'&lt;/code&gt;, the conditional type is resolved to &lt;code&gt;Y&lt;/code&gt;. Intuitively, if the most permissive instantiation of &lt;code&gt;T&lt;/code&gt; is not assignable to the most permissive instantiation of &lt;code&gt;U&lt;/code&gt;, we know that no instantiation will be and we can just resolve to &lt;code&gt;Y&lt;/code&gt;.</source>
          <target state="translated">첫째, 주어진 유형의 &lt;code&gt;T'&lt;/code&gt; 와 &lt;code&gt;U'&lt;/code&gt; 의 인스턴스화입니다 &lt;code&gt;T&lt;/code&gt; 와 &lt;code&gt;U&lt;/code&gt; 형 매개 변수의 모든 항목이 대체됩니다 &lt;code&gt;any&lt;/code&gt; 경우, &lt;code&gt;T'&lt;/code&gt; 로 할당 할 수없는 &lt;code&gt;U'&lt;/code&gt; 는 조건부 유형에 해결 &lt;code&gt;Y&lt;/code&gt; . 직관적으로, &lt;code&gt;T&lt;/code&gt; 의 가장 허용 가능한 인스턴스화가 &lt;code&gt;U&lt;/code&gt; 의 가장 허용 가능한 인스턴스화에 할당 가능하지 않은 경우 , 우리는 인스턴스화가 없으며 &lt;code&gt;Y&lt;/code&gt; 로 해결할 수 있음을 알고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0f154b6d3560afc04e7423c292457f3d4c696d4" translate="yes" xml:space="preserve">
          <source>First, install &lt;a href=&quot;https://dotnet.microsoft.com/apps/aspnet&quot;&gt;ASP.NET Core&lt;/a&gt; if you need it. This quick-start guide requires Visual Studio 2015 or 2017.</source>
          <target state="translated">먼저 필요한 경우 &lt;a href=&quot;https://dotnet.microsoft.com/apps/aspnet&quot;&gt;ASP.NET Core를&lt;/a&gt; 설치 하십시오. 이 빠른 시작 가이드에는 Visual Studio 2015 또는 2017이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5fe122cf8e822627b9c191ebbd95f6c78e81f570" translate="yes" xml:space="preserve">
          <source>First, install browserify, &lt;a href=&quot;https://www.npmjs.com/package/tsify&quot;&gt;tsify&lt;/a&gt;, and vinyl-source-stream. tsify is a Browserify plugin that, like gulp-typescript, gives access to the TypeScript compiler. vinyl-source-stream lets us adapt the file output of Browserify back into a format that gulp understands called &lt;a href=&quot;https://github.com/gulpjs/vinyl&quot;&gt;vinyl&lt;/a&gt;.</source>
          <target state="translated">먼저 &lt;a href=&quot;https://www.npmjs.com/package/tsify&quot;&gt;browserify&lt;/a&gt; , tsify 및 vinyl-source-stream을 설치하십시오. tsify는 gulp-typescript와 같이 TypeScript 컴파일러에 대한 액세스를 제공하는 Browserify 플러그인입니다. 비닐 소스 스트림은 우리가 꿀꺽라는 이해할 수있는 형식으로 Browserify의 뒷면의 파일 출력을 적용 할 수 있습니다 &lt;a href=&quot;https://github.com/gulpjs/vinyl&quot;&gt;비닐&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51744cf60b9ea9e03623f5527d487a42b621f3c4" translate="yes" xml:space="preserve">
          <source>First, install the &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt; utility library:</source>
          <target state="translated">먼저 &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt; 유틸리티 라이브러리를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="f59152e91c742c2580784c2fb852897f78a3c5bd" translate="yes" xml:space="preserve">
          <source>First, the compiler will try to locate a file that represents the imported module. To do so the compiler follows one of two different strategies: &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; or &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt;. These strategies tell the compiler &lt;em&gt;where&lt;/em&gt; to look for &lt;code&gt;moduleA&lt;/code&gt;.</source>
          <target state="translated">먼저 컴파일러는 가져온 모듈을 나타내는 파일을 찾습니다. 이를 위해 컴파일러는 &lt;a href=&quot;#classic&quot;&gt;Classic&lt;/a&gt; 또는 &lt;a href=&quot;#node&quot;&gt;Node&lt;/a&gt; 의 두 가지 전략 중 하나를 따릅니다 . 이러한 전략은 컴파일러에게 &lt;em&gt;어디&lt;/em&gt; 에서 &lt;code&gt;moduleA&lt;/code&gt; 를 찾을 &lt;em&gt;것인지&lt;/em&gt; 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="fee2aae2ee58d3140d673d1cb82204dd56b9f63b" translate="yes" xml:space="preserve">
          <source>First, we can use concatenated output using the &lt;code&gt;--outFile&lt;/code&gt; flag to compile all of the input files into a single JavaScript output file:</source>
          <target state="translated">먼저 &lt;code&gt;--outFile&lt;/code&gt; 플래그를 사용하여 연결된 출력을 사용하여 모든 입력 파일을 단일 JavaScript 출력 파일로 컴파일 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28d19122adb2247e67a766539293d7db8d64dd97" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll review the kinds of libraries TypeScript declaration files can represent. We&amp;rsquo;ll briefly show how each kind of library is &lt;em&gt;used&lt;/em&gt;, how it is &lt;em&gt;written&lt;/em&gt;, and list some example libraries from the real world.</source>
          <target state="translated">먼저 TypeScript 선언 파일이 나타낼 수있는 라이브러리 종류를 검토합니다. 우리는 각 종류의 라이브러리가 어떻게 &lt;em&gt;사용&lt;/em&gt; 되는지, 어떻게 &lt;em&gt;작성&lt;/em&gt; 되는지 , 그리고 실제 세계에서 몇 가지 예제 라이브러리를 간략하게 보여줄 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a7a574b0f49a4d1d52dcd069a74b5d55c404e3a8" translate="yes" xml:space="preserve">
          <source>First, you&amp;rsquo;ll need to enable some module system by setting TypeScript&amp;rsquo;s &lt;code&gt;module&lt;/code&gt; flag. Valid options are &lt;code&gt;commonjs&lt;/code&gt;, &lt;code&gt;amd&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, and &lt;code&gt;umd&lt;/code&gt;.</source>
          <target state="translated">먼저 TypeScript의 &lt;code&gt;module&lt;/code&gt; 플래그를 설정하여 일부 모듈 시스템을 활성화해야합니다 . 유효한 옵션은 &lt;code&gt;commonjs&lt;/code&gt; , &lt;code&gt;amd&lt;/code&gt; , &lt;code&gt;system&lt;/code&gt; 및 &lt;code&gt;umd&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7d0c91cebd6414c6cadf4f9352001f643b829f0b" translate="yes" xml:space="preserve">
          <source>Fixed Length Tuples</source>
          <target state="translated">고정 길이 튜플</target>
        </trans-unit>
        <trans-unit id="3ca7815b9ccb9b2f4adbee87c52250c1c035669b" translate="yes" xml:space="preserve">
          <source>Flag unused declarations with &lt;code&gt;--noUnusedParameters&lt;/code&gt; and &lt;code&gt;--noUnusedLocals&lt;/code&gt;</source>
          <target state="translated">사용하지 않는 선언에 &lt;code&gt;--noUnusedParameters&lt;/code&gt; 및 &lt;code&gt;--noUnusedLocals&lt;/code&gt; 를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="82a9583e4b01eda6ab596923bd11954f7465daf4" translate="yes" xml:space="preserve">
          <source>Following this logic, the compiler will attempt to resolve the two imports as such:</source>
          <target state="translated">이 논리에 따라 컴파일러는 다음과 같이 두 가지 가져 오기를 해결하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="26431a2529d203186f1196ee3c1e08f1f5a1e8c1" translate="yes" xml:space="preserve">
          <source>Following up on specifying the type of &lt;code&gt;this&lt;/code&gt; in a class or an interface, functions and methods can now declare the type of &lt;code&gt;this&lt;/code&gt; they expect.</source>
          <target state="translated">유형 지정에 대한 후속 조치 &lt;code&gt;this&lt;/code&gt; 클래스 또는 인터페이스, 기능 및 방법은 지금의 유형을 선언 할 수 있습니다 &lt;code&gt;this&lt;/code&gt; 그들이 기대합니다.</target>
        </trans-unit>
        <trans-unit id="1c46fd3b2bfcf228c256745663f71fdbf4e9f242" translate="yes" xml:space="preserve">
          <source>Following up our example above, consider if &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; instead used a non-relative path and had the import &lt;code&gt;var x = require(&quot;moduleB&quot;);&lt;/code&gt;. Node would then try to resolve &lt;code&gt;moduleB&lt;/code&gt; to each of the locations until one worked.</source>
          <target state="translated">위의 예를 따라 &lt;code&gt;/root/src/moduleA.js&lt;/code&gt; 가 상대 경로가 아닌 경로를 사용하고 가져 오기가있는 경우 &lt;code&gt;var x = require(&quot;moduleB&quot;);&lt;/code&gt; . 그런 다음 노드는 &lt;code&gt;moduleB&lt;/code&gt; 가 작동 할 때까지 각 위치로 모듈 B 를 해결하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="d651257c7219d6828652b8ed3ae590398f5b2d5c" translate="yes" xml:space="preserve">
          <source>For JavaScript library users, the &lt;a href=&quot;consumption&quot;&gt;Consumption&lt;/a&gt; section offers a few simple steps to locate and install corresponding declaration files.</source>
          <target state="translated">JavaScript 라이브러리 사용자의 경우 &lt;a href=&quot;consumption&quot;&gt;소비&lt;/a&gt; 섹션은 해당 선언 파일을 찾아 설치하는 몇 가지 간단한 단계를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3f13871c6491a9fb503e0b3db6f8d157fced814c" translate="yes" xml:space="preserve">
          <source>For NPM users:</source>
          <target state="translated">NPM 사용자의 경우 :</target>
        </trans-unit>
        <trans-unit id="f29506c87493e2d6a8464c1671b709d1038182e2" translate="yes" xml:space="preserve">
          <source>For React, intrinsic elements are emitted as strings (&lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt;), whereas a component you&amp;rsquo;ve created is not (&lt;code&gt;React.createElement(MyComponent)&lt;/code&gt;).</source>
          <target state="translated">React의 경우 내장 요소는 문자열 ( &lt;code&gt;React.createElement(&quot;div&quot;)&lt;/code&gt; )로 생성되지만, 작성한 컴포넌트는 ( &lt;code&gt;React.createElement(MyComponent)&lt;/code&gt; ) 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="2bc6cffb51efec5345d518d22e0c722de0a63bbe" translate="yes" xml:space="preserve">
          <source>For VS 2013:</source>
          <target state="translated">VS 2013의 경우 :</target>
        </trans-unit>
        <trans-unit id="614775d6367bb72e6635063a6e9a003dfc10d404" translate="yes" xml:space="preserve">
          <source>For VS 2015:</source>
          <target state="translated">VS 2015의 경우 :</target>
        </trans-unit>
        <trans-unit id="fabf9dab407dafe6e4158a0fb10d99a963d13936" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;n in x&lt;/code&gt; expression, where &lt;code&gt;n&lt;/code&gt; is a string literal or string literal type and &lt;code&gt;x&lt;/code&gt; is a union type, the &amp;ldquo;true&amp;rdquo; branch narrows to types which have an optional or required property &lt;code&gt;n&lt;/code&gt;, and the &amp;ldquo;false&amp;rdquo; branch narrows to types which have an optional or missing property &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">A의 &lt;code&gt;n in x&lt;/code&gt; 표현, 여기서 &lt;code&gt;n&lt;/code&gt; 은 문자열의 문자 또는 문자열 리터럴 타입이며, &lt;code&gt;x&lt;/code&gt; 노조 타입, 옵션 또는 필수 속성이 유형에 &quot;true&quot;로 지점 좁히는 &lt;code&gt;n&lt;/code&gt; 및 유형에 &quot;거짓&quot;지점 좁아 선택적 또는 누락 된 속성 &lt;code&gt;n&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="59f0e903aa4d967be8cee2ad438a3b8e7a692972" translate="yes" xml:space="preserve">
          <source>For creating &lt;code&gt;--incremental&lt;/code&gt; builds, users can leverage the &lt;code&gt;createIncrementalProgram&lt;/code&gt; and &lt;code&gt;createIncrementalCompilerHost&lt;/code&gt; APIs. Users can also re-hydrate old program instances from &lt;code&gt;.tsbuildinfo&lt;/code&gt; files generated by this API using the newly exposed &lt;code&gt;readBuilderProgram&lt;/code&gt; function, which is only meant to be used as for creating new programs (i.e. you can&amp;rsquo;t modify the returned instance - it&amp;rsquo;s only meant to be used for the &lt;code&gt;oldProgram&lt;/code&gt; parameter in other &lt;code&gt;create*Program&lt;/code&gt; functions).</source>
          <target state="translated">&lt;code&gt;--incremental&lt;/code&gt; 빌드 를 작성하기 위해 사용자는 &lt;code&gt;createIncrementalProgram&lt;/code&gt; 및 &lt;code&gt;createIncrementalCompilerHost&lt;/code&gt; API를 활용할 수 있습니다 . 사용자는 새로 노출 된 &lt;code&gt;readBuilderProgram&lt;/code&gt; 함수를 사용하여이 API에 의해 생성 된 &lt;code&gt;.tsbuildinfo&lt;/code&gt; 파일 에서 기존 프로그램 인스턴스를 다시 수화 할 수 있습니다. 이 기능은 새 프로그램을 만드는 데만 사용됩니다 (예 : 반환 된 인스턴스를 수정할 수 없음). 에 사용될 &lt;code&gt;oldProgram&lt;/code&gt; 의 다른 파라미터에 &lt;code&gt;create*Program&lt;/code&gt; 기능).</target>
        </trans-unit>
        <trans-unit id="13c650c5b2c3bf134743f81ee8a751c72f2c46d5" translate="yes" xml:space="preserve">
          <source>For declaration file authors who relay on built-in types, e.g. DOM APIs or built-in JS run-time constructors like &lt;code&gt;Symbol&lt;/code&gt; or &lt;code&gt;Iterable&lt;/code&gt;, triple-slash-reference lib directives are the recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.</source>
          <target state="translated">DOM API 또는 &lt;code&gt;Symbol&lt;/code&gt; 또는 &lt;code&gt;Iterable&lt;/code&gt; 과 같은 내장 JS 런타임 생성자와 같이 내장 유형을 릴레이하는 선언 파일 작성자의 경우 triple-slash-reference lib 지시문이 권장됩니다. 이전에는 이러한 .d.ts 파일에 이러한 유형의 전달 / 중복 선언을 추가해야했습니다.</target>
        </trans-unit>
        <trans-unit id="f730367034cc3e65c4c80c7cc48438917a47a1a4" translate="yes" xml:space="preserve">
          <source>For declaration file authors who rely on built-in types, e.g. DOM APIs or built-in JS run-time constructors like &lt;code&gt;Symbol&lt;/code&gt; or &lt;code&gt;Iterable&lt;/code&gt;, triple-slash-reference lib directives are recommended. Previously these .d.ts files had to add forward/duplicate declarations of such types.</source>
          <target state="translated">DOM API 또는 &lt;code&gt;Symbol&lt;/code&gt; 또는 &lt;code&gt;Iterable&lt;/code&gt; 과 같은 내장 JS 런타임 생성자와 같은 내장 유형에 의존하는 선언 파일 작성자의 경우 triple-slash-reference lib 지시문이 권장됩니다. 이전에는 이러한 .d.ts 파일에 이러한 유형의 전달 / 중복 선언을 추가해야했습니다.</target>
        </trans-unit>
        <trans-unit id="c7b31102ddf3ec0f8a01da2c2c2faaf0cec3c40b" translate="yes" xml:space="preserve">
          <source>For declaration files generated during compilation, the compiler will automatically add &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; for you; A &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; in a generated declaration file is added &lt;em&gt;if and only if&lt;/em&gt; the resulting file uses any declarations from the referenced package.</source>
          <target state="translated">컴파일 중에 생성 된 선언 파일의 경우 컴파일러는 자동으로 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; 를 추가합니다. 생성 된 선언 파일 의 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; 는 결과 파일이 참조 된 패키지의 선언을 사용하는 &lt;em&gt;경우에만&lt;/em&gt; 추가 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4710530ea547f1515550efbf2971f53cc2a8b738" translate="yes" xml:space="preserve">
          <source>For declaring a dependency on an &lt;code&gt;@types&lt;/code&gt; package in a &lt;code&gt;.ts&lt;/code&gt; file, use &lt;code&gt;--types&lt;/code&gt; on the command line or in your &lt;code&gt;tsconfig.json&lt;/code&gt; instead. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;using &lt;code&gt;@types&lt;/code&gt;, &lt;code&gt;typeRoots&lt;/code&gt; and &lt;code&gt;types&lt;/code&gt; in &lt;code&gt;tsconfig.json&lt;/code&gt; files&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;.ts&lt;/code&gt; 파일 의 &lt;code&gt;@types&lt;/code&gt; 패키지에 대한 종속성을 선언 하려면 대신 명령 행 또는 &lt;code&gt;tsconfig.json&lt;/code&gt; 에서 &lt;code&gt;--types&lt;/code&gt; 를 사용 하십시오 . 자세한 내용 &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;은 &lt;/a&gt; &lt;code&gt;tsconfig.json&lt;/code&gt; 파일 에서 &lt;code&gt;@types&lt;/code&gt; , &lt;code&gt;typeRoots&lt;/code&gt; 및 &lt;code&gt;types&lt;/code&gt; 사용 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b927d147a48a1d8a678317e5dc270ab1fa0bd354" translate="yes" xml:space="preserve">
          <source>For example consider this project structure:</source>
          <target state="translated">예를 들어이 프로젝트 구조를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="b84169ea004a1106235d82bc2a5c66557575c167" translate="yes" xml:space="preserve">
          <source>For example, adding &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; to one of the files in a compilation is equivalent to compiling with &lt;code&gt;--lib es2017.string&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 컴파일에서 파일 중 하나에 &lt;code&gt;/// &amp;lt;reference lib=&quot;es2017.string&quot; /&amp;gt;&lt;/code&gt; 를 추가하는 것은 &lt;code&gt;--lib es2017.string&lt;/code&gt; 을 사용 하여 컴파일하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9f435730a5bc00012d3042f3d1a8d4332e64f206" translate="yes" xml:space="preserve">
          <source>For example, an import statement like &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; in &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; would result in attempting the following locations for locating &lt;code&gt;&quot;./moduleB&quot;&lt;/code&gt;:</source>
          <target state="translated">예를 들어, 같은 import 문 &lt;code&gt;import { b } from &quot;./moduleB&quot;&lt;/code&gt; 의 &lt;code&gt;/root/src/moduleA.ts&lt;/code&gt; 은 위치에 대해 다음 위치 시도 될 것 &lt;code&gt;&quot;./moduleB&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4dfb27ce129bee760fed1ebcb688044df6ad992b" translate="yes" xml:space="preserve">
          <source>For example, given the decorator &lt;code&gt;@sealed&lt;/code&gt; we might write the &lt;code&gt;sealed&lt;/code&gt; function as follows:</source>
          <target state="translated">예를 들어, 데코레이터 &lt;code&gt;@sealed&lt;/code&gt; 를 사용하면 다음과 같이 &lt;code&gt;sealed&lt;/code&gt; 함수를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba290a075f0c2045568e30b972340550a085db75" translate="yes" xml:space="preserve">
          <source>For example, including &lt;code&gt;/// &amp;lt;reference types=&quot;node&quot; /&amp;gt;&lt;/code&gt; in a declaration file declares that this file uses names declared in &lt;code&gt;@types/node/index.d.ts&lt;/code&gt;; and thus, this package needs to be included in the compilation along with the declaration file.</source>
          <target state="translated">예를 들어 선언 파일에 &lt;code&gt;/// &amp;lt;reference types=&quot;node&quot; /&amp;gt;&lt;/code&gt; 를 포함하면이 파일이 &lt;code&gt;@types/node/index.d.ts&lt;/code&gt; 선언 된 이름을 사용함을 선언합니다 . 따라서이 패키지는 선언 파일과 함께 컴파일에 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7f2169f30439c664d4891dafe1197f03d77f4716" translate="yes" xml:space="preserve">
          <source>For example, it&amp;rsquo;s often very common to forget to &lt;code&gt;.then()&lt;/code&gt; or &lt;code&gt;await&lt;/code&gt; the contents of a &lt;code&gt;Promise&lt;/code&gt; before passing it to another function. TypeScript&amp;rsquo;s error messages are now specialized, and inform the user that perhaps they should consider using the &lt;code&gt;await&lt;/code&gt; keyword.</source>
          <target state="translated">예를 들어, 다른 함수에 전달하기 전에 &lt;code&gt;.then()&lt;/code&gt; 을 잊 거나 &lt;code&gt;Promise&lt;/code&gt; 의 내용을 &lt;code&gt;await&lt;/code&gt; 것이 일반적 입니다. TypeScript의 오류 메시지는 이제 특수화되었으며 사용자에게 &lt;code&gt;await&lt;/code&gt; 키워드 사용을 고려해야한다고 알립니다 .</target>
        </trans-unit>
        <trans-unit id="ffcedc1552ccfc47d112e6dad0906deb0847258a" translate="yes" xml:space="preserve">
          <source>For example, once you&amp;rsquo;ve &lt;code&gt;npm install&lt;/code&gt;-ed your type declarations, you can use imports and write</source>
          <target state="translated">예를 들어, &lt;code&gt;npm install&lt;/code&gt; 유형 선언을 가져 오면 가져 오기를 사용하고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="502a1d2b7504dbb10d71367198e70328d93e9cdc" translate="yes" xml:space="preserve">
          <source>For example, some libraries add new functions to &lt;code&gt;Array.prototype&lt;/code&gt; or &lt;code&gt;String.prototype&lt;/code&gt;.</source>
          <target state="translated">예를 들어 일부 라이브러리는 &lt;code&gt;Array.prototype&lt;/code&gt; 또는 &lt;code&gt;String.prototype&lt;/code&gt; 에 새 함수를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="6eec7c26069b784720c61be112395d7efa3ccaf5" translate="yes" xml:space="preserve">
          <source>For example, the following extracts the return type of a function type:</source>
          <target state="translated">예를 들어, 다음은 함수 유형의 리턴 유형을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="a37862b00fe2100e1e8f8d8cb1ffd54013028ebd" translate="yes" xml:space="preserve">
          <source>For example, the following sample declares variables &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;, and initializes them to &lt;code&gt;getSomeObject().x&lt;/code&gt;, &lt;code&gt;getSomeObject().y&lt;/code&gt; and &lt;code&gt;getSomeObject().z&lt;/code&gt; respectively:</source>
          <target state="translated">예를 들어 다음 샘플은 변수 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 를 선언 하고 각각 &lt;code&gt;getSomeObject().x&lt;/code&gt; , &lt;code&gt;getSomeObject().y&lt;/code&gt; 및 &lt;code&gt;getSomeObject().z&lt;/code&gt; 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="3bfab5d35b8a0425d2cd933627ba6f494f7b15e6" translate="yes" xml:space="preserve">
          <source>For example, we can add a static member to a class:</source>
          <target state="translated">예를 들어 클래스에 정적 멤버를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49d355e75376d6e3edd30760b3a9dda119888e8c" translate="yes" xml:space="preserve">
          <source>For function components (formerly known as SFCs) use ES2015 default initializers:</source>
          <target state="translated">함수 구성 요소 (이전의 SFC)의 경우 ES2015 기본 초기화 프로그램을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6be2baf6180fb6fd27b9800124346282c6fe8435" translate="yes" xml:space="preserve">
          <source>For function members, each function member of the same name is treated as describing an overload of the same function. Of note, too, is that in the case of interface &lt;code&gt;A&lt;/code&gt; merging with later interface &lt;code&gt;A&lt;/code&gt;, the second interface will have a higher precedence than the first.</source>
          <target state="translated">함수 멤버의 경우 동일한 이름의 각 함수 멤버는 동일한 함수의 오버로드를 설명하는 것으로 간주됩니다. 또한 인터페이스 &lt;code&gt;A&lt;/code&gt; 가 이후 인터페이스 &lt;code&gt;A&lt;/code&gt; 와 병합 하는 경우 두 번째 인터페이스가 첫 번째 인터페이스보다 우선 순위가 높다는 점에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="550510b2afc3402e9b75627c000d9fd8d68b9d48" translate="yes" xml:space="preserve">
          <source>For function types to correctly type check, the names of the parameters do not need to match. We could have, for example, written the above example like this:</source>
          <target state="translated">함수 유형이 올바르게 유형을 확인하기 위해 매개 변수 이름이 일치하지 않아도됩니다. 예를 들어 위의 예를 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e49fcf610fb59d8414be6f760fd4d96f45600af" translate="yes" xml:space="preserve">
          <source>For generic types that do not have their type arguments specified, compatibility is checked by specifying &lt;code&gt;any&lt;/code&gt; in place of all unspecified type arguments. The resulting types are then checked for compatibility, just as in the non-generic case.</source>
          <target state="translated">형식 인수가 지정되지 않은 일반 형식의 경우 지정 되지 않은 모든 형식 인수 대신 &lt;code&gt;any&lt;/code&gt; 의 형식 인수를 지정하여 호환성을 검사합니다 . 그런 다음 일반적인 유형이 아닌 경우와 같이 결과 유형의 호환성을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="5b3be90cb960b60b8143e001874d26a541dce254" translate="yes" xml:space="preserve">
          <source>For instance, &lt;code&gt;React.Component&lt;/code&gt; is defined to have two type parameters, &lt;code&gt;Props&lt;/code&gt; and &lt;code&gt;State&lt;/code&gt;. In a &lt;code&gt;.js&lt;/code&gt; file, there is no legal way to specify these in the extends clause. By default the type arguments will be &lt;code&gt;any&lt;/code&gt;:</source>
          <target state="translated">예를 들어 &lt;code&gt;React.Component&lt;/code&gt; 는 &lt;code&gt;Props&lt;/code&gt; 및 &lt;code&gt;State&lt;/code&gt; 의 두 가지 유형 매개 변수를 갖도록 정의됩니다 . A의 &lt;code&gt;.js&lt;/code&gt; 파일의 절을 확장 이러한를 지정하는 법적 방법이 없습니다. 기본적으로 type 인수는 &lt;code&gt;any&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="ad0724dca69663ba4a457c62bb2dc6d54f13c7f2" translate="yes" xml:space="preserve">
          <source>For instance, an import to a module &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; would be translated at runtime to &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 모듈 &lt;code&gt;&quot;jquery&quot;&lt;/code&gt; 로 가져 오기 는 런타임시 &lt;code&gt;&quot;node_modules/jquery/dist/jquery.slim.min.js&quot;&lt;/code&gt; 로 변환 됩니다.</target>
        </trans-unit>
        <trans-unit id="e127b9ec7aa54a885066eddbf73a9390682ef004" translate="yes" xml:space="preserve">
          <source>For instance, if you have something that&amp;rsquo;s typed as &lt;code&gt;Object&lt;/code&gt; you won&amp;rsquo;t be able to call methods like &lt;code&gt;toLowerCase()&lt;/code&gt; on it. Being more general usually means you can do less with a type, but &lt;code&gt;any&lt;/code&gt; is special in that it is the most general type while still allowing you to do anything with it. That means you can call it, construct it, access properties on it, etc. Keep in mind though, whenever you use &lt;code&gt;any&lt;/code&gt;, you lose out on most of the error checking and editor support that TypeScript gives you.</source>
          <target state="translated">예를 들어 &lt;code&gt;Object&lt;/code&gt; 로 입력 한 것이 있으면 &lt;code&gt;toLowerCase()&lt;/code&gt; 와 같은 메소드를 호출 할 수 없습니다 . 보다 일반적으로 사용한다는 것은 유형을 사용하여 작업을 더 적게 할 수 있다는 것을 의미하지만 , 가장 일반적인 유형이라는 점에서 특별한 점은 있지만 &lt;code&gt;any&lt;/code&gt; 유형을 사용할 수 있습니다. 당신이 사용할 때마다, 비록 당신이 그것을 호출을 만들 수 있다는 것을 의미합니다 그것에 액세스 특성 등 명심 &lt;code&gt;any&lt;/code&gt; 타이프 라이터가 당신을 제공합니다, 당신은 오류 검사 및 편집기 지원의 대부분을 놓치게.</target>
        </trans-unit>
        <trans-unit id="76f20136bdec4c8a094a4948f37f41bd9373cd0e" translate="yes" xml:space="preserve">
          <source>For instance, the following interfaces will merge together:</source>
          <target state="translated">예를 들어 다음 인터페이스가 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">예를 들어 :</target>
        </trans-unit>
        <trans-unit id="cc15a1d1ae77d156b224c9eb01c61c6a21c1a488" translate="yes" xml:space="preserve">
          <source>For intrinsic elements, it is the type of the property on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;</source>
          <target state="translated">내장 요소의 경우 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 의 속성 유형입니다.</target>
        </trans-unit>
        <trans-unit id="63e99ee6fde01714eebc90d83730b70795fea95a" translate="yes" xml:space="preserve">
          <source>For leveraging project references, a new &lt;code&gt;createSolutionBuilder&lt;/code&gt; function has been exposed, which returns an instance of the new type &lt;code&gt;SolutionBuilder&lt;/code&gt;.</source>
          <target state="translated">프로젝트 참조를 활용하기 위해 새로운 &lt;code&gt;createSolutionBuilder&lt;/code&gt; 함수가 노출되어 새로운 유형의 &lt;code&gt;SolutionBuilder&lt;/code&gt; 인스턴스를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d4f49775acc3a4322a0557d39b3d6b9d1f2d24cf" translate="yes" xml:space="preserve">
          <source>For more details on the change, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2983&quot;&gt;see the pull request here&lt;/a&gt;.</source>
          <target state="translated">변경에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2983&quot;&gt;여기서 pull 요청을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="43fc548897db905fa8c2333f2655e946bf2edbda" translate="yes" xml:space="preserve">
          <source>For more details on the implementation, see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29332&quot;&gt;the feature&amp;rsquo;s pull request&lt;/a&gt;.</source>
          <target state="translated">구현에 대한 자세한 내용 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29332&quot;&gt;은 기능의 풀 요청을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c866e562806b98ab3450aefd85c82570ae3dbe52" translate="yes" xml:space="preserve">
          <source>For more details on these APIs, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31432&quot;&gt;see the original pull request&lt;/a&gt;.</source>
          <target state="translated">이러한 API에 대한 자세한 내용 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31432&quot;&gt;은 원래 풀 요청을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9db932b4f370cac7158608164dcc7323460cd641" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30552&quot;&gt;see the pull request on GitHub to add &lt;code&gt;Omit&lt;/code&gt;&lt;/a&gt;, as well as &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31134&quot;&gt;the change to use &lt;code&gt;Omit&lt;/code&gt; for object rest&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30552&quot;&gt;GitHub의에서 끌어 오기 요청 추가 참조 &lt;code&gt;Omit&lt;/code&gt; &lt;/a&gt; 뿐만 아니라, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31134&quot;&gt;사용하는 변화 &lt;code&gt;Omit&lt;/code&gt; 객체 나머지&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc45d221d48c167e7361605c82635e85e5e5877b" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30776/files&quot;&gt;see the pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30776/files&quot;&gt;은 GitHub의 풀 요청을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="273ca0c112dc6b1882314478ee8c1e6544170b8e" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/30646&quot;&gt;see the originating issue&lt;/a&gt;, as well as the pull requests that link back to it.</source>
          <target state="translated">자세한 &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/30646&quot;&gt;내용은 원래 문제&lt;/a&gt; 와 다시 연결되는 끌어 오기 요청을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="990cc8daa552812b9673fb27d79710d0a0853e7a" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31801&quot;&gt;see the corresponding pull request&lt;/a&gt;.</source>
          <target state="translated">자세한 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31801&quot;&gt;내용은 해당 풀 요청을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0320510c766022af54173463f58fd051469373de" translate="yes" xml:space="preserve">
          <source>For more details, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32584&quot;&gt;see the original PR on GitHub&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32584&quot;&gt;은 GitHub의 원본 PR을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe5d1addf9d0d4b733550ed18ffe6381b947a86" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29510&quot;&gt;check out the respective pull request&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29510&quot;&gt;은 해당 풀 요청을 확인하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65484dc7f4c4daea7c1d319eb8233395f4407267" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30215&quot;&gt;read more at the original change&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/30215&quot;&gt;은 원래 변경 사항에서 자세히 읽어보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="563dc4e63b054412d2401fc516c6fac2d3df7317" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/30779&quot;&gt;see the original pull request on GitHub&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/30779&quot;&gt;은 GitHub에서 원본 풀 요청을 확인할 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="01a8abf26dc21e0236d3ae01896624d8b626ea07" translate="yes" xml:space="preserve">
          <source>For more details, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32372&quot;&gt;check out the original pull request&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/32372&quot;&gt;은 원래 풀 요청을 확인하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d623177cf84777887441acfa37b705f15554d05f" translate="yes" xml:space="preserve">
          <source>For more details, you can see the pull requests to</source>
          <target state="translated">자세한 내용은 풀 요청을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e64e60d7e437a1ebcf2869771b212e3f2906370" translate="yes" xml:space="preserve">
          <source>For more discussion about modules and namespaces see &lt;a href=&quot;namespaces-and-modules&quot;&gt;Namespaces and Modules&lt;/a&gt;.</source>
          <target state="translated">모듈과 네임 스페이스에 대한 자세한 내용은 &lt;a href=&quot;namespaces-and-modules&quot;&gt;네임 스페이스 및 모듈을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c362b5af66f291c8b84b625e56119e3fdeab25b4" translate="yes" xml:space="preserve">
          <source>For more information about module, please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2242&quot;&gt;ES6 module support spec&lt;/a&gt;.</source>
          <target state="translated">모듈에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2242&quot;&gt;ES6 모듈 지원 사양을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="570e8203155764ac5cbba766759ffb8d69bcac89" translate="yes" xml:space="preserve">
          <source>For more information on temporal dead zones, see relevant content on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;Mozilla Developer Network&lt;/a&gt;.</source>
          <target state="translated">임시 데드 존에 대한 자세한 정보는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let&quot;&gt;Mozilla 개발자 네트워크&lt;/a&gt; 의 관련 컨텐츠를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6fb17b499b05834e5a93ed9076041c12b5a0a99" translate="yes" xml:space="preserve">
          <source>For more information see &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx&quot;&gt;Async Functions&lt;/a&gt; blog post.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://blogs.msdn.com/b/typescript/archive/2015/11/03/what-about-async-await.aspx&quot;&gt;비동기 함수&lt;/a&gt; 블로그 게시물을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e181d79ed93cb811ae26b48402f5381960e6dbda" translate="yes" xml:space="preserve">
          <source>For more information, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31166&quot;&gt;see the relevant pull request&lt;/a&gt;.</source>
          <target state="translated">자세한 정보 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31166&quot;&gt;는 관련 풀 요청을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b92828c4a7429aa0dedb168e31c48305dd400088" translate="yes" xml:space="preserve">
          <source>For more information, please see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2249&quot;&gt;Decorators&lt;/a&gt; proposal.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/2249&quot;&gt;데코레이터&lt;/a&gt; 제안을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5cfc8aafd6a1b42f41322e6dfe173a4a83dcba5" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html&quot;&gt;TypeScript spec&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/blob/master/doc/spec.html&quot;&gt;TypeScript spec을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b6d8db7682d13acc39e4cc45f1bdba1511a9906" translate="yes" xml:space="preserve">
          <source>For more information, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33050&quot;&gt;read up on the original pull request&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33050&quot;&gt;은 원래 풀 요청을 읽으십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="343ef5950853198d94dec424b2d3547e8d8f6fca" translate="yes" xml:space="preserve">
          <source>For more information, you can &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33509&quot;&gt;take a look at the original pull request for these changes&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33509&quot;&gt;은 이러한 변경에 대한 원래 풀 요청을 살펴보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="705c8bb533b7a415fffecd94e72c06081d3e2f68" translate="yes" xml:space="preserve">
          <source>For non-relative module imports, however, the compiler walks up the directory tree starting with the directory containing the importing file, trying to locate a matching definition file.</source>
          <target state="translated">상대적이 아닌 모듈 가져 오기의 경우 컴파일러는 가져 오기 파일이 포함 된 디렉토리부터 시작하여 일치하는 정의 파일을 찾으려고 디렉토리 트리를 안내합니다.</target>
        </trans-unit>
        <trans-unit id="fe8f9cb290ffb799bb30074ff74b3c823de4c1a0" translate="yes" xml:space="preserve">
          <source>For one, TypeScript can now make inferences for the return type of a call. This can improve your experience and catch errors. Something that now works:</source>
          <target state="translated">우선, TypeScript는 호출의 리턴 유형을 추론 할 수 있습니다. 이것은 경험을 향상시키고 오류를 잡을 수 있습니다. 이제 작동하는 것 :</target>
        </trans-unit>
        <trans-unit id="8e2e83bc37a28c5942c02bb933ef427bb23983d8" translate="yes" xml:space="preserve">
          <source>For programs to be useful, we need to be able to work with some of the simplest units of data: numbers, strings, structures, boolean values, and the like. In TypeScript, we support much the same types as you would expect in JavaScript, with a convenient enumeration type thrown in to help things along.</source>
          <target state="translated">프로그램이 유용하기 위해서는 숫자, 문자열, 구조, 부울 값 등과 같은 가장 간단한 데이터 단위로 작업 할 수 있어야합니다. TypeScript에서는 JavaScript에서 예상하는 것과 거의 동일한 유형을 지원하며 편리한 열거 유형을 사용하여 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d3344c32461a0db1e0c782f128f60f424dfe694b" translate="yes" xml:space="preserve">
          <source>For seasoned authors interested in the underlying mechanics of how declaration files work, the &lt;a href=&quot;deep-dive&quot;&gt;Deep Dive&lt;/a&gt; section explains many advanced concepts in declaration writing, and shows how to leverage these concepts to create cleaner and more intuitive declaration files.</source>
          <target state="translated">선언 파일 작동 방식의 기본 메커니즘에 관심이있는 숙련 된 작성자를 위해 &lt;a href=&quot;deep-dive&quot;&gt;Deep Dive&lt;/a&gt; 섹션에서는 선언 작성의 여러 고급 개념에 대해 설명하고 이러한 개념을 활용하여보다 명확하고 직관적 인 선언 파일을 만드는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="13f368b0d84c902186b48234f4040bb16257c671" translate="yes" xml:space="preserve">
          <source>For that reason, we have no immediate plans to provide downleveling support. On the bright side, Node 11 and newer versions of Chrome already support this feature, so you&amp;rsquo;ll be able to use BigInts there when targeting &lt;code&gt;esnext&lt;/code&gt;.</source>
          <target state="translated">따라서 하위 수준의 지원을 제공 할 즉각적인 계획은 없습니다. 당신이 BigInts가 목표로 할 때 사용할 수 있습니다, 그래서 밝은 측면에서, 노드 (11)와 크롬의 최신 버전은 이미이 기능을 지원 &lt;code&gt;esnext&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="a1b0a9136ffac4466c13d6e276a81e02a3314c15" translate="yes" xml:space="preserve">
          <source>For the most part, type declaration packages should always have the same name as the package name on &lt;code&gt;npm&lt;/code&gt;, but prefixed with &lt;code&gt;@types/&lt;/code&gt;, but if you need, you can check out &lt;a href=&quot;https://aka.ms/types&quot;&gt;https://aka.ms/types&lt;/a&gt; to find the package for your favorite library.</source>
          <target state="translated">대부분의 경우 유형 선언 패키지는 항상 &lt;code&gt;npm&lt;/code&gt; 의 패키지 이름과 이름이 같아야 하지만 접두사가 &lt;code&gt;@types/&lt;/code&gt; 이지만 필요한 경우 &lt;a href=&quot;https://aka.ms/types&quot;&gt;https://aka.ms/types&lt;/a&gt; 를 확인 하여 패키지를 찾을 수 있습니다 가장 좋아하는 라이브러리.</target>
        </trans-unit>
        <trans-unit id="034fabf95397dd3d830d8bf8625f29b5fecddc83" translate="yes" xml:space="preserve">
          <source>For the purposes of this article, &amp;ldquo;declaration merging&amp;rdquo; means that the compiler merges two separate declarations declared with the same name into a single definition. This merged definition has the features of both of the original declarations. Any number of declarations can be merged; it&amp;rsquo;s not limited to just two declarations.</source>
          <target state="translated">이 기사의 목적 상 &quot;선언 병합&quot;은 컴파일러가 동일한 이름으로 선언 된 두 개의 개별 선언을 단일 정의로 병합 함을 의미합니다. 이 병합 된 정의에는 원래 선언 모두의 기능이 있습니다. 여러 선언을 병합 할 수 있습니다. 단지 두 가지 선언에만 국한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14bbf380d646374ad4976a37ddd3a52586d0778f" translate="yes" xml:space="preserve">
          <source>For the purposes of writing a declaration file, you&amp;rsquo;ll write the same code whether the module being changed is a plain module or UMD module.</source>
          <target state="translated">선언 파일을 작성하기 위해 변경중인 모듈이 일반 모듈인지 UMD 모듈인지에 관계없이 동일한 코드를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="4aa3bad258aff42d4d06a5737732c3217bc98418" translate="yes" xml:space="preserve">
          <source>For this feature and simplified props, be sure to be use the &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react&quot;&gt;latest version of react.d.ts&lt;/a&gt;.</source>
          <target state="translated">이 기능과 단순화 된 소품의 경우 &lt;a href=&quot;https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/react&quot;&gt;최신 버전의 react.d.ts를 사용해야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="a33482387ee5a013d484cb5ab80e458b7353dca7" translate="yes" xml:space="preserve">
          <source>For those unfamiliar, &lt;code&gt;setTimeout&lt;/code&gt; will try to execute a function after a certain number of milliseconds (though waiting for anything else to stop running).</source>
          <target state="translated">익숙하지 않은 사람들 을 위해 &lt;code&gt;setTimeout&lt;/code&gt; 은 특정 시간 (밀리 초) 후에 함수 실행을 시도합니다 (다른 것이 실행을 멈출 때까지 기다립니다).</target>
        </trans-unit>
        <trans-unit id="a2a4c15a4041ed86596a75791caa9f86b76bf038" translate="yes" xml:space="preserve">
          <source>For value-based elements, it is a bit more complex. It is determined by the type of a property on the &lt;em&gt;element instance type&lt;/em&gt; that was previously determined. Which property to use is determined by &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt;. It should be declared with a single property. The name of that property is then used. As of TypeScript 2.8, if &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; is not provided, the type of first parameter of the class element&amp;rsquo;s constructor or Function Component&amp;rsquo;s call will be used instead.</source>
          <target state="translated">가치 기반 요소의 경우 조금 더 복잡합니다. 이전에 결정된 &lt;em&gt;요소 인스턴스 유형&lt;/em&gt; 의 특성 유형에 의해 결정됩니다. 사용할 특성은 &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; 에 의해 결정됩니다 . 단일 속성으로 선언해야합니다. 그런 다음 해당 속성의 이름이 사용됩니다. TypeScript 2.8에서 &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; 가 제공되지 않으면 클래스 요소 생성자의 첫 번째 매개 변수 유형 또는 함수 구성 요소 호출이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cd4106b2c3bf5670711745c735fa13bc35a27218" translate="yes" xml:space="preserve">
          <source>From TypeScript 3.7 and onwards, you can use &lt;a href=&quot;release-notes/typescript-3-7#optional-chaining&quot;&gt;optional chaining&lt;/a&gt; to simplify working with nullable types.</source>
          <target state="translated">TypeScript 3.7 이상에서는 &lt;a href=&quot;release-notes/typescript-3-7#optional-chaining&quot;&gt;선택적 체인&lt;/a&gt; 을 사용하여 nullable 형식 작업을 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c70347006d57179eb4e0296dfeec4d48fd56374" translate="yes" xml:space="preserve">
          <source>From a Global Library</source>
          <target state="translated">글로벌 도서관에서</target>
        </trans-unit>
        <trans-unit id="7a9218b43b092d03a0883f8b7857dbb282cdf813" translate="yes" xml:space="preserve">
          <source>From a Module or UMD Library</source>
          <target state="translated">모듈 또는 UMD 라이브러리에서</target>
        </trans-unit>
        <trans-unit id="3f9c703cb24035f076046daf82d5597961381bc0" translate="yes" xml:space="preserve">
          <source>From a PowerShell command window, run:</source>
          <target state="translated">PowerShell 명령 창에서 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="108836dc86d3f675e6c3eef00af882d27efb9073" translate="yes" xml:space="preserve">
          <source>From there you&amp;rsquo;ll be able to use lodash in your TypeScript code with no fuss. This works for both modules and global code.</source>
          <target state="translated">거기에서 TypeScript 코드에 lodash를 사용할 수 있습니다. 이것은 모듈과 전역 코드 모두에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="50c9f7eb832e49ced6feaff6d4be4040d50a7444" translate="yes" xml:space="preserve">
          <source>From this point on, we&amp;rsquo;re going to assume that your directory is set up something like this:</source>
          <target state="translated">이제부터는 디렉토리가 다음과 같이 설정되었다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="1177b1db377a31fa211c1c837c048902a33fbabc" translate="yes" xml:space="preserve">
          <source>Function Component</source>
          <target state="translated">기능 구성 요소</target>
        </trans-unit>
        <trans-unit id="14e60fa4031e0e6cd85f9e19b012d6dbfc7853ec" translate="yes" xml:space="preserve">
          <source>Function Component (FC)</source>
          <target state="translated">기능 구성 요소 (FC)</target>
        </trans-unit>
        <trans-unit id="957953f67e0718500a80224139b161eb239e35fa" translate="yes" xml:space="preserve">
          <source>Function Components in React</source>
          <target state="translated">반응의 기능 구성 요소</target>
        </trans-unit>
        <trans-unit id="37eaf4a6db3ea0747ab9364bd4d5e24895e0a544" translate="yes" xml:space="preserve">
          <source>Function Overloads</source>
          <target state="translated">기능 과부하</target>
        </trans-unit>
        <trans-unit id="a258c02eba54e3e0953a40abe8602fb6e1a74ef6" translate="yes" xml:space="preserve">
          <source>Function Parameter Bivariance</source>
          <target state="translated">함수 모수 이변 량</target>
        </trans-unit>
        <trans-unit id="c57d64280c18c54778c8d1947833e0036b6e26da" translate="yes" xml:space="preserve">
          <source>Function Truthy Checks</source>
          <target state="translated">기능성 검사</target>
        </trans-unit>
        <trans-unit id="5b51ae5c386fcffd7ce1ff55e49610a2a8af3637" translate="yes" xml:space="preserve">
          <source>Function Types</source>
          <target state="translated">기능 유형</target>
        </trans-unit>
        <trans-unit id="301ffb948f7d729015635b11db6553b40624b34f" translate="yes" xml:space="preserve">
          <source>Function declarations</source>
          <target state="translated">함수 선언</target>
        </trans-unit>
        <trans-unit id="c5db83a75bbeef08fa2e0b320c74460786ae66aa" translate="yes" xml:space="preserve">
          <source>Function parameters are checked one at a time, with the type in each corresponding parameter position checked against each other. If you do not want to specify types at all, TypeScript&amp;rsquo;s contextual typing can infer the argument types since the function value is assigned directly to a variable of type &lt;code&gt;SearchFunc&lt;/code&gt;. Here, also, the return type of our function expression is implied by the values it returns (here &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">기능 매개 변수는 한 번에 하나씩 점검되며 해당하는 각 매개 변수 위치의 유형이 서로 대조됩니다. 유형을 전혀 지정하지 않으려는 경우 함수 값이 &lt;code&gt;SearchFunc&lt;/code&gt; 유형의 변수에 직접 지정되므로 TypeScript의 상황 별 입력이 인수 유형을 유추 할 수 있습니다 . 또한 함수 표현식의 반환 유형은 반환하는 값 (여기서는 &lt;code&gt;false&lt;/code&gt; 및 &lt;code&gt;true&lt;/code&gt; )으로 암시됩니다 .</target>
        </trans-unit>
        <trans-unit id="53ffe91c4f4d77a902ebdf074913f42349003bbc" translate="yes" xml:space="preserve">
          <source>Function parameters are optional by default</source>
          <target state="translated">기능 매개 변수는 기본적으로 선택 사항입니다</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="f3665432e1a6db576efaea1b6e2d8f839bcdcc98" translate="yes" xml:space="preserve">
          <source>Functions are the fundamental building block of any application in JavaScript. They&amp;rsquo;re how you build up layers of abstraction, mimicking classes, information hiding, and modules. In TypeScript, while there are classes, namespaces, and modules, functions still play the key role in describing how to &lt;em&gt;do&lt;/em&gt; things. TypeScript also adds some new capabilities to the standard JavaScript functions to make them easier to work with.</source>
          <target state="translated">함수는 JavaScript에서 모든 응용 프로그램의 기본 구성 요소입니다. 그것들은 추상화 계층, 모방 클래스, 정보 숨기기 및 모듈을 구축하는 방법입니다. TypeScript에는 클래스, 네임 스페이스 및 모듈이 있지만 함수 &lt;em&gt;는&lt;/em&gt; 작업 &lt;em&gt;수행&lt;/em&gt; 방법을 설명하는 데 여전히 중요한 역할을합니다 . TypeScript는 또한 표준 JavaScript 함수에 몇 가지 새로운 기능을 추가하여보다 쉽게 ​​작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16cd3a7ed4cd7f04f6e352a9b0a671ae06c3867d" translate="yes" xml:space="preserve">
          <source>Functions with code paths that do not return a value in JS implicitly return &lt;code&gt;undefined&lt;/code&gt;. These can now be flagged by the compiler as implicit returns. The check is turned &lt;em&gt;off&lt;/em&gt; by default; use &lt;code&gt;--noImplicitReturns&lt;/code&gt; to turn it on.</source>
          <target state="translated">JS에서 값을 반환하지 않는 코드 경로를 가진 함수는 암시 적으로 &lt;code&gt;undefined&lt;/code&gt; 를 반환 합니다. 이것들은 이제 컴파일러에 의해 암시 적 리턴으로 플래그 될 수 있습니다. 검사는 기본적 으로 &lt;em&gt;해제&lt;/em&gt; 되어 있습니다. 켜 려면 &lt;code&gt;--noImplicitReturns&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ecfd08105c3b9ed934caafb326908c0acb570490" translate="yes" xml:space="preserve">
          <source>Functions with overloads</source>
          <target state="translated">과부하 기능</target>
        </trans-unit>
        <trans-unit id="4f257e8843abb1bab8a5b85a60f95a4c0139aa46" translate="yes" xml:space="preserve">
          <source>Functions: this</source>
          <target state="translated">기능 :이</target>
        </trans-unit>
        <trans-unit id="6089bda1a34a0c953770c8e3b78bec0ef08e1cc9" translate="yes" xml:space="preserve">
          <source>Furthermore, TypeScript also has the notion of &lt;em&gt;global&lt;/em&gt; augmentations of the form &lt;code&gt;declare global { }&lt;/code&gt;. This allows modules to augment global types such as &lt;code&gt;Array&lt;/code&gt; if necessary.</source>
          <target state="translated">또한 TypeScript에는 &lt;code&gt;declare global { }&lt;/code&gt; 형식 의 &lt;em&gt;전역&lt;/em&gt; 기능 보강 개념이 있습니다. 이를 통해 모듈은 필요한 경우 &lt;code&gt;Array&lt;/code&gt; 와 같은 전역 유형을 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4df80e4187f2b8baf6d47a6fdeef464676adeda2" translate="yes" xml:space="preserve">
          <source>Furthermore, in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, control flow based type analysis includes &lt;em&gt;definite assignment analysis&lt;/em&gt; for local variables of types that don&amp;rsquo;t permit the value &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;--strictNullChecks&lt;/code&gt; 모드에서 제어 흐름 기반 유형 분석에는 &lt;code&gt;undefined&lt;/code&gt; 값을 허용하지 않는 유형의 지역 변수에 대한 &lt;em&gt;명확한 할당 분석이&lt;/em&gt; 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="b94633d2f5a1028f484d02bb58c0c7929a0b9214" translate="yes" xml:space="preserve">
          <source>Furthermore, with the &lt;code&gt;keyof&lt;/code&gt; operator&amp;rsquo;s support for &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;symbol&lt;/code&gt; named keys, it is now possible to abstract over access to properties of objects that are indexed by numeric literals (such as numeric enum types) and unique symbols.</source>
          <target state="translated">또한, &lt;code&gt;keyof&lt;/code&gt; 연산자가 &lt;code&gt;number&lt;/code&gt; 와 &lt;code&gt;symbol&lt;/code&gt; 명명 된 키를 지원하므로 숫자 리터럴 (예 : 숫자 열거 형 유형) 및 고유 기호로 색인이 생성 된 객체의 속성에 대한 액세스를 추상화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c7eb0b3402889bd567c0d3af8902acae19e04ce" translate="yes" xml:space="preserve">
          <source>General Types</source>
          <target state="translated">일반 유형</target>
        </trans-unit>
        <trans-unit id="b2fce69037144d8c17c57e4cd48ef47f73df98fb" translate="yes" xml:space="preserve">
          <source>Generated JS code:</source>
          <target state="translated">생성 된 JS 코드 :</target>
        </trans-unit>
        <trans-unit id="819ddb970af7944124739b463d184873a1a7a985" translate="yes" xml:space="preserve">
          <source>Generates a cpu profile at the given path. Passing an existing directory name instead of a file path will cause a timestamp-named profile to be generated in that directory instead.</source>
          <target state="translated">주어진 경로에서 CPU 프로파일을 생성합니다. 파일 경로 대신 기존 디렉토리 이름을 전달하면 해당 디렉토리에 타임 스탬프 이름이 지정된 프로파일이 대신 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2d8f07103db6977c68e0ada027ab65c5c23862d9" translate="yes" xml:space="preserve">
          <source>Generates a sourcemap for each corresponding &amp;lsquo;.d.ts&amp;rsquo; file.</source>
          <target state="translated">해당하는 '.d.ts'파일 각각에 대한 소스 맵을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a2e42f3b65f8aeda6abb391f2b5c0feb9f71f346" translate="yes" xml:space="preserve">
          <source>Generates corresponding &lt;code&gt;.d.ts&lt;/code&gt; file.</source>
          <target state="translated">해당 &lt;code&gt;.d.ts&lt;/code&gt; 파일을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="285e568bc8b6f7ba3db03d758216b4279b6fb84a" translate="yes" xml:space="preserve">
          <source>Generates corresponding &lt;code&gt;.map&lt;/code&gt; file.</source>
          <target state="translated">해당 &lt;code&gt;.map&lt;/code&gt; 파일을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="0edb628a9542a14f813bd7de9f8386b56c8a58b5" translate="yes" xml:space="preserve">
          <source>Generates:</source>
          <target state="translated">Generates:</target>
        </trans-unit>
        <trans-unit id="a3e705cc61a19f33d7c9c030f107a70569966485" translate="yes" xml:space="preserve">
          <source>Generators</source>
          <target state="translated">Generators</target>
        </trans-unit>
        <trans-unit id="44da76948f45623de7d336c343233faa5d2b509e" translate="yes" xml:space="preserve">
          <source>Generators and Iteration for ES5/ES3</source>
          <target state="translated">ES5 / ES3의 생성기 및 반복</target>
        </trans-unit>
        <trans-unit id="052f4c16b4b91a827312bf3baa166ba53bfe5efa" translate="yes" xml:space="preserve">
          <source>Generic Classes</source>
          <target state="translated">일반 클래스</target>
        </trans-unit>
        <trans-unit id="c1219cf49a0e939b3e16bf04e12e2eafc84ee7fd" translate="yes" xml:space="preserve">
          <source>Generic Constraints</source>
          <target state="translated">일반 제약</target>
        </trans-unit>
        <trans-unit id="6e69a2fc2c745899f35839a75d651978ee056569" translate="yes" xml:space="preserve">
          <source>Generic Types</source>
          <target state="translated">제네릭 형식</target>
        </trans-unit>
        <trans-unit id="15d759be2080d6d18e338e98d07714f4c409146a" translate="yes" xml:space="preserve">
          <source>Generic object rest variables and parameters</source>
          <target state="translated">일반 오브젝트 레스트 변수 및 매개 변수</target>
        </trans-unit>
        <trans-unit id="1fdeebd1c396649ca4cc647737cc5d4a10b10b8f" translate="yes" xml:space="preserve">
          <source>Generic parameter defaults</source>
          <target state="translated">일반 매개 변수 기본값</target>
        </trans-unit>
        <trans-unit id="001622f41013d0601ab935e2183da475e787cfd4" translate="yes" xml:space="preserve">
          <source>Generic rest parameters</source>
          <target state="translated">일반 휴식 매개 변수</target>
        </trans-unit>
        <trans-unit id="ee51cfb54175ecd5fb6d2ccc67d80a3554912ff7" translate="yes" xml:space="preserve">
          <source>Generic rest parameters and corresponding inference of tuple types.</source>
          <target state="translated">일반 휴식 매개 변수 및 해당 튜플 유형의 추론.</target>
        </trans-unit>
        <trans-unit id="77980b7a1bd9bc29a811f3721a4ca0efc1244e89" translate="yes" xml:space="preserve">
          <source>Generic spread expressions in object literals</source>
          <target state="translated">객체 리터럴의 일반 스프레드 표현식</target>
        </trans-unit>
        <trans-unit id="a62000d34890a9f512301dfa28ec7342f3e45eb8" translate="yes" xml:space="preserve">
          <source>Generic type aliases</source>
          <target state="translated">제네릭 형식 별칭</target>
        </trans-unit>
        <trans-unit id="92dacb7528945ed9815a679921369b1471575a3f" translate="yes" xml:space="preserve">
          <source>Generic type arguments in JSX elements</source>
          <target state="translated">JSX 요소의 제네릭 형식 인수</target>
        </trans-unit>
        <trans-unit id="f865cd9dc0cd462591b83a2927cb41d99ab230cd" translate="yes" xml:space="preserve">
          <source>Generic type arguments in generic tagged templates</source>
          <target state="translated">일반 태그 템플릿의 일반 유형 인수</target>
        </trans-unit>
        <trans-unit id="80dadd86173d0ff3979257793d4e45beb238b6a2" translate="yes" xml:space="preserve">
          <source>Generics</source>
          <target state="translated">Generics</target>
        </trans-unit>
        <trans-unit id="4d9ef11b75691cea9a6edfb497c3b9914c3b1021" translate="yes" xml:space="preserve">
          <source>Generics: Types</source>
          <target state="translated">제네릭 : 유형</target>
        </trans-unit>
        <trans-unit id="00a40ea9152c19baaaa2f05a471ec1e36c25f25b" translate="yes" xml:space="preserve">
          <source>Get started with a simple TypeScript app.</source>
          <target state="translated">간단한 TypeScript 앱으로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="5ef75e8c40e485b27abd25b4a16247e142017634" translate="yes" xml:space="preserve">
          <source>Getting Declaration Files</source>
          <target state="translated">선언 파일 얻기</target>
        </trans-unit>
        <trans-unit id="9ed37766bb349044c2259b48865fbf239e26a5e7" translate="yes" xml:space="preserve">
          <source>Getting Stricter Checks</source>
          <target state="translated">더 엄격한 검사 받기</target>
        </trans-unit>
        <trans-unit id="b7b2818d4eceb3a3c55e7b64b0c852e4d5109657" translate="yes" xml:space="preserve">
          <source>Getting around these checks is actually really simple. The easiest method is to just use a type assertion:</source>
          <target state="translated">이러한 점검을 해결하는 것은 실제로 매우 간단합니다. 가장 쉬운 방법은 형식 어설 션을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1ed2ad4b9d2d91f971b1ebd9e80d9238f9735423" translate="yes" xml:space="preserve">
          <source>Getting to ES6/ES2015 built-in API declarations were only limited to &lt;code&gt;target: ES6&lt;/code&gt;. Enter &lt;code&gt;--lib&lt;/code&gt;; with &lt;code&gt;--lib&lt;/code&gt; you can specify a list of built-in API declaration groups that you can chose to include in your project. For instance, if you expect your runtime to have support for &lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Promise&lt;/code&gt; (e.g. most evergreen browsers today), just include &lt;code&gt;--lib es2015.collection,es2015.promise&lt;/code&gt;. Similarly you can exclude declarations you do not want to include in your project, e.g. DOM if you are working on a node project using &lt;code&gt;--lib es5,es6&lt;/code&gt;.</source>
          <target state="translated">ES6 / ES2015 기본 제공 API 선언은 &lt;code&gt;target: ES6&lt;/code&gt; 으로 만 제한되었습니다 . &lt;code&gt;--lib&lt;/code&gt; 를 입력하십시오 . 함께 &lt;code&gt;--lib&lt;/code&gt; 당신이 API 선언 그룹의 내장의 목록을 지정할 수 있습니다 당신은 당신의 프로젝트에 포함하기로 결정했습니다 수있다. 예를 들어, 런타임에서 &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; 및 &lt;code&gt;Promise&lt;/code&gt; (예 : 오늘날 가장 상시적인 브라우저)를 지원 &lt;code&gt;--lib es2015.collection,es2015.promise&lt;/code&gt; . 마찬가지로 &lt;code&gt;--lib es5,es6&lt;/code&gt; 을 사용하여 노드 프로젝트에서 작업중인 경우 프로젝트에 포함하지 않으려는 선언을 제외 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca2334233ff9d62586c90c8425d61ccf0156ad00" translate="yes" xml:space="preserve">
          <source>Getting type declarations in TypeScript 2.0 and above requires no tools apart from npm.</source>
          <target state="translated">TypeScript 2.0 이상에서 형식 선언을 가져 오려면 npm 이외의 도구가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0128ee2411d4cce5db2af199ae139a20b41fb10c" translate="yes" xml:space="preserve">
          <source>Given &lt;code&gt;&amp;lt;Expr /&amp;gt;&lt;/code&gt;, the &lt;em&gt;element class type&lt;/em&gt; is the type of &lt;code&gt;Expr&lt;/code&gt;. So in the example above, if &lt;code&gt;MyComponent&lt;/code&gt; was an ES6 class the class type would be that class&amp;rsquo;s constructor and statics. If &lt;code&gt;MyComponent&lt;/code&gt; was a factory function, the class type would be that function.</source>
          <target state="translated">을 감안할 때 &lt;code&gt;&amp;lt;Expr /&amp;gt;&lt;/code&gt; 의 &lt;em&gt;요소 클래스 유형&lt;/em&gt; 의 유형입니다 &lt;code&gt;Expr&lt;/code&gt; . 위의 예에서 &lt;code&gt;MyComponent&lt;/code&gt; 가 ES6 클래스 인 경우 클래스 유형은 해당 클래스의 생성자 및 정적입니다. 경우 &lt;code&gt;MyComponent&lt;/code&gt; 공장 기능이고, 클래스 타입은 함수가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="975e78d60e0d980036725e953131ac369a323b6f" translate="yes" xml:space="preserve">
          <source>Given a declaration of a class &lt;code&gt;Pet&lt;/code&gt; in a module file:</source>
          <target state="translated">모듈 파일에서 &lt;code&gt;Pet&lt;/code&gt; 클래스를 선언하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8083d6ae5a9d183ac1a96bad2a32806cb23140c9" translate="yes" xml:space="preserve">
          <source>Given a name &lt;code&gt;A&lt;/code&gt;, we might find up to three different meanings for &lt;code&gt;A&lt;/code&gt;: a type, a value or a namespace. How the name is interpreted depends on the context in which it is used. For example, in the declaration &lt;code&gt;let m: A.A = A;&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is used first as a namespace, then as a type name, then as a value. These meanings might end up referring to entirely different declarations!</source>
          <target state="translated">이름이 주어 , 우리는 세 가지 다른 의미까지 찾을 수 있습니다 유형, 값 또는 네임 스페이스 :. 이름이 해석되는 방법은 사용되는 컨텍스트에 따라 다릅니다. 예를 들어 선언에서 &lt;code&gt;let m: A.A = A;&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 다음의 값으로, 다음 형태의 이름과 같은 공간으로 먼저 사용된다. 이러한 의미는 완전히 다른 선언을 의미 할 수 있습니다! &lt;code&gt;A&lt;/code&gt; &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a00264a5f3c6cd0479bb605da5bdecfcbf5f69bb" translate="yes" xml:space="preserve">
          <source>Given an expression &lt;code&gt;Base&lt;/code&gt; of a parametric type &lt;code&gt;T&lt;/code&gt; with a constraint &lt;code&gt;X&lt;/code&gt;, a mixin class &lt;code&gt;class C extends Base {...}&lt;/code&gt; is processed as if &lt;code&gt;Base&lt;/code&gt; had type &lt;code&gt;X&lt;/code&gt; and the resulting type is the intersection &lt;code&gt;typeof C &amp;amp; T&lt;/code&gt;. In other words, a mixin class is represented as an intersection between the mixin class constructor type and the parametric base class constructor type.</source>
          <target state="translated">제약 조건 &lt;code&gt;X&lt;/code&gt; 가있는 파라 메트릭 유형 &lt;code&gt;T&lt;/code&gt; 의 표현식 &lt;code&gt;Base&lt;/code&gt; 가 주어지면 , 믹스 인 클래스 &lt;code&gt;class C extends Base {...}&lt;/code&gt; 는 &lt;code&gt;Base&lt;/code&gt; 에 유형 &lt;code&gt;X&lt;/code&gt; 가 있고 결과 유형이 &lt;code&gt;typeof C &amp;amp; T&lt;/code&gt; 의 교차 유형 인 것처럼 처리됩니다 . 즉, 믹스 인 클래스는 믹스 인 클래스 생성자 유형과 파라 메트릭 기본 클래스 생성자 유형 사이의 교차로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f747221667578c67b9937edae87fe4b1bb4a08b1" translate="yes" xml:space="preserve">
          <source>Given an object type &lt;code&gt;X&lt;/code&gt;, &lt;code&gt;keyof X&lt;/code&gt; is resolved as follows:</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 객체 유형이 주어지면 X 의 &lt;code&gt;keyof X&lt;/code&gt; 는 다음과 같이 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="fa581e6e08169205d8be1ad319fd8832a173be18" translate="yes" xml:space="preserve">
          <source>Given that we have two types of declarations with similar scoping semantics, it&amp;rsquo;s natural to find ourselves asking which one to use. Like most broad questions, the answer is: it depends.</source>
          <target state="translated">범위 지정 의미가 비슷한 두 가지 유형의 선언이 있기 때문에 어느 것을 사용해야하는지 스스로 찾는 것이 당연합니다. 가장 광범위한 질문과 마찬가지로 대답은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="610048c0b076b1fb8790fd96c3fc109500ce0670" translate="yes" xml:space="preserve">
          <source>Given this project structure:</source>
          <target state="translated">이 프로젝트 구조가 주어지면 :</target>
        </trans-unit>
        <trans-unit id="05ab21d96c8cc217d9d3bf8ed1a8cf0dc14dc590" translate="yes" xml:space="preserve">
          <source>Glob support in &lt;code&gt;tsconfig.json&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 에서 전역 지원</target>
        </trans-unit>
        <trans-unit id="ee29cd5c1e941ea77b1bcc2b4464658a76d6b503" translate="yes" xml:space="preserve">
          <source>Glob support is here!! Glob support has been &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1927&quot;&gt;one of the most requested features&lt;/a&gt;.</source>
          <target state="translated">세계적 지원이 여기 있습니다! Glob 지원은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/1927&quot;&gt;가장 많이 요청 된 기능 중 하나입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26021db1ea30cf082e152c820806cb17b431aff1" translate="yes" xml:space="preserve">
          <source>Glob-like file patterns are supported two properties &lt;code&gt;&quot;include&quot;&lt;/code&gt; and &lt;code&gt;&quot;exclude&quot;&lt;/code&gt;.</source>
          <target state="translated">전 세계와 유사한 파일 패턴은 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 두 가지 특성이 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="ae4f56ae4da16df74b3d2aeca8b4352281e7be45" translate="yes" xml:space="preserve">
          <source>Global Functions</source>
          <target state="translated">글로벌 함수</target>
        </trans-unit>
        <trans-unit id="bb90b4e7b4f156d78c1c4607edb92deecea2726f" translate="yes" xml:space="preserve">
          <source>Global Libraries</source>
          <target state="translated">글로벌 라이브러리</target>
        </trans-unit>
        <trans-unit id="086706851e81b0cda50c1ad12a71bbbe92f2b609" translate="yes" xml:space="preserve">
          <source>Global Library Template</source>
          <target state="translated">글로벌 라이브러리 템플릿</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes" xml:space="preserve">
          <source>Global Variables</source>
          <target state="translated">글로벌 변수</target>
        </trans-unit>
        <trans-unit id="f939f94390f04e9a571e774b88f07fa51a7034c9" translate="yes" xml:space="preserve">
          <source>Global augmentation</source>
          <target state="translated">글로벌 확대</target>
        </trans-unit>
        <trans-unit id="d9627061a8f161c085d6425d99b5bcd04461ec21" translate="yes" xml:space="preserve">
          <source>Global augmentations have the same behavior and limits as module augmentations.</source>
          <target state="translated">글로벌 기능 보강은 모듈 기능 보강과 동일한 동작 및 한계를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="551b0be00de6f59a327fffe248fc43dd021a48e0" translate="yes" xml:space="preserve">
          <source>Global library code is usually extremely simple. A global &amp;ldquo;Hello, world&amp;rdquo; library might look like this:</source>
          <target state="translated">전역 라이브러리 코드는 일반적으로 매우 간단합니다. 글로벌&amp;ldquo;Hello, world&amp;rdquo;라이브러리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a2a3ce92a02e2b38f5f0131a3a2a15d9bd6e27fc" translate="yes" xml:space="preserve">
          <source>Global plugins are generally easy to identify from their documentation.</source>
          <target state="translated">글로벌 플러그인은 일반적으로 문서에서 쉽게 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f705c81915f4a397894296d2b81a9e9f219df5d" translate="yes" xml:space="preserve">
          <source>Global-modifying modules are generally easy to identify from their documentation. In general, they&amp;rsquo;re similar to global plugins, but need a &lt;code&gt;require&lt;/code&gt; call to activate their effects.</source>
          <target state="translated">전역 수정 모듈은 일반적으로 문서에서 쉽게 식별 할 수 있습니다. 일반적으로 글로벌 플러그인과 비슷하지만 효과를 활성화 &lt;code&gt;require&lt;/code&gt; 호출이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="24713d72fbb7ed9e4d613388f61f4edcd1171735" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;File&lt;/code&gt; &amp;gt; &lt;code&gt;Settings&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt;:</source>
          <target state="translated">이동 &lt;code&gt;File&lt;/code&gt; &amp;gt; &lt;code&gt;Settings&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cb7da868a3e2b03846cee16319e4528c9916294a" translate="yes" xml:space="preserve">
          <source>Go to &lt;code&gt;Preferences&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt;:</source>
          <target state="translated">이동 &lt;code&gt;Preferences&lt;/code&gt; &amp;gt; &lt;code&gt;Languages &amp;amp; Frameworks&lt;/code&gt; &amp;gt; &lt;code&gt;TypeScript&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c06ca0601da1369de3d0247e6e4f8b7bbe8e4bfd" translate="yes" xml:space="preserve">
          <source>Grunt</source>
          <target state="translated">Grunt</target>
        </trans-unit>
        <trans-unit id="b5e0b544d4f7e5ecf776c530d4637f9254bfad0b" translate="yes" xml:space="preserve">
          <source>Guidance</source>
          <target state="translated">Guidance</target>
        </trans-unit>
        <trans-unit id="6b06b3debeeac8b24443fbaf25e471200f47e47b" translate="yes" xml:space="preserve">
          <source>Guidance for structuring modules</source>
          <target state="translated">모듈 구조화에 대한 지침</target>
        </trans-unit>
        <trans-unit id="5a6238801e2733bcdc7249e97a255df97e530fc4" translate="yes" xml:space="preserve">
          <source>Gulp</source>
          <target state="translated">Gulp</target>
        </trans-unit>
        <trans-unit id="79914411b3c89953fe030c6c8025f0574c41a8f8" translate="yes" xml:space="preserve">
          <source>Gulp: Add modules to the code</source>
          <target state="translated">Gulp : 코드에 모듈 추가</target>
        </trans-unit>
        <trans-unit id="21e98a38e254fad84f4a4bbd9e8fa3fea802a72c" translate="yes" xml:space="preserve">
          <source>Gulp: Babel</source>
          <target state="translated">꿀꺽 : 바벨</target>
        </trans-unit>
        <trans-unit id="c3699841f2d588970283b562ce18c4a12378b39f" translate="yes" xml:space="preserve">
          <source>Gulp: Browserify</source>
          <target state="translated">펄프 : Browserify</target>
        </trans-unit>
        <trans-unit id="67718aa41c7c302d8015e6a1f55245492dfe7b5f" translate="yes" xml:space="preserve">
          <source>Gulp: Create a gulpfile.js</source>
          <target state="translated">Gulp : gulpfile.js 만들기</target>
        </trans-unit>
        <trans-unit id="d5f376a8524ce9e40602f913685d1f14707f0f24" translate="yes" xml:space="preserve">
          <source>Gulp: Create a page</source>
          <target state="translated">꿀꺽 : 페이지 만들기</target>
        </trans-unit>
        <trans-unit id="26f1b5afe4ab8f7ba7d8e64daae6616d336e7b8d" translate="yes" xml:space="preserve">
          <source>Gulp: Initialize the project</source>
          <target state="translated">Gulp : 프로젝트 초기화</target>
        </trans-unit>
        <trans-unit id="89ec650baa395d7c6395a96eac5b8b07e6aefed3" translate="yes" xml:space="preserve">
          <source>Gulp: Install our dependencies</source>
          <target state="translated">Gulp : 의존성 설치</target>
        </trans-unit>
        <trans-unit id="94ff547657bd3ea294e187a2a5b6c4e9da41ae2e" translate="yes" xml:space="preserve">
          <source>Gulp: Minimal project</source>
          <target state="translated">Gulp : 최소 프로젝트</target>
        </trans-unit>
        <trans-unit id="5bf88642d6a4c72b1400115e631d3c1241d0a62f" translate="yes" xml:space="preserve">
          <source>Gulp: Test the resulting app</source>
          <target state="translated">Gulp : 결과 앱 테스트</target>
        </trans-unit>
        <trans-unit id="5c5e381120e6ca17177cab8dd1c9b114707b4f32" translate="yes" xml:space="preserve">
          <source>Gulp: Uglify</source>
          <target state="translated">꿀꺽 꿀꺽 마시다</target>
        </trans-unit>
        <trans-unit id="378ef94af067892dc3f571669da77f2d28b9d848" translate="yes" xml:space="preserve">
          <source>Gulp: Watchify</source>
          <target state="translated">꿀꺽 : Watchify</target>
        </trans-unit>
        <trans-unit id="339b09b31f6400bfbd9df2cc056c03bbce7e1947" translate="yes" xml:space="preserve">
          <source>Gulp: Write a simple example</source>
          <target state="translated">Gulp : 간단한 예제 작성</target>
        </trans-unit>
        <trans-unit id="28e2147303cd82753a34e2e9e286d0181633c0c4" translate="yes" xml:space="preserve">
          <source>Had the function expression returned numbers or strings, the type checker would have made an error that indicates return type doesn&amp;rsquo;t match the return type described in the &lt;code&gt;SearchFunc&lt;/code&gt; interface.</source>
          <target state="translated">함수 표현식에서 숫자 또는 문자열을 반환 한 경우 형식 검사기는 반환 형식이 &lt;code&gt;SearchFunc&lt;/code&gt; 인터페이스에 설명 된 반환 형식과 일치하지 않음을 나타내는 오류를 발생 시켰습니다 .</target>
        </trans-unit>
        <trans-unit id="9a7699299b167b02f3b309a214e186f89e6ac90a" translate="yes" xml:space="preserve">
          <source>Hello World of Generics</source>
          <target state="translated">제네릭 세계</target>
        </trans-unit>
        <trans-unit id="4868c6cfe667dc94ff39de6f11b3b8c2dde32455" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;asserts val is string&lt;/code&gt; ensures that after any call to &lt;code&gt;assertIsString&lt;/code&gt;, any variable passed in will be known to be a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;asserts val is string&lt;/code&gt; 임을 주장 합니다. &lt;code&gt;assertIsString&lt;/code&gt; 을 호출 한 후 전달 된 모든 변수는 &lt;code&gt;string&lt;/code&gt; 로 간주 됩니다.</target>
        </trans-unit>
        <trans-unit id="217c263c0612cdb8818f0c2bb1cc2cee17136759" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;map.ts&lt;/code&gt; can declare that it will internally patch the &lt;code&gt;Observable&lt;/code&gt; type from &lt;code&gt;observable.ts&lt;/code&gt; and add the &lt;code&gt;map&lt;/code&gt; method to it.</source>
          <target state="translated">여기서 &lt;code&gt;map.ts&lt;/code&gt; 는 &lt;code&gt;observable.ts&lt;/code&gt; 에서 &lt;code&gt;Observable&lt;/code&gt; 유형을 내부적으로 패치 하고 &lt;code&gt;map&lt;/code&gt; 메소드를 추가 할 것이라고 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b504fd8672cd71981cb916f0743aeadaf081b517" translate="yes" xml:space="preserve">
          <source>Here are some notable differences on how checking works in &lt;code&gt;.js&lt;/code&gt; files compared to &lt;code&gt;.ts&lt;/code&gt; files:</source>
          <target state="translated">다음은 &lt;code&gt;.ts&lt;/code&gt; 파일 과 비교하여 &lt;code&gt;.js&lt;/code&gt; 파일 에서 검사가 작동하는 방식에 대한 몇 가지 주목할만한 차이점입니다 .</target>
        </trans-unit>
        <trans-unit id="14fd63d436a290048d4c1831116810e1e69345e4" translate="yes" xml:space="preserve">
          <source>Here is a list of available API groups:</source>
          <target state="translated">사용 가능한 API 그룹 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="83f91cc0372adb4b62657eb83b59506603d1d14b" translate="yes" xml:space="preserve">
          <source>Here is a list of well-known symbols:</source>
          <target state="translated">다음은 잘 알려진 기호 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d7c6390605af8c73015b19f7184792241b88e764" translate="yes" xml:space="preserve">
          <source>Here is a simple test for the calculator using the exposed &lt;code&gt;test&lt;/code&gt; function.</source>
          <target state="translated">다음은 노출 된 &lt;code&gt;test&lt;/code&gt; 기능을 사용한 간단한 계산기 테스트 입니다.</target>
        </trans-unit>
        <trans-unit id="d867fe52f6b4323b3aa6d543dd0bd5c2bb91d3f0" translate="yes" xml:space="preserve">
          <source>Here is an example that demonstrates this distinction:</source>
          <target state="translated">다음은 이러한 차이점을 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="9d689481e7c027a1b04a6cc241ceab676b7e9d0f" translate="yes" xml:space="preserve">
          <source>Here the syntax starts to get confusing. You can read &lt;code&gt;a: newName1&lt;/code&gt; as &amp;ldquo;&lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt;&amp;rdquo;. The direction is left-to-right, as if you had written:</source>
          <target state="translated">여기서 구문은 혼란스러워지기 시작합니다. &lt;code&gt;a: newName1&lt;/code&gt; 을 &quot; &lt;code&gt;a&lt;/code&gt; as &lt;code&gt;newName1&lt;/code&gt; &quot; 로 읽을 수 있습니다 . 당신이 쓴 것처럼 방향은 왼쪽에서 오른쪽입니다.</target>
        </trans-unit>
        <trans-unit id="0e7c23e184f2a3fc2239ba7dd64a12dacf4b5975" translate="yes" xml:space="preserve">
          <source>Here we explicitly set &lt;code&gt;T&lt;/code&gt; to be &lt;code&gt;string&lt;/code&gt; as one of the arguments to the function call, denoted using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; around the arguments rather than &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">여기서 우리는 &lt;code&gt;T&lt;/code&gt; 를 함수 호출에 대한 인수 중 하나로 &lt;code&gt;string&lt;/code&gt; 로 명시 적으로 설정 하고 &lt;code&gt;()&lt;/code&gt; 대신 인수 주위에 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 를 사용하여 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="4a521f4f8c69adda61863ae271ec13a08aca0267" translate="yes" xml:space="preserve">
          <source>Here we need to create a variable to hold on to the neighbor-map so that we can initialize it. With TypeScript 1.5, we can let the compiler do the heavy lifting:</source>
          <target state="translated">여기서는 이웃 맵을 유지하기 위해 변수를 만들어야 초기화 할 수 있습니다. TypeScript 1.5를 사용하면 컴파일러에서 많은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f454fc62879aec4c05c5b0553ae23ecb3678fbdb" translate="yes" xml:space="preserve">
          <source>Here we were able to copy over all the properties of &lt;code&gt;Person&lt;/code&gt; except for &lt;code&gt;location&lt;/code&gt; using the &lt;code&gt;Omit&lt;/code&gt; helper.</source>
          <target state="translated">여기서 &lt;code&gt;Omit&lt;/code&gt; 도우미를 사용하여 &lt;code&gt;location&lt;/code&gt; 를 제외한 &lt;code&gt;Person&lt;/code&gt; 의 모든 속성을 복사 할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="1036409900634ac21f92613c301ba8e5286a4bef" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re going to create a &lt;code&gt;Student&lt;/code&gt; class with a constructor and a few public fields. Notice that classes and interfaces play well together, letting the programmer decide on the right level of abstraction.</source>
          <target state="translated">여기 에서는 생성자와 몇 개의 공개 필드가 있는 &lt;code&gt;Student&lt;/code&gt; 클래스 를 만듭니다 . 클래스와 인터페이스는 서로 잘 어울리므로 프로그래머는 올바른 추상화 수준을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="285b0ed2d436f147e6b99b312065319a3bd9b594" translate="yes" xml:space="preserve">
          <source>Here we&amp;rsquo;re specifying a few things to TypeScript:</source>
          <target state="translated">다음은 TypeScript에 몇 가지 사항을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="371971b4f21066fe668fdda84538194651b56819" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a revised example:</source>
          <target state="translated">다음은 수정 된 예입니다.</target>
        </trans-unit>
        <trans-unit id="ecace45a094904ef8f89699739d61e7f83e4e706" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a simple example of an unreachable code error:</source>
          <target state="translated">도달 할 수없는 코드 오류의 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="33855c52e889ba154150d2b3670aeb240d95c340" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of this pattern:</source>
          <target state="translated">이 패턴의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e232701f3c0f0553f27b93d9845181d7b9b01bd" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s how you would write and use this function in TypeScript, using the &lt;strong&gt;index type query&lt;/strong&gt; and &lt;strong&gt;indexed access&lt;/strong&gt; operators:</source>
          <target state="translated">다음은 &lt;strong&gt;인덱스 유형 쿼리&lt;/strong&gt; 및 &lt;strong&gt;인덱스 액세스&lt;/strong&gt; 연산자를 사용하여 TypeScript에서이 함수를 작성하고 사용하는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="fb902d04d0d6f8c7ca19c25536908ff73f061681" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s one more example, in which &lt;code&gt;T[P]&lt;/code&gt; is wrapped in a &lt;code&gt;Proxy&amp;lt;T&amp;gt;&lt;/code&gt; class:</source>
          <target state="translated">&lt;code&gt;T[P]&lt;/code&gt; 가 &lt;code&gt;Proxy&amp;lt;T&amp;gt;&lt;/code&gt; 클래스에 래핑 된 예가 하나 더 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2ea446bd29277ad18a8bf4252379c5046cdf44d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;SomeType&lt;/code&gt; appears to originate in both the &lt;code&gt;import&lt;/code&gt; declaration and the local &lt;code&gt;interface&lt;/code&gt; declaration. Perhaps surprisingly, inside the module, &lt;code&gt;SomeType&lt;/code&gt; refers exclusively to the &lt;code&gt;import&lt;/code&gt;ed definition, and the local declaration &lt;code&gt;SomeType&lt;/code&gt; is only usable when imported from another file. This is very confusing and our review of the very small number of cases of code like this in the wild showed that developers usually thought something different was happening.</source>
          <target state="translated">여기서 &lt;code&gt;SomeType&lt;/code&gt; 은 &lt;code&gt;import&lt;/code&gt; 선언과 로컬 &lt;code&gt;interface&lt;/code&gt; 선언 모두에서 시작된 것으로 보입니다 . 놀랍게도 모듈 내부에서 &lt;code&gt;SomeType&lt;/code&gt; 은 &lt;code&gt;import&lt;/code&gt; 정의를 독점적으로 참조 하며 로컬 선언 &lt;code&gt;SomeType&lt;/code&gt; 은 다른 파일에서 가져올 때만 사용할 수 있습니다. 이것은 매우 혼란스럽고 매우 적은 수의 코드 사례를 검토 한 결과 개발자는 일반적으로 뭔가 다른 일이 일어나고 있다고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="a3816a0ed94cd7ceadd9968bd7c237ebde8a5f88" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Up&lt;/code&gt; would have the value &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;Down&lt;/code&gt; would have &lt;code&gt;1&lt;/code&gt;, etc. This auto-incrementing behavior is useful for cases where we might not care about the member values themselves, but do care that each value is distinct from other values in the same enum.</source>
          <target state="translated">여기서 &lt;code&gt;Up&lt;/code&gt; 은 &lt;code&gt;0&lt;/code&gt; 값을 , &lt;code&gt;Down&lt;/code&gt; 은 &lt;code&gt;1&lt;/code&gt; 등을 갖습니다 .이 자동 증가 동작은 멤버 값 자체는 신경 쓰지 않지만 각 값이 같은 다른 값과 구별되는 경우에 유용합니다. 열거 형.</target>
        </trans-unit>
        <trans-unit id="57a9abf556999c9646907cab4f7c7e1dc771a6d2" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;assertNever&lt;/code&gt; checks that &lt;code&gt;s&lt;/code&gt; is of type &lt;code&gt;never&lt;/code&gt; &amp;mdash; the type that&amp;rsquo;s left after all other cases have been removed. If you forget a case, then &lt;code&gt;s&lt;/code&gt; will have a real type and you will get a type error. This method requires you to define an extra function, but it&amp;rsquo;s much more obvious when you forget it.</source>
          <target state="translated">여기서 &lt;code&gt;assertNever&lt;/code&gt; 는 &lt;code&gt;s&lt;/code&gt; 가 &lt;code&gt;never&lt;/code&gt; 유형 인지 확인합니다 . 다른 모든 사례가 제거 된 후 남은 유형입니다. 대소 문자를 잊어 버린 경우 &lt;code&gt;s&lt;/code&gt; 는 실제 유형을 가지며 유형 오류가 발생합니다. 이 방법을 사용하려면 추가 기능을 정의해야하지만 잊었을 때 훨씬 더 분명합니다.</target>
        </trans-unit>
        <trans-unit id="d05882792ac23d4a8b28c31469c8bc7607445ef8" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;let Greeter&lt;/code&gt; is going to be assigned the constructor function. When we call &lt;code&gt;new&lt;/code&gt; and run this function, we get an instance of the class. The constructor function also contains all of the static members of the class. Another way to think of each class is that there is an &lt;em&gt;instance&lt;/em&gt; side and a &lt;em&gt;static&lt;/em&gt; side.</source>
          <target state="translated">여기서 &lt;code&gt;let Greeter&lt;/code&gt; 에 생성자 함수가 할당되도록합니다. &lt;code&gt;new&lt;/code&gt; 를 호출 하고이 함수를 실행하면 클래스의 인스턴스를 얻습니다. 생성자 함수에는 클래스의 모든 정적 멤버도 포함됩니다. 각 클래스를 생각하는 또 다른 방법은 &lt;em&gt;인스턴스&lt;/em&gt; 측과 &lt;em&gt;정적&lt;/em&gt; 측 이 있다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="8dc42a1abbc3302381c653975f640c8b543442a7" translate="yes" xml:space="preserve">
          <source>Here, TypeScript will climb up &lt;code&gt;node_modules&lt;/code&gt; folders looking for a &lt;code&gt;@my-team/tsconfig-base&lt;/code&gt; package. For each of those packages, TypeScript will first check whether &lt;code&gt;package.json&lt;/code&gt; contains a &lt;code&gt;&quot;tsconfig&quot;&lt;/code&gt; field, and if it does, TypeScript will try to load a configuration file from that field. If neither exists, TypeScript will try to read from a &lt;code&gt;tsconfig.json&lt;/code&gt; at the root. This is similar to the lookup process for &lt;code&gt;.js&lt;/code&gt; files in packages that Node uses, and the &lt;code&gt;.d.ts&lt;/code&gt; lookup process that TypeScript already uses.</source>
          <target state="translated">여기서 TypeScript는 &lt;code&gt;@my-team/tsconfig-base&lt;/code&gt; 패키지를 찾는 &lt;code&gt;node_modules&lt;/code&gt; 폴더를 위로 올립니다 . 각 패키지에 대해 TypeScript는 먼저 &lt;code&gt;package.json&lt;/code&gt; 에 &lt;code&gt;&quot;tsconfig&quot;&lt;/code&gt; 필드 가 포함되어 있는지 확인 하고, 포함되어 있으면 TypeScript는 해당 필드에서 구성 파일을로드하려고 시도합니다. 둘 다 존재하지 않으면 TypeScript는 루트 의 &lt;code&gt;tsconfig.json&lt;/code&gt; 에서 읽습니다 . 이는 Node에서 사용하는 패키지의 &lt;code&gt;.js&lt;/code&gt; 파일 조회 프로세스와 TypeScript에서 이미 사용 하는 &lt;code&gt;.d.ts&lt;/code&gt; 조회 프로세스와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="3034e1d8a6bc8a9342b8171fa30badb5f8ee1757" translate="yes" xml:space="preserve">
          <source>Here, our package depends on the &lt;code&gt;browserify&lt;/code&gt; and &lt;code&gt;typescript&lt;/code&gt; packages. &lt;code&gt;browserify&lt;/code&gt; does not bundle its declaration files with its npm packages, so we needed to depend on &lt;code&gt;@types/browserify&lt;/code&gt; for its declarations. &lt;code&gt;typescript&lt;/code&gt;, on the other hand, packages its declaration files, so there was no need for any additional dependencies.</source>
          <target state="translated">여기서 패키지는 &lt;code&gt;browserify&lt;/code&gt; 및 &lt;code&gt;typescript&lt;/code&gt; 패키지 에 따라 다릅니다 . &lt;code&gt;browserify&lt;/code&gt; 는 선언 파일을 npm 패키지와 함께 제공하지 않으므로 선언을 위해 &lt;code&gt;@types/browserify&lt;/code&gt; 를 사용해야했습니다 . 반면에 &lt;code&gt;typescript&lt;/code&gt; 는 선언 파일을 패키지하므로 추가 종속성이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3cda7ef7ff2200b657be6b6273e0dac1be53b72f" translate="yes" xml:space="preserve">
          <source>Here, the &lt;code&gt;pickCard&lt;/code&gt; function will return two different things based on what the user has passed in. If the users passes in an object that represents the deck, the function will pick the card. If the user picks the card, we tell them which card they&amp;rsquo;ve picked. But how do we describe this to the type system?</source>
          <target state="translated">여기서 &lt;code&gt;pickCard&lt;/code&gt; 함수는 사용자가 전달한 내용에 따라 서로 다른 두 가지를 반환합니다. 사용자가 데크를 나타내는 객체를 전달하면 함수가 카드를 선택합니다. 사용자가 카드를 선택하면 선택한 카드를 알려줍니다. 그러나 이것을 유형 시스템에 어떻게 설명합니까?</target>
        </trans-unit>
        <trans-unit id="e58fec9d06a5ad9c41dd9bdefb16a98bb9094511" translate="yes" xml:space="preserve">
          <source>Here, the Typescript type checker used the type of the &lt;code&gt;Window.onmousedown&lt;/code&gt; function to infer the type of the function expression on the right hand side of the assignment. When it did so, it was able to infer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;type&lt;/a&gt; of the &lt;code&gt;mouseEvent&lt;/code&gt; parameter, which does contain a &lt;code&gt;button&lt;/code&gt; property, but not a &lt;code&gt;kangaroo&lt;/code&gt; property.</source>
          <target state="translated">여기서 Typescript type checker는 &lt;code&gt;Window.onmousedown&lt;/code&gt; 함수의 유형을 사용하여 할당 오른쪽에 함수 표현식의 유형을 유추했습니다. 그렇게했을 때, 추론 할 수 있었다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent&quot;&gt;유형&lt;/a&gt; 의 &lt;code&gt;mouseEvent&lt;/code&gt; 포함하지 파라미터, &lt;code&gt;button&lt;/code&gt; 속성을 아니지만 &lt;code&gt;kangaroo&lt;/code&gt; 속성을.</target>
        </trans-unit>
        <trans-unit id="e4d6507505357d507200a72953f1d420dfbcafaf" translate="yes" xml:space="preserve">
          <source>Here, we forgot to call &lt;code&gt;isAdministrator&lt;/code&gt;, and the code incorrectly allows non-adminstrator users to edit the configuration!</source>
          <target state="translated">여기서는 &lt;code&gt;isAdministrator&lt;/code&gt; 를 호출하는 것을 잊어 버렸습니다. 이 코드를 사용하면 관리자가 아닌 사용자가 구성을 편집 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="30996a44efb8790cbea6f775764e2a95c008cc8a" translate="yes" xml:space="preserve">
          <source>Here, we have a function &lt;code&gt;readImage&lt;/code&gt; which reads an image in a non-blocking asynchronous way. In addition to &lt;code&gt;readImage&lt;/code&gt;, we&amp;rsquo;ve provided a convenience function on &lt;code&gt;readImage&lt;/code&gt; itself called &lt;code&gt;readImage.sync&lt;/code&gt;.</source>
          <target state="translated">여기에 비 블로킹 비동기 방식으로 이미지를 읽는 &lt;code&gt;readImage&lt;/code&gt; 함수가 있습니다 . 뿐만 아니라 &lt;code&gt;readImage&lt;/code&gt; , 우리는에 편리한 기능을 제공 한 &lt;code&gt;readImage&lt;/code&gt; 자체라는 &lt;code&gt;readImage.sync&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="4776f9836ab53c81a717b79d18761f412dcd4953" translate="yes" xml:space="preserve">
          <source>Here, we have two local variables &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s scope is limited to the body of &lt;code&gt;f&lt;/code&gt; while &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s scope is limited to the containing &lt;code&gt;if&lt;/code&gt; statement&amp;rsquo;s block.</source>
          <target state="translated">여기에는 두 개의 지역 변수 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 있습니다. &lt;code&gt;a&lt;/code&gt; 의 범위는 &lt;code&gt;f&lt;/code&gt; 의 본문으로 제한 되고 &lt;code&gt;b&lt;/code&gt; 의 범위는 포함하는 &lt;code&gt;if&lt;/code&gt; 문의 블록으로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="48b66ea86a98afc6732087affea2266d22665ee9" translate="yes" xml:space="preserve">
          <source>Here, we&amp;rsquo;ll split our &lt;code&gt;Validation&lt;/code&gt; namespace across many files. Even though the files are separate, they can each contribute to the same namespace and can be consumed as if they were all defined in one place. Because there are dependencies between files, we&amp;rsquo;ll add reference tags to tell the compiler about the relationships between the files. Our test code is otherwise unchanged.</source>
          <target state="translated">여기서는 &lt;code&gt;Validation&lt;/code&gt; 네임 스페이스를 여러 파일로 분할 합니다. 파일이 분리되어 있어도 각각 동일한 네임 스페이스에 기여할 수 있으며 마치 한 곳에서 모두 정의 된 것처럼 사용할 수 있습니다. 파일 간에는 종속성이 있으므로 참조 태그를 추가하여 컴파일러에게 파일 간의 관계를 알려줍니다. 우리의 테스트 코드는 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0be76e8a894cfa9a5cd3d9c31525aeb3396a52fc" translate="yes" xml:space="preserve">
          <source>Here, when we say &lt;code&gt;let greeter: Greeter&lt;/code&gt;, we&amp;rsquo;re using &lt;code&gt;Greeter&lt;/code&gt; as the type of instances of the class &lt;code&gt;Greeter&lt;/code&gt;. This is almost second nature to programmers from other object-oriented languages.</source>
          <target state="translated">여기, 우리가 말할 때 &lt;code&gt;let greeter: Greeter&lt;/code&gt; , 우리가 사용하고있는 &lt;code&gt;Greeter&lt;/code&gt; 클래스의 인스턴스의 유형으로 &lt;code&gt;Greeter&lt;/code&gt; . 이것은 다른 객체 지향 언어의 프로그래머에게는 거의 두 번째입니다.</target>
        </trans-unit>
        <trans-unit id="af2cc1b97022b7d58d48c283943b530d0c3a629b" translate="yes" xml:space="preserve">
          <source>Heterogeneous enums</source>
          <target state="translated">이종 열거 형</target>
        </trans-unit>
        <trans-unit id="bcaf520cc3089e4cf8ad0800fc58fb622275eea2" translate="yes" xml:space="preserve">
          <source>Higher order type inference from generic constructors</source>
          <target state="translated">제네릭 생성자의 고차 형 추론</target>
        </trans-unit>
        <trans-unit id="f7dd4ac35eed5e4b0152fe5390ac0fc4fdadf710" translate="yes" xml:space="preserve">
          <source>Higher order type inference from generic functions</source>
          <target state="translated">일반 함수의 고차 형 추론</target>
        </trans-unit>
        <trans-unit id="173efd9dce0319d3f71e1aa5317de963557d2d4c" translate="yes" xml:space="preserve">
          <source>Hit &lt;code&gt;Install&lt;/code&gt;</source>
          <target state="translated">적중 &lt;code&gt;Install&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89d412a555ac9119a1cb2746b4a8a508c5b127a6" translate="yes" xml:space="preserve">
          <source>How Node.js resolves modules</source>
          <target state="translated">Node.js가 모듈을 해결하는 방법</target>
        </trans-unit>
        <trans-unit id="1a330f9df74d0d83d178ec1580eb2080a18f5765" translate="yes" xml:space="preserve">
          <source>How TypeScript resolves modules</source>
          <target state="translated">TypeScript가 모듈을 해결하는 방법</target>
        </trans-unit>
        <trans-unit id="aea32d84fa10a6814afacd1681bb1e9a0cfcb214" translate="yes" xml:space="preserve">
          <source>However, TypeScript takes the stance that there&amp;rsquo;s probably a bug in this code. Object literals get special treatment and undergo &lt;em&gt;excess property checking&lt;/em&gt; when assigning them to other variables, or passing them as arguments. If an object literal has any properties that the &amp;ldquo;target type&amp;rdquo; doesn&amp;rsquo;t have, you&amp;rsquo;ll get an error:</source>
          <target state="translated">그러나 TypeScript는이 코드에 버그가있을 수 있다는 입장을 취합니다. 객체 리터럴은 다른 변수에 할당하거나 인수로 전달할 때 특별한 처리를 받고 &lt;em&gt;과도한 속성 검사를&lt;/em&gt; 받습니다 . 객체 리터럴에 &quot;대상 유형&quot;에없는 속성이 있으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2df3cad6545d1673cff30d2239dcbcac86f68714" translate="yes" xml:space="preserve">
          <source>However, TypeScript would instead transform the original code into this code:</source>
          <target state="translated">그러나 TypeScript는 대신 원래 코드를 다음 코드로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="d67a8b4fe7f16ad0a4a00091ab517503777587fe" translate="yes" xml:space="preserve">
          <source>However, a better approach might be to add a string index signature if you&amp;rsquo;re sure that the object can have some extra properties that are used in some special way. If &lt;code&gt;SquareConfig&lt;/code&gt; can have &lt;code&gt;color&lt;/code&gt; and &lt;code&gt;width&lt;/code&gt; properties with the above types, but could &lt;em&gt;also&lt;/em&gt; have any number of other properties, then we could define it like so:</source>
          <target state="translated">그러나 개체에 특별한 방식으로 사용되는 추가 속성이있을 수있는 경우 문자열 인덱스 서명을 추가하는 것이 더 나은 방법 일 수 있습니다. 경우 &lt;code&gt;SquareConfig&lt;/code&gt; 가 있을 수 있습니다 &lt;code&gt;color&lt;/code&gt; 과 &lt;code&gt;width&lt;/code&gt; 위의 유형과 특성을 할 수도 있지만 &lt;em&gt;또한&lt;/em&gt; 다른 속성의 번호를 가지고, 우리는 너무 좋아 정의 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ae34467865c8caaf898bf37d8295d39c36fa465b" translate="yes" xml:space="preserve">
          <source>However, a lot of the time, you might just want to import an existing module that may not have its own &lt;code&gt;.d.ts&lt;/code&gt; file. Previously this was an error. Starting with TypeScript 2.1 this is now much easier.</source>
          <target state="translated">그러나 많은 경우에 자체 &lt;code&gt;.d.ts&lt;/code&gt; 파일 이 없을 수있는 기존 모듈을 가져오고 싶을 수도 있습니다 . 이전에는 오류였습니다. TypeScript 2.1부터는 훨씬 쉬워졌습니다.</target>
        </trans-unit>
        <trans-unit id="52fd9d1ab67ec13644f81aac04cb75b6dad506bf" translate="yes" xml:space="preserve">
          <source>However, combining the two naively would allow an error to sneak in. For example, taking our last example using &lt;code&gt;createSquare&lt;/code&gt;:</source>
          <target state="translated">그러나 두 가지를 순진하게 결합하면 오류가 발생할 수 있습니다. 예를 들어 &lt;code&gt;createSquare&lt;/code&gt; 사용하여 마지막 예제를 보자 .</target>
        </trans-unit>
        <trans-unit id="5fd6902ab8657b5adb4ddbc9ea60a37a54d752ab" translate="yes" xml:space="preserve">
          <source>However, having to define a function to figure out if a type is a primitive is kind of a pain. Luckily, you don&amp;rsquo;t need to abstract &lt;code&gt;typeof x === &quot;number&quot;&lt;/code&gt; into its own function because TypeScript will recognize it as a type guard on its own. That means we could just write these checks inline.</source>
          <target state="translated">그러나 타입이 프리미티브인지 알아내는 함수를 정의하는 것은 일종의 고통입니다. 운좋게도, TypeScript는 자체적으로 타입 가드로 인식하기 때문에 &lt;code&gt;typeof x === &quot;number&quot;&lt;/code&gt; 를 자체 함수로 추상화 할 필요가 없습니다 . 즉,이 검사를 인라인으로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb2ee9a73119ef2301052f4deb325a8b58f2559f" translate="yes" xml:space="preserve">
          <source>However, in the above example, both &lt;code&gt;FruitEater&lt;/code&gt;s and &lt;code&gt;ColorConsumer&lt;/code&gt;s should be able to take the string &lt;code&gt;&quot;orange&quot;&lt;/code&gt;, and return either a &lt;code&gt;number&lt;/code&gt; or a &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">그러나 위의 예제에서 &lt;code&gt;FruitEater&lt;/code&gt; 와 &lt;code&gt;ColorConsumer&lt;/code&gt; 는 모두 &lt;code&gt;&quot;orange&quot;&lt;/code&gt; 문자열을 가져 와서 &lt;code&gt;number&lt;/code&gt; 또는 &lt;code&gt;string&lt;/code&gt; 을 반환 할 수 있어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="6b3269ba44655740fda35e4a6cc5c78cee6e3c08" translate="yes" xml:space="preserve">
          <source>However, in the following example, no error will be reported because the fall-through case is empty:</source>
          <target state="translated">그러나 다음 예에서는 대체 사례가 비어 있기 때문에 오류가보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b7d9dc4338c505863904ace315d827dbbcdc28f" translate="yes" xml:space="preserve">
          <source>However, it&amp;rsquo;s not possible for a type alias to appear anywhere else on the right side of the declaration:</source>
          <target state="translated">그러나 타입 별칭이 선언의 오른쪽에 나타날 수는 없습니다 :</target>
        </trans-unit>
        <trans-unit id="261cdca866e8fca9691e1b837aea779937f4bb40" translate="yes" xml:space="preserve">
          <source>However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:</source>
          <target state="translated">그러나 제약 조건에서 형식 변수를 지우고 대신 조건부 형식을 지정하면 동일한 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e03cd94fc4a5be72b1eb26d1ba79c9cc8372ade3" translate="yes" xml:space="preserve">
          <source>However, properties of different types are acceptable if the index signature is a union of the property types:</source>
          <target state="translated">그러나 인덱스 서명이 속성 유형의 합집합 인 경우 다른 유형의 속성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21bd5d4e23e02c99e9395288fd2b3c14719c2452" translate="yes" xml:space="preserve">
          <source>However, resolution for a &lt;a href=&quot;#relative-vs-non-relative-module-imports&quot;&gt;non-relative module name&lt;/a&gt; is performed differently. Node will look for your modules in special folders named &lt;code&gt;node_modules&lt;/code&gt;. A &lt;code&gt;node_modules&lt;/code&gt; folder can be on the same level as the current file, or higher up in the directory chain. Node will walk up the directory chain, looking through each &lt;code&gt;node_modules&lt;/code&gt; until it finds the module you tried to load.</source>
          <target state="translated">그러나 &lt;a href=&quot;#relative-vs-non-relative-module-imports&quot;&gt;상대&lt;/a&gt; 가 아닌 모듈 이름의 해결 방법 은 다르게 수행됩니다. Node는 &lt;code&gt;node_modules&lt;/code&gt; 라는 특수 폴더에서 모듈을 찾습니다 . &lt;code&gt;node_modules&lt;/code&gt; 는 폴더 디렉토리 체인의 최대 높은 현재 파일과 같은 수준에, 또는 수 있습니다. 노드는 로드하려고 시도한 모듈을 찾을 때까지 각 &lt;code&gt;node_modules&lt;/code&gt; 통해 디렉토리 체인 을 안내합니다.</target>
        </trans-unit>
        <trans-unit id="4066c0cf22c6617cd0e99b116883a9d0812e7a0a" translate="yes" xml:space="preserve">
          <source>However, there are two limitations to keep in mind:</source>
          <target state="translated">그러나 명심해야 할 두 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b475ae409f46bd0059bada064f2253dfa62d98f" translate="yes" xml:space="preserve">
          <source>However, this code will log &lt;code&gt;undefined&lt;/code&gt;, since &lt;code&gt;uiEvent&lt;/code&gt; has no property called &lt;code&gt;button&lt;/code&gt;.</source>
          <target state="translated">그러나,이 코드는 로그인 할 &lt;code&gt;undefined&lt;/code&gt; 이후 &lt;code&gt;uiEvent&lt;/code&gt; 라는 프로퍼티가 없습니다 &lt;code&gt;button&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e528b8c265ab20d7ddf0074a5c552ac0aa502914" translate="yes" xml:space="preserve">
          <source>However, this is error prone - there is nothing stopping a user from accidentally misspelling one of the valid easing values:</source>
          <target state="translated">그러나 이것은 오류가 발생하기 쉽습니다. 사용자가 실수로 유효한 여유 값 중 하나를 잘못 철자하는 것을 막을 수있는 것은 없습니다.</target>
        </trans-unit>
        <trans-unit id="47f0cbbb6af8b4a1e0b5d52577ef8a8ca00678b1" translate="yes" xml:space="preserve">
          <source>However, this was a bit overly strict for the original example. If you figure out the precise type of any possible value of &lt;code&gt;S&lt;/code&gt;, you can actually see that it matches the types in &lt;code&gt;T&lt;/code&gt; exactly.</source>
          <target state="translated">그러나 이것은 원래 예제에서는 약간 엄격했습니다. 가능한 &lt;code&gt;S&lt;/code&gt; 값의 정확한 유형을 알아 내면 실제로 &lt;code&gt;T&lt;/code&gt; 의 유형과 정확히 일치 함을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a82aa6652361ecc5084c82f581d35a4cecb03722" translate="yes" xml:space="preserve">
          <source>However, when comparing types that have &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;protected&lt;/code&gt; members, we treat these types differently. For two types to be considered compatible, if one of them has a &lt;code&gt;private&lt;/code&gt; member, then the other must have a &lt;code&gt;private&lt;/code&gt; member that originated in the same declaration. The same applies to &lt;code&gt;protected&lt;/code&gt; members.</source>
          <target state="translated">그러나 &lt;code&gt;private&lt;/code&gt; 멤버 와 &lt;code&gt;protected&lt;/code&gt; 멤버 가있는 유형을 비교할 때 이러한 유형을 다르게 취급합니다. 두 유형이 호환 가능한 것으로 간주 되려면 두 유형 중 하나에 &lt;code&gt;private&lt;/code&gt; 구성원 이있는 경우 다른 유형에 동일한 선언에서 시작한 &lt;code&gt;private&lt;/code&gt; 구성원이 있어야합니다 . &lt;code&gt;protected&lt;/code&gt; 회원 에게도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="e30d71bb57f4f77a84a108277b5b36c06cf3ebc6" translate="yes" xml:space="preserve">
          <source>However, when using the &lt;code&gt;--strictNullChecks&lt;/code&gt; flag, &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; are only assignable to &lt;code&gt;any&lt;/code&gt; and their respective types (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). This helps avoid &lt;em&gt;many&lt;/em&gt; common errors. In cases where you want to pass in either a &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the union type &lt;code&gt;string | null | undefined&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;--strictNullChecks&lt;/code&gt; 플래그를 사용하는 경우 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 는 &lt;code&gt;any&lt;/code&gt; 해당 유형 에만 할당 할 수 있습니다 ( &lt;code&gt;undefined&lt;/code&gt; 인 예외는 &lt;code&gt;void&lt;/code&gt; 에 할당 할 수 있음 ). 이것은 &lt;em&gt;많은&lt;/em&gt; 일반적인 오류를 피하는 데 도움이됩니다 . &lt;code&gt;string&lt;/code&gt; 이나 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 를 전달하려는 경우 공용체 유형 &lt;code&gt;string | null | undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a16fbd6d0aeace5fd6859531c3e68218d7a29dc" translate="yes" xml:space="preserve">
          <source>Hybrid Types</source>
          <target state="translated">하이브리드 타입</target>
        </trans-unit>
        <trans-unit id="51fed45c4210870abf204ad077a177b04a015861" translate="yes" xml:space="preserve">
          <source>IIFEs as namespace declarations</source>
          <target state="translated">네임 스페이스 선언으로서의 IIFE</target>
        </trans-unit>
        <trans-unit id="aacc04465943461c4401f154c73b82378a7e907a" translate="yes" xml:space="preserve">
          <source>Ideally, we may want &lt;code&gt;zoo&lt;/code&gt; to be inferred as an &lt;code&gt;Animal[]&lt;/code&gt;, but because there is no object that is strictly of type &lt;code&gt;Animal&lt;/code&gt; in the array, we make no inference about the array element type. To correct this, instead explicitly provide the type when no one type is a super type of all other candidates:</source>
          <target state="translated">이상적으로 &lt;code&gt;zoo&lt;/code&gt; 을 &lt;code&gt;Animal[]&lt;/code&gt; 로 추론하기를 원할 수 있지만 배열에 &lt;code&gt;Animal&lt;/code&gt; 유형의 객체가 없으므로 배열 요소 유형에 대해서는 유추하지 않습니다. 이를 정정하려면, 다른 유형의 모든 유형의 수퍼 유형이없는 경우 유형을 명시 적으로 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="3fb44df7e96b3c06b0f62dc3d3bf658dd46e932c" translate="yes" xml:space="preserve">
          <source>Ideally, we&amp;rsquo;d just import the React module from within the browser, but most browsers still don&amp;rsquo;t quite support modules yet. Instead libraries have traditionally made themselves available using a single global variable like &lt;code&gt;jQuery&lt;/code&gt; or &lt;code&gt;_&lt;/code&gt;. This is called the &amp;ldquo;namespace pattern&amp;rdquo;, and webpack allows us to continue leveraging libraries written that way. With our entry for &lt;code&gt;&quot;react&quot;: &quot;React&quot;&lt;/code&gt;, webpack will work its magic to make any import of &lt;code&gt;&quot;react&quot;&lt;/code&gt; load from the &lt;code&gt;React&lt;/code&gt; variable.</source>
          <target state="translated">이상적으로는 브라우저 내에서 React 모듈을 가져 오지만 대부분의 브라우저는 아직 모듈을 지원하지 않습니다. 대신 라이브러리는 전통적으로 &lt;code&gt;jQuery&lt;/code&gt; 또는 &lt;code&gt;_&lt;/code&gt; 와 같은 단일 전역 변수를 사용하여 사용할 수 있습니다 . 이것을&amp;ldquo;네임 스페이스 패턴&amp;rdquo;이라고하며, 웹팩을 사용하면 이런 방식으로 작성된 라이브러리를 계속 활용할 수 있습니다. &lt;code&gt;&quot;react&quot;: &quot;React&quot;&lt;/code&gt; 항목을 통해 webpack은 &lt;code&gt;React&lt;/code&gt; 변수 에서 &lt;code&gt;&quot;react&quot;&lt;/code&gt; 로드를 가져 오기 위해 마법을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="7e95984082de67338b2c7ddbc538f64e016c8d48" translate="yes" xml:space="preserve">
          <source>Identifying Kinds of Libraries</source>
          <target state="translated">라이브러리의 종류 식별</target>
        </trans-unit>
        <trans-unit id="e5eb14c632b87d0c6ad5e592a44a1a8fee7f0639" translate="yes" xml:space="preserve">
          <source>Identifying a Global Library from Code</source>
          <target state="translated">코드에서 글로벌 라이브러리 식별</target>
        </trans-unit>
        <trans-unit id="a2ba79579e03b8f78ffd87dd47a547b41065fc1e" translate="yes" xml:space="preserve">
          <source>Identifying a Module Library from Code</source>
          <target state="translated">코드에서 모듈 라이브러리 식별</target>
        </trans-unit>
        <trans-unit id="96a39992ddd95916928039e6a01815883f0054ca" translate="yes" xml:space="preserve">
          <source>Identifying a UMD library</source>
          <target state="translated">UMD 라이브러리 식별</target>
        </trans-unit>
        <trans-unit id="88076b9c11713a1d1df3ba70daf4f6393c85d874" translate="yes" xml:space="preserve">
          <source>Identifying global plugins</source>
          <target state="translated">글로벌 플러그인 식별</target>
        </trans-unit>
        <trans-unit id="7d0b0dbee7bf8c6735a82b5f8993e432ee3b5ca1" translate="yes" xml:space="preserve">
          <source>Identifying global-modifying modules</source>
          <target state="translated">전역 수정 모듈 식별</target>
        </trans-unit>
        <trans-unit id="75c608e5e061dd97d023874171193ba0dedb0879" translate="yes" xml:space="preserve">
          <source>Identifying the structure of a library is the first step in writing its declaration file. We&amp;rsquo;ll give hints on how to identify structure both based on its &lt;em&gt;usage&lt;/em&gt; and its &lt;em&gt;code&lt;/em&gt;. Depending on the library&amp;rsquo;s documentation and organization, one might be easier than the other. We recommend using whichever is more comfortable to you.</source>
          <target state="translated">라이브러리의 구조를 식별하는 것은 선언 파일을 작성하는 첫 번째 단계입니다. &lt;em&gt;사용법&lt;/em&gt; 과 &lt;em&gt;코드를&lt;/em&gt; 기반으로 구조를 식별하는 방법에 대한 힌트를 제공합니다 . 라이브러리의 문서 및 구성에 따라 하나가 다른 것보다 쉬울 수 있습니다. 더 편한 것을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8bd1ece9a873c798fd3b2f187514a3f9ff53eeee" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;default&amp;rsquo; and &amp;lsquo;clean&amp;rsquo; tasks don&amp;rsquo;t show up, refresh the explorer:</source>
          <target state="translated">'default'및 'clean'작업이 표시되지 않으면 탐색기를 새로 고치십시오.</target>
        </trans-unit>
        <trans-unit id="b398aaa2e3e793e66c0386971a0fcc7d95fd4011" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TypeScriptToolsVersion&lt;/code&gt; is not specified, the latest compiler version installed on the machine will be used to build.</source>
          <target state="translated">경우 &lt;code&gt;TypeScriptToolsVersion&lt;/code&gt; 가 지정되지 않은 시스템에 설치된 최신 컴파일러 버전은 빌드에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a66bd888ae761260069cb56ba3782c6cb9f2948" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; contains a numeric index signature, &lt;code&gt;keyof X&lt;/code&gt; is a union of &lt;code&gt;number&lt;/code&gt; and the literal types representing string-like and symbol-like properties, otherwise</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 에 숫자 색인 서명이 포함 된 경우 &lt;code&gt;keyof X&lt;/code&gt; 는 &lt;code&gt;number&lt;/code&gt; 와 문자열 유사 및 기호 유사 특성을 나타내는 리터럴 유형 의 합집합입니다.</target>
        </trans-unit>
        <trans-unit id="6616ffdf1f61f5f170f5695d095b28464311066e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;X&lt;/code&gt; contains a string index signature, &lt;code&gt;keyof X&lt;/code&gt; is a union of &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt;, and the literal types representing symbol-like properties, otherwise</source>
          <target state="translated">&lt;code&gt;X&lt;/code&gt; 에 문자열 인덱스 서명이 포함 된 경우 &lt;code&gt;keyof X&lt;/code&gt; 는 &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;number&lt;/code&gt; 및 기호와 유사한 속성을 나타내는 리터럴 유형 의 합집합입니다.</target>
        </trans-unit>
        <trans-unit id="2f946b4318e41dbe69a87cd5f88e67367fd6d44f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;typeRoots&lt;/code&gt; is specified, &lt;em&gt;only&lt;/em&gt; packages under &lt;code&gt;typeRoots&lt;/code&gt; will be included. For example:</source>
          <target state="translated">경우 &lt;code&gt;typeRoots&lt;/code&gt; 가 지정된 경우 &lt;em&gt;에만&lt;/em&gt; 아래 패키지 &lt;code&gt;typeRoots&lt;/code&gt; 이 포함됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="99b6d90008fb9649958f2be05e76b1dd9a5961c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;types&lt;/code&gt; is specified, only packages listed will be included. For instance:</source>
          <target state="translated">경우 &lt;code&gt;types&lt;/code&gt; 지정되어 나열에만 패키지가 포함됩니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="6fbac6cb9d3b7de97e789cbb5b4510b49f088657" translate="yes" xml:space="preserve">
          <source>If a decision ever comes down to &lt;code&gt;Object&lt;/code&gt; and &lt;code&gt;{}&lt;/code&gt;, you should prefer &lt;code&gt;{}&lt;/code&gt;. While they are mostly the same, technically &lt;code&gt;{}&lt;/code&gt; is a more general type than &lt;code&gt;Object&lt;/code&gt; in certain esoteric cases.</source>
          <target state="translated">결정 적으로 내려 오는 경우 &lt;code&gt;Object&lt;/code&gt; 와 &lt;code&gt;{}&lt;/code&gt; , 당신이 선호한다 &lt;code&gt;{}&lt;/code&gt; . 그것들은 대부분 동일하지만 기술적으로 &lt;code&gt;{}&lt;/code&gt; 는 특정한 난해한 경우 &lt;code&gt;Object&lt;/code&gt; 보다 더 일반적인 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="2ac2b4a6a24acc5fecb490e99fb16cab96cc3bf4" translate="yes" xml:space="preserve">
          <source>If a default type is specified and inference cannot choose a candidate, the default type is inferred.</source>
          <target state="translated">기본 유형이 지정되고 유추가 후보를 선택할 수없는 경우 기본 유형이 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="8fbc86845e0d24c360aaf1bfbc58393acef68624" translate="yes" xml:space="preserve">
          <source>If a segment of a glob pattern includes only &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;.*&lt;/code&gt;, then only files with supported extensions are included (e.g. &lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.tsx&lt;/code&gt;, and &lt;code&gt;.d.ts&lt;/code&gt; by default with &lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt; if &lt;code&gt;allowJs&lt;/code&gt; is set to true).</source>
          <target state="translated">glob 패턴의 세그먼트에 &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;.*&lt;/code&gt; 만 포함 된 경우 지원되는 확장자를 가진 파일 만 포함됩니다 (예 : &lt;code&gt;allowJs&lt;/code&gt; 가 true로 설정된 경우 기본적으로 &lt;code&gt;.js&lt;/code&gt; 및 &lt;code&gt;.jsx&lt;/code&gt; 와 함께 &lt;code&gt;.ts&lt;/code&gt; , &lt;code&gt;.tsx&lt;/code&gt; 및 &lt;code&gt;.d.ts&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="54daf0bb0e7d1bcc3df23442a6dc487446e709b6" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, or &lt;code&gt;in&lt;/code&gt; operator is nullable.</source>
          <target state="translated">(A)의 경우에는 피연산자 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , 또는 &lt;code&gt;in&lt;/code&gt; 오퍼레이터 널이다.</target>
        </trans-unit>
        <trans-unit id="ea5b35d5abd4cbfb9f096e8d991dcb47c08f66f4" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;+&lt;/code&gt; operator is nullable, and neither operand is of type &lt;code&gt;any&lt;/code&gt; or &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">(A)의 경우에는 피연산자 &lt;code&gt;+&lt;/code&gt; 의 운영자는 널없고, 둘 피연산자 타입 인 &lt;code&gt;any&lt;/code&gt; 또는 &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d883272b1b0531d98de565e92423069ee2248d62" translate="yes" xml:space="preserve">
          <source>If either operand of a &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, or &lt;code&gt;^&lt;/code&gt; operator is nullable.</source>
          <target state="translated">(A)의 경우, 피연산자 &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; 또는 &lt;code&gt;^&lt;/code&gt; 연산자는 널 입력 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b999341c4d2107c29465088a4be729def05702d7" translate="yes" xml:space="preserve">
          <source>If environment variable &lt;code&gt;TSC_NONPOLLING_WATCHER&lt;/code&gt; is set to true, watches parent directory of files (just like &lt;code&gt;UseFsEventsOnParentDirectory&lt;/code&gt;). Otherwise watch files using &lt;code&gt;fs.watchFile&lt;/code&gt; with &lt;code&gt;250ms&lt;/code&gt; as the timeout for any file</source>
          <target state="translated">환경 변수 &lt;code&gt;TSC_NONPOLLING_WATCHER&lt;/code&gt; 가 true로 설정되면 파일의 상위 디렉토리를 감시합니다 ( &lt;code&gt;UseFsEventsOnParentDirectory&lt;/code&gt; 와 동일 ). 그렇지 않으면 파일 의 시간 초과 가 &lt;code&gt;250ms&lt;/code&gt; 인 &lt;code&gt;fs.watchFile&lt;/code&gt; 을 사용하여 파일을 감시 하십시오.</target>
        </trans-unit>
        <trans-unit id="d23e16bdfbddee4b25eaec4b1d684282e726836a" translate="yes" xml:space="preserve">
          <source>If properties are never set in the class body, they are considered unknown. If your class has properties that are only read from, add and then annotate a declaration in the constructor with JSDoc to specify the type. You don&amp;rsquo;t even have to give a value if it will be initialised later:</source>
          <target state="translated">클래스 본문에 속성을 설정하지 않으면 알 수없는 것으로 간주됩니다. 클래스에 읽을 수있는 속성이있는 경우 JSDoc을 사용하여 생성자에 선언을 추가 한 다음 주석을 달아 유형을 지정하십시오. 나중에 초기화 될 경우 값을 제공 할 필요조차 없습니다.</target>
        </trans-unit>
        <trans-unit id="cf548e316f27cc773ad61fba2e4a76543f3bb1ce" translate="yes" xml:space="preserve">
          <source>If that didn&amp;rsquo;t work and if the module name is non-relative (and in the case of &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt;, it is), then the compiler will attempt to locate an &lt;a href=&quot;modules#ambient-modules&quot;&gt;ambient module declaration&lt;/a&gt;. We&amp;rsquo;ll cover non-relative imports next.</source>
          <target state="translated">그래도 작동하지 않고 모듈 이름이 관련이 없으면 (그리고 &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; 의 경우 ) 컴파일러는 &lt;a href=&quot;modules#ambient-modules&quot;&gt;앰비언트 모듈 선언&lt;/a&gt; 을 찾으려고 시도합니다 . 다음은 상대적이지 않은 수입을 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="5fc6ba7853747447fab7e2b09e476e794d7eaf75" translate="yes" xml:space="preserve">
          <source>If that sounds too lax for you, you can tighten that behavior up. If, for instance, you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want TypeScript to compile to JavaScript in the face of errors, you can use the &lt;code&gt;noEmitOnError&lt;/code&gt; option. In that sense, TypeScript has a dial on its strictness, and you can turn that knob up as high as you want.</source>
          <target state="translated">소리가 너무 느슨하면 그 동작을 강화할 수 있습니다. 예를 들어, 오류가 발생하여 &lt;code&gt;noEmitOnError&lt;/code&gt; 가 JavaScript로 컴파일 &lt;em&gt;되지 않게&lt;/em&gt; 하려면 noEmitOnError 옵션을 사용할 수 있습니다 . 그런 의미에서 TypeScript에는 엄격함에 다이얼이 있으며 원하는만큼 노브를 올릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80562a30b2229fad8a6df690b031de0355afd589" translate="yes" xml:space="preserve">
          <source>If that&amp;rsquo;s the case, the files that you&amp;rsquo;ve written are going to be used as inputs to TypeScript, and you&amp;rsquo;ll run the outputs it produces. During our JS to TS migration, we&amp;rsquo;ll need to separate our input files to prevent TypeScript from overwriting them. If your output files need to reside in a specific directory, then that will be your output directory.</source>
          <target state="translated">이 경우 작성한 파일은 TypeScript에 대한 입력으로 사용되며 생성 된 출력을 실행합니다. JS에서 TS로 마이그레이션하는 동안 TypeScript가 덮어 쓰지 않도록 입력 파일을 분리해야합니다. 출력 파일이 특정 디렉토리에 있어야하는 경우 출력 디렉토리가됩니다.</target>
        </trans-unit>
        <trans-unit id="2fcbcd9f558fa8a3faacb1b7e2f2cc6f3c7dd80a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; and &lt;code&gt;&quot;include&quot;&lt;/code&gt; are both left unspecified, the compiler defaults to including all TypeScript (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt;) files in the containing directory and subdirectories except those excluded using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. JS files (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt;) are also included if &lt;code&gt;allowJs&lt;/code&gt; is set to true.</source>
          <target state="translated">경우 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 모두 컴파일러의 모든 타이프 라이터를 포함하여 기본값 (지정되지 않은 상태입니다 &lt;code&gt;.ts&lt;/code&gt; , &lt;code&gt;.d.ts&lt;/code&gt; 을 하고 &lt;code&gt;.tsx&lt;/code&gt; 은 Using 제외 제외) 파일을 포함하는 디렉토리 및 하위 디렉토리 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 속성. &lt;code&gt;allowJs&lt;/code&gt; 가 true로 설정된 경우 JS 파일 ( &lt;code&gt;.js&lt;/code&gt; 및 &lt;code&gt;.jsx&lt;/code&gt; )도 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="477c8cbe4706878c16fb156bd723ab8f217099e9" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; and &lt;code&gt;&quot;include&quot;&lt;/code&gt; are both left unspecified, the compiler defaults to including all TypeScript (&lt;code&gt;.ts&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt; and &lt;code&gt;.tsx&lt;/code&gt;) files in the containing directory and subdirectories except those excluded using the &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property. JS files (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.jsx&lt;/code&gt;) are also included if &lt;code&gt;allowJs&lt;/code&gt; is set to true. If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; compiler option are excluded as long as &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; property is not specified.</source>
          <target state="translated">경우 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 모두 컴파일러의 모든 타이프 라이터를 포함하여 기본값 (지정되지 않은 상태입니다 &lt;code&gt;.ts&lt;/code&gt; , &lt;code&gt;.d.ts&lt;/code&gt; 을 하고 &lt;code&gt;.tsx&lt;/code&gt; 은 Using 제외 제외) 파일을 포함하는 디렉토리 및 하위 디렉토리 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 속성. &lt;code&gt;allowJs&lt;/code&gt; 가 true로 설정된 경우 JS 파일 ( &lt;code&gt;.js&lt;/code&gt; 및 &lt;code&gt;.jsx&lt;/code&gt; )도 포함됩니다 . 경우 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 속성이 지정되어, 컴파일러는이 두 속성으로 포함 된 파일의 조합을 포함하는 대신합니다. &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; 을 사용하여 지정된 디렉토리의 파일 &lt;code&gt;&quot;exclude&quot;&lt;/code&gt; 특성이 지정되지 않으면 컴파일러 옵션이 제외됩니다 .</target>
        </trans-unit>
        <trans-unit id="d6b124b086b760cf9eb1864e544665757f5217f3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&quot;files&quot;&lt;/code&gt; or &lt;code&gt;&quot;include&quot;&lt;/code&gt; properties are specified, the compiler will instead include the union of the files included by those two properties. Files in the directory specified using the &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; compiler option are always excluded unless explicitly included via the &lt;code&gt;&quot;files&quot;&lt;/code&gt; property (even when the &amp;ldquo;&lt;code&gt;exclude&lt;/code&gt;&amp;rdquo; property is specified).</source>
          <target state="translated">경우 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;include&quot;&lt;/code&gt; 속성이 지정되어, 컴파일러는이 두 속성으로 포함 된 파일의 조합을 포함하는 대신합니다. &lt;code&gt;&quot;outDir&quot;&lt;/code&gt; 컴파일러 옵션을 사용하여 지정된 디렉토리의 &lt;code&gt;&quot;files&quot;&lt;/code&gt; 은 &quot;files&quot; 특성을 통해 명시 적으로 포함되지 않는 한 ( &quot; &lt;code&gt;exclude&lt;/code&gt; &quot;특성이 지정된 경우에도) 항상 제외됩니다 .</target>
        </trans-unit>
        <trans-unit id="9fce1a983a1219926f1f38bab0bfb60ec3fd4b5c" translate="yes" xml:space="preserve">
          <source>If the accessor decorator returns a value, it will be used as the &lt;em&gt;Property Descriptor&lt;/em&gt; for the member.</source>
          <target state="translated">접근 자 데코레이터가 값을 반환하면 값 이 멤버 의 &lt;em&gt;속성 설명&lt;/em&gt; 자로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="757bf2cd851a721420b759b576fc525ad4b2e255" translate="yes" xml:space="preserve">
          <source>If the class decorator returns a value, it will replace the class declaration with the provided constructor function.</source>
          <target state="translated">클래스 데코레이터가 값을 반환하면 클래스 선언을 제공된 생성자 함수로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="dcdc136ee9d606ac3aebb0a12ffa90330d056cbb" translate="yes" xml:space="preserve">
          <source>If the compiler flag &lt;code&gt;--noResolve&lt;/code&gt; is specified, triple-slash references are ignored; they neither result in adding new files, nor change the order of the files provided.</source>
          <target state="translated">컴파일러 플래그 &lt;code&gt;--noResolve&lt;/code&gt; 를 지정하면 삼중 슬래시 참조가 무시됩니다. 새 파일을 추가하거나 제공된 파일의 순서를 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64760e36eb2b3cf9f6dce25e269af13108cbb2ff" translate="yes" xml:space="preserve">
          <source>If the method decorator returns a value, it will be used as the &lt;em&gt;Property Descriptor&lt;/em&gt; for the method.</source>
          <target state="translated">메소드 데코레이터가 값을 리턴하면 해당 메소드의 &lt;em&gt;특성 설명&lt;/em&gt; 자로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5f107d97fba869cf2daf87a931e54a8895ed1bc" translate="yes" xml:space="preserve">
          <source>If the operand of a &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;, &lt;code&gt;++&lt;/code&gt;, or &lt;code&gt;--&lt;/code&gt; unary operator is nullable.</source>
          <target state="translated">a의 피연산자 경우 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; , &lt;code&gt;++&lt;/code&gt; , 또는 &lt;code&gt;--&lt;/code&gt; 단항 연산자는 널 입력이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a35de86d636b3f4498ca4f03ae3386c7c6c3cc94" translate="yes" xml:space="preserve">
          <source>If the referenced project produces an &lt;code&gt;outFile&lt;/code&gt;, the output file &lt;code&gt;.d.ts&lt;/code&gt; file&amp;rsquo;s declarations will be visible in this project</source>
          <target state="translated">참조 된 프로젝트가 &lt;code&gt;outFile&lt;/code&gt; 을 생성하면이 프로젝트 에서 출력 파일 &lt;code&gt;.d.ts&lt;/code&gt; 파일의 선언이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="dd06f92d40ce76202d5611a64daad24f2a1feac2" translate="yes" xml:space="preserve">
          <source>If the right operand of an &lt;code&gt;instanceof&lt;/code&gt; operator is nullable.</source>
          <target state="translated">&lt;code&gt;instanceof&lt;/code&gt; 연산자 의 오른쪽 피연산자 가 널 입력 가능 인 경우.</target>
        </trans-unit>
        <trans-unit id="bb788c0916122fd9a75b33b92aa45518eb1b4e5a" translate="yes" xml:space="preserve">
          <source>If this function were not in a contextually typed position, the function&amp;rsquo;s argument would implicitly have type &lt;code&gt;any&lt;/code&gt;, and no error would be issued (unless you are using the &lt;code&gt;--noImplicitAny&lt;/code&gt; option):</source>
          <target state="translated">이 함수가 문맥 상 형식화 된 위치에 있지 않은 경우 함수의 인수는 암시 적으로 유형 &lt;code&gt;any&lt;/code&gt; 를 가지며 &lt;code&gt;--noImplicitAny&lt;/code&gt; 옵션을 사용하지 않는 한 오류가 발생하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d3ba6383ac88848a0ef4f846d3fe4de2bef1cab6" translate="yes" xml:space="preserve">
          <source>If we have a value that has a union type, we can only access members that are common to all types in the union.</source>
          <target state="translated">공용체 유형의 값이있는 경우 공용체의 모든 유형에 공통적 인 멤버에만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1d377830062aff369f8dab5df851e9080561624" translate="yes" xml:space="preserve">
          <source>If we want to customize how a decorator is applied to a declaration, we can write a decorator factory. A &lt;em&gt;Decorator Factory&lt;/em&gt; is simply a function that returns the expression that will be called by the decorator at runtime.</source>
          <target state="translated">데코레이터가 선언에 적용되는 방식을 사용자 정의하려면 데코레이터 팩토리를 작성할 수 있습니다. &lt;em&gt;실내 장식 공장은&lt;/em&gt; 단순히 런타임에 장식으로 호출되는 표현을 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="d0a73f363bdb39ad6e23dfd5f55548093ac466d2" translate="yes" xml:space="preserve">
          <source>If we wanted, we could leave off the initializers entirely:</source>
          <target state="translated">원한다면 이니셜 라이저를 완전히 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83df15e4cf413e10be414506c047c7618a0d3d89" translate="yes" xml:space="preserve">
          <source>If we were to use &lt;a href=&quot;#decorator-factories&quot;&gt;decorator factories&lt;/a&gt;, we can observe this evaluation order with the following example:</source>
          <target state="translated">&lt;a href=&quot;#decorator-factories&quot;&gt;데코레이터 팩토리&lt;/a&gt; 를 사용 하는 경우 다음 예제 를 사용 하여이 평가 순서를 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89a7882773e333f0676bc25954729647144846fe" translate="yes" xml:space="preserve">
          <source>If you add a &lt;code&gt;tsconfig.json&lt;/code&gt; file, TypeScript files that are not considered part of that context are not compiled.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; 파일 을 추가하면 해당 컨텍스트의 일부로 간주되지 않는 TypeScript 파일이 컴파일되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c6633882fd2cbc849cc78df7098cdbc11e0f7c9" translate="yes" xml:space="preserve">
          <source>If you are using a different build tool to build your project (e.g. gulp, grunt , etc.) and VS for the development and debugging experience, set &lt;code&gt;&amp;lt;TypeScriptCompileBlocked&amp;gt;true&amp;lt;/TypeScriptCompileBlocked&amp;gt;&lt;/code&gt; in your project. This should give you all the editing support, but not the build when you hit F5.</source>
          <target state="translated">개발 및 디버깅 경험을 위해 다른 빌드 도구를 사용하여 프로젝트 (예 : gulp, grunt 등) 및 VS를 빌드하는 경우 프로젝트에서 &lt;code&gt;&amp;lt;TypeScriptCompileBlocked&amp;gt;true&amp;lt;/TypeScriptCompileBlocked&amp;gt;&lt;/code&gt; 를 설정하십시오. 이렇게하면 F5를 누를 때 모든 편집 지원이 제공되지만 빌드는 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5cd9012eef954c07679b23981cd46180ffa74948" translate="yes" xml:space="preserve">
          <source>If you check in any build outputs (&lt;code&gt;.js&lt;/code&gt;, &lt;code&gt;.d.ts&lt;/code&gt;, &lt;code&gt;.d.ts.map&lt;/code&gt;, etc.), you may need to run a &lt;code&gt;--force&lt;/code&gt; build after certain source control operations depending on whether your source control tool preserves timestamps between the local copy and the remote copy.</source>
          <target state="translated">빌드 출력 ( &lt;code&gt;.js&lt;/code&gt; , &lt;code&gt;.d.ts&lt;/code&gt; , &lt;code&gt;.d.ts.map&lt;/code&gt; 등) 을 체크인하는 경우 소스 제어 도구의 보존 여부에 따라 특정 소스 제어 조작 후 &lt;code&gt;--force&lt;/code&gt; 빌드 를 실행해야 할 수도 있습니다 로컬 사본과 원격 사본 사이의 시간 소인.</target>
        </trans-unit>
        <trans-unit id="6a349b11b7d0ef239663304628dfd9c61e8381c6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to take the time to write out declarations before using a new module, you can now just use a shorthand declaration to get started quickly.</source>
          <target state="translated">새 모듈을 사용하기 전에 선언을 작성하는 데 시간이 걸리지 않는 경우 이제 간단한 선언을 사용하여 빠르게 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fae05d77b88c64d5e95a8ef1a5541f4907ad6f4f" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to take the time to write out declarations before using a new module, you can use a shorthand declaration to get started quickly.</source>
          <target state="translated">새 모듈을 사용하기 전에 선언을 작성하지 않으려는 경우 속기 선언을 사용하여 빠르게 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6d64531eb1511551180721cfd80f278a3113a79" translate="yes" xml:space="preserve">
          <source>If you ever have a value that TypeScript thinks is possibly &lt;code&gt;null&lt;/code&gt;/&lt;code&gt;undefined&lt;/code&gt;, but you know better, you can use the postfix &lt;code&gt;!&lt;/code&gt; operator to tell it otherwise.</source>
          <target state="translated">TypeScript가 &lt;code&gt;null&lt;/code&gt; / &lt;code&gt;undefined&lt;/code&gt; 라고 생각하는 값을 가지고 있지만 더 잘 알고 있다면 접미사를 사용할 수 있습니다 &lt;code&gt;!&lt;/code&gt; 그렇지 않으면 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c329b002b75ec8975f18054725c2bf4040952e7" translate="yes" xml:space="preserve">
          <source>If you had the following Node/CommonJS code:</source>
          <target state="translated">다음과 같은 Node / CommonJS 코드가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="dc04d34dfcaac9afb16dfcca2506c06bccfa00d4" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;tests&lt;/code&gt; folder outside of your &lt;code&gt;src&lt;/code&gt; directory, you might have one &lt;code&gt;tsconfig.json&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt;, and one in &lt;code&gt;tests&lt;/code&gt; as well.</source>
          <target state="translated">당신이있는 경우 &lt;code&gt;tests&lt;/code&gt; 당신의 외부 폴더 &lt;code&gt;src&lt;/code&gt; 디렉토리를 하나있을 수 있습니다 &lt;code&gt;tsconfig.json&lt;/code&gt; 에서 &lt;code&gt;src&lt;/code&gt; 에, 하나를 &lt;code&gt;tests&lt;/code&gt; 뿐만 아니라.</target>
        </trans-unit>
        <trans-unit id="1c080c78e7a69573dae8c2024c9d66a13c40bf94" translate="yes" xml:space="preserve">
          <source>If you have a type with a number index signature, &lt;code&gt;keyof T&lt;/code&gt; will just be &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">숫자 색인 서명이있는 유형이있는 경우 &lt;code&gt;keyof T&lt;/code&gt; 는 &lt;code&gt;number&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bad1becd57096ef1e33ba9bd0ebbac35bc9622bd" translate="yes" xml:space="preserve">
          <source>If you have an msbuild project, you can enable build mode by adding</source>
          <target state="translated">msbuild 프로젝트가있는 경우 다음을 추가하여 빌드 모드를 활성화 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="88dba7da91434766a3c79f38e44d7fef30aa351c" translate="yes" xml:space="preserve">
          <source>If you intended to test the function without calling it, you can correct the definition of it to include &lt;code&gt;undefined&lt;/code&gt;/&lt;code&gt;null&lt;/code&gt;, or use &lt;code&gt;!!&lt;/code&gt; to write something like &lt;code&gt;if (!!user.isAdministrator)&lt;/code&gt; to indicate that the coercion is intentional.</source>
          <target state="translated">함수를 호출하지 않고 테스트하려는 경우 &lt;code&gt;undefined&lt;/code&gt; / &lt;code&gt;null&lt;/code&gt; 을 포함하도록 함수 정의를 수정 하거나 &lt;code&gt;!!&lt;/code&gt; 강요가 의도적임을 나타내는 &lt;code&gt;if (!!user.isAdministrator)&lt;/code&gt; 와 같은 것을 작성 하십시오.</target>
        </trans-unit>
        <trans-unit id="ed97452c7f7269f74ea84e8195f99486afcc62bd" translate="yes" xml:space="preserve">
          <source>If you plan on using the stricter settings that are available, it&amp;rsquo;s best to turn them on now (see &lt;a href=&quot;#getting-stricter-checks&quot;&gt;Getting Stricter Checks&lt;/a&gt; below). For instance, if you never want TypeScript to silently infer &lt;code&gt;any&lt;/code&gt; for a type without you explicitly saying so, you can use &lt;code&gt;noImplicitAny&lt;/code&gt; before you start modifying your files. While it might feel somewhat overwhelming, the long-term gains become apparent much more quickly.</source>
          <target state="translated">사용 가능한보다 엄격한 설정을 사용하려는 경우 지금 설정하는 것이 가장 좋습니다 ( 아래의 &lt;a href=&quot;#getting-stricter-checks&quot;&gt;보다 엄격한 검사 받기&lt;/a&gt; 참조). 당신이 타이프 라이터가 자동으로 추론하고 싶지는 않을 경우 예를 들어, &lt;code&gt;any&lt;/code&gt; 사용자가 명시 적으로 그렇게 말을하지 않고 유형을, 당신은 사용할 수 있습니다 &lt;code&gt;noImplicitAny&lt;/code&gt; 을 당신이 당신의 파일을 수정하기 전에. 다소 압도적으로 느껴질 수 있지만 장기적인 이익은 훨씬 빨리 나타납니다.</target>
        </trans-unit>
        <trans-unit id="d704dd727aa16026d03295d60e4fd6bd0f450b47" translate="yes" xml:space="preserve">
          <source>If you remember from an earlier example, you may sometimes want to write a generic function that works on a set of types where you have some knowledge about what capabilities that set of types will have. In our &lt;code&gt;loggingIdentity&lt;/code&gt; example, we wanted to be able to access the &lt;code&gt;.length&lt;/code&gt; property of &lt;code&gt;arg&lt;/code&gt;, but the compiler could not prove that every type had a &lt;code&gt;.length&lt;/code&gt; property, so it warns us that we can&amp;rsquo;t make this assumption.</source>
          <target state="translated">이전 예제를 기억하는 경우 유형 유형에 어떤 기능이 있는지에 대한 지식이있는 유형 유형에서 작동하는 일반 함수를 작성하려고 할 수 있습니다. 우리에 &lt;code&gt;loggingIdentity&lt;/code&gt; 의 예를 들어, 우리는 액세스 할 수 있기를 원 &lt;code&gt;.length&lt;/code&gt; 의 의 자산 &lt;code&gt;arg&lt;/code&gt; 하지만 컴파일러는 모든 종류의가 있다고 증명할 수 &lt;code&gt;.length&lt;/code&gt; 우리가이 가정을 할 수 있음을 경고, 그래서 속성을.</target>
        </trans-unit>
        <trans-unit id="f2f60b10d440544ea9c56ee6406205dc250ac35c" translate="yes" xml:space="preserve">
          <source>If you see tests for &lt;code&gt;typeof define&lt;/code&gt;, &lt;code&gt;typeof window&lt;/code&gt;, or &lt;code&gt;typeof module&lt;/code&gt; in the code of a library, especially at the top of the file, it&amp;rsquo;s almost always a UMD library.</source>
          <target state="translated">라이브러리 코드, 특히 파일 맨 위에 &lt;code&gt;typeof define&lt;/code&gt; , &lt;code&gt;typeof window&lt;/code&gt; 또는 &lt;code&gt;typeof module&lt;/code&gt; 에 대한 테스트가 표시되는 경우 거의 항상 UMD 라이브러리입니다.</target>
        </trans-unit>
        <trans-unit id="c25089b3bb720ad8bf4d7033bc03403e6d851984" translate="yes" xml:space="preserve">
          <source>If you started converting over to TypeScript imports, you&amp;rsquo;ll probably run into errors like &lt;code&gt;Cannot find module 'foo'.&lt;/code&gt;. The issue here is that you likely don&amp;rsquo;t have &lt;em&gt;declaration files&lt;/em&gt; to describe your library. Luckily this is pretty easy. If TypeScript complains about a package like &lt;code&gt;lodash&lt;/code&gt;, you can just write</source>
          <target state="translated">TypeScript 가져 오기로 변환을 시작한 경우 &lt;code&gt;Cannot find module 'foo'.&lt;/code&gt; 과 같은 오류가 발생할 수 있습니다. . 여기서 문제는 라이브러리를 설명 할 &lt;em&gt;선언 파일&lt;/em&gt; 이 없을 수 있다는 것 입니다. 다행히 이것은 매우 쉽습니다. 타이프 라이터 같은 패키지에 대해 불평하는 경우 &lt;code&gt;lodash&lt;/code&gt; , 당신은 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b4fea75c265155bd6df0203787b647e915b7efa9" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;y&lt;/code&gt; in a way that the type parameter&amp;rsquo;s constraint doesn&amp;rsquo;t support, you&amp;rsquo;ll correctly get an error. In this case, the constraint of &lt;code&gt;T&lt;/code&gt; was (implicitly) &lt;code&gt;{}&lt;/code&gt;, so the last example will appropriately fail.</source>
          <target state="translated">형식 매개 변수의 제약 조건이 지원하지 않는 방식으로 &lt;code&gt;y&lt;/code&gt; 를 사용 하면 오류가 올바르게 발생합니다. 이 경우 &lt;code&gt;T&lt;/code&gt; 의 제한 조건 은 (암시 적으로) &lt;code&gt;{}&lt;/code&gt; 이므로 마지막 예제는 적절하게 실패합니다.</target>
        </trans-unit>
        <trans-unit id="e6bd2cecc096e05874940061ada8a05394b1dbd5" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d prefer to be explicit, you can also enforce the type of values that can be returned, yielded, and evaluated from &lt;code&gt;yield&lt;/code&gt; expressions using an explicit return type. Below, &lt;code&gt;next()&lt;/code&gt; can only be called with &lt;code&gt;boolean&lt;/code&gt;s, and depending on the value of &lt;code&gt;done&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is either a &lt;code&gt;string&lt;/code&gt; or a &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">명시 적을 선호하는 경우 명시 적 반환 유형을 사용하여 &lt;code&gt;yield&lt;/code&gt; 표현식 에서 반환, 산출 및 평가할 수있는 값 유형을 적용 할 수도 있습니다 . 다음, &lt;code&gt;next()&lt;/code&gt; 에서만 호출 할 수 있습니다 &lt;code&gt;boolean&lt;/code&gt; 들, 그리고 값에 따라 &lt;code&gt;done&lt;/code&gt; , &lt;code&gt;value&lt;/code&gt; 중 하나입니다 &lt;code&gt;string&lt;/code&gt; 이나 &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25c9ec1976e4df8a2ef8c0b469042e5f520617b9" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re converting a program from namespaces to modules, it can be easy to end up with a file that looks like this:</source>
          <target state="translated">네임 스페이스에서 모듈로 프로그램을 변환하는 경우 다음과 같은 파일로 쉽게 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="513d665d33a30074384ac54ddb0be0edac2c6bbf" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re exporting multiple objects, put them all at top-level</source>
          <target state="translated">여러 객체를 내보내는 경우 모두 최상위 레벨에 두십시오.</target>
        </trans-unit>
        <trans-unit id="e6a9291b44ab09ee343d0c813d7995f1938982dd" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re looking to convert a React project, we recommend looking at the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide&quot;&gt;React Conversion Guide&lt;/a&gt; first.</source>
          <target state="translated">React 프로젝트를 변환하려면 먼저 &lt;a href=&quot;https://github.com/Microsoft/TypeScript-React-Conversion-Guide#typescript-react-conversion-guide&quot;&gt;React Conversion Guide를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b3d86758d6ba06b2c6d545d9e0ad1ace8a4b070" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re only exporting a single &lt;code&gt;class&lt;/code&gt; or &lt;code&gt;function&lt;/code&gt;, use &lt;code&gt;export default&lt;/code&gt;</source>
          <target state="translated">단일 &lt;code&gt;class&lt;/code&gt; 또는 &lt;code&gt;function&lt;/code&gt; 만 내보내는 경우 &lt;code&gt;export default&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f70d23b3b33808540611f0c15d2283c4e323059" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re reading this guide, you probably already roughly know what a type in TypeScript is. To be more explicit, though, a &lt;em&gt;type&lt;/em&gt; is introduced with:</source>
          <target state="translated">이 안내서를 읽고 있다면 아마도 아마도 TypeScript의 유형이 무엇인지 이미 알고있을 것입니다. 좀 더 명확하게하기 위해, &lt;em&gt;타입&lt;/em&gt; 은 다음과 같이 소개됩니다 :</target>
        </trans-unit>
        <trans-unit id="b934c40448796bd9edae2d68f2dcee6ad19754ce" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re starting a brand new project, take a look at the &lt;a href=&quot;https://create-react-app.dev/docs/adding-typescript&quot;&gt;React Quick Start guide&lt;/a&gt; first.</source>
          <target state="translated">새로운 프로젝트를 시작하는 경우 먼저 &lt;a href=&quot;https://create-react-app.dev/docs/adding-typescript&quot;&gt;React 빠른 시작 안내서를&lt;/a&gt; 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="cff1c0146ace654a504313182db4a173a9b3388c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using Gulp in some fashion, we have a tutorial on &lt;a href=&quot;gulp&quot;&gt;using Gulp&lt;/a&gt; with TypeScript, and integrating with common build tools like Browserify, Babelify, and Uglify. You can read more there.</source>
          <target state="translated">Gulp를 어떤 방식으로 &lt;a href=&quot;gulp&quot;&gt;사용&lt;/a&gt; 하는 경우 TypeScript와 함께 Gulp 를 사용 하고 Browserify, Babelify 및 Uglify와 같은 일반적인 빌드 도구와 통합하는 방법 에 대한 자습서가 있습니다 . 더 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cafdaaff5d59cc2c2f1205e3709213e65336f377" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using a module option other than &lt;code&gt;commonjs&lt;/code&gt;, you&amp;rsquo;ll need to set your &lt;code&gt;moduleResolution&lt;/code&gt; option to &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;commonjs&lt;/code&gt; 이외의 모듈 옵션을 사용하는 경우 &lt;code&gt;moduleResolution&lt;/code&gt; 옵션을 &lt;code&gt;node&lt;/code&gt; 로 설정해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="0aafe02ccb06b6d197194a0b7f3d99641d791f0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re writing in plain JavaScript, it&amp;rsquo;s likely that you&amp;rsquo;re running your JavaScript directly, where your &lt;code&gt;.js&lt;/code&gt; files are in a &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;lib&lt;/code&gt;, or &lt;code&gt;dist&lt;/code&gt; directory, and then ran as desired.</source>
          <target state="translated">일반 JavaScript로 작성하는 경우 &lt;code&gt;.js&lt;/code&gt; 파일이 &lt;code&gt;src&lt;/code&gt; , &lt;code&gt;lib&lt;/code&gt; 또는 &lt;code&gt;dist&lt;/code&gt; 디렉토리 에있는 JavaScript를 직접 실행 한 다음 원하는대로 실행했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdfba1223ac1da9db70e78da0daf0187962aac1a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve read about &lt;code&gt;typeof&lt;/code&gt; type guards and are familiar with the &lt;code&gt;instanceof&lt;/code&gt; operator in JavaScript, you probably have some idea of what this section is about.</source>
          <target state="translated">&lt;code&gt;typeof&lt;/code&gt; type guard 에 대해 읽고 JavaScript 의 &lt;code&gt;instanceof&lt;/code&gt; 연산자에 익숙 하다면 이 섹션의 내용을 알고있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="ba89c0b592333fdedc6dea3af514c7a63cd66e0b" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve used JavaScript offhandedly, the next section might be a good way to refresh your memory. If you&amp;rsquo;re intimately familiar with all the quirks of &lt;code&gt;var&lt;/code&gt; declarations in JavaScript, you might find it easier to skip ahead.</source>
          <target state="translated">자바 스크립트를 불쾌하게 사용한 경우 다음 섹션에서 메모리를 새로 고칠 수 있습니다. JavaScript에서 &lt;code&gt;var&lt;/code&gt; 선언 의 모든 단점에 친숙한 경우 건너 뛰기가 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f637065274f76d0b1f9c68b24c257b06ecca8b9" translate="yes" xml:space="preserve">
          <source>If your functions are only able to handle string named property keys, use &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; in the declaration:</source>
          <target state="translated">함수가 이름 지정된 속성 키만 처리 할 수 있는 경우 선언에서 &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d510aeb4b1e7484eea0e856138d74440b24ca0d1" translate="yes" xml:space="preserve">
          <source>If your functions are open to handling all property keys, then the changes should be done down-stream:</source>
          <target state="translated">모든 속성 키를 처리 할 수있는 기능이 열려 있으면 변경을 다운 스트림으로 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="f902e411cb6ca33234031133f35364e8839ccd53" translate="yes" xml:space="preserve">
          <source>If your global library depends on a UMD module, use a &lt;code&gt;/// &amp;lt;reference types&lt;/code&gt; directive:</source>
          <target state="translated">글로벌 라이브러리가 UMD 모듈에 의존하는 경우 &lt;code&gt;/// &amp;lt;reference types&lt;/code&gt; 지시문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f7345e0903abc9ae4ad2adfd269b38c296742fa6" translate="yes" xml:space="preserve">
          <source>If your library depends on a global library, use a &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; directive:</source>
          <target state="translated">라이브러리가 글로벌 라이브러리에 의존하는 경우 &lt;code&gt;/// &amp;lt;reference types=&quot;...&quot; /&amp;gt;&lt;/code&gt; 지시문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b2e55a3a3ef94d5068ad16150d23ae196cc87947" translate="yes" xml:space="preserve">
          <source>If your library depends on a module, use an &lt;code&gt;import&lt;/code&gt; statement:</source>
          <target state="translated">라이브러리가 모듈에 의존하는 경우 &lt;code&gt;import&lt;/code&gt; 문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="39f14e77085a3e6f94f80d3a5737a97256584f64" translate="yes" xml:space="preserve">
          <source>If your module is not callable or constructable, use the &lt;a href=&quot;templates/module-d-ts&quot;&gt;&lt;code&gt;module.d.ts&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">모듈을 호출하거나 구성 할 수없는 경우 &lt;a href=&quot;templates/module-d-ts&quot;&gt; &lt;code&gt;module.d.ts&lt;/code&gt; &lt;/a&gt; 파일을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="708b87e0f5ca75919f8732aead8eedddc9c8eae8" translate="yes" xml:space="preserve">
          <source>If your module or UMD library depends on a UMD library, use an &lt;code&gt;import&lt;/code&gt; statement:</source>
          <target state="translated">모듈 또는 UMD 라이브러리가 UMD 라이브러리에 의존하는 경우 &lt;code&gt;import&lt;/code&gt; 문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b502ac0f72d569709af646c5ae02325abd8bb700" translate="yes" xml:space="preserve">
          <source>If your package has a main &lt;code&gt;.js&lt;/code&gt; file, you will need to indicate the main declaration file in your &lt;code&gt;package.json&lt;/code&gt; file as well. Set the &lt;code&gt;types&lt;/code&gt; property to point to your bundled declaration file. For example:</source>
          <target state="translated">패키지에 기본 &lt;code&gt;.js&lt;/code&gt; 파일 이있는 경우 &lt;code&gt;package.json&lt;/code&gt; 파일에도 기본 선언 파일을 표시해야합니다 . 번들 속성 파일을 가리 키도록 &lt;code&gt;types&lt;/code&gt; 속성을 설정 하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8809cc04677d076884fe6edcda034b008be7ba2b" translate="yes" xml:space="preserve">
          <source>If your package is not written in TypeScript then the second is the preferred approach.</source>
          <target state="translated">패키지가 TypeScript로 작성되지 않은 경우 두 번째 방법이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="3a45948f03090d8097a2e93bad2b6d30f82543a2" translate="yes" xml:space="preserve">
          <source>If your package is written in TypeScript then the first approach is favored. Use the &lt;code&gt;--declaration&lt;/code&gt; flag to generate declaration files. This way, your declarations and JavaScript will always be in sync.</source>
          <target state="translated">패키지가 TypeScript로 작성된 경우 첫 번째 방법이 선호됩니다. 선언 파일을 생성 하려면 &lt;code&gt;--declaration&lt;/code&gt; 플래그를 사용하십시오 . 이렇게하면 선언과 JavaScript가 항상 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="490e3c77ca2e4322ada004a6ddfd9a7799557dcc" translate="yes" xml:space="preserve">
          <source>If your type definitions depend on another package:</source>
          <target state="translated">유형 정의가 다른 패키지에 의존하는 경우 :</target>
        </trans-unit>
        <trans-unit id="f5dd23741ab01d47a9d58ca45645a4ccefbbd8f1" translate="yes" xml:space="preserve">
          <source>Implementing an interface</source>
          <target state="translated">인터페이스 구현</target>
        </trans-unit>
        <trans-unit id="0aba642bf4d637216b8d72e2f4ad7c9560d9798e" translate="yes" xml:space="preserve">
          <source>Implicit any errors</source>
          <target state="translated">암시적인 오류</target>
        </trans-unit>
        <trans-unit id="7d52fc0e48ad6e0d6c8f5245ccb19f1dd538a022" translate="yes" xml:space="preserve">
          <source>Implicit index signatures</source>
          <target state="translated">암시 적 인덱스 서명</target>
        </trans-unit>
        <trans-unit id="c8c4c307ff84c0f8c706629a70179c01013c51e4" translate="yes" xml:space="preserve">
          <source>Implicit returns</source>
          <target state="translated">암시 적 반환</target>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="ac42b7771deabcf8b9b301382d1ce7966a14ab50" translate="yes" xml:space="preserve">
          <source>Import a module for side-effects only</source>
          <target state="translated">부작용 전용 모듈 가져 오기</target>
        </trans-unit>
        <trans-unit id="c5b568ec8548086b4de521e5d8033aec1c934aac" translate="yes" xml:space="preserve">
          <source>Import a single export from a module</source>
          <target state="translated">모듈에서 단일 내보내기 가져 오기</target>
        </trans-unit>
        <trans-unit id="7830f060b13276e33e83c28a73aa77da5e486098" translate="yes" xml:space="preserve">
          <source>Import declarations, as well, can optionally use &lt;code&gt;as&lt;/code&gt; clauses to specify different local names for the imports. For example:</source>
          <target state="translated">가져 오기 선언도 선택적 &lt;code&gt;as&lt;/code&gt; 절을 사용하여 가져 오기에 다른 로컬 이름을 지정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9914e368d228c16ed67283b9e88ab7f396d147f6" translate="yes" xml:space="preserve">
          <source>Import emit helpers (e.g. &lt;code&gt;__extends&lt;/code&gt;, &lt;code&gt;__rest&lt;/code&gt;, etc..) from &lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">가져 오기 발광 헬퍼 (예 : &lt;code&gt;__extends&lt;/code&gt; , &lt;code&gt;__rest&lt;/code&gt; 에서, 등) &lt;a href=&quot;https://www.npmjs.com/package/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d44d2976c5175c70409be4c97c0352850c0e7940" translate="yes" xml:space="preserve">
          <source>Import the entire module into a single variable, and use it to access the module exports</source>
          <target state="translated">전체 모듈을 단일 변수로 가져 와서이를 사용하여 모듈 내보내기에 액세스</target>
        </trans-unit>
        <trans-unit id="f908ff98948cecb3646ddcfb8cfb7d6851889ec0" translate="yes" xml:space="preserve">
          <source>Import types</source>
          <target state="translated">수입 유형</target>
        </trans-unit>
        <trans-unit id="a60647122c766cfb16cfd3672d6ea4130dbed5fe" translate="yes" xml:space="preserve">
          <source>Importing from Modules</source>
          <target state="translated">모듈에서 가져 오기</target>
        </trans-unit>
        <trans-unit id="f3c938e48f51fc9b9d8d6906d41005ba5ef033c7" translate="yes" xml:space="preserve">
          <source>Importing is just about as easy as exporting from a module. Importing an exported declaration is done through using one of the &lt;code&gt;import&lt;/code&gt; forms below:</source>
          <target state="translated">가져 오기는 모듈에서 내보내는 것만 큼 쉽습니다. 내 보낸 선언은 아래 의 &lt;code&gt;import&lt;/code&gt; 양식 중 하나를 사용하여 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="9f780bafb7678e0e4bc2ed60d39928e72d6363d4" translate="yes" xml:space="preserve">
          <source>Importing modules from a referenced project will instead load its &lt;em&gt;output&lt;/em&gt; declaration file (&lt;code&gt;.d.ts&lt;/code&gt;)</source>
          <target state="translated">참조 된 프로젝트에서 모듈을 가져 오면 대신 &lt;em&gt;출력&lt;/em&gt; 선언 파일 ( &lt;code&gt;.d.ts&lt;/code&gt; ) 이로드 됩니다.</target>
        </trans-unit>
        <trans-unit id="1493dcf2543fd7025bb0dc28504a88da052081ce" translate="yes" xml:space="preserve">
          <source>Importing none-code resources using module loaders extension (e.g. &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt; or &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.html&quot;&gt;SystemJS&lt;/a&gt;) has not been easy before; previously an ambient module declaration had to be defined for each resource.</source>
          <target state="translated">모듈 로더 확장 (예 : &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/loaderplugins.html&quot;&gt;AMD&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/systemjs/systemjs/blob/master/docs/creating-plugins.html&quot;&gt;SystemJS&lt;/a&gt; )을 사용하여 비 코드 리소스를 가져 오는 것은 쉽지 않았습니다. 이전에는 각 리소스에 대해 주변 모듈 선언을 정의해야했습니다.</target>
        </trans-unit>
        <trans-unit id="352d94d7b6ad5d2d2dd80449838c2cf319556903" translate="yes" xml:space="preserve">
          <source>Improved &lt;code&gt;any&lt;/code&gt; Inference</source>
          <target state="translated">개선 된 &lt;code&gt;any&lt;/code&gt; 추론</target>
        </trans-unit>
        <trans-unit id="400b56a2fe294d586033d28165229215531d4f5f" translate="yes" xml:space="preserve">
          <source>Improved &lt;code&gt;keyof&lt;/code&gt; with intersection types</source>
          <target state="translated">교차로 유형으로 키 &lt;code&gt;keyof&lt;/code&gt; 개선</target>
        </trans-unit>
        <trans-unit id="5db53c8c85f119e50fb4fddb0515ec92c8d14cae" translate="yes" xml:space="preserve">
          <source>Improved UX Around Promises</source>
          <target state="translated">약속 된 UX 개선</target>
        </trans-unit>
        <trans-unit id="39095ed614c976a48a5edd3ac9559249a5bcafb9" translate="yes" xml:space="preserve">
          <source>Improved behavior for calling union types</source>
          <target state="translated">조합 유형 호출에 대한 개선 된 동작</target>
        </trans-unit>
        <trans-unit id="3aed2d7ad51f292dd55e2c452dc2f9d916f9f348" translate="yes" xml:space="preserve">
          <source>Improved checking for &lt;code&gt;for..in&lt;/code&gt; statements</source>
          <target state="translated">&lt;code&gt;for..in&lt;/code&gt; 문 검사 개선</target>
        </trans-unit>
        <trans-unit id="c02cdcb0697c02f23de76b9402b3ffb5de18ea5a" translate="yes" xml:space="preserve">
          <source>Improved checking for destructuring object literal</source>
          <target state="translated">객체 리터럴 파괴 검사 개선</target>
        </trans-unit>
        <trans-unit id="55bbe6a04eaea70e8654bdf75776576f97a9d374" translate="yes" xml:space="preserve">
          <source>Improved control over mapped type modifiers</source>
          <target state="translated">매핑 된 유형 수정 자에 대한 향상된 제어</target>
        </trans-unit>
        <trans-unit id="be88c1fb8d146d0b9d876f22a0754323c60b7258" translate="yes" xml:space="preserve">
          <source>Improved excess property checks in union types</source>
          <target state="translated">공용체 유형에서 초과 속성 점검 개선</target>
        </trans-unit>
        <trans-unit id="f0d6c8d205edfb92cb01f19342a7ad56a1cfd004" translate="yes" xml:space="preserve">
          <source>Improved handling of structurally identical classes and &lt;code&gt;instanceof&lt;/code&gt; expressions</source>
          <target state="translated">구조적으로 동일한 클래스 및 표현식 &lt;code&gt;instanceof&lt;/code&gt; 처리 개선</target>
        </trans-unit>
        <trans-unit id="79046527e77a08d10c738b0d3678766e68083dfb" translate="yes" xml:space="preserve">
          <source>Improved inference for generics</source>
          <target state="translated">제네릭에 대한 향상된 추론</target>
        </trans-unit>
        <trans-unit id="9902b64afde9c77bb740ee885857e65ab81753ae" translate="yes" xml:space="preserve">
          <source>Improved support for &lt;code&gt;tsconfig.json&lt;/code&gt; in Visual Studio 2015</source>
          <target state="translated">Visual Studio 2015에서 &lt;code&gt;tsconfig.json&lt;/code&gt; 에 대한 지원 개선</target>
        </trans-unit>
        <trans-unit id="cc966416a9eb70b531ccdaadbbaafa22d9349454" translate="yes" xml:space="preserve">
          <source>Improved type inference for object literals</source>
          <target state="translated">객체 리터럴에 대한 형식 유추 개선</target>
        </trans-unit>
        <trans-unit id="b87ca7b1554d820cbb558e72b3dc2dd9bb2048e0" translate="yes" xml:space="preserve">
          <source>Improved union/intersection type inference</source>
          <target state="translated">통합 / 교차 유형 추론 개선</target>
        </trans-unit>
        <trans-unit id="73d903d34db6a7a7623b02e31683adc136bd1806" translate="yes" xml:space="preserve">
          <source>Improvements for &lt;code&gt;ReadonlyArray&lt;/code&gt; and &lt;code&gt;readonly&lt;/code&gt; tuples</source>
          <target state="translated">&lt;code&gt;ReadonlyArray&lt;/code&gt; 및 &lt;code&gt;readonly&lt;/code&gt; 튜플 개선</target>
        </trans-unit>
        <trans-unit id="75cc15f25fc2ae5d077c25f2e3c6ed80c124c408" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;templates&quot;&gt;Templates&lt;/a&gt; you&amp;rsquo;ll find a number of declaration files that serve as a useful starting point when writing a new file. Refer to the documentation in &lt;a href=&quot;library-structures&quot;&gt;Library Structures&lt;/a&gt; to figure out which template file to use.</source>
          <target state="translated">에서 &lt;a href=&quot;templates&quot;&gt;템플릿&lt;/a&gt; 새 파일을 작성할 때 유용한 시작점 역할을 선언 파일의 번호를 찾을 수 있습니다. 사용할 템플릿 파일을 확인하려면 &lt;a href=&quot;library-structures&quot;&gt;라이브러리 구조&lt;/a&gt; 의 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="053ea35eb45b9803ab97bdc192cb5d0db843884b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, a &lt;code&gt;?&lt;/code&gt; modifier automatically includes &lt;code&gt;undefined&lt;/code&gt; in the element type, similar to optional parameters.</source>
          <target state="translated">에서 &lt;code&gt;--strictNullChecks&lt;/code&gt; 의 모드, &lt;code&gt;?&lt;/code&gt; 수정자는 선택적 매개 변수와 유사하게 요소 유형에 &lt;code&gt;undefined&lt;/code&gt; 자동으로 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="c75d3751acc8527d062926da04731cafe2436c23" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;getProperty&lt;/code&gt;, &lt;code&gt;o: T&lt;/code&gt; and &lt;code&gt;propertyName: K&lt;/code&gt;, so that means &lt;code&gt;o[propertyName]: T[K]&lt;/code&gt;. Once you return the &lt;code&gt;T[K]&lt;/code&gt; result, the compiler will instantiate the actual type of the key, so the return type of &lt;code&gt;getProperty&lt;/code&gt; will vary according to which property you request.</source>
          <target state="translated">에서는 &lt;code&gt;getProperty&lt;/code&gt; 에 , &lt;code&gt;o: T&lt;/code&gt; 및 &lt;code&gt;propertyName: K&lt;/code&gt; , 그래서 수단 &lt;code&gt;o[propertyName]: T[K]&lt;/code&gt; . &lt;code&gt;T[K]&lt;/code&gt; 결과 를 반환하면 컴파일러는 키의 실제 유형을 인스턴스화하므로 &lt;code&gt;getProperty&lt;/code&gt; 의 반환 유형은 요청한 속성에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="cac8a395d23bb271c0a5b1d7324f422027c11b0c" translate="yes" xml:space="preserve">
          <source>In ES2015, constructors which return an object implicitly substitute the value of &lt;code&gt;this&lt;/code&gt; for any callers of &lt;code&gt;super()&lt;/code&gt;. As a result, it is necessary to capture any potential return value of &lt;code&gt;super()&lt;/code&gt; and replace it with &lt;code&gt;this&lt;/code&gt;. This change enables working with &lt;a href=&quot;https://w3c.github.io/webcomponents/spec/custom/#htmlelement-constructor&quot;&gt;Custom Elements&lt;/a&gt;, which takes advantage of this to initialize browser-allocated elements with user-written constructors.</source>
          <target state="translated">ES2015에서 객체를 반환 생성자 암시 값 대신 &lt;code&gt;this&lt;/code&gt; 어느 호출자 &lt;code&gt;super()&lt;/code&gt; . 결과적으로, 잠재적 인 &lt;code&gt;super()&lt;/code&gt; 의 리턴 값을 캡처 하여이를 &lt;code&gt;this&lt;/code&gt; 로 대체해야 합니다 . 이 변경으로 &lt;a href=&quot;https://w3c.github.io/webcomponents/spec/custom/#htmlelement-constructor&quot;&gt;사용자 정의 요소&lt;/a&gt; 작업이 가능해 지며,이를 통해 사용자 작성 생성자로 브라우저 할당 요소를 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="367fc6bebb59a7cbd1d7db58cf0d02857ed175b8" translate="yes" xml:space="preserve">
          <source>In ES6 module loaders, the top-level object (here imported as &lt;code&gt;exp&lt;/code&gt;) can only have properties; the top-level module object is &lt;em&gt;never&lt;/em&gt; callable. The most common solution here is to define a &lt;code&gt;default&lt;/code&gt; export for a callable/constructable object; some module loader shims will automatically detect this situation and replace the top-level object with the &lt;code&gt;default&lt;/code&gt; export.</source>
          <target state="translated">ES6 모듈 로더에서 최상위 레벨 오브젝트 (여기서 &lt;code&gt;exp&lt;/code&gt; 로 가져 오기 )는 특성 만 가질 수 있습니다. 최상위 모듈 객체는 호출 할 수 &lt;em&gt;없습니다&lt;/em&gt; . 여기서 가장 일반적인 해결책 은 호출 가능 / 구성 가능 오브젝트에 대한 &lt;code&gt;default&lt;/code&gt; 내보내기 를 정의하는 것입니다. 일부 모듈 로더 shim은이 상황을 자동으로 감지하여 최상위 수준 개체를 &lt;code&gt;default&lt;/code&gt; 내보내기로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="f9178ac7270dcc05dceadc49b3f02c9dc7dcbddb" translate="yes" xml:space="preserve">
          <source>In Edge, press F12 and click the Debugger tab.</source>
          <target state="translated">Edge에서 F12를 누르고 디버거 탭을 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="54dc2fcbcb0f1f6b32f8968730c12d2717aff252" translate="yes" xml:space="preserve">
          <source>In JSDoc references</source>
          <target state="translated">JSDoc 참조에서</target>
        </trans-unit>
        <trans-unit id="6fdb267749a0a65e58ebbcd5a8e1c2849232fca7" translate="yes" xml:space="preserve">
          <source>In JavaScript it is fairly common to have APIs that expect property names as parameters, but so far it hasn&amp;rsquo;t been possible to express the type relationships that occur in those APIs.</source>
          <target state="translated">JavaScript에서는 속성 이름을 매개 변수로 사용하는 API를 사용하는 것이 일반적이지만 지금까지 이러한 API에서 발생하는 형식 관계를 표현할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="9d68eb64db15f82423559857fcf4d5a5356cdcf0" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;code&gt;this&lt;/code&gt; is a variable that&amp;rsquo;s set when a function is called. This makes it a very powerful and flexible feature, but it comes at the cost of always having to know about the context that a function is executing in. This is notoriously confusing, especially when returning a function or passing a function as an argument.</source>
          <target state="translated">JavaScript에서 &lt;code&gt;this&lt;/code&gt; 함수가 호출 될 때 설정되는 변수입니다. 이는 매우 강력하고 유연한 기능이지만, 함수가 실행되는 컨텍스트에 대해 항상 알아야하는 비용이 발생합니다. 특히 함수를 리턴하거나 함수를 인수로 전달할 때 혼동을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="484bfab743be72776c5e3700ec9d551efe4c463b" translate="yes" xml:space="preserve">
          <source>In JavaScript, &lt;code&gt;var&lt;/code&gt; declarations are &amp;ldquo;hoisted&amp;rdquo; to the top of their enclosing scope. This can result in confusing bugs:</source>
          <target state="translated">JavaScript에서 &lt;code&gt;var&lt;/code&gt; 선언은 포함 범위의 맨 위에 &quot;게양&quot;됩니다. 이로 인해 혼란스러운 버그가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a721d5f467ada10610bec48c19e76c798ba0faad" translate="yes" xml:space="preserve">
          <source>In JavaScript, every parameter is optional, and users may leave them off as they see fit. When they do, their value is &lt;code&gt;undefined&lt;/code&gt;. We can get this functionality in TypeScript by adding a &lt;code&gt;?&lt;/code&gt; to the end of parameters we want to be optional. For example, let&amp;rsquo;s say we want the last name parameter from above to be optional:</source>
          <target state="translated">JavaScript에서 모든 매개 변수는 선택 사항이며 사용자는 원하는대로 매개 변수를 그대로 둘 수 있습니다. 그들이 할 때, 그들의 가치는 &lt;code&gt;undefined&lt;/code&gt; . &lt;code&gt;?&lt;/code&gt; 를 추가하면 TypeScript에서이 기능을 사용할 수 있습니다 . 매개 변수의 끝까지 우리는 선택 사항이되고 싶습니다. 예를 들어 위에서 성 매개 변수를 선택적으로 사용한다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="cd949f14dcd3d1c680cfa42bdf9a32c9f564e9cb" translate="yes" xml:space="preserve">
          <source>In Node.js, most tasks are accomplished by loading one or more modules. We could define each module in its own &lt;code&gt;.d.ts&lt;/code&gt; file with top-level export declarations, but it&amp;rsquo;s more convenient to write them as one larger &lt;code&gt;.d.ts&lt;/code&gt; file. To do so, we use a construct similar to ambient namespaces, but we use the &lt;code&gt;module&lt;/code&gt; keyword and the quoted name of the module which will be available to a later import. For example:</source>
          <target state="translated">Node.js에서 대부분의 작업은 하나 이상의 모듈을로드하여 수행됩니다. 최상위 내보내기 선언 을 사용하여 각 모듈을 자체 &lt;code&gt;.d.ts&lt;/code&gt; 파일로 정의 할 수 있지만 더 큰 &lt;code&gt;.d.ts&lt;/code&gt; 파일 로 작성하는 것이 더 편리 합니다. 이를 위해 앰비언트 네임 스페이스와 유사한 구성을 사용하지만 나중에 가져올 수 있는 &lt;code&gt;module&lt;/code&gt; 키워드와 따옴표 붙은 이름을 사용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a8e105ae7200ecea675173edd80960ba967b794" translate="yes" xml:space="preserve">
          <source>In TypeScript 1.4, we added support for template strings for all targets, and tagged templates for just ES6. Thanks to some considerable work done by &lt;a href=&quot;https://github.com/ivogabe&quot;&gt;@ivogabe&lt;/a&gt;, we bridged the gap for for tagged templates in ES3 and ES5.</source>
          <target state="translated">TypeScript 1.4에서는 모든 대상에 대한 템플릿 문자열에 대한 지원이 추가되었으며 ES6에 대해서만 태그가 지정된 템플릿이 추가되었습니다. &lt;a href=&quot;https://github.com/ivogabe&quot;&gt;@ivogabe가&lt;/a&gt; 수행 한 상당한 작업 덕분 에 ES3 및 ES5에서 태그가 지정된 템플릿의 격차를 해소했습니다.</target>
        </trans-unit>
        <trans-unit id="c136c2bbed32677bb7335ad748e3d5ef230b3921" translate="yes" xml:space="preserve">
          <source>In TypeScript 1.8 with the latest version of react.d.ts (see above), we&amp;rsquo;ve also greatly simplified the declaration of &lt;code&gt;props&lt;/code&gt; types.</source>
          <target state="translated">최신 버전의 react.d.ts (위 참조)가있는 TypeScript 1.8에서는 &lt;code&gt;props&lt;/code&gt; 유형 의 선언을 크게 단순화했습니다 .</target>
        </trans-unit>
        <trans-unit id="51239dcf9cd000d42b9c40712065d5e3ac4e06b5" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.0, it has become significantly easier to consume declaration files, in acquiring, using, and finding them. This page details exactly how to do all three.</source>
          <target state="translated">TypeScript 2.0에서는 선언 파일을 가져 와서 사용하고 찾는 데있어 선언 파일을 사용하는 것이 훨씬 쉬워졌습니다. 이 페이지는 세 가지 방법을 모두 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="280fed62c426cb333df0ac98e6eabc689470726c" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.3, TS introduced type checking of &lt;em&gt;children&lt;/em&gt;. &lt;em&gt;children&lt;/em&gt; is a special property in an &lt;em&gt;element attributes type&lt;/em&gt; where child &lt;em&gt;JSXExpression&lt;/em&gt;s are taken to be inserted into the attributes. Similar to how TS uses &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; to determine the name of &lt;em&gt;props&lt;/em&gt;, TS uses &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; to determine the name of &lt;em&gt;children&lt;/em&gt; within those props. &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; should be declared with a single property.</source>
          <target state="translated">TypeScript 2.3에서 TS는 &lt;em&gt;하위&lt;/em&gt; 유형 검사를 도입했습니다 . &lt;em&gt;children&lt;/em&gt; 은 자식 &lt;em&gt;JSXExpression&lt;/em&gt; 이 속성에 삽입 되는 &lt;em&gt;요소 속성 유형&lt;/em&gt; 의 특수 속성입니다 . TS는 사용하는 방법과 유사 &lt;code&gt;JSX.ElementAttributesProperty&lt;/code&gt; 을 의 이름을 결정하기 위해 &lt;em&gt;소품&lt;/em&gt; , TS는 사용 &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; 을 의 이름을 결정하기 위해 &lt;em&gt;어린이&lt;/em&gt; 들 소품 이내입니다. &lt;code&gt;JSX.ElementChildrenAttribute&lt;/code&gt; 는 단일 속성으로 선언해야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="21bf9c2a83b6910226d6caf86b85a5fe927e4d3f" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.4, it&amp;rsquo;s now an error to assign anything to a weak type when there&amp;rsquo;s no overlap in properties. For example:</source>
          <target state="translated">TypeScript 2.4에서는 속성이 겹치지 않으면 약한 유형에 아무것도 할당하지 않는 것이 오류입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0d04812c896e54873be22b5061fb98c356d962e4" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.4, the function on the right side implicitly &lt;em&gt;gains&lt;/em&gt; type parameters, and &lt;code&gt;y&lt;/code&gt; is inferred to have the type of that type-parameter.</source>
          <target state="translated">TypeScript 2.4에서 오른쪽의 함수는 암시 적으로 형식 매개 변수를 &lt;em&gt;얻으며 &lt;/em&gt; &lt;code&gt;y&lt;/code&gt; 는 해당 형식 매개 변수의 형식을 갖는 것으로 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="fcec71f6bd5ce7d77407d547d676e3be6ddf7295" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.6 and earlier, &lt;code&gt;[number, string, string]&lt;/code&gt; was considered a subtype of &lt;code&gt;[number, string]&lt;/code&gt;. This was motivated by TypeScript&amp;rsquo;s structural nature; the first and second elements of a &lt;code&gt;[number, string, string]&lt;/code&gt; are respectively subtypes of the first and second elements of &lt;code&gt;[number, string]&lt;/code&gt;. However, after examining real world usage of tuples, we noticed that most situations in which this was permitted was typically undesirable.</source>
          <target state="translated">TypeScript 2.6 및 이전 버전에서 &lt;code&gt;[number, string, string]&lt;/code&gt; 은 &lt;code&gt;[number, string]&lt;/code&gt; 의 하위 유형으로 간주되었습니다 . 이것은 TypeScript의 구조적 특성에 의해 동기가 부여되었습니다. (A)의 제 1 및 제 2 요소 &lt;code&gt;[number, string, string]&lt;/code&gt; 각각의 제 1 및 제 2 요소의 서브 타입이다 &lt;code&gt;[number, string]&lt;/code&gt; . 그러나 실제 튜플 사용을 조사한 결과, 이것이 허용 된 대부분의 상황이 일반적으로 바람직하지 않다는 것을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="649188580014293e883a71ef51c9fad716c1836d" translate="yes" xml:space="preserve">
          <source>In TypeScript 2.7, tuples of different arities are no longer assignable to each other. Thanks to a pull request from &lt;a href=&quot;https://github.com/tycho01&quot;&gt;Tycho Grouwstra&lt;/a&gt;, tuple types now encode their arity into the type of their respective &lt;code&gt;length&lt;/code&gt; property. This is accomplished by leveraging numeric literal types, which now allow tuples to be distinct from tuples of different arities.</source>
          <target state="translated">TypeScript 2.7에서는 다른 속성의 튜플을 더 이상 서로 할당 할 수 없습니다. &lt;a href=&quot;https://github.com/tycho01&quot;&gt;Tycho Grouwstra&lt;/a&gt; 의 풀 요청 덕분에 이제 튜플 유형은 해당 &lt;code&gt;length&lt;/code&gt; 속성 의 유형으로 arity를 ​​인코딩 합니다. 이는 숫자 리터럴 유형을 활용하여 튜플을 다른 인종의 튜플과 구별 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="e924e834ba371b237a2fd89703ad1fd92c349cc6" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.1, mapped object types&lt;sup&gt;&lt;a href=&quot;#ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; over tuples and arrays now produce new tuples/arrays, rather than creating a new type where members like &lt;code&gt;push()&lt;/code&gt;, &lt;code&gt;pop()&lt;/code&gt;, and &lt;code&gt;length&lt;/code&gt; are converted. For example:</source>
          <target state="translated">TypeScript 3.1에서 튜플과 배열에 대한 매핑 된 객체 유형 &lt;sup&gt;&lt;a href=&quot;#ts-3-1-only-homomorphic&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; 은 이제 &lt;code&gt;push()&lt;/code&gt; , &lt;code&gt;pop()&lt;/code&gt; 및 &lt;code&gt;length&lt;/code&gt; 같은 멤버 가 변환 되는 새 유형을 만드는 대신 새로운 튜플 / 배열을 생성합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="39f9c3f02fd56ead96678ac1ba450ac3cd68bf5e" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.2, object literals now allow generic spread expressions which now produce intersection types, similar to the &lt;code&gt;Object.assign&lt;/code&gt; function and JSX literals. For example:</source>
          <target state="translated">TypeScript 3.2에서 객체 리터럴은 이제 &lt;code&gt;Object.assign&lt;/code&gt; 함수 및 JSX 리터럴과 유사한 교차 유형을 생성하는 일반 스프레드 식을 허용 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b164e3a6dff9d3898d7cd8f7babad021ca8339a" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, &lt;code&gt;--build&lt;/code&gt; mode&amp;rsquo;s &lt;code&gt;--watch&lt;/code&gt; flag &lt;em&gt;does&lt;/em&gt; leverage incremental file watching as well. That can mean signficantly faster builds under &lt;code&gt;--build --watch&lt;/code&gt;. In our testing, this functionality has resulted in &lt;strong&gt;a reduction of 50% to 75% in build times&lt;/strong&gt; of the original &lt;code&gt;--build --watch&lt;/code&gt; times. &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29161&quot;&gt;You can read more on the original pull request for the change&lt;/a&gt; to see specific numbers, but we believe most composite project users will see significant wins here.</source>
          <target state="translated">TypeScript 3.3에서 &lt;code&gt;--build&lt;/code&gt; 모드의 &lt;code&gt;--watch&lt;/code&gt; 플래그 &lt;em&gt;는&lt;/em&gt; 증분 파일 감시도 활용합니다. 즉 &lt;code&gt;--build --watch&lt;/code&gt; 에서 빌드가 훨씬 빨라질 수 있습니다 . 테스트에서이 기능은 원래 &lt;code&gt;--build --watch&lt;/code&gt; 시간 의 &lt;strong&gt;빌드 시간&lt;/strong&gt; 을 &lt;strong&gt;50 %에서 75 %까지 &lt;/strong&gt;줄였습니다 . 특정 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/29161&quot;&gt;풀을보기 위해 변경에 대한 원래 풀 요청에 대한 자세한 내용을 읽을 수&lt;/a&gt; 있지만 대부분의 복합 프로젝트 사용자는 여기에서 상당한 승리를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ff72425a74a94e8f866efe98b24a9a23e691d20" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, the parameters of these signatures are &lt;em&gt;intersected&lt;/em&gt; together to create a new signature.</source>
          <target state="translated">TypeScript 3.3에서는 이러한 서명의 매개 변수가 서로 &lt;em&gt;교차&lt;/em&gt; 하여 새 서명을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a91f7b680f1b740f03303f6aa85f432e9ad8efa8" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.3, this is no longer an error.</source>
          <target state="translated">TypeScript 3.3에서는 더 이상 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5341077b6a3de5130003da3230dc62974ee76806" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4 and earlier, certain excess properties were allowed in situations where they really shouldn&amp;rsquo;t have been. For instance, TypeScript 3.4 permitted the incorrect &lt;code&gt;name&lt;/code&gt; property in the object literal even though its types don&amp;rsquo;t match between &lt;code&gt;Point&lt;/code&gt; and &lt;code&gt;Label&lt;/code&gt;.</source>
          <target state="translated">TypeScript 3.4 및 이전 버전에서는 실제로 초과해서는 안되는 상황에서 특정 초과 속성이 허용되었습니다. 예를 들어, 타이프 3.4 잘못된 허용 된 &lt;code&gt;name&lt;/code&gt; 의 유형 사이에 일치하지 않는 경우에도 객체 리터럴 재산 &lt;code&gt;Point&lt;/code&gt; 와 &lt;code&gt;Label&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb163ddc0e2f8f1dc49a15fee6ec555fb1d31fba" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4 and prior, the following example would fail:</source>
          <target state="translated">TypeScript 3.4 및 이전 버전에서는 다음 예제가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="09356337029d3d047ed37351c9cbc0dd0318ec54" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4, the &lt;code&gt;readonly&lt;/code&gt; modifier in a mapped type will automatically convert array-like types to their corresponding &lt;code&gt;readonly&lt;/code&gt; counterparts.</source>
          <target state="translated">TypeScript 3.4 에서 매핑 된 형식 의 &lt;code&gt;readonly&lt;/code&gt; 수정자는 배열과 같은 형식을 해당 &lt;code&gt;readonly&lt;/code&gt; 형식으로 자동 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="e962c6d8bea6e7e5e00083a65a632b1e6809958d" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.4, we improved inference for when generic functions that return functions like so:</source>
          <target state="translated">TypeScript 3.4에서는 다음과 같이 함수를 반환하는 일반 함수에 대한 추론이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="8398d8557226d4dcf61ef0d2d8e32afa0789a488" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, the type-checker at least verifies that all the provided properties belong to &lt;em&gt;some&lt;/em&gt; union member and have the appropriate type, meaning that the sample above correctly issues an error.</source>
          <target state="translated">TypeScript 3.5에서 형식 검사기는 적어도 제공된 모든 속성이 &lt;em&gt;일부&lt;/em&gt; 공용체 멤버에 속 하고 적절한 형식을 가지고 있는지 확인합니다. 즉, 위의 샘플에서 오류가 올바르게 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6bd78304e8ab95ec78b59e840c5e6980b10bd2ff" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, when assigning to types with discriminant properties like in &lt;code&gt;T&lt;/code&gt;, the language actually &lt;em&gt;will&lt;/em&gt; go further and decompose types like &lt;code&gt;S&lt;/code&gt; into a union of every possible inhabitant type. In this case, since &lt;code&gt;boolean&lt;/code&gt; is a union of &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt; will be viewed as a union of &lt;code&gt;{ done: false, value: number }&lt;/code&gt; and &lt;code&gt;{ done: true, value: number }&lt;/code&gt;.</source>
          <target state="translated">TypeScript 3.5에서는 &lt;code&gt;T&lt;/code&gt; 와 같이 구별 속성이있는 유형에 할당 할 때 실제로 언어 &lt;em&gt;는 &lt;/em&gt; &lt;code&gt;S&lt;/code&gt; 와 같은 유형을 가능한 모든 거주 유형의 결합으로 분해 합니다. 이 경우 &lt;code&gt;boolean&lt;/code&gt; 은 &lt;code&gt;true&lt;/code&gt; 와 &lt;code&gt;false&lt;/code&gt; 의 결합 이므로 &lt;code&gt;S&lt;/code&gt; 는 &lt;code&gt;{ done: false, value: number }&lt;/code&gt; 및 &lt;code&gt;{ done: true, value: number }&lt;/code&gt; 의 결합으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="d94a96c27cb9468cb91f9314627e1075ad63df4c" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.5, you can now reference UMD global declarations like</source>
          <target state="translated">TypeScript 3.5에서는 다음과 같은 UMD 전역 선언을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebce4ccb31849685f27f521710646fdd135799f4" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.6, the checker now knows that the correct type for &lt;code&gt;curr.value&lt;/code&gt; should be &lt;code&gt;string&lt;/code&gt; in our first example, and will correctly error on our call to &lt;code&gt;next()&lt;/code&gt; in our last example. This is thanks to some changes in the &lt;code&gt;Iterator&lt;/code&gt; and &lt;code&gt;IteratorResult&lt;/code&gt; type declarations to include a few new type parameters, and to a new type that TypeScript uses to represent generators called the &lt;code&gt;Generator&lt;/code&gt; type.</source>
          <target state="translated">TypeScript 3.6에서 검사기는 이제 첫 번째 예제에서 &lt;code&gt;curr.value&lt;/code&gt; 의 올바른 유형 이 &lt;code&gt;string&lt;/code&gt; 이어야한다는 것을 알고 있으며 마지막 예제에서 &lt;code&gt;next()&lt;/code&gt; 를 호출 할 때 올바르게 오류가 발생합니다 . 이는 몇 가지 새로운 유형 매개 변수를 포함 하도록 &lt;code&gt;Iterator&lt;/code&gt; 및 &lt;code&gt;IteratorResult&lt;/code&gt; 유형 선언 의 일부 변경 사항 과 TypeScript가 &lt;code&gt;Generator&lt;/code&gt; 유형 이라는 생성기를 나타내는 데 사용하는 새로운 유형 덕분 입니다.</target>
        </trans-unit>
        <trans-unit id="0905562c8006d5cf59d0f711433ed32656adf580" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31231&quot;&gt;this is now correctly identified as a duplicate identifier error&lt;/a&gt;. The correct fix depends on the original intent of the author and should be addressed on a case-by-case basis. Usually, the naming conflict is unintentional and the best fix is to rename the imported type. If the intent was to augment the imported type, a proper module augmentation should be written instead.</source>
          <target state="translated">TypeScript 3.7에서는 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/31231&quot;&gt;이제 중복 식별자 오류로 올바르게 식별됩니다&lt;/a&gt; . 올바른 수정은 작성자의 원래 의도에 따라 다르며 사례별로 해결해야합니다. 일반적으로 명명 충돌은 의도하지 않은 것이며 가장 좋은 방법은 가져온 유형의 이름을 바꾸는 것입니다. 가져온 유형을 기능 보강하려는 경우 대신 적절한 모듈 기능 보강을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d966bc481353f4c45fe41960daf87445589baab" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, the compiler itself will take advantage of this feature so that generated &lt;code&gt;.d.ts&lt;/code&gt; files will also emit &lt;code&gt;get&lt;/code&gt;/&lt;code&gt;set&lt;/code&gt; accessors.</source>
          <target state="translated">TypeScript 3.7에서는 컴파일러 자체가이 기능을 활용하므로 생성 된 &lt;code&gt;.d.ts&lt;/code&gt; 파일도 &lt;code&gt;get&lt;/code&gt; / &lt;code&gt;set&lt;/code&gt; 접근 자를 방출 합니다.</target>
        </trans-unit>
        <trans-unit id="867e1064d30d0ee6d5ae66e30b7de9d7c76047ce" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, the compiler will take advantage of this feature so that &lt;code&gt;.d.ts&lt;/code&gt; files generated from &lt;code&gt;.js&lt;/code&gt; files can appropriately capture both the callability and constructability of a class-like function.</source>
          <target state="translated">TypeScript 3.7에서 컴파일러는이 기능을 활용 하여 &lt;code&gt;.js&lt;/code&gt; 파일 에서 생성 된 &lt;code&gt;.d.ts&lt;/code&gt; 파일 이 클래스와 유사한 함수의 호출 가능성과 구성 가능성을 적절히 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12c564a00c60c29478392ba0894da5e9c08182a8" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, this is identified as a likely error:</source>
          <target state="translated">TypeScript 3.7에서 이는 가능한 오류로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="4164a94a4712ff430d4d9a46e1e26ed5ff082a55" translate="yes" xml:space="preserve">
          <source>In TypeScript 3.7, when opening a project with dependencies, TypeScript will automatically use the source &lt;code&gt;.ts&lt;/code&gt;/&lt;code&gt;.tsx&lt;/code&gt; files instead. This means projects using project references will now see an improved editing experience where semantic operations are up-to-date and &amp;ldquo;just work&amp;rdquo;. You can disable this behavior with the compiler option &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt; which may be appropriate when working in very large projects where this change may impact editing performance.</source>
          <target state="translated">TypeScript 3.7에서는 종속성이있는 프로젝트를 열 때 TypeScript가 자동으로 소스 &lt;code&gt;.ts&lt;/code&gt; / &lt;code&gt;.tsx&lt;/code&gt; 파일을 사용합니다. 즉, 프로젝트 참조를 사용하는 프로젝트는 시맨틱 작업이 최신 상태이고 &quot;정상적으로 작동하는&quot;향상된 편집 환경을 볼 수 있습니다. 컴파일러 옵션 &lt;code&gt;disableSourceOfProjectReferenceRedirect&lt;/code&gt; 를 사용하여이 동작을 비활성화 할 수 있습니다.이 변경은이 변경이 편집 성능에 영향을 줄 수있는 매우 큰 프로젝트에서 작업 할 때 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38698da453e7ee13579d517a8684b98de7bc1513" translate="yes" xml:space="preserve">
          <source>In TypeScript or ES6, the &lt;code&gt;import&lt;/code&gt; keyword serves the same purpose:</source>
          <target state="translated">TypeScript 또는 ES6에서 &lt;code&gt;import&lt;/code&gt; 키워드는 동일한 용도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="82d214ccb1ea5cf33bc755b464edc62ce95d4e1d" translate="yes" xml:space="preserve">
          <source>In TypeScript, a declaration creates entities in at least one of three groups: namespace, type, or value. Namespace-creating declarations create a namespace, which contains names that are accessed using a dotted notation. Type-creating declarations do just that: they create a type that is visible with the declared shape and bound to the given name. Lastly, value-creating declarations create values that are visible in the output JavaScript.</source>
          <target state="translated">TypeScript에서 선언은 네임 스페이스, 유형 또는 값의 세 그룹 중 하나 이상에 엔터티를 만듭니다. 네임 스페이스 생성 선언은 점으로 구분 된 표기법을 사용하여 액세스하는 이름이 포함 된 네임 스페이스를 만듭니다. 형식 작성 선언은 다음과 같이합니다. 선언 된 모양으로 표시되고 지정된 이름에 바인딩 된 형식을 만듭니다. 마지막으로, 가치 창출 선언은 출력 JavaScript에서 볼 수있는 값을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f59c1f1ad017a0e2538bcd6ec781579714841dc0" translate="yes" xml:space="preserve">
          <source>In TypeScript, both &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; actually have their own types named &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;null&lt;/code&gt; respectively. Much like &lt;code&gt;void&lt;/code&gt;, they&amp;rsquo;re not extremely useful on their own:</source>
          <target state="translated">TypeScript에서 &lt;code&gt;undefined&lt;/code&gt; 와 &lt;code&gt;null&lt;/code&gt; 은 실제로 각각 &lt;code&gt;undefined&lt;/code&gt; 와 &lt;code&gt;null&lt;/code&gt; 이라는 자체 유형을 갖습니다 . &lt;code&gt;void&lt;/code&gt; 와 마찬가지로 , 자체적으로 매우 유용하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1389ac175cd87f93511a411a3c43d05c85ede09" translate="yes" xml:space="preserve">
          <source>In TypeScript, every parameter is assumed to be required by the function. This doesn&amp;rsquo;t mean that it can&amp;rsquo;t be given &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, but rather, when the function is called, the compiler will check that the user has provided a value for each parameter. The compiler also assumes that these parameters are the only parameters that will be passed to the function. In short, the number of arguments given to a function has to match the number of parameters the function expects.</source>
          <target state="translated">TypeScript에서는 모든 매개 변수가 함수에 필요하다고 가정합니다. 이것은 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 를 지정할 수 없다는 것을 의미하는 것이 아니라 함수가 호출 될 때 사용자가 각 매개 변수에 대한 값을 제공했는지 확인합니다. 또한 컴파일러는 이러한 매개 변수가 함수에 전달 될 유일한 매개 변수라고 가정합니다. 간단히 말해서 함수에 주어진 인수의 수는 함수가 기대하는 매개 변수의 수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="a24475a2eada62cf03ff9dfea85139d779f1476f" translate="yes" xml:space="preserve">
          <source>In TypeScript, just as in ECMAScript 2015, any file containing a top-level &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; is considered a module. Conversely, a file without any top-level &lt;code&gt;import&lt;/code&gt; or &lt;code&gt;export&lt;/code&gt; declarations is treated as a script whose contents are available in the global scope (and therefore to modules as well).</source>
          <target state="translated">ECMAScript 2015에서와 마찬가지로 TypeScript에서는 최상위 &lt;code&gt;import&lt;/code&gt; 또는 &lt;code&gt;export&lt;/code&gt; 가 포함 된 모든 파일 이 모듈로 간주됩니다. 반대로 최상위 &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;export&lt;/code&gt; 선언이 없는 파일 은 전역 범위에서 모듈을 사용할 수있는 내용의 스크립트로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="1ed5374d91892c7ddbb0f4d810f43603226252a7" translate="yes" xml:space="preserve">
          <source>In TypeScript, there are several places where type inference is used to provide type information when there is no explicit type annotation. For example, in this code</source>
          <target state="translated">TypeScript에는 명시 적 형식 주석이 없을 때 형식 정보를 제공하기 위해 형식 유추가 사용되는 곳이 여러 곳 있습니다. 예를 들어이 코드에서</target>
        </trans-unit>
        <trans-unit id="ee7d94eb215257ba5c8ab795047cbaba376a919d" translate="yes" xml:space="preserve">
          <source>In TypeScript, we can also set a value that a parameter will be assigned if the user does not provide one, or if the user passes &lt;code&gt;undefined&lt;/code&gt; in its place. These are called default-initialized parameters. Let&amp;rsquo;s take the previous example and default the last name to &lt;code&gt;&quot;Smith&quot;&lt;/code&gt;.</source>
          <target state="translated">TypeScript에서는 사용자가 매개 변수를 제공하지 않거나 사용자가 대신 &lt;code&gt;undefined&lt;/code&gt; 로 전달하는 경우 매개 변수가 할당되는 값을 설정할 수도 있습니다 . 이를 기본 초기화 매개 변수라고합니다. 이전 예제를 취하고 성을 기본적으로 &lt;code&gt;&quot;Smith&quot;&lt;/code&gt; 로 하자 .</target>
        </trans-unit>
        <trans-unit id="9b2996a620036d35453f4c7abf1fb3f20ef36789" translate="yes" xml:space="preserve">
          <source>In TypeScript, we can use common object-oriented patterns. One of the most fundamental patterns in class-based programming is being able to extend existing classes to create new ones using inheritance.</source>
          <target state="translated">TypeScript에서는 일반적인 객체 지향 패턴을 사용할 수 있습니다. 클래스 기반 프로그래밍에서 가장 기본적인 패턴 중 하나는 상속을 사용하여 기존 클래스를 확장하여 새 클래스를 만들 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f733ba5e652ea7387ab081ac7b355a5f8b8f5005" translate="yes" xml:space="preserve">
          <source>In TypeScript, you can gather these arguments together into a variable:</source>
          <target state="translated">TypeScript에서는 이러한 인수를 변수로 모을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55204c277d20a924ef143d3605b8feaf73f1f390" translate="yes" xml:space="preserve">
          <source>In TypeScript, you can model this with the &lt;code&gt;export =&lt;/code&gt; construct.</source>
          <target state="translated">TypeScript에서는 &lt;code&gt;export =&lt;/code&gt; construct를 사용하여이를 모델링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82c14892013104e9e43fd9bdca12513d567a243f" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, Typescript understands the CommonJS module format. Assignments to &lt;code&gt;exports&lt;/code&gt; and &lt;code&gt;module.exports&lt;/code&gt; are recognized as export declarations. Similarly, &lt;code&gt;require&lt;/code&gt; function calls are recognized as module imports. For example:</source>
          <target state="translated">A의 &lt;code&gt;.js&lt;/code&gt; 파일, 타이프 라이터는 CommonJS 모듈 형식을 이해한다. &lt;code&gt;exports&lt;/code&gt; 및 &lt;code&gt;module.exports&lt;/code&gt; 에 대한 지정 은 내보내기 선언으로 인식됩니다. 이와 유사하게, &lt;code&gt;require&lt;/code&gt; 함수 호출이 모듈 수입으로 인식하고 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b54a4161a63a1b96ee32a30fced932fa18ccb0eb" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, the compiler infers properties from property assignments inside the class body. The type of a property is the type given in the constructor, unless it&amp;rsquo;s not defined there, or the type in the constructor is undefined or null. In that case, the type is the union of the types of all the right-hand values in these assignments. Properties defined in the constructor are always assumed to exist, whereas ones defined just in methods, getters, or setters are considered optional.</source>
          <target state="translated">A의 &lt;code&gt;.js&lt;/code&gt; 파일, 클래스 본문 내부의 속성 할당에서 컴파일러를 추론 속성. 속성의 유형은 정의되지 않았거나 생성자의 유형이 정의되지 않았거나 null이 아닌 한 생성자에 지정된 유형입니다. 이 경우 유형은 이러한 할당에서 모든 오른쪽 값 유형의 합집합입니다. 생성자에 정의 된 속성은 항상 존재하는 것으로 간주되는 반면 메서드, getter 또는 setter에 정의 된 속성은 선택 사항으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b1aec57e38f0bba34cdcf5755b6607c4fa3eaad1" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.js&lt;/code&gt; file, types can often be inferred just like in &lt;code&gt;.ts&lt;/code&gt; files. Likewise, when types can&amp;rsquo;t be inferred, they can be specified using JSDoc the same way that type annotations are used in a &lt;code&gt;.ts&lt;/code&gt; file. Just like Typescript, &lt;code&gt;--noImplicitAny&lt;/code&gt; will give you errors on the places that the compiler could not infer a type. (With the exception of open-ended object literals; see below for details.)</source>
          <target state="translated">A의 &lt;code&gt;.js&lt;/code&gt; 파일 형식은 종종 그냥 같이 추정 할 수있다 &lt;code&gt;.ts&lt;/code&gt; 파일입니다. 마찬가지로 형식을 유추 할 수없는 경우 형식 주석이 &lt;code&gt;.ts&lt;/code&gt; 파일 에서 사용되는 것과 같은 방식으로 JSDoc을 사용하여 형식을 지정할 수 있습니다 . Typescript와 &lt;code&gt;--noImplicitAny&lt;/code&gt; 는 컴파일러가 형식을 유추 할 수없는 곳에 오류를 제공합니다. (오픈 엔드 객체 리터럴을 제외하고 자세한 내용은 아래를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="499d42e07e1a5b7dd4bdd55bbff5c492132e6ecc" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;.ts&lt;/code&gt; file, an object literal that initializes a variable declaration gives its type to the declaration. No new members can be added that were not specified in the original literal. This rule is relaxed in a &lt;code&gt;.js&lt;/code&gt; file; object literals have an open-ended type (an index signature) that allows adding and looking up properties that were not defined originally. For instance:</source>
          <target state="translated">A의 &lt;code&gt;.ts&lt;/code&gt; 파일을 변수 선언을 초기화 객체 리터럴은 선언 유형을 제공한다. 원래 리터럴에 지정되지 않은 새 멤버를 추가 할 수 없습니다. 이 규칙은 &lt;code&gt;.js&lt;/code&gt; 파일 에서 완화 됩니다. 객체 리터럴에는 원래 정의되지 않은 속성을 추가하고 조회 할 수있는 개방형 형식 (인덱스 서명)이 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="faa28e2f1cd18a9e6940ea8f152a75b8bef80372" translate="yes" xml:space="preserve">
          <source>In a &lt;code&gt;for...in&lt;/code&gt; statement for an object of a generic type &lt;code&gt;T&lt;/code&gt;, the inferred type of the iteration variable was previously &lt;code&gt;keyof T&lt;/code&gt; but is now &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt;. (In other words, the subset of &lt;code&gt;keyof T&lt;/code&gt; that includes only string-like values.)</source>
          <target state="translated">a는에 &lt;code&gt;for...in&lt;/code&gt; 일반적인 유형의 개체에 대한 문 &lt;code&gt;T&lt;/code&gt; , 반복 변수의 추론 유형은 이전이었다 &lt;code&gt;keyof T&lt;/code&gt; 하지만 지금 &lt;code&gt;Extract&amp;lt;keyof T, string&amp;gt;&lt;/code&gt; . 즉, 문자열과 같은 값만 포함 하는 &lt;code&gt;keyof T&lt;/code&gt; 의 하위 집합입니다 .</target>
        </trans-unit>
        <trans-unit id="94a6c7abfee16098b91b6afd7d77f2cffbbb0188" translate="yes" xml:space="preserve">
          <source>In a function expression or arrow function with no return type annotation, if the function has no &lt;code&gt;return&lt;/code&gt; statements, or only &lt;code&gt;return&lt;/code&gt; statements with expressions of type &lt;code&gt;never&lt;/code&gt;, and if the end point of the function is not reachable (as determined by control flow analysis), the inferred return type for the function is &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">리턴 유형 어노테이션이없는 함수 표현식 또는 화살표 함수에서 함수에 &lt;code&gt;return&lt;/code&gt; 명령문이 없거나 &lt;code&gt;never&lt;/code&gt; 유형 표현식이있는 &lt;code&gt;return&lt;/code&gt; 명령문 만 있고 함수의 끝점에 도달 할 수없는 경우 (제어 플로우 분석에 의해 결정됨) 함수에 대한 유추 된 반환 유형은 &lt;code&gt;never&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a98314a0bada662b45a18394f388ee15a3db9842" translate="yes" xml:space="preserve">
          <source>In a function with an explicit &lt;code&gt;never&lt;/code&gt; return type annotation, all &lt;code&gt;return&lt;/code&gt; statements (if any) must have expressions of type &lt;code&gt;never&lt;/code&gt; and the end point of the function must not be reachable.</source>
          <target state="translated">명시 적으로 함수에서 &lt;code&gt;never&lt;/code&gt; 반환 유형 약어, 모든 &lt;code&gt;return&lt;/code&gt; 문 (있는 경우) 형태의 표현이 없어야합니다 &lt;code&gt;never&lt;/code&gt; 및 함수의 끝 지점에 도달 할 수 없습니다해야합니다.</target>
        </trans-unit>
        <trans-unit id="f21005b5571e17a92c2f4c810bdd49f11c28d379" translate="yes" xml:space="preserve">
          <source>In a mapped type &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt;, each string literal type in &lt;code&gt;K&lt;/code&gt; introduces a property with a string name, each numeric literal type in &lt;code&gt;K&lt;/code&gt; introduces a property with a numeric name, and each unique symbol type in &lt;code&gt;K&lt;/code&gt; introduces a property with a unique symbol name. Furthermore, if &lt;code&gt;K&lt;/code&gt; includes type &lt;code&gt;string&lt;/code&gt;, a string index signature is introduced, and if &lt;code&gt;K&lt;/code&gt; includes type &lt;code&gt;number&lt;/code&gt;, a numeric index signature is introduced.</source>
          <target state="translated">매핑 된 형태 &lt;code&gt;{ [P in K]: XXX }&lt;/code&gt; , 각 캐릭터 문자 타입 &lt;code&gt;K&lt;/code&gt; 는 문자열 이름의 속성은, 각각의 숫자 문자 유형 도입 &lt;code&gt;K&lt;/code&gt; 가 있는 숫자 이름의 속성, 각각 고유 심볼 유형 도입 &lt;code&gt;K&lt;/code&gt; 의 소개를 고유 한 심볼 이름을 가진 속성 또한 &lt;code&gt;K&lt;/code&gt; 에 &lt;code&gt;string&lt;/code&gt; 유형이 포함 되면 문자열 인덱스 서명이 도입되고 &lt;code&gt;K&lt;/code&gt; 에 유형 &lt;code&gt;number&lt;/code&gt; 포함 되면 숫자 인덱스 서명이 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="c902ce3f09f34d229a3e2897a358abb3f93aff0a" translate="yes" xml:space="preserve">
          <source>In a sense, the definite assignment assertion operator is the dual of the non-null assertion operator (in which &lt;em&gt;expressions&lt;/em&gt; are post-fixed with a &lt;code&gt;!&lt;/code&gt;), which we could also have used in the example.</source>
          <target state="translated">어떤 의미에서, 명확한 할당 어설 션 연산자는 null이 아닌 어설 션 연산자 ( &lt;em&gt;표현식&lt;/em&gt; 에 &lt;code&gt;!&lt;/code&gt; 로 포스트 고정 되는)의 이중이며, 이 예제에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51dd880d34f252e0aeb77f1d88f4eba9a15ee3cc" translate="yes" xml:space="preserve">
          <source>In a similar example, we may want to move the generic parameter to be a parameter of the whole interface. This lets us see what type(s) we&amp;rsquo;re generic over (e.g. &lt;code&gt;Dictionary&amp;lt;string&amp;gt;&lt;/code&gt; rather than just &lt;code&gt;Dictionary&lt;/code&gt;). This makes the type parameter visible to all the other members of the interface.</source>
          <target state="translated">비슷한 예에서 일반 매개 변수를 전체 인터페이스의 매개 변수로 이동하려고 할 수 있습니다. 이것은 우리가 어떤 종류의 (들) 우린 일반적인 이상 (예를 들어 볼 수 있습니다 &lt;code&gt;Dictionary&amp;lt;string&amp;gt;&lt;/code&gt; 이 아니라 단지보다는 &lt;code&gt;Dictionary&lt;/code&gt; ). 이렇게하면 인터페이스의 다른 모든 멤버가 type 매개 변수를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aae1c23f28d25359f684353160aa338cdad63b7" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;AMD&lt;/code&gt; and &lt;code&gt;CommonJS&lt;/code&gt; module loaders, TypeScript now supports emitting modules &lt;code&gt;UMD&lt;/code&gt; (&lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;Universal Module Definition&lt;/a&gt;) and &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt;&lt;code&gt;System&lt;/code&gt;&lt;/a&gt; module formats.</source>
          <target state="translated">이외에도 &lt;code&gt;AMD&lt;/code&gt; 와 &lt;code&gt;CommonJS&lt;/code&gt; 모듈 로더, 타이프 해주기 발광 모듈 지원 &lt;code&gt;UMD&lt;/code&gt; ( &lt;a href=&quot;https://github.com/umdjs/umd&quot;&gt;범용 모듈 정의&lt;/a&gt; ) 및 &lt;a href=&quot;https://github.com/systemjs/systemjs&quot;&gt; &lt;code&gt;System&lt;/code&gt; &lt;/a&gt; 모듈 형식.</target>
        </trans-unit>
        <trans-unit id="5006f44bee52625a6ab0a4a313b0d7e2fc88612c" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;Partial&lt;/code&gt;, Mapped Types can express many useful transformations on types:</source>
          <target state="translated">매핑 된 &lt;code&gt;Partial&lt;/code&gt; 은 Partial 외에도 유형에 대한 많은 유용한 변환을 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="191adf935ed2ac18958fb4641280ef26e69e454d" translate="yes" xml:space="preserve">
          <source>In addition to compositional patterns like the above, this new inference on generic constructors means that functions that operate on class components in certain UI libraries like React can more correctly operate on generic class components.</source>
          <target state="translated">위와 같은 구성 패턴 외에도 일반 생성자에 대한이 새로운 추론은 React와 같은 특정 UI 라이브러리의 클래스 구성 요소에서 작동하는 함수가 일반 클래스 구성 요소에서 더 정확하게 작동 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1a90a08e2836eebeca011762ffd80aadcf5c05eb" translate="yes" xml:space="preserve">
          <source>In addition to creating an object with property names for members, numeric enums members also get a &lt;em&gt;reverse mapping&lt;/em&gt; from enum values to enum names. For example, in this example:</source>
          <target state="translated">숫자 열거 형 멤버는 멤버의 속성 이름으로 객체를 만드는 것 외에도 열거 형 값에서 열거 형 이름 으로 &lt;em&gt;역 매핑&lt;/em&gt; 됩니다. 예를 들어,이 예에서 :</target>
        </trans-unit>
        <trans-unit id="9ed91b41f41b6bffe64ebf951bfee935b8c06725" translate="yes" xml:space="preserve">
          <source>In addition to generic interfaces, we can also create generic classes. Note that it is not possible to create generic enums and namespaces.</source>
          <target state="translated">제네릭 인터페이스 외에도 제네릭 클래스를 만들 수도 있습니다. 일반 열거 형과 네임 스페이스를 만들 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d1e90cce3e41b4e86a90a13f73336c6deb38037e" translate="yes" xml:space="preserve">
          <source>In addition to the existing TypeScript support for decorating declarations with &lt;code&gt;export&lt;/code&gt;, module members can also be exported using separate export declarations, optionally specifying different names for exports using &lt;code&gt;as&lt;/code&gt; clauses.</source>
          <target state="translated">&lt;code&gt;export&lt;/code&gt; 로 선언을 장식하는 기존 TypeScript 지원 외에도 별도의 내보내기 선언을 사용하여 모듈 멤버 를 내보낼 수 있으며 선택적 &lt;code&gt;as&lt;/code&gt; 절을 사용하여 내보내기에 다른 이름을 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5fc2368a23b5c630c12625ea45cc7ece18d41984" translate="yes" xml:space="preserve">
          <source>In addition to the pattern of inner classes, you may also be familiar with the JavaScript practice of creating a function and then extending the function further by adding properties onto the function. TypeScript uses declaration merging to build up definitions like this in a type-safe way.</source>
          <target state="translated">내부 클래스의 패턴 외에도 함수를 작성한 다음 함수에 특성을 추가하여 함수를 추가로 확장하는 JavaScript 실습에 익숙 할 수 있습니다. TypeScript는 선언 병합을 사용하여 형식이 안전한 방식으로 이와 같은 정의를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="64dd39fbc1176fa7cb78d499e27b42f425e4f288" translate="yes" xml:space="preserve">
          <source>In addition to user-defined symbols, there are well-known built-in symbols. Built-in symbols are used to represent internal language behaviors.</source>
          <target state="translated">사용자 정의 기호 외에도 잘 알려진 내장 기호가 있습니다. 내장 기호는 내부 언어 동작을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af6dc8ce595252f91c362798795d00c0d72386ed" translate="yes" xml:space="preserve">
          <source>In addition, entities are &lt;em&gt;implicitly&lt;/em&gt; read-only in several situations:</source>
          <target state="translated">또한 엔티티는 여러 상황에서 &lt;em&gt;암시 적으로&lt;/em&gt; 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="f13cadd149f177816bfcd1f47e7199c8a2dd824c" translate="yes" xml:space="preserve">
          <source>In all other cases enum member is considered computed.</source>
          <target state="translated">다른 모든 경우에는 열거 형 멤버가 계산 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="afe27faa913e56241e9fef79caeefb4719b9d97b" translate="yes" xml:space="preserve">
          <source>In cases where the compiler can&amp;rsquo;t eliminate &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, you can use the type assertion operator to manually remove them. The syntax is postfix &lt;code&gt;!&lt;/code&gt;: &lt;code&gt;identifier!&lt;/code&gt; removes &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; from the type of &lt;code&gt;identifier&lt;/code&gt;:</source>
          <target state="translated">컴파일러가 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 를 제거 할 수없는 경우 형식 어설 션 연산자를 사용하여 수동으로 제거 할 수 있습니다. 구문은 postfix입니다 &lt;code&gt;!&lt;/code&gt; : &lt;code&gt;identifier!&lt;/code&gt; &lt;code&gt;identifier&lt;/code&gt; 유형에서 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="46e7cfaa389b12ae897eb1224615c0bd3a3a74e0" translate="yes" xml:space="preserve">
          <source>In earlier versions of TypeScript, we generalized mapped types to operate differently on array-like types. This meant that a mapped type like &lt;code&gt;Boxify&lt;/code&gt; could work on arrays and tuples alike.</source>
          <target state="translated">이전 버전의 TypeScript에서는 배열 유형에서 다르게 작동하도록 매핑 된 유형을 일반화했습니다. 이것은 &lt;code&gt;Boxify&lt;/code&gt; 와 같은 매핑 된 유형이 배열 및 튜플에서 모두 작동 할 수 있음을 의미했습니다 .</target>
        </trans-unit>
        <trans-unit id="d3125ad49c86be35f677e4c8afe1f401c2f39f09" translate="yes" xml:space="preserve">
          <source>In exact terms, the &lt;code&gt;--strict&lt;/code&gt; option sets the &lt;em&gt;default&lt;/em&gt; value for the compiler options listed above. This means it is still possible to individually control the options. For example,</source>
          <target state="translated">정확하게 말하면 &lt;code&gt;--strict&lt;/code&gt; 옵션은 위에 나열된 컴파일러 옵션 의 &lt;em&gt;기본값을&lt;/em&gt; 설정합니다 . 즉, 옵션을 개별적으로 제어 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="f8bbd9b4c8e18d955c59e1b9bb4bd269b6054dc3" translate="yes" xml:space="preserve">
          <source>In extends clause</source>
          <target state="translated">extends 절</target>
        </trans-unit>
        <trans-unit id="317805e6e63ca60bc3ca9fd2d268f7e654b8cbb1" translate="yes" xml:space="preserve">
          <source>In function calls</source>
          <target state="translated">함수 호출에서</target>
        </trans-unit>
        <trans-unit id="c33d3561ce65af4351cdeaf45173b07c0b043d0d" translate="yes" xml:space="preserve">
          <source>In general, not much is needed to transition a repo using relative modules. Simply place a &lt;code&gt;tsconfig.json&lt;/code&gt; file in each subdirectory of a given parent folder, and add &lt;code&gt;reference&lt;/code&gt;s to these config files to match the intended layering of the program. You will need to either set the &lt;code&gt;outDir&lt;/code&gt; to an explicit subfolder of the output folder, or set the &lt;code&gt;rootDir&lt;/code&gt; to the common root of all project folders.</source>
          <target state="translated">일반적으로 상대 모듈을 사용하여 리포지토리를 전환하는 데는 별다른 필요가 없습니다. 단순히 배치 &lt;code&gt;tsconfig.json&lt;/code&gt; 의 주어진 상위 폴더의 각 하위 디렉토리에 파일을 추가합니다 &lt;code&gt;reference&lt;/code&gt; 하여 프로그램의 적층 구성에 맞게 이러한 설정 파일에들. 당신이 중 하나를 설정을해야합니다 &lt;code&gt;outDir&lt;/code&gt; 출력 폴더의 명시 적 하위 폴더, 또는 설정 &lt;code&gt;rootDir&lt;/code&gt; 모든 프로젝트 폴더의 일반적인 루트.</target>
        </trans-unit>
        <trans-unit id="b1625c54a8a7392317454ab8180d6577f1b9ae1b" translate="yes" xml:space="preserve">
          <source>In instantiations of a distributive conditional type &lt;code&gt;T extends U ? X : Y&lt;/code&gt;, references to &lt;code&gt;T&lt;/code&gt; within the conditional type are resolved to individual constituents of the union type (i.e. &lt;code&gt;T&lt;/code&gt; refers to the individual constituents &lt;em&gt;after&lt;/em&gt; the conditional type is distributed over the union type). Furthermore, references to &lt;code&gt;T&lt;/code&gt; within &lt;code&gt;X&lt;/code&gt; have an additional type parameter constraint &lt;code&gt;U&lt;/code&gt; (i.e. &lt;code&gt;T&lt;/code&gt; is considered assignable to &lt;code&gt;U&lt;/code&gt; within &lt;code&gt;X&lt;/code&gt;).</source>
          <target state="translated">분배 조건부 유형 &lt;code&gt;T extends U ? X : Y&lt;/code&gt; 인스턴스화에서 U? X : Y , 조건 유형 내의 &lt;code&gt;T&lt;/code&gt; 에 대한 참조 는 조합 유형의 개별 구성 요소로 해석됩니다 (즉, &lt;code&gt;T&lt;/code&gt; 는 조건 유형이 결합 유형에 분배 된 &lt;em&gt;후&lt;/em&gt; 개별 구성 요소를 나타냄 ). 또한 &lt;code&gt;X&lt;/code&gt; 내의 &lt;code&gt;T&lt;/code&gt; 에 대한 참조 에는 추가 유형 매개 변수 제약 조건 &lt;code&gt;U&lt;/code&gt; 가 있습니다 (즉, &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;X&lt;/code&gt; 내의 &lt;code&gt;U&lt;/code&gt; 에 할당 가능한 것으로 간주 됨 ).</target>
        </trans-unit>
        <trans-unit id="ade42fc57c0936ec5b4a222b5c45022a1c4760c5" translate="yes" xml:space="preserve">
          <source>In languages like C# and Java, one of the main tools in the toolbox for creating reusable components is &lt;em&gt;generics&lt;/em&gt;, that is, being able to create a component that can work over a variety of types rather than a single one. This allows users to consume these components and use their own types.</source>
          <target state="translated">C # 및 Java와 같은 언어에서 재사용 가능한 컴포넌트를 작성하기위한 도구 상자의 주요 도구 중 하나는 &lt;em&gt;generics입니다&lt;/em&gt; . 즉, 단일 유형이 아닌 다양한 유형에서 작동 할 수있는 컴포넌트를 작성할 수 있습니다. 이를 통해 사용자는 이러한 구성 요소를 소비하고 자체 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c5505a3474915f4cc4c566956af416ee322aa67" translate="yes" xml:space="preserve">
          <source>In most cases, enums are a perfectly valid solution. However sometimes requirements are tighter. To avoid paying the cost of extra generated code and additional indirection when accessing enum values, it&amp;rsquo;s possible to use &lt;code&gt;const&lt;/code&gt; enums. Const enums are defined using the &lt;code&gt;const&lt;/code&gt; modifier on our enums:</source>
          <target state="translated">대부분의 경우 열거 형은 완벽하게 유효한 솔루션입니다. 그러나 때로는 요구 사항이 더 엄격합니다. 열거 형 값에 액세스 할 때 추가로 생성 된 코드 및 추가 간접비를 지불하지 않기 위해 &lt;code&gt;const&lt;/code&gt; 열거 형 을 사용할 수 있습니다 . Const 열거 형은 열거 형의 &lt;code&gt;const&lt;/code&gt; 한정자를 사용하여 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="9977fd8d646f7ee47ce74c49df2a1398accb087c" translate="yes" xml:space="preserve">
          <source>In most cases, type inference is straightforward. In the following sections, we&amp;rsquo;ll explore some of the nuances in how types are inferred.</source>
          <target state="translated">대부분의 경우 형식 유추는 간단합니다. 다음 섹션에서는 유형을 유추하는 방법에 대한 몇 가지 뉘앙스를 살펴볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="49e5eb0fe073a6b366d084def4b417b2dc17ba91" translate="yes" xml:space="preserve">
          <source>In nominally-typed languages like C# or Java, the equivalent code would be an error because the &lt;code&gt;Person&lt;/code&gt; class does not explicitly describe itself as being an implementer of the &lt;code&gt;Named&lt;/code&gt; interface.</source>
          <target state="translated">C # 또는 Java와 같은 명목 형 언어에서는 &lt;code&gt;Person&lt;/code&gt; 클래스가 자체적으로 &lt;code&gt;Named&lt;/code&gt; 인터페이스 의 구현 자로 설명하지 않기 때문에 해당 코드는 오류가 됩니다.</target>
        </trans-unit>
        <trans-unit id="6cd6a1cda7b4b6dafff0249316846cd737bb057b" translate="yes" xml:space="preserve">
          <source>In older versions of TypeScript, type aliases couldn&amp;rsquo;t be extended or implemented from (nor could they extend/implement other types). As of version 2.7, type aliases can be extended by creating a new intersection type e.g. &lt;code&gt;type Cat = Animal &amp;amp; { purrs: true }&lt;/code&gt;.</source>
          <target state="translated">이전 버전의 TypeScript에서는 유형 별칭을 확장하거나 구현할 수 없었습니다 (다른 유형을 확장 / 구현할 수도 없음). 버전 2.7 &lt;code&gt;type Cat = Animal &amp;amp; { purrs: true }&lt;/code&gt; 유형과 같은 새 교차 유형을 작성하여 유형 별명을 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4485cefc41070d0508c8ae3601f889e0c3ca550d" translate="yes" xml:space="preserve">
          <source>In older versions, TypeScript would infer the empty object type (&lt;code&gt;{}&lt;/code&gt;) when inferring from other type variables like &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">이전 버전에서 TypeScript는 &lt;code&gt;T&lt;/code&gt; 및 &lt;code&gt;U&lt;/code&gt; 와 같은 다른 유형 변수에서 유추 할 때 빈 오브젝트 유형 ( &lt;code&gt;{}&lt;/code&gt; )을 유추했습니다 .</target>
        </trans-unit>
        <trans-unit id="3becc57b3af3b6f00aff1c308abe30fb09b363bc" translate="yes" xml:space="preserve">
          <source>In order for the compiler to pick the correct type check, it follows a similar process to the underlying JavaScript. It looks at the overload list and, proceeding with the first overload, attempts to call the function with the provided parameters. If it finds a match, it picks this overload as the correct overload. For this reason, it&amp;rsquo;s customary to order overloads from most specific to least specific.</source>
          <target state="translated">컴파일러가 올바른 유형 검사를 선택하려면 기본 JavaScript와 유사한 프로세스를 따릅니다. 오버로드 목록을보고 첫 번째 오버로드를 진행하면서 제공된 매개 변수를 사용하여 함수를 호출하려고 시도합니다. 일치하는 것을 찾으면이 과부하를 올바른 과부하로 선택합니다. 이러한 이유로 과부하를 가장 구체적으로 또는 덜 구체적으로 주문하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="ec884edde65bedd374e2043ee3584a67f5dd3d21" translate="yes" xml:space="preserve">
          <source>In order to ensure that a function never potentially returned &lt;code&gt;undefined&lt;/code&gt; or effectively returned from all code paths, TypeScript needed some syntactic signal - either a &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;throw&lt;/code&gt; at the end of a function. So users found themselves &lt;code&gt;return&lt;/code&gt;-ing their failure functions.</source>
          <target state="translated">함수 가 모든 코드 경로에서 &lt;code&gt;undefined&lt;/code&gt; 거나 효과적으로 반환 되지 않도록하려면 TypeScript 는 함수의 끝에서 &lt;code&gt;return&lt;/code&gt; 또는 &lt;code&gt;throw&lt;/code&gt; 같은 구문 신호가 필요했습니다 . 따라서 사용자는 자신 이 실패한 기능을 &lt;code&gt;return&lt;/code&gt; 한다는 것을 알았습니다 .</target>
        </trans-unit>
        <trans-unit id="7a30e2c325b4e7b632ea33292d372bb91480fbed" translate="yes" xml:space="preserve">
          <source>In order to understand type checking with JSX, you must first understand the difference between intrinsic elements and value-based elements. Given a JSX expression &lt;code&gt;&amp;lt;expr /&amp;gt;&lt;/code&gt;, &lt;code&gt;expr&lt;/code&gt; may either refer to something intrinsic to the environment (e.g. a &lt;code&gt;div&lt;/code&gt; or &lt;code&gt;span&lt;/code&gt; in a DOM environment) or to a custom component that you&amp;rsquo;ve created. This is important for two reasons:</source>
          <target state="translated">JSX로 유형 검사를 이해하려면 먼저 고유 요소와 값 기반 요소의 차이점을 이해해야합니다. JSX 표현을 감안할 때 &lt;code&gt;&amp;lt;expr /&amp;gt;&lt;/code&gt; , &lt;code&gt;expr&lt;/code&gt; 이 중 환경에 뭔가 고유 참조 할 수 있습니다 (예 : &lt;code&gt;div&lt;/code&gt; 또는 &lt;code&gt;span&lt;/code&gt; 는 DOM 환경에서) 또는 사용자가 만든 것으로 사용자 정의 구성 요소. 이것은 두 가지 이유로 중요합니다.</target>
        </trans-unit>
        <trans-unit id="2c6b1f2bc59ac8b4cd64d29de8b2d3e100cb6d4f" translate="yes" xml:space="preserve">
          <source>In order to use JSX you must do two things.</source>
          <target state="translated">JSX를 사용하려면 두 가지 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="2425b2f241ed01dc603f0c439b76c219ccaf89d0" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;x&lt;/code&gt; must be &lt;code&gt;1&lt;/code&gt; when it gets compared to &lt;code&gt;2&lt;/code&gt;, meaning that the above check is making an invalid comparison.</source>
          <target state="translated">즉, &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;2&lt;/code&gt; 와 비교 될 때 x 는 &lt;code&gt;1&lt;/code&gt; 이어야합니다. 즉, 위의 검사가 유효하지 않은 비교를하고 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7e1538e5dd442871789cc5ecc7783750fa78d9ea" translate="yes" xml:space="preserve">
          <source>In other words, TypeScript now catches the above bug, which may be a breaking change for some users, but will largely be helpful.</source>
          <target state="translated">즉, TypeScript는 이제 위의 버그를 발견하여 일부 사용자에게는 큰 변화가 될 수 있지만 크게 도움이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="93e13237760bfc497efa3e019beaf296fba0f599" translate="yes" xml:space="preserve">
          <source>In other words, hitting go-to-definition on a declaration from a &lt;code&gt;.d.ts&lt;/code&gt; file generated with &lt;code&gt;--declarationMap&lt;/code&gt; will take you to the source file (&lt;code&gt;.ts&lt;/code&gt;) location where that declaration was defined, and not to the &lt;code&gt;.d.ts&lt;/code&gt;.</source>
          <target state="translated">즉, 타격 이동 - 투 - 정의 a에서 선언에 &lt;code&gt;.d.ts&lt;/code&gt; 의 과 생성 된 파일 &lt;code&gt;--declarationMap&lt;/code&gt; 는 소스 파일 (당신을 데려 갈 것이다 &lt;code&gt;.ts&lt;/code&gt; 그 선언이 정의 된) 위치 및하지로 &lt;code&gt;.d.ts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c2ced57a304d01037d71bbb4f8dbc6d272f4c53" translate="yes" xml:space="preserve">
          <source>In other words, instead of producing the type</source>
          <target state="translated">즉, 유형을 생성하는 대신</target>
        </trans-unit>
        <trans-unit id="13c9723a82ddbb23b59c0ac5eb80038fe61fb8ae" translate="yes" xml:space="preserve">
          <source>In our example, we knew that all uses of &lt;code&gt;x&lt;/code&gt; would be initialized so it makes more sense to use definite assignment assertions than non-null assertions.</source>
          <target state="translated">이 예에서는 &lt;code&gt;x&lt;/code&gt; 의 모든 사용 이 초기화되므로 null이 아닌 어설 션보다 명확한 대입 어설 션을 사용하는 것이 더 합리적이라는 것을 알고있었습니다 .</target>
        </trans-unit>
        <trans-unit id="e09a40d13c5b9150cdb7cb04b404685efc24c2e1" translate="yes" xml:space="preserve">
          <source>In our examples, we&amp;rsquo;ve been able to freely access the members that we declared throughout our programs. If you&amp;rsquo;re familiar with classes in other languages, you may have noticed in the above examples we haven&amp;rsquo;t had to use the word &lt;code&gt;public&lt;/code&gt; to accomplish this; for instance, C# requires that each member be explicitly labeled &lt;code&gt;public&lt;/code&gt; to be visible. In TypeScript, each member is &lt;code&gt;public&lt;/code&gt; by default.</source>
          <target state="translated">우리의 예에서, 우리는 프로그램 전체에서 선언 한 멤버들에게 자유롭게 접근 할 수있었습니다. 다른 언어로 된 수업에 익숙하다면 위의 예에서 이것을 달성하기 위해 &lt;code&gt;public&lt;/code&gt; 이라는 단어를 사용하지 않았 음을 알 수 있습니다 . 예를 들어 C #에서는 각 멤버를 명시 적으로 &lt;code&gt;public&lt;/code&gt; 으로 표시 해야합니다. TypeScript에서 각 멤버는 기본적으로 &lt;code&gt;public&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="077f32db3171bafea36c02345fca8439c23de1f0" translate="yes" xml:space="preserve">
          <source>In our first example using interfaces, TypeScript lets us pass &lt;code&gt;{ size: number; label: string; }&lt;/code&gt; to something that only expected a &lt;code&gt;{ label: string; }&lt;/code&gt;. We also just learned about optional properties, and how they&amp;rsquo;re useful when describing so-called &amp;ldquo;option bags&amp;rdquo;.</source>
          <target state="translated">인터페이스를 사용하는 첫 번째 예에서 TypeScript를 사용하면 &lt;code&gt;{ size: number; label: string; }&lt;/code&gt; 만 예상 뭔가 &lt;code&gt;{ label: string; }&lt;/code&gt; . 우리는 또한 선택적 속성과 이른바&amp;ldquo;옵션 백&amp;rdquo;을 설명 할 때 유용한 속성에 대해 배웠습니다.</target>
        </trans-unit>
        <trans-unit id="b5509d814ae50a61b30f1663160809aaacc3c863" translate="yes" xml:space="preserve">
          <source>In our last example, we had to declare a readonly member &lt;code&gt;name&lt;/code&gt; and a constructor parameter &lt;code&gt;theName&lt;/code&gt; in the &lt;code&gt;Octopus&lt;/code&gt; class. This is needed in order to have the value of &lt;code&gt;theName&lt;/code&gt; accessible after the &lt;code&gt;Octopus&lt;/code&gt; constructor is executed. &lt;em&gt;Parameter properties&lt;/em&gt; let you create and initialize a member in one place. Here&amp;rsquo;s a further revision of the previous &lt;code&gt;Octopus&lt;/code&gt; class using a parameter property:</source>
          <target state="translated">마지막 예제에서는 &lt;code&gt;Octopus&lt;/code&gt; 클래스 에서 읽기 전용 멤버 &lt;code&gt;name&lt;/code&gt; 과 생성자 매개 변수 &lt;code&gt;theName&lt;/code&gt; 을 선언해야했습니다 . 이는 &lt;code&gt;Octopus&lt;/code&gt; 생성자가 실행 된 후 &lt;code&gt;theName&lt;/code&gt; 값에 액세스 할 수 있도록 하기 위해 필요합니다 . &lt;em&gt;매개 변수 속성&lt;/em&gt; 을 사용하면 한 곳에서 멤버를 만들고 초기화 할 수 있습니다. 다음 은 매개 변수 속성을 사용하는 이전 &lt;code&gt;Octopus&lt;/code&gt; 클래스 의 추가 개정판입니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a2a7cf3a706d3a1af3a4cb37abf72ef77d6e4707" translate="yes" xml:space="preserve">
          <source>In playing with the example, you may notice that the TypeScript compiler can figure out the type even if you only have types on one side of the equation:</source>
          <target state="translated">예제를 사용하면 방정식의 한쪽에만 유형이 있더라도 TypeScript 컴파일러가 유형을 알아낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c1b4684fb04512e6c7b40289668510482450dd8" translate="yes" xml:space="preserve">
          <source>In practical terms, strict null checking mode requires that all files in a compilation are null- and undefined-aware.</source>
          <target state="translated">실질적으로 엄격한 null 확인 모드를 사용하려면 컴파일의 모든 파일이 null 및 undefined를 인식해야합니다.</target>
        </trans-unit>
        <trans-unit id="6bafe310667e5e4e7564369b651bf5008fd49779" translate="yes" xml:space="preserve">
          <source>In pre-ES2015 targets, the most faithful emit for constructs like &lt;code&gt;for&lt;/code&gt;/&lt;code&gt;of&lt;/code&gt; loops and array spreads can be a bit heavy. For this reason, TypeScript uses a simpler emit by default that only supports array types, and supports iterating on other types using the &lt;code&gt;--downlevelIteration&lt;/code&gt; flag. The looser default without &lt;code&gt;--downlevelIteration&lt;/code&gt; works fairly well; however, there were some common cases where the transformation of array spreads had observable differences. For example, the following array containing a spread</source>
          <target state="translated">ES2015 이전의 목표에서 &lt;code&gt;for&lt;/code&gt; / &lt;code&gt;of&lt;/code&gt; 루프 및 배열 확산과 같은 구성에 대해 가장 충실한 방출 은 약간 무거울 수 있습니다. 이러한 이유로 TypeScript는 기본적으로 배열 유형 만 지원하고 &lt;code&gt;--downlevelIteration&lt;/code&gt; 플래그를 사용하여 다른 유형에 대한 반복을 지원하는 더 간단한 이미 터를 사용합니다 . &lt;code&gt;--downlevelIteration&lt;/code&gt; 이 없는 느슨한 기본값 은 상당히 잘 작동합니다. 그러나 배열 스프레드의 변환에 상당한 차이가있는 몇 가지 일반적인 경우가있었습니다. 예를 들어 스프레드가 포함 된 다음 배열</target>
        </trans-unit>
        <trans-unit id="d8dc065deb2345b3fc2204f90ad4ee7eedf78bff" translate="yes" xml:space="preserve">
          <source>In previous sections, we created generic identity functions that worked over a range of types. In this section, we&amp;rsquo;ll explore the type of the functions themselves and how to create generic interfaces.</source>
          <target state="translated">이전 섹션에서는 다양한 유형에서 작동하는 일반 아이덴티티 함수를 만들었습니다. 이 섹션에서는 함수 자체의 유형과 일반 인터페이스를 만드는 방법을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="f628a9f7456d28c2ae0af03d23563c657fc921e2" translate="yes" xml:space="preserve">
          <source>In previous versions of TypeScript, it was an error to merge classes and functions under any circumstances. Now, ambient classes and functions (classes/functions with the &lt;code&gt;declare&lt;/code&gt; modifier, or in &lt;code&gt;.d.ts&lt;/code&gt; files) can merge. This means that now you can write the following:</source>
          <target state="translated">이전 버전의 TypeScript에서는 모든 상황에서 클래스와 함수를 병합하는 것이 오류였습니다. 이제 앰비언트 클래스와 함수 ( &lt;code&gt;declare&lt;/code&gt; &lt;code&gt;.d.ts&lt;/code&gt; 사용하는 클래스 / 함수 또는 .d.ts 파일)가 병합 될 수 있습니다. 이것은 이제 다음을 쓸 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f22c95046aa4c7055bed172e8f2f4e6828c3f4e5" translate="yes" xml:space="preserve">
          <source>In previous versions of TypeScript, the language didn&amp;rsquo;t allow &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessors in ambient contexts (like in &lt;code&gt;declare&lt;/code&gt;-d classes, or in &lt;code&gt;.d.ts&lt;/code&gt; files in general). The rationale was that accessors weren&amp;rsquo;t distinct from properties as far as writing and reading to these properties; however, &lt;a href=&quot;https://github.com/tc39/proposal-class-fields/issues/248&quot;&gt;because ECMAScript&amp;rsquo;s class fields proposal may have differing behavior from in existing versions of TypeScript&lt;/a&gt;, we realized we needed a way to communicate this different behavior to provide appropriate errors in subclasses.</source>
          <target state="translated">이전 버전의 TypeScript에서 언어는 주변 컨텍스트 (예 : &lt;code&gt;declare&lt;/code&gt; -d 클래스 또는 일반적으로 &lt;code&gt;.d.ts&lt;/code&gt; 파일) 에서 접근자를 &lt;code&gt;get&lt;/code&gt; 오고 &lt;code&gt;set&lt;/code&gt; 수 없었습니다 . 이론적 근거는 접근 자들이 이러한 속성에 대해 읽고 쓰는 한 속성과 구별되지 않았다는 것입니다. 그러나 &lt;a href=&quot;https://github.com/tc39/proposal-class-fields/issues/248&quot;&gt;ECMAScript의 클래스 필드 제안은 기존 버전의 TypeScript&lt;/a&gt; 와 동작이 다를 수 있으므로 서브 클래스에 적절한 오류를 제공하기 위해이 다른 동작을 전달하는 방법이 필요하다는 것을 깨달았습니다.</target>
        </trans-unit>
        <trans-unit id="3cd7367e12bf3be0daca8711d8c00eca9148e271" translate="yes" xml:space="preserve">
          <source>In prior versions of TypeScript, unions of callable types could &lt;em&gt;only&lt;/em&gt; be invoked if they had identical parameter lists.</source>
          <target state="translated">이전 버전의 TypeScript에서는 호출 가능한 형식의 공용체 가 동일한 매개 변수 목록이있는 경우 &lt;em&gt;에만&lt;/em&gt; 호출 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="6c9fb325d7fa06659600b395394db2f6b03b95fa" translate="yes" xml:space="preserve">
          <source>In regular type checking mode the inferred type of &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;any&lt;/code&gt; because of widening, but in strict null checking mode the inferred type of &lt;code&gt;z&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; (and therefore, absent a type annotation, &lt;code&gt;null&lt;/code&gt; is the only possible value for &lt;code&gt;z&lt;/code&gt;).</source>
          <target state="translated">일정한 유형 검사 모드에서의 유추 형 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;any&lt;/code&gt; 때문에 넓히는, 그러나 엄격한 널 모드에서 검사 유추 형 &lt;code&gt;z&lt;/code&gt; 인 &lt;code&gt;null&lt;/code&gt; (따라서, 타입 주석이 존재하지 &lt;code&gt;null&lt;/code&gt; 유일한 가능한 값 &lt;code&gt;z&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7f54adc2fc21b0868ad3536236db9c436bfd98c6" translate="yes" xml:space="preserve">
          <source>In short using this general type, we can model React&amp;rsquo;s specific behavior for things like &lt;code&gt;defaultProps&lt;/code&gt; and, to some extent, &lt;code&gt;propTypes&lt;/code&gt;.</source>
          <target state="translated">간단히 말해서이 일반 유형을 사용하면 &lt;code&gt;defaultProps&lt;/code&gt; 및 &lt;code&gt;propTypes&lt;/code&gt; 와 같은 것에 대한 React의 특정 동작을 모델링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e40e3de53767b82c408d32adbf7faeb04be447e" translate="yes" xml:space="preserve">
          <source>In short, what this means is that you&amp;rsquo;ll be able to appropriately narrow down values from iterators when dealing with them directly.</source>
          <target state="translated">즉, 이것이 의미하는 바는 반복자를 직접 처리 할 때 반복기의 값을 적절하게 좁힐 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d6cb0b5b618417fb0993aeb5137486599cc6a685" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to only load a module under some conditions. In TypeScript, we can use the pattern shown below to implement this and other advanced loading scenarios to directly invoke the module loaders without losing type safety.</source>
          <target state="translated">경우에 따라 특정 조건에서만 모듈을로드 할 수 있습니다. TypeScript에서는 아래 표시된 패턴을 사용하여 유형 및 기타 고급 로딩 시나리오를 구현하여 유형 안전성을 잃지 않고 모듈 로더를 직접 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c99a1ed58829ceab5559116a15c7379e705e9cf2" translate="yes" xml:space="preserve">
          <source>In strict null checking mode the compiler requires every reference to a local variable of a type that doesn&amp;rsquo;t include &lt;code&gt;undefined&lt;/code&gt; to be preceded by an assignment to that variable in every possible preceding code path.</source>
          <target state="translated">엄격한 null 확인 모드에서 컴파일러는 가능한 모든 선행 코드 경로에서 해당 변수에 대한 할당이 앞에 &lt;code&gt;undefined&lt;/code&gt; 되지 않은 포함 되지 않은 유형의 로컬 변수에 대한 모든 참조가 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="90cda15a62a8aabc97010caa6808ab78ddacdf3d" translate="yes" xml:space="preserve">
          <source>In strict null checking mode, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values are &lt;em&gt;not&lt;/em&gt; in the domain of every type and are only assignable to themselves and &lt;code&gt;any&lt;/code&gt; (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;). So, whereas &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;T | undefined&lt;/code&gt; are considered synonymous in regular type checking mode (because &lt;code&gt;undefined&lt;/code&gt; is considered a subtype of any &lt;code&gt;T&lt;/code&gt;), they are different types in strict type checking mode, and only &lt;code&gt;T | undefined&lt;/code&gt; permits &lt;code&gt;undefined&lt;/code&gt; values. The same is true for the relationship of &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;T | null&lt;/code&gt;.</source>
          <target state="translated">엄격한 널 검사 모드에서 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 값은 모든 유형의 도메인에 &lt;em&gt;있지 않으며&lt;/em&gt; 자신 및 &lt;code&gt;any&lt;/code&gt; 에게만 지정할 수 있습니다 ( &lt;code&gt;undefined&lt;/code&gt; 예외는 &lt;code&gt;void&lt;/code&gt; 에 지정할 수도 있습니다 ). 그래서, 반면 &lt;code&gt;T&lt;/code&gt; 및 &lt;code&gt;T | undefined&lt;/code&gt; 는 일반 유형 검사 모드에서 동의어로 간주되며 ( &lt;code&gt;undefined&lt;/code&gt; 는 &lt;code&gt;T&lt;/code&gt; 의 하위 유형으로 간주 되므로 ) 엄격한 유형 검사 모드에서는 서로 다른 유형이며 &lt;code&gt;T | undefined&lt;/code&gt; 는 &lt;code&gt;undefined&lt;/code&gt; 값을 허용 합니다. 동일의 관계를 사실 &lt;code&gt;T&lt;/code&gt; 에 &lt;code&gt;T | null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="864d1a7dd1f8dd603a28df5bb3a63874ccc5a6ed" translate="yes" xml:space="preserve">
          <source>In strict null checking mode, the &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; values are not in the domain of every type and are only assignable to themselves and &lt;code&gt;any&lt;/code&gt; (the one exception being that &lt;code&gt;undefined&lt;/code&gt; is also assignable to &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">엄격한 널 검사 모드에서 &lt;code&gt;null&lt;/code&gt; 및 &lt;code&gt;undefined&lt;/code&gt; 값은 모든 유형의 도메인에 있지 않으며 자신 및 &lt;code&gt;any&lt;/code&gt; 에게만 지정할 수 있습니다 ( &lt;code&gt;undefined&lt;/code&gt; 예외는 &lt;code&gt;void&lt;/code&gt; 에 지정할 수도 있습니다 ).</target>
        </trans-unit>
        <trans-unit id="1682f16f9b1d6f4b318f3d23665b6e6fd98e0061" translate="yes" xml:space="preserve">
          <source>In that example, we first checked whether &lt;code&gt;x&lt;/code&gt; was &lt;em&gt;not&lt;/em&gt;&lt;code&gt;E.Foo&lt;/code&gt;. If that check succeeds, then our &lt;code&gt;||&lt;/code&gt; will short-circuit, and the body of the &amp;lsquo;if&amp;rsquo; will run. However, if the check didn&amp;rsquo;t succeed, then &lt;code&gt;x&lt;/code&gt; can &lt;em&gt;only&lt;/em&gt; be &lt;code&gt;E.Foo&lt;/code&gt;, so it doesn&amp;rsquo;t make sense to see whether it&amp;rsquo;s equal to &lt;code&gt;E.Bar&lt;/code&gt;.</source>
          <target state="translated">여부를 그 예제에서, 우리는 먼저 확인 &lt;code&gt;x&lt;/code&gt; 가 있었다 &lt;em&gt;하지 &lt;/em&gt; &lt;code&gt;E.Foo&lt;/code&gt; . 확인이 성공하면 &lt;code&gt;||&lt;/code&gt; 단락되고 'if'의 본문이 실행됩니다. 그러나 확인에 실패하면 &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;E.Foo&lt;/code&gt; &lt;em&gt;만&lt;/em&gt; 될 수 있으므로 E.Bar 와 같은지 여부는 알 수 &lt;code&gt;E.Bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79540091a75f3fdf1fb7b3a682d8e9c3c45c75f2" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt; will work fine but &lt;code&gt;&amp;lt;bar /&amp;gt;&lt;/code&gt; will result in an error since it has not been specified on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 &lt;code&gt;&amp;lt;foo /&amp;gt;&lt;/code&gt; 는 제대로 작동하지만 &lt;code&gt;&amp;lt;bar /&amp;gt;&lt;/code&gt; 는 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 에 지정되지 않았으므로 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="99596fbea2ab9226b233fd913b5eb437d1c67537" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;SelectableControl&lt;/code&gt; contains all of the members of &lt;code&gt;Control&lt;/code&gt;, including the private &lt;code&gt;state&lt;/code&gt; property. Since &lt;code&gt;state&lt;/code&gt; is a private member it is only possible for descendants of &lt;code&gt;Control&lt;/code&gt; to implement &lt;code&gt;SelectableControl&lt;/code&gt;. This is because only descendants of &lt;code&gt;Control&lt;/code&gt; will have a &lt;code&gt;state&lt;/code&gt; private member that originates in the same declaration, which is a requirement for private members to be compatible.</source>
          <target state="translated">위 예제에서 &lt;code&gt;SelectableControl&lt;/code&gt; 은 private &lt;code&gt;state&lt;/code&gt; 속성을 포함하여 &lt;code&gt;Control&lt;/code&gt; 의 모든 멤버를 포함합니다 . 이후 &lt;code&gt;state&lt;/code&gt; 개인 구성원 인의 후손을 위해에만 가능 &lt;code&gt;Control&lt;/code&gt; 구현하는 &lt;code&gt;SelectableControl&lt;/code&gt; 을 . 이것은의 후손 때문이다 &lt;code&gt;Control&lt;/code&gt; 해야합니다 &lt;code&gt;state&lt;/code&gt; 개인 회원이 개인 회원 호환하기위한 요구 사항입니다 같은 선언에서 유래.</target>
        </trans-unit>
        <trans-unit id="6ed88f77aa26355727030898d3eda06664af6814" translate="yes" xml:space="preserve">
          <source>In the above example, all declarations of &lt;code&gt;x&lt;/code&gt; actually refer to the &lt;em&gt;same&lt;/em&gt;&lt;code&gt;x&lt;/code&gt;, and this is perfectly valid. This often ends up being a source of bugs. Thankfully, &lt;code&gt;let&lt;/code&gt; declarations are not as forgiving.</source>
          <target state="translated">위의 예에서 &lt;code&gt;x&lt;/code&gt; 의 모든 선언은 실제로 &lt;em&gt;동일한 &lt;/em&gt; &lt;code&gt;x&lt;/code&gt; 를 참조 하며 이는 완벽하게 유효합니다. 이것은 종종 버그의 원인이됩니다. 다행히, &lt;code&gt;let&lt;/code&gt; 선언 용서로하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b37f0e6648f951eed9141c60cd7cf7e3ccaa9494" translate="yes" xml:space="preserve">
          <source>In the above, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are compatible because their structures do not use the type argument in a differentiating way. Changing this example by adding a member to &lt;code&gt;Empty&amp;lt;T&amp;gt;&lt;/code&gt; shows how this works:</source>
          <target state="translated">위의 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 구조가 다른 방식으로 type 인수를 사용하지 않기 때문에 호환됩니다. 멤버를 &lt;code&gt;Empty&amp;lt;T&amp;gt;&lt;/code&gt; 에 추가하여이 예제를 변경하면 작동 방식을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="bcf8f6881cecc6ec19e3b84c191f76d8a00ed9f0" translate="yes" xml:space="preserve">
          <source>In the above, if we truly meant for &lt;code&gt;baz&lt;/code&gt; to potentially be &lt;code&gt;undefined&lt;/code&gt;, we should have declared it with the type &lt;code&gt;boolean | undefined&lt;/code&gt;.</source>
          <target state="translated">위에서 &lt;code&gt;baz&lt;/code&gt; 가 잠재적으로 &lt;code&gt;undefined&lt;/code&gt; 가되도록하려면 &lt;code&gt;boolean | undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce3f57dfeaf54342e6e1919ab8d0e5f056d046b7" translate="yes" xml:space="preserve">
          <source>In the above, the variable &lt;code&gt;a&lt;/code&gt; has a conditional type that hasn&amp;rsquo;t yet chosen a branch. When another piece of code ends up calling &lt;code&gt;foo&lt;/code&gt;, it will substitute in &lt;code&gt;U&lt;/code&gt; with some other type, and TypeScript will re-evaluate the conditional type, deciding whether it can actually pick a branch.</source>
          <target state="translated">위의 변수 &lt;code&gt;a&lt;/code&gt; 에는 아직 분기를 선택하지 않은 조건부 유형이 있습니다. 다른 코드가 &lt;code&gt;foo&lt;/code&gt; 를 호출 하면 &lt;code&gt;U&lt;/code&gt; 에서 다른 유형으로 대체 되고 TypeScript는 조건부 유형을 다시 평가하여 실제로 분기를 선택할 수 있는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="61a17b1c1f756acdcb3aa7db7732994bae993575" translate="yes" xml:space="preserve">
          <source>In the code below, we show how you can model mixins in TypeScript. After the code, we&amp;rsquo;ll break down how it works.</source>
          <target state="translated">아래 코드에서는 TypeScript에서 믹스 인을 모델링하는 방법을 보여줍니다. 코드가 끝나면 작동 방식을 세분화합니다.</target>
        </trans-unit>
        <trans-unit id="03d5f48ae796a4f0c523d1b9798d453b05171c1c" translate="yes" xml:space="preserve">
          <source>In the declaration of &lt;code&gt;f2&lt;/code&gt; above, type inference infers types &lt;code&gt;number&lt;/code&gt;, &lt;code&gt;[string, boolean]&lt;/code&gt; and &lt;code&gt;void&lt;/code&gt; for &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; respectively.</source>
          <target state="translated">위 의 &lt;code&gt;f2&lt;/code&gt; 선언 에서 형식 유추는 유형 &lt;code&gt;number&lt;/code&gt; , &lt;code&gt;[string, boolean]&lt;/code&gt; 및 &lt;code&gt;void&lt;/code&gt; 를 각각 &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;U&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 에 유추합니다 .</target>
        </trans-unit>
        <trans-unit id="95157007d65e1f4f235f4c91408fe5a0cb118ec2" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;methods&lt;/code&gt; object in the argument to &lt;code&gt;makeObject&lt;/code&gt; has a contextual type that includes &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; and therefore the type of &lt;code&gt;this&lt;/code&gt; in methods within the &lt;code&gt;methods&lt;/code&gt; object is &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt;. Notice how the type of the &lt;code&gt;methods&lt;/code&gt; property simultaneously is an inference target and a source for the &lt;code&gt;this&lt;/code&gt; type in methods.</source>
          <target state="translated">위의 예 에서 &lt;code&gt;makeObject&lt;/code&gt; 인수 의 &lt;code&gt;methods&lt;/code&gt; 오브젝트 에는 &lt;code&gt;ThisType&amp;lt;D &amp;amp; M&amp;gt;&lt;/code&gt; 을 포함하는 컨텍스트 유형이 있으므로 &lt;code&gt;methods&lt;/code&gt; 오브젝트 내의 메소드 &lt;code&gt;this&lt;/code&gt; 유형 은 &lt;code&gt;{ x: number, y: number } &amp;amp; { moveBy(dx: number, dy: number): number }&lt;/code&gt; . &lt;code&gt;methods&lt;/code&gt; 속성 의 유형이 동시에 추론 대상 &lt;code&gt;this&lt;/code&gt; 되고 메소드 에서이 유형 의 소스가되는 방법에 주목하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d5d9e4e961d95a62eff2086560d0f53e21c16be" translate="yes" xml:space="preserve">
          <source>In the example above, the parameters &lt;code&gt;fruit&lt;/code&gt; and &lt;code&gt;color&lt;/code&gt; are intersected together to a new parameter of type &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt;. &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; is really the same as &lt;code&gt;(&quot;apple&quot; | &quot;orange&quot;) &amp;amp; (&quot;red&quot; | &quot;orange&quot;)&lt;/code&gt; which is equivalent to &lt;code&gt;(&quot;apple&quot; &amp;amp; &quot;red&quot;) | (&quot;apple&quot; &amp;amp; &quot;orange&quot;) | (&quot;orange&quot; &amp;amp; &quot;red&quot;) | (&quot;orange&quot; &amp;amp; &quot;orange&quot;)&lt;/code&gt;. Each of those impossible intersections reduces to &lt;code&gt;never&lt;/code&gt;, and we&amp;rsquo;re left with &lt;code&gt;&quot;orange&quot; &amp;amp; &quot;orange&quot;&lt;/code&gt; which is just &lt;code&gt;&quot;orange&quot;&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 &lt;code&gt;fruit&lt;/code&gt; 및 &lt;code&gt;color&lt;/code&gt; 매개 변수는 &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; 유형의 새로운 매개 변수와 함께 교차됩니다 . &lt;code&gt;Fruit &amp;amp; Color&lt;/code&gt; 정말 동일하다 &lt;code&gt;(&quot;apple&quot; | &quot;orange&quot;) &amp;amp; (&quot;red&quot; | &quot;orange&quot;)&lt;/code&gt; 에 해당하는 &lt;code&gt;(&quot;apple&quot; &amp;amp; &quot;red&quot;) | (&quot;apple&quot; &amp;amp; &quot;orange&quot;) | (&quot;orange&quot; &amp;amp; &quot;red&quot;) | (&quot;orange&quot; &amp;amp; &quot;orange&quot;)&lt;/code&gt; . 그 불가능 교차로의 각을 줄여 &lt;code&gt;never&lt;/code&gt; , 우리는 남아있는 &lt;code&gt;&quot;orange&quot; &amp;amp; &quot;orange&quot;&lt;/code&gt; 그냥 &lt;code&gt;&quot;orange&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e74ceca454671112b40bc5e5f6a4f738b5ff4300" translate="yes" xml:space="preserve">
          <source>In the following example, each input element will be printed out one at a time with a 400ms delay:</source>
          <target state="translated">다음 예에서 각 입력 요소는 400ms 지연으로 한 번에 하나씩 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="8c77483272b3e6dc467114f873247e6bedc0a970" translate="yes" xml:space="preserve">
          <source>In the last line we construct an instance of the &lt;code&gt;Greeter&lt;/code&gt; class using &lt;code&gt;new&lt;/code&gt;. This calls into the constructor we defined earlier, creating a new object with the &lt;code&gt;Greeter&lt;/code&gt; shape, and running the constructor to initialize it.</source>
          <target state="translated">마지막 줄에서 &lt;code&gt;new&lt;/code&gt; 를 사용하여 &lt;code&gt;Greeter&lt;/code&gt; 클래스 의 인스턴스를 만듭니다. 앞에서 정의한 생성자를 호출하여 &lt;code&gt;Greeter&lt;/code&gt; 모양 의 새 객체를 생성 하고 생성자를 실행하여 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="00dda950efe1878e4784a73323a690e1209928a7" translate="yes" xml:space="preserve">
          <source>In the last window, select the &lt;strong&gt;Empty&lt;/strong&gt; template and press the &lt;em&gt;Create&lt;/em&gt; button</source>
          <target state="translated">마지막 창에서 &lt;strong&gt;빈&lt;/strong&gt; 템플릿을 선택 하고 &lt;em&gt;만들기&lt;/em&gt; 버튼을 누릅니다</target>
        </trans-unit>
        <trans-unit id="730482750c8e706f4fdc3f8ccd811c5e5dd87860" translate="yes" xml:space="preserve">
          <source>In the meantime, we can assign a conditional type to any other target type as long as each branch of the conditional is assignable to that target. So in our example above we were able to assign &lt;code&gt;U extends Foo ? string : number&lt;/code&gt; to &lt;code&gt;string | number&lt;/code&gt; since no matter what the conditional evaluates to, it&amp;rsquo;s known to be either &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">그 동안 조건부 각 분기를 해당 대상에 할당 할 수있는 한 다른 대상 유형에 조건부 유형을 할당 할 수 있습니다. 위의 예에서 &lt;code&gt;U extends Foo ? string : number&lt;/code&gt; 를 &lt;code&gt;string | number&lt;/code&gt; 조건부 평가하여, 그것은 알려진하는 상관없이 보낸 사람이 될 수 있습니다 &lt;code&gt;string&lt;/code&gt; 이나 &lt;code&gt;number&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fa79973a1fa7675ac6793a6ef6bc0254a0e6be8" translate="yes" xml:space="preserve">
          <source>In the near future, we&amp;rsquo;re going to be refreshing the playground samples, adding JSX support, and polishing automatic type acquisition, meaning that you&amp;rsquo;ll be able to see the same experience on the playground as you&amp;rsquo;d get in your personal editor.</source>
          <target state="translated">가까운 장래에 놀이터 샘플을 새로 고치고 JSX 지원을 추가하고 자동 유형 획득을 연마 할 것입니다. 즉, 개인 편집기에서 얻을 때와 동일한 놀이터에서 동일한 경험을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3d6d530b9dead34dd8c0b86ef1bb298c7054a3c" translate="yes" xml:space="preserve">
          <source>In the project root, &lt;code&gt;proj&lt;/code&gt;, create the file &lt;code&gt;tsconfig.json&lt;/code&gt;:</source>
          <target state="translated">프로젝트 루트 &lt;code&gt;proj&lt;/code&gt; 에서 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="709cd93c7870c32633ca0a9bee5820c6fc2cb1c9" translate="yes" xml:space="preserve">
          <source>In the project root, create the file &lt;code&gt;gulpfile.js&lt;/code&gt;:</source>
          <target state="translated">프로젝트 루트에서 &lt;code&gt;gulpfile.js&lt;/code&gt; 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="73b6e04bf922a9cb6a95afcfe0525fa94ba745bd" translate="yes" xml:space="preserve">
          <source>In the type of a module object, exported &lt;code&gt;const&lt;/code&gt; variables are considered read-only properties.</source>
          <target state="translated">모듈 객체의 유형에서 내 보낸 &lt;code&gt;const&lt;/code&gt; 변수는 읽기 전용 속성으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="755da82a78f6c2a7ac8e76c0724da8dab740a01c" translate="yes" xml:space="preserve">
          <source>In the type of an enum object, enum members are considered read-only properties.</source>
          <target state="translated">열거 형 객체의 유형에서 열거 형 멤버는 읽기 전용 속성으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="637246693f4b6e39ecb694cc209862482bcc6694" translate="yes" xml:space="preserve">
          <source>In these examples, the properties list is &lt;code&gt;keyof T&lt;/code&gt; and the resulting type is some variant of &lt;code&gt;T[P]&lt;/code&gt;. This is a good template for any general use of mapped types. That&amp;rsquo;s because this kind of transformation is &lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphism&quot;&gt;homomorphic&lt;/a&gt;, which means that the mapping applies only to properties of &lt;code&gt;T&lt;/code&gt; and no others. The compiler knows that it can copy all the existing property modifiers before adding any new ones. For example, if &lt;code&gt;Person.name&lt;/code&gt; was readonly, &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; would be readonly and optional.</source>
          <target state="translated">이 예제에서 특성 목록은 &lt;code&gt;keyof T&lt;/code&gt; 이고 결과 유형은 &lt;code&gt;T[P]&lt;/code&gt; 의 일부 변형입니다 . 매핑 된 형식을 일반적으로 사용하기에 적합한 템플릿입니다. 이런 종류의 변환은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Homomorphism&quot;&gt;동형&lt;/a&gt; 이기 때문에 매핑은 &lt;code&gt;T&lt;/code&gt; 의 속성에만 적용 되고 다른 속성에는 적용 되지 않습니다. 컴파일러는 새로운 속성 수정자를 추가하기 전에 기존의 모든 속성 수정자를 복사 할 수 있다는 것을 알고 있습니다. 예를 들어 &lt;code&gt;Person.name&lt;/code&gt; 이 읽기 전용 인 경우 &lt;code&gt;Partial&amp;lt;Person&amp;gt;.name&lt;/code&gt; 은 읽기 전용이며 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="ed7a5a445e563d2e25cbaa994041bb2fd2483e73" translate="yes" xml:space="preserve">
          <source>In this above example, &lt;code&gt;g&lt;/code&gt; captured the variable &lt;code&gt;a&lt;/code&gt; declared in &lt;code&gt;f&lt;/code&gt;. At any point that &lt;code&gt;g&lt;/code&gt; gets called, the value of &lt;code&gt;a&lt;/code&gt; will be tied to the value of &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;f&lt;/code&gt;. Even if &lt;code&gt;g&lt;/code&gt; is called once &lt;code&gt;f&lt;/code&gt; is done running, it will be able to access and modify &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 &lt;code&gt;g&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 에 선언 된 변수 &lt;code&gt;a&lt;/code&gt; 를 캡처했습니다 . 것을 어느 시점에서 &lt;code&gt;g&lt;/code&gt; 가 호출되는, 값 &lt;code&gt;a&lt;/code&gt; 값에 연결됩니다 에서 &lt;code&gt;f&lt;/code&gt; . &lt;code&gt;f&lt;/code&gt; 가 실행 되면 &lt;code&gt;g&lt;/code&gt; 가 호출 되더라도 &lt;code&gt;a&lt;/code&gt; 에 액세스하고 수정할 수 있습니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c8516f6347c523b45eca06136cb8874b9907d612" translate="yes" xml:space="preserve">
          <source>In this case, we need to use TypeScript to tell any of our callers about the ways &lt;code&gt;myCoolFunction&lt;/code&gt; can be called using function overloads.</source>
          <target state="translated">이 경우 호출자에게 함수 오버로드를 사용하여 &lt;code&gt;myCoolFunction&lt;/code&gt; 을 호출 할 수있는 방법에 대해 알리려면 TypeScript를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e82ac6e4567b6044965f051115c0822a64abe344" translate="yes" xml:space="preserve">
          <source>In this example if &lt;code&gt;someValue&lt;/code&gt; isn&amp;rsquo;t equal to &lt;code&gt;42&lt;/code&gt;, then &lt;code&gt;assert&lt;/code&gt; will throw an &lt;code&gt;AssertionError&lt;/code&gt;.</source>
          <target state="translated">만약이 예에서 &lt;code&gt;someValue&lt;/code&gt; 와는 동일하지 않은 &lt;code&gt;42&lt;/code&gt; 다음 &lt;code&gt;assert&lt;/code&gt; 던 것이다 &lt;code&gt;AssertionError&lt;/code&gt; 를이 .</target>
        </trans-unit>
        <trans-unit id="e08fcd6cf022585dcfea9733e021155ec20b4944" translate="yes" xml:space="preserve">
          <source>In this example the &lt;code&gt;b?&lt;/code&gt; indicates that &lt;code&gt;b&lt;/code&gt; is optional, so it may be &lt;code&gt;undefined&lt;/code&gt;. &lt;code&gt;keepWholeObject&lt;/code&gt; now has a variable for &lt;code&gt;wholeObject&lt;/code&gt; as well as the properties &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, even if &lt;code&gt;b&lt;/code&gt; is undefined.</source>
          <target state="translated">이 예에서 &lt;code&gt;b?&lt;/code&gt; 것을 나타내고 &lt;code&gt;b&lt;/code&gt; 이 될 수 있으므로, 선택적 &lt;code&gt;undefined&lt;/code&gt; . &lt;code&gt;keepWholeObject&lt;/code&gt; 에는 이제 &lt;code&gt;b&lt;/code&gt; 가 정의되지 않은 경우에도 속성 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 뿐만 아니라 &lt;code&gt;wholeObject&lt;/code&gt; 에 대한 변수 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0117e5cd2d6305504464fa64c2596948182a60ec" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;greeter1&lt;/code&gt; works similarly to before. We instantiate the &lt;code&gt;Greeter&lt;/code&gt; class, and use this object. This we have seen before.</source>
          <target state="translated">이 예에서 &lt;code&gt;greeter1&lt;/code&gt; 은 이전과 유사하게 작동합니다. &lt;code&gt;Greeter&lt;/code&gt; 클래스를 인스턴스화 하고이 객체를 사용합니다. 우리는 전에 본 적이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbc3444b1d43d45eab0b74e1029b727531c4431d" translate="yes" xml:space="preserve">
          <source>In this example, best common type has a set of four candidates: &lt;code&gt;Animal&lt;/code&gt;, &lt;code&gt;Rhino&lt;/code&gt;, &lt;code&gt;Elephant&lt;/code&gt;, and &lt;code&gt;Snake&lt;/code&gt;. Of these, &lt;code&gt;Animal&lt;/code&gt; can be chosen by the best common type algorithm.</source>
          <target state="translated">이 예에서 best common type에는 &lt;code&gt;Animal&lt;/code&gt; , &lt;code&gt;Rhino&lt;/code&gt; , &lt;code&gt;Elephant&lt;/code&gt; 및 &lt;code&gt;Snake&lt;/code&gt; 의 네 가지 후보 세트가 있습니다. 이 중 가장 일반적인 유형 알고리즘으로 &lt;code&gt;Animal&lt;/code&gt; 을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb24f11a568ad33b4fe399d85ff9d360b565ca4d" translate="yes" xml:space="preserve">
          <source>In this example, the first block creates the following name meanings:</source>
          <target state="translated">이 예에서 첫 번째 블록은 다음과 같은 이름 의미를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6e7043ef257b3c1ba5ae99cc4588d236122d0645" translate="yes" xml:space="preserve">
          <source>In this example, there wasn&amp;rsquo;t a namespace &lt;code&gt;C&lt;/code&gt; until we wrote the &lt;code&gt;namespace&lt;/code&gt; declaration for it. The meaning &lt;code&gt;C&lt;/code&gt; as a namespace doesn&amp;rsquo;t conflict with the value or type meanings of &lt;code&gt;C&lt;/code&gt; created by the class.</source>
          <target state="translated">이 예에서는 &lt;code&gt;namespace&lt;/code&gt; 선언을 작성할 때까지 네임 스페이스 &lt;code&gt;C&lt;/code&gt; 가 없었 습니다. 네임 스페이스로서의 &lt;code&gt;C&lt;/code&gt; 의 의미 는 클래스에 의해 생성 된 &lt;code&gt;C&lt;/code&gt; 의 값 또는 유형의 의미와 충돌하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="07eb43c9c23afe5a52badab0f998515ac89c2d2c" translate="yes" xml:space="preserve">
          <source>In this example, we have an &lt;code&gt;Animal&lt;/code&gt; and a &lt;code&gt;Rhino&lt;/code&gt;, with &lt;code&gt;Rhino&lt;/code&gt; being a subclass of &lt;code&gt;Animal&lt;/code&gt;. We also have a new class &lt;code&gt;Employee&lt;/code&gt; that looks identical to &lt;code&gt;Animal&lt;/code&gt; in terms of shape. We create some instances of these classes and then try to assign them to each other to see what will happen. Because &lt;code&gt;Animal&lt;/code&gt; and &lt;code&gt;Rhino&lt;/code&gt; share the &lt;code&gt;private&lt;/code&gt; side of their shape from the same declaration of &lt;code&gt;private name: string&lt;/code&gt; in &lt;code&gt;Animal&lt;/code&gt;, they are compatible. However, this is not the case for &lt;code&gt;Employee&lt;/code&gt;. When we try to assign from an &lt;code&gt;Employee&lt;/code&gt; to &lt;code&gt;Animal&lt;/code&gt; we get an error that these types are not compatible. Even though &lt;code&gt;Employee&lt;/code&gt; also has a &lt;code&gt;private&lt;/code&gt; member called &lt;code&gt;name&lt;/code&gt;, it&amp;rsquo;s not the one we declared in &lt;code&gt;Animal&lt;/code&gt;.</source>
          <target state="translated">이 예제에는 &lt;code&gt;Animal&lt;/code&gt; 과 &lt;code&gt;Rhino&lt;/code&gt; 가 있으며 &lt;code&gt;Rhino&lt;/code&gt; 는 &lt;code&gt;Animal&lt;/code&gt; 의 하위 클래스입니다 . 또한 모양면에서 &lt;code&gt;Animal&lt;/code&gt; 과 동일하게 보이는 새로운 클래스 &lt;code&gt;Employee&lt;/code&gt; 이 있습니다. 이러한 클래스의 일부 인스턴스를 만든 다음 서로에게 할당하여 어떤 일이 발생할지 확인합니다. 때문에 &lt;code&gt;Animal&lt;/code&gt; 과 &lt;code&gt;Rhino&lt;/code&gt; 에서 공유 &lt;code&gt;private&lt;/code&gt; 같은 선언에서 그 형태의면 &lt;code&gt;private name: string&lt;/code&gt; 의 &lt;code&gt;Animal&lt;/code&gt; , 그들은 호환됩니다. 그러나 &lt;code&gt;Employee&lt;/code&gt; 의 경우에는 해당되지 않습니다 . &lt;code&gt;Employee&lt;/code&gt; 으로부터 배정하려고 할 때에 &lt;code&gt;Animal&lt;/code&gt; 우리는 이러한 유형의 호환되지 않는 오류가 발생합니다. &lt;code&gt;Employee&lt;/code&gt; 에도 &lt;code&gt;name&lt;/code&gt; 이라는 &lt;code&gt;private&lt;/code&gt; 구성원 이 있지만 &lt;code&gt;Animal&lt;/code&gt; 에서 선언 한 구성원 이 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="b1b93b10a4841edacda1facc2b60962e38ac6558" translate="yes" xml:space="preserve">
          <source>In this example, we&amp;rsquo;ll move all validator-related entities into a namespace called &lt;code&gt;Validation&lt;/code&gt;. Because we want the interfaces and classes here to be visible outside the namespace, we preface them with &lt;code&gt;export&lt;/code&gt;. Conversely, the variables &lt;code&gt;lettersRegexp&lt;/code&gt; and &lt;code&gt;numberRegexp&lt;/code&gt; are implementation details, so they are left unexported and will not be visible to code outside the namespace. In the test code at the bottom of the file, we now need to qualify the names of the types when used outside the namespace, e.g. &lt;code&gt;Validation.LettersOnlyValidator&lt;/code&gt;.</source>
          <target state="translated">이 예에서는 모든 유효성 검사기 관련 엔터티를 &lt;code&gt;Validation&lt;/code&gt; 이라는 네임 스페이스로 이동합니다 . 여기서 인터페이스와 클래스가 네임 스페이스 외부에 표시되기를 원하므로 &lt;code&gt;export&lt;/code&gt; 로 시작 합니다. 반대로, 변수 &lt;code&gt;lettersRegexp&lt;/code&gt; 및 &lt;code&gt;numberRegexp&lt;/code&gt; 는 구현 세부 사항이므로 내 보내지 않고 네임 스페이스 외부의 코드에는 표시되지 않습니다. 파일 맨 아래에있는 테스트 코드에서 네임 스페이스 외부에서 사용될 때 유형의 이름 (예 : &lt;code&gt;Validation.LettersOnlyValidator&lt;/code&gt; )을 규정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="21b24c391b92fb3d3163326a7abc4416dc6df6f4" translate="yes" xml:space="preserve">
          <source>In this generated code, an enum is compiled into an object that stores both forward (&lt;code&gt;name&lt;/code&gt; -&amp;gt; &lt;code&gt;value&lt;/code&gt;) and reverse (&lt;code&gt;value&lt;/code&gt; -&amp;gt; &lt;code&gt;name&lt;/code&gt;) mappings. References to other enum members are always emitted as property accesses and never inlined.</source>
          <target state="translated">(이 생성 된 코드에서, ENUM은 저장 순방향 것을 목적으로 컴파일 &lt;code&gt;name&lt;/code&gt; -&amp;gt; &lt;code&gt;value&lt;/code&gt; ) 및 (후진 &lt;code&gt;value&lt;/code&gt; -&amp;gt; &lt;code&gt;name&lt;/code&gt; 매핑). 다른 열거 형 멤버에 대한 참조는 항상 속성 액세스로 생성되며 인라인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bdc69a132c77ea1870143e272db1728193078fad" translate="yes" xml:space="preserve">
          <source>In this guide, we&amp;rsquo;ll assume basic familiarity with the TypeScript language. If you haven&amp;rsquo;t already, you should read the &lt;a href=&quot;../basic-types&quot;&gt;TypeScript Handbook&lt;/a&gt; to familiarize yourself with basic concepts, especially types and namespaces.</source>
          <target state="translated">이 가이드에서는 TypeScript 언어에 대한 기본 지식이 있다고 가정합니다. 아직없는 경우 &lt;a href=&quot;../basic-types&quot;&gt;TypeScript 핸드북&lt;/a&gt; 을 읽고 기본 개념, 특히 유형 및 네임 스페이스에 익숙해 져야합니다.</target>
        </trans-unit>
        <trans-unit id="344769647b81b7e0305ef0d99ae5fb65a087fe6f" translate="yes" xml:space="preserve">
          <source>In this mode, references to modules and packages (e.g. &lt;code&gt;import&lt;/code&gt;s and &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; directives) are all resolved relative to the location of the symbolic link file, rather than relative to the path that the symbolic link resolves to. For a more concrete example, we&amp;rsquo;ll defer to &lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;the documentation on the Node.js website&lt;/a&gt;.</source>
          <target state="translated">이 모드에서 모듈 및 패키지에 대한 참조 (예 : &lt;code&gt;import&lt;/code&gt; 및 &lt;code&gt;/// &amp;lt;reference type=&quot;...&quot; /&amp;gt;&lt;/code&gt; 지시문)는 모두 해당 경로가 아니라 기호 링크 파일의 위치를 ​​기준으로 확인됩니다 심볼릭 링크가 해결됩니다. 보다 구체적인 예를 보려면 &lt;a href=&quot;https://nodejs.org/api/cli.html#cli_preserve_symlinks&quot;&gt;Node.js 웹 사이트의 설명서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e80e58412d6afa0148bbe0431cb48a4186ad829b" translate="yes" xml:space="preserve">
          <source>In this section we&amp;rsquo;ll describe various common pitfalls in using namespaces and modules, and how to avoid them.</source>
          <target state="translated">이 섹션에서는 네임 스페이스와 모듈을 사용할 때 발생하는 다양한 일반적인 함정과이를 피하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1517fdb2153dd36963c7b932505762d1e99e7637" translate="yes" xml:space="preserve">
          <source>In this section, we will cover type inference in TypeScript. Namely, we&amp;rsquo;ll discuss where and how types are inferred.</source>
          <target state="translated">이 섹션에서는 TypeScript의 형식 유추에 대해 설명합니다. 즉, 유형을 유추하는 위치와 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bf72d17da27b309b1e4973b2684904a5f12bc9b3" translate="yes" xml:space="preserve">
          <source>In this simple example, &lt;code&gt;Keys&lt;/code&gt; is a hard-coded list of property names and the property type is always &lt;code&gt;boolean&lt;/code&gt;, so this mapped type is equivalent to writing:</source>
          <target state="translated">이 간단한 예제에서 &lt;code&gt;Keys&lt;/code&gt; 는 하드 코딩 된 속성 이름 목록이며 속성 유형은 항상 &lt;code&gt;boolean&lt;/code&gt; 이므로이 매핑 된 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7836cdb9242f8e5048b5c13b75f69d0839c138b0" translate="yes" xml:space="preserve">
          <source>In this version, we add a setter that checks the length of the &lt;code&gt;newName&lt;/code&gt; to make sure it&amp;rsquo;s compatible with the max-length of our backing database field. If it isn&amp;rsquo;t we throw an error notifying client code that something went wrong.</source>
          <target state="translated">이 버전에서는 &lt;code&gt;newName&lt;/code&gt; 의 길이를 확인하여 백업 데이터베이스 필드의 최대 길이와 호환되는지 확인하는 setter를 추가 합니다. 그렇지 않으면 클라이언트 코드에 문제가 있음을 알리는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2de95615256a6fbbdcec9fe7db708d237a429e35" translate="yes" xml:space="preserve">
          <source>In this way, a generic type that has its type arguments specified acts just like a non-generic type.</source>
          <target state="translated">이런 식으로 형식 인수가 지정된 제네릭 형식은 제네릭이 아닌 형식처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6f1aae5fbefc53fbec291cb812ed1e6d471e127d" translate="yes" xml:space="preserve">
          <source>In traditional object-oriented code, we might abstract over the two types by creating a hierarchy of types. While this is much more explicit, it&amp;rsquo;s also a little bit overkill. One of the nice things about the original version of &lt;code&gt;padLeft&lt;/code&gt; was that we were able to just pass in primitives. That meant that usage was simple and concise. This new approach also wouldn&amp;rsquo;t help if we were just trying to use a function that already exists elsewhere.</source>
          <target state="translated">전통적인 객체 지향 코드에서는 유형의 계층 구조를 만들어 두 유형을 추상화 할 수 있습니다. 이것은 훨씬 더 명시 적이지만 약간 과잉입니다. &lt;code&gt;padLeft&lt;/code&gt; 의 원래 버전에 대한 좋은 점 중 하나는 프리미티브를 전달할 수 있다는 것입니다. 그것은 사용법이 간단하고 간결하다는 것을 의미했습니다. 이 새로운 접근법은 우리가 이미 다른 곳에 존재하는 함수를 사용하려고 시도해도 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3797c645e8a8c499cfcb7b4049e4893eece69214" translate="yes" xml:space="preserve">
          <source>In your editor, type the following JavaScript code in &lt;code&gt;greeter.ts&lt;/code&gt;:</source>
          <target state="translated">편집기에서 &lt;code&gt;greeter.ts&lt;/code&gt; 에 다음 JavaScript 코드를 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="4dbe40d3f9dd76b0ebc598a2769c3f694b16d1ea" translate="yes" xml:space="preserve">
          <source>Include modules imported with &lt;code&gt;.json&lt;/code&gt; extension.</source>
          <target state="translated">&lt;code&gt;.json&lt;/code&gt; 확장자로 가져온 모듈을 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="6898584222dc5329b65b711cc8ca941a2e824a68" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;.js&lt;/code&gt; files with &lt;code&gt;--allowJs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--allowJs&lt;/code&gt; 와 함께 &lt;code&gt;.js&lt;/code&gt; 파일 포함</target>
        </trans-unit>
        <trans-unit id="ab817f6003eff1222b8c915e012bd4827feb5c30" translate="yes" xml:space="preserve">
          <source>Including built-in type declarations with &lt;code&gt;--lib&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--lib&lt;/code&gt; 와 함께 내장형 선언 포함</target>
        </trans-unit>
        <trans-unit id="c320930067fba589bb3a1d6786d55f841bf144ab" translate="yes" xml:space="preserve">
          <source>Including declarations in your npm package</source>
          <target state="translated">npm 패키지에 선언 포함</target>
        </trans-unit>
        <trans-unit id="9bc53de5c2f8d2c282bf0578d8a05703182b23ad" translate="yes" xml:space="preserve">
          <source>Incremental file watching for composite projects in &lt;code&gt;--build --watch&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--build --watch&lt;/code&gt; 에서 복합 프로젝트에 대한 증분 파일 감시</target>
        </trans-unit>
        <trans-unit id="5eccb92925bc3929eabb42f52bbdf91059031375" translate="yes" xml:space="preserve">
          <source>Index types</source>
          <target state="translated">색인 유형</target>
        </trans-unit>
        <trans-unit id="0b06669b4c136bdf3d1ec21cafd1d15df80fad00" translate="yes" xml:space="preserve">
          <source>Index types and index signatures</source>
          <target state="translated">색인 유형 및 색인 서명</target>
        </trans-unit>
        <trans-unit id="aaf103e4bce1dd95f1b6e037cb4cf33238541524" translate="yes" xml:space="preserve">
          <source>Indexable Types</source>
          <target state="translated">인덱서 블 타입</target>
        </trans-unit>
        <trans-unit id="3260fe038f2a1e9f4a6bf5d1a731cf910deb01de" translate="yes" xml:space="preserve">
          <source>Inference from mapped types</source>
          <target state="translated">매핑 된 형식에서 유추</target>
        </trans-unit>
        <trans-unit id="72e097bb1e3bc0e862f9bef6c7816dfc1cfe0932" translate="yes" xml:space="preserve">
          <source>Inferring the types</source>
          <target state="translated">유형 유추</target>
        </trans-unit>
        <trans-unit id="fdaddb9ce367c2ca746a97cc24d2e8817a51f27d" translate="yes" xml:space="preserve">
          <source>Inheritance</source>
          <target state="translated">Inheritance</target>
        </trans-unit>
        <trans-unit id="29c771a275b4fc168c6e9a9b4f16f9f866101cf5" translate="yes" xml:space="preserve">
          <source>Initialize the project</source>
          <target state="translated">프로젝트 초기화</target>
        </trans-unit>
        <trans-unit id="0223edbd4b306241485da6ea36e04c5f73dc76b6" translate="yes" xml:space="preserve">
          <source>Initializes a TypeScript project and creates a &lt;code&gt;tsconfig.json&lt;/code&gt; file.</source>
          <target state="translated">TypeScript 프로젝트를 초기화하고 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="d40721226c9107841a5c9b9ca80d5a8dfbb2c0d8" translate="yes" xml:space="preserve">
          <source>Initializing an object with dynamic properties can be a bit of a burden. Take the following example:</source>
          <target state="translated">동적 속성으로 객체를 초기화하는 것은 약간의 부담이 될 수 있습니다. 다음 예제를 보자.</target>
        </trans-unit>
        <trans-unit id="b568d47f2e244743b1fd7472db836ef9769c21f8" translate="yes" xml:space="preserve">
          <source>Input</source>
          <target state="translated">Input</target>
        </trans-unit>
        <trans-unit id="48ea5eb348b8b2f027b76b2af44bc6ce31c449b9" translate="yes" xml:space="preserve">
          <source>Inside the &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; section of the &lt;code&gt;package.json&lt;/code&gt; file, add &lt;em&gt;gulp&lt;/em&gt; and &lt;em&gt;del&lt;/em&gt;</source>
          <target state="translated">내부 &lt;code&gt;&quot;devDependencies&quot;&lt;/code&gt; 의 섹션 &lt;code&gt;package.json&lt;/code&gt; 의 파일, 추가 &lt;em&gt;꿀꺽&lt;/em&gt; 와 &lt;em&gt;델을&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fd6c3ebf7befca9f8208f86c76e4d4180303745c" translate="yes" xml:space="preserve">
          <source>Install</source>
          <target state="translated">Install</target>
        </trans-unit>
        <trans-unit id="e922164fa8e7b23fe5db7d0703923eff79dbef32" translate="yes" xml:space="preserve">
          <source>Install ASP.NET Core and TypeScript</source>
          <target state="translated">ASP.NET Core 및 TypeScript 설치</target>
        </trans-unit>
        <trans-unit id="1e48e8ef34685eb17d478c13cfd199caadcb3708" translate="yes" xml:space="preserve">
          <source>Install our dependencies</source>
          <target state="translated">의존성 설치</target>
        </trans-unit>
        <trans-unit id="e371877bb54c12671888c28362c3b32432ec40a5" translate="yes" xml:space="preserve">
          <source>Installing TypeScript</source>
          <target state="translated">TypeScript 설치</target>
        </trans-unit>
        <trans-unit id="98a0fba8620f4d80c37344d00d25fe24a9d88fbd" translate="yes" xml:space="preserve">
          <source>InstanceType&amp;lt;T&amp;gt;</source>
          <target state="translated">InstanceType&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ef07ef5ff526694802527d041e5b29af71c04bd8" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;Object&lt;/code&gt;, use the non-primitive &lt;code&gt;object&lt;/code&gt; type (&lt;a href=&quot;../release-notes/typescript-2-2#object-type&quot;&gt;added in TypeScript 2.2&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;Object&lt;/code&gt; 대신 기본이 아닌 &lt;code&gt;object&lt;/code&gt; 유형 ( &lt;a href=&quot;../release-notes/typescript-2-2#object-type&quot;&gt;TypeScript 2.2에 추가&lt;/a&gt; )을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ee6363c045a14fb760ecdd97fa1210a76455315e" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;any&lt;/code&gt;, we can use a &lt;em&gt;union type&lt;/em&gt; for the &lt;code&gt;padding&lt;/code&gt; parameter:</source>
          <target state="translated">&lt;code&gt;any&lt;/code&gt; 대신에 &lt;code&gt;padding&lt;/code&gt; 매개 변수에 &lt;em&gt;공용체 유형&lt;/em&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1fdeb6abb8961fb107ac368ef09e36ad9963ee3" translate="yes" xml:space="preserve">
          <source>Instead of a relatively useless type like &lt;code&gt;(x: {}) =&amp;gt; Box&amp;lt;{}[]&amp;gt;&lt;/code&gt;, which older versions of the language would infer, TypeScript 3.4&amp;rsquo;s inference allows &lt;code&gt;newFn&lt;/code&gt; to be generic. Its new type is &lt;code&gt;&amp;lt;T&amp;gt;(x: T) =&amp;gt; Box&amp;lt;T[]&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이전 버전의 언어에서 추론 할 수있는 &lt;code&gt;(x: {}) =&amp;gt; Box&amp;lt;{}[]&amp;gt;&lt;/code&gt; 와 같이 비교적 쓸모없는 유형 대신 TypeScript 3.4의 추론을 통해 &lt;code&gt;newFn&lt;/code&gt; 을 일반화 할 수 있습니다. 새로운 유형은 &lt;code&gt;&amp;lt;T&amp;gt;(x: T) =&amp;gt; Box&amp;lt;T[]&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f41af89aee0ce0aa8f256c662d27ad424fd39973" translate="yes" xml:space="preserve">
          <source>Instead of working with any and all types, we&amp;rsquo;d like to constrain this function to work with any and all types that also have the &lt;code&gt;.length&lt;/code&gt; property. As long as the type has this member, we&amp;rsquo;ll allow it, but it&amp;rsquo;s required to have at least this member. To do so, we must list our requirement as a constraint on what T can be.</source>
          <target state="translated">모든 유형의 작업을 수행하는 대신이 함수가 &lt;code&gt;.length&lt;/code&gt; 속성 이있는 모든 유형에서 작동하도록 제한 하려고 합니다. 유형에이 멤버가있는 한 허용하지만 최소한이 멤버가 있어야합니다. 그렇게하려면 T가 무엇인지에 대한 제약 조건으로 요구 사항을 나열해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e88339b09438dc6ef45500af5364169862881c3" translate="yes" xml:space="preserve">
          <source>Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a &lt;em&gt;type variable&lt;/em&gt;, a special kind of variable that works on types rather than values.</source>
          <target state="translated">대신, 인수 유형을 캡처하여 리턴되는 내용을 표시 할 수있는 방식으로 인수 유형을 캡처하는 방법이 필요합니다. 여기서는 값이 아닌 유형에서 작동하는 특수한 &lt;em&gt;유형의 변수&lt;/em&gt; 인 &lt;em&gt;type variable&lt;/em&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="877c391d483e3da8842226931c49930770980487" translate="yes" xml:space="preserve">
          <source>Instead, we need to pass in values whose type has all the required properties:</source>
          <target state="translated">대신 유형에 필요한 모든 속성이있는 값을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="01593ae1a34a1c7e14f63f2874056a43c2031680" translate="yes" xml:space="preserve">
          <source>Instead, you would need to work with the static side of the class directly. In this example, we define two interfaces, &lt;code&gt;ClockConstructor&lt;/code&gt; for the constructor and &lt;code&gt;ClockInterface&lt;/code&gt; for the instance methods. Then, for convenience, we define a constructor function &lt;code&gt;createClock&lt;/code&gt; that creates instances of the type that is passed to it:</source>
          <target state="translated">대신 클래스의 정적 측면을 직접 사용해야합니다. 이 예제에서는 생성자를 위한 &lt;code&gt;ClockInterface&lt;/code&gt; 와 인스턴스 메소드를위한 &lt;code&gt;ClockConstructor&lt;/code&gt; 두 가지 인터페이스를 정의 합니다. 그런 다음 편의상 전달 된 형식의 인스턴스를 만드는 생성자 함수 &lt;code&gt;createClock&lt;/code&gt; 을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="e3192428f7f4fc6017fd4b426dc0b119b5a30e14" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools</source>
          <target state="translated">빌드 도구와 통합</target>
        </trans-unit>
        <trans-unit id="22212097f0e33b11964a53f929fec73cee63a40c" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Babel</source>
          <target state="translated">빌드 도구와 통합 : Babel</target>
        </trans-unit>
        <trans-unit id="9dbaa1369f5ee20cc334fa494b2df4b92581aa4c" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Browserify</source>
          <target state="translated">빌드 도구와 통합 : Browserify</target>
        </trans-unit>
        <trans-unit id="3ec7ffbef629ea76ad15ce276ed9ecdb2cc592e5" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Duo</source>
          <target state="translated">빌드 도구와 통합 : Duo</target>
        </trans-unit>
        <trans-unit id="fbba0594dd61ce66de3d77f11bfcd50051321332" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Grunt</source>
          <target state="translated">빌드 툴과 통합 : Grunt</target>
        </trans-unit>
        <trans-unit id="ffe5a64fcf1dd3fb7dd23d6ac3c6b86ef5e5925e" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Gulp</source>
          <target state="translated">빌드 도구와 통합 : Gulp</target>
        </trans-unit>
        <trans-unit id="aa266b141c65598c72592d75b9246ecc79078e35" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Jspm</source>
          <target state="translated">빌드 도구와 통합 : Jspm</target>
        </trans-unit>
        <trans-unit id="70482080c6efdc1c68f0832eaaf93423e1e5b273" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: MSBuild</source>
          <target state="translated">빌드 도구와 통합 : MSBuild</target>
        </trans-unit>
        <trans-unit id="ab83f8abf8483dec13ed24ba6d2e9eb284f56ffa" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: NuGet</source>
          <target state="translated">빌드 도구와 통합 : NuGet</target>
        </trans-unit>
        <trans-unit id="d40c6086bb9387a195dd8b229c344fef47424fa3" translate="yes" xml:space="preserve">
          <source>Integrating with Build Tools: Webpack</source>
          <target state="translated">빌드 도구와 통합 : Webpack</target>
        </trans-unit>
        <trans-unit id="50c62dd2c72c526623cd3aa97cdf9e954ed24d3d" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA (Mac)</source>
          <target state="translated">IntelliJ IDEA (Mac)</target>
        </trans-unit>
        <trans-unit id="786f15960455f4c51ef85df82efd7a27a91dc1ba" translate="yes" xml:space="preserve">
          <source>IntelliJ IDEA (Windows)</source>
          <target state="translated">IntelliJ IDEA (Windows)</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="b356313f979923fc829adb909098ed26a5a01aff" translate="yes" xml:space="preserve">
          <source>Interfaces</source>
          <target state="translated">Interfaces</target>
        </trans-unit>
        <trans-unit id="92daefb7ec0fc8b648c80aca28475265591e79ec" translate="yes" xml:space="preserve">
          <source>Interfaces Extending Classes</source>
          <target state="translated">클래스 확장 인터페이스</target>
        </trans-unit>
        <trans-unit id="96e2b4ca11436e61acf1d8a96fcf247872f1b2ff" translate="yes" xml:space="preserve">
          <source>Interfaces are capable of describing the wide range of shapes that JavaScript objects can take. In addition to describing an object with properties, interfaces are also capable of describing function types.</source>
          <target state="translated">인터페이스는 JavaScript 객체가 취할 수있는 광범위한 모양을 설명 할 수 있습니다. 속성이있는 객체를 설명하는 것 외에도 인터페이스는 함수 유형을 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1182e7a77aad9fb1ced581374b610320fa4806c8" translate="yes" xml:space="preserve">
          <source>Interfaces describe the public side of the class, rather than both the public and private side. This prohibits you from using them to check that a class also has particular types for the private side of the class instance.</source>
          <target state="translated">인터페이스는 공개 및 비공개 측면이 아니라 클래스의 공개 측면을 설명합니다. 이렇게하면 클래스를 사용하여 클래스에 클래스 인스턴스의 전용 측면에 대한 특정 유형이 있는지 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="296b5977caa1cbec518b7e75c1da7e2fd0eaa696" translate="yes" xml:space="preserve">
          <source>Interfaces vs. Type Aliases</source>
          <target state="translated">인터페이스 대 유형 별명</target>
        </trans-unit>
        <trans-unit id="54fe00f4a20d8d06ce299185a910049d83b48bdd" translate="yes" xml:space="preserve">
          <source>Interfaces with optional properties are written similar to other interfaces, with each optional property denoted by a &lt;code&gt;?&lt;/code&gt; at the end of the property name in the declaration.</source>
          <target state="translated">선택적 속성이있는 인터페이스는 다른 인터페이스와 유사하게 작성되며 각 선택적 속성은 &lt;code&gt;?&lt;/code&gt; 선언에서 속성 이름 끝에</target>
        </trans-unit>
        <trans-unit id="ef35fc41614978724e53f8c707770be7d1309ab3" translate="yes" xml:space="preserve">
          <source>Intersection Types</source>
          <target state="translated">교차로 유형</target>
        </trans-unit>
        <trans-unit id="b87d8878892520ebb9edc358d8dd9e3d44011f0c" translate="yes" xml:space="preserve">
          <source>Intersection types</source>
          <target state="translated">교차로 유형</target>
        </trans-unit>
        <trans-unit id="c8bf0e8c1ae3e60a82098f1409f6db85661db7a9" translate="yes" xml:space="preserve">
          <source>Intrinsic elements</source>
          <target state="translated">본질적인 요소</target>
        </trans-unit>
        <trans-unit id="f97123626594d771751041a210b6256d26fd2930" translate="yes" xml:space="preserve">
          <source>Intrinsic elements are looked up on the special interface &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt;. By default, if this interface is not specified, then anything goes and intrinsic elements will not be type checked. However, if this interface &lt;em&gt;is&lt;/em&gt; present, then the name of the intrinsic element is looked up as a property on the &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; interface. For example:</source>
          <target state="translated">내장 요소는 특수 인터페이스 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 에서 조회 됩니다. 기본적으로이 인터페이스를 지정하지 않으면 모든 것이 진행되고 내장 요소는 유형 검사되지 않습니다. 그러나이 인터페이스 &lt;em&gt;가&lt;/em&gt; 있으면 내장 요소의 이름이 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 인터페이스 에서 특성으로 검색 됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="92a605a41a1bfb9eec6573b6d10084310be8afb9" translate="yes" xml:space="preserve">
          <source>Introduction: Deep Dive</source>
          <target state="translated">소개 : 딥 다이브</target>
        </trans-unit>
        <trans-unit id="88ac7b281daf4911d47c89c86d34416225280141" translate="yes" xml:space="preserve">
          <source>Introduction: Find and Install Declaration Files</source>
          <target state="translated">소개 : 선언 파일 찾기 및 설치</target>
        </trans-unit>
        <trans-unit id="4f8abbfcfad58ab5902f7d7dad80570ab5c1e9de" translate="yes" xml:space="preserve">
          <source>Introduction: Library Structures</source>
          <target state="translated">소개 : 라이브러리 구조</target>
        </trans-unit>
        <trans-unit id="be4e2ac8a7225060bbaf50e88cd4c64bbb2b91e0" translate="yes" xml:space="preserve">
          <source>Introduction: Publish to npm</source>
          <target state="translated">소개 : npm에 게시</target>
        </trans-unit>
        <trans-unit id="d9cf5daf5910fcc22fa06cac1c556299707a4e15" translate="yes" xml:space="preserve">
          <source>Introduction: Sections</source>
          <target state="translated">소개 : 섹션</target>
        </trans-unit>
        <trans-unit id="9da99d0d81d3d8dfe82f617de62c7c013f3809b6" translate="yes" xml:space="preserve">
          <source>Introduction: Templates</source>
          <target state="translated">소개 : 템플릿</target>
        </trans-unit>
        <trans-unit id="4744b3b706d889422bd89021c824c3afa8c9a741" translate="yes" xml:space="preserve">
          <source>Introduction: “Do”s and “Don’t”s</source>
          <target state="translated">소개 :&amp;ldquo;해야 할 일&amp;rdquo;과&amp;ldquo;하지 말아야 할 것&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="3e7c599bec18d30837143fafc667da7bae8fb3ce" translate="yes" xml:space="preserve">
          <source>Invoking &lt;code&gt;tsc&lt;/code&gt; twice incurs more startup time overhead</source>
          <target state="translated">&lt;code&gt;tsc&lt;/code&gt; 를 두 번 호출하면 더 많은 시작 시간 오버 헤드가 발생합니다</target>
        </trans-unit>
        <trans-unit id="580856a132ab9d88e4420d07722840d0bee558f0" translate="yes" xml:space="preserve">
          <source>Invoking the compiler with &lt;code&gt;--alwaysStrict&lt;/code&gt; causes:</source>
          <target state="translated">&lt;code&gt;--alwaysStrict&lt;/code&gt; 를 사용 하여 컴파일러를 호출하면 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2aa2b4b449585e3cac683fe9949dde17f0c4900d" translate="yes" xml:space="preserve">
          <source>Invoking the compiler with &lt;code&gt;--traceResolution&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--traceResolution&lt;/code&gt; 을 사용 하여 컴파일러 호출</target>
        </trans-unit>
        <trans-unit id="95f0156bbb4c60fc06035b7f6f73dc250490e988" translate="yes" xml:space="preserve">
          <source>It can also be used as a global variable, but only inside of a script. (A script is a file with no imports or exports.)</source>
          <target state="translated">전역 변수로도 사용할 수 있지만 스크립트 내에서만 사용할 수 있습니다. (스크립트는 가져 오기 또는 내보내기가없는 파일입니다.)</target>
        </trans-unit>
        <trans-unit id="a4a4a00d6a8d5c101bf84b8d87236b25e876e72f" translate="yes" xml:space="preserve">
          <source>It can also be used to create simple namespaces:</source>
          <target state="translated">간단한 네임 스페이스를 만드는 데 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4806c2a5b8c0aca238175b098dcd2585b109419d" translate="yes" xml:space="preserve">
          <source>It does not have an initializer and the preceding enum member was a &lt;em&gt;numeric&lt;/em&gt; constant. In this case the value of the current enum member will be the value of the preceding enum member plus one.</source>
          <target state="translated">이니셜 라이저가 없으며 앞의 열거 형 멤버가 &lt;em&gt;숫자&lt;/em&gt; 상수였습니다. 이 경우 현재 열거 형 멤버의 값은 선행 열거 형 멤버의 값에 1을 더한 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="ae3a8ea5fd61fc3c908eab11fa4a4f9073d77d83" translate="yes" xml:space="preserve">
          <source>It is a common pattern to return the current object (i.e. &lt;code&gt;this&lt;/code&gt;) from a method to create &lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;fluent-style APIs&lt;/a&gt;. For instance, consider the following &lt;code&gt;BasicCalculator&lt;/code&gt; module:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Fluent_interface&quot;&gt;유창한 스타일의 API&lt;/a&gt; 를 생성하는 메소드에서 현재 객체 (예 : &lt;code&gt;this&lt;/code&gt; ) 를 반환하는 일반적인 패턴 입니다. 예를 들어 다음 &lt;code&gt;BasicCalculator&lt;/code&gt; 모듈을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="62ffe9a036a8fbf5b41aec16bc2aa0caa4f8a019" translate="yes" xml:space="preserve">
          <source>It is a compile time error for constant enum expressions to be evaluated to &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Infinity&lt;/code&gt;.</source>
          <target state="translated">상수 열거 형 표현식이 &lt;code&gt;NaN&lt;/code&gt; 또는 &lt;code&gt;Infinity&lt;/code&gt; 로 평가되는 것은 컴파일 시간 오류입니다 .</target>
        </trans-unit>
        <trans-unit id="99b3cb57ca8b4b1d02c5836ced85b9301080e00f" translate="yes" xml:space="preserve">
          <source>It is also worth noting that, for Node.js applications, modules are the default and the recommended approach to structure your code.</source>
          <target state="translated">Node.js 응용 프로그램의 경우 모듈이 기본이며 코드를 구성하는 데 권장되는 접근 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f083343eb50dcd945be59c0708845b66b4753dc5" translate="yes" xml:space="preserve">
          <source>It is an error to reference a file that does not exist. It is an error for a file to have a triple-slash reference to itself.</source>
          <target state="translated">존재하지 않는 파일을 참조하는 것은 오류입니다. 파일 자체에 트리플 슬래시 참조가있는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="3f74a022e24576b8bca3c7e9007ad3819041ef57" translate="yes" xml:space="preserve">
          <source>It is important to note that it is an error to call a function with too many arguments.</source>
          <target state="translated">너무 많은 인수를 가진 함수를 호출하는 것은 오류라는 점에 유의해야합니다.</target>
        </trans-unit>
        <trans-unit id="be67ce2203241cd9f4ea1e5b61ef39e52b2d569c" translate="yes" xml:space="preserve">
          <source>It is important to note that the compiler will &lt;em&gt;not&lt;/em&gt; perform any of these transformations; it just uses these pieces of information to guide the process of resolving a module import to its definition file.</source>
          <target state="translated">컴파일러는 이러한 변환을 수행하지 &lt;em&gt;않습니다&lt;/em&gt; . 이 정보를 사용하여 모듈 가져 오기를 정의 파일로 해결하는 프로세스를 안내합니다.</target>
        </trans-unit>
        <trans-unit id="1efd3564ec8a22d45891c5ad072535fbd6663440" translate="yes" xml:space="preserve">
          <source>It is not possible to use &lt;code&gt;infer&lt;/code&gt; declarations in constraint clauses for regular type parameters:</source>
          <target state="translated">일반 유형 매개 변수에 대한 제한 조건 절에서 &lt;code&gt;infer&lt;/code&gt; 선언 을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="78ecb7e98034ba8c6a31702e1802139e82a8abee" translate="yes" xml:space="preserve">
          <source>It is possible to define the type of a class component. However, to do so it is best to understand two new terms: the &lt;em&gt;element class type&lt;/em&gt; and the &lt;em&gt;element instance type&lt;/em&gt;.</source>
          <target state="translated">클래스 구성 요소의 유형을 정의 할 수 있습니다. 그러나 그렇게하려면 &lt;em&gt;요소 클래스 유형&lt;/em&gt; 과 &lt;em&gt;요소 인스턴스 유형의&lt;/em&gt; 두 가지 새로운 용어를 이해하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="3393d397de3e56585237bbbf12b74b296eb1e0ea" translate="yes" xml:space="preserve">
          <source>It is the first member in the enum and it has no initializer, in which case it&amp;rsquo;s assigned the value &lt;code&gt;0&lt;/code&gt;:</source>
          <target state="translated">열거 형의 첫 번째 멤버이며 초기화 프로그램이 없으므로 &lt;code&gt;0&lt;/code&gt; 값이 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f0bcd520e9a01c5bb05819edfd82f1aa74077c5" translate="yes" xml:space="preserve">
          <source>It is worth noting that if the npm package already includes its declaration file as described in &lt;a href=&quot;publishing&quot;&gt;Publishing&lt;/a&gt;, downloading the corresponding &lt;code&gt;@types&lt;/code&gt; package is not needed.</source>
          <target state="translated">npm 패키지에 &lt;a href=&quot;publishing&quot;&gt;Publishing에&lt;/a&gt; 설명 된대로 선언 파일이 이미 포함되어 있으면 해당 &lt;code&gt;@types&lt;/code&gt; 패키지를 다운로드 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cf377c6233f3ae5de354c35e343aab9bdd355017" translate="yes" xml:space="preserve">
          <source>It just so happens that TypeScript has something called a &lt;em&gt;type guard&lt;/em&gt;. A type guard is some expression that performs a runtime check that guarantees the type in some scope.</source>
          <target state="translated">TypeScript에는 &lt;em&gt;type guard&lt;/em&gt; 라는 것이 있습니다. 타입 가드는 타입 범위를 보장하는 런타임 검사를 수행하는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="63c224c58a227f7ca3d5c83c05a2c04331b2b180" translate="yes" xml:space="preserve">
          <source>It was possible for the implementation files to import the test files</source>
          <target state="translated">구현 파일이 테스트 파일을 가져올 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="32c6f037d7103d04bf695eff504eb483c338105a" translate="yes" xml:space="preserve">
          <source>It wasn&amp;rsquo;t possible to build &lt;code&gt;test&lt;/code&gt; and &lt;code&gt;src&lt;/code&gt; at the same time without having &lt;code&gt;src&lt;/code&gt; appear in the output folder name, which you probably don&amp;rsquo;t want</source>
          <target state="translated">출력 폴더 이름에 &lt;code&gt;src&lt;/code&gt; 가 나타나지 않으면 &lt;code&gt;test&lt;/code&gt; 와 &lt;code&gt;src&lt;/code&gt; 를 동시에 빌드 할 수 없었습니다.</target>
        </trans-unit>
        <trans-unit id="dae1101862749291ae4f393bc2ced9ae6e2e1e04" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also common to try to access a method before &lt;code&gt;await&lt;/code&gt;-ing or &lt;code&gt;.then()&lt;/code&gt;-ing a &lt;code&gt;Promise&lt;/code&gt;. This is another example, among many others, where we&amp;rsquo;re able to do better.</source>
          <target state="translated">그것은 이전하는 방법에 액세스하려고하는 것이 일반적입니다 &lt;code&gt;await&lt;/code&gt; 를 -ing 나 &lt;code&gt;.then()&lt;/code&gt; -ing &lt;code&gt;Promise&lt;/code&gt; . 이것은 우리가 더 잘할 수있는 다른 많은 사례 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="cb42ff8fbd52b3c44d6730e6b6e080e1b24c9119" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s also important to note that TypeScript doesn&amp;rsquo;t transform references to &lt;code&gt;globalThis&lt;/code&gt; when compiling to older versions of ECMAScript. As such, unless you&amp;rsquo;re targeting evergreen browsers (which already support &lt;code&gt;globalThis&lt;/code&gt;), you may want to &lt;a href=&quot;https://github.com/ljharb/globalThis&quot;&gt;use an appropriate polyfill&lt;/a&gt; instead.</source>
          <target state="translated">또한 TypeScript는 이전 버전의 ECMAScript로 컴파일 할 때 &lt;code&gt;globalThis&lt;/code&gt; 에 대한 참조를 변환하지 않습니다 . 따라서 이미 &lt;code&gt;globalThis&lt;/code&gt; 를 지원하는 상록 브라우저를 대상으로하지 않는 &lt;a href=&quot;https://github.com/ljharb/globalThis&quot;&gt;한 적절한 폴리 필을&lt;/a&gt; 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e464e560c1d455645701c6f4e6f1a57f254a2a8d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s always nice to be able to document your configuration! &lt;code&gt;tsconfig.json&lt;/code&gt; now accepts single and multi-line comments.</source>
          <target state="translated">구성을 문서화 할 수있는 것이 좋습니다. &lt;code&gt;tsconfig.json&lt;/code&gt; 은 이제 한 줄 및 여러 줄 주석을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="4bd81a3c45eee4646f38cdbd9c1c1ad1a29861b2" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s an error to destructure a tuple beyond the range of its elements:</source>
          <target state="translated">요소의 범위를 넘어 튜플을 구조화하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="8a9920985b571f2cfef7325bc2d8544e7b54739d" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important in this situation to not prepend at each reference, because you&amp;rsquo;ll end up with two copies of &lt;code&gt;A&lt;/code&gt; in the output of &lt;code&gt;D&lt;/code&gt; - this can lead to unexpected results.</source>
          <target state="translated">이 상황에서 각 참조 앞에 붙지 않는 것이 중요합니다. &lt;code&gt;D&lt;/code&gt; 의 출력에서 &lt;code&gt;A&lt;/code&gt; 의 사본 두 개로 끝나기 때문에 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97ea9b1bc3713a2cc3d96cf61a87c436f5f16077" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to note that awesome-typescript-loader will need to run before any other loader that deals with &lt;code&gt;.js&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; 파일 을 처리하는 다른 로더보다 먼저 awesome-typescript-loader를 실행해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ad109c65e3188cac84e48f320d15d4fae5d7f0a7" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not uncommon for an API to expect a specific set of strings for certain values. For instance, consider a UI library that can move elements across the screen while controlling the &lt;a href=&quot;https://en.wikipedia.org/wiki/Inbetweening&quot;&gt;&amp;ldquo;easing&amp;rdquo; of the animation.&lt;/a&gt;</source>
          <target state="translated">API가 특정 값에 대해 특정 문자열 세트를 기대하는 것은 드문 일이 아닙니다. 예를 들어, &lt;a href=&quot;https://en.wikipedia.org/wiki/Inbetweening&quot;&gt;애니메이션&lt;/a&gt; 의 &quot;여유&quot; 를 제어하면서 화면을 가로 질러 요소를 이동할 수있는 UI 라이브러리를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="1423913ba24c08e5752678ce9b4d9c6bc28a43a2" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s worth pointing out that the type checker does not require that these properties come in any sort of order, only that the properties the interface requires are present and have the required type.</source>
          <target state="translated">타입 체커는 이러한 속성들이 어떤 종류의 순서로 오도록 요구할 필요는 없으며 인터페이스에 필요한 속성들이 존재하고 필요한 타입을 가질뿐임을 지적 할 가치가있다.</target>
        </trans-unit>
        <trans-unit id="4dd80eea3f6c51bf5b9c13a8a47609bd55b30e0e" translate="yes" xml:space="preserve">
          <source>Iterables</source>
          <target state="translated">Iterables</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="203e9155620464a525f901cb5421a31b901a89ef" translate="yes" xml:space="preserve">
          <source>Iterators &amp;amp; Generators</source>
          <target state="translated">반복자 및 생성기</target>
        </trans-unit>
        <trans-unit id="99b5cd227ff34de634e9717a978834aba820bbe5" translate="yes" xml:space="preserve">
          <source>Iterators and Generators</source>
          <target state="translated">반복자와 생성기</target>
        </trans-unit>
        <trans-unit id="36347e6c81d6767cb3d6230d14c1fc3fd3e5b4ee" translate="yes" xml:space="preserve">
          <source>JQuery.d.ts</source>
          <target state="translated">JQuery.d.ts</target>
        </trans-unit>
        <trans-unit id="e3449392ff6bd7faf1750366c59ea9d2cae9f435" translate="yes" xml:space="preserve">
          <source>JSDoc annotated functions are excluded from this rule. Use JSDoc optional parameter syntax to express optionality. e.g.:</source>
          <target state="translated">JSDoc 어노테이션이있는 기능은이 규칙에서 제외됩니다. JSDoc 선택적 매개 변수 구문을 사용하여 선택 적성을 표현하십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="a992571945b4a5c87d6bf56acece269e2c17f9ae" translate="yes" xml:space="preserve">
          <source>JSDoc annotations adorning a declaration will be used to set the type of that declaration. For example:</source>
          <target state="translated">선언을 장식하는 JSDoc 주석은 해당 선언의 유형을 설정하는 데 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56567b264de0a6e662152c49ade304ca30e42a64" translate="yes" xml:space="preserve">
          <source>JSDoc types are used for type information</source>
          <target state="translated">JSDoc 유형은 유형 정보에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e4779d05c5a545a6bd2f3323d3fe430a37f5d7b" translate="yes" xml:space="preserve">
          <source>JSX</source>
          <target state="translated">JSX</target>
        </trans-unit>
        <trans-unit id="c9a7b3c3bca23e176771346061c84e126c239c19" translate="yes" xml:space="preserve">
          <source>JSX allows you to embed expressions between tags by surrounding the expressions with curly braces (&lt;code&gt;{ }&lt;/code&gt;).</source>
          <target state="translated">JSX를 사용하면 표현식을 중괄호 ( &lt;code&gt;{ }&lt;/code&gt; )로 묶어 태그 사이에 표현식을 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39068335c89e9baa8ee40bd585e128fbed44107c" translate="yes" xml:space="preserve">
          <source>JSX element names and properties are validated against the &lt;code&gt;JSX&lt;/code&gt; namespace. Please see the [[JSX]] wiki page for defining the &lt;code&gt;JSX&lt;/code&gt; namespace for your framework.</source>
          <target state="translated">JSX 요소 이름 및 특성은 &lt;code&gt;JSX&lt;/code&gt; 네임 스페이스 에 대해 유효성 검증 됩니다. 프레임 워크에 대한 &lt;code&gt;JSX&lt;/code&gt; 네임 스페이스를 정의하려면 [[JSX]] 위키 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c00129d0a4abfd5ac94250f0271eb16efd1bd3c7" translate="yes" xml:space="preserve">
          <source>JSX elements now allow passing type arguments to generic components.</source>
          <target state="translated">JSX 요소는 이제 형식 인수를 일반 구성 요소에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18de8f2d2e7d3ab6aeff186b905d5c34cc12e52a" translate="yes" xml:space="preserve">
          <source>JSX is an embeddable XML-like syntax. It is meant to be transformed into valid JavaScript, but the semantics of that transformation are implementation-specific. JSX came to popularity with the React library but has since seen other applications. TypeScript 1.6 supports embedding, type checking, and optionally compiling JSX directly into JavaScript.</source>
          <target state="translated">JSX는 임베드 가능한 XML 유사 구문입니다. 유효한 JavaScript로 변환되어야하지만 해당 변환의 의미는 구현에 따라 다릅니다. JSX는 React 라이브러리에서 인기를 얻었지만 이후 다른 응용 프로그램을 보았습니다. TypeScript 1.6은 포함, 유형 검사 및 선택적으로 JSX를 JavaScript로 직접 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35be1251a23e865870550e0bb93b3a161d7ed6f9" translate="yes" xml:space="preserve">
          <source>JSX support</source>
          <target state="translated">JSX 지원</target>
        </trans-unit>
        <trans-unit id="96d35d103f80b8423a542d0896d9282bfecda177" translate="yes" xml:space="preserve">
          <source>JSX type checking is driven by definitions in a JSX namespace, for instance &lt;code&gt;JSX.Element&lt;/code&gt; for the type of a JSX element, and &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; for built-in elements. Before TypeScript 2.8 the &lt;code&gt;JSX&lt;/code&gt; namespace was expected to be in the global namespace, and thus only allowing one to be defined in a project. Starting with TypeScript 2.8 the &lt;code&gt;JSX&lt;/code&gt; namespace will be looked under the &lt;code&gt;jsxNamespace&lt;/code&gt; (e.g. &lt;code&gt;React&lt;/code&gt;) allowing for multiple jsx factories in one compilation. For backward compatibility the global &lt;code&gt;JSX&lt;/code&gt; namespace is used as a fallback if none was defined on the factory function. Combined with the per-file &lt;code&gt;@jsx&lt;/code&gt; pragma, each file can have a different JSX factory.</source>
          <target state="translated">JSX 타입 체크는 예를 들면, JSX 정의 네임 스페이스에 의해 구동된다 &lt;code&gt;JSX.Element&lt;/code&gt; JSX 요소의 유형 및 &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 요소 내장한다. TypeScript 2.8 이전에는 &lt;code&gt;JSX&lt;/code&gt; 네임 스페이스가 전역 네임 스페이스에 있어야하므로 프로젝트에서 하나만 정의 할 수있었습니다. TypeScript 2.8부터 &lt;code&gt;JSX&lt;/code&gt; 네임 스페이스는 &lt;code&gt;jsxNamespace&lt;/code&gt; (예 : &lt;code&gt;React&lt;/code&gt; ) 아래 에서 한 번의 컴파일로 여러 jsx 팩토리를 허용합니다. 이전 버전과의 호환성을 위해 전역 &lt;code&gt;JSX&lt;/code&gt; 네임 스페이스는 팩토리 함수에 정의되지 않은 경우 대체로 사용됩니다. 파일 당 &lt;code&gt;@jsx&lt;/code&gt; 와 결합 pragma, 각 파일은 다른 JSX 팩토리를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5814b75aeb763bc1d09322412eaf957f2d26543e" translate="yes" xml:space="preserve">
          <source>JavaScript has a lot of different module syntaxes or conventions: the one in the ECMAScript standard, the one Node already supports (CommonJS), AMD, System.js, and more! For the most part, TypeScript would default to auto-importing using ECMAScript module syntax, which was often inappropriate in certain TypeScript projects with different compiler settings, or in Node projects with plain JavaScript and &lt;code&gt;require&lt;/code&gt; calls.</source>
          <target state="translated">JavaScript에는 ECMAScript 표준의 하나, Node가 이미 (CommonJS), AMD, System.js 등을 지원하는 다양한 모듈 구문 또는 규칙이 있습니다! 대부분의 경우 TypeScript는 기본적으로 ECMAScript 모듈 구문을 사용하여 자동 가져 오기로 기본 설정되며, 이는 컴파일러 설정이 다른 특정 TypeScript 프로젝트 또는 일반 JavaScript가있는 노드 프로젝트에서 부적절 &lt;code&gt;require&lt;/code&gt; 호출이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="6de0d5c33105af7de987fd16c4c5f05a9230e4fc" translate="yes" xml:space="preserve">
          <source>JavaScript is inherently a very dynamic language. It&amp;rsquo;s not uncommon for a single JavaScript function to return different types of objects based on the shape of the arguments passed in.</source>
          <target state="translated">JavaScript는 본질적으로 매우 역동적 인 언어입니다. 단일 JavaScript 함수가 전달 된 인수의 모양에 따라 다른 유형의 객체를 반환하는 것은 드문 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7196497deb2208abcd944f2734a4a8cd07bbe990" translate="yes" xml:space="preserve">
          <source>Jspm</source>
          <target state="translated">Jspm</target>
        </trans-unit>
        <trans-unit id="a2fb0be4963908fbe076c5e18c4d463d46dfdc5e" translate="yes" xml:space="preserve">
          <source>Just as &amp;ldquo;exporting near the top-level&amp;rdquo; reduces friction on your module&amp;rsquo;s consumers, so does introducing a default export. If a module&amp;rsquo;s primary purpose is to house one specific export, then you should consider exporting it as a default export. This makes both importing and actually using the import a little easier. For example:</source>
          <target state="translated">&quot;최상위 수준에 가까운 내보내기&quot;가 모듈 소비자의 마찰을 줄이는 것처럼 기본 내보내기도 도입됩니다. 모듈의 주요 목적이 하나의 특정 내보내기를 저장하는 것이라면 기본 내보내기로 내보내는 것을 고려해야합니다. 이를 통해 가져 오기와 실제로 가져 오기를 조금 더 쉽게 수행 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d035ba479610b88ab3f44fd6721d6d5b47bab897" translate="yes" xml:space="preserve">
          <source>Just as in JavaScript, functions can refer to variables outside of the function body. When they do so, they&amp;rsquo;re said to &lt;em&gt;capture&lt;/em&gt; these variables. While understanding how this works (and the trade-offs when using this technique) is outside of the scope of this article, having a firm understanding how this mechanic works is an important piece of working with JavaScript and TypeScript.</source>
          <target state="translated">JavaScript에서와 마찬가지로 함수는 함수 본문 외부의 변수를 참조 할 수 있습니다. 그들이 그렇게 할 때, 그들은 이 변수 들을 &lt;em&gt;포착&lt;/em&gt; 한다고 합니다. 이것이 어떻게 작동하는지 (그리고이 기술을 사용할 때의 트레이드 오프) 이해하는 것은이 기사의 범위를 벗어나는 것이지만,이 메커니즘이 어떻게 작동하는지 이해하는 것은 JavaScript 및 TypeScript를 사용하는 중요한 부분입니다.</target>
        </trans-unit>
        <trans-unit id="e42c4ea3c8c69c9835a8ffa699912e1dc17b476c" translate="yes" xml:space="preserve">
          <source>Just as there is a one-to-one correspondence between JS files and modules, TypeScript has a one-to-one correspondence between module source files and their emitted JS files. One effect of this is that it&amp;rsquo;s not possible to concatenate multiple module source files depending on the module system you target. For instance, you can&amp;rsquo;t use the &lt;code&gt;outFile&lt;/code&gt; option while targeting &lt;code&gt;commonjs&lt;/code&gt; or &lt;code&gt;umd&lt;/code&gt;, but with TypeScript 1.8 and later, &lt;a href=&quot;release-notes/typescript-1-8#concatenate-amd-and-system-modules-with---outfile&quot;&gt;it&amp;rsquo;s possible&lt;/a&gt; to use &lt;code&gt;outFile&lt;/code&gt; when targeting &lt;code&gt;amd&lt;/code&gt; or &lt;code&gt;system&lt;/code&gt;.</source>
          <target state="translated">JS 파일과 모듈간에 일대일 대응이있는 것처럼 TypeScript는 모듈 소스 파일과 방출 된 JS 파일 사이에 일대일 대응이 있습니다. 이것의 한 가지 효과는 대상 모듈 시스템에 따라 여러 개의 모듈 소스 파일을 연결할 수 없다는 것입니다. 예를 들어 &lt;code&gt;commonjs&lt;/code&gt; 또는 &lt;code&gt;umd&lt;/code&gt; 를 대상으로하는 동안 &lt;code&gt;outFile&lt;/code&gt; 옵션을 사용할 수 없지만 TypeScript 1.8 이상에서는 &lt;code&gt;amd&lt;/code&gt; 또는 &lt;code&gt;system&lt;/code&gt; 을 대상으로 하는 경우 &lt;code&gt;outFile&lt;/code&gt; 을 사용할 &lt;a href=&quot;release-notes/typescript-1-8#concatenate-amd-and-system-modules-with---outfile&quot;&gt;수 &lt;/a&gt;있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2ceed31b51e352f32e51cd21fbc2af5be43b412" translate="yes" xml:space="preserve">
          <source>Just as with interface, putting the type parameter on the class itself lets us make sure all of the properties of the class are working with the same type.</source>
          <target state="translated">인터페이스와 마찬가지로 클래스 자체에 type 매개 변수를 지정하면 클래스의 모든 속성이 동일한 유형으로 작동하는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d37f6d0d224175d9c14bf98baa6ad7248f29798" translate="yes" xml:space="preserve">
          <source>Just like all global namespace pollution, it can be hard to identify component dependencies, especially in a large application.</source>
          <target state="translated">모든 글로벌 네임 스페이스 오염과 마찬가지로, 특히 대규모 응용 프로그램에서 구성 요소 종속성을 식별하기가 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2f08fadea784d51622be345d4e8e8eadd88d668" translate="yes" xml:space="preserve">
          <source>Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:</source>
          <target state="translated">인터페이스와 마찬가지로 타입 별칭도 일반적 일 수 있습니다. 타입 파라미터를 추가하고 별칭 선언의 오른쪽에서 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="025c330d74702a4acd5017db2925ef6790f2b67b" translate="yes" xml:space="preserve">
          <source>Just like namespaces, modules can contain both code and declarations. The main difference is that modules &lt;em&gt;declare&lt;/em&gt; their dependencies.</source>
          <target state="translated">네임 스페이스와 마찬가지로 모듈은 코드와 선언을 모두 포함 할 수 있습니다. 가장 큰 차이점은 모듈 이 종속성을 &lt;em&gt;선언&lt;/em&gt; 한다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="40539a34306df46457893cadb44a5176185146b1" translate="yes" xml:space="preserve">
          <source>Just like strings, symbols can be used as keys for object properties.</source>
          <target state="translated">문자열과 마찬가지로 심볼을 객체 속성의 키로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="accadaa2de1d9b54d08912507fc259d22f1d0931" translate="yes" xml:space="preserve">
          <source>Just run:</source>
          <target state="translated">그냥 실행 :</target>
        </trans-unit>
        <trans-unit id="125f418dffdfd3ad4877030138769ad27527fedf" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; will be turned on along with other &lt;code&gt;--strict&lt;/code&gt; mode flags, which can impact your project. You can set the &lt;code&gt;strictPropertyInitialization&lt;/code&gt; setting to &lt;code&gt;false&lt;/code&gt; in your &lt;code&gt;tsconfig.json&lt;/code&gt;&amp;rsquo;s &lt;code&gt;compilerOptions&lt;/code&gt;, or &lt;code&gt;--strictPropertyInitialization false&lt;/code&gt; on the command line to turn off this checking.</source>
          <target state="translated">있다는 사실을 숙지 &lt;code&gt;--strictPropertyInitialization&lt;/code&gt; 가 다른과 함께 켜집니다 &lt;code&gt;--strict&lt;/code&gt; 의 프로젝트에 영향을 줄 수있는 모드 플래그. 당신은 설정할 수 있습니다 &lt;code&gt;strictPropertyInitialization&lt;/code&gt; 의 설정을 &lt;code&gt;false&lt;/code&gt; 당신에 &lt;code&gt;tsconfig.json&lt;/code&gt; 의 &lt;code&gt;compilerOptions&lt;/code&gt; 를 , 또는 &lt;code&gt;--strictPropertyInitialization false&lt;/code&gt; 명령 행에서이 검사를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="0abfd4d342104dbd9ec0e7580639c9a4652da4fe" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;?.&lt;/code&gt; acts differently than those &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operations since &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; will act specially on &amp;ldquo;falsy&amp;rdquo; values (e.g. the empty string, &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt;, and, well, &lt;code&gt;false&lt;/code&gt;), but this is an intentional feature of the construct. It doesn&amp;rsquo;t short-circuit on valid data like &lt;code&gt;0&lt;/code&gt; or empty strings.</source>
          <target state="translated">명심하십시오 &lt;code&gt;?.&lt;/code&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 는 &quot;falsy&quot;값 (예 : 빈 문자열, &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;NaN&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; ) 에 대해 특수하게 작동하므로 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 연산 과 다르게 작동 하지만 이는 구성의 의도적 인 기능입니다. &lt;code&gt;0&lt;/code&gt; 또는 빈 문자열 과 같은 유효한 데이터를 단락시키지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e08badd7e94b5e92e8e60fc455f43139d018f482" translate="yes" xml:space="preserve">
          <source>Keep in mind that automatic inclusion is only important if you&amp;rsquo;re using files with global declarations (as opposed to files declared as modules). If you use an &lt;code&gt;import &quot;foo&quot;&lt;/code&gt; statement, for instance, TypeScript may still look through &lt;code&gt;node_modules&lt;/code&gt; &amp;amp; &lt;code&gt;node_modules/@types&lt;/code&gt; folders to find the &lt;code&gt;foo&lt;/code&gt; package.</source>
          <target state="translated">자동 선언은 전역 선언이있는 파일 (모듈로 선언 된 파일이 아닌)을 사용하는 경우에만 중요합니다. 예를 들어 &lt;code&gt;import &quot;foo&quot;&lt;/code&gt; 문 을 사용하는 경우 TypeScript는 여전히 &lt;code&gt;node_modules&lt;/code&gt; &amp;amp; &lt;code&gt;node_modules/@types&lt;/code&gt; 폴더를 통해 &lt;code&gt;foo&lt;/code&gt; 패키지 를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="268830906a0177b0c9a669ca7e3cb1faf3ef7c1b" translate="yes" xml:space="preserve">
          <source>Keep in mind that for simple code like above, you probably shouldn&amp;rsquo;t be trying to &amp;ldquo;get around&amp;rdquo; these checks. For more complex object literals that have methods and hold state, you might need to keep these techniques in mind, but a majority of excess property errors are actually bugs. That means if you&amp;rsquo;re running into excess property checking problems for something like option bags, you might need to revise some of your type declarations. In this instance, if it&amp;rsquo;s okay to pass an object with both a &lt;code&gt;color&lt;/code&gt; or &lt;code&gt;colour&lt;/code&gt; property to &lt;code&gt;createSquare&lt;/code&gt;, you should fix up the definition of &lt;code&gt;SquareConfig&lt;/code&gt; to reflect that.</source>
          <target state="translated">위와 같은 간단한 코드의 경우 이러한 검사를 &quot;해결&quot;하려고 시도해서는 안됩니다. 메서드가 있고 상태를 유지하는 더 복잡한 개체 리터럴의 경우 이러한 기술을 염두에 두어야하지만 과도한 속성 오류의 대부분은 실제로 버그입니다. 즉, 옵션 백과 같은 속성에 대한 초과 속성 검사 문제가 발생하면 일부 유형 선언을 수정해야 할 수도 있습니다. 이 경우, &lt;code&gt;createSquare&lt;/code&gt; 에 &lt;code&gt;color&lt;/code&gt; 또는 &lt;code&gt;colour&lt;/code&gt; 속성이 있는 객체 를 전달해도 괜찮다면 SquareConfig 정의를 &lt;code&gt;SquareConfig&lt;/code&gt; 하여 반영해야합니다.</target>
        </trans-unit>
        <trans-unit id="f6bddc5a736f8d59d17afc0337ba7f62d7baf26b" translate="yes" xml:space="preserve">
          <source>Keep in mind that our support for async iterators relies on support for &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; to exist at runtime. You may need to polyfill &lt;code&gt;Symbol.asyncIterator&lt;/code&gt;, which for simple purposes can be as simple as: &lt;code&gt;(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for(&quot;Symbol.asyncIterator&quot;);&lt;/code&gt;</source>
          <target state="translated">비동기 반복자에 대한 지원 은 런타임에 존재 하는 &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; 에 대한 지원에 의존 합니다. 간단한 목적을 위해 다음과 같이 간단 할 수있는 &lt;code&gt;Symbol.asyncIterator&lt;/code&gt; 를 polyfill해야 할 수도 있습니다. &lt;code&gt;(Symbol as any).asyncIterator = Symbol.asyncIterator || Symbol.for(&quot;Symbol.asyncIterator&quot;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0ee6543e6ec698fd6b6185b09f38eac28c9b2e1" translate="yes" xml:space="preserve">
          <source>Keep in mind that string enum members &lt;em&gt;do not&lt;/em&gt; get a reverse mapping generated at all.</source>
          <target state="translated">문자열 열거 형 멤버 &lt;em&gt;는 전혀&lt;/em&gt; 역방향 매핑을 생성 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="629873668f1873eae0d44964937115d6002d3f50" translate="yes" xml:space="preserve">
          <source>Keep outdated console output in watch mode instead of clearing the screen</source>
          <target state="translated">화면을 지우지 않고 오래된 콘솔 출력을 시계 모드로 유지</target>
        </trans-unit>
        <trans-unit id="a22c16410dc4eafc94fbc317a11af2903d7b50a3" translate="yes" xml:space="preserve">
          <source>Key Concepts</source>
          <target state="translated">주요 컨셉</target>
        </trans-unit>
        <trans-unit id="eaf7e256a5a476287d569594d43c22027adc861c" translate="yes" xml:space="preserve">
          <source>Lastly, we create a helper function that will do the mixing for us. This will run through the properties of each of the mixins and copy them over to the target of the mixins, filling out the stand-in properties with their implementations.</source>
          <target state="translated">마지막으로 믹싱을 수행 할 도우미 함수를 만듭니다. 그러면 각 믹스 인의 속성이 실행되고 믹스 인의 대상으로 복사되어 독립형 속성이 해당 구현으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="0deb513412e10426cc0e13efd7af25f69b12a4e1" translate="yes" xml:space="preserve">
          <source>Lay out the project</source>
          <target state="translated">프로젝트 배치</target>
        </trans-unit>
        <trans-unit id="0fd2852022c2c1345c56213c485ff5c6c7b31b62" translate="yes" xml:space="preserve">
          <source>Layout for compilations using &lt;code&gt;outFile&lt;/code&gt; is more flexible because relative paths don&amp;rsquo;t matter as much. One thing to keep in mind is that you&amp;rsquo;ll generally want to not use &lt;code&gt;prepend&lt;/code&gt; until the &amp;ldquo;last&amp;rdquo; project - this will improve build times and reduce the amount of I/O needed in any given build. The TypeScript repo itself is a good reference here - we have some &amp;ldquo;library&amp;rdquo; projects and some &amp;ldquo;endpoint&amp;rdquo; projects; &amp;ldquo;endpoint&amp;rdquo; projects are kept as small as possible and pull in only the libraries they need.</source>
          <target state="translated">상대 경로는 중요하지 않기 때문에 &lt;code&gt;outFile&lt;/code&gt; 을 사용한 컴파일 레이아웃 이 더 유연합니다. 명심해야 할 한 가지는 일반적으로 &quot;마지막&quot;프로젝트까지 &lt;code&gt;prepend&lt;/code&gt; 사용하지 않을 것입니다. 이렇게하면 빌드 시간이 향상되고 특정 빌드에 필요한 I / O 양이 줄어 듭니다. TypeScript 저장소 자체는 좋은 참고 자료입니다. 우리는 &quot;라이브러리&quot;프로젝트와 &quot;종료점&quot;프로젝트가 있습니다. &amp;ldquo;종점&amp;rdquo;프로젝트는 가능한 작게 유지하고 필요한 라이브러리 만 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6bb28e55ee1d62a9d6d258deae5c6e572957f877" translate="yes" xml:space="preserve">
          <source>Learning how to use &lt;code&gt;this&lt;/code&gt; in JavaScript is something of a rite of passage. Since TypeScript is a superset of JavaScript, TypeScript developers also need to learn how to use &lt;code&gt;this&lt;/code&gt; and how to spot when it&amp;rsquo;s not being used correctly. Fortunately, TypeScript lets you catch incorrect uses of &lt;code&gt;this&lt;/code&gt; with a couple of techniques. If you need to learn how &lt;code&gt;this&lt;/code&gt; works in JavaScript, though, first read Yehuda Katz&amp;rsquo;s &lt;a href=&quot;http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;Understanding JavaScript Function Invocation and &amp;ldquo;this&amp;rdquo;&lt;/a&gt;. Yehuda&amp;rsquo;s article explains the inner workings of &lt;code&gt;this&lt;/code&gt; very well, so we&amp;rsquo;ll just cover the basics here.</source>
          <target state="translated">JavaScript에서 &lt;code&gt;this&lt;/code&gt; 사용하는 방법을 배우는 것은 통과 의례입니다. TypeScript는 JavaScript의 상위 집합이므로 TypeScript 개발자는 &lt;code&gt;this&lt;/code&gt; 를 사용 하는 방법과 올바르게 사용되지 않을 때 확인하는 방법을 배워야 합니다. 다행히, 타이프 라이터는 잘못 사용 잡을 수 있도록 &lt;code&gt;this&lt;/code&gt; 기술의 부부와 함께. JavaScript에서 &lt;code&gt;this&lt;/code&gt; 어떻게 작동 하는지 배우 려면 먼저 Yehuda Katz의 &lt;a href=&quot;http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/&quot;&gt;JavaScript 함수 호출 이해 및&amp;ldquo;this&amp;rdquo;를&lt;/a&gt; 읽으십시오 . 예후의 문서의 내부 동작 설명 &lt;code&gt;this&lt;/code&gt; 우리가 여기에 기초를 다룰 것이다, 그래서 아주 잘.</target>
        </trans-unit>
        <trans-unit id="d19ec9c75f791d8e76b8abbb3fa24159df758f91" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add a couple of interfaces to our example above, &lt;code&gt;Card&lt;/code&gt; and &lt;code&gt;Deck&lt;/code&gt;, to make the types clearer and easier to reuse:</source>
          <target state="translated">위의 예에 &lt;code&gt;Card&lt;/code&gt; 와 &lt;code&gt;Deck&lt;/code&gt; 인터페이스를 추가 하여 유형을보다 명확하고 재사용하기 쉽게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0810e0790bb570bb542897e9f00f0ff27a268b73" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s add types to our simple examples from earlier:</source>
          <target state="translated">이전의 간단한 예제에 유형을 추가해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="2fbda1714e2bf191061f156921ed8a14ecb815d5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s convert a simple class to use &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;. First, let&amp;rsquo;s start with an example without getters and setters.</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 과 &lt;code&gt;set&lt;/code&gt; 을 사용하도록 간단한 클래스를 변환 해 봅시다 . 먼저, 게터와 세터가없는 예제부터 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="71429700e5fe5c8713f8050f9d22fc5e71f408cf" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s develop our sample further. Here we use an interface that describes objects that have a firstName and lastName field. In TypeScript, two types are compatible if their internal structure is compatible. This allows us to implement an interface just by having the shape the interface requires, without an explicit &lt;code&gt;implements&lt;/code&gt; clause.</source>
          <target state="translated">샘플을 더 개발해 봅시다. 여기서 firstName 및 lastName 필드가있는 객체를 설명하는 인터페이스를 사용합니다. TypeScript에서 내부 구조가 호환되는 경우 두 가지 유형이 호환됩니다. 이를 통해 명시적인 &lt;code&gt;implements&lt;/code&gt; 조항 없이 인터페이스에 필요한 형태를 갖도록 인터페이스를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65d0faf04337211735b15f8a5d34c2608e50c347" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get started by building a simple web application with TypeScript.</source>
          <target state="translated">TypeScript를 사용하여 간단한 웹 응용 프로그램을 작성하여 시작해 봅시다.</target>
        </trans-unit>
        <trans-unit id="b1e0b8ac0a49ba6917defbab6438fe121a7b57d4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back and write the code for the version of &lt;code&gt;padLeft&lt;/code&gt; that uses union types. We could write it with type predicates as follows:</source>
          <target state="translated">돌아가서 결합 유형을 사용 하는 &lt;code&gt;padLeft&lt;/code&gt; 버전의 코드를 작성해 봅시다 . 다음과 같이 유형 술어로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a370033b626aeaa4b56b2ffa2c9b364f90cf9047" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a fairly normal program and see how project references can help us better organize it. Imagine you have a project with two modules, &lt;code&gt;converter&lt;/code&gt; and &lt;code&gt;units&lt;/code&gt;, and a corresponding test file for each:</source>
          <target state="translated">상당히 정상적인 프로그램을 살펴보고 프로젝트 참조가 프로그램을 더 잘 구성하는 데 어떻게 도움이 될 수 있는지 봅시다. 두 개의 모듈 ( &lt;code&gt;converter&lt;/code&gt; 및 &lt;code&gt;units&lt;/code&gt; )과 각각에 해당하는 테스트 파일 이있는 프로젝트가 있다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f36707930dcd360fc642c46ec4865e86294c552d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example to better see how this plays out in practice:</source>
          <target state="translated">이것이 실제로 어떻게 작동하는지 더 잘 알기위한 예를 보자.</target>
        </trans-unit>
        <trans-unit id="d172a231ad56188812168291eea6a5fd8742b6b4" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at an example:</source>
          <target state="translated">예를 보자.</target>
        </trans-unit>
        <trans-unit id="eeeed955a225d9a00620ccdff1e785a00b797db0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s modify the example a bit to show this difference:</source>
          <target state="translated">이 차이점을 보여주기 위해 예제를 약간 수정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="b02e9aea645d47e4e6bf161ee47aada331ae51db" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now add React and React-DOM, along with their declaration files, as dependencies to your &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;package.json&lt;/code&gt; 파일에 대한 의존성으로 선언 파일과 함께 React 및 React-DOM을 추가해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="83704a6507b28f550a9354f7a8254f0aa3c131e5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now look at a more complex example.</source>
          <target state="translated">이제 더 복잡한 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="014bde7411db7919604626e4a814bd5fe5d15eef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say that we&amp;rsquo;ve actually intended this function to work on arrays of &lt;code&gt;T&lt;/code&gt; rather than &lt;code&gt;T&lt;/code&gt; directly. Since we&amp;rsquo;re working with arrays, the &lt;code&gt;.length&lt;/code&gt; member should be available. We can describe this just like we would create arrays of other types:</source>
          <target state="translated">실제로이 함수가 &lt;code&gt;T&lt;/code&gt; 가 아닌 &lt;code&gt;T&lt;/code&gt; 의 배열에서 직접 작동하도록 의도했다고 가정 해 봅시다 . 우리는 배열을 사용하고 있기 때문에 &lt;code&gt;.length&lt;/code&gt; 멤버를 사용할 수 있어야합니다. 다른 유형의 배열을 만드는 것처럼 이것을 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0afa8a2c9e9ae086ac85d8e4851a50d094dc340f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we have a sample application that uses the &lt;code&gt;typescript&lt;/code&gt; module. &lt;code&gt;app.ts&lt;/code&gt; has an import like &lt;code&gt;import * as ts from &quot;typescript&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;typescript&lt;/code&gt; 모듈 을 사용하는 샘플 응용 프로그램이 있다고 가정 해 봅시다 . &lt;code&gt;app.ts&lt;/code&gt; 는 &lt;code&gt;import * as ts from &quot;typescript&quot;&lt;/code&gt; 같은 import *를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="b98ecb1cac8b86219be2530212acfb40004f6c82" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say we wrote a module file &lt;code&gt;foo.d.ts&lt;/code&gt;:</source>
          <target state="translated">모듈 파일 &lt;code&gt;foo.d.ts&lt;/code&gt; 를 작성했다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="bf265138b3f25556fefa76ca3b0b12725b0f86b1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s scaffold this out:</source>
          <target state="translated">이것을 비계로 만들어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="aa591bb3c4e18fed63fab3f054ebcf47625b721d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this can be used.</source>
          <target state="translated">이것이 어떻게 사용될 수 있는지 봅시다.</target>
        </trans-unit>
        <trans-unit id="a2d4ab99ed2cfcd0bf4a97a7f9d646bc565fffa9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start out with a new directory. We&amp;rsquo;ll name it &lt;code&gt;proj&lt;/code&gt; for now, but you can change it to whatever you want.</source>
          <target state="translated">새로운 디렉토리로 시작하자. 우리는 지금 이름을 &lt;code&gt;proj&lt;/code&gt; 로 지정 하지만 원하는대로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55bbd8a0f85bfbe95c8b7cb6332b5825ff504f0e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with the program we&amp;rsquo;ll be using as our example throughout this page. We&amp;rsquo;ve written a small set of simplistic string validators, as you might write to check a user&amp;rsquo;s input on a form in a webpage or check the format of an externally-provided data file.</source>
          <target state="translated">이 페이지 전체에서 예제로 사용할 프로그램으로 시작하겠습니다. 우리는 웹 페이지의 폼에서 사용자 입력을 확인하거나 외부 제공 데이터 파일의 형식을 확인하기 위해 작성할 수있는 간단한 문자열 유효성 검사기 세트를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="bf10a2b8087f57e53feead64793d541595e6996c" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at a simple class-based example:</source>
          <target state="translated">간단한 클래스 기반 예제를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="3484d66cbe4a02744097aac7ef40e2f056cef65a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at an example:</source>
          <target state="translated">예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="b54485584eecf2901825f4b3995651a7e60470f5" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a look at the simplest mapped type and its parts:</source>
          <target state="translated">가장 간단한 매핑 유형과 그 부분을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="388956de0f4c78ed65b63c815c68a779d593b807" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a minute to consider what that means. &lt;code&gt;setTimeout&lt;/code&gt; will run a function after some number of milliseconds, &lt;em&gt;but only&lt;/em&gt; after the &lt;code&gt;for&lt;/code&gt; loop has stopped executing; By the time the &lt;code&gt;for&lt;/code&gt; loop has stopped executing, the value of &lt;code&gt;i&lt;/code&gt; is &lt;code&gt;10&lt;/code&gt;. So each time the given function gets called, it will print out &lt;code&gt;10&lt;/code&gt;!</source>
          <target state="translated">그것이 무엇을 의미하는지 잠시 생각해 봅시다. &lt;code&gt;setTimeout&lt;/code&gt; 은 몇 밀리 초 후에 함수를 실행 &lt;em&gt;하지만 &lt;/em&gt; &lt;code&gt;for&lt;/code&gt; 루프가 실행을 중지 한 후에 &lt;em&gt;만&lt;/em&gt; 실행됩니다. &lt;code&gt;for&lt;/code&gt; 루프가 실행을 중지 할 때까지 &lt;code&gt;i&lt;/code&gt; 값 은 &lt;code&gt;10&lt;/code&gt; 입니다. 주어진 함수가 호출 될 때마다 &lt;code&gt;10&lt;/code&gt; 을 출력합니다 !</target>
        </trans-unit>
        <trans-unit id="309b7fe3def1ff082c552cb81229fe971bbfb8b9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take our &lt;code&gt;identity&lt;/code&gt; function from earlier:</source>
          <target state="translated">&lt;code&gt;identity&lt;/code&gt; 기능을 이전부터 살펴 보자 .</target>
        </trans-unit>
        <trans-unit id="c819787bed8495ecea9cfe18f716371127e40d52" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a Hello World program. In &lt;code&gt;src&lt;/code&gt;, create the file &lt;code&gt;main.ts&lt;/code&gt;:</source>
          <target state="translated">Hello World 프로그램을 작성해 봅시다. 에서 &lt;code&gt;src&lt;/code&gt; , 파일 생성 &lt;code&gt;main.ts&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="4f861095293696b450d02c85427a11313836cd45" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write our first TypeScript file using React. First, create a file named &lt;code&gt;Hello.tsx&lt;/code&gt; in &lt;code&gt;src/components&lt;/code&gt; and write the following:</source>
          <target state="translated">React를 사용하여 첫 번째 TypeScript 파일을 작성해 봅시다. 먼저,라는 이름의 파일 생성 &lt;code&gt;Hello.tsx&lt;/code&gt; 에 &lt;code&gt;src/components&lt;/code&gt; 및 다음 쓰기 :</target>
        </trans-unit>
        <trans-unit id="166644bb8752dfdaa61026de73139cfde0a4a540" translate="yes" xml:space="preserve">
          <source>LettersOnlyValidator.ts</source>
          <target state="translated">LettersOnlyValidator.ts</target>
        </trans-unit>
        <trans-unit id="875c3c9135ee949f84870492409833fc57642b20" translate="yes" xml:space="preserve">
          <source>Libraries can also use &lt;code&gt;this&lt;/code&gt; parameters to declare how callbacks will be invoked.</source>
          <target state="translated">라이브러리는 &lt;code&gt;this&lt;/code&gt; 매개 변수를 사용 하여 콜백이 호출되는 방법을 선언 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c8d68bdf290b3650035c5dab105050f96236c14" translate="yes" xml:space="preserve">
          <source>Library Structures</source>
          <target state="translated">도서관 구조</target>
        </trans-unit>
        <trans-unit id="4e958d206e87dee6202602f12cba1d07ddc64591" translate="yes" xml:space="preserve">
          <source>Library Structures: Consuming Dependencies</source>
          <target state="translated">라이브러리 구조 : 소비 종속성</target>
        </trans-unit>
        <trans-unit id="b96d274e68825ffb1cf50ff3a8842c7507fb9c61" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on Global Libraries</source>
          <target state="translated">라이브러리 구조 : 글로벌 라이브러리에 대한 종속성</target>
        </trans-unit>
        <trans-unit id="c7d79eff0a64c91827b34425186a057bf7eefed6" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on Modules</source>
          <target state="translated">라이브러리 구조 : 모듈에 대한 종속성</target>
        </trans-unit>
        <trans-unit id="0e5b4340018e06cc22410c43d8c05671e353f758" translate="yes" xml:space="preserve">
          <source>Library Structures: Dependencies on UMD libraries</source>
          <target state="translated">라이브러리 구조 : UMD 라이브러리에 대한 종속성</target>
        </trans-unit>
        <trans-unit id="25679ea328e38a91aa99fd34521cab5334cfc5f6" translate="yes" xml:space="preserve">
          <source>Library Structures: Global Libraries</source>
          <target state="translated">라이브러리 구조 : 글로벌 라이브러리</target>
        </trans-unit>
        <trans-unit id="583896dcdb93f9cebf804f97f952c1047d1b09e6" translate="yes" xml:space="preserve">
          <source>Library Structures: Global Plugin</source>
          <target state="translated">라이브러리 구조 : 글로벌 플러그인</target>
        </trans-unit>
        <trans-unit id="46852e3e51c98d1fbda888c84f0fd0b001bb9a75" translate="yes" xml:space="preserve">
          <source>Library Structures: Global-modifying Modules</source>
          <target state="translated">라이브러리 구조 : 전역 수정 모듈</target>
        </trans-unit>
        <trans-unit id="38fb731884bc1a45c091fe53bb4f59beacc5c010" translate="yes" xml:space="preserve">
          <source>Library Structures: Identifying Kinds of Libraries</source>
          <target state="translated">라이브러리 구조 : 라이브러리 종류 식별</target>
        </trans-unit>
        <trans-unit id="dd13ad9cf324101c470f4a966d00d41d7ab63505" translate="yes" xml:space="preserve">
          <source>Library Structures: Library file layout</source>
          <target state="translated">라이브러리 구조 : 라이브러리 파일 레이아웃</target>
        </trans-unit>
        <trans-unit id="c83378208463304e24be07d77ddfa86166dca09e" translate="yes" xml:space="preserve">
          <source>Library Structures: Modular Libraries</source>
          <target state="translated">라이브러리 구조 : 모듈 식 라이브러리</target>
        </trans-unit>
        <trans-unit id="1fe937767fb28d22ee73b66129f61b0fe7d8aa7e" translate="yes" xml:space="preserve">
          <source>Library Structures: Module Plugin or UMD Plugin</source>
          <target state="translated">라이브러리 구조 : 모듈 플러그인 또는 UMD 플러그인</target>
        </trans-unit>
        <trans-unit id="4f845580b5f18381f6fa82c3be48352cc4e140d3" translate="yes" xml:space="preserve">
          <source>Library Structures: Preventing Name Conflicts</source>
          <target state="translated">라이브러리 구조 : 이름 충돌 방지</target>
        </trans-unit>
        <trans-unit id="f1c767319c72858af7a6896ba4967b323b7a1717" translate="yes" xml:space="preserve">
          <source>Library Structures: The Impact of ES6 on Module Plugins</source>
          <target state="translated">라이브러리 구조 : 모듈 플러그인에 대한 ES6의 영향</target>
        </trans-unit>
        <trans-unit id="c4c82656844e89a1600df1de5a6196522c148102" translate="yes" xml:space="preserve">
          <source>Library Structures: UMD</source>
          <target state="translated">라이브러리 구조 : UMD</target>
        </trans-unit>
        <trans-unit id="b914f6929708a78f5ebc7f6182f8d6dadfdf5520" translate="yes" xml:space="preserve">
          <source>Library file layout</source>
          <target state="translated">라이브러리 파일 레이아웃</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apache 라이센스, 버전 2.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="614020e4b48ba41cbc8feb6a827a9777cf491e2e" translate="yes" xml:space="preserve">
          <source>Like array destructuring, you can have assignment without declaration:</source>
          <target state="translated">배열 파괴와 마찬가지로 선언없이 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8179c422e4946b3006e7ce0d9f1b27008179e0fd" translate="yes" xml:space="preserve">
          <source>Like classes, interfaces can extend each other. This allows you to copy the members of one interface into another, which gives you more flexibility in how you separate your interfaces into reusable components.</source>
          <target state="translated">클래스와 마찬가지로 인터페이스도 서로 확장 될 수 있습니다. 이를 통해 한 인터페이스의 멤버를 다른 인터페이스로 복사 할 수 있으므로 인터페이스를 재사용 가능한 구성 요소로 분리하는 방법에있어 유연성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="e100fe20d9c089d3990a58c235d7844235322341" translate="yes" xml:space="preserve">
          <source>Like other special JS checking behaviors, this behavior can be changed by specifying a JSDoc type for the variable. For example:</source>
          <target state="translated">다른 특수 JS 검사 동작과 마찬가지로이 동작은 변수에 JSDoc 유형을 지정하여 변경할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="991d21c5bdd231b177d8dbce4a5a58935deb5866" translate="yes" xml:space="preserve">
          <source>Like we mentioned, it&amp;rsquo;s not unexpected to get error messages after conversion. The important thing is to actually go one by one through these and decide how to deal with the errors. Often these will be legitimate bugs, but sometimes you&amp;rsquo;ll have to explain what you&amp;rsquo;re trying to do a little better to TypeScript.</source>
          <target state="translated">앞에서 언급했듯이 변환 후 오류 메시지가 나타나는 것은 예기치 않은 일이 아닙니다. 중요한 것은 실제로 이들을 통해 하나씩 이동하여 오류를 처리하는 방법을 결정하는 것입니다. 종종 이것들은 합법적 인 버그 일 것입니다. 그러나 때로는 TypeScript에 대해 조금 더 잘하려고하는 것을 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="ad22df7237ec893f071e3a632c74d36af489349a" translate="yes" xml:space="preserve">
          <source>Likewise, for the return type of a function:</source>
          <target state="translated">마찬가지로 함수의 반환 유형에 대해서도 :</target>
        </trans-unit>
        <trans-unit id="bbb07555ce6ca44b59035a2a319034782de9f8d0" translate="yes" xml:space="preserve">
          <source>Likewise, multiple candidates for the same type variable in contra-variant positions causes an intersection type to be inferred:</source>
          <target state="translated">마찬가지로, 반 변형 위치에서 동일한 유형 변수에 대한 여러 후보는 교점 유형을 유추합니다.</target>
        </trans-unit>
        <trans-unit id="5359c0166343c48f9f035c401a1a6fd47a5d3c30" translate="yes" xml:space="preserve">
          <source>List of</source>
          <target state="translated">의 목록</target>
        </trans-unit>
        <trans-unit id="465c88588b5cdd41299c2edcb1468c48ae202ec0" translate="yes" xml:space="preserve">
          <source>List of folders to include type definitions from. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots and &amp;ndash;types&lt;/a&gt; for more details.</source>
          <target state="translated">유형 정의를 포함 할 폴더 목록. 자세한 내용은 &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots 및 &amp;ndash;types&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6ced5dd028928de0448e70e83b68d98333283e39" translate="yes" xml:space="preserve">
          <source>List of library files to be included in the compilation.</source>
          <target state="translated">컴파일에 포함 할 라이브러리 파일 목록.</target>
        </trans-unit>
        <trans-unit id="bcb7afa9aa95b8c02629a8477085e1d618f28bc0" translate="yes" xml:space="preserve">
          <source>List of names of type definitions to include. See &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots and &amp;ndash;types&lt;/a&gt; for more details.</source>
          <target state="translated">포함 할 유형 정의의 이름 목록입니다. 자세한 내용은 &lt;a href=&quot;tsconfig-json#types-typeroots-and-types&quot;&gt;@types, &amp;ndash;typeRoots 및 &amp;ndash;types&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="653b9b02be1c90476a3ad618b040891655bf5f51" translate="yes" xml:space="preserve">
          <source>List of path mapping entries for module names to locations relative to the &lt;code&gt;baseUrl&lt;/code&gt;. See &lt;a href=&quot;module-resolution#path-mapping&quot;&gt;Module Resolution documentation&lt;/a&gt; for more details.</source>
          <target state="translated">받는 사람의 상대 위치에 모듈 이름에 대한 경로 매핑 항목의 목록 &lt;code&gt;baseUrl&lt;/code&gt; . 자세한 내용은 &lt;a href=&quot;module-resolution#path-mapping&quot;&gt;모듈 확인 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bb25bc49f0293214d4dc209e4fc9026643313119" translate="yes" xml:space="preserve">
          <source>Literal type widening can be controlled through explicit type annotations. Specifically, when an expression of a literal type is inferred for a const location without a type annotation, that &lt;code&gt;const&lt;/code&gt; variable gets a widening literal type inferred. But when a &lt;code&gt;const&lt;/code&gt; location has an explicit literal type annotation, the &lt;code&gt;const&lt;/code&gt; variable gets a non-widening literal type.</source>
          <target state="translated">명시 적 유형 주석을 통해 리터럴 유형 확장을 제어 할 수 있습니다. 특히, 리터럴 타입의 표현식이 타입 어노테이션이없는 const 위치에 대해 유추 될 때, 그 &lt;code&gt;const&lt;/code&gt; 변수는 확장 된 리터럴 타입을 유추합니다. 그러나 &lt;code&gt;const&lt;/code&gt; 위치에 명시적인 리터럴 형식 주석이 있으면 &lt;code&gt;const&lt;/code&gt; 변수는 확장되지 않은 리터럴 형식을 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="e7a432de388d59eb0330d3d1bf7924a86dc9fda9" translate="yes" xml:space="preserve">
          <source>Loading of types from npm packages</source>
          <target state="translated">npm 패키지에서 유형로드</target>
        </trans-unit>
        <trans-unit id="7e4fa40194fa1599fc6410e0f480c52786bb6b60" translate="yes" xml:space="preserve">
          <source>Local and Imported Type Declarations Now Conflict</source>
          <target state="translated">로컬 및 가져온 형식 선언이 충돌합니다.</target>
        </trans-unit>
        <trans-unit id="dc901218db3c05e3ca7a85bfcded3b7a52e18ec2" translate="yes" xml:space="preserve">
          <source>Local class, interface, enum, and type alias declarations can now appear inside function declarations. Local types are block scoped, similar to variables declared with &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt;. For example:</source>
          <target state="translated">이제 로컬 클래스, 인터페이스, 열거 형 및 유형 별칭 선언이 함수 선언 내에 나타날 수 있습니다. 지역 유형은 &lt;code&gt;let&lt;/code&gt; 및 &lt;code&gt;const&lt;/code&gt; 로 선언 된 변수와 유사한 블록 범위 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d28868f17a046f8c9d0605670df6ffd291397586" translate="yes" xml:space="preserve">
          <source>Local type declarations</source>
          <target state="translated">지역 유형 선언</target>
        </trans-unit>
        <trans-unit id="25ce31967aab4a48e0accd8ada4e9c79a67d8e96" translate="yes" xml:space="preserve">
          <source>Local types may reference enclosing type parameters and local class and interfaces may themselves be generic. For example:</source>
          <target state="translated">로컬 형식은 둘러싸는 형식 매개 변수를 참조 할 수 있으며 로컬 클래스와 인터페이스 자체는 일반적 일 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d54f7840dd15f9efca1a3c2a835dba90f27406bb" translate="yes" xml:space="preserve">
          <source>Localized diagnostics on the command line</source>
          <target state="translated">명령 줄에서 현지화 된 진단</target>
        </trans-unit>
        <trans-unit id="dbc698b0052336839927b67e68ee8b808258468a" translate="yes" xml:space="preserve">
          <source>Locally scoped JSX namespaces</source>
          <target state="translated">로컬 범위의 JSX 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="f34ec36309212ab4f733a475011c562c23d0e729" translate="yes" xml:space="preserve">
          <source>Log.ts</source>
          <target state="translated">Log.ts</target>
        </trans-unit>
        <trans-unit id="57f54137157041b8ae56134eceada37f0aaf7daf" translate="yes" xml:space="preserve">
          <source>Look in the first localhost folder, then scripts/app.ts</source>
          <target state="translated">첫 번째 localhost 폴더를 찾은 다음 scripts / app.ts를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="8fdfcce162943820f24951cb2a2e053a7c7c3ec0" translate="yes" xml:space="preserve">
          <source>Look in your &lt;code&gt;C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets&lt;/code&gt; file. The authoritative mappings between MSBuild XML tags and &lt;code&gt;tsc&lt;/code&gt; compiler options live in there.</source>
          <target state="translated">당신의 봐 &lt;code&gt;C:\Program Files (x86)\MSBuild\Microsoft\VisualStudio\v$(VisualStudioVersion)\TypeScript\Microsoft.TypeScript.targets&lt;/code&gt; 파일. MSBuild XML 태그와 &lt;code&gt;tsc&lt;/code&gt; 컴파일러 옵션 사이의 권위있는 매핑 이 여기에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6b0fb8ef6778ed02a7ae1ae513bbf8d954f0a94" translate="yes" xml:space="preserve">
          <source>MSBuild</source>
          <target state="translated">MSBuild</target>
        </trans-unit>
        <trans-unit id="2e00dde89c6a5b86d9cb21be7fbf224d7c22deec" translate="yes" xml:space="preserve">
          <source>MSBuild Property Name</source>
          <target state="translated">MSBuild 속성 이름</target>
        </trans-unit>
        <trans-unit id="528349fad89f8e558db9d5dd9f001d6ed4aceabc" translate="yes" xml:space="preserve">
          <source>Make sure that the modules work by running &lt;code&gt;gulp&lt;/code&gt; and then testing in Node:</source>
          <target state="translated">&lt;code&gt;gulp&lt;/code&gt; 를 실행 한 다음 노드에서 테스트 하여 모듈이 작동하는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="06adecb648f1663461f793b6ad17375e5c241d45" translate="yes" xml:space="preserve">
          <source>Make sure to revisit the &lt;a href=&quot;library-structures#consuming-dependencies&quot;&gt;Consuming dependencies&lt;/a&gt; section for more information.</source>
          <target state="translated">자세한 정보 는 &lt;a href=&quot;library-structures#consuming-dependencies&quot;&gt;소비 종속성&lt;/a&gt; 섹션 을 다시 방문 하십시오.</target>
        </trans-unit>
        <trans-unit id="8dc73c8a520471a285c4dd9769e30a805d1f4ca3" translate="yes" xml:space="preserve">
          <source>Many JavaScript developers are intimately familiar with this behavior, but if you&amp;rsquo;re surprised, you&amp;rsquo;re certainly not alone. Most people expect the output to be</source>
          <target state="translated">많은 JavaScript 개발자는이 동작에 대해 친숙하지만 친숙한 사용자는 아닙니다. 대부분의 사람들은 출력이</target>
        </trans-unit>
        <trans-unit id="fe4a673619fce4477eac837da092bcc0b04ae5cf" translate="yes" xml:space="preserve">
          <source>Many bundlers have support for automatically splitting output bundles based on these &lt;code&gt;import&lt;/code&gt; expressions, so consider using this new feature with the &lt;code&gt;esnext&lt;/code&gt; module target.</source>
          <target state="translated">많은 번 &lt;code&gt;esnext&lt;/code&gt; 는 이러한 &lt;code&gt;import&lt;/code&gt; 표현식을 기반으로 출력 번들 자동 분할을 지원 하므로 esnext 모듈 대상 에이 새로운 기능을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="584c646b07ca217d5f7c1b61637d077ae1a5e971" translate="yes" xml:space="preserve">
          <source>Many common mistakes in declaration files can be easily avoided. The &lt;a href=&quot;do-s-and-don-ts&quot;&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt; section identifies common errors, describes how to detect them, and how to fix them. Everyone should read this section to help themselves avoid common mistakes.</source>
          <target state="translated">선언 파일의 많은 일반적인 실수는 쉽게 피할 수 있습니다. &lt;a href=&quot;do-s-and-don-ts&quot;&gt;하는 것과하지 않는&lt;/a&gt; 섹션을 식별 일반적인 오류는이를 감지하는 방법 및이를 해결하는 방법을 설명합니다. 일반적인 실수를 피하기 위해이 섹션을 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="eb06e5cbf12cdc30df47507b636fcce479ba328c" translate="yes" xml:space="preserve">
          <source>Many popular Node.js libraries are in the module family, such as &lt;a href=&quot;http://expressjs.com/&quot;&gt;&lt;code&gt;express&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;http://gulpjs.com/&quot;&gt;&lt;code&gt;gulp&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://github.com/request/request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://expressjs.com/&quot;&gt; &lt;code&gt;express&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;http://gulpjs.com/&quot;&gt; &lt;code&gt;gulp&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://github.com/request/request&quot;&gt; &lt;code&gt;request&lt;/code&gt; &lt;/a&gt; 와 같이 많은 인기있는 Node.js 라이브러리가 모듈 제품군에 있습니다.</target>
        </trans-unit>
        <trans-unit id="63a6f8dd928db9783606b9b55a4d1e30673d97c7" translate="yes" xml:space="preserve">
          <source>Many popular libraries, such as Express, expose themselves as a callable function when imported. For example, the typical Express usage looks like this:</source>
          <target state="translated">Express와 같은 널리 사용되는 많은 라이브러리는 가져올 때 호출 가능한 함수로 자신을 노출시킵니다. 예를 들어, 일반적인 Express 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6113dbcfc0c046c2e863aac93003dd4c0388bee" translate="yes" xml:space="preserve">
          <source>Many times, we are faced with writing a declaration file when we only have examples of the underlying library to guide us. The &lt;a href=&quot;by-example&quot;&gt;By Example&lt;/a&gt; section shows many common API patterns and how to write declarations for each of them. This guide is aimed at the TypeScript novice who may not yet be familiar with every language construct in TypeScript.</source>
          <target state="translated">우리는 기본 라이브러리의 예제 만 가지고있을 때 선언 파일을 작성해야하는 경우가 많습니다. &lt;a href=&quot;by-example&quot;&gt;으로 예&lt;/a&gt; 섹션 쇼 많은 일반적인 API 패턴과 방법을 그들 각각에 대한 선언을 작성하는 방법. 이 안내서는 TypeScript의 모든 언어 구성에 아직 익숙하지 않은 TypeScript 초보자를 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="b39eaaa138d38f75f9ba15b0ecb54217b1f43d1d" translate="yes" xml:space="preserve">
          <source>Mapped Types</source>
          <target state="translated">매핑 된 유형</target>
        </trans-unit>
        <trans-unit id="f5503e0acfd60752001069a9088cb22064b114de" translate="yes" xml:space="preserve">
          <source>Mapped types</source>
          <target state="translated">매핑 된 유형</target>
        </trans-unit>
        <trans-unit id="150ac025be99fedc0936df23f699d5432059212b" translate="yes" xml:space="preserve">
          <source>Mapped types are produced by taking a union of literal types, and computing a set of properties for a new object type. They&amp;rsquo;re like &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions&quot;&gt;list comprehensions in Python&lt;/a&gt;, but instead of producing new elements in a list, they produce new properties in a type.</source>
          <target state="translated">매핑 된 형식은 리터럴 형식을 통합하고 새 개체 형식에 대한 속성 집합을 계산하여 생성됩니다. 그들은 &lt;a href=&quot;https://docs.python.org/2/tutorial/datastructures.html#nested-list-comprehensions&quot;&gt;파이썬에서 목록 이해&lt;/a&gt; 와 같지만 목록에서 새로운 요소를 생성하는 대신 유형으로 새로운 속성을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="347c61475a676c2faf7ddbe772ebae4b5d598063" translate="yes" xml:space="preserve">
          <source>Mapped types on tuples and arrays</source>
          <target state="translated">튜플 및 배열의 ​​매핑 된 유형</target>
        </trans-unit>
        <trans-unit id="8e8a7963f001150e8ed8e3c1be77a5be18c61c35" translate="yes" xml:space="preserve">
          <source>Mapped types support adding a &lt;code&gt;readonly&lt;/code&gt; or &lt;code&gt;?&lt;/code&gt; modifier to a mapped property, but they did not provide support the ability to &lt;em&gt;remove&lt;/em&gt; modifiers. This matters in &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/12563&quot;&gt;&lt;em&gt;homomorphic mapped types&lt;/em&gt;&lt;/a&gt; which by default preserve the modifiers of the underlying type.</source>
          <target state="translated">매핑 된 유형은 &lt;code&gt;readonly&lt;/code&gt; 또는 &lt;code&gt;?&lt;/code&gt; 수정자를 맵핑 된 특성에 대한 수정 자이지만 수정자를 &lt;em&gt;제거&lt;/em&gt; 하는 기능을 지원하지 않았습니다 . 기본적으로 기본 형식의 수정자를 유지하는 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/pull/12563&quot;&gt;&lt;em&gt;동형 매핑 형식&lt;/em&gt;&lt;/a&gt; 이 중요 합니다.</target>
        </trans-unit>
        <trans-unit id="1cbcdd98d1b5744757244f463b7f939b4869f3e4" translate="yes" xml:space="preserve">
          <source>Mappings</source>
          <target state="translated">Mappings</target>
        </trans-unit>
        <trans-unit id="76afa4572a785cbf8909d66ab1eaf36ef69ba191" translate="yes" xml:space="preserve">
          <source>Matching behavior</source>
          <target state="translated">어울리는 행동</target>
        </trans-unit>
        <trans-unit id="d61fb1c71d97cf23364513b6c042480baf71317b" translate="yes" xml:space="preserve">
          <source>Maybe it was easy to spot out for some, but the inner &lt;code&gt;for&lt;/code&gt;-loop will accidentally overwrite the variable &lt;code&gt;i&lt;/code&gt; because &lt;code&gt;i&lt;/code&gt; refers to the same function-scoped variable. As experienced developers know by now, similar sorts of bugs slip through code reviews and can be an endless source of frustration.</source>
          <target state="translated">어쩌면 일부를 알아내는 것이 쉽지만 내부 &lt;code&gt;for&lt;/code&gt; -loop는 실수로 변수 &lt;code&gt;i&lt;/code&gt; 를 덮어 씁니다. 왜냐하면 &lt;code&gt;i&lt;/code&gt; 는 동일한 함수 범위 변수를 참조하기 때문 입니다. 숙련 된 개발자들이 지금까지 알고 있듯이, 비슷한 종류의 버그는 코드 검토를 거치며 끝없는 좌절의 원인이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8e319d394c7e9ed6ef1448bbdf219ff4e98198e" translate="yes" xml:space="preserve">
          <source>Merging Interfaces</source>
          <target state="translated">인터페이스 병합</target>
        </trans-unit>
        <trans-unit id="87557ad474b3ea1cb7dc79b4a0a69cc3c542648b" translate="yes" xml:space="preserve">
          <source>Merging Namespaces</source>
          <target state="translated">네임 스페이스 병합</target>
        </trans-unit>
        <trans-unit id="d457feda7cc53bf9cc76dc59489863c6ef6d30dd" translate="yes" xml:space="preserve">
          <source>Merging Namespaces with Classes</source>
          <target state="translated">클래스와 네임 스페이스 병합</target>
        </trans-unit>
        <trans-unit id="78529d067c66e125c411afd44c6c212aea17fa3a" translate="yes" xml:space="preserve">
          <source>Merging Namespaces with Classes, Functions, and Enums</source>
          <target state="translated">클래스, 함수 및 열거와 네임 스페이스 병합</target>
        </trans-unit>
        <trans-unit id="91bb6095ae597def81503d12e83651b39c84f4ab" translate="yes" xml:space="preserve">
          <source>Merging ambient class and interface declaration</source>
          <target state="translated">앰비언트 클래스 및 인터페이스 선언 병합</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="f70c71c1b2246c59d442015fb609b0bf48d83d56" translate="yes" xml:space="preserve">
          <source>Method Decorators</source>
          <target state="translated">메소드 데코레이터</target>
        </trans-unit>
        <trans-unit id="9adde04ca5b9eac1941dd0c91655d283d19fa1d1" translate="yes" xml:space="preserve">
          <source>Methods within an abstract class that are marked as abstract do not contain an implementation and must be implemented in derived classes. Abstract methods share a similar syntax to interface methods. Both define the signature of a method without including a method body. However, abstract methods must include the &lt;code&gt;abstract&lt;/code&gt; keyword and may optionally include access modifiers.</source>
          <target state="translated">추상으로 표시된 추상 클래스 내의 메소드는 구현을 포함하지 않으며 파생 클래스에서 구현되어야합니다. 추상 메소드는 인터페이스 메소드와 유사한 구문을 공유합니다. 둘 다 메소드 본문을 포함하지 않고 메소드의 서명을 정의합니다. 그러나 추상 메소드는 &lt;code&gt;abstract&lt;/code&gt; 키워드를 포함해야하며 선택적으로 액세스 수정자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6b88d2f7dec6e6507655392b41d6d66aa58943b" translate="yes" xml:space="preserve">
          <source>Microsoft.TypeScript.Compiler</source>
          <target state="translated">Microsoft.TypeScript.Compiler</target>
        </trans-unit>
        <trans-unit id="d6994e014929b9c9acadb4efcdd0d8898ec4998f" translate="yes" xml:space="preserve">
          <source>Microsoft.TypeScript.MSBuild</source>
          <target state="translated">Microsoft.TypeScript.MSBuild</target>
        </trans-unit>
        <trans-unit id="ecf39fd6186584cf8c46f851590e11d05b7c8704" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript</source>
          <target state="translated">JavaScript에서 마이그레이션</target>
        </trans-unit>
        <trans-unit id="006f2d2335563fb2900269f9b04adab236ac86ea" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Early Benefits</source>
          <target state="translated">JavaScript에서 마이그레이션 : 초기 이점</target>
        </trans-unit>
        <trans-unit id="1fed3c879f3bb26b579690b94983582cf0edda15" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Getting Stricter Checks</source>
          <target state="translated">JavaScript에서 마이그레이션 :보다 엄격한 검사</target>
        </trans-unit>
        <trans-unit id="1dc81892a9e5e97f6be65072af4047daf654e1d2" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Gulp</source>
          <target state="translated">JavaScript에서 마이그레이션 : Gulp</target>
        </trans-unit>
        <trans-unit id="7e19d5d40009a708d8b21bd446a6de963f361896" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Integrating with Build Tools</source>
          <target state="translated">JavaScript에서 마이그레이션 : 빌드 도구와 통합</target>
        </trans-unit>
        <trans-unit id="4ff2a610f7fca46011040ebfbaebde73fe2d0b89" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Moving to TypeScript Files</source>
          <target state="translated">JavaScript에서 마이그레이션 : TypeScript 파일로 이동</target>
        </trans-unit>
        <trans-unit id="9b91d79ea65c179b3144057c1b47e944dbe888c8" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Setting up your Directories</source>
          <target state="translated">JavaScript에서 마이그레이션 : 디렉토리 설정</target>
        </trans-unit>
        <trans-unit id="47148fd07a568fa2a38d4ed900235994bd81cea2" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Webpack</source>
          <target state="translated">JavaScript에서 마이그레이션 : Webpack</target>
        </trans-unit>
        <trans-unit id="49c6b428dbb35a643f704a1239347e7235a4958b" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Weeding out Errors</source>
          <target state="translated">JavaScript에서 마이그레이션 : 오류 제거</target>
        </trans-unit>
        <trans-unit id="8ec1b6d66f7377a566796d605d898d7ac205f685" translate="yes" xml:space="preserve">
          <source>Migrating from JavaScript: Writing a Configuration File</source>
          <target state="translated">JavaScript에서 마이그레이션 : 구성 파일 작성</target>
        </trans-unit>
        <trans-unit id="df5cb9211be987b98b3cea69592169ee4806d416" translate="yes" xml:space="preserve">
          <source>Minimal project</source>
          <target state="translated">최소 프로젝트</target>
        </trans-unit>
        <trans-unit id="656fbec7e4c8bcab6e3951b1194d9d3fdebdb947" translate="yes" xml:space="preserve">
          <source>Mixin classes can constrain the types of classes they can mix into by specifying a construct signature return type in the constraint for the type parameter. For example, the following &lt;code&gt;WithLocation&lt;/code&gt; function implements a subclass factory that adds a &lt;code&gt;getLocation&lt;/code&gt; method to any class that satisfies the &lt;code&gt;Point&lt;/code&gt; interface (i.e. that has &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; properties of type &lt;code&gt;number&lt;/code&gt;).</source>
          <target state="translated">Mixin 클래스는 type 매개 변수의 제약 조건에서 구문 서명 반환 형식을 지정하여 혼합 할 수있는 클래스 유형을 제한 할 수 있습니다. 예를 들어, 다음 &lt;code&gt;WithLocation&lt;/code&gt; 의 기능을 구현하는 추가 서브 클래스 공장 &lt;code&gt;getLocation&lt;/code&gt; 어떤 클래스 방법을 만족하는 &lt;code&gt;Point&lt;/code&gt; (즉 갖는 인터페이스 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 형의 특성 &lt;code&gt;number&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ed6542d9669951817ce6e0f5f573873a74bbcd94" translate="yes" xml:space="preserve">
          <source>Mixin sample</source>
          <target state="translated">믹스 인 샘플</target>
        </trans-unit>
        <trans-unit id="d634308003ff858f289d2833f637dfc9bee3fc78" translate="yes" xml:space="preserve">
          <source>Mixins</source>
          <target state="translated">Mixins</target>
        </trans-unit>
        <trans-unit id="a7b93d2128e820f861fc8dfccd9f5521e89ad21f" translate="yes" xml:space="preserve">
          <source>Mode</source>
          <target state="translated">Mode</target>
        </trans-unit>
        <trans-unit id="8686e36f3c455dfff0e15750343932a50c4f9345" translate="yes" xml:space="preserve">
          <source>Modular Libraries</source>
          <target state="translated">모듈 식 라이브러리</target>
        </trans-unit>
        <trans-unit id="e87eeaf0b3370593816d7faa70993da2a4c34bdc" translate="yes" xml:space="preserve">
          <source>Modular libraries will typically have at least some of the following:</source>
          <target state="translated">모듈 식 라이브러리는 일반적으로 다음 중 일부를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="679935999c06d0d64c305facc48d71ad3d62a359" translate="yes" xml:space="preserve">
          <source>Module Augmentation</source>
          <target state="translated">모듈 확대</target>
        </trans-unit>
        <trans-unit id="288e4a8c6676ea4eb83392ffcf2395bf08c232ab" translate="yes" xml:space="preserve">
          <source>Module Resolution</source>
          <target state="translated">모듈 확인</target>
        </trans-unit>
        <trans-unit id="e38eacd064c21c297854627bdac879933ce99fef" translate="yes" xml:space="preserve">
          <source>Module Resolution Strategies</source>
          <target state="translated">모듈 확인 전략</target>
        </trans-unit>
        <trans-unit id="4cd56198bb579b9f107f6cea74de7d094276eb7a" translate="yes" xml:space="preserve">
          <source>Module identifiers allow for &lt;code&gt;.js&lt;/code&gt; extension</source>
          <target state="translated">&lt;code&gt;.js&lt;/code&gt; 확장자를 허용하는 모듈 식별자</target>
        </trans-unit>
        <trans-unit id="a00b56b003050bea7431d876a345583f047b820c" translate="yes" xml:space="preserve">
          <source>Module imports are resolved differently based on whether the module reference is relative or non-relative.</source>
          <target state="translated">모듈 가져 오기는 모듈 참조가 상대적인지 아닌지에 따라 다르게 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="79dbe4a4af0851fd89a5e09eccc010e3219dbe7b" translate="yes" xml:space="preserve">
          <source>Module loaders like SystemJS wrap CommonJS modules and expose then as a &lt;code&gt;default&lt;/code&gt; ES6 import. This makes it impossible to share the definition files between the SystemJS and CommonJS implementation of the module as the module shape looks different based on the loader.</source>
          <target state="translated">SystemJS와 같은 모듈 로더는 CommonJS 모듈을 랩핑 한 다음 &lt;code&gt;default&lt;/code&gt; ES6 가져 오기 로 노출 합니다. 이는 로더에 따라 모듈 모양이 다르기 때문에 모듈의 SystemJS와 CommonJS 구현간에 정의 파일을 공유 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8706260383ba3213edb052d2ee2093acb606b380" translate="yes" xml:space="preserve">
          <source>Module resolution enhancements: BaseUrl, Path mapping, rootDirs and tracing</source>
          <target state="translated">모듈 해상도 향상 : BaseUrl, 경로 매핑, rootDirs 및 추적</target>
        </trans-unit>
        <trans-unit id="47f28156d69593c826cc9c4bbfcf281e3d6aa9d7" translate="yes" xml:space="preserve">
          <source>Module resolution kind is not specified, using &lt;strong&gt;&amp;lsquo;NodeJs&amp;rsquo;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;'NodeJs'를&lt;/strong&gt; 사용하여 모듈 분석 종류를 지정하지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="a30c7f6e8f418488e99ab172a19da443b4fdc2aa" translate="yes" xml:space="preserve">
          <source>Modules also have a dependency on a module loader (such as CommonJs/Require.js). For a small JS application this might not be optimal, but for larger applications, the cost comes with long term modularity and maintainability benefits. Modules provide for better code reuse, stronger isolation and better tooling support for bundling.</source>
          <target state="translated">모듈은 또한 모듈 로더 (예 : CommonJs / Require.js)에 종속됩니다. 소규모 JS 애플리케이션의 경우 이것이 최적이 아닐 수 있지만 대규모 애플리케이션의 경우 장기적인 모듈화 및 유지 관리 이점이 있습니다. 모듈은 더 나은 코드 재사용, 강력한 격리 및 번들링을위한 더 나은 툴링 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="78a50e79f8142b8f5f0f90d0fa7d14efea7d1c2f" translate="yes" xml:space="preserve">
          <source>Modules are declarative; the relationships between modules are specified in terms of imports and exports at the file level.</source>
          <target state="translated">모듈은 선언적입니다. 모듈 간의 관계는 파일 레벨에서 가져 오기 및 내보내기 측면에서 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="675dd99631ed01c0f9ec0b8b2aaed9ef0a2c4dfd" translate="yes" xml:space="preserve">
          <source>Modules are executed within their own scope, not in the global scope; this means that variables, functions, classes, etc. declared in a module are not visible outside the module unless they are explicitly exported using one of the &lt;a href=&quot;#export&quot;&gt;&lt;code&gt;export&lt;/code&gt; forms&lt;/a&gt;. Conversely, to consume a variable, function, class, interface, etc. exported from a different module, it has to be imported using one of the &lt;a href=&quot;#import&quot;&gt;&lt;code&gt;import&lt;/code&gt; forms&lt;/a&gt;.</source>
          <target state="translated">모듈은 전역 범위가 아닌 자체 범위 내에서 실행됩니다. 이는 모듈에 선언 된 변수, 함수, 클래스 등이 &lt;a href=&quot;#export&quot;&gt; &lt;code&gt;export&lt;/code&gt; 양식&lt;/a&gt; 중 하나를 사용하여 명시 적으로 내 보내지 않는 한 모듈 외부에서 볼 수 없음을 의미 합니다 . 반대로, 다른 모듈에서 내 보낸 변수, 함수, 클래스, 인터페이스 등을 사용하려면 &lt;a href=&quot;#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; 양식&lt;/a&gt; 중 하나를 사용하여 가져와야 합니다 .</target>
        </trans-unit>
        <trans-unit id="cf0193704c9e50ad766367f6e68a7b531b34d65e" translate="yes" xml:space="preserve">
          <source>Modules are now emitted with a &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; prologue</source>
          <target state="translated">모듈은 이제 &lt;code&gt;&quot;use strict&quot;;&lt;/code&gt; 방출됩니다 . 프롤로그</target>
        </trans-unit>
        <trans-unit id="e2a4a37826bb3f0f9a97d6eaca31fecba95d357a" translate="yes" xml:space="preserve">
          <source>Modules are parsed automatically in strict mode. The new flag is recommended for non-module code.</source>
          <target state="translated">엄격 모드에서는 모듈이 자동으로 구문 분석됩니다. 비 플래그 코드에는 새로운 플래그가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="5b28d96858ba2eea0c5a37016b2613ff4945fbf0" translate="yes" xml:space="preserve">
          <source>Modules can import types declared in other modules. But non-module global scripts cannot access types declared in modules. Enter &lt;code&gt;import&lt;/code&gt; types.</source>
          <target state="translated">모듈은 다른 모듈에서 선언 된 유형을 가져올 수 있습니다. 그러나 비 모듈 전역 스크립트는 모듈에 선언 된 유형에 액세스 할 수 없습니다. &lt;code&gt;import&lt;/code&gt; 유형을 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="f37a7873a73994ccdd158807226796e74f617880" translate="yes" xml:space="preserve">
          <source>Modules import one another using a module loader. At runtime the module loader is responsible for locating and executing all dependencies of a module before executing it. Well-known module loaders used in JavaScript are Node.js&amp;rsquo;s loader for &lt;a href=&quot;https://en.wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; modules and the &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; loader for &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/amd.html&quot;&gt;AMD&lt;/a&gt; modules in Web applications.</source>
          <target state="translated">모듈은 모듈 로더를 사용하여 서로 가져옵니다. 런타임시 모듈 로더는 모듈을 실행하기 전에 모듈의 모든 종속성을 찾아 실행해야합니다. JavaScript에 사용되는 잘 알려진 모듈 로더는 &lt;a href=&quot;https://en.wikipedia.org/wiki/CommonJS&quot;&gt;CommonJS&lt;/a&gt; 모듈 용 Node.js의 로더 이며 웹 응용 프로그램의 &lt;a href=&quot;https://github.com/amdjs/amdjs-api/blob/master/amd.html&quot;&gt;AMD&lt;/a&gt; 모듈 용 &lt;a href=&quot;http://requirejs.org/&quot;&gt;RequireJS&lt;/a&gt; 로더입니다 .</target>
        </trans-unit>
        <trans-unit id="f58764143073eae1cd29c9babec8bc1672b59332" translate="yes" xml:space="preserve">
          <source>Modules were always parsed in strict mode as per ES6, but for non-ES6 targets this was not respected in the generated code. Starting with TypeScript 1.8, emitted modules are always in strict mode. This shouldn&amp;rsquo;t have any visible changes in most code as TS considers most strict mode errors as errors at compile time, but it means that some things which used to silently fail at runtime in your TS code, like assigning to &lt;code&gt;NaN&lt;/code&gt;, will now loudly fail. You can reference the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDN Article&lt;/a&gt; on strict mode for a detailed list of the differences between strict mode and non-strict mode.</source>
          <target state="translated">모듈은 항상 ES6에 따라 엄격 모드로 구문 분석되었지만 ES6 이외의 대상의 경우 생성 된 코드에서이를 고려하지 않았습니다. TypeScript 1.8부터는 방출 모듈이 항상 엄격 모드입니다. TS가 컴파일 타임에 가장 엄격한 모드 오류를 오류로 간주하기 때문에 대부분의 코드에서 눈에 띄는 변화가 없어야하지만 TS 코드에서 런타임에 자동으로 실패하는 &lt;code&gt;NaN&lt;/code&gt; 할당과 같은 일부 는 이제 크게 들립니다. 불합격. 엄격 모드와 엄격하지 않은 모드의 차이점에 대한 자세한 목록은 엄격 모드 에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode&quot;&gt;MDN 아티클&lt;/a&gt; 을 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69245e47778546d5b4d8c60a97c075633036ce67" translate="yes" xml:space="preserve">
          <source>More Accurate Array Spread</source>
          <target state="translated">보다 정확한 어레이 확산</target>
        </trans-unit>
        <trans-unit id="867951121618b22e94ac0ddd378f75a352293d4f" translate="yes" xml:space="preserve">
          <source>More details about defining MSBuild compiler options: &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;Setting Compiler Options in MSBuild projects&lt;/a&gt;</source>
          <target state="translated">MSBuild 컴파일러 옵션 정의에 대한 자세한 내용 : &lt;a href=&quot;compiler-options-in-msbuild&quot;&gt;MSBuild 프로젝트에서 컴파일러 옵션 설정&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="341a196acd33aea44262f80c4074a8f29f17eab0" translate="yes" xml:space="preserve">
          <source>More details can be found at &lt;a href=&quot;http://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;Package Manager Dialog&lt;/a&gt; and &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;using nightly builds with NuGet&lt;/a&gt;</source>
          <target state="translated">자세한 내용은에서 찾을 수 있습니다 &lt;a href=&quot;http://docs.nuget.org/Consume/Package-Manager-Dialog&quot;&gt;패키지 관리자 대화 상자&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Nightly-drops#using-nuget-with-msbuild&quot;&gt;사용하여 야간 NuGet으로 구축&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53846a07e48104da9e41b5b1360721c3ad76cfc9" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm&quot;&gt;TypeScriptSamples/jspm&lt;/a&gt;</source>
          <target state="translated">자세한 내용 : &lt;a href=&quot;https://github.com/Microsoft/TypeScriptSamples/tree/master/jspm&quot;&gt;TypeScriptSamples / jspm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f54abbf20043f5f79ba176f97dcafaab83a262d" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/TypeStrong/grunt-ts&quot;&gt;TypeStrong/grunt-ts&lt;/a&gt;</source>
          <target state="translated">자세한 내용 : &lt;a href=&quot;https://github.com/TypeStrong/grunt-ts&quot;&gt;TypeStrong / grunt-ts&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4be1d9cace5494e189a22e68f895ee7cf9cddcd" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/frankwallis/duo-typescript&quot;&gt;frankwallis/duo-typescript&lt;/a&gt;</source>
          <target state="translated">자세한 내용 : &lt;a href=&quot;https://github.com/frankwallis/duo-typescript&quot;&gt;frankwallis / duo-typescript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9288db5f93cb0d64c4598820b26040518ce475e5" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/ivogabe/gulp-typescript&quot;&gt;ivogabe/gulp-typescript&lt;/a&gt;</source>
          <target state="translated">자세한 내용 : &lt;a href=&quot;https://github.com/ivogabe/gulp-typescript&quot;&gt;ivogabe / gulp-typescript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c2859a3239620cafb1098f30753d17591c86749" translate="yes" xml:space="preserve">
          <source>More details: &lt;a href=&quot;https://github.com/smrq/tsify&quot;&gt;smrq/tsify&lt;/a&gt;</source>
          <target state="translated">자세한 내용 : &lt;a href=&quot;https://github.com/smrq/tsify&quot;&gt;smrq / tsify&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="383f0e0e882a4dc2683b66372e6aa52e3a75f04b" translate="yes" xml:space="preserve">
          <source>More examples</source>
          <target state="translated">더 많은 예</target>
        </trans-unit>
        <trans-unit id="d6f53e513aa21c7609698b66494f900516f1e524" translate="yes" xml:space="preserve">
          <source>More information is available at &lt;a href=&quot;https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions&quot;&gt;VSCode documentation&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://code.visualstudio.com/Docs/languages/typescript#_using-newer-typescript-versions&quot;&gt;VSCode 설명서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ebf7c56cc3c7e6470d4e988436ec5ba45710c59" translate="yes" xml:space="preserve">
          <source>More information is available at the &lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation&quot;&gt;TypeScript Plugin for Sublime Text installation documentation&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript-Sublime-Plugin#installation&quot;&gt;Sublime Text 용 TypeScript 플러그인 설치 설명서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f1fd24b8a3a7e494a8b827fe826c345c6c39fc7" translate="yes" xml:space="preserve">
          <source>More more details, you can &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining/&quot;&gt;read up on the proposal&lt;/a&gt; and &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33294&quot;&gt;view the original pull request&lt;/a&gt;.</source>
          <target state="translated">더 자세한 내용은, 당신은 할 수 있습니다 &lt;a href=&quot;https://github.com/tc39/proposal-optional-chaining/&quot;&gt;제안에 읽어&lt;/a&gt; 하고 &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/33294&quot;&gt;원래의 풀 요청을 볼&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2090b67c917ff081773b34229e30e6990c49b179" translate="yes" xml:space="preserve">
          <source>More plainly, that code snippet is the same as writing the following.</source>
          <target state="translated">보다 명확하게 해당 코드 스 니펫은 다음을 작성하는 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ba3ba120356f7dea7aa61a6e3ef6b6565d3edcce" translate="yes" xml:space="preserve">
          <source>Most popular libraries are now available as UMD packages. Examples include &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt;, &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt;, &lt;a href=&quot;https://lodash.com/&quot;&gt;lodash&lt;/a&gt;, and many more.</source>
          <target state="translated">가장 인기있는 라이브러리는 이제 UMD 패키지로 제공됩니다. 예를 들어 &lt;a href=&quot;https://jquery.com/&quot;&gt;jQuery&lt;/a&gt; , &lt;a href=&quot;http://momentjs.com/&quot;&gt;Moment.js&lt;/a&gt; , &lt;a href=&quot;https://lodash.com/&quot;&gt;lodash&lt;/a&gt; 등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="638f05be2eca8814a76fc1ca76ad8fd857366420" translate="yes" xml:space="preserve">
          <source>Moving to TypeScript Files</source>
          <target state="translated">TypeScript 파일로 이동</target>
        </trans-unit>
        <trans-unit id="43621334a2a23b4d5d4b6053efcc9a2d2b0aab17" translate="yes" xml:space="preserve">
          <source>Much of the time when we talk about &amp;ldquo;singleton types&amp;rdquo;, we&amp;rsquo;re referring to both enum member types as well as numeric/string literal types, though many users will use &amp;ldquo;singleton types&amp;rdquo; and &amp;ldquo;literal types&amp;rdquo; interchangeably.</source>
          <target state="translated">많은 사람들이&amp;ldquo;단일 유형&amp;rdquo;과&amp;ldquo;문자 유형&amp;rdquo;을 상호 교환 적으로 사용하지만&amp;ldquo;단일 유형&amp;rdquo;에 대해 이야기 할 때 많은 경우에, 우리는 열거 형 멤버 유형과 숫자 / 문자열 리터럴 유형을 모두 언급하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="17529a071acaf46e503733acf690f3a9c40c2a13" translate="yes" xml:space="preserve">
          <source>Multi-file namespaces</source>
          <target state="translated">다중 파일 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="6a46449eba494ccdd3d50009ef86e5514ea905cd" translate="yes" xml:space="preserve">
          <source>Multiple decorators can be applied to a declaration, as in the following examples:</source>
          <target state="translated">다음 예제와 같이 선언에 여러 데코레이터를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c84cbd92065cb5c6f658fb4c2b736202ca88a094" translate="yes" xml:space="preserve">
          <source>Multiple fields</source>
          <target state="translated">여러 필드</target>
        </trans-unit>
        <trans-unit id="e64884c573469c4403ae3581451fc7bb26479d03" translate="yes" xml:space="preserve">
          <source>Multiple files that have the same &lt;code&gt;export namespace Foo {&lt;/code&gt; at top-level (don&amp;rsquo;t think that these are going to combine into one &lt;code&gt;Foo&lt;/code&gt;!)</source>
          <target state="translated">최상위에 동일한 &lt;code&gt;export namespace Foo {&lt;/code&gt; 를 가진 여러 파일 (이 파일들이 하나의 &lt;code&gt;Foo&lt;/code&gt; 로 결합 될 것이라고 생각하지 마십시오 !)</target>
        </trans-unit>
        <trans-unit id="c9a109a97c148517f646b23952e44c0d2099a11f" translate="yes" xml:space="preserve">
          <source>Multiple object literal type inferences for the same type parameter are similarly collapsed into a single normalized union type:</source>
          <target state="translated">동일한 형식 매개 변수에 대한 여러 개체 리터럴 형식 유추는 마찬가지로 표준화 된 단일 공용체 형식으로 축소됩니다.</target>
        </trans-unit>
        <trans-unit id="2e944fe6e675e7e28c8ee6b40790b0f75443bf77" translate="yes" xml:space="preserve">
          <source>MyClass.ts</source>
          <target state="translated">MyClass.ts</target>
        </trans-unit>
        <trans-unit id="9d75928f38872b5fba12d9e28028ca42f4f74a7f" translate="yes" xml:space="preserve">
          <source>MyFunc.ts</source>
          <target state="translated">MyFunc.ts</target>
        </trans-unit>
        <trans-unit id="6a6cd093331d4efd7bda9e1eec1f6de5f0b888e7" translate="yes" xml:space="preserve">
          <source>MyLargeModule.ts</source>
          <target state="translated">MyLargeModule.ts</target>
        </trans-unit>
        <trans-unit id="d4689856a3bbc2e7a56c851bfc734afc822d4050" translate="yes" xml:space="preserve">
          <source>MyTestPage.html (excerpt)</source>
          <target state="translated">MyTestPage.html (발췌)</target>
        </trans-unit>
        <trans-unit id="5621ae759c74cfb2dde7856d9cb911d0824e1648" translate="yes" xml:space="preserve">
          <source>MyThings.ts</source>
          <target state="translated">MyThings.ts</target>
        </trans-unit>
        <trans-unit id="4e93c1eccd779026bfe9421435d57abbf755af58" translate="yes" xml:space="preserve">
          <source>NOTE A &lt;em&gt;Property Descriptor&lt;/em&gt; is not provided as an argument to a property decorator due to how property decorators are initialized in TypeScript. This is because there is currently no mechanism to describe an instance property when defining members of a prototype, and no way to observe or modify the initializer for a property. The return value is ignored too. As such, a property decorator can only be used to observe that a property of a specific name has been declared for a class.</source>
          <target state="translated">주의점 &lt;em&gt;재산권 기술자&lt;/em&gt; 에 의한 재산 장식은 타이프 라이터로 초기화하는 방법에 속성 데코레이터에 대한 인수로 제공되지 않습니다. 현재 프로토 타입의 멤버를 정의 할 때 인스턴스 속성을 설명하는 메커니즘이없고 속성의 이니셜 라이저를 관찰하거나 수정할 수있는 방법이 없기 때문입니다. 반환 값도 무시됩니다. 따라서 속성 데코레이터는 특정 이름의 속성이 클래스에 선언되었음을 관찰하는 데만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9845c4ce119ecd689f1dfdba7ee10411216b49e9" translate="yes" xml:space="preserve">
          <source>NOTE A parameter decorator can only be used to observe that a parameter has been declared on a method.</source>
          <target state="translated">참고 매개 변수 데코레이터는 매개 변수가 메소드에서 선언되었음을 관찰하는 데만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b79455e774377963b080298d153feef0d875163" translate="yes" xml:space="preserve">
          <source>NOTE Decorator metadata is an experimental feature and may introduce breaking changes in future releases.</source>
          <target state="translated">주 데코레이터 메타 데이터는 실험적인 기능으로 향후 릴리스에서 주요 변경 사항이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2285b393e7b504af0a81971d53ea0b3d317886cd" translate="yes" xml:space="preserve">
          <source>NOTE Decorators are an experimental feature that may change in future releases.</source>
          <target state="translated">주 데코레이터는 향후 릴리스에서 변경 될 수있는 실험적인 기능입니다.</target>
        </trans-unit>
        <trans-unit id="a60eb9bd0a4289a1fdb762b911bc6c4ca3667c6d" translate="yes" xml:space="preserve">
          <source>NOTE Should you choose to return a new constructor function, you must take care to maintain the original prototype. The logic that applies decorators at runtime will &lt;strong&gt;not&lt;/strong&gt; do this for you.</source>
          <target state="translated">참고 새 생성자 함수를 반환하도록 선택한 경우 원래 프로토 타입을 유지 관리해야합니다. 런타임시 데코레이터를 적용하는 논리 는이를 수행하지 &lt;strong&gt;않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="60bdff9d3b04677acbffa7e2cc622c91f6a36bb2" translate="yes" xml:space="preserve">
          <source>NOTE The &lt;em&gt;Property Descriptor&lt;/em&gt; will be &lt;code&gt;undefined&lt;/code&gt; if your script target is less than &lt;code&gt;ES5&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;em&gt;재산권 기술자가&lt;/em&gt; 될 것입니다 &lt;code&gt;undefined&lt;/code&gt; 스크립트 목표보다 작은 경우 &lt;code&gt;ES5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3819f97fdfb5b90ae474745720dbbf7bdc58c9e6" translate="yes" xml:space="preserve">
          <source>NOTE The return value is ignored if your script target is less than &lt;code&gt;ES5&lt;/code&gt;.</source>
          <target state="translated">참고 스크립트 대상이 &lt;code&gt;ES5&lt;/code&gt; 미만인 경우 반환 값이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="195da41da17e46986e65163a2bd1160b912d7429" translate="yes" xml:space="preserve">
          <source>NOTE This example requires the &lt;code&gt;reflect-metadata&lt;/code&gt; library. See &lt;a href=&quot;#metadata&quot;&gt;Metadata&lt;/a&gt; for more information about the &lt;code&gt;reflect-metadata&lt;/code&gt; library.</source>
          <target state="translated">참고이 예에는 &lt;code&gt;reflect-metadata&lt;/code&gt; 라이브러리 가 필요합니다 . &lt;code&gt;reflect-metadata&lt;/code&gt; 라이브러리 에 대한 자세한 내용은 &lt;a href=&quot;#metadata&quot;&gt;메타 데이터&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a10f30aafff5360ca16967a3e15b058ca9402455" translate="yes" xml:space="preserve">
          <source>NOTE TypeScript disallows decorating both the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessor for a single member. Instead, all decorators for the member must be applied to the first accessor specified in document order. This is because decorators apply to a &lt;em&gt;Property Descriptor&lt;/em&gt;, which combines both the &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; accessor, not each declaration separately.</source>
          <target state="translated">참고 TypeScript 에서는 단일 멤버에 대한 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 접근자를 모두 장식 할 수 없습니다 . 대신 멤버의 모든 데코레이터를 문서 순서대로 지정된 첫 번째 접근 자에 적용해야합니다. 데코레이터가 &lt;em&gt;속성 설명자에&lt;/em&gt; 적용되기 때문에 각 선언이 아닌 &lt;code&gt;get&lt;/code&gt; 및 &lt;code&gt;set&lt;/code&gt; 접근 자를 결합합니다 .</target>
        </trans-unit>
        <trans-unit id="45308d86614845d7f3bb84b8a20942a74d48e6a9" translate="yes" xml:space="preserve">
          <source>NOTE You can see a more detailed example of a decorator factory in &lt;a href=&quot;#method-decorators&quot;&gt;Method Decorators&lt;/a&gt;, below.</source>
          <target state="translated">참고 아래의 &lt;a href=&quot;#method-decorators&quot;&gt;메소드 데코레이터&lt;/a&gt; 에서 데코레이터 팩토리에 대한 자세한 예를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77a213401e1d655ca6ce67ccac1b595b83f6a49a" translate="yes" xml:space="preserve">
          <source>NOTE You can see a more detailed example of a decorator in &lt;a href=&quot;#class-decorators&quot;&gt;Class Decorators&lt;/a&gt;, below.</source>
          <target state="translated">참고 아래의 &lt;a href=&quot;#class-decorators&quot;&gt;클래스 데코레이터&lt;/a&gt; 에서 데코레이터에 대한 자세한 예를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3bfed306b0b8464442bdb1711257fd81e5104011" translate="yes" xml:space="preserve">
          <source>Name and location of the import</source>
          <target state="translated">수입품의 이름과 위치</target>
        </trans-unit>
        <trans-unit id="c4e900249c06ced551414f6dbfecd4345fbf0964" translate="yes" xml:space="preserve">
          <source>Name your files with a &lt;code&gt;.tsx&lt;/code&gt; extension</source>
          <target state="translated">&lt;code&gt;.tsx&lt;/code&gt; 확장자로 파일 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="f1e1fdc0047ebce963af46e324aa0bb6cc3cd40b" translate="yes" xml:space="preserve">
          <source>Name your project and solution. After select the &lt;em&gt;Create&lt;/em&gt; button</source>
          <target state="translated">프로젝트와 솔루션의 이름을 지정하십시오. &lt;em&gt;생성&lt;/em&gt; 버튼을 선택한 후</target>
        </trans-unit>
        <trans-unit id="0449e1003dd0cdd92ab163e844540614258e8b38" translate="yes" xml:space="preserve">
          <source>Namespace</source>
          <target state="translated">Namespace</target>
        </trans-unit>
        <trans-unit id="62936894b0ebe54f16bb9d18daac6e4b06cda0b2" translate="yes" xml:space="preserve">
          <source>Namespaced Validators</source>
          <target state="translated">네임 스페이스 유효성 검사기</target>
        </trans-unit>
        <trans-unit id="be09a63bd1995e99cd22064cdc39a4bae464033d" translate="yes" xml:space="preserve">
          <source>Namespaces</source>
          <target state="translated">Namespaces</target>
        </trans-unit>
        <trans-unit id="6f67c77b8db69b7cbbe81780dca2a3cd93d34c20" translate="yes" xml:space="preserve">
          <source>Namespaces &amp;amp; Modules</source>
          <target state="translated">네임 스페이스 및 모듈</target>
        </trans-unit>
        <trans-unit id="9b1e65cb7124596d09d4502bbe02b71fb8a3d882" translate="yes" xml:space="preserve">
          <source>Namespaces and Modules</source>
          <target state="translated">네임 스페이스 및 모듈</target>
        </trans-unit>
        <trans-unit id="13339d851d51b5c81981062cf249473168c678ea" translate="yes" xml:space="preserve">
          <source>Namespaces are flexible enough to also merge with other types of declarations. To do so, the namespace declaration must follow the declaration it will merge with. The resulting declaration has properties of both declaration types. TypeScript uses this capability to model some of the patterns in JavaScript as well as other programming languages.</source>
          <target state="translated">네임 스페이스는 다른 유형의 선언과 병합 할 수있을만큼 유연합니다. 그렇게하려면 네임 스페이스 선언이 병합 할 선언을 따라야합니다. 결과 선언에는 두 선언 유형 모두의 속성이 있습니다. TypeScript는이 기능을 사용하여 JavaScript 및 기타 프로그래밍 언어의 일부 패턴을 모델링합니다.</target>
        </trans-unit>
        <trans-unit id="0fd9b6444054278bf7680e4f8067f50258da5add" translate="yes" xml:space="preserve">
          <source>Namespaces are important to avoid naming collisions in the global scope. For example, you might have &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; and &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; &amp;ndash; two types with the same name, but a different namespace. This, however, is not an issue with modules. Within a module, there&amp;rsquo;s no plausible reason to have two objects with the same name. From the consumption side, the consumer of any given module gets to pick the name that they will use to refer to the module, so accidental naming conflicts are impossible.</source>
          <target state="translated">네임 스페이스는 전역 범위에서 이름 충돌을 피하기 위해 중요합니다. 예를 들어 이름이 같지만 네임 스페이스가 다른 두 가지 유형 인 &lt;code&gt;My.Application.Customer.AddForm&lt;/code&gt; 및 &lt;code&gt;My.Application.Order.AddForm&lt;/code&gt; 이있을 수 있습니다 . 그러나 이것은 모듈의 문제가 아닙니다. 모듈 내에서 동일한 이름을 가진 두 개의 객체를 가질만한 이유는 없습니다. 소비 측면에서 특정 모듈의 소비자는 모듈을 참조하는 데 사용할 이름을 선택하므로 우연한 이름 충돌이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="5e4e7df3860290d042f9971740a7d47d81a9f02b" translate="yes" xml:space="preserve">
          <source>Namespaces are simply named JavaScript objects in the global namespace. This makes namespaces a very simple construct to use. They can span multiple files, and can be concatenated using &lt;code&gt;--outFile&lt;/code&gt;. Namespaces can be a good way to structure your code in a Web Application, with all dependencies included as &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags in your HTML page.</source>
          <target state="translated">네임 스페이스는 단순히 글로벌 네임 스페이스에서 JavaScript 객체로 명명됩니다. 이것은 네임 스페이스를 사용하기 매우 간단한 구조로 만듭니다. 여러 파일에 걸쳐있을 수 있으며 &lt;code&gt;--outFile&lt;/code&gt; 을 사용하여 연결할 수 있습니다 . 네임 스페이스는 웹 응용 프로그램에서 코드를 구성하는 좋은 방법이 될 수 있으며 HTML 페이지에 모든 종속성이 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그로 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="362b423baafd1e7b201b94eb4694146a945d2f27" translate="yes" xml:space="preserve">
          <source>Namespacing</source>
          <target state="translated">Namespacing</target>
        </trans-unit>
        <trans-unit id="166846adfb9918dc66f0055635e2541ff9496d41" translate="yes" xml:space="preserve">
          <source>Native ECMAScript 2015 modules SimpleModule.js</source>
          <target state="translated">기본 ECMAScript 2015 모듈 SimpleModule.js</target>
        </trans-unit>
        <trans-unit id="fe8c21145c9261ff78e4961a2b85ef9086d1cb41" translate="yes" xml:space="preserve">
          <source>Needless Namespacing</source>
          <target state="translated">불필요한 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="e41b56abbcfdf8901dfab715d721b400cec7b1fc" translate="yes" xml:space="preserve">
          <source>Neither module augmentations nor global augmentations can add new items to the top level scope - they can only &amp;ldquo;patch&amp;rdquo; existing declarations.</source>
          <target state="translated">모듈 기능 보강이나 전역 기능 보강은 최상위 항목에 새 항목을 추가 할 수 없으며 기존 선언 만 &quot;패치&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6bef57bae5c0e8838a79a353fc36602b74e1fc1" translate="yes" xml:space="preserve">
          <source>Nested and merged declarations</source>
          <target state="translated">중첩 및 병합 된 선언</target>
        </trans-unit>
        <trans-unit id="4d4cd8fe398e6e096cb8030f584f4c402cf52fc5" translate="yes" xml:space="preserve">
          <source>Nesting works to any level now, and merges correctly across files. Previously neither was the case.</source>
          <target state="translated">중첩은 이제 모든 수준에서 작동하며 파일간에 올바르게 병합됩니다. 이전에는 그렇지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="80c3052d33ccdee15ffaaa110c5c39072495fe63" translate="yes" xml:space="preserve">
          <source>Never</source>
          <target state="translated">Never</target>
        </trans-unit>
        <trans-unit id="1acaa361d7e585d276debdfd60f55c71408418be" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--alwaysStrict&lt;/code&gt;</source>
          <target state="translated">새롭고 &lt;code&gt;--alwaysStrict&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ac644d9fe3dbb3ac2dccc6d1b53a6bed2b697fc" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--declarationDir&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;--declarationDir&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="720d98b2f44f4640d6cfec4c055ef03a55e5d548" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--declarationMap&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;--declarationMap&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b89c753438c197bdc13cb6ed610b532eff5723f" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--downlevelIteration&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;--downlevelIteration&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a00d32452ace95eaef3db016e18a1198fbb4791b" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--emitDeclarationOnly&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;--emitDeclarationOnly&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8227c234e0daa0aaa18b885af7157a89a55e5b26" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--resolveJsonModule&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;--resolveJsonModule&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="805477b1e825abe5eda721395ad4816c0fd064db" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--skipLibCheck&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;--skipLibCheck&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fcbfed49c3a6bd382d5f91b01c13c2352408ca8e" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;--strict&lt;/code&gt; master option</source>
          <target state="translated">새로운- &lt;code&gt;--strict&lt;/code&gt; 마스터 옵션</target>
        </trans-unit>
        <trans-unit id="d911d8e68bbe08754a7470249f09d0d73ac4db62" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;.tsx&lt;/code&gt; file extension and &lt;code&gt;as&lt;/code&gt; operator</source>
          <target state="translated">새로운 &lt;code&gt;.tsx&lt;/code&gt; 의 파일 확장자와 &lt;code&gt;as&lt;/code&gt; 연산자</target>
        </trans-unit>
        <trans-unit id="84261bdb966ed15a62fb8f6e8d19c7f9f2c38198" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;jsx: react-native&lt;/code&gt;</source>
          <target state="translated">새로운 &lt;code&gt;jsx: react-native&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1306ec7c0fb90964d3f3b400158133f1b7d16572" translate="yes" xml:space="preserve">
          <source>New &lt;code&gt;unknown&lt;/code&gt; top type</source>
          <target state="translated">&lt;code&gt;unknown&lt;/code&gt; 새로운 유형</target>
        </trans-unit>
        <trans-unit id="70bbb8ec99677d5bef2d3951d16be6268f24f3eb" translate="yes" xml:space="preserve">
          <source>New TypeScript Playground</source>
          <target state="translated">새로운 TypeScript 놀이터</target>
        </trans-unit>
        <trans-unit id="6de3d5b36312b21832416e8730475cc96c42db45" translate="yes" xml:space="preserve">
          <source>New checks added to TypeScript are often off by default to avoid breaking existing projects. While avoiding breakage is a good thing, this strategy has the drawback of making it increasingly complex to choose the highest level of type safety, and doing so requires explicit opt-in action on every TypeScript release. With the &lt;code&gt;--strict&lt;/code&gt; option it becomes possible to choose maximum type safety with the understanding that additional errors might be reported by newer versions of the compiler as improved type checking features are added.</source>
          <target state="translated">기존 프로젝트가 중단되는 것을 막기 위해 TypeScript에 추가 된 새로운 검사는 종종 기본적으로 해제되어 있습니다. 파손을 피하는 것이 좋지만이 전략은 최고 수준의 유형 안전을 선택하는 것이 점점 더 복잡해 지므로 모든 TypeScript 릴리스에서 명시적인 옵트 인 조치가 필요하다는 단점이 있습니다. &lt;code&gt;--strict&lt;/code&gt; 옵션을 사용하면 향상된 유형 검사 기능이 추가됨에 따라 최신 버전의 컴파일러에서 추가 오류가보고 될 수 있다는 점을 이해하여 최대 유형 안전을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ba10c954271506a3bcae23fd68b8232b3e4e8de" translate="yes" xml:space="preserve">
          <source>Next we have an example of how to override the constructor.</source>
          <target state="translated">다음으로 생성자를 재정의하는 방법에 대한 예제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b330ca07a7da236f37925657529d467d0a58f857" translate="yes" xml:space="preserve">
          <source>Next we will add a new folder and call it &lt;code&gt;scripts&lt;/code&gt;.</source>
          <target state="translated">다음으로 새 폴더를 추가하고이를 &lt;code&gt;scripts&lt;/code&gt; 라고합니다 .</target>
        </trans-unit>
        <trans-unit id="b62c3108bc37dfcdf96234518498c091954b4711" translate="yes" xml:space="preserve">
          <source>Next, for each type variable introduced by an &lt;code&gt;infer&lt;/code&gt; (more later) declaration within &lt;code&gt;U&lt;/code&gt; collect a set of candidate types by inferring from &lt;code&gt;T&lt;/code&gt; to &lt;code&gt;U&lt;/code&gt; (using the same inference algorithm as type inference for generic functions). For a given &lt;code&gt;infer&lt;/code&gt; type variable &lt;code&gt;V&lt;/code&gt;, if any candidates were inferred from co-variant positions, the type inferred for &lt;code&gt;V&lt;/code&gt; is a union of those candidates. Otherwise, if any candidates were inferred from contra-variant positions, the type inferred for &lt;code&gt;V&lt;/code&gt; is an intersection of those candidates. Otherwise, the type inferred for &lt;code&gt;V&lt;/code&gt; is &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">다음으로, &lt;code&gt;U&lt;/code&gt; 내에서 &lt;code&gt;infer&lt;/code&gt; (보다 나중에) 선언에 의해 도입 된 각 유형 변수에 대해 &lt;code&gt;T&lt;/code&gt; 에서 &lt;code&gt;U&lt;/code&gt; 로 추론하여 (일반 함수의 유형 추론과 동일한 추론 알고리즘 사용) 후보 유형 세트를 수집합니다 . 주어진 &lt;code&gt;infer&lt;/code&gt; 유형 변수 &lt;code&gt;V&lt;/code&gt; 의 경우, 후보가 공변량 위치에서 추론 된 경우 &lt;code&gt;V&lt;/code&gt; 에 대해 추론되는 유형 은 해당 후보의 합집합입니다. 그렇지 않은 경우, 후보가 반 변형 위치에서 추론 된 경우 &lt;code&gt;V&lt;/code&gt; 에 대해 유추 된 유형 은 해당 후보의 교집합입니다. 그렇지 않으면 &lt;code&gt;V&lt;/code&gt; 에 대해 유추 된 유형 은 &lt;code&gt;never&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="149d602ff05c96e06423dc39ea5d234017f2a784" translate="yes" xml:space="preserve">
          <source>Next, if your version of Visual Studio does not already have the latest TypeScript, you can &lt;a href=&quot;https://www.typescriptlang.org/index.html#download-links&quot;&gt;install it&lt;/a&gt;.</source>
          <target state="translated">다음으로 Visual Studio 버전에 최신 TypeScript가없는 경우 &lt;a href=&quot;https://www.typescriptlang.org/index.html#download-links&quot;&gt;설치할 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="074954ffe368a9f868383848acfd3ad865a34cf0" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s create an &lt;code&gt;index.tsx&lt;/code&gt; in &lt;code&gt;src&lt;/code&gt; with the following source:</source>
          <target state="translated">다음 소스를 사용하여 &lt;code&gt;src&lt;/code&gt; 에 &lt;code&gt;index.tsx&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="56492bdb624437d084cf97ce29f5755c9355f32f" translate="yes" xml:space="preserve">
          <source>Next, we then use the class directly. Here we create a new variable called &lt;code&gt;greeterMaker&lt;/code&gt;. This variable will hold the class itself, or said another way its constructor function. Here we use &lt;code&gt;typeof Greeter&lt;/code&gt;, that is &amp;ldquo;give me the type of the &lt;code&gt;Greeter&lt;/code&gt; class itself&amp;rdquo; rather than the instance type. Or, more precisely, &amp;ldquo;give me the type of the symbol called &lt;code&gt;Greeter&lt;/code&gt;,&amp;rdquo; which is the type of the constructor function. This type will contain all of the static members of Greeter along with the constructor that creates instances of the &lt;code&gt;Greeter&lt;/code&gt; class. We show this by using &lt;code&gt;new&lt;/code&gt; on &lt;code&gt;greeterMaker&lt;/code&gt;, creating new instances of &lt;code&gt;Greeter&lt;/code&gt; and invoking them as before.</source>
          <target state="translated">다음으로 클래스를 직접 사용합니다. 여기 &lt;code&gt;greeterMaker&lt;/code&gt; 라는 새 변수를 만듭니다 . 이 변수는 클래스 자체를 보유하거나 생성자 함수를 다르게 설명합니다. 여기서 우리는 &lt;code&gt;typeof Greeter&lt;/code&gt; 를 사용 합니다. 즉, 인스턴스 유형이 아닌&amp;ldquo; &lt;code&gt;Greeter&lt;/code&gt; 클래스 자체 의 유형을 제공 합니다.&amp;rdquo; 또는 더 정확하게 는 생성자 함수의 유형 인&amp;ldquo; &lt;code&gt;Greeter&lt;/code&gt; 라는 심볼의 유형을 알려주십시오. &amp;rdquo;입니다. 이 유형에는 &lt;code&gt;Greeter&lt;/code&gt; 클래스의 인스턴스를 생성하는 생성자와 함께 Greeter의 모든 정적 멤버가 포함됩니다 . &lt;code&gt;greeterMaker&lt;/code&gt; 에서 &lt;code&gt;new&lt;/code&gt; 를 사용하여 &lt;code&gt;Greeter&lt;/code&gt; 의 새 인스턴스를 만들어 이를 보여줍니다. 이전과 같이 호출합니다.</target>
        </trans-unit>
        <trans-unit id="48fd249b15120ba7e0e8c493ff3db4c13ad95d86" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll add development-time dependencies on the &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ts-loader&lt;/a&gt; and &lt;a href=&quot;https://www.npmjs.com/package/source-map-loader&quot;&gt;source-map-loader&lt;/a&gt;.</source>
          <target state="translated">다음으로 &lt;a href=&quot;https://www.npmjs.com/package/ts-loader&quot;&gt;ts-loader&lt;/a&gt; 및 &lt;a href=&quot;https://www.npmjs.com/package/source-map-loader&quot;&gt;source-map-loader&lt;/a&gt; 에 개발 시간 종속성을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="dc79aea4b8183b17aa2b08058010210e82ecc955" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll create the class that will handle the combination of the two mixins. Let&amp;rsquo;s look at this in more detail to see how it does this:</source>
          <target state="translated">다음으로 두 믹스 인의 조합을 처리 할 클래스를 만듭니다. 이것이 어떻게 작동하는지 더 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="3da6f66c39205de12c1b0ea85576f12a60c67429" translate="yes" xml:space="preserve">
          <source>Nightly Builds</source>
          <target state="translated">야간 빌드</target>
        </trans-unit>
        <trans-unit id="cb01bbc0b3a89a2f95960449dd66e5b7ab419b0c" translate="yes" xml:space="preserve">
          <source>Nightly Builds: Using NuGet with MSBuild</source>
          <target state="translated">야간 빌드 : MSBuild와 함께 NuGet 사용</target>
        </trans-unit>
        <trans-unit id="269472362c2cb3218dea4a230801c99606e84281" translate="yes" xml:space="preserve">
          <source>Nightly Builds: Using npm</source>
          <target state="translated">야간 빌드 : npm 사용</target>
        </trans-unit>
        <trans-unit id="d29bc0fc428d8dd325a7aa22de797acf39705506" translate="yes" xml:space="preserve">
          <source>Nightly builds</source>
          <target state="translated">야간 빌드</target>
        </trans-unit>
        <trans-unit id="d7957143496bc3e4f3d8bec258d34ddbf9a66c00" translate="yes" xml:space="preserve">
          <source>No Implicit &lt;code&gt;any&lt;/code&gt;</source>
          <target state="translated">내재 된 &lt;code&gt;any&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a2211d43130f5295a9f394d970fa79e1787ca90" translate="yes" xml:space="preserve">
          <source>No Implicit &lt;code&gt;any&lt;/code&gt; for &lt;code&gt;this&lt;/code&gt;</source>
          <target state="translated">어떤 암시 적없는 &lt;code&gt;any&lt;/code&gt; 을위한 &lt;code&gt;this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2b9fbfb21cfa0b34035ba18cef71091f735deb52" translate="yes" xml:space="preserve">
          <source>No type is a subtype of or assignable to &lt;code&gt;never&lt;/code&gt; (except &lt;code&gt;never&lt;/code&gt; itself).</source>
          <target state="translated">어떤 유형에의 하위 유형 또는 양도 할 수 없습니다 &lt;code&gt;never&lt;/code&gt; (제외 &lt;code&gt;never&lt;/code&gt; 그 자체).</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
        <trans-unit id="0dc5564786f44ffe5d739e06a70c0a346cb415f8" translate="yes" xml:space="preserve">
          <source>Non-function members of the interfaces should be unique. If they are not unique, they must be of the same type. The compiler will issue an error if the interfaces both declare a non-function member of the same name, but of different types.</source>
          <target state="translated">인터페이스의 비 기능 구성원은 고유해야합니다. 고유하지 않은 경우 동일한 유형이어야합니다. 인터페이스가 모두 같은 이름이지만 기능이 다른 유형의 함수가 아닌 멤버를 선언하면 컴파일러에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1494b169c26da2fba5af5bb24c5a642f24c6c749" translate="yes" xml:space="preserve">
          <source>Non-generic spread expressions continue to be processed as before: Call and construct signatures are stripped, only non-method properties are preserved, and for properties with the same name, the type of the rightmost property is used. This contrasts with intersection types which concatenate call and construct signatures, preserve all properties, and intersect the types of properties with the same name. Thus, spreads of the same types may produce different results when they are created through instantiation of generic types:</source>
          <target state="translated">제네릭이 아닌 스프레드 식은 이전과 같이 계속 처리됩니다. 호출 및 구문 서명이 제거되고 메서드가 아닌 속성 만 보존되며 이름이 같은 속성의 경우 가장 오른쪽 속성 유형이 사용됩니다. 이는 호출을 연결하고 서명을 구성하고 모든 속성을 유지하며 동일한 이름의 속성 유형을 교차시키는 교차 유형과 대조됩니다. 따라서 동일한 유형의 스프레드는 일반 유형의 인스턴스화를 통해 생성 될 때 다른 결과를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f0cc9ae44503c7a979e12906895cd156851a3f6" translate="yes" xml:space="preserve">
          <source>Non-homomorphic types are essentially creating new properties, so they can&amp;rsquo;t copy property modifiers from anywhere.</source>
          <target state="translated">동형이 아닌 유형은 본질적으로 새로운 속성을 생성하므로 어디서나 속성 수정자를 복사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="67964b3d04ccfc686f4aea422e7f8a00b96d652b" translate="yes" xml:space="preserve">
          <source>Non-null and non-undefined type guards</source>
          <target state="translated">널이 아닌 및 정의되지 않은 유형 가드</target>
        </trans-unit>
        <trans-unit id="6dfb137ece21865c79297ea685dd84ed857ee8cd" translate="yes" xml:space="preserve">
          <source>Non-null and non-undefined type guards may use the &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;, &lt;code&gt;===&lt;/code&gt;, or &lt;code&gt;!==&lt;/code&gt; operator to compare to &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, as in &lt;code&gt;x != null&lt;/code&gt; or &lt;code&gt;x === undefined&lt;/code&gt;. The effects on subject variable types accurately reflect JavaScript semantics (e.g. double-equals operators check for both values no matter which one is specified whereas triple-equals only checks for the specified value).</source>
          <target state="translated">비 - 널 및 사용할 수있는 비 미정 형 가드 &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; , &lt;code&gt;===&lt;/code&gt; 또는 &lt;code&gt;!==&lt;/code&gt; 연산자 비교할 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 같이 &lt;code&gt;x != null&lt;/code&gt; 또는 &lt;code&gt;x === undefined&lt;/code&gt; . 주제 변수 유형에 미치는 영향은 JavaScript 의미를 정확하게 반영합니다 (예 : 이중 같음 연산자는 지정된 값에 관계없이 두 값을 모두 확인하지만 삼중 같음은 지정된 값만 확인).</target>
        </trans-unit>
        <trans-unit id="1429182fce7f9a8560f2257cc03417f636cfd4e4" translate="yes" xml:space="preserve">
          <source>Non-null assertion operator</source>
          <target state="translated">널이 아닌 어설 션 연산자</target>
        </trans-unit>
        <trans-unit id="8c77d1fe01b3d6b896e59e7ad679a030f98eb254" translate="yes" xml:space="preserve">
          <source>Non-nullable types have no meaning and are treated just as their original type:</source>
          <target state="translated">널 입력 불가능 유형은 의미가 없으며 원래 유형으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="eac50a4571700d4b796b3f2c2c60e4c14af40f6f" translate="yes" xml:space="preserve">
          <source>Non-unit types as union discriminants</source>
          <target state="translated">노동 조합 차별 자로서의 비 단위 유형</target>
        </trans-unit>
        <trans-unit id="80660f063a6440a3a7e05a18a3ba076eeaf007e6" translate="yes" xml:space="preserve">
          <source>NonNullable&amp;lt;T&amp;gt;</source>
          <target state="translated">NonNullable&amp;lt;T&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9e8dd4dc111ded7b2320e89d0f31eaa58c3daeae" translate="yes" xml:space="preserve">
          <source>Normally the compiler will attempt to resolve all module imports before it starts the compilation process. Every time it successfully resolves an &lt;code&gt;import&lt;/code&gt; to a file, the file is added to the set of files the compiler will process later on.</source>
          <target state="translated">일반적으로 컴파일러는 컴파일 프로세스를 시작하기 전에 모든 모듈 가져 오기를 해결하려고 시도합니다. 파일 로 &lt;code&gt;import&lt;/code&gt; 가 성공적으로 해결 될 때마다 파일은 컴파일러가 나중에 처리 할 파일 세트에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="fa102d6a31f636b67a2c1043b2e52c1f1dd3e13e" translate="yes" xml:space="preserve">
          <source>Normally, &lt;code&gt;tsc&lt;/code&gt; will produce outputs (&lt;code&gt;.js&lt;/code&gt; and &lt;code&gt;.d.ts&lt;/code&gt;) in the presence of syntax or type errors, unless &lt;code&gt;noEmitOnError&lt;/code&gt; is on. Doing this in an incremental build system would be very bad - if one of your out-of-date dependencies had a new error, you&amp;rsquo;d only see it &lt;em&gt;once&lt;/em&gt; because a subsequent build would skip building the now up-to-date project. For this reason, &lt;code&gt;tsc -b&lt;/code&gt; effectively acts as if &lt;code&gt;noEmitOnError&lt;/code&gt; is enabled for all projects.</source>
          <target state="translated">일반적으로, &lt;code&gt;tsc&lt;/code&gt; (출력을 생산할 예정 &lt;code&gt;.js&lt;/code&gt; 및 &lt;code&gt;.d.ts&lt;/code&gt; 을 하지 않는 구 타입 또는 에러의 존재 하에서) &lt;code&gt;noEmitOnError&lt;/code&gt; 가 에있다. 증분 빌드 시스템에서이 작업을 수행하는 것은 매우 나쁩니다. 오래된 종속성 중 하나에 새로운 오류가 발생 하면 후속 빌드에서 최신 프로젝트 빌드를 건너 뛰기 때문에 &lt;em&gt;한 번만&lt;/em&gt; 보게됩니다 . 이러한 이유로 &lt;code&gt;tsc -b&lt;/code&gt; 는 모든 프로젝트에 대해 &lt;code&gt;noEmitOnError&lt;/code&gt; 가 활성화 된 것처럼 효과적으로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="3d901c000076266c2726be52567eee3a9e906da5" translate="yes" xml:space="preserve">
          <source>Not all merges are allowed in TypeScript. Currently, classes can not merge with other classes or with variables. For information on mimicking class merging, see the &lt;a href=&quot;mixins&quot;&gt;Mixins in TypeScript&lt;/a&gt; section.</source>
          <target state="translated">TypeScript에서 모든 병합이 허용되는 것은 아닙니다. 현재 클래스는 다른 클래스 또는 변수와 병합 할 수 없습니다. 클래스 병합 모방에 대한 정보 &lt;a href=&quot;mixins&quot;&gt;는 TypeScript의 믹스 인&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0fecf4145f603258529bada9dcd0bcbc05978112" translate="yes" xml:space="preserve">
          <source>Not all properties of an interface may be required. Some exist under certain conditions or may not be there at all. These optional properties are popular when creating patterns like &amp;ldquo;option bags&amp;rdquo; where you pass an object to a function that only has a couple of properties filled in.</source>
          <target state="translated">인터페이스의 모든 속성이 필요한 것은 아닙니다. 일부는 특정 조건 하에서 존재하거나 전혀 존재하지 않을 수 있습니다. 이러한 선택적 속성은 객체가 몇 개의 속성 만 채워진 함수에 전달되는&amp;ldquo;옵션 백&amp;rdquo;과 같은 패턴을 만들 때 널리 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="4738934001095b56c8ba017549da8753b92711d7" translate="yes" xml:space="preserve">
          <source>Note any tags which are not explicitly listed below (such as &lt;code&gt;@async&lt;/code&gt;) are not yet supported.</source>
          <target state="translated">아래에 명시 적으로 나열되지 않은 태그 (예 : &lt;code&gt;@async&lt;/code&gt; )는 아직 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="034f4525d05999ff963000183c0ac076ec562336" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@enum&lt;/code&gt; is quite different from, and much simpler than, Typescript&amp;rsquo;s &lt;code&gt;enum&lt;/code&gt;. However, unlike Typescript&amp;rsquo;s enums, &lt;code&gt;@enum&lt;/code&gt; can have any type:</source>
          <target state="translated">참고 &lt;code&gt;@enum&lt;/code&gt; 는 상당히 다른, 그리고, 타이프 라이터의 것보다 훨씬 간단 &lt;code&gt;enum&lt;/code&gt; . 그러나 Typescript의 열거 형과 달리 &lt;code&gt;@enum&lt;/code&gt; 은 모든 유형을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a50c9eb18039f11d764d2dd9c6139bfa5f2ed615" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;@extends&lt;/code&gt; only works with classes. Currently, there is no way for a constructor function extend a class.</source>
          <target state="translated">참고 &lt;code&gt;@extends&lt;/code&gt; 는 클래스 만 작동합니다. 현재 생성자 함수가 클래스를 확장 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a0526a2b13316a828fc44ba4c43a0a7de6c3d55" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; are so useful, they are included in TypeScript&amp;rsquo;s standard library along with &lt;code&gt;Pick&lt;/code&gt; and &lt;code&gt;Record&lt;/code&gt;:</source>
          <target state="translated">참고 &lt;code&gt;Readonly&amp;lt;T&amp;gt;&lt;/code&gt; 와 &lt;code&gt;Partial&amp;lt;T&amp;gt;&lt;/code&gt; , 그들과 함께 타이프의 표준 라이브러리에 매우 유용하게 포함되어 있습니다 &lt;code&gt;Pick&lt;/code&gt; 및 &lt;code&gt;Record&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1258e6d6b1a495d8e56ed02d68cc95af53525487" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;y&lt;/code&gt; has an extra &lt;code&gt;location&lt;/code&gt; property, but this does not create an error. Only members of the target type (&lt;code&gt;Named&lt;/code&gt; in this case) are considered when checking for compatibility.</source>
          <target state="translated">참고 것을 &lt;code&gt;y&lt;/code&gt; 추가가 &lt;code&gt;location&lt;/code&gt; 속성을하지만,이 오류를 생성하지 않습니다. 호환성을 확인할 때는 대상 유형 ( 이 경우 &lt;code&gt;Named&lt;/code&gt; 의 멤버 만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="52de29b3288a647d26453cfca4097defc33488b8" translate="yes" xml:space="preserve">
          <source>Note that TypeScript treats &lt;code&gt;null&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt; differently in order to match JavaScript semantics. &lt;code&gt;string | null&lt;/code&gt; is a different type than &lt;code&gt;string | undefined&lt;/code&gt; and &lt;code&gt;string | undefined | null&lt;/code&gt;.</source>
          <target state="translated">TypeScript는 JavaScript 의미와 일치시키기 위해 &lt;code&gt;null&lt;/code&gt; 과 &lt;code&gt;undefined&lt;/code&gt; 를 다르게 처리합니다 . &lt;code&gt;string | null&lt;/code&gt; 은 &lt;code&gt;string | undefined&lt;/code&gt; 과 다른 유형입니다. | 정의 및 &lt;code&gt;string | undefined | null&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fad3fa5b17d28ad4ad1296cea04ea7aae98a3e8a" translate="yes" xml:space="preserve">
          <source>Note that as with &lt;code&gt;tsconfig.json&lt;/code&gt; / &lt;code&gt;-p&lt;/code&gt;, existing TypeScript project properties will not be respected - all settings should be managed using your tsconfig file.</source>
          <target state="translated">&lt;code&gt;tsconfig.json&lt;/code&gt; / &lt;code&gt;-p&lt;/code&gt; 와 마찬가지로 기존 TypeScript 프로젝트 속성은 고려되지 않으며 모든 설정은 tsconfig 파일을 사용하여 관리해야합니다.</target>
        </trans-unit>
        <trans-unit id="b588c9ab272861e6d668b1d11af54118f839ddd3" translate="yes" xml:space="preserve">
          <source>Note that global variables declared with &lt;code&gt;let&lt;/code&gt; and &lt;code&gt;const&lt;/code&gt; don&amp;rsquo;t show up on &lt;code&gt;globalThis&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;let&lt;/code&gt; 과 &lt;code&gt;const&lt;/code&gt; 로 선언 된 전역 변수는 &lt;code&gt;globalThis&lt;/code&gt; 에 표시되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f628326a2f77697a922d2fe82dda47c7b50dda0f" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;bar&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, our code will still hit an error accessing &lt;code&gt;baz&lt;/code&gt;. Likewise, if &lt;code&gt;baz&lt;/code&gt; is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt;, we&amp;rsquo;ll hit an error at the call site. &lt;code&gt;?.&lt;/code&gt; only checks for whether the value on the &lt;em&gt;left&lt;/em&gt; of it is &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; - not any of the subsequent properties.</source>
          <target state="translated">참고 경우 것이 &lt;code&gt;bar&lt;/code&gt; 있다 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; , 우리의 코드는 여전히 액세스 할 경우에 에러 칠 것이다 &lt;code&gt;baz&lt;/code&gt; . 마찬가지로 &lt;code&gt;baz&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 인 경우 호출 사이트에서 오류가 발생합니다. &lt;code&gt;?.&lt;/code&gt; &lt;em&gt;왼쪽&lt;/em&gt; 의 값 이 &lt;code&gt;null&lt;/code&gt; 인지 &lt;code&gt;undefined&lt;/code&gt; 않은지 여부 만 확인 하며 후속 속성은 없습니다.</target>
        </trans-unit>
        <trans-unit id="9bc1e2dc91d339a1731d988771c4e0964ee425ef" translate="yes" xml:space="preserve">
          <source>Note that in &lt;code&gt;--strictNullChecks&lt;/code&gt; mode, when a homomorphic mapped type removes a &lt;code&gt;?&lt;/code&gt; modifier from a property in the underlying type it also removes &lt;code&gt;undefined&lt;/code&gt; from the type of that property:</source>
          <target state="translated">에 있습니다 &lt;code&gt;--strictNullChecks&lt;/code&gt; 모드, 호모 모르 픽 매핑 유형이 제거 &lt;code&gt;?&lt;/code&gt; 기본 유형의 속성에서 수정 자 또한 해당 속성의 유형에서 &lt;code&gt;undefined&lt;/code&gt; 을 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="eea4e2c81bc66e020338b949c3e934f29a66e808" translate="yes" xml:space="preserve">
          <source>Note that in TypeScript 1.4, when accessing an element outside the set of known indices, a union type is used instead:</source>
          <target state="translated">TypeScript 1.4에서는 알려진 인덱스 집합 외부의 요소에 액세스 할 때 공용체 유형이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="739942391df257a53a10ec2f75e3c9725103c615" translate="yes" xml:space="preserve">
          <source>Note that in this example, we added a value to the &lt;em&gt;static&lt;/em&gt; side of &lt;code&gt;C&lt;/code&gt; (its constructor function). This is because we added a &lt;em&gt;value&lt;/em&gt;, and the container for all values is another value (types are contained by namespaces, and namespaces are contained by other namespaces).</source>
          <target state="translated">이 예에서는 &lt;code&gt;C&lt;/code&gt; 의 &lt;em&gt;정적&lt;/em&gt; 측 (생성자 함수)에 값을 추가했습니다 . 이는 &lt;em&gt;value를&lt;/em&gt; 추가하고 모든 값의 컨테이너가 다른 값 이기 때문입니다 (유형은 네임 스페이스에 포함되고 네임 스페이스는 다른 네임 스페이스에 포함됨).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d0af180e34bef9f30805628b530dfa3020972dea" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s possible to define many types in the global scope when writing a global declaration file. We strongly discourage this as it leads to possible unresolvable name conflicts when many declaration files are in a project.</source>
          <target state="translated">전역 선언 파일을 작성할 때 전역 범위에서 많은 유형을 정의 할 수 있습니다. 많은 선언 파일이 프로젝트에있을 때 해결할 수없는 이름 충돌이 발생할 수 있으므로이 방법을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="907347b9fd2f8faa12df54e188fdcc427177ea81" translate="yes" xml:space="preserve">
          <source>Note that parentheses are optional for union types.</source>
          <target state="translated">괄호는 공용체 유형의 경우 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="4fabbe755152dc7983d25e5f9f36d98457b37c5e" translate="yes" xml:space="preserve">
          <source>Note that partial overlap is still permitted as long as the property types are valid.</source>
          <target state="translated">속성 유형이 유효한 한 부분 오버랩이 여전히 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="cc68887371a320bc99d4047b11fa95c7b5bed915" translate="yes" xml:space="preserve">
          <source>Note that relative module imports are not impacted by setting the baseUrl, as they are always resolved relative to their importing files.</source>
          <target state="translated">상대 모듈 가져 오기는 baseUrl을 설정해도 영향을받지 않습니다. 이는 항상 가져 오기 파일을 기준으로 해결되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="7f7166fe564b0ad642ff41fe82fc874132e2ab74" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;&quot;typings&quot;&lt;/code&gt; field is synonymous with &lt;code&gt;&quot;types&quot;&lt;/code&gt;, and could be used as well.</source>
          <target state="translated">있습니다 &lt;code&gt;&quot;typings&quot;&lt;/code&gt; 필드의 대명사 &lt;code&gt;&quot;types&quot;&lt;/code&gt; ,뿐만 아니라 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="4b2efe58a5ebfdb3d94ff74e3c4e2bfaf07628f5" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;function pickCard(x): any&lt;/code&gt; piece is not part of the overload list, so it only has two overloads: one that takes an object and one that takes a number. Calling &lt;code&gt;pickCard&lt;/code&gt; with any other parameter types would cause an error.</source>
          <target state="translated">그 주 &lt;code&gt;function pickCard(x): any&lt;/code&gt; 목적을 얻어 하나의 숫자를 취 하나가 두 과부하를 갖도록 조각 과부하리스트의 일부가 아니다. 다른 매개 변수 유형으로 &lt;code&gt;pickCard&lt;/code&gt; 를 호출 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d805d68393f371b58b5632620fd80bca6ffff116" translate="yes" xml:space="preserve">
          <source>Note that this collapsing should only occur when all overloads have the same return type.</source>
          <target state="translated">이 붕괴는 모든 과부하가 동일한 반환 유형을 갖는 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="067bba3132c520df5de825dbb6713533d577f153" translate="yes" xml:space="preserve">
          <source>Note that this does not imply tuples represent immutable arrays, but it is an implied convention.</source>
          <target state="translated">이것은 튜플이 불변 배열을 나타내는 것은 아닙니다만, 이것은 암묵적인 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="00c87ccc96ac44dfdeaad5b5ee7925bc2c9a2141" translate="yes" xml:space="preserve">
          <source>Note that this is a breaking change for some code. If you need to resort to the original behavior in which tuples only enforce a minimum length, you can use a similar declaration that does not explicitly define a &lt;code&gt;length&lt;/code&gt; property, falling back to &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">이것은 일부 코드의 주요 변경 사항입니다. 튜플이 최소 길이 만 적용하는 원래 동작에 의존해야하는 경우 &lt;code&gt;length&lt;/code&gt; 속성을 명시 적으로 정의하지 않고 &lt;code&gt;number&lt;/code&gt; 로 돌아가는 유사한 선언을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2da7ac7b1000043c557ae42f5143ae70cebcc452" translate="yes" xml:space="preserve">
          <source>Note that this syntax describes a type rather than a member. If you want to add members, you can use an intersection type:</source>
          <target state="translated">이 구문은 멤버가 아닌 유형을 설명합니다. 멤버를 추가하려는 경우 교차 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24ee265701152c1f723e8f2dfcc2a5432fb8e8f0" translate="yes" xml:space="preserve">
          <source>Note that this unwrapping inference only works on homomorphic mapped types. If the mapped type is not homomorphic you&amp;rsquo;ll have to give an explicit type parameter to your unwrapping function.</source>
          <target state="translated">이 언 래핑 추론은 동형 매핑 된 유형에서만 작동합니다. 매핑 된 유형이 동형이 아닌 경우 언 래핑 함수에 명시 적 유형 매개 변수를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="eead77930da9ed7756b7450464191e29579bb786" translate="yes" xml:space="preserve">
          <source>Note that we cannot add to type aliases (&lt;code&gt;type s = string;&lt;/code&gt;) using an interface.</source>
          <target state="translated">인터페이스를 사용하여 유형 별칭 ( &lt;code&gt;type s = string;&lt;/code&gt; )에 추가 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a04a128b4126a71144c52f15a922d0f362febded" translate="yes" xml:space="preserve">
          <source>Note that we currently only support discriminant properties of string literal types. We intend to later add support for boolean and numeric literal types.</source>
          <target state="translated">현재 문자열 리터럴 유형의 판별 특성 만 지원합니다. 나중에 부울 및 숫자 리터럴 유형에 대한 지원을 추가하려고합니다.</target>
        </trans-unit>
        <trans-unit id="8866bd22d60ec16a512c3e18fc8883ee9088f218" translate="yes" xml:space="preserve">
          <source>Note that we didn&amp;rsquo;t make &lt;code&gt;b&lt;/code&gt; optional here because the return types of the signatures differ.</source>
          <target state="translated">서명의 반환 유형이 다르기 때문에 여기서 &lt;code&gt;b&lt;/code&gt; 를 선택적으로 만들지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="94ec1d6aab212f5e757f0e4659331e046f79564c" translate="yes" xml:space="preserve">
          <source>Note that when a tuple type is inferred from a sequence of parameters and later expanded into a parameter list, as is the case for &lt;code&gt;U&lt;/code&gt;, the original parameter names are used in the expansion (however, the names have no semantic meaning and are not otherwise observable).</source>
          <target state="translated">튜플 유형이 일련의 매개 변수에서 유추되고 나중에 &lt;code&gt;U&lt;/code&gt; 의 경우와 같이 매개 변수 목록으로 확장 되면 원래 매개 변수 이름이 확장에 사용됩니다 (단, 의미는 의미가 없으며 다른 의미는 아닙니다) 주목할 만한).</target>
        </trans-unit>
        <trans-unit id="71b62ae2aa2aff8c7c71bbad8ff17968c2580e86" translate="yes" xml:space="preserve">
          <source>Note that when using these flags together, TypeScript doesn&amp;rsquo;t necessarily have to downlevel &lt;code&gt;.js&lt;/code&gt; files. If you simply want TypeScript to create &lt;code&gt;.d.ts&lt;/code&gt; files, you can use the &lt;code&gt;--emitDeclarationOnly&lt;/code&gt; compiler option.</source>
          <target state="translated">이러한 플래그를 함께 사용하는 경우 TypeScript가 반드시 &lt;code&gt;.js&lt;/code&gt; 파일 을 다운 레벨 할 필요는 없습니다 . TypeScript가 &lt;code&gt;.d.ts&lt;/code&gt; 파일 을 만들려면 &lt;code&gt;--emitDeclarationOnly&lt;/code&gt; 컴파일러 옵션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d88437440fe56ffd946a572ef7fc0f549aafede2" translate="yes" xml:space="preserve">
          <source>Note that while this example uses &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;function components&lt;/a&gt;, we could also make our example a little &lt;em&gt;classier&lt;/em&gt; as well.</source>
          <target state="translated">이 예제가 사용하는 동안주의 &lt;a href=&quot;https://reactjs.org/docs/components-and-props.html#functional-and-class-components&quot;&gt;구성 요소를 작동&lt;/a&gt; , 우리는 또한 우리의 예를 조금 할 수 &lt;em&gt;classier&lt;/em&gt; 뿐만 아니라.</target>
        </trans-unit>
        <trans-unit id="f4126eba79591c06a88ec80a2218d901b6a7fced" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; targets latest supported</source>
          <target state="translated">참고 : &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; 는 최신 지원 대상</target>
        </trans-unit>
        <trans-unit id="00f6312a7e060d93f44452f049fdc1698e20c055" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; targets latest supported &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES proposed features&lt;/a&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;&quot;ESNext&quot;&lt;/code&gt; 는 지원되는 최신 &lt;a href=&quot;https://github.com/tc39/proposals&quot;&gt;ES 제안 기능을&lt;/a&gt; 대상으로 합니다 .</target>
        </trans-unit>
        <trans-unit id="eff587a71ddbf90b7c884baa1aa1a82827ace5dd" translate="yes" xml:space="preserve">
          <source>Note: Avoid using &lt;code&gt;Object&lt;/code&gt; in favor of the non-primitive &lt;code&gt;object&lt;/code&gt; type as described in our &lt;a href=&quot;declaration-files/do-s-and-don-ts#general-types&quot;&gt;Do&amp;rsquo;s and Don&amp;rsquo;ts&lt;/a&gt; section.</source>
          <target state="translated">참고 :하지 &lt;a href=&quot;declaration-files/do-s-and-don-ts#general-types&quot;&gt;말아야 할 것과하지 말아야 할&lt;/a&gt; 섹션에 설명 된 것처럼 기본이 아닌 &lt;code&gt;object&lt;/code&gt; 유형 에 유리하게 &lt;code&gt;Object&lt;/code&gt; 를 사용 하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="c1444747b0861651e319b205e1c59d9ae374ba31" translate="yes" xml:space="preserve">
          <source>Note: Function Components were formerly known as Stateless Function Components (SFC). As Function Components can no longer be considered stateless in recent versions of react, the type &lt;code&gt;SFC&lt;/code&gt; and its alias &lt;code&gt;StatelessComponent&lt;/code&gt; were deprecated.</source>
          <target state="translated">참고 : 기능 구성 요소는 이전에는 상태 비 저장 기능 구성 요소 (SFC)로 알려져 있습니다. 최신 버전의 반응에서는 함수 구성 요소를 더 이상 상태 비 저장으로 간주 할 수 없으므로 &lt;code&gt;SFC&lt;/code&gt; 유형 및 별명 &lt;code&gt;StatelessComponent&lt;/code&gt; 는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2167c13fca90fe94989b38585bc930d77ebf1308" translate="yes" xml:space="preserve">
          <source>Note: If &lt;code&gt;--lib&lt;/code&gt; is not specified a default list of libraries are injected. The default libraries injected are:</source>
          <target state="translated">참고 : &lt;code&gt;--lib&lt;/code&gt; 를 지정하지 않으면 기본 라이브러리 목록이 삽입됩니다. 주입 된 기본 라이브러리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="284acafdfa85eadac42feff0fa8aca15b6a97293" translate="yes" xml:space="preserve">
          <source>Note: If an attribute name is not a valid JS identifier (like a &lt;code&gt;data-*&lt;/code&gt; attribute), it is not considered to be an error if it is not found in the element attributes type.</source>
          <target state="translated">참고 : 속성 이름이 유효한 JS 식별자 (예 : &lt;code&gt;data-*&lt;/code&gt; 속성)가 아닌 경우 요소 속성 유형에서 찾을 수없는 경우 오류로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e941b79a012efff59ecdd0cbaa4fcd9aa032b565" translate="yes" xml:space="preserve">
          <source>Note: Most changes do not require you to install a new version of the VS TypeScript plugin.</source>
          <target state="translated">참고 : 대부분의 변경으로 인해 새 버전의 VS TypeScript 플러그인을 설치할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="70970313d46e20ac27b9140a27eba7644c3d73af" translate="yes" xml:space="preserve">
          <source>Note: Previous syntax defining internal modules are still supported.</source>
          <target state="translated">참고 : 내부 모듈을 정의하는 이전 구문은 계속 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="98d80fe98cbbdfa6ce68828aed81191aecaa3aa8" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;Exclude&lt;/code&gt; type is a proper implementation of the &lt;code&gt;Diff&lt;/code&gt; type suggested &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;here&lt;/a&gt;. We&amp;rsquo;ve used the name &lt;code&gt;Exclude&lt;/code&gt; to avoid breaking existing code that defines a &lt;code&gt;Diff&lt;/code&gt;, plus we feel that name better conveys the semantics of the type.</source>
          <target state="translated">참고 : &lt;code&gt;Exclude&lt;/code&gt; 유형은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;여기에&lt;/a&gt; 제안 된 &lt;code&gt;Diff&lt;/code&gt; 유형 의 올바른 구현입니다 . &lt;code&gt;Exclude&lt;/code&gt; 라는 이름을 사용하여 &lt;code&gt;Diff&lt;/code&gt; 를 정의하는 기존 코드가 깨지지 않도록 하고 해당 이름이 형식의 의미를보다 잘 전달한다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="3b301e8bc42764dd4dd4644d5e8e453ac7e989ae" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;Exclude&lt;/code&gt; type is a proper implementation of the &lt;code&gt;Diff&lt;/code&gt; type suggested &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;here&lt;/a&gt;. We&amp;rsquo;ve used the name &lt;code&gt;Exclude&lt;/code&gt; to avoid breaking existing code that defines a &lt;code&gt;Diff&lt;/code&gt;, plus we feel that name better conveys the semantics of the type. We did not include the &lt;code&gt;Omit&amp;lt;T, K&amp;gt;&lt;/code&gt; type because it is trivially written as &lt;code&gt;Pick&amp;lt;T, Exclude&amp;lt;keyof T, K&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;Exclude&lt;/code&gt; 유형은 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458&quot;&gt;여기에&lt;/a&gt; 제안 된 &lt;code&gt;Diff&lt;/code&gt; 유형 의 올바른 구현입니다 . &lt;code&gt;Exclude&lt;/code&gt; 라는 이름을 사용하여 &lt;code&gt;Diff&lt;/code&gt; 를 정의하는 기존 코드가 깨지지 않도록 하고 해당 이름이 형식의 의미를보다 잘 전달한다고 생각합니다. &lt;code&gt;Omit&amp;lt;T, K&amp;gt;&lt;/code&gt; 유형은 &lt;code&gt;Pick&amp;lt;T, Exclude&amp;lt;keyof T, K&amp;gt;&amp;gt;&lt;/code&gt; 포함하지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="890949cc49cb65675bbdc6a302bba418a9f75399" translate="yes" xml:space="preserve">
          <source>Note: The new behavior is added under a flag to avoid unwarranted breaks to existing code bases. &lt;strong&gt;We highly recommend applying it both to new and existing projects.&lt;/strong&gt; For existing projects, namespace imports (&lt;code&gt;import * as express from &quot;express&quot;; express();&lt;/code&gt;) will need to be converted to default imports (&lt;code&gt;import express from &quot;express&quot;; express();&lt;/code&gt;).</source>
          <target state="translated">참고 : 기존 코드베이스에 대한 불필요한 중단을 피하기 위해 플래그 아래에 새로운 동작이 추가되었습니다. &lt;strong&gt;새로운 프로젝트와 기존 프로젝트 모두에 적용하는 것이 좋습니다.&lt;/strong&gt; 기존 프로젝트의 경우 네임 스페이스 가져 오기 ( &lt;code&gt;import * as express from &quot;express&quot;; express();&lt;/code&gt; )를 기본 가져 &lt;code&gt;import express from &quot;express&quot;; express();&lt;/code&gt; 로 변환해야합니다 ( import express from &quot;express&quot;; express (); ).</target>
        </trans-unit>
        <trans-unit id="1ed11ffc3601c3d16f34bfee2955149b8374ad13" translate="yes" xml:space="preserve">
          <source>Note: This change brings a new emit helper, &lt;code&gt;__makeTemplateObject&lt;/code&gt;; if you are using &lt;code&gt;--importHelpers&lt;/code&gt; with &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt;&lt;code&gt;tslib&lt;/code&gt;&lt;/a&gt;, an updated to version 1.8 or later.</source>
          <target state="translated">참고 :이 변경으로 새로운 방출 도우미 &lt;code&gt;__makeTemplateObject&lt;/code&gt; 가 제공됩니다 . &lt;a href=&quot;https://github.com/Microsoft/tslib&quot;&gt; &lt;code&gt;tslib&lt;/code&gt; &lt;/a&gt; 와 함께 &lt;code&gt;--importHelpers&lt;/code&gt; 를 사용하는 경우 버전 1.8 이상으로 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="f9c2b580006a52af1ed6b77bbd97ca85b4b1524b" translate="yes" xml:space="preserve">
          <source>Note: This type only works correctly if &lt;code&gt;--strictFunctionTypes&lt;/code&gt; is enabled. See &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/32964&quot;&gt;#32964&lt;/a&gt;.</source>
          <target state="translated">참고 :이 유형 은 &lt;code&gt;--strictFunctionTypes&lt;/code&gt; 가 활성화 된 경우에만 올바르게 작동합니다 . &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/32964&quot;&gt;# 32964를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="df7f583105fdd881893e583d6f13dbb72c16aa47" translate="yes" xml:space="preserve">
          <source>Note: You can also specify a catch-all string indexer on &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; as follows:</source>
          <target state="translated">참고 : &lt;code&gt;JSX.IntrinsicElements&lt;/code&gt; 에서 다음과 같이 범용 문자열 인덱서를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="86b84c8f5ebae0249a61b0e8be7e70f077917ea7" translate="yes" xml:space="preserve">
          <source>Note: You&amp;rsquo;ll need to configure your project to use the NuGet packages. Please see &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet&quot;&gt;Configuring MSBuild projects to use NuGet&lt;/a&gt; for more information.</source>
          <target state="translated">참고 : NuGet 패키지를 사용하도록 프로젝트를 구성해야합니다. 참조하십시오 &lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Configuring-MSBuild-projects-to-use-NuGet&quot;&gt;구성은 MSBuild 프로젝트 NuGet을 사용하는&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="428e262209f33a2ca2447240e01cc6cf696d81da" translate="yes" xml:space="preserve">
          <source>Note: first, we need to make sure our run-time has an ECMAScript-compliant &lt;code&gt;Promise&lt;/code&gt; available globally. That might involve grabbing &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;a polyfill&lt;/a&gt; for &lt;code&gt;Promise&lt;/code&gt;, or relying on one that you might have in the run-time that you&amp;rsquo;re targeting. We also need to make sure that TypeScript knows &lt;code&gt;Promise&lt;/code&gt; exists by setting your &lt;code&gt;lib&lt;/code&gt; flag to something like &lt;code&gt;&quot;dom&quot;, &quot;es2015&quot;&lt;/code&gt; or &lt;code&gt;&quot;dom&quot;, &quot;es2015.promise&quot;, &quot;es5&quot;&lt;/code&gt;</source>
          <target state="translated">참고 : 먼저 런타임에 ECMAScript 호환 &lt;code&gt;Promise&lt;/code&gt; 가 전 세계적으로 제공 되는지 확인해야합니다 . &lt;code&gt;Promise&lt;/code&gt; 용 &lt;a href=&quot;https://github.com/stefanpenner/es6-promise&quot;&gt;폴리 필&lt;/a&gt; 을 가져 오거나 대상으로 하는 런타임 에 있을 수 있는 폴리 필 에 의존 할 수 있습니다. 또한 &lt;code&gt;lib&lt;/code&gt; 플래그를 &lt;code&gt;&quot;dom&quot;, &quot;es2015&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;dom&quot;, &quot;es2015.promise&quot;, &quot;es5&quot;&lt;/code&gt; 와 같은 형식 으로 설정하여 TypeScript에 &lt;code&gt;Promise&lt;/code&gt; 가 있음을 알도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ccce25f4f717ae800fc16f144d50c248273d87f" translate="yes" xml:space="preserve">
          <source>Note: if the declaration file you are searching for is not present, you can always contribute one back and help out the next developer looking for it. Please see the DefinitelyTyped &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;contribution guidelines page&lt;/a&gt; for details.</source>
          <target state="translated">참고 : 검색중인 선언 파일이 없으면 언제든지 다시 기여하고 다음 개발자가 도움을 줄 수 있습니다. 자세한 내용은 DefinitelyTyped &lt;a href=&quot;http://definitelytyped.org/guides/contributing.html&quot;&gt;기여 지침 페이지&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7e6e74755e762c4957a748b815736bf13786cbb4" translate="yes" xml:space="preserve">
          <source>Notice how we dropped &lt;code&gt;theName&lt;/code&gt; altogether and just use the shortened &lt;code&gt;readonly name: string&lt;/code&gt; parameter on the constructor to create and initialize the &lt;code&gt;name&lt;/code&gt; member. We&amp;rsquo;ve consolidated the declarations and assignment into one location.</source>
          <target state="translated">우리가 떨어 방법 공지 사항 &lt;code&gt;theName&lt;/code&gt; 를 모두 그냥 단축 사용 &lt;code&gt;readonly name: string&lt;/code&gt; 생성 및 초기화하는 생성자에 매개 변수를 &lt;code&gt;name&lt;/code&gt; 멤버. 선언과 과제를 한 곳에 통합했습니다.</target>
        </trans-unit>
        <trans-unit id="6a85b01a3af32d42a46518c09152775637f852de" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;T&lt;/code&gt; has been propagated from &lt;code&gt;makeArray&lt;/code&gt; into the resulting type&amp;rsquo;s type parameter list. This means that genericity from &lt;code&gt;compose&lt;/code&gt;&amp;rsquo;s arguments has been preserved and our &lt;code&gt;makeBoxedArray&lt;/code&gt; sample will just work!</source>
          <target state="translated">것을 알 수 &lt;code&gt;T&lt;/code&gt; 가 에서 전파 된 &lt;code&gt;makeArray&lt;/code&gt; 결과 형식의 형식 매개 변수 목록에. 즉, &lt;code&gt;compose&lt;/code&gt; 인수의 &lt;code&gt;makeBoxedArray&lt;/code&gt; 이 유지되고 makeBoxedArray 샘플이 작동합니다!</target>
        </trans-unit>
        <trans-unit id="a26aafd348bc0fd9af2fe643fb8a471bed279231" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;T&lt;/code&gt; has the additional constraint &lt;code&gt;any[]&lt;/code&gt; within the true branch of &lt;code&gt;Boxed&amp;lt;T&amp;gt;&lt;/code&gt; and it is therefore possible to refer to the element type of the array as &lt;code&gt;T[number]&lt;/code&gt;. Also, notice how the conditional type is distributed over the union type in the last example.</source>
          <target state="translated">공지 것이 &lt;code&gt;T&lt;/code&gt; 는 추가적인 제약이있다 &lt;code&gt;any[]&lt;/code&gt; 의 실제 분기 내에 &lt;code&gt;Boxed&amp;lt;T&amp;gt;&lt;/code&gt; 과 같이 배열의 요소 유형을 참조하는 것이 가능하다 &lt;code&gt;T[number]&lt;/code&gt; . 또한 마지막 예에서 조건 유형이 공용체 유형에 어떻게 분산되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="10af1f3e49765726e808fd41e23133e1c2a4e7ed" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;createCardPicker&lt;/code&gt; is a function that itself returns a function. If we tried to run the example, we would get an error instead of the expected alert box. This is because the &lt;code&gt;this&lt;/code&gt; being used in the function created by &lt;code&gt;createCardPicker&lt;/code&gt; will be set to &lt;code&gt;window&lt;/code&gt; instead of our &lt;code&gt;deck&lt;/code&gt; object. That&amp;rsquo;s because we call &lt;code&gt;cardPicker()&lt;/code&gt; on its own. A top-level non-method syntax call like this will use &lt;code&gt;window&lt;/code&gt; for &lt;code&gt;this&lt;/code&gt;. (Note: under strict mode, &lt;code&gt;this&lt;/code&gt; will be &lt;code&gt;undefined&lt;/code&gt; rather than &lt;code&gt;window&lt;/code&gt;).</source>
          <target state="translated">것을 알 수 &lt;code&gt;createCardPicker&lt;/code&gt; 은 그 자체가 함수를 반환하는 함수입니다. 예제를 실행하려고하면 예상 된 경고 상자 대신 오류가 발생합니다. 때문이다 &lt;code&gt;this&lt;/code&gt; 만든 함수에서 사용되는 &lt;code&gt;createCardPicker&lt;/code&gt; 가 설정됩니다 &lt;code&gt;window&lt;/code&gt; 대신에 우리의 &lt;code&gt;deck&lt;/code&gt; 객체입니다. 자체적으로 &lt;code&gt;cardPicker()&lt;/code&gt; 를 호출하기 때문 입니다. 이와 같은 최상위 비 메소드 구문 호출은 this에 &lt;code&gt;window&lt;/code&gt; 를 사용 &lt;code&gt;this&lt;/code&gt; . (참고 : 엄격 모드에서, &lt;code&gt;this&lt;/code&gt; 됩니다 &lt;code&gt;undefined&lt;/code&gt; 보다는 &lt;code&gt;window&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="763a205d6a7b4e6716dbfe0467c7193103f61a5d" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;uglify&lt;/code&gt; itself has just one call &amp;mdash; the calls to &lt;code&gt;buffer&lt;/code&gt; and &lt;code&gt;sourcemaps&lt;/code&gt; exist to make sure sourcemaps keep working. These calls give us a separate sourcemap file instead of using inline sourcemaps like before. Now you can run Gulp and check that &lt;code&gt;bundle.js&lt;/code&gt; does get minified into an unreadable mess:</source>
          <target state="translated">공지 사항 &lt;code&gt;uglify&lt;/code&gt; 자체가 하나의 호출이 - 호출하는 &lt;code&gt;buffer&lt;/code&gt; 하고 &lt;code&gt;sourcemaps&lt;/code&gt; 는 확인 sourcemaps이 작업을 계속하기 위해 존재한다. 이러한 호출은 이전과 같이 인라인 소스 맵을 사용하는 대신 별도의 소스 맵 파일을 제공합니다. 이제 Gulp를 실행하고 &lt;code&gt;bundle.js&lt;/code&gt; 가 읽을 수없는 혼란으로 축소 되었는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9840073ae62b539ce3e1ebbfd27d812a30288a78" translate="yes" xml:space="preserve">
          <source>Notice that Node.js jumped up a directory in steps (4) and (7).</source>
          <target state="translated">Node.js는 단계 (4)와 (7)에서 디렉토리를 뛰어 넘었습니다.</target>
        </trans-unit>
        <trans-unit id="ab4bf996704c0896075b225907ab9de7984c49ba" translate="yes" xml:space="preserve">
          <source>Notice that TypeScript not only knows that &lt;code&gt;pet&lt;/code&gt; is a &lt;code&gt;Fish&lt;/code&gt; in the &lt;code&gt;if&lt;/code&gt; branch; it also knows that in the &lt;code&gt;else&lt;/code&gt; branch, you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; have a &lt;code&gt;Fish&lt;/code&gt;, so you must have a &lt;code&gt;Bird&lt;/code&gt;.</source>
          <target state="translated">타이프 라이터가 알고뿐만 아니라 통지 &lt;code&gt;pet&lt;/code&gt; A는 &lt;code&gt;Fish&lt;/code&gt; 의 &lt;code&gt;if&lt;/code&gt; 지점; 그것은 또한에서 것을 알고 &lt;code&gt;else&lt;/code&gt; 지점, 당신이 &lt;em&gt;하지 않는&lt;/em&gt; 이 &lt;code&gt;Fish&lt;/code&gt; 당신이 있어야합니다, 그래서 &lt;code&gt;Bird&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb0aa408a6fabdf5fe7f3f24ac365f674b565f27" translate="yes" xml:space="preserve">
          <source>Notice that although there were errors, the &lt;code&gt;greeter.js&lt;/code&gt; file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.</source>
          <target state="translated">오류가 있었지만 &lt;code&gt;greeter.js&lt;/code&gt; 파일이 계속 생성됩니다. 코드에 오류가 있어도 TypeScript를 사용할 수 있습니다. 그러나이 경우 TypeScript는 코드가 예상대로 실행되지 않을 것이라고 경고합니다.</target>
        </trans-unit>
        <trans-unit id="f262e26dd39e3b5a66a391868d3fb9f6d6e5738f" translate="yes" xml:space="preserve">
          <source>Notice that even though we used ES2015 module syntax, TypeScript emitted CommonJS modules that Node uses. We&amp;rsquo;ll stick with CommonJS for this tutorial, but you could set &lt;code&gt;module&lt;/code&gt; in the options object to change this.</source>
          <target state="translated">ES2015 모듈 구문을 사용했지만 TypeScript는 Node가 사용하는 CommonJS 모듈을 생성했습니다. 이 튜토리얼에서는 CommonJS를 사용하지만 옵션 객체에서 &lt;code&gt;module&lt;/code&gt; 을 설정 하여이를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6426330771f7083cfd35796802456c49f5b66b69" translate="yes" xml:space="preserve">
          <source>Notice that our example has changed to be something slightly different. Instead of describing a generic function, we now have a non-generic function signature that is a part of a generic type. When we use &lt;code&gt;GenericIdentityFn&lt;/code&gt;, we now will also need to specify the corresponding type argument (here: &lt;code&gt;number&lt;/code&gt;), effectively locking in what the underlying call signature will use. Understanding when to put the type parameter directly on the call signature and when to put it on the interface itself will be helpful in describing what aspects of a type are generic.</source>
          <target state="translated">이 예는 약간 다른 것으로 변경되었습니다. 제네릭 함수를 설명하는 대신 이제 제네릭 형식의 일부인 제네릭이 아닌 함수 서명이 있습니다. &lt;code&gt;GenericIdentityFn&lt;/code&gt; 을 사용하는 경우 이제 해당 유형 인수 (여기서는 &lt;code&gt;number&lt;/code&gt; ) 를 지정 하여 기본 호출 서명이 사용할 항목을 효과적으로 잠급니다. 유형 매개 변수를 호출 시그니처에 직접 배치 할시기와 인터페이스 자체에 배치 할시기를 이해하면 유형의 일반적인 측면을 설명하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="9bb1da98b82bb82ebbe555bd6d19c0a036a3fa15" translate="yes" xml:space="preserve">
          <source>Notice that the elements of each group maintains the same order, but the groups themselves are merged with later overload sets ordered first.</source>
          <target state="translated">각 그룹의 요소는 동일한 순서를 유지하지만 그룹 자체는 나중에 주문 된 이후의 과부하 세트와 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="765da565a7c17cfcf3312a5eda7111c42ee0f02e" translate="yes" xml:space="preserve">
          <source>Notice that we didn&amp;rsquo;t have to explicitly pass the type in the angle brackets (&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;); the compiler just looked at the value &lt;code&gt;&quot;myString&quot;&lt;/code&gt;, and set &lt;code&gt;T&lt;/code&gt; to its type. While type argument inference can be a helpful tool to keep code shorter and more readable, you may need to explicitly pass in the type arguments as we did in the previous example when the compiler fails to infer the type, as may happen in more complex examples.</source>
          <target state="translated">꺾쇠 괄호 ( &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; )로 유형을 명시 적으로 전달할 필요는 없습니다 . 컴파일러는 방금 &lt;code&gt;&quot;myString&quot;&lt;/code&gt; 값을보고 &lt;code&gt;T&lt;/code&gt; 를 해당 유형으로 설정 했습니다. 형식 인수 유추는 코드를 더 짧고 읽기 쉽게 유지하는 데 유용한 도구 일 수 있지만 컴파일러가 형식을 유추하지 못하는 경우 이전 예제에서와 같이 형식 인수를 명시 적으로 전달해야합니다. .</target>
        </trans-unit>
        <trans-unit id="e2786dc0fc7753238adaa3b182c5756666dbd537" translate="yes" xml:space="preserve">
          <source>Notice that we don&amp;rsquo;t use the &lt;code&gt;require&lt;/code&gt; keyword; instead we assign directly from the qualified name of the symbol we&amp;rsquo;re importing. This is similar to using &lt;code&gt;var&lt;/code&gt;, but also works on the type and namespace meanings of the imported symbol. Importantly, for values, &lt;code&gt;import&lt;/code&gt; is a distinct reference from the original symbol, so changes to an aliased &lt;code&gt;var&lt;/code&gt; will not be reflected in the original variable.</source>
          <target state="translated">&lt;code&gt;require&lt;/code&gt; 키워드는 사용하지 않습니다 . 대신 가져 오는 심볼의 정규화 된 이름에서 직접 할당합니다. 이것은 &lt;code&gt;var&lt;/code&gt; 사용과 유사 하지만 가져온 심볼의 유형 및 네임 스페이스 의미에서도 작동합니다. 중요하게, 값의 경우 &lt;code&gt;import&lt;/code&gt; 는 원래 기호와 별개의 참조이므로 별칭 &lt;code&gt;var&lt;/code&gt; 에 대한 변경 사항 은 원래 변수에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5474e3c4f0295fff5cf94b925d396e756aa6518e" translate="yes" xml:space="preserve">
          <source>Notice that we had to surround this statement with parentheses. JavaScript normally parses a &lt;code&gt;{&lt;/code&gt; as the start of block.</source>
          <target state="translated">이 문장을 괄호로 묶어야합니다. JavaScript는 일반적으로 &lt;code&gt;{&lt;/code&gt; 를 블록의 시작 으로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="f3a80c95c92964743c3a7674b186fd203447952a" translate="yes" xml:space="preserve">
          <source>Notice that we had to use type assertions several times. It would be much better if once we performed the check, we could know the type of &lt;code&gt;pet&lt;/code&gt; within each branch.</source>
          <target state="translated">형식 어설 션을 여러 번 사용해야했습니다. 점검을 한 후에 각 지점 에서 &lt;code&gt;pet&lt;/code&gt; 의 종류를 알 수 있다면 훨씬 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f1d22a5b64c25dc62cca8b1fc9ad531fb98be848" translate="yes" xml:space="preserve">
          <source>Notice that we installed TypeScript as a development dependency. We could also have linked TypeScript to a global copy with &lt;code&gt;npm link typescript&lt;/code&gt;, but this is a less common scenario.</source>
          <target state="translated">개발 의존성으로 TypeScript를 설치했습니다. &lt;code&gt;npm link typescript&lt;/code&gt; 를 사용하여 TypeScript를 전역 복사본에 연결할 수도 있지만 이는 덜 일반적인 시나리오입니다.</target>
        </trans-unit>
        <trans-unit id="e83cd308da6a35cefd1d54ccc96691cc920beea5" translate="yes" xml:space="preserve">
          <source>Notice that we specified &lt;code&gt;debug: true&lt;/code&gt; to Browserify. This causes tsify to emit source maps inside the bundled JavaScript file. Source maps let you debug your original TypeScript code in the browser instead of the bundled JavaScript. You can test that source maps are working by opening the debugger for your browser and putting a breakpoint inside &lt;code&gt;main.ts&lt;/code&gt;. When you refresh the page the breakpoint should pause the page and let you debug &lt;code&gt;greet.ts&lt;/code&gt;.</source>
          <target state="translated">Browserify에 &lt;code&gt;debug: true&lt;/code&gt; 를 지정 했습니다. 이로 인해 tsify는 번들 JavaScript 파일 내에서 소스 맵을 생성합니다. 소스 맵을 사용하면 번들 JavaScript 대신 브라우저에서 원본 TypeScript 코드를 디버깅 할 수 있습니다. 브라우저의 디버거를 열고 &lt;code&gt;main.ts&lt;/code&gt; 안에 중단 점을 두어 소스 맵이 작동하는지 테스트 할 수 있습니다 . 페이지를 새로 고치면 중단 점이 페이지를 일시 중지하고 &lt;code&gt;greet.ts&lt;/code&gt; 를 디버깅 할 수 있도록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="67d48d2666a5c7a992a5ba5ca0e49f58d31d4a07" translate="yes" xml:space="preserve">
          <source>Notice that we&amp;rsquo;re including files from within &lt;code&gt;node_modules&lt;/code&gt;. React and React-DOM&amp;rsquo;s npm packages include standalone &lt;code&gt;.js&lt;/code&gt; files that you can include in a web page, and we&amp;rsquo;re referencing them directly to get things moving faster. Feel free to copy these files to another directory, or alternatively, host them on a content delivery network (CDN). Facebook makes CDN-hosted versions of React available, and you can &lt;a href=&quot;http://facebook.github.io/react/downloads.html#development-vs.-production-builds&quot;&gt;read more about that here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;node_modules&lt;/code&gt; 내에 파일이 포함되어 있습니다 . React 및 React-DOM의 npm 패키지에는 웹 페이지에 포함 할 수있는 독립형 &lt;code&gt;.js&lt;/code&gt; 파일이 포함되어 있으며, 더 빠르게 이동하기 위해 직접 참조합니다. 이러한 파일을 다른 디렉토리로 복사하거나 CDN (Content Delivery Network)에서 호스팅하십시오. Facebook은 CDN 호스트 버전의 React를 제공 &lt;a href=&quot;http://facebook.github.io/react/downloads.html#development-vs.-production-builds&quot;&gt;하며 여기에서 자세한 내용을 볼 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b09f5734b53cfac68ac359e515430d1247899638" translate="yes" xml:space="preserve">
          <source>Notice that while we can&amp;rsquo;t use &lt;code&gt;name&lt;/code&gt; from outside of &lt;code&gt;Person&lt;/code&gt;, we can still use it from within an instance method of &lt;code&gt;Employee&lt;/code&gt; because &lt;code&gt;Employee&lt;/code&gt; derives from &lt;code&gt;Person&lt;/code&gt;.</source>
          <target state="translated">우리가 사용하는 수는 없지만 것을주의 &lt;code&gt;name&lt;/code&gt; 외부에서 &lt;code&gt;Person&lt;/code&gt; , 우리는 여전히의 인스턴스 메서드 내에서 사용할 수 있습니다 &lt;code&gt;Employee&lt;/code&gt; 때문에 &lt;code&gt;Employee&lt;/code&gt; 에서 유래 &lt;code&gt;Person&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="057539fc62c3a3433f309ba4576e4667a469ea4a" translate="yes" xml:space="preserve">
          <source>Notice the above needed no type annotations. The &lt;code&gt;const&lt;/code&gt; assertion allowed TypeScript to take the most specific type of the expression.</source>
          <target state="translated">위의 유형 주석은 필요하지 않습니다. &lt;code&gt;const&lt;/code&gt; 주장은 타이프는 식의 가장 구체적인 유형을 할 수 있었다.</target>
        </trans-unit>
        <trans-unit id="f321483ba4f94eea3586e9078b133451c9b94b14" translate="yes" xml:space="preserve">
          <source>Notice the given argument to &lt;code&gt;createSquare&lt;/code&gt; is spelled &lt;em&gt;&lt;code&gt;colour&lt;/code&gt;&lt;/em&gt; instead of &lt;code&gt;color&lt;/code&gt;. In plain JavaScript, this sort of thing fails silently.</source>
          <target state="translated">에 주어진 인수에 주목 &lt;code&gt;createSquare&lt;/code&gt; 가 철자 &lt;em&gt; &lt;code&gt;colour&lt;/code&gt; &lt;/em&gt; 대신 &lt;code&gt;color&lt;/code&gt; . 일반 JavaScript에서는 이런 종류의 일이 자동으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="449041a6d7a9b6fc7d3b8e6410b5c6cd0fde878b" translate="yes" xml:space="preserve">
          <source>Now &lt;code&gt;search&lt;/code&gt; is &lt;code&gt;{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }&lt;/code&gt;. Object spreading is more complex than array spreading. Like array spreading, it proceeds from left-to-right, but the result is still an object. This means that properties that come later in the spread object overwrite properties that come earlier. So if we modify the previous example to spread at the end:</source>
          <target state="translated">이제 &lt;code&gt;search&lt;/code&gt; 것입니다 &lt;code&gt;{ food: &quot;rich&quot;, price: &quot;$$&quot;, ambiance: &quot;noisy&quot; }&lt;/code&gt; . 객체 확산은 배열 확산보다 복잡합니다. 배열 확산과 같이 왼쪽에서 오른쪽으로 진행되지만 결과는 여전히 개체입니다. 이는 스프레드 객체에서 나중에 나오는 속성이 앞서 나오는 속성을 덮어 씁니다. 따라서 이전 예제를 수정하여 마지막에 확산되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="db8e5588d2d1057026cfc4a79854c4482517ae14" translate="yes" xml:space="preserve">
          <source>Now TypeScript knows that &lt;code&gt;createCardPicker&lt;/code&gt; expects to be called on a &lt;code&gt;Deck&lt;/code&gt; object. That means that &lt;code&gt;this&lt;/code&gt; is of type &lt;code&gt;Deck&lt;/code&gt; now, not &lt;code&gt;any&lt;/code&gt;, so &lt;code&gt;--noImplicitThis&lt;/code&gt; will not cause any errors.</source>
          <target state="translated">TypeScript는 &lt;code&gt;createCardPicker&lt;/code&gt; 가 &lt;code&gt;Deck&lt;/code&gt; 객체 에서 호출 될 것으로 예상 한다는 것을 알고 있습니다 . 것을 그 수단 &lt;code&gt;this&lt;/code&gt; 타입이다 &lt;code&gt;Deck&lt;/code&gt; 하지, 지금 &lt;code&gt;any&lt;/code&gt; 때문에, &lt;code&gt;--noImplicitThis&lt;/code&gt; 는 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bb4e738e148009f79ea8206746e9d01e2ac6c80" translate="yes" xml:space="preserve">
          <source>Now change &lt;code&gt;main.ts&lt;/code&gt; to update the page:</source>
          <target state="translated">이제 &lt;code&gt;main.ts&lt;/code&gt; 를 변경 하여 페이지를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="19f45556bb4ffb06e428f0775fa838cee98426d1" translate="yes" xml:space="preserve">
          <source>Now change the code in &lt;code&gt;src/main.ts&lt;/code&gt; to import &lt;code&gt;sayHello&lt;/code&gt; from &lt;code&gt;greet.ts&lt;/code&gt;:</source>
          <target state="translated">지금의 코드 변경 &lt;code&gt;src/main.ts&lt;/code&gt; 가져올 &lt;code&gt;sayHello&lt;/code&gt; 에서 &lt;code&gt;greet.ts&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc972ac7f876ddb230eb09fff1d371c82cba09d1" translate="yes" xml:space="preserve">
          <source>Now change your gulpfile to the following:</source>
          <target state="translated">이제 gulpfile을 다음과 같이 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="d5e91337836080850365ec1adb6a6e22456b494f" translate="yes" xml:space="preserve">
          <source>Now if you annotate calling code with &lt;code&gt;this&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;this&lt;/code&gt; 호출 코드에 주석을 달면 :</target>
        </trans-unit>
        <trans-unit id="ce21fbd716cb22501e3b77ae211a67a20a5b69a6" translate="yes" xml:space="preserve">
          <source>Now imports to &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; would be looked up in &lt;code&gt;./modules/moduleA&lt;/code&gt;</source>
          <target state="translated">이제 &lt;code&gt;&quot;moduleA&quot;&lt;/code&gt; 로의 가져 오기 는 &lt;code&gt;./modules/moduleA&lt;/code&gt; 에서 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="7bb24a6d01809ab25d994975acd19c2bdf7782ca" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at how return types are treated, using two functions that differ only by their return type:</source>
          <target state="translated">이제 리턴 유형 만 다른 두 가지 함수를 사용하여 리턴 유형을 처리하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="cfc81a9edf6b5df21e2f8d967d810f4429dddd90" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s move this project from Node to the browser. To do this, we&amp;rsquo;d like to bundle all our modules into one JavaScript file. Fortunately, that&amp;rsquo;s exactly what Browserify does. Even better, it lets us use the CommonJS module system used by Node, which is the default TypeScript emit. That means our TypeScript and Node setup will transfer to the browser basically unchanged.</source>
          <target state="translated">이제이 프로젝트를 노드에서 브라우저로 옮깁니다. 이를 위해 모든 모듈을 하나의 JavaScript 파일로 묶고 싶습니다. 다행히도 이것이 바로 Browserify가하는 일입니다. 또한 기본 TypeScript 이미 터 인 Node에서 사용하는 CommonJS 모듈 시스템을 사용할 수 있습니다. 즉, TypeScript 및 Node 설정은 기본적으로 변경되지 않은 브라우저로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="f2ff6a3f3742717cb814ea8ff8b733c8987d4bca" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s use the discriminated union:</source>
          <target state="translated">이제 차별적 노동 조합을 사용합시다 :</target>
        </trans-unit>
        <trans-unit id="ff37331bf4adb180113ce3c6cbbb96618f575e44" translate="yes" xml:space="preserve">
          <source>Now open up &lt;code&gt;index.html&lt;/code&gt; in your favorite browser and everything should be ready to use! You should see a page that says &amp;ldquo;Hello from TypeScript and React!&amp;rdquo;</source>
          <target state="translated">이제 선호하는 브라우저에서 &lt;code&gt;index.html&lt;/code&gt; 을 열고 모든 것을 사용할 준비가되었습니다! &amp;ldquo;Hello from TypeScript and React!&amp;rdquo;라는 페이지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="b64ae89f2b2c42dc4bb6323281704d7232b3bc08" translate="yes" xml:space="preserve">
          <source>Now right-click on &lt;code&gt;gulpfile.js&lt;/code&gt; and click Task Runner Explorer.</source>
          <target state="translated">&lt;code&gt;gulpfile.js&lt;/code&gt; 를 마우스 오른쪽 버튼으로 클릭 하고 Task Runner Explorer를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="016beaf6be9be172cdeebc211faf5982d24125cf" translate="yes" xml:space="preserve">
          <source>Now that we are bundling our code with Browserify and tsify, we can add various features to our build with browserify plugins.</source>
          <target state="translated">이제 코드를 Browserify 및 tsify와 번들로 제공하므로 browserify 플러그인을 사용하여 빌드에 다양한 기능을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3572b0fda28e71add853bf4afaed6b354c007b3b" translate="yes" xml:space="preserve">
          <source>Now that we&amp;rsquo;ve typed the function, let&amp;rsquo;s write the full type of the function out by looking at each piece of the function type.</source>
          <target state="translated">함수를 입력 했으므로 함수 유형의 각 부분을보고 함수의 전체 유형을 작성해 봅시다.</target>
        </trans-unit>
        <trans-unit id="2966203d51ca9197ed946ae5160c527e0fb03c59" translate="yes" xml:space="preserve">
          <source>Now that you have authored a declaration file following the steps of this guide, it is time to publish it to npm. There are two main ways you can publish your declaration files to npm:</source>
          <target state="translated">이 안내서의 단계에 따라 선언 파일을 작성 했으므로 이제 npm에 게시 할 차례입니다. 선언 파일을 npm에 게시 할 수있는 두 가지 주요 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c3e6c78d4bb8682924668ec470406f5a06e700d" translate="yes" xml:space="preserve">
          <source>Now that you know how to wrap the properties of a type, the next thing you&amp;rsquo;ll want to do is unwrap them. Fortunately, that&amp;rsquo;s pretty easy:</source>
          <target state="translated">타입의 속성을 래핑하는 방법을 알았으니, 다음으로해야 할 것은 래핑 해제입니다. 다행히도 매우 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="586d73d271314d06733d1c62bea37895a7824b97" translate="yes" xml:space="preserve">
          <source>Now to extend this to add support for input with numbers in bases other than 10, let&amp;rsquo;s create &lt;code&gt;ProgrammerCalculator.ts&lt;/code&gt;</source>
          <target state="translated">10이 아닌 다른 숫자로 입력을 지원하기 위해 이것을 확장하기 위해 &lt;code&gt;ProgrammerCalculator.ts&lt;/code&gt; 를 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="54df9cc661a5983b5f51492bea457bb95cb0f212" translate="yes" xml:space="preserve">
          <source>Now type the following in &lt;code&gt;greeter.html&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;greeter.html&lt;/code&gt; 에 다음을 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="0aedf42a298e6637bb4289e35235553f17c5d827" translate="yes" xml:space="preserve">
          <source>Now we can &lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt;&lt;code&gt;node.d.ts&lt;/code&gt; and then load the modules using &lt;code&gt;import url = require(&quot;url&quot;);&lt;/code&gt; or &lt;code&gt;import * as URL from &quot;url&quot;&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;/// &amp;lt;reference&amp;gt;&lt;/code&gt; &lt;code&gt;node.d.ts&lt;/code&gt; 를 수행 한 다음 &lt;code&gt;import url = require(&quot;url&quot;);&lt;/code&gt; 또는 &lt;code&gt;import * as URL from &quot;url&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2993564eab76d9b635f5473fb0c79d7180499112" translate="yes" xml:space="preserve">
          <source>Now we can start taking advantage of some of the new tools TypeScript offers. Add a &lt;code&gt;: string&lt;/code&gt; type annotation to the &amp;lsquo;person&amp;rsquo; function argument as shown here:</source>
          <target state="translated">이제 TypeScript가 제공하는 몇 가지 새로운 도구를 활용할 수 있습니다. 다음 과 같이 'person'함수 인수에 &lt;code&gt;: string&lt;/code&gt; 유형 주석을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="a9ba4be9a993e3629ea4a24cf3ff116ae3e0a325" translate="yes" xml:space="preserve">
          <source>Now we can use &lt;code&gt;npm install&lt;/code&gt; to install packages. First install &lt;code&gt;gulp-cli&lt;/code&gt; globally (if you use a Unix system, you may need to prefix the &lt;code&gt;npm install&lt;/code&gt; commands in this guide with &lt;code&gt;sudo&lt;/code&gt;).</source>
          <target state="translated">이제 &lt;code&gt;npm install&lt;/code&gt; 을 사용하여 패키지를 설치할 수 있습니다 . 먼저 &lt;code&gt;gulp-cli&lt;/code&gt; 를 전체적으로 설치하십시오 (Unix 시스템을 사용하는 경우이 안내서에서 &lt;code&gt;npm install&lt;/code&gt; 명령 앞에 &lt;code&gt;sudo&lt;/code&gt; 를 추가 해야 할 수도 있습니다 ).</target>
        </trans-unit>
        <trans-unit id="a7d081445a246b0f99f5a3375693fd0bead88a94" translate="yes" xml:space="preserve">
          <source>Now we&amp;rsquo;ll turn this folder into an npm package.</source>
          <target state="translated">이제이 폴더를 npm 패키지로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="798f21b6ccc1b472b81074260cf839e73de6d419" translate="yes" xml:space="preserve">
          <source>Now when these &lt;code&gt;never&lt;/code&gt;-returning functions are called, TypeScript recognizes that they affect the control flow graph and accounts for them.</source>
          <target state="translated">이제 이러한 &lt;code&gt;never&lt;/code&gt; 반환 기능이 호출되면 TypeScript는 해당 기능이 제어 흐름 그래프에 영향을 미치고이를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4fec837a26b514bcf683dcfc0bc3cc7b47c80376" translate="yes" xml:space="preserve">
          <source>Now when you run Gulp, it should start and stay running. Try changing the code for &lt;code&gt;showHello&lt;/code&gt; in &lt;code&gt;main.ts&lt;/code&gt; and saving it. You should see output that looks like this:</source>
          <target state="translated">이제 Gulp를 실행하면 시작되어 계속 실행됩니다. &lt;code&gt;showHello&lt;/code&gt; 에서 &lt;code&gt;main.ts&lt;/code&gt; 의 코드를 변경 하고 저장해보십시오. 다음과 같은 출력이 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5ab194637a92c49cdda73412d946249336784333" translate="yes" xml:space="preserve">
          <source>Now you can import things that match &lt;code&gt;&quot;*!text&quot;&lt;/code&gt; or &lt;code&gt;&quot;json!*&quot;&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;&quot;*!text&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;json!*&quot;&lt;/code&gt; 와 일치하는 항목을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="32b6a0eecd0bd91b730d6782f43f8351f9e8957b" translate="yes" xml:space="preserve">
          <source>NuGet</source>
          <target state="translated">NuGet</target>
        </trans-unit>
        <trans-unit id="3fd953c33b944413003ce7910b6fafa75556a775" translate="yes" xml:space="preserve">
          <source>Null and Undefined</source>
          <target state="translated">널 및 정의되지 않음</target>
        </trans-unit>
        <trans-unit id="0ba35c721cc86f9e03aa8786b08aba75ab337b54" translate="yes" xml:space="preserve">
          <source>Null- and undefined-aware types</source>
          <target state="translated">널 및 정의되지 않은 인식 유형</target>
        </trans-unit>
        <trans-unit id="4235ec51572e6a2ff85027b7b1a8ce199c7cf8fd" translate="yes" xml:space="preserve">
          <source>Nullable types</source>
          <target state="translated">널 입력 가능 유형</target>
        </trans-unit>
        <trans-unit id="a75b78680034aa8db560e36a8c2208c5c33aa012" translate="yes" xml:space="preserve">
          <source>Nullable types only have meaning if &lt;code&gt;strictNullChecks&lt;/code&gt; is on:</source>
          <target state="translated">Nullable 유형 은 &lt;code&gt;strictNullChecks&lt;/code&gt; 가 설정된 경우에만 의미 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="961f4d441aaa81cdea02877b88e051c0d6fe0b64" translate="yes" xml:space="preserve">
          <source>Nullish Coalescing</source>
          <target state="translated">널리 한 병합</target>
        </trans-unit>
        <trans-unit id="b7baa1d40c4ea29afc9098732bffee2a861a6c44" translate="yes" xml:space="preserve">
          <source>Number</source>
          <target state="translated">Number</target>
        </trans-unit>
        <trans-unit id="c3e5f2be0a6baf4d94beda8d9cf3d891411658e7" translate="yes" xml:space="preserve">
          <source>Number-like properties of an object type are those declared using a numeric literal or computed property name of a numeric literal type.</source>
          <target state="translated">객체 유형의 숫자와 유사한 속성은 숫자 리터럴 또는 숫자 리터럴 유형의 계산 된 속성 이름을 사용하여 선언 된 속성입니다.</target>
        </trans-unit>
        <trans-unit id="6be519964a1d39fca2eb603fe581121e0fee9182" translate="yes" xml:space="preserve">
          <source>Numeric Literal Types</source>
          <target state="translated">숫자 리터럴 유형</target>
        </trans-unit>
        <trans-unit id="87f1897cf6e443b573ef4632ce2ba3620162bbc7" translate="yes" xml:space="preserve">
          <source>Numeric enums</source>
          <target state="translated">숫자 열거 형</target>
        </trans-unit>
        <trans-unit id="9587a80bbfa80632e8af306b43edbc1e13077c08" translate="yes" xml:space="preserve">
          <source>Numeric enums can be mixed in &lt;a href=&quot;#computed-and-constant-members&quot;&gt;computed and constant members (see below)&lt;/a&gt;. The short story is, enums without initializers either need to be first, or have to come after numeric enums initialized with numeric constants or other constant enum members. In other words, the following isn&amp;rsquo;t allowed:</source>
          <target state="translated">숫자 열거 형은 &lt;a href=&quot;#computed-and-constant-members&quot;&gt;계산 멤버와 상수 멤버&lt;/a&gt; 로 혼합 될 수 있습니다 (아래 참조) . 간단한 이야기는, 이니셜 라이저가없는 열거 형이 먼저 필요하거나 숫자 상수 또는 다른 상수 열거 형 멤버로 초기화 된 숫자 열거 형 뒤에 와야한다는 것입니다. 즉, 다음은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="830f0ed9d3be32844d496bfeb9d33c2f9dea7d6a" translate="yes" xml:space="preserve">
          <source>Numeric separators</source>
          <target state="translated">숫자 분리기</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="7a98263bb62cd83a74dc00c8238d597167506261" translate="yes" xml:space="preserve">
          <source>Object Spread and Rest</source>
          <target state="translated">물체 퍼짐 및 휴식</target>
        </trans-unit>
        <trans-unit id="a7dc9622d9872b2041ea4b92f628450cd8b88097" translate="yes" xml:space="preserve">
          <source>Object destructuring</source>
          <target state="translated">객체 파괴</target>
        </trans-unit>
        <trans-unit id="7cd3db8976f376a1f019b5d0fed0df37b11861ba" translate="yes" xml:space="preserve">
          <source>Object literals are open-ended</source>
          <target state="translated">객체 리터럴은 개방형입니다.</target>
        </trans-unit>
        <trans-unit id="b3c62e15831841090f5476450b68b035ffba0566" translate="yes" xml:space="preserve">
          <source>Object literals behave as if they have an index signature &lt;code&gt;[x:string]: any&lt;/code&gt; that allows them to be treated as open maps instead of closed objects.</source>
          <target state="translated">객체 리터럴은 인덱스 서명 &lt;code&gt;[x:string]: any&lt;/code&gt; 이있는 것처럼 동작 합니다.이 객체는 닫힌 객체 대신 열린 맵으로 취급 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74365de67eba166395b7f2ad380a09c31367e923" translate="yes" xml:space="preserve">
          <source>Object rests are the dual of object spreads, in that they can extract any extra properties that don&amp;rsquo;t get picked up when destructuring an element:</source>
          <target state="translated">오브젝트 레스트는 요소를 파괴 할 때 선택되지 않은 추가 속성을 추출 할 수 있다는 점에서 오브젝트 스프레드의 이중입니다.</target>
        </trans-unit>
        <trans-unit id="5eeac8ca658c85a10aefd3ffe0bf35ef9f80485c" translate="yes" xml:space="preserve">
          <source>Object spread also has a couple of other surprising limits. First, it only includes an objects&amp;rsquo; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;own, enumerable properties&lt;/a&gt;. Basically, that means you lose methods when you spread instances of an object:</source>
          <target state="translated">개체 확산에는 몇 가지 놀라운 한계가 있습니다. 먼저, 객체 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Enumerability_and_ownership_of_properties&quot;&gt;자체의 열거 가능한 속성&lt;/a&gt; 만 포함합니다 . 기본적으로 객체의 인스턴스를 펼치면 메소드가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="132f0e2906b1a9d29d3142065e0490a0c7b00912" translate="yes" xml:space="preserve">
          <source>Objects with Properties</source>
          <target state="translated">속성이있는 객체</target>
        </trans-unit>
        <trans-unit id="896953fcb00b0eb5b0ba4da3b193100a1b6c1094" translate="yes" xml:space="preserve">
          <source>Of course, any of these types can be declared using Typescript syntax in a single-line &lt;code&gt;@typedef&lt;/code&gt;:</source>
          <target state="translated">물론 이러한 유형은 단일 줄 &lt;code&gt;@typedef&lt;/code&gt; 에서 Typescript 구문을 사용하여 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a729d408f1e41978ee6a94cb932a7977199d3c0" translate="yes" xml:space="preserve">
          <source>Of course, since this is JavaScript, you can just ignore trailing elements you don&amp;rsquo;t care about:</source>
          <target state="translated">물론 이것은 JavaScript이기 때문에 신경 쓰지 않는 후행 요소를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9ca67ed45e73556a1cbb12d34b79f3e95210af4" translate="yes" xml:space="preserve">
          <source>Of course, that might not feel right. If you open that file in an editor with TypeScript support (or if you run &lt;code&gt;tsc --pretty&lt;/code&gt;), you might see red squiggles on certain lines. You should think of these the same way you&amp;rsquo;d think of red squiggles in an editor like Microsoft Word. TypeScript will still translate your code, just like Word will still let you print your documents.</source>
          <target state="translated">물론, 그것은 기분이 좋지 않을 수 있습니다. TypeScript를 지원하는 편집기에서 해당 파일을 열거 나 (또는 &lt;code&gt;tsc --pretty&lt;/code&gt; 를 실행하는 경우 ) 특정 행에 빨간색 표시가 나타날 수 있습니다. Microsoft Word와 같은 편집기에서 빨간색 구불 구불 한 생각과 동일한 방식으로 생각해야합니다. Word에서 문서를 인쇄 할 수있는 것처럼 TypeScript는 여전히 코드를 번역합니다.</target>
        </trans-unit>
        <trans-unit id="33b53cf1b820a2734ec0c25dc3f2c29570965d4b" translate="yes" xml:space="preserve">
          <source>Of note, only the parameters and the return type make up the function type. Captured variables are not reflected in the type. In effect, captured variables are part of the &amp;ldquo;hidden state&amp;rdquo; of any function and do not make up its API.</source>
          <target state="translated">매개 변수와 리턴 유형 만 기능 유형을 구성합니다. 캡처 된 변수는 유형에 반영되지 않습니다. 실제로 캡처 된 변수는 함수의 &quot;숨겨진 상태&quot;의 일부이며 API를 구성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d23057a19f87b1d7a3f861f468248c8e5a5974a" translate="yes" xml:space="preserve">
          <source>Official TypeScript NuGet package</source>
          <target state="translated">공식 TypeScript NuGet 패키지</target>
        </trans-unit>
        <trans-unit id="a342b6bea0bb720b9577de62cca20c2743aa540e" translate="yes" xml:space="preserve">
          <source>Often a project has multiple output targets, e.g. &lt;code&gt;ES5&lt;/code&gt; and &lt;code&gt;ES2015&lt;/code&gt;, debug and production or &lt;code&gt;CommonJS&lt;/code&gt; and &lt;code&gt;System&lt;/code&gt;; Just a few configuration options change between these two targets, and maintaining multiple &lt;code&gt;tsconfig.json&lt;/code&gt; files can be a hassle.</source>
          <target state="translated">종종 프로젝트에는 여러 개의 출력 대상 (예 : &lt;code&gt;ES5&lt;/code&gt; 및 &lt;code&gt;ES2015&lt;/code&gt; , 디버그 및 프로덕션 또는 &lt;code&gt;CommonJS&lt;/code&gt; 및 &lt;code&gt;System&lt;/code&gt; . 이 두 대상간에 몇 가지 구성 옵션 만 변경하면 여러 &lt;code&gt;tsconfig.json&lt;/code&gt; 파일을 유지 관리하는 것이 번거로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d6fe7c72174392511bd9351eaea580b26d61ce5" translate="yes" xml:space="preserve">
          <source>Often in Node.js applications a &lt;code&gt;.json&lt;/code&gt; is needed. With TypeScript 2.9, &lt;code&gt;--resolveJsonModule&lt;/code&gt; allows for importing, extracting types from and generating &lt;code&gt;.json&lt;/code&gt; files.</source>
          <target state="translated">종종 Node.js 애플리케이션에서 &lt;code&gt;.json&lt;/code&gt; 이 필요합니다. TypeScript 2.9에서 &lt;code&gt;--resolveJsonModule&lt;/code&gt; 을 사용하면 &lt;code&gt;.json&lt;/code&gt; 파일 에서 가져 오기, 유형 추출 및 생성이 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="c504b6f49a2c17cd30c9562020e80d82bcb972da" translate="yes" xml:space="preserve">
          <source>Often modules extend other modules, and partially expose some of their features. A re-export does not import it locally, or introduce a local variable.</source>
          <target state="translated">종종 모듈은 다른 모듈을 확장하고 일부 기능을 부분적으로 노출합니다. 다시 내보내기는 로컬로 가져 오거나 로컬 변수를 도입하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7ca1979392492f5b243f43458b409b3671c295fb" translate="yes" xml:space="preserve">
          <source>Often there are external source files in your project that may not be authored in TypeScript. Alternatively, you might be in the middle of converting a JS code base into TS, but still want to bundle all your JS code into a single file with the output of your new TS code.</source>
          <target state="translated">종종 프로젝트에 TypeScript로 제작되지 않은 외부 소스 파일이 있습니다. 또는 JS 코드베이스를 TS로 변환하는 중이지만 새 TS 코드의 출력을 사용하여 모든 JS 코드를 단일 파일로 번들링하려는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dd8eb55cce46da17a5fd56794f37ca6d1bdbaaf" translate="yes" xml:space="preserve">
          <source>Often you will need to extend functionality on a module. A common JS pattern is to augment the original object with &lt;em&gt;extensions&lt;/em&gt;, similar to how JQuery extensions work. As we&amp;rsquo;ve mentioned before, modules do not &lt;em&gt;merge&lt;/em&gt; like global namespace objects would. The recommended solution is to &lt;em&gt;not&lt;/em&gt; mutate the original object, but rather export a new entity that provides the new functionality.</source>
          <target state="translated">종종 모듈의 기능을 확장해야합니다. 일반적인 JS 패턴은 JQuery 확장이 작동하는 방식과 유사하게 원래 객체를 &lt;em&gt;확장&lt;/em&gt; 기능으로 확장하는 것입니다. 앞에서 언급했듯이 모듈은 전역 네임 스페이스 객체처럼 &lt;em&gt;병합&lt;/em&gt; 되지 않습니다 . 권장되는 솔루션은 원래 객체를 변경 &lt;em&gt;하지&lt;/em&gt; 않고 새로운 기능을 제공하는 새 엔티티를 내보내는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3cd64adc89519f486491a6325593966cd9fc3e61" translate="yes" xml:space="preserve">
          <source>Omit&amp;lt;T,K&amp;gt;</source>
          <target state="translated">Omit&amp;lt;T,K&amp;gt;</target>
        </trans-unit>
        <trans-unit id="92df791023a2af27d1199c4ac1986b7a67686b3d" translate="yes" xml:space="preserve">
          <source>OmitThisParameter</source>
          <target state="translated">OmitThisParameter</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
