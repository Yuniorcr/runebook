<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="knockout">
    <body>
      <group id="knockout">
        <trans-unit id="8f6eeb12ba06f0cf2cb646fe6069b9cdfdf92aea" translate="yes" xml:space="preserve">
          <source>The foreach binding duplicates a section of markup for each entry in an array, and binds each copy of that markup to the corresponding array item. This is especially useful for rendering lists or tables.</source>
          <target state="translated">foreach 바인딩은 배열의 각 항목에 대한 마크 업 섹션을 복제하고 해당 마크 업의 각 사본을 해당 배열 항목에 바인딩합니다. 이것은 목록이나 테이블을 렌더링 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9050b1bc9f4409b41e99062ebff1d7799e7e99bd" translate="yes" xml:space="preserve">
          <source>The function you want to bind to the element&amp;rsquo;s click event.</source>
          <target state="translated">요소의 클릭 이벤트에 바인딩하려는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="a9c17e8675f71dfc3ebda72d93dbff1f7d1f9956" translate="yes" xml:space="preserve">
          <source>The function you want to bind to the element&amp;rsquo;s submit event.</source>
          <target state="translated">요소의 제출 이벤트에 바인딩하려는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="8f7a07f601445346a49b60b0d4248c64175eae01" translate="yes" xml:space="preserve">
          <source>The hasFocus binding links a DOM element&amp;rsquo;s focus state with a viewmodel property. It is a two-way binding, so:</source>
          <target state="translated">hasFocus 바인딩은 DOM 요소의 포커스 상태를 viewmodel 속성과 연결합니다. 양방향 바인딩이므로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="05ab416911dfc8b9849c830b007486b93d0e2ffb" translate="yes" xml:space="preserve">
          <source>The html binding causes the associated DOM element to display the HTML specified by your parameter.</source>
          <target state="translated">html 바인딩은 연관된 DOM 요소가 매개 변수로 지정된 HTML을 표시하게합니다.</target>
        </trans-unit>
        <trans-unit id="2d7f5cb6c1b083bcb208b0a402a5e11e8bc45313" translate="yes" xml:space="preserve">
          <source>The if binding causes a section of markup to appear in your document (and to have its data-bind attributes applied), only if a specified expression evaluates to true (or a true-ish value such as a non-null object or nonempty string).</source>
          <target state="translated">if 바인딩을 사용하면 지정된 표현식이 true 또는 널이 아닌 오브젝트 또는 비어 있지 않은 문자열과 같은 참 값으로 평가되는 경우에만 마크 업 섹션이 문서에 나타나고 해당 데이터 바인드 속성이 적용됩니다. ).</target>
        </trans-unit>
        <trans-unit id="d6048125b8510f2371496031c443eb75903bc261" translate="yes" xml:space="preserve">
          <source>The ifnot binding is exactly the same as &lt;a href=&quot;if-binding&quot;&gt;the if binding&lt;/a&gt;, except that it inverts the result of whatever expression you pass to it. For more details, see documentation for &lt;a href=&quot;if-binding&quot;&gt;the if binding&lt;/a&gt;.</source>
          <target state="translated">ifnot 바인딩은 전달한 표현식의 결과를 반전 시킨다는 점을 제외 &lt;a href=&quot;if-binding&quot;&gt;하면 if binding&lt;/a&gt; 과 정확히 동일 합니다. 자세한 내용 &lt;a href=&quot;if-binding&quot;&gt;은 if 바인딩에&lt;/a&gt; 대한 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7044aff700ff62379c0951bf28dff3be7f0d55a6" translate="yes" xml:space="preserve">
          <source>The ignore array you specify in the mapping options is combined with the default ignore array. You can manipulate this default array like this:</source>
          <target state="translated">매핑 옵션에서 지정한 무시 배열은 기본 무시 배열과 결합됩니다. 이 기본 배열을 다음과 같이 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5eeaae6307cf68ec3980cc78a92bb6a6591a6d9f" translate="yes" xml:space="preserve">
          <source>The include array you specify in the mapping options is combined with the default include array, which by default only contains _destroy. You can manipulate this default array like this:</source>
          <target state="translated">맵핑 옵션에서 지정하는 포함 배열은 기본 포함 배열과 결합되며 기본적으로 _destroy 만 포함합니다. 이 기본 배열을 다음과 같이 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b87740eb29c4e7b2de0e2d39f19f6cdb894afeb0" translate="yes" xml:space="preserve">
          <source>The index of the added array element</source>
          <target state="translated">추가 된 배열 요소의 색인</target>
        </trans-unit>
        <trans-unit id="153c8a10482991a921027e17eb883d2bb702edb1" translate="yes" xml:space="preserve">
          <source>The index of the moved array element</source>
          <target state="translated">이동 된 배열 요소의 색인</target>
        </trans-unit>
        <trans-unit id="29a08ceacbce3d40e8f8be71109fda7e68478a29" translate="yes" xml:space="preserve">
          <source>The index of the removed array element</source>
          <target state="translated">제거 된 배열 요소의 색인</target>
        </trans-unit>
        <trans-unit id="fb09d7316d9032eb6b50bdd38607e85a620a8ae9" translate="yes" xml:space="preserve">
          <source>The indexOf function returns the index of the first array item that equals your parameter. For example, myObservableArray.indexOf('Blah') will return the zero-based index of the first array entry that equals Blah, or the value -1 if no matching value was found.</source>
          <target state="translated">indexOf 함수는 매개 변수와 동일한 첫 번째 배열 항목의 색인을 리턴합니다. 예를 들어, myObservableArray.indexOf ( 'Blah')는 Blah와 동일한 첫 번째 배열 항목의 인덱스 (0부터 시작) 또는 일치하는 값이 없으면 값 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69e9515a5f943cb16af4deed10ea470bb0ce01de" translate="yes" xml:space="preserve">
          <source>The inserted option element</source>
          <target state="translated">삽입 된 옵션 요소</target>
        </trans-unit>
        <trans-unit id="43d7b19d929050c04ef482f3719e22f56037aa52" translate="yes" xml:space="preserve">
          <source>The ko.ignoreDependencies function is available for scenarios where you want to execute code within a computed that should not contribute to that computed&amp;rsquo;s dependencies. This is often useful in a custom binding when you want to call code that may access observables, but you do not want to re-trigger the binding based on changes to those observables.</source>
          <target state="translated">ko.ignoreDependencies 함수는 계산 된 종속성에 영향을 미치지 않아야하는 계산 된 코드를 실행하려는 시나리오에 사용할 수 있습니다. 이 기능은 옵저버 블에 액세스 할 수있는 코드를 호출하려고 할 때 사용자 지정 바인딩에 유용하지만 해당 옵저버 블의 변경 사항에 따라 바인딩을 다시 트리거하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e70afc86097fdbd770f7db83c02acc1eb5189b8" translate="yes" xml:space="preserve">
          <source>The mapped observable array also exposes a mappedCreate function:</source>
          <target state="translated">맵핑 된 관찰 가능 배열은 또한 맵핑 된 작성 함수를 노출합니다.</target>
        </trans-unit>
        <trans-unit id="81bf44e52d770989f5c1e8f38818ebe340c1c206" translate="yes" xml:space="preserve">
          <source>The method option controls when notifications fire, and accepts the following values:</source>
          <target state="translated">method 옵션은 알림 발생시기를 제어하고 다음 값을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="746cbdd45a1a4b3b4493f7c5d3603dfd8515ae49" translate="yes" xml:space="preserve">
          <source>The moved array element</source>
          <target state="translated">이동 된 배열 요소</target>
        </trans-unit>
        <trans-unit id="a4d37fddd3510152eb42158703c05ddb3d9aef39" translate="yes" xml:space="preserve">
          <source>The object that you want to use as the context for binding descendant elements.</source>
          <target state="translated">하위 요소 바인딩을위한 컨텍스트로 사용하려는 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="cf7c2b7cc23dbce0f5f5998ff2b85f43ee703917" translate="yes" xml:space="preserve">
          <source>The observe array you specify in the mapping options is combined with the default observe array, which by default is empty. You can manipulate this default array like this:</source>
          <target state="translated">매핑 옵션에서 지정하는 관찰 배열은 기본 관찰 배열과 결합되며 기본적으로 비어 있습니다. 이 기본 배열을 다음과 같이 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40607abcaf26d4c21ed2b1d2dda932e347adb699" translate="yes" xml:space="preserve">
          <source>The only reason to use ifnot instead of a negated if is just as a matter of taste: many developers feel that it looks tidier.</source>
          <target state="translated">부정 된 if 대신 ifnot을 사용하는 유일한 이유는 맛의 문제 일뿐입니다. 많은 개발자들은 그것이 더 깔끔해 보인다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="6dd503e19f27964041b8e7f04ad17561a372b88b" translate="yes" xml:space="preserve">
          <source>The options argument supplied to your create callback is a JavaScript object containing:</source>
          <target state="translated">create 콜백에 제공된 options 인수는 다음을 포함하는 JavaScript 객체입니다.</target>
        </trans-unit>
        <trans-unit id="acc3ee61c9b4ee99cc1a57fa897a3b346a227831" translate="yes" xml:space="preserve">
          <source>The options argument supplied to your update callback is a JavaScript object containing:</source>
          <target state="translated">업데이트 콜백에 제공된 옵션 인수는 다음을 포함하는 JavaScript 객체입니다.</target>
        </trans-unit>
        <trans-unit id="3f54901ff390f831f573f9eb13f6386cf4f2454e" translate="yes" xml:space="preserve">
          <source>The options binding controls what options should appear in a drop-down list (i.e., a &amp;lt;select&amp;gt; element) or multi-select list (e.g., &amp;lt;select size='6'&amp;gt;). This binding cannot be used with anything other than &amp;lt;select&amp;gt; elements.</source>
          <target state="translated">옵션 바인딩은 드롭 다운 목록 (예 : &amp;lt;select&amp;gt; 요소) 또는 다중 선택 목록 (예 : &amp;lt;select size = '6'&amp;gt;)에 표시 할 옵션을 제어합니다. 이 바인딩은 &amp;lt;select&amp;gt; 요소 이외의 다른 요소와 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="162c8d94929e2437460193ade4632f67b6acd841" translate="yes" xml:space="preserve">
          <source>The other neat trick is that declarative bindings are simply implemented as computed observables. So, if a binding reads the value of an observable, that binding becomes dependent on that observable, which causes that binding to be re-evaluated if the observable changes.</source>
          <target state="translated">또 다른 깔끔한 요령은 선언적 바인딩이 단순히 계산 된 관찰 가능 항목으로 구현된다는 것입니다. 따라서 바인딩이 관찰 가능 값을 읽는 경우 해당 바인딩은 관찰 가능 값에 종속되므로 관찰 가능 변경 사항이있는 경우 해당 바인딩을 다시 평가하게됩니다.</target>
        </trans-unit>
        <trans-unit id="d9c6da254c285296a2484119e3b32c7ea72d4244" translate="yes" xml:space="preserve">
          <source>The preceding view model code demonstrates the &lt;em&gt;single parameter syntax&lt;/em&gt; for initializing computed observables. See the &lt;a href=&quot;computed-reference&quot;&gt;computed observable reference&lt;/a&gt; for the full list of available options.</source>
          <target state="translated">앞의 뷰 모델 코드는 계산 된 관측 가능 개체를 초기화하기위한 &lt;em&gt;단일 매개 변수 구문&lt;/em&gt; 을 보여줍니다 . 사용 &lt;a href=&quot;computed-reference&quot;&gt;가능한&lt;/a&gt; 전체 옵션 목록은 계산 가능한 관찰 가능 참조 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1eba8a376d4e1fe3d6273f564007f1679bed7333" translate="yes" xml:space="preserve">
          <source>The problem is that this will cause &lt;em&gt;two&lt;/em&gt; Ajax requests: the first one will start when you update pageSize, and the second one will start immediately afterwards when you update pageIndex. This is a waste of bandwidth and server resources, and a source of unpredictable race conditions.</source>
          <target state="translated">문제는 &lt;em&gt;두 개의&lt;/em&gt; Ajax 요청 이 발생한다는 것입니다 . 첫 번째 요청은 pageSize를 업데이트 할 때 시작되고 &lt;em&gt;두&lt;/em&gt; 번째 요청은 pageIndex를 업데이트 할 때 즉시 시작됩니다. 이는 대역폭 및 서버 리소스 낭비이며 예측할 수없는 경쟁 조건의 원인입니다.</target>
        </trans-unit>
        <trans-unit id="37cce1f32edc965597a382d568819abb832a7fd0" translate="yes" xml:space="preserve">
          <source>The quickest and most fun way to get started is by working through the &lt;a href=&quot;http://learn.knockoutjs.com&quot;&gt;interactive tutorials&lt;/a&gt;. Once you&amp;rsquo;ve got to grips with the basics, explore the &lt;a href=&quot;http://knockoutjs.com/examples/index.html&quot;&gt;live examples&lt;/a&gt; and then have a go with it in your own project.</source>
          <target state="translated">시작하는 가장 빠르고 재미있는 방법은 &lt;a href=&quot;http://learn.knockoutjs.com&quot;&gt;대화식 자습서를&lt;/a&gt; 통해 작업하는 것 입니다. 기본 사항에 익숙해지면 &lt;a href=&quot;http://knockoutjs.com/examples/index.html&quot;&gt;라이브 예제를&lt;/a&gt; 탐색하고 자신의 프로젝트에서 예제를 살펴 보십시오.</target>
        </trans-unit>
        <trans-unit id="ea006c24537a65a2ba624708630c7fc651c4642e" translate="yes" xml:space="preserve">
          <source>The rateLimit extender can be applied to any type of observable, including &lt;a href=&quot;observablearrays&quot;&gt;observable arrays&lt;/a&gt; and &lt;a href=&quot;computedobservables&quot;&gt;computed observables&lt;/a&gt;. The main use cases for rate-limiting are:</source>
          <target state="translated">rateLimit 익스텐더는 &lt;a href=&quot;observablearrays&quot;&gt;관찰 가능 배열&lt;/a&gt; 및 &lt;a href=&quot;computedobservables&quot;&gt;계산 된 관찰 가능 항목을&lt;/a&gt; 포함하여 모든 유형의 관찰 가능 항목에 적용 할 수 있습니다 . 요율 제한의 주요 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7fb3e0a025185b71bc07f0984aae74db606ff1f" translate="yes" xml:space="preserve">
          <source>The reason you shouldn&amp;rsquo;t use a &lt;em&gt;pure&lt;/em&gt; computed if the evaluator has important side effects is simply that the evaluator will not run whenever the computed has no active subscribers (and so is sleeping). If it&amp;rsquo;s important for the evaluator to always run when dependencies change, use a &lt;a href=&quot;computedobservables&quot;&gt;regular computed&lt;/a&gt; instead.</source>
          <target state="translated">평가자가 중요한 부작용이있는 경우 &lt;em&gt;순수한&lt;/em&gt; 계산을 사용하지 않아야하는 이유 는 계산 된 활성 가입자가 없을 때 (그리고 잠자기 상태 일 때마다) 평가자가 실행되지 않기 때문입니다. 종속성이 변경 될 때 평가자가 항상 실행되어야하는 경우 대신 &lt;a href=&quot;computedobservables&quot;&gt;정규 계산을&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="43b68b7f8a261dc6fd71424b790107e7bba36eec" translate="yes" xml:space="preserve">
          <source>The removed array element</source>
          <target state="translated">제거 된 배열 요소</target>
        </trans-unit>
        <trans-unit id="2b8edfced12b2275ac8a80e2f1255222d87df6ce" translate="yes" xml:space="preserve">
          <source>The rest of this page describes observableArray&amp;rsquo;s functions for reading and writing array information.</source>
          <target state="translated">이 페이지의 나머지 부분에서는 배열 정보를 읽고 쓰는 observableArray의 기능에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4e00afb986323ba904efea3a982c45371e5a241e" translate="yes" xml:space="preserve">
          <source>The result will be:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c8738ad7d358e2c69d84d24c2be85c7b85214872" translate="yes" xml:space="preserve">
          <source>The returned AMD module object can be in any of the forms allowed for viewmodels. So, it can be a constructor function, e.g.:</source>
          <target state="translated">반환 된 AMD 모듈 객체는 뷰 모델에 허용되는 모든 형식 일 수 있습니다. 따라서 생성자 함수가 될 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="f55dc67e0ec57a14fa41387c5f86cbfbf87a4bdb" translate="yes" xml:space="preserve">
          <source>The returned AMD module object can be in any of the forms allowed for viewmodels. So, it can be a string of markup, e.g. fetched using &lt;a href=&quot;http://requirejs.org/docs/api.html#text&quot;&gt;require.js&amp;rsquo;s text plugin&lt;/a&gt;:</source>
          <target state="translated">반환 된 AMD 모듈 객체는 뷰 모델에 허용되는 모든 형식 일 수 있습니다. 따라서 마크 업 문자열 일 수 있습니다 (예 : &lt;a href=&quot;http://requirejs.org/docs/api.html#text&quot;&gt;require.js의 텍스트 플러그인을&lt;/a&gt; 사용하여 가져옴) .</target>
        </trans-unit>
        <trans-unit id="97f1dd160bf2d7329f218a8a066037037fd32f5a" translate="yes" xml:space="preserve">
          <source>The second parameter to ko.computed (the bit where we passed this in the above example) defines the value of this when evaluating the computed observable. Without passing it in, it would not have been possible to refer to this.firstName() or this.lastName(). Experienced JavaScript coders will regard this as obvious, but if you&amp;rsquo;re still getting to know JavaScript it might seem strange. (Languages like C# and Java never expect the programmer to set a value for this, but JavaScript does, because its functions themselves aren&amp;rsquo;t part of any object by default.)</source>
          <target state="translated">ko.computed의 두 번째 매개 변수 (위 예제에서이 비트를 전달한 비트)는 계산 된 관찰 가능 항목을 평가할 때이 값을 정의합니다. 전달하지 않으면 this.firstName () 또는 this.lastName ()을 참조 할 수 없었습니다. 숙련 된 JavaScript 코더는이를 명백한 것으로 간주하지만 여전히 JavaScript를 알고 있다면 이상하게 보일 수 있습니다. (C # 및 Java와 같은 언어는 프로그래머가 이에 대한 값을 설정할 것으로 예상하지 않지만 JavaScript 자체는 기본적으로 함수 자체가 객체의 일부가 아니기 때문에 JavaScript는 값을 설정하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="276174d892c3bad296aa46c527585e258f34f083" translate="yes" xml:space="preserve">
          <source>The selectedOptions binding controls which elements in a multi-select list are currently selected. This is intended to be used in conjunction with a &amp;lt;select&amp;gt; element and the options binding.</source>
          <target state="translated">selectedOptions 바인딩은 다중 선택 목록에서 현재 선택된 요소를 제어합니다. 이것은 &amp;lt;select&amp;gt; 요소 및 옵션 바인딩과 함께 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8e064f117111b091febd6324a44a5d55fdf3a4a8" translate="yes" xml:space="preserve">
          <source>The server might return JSON data similar to the following:</source>
          <target state="translated">서버는 다음과 유사한 JSON 데이터를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b0df9758bfbf2068ff3ee480efe9e6ed9e4ab1a" translate="yes" xml:space="preserve">
          <source>The shorthand value can also be observable. In this case, if it changes, the component binding will &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;dispose&lt;/a&gt; the old component instance, and inject the newly-referenced component. Example:</source>
          <target state="translated">속기 값도 관찰 할 수 있습니다. 이 변경되면이 경우, 바인딩 구성 요소가됩니다 &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;폐기&lt;/a&gt; 이전 구성 요소 인스턴스를 새로 참조 된 구성 요소를 주입. 예:</target>
        </trans-unit>
        <trans-unit id="049fd86ea4cbaee495bc01813f2e795073b4e49c" translate="yes" xml:space="preserve">
          <source>The slice function is the observableArray equivalent of the native JavaScript slice function (i.e., it returns the entries of your array from a given start index up to a given end index). Calling myObservableArray.slice(...) is equivalent to calling the same method on the underlying array (i.e., myObservableArray().slice(...)).</source>
          <target state="translated">slice 함수는 기본 JavaScript slice 함수와 동등한 observableArray입니다 (예 : 지정된 시작 색인에서 지정된 종료 색인까지 배열 항목을 반환 함). myObservableArray.slice (...)를 호출하는 것은 기본 배열에서 동일한 메소드를 호출하는 것과 같습니다 (예 : myObservableArray (). slice (...)).</target>
        </trans-unit>
        <trans-unit id="51256b6bbeb757b7a3e53c454df3877ec1922f40" translate="yes" xml:space="preserve">
          <source>The standard method of defining a &lt;em&gt;pure&lt;/em&gt; computed observable is to use ko.pureComputed:</source>
          <target state="translated">&lt;em&gt;순수한&lt;/em&gt; 계산 된 관측 가능 객체 를 정의하는 표준 방법은 ko.pureComputed를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="47dbc61c148aa218c24d0f4919a72baba631be9b" translate="yes" xml:space="preserve">
          <source>The style binding adds or removes one or more style values to the associated DOM element. This is useful, for example, to highlight some value in red if it becomes negative, or to set the width of a bar to match a numerical value that changes.</source>
          <target state="translated">스타일 바인딩은 하나 이상의 스타일 값을 연관된 DOM 요소에 추가하거나 제거합니다. 예를 들어 음수가되면 일부 값을 빨간색으로 강조 표시하거나 바의 너비를 변경하는 숫자 값과 일치하도록 설정하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1ef276a741bad031dcded61f8068495eb09f16a8" translate="yes" xml:space="preserve">
          <source>The submit binding adds an event handler so that your chosen JavaScript function will be invoked when the associated DOM element is submitted. Typically you will only want to use this on form elements.</source>
          <target state="translated">제출 바인딩은 연관된 DOM 요소가 제출 될 때 선택한 JavaScript 함수가 호출되도록 이벤트 핸들러를 추가합니다. 일반적으로 양식 요소에만 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="f2b3c41c3803b6fdf7bb3dcb97584e848e98e1cc" translate="yes" xml:space="preserve">
          <source>The subscribe function accepts three parameters: callback is the function that is called whenever the notification happens, target (optional) defines the value of this in the callback function, and event (optional; default is &quot;change&quot;) is the name of the event to receive notification for.</source>
          <target state="translated">subscribe 함수는 세 가지 매개 변수를 허용합니다. callback은 알림이 발생할 때마다 호출되는 함수이고 target (선택적)은 콜백 함수에서이 값을 정의하며 event (선택적, 기본값은 &quot;change&quot;)는 이벤트의 이름입니다. 에 대한 알림을받습니다.</target>
        </trans-unit>
        <trans-unit id="016b4f1bb0fd10e4b91ab01327aa8086f3b0e070" translate="yes" xml:space="preserve">
          <source>The subscribe function is how many parts of KO work internally. Most of the time you don&amp;rsquo;t need to use this, because the built-in bindings and templating system take care of managing subscriptions.</source>
          <target state="translated">구독 기능은 KO의 내부에서 몇 부분이 작동하는지입니다. 빌트인 바인딩 및 템플릿 시스템이 구독 관리를 담당하기 때문에 대부분이 시간을 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="046a68fc34463623e0087f15d2cbe37f0a99e3bf" translate="yes" xml:space="preserve">
          <source>The syntax is more convenient. To call KO&amp;rsquo;s push method, just write myObservableArray.push(...). This is slightly nicer than calling the underlying array&amp;rsquo;s push method by writing myObservableArray().push(...).</source>
          <target state="translated">구문이 더 편리합니다. KO의 push 메소드를 호출하려면 myObservableArray.push (...)를 작성하십시오. myObservableArray (). push (...)를 작성하여 기본 배열의 push 메소드를 호출하는 것보다 약간 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bd48513a1e40433618e2382185d34142f3816b64" translate="yes" xml:space="preserve">
          <source>The template binding populates the associated DOM element with the results of rendering a template. Templates are a simple and convenient way to build sophisticated UI structures - possibly with repeating or nested blocks - as a function of your view model data.</source>
          <target state="translated">템플리트 바인딩은 연관된 DOM 요소를 템플리트 렌더링 결과로 채 웁니다. 템플릿은 뷰 모델 데이터의 함수로서 반복적이거나 중첩 된 블록을 사용하여 정교한 UI 구조를 작성하는 간단하고 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="c4ef5b8434eccb8c5846957e191b2353bcb8c255" translate="yes" xml:space="preserve">
          <source>The templateConfig value is simply the template property from any componentConfig object. For example, it may contain &quot;some markup&quot; or {element:&quot;someId&quot;} or a custom format such as {loadFromUrl:&quot;someUrl.html&quot;}.</source>
          <target state="translated">templateConfig 값은 모든 componentConfig 오브젝트의 템플리트 특성입니다. 예를 들어 &quot;some markup&quot;또는 {element : &quot;someId&quot;} 또는 {loadFromUrl : &quot;someUrl.html&quot;}과 같은 사용자 정의 형식을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0cfb1138db7edd7758273fad1e4a3a38ac65bd9" translate="yes" xml:space="preserve">
          <source>The text binding causes the associated DOM element to display the text value of your parameter.</source>
          <target state="translated">텍스트 바인딩은 연관된 DOM 요소가 매개 변수의 텍스트 값을 표시하게합니다.</target>
        </trans-unit>
        <trans-unit id="583c97cdc5485ae99a9042d6a2aa5ca3bd365673" translate="yes" xml:space="preserve">
          <source>The textInput binding is specifically designed to handle a wide range of browser quirks, to provide consistent and immediate model updates even in response to unusual text entry methods.</source>
          <target state="translated">textInput 바인딩은 특수한 텍스트 입력 방법에 대한 응답으로도 일관되고 즉각적인 모델 업데이트를 제공하기 위해 광범위한 브라우저 문제를 처리하도록 특별히 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="98c7d7411d6cd38a5fa10c5e758660c706e016b3" translate="yes" xml:space="preserve">
          <source>The textInput binding links a text box (&amp;lt;input&amp;gt;) or text area (&amp;lt;textarea&amp;gt;) with a viewmodel property, providing two-way updates between the viewmodel property and the element&amp;rsquo;s value. Unlike the value binding, textInput provides instant updates from the DOM for all types of user input, including autocomplete, drag-and-drop, and clipboard events.</source>
          <target state="translated">textInput 바인딩은 텍스트 상자 (&amp;lt;input&amp;gt;) 또는 텍스트 영역 (&amp;lt;textarea&amp;gt;)을 viewmodel 속성과 연결하여 viewmodel 속성과 요소 값 사이의 양방향 업데이트를 제공합니다. 값 바인딩과 달리 textInput은 자동 완성, 끌어서 놓기 및 클립 보드 이벤트를 포함한 모든 유형의 사용자 입력에 대해 DOM에서 즉시 업데이트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c97b5f8151ffd9c3cb4b842df2c6ab37add94e04" translate="yes" xml:space="preserve">
          <source>The uniqueName binding ensures that the associated DOM element has a nonempty name attribute. If the DOM element did not have a name attribute, this binding gives it one and sets it to some unique string value.</source>
          <target state="translated">uniqueName 바인딩은 연관된 DOM 요소가 비어 있지 않은 이름 속성을 갖도록합니다. DOM 요소에 이름 속성이없는 경우이 바인딩은이를 제공하여 고유 한 문자열 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8ad9163f8b350f9acb1cee05eb1ef6108edde552" translate="yes" xml:space="preserve">
          <source>The value binding links the associated DOM element&amp;rsquo;s value with a property on your view model. This is typically useful with form elements such as &amp;lt;input&amp;gt;, &amp;lt;select&amp;gt; and &amp;lt;textarea&amp;gt;.</source>
          <target state="translated">값 바인딩은 연관된 DOM 요소의 값을 뷰 모델의 특성과 연결합니다. 이것은 일반적으로 &amp;lt;input&amp;gt;, &amp;lt;select&amp;gt; 및 &amp;lt;textarea&amp;gt;와 같은 양식 요소에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9387180a42aa7a17b48448a72d7472f68cb9f230" translate="yes" xml:space="preserve">
          <source>The value of the computed observable shouldn&amp;rsquo;t vary based on the number of evaluations or other &amp;ldquo;hidden&amp;rdquo; information. Its value should be based solely on the values of other observables in the application, which for the pure function definition, are considered its parameters.</source>
          <target state="translated">계산 된 관측 가능 값은 평가 횟수 또는 기타 &quot;숨겨진&quot;정보에 따라 달라지지 않아야합니다. 이 값은 응용 프로그램의 다른 관측 가능 값에만 기반해야하며 순수한 함수 정의의 경우 해당 매개 변수로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="14eb51c71508d408d23b29aa7938c5e57a2a7c2e" translate="yes" xml:space="preserve">
          <source>The value you assign should be an array (or observable array). The &amp;lt;select&amp;gt; element will then display one item for each item in your array.</source>
          <target state="translated">할당 한 값은 배열 (또는 관찰 가능한 배열)이어야합니다. &amp;lt;select&amp;gt; 요소는 배열의 각 항목에 대해 하나의 항목을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="fe79d0c6fc554a50ffe91a6318c3a95369cb8cac" translate="yes" xml:space="preserve">
          <source>The viewModelConfig value is simply the viewModel property from any componentConfig object. For example, it may be a constructor function, or a custom format such as {myViewModelType:'Something',options:{}}.</source>
          <target state="translated">viewModelConfig 값은 단순히 componentConfig 객체의 viewModel 속성입니다. 예를 들어 생성자 함수이거나 {myViewModelType : 'Something', options : {}}와 같은 사용자 정의 형식 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff29c13e73c111a3106d90b4abd24a7404d96b9c" translate="yes" xml:space="preserve">
          <source>The visible binding causes the associated DOM element to become hidden or visible according to the value you pass to the binding.</source>
          <target state="translated">보이는 바인딩은 연결된 DOM 요소가 바인딩에 전달한 값에 따라 숨겨 지거나 보이도록합니다.</target>
        </trans-unit>
        <trans-unit id="3dcca4073da45812cd05022db33c86a1c7087f8e" translate="yes" xml:space="preserve">
          <source>The whole point of observables is that they can be observed, i.e., other code can say that it wants to be notified of changes. That&amp;rsquo;s what many of KO&amp;rsquo;s built-in bindings do internally. So, when you wrote data-bind=&quot;text: personName&quot;, the text binding registered itself to be notified when personName changes (assuming it&amp;rsquo;s an observable value, which it is now).</source>
          <target state="translated">관찰 가능 항목의 요점은 관찰 가능하다는 것입니다. 즉, 다른 코드는 변경 사항을 통보 받고 싶다고 말할 수 있습니다. 그것이 KO의 많은 내장 바인딩이 내부적으로하는 일입니다. 따라서 data-bind = &quot;text : personName&quot;을 작성할 때 personName이 변경 될 때 알림을 받도록 텍스트 바인딩 자체가 등록되었습니다 (관찰 가능한 값이라고 가정).</target>
        </trans-unit>
        <trans-unit id="08840010b83b1dfd4295b6784268bddb1bef073c" translate="yes" xml:space="preserve">
          <source>The with binding creates a new &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;, so that descendant elements are bound in the context of a specified object.</source>
          <target state="translated">with 바인딩은 새로운 &lt;a href=&quot;binding-context&quot;&gt;바인딩 컨텍스트를&lt;/a&gt; 생성하여 하위 요소가 지정된 객체의 컨텍스트에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="524ea84b41e8a5893953b0074485b90cf1eff52f" translate="yes" xml:space="preserve">
          <source>The with binding will dynamically add or remove descendant elements depending on whether the associated value is null/undefined or not</source>
          <target state="translated">with 바인딩은 연관된 값이 null / undefined인지 여부에 따라 하위 요소를 동적으로 추가하거나 제거합니다.</target>
        </trans-unit>
        <trans-unit id="7e032d672f4e300f7eeb1bbf7504868ad1577af8" translate="yes" xml:space="preserve">
          <source>Then, with this componentConfig object, calls each of the registered loaders&amp;rsquo; loadComponent functions in turn, until the first one supplies a non-null template/createViewModel pair.</source>
          <target state="translated">그런 다음이 componentConfig 오브젝트를 사용하여 첫 번째 함수가 널이 아닌 템플리트 / createViewModel 쌍을 제공 할 때까지 등록 된 각 로더의 loadComponent 함수를 차례로 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="af5fd56709b842c37eecfef0bd5fee58c13743cd" translate="yes" xml:space="preserve">
          <source>Then, you can use jQuery.tmpl syntax in your templates. For example,</source>
          <target state="translated">그런 다음 템플릿에서 jQuery.tmpl 구문을 사용할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="1da7ec95f9f3bd6c9bcf839432044e2340b7b515" translate="yes" xml:space="preserve">
          <source>Then, your custom function will become available on all values of that type created from that point onwards.</source>
          <target state="translated">그러면 해당 시점부터 생성 된 해당 유형의 모든 값에서 사용자 정의 기능을 사용할 수있게됩니다.</target>
        </trans-unit>
        <trans-unit id="cd22bd8141f2da85ed82fbfb3975c4c5b8fe254b" translate="yes" xml:space="preserve">
          <source>There are two main ways of using templates:</source>
          <target state="translated">템플릿을 사용하는 주요 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="88cee14671dcbec805136df550f741e76f165562" translate="yes" xml:space="preserve">
          <source>There are two ways to use the component binding:</source>
          <target state="translated">컴포넌트 바인딩을 사용하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="624acfe0a4456c96d3f7eb19804d2c53591e62dd" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s a popular convention that avoids the need to track this altogether: if your viewmodel&amp;rsquo;s constructor copies a reference to this into a different variable (traditionally called self), you can then use self throughout your viewmodel and don&amp;rsquo;t have to worry about it being redefined to refer to something else. For example:</source>
          <target state="translated">뷰 모델의 생성자가 이에 대한 참조를 다른 변수 (전통적으로 self라고 함)에 복사하면 뷰 모델 전체에서 self를 사용할 수 있으므로 걱정할 필요가 없습니다. 다른 것을 참조하도록 재정의되었습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="90d3a6cc255f075aee8c59ce311e982c597bc606" translate="yes" xml:space="preserve">
          <source>These examples show that the value can be just about any JavaScript expression. Even the comma is fine when it&amp;rsquo;s enclosed in braces, brackets, or parentheses. When the value is an object literal, the object&amp;rsquo;s property names must be valid JavaScript identifiers or be enclosed in quotes. If the binding value is an invalid expression or references an unknown variable, Knockout will output an error and stop processing bindings.</source>
          <target state="translated">이 예제는 값이 거의 모든 JavaScript 표현식 일 수 있음을 보여줍니다. 쉼표도 중괄호, 괄호 또는 괄호로 묶으면 괜찮습니다. 값이 객체 리터럴 인 경우 객체의 속성 이름은 유효한 JavaScript 식별자이거나 따옴표로 묶어야합니다. 바인딩 값이 유효하지 않은 표현식이거나 알 수없는 변수를 참조하면 Knockout은 오류를 출력하고 바인딩 처리를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="1f3eb587b2006b4e40fc88eeb1c957f9aa6b49ff" translate="yes" xml:space="preserve">
          <source>These facilities are typically useful only in advanced scenarios, for example when your computed observable&amp;rsquo;s primary purpose is to trigger some side-effect during its evaluator, and you want to perform some setup logic only during the first run, or only if it has at least one dependency (and hence might re-evaluate in the future). Most computed properties do not need to care whether they have been evaluated before, or how many dependencies they have.</source>
          <target state="translated">이러한 기능은 일반적으로 고급 시나리오에서만 유용합니다. 예를 들어 계산 된 관찰 가능의 주요 목적이 평가 기 동안 일부 부작용을 유발하고 첫 번째 실행 중에 만 또는 일부 이상이있는 경우에만 일부 설정 논리를 수행하려는 경우 하나의 의존성 (따라서 향후 재평가 될 수 있음). 대부분의 계산 된 속성은 이전에 평가되었는지 또는 얼마나 많은 종속성이 있는지를 신경 쓸 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="07ffcc399a3f0a54ad9c2648a23eb7d7ec9c57ef" translate="yes" xml:space="preserve">
          <source>These helper functions can be used in event handlers that are attached unobtrusively using something like jQuery&amp;rsquo;s bind or click. The above function could be attached to each link with a remove class like:</source>
          <target state="translated">이 도우미 함수는 jQuery의 바인드 또는 클릭과 같은 것을 사용하여 눈에 잘 띄지 않게 연결된 이벤트 핸들러에서 사용할 수 있습니다. 위의 함수는 다음과 같이 remove 클래스를 사용하여 각 링크에 연결될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8797502eb386f1c824a0aa629bcaa04c161fe178" translate="yes" xml:space="preserve">
          <source>They are functionally equivalent to the regular ko.observableArray functions, but can do things based on the key of the object. For example, this would work:</source>
          <target state="translated">그것들은 기능적으로 일반 ko.observableArray 함수와 동일하지만 객체의 키를 기반으로 작업을 수행 할 수 있습니다. 예를 들어 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="18962a789df3d7447e4daeeed751e58a433346fb" translate="yes" xml:space="preserve">
          <source>They work on all targeted browsers. (For example, the native JavaScript indexOf function doesn&amp;rsquo;t work on IE 8 or earlier, but KO&amp;rsquo;s indexOf works everywhere.)</source>
          <target state="translated">그들은 모든 대상 브라우저에서 작동합니다. 예를 들어 기본 JavaScript indexOf 함수는 IE 8 이전 버전에서는 작동하지 않지만 KO의 indexOf는 모든 곳에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b23e367c7cba12e6cfcd6e2cb9f9d24753504d55" translate="yes" xml:space="preserve">
          <source>This &amp;ldquo;special list&amp;rdquo; example does nothing more than insert a heading above each list item. But the same technique can be used to create sophisticated grids, dialogs, tab sets, and so on, since all that is needed for such UI elements is common UI markup (e.g., to define the grid or dialog&amp;rsquo;s heading and borders) wrapped around arbitrary supplied markup.</source>
          <target state="translated">이 &quot;특수 목록&quot;예제는 각 목록 항목 위에 제목을 삽입하는 것 이상을 수행하지 않습니다. 그러나 동일한 UI 기술을 사용하여 정교한 그리드, 대화 상자, 탭 세트 등을 만들 수 있습니다. 이러한 UI 요소에 필요한 모든 것은 임의의 주위에 래핑 된 일반적인 UI 마크 업 (예 : 그리드 또는 대화 상자의 제목 및 테두리 정의)이기 때문입니다. 제공된 마크 업.</target>
        </trans-unit>
        <trans-unit id="5fac83af14640609f6eb7dbff17d1de27fd0b429" translate="yes" xml:space="preserve">
          <source>This ability is especially useful when paired with &lt;a href=&quot;binding-preprocessing&quot;&gt;binding preprocessing&lt;/a&gt;, which can assign a default value for a binding.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;binding-preprocessing&quot;&gt;바인딩 사전 처리&lt;/a&gt; 와 페어링 될 때 특히 유용하며 바인딩 의 기본값을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcf4fe4f919e5f9a307b9e9f04eda05c1f8836ad" translate="yes" xml:space="preserve">
          <source>This allows for a very modern, &lt;a href=&quot;http://www.w3.org/TR/components-intro/&quot;&gt;WebComponents&lt;/a&gt;-like way to organize your code, while retaining support for even very old browsers (see &lt;a href=&quot;#note-custom-elements-and-internet-explorer-6-to-8&quot;&gt;custom elements and IE 6 to 8&lt;/a&gt;).</source>
          <target state="translated">이를 통해 코드를 구성 하는 매우 현대적인 &lt;a href=&quot;http://www.w3.org/TR/components-intro/&quot;&gt;WebComponents&lt;/a&gt; 와 유사한 방법을 사용할 수 있으며 아주 오래된 브라우저도 지원할 수 있습니다 ( &lt;a href=&quot;#note-custom-elements-and-internet-explorer-6-to-8&quot;&gt;사용자 지정 요소 및 IE 6 ~ 8 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1eb5e5d48d4ea01bc727416a9600946df475abd7" translate="yes" xml:space="preserve">
          <source>This automatically creates observable properties for each of the properties on data. Then, every time you receive new data from the server, you can update all the properties on viewModel in one step by calling the ko.mapping.fromJS function again:</source>
          <target state="translated">그러면 데이터의 각 속성에 대해 관찰 가능한 속성이 자동으로 생성됩니다. 그런 다음 서버에서 새 데이터를 수신 할 때마다 ko.mapping.fromJS 함수를 다시 호출하여 viewModel의 모든 특성을 한 번에 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50dfddf19ae9e5c9f7164b96b3b17f0f1a097c05" translate="yes" xml:space="preserve">
          <source>This contains a mix of observables, computed observables, observable arrays, and plain values. You can convert it to a JSON string suitable for sending to the server using ko.toJSON as follows:</source>
          <target state="translated">여기에는 관찰 가능 항목, 계산 된 관찰 가능 항목, 관찰 가능 배열 및 일반 값이 혼합되어 있습니다. 다음과 같이 ko.toJSON을 사용하여 서버로 전송하기에 적합한 JSON 문자열로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e7f5312e7a860e5c84608a61ebd0ff4a1fe6f16" translate="yes" xml:space="preserve">
          <source>This double-unwrapping would be ugly, inconvenient, and unexpected, so Knockout automatically sets up the generated computed property (params.myExpr) to unwrap its value for you. That is, the component can read params.myExpr() to get the value of whichever observable has been selected (observable1 or observable2), without the need for double-unwrapping.</source>
          <target state="translated">이 이중 언 래핑은 추악하고 불편하며 예기치 않은 일이므로 Knockout은 생성 된 계산 속성 (params.myExpr)을 자동으로 설정하여 값을 줄입니다. 즉, 구성 요소는 params.myExpr ()을 읽고 이중 언 래핑 없이도 관찰 가능한 값 (observable1 또는 observable2)의 값을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="835c1c20db465de114b6ecf00cf935dce609fbad" translate="yes" xml:space="preserve">
          <source>This easy to do: just add an additional parameter with name optionsCaption, with its value being a string to display. For example:</source>
          <target state="translated">이 작업은 쉽게 수행 할 수 있습니다. 이름 optionsCaption과 함께 추가 매개 변수를 추가하면 값은 표시 할 문자열입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f6f4ddca2613356e2726599ab4684e2eaa1b28b" translate="yes" xml:space="preserve">
          <source>This example creates an extender that allows an observable to be marked as required. Instead of returning a new object, this extender simply adds additional sub-observables to the existing observable. Since observables are functions, they can actually have their own properties. However, when the view model is converted to JSON, the sub-observables will be dropped and we will simply be left with the value of our actual observable. This is a nice way to add additional functionality that is only relevant for the UI and does not need to be sent back to the server.</source>
          <target state="translated">이 예제에서는 관찰 가능 항목을 필요에 따라 표시 할 수있는 익스텐더를 만듭니다. 이 익스텐더는 새 객체를 반환하는 대신 기존 관찰 가능 항목에 하위 관찰 가능 항목을 추가하기 만하면됩니다. 옵저버 블은 함수이므로 실제로 자체 속성을 가질 수 있습니다. 그러나 뷰 모델이 JSON으로 변환되면 하위 관찰 가능 항목이 삭제되고 실제 관찰 가능 값만 남게됩니다. 이것은 UI에만 관련된 추가 기능을 추가 할 수있는 좋은 방법입니다. 서버로 다시 보낼 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="65ecaa594cf97a786d25b11561c62fb053ea502c" translate="yes" xml:space="preserve">
          <source>This example creates an extender that forces writes to an observable to be numeric rounded to a configurable level of precision. In this case, the extender will return a new writable computed observable that will sit in front of the real observable intercepting writes.</source>
          <target state="translated">이 예제는 옵저버 블에 쓰기를 구성 가능한 정밀도 수준으로 반올림하도록하는 익스텐더를 만듭니다. 이 경우, 익스텐더는 실제 관찰 가능한 가로 채기 쓰기 앞에 앉아 쓰기 가능한 새로운 계산 가능한 관찰 가능 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7bc47da371a683aaa1120d6ec7b6e5389241143d" translate="yes" xml:space="preserve">
          <source>This example declares a component, and then injects two instances of it into a view. See the source code below.</source>
          <target state="translated">이 예제는 컴포넌트를 선언 한 다음 두 개의 인스턴스를 뷰에 삽입합니다. 아래 소스 코드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="579304ee7faef55eabaa909aa4e1dc99ece5d462" translate="yes" xml:space="preserve">
          <source>This example shows &amp;ldquo;add&amp;rdquo; and &amp;ldquo;remove&amp;rdquo; links on multiple levels of parents and children with a single handler attached unobtrusively for each type of link.</source>
          <target state="translated">이 예는 각 유형의 링크에 대해 단일 처리기가 첨부 된 여러 수준의 부모 및 자식에 대한 &quot;add&quot;및 &quot;remove&quot;링크를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e7d030e3401c09158dec61fedd6b90ab7f45ab5c" translate="yes" xml:space="preserve">
          <source>This example shows that the if binding can dynamically add and remove sections of markup as observable values change.</source>
          <target state="translated">이 예제는 if 바인딩이 관찰 가능한 값이 변경 될 때 마크 업 섹션을 동적으로 추가 및 제거 할 수 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="969c85da8be854a1b6c00abcfd3856c63f7a00ff" translate="yes" xml:space="preserve">
          <source>This example simply displays a message if the textbox currently has focus, and uses a button to show that you can trigger focus programmatically.</source>
          <target state="translated">이 예제는 텍스트 상자에 현재 포커스가있는 경우 메시지를 표시하고 단추를 사용하여 프로그래밍 방식으로 포커스를 트리거 할 수 있음을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d2a7a601d44439dd914189703f94ab3cea4924d9" translate="yes" xml:space="preserve">
          <source>This example uses foreach to produce a read-only table with a row for each array entry.</source>
          <target state="translated">이 예제는 foreach를 사용하여 각 배열 항목에 대한 행이있는 읽기 전용 테이블을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d0a6677ca47c0e8f5d5df08e50b25d599f696a47" translate="yes" xml:space="preserve">
          <source>This functionality applies to errors in the following contexts:</source>
          <target state="translated">이 기능은 다음 컨텍스트의 오류에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="da0d1aeda4e842abb4270aaff5c44f9cf5e0cbec" translate="yes" xml:space="preserve">
          <source>This gives the same result as embedding an anonymous template directly inside the element to which you use foreach, i.e.:</source>
          <target state="translated">이는 foreach를 사용하는 요소 내에 익명 템플릿을 직접 포함시키는 것과 동일한 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="66096e1d294700a561ed7c38d1667f6e3e659ad9" translate="yes" xml:space="preserve">
          <source>This happens because, by default, the mapping plugin simply compares the two objects in the array. And since in JavaScript the object {id:1,name:'Alicw'} does not equal {id:1,name:'Alice'} it thinks that the &lt;em&gt;entire&lt;/em&gt; child needs to be removed and replaced by a new one.</source>
          <target state="translated">기본적으로 매핑 플러그인은 단순히 배열의 두 객체를 비교하기 때문에 발생합니다. 그리고 JavaScript에서 {id : 1, name : 'Alicw'} 개체는 {id : 1, name : 'Alice'}와 같지 않기 때문에 &lt;em&gt;전체&lt;/em&gt; 자식을 제거하고 새 것으로 교체해야 한다고 생각합니다 .</target>
        </trans-unit>
        <trans-unit id="e2d595e57fa825c7d94c939731588cee9344439f" translate="yes" xml:space="preserve">
          <source>This has exactly the same result, without requiring the priceRating computed observable.</source>
          <target state="translated">이는 priceRating 계산 된 관찰 가능을 요구하지 않고 정확히 동일한 결과를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="3077765de26211664ba2efe22cb2b9cd04fb4caa" translate="yes" xml:space="preserve">
          <source>This interactive example demonstrates that:</source>
          <target state="translated">이 대화식 예제는 다음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5643babfcf6893a24373debdbe07dfee55a51dd1" translate="yes" xml:space="preserve">
          <source>This is a limitation of the HTML specification and is outside the scope of what Knockout can control. HTML parsers, following the HTML specification, &lt;a href=&quot;http://dev.w3.org/html5/spec-author-view/syntax.html#syntax-start-tag&quot;&gt;ignore any self-closing slashes&lt;/a&gt; (except on a small number of special &amp;ldquo;foreign elements&amp;rdquo;, which are hardcoded into the parser). HTML is not the same as XML.</source>
          <target state="translated">이는 HTML 사양의 제한 사항이며 Knockout이 제어 할 수있는 범위를 벗어납니다. HTML 사양에 따른 HTML 파서는 &lt;a href=&quot;http://dev.w3.org/html5/spec-author-view/syntax.html#syntax-start-tag&quot;&gt;자체 닫는 슬래시를 무시합니다&lt;/a&gt; (파서에 하드 코딩 된 소수의 특수 &quot;외부 요소&quot;제외). HTML은 XML과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f78bc1ff46d4250e923789d55c729bf459efb257" translate="yes" xml:space="preserve">
          <source>This is an array representing all of the parent view models:</source>
          <target state="translated">이것은 모든 상위 뷰 모델을 나타내는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="74000dd6220d8d962de61f08d4444c669e765e23" translate="yes" xml:space="preserve">
          <source>This is how you can pass properties from a parent viewmodel to a child component. If the properties themselves are observable, then the parent viewmodel will be able to observe and react to any new values inserted into them by the child component.</source>
          <target state="translated">이것은 부모 뷰 모델에서 자식 컴포넌트로 속성을 전달하는 방법입니다. 속성 자체를 관찰 할 수있는 경우 부모 뷰 모델은 자식 구성 요소가 삽입 한 새 값을 관찰하고 반응 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a2bb49027f1ab6742f350a8ffba17b3b3c61fdd" translate="yes" xml:space="preserve">
          <source>This is mainly useful if you have multiple levels of nested foreach blocks, because it gives you an unambiguous way to refer to any named item declared at a higher level in the hierarchy. Here&amp;rsquo;s a complete example, showing how season can be referenced while rendering a month:</source>
          <target state="translated">계층 구조에서 상위 수준으로 선언 된 명명 된 항목을 명확하게 참조 할 수 있으므로 여러 수준의 중첩 된 foreach 블록이있는 경우 주로 유용합니다. 다음은 한 달을 렌더링하는 동안 시즌을 참조 할 수있는 방법을 보여주는 완전한 예입니다.</target>
        </trans-unit>
        <trans-unit id="8cfd1c39aecebfca1259dc459499bea32121ecc1" translate="yes" xml:space="preserve">
          <source>This is mainly useful when you&amp;rsquo;re fetching the markup from somewhere programmatically (e.g., &lt;a href=&quot;#a-recommended-amd-module-pattern&quot;&gt;AMD - see below&lt;/a&gt;), or as a build system output that packages components for distribution, since it&amp;rsquo;s not very convenient to manually edit HTML as a JavaScript string literal.</source>
          <target state="translated">이 방법은 프로그래밍 방식으로 어딘가에서 마크 업을 가져 오거나 (예 : &lt;a href=&quot;#a-recommended-amd-module-pattern&quot;&gt;AMD-아래 참조&lt;/a&gt; ) 배포를 위해 구성 요소를 패키징하는 빌드 시스템 출력으로 HTML을 JavaScript 문자열 리터럴로 수동으로 편집하는 것이 매우 편리하지 않기 때문에 주로 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="456a8a825127f0754a6b3c29d2b3b6a2b87ce4f4" translate="yes" xml:space="preserve">
          <source>This is the element DOM object (for virtual elements, it will be the comment DOM object) of the current binding. This can be useful if a binding needs to access an attribute of the current element. Example:</source>
          <target state="translated">이것은 현재 바인딩의 요소 DOM 객체 (가상 요소의 경우 주석 DOM 객체가 됨)입니다. 바인딩이 현재 요소의 속성에 액세스해야하는 경우 유용 할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="a03a71e0074cf075a1a1081583cac59ac61756fe" translate="yes" xml:space="preserve">
          <source>This is the exact opposite of the &lt;a href=&quot;http://knockoutjs.com/examples/helloWorld.html&quot;&gt;Hello World&lt;/a&gt; example, in that here the first and last names are not editable, but the combined full name is editable.</source>
          <target state="translated">이것은 &lt;a href=&quot;http://knockoutjs.com/examples/helloWorld.html&quot;&gt;Hello World&lt;/a&gt; 예제와 정반대입니다. 여기서 성과 이름은 편집 할 수 없지만 결합 된 전체 이름은 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="173aba90415cf038a5ca44929194616b39af11e1" translate="yes" xml:space="preserve">
          <source>This is the main view model object in the root context, i.e., the topmost parent context. It&amp;rsquo;s usually the object that was passed to ko.applyBindings. It is equivalent to $parents[$parents.length - 1].</source>
          <target state="translated">루트 컨텍스트, 즉 최상위 부모 컨텍스트의 기본 뷰 모델 객체입니다. 일반적으로 ko.applyBindings에 전달 된 객체입니다. $ parents [$ parents.length-1]와 같습니다.</target>
        </trans-unit>
        <trans-unit id="6240fa458446de4cb8e845cb681191b4719f6c7d" translate="yes" xml:space="preserve">
          <source>This is the mirror image of the enable binding. For more information, see &lt;a href=&quot;enable-binding&quot;&gt;documentation for the enable binding&lt;/a&gt;, because disable works in exactly the same way except that it negates whatever parameter you pass to it.</source>
          <target state="translated">이것은 인 에이블 바인딩의 미러 이미지입니다. 자세한 내용 &lt;a href=&quot;enable-binding&quot;&gt;은 enable 바인딩에 대한 설명서를&lt;/a&gt; 참조하십시오. disable은 전달하는 매개 변수를 무효화한다는 점을 제외하고는 동일한 방식으로 작동하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="29889de6133ca2a7946ef92ef09c7a021e5d70d0" translate="yes" xml:space="preserve">
          <source>This is the raw view model value in the current context. Usually this will be the same as $data, but if the view model provided to Knockout is wrapped in an observable, $data will be the unwrapped view model, and $rawData will be the observable itself.</source>
          <target state="translated">이것은 현재 컨텍스트에서 원시 뷰 모델 값입니다. 일반적으로 이것은 $ data와 동일하지만 Knockout에 제공된 뷰 모델이 Observable에 래핑 된 경우 $ data는 래핑되지 않은 뷰 모델이되고 $ rawData는 Observable 자체가됩니다.</target>
        </trans-unit>
        <trans-unit id="aaaecc06d2965d5100af141ea778d358bd106f1b" translate="yes" xml:space="preserve">
          <source>This is the view model object in the current context. In the root context, $data and $root are equivalent. Inside a nested binding context, this parameter will be set to the current data item (e.g., inside a with: person binding, $data will be set to person). $data is useful when you want to reference the viewmodel itself, rather than a property on the viewmodel. Example:</source>
          <target state="translated">현재 컨텍스트의 뷰 모델 객체입니다. 루트 컨텍스트에서 $ data와 $ root는 동일합니다. 중첩 된 바인딩 컨텍스트 내에서이 매개 변수는 현재 데이터 항목으로 설정됩니다 (예 : with : person 바인딩, $ data는 person으로 설정 됨). $ data는 뷰 모델의 속성이 아닌 뷰 모델 자체를 참조 할 때 유용합니다. 예:</target>
        </trans-unit>
        <trans-unit id="1425847fb23b8c40942166dc9b9ab9eb5c03913c" translate="yes" xml:space="preserve">
          <source>This is the view model object in the parent context, the one immeditely outside the current context. In the root context, this is undefined. Example:</source>
          <target state="translated">이것은 부모 컨텍스트의 뷰 모델 개체로, 현재 컨텍스트 외부에있는 개체입니다. 루트 컨텍스트에서는 정의되지 않습니다. 예:</target>
        </trans-unit>
        <trans-unit id="0a75f1ff617db05b67a63f53671406646513047f" translate="yes" xml:space="preserve">
          <source>This is the zero-based index of the current array entry being rendered by a foreach binding. Unlike the other binding context properties, $index is an observable and is updated whenever the index of the item changes (e.g., if items are added to or removed from the array).</source>
          <target state="translated">이것은 foreach 바인딩으로 렌더링되는 현재 배열 항목의 인덱스 (0부터 시작)입니다. 다른 바인딩 컨텍스트 속성과 달리 $ index는 관찰 가능하며 항목의 인덱스가 변경 될 때마다 (예 : 항목이 배열에 추가되거나 배열에서 제거되는 경우) 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="c4b96d23cc0b80a5d0c6fab427a1e7b9868d5d79" translate="yes" xml:space="preserve">
          <source>This is useful if you want to build components that represent &amp;ldquo;container&amp;rdquo; UI elements, such as grids, lists, dialogs, or tab sets, which need to inject and bind arbitrary markup into a common structure. See &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;a complete example for custom elements&lt;/a&gt;, which also works without custom elements using the syntax shown above.</source>
          <target state="translated">이는 임의의 마크 업을 공통 구조에 삽입하고 바인딩해야하는 그리드, 목록, 대화 상자 또는 탭 세트와 같은 &quot;컨테이너&quot;UI 요소를 나타내는 컴포넌트를 빌드하려는 경우에 유용합니다. 위의 구문을 사용하여 사용자 정의 요소없이 작동하는 &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;사용자 정의 요소에 대한 전체 예제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ba543ff4dde01f5c7ccc4e0eadd6fedd604bb14" translate="yes" xml:space="preserve">
          <source>This is useful if you&amp;rsquo;re building sophisticated forms in which editable elements appear dynamically, and you would like to control where the user should start typing, or respond to the location of the caret.</source>
          <target state="translated">편집 가능한 요소가 동적으로 나타나는 정교한 양식을 작성하고 사용자가 입력을 시작하거나 캐럿의 위치에 응답해야하는 위치를 제어하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0fa03a3f15a0e8fbad9cff23f1c0c40a68b4b25f" translate="yes" xml:space="preserve">
          <source>This is useful, for example, if a component&amp;rsquo;s template includes one or more foreach blocks in which you wish to refer to some property or function on the component viewmodel rather than on the current data item.</source>
          <target state="translated">예를 들어, 구성 요소의 템플릿에 현재 데이터 항목이 아닌 구성 요소 뷰 모델의 일부 속성 또는 함수를 참조하려는 하나 이상의 foreach 블록이 포함 된 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="599fc1798895695cf0148c049103421a0f316ffe" translate="yes" xml:space="preserve">
          <source>This is very simple and elegant (and it&amp;rsquo;s trivial to add yet more observable query parameters that also trigger a refresh automatically whenever they change), but there is a potential efficiency problem. Suppose you add the following function to GridViewModel that changes both pageIndex and pageSize:</source>
          <target state="translated">이것은 매우 간단하고 우아하며 변경 될 때마다 자동으로 새로 고침을 트리거하는 더 많은 관찰 가능한 쿼리 매개 변수를 추가하는 것이 쉽지만 잠재적 인 효율성 문제가 있습니다. pageIndex 및 pageSize를 모두 변경하는 다음 함수를 GridViewModel에 추가한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="9117d0ab32efbb0c3350f9f8bac13fc40074e4e2" translate="yes" xml:space="preserve">
          <source>This means that if giftWrap was defined with the initial state false (i.e., giftWrap: ko.observable(false)) then the associated DIV would initially be hidden, and then would slide into view when the user later checks the box.</source>
          <target state="translated">즉, giftWrap이 초기 상태 인 false로 정의 된 경우 (즉, giftWrap : ko.observable (false)) 연결된 DIV는 처음에 숨겨져 나중에 사용자가 확인란을 선택하면 화면에 미끄러 져 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="6a8c9ee94416efc36e3d0b09cb54b5b894dd20f1" translate="yes" xml:space="preserve">
          <source>This one is trickier. The expression itself, when evaluated, reads an observable. That observable&amp;rsquo;s value could change over time, so the expression result could change over time.</source>
          <target state="translated">이것은 까다 롭습니다. 표현식 자체는 평가할 때 관찰 가능 항목을 읽습니다. 이 관찰 가능 값은 시간이 지남에 따라 변경 될 수 있으므로 표현식 결과는 시간이 지남에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="764cca70bf6bc3478b2f5d9c5e14adb25a24ed61" translate="yes" xml:space="preserve">
          <source>This pattern is beneficial for large applications, because it &lt;strong&gt;simplifies development&lt;/strong&gt; through clear organization and encapsulation, and helps to &lt;strong&gt;improve runtime performance&lt;/strong&gt; by incrementally loading your application code and templates as needed.</source>
          <target state="translated">이 패턴은 명확한 구성 및 캡슐화를 통해 &lt;strong&gt;개발&lt;/strong&gt; 을 &lt;strong&gt;단순화&lt;/strong&gt; 하고 필요에 따라 응용 프로그램 코드 및 템플릿을 점차적으로로드하여 &lt;strong&gt;런타임 성능&lt;/strong&gt; 을 &lt;strong&gt;향상&lt;/strong&gt; 시키므로 대규모 응용 프로그램에 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="c49ec8a2f8904ae806b7933742cc5c46416eb94c" translate="yes" xml:space="preserve">
          <source>This phase always completes synchronously (constructors and factory functions are not allowed to be asynchronous), since it occurs &lt;em&gt;every time a component is instantiated&lt;/em&gt; and performance would be unacceptable if it involved waiting for network requests.</source>
          <target state="translated">이 단계 &lt;em&gt;는 구성 요소가 인스턴스화 될 때마다&lt;/em&gt; 발생 &lt;em&gt;하고&lt;/em&gt; 네트워크 요청 대기와 관련된 경우 성능을 수용 할 수 없으므로 항상 동 기적으로 완료됩니다 (생성자 및 팩토리 기능은 비동기식으로 허용되지 않음) .</target>
        </trans-unit>
        <trans-unit id="7cd17e2e83be7a02ac954b0879cc442249587320" translate="yes" xml:space="preserve">
          <source>This refers to the binding context object at the parent level. This is different from $parent, which refers to the &lt;em&gt;data&lt;/em&gt; (not binding context) at the parent level. This is useful, for example, if you need to access the index value of an outer foreach item from an inner context (usage: $parentContext.$index). This is undefined in the root context.</source>
          <target state="translated">이것은 부모 수준의 바인딩 컨텍스트 개체를 나타냅니다. 이것은 부모 수준 의 &lt;em&gt;데이터&lt;/em&gt; (바인딩 컨텍스트가 아님) 를 나타내는 $ parent와 다릅니다 . 예를 들어 내부 컨텍스트에서 외부 foreach 항목의 인덱스 값에 액세스해야하는 경우 유용합니다 (예 : $ parentContext. $ index). 이것은 루트 컨텍스트에서 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06c6933149d42721a432ae0308df0854c322572c" translate="yes" xml:space="preserve">
          <source>This refers to the current binding context object. This may be useful if you want to access properties of the context when they might also exist in the view model, or if you want to pass the context object to a helper function in your view model.</source>
          <target state="translated">이것은 현재 바인딩 컨텍스트 개체를 나타냅니다. 이는 뷰 모델에 존재할 수있는 컨텍스트의 속성에 액세스하려는 경우 또는 뷰 모델의 도우미 함수에 컨텍스트 개체를 전달하려는 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f387b998e8ac7a29ae76937857a5182d84c0d6a8" translate="yes" xml:space="preserve">
          <source>This returns a new computed value that provides a filtered view of the array, while leaving the original array unchanged. Because the filtered array is a computed observable, it will be re-evaluated whenever the underlying array changes.</source>
          <target state="translated">그러면 원래 배열은 변경하지 않고 배열의 필터링 된보기를 제공하는 새로운 계산 된 값이 반환됩니다. 필터링 된 배열은 계산 가능한 관찰 가능하므로 기본 배열이 변경 될 때마다 다시 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="e779749b0336c95080fa9bf6da2b3b0f50a52bf9" translate="yes" xml:space="preserve">
          <source>This should be a very unusual scenario, so normally you will not need to work with $raw.</source>
          <target state="translated">이것은 매우 이례적인 시나리오이므로 일반적으로 $ raw로 작업 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="01da6ff51ae4d2c3c90a4030485a45aed896a7b0" translate="yes" xml:space="preserve">
          <source>This should be an array (or an observable array). KO sets the element&amp;rsquo;s selected options to match the contents of the array. Any previous selection state will be overwritten.</source>
          <target state="translated">이것은 배열 (또는 관찰 가능한 배열)이어야합니다. KO는 요소의 선택된 옵션을 배열의 내용과 일치하도록 설정합니다. 이전의 모든 선택 상태를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="88bbbc0277944375aa46b38dfa45e9ab615c5899" translate="yes" xml:space="preserve">
          <source>This simple logChange extender subscribes to the observable and uses the console to write any changes along with a configurable message.</source>
          <target state="translated">이 간단한 logChange 익스텐더는 Observable에 가입하고 콘솔을 사용하여 구성 가능한 메시지와 함께 변경 사항을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="c93d03a0497f4b6a9cf5527ffc5543496c0874f0" translate="yes" xml:space="preserve">
          <source>This technique is also possible when using components &lt;em&gt;without&lt;/em&gt; custom elements, i.e., &lt;a href=&quot;component-binding#note-passing-markup-to-components&quot;&gt;passing markup when using the component binding directly&lt;/a&gt;.</source>
          <target state="translated">이 기술은 사용자 지정 요소 &lt;em&gt;없이&lt;/em&gt; 구성 요소 &lt;em&gt;를&lt;/em&gt; 사용할 때도 가능 합니다. 즉, &lt;a href=&quot;component-binding#note-passing-markup-to-components&quot;&gt;구성 요소 바인딩을 직접 사용할 때 마크 업을 전달합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="256c845485dd4d340fc02fc1d45ab4dd11c131f5" translate="yes" xml:space="preserve">
          <source>This updated withProperties binding could now be used in a nested way, with each level of nesting able to access the parent level via $parentContext:</source>
          <target state="translated">이 업데이트 된 withProperties 바인딩은 이제 중첩 방식으로 사용될 수 있으며 각 중첩 레벨은 $ parentContext를 통해 상위 레벨에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d002804da1ead8e6117a2574e37ec65f769d881" translate="yes" xml:space="preserve">
          <source>This uses the &lt;a href=&quot;https://github.com/substack/brfs&quot;&gt;brfs Browserify plugin&lt;/a&gt; to automatically inline the .html file, so you would need to build the script file using a command similar to:</source>
          <target state="translated">이것은 &lt;a href=&quot;https://github.com/substack/brfs&quot;&gt;brfs Browserify 플러그인&lt;/a&gt; 을 사용하여 .html 파일을 자동으로 인라인하므로 다음과 유사한 명령을 사용하여 스크립트 파일을 빌드해야합니다.</target>
        </trans-unit>
        <trans-unit id="e7012cd7733550a283d385731119658ec9bb44e4" translate="yes" xml:space="preserve">
          <source>This way, every time the mapping plugin checks an item in the children array, it will only look at the id property to determine if an object was completely replaced or merely needs updating.</source>
          <target state="translated">이런 식으로 매핑 플러그인이 자식 배열의 항목을 확인할 때마다 개체가 완전히 교체되었거나 업데이트가 필요한지 여부를 확인하기 위해 id 속성 만 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a8568ff1255174753fee15506ea5b939e7eba400" translate="yes" xml:space="preserve">
          <source>This will add the provided callback function to the microtask queue. Knockout includes a fast task queue that runs tasks in FIFO order until the queue is empty. When the first task is scheduled, Knockout will schedule a flush event using the &lt;a href=&quot;#implementation&quot;&gt;browser&amp;rsquo;s microtask&lt;/a&gt; support if possible. This ensures that the first task and subsequent tasks behave similarly.</source>
          <target state="translated">제공된 콜백 함수가 마이크로 태스크 큐에 추가됩니다. 녹아웃에는 대기열이 비워 질 때까지 FIFO 순서로 작업을 실행하는 빠른 작업 대기열이 포함됩니다. 첫 번째 작업이 예약되면 녹아웃은 가능한 경우 &lt;a href=&quot;#implementation&quot;&gt;브라우저의 마이크로 태스킹&lt;/a&gt; 지원을 사용하여 플러시 이벤트를 예약 합니다. 이렇게하면 첫 번째 작업과 후속 작업이 비슷하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="89fe8682d00eb2da96a5709d31b9029ffbcfc05d" translate="yes" xml:space="preserve">
          <source>This will alert Grahamfoo!.</source>
          <target state="translated">Grahamfoo!에 경고합니다.</target>
        </trans-unit>
        <trans-unit id="1e9d83f540d0f759264a50c1deaee9fadbc1b907" translate="yes" xml:space="preserve">
          <source>This will apply the CSS class profitPositive when the currentProfit value is positive, otherwise it will apply the profitWarning CSS class.</source>
          <target state="translated">currentProfit 값이 양수이면 CSS 클래스 profitPositive를 적용하고, 그렇지 않으면 profitWarning CSS 클래스를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="f87913830792a93e929c5041e49a1ac864f3534e" translate="yes" xml:space="preserve">
          <source>This will apply the CSS class profitWarning whenever the currentProfit value dips below zero, and remove that class whenever it goes above zero.</source>
          <target state="translated">currentProfit 값이 0 아래로 떨어질 때마다 CSS 클래스 profitWarning을 적용하고 0보다 커질 때마다 해당 클래스를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="18e90989c33e17d16d78799aa4ba01332cd092cc" translate="yes" xml:space="preserve">
          <source>This will be the &lt;a href=&quot;observables&quot;&gt;ko.observable&lt;/a&gt; instance declared on the parent viewmodel as myObservable. It is not a wrapper &amp;mdash; it&amp;rsquo;s the actual same instance as referenced by the parent. So if the child viewmodel writes to this observable, the parent viewmodel will receive that change.</source>
          <target state="translated">이렇게하면 될 것 &lt;a href=&quot;observables&quot;&gt;ko.observable&lt;/a&gt; myObservable로 부모 뷰 모델에 선언 된 인스턴스입니다. 랩퍼가 아닙니다. 부모가 참조한 실제 인스턴스와 동일합니다. 따라서 자식 뷰 모델이이 Observable에 쓰면 부모 뷰 모델이 그 변화를받습니다.</target>
        </trans-unit>
        <trans-unit id="2f67007f4b1a32d450aaea3739ae4efc22153a68" translate="yes" xml:space="preserve">
          <source>This will be the numeric value 2. It will not be an observable or computed value, since there are no observables involved.</source>
          <target state="translated">이것은 숫자 값 2입니다. 관찰 가능한 값이 없기 때문에 관찰 가능한 값 또는 계산 된 값이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1c5ede0dd1910b9dd5251dfa29559d2f0637ba62" translate="yes" xml:space="preserve">
          <source>This will create an unmapped object containing only the properties of the mapped object that were part of your original JS object. So in other words, any properties or functions that you manually added to your view model are ignored. By default, the only exception to this rule is the _destroy property which will also be mapped back, because it is a property that Knockout may generate when you destroy an item from an ko.observableArray. See the &amp;ldquo;Advanced Usage&amp;rdquo; section for more details on how to configure this.</source>
          <target state="translated">그러면 원래 JS 객체의 일부인 매핑 된 객체의 속성 만 포함 된 매핑되지 않은 객체가 생성됩니다. 즉, 뷰 모델에 수동으로 추가 한 모든 속성 또는 함수는 무시됩니다. 기본적으로이 규칙의 유일한 예외는 _destroy 속성입니다.이 속성은 ko.observableArray에서 항목을 제거 할 때 녹아웃이 생성 할 수있는 속성이기 때문에 다시 매핑됩니다. 이를 구성하는 방법에 대한 자세한 내용은&amp;ldquo;고급 사용&amp;rdquo;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9c3e13ac9f2224e44e42edef86d37eab2fe74fad" translate="yes" xml:space="preserve">
          <source>This will set the element&amp;rsquo;s href attribute to year-end.html and the element&amp;rsquo;s title attribute to Report including final year-end statistics.</source>
          <target state="translated">그러면 요소의 href 속성이 year-end.html로 설정되고 요소의 title 속성은 최종 연말 통계를 포함하여 Report로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b1010c547f79842589b0e311d7876305e18791c1" translate="yes" xml:space="preserve">
          <source>This will set the element&amp;rsquo;s style.color property to red whenever the currentProfit value dips below zero, and to black whenever it goes above zero.</source>
          <target state="translated">현재의 Profit 값이 0 아래로 떨어질 때마다 요소의 style.color 속성이 빨간색으로 설정되고 0 위에 올 때마다 검은 색으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="39c0ebf1e1a352368a835454316aec61a6b25f3d" translate="yes" xml:space="preserve">
          <source>This works because {{each...}} and ${ ... } are jQuery.tmpl syntaxes. What&amp;rsquo;s more, it&amp;rsquo;s trivial to nest templates: because you can use data-bind attributes from inside a template, you can simply put a data-bind=&quot;template: ...&quot; inside a template to render a nested one.</source>
          <target state="translated">{{each ...}} 및 $ {...}이 jQuery.tmpl 구문이기 때문에 작동합니다. 게다가 템플릿을 중첩하는 것은 쉽지 않습니다. 템플릿 내부에서 데이터 바인딩 속성을 사용할 수 있으므로 템플릿 내에 data-bind = &quot;template : ...&quot;을 넣어 중첩 된 템플릿을 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fdac77a92e4befc847d03ccedc3c0f29ee5e341" translate="yes" xml:space="preserve">
          <source>This works nicely with regular DOM elements. The following elements will be shuffled into a random order:</source>
          <target state="translated">이것은 일반적인 DOM 요소와 잘 작동합니다. 다음 요소는 임의 순서로 섞입니다.</target>
        </trans-unit>
        <trans-unit id="6cea06b68ab89e21eb2eb393da04144cdf69163b" translate="yes" xml:space="preserve">
          <source>Tip: Remember to pass a &lt;em&gt;string literal value&lt;/em&gt; to as (e.g., as: 'category', &lt;em&gt;not&lt;/em&gt; as: category), because you are giving a name for a new variable, not reading the value of a variable that already exists.</source>
          <target state="translated">팁 : &lt;em&gt;문자열 리터럴 값&lt;/em&gt; 을로 (예 : 범주가 &lt;em&gt;아닌&lt;/em&gt; 'category' 로) 전달해야합니다. 이미 존재하는 변수의 값을 읽지 않고 새 변수의 이름을 제공하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d8500f75dd4919cdb81ed364100516eb992fda0f" translate="yes" xml:space="preserve">
          <source>Tip: Remember to pass a &lt;em&gt;string literal value&lt;/em&gt; to as (e.g., as: 'season', &lt;em&gt;not&lt;/em&gt; as: season), because you are giving a name for a new variable, not reading the value of a variable that already exists.</source>
          <target state="translated">팁 : 이미 존재하는 변수의 값을 읽지 않고 새 변수의 이름을 지정하므로 &lt;em&gt;문자열 리터럴 값&lt;/em&gt; 을 as (예 : 'season', as &lt;em&gt;not&lt;/em&gt; : season)로 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="4e7109024dd6bcf80fd3c4071c74f0ccac474646" translate="yes" xml:space="preserve">
          <source>To &lt;strong&gt;read&lt;/strong&gt; the observable&amp;rsquo;s current value, just call the observable with no parameters. In this example, myViewModel.personName() will return 'Bob', and myViewModel.personAge() will return 123.</source>
          <target state="translated">Observable의 현재 값 을 &lt;strong&gt;읽으&lt;/strong&gt; 려면 매개 변수없이 Observable을 호출하십시오. 이 예에서 myViewModel.personName ()은 'Bob'을 반환하고 myViewModel.personAge ()는 123을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1603a0143d3999d60952c967221acb25e519b499" translate="yes" xml:space="preserve">
          <source>To &lt;strong&gt;write&lt;/strong&gt; a new value to the observable, call the observable and pass the new value as a parameter. For example, calling myViewModel.personName('Mary') will change the name value to 'Mary'.</source>
          <target state="translated">Observable에 새 값 을 &lt;strong&gt;쓰&lt;/strong&gt; 려면 Observable을 호출하고 새 값을 매개 변수로 전달하십시오. 예를 들어, myViewModel.personName ( 'Mary')을 호출하면 이름 값이 'Mary'로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="8c1dd52f53359b8999172932067a959e30b50bb9" translate="yes" xml:space="preserve">
          <source>To activate Knockout, add the following line to a &amp;lt;script&amp;gt; block:</source>
          <target state="translated">녹아웃을 활성화하려면 &amp;lt;script&amp;gt; 블록에 다음 줄을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4bedfacc43fa04424dc2037d1ad45179e728cf82" translate="yes" xml:space="preserve">
          <source>To attach a custom function, add it to one of the following extensibility points:</source>
          <target state="translated">사용자 정의 기능을 첨부하려면 다음 확장 성 포인트 중 하나에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="fc34fc8c1a8f61015e6ccf19b6048b726ab8b730" translate="yes" xml:space="preserve">
          <source>To check if a property is observable, computed, etc., use the following set of functions:</source>
          <target state="translated">속성이 관찰 가능하고 계산 등인지 확인하려면 다음 함수 집합을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a6ca1b4a2f54eff18a5d64c54c19bfbc24f36608" translate="yes" xml:space="preserve">
          <source>To create a view model via the mapping plugin, replace the creation of viewModel in the code above with the ko.mapping.fromJS function:</source>
          <target state="translated">맵핑 플러그인을 통해보기 모델을 작성하려면 위 코드에서 viewModel 작성을 ko.mapping.fromJS 함수로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="9bca32773ffd1de2e683926bbbc0399c4ce35c07" translate="yes" xml:space="preserve">
          <source>To create a view model with KO, just declare any JavaScript object. For example,</source>
          <target state="translated">KO로 뷰 모델을 만들려면 JavaScript 객체를 선언하면됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ed5b10cf91ed48dc2161202d3dbba9996462cd34" translate="yes" xml:space="preserve">
          <source>To do this, attach a preprocess function to the binding handler:</source>
          <target state="translated">이를 수행하려면 사전 처리 함수를 바인딩 핸들러에 첨부하십시오.</target>
        </trans-unit>
        <trans-unit id="b6f315d7429f0172c8d46409834c17cc33ad391f" translate="yes" xml:space="preserve">
          <source>To do this, define a preprocessNode function on your binding provider:</source>
          <target state="translated">이를 수행하려면 바인딩 제공자에서 preprocessNode 함수를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="8a2f9db2683d5e7dd55d32347c60ef3b9fd17aa7" translate="yes" xml:space="preserve">
          <source>To do this, simply return {controlsDescendantBindings:true} from your binding&amp;rsquo;s init function.</source>
          <target state="translated">이를 위해서는 바인딩의 init 함수에서 {controlsDescendantBindings : true}를 반환하면됩니다.</target>
        </trans-unit>
        <trans-unit id="0d02d6d0b98e8e4132512edf37abb131f03195b9" translate="yes" xml:space="preserve">
          <source>To ensure that the child component can react to changes in the expression value, Knockout &lt;strong&gt;automatically upgrades this parameter to a computed property&lt;/strong&gt;. So, the child component will be able to read params.observableExpression() to get the current value, or use params.observableExpression.subscribe(...), etc.</source>
          <target state="translated">하위 구성 요소가 표현식 값의 변경에 반응 할 수 있도록 Knockout &lt;strong&gt;은이 매개 변수를 계산 된 특성으로 자동 업그레이드합니다&lt;/strong&gt; . 따라서 자식 구성 요소는 params.observableExpression ()을 읽고 현재 값을 얻거나 params.observableExpression.subscribe (...) 등을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4a8d0a19e57da9771491cbbe8f1040202f3913f" translate="yes" xml:space="preserve">
          <source>To ensure that the subscribers are always notified of an update, even if the value is the same, you would use the notify extender:</source>
          <target state="translated">값이 동일한 경우에도 구독자에게 항상 업데이트 알림을 표시하려면 알림 익스텐더를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a230b2caaad8521494456ece11667c71eb8c9cab" translate="yes" xml:space="preserve">
          <source>To get started, here&amp;rsquo;s a custom binding that randomises the order of DOM nodes:</source>
          <target state="translated">시작하려면 DOM 노드의 순서를 무작위로 지정하는 사용자 정의 바인딩이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e12f7ef2adfbd28b0327ae040b9449ce8ae8c4a" translate="yes" xml:space="preserve">
          <source>To get started, you can register a component using ko.components.register (technically, registration is optional, but it&amp;rsquo;s the easiest way to get started). A component definition specifies a viewModel and template. For example:</source>
          <target state="translated">시작하려면 ko.components.register를 사용하여 구성 요소를 등록 할 수 있습니다 (기술적으로 등록은 선택 사항이지만 시작하는 가장 쉬운 방법입니다). 컴포넌트 정의는 viewModel 및 템플리트를 지정합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34c9f670f8df2e29349796ad5b0233f8c05eff2a" translate="yes" xml:space="preserve">
          <source>To handle this, you can use the &lt;em&gt;containerless control flow syntax&lt;/em&gt;, which is based on comment tags. For example,</source>
          <target state="translated">이를 처리하기 위해 주석 태그를 기반으로 하는 &lt;em&gt;컨테이너리스 제어 흐름 구문을&lt;/em&gt; 사용할 수 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="d18572193a45491f5f82b42ce11142e475501e50" translate="yes" xml:space="preserve">
          <source>To handle this, you can use the &lt;em&gt;containerless syntax&lt;/em&gt;, which is based on comment tags.</source>
          <target state="translated">이를 처리하기 위해 주석 태그를 기반으로 하는 &lt;em&gt;컨테이너리스 구문을&lt;/em&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="344aafcd8749ab67bed4212faedd867ef9944e6c" translate="yes" xml:space="preserve">
          <source>To implement a naming convention, your custom component loader only needs to implement getConfig. For example:</source>
          <target state="translated">이름 지정 규칙을 구현하려면 사용자 정의 컴포넌트 로더가 getConfig 만 구현하면됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1e3b53d1cbf555a90afd50c492b3f2aa86042a55" translate="yes" xml:space="preserve">
          <source>To make it easy to serialize view model data, including observables and the like, Knockout includes two helper functions:</source>
          <target state="translated">관측 값 등을 포함하여 뷰 모델 데이터를 쉽게 직렬화 할 수 있도록 Knockout에는 다음과 같은 두 가지 도우미 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a16e4b410b776f2eb11f1b98050f24b8ce7df16f" translate="yes" xml:space="preserve">
          <source>To register a binding, add it as a subproperty of ko.bindingHandlers:</source>
          <target state="translated">바인딩을 등록하려면 ko.bindingHandlers의 하위 속성으로 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="9a050d6aedfdbef27779228a105257ebafded91d" translate="yes" xml:space="preserve">
          <source>To register a function to run when a node is removed, you can call ko.utils.domNodeDisposal.addDisposeCallback(node, callback). As an example, suppose you create a custom binding to instantiate a widget. When the element with the binding is removed, you may want to call the destroy method of the widget:</source>
          <target state="translated">노드가 제거 될 때 실행할 함수를 등록하려면 ko.utils.domNodeDisposal.addDisposeCallback (node, callback)을 호출하면됩니다. 예를 들어, 위젯을 인스턴스화하기 위해 사용자 정의 바인딩을 작성한다고 가정하십시오. 바인딩이있는 요소가 제거되면 위젯의 destroy 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="628e530a0cb918fd2a0dc463a561ba3eb6ded4c1" translate="yes" xml:space="preserve">
          <source>To register any event handlers so that, for example, when the user clicks on or modifies the DOM element, you can change the state of the associated observable</source>
          <target state="translated">예를 들어 사용자가 DOM 요소를 클릭하거나 수정하는 경우 이벤트 처리기를 등록하려면 연결된 관찰 가능 상태를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e971fd083a8eb6c18b73f34e2fcf3c1be214c7ef" translate="yes" xml:space="preserve">
          <source>To see how you can bind the observableArray to a UI and let the user modify it, see &lt;a href=&quot;http://knockoutjs.com/examples/simpleList.html&quot;&gt;the simple list example&lt;/a&gt;.</source>
          <target state="translated">observableArray를 UI에 바인딩하고 사용자가이를 수정하도록하는 방법을 보려면 &lt;a href=&quot;http://knockoutjs.com/examples/simpleList.html&quot;&gt;간단한 목록 예제를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="095a567dfb57127d79567d4bc52abc97f60ac311" translate="yes" xml:space="preserve">
          <source>To see this take effect, here&amp;rsquo;s a sample usage:</source>
          <target state="translated">이것이 적용되는 것을보기 위해 다음은 샘플 사용법입니다.</target>
        </trans-unit>
        <trans-unit id="3ae1228ed42dd51e2a79a4933915655e8327da14" translate="yes" xml:space="preserve">
          <source>To set any initial state for the DOM element</source>
          <target state="translated">DOM 요소의 초기 상태를 설정하려면</target>
        </trans-unit>
        <trans-unit id="9f816fffe2f0c1ef4a2672aecdb14944095d7a12" translate="yes" xml:space="preserve">
          <source>To solve this, you can specify which key the mapping plugin should use to determine if an object is new or old. You would set it up like this:</source>
          <target state="translated">이를 해결하기 위해 오브젝트가 새 것인지 오래된 것인지를 판별하기 위해 맵핑 플러그인이 사용해야하는 키를 지정할 수 있습니다. 다음과 같이 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d875d374a5b560ee2a9072eedb09b31f34d14b2b" translate="yes" xml:space="preserve">
          <source>To summarise: KO doesn&amp;rsquo;t compete with jQuery or similar low-level DOM APIs. KO provides a complementary, high-level way to link a data model to a UI. KO itself doesn&amp;rsquo;t depend on jQuery, but you can certainly use jQuery at the same time, and indeed that&amp;rsquo;s often useful if you want things like animated transitions.</source>
          <target state="translated">요약하자면 KO는 jQuery 또는 유사한 저수준 DOM API와 경쟁하지 않습니다. KO는 데이터 모델을 UI에 연결하는 보완적인 고급 방법을 제공합니다. KO 자체는 jQuery에 의존하지 않지만 확실히 jQuery를 동시에 사용할 수 있으며 애니메이션 전환과 같은 것을 원할 때 종종 유용합니다.</target>
        </trans-unit>
        <trans-unit id="64c8953197898f78eeca558500a49ab49daef233" translate="yes" xml:space="preserve">
          <source>To supply a configuration, call callback(componentConfig), where componentConfig is any object that can be understood by the loadComponent function on your loader or any other loader. The default loader simply supplies whatever object was registered using ko.components.register.</source>
          <target state="translated">구성을 제공하려면 callback (componentConfig)를 호출하십시오. 여기서 componentConfig는 로더 또는 다른 로더의 loadComponent 함수가 이해할 수있는 객체입니다. 기본 로더는 ko.components.register를 사용하여 등록 된 객체를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="19095264c8ed4472bafe7730a63b6cf4ef5c336b" translate="yes" xml:space="preserve">
          <source>To supply a createViewModel function, call callback(yourCreateViewModelFunction). The createViewModel function must accept parameters (params, componentInfo) and must synchronously return a new viewmodel instance each time it is called.</source>
          <target state="translated">createViewModel 함수를 제공하려면 callback (yourCreateViewModelFunction)을 호출하십시오. createViewModel 함수는 매개 변수 (params, componentInfo)를 승인해야하며 호출 될 때마다 새 viewmodel 인스턴스를 동 기적으로 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b5f93798c8c651e942c21326f558b5aa4d8d7c6" translate="yes" xml:space="preserve">
          <source>To supply a viewmodel/template pair, call callback(result), where result is an object with the following properties:</source>
          <target state="translated">뷰 모델 / 템플릿 쌍을 제공하려면 callback (result)를 호출하십시오. 여기서 result는 다음 속성을 가진 객체입니다.</target>
        </trans-unit>
        <trans-unit id="4ead5da5921414482244d25f573f52e9a5b955e8" translate="yes" xml:space="preserve">
          <source>To supply an array of DOM nodes, call callback(domNodeArray).</source>
          <target state="translated">DOM 노드의 배열을 제공하려면 callback (domNodeArray)를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="1724664ad5c98bc91fe046f856ef3cda6f3d6e51" translate="yes" xml:space="preserve">
          <source>To supply parameters to the component, pass an object with the following properties:</source>
          <target state="translated">컴포넌트에 매개 변수를 제공하려면 다음 특성을 가진 오브젝트를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="478bbd64e518e9b998ff4a6cab53605b1ae49ad6" translate="yes" xml:space="preserve">
          <source>To write values to &lt;strong&gt;multiple observable properties&lt;/strong&gt; on a model object, you can use &lt;em&gt;chaining syntax&lt;/em&gt;. For example, myViewModel.personName('Mary').personAge(50) will change the name value to 'Mary' &lt;em&gt;and&lt;/em&gt; the age value to 50.</source>
          <target state="translated">모델 객체의 &lt;strong&gt;여러 관측 가능 속성&lt;/strong&gt; 에 값을 쓰려면 &lt;em&gt;연결 구문을&lt;/em&gt; 사용할 수 있습니다 . 예를 들어, myViewModel.personName ( 'Mary'). personAge (50)은 이름 값을 'Mary' &lt;em&gt;로&lt;/em&gt; , 나이 값을 50으로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="3a5865922af306bd8ae540e6e29d90f3c0fc25a0" translate="yes" xml:space="preserve">
          <source>Triggering UI-level validation using a library such as &lt;a href=&quot;https://github.com/jzaefferer/jquery-validation&quot;&gt;jQuery Validation&lt;/a&gt;, using code similar to the following snippet: if ($(formElement).valid()) { /* do something */ }.</source>
          <target state="translated">다음 스 니펫과 유사한 코드를 사용하여 &lt;a href=&quot;https://github.com/jzaefferer/jquery-validation&quot;&gt;jQuery Validation&lt;/a&gt; 과 같은 라이브러리를 사용하여 UI 레벨 유효성 검증 트리거 : if ($ (formElement) .valid ()) {/ * * *}.</target>
        </trans-unit>
        <trans-unit id="0969eb5b711519c18e0b6f0a6871c28056b8ba40" translate="yes" xml:space="preserve">
          <source>Try it out:</source>
          <target state="translated">사용해보십시오 :</target>
        </trans-unit>
        <trans-unit id="4d46d56fedff8d9d8e85c637f94cca6486220b3d" translate="yes" xml:space="preserve">
          <source>Try it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf9d5be1a5edee29dc70627d1391050d53eaeb0" translate="yes" xml:space="preserve">
          <source>Two points to note about this example:</source>
          <target state="translated">이 예에서 두 가지 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="9142247f90c4a68927ee8f397af8554e56a791cf" translate="yes" xml:space="preserve">
          <source>Two things have happened here: name was changed from Scot to Scott and children[0].name was changed from Alicw to the typo-free Alice. You can update viewModel based on this new data:</source>
          <target state="translated">두 가지 일이 일어났다 : 이름이 스코틀랜드에서 스콧으로 바뀌었고 아이들 [0]. 이름이 알리 크에서 오타가없는 앨리스로 바뀌었다. 이 새로운 데이터를 기반으로 viewModel을 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ec6595c029c891202be0000bd3de833e1a37085" translate="yes" xml:space="preserve">
          <source>Typically this is useful when values in your view model are actually strings of HTML markup that you want to render.</source>
          <target state="translated">일반적으로 이는 뷰 모델의 값이 실제로 렌더링하려는 HTML 마크 업 문자열 인 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c44eb7cfce780337ba99afe9286699b6ff8a45d7" translate="yes" xml:space="preserve">
          <source>Typically this is useful with elements like &amp;lt;span&amp;gt; or &amp;lt;em&amp;gt; that traditionally display text, but technically you can use it with any element.</source>
          <target state="translated">일반적으로 이것은 전통적으로 텍스트를 표시하는 &amp;lt;span&amp;gt; 또는 &amp;lt;em&amp;gt;과 같은 요소에 유용하지만 기술적으로는 모든 요소와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe23c3213b817a535e503650eb3aed5e4ffa688e" translate="yes" xml:space="preserve">
          <source>Typically you&amp;rsquo;d only want to use optionsValue as a way of ensuring that KO can correctly retain selection when you update the set of available options. For example, if you&amp;rsquo;re repeatedly getting a list of &amp;ldquo;car&amp;rdquo; objects via Ajax calls and want to ensure that the selected car is preserved, you might need to set optionsValue to &quot;carId&quot; or whatever unique identifier each &amp;ldquo;car&amp;rdquo; object has, otherwise KO won&amp;rsquo;t necessarily know which of the previous &amp;ldquo;car&amp;rdquo; objects corresponds to which of the new ones.</source>
          <target state="translated">일반적으로 사용 가능한 옵션 세트를 업데이트 할 때 KO가 선택을 올바르게 유지할 수 있도록 optionsValue 만 사용하려고합니다. 예를 들어, Ajax 호출을 통해 &quot;car&quot;객체 목록을 반복해서 받고 선택한 자동차가 유지되도록하려면 optionsValue를 &quot;carId&quot;또는 각 &quot;car&quot;객체에 고유 한 식별자로 설정해야합니다. 그렇지 않으면 KO는 이전의 &quot;차&quot;객체 중 어떤 것이 새로운 객체에 해당하는지 반드시 알 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="48d4528c74c77bb144c5416d7e9ba854d62bff55" translate="yes" xml:space="preserve">
          <source>Uniquely identifying objects using &amp;ldquo;keys&amp;rdquo;</source>
          <target state="translated">&quot;키&quot;를 사용하여 객체를 고유하게 식별</target>
        </trans-unit>
        <trans-unit id="035deff1cdf7cc31acdb9702441a6e450f6d339e" translate="yes" xml:space="preserve">
          <source>Unlike some more traditional programming languages however, the current iteration of JavaScript (ECMA-262) doesn&amp;rsquo;t provide developers with the means to import such modules of code in a clean, organized manner. It&amp;rsquo;s one of the concerns with specifications that haven&amp;rsquo;t required great thought until more recent years where the need for more organized JavaScript applications became apparent.</source>
          <target state="translated">그러나 일부 기존 프로그래밍 언어와 달리 현재 JavaScript 반복 (ECMA-262)은 개발자에게 이러한 코드 모듈을 깔끔하고 체계적인 방식으로 가져올 수있는 수단을 제공하지 않습니다. 보다 체계적인 JavaScript 응용 프로그램의 필요성이 명백해진 최근 몇 년 전까지는 좋은 생각이 필요없는 사양에 대한 우려 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="28ef317e90976436c53e6fd9743c3a6007ec616a" translate="yes" xml:space="preserve">
          <source>Unmapping</source>
          <target state="translated">Unmapping</target>
        </trans-unit>
        <trans-unit id="00b5fe370c80c9fd15a6c4aaf4ed7a457fabe3fe" translate="yes" xml:space="preserve">
          <source>Updating View Model Data using JSON</source>
          <target state="translated">JSON을 사용하여 뷰 모델 데이터 업데이트</target>
        </trans-unit>
        <trans-unit id="882404f2cec0fb17f2287042b3e7158d2e826690" translate="yes" xml:space="preserve">
          <source>Use clearInterval(handle) to stop them, otherwise your viewmodel might be held in memory.</source>
          <target state="translated">clearInterval (handle)을 사용하여 중지하십시오. 그렇지 않으면 뷰 모델이 메모리에 유지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f18b7da089633a2ca0b4636635f86dba16e5da93" translate="yes" xml:space="preserve">
          <source>Using a computed observable</source>
          <target state="translated">계산 된 관찰 가능 객체 사용</target>
        </trans-unit>
        <trans-unit id="acf1fb7bc54bfd69e0f891d41bdd8354fa0c478f" translate="yes" xml:space="preserve">
          <source>Using a computed observable to run a callback based on multiple observables.</source>
          <target state="translated">계산 된 옵저버 블을 사용하여 여러 옵저버 블을 기반으로 콜백을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="c2a6531054ec097e5ed70a832394e057ca205e4a" translate="yes" xml:space="preserve">
          <source>Using custom elements</source>
          <target state="translated">맞춤 요소 사용</target>
        </trans-unit>
        <trans-unit id="7461986ee1f28f48b4bff59743d52212ae099805" translate="yes" xml:space="preserve">
          <source>Using deferred updates ensures that computed observables and bindings are updated only after their dependencies are stable. Even if an observable might go through multiple intermediate values, only the latest value is used to update its dependencies. To facilitate this, all notifications become asynchronous, scheduled using the &lt;a href=&quot;microtasks&quot;&gt;Knockout microtask queue&lt;/a&gt;. This may sound very similar to &lt;a href=&quot;ratelimit-observable&quot;&gt;rate-limiting&lt;/a&gt;, which also helps prevent extra notifications, but deferred updates can provide these benefits across an entire application without adding delays. Here&amp;rsquo;s how notification scheduling differs between the standard, deferred, and rate-limited modes:</source>
          <target state="translated">지연된 업데이트를 사용하면 계산 된 관찰 가능 항목과 바인딩이 종속성이 안정적인 후에 만 ​​업데이트됩니다. Observable이 여러 중간 값을 통과하더라도 최신 값만 사용하여 종속성을 업데이트합니다. 이를 용이하게하기 위해 모든 알림은 &lt;a href=&quot;microtasks&quot;&gt;Knockout 마이크로 태스크 대기열을&lt;/a&gt; 사용하여 스케줄되고 비 동기화 됩니다 . &lt;a href=&quot;ratelimit-observable&quot;&gt;속도 제한&lt;/a&gt; 과 매우 비슷하게 들리므로 추가 알림을 방지 할 수 있지만 지연된 업데이트는 지연없이 전체 응용 프로그램에서 이러한 이점을 제공 할 수 있습니다. 표준, 지연 및 속도 제한 모드에서 알림 일정이 어떻게 다른지 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d22dae89d982b72d6b6d2ac79e0ca3abf367c0e3" translate="yes" xml:space="preserve">
          <source>Using deferred updates for specific observables</source>
          <target state="translated">특정 관찰 가능 항목에 대해 지연된 업데이트 사용</target>
        </trans-unit>
        <trans-unit id="82500147d6fe068e5f3eac3c33aa845f26a5b095" translate="yes" xml:space="preserve">
          <source>Using extenders to augment observables</source>
          <target state="translated">익스텐더를 사용하여 관찰 가능 기능 보강</target>
        </trans-unit>
        <trans-unit id="50d3aa10da781d57d5fb5f9b37232d95022250cb" translate="yes" xml:space="preserve">
          <source>Using the component binding</source>
          <target state="translated">컴포넌트 바인딩 사용</target>
        </trans-unit>
        <trans-unit id="4fdbe03b68d1b5f0b1e0b8df84af814851a7626f" translate="yes" xml:space="preserve">
          <source>Using the computed context</source>
          <target state="translated">계산 된 컨텍스트 사용</target>
        </trans-unit>
        <trans-unit id="36cfba518908dc7ac80815a581dbac4dbfe3d45f" translate="yes" xml:space="preserve">
          <source>Using unobtrusive event handlers</source>
          <target state="translated">눈에 거슬리지 않는 이벤트 핸들러 사용</target>
        </trans-unit>
        <trans-unit id="2a98028d793eefede53201a64728cbb7a99bc8be" translate="yes" xml:space="preserve">
          <source>Using valueAllowUnset with &amp;lt;select&amp;gt; elements</source>
          <target state="translated">&amp;lt;select&amp;gt; 요소와 함께 valueAllowUnset 사용</target>
        </trans-unit>
        <trans-unit id="a2fccbf4307cd999a23c6d6d0c8c15cd45251e9e" translate="yes" xml:space="preserve">
          <source>Viewmodels can be specified in any of the following forms:</source>
          <target state="translated">뷰 모델은 다음 형식 중 하나로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67410bb1c50d4c83c27173e0489e96f063272dc6" translate="yes" xml:space="preserve">
          <source>Virtual Element APIs</source>
          <target state="translated">가상 요소 API</target>
        </trans-unit>
        <trans-unit id="e406729e158e24dd87b8e698dcec51dd531fa16b" translate="yes" xml:space="preserve">
          <source>Virtual elements</source>
          <target state="translated">가상 요소</target>
        </trans-unit>
        <trans-unit id="350a4fbd76ca00bce2ade90d8477e5ed8a1a52e4" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve borrowed the term from &lt;a href=&quot;http://en.wikipedia.org/wiki/Pure_function&quot;&gt;pure functions&lt;/a&gt; because this feature is generally only applicable for computed observables whose evaluator is a &lt;em&gt;pure function&lt;/em&gt; as follows:</source>
          <target state="translated">이 기능은 일반적으로 평가자가 다음과 같은 &lt;em&gt;순수 함수&lt;/em&gt; 인 계산 된 관측 가능 항목에만 적용 가능하기 때문에 &lt;a href=&quot;http://en.wikipedia.org/wiki/Pure_function&quot;&gt;순수 함수&lt;/a&gt; 에서 용어를 빌 렸습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="35a6b726c72e0d5b8bef238a8458f1acc64e5a41" translate="yes" xml:space="preserve">
          <source>What if you&amp;rsquo;ve got an &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; for firstName, and another for lastName, and you want to display the full name? That&amp;rsquo;s where &lt;em&gt;computed observables&lt;/em&gt; come in - these are functions that are dependent on one or more other observables, and will automatically update whenever any of these dependencies change.</source>
          <target state="translated">firstName에 대한 &lt;a href=&quot;observables&quot;&gt;관찰 가능 항목&lt;/a&gt; 과 lastName에 대한 관찰 가능 항목 이 있고 전체 이름을 표시하려면 어떻게해야합니까? &lt;em&gt;계산 된 옵저버 블이&lt;/em&gt; 들어오는 곳입니다. 이들은 하나 이상의 다른 옵저버 블에 의존하는 함수이며 이러한 종속성이 변경 될 때마다 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="d0955f26cb60a2b7c19f0ff4510ffa1f1f8a847e" translate="yes" xml:space="preserve">
          <source>What tends to be most useful in practice is creating AMD modules that have inline viewmodel classes, and explicitly take AMD dependencies on external template files.</source>
          <target state="translated">실제로 가장 유용한 경향은 인라인 뷰 모델 클래스가있는 AMD 모듈을 생성하고 외부 템플릿 파일에 대한 AMD 의존성을 명시 적으로 취하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d0746929aa2438a6c079c324161ceff7bcbb2cda" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;not&lt;/em&gt; to use a &lt;em&gt;pure&lt;/em&gt; computed observable</source>
          <target state="translated">때 &lt;em&gt;하지&lt;/em&gt; 사용하는 &lt;em&gt;순수&lt;/em&gt; 계산 관찰을</target>
        </trans-unit>
        <trans-unit id="e688d2a76e0cc347828e115ec7ca0f7f8f898a8d" translate="yes" xml:space="preserve">
          <source>When a component binding injects a component,</source>
          <target state="translated">구성 요소 바인딩이 구성 요소를 주입하면</target>
        </trans-unit>
        <trans-unit id="49718b2901f95c68a1922d6b2983c5beec56f4c3" translate="yes" xml:space="preserve">
          <source>When a computed observable returns a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in notify &lt;a href=&quot;extenders&quot;&gt;extender&lt;/a&gt; to ensure that a computed observable&amp;rsquo;s subscribers are always notified on an update, even if the value is the same. You would apply the extender like this:</source>
          <target state="translated">계산 된 Observable이 기본 값 (숫자, 문자열, 부울 또는 널)을 리턴 할 때, Observable의 종속성은 일반적으로 값이 실제로 변경된 경우에만 통지됩니다. 그러나 내장 된 알림 &lt;a href=&quot;extenders&quot;&gt;익스텐더&lt;/a&gt; 를 사용하여 값이 동일한 경우에도 계산 된 관찰 가능 가입자에게 항상 업데이트 알림을 제공 할 수 있습니다. 다음과 같이 익스텐더를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="e830112947080dad24b739108f8a4da674f8a04f" translate="yes" xml:space="preserve">
          <source>When applied to a computed observable, the deferred extender will also avoid excess evaluation of the computed function. Using deferred updates ensures that any sequence of changes to dependencies in the current task will trigger just &lt;em&gt;one&lt;/em&gt; re-evaluation of the computed observable. For example:</source>
          <target state="translated">계산 된 옵저버 블에 적용되면 지연된 익스텐더는 계산 된 함수의 과도한 평가도 피할 수 있습니다. 지연된 업데이트를 사용하면 현재 작업의 종속성에 대한 일련의 변경 사항 이 계산 된 관찰 가능 항목을 &lt;em&gt;한&lt;/em&gt; 번만 다시 평가하게됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="240548473b5b8fba3f48d06580b1747a636e1733" translate="yes" xml:space="preserve">
          <source>When calling your handler, Knockout will supply the current model value as the first parameter. This is particularly useful if you&amp;rsquo;re rendering some UI for each item in a collection, and you need to know which item the event refers to. For example,</source>
          <target state="translated">핸들러를 호출하면 Knockout은 현재 모델 값을 첫 번째 매개 변수로 제공합니다. 컬렉션의 각 항목에 대해 일부 UI를 렌더링하고 이벤트가 참조하는 항목을 알아야하는 경우에 특히 유용합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="69391a30effde287dee34eb73d855395d87ce5a9" translate="yes" xml:space="preserve">
          <source>When calling your handler, Knockout will supply the current model value as the first parameter. This is particularly useful if you&amp;rsquo;re rendering some UI for each item in a collection, and you need to know which item&amp;rsquo;s UI was clicked. For example,</source>
          <target state="translated">핸들러를 호출하면 Knockout은 현재 모델 값을 첫 번째 매개 변수로 제공합니다. 컬렉션의 각 항목에 대해 일부 UI를 렌더링하고 어떤 항목의 UI를 클릭했는지 알아야하는 경우에 특히 유용합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="fbadbc1c18a2eb0a89cdf0f66ab67f3c68470882" translate="yes" xml:space="preserve">
          <source>When converting your view model back to a JS object, by default the mapping plugin will create observables based on the rules explained &lt;a href=&quot;#how-things-are-mapped&quot;&gt;above&lt;/a&gt;. If you want to force the mapping plugin to simply copy the property instead of making it observable, add its name to the &amp;ldquo;copy&amp;rdquo; array:</source>
          <target state="translated">뷰 모델을 JS 객체로 다시 변환 할 때 기본적으로 매핑 플러그인은 &lt;a href=&quot;#how-things-are-mapped&quot;&gt;위에서&lt;/a&gt; 설명한 규칙에 따라 관찰 가능 항목을 만듭니다 . 매핑 플러그인이 속성을 관찰 가능하게 만드는 대신 단순히 복사하도록하려면 &quot;복사&quot;배열에 해당 이름을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="34bc7212872348445dd0f0e3cd8734701a523ffe" translate="yes" xml:space="preserve">
          <source>When converting your view model back to a JS object, by default the mapping plugin will only include properties that were part of your original view model, except it will also include the Knockout-generated _destroy property even if it was not part of your original object. However, you can choose to customize this array:</source>
          <target state="translated">뷰 모델을 JS 객체로 다시 변환 할 때 기본적으로 매핑 플러그인은 원래 객체의 일부가 아니더라도 녹아웃에서 생성 된 _destroy 속성도 포함한다는 점을 제외하고는 원래 뷰 모델의 일부인 속성 만 포함합니다. . 그러나이 배열을 사용자 정의하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d17cbd8252177d3eecb0c97f654d8e466d16f693" translate="yes" xml:space="preserve">
          <source>When nesting foreach templates, it&amp;rsquo;s often useful to refer to items at higher levels in the hierarchy. One way to do this is to refer to $parent or other &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; variables in your bindings.</source>
          <target state="translated">각 템플릿을 중첩 할 때 계층 구조에서 더 높은 수준의 항목을 참조하는 것이 유용한 경우가 많습니다. 이를 수행하는 한 가지 방법은 &lt;a href=&quot;binding-context&quot;&gt;바인딩에서&lt;/a&gt; $ parent 또는 다른 바인딩 컨텍스트 변수 를 참조하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0447c91d2a396145a22645b117ae8a779d972c73" translate="yes" xml:space="preserve">
          <source>When presenting the user with a list of selectable items, it is often useful to include a method to select or deselect all of the items. This can be represented quite intuitively with a boolean value that represents whether all items are selected. When set to true it will select all items, and when set to false it will deselect them.</source>
          <target state="translated">사용자에게 선택 가능한 항목 목록을 제시 할 때 모든 항목을 선택하거나 선택 해제하는 방법을 포함시키는 것이 종종 유용합니다. 모든 항목의 선택 여부를 나타내는 부울 값으로 직관적으로 표현할 수 있습니다. true로 설정하면 모든 항목이 선택되고 false로 설정되면 선택이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="fa06a171ee457055a05faa668013d2f40356d7d1" translate="yes" xml:space="preserve">
          <source>When removing an element, Knockout runs logic to clean up any data associated with the element. As part of this logic, Knockout calls jQuery&amp;rsquo;s cleanData method if jQuery is loaded in your page. In advanced scenarios, you may want to prevent or customize how this data is removed in your application. Knockout exposes a function, ko.utils.domNodeDisposal.cleanExternalData(node), that can be overridden to support custom logic. For example, to prevent cleanData from being called, an empty function could be used to replace the standard cleanExternalData implementation:</source>
          <target state="translated">When removing an element, Knockout runs logic to clean up any data associated with the element. As part of this logic, Knockout calls jQuery&amp;rsquo;s cleanData method if jQuery is loaded in your page. In advanced scenarios, you may want to prevent or customize how this data is removed in your application. Knockout exposes a function, ko.utils.domNodeDisposal.cleanExternalData(node), that can be overridden to support custom logic. For example, to prevent cleanData from being called, an empty function could be used to replace the standard cleanExternalData implementation:</target>
        </trans-unit>
        <trans-unit id="0d673da0804e0a4a38175c4dafe9330c0b8fbb10" translate="yes" xml:space="preserve">
          <source>When the computed observable is only used in your UI</source>
          <target state="translated">계산 된 옵저버 블이 UI에서만 사용되는 경우</target>
        </trans-unit>
        <trans-unit id="db6fb44d7f7d1f10f432541accee58dc638af22b" translate="yes" xml:space="preserve">
          <source>When the default loader&amp;rsquo;s loadComponent runs, it simultaneously:</source>
          <target state="translated">기본 로더의 loadComponent가 실행될 때 동시에 :</target>
        </trans-unit>
        <trans-unit id="1aa25dca397cfdaf6f58c0b5c990ffd248e032ba" translate="yes" xml:space="preserve">
          <source>When the deferUpdates option is on, all observables, computed observables, and bindings will be set to use deferred updates and notifications. Enabling this feature at the start of creating a Knockout-based application means you do not need to worry about working around the intermediate-value problem, and so can facilitate a cleaner, purely reactive design. But you should take care when enabling deferred updates for an existing application because it will break code that depends on synchronous updates or on notification of intermediate values (although you may be able to &lt;a href=&quot;#forcing-deferred-notifications-to-happen-early&quot;&gt;work around these issues&lt;/a&gt;).</source>
          <target state="translated">deferUpdates 옵션이 켜져 있으면 모든 관찰 가능 항목, 계산 된 관찰 가능 항목 및 바인딩이 지연된 업데이트 및 알림을 사용하도록 설정됩니다. Knockout 기반 응용 프로그램을 시작할 때이 기능을 활성화하면 중간 값 문제를 해결하는 데 대해 걱정할 필요가 없으므로보다 깨끗하고 반응성이 뛰어난 디자인이 가능합니다. 그러나 기존 응용 프로그램에 대해 지연된 업데이트를 활성화 할 때는 동기 업데이트 나 중간 값 알림에 의존하는 코드가 손상되므로 &lt;a href=&quot;#forcing-deferred-notifications-to-happen-early&quot;&gt;이러한 문제를 해결할&lt;/a&gt; 수는 있지만주의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="14350d5d7b6cb62c7f2e96ed3335bddec0681969" translate="yes" xml:space="preserve">
          <source>When the first task is scheduled (initially and after a previous flush event has finished), Knockout will schedule a flush event to process the microtask queue. If possible, it will try to use the browsers&amp;rsquo;s own microtask capabilities. In modern browsers, it will use a &lt;a href=&quot;http://dom.spec.whatwg.org/#mutation-observers&quot;&gt;DOM mutation observer&lt;/a&gt;, and in older versions of Internet Explorer, it will use a &amp;lt;script&amp;gt; onreadystatechange event. These methods allow it to start processing the queue before any reflow or redrawing. In other browsers, it will revert to using setTimeout.</source>
          <target state="translated">첫 번째 작업이 예약되면 (초기 및 이전 플러시 이벤트가 완료된 후) 녹아웃은 마이크로 태스크 대기열을 처리하기 위해 플러시 이벤트를 예약합니다. 가능하면 브라우저 자체의 마이크로 태스킹 기능을 사용하려고 시도합니다. 최신 브라우저에서는 &lt;a href=&quot;http://dom.spec.whatwg.org/#mutation-observers&quot;&gt;DOM 돌연변이 관찰자를&lt;/a&gt; 사용하고 이전 버전의 Internet Explorer에서는 &amp;lt;script&amp;gt; onreadystatechange 이벤트를 사용합니다. 이 메소드를 사용하면 리플 로우 또는 다시 그리기 전에 큐 처리를 시작할 수 있습니다. 다른 브라우저에서는 setTimeout 사용으로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="b4c02d5563dd9c10af0804c769590634547b5a72" translate="yes" xml:space="preserve">
          <source>When the options binding changes the set of options in your &amp;lt;select&amp;gt; element, KO will leave the user&amp;rsquo;s selection unchanged where possible. So, for a single-select drop-down list, the previously selected option value will still be selected, and for a multi-select list, all the previously selected option values will still be selected (unless, of course, you&amp;rsquo;ve removed one or more of those options).</source>
          <target state="translated">옵션 바인딩이 &amp;lt;select&amp;gt; 요소의 옵션 세트를 변경하면 KO는 가능한 경우 사용자 선택을 변경하지 않고 그대로 둡니다. 따라서 단일 선택 드롭 다운 목록의 경우 이전에 선택한 옵션 값이 계속 선택되고 다중 선택 목록의 경우 이전에 선택한 모든 옵션 값이 계속 선택됩니다 (물론, 제거하지 않은 경우) 해당 옵션 중 하나 이상).</target>
        </trans-unit>
        <trans-unit id="d3b21cd263e89b964e6c3850344e09506b5dcfe3" translate="yes" xml:space="preserve">
          <source>When the parameter resolves to a &lt;strong&gt;false-like value&lt;/strong&gt; (e.g., the boolean value false, or the numeric value 0, or null, or undefined), the binding sets yourElement.style.display to none, causing it to be hidden. This takes priority over any display style you&amp;rsquo;ve defined using CSS.</source>
          <target state="translated">매개 변수가 &lt;strong&gt;false와 같은 값&lt;/strong&gt; (예 : 부울 값 false 또는 숫자 값 0 또는 널 (null) 또는 정의되지 않음)으로 해석되면 바인딩은 yourElement.style.display를 none으로 설정하여 숨겨지게합니다. CSS를 사용하여 정의한 표시 스타일보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="424933b4a587b12800d5037b620d089e1310bebf" translate="yes" xml:space="preserve">
          <source>When the parameter resolves to a &lt;strong&gt;true-like value&lt;/strong&gt; (e.g., the boolean value true, or a non-null object or array), the binding removes the yourElement.style.display value, causing it to become visible.</source>
          <target state="translated">매개 변수가 &lt;strong&gt;실제와 같은 값&lt;/strong&gt; (예 : 부울 값 true 또는 널이 아닌 오브젝트 또는 배열)로 해석되면 바인딩은 yourElement.style.display 값을 제거하여 표시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="f5648040a47d72bcccb395b1f9a5a715c4f582e4" translate="yes" xml:space="preserve">
          <source>When the user changes which radio button is selected, KO will set your model property to equal the value of the selected radio button. In the preceding example, clicking on the radio button with value=&quot;cherry&quot; would set viewModel.spamFlavor to be &quot;cherry&quot;.</source>
          <target state="translated">사용자가 선택한 라디오 버튼을 변경하면 KO는 모델 속성을 선택한 라디오 버튼의 값과 동일하게 설정합니다. 앞의 예에서 value = &quot;cherry&quot;인 라디오 버튼을 클릭하면 viewModel.spamFlavor가 &quot;cherry&quot;로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="af87db2ce5d35d81a05adcc1a10b76bb7ceb65d5" translate="yes" xml:space="preserve">
          <source>When the user checks or unchecks the checkbox, KO will add or remove the value from the array accordingly.</source>
          <target state="translated">사용자가 확인란을 선택하거나 선택 취소하면 KO는 그에 따라 배열에서 값을 추가하거나 제거합니다.</target>
        </trans-unit>
        <trans-unit id="7ed7961c716e1412d259d37491a6eb0f3e216a42" translate="yes" xml:space="preserve">
          <source>When the user checks or unchecks the checkbox, KO will set your model property to true or false accordingly.</source>
          <target state="translated">사용자가 확인란을 선택하거나 선택 취소하면 KO는 이에 따라 모델 속성을 true 또는 false로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a975d33ef8135e1f85ea96cb074a21a12a6b1e5a" translate="yes" xml:space="preserve">
          <source>When the user checks the associated form control, this updates the value on your view model. Likewise, when you update the value in your view model, this checks or unchecks the form control on screen.</source>
          <target state="translated">사용자가 관련 양식 컨트롤을 확인하면 뷰 모델의 값이 업데이트됩니다. 마찬가지로 뷰 모델에서 값을 업데이트하면 화면의 양식 컨트롤을 확인하거나 선택 취소합니다.</target>
        </trans-unit>
        <trans-unit id="c0803213f1274b2a55d9b91b874c4a9d488ed496" translate="yes" xml:space="preserve">
          <source>When the user edits the value in the associated form control, it updates the value on your view model. Likewise, when you update the value in your view model, this updates the value of the form control on screen.</source>
          <target state="translated">사용자가 연결된 양식 컨트롤에서 값을 편집하면 뷰 모델의 값이 업데이트됩니다. 마찬가지로 뷰 모델에서 값을 업데이트하면 화면의 양식 컨트롤 값이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="f0189caf134a5f34340d62bfc5c510d298e95ca3" translate="yes" xml:space="preserve">
          <source>When the user manually focuses or unfocuses the element, your value will be set to true or false accordingly.</source>
          <target state="translated">사용자가 수동으로 요소의 초점을 맞추거나 초점을 해제하면 값이 true 또는 false로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="98cfccafa8cf961040d59d473116f98c49c5beb7" translate="yes" xml:space="preserve">
          <source>When the user selects or de-selects an item in the multi-select list, this adds or removes the corresponding value to an array on your view model. Likewise, assuming it&amp;rsquo;s an &lt;em&gt;observable&lt;/em&gt; array on your view model, then whenever you add or remove (e.g., via push or splice) items to this array, the corresponding items in the UI become selected or deselected. It&amp;rsquo;s a 2-way binding.</source>
          <target state="translated">사용자가 다중 선택 목록에서 항목을 선택하거나 선택 취소하면 뷰 모델의 배열에 해당 값이 추가되거나 제거됩니다. 마찬가지로 뷰 모델에서 &lt;em&gt;관찰 가능한&lt;/em&gt; 배열 이라고 가정하면 이 배열에 항목을 추가하거나 제거 (예 : 푸시 또는 스플 라이스를 통해) 할 때마다 UI의 해당 항목이 선택되거나 선택 해제됩니다. 양방향 바인딩입니다.</target>
        </trans-unit>
        <trans-unit id="0074731e38b2821484d16af4acc4755105ba6332" translate="yes" xml:space="preserve">
          <source>When the value of any observable is primitive (a number, string, boolean, or null), the dependents of the observable are by default notified only when it is set to a value that is actually different from before. So, primitive-valued deferred observables notify only when their value is actually different at the end of the current task. In other words, if a primitive-valued deferred observable is changed to a new value and then changed back to the original value, no notification will happen.</source>
          <target state="translated">Observable의 값이 기본 (숫자, 문자열, 부울 또는 널) 인 경우 Observable의 종속 항목은 기본적으로 실제로 이전과 다른 값으로 설정된 경우에만 통지됩니다. 따라서 기본 값의 지연된 관측 가능 개체는 현재 작업이 끝날 때 해당 값이 실제로 다른 경우에만 알립니다. 즉, 기본 값의 지연된 관찰 가능 항목이 새 값으로 변경된 후 원래 값으로 다시 변경되면 알림이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73a77795bd66e1cb3b16bdd68e57f5a159e05b77" translate="yes" xml:space="preserve">
          <source>When the value of any observable is primitive (a number, string, boolean, or null), the dependents of the observable are by default notified only when it is set to a value that is actually different from before. So, primitive-valued rate-limited observables notify only when their value is actually different at the end of the timeout period. In other words, if a primitive-valued rate-limited observable is changed to a new value and then changed back to the original value before the timeout period ends, no notification will happen.</source>
          <target state="translated">Observable의 값이 기본 (숫자, 문자열, 부울 또는 널) 인 경우 Observable의 종속 항목은 기본적으로 실제로 이전과 다른 값으로 설정된 경우에만 통지됩니다. 따라서 기본 값의 속도 제한 옵저버 블은 시간 만료 기간이 끝날 때 값이 실제로 다른 경우에만 알립니다. 즉, 기본 값의 속도 제한 관측 가능 항목이 새 값으로 변경된 후 시간 초과 기간이 끝나기 전에 원래 값으로 다시 변경되면 알림이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09e87bae7a7069eae757161892afd1feaa3f86ad" translate="yes" xml:space="preserve">
          <source>When to use a &lt;em&gt;pure&lt;/em&gt; computed observable</source>
          <target state="translated">&lt;em&gt;순수한&lt;/em&gt; 계산 된 관측 가능 을 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="0d9cb52535c85c16c1cd6054161d9b5a42c19b24" translate="yes" xml:space="preserve">
          <source>When using KO, your view is simply your HTML document with declarative bindings to link it to the view model. Alternatively, you can use templates that generate HTML using data from your view model.</source>
          <target state="translated">KO를 사용할 때 뷰는 단순히 선언적 바인딩이있는 HTML 문서로 뷰 모델에 연결됩니다. 또는 뷰 모델의 데이터를 사용하여 HTML을 생성하는 템플릿을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="233388c234469b332e4372d743016356bcc6ddb1" translate="yes" xml:space="preserve">
          <source>When using rateLimit:</source>
          <target state="translated">rateLimit를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="cdd38baa0a09da7b54c34c1c8c1440db8b27182f" translate="yes" xml:space="preserve">
          <source>When we say an application is modular, we generally mean it&amp;rsquo;s composed of a set of highly decoupled, distinct pieces of functionality stored in modules. As you probably know, loose coupling facilitates easier maintainability of apps by removing dependencies where possible. When this is implemented efficiently, its quite easy to see how changes to one part of a system may affect another.</source>
          <target state="translated">애플리케이션이 모듈식이라고 할 때 일반적으로 애플리케이션은 모듈에 저장된 고도로 분리 된 고유 한 기능으로 구성됩니다. 아시다시피 느슨한 결합은 가능한 경우 종속성을 제거하여 앱의 유지 관리를 용이하게합니다. 이것이 효율적으로 구현되면 시스템의 한 부분에 대한 변경 사항이 다른 부분에 어떤 영향을 미치는지 쉽게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e729fad8dd8395be4b5dee56db32c21c2e12be4" translate="yes" xml:space="preserve">
          <source>When writing to an observable that contains a primitive value (a number, string, boolean, or null), the dependencies of the observable are normally only notified if the value actually changed. However, it is possible to use the built-in notify &lt;a href=&quot;extenders&quot;&gt;extender&lt;/a&gt; to ensure that an observable&amp;rsquo;s subscribers are always notified on a write, even if the value is the same. You would apply the extender to an observable like this:</source>
          <target state="translated">기본 값 (숫자, 문자열, 부울 또는 널)을 포함하는 Observable에 쓸 때, Observable의 종속성은 일반적으로 값이 실제로 변경된 경우에만 통지됩니다. 그러나 내장 된 통지 &lt;a href=&quot;extenders&quot;&gt;익스텐더&lt;/a&gt; 를 사용하여 값이 동일한 경우에도 관찰자의 구독자에게 항상 쓰기를 통지 할 수 있습니다. 다음과 같이 익스텐더를 관찰 가능 객체에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="72a073d3684319f9171f7c76ed59be1b723f8be1" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;add&lt;/strong&gt; array entries, foreach will render new copies of your template and insert them into the existing DOM</source>
          <target state="translated">배열 항목 을 &lt;strong&gt;추가&lt;/strong&gt; 하면 foreach는 템플릿의 새 사본을 렌더링하여 기존 DOM에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="fac1b26f280d61f56ca4bfb78786061572d31924" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;delete&lt;/strong&gt; array entries, foreach will simply remove the corresponding DOM elements</source>
          <target state="translated">배열 항목 을 &lt;strong&gt;삭제&lt;/strong&gt; 하면 foreach는 해당 DOM 요소를 간단히 제거합니다.</target>
        </trans-unit>
        <trans-unit id="74f4836dcc40687d501d0a60aca7bfa37c93bc31" translate="yes" xml:space="preserve">
          <source>When you &lt;strong&gt;reorder&lt;/strong&gt; array entries (retaining the same object instances), foreach will typically just move the corresponding DOM elements into their new position</source>
          <target state="translated">동일한 객체 인스턴스를 유지하면서 배열 항목 을 &lt;strong&gt;재정렬&lt;/strong&gt; 하면 foreach는 일반적으로 해당 DOM 요소를 새 위치로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="5e24e098b9af5a56adbd90dc77567f135eceb3a7" translate="yes" xml:space="preserve">
          <source>When you change the name value to 'Mary' by calling myViewModel.personName('Mary'), the text binding will automatically update the text contents of the associated DOM element. That&amp;rsquo;s how changes to the view model automatically propagate to the view.</source>
          <target state="translated">myViewModel.personName ( 'Mary')을 호출하여 이름 값을 'Mary'로 변경하면 텍스트 바인딩이 연관된 DOM 요소의 텍스트 컨텐츠를 자동으로 업데이트합니다. 이것이 뷰 모델의 변경 사항이 뷰에 자동으로 전파되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="7b233d0df811d63859dad5c6f37d404b45b3fb25" translate="yes" xml:space="preserve">
          <source>When you load a viewmodel or template via require declarations, e.g.,</source>
          <target state="translated">require 선언을 통해 뷰 모델 또는 템플릿을로드 할 때</target>
        </trans-unit>
        <trans-unit id="cd8c8cbbd6da1bb5e72e94c4fe56cd77a45a9d91" translate="yes" xml:space="preserve">
          <source>When you modify the contents of your model array (by adding, moving, or deleting its entries), the foreach binding uses an efficient differencing algorithm to figure out what has changed, so it can then update the DOM to match. This means it can handle arbitrary combinations of simulaneous changes.</source>
          <target state="translated">항목을 추가, 이동 또는 삭제하여 모델 배열의 내용을 수정하면 foreach 바인딩은 효율적인 차이 알고리즘을 사용하여 변경된 내용을 파악하므로 일치하도록 DOM을 업데이트 할 수 있습니다. 즉, 동시 변경의 임의 조합을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="c3c82ab350bb2f560fd3b83e7250551b12fe5380" translate="yes" xml:space="preserve">
          <source>When you use the submit binding on a form, Knockout will prevent the browser&amp;rsquo;s default submit action for that form. In other words, the browser will call your handler function but will &lt;em&gt;not&lt;/em&gt; submit the form to the server. This is a useful default because when you use the submit binding, it&amp;rsquo;s normally because you&amp;rsquo;re using the form as an interface to your view model, not as a regular HTML form. If you &lt;em&gt;do&lt;/em&gt; want to let the form submit like a normal HTML form, just return true from your submit handler.</source>
          <target state="translated">양식에서 제출 바인딩을 사용하면 녹아웃은 해당 양식에 대한 브라우저의 기본 제출 조치를 방지합니다. 즉, 브라우저는 핸들러 함수를 호출하지만 양식을 서버에 제출 &lt;em&gt;하지는 않습니다&lt;/em&gt; . 제출 바인딩을 사용할 때 일반적으로 양식을 일반 HTML 양식이 아닌보기 모델의 인터페이스로 사용하기 때문에 이는 유용한 기본값입니다. 당신이 경우 &lt;em&gt;않는&lt;/em&gt; 형태가 보통의 HTML 양식과 같이 제출하게 할, 당신의 제출 핸들러에서 true를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="5099e034c651dd974110c8f683aaf6e9c35ee49c" translate="yes" xml:space="preserve">
          <source>Whenever it has &lt;em&gt;any&lt;/em&gt; change subscribers, it is awake and &lt;strong&gt;&lt;em&gt;listening&lt;/em&gt;&lt;/strong&gt;. When entering the &lt;em&gt;listening&lt;/em&gt; state, it immediately subscribes to any dependencies. In this state, it operates just like a regular computed observable, as described in &lt;a href=&quot;computed-dependency-tracking&quot;&gt;how dependency tracking works&lt;/a&gt;.</source>
          <target state="translated">그 때마다 &lt;em&gt;어떤&lt;/em&gt; 변경 가입자, 그것은 깨어이며 &lt;strong&gt;&lt;em&gt;듣기&lt;/em&gt;&lt;/strong&gt; . &lt;em&gt;청취&lt;/em&gt; 상태에 들어가면 즉시 모든 종속성을 구독합니다. 이 상태에서는 &lt;a href=&quot;computed-dependency-tracking&quot;&gt;종속성 추적의 작동 방식에&lt;/a&gt; 설명 된대로 일반 계산 된 관찰 가능 객체와 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="027a73abac754e236b9d5e7c8cff74895b7e243f" translate="yes" xml:space="preserve">
          <source>Whenever it has &lt;em&gt;no&lt;/em&gt; change subscribers, it is &lt;strong&gt;&lt;em&gt;sleeping&lt;/em&gt;&lt;/strong&gt;. When entering the &lt;em&gt;sleeping&lt;/em&gt; state, it disposes all subscriptions to its dependencies. During this state, it will not subscribe to any observables accessed in the evaluator function (although it does keep track of them). If the computed observable&amp;rsquo;s value is read while it is &lt;em&gt;sleeping&lt;/em&gt;, it is automatically re-evaluated if any of its dependencies have changed.</source>
          <target state="translated">변경 가입자 가 &lt;em&gt;없을&lt;/em&gt; 때마다 &lt;strong&gt;&lt;em&gt;휴면 상태&lt;/em&gt;&lt;/strong&gt; 입니다. &lt;em&gt;휴면&lt;/em&gt; 상태에 들어가면 모든 구독을 해당 종속성에 폐기합니다. 이 상태에서는 평가 기 기능에서 액세스 한 관찰 가능 항목을 구독하지 않습니다 (추적하지만 추적). &lt;em&gt;잠자는&lt;/em&gt; 동안 계산 된 관찰 가능 값을 읽는 경우 종속 항목이 변경된 경우 자동으로 재평가됩니다.</target>
        </trans-unit>
        <trans-unit id="c6f248d3a9bf144743685335ebbb7395f73f3d22" translate="yes" xml:space="preserve">
          <source>Whenever the user edits the value in the associated form control, KO will update the property on your view model. KO will always attempt to update your view model when the value has been modified and a user transfers focus to another DOM node (i.e., on the change event), but you can also trigger updates based on other events by using the valueUpdate parameter described below.</source>
          <target state="translated">사용자가 관련 양식 컨트롤에서 값을 편집 할 때마다 KO는 뷰 모델의 속성을 업데이트합니다. KO는 값이 수정되고 사용자가 다른 DOM 노드 (예 : 변경 이벤트)로 포커스를 전송할 때 항상 뷰 모델을 업데이트하려고 시도하지만 아래 설명 된 valueUpdate 매개 변수를 사용하여 다른 이벤트를 기반으로 업데이트를 트리거 할 수도 있습니다. .</target>
        </trans-unit>
        <trans-unit id="e5c65dd94ea67e2fad51961211d1569eac9051c0" translate="yes" xml:space="preserve">
          <source>Whenever the user edits the value in the associated form control, KO will update the property on your view model. KO will always attempt to update your view model when the value has been modified by the user or any DOM events.</source>
          <target state="translated">사용자가 관련 양식 컨트롤에서 값을 편집 할 때마다 KO는 뷰 모델의 속성을 업데이트합니다. KO는 사용자 또는 DOM 이벤트에 의해 값이 수정 될 때 항상 뷰 모델을 업데이트하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="b90ce04fb0166e97a8840e6753fa79876c4f03da" translate="yes" xml:space="preserve">
          <source>Whenever you declare a computed observable, KO immediately invokes its evaluator function to get its initial value.</source>
          <target state="translated">계산 된 관측 가능 객체를 선언 할 때마다 KO는 즉시 평가 기 함수를 호출하여 초기 값을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="1709d61d9bf5080cbac0848f20d050481e016f8d" translate="yes" xml:space="preserve">
          <source>Whenever you inject a &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; using the &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; or a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;, Knockout fetches that component&amp;rsquo;s template and viewmodel using one or more &lt;em&gt;component loaders&lt;/em&gt;. The job of a component loader is to asynchronously supply a template/viewmodel pair for any given component name.</source>
          <target state="translated">&lt;a href=&quot;component-binding&quot;&gt;구성 요소 바인딩&lt;/a&gt; 또는 &lt;a href=&quot;component-custom-elements&quot;&gt;사용자 정의 요소를&lt;/a&gt; 사용하여 구성 &lt;a href=&quot;component-overview&quot;&gt;요소&lt;/a&gt; 를 삽입 할 때마다 Knockout은 하나 이상의 &lt;em&gt;구성 요소 로더를&lt;/em&gt; 사용하여 해당 구성 요소의 템플리트 및 뷰 모델을 가져옵니다 . 컴포넌트 로더의 역할은 주어진 컴포넌트 이름에 대해 템플릿 / 뷰 모델 쌍을 비동기 적으로 제공하는 것입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7c9368d85e06a808f77b28f4f80f37db962b0bef" translate="yes" xml:space="preserve">
          <source>Whether or not the parameter is an observable array, KO will detect when the user selects or deselects an item in the multi-select list, and will update the array to match. This is how you can read which of the options is selected.</source>
          <target state="translated">KO는 매개 변수가 관측 가능한 배열인지 여부에 관계없이 사용자가 다중 선택 목록에서 항목을 선택하거나 선택 해제 할 때를 감지하고 일치하도록 배열을 업데이트합니다. 선택한 옵션을 읽는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ff7601f5aa5d98b7725bc5ff59a4afe66d02b8ee" translate="yes" xml:space="preserve">
          <source>While result2 will be:</source>
          <target state="translated">result2는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="deedac358e26a9b41a5c69e270deca1435272118" translate="yes" xml:space="preserve">
          <source>While the evaluator function is running, KO sets up a subscription to any observables (including other computed observables) that the evaluator reads. The subscription callback is set to cause the evaluator to run again, looping the whole process back to step 1 (disposing of any old subscriptions that no longer apply).</source>
          <target state="translated">평가자 기능이 실행되는 동안 KO는 평가자가 읽는 모든 관찰 가능 항목 (기타 계산 된 관찰 가능 항목 포함)에 대한 구독을 설정합니다. 구독 콜백은 평가자가 다시 실행되도록 설정하여 전체 프로세스를 1 단계로 다시 반복합니다 (더 이상 적용되지 않는 이전 구독은 삭제).</target>
        </trans-unit>
        <trans-unit id="96bfb27bf17fe0044cc0631c47cb88836e206732" translate="yes" xml:space="preserve">
          <source>Whilst native solutions to these problems will be arriving in ES Harmony, the good news is that writing modular JavaScript has never been easier and you can start doing it today.</source>
          <target state="translated">이러한 문제에 대한 기본 솔루션이 ES Harmony에 제공 될 것이지만, 좋은 소식은 모듈 식 JavaScript를 작성하는 것이 결코 쉬운 일이 아니며 지금 바로 시작할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="47b13cdb0607925057b8e9d36b0386d1a11eb54c" translate="yes" xml:space="preserve">
          <source>Whitespace</source>
          <target state="translated">Whitespace</target>
        </trans-unit>
        <trans-unit id="5e0dfd97e23e633bf46dddf5920fffb9c6f7b27f" translate="yes" xml:space="preserve">
          <source>Why &amp;ldquo;pure&amp;rdquo;?</source>
          <target state="translated">&amp;ldquo;순수한&amp;rdquo;이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="3713912b140d1bc73909fbeb997ac04de7b22784" translate="yes" xml:space="preserve">
          <source>Why not just put a click handler on the submit button?</source>
          <target state="translated">제출 버튼에 클릭 핸들러를 넣는 것이 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="6c9c00dce5a6b8f081befac104650345017434f1" translate="yes" xml:space="preserve">
          <source>Working with JSON strings</source>
          <target state="translated">JSON 문자열 작업</target>
        </trans-unit>
        <trans-unit id="3d63791dc040b8cd0707dc196c19e179ce90bb55" translate="yes" xml:space="preserve">
          <source>Writable computed observables</source>
          <target state="translated">쓰기 가능한 계산 된 관측 가능 항목</target>
        </trans-unit>
        <trans-unit id="e5c7527fc9cce64616a1be5b3da7d5aeedc2fcd8" translate="yes" xml:space="preserve">
          <source>Writable computed observables are a powerful feature with a wide range of possible uses.</source>
          <target state="translated">쓰기 가능한 계산 된 관찰 가능 항목은 다양한 용도로 사용할 수있는 강력한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="91aa11ff1c1ba1f14720abfd6158e9094fb52d2a" translate="yes" xml:space="preserve">
          <source>You are not limited to supplying configuration objects in any standard format. You can supply arbitrary objects as long as your loadComponent function understands them.</source>
          <target state="translated">표준 형식으로 구성 개체를 제공하는 것으로 제한되지 않습니다. loadComponent 함수가 이해하는 한 임의의 오브젝트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee01c6f1c55a18105ff17707a47b82bb6d92c0a0" translate="yes" xml:space="preserve">
          <source>You can also customize how an object is updated by specifying an update callback. It will receive the object it is trying to update and an options object which is identical to the one used by the create callback. You should return the updated value.</source>
          <target state="translated">업데이트 콜백을 지정하여 객체 업데이트 방법을 사용자 지정할 수도 있습니다. 업데이트하려는 객체와 create 콜백에서 사용 된 것과 동일한 옵션 객체를받습니다. 업데이트 된 값을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d880f5ee3e205f53c33334d9f482d9e5a03043e" translate="yes" xml:space="preserve">
          <source>You can also terminate a subscription if you wish: first capture the return value as a variable, then you can call its dispose function, e.g.:</source>
          <target state="translated">원하는 경우 구독을 종료 할 수도 있습니다. 먼저 반환 값을 변수로 캡처 한 다음 dispose 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43f66180a0db996f97c6c83a8137770d9b5159f5" translate="yes" xml:space="preserve">
          <source>You can also use a JavaScript function or arbitrary JavaScript expression as the parameter value. If you do, KO will run your function/evaluate your expression, and use the result to determine whether to hide the element.</source>
          <target state="translated">JavaScript 함수 또는 임의의 JavaScript 표현식을 매개 변수 값으로 사용할 수도 있습니다. 그렇게하면 KO가 함수를 실행 / 식을 평가 한 후 결과를 사용하여 요소를 숨길 지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="e50756d8b024dc4f5ab0d1482650d8b221903759" translate="yes" xml:space="preserve">
          <source>You can also use the value binding with a &amp;lt;select&amp;gt; element that does not use the options binding. In this case, you can choose to specify your &amp;lt;option&amp;gt; elements in markup or build them using the foreach or template bindings. You can even nest options within &amp;lt;optgroup&amp;gt; elements and Knockout will set the selected value appropriately.</source>
          <target state="translated">옵션 바인딩을 사용하지 않는 &amp;lt;select&amp;gt; 요소와 함께 값 바인딩을 사용할 수도 있습니다. 이 경우 마크 업에서 &amp;lt;option&amp;gt; 요소를 지정하거나 foreach 또는 템플릿 바인딩을 사용하여 요소를 빌드하도록 선택할 수 있습니다. &amp;lt;optgroup&amp;gt; 요소 내에 옵션을 중첩시킬 수도 있으며 녹아웃은 선택한 값을 적절하게 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a9bd87c7ad551c644aec3e46f44aa15771ecde5d" translate="yes" xml:space="preserve">
          <source>You can combine multiple JS objects in one viewmodel by applying multiple ko.mapping.fromJS calls, e.g.:</source>
          <target state="translated">여러 ko.mapping.fromJS 호출을 적용하여 하나의 뷰 모델에서 여러 JS 객체를 결합 할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="052f12c0432421aa4b5f276ed7c52cb3ffd99104" translate="yes" xml:space="preserve">
          <source>You can either put the script block at the bottom of your HTML document, or you can put it at the top and wrap the contents in a DOM-ready handler such as &lt;a href=&quot;http://api.jquery.com/jQuery/#jQuery3&quot;&gt;jQuery&amp;rsquo;s $ function&lt;/a&gt;.</source>
          <target state="translated">스크립트 블록을 HTML 문서의 맨 아래에 놓거나 맨 위에 놓고 &lt;a href=&quot;http://api.jquery.com/jQuery/#jQuery3&quot;&gt;jQuery의 $ function&lt;/a&gt; 과 같은 DOM 지원 핸들러에 내용을 래핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1dba98508f19715d131036a3aa6e81ae5ae8188c" translate="yes" xml:space="preserve">
          <source>You can even set multiple CSS classes based on the same condition by wrapping the names in quotes like:</source>
          <target state="translated">다음과 같이 이름을 따옴표로 묶어 동일한 조건을 기반으로 여러 CSS 클래스를 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ec2e8dcbd91bae1eafeddc57bddc053e1571e0f" translate="yes" xml:space="preserve">
          <source>You can find a good list of reserved words on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords&quot;&gt;Mozilla&amp;rsquo;s MDN page here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#Keywords&quot;&gt;모질라의 MDN 페이지에서&lt;/a&gt; 예약어 목록을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3cfbf0de916a9a332d3fb80ff672ea022cb01b5" translate="yes" xml:space="preserve">
          <source>You can hook into Knockout&amp;rsquo;s logic for interpreting data-bind attributes by providing a &lt;em&gt;binding preprocessor&lt;/em&gt; for a specific binding handler (such as click, visible, or any &lt;a href=&quot;custom-bindings&quot;&gt;custom binding handler&lt;/a&gt;).</source>
          <target state="translated">특정 바인딩 핸들러 (예 : 클릭, 표시 또는 &lt;a href=&quot;custom-bindings&quot;&gt;사용자 정의 바인딩 핸들러&lt;/a&gt; )에 &lt;em&gt;바인딩 프리 프로세서&lt;/em&gt; 를 제공하여 데이터 바인드 속성을 해석하기위한 Knockout의 논리에 연결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87fac0243102cb0636d3c50436c06c35c6bc14b1" translate="yes" xml:space="preserve">
          <source>You can hook into Knockout&amp;rsquo;s logic for traversing the DOM by providing a &lt;em&gt;node preprocessor&lt;/em&gt;. This is a function that Knockout will call once for each DOM node that it walks over, both when the UI is first bound, and later when any new DOM subtrees are injected (e.g., via a &lt;a href=&quot;foreach-binding&quot;&gt;foreach binding&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;노드 전처리기를&lt;/em&gt; 제공하여 DOM을 통과하기위한 Knockout의 논리에 연결할 수 있습니다 . 이것은 UI가 처음 바인딩 될 때와 나중에 새로운 DOM 서브 트리가 주입 될 때 (예 : &lt;a href=&quot;foreach-binding&quot;&gt;foreach 바인딩을&lt;/a&gt; 통해) 각 DOM 노드에 대해 Knockout이 한 번 호출하는 기능입니다 .</target>
        </trans-unit>
        <trans-unit id="3e4c6da9d3b1f66034b47e8dd672b13081d17170" translate="yes" xml:space="preserve">
          <source>You can map this to a view model without any problems:</source>
          <target state="translated">아무 문제없이 이것을 뷰 모델에 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="689af8b06e2b8d5ff8ae217915b9eefe6ba45a38" translate="yes" xml:space="preserve">
          <source>You can reference any JavaScript function - it doesn&amp;rsquo;t have to be a function on your view model. You can reference a function on any object by writing click: someObject.someFunction.</source>
          <target state="translated">JavaScript 함수를 참조 할 수 있습니다. 뷰 모델에서 함수일 필요는 없습니다. click : someObject.someFunction을 작성하여 모든 객체에서 함수를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef0d5d305918c213b70064faeb270cf5be19cc1a" translate="yes" xml:space="preserve">
          <source>You can reference any JavaScript function - it doesn&amp;rsquo;t have to be a function on your view model. You can reference a function on any object by writing event { mouseover: someObject.someFunction }.</source>
          <target state="translated">JavaScript 함수를 참조 할 수 있습니다. 뷰 모델에서 함수일 필요는 없습니다. 이벤트 {mouseover : someObject.someFunction}을 작성하여 모든 객체에서 함수를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7731e4275a6724a076a102c99873fd04d12377b" translate="yes" xml:space="preserve">
          <source>You can reference any JavaScript function - it doesn&amp;rsquo;t have to be a function on your view model. You can reference a function on any object by writing submit: someObject.someFunction.</source>
          <target state="translated">JavaScript 함수를 참조 할 수 있습니다. 뷰 모델에서 함수일 필요는 없습니다. submit : someObject.someFunction을 작성하여 모든 오브젝트에서 함수를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3bf8a9a01529e6b883f85d2f5580c56462d82cd" translate="yes" xml:space="preserve">
          <source>You can register a component as follows:</source>
          <target state="translated">다음과 같이 구성 요소를 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc66fcbdb568796cafb3b258bf02626926a8c07f" translate="yes" xml:space="preserve">
          <source>You can set multiple CSS classes at once. For example, if your view model has a property called isSevere,</source>
          <target state="translated">한 번에 여러 CSS 클래스를 설정할 수 있습니다. 예를 들어 뷰 모델에 isSevere라는 속성이 있으면</target>
        </trans-unit>
        <trans-unit id="ee756fc2ba7ca22b5831bf756c710f284d654159" translate="yes" xml:space="preserve">
          <source>You can set multiple style values at once. For example, if your view model has a property called isSevere,</source>
          <target state="translated">한 번에 여러 스타일 값을 설정할 수 있습니다. 예를 들어 뷰 모델에 isSevere라는 속성이 있으면</target>
        </trans-unit>
        <trans-unit id="3dba377f14bffba8a5efad9ec37fc825bce450e7" translate="yes" xml:space="preserve">
          <source>You can then create a very simple &lt;em&gt;view&lt;/em&gt; of this view model using a declarative binding. For example, the following markup displays the personName value:</source>
          <target state="translated">그런 다음 선언적 바인딩을 사용하여이 뷰 모델의 매우 간단한 &lt;em&gt;뷰&lt;/em&gt; 를 만들 수 있습니다 . 예를 들어, 다음 마크 업은 personName 값을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9f862efa038e8d26e7af75e8f1448e315ace30bd" translate="yes" xml:space="preserve">
          <source>You can use a writable computed observable exactly like a regular observable, with your own custom logic intercepting all reads and writes. Just like observables, you can write values to multiple observable or computed observable properties on a model object using &lt;em&gt;chaining syntax&lt;/em&gt;. For example, myViewModel.fullName('Joe Smith').age(50).</source>
          <target state="translated">모든 읽기 및 쓰기를 가로채는 사용자 지정 논리를 사용하여 쓰기 가능한 계산 된 관측 가능 개체를 일반 관측 가능 개체와 정확히 동일하게 사용할 수 있습니다. 옵저버 블과 마찬가지로 &lt;em&gt;체인 구문을&lt;/em&gt; 사용하여 모델 객체의 여러 옵저버 블 또는 계산 된 옵저버 블 속성에 값을 쓸 수 있습니다 . 예를 들어, myViewModel.fullName ( 'Joe Smith'). age (50)입니다.</target>
        </trans-unit>
        <trans-unit id="cc3db9cdadd161e89137b6c1f8b5ea73932af31f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;em&gt;pure&lt;/em&gt; feature for any computed observable that follows the &lt;a href=&quot;#pure-computed-function-defined&quot;&gt;&lt;em&gt;pure function&lt;/em&gt; guidelines&lt;/a&gt;. You&amp;rsquo;ll see the most benefit, though, when it is applied to application designs that involve persistent view models that are used and shared by temporary views and view models. Using &lt;em&gt;pure&lt;/em&gt; computed observables in a persistent view model provides computation performance benefits. Using them in temporary view models provides memory management benefits.</source>
          <target state="translated">&lt;a href=&quot;#pure-computed-function-defined&quot;&gt;&lt;em&gt;순수한 기능&lt;/em&gt;&lt;/a&gt; 지침 을 따르는 계산 된 관측 가능 객체 에는 &lt;em&gt;순수한&lt;/em&gt; 기능을 사용할 수 있습니다 . 그러나 임시 뷰 및 뷰 모델에서 사용하고 공유하는 영구 뷰 모델이 포함 된 응용 프로그램 설계에 적용하면 가장 큰 이점을 얻을 수 있습니다. 영구 뷰 모델에서 &lt;em&gt;순수한&lt;/em&gt; 계산 된 관측 가능 객체를 사용하면 계산 성능이 향상됩니다. 임시 뷰 모델에서 사용하면 메모리 관리 이점이 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="445598a09e09ab27b378c79e9f86d7333d1962c6" translate="yes" xml:space="preserve">
          <source>You can use the init callback as a place to register an event handler that will cause changes to the associated observable. For example,</source>
          <target state="translated">초기화 콜백을 장소로 사용하여 관련 관찰 가능 항목을 변경하는 이벤트 핸들러를 등록 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="c9980038705a45b71f8dc2def98206cccd1f4d42" translate="yes" xml:space="preserve">
          <source>You can use this technique if, for example, you want to control which subset of registered components may be used as custom elements.</source>
          <target state="translated">예를 들어, 사용자 정의 요소로 사용될 등록 된 구성 요소의 서브 세트를 제어하려는 경우이 기술을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="661a6f45bdafd50b10c85ee0a3c036fc7df926c5" translate="yes" xml:space="preserve">
          <source>You could bind this view model to some HTML elements as follows:</source>
          <target state="translated">이 뷰 모델을 다음과 같이 일부 HTML 요소에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1d471328860434648aa8fa03313f486aae8251e" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t have to change the view at all - the same data-bind syntax will keep working. The difference is that it&amp;rsquo;s now capable of detecting changes, and when it does, it will update the view automatically.</source>
          <target state="translated">뷰를 전혀 변경할 필요가 없습니다. 동일한 데이터 바인딩 구문이 계속 작동합니다. 차이점은 이제 변경 사항을 감지 할 수 있으며 변경 사항이 있으면 자동으로보기를 업데이트한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="17a973a03dcc80b13d7dbe90df99ac6b1793924e" translate="yes" xml:space="preserve">
          <source>You might want to implement a custom component loader if you want to use naming conventions, rather than explicit registration, to load components. Or, if you want to use a third-party &amp;ldquo;loader&amp;rdquo; library to fetch component viewmodels or templates from external locations.</source>
          <target state="translated">명시 적 등록이 아닌 이름 지정 규칙을 사용하여 구성 요소를로드하려는 경우 사용자 정의 구성 요소 로더를 구현할 수 있습니다. 또는 타사 &quot;로더&quot;라이브러리를 사용하여 외부 위치에서 구성 요소 뷰 모델 또는 템플릿을 가져 오려는 경우.</target>
        </trans-unit>
        <trans-unit id="fee233d9fef0eab27974da7495e7c970d76709ab" translate="yes" xml:space="preserve">
          <source>You must use dispose to release any resources that aren&amp;rsquo;t inherently garbage-collectable. For example:</source>
          <target state="translated">본질적으로 가비지 수집 할 수없는 자원을 해제하려면 dispose를 사용해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d43cca43db2b101cb12f2e4c94e2a371e5bd69f" translate="yes" xml:space="preserve">
          <source>You must write &amp;lt;my-custom-element&amp;gt;&amp;lt;/my-custom-element&amp;gt;, and &lt;strong&gt;not&lt;/strong&gt; &amp;lt;my-custom-element /&amp;gt;. Otherwise, your custom element is not closed and subsequent elements will be parsed as child elements.</source>
          <target state="translated">당신은 &amp;lt;내-사용자 정의 요소&amp;gt; 작성해야합니다 &amp;lt;/ 내 - 사용자 정의 요소&amp;gt;, 그리고 &lt;strong&gt;하지&lt;/strong&gt; &amp;lt;내-사용자 정의 요소 /&amp;gt;. 그렇지 않으면 사용자 정의 요소가 닫히지 않고 후속 요소가 하위 요소로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="d9251d769ce5e182a494a279bea207eec0172927" translate="yes" xml:space="preserve">
          <source>You only need two files for the component - a viewmodel (path/my-component.js) and a template (path/my-component.html) - which is a very natural arrangement during development.</source>
          <target state="translated">컴포넌트에는 뷰 모델 (path / my-component.js)과 템플릿 (path / my-component.html)이라는 두 개의 파일 만 있으면 개발 과정에서 매우 자연스러운 배열입니다.</target>
        </trans-unit>
        <trans-unit id="a29664b58fa5bfc4804c4fec44e01829983a68be" translate="yes" xml:space="preserve">
          <source>You should not use the &lt;em&gt;pure&lt;/em&gt; feature for a computed observable that is meant to perform an action when its dependencies change. Examples include:</source>
          <target state="translated">종속성이 변경 될 때 작업을 수행하기 위해 계산 된 관찰 가능 개체에 &lt;em&gt;순수&lt;/em&gt; 기능을 사용해서는 안됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="350964aafaead15e0f900fd5cb4610606ba71f2c" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names correspond to attribute names, and the values correspond to the attribute values you wish to apply.</source>
          <target state="translated">속성 이름이 속성 이름에 해당하고 값이 적용하려는 속성 값에 해당하는 JavaScript 객체를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0ebd1ec7d9cfc0718391b658886d523d78de173" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names correspond to event names, and the values correspond to the function that you want to bind to the event.</source>
          <target state="translated">속성 이름이 이벤트 이름에 해당하고 값이 이벤트에 바인딩하려는 함수에 해당하는 JavaScript 객체를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e10e77115395251f2707e5c49667eb3dc1b1e89" translate="yes" xml:space="preserve">
          <source>You should pass a JavaScript object in which the property names correspond to style names, and the values correspond to the style values you wish to apply.</source>
          <target state="translated">속성 이름이 스타일 이름에 해당하고 값이 적용하려는 스타일 값에 해당하는 JavaScript 객체를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="f2431741ff9d62f8125af6f5b235418b67c42a31" translate="yes" xml:space="preserve">
          <source>You should supply an array (or observable array). For each item, KO will add an &amp;lt;option&amp;gt; to the associated &amp;lt;select&amp;gt; node. Any previous options will be removed.</source>
          <target state="translated">배열 (또는 관찰 가능한 배열)을 제공해야합니다. KO는 각 항목에 대해 &amp;lt;option&amp;gt;을 관련 &amp;lt;select&amp;gt; 노드에 추가합니다. 이전의 모든 옵션이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b1f309b2b779d610009271c39ee65e9c095e6b65" translate="yes" xml:space="preserve">
          <source>You want to display the current server-time and the number of users on your web page. You could represent this information using the following view model:</source>
          <target state="translated">웹 페이지에 현재 서버 시간과 사용자 수를 표시하려고합니다. 다음 뷰 모델을 사용하여이 정보를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab0462be804f0902ece6db1caf383668c565a43e" translate="yes" xml:space="preserve">
          <source>You won&amp;rsquo;t need to use this often. It&amp;rsquo;s only useful in a few rare cases, e.g.:</source>
          <target state="translated">이것을 자주 사용할 필요는 없습니다. 다음과 같은 몇 가지 드문 경우에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="136d45b744ad9e632284ca13aec225df9d9d766f" translate="yes" xml:space="preserve">
          <source>You would have to do this for every variable you want to display on your page. If your data structures become more complex (e.g. they contain children or contain arrays) this becomes very cumbersome to handle manually. What the mapping plugin allows you to do is create a mapping from the regular JavaScript object (or JSON structure) to an observable view model.</source>
          <target state="translated">페이지에 표시하려는 모든 변수에 대해이 작업을 수행해야합니다. 데이터 구조가 더 복잡해지면 (예 : 자식을 포함하거나 배열을 포함) 수동으로 처리하기가 매우 번거로워집니다. 매핑 플러그인으로 할 수있는 것은 일반 JavaScript 객체 (또는 JSON 구조)에서 관찰 가능한 뷰 모델로의 매핑을 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f9c1cd6deaf34424cd7538a83dcd4251f9037aed" translate="yes" xml:space="preserve">
          <source>You would use this extender by calling the extend function of an observable and passing an object that contains a logChange property.</source>
          <target state="translated">Observable의 extend 함수를 호출하고 logChange 특성이 포함 된 오브젝트를 전달하여이 Extender를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6c472940368ffb2c6f5ef7385d23da07c065fb9d" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to referencing variables - you can reference arbitrary expressions to control an element&amp;rsquo;s enabledness. For example,</source>
          <target state="translated">변수 참조에만 국한되지는 않습니다. 임의의 표현식을 참조하여 요소의 활성화를 제어 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="fa251b979a6c1805f4ab439f863653eaa0839791" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to using &amp;lt;template&amp;gt; elements, but these are convenient (on browsers that support them) since they don&amp;rsquo;t get rendered on their own. Any other element type works too.</source>
          <target state="translated">&amp;lt;template&amp;gt; 요소를 사용하는 것에 만 국한되지는 않지만, 독자적으로 렌더링되지 않기 때문에 (요소를 지원하는 브라우저에서) 편리합니다. 다른 요소 유형도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2cf0cf7d70766bca9a0f4aed278bfa9447202bcb" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;re not limited to using the built-in bindings like click, value, and so on &amp;mdash; you can create your own ones. This is how to control how observables interact with DOM elements, and gives you a lot of flexibility to encapsulate sophisticated behaviors in an easy-to-reuse way.</source>
          <target state="translated">클릭, 값 등과 같은 기본 제공 바인딩을 사용하는 것에 만 국한되지 않고 자신 만의 바인딩을 만들 수 있습니다. 이것은 옵저버 블이 DOM 요소와 상호 작용하는 방식을 제어하는 ​​방법이며 정교한 동작을 재사용하기 쉬운 방식으로 캡슐화 할 수있는 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e47fc623d74756db24366a5c57ef4b49ba356887" translate="yes" xml:space="preserve">
          <source>You&amp;rsquo;ve already seen how to use update so that, when an observable changes, you can update an associated DOM element. But what about events in the other direction? When the user performs some action on a DOM element, you might want to updated an associated observable.</source>
          <target state="translated">관찰이 변경 될 때 관련 DOM 요소를 업데이트 할 수 있도록 업데이트 사용 방법을 이미 살펴 보았습니다. 그러나 다른 방향의 사건은 어떻습니까? 사용자가 DOM 요소에 대한 작업을 수행 할 때 관련 관찰 가능 항목을 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4be6289caef2ba7111850de2b50105c34b7ea767" translate="yes" xml:space="preserve">
          <source>Your preprocess function must return the new string value to be parsed and passed to the binding, or return undefined to remove the binding.</source>
          <target state="translated">사전 처리 함수는 구문 분석하여 바인딩에 전달할 새 문자열 값을 리턴하거나 정의되지 않은 상태로 리턴하여 바인딩을 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="feacdda40c5240dc38595a9dd2636c7cd727afa1" translate="yes" xml:space="preserve">
          <source>Your view models &lt;em&gt;are&lt;/em&gt; JavaScript objects, so in a sense, you could just serialize them as JSON using any standard JSON serializer, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt; (a native function in modern browsers), or the &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt; library. However, your view models probably contain observables, computed observables, and observable arrays, which are implemented as JavaScript functions and therefore won&amp;rsquo;t always serialize cleanly without additional work on your behalf.</source>
          <target state="translated">뷰 모델 &lt;em&gt;은&lt;/em&gt; JavaScript 객체이므로 어떤 의미에서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt; (현대 브라우저의 기본 함수) 또는 &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt; 라이브러리 와 같은 표준 JSON 직렬 변환기를 사용하여 JSON으로 직렬화 할 수 있습니다. 그러나 뷰 모델에는 관찰 가능 항목, 계산 가능 관찰 가능 항목 및 관찰 가능 배열이 포함되어있을 수 있으며,이 기능은 JavaScript 함수로 구현되므로 사용자를 대신하여 추가 작업을하지 않아도 항상 명확하게 직렬화되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="39cb2f1192f456b678052badfe6dfbc807f31fd4" translate="yes" xml:space="preserve">
          <source>a &lt;strong&gt;computed observable&lt;/strong&gt; called selectedItems that returns an array of item objects corresponding to the selected indexes</source>
          <target state="translated">&lt;strong&gt;계산 관찰&lt;/strong&gt; 항목의 배열을 반환라는 selectedItems를 선택한 인덱스에 대응하는 개체</target>
        </trans-unit>
        <trans-unit id="c304f8e7203b72eac14ca40325fc8fce86a3be08" translate="yes" xml:space="preserve">
          <source>addBinding: a callback function you can optionally use to insert another binding on the current element. This requires two parameters, name and value. For example, inside your preprocess function, call addBinding('visible', 'acceptsTerms()'); to make Knockout behave as if the element had a visible: acceptsTerms() binding on it.</source>
          <target state="translated">addBinding : 현재 요소에 다른 바인딩을 삽입하는 데 선택적으로 사용할 수있는 콜백 함수입니다. 여기에는 이름과 값의 두 매개 변수가 필요합니다. 예를 들어, 전처리 함수 내에서 addBinding ( 'visible', 'acceptsTerms ()'); 녹아웃이 요소가 보이는 것처럼 동작하도록하려면 acceptsTerms () 바인딩이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ca84e4058eedaa99100e4d5459ba5d30f2c5b8ab" translate="yes" xml:space="preserve">
          <source>afterAdd &amp;mdash; is like afterRender, except it is invoked only when new entries are added to your array (and &lt;em&gt;not&lt;/em&gt; when foreach first iterates over your array&amp;rsquo;s initial contents). A common use for afterAdd is to call a method such as jQuery&amp;rsquo;s $(domNode).fadeIn() so that you get animated transitions whenever items are added. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">afterAdd &amp;mdash; afterRender와 비슷하지만 새 항목이 배열에 추가 될 때만 호출되며 foreach가 처음 배열의 초기 내용을 반복 할 때는 호출 &lt;em&gt;되지 않습니다&lt;/em&gt; . afterAdd의 일반적인 용도는 jQuery의 $ (domNode) .fadeIn ()과 같은 메소드를 호출하여 항목이 추가 될 때마다 애니메이션 전환을 얻는 것입니다. 녹아웃은 다음 매개 변수를 콜백에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5875d6886a7574f1c5c1b075f6971a15d98841a2" translate="yes" xml:space="preserve">
          <source>afterMove &amp;mdash; is invoked after an array item has changed position in the array, and after foreach has updated the DOM to match. Note that afterMove applies to all array elements whose indexes have changed, so if you insert a new item at the beginning of an array, then the callback (if specified) will fire for all other elements, since their index position has increased by one. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">afterMove &amp;mdash; 배열 항목이 배열에서 위치를 변경 한 후 foreach가 일치하도록 DOM을 업데이트 한 후에 호출됩니다. afterMove는 인덱스가 변경된 모든 배열 요소에 적용되므로 배열의 시작 부분에 새 항목을 삽입하면 인덱스 위치가 1 씩 증가했기 때문에 다른 모든 요소에 대해 콜백 (지정된 경우)이 실행됩니다. 녹아웃은 다음 매개 변수를 콜백에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ebb1a50ce7bb74ee728f2eee95c47b413f5bd53d" translate="yes" xml:space="preserve">
          <source>afterRender &amp;mdash; is invoked each time the foreach block is duplicated and inserted into the document, both when foreach first initializes, and when new entries are added to the associated array later. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">afterRender &amp;mdash; foreach 블록이 복제되어 문서에 삽입 될 때마다 (foreach가 처음 초기화 될 때와 나중에 새 배열이 관련 배열에 추가 될 때) 호출됩니다. 녹아웃은 다음 매개 변수를 콜백에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e5870134ecf0c0be5c68beda1e34f16544cda8dc" translate="yes" xml:space="preserve">
          <source>afterRender, afterAdd, or beforeRemove &amp;mdash; callback functions to be invoked against the rendered DOM elements - see &lt;a href=&quot;#note-4-using-afterrender-afteradd-and-beforeremove&quot;&gt;Note 4&lt;/a&gt;</source>
          <target state="translated">afterRender, afterAdd 또는 beforeRemove &amp;mdash; 렌더링 된 DOM 요소에 대해 호출 할 콜백 함수- &lt;a href=&quot;#note-4-using-afterrender-afteradd-and-beforeremove&quot;&gt;참고 4&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="b90203ff7ecbf7871ddb8178bb79cea83c9713d2" translate="yes" xml:space="preserve">
          <source>allBindings &amp;mdash; A JavaScript object that you can use to access all the model values bound to this DOM element. Call allBindings.get('name') to retrieve the value of the name binding (returns undefined if the binding doesn&amp;rsquo;t exist); or allBindings.has('name') to determine if the name binding is present for the current element.</source>
          <target state="translated">allBindings &amp;mdash;이 DOM 요소에 바인딩 된 모든 모델 값에 액세스하는 데 사용할 수있는 JavaScript 객체입니다. allBindings.get ( 'name')을 호출하여 이름 바인딩의 값을 검색하십시오 (바인딩이 없으면 정의되지 않음을 리턴 함). 또는 allBindings.has ( 'name')를 사용하여 현재 요소에 대한 이름 바인딩이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0e42813294fc8d28f3ca0881b6187457d3cc1b1f" translate="yes" xml:space="preserve">
          <source>an &lt;strong&gt;observable&lt;/strong&gt; called items representing a set of items</source>
          <target state="translated">&lt;strong&gt;관찰&lt;/strong&gt; 항목 집합을 나타내는라는 항목</target>
        </trans-unit>
        <trans-unit id="bc46cf26656d742bd5335bdf9b52eddf49a88381" translate="yes" xml:space="preserve">
          <source>another &lt;strong&gt;computed observable&lt;/strong&gt; that returns true or false depending on whether any of selectedItems has some property (like being new or being unsaved). Some UI element, like a button, might be enabled or disabled based on this value.</source>
          <target state="translated">selectedItems에 일부 속성이 있는지 (새 항목인지 저장되지 않은지)에 따라 true 또는 false를 반환하는 &lt;strong&gt;계산 된&lt;/strong&gt; 다른 &lt;strong&gt;관측 가능 개체&lt;/strong&gt; 입니다. 이 값을 기반으로 버튼과 같은 일부 UI 요소가 활성화 또는 비활성화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b76c357ba02c535d132081781d20a66952d6dcc1" translate="yes" xml:space="preserve">
          <source>another &lt;strong&gt;observable&lt;/strong&gt; called selectedIndexes storing which item indexes have been &amp;lsquo;selected&amp;rsquo; by the user</source>
          <target state="translated">사용자가 '선택한'항목 색인을 저장하는 selectedIndexes라는 또 다른 &lt;strong&gt;관찰 가능&lt;/strong&gt; 항목</target>
        </trans-unit>
        <trans-unit id="bd21690b8380b0841426a885d83cab1ab8325f45" translate="yes" xml:space="preserve">
          <source>as &amp;mdash; when used in conjunction with foreach, defines an alias for each item being rendered - see &lt;a href=&quot;#note-3-using-as-to-give-an-alias-to-foreach-items&quot;&gt;Note 3&lt;/a&gt; for details.</source>
          <target state="translated">as &amp;mdash; foreach와 함께 사용하면 렌더링되는 각 항목의 별칭을 정의합니다 . 자세한 내용 은 &lt;a href=&quot;#note-3-using-as-to-give-an-alias-to-foreach-items&quot;&gt;참고 3&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7a9500f82291e43e9cc92d2055245a5a38e892ea" translate="yes" xml:space="preserve">
          <source>asynchronous updates made as part of the textInput and value binding</source>
          <target state="translated">textInput 및 value 바인딩의 일부로 작성된 비동기 업데이트</target>
        </trans-unit>
        <trans-unit id="90c55536df6492005a02b302ee99abb278abe315" translate="yes" xml:space="preserve">
          <source>attr binding</source>
          <target state="translated">속성 바인딩</target>
        </trans-unit>
        <trans-unit id="8f5e3f66d7b1824f9fbcb9556a10b1149c3b377c" translate="yes" xml:space="preserve">
          <source>beforeMove &amp;mdash; is invoked when an array item has changed position in the array, but before the corresponding DOM nodes have been moved. Note that beforeMove applies to all array elements whose indexes have changed, so if you insert a new item at the beginning of an array, then the callback (if specified) will fire for all other elements, since their index position has increased by one. You could use beforeMove to store the original screen coordinates of the affected elements so that you can animate their movements in the afterMove callback. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">beforeMove &amp;mdash; 배열 항목이 배열에서 위치를 변경 한 경우 해당 DOM 노드가 이동되기 전에 호출됩니다. beforeMove는 인덱스가 변경된 모든 배열 요소에 적용되므로 배열의 시작 부분에 새 항목을 삽입하면 인덱스 위치가 1 씩 증가했기 때문에 다른 모든 요소에 대해 콜백 (지정된 경우)이 실행됩니다. beforeMove를 사용하면 영향을받는 요소의 원래 화면 좌표를 저장하여 afterMove 콜백에서 해당 동작을 애니메이션 할 수 있습니다. 녹아웃은 다음 매개 변수를 콜백에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3992daaa62b44af106b3c47484f57555aa0b6bb5" translate="yes" xml:space="preserve">
          <source>beforeRemove &amp;mdash; is invoked when an array item has been removed, but before the corresponding DOM nodes have been removed. If you specify a beforeRemove callback, then &lt;em&gt;it becomes your responsibility to remove the DOM nodes&lt;/em&gt;. The obvious use case here is calling something like jQuery&amp;rsquo;s $(domNode).fadeOut() to animate the removal of the corresponding DOM nodes &amp;mdash; in this case, Knockout cannot know how soon it is allowed to physically remove the DOM nodes (who knows how long your animation will take?), so it is up to you to remove them. Knockout will supply the following parameters to your callback:</source>
          <target state="translated">beforeRemove &amp;mdash; 배열 항목이 제거되었지만 해당 DOM 노드가 제거되기 전에 호출됩니다. beforeRemove 콜백을 지정 &lt;em&gt;하면 DOM 노드를 제거해야합니다&lt;/em&gt; . 여기서 명백한 유스 케이스는 jQuery의 $ (domNode) .fadeOut ()과 같은 것을 호출하여 해당 DOM 노드의 제거를 애니메이션으로 만드는 것입니다.이 경우 녹아웃은 DOM 노드를 물리적으로 얼마나 빨리 제거 할 수 있는지 알 수 없습니다 애니메이션이 오래 걸리나요?) 따라서 애니메이션을 제거하는 것은 사용자의 몫입니다. 녹아웃은 다음 매개 변수를 콜백에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2eb4c0b60f525fd135163b1ae9de765428f744e2" translate="yes" xml:space="preserve">
          <source>bindingContext &amp;mdash; An object that holds the &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; available to this element&amp;rsquo;s bindings. This object includes special properties including $parent, $parents, and $root that can be used to access data that is bound against ancestors of this context.</source>
          <target state="translated">bindingContext &amp;mdash; 이 요소의 바인딩에 사용 가능한 &lt;a href=&quot;binding-context&quot;&gt;바인딩 컨텍스트&lt;/a&gt; 를 보유하는 객체입니다 . 이 객체에는 $ parent, $ parents 및 $ root를 포함하여이 컨텍스트의 상위 항목에 바인딩 된 데이터에 액세스하는 데 사용할 수있는 특수 속성이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="381b31a682de37484b9fd0f593135748a0b77c19" translate="yes" xml:space="preserve">
          <source>checked binding</source>
          <target state="translated">바인딩 확인</target>
        </trans-unit>
        <trans-unit id="178f138000896f2d7e388a6b20ae521a0f454c9a" translate="yes" xml:space="preserve">
          <source>click binding</source>
          <target state="translated">바인딩 클릭</target>
        </trans-unit>
        <trans-unit id="4a22520e4829f157bb92c323abde36645d85a42d" translate="yes" xml:space="preserve">
          <source>component binding</source>
          <target state="translated">컴포넌트 바인딩</target>
        </trans-unit>
        <trans-unit id="74588c318ed3e1373d32a16c8b82217c6a9e2c33" translate="yes" xml:space="preserve">
          <source>component loading of a cached component when not configured for &lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;synchronous loading&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;동기식 로딩을&lt;/a&gt; 위해 구성되지 않은 경우 캐시 된 구성 요소의 구성 요소 로딩</target>
        </trans-unit>
        <trans-unit id="ec2727b3b71f07635f726026bef44352ec89e452" translate="yes" xml:space="preserve">
          <source>context</source>
          <target state="translated">context</target>
        </trans-unit>
        <trans-unit id="47c42e798ee874e6cfcd86804e9bec622c1878b5" translate="yes" xml:space="preserve">
          <source>createViewModel(params, componentInfo) - &lt;strong&gt;Optional.&lt;/strong&gt; A function that will later be called to supply a viewmodel object for each instance of this component</source>
          <target state="translated">createViewModel (params, componentInfo)- &lt;strong&gt;선택 사항. &lt;/strong&gt;이 컴포넌트의 각 인스턴스에 대해 뷰 모델 객체를 제공하기 위해 나중에 호출 될 함수</target>
        </trans-unit>
        <trans-unit id="df7b59f08733d6664f20aa71e5e0386fdb0dd586" translate="yes" xml:space="preserve">
          <source>css binding</source>
          <target state="translated">CSS 바인딩</target>
        </trans-unit>
        <trans-unit id="26be54a22383463c792c869319f96dd9c12860d2" translate="yes" xml:space="preserve">
          <source>data &amp;mdash; an object to supply as the data for the template to render. If you omit this parameter, KO will look for a foreach parameter, or will fall back on using your current model object.</source>
          <target state="translated">data &amp;mdash; 템플릿이 렌더링 할 데이터로 제공 할 객체입니다. 이 매개 변수를 생략하면 KO는 foreach 매개 변수를 찾거나 현재 모델 객체를 사용하여 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="2ace213c7cef8b5a242680b74c316a32b95cb054" translate="yes" xml:space="preserve">
          <source>data-bind syntax</source>
          <target state="translated">데이터 바인드 구문</target>
        </trans-unit>
        <trans-unit id="34bb93443083edc26cd67b3c2dc4fe14c3dbe694" translate="yes" xml:space="preserve">
          <source>data: The JavaScript object containing the data for this child</source>
          <target state="translated">data :이 자식에 대한 데이터를 포함하는 JavaScript 객체</target>
        </trans-unit>
        <trans-unit id="37d53aab95d0d1b492e4799d7924de18059840ba" translate="yes" xml:space="preserve">
          <source>deferEvaluation &amp;mdash; Optional. If this option is true, then the value of the computed observable will not be evaluated until something actually attempts to access its value or manually subscribes to it. By default, a computed observable has its value determined immediately during creation.</source>
          <target state="translated">deferEvaluation &amp;mdash; 선택 사항. 이 옵션이 true이면 계산 된 옵저버 블의 값은 실제로 값에 액세스하려고 시도하거나 수동으로 값을 구독 할 때까지 평가되지 않습니다. 기본적으로 계산 된 관측 가능 값은 생성하는 동안 즉시 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="b9fa8509278c6cb3f2826b8ba5d48e406bb348d7" translate="yes" xml:space="preserve">
          <source>destroy and destroyAll (Note: Usually relevant to Ruby on Rails developers only)</source>
          <target state="translated">destroy and destroyAll (참고 : 일반적으로 Ruby on Rails 개발자에게만 해당)</target>
        </trans-unit>
        <trans-unit id="53a4c6ac425d3063b86bc1ab2c792b870176f0d5" translate="yes" xml:space="preserve">
          <source>destroy( function (someItem) { return someItem.age &amp;lt; 18; } ) &amp;mdash; Finds any objects in the array whose age property is less than 18, and gives those objects a special property called _destroy with value true.</source>
          <target state="translated">destroy (function (someItem) {return someItem.age &amp;lt;18;}) &amp;mdash; 배열에서 age 속성이 18보다 작은 객체를 찾고 해당 객체에 true 값을 갖는 _destroy라는 특수 속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="096f0b56c9676c58652a45daacde73ceec0b98f6" translate="yes" xml:space="preserve">
          <source>destroy( someItem ) &amp;mdash; Finds any objects in the array that equal someItem and gives them a special property called _destroy with value true.</source>
          <target state="translated">destroy (someItem) &amp;mdash; 배열에서 someItem과 동일한 객체를 찾고 true 값을 가진 _destroy라는 특수 속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fad302ca93de39a8152dfd801b6995ae49e76427" translate="yes" xml:space="preserve">
          <source>destroyAll( ['Chad', 132, undefined] ) &amp;mdash; Finds any objects in the array that equal 'Chad', 123, or undefined and gives them a special property called _destroy with value true.</source>
          <target state="translated">destroyAll ([ 'Chad', 132, undefined]) &amp;mdash; 배열에서 'Chad', 123 또는 undefined 인 객체를 찾아서 true 값을 가진 _destroy라는 특수 속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0c040eb253b450db9af8ba7d1cc4c4ceed51a12c" translate="yes" xml:space="preserve">
          <source>destroyAll() &amp;mdash; Gives a special property called _destroy with value true to all objects in the array.</source>
          <target state="translated">destroyAll () &amp;mdash; 배열의 모든 객체에 true 값을 갖는 _destroy라는 특수 속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d92388626bd61574908cf24a5d84d7ffe24cba8a" translate="yes" xml:space="preserve">
          <source>disable binding</source>
          <target state="translated">바인딩 비활성화</target>
        </trans-unit>
        <trans-unit id="04f99f5aa32d4e1d11f627b6330ddd81b87c9a84" translate="yes" xml:space="preserve">
          <source>dispose() &amp;mdash; Manually disposes the computed observable, clearing all subscriptions to dependencies. This function is useful if you want to stop a computed observable from being updated or want to clean up memory for a computed observable that has dependencies on observables that won&amp;rsquo;t be cleaned.</source>
          <target state="translated">dispose () &amp;mdash; 계산 된 관찰 가능 항목을 수동으로 삭제하여 모든 구독을 종속성으로 지 웁니다. 이 기능은 계산 된 Observable의 업데이트를 중지하거나 정리되지 않는 Observable에 종속 된 계산 된 Observable의 메모리를 정리하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="02ed7cabc21681b07d4278e4c14c20d3a17e8b0b" translate="yes" xml:space="preserve">
          <source>disposeWhen &amp;mdash; Optional. If given, this function is executed before each re-evaluation to determine if the computed observable should be disposed. A true-ish result will trigger disposal of the computed observable.</source>
          <target state="translated">disposeWhen &amp;mdash; 선택 사항입니다. 주어진 경우,이 기능은 각 재평가 전에 실행되어 계산 된 관측 가능 물체가 폐기되어야하는지 결정합니다. 실제 결과는 계산 된 관측 가능 항목의 폐기를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="248f5cb9e1c627a7396078c4ffb6961606c2969b" translate="yes" xml:space="preserve">
          <source>disposeWhenNodeIsRemoved &amp;mdash; Optional. If given, disposal of the computed observable will be triggered when the specified DOM node is removed by KO. This feature is used to dispose computed observables used in bindings when nodes are removed by the template and control-flow bindings.</source>
          <target state="translated">disposeWhenNodeIsRemoved &amp;mdash; 선택 사항입니다. 주어진 경우 계산 된 관찰 가능 항목의 폐기는 지정된 DOM 노드가 KO에 의해 제거 될 때 트리거됩니다. 이 기능은 템플릿 및 제어 흐름 바인딩으로 노드를 제거 할 때 바인딩에 사용 된 계산 된 관찰 가능 항목을 처리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ee8eb5a2c228591905a3602312f95d5295c4df85" translate="yes" xml:space="preserve">
          <source>element &amp;mdash; The DOM element involved in this binding</source>
          <target state="translated">element &amp;mdash;이 바인딩에 관련된 DOM 요소</target>
        </trans-unit>
        <trans-unit id="4859f3f9258067e95015c5768146fc6fdd7df0af" translate="yes" xml:space="preserve">
          <source>enable binding</source>
          <target state="translated">바인딩 활성화</target>
        </trans-unit>
        <trans-unit id="a254fc2b2604547861a201222e9abc1f8f487b17" translate="yes" xml:space="preserve">
          <source>evaluator &amp;mdash; A function that is used to evaluate the computed observable&amp;rsquo;s current value.</source>
          <target state="translated">evaluator (평가자) &amp;mdash; 계산 된 관찰 가능 항목의 현재 값을 평가하는 데 사용되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="09016bc9005f501c49350459275e5548a714be1d" translate="yes" xml:space="preserve">
          <source>event binding</source>
          <target state="translated">이벤트 바인딩</target>
        </trans-unit>
        <trans-unit id="c3a2e9f3820a8e92022c44f759eb5cbd25a9a0ad" translate="yes" xml:space="preserve">
          <source>event handlers added by ko.utils.registerEventHandler including those bound by the event and click bindings</source>
          <target state="translated">이벤트 및 클릭 바인딩에 의해 바인딩 된 것을 포함하여 ko.utils.registerEventHandler에 의해 추가 된 이벤트 핸들러</target>
        </trans-unit>
        <trans-unit id="441a9b8c6e5fb83a5d5904e2015cace1348719af" translate="yes" xml:space="preserve">
          <source>extend(extenders) &amp;mdash; Applies the given &lt;a href=&quot;extenders&quot;&gt;extenders&lt;/a&gt; to the computed observable.</source>
          <target state="translated">extend (extenders) &amp;mdash; 주어진 &lt;a href=&quot;extenders&quot;&gt;익스텐더&lt;/a&gt; 를 계산 된 관찰 가능 객체 에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="cd71042eef75a46bae679bea017b7d3dfcc8efba" translate="yes" xml:space="preserve">
          <source>foreach &amp;mdash; instructs KO to render the template in &amp;ldquo;foreach&amp;rdquo; mode - see &lt;a href=&quot;#note-2-using-the-foreach-option-with-a-named-template&quot;&gt;Note 2&lt;/a&gt; for details.</source>
          <target state="translated">foreach &amp;mdash; KO가 &quot;foreach&quot;모드로 템플릿을 렌더링하도록 지시 합니다. 자세한 내용 은 &lt;a href=&quot;#note-2-using-the-foreach-option-with-a-named-template&quot;&gt;참고 2&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="23b634a4c77edfd882e83d6831db243e019ba4a5" translate="yes" xml:space="preserve">
          <source>foreach binding</source>
          <target state="translated">foreach 바인딩</target>
        </trans-unit>
        <trans-unit id="05900663008f6a8d4c17b3c024b26ac955efa734" translate="yes" xml:space="preserve">
          <source>getConfig(name, callback)</source>
          <target state="translated">getConfig (이름, 콜백)</target>
        </trans-unit>
        <trans-unit id="c490db1820ff63fc6b9af3cb9e098588f2dbf1da" translate="yes" xml:space="preserve">
          <source>getDependenciesCount() &amp;mdash; Returns the current number of dependencies of the computed observable.</source>
          <target state="translated">getDependenciesCount () &amp;mdash; 계산 된 관찰 가능 항목의 현재 종속성 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="84b6a1fc96c1619898d42781f47554a1b5f0de39" translate="yes" xml:space="preserve">
          <source>getDependenciesCount() &amp;mdash; Returns the number of dependencies of the computed observable detected so far during the current evaluation.</source>
          <target state="translated">getDependenciesCount () &amp;mdash; 현재 평가 중에 지금까지 탐지 된 계산 된 관찰 가능 항목의 종속성 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="92edb1e30abbee2fdc76356e034a41321e09a327" translate="yes" xml:space="preserve">
          <source>getSubscriptionsCount( [event] ) &amp;mdash; Returns the current number of subscriptions (either from other computed observables or manual subscriptions) of the computed observable. Optionally, pass an event name (like &quot;change&quot;) to return just the count of subscriptions for that event.</source>
          <target state="translated">getSubscriptionsCount ([event]) &amp;mdash; 계산 된 관찰 가능 항목의 현재 구독 수 (다른 계산 된 관찰 가능 항목 또는 수동 구독 중 하나)를 반환합니다. 선택적으로, 이벤트 이름 (예 : &quot;change&quot;)을 전달하여 해당 이벤트에 대한 구독 수만 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="e94c9d2e11930e54a96635c7830349bc8bbc5fc1" translate="yes" xml:space="preserve">
          <source>hasFocus binding</source>
          <target state="translated">hasFocus 바인딩</target>
        </trans-unit>
        <trans-unit id="78501003a54e9c53d78d928bcf94cf00a9b15734" translate="yes" xml:space="preserve">
          <source>html binding</source>
          <target state="translated">html 바인딩</target>
        </trans-unit>
        <trans-unit id="5767293ed1ea5a45170adafe80d616753ab89d4e" translate="yes" xml:space="preserve">
          <source>if &amp;mdash; if this parameter is provided, the template will only be rendered if the specified expression evaluates to true (or a true-ish value). This can be useful for preventing a null observable from being bound against a template before it is populated.</source>
          <target state="translated">if &amp;mdash;이 매개 변수가 제공되면 지정된 표현식이 true (또는 true-ish 값)로 평가되는 경우에만 템플리트가 렌더링됩니다. 이는 템플릿이 채워지기 전에 null 옵저버 블이 템플릿에 바인딩되지 않도록하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8595778a42da105c7c0cd044962a90ff2d28f8c7" translate="yes" xml:space="preserve">
          <source>if binding</source>
          <target state="translated">바인딩하는 경우</target>
        </trans-unit>
        <trans-unit id="703e05e02465cf23455e0519cadf7b85a6baeca8" translate="yes" xml:space="preserve">
          <source>if plays a similar role to &lt;a href=&quot;visible-binding&quot;&gt;the visible binding&lt;/a&gt;. The difference is that, with visible, the contained markup always remains in the DOM and always has its data-bind attributes applied - the visible binding just uses CSS to toggle the container element&amp;rsquo;s visiblity. The if binding, however, physically adds or removes the contained markup in your DOM, and only applies bindings to descendants if the expression is true.</source>
          <target state="translated">&lt;a href=&quot;visible-binding&quot;&gt;보이는 바인딩&lt;/a&gt; 과 비슷한 역할을 하는 경우 . 차이점은 보이는 경우 포함 된 마크 업은 항상 DOM에 유지되고 항상 데이터 바인딩 속성이 적용된다는 것입니다. 보이는 바인딩은 CSS를 사용하여 컨테이너 요소의 가시성을 전환합니다. 그러나 if 바인딩은 DOM에 포함 된 마크 업을 물리적으로 추가하거나 제거하며 표현식이 true 인 경우에만 하위 항목에 바인딩을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="369832115815305bb53a2b29db05f53365aa632e" translate="yes" xml:space="preserve">
          <source>ifnot binding</source>
          <target state="translated">바인딩하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="a35568315c1ca43522c11c18e4a77538f03287b9" translate="yes" xml:space="preserve">
          <source>indexOf</source>
          <target state="translated">indexOf</target>
        </trans-unit>
        <trans-unit id="16c8e78fdbe507804a784e42208f919531155c8d" translate="yes" xml:space="preserve">
          <source>isActive() &amp;mdash; Returns whether the computed observable may be updated in the future. A computed observable is inactive if it has no dependencies.</source>
          <target state="translated">isActive () &amp;mdash; 계산 된 관찰 가능 항목이 나중에 업데이트 될 수 있는지 여부를 반환합니다. 종속성이없는 경우 계산 된 관찰 가능 개체가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="213f712732355425bb5676b74b023984157a1fc1" translate="yes" xml:space="preserve">
          <source>isInitial() &amp;mdash; A function that returns true if called during the first ever evaluation of the current computed observable, or false otherwise. For &lt;em&gt;pure&lt;/em&gt; computed observables, isInitial() is always undefined.</source>
          <target state="translated">isInitial () &amp;mdash; 현재 계산 된 관찰 가능 항목을 처음 평가하는 동안 호출 된 경우 true를 반환하고 그렇지 않으면 false를 반환하는 함수입니다. 들어 &lt;em&gt;순수한&lt;/em&gt; 계산 된 관찰 가능한, isInitial ()는 항상 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87aad0bc78c46e535fc5dc0237fb0a38695c78b2" translate="yes" xml:space="preserve">
          <source>ko.bindingHandlers.&amp;lt;name&amp;gt;.preprocess(value, name, addBindingCallback)</source>
          <target state="translated">ko.bindingHandlers. &amp;lt;이름&amp;gt; .preprocess (값, 이름, addBindingCallback)</target>
        </trans-unit>
        <trans-unit id="3c1d83117feab81eede2624f7c5f8381d8978da6" translate="yes" xml:space="preserve">
          <source>ko.bindingProvider.instance.preprocessNode(node)</source>
          <target state="translated">ko.bindingProvider.instance.preprocessNode(node)</target>
        </trans-unit>
        <trans-unit id="055225b66db9860a7fdc32f9d0f603bb832d0cfd" translate="yes" xml:space="preserve">
          <source>ko.components.clearCachedDefinition(name)</source>
          <target state="translated">ko.components.clearCachedDefinition(name)</target>
        </trans-unit>
        <trans-unit id="7a279b97657226354a93afb2f4ea4220ffc22e79" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.getConfig(name, callback)</source>
          <target state="translated">ko.components.defaultLoader.getConfig (이름, 콜백)</target>
        </trans-unit>
        <trans-unit id="2459bd18ae1dc7e03d2b20bfd3bf5cb59b715afa" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.loadComponent(name, componentConfig, callback)</source>
          <target state="translated">ko.components.defaultLoader.loadComponent (이름, componentConfig, 콜백)</target>
        </trans-unit>
        <trans-unit id="16b20060cf28c63034230aa98ea10ad5f2365b12" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.loadTemplate(name, templateConfig, callback)</source>
          <target state="translated">ko.components.defaultLoader.loadTemplate (이름, templateConfig, 콜백)</target>
        </trans-unit>
        <trans-unit id="21a38533dd3c756e30cf34b8f8ccca46fa822259" translate="yes" xml:space="preserve">
          <source>ko.components.defaultLoader.loadViewModel(name, viewModelConfig, callback)</source>
          <target state="translated">ko.components.defaultLoader.loadViewModel (이름, viewModelConfig, 콜백)</target>
        </trans-unit>
        <trans-unit id="329d6b1d29362063e6c26807624b008e42dc8a23" translate="yes" xml:space="preserve">
          <source>ko.components.get(name, callback)</source>
          <target state="translated">ko.components.get (이름, 콜백)</target>
        </trans-unit>
        <trans-unit id="807267b5ea3ed18c0e6c441d7bbb7266de4efac9" translate="yes" xml:space="preserve">
          <source>ko.components.isRegistered(name)</source>
          <target state="translated">ko.components.isRegistered(name)</target>
        </trans-unit>
        <trans-unit id="465f62f6b74979963d9063914c13f8f93854ea91" translate="yes" xml:space="preserve">
          <source>ko.components.register(name, configuration)</source>
          <target state="translated">ko.components.register (이름, 구성)</target>
        </trans-unit>
        <trans-unit id="aa5bff0c09be54c216270b110f420a227104f8f0" translate="yes" xml:space="preserve">
          <source>ko.components.unregister(name)</source>
          <target state="translated">ko.components.unregister(name)</target>
        </trans-unit>
        <trans-unit id="eb0d870a4e6ad5b29fe16fcf4f027a7e968ff00b" translate="yes" xml:space="preserve">
          <source>ko.computed properties continue to receive notifications from their dependencies until explicitly disposed.</source>
          <target state="translated">ko.computed 속성은 명시 적으로 폐기 될 때까지 종속성에서 계속 알림을받습니다.</target>
        </trans-unit>
        <trans-unit id="9e8f7511dca3b06e70c9faf4aba9d6016334a4e6" translate="yes" xml:space="preserve">
          <source>ko.computed( evaluator [, targetObject, options] ) &amp;mdash; This form supports the most common case of creating a computed observable.</source>
          <target state="translated">ko.computed (evaluator [, targetObject, options]) &amp;mdash;이 양식은 계산 된 관찰 가능 객체를 만드는 가장 일반적인 경우를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b00774478c790a957ea39251a6fb67eafd152ac0" translate="yes" xml:space="preserve">
          <source>ko.computed( options ) &amp;mdash; This single parameter form for creating a computed observable accepts a JavaScript object with any of the following properties.</source>
          <target state="translated">ko.computed (options) &amp;mdash; 계산 된 관찰 가능 객체를 만들기위한이 단일 매개 변수 형식은 다음 속성 중 하나를 사용하여 JavaScript 객체를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="f1c20d087a46710430ae7e74a8957062cb722070" translate="yes" xml:space="preserve">
          <source>ko.computed.fn</source>
          <target state="translated">ko.computed.fn</target>
        </trans-unit>
        <trans-unit id="d26d19c3de9ae466805a8d659a3c953c8c1d0530" translate="yes" xml:space="preserve">
          <source>ko.contextFor(element) - returns the entire &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; that was available to the DOM element.</source>
          <target state="translated">ko.contextFor (element)-DOM 요소 에 사용 가능한 전체 &lt;a href=&quot;binding-context&quot;&gt;바인딩 컨텍스트&lt;/a&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="06265ae214e4c7ed0b5122f8c519271d97fbfb8c" translate="yes" xml:space="preserve">
          <source>ko.dataFor(element) - returns the data that was available for binding against the element</source>
          <target state="translated">ko.dataFor (element)-요소에 바인딩 할 수있는 데이터를 반환</target>
        </trans-unit>
        <trans-unit id="e5ab92cfd76820bc882d2a512801533d3821d30a" translate="yes" xml:space="preserve">
          <source>ko.isComputed &amp;mdash; returns true for all computed observables.</source>
          <target state="translated">ko.isComputed &amp;mdash; 모든 계산 된 관찰 가능 항목에 대해 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba0a8c1361fd16fa684b1945bb04a31e37a75289" translate="yes" xml:space="preserve">
          <source>ko.isObservable &amp;mdash; returns true for observables, observable arrays, and all computed observables.</source>
          <target state="translated">ko.isObservable &amp;mdash; 관찰 가능 항목, 관찰 가능 배열 및 모든 계산 된 관찰 가능 항목에 대해 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2d026a183086e8ab18f0fea90633d888febdc550" translate="yes" xml:space="preserve">
          <source>ko.isObservable - returns true for observables, observable arrays, and all computed observables.</source>
          <target state="translated">ko.isObservable-관찰 가능 항목, 관찰 가능 배열 및 모든 계산 된 관찰 가능 항목에 대해 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="33e63cd27e89b9898ebb8e10b0f17a0934ea8e48" translate="yes" xml:space="preserve">
          <source>ko.isPureComputed &amp;mdash; returns true for &lt;em&gt;pure&lt;/em&gt; computed observables.</source>
          <target state="translated">ko.isPureComputed &amp;mdash; &lt;em&gt;순수한&lt;/em&gt; 계산 된 관찰 가능 항목에 대해 true를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0c4edd7fa41dfb49e265401fb4e953fe2f59d5fb" translate="yes" xml:space="preserve">
          <source>ko.isWritableObservable &amp;mdash; returns true for observables, observable arrays, and &lt;em&gt;writable&lt;/em&gt; computed observables (also aliased as ko.isWriteableObservable).</source>
          <target state="translated">ko.isWritableObservable &amp;mdash; 관찰 가능 항목, 관찰 가능 배열 및 &lt;em&gt;쓰기 가능한&lt;/em&gt; 계산 가능 관찰 가능 항목 (ko.isWriteableObservable이라고도 함)에 대해 true를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="754ea921da81e0b6e8a76f19d21a38b2fd6b07b5" translate="yes" xml:space="preserve">
          <source>ko.isWritableObservable - returns true for observables, observable arrays, and writable computed observables (also aliased as ko.isWriteableObservable).</source>
          <target state="translated">ko.isWritableObservable-관찰 가능 항목, 관찰 가능 배열 및 쓰기 가능한 계산 가능 관찰 가능 항목 (ko.isWriteableObservable이라고도 함)에 대해 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e289a906e88ca4290e5d991a93f7c57b8c4684a6" translate="yes" xml:space="preserve">
          <source>ko.observable.fn</source>
          <target state="translated">ko.observable.fn</target>
        </trans-unit>
        <trans-unit id="dc9c8ae3fe7bb15035ebcb2f7a2ce4c354d592de" translate="yes" xml:space="preserve">
          <source>ko.observableArray.fn</source>
          <target state="translated">ko.observableArray.fn</target>
        </trans-unit>
        <trans-unit id="a6f5f5f281a8736bda725dd28aa8d5c4848f7ea9" translate="yes" xml:space="preserve">
          <source>ko.onError</source>
          <target state="translated">ko.onError</target>
        </trans-unit>
        <trans-unit id="106eda8827c7f9a29315d41770f83ea9dfec979e" translate="yes" xml:space="preserve">
          <source>ko.pureComputed( evaluator [, targetObject] ) &amp;mdash; Constructs a &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed observable&lt;/a&gt; using the given evaluator function and optional object to use for this. Unlike ko.computed, this method doesn&amp;rsquo;t accept an options parameter.</source>
          <target state="translated">ko.pureComputed (evaluator [, targetObject]) &amp;mdash; 주어진 평가 기 함수와이를 위해 사용할 선택적 객체를 사용하여 &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;순수한&lt;/em&gt; 계산 된 관찰 가능&lt;/a&gt; 객체를 구성합니다. ko.computed와 달리이 방법은 옵션 매개 변수를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7562774ba1edf2db877045ee696268509d532ef8" translate="yes" xml:space="preserve">
          <source>ko.pureComputed( options ) &amp;mdash; Constructs a &lt;em&gt;pure&lt;/em&gt; computed observable using an options object. This accepts the read, write, and owner options described above.</source>
          <target state="translated">ko.pureComputed (options) &amp;mdash; options 객체를 사용하여 &lt;em&gt;순수한&lt;/em&gt; 계산 된 관찰 가능 객체를 구성합니다. 위에서 설명한 읽기, 쓰기 및 소유자 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee34b3491247fbedc6018f48a7b0649bf286403f" translate="yes" xml:space="preserve">
          <source>ko.subscribable.fn</source>
          <target state="translated">ko.subscribable.fn</target>
        </trans-unit>
        <trans-unit id="15a6aefd0151368becbda1d0ee853e26ef3e063b" translate="yes" xml:space="preserve">
          <source>ko.tasks.runEarly() &amp;mdash; Call this method to process the current microtask queue on demand, immediately, until it is empty. Besides library integration, you might use this method if you have code that schedules a number of tasks, but then needs to deal with the effects of those tasks synchronously.</source>
          <target state="translated">ko.tasks.runEarly () &amp;mdash; 현재 마이크로 태스크 대기열이 비워 질 때까지 즉시 처리하려면이 메소드를 호출하십시오. 라이브러리 통합 외에도 여러 작업을 예약하는 코드가 있지만 해당 작업의 영향을 동 기적으로 처리해야하는 경우이 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faa0c0987272811d4ff86131601c71626df34cea" translate="yes" xml:space="preserve">
          <source>ko.tasks.scheduler &amp;mdash; Override this method to redefine or augment how Knockout schedules the event to process and flush the queue. Knockout calls this method when the first task is scheduled, so it must schedule the event and return immediately. For example, if your application is running in Node.js, you might prefer to use process.nextTick for the flush event: ko.tasks.scheduler = process.nextTick;.</source>
          <target state="translated">ko.tasks.scheduler &amp;mdash;이 방법을 재정 의하여 Knockout이 이벤트를 처리하고 큐를 플러시하도록 일정을 예약하는 방식을 재정의하거나 기능을 보강합니다. 녹아웃은 첫 번째 작업이 예약 될 때이 메서드를 호출하므로 이벤트를 예약하고 즉시 반환해야합니다. 예를 들어, 애플리케이션이 Node.js에서 실행중인 경우, 플러시 이벤트에 대해 process.nextTick을 사용하는 것이 좋습니다 (ko.tasks.scheduler = process.nextTick;).</target>
        </trans-unit>
        <trans-unit id="72f6e7831d1df86bc87ee07643b98cbfaffdbb89" translate="yes" xml:space="preserve">
          <source>ko.toJS &amp;mdash; this clones your view model&amp;rsquo;s object graph, substituting for each observable the current value of that observable, so you get a plain copy that contains only your data and no Knockout-related artifacts</source>
          <target state="translated">ko.toJS &amp;mdash; 뷰 모델의 객체 그래프를 복제하여 각 관측 가능 객체에 해당 관측 가능 값의 현재 값을 대치하여 데이터 만 포함하고 녹아웃 관련 아티팩트가없는 일반 사본을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="8f921b7a45abcec43b02a6601d9bdc280d40c78e" translate="yes" xml:space="preserve">
          <source>ko.toJSON &amp;mdash; this produces a JSON string representing your view model&amp;rsquo;s data. Internally, it simply calls ko.toJS on your view model, and then uses the browser&amp;rsquo;s native JSON serializer on the result. Note: for this to work on older browsers that have no native JSON serializer (e.g., IE 7 or earlier), you must also reference the &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt; library.</source>
          <target state="translated">ko.toJSON &amp;mdash; 뷰 모델의 데이터를 나타내는 JSON 문자열을 생성합니다. 내부적으로는 뷰 모델에서 ko.toJS를 호출 한 다음 결과에서 브라우저의 기본 JSON 직렬 변환기를 사용합니다. 참고 : 기본 JSON 시리얼 라이저 (예 : IE 7 이하)가없는 구형 브라우저에서 작동하려면 &lt;a href=&quot;https://github.com/douglascrockford/JSON-js/blob/master/json2.js&quot;&gt;json2.js&lt;/a&gt; 라이브러리 도 참조해야합니다 .</target>
        </trans-unit>
        <trans-unit id="738a8193c3e783c17d50280b2acff5c17c5363ce" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.allowedBindings</source>
          <target state="translated">ko.virtualElements.allowedBindings</target>
        </trans-unit>
        <trans-unit id="3fc144ac6a03bb72f185dbc31fd3e60209cdccfc" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.emptyNode(containerElem)</source>
          <target state="translated">ko.virtualElements.emptyNode(containerElem)</target>
        </trans-unit>
        <trans-unit id="16cb1a0760097250c1d6a57cda17df82d6a63922" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.firstChild(containerElem)</source>
          <target state="translated">ko.virtualElements.firstChild(containerElem)</target>
        </trans-unit>
        <trans-unit id="06073de57d46544971ccb6059851d47ea1ab2fec" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.insertAfter(containerElem, nodeToInsert, insertAfter)</source>
          <target state="translated">ko.virtualElements.insertAfter (containerElem, nodeToInsert, insertAfter)</target>
        </trans-unit>
        <trans-unit id="f0630dc3ec6d4f13606bdea53863015c2cb27263" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.nextSibling(node)</source>
          <target state="translated">ko.virtualElements.nextSibling(node)</target>
        </trans-unit>
        <trans-unit id="fe4347781b95d863c9d53b169d5a53b5a49663ac" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.prepend(containerElem, nodeToPrepend)</source>
          <target state="translated">ko.virtualElements.prepend (containerElem, nodeToPrepend)</target>
        </trans-unit>
        <trans-unit id="e6c8f2823abd2f761611dc1d03bd6be1f6b71b8e" translate="yes" xml:space="preserve">
          <source>ko.virtualElements.setDomNodeChildren(containerElem, arrayOfNodes)</source>
          <target state="translated">ko.virtualElements.setDomNodeChildren (containerElem, arrayOfNodes)</target>
        </trans-unit>
        <trans-unit id="53b7dfcb52da6b0ba4650716e4ca43082f5feafd" translate="yes" xml:space="preserve">
          <source>loadComponent(name, componentConfig, callback)</source>
          <target state="translated">loadComponent (이름, componentConfig, 콜백)</target>
        </trans-unit>
        <trans-unit id="62e20634e40fa347d5ad134f972b15f2c990a759" translate="yes" xml:space="preserve">
          <source>loadTemplate(name, templateConfig, callback)</source>
          <target state="translated">loadTemplate (이름, templateConfig, 콜백)</target>
        </trans-unit>
        <trans-unit id="41fe8394a06084fc87259bbd05c6e913daa937d7" translate="yes" xml:space="preserve">
          <source>loadViewModel(name, templateConfig, callback)</source>
          <target state="translated">loadViewModel (이름, templateConfig, 콜백)</target>
        </trans-unit>
        <trans-unit id="7080dbc7436a18db36408fd6a408608eee003c46" translate="yes" xml:space="preserve">
          <source>mappedDestroy</source>
          <target state="translated">mappedDestroy</target>
        </trans-unit>
        <trans-unit id="5136c37aaef9493efe3b449744ba2f34d4cdcc8b" translate="yes" xml:space="preserve">
          <source>mappedDestroyAll</source>
          <target state="translated">mappedDestroyAll</target>
        </trans-unit>
        <trans-unit id="99002c7fb8b1dacc2772e98e37f191c8d33a1256" translate="yes" xml:space="preserve">
          <source>mappedIndexOf</source>
          <target state="translated">mappedIndexOf</target>
        </trans-unit>
        <trans-unit id="14d1111fd891b47dbe5304a5bf26024c52b381cc" translate="yes" xml:space="preserve">
          <source>mappedRemove</source>
          <target state="translated">mappedRemove</target>
        </trans-unit>
        <trans-unit id="2dca0f36f8e0c0920d22300deffb28e503aeabf5" translate="yes" xml:space="preserve">
          <source>mappedRemoveAll</source>
          <target state="translated">mappedRemoveAll</target>
        </trans-unit>
        <trans-unit id="8615a2284a082e7284f964e699021504000797a2" translate="yes" xml:space="preserve">
          <source>name &amp;mdash; the ID of an element that contains the template you wish to render - see &lt;a href=&quot;#note-5-dynamically-choosing-which-template-is-used&quot;&gt;Note 5&lt;/a&gt; for how to vary this programmatically.</source>
          <target state="translated">name &amp;mdash; 렌더링하려는 템플릿이 포함 된 요소의 ID입니다 . 프로그래밍 방식으로 변경하는 방법 은 &lt;a href=&quot;#note-5-dynamically-choosing-which-template-is-used&quot;&gt;참고 5&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43ae5c03a40af9e524c7f17000f40eab0946953c" translate="yes" xml:space="preserve">
          <source>name &amp;mdash; the name of the component to inject. Again, this can be observable.</source>
          <target state="translated">name &amp;mdash; 주입 할 구성 요소의 이름입니다. 다시, 이것은 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="153b716a1c705fc7b577a6d6cc8234a6909f9cc0" translate="yes" xml:space="preserve">
          <source>name: the name of the binding (e.g., for yourBinding: 1 + 1, the name is &quot;yourBinding&quot; as a string).</source>
          <target state="translated">name : 바인딩의 이름입니다 (예 : yourBinding : 1 + 1의 경우 이름은 문자열로 &quot;yourBinding&quot;임).</target>
        </trans-unit>
        <trans-unit id="fd9f9671fef2600dc7d9a2e2f6ac58059c2cf1e5" translate="yes" xml:space="preserve">
          <source>nodes &amp;mdash; directly pass an array of DOM nodes to use as a template. This should be a non-observable array and note that the elements will be removed from their current parent if they have one. This option is ignored if you have also passed a nonempty value for name.</source>
          <target state="translated">노드 &amp;mdash; 템플릿으로 사용할 DOM 노드 배열을 직접 전달합니다. 이것은 관찰 할 수없는 배열이어야하며 요소가있는 경우 현재 부모에서 요소가 제거됩니다. name에 비어 있지 않은 값도 전달한 경우이 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ade2fb9bb0e21209a2280976a96721a3984afaaa" translate="yes" xml:space="preserve">
          <source>notifyAtFixedRate &amp;mdash; &lt;strong&gt;Default value if not otherwise specified&lt;/strong&gt;. The notification happens after the specified period of time from the first change to the observable (either initially or since the previous notification).</source>
          <target state="translated">notifyAtFixedRate &amp;mdash; &lt;strong&gt;달리 지정되지 않은 경우 기본값&lt;/strong&gt; 입니다. 알림은 첫 번째 변경에서 관찰 가능 항목으로 지정된 기간 (초기 또는 이전 알림 이후) 이후에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bfc6c7b444c24d6b64a8361cd00dc9091107de87" translate="yes" xml:space="preserve">
          <source>notifyWhenChangesStop &amp;mdash; The notification happens after no changes have occured to the observable for the specified period of time. Each time the observable changes, that timer is reset, so notifications cannot happen if the observable continuously changes more frequently than the timeout period.</source>
          <target state="translated">notifyWhenChangesStop &amp;mdash; 지정된 기간 동안 관찰 가능 항목에 대한 변경이 없으면 알림이 발생합니다. 관찰 가능 항목이 변경 될 때마다 해당 타이머가 재설정되므로 관찰 가능 대상이 시간 초과 기간보다 지속적으로 자주 변경되면 알림을받을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7cf7948331269132eb18cd16d74bca7c9656a62e" translate="yes" xml:space="preserve">
          <source>observable: If the property is an observable, this will be set to the actual observable</source>
          <target state="translated">관찰 가능 : 속성이 관찰 가능 인 경우 실제 관찰 가능으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3a12abbdbb90d2aa3b8a8824637963734fe18f32" translate="yes" xml:space="preserve">
          <source>observableArray adds some more useful methods that aren&amp;rsquo;t found on JavaScript arrays by default:</source>
          <target state="translated">observableArray는 기본적으로 JavaScript 배열에는없는 유용한 메소드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c136e98248f5a0b1e7844aac2ff24bd91872be37" translate="yes" xml:space="preserve">
          <source>observableArray exposes a familiar set of functions for modifying the contents of the array and notifying listeners.</source>
          <target state="translated">observableArray는 배열의 내용을 수정하고 리스너에게 알리는 익숙한 함수 집합을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d313002d790cf1264f49478e1a7e27592448f033" translate="yes" xml:space="preserve">
          <source>observableExpression</source>
          <target state="translated">observableExpression</target>
        </trans-unit>
        <trans-unit id="6ae20630c651e48135794f920e43f6369bd29f8f" translate="yes" xml:space="preserve">
          <source>options &amp;mdash; An object with further properties for the computed observable. See the full list below.</source>
          <target state="translated">옵션 &amp;mdash; 계산 된 관찰 가능 객체에 대한 추가 속성이있는 객체입니다. 아래의 전체 목록을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6f3cb718d8232f8095093bcd8b8ef4c1e83a310" translate="yes" xml:space="preserve">
          <source>options binding</source>
          <target state="translated">옵션 바인딩</target>
        </trans-unit>
        <trans-unit id="c200e46257cc25ebc5150d82eb3ee07b6e38447d" translate="yes" xml:space="preserve">
          <source>optionsAfterRender</source>
          <target state="translated">optionsAfterRender</target>
        </trans-unit>
        <trans-unit id="924bed9ee85f51893b937580ab61c608cdc93818" translate="yes" xml:space="preserve">
          <source>optionsCaption</source>
          <target state="translated">optionsCaption</target>
        </trans-unit>
        <trans-unit id="9dfa9e0a9830d2655b73d8d8deb5640b800c4037" translate="yes" xml:space="preserve">
          <source>optionsIncludeDestroyed</source>
          <target state="translated">optionsIncludeDestroyed</target>
        </trans-unit>
        <trans-unit id="8ae7670102147644c6634d485af1c1fc8805ccfb" translate="yes" xml:space="preserve">
          <source>optionsText</source>
          <target state="translated">optionsText</target>
        </trans-unit>
        <trans-unit id="0d2c0213a91bd297d264f544b41793b3cded6023" translate="yes" xml:space="preserve">
          <source>optionsValue</source>
          <target state="translated">optionsValue</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="98d78190e1c18c8409cc555525dba84fa833eb6e" translate="yes" xml:space="preserve">
          <source>owner &amp;mdash; Optional. If given, defines the value of this whenever KO invokes your read or write callbacks.</source>
          <target state="translated">owner &amp;mdash; 선택 사항입니다. 주어진 경우, KO가 읽기 또는 쓰기 콜백을 호출 할 때마다이 값을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="a07e95b0cdb77798a52385e0291f03fa5a033510" translate="yes" xml:space="preserve">
          <source>params &amp;mdash; an object that will be passed on to the component. Typically this is a key-value object containing multiple parameters, and is typically received by the component&amp;rsquo;s viewmodel constructor.</source>
          <target state="translated">params &amp;mdash; 구성 요소에 전달 될 객체입니다. 일반적으로 이것은 여러 매개 변수를 포함하는 키-값 객체이며 일반적으로 구성 요소의 viewmodel 생성자에 의해 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="29fca18badf74bcc82a52bdd8ab473f35ada2a92" translate="yes" xml:space="preserve">
          <source>parent: The parent object or array to which this child belongs</source>
          <target state="translated">parent :이 자식이 속한 부모 객체 또는 배열</target>
        </trans-unit>
        <trans-unit id="84e2aa7296151d313a34b5208e6160b57faaf939" translate="yes" xml:space="preserve">
          <source>peek() &amp;mdash; Returns the current value of the computed observable without creating a dependency (see the section on &lt;a href=&quot;computed-dependency-tracking#controlling-dependencies-using-peek&quot;&gt;peek&lt;/a&gt;).</source>
          <target state="translated">peek () &amp;mdash; 종속성을 만들지 않고 계산 된 관찰 가능 값의 현재 값을 반환합니다 ( &lt;a href=&quot;computed-dependency-tracking#controlling-dependencies-using-peek&quot;&gt;peek&lt;/a&gt; 섹션 참조 ).</target>
        </trans-unit>
        <trans-unit id="7eff74c13ae15cbc418dcf740fe5df3ce50f2c51" translate="yes" xml:space="preserve">
          <source>pop() &amp;mdash; Removes the last value from the array and returns it.</source>
          <target state="translated">pop () &amp;mdash; 배열에서 마지막 값을 제거하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ca69cbe02c25699e6ece62ec814d7791c4911c3" translate="yes" xml:space="preserve">
          <source>pop, push, shift, unshift, reverse, sort, splice</source>
          <target state="translated">팝, 푸시, 시프트, 언 시프트, 리버스, 정렬, 스플 라이스</target>
        </trans-unit>
        <trans-unit id="416e762665dd122de1e192dd764a4872244dd057" translate="yes" xml:space="preserve">
          <source>preprocessing</source>
          <target state="translated">preprocessing</target>
        </trans-unit>
        <trans-unit id="4a6b2f0003c223ed4373d59b9044c43a3b0ec52d" translate="yes" xml:space="preserve">
          <source>pure &amp;mdash; Optional. If this option is true, the computed observable will be set up as a &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed observable&lt;/a&gt;. This option is an alternative to the ko.pureComputed constructor.</source>
          <target state="translated">순수 &amp;mdash; 선택 사항입니다. 이 옵션이 true이면 계산 된 관찰 가능 개체는 &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;순수한&lt;/em&gt; 계산 된 관찰 가능 장치&lt;/a&gt; 로 설정됩니다 . 이 옵션은 ko.pureComputed 생성자의 대안입니다.</target>
        </trans-unit>
        <trans-unit id="8f36b390db7ad00f023d03c9a8e1cd34da7cea23" translate="yes" xml:space="preserve">
          <source>push( value ) &amp;mdash; Adds a new item to the end of array.</source>
          <target state="translated">push (value) &amp;mdash; 배열 끝에 새 항목을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e21048ba125aebf005126df579aa7d684aaa1216" translate="yes" xml:space="preserve">
          <source>rateLimit supports two parameter formats:</source>
          <target state="translated">rateLimit는 두 가지 매개 변수 형식을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="4139be45f16ffa0fe5e84f6cade922de5f51c46f" translate="yes" xml:space="preserve">
          <source>read &amp;mdash; Required. A function that is used to evaluate the computed observable&amp;rsquo;s current value.</source>
          <target state="translated">읽기 &amp;mdash; 필수. 계산 된 관측 값의 현재 값을 평가하는 데 사용되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="e718caf79a7fe0cf6a87d95cc2a7797870e5f1cc" translate="yes" xml:space="preserve">
          <source>remove and removeAll</source>
          <target state="translated">제거 및 모두 제거</target>
        </trans-unit>
        <trans-unit id="96d8e0f211ec9e71e2ecd7b8f3e6fa85b82a0938" translate="yes" xml:space="preserve">
          <source>remove( function (item) { return item.age &amp;lt; 18; } ) &amp;mdash; Removes all values whose age property is less than 18, and returns them as an array.</source>
          <target state="translated">remove (function (item) {return item.age &amp;lt;18;}) &amp;mdash; age 속성이 18보다 작은 모든 값을 제거하고 배열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8cb74b9b1b5503e58de979117dcb56a32521b991" translate="yes" xml:space="preserve">
          <source>remove( someItem ) &amp;mdash; Removes all values that equal someItem and returns them as an array.</source>
          <target state="translated">remove (someItem) &amp;mdash; someItem과 동일한 모든 값을 제거하고 배열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d5ddbae3af08573d9f04a58584e212e1b3b6b7e" translate="yes" xml:space="preserve">
          <source>removeAll( ['Chad', 132, undefined] ) &amp;mdash; Removes all values that equal 'Chad', 123, or undefined and returns them as an array.</source>
          <target state="translated">removeAll ([ 'Chad', 132, undefined]) &amp;mdash; 'Chad', 123 또는 undefined와 같은 모든 값을 제거하고 배열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cc7eba478a0fbf207e7ee5a77ca70f0bbffef7c8" translate="yes" xml:space="preserve">
          <source>removeAll() &amp;mdash; Removes all values and returns them as an array.</source>
          <target state="translated">removeAll () &amp;mdash; 모든 값을 제거하고 배열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0478604d4aea96fd3a393109a2b1037b3e927fd" translate="yes" xml:space="preserve">
          <source>reverse() &amp;mdash; Reverses the order of the array and returns the observableArray (not the underlying array).</source>
          <target state="translated">reverse () &amp;mdash; 배열의 순서를 반대로 바꾸고 observableArray (기본 배열이 아님)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="59f2d78389675b86fdc3ff8aa20480298ed96edf" translate="yes" xml:space="preserve">
          <source>scripts/appViewModel.js</source>
          <target state="translated">scripts/appViewModel.js</target>
        </trans-unit>
        <trans-unit id="3d86e3a05ce2d4beabae39286b9e1f21797e0cc4" translate="yes" xml:space="preserve">
          <source>scripts/init.js</source>
          <target state="translated">scripts/init.js</target>
        </trans-unit>
        <trans-unit id="8ca245bc231e1ea924af9ce333849af65afcced1" translate="yes" xml:space="preserve">
          <source>selectedOptions</source>
          <target state="translated">selectedOptions</target>
        </trans-unit>
        <trans-unit id="0cc4bc27e43d8c540c56bb29619529b32d7e1d78" translate="yes" xml:space="preserve">
          <source>selectedOptions binding</source>
          <target state="translated">selectedOptions 바인딩</target>
        </trans-unit>
        <trans-unit id="c1de595d71ffb6e5bfd55b59347f3a99defa5aa3" translate="yes" xml:space="preserve">
          <source>setInterval callbacks will continue to fire until explicitly cleared.</source>
          <target state="translated">setInterval 콜백은 명시 적으로 지울 때까지 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0e0977525af7bb738c2d7f294371eb114a5f9172" translate="yes" xml:space="preserve">
          <source>shift() &amp;mdash; Removes the first value from the array and returns it.</source>
          <target state="translated">shift () &amp;mdash; 배열에서 첫 번째 값을 제거하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="88fbb170c082bb72bb147471c70547512b13611a" translate="yes" xml:space="preserve">
          <source>simpleExpression</source>
          <target state="translated">simpleExpression</target>
        </trans-unit>
        <trans-unit id="88f11ced9c5850c42b7ad4f6655dbd9d58dbd3c2" translate="yes" xml:space="preserve">
          <source>simpleObservable</source>
          <target state="translated">simpleObservable</target>
        </trans-unit>
        <trans-unit id="0a5228e66df38e2f27ca61b901edf86f7ef97fb8" translate="yes" xml:space="preserve">
          <source>slice</source>
          <target state="translated">slice</target>
        </trans-unit>
        <trans-unit id="56ab5e4c42113718cabb807a70d36218e826aaf4" translate="yes" xml:space="preserve">
          <source>sort() &amp;mdash; Sorts the array contents and returns the observableArray.</source>
          <target state="translated">sort () &amp;mdash; 배열 내용을 정렬하고 observableArray를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="42b90ae0a8b7cade6771bd136b879de650e1c97a" translate="yes" xml:space="preserve">
          <source>splice() &amp;mdash; Removes and returns a given number of elements starting from a given index. For example, myObservableArray.splice(1, 3) removes three elements starting from index position 1 (i.e., the 2nd, 3rd, and 4th elements) and returns them as an array.</source>
          <target state="translated">splice () &amp;mdash; 주어진 색인에서 시작하여 주어진 수의 요소를 제거하고 반환합니다. 예를 들어, myObservableArray.splice (1, 3)은 인덱스 위치 1에서 시작하는 세 가지 요소 (예 : 두 번째, 세 번째 및 네 번째 요소)를 제거하고 배열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6253e860960f6bbaedffe4b667c89e216110d409" translate="yes" xml:space="preserve">
          <source>style binding</source>
          <target state="translated">스타일 바인딩</target>
        </trans-unit>
        <trans-unit id="8779e91de4557c0e390ed1fb33b2e709310a78a8" translate="yes" xml:space="preserve">
          <source>submit binding</source>
          <target state="translated">바인딩 제출</target>
        </trans-unit>
        <trans-unit id="820fbe076d0fd7d9855c3332a110247db7d06ef6" translate="yes" xml:space="preserve">
          <source>subscribe( callback [,callbackTarget, event] ) &amp;mdash; Registers a &lt;a href=&quot;observables#explicitly-subscribing-to-observables&quot;&gt;manual subscription&lt;/a&gt; to be notified of changes to the computed observable.</source>
          <target state="translated">subscribe (callback [, callbackTarget, event]) &amp;mdash; 계산 된 관찰 가능 항목에 대한 변경 사항을 &lt;a href=&quot;observables#explicitly-subscribing-to-observables&quot;&gt;알리기&lt;/a&gt; 위해 수동 구독 을 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="dafd82441d770fee53da532cf0cc778383385fe6" translate="yes" xml:space="preserve">
          <source>targetObject &amp;mdash; If given, defines the value of this whenever KO invokes your callback functions. See the section on &lt;a href=&quot;computedobservables#managing-this&quot;&gt;managing this&lt;/a&gt; for more information.</source>
          <target state="translated">targetObject &amp;mdash; 주어진 경우 KO가 콜백 함수를 호출 할 때마다이 값을 정의합니다. 자세한 내용은 &lt;a href=&quot;computedobservables#managing-this&quot;&gt;이&lt;/a&gt; 를 관리 하는 섹션 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3c94ad78a19fe31d36596c68497f86eec7b1c3d9" translate="yes" xml:space="preserve">
          <source>template - &lt;strong&gt;Required.&lt;/strong&gt; An array of DOM nodes</source>
          <target state="translated">템플릿- &lt;strong&gt;필수. &lt;/strong&gt;DOM 노드의 배열</target>
        </trans-unit>
        <trans-unit id="253d1a2eda05db9287d0590f7c3d7acab99953a0" translate="yes" xml:space="preserve">
          <source>template binding</source>
          <target state="translated">템플릿 바인딩</target>
        </trans-unit>
        <trans-unit id="6e4853d9a9512e127ea4b62e7f52af33fc271c3f" translate="yes" xml:space="preserve">
          <source>template is required, and can take any of &lt;a href=&quot;#specifying-a-template&quot;&gt;the template formats described below&lt;/a&gt;.</source>
          <target state="translated">템플릿이 필요하며 &lt;a href=&quot;#specifying-a-template&quot;&gt;아래 설명 된 템플릿 형식을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da65429399cce754285fdbcec2552149cb86a956" translate="yes" xml:space="preserve">
          <source>text binding</source>
          <target state="translated">텍스트 바인딩</target>
        </trans-unit>
        <trans-unit id="adf56df0f3eb83ef4e28a07bf6ef6a5225f02b82" translate="yes" xml:space="preserve">
          <source>textInput binding</source>
          <target state="translated">textInput 바인딩</target>
        </trans-unit>
        <trans-unit id="b2b2c593b67fd9c750a7b4dc7bc74905c48586e7" translate="yes" xml:space="preserve">
          <source>uniqueName binding</source>
          <target state="translated">uniqueName 바인딩</target>
        </trans-unit>
        <trans-unit id="c16c416b43e2a2e26766a7d93713d6642892d606" translate="yes" xml:space="preserve">
          <source>unshift( value ) &amp;mdash; Inserts a new item at the beginning of the array.</source>
          <target state="translated">unshift (value) &amp;mdash; 배열의 시작 부분에 새 항목을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="69376c529d40f826b3d0595aee8c136c0af54867" translate="yes" xml:space="preserve">
          <source>value binding</source>
          <target state="translated">가치 바인딩</target>
        </trans-unit>
        <trans-unit id="e7253474b4d3ffd33c594b51d8119d43a0bb6bba" translate="yes" xml:space="preserve">
          <source>value, by default, only updates your model when the user moves focus out of the text box. textInput updates your model immediately on each keystroke or other text entry mechanism (such as cutting or dragging text, which don&amp;rsquo;t necessarily raise any focus change events).</source>
          <target state="translated">값은 기본적으로 사용자가 텍스트 상자 밖으로 포커스를 이동할 때만 모델을 업데이트합니다. textInput은 각 키 스트로크 또는 기타 텍스트 입력 메커니즘 (예 : 포커스 변경 이벤트를 발생시키지 않는 텍스트 잘라 내기 또는 드래그)에서 모델을 즉시 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="0315000a3f53e1c0a46b78819975a5d6ad678ede" translate="yes" xml:space="preserve">
          <source>value: the syntax associated with the binding value before Knockout attempts to parse it (e.g., for yourBinding: 1 + 1, the associated value is &quot;1 + 1&quot; as a string).</source>
          <target state="translated">value : Knockout이 구문 분석을 시도하기 전에 바인딩 값과 관련된 구문입니다 (예 : yourBinding : 1 + 1의 경우 관련 값은 문자열로 &quot;1 + 1&quot;임).</target>
        </trans-unit>
        <trans-unit id="4c6bf64e230167a81d331f0e53be657f29268a03" translate="yes" xml:space="preserve">
          <source>valueAccessor &amp;mdash; A JavaScript function that you can call to get the current model property that is involved in this binding. Call this without passing any parameters (i.e., call valueAccessor()) to get the current model property value. To easily accept both observable and plain values, call ko.unwrap on the returned value.</source>
          <target state="translated">valueAccessor &amp;mdash;이 바인딩과 관련된 현재 모델 속성을 얻기 위해 호출 할 수있는 JavaScript 함수입니다. 매개 변수 (예 : call valueAccessor ())를 전달하지 않고이를 호출하여 현재 모델 특성 값을 가져 오십시오. 관찰 가능 값과 일반 값을 쉽게 허용하려면 반환 된 값에 대해 ko.unwrap을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="09d6bee9bf5ab035edcf3bdb1c2d3ca252cab50d" translate="yes" xml:space="preserve">
          <source>valueAllowUnset</source>
          <target state="translated">valueAllowUnset</target>
        </trans-unit>
        <trans-unit id="3b9eeb08f6cc0027bfae1d6ae33f6eec82fa4980" translate="yes" xml:space="preserve">
          <source>valueUpdate</source>
          <target state="translated">valueUpdate</target>
        </trans-unit>
        <trans-unit id="85d24d98408f285817ccc63b116e75becf9bfb63" translate="yes" xml:space="preserve">
          <source>viewModel &amp;mdash; This parameter is deprecated in Knockout 3.x. Use bindingContext.$data or bindingContext.$rawData to access the view model instead.</source>
          <target state="translated">viewModel &amp;mdash;이 매개 변수는 Knockout 3.x에서 더 이상 사용되지 않습니다. 대신 viewContext에 액세스하려면 bindingContext. $ data 또는 bindingContext. $ rawData를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7d9112700ef264af454bd57cf55fc6e70b23ecbc" translate="yes" xml:space="preserve">
          <source>viewModel is optional, and can take any of &lt;a href=&quot;#specifying-a-viewmodel&quot;&gt;the viewModel formats described below&lt;/a&gt;.</source>
          <target state="translated">viewModel은 선택 사항이며 &lt;a href=&quot;#specifying-a-viewmodel&quot;&gt;아래 설명 된 viewModel 형식을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7eea042fe202adb1f0ad66ed57626d9b9dcd238a" translate="yes" xml:space="preserve">
          <source>visible binding</source>
          <target state="translated">눈에 보이는 바인딩</target>
        </trans-unit>
        <trans-unit id="012cd28b54d4dcfd92ef8c4dccc2bb3476547a20" translate="yes" xml:space="preserve">
          <source>with binding</source>
          <target state="translated">바인딩</target>
        </trans-unit>
        <trans-unit id="342fd4ebade4bf72ed7582148a5b0cdbca608bfe" translate="yes" xml:space="preserve">
          <source>write &amp;mdash; Optional. If given, makes the computed observable &lt;em&gt;writable&lt;/em&gt;. This is a function that receives values that other code is trying to write to your computed observable. It&amp;rsquo;s up to you to supply custom logic to handle the incoming values, typically by writing the values to some underlying observable(s).</source>
          <target state="translated">쓰기 &amp;mdash; 선택 사항입니다. 주어진 경우, 계산 된 관찰 &lt;em&gt;가능 쓰기 가능&lt;/em&gt; 하게합니다 . 다른 코드가 계산 된 관찰 가능 객체에 쓰려고하는 값을받는 함수입니다. 들어오는 값을 처리하기위한 사용자 지정 논리를 제공하는 것은 전적으로 사용자에게 달려 있습니다. 일반적으로 일부 기본 관찰 가능 값에 값을 작성합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
