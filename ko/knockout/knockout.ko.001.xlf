<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="knockout">
    <body>
      <group id="knockout">
        <trans-unit id="55f7a75bfb6b682f736e46b92c2f236aae124e0e" translate="yes" xml:space="preserve">
          <source>&quot;afterkeydown&quot; - updates your view model as soon as the user begins typing a character. This works by catching the browser&amp;rsquo;s keydown event and handling the event asynchronously. This does not work in some mobile browsers.</source>
          <target state="translated">&quot;afterkeydown&quot; - updates your view model as soon as the user begins typing a character. This works by catching the browser&amp;rsquo;s keydown event and handling the event asynchronously. This does not work in some mobile browsers.</target>
        </trans-unit>
        <trans-unit id="9bf88a9f967d7e0a2ecb9a2c3cb373e62550ca35" translate="yes" xml:space="preserve">
          <source>&quot;input&quot; - updates your view model when the value of an &amp;lt;input&amp;gt; or &amp;lt;textarea&amp;gt; element changes. Note that this event is only raised by reasonably modern browsers (e.g., IE 9+).</source>
          <target state="translated">&quot;input&quot; - updates your view model when the value of an &amp;lt;input&amp;gt; or &amp;lt;textarea&amp;gt; element changes. Note that this event is only raised by reasonably modern browsers (e.g., IE 9+).</target>
        </trans-unit>
        <trans-unit id="43249745c4adbf35a9cb9922652997d87dbe4042" translate="yes" xml:space="preserve">
          <source>&quot;keypress&quot; - updates your view model when the user has typed a key. Unlike keyup, this updates repeatedly while the user holds a key down</source>
          <target state="translated">&quot;keypress&quot; - updates your view model when the user has typed a key. Unlike keyup, this updates repeatedly while the user holds a key down</target>
        </trans-unit>
        <trans-unit id="754a19ddfd1580a60ebdb60a67460f4ed1868828" translate="yes" xml:space="preserve">
          <source>&quot;keyup&quot; - updates your view model when the user releases a key</source>
          <target state="translated">&quot;keyup&quot; - updates your view model when the user releases a key</target>
        </trans-unit>
        <trans-unit id="e067625ca975ca350ad14ef24cf6b1eeeb932ab7" translate="yes" xml:space="preserve">
          <source>$component</source>
          <target state="translated">$component</target>
        </trans-unit>
        <trans-unit id="f27c0d6823b43be383afbf56a525fa3e7b5bca08" translate="yes" xml:space="preserve">
          <source>$componentTemplateNodes</source>
          <target state="translated">$componentTemplateNodes</target>
        </trans-unit>
        <trans-unit id="b4aa877f2150e2e324627c78466629fcce97867e" translate="yes" xml:space="preserve">
          <source>$context</source>
          <target state="translated">$context</target>
        </trans-unit>
        <trans-unit id="461e9bac5c124e13e943d74294b5b3c23e91e59a" translate="yes" xml:space="preserve">
          <source>$data</source>
          <target state="translated">$data</target>
        </trans-unit>
        <trans-unit id="8d42409e40e4019fe1ad3970dab02ce54792984f" translate="yes" xml:space="preserve">
          <source>$element</source>
          <target state="translated">$element</target>
        </trans-unit>
        <trans-unit id="a7455dbeff981624c8fd90602ba9b39d8a3236fe" translate="yes" xml:space="preserve">
          <source>$index (only available within foreach bindings)</source>
          <target state="translated">$index (only available within foreach bindings)</target>
        </trans-unit>
        <trans-unit id="45e7737b5f1d96d16a40213881d84a2a492be556" translate="yes" xml:space="preserve">
          <source>$parent</source>
          <target state="translated">$parent</target>
        </trans-unit>
        <trans-unit id="95e2237aee892666510550fbfab5413dc3d3c57a" translate="yes" xml:space="preserve">
          <source>$parentContext</source>
          <target state="translated">$parentContext</target>
        </trans-unit>
        <trans-unit id="551e29188e6f391357b84d891bae6ddf016d5ab0" translate="yes" xml:space="preserve">
          <source>$parents</source>
          <target state="translated">$parents</target>
        </trans-unit>
        <trans-unit id="f68b486675e88b186e3e5d97a647fbca76132e19" translate="yes" xml:space="preserve">
          <source>$parents[0] is the view model from the parent context (i.e., it&amp;rsquo;s the same as $parent)</source>
          <target state="translated">$parents[0] is the view model from the parent context (i.e., it&amp;rsquo;s the same as $parent)</target>
        </trans-unit>
        <trans-unit id="65c4ecaa451b9f437d3935b91802b54bbb000546" translate="yes" xml:space="preserve">
          <source>$parents[1] is the view model from the grandparent context</source>
          <target state="translated">$parents[1] is the view model from the grandparent context</target>
        </trans-unit>
        <trans-unit id="3cdd4ec57af42ab07ce806176c82747601207768" translate="yes" xml:space="preserve">
          <source>$parents[2] is the view model from the great-grandparent context</source>
          <target state="translated">$parents[2] is the view model from the great-grandparent context</target>
        </trans-unit>
        <trans-unit id="7efb9bde8c0dcb7c458231902442f2ac06b5d48e" translate="yes" xml:space="preserve">
          <source>$rawData</source>
          <target state="translated">$rawData</target>
        </trans-unit>
        <trans-unit id="b764ba81776db6e2c0d3c795e5f0fb4f7b3b3158" translate="yes" xml:space="preserve">
          <source>$root</source>
          <target state="translated">$root</target>
        </trans-unit>
        <trans-unit id="281a6ce7dc200bc3ee6a1f7a74996c60f02fadb8" translate="yes" xml:space="preserve">
          <source>&amp;copy; Steven Sanderson, the Knockout.js team, and other contributors</source>
          <target state="translated">&amp;copy; Steven Sanderson, the Knockout.js team, and other contributors</target>
        </trans-unit>
        <trans-unit id="a48ee17c964423bf4cc960d5d152f164fe712d06" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and IE 6 renders no whitespace before the words to our web site, you can avoid the problem by putting any text into the &amp;lt;span&amp;gt;, e.g.:</source>
          <target state="translated">&amp;hellip; and IE 6 renders no whitespace before the words to our web site, you can avoid the problem by putting any text into the &amp;lt;span&amp;gt;, e.g.:</target>
        </trans-unit>
        <trans-unit id="e27c42ca2533fdefaeb58cc1b7eb45a5f42080eb" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and define a corresponding function on your view model (i.e., the object that contains myData):</source>
          <target state="translated">&amp;hellip; and define a corresponding function on your view model (i.e., the object that contains myData):</target>
        </trans-unit>
        <trans-unit id="98e4a9ac6cd86f6006efcb5074a7cfc4a95acc99" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and so on.</source>
          <target state="translated">&amp;hellip; and so on.</target>
        </trans-unit>
        <trans-unit id="5a844d0606e2cebac6157c81cc9a6f5ca56660d6" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and the following custom loader will take care of loading viewmodels configured with a viaLoader value:</source>
          <target state="translated">&amp;hellip; and the following custom loader will take care of loading viewmodels configured with a viaLoader value:</target>
        </trans-unit>
        <trans-unit id="2392c33f696700587811efee0b525c35b66a8113" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and the template markup is in the file path/my-component.html, then you have these benefits:</source>
          <target state="translated">&amp;hellip; and the template markup is in the file path/my-component.html, then you have these benefits:</target>
        </trans-unit>
        <trans-unit id="306ad3adf4c6d524c866e2da9e33f77bb76e411e" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and then you can use it on any number of DOM elements:</source>
          <target state="translated">&amp;hellip; and then you can use it on any number of DOM elements:</target>
        </trans-unit>
        <trans-unit id="1d1269190ed98d387c971daefbe0a562031c6ac7" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and they will be updated whenever firstName or lastName changes (your evaluator function will be called once each time any of its dependencies change, and whatever value you return will be passed on to the observers such as UI elements or other computed observables).</source>
          <target state="translated">&amp;hellip; and they will be updated whenever firstName or lastName changes (your evaluator function will be called once each time any of its dependencies change, and whatever value you return will be passed on to the observers such as UI elements or other computed observables).</target>
        </trans-unit>
        <trans-unit id="f0e6d69780be5a001171b8e0891626e76815b8cb" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and you can do so using custom loaders.</source>
          <target state="translated">&amp;hellip; and you can do so using custom loaders.</target>
        </trans-unit>
        <trans-unit id="c678b47361f53960d600a49f5e2a49ab33bf1efb" translate="yes" xml:space="preserve">
          <source>&amp;hellip; assuming that someProperty is &lt;em&gt;observable&lt;/em&gt; and hence you need to invoke it as a function to obtain the current value.</source>
          <target state="translated">&amp;hellip; assuming that someProperty is &lt;em&gt;observable&lt;/em&gt; and hence you need to invoke it as a function to obtain the current value.</target>
        </trans-unit>
        <trans-unit id="436bfbadf0d7e3d2acd161b36e9fa6c0aee1ca68" translate="yes" xml:space="preserve">
          <source>&amp;hellip; because data-something isn&amp;rsquo;t a legal identifier name at that point. The solution is simple: just wrap the identifier name in quotes so that it becomes a string literal, which is legal in a JavaScript object literal. For example,</source>
          <target state="translated">&amp;hellip; because data-something isn&amp;rsquo;t a legal identifier name at that point. The solution is simple: just wrap the identifier name in quotes so that it becomes a string literal, which is legal in a JavaScript object literal. For example,</target>
        </trans-unit>
        <trans-unit id="d96ec87b990d2a5f05fcb8d21bf32f55812f3e19" translate="yes" xml:space="preserve">
          <source>&amp;hellip; because my-class isn&amp;rsquo;t a legal identifier name at that point. The solution is simple: just wrap the identifier name in quotes so that it becomes a string literal, which is legal in a JavaScript object literal. For example,</source>
          <target state="translated">&amp;hellip; because my-class isn&amp;rsquo;t a legal identifier name at that point. The solution is simple: just wrap the identifier name in quotes so that it becomes a string literal, which is legal in a JavaScript object literal. For example,</target>
        </trans-unit>
        <trans-unit id="e308fd02d63129d37593963615074a07790d41e5" translate="yes" xml:space="preserve">
          <source>&amp;hellip; but you don&amp;rsquo;t have to, because firstName will be evaluated within the context of $data by default anyway.</source>
          <target state="translated">&amp;hellip; but you don&amp;rsquo;t have to, because firstName will be evaluated within the context of $data by default anyway.</target>
        </trans-unit>
        <trans-unit id="6dd0331bbbc30c917af2ce818fb5586d7cecd6f7" translate="yes" xml:space="preserve">
          <source>&amp;hellip; can be injected with:</source>
          <target state="translated">&amp;hellip; can be injected with:</target>
        </trans-unit>
        <trans-unit id="7f3a7cb698f6c8ba821554005a2fe7438261aff6" translate="yes" xml:space="preserve">
          <source>&amp;hellip; can be used as the template for a component by specifying its ID:</source>
          <target state="translated">&amp;hellip; can be used as the template for a component by specifying its ID:</target>
        </trans-unit>
        <trans-unit id="9ddd2ca25a0f65763e8a310b7c6de249963ba2b7" translate="yes" xml:space="preserve">
          <source>&amp;hellip; is equivalent to the following:</source>
          <target state="translated">&amp;hellip; is equivalent to the following:</target>
        </trans-unit>
        <trans-unit id="fd4393ed67ac1cfb24dad9cf459b5a8aa896d33c" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or a createViewModel function, e.g.:</source>
          <target state="translated">&amp;hellip; or a createViewModel function, e.g.:</target>
        </trans-unit>
        <trans-unit id="4445358862216b92eb56a5a61275070dfed5150b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or a shared object instance, e.g.:</source>
          <target state="translated">&amp;hellip; or a shared object instance, e.g.:</target>
        </trans-unit>
        <trans-unit id="9f9f2be5a24b6d2be93f0a540aa1c45603b7e12d" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or any of the other forms described here, though it would be unusual for the others to be useful when fetching templates via AMD.</source>
          <target state="translated">&amp;hellip; or any of the other forms described here, though it would be unusual for the others to be useful when fetching templates via AMD.</target>
        </trans-unit>
        <trans-unit id="dfd09f5a0fc940760751819d925befbc4f3884f0" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or even, though it&amp;rsquo;s unlikely you&amp;rsquo;d want to do this, a reference to a different AMD module, e.g.:</source>
          <target state="translated">&amp;hellip; or even, though it&amp;rsquo;s unlikely you&amp;rsquo;d want to do this, a reference to a different AMD module, e.g.:</target>
        </trans-unit>
        <trans-unit id="76deaf0467a8d01ce5fda8253ca2bf94e5c1d09f" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or passing parameters:</source>
          <target state="translated">&amp;hellip; or passing parameters:</target>
        </trans-unit>
        <trans-unit id="c8dde18842940735246b96ebc2b6801af0bff816" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or you can send data to the server:</source>
          <target state="translated">&amp;hellip; or you can send data to the server:</target>
        </trans-unit>
        <trans-unit id="83dd09db0bbbaf75986c9f14324dd51a6c7b3c2b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or, more conveniently, as a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;:</source>
          <target state="translated">&amp;hellip; or, more conveniently, as a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="9a0cac50f6e17cb0207d461cfe3eadb4c1cb5b0b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; the component viewmodel&amp;rsquo;s params parameter will contain three values:</source>
          <target state="translated">&amp;hellip; the component viewmodel&amp;rsquo;s params parameter will contain three values:</target>
        </trans-unit>
        <trans-unit id="d03a96e5ee2c9a78e87d9468f59e17ba046629a1" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then see &lt;a href=&quot;custom-bindings-for-virtual-elements&quot;&gt;the documentation for virtual elements&lt;/a&gt;.</source>
          <target state="translated">&amp;hellip; then see &lt;a href=&quot;custom-bindings-for-virtual-elements&quot;&gt;the documentation for virtual elements&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="8eb4b5f8187f3ef64e228acdde18a278aa6c4f55" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then upperCaseName will be recomputed immediately, before your next line of code runs. But if you instead define name using rateLimit as follows:</source>
          <target state="translated">&amp;hellip; then upperCaseName will be recomputed immediately, before your next line of code runs. But if you instead define name using rateLimit as follows:</target>
        </trans-unit>
        <trans-unit id="d6d1fbc554c515663655cf7715837ed5aa4d192b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then upperCaseName will not be recomputed immediately when name changes&amp;mdash;instead, name will wait for 500 milliseconds (half a second) before notifying its new value to upperCaseName, which will then recompute its value. No matter how many times name is changed during those 500 ms, upperCaseName will only be updated once with the most recent value.</source>
          <target state="translated">&amp;hellip; then upperCaseName will not be recomputed immediately when name changes&amp;mdash;instead, name will wait for 500 milliseconds (half a second) before notifying its new value to upperCaseName, which will then recompute its value. No matter how many times name is changed during those 500 ms, upperCaseName will only be updated once with the most recent value.</target>
        </trans-unit>
        <trans-unit id="6b92e76aa3ffd11c41f69f8adf6378acda520d0e" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then you&amp;rsquo;ll get the error The binding 'randomOrder' cannot be used with virtual elements. Let&amp;rsquo;s fix this. To make randomOrder usable with virtual elements, start by telling Knockout to allow it. Add the following:</source>
          <target state="translated">&amp;hellip; then you&amp;rsquo;ll get the error The binding 'randomOrder' cannot be used with virtual elements. Let&amp;rsquo;s fix this. To make randomOrder usable with virtual elements, start by telling Knockout to allow it. Add the following:</target>
        </trans-unit>
        <trans-unit id="80d023722c8262c22ad3fc675542d06cee7a10d4" translate="yes" xml:space="preserve">
          <source>&amp;hellip; this would &lt;em&gt;not&lt;/em&gt; render as italic text, but would render as literal text with visible angle brackets.</source>
          <target state="translated">&amp;hellip; this would &lt;em&gt;not&lt;/em&gt; render as italic text, but would render as literal text with visible angle brackets.</target>
        </trans-unit>
        <trans-unit id="4fe8ec038bc4329e9e45b5dfe41cee9f2fe195b1" translate="yes" xml:space="preserve">
          <source>&amp;hellip; you can write:</source>
          <target state="translated">&amp;hellip; you can write:</target>
        </trans-unit>
        <trans-unit id="b66a8f7dc087cc3fe583564359f2ab71878995ff" translate="yes" xml:space="preserve">
          <source>&amp;hellip; you could add a computed observable to return the full name:</source>
          <target state="translated">&amp;hellip; you could add a computed observable to return the full name:</target>
        </trans-unit>
        <trans-unit id="71d7c773808d5efbd7cce431ad808079c3272374" translate="yes" xml:space="preserve">
          <source>&amp;hellip;all Knockout does is call require(['some/module/name'], callback) and require(['text!some-template.html'], callback), and uses the asynchronously-returned objects as the viewmodel and template definitions. So,</source>
          <target state="translated">&amp;hellip;all Knockout does is call require(['some/module/name'], callback) and require(['text!some-template.html'], callback), and uses the asynchronously-returned objects as the viewmodel and template definitions. So,</target>
        </trans-unit>
        <trans-unit id="38ee4fba456bf575e89e5da4159e11ef4ef51e69" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can be composed together (nested) or inherited from other components</source>
          <target state="translated">&amp;hellip;can be composed together (nested) or inherited from other components</target>
        </trans-unit>
        <trans-unit id="162d2e6a27442e0aa5ac2c677764866d6758b55a" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can easily be packaged for reuse across projects</source>
          <target state="translated">&amp;hellip;can easily be packaged for reuse across projects</target>
        </trans-unit>
        <trans-unit id="bcba4513804170c2cfb012b6c5f4e034f8b93be4" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can either be preloaded, or loaded asynchronously (on demand) via AMD or other module systems</source>
          <target state="translated">&amp;hellip;can either be preloaded, or loaded asynchronously (on demand) via AMD or other module systems</target>
        </trans-unit>
        <trans-unit id="7734991d30f834e7dc1591e178e0cd0b0d5521fb" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can receive parameters, and optionally write back changes to them or invoke callbacks</source>
          <target state="translated">&amp;hellip;can receive parameters, and optionally write back changes to them or invoke callbacks</target>
        </trans-unit>
        <trans-unit id="37c9fb1cbc39cb59f3625da14f6e4805d7b6d501" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can represent individual controls/widgets, or entire sections of your application</source>
          <target state="translated">&amp;hellip;can represent individual controls/widgets, or entire sections of your application</target>
        </trans-unit>
        <trans-unit id="1c2182731546dc53e24b1c9569feb025fd6bb517" translate="yes" xml:space="preserve">
          <source>&amp;hellip;contain their own view, and usually (but optionally) their own viewmodel</source>
          <target state="translated">&amp;hellip;contain their own view, and usually (but optionally) their own viewmodel</target>
        </trans-unit>
        <trans-unit id="62feedff48dd72e9502546eae6f60f51588cac08" translate="yes" xml:space="preserve">
          <source>&amp;hellip;let you define your own conventions/logic for configuration and loading</source>
          <target state="translated">&amp;hellip;let you define your own conventions/logic for configuration and loading</target>
        </trans-unit>
        <trans-unit id="5e5c19398840fdde1cad04e87976626ec9752a56" translate="yes" xml:space="preserve">
          <source>&amp;lt;div data-bind=&quot;style: { color: currentProfit() &amp;lt; 0 ? 'red' : 'black', fontWeight: isSevere() ? 'bold' : '' }&quot;&amp;gt;...&amp;lt;/div&amp;gt;</source>
          <target state="translated">&amp;lt;div data-bind=&quot;style: { color: currentProfit() &amp;lt; 0 ? 'red' : 'black', fontWeight: isSevere() ? 'bold' : '' }&quot;&amp;gt;...&amp;lt;/div&amp;gt;</target>
        </trans-unit>
        <trans-unit id="38e9d45ee1eed004e555cb8df16e05183c19f62c" translate="yes" xml:space="preserve">
          <source>&amp;lt;select data-bind='options: myOptions, optionsCaption: &quot;Select an item...&quot;, value: myChosenValue'&amp;gt;&amp;lt;/select&amp;gt;</source>
          <target state="translated">&amp;lt;select data-bind='options: myOptions, optionsCaption: &quot;Select an item...&quot;, value: myChosenValue'&amp;gt;&amp;lt;/select&amp;gt;</target>
        </trans-unit>
        <trans-unit id="db710280a1f20bb61913609f07dc49291fe0ba4f" translate="yes" xml:space="preserve">
          <source>&amp;lt;select data-bind='options: myOptions, optionsIncludeDestroyed: true'&amp;gt;&amp;lt;/select&amp;gt;</source>
          <target state="translated">&amp;lt;select data-bind='options: myOptions, optionsIncludeDestroyed: true'&amp;gt;&amp;lt;/select&amp;gt;</target>
        </trans-unit>
        <trans-unit id="eb1429e4a9ace15f00ed398e300f2d1e6d8acde7" translate="yes" xml:space="preserve">
          <source>(Note: If you don&amp;rsquo;t want to apply a CSS class but instead want to assign a style attribute value directly, see &lt;a href=&quot;style-binding&quot;&gt;the style binding&lt;/a&gt;.)</source>
          <target state="translated">(Note: If you don&amp;rsquo;t want to apply a CSS class but instead want to assign a style attribute value directly, see &lt;a href=&quot;style-binding&quot;&gt;the style binding&lt;/a&gt;.)</target>
        </trans-unit>
        <trans-unit id="9a142a8a08360ecb44da2e404e6e9702082412cb" translate="yes" xml:space="preserve">
          <source>(Note: If you don&amp;rsquo;t want to apply an explicit style value but instead want to assign a CSS class, see &lt;a href=&quot;css-binding&quot;&gt;the css binding&lt;/a&gt;.)</source>
          <target state="translated">(Note: If you don&amp;rsquo;t want to apply an explicit style value but instead want to assign a CSS class, see &lt;a href=&quot;css-binding&quot;&gt;the css binding&lt;/a&gt;.)</target>
        </trans-unit>
        <trans-unit id="fd7f1dbd9b0a6243440f34f5f4c46eeb6f3829a1" translate="yes" xml:space="preserve">
          <source>(The awake event also applies to normal computed observables created with the deferEvaluation option.)</source>
          <target state="translated">(The awake event also applies to normal computed observables created with the deferEvaluation option.)</target>
        </trans-unit>
        <trans-unit id="8626117b5c558a6896256b03c3366c11dc83bf9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; is a popular library for referencing JavaScript libraries with a Node-style synchronous require syntax. It&amp;rsquo;s often considered as an alternative to an AMD loader such as require.js. However Browserify solves a rather different problem: synchronous build-time reference resolution, rather than asynchronous runtime reference resolution as handled by AMD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b39766fa59a9837dc3c0076b5c0edc9947c018b2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ratelimit-observable&quot;&gt;rate-limited&lt;/a&gt; and &lt;a href=&quot;http://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;throttled&lt;/a&gt; computeds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799efd7655ba3b9889f9740fd0862be90bc93730" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to supply configurations programmatically based on names, e.g., to implement a naming convention.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6212d983fffffd9e6209c49fa2c090cd3246f96" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to take control over how component configurations are interpreted, e.g., if you do not want to use the standard viewModel/template pair format.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a555c705767297e9a26aa2786f606e4bddfbdc4a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to use custom logic to supply DOM nodes for a given template configuration (e.g., using an ajax request to fetch a template by URL).&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42c134db8841f2566f885e08b68c5c8d619f2908" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to use custom logic to supply a viewmodel factory for a given viewmodel configuration (e.g., integrating with a third-party module loader or dependency injection system).&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="951a4f2777566b4db649df1913890afa95d9199f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Beginners don&amp;rsquo;t need to know about this, but more advanced developers will want to know why we keep making all these claims about KO automatically tracking dependencies and updating the right parts of the UI&amp;hellip;&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa952fc0ed2f794d316a68b12bbe7feaad64baf2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Beginners may wish to skip this section - writable computed observables are fairly advanced and are not necessary in most situations&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05d71845457c0f57f5c46e823954aa6b0676cbf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deferred&lt;/em&gt; &amp;ndash; Notifications happen asynchronously, immediately after the current task and generally before any UI redraws.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a3eb4911a7639fdbf44236533a918c6726b8746" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Model-View-View Model (MVVM)&lt;/em&gt; is a design pattern for building user interfaces. It describes how you can keep a potentially sophisticated UI simple by splitting it into three parts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5d07f2734b6af11f85414b793aa7ddf201eb11" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Native templating&lt;/em&gt; is the mechanism that underpins foreach, if, with, and other control flow bindings. Internally, those control flow bindings capture the HTML markup contained in your element, and use it as a template to render against an arbitrary data item. This feature is built into Knockout and doesn&amp;rsquo;t require any external library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62995f07b684cd1e442b8e8983d90777e3520707" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: As an alternative, it&amp;rsquo;s possible to implement a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt; that fetches components by your own conventions instead of explicit configuration.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d338d1a1dd37312fe044a380c3ea1d735e815b63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This documentation applies to Knockout 3.4.0 and later. For previous versions, the &lt;a href=&quot;https://github.com/mbest/knockout-deferred-updates&quot;&gt;Deferred Updates&lt;/a&gt; plugin provides similar support.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62498b02454097b103305de14b9e278671df1dae" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This documentation applies to Knockout 3.4.0 and later.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a452d27c97bc5cb3c05b0a492913c856dfecc7e2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This is an advanced technique, typically used only when creating libraries of reusable bindings or extended syntaxes. It&amp;rsquo;s not something you&amp;rsquo;ll normally need to do when building applications with Knockout.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d10f8fcc7959551d54bb29ecb4d9c7d6381a396c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This is an advanced technique, typically used only when creating libraries of reusable bindings. It&amp;rsquo;s not something you&amp;rsquo;ll normally need to do when building applications with Knockout.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13a617cb2c3f39c989433be077da2528155d2c63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This rate-limit API was added in Knockout 3.1.0. For previous versions, the &lt;a href=&quot;http://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;throttle extender&lt;/a&gt; provides similar functionality.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68ff05c21394b3c8fde74181447625b3f4a3c9c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pure&lt;/em&gt; computed observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a339e267cfb8f1a5acc964a91f6bddd68f8c55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pure&lt;/em&gt; computed observables work slightly differently. For more details, see the documentation for &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed observables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d78dec7911bd8203863417e869cad05a283e2aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pure&lt;/em&gt; computed observables, introduced in Knockout 3.2.0, provide performance and memory benefits over regular computed observables for most applications. This is because a &lt;em&gt;pure&lt;/em&gt; computed observable doesn&amp;rsquo;t maintain subscriptions to its dependencies when it has no subscribers itself. This feature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874de401496e2450d62370c0489d8134a4680445" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Rate-limited&lt;/em&gt; &amp;ndash; Notifications happen after the specified period of time (a minimum of 2-10 ms depending on the browser).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9fb2be0abb789016ac0a5f7e66231b360cba479" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Standard&lt;/em&gt; &amp;ndash; Notifications happen immediately and synchronously. Dependencies are often notified of intermediate values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a530af1836dfa7520cbd67286036f07b4d5db232" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;String-based templating&lt;/em&gt; is a way to connect Knockout to a third-party template engine. Knockout will pass your model values to the external template engine and inject the resulting markup string into your document. See below for examples that use the &lt;em&gt;jquery.tmpl&lt;/em&gt; and &lt;em&gt;Underscore&lt;/em&gt; template engines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89db5d2a0f4af59a6f45fb25a27d621ea08d0a1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Writes&lt;/em&gt; to observables are not delayed; the observable&amp;rsquo;s value is updated right away. For writable computed observables, this means that the write function is always run right away.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="976802e52d04d57e933efed69813c57bdea15efe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;You won&amp;rsquo;t normally need to set up subscriptions manually, so beginners should skip this section.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6f4cea10f713ca2c89ae228e3ad371071a148e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output&quot;&gt;Version 2.0&lt;/a&gt;&lt;/strong&gt; (8.6kb minified)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc9b0f2bd6f8643b58e34e7531e60e824fddf5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/strong&gt; It&amp;rsquo;s best to use this extensibility point only for custom functions that are truly applicable in a wide range of scenarios. You don&amp;rsquo;t need to add a custom function to these namespaces if you&amp;rsquo;re only planning to use it once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af169da745a1392a07e007770b35a87197553011" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Browser event quirks handling&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4642b89f0bf9cae05827d33f0e6b50627671416f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can be added on top of your existing web application&lt;/strong&gt; without requiring major architectural changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f22e14067daefd1c483604455b05ad6c16fab03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Compact&lt;/strong&gt; - around 13kb after gzipping</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21be6783f2642d52a3544838078409e490d219d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Components&lt;/strong&gt; are a powerful, clean way of organizing your UI code into self-contained, reusable chunks. They:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67202d2d955236aa4dfeac5729c2f6c4ab70604a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comprehensive suite of specifications&lt;/strong&gt; (developed BDD-style) means its correct functioning can easily be verified on new browsers and platforms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe040890c716ea22696a8f2b6f9be7582d520286" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Custom elements&lt;/strong&gt; are an optional but convenient syntax for consuming components. Instead of needing placeholder &amp;lt;div&amp;gt;s into which components are injected with bindings, you can use more self-descriptive markup with custom element names (e.g., &amp;lt;voting-button&amp;gt; or &amp;lt;product-editor&amp;gt;). Knockout takes care to ensure compatibility even with old browsers such as IE 6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14acee7d825a2fe41e8bcf0a2ee1b89a69b3b6a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Declarative bindings&lt;/strong&gt; - a simple and obvious way to connect parts of your UI to your data model. You can construct a complex dynamic UIs easily using arbitrarily nested binding contexts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990b12697bf051a85eebd23ba9e0305e64003986" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Elegant dependency tracking&lt;/strong&gt; - automatically updates the right parts of your UI whenever your data model changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c47af57f11ec324216f4b036c02f4d8a8dd1885" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Full syntax&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd14d38224fd44da0d36469b3026a46c9a2a53c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If the component has a viewmodel, it is instantiated&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853557afd32cc4840ee8b113330eee7c54353605" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Immediate updates&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="005d93bacec0cddafeed676ed8ea8668552bc146" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Internet Explorer 6 to 8&lt;/strong&gt; also supports custom elements, &lt;em&gt;but only if they are registered before the HTML parser encounters any of those elements&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd066585f0b991d7b67e9c322cf8b29f5934ed43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Knockout does not interpret the module name&lt;/strong&gt; in any way - it merely passes it through to require(). So of course Knockout does not know or care about where your module files are loaded from. That&amp;rsquo;s up to your AMD loader and how you&amp;rsquo;ve configured it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14afc719747032408502f996f8253babcf10125" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Knockout doesn&amp;rsquo;t know or care whether your AMD modules are anonymous or not&lt;/strong&gt;. Typically we find it&amp;rsquo;s most convenient for components to be defined as anonymous modules, but that concern is entirely separate from KO.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7623301b20fba50846d11ffcff0175e2f950b534" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Native templating&lt;/strong&gt; does not require any library other than Knockout itself</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cce7f1297a779b792b0890892033a0603eadd234" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Normally, you&amp;rsquo;d load the view model and template from external files&lt;/strong&gt; instead of declaring them inline like this. We&amp;rsquo;ll get to that later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9547e2cb901643dbdb78d8aee63e0abb0b96ab2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For such trivial requirements as validating that an input is numeric, this technique is overkill. It would be far easier just to use jQuery Validation and its number class on the &amp;lt;input&amp;gt; element. Knockout and jQuery Validation work together nicely, as demonstrated on the &lt;a href=&quot;http://knockoutjs.com/examples/gridEditor.html&quot;&gt;grid editor&lt;/a&gt; example. However, the preceding example demonstrates a more general mechanism for filtering and validating with custom logic to control what kind of user feedback appears, which may be of use if your scenario is more complex than jQuery Validation handles natively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c1d2bdf3c7252f3d741539a13c27876814e6d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; These callbacks are &lt;em&gt;only&lt;/em&gt; intended for triggering animations related to changes in a list. If your goal is actually to attach other behaviors to new DOM elements when they have been added (e.g., event handlers, or to activate third-party UI controls), then your work will be much easier if you implement that new behavior as a &lt;a href=&quot;custom-bindings&quot;&gt;custom binding&lt;/a&gt; instead, because then you can use that behavior anywhere, independently of the foreach binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf6a6684f50f3ea7a170aa3398f4403873e6036" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Parameters:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Parameters:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="96f242a46391269bfbcea22f170fb9153b44f393" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Prevents memory leaks&lt;/strong&gt; from computed observables that are no longer referenced in an application but whose dependencies still exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af02e14314a6af73700df96c09743c910918af4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pure JavaScript library&lt;/strong&gt; - works with any server or client-side technology</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65b27346b30be7b0a4f38908addd9e6f4370dbcc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reduces computation overhead&lt;/strong&gt; by not re-calculating computed observables whose value isn&amp;rsquo;t being observed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36974a86b9014bdc65e78c9d0ffe9aae3425befe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Requirements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Requirements&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="38b847315206d412de961c02dd15d22a61454dd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return value&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538d30d06518081cbff7ad599fc04c913bb63f0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shorthand syntax&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c03113c1df32711c668bb01816e62caf66f8cf31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;String-based templating&lt;/strong&gt; works only once you&amp;rsquo;ve referenced a suitable template engine, such as jQuery.tmpl or the Underscore template engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f4687a04e08868399938b56a400b5cef0e8132" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subscriptions&lt;/strong&gt; to observables continue to fire until explicitly disposed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f777cc20c7769740052cd86dadccf8d489dfd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The component is active&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7395eabba8d626f204fa038e96ea461092ce9a5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The component is torn down, and the viewmodel is disposed&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b6f57d0a651bb6db8d366391beeb0328a19e7be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The component template is cloned and injected into the container element&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e6e92787d7eb666a8b10c3b0f889e56b7acf80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The viewmodel is bound to the view&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6460afbcbb4cbdec561841a248ba1e6424d666a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This does not take a strict dependency on &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;&lt;/strong&gt; or any other particular module loader. &lt;em&gt;Any&lt;/em&gt; module loader that provides an AMD-style require API will do. If you want to integrate with a module loader whose API is different, you can implement a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04dcd21b22096736da7955495e67376657beed6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Trivially extensible&lt;/strong&gt; - implement custom behaviors as new declarative bindings for easy reuse in just a few lines of code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0992ab4728f88b2a84a0b8caa835c1cf39986f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using the component&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32cbc5d0a2b4f65ca0027e1ba199cc25d7d8a11a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why is component loading normally forced to be asynchronous?&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa66cf89ab1790c16c3bd2f001aebe35bb73112" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why would you ever enable synchronous loading?&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f570eaf052941ca34607e3a4699d3fedd619ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Works on any mainstream browser&lt;/strong&gt; (IE 6+, Firefox 2+, Chrome, Safari, Edge, others)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78c43aa7b941a0cf5c09e85ba15c220598279bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Your component loaders are asked to supply the viewmodel factory and template&lt;/strong&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c74267b4a56b3e028b9afdd40d0fafdfcfdcb9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;binding context&lt;/em&gt; is an object that holds data that you can reference from your bindings. While applying bindings, Knockout automatically creates and manages a hierarchy of binding contexts. The root level of the hierarchy refers to the viewModel parameter you supplied to ko.applyBindings(viewModel). Then, each time you use a control flow binding such as &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; or &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, that creates a child binding context that refers to the nested view model data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a248fb269bbbb88f6088e277f3883569cefc2a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;model&lt;/em&gt;: your application&amp;rsquo;s stored data. This data represents objects and operations in your business domain (e.g., bank accounts that can perform money transfers) and is independent of any UI. When using KO, you will usually make Ajax calls to some server-side code to read and write this stored model data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="672cec499a5e1f1cee87a332d86b3b33abc231fe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pure&lt;/em&gt; computed observable automatically switches between two states based on whether it has change subscribers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59bc15f49d66eaa773779760f79faa3fa9423729" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;view model&lt;/em&gt;: a pure-code representation of the data and operations on a UI. For example, if you&amp;rsquo;re implementing a list editor, your view model would be an object holding a list of items, and exposing methods to add and remove items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eace4ec15816838615483a0f9f07130cd593dae7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;view&lt;/em&gt;: a visible, interactive UI representing the state of the view model. It displays information from the view model, sends commands to the view model (e.g., when the user clicks buttons), and updates whenever the state of the view model changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca93da47b0c5a3da43e52690cd086f2e1a2ebd77" translate="yes" xml:space="preserve">
          <source>A DOM node being added to the document</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d551d8332829826ecacd9fb849d14363184a926a" translate="yes" xml:space="preserve">
          <source>A DOM node that may be about to move</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6331cd6f9ebb43fddcf15dfc9b7fb432c2f730af" translate="yes" xml:space="preserve">
          <source>A DOM node that may have moved</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a3f7e5611e70df33d8f227c6f7b7360a7dd399e" translate="yes" xml:space="preserve">
          <source>A DOM node that you should remove</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa9b23eb6c3fecb0a19eee9723a2f762712f465" translate="yes" xml:space="preserve">
          <source>A binding consists of two items, the binding &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt;, separated by a colon. Here is an example of a single, simple binding:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97f27c6008d5459bdb04cdb810c301f0271f67b" translate="yes" xml:space="preserve">
          <source>A computed observable can be constructed using one of the following forms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b3c42d55504f21b1b9ff8c6dc937021d9e0fbbb" translate="yes" xml:space="preserve">
          <source>A computed observable provides the following functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2ee99b4fbef7f88d22ec53a5ac2485da3ddb43" translate="yes" xml:space="preserve">
          <source>A constructor function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d421b1fb0fc49225f6485c171df52e5c3cf18816" translate="yes" xml:space="preserve">
          <source>A createViewModel factory function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3140686e93078602a724ffd63d00b2000a63120a" translate="yes" xml:space="preserve">
          <source>A custom component loader is simply an object whose properties are &lt;strong&gt;any combination&lt;/strong&gt; of the following functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875be908e85823e41220d8f215eb69acb7523ecf" translate="yes" xml:space="preserve">
          <source>A custom element can have a regular data-bind attribute (in addition to any params attribute) if needed. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbce704022becdf28532ea1454acbf19683d7755" translate="yes" xml:space="preserve">
          <source>A document fragment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84827e1e80c6d853c30bc27f2185443890c1904" translate="yes" xml:space="preserve">
          <source>A popular convention that simplifies things</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fb40af78bc85a323dc4a804096a956f6e13aef0" translate="yes" xml:space="preserve">
          <source>A pure computed observable notifies an awake event (using its current value) whenever it enters the &lt;em&gt;listening&lt;/em&gt; state and notifies an asleep event (using an undefined value) whevener it enter the &lt;em&gt;sleeping&lt;/em&gt; state. You won&amp;rsquo;t normally need to know about the internal state of your computed observables. But since the internal state can correspond to whether the computed observable is bound to the view or not, you might use that information to do some view-model initialization or cleanup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="219abd734eaa39b3e5af5d4aae85aae74f210ba7" translate="yes" xml:space="preserve">
          <source>A recommended AMD module pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a16d06ab9525707f973555c03a9a069b2890ef" translate="yes" xml:space="preserve">
          <source>A shared object instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05cd21e831a202875a8dffd0d37c25b82bec9e6" translate="yes" xml:space="preserve">
          <source>A simpler and more elegant option, however, is to use as to declare a name for your iteration variables. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c8841f5e8f9c936c29327e4d6733bdab3c12e1" translate="yes" xml:space="preserve">
          <source>A string of markup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a59868d9ef75167ce556f0565eb922f6cc31f5" translate="yes" xml:space="preserve">
          <source>A value that controls whether or not the associated DOM element should be enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1629231a910c1a9903f050df95a79a00ff663fe9" translate="yes" xml:space="preserve">
          <source>AMD modules are loaded only on demand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="dba104dad21c672e8d177c331e1988224ee9c40f" translate="yes" xml:space="preserve">
          <source>Activating Knockout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e50bbf06486aad9ed5858d61f790ecc35cf4bdb" translate="yes" xml:space="preserve">
          <source>Adding custom functions using &quot;fn&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f55b709f75ff470666d48ed8e0dd3202f9462b3" translate="yes" xml:space="preserve">
          <source>Additional benefits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ca1471a1c5c73c1eaf333a7d893c103077a28a" translate="yes" xml:space="preserve">
          <source>Additional parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eecc85d283c6cfc2c01cf8cf19d07776798fd03" translate="yes" xml:space="preserve">
          <source>Additionally, Knockout provides similar functions that can operate on observables and computed observables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69d691f44445960d684f25080c894d46d0ef6515" translate="yes" xml:space="preserve">
          <source>Advanced queue control</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5126940d744a6dff391a643edf858b06f00785ed" translate="yes" xml:space="preserve">
          <source>Advanced usage</source>
          <target state="translated">고급 사용법</target>
        </trans-unit>
        <trans-unit id="bdafa12daa294233db606dc624e7cfa8736c4318" translate="yes" xml:space="preserve">
          <source>Advanced: Accessing $raw parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb27fde407851516098c690ede0080b631c0f01" translate="yes" xml:space="preserve">
          <source>Advanced: Custom component loaders</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b68add7c4ef423265bf6c36f75e07b61ca328f2" translate="yes" xml:space="preserve">
          <source>After you have defined the module update the input element from the HTML example above to be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="329df29582c6ec3024bef034171a5a78bd9cbb39" translate="yes" xml:space="preserve">
          <source>Again, only the nodes &lt;em&gt;inside&lt;/em&gt; the specified element will be cloned for use as the component&amp;rsquo;s template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9180eedfdd61587618067116c1c45385c35cb38" translate="yes" xml:space="preserve">
          <source>All change notifications are delayed, including when calling valueHasMutated manually. This means you can&amp;rsquo;t use valueHasMutated to force a rate-limited observable to notify an un-changed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1faff78215a2b42eb91a45b8356b4f79235b938d" translate="yes" xml:space="preserve">
          <source>All of these functions are equivalent to running the native JavaScript array functions on the underlying array, and then notifying listeners about the change:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9de1c05e289fb463cf3a1c26f4670e737ed411" translate="yes" xml:space="preserve">
          <source>All properties of an object are converted into an observable. If an update would change the value, it will update the observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c026ebda36ef4388e796344b3abce466922b2b" translate="yes" xml:space="preserve">
          <source>Also, randomOrder will still work with regular DOM elements, because all of the ko.virtualElements APIs are backwardly compatible with regular DOM elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fda4896a6cfabf38010923d25545054759b05e1" translate="yes" xml:space="preserve">
          <source>Also, since ko.components.defaultLoader is a component loader, it implements the following standard component loader functions. You can invoke these directly, e.g., as part of your implementation of a custom loader:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4edfae09ecfcc29756a62316c12a008c591612f8" translate="yes" xml:space="preserve">
          <source>Also, you need to have referenced a suitable module loader library (such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;) or implemented a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt; that knows how to grab your files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b5cc861eaf7ac508de6b2b58d1ed770fee1e988" translate="yes" xml:space="preserve">
          <source>Alternatively, if you prefer to avoid the function literal in your view, you can use the &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;bind&lt;/a&gt; function, which attaches specific parameter values to a function reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa6e7ea09a57e761a9110c8a9df4784c24443111" translate="yes" xml:space="preserve">
          <source>Alternatively, pass a JavaScript object literal with a property called data which is the array you wish to iterate over. The object literal may also have other properties, such as afterAdd or includeDestroyed &amp;mdash; see below for details of these extra options and examples of their use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7dfbc21d336e304b1aefd8da00433e7d002f8f1" translate="yes" xml:space="preserve">
          <source>Alternatively, you can &lt;a href=&quot;#controlling-custom-element-tag-names&quot;&gt;override getComponentNameForNode&lt;/a&gt; to control dynamically which elements map to which component names, independently of preregistration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae14a33d0421d469795c28cb8d6c7b5a300d1437" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the pure option with ko.computed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6881ab5fe1c9360a98b31b040fcb030610e5b9a" translate="yes" xml:space="preserve">
          <source>Alternatively, you don&amp;rsquo;t need to create a computed observable if you&amp;rsquo;re doing something simple like this. You can pass an arbitrary JavaScript expression to the text binding. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467b199c0d9c0c472351991602cecc7ed24eedcf" translate="yes" xml:space="preserve">
          <source>Although deferred, asynchronous notifications are generally better because of fewer UI updates, it can be a problem if you need to update the UI immediately. Sometimes, for proper functionality, you need an intermediate value pushed to the UI. You can accomplish this using the &lt;a href=&quot;microtasks#advanced-queue-control&quot;&gt;ko.tasks.runEarly method&lt;/a&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cccda6b76e9fe36a78cbb8b19672fab53b808ae3" translate="yes" xml:space="preserve">
          <source>Although the &lt;a href=&quot;value-binding&quot;&gt;value binding&lt;/a&gt; can also perform two-way binding between text boxes and viewmodel properties, you should prefer textInput whenever you want immediate live updates. The main differences are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e9247f8574a1aa66c8291b2a6f5cecfef75b1e" translate="yes" xml:space="preserve">
          <source>Although the DOM nodes in this element will be stripped out and not bound by default, they are not lost. Instead, they are supplied to the component (in this case, my-special-list), which can include them in its output however it wishes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c64e2a25f4ecdbf890fa878004386d735536f164" translate="yes" xml:space="preserve">
          <source>An AMD module whose value describes a template</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e68eb6e1b6701b3c386d6f393c8c2332fcca13e2" translate="yes" xml:space="preserve">
          <source>An AMD module whose value describes a viewmodel</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="242417090831cde58cc194cc22ae4eab474f143d" translate="yes" xml:space="preserve">
          <source>An array of DOM nodes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="968a4f61a70888dd1fa2a0eb32b82dc937a8263d" translate="yes" xml:space="preserve">
          <source>An array of the inserted DOM elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="677bc5c11af17aad4286438791881da11106a6b3" translate="yes" xml:space="preserve">
          <source>An element can include multiple bindings (related or unrelated), with each binding separated by a comma. Here are some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d626c0f133638f459d4ffb6d3a56ba114d6d9ce" translate="yes" xml:space="preserve">
          <source>An existing element ID</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36639c5e653a711057a5a79fa2fd56cc32a4737" translate="yes" xml:space="preserve">
          <source>An existing element instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48281418a421e56b65e2f335f96fc8ee14c0591" translate="yes" xml:space="preserve">
          <source>An object whose keys determine which bindings are usable with virtual elements. Set ko.virtualElements.allowedBindings.mySuperBinding = true to allow mySuperBinding to be used with virtual elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750e1b4a97e09ed466c53a7a581f325eb74fda90" translate="yes" xml:space="preserve">
          <source>And name would have changed as expected. However, in the children array, the child (Alicw) would have been completely removed and a new one (Alice) added. This is not completely what you would have expected. Instead, you would have expected that only the name property of the child was updated from Alicw to Alice, not that the entire child was replaced!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9ca86081be1235e5d657f4784b8eda45576a203" translate="yes" xml:space="preserve">
          <source>Any existing content is removed and discarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f4f05405754c54fdd9676fba604372b29335c05" translate="yes" xml:space="preserve">
          <source>Apart from the fact that they work with JSON strings instead of JS objects these functions are completely identical to their *JS counterparts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f1ccfc969139d4ee723e3cd26a3b87a5f4bd6fb" translate="yes" xml:space="preserve">
          <source>Applications can reference this trivially, i.e., ko.components.register('my-component', { require: 'path/my-component' });</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c42fc46dfc0ee9be1215927e31c8ac247229ec" translate="yes" xml:space="preserve">
          <source>Applying multiple extenders</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb775857f1edfb66da986af1438cdd40f990f61d" translate="yes" xml:space="preserve">
          <source>Applying the rateLimit extender</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30bfe9fb3fdb4e5e2bd1e24672ab720fe7f064f" translate="yes" xml:space="preserve">
          <source>Arrays are converted into &lt;a href=&quot;observablearrays&quot;&gt;observable arrays&lt;/a&gt;. If an update would change the number of items, it will perform the appropriate add/remove actions. It will also try to keep the order the same as the original JavaScript array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e6eb4e5415e08468cb571b630e6982ce45a64e" translate="yes" xml:space="preserve">
          <source>As an alternative, Knockout provides two helper functions that allow you to identify the data associated with a DOM element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18bd9d7dc396ea105d8584c5d8a67ce95140998c" translate="yes" xml:space="preserve">
          <source>As an array, $componentTemplateNodes, available to any binding expression in the component&amp;rsquo;s template (i.e., as a &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; property). Usually this is the most convenient way to use the supplied markup. See the example below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc42cbe041397354fa48d36ba2fff1663ff9d0f" translate="yes" xml:space="preserve">
          <source>As an array, componentInfo.templateNodes, passed to its &lt;a href=&quot;component-registration#a-createviewmodel-factory-function&quot;&gt;createViewModel function&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab4f1ab556f0024f4505366ba60640abe3aa3a6" translate="yes" xml:space="preserve">
          <source>As described in Note 1, you can refer to each array entry using the $data &lt;a href=&quot;binding-context&quot;&gt;context variable&lt;/a&gt;. In some cases though, it may be useful to give the current item a more descriptive name using the as option like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e6cce525faa11e83082f916934eb369ee22979" translate="yes" xml:space="preserve">
          <source>As illustrated in this example, KO passes the form element as a parameter to your submit handler function. You can ignore that parameter if you want, or there are various ways you might want to use it, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40531ab2533e66fef97d544b345056144f69e728" translate="yes" xml:space="preserve">
          <source>As shown in the above examples, bindings within the foreach block can refer to properties on the array entries. For example, &lt;a href=&quot;#example-1-iterating-over-an-array&quot;&gt;Example 1&lt;/a&gt; referenced the firstName and lastName properties on each array entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03dd56f30baeedf6f43ffeb0f96b6c0c125970f3" translate="yes" xml:space="preserve">
          <source>As soon as your UI gets nontrivial and has a few overlapping behaviors, things can get tricky and expensive to maintain if you only use jQuery. Consider an example: you&amp;rsquo;re displaying a list of items, stating the number of items in that list, and want to enable an &amp;lsquo;Add&amp;rsquo; button only when there are fewer than 5 items. jQuery doesn&amp;rsquo;t have a concept of an underlying data model, so to get the number of items you have to infer it from the number of TRs in a table or the number of DIVs with a certain CSS class. Maybe the number of items is displayed in some SPAN, and you have to remember to update that SPAN&amp;rsquo;s text when the user adds an item. You also must remember to disable the &amp;lsquo;Add&amp;rsquo; button when the number of TRs is 5. Later, you&amp;rsquo;re asked also to implement a &amp;lsquo;Delete&amp;rsquo; button and you have to figure out which DOM elements to change whenever it&amp;rsquo;s clicked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3824481999af1a08c2a42310b9623d970b4c8e60" translate="yes" xml:space="preserve">
          <source>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. KO will evaluate them and use the resulting values to detemine the style values to apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce18070a48ec4dcf3c21d8c773695eaa7e43f60a" translate="yes" xml:space="preserve">
          <source>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. KO will evaluate them and use the resulting values to determine the appropriate CSS classes to add or remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57fd897b08c686dca588676f977987af4cbc17de" translate="yes" xml:space="preserve">
          <source>As well as (or instead of) template and viewModel, your component configuration object can have arbitrary other properties. This configuration object is made available to any &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt; you may be using.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="271643e4723e546ecfd37518fb0f1e341e319028" translate="yes" xml:space="preserve">
          <source>As you can see from Example 2 above, it&amp;rsquo;s possible to use $index to refer to the zero-based index of the current array item. $index is an observable and is updated whenever the index of the item changes (e.g., if items are added to or removed from the array).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cabec4e28a1cc149d5844e47658d55240bebd319" translate="yes" xml:space="preserve">
          <source>As you can see, binding contexts have an extend function that produces a clone with extra properties. The extend function accepts either an object with the properties to copy or a function that returns such an object. The function syntax is preferred so that future changes in the binding value are always updated in the binding context. This process doesn&amp;rsquo;t affect the original binding context, so there is no danger of affecting sibling-level elements - it will only affect descendants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ea6690b6b5207f9ef37a626e0bbe8a12a55cab9" translate="yes" xml:space="preserve">
          <source>As you have seen in the examples above, you can use a params attribute to supply parameters to the component viewmodel. The contents of the params attribute are interpreted like a JavaScript object literal (just like a data-bind attribute), so you can pass arbitrary values of any type. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34c40ba0f5fa3fb6eb13d61c372271984f13555" translate="yes" xml:space="preserve">
          <source>Assuming your array is an &lt;a href=&quot;observablearrays&quot;&gt;observable array&lt;/a&gt;, whenever you later add, remove, or re-order array entries, the binding will efficiently update the UI to match - inserting or removing more copies of the markup, or re-ordering existing DOM elements, without affecting any other DOM elements. This is far faster than regenerating the entire foreach output after each array change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a29a876f6fee0ab06e8d6374c2a1f8b7410a520" translate="yes" xml:space="preserve">
          <source>Asynchronous Module Definition (AMD) With RequireJs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f15ea1e1d443f1c22a341a9e0edeca34b288d76c" translate="yes" xml:space="preserve">
          <source>Asynchronous error handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b6cc5cdc6b8261c411bf780fb442ecccc793b5" translate="yes" xml:space="preserve">
          <source>Asynchronous module definition (AMD) with requireJs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4669c785b85f8d268aedb9a3b7494a7c8313488f" translate="yes" xml:space="preserve">
          <source>Because of inheritance, if you attach a function to ko.subscribable, it will be available on all the others too. If you attach a function to ko.observable, it will be inherited by ko.observableArray but not by ko.computed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aa536687687d7362ee99aa5d4ec974df63a5c14" translate="yes" xml:space="preserve">
          <source>Because self is captured in the function&amp;rsquo;s closure, it remains available and consistent in any nested functions, such as the computed observable&amp;rsquo;s evaluator. This convention is even more useful when it comes to event handlers, as you&amp;rsquo;ll see in many of the &lt;a href=&quot;http://knockoutjs.com/examples/&quot;&gt;live examples&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550907ac1f6696f0600c8c1a60187b368d514a83" translate="yes" xml:space="preserve">
          <source>Because the computed observable evaluates both pageIndex and pageSize, it becomes dependent on both of them. So, this code will use jQuery&amp;rsquo;s &lt;a href=&quot;http://api.jquery.com/jQuery.getJSON/&quot;&gt;$.getJSON function&lt;/a&gt; to reload currentPageData when a GridViewModel is first instantiated &lt;em&gt;and&lt;/em&gt; whenever the pageIndex or pageSize properties are later changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c00e991fcf301ea36ef0431f7266e3845d6942f" translate="yes" xml:space="preserve">
          <source>Because the hasFocus binding works in both directions (setting the associated value focuses or unfocuses the element; focusing or unfocusing the element sets the associated value), it&amp;rsquo;s a convenient way to toggle an &amp;ldquo;edit&amp;rdquo; mode. In this example, the UI displays either a &amp;lt;span&amp;gt; or an &amp;lt;input&amp;gt; element depending on the model&amp;rsquo;s editing property. Unfocusing the &amp;lt;input&amp;gt; element sets editing to false, so the UI switches out of &amp;ldquo;edit&amp;rdquo; mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd8beb104f73636a98fcd6cda7c1acde17a32e28" translate="yes" xml:space="preserve">
          <source>Behind the scenes, an observableArray is actually an &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; whose value is an array (plus, observableArray adds some additional features described below). So, you can get the underlying JavaScript array by invoking the observableArray as a function with no parameters, just like any other observable. Then you can read information from that underlying array. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd4c935e79a15a4f2de856a72f11306af77e87c" translate="yes" xml:space="preserve">
          <source>Better yet, this techinique could be used to support event delegation. jQuery&amp;rsquo;s live/delegate/on functions are an easy way to make this happen:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f0043e684cc2e548822e45bee14ea4c4673e262" translate="yes" xml:space="preserve">
          <source>Binding</source>
          <target state="translated">Binding</target>
        </trans-unit>
        <trans-unit id="3a81a526cb1140d2e424d0180bf85d9cd3d1c460" translate="yes" xml:space="preserve">
          <source>Binding context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f722c7a7e44d3deb47b141e7f82c81b0815261" translate="yes" xml:space="preserve">
          <source>Binding preprocessor reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bd59c5a7fe5f05639190e405278fb2261e77836" translate="yes" xml:space="preserve">
          <source>Binding syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9b9212b6073a73407ac32ba882e6a4bcaeeaed2" translate="yes" xml:space="preserve">
          <source>Binding values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="967382f86044b6efc91dfee8f4e2b4ed941211cd" translate="yes" xml:space="preserve">
          <source>Bindings</source>
          <target state="translated">Bindings</target>
        </trans-unit>
        <trans-unit id="52b0f9a9f1a5ef31bad0fa03e077b16e18f5a9b5" translate="yes" xml:space="preserve">
          <source>Bindings can include any amount of &lt;em&gt;whitespace&lt;/em&gt; (spaces, tab, and newlines), so you&amp;rsquo;re free to use it to arrange your bindings as you like. The following examples are all equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92f78f786d943b799c2c8bf4c4f8c9a36f323743" translate="yes" xml:space="preserve">
          <source>Bindings contexts offer the following special properties that you can reference in any binding:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7dfee65d89e215d7fc623cc4674a60289e7c1ce" translate="yes" xml:space="preserve">
          <source>Bindings such as &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; create extra levels in the binding context hierarchy. This means that their descendants can access data at outer levels by using $parent, $parents, $root, or $parentContext.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6acc9a939f24c837662878de4c3d39eeade8294a" translate="yes" xml:space="preserve">
          <source>Both result and result2 will be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b375916d78848c4b0ac042003d5c4e6a2e1607f" translate="yes" xml:space="preserve">
          <source>Browsers are highly inconsistent in the events that fire in response to unusual text entry mechanisms such as cutting, dragging, or accepting autocomplete suggestions. The value binding, even with extra options such as valueUpdate: afterkeydown to get updates on particular events, does not cover all text entry scenarios on all browsers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82dc9108de5adbfed209f29bd45aca2f7129d561" translate="yes" xml:space="preserve">
          <source>But what if you want to refer to the array entry itself (not just one of its properties)? In that case, you can use the &lt;a href=&quot;binding-context&quot;&gt;special context property&lt;/a&gt; $data. Within a foreach block, it means &amp;ldquo;the current item&amp;rdquo;. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eec18f7623a3b7b58d6302099822dbf86dd41114" translate="yes" xml:space="preserve">
          <source>By default, Knockout assumes that your custom element tag names correspond exactly to the names of components registered using ko.components.register. This convention-over-configuration strategy is ideal for most applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfd4b509346f65fb32adf29e6062d88da4847b7c" translate="yes" xml:space="preserve">
          <source>By default, Knockout comes with support for &lt;a href=&quot;https://github.com/BorisMoore/jquery-tmpl&quot;&gt;jquery.tmpl&lt;/a&gt;. To use it, you need to reference the following libraries, in this order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6a1b05bbc994e6ce05943724747faea53070d14" translate="yes" xml:space="preserve">
          <source>By default, Knockout will allow the click event to continue to bubble up to any higher level event handlers. For example, if your element and a parent of that element are both handling the click event, then the click handler for both elements will be triggered. If necessary, you can prevent the event from bubbling by including an additional binding that is named clickBubble and passing false to it, as in this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f653a59193ad26cd8f474a7f1ec0369bc69dd3cf" translate="yes" xml:space="preserve">
          <source>By default, Knockout will allow the event to continue to bubble up to any higher level event handlers. For example, if your element is handling a mouseover event and a parent of the element also handles that same event, then the event handler for both elements will be triggered. If necessary, you can prevent the event from bubbling by including an additional binding that is named youreventBubble and passing false to it, as in this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0213c08b2e3987a7bcfe88f7f8be8cd23b5038ae" translate="yes" xml:space="preserve">
          <source>By default, Knockout will prevent the click event from taking any default action. This means that if you use the click binding on an a tag (a link), for example, the browser will only call your handler function and will &lt;em&gt;not&lt;/em&gt; navigate to the link&amp;rsquo;s href. This is a useful default because when you use the click binding, it&amp;rsquo;s normally because you&amp;rsquo;re using the link as part of a UI that manipulates your view model, not as a regular hyperlink to another web page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25eb83de5d5b73340ff952e4e80755f80b025215" translate="yes" xml:space="preserve">
          <source>By default, Knockout will prevent the event from taking any default action. For example if you use the event binding to capture the keypress event of an input tag, the browser will only call your handler function and will &lt;em&gt;not&lt;/em&gt; add the value of the key to the input element&amp;rsquo;s value. A more common example is using &lt;a href=&quot;click-binding&quot;&gt;the click binding&lt;/a&gt;, which internally uses this binding, where your handler function will be called, but the browser will &lt;em&gt;not&lt;/em&gt; navigate to the link&amp;rsquo;s href. This is a useful default because when you use the click binding, it&amp;rsquo;s normally because you&amp;rsquo;re using the link as part of a UI that manipulates your view model, not as a regular hyperlink to another web page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e7b48de47c13e7d29cf450260662702544cfb2" translate="yes" xml:space="preserve">
          <source>By default, bindings only affect the element to which they are applied. But what if you want to affect all descendant elements too? This is possible. Your binding can tell Knockout &lt;em&gt;not&lt;/em&gt; to bind descendants at all, and then your custom binding can do whatever it likes to bind them in a different way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c243a6737db34c7b0eeac830e3f8771116e5e45" translate="yes" xml:space="preserve">
          <source>By default, the DOM nodes inside &amp;lt;my-special-list&amp;gt; will be stripped out (without being bound to any viewmodel) and replaced by the component&amp;rsquo;s output. However, those DOM nodes aren&amp;rsquo;t lost: they are remembered, and are supplied to the component in two ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c47fdcb3268ade367b3d412d238b7c1e97b37a3" translate="yes" xml:space="preserve">
          <source>By default, the foreach binding will skip over (i.e., hide) any array entries that are marked as destroyed. If you want to show destroyed entries, use the includeDestroyed option. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d966b6b812aaffebe3e1b225c111fc8166fe9bd" translate="yes" xml:space="preserve">
          <source>By default, the options binding will skip over (i.e., hide) any array entries that are marked as destroyed. If you want to show destroyed entries, then specify this additional parameter like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd4b73242b19586f5ded1578826470337eec450d" translate="yes" xml:space="preserve">
          <source>By modifying binding contexts and controlling descendant bindings, you have a powerful and advanced tool to create custom binding mechanisms of your own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ffe9da1a370013ec59a35300a7401d42fae6091" translate="yes" xml:space="preserve">
          <source>Calls each of the registered loaders&amp;rsquo; getConfig functions in turn, until the first one supplies a non-null componentConfig.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce90863a4388baecfe3dc5e7b6c6832eca44d46f" translate="yes" xml:space="preserve">
          <source>Calls each of the registered loaders&amp;rsquo; loadTemplate functions in turn, until the first one supplies a non-null DOM array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd542f36c0ad03db70cea2aa6e54148b04219c1b" translate="yes" xml:space="preserve">
          <source>Calls each of the registered loaders&amp;rsquo; loadViewModel functions in turn, until the first one supplies a non-null createViewModel function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ff3b8319fac2d8b7d9acad81d7aa35a5ad48a52" translate="yes" xml:space="preserve">
          <source>Changes to items or selectedIndexes will ripple through the chain of computed observables, which in turn will update any UI elements bound to them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c1d4b0b47058f82dd1b216d04be28f56938456f" translate="yes" xml:space="preserve">
          <source>Combining multiple changes into a single update</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49288181e14cf83b9352f7e2e0537da14cdcb5e8" translate="yes" xml:space="preserve">
          <source>Communication between parent and child components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c97e23b3c4d2518efc7bf5b1e60ef2c00b9c85c1" translate="yes" xml:space="preserve">
          <source>Comparison with deferred updates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb8c2f5e94bd4d3fa6518057575ef05920fde751" translate="yes" xml:space="preserve">
          <source>Comparison with the throttle extender</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="4a87edfaece4a4e94d877c76e134bc7cf6471a21" translate="yes" xml:space="preserve">
          <source>Component lifecycle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ffddfd282dff2b14a0ea7fa7125f3df71357ad8" translate="yes" xml:space="preserve">
          <source>Component loader utility functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="761842342f7602addd473021216f52faa86cae83" translate="yes" xml:space="preserve">
          <source>Component loaders</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f452457ae4b51fa02b1e173b4b0f6a1052bd7c42" translate="yes" xml:space="preserve">
          <source>Component registration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9289473eeedaee09d76c8cf1b6994d8550debf46" translate="yes" xml:space="preserve">
          <source>Components</source>
          <target state="translated">Components</target>
        </trans-unit>
        <trans-unit id="eed91a528f2fc4fa5bc0cc953effda03077582c3" translate="yes" xml:space="preserve">
          <source>Components and Custom Elements - Overview</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659136f125703fbf239b6fdcbf9807af68bdd3ca" translate="yes" xml:space="preserve">
          <source>Components usually have viewmodels, but they don&amp;rsquo;t necessarily have to. A component can specify just a template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02608739ad96779f6714a96facc9a51c046de4d6" translate="yes" xml:space="preserve">
          <source>Computed Observable Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cac67370227943652edb1bf32470cb7ededf3cd3" translate="yes" xml:space="preserve">
          <source>Computed Observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d98b156baebd0cc88075e455bd6e7b1bb0e76a4b" translate="yes" xml:space="preserve">
          <source>Computed observable reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2ec0435fbe18656377dae8b79915d57ab98a0b9" translate="yes" xml:space="preserve">
          <source>Computed observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5be6efbe0cdf63c1654669d988fd6948bafd8cb6" translate="yes" xml:space="preserve">
          <source>Computed observables are supposed to map a set of observable inputs into a single observable output. As such, it doesn&amp;rsquo;t make sense to include cycles in your dependency chains. Cycles would &lt;em&gt;not&lt;/em&gt; be analogous to recursion; they would be analogous to having two spreadsheet cells that are computed as functions of each other. It would lead to an infinite evaluation loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2947b370ef1780b5ce5f7b757f8fbc6949d5aa95" translate="yes" xml:space="preserve">
          <source>Consider a special list component that can be invoked as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdc5c7e600b4462cb7a47184c49b5743744e2362" translate="yes" xml:space="preserve">
          <source>Consider the following unusual case, in which useObservable1, observable1, and observable2 are all observables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2013a8ac11dfd30a4371b3a3b80a3e57ac8e78e1" translate="yes" xml:space="preserve">
          <source>Consider the observables in the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1117c8b3e83be86f1626d72435beb4550b6b1224" translate="yes" xml:space="preserve">
          <source>Constructing a computed observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4221e67369d1a203bdb0ecf119eb9ef7949b278f" translate="yes" xml:space="preserve">
          <source>Consults each registered loader in turn (by default, that&amp;rsquo;s just the default loader), to find the first one that supplies a viewmodel/template definition for the named component, then invokes callback to return than viewmodel/template declaration. Invokes callback(null) if none of the registered loaders know about this component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edea616075e1b992e2a1f7d2acc1cdd1bdf21fbc" translate="yes" xml:space="preserve">
          <source>Continuing the previous example, you might want slideVisible to set the element to be instantly visible or invisible when the page first appears (without any animated slide), so that the animation only runs when the user changes the model state. You could do that as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce832f145332955eb3265a8ede075cf6b1348107" translate="yes" xml:space="preserve">
          <source>Controlling custom element tag names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8f133feb465932694ab2a98e1eb7747d66f64e3" translate="yes" xml:space="preserve">
          <source>Controlling dependencies using peek</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6504831105dad1f130ff746a8aac74129f3308" translate="yes" xml:space="preserve">
          <source>Controlling or modifying the binding context in custom bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7001c43b6b88f7e449641661e4b5f14d9fd1e3c4" translate="yes" xml:space="preserve">
          <source>Controlling precedence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a2bc032092b4e94355ac6de4992fb4188dcfb12" translate="yes" xml:space="preserve">
          <source>Controlling synchronous/asynchronous loading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c7def4489979402bef239f8ce6c91bfba309a07" translate="yes" xml:space="preserve">
          <source>Converting View Model Data to Plain JSON</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db93df4caeca527834703cd00425530177a63ba" translate="yes" xml:space="preserve">
          <source>Copying certain properties using &amp;ldquo;copy&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2203e5a230379d565a0c899ed4adc6b93e7f6dea" translate="yes" xml:space="preserve">
          <source>Creating an extender involves adding a function to the ko.extenders object. The function takes in the observable itself as the first argument and any options in the second argument. It can then either return the observable or return something new like a computed observable that uses the original observable in some way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4039add3326a9c3c1c76f899ffeb9a382a6a0bbb" translate="yes" xml:space="preserve">
          <source>Creating custom bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb9756189a28d9adfb06e166fd3288595e0d920" translate="yes" xml:space="preserve">
          <source>Creating custom bindings that control descendant bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f643fe053a4c78aac0aa1cb4ee160c7166f2853b" translate="yes" xml:space="preserve">
          <source>Creating custom bindings that support virtual elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb539e2cde83f162d3671d028d8f300a026106c8" translate="yes" xml:space="preserve">
          <source>Custom bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33671f984027a68370db04ee2850cad72a30b9b1" translate="yes" xml:space="preserve">
          <source>Custom bindings can work with virtual elements too, but to enable this, you must explicitly tell Knockout that your binding understands virtual elements, by using the ko.virtualElements.allowedBindings API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b02f7ac0bddff91f51122a7841af16420a2282a7" translate="yes" xml:space="preserve">
          <source>Custom disposal logic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6789075eb722c50f4da3df82b6df6ba9f8fa1b61" translate="yes" xml:space="preserve">
          <source>Custom elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac9f87f42e53076f0f3bc01bdfc33cd3a3330a1" translate="yes" xml:space="preserve">
          <source>Custom elements are a syntactical alternative to the &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; (and in fact, custom elements make use of a component binding behind the scenes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bdeeedc365799bc2628a672569777dea3cd4f5b" translate="yes" xml:space="preserve">
          <source>Custom elements provide a convenient way of injecting &lt;a href=&quot;component-overview&quot;&gt;components&lt;/a&gt; into your views.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="253deb0b4c3f25b5d0a8ab69ab15a0a5e8a1bbf9" translate="yes" xml:space="preserve">
          <source>Custom functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20edd160b708193b8cd0d39f58c10bc666a47f89" translate="yes" xml:space="preserve">
          <source>Custom loaders can plug into any part of this process, so you can take control over supplying configurations, interpreting configurations, supplying DOM nodes, or supplying viewmodel factory functions. By putting custom loaders into a chosen order inside ko.components.loaders, you can control the priority order of different loading strategies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1cea07f3d8dcbe1745bc7ec0339edf9dd8a1c9" translate="yes" xml:space="preserve">
          <source>Customizing object construction using &amp;ldquo;create&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50ee97e0e3e0b6e26cae536ab969b9b4086cfdd" translate="yes" xml:space="preserve">
          <source>Customizing object updating using &amp;ldquo;update&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e01b2c84eeb85c92c0c227a329d46faf0286ed" translate="yes" xml:space="preserve">
          <source>Declarative bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602e3ca9311ed01ea1f90901d68acf0154edb840" translate="yes" xml:space="preserve">
          <source>Deferred updates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d33bdc7c7c750f5687e4acfbfe0dbcbd94980b54" translate="yes" xml:space="preserve">
          <source>Deferred updates are turned off by default to provide compatibility with existing applications. To use deferred updates for your application, you must enable it before initializing your viewmodels by setting the following option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222e63650134f06185ff4eba850a6bbc59f05df7" translate="yes" xml:space="preserve">
          <source>Defining and registering components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82561171b4e8eed7831575a3bd0fd837f8a82416" translate="yes" xml:space="preserve">
          <source>Delaying and/or suppressing change notifications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="a811f27fa09ba74dbb3e42867afbb878bcbad3e6" translate="yes" xml:space="preserve">
          <source>Dependency chains just work</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c363ed6db02f3ea32be85600b21f30d4c97ea44" translate="yes" xml:space="preserve">
          <source>Descendant bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59380b44a10043c9034706c8bb58c001df92a319" translate="yes" xml:space="preserve">
          <source>Determining if a property is a computed observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7568009623a301a6c07b4b81d08e0e95375454" translate="yes" xml:space="preserve">
          <source>Determining if a property is a pure computed observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8177b5ed57d02388907afbbf9df075dc986c6b4a" translate="yes" xml:space="preserve">
          <source>Determining the observable type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ff2f116ddb0dad37555150f401b3a0c8dbb95b1" translate="yes" xml:space="preserve">
          <source>Developers familiar with Ruby on Rails, ASP.NET MVC, or other MV* technologies may see MVVM as a real-time form of MVC with declarative syntax. In another sense, you can think of KO as a general way to make UIs for editing JSON data&amp;hellip; whatever works for you :)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853ee1f12570f18e3388b47c2a0f03eb555b5bbd" translate="yes" xml:space="preserve">
          <source>Disposal and memory management</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b44b6295dded1bbfd5d400fc72e1bf24012f125" translate="yes" xml:space="preserve">
          <source>Documentation on Binding Handlers in general can be found &lt;a href=&quot;custom-bindings&quot;&gt;here&lt;/a&gt;. This section is meant to demonstrate the power that AMD modules provide in maintaining your custom handlers. We will take the example of the ko.bindingHandlers.hasFocus example from the binding handlers documentation. By wrapping that handler in it&amp;rsquo;s own module you can restrict it&amp;rsquo;s use only to the pages that need it. The wrapped module becomes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e71968601f25cc8d728fb672b3c6eef4f524e2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t return non-string values. That wouldn&amp;rsquo;t make sense, because markup is always a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c7559a433a9d713a940341db539ff9c4b28ea8a" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t try to use the value and textInput bindings together on the same element, as that won&amp;rsquo;t achieve anything useful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f44f2279c8cf4e05783eedaa0f0f9909bcb3b91" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t write {font-weight:someValue}; do write {fontWeight:someValue}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be7c5667ed6550d41ae6c0658c6f47b62d579f4" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t write {text-decoration:someValue}; do write {textDecoration:someValue}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a479c9c34e878d07b4d67a73a48f432ad7dc53c8" translate="yes" xml:space="preserve">
          <source>Download</source>
          <target state="translated">Download</target>
        </trans-unit>
        <trans-unit id="f9ae8a63307356d3207b70880fd5b3983d9bf72f" translate="yes" xml:space="preserve">
          <source>Drilling down into arrays/objects works but copy and observe can conflict:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b14f1acd92dd2af3e3a0d2d48a5aca685f3a348f" translate="yes" xml:space="preserve">
          <source>During the execution of a computed observable&amp;rsquo;s evaluator function, you can access ko.computedContext to get information about the current computed property. It provides the following functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb51b2c1c5469acfdd11fbdd71a5689e012cc63b" translate="yes" xml:space="preserve">
          <source>Each time you click the button, this will invoke incrementClickCounter() on the view model, which in turn changes the view model state, which causes the UI to update.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa9b2101da6336d889f8e0edd362bebf4c734ee" translate="yes" xml:space="preserve">
          <source>Enabling deferred updates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ae64a2d0e5091397c73f3a4af82d2c60920a8a" translate="yes" xml:space="preserve">
          <source>Ensure you call ko.components.register('your-component') &lt;em&gt;before&lt;/em&gt; the HTML parser sees any &amp;lt;your-component&amp;gt; elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="1dad2cf157eb99bbacb6f803399efe19332b4be1" translate="yes" xml:space="preserve">
          <source>Evaluating the computed observable should not cause any side effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb63aeafbc8fa85c1955b6434579c431172024e1" translate="yes" xml:space="preserve">
          <source>Evaluation of a rate-limited computed observable isn&amp;rsquo;t rate-limited; it will re-evaluate if you read its value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a4dd6b0c34a91a968005c6fdb0958613d790b68" translate="yes" xml:space="preserve">
          <source>Even if you don&amp;rsquo;t enable deferred updates for your whole application, you can still benefit from this feature by specifically making certain observables deferred. This is done using the deferred extender:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabc790d00812b33da77b202701e348d39479228" translate="yes" xml:space="preserve">
          <source>Event handling</source>
          <target state="translated">이벤트 처리</target>
        </trans-unit>
        <trans-unit id="ecaca2e0dae16fbf4a4ad04e56b1d2b31b12e57f" translate="yes" xml:space="preserve">
          <source>Everyone loves jQuery! It&amp;rsquo;s an outstanding replacement for the clunky, inconsistent DOM API we had to put up with in the past. jQuery is an excellent low-level way to manipulate elements and event handlers in a web page. KO solves a different problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="translated">실시 예 1</target>
        </trans-unit>
        <trans-unit id="77ef6015f49d42a91349a37284f0d10ce58dfca6" translate="yes" xml:space="preserve">
          <source>Example 1 showed how a writable computed observable can effectively &lt;em&gt;filter&lt;/em&gt; its incoming data by choosing not to write certain values back to the underlying observables if they don&amp;rsquo;t meet some criteria. It ignored full name values that didn&amp;rsquo;t include a space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c47207b8b7ae8ab2d635eb01fc483f744594a47" translate="yes" xml:space="preserve">
          <source>Example 1: A component loader that sets up naming conventions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25518d7fb94487e753554d645c6334d7a18971ef" translate="yes" xml:space="preserve">
          <source>Example 1: Decomposing user input</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea51a4ffde5737f46b31ecbe0d2ce38e03e5c87" translate="yes" xml:space="preserve">
          <source>Example 1: Drop-down list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4cfa89e17777c37aa14362706fd9828f313abe" translate="yes" xml:space="preserve">
          <source>Example 1: Iterating over an array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde8db0303a6ef26ab001c13fc6ef4c4a5867277" translate="yes" xml:space="preserve">
          <source>Example 1: Setting a default value for a binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b080011a40c4eb15898518a2e3a11c9a40dc6a7" translate="yes" xml:space="preserve">
          <source>Example 1: The basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="translated">실시 예 2</target>
        </trans-unit>
        <trans-unit id="de3d10fd223ba2f62435c7e02579b9cdc45e4ca2" translate="yes" xml:space="preserve">
          <source>Example 2: A component loader that loads external files using custom code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="152baefa2649a3e481777e4febefb3f62efbbff0" translate="yes" xml:space="preserve">
          <source>Example 2: Binding expressions to events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9d8b537de776eff6af7ceab0dd013a34c60123d" translate="yes" xml:space="preserve">
          <source>Example 2: Click-to-edit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d220784caedb8582e4b56dcacda886e7debebcbd" translate="yes" xml:space="preserve">
          <source>Example 2: Doing something when the user stops typing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68cfd4d2225424d953c697fb7607585a091cb604" translate="yes" xml:space="preserve">
          <source>Example 2: Live example with add/remove</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3711f3c0d99468999474edf36f69743a26180f" translate="yes" xml:space="preserve">
          <source>Example 2: Multi-select list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b269bb32dd9e2791dd2abef3477feb53abf1d7" translate="yes" xml:space="preserve">
          <source>Example 2: Selecting/deselecting all items</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50e87750a3521296001652d5e8e5eb52d3e10882" translate="yes" xml:space="preserve">
          <source>Example 3: A value converter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ae049f41b4bef03f225ee3aa4c5f8f8e6b59956" translate="yes" xml:space="preserve">
          <source>Example 3: Drop-down list representing arbitrary JavaScript objects, not just strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65ad7a42106a9c349f796f4927c5d9dd3e154f38" translate="yes" xml:space="preserve">
          <source>Example 3: Virtual template elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6ee2315f1fbb9f42c5ff7683886da7013cc130" translate="yes" xml:space="preserve">
          <source>Example 4: Drop-down list representing arbitrary JavaScript objects, with displayed text computed as a function of the represented item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="113b6fb251c660444fac91367247b19ef5ceb219" translate="yes" xml:space="preserve">
          <source>Example 4: Filtering and validating user input</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a7dec77db39f767aebc5bdc16bef64364a4359" translate="yes" xml:space="preserve">
          <source>Example adding checkboxes bound to an array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50416933cd6d1c51d0982199bf3a9959f145560c" translate="yes" xml:space="preserve">
          <source>Example adding radio buttons</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0fb6e0f3233e0276bdc610ce75b2efce4645ad" translate="yes" xml:space="preserve">
          <source>Example with checkbox</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d8ebdde40a810f8bcecb22744e7b919dc5edb75" translate="yes" xml:space="preserve">
          <source>Example with dynamic classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6433628dbf98786e98c232e686cdd5f6a5f19fc7" translate="yes" xml:space="preserve">
          <source>Example with static classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="32d559acc95c5e2026c88355b2fc6dbb56610729" translate="yes" xml:space="preserve">
          <source>Example: A filtered view of an observable array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48ca56b48fa467d7cffa5a1ad762033d25d9baf5" translate="yes" xml:space="preserve">
          <source>Example: A like/dislike widget</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550a2ef513bd2e9716cf255edf159d7eac98e6ab" translate="yes" xml:space="preserve">
          <source>Example: Adding extra levels in the binding context hierarchy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="530246441e8d386c7708bd3e341f39543a901741" translate="yes" xml:space="preserve">
          <source>Example: Avoiding multiple Ajax requests</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed1408f9ac2794bd9571def8f7b6df4057a59a28" translate="yes" xml:space="preserve">
          <source>Example: Avoiding multiple UI updates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2642b17305d614b451304cd70c56ebaa48362c4" translate="yes" xml:space="preserve">
          <source>Example: Controlling whether or not descendant bindings are applied</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3289a0b0b51a0be2ba51f5bf9c959f825caa0c" translate="yes" xml:space="preserve">
          <source>Example: Loading the like/dislike widget from external files, on demand</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6597b4b37cee763a15316f6ba15516f4f3baf020" translate="yes" xml:space="preserve">
          <source>Example: Manual mapping without the ko.mapping plugin</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c298c6fe3398c7d0b1e666fec016b7d667c91616" translate="yes" xml:space="preserve">
          <source>Example: Supplying additional values to descendant bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30054173d63a971c583a297024b8430fbad005a6" translate="yes" xml:space="preserve">
          <source>Example: Using ko.mapping</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b10251ba9ffb2c86c7da769237457e995ac6fa9" translate="yes" xml:space="preserve">
          <source>Excerpt From &lt;a href=&quot;http://addyosmani.com/writing-modular-js/&quot;&gt;Writing Modular JavaScript With AMD, CommonJs &amp;amp; ES Harmony&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bdedba4c5ce2948fd4206f7e11d5e6799420d42" translate="yes" xml:space="preserve">
          <source>Explicitly subscribing to observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1208c99ef5025c09bf368869c5593ca302f58dd8" translate="yes" xml:space="preserve">
          <source>Extending Knockout's binding syntax using preprocessing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477b9ac7b2012a7c4ef01dab5b6738e39bfd0290" translate="yes" xml:space="preserve">
          <source>Extending observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d075b19378326b1dd5562c4110427dc1221e6d9" translate="yes" xml:space="preserve">
          <source>Extracting additional data or state from the form elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa46347e225c51cf57a22ad6da0baa8c26e37d15" translate="yes" xml:space="preserve">
          <source>Finally, to update your view model using this data (without using the mapping plugin), you would write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95a70ce88e1373d7443eeddd31cb4fdbb0259963" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;checkboxes&lt;/strong&gt;, KO will set the element to be &lt;em&gt;checked&lt;/em&gt; when the parameter value is true, and &lt;em&gt;unchecked&lt;/em&gt; when it is false. If you give a value that isn&amp;rsquo;t actually boolean, it will be interpreted loosely. This means that nonzero numbers and non-null objects and non-empty strings will all be interpreted as true, whereas zero, null, undefined, and empty strings will be interpreted as false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28d41ab8ba0a18cc5a9b626ab01db87a9b2b8cd" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;radio buttons&lt;/strong&gt;, KO will set the element to be &lt;em&gt;checked&lt;/em&gt; if and only if the parameter value equals the radio button node&amp;rsquo;s value attribute or the value specified by the checkedValue parameter. In the previous example, the radio button with value=&quot;almond&quot; was checked only when the view model&amp;rsquo;s spamFlavor property was equal to &quot;almond&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d85206a98cfdd4a13c8db149c728546b8ffb8cf" translate="yes" xml:space="preserve">
          <source>For Knockout to be able to load and instantiate your components, you must register them using ko.components.register, providing a configuration as described here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb653bd6fda509ae69de2f3c411ab3f9ecc16aff" translate="yes" xml:space="preserve">
          <source>For a computed observable, the rate-limit timer is triggered when one of the computed observable&amp;rsquo;s dependencies change instead of when its value changes. The computed observable is not re-evaluated until its value is actually needed&amp;mdash;after the timeout period when the change notification should happen, or when the computed observable value is accessed directly. If you need to access the value of the computed&amp;rsquo;s most recent evaluation, you can do so with the peek method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6a669cb32d714a0fa05339382fe1c38249fefbd" translate="yes" xml:space="preserve">
          <source>For a multi-select list, you can read and write the selection state using selectedOptions. Technically this is a separate binding, so it has &lt;a href=&quot;selectedoptions-binding&quot;&gt;its own documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd598195e6041713fa3eb6fa2ec0c343db66800" translate="yes" xml:space="preserve">
          <source>For a very simple example, here&amp;rsquo;s a custom binding called allowBindings that allows descendant bindings to be applied only if its value is true. If the value is false, then allowBindings tells Knockout that it is responsible for descendant bindings so they won&amp;rsquo;t be bound as usual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f738301a087259c2cb88d3ee079875129c0660ae" translate="yes" xml:space="preserve">
          <source>For advanced users, if you want to register your own subscriptions to be notified of changes to observables, you can call their subscribe function. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc285857d05b5c21a59d307e884dc555d9c7a77" translate="yes" xml:space="preserve">
          <source>For complete syntax, see the &lt;a href=&quot;computed-reference&quot;&gt;computed observable reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f8598317b25a1d69826eb855f00f8318431cdf0" translate="yes" xml:space="preserve">
          <source>For documentation on these standard component loader functions, see &lt;a href=&quot;#custom-component-loader&quot;&gt;implementing a custom component loader&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d6aa97d869ac1df9beec0c8c0cbb559a4d3a8d" translate="yes" xml:space="preserve">
          <source>For even better encapsulation, you can package a component into a single self-describing AMD module. Then you can reference a component as simply as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="b6431474d550826b851e8376cf48298a6011540b" translate="yes" xml:space="preserve">
          <source>For example, a componentConfig like {template:'someElementId',viewModel:{require:'myModule'}} can be understood and instantiated by the default loader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63125df5cb160d3708cafec1f0e9b2f0547ee516" translate="yes" xml:space="preserve">
          <source>For example, define a view model as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36572a6a5e79cde64bef7c1785b1f36c362c494f" translate="yes" xml:space="preserve">
          <source>For example, given the following view model class,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c8a073a43cbbbf266ce41b059e8d1e1736f0261" translate="yes" xml:space="preserve">
          <source>For example, if the following is in a file at path/my-component.js,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="389a8f18d6ec0043db2935b9cac1d05b35c584a6" translate="yes" xml:space="preserve">
          <source>For example, if you return 'value + &quot;.toUpperCase()&quot;' as a string, then yourBinding: &quot;Bert&quot; would be interpreted as if the markup contained yourBinding: &quot;Bert&quot;.toUpperCase(). Knockout will parse the returned value in the normal way, so it has to be a legal JavaScript expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1345d943ae097566d0a2d604bb67d731cf352713" translate="yes" xml:space="preserve">
          <source>For example, if you structure your page like this, then everything will be OK:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a37e35428471e05739a74959c92c8f8eda5e555f" translate="yes" xml:space="preserve">
          <source>For example, if your component is inside some other element with an &lt;a href=&quot;if-binding&quot;&gt;if binding&lt;/a&gt; (or another control flow binding), then it will not cause the AMD module to be loaded until the if condition is true. Of course, if the AMD module was already loaded (e.g., in a preloaded bundle) then the require call will not trigger any additional HTTP requests, so you can control what is preloaded and what is loaded on demand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99ffdec1cc7a8a75e2b94b719091deff0a98942" translate="yes" xml:space="preserve">
          <source>For example, instead of writing this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a23df25508d72cfc8abcacad7f0ed1d5ab1eb72" translate="yes" xml:space="preserve">
          <source>For example, rewrite the preceding view model object as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abacb1facc5d8e8adbbbcedeb1ae28fe320f9867" translate="yes" xml:space="preserve">
          <source>For example, the following element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64c9c667af6bb9f6172083bac994162a1c1b7a9a" translate="yes" xml:space="preserve">
          <source>For example, the my-special-list component&amp;rsquo;s template can reference $componentTemplateNodes so that its output includes the supplied markup. Here&amp;rsquo;s the complete working example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b6ff54598ebe3588255d709e9a0c9f753a2b35d" translate="yes" xml:space="preserve">
          <source>For example, you can create interactive components like grids, tabsets, and so on, in the form of custom bindings (see the &lt;a href=&quot;http://knockoutjs.com/examples/grid.html&quot;&gt;grid example&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1a7c228afe4cc9a5c128478008d3b1f5884e84" translate="yes" xml:space="preserve">
          <source>For example, you might have been controlling an element&amp;rsquo;s visibility using the visible binding, but now you want to go a step further and animate the transition. You want elements to slide into and out of existence according to the value of an observable. You can do this by writing a custom binding that calls jQuery&amp;rsquo;s slideUp/slideDown functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0af413f30c072cb2f86c4d5c9c43068f2afe457" translate="yes" xml:space="preserve">
          <source>For example, you might want to enable configuration formats like the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f678f7a6798df2a555b214e68d162f307fd8e326" translate="yes" xml:space="preserve">
          <source>For examples of afterAdd and beforeRemove see &lt;a href=&quot;http://knockoutjs.com/examples/animatedTransitions.html&quot;&gt;animated transitions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fee50827f83055c14d664c8ae49efc9b3ea847" translate="yes" xml:space="preserve">
          <source>For functions that modify the contents of the array, such as push and splice, KO&amp;rsquo;s methods automatically trigger the dependency tracking mechanism so that all registered listeners are notified of the change, and your UI is automatically updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a00e59b8c3067b079a7bc20c769830ca1ae02b" translate="yes" xml:space="preserve">
          <source>For information about how to pass additional parameters to your submit handler function, or how to control the this handle when invoking functions that aren&amp;rsquo;t on your view model, see the notes relating to the &lt;a href=&quot;click-binding&quot;&gt;click binding&lt;/a&gt;. All the notes on that page apply to submit handlers too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7f48a902247b730ada79fe82babfb437d3afca3" translate="yes" xml:space="preserve">
          <source>For loading, update your view model using data that you&amp;rsquo;ve received using one of the above techniques</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7adb7866a71f6f46b996a32c046194acab2ca099" translate="yes" xml:space="preserve">
          <source>For more control, pass a JavaScript object with some combination of the following properties:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad4b6504c8a1b8acae6adc1c35890de1f949db77" translate="yes" xml:space="preserve">
          <source>For more details about these observableArray functions, see the equivalent documentation of the &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array#Methods_2&quot;&gt;standard JavaScript array functions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ebce62a68ac66ad4bdebcd712e571477e40bce" translate="yes" xml:space="preserve">
          <source>For more information about $index and other context properties such as $parent, see documentation for &lt;a href=&quot;binding-context&quot;&gt;binding context properties&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d002e63ef2bdfe307b7dc6dd93d11d5d0f3420e" translate="yes" xml:space="preserve">
          <source>For saving, get your view model data into a simple JSON format so you can send it using one of the above techniques</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22b50f0de3d7cac900daaf7c9e5b4041689cd2f" translate="yes" xml:space="preserve">
          <source>For this to work, the files &lt;a href=&quot;files/component-like-widget.js&quot;&gt;files/component-like-widget.js&lt;/a&gt; and &lt;a href=&quot;files/component-like-widget&quot;&gt;files/component-like-widget.html&lt;/a&gt; need to exist. Check them out (and &lt;em&gt;view source&lt;/em&gt; on the .html one) - as you&amp;rsquo;ll see, this is cleaner and more convenient that including the code inline in the definition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3f6e3b0f1ca1f18fefa1a37d9ba45e25616b20" translate="yes" xml:space="preserve">
          <source>Forcing computed observables to always notify subscribers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84662a42c470dcc749e4f555eafc404bee27a93f" translate="yes" xml:space="preserve">
          <source>Forcing deferred notifications to happen early</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f499a5d8b4de8fa658740f93586939f3677a5ae" translate="yes" xml:space="preserve">
          <source>Forcing deferred observables to always notify subscribers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98d0c19699f7a2e290891f5a4e98f8719c1258d5" translate="yes" xml:space="preserve">
          <source>Forcing observables to always notify subscribers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f54bb0060ff337df25025c131396a49f22403fe7" translate="yes" xml:space="preserve">
          <source>Forcing rate-limited observables to always notify subscribers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e02a1c244564b921ceb8e82920afc310566e328" translate="yes" xml:space="preserve">
          <source>Full details:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c93794a5d7ef6cb3e1c45af5db6db00afa54472" translate="yes" xml:space="preserve">
          <source>Functions on your view model are slightly special because you can reference them by name, i.e., you can write submit: doSomething and &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; have to write submit: viewModel.doSomething (though technically that&amp;rsquo;s also valid).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45c386b929cd8059a6ebbcf8d5cf6632dffb76e7" translate="yes" xml:space="preserve">
          <source>Functions you can implement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b8ebd236050a24d7ee285b263736dd0ada77452" translate="yes" xml:space="preserve">
          <source>Generally, the best way to perform such post-processing on DOM elements is to write a &lt;a href=&quot;custom-bindings&quot;&gt;custom binding&lt;/a&gt;, but if you really just want to access the raw DOM elements emitted by a template, you can use afterRender.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc53371ed103fecb3625d6b54a824260aab0b6d" translate="yes" xml:space="preserve">
          <source>Going back to the classic &amp;ldquo;first name + last name = full name&amp;rdquo; example, you can turn things back-to-front: make the fullName computed observable writable, so that the user can directly edit the full name, and their supplied value will be parsed and mapped back to the underlying firstName and lastName observables. In this example, the write callback handles incoming values by splitting the incoming text into &amp;ldquo;firstName&amp;rdquo; and &amp;ldquo;lastName&amp;rdquo; components, and writing those values back to the underlying observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="e790fc9db2ebd2516f36edd273ef2c230b8019be" translate="yes" xml:space="preserve">
          <source>HTML5-era browsers, which includes &lt;strong&gt;Internet Explorer 9&lt;/strong&gt; and later, automatically allow for custom elements with no difficulties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db3faaddbfebaf215e63526cf28c5c5fa9f0ccf7" translate="yes" xml:space="preserve">
          <source>Headline features:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e7751af05ac722a6fb5ef531e8dadad667d4de0" translate="yes" xml:space="preserve">
          <source>Here a few situations in which you might want to use these mapping options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e69de42d839b42bf754d25ca92cab286df4be6" translate="yes" xml:space="preserve">
          <source>Here is a very basic example of switching the binding context to a child object. Notice that in the data-bind attributes, it is &lt;em&gt;not&lt;/em&gt; necessary to prefix latitude or longitude with coords., because the binding context is switched to coords.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b82739780a396a71434b267de5bea3a454dbbe20" translate="yes" xml:space="preserve">
          <source>Here is an example of a configuration that will add some text to the incoming data before updating:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3280dba535f19f2febc60673f89c1a84ba00d47d" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s &lt;a href=&quot;http://jsfiddle.net/rniemeyer/NW5Vn/&quot;&gt;a simple implementation of integrating Underscore templates with Knockout&lt;/a&gt;. The integration code is just 16 lines long, but it&amp;rsquo;s enough to support Knockout data-bind attributes (and hence nested templates) and Knockout &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; variables ($parent, $root, etc.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84443bf9a128caa94205efa8ada501ff154e881b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a trivial example that uses afterAdd to apply the classic &amp;ldquo;yellow fade&amp;rdquo; effect to newly-added items. It requires the &lt;a href=&quot;https://github.com/jquery/jquery-color&quot;&gt;jQuery Color plugin&lt;/a&gt; to enable animation of background colors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37cf14e229e69417a43a02c23085e0aa99c73561" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a way to define a filterByProperty function that will become available on all subsequently-created ko.observableArray instances:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb66c98e55cbff21c223380e9a5374ec4c0a1ef" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05ce77e66ba4c65f03af6e3ab19e65b03d68454" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of using the above custom binding:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b583251e6c4a39e879523f6accea2dbf4b4259" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example that uses optionsAfterRender to add a disable binding to each option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b31c34d144c1947d36ca331230826869c8a16e" translate="yes" xml:space="preserve">
          <source>How Knockout loads components via AMD</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e306597890108bc7fc111d560e6054689ac6ebc" translate="yes" xml:space="preserve">
          <source>How dependency tracking works</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93fddf00520975913c2fecc46ee1c69334b1426a" translate="yes" xml:space="preserve">
          <source>How is Knockout different?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47ba114c765ebcdb727f9bec12dc3ebaf5886692" translate="yes" xml:space="preserve">
          <source>How things are mapped</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361fb2674c6c2b62b9aae1a7ce5281fcff2e1a0b" translate="yes" xml:space="preserve">
          <source>How to create an extender</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae005b5e0ed8d5109a9c1e98c6cbd19a088774bc" translate="yes" xml:space="preserve">
          <source>However, if you &lt;em&gt;do&lt;/em&gt; want to let the default action proceed, just return true from your event handler function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ce42b8e7f69d107832250d68dbd01a878deeb2" translate="yes" xml:space="preserve">
          <source>However, if you &lt;em&gt;do&lt;/em&gt; want to let the default click action proceed, just return true from your click handler function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e2915dc92ca412b52398579f1e49c3c8348959" translate="yes" xml:space="preserve">
          <source>However, if you use value to link a form element to a &lt;em&gt;non&lt;/em&gt;-observable property (e.g., a plain old string, or an arbitrary JavaScript expression), KO will do the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c30fbacefa412111122658b9f8bc072a603ddd1" translate="yes" xml:space="preserve">
          <source>However, it does &lt;em&gt;not&lt;/em&gt; work with virtual elements. If you try the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8531b5d91c66d42745ea8deb05f270abe4564d92" translate="yes" xml:space="preserve">
          <source>However, it does not make sense to use bindings that would modify the element&amp;rsquo;s contents, such as the &lt;a href=&quot;text-binding&quot;&gt;text&lt;/a&gt; or &lt;a href=&quot;template-binding&quot;&gt;template&lt;/a&gt; bindings, since they would overwrite the template injected by your component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b2c1d7baa87a948e36706143a1b3bd56c309bf4" translate="yes" xml:space="preserve">
          <source>However, many developers prefer to use a more conventions-based approach to updating their view models using incoming data without manually writing a line of code for every property to be updated. This can be beneficial if your view models have many properties, or deeply nested data structures, because it can greatly reduce the amount of manual mapping code you need to write. For more details about this technique, see &lt;a href=&quot;plugins-mapping&quot;&gt;the knockout.mapping plugin&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df78c9be1d978ee24c637cf614f8f43143a6b702" translate="yes" xml:space="preserve">
          <source>However, sometimes you might not want that behavior. If instead you want Knockout to allow your model observable to take values that have no corresponding entry in the &amp;lt;select&amp;gt;, then specify valueAllowUnset: true. In this case, whenever your model value cannot be represented in the &amp;lt;select&amp;gt;, then the &amp;lt;select&amp;gt; simply has no selected value at that time, which is visually represented by it being blank. When the user later selects an entry from the dropdown, this will be written to your model as usual. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0df1b7294fed0a051d101c1ced30ea172ab4baf7" translate="yes" xml:space="preserve">
          <source>However, the value of the computed property is itself an observable. This would seem to lead to an awkward scenario, where reading its current value would involve double-unwrapping (i.e., params.myExpr()(), where the first parentheses give the value of the expression, and the second give the value of the resulting observable instance).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4ce8e4d8bb3b24ee5b708a10a1169afa34a1e3" translate="yes" xml:space="preserve">
          <source>IE 6 does not allow radio buttons to be checked if they don&amp;rsquo;t have a name attribute. Most of the time this is irrelevant because your radio button elements &lt;em&gt;will&lt;/em&gt; have name attributes to put them into mutually-exclusive groups. However, just in case you didn&amp;rsquo;t add a name attribute because it&amp;rsquo;s unnecessary in your case, KO will internally use uniqueName on those elements to ensure they can be checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fcefc92a53613238743a06738a1a958455ef2e0" translate="yes" xml:space="preserve">
          <source>IE 6 has a strange quirk whereby it sometimes ignores whitespace that immediately follows an empty span. This has nothing directly to do with Knockout, but in case you do want to write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91559d59670bd974a48fef061e5a488f693ecb19" translate="yes" xml:space="preserve">
          <source>IE 6-8&amp;rsquo;s HTML parser will discard any unrecognized elements. To ensure it doesn&amp;rsquo;t throw out your custom elements, you must do one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa5f5e45ca2c0ef94cde806f22f9193ea7e171a" translate="yes" xml:space="preserve">
          <source>If a dependency is on an external object, then be sure to use .dispose() on the computed property, otherwise it (and possibly also your viewmodel) will be held in memory. Alternatively, consider using a &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed&lt;/a&gt; to avoid the need for manual disposal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97a8252f992217661b3da8e9168c34da29b4082" translate="yes" xml:space="preserve">
          <source>If a parameter&amp;rsquo;s evaluation &lt;strong&gt;does not&lt;/strong&gt; involve evaluating an observable/computed, it is passed literally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85bdcb92d8fed08ef07c5a9167f6303fb9542783" translate="yes" xml:space="preserve">
          <source>If a parameter&amp;rsquo;s evaluation &lt;strong&gt;does&lt;/strong&gt; involve evaluating one or more observables/computeds, it is passed as a computed property so that you can react to changes in the parameter value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f49d13df2276280d49d2672aa1b68bc3513435f" translate="yes" xml:space="preserve">
          <source>If a task throws an exception, it will not interrupt the task queue, which will continue until it is empty. The exception will instead be postponed to a later event and can be handled using &lt;a href=&quot;asynchronous-error-handling&quot;&gt;ko.onError&lt;/a&gt; or window.onerror.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e58b3f0b1346e29b75ea079a4a3af7f374c623" translate="yes" xml:space="preserve">
          <source>If any of the parameters passed to the component is observable, then the component can of course observe any changes, or even write back modified values. This is how it can communicate cleanly with its parent, without tightly coupling the component code to any parent that uses it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2042df6fe8e9a541f83353153b54cf9ca0fb63e" translate="yes" xml:space="preserve">
          <source>If declared, Knockout will call this function to convert a componentConfig object into a viewmodel/template pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="399dea5a85a9f6316a3592794fb48cd5d6a619e0" translate="yes" xml:space="preserve">
          <source>If declared, Knockout will call this function to obtain a configuration object for each component being instantiated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4cb475157b09548b6d107ebd37c013b2c16886" translate="yes" xml:space="preserve">
          <source>If defined, this function will be called for each &amp;lt;name&amp;gt; binding before the binding is evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a046840fb4cbdaaea31db2bea0e71b5d3908b95" translate="yes" xml:space="preserve">
          <source>If defined, this function will be called for each DOM node before bindings are processed. The function can modify, remove, or replace node. Any new nodes must be inserted immediately before node, and if any nodes were added or node was removed, the function must return an array of the new nodes that are now in the document in place of node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a2cb3b57840c0deef2eb7e49e7b4db257ff08df" translate="yes" xml:space="preserve">
          <source>If no viewmodel is given, the component is treated as a simple block of HTML that will be bound to any parameters passed to the component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6caa6867d855ce7ca277ec137fe7e6b2092a7de4" translate="yes" xml:space="preserve">
          <source>If required, you can remove ko.components.defaultLoader from the loaders array altogether.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03317c5ba9cb772a076d1cd9742af2eaadf6c3ea" translate="yes" xml:space="preserve">
          <source>If the array you supply is observable, the foreach binding will respond to any future changes in the array&amp;rsquo;s contents by adding or removing corresponding sections of markup in the DOM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72ef00d24a33559e687f508a59c22e7850ec79c" translate="yes" xml:space="preserve">
          <source>If the component binding&amp;rsquo;s name value changes observably, or if an enclosing control-flow binding causes the container element to be removed, then any dispose function on the viewmodel is called just before the container element is removed from the DOM. See also: &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;disposal and memory management&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354afd97c35f636203d9262ca360ec893a10aa03" translate="yes" xml:space="preserve">
          <source>If the expression you supply evaluates to null or undefined, descendant elements will &lt;em&gt;not&lt;/em&gt; be bound at all, but will instead be removed from the document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="348434b438cb1d0346b5c2336a1b0270a699841f" translate="yes" xml:space="preserve">
          <source>If the expression you supply involves any observable values, the expression will be re-evaluated whenever any of those observables change. Then, descendant elements will be cleared out, and &lt;strong&gt;a new copy of the markup&lt;/strong&gt; will be added to your document and bound in the context of the new evaluation result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61935dcf249e331edbcc8210b8ebbb2409b5384" translate="yes" xml:space="preserve">
          <source>If the firstName observable&amp;rsquo;s value was changed to Ted, then the console would show first name: Ted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ee5b54e158b99edb3b0d00a6d84366ceb29486" translate="yes" xml:space="preserve">
          <source>If the user manually focuses or unfocuses the associated element, the viewmodel property will be set to true or false accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbaee0a673e126908759d4192388e02a5778a34a" translate="yes" xml:space="preserve">
          <source>If the value you supply is observable, the hasFocus binding will update the element&amp;rsquo;s focus state whenever that observable value changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5c5acd515e8ae2158bb6854344b82731dca4d6c" translate="yes" xml:space="preserve">
          <source>If the viewmodel is given as a constructor function, this means Knockout calls new YourViewModel(params).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a19cfa23e05247f726bb0c3e3e11110deb972d" translate="yes" xml:space="preserve">
          <source>If the viewmodel is given as a createViewModel factory function, Knockout calls createViewModel(params, componentInfo), where componentInfo.element is the element into which the not-yet-bound template has already been injected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105d045e38636fe798ecdb5a45a203d90df04fff" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s available options whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s available options once and will not update them again later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1eb730b6d4db61f330d71ef6135d8fac903258" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s content whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s content once and will not update it again later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d54c813843091459c90fd11e7297fc0446687938" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s text whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s text once and will not update it again later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a744e971b96b18141128533922f19a87beb8881" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s value whenever the observable value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s value once and will not update it again later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47eda63e6c27e664a420f7aabc543742f5f58f16" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s value whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s value once and will not update it again later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697682d3cadcd44d9c1d1305da3a61036fdfa605" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s visibility whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s visibility once and will not update it again later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f45c52f51bf20ce24a7e4b608d15ab347ed9c290" translate="yes" xml:space="preserve">
          <source>If valueAllowUnset had not been enabled, then Knockout would have overwritten selectedCountry with undefined, so that it would match the value of the 'Choose one...' caption entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3ea4a49bfcd03916cd06d69dac827b155984b2" translate="yes" xml:space="preserve">
          <source>If you are trying to bind an &amp;lt;input type=&quot;text&quot; /&amp;gt; or &amp;lt;textarea&amp;gt; to get instant updates to your viewmodel, use the &lt;a href=&quot;textinput-binding&quot;&gt;the textInput binding&lt;/a&gt;. It has better support for browser edge cases than any combination of valueUpdate options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a7f396d14387545628545aeb2802baaa004a716" translate="yes" xml:space="preserve">
          <source>If you are using a component loader to fetch components by a naming convention, and are &lt;em&gt;not&lt;/em&gt; registering your components using ko.components.register, then those components will not automatically be usable as custom elements (because you haven&amp;rsquo;t told Knockout that they even exist).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57acecaab300936e5fb81a00ce2ade1592a7db93" translate="yes" xml:space="preserve">
          <source>If you are using foreach and only want to be notified about elements that are specifically being added or are being removed, you can use afterAdd and beforeRemove instead. For details, see documentation for the &lt;a href=&quot;foreach-binding&quot;&gt;foreach binding&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce083543ff1be7a981205d49b50c12c2d35aab21" translate="yes" xml:space="preserve">
          <source>If you are using static CSS class names, then you can pass a JavaScript object in which the property names are your CSS classes, and their values evaluate to true or false according to whether the class should currently be applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b409ece9cd23f86abee691f7b17d7b89e59dbba4" translate="yes" xml:space="preserve">
          <source>If you are using the default component loader, and hence are registering your components using ko.components.register, then there is nothing extra you need to do. Components registered this way are immediately available for use as custom elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ddcd80cbca13d044050f160b5fe2da2f4edef8d" translate="yes" xml:space="preserve">
          <source>If you commonly include template content using virtual elements, the normal syntax can feel a bit verbose. Using preprocessing, you can add a new template format that uses a single comment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39dac748b82ce1d7e9df2f75a51a1b265e4aee88" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a configuration for the named component, then call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a803a11622a50576c908d4836ed761b181f5ff65" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a createViewModel function for the given parameters (e.g., because it does not recognize the configuration format), call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a98aefdcf31a903e5d480df483166240bfba37" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a template for the given parameters (e.g., because it does not recognize the configuration format), call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96bd57dfc5e8e227d695eb9cc1de257c99d1c474" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a viewmodel/template pair for the given parameters, then call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c512ba9128c02d4d1a3f480875fdee4dc35677d7" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to display just a simple property value as the text for each item in the dropdown, you can pass a JavaScript function for the optionsText option and supply your own arbitrary logic for computing the displayed text in terms of the represented object. See Example 4 above, which shows how you could generate the displayed text by concatenating together multiple property values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4830a1b281a9a9be8b4899be04ed0ad714a44701" translate="yes" xml:space="preserve">
          <source>If you have a reference to a DOM element in your code, you can use it as a container for template markup:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fc07db8d07ca18d202ff7e05a94198b45413180" translate="yes" xml:space="preserve">
          <source>If you have an AMD loader (such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;) already in your page, then you can use it to fetch a template. For more details about how this works, see &lt;a href=&quot;#how-knockout-loads-components-via-amd&quot;&gt;how Knockout loads components via AMD&lt;/a&gt; below. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a69d18b622bb3cca3c70f1710dff19c9f5aca93" translate="yes" xml:space="preserve">
          <source>If you have an AMD loader (such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;) already in your page, then you can use it to fetch a viewmodel. For more details about how this works, see &lt;a href=&quot;#how-knockout-loads-components-via-amd&quot;&gt;how Knockout loads components via AMD&lt;/a&gt; below. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d613332487fc8236cb7e6d5e6bc539bf312e263" translate="yes" xml:space="preserve">
          <source>If you have implemented a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt;, and are not using ko.components.register, then you need to tell Knockout about any element names you wish to use as custom elements. To do this, simply call ko.components.register - you don&amp;rsquo;t need to specify any configuration, since your custom component loader won&amp;rsquo;t be using the configuration anyway. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6dc783c88a9a55d059f753b19bf7c4b10f1293f" translate="yes" xml:space="preserve">
          <source>If you have multiple named templates, you can pass an observable for the name option. As the observable&amp;rsquo;s value is updated, the element&amp;rsquo;s contents will be re-rendered using the appropriate template. Alternatively, you can pass a callback function to determine which template to use. If you are using the foreach template mode, Knockout will evaluate the function for each item in your array, passing that item&amp;rsquo;s value as the only argument. Otherwise, the function will be given the data option&amp;rsquo;s value or fall back to providing your whole current model object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9fde0bfc8d899331beb6d9ec952dcb2dab1b640" translate="yes" xml:space="preserve">
          <source>If you have subscribed to an external observable, be sure to use .dispose() on the subscription, otherwise the callback (and possibly also your viewmodel) will be held in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c4d57bb828a71531ceeb4aa49b28a3c60f87e52" translate="yes" xml:space="preserve">
          <source>If you leave off the value of a binding, it&amp;rsquo;s bound to undefined by default. If you want to have a different default value for a binding, you can do so with a preprocessor. For example, you can allow uniqueName to be bound without a value by making its default value true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df6baaff79cb69e31e568c59ade70f1456f1c34c" translate="yes" xml:space="preserve">
          <source>If you need to pass more parameters, one way to do it is by wrapping your handler in a function literal that takes in a parameter, as in this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="395b1c02e2a6fd4dd3478f8ed3123de446425e64" translate="yes" xml:space="preserve">
          <source>If you need to run some further custom logic on the generated DOM elements, you can use any of the afterRender/afterAdd/beforeRemove/beforeMove/afterMove callbacks described below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e172b40bc2aac406378c1826a63899ef1e1c8897" translate="yes" xml:space="preserve">
          <source>If you need to run some further custom logic on the generated option elements, you can use the optionsAfterRender callback. See Note 2 below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0946163467362f9f0453888bade424cd2a18cd9" translate="yes" xml:space="preserve">
          <source>If you need to run some further custom logic on the generated option elements, you can use the optionsAfterRender callback. The callback function is invoked each time an option element is inserted into the list, with the following parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7add5138afadba9db94cdfc48e15c94798748a29" translate="yes" xml:space="preserve">
          <source>If you need to set HTML content in this manner, see &lt;a href=&quot;html-binding&quot;&gt;the html binding&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e813a05b4d4fc8d95d220cb80a0c91d23fba7f44" translate="yes" xml:space="preserve">
          <source>If you only need to combine updates without adding a delay, &lt;a href=&quot;deferred-updates&quot;&gt;deferred updates&lt;/a&gt; provides a more efficient method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e7be95f226e675b640699b19295d6d29cb25a1d" translate="yes" xml:space="preserve">
          <source>If you only need to use the compound full name in the UI you could declare it as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd19412014a27de66dbd7f90139a256b3d51da33" translate="yes" xml:space="preserve">
          <source>If you open your browser developer tools&amp;rsquo; &lt;strong&gt;Network&lt;/strong&gt; inspector before your first click on &lt;em&gt;Add product&lt;/em&gt;, you&amp;rsquo;ll see that the component&amp;rsquo;s .js/.html files are fetched on demand when first required, and thereafter retained for reuse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e3531ed2ee3130336ffaac70ea47406b8f9ad62" translate="yes" xml:space="preserve">
          <source>If you pass just a string, it is interpreted as a component name. The named component is then injected without supplying any parameters to it. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8655e03ea768a2840f2c814ce3e4612e25b0a0e" translate="yes" xml:space="preserve">
          <source>If you prefer, you could combine templateFromUrlLoader and viewModelCustomLoader into a single loader by putting the loadTemplate and loadViewModel functions on a single object. However it&amp;rsquo;s quite nice to separate out these concerns, since their implementations are quite independent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d9099195cbde906f499c9495d5f5fd785651e50" translate="yes" xml:space="preserve">
          <source>If you refer to model properties in a params attribute, then you are of course referring to the properties on the viewmodel outside the component (the &amp;lsquo;parent&amp;rsquo; or &amp;lsquo;host&amp;rsquo; viewmodel), since the component itself is not instantiated yet. In the above example, myModelValue would be a property on the parent viewmodel, and would be received by the child component viewmodel&amp;rsquo;s constructor as params.someModelProperty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b53a3732a6bc04d508eda25f801b0bef1ad6dfd" translate="yes" xml:space="preserve">
          <source>If you reference a &lt;em&gt;simple property&lt;/em&gt;, i.e., it is just a regular property on your view model, KO will set the form element&amp;rsquo;s initial state to the property value, and when the form element is edited, KO will write the changes back to your property. It cannot detect when the property changes (because it isn&amp;rsquo;t observable), so this is only a 1-way binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d891ed8be741967c449e958da98ffc8cc566217" translate="yes" xml:space="preserve">
          <source>If you reference something that is &lt;em&gt;not&lt;/em&gt; a simple property, e.g., the result of a function call or comparison operation, KO will set the form element&amp;rsquo;s initial state to that value, but it will not be able to write any changes back when the user edits the form element. In this case it&amp;rsquo;s a one-time-only value setter, not an ongoing binding that reacts to changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4136055364963301ac3a0672768006e0b60b4010" translate="yes" xml:space="preserve">
          <source>If you set the viewmodel property to true or false, the associated element will become focused or unfocused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea10c506e67e02d37f3ff59d06b553132c889a0" translate="yes" xml:space="preserve">
          <source>If you supply something other than a number or a string (e.g., you pass an object or an array), the displayed text will be equivalent to yourParameter.toString()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f936a4cf3802ef50c0aec5ecfef503f372a0ded" translate="yes" xml:space="preserve">
          <source>If you supply something other than a number or a string (e.g., you pass an object or an array), the displayed text will be equivalent to yourParameter.toString() (that&amp;rsquo;s usually not very useful, so it&amp;rsquo;s best to supply string or numeric values).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33531730aa65cc0aed58be0f106c04649fd218ba" translate="yes" xml:space="preserve">
          <source>If you supply something other than a number or a string (e.g., you pass an object or an array), the innerHTML will be equivalent to yourParameter.toString()</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0c67876e2d6e6a962ee02ea3bfd2bc8d147be3f" translate="yes" xml:space="preserve">
          <source>If you tend to filter observable arrays a lot, adding a filterByProperty globally to all observable arrays might make your code tidier. But if you only need to filter occasionally, you could instead choose &lt;em&gt;not&lt;/em&gt; to attach to ko.observableArray.fn, and instead just construct doneTasks by hand as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e10e3c94b35fd8632dab2ca5d675651a6b4f0bb0" translate="yes" xml:space="preserve">
          <source>If you use value to link a form element to an observable property, KO is able to set up a 2-way binding so that changes to either affect the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e93054a2d66f23c13f6c50afc30a17cac10665b4" translate="yes" xml:space="preserve">
          <source>If you want Knockout to allow your model property to take values that have no corresponding entry in your &amp;lt;select&amp;gt; element (and display this by making the &amp;lt;select&amp;gt; element blank), then see &lt;a href=&quot;value-binding#using-valueallowunset-with-select-elements&quot;&gt;documentation for valueAllowUnset&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a89bcaf9d5696bd11fb99d2d58e919ab34e4a21" translate="yes" xml:space="preserve">
          <source>If you want a custom binding to be usable with Knockout&amp;rsquo;s &lt;em&gt;virtual elements&lt;/em&gt; syntax, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12de6cba1d2b34cbb4e79120d38a72eb8f87f4f5" translate="yes" xml:space="preserve">
          <source>If you want all instances of your component to share the same viewmodel object instance (which is not usually desirable):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f370654b97f0f29acfaf8c9f3cbd1053b47dfd4" translate="yes" xml:space="preserve">
          <source>If you want the equivalent of a foreach binding, but using a named template, you can do so in the natural way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0687bb9af427b875127182534a1eca56e0d6596" translate="yes" xml:space="preserve">
          <source>If you want the mapping plugin to ignore some properties of your JS object (i.e. to not map them), you can specify an array of propertynames to ignore:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48877e0877c23be66516c571a7f2f9808b04bbbc" translate="yes" xml:space="preserve">
          <source>If you want the mapping plugin to only create observables of some properties of your JS object and copy the rest, you can specify an array of propertynames to observe:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a610cb362a9cb355f038caa3483260b1682b467" translate="yes" xml:space="preserve">
          <source>If you want to access data/functions from parent binding contexts, you can use &lt;a href=&quot;binding-context&quot;&gt;special context properties such as $parent and $root&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5e8a9598e8913d6b161a0231caddfc4c3d6385d" translate="yes" xml:space="preserve">
          <source>If you want to apply a font-weight or text-decoration style, or any other style whose name isn&amp;rsquo;t a legal JavaScript identifier (e.g., because it contains a hyphen), you must use the &lt;em&gt;JavaScript name&lt;/em&gt; for that style. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1a7840c3566eba919210c187885f629cdea7e6" translate="yes" xml:space="preserve">
          <source>If you want to apply the CSS class my-class, you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; write this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="400ea2089a975a1be517a84a31ee89203ffb5ce6" translate="yes" xml:space="preserve">
          <source>If you want to apply the attribute data-something, you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; write this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="926dd1aabde3cc388fd5f78c44f8b0dc656ffe88" translate="yes" xml:space="preserve">
          <source>If you want to be notified of the value of an observable before it is about to be changed, you can subscribe to the beforeChange event. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc22f6555d4554142d875304efe0f5c3fb52625" translate="yes" xml:space="preserve">
          <source>If you want to change the policy for a particular component, you can specify synchronous: true on that component&amp;rsquo;s configuration. Then it might load asynchronously on first use, followed by synchronously on all subsequent uses. If you do this, then you need to account for this changeable behavior in any code that waits for components to load. However, if your component can always be loaded and initialized synchronously, then enabling this option will ensure consistently synchronous behavior. This might be important if you&amp;rsquo;re using a component within a foreach binding and want to use the afterAdd or afterRender options to do post-processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d46531ca9799ade7ca26f1bed17707b4876bd54" translate="yes" xml:space="preserve">
          <source>If you want to convert your mapped object back to a regular JS object, use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20972324a8ac6446023da390397678c0423402dd" translate="yes" xml:space="preserve">
          <source>If you want to detect and respond to changes on one object, you&amp;rsquo;d use &lt;a href=&quot;observables&quot;&gt;observables&lt;/a&gt;. If you want to detect and respond to changes of a &lt;em&gt;collection of things&lt;/em&gt;, use an observableArray. This is useful in many scenarios where you&amp;rsquo;re displaying or editing multiple values and need repeated sections of UI to appear and disappear as items are added and removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dbe5851856488928c88861ca66a429c2a8a54c3" translate="yes" xml:space="preserve">
          <source>If you want to detemine text programmatically, one option is to create a &lt;a href=&quot;computedobservables&quot;&gt;computed observable&lt;/a&gt;, and use its evaluator function as a place for your code that works out what text to display.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0e5d4f6f665f1af91a7e87e9210302dace1de3d" translate="yes" xml:space="preserve">
          <source>If you want to do this in custom bindings, then instead of using bindingContext.extend(), use bindingContext.createChildContext(someData). This returns a new binding context whose viewmodel is someData and whose $parentContext is bindingContext. If you want, you can then extend the child context with extra properties using ko.utils.extend. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87af9ca294d83f6fba572d78050da057a49b8c89" translate="yes" xml:space="preserve">
          <source>If you want to ensure that the subscribers are always notified of an update, even if the value is the same, you would use the notify extender in addition to rateLimit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44cdfd3b6064088d2c5aa5fc20d93a5155c03685" translate="yes" xml:space="preserve">
          <source>If you want to handle a part of the mapping yourself, you can also provide a create callback. If this callback is present, the mapping plugin will allow you to do this part of the mapping yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72b1f64bd3585abcdb719c6af16ba28b06cb4a0c" translate="yes" xml:space="preserve">
          <source>If you want to have different custom element tag names, you can override getComponentNameForNode to control this. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f48f247482677e3d298eb9f8794c7720f2d28823" translate="yes" xml:space="preserve">
          <source>If you want to map the children array yourself, you can specify that like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1351e5f77b9081488d46eb8f548df93a34b7ae41" translate="yes" xml:space="preserve">
          <source>If you want to run any setup logic on the associated element before it is bound to the viewmodel, or use arbitrary logic to decide which viewmodel class to instantiate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c66df88a215f6f7b24bd3deee59aec7e6d2e2f59" translate="yes" xml:space="preserve">
          <source>If you want to use dynamic CSS class names, then you can pass a string that corresponds to the CSS class or classes that you want to add to the element. If the parameter references an observable value, then the binding will remove any previously added classes and add the class or classes corresponding to the observable&amp;rsquo;s new value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d39bf93c568ed46321d7833a330f6569b221b30" translate="yes" xml:space="preserve">
          <source>If you want your custom loader to take precedence over the default loader (so it gets the first opportunity to supply configuration/values), then add it to the &lt;em&gt;beginning&lt;/em&gt; of the array. If you want the default loader to take precedence (so your custom loader is only called for components not explicitly registered), then add it to the &lt;em&gt;end&lt;/em&gt; of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ceafe6c0f244a6b62bf46e8591b041a309c0459" translate="yes" xml:space="preserve">
          <source>If you want your observable array &lt;strong&gt;not&lt;/strong&gt; to start empty, but to contain some initial items, pass those items as an array to the constructor. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e61100d48bd38e328d61f92193723be823f648bd" translate="yes" xml:space="preserve">
          <source>If you wanted, you could use $data as a prefix when referencing properties on each entry. For example, you could rewrite part of &lt;a href=&quot;#example-1-iterating-over-an-array&quot;&gt;Example 1&lt;/a&gt; as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0c200b210145556f08539e16369c8ae1101651" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to be able to bind expressions to click events (rather than a function reference as Knockout expects), you can set up a preprocessor for the click handler to support this syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="907374589d9e730eb5f8d2c95837b3f35a14d2f1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to migrate code from using the deprecated throttle extender, you should note the following ways that the rateLimit extender is different from the throttle extender.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82cf070f85ee99e13abeb8d98714402eb45540b9" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building configurations programmatically and you have a DocumentFragment object, you can use it as a component template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="362388121008c8da14509414fa3107e12b516595" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building configurations programmatically and you have an array of DOM nodes, you can use them as a component template:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5fbe4f70abc50527b7288b53aa01cad2d4a9fe8" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re inside a nested &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;, for example if you&amp;rsquo;re inside a foreach or a with block, but your handler function is on the root viewmodel or some other parent context, you&amp;rsquo;ll need to use a prefix such as $parent or $root to locate the handler function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b30aa6dd1b7b726ed22a1386408193b3ed07cc63" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not a fan of the &amp;lt;%= ... %&amp;gt; delimiters, you can configure the Underscore template engine to use any other delimiter characters of your choice.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="128a03e2b47df3a4720a787432ce69b6c26af34a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re within the context of a particular &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; template, then $component refers to the viewmodel for that component. It&amp;rsquo;s the component-specific equivalent to $root. In the case of nested components, $component refers to the viewmodel for the closest component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8207088fe6ea022be6846a6dde93cdfdbb4659e7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re within the context of a particular &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; template, then $componentTemplateNodes is an array containing any DOM nodes that were passed to that component. This makes it easy to build components that receive templates, for example a grid component that accepts a template to define its output rows. For a complete example, see &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;passing markup into components&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50cd6a8b962993f971b8353a9f4567faa0ee548a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re working with AMD, then you might prefer a structure like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d7b9ced2efd23f656198e4a25fb4db243307f5a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve loaded some data from the server and want to use it to update your view model, the most straightforward way is to do it yourself. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf20ec3aaef79dcc3c3e98b605cfa93d5c521bb6" translate="yes" xml:space="preserve">
          <source>If your Ajax call returns a JSON string (and does not deserialize it into a JavaScript object), then you can use the function ko.mapping.fromJSON to create and update your view model instead. To unmap, you can use ko.mapping.toJSON.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b44f19840a62453340adc3a1ccb826f912401798" translate="yes" xml:space="preserve">
          <source>If your binding also includes a parameter called valueUpdate, this defines additional browser events KO should use to detect changes besides the change event. The following string values are the most commonly useful choices:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d155bf9b29c1f0a2a9418e2feadc2ccfa15452dc" translate="yes" xml:space="preserve">
          <source>If your binding also includes checkedValue, this defines the value used by the checked binding instead of the element&amp;rsquo;s value attribute. This is useful if you want the value to be something other than a string (such as an integer or object), or you want the value set dynamically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10fa5bcf76b5721cd82848b0bb414540b34d62f" translate="yes" xml:space="preserve">
          <source>If your checkedValue parameter is an observable value, whenever the value changes and the element is currently checked, the binding will update the checked model property. For checkboxes, it will remove the old value from the array and add the new value. For radio buttons, it will just update the model value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dbc2f2301ffac98a49b2e6297ccb2fb1e2c8d49" translate="yes" xml:space="preserve">
          <source>If your component configuration has a boolean synchronous property, Knockout uses this to determine whether the component is allowed to be loaded and injected synchronously. The default is false (i.e., forced to be asynchronous). For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9854050320055febc419828d11cb1650e59a3b0" translate="yes" xml:space="preserve">
          <source>If your computed observable simply calculates and returns a value based on some observable dependencies, then it&amp;rsquo;s better to declare it as a ko.pureComputed instead of a ko.computed. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f07feff737da55640367588cd5b8867853add3d9" translate="yes" xml:space="preserve">
          <source>If your custom loader implements loadTemplate and/or loadViewModel, then you can plug in custom code to the loading process. You can also use these functions to interpret custom configuration formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e85383888aee26e47a33473edbdb8e84955e5a" translate="yes" xml:space="preserve">
          <source>If your expression involves any observable values, the expression will be re-evaluated whenever any of them change. Correspondingly, the markup within your if block can be added or removed dynamically as the result of the expression changes. data-bind attributes will be applied to &lt;strong&gt;a new copy of the contained markup&lt;/strong&gt; whenever it is re-added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226676b80f71bd0aee4405b7dbac5960cfd4e3e7" translate="yes" xml:space="preserve">
          <source>If your function accepts a second parameter, then it will receive the entire &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;. You can then access $parent or any other &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; variable when dynamically choosing a template. For example, you could amend the preceding code snippet as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b4eec9f8db27a16ed532421672ba7179cce19f2" translate="yes" xml:space="preserve">
          <source>If your function references observable values, then the binding will update whenever any of those values change. This will cause the data to be re-rendered using the appropriate template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6374db41fb1a34f6794e3a7a263b2a5d8f3d6ae6" translate="yes" xml:space="preserve">
          <source>If your parameter is an observable array, the binding will update the element&amp;rsquo;s selection whenever the array changes (e.g., via push, pop or &lt;a href=&quot;observablearrays&quot;&gt;other observable array methods&lt;/a&gt;). If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s selection state once and will not update it again later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ddb383dfae6006d12773bd8bc5511d587b2ccb9" translate="yes" xml:space="preserve">
          <source>If your parameter is an observable value, the binding will update the element&amp;rsquo;s checked state whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s checked state once and will not update it again later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fff36bdc6055d9bb8992e0fdfb26a189710fb02" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will add or remove the CSS class whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only add or remove the class once and will not do so again later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6f113eec157fdb2ab367ee2fd9cbd80ddb0996" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will update the attribute whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only set the attribute once and will not update it later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="633f858df401ebd55c78f8496da63fdb61af5458" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will update the enabled/disabled state whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only set the state once and will not do so again later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3819bd4ed3fd60e94476b444ece0ada882cf49" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will update the styles whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only set the styles once and will not update them later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c0408c9bf4c4a37030fc7cdecf2361bd78f581" translate="yes" xml:space="preserve">
          <source>If your parameter&amp;rsquo;s value is an array of strings, you don&amp;rsquo;t need to give any other parameters. The &amp;lt;select&amp;gt; element will display an option for each string value. However, if you want to let the user choose from an array of &lt;em&gt;arbitrary JavaScript objects&lt;/em&gt; (not merely strings), then see the optionsText and optionsValue parameters below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a69077a26824bf6bf1d9998d4bf4a08fe6a1767d" translate="yes" xml:space="preserve">
          <source>If, like in the example above, you are performing the mapping inside of a class, you would like to have this as the target of your mapping operation. The third parameter to ko.mapping.fromJS indicates the target. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ee772074f2af1d7a8aaad138b9ed8cf1f46dbbc" translate="yes" xml:space="preserve">
          <source>Ignoring certain properties using &amp;ldquo;ignore&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="862cab77807ae3aed03ab6e5350848a0245d7862" translate="yes" xml:space="preserve">
          <source>Ignoring dependencies within a computed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="e98d0b401da7a27f72e4030036db78a4058a43b6" translate="yes" xml:space="preserve">
          <source>Implementing a custom component loader</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e1f2cc17fbee96463fbddbcea3b554850c3baa9" translate="yes" xml:space="preserve">
          <source>In a binding&amp;rsquo;s init function, using a computed observable to update the bound element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6abb210083356c831fde074a2c122126ad2030b" translate="yes" xml:space="preserve">
          <source>In a typical Knockout application, DOM elements are dynamically added and removed, for example using the &lt;a href=&quot;template-binding&quot;&gt;template&lt;/a&gt; binding or via control-flow bindings (&lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt;, &lt;a href=&quot;ifnot-binding&quot;&gt;ifnot&lt;/a&gt;, &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt;, and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;). When creating a custom binding, it is often desirable to add clean-up logic that runs when an element associated with your custom binding is removed by Knockout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="141b57414e301727c0b0d54cb5649b30de0602c3" translate="yes" xml:space="preserve">
          <source>In case you&amp;rsquo;re wondering what the parameters to ko.applyBindings do,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="934ed4b9942e197c4b326248bae145be6b363266" translate="yes" xml:space="preserve">
          <source>In complex applications, with multiple, intertwined dependencies, updating a single &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; might trigger a cascade of &lt;a href=&quot;computedobservables&quot;&gt;computed observables&lt;/a&gt;, manual subscriptions, and UI binding updates. These updates can be expensive and inefficient if unnecessary intermediate values are pushed to the view or result in extra computed observable evaluations. Even in a simple application, updating related observables or a single observable multiple times (such as filling an &lt;a href=&quot;observablearrays&quot;&gt;observable array&lt;/a&gt;) can have a similar effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298a4f1f3d69231f90369b88842f87a3f201c02d" translate="yes" xml:space="preserve">
          <source>In general, if a parameter&amp;rsquo;s evaluation does not involve evaluating an observable (in this case, the observable was simply passed without evaluating it), then the value is passed literally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fea9cada35fecd5a76c1bf34c364291fb1dfeb5" translate="yes" xml:space="preserve">
          <source>In general, if a parameter&amp;rsquo;s evaluation does not involve evaluating an observable (in this case, the value did not involve observables at all), then the value is passed literally. If the value was an object, then the child component could mutate it, but since it&amp;rsquo;s not observable the parent would not know the child had done so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9408b29fab575c1d6a718e0d164b10b2342550d4" translate="yes" xml:space="preserve">
          <source>In general, with custom elements, if a parameter&amp;rsquo;s evaluation involves evaluating an observable, then Knockout automatically constructs a ko.computed value to give the expression&amp;rsquo;s result, and supplies that to the component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dada114537b3d8ec4d940c1f848a0b4d17e427dd" translate="yes" xml:space="preserve">
          <source>In many scenarios, this direct approach is the simplest and most flexible solution. Of course, as you update the properties on your view model, Knockout will take care of updating the visible UI to match it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1336d55dbbe8a14101718dce289bfc08355c43e3" translate="yes" xml:space="preserve">
          <source>In most applications, you&amp;rsquo;ll want to keep component view models and templates in external files. If you configure Knockout to fetch them via an AMD module loader such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;, then they can either be preloaded (possibly bundled/minified), or incrementally loaded as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9393d5a40d776a6854af0f2c50bfec273ef93bff" translate="yes" xml:space="preserve">
          <source>In most cases, data-bind attributes provide a clean and succinct way to bind to a view model. However, event handling is one area that can often result in verbose data-bind attributes, as anonymous functions were typically the recommended techinique to pass arguments. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51abc57c35dadaabfdce19179eb0debbebbeaf7" translate="yes" xml:space="preserve">
          <source>In older browsers (ie8 and below) using reserved javascript words as attribute names causes an error. You can get around this by quoting them like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c97a2a9b619f6af8e28ca3d1b212c9106b36d9" translate="yes" xml:space="preserve">
          <source>In some cases, you might want to duplicate a section of markup, but you don&amp;rsquo;t have any container element on which to put a foreach binding. For example, you might want to generate the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24cb80dcb3e226fb881227f4a0ccddef514b98a4" translate="yes" xml:space="preserve">
          <source>In some scenarios, it is useful to programmatically determine if you are dealing with a computed observable. Knockout provides a utility function, ko.isComputed to help with this situation. For example, you might want to exclude computed observables from data that you are sending back to the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e3b5296e5cf5300764dcbb83ced0ab56bb3f938" translate="yes" xml:space="preserve">
          <source>In some scenarios, it is useful to programmatically determine if you are dealing with a pure computed observable. Knockout provides a utility function, ko.isPureComputed to help with this situation. For example, you might want to exclude non-pure computed observables from data that you are sending back to the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642b0b573c69ea5aac246a77f09332e0af893398" translate="yes" xml:space="preserve">
          <source>In some scenarios, you may need to access the DOM event object associated with your click event. Knockout will pass the event as the second parameter to your function, as in this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a035bdd8bde1fc808e15cc5a03eb180ed46c10" translate="yes" xml:space="preserve">
          <source>In some scenarios, you may need to access the DOM event object associated with your event. Knockout will pass the event as the second parameter to your function, as in this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a7c3e36457e6b3964cbe1d0bb7c4a44fc9b6097" translate="yes" xml:space="preserve">
          <source>In summary, the general rule is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7abd619b7fce5ea9d7c5cd5e72650986e1b05fc5" translate="yes" xml:space="preserve">
          <source>In the above example, selectedCountry will retain the value 'Latvia', and the dropdown will be blank, because there is no corresponding option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a079557bbe2fc66148c2ddbfa0077e907128f7e8" translate="yes" xml:space="preserve">
          <source>In the example below, a computed observable is used to reload an observable named currentPageData using Ajax with data from two other observable properties. The computed observable will update whenever pageIndex changes, but it ignores changes to selectedItem because it is accessed using peek. In this case, the user might want to use the current value of selectedItem only for tracking purposes when a new set of data is loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="257966647233e2e113fd6e59387bdb2e8ee4f13b" translate="yes" xml:space="preserve">
          <source>In the example code above, the user can choose from an array of string values. You&amp;rsquo;re &lt;em&gt;not&lt;/em&gt; limited to providing strings - your options array can contain arbitrary JavaScript objects if you wish. See &lt;a href=&quot;options-binding&quot;&gt;the options binding&lt;/a&gt; for details on how to control how arbitrary objects should be displayed in the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f1eec557c11682dd0041b7ee985e305de5b96b1" translate="yes" xml:space="preserve">
          <source>In the following example of a simple wizard interface, the fullName &lt;em&gt;pure&lt;/em&gt; computed is only bound to the view during the final step and so is only updated when that step is active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f00c733671a04000a05bf717e25acf161719f5a" translate="yes" xml:space="preserve">
          <source>In the following example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b59bdb65eb1fb7ea8933f16ea767b69ee4a3eb" translate="yes" xml:space="preserve">
          <source>In the following example, the &amp;lt;div&amp;gt; element will be empty for &amp;ldquo;Mercury&amp;rdquo;, but populated for &amp;ldquo;Earth&amp;rdquo;. That&amp;rsquo;s because Earth has a non-null capital property, whereas &amp;ldquo;Mercury&amp;rdquo; has null for that property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4ef6f441e7c614e804c04b6a2e41d53a3f525d" translate="yes" xml:space="preserve">
          <source>In the following example, the item objects themselves (not their itemName strings) will be included in the chosenItems array when their corresponding checkboxes are checked:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd533036ba8a852bee55ce9ff27ce0f5cbea1320" translate="yes" xml:space="preserve">
          <source>In the unlikely event that you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want the automatic unwrapping, because you want to access the observable1/observable2 instances directly, you can read values from params.$raw. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82f26ef92fcf3d919b5692d621d24247e24ffdf3" translate="yes" xml:space="preserve">
          <source>In the vast majority of cases, Knockout&amp;rsquo;s native templating and the foreach, if, with and other control flow bindings will be all you need to construct an arbitrarily sophisticated UI. But in case you wish to integrate with an external templating library, such as the &lt;a href=&quot;http://documentcloud.github.com/underscore/#template&quot;&gt;Underscore template engine&lt;/a&gt; or &lt;a href=&quot;http://api.jquery.com/jquery.tmpl/&quot;&gt;jquery.tmpl&lt;/a&gt;, Knockout offers a way to do it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6089b197798e2998b901eb8dbbf1b20e0c170048" translate="yes" xml:space="preserve">
          <source>In this case, all the specified nodes (and their descendants) will be cloned and concatenated into each copy of the component that gets instantiated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a348c38b4b02b07c8665149add553a1e8b9d5d0e" translate="yes" xml:space="preserve">
          <source>In this case, both the required and logChange extenders would be executed against our observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a699872accd4a004c8e32410cc63d8c1833fccde" translate="yes" xml:space="preserve">
          <source>In this case, the object to which the component&amp;rsquo;s view is bound is the params object that you passed to the component binding. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c17fd19412152ec3913a0a1d358a54a8292c9681" translate="yes" xml:space="preserve">
          <source>In this case, you can&amp;rsquo;t put if on the &amp;lt;ul&amp;gt; (because then it would affect the first &amp;lt;li&amp;gt; too), and you can&amp;rsquo;t put any other container around the second &amp;lt;li&amp;gt; (because HTML doesn&amp;rsquo;t allow extra containers within &amp;lt;ul&amp;gt;s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bd55725b74476a658ad8c3ddffc52240205843b" translate="yes" xml:space="preserve">
          <source>In this example, the &amp;ldquo;Your cellphone number&amp;rdquo; text box will initially be disabled. It will be enabled only when the user checks the box labelled &amp;ldquo;I have a cellphone&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b1af26f17b9406ba47b28c79e10c531b381108" translate="yes" xml:space="preserve">
          <source>In this example, the component both displays and edits an observable property called userRating on the Product view model class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b578fdc737cd1643dadd8aea539b4c2f16e439d0" translate="yes" xml:space="preserve">
          <source>In this example, the person-template markup is used twice: once for buyer, and once for seller. Notice that the template markup is wrapped in a &amp;lt;script type=&quot;text/html&quot;&amp;gt; &amp;mdash; the dummy type attribute is necessary to ensure that the markup is not executed as JavaScript, and Knockout does not attempt to apply bindings to that markup except when it is being used as a template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4923e8cd2117852530d9802d4bbf382ff3afc82c" translate="yes" xml:space="preserve">
          <source>In this example, there isn&amp;rsquo;t anywhere to put a normal foreach binding. You can&amp;rsquo;t put it on the &amp;lt;ul&amp;gt; (because then you&amp;rsquo;d be duplicating the header item), nor can you put a further container inside the &amp;lt;ul&amp;gt; (because only &amp;lt;li&amp;gt; elements are allowed inside &amp;lt;ul&amp;gt;s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb736901afba0868e604845ea5c5136b0ef06755" translate="yes" xml:space="preserve">
          <source>In this live example, there&amp;rsquo;s an instantaneousValue observable that reacts immediately when you press a key. This is then wrapped inside a delayedValue computed observable that&amp;rsquo;s configured to notify only when changes stop for at least 400 milliseconds, using the notifyWhenChangesStop rate-limit method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="697eb6430df1ff767ba12b86170aabf874197762" translate="yes" xml:space="preserve">
          <source>In this scenario, the values you can read and write using selectedOptions are those objects themselves, &lt;em&gt;not&lt;/em&gt; their textual representations. This leads to much cleaner and more elegant code in most cases. Your view model can imagine that the user chooses from an array of arbitrary objects, without having to care how those objects are mapped to an on-screen representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="899b5b3c843785e5bdf5e9462999644c6d640741" translate="yes" xml:space="preserve">
          <source>In your viewmodel, it&amp;rsquo;s often useful to declare self (or some other variable) as an alias for this. Doing so avoids any problems with this being redefined to mean something else in event handlers or Ajax request callbacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d3f9dd3adc47ab7ac1b64ead3455b5e2967b39" translate="yes" xml:space="preserve">
          <source>Include the module in the list of dependencies for your view model:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a540fcc7f8debd81035e2aedabe7eca5ef988f87" translate="yes" xml:space="preserve">
          <source>Including certain properties using &amp;ldquo;include&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12cbb6e3feed90f14fa1eaeab9ddfc2be5402137" translate="yes" xml:space="preserve">
          <source>Inserts nodeToInsert as a child of the real or virtual element containerElem, positioned immediately after insertAfter (where insertAfter must be a child of containerElem).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5226f3c318b899bef48bc2eb6b90732ff9e7c110" translate="yes" xml:space="preserve">
          <source>Inserts nodeToPrepend as the first child of the real or virtual element containerElem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6bbabe746e549a40b0c4c9d91c41eb15b7c78a" translate="yes" xml:space="preserve">
          <source>Instead of using submit on the form, you &lt;em&gt;could&lt;/em&gt; use click on the submit button. However, submit has the advantage that it also captures alternative ways to submit the form, such as pressing the &lt;em&gt;enter&lt;/em&gt; key while typing into a text box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83dd21419fd3a38dcc7db394fe1758f026c592be" translate="yes" xml:space="preserve">
          <source>Instead, developers at present are left to fall back on variations of the module or object literal patterns. With many of these, module scripts are strung together in the DOM with namespaces being described by a single global object where it&amp;rsquo;s still possible to incur naming collisions in your architecture. There&amp;rsquo;s also no clean way to handle dependency management without some manual effort or third party tools.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="0ed5597c3a7b69dedb6a6d299a96c9f0d4cdda78" translate="yes" xml:space="preserve">
          <source>Is KO intended to compete with jQuery (or Prototype, etc.) or work with it?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65da43a24216ab5b6b86fc60da5f46e3f4aeba18" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t strictly necessary to dispose computeds and subscriptions that only depend on properties of the same viewmodel object, since this creates only a circular reference which JavaScript garbage collectors know how to release. However, to avoid having to remember which things need disposal, you may prefer to use pureComputed wherever possible, and explicitly dispose all other computeds/subscriptions whether technically necessary or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c8d88dcd3513a54272253518c0497355ab086ef" translate="yes" xml:space="preserve">
          <source>It will first check if the key is already present and will throw an exception if it is. Next, it will invoke the create and update callbacks, if any, to create the new object. Finally, it will add this object to the array and return it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79526c06b498ef03e22fd6acf22e655f708bfbf" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s actually very simple and rather lovely. The tracking algorithm goes like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="878cb611fac9777800e6495d4a84b9db45ca03ab" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to understand that the if binding really is vital to make this code work properly. Without it, there would be an error when trying to evaluate capital.cityName in the context of &amp;ldquo;Mercury&amp;rdquo; where capital is null. In JavaScript, you&amp;rsquo;re not allowed to evaluate subproperties of null or undefined values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3874fb9afc15bfa8481f8f5826ec25b83ba6641" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s much easier with KO. It lets you scale up in complexity without fear of introducing inconsistencies. Just represent your items as a JavaScript array, and then use a foreach binding to transform this array into a TABLE or set of DIVs. Whenever the array changes, the UI changes to match (you don&amp;rsquo;t have to figure out how to inject new TRs or where to inject them). The rest of the UI stays in sync. For example, you can declaratively bind a SPAN to display the number of items as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="006519a934952c4254be41efd04fdc8f35b9bbc1" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not mandatory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b7ff8fbd1e3390894e542bb222f79b8c9ed9a17" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not very often that you&amp;rsquo;ll need to use named templates, but on occasion it can help to minimise duplication of markup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f7ea21297f054ffd0625db94299b6ba1fe8aaa4" translate="yes" xml:space="preserve">
          <source>JSON data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34fcbc8242b1e3ebc93c1cfe4363423f333e167a" translate="yes" xml:space="preserve">
          <source>Just like other control flow elements such as &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, you can use with without any container element to host it. This is useful if you need to use with in a place where it would not be legal to introduce a new container element just to hold the with binding. See the documentation for &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; or &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f64bb981f55e85e97b341a43c767424d5619a17b" translate="yes" xml:space="preserve">
          <source>Just like the built-in bindings &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, custom bindings can change the binding context for their descendant elements, or provide special properties by extending the binding context object. This is described in detail under &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;creating custom bindings that control descendant bindings&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f10396afd953909c4df70ba9023b9185a81cc60" translate="yes" xml:space="preserve">
          <source>KO clears the previous content and then sets the element&amp;rsquo;s content to your parameter value using jQuery&amp;rsquo;s html function or by parsing the string into HTML nodes and appending each node as a child of the element, if jQuery is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69fa041d6384a6c679e26d44e244d5f32beebb78" translate="yes" xml:space="preserve">
          <source>KO notifies any subscribers about the new value of your computed observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71fb9b79738717eee4554654ca119320338369c1" translate="yes" xml:space="preserve">
          <source>KO sets the element&amp;rsquo;s checked state to match your parameter value. Any previous checked state will be overwritten. The way your parameter is interpreted depends on what type of element you&amp;rsquo;re binding to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a3df96598c4036511dc238d5a88ee9394c86f50" translate="yes" xml:space="preserve">
          <source>KO sets the element&amp;rsquo;s text content to your parameter value. Any previous value will be overwritten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1f9d65da5ea43666bdeb72a28f9a6b37496e064" translate="yes" xml:space="preserve">
          <source>KO sets the element&amp;rsquo;s value property to your parameter value. Any previous value will be overwritten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bde7388020d016b48b1ca2b6ab57e2975906b8d" translate="yes" xml:space="preserve">
          <source>KO will pass exactly the same set of parameters that it passes to &lt;a href=&quot;#the-update-callback&quot;&gt;the update callback&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ac751a44f21c39e46010fe72a276f9173a2c15" translate="yes" xml:space="preserve">
          <source>KO will prefix the list of items with one that displays the text &amp;ldquo;Select an item&amp;hellip;&amp;rdquo; and has the value undefined. So, if myChosenValue holds the value undefined (which observables do by default), then the dummy option will be selected. If the optionsCaption parameter is an observable, then the text of the initial item will update as the observable&amp;rsquo;s value changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa70ea5fbce8c2f9ed5def8836b676cb1d01b105" translate="yes" xml:space="preserve">
          <source>Key point: An observableArray tracks which objects are &lt;em&gt;in&lt;/em&gt; the array, &lt;em&gt;not&lt;/em&gt; the state of those objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20cd00a0b3dad001fec0c192cbc11b089833bdc7" translate="yes" xml:space="preserve">
          <source>Knockout allows you to implement sophisticated client-side interactivity, but almost all web applications also need to exchange data with the server, or at least to serialize the data for local storage. The most convenient way to exchange or store data is in &lt;a href=&quot;http://json.org/&quot;&gt;JSON format&lt;/a&gt; - the format that the majority of Ajax applications use today.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f229f6596fbe329e6bb64b5dce17d58c2ffbdd68" translate="yes" xml:space="preserve">
          <source>Knockout allows you to use multiple component loaders simultaneously. This is useful so that, for example, you can plug in loaders that implement different mechanisms (e.g., one might fetch templates from a backend server according to a naming convention; another might set up viewmodels using a dependency injection system) and have them work together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b60fb8fc7684ef97c17d8ccca6eefd233019acb9" translate="yes" xml:space="preserve">
          <source>Knockout does not call require([moduleName], ...) until your component is being instantiated. This is how components get loaded on demand, not up front.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bdbad01c03ad4f569a7ab9c513b131c9c780424" translate="yes" xml:space="preserve">
          <source>Knockout doesn&amp;rsquo;t force you to use any one particular technique to load or save data. You can use whatever mechanism is a convenient fit for your chosen server-side technology. The most commonly-used mechanism is jQuery&amp;rsquo;s Ajax helper methods, such as &lt;a href=&quot;http://api.jquery.com/jQuery.getJSON/&quot;&gt;getJSON&lt;/a&gt;, &lt;a href=&quot;http://api.jquery.com/jQuery.post/&quot;&gt;post&lt;/a&gt;, and &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;ajax&lt;/a&gt;. You can fetch data from the server:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5aed4a079474df37e1a8e5472e53d73006c662b" translate="yes" xml:space="preserve">
          <source>Knockout has special support for drop-down lists (i.e., &amp;lt;select&amp;gt; elements). The value binding works in conjunction with the options binding to let you read and write values that are arbitrary JavaScript objects, not just string values. This is very useful if you want to let the user select from a set of model objects. For examples of this, see &lt;a href=&quot;options-binding&quot;&gt;the options binding&lt;/a&gt; or for handling multi-select lists, see the documentation for &lt;a href=&quot;selectedoptions-binding&quot;&gt;the selectedOptions binding&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfbfbf7e76555709a0e8ee8ab3da25adea41602f" translate="yes" xml:space="preserve">
          <source>Knockout is a JavaScript library that helps you to create rich, responsive display and editor user interfaces with a clean underlying data model. Any time you have sections of UI that update dynamically (e.g., changing depending on the user&amp;rsquo;s actions or when an external data source changes), KO can help you implement it more simply and maintainably.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce1aa9a9160bc65a886f29f47c527a318a8927af" translate="yes" xml:space="preserve">
          <source>Knockout is built around three core features:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a2d95410f39ed2247b45c19059e92620c5572c" translate="yes" xml:space="preserve">
          <source>Knockout is designed to allow you to use arbitrary JavaScript objects as view models. As long as some of your view model&amp;rsquo;s properties are &lt;a href=&quot;observables&quot;&gt;observables&lt;/a&gt;, you can use KO to bind to them to your UI, and the UI will be updated automatically whenever the observable properties change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0332512be6d6db18462a0af0288d09889035cb5f" translate="yes" xml:space="preserve">
          <source>Knockout observables provide the basic features necessary to support reading/writing values and notifying subscribers when that value changes. In some cases, though, you may wish to add additional functionality to an observable. This might include adding additional properties to the observable or intercepting writes by placing a writable computed observable in front of the observable. Knockout extenders provide an easy and flexible way to do this type of augmentation to an observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad0f3305d675fb1b797b9228f57e9108d17c6a8" translate="yes" xml:space="preserve">
          <source>Knockout provides some advanced methods to control when the microtask queue is processed. These are useful if you want to integrate Knockout&amp;rsquo;s microtask system with another library or add support for additional environments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6abd5738b63edcd68975dfacaf86d8c1192d78" translate="yes" xml:space="preserve">
          <source>Knockout provides the following functions for working with virtual elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c0091a1df891fb4dfb8dfd62f26c34e55f8c10" translate="yes" xml:space="preserve">
          <source>Knockout sets the element&amp;rsquo;s content to a text node with your parameter value. Any previous content will be overwritten.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4be7114f1815cac446415c10a81311effa02c36" translate="yes" xml:space="preserve">
          <source>Knockout tries hard to spare developers the pain of dealing with cross-browser compatiblity issues, especially those relating to older browsers! Even though custom elements provide a very modern style of web development, they still work on all commonly-encountered browsers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3614b4e93dd3cdeb6c24be3fd21755de5f630cec" translate="yes" xml:space="preserve">
          <source>Knockout version 3.4.0 added support for &lt;a href=&quot;deferred-updates&quot;&gt;&lt;em&gt;deferred updates&lt;/em&gt;&lt;/a&gt;, which works similarly to rate-limiting by making notifications and updates asynchronous. But instead of using a timed delay, deferred updates are processed as soon as possible after the current task, before yielding for I/O, reflow, or redrawing. If you are upgrading to 3.4.0 and have code that uses a short rate-limit timeout (e.g., 0 milliseconds), you could modify it to use deferred updates instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf00d058136f6ed851cf257f843756b9fbf0a3dc" translate="yes" xml:space="preserve">
          <source>Knockout will call the update callback initially when the binding is applied to an element and track any dependencies (observables/computeds) that you access. When any of these dependencies change, the update callback will be called once again. The following parameters are passed to it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eae698b690b8c1bcce8105ecab4ab66625edf99" translate="yes" xml:space="preserve">
          <source>Knockout will call your init function once for each DOM element that you use the binding on. There are two main uses for init:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a23739891b1f51e8af9e998ec7eca300dc988110" translate="yes" xml:space="preserve">
          <source>Knockout will create a computed observable internally in order to detect what observables the expression depends on, and will automatically dispose it when the associated element is later removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ab974d067e98d55b933807ee21cdb58029eeed8" translate="yes" xml:space="preserve">
          <source>Knockout will invoke your constructor once for each instance of the component, producing a separate viewmodel object for each. Properties on the resulting object or its prototype chain (e.g., someProperty and doSomething in the example above) are available for binding in the component&amp;rsquo;s view.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c5db285f5258d37819571d4c74273c14dd139e" translate="yes" xml:space="preserve">
          <source>Knockout will prevent the use of any bindings that use &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;controlsDescendantBindings&lt;/a&gt;, because this also would clash with the component when trying to bind its viewmodel to the injected template. Therefore if you want to use a control flow binding such as if or foreach, then you must wrap it around your custom element rather than using it directly on the custom element, e.g.,:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409698893159f365e2fba812abf15b879db2dd76" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery, if it is present, for handling UI events such as change. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling ko.applyBindings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628ae63ef225d2591f558c7eb5f9fe4b46e164f9" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery, if it is present, for handling UI events such as click. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling ko.applyBindings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77ef2ccc75214842d9b2c0a3d534e87e201ecce" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery, if it is present, for handling UI events. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling ko.applyBindings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a463ee652f33a4ecb8721a1952f7992b0096faf" translate="yes" xml:space="preserve">
          <source>Knockout wraps internal asynchronous calls and looks for an optional ko.onError callback to execute, if an exception is encountered, before throwing the original error. This gives you the opportunity to run custom logic, such as passing the error to a logging module. Additionally, since the original call is wrapped in a try/catch, the error passed to ko.onError contains a stack property, which is not true in many browsers when handling errors using window.onerror.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaba5f2372fd360661055282561600552507d4f4" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s &lt;em&gt;control flow bindings&lt;/em&gt; (e.g., &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;) can be applied not only to regular DOM elements, but also to &amp;ldquo;virtual&amp;rdquo; DOM elements defined by a special comment-based syntax. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10dcefe7d15993a636613b17dda7a5e5e9fcae8a" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s automatic dependency tracking normally does exactly what you want. But you might sometimes need to control which observables will update your computed observable, especially if the computed observable performs some sort of action, such as making an Ajax request. The peek function lets you access an observable or computed observable without creating a dependency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd482bdf1441531cfa78b4dbd9241b7e06ebb86c" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s declarative binding system provides a concise and powerful way to link data to the UI. It&amp;rsquo;s generally easy and obvious to bind to simple data properties or to use a single binding. For more complex bindings, it helps to better understand the behavior and syntax of Knockout&amp;rsquo;s binding system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7691338ff4b6fbe0156716cb2ed66851f5e37135" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s microtask queue</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29bf809f39e83f00213a2579389145bb353bc904" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s microtask queue supports scheduling tasks to run as soon as possible while still being asynchronous, striving to schedule them to occur before yielding for I/O, reflow, or redrawing. It is used internally for &lt;a href=&quot;component-overview&quot;&gt;Knockout components&lt;/a&gt; to maintain asynchronous behavior, and for scheduling &lt;a href=&quot;deferred-updates&quot;&gt;deferred updates&lt;/a&gt; for observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca702ffcf354707c6d7e704262cbeb2920d80d3" translate="yes" xml:space="preserve">
          <source>Knockout.js</source>
          <target state="translated">Knockout.js</target>
        </trans-unit>
        <trans-unit id="8c7dca686f307018a9b4d98dff3ae5fb4bbceb4a" translate="yes" xml:space="preserve">
          <source>Later, when you&amp;rsquo;re asked to implement the &amp;lsquo;Delete&amp;rsquo; functionality, you don&amp;rsquo;t have to figure out what bits of the UI it has to interact with; you just make it alter the underlying data model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">더 알아보기</target>
        </trans-unit>
        <trans-unit id="1f2e2bde04a28d8be8e4af5907acc2fba80505c0" translate="yes" xml:space="preserve">
          <source>Learn more about configuring and registering components with the default loader</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be1bb6cdfa52ff974724e62faceb68b7d67cb10" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have a JavaScript object that looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94f3d8639201581d19e8cd3a9912e85ca0fa345a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s update the code for randomOrder, this time using KO&amp;rsquo;s virtual element APIs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="a22c0dccba3224320a8069043f5f6f3d98d749d5" translate="yes" xml:space="preserve">
          <source>Live Example 1: Forcing input to be numeric</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a999d211200204fb1d5f89b2e98b09601e4ab925" translate="yes" xml:space="preserve">
          <source>Live Example 2: Adding validation to an observable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f19646932df2821a76d070d391a81a56f5b95215" translate="yes" xml:space="preserve">
          <source>Live example</source>
          <target state="translated">라이브 예</target>
        </trans-unit>
        <trans-unit id="c96856283b27b5efa4c99dbc46c686a71954647b" translate="yes" xml:space="preserve">
          <source>Live example: nested children</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce4efabbd5fd9902131eac73e8e59cb786288b4a" translate="yes" xml:space="preserve">
          <source>Live examples are not available on DevDocs, sorry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8179062abf1c808535e17f3bba054486e091bd3" translate="yes" xml:space="preserve">
          <source>Loading Knockout.js and a ViewModel class via RequireJs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a1275f750d43f39de53842ed4dbab527886627e" translate="yes" xml:space="preserve">
          <source>Loading Knockout.js, a Binding Handler, and a ViewModel class via RequireJs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6971a11e0a52091a5c953372bb00569922b2df7" translate="yes" xml:space="preserve">
          <source>Loading and Saving JSON data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28f44d40c76afc7d7591cf58f327b1bbe21530d4" translate="yes" xml:space="preserve">
          <source>Loading or Saving Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac600279c0db054ae2804d05146b63ba0414ceea" translate="yes" xml:space="preserve">
          <source>MVVM and View Models</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0132e7037dde4a1569f3f0cf422fc539613ba46" translate="yes" xml:space="preserve">
          <source>Main Parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b773120102a6c1a24da236928541cb48a5ec94c" translate="yes" xml:space="preserve">
          <source>Main parameter</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042abe727f60c8d9932534243bb81872b7416c98" translate="yes" xml:space="preserve">
          <source>Making things respond after a certain delay</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a5870106ccf1eddcdec83e7b076fb5c8b992dd" translate="yes" xml:space="preserve">
          <source>Managing &amp;lsquo;this&amp;rsquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f860a27c927a94a2081dcaffc79957c81d02b57" translate="yes" xml:space="preserve">
          <source>Manipulating an observableArray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22316e0ceeda20484d97d991e8da0112dd866d9" translate="yes" xml:space="preserve">
          <source>Manually-created &lt;strong&gt;event handlers&lt;/strong&gt; on external DOM elements, if created inside a createViewModel function (or even inside a regular component viewmodel, although to fit the MVVM pattern you shouldn&amp;rsquo;t) must be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588de813ea47b650faf54523ad98714b629c740e" translate="yes" xml:space="preserve">
          <source>Mapped observable array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="def2eba59562958fa4a005f8070d692ef8502312" translate="yes" xml:space="preserve">
          <source>Mapping</source>
          <target state="translated">Mapping</target>
        </trans-unit>
        <trans-unit id="996b905af8ff85c85478f1f8432f440056372995" translate="yes" xml:space="preserve">
          <source>Mapping from multiple sources</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e632657a4c6244bb198de62ec1571b6dfbf8396" translate="yes" xml:space="preserve">
          <source>Mapping options that you specify in each call will be merged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c19d4dee164eb75d3ed611fe2afd01eccf8b645" translate="yes" xml:space="preserve">
          <source>Microtasks</source>
          <target state="translated">Microtasks</target>
        </trans-unit>
        <trans-unit id="1ee20630e0871cafa9aed0bf7aa0013db967c5b0" translate="yes" xml:space="preserve">
          <source>Microtasks can be canceled using the &lt;em&gt;handle&lt;/em&gt; value returned from ko.tasks.schedule. If the task has already run or was previously canceled, cancel does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="53e411847528d541c26c3c00ed9603e00cf5d49c" translate="yes" xml:space="preserve">
          <source>Modifying observables after DOM events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148523423d67830c8f1a8a3e23b0aa52da24e903" translate="yes" xml:space="preserve">
          <source>More more detailed information, see:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03e0bcfaabb4306e0ad24ddb4448860d09263fb3" translate="yes" xml:space="preserve">
          <source>More than one extender can be applied in a single call to the .extend method of an observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a842f6a98c04fd60847152441adf06e65c2bcdb" translate="yes" xml:space="preserve">
          <source>Most applications need to fetch data from a backend server. Since the server doesn&amp;rsquo;t have any concept of observables, it will just supply a plain JavaScript object (usually serialized as JSON). The mapping plugin gives you a straightforward way to map that plain JavaScript object into a view model with the appropriate observables. This is an alternative to manually writing your own JavaScript code that constructs a view model based on some data you&amp;rsquo;ve fetched from the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d448139b3552f2ce58ee18a84ae6283ba5f3bb" translate="yes" xml:space="preserve">
          <source>Multiple component loaders may be consulted, until the first one recognises the component name and supplies a viewmodel/template. This process only takes place &lt;strong&gt;once per component type&lt;/strong&gt;, since Knockout caches the resulting definitions in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a6cd3eea908b0b2a5c411ea2342c43a36c3d759" translate="yes" xml:space="preserve">
          <source>Next, you want to fetch the latest data from the server. Every 5 seconds you might issue an Ajax request (e.g., using jQuery&amp;rsquo;s $.getJSON or $.ajax functions):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f490764c270257caa7816a634ad9ceb0029f602" translate="yes" xml:space="preserve">
          <source>No matter how nested the links become, the handler is always able to identify and operate on the appropriate data. Using this techinique, we can avoid the overhead of attaching handlers to each individual link and can keep the markup clean and concise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afa1839782d1d70ed8698b21df5705b582780b4b" translate="yes" xml:space="preserve">
          <source>Non-boolean values are interpreted loosely as boolean. For example, 0 and null are treated as false, whereas 21 and non-null objects are treated as true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="b7e6ebe0a5573c6fa19a2a0f36cfae8a5b91c39f" translate="yes" xml:space="preserve">
          <source>None, other than the core Knockout library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db09b0691b02a98f1c82dcb9d3a19d0909373cf6" translate="yes" xml:space="preserve">
          <source>Normally, Knockout consults the loaders &lt;em&gt;once per component name&lt;/em&gt;, then caches the resulting definition. This ensures that large numbers of components may be instantiated very quickly. If you want to clear the cache entry for a given component, call this, and then the loaders will be consulted again the next time that component is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeec499c3f627d57c3576dc1e65df40411bba37d" translate="yes" xml:space="preserve">
          <source>Normally, Knockout ensures that component loading, and hence component injection, always completes asynchronously, because &lt;em&gt;sometimes it has no choice but to be asynchronous&lt;/em&gt; (e.g., because it involves a request to the server). It does this even if a particular component instance could be injected synchronously (e.g., because the component definition was already loaded). This always-asynchronous policy is a matter of consistency, and is a well-established convention inherited from other modern asynchronous JavaScript technologies, such as AMD. The convention is a safe default &amp;mdash; it mitigates potential bugs where a developer might not account for the possibility of a typically-asynchronous process sometimes completing synchronously or vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6524854e62e38125ced06867534d8b38f18ad484" translate="yes" xml:space="preserve">
          <source>Normally, a computed observable updates and notifies its subscribers immediately, as soon as its dependencies change. But if a computed observable has many dependencies or involves expensive updates, you may get better performance by limiting or delaying the computed observable&amp;rsquo;s updates and notifications. This is accomplished using the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de8510f955a76aae57a6decf3b1d448a2721eab0" translate="yes" xml:space="preserve">
          <source>Normally, an &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; that is changed notifies its subscribers immediately, so that any computed observables or bindings that depend on the observable are updated synchronously. The rateLimit extender, however, causes an observable to suppress and delay change notifications for a specified period of time. A rate-limited observable therefore updates dependencies asynchronously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85e4e3194fb98ff27c2137c8428ce2e4d1b258a4" translate="yes" xml:space="preserve">
          <source>Normally, an observable notifies its subscribers immediately, as soon as it&amp;rsquo;s changed. But if an observable is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying the observable&amp;rsquo;s change notifications. This is accomplished using the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971d310ac30608c092a71563e91ea63dc1528f2c" translate="yes" xml:space="preserve">
          <source>Normally, an observableArray notifies its subscribers immediately, as soon as it&amp;rsquo;s changed. But if an observableArray is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying change notifications. This is accomplished using the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43fe63b87c4cb41558a04d9c42885616a56c55a" translate="yes" xml:space="preserve">
          <source>Normally, bindings that use controlsDescendantBindings will also call ko.applyBindingsToDescendants(someBindingContext, element) to apply the descendant bindings against some modified &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;. For example, you could have a binding called withProperties that attaches some extra properties to the binding context that will then be available to all descendant bindings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b15e1efcc6bbdd05b9bb899a299cf912de21af36" translate="yes" xml:space="preserve">
          <source>Normally, computed observables have a value that is computed from other observables and are therefore &lt;em&gt;read-only&lt;/em&gt;. What may seem surprising, then, is that it is possible to make computed observables &lt;em&gt;writable&lt;/em&gt;. You just need to supply your own callback function that does something sensible with written values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d425a57c002e80bcb922861fb6ad11cb4606ddb8" translate="yes" xml:space="preserve">
          <source>Normally, if you change name as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5e697b7346a3eeff279e706b4abc4448a43fae" translate="yes" xml:space="preserve">
          <source>Normally, in this case myButtonHandler would be called first, then the click event would bubble up to myDivHandler. However, the clickBubble binding that we added with a value of false prevents the event from making it past myButtonHandler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7808246a4e59ebea4927b73d56662e9805e699" translate="yes" xml:space="preserve">
          <source>Normally, in this case myButtonHandler would be called first, then the event would bubble up to myDivHandler. However, the mouseoverBubble binding that we added with a value of false prevents the event from making it past myButtonHandler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00011c53827e97e83b74eeaeeb5176dcdd95e89" translate="yes" xml:space="preserve">
          <source>Normally, this is an &lt;em&gt;asynchronous&lt;/em&gt; process. It may involve requests to the server. For API consistency, Knockout by default ensures that the loading process completes as an asynchronous callback even if the component is already loaded and cached in memory. For more about this, and how to allow synchronous loading, see &lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;Controlling synchronous/asynchronous loading&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5928082628ac47958f2a49985793c5a9cfe7a4ac" translate="yes" xml:space="preserve">
          <source>Normally, when you use the value binding on a &amp;lt;select&amp;gt; element, it means that you want the associated model value to describe which item in the &amp;lt;select&amp;gt; is selected. But what happens if you set the model value to something that has no corresponding entry in the list? The default behavior is for Knockout to overwrite your model value to reset it to whatever is already selected in the dropdown, thereby preventing the model and UI from getting out of sync.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d7a6b36856238f1888ea77959ac6db008365ad" translate="yes" xml:space="preserve">
          <source>Normally, when you&amp;rsquo;re using control flow bindings (foreach, with, if, etc.), there&amp;rsquo;s no need to give names to your templates: they are defined implicitly and anonymously by the markup inside your DOM element. But if you want to, you can factor out templates into a separate element and then reference them by name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="892c7a538c26d5912a114ef4c5b4dd9cb750dea3" translate="yes" xml:space="preserve">
          <source>Not all browsers support JavaScript getters and setters (* cough * IE * cough *), so for compatibility, ko.observable objects are actually &lt;em&gt;functions&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312a5f5143031f243bb9a60c2b68ea23336cd99f" translate="yes" xml:space="preserve">
          <source>Note 1: Getting value updates instantly from inputs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fab9187a677e6b78569955d9666c1ccb6694140" translate="yes" xml:space="preserve">
          <source>Note 1: Passing a &amp;ldquo;current item&amp;rdquo; as a parameter to your handler function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a814cb6ad3dec3e35271de124fcb52fc7ea8a30" translate="yes" xml:space="preserve">
          <source>Note 1: Referring to each array entry using $data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca9ba60cb79484ae10cbb526fdec0d6b22f6191b" translate="yes" xml:space="preserve">
          <source>Note 1: Rendering a named template</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb27abf41be27c85ca84a090a734e919e5e138f" translate="yes" xml:space="preserve">
          <source>Note 1: Selection is preserved when setting/changing options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ce25db4800747a44dd7be30e5487498ca714b8" translate="yes" xml:space="preserve">
          <source>Note 1: Using &amp;ldquo;with&amp;rdquo; without a container element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e4b385f89381daa4e0c5e3ef0819aa9d2954e1" translate="yes" xml:space="preserve">
          <source>Note 1: Using functions and expressions to detemine text values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e70856ca0bef317ab669b291a07dba08a49ed6" translate="yes" xml:space="preserve">
          <source>Note 1: textInput vs value binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="890064c263ea4cdf85ec4df05608a767470d9dee" translate="yes" xml:space="preserve">
          <source>Note 2: About HTML encoding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d94bff3e26ecd38bca324673da6818a6524a66" translate="yes" xml:space="preserve">
          <source>Note 2: Accessing the event object, or passing more parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fa0d7caea5eed0f78bbea6e5338469a3a2dc28c" translate="yes" xml:space="preserve">
          <source>Note 2: Post-processing the generated options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba1677efb75559f0bfd41b60da29baf1f864a1f9" translate="yes" xml:space="preserve">
          <source>Note 2: Using $index, $parent, and other context properties</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8999863783c665a40bdd09bd691a298f8f656468" translate="yes" xml:space="preserve">
          <source>Note 2: Using the &amp;ldquo;foreach&amp;rdquo; option with a named template</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2d8c3723f8725ce919b58379e9c2909628d4ef" translate="yes" xml:space="preserve">
          <source>Note 2: Working with drop-down lists (i.e., &amp;lt;select&amp;gt; elements)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2c468fee63b93cfdf8f4899d1272df0051f3f42" translate="yes" xml:space="preserve">
          <source>Note 3: Allowing the default action</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961ff8e09bdf3aa8b1b204afa8f0a5e5a818618c" translate="yes" xml:space="preserve">
          <source>Note 3: Allowing the default click action</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e882f5d136c5c9ff8d8962c222ce417eb151f4" translate="yes" xml:space="preserve">
          <source>Note 3: Updating observable and non-observable property values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7588edf8b51bfb005ba96690f74a34daa01047a1" translate="yes" xml:space="preserve">
          <source>Note 3: Using &amp;ldquo;as&amp;rdquo; to give an alias to &amp;ldquo;foreach&amp;rdquo; items</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f42f724af26e21363687b0dda2ed01310ea7ab5a" translate="yes" xml:space="preserve">
          <source>Note 3: Using &amp;ldquo;text&amp;rdquo; without a container element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a20f1b394f93301d92f03c60d60e1549f40c99" translate="yes" xml:space="preserve">
          <source>Note 4: About an IE 6 whitespace quirk</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23419d68201af3e1cc15bff11daeeb0f79f2c99c" translate="yes" xml:space="preserve">
          <source>Note 4: Preventing the event from bubbling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e526ff19533fbdea78f0e87c923669d66b13daf" translate="yes" xml:space="preserve">
          <source>Note 4: Using &amp;ldquo;afterRender&amp;rdquo;, &amp;ldquo;afterAdd&amp;rdquo;, and &amp;ldquo;beforeRemove&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2163a402155b39d7e2c760112b0647ef85484e62" translate="yes" xml:space="preserve">
          <source>Note 4: Using foreach without a container element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c786ee828c774288377fdaba163a22ff298763be" translate="yes" xml:space="preserve">
          <source>Note 4: Using the value binding with the checked binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea9b887209a1ac7ee930f38b5412044c510f0f34" translate="yes" xml:space="preserve">
          <source>Note 5: Dynamically choosing which template is used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bff1a14c09530d5378f91032bbee6d975eeab75" translate="yes" xml:space="preserve">
          <source>Note 5: How array changes are detected and handled</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f5c157ce0b3313df132dd29f97171e41483cf0" translate="yes" xml:space="preserve">
          <source>Note 5: Interaction with jQuery</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bdb9fca3db83a1d3859d688638577c6ee88ba7f" translate="yes" xml:space="preserve">
          <source>Note 6: Destroyed entries are hidden by default</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a357c555f225c8e2949ce0c275baf99efa923731" translate="yes" xml:space="preserve">
          <source>Note 6: Using jQuery.tmpl, an external string-based template engine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b8b656336f81c4a99e466d9c14848a3f391c670" translate="yes" xml:space="preserve">
          <source>Note 7: Post-processing or animating the generated DOM elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7bcd8dcb7fb8e81342016d8da6a4aa51bb7c3a9" translate="yes" xml:space="preserve">
          <source>Note 7: Using the Underscore.js template engine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf25c2749f90cc1bc6823eee106a1d44e331c5bf" translate="yes" xml:space="preserve">
          <source>Note that any display style you&amp;rsquo;ve configured using your CSS rules will then apply (so CSS rules like x { display:table-row } work fine in conjunction with this binding).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f64d633bf252e83e6a30775ca9bae85c7feffc" translate="yes" xml:space="preserve">
          <source>Note that for this to automatically erase rejected values from the UI, it&amp;rsquo;s necessary to use .extend({ notify: 'always' }) on the computed observable. Without this, it&amp;rsquo;s possible for the user to enter an invalid newValue that when rounded gives an unchanged valueToWrite. Then, since the model value would not be changing, there would be no notification to update the textbox in the UI. Using {notify:'always'} causes the textbox to refresh (erasing rejected values) even if the computed property has not changed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3928cd9c277ba72dbf69e81590702f90731185e0" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s necessary to specify viewModel: { instance: object }, and not just viewModel: object. This differentiates from the other cases below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc236e1ebc6928f0c511903c41b30d3206eee445" translate="yes" xml:space="preserve">
          <source>Note that ko.toJSON accepts the same arguments as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt;. For example, it can be useful to have a &amp;ldquo;live&amp;rdquo; representation of your view model data when debugging a Knockout application. To generate a nicely formatted display for this purpose, you can pass the &lt;em&gt;spaces&lt;/em&gt; argument into ko.toJSON and bind against your view model like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ed17d0a4365c067e0d0cca185b3a02627fee026" translate="yes" xml:space="preserve">
          <source>Note that only the nodes &lt;em&gt;inside&lt;/em&gt; the specified element will be cloned into each instance of the component. The container element (in this example, the &amp;lt;template&amp;gt; element), will &lt;em&gt;not&lt;/em&gt; be treated as part of the component template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd98c45b76cfffda7fb29aabbcc4105f3cac578" translate="yes" xml:space="preserve">
          <source>Note that reordering detection is not guaranteed: to ensure the algorithm completes quickly, it is optimized to detect &amp;ldquo;simple&amp;rdquo; movements of small numbers of array entries. If the algorithm detects too many simultaneous reorderings combined with unrelated insertions and deletions, then for speed it can choose to regard a reordering as an &amp;ldquo;delete&amp;rdquo; plus an &amp;ldquo;add&amp;rdquo; instead of a single &amp;ldquo;move&amp;rdquo;, and in that case the corresponding DOM elements will be torn down and recreated. Most developers won&amp;rsquo;t encounter this edge case, and even if you do, the end-user experience will usually be identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4451b80b2ea7a6435a9b74cfdb3ee7699047bf" translate="yes" xml:space="preserve">
          <source>Note that the custom binding handler module does not inject anything into our ViewModel module, that is because it does not return anything. It just appends additional behavior to the knockout module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85932fb55d2aff93e968e51c4da2dd6a4165c51" translate="yes" xml:space="preserve">
          <source>Note that the only difference between examples 3 and 4 is the optionsText value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7ebe43d20e5eae9b1b095f73abef9b56607824" translate="yes" xml:space="preserve">
          <source>Note that this is not the UI itself: it doesn&amp;rsquo;t have any concept of buttons or display styles. It&amp;rsquo;s not the persisted data model either - it holds the unsaved data the user is working with. When using KO, your view models are pure JavaScript objects that hold no knowledge of HTML. Keeping the view model abstract in this way lets it stay simple, so you can manage more sophisticated behaviors without getting lost.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e87df4d38ae4cd5ed452a5004cb65d4e1e2d6c9d" translate="yes" xml:space="preserve">
          <source>Note that when KO renders a foreach binding, it automatically hides any objects marked with _destroy equal to true. So, you can have some kind of &amp;ldquo;delete&amp;rdquo; button that invokes the destroy(someItem) method on the array, and this will immediately cause the specified item to vanish from the visible UI. Later, when you submit the JSON object graph to Rails, that item will also be deleted from the database (while the other array items will be inserted or updated as usual).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e450c418845800c7f4318df4ef7374c24e1e9cb3" translate="yes" xml:space="preserve">
          <source>Note that whenever a component is removed (either because the name observable changed, or because an enclosing control-flow binding removed the entire element), the removed component is &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;disposed&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65025960631541c741b459bf73aacbde8d728d8d" translate="yes" xml:space="preserve">
          <source>Note that, typically, it&amp;rsquo;s best to perform direct DOM manipulation only through &lt;a href=&quot;custom-bindings&quot;&gt;custom bindings&lt;/a&gt; rather than acting on componentInfo.element from inside createViewModel. This leads to more modular, reusable code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab69f1d78a98533c1ec94379b4b6361aa3fd348" translate="yes" xml:space="preserve">
          <source>Note: &amp;ldquo;ifnot&amp;rdquo; is the same as a negated &amp;ldquo;if&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d936c2871be1bf2c84824c58d0b50a0046f059e" translate="yes" xml:space="preserve">
          <source>Note: About HTML encoding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3bd5be04d2a77b8fbb42b423e270ca8d27974f7" translate="yes" xml:space="preserve">
          <source>Note: Applying CSS classes whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e59391e4012e916e2efca315ab8a0ac9019825" translate="yes" xml:space="preserve">
          <source>Note: Applying attributes whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40dbc8e3fecd759b1343c0ec1a8b8e04691b65e3" translate="yes" xml:space="preserve">
          <source>Note: Applying styles whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4f74718bbd2f9c628b5720909d7d35fb25664a8" translate="yes" xml:space="preserve">
          <source>Note: Combining custom elements with regular bindings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e0ba81f0e79b9ea41b49ea9879be53189f0c81a" translate="yes" xml:space="preserve">
          <source>Note: Custom component loaders and custom elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="097a1159163b98735917888cc1f3edd2f432ff4d" translate="yes" xml:space="preserve">
          <source>Note: Custom elements and Internet Explorer 6 to 8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3452f7b8dfc0078e81c174fd19ab87bdb730cee7" translate="yes" xml:space="preserve">
          <source>Note: Custom elements cannot be self-closing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b14d285bce9dc6c5d35d744705210b61bb5f03" translate="yes" xml:space="preserve">
          <source>Note: For a multi-select list, to set which of the options are selected, or to read which of the options are selected, use &lt;a href=&quot;selectedoptions-binding&quot;&gt;the selectedOptions binding&lt;/a&gt;. For a single-select list, you can also read and write the selected option using &lt;a href=&quot;value-binding&quot;&gt;the value binding&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea83c2531ea63cd46a3690a3c5a207b81e6a5f4" translate="yes" xml:space="preserve">
          <source>Note: For text boxes, drop-down lists, and all non-checkable form controls, use &lt;a href=&quot;value-binding&quot;&gt;the value binding&lt;/a&gt; to read and write the element&amp;rsquo;s value, not the checked binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d17b383b870bd49e9fdcd437b821085b1249406" translate="yes" xml:space="preserve">
          <source>Note: If the user navigates to an entirely different web page, browsers do this without asking any code running in the page to clean up. So in this case no dispose functions will be invoked. This is OK because the browser will automatically release the memory used by all objects that were in use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07830fa525672973fcad872d9479a00d3f0aae0b" translate="yes" xml:space="preserve">
          <source>Note: If you just want to prevent a computed observable from updating too often, see the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9907430c3d424ba976757e1f30ff936d301ef5" translate="yes" xml:space="preserve">
          <source>Note: If you&amp;rsquo;re working with checkboxes or radio buttons, use &lt;a href=&quot;checked-binding&quot;&gt;the checked binding&lt;/a&gt; to read and write your element&amp;rsquo;s checked state, not the value binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4013149ccb3f87d8ccbd0084efe996d0838d6311" translate="yes" xml:space="preserve">
          <source>Note: In more realistic cases, you would typically load component viewmodels and templates from external files, instead of hardcoding them into the registration. See &lt;a href=&quot;component-overview#example-loading-the-likedislike-widget-from-external-files-on-demand&quot;&gt;an example&lt;/a&gt; and &lt;a href=&quot;component-registration&quot;&gt;registration documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f182a0b9cb163063cf0210deaf0ef0bfd93fe2" translate="yes" xml:space="preserve">
          <source>Note: Integrating with browserify</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5847643b33a4979437c074b1772f4baa9785665" translate="yes" xml:space="preserve">
          <source>Note: Knockout does not guarantee that the beforeChange and change events will occur in pairs, since other parts of your code might raise either event individually. If you need to track the previous value of an observable, it&amp;rsquo;s up to you to use a subscription to capture and track it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="129196d92bb0c541677b616e7f9a98c3cc7e94cf" translate="yes" xml:space="preserve">
          <source>Note: Letting the user select from arbitrary JavaScript objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="140ebf77e1d231f3e690deb8c6320dc6a123f7b1" translate="yes" xml:space="preserve">
          <source>Note: Passing markup to components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60bd54c6d3ace6bef5b8658344fb90ff9e01f394" translate="yes" xml:space="preserve">
          <source>Note: Since the r.js optimizer is very flexible, it has a lot of options and can take some time to set up. You may want to start from a ready-made example of Knockout components being optimized through r.js, in which case see &lt;a href=&quot;http://yeoman.io/&quot;&gt;Yeoman&lt;/a&gt; and the &lt;a href=&quot;https://www.npmjs.org/package/generator-ko&quot;&gt;generator-ko&lt;/a&gt; generator. Blog post coming soon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b8295547dbd8dd296d604963578e9c5ba48c73" translate="yes" xml:space="preserve">
          <source>Note: Supporting virtual elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd0ab8e16c1919532cc43e7aa1a6b879552640b4" translate="yes" xml:space="preserve">
          <source>Note: Template-only components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05caaa87623573294cec899219e7deabd2359f2" translate="yes" xml:space="preserve">
          <source>Note: To control which element in a single-select drop-down list is selected, you can use &lt;a href=&quot;value-binding&quot;&gt;the value binding&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ccfb58e2925ffb0818561abbfa7a1e8de927a56" translate="yes" xml:space="preserve">
          <source>Note: Using &amp;ldquo;if&amp;rdquo; without a container element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71884929340b18d767f7c056cf2d3ecb21755e40" translate="yes" xml:space="preserve">
          <source>Note: Using arbitrary JavaScript expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4403ac4eff9ff864673188e035a34bcf003869af" translate="yes" xml:space="preserve">
          <source>Note: Using component without a container element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0bc144231da12d70fed9c1daabfaf618fbc1bf" translate="yes" xml:space="preserve">
          <source>Note: Using functions and expressions to control element visibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e11057c5759e08cd6106a99f6b95d00bd0ed796b" translate="yes" xml:space="preserve">
          <source>Note: Using reserved words as attribute names in older browsers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f815e27b345ec1efada4bea3643d51e789c47670" translate="yes" xml:space="preserve">
          <source>Note: Why circular dependencies aren&amp;rsquo;t meaningful</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8a2ea7aa039e3cc85d86b844a0aed9f68c466c1" translate="yes" xml:space="preserve">
          <source>Note: ko.computedContext.getDependenciesCount() is equivalent to calling getDependenciesCount() on the computed observable itself. The reason that it also exists on ko.computedContext is to provide a way of counting the dependencies during the first ever evaluation, before the computed observable has even finished being constructed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="102fb6d0d403a0d599dae72a7da85eadcf53fd8f" translate="yes" xml:space="preserve">
          <source>Note: you don&amp;rsquo;t actually have to provide both init &lt;em&gt;and&lt;/em&gt; update callbacks &amp;mdash; you can just provide one or the other if that&amp;rsquo;s all you need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="e652fe47c807dd0369ac321e0b23b49fe4d6ad4e" translate="yes" xml:space="preserve">
          <source>Notice how, instead of using APIs like domElement.firstChild, we&amp;rsquo;re now using ko.virtualElements.firstChild(domOrVirtualElement). The randomOrder binding will now correctly work with virtual elements, e.g., &amp;lt;!-- ko randomOrder: true --&amp;gt;...&amp;lt;!-- /ko --&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="881524b74eec619b61fa6cd558f217630d0d2032" translate="yes" xml:space="preserve">
          <source>Notice that no viewmodel/template pair is specified. The AMD module itself can provide a viewmodel/template pair, using any of the definition formats listed above. For example, the file some/module.js could be declared as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ffaab6a02fcd20ec4acba9eb285ffb74bb339fc" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;em&gt;not&lt;/em&gt; intended to be a complete replacement to the full set of regular DOM APIs. Knockout provides only a minimal set of virtual element APIs to make it possible to perform the kinds of transformations needed when implementing control flow bindings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d64ee77ed37778a54c73db4a866a3e17bd92900f" translate="yes" xml:space="preserve">
          <source>Notice the string value 'employee' associated with as. Now anywhere inside this foreach loop, bindings in your child templates will be able to refer to employee to access the employee object being rendered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ac7108123b5f245ef9f5df9d943f636924637d" translate="yes" xml:space="preserve">
          <source>Now anywhere inside this foreach loop, bindings will be able to refer to person to access the current array item, from the people array, that is being rendered. This can be especially useful in scenarios where you have nested foreach blocks and you need to refer to an item declared at a higher level in the hierarchy. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5673fdafd7626621793c97c3c05163e839f06fa8" translate="yes" xml:space="preserve">
          <source>Now like-or-dislike can be consumed in the same way as before, using either a &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; or a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6480651531660c84a55576d27e9ed7d8351ebcd4" translate="yes" xml:space="preserve">
          <source>Now the component is operating, and can remain on-screen for as long as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee0ffaf853c8407a424f11a481c7a0f71be59bc" translate="yes" xml:space="preserve">
          <source>Now there won&amp;rsquo;t be an error. However, it still won&amp;rsquo;t work properly, because our randomOrder binding is coded using normal DOM API calls (firstChild, appendChild, etc.) which don&amp;rsquo;t understand virtual elements. This is the reason why KO requires you to explicitly opt in to virtual element support: unless your custom binding is coded using virtual element APIs, it&amp;rsquo;s not going to work properly!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68b7fa0902e29163231a8e1b14bcdcd84f1f8c2" translate="yes" xml:space="preserve">
          <source>Now this is registered, you can reference components with any name (without preregistering them), e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9abe577afb6560e727b712ab6c0be7874d881af" translate="yes" xml:space="preserve">
          <source>Now we can push a bunch of items into the data array without worrying about causing excessive UI or computed updates. The deferred extender can be applied to any type of observable, including observable arrays and computed observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fda568a2d060f080b79888ad65ca98b3f5cb075b" translate="yes" xml:space="preserve">
          <source>Now you can bind click like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3482f1f45804606e4ae189fe1f25ad32491bef16" translate="yes" xml:space="preserve">
          <source>Now you can bind it like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d230de5c1460b029face137aa50f89cfff29a6" translate="yes" xml:space="preserve">
          <source>Now you can both read and write the &amp;ldquo;focusedness&amp;rdquo; of an element by binding it to an observable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de72398a9643fb68b8c419f88d72e0cc3455cae" translate="yes" xml:space="preserve">
          <source>Now you can change pageIndex and pageSize as many times as you like, and the Ajax call will only happen once after you release your thread back to the JavaScript runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f2aeef65d906e4473cfba8e914455277450ce1" translate="yes" xml:space="preserve">
          <source>Now you can include a template in your view like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd6cfad8e975c0657b6d67e96fe52c3a48e9aa8" translate="yes" xml:space="preserve">
          <source>Now you can use this binding as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9b28edefdb5a8470622ecf317b145edc4837c3" translate="yes" xml:space="preserve">
          <source>Now you could bind UI elements to it, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02d8cd1aeb019148b74c77705355b7163631d297" translate="yes" xml:space="preserve">
          <source>Now your binding in UI elements becomes a method call, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f030ce6c537ab6ebb0bf1ffd14b3a4657684bade" translate="yes" xml:space="preserve">
          <source>Now, KO will pass the data and event objects to your function literal, which are then available to be passed to your handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd13b366a6bf0e481a78cb8415ed4850572371a6" translate="yes" xml:space="preserve">
          <source>Now, KO will pass the event to your function literal, which is then available to be passed to your handler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b3699fea4994e40b27cf8acdc9dbd74ac8d3b7" translate="yes" xml:space="preserve">
          <source>Now, a single event handler is attached at a higher level and handles clicks against any links with the remove class. This method has the added benefit of automatically handling additional links that are dynamically added to the document (perhaps as the result of an item being added to an observableArray).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd680cea0a442ee897310989fbae69d04e84c88d" translate="yes" xml:space="preserve">
          <source>Now, acceptedNumericValue will only ever contain numeric values, and any other values entered will trigger the appearance of a validation message instead of updating acceptedNumericValue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f38308579b18f9d4a6971e8cbcbf8290d174a2" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s say the data is updated to be without any typos:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540f67e29415bf23f1b5c0759292b5c41747e4c8" translate="yes" xml:space="preserve">
          <source>Now, moving your mouse pointer on or off of the first element will invoke methods on the view model to toggle the detailsEnabled observable. The second element reacts to changes to the value of detailsEnabled by either showing or hiding itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3736efca9ddde7db65691710604802d1a6d9f093" translate="yes" xml:space="preserve">
          <source>Now, the text will switch between &amp;ldquo;expensive&amp;rdquo; and &amp;ldquo;affordable&amp;rdquo; as needed whenever price changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="088a5e50ba0e6a14fe36eaa6f26ee4c53c1aeffe" translate="yes" xml:space="preserve">
          <source>Now, to use this component, you can reference it from any other view in your application, either using the &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; or using a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;. Here&amp;rsquo;s a live example that uses it as a custom element:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4245c3b686b0a2dc1aff4f4de7c87fcd1a33a5a7" translate="yes" xml:space="preserve">
          <source>Now, whenever the user enters a new price, the text box immediately updates to show it formatted with the currency symbol and two decimal places, no matter what format they entered the value in. This gives a great user experience, because the user sees how the software has understood their data entry as a price. They know they can&amp;rsquo;t enter more than two decimal places, because if they try to, the additional decimal places are immediately removed. Similarly, they can&amp;rsquo;t enter negative values, because the write callback strips off any minus sign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ac3b49a89e1b1842cca9897c548ac837711b286" translate="yes" xml:space="preserve">
          <source>OK, how do you use it?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42801dc107e69330fc6f28652e42c67848f2e3d3" translate="yes" xml:space="preserve">
          <source>OK, you&amp;rsquo;ve seen how to create a basic view model and how to display one of its properties using a binding. But one of the key benefits of KO is that it updates your UI automatically when the view model changes. How can KO know when parts of your view model change? Answer: you need to declare your model properties as &lt;em&gt;observables&lt;/em&gt;, because these are special JavaScript objects that can notify subscribers about changes, and can automatically detect dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49ef41d692a31c86e07e70c90965e70e376a7d17" translate="yes" xml:space="preserve">
          <source>Observable Arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46996089e8555e78352bfb82f74492b629adadd3" translate="yes" xml:space="preserve">
          <source>Observable arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae2926058ff9077b5ef1fa67cef194213c7bb29a" translate="yes" xml:space="preserve">
          <source>Observable arrays that are generated by the mapping plugin are augmented with a few functions that can make use of the keys mapping:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8136b5b444e74956953de6d7e21de45a7208ed8b" translate="yes" xml:space="preserve">
          <source>Observables</source>
          <target state="translated">Observables</target>
        </trans-unit>
        <trans-unit id="b11d034f48ad50b05bcdbc51fb2bc638d49916bb" translate="yes" xml:space="preserve">
          <source>Observables and dependency tracking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="621445c3740dea16b530b18f93e077809839e366" translate="yes" xml:space="preserve">
          <source>Observing only certain properties using &amp;ldquo;observe&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5820d44b10477929b579ab80e1dfa0b99895aa33" translate="yes" xml:space="preserve">
          <source>Occasionally, you may find opportunities to streamline your code by attaching new functionality to Knockout&amp;rsquo;s core value types. You can define custom functions on any of the following types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31449567d7f21edc1facbf4447d941d2b4798e0a" translate="yes" xml:space="preserve">
          <source>Of course, inside the create callback you can do another call to ko.mapping.fromJS if you wish. A typical use-case might be if you want to augment the original JavaScript object with some additional &lt;a href=&quot;computedobservables&quot;&gt;computed observables&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ab11f1d7ae1b763bfdbe3807e0dd9ad83af6511" translate="yes" xml:space="preserve">
          <source>Of course, this is a lot of code at first glance, but once you&amp;rsquo;ve created your custom bindings they can very easily be reused in many places.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f700094b19d2adf8500f72e2a84b3d54353191" translate="yes" xml:space="preserve">
          <source>Of course, this is most useful when you have multiple radio button elements bound to a single model property. To ensure that only &lt;em&gt;one&lt;/em&gt; of those radio buttons can be checked at any one time, you should set all of their name attributes to an arbitrary common value (e.g., the value flavorGroup in the preceding example) - doing this puts them into a group where only one can be selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c68f1c87405be42eacbbbce0c48e9cb553450844" translate="yes" xml:space="preserve">
          <source>Of course, x.y.z should be replaced with the version number of the Knockout script you are loading (e.g., knockout-3.1.0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa33e822518a764cd6aa37dbe83b7633c72e02d" translate="yes" xml:space="preserve">
          <source>Of course, you can arbitrarily nest any number of foreach bindings along with other control-flow bindings such as if and with.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f4b8ea9e954eebaa70e0a9c65d26766627d86b" translate="yes" xml:space="preserve">
          <source>Of course, you can arbitrarily nest with bindings along with the other control-flow bindings such as &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f3aa665242655dd6d40a7753ba8a1bef582d3cc" translate="yes" xml:space="preserve">
          <source>Of course, you can create whole chains of computed observables if you wish. For example, you might have:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b3b30a86f9e0ac4c5bc2f098d8abb20f874f834" translate="yes" xml:space="preserve">
          <source>Of course, you don&amp;rsquo;t have to worry about releasing any event handlers created by standard Knockout bindings in your view, as KO automatically unregisters them when the elements are removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7bdef4ca5fa385742d68cfa6579c30b6c61548d" translate="yes" xml:space="preserve">
          <source>On this page, you&amp;rsquo;ll learn about the first of these three. But before that, let&amp;rsquo;s examine the MVVM pattern and the concept of a &lt;em&gt;view model&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1bc6631468dfada790b80fb194db5f58e531526" translate="yes" xml:space="preserve">
          <source>Optionally, you can pass a second parameter to define which part of the document you want to search for data-bind attributes. For example, ko.applyBindings(myViewModel, document.getElementById('someElementId')). This restricts the activation to the element with ID someElementId and its descendants, which is useful if you want to have multiple view models and associate each with a different region of the page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1765a06342825b17a9e403b215e90bde7a3b1c92" translate="yes" xml:space="preserve">
          <source>Optionally, your viewmodel class may have a dispose function. If implemented, Knockout will call this whenever the component is being torn down and removed from the DOM (e.g., because the corresponding item was removed from a foreach, or an if binding has become false).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4e4c99b9180d995ef38e38e86d46c2c354b0131" translate="yes" xml:space="preserve">
          <source>Or if you really don&amp;rsquo;t like the hackiness of the document.createElement call, then you could use a &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; for your top-level component instead of a custom element. As long as all other components are registered before your ko.applyBindings call, they can be used as custom elements on IE6-8 without futher trouble:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c54970fdc4cfe5ce955d0d99cddf7a056c2d8f2" translate="yes" xml:space="preserve">
          <source>Or, at least call document.createElement('your-component') &lt;em&gt;before&lt;/em&gt; the HTML parser sees any &amp;lt;your-component&amp;gt; elements. You can ignore the result of the createElement call &amp;mdash; all that matters is that you have called it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="888fa89b9dae94f674ec75254af5184f71fd7fb9" translate="yes" xml:space="preserve">
          <source>Or, if the component has no viewmodel, then the view is bound to any params you&amp;rsquo;ve supplied to the component binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ba0856e67eb87e7f52493db1a23ca2ca82c78f6" translate="yes" xml:space="preserve">
          <source>Or, if you don&amp;rsquo;t want to use jQuery, you can use any other mechanism for loading or saving JSON data. So, all Knockout needs to help you do is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f699ec4a263d96ea6e8330f504cbc76acb04a6da" translate="yes" xml:space="preserve">
          <source>Or, if you just want the plain JavaScript object graph &lt;em&gt;before&lt;/em&gt; serialization, use ko.toJS as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f545ea154ca17421845c1c4d49c0c277020bb7c" translate="yes" xml:space="preserve">
          <source>Other browsers, and newer versions of IE, don&amp;rsquo;t have this quirk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7d69219a1d86b1de7eaa38435a5ef6a295349c2" translate="yes" xml:space="preserve">
          <source>Other technologies may depend on the assumption that certain elements have names, even though names might be irrelevant when you&amp;rsquo;re using KO. For example, &lt;a href=&quot;http://jqueryvalidation.org/&quot;&gt;jQuery Validation&lt;/a&gt; currently will only validate elements that have names. To use this with a Knockout UI, it&amp;rsquo;s sometimes necessary to apply the uniqueName binding to avoid confusing jQuery Validation. See &lt;a href=&quot;http://knockoutjs.com/examples/gridEditor.html&quot;&gt;an example of using jQuery Validation with KO&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b76426a4b4527523a89c8447c24b37b42bba21f" translate="yes" xml:space="preserve">
          <source>Overriding the clean-up of external data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c6c53d0c3ba99a8159d80012914470bb2bd02f8" translate="yes" xml:space="preserve">
          <source>Overview of AMD</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="ee9bc64679c883d8315ef21591e760cbc38b8e61" translate="yes" xml:space="preserve">
          <source>Pass a function reference (either a function literal, or give the name of a function on your view model), and Knockout will invoke it immediately after rendering or re-rendering your template. If you&amp;rsquo;re using foreach, Knockout will invoke your afterRender callback for each item added to your observable array. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a4fc664fb015dd2b90366bae7b7c6166a290c0f" translate="yes" xml:space="preserve">
          <source>Pass the array that you wish to iterate over. The binding will output a section of markup for each entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac917217788ea4daf427e3524d9e686c7fae6951" translate="yes" xml:space="preserve">
          <source>Pass true (or some value that evaluates as true) to enable the uniqueName binding, as in the preceding example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48fbf79eab4d275311cd306a9da00e04a2da8f50" translate="yes" xml:space="preserve">
          <source>Pass true (or some value that evaluates as true) to focus the associated element. Otherwise, the associated element will be unfocused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9cfb6f55eaea0baeb940c302cc0775a2e4e29f0" translate="yes" xml:space="preserve">
          <source>Passing markup into components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b31412042fa68bceb2962653f184dcb45a1c94c" translate="yes" xml:space="preserve">
          <source>Passing observable expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3157744f3e6488a569fb33f59900039dd87730b5" translate="yes" xml:space="preserve">
          <source>Passing parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c30396c874cdc27bd19277aa1a80c77188378ef" translate="yes" xml:space="preserve">
          <source>Please note that, as of December 2011, jQuery.tmpl is no longer under active development. We recommend the use of Knockout&amp;rsquo;s native DOM-based templating (i.e., the foreach, if, with, etc. bindings) instead of jQuery.tmpl or any other string-based template engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="24a0be8dab4fe687c8ad437ae1be347c7c275ab3" translate="yes" xml:space="preserve">
          <source>Prepopulating an observableArray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d1738d650def938c652b581eb2ab8e9e23bac2" translate="yes" xml:space="preserve">
          <source>Preprocessing DOM nodes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bd28988e0d739a767c1940c87323328cfd0452d" translate="yes" xml:space="preserve">
          <source>Preprocessing Reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b4f8689a05bc9cca63e4c44017f14efdaadb92" translate="yes" xml:space="preserve">
          <source>Preprocessing binding strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72734b1cb5286fcdc2e795102ddabad4a96ba527" translate="yes" xml:space="preserve">
          <source>Pretty simple, really.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02097511df2d0e39c9337e94983004dd3194c3a0" translate="yes" xml:space="preserve">
          <source>Prior to Knockout 3.4.0, you might need to use synchronous loading to prevent multiple DOM reflows when including many components simultaneously (such as with the foreach binding). With Knockout 3.4.0, components use Knockout&amp;rsquo;s &lt;a href=&quot;microtasks&quot;&gt;microtasks&lt;/a&gt; to ensure asynchronicity, and so will generally perform as well as synchronous loading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d2145824730e5c1b8fb6fa87d2dd101b9cb427" translate="yes" xml:space="preserve">
          <source>Pure computed observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ce509d140c0943b0fb6b3aa19d560a50d452fc" translate="yes" xml:space="preserve">
          <source>Pure computeds were introduced in Knockout 3.2.0. See also: &lt;a href=&quot;computed-pure&quot;&gt;more about pure computed observables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="57f47271f3869d1768dcebd5706b5e412a9e5dd1" translate="yes" xml:space="preserve">
          <source>Rate-limiting observable notifications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="109ca37b53291d60621572a50045d0cd051c1b2b" translate="yes" xml:space="preserve">
          <source>Reading and writing observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a460971e455292dd35a366b845f6510cca16999" translate="yes" xml:space="preserve">
          <source>Reading information from an observableArray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10a415b94b161f38c600daa4d4bb513ecf982216" translate="yes" xml:space="preserve">
          <source>Recursive task limit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43f5384571767bbaaa6fd7375d219904895bb1b7" translate="yes" xml:space="preserve">
          <source>Registering a callback on the disposal of an element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a480de52dbedb53c2cf2350afee5ac13630029e" translate="yes" xml:space="preserve">
          <source>Registering components as a single AMD module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35b2eb936781d5e3694cfbb0f326c5c7048ea539" translate="yes" xml:space="preserve">
          <source>Registering components as a viewmodel/template pair</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbdca1da5454335dd25004eb3b50c8f66e895af6" translate="yes" xml:space="preserve">
          <source>Registering custom component loaders</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbd0999bf6bb00d22dc5e82c04cc79930c05379a" translate="yes" xml:space="preserve">
          <source>Registering custom elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1532215d29dce0afe9ba8e71d6fd4a5554bf38e2" translate="yes" xml:space="preserve">
          <source>Registering your binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a362d04fc57f7bc49c1be4cc35fc032c5bc523" translate="yes" xml:space="preserve">
          <source>Registers a component. See: &lt;a href=&quot;component-registration&quot;&gt;full documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e806ea593f70ec532713b2e31cb54e34ae2fbb61" translate="yes" xml:space="preserve">
          <source>Removes all child nodes from the real or virtual element containerElem (cleaning away any data associated with them to avoid memory leaks).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55eb1f75a4466755cbf9da8ee93eb912dc9b1c70" translate="yes" xml:space="preserve">
          <source>Removes all child nodes from the real or virtual element containerElem (in the process, cleaning away any data associated with them to avoid memory leaks), and then inserts all of the nodes from arrayOfNodes as its new children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa97aaf82420ccf3d840fd847ac4d33d6adbd799" translate="yes" xml:space="preserve">
          <source>Removes the named component from the registry. Or if no such component was registered, does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0890f779408fa8ac76a438a26ba53f60dda91ecf" translate="yes" xml:space="preserve">
          <source>RequireJs Download</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00f09c861f9b24affecf1566366551a836249bc6" translate="yes" xml:space="preserve">
          <source>RequireJs can be downloaded from &lt;a href=&quot;http://requirejs.org/docs/download.html&quot;&gt;http://requirejs.org/docs/download.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="353d8d344e6b162e4c17b4210bea67369e7ef3b0" translate="yes" xml:space="preserve">
          <source>Returns the first child of the real or virtual element containerElem, or null if there are no children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44b98d7f68f260183d81c591bdaf943f8bbc926" translate="yes" xml:space="preserve">
          <source>Returns the sibling node that follows node in its real or virtual parent element, or null if there is no following sibling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bb189a069efd2411fee0be779b73d0bb87f5573" translate="yes" xml:space="preserve">
          <source>Returns true if a component with the specified name is already registered; false otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0da6a7855830c066dbda602feb809af4d79023" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#using-valueallowunset-with-select-elements&quot;&gt;Note 2&lt;/a&gt; below. Note that valueAllowUnset is only applicable when using value to control selection on a &amp;lt;select&amp;gt; element. On other elements it has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a4086bf02e9470ff9beaf89243d77e8723e08b3" translate="yes" xml:space="preserve">
          <source>See Example 3 above to see how you can bind options to an array of arbitrary JavaScript object - not just strings. In this case, you need to choose which of the objects&amp;rsquo; properties should be displayed as the text in the drop-down list or multi-select list. Example 3 shows how you can specify that property name by passing an additional parameter called optionsText.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="627ede17723b7a1dcb26a936f7757623f8efd898" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;http://www.comptechdoc.org/independent/web/cgi/javamanual/javastyle.html&quot;&gt;a longer list of style names and their JavaScript equivalents&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60845dd06d2f273308891baec64862cb1ed3b782" translate="yes" xml:space="preserve">
          <source>See later on this page for an API reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf68dcb1970e76f58db5ceb232524856770b8e5d" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;component-custom-elements#registering-custom-elements&quot;&gt;How to enable custom elements with names that don&amp;rsquo;t correspond to explicitly registered components&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95713d3429a1266b03118a0b69f2eaedb23716fe" translate="yes" xml:space="preserve">
          <source>Sequence of calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a58a31297954712265cfbf6c89f922aec8df4a41" translate="yes" xml:space="preserve">
          <source>Shorthand syntax: If you just supply a string value, KO will interpret this as the ID of a template to render. The data it supplies to the template will be your current model object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b9f5929894997ad56cc3c83383ff218a8e4e68" translate="yes" xml:space="preserve">
          <source>Side effects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6ea4fd88d422a61726a7ab7fbe12390130c4662" translate="yes" xml:space="preserve">
          <source>Similar to optionsText, you can also pass an additional parameter called optionsValue to specify which of the objects&amp;rsquo; properties should be used to set the value attribute on the &amp;lt;option&amp;gt; elements that KO generates. You can also specify a JavaScript function to determine this value. This function will receive the selected item as its only argument and should return a string to use for the &amp;lt;option&amp;gt; element&amp;rsquo;s value attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a3bedd0f29a85642c5a7d68ff7d9693c61a907d" translate="yes" xml:space="preserve">
          <source>Similarly, you can use $parent to refer to data from outside the foreach, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650503158b05d9103c9329aa587f1f1317a8e97b" translate="yes" xml:space="preserve">
          <source>Simply putting an object into an observableArray doesn&amp;rsquo;t make all of that object&amp;rsquo;s properties themselves observable. Of course, you can make those properties observable if you wish, but that&amp;rsquo;s an independent choice. An observableArray just tracks which objects it holds, and notifies listeners when objects are added or removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abf2e06137216103f9b100bf2bc6e09236071fb4" translate="yes" xml:space="preserve">
          <source>Since Browserify is a build-time tool, it doesn&amp;rsquo;t really need any special integration with KO components, and there&amp;rsquo;s no need to implement any kind of custom component loader to work with it. You can simply use Browserify&amp;rsquo;s require statements to grab instances of your component viewmodels, then explicitly register them, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010c57fd25ed1704f31800fad07288ef30d11c0d" translate="yes" xml:space="preserve">
          <source>Since Knockout processes the microtask queue until it is empty, without yielding to external events, numerous or lengthy tasks could cause the browser page to become unresponsive. Knockout prevents infinite recursion by canceling all remaining tasks if it detects a high level of recursion. For example, the following will eventually stop and throw an error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12616501c65e2d78b083723430a1a67a2a4941a" translate="yes" xml:space="preserve">
          <source>Since document fragments can have multiple top-level nodes, the &lt;em&gt;entire&lt;/em&gt; document fragment (not just descendants of top-level nodes) is treated as the component template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd18b758f5b6eba86bebba7b461201774c396857" translate="yes" xml:space="preserve">
          <source>Since evaluating myExpr involves reading an observable (useObservable1), KO will supply the parameter to the component as a computed property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03be85be12c780e8cd251d6eb6bc1adf4b6ad284" translate="yes" xml:space="preserve">
          <source>Since the dependency on the template is explicitly stated in the define call, this automatically works with the &lt;a href=&quot;http://requirejs.org/docs/optimization.html&quot;&gt;r.js optimizer&lt;/a&gt; or similar bundling tools. The entire component - viewmodel plus template - can therefore trivially be included in a bundle file during a build step.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224aadfbf82f9551d1965c5a2c5ff4d289869d3f" translate="yes" xml:space="preserve">
          <source>Since the view model properties are observable, KO will automatically update the HTML elements whenever those properties change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ad2a3557f290cc16325b7dad71154f1a20332d" translate="yes" xml:space="preserve">
          <source>Since this binding sets your element&amp;rsquo;s content using innerHTML, you should be careful not to use it with untrusted model values, because that might open the possibility of a script injection attack. If you cannot guarantee that the content is safe to display (for example, if it is based on a different user&amp;rsquo;s input that was stored in your database), then you can use &lt;a href=&quot;text-binding&quot;&gt;the text binding&lt;/a&gt;, which will set the element&amp;rsquo;s text value using innerText or textContent instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd93df4e4321804a588bbd3af3830ed05cdb095f" translate="yes" xml:space="preserve">
          <source>Since this binding sets your text value using a text node, it&amp;rsquo;s safe to set any string value without risking HTML or script injection. For example, if you wrote:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef8a4666dd8f23e26196f0af5791e8341741188" translate="yes" xml:space="preserve">
          <source>Since this computed is declared to be &lt;em&gt;pure&lt;/em&gt; (i.e., its evaluator does not directly modify other objects or state), Knockout can more efficiently manage its re-evaluation and memory use. Knockout will automatically suspend or release it if no other code has an active dependency on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eec92e863ead404e06db453854298b7f7aeeb964" translate="yes" xml:space="preserve">
          <source>Skipping the binding value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a0401febcbb91e5467f60a83d13d63f45dbb325" translate="yes" xml:space="preserve">
          <source>So what does Knockout do if you have a cycle in your dependency graph? It avoids infinite loops by enforcing the following rule: &lt;strong&gt;Knockout will not restart evaluation of a computed while it is already evaluating&lt;/strong&gt;. This is very unlikely to affect your code. It&amp;rsquo;s relevant in two situations: when two computed observables are dependent on each other (possible only if one or both use the deferEvaluation option), or when a computed observable writes to another observable on which it has a dependency (either directly or via a dependency chain). If you need to use one of these patterns and want to entirely avoid the circular dependency, you can use the peek function described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6f08edfde52faf5dc68f34cf119dab791fd12c1" translate="yes" xml:space="preserve">
          <source>So, Knockout doesn&amp;rsquo;t just detect dependencies the first time the evaluator runs - it redetects them every time. This means, for example, that the dependencies can vary dynamically: dependency A could determine whether the computed observable also depend on B or C. Then, it will only be re-evaluated when either A or your current choice of B or C changes. You don&amp;rsquo;t have to declare dependencies: they&amp;rsquo;re determined at runtime from the code&amp;rsquo;s execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6039155cfd6e7342a4bb866968884c937aafd1" translate="yes" xml:space="preserve">
          <source>So, if you would like to map a JavaScript object to this, you can pass this as the third argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c47887016b47f8753b43bbda895cb4a52d3627b" translate="yes" xml:space="preserve">
          <source>So, ko.components.loaders is an array containing all the loaders currently enabled. By default, this array contains just one item: ko.components.defaultLoader. To add additional loaders, simply insert them into the ko.components.loaders array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcadd6a9a819e98e876d51538df845e3924045c1" translate="yes" xml:space="preserve">
          <source>So, what&amp;rsquo;s this _destroy thing all about? It&amp;rsquo;s only really interesting to Rails developers. The convention in Rails is that, when you pass into an action a JSON object graph, the framework can automatically convert it to an ActiveRecord object graph and then save it to your database. It knows which of the objects are already in your database, and issues the correct INSERT or UPDATE statements. To tell the framework to DELETE a record, you just mark it with _destroy set to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc17b6b6ff109ca3571a9c612acc5269c5e86c5" translate="yes" xml:space="preserve">
          <source>Sometimes it may be necessary to have more control over how the mapping is performed. This is accomplished using &lt;em&gt;mapping options&lt;/em&gt;. They can be specified during the ko.mapping.fromJS call. In subsequent calls you don&amp;rsquo;t need to specify them again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1efa8d65721b2af289c42fb7b810ae66b4f29f5d" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to control the presence/absence of a section of markup &lt;em&gt;without&lt;/em&gt; having any container element that can hold an if binding. For example, you might want to control whether a certain &amp;lt;li&amp;gt; element appears alongside siblings that always appear:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090d7c130eac68daf4d626886fb71b101a09b651" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to create a component that receives markup and uses it as part of its output. For example, you may want to build a &amp;ldquo;container&amp;rdquo; UI element such as a grid, list, dialog, or tab set that can receive and bind arbitrary markup inside itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1450743be880bbdffbc9a1ba26bf1fd07e6f657e" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to inject a component into a view without using an extra container element. You can do this using &lt;em&gt;containerless control flow syntax&lt;/em&gt;, which is based on comment tags. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b22fd48b43a0ffdb2cae9da6d525da9fd48f8e" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to mark an array entry as deleted, but without actually losing record of its existence. This is known as a &lt;em&gt;non-destructive delete&lt;/em&gt;. For details of how to do this, see &lt;a href=&quot;observablearrays#destroy-and-destroyall&quot;&gt;the destroy function on observableArray&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbd93e9d13d7bfcfd8e5c31ed2ceac2a6c4e1754" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to mark an array entry as deleted, but without actually losing record of its existence. This is known as a non-destructive delete. For details of how to do this, see &lt;a href=&quot;observablearrays#destroy-and-destroyall&quot;&gt;the destroy function on observableArray&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a812dff6786cd406aaefba5f4c3b70873c52a6" translate="yes" xml:space="preserve">
          <source>Sometimes you may want to set text using Knockout without including an extra element for the text binding. For example, you&amp;rsquo;re not allowed to include other elements within an option element, so the following will not work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a4525599ef68a9fe43c6df211cccff711b57d1e" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to represent a data point on the screen in a different format than its underlying storage. For example, you might want to store a price as a raw float value, but let the user edit it with a currency symbol and fixed number of decimal places. You can use a writable computed observable to represent the formatted price, mapping incoming values back to the underlying float value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05cfb62c148b0599a08339e0df2d05f5ef502466" translate="yes" xml:space="preserve">
          <source>Sometimes you might want to run custom post-processing logic on the DOM elements generated by your templates. For example, if you&amp;rsquo;re using a JavaScript widgets library such as jQuery UI, you might want to intercept your templates&amp;rsquo; output so that you can run jQuery UI commands on it to transform some of the rendered elements into date pickers, sliders, or anything else.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a20134d13c4fa83399a61a6648dae5f5c9116e3" translate="yes" xml:space="preserve">
          <source>Sometimes, you might not want to select any particular option by default. But a single-select drop-down list usually starts with some item selected, so how can you avoid preselecting something? The usual solution is to prefix the list of options with a special dummy option that just reads &amp;ldquo;Select an item&amp;rdquo; or &amp;ldquo;Please choose an option&amp;rdquo; or similar, and have that one selected by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a88830ac8683679b861aa2877996a238dbfdf87d" translate="yes" xml:space="preserve">
          <source>Source code: View</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6506bd5b573750d96e1b57831c62ba19272cf14f" translate="yes" xml:space="preserve">
          <source>Source code: View model</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f8a682df856004ef8f68cac3fd529a0a678f8b" translate="yes" xml:space="preserve">
          <source>Special consideration for computed observables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4551a643a13595067fd9579e7489ebfab8a1983d" translate="yes" xml:space="preserve">
          <source>Special consideration is given if your parameter resolves to an array. In this case, KO will set the element to be &lt;em&gt;checked&lt;/em&gt; if the value matches an item in the array, and &lt;em&gt;unchecked&lt;/em&gt; if it is not contained in the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26666026e63743d1a82020481615fe638ff934ed" translate="yes" xml:space="preserve">
          <source>Specifying a template</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b1d7859ab19cd19f47ec6abc15db40ae61a246c" translate="yes" xml:space="preserve">
          <source>Specifying a viewmodel</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea0e6f5e3da2da0e29f0ea90ea1b0cd98c85ba63" translate="yes" xml:space="preserve">
          <source>Specifying additional component options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b4234e7c86c009699286451ef7b9d36ae43d1e" translate="yes" xml:space="preserve">
          <source>Specifying the update target</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bcfc349547d09f30035896045c448b81206e326" translate="yes" xml:space="preserve">
          <source>Starting with Knockout 3.0, developers can define custom syntaxes by providing callbacks that rewrite DOM nodes and binding strings during the binding process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c796aa5f2bada6792690259418192c7883d1c418" translate="yes" xml:space="preserve">
          <source>Starting with Knockout 3.0, you can specify bindings without a value, which will give the binding an undefined value. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2693170c13c752044d965baa86ff029af25c5bd4" translate="yes" xml:space="preserve">
          <source>State-change notifications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="c6f3ef32f538ba7ddc197ba2a40ed8bf1267eff0" translate="yes" xml:space="preserve">
          <source>Taking this a step further, you could also toggle an isValid flag depending on whether the latest input was satisfactory, and display a message in the UI accordingly. There&amp;rsquo;s an easier way of doing validation (explained below), but first consider the following example, which demonstrates the mechanism:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd2f41bbe59a64109622cb800b43d5098fbef87" translate="yes" xml:space="preserve">
          <source>Technically you can use any of the native JavaScript array functions to operate on that underlying array, but normally there&amp;rsquo;s a better alternative. KO&amp;rsquo;s observableArray has equivalent functions of its own, and they&amp;rsquo;re more useful because:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9d610e2da9960031e5fc6eb154252b9be195eaf" translate="yes" xml:space="preserve">
          <source>Templates can be specified in any of the following forms. The most commonly useful are &lt;a href=&quot;#an-existing-element-id&quot;&gt;existing element IDs&lt;/a&gt; and &lt;a href=&quot;#an-amd-module-whose-value-describes-a-template&quot;&gt;AMD modules&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="200be3445e2bde1ede81d4c95d33bd1076a8277f" translate="yes" xml:space="preserve">
          <source>Templating</source>
          <target state="translated">Templating</target>
        </trans-unit>
        <trans-unit id="d0044a6eb26a5c396986a0204048b9d5e5baf64c" translate="yes" xml:space="preserve">
          <source>That does it! Now, your view will display as if you&amp;rsquo;d written the following HTML:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02e149eee4340af4ceec19232b911078d7192e9a" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s because the options binding tries to be independent of the value binding (which controls selection for a single-select list) and the selectedOptions binding (which controls selection for a multi-select list).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e674558ecc1081e9c1295665f7df128dafb8d87b" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s it! You don&amp;rsquo;t have to write code to update it; it updates on its own when the myItems array changes. Similarly, to make the &amp;lsquo;Add&amp;rsquo; button enable or disable depending on the number of items, just write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="667657cfbe0d82dea6d00158cadde1d15d9e504d" translate="yes" xml:space="preserve">
          <source>The &quot;attr&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81fe0aefcb8907e65d4f80424d8b82ba6529ef05" translate="yes" xml:space="preserve">
          <source>The &quot;checked&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="729792440e88ab1975faa8b1ae741d3568a9e80f" translate="yes" xml:space="preserve">
          <source>The &quot;click&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f9daf36f2cbfcb9347bc8d5a2a9ac913f55ee0" translate="yes" xml:space="preserve">
          <source>The &quot;component&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="268bdcaa2d0957c8d0391d4c4e143f349a3a0908" translate="yes" xml:space="preserve">
          <source>The &quot;css&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa22ef1d97b1be4a810e3f5260ca2fd7b9c4b9cc" translate="yes" xml:space="preserve">
          <source>The &quot;disable&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="041e1100c69440c690c0a77bb60251bbe60aa13d" translate="yes" xml:space="preserve">
          <source>The &quot;enable&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b081740d1fb26b2947fc54f2be8290dd6b4f171" translate="yes" xml:space="preserve">
          <source>The &quot;event&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeb9266b69cb94e4efef8e8ec8245bac4441f5fb" translate="yes" xml:space="preserve">
          <source>The &quot;foreach&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387e6548a4d36e8f21807318bf235e14d2cabd7e" translate="yes" xml:space="preserve">
          <source>The &quot;hasFocus&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3bd7e57ef15a3a444a9a54af1c145628250ace9" translate="yes" xml:space="preserve">
          <source>The &quot;html&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8a22f402c1cb22df5a11c1cf759eb4fcb7755fd" translate="yes" xml:space="preserve">
          <source>The &quot;if&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e058224b266f791dfd293b2509c3657b73c91ee" translate="yes" xml:space="preserve">
          <source>The &quot;ifnot&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86ecb831b753a1b99237c2da228b61981e524a2c" translate="yes" xml:space="preserve">
          <source>The &quot;options&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="998f0ccdcc6e82328f9f4ecba0c9325b97e976df" translate="yes" xml:space="preserve">
          <source>The &quot;selectedOptions&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0ad502b61055bf3d6312ebedf00afcf36c21e2" translate="yes" xml:space="preserve">
          <source>The &quot;style&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="012a650b218ca98273aeac430939dd9445632dd3" translate="yes" xml:space="preserve">
          <source>The &quot;submit&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e48a0247d14aa0d9c333491f221626e25bc43fb" translate="yes" xml:space="preserve">
          <source>The &quot;template&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d856ef4864767a8e9b7d18ca94745b74199eb43" translate="yes" xml:space="preserve">
          <source>The &quot;text&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60b50b0405f6a55d057311d3ce77ae607e221184" translate="yes" xml:space="preserve">
          <source>The &quot;textInput&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf70dcaafb5eeb11cd70e48b42ab8792299341fb" translate="yes" xml:space="preserve">
          <source>The &quot;uniqueName&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abff06e6a46c514b00a9d69ebda1678fe9b61252" translate="yes" xml:space="preserve">
          <source>The &quot;value&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9926725b31c6326f65c499ed6e2d7c6ef89cb6" translate="yes" xml:space="preserve">
          <source>The &quot;visible&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2695c31457d8ecf209fdcde945ae4b7e6b35704" translate="yes" xml:space="preserve">
          <source>The &quot;with&quot; binding</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0172068eae28b7598208322680a72ead20dc040" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;init&amp;rdquo; callback</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bffd25f7f08d8f696284fca0cd9e9a510a5a82" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;update&amp;rdquo; callback</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7b56425c510dea26081ff5f361028be5d697e8c" translate="yes" xml:space="preserve">
          <source>The &amp;lt;!-- ko --&amp;gt; and &amp;lt;!-- /ko --&amp;gt; comments act as start/end markers, defining a &amp;ldquo;virtual element&amp;rdquo; that contains the markup inside. Knockout understands this virtual element syntax and binds as if you had a real container element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66447128a53fc158d2a378583ff58d8cb3b7f44b" translate="yes" xml:space="preserve">
          <source>The &amp;lt;!--ko--&amp;gt; and &amp;lt;!--/ko--&amp;gt; comments act as start/end markers, defining a &amp;ldquo;virtual element&amp;rdquo; that contains the markup inside. Knockout understands this virtual element syntax and binds as if you had a real container element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c0fa3ec409d116219327c807820e685d0a681ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;checked-binding&quot;&gt;checked&lt;/a&gt; binding should be used to bind a view model property against the value of a checkbox (&amp;lt;input type='checkbox'&amp;gt;) or radio button (&amp;lt;input type='radio'&amp;gt;). If you do include the value binding with the checked binding on one of these elements, then the value binding will simply act like the &lt;a href=&quot;checked-binding#checkedValue&quot;&gt;checkedValue&lt;/a&gt; option that can be used with the checked binding and will control the value that is used for updating your view model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="063f48d562135b75491eebc35abcf6a8aa221482" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://documentcloud.github.com/underscore/#template&quot;&gt;Underscore.js template engine&lt;/a&gt; by default uses ERB-style delimiters (&amp;lt;%= ... %&amp;gt;). Here&amp;rsquo;s how the preceding example&amp;rsquo;s template might look with Underscore:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef92cc17f05a45263dfe218714287940c12a0b66" translate="yes" xml:space="preserve">
          <source>The added array element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b57088d36db63605ea20966d4f6ddfdc3a240418" translate="yes" xml:space="preserve">
          <source>The arrays ignore and include still work as normal. The array copy can be used for efficiency to copy array or object properties including children. If an array or object property is not specified in copy or observe then it is recursively mapped:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b6946f4dee7b5d349c61c577e42283624be620" translate="yes" xml:space="preserve">
          <source>The attr binding provides a generic way to set the value of any attribute for the associated DOM element. This is useful, for example, when you need to set the title attribute of an element, the src of an img tag, or the href of a link based on values in your view model, with the attribute value being updated automatically whenever the corresponding model property changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ef329ec6555c9ead7be23ed4a0362089a23da81" translate="yes" xml:space="preserve">
          <source>The binding &lt;em&gt;name&lt;/em&gt; should generally match a registered binding handler (either built-in or &lt;a href=&quot;custom-bindings&quot;&gt;custom&lt;/a&gt;) or be a parameter for another binding. If the name matches neither of those, Knockout will ignore it (without any error or warning). So if a binding doesn&amp;rsquo;t appear to work, first check that the name is correct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="652f2f5c9f8a12eb6ee21fee9ad6a56c07e3be9d" translate="yes" xml:space="preserve">
          <source>The binding &lt;em&gt;value&lt;/em&gt; can be a single &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Values,_variables,_and_literals&quot;&gt;value, variable, or literal&lt;/a&gt; or almost any valid &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Expressions_and_Operators&quot;&gt;JavaScript expression&lt;/a&gt;. Here are examples of various binding values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c2e2c23df54cb959bb9b3e5e3e3ebc75348a46" translate="yes" xml:space="preserve">
          <source>The built-in default component loader, ko.components.defaultLoader, is based around a central &amp;ldquo;registry&amp;rdquo; of component definitions. It relies on you explicitly registering a configuration for each component before you can use that component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d971840dc40d1d830c39a6836f76bdcbe10df112" translate="yes" xml:space="preserve">
          <source>The checked binding links a checkable form control &amp;mdash; i.e., a checkbox (&amp;lt;input type='checkbox'&amp;gt;) or a radio button (&amp;lt;input type='radio'&amp;gt;) &amp;mdash; with a property on your view model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30cda63d43cbee5c35bb13029131bdfe0150f240" translate="yes" xml:space="preserve">
          <source>The click binding adds an event handler so that your chosen JavaScript function will be invoked when the associated DOM element is clicked. This is most commonly used with elements like button, input, and a, but actually works with any visible DOM element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315af6b13a3b050b2e8e589958153d689f7c75e4" translate="yes" xml:space="preserve">
          <source>The component &lt;strong&gt;name&lt;/strong&gt; can be any nonempty string. It&amp;rsquo;s recommended, but not mandatory, to use lowercase dash-separated strings (such as your-component-name) so that the component name is valid to use as a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt; (such as &amp;lt;your-component-name&amp;gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ee1b6f8e527013cbe31220266cd96f28da0019" translate="yes" xml:space="preserve">
          <source>The component binding injects a specified &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; into an element, and optionally passes parameters to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d5135a132a3ef368448c56cda2be61f2f6fc1c6" translate="yes" xml:space="preserve">
          <source>The component can then choose to use the supplied DOM nodes as part of its output however it wishes, such as by using template: { nodes: $componentTemplateNodes } on any element in the component&amp;rsquo;s template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f46804718d8f0a271608004b91334bb085b20e" translate="yes" xml:space="preserve">
          <source>The componentInfo.templateNodes array is useful if you want to build a component that accepts arbitrary markup to influence its output (for example, a grid, list, dialog, or tab set that injects supplied markup into itself). For a complete example, see &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;passing markup into components&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c8df0fe7dc76501e3c6d96810962786f87bc2a" translate="yes" xml:space="preserve">
          <source>The copy array you specify in the mapping options is combined with the default copy array, which by default is empty. You can manipulate this default array like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="932d9cd639f9a34ea0a379bb562c58e1459a2f51" translate="yes" xml:space="preserve">
          <source>The css binding adds or removes one or more named CSS classes to the associated DOM element. This is useful, for example, to highlight some value in red if it becomes negative.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bca18c0eecebb94630002d080cd4f3ec6dd0351" translate="yes" xml:space="preserve">
          <source>The data item against which it is bound, or undefined for the caption element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="108f5df83762dc6213fdc4d63d42ffa6220b8746" translate="yes" xml:space="preserve">
          <source>The data item against which they are being bound</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e02fc5ece743a7fd3262031255398c42b17ef54c" translate="yes" xml:space="preserve">
          <source>The data-bind attribute isn&amp;rsquo;t native to HTML, though it is perfectly OK (it&amp;rsquo;s strictly compliant in HTML 5, and causes no problems with HTML 4 even though a validator will point out that it&amp;rsquo;s an unrecognized attribute). But since the browser doesn&amp;rsquo;t know what it means, you need to activate Knockout to make it take effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e3559e993c827d22c705e31984a570c621dea7" translate="yes" xml:space="preserve">
          <source>The data-bind syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="366e4820449d60904ec50a029f22f31fe805c045" translate="yes" xml:space="preserve">
          <source>The default component loader</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce7b599739744a48558fac0535eb69108e550ffd" translate="yes" xml:space="preserve">
          <source>The default component loader supplies viewmodels/templates based on &lt;a href=&quot;component-registration&quot;&gt;what you have registered&lt;/a&gt;. If applicable, this is the phase where it requests any specified AMD modules from your AMD loader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09732649e70687aaf1c33ff6ca19f79f252c6c8b" translate="yes" xml:space="preserve">
          <source>The default component loader will call this function on any registered loaders that declare it, to convert the template part of a component configuration into an array of DOM nodes. The nodes are then cached and cloned for each instance of the component.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ccce60a7742e398540647ff9062227dfd855b0" translate="yes" xml:space="preserve">
          <source>The default component loader will call this function on any registered loaders that declare it, to convert the viewModel part of a component configuration into a createViewModel factory function. The function is then cached and called for each new instance of the component that needs a viewmodel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15dd6f7b5fcf81a774da95adae457614aaac160f" translate="yes" xml:space="preserve">
          <source>The default loader itself has a loadTemplate function that resolves a range of template configuration formats into DOM arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead01d1120c6a1f313be5641ab191d173c3b1ccd" translate="yes" xml:space="preserve">
          <source>The default loader itself has a loadViewModel function that resolves a range of viewmodel configuration formats into createViewModel functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7897f3dd77b93db3f4074ec350ef4f1d3045faba" translate="yes" xml:space="preserve">
          <source>The default rate-limit method is different from the throttle algorithm. To match the throttle behavior, use the notifyWhenChangesStop method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e8110ec26b3e497db5167ef4c25bc7261c68f9a" translate="yes" xml:space="preserve">
          <source>The default sort is alphabetical, but you can optionally pass a function to control how the array should be sorted. Your function should accept any two objects from the array and return a negative value if the first argument is smaller, a positive value is the second is smaller, or zero to treat them as equal. For example, to sort an array of &amp;lsquo;person&amp;rsquo; objects by last name, you could write myObservableArray.sort(function (left, right) { return left.lastName == right.lastName ? 0 : (left.lastName &amp;lt; right.lastName ? -1 : 1) })</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d097cb656bd9314287c368f7b582f51a1afa06" translate="yes" xml:space="preserve">
          <source>The destroy and destroyAll functions are mainly intended as a convenience for developers using Ruby on Rails:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dc38377602a5bf251c9ac8f8c358c2b61a483de" translate="yes" xml:space="preserve">
          <source>The disable binding causes the associated DOM element to be disabled only when the parameter value is true. This is useful with form elements like input, select, and textarea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="034a88a2a8e70f61d5f53b00afb344cce6b30f2a" translate="yes" xml:space="preserve">
          <source>The element you attach a component binding to may contain further markup. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3c15f42cf7a0908e29bc9f6fc045acec85c8dec" translate="yes" xml:space="preserve">
          <source>The enable binding causes the associated DOM element to be enabled only when the parameter value is true. This is useful with form elements like input, select, and textarea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3a188f4389ae5361ef1aab713ad2e218776c5b" translate="yes" xml:space="preserve">
          <source>The event binding allows you to add an event handler for a specified event so that your chosen JavaScript function will be invoked when that event is triggered for the associated DOM element. This can be used to bind to any event, such as keypress, mouseover or mouseout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6bb1049202e2fc471d173b4114d739d41bd5d4a" translate="yes" xml:space="preserve">
          <source>The expression you wish to evaluate. If it evaluates to true (or a true-ish value), the contained markup will be present in the document, and any data-bind attributes on it will be applied. If your expression evaluates to false, the contained markup will be removed from your document without first applying any bindings to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08b6e9421ee0e5a90e98af3344e9a07e58b28e79" translate="yes" xml:space="preserve">
          <source>The first parameter says what view model object you want to use with the declarative bindings it activates</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b90ab49c50c0b034f2f0166f20a5588123515faf" translate="yes" xml:space="preserve">
          <source>The first time Knockout needs to construct a component with a given name, it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49abc06d3a5bd2396f32cea388b57547fd21ef1f" translate="yes" xml:space="preserve">
          <source>The following custom loader will take care of loading templates configured with a fromUrl value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3995f6c348f83c5d5d2c8c0c8d7c7c7dfb7c996e" translate="yes" xml:space="preserve">
          <source>The following documentation describes how to construct and work with computed observables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0271855925638e4b40f25932438e098db254cb45" translate="yes" xml:space="preserve">
          <source>The following example shows that, if your array is observable, then the UI will be kept in sync with changes to that array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0edc57c644719ae6f6c9285db552bc68ee184f" translate="yes" xml:space="preserve">
          <source>The following functions read and write the default component loader&amp;rsquo;s registry:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0549b512d611b4d61feda0a2b865a4445c3979c" translate="yes" xml:space="preserve">
          <source>The following functions work across the complete list of registered component loaders (not only the default loader):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e0d8a79330b00d1238373a646441103eff02bac" translate="yes" xml:space="preserve">
          <source>The following is a contrived example to demonstrate the ability of deferred updates to eliminate UI updates of intermediate values and how this can improve performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c11fe6c92bb9852e1a3441bd3a5eaa04a0bf79f" translate="yes" xml:space="preserve">
          <source>The following live example shows how you could use this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbe9e5e7430435e030bf8f72ddf5fd35ac54309f" translate="yes" xml:space="preserve">
          <source>The following markup:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a36c23f779b16430f2a073c5b148d24516e2493" translate="yes" xml:space="preserve">
          <source>The following model represents data that you could render as a paged grid:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0852ae4081a5c612640e5df5209e727eefc9387" translate="yes" xml:space="preserve">
          <source>The following special variables are also available in bindings, but are not part of the binding context object:</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
