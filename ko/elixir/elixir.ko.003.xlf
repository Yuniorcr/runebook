<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="f8c0e8ae95524397c8a10deff38a828266588e66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:metadata&lt;/code&gt; - the metadata to be printed by &lt;code&gt;$metadata&lt;/code&gt;. Defaults to an empty list (no metadata). Setting &lt;code&gt;:metadata&lt;/code&gt; to &lt;code&gt;:all&lt;/code&gt; prints all metadata. See the &quot;Metadata&quot; section for more information.</source>
          <target state="translated">&lt;code&gt;:metadata&lt;/code&gt; - &lt;code&gt;$metadata&lt;/code&gt; 의해 인쇄 될 메타 데이터 . 기본적으로 빈 목록 (메타 데이터 없음)입니다. &lt;code&gt;:metadata&lt;/code&gt; 를 &lt;code&gt;:all&lt;/code&gt; 로 설정 하면 모든 메타 데이터가 인쇄됩니다. 자세한 내용은 &quot;메타 데이터&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4226f062e7d1ef7200c84fbb24a73070b2503346" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:metadata&lt;/code&gt; - the metadata to include in that backend</source>
          <target state="translated">&lt;code&gt;:metadata&lt;/code&gt; - 해당 백엔드에 포함 할 메타 데이터</target>
        </trans-unit>
        <trans-unit id="0dd254815bbc61d41ceac9cf399bee96bce92c84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:mixed&lt;/code&gt; - allows mixed case characters</source>
          <target state="translated">&lt;code&gt;:mixed&lt;/code&gt; - 대소 문자 혼합 가능</target>
        </trans-unit>
        <trans-unit id="034a02a2f75fdec584b2557986417d5297d5c51a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:module&lt;/code&gt; - an atom which is the module where the function is defined when anonymous or the module which the function refers to when it's a named function.</source>
          <target state="translated">&lt;code&gt;:module&lt;/code&gt; module-익명 일 때 함수가 정의 된 모듈 또는 이름 지정된 함수일 때 함수가 참조하는 모듈 인 원자입니다.</target>
        </trans-unit>
        <trans-unit id="03afe92f92a850066369ecbeec077fb8c8730935" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:module&lt;/code&gt; - filters out any results not pertaining to the given module</source>
          <target state="translated">&lt;code&gt;:module&lt;/code&gt; module-주어진 모듈과 관련이없는 결과를 걸러냅니다.</target>
        </trans-unit>
        <trans-unit id="e73e68fdc5f4b5f45f5d525de21b134f3514b74b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:module&lt;/code&gt; - the current module</source>
          <target state="translated">&lt;code&gt;:module&lt;/code&gt; - 현재 모듈</target>
        </trans-unit>
        <trans-unit id="44a3a462ffcd267c2d4f890aa1dcb1bb7578f22c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:module&lt;/code&gt; - the module atom name</source>
          <target state="translated">&lt;code&gt;:module&lt;/code&gt; - 모듈 아톰 이름</target>
        </trans-unit>
        <trans-unit id="9552132b93967bd9351a85fab1e15d279d8a46db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:module&lt;/code&gt; - the module on which the test was defined</source>
          <target state="translated">&lt;code&gt;:module&lt;/code&gt; - 테스트가 정의 된 모듈</target>
        </trans-unit>
        <trans-unit id="fc6879076b19a627a0380a04c7a0d2d546631516" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:module&lt;/code&gt; - the protocol module atom name</source>
          <target state="translated">&lt;code&gt;:module&lt;/code&gt; - 프로토콜 모듈 아톰 이름</target>
        </trans-unit>
        <trans-unit id="8b13174d9aff6adff24ee44d0e9d07b2214e3c67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:module&lt;/code&gt; - the test module</source>
          <target state="translated">&lt;code&gt;:module&lt;/code&gt; - 테스트 모듈</target>
        </trans-unit>
        <trans-unit id="2d3cb635d826e6e2f42e31d395df5bc5b08374a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:module_load_timeout&lt;/code&gt; - the timeout to be used when loading a test module in milliseconds, defaults to &lt;code&gt;60_000&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;:module_load_timeout&lt;/code&gt; - 테스트 모듈을 밀리 초 단위로로드 할 때 사용되는 시간 초과, 기본값은 &lt;code&gt;60_000&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="d4de44ef4c35d06879a3ced99558869a7eb86898" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:modules&lt;/code&gt; - it should be a list with one element &lt;code&gt;[module]&lt;/code&gt;, where module is the name of the callback module only if the child process is a &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;; if the child process is a &lt;a href=&quot;genevent&quot;&gt;&lt;code&gt;GenEvent&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;:modules&lt;/code&gt; should be &lt;code&gt;:dynamic&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:modules&lt;/code&gt; &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 하나의 요소 &lt;code&gt;[module]&lt;/code&gt; 이있는 목록이어야합니다. 여기서 module은 자식 프로세스가 &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 또는 GenServer 인 경우에만 콜백 모듈의 이름입니다 . 자식 프로세스가 &lt;a href=&quot;genevent&quot;&gt; &lt;code&gt;GenEvent&lt;/code&gt; 인&lt;/a&gt; 경우 &lt;code&gt;:modules&lt;/code&gt; 는 &lt;code&gt;:dynamic&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b46c49197edb9f631c7197843c5072be7a2e97cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:monotonic&lt;/code&gt; - the returned integer is monotonically increasing. This means that, on the same runtime instance (but even on different processes), integers returned using the &lt;code&gt;:monotonic&lt;/code&gt; modifier will always be strictly less than integers returned by successive calls with the &lt;code&gt;:monotonic&lt;/code&gt; modifier.</source>
          <target state="translated">&lt;code&gt;:monotonic&lt;/code&gt; - 리턴 된 정수가 단조 증가합니다. 같은 런타임 인스턴스 (그러나 심지어 다른 프로세스에), 정수가 사용하는 반환,이 수단 &lt;code&gt;:monotonic&lt;/code&gt; 수정은 항상로 연속적인 호출에 의해 반환되는 정수보다 엄격하게 적을 것이다 &lt;code&gt;:monotonic&lt;/code&gt; 수정.</target>
        </trans-unit>
        <trans-unit id="fe1bf16ea612e21f7ed9d11d89e86df957666d8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:name&lt;/code&gt; - (atom) the name of the function.</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; - (아톰) 함수의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="50c8b0d3195f9dcf65699cef76043138713e0e27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:name&lt;/code&gt; - a name to register the supervisor process. Supported values are explained in the &quot;Name registration&quot; section in the documentation for &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Optional.</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; name-감독자 프로세스를 등록 할 이름입니다. 지원되는 값은 &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 문서의 &quot;이름 등록&quot;섹션에 설명되어 있습니다 . 선택 과목.</target>
        </trans-unit>
        <trans-unit id="16f8eb524605e91d50e6381d13c1fec381bf9af1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:name&lt;/code&gt; - the name of the generated escript. Defaults to app name.</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; name-생성 된 escript의 이름입니다. 앱 이름이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="2600c278c31a1e1c8298e6e701956a29855af335" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:name&lt;/code&gt; - the name of the registry and its tables</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; name-레지스트리 및 테이블 이름</target>
        </trans-unit>
        <trans-unit id="128744a3dca6488c56f9f75cfe18ae9e4336a316" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:name&lt;/code&gt; - the test case name</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; - 테스트 케이스 이름</target>
        </trans-unit>
        <trans-unit id="c3eb020586c1e91919b1e11fc875e674f851d758" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:name&lt;/code&gt; - the test name</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; - 테스트 이름</target>
        </trans-unit>
        <trans-unit id="01a18172e153ec90bcdbca66d6e84c34c3288cc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:name&lt;/code&gt; - used for name registration as described in the &quot;Name registration&quot; section in the documentation for &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; - &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 문서의 &quot;이름 등록&quot;섹션에 설명 된 이름 등록에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d74908d7eb54c999a9bfde3e2955191d78ff9678" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:name&lt;/code&gt; - used to register a supervisor name, the supported values are described under the &lt;code&gt;Name Registration&lt;/code&gt; section in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module docs;</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 감독자 이름을 등록하는 데 사용되며 지원되는 값은 GenServer 모듈 문서 의 &lt;code&gt;Name Registration&lt;/code&gt; 섹션에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="acfd8be1ce758b3026bf57dff69111e7fcd5a8ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:new_index&lt;/code&gt; - (integer) an index into the module function table.</source>
          <target state="translated">&lt;code&gt;:new_index&lt;/code&gt; - 모듈 함수 테이블에 대한 인덱스 (정수)입니다.</target>
        </trans-unit>
        <trans-unit id="161c527608bad21ffff501946a03419dfc142531" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:new_uniq&lt;/code&gt; - (binary) a unique value for this function. It's calculated from the compiled code for the entire module.</source>
          <target state="translated">&lt;code&gt;:new_uniq&lt;/code&gt; - 이 함수의 고유 한 값입니다. 전체 모듈에 대해 컴파일 된 코드에서 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="1f6fea81bc1e0f6b5eff26c026b0aee54699962a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:nfc&lt;/code&gt; - Normalization Form Canonical Composition. Characters are decomposed and then recomposed by canonical equivalence.</source>
          <target state="translated">&lt;code&gt;:nfc&lt;/code&gt; - 정규화 형식 정식 구성. 문자는 분해 된 후 정식 동등성으로 재구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7045d14e5dbaf635ddb7e2ebbfa3e40fdcbb6c40" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:nfd&lt;/code&gt; - Normalization Form Canonical Decomposition. Characters are decomposed by canonical equivalence, and multiple combining characters are arranged in a specific order.</source>
          <target state="translated">&lt;code&gt;:nfd&lt;/code&gt; - 정규화 형식 정식 분해. 문자는 정식 등가로 분해되고 여러 결합 문자가 특정 순서로 배열됩니다.</target>
        </trans-unit>
        <trans-unit id="4aa6af82b34423b1f6ea582b4cb31c825940854b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:noconnect&lt;/code&gt; - when used, if sending the message would require an auto-connection to another node the message is not sent and &lt;code&gt;:noconnect&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;:noconnect&lt;/code&gt; - 메시지를 보낼 때 다른 노드에 자동 연결해야하는 경우 메시지가 전송되지 않고 &lt;code&gt;:noconnect&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8e039a3b05df1dbc0406ab8f52dd05fb5a8365cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:none&lt;/code&gt; - does not return matching subpatterns at all</source>
          <target state="translated">&lt;code&gt;:none&lt;/code&gt; -일치하는 하위 패턴을 전혀 반환하지 않습니다</target>
        </trans-unit>
        <trans-unit id="e05cd3cd1ea9b5187e61dc703681711120bf8926" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:none&lt;/code&gt; - if there is no translation, which triggers the next translator</source>
          <target state="translated">&lt;code&gt;:none&lt;/code&gt; -번역이없는 경우 다음 번역기를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="249a47ff9128b780dd1578c5de067a02d8afb0dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:normal&lt;/code&gt; - in such cases, the exit won't be logged, there is no restart in transient mode, and linked processes do not exit</source>
          <target state="translated">&lt;code&gt;:normal&lt;/code&gt; -이러한 경우 종료가 기록되지 않고 일시적 모드에서 다시 시작되지 않으며 링크 된 프로세스가 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf16a0cb151458c4bbe810828ac70da7a9c6b053" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:normal&lt;/code&gt; - used if the startup is a normal startup or if the application is distributed and is started on the current node because of a failover from another node and the application specification key &lt;code&gt;:start_phases&lt;/code&gt; is &lt;code&gt;:undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:normal&lt;/code&gt; &lt;code&gt;:start_phases&lt;/code&gt; 시작이 정상 시작이거나 다른 노드의 장애 조치로 인해 응용 프로그램이 배포되어 현재 노드에서 시작되고 응용 프로그램 사양 키 : start_phases 가 &lt;code&gt;:undefined&lt;/code&gt; 인 경우에 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="0108614a94cf717462c8a940ce89f65176962e19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:nosuspend&lt;/code&gt; - when used, if sending the message would cause the sender to be suspended the message is not sent and &lt;code&gt;:nosuspend&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;:nosuspend&lt;/code&gt; - 사용될 때, 메시지를 보낼 때 발신자가 일시 중단되는 경우 메시지가 전송되지 않고 &lt;code&gt;:nosuspend&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9d697c6fad7644d5c44cc03beb2cdf09f070f143" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:on&lt;/code&gt; - specifies which captures to split the string on, and in what order. Defaults to &lt;code&gt;:first&lt;/code&gt; which means captures inside the regex do not affect the splitting process.</source>
          <target state="translated">&lt;code&gt;:on&lt;/code&gt; on-문자열을 분할 할 캡처를 어떤 순서로 지정합니다. 기본값은 &lt;code&gt;:first&lt;/code&gt; 입니다. 즉, 정규 표현식 내부의 캡처는 분할 프로세스에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b63ce5b92cf87aaf8196a041e1faa21397a5e1a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:on_eof&lt;/code&gt; - if it should &lt;code&gt;:stop_evaluator&lt;/code&gt; (default) or &lt;code&gt;:halt&lt;/code&gt; the system</source>
          <target state="translated">&lt;code&gt;:on_eof&lt;/code&gt; - 필요한 경우 &lt;code&gt;:stop_evaluator&lt;/code&gt; (기본값) 또는 &lt;code&gt;:halt&lt;/code&gt; 시스템 중지</target>
        </trans-unit>
        <trans-unit id="d548253b9f1938f29a8cd30c79d0668b2da0b00f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:on_timeout&lt;/code&gt; - what do to when a task times out. The possible values are:</source>
          <target state="translated">&lt;code&gt;:on_timeout&lt;/code&gt; - 작업 시간이 초과 될 때 수행 할 작업 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="967f2648d4361145dec902214164deca8962ea9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:on_timeout&lt;/code&gt; - what to do when a task times out. The possible values are:</source>
          <target state="translated">&lt;code&gt;:on_timeout&lt;/code&gt; - 작업이 시간 초과 될 때 수행 할 작업 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c005f28aee9fbfc4e81dfedffe4486f2021c9fd7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:one_for_all&lt;/code&gt; - if a child process terminates, all other child processes are terminated and then all child processes (including the terminated one) are restarted.</source>
          <target state="translated">&lt;code&gt;:one_for_all&lt;/code&gt; - 하위 프로세스가 종료되면 다른 모든 하위 프로세스가 종료 된 후 종료 된 프로세스를 포함한 모든 하위 프로세스가 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="0336c9bdb63340074782b8de5a2753c895868b6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:one_for_one&lt;/code&gt; - if a child process terminates, only that process is restarted.</source>
          <target state="translated">&lt;code&gt;:one_for_one&lt;/code&gt; - 하위 프로세스가 종료되면 해당 프로세스 만 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="49745e56745dd2d278e647db8397f06e8ac4651a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:only&lt;/code&gt; - the dependency is made available only in the given environments, useful when declaring dev- or test-only dependencies; by default the dependency will be available in all environments. The value of this option can either be a single environment (like &lt;code&gt;:dev&lt;/code&gt;) or a list of environments (like &lt;code&gt;[:dev, :test]&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;:only&lt;/code&gt; only-지정된 환경에서만 종속성을 사용할 수 있으며 개발자 전용 또는 테스트 전용 종속성을 선언 할 때 유용합니다. 기본적으로 모든 환경에서 종속성을 사용할 수 있습니다. 이 옵션의 값은 단일 환경 ( &lt;code&gt;:dev&lt;/code&gt; 등 ) 또는 환경 목록 ( &lt;code&gt;[:dev, :test]&lt;/code&gt; ) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4a49a5b1a71967998498e4f9c663e9db62e642a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:only_operators&lt;/code&gt; - includes only operators</source>
          <target state="translated">&lt;code&gt;:only_operators&lt;/code&gt; - 연산자 만 포함</target>
        </trans-unit>
        <trans-unit id="89ac265643029bb4e9eb87a3a1eb43a83ac0e877" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:only_test_ids&lt;/code&gt; - a list of &lt;code&gt;{module_name, test_name}&lt;/code&gt; tuples that limits what tests get run;</source>
          <target state="translated">&lt;code&gt;:only_test_ids&lt;/code&gt; - 실행할 테스트를 제한하는 &lt;code&gt;{module_name, test_name}&lt;/code&gt; 튜플 의 목록 .</target>
        </trans-unit>
        <trans-unit id="63e34ca0c4f83325812704dbfa01fc6f74cf793a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:opt_release&lt;/code&gt; - OTP release it was compiled with</source>
          <target state="translated">&lt;code&gt;:opt_release&lt;/code&gt; -OTP 릴리스로 컴파일되었습니다.</target>
        </trans-unit>
        <trans-unit id="759987ebbfa09610ba0e7f6e23e613bfab1fb35f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:optional&lt;/code&gt; - marks the dependency as optional. In such cases, the current project will always include the optional dependency but any other project that depends on the current project won't be forced to use the optional dependency. However, if the other project includes the optional dependency on its own, the requirements and options specified here will also be applied.</source>
          <target state="translated">&lt;code&gt;:optional&lt;/code&gt; -종속성을 선택 사항으로 표시합니다. 이러한 경우 현재 프로젝트에는 항상 선택적 종속성이 포함되지만 현재 프로젝트에 의존하는 다른 프로젝트는 선택적 종속성을 사용하지 않습니다. 그러나 다른 프로젝트가 자체적으로 선택적 종속성을 포함하는 경우 여기에 지정된 요구 사항 및 옵션도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa75a186c5e0b6e3cd756723da44fdbe7c72a94a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:ordered&lt;/code&gt; - whether the results should be returned in the same order as the input stream. This option is useful when you have large streams and don't want to buffer results before they are delivered. This is also useful when you're using the tasks for side effects. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:ordered&lt;/code&gt; - 입력 스트림과 동일한 순서로 결과를 반환해야하는지 여부입니다. 이 옵션은 스트림이 많고 결과가 전달되기 전에 버퍼링하지 않으려는 경우에 유용합니다. 부작용에 대한 작업을 사용할 때도 유용합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="109bd51b27eae75e1fd5751b4effad28d8d6894c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:output&lt;/code&gt; - the output directory for cover results. Defaults to &lt;code&gt;&quot;cover&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:output&lt;/code&gt; - 표지 결과의 출력 디렉토리입니다. &lt;code&gt;&quot;cover&quot;&lt;/code&gt; 기본 설정</target>
        </trans-unit>
        <trans-unit id="dae0f0ed816b6755246a3425d7e89c8cbe1617c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:override&lt;/code&gt; - if set to &lt;code&gt;true&lt;/code&gt; the dependency will override any other definitions of itself by other dependencies</source>
          <target state="translated">&lt;code&gt;:override&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; 로 설정 하면 종속성이 다른 종속성에 의해 다른 자체 정의를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="ee21d75db571092b33f3c6e04150d8d96d12186b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:owner&lt;/code&gt; - the PID of the process that started the task</source>
          <target state="translated">&lt;code&gt;:owner&lt;/code&gt; - 작업을 시작한 프로세스의 PID</target>
        </trans-unit>
        <trans-unit id="c871b777e9d6dc410ad77517a57eb10ea04f208d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:padding&lt;/code&gt; - specifies whether to apply padding</source>
          <target state="translated">&lt;code&gt;:padding&lt;/code&gt; -패딩 적용 여부를 지정합니다</target>
        </trans-unit>
        <trans-unit id="05b6bc5dd9b9c177e298ed308bd0312e9879c46e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:padding&lt;/code&gt; - specifies whether to require padding</source>
          <target state="translated">&lt;code&gt;:padding&lt;/code&gt; -패딩이 필요한지 여부를 지정합니다</target>
        </trans-unit>
        <trans-unit id="7e85cd35375539c186e4ef217380868547a2f1d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:parallelism&lt;/code&gt; - when &lt;code&gt;true&lt;/code&gt;, the VM will schedule port tasks to improve parallelism in the system. If set to &lt;code&gt;false&lt;/code&gt;, the VM will try to perform commands immediately, improving latency at the expense of parallelism. The default can be set on system startup by passing the &quot;+spp&quot; argument to &lt;code&gt;--erl&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:parallelism&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; 이면 VM은 시스템의 병렬 처리를 향상시키기 위해 포트 작업을 예약합니다. &lt;code&gt;false&lt;/code&gt; 로 설정 되면 VM은 명령을 즉시 수행하려고 시도하여 병렬 처리를 대신하여 대기 시간을 개선합니다. &quot;+ spp&quot;인수를 &lt;code&gt;--erl&lt;/code&gt; 에 전달하여 시스템 시작시 기본값을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="102eba9adcb8ff5954a857f9e93f446ec880188e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:parents&lt;/code&gt; - starts the dependency traversal from the given parents instead of the application root</source>
          <target state="translated">&lt;code&gt;:parents&lt;/code&gt; parents-응용 프로그램 루트 대신 지정된 부모로부터 종속성 통과를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="3623e6b3ee4e48790eba50c01efff6e8f6ad8dc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:partitions&lt;/code&gt; - the number of partitions in the registry. Defaults to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:partitions&lt;/code&gt; - 레지스트리의 파티션 수 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fbe591931e54f52a5cb6243fb366662ce3c9e43a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:parts&lt;/code&gt; (positive integer or &lt;code&gt;:infinity&lt;/code&gt;) - the string is split into at most as many parts as this option specifies. If &lt;code&gt;:infinity&lt;/code&gt;, the string will be split into all possible parts. Defaults to &lt;code&gt;:infinity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:parts&lt;/code&gt; (양의 정수 또는 &lt;code&gt;:infinity&lt;/code&gt; )-문자열은이 옵션이 지정하는 최대 부분으로 분할됩니다. 경우 &lt;code&gt;:infinity&lt;/code&gt; , 문자열은 모든 가능한 부분으로 분할됩니다. 기본값은 &lt;code&gt;:infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="738e4711d24c22556e9769f827fc877a333c3ec9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:parts&lt;/code&gt; - when specified, splits the string into the given number of parts. If not specified, &lt;code&gt;:parts&lt;/code&gt; defaults to &lt;code&gt;:infinity&lt;/code&gt;, which will split the string into the maximum number of parts possible based on the given pattern.</source>
          <target state="translated">&lt;code&gt;:parts&lt;/code&gt; parts-지정된 경우 문자열을 지정된 수의 부분으로 나눕니다. 지정되지 않은 경우 &lt;code&gt;:parts&lt;/code&gt; 의 기본값은 &lt;code&gt;:infinity&lt;/code&gt; 로 , 지정된 패턴에 따라 문자열을 가능한 최대 부분 수로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="f8406b284a5d9f169d7ef202053625ca78690289" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:path&lt;/code&gt; - the path for the dependency</source>
          <target state="translated">&lt;code&gt;:path&lt;/code&gt; - 종속성의 경로</target>
        </trans-unit>
        <trans-unit id="b56c1cc4784009d5aadab5d03f37af62be889258" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:path&lt;/code&gt; - the path to write the escript to. Defaults to app name.</source>
          <target state="translated">&lt;code&gt;:path&lt;/code&gt; -escript를 쓸 경로입니다. 앱 이름이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="37ef1282fca65e1ae92072e62b8991b4072fcb4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:permanent&lt;/code&gt; - if &lt;code&gt;app&lt;/code&gt; terminates, all other applications and the entire node are also terminated.</source>
          <target state="translated">&lt;code&gt;:permanent&lt;/code&gt; - 경우 &lt;code&gt;app&lt;/code&gt; 종료, 다른 모든 응용 프로그램 및 전체 노드도 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="8173b1a9fdd8413821b53ff0d59ff5ae7d56eec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:permanent&lt;/code&gt; - the child process is always restarted</source>
          <target state="translated">&lt;code&gt;:permanent&lt;/code&gt; -자식 프로세스는 항상 다시 시작됩니다</target>
        </trans-unit>
        <trans-unit id="234321a1e7ed8d159948d60118f2b6f61e82c18f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:permanent&lt;/code&gt; - the child process is always restarted.</source>
          <target state="translated">&lt;code&gt;:permanent&lt;/code&gt; - 자식 프로세스가 항상 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="5af1c24ccb0c6eacd3bee795d8a1eb3bffe04c6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:persist&lt;/code&gt; - the attribute will be persisted in the Erlang Abstract Format. Useful when interfacing with Erlang libraries.</source>
          <target state="translated">&lt;code&gt;:persist&lt;/code&gt; - 속성이 Erlang 추상 형식으로 유지됩니다. Erlang 라이브러리와 인터페이스 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="95c886b860026fac40b14994cc8c7589bc9d5579" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:persistent&lt;/code&gt; - persists the given value on application load and reloads</source>
          <target state="translated">&lt;code&gt;:persistent&lt;/code&gt; - 응용 프로그램로드 및 재로드시 지정된 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="c1e21c7b8be8dd8f64aa4684e89339f074ceea00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:pid&lt;/code&gt; - PID of the process that originally created the function.</source>
          <target state="translated">&lt;code&gt;:pid&lt;/code&gt; - 원래 함수를 만든 프로세스의 PID</target>
        </trans-unit>
        <trans-unit id="6fdd59eeb918211220a78f33fe0ea77139aabb39" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:pid&lt;/code&gt; - the PID of the task process; &lt;code&gt;nil&lt;/code&gt; if the task does not use a task process</source>
          <target state="translated">&lt;code&gt;:pid&lt;/code&gt; - 작업 프로세스의 PID; 작업이 작업 프로세스를 사용하지 않으면 &lt;code&gt;nil&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="89fc2eba42a25521afbb74432f41643f75e1cb86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:pid&lt;/code&gt; - the current process identifier</source>
          <target state="translated">&lt;code&gt;:pid&lt;/code&gt; - 현재 프로세스 식별자</target>
        </trans-unit>
        <trans-unit id="b5003a88b1f32f3ca59143861dd60c14442ca836" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:pop&lt;/code&gt;, which implies that the current value under &lt;code&gt;key&lt;/code&gt; should be removed from the structure and returned.</source>
          <target state="translated">&lt;code&gt;:pop&lt;/code&gt; 은 &lt;code&gt;key&lt;/code&gt; 아래의 현재 값을 구조에서 제거하여 반환해야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="c23ced478543f9465b4975d50e6ad67db0bc29fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:positive&lt;/code&gt; - the returned integer is guaranteed to be positive.</source>
          <target state="translated">&lt;code&gt;:positive&lt;/code&gt; - 반환 된 정수가 양수임을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="b7eca98f205a2eb6fa4afcfa1aaf0a99d46382c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:posix&lt;/code&gt; - returns the time as integer seconds since epoch</source>
          <target state="translated">&lt;code&gt;:posix&lt;/code&gt; - 에포크 이후의 시간을 정수 초로 반환합니다</target>
        </trans-unit>
        <trans-unit id="ea02bc9a384e4edfcb6c2cc741dc4786b967cbd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:preferred_cli_env&lt;/code&gt; - a keyword list of &lt;code&gt;{task, env}&lt;/code&gt; tuples where &lt;code&gt;task&lt;/code&gt; is the task name as an atom (for example, &lt;code&gt;:&quot;deps.get&quot;&lt;/code&gt;) and &lt;code&gt;env&lt;/code&gt; is the preferred environment (for example, &lt;code&gt;:test&lt;/code&gt;). This option overrides what is specified by the tasks with the &lt;code&gt;@preferred_cli_env&lt;/code&gt; attribute (see the docs for &lt;a href=&quot;mix.task&quot;&gt;&lt;code&gt;Mix.Task&lt;/code&gt;&lt;/a&gt;). Defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:preferred_cli_env&lt;/code&gt; - &lt;code&gt;{task, env}&lt;/code&gt; 튜플 의 키워드 목록입니다. 여기서 &lt;code&gt;task&lt;/code&gt; 는 원자 이름으로 작업 이름이고 (예 &lt;code&gt;:&quot;deps.get&quot;&lt;/code&gt; ) &lt;code&gt;env&lt;/code&gt; 는 선호되는 환경 (예 &lt;code&gt;:test&lt;/code&gt; )입니다. 와 작업에 지정된 것을이 옵션은 무시 &lt;code&gt;@preferred_cli_env&lt;/code&gt; 의 속성 (대한 문서 참조 &lt;a href=&quot;mix.task&quot;&gt; &lt;code&gt;Mix.Task&lt;/code&gt; 을&lt;/a&gt; ). 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ae71f650b5c3ff499f225d9db2c4ded70c2ae8af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:preferred_cli_target&lt;/code&gt; - a keyword list of &lt;code&gt;{task, target}&lt;/code&gt; tuples where &lt;code&gt;task&lt;/code&gt; is the task name as an atom (for example, &lt;code&gt;:test&lt;/code&gt;) and &lt;code&gt;target&lt;/code&gt; is the preferred target (for example, &lt;code&gt;:host&lt;/code&gt;). Defaults to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:preferred_cli_target&lt;/code&gt; - &lt;code&gt;{task, target}&lt;/code&gt; 튜플 의 키워드 목록입니다. 여기서 &lt;code&gt;task&lt;/code&gt; 는 원자 이름 인 작업 이름 (예 &lt;code&gt;:test&lt;/code&gt; )이고 &lt;code&gt;target&lt;/code&gt; 은 선호되는 대상 (예 &lt;code&gt;:host&lt;/code&gt; )입니다. 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="144b18390df45b9e362d37e94ce800c0b5df1bba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:prefix&lt;/code&gt; - the IEx prefix</source>
          <target state="translated">&lt;code&gt;:prefix&lt;/code&gt; -IEx 접두사</target>
        </trans-unit>
        <trans-unit id="825668baf0806b14b62d6651ff422468cea677d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:pretty&lt;/code&gt; - if set to &lt;code&gt;true&lt;/code&gt; enables pretty printing, defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:pretty&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; 로 설정 하면 예쁜 인쇄가 가능하고 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8601a8e7eca3b625cc8cb07702803a2fe0b6855d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:printable&lt;/code&gt; - the string is split into chunks of printable and non-printable character sequences</source>
          <target state="translated">&lt;code&gt;:printable&lt;/code&gt; - 문자열이 인쇄 가능 및 인쇄 불가능 문자 시퀀스로 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="79f3790d5f2a7ff6e99ae9f98dc69012ae7abae7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:printable_limit&lt;/code&gt; - limits the number of characters that are inspected on printable strings and printable charlists. You can use &lt;a href=&quot;string#printable?/1&quot;&gt;&lt;code&gt;String.printable?/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;list#ascii_printable?/1&quot;&gt;&lt;code&gt;List.ascii_printable?/1&lt;/code&gt;&lt;/a&gt; to check if a given string or charlist is printable. Defaults to 4096. If you don't want to limit the number of characters to a particular number, use &lt;code&gt;:infinity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:printable_limit&lt;/code&gt; -인쇄 가능한 문자열 및 인쇄 가능한 문자 목록에서 검사되는 문자 수를 제한합니다. 당신은 사용할 수 있습니다 &lt;a href=&quot;string#printable?/1&quot;&gt; &lt;code&gt;String.printable?/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;list#ascii_printable?/1&quot;&gt; &lt;code&gt;List.ascii_printable?/1&lt;/code&gt; &lt;/a&gt; 주어진 문자열이나 charlist가 인쇄인지 확인합니다. 기본값은 4096입니다. 문자 수를 특정 숫자로 제한하지 않으려면 &lt;code&gt;:infinity&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="410adb09a6ecf7e6416cfacc8be4f6d5ae1a9cb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:prod&lt;/code&gt; - the environment your dependencies run on</source>
          <target state="translated">&lt;code&gt;:prod&lt;/code&gt; - 종속성이 실행되는 환경</target>
        </trans-unit>
        <trans-unit id="7a4f54da6e36123b2d0abcd43ec7c9b1ec1bb3a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:prod&lt;/code&gt; - the one you will use to run your project in production</source>
          <target state="translated">&lt;code&gt;:prod&lt;/code&gt; - 프로덕션에서 프로젝트를 실행하는 데 사용할 것</target>
        </trans-unit>
        <trans-unit id="e2b4fb1538eb0b3321b10395f6eeb08b1757f804" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:prune_metadata&lt;/code&gt; - when true, removes metadata from escaped AST nodes. Note this option changes the semantics of escaped code and it should only be used when escaping ASTs, never values. Defaults to false.</source>
          <target state="translated">&lt;code&gt;:prune_metadata&lt;/code&gt; -true 인 경우 이스케이프 된 AST 노드에서 메타 데이터를 제거합니다. 이 옵션은 이스케이프 된 코드의 의미를 변경하며 값을 절대로 사용하지 않고 AST를 이스케이프 할 때만 사용해야합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="6bfc26e873b6c092ea866965157d01fa76cb5ee3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:raw&lt;/code&gt; - a single atom to bypass the file server and only check for the file locally</source>
          <target state="translated">&lt;code&gt;:raw&lt;/code&gt; - 파일 서버를 우회하고 로컬에서만 파일을 확인하는 단일 아톰</target>
        </trans-unit>
        <trans-unit id="837ead4ba27d5e026c9a07708c1e9ca692ba17c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:read&lt;/code&gt; - the file, which must exist, is opened for reading.</source>
          <target state="translated">&lt;code&gt;:read&lt;/code&gt; - 존재해야하는 파일을 읽기 위해 열립니다.</target>
        </trans-unit>
        <trans-unit id="41f2b24882408cbe66a5f9e787bb34bbad9bb826" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:ref&lt;/code&gt; - the reference to checkout (may be a branch, a commit SHA or a tag)</source>
          <target state="translated">&lt;code&gt;:ref&lt;/code&gt; - 체크 아웃에 대한 참조 (브랜치, 커밋 SHA 또는 태그 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="9d480f66df0057bb82616e58781811e154a72adc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:ref&lt;/code&gt; - the task monitor reference</source>
          <target state="translated">&lt;code&gt;:ref&lt;/code&gt; - 작업 모니터 참조</target>
        </trans-unit>
        <trans-unit id="417480cff77826d3dfc29a2ea00d2a119bdc3ade" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:refute_receive_timeout&lt;/code&gt; - the timeout to be used on &lt;code&gt;refute_receive&lt;/code&gt; calls in milliseconds, defaults to &lt;code&gt;100&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;:refute_receive_timeout&lt;/code&gt; - &lt;code&gt;refute_receive&lt;/code&gt; 호출에 사용되는 시간 초과 ( 밀리 초)이며 기본값은 &lt;code&gt;100&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="229b5c7ed45f45fed3bc29a08eb916ef712f16c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:registered&lt;/code&gt; - used for &lt;a href=&quot;exunit.case#register_attribute/3&quot;&gt;&lt;code&gt;ExUnit.Case.register_attribute/3&lt;/code&gt;&lt;/a&gt; values</source>
          <target state="translated">&lt;code&gt;:registered&lt;/code&gt; - &lt;a href=&quot;exunit.case#register_attribute/3&quot;&gt; &lt;code&gt;ExUnit.Case.register_attribute/3&lt;/code&gt; &lt;/a&gt; 값에 사용</target>
        </trans-unit>
        <trans-unit id="76107f04b252aa2d494b9f3ac57d2e536b8f063b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:registered_name&lt;/code&gt; - the process registered name as an atom</source>
          <target state="translated">&lt;code&gt;:registered_name&lt;/code&gt; - 프로세스 등록 된 이름을 아톰으로</target>
        </trans-unit>
        <trans-unit id="06becb331a4b35f5874f87f1f273eb1acc1b1ccd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:relative_paths&lt;/code&gt; - when &lt;code&gt;true&lt;/code&gt;, use relative paths in quoted nodes, warnings and errors generated by the compiler. Note disabling this option won't affect runtime warnings and errors. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:relative_paths&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; 인 경우 인용 노드의 상대 경로, 컴파일러가 생성 한 경고 및 오류를 사용합니다. 이 옵션을 비활성화해도 런타임 경고 및 오류에는 영향을 미치지 않습니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3c9b9529236ac69920375f4608006430e5e82f28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:rename_deprecated_at&lt;/code&gt; - rename all known deprecated functions at the given version to their non-deprecated equivalent. It expects a valid &lt;a href=&quot;version&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; which is usually the minimum Elixir version supported by the project.</source>
          <target state="translated">&lt;code&gt;:rename_deprecated_at&lt;/code&gt; - 지정된 버전에서 알려진 더 이상 사용되지 않는 함수의 이름을 더 이상 사용되지 않는 기능으로 바꿉니다. 일반적으로 프로젝트에서 지원하는 최소 Elixir 버전 인 유효한 &lt;a href=&quot;version&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt; 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a041a0b82d4d647034a3e36bbcb3cd58280dd271" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:requires&lt;/code&gt; - a list of modules required</source>
          <target state="translated">&lt;code&gt;:requires&lt;/code&gt; 필수-필요한 모듈 목록</target>
        </trans-unit>
        <trans-unit id="94cf107e8f2ec96f62b5bcda4ba38f57ecdf19f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:rest_for_one&lt;/code&gt; - if a child process terminates, the terminated child process and the rest of the children started after it, are terminated and restarted.</source>
          <target state="translated">&lt;code&gt;:rest_for_one&lt;/code&gt; - 하위 프로세스가 종료되면 종료 된 하위 프로세스와 그 이후에 시작된 나머지 하위 프로세스가 종료되고 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="68e05441de900538fe9477d909c390fedde76193" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:restart&lt;/code&gt; - an atom that defines when a terminated child process should be restarted (see the &quot;Restart values&quot; section below)</source>
          <target state="translated">&lt;code&gt;:restart&lt;/code&gt; - 종료 된 하위 프로세스를 다시 시작해야하는시기를 정의하는 아톰 (아래의 &quot;값 다시 시작&quot;섹션 참조)</target>
        </trans-unit>
        <trans-unit id="c3f56495278d055220a28af1dee51e5d16162127" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:restart&lt;/code&gt; - an atom that defines when a terminated child process should be restarted (see the &quot;Restart values&quot; section below). This key is optional and defaults to &lt;code&gt;:permanent&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:restart&lt;/code&gt; - 종료 된 하위 프로세스를 언제 다시 시작해야하는지 정의하는 원자입니다 (아래의 &quot;값 다시 시작&quot;섹션 참조). 이 키는 선택 사항이며 기본값은 &lt;code&gt;:permanent&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="31df30af299f360d0ce36c8750e7fac18dea49e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:restart&lt;/code&gt; - the restart strategy, may be &lt;code&gt;:temporary&lt;/code&gt; (the default), &lt;code&gt;:transient&lt;/code&gt; or &lt;code&gt;:permanent&lt;/code&gt;. &lt;code&gt;:temporary&lt;/code&gt; means the task is never restarted, &lt;code&gt;:transient&lt;/code&gt; means it is restarted if the exit is not &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt; or &lt;code&gt;{:shutdown, reason}&lt;/code&gt;. A &lt;code&gt;:permanent&lt;/code&gt; restart strategy means it is always restarted. It defaults to &lt;code&gt;:temporary&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:restart&lt;/code&gt; - 재시작 전략은 &lt;code&gt;:temporary&lt;/code&gt; (기본값), &lt;code&gt;:transient&lt;/code&gt; 또는 &lt;code&gt;:permanent&lt;/code&gt; 일 수 있습니다. &lt;code&gt;:temporary&lt;/code&gt; 는 태스크가 다시 시작되지 않음을 의미합니다 &lt;code&gt;:transient&lt;/code&gt; 는 종료가 &lt;code&gt;:normal&lt;/code&gt; , &lt;code&gt;:shutdown&lt;/code&gt; 또는 &lt;code&gt;{:shutdown, reason}&lt;/code&gt; 이 아닌 경우 다시 시작됨을 의미합니다 . &lt;code&gt;:permanent&lt;/code&gt; 재시작 전략은 항상 다시 시작을 의미합니다. 기본값은 &lt;code&gt;:temporary&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d94868512153cae048d95355b79448372cfe504b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:restart&lt;/code&gt; - when the child should be restarted, defaults to &lt;code&gt;:permanent&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:restart&lt;/code&gt; - 자식을 다시 시작해야 할 때 기본값은 &lt;code&gt;:permanent&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c63e56060e5424b4a88bbcfb341afd200f5f7897" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:restart&lt;/code&gt; - when the child should be restarted, defaults to &lt;code&gt;:temporary&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:restart&lt;/code&gt; - 자식을 다시 시작해야 할 때 기본값은 &lt;code&gt;:temporary&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6de1858d17c1b3a7b52262da84be82d05ba0d46d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:restart&lt;/code&gt; - when the supervisor should be restarted, defaults to &lt;code&gt;:permanent&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:restart&lt;/code&gt; - 수퍼바이저를 다시 시작해야하는 경우 기본값은 &lt;code&gt;:permanent&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="440372047cb7510fed08fef14217a8f597bd7289" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:return&lt;/code&gt; - set to &lt;code&gt;:index&lt;/code&gt; to return byte index and match length. Defaults to &lt;code&gt;:binary&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:return&lt;/code&gt; - 바이트 인덱스를 반환하고 길이를 일치 시키 려면 &lt;code&gt;:index&lt;/code&gt; 로 설정합니다 . 기본값은 &lt;code&gt;:binary&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="38002dbf053bffbccd100620de9a971d9751a6b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:revision&lt;/code&gt; - short Git revision hash. If Git was not available at building time, it is set to &lt;code&gt;&quot;&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:revision&lt;/code&gt; - 짧은 Git 개정 해시. 빌드 할 때 Git을 사용할 수 없으면 &lt;code&gt;&quot;&quot;&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="47ad37a4945d66cff0b511df34d8cb047955022d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:runtime&lt;/code&gt; - whether the dependency is part of runtime applications. If the &lt;code&gt;:applications&lt;/code&gt; key is not provided in &lt;code&gt;def application&lt;/code&gt; in your &lt;code&gt;mix.exs&lt;/code&gt; file, Mix will automatically include all dependencies as a runtime application, except if &lt;code&gt;runtime: false&lt;/code&gt; is given. Defaults to true.</source>
          <target state="translated">&lt;code&gt;:runtime&lt;/code&gt; - 종속성이 런타임 애플리케이션의 일부인지 여부 경우 &lt;code&gt;:applications&lt;/code&gt; 키가 제공되지 &lt;code&gt;def application&lt;/code&gt; 사용자에 &lt;code&gt;mix.exs&lt;/code&gt; 의 파일, 믹스 경우를 제외하고, 런타임 응용 프로그램으로 모든 종속성을 자동으로 포함됩니다 &lt;code&gt;runtime: false&lt;/code&gt; 주어진다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="00d27bf7444b8506e92e835fad445d9f5d17c7a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:safe&lt;/code&gt; - when &lt;code&gt;false&lt;/code&gt;, failures while inspecting structs will be raised as errors instead of being wrapped in the &lt;a href=&quot;inspect.error&quot;&gt;&lt;code&gt;Inspect.Error&lt;/code&gt;&lt;/a&gt; exception. This is useful when debugging failures and crashes for custom inspect implementations.</source>
          <target state="translated">&lt;code&gt;:safe&lt;/code&gt; - &lt;code&gt;false&lt;/code&gt; 인 경우 구조체를 검사하는 동안 실패가 &lt;a href=&quot;inspect.error&quot;&gt; &lt;code&gt;Inspect.Error&lt;/code&gt; &lt;/a&gt; 예외 에 래핑되는 대신 오류로 발생합니다 . 이는 사용자 지정 검사 구현에서 오류를 디버깅하고 충돌 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="001fb2888a3bbf8f2282716dcd9bc9e213771931" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:second&lt;/code&gt;, &lt;code&gt;:millisecond&lt;/code&gt;, etc. (v1.4)</source>
          <target state="translated">&lt;code&gt;:second&lt;/code&gt; , &lt;code&gt;:millisecond&lt;/code&gt; 등 (v1.4)</target>
        </trans-unit>
        <trans-unit id="fc20f799112d39f70e51b99fd18bdd1c1ee396e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:seconds&lt;/code&gt;, &lt;code&gt;:milliseconds&lt;/code&gt;, etc. as time units</source>
          <target state="translated">&lt;code&gt;:seconds&lt;/code&gt; 시간 단위로 : seconds , &lt;code&gt;:milliseconds&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="998c92a04eac1b1ae60c5fb46272bef007b2eaa7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:seed&lt;/code&gt; - an integer seed value to randomize the test suite. This seed is also mixed with the test module and name to create a new unique seed on every test, which is automatically fed into the &lt;code&gt;:rand&lt;/code&gt; module. This provides randomness between tests, but predictable and reproducible results;</source>
          <target state="translated">&lt;code&gt;:seed&lt;/code&gt; - 테스트 스위트를 무작위 화하기위한 정수 시드 값. 이 시드는 또한 테스트 모듈 및 이름과 혼합되어 모든 테스트에서 새로운 고유 시드를 생성하며, 자동으로 &lt;code&gt;:rand&lt;/code&gt; 모듈에 공급됩니다 . 이것은 테스트간에 임의성을 제공하지만 예측 가능하고 재현 가능한 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6f522c42e08b6faff3741f41a44a8b151be7a4ce" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:separator&lt;/code&gt; - the separator used between each doc</source>
          <target state="translated">&lt;code&gt;:separator&lt;/code&gt; - 각 문서 사이에 사용되는 구분 기호</target>
        </trans-unit>
        <trans-unit id="3df407e63d4f1dd306d22158c48447875dcd44a9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:shebang&lt;/code&gt; - shebang interpreter directive used to execute the escript. Defaults to &lt;code&gt;&quot;#! /usr/bin/env escript\n&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:shebang&lt;/code&gt; -escript를 실행하는 데 사용되는 shebang 인터프리터 지시문입니다. 기본값은 &lt;code&gt;&quot;#! /usr/bin/env escript\n&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac59fe1ea179551b1d0d56d67d2e5ba3c352a0ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:shutdown&lt;/code&gt; - &lt;code&gt;:brutal_kill&lt;/code&gt; if the tasks must be killed directly on shutdown or an integer indicating the timeout value, defaults to 5000 milliseconds.</source>
          <target state="translated">&lt;code&gt;:shutdown&lt;/code&gt; - &lt;code&gt;:brutal_kill&lt;/code&gt; 작업이 종료 또는 5000 밀리 초 단위로 시간 제한 값, 기본값을 나타내는 정수에 직접 살해해야합니다.</target>
        </trans-unit>
        <trans-unit id="936a9bb35e41ad39f3649a9ecb5c019ee144362b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:shutdown&lt;/code&gt; - &lt;code&gt;:brutal_kill&lt;/code&gt; if the tasks must be killed directly on shutdown or an integer indicating the timeout value. Defaults to &lt;code&gt;5000&lt;/code&gt; milliseconds.</source>
          <target state="translated">&lt;code&gt;:shutdown&lt;/code&gt; - &lt;code&gt;:brutal_kill&lt;/code&gt; 작업이 종료 또는 시간 제한 값을 나타내는 정수에 직접 살해해야합니다. 기본값은 &lt;code&gt;5000&lt;/code&gt; 밀리 초입니다.</target>
        </trans-unit>
        <trans-unit id="1cf41cf5f20acc429222ecbf9a193bced833b34a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:shutdown&lt;/code&gt; - an atom that defines how a child process should be terminated (see the &quot;Shutdown values&quot; section below)</source>
          <target state="translated">&lt;code&gt;:shutdown&lt;/code&gt; - 하위 프로세스 종료 방법을 정의하는 원자 (아래 &quot;종료 값&quot;섹션 참조)</target>
        </trans-unit>
        <trans-unit id="9620978d3a10c2d505e327fdfaf699eced8b0449" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:shutdown&lt;/code&gt; - an atom that defines how a child process should be terminated (see the &quot;Shutdown values&quot; section below). This key is optional and defaults to &lt;code&gt;5000&lt;/code&gt; if the type is &lt;code&gt;:worker&lt;/code&gt; or &lt;code&gt;:infinity&lt;/code&gt; if the type is &lt;code&gt;:supervisor&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:shutdown&lt;/code&gt; - 하위 프로세스 종료 방법을 정의하는 원자입니다 (아래 &quot;종료 값&quot;섹션 참조). 이 키는 선택 사항이며 기본값은 &lt;code&gt;5000&lt;/code&gt; 유형 인 경우 &lt;code&gt;:worker&lt;/code&gt; 나 &lt;code&gt;:infinity&lt;/code&gt; 유형 인 경우 &lt;code&gt;:supervisor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddcaa1d742adc479e7f57ff4367400cc87484a2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:shutdown&lt;/code&gt; - how to shut down the child, either immediately or by giving it time to shut down</source>
          <target state="translated">&lt;code&gt;:shutdown&lt;/code&gt; - 즉시 또는 종료 시간을 제공하여 자식을 종료하는 방법</target>
        </trans-unit>
        <trans-unit id="b1aba46cc3edbcb6180c7652dcd34c6ba320a2c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:shutdown&lt;/code&gt; or &lt;code&gt;{:shutdown, term}&lt;/code&gt; - in such cases, the exit won't be logged, there is no restart in transient mode, and linked processes exit with the same reason unless they're trapping exits</source>
          <target state="translated">&lt;code&gt;:shutdown&lt;/code&gt; 또는 &lt;code&gt;{:shutdown, term}&lt;/code&gt; -이 경우 엑시트가 기록되지 않고 임시 모드에서 재시작이 없으며 링크 된 프로세스가 엑시트를 트랩하지 않는 한 동일한 이유로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="266532d049cf506370e108062bc4a50658b5256d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:skip&lt;/code&gt; - if the message is not meant to be translated nor logged</source>
          <target state="translated">&lt;code&gt;:skip&lt;/code&gt; - 메시지를 번역하거나 기록하지 않은 경우</target>
        </trans-unit>
        <trans-unit id="ff7f81cb7821c0feece478ab371981af6cf1f69a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:skip&lt;/code&gt; - skips the test with the given reason</source>
          <target state="translated">&lt;code&gt;:skip&lt;/code&gt; - 주어진 이유로 테스트를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="022caec0dc167b29f0c878de3ec67c7ab0c56551" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:skip_operators&lt;/code&gt; - skips operators</source>
          <target state="translated">&lt;code&gt;:skip_operators&lt;/code&gt; - 연산자를 건너 뜁니다</target>
        </trans-unit>
        <trans-unit id="a4b3697aab2485b4ee7ea6ef4fb2eecc63a70d5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:slowest&lt;/code&gt; - prints timing information for the N slowest tests. Running ExUnit with slow test reporting automatically runs in &lt;code&gt;trace&lt;/code&gt; mode. It is disabled by default;</source>
          <target state="translated">&lt;code&gt;:slowest&lt;/code&gt; -N 개의 가장 느린 테스트에 대한 타이밍 정보를 인쇄합니다. 느린 테스트보고로 ExUnit을 실행하면 자동으로 &lt;code&gt;trace&lt;/code&gt; 모드 에서 실행 됩니다. 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="61a5ecc1db838c978ad68e03c29acffb369c9b18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:sort&lt;/code&gt; - sort the results by &lt;code&gt;:time&lt;/code&gt; or &lt;code&gt;:calls&lt;/code&gt; (default: &lt;code&gt;:time&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;:sort&lt;/code&gt; -결과를 &lt;code&gt;:time&lt;/code&gt; 또는 &lt;code&gt;:calls&lt;/code&gt; (기본값 : &lt;code&gt;:time&lt;/code&gt; )로 정렬</target>
        </trans-unit>
        <trans-unit id="5a0fbd35060bc33058f26c75fbb0786746853984" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:sort&lt;/code&gt; - sorts the output by given key: &lt;code&gt;:acc&lt;/code&gt; (default) or &lt;code&gt;:own&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:sort&lt;/code&gt; &lt;code&gt;:acc&lt;/code&gt; 주어진 키를 기준으로 출력을 정렬합니다 : : acc (기본값) 또는 &lt;code&gt;:own&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f7c0ae6bc71ab6ce71807d74b1d6644314067777" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:sparse&lt;/code&gt; - checkout a single directory inside the Git repository and use it as your Mix dependency. Search &quot;sparse git checkouts&quot; for more information.</source>
          <target state="translated">&lt;code&gt;:sparse&lt;/code&gt; -Git 저장소 내에서 단일 디렉토리를 체크 아웃하고이를 Mix 종속성으로 사용하십시오. 자세한 정보는 &quot;스파 스 git 체크 아웃&quot;을 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="8f14b0c78d56b7cb533ee482d5f2f0bb4eb40c9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:spawn&lt;/code&gt; will retrieve the program name from the argument and traverse your operating system &lt;code&gt;$PATH&lt;/code&gt; environment variable looking for a matching program.</source>
          <target state="translated">&lt;code&gt;:spawn&lt;/code&gt; 은 인수에서 프로그램 이름을 검색하고 운영 체제 &lt;code&gt;$PATH&lt;/code&gt; 환경 변수를 탐색하여 일치하는 프로그램을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="1bc8c2fc08c495bee7787edbf2eea78df04638c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:spawn_opt&lt;/code&gt; - if present, its value is passed as options to the underlying process as in &lt;a href=&quot;process#spawn/4&quot;&gt;&lt;code&gt;Process.spawn/4&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;:spawn_opt&lt;/code&gt; - 존재하는 경우 해당 값은 &lt;a href=&quot;process#spawn/4&quot;&gt; &lt;code&gt;Process.spawn/4&lt;/code&gt; &lt;/a&gt; 에서와 같이 기본 프로세스에 옵션으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="bd4275872253e2afba277f439142884806fb692e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:specs&lt;/code&gt; - the number of children processes</source>
          <target state="translated">&lt;code&gt;:specs&lt;/code&gt; - 자식 프로세스 수</target>
        </trans-unit>
        <trans-unit id="3a46b61f201e318f7905a2d0fe61831192204a3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:specs&lt;/code&gt; - the total count of children, dead or alive</source>
          <target state="translated">&lt;code&gt;:specs&lt;/code&gt; - 사망 또는 살아있는 어린이의 총 수</target>
        </trans-unit>
        <trans-unit id="9d3891b26de246a89814cfdd208bf4676f78f7f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:stack_info&lt;/code&gt; - ... the stacktrace color</source>
          <target state="translated">&lt;code&gt;:stack_info&lt;/code&gt; -... 스택 추적 색상</target>
        </trans-unit>
        <trans-unit id="0070dccb5edec0c3460ca92eea2a5ff294243a98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:stacktrace_depth&lt;/code&gt; - configures the stacktrace depth to be used on formatting and reporters, defaults to &lt;code&gt;20&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;:stacktrace_depth&lt;/code&gt; - 형식 및 리포터에 사용할 스택 추적 깊이를 구성합니다 . 기본값은 &lt;code&gt;20&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="81aa5a013a0b30e71264b2a6df647e044f117888" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:start&lt;/code&gt; - a tuple with the module-function-args to be invoked to start the child process. This key is required.</source>
          <target state="translated">&lt;code&gt;:start&lt;/code&gt; start-하위 프로세스를 시작하기 위해 호출 할 module-function-args가있는 튜플. 이 키는 필수입니다.</target>
        </trans-unit>
        <trans-unit id="e4389c8a4f1e9e9b79cd01871ba2e306282798fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:state&lt;/code&gt; - the finished test state (see &lt;a href=&quot;exunit#t:state/0&quot;&gt;&lt;code&gt;ExUnit.state/0&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;:state&lt;/code&gt; &lt;a href=&quot;exunit#t:state/0&quot;&gt; &lt;code&gt;ExUnit.state/0&lt;/code&gt; &lt;/a&gt; 완료된 테스트 상태 ( ExUnit.state / 0 참조 )</target>
        </trans-unit>
        <trans-unit id="060b62ea4c1cd006950ab4a603b2e3d10c314354" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:state&lt;/code&gt; - the test error state (see &lt;a href=&quot;exunit#t:state/0&quot;&gt;&lt;code&gt;ExUnit.state/0&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;:state&lt;/code&gt; &lt;a href=&quot;exunit#t:state/0&quot;&gt; &lt;code&gt;ExUnit.state/0&lt;/code&gt; &lt;/a&gt; 테스트 오류 상태 ( ExUnit.state / 0 참조 )</target>
        </trans-unit>
        <trans-unit id="4e8e9dbb5db3d0c5b133a1711403f03c2707f93c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:static_atom_encoder&lt;/code&gt; - The static atom encoder function, see &quot;The &lt;code&gt;:static_atom_encoder&lt;/code&gt; function&quot; section below. This option overrides the &lt;code&gt;:existing_atoms_only&lt;/code&gt; behaviour for static atoms but &lt;code&gt;:existing_atoms_only&lt;/code&gt; is still used for dynamic atoms, such as atoms with interpolations.</source>
          <target state="translated">&lt;code&gt;:static_atom_encoder&lt;/code&gt; - 정적 아톰 엔코더 기능은 아래 &quot;static &lt;code&gt;:static_atom_encoder&lt;/code&gt; 기능&quot;섹션을 참조하십시오. 이 옵션은 정적 원자에 대한 &lt;code&gt;:existing_atoms_only&lt;/code&gt; 동작을 재정의 하지만 보간이있는 원자와 같이 동적 원자에 대해서는 &lt;code&gt;:existing_atoms_only&lt;/code&gt; 가 계속 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="343ef905fb4f21e5d27635c8e9062e23d8bcc3a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:stderr&lt;/code&gt; - a shortcut for the named process &lt;code&gt;:standard_error&lt;/code&gt; provided in Erlang</source>
          <target state="translated">&lt;code&gt;:stderr&lt;/code&gt; - Erlang에서 제공되는 명명 된 프로세스에 대한 바로 가기 &lt;code&gt;:standard_error&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f83bee1f54001a194ca817ca04fac4082d02743" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:stderr_to_stdout&lt;/code&gt; - redirects stderr to stdout when &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:stderr_to_stdout&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; 일 때 stderr를 stdout으로 경로 재 지정</target>
        </trans-unit>
        <trans-unit id="e60878611aa41a0dc31c7c64864c5d1bd0faed6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:stdio&lt;/code&gt; - a shortcut for &lt;code&gt;:standard_io&lt;/code&gt;, which maps to the current &lt;a href=&quot;process#group_leader/0&quot;&gt;&lt;code&gt;Process.group_leader/0&lt;/code&gt;&lt;/a&gt; in Erlang</source>
          <target state="translated">&lt;code&gt;:stdio&lt;/code&gt; - Erlang 의 현재 &lt;a href=&quot;process#group_leader/0&quot;&gt; &lt;code&gt;Process.group_leader/0&lt;/code&gt; &lt;/a&gt; 에 매핑되는 &lt;code&gt;:standard_io&lt;/code&gt; 의 바로 가기</target>
        </trans-unit>
        <trans-unit id="58045e7e96ed45a0fb6a2556602dbe4dff9befbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:strategy&lt;/code&gt; - the restart strategy option. It can be either &lt;code&gt;:one_for_one&lt;/code&gt;, &lt;code&gt;:rest_for_one&lt;/code&gt;, &lt;code&gt;:one_for_all&lt;/code&gt;, or &lt;code&gt;:simple_one_for_one&lt;/code&gt;. You can learn more about strategies in the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">&lt;code&gt;:strategy&lt;/code&gt; - 재시작 전략 옵션. &lt;code&gt;:one_for_one&lt;/code&gt; , &lt;code&gt;:rest_for_one&lt;/code&gt; , &lt;code&gt;:one_for_all&lt;/code&gt; 또는 &lt;code&gt;:simple_one_for_one&lt;/code&gt; 중 하나 일 수 있습니다 . &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 모듈 문서 에서 전략에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="328214f38c6d873de09f4dee8577407384e48cb8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:strategy&lt;/code&gt; - the restart strategy option. The only supported value is &lt;code&gt;:one_for_one&lt;/code&gt; which means that no other child is terminated if a child process terminates. You can learn more about strategies in the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module docs.</source>
          <target state="translated">&lt;code&gt;:strategy&lt;/code&gt; - 재시작 전략 옵션. 유일하게 지원되는 값은 &lt;code&gt;:one_for_one&lt;/code&gt; 이며 하위 프로세스가 종료되면 다른 하위가 종료되지 않음 을 의미합니다. &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 모듈 문서 에서 전략에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aba2a28a21a71d37aecb4e25a9571218596b092c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:strategy&lt;/code&gt; - the supervision strategy option. It can be either &lt;code&gt;:one_for_one&lt;/code&gt;, &lt;code&gt;:rest_for_one&lt;/code&gt; or &lt;code&gt;:one_for_all&lt;/code&gt;. Required. See the &quot;Strategies&quot; section.</source>
          <target state="translated">&lt;code&gt;:strategy&lt;/code&gt; - 감독 전략 옵션. &lt;code&gt;:one_for_one&lt;/code&gt; , &lt;code&gt;:rest_for_one&lt;/code&gt; 또는 &lt;code&gt;:one_for_all&lt;/code&gt; 중 하나 일 수 있습니다 . 필수입니다. &quot;전략&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e1f83540fffe130cdc9643409c033d9e92241452" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:strategy&lt;/code&gt; - the supervision strategy option. It can be either &lt;code&gt;:one_for_one&lt;/code&gt;, &lt;code&gt;:rest_for_one&lt;/code&gt;, &lt;code&gt;:one_for_all&lt;/code&gt;, or the deprecated &lt;code&gt;:simple_one_for_one&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:strategy&lt;/code&gt; - 감독 전략 옵션. 그것은 될 수 있습니다 &lt;code&gt;:one_for_one&lt;/code&gt; , &lt;code&gt;:rest_for_one&lt;/code&gt; , &lt;code&gt;:one_for_all&lt;/code&gt; 또는 사용되지 않는 &lt;code&gt;:simple_one_for_one&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af1c6ce276c33d1550d8c38b505c9a844b0f8a42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:strict&lt;/code&gt; - defines strict switches and their types. Any switch in &lt;code&gt;argv&lt;/code&gt; that is not specified in the list is returned in the invalid options list. This is the preferred way to parse options.</source>
          <target state="translated">&lt;code&gt;:strict&lt;/code&gt; - 엄격한 스위치 및 해당 유형을 정의합니다. 목록에 지정되지 않은 &lt;code&gt;argv&lt;/code&gt; 의 모든 스위치 는 유효하지 않은 옵션 목록에 리턴됩니다. 옵션을 구문 분석하는 데 선호되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="c793876b11b8ab1cbc7182ff168a554b74265bdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:string&lt;/code&gt; - parses the value as a string</source>
          <target state="translated">&lt;code&gt;:string&lt;/code&gt; string-값을 문자열로 구문 분석</target>
        </trans-unit>
        <trans-unit id="5fb0eee54aeddb670a69245cf74b0ac28cacdc61" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:strip_beam&lt;/code&gt; - if &lt;code&gt;true&lt;/code&gt; strips BEAM code in the escript to remove chunks unnecessary at runtime, such as debug information and documentation. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:strip_beam&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; 이면 디버그 정보 및 문서와 같이 런타임시 불필요한 청크를 제거하기 위해 escript에서 BEAM 코드를 제거합니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9d4b0681bc2e63567bfddd7c1a32eb1a2af4cc12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:structs&lt;/code&gt; - when &lt;code&gt;false&lt;/code&gt;, structs are not formatted by the inspect protocol, they are instead printed as maps, defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:structs&lt;/code&gt; - &lt;code&gt;false&lt;/code&gt; 이면 구조체가 inspect 프로토콜에 의해 형식화되지 않고 대신 맵으로 인쇄되며 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="535bfa8e2b14835196f89e91d1dbba30cd7fd13e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:submodules&lt;/code&gt; - when &lt;code&gt;true&lt;/code&gt;, initialize submodules for the repo</source>
          <target state="translated">&lt;code&gt;:submodules&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; 인 경우 저장소의 하위 모듈을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="fd1a11e08b3533d6ec7807000ca6b512f99b293b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:summary&lt;/code&gt; - summary output configuration; can be either a boolean or a keyword list. When a keyword list is passed, it can specify a &lt;code&gt;:threshold&lt;/code&gt;, which is a boolean or numeric value that enables coloring of code coverage results in red or green depending on whether the percentage is below or above the specified threshold, respectively. Defaults to &lt;code&gt;[threshold: 90]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:summary&lt;/code&gt; -요약 출력 구성; 부울 또는 키워드 목록 일 수 있습니다. 키워드 목록이 전달 될 때 &lt;code&gt;:threshold&lt;/code&gt; 를 지정할 수 있습니다 . 부울 또는 숫자 값으로, 백분율이 지정된 임계 값 아래인지 또는 위에 있는지에 따라 코드 적용 범위의 결과를 빨간색 또는 녹색으로 채색 할 수 있습니다. 기본값은 &lt;code&gt;[threshold: 90]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="caae8c51b443956985309cfe957ca2d2488d4f5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:supervisors&lt;/code&gt; - the count of all supervisors whether or not the child process is still alive</source>
          <target state="translated">&lt;code&gt;:supervisors&lt;/code&gt; -자식 프로세스가 아직 활성 상태인지 여부에 상관없이 모든 수퍼바이저 수</target>
        </trans-unit>
        <trans-unit id="fe23eb4b90f7f51cad01e75be68fdcd3f495ebbe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:supervisors&lt;/code&gt; - the count of all supervisors whether or not these child supervisors are still alive</source>
          <target state="translated">&lt;code&gt;:supervisors&lt;/code&gt; -이 자식 감독자가 여전히 살아 있는지 여부에 상관없이 모든 감독관의 수</target>
        </trans-unit>
        <trans-unit id="28c96dc0f5b0d2b21c6a75b87f6a5675c12740c7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:suspend&lt;/code&gt; - the enumeration should be suspended immediately</source>
          <target state="translated">&lt;code&gt;:suspend&lt;/code&gt; - 열거는 즉시 중단되어야합니다</target>
        </trans-unit>
        <trans-unit id="afff777a8b91efd6a7328a1dc7bacbf707dcf110" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:switches&lt;/code&gt; - defines switches and their types. This function still attempts to parse switches that are not in this list.</source>
          <target state="translated">&lt;code&gt;:switches&lt;/code&gt; -스위치 및 해당 유형을 정의합니다. 이 기능은 여전히이 목록에없는 스위치를 구문 분석하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="fe6ee28c7980294509aa65f52a5155fddb2b9949" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:switches&lt;/code&gt; or &lt;code&gt;:strict&lt;/code&gt; - see the &quot;Switch definitions&quot; section below</source>
          <target state="translated">&lt;code&gt;:switches&lt;/code&gt; 또는 &lt;code&gt;:strict&lt;/code&gt; - 아래 &quot;스위치 정의&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="41ebdb15357f55413373b605a304c40cd67b6e18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:symlink_ebin&lt;/code&gt; - symlink ebin instead of copying it</source>
          <target state="translated">&lt;code&gt;:symlink_ebin&lt;/code&gt; - 복사하는 대신 symlink ebin</target>
        </trans-unit>
        <trans-unit id="3f4ba688e23f2c521ba75337c1b3789939d1ff7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:sync_threshold&lt;/code&gt; - if the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; manager has more than &lt;code&gt;:sync_threshold&lt;/code&gt; messages in its queue, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; will change to &lt;em&gt;sync mode&lt;/em&gt;, to apply backpressure to the clients. &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; will return to &lt;em&gt;async mode&lt;/em&gt; once the number of messages in the queue is reduced to one below the &lt;code&gt;sync_threshold&lt;/code&gt;. Defaults to 20 messages. &lt;code&gt;:sync_threshold&lt;/code&gt; can be set to &lt;code&gt;0&lt;/code&gt; to force &lt;em&gt;sync mode&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;:sync_threshold&lt;/code&gt; - 경우 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 관리자가보다 더있다 &lt;code&gt;:sync_threshold&lt;/code&gt; 대기열에서 메시지를 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 로 변경됩니다 &lt;em&gt;동기화 모드&lt;/em&gt; 클라이언트에 배압을 적용합니다. 큐의 메시지 수가 &lt;code&gt;sync_threshold&lt;/code&gt; 아래로 감소하면 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 는 &lt;em&gt;비동기 모드로&lt;/em&gt; 돌아갑니다 . 기본적으로 20 개의 메시지입니다. &lt;code&gt;:sync_threshold&lt;/code&gt; 를 &lt;code&gt;0&lt;/code&gt; 으로 설정하여 &lt;em&gt;동기화 모드&lt;/em&gt; 를 강제 설정할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7ec2abd529b1aa552da9ce3d98d2a89cd3dc8ad8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:syntax_colors&lt;/code&gt; - when set to a keyword list of colors the output is colorized. The keys are types and the values are the colors to use for each type (for example, &lt;code&gt;[number: :red, atom: :blue]&lt;/code&gt;). Types can include &lt;code&gt;:number&lt;/code&gt;, &lt;code&gt;:atom&lt;/code&gt;, &lt;code&gt;regex&lt;/code&gt;, &lt;code&gt;:tuple&lt;/code&gt;, &lt;code&gt;:map&lt;/code&gt;, &lt;code&gt;:list&lt;/code&gt;, and &lt;code&gt;:reset&lt;/code&gt;. Colors can be any &lt;a href=&quot;io.ansi#t:ansidata/0&quot;&gt;&lt;code&gt;IO.ANSI.ansidata/0&lt;/code&gt;&lt;/a&gt; as accepted by &lt;a href=&quot;io.ansi#format/1&quot;&gt;&lt;code&gt;IO.ANSI.format/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;:syntax_colors&lt;/code&gt; - 키워드 색상 목록으로 설정하면 출력 색상이 지정됩니다. 키는 유형이고 값은 각 유형에 사용할 색상입니다 (예 &lt;code&gt;[number: :red, atom: :blue]&lt;/code&gt; ). 유형은 &lt;code&gt;:number&lt;/code&gt; , &lt;code&gt;:atom&lt;/code&gt; , &lt;code&gt;regex&lt;/code&gt; , &lt;code&gt;:tuple&lt;/code&gt; , &lt;code&gt;:map&lt;/code&gt; , &lt;code&gt;:list&lt;/code&gt; 및 &lt;code&gt;:reset&lt;/code&gt; 을 포함 할 수 있습니다. &lt;a href=&quot;io.ansi#format/1&quot;&gt; &lt;code&gt;IO.ANSI.format/1&lt;/code&gt; 에서&lt;/a&gt; 허용하는 색상은 &lt;a href=&quot;io.ansi#t:ansidata/0&quot;&gt; &lt;code&gt;IO.ANSI.ansidata/0&lt;/code&gt; 일&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fc68f71f7771a43da5d88e5526c2ab32c9df54a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:system_env&lt;/code&gt; - an enumerable of key-value tuples of binaries to be set as environment variables when loading or compiling the dependency</source>
          <target state="translated">&lt;code&gt;:system_env&lt;/code&gt; - 의존성을로드하거나 컴파일 할 때 환경 변수로 설정 될 바이너리의 키-값 튜플 열거 가능</target>
        </trans-unit>
        <trans-unit id="3ada65ff2401005a619f67139d0ac025b40891d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:system_limit&lt;/code&gt; - all available ports in the Erlang emulator are in use</source>
          <target state="translated">&lt;code&gt;:system_limit&lt;/code&gt; -Erlang 에뮬레이터에서 사용 가능한 모든 포트가 사용 중입니다.</target>
        </trans-unit>
        <trans-unit id="c3723a25f474d6156a4964e6d55bb745f148b597" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:tag&lt;/code&gt; - the Git tag to checkout</source>
          <target state="translated">&lt;code&gt;:tag&lt;/code&gt; tag-체크 아웃 할 Git 태그</target>
        </trans-unit>
        <trans-unit id="3619075d3eee8e910609afdbc22465ad531aeddb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:tags&lt;/code&gt; - the test tags</source>
          <target state="translated">&lt;code&gt;:tags&lt;/code&gt; - 테스트 태그</target>
        </trans-unit>
        <trans-unit id="9b5435d8bc38d5fc84b0cc5dd6913e6d59a3dd03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:targets&lt;/code&gt; - the dependency is made available only for the given targets. By default the dependency will be available in all environments. The value of this option can either be a single target (like &lt;code&gt;:host&lt;/code&gt;) or a list of environments (like &lt;code&gt;[:host, :rpi3]&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;:targets&lt;/code&gt; - 지정된 대상에 대해서만 종속성을 사용할 수 있습니다. 기본적으로 모든 환경에서 종속성을 사용할 수 있습니다. 이 옵션의 값은 단일 대상 (예 &lt;code&gt;:host&lt;/code&gt; )이거나 환경 목록 (예 &lt;code&gt;[:host, :rpi3]&lt;/code&gt; ) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54d2de44d85c61192c7cad03af98fe1af3d9a1be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:temporary&lt;/code&gt; - if &lt;code&gt;app&lt;/code&gt; terminates, it is reported but no other applications are terminated (the default).</source>
          <target state="translated">&lt;code&gt;:temporary&lt;/code&gt; - &lt;code&gt;app&lt;/code&gt; 종료되면보고되지만 다른 애플리케이션은 종료되지 않습니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="4c539ed3846b0fb29a4866d15d8c60ecc20ec1d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:temporary&lt;/code&gt; - the child process is never restarted (not even when the supervisor's strategy is &lt;code&gt;:rest_for_one&lt;/code&gt; or &lt;code&gt;:one_for_all&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;:temporary&lt;/code&gt; -하위 프로세스가 다시 시작되지 않습니다 (감독자의 전략이 &lt;code&gt;:rest_for_one&lt;/code&gt; 또는 &lt;code&gt;:one_for_all&lt;/code&gt; 인 경우에도 )</target>
        </trans-unit>
        <trans-unit id="31eabe44bb62418e11c93f7e46da12189bd5aaa1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:temporary&lt;/code&gt; - the child process is never restarted, regardless of the supervision strategy: any termination (even abnormal) is considered successful.</source>
          <target state="translated">&lt;code&gt;:temporary&lt;/code&gt; -감독 전략에 관계없이 하위 프로세스가 다시 시작되지 않습니다. 모든 종료 (비정상적 일지라도)는 성공적인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f22bbcb496432cea55f6a9f47e8bd2d643c8b467" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:test&lt;/code&gt; - the environment &lt;a href=&quot;mix.tasks.test&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; runs on</source>
          <target state="translated">&lt;code&gt;:test&lt;/code&gt; - 환경 &lt;a href=&quot;mix.tasks.test&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt; 가 실행됩니다</target>
        </trans-unit>
        <trans-unit id="b76e6f5c90e7a6502ee72e49445edbe147645e1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:test&lt;/code&gt; - the test name</source>
          <target state="translated">&lt;code&gt;:test&lt;/code&gt; - 테스트 이름</target>
        </trans-unit>
        <trans-unit id="90fcbfaf585325b36b4502c01e390ea297199d7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:test&lt;/code&gt; - used by &lt;code&gt;mix test&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:test&lt;/code&gt; -에서 사용하는 &lt;code&gt;mix test&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8552d2a1fa910d0583045a91b3e56578f35d7bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:test_coverage&lt;/code&gt; - a set of options to be passed down to the coverage mechanism</source>
          <target state="translated">&lt;code&gt;:test_coverage&lt;/code&gt; - 커버리지 메커니즘으로 전달되는 옵션 세트</target>
        </trans-unit>
        <trans-unit id="ab99093006f8a392a546b357f96e21e57466385c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:test_location_relative_path&lt;/code&gt; - the test location is the file:line information printed by tests as a shortcut to run a given test. When this value is set, the value is used as a prefix for the test itself. This is typically used by Mix to properly set-up umbrella projects</source>
          <target state="translated">&lt;code&gt;:test_location_relative_path&lt;/code&gt; - 테스트 위치는 주어진 테스트를 실행하기위한 바로 가기로 테스트에 의해 인쇄 된 파일 : 라인 정보입니다. 이 값을 설정하면 값이 테스트 자체의 접두사로 사용됩니다. 이는 일반적으로 Mix에서 우산 프로젝트를 올바르게 설정하는 데 사용</target>
        </trans-unit>
        <trans-unit id="002a1a6acbf0c987e6f149650dc64ee37f6191d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:test_paths&lt;/code&gt; - list of paths containing test files. Defaults to &lt;code&gt;[&quot;test&quot;]&lt;/code&gt; if the &lt;code&gt;test&lt;/code&gt; directory exists; otherwise, it defaults to &lt;code&gt;[]&lt;/code&gt;. It is expected that all test paths contain a &lt;code&gt;test_helper.exs&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;:test_paths&lt;/code&gt; - 테스트 파일을 포함하는 경로 목록 &lt;code&gt;test&lt;/code&gt; 디렉토리가 존재 하면 기본값은 &lt;code&gt;[&quot;test&quot;]&lt;/code&gt; 입니다 . 그렇지 않으면 기본값은 &lt;code&gt;[]&lt;/code&gt; 입니다. 모든 테스트 경로에는 &lt;code&gt;test_helper.exs&lt;/code&gt; 파일이 포함되어 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="b83107d9f58141aa3359434d963157b4ee458a18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:test_pattern&lt;/code&gt; - a pattern to load test files. Defaults to &lt;code&gt;*_test.exs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:test_pattern&lt;/code&gt; - 테스트 파일을로드하는 패턴 기본값은 &lt;code&gt;*_test.exs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a91a4aef73b36cb1759a347e386bab5fcd35f14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:tests&lt;/code&gt; - all tests for this case</source>
          <target state="translated">&lt;code&gt;:tests&lt;/code&gt; - 이 경우에 대한 모든 테스트</target>
        </trans-unit>
        <trans-unit id="6fe266c99e03604d6137a8d1ea2015fe914436ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:time&lt;/code&gt; - configures how the file timestamps are returned</source>
          <target state="translated">&lt;code&gt;:time&lt;/code&gt; time-파일 타임 스탬프가 반환되는 방법을 구성합니다</target>
        </trans-unit>
        <trans-unit id="0bf29d79146cc591901187eaae942b579a923d41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:time&lt;/code&gt; - filters out any results that took lower than specified (in &amp;micro;s)</source>
          <target state="translated">&lt;code&gt;:time&lt;/code&gt; time-지정된 (&amp;micro;s)보다 낮은 결과를 필터링합니다.</target>
        </trans-unit>
        <trans-unit id="945d163c11a9410b1a739a489e0aa33606521d01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:time&lt;/code&gt; - the duration in microseconds of the test's runtime</source>
          <target state="translated">&lt;code&gt;:time&lt;/code&gt; time-테스트 런타임의 지속 시간 (마이크로 초)</target>
        </trans-unit>
        <trans-unit id="1bb289f6502ed3468e35c755cc0f3501180ebada" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:timeout&lt;/code&gt; - customizes the test timeout in milliseconds (defaults to 60000). Accepts &lt;code&gt;:infinity&lt;/code&gt; as a timeout value.</source>
          <target state="translated">&lt;code&gt;:timeout&lt;/code&gt; - 테스트 시간 초과를 밀리 초 단위로 사용자 지정합니다 (기본값은 60000). &lt;code&gt;:infinity&lt;/code&gt; 를 시간 초과 값으로 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="cc267265be13bca0983f3fe0f82491f86c3281fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:timeout&lt;/code&gt; - if present, the server is allowed to spend the given number of milliseconds initializing or it will be terminated and the start function will return &lt;code&gt;{:error, :timeout}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:timeout&lt;/code&gt; - 존재하는 경우, 서버는 초기화에 주어진 시간 (밀리 초)을 소비 할 수 있거나 종료되며 시작 기능은 &lt;code&gt;{:error, :timeout}&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="31542e4a35ff214ba221de059f800cc2101050ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:timeout&lt;/code&gt; - sets the timeout for the tests in milliseconds, defaults to &lt;code&gt;60_000&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;:timeout&lt;/code&gt; &lt;code&gt;60_000&lt;/code&gt; 테스트 시간 초과를 밀리 초 단위로 설정합니다 . 기본값은 60_000입니다 .</target>
        </trans-unit>
        <trans-unit id="2baafad806202f66b01ccfd25bb715322d63de82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:timeout&lt;/code&gt; - the maximum amount of time (in milliseconds) each task is allowed to execute for. Defaults to &lt;code&gt;5000&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:timeout&lt;/code&gt; - 각 작업을 실행할 수있는 최대 시간 (밀리 초)입니다. 기본값은 &lt;code&gt;5000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cb2ba6f815c6858cb7e4136a89c5d45161dc4d98" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:timeout&lt;/code&gt; - the maximum amount of time to wait (in milliseconds) without receiving a task reply (across all running tasks). Defaults to &lt;code&gt;5000&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:timeout&lt;/code&gt; - 실행중인 모든 작업에서 작업 응답을받지 않고 대기 할 최대 시간 (밀리 초)입니다. 기본값은 &lt;code&gt;5000&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a888f2b8abe68c72ecc4a468fad6dcd9c82ece65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:timeout&lt;/code&gt; - the timeout for the change (defaults to &lt;code&gt;5_000&lt;/code&gt; milliseconds)</source>
          <target state="translated">&lt;code&gt;:timeout&lt;/code&gt; &lt;code&gt;5_000&lt;/code&gt; 변경 시간 초과 (기본값은 5_000 밀리 초)</target>
        </trans-unit>
        <trans-unit id="34e24470b02bfc44c44f776cb2fcc734faafb94f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:to&lt;/code&gt; - the module to dispatch to.</source>
          <target state="translated">&lt;code&gt;:to&lt;/code&gt; to-전달할 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="834e5bf44b0a682b00fcfce09fe6a6d232dc65ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:tool&lt;/code&gt; - the coverage tool</source>
          <target state="translated">&lt;code&gt;:tool&lt;/code&gt; - 적용 범위 도구</target>
        </trans-unit>
        <trans-unit id="99082314da4b63e3d8f7a64f945d58a484e4ab21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:trace&lt;/code&gt; - sets ExUnit into trace mode, this sets &lt;code&gt;:max_cases&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; and prints each test case and test while running. Note that in trace mode test timeouts will be ignored as timeout is set to &lt;code&gt;:infinity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:trace&lt;/code&gt; -ExUnit을 추적 모드로 설정합니다 &lt;code&gt;:max_cases&lt;/code&gt; 이 설정은 : max_cases 를 &lt;code&gt;1&lt;/code&gt; 로 설정 하고 각 테스트 케이스를 인쇄하고 실행 중에 테스트합니다. 추적 모드에서 제한 시간이 &lt;code&gt;:infinity&lt;/code&gt; 로 설정되면 테스트 제한 시간이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="70971b562b0e5ec3e13c95916e7a96be595a80a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:transient&lt;/code&gt; - if &lt;code&gt;app&lt;/code&gt; terminates with &lt;code&gt;:normal&lt;/code&gt; reason, it is reported but no other applications are terminated. If a transient application terminates abnormally, all other applications and the entire node are also terminated.</source>
          <target state="translated">&lt;code&gt;:transient&lt;/code&gt; - &lt;code&gt;:normal&lt;/code&gt; 이유로 &lt;code&gt;app&lt;/code&gt; 종료 되면 보고되지만 다른 애플리케이션은 종료되지 않습니다. 임시 애플리케이션이 비정상적으로 종료되면 다른 모든 애플리케이션과 전체 노드도 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="8c8b579053cc8b765ddb56db8a5d6c340a1c9ba4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:transient&lt;/code&gt; - the child process is restarted only if it terminates abnormally, i.e., with an exit reason other than &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt; or &lt;code&gt;{:shutdown, term}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:transient&lt;/code&gt; - 하위 프로세스가 비정상적으로 종료 된 경우에만 다시 시작됩니다 (예 &lt;code&gt;:normal&lt;/code&gt; , &lt;code&gt;:shutdown&lt;/code&gt; 또는 &lt;code&gt;{:shutdown, term}&lt;/code&gt; 이외의 종료 이유 ) .</target>
        </trans-unit>
        <trans-unit id="dd62486aa68570d0f4a2e16bacd9ea1b578b8a0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:transient&lt;/code&gt; - the child process is restarted only if it terminates abnormally, i.e., with an exit reason other than &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt;, or &lt;code&gt;{:shutdown, term}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:transient&lt;/code&gt; - 하위 프로세스가 비정상적으로 종료 된 경우에만 다시 시작됩니다 (예 &lt;code&gt;:normal&lt;/code&gt; , &lt;code&gt;:shutdown&lt;/code&gt; 또는 &lt;code&gt;{:shutdown, term}&lt;/code&gt; 이외의 종료 이유) .</target>
        </trans-unit>
        <trans-unit id="f069e598cc72f10de360ffe78ef566fd3d1a1b38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:translator_inspect_opts&lt;/code&gt; - when translating OTP reports and errors, the last message and state must be inspected in the error reports. This configuration allow developers to change how much and how the data should be inspected.</source>
          <target state="translated">&lt;code&gt;:translator_inspect_opts&lt;/code&gt; -OTP 보고서 및 오류를 변환 할 때 오류 메시지에서 마지막 메시지 및 상태를 검사해야합니다. 이 구성을 통해 개발자는 데이터 검사 량과 방법을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8bd50a7c18a4e891bbba01af094152e12dc8854" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:trim&lt;/code&gt; (boolean) - if &lt;code&gt;true&lt;/code&gt;, empty strings are removed from the resulting list.</source>
          <target state="translated">&lt;code&gt;:trim&lt;/code&gt; (부울) - 경우 &lt;code&gt;true&lt;/code&gt; , 빈 문자열은 결과 목록에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="4a665c5e500044cbff85b11b93656534301845be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:trim&lt;/code&gt; - trims whitespace left/right of quotation tags. If a quotation tag appears on its own in a given line, line endings are also removed.</source>
          <target state="translated">&lt;code&gt;:trim&lt;/code&gt; - 인용 태그의 왼쪽 / 오른쪽 공백을 자릅니다. 따옴표 태그가 주어진 줄에 단독으로 나타나면 줄 끝도 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b09754295e0a7f11e57f31788d5d04d1352790d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:trim&lt;/code&gt; - when &lt;code&gt;true&lt;/code&gt;, removes empty strings (&lt;code&gt;&quot;&quot;&lt;/code&gt;) from the result. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:trim&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; 이면 결과에서 빈 문자열 ( &lt;code&gt;&quot;&quot;&lt;/code&gt; )을 제거합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d71bda1f4d67b286a26089f9b3d3a7af2141030a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:truncate&lt;/code&gt; - the maximum message size to be logged (in bytes). Defaults to 8192 bytes. Note this configuration is approximate. Truncated messages will have &lt;code&gt;&quot; (truncated)&quot;&lt;/code&gt; at the end. The atom &lt;code&gt;:infinity&lt;/code&gt; can be passed to disable this behavior.</source>
          <target state="translated">&lt;code&gt;:truncate&lt;/code&gt; - 기록 할 최대 메시지 크기 (바이트)입니다. 기본값은 8192 바이트입니다. 이 구성은 대략적인 것입니다. 잘린 메시지 의 끝에 &lt;code&gt;&quot; (truncated)&quot;&lt;/code&gt; 됩니다. atom &lt;code&gt;:infinity&lt;/code&gt; 를 전달하여이 동작을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c269b735cc40a6e0b9e6ae233b92cbc96bb45b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:type&lt;/code&gt; - &lt;code&gt;:local&lt;/code&gt; (for anonymous functions) or &lt;code&gt;:external&lt;/code&gt; (for named functions).</source>
          <target state="translated">&lt;code&gt;:type&lt;/code&gt; - &lt;code&gt;:local&lt;/code&gt; (익명 함수) 또는 &lt;code&gt;:external&lt;/code&gt; (이름 기능).</target>
        </trans-unit>
        <trans-unit id="07b2d5e7363b172a9678eec9bf2505da8b949758" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:type&lt;/code&gt; - specifies that the child process is a &lt;code&gt;:worker&lt;/code&gt; or a &lt;code&gt;:supervisor&lt;/code&gt;. This key is optional and defaults to &lt;code&gt;:worker&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:type&lt;/code&gt; - 자식 프로세스가 &lt;code&gt;:worker&lt;/code&gt; 또는 &lt;code&gt;:supervisor&lt;/code&gt; 임을 지정합니다 . 이 키는 선택 사항이며 기본값은 &lt;code&gt;:worker&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ef0b82875d3e0219deca5a33c69825d900b1ddd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:uniq&lt;/code&gt; - (integer) a unique value for this function. This integer is calculated from the compiled code for the entire module.</source>
          <target state="translated">&lt;code&gt;:uniq&lt;/code&gt; - (정수)이 함수의 고유 한 값입니다. 이 정수는 전체 모듈에 대해 컴파일 된 코드에서 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="ca9d3acb06123805c5480fec9d97b0e18ec5a45a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:universal&lt;/code&gt; - returns a &lt;code&gt;{date, time}&lt;/code&gt; tuple in UTC (default)</source>
          <target state="translated">&lt;code&gt;:universal&lt;/code&gt; - &lt;code&gt;{date, time}&lt;/code&gt; 튜플을 UTC로 반환합니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="90bb6b004d3a5bade442ad27b72dd634377a8d2b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:unquote&lt;/code&gt; - when &lt;code&gt;false&lt;/code&gt;, disables unquoting. This means any &lt;code&gt;unquote&lt;/code&gt; call will be kept as is in the AST, instead of replaced by the &lt;code&gt;unquote&lt;/code&gt; arguments. For example:</source>
          <target state="translated">&lt;code&gt;:unquote&lt;/code&gt; - &lt;code&gt;false&lt;/code&gt; 인 경우 인용을 해제합니다. 이는 &lt;code&gt;unquote&lt;/code&gt; 인수 로 대체되는 대신 &lt;code&gt;unquote&lt;/code&gt; 호출이 AST에있는 그대로 유지됨을 의미합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c8522475e803f9d234e8fefb372137355db79dd6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:unquote&lt;/code&gt; - when true, this function leaves &lt;a href=&quot;kernel.specialforms#unquote/1&quot;&gt;&lt;code&gt;unquote/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel.specialforms#unquote_splicing/1&quot;&gt;&lt;code&gt;unquote_splicing/1&lt;/code&gt;&lt;/a&gt; statements unescaped, effectively unquoting the contents on escape. This option is useful only when escaping ASTs which may have quoted fragments in them. Defaults to false.</source>
          <target state="translated">&lt;code&gt;:unquote&lt;/code&gt; -true 인 경우이 함수는 &lt;a href=&quot;kernel.specialforms#unquote/1&quot;&gt; &lt;code&gt;unquote/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;kernel.specialforms#unquote_splicing/1&quot;&gt; &lt;code&gt;unquote_splicing/1&lt;/code&gt; &lt;/a&gt; 문을 이스케이프하지 않고 이스케이프 할 때 내용을 효과적으로 인용 해제합니다. 이 옵션은 조각을 인용 한 AST를 이스케이프 처리 할 때만 유용합니다. 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="da1acb5f6f05ab526efed9e68ec909c1560d04b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:upper&lt;/code&gt; - only allows upper case characters (default)</source>
          <target state="translated">&lt;code&gt;:upper&lt;/code&gt; - 대문자 만 허용 (기본값)</target>
        </trans-unit>
        <trans-unit id="e7569b8882893c01db9f45913b40ea583be067a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:upper&lt;/code&gt; - uses upper case characters (default)</source>
          <target state="translated">&lt;code&gt;:upper&lt;/code&gt; - 대문자 사용 (기본값)</target>
        </trans-unit>
        <trans-unit id="9411b629323b5e86fa681c28de9a4aceec773ecf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:utc_log&lt;/code&gt; - when &lt;code&gt;true&lt;/code&gt;, uses UTC in logs. By default it uses local time (i.e., it defaults to &lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;:utc_log&lt;/code&gt; - &lt;code&gt;true&lt;/code&gt; 인 경우 로그에서 UTC를 사용합니다. 기본적으로 현지 시간을 사용합니다 (예 : 기본값은 &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="effab779af0f67bc8dd05247dbafef135012c33f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:utf8&lt;/code&gt; - this option denotes how data is actually stored in the disk file and makes the file perform automatic translation of characters to and from UTF-8.</source>
          <target state="translated">&lt;code&gt;:utf8&lt;/code&gt; - 이 옵션은 데이터가 실제로 디스크 파일에 저장되는 방식을 나타내며 파일이 UTF-8과의 문자 자동 변환을 수행하게합니다.</target>
        </trans-unit>
        <trans-unit id="f94cda1b877876edd0aa1cda48627ad7c2b262a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:valid&lt;/code&gt; - the string is split into chunks of valid and invalid character sequences</source>
          <target state="translated">&lt;code&gt;:valid&lt;/code&gt; - 문자열이 유효하고 유효하지 않은 문자 시퀀스로 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="f2b436b6c7866bb272d673331295201a888ee4c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:version&lt;/code&gt; - the Elixir version</source>
          <target state="translated">&lt;code&gt;:version&lt;/code&gt; -Elixir 버전</target>
        </trans-unit>
        <trans-unit id="55a62f489cf1e3c1c55f5ca9ee8251ef3deeeaf2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:warn&lt;/code&gt; - color for warn messages. Defaults to: &lt;code&gt;:yellow&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:warn&lt;/code&gt; - 경고 메시지의 색상입니다. 기본값은 : &lt;code&gt;:yellow&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8c5e79805db42d87c49b6e732710f8a9883d53cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:warn&lt;/code&gt; - for warnings</source>
          <target state="translated">&lt;code&gt;:warn&lt;/code&gt; -경고</target>
        </trans-unit>
        <trans-unit id="8897349b08555a476d4d32bf64bf637a91daee5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:warn_on_unnecessary_quotes&lt;/code&gt; - when &lt;code&gt;false&lt;/code&gt;, does not warn when atoms, keywords or calls have unnecessary quotes on them. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:warn_on_unnecessary_quotes&lt;/code&gt; - &lt;code&gt;false&lt;/code&gt; 인 경우 원자, 키워드 또는 호출에 불필요한 인용 부호가있는 경우 경고하지 않습니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b142347ad2985921b40e9d4f2b41f245a5ea2680" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:warn_test_pattern&lt;/code&gt; - a pattern to match potentially misnamed test files and display a warning. Defaults to &lt;code&gt;*_test.ex&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:warn_test_pattern&lt;/code&gt; - 이름이 잘못 지정된 테스트 파일과 일치하고 경고를 표시하는 패턴입니다. 기본값은 &lt;code&gt;*_test.ex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b69954b8616460123488d7e49e31c3f41ede8d95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:warnings_as_errors&lt;/code&gt; - causes compilation to fail when warnings are generated. Defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:warnings_as_errors&lt;/code&gt; - 경고가 생성 될 때 컴파일이 실패합니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bf0388681f52d7a3593391ced5d12986df6c7ec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:width&lt;/code&gt; - defaults to 80 characters, used when pretty is &lt;code&gt;true&lt;/code&gt; or when printing to IO devices. Set to 0 to force each item to be printed on its own line. If you don't want to limit the number of items to a particular number, use &lt;code&gt;:infinity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:width&lt;/code&gt; - 기본값은 80 자이며 pretty가 &lt;code&gt;true&lt;/code&gt; 이거나 IO 장치로 인쇄 할 때 사용됩니다 . 각 항목을 자체 행에 인쇄하려면 0으로 설정하십시오. 항목 수를 특정 수로 제한하지 않으려면 &lt;code&gt;:infinity&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7d69d648c9f7b6c21f4f63f8b22f6cb9790f034" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:workers&lt;/code&gt; - the count of all workers, whether or not the child process is still alive</source>
          <target state="translated">&lt;code&gt;:workers&lt;/code&gt; - 하위 프로세스가 여전히 존재하는지 여부에 관계없이 모든 작업자 수</target>
        </trans-unit>
        <trans-unit id="334cc70397dfdbf2e8f49b9a5c8da45b65cfee84" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:workers&lt;/code&gt; - the count of all workers, whether or not these child workers are still alive</source>
          <target state="translated">&lt;code&gt;:workers&lt;/code&gt; -이 아동 근로자가 아직 살아 있는지 여부에 관계없이 모든 근로자의 수</target>
        </trans-unit>
        <trans-unit id="0f80205292677fed0fe9f8b3f5a559aeecfd0ac9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:write&lt;/code&gt; - the file is opened for writing. It is created if it does not exist.</source>
          <target state="translated">&lt;code&gt;:write&lt;/code&gt; - 파일이 쓰기 위해 열립니다. 존재하지 않는 경우 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="09715b1f90ef6627a93d9acfa01177825316b0eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;:yecc_options&lt;/code&gt; - compilation options that apply to Yecc's compiler.</source>
          <target state="translated">&lt;code&gt;:yecc_options&lt;/code&gt; -Yecc의 컴파일러에 적용되는 컴파일 옵션.</target>
        </trans-unit>
        <trans-unit id="0fefd30d847d0341dd6b85fb040758a0c5fb2fc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;=&amp;gt;&lt;/code&gt; (valid syntax only inside &lt;code&gt;%{}&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;=&amp;gt;&lt;/code&gt; ( &lt;code&gt;%{}&lt;/code&gt; 내에서만 유효한 구문 )</target>
        </trans-unit>
        <trans-unit id="f772920ee2b8149ecd45efca6c94a408441c5967" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;==&lt;/code&gt;&lt;code&gt;!=&lt;/code&gt;&lt;code&gt;=~&lt;/code&gt;&lt;code&gt;===&lt;/code&gt;&lt;code&gt;!==&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt;&lt;code&gt;!=&lt;/code&gt;&lt;code&gt;=~&lt;/code&gt;&lt;code&gt;===&lt;/code&gt;&lt;code&gt;!==&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30dbfa13a150bcf3624e9ca02561b827e1f10970" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?&lt;/code&gt; - matches one character.</source>
          <target state="translated">&lt;code&gt;?&lt;/code&gt; -한 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8fff3a404ea676594d737e706c90d88f4f595921" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?\a&lt;/code&gt; - Bell</source>
          <target state="translated">&lt;code&gt;?\a&lt;/code&gt; a-벨</target>
        </trans-unit>
        <trans-unit id="613f9bcb89eecba54532c8aaec33df641326ae00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?\b&lt;/code&gt; - Backspace</source>
          <target state="translated">&lt;code&gt;?\b&lt;/code&gt; 백 스페이스</target>
        </trans-unit>
        <trans-unit id="e5ecf6f761279616c3d32f47521aec8133a4e290" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?\e&lt;/code&gt; - Escape</source>
          <target state="translated">&lt;code&gt;?\e&lt;/code&gt; 탈출</target>
        </trans-unit>
        <trans-unit id="39d2d4d0c7cc57ab6723bacaa43078296d967029" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?\f&lt;/code&gt; - Form feed</source>
          <target state="translated">&lt;code&gt;?\f&lt;/code&gt; 양식 피드</target>
        </trans-unit>
        <trans-unit id="23e3f2abd16162eb807b9232767c5ace80662783" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?\n&lt;/code&gt; - Line feed</source>
          <target state="translated">&lt;code&gt;?\n&lt;/code&gt; 줄 바꿈</target>
        </trans-unit>
        <trans-unit id="95a05724bb974cbfc0c47983a4723149096071b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?\r&lt;/code&gt; - Carriage return</source>
          <target state="translated">&lt;code&gt;?\r&lt;/code&gt; 캐리지 리턴</target>
        </trans-unit>
        <trans-unit id="bca888af28a2983a4c7577d14529f75cf25fb175" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?\t&lt;/code&gt; - Horizontal tab</source>
          <target state="translated">&lt;code&gt;?\t&lt;/code&gt; 가로 탭</target>
        </trans-unit>
        <trans-unit id="df9cea6c334078b1be9dce7f59ef87281fa242d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;?\v&lt;/code&gt; - Vertical tab</source>
          <target state="translated">&lt;code&gt;?\v&lt;/code&gt; 세로 탭</target>
        </trans-unit>
        <trans-unit id="37a3265ca91a672634680057bcfb31fce197ab8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@before_compile&lt;/code&gt; - provides a hook that will be invoked before the module is compiled. This makes it possible to inject functions inside the module exactly before compilation.</source>
          <target state="translated">&lt;code&gt;@before_compile&lt;/code&gt; - 모듈이 컴파일되기 전에 호출 될 후크를 제공합니다. 이를 통해 컴파일 직전에 모듈 내부에 함수를 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5006c789ded71d15ca28be2b24956a998969c02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@behaviour&lt;/code&gt; - (notice the British spelling) used for specifying an</source>
          <target state="translated">&lt;code&gt;@behaviour&lt;/code&gt; - 영국식 철자에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="a27e3e245e0b9d802a39440f4800291c27791121" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@callback&lt;/code&gt; - provides a specification for a behaviour callback</source>
          <target state="translated">&lt;code&gt;@callback&lt;/code&gt; callback-행동 콜백에 대한 사양을 제공합니다</target>
        </trans-unit>
        <trans-unit id="2b99fba722dcddee5b4e812a35c1a4ae382006f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@callback&lt;/code&gt; module attribute (v1.0)</source>
          <target state="translated">&lt;code&gt;@callback&lt;/code&gt; 모듈 속성 (v1.0)</target>
        </trans-unit>
        <trans-unit id="d3ad364f188f9d6529caf420bd702cacfcfd7c8b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@compile :debug_info&lt;/code&gt; - includes &lt;code&gt;:debug_info&lt;/code&gt; regardless of the corresponding setting in &lt;a href=&quot;code#compiler_options/1&quot;&gt;&lt;code&gt;Code.compiler_options/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;@compile :debug_info&lt;/code&gt; - &lt;a href=&quot;code#compiler_options/1&quot;&gt; &lt;code&gt;Code.compiler_options/1&lt;/code&gt; &lt;/a&gt; 의 해당 설정에 관계없이 &lt;code&gt;:debug_info&lt;/code&gt; 포함</target>
        </trans-unit>
        <trans-unit id="5910f1418f6efbba1a18f2905a498692fe1df693" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@compile {:autoload, false}&lt;/code&gt; - disables automatic loading of modules after compilation. Instead, the module will be loaded after it is dispatched to</source>
          <target state="translated">&lt;code&gt;@compile {:autoload, false}&lt;/code&gt; -컴파일 후 모듈 자동로드를 비활성화합니다. 대신에 모듈이 전달 된 후로드됩니다.</target>
        </trans-unit>
        <trans-unit id="0389a458fd16e5d2ea5409d9cccc30f2ad04f1c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@compile {:debug_info, false}&lt;/code&gt; - disables &lt;code&gt;:debug_info&lt;/code&gt; regardless of the corresponding setting in &lt;a href=&quot;code#compiler_options/1&quot;&gt;&lt;code&gt;Code.compiler_options/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;@compile {:debug_info, false}&lt;/code&gt; &lt;a href=&quot;code#compiler_options/1&quot;&gt; &lt;code&gt;Code.compiler_options/1&lt;/code&gt; &lt;/a&gt; 의 해당 설정에 관계없이 &lt;code&gt;:debug_info&lt;/code&gt; 를 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="97e47694ebddaaa4418902dea32c44caad53bf34" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@compile {:inline, some_fun: 2, other_fun: 3}&lt;/code&gt; - inlines the given name/arity pairs. Inlining is applied locally, calls from another module are not affected by this option</source>
          <target state="translated">&lt;code&gt;@compile {:inline, some_fun: 2, other_fun: 3}&lt;/code&gt; -주어진 이름 / 배열 쌍을 인라인합니다. 인라인이 로컬로 적용되고 다른 모듈의 통화는이 옵션의 영향을받지 않습니다</target>
        </trans-unit>
        <trans-unit id="77e73a5ef9dce8313d7bfd5b64cbcbaee21df0a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@compile {:parse_transform, _}&lt;/code&gt; in &lt;a href=&quot;module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;@compile {:parse_transform, _}&lt;/code&gt; 에서 &lt;a href=&quot;module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e96152207ec3eb21d84903fe60382b1b081d4289" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@doc&lt;/code&gt; - provides documentation for the function or macro that follows the attribute.</source>
          <target state="translated">&lt;code&gt;@doc&lt;/code&gt; - 속성 뒤에 오는 함수 또는 매크로에 대한 설명서를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f15234e54e9e652b13174cfaa49be965b1680a5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@doc&lt;/code&gt; and &lt;code&gt;@typedoc&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@doc&lt;/code&gt; 와 &lt;code&gt;@typedoc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="59af86a43d50330626df1552fc92e1a38a7fb747" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@doc&lt;/code&gt; module attribute (v1.0)</source>
          <target state="translated">&lt;code&gt;@doc&lt;/code&gt; 모듈 속성 (v1.0)</target>
        </trans-unit>
        <trans-unit id="934e98fc755a06331804d907ade934513ee502fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@impl&lt;/code&gt; - declares an implementation of a callback function or macro</source>
          <target state="translated">&lt;code&gt;@impl&lt;/code&gt; - 콜백 함수 또는 매크로의 구현을 선언</target>
        </trans-unit>
        <trans-unit id="17819c89ee896cbaf7bd2d2e886773c6fce57eec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@impl&lt;/code&gt; also helps with maintainability by making it clear to other developers that the function is implementing a callback.</source>
          <target state="translated">&lt;code&gt;@impl&lt;/code&gt; 은 또한 함수가 콜백을 구현하고 있음을 다른 개발자에게 명확하게함으로써 유지 보수성 을 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="a88e78800c83e0b772a5ac19b1fe178e99242f3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@impl&lt;/code&gt; works on a per-context basis. If you generate a function through a macro and mark it with &lt;code&gt;@impl&lt;/code&gt;, that won't affect the module where that function is generated in.</source>
          <target state="translated">&lt;code&gt;@impl&lt;/code&gt; 은 상황에 따라 작동합니다. 매크로를 통해 함수를 생성하고 &lt;code&gt;@impl&lt;/code&gt; 로 표시하면 해당 함수가 생성되는 모듈에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f2bccc6948542760dcd3c3f6f7b7199679e2fa95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@macrocallback&lt;/code&gt; - provides a specification for a macro behaviour callback</source>
          <target state="translated">&lt;code&gt;@macrocallback&lt;/code&gt; - 매크로 비헤이비어 콜백에 대한 사양을 제공합니다</target>
        </trans-unit>
        <trans-unit id="381a38bb94c99bb9edf99588bac350cd814a717c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@moduledoc&lt;/code&gt; - provides documentation for the current module.</source>
          <target state="translated">&lt;code&gt;@moduledoc&lt;/code&gt; - 현재 모듈에 대한 설명서를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="437861897b2e92f1b4983b067489afc4d19b2f7c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@moduledoc&lt;/code&gt; and &lt;code&gt;@doc&lt;/code&gt; are by far the most used attributes, and we expect you to use them a lot. Elixir treats documentation as first-class and provides many functions to access documentation. You can read more about &lt;a href=&quot;https://hexdocs.pm/elixir/writing-documentation.html&quot;&gt;writing documentation in Elixir in our official documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@moduledoc&lt;/code&gt; 및 &lt;code&gt;@doc&lt;/code&gt; 은 가장 많이 사용되는 속성이므로 많은 속성을 사용해야합니다. Elixir는 문서를 일류로 취급하고 문서에 액세스하기위한 많은 기능을 제공합니다. &lt;a href=&quot;https://hexdocs.pm/elixir/writing-documentation.html&quot;&gt;Elixir의 문서 작성&lt;/a&gt; 에 대한 자세한 내용은 공식 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="451e2829b6a116284e15823242417d31cdf4fd8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@opaque&lt;/code&gt; - defines an opaque type to be used in &lt;code&gt;@spec&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@opaque&lt;/code&gt; -에 사용되는 불투명 한 형을 정의 &lt;code&gt;@spec&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="85a017da91a01cbf5dc930c0f088328c5e12a293" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@optional_callbacks&lt;/code&gt; - specifies which behaviour callbacks and macro behaviour callbacks are optional</source>
          <target state="translated">&lt;code&gt;@optional_callbacks&lt;/code&gt; optional_callbacks-선택적인 행동 콜백 및 매크로 행동 콜백을 지정합니다</target>
        </trans-unit>
        <trans-unit id="07bf37b9ee7e6e2d160fd237b741b014ae960ecb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@preferred_cli_env&lt;/code&gt; - recommends environment to run task. It is used in absence of a Mix project recommendation, or explicit &lt;code&gt;MIX_ENV&lt;/code&gt;, and it only works for tasks in the current project. &lt;code&gt;@preferred_cli_env&lt;/code&gt; is not loaded from dependencies as we need to know the environment before dependencies are loaded.</source>
          <target state="translated">&lt;code&gt;@preferred_cli_env&lt;/code&gt; - 작업을 실행할 환경을 권장합니다. Mix 프로젝트 권장 사항 또는 명시적인 &lt;code&gt;MIX_ENV&lt;/code&gt; 없이 사용 되며 현재 프로젝트의 태스크에만 작동합니다. 종속성이로드되기 전에 환경을 알아야하기 때문에 &lt;code&gt;@preferred_cli_env&lt;/code&gt; 는 종속성에서로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca908949bd667b235800ff24cb022d02b2c7b22f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@recursive&lt;/code&gt; - runs the task recursively in umbrella projects</source>
          <target state="translated">&lt;code&gt;@recursive&lt;/code&gt; recursive-우산 프로젝트에서 작업을 재귀 적으로 실행합니다</target>
        </trans-unit>
        <trans-unit id="cbfdcfb85b0218f0ecbce848006d6e4018957214" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@shortdoc&lt;/code&gt; - makes the task public with a short description that appears on &lt;a href=&quot;mix.tasks.help&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;@shortdoc&lt;/code&gt; -&lt;a href=&quot;mix.tasks.help&quot;&gt; &lt;code&gt;mix help&lt;/code&gt; &lt;/a&gt; 나타나는 간단한 설명으로 작업을 공개합니다</target>
        </trans-unit>
        <trans-unit id="efee48c5a9b83b5d61138f95175ab7ba3a1452ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@spec&lt;/code&gt; - provides a specification for a function</source>
          <target state="translated">&lt;code&gt;@spec&lt;/code&gt; - 함수에 대한 사양을 제공합니다</target>
        </trans-unit>
        <trans-unit id="158af346d3f53b1378f06a1d8efff2de54c7e218" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@type&lt;/code&gt; - defines a type to be used in &lt;code&gt;@spec&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@type&lt;/code&gt; -에 사용되는 유형 정의 &lt;code&gt;@spec&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="0d93ce7d4632d38027a52a9295a9a40662cdf05f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@typep&lt;/code&gt; - defines a private type to be used in &lt;code&gt;@spec&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;@typep&lt;/code&gt; -에 사용되는 개인 형을 정의 &lt;code&gt;@spec&lt;/code&gt; 을</target>
        </trans-unit>
        <trans-unit id="be2c80ff23d06188671d40d1e4258d13bb6998da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Any&lt;/code&gt; (see below)</source>
          <target state="translated">&lt;code&gt;Any&lt;/code&gt; (아래 참조)</target>
        </trans-unit>
        <trans-unit id="cab1a8a7a7f40a3fa2c2093e4a4bbf8aec7bfe18" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;C:\TMP&lt;/code&gt; on Windows or &lt;code&gt;/tmp&lt;/code&gt; on Unix</source>
          <target state="translated">&lt;code&gt;C:\TMP&lt;/code&gt; Windows의 경우 C : \ TMP 또는 Unix의 경우 &lt;code&gt;/tmp&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="83b7688814bc4bb8e003a5dec38f284a5a872dd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CoverModule&lt;/code&gt; can be any module that exports &lt;code&gt;start/2&lt;/code&gt;, receiving the compilation path and the &lt;code&gt;test_coverage&lt;/code&gt; options as arguments. It must return either &lt;code&gt;nil&lt;/code&gt; or an anonymous function of zero arity that will be run after the test suite is done.</source>
          <target state="translated">&lt;code&gt;CoverModule&lt;/code&gt; 은 &lt;code&gt;start/2&lt;/code&gt; 를 내보내고 컴파일 경로 및 &lt;code&gt;test_coverage&lt;/code&gt; 옵션을 인수로 받는 모든 모듈 일 수 있습니다 . 테스트 스위트가 완료된 후 실행될 &lt;code&gt;nil&lt;/code&gt; 또는 익명 성이 0 인 익명 함수를 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ac3a6bcf59cce82a9597afb726db205333f00d59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DynamicSupervisor.start_child/2&lt;/code&gt; expects the name of the supervisor and the child specification of the child to be started.</source>
          <target state="translated">&lt;code&gt;DynamicSupervisor.start_child/2&lt;/code&gt; 는 감독자의 이름과 자식의 자식 사양이 시작될 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="4be1d465a033470e0d13e03f803f35a23df2fbc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ERL_COMPILER_OPTIONS&lt;/code&gt; - can be used to give default compile options. The value must be a valid Erlang term. If the value is a list, it will be used as is. If it is not a list, it will be put into a list.</source>
          <target state="translated">&lt;code&gt;ERL_COMPILER_OPTIONS&lt;/code&gt; - 기본 컴파일 옵션을 제공하는 데 사용할 수 있습니다. 값은 유효한 Erlang 용어 여야합니다. 값이 목록이면 그대로 사용됩니다. 목록이 아닌 경우 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6f324bdba6e17d20eaca2ae660b30254ca8ff092" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Enum.chunk/2&lt;/code&gt;&lt;a href=&quot;%60enum.chunk/4%60&quot;&gt;&lt;code&gt;/3/4&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;Enum.chunk/2&lt;/code&gt;&lt;a href=&quot;%60enum.chunk/4%60&quot;&gt;&lt;code&gt;/3/4&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed541833a5f66414f125983720593b8ffac0eb96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IEx.pry/0&lt;/code&gt; and &lt;code&gt;IEx.break!/2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;IEx.pry/0&lt;/code&gt; 및 &lt;code&gt;IEx.break!/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="22c577ef1c31238772ee8831a83e168e224b3891" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IO.inspect/2&lt;/code&gt; also provides the ability to decorate the output with a &lt;code&gt;label&lt;/code&gt; option. The label will be printed before the inspected &lt;code&gt;item&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;IO.inspect/2&lt;/code&gt; 는 &lt;code&gt;label&lt;/code&gt; 옵션으로 출력을 꾸미는 기능도 제공합니다 . 검사 된 &lt;code&gt;item&lt;/code&gt; 전에 라벨이 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab245843059173dbf82eb4fe6e1efb8953b384a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KVServer.Command.run/1&lt;/code&gt;&amp;rsquo;s implementation is sending commands directly to the server named &lt;code&gt;KV.Registry&lt;/code&gt;, which is registered by the &lt;code&gt;:kv&lt;/code&gt; application. This means this server is global and if we have two tests sending messages to it at the same time, our tests will conflict with each other (and likely fail). We need to decide between having unit tests that are isolated and can run asynchronously, or writing integration tests that work on top of the global state, but exercise our application&amp;rsquo;s full stack as it is meant to be exercised in production.</source>
          <target state="translated">&lt;code&gt;KVServer.Command.run/1&lt;/code&gt; 의 구현은 &lt;code&gt;:kv&lt;/code&gt; 애플리케이션에 의해 등록 된 &lt;code&gt;KV.Registry&lt;/code&gt; 라는 서버로 직접 명령을 전송합니다 . 이는이 서버가 글로벌 서버임을 의미하며 동시에 두 개의 테스트 메시지를 보내는 테스트가 있으면 테스트가 서로 충돌하여 실패 할 수 있습니다. 격리되고 비동기 적으로 실행될 수있는 단위 테스트를 수행하거나 전역 상태에서 작동하는 통합 테스트를 작성해야할지 결정해야하지만 프로덕션 환경에서 응용 프로그램의 전체 스택을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="da6d4153744f3433ed1a5402789f34e812c03af1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_ARCHIVES&lt;/code&gt; - specifies the directory into which the archives should be installed</source>
          <target state="translated">&lt;code&gt;MIX_ARCHIVES&lt;/code&gt; - 아카이브를 설치할 디렉토리를 지정합니다</target>
        </trans-unit>
        <trans-unit id="9e3878570d540f1dc8a3f3f892fd2b11f01cccaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_BUILD_PATH&lt;/code&gt; - sets the project build_path config</source>
          <target state="translated">&lt;code&gt;MIX_BUILD_PATH&lt;/code&gt; - 프로젝트 build_path 설정을 설정</target>
        </trans-unit>
        <trans-unit id="0140498ebd7646b788b6566801c7befbab061cb9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_DEBUG&lt;/code&gt; - outputs debug information about each task before running it</source>
          <target state="translated">&lt;code&gt;MIX_DEBUG&lt;/code&gt; - 각 작업을 실행하기 전에 디버그 정보를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="329ed8db0c467fa57966c2408385f46d68602c32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_ENV&lt;/code&gt; - specifies which environment should be used. See &lt;a href=&quot;#module-environments&quot;&gt;Environments&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;MIX_ENV&lt;/code&gt; - 사용해야하는 환경을 지정합니다. &lt;a href=&quot;#module-environments&quot;&gt;환경&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="2d50621b63f1f2c2227991dd4eff2fd82684592f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_EXS&lt;/code&gt; - changes the full path to the &lt;code&gt;mix.exs&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;MIX_EXS&lt;/code&gt; - &lt;code&gt;mix.exs&lt;/code&gt; 파일 의 전체 경로를 변경 합니다</target>
        </trans-unit>
        <trans-unit id="0c7e96e7109921de42973a61dead2b979ac90fe0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_HOME&lt;/code&gt; - path to Mix's home directory, stores configuration files and scripts used by Mix</source>
          <target state="translated">&lt;code&gt;MIX_HOME&lt;/code&gt; -Mix의 홈 디렉토리 경로, Mix가 사용하는 구성 파일 및 스크립트 저장</target>
        </trans-unit>
        <trans-unit id="553587fa68acdae7dd360d62677c233b8de4b6a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_PATH&lt;/code&gt; - appends extra code paths</source>
          <target state="translated">&lt;code&gt;MIX_PATH&lt;/code&gt; - 추가 코드 경로 추가</target>
        </trans-unit>
        <trans-unit id="e5e1141c719d2a85373ac124af8fe76e6cceea81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_QUIET&lt;/code&gt; - does not print information messages to the terminal</source>
          <target state="translated">&lt;code&gt;MIX_QUIET&lt;/code&gt; - 터미널에 정보 메시지를 인쇄하지 않습니다</target>
        </trans-unit>
        <trans-unit id="7254592f8891c8c6dd40bd7299fc6ec41c04871d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_REBAR3&lt;/code&gt; - path to rebar3 command that overrides the one Mix installs</source>
          <target state="translated">&lt;code&gt;MIX_REBAR3&lt;/code&gt; - 믹스 설치를 재정의하는 rebar3 명령의 경로</target>
        </trans-unit>
        <trans-unit id="06ea93f78b26d8cfb7ce48134404d1f745e0f50b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_REBAR&lt;/code&gt; - path to rebar command that overrides the one Mix installs</source>
          <target state="translated">&lt;code&gt;MIX_REBAR&lt;/code&gt; - 믹스 설치를 재정의하는 철근 명령 경로</target>
        </trans-unit>
        <trans-unit id="9971767c5036a2608426896f053fa0cf39812d0a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIX_TARGET&lt;/code&gt; - specifies which target should be used. See &lt;a href=&quot;#module-targets&quot;&gt;Targets&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;MIX_TARGET&lt;/code&gt; - 사용해야하는 대상을 지정합니다. &lt;a href=&quot;#module-targets&quot;&gt;대상&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="3d25413013d7642f8cf841919f8270de1f43ed5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Macro.expand_once/2&lt;/code&gt; receives a quoted expression and expands it according to the current environment. In this case, it expanded/invoked the &lt;code&gt;Unless.macro_unless/2&lt;/code&gt; macro and returned its result. We then proceeded to convert the returned quoted expression to a string and print it (we will talk about &lt;code&gt;__ENV__&lt;/code&gt; later in this chapter).</source>
          <target state="translated">&lt;code&gt;Macro.expand_once/2&lt;/code&gt; 는 인용 된 표현식을 수신하여 현재 환경에 따라 확장합니다. 이 경우 &lt;code&gt;Unless.macro_unless/2&lt;/code&gt; 매크로를 확장 / 호출 하고 결과를 반환했습니다. 그런 다음 반환 된 인용 식을 문자열로 변환하고 인쇄합니다 ( 이 장의 뒷부분 에 &lt;code&gt;__ENV__&lt;/code&gt; 에 대해 이야기하겠습니다 ).</target>
        </trans-unit>
        <trans-unit id="3fc6929a951f92925b08e51e26456aa3d1b43853" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Stream.chunk/2&lt;/code&gt;&lt;a href=&quot;%60stream.chunk/4%60&quot;&gt;&lt;code&gt;/3/4&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;Stream.chunk/2&lt;/code&gt;&lt;a href=&quot;%60stream.chunk/4%60&quot;&gt;&lt;code&gt;/3/4&lt;/code&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c79ae2e0183612283b4bdd763f31738afe6b32e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String.ljust/3&lt;/code&gt; and &lt;code&gt;String.rjust/3&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String.ljust/3&lt;/code&gt; 및 &lt;code&gt;String.rjust/3&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d6971e188b1f5ca6887f36a1aabb3d9f4803817" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String.lstrip/1&lt;/code&gt; and &lt;code&gt;String.rstrip/1&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String.lstrip/1&lt;/code&gt; 및 &lt;code&gt;String.rstrip/1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4f8fac69d745e565219ca9c212f205a839b4d94" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String.lstrip/2&lt;/code&gt; and &lt;code&gt;String.rstrip/2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String.lstrip/2&lt;/code&gt; 및 &lt;code&gt;String.rstrip/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3dba6d3f4606546ef740ff6427a2da28113bd080" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;String.strip/1&lt;/code&gt; and &lt;code&gt;String.strip/2&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;String.strip/1&lt;/code&gt; 및 &lt;code&gt;String.strip/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd32067781123d89c1ac8e4f997b876beb9c3863" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; is capable of building a child specification from a given module and/or tuple, and it also accepts values that override the underlying child specification. Now we have an always running acceptor that starts temporary task processes under an always running task supervisor.</source>
          <target state="translated">&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; 는 주어진 모듈 및 / 또는 튜플에서 하위 사양을 작성할 수 있으며 기본 하위 사양을 재정의하는 값도 허용합니다. 이제 항상 실행중인 작업 관리자에서 임시 작업 프로세스를 시작하는 항상 실행중인 수락자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad77d229f6cbfcafcb4f7741c0dc27b0f4b740b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt; 와 &lt;code&gt;]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="088aa7cd9bf1e6a8427fd52deb0693f6c10b18ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[char1,char2,...]&lt;/code&gt; - matches any of the characters listed; two characters separated by a hyphen will match a range of characters. Do not add spaces before and after the comma as it would then match paths containing the space character itself.</source>
          <target state="translated">&lt;code&gt;[char1,char2,...]&lt;/code&gt; -나열된 문자와 일치합니다. 하이픈으로 구분 된 두 문자는 문자 범위와 일치합니다. 공백 문자 자체를 포함하는 경로와 일치하므로 쉼표 앞뒤에 공백을 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="39c640871ce2526ab4fa5310ef6480273c950ee4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\0&lt;/code&gt; - null byte</source>
          <target state="translated">&lt;code&gt;\0&lt;/code&gt; 널 바이트</target>
        </trans-unit>
        <trans-unit id="65ed13dac56222bcbf8e3e216b956a7a2244b177" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\\&lt;/code&gt; &amp;ndash; single backslash</source>
          <target state="translated">&lt;code&gt;\\&lt;/code&gt; &amp;ndash; 단일 백 슬래시</target>
        </trans-unit>
        <trans-unit id="b174b497cb3a1cc6880a9950599e3a0b77cab5ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\\&lt;/code&gt; is used to specify a default value for a parameter of a function. For example:</source>
          <target state="translated">&lt;code&gt;\\&lt;/code&gt; 는 함수의 매개 변수에 대한 기본값을 지정하는 데 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f9d9ffe5a9bac743656529800fff03c95336241" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\a&lt;/code&gt; &amp;ndash; bell/alert</source>
          <target state="translated">&lt;code&gt;\a&lt;/code&gt; &amp;ndash; 종 / 경고</target>
        </trans-unit>
        <trans-unit id="14886ebc85cca038dec60a61c0e91b8b4ead61c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\b&lt;/code&gt; &amp;ndash; backspace</source>
          <target state="translated">&lt;code&gt;\b&lt;/code&gt; &amp;ndash; 백 스페이스</target>
        </trans-unit>
        <trans-unit id="0bb4d977ed1327929c1a92021eb0613308fd0ef9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\d&lt;/code&gt; - delete</source>
          <target state="translated">&lt;code&gt;\d&lt;/code&gt; 삭제</target>
        </trans-unit>
        <trans-unit id="ccb79b2d6e647a0cac1fd9c56eabf463190b35ef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\e&lt;/code&gt; - escape</source>
          <target state="translated">&lt;code&gt;\e&lt;/code&gt; 탈출</target>
        </trans-unit>
        <trans-unit id="7df87f44b5903cdd4ae86383ef920d5afcb83fd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\f&lt;/code&gt; - form feed</source>
          <target state="translated">&lt;code&gt;\f&lt;/code&gt; 양식 피드</target>
        </trans-unit>
        <trans-unit id="74c29c02b88f493e0b8a40781b5dd5c63d7f01bc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\n&lt;/code&gt; &amp;ndash; newline</source>
          <target state="translated">&lt;code&gt;\n&lt;/code&gt; &amp;ndash; 줄 바꿈</target>
        </trans-unit>
        <trans-unit id="f63d66cab57190093b88defb77e6fab011870475" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\r&lt;/code&gt; &amp;ndash; carriage return</source>
          <target state="translated">&lt;code&gt;\r&lt;/code&gt; &amp;ndash; 캐리지 리턴</target>
        </trans-unit>
        <trans-unit id="0a1c5bdfb07d4e036fe4810e5550d502e2f30408" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\s&lt;/code&gt; &amp;ndash; space</source>
          <target state="translated">&lt;code&gt;\s&lt;/code&gt; &amp;ndash; 공간</target>
        </trans-unit>
        <trans-unit id="547d5d52bd4fa577be6f348f6604137b954496a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\t&lt;/code&gt; &amp;ndash; tab</source>
          <target state="translated">&lt;code&gt;\t&lt;/code&gt; &amp;ndash; 탭</target>
        </trans-unit>
        <trans-unit id="736c96e8078aabb67ae94f12f2958e5765eb382c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\uDDDD&lt;/code&gt; and &lt;code&gt;\u{D...}&lt;/code&gt; - represents a Unicode codepoint in hexadecimal (such as &lt;code&gt;\u{1F600}&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;\uDDDD&lt;/code&gt; 및 &lt;code&gt;\u{D...}&lt;/code&gt; -16 진수로 된 유니 코드 코드 포인트를 나타냅니다 (예 : &lt;code&gt;\u{1F600}&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="46eb12f311d0fe7aa10c40fac2213a97f6692013" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\uXXXX&lt;/code&gt; or &lt;code&gt;\u{X*}&lt;/code&gt; (v1.1)</source>
          <target state="translated">&lt;code&gt;\uXXXX&lt;/code&gt; 또는 &lt;code&gt;\u{X*}&lt;/code&gt; (v1.1)</target>
        </trans-unit>
        <trans-unit id="c0b1167bef21cda9a624d04841f631aeb54af646" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\v&lt;/code&gt; &amp;ndash; vertical tab</source>
          <target state="translated">&lt;code&gt;\v&lt;/code&gt; &amp;ndash; 세로 탭</target>
        </trans-unit>
        <trans-unit id="38a8f23f2eb09ba8af053d2c20b167de36d6466a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\xDD&lt;/code&gt; - represents a single byte in hexadecimal (such as &lt;code&gt;\x13&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;\xDD&lt;/code&gt; -16 진수로 단일 바이트를 나타냅니다 (예 : &lt;code&gt;\x13&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3210dc14496231e2d2fc4514864f15323c30fdbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;\x{X*}&lt;/code&gt; inside strings/sigils/charlists</source>
          <target state="translated">&lt;code&gt;\x{X*}&lt;/code&gt; 문자열 / sigils / charlists 내부의 \ x {X *}</target>
        </trans-unit>
        <trans-unit id="3cde9d9e85c4c0b53108719f116e97eb679ac877" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__ENV__&lt;/code&gt; returns an instance of the &lt;code&gt;Macro.Env&lt;/code&gt; struct which contains useful information about the compilation environment, including the current module, file, and line, all variables defined in the current scope, as well as imports, requires and so on:</source>
          <target state="translated">&lt;code&gt;__ENV__&lt;/code&gt; 는 현재 모듈, 파일 및 줄, 현재 범위에 정의 된 모든 변수 및 가져 오기 등의 컴파일 환경에 대한 유용한 정보가 포함 된 &lt;code&gt;Macro.Env&lt;/code&gt; 구조체 의 인스턴스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e61733caa542452527b202971f1b67c6052df9a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__protocol__/1&lt;/code&gt; - returns the protocol information. The function takes one of the following atoms:</source>
          <target state="translated">&lt;code&gt;__protocol__/1&lt;/code&gt; 프로토콜 정보를 반환합니다. 이 함수는 다음 원자 중 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ead78218949f957d38127d6c0b9181cecc79bdc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__using__/1&lt;/code&gt; is typically used when there is a need to set some state (via module attributes) or callbacks (like &lt;code&gt;@before_compile&lt;/code&gt;, see the documentation for &lt;a href=&quot;module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; for more information) into the caller.</source>
          <target state="translated">&lt;code&gt;__using__/1&lt;/code&gt; 은 일반적으로 호출자 에게 상태 (모듈 속성을 통해) 또는 콜백 ( &lt;code&gt;@before_compile&lt;/code&gt; 과 같은 자세한 내용 은 &lt;a href=&quot;module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt; 설명서 참조 )을 설정해야 할 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="18fec841d33b1eed5707722ba145fa8e46469457" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;__using__/1&lt;/code&gt; may also be used to alias, require, or import functionality from different modules:</source>
          <target state="translated">&lt;code&gt;__using__/1&lt;/code&gt; 사용하여 다른 모듈에서 기능을 별칭으로 지정하거나 요구하거나 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5888cfe9b0257d8c48e3413d54a04e07ef4f2f2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt;: words in the list are atoms</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; : 목록의 단어는 원자입니다</target>
        </trans-unit>
        <trans-unit id="5dd0df57ca13d192483ae4afa8ee7dcd66ac716e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;access&lt;/code&gt; - &lt;code&gt;:read | :write | :read_write | :none&lt;/code&gt;; the current system access to the file.</source>
          <target state="translated">&lt;code&gt;access&lt;/code&gt; - &lt;code&gt;:read | :write | :read_write | :none&lt;/code&gt; ; 파일에 대한 현재 시스템 액세스</target>
        </trans-unit>
        <trans-unit id="5bf576af207250aae2f10f4b1a3367c771a70828" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;after&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;after&lt;/code&gt; 절</target>
        </trans-unit>
        <trans-unit id="8e3d214af6b3554314446ba0e18e374c3577cbda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;after_fun&lt;/code&gt; is invoked when iteration is done and must also return &lt;code&gt;{:cont, element, acc}&lt;/code&gt; or &lt;code&gt;{:cont, acc}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;after_fun&lt;/code&gt; 은 반복이 수행 될 때 호출되며 &lt;code&gt;{:cont, element, acc}&lt;/code&gt; 또는 &lt;code&gt;{:cont, acc}&lt;/code&gt; 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="72b02de91b9af39aa2a7c9496b9788f7c36c0544" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;alias&lt;/code&gt; allows you to set up aliases for any given module name.</source>
          <target state="translated">&lt;code&gt;alias&lt;/code&gt; 를 사용하면 지정된 모듈 이름에 대한 별칭을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c880b6a07ca827b5812f7f974a1fcacab19aaf4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aliases&lt;/code&gt; - a list of two-element tuples, where the first element is the aliased name and the second one the actual name</source>
          <target state="translated">&lt;code&gt;aliases&lt;/code&gt; - 두 요소 튜플의 목록. 첫 번째 요소는 별명 이며 두 번째 요소는 실제 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8d4e8eef689e82c072f90c3d43dbd352d218bf09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;anchored&lt;/code&gt; - not available, use &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;\A&lt;/code&gt; instead</source>
          <target state="translated">&lt;code&gt;anchored&lt;/code&gt; -사용할 수 없음, 대신 &lt;code&gt;^&lt;/code&gt; 또는 &lt;code&gt;\A&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="4458fc9a4b25b25b5a15d3aebebe9b878cfddf7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arg&lt;/code&gt; is passed as the argument to &lt;a href=&quot;task#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;:start&lt;/code&gt; field of the spec.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 는 사양 의 &lt;code&gt;:start&lt;/code&gt; 필드 에서 &lt;a href=&quot;task#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; &lt;/a&gt; 에 인수로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="d15eca1e275872ac68dbab33a4fcdc7d4900f368" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arg&lt;/code&gt; must be a boolean; if it's not, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">&lt;code&gt;arg&lt;/code&gt; 는 부울이어야합니다. 그렇지 않으면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c766db9327568eebb91c2c7ede208193b9693614" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; is a list of the remaining arguments in &lt;code&gt;argv&lt;/code&gt; as strings</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 는 &lt;code&gt;argv&lt;/code&gt; 의 나머지 인수 목록을 문자열로 나타낸 것입니다</target>
        </trans-unit>
        <trans-unit id="67b55e613b38ca10448abedd47d027b2fda5747b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;args&lt;/code&gt; must be a list of binaries which the executable will receive as its arguments as is. This means that:</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 는 실행 파일이 그대로 인수로받을 바이너리 목록이어야합니다. 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6116c0e3ccd4227ebffa3336ec78198214587e47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as: true | false&lt;/code&gt; in &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt;&lt;code&gt;alias/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel.specialforms#require/2&quot;&gt;&lt;code&gt;require/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;as: true | false&lt;/code&gt; &lt;a href=&quot;kernel.specialforms#alias/2&quot;&gt; &lt;code&gt;alias/2&lt;/code&gt; &lt;/a&gt; 에서 false 이고 / 2 가 &lt;a href=&quot;kernel.specialforms#require/2&quot;&gt; &lt;code&gt;require/2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="822629b7db721ef2933cb934e45149d4a945780c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;as_boolean(t)&lt;/code&gt; exists to signal users that the given value will be treated as a boolean, where &lt;code&gt;nil&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; will be evaluated as &lt;code&gt;false&lt;/code&gt; and everything else is &lt;code&gt;true&lt;/code&gt;. For example, &lt;a href=&quot;enum#filter/2&quot;&gt;&lt;code&gt;Enum.filter/2&lt;/code&gt;&lt;/a&gt; has the following specification: &lt;code&gt;filter(t, (element -&amp;gt; as_boolean(term))) :: list&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;as_boolean(t)&lt;/code&gt; 주어진 부울 값으로 취급된다는 것을 사용자에게 알리기 위해 존재 &lt;code&gt;nil&lt;/code&gt; 과 &lt;code&gt;false&lt;/code&gt; 로 평가 될 것이다 &lt;code&gt;false&lt;/code&gt; 그 밖의 모든 것이 &lt;code&gt;true&lt;/code&gt; . 예를 들어 &lt;a href=&quot;enum#filter/2&quot;&gt; &lt;code&gt;Enum.filter/2&lt;/code&gt; &lt;/a&gt; 는 다음 사양을 갖습니다. &lt;code&gt;filter(t, (element -&amp;gt; as_boolean(term))) :: list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9d720388f308d192f8429307f6fcab52f0e1f5c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;assert&lt;/code&gt; introspects the underlying expression and provides good reporting whenever there is a failure. For example, if the expression uses the comparison operator, the message will show the values of the two sides. The assertion</source>
          <target state="translated">&lt;code&gt;assert&lt;/code&gt; 는 기본 표현을 검사하고 실패가있을 때마다 좋은보고 기능을 제공합니다. 예를 들어, 표현식이 비교 연산자를 사용하는 경우 메시지에 양면 값이 표시됩니다. 주장</target>
        </trans-unit>
        <trans-unit id="b8c959da5563d8804e6c5ab088f8ce78ed2be376" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;async/await&lt;/code&gt; provides a very simple mechanism to compute values concurrently. Not only that, &lt;code&gt;async/await&lt;/code&gt; can also be used with the same &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; we have used in previous chapters. We just need to call &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; instead of &lt;code&gt;Task.Supervisor.start_child/2&lt;/code&gt; and use &lt;code&gt;Task.await/2&lt;/code&gt; to read the result later on.</source>
          <target state="translated">&lt;code&gt;async/await&lt;/code&gt; 는 값을 동시에 계산하는 매우 간단한 메커니즘을 제공합니다. 뿐만 아니라 &lt;code&gt;async/await&lt;/code&gt; 는 이전 장에서 사용한 것과 동일한 &lt;a href=&quot;https://hexdocs.pm/elixir/Task.Supervisor.html&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수도 있습니다 . 우리는 호출 할 필요가 &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; 대신 &lt;code&gt;Task.Supervisor.start_child/2&lt;/code&gt; 및 사용 &lt;code&gt;Task.await/2&lt;/code&gt; 를 나중에 결과를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cbc2fd902dcfa9a0d5b3b03629aa9a39e8105cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atime&lt;/code&gt; - the last time the file was read.</source>
          <target state="translated">&lt;code&gt;atime&lt;/code&gt; - 파일을 마지막으로 읽은 시간</target>
        </trans-unit>
        <trans-unit id="a1bc563adc7ed0327db5ff505175d84400d984ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bad_nodes&lt;/code&gt; - is a list of nodes that either did not exist or where a server with the given &lt;code&gt;name&lt;/code&gt; did not exist or did not reply</source>
          <target state="translated">&lt;code&gt;bad_nodes&lt;/code&gt; - 존재하지 않거나 주어진 &lt;code&gt;name&lt;/code&gt; 의 서버가 존재하지 않거나 응답하지 않은 노드의 목록입니다</target>
        </trans-unit>
        <trans-unit id="b0f9d352deff5e6bef483d40252e8c579ec823db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;base&lt;/code&gt; can be an integer between 2 and 36.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 는 2와 36 사이의 정수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8fd140ab9c10a0cfc1c2df9c9a53282f52de13e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;big&lt;/code&gt; (default)</source>
          <target state="translated">&lt;code&gt;big&lt;/code&gt; (기본값)</target>
        </trans-unit>
        <trans-unit id="683140005c82637887b9603468709538ca7e8c82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo daemon&lt;/code&gt; and &lt;code&gt;bin/foo daemon_iex&lt;/code&gt; - to start the system as a daemon on Unix-like systems</source>
          <target state="translated">&lt;code&gt;bin/foo daemon&lt;/code&gt; 및 &lt;code&gt;bin/foo daemon_iex&lt;/code&gt; -Unix 계열 시스템에서 시스템을 데몬으로 시작</target>
        </trans-unit>
        <trans-unit id="decd6a4e6f8eff7dd632caccc3c36fce1d0d44bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo eval COMMAND&lt;/code&gt; - to start a fresh system that runs a single command and then shuts down</source>
          <target state="translated">&lt;code&gt;bin/foo eval COMMAND&lt;/code&gt; - 단일 명령을 실행 한 다음 종료되는 새로운 시스템을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="432eeca34ed295a1f1ff0e49167671eefec3e74c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo install&lt;/code&gt; - to install the system as a service on Windows machines</source>
          <target state="translated">&lt;code&gt;bin/foo install&lt;/code&gt; -Windows 시스템에서 시스템을 서비스로 설치</target>
        </trans-unit>
        <trans-unit id="8eb1dbc6df6a7ebd68488f9c558335906ced9632" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo rpc COMMAND&lt;/code&gt; and &lt;code&gt;bin/foo remote&lt;/code&gt; - for running commands on the running system or to connect to the running system</source>
          <target state="translated">&lt;code&gt;bin/foo rpc COMMAND&lt;/code&gt; 및 &lt;code&gt;bin/foo remote&lt;/code&gt; - 또는 실행중인 시스템에서 명령을 실행은 실행중인 시스템에 연결</target>
        </trans-unit>
        <trans-unit id="61afcc7c9d27662591ec64aeb53fbe50494c9c54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bin/foo start&lt;/code&gt;, &lt;code&gt;bin/foo start_iex&lt;/code&gt;, &lt;code&gt;bin/foo restart&lt;/code&gt;, and &lt;code&gt;bin/foo stop&lt;/code&gt; - for general management of the release</source>
          <target state="translated">&lt;code&gt;bin/foo start&lt;/code&gt; , &lt;code&gt;bin/foo start_iex&lt;/code&gt; , &lt;code&gt;bin/foo restart&lt;/code&gt; 및 &lt;code&gt;bin/foo stop&lt;/code&gt; stop- 릴리스의 일반 관리</target>
        </trans-unit>
        <trans-unit id="1d72332764c11e123f7347708663156c1233e11a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;binding&lt;/code&gt; is a keyword list with the value of all variable bindings after evaluating &lt;code&gt;string&lt;/code&gt;. The binding key is usually an atom, but it may be a tuple for variables defined in a different context.</source>
          <target state="translated">&lt;code&gt;binding&lt;/code&gt; 은 &lt;code&gt;string&lt;/code&gt; 을 평가 한 후 모든 변수 바인딩 값이있는 키워드 목록입니다 . 바인딩 키는 일반적으로 원자이지만 다른 컨텍스트에서 정의 된 변수의 튜플 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c823d3a888334fa369393bafb696100163d27f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bits&lt;/code&gt; (alias for &lt;code&gt;bitstring&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;bits&lt;/code&gt; (별칭 &lt;code&gt;bitstring&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="15d4a43121fe32de8967a969e91d058bcf17a84c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bytes&lt;/code&gt; (alias for &lt;code&gt;binary&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;bytes&lt;/code&gt; ( &lt;code&gt;binary&lt;/code&gt; 별명 )</target>
        </trans-unit>
        <trans-unit id="834919dffb47cc92a7a48cd0b0701a70f30f53b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt;: words in the list are charlists</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; : 목록의 단어는 문자 목록입니다</target>
        </trans-unit>
        <trans-unit id="b2ccd200c0a8ea5eab26b2092f3c2628e13ebdda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;call&lt;/code&gt;, &lt;code&gt;cast&lt;/code&gt; or &lt;code&gt;info&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; , &lt;code&gt;cast&lt;/code&gt; 또는 &lt;code&gt;info&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="f8c3b2d3da64ab6cc3b0a518b860cadf593c568e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;callback&lt;/code&gt; is a function that receives no arguments and runs in a separate process than the caller.</source>
          <target state="translated">&lt;code&gt;callback&lt;/code&gt; 은 인수를받지 않고 호출자와 다른 프로세스에서 실행되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="95b68f4cda4012cbd6bf09e1c90d22f081c35df3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;case&lt;/code&gt; allows us to compare a value against many patterns until we find a matching one:</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 를 사용하면 일치하는 패턴을 찾을 때까지 여러 패턴과 값을 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2e836bef50ccfd75e73db047504ecafbbd45966" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;case&lt;/code&gt; is useful when you need to match against different values. However, in many circumstances, we want to check different conditions and find the first one that does not evaluate to &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. In such cases, one may use &lt;code&gt;cond&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 는 다른 값과 일치해야 할 때 유용합니다. 그러나 많은 상황에서 우리는 다른 조건을 확인하고 &lt;code&gt;nil&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 로 평가되지 않는 첫 번째 조건을 찾고 싶습니다 . 이러한 경우 &lt;code&gt;cond&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93db9ef7d76055eccf64ca125a1bd08e2afa0ce3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;caseless&lt;/code&gt; (i) - adds case insensitivity</source>
          <target state="translated">&lt;code&gt;caseless&lt;/code&gt; (i)-대소 문자를 구분하지 않습니다</target>
        </trans-unit>
        <trans-unit id="81988c264165854eebe013b354206a9d80761cc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; can be used to catch values thrown by &lt;a href=&quot;kernel#throw/1&quot;&gt;&lt;code&gt;Kernel.throw/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 는 &lt;a href=&quot;kernel#throw/1&quot;&gt; &lt;code&gt;Kernel.throw/1&lt;/code&gt; 에&lt;/a&gt; 의해 던져진 값을 잡는데 사용될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cb7c5d439fab5f4770d5cbbe8aa9adfa7fda6776" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;catch&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;catch&lt;/code&gt; 조항</target>
        </trans-unit>
        <trans-unit id="db91933fecb8b9776531516395537a60984fe8c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;changed&lt;/code&gt; is a keyword list of keys and their changed values in the application environment. &lt;code&gt;new&lt;/code&gt; is a keyword list with all new keys and their values. &lt;code&gt;removed&lt;/code&gt; is a list with all removed keys.</source>
          <target state="translated">&lt;code&gt;changed&lt;/code&gt; 는 응용 프로그램 환경에서 키워드의 키 목록 및 변경된 값입니다. &lt;code&gt;new&lt;/code&gt; 는 모든 새 키와 해당 값이 포함 된 키워드 목록입니다. &lt;code&gt;removed&lt;/code&gt; 는 모든 제거 된 키가있는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="60538f44591b66b504b274f4df6fe77688be99e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char_list/0&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;char_list/0&lt;/code&gt; 타입</target>
        </trans-unit>
        <trans-unit id="343cfd2a019aa43de8f9ab53908dba3ccb94d728" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;child&lt;/code&gt; - the PID of the corresponding child process or the atom &lt;code&gt;:restarting&lt;/code&gt; if the process is about to be restarted</source>
          <target state="translated">&lt;code&gt;child&lt;/code&gt; - 해당 자식 프로세스 또는 원자의 PID &lt;code&gt;:restarting&lt;/code&gt; 프로세스가 다시 시작하는 것입니다 경우</target>
        </trans-unit>
        <trans-unit id="8b19e01788ee36713a234b5a35b8998444e68a3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;child&lt;/code&gt; - the PID of the corresponding child process, &lt;code&gt;:restarting&lt;/code&gt; if the process is about to be restarted, or &lt;code&gt;:undefined&lt;/code&gt; if there is no such process</source>
          <target state="translated">&lt;code&gt;child&lt;/code&gt; - 해당하는 자식 프로세스의 PID, &lt;code&gt;:restarting&lt;/code&gt; 프로세스를 다시 시작 하려고하면 다시 시작, 또는 프로세스가없는 경우 &lt;code&gt;:undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4b785aaae874a7f7ac89b390425e4e181327565b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;child_spec&lt;/code&gt; should be a valid child specification as detailed in the &quot;child_spec/1&quot; section of the documentation for &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. The child process will be started as defined in the child specification.</source>
          <target state="translated">&lt;code&gt;child_spec&lt;/code&gt; 은 &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 문서의 &quot;child_spec / 1&quot;섹션에 설명 된 유효한 자식 사양이어야합니다 . 하위 프로세스는 하위 스펙에 정의 된대로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d9984de2b8855daeaef81ef2dcc1396c0705a01d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;child_spec&lt;/code&gt; should be a valid child specification. The child process will be started as defined in the child specification.</source>
          <target state="translated">&lt;code&gt;child_spec&lt;/code&gt; 은 유효한 자식 사양이어야합니다. 하위 프로세스는 하위 스펙에 정의 된대로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="9f93140b69bea94d444900d436d05d80b21439d9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;chunk_fun&lt;/code&gt; receives the current element and the accumulator and must return &lt;code&gt;{:cont, element, acc}&lt;/code&gt; to emit the given chunk and continue with accumulator or &lt;code&gt;{:cont, acc}&lt;/code&gt; to not emit any chunk and continue with the return accumulator.</source>
          <target state="translated">&lt;code&gt;chunk_fun&lt;/code&gt; 은 현재 요소와 누산기를 수신하고 &lt;code&gt;{:cont, element, acc}&lt;/code&gt; 를 리턴 하여 주어진 청크를 방출하고 어큐뮬레이터 또는 &lt;code&gt;{:cont, acc}&lt;/code&gt; 를 계속 수행하여 청크를 방출하지 않고 리턴 누산기를 계속해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a4d8126ef5b5ce5f93f354fe8074bc265f819b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;client&lt;/code&gt; must be the &lt;code&gt;from&lt;/code&gt; argument (the second argument) accepted by &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; callbacks. &lt;code&gt;reply&lt;/code&gt; is an arbitrary term which will be given back to the client as the return value of the call.</source>
          <target state="translated">&lt;code&gt;client&lt;/code&gt; 는 &lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt; 콜백에서 허용 하는 &lt;code&gt;from&lt;/code&gt; 인수 (두 번째 인수) 여야합니다 . &lt;code&gt;reply&lt;/code&gt; 은 호출의 반환 값으로 클라이언트에 다시 제공되는 임의의 용어입니다.</target>
        </trans-unit>
        <trans-unit id="74ea1ebde7d25d8d5b3afc102cd5079c21ac3674" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;command&lt;/code&gt; is expected to be an executable available in PATH unless an absolute path is given.</source>
          <target state="translated">&lt;code&gt;command&lt;/code&gt; 절대 경로가 지정되지 않은 경우 명령 은 PATH에서 사용 가능한 실행 파일이어야합니다.</target>
        </trans-unit>
        <trans-unit id="dcd9856e60a10b0680192123ebbb0d9096956b79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/config.exs&lt;/code&gt; (and &lt;code&gt;config/prod.exs&lt;/code&gt;) - provides build-time application configuration, which is executed when the release is assembled</source>
          <target state="translated">&lt;code&gt;config/config.exs&lt;/code&gt; (및 &lt;code&gt;config/prod.exs&lt;/code&gt; )-빌드 타임 애플리케이션 구성을 제공합니다.이 구성은 릴리즈가 어셈블 될 때 실행됩니다</target>
        </trans-unit>
        <trans-unit id="238fad20b64f6752094e989e81c47221593a4dc8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/releases.exs&lt;/code&gt; - provides runtime application configuration. It is executed every time the release boots and is further extensible via config providers</source>
          <target state="translated">&lt;code&gt;config/releases.exs&lt;/code&gt; - 런타임 응용 프로그램 구성을 제공합니다. 릴리스가 부팅 될 때마다 실행되며 구성 제공자를 통해 추가로 확장 가능</target>
        </trans-unit>
        <trans-unit id="a8ff7a040c02a1351d6dbd358d27db3517eb600c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config/releases.exs&lt;/code&gt; files work very similar to a regular &lt;code&gt;config/config.exs&lt;/code&gt; but it may have some restrictions. You can &lt;a href=&quot;https://hexdocs.pm/mix/1.9.0-rc.0/Mix.Tasks.Release.html#module-runtime-configuration&quot;&gt;read the documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;config/releases.exs&lt;/code&gt; 파일은 일반 &lt;code&gt;config/config.exs&lt;/code&gt; 와 매우 유사 하지만 약간의 제한이있을 수 있습니다. 당신은 할 수 있습니다 &lt;a href=&quot;https://hexdocs.pm/mix/1.9.0-rc.0/Mix.Tasks.Release.html#module-runtime-configuration&quot;&gt;설명서를 참조&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="8f3eb732cc99e5e8d0e7d53c8f3927e2f14fdbcc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;content&lt;/code&gt; must be &lt;code&gt;iodata&lt;/code&gt; (a list of bytes or a binary). Setting the encoding for this function has no effect.</source>
          <target state="translated">&lt;code&gt;content&lt;/code&gt; 는 &lt;code&gt;iodata&lt;/code&gt; (바이트 목록 또는 이진) 여야합니다 . 이 기능의 인코딩 설정은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3deab4bf4d8695b2db46398f128ebe3680400d0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;contents&lt;/code&gt; can be either a string, a list of strings, or a compiled pattern.</source>
          <target state="translated">&lt;code&gt;contents&lt;/code&gt; 은 문자열, 문자열 목록 또는 컴파일 된 패턴 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4068af36af3815a173cb8e9bbb5840dd4f7966e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;context&lt;/code&gt; - the context of the environment; it can be &lt;code&gt;nil&lt;/code&gt; (default context), &lt;code&gt;:guard&lt;/code&gt; (inside a guard) or &lt;code&gt;:match&lt;/code&gt; (inside a match)</source>
          <target state="translated">&lt;code&gt;context&lt;/code&gt; -환경의 맥락; 그것은 할 수있다 &lt;code&gt;nil&lt;/code&gt; (기본 컨텍스트), &lt;code&gt;:guard&lt;/code&gt; (가드 내부) 또는 &lt;code&gt;:match&lt;/code&gt; (일치하는 내부)</target>
        </trans-unit>
        <trans-unit id="e65d01ac3d70dd939e249ff006400606c24ca6a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;context_modules&lt;/code&gt; - a list of modules defined in the current context</source>
          <target state="translated">&lt;code&gt;context_modules&lt;/code&gt; - 현재 컨텍스트에 정의 된 모듈 목록</target>
        </trans-unit>
        <trans-unit id="5d9edb2d993802ba4716d7849368f4f8e74a86f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cprof&lt;/code&gt; can be useful when you want to discover the bottlenecks related to function calls.</source>
          <target state="translated">&lt;code&gt;cprof&lt;/code&gt; 는 함수 호출과 관련된 병목 현상을 발견 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38a38cdb98964403a68aee6e3174c867d51569e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ctime&lt;/code&gt; - the interpretation of this time field depends on the operating system. On Unix, it is the last time the file or the inode was changed. In Windows, it is the time of creation.</source>
          <target state="translated">&lt;code&gt;ctime&lt;/code&gt; - 이 시간 필드의 해석은 운영 체제에 따라 다릅니다. Unix에서는 파일 또는 inode가 마지막으로 변경된 시간입니다. Windows에서는 지금이 만들어졌습니다.</target>
        </trans-unit>
        <trans-unit id="f1205b070fab0c83d6c993c3f3960abb127d2ea4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; - the characters in the line terminated by a line-feed (LF) or end of file (EOF)</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; - 라인 피드 (LF) 또는 파일의 끝으로 종료 라인의 문자 (EOF)</target>
        </trans-unit>
        <trans-unit id="65ebe7dc5a6cbe47bb0f679ee7ef6cf59418d356" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; - the input characters</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; - 입력 문자</target>
        </trans-unit>
        <trans-unit id="3d4410c596b384477fdcae0b3c0d2b1de73cede5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; - the output bytes</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; - 출력 바이트</target>
        </trans-unit>
        <trans-unit id="d66ff6e276982cb027d53bd1f1e405fd861fcfe8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; - the output characters</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; - 출력 문자</target>
        </trans-unit>
        <trans-unit id="f1e314b3d0f6ce196df7c11d73e42319ca204a0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;data&lt;/code&gt; is a nested structure (that is, a map, keyword list, or struct that implements the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 는 중첩 구조 (즉, &lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 동작 을 구현하는 맵, 키워드 목록 또는 구조체 )입니다.</target>
        </trans-unit>
        <trans-unit id="e5cb8b51e466bd529414676deb5702007605833f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dest&lt;/code&gt; may be a remote or local PID, a local port, a locally registered name, or a tuple in the form of &lt;code&gt;{registered_name, node}&lt;/code&gt; for a registered name at another node.</source>
          <target state="translated">&lt;code&gt;dest&lt;/code&gt; 는 원격 또는 로컬 PID, 로컬 포트, 로컬로 등록 된 이름 또는 다른 노드에서 등록 된 이름에 대한 &lt;code&gt;{registered_name, node}&lt;/code&gt; 형식의 튜플 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06cb04154e21b24c69f9c8bad5656b7a39545bc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;device&lt;/code&gt; - the IO device</source>
          <target state="translated">&lt;code&gt;device&lt;/code&gt; -IO 장치</target>
        </trans-unit>
        <trans-unit id="48cd3cb1cdaa44a2d6bca7edd5d1a1fc56abbc4b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do/end&lt;/code&gt; blocks</source>
          <target state="translated">&lt;code&gt;do/end&lt;/code&gt; 블록</target>
        </trans-unit>
        <trans-unit id="325351821945a7973f1da881d3d9c9177ab84e7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do/end&lt;/code&gt; blocks are a syntactic convenience built on top of the keywords one. That&amp;rsquo;s why &lt;code&gt;do/end&lt;/code&gt; blocks do not require a comma between the previous argument and the block. They are useful exactly because they remove the verbosity when writing blocks of code. These are equivalent:</source>
          <target state="translated">&lt;code&gt;do/end&lt;/code&gt; 블록은 키워드 하나 위에 구축 된 구문상의 편의성입니다. 따라서 &lt;code&gt;do/end&lt;/code&gt; 블록은 이전 인수와 블록 사이에 쉼표가 필요하지 않습니다. 코드 블록을 작성할 때 자세한 정보를 제거하기 때문에 정확하게 유용합니다. 이들은 동등합니다 :</target>
        </trans-unit>
        <trans-unit id="ade8e208e831b5d198ac3add386fe1dab9834807" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, &lt;code&gt;rescue&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt; - used in do/end blocks</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; , &lt;code&gt;catch&lt;/code&gt; , &lt;code&gt;rescue&lt;/code&gt; , &lt;code&gt;after&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; / end 블록에 사용</target>
        </trans-unit>
        <trans-unit id="3985298d4759592d757f0cb9a9e4f9b15e52aa5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 블록을</target>
        </trans-unit>
        <trans-unit id="43edbc936cf9ae8a8d1677e787957e43950a7cc0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dollar_endonly&lt;/code&gt; - not available, use &lt;code&gt;\z&lt;/code&gt; instead</source>
          <target state="translated">&lt;code&gt;dollar_endonly&lt;/code&gt; - 사용 불가, 대신 &lt;code&gt;\z&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="81166ee1fc1c5f6aa3345e5c1516903114a049ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dot&lt;/code&gt; - produces a DOT graph description in &lt;code&gt;xref_graph.dot&lt;/code&gt; in the current directory. Warning: this will override any previously generated file</source>
          <target state="translated">&lt;code&gt;dot&lt;/code&gt; -에서 DOT 그래프 설명 생산 &lt;code&gt;xref_graph.dot&lt;/code&gt; 현재 디렉토리에 있습니다. 경고 : 이전에 생성 된 파일보다 우선합니다</target>
        </trans-unit>
        <trans-unit id="5aa86ef28d23f77d91172ba542c09d2cc5b7637b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dotall&lt;/code&gt; (s) - causes dot to match newlines and also set newline to anycrlf; the new line setting can be overridden by setting &lt;code&gt;(*CR)&lt;/code&gt; or &lt;code&gt;(*LF)&lt;/code&gt; or &lt;code&gt;(*CRLF)&lt;/code&gt; or &lt;code&gt;(*ANY)&lt;/code&gt; according to &lt;code&gt;:re&lt;/code&gt; documentation</source>
          <target state="translated">&lt;code&gt;dotall&lt;/code&gt; (s)-점이 개행과 일치하고 개행을 anycrlf로 설정합니다. &lt;code&gt;:re&lt;/code&gt; documentation 에 따라 &lt;code&gt;(*CR)&lt;/code&gt; 또는 &lt;code&gt;(*LF)&lt;/code&gt; 또는 &lt;code&gt;(*CRLF)&lt;/code&gt; 또는 &lt;code&gt;(*ANY)&lt;/code&gt; 를 설정하여 줄 바꿈 설정을 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df6f1675aa9801dfb22096bcea57d03ccca2fb4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;else&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt; 절</target>
        </trans-unit>
        <trans-unit id="d4c769601399680023c8ba6fd6b77d7373a374a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;else&lt;/code&gt; clauses allow the result of the body passed to &lt;a href=&quot;#try/1&quot;&gt;&lt;code&gt;try/1&lt;/code&gt;&lt;/a&gt; to be pattern matched on:</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt; 절을 사용하면 &lt;a href=&quot;#try/1&quot;&gt; &lt;code&gt;try/1&lt;/code&gt; &lt;/a&gt; 에 전달 된 본문의 결과를 다음 과 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cddbb9fd21a3bab1166f759ba9181e02747b988c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exit&lt;/code&gt; can also be &amp;ldquo;caught&amp;rdquo; using &lt;code&gt;try/catch&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;exit&lt;/code&gt; 는 &lt;code&gt;try/catch&lt;/code&gt; 를 사용하여&amp;ldquo;잡힐 수 있습니다&amp;rdquo; :</target>
        </trans-unit>
        <trans-unit id="17e496cdf50605afa594c0a2b3b48bf5f1fd62d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;exit&lt;/code&gt; signals are an important part of the fault tolerant system provided by the Erlang</source>
          <target state="translated">&lt;code&gt;exit&lt;/code&gt; 신호는 Erlang이 제공하는 내결함성 시스템의 중요한 부분입니다.</target>
        </trans-unit>
        <trans-unit id="db3067f33775b9f16e85d2c27602d9e6760ad782" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;extended&lt;/code&gt; (x) - whitespace characters are ignored except when escaped and allow &lt;code&gt;#&lt;/code&gt; to delimit comments</source>
          <target state="translated">&lt;code&gt;extended&lt;/code&gt; (x)-이스케이프 된 경우를 제외하고 공백 문자는 무시되며 &lt;code&gt;#&lt;/code&gt; 로 주석을 구분합니다.</target>
        </trans-unit>
        <trans-unit id="5dd94be61300bd55483654aaa07e30abd3dae510" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; - ignores padding from the input string</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; - 입력 문자열에서 패딩을 무시합니다</target>
        </trans-unit>
        <trans-unit id="0f2f2cad3367ff4259e6a85005d20253c790cbd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;false&lt;/code&gt; - omit padding from the output string</source>
          <target state="translated">&lt;code&gt;false&lt;/code&gt; - 출력 문자열에서 패딩 생략</target>
        </trans-unit>
        <trans-unit id="0dd4008fc42804b6bf3e46bd4df4d0ea81c26c3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;file&lt;/code&gt; - the current file name as a binary</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; - 바이너리로 현재 파일 이름</target>
        </trans-unit>
        <trans-unit id="89e027d1ed05b4018b4a08d0262f23b3ff60ce93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;firstline&lt;/code&gt; (f) - forces the unanchored pattern to match before or at the first newline, though the matched text may continue over the newline</source>
          <target state="translated">&lt;code&gt;firstline&lt;/code&gt; (f)-일치하는 텍스트가 개행을 계속할 수 있지만 고정되지 않은 패턴이 첫 번째 개행 이전 또는 첫 번째 개행과 일치하도록합니다.</target>
        </trans-unit>
        <trans-unit id="6908e3631ddb64d7fcca5b3480aa8fd1cfac7e55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fn&lt;/code&gt; - used for anonymous function definitions</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; - 익명 함수 정의에 사용</target>
        </trans-unit>
        <trans-unit id="7b569c1f1b88d633c8ae41253689a2f767acd2bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo.bar&lt;/code&gt; - accesses a map/struct field; in case the field is not present, an error is raised</source>
          <target state="translated">&lt;code&gt;foo.bar&lt;/code&gt; - 지도 / 구조체 필드에 접근합니다; 필드가없는 경우 오류가 발생합니다</target>
        </trans-unit>
        <trans-unit id="f4b838ac959304b5441479216a13abe7cbdbbcf7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;foo[bar]&lt;/code&gt; - accesses the key &lt;code&gt;bar&lt;/code&gt; in &lt;code&gt;foo&lt;/code&gt;; in case &lt;code&gt;foo&lt;/code&gt; is nil, &lt;code&gt;nil&lt;/code&gt; is returned</source>
          <target state="translated">&lt;code&gt;foo[bar]&lt;/code&gt; - 키에 액세스하는 &lt;code&gt;bar&lt;/code&gt; 의 &lt;code&gt;foo&lt;/code&gt; 는 ; 경우에 &lt;code&gt;foo&lt;/code&gt; 는이 전무하다, &lt;code&gt;nil&lt;/code&gt; 반환된다</target>
        </trans-unit>
        <trans-unit id="eef0f2d09999efe1c1a474dc48a013215ea64e1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fprof&lt;/code&gt; can be useful when you want to discover the bottlenecks of a sequential code.</source>
          <target state="translated">&lt;code&gt;fprof&lt;/code&gt; 는 순차 코드의 병목 현상을 발견 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c7bedba0b383b7f10d86c6ad80100844e60be3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; is called with the current value under &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt; (or &lt;code&gt;nil&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;) and must return a two-element tuple: the &quot;get&quot; value (the retrieved value, which can be operated on before being returned) and the new value to be stored under &lt;code&gt;key&lt;/code&gt; in the resulting new map. &lt;code&gt;fun&lt;/code&gt; may also return &lt;code&gt;:pop&lt;/code&gt;, which means the current value shall be removed from &lt;code&gt;map&lt;/code&gt; and returned (making this function behave like &lt;code&gt;Map.pop(map, key)&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 아래의 현재 값 불려 &lt;code&gt;key&lt;/code&gt; 의 &lt;code&gt;map&lt;/code&gt; (또는 &lt;code&gt;nil&lt;/code&gt; 경우 &lt;code&gt;key&lt;/code&gt; 에 존재하지 않는 &lt;code&gt;map&lt;/code&gt; )와, 2 요소 튜플을 반환해야합니다 다음은 &quot;GET&quot;값 (반환하기 전에에서 작동 할 수 검색된 값) 새 값 은 결과 새 맵 에서 &lt;code&gt;key&lt;/code&gt; 아래에 저장 됩니다. &lt;code&gt;fun&lt;/code&gt; 은 또한 &lt;code&gt;:pop&lt;/code&gt; 을 반환 할 수 있습니다 . 즉, 현재 값이 &lt;code&gt;map&lt;/code&gt; 에서 제거되어 반환됩니다 (이 기능을 &lt;code&gt;Map.pop(map, key)&lt;/code&gt; 처럼 동작하게 함 ).</target>
        </trans-unit>
        <trans-unit id="73987292ec55c205146407f70cc34101bc201e85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; is called with the module name of the given &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt;. The return value of this function is the return value of &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 주어진 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Project&lt;/code&gt; &lt;/a&gt; 의 모듈 이름으로 fun 이 호출됩니다 . 이 함수의 반환 값은 &lt;code&gt;fun&lt;/code&gt; 의 반환 값입니다 .</target>
        </trans-unit>
        <trans-unit id="0344ca817de66fc2cf01667d06d78a915e393ff7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; must be a zero-arity anonymous function.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 은 제로 익명의 기능이어야합니다.</target>
        </trans-unit>
        <trans-unit id="bec4f976c611de0387ba3b8e5bc5a82998ebd9f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fun&lt;/code&gt; must be a zero-arity anonymous function. This function spawns a process that is linked to and monitored by the caller process. A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; struct is returned containing the relevant information.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 은 제로 익명의 기능이어야합니다. 이 함수는 호출자 프로세스에 연결되고 모니터되는 프로세스를 생성합니다. 관련 정보가 포함 된 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 구조체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ba04c9a31c6587cb12b54223a008938c6c36fce6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;function&lt;/code&gt; - a tuple as &lt;code&gt;{atom, integer}&lt;/code&gt;, where the first element is the function name and the second its arity; returns &lt;code&gt;nil&lt;/code&gt; if not inside a function</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; - &lt;code&gt;{atom, integer}&lt;/code&gt; 의 튜플 . 여기서 첫 번째 요소는 함수 이름이고 두 번째 요소는 arity입니다. 함수 안에 있지 않으면 &lt;code&gt;nil&lt;/code&gt; 을 반환</target>
        </trans-unit>
        <trans-unit id="fdce62b51d95c967bffec92639abb05fa80a816f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;functions&lt;/code&gt; - a list of functions imported from each module</source>
          <target state="translated">&lt;code&gt;functions&lt;/code&gt; -각 모듈에서 가져온 함수 목록</target>
        </trans-unit>
        <trans-unit id="98e52e06e0331479a62ea10bc00f303f3f507f2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;get_value&lt;/code&gt; is the retrieved value (which can be operated on before being returned)</source>
          <target state="translated">&lt;code&gt;get_value&lt;/code&gt; 는 검색된 값입니다 (반환되기 전에 작동 가능).</target>
        </trans-unit>
        <trans-unit id="24a178311ad224c4a60feb7863864b4d30e88cd7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gid&lt;/code&gt; - indicates the group that owns the file. Will be zero for non-Unix file systems.</source>
          <target state="translated">&lt;code&gt;gid&lt;/code&gt; - 파일을 소유 한 그룹을 나타냅니다. 비 유닉스 파일 시스템의 경우 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="64ea8480a297125c017fea9dde76f546c7b7fe47" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;group_leader&lt;/code&gt; is the group leader of the process which logged the message</source>
          <target state="translated">&lt;code&gt;group_leader&lt;/code&gt; 는 메시지를 기록한 프로세스의 그룹 리더입니다.</target>
        </trans-unit>
        <trans-unit id="7e4a6ea58f48db7fc69ef53cf936a56a08b467db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle_call/3&lt;/code&gt; must be used for synchronous requests. This should be the default choice as waiting for the server reply is a useful backpressure mechanism.</source>
          <target state="translated">&lt;code&gt;handle_call/3&lt;/code&gt; 동기 요청에는 handle_call / 3을 사용해야합니다. 서버 응답을 기다리는 것이 유용한 역압 메커니즘이므로 기본 선택이되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a2af7471be23ef0937ae1a0fe2c62f92e8f8d066" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle_cast/2&lt;/code&gt; must be used for asynchronous requests, when you don&amp;rsquo;t care about a reply. A cast does not even guarantee the server has received the message and, for this reason, should be used sparingly. For example, the &lt;code&gt;create/2&lt;/code&gt; function we have defined in this chapter should have used &lt;code&gt;call/2&lt;/code&gt;. We have used &lt;code&gt;cast/2&lt;/code&gt; for didactic purposes.</source>
          <target state="translated">&lt;code&gt;handle_cast/2&lt;/code&gt; 응답에 신경 쓰지 않으면 비동기 요청에 handle_cast / 2를 사용해야합니다. 캐스트는 서버가 메시지를 수신했음을 보증하지도 않기 때문에 드물게 사용해야합니다. 예를 들어, 이 장에서 정의한 &lt;code&gt;create/2&lt;/code&gt; 함수는 &lt;code&gt;call/2&lt;/code&gt; 를 사용해야합니다 . 우리는 교훈적인 목적으로 &lt;code&gt;cast/2&lt;/code&gt; 를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="ba53ab70dc78f0a9b7412ec3b2bb0f747a7d63ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handle_info/2&lt;/code&gt; must be used for all other messages a server may receive that are not sent via &lt;code&gt;GenServer.call/2&lt;/code&gt; or &lt;code&gt;GenServer.cast/2&lt;/code&gt;, including regular messages sent with &lt;code&gt;send/2&lt;/code&gt;. The monitoring &lt;code&gt;:DOWN&lt;/code&gt; messages are an example of this.</source>
          <target state="translated">&lt;code&gt;handle_info/2&lt;/code&gt; 는 &lt;code&gt;send/2&lt;/code&gt; 로 전송 된 일반 메시지를 포함하여 &lt;code&gt;GenServer.call/2&lt;/code&gt; 또는 &lt;code&gt;GenServer.cast/2&lt;/code&gt; 를 통해 전송되지 않은 서버가 수신 할 수있는 다른 모든 메시지에 사용해야합니다 . 모니터링 &lt;code&gt;:DOWN&lt;/code&gt; 메시지는 이에 대한 예입니다.</target>
        </trans-unit>
        <trans-unit id="8e34c824ac05b21ab757c5fbf6100951dcd8cb12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt; - as defined in the child specification</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; - 하위 스펙에 정의 된대로</target>
        </trans-unit>
        <trans-unit id="a955d26c8cf2d713bf003551df2c96067ee51799" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt; - it is always &lt;code&gt;:undefined&lt;/code&gt; for dynamic supervisors</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; - 동적 관리자에 대해 항상 &lt;code&gt;:undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f9254b1d6d22c5cafac5af8f10ed37f33275d42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 에 &lt;code&gt;unless&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a89169d2e3dce0e0e3f3d300ab237fbc286465d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;impl_for!/1&lt;/code&gt; - same as above but raises an error if an implementation is not found</source>
          <target state="translated">&lt;code&gt;impl_for!/1&lt;/code&gt; - 위와 동일하지만 구현을 찾지 못하면 오류가 발생합니다</target>
        </trans-unit>
        <trans-unit id="dd4dcd3de4db76dbf5cd688389ee6bc144a73c64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;impl_for/1&lt;/code&gt; - receives a structure and returns the module that implements the protocol for the structure, &lt;code&gt;nil&lt;/code&gt; otherwise</source>
          <target state="translated">&lt;code&gt;impl_for/1&lt;/code&gt; - 구조를 수신하고 구조에 대한 프로토콜을 구현하는 모듈을 리턴합니다. 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77adafb3f8e1c04dc649c8a27bf4a028398d3422" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import Config&lt;/code&gt; will import the functions &lt;a href=&quot;#config/2&quot;&gt;&lt;code&gt;config/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#config/3&quot;&gt;&lt;code&gt;config/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#import_config/1&quot;&gt;&lt;code&gt;import_config/1&lt;/code&gt;&lt;/a&gt; to help you manage your configuration.</source>
          <target state="translated">&lt;code&gt;import Config&lt;/code&gt; 는 &lt;a href=&quot;#config/2&quot;&gt; &lt;code&gt;config/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#config/3&quot;&gt; &lt;code&gt;config/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#import_config/1&quot;&gt; &lt;code&gt;import_config/1&lt;/code&gt; 기능&lt;/a&gt; 을 가져와 구성 관리에 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="4616b488ff51bfbaf80546fbb756faeba6d758dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;import&lt;/code&gt; also supports &lt;code&gt;:macros&lt;/code&gt; and &lt;code&gt;:functions&lt;/code&gt; to be given to &lt;code&gt;:only&lt;/code&gt;. For example, to import all macros, one could write:</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 는 &lt;code&gt;:macros&lt;/code&gt; 와 &lt;code&gt;:functions&lt;/code&gt; 을 &lt;code&gt;:only&lt;/code&gt; 에만 제공 합니다. 예를 들어, 모든 매크로를 가져 오기 위해 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6778e8370969e09cdb7b6d95b8411befab07014d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;in&lt;/code&gt;&lt;code&gt;not in&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; &lt;code&gt;not in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c71b4bbf5308a944ca78d7e8a7957ad9301c49e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;index_range&lt;/code&gt; must be a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;. Given an &lt;code&gt;enumerable&lt;/code&gt;, it drops elements before &lt;code&gt;index_range.first&lt;/code&gt; (zero-base), then takes elements until element &lt;code&gt;index_range.last&lt;/code&gt; (inclusively).</source>
          <target state="translated">&lt;code&gt;index_range&lt;/code&gt; 는 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 이어야합니다 . &lt;code&gt;enumerable&lt;/code&gt; 하면 &lt;code&gt;index_range.first&lt;/code&gt; (제로베이스) 앞에 요소를 제거한 다음 &lt;code&gt;index_range.last&lt;/code&gt; 요소 (포함) 까지 요소를 취합니다 .</target>
        </trans-unit>
        <trans-unit id="ef0c6a6de6ca13024ac4a294bfc40896fc29eea9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;init_arg&lt;/code&gt; is the argument term (second argument) passed to &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;init_arg&lt;/code&gt; 는 start_link &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 전달 된 인수 용어 (두 번째 인수) 입니다.</target>
        </trans-unit>
        <trans-unit id="42ccdeed4cb31f96c120a6107473e17cfa988fb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;inode&lt;/code&gt; - gives the inode number. On non-Unix file systems, this field will be zero.</source>
          <target state="translated">&lt;code&gt;inode&lt;/code&gt; -inode 번호를 제공합니다. Unix 이외의 파일 시스템에서는이 필드가 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="a082bb1049b72730ef91489b19d870c7f2e5f5fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;integer()&lt;/code&gt; | &lt;code&gt;float()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;integer()&lt;/code&gt; | &lt;code&gt;float()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7cac343e7ca30a47b6b2cafdd3b896dfb0b1254c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, &lt;code&gt;utf32&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;utf16&lt;/code&gt; , &lt;code&gt;utf32&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f662fb245490dd208672d79aaf08db7f1d03ffe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;integer&lt;/code&gt;, &lt;code&gt;utf16&lt;/code&gt;, &lt;code&gt;utf32&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; , &lt;code&gt;utf16&lt;/code&gt; , &lt;code&gt;utf32&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04dc3cb7748f4ca9dc612c4051de3bbd8865f718" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;invalid&lt;/code&gt; is a list of invalid options as &lt;code&gt;{option_name, value}&lt;/code&gt; where &lt;code&gt;option_name&lt;/code&gt; is the raw option and &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; if the option wasn't expected or the string value if the value didn't have the expected type for the corresponding option</source>
          <target state="translated">&lt;code&gt;invalid&lt;/code&gt; 는 &lt;code&gt;{option_name, value}&lt;/code&gt; 와 같은 유효하지 않은 옵션 목록입니다. 여기서 &lt;code&gt;option_name&lt;/code&gt; 은 원시 옵션이고 옵션이 예상되지 않은 경우 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;nil&lt;/code&gt; 이거나 값에 해당 옵션에 대한 예상 유형이없는 경우 문자열 값입니다.</target>
        </trans-unit>
        <trans-unit id="55411785328be352b733c3e64dd054a411983253" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io_device&lt;/code&gt; is actually the PID of the process which handles the file. This process is linked to the process which originally opened the file. If any process to which the &lt;code&gt;io_device&lt;/code&gt; is linked terminates, the file will be closed and the process itself will be terminated.</source>
          <target state="translated">&lt;code&gt;io_device&lt;/code&gt; 는 실제로 파일을 처리하는 프로세스의 PID입니다. 이 프로세스는 원래 파일을 연 프로세스와 연결되어 있습니다. &lt;code&gt;io_device&lt;/code&gt; 가 연결된 프로세스가 종료되면 파일이 닫히고 프로세스 자체가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="5af2f0d60c8ca31bd9daa14054f2d8834771b498" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iodata&lt;/code&gt; and &lt;code&gt;chardata&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;iodata&lt;/code&gt; 와 &lt;code&gt;chardata&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea30f7281c750bcdb363bf792a71040fa82420b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;iolist()&lt;/code&gt; | &lt;code&gt;binary()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;iolist()&lt;/code&gt; | &lt;code&gt;binary()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e622f1b70f9ca4dde650995469cb5ac546f01dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_&lt;/code&gt; prefix (&lt;code&gt;is_foo&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;is_&lt;/code&gt; 접두사 ( &lt;code&gt;is_foo&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0ae12fa1bd5cefeb45ca87984e5434aa6c1ab55d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;joiner&lt;/code&gt; can be either a binary or a list and the result will be of the same type as &lt;code&gt;joiner&lt;/code&gt;. If &lt;code&gt;joiner&lt;/code&gt; is not passed at all, it defaults to an empty binary.</source>
          <target state="translated">&lt;code&gt;joiner&lt;/code&gt; 는 이진 또는 목록 일 수 있으며 결과는 &lt;code&gt;joiner&lt;/code&gt; 와 동일한 유형 입니다. 경우 &lt;code&gt;joiner&lt;/code&gt; 전혀 전달되지 빈 이진 기본값.</target>
        </trans-unit>
        <trans-unit id="050495ebb57fd238ad025920a895b7b1b31f5954" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kind&lt;/code&gt; - if the message is a &lt;code&gt;:report&lt;/code&gt; or &lt;code&gt;:format&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;kind&lt;/code&gt; - 메시지가 &lt;code&gt;:report&lt;/code&gt; 또는 &lt;code&gt;:format&lt;/code&gt; 인 경우</target>
        </trans-unit>
        <trans-unit id="341383e5f6f763ffb092f6be26a117949ada5934" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;kind&lt;/code&gt; can be any of &lt;code&gt;:def&lt;/code&gt;, &lt;code&gt;:defp&lt;/code&gt;, &lt;code&gt;:defmacro&lt;/code&gt;, or &lt;code&gt;:defmacrop&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;kind&lt;/code&gt; 는 &lt;code&gt;:def&lt;/code&gt; , &lt;code&gt;:defp&lt;/code&gt; , &lt;code&gt;:defmacro&lt;/code&gt; 또는 &lt;code&gt;:defmacrop&lt;/code&gt; 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43a606e3b01bc357576e2067b4913ba6530c37d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;language: :elixir | :erlang&lt;/code&gt; - set it to &lt;code&gt;:erlang&lt;/code&gt; for Erlang projects managed by Mix. Doing so will ensure Elixir is not embedded by default. Your app will still be started as part of escript loading, with the config used during build.</source>
          <target state="translated">&lt;code&gt;language: :elixir | :erlang&lt;/code&gt; - Mix에서 관리하는 Erlang 프로젝트의 경우 &lt;code&gt;:erlang&lt;/code&gt; 으로 설정하십시오 . 그렇게하면 Elixir가 기본적으로 포함되지 않습니다. 빌드하는 동안 사용 된 구성을 사용하여 앱은 여전히 ​​escript 로딩의 일부로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="1615078eab6862c1223e38ceca7c0c858e7fb3ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;left not in right&lt;/code&gt; is parsed by the compiler into the AST:</source>
          <target state="translated">&lt;code&gt;left not in right&lt;/code&gt; 이 아닌 왼쪽 은 컴파일러에 의해 AST로 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="04daa36a0e26e29c02251806cbf56bde90f72442" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;level&lt;/code&gt; - the level of the message being translated</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; - 메시지의 수준은 번역되고</target>
        </trans-unit>
        <trans-unit id="a0cdec75a5c5e0d6470766585fef67da68441fbb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;level&lt;/code&gt; is one of &lt;code&gt;:debug&lt;/code&gt;, &lt;code&gt;:info&lt;/code&gt;, &lt;code&gt;:warn&lt;/code&gt;, or &lt;code&gt;:error&lt;/code&gt;, as previously described</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 은 앞에서 설명한 것처럼 &lt;code&gt;:debug&lt;/code&gt; , &lt;code&gt;:info&lt;/code&gt; , &lt;code&gt;:warn&lt;/code&gt; 또는 &lt;code&gt;:error&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="ad467d7b51aa9a22263cef951086b6316700c37b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lexical_tracker&lt;/code&gt; - PID of the lexical tracker which is responsible for keeping user info</source>
          <target state="translated">&lt;code&gt;lexical_tracker&lt;/code&gt; - 사용자 정보를 유지하는 어휘 추적기의 PID</target>
        </trans-unit>
        <trans-unit id="00b7f69aa97db45047c5fc9677b43d58013c72d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;line&lt;/code&gt; - the current line as an integer</source>
          <target state="translated">&lt;code&gt;line&lt;/code&gt; - 정수로 현재 행</target>
        </trans-unit>
        <trans-unit id="8a637d2453fa7712dde78a4184c51cb4f28ba3e3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;line_or_bytes&lt;/code&gt; - if reading should read lines or a given number of bytes</source>
          <target state="translated">&lt;code&gt;line_or_bytes&lt;/code&gt; - 읽은 줄이나 주어진 바이트 수를 읽어야하는 경우</target>
        </trans-unit>
        <trans-unit id="de043cb51af4ab5a147a2fd2fb7510e6d4f6968b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;links&lt;/code&gt; - the number of links to this file. This is always 1 for file systems which have no concept of links.</source>
          <target state="translated">&lt;code&gt;links&lt;/code&gt; - 이 파일에 대한 링크 수 링크 개념이없는 파일 시스템의 경우 항상 1입니다.</target>
        </trans-unit>
        <trans-unit id="b6df45129219eb88ff0e445a634f5ec40fa7565a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;list(binary)&lt;/code&gt; - a list of named captures to capture</source>
          <target state="translated">&lt;code&gt;list(binary)&lt;/code&gt; -캡처 할 명명 된 캡처 목록</target>
        </trans-unit>
        <trans-unit id="b30b2f2ca39cc18127aed43526b57922054977d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macro_aliases&lt;/code&gt; - a list of aliases defined inside the current macro</source>
          <target state="translated">&lt;code&gt;macro_aliases&lt;/code&gt; - 현재 매크로 내에 정의 된 별명 목록</target>
        </trans-unit>
        <trans-unit id="e68229a8f305b62b43dd03a0bee3d8371fd691cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;macros&lt;/code&gt; - a list of macros imported from each module</source>
          <target state="translated">&lt;code&gt;macros&lt;/code&gt; -각 모듈에서 가져온 매크로 목록</target>
        </trans-unit>
        <trans-unit id="da01a0ff55acb30995528624346541bfd079654b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;major_device&lt;/code&gt; - identifies the file system where the file is located. In Windows, the number indicates a drive as follows: 0 means A:, 1 means B:, and so on.</source>
          <target state="translated">&lt;code&gt;major_device&lt;/code&gt; - 파일이있는 파일 시스템을 식별합니다. Windows에서 숫자는 다음과 같이 드라이브를 나타냅니다. 0은 A :를 의미하고 1은 B :를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="122658d8aed547a03014a89daa76d75e7458af25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;message&lt;/code&gt; - the message to format. If it is &lt;code&gt;:report&lt;/code&gt;, it is a tuple with &lt;code&gt;{report_type, report_data}&lt;/code&gt;, if it is &lt;code&gt;:format&lt;/code&gt;, it is a tuple with &lt;code&gt;{format_message, format_args}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; - 형식화 할 메시지 이 경우 &lt;code&gt;:report&lt;/code&gt; , 그것은을 가진 튜플이다 &lt;code&gt;{report_type, report_data}&lt;/code&gt; 는 경우 &lt;code&gt;:format&lt;/code&gt; , 그것은을 가진 튜플 &lt;code&gt;{format_message, format_args}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="758cc0c5ee8acd71fe0b83a3e86f48dd145a827c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;message&lt;/code&gt; is the actual message (as chardata)</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; 는 실제 메시지입니다 (chardata).</target>
        </trans-unit>
        <trans-unit id="876c3f9a8c4fd0d3cc2d1f037866f3debf0464cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;metadata&lt;/code&gt; is a keyword list of metadata used when logging the message</source>
          <target state="translated">&lt;code&gt;metadata&lt;/code&gt; 는 메시지를 기록 할 때 사용되는 메타 데이터의 키워드 목록입니다.</target>
        </trans-unit>
        <trans-unit id="a589d4f6762768ff5257c5bba38458ca30db3f60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_level&lt;/code&gt; - the current Logger level</source>
          <target state="translated">&lt;code&gt;min_level&lt;/code&gt; - 현재 로거 레벨</target>
        </trans-unit>
        <trans-unit id="3885fa3becd34b396b52f6d8056bdc58ee479e32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minor_device&lt;/code&gt; - only valid for character devices on Unix. In all other cases, this field is zero.</source>
          <target state="translated">&lt;code&gt;minor_device&lt;/code&gt; -Unix의 문자 장치에만 유효합니다. 다른 모든 경우에는이 필드가 0입니다.</target>
        </trans-unit>
        <trans-unit id="b6340174a39f21a758f5572a672b194a9d24cc3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; - the file permissions.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; - 파일 권한</target>
        </trans-unit>
        <trans-unit id="8a3927965ac3d6f77c51036b665e6f351a35212d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; can be &lt;code&gt;:always&lt;/code&gt;, which means nesting always happen, or &lt;code&gt;:break&lt;/code&gt;, which means nesting only happens inside a group that has been broken.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 는 &lt;code&gt;:always&lt;/code&gt; 일 수 있습니다 . 이는 중첩이 항상 발생 함을 의미하거나 &lt;code&gt;:break&lt;/code&gt; 는 중첩 된 그룹 내에서만 중첩이 발생 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="58c0879f979115e580bc917136d2b58ff8c9f14b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; can be &lt;code&gt;:enabled&lt;/code&gt; or &lt;code&gt;:disabled&lt;/code&gt;. When &lt;code&gt;:enabled&lt;/code&gt;, it will consider the document as fit as soon as it finds the next break, effectively cancelling the break. It will also ignore any &lt;a href=&quot;#force_unfit/1&quot;&gt;&lt;code&gt;force_unfit/1&lt;/code&gt;&lt;/a&gt; in search of the next break.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 는 &lt;code&gt;:enabled&lt;/code&gt; 또는 &lt;code&gt;:disabled&lt;/code&gt; 일 수 있습니다. 시 &lt;code&gt;:enabled&lt;/code&gt; 효과적으로 휴식을 취소, 다음 휴식을 발견, 그것은 바로 적합로 문서를 고려할 것입니다. 또한 다음 나누기를 검색 할 때 &lt;a href=&quot;#force_unfit/1&quot;&gt; &lt;code&gt;force_unfit/1&lt;/code&gt; &lt;/a&gt; 을 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="50100399cfb27f3841672acd2f4af9b485e65862" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; may be &lt;code&gt;:default&lt;/code&gt;, &lt;code&gt;:ascii&lt;/code&gt; or &lt;code&gt;:greek&lt;/code&gt;. The &lt;code&gt;:default&lt;/code&gt; mode considers all non-conditional transformations outlined in the Unicode standard. &lt;code&gt;:ascii&lt;/code&gt; lowercases only the letters A to Z. &lt;code&gt;:greek&lt;/code&gt; includes the context sensitive mappings found in Greek.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 는 &lt;code&gt;:default&lt;/code&gt; , &lt;code&gt;:ascii&lt;/code&gt; 또는 &lt;code&gt;:greek&lt;/code&gt; 일 수 있습니다 . &lt;code&gt;:default&lt;/code&gt; 모드는 유니 코드 표준에 명시된 이외의 모든 조건 변환을 고려한다. &lt;code&gt;:ascii&lt;/code&gt; 는 소문자 A부터 Z까지만 소문자로 표기합니다. &lt;code&gt;:greek&lt;/code&gt; 에는 그리스어로 된 문맥 인식 매핑이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a1aa428e4e231b54bacb63710c1631f262151d79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; may be &lt;code&gt;:default&lt;/code&gt;, &lt;code&gt;:ascii&lt;/code&gt; or &lt;code&gt;:greek&lt;/code&gt;. The &lt;code&gt;:default&lt;/code&gt; mode considers all non-conditional transformations outlined in the Unicode standard. &lt;code&gt;:ascii&lt;/code&gt; uppercases only the letters a to z. &lt;code&gt;:greek&lt;/code&gt; includes the context sensitive mappings found in Greek.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 는 &lt;code&gt;:default&lt;/code&gt; , &lt;code&gt;:ascii&lt;/code&gt; 또는 &lt;code&gt;:greek&lt;/code&gt; 일 수 있습니다 . &lt;code&gt;:default&lt;/code&gt; 모드는 유니 코드 표준에 명시된 이외의 모든 조건 변환을 고려한다. &lt;code&gt;:ascii&lt;/code&gt; 는 대문자 a에서 z까지만 대문자입니다. &lt;code&gt;:greek&lt;/code&gt; 에는 그리스어로 된 문맥 감지 매핑이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a86fdaff8bc5148e78a1c4c04f8fce0a3900889d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modes&lt;/code&gt; - the file modes</source>
          <target state="translated">&lt;code&gt;modes&lt;/code&gt; - 파일 모드</target>
        </trans-unit>
        <trans-unit id="8d0e52c287df97f7b63fd739d48b6d486974eb14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modes_or_function&lt;/code&gt; can either be a list of modes or a function. If it's a list, it's considered to be a list of modes (that are documented below). If it's a function, then it's equivalent to calling &lt;code&gt;open(path, [], modes_or_function)&lt;/code&gt;. See the documentation for &lt;a href=&quot;#open/3&quot;&gt;&lt;code&gt;open/3&lt;/code&gt;&lt;/a&gt; for more information on this function.</source>
          <target state="translated">&lt;code&gt;modes_or_function&lt;/code&gt; 은 모드 목록이거나 함수일 수 있습니다. 목록 인 경우 모드 목록으로 간주됩니다 (아래에 설명되어 있음). 함수 인 경우 &lt;code&gt;open(path, [], modes_or_function)&lt;/code&gt; 을 호출하는 것과 같습니다 . 이 기능에 대한 자세한 내용 은 &lt;a href=&quot;#open/3&quot;&gt; &lt;code&gt;open/3&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34262bd30becc8991857017eb2e5b09e7a70e4f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; - the current module name</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; - 현재 모듈 이름</target>
        </trans-unit>
        <trans-unit id="698d9c8f57c8e28a58401b70d215fc5e4dfe9978" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module&lt;/code&gt; has to be an Elixir module, as &lt;a href=&quot;#split/1&quot;&gt;&lt;code&gt;split/1&lt;/code&gt;&lt;/a&gt; won't work with Erlang-style modules (for example, &lt;code&gt;split(:lists)&lt;/code&gt; raises an error).</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 로서, 엘릭서 모듈이어야 &lt;a href=&quot;#split/1&quot;&gt; &lt;code&gt;split/1&lt;/code&gt; &lt;/a&gt; (예컨대, 윌 얼랑 스타일 모듈하지 일 &lt;code&gt;split(:lists)&lt;/code&gt; 에러를 발생).</target>
        </trans-unit>
        <trans-unit id="548b3515fdb43f8aa1119d92ad82f1b43b9de201" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modules&lt;/code&gt; - as defined in the child specification</source>
          <target state="translated">&lt;code&gt;modules&lt;/code&gt; 하위 스펙에 정의 된 모듈</target>
        </trans-unit>
        <trans-unit id="5b0d17e736b2173d4e4a1a204473eec63e0cda5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modules&lt;/code&gt; - as specified by the child specification</source>
          <target state="translated">&lt;code&gt;modules&lt;/code&gt; 하위 스펙에 지정된 모듈</target>
        </trans-unit>
        <trans-unit id="b3e68cee7399cd5a129a86e8776d09db0b50d6de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;msg&lt;/code&gt; is the message and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. When a timeout occurs the message is &lt;code&gt;:timeout&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;msg&lt;/code&gt; 는 메시지이고 &lt;code&gt;state&lt;/code&gt; 는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 의 현재 상태입니다 . 시간 초과가 발생하면 메시지는 &lt;code&gt;:timeout&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="235eae13b2d8f1e8b35533fb20776ffccdd37a72" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mtime&lt;/code&gt; - the last time the file was written.</source>
          <target state="translated">&lt;code&gt;mtime&lt;/code&gt; - 파일이 마지막으로 작성된 시간</target>
        </trans-unit>
        <trans-unit id="4413bd051f5b2ef5173fbddf4ea926ec05b4ccf2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multiline&lt;/code&gt; (m) - causes &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; to mark the beginning and end of each line; use &lt;code&gt;\A&lt;/code&gt; and &lt;code&gt;\z&lt;/code&gt; to match the end or beginning of the string</source>
          <target state="translated">&lt;code&gt;multiline&lt;/code&gt; (m)- &lt;code&gt;^&lt;/code&gt; 와 &lt;code&gt;$&lt;/code&gt; 가 각 줄의 시작과 끝을 표시합니다. &lt;code&gt;\A&lt;/code&gt; 와 &lt;code&gt;\z&lt;/code&gt; 를 사용 하여 문자열의 끝이나 시작과 일치</target>
        </trans-unit>
        <trans-unit id="1aa7f499be35910aae1a7c96d198532426312d81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; can be a negative value: if it is, the corresponding expression value relative to the current one is returned. For example, &lt;code&gt;v(-2)&lt;/code&gt; returns the value of the expression evaluated before the last evaluated expression. In particular, &lt;code&gt;v(-1)&lt;/code&gt; returns the result of the last evaluated expression and &lt;code&gt;v()&lt;/code&gt; does the same.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 은 음수 값일 수 있습니다. 값이면 현재 값을 기준으로 해당 표현식 값이 반환됩니다. 예를 들어, &lt;code&gt;v(-2)&lt;/code&gt; 는 마지막으로 평가 된 표현식 전에 평가 된 표현식의 값을 반환합니다. 특히 &lt;code&gt;v(-1)&lt;/code&gt; 은 마지막으로 평가 된 식의 결과를 반환하고 &lt;code&gt;v()&lt;/code&gt; 는 동일하게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="45c8a3e19ab3e2ddbc2090990f79c346b752b3be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; is an integer greater than or equal to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;0&lt;/code&gt; 이상의 정수 입니다.</target>
        </trans-unit>
        <trans-unit id="5659d6236346e538cb5cb8cba7c914efd4b16565" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name/0&lt;/code&gt; to create a new record with default values for all fields</source>
          <target state="translated">&lt;code&gt;name/0&lt;/code&gt; 모든 필드의 기본값으로 새 레코드를 작성하려면 name / 0</target>
        </trans-unit>
        <trans-unit id="f6ba1c0b71b535b43431e95788b71f1fdb5ee903" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name/1&lt;/code&gt; to create a new record with the given fields and values, to get the zero-based index of the given field in a record or to convert the given record to a keyword list</source>
          <target state="translated">&lt;code&gt;name/1&lt;/code&gt; 주어진 필드 및 값으로 새 레코드를 작성하거나, 레코드에서 지정된 필드의 0부터 시작하는 색인을 얻거나, 주어진 레코드를 키워드 목록으로 변환하기 위해 name / 1</target>
        </trans-unit>
        <trans-unit id="cd9835c312b0e62d1d19feb8dd6a112dd5f5a0e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name/2&lt;/code&gt; to update an existing record with the given fields and values or to access a given field in a given record</source>
          <target state="translated">&lt;code&gt;name/2&lt;/code&gt; 지정된 필드 및 값으로 기존 레코드를 업데이트하거나 지정된 레코드의 지정된 필드에 액세스하려면 이름 / 2</target>
        </trans-unit>
        <trans-unit id="64a47b8a0625c2774e6a643cd7191d74cfc61cda" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt; must be an atom and can then be used instead of the PID/port identifier when sending messages with &lt;a href=&quot;kernel#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 은 아톰이어야하며 &lt;a href=&quot;kernel#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; 로&lt;/a&gt; 메시지를 보낼 때 PID / 포트 식별자 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91d48a3d18e54472d43b317cb1d047ea37a8ead4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;, which is the name of the extracted record, is expected to be an atom &lt;em&gt;at compile time&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 추출 된 레코드의 이름이고, 원자 것으로 예상된다 &lt;em&gt;컴파일시&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ec3f729a0f6c717fcfbc43d515a7ec59810c5367" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;native&lt;/code&gt; is determined by the VM at startup and will depend on the host operating system.</source>
          <target state="translated">&lt;code&gt;native&lt;/code&gt; 은 시작시 VM에 의해 결정되며 호스트 운영 체제에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="301f84b74fc20491f743cd765b9febdae2256dd4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new_data&lt;/code&gt; is &lt;code&gt;data&lt;/code&gt; after updating the value of &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;update_value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_data&lt;/code&gt; 는 인 &lt;code&gt;data&lt;/code&gt; 의 값을 업데이트 한 후 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;update_value&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="8f28f31350f1c7665853e6d4b5999e6152b971b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;newline&lt;/code&gt; - not available, use &lt;code&gt;(*CR)&lt;/code&gt; or &lt;code&gt;(*LF)&lt;/code&gt; or &lt;code&gt;(*CRLF)&lt;/code&gt; or &lt;code&gt;(*ANYCRLF)&lt;/code&gt; or &lt;code&gt;(*ANY)&lt;/code&gt; at the beginning of the regexp according to the &lt;code&gt;:re&lt;/code&gt; documentation</source>
          <target state="translated">&lt;code&gt;newline&lt;/code&gt; -사용할 수없는 경우 &lt;code&gt;:re&lt;/code&gt; documentation 에 따라 정규 표현식 시작 부분에 &lt;code&gt;(*CR)&lt;/code&gt; 또는 &lt;code&gt;(*LF)&lt;/code&gt; 또는 &lt;code&gt;(*CRLF)&lt;/code&gt; 또는 &lt;code&gt;(*ANYCRLF)&lt;/code&gt; 또는 &lt;code&gt;(*ANY)&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="22526a6e658f1a28d28bf75f04eb407c154f8ec9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; (v1.0)</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; (v1.0)</target>
        </trans-unit>
        <trans-unit id="6fab3275a5dbf0c17e6bb5dbfbc499091c5cb4ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nil&lt;/code&gt; if the task keeps running past the timeout</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 작업이 시간 초과를지나 계속 실행되면 nil</target>
        </trans-unit>
        <trans-unit id="0d2d366e73b9ec112919fa2886cd3525aa66ea55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;no_auto_capture&lt;/code&gt; - not available, use &lt;code&gt;?:&lt;/code&gt; instead</source>
          <target state="translated">&lt;code&gt;no_auto_capture&lt;/code&gt; - 사용할 수 없습니다 &lt;code&gt;?:&lt;/code&gt; 대신 ? :를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="408ece252fdd1021e44cd3be96e784b7803ec157" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nodes&lt;/code&gt; is a list of node names to which the request is sent. The default value is the list of all known nodes (including this node).</source>
          <target state="translated">&lt;code&gt;nodes&lt;/code&gt; 는 요청이 전송되는 노드 이름 목록입니다. 기본값은 알려진 모든 노드 (이 노드 포함)의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="8137eb4c3f6c478804bd118d3101e44c85663fab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nth&lt;/code&gt; must be a non-negative integer.</source>
          <target state="translated">&lt;code&gt;nth&lt;/code&gt; 는 음이 아닌 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f3b3f1b4b4b341558fb4af537b367fd2795f31d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; is either a &lt;code&gt;pid&lt;/code&gt; of the monitored process (if monitoring a PID) or &lt;code&gt;{name, node}&lt;/code&gt; (if monitoring a remote or local name);</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 중 하나 인 &lt;code&gt;pid&lt;/code&gt; 또는 (a PID 감시 경우) 모니터링 프로세스 &lt;code&gt;{name, node}&lt;/code&gt; (원격 또는 로컬 이름을 모니터링하는 경우);</target>
        </trans-unit>
        <trans-unit id="60373c8878902ec332f31b76bff00eee4691253c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;object&lt;/code&gt; is either the &lt;code&gt;port&lt;/code&gt; being monitored (when monitoring by port ID) or &lt;code&gt;{name, node}&lt;/code&gt; (when monitoring by a port name);</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 는 모니터중인 &lt;code&gt;port&lt;/code&gt; (포트 ID로 모니터링 할 때) 또는 &lt;code&gt;{name, node}&lt;/code&gt; (포트 이름으로 모니터링 할 때)입니다.</target>
        </trans-unit>
        <trans-unit id="f4103502bdc67af84a755c711febd0144e731649" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;old_vsn&lt;/code&gt; is the previous version of the module (defined by the &lt;code&gt;@vsn&lt;/code&gt; attribute) when upgrading. When downgrading the previous version is wrapped in a 2-tuple with first element &lt;code&gt;:down&lt;/code&gt;. &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;extra&lt;/code&gt; is any extra data required to change the state.</source>
          <target state="translated">&lt;code&gt;old_vsn&lt;/code&gt; 은 업그레이드시 모듈의 이전 버전 ( &lt;code&gt;@vsn&lt;/code&gt; 속성으로 정의 )입니다. 이전 버전을 다운 그레이드 할 때 첫 번째 요소 &lt;code&gt;:down&lt;/code&gt; 과 함께 2 개의 튜플로 래핑 됩니다 . &lt;code&gt;state&lt;/code&gt; 는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 의 현재 상태 이며 &lt;code&gt;extra&lt;/code&gt; 는 상태를 변경하는 데 필요한 추가 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="571d94e13302249f0de59d56d782ae3e234cacb0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options_or_function&lt;/code&gt; can be a keyword list of options or a function.</source>
          <target state="translated">&lt;code&gt;options_or_function&lt;/code&gt; 은 키워드 옵션 또는 함수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bab089b1bf1e41f034e7ae6bdb132bc0001b94a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;or&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt; are short-circuit operators. They only execute the right side if the left side is not enough to determine the result:</source>
          <target state="translated">&lt;code&gt;or&lt;/code&gt; 및 &lt;code&gt;and&lt;/code&gt; 단락 회로 운영된다. 왼쪽이 결과를 결정하기에 충분하지 않은 경우에만 오른쪽을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="ccbe854a095f6f33ceeba28c9b8d43c2cbc1d56a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parsed&lt;/code&gt; is a keyword list of parsed switches with &lt;code&gt;{switch_name, value}&lt;/code&gt; tuples in it; &lt;code&gt;switch_name&lt;/code&gt; is the atom representing the switch name while &lt;code&gt;value&lt;/code&gt; is the value for that switch parsed according to &lt;code&gt;opts&lt;/code&gt; (see the &quot;Examples&quot; section for more information)</source>
          <target state="translated">&lt;code&gt;parsed&lt;/code&gt; 는 &lt;code&gt;{switch_name, value}&lt;/code&gt; 튜플이있는 구문 분석 된 스위치의 키워드 목록입니다 . &lt;code&gt;switch_name&lt;/code&gt; 은 스위치 이름을 나타내는 원자이고 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;opts&lt;/code&gt; 에 따라 구문 분석 된 스위치의 값입니다 (자세한 내용은 &quot;예&quot;섹션 참조).</target>
        </trans-unit>
        <trans-unit id="b1fbee1588161b4bf8e5a810b28d741081f25011" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parsed&lt;/code&gt; is the list of parsed switches (same as in &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;parsed&lt;/code&gt; 는 구문 분석 된 스위치의 목록입니다 ( &lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt; 와 동일 )</target>
        </trans-unit>
        <trans-unit id="2788d1165c4896248d485fc9d7605024d3d940c1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parsed&lt;/code&gt; is the list of parsed switches (same as in &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;parsed&lt;/code&gt; 는 구문 분석 된 스위치 목록입니다 ( &lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; &lt;/a&gt; 와 동일 ).</target>
        </trans-unit>
        <trans-unit id="56a1d646feea00078c3dafde93470f5d90c7d9db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; - the file path</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; - 파일 경로</target>
        </trans-unit>
        <trans-unit id="c68a85ae9613cab9896c95f71c08475d4a1e6f88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;path&lt;/code&gt; has to be a literal string and is automatically expanded via &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 는 리터럴 문자열이어야하며 &lt;a href=&quot;https://hexdocs.pm/elixir/Path.html#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; 을&lt;/a&gt; 통해 자동으로 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="bff908c352a7c02daae4149d788dab257dcc7734" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pdict_and_state&lt;/code&gt; is a two-elements list &lt;code&gt;[pdict, state]&lt;/code&gt; where &lt;code&gt;pdict&lt;/code&gt; is a list of &lt;code&gt;{key, value}&lt;/code&gt; tuples representing the current process dictionary of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pdict_and_state&lt;/code&gt; 이 두 요소 목록 &lt;code&gt;[pdict, state]&lt;/code&gt; 여기서 &lt;code&gt;pdict&lt;/code&gt; 이 목록이다 &lt;code&gt;{key, value}&lt;/code&gt; 의 현재 프로세스 사전 나타내는 튜플 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 가&lt;/a&gt; 및 &lt;code&gt;state&lt;/code&gt; 의 현재 상태 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c00f6b21503d6f14ec9e351116f82e98a1a573d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid()&lt;/code&gt; | &lt;code&gt;port()&lt;/code&gt; | &lt;code&gt;reference()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pid()&lt;/code&gt; | &lt;code&gt;port()&lt;/code&gt; | &lt;code&gt;reference()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="283bbf3a7e63361529544f57e65445c33be2473a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; is the PID of the caller and &lt;code&gt;tag&lt;/code&gt; is a unique term used to identify the call.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 는 호출자의 PID이며 &lt;code&gt;tag&lt;/code&gt; 는 호출을 식별하는 데 사용되는 고유 한 용어입니다.</target>
        </trans-unit>
        <trans-unit id="7472d33de0e4e4c6d6bc5be3bc64d1117f76ab97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pid&lt;/code&gt; must refer to a process running on the local node or &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 는 로컬 노드에서 실행중인 프로세스를 참조해야합니다 . 그렇지 않으면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="167a28851306fdaf355a0b9d87bd9e06c3264602" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;plain&lt;/code&gt; - the same as pretty except ASCII characters are used instead of Unicode characters. This is the default on Windows;</source>
          <target state="translated">&lt;code&gt;plain&lt;/code&gt; -유니 코드 문자 대신 ASCII 문자가 사용된다는 점을 제외하고는 거의 동일합니다. 이것이 Windows의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="d8a4a973778edbc3b9292682c2961c04afdada51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prefix&lt;/code&gt; can be either a string, a list of strings, or a compiled pattern.</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; 는 문자열, 문자열 목록 또는 컴파일 된 패턴 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7a7b88e7dfa1815defebaaadeadc69b2b64802d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pretty&lt;/code&gt; - prints the graph to the terminal using Unicode characters. Each prints each file followed by the files it depends on. This is the default except on Windows;</source>
          <target state="translated">&lt;code&gt;pretty&lt;/code&gt; - 유니 코드 문자를 사용하여 그래프를 터미널에 인쇄합니다. 각각은 각 파일과 그에 의존하는 파일을 인쇄합니다. 이것이 Windows를 제외한 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="a5c6719a29e3444d2a98704658b2abe3abc07b42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;raw&lt;/code&gt; - a boolean indicating if bin functions should be used</source>
          <target state="translated">&lt;code&gt;raw&lt;/code&gt; -bin 함수를 사용해야하는지 여부를 나타내는 부울</target>
        </trans-unit>
        <trans-unit id="2413f2dcbac9c52ab69f886cdee3aec797acde03" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reason&lt;/code&gt; is exit reason and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The return value is ignored.</source>
          <target state="translated">&lt;code&gt;reason&lt;/code&gt; 은 종료 reason이고 &lt;code&gt;state&lt;/code&gt; 는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 의 현재 상태입니다 . 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3d14f1d74048b142cf9c3c866e8baef03f5f628e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reason&lt;/code&gt; is the exit reason.</source>
          <target state="translated">&lt;code&gt;reason&lt;/code&gt; 는 종료 이유입니다.</target>
        </trans-unit>
        <trans-unit id="017b38f6c3a63b34a77cb61fad862a0108619da3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; is a monitor reference returned by this function;</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 는이 함수에 의해 반환되는 모니터 참조입니다.</target>
        </trans-unit>
        <trans-unit id="f1dac4945e37fa410a22296831615f2618a6f8b6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rel/env.sh.eex&lt;/code&gt; and &lt;code&gt;rel/env.bat.eex&lt;/code&gt; - template files that are copied into every release and executed on every command to set up environment variables, including ones specific to the VM, and the general environment</source>
          <target state="translated">&lt;code&gt;rel/env.sh.eex&lt;/code&gt; 및 &lt;code&gt;rel/env.bat.eex&lt;/code&gt; - 모든 릴리스에 복사되고 모든 명령에서 실행되어 VM과 관련된 환경 변수 및 일반 환경을 포함한 환경 변수를 설정하는 템플릿 파일</target>
        </trans-unit>
        <trans-unit id="c19918b14a9453c91c643c933cd15244538fc1e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rel/vm.args.eex&lt;/code&gt; - a template file that is copied into every release and provides static configuration of the Erlang Virtual Machine and other runtime flags</source>
          <target state="translated">&lt;code&gt;rel/vm.args.eex&lt;/code&gt; - 모든 릴리즈에 복사되고 Erlang 가상 머신 및 기타 런타임 플래그의 정적 구성을 제공하는 템플리트 파일</target>
        </trans-unit>
        <trans-unit id="7f40a3451ab81b3153487e704b02d37b9b6a4ead" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replies&lt;/code&gt; - is a list of &lt;code&gt;{node, reply}&lt;/code&gt; tuples where &lt;code&gt;node&lt;/code&gt; is the node that replied and &lt;code&gt;reply&lt;/code&gt; is its reply</source>
          <target state="translated">&lt;code&gt;replies&lt;/code&gt; - &lt;code&gt;{node, reply}&lt;/code&gt; 튜플 의 목록입니다. 여기서 &lt;code&gt;node&lt;/code&gt; 는 응답 한 노드이고 &lt;code&gt;reply&lt;/code&gt; 는 해당 응답입니다.</target>
        </trans-unit>
        <trans-unit id="1e85e74a7cd5534b5dc26bb806f6e8445febf275" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;request&lt;/code&gt; is the request message sent by a &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;from&lt;/code&gt; is a 2-tuple containing the caller's PID and a term that uniquely identifies the call, and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;request&lt;/code&gt; 는 &lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt; 의해 전송 된 요청 메시지 이며 &lt;code&gt;from&lt;/code&gt; 은 호출자의 PID와 호출을 고유하게 식별하는 용어를 포함하는 2- 튜플이며 &lt;code&gt;state&lt;/code&gt; 는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 의 현재 상태입니다 .</target>
        </trans-unit>
        <trans-unit id="04e74abb0f4cf0d18536a2a96e905cc0f6069b33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;request&lt;/code&gt; is the request message sent by a &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;state&lt;/code&gt; is the current state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;request&lt;/code&gt; 는 &lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; 에&lt;/a&gt; 의해 전송 된 요청 메시지 이고 &lt;code&gt;state&lt;/code&gt; 는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 의 현재 상태입니다 .</target>
        </trans-unit>
        <trans-unit id="93816bb90205c96752dc4b1f4768e5dfd91ffd4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;requires&lt;/code&gt; - the list of required modules</source>
          <target state="translated">&lt;code&gt;requires&lt;/code&gt; - 필수 모듈 목록</target>
        </trans-unit>
        <trans-unit id="6c48083bf2c441634af8637cbd181b09103d558d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rescue&lt;/code&gt; clauses</source>
          <target state="translated">&lt;code&gt;rescue&lt;/code&gt; 조항</target>
        </trans-unit>
        <trans-unit id="c088bb2e30718916b5822f6df8045124d80cf2b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rescue&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;/&lt;code&gt;after&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;rescue&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;/&lt;code&gt;after&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fafec51a6ba058e17a08730a003c35a45d91a237" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rest&lt;/code&gt; is the list of arguments (same as in &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;rest&lt;/code&gt; 는 인수 목록입니다 ( &lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt; 와 동일 )</target>
        </trans-unit>
        <trans-unit id="99d571b4f50dd13d3d5dab2e90c0858010d81600" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rest&lt;/code&gt; is the list of arguments (same as in &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;rest&lt;/code&gt; 는 인수 목록입니다 ( &lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; &lt;/a&gt; 와 동일 )</target>
        </trans-unit>
        <trans-unit id="3bfa723258218ecec6b8ad74fe2b88b2c40ccf7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;s&lt;/code&gt;: words in the list are strings (default)</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; : 목록의 단어는 문자열입니다 (기본값)</target>
        </trans-unit>
        <trans-unit id="62965b3fa200d2fcdd302a063393661d33658602" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;send&lt;/code&gt; and &lt;code&gt;receive&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 및 &lt;code&gt;receive&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f2218676f02b43a5d86faf5ba604881574737c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;serve/1&lt;/code&gt; is another loop that reads a line from the socket and writes those lines back to the socket. Note that the &lt;code&gt;serve/1&lt;/code&gt; function uses &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt;the pipe operator &lt;code&gt;|&amp;gt;&lt;/code&gt;&lt;/a&gt; to express this flow of operations. The pipe operator evaluates the left side and passes its result as the first argument to the function on the right side. The example above:</source>
          <target state="translated">&lt;code&gt;serve/1&lt;/code&gt; 은 소켓에서 한 줄을 읽고 해당 줄을 다시 소켓에 쓰는 또 다른 루프입니다. 노트는 그 &lt;code&gt;serve/1&lt;/code&gt; 함수를 사용하여 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#%7C%3E/2&quot;&gt;파이프 연산자 &lt;code&gt;|&amp;gt;&lt;/code&gt; &lt;/a&gt; 동작의 흐름을 표현. 파이프 연산자는 왼쪽을 평가하고 결과를 첫 번째 인수로 오른쪽의 함수에 전달합니다. 위의 예 :</target>
        </trans-unit>
        <trans-unit id="4035242838ff6348de2918394188b203c1cec888" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server&lt;/code&gt; can be any of the values described in the &quot;Name registration&quot; section of the documentation for this module.</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; 는이 모듈에 대한 문서의 &quot;이름 등록&quot;섹션에 설명 된 값 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bd4d2b94c9ed5de47dab724a819b4256c36fb8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setup&lt;/code&gt; and &lt;code&gt;setup_all&lt;/code&gt; callbacks can be defined by a block, by passing an atom naming a one-arity function, or by passing a list of such atoms. Both can opt to receive the current context by specifying it as parameter if defined by a block. Functions used to define a test setup must accept the context as single argument.</source>
          <target state="translated">&lt;code&gt;setup&lt;/code&gt; 및 &lt;code&gt;setup_all&lt;/code&gt; 콜백은 하나의 원자 이름을 갖는 원자를 전달하거나 그러한 원자의 목록을 전달하여 블록으로 정의 할 수 있습니다. 둘 다 블록으로 정의 된 경우 현재 컨텍스트를 매개 변수로 지정하여 현재 컨텍스트를 수신하도록 선택할 수 있습니다. 테스트 설정을 정의하는 데 사용되는 함수는 컨텍스트를 단일 인수로 승인해야합니다.</target>
        </trans-unit>
        <trans-unit id="74e50f77430f1a1bdfe5ca63476784209360d3eb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;signed&lt;/code&gt; and &lt;code&gt;unsigned&lt;/code&gt; are only used for matching binaries (see below) and are only used for integers.</source>
          <target state="translated">&lt;code&gt;signed&lt;/code&gt; 와 &lt;code&gt;unsigned&lt;/code&gt; 는 이진 일치 (아래 참조)에만 사용되며 정수에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cfa5ba00cd0c9fad3ce7a3c8fe2e154e61d87770" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt; - size of file in bytes.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; - 바이트에서 파일의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="0a4f18566a210c559013bf9a5086044257909566" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;source_file&lt;/code&gt; and &lt;code&gt;destination_file&lt;/code&gt; must be a file or a symbolic link to one, or in the case of destination, a path to a non-existent file. If either one of them is a directory, &lt;code&gt;{:error, :eisdir}&lt;/code&gt; will be returned.</source>
          <target state="translated">&lt;code&gt;source_file&lt;/code&gt; 및 &lt;code&gt;destination_file&lt;/code&gt; 은 파일이거나 대상의 경우 존재하지 않는 파일의 경로에 대한 파일 또는 심볼릭 링크 여야합니다. 둘 중 하나가 디렉토리이면 &lt;code&gt;{:error, :eisdir}&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="38212c1b9d372738da7952d34b2b9942eed99263" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spawn/1&lt;/code&gt; and &lt;code&gt;spawn_link/1&lt;/code&gt; are the basic primitives for creating processes in Elixir. Although we have used them exclusively so far, most of the time we are going to use abstractions that build on top of them. Let&amp;rsquo;s see the most common one, called tasks.</source>
          <target state="translated">&lt;code&gt;spawn/1&lt;/code&gt; 및 &lt;code&gt;spawn_link/1&lt;/code&gt; 은 Elixir에서 프로세스를 생성하기위한 기본 프리미티브입니다. 우리는 지금까지 독점적으로 사용했지만 대부분은 그 위에 구축 된 추상화를 사용할 것입니다. 가장 일반적인 작업 인 작업을 봅시다.</target>
        </trans-unit>
        <trans-unit id="ef8e38976f8ee83eeb6656542cc862dd86ba301d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;spawn/1&lt;/code&gt; takes a function which it will execute in another process.</source>
          <target state="translated">&lt;code&gt;spawn/1&lt;/code&gt; 은 다른 프로세스에서 실행될 함수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9161cde7817a029486e4390329e091bf1151d940" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_args&lt;/code&gt; are the arguments passed to the application in the &lt;code&gt;:mod&lt;/code&gt; specification key (e.g., &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;start_args&lt;/code&gt; 는 &lt;code&gt;:mod&lt;/code&gt; 사양 키 에서 응용 프로그램으로 전달되는 인수입니다 (예 &lt;code&gt;mod: {MyApp, [:my_args]}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fe417925fd6a03a1cadb38a84034165856ff0856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_link/2&lt;/code&gt;, &lt;code&gt;init/2&lt;/code&gt;, and strategies</source>
          <target state="translated">&lt;code&gt;start_link/2&lt;/code&gt; , &lt;code&gt;init/2&lt;/code&gt; 및 전략</target>
        </trans-unit>
        <trans-unit id="2e7dcff739bcad8d1857be2bedb467d433c4d61c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_type&lt;/code&gt; defines how the application is started:</source>
          <target state="translated">&lt;code&gt;start_type&lt;/code&gt; 은 응용 프로그램이 시작되는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="bed6184e7c750cc712f2203171e1d9b7e789646a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;state&lt;/code&gt; is the state returned by &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt;, if it did, or &lt;code&gt;[]&lt;/code&gt; otherwise. If the optional callback &lt;a href=&quot;#c:prep_stop/1&quot;&gt;&lt;code&gt;prep_stop/1&lt;/code&gt;&lt;/a&gt; is present, &lt;code&gt;state&lt;/code&gt; is its return value instead.</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 에 의해 반환 된 상태 &lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; 가 한 경우, 또는, &lt;code&gt;[]&lt;/code&gt; 그렇지. 선택적 콜백 &lt;a href=&quot;#c:prep_stop/1&quot;&gt; &lt;code&gt;prep_stop/1&lt;/code&gt; &lt;/a&gt; 이 있으면 &lt;code&gt;state&lt;/code&gt; 는 대신 반환 값입니다.</target>
        </trans-unit>
        <trans-unit id="2e6893ab1b754c2ae7dc9f997ecb10ec083f344f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stats&lt;/code&gt; - prints general statistics about the graph;</source>
          <target state="translated">&lt;code&gt;stats&lt;/code&gt; -그래프에 대한 일반 통계를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2790d8f945460f49048af9ed95a7afa73085f9a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt; must be a non-negative integer value which is returned by the runtime system to the operating system.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; 는 음수가 아닌 정수 값이어야하며 런타임 시스템에서 운영 체제로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8c1f069e75f041dd495821b88b772c17da451669" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;status&lt;/code&gt; must be a non-negative integer, the atom &lt;code&gt;:abort&lt;/code&gt; or a binary.</source>
          <target state="translated">&lt;code&gt;status&lt;/code&gt; 는 음이 아닌 정수, atom &lt;code&gt;:abort&lt;/code&gt; 또는 2 진 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d6ac53a1094c979479b6f1b561f3e74f3968e85d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;step&lt;/code&gt; is optional and, if not passed, defaults to &lt;code&gt;count&lt;/code&gt;, i.e. chunks do not overlap.</source>
          <target state="translated">&lt;code&gt;step&lt;/code&gt; 은 선택 사항이며, 전달되지 않은 경우 기본값은 &lt;code&gt;count&lt;/code&gt; 입니다 . 즉 청크가 겹치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07277647df2178950f06633decd26215f156ae7b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; must be the string representation of a float including a decimal point. In order to parse a string without decimal point as a float then &lt;a href=&quot;float#parse/1&quot;&gt;&lt;code&gt;Float.parse/1&lt;/code&gt;&lt;/a&gt; should be used. Otherwise, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 은 소수점을 포함한 float의 문자열 표현이어야합니다. 소수점이없는 문자열을 부동 소수점으로 구문 분석하려면 &lt;a href=&quot;float#parse/1&quot;&gt; &lt;code&gt;Float.parse/1&lt;/code&gt; 을&lt;/a&gt; 사용해야합니다. 그렇지 않으면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3a57ce393e0bf34dc0ca576de7675a4598947d32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; must be the string representation of an integer. Otherwise, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; will be raised. If you want to parse a string that may contain an ill-formatted integer, use &lt;a href=&quot;integer#parse/1&quot;&gt;&lt;code&gt;Integer.parse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 은 정수의 문자열 표현이어야합니다. 그렇지 않으면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 형식이 잘못된 정수를 포함 할 수있는 문자열을 구문 분석하려면 &lt;a href=&quot;integer#parse/1&quot;&gt; &lt;code&gt;Integer.parse/1&lt;/code&gt; 을 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a8f508a843dbaf6b9d5439d982a8903dd2999cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; will be the initial input of the newly created device.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 은 새로 생성 된 장치의 초기 입력입니다.</target>
        </trans-unit>
        <trans-unit id="572985c443231f1ffed373013f737ade9f044914" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;suffixes&lt;/code&gt; can be either a single suffix or a list of suffixes.</source>
          <target state="translated">&lt;code&gt;suffixes&lt;/code&gt; 는 단일 접미사 또는 접미사 목록 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdbf5dd9e7ab5c58f01c1dec17c4fb41c8b81931" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; is an integer greater than zero which specifies how many milliseconds are allowed before the agent executes the function and returns the result value, or the atom &lt;code&gt;:infinity&lt;/code&gt; to wait indefinitely. If no result is received within the specified time, the function call fails and the caller exits.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 은 0보다 큰 정수로, 에이전트가 함수를 실행하고 결과 값을 반환하기 전에 허용되는 밀리 초 (밀리 초) 또는 무기 &lt;code&gt;:infinity&lt;/code&gt; 대기 시간을 지정합니다. 지정된 시간 내에 결과가 수신되지 않으면 함수 호출이 실패하고 호출자가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="1d95411839d7e41402b228ea7bab4f308778467d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; is an integer greater than zero which specifies how many milliseconds to wait for a reply, or the atom &lt;code&gt;:infinity&lt;/code&gt; to wait indefinitely. The default value is &lt;code&gt;5000&lt;/code&gt;. If no reply is received within the specified time, the function call fails and the caller exits. If the caller catches the failure and continues running, and the server is just late with the reply, it may arrive at any time later into the caller's message queue. The caller must in this case be prepared for this and discard any such garbage messages that are two-element tuples with a reference as the first element.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 은 응답을 기다리는 시간 (밀리 초) 또는 atom &lt;code&gt;:infinity&lt;/code&gt; 를 무한정 기다리는 시간을 지정하는 0보다 큰 정수 입니다. 기본값은 &lt;code&gt;5000&lt;/code&gt; 입니다. 지정된 시간 내에 응답이 수신되지 않으면 함수 호출이 실패하고 호출자가 종료됩니다. 호출자가 실패를 발견하고 계속 실행하고 서버가 응답이 늦어지면 언제든지 호출자의 메시지 큐에 도착할 수 있습니다. 이 경우 호출자는이를 준비하고 첫 번째 요소로 참조되는 두 요소 튜플 인 가비지 메시지를 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f68b2a1cb84499ed2c00c6482e49eeac64039aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timeout&lt;/code&gt; is either the number of milliseconds to sleep as an integer or the atom &lt;code&gt;:infinity&lt;/code&gt;. When &lt;code&gt;:infinity&lt;/code&gt; is given, the current process will sleep forever, and not consume or reply to messages.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 은 정수로 잠자기하는 밀리 초 수 또는 atom &lt;code&gt;:infinity&lt;/code&gt; 입니다. 때 &lt;code&gt;:infinity&lt;/code&gt; 주어, 현재 프로세스 영원히 잠, 그리고 소비 또는 메시지에 회신하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d03dca1cbfe2406a67e381ab2870ef2bddd059b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;timestamp&lt;/code&gt; is the timestamp for when the message was logged, as a &lt;code&gt;{{year, month, day}, {hour, minute, second, millisecond}}&lt;/code&gt; tuple</source>
          <target state="translated">&lt;code&gt;timestamp&lt;/code&gt; 는 메시지가 &lt;code&gt;{{year, month, day}, {hour, minute, second, millisecond}}&lt;/code&gt; 튜플 로 기록 된 타임 스탬프 입니다.</target>
        </trans-unit>
        <trans-unit id="08d7a6e449b07af8124dddd49b8a31de7399fb11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; - pad the output string to the nearest multiple of 8 (default)</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; - 출력 문자열을 가장 가까운 8의 배수로 채 웁니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="4948e3624434de9113da8f38917d02367479d2b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; - requires the input string to be padded to the nearest multiple of 8 (default)</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; - 입력 문자열을 가장 가까운 8의 배수로 채 웁니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="37f317994df4c5094e8b2eff3348d68fdc66f93d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be5f7234d664879c7a94dbc62ea230645de6ab29" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt; | &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; | &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8f74a2bb6fb5fbbcf93b8f217f0cc291412b0a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; - used as atoms</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;nil&lt;/code&gt; - 원자로 사용</target>
        </trans-unit>
        <trans-unit id="040c2cc20f87605723b2be4cdc0803a474de3d24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;nil&lt;/code&gt; are reserved words that are represented by the atoms &lt;code&gt;:true&lt;/code&gt;, &lt;code&gt;:false&lt;/code&gt; and &lt;code&gt;:nil&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 및 &lt;code&gt;nil&lt;/code&gt; 은 각각 원자 &lt;code&gt;:true&lt;/code&gt; , &lt;code&gt;:false&lt;/code&gt; 및 &lt;code&gt;:nil&lt;/code&gt; 로 표시되는 예약어 입니다.</target>
        </trans-unit>
        <trans-unit id="256ad4bcf7e37fd9a26fac8676e48361c0ed6b79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:device | :directory | :regular | :other | :symlink&lt;/code&gt;; the type of the file.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:device | :directory | :regular | :other | :symlink&lt;/code&gt; ; 파일의 형태</target>
        </trans-unit>
        <trans-unit id="300d31ca0e6078f76938d4d6e305aff178a1dd44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:worker&lt;/code&gt; or &lt;code&gt;:supervisor&lt;/code&gt; as defined in the child specification</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:worker&lt;/code&gt; 또는 &lt;code&gt;:supervisor&lt;/code&gt; 자식 사양에 정의 된대로</target>
        </trans-unit>
        <trans-unit id="1b592d0e2922f716b9d2f7ecf2cb31932d6201bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:worker&lt;/code&gt; or &lt;code&gt;:supervisor&lt;/code&gt;, as specified by the child specification</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; - &lt;code&gt;:worker&lt;/code&gt; 나 &lt;code&gt;:supervisor&lt;/code&gt; , 아이 사양에 지정된대로</target>
        </trans-unit>
        <trans-unit id="c53830ff73ee4bc1cf4e63694e58c8a37efe371d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uid&lt;/code&gt; - indicates the owner of the file. Will be zero for non-Unix file systems.</source>
          <target state="translated">&lt;code&gt;uid&lt;/code&gt; - 파일의 소유자를 나타냅니다. 비 유닉스 파일 시스템의 경우 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="11d146eb39b484665d14fa72a8f2163b4c09bdef" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ungreedy&lt;/code&gt; (U) - inverts the &quot;greediness&quot; of the regexp (the previous &lt;code&gt;r&lt;/code&gt; option is deprecated in favor of &lt;code&gt;U&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;ungreedy&lt;/code&gt; (U)-정규 표현식의 &quot;greediness&quot;를 반전시킵니다 (이전 &lt;code&gt;r&lt;/code&gt; 옵션은 &lt;code&gt;U&lt;/code&gt; 를 위해 더 이상 사용되지 않습니다 )</target>
        </trans-unit>
        <trans-unit id="2b1493a8644a9f711c2b660f18b2fd58dc57c6be" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unicode&lt;/code&gt; (u) - enables Unicode specific patterns like &lt;code&gt;\p&lt;/code&gt; and change modifiers like &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\W&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt; and friends to also match on Unicode. It expects valid Unicode strings to be given on match</source>
          <target state="translated">&lt;code&gt;unicode&lt;/code&gt; (u)- &lt;code&gt;\p&lt;/code&gt; 와 같은 유니 코드 특정 패턴을 활성화 하고 &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\W&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; 및 friends와 같은 수정자를 유니 코드에서도 일치시킬 수 있습니다. 유효한 유니 코드 문자열이 일치 할 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="3e21f4d0f150e8661e7894e55a7889cd5ea7c932" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unquote&lt;/code&gt; can even be used to inject function names:</source>
          <target state="translated">&lt;code&gt;unquote&lt;/code&gt; 를 사용하여 함수 이름을 삽입 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b17f1b91056678deff5c7f31333a1d38b43965f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unsigned&lt;/code&gt; (default)</source>
          <target state="translated">&lt;code&gt;unsigned&lt;/code&gt; (기본값)</target>
        </trans-unit>
        <trans-unit id="bbc231aa855ba6f7ffb1640e13a6665c3a71931f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;update_value&lt;/code&gt; is the new value to be stored under &lt;code&gt;key&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;update_value&lt;/code&gt; 는 &lt;code&gt;key&lt;/code&gt; 아래에 저장 될 새 값입니다.</target>
        </trans-unit>
        <trans-unit id="be70aa90b34d9b75607b8ad2c0d7e7068392c466" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Agent&lt;/code&gt; also accepts a list of options which configures the child specification and therefore how it runs under a supervisor. The generated &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; can be customized with the following options:</source>
          <target state="translated">&lt;code&gt;use Agent&lt;/code&gt; 는 하위 사양을 구성하는 옵션 목록과 감독자에서 실행되는 방식도 허용합니다. 생성 된 &lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt; 은 다음 옵션으로 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d929111db564f10be37ff4f2d784720755bf5dc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Application&lt;/code&gt; defines a default implementation of this function which does nothing and just returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;use Application&lt;/code&gt; 은이 기능의 기본 구현을 정의하고 아무것도 수행하지 않고 &lt;code&gt;:ok&lt;/code&gt; 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3f521f271795fce8731ff9d935e42ca1131f1873" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Application&lt;/code&gt; provides no default implementation for the &lt;a href=&quot;#start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">&lt;code&gt;use Application&lt;/code&gt; 은 &lt;a href=&quot;#start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; &lt;/a&gt; 콜백에 대한 기본 구현을 제공하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8a3cd0a6ee94294da88b60ba9da6b647450af00b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use ExUnit.Case&lt;/code&gt; is responsible for setting up our module for testing and imports many test-related functionality, such as the &lt;code&gt;test/2&lt;/code&gt; macro.</source>
          <target state="translated">&lt;code&gt;use ExUnit.Case&lt;/code&gt; 는 테스트를 위해 모듈을 설정하고 &lt;code&gt;test/2&lt;/code&gt; 매크로 와 같은 많은 테스트 관련 기능을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="0384590b7214948d657738c3d5bfaf0a2cce9c64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use GenServer&lt;/code&gt; also accepts a list of options which configures the child specification and therefore how it runs under a supervisor. The generated &lt;code&gt;child_spec/1&lt;/code&gt; can be customized with the following options:</source>
          <target state="translated">&lt;code&gt;use GenServer&lt;/code&gt; 는 하위 사양을 구성하는 옵션 목록과 감독자에서 실행되는 방식도 허용합니다. 생성 된 &lt;code&gt;child_spec/1&lt;/code&gt; 은 다음 옵션으로 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19aacd0bb192aebbc1eaab7675d05f8b371c3c5e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Supervisor&lt;/code&gt; also defines a &lt;code&gt;child_spec/1&lt;/code&gt; function which allows us to run &lt;code&gt;MyApp.Supervisor&lt;/code&gt; as a child of another supervisor or at the top of your supervision tree as:</source>
          <target state="translated">&lt;code&gt;use Supervisor&lt;/code&gt; 는 또한 다음 &lt;code&gt;MyApp.Supervisor&lt;/code&gt; 같이 MyApp.Supervisor 를 다른 감독자의 자식으로 또는 감독 트리의 최상위에서 실행할 수 있는 &lt;code&gt;child_spec/1&lt;/code&gt; 함수를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="32f3cdd98eaec66584c149fc480cbffd83f3560c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use Task&lt;/code&gt; defines a &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; function, allowing the defined module to be put under a supervision tree. The generated &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; can be customized with the following options:</source>
          <target state="translated">&lt;code&gt;use Task&lt;/code&gt; 는 &lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt; 함수를 정의하여 정의 된 모듈을 감독 트리 아래에 둘 수 있습니다. 생성 된 &lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt; 은 다음 옵션으로 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9001f343f267d4f2ca6c3f31d0f08dd106421221" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vars&lt;/code&gt; - a list keeping all defined variables as &lt;code&gt;{var, context}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;vars&lt;/code&gt; - 모든 정의 된 변수를 &lt;code&gt;{var, context}&lt;/code&gt; 로 유지하는 목록</target>
        </trans-unit>
        <trans-unit id="39f4537522a5331ce77a3c7353321177c38c05b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;when&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;in&lt;/code&gt; - used as operators</source>
          <target state="translated">&lt;code&gt;when&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt; , &lt;code&gt;in&lt;/code&gt; - 연산자로 사용</target>
        </trans-unit>
        <trans-unit id="a2513b6e343efdb3f9d26eeabec520aa38f1a707" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x &amp;lt;&amp;gt; &quot;bar&quot; = &quot;foobar&quot;&lt;/code&gt; would have resulted in a &lt;a href=&quot;compileerror&quot;&gt;&lt;code&gt;CompileError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">&lt;code&gt;x &amp;lt;&amp;gt; &quot;bar&quot; = &quot;foobar&quot;&lt;/code&gt; 로 인해 &lt;a href=&quot;compileerror&quot;&gt; &lt;code&gt;CompileError&lt;/code&gt; &lt;/a&gt; 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="2f10cb46a7888b0c5592ef3405b96b453cace5d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:EXIT, port, reason}&lt;/code&gt; - exit signals in case the port crashes. If reason is not &lt;code&gt;:normal&lt;/code&gt;, this message will only be received if the owner process is trapping exits</source>
          <target state="translated">&lt;code&gt;{:EXIT, port, reason}&lt;/code&gt; -포트가 충돌하는 경우 종료 신호. reason이 (가) 아닌 경우 &lt;code&gt;:normal&lt;/code&gt; 소유자 프로세스가 종료를 트래핑하는 경우에만이 메시지가 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="9a4a7ed7743b808212846bc29e7788b55113c253" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:cont, acc}&lt;/code&gt; to continue the reduction with &lt;code&gt;acc&lt;/code&gt; as the new accumulator or</source>
          <target state="translated">&lt;code&gt;{:cont, acc}&lt;/code&gt; 를 사용하여 &lt;code&gt;acc&lt;/code&gt; 를 새 축 압기로 계속 줄이거 나</target>
        </trans-unit>
        <trans-unit id="d680d1ab4f34debbf293fabb4c907ec127e5d9c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:error, reason}&lt;/code&gt; - other (rare) error condition; for instance, &lt;code&gt;{:error, :estale}&lt;/code&gt; if reading from an NFS volume</source>
          <target state="translated">&lt;code&gt;{:error, reason}&lt;/code&gt; -기타 (드문) 오류 조건; 예를 들어, NFS 볼륨에서 읽을 경우 &lt;code&gt;{:error, :estale}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="583a02e135d23d6e385e3fd6dec1ef2ebace7264" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:error, reason}&lt;/code&gt; - the file could not be opened.</source>
          <target state="translated">&lt;code&gt;{:error, reason}&lt;/code&gt; -파일을 열 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b6d8de35ac50e9117049f505f7b0ce980f3a49c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:error, rest}&lt;/code&gt; - there are no switches at the head of the given &lt;code&gt;argv&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{:error, rest}&lt;/code&gt; -주어진 &lt;code&gt;argv&lt;/code&gt; 의 헤드에 스위치가 없습니다</target>
        </trans-unit>
        <trans-unit id="905947e36e510a423fa76acaab54776f74a95e6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:exit, reason}&lt;/code&gt; if the task has died</source>
          <target state="translated">&lt;code&gt;{:exit, reason}&lt;/code&gt; 작업이 종료 된 경우 {: 종료, 이유}</target>
        </trans-unit>
        <trans-unit id="c382ab89c3746807c841484e4b211c5a497ce846" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:failover, node}&lt;/code&gt; - used if the application is distributed and is started on the current node because of a failover on node &lt;code&gt;node&lt;/code&gt;, and the application specification key &lt;code&gt;:start_phases&lt;/code&gt; is not &lt;code&gt;:undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:failover, node}&lt;/code&gt; - 응용 프로그램이 배포되고 있기 때문에 노드에 장애 조치의 현재 노드에서 시작되는 경우에 사용 &lt;code&gt;node&lt;/code&gt; , 응용 프로그램 사양 키 &lt;code&gt;:start_phases&lt;/code&gt; 은 아니다 &lt;code&gt;:undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6493ada3691c289f4563082f5504570c40c851bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:fd, fd_in, fd_out}&lt;/code&gt; - accesses file descriptors, &lt;code&gt;fd_in&lt;/code&gt; and &lt;code&gt;fd_out&lt;/code&gt; opened by the VM.</source>
          <target state="translated">&lt;code&gt;{:fd, fd_in, fd_out}&lt;/code&gt; &lt;code&gt;fd_out&lt;/code&gt; 열린 파일 디스크립터 &lt;code&gt;fd_in&lt;/code&gt; 및 fd_out에 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="14377d50e215463748eff219d9c02d214d948fa0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:global, term}&lt;/code&gt; - the GenServer is registered globally with the given term using the functions in the &lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt;&lt;code&gt;:global&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{:global, term}&lt;/code&gt; -GenServer는 &lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt; &lt;code&gt;:global&lt;/code&gt; 모듈&lt;/a&gt; 의 함수를 사용하여 주어진 용어로 전체적으로 등록 됩니다.</target>
        </trans-unit>
        <trans-unit id="53c120865859b22092af466d2b931e7ac0b771c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:global, term}&lt;/code&gt; if the server is globally registered</source>
          <target state="translated">&lt;code&gt;{:global, term}&lt;/code&gt; 서버가 전체적으로 등록 된 경우 {: global, term}</target>
        </trans-unit>
        <trans-unit id="ef45711b970d4f5ebbd374f8b94ce469f1caf938" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:halt, acc}&lt;/code&gt; to halt the reduction</source>
          <target state="translated">&lt;code&gt;{:halt, acc}&lt;/code&gt; 감소를 중단시키는 {: halt, acc}</target>
        </trans-unit>
        <trans-unit id="df2e65d7200b3a773f87421feb6af3b00afa9729" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:invalid, key, value, rest}&lt;/code&gt; - the option &lt;code&gt;key&lt;/code&gt; is invalid with &lt;code&gt;value&lt;/code&gt; (returned when the value cannot be parsed according to the switch type)</source>
          <target state="translated">&lt;code&gt;{:invalid, key, value, rest}&lt;/code&gt; -옵션 &lt;code&gt;key&lt;/code&gt; 가 &lt;code&gt;value&lt;/code&gt; 유효하지 않습니다 (스위치 유형에 따라 값을 구문 분석 할 수없는 경우 반환 됨)</target>
        </trans-unit>
        <trans-unit id="70b5edb9ec5c74f3f67332fddbfa4c82e88ce245" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, chardata, metadata}&lt;/code&gt; - if the message translation with its metadata</source>
          <target state="translated">&lt;code&gt;{:ok, chardata, metadata}&lt;/code&gt; -메시지가 메타 데이터로 번역 된 경우</target>
        </trans-unit>
        <trans-unit id="996ab638f8c8d4d802e499bedf1f4770ab7fbb80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, chardata}&lt;/code&gt; - the translated message</source>
          <target state="translated">&lt;code&gt;{:ok, chardata}&lt;/code&gt; -번역 된 메시지</target>
        </trans-unit>
        <trans-unit id="e3a6f52fcc50382042712f66d3261d0c08067f8c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, io_device}&lt;/code&gt; - the file has been opened in the requested mode.</source>
          <target state="translated">&lt;code&gt;{:ok, io_device}&lt;/code&gt; -파일이 요청 된 모드에서 열립니다.</target>
        </trans-unit>
        <trans-unit id="a0b6d7c9a83237db145690056b0e8a37a74e66c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, key, value, rest}&lt;/code&gt; - the option &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt; was successfully parsed</source>
          <target state="translated">&lt;code&gt;{:ok, key, value, rest}&lt;/code&gt; - &lt;code&gt;value&lt;/code&gt; 이 있는 옵션 &lt;code&gt;key&lt;/code&gt; 가 구문 분석되었습니다.</target>
        </trans-unit>
        <trans-unit id="7268c1f7f90baff55c1875a554395341ede463ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:ok, term}&lt;/code&gt; if the task has successfully reported its result back in the given time interval</source>
          <target state="translated">&lt;code&gt;{:ok, term}&lt;/code&gt; 작업이 주어진 시간 간격으로 결과를 성공적으로보고 한 경우 {: ok, term}</target>
        </trans-unit>
        <trans-unit id="15f17eecf5beefa66ca856a267346c5b572581dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:spawn, command}&lt;/code&gt; - runs an external program. &lt;code&gt;command&lt;/code&gt; must contain the program name and optionally a list of arguments separated by space. If passing programs or arguments with space in their name, use the next option.</source>
          <target state="translated">&lt;code&gt;{:spawn, command}&lt;/code&gt; -외부 프로그램을 실행합니다. &lt;code&gt;command&lt;/code&gt; 는 프로그램 이름과 선택적으로 공백으로 구분 된 인수 목록을 포함해야합니다. 이름에 공백이있는 프로그램이나 인수를 전달하는 경우 다음 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d6ebca30f0cc1777601d5fcf5ac5189ec02cece8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:spawn_driver, command}&lt;/code&gt; - spawns so-called port drivers.</source>
          <target state="translated">&lt;code&gt;{:spawn_driver, command}&lt;/code&gt; -소위 포트 드라이버를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="66e3057e6196a07aafd175143d071fd417be195c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:spawn_executable, filename}&lt;/code&gt; - runs the executable given by the absolute file name &lt;code&gt;filename&lt;/code&gt;. Arguments can be passed via the &lt;code&gt;:args&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;{:spawn_executable, filename}&lt;/code&gt; -절대 파일 이름 &lt;code&gt;filename&lt;/code&gt; 으로 지정된 실행 파일을 실행합니다 . 인수는 &lt;code&gt;:args&lt;/code&gt; 옵션을 통해 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1573672f3d270a166ee722ed200846e37ef9cf60" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:takeover, node}&lt;/code&gt; - used if the application is distributed and is started on the current node because of a failover on the node &lt;code&gt;node&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:takeover, node}&lt;/code&gt; -응용 프로그램이 배포되고 노드 &lt;code&gt;node&lt;/code&gt; 의 장애 조치로 인해 현재 노드에서 시작된 경우 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c26b97b81c2506b473edb7172c2f617dcec5b26d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:undefined, key, value, rest}&lt;/code&gt; - the option &lt;code&gt;key&lt;/code&gt; is undefined (returned in strict mode when the switch is unknown or on nonexistent atoms)</source>
          <target state="translated">&lt;code&gt;{:undefined, key, value, rest}&lt;/code&gt; -옵션 &lt;code&gt;key&lt;/code&gt; 가 정의되지 않음 (스위치를 알 수 없거나 원자가없는 경우 엄격 모드로 반환)</target>
        </trans-unit>
        <trans-unit id="85bdb5005d451e7a63cf262238f500974e283030" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:via, module, name}&lt;/code&gt; if the server is registered through an alternative registry</source>
          <target state="translated">&lt;code&gt;{:via, module, name}&lt;/code&gt; 서버가 대체 레지스트리를 통해 등록 된 경우 {: via, module, name}</target>
        </trans-unit>
        <trans-unit id="8b29339dcb62621d0d8075c996c9fab09ff31622" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{:via, module, term}&lt;/code&gt; - the GenServer is registered with the given mechanism and name. The &lt;code&gt;:via&lt;/code&gt; option expects a module that exports &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt; and &lt;a href=&quot;kernel#send/2&quot;&gt;&lt;code&gt;send/2&lt;/code&gt;&lt;/a&gt;. One such example is the &lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt;&lt;code&gt;:global&lt;/code&gt; module&lt;/a&gt; which uses these functions for keeping the list of names of processes and their associated PIDs that are available globally for a network of Elixir nodes. Elixir also ships with a local, decentralized and scalable registry called &lt;a href=&quot;registry&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; for locally storing names that are generated dynamically.</source>
          <target state="translated">&lt;code&gt;{:via, module, term}&lt;/code&gt; -GenServer는 지정된 메커니즘과 이름으로 등록됩니다. &lt;code&gt;:via&lt;/code&gt; 옵션을 수출하는 모듈 예상 &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , &lt;code&gt;whereis_name/1&lt;/code&gt; 및 &lt;a href=&quot;kernel#send/2&quot;&gt; &lt;code&gt;send/2&lt;/code&gt; &lt;/a&gt; . 이러한 예 중 하나는 &lt;a href=&quot;http://www.erlang.org/doc/man/global.html&quot;&gt; &lt;code&gt;:global&lt;/code&gt; 모듈&lt;/a&gt; 인데,이 기능을 사용하여 Elixir 노드 네트워크에 대해 전체적으로 사용 가능한 프로세스 이름 및 관련 PID 목록을 유지합니다. Elixir는 동적으로 생성 된 이름을 로컬에 저장하기 위해 &lt;a href=&quot;registry&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt; 라는 로컬, 분산 및 확장 가능한 레지스트리와 함께 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc2c818f59492934d15abff13439c0782289f3e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;{&lt;/code&gt; 와 &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c6157992132973e0f3d822fb7bbb7d409431fec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{Logger, message, timestamp, metadata}&lt;/code&gt; is a tuple containing information about the logged message:</source>
          <target state="translated">&lt;code&gt;{Logger, message, timestamp, metadata}&lt;/code&gt; 는 기록 된 메시지에 대한 정보가 포함 된 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="db1f5193dbaaf9fec82f82738b42e72b2810c7d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{atom, node}&lt;/code&gt; if the server is locally registered at another node</source>
          <target state="translated">&lt;code&gt;{atom, node}&lt;/code&gt; 서버가 다른 노드에 로컬로 등록 된 경우 {atom, node}</target>
        </trans-unit>
        <trans-unit id="2d5e8a342d00497e80fb0e1378891350b6989d2e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{item1,item2,...}&lt;/code&gt; - matches one of the alternatives. Do not add spaces before and after the comma as it would then match paths containing the space character itself.</source>
          <target state="translated">&lt;code&gt;{item1,item2,...}&lt;/code&gt; -대안 중 하나와 일치합니다. 공백 문자 자체를 포함하는 경로와 일치하므로 쉼표 앞뒤에 공백을 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ac157d52ecf1d75482d9d1aeecc889281122e50e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{pid, :close}&lt;/code&gt; - closes the port. Unless the port is already closed, the port will reply with &lt;code&gt;{port, :closed}&lt;/code&gt; message once it has flushed its buffers and effectively closed. See &lt;a href=&quot;#close/1&quot;&gt;&lt;code&gt;close/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{pid, :close}&lt;/code&gt; -포트를 닫습니다. 포트가 이미 닫히지 않으면 포트는 버퍼를 비우고 효과적으로 닫으면 &lt;code&gt;{port, :closed}&lt;/code&gt; 메시지로 응답 합니다. &lt;a href=&quot;#close/1&quot;&gt; &lt;code&gt;close/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a895632430cc7c653dfc0e0b7e07abf543b5e9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{pid, {:command, binary}}&lt;/code&gt; - sends the given data to the port. See &lt;a href=&quot;#command/3&quot;&gt;&lt;code&gt;command/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{pid, {:command, binary}}&lt;/code&gt; -주어진 데이터를 포트로 보냅니다. 참조 &lt;a href=&quot;#command/3&quot;&gt; &lt;code&gt;command/3&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="288f6592e3c497e594f8671f3ea30d712d05da67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{pid, {:connect, new_pid}}&lt;/code&gt; - sets the &lt;code&gt;new_pid&lt;/code&gt; as the new owner of the port. Once a port is opened, the port is linked and connected to the caller process and communication to the port only happens through the connected process. This message makes &lt;code&gt;new_pid&lt;/code&gt; the new connected processes. Unless the port is dead, the port will reply to the old owner with &lt;code&gt;{port, :connected}&lt;/code&gt;. See &lt;a href=&quot;#connect/2&quot;&gt;&lt;code&gt;connect/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{pid, {:connect, new_pid}}&lt;/code&gt; - &lt;code&gt;new_pid&lt;/code&gt; 를 포트의 새로운 소유자로 설정합니다 . 포트가 열리면 포트는 호출자 프로세스에 연결되고 연결되며 포트와의 통신은 연결된 프로세스를 통해서만 이루어집니다. 이 메시지는 &lt;code&gt;new_pid&lt;/code&gt; 를 새로운 연결된 프로세스로 만듭니다. 포트가 작동하지 않으면 포트는 &lt;code&gt;{port, :connected}&lt;/code&gt; 이전 소유자에게 응답합니다 . &lt;a href=&quot;#connect/2&quot;&gt; &lt;code&gt;connect/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e874c9f986bcbc4835de87b79c60801c982748f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{port, :closed}&lt;/code&gt; - reply to the &lt;code&gt;{pid, :close}&lt;/code&gt; message</source>
          <target state="translated">&lt;code&gt;{port, :closed}&lt;/code&gt; - &lt;code&gt;{pid, :close}&lt;/code&gt; 메시지에 회신</target>
        </trans-unit>
        <trans-unit id="fa93e43d244395859c46aade03423cd222f87032" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{port, :connected}&lt;/code&gt; - reply to the &lt;code&gt;{pid, {:connect, new_pid}}&lt;/code&gt; message</source>
          <target state="translated">&lt;code&gt;{port, :connected}&lt;/code&gt; - &lt;code&gt;{pid, {:connect, new_pid}}&lt;/code&gt; 메시지에 회신</target>
        </trans-unit>
        <trans-unit id="efc9c7697827d4669aad3228ed4c07741bb10c50" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;{port, {:data, data}}&lt;/code&gt; - data sent by the port</source>
          <target state="translated">&lt;code&gt;{port, {:data, data}}&lt;/code&gt; -포트에서 전송 한 데이터</target>
        </trans-unit>
        <trans-unit id="8331cbf97282804d067bb29ba8bd9b7caf6144bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;~&lt;/code&gt;&lt;code&gt;~&amp;gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;~&lt;/code&gt;&lt;code&gt;~&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;~&lt;/code&gt;&lt;code&gt;~&amp;gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;~&lt;/code&gt;&lt;code&gt;~&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;~&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;|&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a1fc7b83a3791c9f16933b021a993fc251a976d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;|&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;|&lt;/code&gt; 와 &lt;code&gt;|&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f53c515caea553b7a18b81d363c568a315a5150f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;||&lt;/code&gt;&lt;code&gt;|||&lt;/code&gt;&lt;code&gt;or&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt;&lt;code&gt;|||&lt;/code&gt;&lt;code&gt;or&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="036d3dd0689aaa1e1f2cd3395422e4acf8dcaf56" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&amp;gt;&lt;/code&gt; will never include pre-release versions of its upper bound, regardless of the usage of the &lt;code&gt;:allow_pre&lt;/code&gt; option, or whether the operand is a pre-release version. It can also be used to set an upper bound on only the major version part. See the table below for &lt;code&gt;~&amp;gt;&lt;/code&gt; requirements and their corresponding translations.</source>
          <target state="translated">&lt;code&gt;~&amp;gt;&lt;/code&gt; 는 &lt;code&gt;:allow_pre&lt;/code&gt; 옵션 의 사용 또는 피연산자가 시험판 버전인지 여부에 상관없이 시험판 버전의 상한을 포함하지 않습니다 . 주 버전 부분에만 상한을 설정하는 데에도 사용할 수 있습니다. &lt;code&gt;~&amp;gt;&lt;/code&gt; 요구 사항 및 해당 번역에 대해서는 아래 표를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d3a808d1b26854bfff9e3a0b3845ea1a05448e77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt;, &lt;code&gt;_&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; , &lt;code&gt;_&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09579eaf4feb9e28fce9fc17746e4ff55890bca0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;None&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;None&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5d79e4e6ea4fe26e44ae09fe2933d731631027ff" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note&lt;/em&gt;: unlike &lt;code&gt;@after_compile&lt;/code&gt;, the callback function/macro must be placed in a separate module (because when the callback is invoked, the current module does not yet exist).</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;code&gt;@after_compile&lt;/code&gt; 과 달리 콜백 함수 / 매크로는 별도의 모듈에 배치해야합니다 (콜백이 호출 될 때 현재 모듈이 아직 없기 때문에).</target>
        </trans-unit>
        <trans-unit id="4f08c9a12c9ca68459deea27c07cfa5cbf312698" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The leading underscore in &lt;code&gt;_sep&lt;/code&gt; means that the variable will be ignored in this function; see &lt;a href=&quot;https://hexdocs.pm/elixir/master/naming-conventions.html#underscore-_foo&quot;&gt;Naming Conventions&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;_sep&lt;/code&gt; 에서 밑줄 은 변수가이 함수에서 무시 됨을 의미합니다. &lt;a href=&quot;https://hexdocs.pm/elixir/master/naming-conventions.html#underscore-_foo&quot;&gt;명명 규칙을&lt;/a&gt; 참조하십시오 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d76d0c90116afc56a7d7c36ee9aa1c61ab7189e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;The trailing question mark in &lt;code&gt;zero?&lt;/code&gt; means that this function returns a boolean; see &lt;a href=&quot;https://hexdocs.pm/elixir/master/naming-conventions.html#trailing-question-mark-foo&quot;&gt;Naming Conventions&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;후행 물음표는 &lt;code&gt;zero?&lt;/code&gt; 이 함수는 부울을 리턴 함을 의미합니다. &lt;a href=&quot;https://hexdocs.pm/elixir/master/naming-conventions.html#trailing-question-mark-foo&quot;&gt;명명 규칙을&lt;/a&gt; 참조하십시오 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="64b3259a23cbcee4b6f5269de5bf892f183bee1a" translate="yes" xml:space="preserve">
          <source>&lt;small&gt;Elixir v1.9.1&lt;/small&gt; API Reference</source>
          <target state="translated">&lt;small&gt;Elixir v1.9.1&lt;/small&gt; API 참조</target>
        </trans-unit>
        <trans-unit id="f3775fefac93bd98a436d0d00b0aab5a204bb7bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;ExUnit&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; is a test-unit based framework that ships with Elixir;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;ExUnit&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; 은 Elixir와 함께 제공되는 테스트 단위 기반 프레임 워크입니다.</target>
        </trans-unit>
        <trans-unit id="79fc31f88ea6f7006047293577c94843734d6c4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://hexdocs.pm/mix/&quot;&gt;Mix&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; is a build tool that ships with Elixir that provides tasks for creating, compiling, testing your application, managing its dependencies and much more;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://hexdocs.pm/mix/&quot;&gt;Mix&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; 는 Elixir와 함께 제공되는 빌드 도구로, 응용 프로그램 작성, 컴파일, 테스트, 종속성 관리 등의 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7760e740159ba1e4a18006d398566be346370d1b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;OTP&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;(Open Telecom Platform)&lt;/em&gt; is a set of libraries that ships with Erlang. Erlang developers use OTP to build robust, fault-tolerant applications. In this chapter we will explore how many aspects from OTP integrate with Elixir, including supervision trees, event managers and more;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;OTP&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; (Open Telecom Platform)&lt;/em&gt; 는 Erlang과 함께 제공되는 라이브러리 세트입니다. Erlang 개발자는 OTP를 사용하여 강력하고 내결함성이있는 애플리케이션을 구축합니다. 이 장에서는 감독 트리, 이벤트 관리자 등 OTP의 몇 가지 측면이 Elixir와 통합되는지 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="45bdb2bd826dc57156f3bf24a36a9c22bb6b679a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important:&lt;/strong&gt; if you are writing a library to be used by other developers, it is generally recommended to avoid the application environment, as the application environment is effectively a global storage. For more information, read our &lt;a href=&quot;library-guidelines&quot;&gt;library guidelines&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;중요 사항 :&lt;/strong&gt; 다른 개발자가 사용할 라이브러리를 작성하는 경우 애플리케이션 환경은 사실상 글로벌 스토리지이므로 애플리케이션 환경을 피하는 것이 좋습니다. 자세한 내용은 &lt;a href=&quot;library-guidelines&quot;&gt;라이브러리 지침을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cebf98b4bce979e6d8b77444f797642d0aeb4c22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: in Elixir, you don&amp;rsquo;t have to define the &lt;code&gt;Foo&lt;/code&gt; module before being able to define the &lt;code&gt;Foo.Bar&lt;/code&gt; module, as the language translates all module names to atoms. You can define arbitrarily-nested modules without defining any module in the chain (e.g., &lt;code&gt;Foo.Bar.Baz&lt;/code&gt; without defining &lt;code&gt;Foo&lt;/code&gt; or &lt;code&gt;Foo.Bar&lt;/code&gt; first).</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Elixir에서는 언어가 모든 모듈 이름을 원자로 변환 하므로 &lt;code&gt;Foo.Bar&lt;/code&gt; 모듈 을 정의하기 전에 &lt;code&gt;Foo&lt;/code&gt; 모듈 을 정의 할 필요가 없습니다 . 사용자는 (예를 들면, 체인의 모든 모듈을 정의하지 않고 임의로 중첩 모듈을 정의 할 수 &lt;code&gt;Foo.Bar.Baz&lt;/code&gt; 을 정의하지 않고 &lt;code&gt;Foo&lt;/code&gt; 또는 &lt;code&gt;Foo.Bar&lt;/code&gt; 첫번째).</target>
        </trans-unit>
        <trans-unit id="4830045d3f9fb785bdafea364ad01a0303638b81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this function must be used only for debugging purposes.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 기능은 디버깅 목적으로 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5c1f94fbf601c6ec501544925ca954903163e6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use this function with extreme care&lt;/strong&gt;. For almost all situations where you would use &lt;a href=&quot;#sleep/1&quot;&gt;&lt;code&gt;sleep/1&lt;/code&gt;&lt;/a&gt; in Elixir, there is likely a more correct, faster and precise way of achieving the same with message passing.</source>
          <target state="translated">&lt;strong&gt;이 기능은 매우주의해서 사용하십시오&lt;/strong&gt; . Elixir에서 &lt;a href=&quot;#sleep/1&quot;&gt; &lt;code&gt;sleep/1&lt;/code&gt; &lt;/a&gt; 을 사용하는 거의 모든 상황에서 메시지 전달을 통해보다 정확하고 빠르며 정확한 방법을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d8fa24c5f50dfc16b2c10bf309baf5a47726342" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Every time this function is invoked, a file descriptor is opened and a new process is spawned to write to the file. For this reason, if you are doing multiple writes in a loop, opening the file via &lt;a href=&quot;file#open/2&quot;&gt;&lt;code&gt;File.open/2&lt;/code&gt;&lt;/a&gt; and using the functions in &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; to write to the file will yield much better performance than calling this function multiple times.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 이 함수가 호출 될 때마다 파일 디스크립터가 열리고 파일에 쓸 새 프로세스가 생성됩니다. 이러한 이유로 루프에서 여러 번 쓰기를 수행하는 경우 &lt;a href=&quot;file#open/2&quot;&gt; &lt;code&gt;File.open/2&lt;/code&gt; &lt;/a&gt; 를 통해 파일을 열고 &lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 의 함수를 사용 하여 파일에 쓰면이 함수를 여러 번 호출하는 것보다 훨씬 나은 성능을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="365ce4331359866dc083be4a975f43b82fadac5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt; can be any Elixir code and code can be executed with the same privileges as the Erlang VM: this means that such code could compromise the machine (for example by executing system commands). Don't use &lt;a href=&quot;#compile_string/2&quot;&gt;&lt;code&gt;compile_string/2&lt;/code&gt;&lt;/a&gt; with untrusted input (such as strings coming from the network).</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;code&gt;string&lt;/code&gt; 은 모든 Elixir 코드 일 수 있으며 Erlang VM과 동일한 권한으로 코드를 실행할 수 있습니다. 즉, 이러한 코드는 시스템 명령을 실행하여 시스템을 손상시킬 수 있습니다. 신뢰할 수없는 입력 (예 : 네트워크에서 오는 문자열)과 함께 &lt;a href=&quot;#compile_string/2&quot;&gt; &lt;code&gt;compile_string/2&lt;/code&gt; &lt;/a&gt; 를 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="9a9945569acc699104fbc382a7f6902cdbb849ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: &lt;code&gt;string&lt;/code&gt; can be any Elixir code and will be executed with the same privileges as the Erlang VM: this means that such code could compromise the machine (for example by executing system commands). Don't use &lt;a href=&quot;#eval_string/3&quot;&gt;&lt;code&gt;eval_string/3&lt;/code&gt;&lt;/a&gt; with untrusted input (such as strings coming from the network).</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;code&gt;string&lt;/code&gt; 은 모든 Elixir 코드 일 수 있으며 Erlang VM과 동일한 권한으로 실행됩니다. 즉, 이러한 코드는 시스템 명령을 실행하여 시스템을 손상시킬 수 있습니다. 신뢰할 수없는 입력 (예 : 네트워크에서 오는 문자열)과 함께 &lt;a href=&quot;#eval_string/3&quot;&gt; &lt;code&gt;eval_string/3&lt;/code&gt; &lt;/a&gt; 을 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="2875bd2bb7c9486ad98cafa18ea844a4e68bfa0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: Calling this function inside a macro is considered bad practice as it will attempt to evaluate runtime values at compile time. Macro arguments are typically transformed by unquoting them into the returned quoted expressions (instead of evaluated).</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 매크로 내에서이 함수를 호출하면 컴파일 타임에 런타임 값을 평가하려고하므로 나쁜 습관으로 간주됩니다. 매크로 인수는 일반적으로 평가 대신에 인용 된 표현식으로 인용 부호를 지정하여 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="993e7a2f2e8a8af096a402bf2629008a4fb49467" translate="yes" xml:space="preserve">
          <source>= (2)</source>
          <target state="translated">= (2)</target>
        </trans-unit>
        <trans-unit id="070f4bb5062b181b2dab5baebd4e926e8227b544" translate="yes" xml:space="preserve">
          <source>== (2)</source>
          <target state="translated">== (2)</target>
        </trans-unit>
        <trans-unit id="80782192fde18010086342ec452afa4a2968c387" translate="yes" xml:space="preserve">
          <source>=== (2)</source>
          <target state="translated">=== (2)</target>
        </trans-unit>
        <trans-unit id="7d042330e275b9df07c1b99a60576379d66570eb" translate="yes" xml:space="preserve">
          <source>=~ (2)</source>
          <target state="translated">= ~ (2)</target>
        </trans-unit>
        <trans-unit id="3ac5ef8377daeb708c25b635e6c467ff0bfcb4e4" translate="yes" xml:space="preserve">
          <source>@expr</source>
          <target state="translated">@expr</target>
        </trans-unit>
        <trans-unit id="3fb5c30970be466c24df6f91f050369f404a45eb" translate="yes" xml:space="preserve">
          <source>@expr (1)</source>
          <target state="translated">@expr (1)</target>
        </trans-unit>
        <trans-unit id="212381917bbc6314dd3515bae3faeae224b2edde" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; is most commonly started under a supervision tree. When we invoke &lt;code&gt;use GenServer&lt;/code&gt;, it automatically defines a &lt;code&gt;child_spec/1&lt;/code&gt; function that allows us to start the &lt;code&gt;Stack&lt;/code&gt; directly under a supervisor. To start a default stack of &lt;code&gt;[:hello]&lt;/code&gt; under a supervisor, one may do:</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 는&lt;/a&gt; 가장 일반적으로 감독의 나무 아래에서 시작됩니다. &lt;code&gt;use GenServer&lt;/code&gt; 을 호출 하면 Supervisor 에서 직접 &lt;code&gt;Stack&lt;/code&gt; 을 시작할 수 있는 &lt;code&gt;child_spec/1&lt;/code&gt; 함수를 자동으로 정의합니다 . 수퍼바이저에서 &lt;code&gt;[:hello]&lt;/code&gt; 의 기본 스택을 시작하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b04250c280e3b81f91e1d5dd337c0df8de26b240" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt; is represented internally using the &lt;code&gt;%MapSet{}&lt;/code&gt; struct. This struct can be used whenever there's a need to pattern match on something being a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; 에이&lt;/a&gt; 은 USING 내부 표현 &lt;code&gt;%MapSet{}&lt;/code&gt; 구조체. 이 구조체는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; 인&lt;/a&gt; 무언가에 패턴 일치가 필요할 때마다 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96991deff4ed5a082a254d0673af19964e04b750" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;StringIO&lt;/code&gt;&lt;/a&gt; IO device can be passed as a &quot;device&quot; to most of the functions in the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;StringIO&lt;/code&gt; &lt;/a&gt; IO 장치가있는 대부분의 기능을 &quot;장치&quot;로서 전달 될 수 &lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="11c30e3595630fd2ed85f755977f5e0806af282c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; is bound to the same name registration rules as a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Read more about them in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; docs.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; 는&lt;/a&gt; A와 같은 이름의 등록 규칙에 바인딩 &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 문서 에서 자세한 내용을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="04a844239e65727f5eb23023aa50bf8c3c86fe4c" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; struct is returned containing the relevant information. Developers must eventually call &lt;a href=&quot;task#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;task#yield/2&quot;&gt;&lt;code&gt;Task.yield/2&lt;/code&gt;&lt;/a&gt; followed by &lt;a href=&quot;task#shutdown/2&quot;&gt;&lt;code&gt;Task.shutdown/2&lt;/code&gt;&lt;/a&gt; on the returned task.</source>
          <target state="translated">관련 정보가 포함 된 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 구조체가 반환됩니다. 개발자는 결국 호출해야합니다 &lt;a href=&quot;task#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;task#yield/2&quot;&gt; &lt;code&gt;Task.yield/2&lt;/code&gt; &lt;/a&gt; 다음 &lt;a href=&quot;task#shutdown/2&quot;&gt; &lt;code&gt;Task.shutdown/2&lt;/code&gt; &lt;/a&gt; 반환 작업에 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b893cfed0032b8cee12fcb9d4b611446984d618" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;:name&lt;/code&gt; option could also be given to &lt;code&gt;Agent.start_link/2&lt;/code&gt; and it would be automatically registered. Besides agents, Elixir provides an API for building generic servers (called &lt;code&gt;GenServer&lt;/code&gt;), tasks, and more, all powered by processes underneath. Those, along with supervision trees, will be explored with more detail in the &lt;strong&gt;&lt;em&gt;Mix and OTP guide&lt;/em&gt;&lt;/strong&gt; which will build a complete Elixir application from start to finish.</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; 옵션은 부여 할 수 &lt;code&gt;Agent.start_link/2&lt;/code&gt; 및 자동 등록됩니다. 에이전트 외에도 Elixir는 일반 서버 ( &lt;code&gt;GenServer&lt;/code&gt; 라고 함 ), 작업 등 을 구축 할 수있는 API를 제공합니다 . 그것들은 감독 트리와 함께 &lt;strong&gt;&lt;em&gt;Mix and OTP 안내서&lt;/em&gt;&lt;/strong&gt; 에서 더 자세히 살펴볼 것입니다.이 &lt;strong&gt;&lt;em&gt;안내서&lt;/em&gt;&lt;/strong&gt; 는 처음부터 끝까지 완전한 Elixir 응용 프로그램을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="e18a4ffc55e5c9028c4e176af5316103f1339b8d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;post_config&lt;/code&gt; can be passed that will be merged into the project configuration.</source>
          <target state="translated">&lt;code&gt;post_config&lt;/code&gt; 은 프로젝트 구성에 병합 될 것이다 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="953f85d383aa733b4232421e096ff53630a36ae0" translate="yes" xml:space="preserve">
          <source>A Date struct and functions.</source>
          <target state="translated">Date 구조체와 함수</target>
        </trans-unit>
        <trans-unit id="41bff3f5550cc14457144dffbdae442d3deffbd2" translate="yes" xml:space="preserve">
          <source>A GUI should pop-up containing all sorts of information about our system, from general statistics to load charts as well as a list of all running processes and applications.</source>
          <target state="translated">일반 통계에서로드 차트, 실행중인 모든 프로세스 및 응용 프로그램 목록에 이르기까지 시스템에 대한 모든 종류의 정보가 포함 된 GUI가 팝업되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ce30e5498af53503d24e931e06501bf314a92d8d" translate="yes" xml:space="preserve">
          <source>A GenServer is a process like any other Elixir process and it can be used to keep state, execute code asynchronously and so on. The advantage of using a generic server process (GenServer) implemented using this module is that it will have a standard set of interface functions and include functionality for tracing and error reporting. It will also fit into a supervision tree.</source>
          <target state="translated">GenServer는 다른 Elixir 프로세스와 같은 프로세스이며 상태를 유지하고 코드를 비동기식으로 실행하는 데 사용할 수 있습니다. 이 모듈을 사용하여 구현 된 일반 서버 프로세스 (GenServer)의 장점은 표준 인터페이스 기능 세트를 가지며 추적 및 오류보고 기능을 포함한다는 것입니다. 또한 감시 트리에도 적합합니다.</target>
        </trans-unit>
        <trans-unit id="e1d021610e2e2d5fff8dcc8068b986d35f87da19" translate="yes" xml:space="preserve">
          <source>A GenServer is a process that invokes a limited set of functions under specific conditions. When we used an &lt;code&gt;Agent&lt;/code&gt;, we would keep both the client code and the server code side by side, like this:</source>
          <target state="translated">GenServer는 특정 조건 하에서 제한된 기능 세트를 호출하는 프로세스입니다. &lt;code&gt;Agent&lt;/code&gt; 를 사용할 때 다음 과 같이 클라이언트 코드와 서버 코드를 나란히 유지합니다.</target>
        </trans-unit>
        <trans-unit id="fa09e34f4344d6d1e3072b5dbac5303f17145bcc" translate="yes" xml:space="preserve">
          <source>A GenServer is implemented in two parts: the client API and the server callbacks. You can either combine both parts into a single module or you can separate them into a client module and a server module. The client is any process that invokes the client function. The server is always the process identifier or process name that we will explicitly pass as argument to the client API. Here we&amp;rsquo;ll use a single module for both the server callbacks and the client API.</source>
          <target state="translated">GenServer는 클라이언트 API와 서버 콜백의 두 부분으로 구현됩니다. 두 부분을 단일 모듈로 결합하거나 클라이언트 모듈과 서버 모듈로 분리 할 수 ​​있습니다. 클라이언트는 클라이언트 기능을 호출하는 모든 프로세스입니다. 서버는 항상 프로세스 식별자 또는 프로세스 이름으로 클라이언트 API에 인수로 명시 적으로 전달합니다. 여기서는 서버 콜백과 클라이언트 API 모두에 단일 모듈을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2c3564c401d9bcae5f982375952ba5b0f96579bf" translate="yes" xml:space="preserve">
          <source>A GenServer, or a process in general, must be used to model runtime characteristics of your system. A GenServer must never be used for code organization purposes.</source>
          <target state="translated">시스템의 런타임 특성을 모델링하려면 GenServer 또는 일반적인 프로세스를 사용해야합니다. 코드 구성 목적으로 GenServer를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="4c204de36640465711bc67da137f234cf9e4f98d" translate="yes" xml:space="preserve">
          <source>A Mix project is defined by calling &lt;code&gt;use Mix.Project&lt;/code&gt; in a module, usually placed in &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">믹스 프로젝트는 보통 &lt;code&gt;mix.exs&lt;/code&gt; 에 배치 된 모듈에서 &lt;code&gt;use Mix.Project&lt;/code&gt; 을 호출 하여 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="4077ad8fe6f71eae596391489d6e96f0ea24015b" translate="yes" xml:space="preserve">
          <source>A Mix task can be defined by simply using &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Task&lt;/code&gt;&lt;/a&gt; in a module starting with &lt;code&gt;Mix.Tasks.&lt;/code&gt; and defining the &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">Mix 작업은 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Task&lt;/code&gt; s&lt;/a&gt; 로 시작하는 모듈에서 Mix.Task 를 사용하여 간단히 정의 할 수 있습니다 &lt;code&gt;Mix.Tasks.&lt;/code&gt; &lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; &lt;/a&gt; 함수를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ed54926907bf0ba78a3375ef0d22019252f3389e" translate="yes" xml:space="preserve">
          <source>A NaiveDateTime struct (without a time zone) and functions.</source>
          <target state="translated">NaiveDateTime 구조체 (시간대 제외) 및 기능.</target>
        </trans-unit>
        <trans-unit id="555fb6c5e065889ab4dcadeaa574e32486d7fb5d" translate="yes" xml:space="preserve">
          <source>A Regex is represented internally as the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; struct. Therefore, &lt;code&gt;%Regex{}&lt;/code&gt; can be used whenever there is a need to match on them. Keep in mind it is not guaranteed two regular expressions from the same source are equal, for example:</source>
          <target state="translated">정규식은 내부적으로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt; 구조체로 표시됩니다. 따라서 &lt;code&gt;%Regex{}&lt;/code&gt; 는 일치해야 할 때마다 사용할 수 있습니다. 예를 들어, 동일한 소스에서 나온 두 개의 정규 표현식이 동일하다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="2afaaf5f34eb9535b346406765e25f28777ebcbf" translate="yes" xml:space="preserve">
          <source>A String in Elixir is a UTF-8 encoded binary.</source>
          <target state="translated">Elixir의 문자열은 UTF-8로 인코딩 된 바이너리입니다.</target>
        </trans-unit>
        <trans-unit id="1d40f8897ae8fea751dfe1a3787ebde9eaf60e69" translate="yes" xml:space="preserve">
          <source>A TCP server, in broad strokes, performs the following steps:</source>
          <target state="translated">광범위한 스트로크로 TCP 서버는 다음 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9b4c21dfcd9b32e19a4da6bba2ed1b078799abfe" translate="yes" xml:space="preserve">
          <source>A Time struct and functions.</source>
          <target state="translated">시간 구조와 기능.</target>
        </trans-unit>
        <trans-unit id="8ed92df07fe6e75daa797531db7710c5a365538d" translate="yes" xml:space="preserve">
          <source>A UTF-8 code point. It may be one or more bytes.</source>
          <target state="translated">UTF-8 코드 포인트 하나 이상의 바이트 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4551e142fcb8c6dfcab6f6c771c1757c5d408c6" translate="yes" xml:space="preserve">
          <source>A UTF-8 encoded binary.</source>
          <target state="translated">UTF-8로 인코딩 된 바이너리입니다.</target>
        </trans-unit>
        <trans-unit id="c6baac594934e18050d15b336369478a962b486d" translate="yes" xml:space="preserve">
          <source>A basic setup for ExUnit is shown below:</source>
          <target state="translated">ExUnit의 기본 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d872a4d789410051d4047736ebac85378931dcb1" translate="yes" xml:space="preserve">
          <source>A beginning is inclusive. An ending is exclusive. Eg. if a period is from 2015-03-29 01:00:00 and until 2015-10-25 01:00:00, the period includes and begins from the beginning of 2015-03-29 01:00:00 and lasts until just before 2015-10-25 01:00:00.</source>
          <target state="translated">시작은 포괄적입니다. 엔딩은 배타적입니다. 예 : 기간이 2015-03-29 01:00:00부터 2015-10-25 01:00:00까지 인 경우 기간은 2015-03-29 01:00:00을 포함하여 시작하여 2015-03-29 01:00:00부터 시작하여 2015-10-25 01:00:00 직전에.</target>
        </trans-unit>
        <trans-unit id="4b46e9949a74e5098958730c1a927a02cf0e1c74" translate="yes" xml:space="preserve">
          <source>A beginning or end for certain periods are infinite. For instance the latest period for time zones without DST or plans to change. However for the purpose of this behaviour they are only used for gaps in wall time where the needed period limits are at a certain time.</source>
          <target state="translated">특정 기간의 시작 또는 끝은 무한합니다. 예를 들어 DST가 없거나 시간대를 변경하려는 시간대의 최신 기간입니다. 그러나이 동작의 목적을 위해 필요한 시간 제한이 특정 시간에있는 벽 시간 간격에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eb34fc850ae56e44c450bb71c054995b2321814e" translate="yes" xml:space="preserve">
          <source>A behaviour module defines a set of functions and macros (referred to as &lt;em&gt;callbacks&lt;/em&gt;) that callback modules implementing that behaviour must export. This &quot;interface&quot; identifies the specific part of the component. For example, the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; behaviour and functions abstract away all the message-passing (sending and receiving) and error reporting that a &quot;server&quot; process will likely want to implement from the specific parts such as the actions that this server process has to perform.</source>
          <target state="translated">비헤이비어 모듈은 해당 비헤이비어를 구현하는 콜백 모듈이 내 보내야하는 함수 및 매크로 ( &lt;em&gt;콜백&lt;/em&gt; 이라고 함) 세트를 정의 합니다. 이 &quot;인터페이스&quot;는 구성 요소의 특정 부분을 식별합니다. 예를 들어, &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 동작 및 기능은 &quot;서버&quot;프로세스가이 서버 프로세스가 수행해야하는 작업과 같은 특정 부분에서 구현하고자하는 모든 메시지 전달 (송수신) 및 오류보고를 추상화합니다.</target>
        </trans-unit>
        <trans-unit id="7c9e867bc2a6fb80d40eab6dcf2caa49046c25ae" translate="yes" xml:space="preserve">
          <source>A behaviour module for implementing supervisors.</source>
          <target state="translated">감독자를 구현하기위한 행동 모듈.</target>
        </trans-unit>
        <trans-unit id="605d4ad9d9fdab9c7d0d8facad9343748a300de2" translate="yes" xml:space="preserve">
          <source>A behaviour module for implementing the server of a client-server relation.</source>
          <target state="translated">클라이언트-서버 관계의 서버를 구현하기위한 행동 모듈.</target>
        </trans-unit>
        <trans-unit id="00f8ebc260124e1ab7b63ede984d78166228dd40" translate="yes" xml:space="preserve">
          <source>A better function definition would be:</source>
          <target state="translated">더 나은 기능 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="415e0f889e1439e4772c9c6a317c5d9eae0185a6" translate="yes" xml:space="preserve">
          <source>A binary always contains a complete number of bytes.</source>
          <target state="translated">바이너리는 항상 완전한 바이트 수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="d08e886402089500f760cd62e9be33847d11368c" translate="yes" xml:space="preserve">
          <source>A binary is a sequence of bytes. Those bytes can be organized in any way, even in a sequence that does not make them a valid string:</source>
          <target state="translated">이진은 일련의 바이트입니다. 이러한 바이트는 유효한 문자열이 아닌 순서로도 어떤 방식 으로든 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f4b7277d1938d9dc02215252a72af388262f382" translate="yes" xml:space="preserve">
          <source>A bitstring generator can be mixed with &amp;ldquo;regular&amp;rdquo; enumerable generators, and supports filters as well.</source>
          <target state="translated">비트 스트링 생성기는 &quot;일반&quot;열거 가능 생성기와 혼합 할 수 있으며 필터도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="18fa63ca56fa56c911a7c87acd788299f0b5e786" translate="yes" xml:space="preserve">
          <source>A bitstring is made of many segments and each segment has a type. There are 9 types used in bitstrings:</source>
          <target state="translated">비트 열은 많은 세그먼트로 구성되며 각 세그먼트에는 유형이 있습니다. 비트 열에는 9 가지 유형이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ea8cc225102a641a743fb78156d8a9bef53771d8" translate="yes" xml:space="preserve">
          <source>A byte of Erlang</source>
          <target state="translated">얼랭 바이트</target>
        </trans-unit>
        <trans-unit id="79fd446d748480ae656763877da9c4cf859f5647" translate="yes" xml:space="preserve">
          <source>A calendar implementation</source>
          <target state="translated">캘린더 구현</target>
        </trans-unit>
        <trans-unit id="45adc33f9e352c348aeb6f71e9cae2cc39cef184" translate="yes" xml:space="preserve">
          <source>A calendar implementation that follows to ISO 8601.</source>
          <target state="translated">ISO 8601을 따르는 캘린더 구현.</target>
        </trans-unit>
        <trans-unit id="4983d0390c0cc88fb62df8a53e3ded20887e73ee" translate="yes" xml:space="preserve">
          <source>A charlist is nothing more than a list of code points. Char lists may be created with single-quoted literals:</source>
          <target state="translated">charlist는 코드 포인트 목록에 지나지 않습니다. 작은 따옴표로 리터럴을 사용하여 문자 목록을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e14e2847d8fdb35b747294036ae2ad35a22ccd61" translate="yes" xml:space="preserve">
          <source>A common trick in Elixir is to concatenate the null byte &lt;code&gt;&amp;lt;&amp;lt;0&amp;gt;&amp;gt;&lt;/code&gt; to a string to see its inner binary representation:</source>
          <target state="translated">Elixir의 일반적인 트릭은 null 바이트 &lt;code&gt;&amp;lt;&amp;lt;0&amp;gt;&amp;gt;&lt;/code&gt; 을 문자열에 연결하여 내부 이진 표현을 보는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1bfb26f32033c8d890b9980e9f88f657ab247fd3" translate="yes" xml:space="preserve">
          <source>A common use case of &lt;code&gt;:into&lt;/code&gt; can be transforming values in a map, without touching the keys:</source>
          <target state="translated">&lt;code&gt;:into&lt;/code&gt; 의 일반적인 사용 사례 는 키를 터치하지 않고도 맵에서 값을 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27f0ae652ebbfbd5531320563e778f58becfe7bb" translate="yes" xml:space="preserve">
          <source>A compiled pattern can also be given:</source>
          <target state="translated">컴파일 된 패턴도 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e76869e54063c0294aaea20a8943a0f7504376d4" translate="yes" xml:space="preserve">
          <source>A compiled pattern:</source>
          <target state="translated">컴파일 된 패턴 :</target>
        </trans-unit>
        <trans-unit id="d3ab1c60e70dbccd5bb3b6385dfc22cb20961df9" translate="yes" xml:space="preserve">
          <source>A complete reference about the binary / bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; can be found &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1&quot;&gt;in the Elixir documentation&lt;/a&gt;. This concludes our tour of bitstrings, binaries and strings. A string is a UTF-8 encoded binary and a binary is a bitstring where the number of bits is divisible by 8. Although this shows the flexibility Elixir provides for working with bits and bytes, 99% of the time you will be working with binaries and using the &lt;code&gt;is_binary/1&lt;/code&gt; and &lt;code&gt;byte_size/1&lt;/code&gt; functions.</source>
          <target state="translated">바이너리 / 비트 스트링 생성자 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 에 대한 완전한 참조 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1&quot;&gt;는 Elixir 문서에서&lt;/a&gt; 찾을 수 있습니다 . 이것으로 비트 스트링, 바이너리 및 스트링 둘러보기를 마칩니다. 문자열은 UTF-8로 인코딩 된 이진수이고 이진수는 비트 수를 8로 나눌 수있는 비트 열입니다. 이는 Elixir가 비트 및 바이트 작업을 위해 제공하는 유연성을 보여 주지만 이진으로 작업하는 시간의 99 % 상기 사용 &lt;code&gt;is_binary/1&lt;/code&gt; 및 &lt;code&gt;byte_size/1&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="105058c6913b6aca65f638c1f413a6d39b69929a" translate="yes" xml:space="preserve">
          <source>A comprehension accepts many generators and filters. Enumerable generators are defined using &lt;code&gt;&amp;lt;-&lt;/code&gt;:</source>
          <target state="translated">이해력은 많은 발전기와 필터를 수용합니다. 열거 가능한 생성기는 &lt;code&gt;&amp;lt;-&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f2254d1e3c598efd95bae0fbcd5261dc7a19b584" translate="yes" xml:space="preserve">
          <source>A comprehension is made of three parts: generators, filters, and collectables.</source>
          <target state="translated">이해는 생성기, 필터 및 수집품의 세 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="57e82275e50252bbe2085b03c1d0b32e426de8c6" translate="yes" xml:space="preserve">
          <source>A config provider is typically initialized on the machine where the system is assembled and not on the target machine. The &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback is useful to verify the arguments given to the provider and prepare the state that will be given to &lt;a href=&quot;#c:load/2&quot;&gt;&lt;code&gt;load/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구성 제공자는 일반적으로 대상 시스템이 아닌 시스템이 조립 된 시스템에서 초기화됩니다. &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 콜백 제공자에게 주어진 인자를 확인하고 설명한다 상태를 준비 할 때 유용 &lt;a href=&quot;#c:load/2&quot;&gt; &lt;code&gt;load/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2d91cecc19bd9b6373cb65cc2b96981847455a7" translate="yes" xml:space="preserve">
          <source>A continuation can be trivially implemented as long as the reduce function is defined in a tail recursive fashion. If the function is tail recursive, all the state is passed as arguments, so the continuation is the reducing function partially applied.</source>
          <target state="translated">감소 함수가 꼬리 재귀 방식으로 정의되는 한 연속은 간단하게 구현 될 수 있습니다. 함수가 꼬리 재귀 인 경우 모든 상태가 인수로 전달되므로 계속되는 부분은 축소 함수입니다.</target>
        </trans-unit>
        <trans-unit id="d9d07f696d7dfca22202afba7e8f633e04a8e575" translate="yes" xml:space="preserve">
          <source>A convenience macro that checks if the right side (an expression) matches the left side (a pattern).</source>
          <target state="translated">오른쪽 (표현식)이 왼쪽 (패턴)과 일치하는지 확인하는 편의 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="519bb29b1d6986fcd05f0a99d472d916cc9bd057" translate="yes" xml:space="preserve">
          <source>A datetime implementation with a time zone.</source>
          <target state="translated">시간대가있는 날짜 / 시간 구현입니다.</target>
        </trans-unit>
        <trans-unit id="78f3b8cdfef736d240c67d26318dec43ff774694" translate="yes" xml:space="preserve">
          <source>A developer can filter to import only macros or functions via the only option:</source>
          <target state="translated">개발자는 유일한 옵션을 통해 매크로 또는 함수 만 가져 오도록 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a911f4ab0ec30f4f88b0aebbdc462456eb2bb1d" translate="yes" xml:space="preserve">
          <source>A developer must never use a process for code organization purposes. A process must be used to model runtime properties such as:</source>
          <target state="translated">개발자는 코드 구성 목적으로 프로세스를 사용해서는 안됩니다. 다음과 같은 런타임 특성을 모델링하려면 프로세스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d1073f62e845462d6a9fa22958360b75968c4eb" translate="yes" xml:space="preserve">
          <source>A dynamic supervisor is started with no children, often under a supervisor with the supervision strategy (the only strategy currently supported is &lt;code&gt;:one_for_one&lt;/code&gt;) and a name:</source>
          <target state="translated">동적 감독자는 자식없이 시작하며, 종종 감독 전략 (현재 지원되는 유일한 전략은 &lt;code&gt;:one_for_one&lt;/code&gt; )과 이름을 가진 감독자 아래에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="206a7ca6f86f975f7d383ad0847c73bb36ab55be" translate="yes" xml:space="preserve">
          <source>A event manager with event handlers behaviour.</source>
          <target state="translated">이벤트 핸들러 동작이있는 이벤트 관리자</target>
        </trans-unit>
        <trans-unit id="5b9f82bdf9353661bdb7bfb129accfcfc67cacc8" translate="yes" xml:space="preserve">
          <source>A file can also be opened with &lt;code&gt;:utf8&lt;/code&gt; encoding, which tells the &lt;code&gt;File&lt;/code&gt; module to interpret the bytes read from the file as UTF-8-encoded bytes.</source>
          <target state="translated">&lt;code&gt;:utf8&lt;/code&gt; 인코딩을 사용하여 &lt;code&gt;File&lt;/code&gt; 열 수도 있습니다 . 파일 모듈에서 파일에서 읽은 바이트를 UTF-8로 인코딩 된 바이트로 해석하도록합니다.</target>
        </trans-unit>
        <trans-unit id="26174891cb43d56e620f230c7e58f6661e413141" translate="yes" xml:space="preserve">
          <source>A file named &lt;code&gt;mix.exs&lt;/code&gt; was generated inside our new project folder (&lt;code&gt;kv&lt;/code&gt;) and its main responsibility is to configure our project. Let&amp;rsquo;s take a look at it:</source>
          <target state="translated">&lt;code&gt;mix.exs&lt;/code&gt; 파일이 새 프로젝트 폴더 ( &lt;code&gt;kv&lt;/code&gt; ) 내에 생성 되었으며 주된 책임은 프로젝트를 구성하는 것입니다. 살펴 보자.</target>
        </trans-unit>
        <trans-unit id="b7f8081cbb17a898eeed9fb6829112a813894639" translate="yes" xml:space="preserve">
          <source>A finished test can be in one of five states:</source>
          <target state="translated">완료된 테스트는 5 가지 상태 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fed755e476e5364797de1ef4e79f28c16e21183" translate="yes" xml:space="preserve">
          <source>A first attempt at improving it could be with ranges:</source>
          <target state="translated">그것을 개선하기위한 첫 번째 시도는 범위가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="433ee9a9f829c196fd1ee1abea74ddd48c74e24a" translate="yes" xml:space="preserve">
          <source>A flex break still causes a group to break, like &lt;a href=&quot;#break/1&quot;&gt;&lt;code&gt;break/1&lt;/code&gt;&lt;/a&gt;, but it is re-evaluated when the documented is rendered.</source>
          <target state="translated">플렉스 브레이크는 여전히 &lt;a href=&quot;#break/1&quot;&gt; &lt;code&gt;break/1&lt;/code&gt; &lt;/a&gt; 과 같이 그룹을 중단 시키지만 문서화가 렌더링 될 때 다시 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="c789b9878ed6a8416701bcc8a3653070d47748c6" translate="yes" xml:space="preserve">
          <source>A full match spec used when selecting objects in the registry</source>
          <target state="translated">레지스트리에서 객체를 선택할 때 사용되는 전체 일치 사양</target>
        </trans-unit>
        <trans-unit id="7d5721d8d9a91361a538da41fa6ecb3b70b6fe95" translate="yes" xml:space="preserve">
          <source>A function that expects arguments can be defined as follows:</source>
          <target state="translated">인수를 기대하는 함수는 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d355151786999a1eeed6fd34569b3fb108130e3c" translate="yes" xml:space="preserve">
          <source>A general guideline is to use the supervisor without a callback module only at the top of your supervision tree, generally in the &lt;a href=&quot;application#c:start/2&quot;&gt;&lt;code&gt;Application.start/2&lt;/code&gt;&lt;/a&gt; callback. We recommend using module-based supervisors for any other supervisor in your application, so they can run as a child of another supervisor in the tree. The &lt;code&gt;child_spec/1&lt;/code&gt; generated automatically by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; can be customized with the following options:</source>
          <target state="translated">일반적인 지침은 일반적으로 &lt;a href=&quot;application#c:start/2&quot;&gt; &lt;code&gt;Application.start/2&lt;/code&gt; &lt;/a&gt; 콜백 에서 감독 트리 상단에서만 콜백 모듈없이 수퍼바이저를 사용하는 것 입니다. 응용 프로그램의 다른 수퍼바이저에 대해 모듈 기반 수퍼바이저를 사용하여 트리에서 다른 수퍼바이저의 자식으로 실행할 수 있도록하는 것이 좋습니다. &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 가 자동으로 생성 한 &lt;code&gt;child_spec/1&lt;/code&gt; 은 다음 옵션으로 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6b4711dc1275381e6488c7af769cb77bdc74fad" translate="yes" xml:space="preserve">
          <source>A given bytecode or protocol implementation can be checked to be consolidated or not by analyzing the protocol attribute:</source>
          <target state="translated">주어진 바이트 코드 또는 프로토콜 구현은 프로토콜 속성을 분석하여 통합 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78b0b35ef86b280f67197dee5c9182e1ddbec041" translate="yes" xml:space="preserve">
          <source>A given include/exclude filter can be given more than once:</source>
          <target state="translated">지정된 포함 / 제외 필터는 두 번 이상 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ace5acb901e1cf11450076f19fc37584bf1d2ad7" translate="yes" xml:space="preserve">
          <source>A group with linebreaks will fit if all lines in the group fit.</source>
          <target state="translated">그룹의 모든 줄이 맞으면 줄 바꿈이있는 그룹이 적합합니다.</target>
        </trans-unit>
        <trans-unit id="d57f1441409523fcaba5ede0a6bbc3934bffdaa3" translate="yes" xml:space="preserve">
          <source>A guard to be evaluated when matching on objects in a registry</source>
          <target state="translated">레지스트리의 객체와 일치 할 때 평가할 가드</target>
        </trans-unit>
        <trans-unit id="f530d85d2682e767c664f63f19c8edab6f12a410" translate="yes" xml:space="preserve">
          <source>A handful of functions exist to handle duplicated keys, in particular, &lt;a href=&quot;enum#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt; allows creating new keywords without removing duplicated keys, &lt;a href=&quot;#get_values/2&quot;&gt;&lt;code&gt;get_values/2&lt;/code&gt;&lt;/a&gt; returns all values for a given key and &lt;a href=&quot;#delete_first/2&quot;&gt;&lt;code&gt;delete_first/2&lt;/code&gt;&lt;/a&gt; deletes just one of the existing entries.</source>
          <target state="translated">중복 키를 처리하는 소수의 기능이 있습니다. 특히 &lt;a href=&quot;enum#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; &lt;/a&gt; 는 중복 키를 제거하지 않고 새 키워드를 만들 수 있으며 &lt;a href=&quot;#get_values/2&quot;&gt; &lt;code&gt;get_values/2&lt;/code&gt; &lt;/a&gt; 는 지정된 키의 모든 값을 반환하며 &lt;a href=&quot;#delete_first/2&quot;&gt; &lt;code&gt;delete_first/2&lt;/code&gt; &lt;/a&gt; 는 기존 항목 중 하나만 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="596a9b5a3a8aa9b50ec41bf23a4f842662a8cb81" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked before the module is compiled.</source>
          <target state="translated">모듈이 컴파일되기 전에 호출되는 후크입니다.</target>
        </trans-unit>
        <trans-unit id="a0a0a51df914ce59ba1556541b6506e53ae5b94d" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked before the module is compiled. Accepts a module or a &lt;code&gt;{module, function_or_macro_name}&lt;/code&gt; tuple. See the &quot;Compile callbacks&quot; section below.</source>
          <target state="translated">모듈이 컴파일되기 전에 호출되는 후크입니다. 모듈 또는 &lt;code&gt;{module, function_or_macro_name}&lt;/code&gt; 튜플을 승인합니다 . 아래의 &quot;컴파일 콜백&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6987134a6eff9f82a6141f1c9cc8c83ffe79d180" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked right after the current module is compiled.</source>
          <target state="translated">현재 모듈이 컴파일 된 직후에 호출되는 후크입니다.</target>
        </trans-unit>
        <trans-unit id="83dcc203e6f45c9ceed02fc70bb7ce0dc9022031" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked right after the current module is compiled. Accepts a module or a &lt;code&gt;{module, function_name}&lt;/code&gt;. See the &quot;Compile callbacks&quot; section below.</source>
          <target state="translated">현재 모듈이 컴파일 된 직후에 호출되는 후크입니다. 모듈 또는 &lt;code&gt;{module, function_name}&lt;/code&gt; 승인합니다 . 아래의 &quot;컴파일 콜백&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7281774c2eebc7eedcdde8f4eb9495e25954bfba" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked when each function or macro in the current module is defined. Useful when annotating functions.</source>
          <target state="translated">현재 모듈의 각 함수 또는 매크로가 정의 될 때 호출되는 후크입니다. 함수에 주석을 달 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b574e1f9586eced8b5deb66bb46ac24d0c228cae" translate="yes" xml:space="preserve">
          <source>A hook that will be invoked whenever the module is loaded.</source>
          <target state="translated">모듈이로드 될 때마다 호출되는 후크입니다.</target>
        </trans-unit>
        <trans-unit id="3230b053994c4f824d19b0f0c39c5b461d162140" translate="yes" xml:space="preserve">
          <source>A keyword list can also be given if there is a need to change the child specification for the given child process:</source>
          <target state="translated">지정된 자식 프로세스에 대한 자식 사양을 변경해야 할 경우 키워드 목록을 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="27f0445b17da9c462d7db8862e1b68f43ab27b20" translate="yes" xml:space="preserve">
          <source>A keyword list containing inspect options used by the shell when printing results of expression evaluation. Default to pretty formatting with a limit of 50 entries.</source>
          <target state="translated">표현식 평가 결과를 인쇄 할 때 쉘에서 사용하는 검사 옵션을 포함하는 키워드 목록. 기본값은 50 개 항목으로 구성된 예쁜 형식입니다.</target>
        </trans-unit>
        <trans-unit id="61fe73f02ff5a301c92071887b054a01257fbb87" translate="yes" xml:space="preserve">
          <source>A keyword list is a list of two-element tuples where the first element of the tuple is an atom and the second element can be any value.</source>
          <target state="translated">키워드 목록은 튜플의 첫 번째 요소가 원자이고 두 번째 요소가 임의의 값일 수있는 두 요소 튜플의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="352c6325949d916dfbf48e00d1fe4d030d4dc592" translate="yes" xml:space="preserve">
          <source>A keyword list that encapsulates all color settings used by the shell. See documentation for the &lt;a href=&quot;https://hexdocs.pm/elixir/IO.ANSI.html&quot;&gt;&lt;code&gt;IO.ANSI&lt;/code&gt;&lt;/a&gt; module for the list of supported colors and attributes.</source>
          <target state="translated">쉘에서 사용하는 모든 색상 설정을 캡슐화하는 키워드 목록. 지원되는 색상 및 속성 목록은 &lt;a href=&quot;https://hexdocs.pm/elixir/IO.ANSI.html&quot;&gt; &lt;code&gt;IO.ANSI&lt;/code&gt; &lt;/a&gt; 모듈 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90fd8fbcd55ac37d5c84cb3c58c955ad51a59d87" translate="yes" xml:space="preserve">
          <source>A keyword list:</source>
          <target state="translated">키워드 목록 :</target>
        </trans-unit>
        <trans-unit id="207a17d66a4d274303a0b808b876e2f07cab4cdc" translate="yes" xml:space="preserve">
          <source>A keyword may have duplicated keys so it is not strictly a key-value store. However most of the functions in this module behave exactly as a dictionary so they work similarly to the functions you would find in the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">키워드에 중복 키가있을 수 있으므로 키-값 저장소가 아닙니다. 그러나이 모듈의 대부분의 함수는 사전으로 정확하게 작동하므로 &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 모듈 에서 찾은 함수와 유사하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="7d3c9948a05d7abcab99c9cefbe9438aa010a2dc" translate="yes" xml:space="preserve">
          <source>A leap year is a year of a longer length than normal. The exact meaning is up to the calendar. A calendar must return &lt;code&gt;false&lt;/code&gt; if it does not support the concept of leap years.</source>
          <target state="translated">윤년은 정상보다 길이가 더 길다. 정확한 의미는 달력에 달려 있습니다. 윤년 개념을 지원하지 않는 달력은 &lt;code&gt;false&lt;/code&gt; 를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fb9fe9c85fbf7d3fb18bb99ccf2350f33242ce20" translate="yes" xml:space="preserve">
          <source>A library should not provide &lt;code&gt;use MyLib&lt;/code&gt; functionality if all &lt;code&gt;use MyLib&lt;/code&gt; does is to &lt;code&gt;import&lt;/code&gt;/&lt;code&gt;alias&lt;/code&gt; the module itself. For example, this is an anti-pattern:</source>
          <target state="translated">라이브러리는 제공하지 않아야 &lt;code&gt;use MyLib&lt;/code&gt; 모든 경우 기능을 &lt;code&gt;use MyLib&lt;/code&gt; 하지가입니다 &lt;code&gt;import&lt;/code&gt; / &lt;code&gt;alias&lt;/code&gt; 모듈 자체. 예를 들어, 이것은 안티 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="86a187cb80a7c4ad0fb8e723a871bc21c28d506c" translate="yes" xml:space="preserve">
          <source>A link is created between the calling process and the new process, atomically. If &lt;code&gt;node&lt;/code&gt; does not exist, a useless PID is returned (and due to the link, an exit signal with exit reason &lt;code&gt;:noconnection&lt;/code&gt; will be received).</source>
          <target state="translated">호출 프로세스와 새 프로세스간에 원자 적으로 링크가 작성됩니다. 경우 &lt;code&gt;node&lt;/code&gt; 존재하지 않는, 쓸모없는 PID가 반환 (인해 링크, 출구 이유가 종료 신호에있다 &lt;code&gt;:noconnection&lt;/code&gt; 가 수신됩니다).</target>
        </trans-unit>
        <trans-unit id="f32efab7c564ee44d8dbdb445e6ef037578935c8" translate="yes" xml:space="preserve">
          <source>A list also supports matching on its own head and tail:</source>
          <target state="translated">리스트는 또한 머리와 꼬리에 일치하는 것을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="b51c3a4547f02d7e7f4e5168a995c1a16dcdbcfa" translate="yes" xml:space="preserve">
          <source>A list can be checked if it is made of only printable ASCII characters with &lt;a href=&quot;#ascii_printable?/2&quot;&gt;&lt;code&gt;ascii_printable?/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ascii_printable?/2&quot;&gt; &lt;code&gt;ascii_printable?/2&lt;/code&gt; 인&lt;/a&gt; 인쇄 가능한 ASCII 문자로만 구성된 경우 목록을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09109009b595afbd12ae9a2a04f05c373522edd5" translate="yes" xml:space="preserve">
          <source>A list of environment options can also be given as argument. See &lt;a href=&quot;code#eval_string/3&quot;&gt;&lt;code&gt;Code.eval_string/3&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">환경 옵션 목록을 인수로 제공 할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;code#eval_string/3&quot;&gt; &lt;code&gt;Code.eval_string/3&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5fa40d2c95d1592c3f577816c839f4bfb9a0eb32" translate="yes" xml:space="preserve">
          <source>A list of files can be given after the task name in order to select the files to compile:</source>
          <target state="translated">컴파일 할 파일을 선택하기 위해 작업 이름 뒤에 파일 목록을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4f891471b493829a13afb97466625b0b354b781" translate="yes" xml:space="preserve">
          <source>A list of guards to be evaluated when matching on objects in a registry</source>
          <target state="translated">레지스트리의 객체와 일치 할 때 평가할 가드 목록</target>
        </trans-unit>
        <trans-unit id="a09af47acaa10fb69360523f8594ec6d2a340887" translate="yes" xml:space="preserve">
          <source>A list of lists is returned, where each entry in the primary list represents a match and each entry in the secondary list represents the captured contents.</source>
          <target state="translated">기본 목록의 각 항목은 일치를 나타내고 보조 목록의 각 항목은 캡처 된 내용을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ea96d09747a4aa343151e0377aac270bb2119eb2" translate="yes" xml:space="preserve">
          <source>A list of options which can be used to specify things like the name of the server. For now, we forward the list of options that we receive on &lt;code&gt;start_link/1&lt;/code&gt; to &lt;code&gt;GenServer.start_link/3&lt;/code&gt;</source>
          <target state="translated">서버 이름과 같은 항목을 지정하는 데 사용할 수있는 옵션 목록입니다. 지금 은 &lt;code&gt;GenServer.start_link/3&lt;/code&gt; &lt;code&gt;start_link/1&lt;/code&gt; 에서 받는 옵션 목록 을 GenServer에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="14180540c9dfb80b1033daf7503e57620771cedc" translate="yes" xml:space="preserve">
          <source>A list of patterns:</source>
          <target state="translated">패턴 목록 :</target>
        </trans-unit>
        <trans-unit id="bfadb8e1f57e1fb13ad2e8d3a0b69f6c2d5144ae" translate="yes" xml:space="preserve">
          <source>A local, decentralized and scalable key-value process storage.</source>
          <target state="translated">로컬, 분산 및 확장 가능한 키-값 프로세스 스토리지.</target>
        </trans-unit>
        <trans-unit id="fea558b9d01d10708bd232eedeea8d9affdc8614" translate="yes" xml:space="preserve">
          <source>A logger for Elixir applications.</source>
          <target state="translated">Elixir 애플리케이션 용 로거.</target>
        </trans-unit>
        <trans-unit id="0f699b34255da40ccc76a38c897571c0c579e349" translate="yes" xml:space="preserve">
          <source>A mandatory linebreak.</source>
          <target state="translated">필수 줄 바꿈.</target>
        </trans-unit>
        <trans-unit id="a06294fa5d8aaf5ba345cd5c76ff398b3966ffbf" translate="yes" xml:space="preserve">
          <source>A map representing the results of running a test suite</source>
          <target state="translated">테스트 스위트 실행 결과를 나타내는 맵</target>
        </trans-unit>
        <trans-unit id="3d6bcd31c59bce4c517c58779221986c48c5763e" translate="yes" xml:space="preserve">
          <source>A meta task that compiles source files.</source>
          <target state="translated">소스 파일을 컴파일하는 메타 작업입니다.</target>
        </trans-unit>
        <trans-unit id="6a1a9dcccbb902320d46c5c63b16e41809e26be8" translate="yes" xml:space="preserve">
          <source>A module for working with applications and defining application callbacks.</source>
          <target state="translated">응용 프로그램 작업 및 응용 프로그램 콜백 정의를위한 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="8dd0cdfde3f3104d72c5cb46bfa86d5986868373" translate="yes" xml:space="preserve">
          <source>A module is &quot;open&quot; if it is currently being defined and its attributes and functions can be modified.</source>
          <target state="translated">모듈이 현재 정의되어 있고 해당 속성과 기능을 수정할 수있는 경우 &quot;개방&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="db0c1125a7c9859ba806c52d2b8389c8da71008d" translate="yes" xml:space="preserve">
          <source>A module may export functions that are not meant to be used directly: these functions won't be autocompleted by IEx. IEx will not autocomplete functions annotated with &lt;code&gt;@doc false&lt;/code&gt;, &lt;code&gt;@impl true&lt;/code&gt;, or functions that aren't explicitly documented and where the function name is in the form of &lt;code&gt;__foo__&lt;/code&gt;.</source>
          <target state="translated">모듈은 직접 사용되지 않는 기능을 내보낼 수 있습니다. 이러한 기능은 IEx에 의해 자동 완성되지 않습니다. IEx는 &lt;code&gt;@doc false&lt;/code&gt; , &lt;code&gt;@impl true&lt;/code&gt; 로 주석이 달린 함수 또는 명시 적으로 문서화되지 않은 함수와 함수 이름이 &lt;code&gt;__foo__&lt;/code&gt; 형식 인 함수를 자동 완성 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="32cd185a5680fc74f94a90987dd36d929f10c20a" translate="yes" xml:space="preserve">
          <source>A module responsible for compiling and requiring files in parallel.</source>
          <target state="translated">파일을 병렬로 컴파일하고 요구하는 모듈.</target>
        </trans-unit>
        <trans-unit id="29645843a5110b928d9faeadea534106995dc37f" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;index&lt;/code&gt; can be passed, which means the &lt;code&gt;enumerable&lt;/code&gt; is enumerated once and the &lt;code&gt;index&lt;/code&gt; is counted from the end (for example, &lt;code&gt;-1&lt;/code&gt; fetches the last element).</source>
          <target state="translated">음수 &lt;code&gt;index&lt;/code&gt; 를 전달할 수 있는데, 이는 &lt;code&gt;enumerable&lt;/code&gt; 이 한 번 열거되고 &lt;code&gt;index&lt;/code&gt; 가 끝부터 계산 됨을 의미합니다 (예 : &lt;code&gt;-1&lt;/code&gt; 은 마지막 요소를 가져옵니다).</target>
        </trans-unit>
        <trans-unit id="26cdfdc092bdd1d22ed3029d691848711d9f566b" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;index&lt;/code&gt; can be passed, which means the &lt;code&gt;enumerable&lt;/code&gt; is enumerated once and the &lt;code&gt;index&lt;/code&gt; is counted from the end (for example, &lt;code&gt;-1&lt;/code&gt; finds the last element).</source>
          <target state="translated">음수 &lt;code&gt;index&lt;/code&gt; 를 전달할 수 있습니다. 즉, &lt;code&gt;enumerable&lt;/code&gt; 이 한 번 열거되고 &lt;code&gt;index&lt;/code&gt; 가 끝부터 계산됩니다 (예 : &lt;code&gt;-1&lt;/code&gt; 이 마지막 요소를 찾습니다).</target>
        </trans-unit>
        <trans-unit id="7237cde12b43d44a106f66033ee7470522a9c3a4" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;length&lt;/code&gt; can be used to extract bytes that come &lt;em&gt;before&lt;/em&gt; the byte at &lt;code&gt;start&lt;/code&gt;:</source>
          <target state="translated">음수 &lt;code&gt;length&lt;/code&gt; 를 사용하여 &lt;code&gt;start&lt;/code&gt; 바이트 &lt;em&gt;앞에&lt;/em&gt; 오는 바이트를 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36a3b9605725fcc95fe9b23e674356e7e27c98c9" translate="yes" xml:space="preserve">
          <source>A negative &lt;code&gt;start_index&lt;/code&gt; can be passed, which means the &lt;code&gt;enumerable&lt;/code&gt; is enumerated once and the index is counted from the end (for example, &lt;code&gt;-1&lt;/code&gt; starts slicing from the last element).</source>
          <target state="translated">음수 &lt;code&gt;start_index&lt;/code&gt; 를 전달할 수 있습니다. 즉, &lt;code&gt;enumerable&lt;/code&gt; 이 한 번 열거되고 색인부터 끝까지 계산됩니다 (예 : &lt;code&gt;-1&lt;/code&gt; 은 마지막 요소에서 슬라이스 시작).</target>
        </trans-unit>
        <trans-unit id="81c58f8de418e8cd25d1b22380a53e0273247707" translate="yes" xml:space="preserve">
          <source>A negative assertion, expects the expression to be &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">부정 어설 션은 표현식이 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 이 될 것으로 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="f88876dd5bc14e91399b8aa67a2ddb2e03a67c34" translate="yes" xml:space="preserve">
          <source>A non-local return from a function.</source>
          <target state="translated">함수에서 로컬이 아닌 리턴.</target>
        </trans-unit>
        <trans-unit id="0eaabe61fdbf51208eaa83fc1dc3996aba60b1e8" translate="yes" xml:space="preserve">
          <source>A non-temporary child process may later be restarted by the supervisor. The child process can also be restarted explicitly by calling &lt;a href=&quot;#restart_child/2&quot;&gt;&lt;code&gt;restart_child/2&lt;/code&gt;&lt;/a&gt;. Use &lt;a href=&quot;#delete_child/2&quot;&gt;&lt;code&gt;delete_child/2&lt;/code&gt;&lt;/a&gt; to remove the child specification.</source>
          <target state="translated">비 임시적 하위 프로세스는 나중에 감독자가 다시 시작할 수 있습니다. 자식 프로세스는 &lt;a href=&quot;#restart_child/2&quot;&gt; &lt;code&gt;restart_child/2&lt;/code&gt; &lt;/a&gt; 를 호출하여 명시 적으로 다시 시작할 수도 있습니다 . 하위 스펙을 제거 하려면 &lt;a href=&quot;#delete_child/2&quot;&gt; &lt;code&gt;delete_child/2&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f2c93e683b0d27c8800a0f19ebf6094692e37b8" translate="yes" xml:space="preserve">
          <source>A partially applied reduce function.</source>
          <target state="translated">부분적으로 적용된 감소 기능.</target>
        </trans-unit>
        <trans-unit id="e00db969c5f31283ff3f80e6b605d47156f36587" translate="yes" xml:space="preserve">
          <source>A path may start with a variable, local or remote call, and must be followed by one or more:</source>
          <target state="translated">경로는 변수, 로컬 또는 원격 호출로 시작할 수 있으며 뒤에 하나 이상이 와야합니다.</target>
        </trans-unit>
        <trans-unit id="5e11bed9e1e8a8a0b7c8ded2d01ff3d9a7368c94" translate="yes" xml:space="preserve">
          <source>A path pointing to a configuration file.</source>
          <target state="translated">구성 파일을 가리키는 경로입니다.</target>
        </trans-unit>
        <trans-unit id="41835ab5b136f3e0eaefd676f9827017842ad941" translate="yes" xml:space="preserve">
          <source>A pattern match error will occur if the sides can&amp;rsquo;t be matched, for example if the tuples have different sizes:</source>
          <target state="translated">튜플의 크기가 다른 경우와 같이면을 일치시킬 수없는 경우 패턴 일치 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="79fa4792dd24d1c9ce95071d9547feb6a4d474ba" translate="yes" xml:space="preserve">
          <source>A pattern to match on objects in a registry</source>
          <target state="translated">레지스트리의 객체와 일치하는 패턴</target>
        </trans-unit>
        <trans-unit id="3d346e75c8c6987f80b82de7253d52d8aba958ff" translate="yes" xml:space="preserve">
          <source>A pattern used to representing the output format part of a match spec</source>
          <target state="translated">일치 스펙의 출력 형식 부분을 나타내는 데 사용되는 패턴</target>
        </trans-unit>
        <trans-unit id="a00cd65793f8f99aab040156d050cf1a0b39a869" translate="yes" xml:space="preserve">
          <source>A period where a certain combination of UTC offset, standard offset and zone abbreviation is in effect.</source>
          <target state="translated">UTC 오프셋, 표준 오프셋 및 영역 약어의 특정 조합이 적용되는 기간입니다.</target>
        </trans-unit>
        <trans-unit id="a5288558e1086c80bf20bc1087103275b3133199" translate="yes" xml:space="preserve">
          <source>A port can be closed via the &lt;a href=&quot;#close/1&quot;&gt;&lt;code&gt;close/1&lt;/code&gt;&lt;/a&gt; function or by sending a &lt;code&gt;{pid, :close}&lt;/code&gt; message. However, if the VM crashes, a long-running program started by the port will have its stdin and stdout channels closed but &lt;strong&gt;it won't be automatically terminated&lt;/strong&gt;.</source>
          <target state="translated">&lt;a href=&quot;#close/1&quot;&gt; &lt;code&gt;close/1&lt;/code&gt; &lt;/a&gt; 기능을 통해 또는 &lt;code&gt;{pid, :close}&lt;/code&gt; 메시지 를 보내 포트를 닫을 수 있습니다 . 그러나 VM이 충돌하면 포트에서 시작한 장기 실행 프로그램의 stdin 및 stdout 채널이 닫히지 만 &lt;strong&gt;자동으로 종료되지는 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b2122c1973c2dda96664be48d7e0ad6fbebe03e1" translate="yes" xml:space="preserve">
          <source>A printable charlist in Elixir contains only the printable characters in the standard seven-bit ASCII character encoding, which are characters ranging from 32 to 126 in decimal notation, plus the following control characters:</source>
          <target state="translated">Elixir의 인쇄 가능한 문자 목록에는 표준 7 비트 ASCII 문자 인코딩의 인쇄 가능한 문자 (십진수 표기법으로 32에서 126까지의 문자)와 다음 제어 문자 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b3af7c971656040987518db1c82f85c014263d8e" translate="yes" xml:space="preserve">
          <source>A process destination.</source>
          <target state="translated">프로세스 대상</target>
        </trans-unit>
        <trans-unit id="fcf40e109a152697e452d59c6feb366ea55241fd" translate="yes" xml:space="preserve">
          <source>A protocol specifies an API that should be defined by its implementations. A protocol is defined with &lt;a href=&quot;kernel#defprotocol/2&quot;&gt;&lt;code&gt;Kernel.defprotocol/2&lt;/code&gt;&lt;/a&gt; and its implementations with &lt;a href=&quot;kernel#defimpl/2&quot;&gt;&lt;code&gt;Kernel.defimpl/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로토콜은 구현에 의해 정의되어야하는 API를 지정합니다. 프로토콜이 정의된다 &lt;a href=&quot;kernel#defprotocol/2&quot;&gt; &lt;code&gt;Kernel.defprotocol/2&lt;/code&gt; &lt;/a&gt; 와 함께 그 구현 &lt;a href=&quot;kernel#defimpl/2&quot;&gt; &lt;code&gt;Kernel.defimpl/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="40779d1515587d6db075e7f5314df3d534311c89" translate="yes" xml:space="preserve">
          <source>A protocol to traverse data structures.</source>
          <target state="translated">데이터 구조를 통과하는 프로토콜입니다.</target>
        </trans-unit>
        <trans-unit id="faabe41c6f24d8fc609c47ff799c87b178b75359" translate="yes" xml:space="preserve">
          <source>A range implements the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, which means functions in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module can be used to work with ranges:</source>
          <target state="translated">범위는 &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 프로토콜을 구현합니다 . 이는 &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈의 함수를 사용하여 범위를 처리 할 수 ​​있음 을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="c2bc069750ea0a5631ff0d83641bb81ba15fed6b" translate="yes" xml:space="preserve">
          <source>A range is represented internally as a struct. However, the most common form of creating and matching on ranges is via the &lt;a href=&quot;kernel#../2&quot;&gt;&lt;code&gt;../2&lt;/code&gt;&lt;/a&gt; macro, auto-imported from &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">범위는 내부적으로 구조체로 표시됩니다. 그러나 범위에서 만들고 생성하는 가장 일반적인 형태는 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 에서 자동으로 가져 오는 &lt;a href=&quot;kernel#../2&quot;&gt; &lt;code&gt;../2&lt;/code&gt; &lt;/a&gt; 매크로 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="28e7d9d80973e28b2fb29cdc49aa8ec0aa8cccf3" translate="yes" xml:space="preserve">
          <source>A range of dates implements the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, which means functions in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module can be used to work with ranges:</source>
          <target state="translated">날짜 범위는 &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 프로토콜을 구현합니다. 즉 &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈의 함수를 사용하여 범위 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef459269461f63f29663369bbbf33d383fe471b6" translate="yes" xml:space="preserve">
          <source>A range of dates represents a discrete number of dates where the first and last values are dates with matching calendars.</source>
          <target state="translated">날짜 범위는 첫 번째 값과 마지막 값이 달력과 일치하는 날짜 인 이산 날짜 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="857a01be27effa9640fcaf21a35ced2eddd4ea08" translate="yes" xml:space="preserve">
          <source>A range represents a sequence of one or many, ascending or descending, consecutive integers.</source>
          <target state="translated">범위는 하나 이상의 오름차순 또는 내림차순 연속 정수 시퀀스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3fb37b0dc70a7a2ede2ae25048520f07b813bb7c" translate="yes" xml:space="preserve">
          <source>A regular expression:</source>
          <target state="translated">정규식 :</target>
        </trans-unit>
        <trans-unit id="be263ca652770d8e713a67b34a6b5d617a6d08fc" translate="yes" xml:space="preserve">
          <source>A release is a self-contained directory that consists of your application code, all of its dependencies, plus the whole Erlang Virtual Machine (VM) and runtime. Once a release is assembled, it can be packaged and deployed to a target as long as the target runs on the same operating system (OS) distribution and version as the machine that assembled the release.</source>
          <target state="translated">릴리스는 응용 프로그램 코드, 모든 종속 항목 및 전체 Erlang 가상 머신 (VM) 및 런타임으로 구성된 독립형 디렉토리입니다. 릴리스가 조립되면 대상이 릴리스를 조립 한 시스템과 동일한 운영 체제 (OS) 배포 및 버전에서 실행되는 한 패키지를 대상에 배포하고 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c42536b2192014c69ae4b22e18c222e0b18ad99c" translate="yes" xml:space="preserve">
          <source>A remote or local PID, a local port, a locally registered name, or a tuple in the form of &lt;code&gt;{registered_name, node}&lt;/code&gt; for a registered name at another node.</source>
          <target state="translated">다른 노드에서 등록 된 이름에 대한 원격 또는 로컬 PID, 로컬 포트, 로컬로 등록 된 이름 또는 &lt;code&gt;{registered_name, node}&lt;/code&gt; 형식의 튜플 .</target>
        </trans-unit>
        <trans-unit id="ed74d2fa39cb6d22ba41097b9f56baec46115768" translate="yes" xml:space="preserve">
          <source>A runtime error can be raised any time by using &lt;code&gt;raise/1&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;raise/1&lt;/code&gt; 을 사용하면 언제든지 런타임 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecf229e1b88c6de3ab419f5af0149c86ba96a100" translate="yes" xml:space="preserve">
          <source>A set can contain any kind of elements, and elements in a set don't have to be of the same type. By definition, sets can't contain duplicate elements: when inserting an element in a set where it's already present, the insertion is simply a no-op.</source>
          <target state="translated">집합은 모든 종류의 요소를 포함 할 수 있으며 집합의 요소는 같은 유형일 필요는 없습니다. 정의에 따르면, 세트는 중복 요소를 포함 할 수 없습니다. 이미 존재하는 세트에 요소를 삽입 할 때 삽입은 단순히 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69129ee232976b3cda2ab262254ae0307e0e66f5" translate="yes" xml:space="preserve">
          <source>A set of aliases can be specified in the &lt;code&gt;:aliases&lt;/code&gt; option:</source>
          <target state="translated">별명 세트는 &lt;code&gt;:aliases&lt;/code&gt; 옵션 에서 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e06834fc00f6bb288e0de824ba38e921ca02021c" translate="yes" xml:space="preserve">
          <source>A set of functions for creating and manipulating algebra documents.</source>
          <target state="translated">대수 문서를 작성하고 조작하기위한 함수 세트.</target>
        </trans-unit>
        <trans-unit id="88d1b0f8b81589767cdd10b2d4eb2dac1c18cfad" translate="yes" xml:space="preserve">
          <source>A set of functions for working with functions.</source>
          <target state="translated">함수 작업을위한 함수 집합입니다.</target>
        </trans-unit>
        <trans-unit id="730d44e1645bfae97fe7c12ff77a7bf08210ea3c" translate="yes" xml:space="preserve">
          <source>A set of functions for working with keywords.</source>
          <target state="translated">키워드 작업을위한 일련의 기능.</target>
        </trans-unit>
        <trans-unit id="dfb7a76606ff3c8779b3a99cd95301d320dbf7d1" translate="yes" xml:space="preserve">
          <source>A set of functions for working with maps.</source>
          <target state="translated">맵 작업을위한 함수 세트입니다.</target>
        </trans-unit>
        <trans-unit id="5f326a556060d175497aed660d915fb196c3082f" translate="yes" xml:space="preserve">
          <source>A set of macros that perform calculations on bits.</source>
          <target state="translated">비트에 대한 계산을 수행하는 매크로 세트.</target>
        </trans-unit>
        <trans-unit id="7d47059c046e5014c34e11ea59ece30879e2953e" translate="yes" xml:space="preserve">
          <source>A short example is:</source>
          <target state="translated">간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cbb763bbb5e88ec5f61d4da245e4ae7009da3216" translate="yes" xml:space="preserve">
          <source>A similar example is when the formatter breaks a function definition over multiple clauses:</source>
          <target state="translated">비슷한 예는 포맷터가 여러 절에 대해 함수 정의를 어기는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="40cf8919ea34c404a49fa4a02115691af647ed4f" translate="yes" xml:space="preserve">
          <source>A simple example</source>
          <target state="translated">간단한 예</target>
        </trans-unit>
        <trans-unit id="70f5ef2ef60f95969333b92d42f3f374f63b82f9" translate="yes" xml:space="preserve">
          <source>A simple keyword-based configuration API.</source>
          <target state="translated">간단한 키워드 기반 구성 API</target>
        </trans-unit>
        <trans-unit id="c8561655e8b17e9fc3693ef2633482210d43ebb9" translate="yes" xml:space="preserve">
          <source>A simple module that provides conveniences for creating, loading and manipulating tasks.</source>
          <target state="translated">작업을 생성,로드 및 조작 할 수있는 편의성을 제공하는 간단한 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="15571e3a35bf5ea9940001cd7a008535588aae55" translate="yes" xml:space="preserve">
          <source>A simpler option would be to use comprehensions for the mapping and filtering of letters, and then we invoke &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt; to build a map, for example:</source>
          <target state="translated">더 간단한 옵션은 글자의 매핑과 필터링에 이해력을 사용하는 것입니다. 그런 다음 &lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt; 를 호출 하여 맵을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="42b7224e7f04fc46b45efe7b42b88ffb7dce900f" translate="yes" xml:space="preserve">
          <source>A slicing function that receives the initial position and the number of elements in the slice.</source>
          <target state="translated">슬라이스의 초기 위치와 요소 수를받는 슬라이싱 기능입니다.</target>
        </trans-unit>
        <trans-unit id="9542d8f0337c374d610ba8edde94615ef17ee5bc" translate="yes" xml:space="preserve">
          <source>A solution is to make sure the child processes listen to the standard input and terminate when standard input is closed. We discuss this topic at length in the &quot;Zombie operating system processes&quot; of the &lt;a href=&quot;https://hexdocs.pm/elixir/Port.html&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; module documentation.</source>
          <target state="translated">해결책은 하위 프로세스가 표준 입력을 청취하고 표준 입력이 닫힐 때 종료되도록하는 것입니다. 이 주제에 대해서는 &lt;a href=&quot;https://hexdocs.pm/elixir/Port.html&quot;&gt; &lt;code&gt;Port&lt;/code&gt; &lt;/a&gt; 모듈 설명서 의 &quot;좀비 운영 체제 프로세스&quot;에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c87e0295b0434ce8d6e0bea2a0090734199f18b2" translate="yes" xml:space="preserve">
          <source>A specification for a function can be defined as follows:</source>
          <target state="translated">함수의 스펙은 다음과 같이 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb5a957f0b3dafd85aa37ba4fcf8ab83b116491b" translate="yes" xml:space="preserve">
          <source>A stacktrace must be given as an argument. If not, the stacktrace is retrieved from &lt;a href=&quot;process#info/2&quot;&gt;&lt;code&gt;Process.info/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">스택 추적은 인수로 제공되어야합니다. 그렇지 않은 경우 스택 추적은 &lt;a href=&quot;process#info/2&quot;&gt; &lt;code&gt;Process.info/2&lt;/code&gt; &lt;/a&gt; 에서 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="024c57bba13b29b29ec58526f15dcb1593786c12" translate="yes" xml:space="preserve">
          <source>A string is a UTF-8 encoded binary. In order to understand exactly what we mean by that, we need to understand the difference between bytes and code points.</source>
          <target state="translated">문자열은 UTF-8로 인코딩 된 이진입니다. 우리가 의미하는 바를 정확히 이해하려면 바이트와 코드 포인트의 차이점을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="3135dbc4cf4ce228f4aedafff7fb3268b76ca8f3" translate="yes" xml:space="preserve">
          <source>A struct is a tagged map that allows developers to provide default values for keys, tags to be used in polymorphic dispatches and compile time assertions.</source>
          <target state="translated">구조체는 개발자가 키에 대한 기본값, 다형성 디스패치에 사용되는 태그 및 컴파일 시간 명제를 제공 할 수있는 태그 된 맵입니다.</target>
        </trans-unit>
        <trans-unit id="9134cc0bb82067454750b89f0528401b6a9bc1d3" translate="yes" xml:space="preserve">
          <source>A struct that holds compile time environment information.</source>
          <target state="translated">컴파일 시간 환경 정보를 보유하는 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="2aab307089f5f9db7819dc7a115a812e5a3fa578" translate="yes" xml:space="preserve">
          <source>A struct that holds file information.</source>
          <target state="translated">파일 정보를 보유하는 구조체</target>
        </trans-unit>
        <trans-unit id="682f2bb617fd3f67f3ee1da2f3c9e406cf26c520" translate="yes" xml:space="preserve">
          <source>A struct that holds version requirement information.</source>
          <target state="translated">버전 요구 사항 정보를 보유하는 구조체.</target>
        </trans-unit>
        <trans-unit id="41babc3e64f09380f0db683d589523654ce213d8" translate="yes" xml:space="preserve">
          <source>A struct that keeps information about the test case.</source>
          <target state="translated">테스트 케이스에 대한 정보를 유지하는 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="977bdad55f17ecd8ee2f048b6fc658fc29753b9a" translate="yes" xml:space="preserve">
          <source>A struct that keeps information about the test.</source>
          <target state="translated">테스트에 대한 정보를 유지하는 구조체입니다.</target>
        </trans-unit>
        <trans-unit id="ac118fd8485fc091bbf3bccd439369617ac9e067" translate="yes" xml:space="preserve">
          <source>A supervisor is a process which supervises other processes, which we refer to as &lt;em&gt;child processes&lt;/em&gt;. Supervisors are used to build a hierarchical process structure called a &lt;em&gt;supervision tree&lt;/em&gt;. Supervision trees provide fault-tolerance and encapsulate how our applications start and shutdown.</source>
          <target state="translated">감독자는 다른 프로세스를 감독하는 프로세스로, 우리는 &lt;em&gt;자식 프로세스라고&lt;/em&gt; 합니다. 감독자는 &lt;em&gt;감독 트리&lt;/em&gt; 라고하는 계층 적 프로세스 구조를 구축하는 데 사용됩니다 . 감독 트리는 내결함성을 제공하고 애플리케이션 시작 및 종료 방법을 캡슐화합니다.</target>
        </trans-unit>
        <trans-unit id="55d0b2c21ea69ec921c9ed14e37c45764559b92c" translate="yes" xml:space="preserve">
          <source>A supervisor is a process which supervises other processes, which we refer to as child processes. The act of supervising a process includes three distinct responsibilities. The first one is to start child processes. Once a child process is running, the supervisor may restart a child process, either because it terminated abnormally or because a certain condition was reached. For example, a supervisor may restart all children if any child dies. Finally, a supervisor is also responsible for shutting down the child processes when the system is shutting down. Please see the &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;Supervisor&lt;/a&gt; module for a more in-depth discussion.</source>
          <target state="translated">감독자는 다른 프로세스를 감독하는 프로세스로, 우리는 자식 프로세스라고합니다. 프로세스를 감독하는 행위에는 세 가지 책임이 있습니다. 첫 번째는 자식 프로세스를 시작하는 것입니다. 하위 프로세스가 실행되면 수퍼바이저가 비정상적으로 종료되었거나 특정 조건에 도달하여 하위 프로세스를 다시 시작할 수 있습니다. 예를 들어, 감독관은 자녀가 사망하면 모든 자녀를 다시 시작할 수 있습니다. 마지막으로, 관리자는 시스템이 종료 될 때 자식 프로세스를 종료해야합니다. 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;Supervisor&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2148e1ac9ba1ddbf69713d1fe8062e24faf800f8" translate="yes" xml:space="preserve">
          <source>A supervisor is bound to the same name registration rules as a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Read more about these rules in the documentation for &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">감독자는 &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 와 동일한 이름 등록 규칙에 바인딩됩니다 . &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 설명서에서 이러한 규칙에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="789257e49c9248f0d549832ff687e69eea5012dc" translate="yes" xml:space="preserve">
          <source>A supervisor may be started directly with a list of children via &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; or you may define a module-based supervisor that implements the required callbacks. The sections below use &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; to start supervisors in most examples, but it also includes a specific section on module-based ones.</source>
          <target state="translated">수퍼바이저는 &lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; 를 통해 하위 목록으로 직접 시작 하거나 필요한 콜백을 구현하는 모듈 기반 수퍼바이저를 정의 할 수 있습니다. 아래 섹션 은 대부분의 예에서 &lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; 를 사용 하여 수퍼바이저를 시작하지만 모듈 기반 섹션에 대한 특정 섹션도 포함합니다.</target>
        </trans-unit>
        <trans-unit id="73975472006297ae3fcad167925a215d573e02d7" translate="yes" xml:space="preserve">
          <source>A supervisor restarts a child process depending on its &lt;code&gt;:restart&lt;/code&gt; configuration. For example, when &lt;code&gt;:restart&lt;/code&gt; is set to &lt;code&gt;:transient&lt;/code&gt;, the supervisor does not restart the child in case it exits with reason &lt;code&gt;:normal&lt;/code&gt;, &lt;code&gt;:shutdown&lt;/code&gt; or &lt;code&gt;{:shutdown, term}&lt;/code&gt;.</source>
          <target state="translated">감독자는 &lt;code&gt;:restart&lt;/code&gt; 구성 에 따라 하위 프로세스를 다시 시작 합니다. 예를 들어, &lt;code&gt;:restart&lt;/code&gt; 가 &lt;code&gt;:transient&lt;/code&gt; 로 설정 되면 수퍼바이저는 reason &lt;code&gt;:normal&lt;/code&gt; , &lt;code&gt;:shutdown&lt;/code&gt; 또는 &lt;code&gt;{:shutdown, term}&lt;/code&gt; 되는 경우 하위를 다시 시작하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="60c5977b15b358f6b78f3ae1aad052bb829be570" translate="yes" xml:space="preserve">
          <source>A supervisor that starts children dynamically.</source>
          <target state="translated">자식을 동적으로 시작하는 감독자.</target>
        </trans-unit>
        <trans-unit id="615c68fd3df9515609693344bfb85db4d952662a" translate="yes" xml:space="preserve">
          <source>A tag can be set for all tests in a module or describe block by setting &lt;code&gt;@moduletag&lt;/code&gt; or &lt;code&gt;@describetag&lt;/code&gt; inside each context respectively:</source>
          <target state="translated">각 컨텍스트 내에서 각각 &lt;code&gt;@moduletag&lt;/code&gt; 또는 &lt;code&gt;@describetag&lt;/code&gt; 를 설정하여 모듈 또는 describe 블록의 모든 테스트에 대해 태그를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0662f79c653f0ec45efdb5f488b2e4dad7e4bc27" translate="yes" xml:space="preserve">
          <source>A task needs to implement &lt;code&gt;run&lt;/code&gt; which receives a list of command line args.</source>
          <target state="translated">작업 은 명령 행 인수 목록을 수신하는 &lt;code&gt;run&lt;/code&gt; 을 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e97df0f46736141ff7a6d7cb0a21370015757093" translate="yes" xml:space="preserve">
          <source>A task supervisor is started with no children, often under a supervisor and a name:</source>
          <target state="translated">작업 감독자는 자식없이 시작하며 종종 감독자와 이름으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="ff48cedfb7c96d7c2ed5d2fcc23ecbe5aa13422a" translate="yes" xml:space="preserve">
          <source>A task supervisor is typically started under a supervision tree using the tuple format:</source>
          <target state="translated">작업 감독자는 일반적으로 튜플 형식을 사용하여 감독 트리에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="400405b3406f1f222a1d0498ff7d0e89bdd37f83" translate="yes" xml:space="preserve">
          <source>A task supervisor.</source>
          <target state="translated">작업 감독자.</target>
        </trans-unit>
        <trans-unit id="2894abc710a014ff1c5c80e21ac1103d9d069763" translate="yes" xml:space="preserve">
          <source>A term of type &lt;strong&gt;IO data&lt;/strong&gt; is a binary or a list containing bytes (integers in &lt;code&gt;0..255&lt;/code&gt;) or nested IO data. The type is recursive. Let's see an example of one of the possible IO data representing the binary &lt;code&gt;&quot;hello&quot;&lt;/code&gt;:</source>
          <target state="translated">&lt;strong&gt;IO 데이터&lt;/strong&gt; 유형의 용어는 바이트 ( &lt;code&gt;0..255&lt;/code&gt; 의 정수 ) 또는 중첩 된 IO 데이터를 포함하는 이진 또는 목록 입니다. 유형은 재귀 적입니다. 바이너리 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 를 나타내는 가능한 IO 데이터 중 하나의 예를 보자 .</target>
        </trans-unit>
        <trans-unit id="7c720a57b20bbb00d7cd6e1d7bb642e1d8d5947c" translate="yes" xml:space="preserve">
          <source>A test module can define multiple &lt;code&gt;setup&lt;/code&gt; and &lt;code&gt;setup_all&lt;/code&gt; callbacks, and they are invoked in order of appearance.</source>
          <target state="translated">테스트 모듈은 여러 개의 &lt;code&gt;setup&lt;/code&gt; 및 &lt;code&gt;setup_all&lt;/code&gt; 콜백을 정의 할 수 있으며 모양 순서대로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ec4945e7afe50419c6b9cae97faa15dec66d7711" translate="yes" xml:space="preserve">
          <source>A time unit can also be a strictly positive integer. In this case, it represents the &quot;parts per second&quot;: the time will be returned in &lt;code&gt;1 / parts_per_second&lt;/code&gt; seconds. For example, using the &lt;code&gt;:millisecond&lt;/code&gt; time unit is equivalent to using &lt;code&gt;1000&lt;/code&gt; as the time unit (as the time will be returned in 1/1000 seconds - milliseconds).</source>
          <target state="translated">시간 단위는 또한 양의 정수일 수 있습니다. 이 경우 &quot;초당 파트 수&quot;를 나타냅니다. 시간은 &lt;code&gt;1 / parts_per_second&lt;/code&gt; 초로 반환됩니다 . 예를 들어, &lt;code&gt;:millisecond&lt;/code&gt; 시간 단위를 사용 하는 것은 시간 단위로 &lt;code&gt;1000&lt;/code&gt; 을 사용하는 것과 같습니다 (시간은 1/1000 초-밀리 초로 반환 됨).</target>
        </trans-unit>
        <trans-unit id="f8027bb61ebc1be6167e83dd5aa3351e16405a8f" translate="yes" xml:space="preserve">
          <source>A timeout in milliseconds or &lt;code&gt;:infinity&lt;/code&gt;, can be given with a default value of &lt;code&gt;5000&lt;/code&gt;. If the timeout is exceeded, then the current process will exit. If the task process is linked to the current process which is the case when a task is started with &lt;code&gt;async&lt;/code&gt;, then the task process will also exit. If the task process is trapping exits or not linked to the current process, then it will continue to run.</source>
          <target state="translated">밀리 초 또는 &lt;code&gt;:infinity&lt;/code&gt; 의 시간 종료 는 기본값 &lt;code&gt;5000&lt;/code&gt; 으로 제공 될 수 있습니다 . 시간 초과가 초과되면 현재 프로세스가 종료됩니다. 작업 프로세스가 작업이 &lt;code&gt;async&lt;/code&gt; 로 시작된 경우 인 현재 프로세스에 링크 된 경우 작업 프로세스도 종료됩니다. 작업 프로세스가 종료되고 있거나 현재 프로세스에 연결되어 있지 않으면 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="198be1f82bcaf7ef6e87003105d7f1bb0913880a" translate="yes" xml:space="preserve">
          <source>A timeout of 0 can be given when you already expect the message to be in the mailbox.</source>
          <target state="translated">메시지가 이미 사서함에있을 것으로 예상되면 시간 초과 0이 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdda64adffbe29ce867f4e13216350c2cecaa35a" translate="yes" xml:space="preserve">
          <source>A timeout, in milliseconds or &lt;code&gt;:infinity&lt;/code&gt;, can be given with a default value of &lt;code&gt;5000&lt;/code&gt;.</source>
          <target state="translated">밀리 초 또는 &lt;code&gt;:infinity&lt;/code&gt; 의 시간 종료 는 기본값 &lt;code&gt;5000&lt;/code&gt; 으로 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68fd1acb1d049659698dd0e6399a2faf0bb992be" translate="yes" xml:space="preserve">
          <source>A timeout, in milliseconds or &lt;code&gt;:infinity&lt;/code&gt;, can be given with a default value of &lt;code&gt;5000&lt;/code&gt;. If the time runs out before a message from the task is received, this function will return &lt;code&gt;nil&lt;/code&gt; and the monitor will remain active. Therefore &lt;a href=&quot;#yield/2&quot;&gt;&lt;code&gt;yield/2&lt;/code&gt;&lt;/a&gt; can be called multiple times on the same task.</source>
          <target state="translated">밀리 초 또는 &lt;code&gt;:infinity&lt;/code&gt; 의 시간 종료 는 기본값 &lt;code&gt;5000&lt;/code&gt; 으로 제공 될 수 있습니다 . 작업에서 메시지를 받기 전에 시간이 부족하면이 기능은 &lt;code&gt;nil&lt;/code&gt; 을 반환 하고 모니터는 활성 상태를 유지합니다. 따라서 동일한 작업에서 &lt;a href=&quot;#yield/2&quot;&gt; &lt;code&gt;yield/2&lt;/code&gt; &lt;/a&gt; 를 여러 번 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d0d4ddbed899c477cc9f6352b9a36db821efe20" translate="yes" xml:space="preserve">
          <source>A trailing bang (exclamation mark) signifies a function or macro where failure cases raise an exception.</source>
          <target state="translated">후행 뱅 (느낌표)은 실패 사례가 예외를 발생시키는 기능 또는 매크로를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="595193044562313fed22c09af41ccc775c92d1e5" translate="yes" xml:space="preserve">
          <source>A translator is simply a tuple containing a module and a function that can be added and removed via the &lt;a href=&quot;logger#add_translator/1&quot;&gt;&lt;code&gt;Logger.add_translator/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;logger#remove_translator/1&quot;&gt;&lt;code&gt;Logger.remove_translator/1&lt;/code&gt;&lt;/a&gt; functions and is invoked for every Erlang message above the minimum log level with four arguments:</source>
          <target state="translated">변환기는 단순히 모듈과 &lt;a href=&quot;logger#add_translator/1&quot;&gt; &lt;code&gt;Logger.add_translator/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;logger#remove_translator/1&quot;&gt; &lt;code&gt;Logger.remove_translator/1&lt;/code&gt; &lt;/a&gt; 함수 를 통해 추가 및 제거 할 수있는 기능을 포함하는 튜플이며, 네 개의 인수를 사용하여 최소 로그 레벨 이상의 모든 Erlang 메시지에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="977fa89e1a9a5fcdc6a2202879cd6a99f38e175d" translate="yes" xml:space="preserve">
          <source>A tuple may contain elements of different types, which are stored contiguously in memory. Accessing any element takes constant time, but modifying a tuple, which produces a shallow copy, takes linear time. Tuples are good for reading data while lists are better for traversals.</source>
          <target state="translated">튜플은 메모리에 연속적으로 저장된 다른 유형의 요소를 포함 할 수 있습니다. 요소에 액세스하는 데는 시간이 걸리지 만 얕은 복사본을 생성하는 튜플을 수정하면 선형 시간이 걸립니다. 튜플은 데이터를 읽는 데 좋고리스트는 순회에 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3b70a1f3c40082637faa4be4833ceb4685eae005" translate="yes" xml:space="preserve">
          <source>A type defined with &lt;code&gt;@typep&lt;/code&gt; is private. An opaque type, defined with &lt;code&gt;@opaque&lt;/code&gt; is a type where the internal structure of the type will not be visible, but the type is still public.</source>
          <target state="translated">&lt;code&gt;@typep&lt;/code&gt; 로 정의 된 유형 은 개인용입니다. &lt;code&gt;@opaque&lt;/code&gt; 로 정의 된 불투명 한 형식 은 형식의 내부 구조가 보이지 않지만 형식은 여전히 ​​공용 인 형식입니다.</target>
        </trans-unit>
        <trans-unit id="8d3bd389baf78dba20b0d8db318aee60b33e011c" translate="yes" xml:space="preserve">
          <source>A value to be associated with this registration must also be given. This value will be retrieved whenever dispatching or doing a key lookup.</source>
          <target state="translated">이 등록과 관련된 값도 제공해야합니다. 이 값은 디스패치하거나 키 조회를 수행 할 때마다 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="e27b2906462bb426d4db8b9c875eb3719eb195a6" translate="yes" xml:space="preserve">
          <source>A variable assigned inside a function does not affect its surrounding environment:</source>
          <target state="translated">함수 내부에 지정된 변수는 주변 환경에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eefe91c5b1f2dca4795e8c30b3e66948a135ee4c" translate="yes" xml:space="preserve">
          <source>A variable can only be assigned on the left side of &lt;code&gt;=&lt;/code&gt;:</source>
          <target state="translated">변수는 &lt;code&gt;=&lt;/code&gt; 의 왼쪽에만 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc60d48fd93ed889b691c632db601f39d5eb520c" translate="yes" xml:space="preserve">
          <source>A version is a string in a specific format or a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; generated after parsing via &lt;a href=&quot;version#parse/1&quot;&gt;&lt;code&gt;Version.parse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전은 특정 형식의 문자열이거나 &lt;a href=&quot;version#parse/1&quot;&gt; &lt;code&gt;Version.parse/1&lt;/code&gt; 을&lt;/a&gt; 통해 구문 분석 한 후 생성 된 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9ddca9755179e1f59903c4ddf6f15ddbb4628e05" translate="yes" xml:space="preserve">
          <source>A warning will be printed on missing assigns. Future versions will raise.</source>
          <target state="translated">누락 된 어사 인에 경고가 인쇄됩니다. 향후 버전이 올라갈 것입니다.</target>
        </trans-unit>
        <trans-unit id="8ca63c80632d0cf1aa32c53e95d09843a1d1dd72" translate="yes" xml:space="preserve">
          <source>A word on distributed agents</source>
          <target state="translated">분산 에이전트에 대한 단어</target>
        </trans-unit>
        <trans-unit id="be1bb8f888ee7021de890698fb2afa717b6c1550" translate="yes" xml:space="preserve">
          <source>ACC - total time spent in the function</source>
          <target state="translated">ACC-함수에 소요 된 총 시간</target>
        </trans-unit>
        <trans-unit id="586d4163da04d5ab6791e3c06e9ffe5c9db509ec" translate="yes" xml:space="preserve">
          <source>ANSI escapes in &lt;code&gt;string&lt;/code&gt; are not processed in any way.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; ANSI 이스케이프는 어떤 식으로도 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="08955ef48e12709a927739991a3df46487d19807" translate="yes" xml:space="preserve">
          <source>API for reading config files defined with &lt;a href=&quot;config&quot;&gt;&lt;code&gt;Config&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정의 설정 파일 읽기위한 API &lt;a href=&quot;config&quot;&gt; &lt;code&gt;Config&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b349aa6f5c8405e74e0ce2c3f7201bebe1b4de3" translate="yes" xml:space="preserve">
          <source>AST considerations</source>
          <target state="translated">AST 고려 사항</target>
        </trans-unit>
        <trans-unit id="722e9952d5c095e4d71bce17445a76597f676acc" translate="yes" xml:space="preserve">
          <source>AST representation</source>
          <target state="translated">AST 표현</target>
        </trans-unit>
        <trans-unit id="266c0ed1029b1e5c3251173a36c9d608b25b8d14" translate="yes" xml:space="preserve">
          <source>Aborts when a command exits with a non-zero status.</source>
          <target state="translated">명령이 0이 아닌 상태로 종료되면 중단합니다.</target>
        </trans-unit>
        <trans-unit id="fff456f1c782da0b35f8fa5b303ce271025c27f6" translate="yes" xml:space="preserve">
          <source>Abstract Syntax Tree (AST)</source>
          <target state="translated">추상 구문 트리 (AST)</target>
        </trans-unit>
        <trans-unit id="16d98934b253153ce90ef5967a4ab32ed934fb4d" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;ignore: :whitespace&lt;/code&gt; option which will ignore all the whitespace characters in the input string.</source>
          <target state="translated">입력 문자열의 모든 공백 문자를 무시하는 &lt;code&gt;ignore: :whitespace&lt;/code&gt; 옵션을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="ff9572ac36a4e1f1c2d3b6e7fe1206f556bcd6be" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;padding: false&lt;/code&gt; option which will ignore padding from the input string.</source>
          <target state="translated">&lt;code&gt;padding: false&lt;/code&gt; 옵션을 허용 합니다. 입력 문자열에서 패딩을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="e6606a70939f51500cf29d0104ea455b8e57bbbd" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;padding: false&lt;/code&gt; option which will omit padding from the output string.</source>
          <target state="translated">&lt;code&gt;padding: false&lt;/code&gt; 허용 : 출력 문자열에서 패딩을 생략하는 false 옵션.</target>
        </trans-unit>
        <trans-unit id="d11f73644b7b3add855698ef69a041b85cac741e" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;relative_to&lt;/code&gt; as an argument to tell where the file is located.</source>
          <target state="translated">&lt;code&gt;relative_to&lt;/code&gt; 를 인수로 받아 들여 파일의 위치를 ​​알려줍니다.</target>
        </trans-unit>
        <trans-unit id="312c5b592fe6d7dd571d6c8037a1f4c663f75282" translate="yes" xml:space="preserve">
          <source>Accepts &lt;code&gt;relative_to&lt;/code&gt; as an argument to tell where the file is located. If the file was already required, &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; doesn't do anything and returns &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;relative_to&lt;/code&gt; 를 인수로 받아 들여 파일의 위치를 ​​알려줍니다. 파일이 이미 필요한 경우 &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; 는 아무것도하지 않고 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0a8f51a20bef3da7c165ebe3b333dbb26c7d054f" translate="yes" xml:space="preserve">
          <source>Accepts a block or the name of a one-arity function in the form of an atom, or a list of such atoms.</source>
          <target state="translated">원자 또는 그러한 원자 목록의 형태로 단일 배열 함수의 블록 또는 이름을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="8001c91fcbcc7035c433992b44685f5330523f6b" translate="yes" xml:space="preserve">
          <source>Accepts a module or a &lt;code&gt;{module, function_name}&lt;/code&gt; tuple. See the &quot;Compile callbacks&quot; section below.</source>
          <target state="translated">모듈 또는 &lt;code&gt;{module, function_name}&lt;/code&gt; 튜플을 승인합니다 . 아래의 &quot;컴파일 콜백&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c68ab20eebd551a8183d8a271c2a11f2f59f798e" translate="yes" xml:space="preserve">
          <source>Accepts a module or a &lt;code&gt;{module, function_name}&lt;/code&gt; tuple. The function must take 6 arguments:</source>
          <target state="translated">모듈 또는 &lt;code&gt;{module, function_name}&lt;/code&gt; 튜플을 승인합니다 . 이 함수는 6 개의 인수를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="7bebfa805f9fa42810edbee6281c1119c222c690" translate="yes" xml:space="preserve">
          <source>Accepts a module or a &lt;code&gt;{module, function_name}&lt;/code&gt; tuple. The function must take two arguments: the module environment and its bytecode. When just a module is provided, the function is assumed to be &lt;code&gt;__after_compile__/2&lt;/code&gt;.</source>
          <target state="translated">모듈 또는 &lt;code&gt;{module, function_name}&lt;/code&gt; 튜플을 승인합니다 . 함수는 모듈 환경과 바이트 코드의 두 가지 인수를 가져야합니다. 모듈 만 제공되는 경우 함수는 &lt;code&gt;__after_compile__/2&lt;/code&gt; 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e8eec1dc724492ff94d0553bb6ff5b22253d396" translate="yes" xml:space="preserve">
          <source>Accepts a module or a &lt;code&gt;{module, function_or_macro_name}&lt;/code&gt; tuple. The function/macro must take one argument: the module environment. If it's a macro, its returned value will be injected at the end of the module definition before the compilation starts.</source>
          <target state="translated">모듈 또는 &lt;code&gt;{module, function_or_macro_name}&lt;/code&gt; 튜플을 승인합니다 . 함수 / 매크로는 모듈 환경이라는 하나의 인수를 취해야합니다. 매크로 인 경우 컴파일이 시작되기 전에 반환 된 값이 모듈 정의의 끝에 주입됩니다.</target>
        </trans-unit>
        <trans-unit id="b8a02787b1528282c9b913825c8890849c97b169" translate="yes" xml:space="preserve">
          <source>Accepts a string (often a heredoc) or &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;@doc false&lt;/code&gt; will make the entity invisible to documentation extraction tools like &lt;a href=&quot;https://hexdocs.pm/ex_doc/&quot;&gt;&lt;code&gt;ExDoc&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">&lt;code&gt;@doc false&lt;/code&gt; 를 사용하면 &lt;a href=&quot;https://hexdocs.pm/ex_doc/&quot;&gt; &lt;code&gt;ExDoc&lt;/code&gt; &lt;/a&gt; 과 같은 문서 추출 도구에서 엔티티를 볼 수 없게 되는 문자열 ( 여기서는 heredoc ) 또는 &lt;code&gt;false&lt;/code&gt; 를 허용합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e201112d9033197e821f8bcdf23e660e950b4fd3" translate="yes" xml:space="preserve">
          <source>Accepts a string (often a heredoc) or &lt;code&gt;false&lt;/code&gt; where &lt;code&gt;@moduledoc false&lt;/code&gt; will make the module invisible to documentation extraction tools like &lt;a href=&quot;https://hexdocs.pm/ex_doc/&quot;&gt;&lt;code&gt;ExDoc&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@moduledoc false&lt;/code&gt; 를 사용하면 &lt;a href=&quot;https://hexdocs.pm/ex_doc/&quot;&gt; &lt;code&gt;ExDoc&lt;/code&gt; &lt;/a&gt; 과 같은 문서 추출 도구에서 모듈을 볼 수 없는 문자열 ( 여기서는 heredoc ) 또는 &lt;code&gt;false&lt;/code&gt; 를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="a5cd37e51e05c989f61c56fcc8057339b69ee344" translate="yes" xml:space="preserve">
          <source>Accepts an &lt;code&gt;amount_to_add&lt;/code&gt; in any &lt;code&gt;unit&lt;/code&gt; available from &lt;a href=&quot;system#t:time_unit/0&quot;&gt;&lt;code&gt;System.time_unit/0&lt;/code&gt;&lt;/a&gt;. Negative values will move backwards in time.</source>
          <target state="translated">&lt;a href=&quot;system#t:time_unit/0&quot;&gt; &lt;code&gt;System.time_unit/0&lt;/code&gt; &lt;/a&gt; 에서 사용 가능한 모든 &lt;code&gt;unit&lt;/code&gt; 로 &lt;code&gt;amount_to_add&lt;/code&gt; 를 승인합니다 . 음수 값은 시간이 지나면 뒤로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="9c7e182b3105eb309155a16cd4d01036199f0e2d" translate="yes" xml:space="preserve">
          <source>Accepts an atom, a tuple, or a list of atoms and tuples. For example:</source>
          <target state="translated">원자, 튜플 또는 원자 및 튜플 목록을 승인합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e6f11dba90273a10068990877edcdfb26f22547" translate="yes" xml:space="preserve">
          <source>Accepts the function name (as an atom) of a function in the current module or &lt;code&gt;{function_name, 0}&lt;/code&gt; tuple where &lt;code&gt;function_name&lt;/code&gt; is the name of a function in the current module. The function must be public and have an arity of 0 (no arguments). If the function does not return &lt;code&gt;:ok&lt;/code&gt;, the loading of the module will be aborted. For example:</source>
          <target state="translated">현재 모듈 또는 &lt;code&gt;{function_name, 0}&lt;/code&gt; 튜플에서 &lt;code&gt;function_name&lt;/code&gt; 의 함수 이름 (원자)을 승인합니다. 여기서 function_name 은 현재 모듈의 함수 이름입니다. 이 함수는 public이어야하고 arity가 0이어야합니다 (인수 없음). 함수가 &lt;code&gt;:ok&lt;/code&gt; 를 반환하지 않으면 모듈 로딩이 중단됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f81a22de0af5e9eab19326e19693f86ce612518" translate="yes" xml:space="preserve">
          <source>Access</source>
          <target state="translated">Access</target>
        </trans-unit>
        <trans-unit id="61eeb1ced62d9d70c3a7da771b7e65111efa9eeb" translate="yes" xml:space="preserve">
          <source>Access &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">액세스 &lt;small&gt;행동&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="32cc0e2e72b4a5cd8e1d10f3088022c273757f9c" translate="yes" xml:space="preserve">
          <source>Access syntax</source>
          <target state="translated">액세스 구문</target>
        </trans-unit>
        <trans-unit id="ffaea95d2c8c2a121901ac8053918362a2259c0d" translate="yes" xml:space="preserve">
          <source>Accesses an already bound variable in match clauses. Also known as the pin operator.</source>
          <target state="translated">match 절에서 이미 바인딩 된 변수에 액세스합니다. 핀 연산자라고도합니다.</target>
        </trans-unit>
        <trans-unit id="114bded9b29083adea70f97a0e2b9cca28f2f55b" translate="yes" xml:space="preserve">
          <source>Accessing and updating structs</source>
          <target state="translated">구조체 접근 및 업데이트</target>
        </trans-unit>
        <trans-unit id="778701a39f61d1d0d376ec6add6756493d3c6f48" translate="yes" xml:space="preserve">
          <source>Accessing the stacktrace outside of a rescue/catch is deprecated. If you want to support only Elixir v1.7+, you must access &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; inside a rescue/catch. If you want to support earlier Elixir versions, move &lt;a href=&quot;system#stacktrace/0&quot;&gt;&lt;code&gt;System.stacktrace/0&lt;/code&gt;&lt;/a&gt; inside a rescue/catch.</source>
          <target state="translated">구조 / 캐치 외부의 스택 추적에 액세스하는 것은 더 이상 사용되지 않습니다. Elixir v1.7 + 만 지원하려면 복구 / 캐치 내의 &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt; 액세스해야합니다 . 이전 Elixir 버전을 지원하려면 복구 / 캐치 내에서 &lt;a href=&quot;system#stacktrace/0&quot;&gt; &lt;code&gt;System.stacktrace/0&lt;/code&gt; 을&lt;/a&gt; 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="c08435b6ee1c53e0f3db32fa2d67cb282966fb48" translate="yes" xml:space="preserve">
          <source>According to the failure message, we are expecting that the bucket no longer exists on the table, but it still does! This problem is the opposite of the one we have just solved: while previously there was a delay between the command to create a bucket and updating the table, now there is a delay between the bucket process dying and its entry being removed from the table. Since this is a race condition, you may not be able to reproduce it on your machine, but it is there.</source>
          <target state="translated">실패 메시지에 따르면 버킷이 더 이상 테이블에 존재하지 않을 것으로 예상되지만 여전히 존재합니다! 이 문제는 방금 해결 한 것과 반대입니다. 이전에는 버킷을 생성하는 명령과 테이블을 업데이트하는 명령 사이에 지연이 있었지만 이제 버킷 프로세스 종료와 해당 항목이 테이블에서 제거되는 사이에 지연이있었습니다. 이것은 경쟁 조건이므로 컴퓨터에서 재현 할 수 없지만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f82c99de451613d4c3468e6d7fc04fc56efcc179" translate="yes" xml:space="preserve">
          <source>Actually expands to:</source>
          <target state="translated">실제로 다음과 같이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="9e4e792ab5793275266dbf12ecb483ea47d35fb1" translate="yes" xml:space="preserve">
          <source>Adding explicit parentheses is enough to bind the block to &lt;code&gt;if&lt;/code&gt;:</source>
          <target state="translated">명시 적 괄호를 추가 &lt;code&gt;if&lt;/code&gt; 다음 과 같은 경우에 블록을 바인딩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be05b1119a34ef95ba3623420677cc256aa4984b" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;a href=&quot;macro#to_string/2&quot;&gt;&lt;code&gt;Macro.to_string/2&lt;/code&gt;&lt;/a&gt; will translate all occurrences of this AST to &lt;code&gt;left not in right&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;macro#to_string/2&quot;&gt; &lt;code&gt;Macro.to_string/2&lt;/code&gt; &lt;/a&gt; 는이 AST의 모든 항목을 &lt;code&gt;left not in right&lt;/code&gt; 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="084086258188a6f83f3c0621f1d91c6afb01428b" translate="yes" xml:space="preserve">
          <source>Additionally, the following functions and operators for lists are found in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">또한 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 에는 다음과 같은 목록의 함수와 연산자가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b78d4c95ca68cd548509bceede9d001db1a210fc" translate="yes" xml:space="preserve">
          <source>Additionally, the following scope values can be configured:</source>
          <target state="translated">또한 다음 범위 값을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edc18d92bf1b07aac7b2b79037d7ed0c830219fc" translate="yes" xml:space="preserve">
          <source>Adds a child specification to &lt;code&gt;supervisor&lt;/code&gt; and starts that child.</source>
          <target state="translated">&lt;code&gt;supervisor&lt;/code&gt; 에게 자식 사양을 추가하고 해당 자식을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="af3a79b1bbb83ca34755ad54eebe67e43975dc73" translate="yes" xml:space="preserve">
          <source>Adds a new backend.</source>
          <target state="translated">새로운 백엔드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4547e3e08756cb2ef5ae23175de234a94738c653" translate="yes" xml:space="preserve">
          <source>Adds a new translator.</source>
          <target state="translated">새 번역기를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9653b7fdeddd56fa913d9c1e6e4dd46142fe6bb5" translate="yes" xml:space="preserve">
          <source>Adds a specified amount of time to a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 시간을 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 에&lt;/a&gt; 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="0fefe8eff4657ca8af82a86c4c01dcdded8f65fb" translate="yes" xml:space="preserve">
          <source>Adds a specified amount of time to a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 시간을 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; 에&lt;/a&gt; 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="b33fc73fd1c20e1aa238dde8be82279974905542" translate="yes" xml:space="preserve">
          <source>Adds the &lt;code&gt;number&lt;/code&gt; of &lt;code&gt;unit&lt;/code&gt;s to the given &lt;code&gt;time&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;time&lt;/code&gt; 에 &lt;code&gt;unit&lt;/code&gt; &lt;code&gt;number&lt;/code&gt; 를 더 합니다 .</target>
        </trans-unit>
        <trans-unit id="ad9a4469809cf0d6f045e57922aa36fef739da3f" translate="yes" xml:space="preserve">
          <source>Adds the number of days to the given &lt;code&gt;date&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;date&lt;/code&gt; 에 일 수를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="789089ca60682ff54ac072e501a17b9c7a45b283" translate="yes" xml:space="preserve">
          <source>Adopting a behaviour is straightforward:</source>
          <target state="translated">행동을 채택하는 것은 간단합니다 :</target>
        </trans-unit>
        <trans-unit id="3aa1232b05d45b3e4a3b9d5865607daf60ef5d9b" translate="yes" xml:space="preserve">
          <source>Adopting behaviours</source>
          <target state="translated">행동 채택</target>
        </trans-unit>
        <trans-unit id="79ba5e1b3f99abfd54ef8d839ba12bd2ac4d79cb" translate="yes" xml:space="preserve">
          <source>After</source>
          <target state="translated">After</target>
        </trans-unit>
        <trans-unit id="9ffdfdf4928b7893065d8f9388d98cfc7e4718e4" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;IO.write/2&lt;/code&gt;, we can see the request sent by the &lt;code&gt;IO&lt;/code&gt; module (a four-elements tuple) printed out. Soon after that, we see that it fails since the &lt;code&gt;IO&lt;/code&gt; module expected some kind of result, which we did not supply.</source>
          <target state="translated">&lt;code&gt;IO.write/2&lt;/code&gt; 후에 는 &lt;code&gt;IO&lt;/code&gt; 모듈 (4 요소 튜플)이 보낸 요청이 인쇄 된 것을 볼 수 있습니다. 그 후 곧 우리는 &lt;code&gt;IO&lt;/code&gt; 모듈이 우리가 제공하지 않은 어떤 종류의 결과를 기대 했기 때문에 실패한다는 것을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="83a04e6c0b27ee981def4e7b4af06e562bbb3d2e" translate="yes" xml:space="preserve">
          <source>After a module is compiled, using many of the functions in this module will raise errors, since it is out of their scope to inspect runtime data. Most of the runtime data can be inspected via the &lt;a href=&quot;module#c:__info__/1&quot;&gt;&lt;code&gt;__info__/1&lt;/code&gt;&lt;/a&gt; function attached to each compiled module.</source>
          <target state="translated">모듈이 컴파일 된 후이 모듈의 많은 함수를 사용하면 런타임 데이터를 검사 할 수있는 범위를 벗어나므로 오류가 발생합니다. 대부분의 런타임 데이터는 컴파일 된 각 모듈에 연결된 &lt;a href=&quot;module#c:__info__/1&quot;&gt; &lt;code&gt;__info__/1&lt;/code&gt; &lt;/a&gt; 함수 를 통해 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6dcdc4f162ba136a3bc34f25783a0a1ec25d1f72" translate="yes" xml:space="preserve">
          <source>After calling this function, &lt;code&gt;shell&lt;/code&gt; becomes the shell that is returned by &lt;a href=&quot;#shell/0&quot;&gt;&lt;code&gt;shell/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수를 호출 한 후 &lt;code&gt;shell&lt;/code&gt; 은 &lt;a href=&quot;#shell/0&quot;&gt; &lt;code&gt;shell/0&lt;/code&gt; 에&lt;/a&gt; 의해 반환되는 쉘이 됩니다.</target>
        </trans-unit>
        <trans-unit id="015771d68b1b737818fe24be939749860bc0bbd0" translate="yes" xml:space="preserve">
          <source>After closing the pair, zero or more ASCII letters can be given as a modifier. Sigils are expressed as non-qualified calls prefixed with &lt;code&gt;sigil_&lt;/code&gt; where the first argument is the sigil contents as a string and the second argument is a list of integers as modifiers:</source>
          <target state="translated">쌍을 닫은 후 0 개 이상의 ASCII 문자를 수정 자로 지정할 수 있습니다. 비공 호출 접두사로서 Sigils 표현된다 &lt;code&gt;sigil_&lt;/code&gt; 첫 번째 인수는 문자열과 상기 제 인수로 인장 내용이 개질제로서 정수의 목록이다 :</target>
        </trans-unit>
        <trans-unit id="08a92d7d688a663eb3eb033ee1302c04449e9c25" translate="yes" xml:space="preserve">
          <source>After getting familiar with the basics of the language you may want to try writing simple programs. This can be accomplished by putting the following Elixir code into a file:</source>
          <target state="translated">언어의 기본에 익숙해지면 간단한 프로그램을 작성해 볼 수 있습니다. 다음과 같은 Elixir 코드를 파일에 넣으면됩니다.</target>
        </trans-unit>
        <trans-unit id="01d3a5404436a56254e32994bb8c7a88df4d1e46" translate="yes" xml:space="preserve">
          <source>After sending those two messages, we invoked the IEx helper &lt;code&gt;flush()&lt;/code&gt;, which printed all messages received from the port, in this case we got &quot;hello&quot; and &quot;world&quot; back. Notice the messages are in binary because we passed the &lt;code&gt;:binary&lt;/code&gt; option when opening the port in &lt;a href=&quot;port#open/2&quot;&gt;&lt;code&gt;Port.open/2&lt;/code&gt;&lt;/a&gt;. Without such option, it would have yielded a list of bytes.</source>
          <target state="translated">이 두 메시지를 보낸 후 포트에서받은 모든 메시지를 인쇄 한 IEx 도우미 &lt;code&gt;flush()&lt;/code&gt; 호출 했습니다.이 경우 &quot;hello&quot;와 &quot;world&quot;가 다시 나타납니다. &lt;a href=&quot;port#open/2&quot;&gt; &lt;code&gt;Port.open/2&lt;/code&gt; &lt;/a&gt; 에서 포트를 열 때 &lt;code&gt;:binary&lt;/code&gt; 옵션을 전달했기 때문에 메시지가 바이너리로 되어 있습니다 . 이러한 옵션이 없으면 바이트 목록이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d8c5a6d820a4e4b08554b8cba7d6f0f399ab90d4" translate="yes" xml:space="preserve">
          <source>After the child specification is retrieved, the fields on &lt;code&gt;overrides&lt;/code&gt; are directly applied on the child spec. If &lt;code&gt;overrides&lt;/code&gt; has keys that do not map to any child specification field, an error is raised.</source>
          <target state="translated">하위 스펙을 검색 한 후 &lt;code&gt;overrides&lt;/code&gt; 의 필드 가 하위 스펙에 직접 적용됩니다. 경우 &lt;code&gt;overrides&lt;/code&gt; 하위 사양 필드에 매핑되지 않는 키가 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1e6e228112ef9b4259dcc6e0928e5df6bda71427" translate="yes" xml:space="preserve">
          <source>After the parsing is done, we will update our server to dispatch the parsed commands to the &lt;code&gt;:kv&lt;/code&gt; application we built previously.</source>
          <target state="translated">구문 분석이 완료되면 서버를 업데이트하여 구문 분석 된 명령을 이전에 빌드 한 &lt;code&gt;:kv&lt;/code&gt; 응용 프로그램 으로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="126c87f3f297e14cbbd86077daaca606cae164a1" translate="yes" xml:space="preserve">
          <source>After the port was created, we sent it two commands in the form of messages using &lt;a href=&quot;kernel#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt;. The first command has the binary payload of &quot;hello&quot; and the second has &quot;world&quot;.</source>
          <target state="translated">포트가 생성 된 후 &lt;a href=&quot;kernel#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; 를&lt;/a&gt; 사용하여 메시지 형태로 두 개의 명령을 보냈습니다 . 첫 번째 명령에는 &quot;hello&quot;라는 이진 페이로드가 있고 두 번째 명령에는 &quot;world&quot;가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a727cf7abfa15b42a8b410dabb9bf09752b2748" translate="yes" xml:space="preserve">
          <source>After the supervisor retrieves all child specifications, it proceeds to start its children one by one, in the order they were defined, using the information in the &lt;code&gt;:start&lt;/code&gt; key in the child specification. For our current specification, it will call &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt;.</source>
          <target state="translated">수퍼바이저는 모든 하위 사양을 검색 한 후 하위 사양의 &lt;code&gt;:start&lt;/code&gt; 키에있는 정보를 사용하여 정의 된 순서대로 하위를 하나씩 시작 합니다. 현재 사양에서는 &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="5ae1d560c6b4b698d633609ab136df680bf93a49" translate="yes" xml:space="preserve">
          <source>After the two import calls above, only &lt;a href=&quot;list#keyfind/4&quot;&gt;&lt;code&gt;List.keyfind/4&lt;/code&gt;&lt;/a&gt; will be imported.</source>
          <target state="translated">위의 두 번의 가져 오기 호출 후 &lt;a href=&quot;list#keyfind/4&quot;&gt; &lt;code&gt;List.keyfind/4&lt;/code&gt; &lt;/a&gt; 만 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="5d98e7e2a0b904bdc0ce797580a3b0c7291ef112" translate="yes" xml:space="preserve">
          <source>After this function is called, &lt;code&gt;port&lt;/code&gt; will be returned by &lt;a href=&quot;#default_port/1&quot;&gt;&lt;code&gt;default_port/1&lt;/code&gt;&lt;/a&gt; for the given scheme &lt;code&gt;scheme&lt;/code&gt;. Note that this function changes the default port for the given &lt;code&gt;scheme&lt;/code&gt;&lt;em&gt;globally&lt;/em&gt;, meaning for every application.</source>
          <target state="translated">이 함수가 호출 된 후 주어진 체계 &lt;code&gt;scheme&lt;/code&gt; 대해 &lt;code&gt;port&lt;/code&gt; 는 &lt;a href=&quot;#default_port/1&quot;&gt; &lt;code&gt;default_port/1&lt;/code&gt; &lt;/a&gt; 에 의해 리턴됩니다 . 이 함수는 주어진 &lt;code&gt;scheme&lt;/code&gt; 의 기본 포트를 &lt;em&gt;전역 적으로&lt;/em&gt; 변경하므로 모든 응용 프로그램에 적용됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ce2e6f40299204d94dfc0abf19fa8ab52d6c211" translate="yes" xml:space="preserve">
          <source>Agent</source>
          <target state="translated">Agent</target>
        </trans-unit>
        <trans-unit id="64acf7e2a7590f731f683acd7aa2c04794d8cfee" translate="yes" xml:space="preserve">
          <source>Agents</source>
          <target state="translated">Agents</target>
        </trans-unit>
        <trans-unit id="42dff267934990ba61a679256d1501706a0e086a" translate="yes" xml:space="preserve">
          <source>Agents are a simple abstraction around state.</source>
          <target state="translated">에이전트는 상태에 대한 간단한 추상화입니다.</target>
        </trans-unit>
        <trans-unit id="471de3b97e03acd6d8c9e778e9edad48b7ff717f" translate="yes" xml:space="preserve">
          <source>Agents provide a segregation between the client and server APIs (similar to &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;s). In particular, the functions passed as arguments to the calls to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; functions are invoked inside the agent (the server). This distinction is important because you may want to avoid expensive operations inside the agent, as they will effectively block the agent until the request is fulfilled.</source>
          <target state="translated">에이전트는 클라이언트와 서버 API ( &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 와 유사)를 분리 합니다. 특히 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; 함수 호출에 인수로 전달 된 함수는 에이전트 (서버) 내부에서 호출됩니다. 이 구별은 요청이 이행 될 때까지 에이전트를 효과적으로 차단하므로 에이전트 내부에서 값 비싼 조작을 피할 수 있기 때문에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="e95c6b8e92e1e60f6213d7958b0da2f180bb6e84" translate="yes" xml:space="preserve">
          <source>Alias shortcut</source>
          <target state="translated">별명 단축키</target>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes" xml:space="preserve">
          <source>Aliases</source>
          <target state="translated">Aliases</target>
        </trans-unit>
        <trans-unit id="d5851935f3ef549bdaa12137353f49d219f63837" translate="yes" xml:space="preserve">
          <source>Aliases are constructs that expand to atoms at compile-time. The alias &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; expands to the atom &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt;. Aliases must start with an ASCII uppercase character which may be followed by any ASCII letter, number, or underscore. Non-ASCII characters are not supported in aliases.</source>
          <target state="translated">별칭은 컴파일 타임에 원자로 확장되는 구문입니다. 별명 &lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 은 atom &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt; 으로 확장됩니다 . 별명은 ASCII 대문자로 시작해야하며 뒤에 ASCII 문자, 숫자 또는 밑줄이 올 수 있습니다. 비 ASCII 문자는 별명에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7f30b783a5f1e139f6a5d96cc53a7d69f34c844f" translate="yes" xml:space="preserve">
          <source>Aliases are expanded (if possible) and return atoms</source>
          <target state="translated">별명 확장 (가능한 경우) 및 원자 반환</target>
        </trans-unit>
        <trans-unit id="4a6b274949d1238578afe2d23ab6b398292dddae" translate="yes" xml:space="preserve">
          <source>Aliases are frequently used to define shortcuts. In fact, calling &lt;code&gt;alias&lt;/code&gt; without an &lt;code&gt;:as&lt;/code&gt; option sets the alias automatically to the last part of the module name, for example:</source>
          <target state="translated">별칭은 바로 가기를 정의하는 데 자주 사용됩니다. 실제로 &lt;code&gt;:as&lt;/code&gt; 옵션 없이 &lt;code&gt;alias&lt;/code&gt; 를 호출 하면 다음과 같이 별명이 모듈 이름의 마지막 부분으로 자동 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="47bc7db39f959bb0d4762319a37898eaad71d649" translate="yes" xml:space="preserve">
          <source>Aliases are represented by an &lt;code&gt;__aliases__&lt;/code&gt; call with each segment separated by dot as an argument:</source>
          <target state="translated">별명은 인수로 점으로 구분 된 각 세그먼트와 함께 &lt;code&gt;__aliases__&lt;/code&gt; 호출로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e23b34bcabd70da598f18dfcddb8220122d3216a" translate="yes" xml:space="preserve">
          <source>Aliases are shortcuts or tasks specific to the current project.</source>
          <target state="translated">별칭은 현재 프로젝트와 관련된 바로 가기 또는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="dc86688ecfcf9059408582f98b57b9f4cbad8152" translate="yes" xml:space="preserve">
          <source>Aliases can be used very powerfully to also run Elixir scripts and shell commands, for example:</source>
          <target state="translated">Alixir 스크립트와 쉘 명령을 실행하기 위해 별칭을 매우 강력하게 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6dd7a63c3cd9394fafd3a4d7cedc21c8e943565f" translate="yes" xml:space="preserve">
          <source>Aliases defined in the current project do not affect its dependencies and aliases defined in dependencies are not accessible from the current project.</source>
          <target state="translated">현재 프로젝트에 정의 된 별칭은 해당 종속성에 영향을 미치지 않으며 종속성에 정의 된 별칭은 현재 프로젝트에서 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="abd1a8b6bae9484ed0f8605fb305658910cefe92" translate="yes" xml:space="preserve">
          <source>Aliases expand to atoms because in the Erlang</source>
          <target state="translated">Erlang에서 별칭은 원자로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="f82ba68692bccb420e6f34813f0fa1ce8af8c883" translate="yes" xml:space="preserve">
          <source>Aliases inside quote are hygienic by default. Consider the following example:</source>
          <target state="translated">인용 부호 안의 별칭은 기본적으로 위생적입니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="fb42d78167a0f8c042ef1bf76a5e556ce9a643e9" translate="yes" xml:space="preserve">
          <source>Aliases may also be lists, specifying multiple tasks to be run consecutively:</source>
          <target state="translated">여러 작업을 연속적으로 실행하도록 지정하여 별칭을 목록으로 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8d1c898fa93e8bcfa2c17a37c421760581f9672" translate="yes" xml:space="preserve">
          <source>Aliases, commonly used as module names, are an exception as they must be capitalized and written in &lt;code&gt;CamelCase&lt;/code&gt;, like &lt;a href=&quot;optionparser&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt;. For aliases, capital letters are kept in acronyms, like &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.CaptureIO.html&quot;&gt;&lt;code&gt;ExUnit.CaptureIO&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://hexdocs.pm/mix/Mix.SCM.html&quot;&gt;&lt;code&gt;Mix.SCM&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 모듈 이름으로 사용되는 별명 은 &lt;a href=&quot;optionparser&quot;&gt; &lt;code&gt;OptionParser&lt;/code&gt; &lt;/a&gt; 와 같이 대문자로 작성하고 &lt;code&gt;CamelCase&lt;/code&gt; 로 작성해야하므로 예외 입니다. 별칭의 경우 대문자는 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.CaptureIO.html&quot;&gt; &lt;code&gt;ExUnit.CaptureIO&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.SCM.html&quot;&gt; &lt;code&gt;Mix.SCM&lt;/code&gt; &lt;/a&gt; 과 같은 두문자어로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="493ad9ebd988ff9d7cf101317d6dd33763da348c" translate="yes" xml:space="preserve">
          <source>All Elixir code runs inside processes that communicate with each other. When a process dies of &amp;ldquo;natural causes&amp;rdquo; (e.g., unhandled exceptions), it sends an &lt;code&gt;exit&lt;/code&gt; signal. A process can also die by explicitly sending an &lt;code&gt;exit&lt;/code&gt; signal:</source>
          <target state="translated">모든 Elixir 코드는 서로 통신하는 프로세스 내에서 실행됩니다. 프로세스가 &quot;자연적 원인&quot;(예 : 처리되지 않은 예외)으로 죽으면 &lt;code&gt;exit&lt;/code&gt; 신호를 보냅니다 . &lt;code&gt;exit&lt;/code&gt; 신호를 명시 적으로 전송하여 프로세스를 종료 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc3c548d2fd0d5198604c9d4a51b137d915ab1ca" translate="yes" xml:space="preserve">
          <source>All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system starts all applications once again.</source>
          <target state="translated">시스템이 모든 응용 프로그램을 다시 시작하기 전에 모든 응용 프로그램이 원활하게 중단되고 모든 코드가 언로드되며 모든 포트가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="32c3b583cda24a964ba5c0b1c5db5a5180eab7bc" translate="yes" xml:space="preserve">
          <source>All applications are taken down smoothly, all code is unloaded, and all ports are closed before the system terminates by calling &lt;a href=&quot;#halt/1&quot;&gt;&lt;code&gt;halt/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#halt/1&quot;&gt; &lt;code&gt;halt/1&lt;/code&gt; &lt;/a&gt; 을 호출하여 시스템이 종료되기 전에 모든 응용 프로그램이 원활하게 중단되고 모든 코드가 언로드되며 모든 포트가 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="ea13d46d1a7a005cc3e73f0e566c97f99798c880" translate="yes" xml:space="preserve">
          <source>All arguments, except the first, are guaranteed to be atoms.</source>
          <target state="translated">첫 번째 인수를 제외한 모든 인수는 원자임을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="a450b0f803f6ae1fce87a01c5eeb4990d00edaa1" translate="yes" xml:space="preserve">
          <source>All available modes are discussed below.</source>
          <target state="translated">사용 가능한 모든 모드는 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0506e345cce0be172d12fdeec69c477b8538823" translate="yes" xml:space="preserve">
          <source>All bitwise macros can be used in guards:</source>
          <target state="translated">모든 비트 단위 매크로는 가드에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f24df6aca6fef7279aa46c984d854c8399f1b8a" translate="yes" xml:space="preserve">
          <source>All configuration below can be set via config files (such as &lt;code&gt;config/config.exs&lt;/code&gt;) but also changed dynamically during runtime via &lt;a href=&quot;logger#configure/1&quot;&gt;&lt;code&gt;Logger.configure/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아래의 모든 구성은 구성 파일 (예 : &lt;code&gt;config/config.exs&lt;/code&gt; )을 통해 설정할 수 있지만 런타임 중에 &lt;a href=&quot;logger#configure/1&quot;&gt; &lt;code&gt;Logger.configure/1&lt;/code&gt; 을&lt;/a&gt; 통해 동적으로 변경 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f86cb886460af2d7afbabd4518c2a4ae8d572dd7" translate="yes" xml:space="preserve">
          <source>All configuration for Xref should be placed under the key &lt;code&gt;:xref&lt;/code&gt;.</source>
          <target state="translated">외부 참조에 대한 모든 구성은 키 &lt;code&gt;:xref&lt;/code&gt; 아래에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7e0d2ee2fbfbf3acfd326c27d7a8c9cdf22d871f" translate="yes" xml:space="preserve">
          <source>All duplicated keys are removed. See &lt;a href=&quot;#pop_first/3&quot;&gt;&lt;code&gt;pop_first/3&lt;/code&gt;&lt;/a&gt; for removing only the first entry.</source>
          <target state="translated">모든 중복 키가 제거됩니다. 첫 번째 항목 만 제거하려면 &lt;a href=&quot;#pop_first/3&quot;&gt; &lt;code&gt;pop_first/3&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="962493e8f49621899a7a8fb10598ca516db9a007" translate="yes" xml:space="preserve">
          <source>All elements in the &lt;code&gt;enumerable&lt;/code&gt; must be convertible to a binary, otherwise an error is raised.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 모든 요소 는 이진으로 변환 가능 해야합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="75780da216d4a9fe9a0de4cd507f0ecf910086a9" translate="yes" xml:space="preserve">
          <source>All elements returned from invoking the &lt;code&gt;mapper&lt;/code&gt; must be convertible to a binary, otherwise an error is raised.</source>
          <target state="translated">&lt;code&gt;mapper&lt;/code&gt; 를 호출하여 반환 된 모든 요소 는 이진으로 변환 가능해야합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a81afb8178e29a9385a90fd94857e3690f36f499" translate="yes" xml:space="preserve">
          <source>All expressions that output something to the template &lt;strong&gt;must&lt;/strong&gt; use the equals sign (&lt;code&gt;=&lt;/code&gt;). Since everything in Elixir is an expression, there are no exceptions for this rule. For example, while some template languages would special-case &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; clauses, they are treated the same in EEx and also require &lt;code&gt;=&lt;/code&gt; in order to have their result printed:</source>
          <target state="translated">모든 표현식은 템플릿 출력 무언가가 있다고 &lt;strong&gt;한다&lt;/strong&gt; 등호 기호 (사용 &lt;code&gt;=&lt;/code&gt; 을 ). Elixir의 모든 것은 표현이므로이 규칙에 대한 예외는 없습니다. 예를 들어 일부 템플릿 언어는 특수한 경우 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt; 절이지만 EEx에서는 동일하게 취급되며 결과를 인쇄 하려면 &lt;code&gt;=&lt;/code&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="64dc310c834981873443bb0c895820130d8003ed" translate="yes" xml:space="preserve">
          <source>All functions in this module accept EEx-related options. They are:</source>
          <target state="translated">이 모듈의 모든 기능은 EEx 관련 옵션을 허용합니다. 그들은:</target>
        </trans-unit>
        <trans-unit id="1f14031fee2bc02634aba88d8e6180547c70d0ae" translate="yes" xml:space="preserve">
          <source>All keys in &lt;code&gt;map2&lt;/code&gt; will be added to &lt;code&gt;map1&lt;/code&gt;, overriding any existing one (i.e., the keys in &lt;code&gt;map2&lt;/code&gt; &quot;have precedence&quot; over the ones in &lt;code&gt;map1&lt;/code&gt;).</source>
          <target state="translated">모든 키 &lt;code&gt;map2&lt;/code&gt; 추가됩니다 &lt;code&gt;map1&lt;/code&gt; 기존 하나를 (즉,의 키 무시, &lt;code&gt;map2&lt;/code&gt; 있는 사람을 통해 &quot;우선 순위가&quot; &lt;code&gt;map1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c4382006c46118de92713063dd12ca0d2391ea22" translate="yes" xml:space="preserve">
          <source>All keys in &lt;code&gt;map2&lt;/code&gt; will be added to &lt;code&gt;map1&lt;/code&gt;. The given function will be invoked when there are duplicate keys; its arguments are &lt;code&gt;key&lt;/code&gt; (the duplicate key), &lt;code&gt;value1&lt;/code&gt; (the value of &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map1&lt;/code&gt;), and &lt;code&gt;value2&lt;/code&gt; (the value of &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map2&lt;/code&gt;). The value returned by &lt;code&gt;fun&lt;/code&gt; is used as the value under &lt;code&gt;key&lt;/code&gt; in the resulting map.</source>
          <target state="translated">&lt;code&gt;map2&lt;/code&gt; 의 모든 키 가 &lt;code&gt;map1&lt;/code&gt; 에 추가됩니다 . 주어진 기능은 중복 키가있을 때 호출됩니다. 인수는 &lt;code&gt;key&lt;/code&gt; (중복 키), &lt;code&gt;value1&lt;/code&gt; (값 &lt;code&gt;key&lt;/code&gt; 에서 &lt;code&gt;map1&lt;/code&gt; )과 &lt;code&gt;value2&lt;/code&gt; (값 &lt;code&gt;key&lt;/code&gt; 에 &lt;code&gt;map2&lt;/code&gt; ). &lt;code&gt;fun&lt;/code&gt; 에 의해 리턴 된 값 은 결과 맵 에서 &lt;code&gt;key&lt;/code&gt; 아래의 값으로 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="81067fca2a4826fa2b861dc9ccff01a040457240" translate="yes" xml:space="preserve">
          <source>All keys, including duplicated keys, given in &lt;code&gt;keywords2&lt;/code&gt; will be added to &lt;code&gt;keywords1&lt;/code&gt;, overriding any existing one.</source>
          <target state="translated">주어진 중복 키를 포함한 모든 키, &lt;code&gt;keywords2&lt;/code&gt; 이 추가됩니다 &lt;code&gt;keywords1&lt;/code&gt; 기존 하나를 오버라이드 (override).</target>
        </trans-unit>
        <trans-unit id="e2c2426bd83d495cefd1511dd9e29d2650392f21" translate="yes" xml:space="preserve">
          <source>All keys, including duplicated keys, given in &lt;code&gt;keywords2&lt;/code&gt; will be added to &lt;code&gt;keywords1&lt;/code&gt;. The given function will be invoked to solve conflicts.</source>
          <target state="translated">주어진 중복 키를 포함한 모든 키, &lt;code&gt;keywords2&lt;/code&gt; 이 추가됩니다 &lt;code&gt;keywords1&lt;/code&gt; . 주어진 함수는 충돌을 해결하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5e5fd7c77cbce8d2bd6aeafdabf4cfeac9e29a80" translate="yes" xml:space="preserve">
          <source>All modifiers listed above can be combined; repeated modifiers in &lt;code&gt;modifiers&lt;/code&gt; will be ignored.</source>
          <target state="translated">위에 나열된 모든 수정자를 결합 할 수 있습니다. 반복 된 수정 &lt;code&gt;modifiers&lt;/code&gt; 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c9db69ff5fd80f1c32d968ebb750da1bd96e5703" translate="yes" xml:space="preserve">
          <source>All of the constructs above are part of Elixir's syntax and have their own representation as part of the Elixir AST. This section will discuss the remaining constructs that &quot;desugar&quot; to one of the constructs explored above. In other words, the constructs below can be represented in more than one way in your Elixir code and retain AST equivalence.</source>
          <target state="translated">위의 모든 구문은 Elixir 구문의 일부이며 Elixir AST의 일부로 자체 표현이 있습니다. 이 섹션에서는 위에서 살펴본 구성 중 하나에 &quot;탈당&quot;하는 나머지 구성에 대해 설명합니다. 다시 말해, 아래의 구성은 엘릭서 코드에서 하나 이상의 방식으로 표현되고 AST 동등성을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efecbd33be6692e33153d5c191da2fd42dffe301" translate="yes" xml:space="preserve">
          <source>All operators in Elixir are also valid atoms. Valid examples are &lt;code&gt;:foo&lt;/code&gt;, &lt;code&gt;:FOO&lt;/code&gt;, &lt;code&gt;:foo_42&lt;/code&gt;, &lt;code&gt;:foo@bar&lt;/code&gt;, and &lt;code&gt;:++&lt;/code&gt;. Invalid examples are &lt;code&gt;:@foo&lt;/code&gt; (&lt;code&gt;@&lt;/code&gt; is not allowed at start), &lt;code&gt;:123&lt;/code&gt; (numbers are not allowed at start), and &lt;code&gt;:(*)&lt;/code&gt; (not a valid operator).</source>
          <target state="translated">Elixir의 모든 연산자는 유효한 원자입니다. 유효한 예는 &lt;code&gt;:foo&lt;/code&gt; , &lt;code&gt;:FOO&lt;/code&gt; , &lt;code&gt;:foo_42&lt;/code&gt; , &lt;code&gt;:foo@bar&lt;/code&gt; 및 &lt;code&gt;:++&lt;/code&gt; 입니다. 유효 하지 않은 예는 &lt;code&gt;:@foo&lt;/code&gt; ( &lt;code&gt;@&lt;/code&gt; 는 시작시 허용되지 않음), &lt;code&gt;:123&lt;/code&gt; (시작시 숫자 허용되지 않음) 및 &lt;code&gt;:(*)&lt;/code&gt; (유효한 연산자가 아님)입니다.</target>
        </trans-unit>
        <trans-unit id="a68a6061ed529e7321fbab2a1e1466c173d56718" translate="yes" xml:space="preserve">
          <source>All terms in Elixir can be compared with each other.</source>
          <target state="translated">Elixir의 모든 용어는 서로 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd8a32aefda3f349478b8a4289ce78ffc774e378" translate="yes" xml:space="preserve">
          <source>All tests receive a context as an argument. The context is particularly useful for sharing information between callbacks and tests:</source>
          <target state="translated">모든 테스트는 컨텍스트를 인수로받습니다. 컨텍스트는 콜백과 테스트간에 정보를 공유 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="46f1e0081d7ff3ef1598ee1f4611d0858df9a878" translate="yes" xml:space="preserve">
          <source>All tests start with a state of &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">모든 테스트는 &lt;code&gt;nil&lt;/code&gt; 상태로 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="471fbe4680a438c1f34492b7155396825fbf6e7e" translate="yes" xml:space="preserve">
          <source>All the functions in the &lt;code&gt;Enum&lt;/code&gt; module are eager. Many functions expect an enumerable and return a list back:</source>
          <target state="translated">&lt;code&gt;Enum&lt;/code&gt; 모듈 의 모든 기능 이 간절합니다. 많은 함수가 열거 가능할 것으로 예상하고 목록을 다시 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ad97f344ca26467cc845b62f0e8a053c5eb38fe0" translate="yes" xml:space="preserve">
          <source>All the values of caller functions describe the marked function. For example, the first row means that &lt;code&gt;Mod.caller1/0&lt;/code&gt; invoked &lt;code&gt;Mod.some_function/0&lt;/code&gt; 3 times. 200ms of the total time spent in &lt;code&gt;Mod.some_function/0&lt;/code&gt; was spent processing calls from this particular caller.</source>
          <target state="translated">호출자 함수의 모든 값은 표시된 함수를 설명합니다. 예를 들어 첫 번째 행은 &lt;code&gt;Mod.caller1/0&lt;/code&gt; 이 &lt;code&gt;Mod.some_function/0&lt;/code&gt; 을 3 번 호출 했음을 의미합니다 . &lt;code&gt;Mod.some_function/0&lt;/code&gt; 에 소비 된 총 시간의 200ms는 이 특정 발신자의 통화 처리에 소비되었습니다.</target>
        </trans-unit>
        <trans-unit id="ab62fee1181d53e168d5ddca4b76c2a3f0f14d49" translate="yes" xml:space="preserve">
          <source>All these macros are public macros (as defined by &lt;code&gt;defmacro&lt;/code&gt;).</source>
          <target state="translated">이 매크로는 모두 공개 매크로입니다 ( &lt;code&gt;defmacro&lt;/code&gt; 에 의해 정의 됨 ).</target>
        </trans-unit>
        <trans-unit id="34f3030dbffbd799437c8acd75092b93db7172e2" translate="yes" xml:space="preserve">
          <source>Allowed in guard clauses.</source>
          <target state="translated">가드 조항에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="16b8d71f3125091140d0f8672105255771ac2803" translate="yes" xml:space="preserve">
          <source>Allowed in guard clauses. Inlined by the compiler.</source>
          <target state="translated">가드 조항에서 허용됩니다. 컴파일러에 의해 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="bc41d2a47a402c530d62da0bb42913ffb6baf173" translate="yes" xml:space="preserve">
          <source>Allowed in guard tests.</source>
          <target state="translated">가드 테스트에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="af6c8de133dbdc2f69863328f74fb83aacfb7360" translate="yes" xml:space="preserve">
          <source>Allowed in guard tests. Inlined by the compiler.</source>
          <target state="translated">가드 테스트에서 허용됩니다. 컴파일러에 의해 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="2b173cc6a1f043289cd7c3164ac03625499e4950" translate="yes" xml:space="preserve">
          <source>Allows a developer to customize the using block when the case template is used.</source>
          <target state="translated">사례 템플릿을 사용할 때 개발자가 사용 블록을 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce229aa087121abe44456ef91f4d85fd2c83436e" translate="yes" xml:space="preserve">
          <source>Allows to programmatically run the &lt;code&gt;cprof&lt;/code&gt; profiler on expression in &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">프로그래밍 방식으로 &lt;code&gt;cprof&lt;/code&gt; 프로파일 러 를 프로그래밍 방식 으로 &lt;code&gt;fun&lt;/code&gt; 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36e890e59c1727dd986c090acbf3706458233a86" translate="yes" xml:space="preserve">
          <source>Allows to programmatically run the &lt;code&gt;eprof&lt;/code&gt; profiler on expression in &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">프로그래밍 방식으로 &lt;code&gt;eprof&lt;/code&gt; 프로파일 러 를 프로그래밍 방식 으로 &lt;code&gt;fun&lt;/code&gt; 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cec7e6385a65f90ce774de5cfa85e6c67d629db7" translate="yes" xml:space="preserve">
          <source>Allows to programmatically run the &lt;code&gt;fprof&lt;/code&gt; profiler on expression in &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">프로그래밍 방식으로 &lt;code&gt;fprof&lt;/code&gt; 프로파일 러 를 프로그래밍 방식 으로 &lt;code&gt;fun&lt;/code&gt; 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fb76106047518ce4fb611a343f5cfc33db811df" translate="yes" xml:space="preserve">
          <source>Alongside the observer application, Erlang also includes a &lt;code&gt;:crashdump_viewer&lt;/code&gt; to view crash dumps</source>
          <target state="translated">Erlang은 옵저버 애플리케이션과 함께 &lt;code&gt;:crashdump_viewer&lt;/code&gt; 를 볼 수 있는 : crashdump_viewer 도 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="7b9345037b9e6e5f6f050e0e1c3ba89d21df3bda" translate="yes" xml:space="preserve">
          <source>Alphanumeric characters: &lt;code&gt;A-Z&lt;/code&gt;, &lt;code&gt;a-z&lt;/code&gt;, &lt;code&gt;0-9&lt;/code&gt;</source>
          <target state="translated">영숫자 : &lt;code&gt;A-Z&lt;/code&gt; , &lt;code&gt;a-z&lt;/code&gt; , &lt;code&gt;0-9&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fc66c0fdb05c288a2d0be6731b80e56ea10955b8" translate="yes" xml:space="preserve">
          <source>Also note that Erlang&amp;rsquo;s formatting functions require special attention to Unicode handling.</source>
          <target state="translated">또한 Erlang의 서식 기능에는 유니 코드 처리에 특별한주의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="25e5fdf8b80ad209b572bf379ee2d97f709f491c" translate="yes" xml:space="preserve">
          <source>Also note the &lt;code&gt;async: true&lt;/code&gt; option passed to &lt;code&gt;ExUnit.Case&lt;/code&gt;. This option makes the test case run in parallel with other &lt;code&gt;:async&lt;/code&gt; test cases by using multiple cores in our machine. This is extremely useful to speed up our test suite. However, &lt;code&gt;:async&lt;/code&gt; must &lt;em&gt;only&lt;/em&gt; be set if the test case does not rely on or change any global values. For example, if the test requires writing to the filesystem or access a database, keep it synchronous (omit the &lt;code&gt;:async&lt;/code&gt; option) to avoid race conditions between tests.</source>
          <target state="translated">또한 &lt;code&gt;async: true&lt;/code&gt; 옵션이 &lt;code&gt;ExUnit.Case&lt;/code&gt; 로 전달되었습니다 . 이 옵션은 머신에서 여러 코어를 사용하여 테스트 케이스 를 다른 &lt;code&gt;:async&lt;/code&gt; 테스트 케이스 와 병렬로 실행 합니다. 테스트 스위트 속도를 높이는 데 매우 유용합니다. 그러나 테스트 케이스가 전역 값에 의존하지 않거나 전역 값을 변경하지 않는 경우 &lt;em&gt;에만 &lt;/em&gt; &lt;code&gt;:async&lt;/code&gt; 를 설정 해야 합니다. 예를 들어, 테스트에서 파일 시스템에 쓰거나 데이터베이스에 액세스해야하는 경우 테스트 간에 경쟁 조건을 피하기 위해 동기식으로 유지하십시오 ( &lt;code&gt;:async&lt;/code&gt; 옵션 생략 ).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="99f95b6ecaf40ea41137c6dd421e917e63ab648f" translate="yes" xml:space="preserve">
          <source>Also, keep in mind that profiling might significantly increase the running time of the profiled processes. This might skew your results if, for example, those processes perform some I/O operations, since running time of those operations will remain unchanged, while CPU bound operations of the profiled processes might take significantly longer. Thus, when profiling some intensive program, try to reduce such dependencies, or be aware of the resulting bias.</source>
          <target state="translated">또한 프로파일 링은 프로파일 링 된 프로세스의 실행 시간을 크게 증가시킬 수 있습니다. 예를 들어, 해당 프로세스의 실행 시간이 변경되지 않고 프로파일 된 프로세스의 CPU 바운드 조작이 상당히 오래 걸릴 수 있기 때문에 해당 프로세스가 일부 I / O 조작을 수행하는 경우 결과가 왜곡 될 수 있습니다. 따라서 일부 집중적 인 프로그램을 프로파일 링 할 때는 이러한 종속성을 줄이거 나 결과적인 편견을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="92516fadfd2f18efb90c2a6ec6fde01d43c3b8e5" translate="yes" xml:space="preserve">
          <source>Also, note that we started the documentation string using &lt;code&gt;@doc ~S&quot;&quot;&quot;&lt;/code&gt;. The &lt;code&gt;~S&lt;/code&gt; prevents the &lt;code&gt;\r\n&lt;/code&gt; characters from being converted to a carriage return and line feed until they are evaluated in the test.</source>
          <target state="translated">또한 &lt;code&gt;@doc ~S&quot;&quot;&quot;&lt;/code&gt; 사용하여 문서화 문자열을 시작했습니다 . &lt;code&gt;~S&lt;/code&gt; 는 &lt;code&gt;\r\n&lt;/code&gt; 문자가 테스트에서 평가 될 때까지 캐리지 리턴 및 줄 바꿈으로 변환되지 않도록합니다 .</target>
        </trans-unit>
        <trans-unit id="48be7d4f57a1ff8c0c8de01d6b7c49d0f740172b" translate="yes" xml:space="preserve">
          <source>Alternates between sync and async modes to remain performant when required but also apply backpressure when under stress.</source>
          <target state="translated">동기화 모드와 비동기 모드 사이를 전환하여 필요할 때 성능을 유지하지만 스트레스를받을 때 배압을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="56a32fedc781d04589b1e27a4190731f2b801a94" translate="yes" xml:space="preserve">
          <source>Alternatively to pattern matching, filters can be used to select some particular elements. For example, we can select the multiples of 3 and discard all others:</source>
          <target state="translated">패턴 일치 대신 필터를 사용하여 일부 특정 요소를 선택할 수 있습니다. 예를 들어, 3의 배수를 선택하고 나머지는 모두 버릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="738072000214e7dd8d85de9d3d93ddc937487ae4" translate="yes" xml:space="preserve">
          <source>Alternatively, Elixir allows a developer to pass pairs of name/arities to &lt;code&gt;:only&lt;/code&gt; or &lt;code&gt;:except&lt;/code&gt; as a fine grained control on what to import (or not):</source>
          <target state="translated">또는 Elixir를 사용하면 개발자 가 가져올 이름에 대한 세밀한 제어로 이름 / 군목 쌍을 &lt;code&gt;:only&lt;/code&gt; 또는 &lt;code&gt;:except&lt;/code&gt; 에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f1d115c4cc71092e4215eb5349ece403f7a97dc" translate="yes" xml:space="preserve">
          <source>Alternatively, the number of stops can be increased by passing the &lt;code&gt;stops&lt;/code&gt; argument. &lt;a href=&quot;iex.helpers#reset_break/1&quot;&gt;&lt;code&gt;IEx.Helpers.reset_break/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;iex.helpers#reset_break/3&quot;&gt;&lt;code&gt;IEx.Helpers.reset_break/3&lt;/code&gt;&lt;/a&gt; can be used to reset the number back to zero. Note the module remains &quot;instrumented&quot; even after all stops on all breakpoints are consumed. You can remove the instrumentation in a given module by calling &lt;a href=&quot;iex.helpers#remove_breaks/1&quot;&gt;&lt;code&gt;IEx.Helpers.remove_breaks/1&lt;/code&gt;&lt;/a&gt; and on all modules by calling &lt;a href=&quot;iex.helpers#remove_breaks/0&quot;&gt;&lt;code&gt;IEx.Helpers.remove_breaks/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또는 &lt;code&gt;stops&lt;/code&gt; 인수 를 전달하여 중지 수를 늘릴 수 있습니다 . &lt;a href=&quot;iex.helpers#reset_break/1&quot;&gt; &lt;code&gt;IEx.Helpers.reset_break/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;iex.helpers#reset_break/3&quot;&gt; &lt;code&gt;IEx.Helpers.reset_break/3&lt;/code&gt; &lt;/a&gt; 을 사용하여 숫자를 다시 0으로 재설정 할 수 있습니다. 모든 중단 점에서 모든 정지가 소비 된 후에도 모듈은 &quot;계측 된&quot;상태로 유지됩니다. &lt;a href=&quot;iex.helpers#remove_breaks/1&quot;&gt; &lt;code&gt;IEx.Helpers.remove_breaks/1&lt;/code&gt; &lt;/a&gt; 을 호출하여 지정된 모듈 및 &lt;a href=&quot;iex.helpers#remove_breaks/0&quot;&gt; &lt;code&gt;IEx.Helpers.remove_breaks/0&lt;/code&gt; &lt;/a&gt; 을 호출하여 모든 모듈 에서 계측을 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f6b64d93c6e1bd876f47c2efd90152e6697540d" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; to setup a breakpoint on a given module, function and arity you have no control of. While &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt; is more flexible, it does not contain information about imports and aliases from the source code.</source>
          <target state="translated">또는 &lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt; 를 사용 하여 제어 할 수없는 특정 모듈, 기능 및 특성에 중단 점을 설정할 수 있습니다. &lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; &lt;/a&gt; 는 융통성이 있지만 소스 코드에서 가져 오기 및 별명에 대한 정보는 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a4be7155bcffba0850c80a370bc5c6b34c37e74" translate="yes" xml:space="preserve">
          <source>Alternatives</source>
          <target state="translated">Alternatives</target>
        </trans-unit>
        <trans-unit id="b0a8089f58c0c54576c2250b325fc6b97e8e0b35" translate="yes" xml:space="preserve">
          <source>Alters the current process metadata according the given keyword list.</source>
          <target state="translated">주어진 키워드 목록에 따라 현재 프로세스 메타 데이터를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="6b160e130daad190a032bd2c82f16a239367a706" translate="yes" xml:space="preserve">
          <source>Alters the value stored under &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, but only if the entry &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;keywords&lt;/code&gt;.</source>
          <target state="translated">변경합니다 아래에 저장된 값 &lt;code&gt;key&lt;/code&gt; 에 &lt;code&gt;value&lt;/code&gt; ,하지만 진입하면 &lt;code&gt;key&lt;/code&gt; 이미 존재하는 &lt;code&gt;keywords&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9aed7587419c22040987ccddf36342ed35dbbef" translate="yes" xml:space="preserve">
          <source>Alters the value stored under &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, but only if the entry &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">변경합니다 아래에 저장된 값 &lt;code&gt;key&lt;/code&gt; 에 &lt;code&gt;value&lt;/code&gt; ,하지만 진입하면 &lt;code&gt;key&lt;/code&gt; 이미 존재하는 &lt;code&gt;map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="375d49ba0682b4200a357c23af57a8fe3e771407" translate="yes" xml:space="preserve">
          <source>Although Elixir includes specific functions such as &lt;code&gt;tuple_size&lt;/code&gt;, &lt;code&gt;binary_size&lt;/code&gt; and &lt;code&gt;map_size&lt;/code&gt;, sometimes we want to be able to retrieve the size of a data structure regardless of its type. In Elixir we can write polymorphic code, i.e. code that works with different shapes/types, by using protocols. A size protocol could be implemented as follows:</source>
          <target state="translated">Elixir에는 &lt;code&gt;tuple_size&lt;/code&gt; , &lt;code&gt;binary_size&lt;/code&gt; 및 &lt;code&gt;map_size&lt;/code&gt; 와 같은 특정 기능이 포함되어 있지만 유형에 관계없이 데이터 구조의 크기를 검색 할 수있는 경우가 있습니다. Elixir에서는 프로토콜을 사용하여 다형성 코드, 즉 다른 모양 / 유형으로 작동하는 코드를 작성할 수 있습니다. 크기 프로토콜은 다음과 같이 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="271db6153eba80f48b3cb5615c2c7cf2befa189f" translate="yes" xml:space="preserve">
          <source>Although Mix generates and maintains the &lt;code&gt;.app&lt;/code&gt; file for us, we can customize its contents by adding new entries to the &lt;code&gt;application/0&lt;/code&gt; function inside the &lt;code&gt;mix.exs&lt;/code&gt; project file. We are going to do our first customization soon.</source>
          <target state="translated">Mix는 &lt;code&gt;.app&lt;/code&gt; 파일을 생성하고 유지 관리하지만 &lt;code&gt;mix.exs&lt;/code&gt; 프로젝트 파일 의 &lt;code&gt;application/0&lt;/code&gt; 함수에 새 항목을 추가하여 내용을 사용자 정의 할 수 있습니다 . 우리는 곧 첫 번째 사용자 정의를 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="b17471efb7e8b7966f0aa39356cf0b8489d5f43b" translate="yes" xml:space="preserve">
          <source>Although code points could be represented as integers, this module represents all code points as strings. For example:</source>
          <target state="translated">코드 포인트는 정수로 표현 될 수 있지만이 모듈은 모든 코드 포인트를 문자열로 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14fda69fb3ca698206ce8ef9fa7ae0f578b2ed83" translate="yes" xml:space="preserve">
          <source>Although doing so is not recommended as it may affect your test suite performance.</source>
          <target state="translated">테스트 스위트 성능에 영향을 줄 수 있으므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7089c4bbd915ddfe4f12d574def40357ae4ad792" translate="yes" xml:space="preserve">
          <source>Although improper lists are generally avoided, they are used in some special circumstances like iodata and chardata entities (see the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">부적절한 목록은 일반적으로 피하지만 iodata 및 chardata 엔티티와 같은 특수한 환경에서 사용됩니다 ( &lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 모듈 참조 ).</target>
        </trans-unit>
        <trans-unit id="1fac951d9acd827630fc984ba5e390c89493d219" translate="yes" xml:space="preserve">
          <source>Although in the example above we have used &lt;a href=&quot;genserver#start_link/3&quot;&gt;&lt;code&gt;GenServer.start_link/3&lt;/code&gt;&lt;/a&gt; and friends to directly start and communicate with the server, most of the time we don't call the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; functions directly. Instead, we wrap the calls in new functions representing the public API of the server.</source>
          <target state="translated">위의 예에서 &lt;a href=&quot;genserver#start_link/3&quot;&gt; &lt;code&gt;GenServer.start_link/3&lt;/code&gt; &lt;/a&gt; 및 friends를 사용하여 서버를 직접 시작하고 통신했지만 대부분 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 함수를 직접 호출하지는 않습니다 . 대신 서버의 공개 API를 나타내는 새로운 함수로 호출을 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="05cad5e03ed101afeda99f24e9baf0f87a53f9f2" translate="yes" xml:space="preserve">
          <source>Although our tests pass, our testing structure is getting more complex. In particular, running tests with only &lt;code&gt;mix test&lt;/code&gt; causes failures in our suite, since our test requires a connection to another node.</source>
          <target state="translated">테스트는 통과했지만 테스트 구조는 점점 복잡해지고 있습니다. 특히 &lt;code&gt;mix test&lt;/code&gt; 만으로 테스트를 실행 하면 테스트에서 다른 노드에 연결해야하므로 스위트에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ff729d77091a6064c1d998a90b46541e7d7f75c9" translate="yes" xml:space="preserve">
          <source>Although pattern matching allows us to build powerful constructs, its usage is limited. For instance, you cannot make function calls on the left side of a match. The following example is invalid:</source>
          <target state="translated">패턴 매칭은 강력한 구조를 만들 수 있지만 사용법은 제한적입니다. 예를 들어, 일치하는 왼쪽에서 함수 호출을 수행 할 수 없습니다. 다음 예는 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1d430d2d6fb0548beb47e18ecfea58c354f9cde" translate="yes" xml:space="preserve">
          <source>Although structs are maps, by default structs do not implement any of the protocols implemented for maps. Check &lt;a href=&quot;kernel#defprotocol/2&quot;&gt;&lt;code&gt;Kernel.defprotocol/2&lt;/code&gt;&lt;/a&gt; for more information on how structs can be used with protocols for polymorphic dispatch. Also see &lt;a href=&quot;kernel#struct/2&quot;&gt;&lt;code&gt;Kernel.struct/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#struct!/2&quot;&gt;&lt;code&gt;Kernel.struct!/2&lt;/code&gt;&lt;/a&gt; for examples on how to create and update structs dynamically.</source>
          <target state="translated">구조체는 맵이지만 기본적으로 구조체는 맵에 구현 된 프로토콜을 구현하지 않습니다. 구조체를 다형성 디스패치 프로토콜과 함께 사용하는 방법에 대한 자세한 내용은 &lt;a href=&quot;kernel#defprotocol/2&quot;&gt; &lt;code&gt;Kernel.defprotocol/2&lt;/code&gt; &lt;/a&gt; 를 확인하십시오 . 구조체를 동적으로 만들고 업데이트하는 방법에 대한 예제는 &lt;a href=&quot;kernel#struct/2&quot;&gt; &lt;code&gt;Kernel.struct/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;kernel#struct!/2&quot;&gt; &lt;code&gt;Kernel.struct!/2&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="870fe0c59e3d007685ea9833cb1390f52f0e514b" translate="yes" xml:space="preserve">
          <source>Although structs are maps, by default structs do not implement any of the protocols implemented for maps. For example, attempting to use a protocol with the &lt;code&gt;User&lt;/code&gt; struct leads to an error:</source>
          <target state="translated">구조체는 맵이지만 기본적으로 구조체는 맵에 구현 된 프로토콜을 구현하지 않습니다. 예를 들어, &lt;code&gt;User&lt;/code&gt; 구조체 와 함께 프로토콜을 사용하려고 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="431f21d40dbb5403d9bd326700ba842d9364814b" translate="yes" xml:space="preserve">
          <source>Although the above is handy, it means it is impossible to invoke an executable that has whitespaces on its name or in any of its arguments. For those reasons, most times it is preferable to execute &lt;code&gt;:spawn_executable&lt;/code&gt;.</source>
          <target state="translated">위의 내용은 편리하지만 이름이나 인수에 공백이있는 실행 파일을 호출 할 수 없다는 것을 의미합니다. 이러한 이유로 대부분의 경우 &lt;code&gt;:spawn_executable&lt;/code&gt; 을 실행하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5fb3fdd978f27b5125e369d37a21e919df537b80" translate="yes" xml:space="preserve">
          <source>Although the directory can be accessed as &lt;code&gt;Path.dirname(__ENV__.file)&lt;/code&gt;, this macro is a convenient shortcut.</source>
          <target state="translated">디렉토리는 &lt;code&gt;Path.dirname(__ENV__.file)&lt;/code&gt; 로 액세스 할 수 있지만 이 매크로는 편리한 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="08556dd674acbaa5235d5a6dd7ba968777f84148" translate="yes" xml:space="preserve">
          <source>Although the end result is the same, the order in which the elements were printed changed! With streams, we print the first element and then print its double. In this example, the list was enumerated just once!</source>
          <target state="translated">최종 결과는 동일하지만 요소 인쇄 순서가 변경되었습니다! 스트림을 사용하여 첫 번째 요소를 인쇄 한 다음 이중 요소를 인쇄합니다. 이 예에서는 목록이 한 번만 열거되었습니다!</target>
        </trans-unit>
        <trans-unit id="34317ca951c3b1fca45985dcc2015a9c9f8ee491" translate="yes" xml:space="preserve">
          <source>Although the example above is made of two characters, it is perceived by users as one.</source>
          <target state="translated">위의 예는 두 문자로 구성되어 있지만 사용자가 하나의 문자로 인식합니다.</target>
        </trans-unit>
        <trans-unit id="a4ac7eba93e375ca0b8410e005578a589bad8a11" translate="yes" xml:space="preserve">
          <source>Although the function above works, it performs poorly. To calculate the length of the string, we need to traverse it fully, so we traverse both &lt;code&gt;prefix&lt;/code&gt; and &lt;code&gt;full&lt;/code&gt; strings, then slice the &lt;code&gt;full&lt;/code&gt; one, traversing it again.</source>
          <target state="translated">위의 기능은 작동하지만 성능이 저하됩니다. 문자열의 길이를 계산하기 위해, 우리는 우리가 모두 통과, 그래서 그것을 완전히 통과 할 필요는 &lt;code&gt;prefix&lt;/code&gt; 와 &lt;code&gt;full&lt;/code&gt; 문자열, 다음 슬라이스 &lt;code&gt;full&lt;/code&gt; 를 다시 통과.</target>
        </trans-unit>
        <trans-unit id="2ad64b2ae9d7779aeafe9f53ba81c4ac6a8c3bcb" translate="yes" xml:space="preserve">
          <source>Although the implementation above is arguably not a reasonable one. For example, it makes no sense to say a PID or an integer have a size of &lt;code&gt;0&lt;/code&gt;. That's one of the reasons why &lt;code&gt;@fallback_to_any&lt;/code&gt; is an opt-in behaviour. For the majority of protocols, raising an error when a protocol is not implemented is the proper behaviour.</source>
          <target state="translated">위의 구현은 아마도 합리적인 것이 아닙니다. 예를 들어 PID 또는 정수의 크기가 &lt;code&gt;0&lt;/code&gt; 이라고 말하는 것은 의미가 없습니다 . 이것이 &lt;code&gt;@fallback_to_any&lt;/code&gt; 가 옵트 인 동작 인 이유 중 하나입니다 . 대부분의 프로토콜에서 프로토콜이 구현되지 않은 경우 오류를 발생시키는 것이 올바른 동작입니다.</target>
        </trans-unit>
        <trans-unit id="2d80e43bdc8417d6590a2fd8779a42e453b4510f" translate="yes" xml:space="preserve">
          <source>Although the module can be accessed in the &lt;a href=&quot;#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt;, this macro is a convenient shortcut.</source>
          <target state="translated">&lt;a href=&quot;#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt; 에서 모듈에 액세스 할 수 있지만 이 매크로는 편리한 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="523bba024fe01ece815e7c56ce1e3c3d7d5ff12a" translate="yes" xml:space="preserve">
          <source>Although the previous section could be summarized as &quot;avoid macros&quot;, both topics are important enough to deserve their own sections.</source>
          <target state="translated">이전 섹션을 &quot;매크로 방지&quot;로 요약 할 수 있지만 두 항목 모두 자체 섹션을 사용할 수있을만큼 중요합니다.</target>
        </trans-unit>
        <trans-unit id="8a45380bdb24cc0394ac693565319d64e7fe3702" translate="yes" xml:space="preserve">
          <source>Although this chapter was the first time we implemented a supervisor, it was not the first time we used one! In the previous chapter, when we used &lt;code&gt;start_supervised!&lt;/code&gt; to start the registry during our tests, &lt;code&gt;ExUnit&lt;/code&gt; started the registry under a supervisor managed by the ExUnit framework itself. By defining our own supervisor, we provide more structure on how we initialize, shutdown and supervise processes in our applications, aligning our production code and tests with best practices.</source>
          <target state="translated">이 장은 처음으로 관리자를 구현했지만 처음 사용한 것은 아닙니다! 이전 장에서 &lt;code&gt;start_supervised!&lt;/code&gt; 우리의 테스트 기간 동안 레지스트리를 시작, &lt;code&gt;ExUnit&lt;/code&gt; 는 ExUnit 프레임 워크 자체에 의해 관리 감독자 아래 레지스트리를 시작했다. 자체 감독자를 정의함으로써 애플리케이션에서 프로세스를 초기화, 종료 및 감독하는 방법에 대한 더 많은 구조를 제공하여 프로덕션 코드와 테스트를 모범 사례에 맞 춥니 다.</target>
        </trans-unit>
        <trans-unit id="3c9f4ae19a7eeeab2983d7dec1f1792d10b1c1ba" translate="yes" xml:space="preserve">
          <source>Although this is a subtle difference, you only need to worry about these details if you intend to pass lists to those functions. Binaries are already represented by the underlying bytes and as such their representation is always &amp;ldquo;raw&amp;rdquo;.</source>
          <target state="translated">이것은 미묘한 차이이지만 목록을 해당 함수에 전달하려는 경우 이러한 세부 정보 만 걱정하면됩니다. 바이너리는 이미 기본 바이트로 표시되므로 항상 &quot;raw&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="84c3d8b250459ad3c47db87432253967c9d495f1" translate="yes" xml:space="preserve">
          <source>Although we can pattern match on keyword lists, it is rarely done in practice since pattern matching on lists requires the number of items and their order to match:</source>
          <target state="translated">키워드 목록에서 패턴 일치를 할 수는 있지만, 목록에서 패턴 일치는 항목 수와 순서가 일치해야하기 때문에 실제로는 거의 이루어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1624e83a6f323b5d4e4763fd7f94a95a8d4f3768" translate="yes" xml:space="preserve">
          <source>Although we expect the vast majority of programs to remain compatible over time, it is impossible to guarantee that no future change will break any program. Under some unlikely circumstances, we may introduce changes that break existing code:</source>
          <target state="translated">우리는 대부분의 프로그램이 시간이 지남에 따라 호환성을 유지하기를 기대하지만 향후 변경으로 인해 프로그램이 중단되지는 않을 것입니다. 가능성이 거의없는 상황에서 기존 코드를 손상시키는 변경 사항이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b17a13f88c530e5861a53d56146266cecae866f" translate="yes" xml:space="preserve">
          <source>Although we have overlooked some details, this is the main idea behind creating domain-specific modules in Elixir. Macros enable us to return quoted expressions that are executed in the caller, which we can then use to transform code and store relevant information in the target module via module attributes. Finally, callbacks such as &lt;code&gt;@before_compile&lt;/code&gt; allow us to inject code into the module when its definition is complete.</source>
          <target state="translated">우리는 몇 가지 세부 사항을 간과했지만 이것이 Elixir에서 도메인 별 모듈을 생성하는 주요 아이디어입니다. 매크로를 사용하면 호출자에서 실행되는 따옴표로 묶인 표현식을 반환 할 수 있습니다. 그러면 코드를 변환하고 모듈 속성을 통해 대상 모듈에 관련 정보를 저장할 수 있습니다. 마지막으로 &lt;code&gt;@before_compile&lt;/code&gt; 과 같은 콜백을 통해 정의가 완료되면 모듈에 코드를 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3359c56da801ba4eef5b9504bfbf16ddf4e8ca4b" translate="yes" xml:space="preserve">
          <source>Always returns &lt;code&gt;:ok&lt;/code&gt; and automatically unlinks the current process from the owner if there are no more keys associated to the current process. See also &lt;a href=&quot;#register/3&quot;&gt;&lt;code&gt;register/3&lt;/code&gt;&lt;/a&gt; to read more about the &quot;owner&quot;.</source>
          <target state="translated">항상 &lt;code&gt;:ok&lt;/code&gt; 를 반환 하고 현재 프로세스와 연관된 키가 더 이상 없으면 현재 프로세스를 소유자와 자동으로 연결 해제합니다. &quot;소유자&quot;에 대한 자세한 내용은 &lt;a href=&quot;#register/3&quot;&gt; &lt;code&gt;register/3&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72c0244fa532d1e23d46ac34ccb91bfb72ffc273" translate="yes" xml:space="preserve">
          <source>Ambiguous function/macro names</source>
          <target state="translated">모호한 함수 / 매크로 이름</target>
        </trans-unit>
        <trans-unit id="a049ff1aa2d29c7c72357b2f704f3d8dea2f8d78" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; is most commonly started under a supervision tree. When we invoke &lt;code&gt;use Agent&lt;/code&gt;, it automatically defines a &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; function that allows us to start the agent directly under a supervisor. To start an agent under a supervisor with an initial counter of 0, one may do:</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; 가장 일반적으로 감독의 나무 아래에서 시작됩니다. &lt;code&gt;use Agent&lt;/code&gt; 를 호출 하면 수퍼바이저에서 에이전트를 직접 시작할 수 있는 &lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt; 함수가 자동으로 정의됩니다 . 초기 카운터가 0 인 수퍼바이저에서 에이전트를 시작하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0cd52ac6bbd448008fc9991be40af1235993cec9" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised if the padding is incorrect or a non-alphabet character is present in the string.</source>
          <target state="translated">&lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 패딩이 잘못 또는 비 알파벳 문자가 문자열에있는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e7f62694e798684b6b70596713962c709a802b67" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;io.stream&quot;&gt;&lt;code&gt;IO.Stream&lt;/code&gt;&lt;/a&gt; implements both &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;collectable&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt;, allowing it to be used for both read and write.</source>
          <target state="translated">&lt;a href=&quot;io.stream&quot;&gt; &lt;code&gt;IO.Stream&lt;/code&gt; 은&lt;/a&gt; 모두 구현 &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; 에서&lt;/a&gt; 와 &lt;a href=&quot;collectable&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; 가 읽기 및 쓰기 모두에 사용할 수 있도록.</target>
        </trans-unit>
        <trans-unit id="afe086c320e6384512964bd01dec4f5547e66922" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;after&lt;/code&gt; clause allows you to define cleanup logic that will be invoked both when the block of code passed to &lt;a href=&quot;#try/1&quot;&gt;&lt;code&gt;try/1&lt;/code&gt;&lt;/a&gt; succeeds and also when an error is raised. Note that the process will exit as usual when receiving an exit signal that causes it to exit abruptly and so the &lt;code&gt;after&lt;/code&gt; clause is not guaranteed to be executed. Luckily, most resources in Elixir (such as open files, ETS tables, ports, sockets, and so on) are linked to or monitor the owning process and will automatically clean themselves up if that process exits.</source>
          <target state="translated">&lt;code&gt;after&lt;/code&gt; 절은 코드의 블록에 전달하면 모두 호출됩니다 정리 논리를 정의 할 수 있습니다 &lt;a href=&quot;#try/1&quot;&gt; &lt;code&gt;try/1&lt;/code&gt; &lt;/a&gt; 오류가 발생할 때 또한 성공하고있다. 종료 신호를 수신하면 프로세스가 갑자기 종료되어 프로세스 가 정상적으로 종료되므로 &lt;code&gt;after&lt;/code&gt; 절이 실행되지는 않습니다. 다행히 Elixir의 대부분의 리소스 (예 : 열린 파일, ETS 테이블, 포트, 소켓 등)는 소유 프로세스에 연결되거나 모니터링되며 프로세스가 종료되면 자동으로 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="d9b71baa3ec4aca419614eb83a6884fce9738af0" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;else&lt;/code&gt; option can be given to modify what is being returned from &lt;code&gt;with&lt;/code&gt; in the case of a failed match:</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt; 옵션에서 반환되는 내용 수정 주어질 수 &lt;code&gt;with&lt;/code&gt; 실패한 경기의 경우 :</target>
        </trans-unit>
        <trans-unit id="ff7e359bf597a6fd9ce8084d91ed80c5b7ad85f6" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;else&lt;/code&gt; option can be given to specify the opposite:</source>
          <target state="translated">&lt;code&gt;else&lt;/code&gt; 옵션은 반대를 지정 주어질 수있다 :</target>
        </trans-unit>
        <trans-unit id="e95cabc5495eb242ab85459b1aeff5cf96a48942" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;io_device&lt;/code&gt; returned from this call can be used as an argument to the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module functions.</source>
          <target state="translated">이 호출에서 반환 된 &lt;code&gt;io_device&lt;/code&gt; 는 &lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 모듈 함수 의 인수로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f97b9473a3f0b32057fd9dcd3bc6ae93dc6f50c3" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;edit script&lt;/em&gt; is a keyword list. Each key describes the &quot;editing action&quot; to take in order to bring &lt;code&gt;list1&lt;/code&gt; closer to being equal to &lt;code&gt;list2&lt;/code&gt;; a key can be &lt;code&gt;:eq&lt;/code&gt;, &lt;code&gt;:ins&lt;/code&gt;, or &lt;code&gt;:del&lt;/code&gt;. Each value is a sublist of either &lt;code&gt;list1&lt;/code&gt; or &lt;code&gt;list2&lt;/code&gt; that should be inserted (if the corresponding key &lt;code&gt;:ins&lt;/code&gt;), deleted (if the corresponding key is &lt;code&gt;:del&lt;/code&gt;), or left alone (if the corresponding key is &lt;code&gt;:eq&lt;/code&gt;) in &lt;code&gt;list1&lt;/code&gt; in order to be closer to &lt;code&gt;list2&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;편집 스크립트는&lt;/em&gt; 키워드 목록입니다. 각 키는 &lt;code&gt;list1&lt;/code&gt; 을 &lt;code&gt;list2&lt;/code&gt; 와 더 가깝게 하기 위해 수행 할 &quot;편집 작업&quot;을 설명합니다 . 키는 &lt;code&gt;:eq&lt;/code&gt; , &lt;code&gt;:ins&lt;/code&gt; 또는 &lt;code&gt;:del&lt;/code&gt; 일 수 있습니다. 각 값은 하나의 서브리스트 인 &lt;code&gt;list1&lt;/code&gt; 또는 &lt;code&gt;list2&lt;/code&gt; (해당 키 경우 삽입한다 &lt;code&gt;:ins&lt;/code&gt; (해당 키 인 경우, 삭제) &lt;code&gt;:del&lt;/code&gt; ) 또는 (대응하는 키인지 방치 &lt;code&gt;:eq&lt;/code&gt; )의 &lt;code&gt;list1&lt;/code&gt; 순서대로 &lt;code&gt;list2&lt;/code&gt; 에 더 가깝습니다 .</target>
        </trans-unit>
        <trans-unit id="b968d4ec51b4353a379f80bf32b0dc9347be2642" translate="yes" xml:space="preserve">
          <source>An IO device may be an atom or a PID. In case it is an atom, the atom must be the name of a registered process. In addition, Elixir provides two shortcuts:</source>
          <target state="translated">IO 장치는 원자 또는 PID 일 수 있습니다. 원자 인 경우 원자는 등록 된 프로세스의 이름이어야합니다. 또한 Elixir는 두 가지 단축키를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d60cf8ae86edc9af73dfcd3cc01f5bc137486aa4" translate="yes" xml:space="preserve">
          <source>An agent can have its code hot swapped live by simply passing a module, function, and arguments tuple to the update instruction. For example, imagine you have an agent named &lt;code&gt;:sample&lt;/code&gt; and you want to convert its inner state from a keyword list to a map. It can be done with the following instruction:</source>
          <target state="translated">에이전트는 단순히 모듈, 함수 및 인수 튜플을 업데이트 명령에 전달하여 코드를 핫스왑 할 수 있습니다. 예를 들어, 이름이 &lt;code&gt;:sample&lt;/code&gt; 인 에이전트가 있고 내부 상태를 키워드 목록에서 맵으로 변환하려고한다고 가정하십시오. 다음 명령으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b354895b4d9f46ba32dcc5d6d21ad6dbac64a90c" translate="yes" xml:space="preserve">
          <source>An agent is bound to the same name registration rules as GenServers. Read more about it in the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">에이전트는 GenServer와 동일한 이름 등록 규칙에 바인딩됩니다. 이에 대한 자세한 내용은 &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2d060fe1a8daedc42f287a49cf8e64646cafb9fe" translate="yes" xml:space="preserve">
          <source>An alias in Elixir is a capitalized identifier (like &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Keyword&lt;/code&gt;, etc) which is converted to an atom during compilation. For instance, the &lt;code&gt;String&lt;/code&gt; alias translates by default to the atom &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt;:</source>
          <target state="translated">Elixir의 별칭은 컴파일하는 동안 원자로 변환 되는 대문자 식별자 (예 : &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Keyword&lt;/code&gt; 등)입니다. 예를 들어, &lt;code&gt;String&lt;/code&gt; 별명은 기본적으로 atom &lt;code&gt;:&quot;Elixir.String&quot;&lt;/code&gt; 으로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="f1c5142518fdf011cadf3f17245bcd8f2a562ce8" translate="yes" xml:space="preserve">
          <source>An application is a component implementing some specific functionality, with a standardized directory structure, configuration, and lifecycle. Applications are &lt;em&gt;loaded&lt;/em&gt;, &lt;em&gt;started&lt;/em&gt;, and &lt;em&gt;stopped&lt;/em&gt;.</source>
          <target state="translated">응용 프로그램은 표준화 된 디렉토리 구조, 구성 및 수명주기와 함께 특정 기능을 구현하는 구성 요소입니다. 응용 프로그램이 &lt;em&gt;로드&lt;/em&gt; , &lt;em&gt;시작&lt;/em&gt; 및 &lt;em&gt;중지되었습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e3fcb6166c3639e8ba7a2f7130be093979e1d4e4" translate="yes" xml:space="preserve">
          <source>An atom is a constant whose value is its own name. Some other languages call these symbols. They are often useful to enumerate over distinct values, such as:</source>
          <target state="translated">원자는 값이 자신의 이름 인 상수입니다. 다른 언어는 이러한 기호를 호출합니다. 다음과 같은 고유 한 값을 열거하는 데 종종 유용합니다.</target>
        </trans-unit>
        <trans-unit id="86fb449cced27f4191bdd440f9d6ef1683f1583a" translate="yes" xml:space="preserve">
          <source>An attempt to call a macro that was not loaded will raise an error.</source>
          <target state="translated">로드되지 않은 매크로를 호출하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="be3bd9f0eca00ecaf433384dd9dcab4453a5b9a4" translate="yes" xml:space="preserve">
          <source>An easy way to do so is by sending a synchronous request to the registry before we do the bucket lookup. The &lt;code&gt;Agent.stop/2&lt;/code&gt; operation is synchronous and only returns after the bucket process terminates and all &lt;code&gt;:DOWN&lt;/code&gt; messages are delivered. Therefore, once &lt;code&gt;Agent.stop/2&lt;/code&gt; returns, the registry has already received the &lt;code&gt;:DOWN&lt;/code&gt; message but it may not have processed it yet. In order to guarantee the processing of the &lt;code&gt;:DOWN&lt;/code&gt; message, we can do a synchronous request. Since messages are processed in order, once the registry replies to the synchronous request, then the &lt;code&gt;:DOWN&lt;/code&gt; message will definitely have been processed.</source>
          <target state="translated">버킷 조회를 수행하기 전에 동기식 요청을 레지스트리에 전송하는 것이 쉬운 방법입니다. &lt;code&gt;Agent.stop/2&lt;/code&gt; 작업은 동기 만 반환 버킷 프로세스 종료 및 모든 이후 &lt;code&gt;:DOWN&lt;/code&gt; 메시지가 전달됩니다. 따라서 &lt;code&gt;Agent.stop/2&lt;/code&gt; 가 반환되면 레지스트리는 이미 &lt;code&gt;:DOWN&lt;/code&gt; 메시지를 받았지만 아직 처리하지 않았을 수 있습니다. &lt;code&gt;:DOWN&lt;/code&gt; 메시지 의 처리를 보장하기 위해 동기 요청을 수행 할 수 있습니다. 메시지가 순서대로 처리되므로 레지스트리가 동기 요청에 응답하면 &lt;code&gt;:DOWN&lt;/code&gt; 메시지가 확실히 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="bc95a79f72a6064f19e08b29349826dd25b216ee" translate="yes" xml:space="preserve">
          <source>An empty list can be passed to avoid stacktrace printing.</source>
          <target state="translated">스택 트레이스 인쇄를 방지하기 위해 빈 목록을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="276e3d577cef8507d9164a96e53206098957da90" translate="yes" xml:space="preserve">
          <source>An empty list if there is no match.</source>
          <target state="translated">일치하는 항목이 없으면 빈 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f6764a9eb225a20637ece5e74ca6e79cd54f249b" translate="yes" xml:space="preserve">
          <source>An empty list will be returned if there is no match.</source>
          <target state="translated">일치하는 항목이 없으면 빈 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2c7a57e0b595be7bebd781fac5740e7fc7f12ace" translate="yes" xml:space="preserve">
          <source>An empty string will always match:</source>
          <target state="translated">빈 문자열은 항상 다음과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bb794abcdf1956bbd61a3d6b9cb82432c85ee4f0" translate="yes" xml:space="preserve">
          <source>An empty suffix will always match:</source>
          <target state="translated">빈 접미사는 항상 다음과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bc88b4de65545bb70648538e7fb3eb0cf86cc242" translate="yes" xml:space="preserve">
          <source>An engine may also &lt;code&gt;use EEx.Engine&lt;/code&gt; to get the default behaviour but this is not advised. In such cases, if any of the callbacks are overridden, they must call &lt;code&gt;super()&lt;/code&gt; to delegate to the underlying &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;EEx.Engine&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">엔진은 기본 동작을 얻기 &lt;code&gt;use EEx.Engine&lt;/code&gt; 을 사용할 수도 있지만 권장되지는 않습니다. 이러한 경우 콜백이 재정의되면 기본 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;EEx.Engine&lt;/code&gt; &lt;/a&gt; 에 위임하려면 &lt;code&gt;super()&lt;/code&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2319178933b7fc280516f48198d763f0d06241ea" translate="yes" xml:space="preserve">
          <source>An engine needs to implement all callbacks below.</source>
          <target state="translated">엔진은 아래의 모든 콜백을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d57834eea31257f109e7c789d7d41f86df67542" translate="yes" xml:space="preserve">
          <source>An error is raised if the accessed structure is not a list:</source>
          <target state="translated">액세스 한 구조가 목록이 아닌 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5f8f5a5cd7e9dceea4cbf840417ae0c08edc2e95" translate="yes" xml:space="preserve">
          <source>An error is raised if the accessed structure is not a map or a struct:</source>
          <target state="translated">액세스 한 구조가 맵 또는 구조체가 아닌 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="50fb59be68cf5f14388edcb66f9d042d984c8dde" translate="yes" xml:space="preserve">
          <source>An error is raised if the accessed structure is not a map/struct:</source>
          <target state="translated">액세스 한 구조가 맵 / 구조가 아닌 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="55f9d11748bcf3c144604b93c6b2ae25f8aeccb1" translate="yes" xml:space="preserve">
          <source>An error is raised if the accessed structure is not a tuple:</source>
          <target state="translated">액세스 한 구조가 튜플이 아닌 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="de94d63a6d219c4ead87b23e065fc7de46de12f5" translate="yes" xml:space="preserve">
          <source>An error is raised if the predicate is not a function or is of the incorrect arity:</source>
          <target state="translated">술어가 기능이 아니거나 올바르지 않은 arity 인 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8b078cb3fc34c37337f004467d0ce9378efe754a" translate="yes" xml:space="preserve">
          <source>An error occurred and it will be handled by a different mechanism than the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;. Likely this approach involves calling &lt;a href=&quot;supervisor#restart_child/2&quot;&gt;&lt;code&gt;Supervisor.restart_child/2&lt;/code&gt;&lt;/a&gt; after a delay to attempt a restart.</source>
          <target state="translated">오류가 발생했으며 &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 와 다른 메커니즘으로 처리됩니다 . 이 방법은 지연 후 &lt;a href=&quot;supervisor#restart_child/2&quot;&gt; &lt;code&gt;Supervisor.restart_child/2&lt;/code&gt; &lt;/a&gt; 를 호출 하여 재시작을 시도하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee6f2f4da896a18384f200b0e36a0f349ec99076" translate="yes" xml:space="preserve">
          <source>An escript is an executable that can be invoked from the command line. An escript can run on any machine that has Erlang/OTP installed and by default does not require Elixir to be installed, as Elixir is embedded as part of the escript.</source>
          <target state="translated">escript는 명령 줄에서 호출 할 수있는 실행 파일입니다. Erlang / OTP가 설치된 모든 컴퓨터에서 escript를 실행할 수 있으며, Elixir가 escript의 일부로 내장되어 있기 때문에 기본적으로 Elixir를 설치할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="21ae8235dad3d0eb05c1b7a4b8d8a02b347ddf84" translate="yes" xml:space="preserve">
          <source>An instance of &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; must not be modified by hand. If you need to create a custom environment to pass to &lt;a href=&quot;code#eval_quoted/3&quot;&gt;&lt;code&gt;Code.eval_quoted/3&lt;/code&gt;&lt;/a&gt;, use the following trick:</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt; 인스턴스는 직접 수정해서는 안됩니다. &lt;a href=&quot;code#eval_quoted/3&quot;&gt; &lt;code&gt;Code.eval_quoted/3&lt;/code&gt; &lt;/a&gt; 에 전달할 사용자 정의 환경을 작성해야하는 경우 다음 트릭을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dd8bc729544e66eee698242f46c5404236f10a6e" translate="yes" xml:space="preserve">
          <source>An integer indicating the maximum number of columns to use in output. The default value is 80 columns. The actual output width is the minimum of this number and result of &lt;code&gt;:io.columns&lt;/code&gt;. This way you can configure IEx to be your largest screen size and it should always take up the full width of your current terminal screen.</source>
          <target state="translated">출력에 사용할 최대 열 수를 나타내는 정수입니다. 기본값은 80 열입니다. 실제 출력 너비는이 숫자의 최소값이며 결과는 &lt;code&gt;:io.columns&lt;/code&gt; 입니다. 이렇게하면 IEx를 가장 큰 화면 크기로 구성 할 수 있으며 항상 현재 터미널 화면의 전체 너비를 차지해야합니다.</target>
        </trans-unit>
        <trans-unit id="62dfd3ff7081b119a8a16043b2a10c06d4c45481" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;after&lt;/code&gt; clause can be given in case the message was not received after the given timeout period, specified in milliseconds:</source>
          <target state="translated">지정된 시간 초과 기간 이후에 메시지가 수신되지 않은 경우 (밀리 초로 지정된 경우) 선택적 &lt;code&gt;after&lt;/code&gt; 절을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="509d438b27e12dd94c38e2a190b7ee190fb17b57" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;base&lt;/code&gt; to the corresponding integer can be provided. If &lt;code&gt;base&lt;/code&gt; is not given, 10 will be used.</source>
          <target state="translated">해당 정수에 대한 선택적 &lt;code&gt;base&lt;/code&gt; 이 제공 될 수 있습니다. 경우 &lt;code&gt;base&lt;/code&gt; 주어지지, 10이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bda79df01bfb65a34e0eb465b572e1c22d155d69" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;base&lt;/code&gt; value may be provided representing the radix for the &lt;code&gt;digits&lt;/code&gt;. Base has to be an integer greater than or equal to &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;digits&lt;/code&gt; 의 기수를 나타내는 선택적 &lt;code&gt;base&lt;/code&gt; 값이 제공 될 수 있습니다 . 밑은 &lt;code&gt;2&lt;/code&gt; 이상의 정수 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="5139348d1208b18f1412d9ff5406b136dc7222e8" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;base&lt;/code&gt; value may be provided representing the radix for the returned digits. This one must be an integer &amp;gt;= 2.</source>
          <target state="translated">반환 된 숫자의 기수를 나타내는 선택적 &lt;code&gt;base&lt;/code&gt; 값이 제공 될 수 있습니다. 이것은 정수&amp;gt; = 2 여야합니다.</target>
        </trans-unit>
        <trans-unit id="68a979cd20856e6e7b0398abc497d56ec40c554a" translate="yes" xml:space="preserve">
          <source>An optional boolean parameter can be passed to enable or disable emitting actual ANSI codes. When &lt;code&gt;false&lt;/code&gt;, no ANSI codes will be emitted. By default checks if ANSI is enabled using the &lt;a href=&quot;#enabled?/0&quot;&gt;&lt;code&gt;enabled?/0&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">실제 ANSI 코드 방출을 활성화 또는 비활성화하기 위해 선택적 부울 매개 변수를 전달할 수 있습니다. 때 &lt;code&gt;false&lt;/code&gt; , 더 ANSI 코드가 방출되지 않습니다. 기본적으로 &lt;a href=&quot;#enabled?/0&quot;&gt; &lt;code&gt;enabled?/0&lt;/code&gt; &lt;/a&gt; 기능을 사용하여 ANSI가 활성화되어 있는지 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="141cb8c089b77fc45a4b599501be2124087d63c3" translate="yes" xml:space="preserve">
          <source>An optional boolean parameter can be passed to enable or disable emitting actual ANSI codes. When &lt;code&gt;false&lt;/code&gt;, no ANSI codes will emitted. By default checks if ANSI is enabled using the &lt;a href=&quot;#enabled?/0&quot;&gt;&lt;code&gt;enabled?/0&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">실제 ANSI 코드 방출을 활성화 또는 비활성화하기 위해 선택적 부울 매개 변수를 전달할 수 있습니다. 때 &lt;code&gt;false&lt;/code&gt; , 더 ANSI 코드가 방출되지 않습니다. 기본적으로 &lt;a href=&quot;#enabled?/0&quot;&gt; &lt;code&gt;enabled?/0&lt;/code&gt; &lt;/a&gt; 기능을 사용하여 ANSI가 활성화되어 있는지 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="670e0435cab9da74bff554f172d6191175f5b29a" translate="yes" xml:space="preserve">
          <source>An overridable function is lazily defined, allowing a developer to customize it. See &lt;a href=&quot;kernel#defoverridable/1&quot;&gt;&lt;code&gt;Kernel.defoverridable/1&lt;/code&gt;&lt;/a&gt; for more information and documentation.</source>
          <target state="translated">재정의 가능한 함수는 느리게 정의되어 개발자가이를 사용자 지정할 수 있습니다. 자세한 내용과 설명서는 &lt;a href=&quot;kernel#defoverridable/1&quot;&gt; &lt;code&gt;Kernel.defoverridable/1&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f06ca58408ebbb2e2d18da83ab38dd0e2381bfd3" translate="yes" xml:space="preserve">
          <source>An overridable function is lazily defined, allowing a developer to override it.</source>
          <target state="translated">재정의 가능한 함수가 느리게 정의되어 개발자가이를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="735f79f261a0a1398e39bb2ba9f23bdd5b445481" translate="yes" xml:space="preserve">
          <source>An unknown key:</source>
          <target state="translated">알 수없는 키 :</target>
        </trans-unit>
        <trans-unit id="4eb360277b153c599c984a044f3a3b8d7442bbcf" translate="yes" xml:space="preserve">
          <source>An update operation specific for structs is also available:</source>
          <target state="translated">구조체에 특정한 업데이트 작업도 가능합니다 :</target>
        </trans-unit>
        <trans-unit id="dbebd5f66bf57539f1cae5d05912dfd58e43605d" translate="yes" xml:space="preserve">
          <source>Ancestor and Caller Tracking</source>
          <target state="translated">조상 및 발신자 추적</target>
        </trans-unit>
        <trans-unit id="4bf59e857bc43e008d05f39c6798933eabe92a7b" translate="yes" xml:space="preserve">
          <source>And &lt;code&gt;:greek&lt;/code&gt; properly handles the context sensitive sigma in Greek:</source>
          <target state="translated">그리고 &lt;code&gt;:greek&lt;/code&gt; 는 그리스어 에서 상황에 민감한 시그마를 올바르게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="57f523660878f0ae5422d81e21ff0f2d992fab43" translate="yes" xml:space="preserve">
          <source>And also in umbrella dependencies:</source>
          <target state="translated">또한 우산 의존성에서 :</target>
        </trans-unit>
        <trans-unit id="7475479141d0c8752fe853a18f88400575acc441" translate="yes" xml:space="preserve">
          <source>And also when comparing different types:</source>
          <target state="translated">또한 다른 유형을 비교할 때 :</target>
        </trans-unit>
        <trans-unit id="ddcbca0482883ea8e4091eaadee210a79869f2e4" translate="yes" xml:space="preserve">
          <source>And execute it as:</source>
          <target state="translated">그리고 다음과 같이 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="419827a34eea4ec811bd9357533fc68ae720c124" translate="yes" xml:space="preserve">
          <source>And finally successfully boot it:</source>
          <target state="translated">그리고 마지막으로 성공적으로 부팅하십시오.</target>
        </trans-unit>
        <trans-unit id="72688afe4af65ced53cacec5689d360d88950fb2" translate="yes" xml:space="preserve">
          <source>And here is an example of how you can define &lt;code&gt;MyConsoleLogger.format/4&lt;/code&gt; from the above configuration:</source>
          <target state="translated">위 구성에서 &lt;code&gt;MyConsoleLogger.format/4&lt;/code&gt; 를 정의하는 방법의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f0d1bd4c59aaee11683223b356559849183e2699" translate="yes" xml:space="preserve">
          <source>And it then returned a quoted expression as follows:</source>
          <target state="translated">그런 다음 다음과 같이 따옴표로 묶은 표현식을 반환했습니다.</target>
        </trans-unit>
        <trans-unit id="e0b5f0362b86f72e75548b22466dd13d5a1cf84b" translate="yes" xml:space="preserve">
          <source>And it will provide the same behaviour. You may use &lt;code&gt;do:&lt;/code&gt; for one-liners but always use &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; for functions spanning multiple lines.</source>
          <target state="translated">그리고 그것은 같은 행동을 제공 할 것입니다. 하나의 라이너에는 &lt;code&gt;do:&lt;/code&gt; 를 사용할 수 있지만 여러 줄에 걸친 함수 에는 항상 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3be6c2d0cb8b49833135e767d2d7a4fbac9b3c5" translate="yes" xml:space="preserve">
          <source>And it works!</source>
          <target state="translated">그리고 작동합니다!</target>
        </trans-unit>
        <trans-unit id="e5ff9d5b10d267dee51c69e79f2c679b450ef8f6" translate="yes" xml:space="preserve">
          <source>And let&amp;rsquo;s connect to it and issue a request in another terminal:</source>
          <target state="translated">연결하고 다른 터미널에서 요청을 발행하십시오.</target>
        </trans-unit>
        <trans-unit id="aef6f548c63d313f3e6febdf170c4b53e23d4948" translate="yes" xml:space="preserve">
          <source>And let&amp;rsquo;s try to start our application again:</source>
          <target state="translated">그리고 우리의 응용 프로그램을 다시 시작해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="0a3e48a60746f6b847d997fa0fbe9c121a13a5e1" translate="yes" xml:space="preserve">
          <source>And more</source>
          <target state="translated">그리고 더</target>
        </trans-unit>
        <trans-unit id="3975c92bca370daedd767ed422d2ad2a60b72331" translate="yes" xml:space="preserve">
          <source>And now let&amp;rsquo;s assemble it once more:</source>
          <target state="translated">이제 다시 한 번 조립하겠습니다 :</target>
        </trans-unit>
        <trans-unit id="d14e640d4bda56647f06d50190912bc628cfe672" translate="yes" xml:space="preserve">
          <source>And now let&amp;rsquo;s assemble it:</source>
          <target state="translated">이제 조립하자 :</target>
        </trans-unit>
        <trans-unit id="450675268dca95ea69df946fd7052040689b26b5" translate="yes" xml:space="preserve">
          <source>And now run tests with:</source>
          <target state="translated">이제 다음을 사용하여 테스트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="91c1d6064e2642eec275bb2697301c83bf002443" translate="yes" xml:space="preserve">
          <source>And play a bit with agents:</source>
          <target state="translated">그리고 에이전트들과 조금 놀아보십시오.</target>
        </trans-unit>
        <trans-unit id="2dadb42bf111f89bf23b4940e02183ac02eb51a8" translate="yes" xml:space="preserve">
          <source>And play with those definitions:</source>
          <target state="translated">그리고 그 정의를 가지고 놀아 라 :</target>
        </trans-unit>
        <trans-unit id="16ce5c350460be5d7d537d13e7f1131d9b8fad50" translate="yes" xml:space="preserve">
          <source>And the variable can be defined in the match itself (prior to its use):</source>
          <target state="translated">그리고 변수는 사용하기 전에 일치 자체에서 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e8b021dea943d8ac4bd67ab292eb615322244df" translate="yes" xml:space="preserve">
          <source>And then a module may use it as:</source>
          <target state="translated">그런 다음 모듈은 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9c544212c0f62fab7a929bdf6254c14ee92c57a" translate="yes" xml:space="preserve">
          <source>And then passing it to the supervisor:</source>
          <target state="translated">그런 다음 감독자에게 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="75d0f7371704fa5ce1ab31b056a3610c4f01dd6d" translate="yes" xml:space="preserve">
          <source>And then start it:</source>
          <target state="translated">그런 다음 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="46195fee28b6f3924859b2e05c7f84e26d2f56e8" translate="yes" xml:space="preserve">
          <source>And then you can define the implementations specific to the test environment inside &lt;code&gt;test/support/some_file.ex&lt;/code&gt;.</source>
          <target state="translated">그런 다음 &lt;code&gt;test/support/some_file.ex&lt;/code&gt; 내에 테스트 환경에 특정한 구현을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="462519e135281467088215ccc649f512ae9b84ce" translate="yes" xml:space="preserve">
          <source>Anonymous functions</source>
          <target state="translated">익명 함수</target>
        </trans-unit>
        <trans-unit id="bb9a933ae349228e32e1f073b740f4f65715b58c" translate="yes" xml:space="preserve">
          <source>Anonymous functions are reported as -func/arity-anonfn-count-, where func is the name of the enclosing function. Convert to &quot;anonymous fn in func/arity&quot;</source>
          <target state="translated">익명 함수는 -func / arity-anonfn-count-로보고됩니다. 여기서 func는 둘러싸는 함수의 이름입니다. &quot;func / arity의 익명 fn&quot;으로 변환</target>
        </trans-unit>
        <trans-unit id="8e2e0b675b3d9b8858e0c45385fd95f27e5170f3" translate="yes" xml:space="preserve">
          <source>Anonymous functions can also have multiple clauses. All clauses should expect the same number of arguments:</source>
          <target state="translated">익명 함수는 여러 절을 가질 수도 있습니다. 모든 절은 동일한 개수의 인수를 예상해야합니다.</target>
        </trans-unit>
        <trans-unit id="bfa301a3c21795199d13e7b6588d342af94a24a1" translate="yes" xml:space="preserve">
          <source>Anonymous functions in Elixir are also identified by the number of arguments they receive. We can check if a function is of any given arity by using &lt;code&gt;is_function/2&lt;/code&gt;:</source>
          <target state="translated">엘릭서의 익명 함수는 또한 그들이받는 인수의 수로 식별됩니다. &lt;code&gt;is_function/2&lt;/code&gt; 를 사용하여 함수가 주어진 arity인지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc3478c83b0f2c05d9c65b14ae56037cbfc0b5c6" translate="yes" xml:space="preserve">
          <source>Anonymous functions with no expression after &lt;code&gt;-&amp;gt;&lt;/code&gt;</source>
          <target state="translated">뒤에 표현식이없는 익명 함수 &lt;code&gt;-&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f9ea76dc507dd1537d2a78a7f363a18e4775cd5" translate="yes" xml:space="preserve">
          <source>Another alternative to &lt;code&gt;@derive&lt;/code&gt; is to explicitly tell the protocol to fallback to &lt;code&gt;Any&lt;/code&gt; when an implementation cannot be found. This can be achieved by setting &lt;code&gt;@fallback_to_any&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in the protocol definition:</source>
          <target state="translated">&lt;code&gt;@derive&lt;/code&gt; 의 또 다른 대안 은 구현을 찾을 수 없을 때 프로토콜을 &lt;code&gt;Any&lt;/code&gt; 로 대체하도록 명시 적으로 지시 하는 것입니다. 프로토콜 정의에서 &lt;code&gt;@fallback_to_any&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정 하면 됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ce311858ef69483871a91631dbd1d6d4dde210e" translate="yes" xml:space="preserve">
          <source>Another approach is to disable protocol consolidation during tests in your mix.exs:</source>
          <target state="translated">또 다른 방법은 mix.exs에서 테스트하는 동안 프로토콜 통합을 비활성화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd6916cf153042850a0d4907b1527f29fbe844df" translate="yes" xml:space="preserve">
          <source>Another common metadata is &lt;code&gt;:deprecated&lt;/code&gt;, which emits a warning in the documentation, explaining that its usage is discouraged:</source>
          <target state="translated">또 다른 일반적인 메타 데이터는 &lt;code&gt;:deprecated&lt;/code&gt; 로 , 설명서에 경고가 표시되고 사용법이 권장되지 않는다고 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2b8f4fcb03038d3204cf32a1e07964ca7ae1e5e9" translate="yes" xml:space="preserve">
          <source>Another common need in releases is to compute configuration when the release runs, not when the release is assembled. The &lt;code&gt;config/config.exs&lt;/code&gt; file we defined at the beginning of this chapter runs on every Mix command, when we build, test and run our application. This is great, because it provides a unified configuration for dev, test, and prod.</source>
          <target state="translated">릴리스에서 또 다른 일반적인 요구 사항은 릴리스가 조립 될 때가 아니라 릴리스가 실행될 때 구성을 계산하는 것입니다. &lt;code&gt;config/config.exs&lt;/code&gt; 우리가 테스트를 구축하고 우리의 응용 프로그램을 실행할 때, 우리는 모든 믹스 명령에 대한이 장 실행의 시작 부분에 정의 된 파일. dev, test 및 prod에 대한 통합 구성을 제공하기 때문에 훌륭합니다.</target>
        </trans-unit>
        <trans-unit id="d2d6bcdc6f9dd5a9edc0684e098b03c84e550047" translate="yes" xml:space="preserve">
          <source>Another example comes from &lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;the ExUnit framework&lt;/a&gt; which uses module attributes as annotation and storage:</source>
          <target state="translated">또 다른 예는 주석 및 스토리지로 모듈 속성을 사용 &lt;a href=&quot;https://hexdocs.pm/ex_unit/&quot;&gt;하는 ExUnit 프레임 워크&lt;/a&gt; 에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa358ec240cab1628444ba9ff9bd76a8046b33fc" translate="yes" xml:space="preserve">
          <source>Another example while using an imported or local function:</source>
          <target state="translated">가져온 함수 또는 로컬 함수를 사용하는 또 다른 예 :</target>
        </trans-unit>
        <trans-unit id="dbe451732076cc22d41fb430c0f2cb877351509f" translate="yes" xml:space="preserve">
          <source>Another important distinction is that &lt;a href=&quot;module#create/3&quot;&gt;&lt;code&gt;Module.create/3&lt;/code&gt;&lt;/a&gt; allows you to control the environment variables used when defining the module, while &lt;a href=&quot;kernel#defmodule/2&quot;&gt;&lt;code&gt;Kernel.defmodule/2&lt;/code&gt;&lt;/a&gt; automatically uses the environment it is invoked at.</source>
          <target state="translated">또 다른 중요한 차이점은 &lt;a href=&quot;module#create/3&quot;&gt; &lt;code&gt;Module.create/3&lt;/code&gt; 를&lt;/a&gt; 사용하면 모듈을 정의 할 때 사용되는 환경 변수를 제어 할 수 있지만 &lt;a href=&quot;kernel#defmodule/2&quot;&gt; &lt;code&gt;Kernel.defmodule/2&lt;/code&gt; &lt;/a&gt; 는 호출 된 환경을 자동으로 사용한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5b885d633868b72a3319e18e467d568e3f820f4a" translate="yes" xml:space="preserve">
          <source>Another interesting function is &lt;code&gt;Stream.resource/3&lt;/code&gt; which can be used to wrap around resources, guaranteeing they are opened right before enumeration and closed afterwards, even in the case of failures. For example, we can use it to stream a file:</source>
          <target state="translated">또 다른 흥미로운 기능은 &lt;code&gt;Stream.resource/3&lt;/code&gt; 로, 리소스를 감싸는 데 사용될 수 있으며, 리소스가 열거되기 직전에 열리고 실패한 경우에도 닫힙니다. 예를 들어 파일을 스트리밍하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99dd3549eee17cdcf074d50bea27d1a61c1fe1b2" translate="yes" xml:space="preserve">
          <source>Another interesting property of maps is that they provide their own syntax for accessing atom keys:</source>
          <target state="translated">맵의 또 다른 흥미로운 속성은 원자 키에 액세스하기위한 고유 구문을 제공한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9a1777838dac8ee28fe902db2218ed802abd5034" translate="yes" xml:space="preserve">
          <source>Another option is to make the routing table configurable. This means we can change the routing table on specific tests to assert for specific behaviour. As we will learn in the next chapter, changing the routing table this way has the downside that those particular tests can no longer run asynchronously, so it is a technique that should be used sparingly.</source>
          <target state="translated">다른 옵션은 라우팅 테이블을 구성 할 수있게하는 것입니다. 이것은 우리가 특정 행동에 대해 주장하기 위해 특정 테스트에서 라우팅 테이블을 변경할 수 있음을 의미합니다. 다음 장에서 배우 겠지만,이 방법으로 라우팅 테이블을 변경하면 이러한 특정 테스트를 더 이상 비동기식으로 실행할 수 없다는 단점이 있으므로 드물게 사용해야하는 기술입니다.</target>
        </trans-unit>
        <trans-unit id="24a9327535a522b50c90a3875aaafa4123543d75" translate="yes" xml:space="preserve">
          <source>Another use case for tags and filters is to exclude all tests that have a particular tag by default, regardless of its value, and include only a certain subset:</source>
          <target state="translated">태그 및 필터의 또 다른 사용 사례는 값에 관계없이 기본적으로 특정 태그가있는 모든 테스트를 제외하고 특정 하위 집합 만 포함시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="726155227c06c751e3edc99ac5a96aa24ef74e16" translate="yes" xml:space="preserve">
          <source>Another useful example is the &lt;code&gt;String.Chars&lt;/code&gt; protocol, which specifies how to convert a data structure with characters to a string. It&amp;rsquo;s exposed via the &lt;code&gt;to_string&lt;/code&gt; function:</source>
          <target state="translated">또 다른 유용한 예는 문자가 포함 된 데이터 구조를 문자열로 변환하는 방법을 지정하는 &lt;code&gt;String.Chars&lt;/code&gt; 프로토콜입니다. &lt;code&gt;to_string&lt;/code&gt; 함수 를 통해 노출됩니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
