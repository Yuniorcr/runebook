<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="f364101757fd7b07c462556f8631107344aea9a7" translate="yes" xml:space="preserve">
          <source>Anti-patterns</source>
          <target state="translated">Anti-patterns</target>
        </trans-unit>
        <trans-unit id="bf6f13831a7432164063eab288ffb17f48516527" translate="yes" xml:space="preserve">
          <source>Any Elixir code can be represented using Elixir data structures. The building block of Elixir macros is a tuple with three elements, for example:</source>
          <target state="translated">모든 Elixir 코드는 Elixir 데이터 구조를 사용하여 표현할 수 있습니다. Elixir 매크로의 구성 요소는 다음과 같은 세 가지 요소가 포함 된 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="cc4013b8d32a07ea1cafd334cef7889bf5c90d15" translate="yes" xml:space="preserve">
          <source>Any arbitrary configuration can also be passed to &lt;a href=&quot;#configure/1&quot;&gt;&lt;code&gt;configure/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#start/1&quot;&gt;&lt;code&gt;start/1&lt;/code&gt;&lt;/a&gt;, and these options can then be used in places such as custom formatters. These other options will be ignored by ExUnit itself.</source>
          <target state="translated">임의의 구성을 &lt;a href=&quot;#configure/1&quot;&gt; &lt;code&gt;configure/1&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#start/1&quot;&gt; &lt;code&gt;start/1&lt;/code&gt; &lt;/a&gt; 로 전달할 수도 있으며 이러한 옵션은 사용자 정의 포맷터와 같은 위치에서 사용할 수 있습니다. 이러한 다른 옵션은 ExUnit 자체에서 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ddb0b53128202d492ea01bc6e15be1d122ecf8de" translate="yes" xml:space="preserve">
          <source>Any developer can create their own &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; backend. Since &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; is an event manager powered by &lt;code&gt;:gen_event&lt;/code&gt;, writing a new backend is a matter of creating an event handler, as described in the &lt;a href=&quot;http://erlang.org/doc/man/gen_event.html&quot;&gt;&lt;code&gt;:gen_event&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">모든 개발자는 자신의 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 백엔드를 만들 수 있습니다 . &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;:gen_event&lt;/code&gt; 로 구동되는 이벤트 관리자 이므로 새로운 백엔드 작성은 &lt;a href=&quot;http://erlang.org/doc/man/gen_event.html&quot;&gt; &lt;code&gt;:gen_event&lt;/code&gt; &lt;/a&gt; 문서에 설명 된대로 이벤트 핸들러를 작성하는 문제입니다 .</target>
        </trans-unit>
        <trans-unit id="0eda7adbc051844f9bb1f76988dfdbc8ee614b71" translate="yes" xml:space="preserve">
          <source>Any expression is allowed to serve as a default value, but it won&amp;rsquo;t be evaluated during the function definition. Every time the function is invoked and any of its default values have to be used, the expression for that default value will be evaluated:</source>
          <target state="translated">모든 표현식은 기본값으로 사용할 수 있지만 함수 정의 중에는 평가되지 않습니다. 함수가 호출되고 기본값을 사용해야 할 때마다 해당 기본값에 대한 표현식이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="51294445c2892caace0f93beba65cca2df4db722" translate="yes" xml:space="preserve">
          <source>Any functions may be called when defining a module attribute.</source>
          <target state="translated">모듈 속성을 정의 할 때 모든 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="168da730b1d34c5154e469d6a2c57e8cc938548d" translate="yes" xml:space="preserve">
          <source>Any map/struct that contains the date fields</source>
          <target state="translated">날짜 필드를 포함하는 모든 맵 / 구조</target>
        </trans-unit>
        <trans-unit id="6009b6eb66ee2e5f4fe90dd4f8cc38fa5add92f6" translate="yes" xml:space="preserve">
          <source>Any map/struct that contains the datetime fields</source>
          <target state="translated">날짜 시간 필드를 포함하는 모든 맵 / 구조</target>
        </trans-unit>
        <trans-unit id="bdac0a5a4c31c821fbdf66fa2f00b8ebf1826565" translate="yes" xml:space="preserve">
          <source>Any map/struct that contains the naive_datetime fields</source>
          <target state="translated">naive_datetime 필드를 포함하는 모든 맵 / 구조</target>
        </trans-unit>
        <trans-unit id="c72e818c080afa7ce37cf5ba8b92ceb1c5d794de" translate="yes" xml:space="preserve">
          <source>Any map/struct that contains the time fields</source>
          <target state="translated">시간 필드를 포함하는 모든 맵 / 구조</target>
        </trans-unit>
        <trans-unit id="f0169052fc32e3ac2806fe55bbfa851febc0b349" translate="yes" xml:space="preserve">
          <source>Any module is also able to define its own types and the modules in Elixir are no exception. For example, the &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; module defines a &lt;a href=&quot;t:Range.t/0&quot;&gt;&lt;code&gt;t/0&lt;/code&gt;&lt;/a&gt; type that represents a range: this type can be referred to as &lt;a href=&quot;range#t:t/0&quot;&gt;&lt;code&gt;Range.t/0&lt;/code&gt;&lt;/a&gt;. In a similar fashion, a string is &lt;a href=&quot;string#t:t/0&quot;&gt;&lt;code&gt;String.t/0&lt;/code&gt;&lt;/a&gt;, any enumerable can be &lt;a href=&quot;enum#t:t/0&quot;&gt;&lt;code&gt;Enum.t/0&lt;/code&gt;&lt;/a&gt;, and so on.</source>
          <target state="translated">모든 모듈은 자체 유형을 정의 할 수 있으며 Elixir의 모듈도 예외는 아닙니다. 예를 들어, &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 모듈은 범위 를 나타내는 &lt;a href=&quot;t:Range.t/0&quot;&gt; &lt;code&gt;t/0&lt;/code&gt; &lt;/a&gt; 유형을 정의합니다 .이 유형은 &lt;a href=&quot;range#t:t/0&quot;&gt; &lt;code&gt;Range.t/0&lt;/code&gt; &lt;/a&gt; 이라고 할 수 있습니다 . 비슷한 방식으로 문자열은 &lt;a href=&quot;string#t:t/0&quot;&gt; &lt;code&gt;String.t/0&lt;/code&gt; &lt;/a&gt; 이고 열거 가능한 모든 &lt;a href=&quot;enum#t:t/0&quot;&gt; &lt;code&gt;Enum.t/0&lt;/code&gt; &lt;/a&gt; 등이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8630a55fc792a79de5fdbeb3cf17c110eb8b5440" translate="yes" xml:space="preserve">
          <source>Any module that contains a call to the &lt;a href=&quot;#defexception/1&quot;&gt;&lt;code&gt;defexception/1&lt;/code&gt;&lt;/a&gt; macro automatically implements the &lt;a href=&quot;exception#c:exception/1&quot;&gt;&lt;code&gt;Exception.exception/1&lt;/code&gt;&lt;/a&gt; callback expected by &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt;. For more information, see &lt;a href=&quot;#defexception/1&quot;&gt;&lt;code&gt;defexception/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#defexception/1&quot;&gt; &lt;code&gt;defexception/1&lt;/code&gt; &lt;/a&gt; 매크로에 대한 호출을 포함하는 모든 모듈은 &lt;a href=&quot;#raise/2&quot;&gt; &lt;code&gt;raise/2&lt;/code&gt; 가&lt;/a&gt; 예상 하는 &lt;a href=&quot;exception#c:exception/1&quot;&gt; &lt;code&gt;Exception.exception/1&lt;/code&gt; &lt;/a&gt; 콜백을 자동으로 구현합니다 . 자세한 정보는 &lt;a href=&quot;#defexception/1&quot;&gt; &lt;code&gt;defexception/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75747731e474a8178e05e264cb1563d939c05224" translate="yes" xml:space="preserve">
          <source>Any other exit reason will cause the operating system process to exit with status &lt;code&gt;1&lt;/code&gt; and linked Erlang processes to crash.</source>
          <target state="translated">다른 종료 사유로 인해 운영 체제 프로세스가 상태 &lt;code&gt;1&lt;/code&gt; 로 종료 되고 연결된 Erlang 프로세스가 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="0f5f30288dbfabd82f00bbad3a6e84be7fe32c88" translate="yes" xml:space="preserve">
          <source>Any other value, such as a map or a four-element tuple, must be escaped (&lt;a href=&quot;macro#escape/1&quot;&gt;&lt;code&gt;Macro.escape/1&lt;/code&gt;&lt;/a&gt;) before being introduced into an AST.</source>
          <target state="translated">맵 또는 4 요소 튜플과 같은 다른 값 은 AST에 도입되기 전에 이스케이프되어야합니다 ( &lt;a href=&quot;macro#escape/1&quot;&gt; &lt;code&gt;Macro.escape/1&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="21dbf38e245345b7875ff893e598c955362174cf" translate="yes" xml:space="preserve">
          <source>Any protocol module contains three extra functions:</source>
          <target state="translated">모든 프로토콜 모듈에는 세 가지 추가 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f90ff0f062168c098cc8f21cea2c19c727f8a1e" translate="yes" xml:space="preserve">
          <source>Appends a path to the end of the Erlang VM code path list.</source>
          <target state="translated">Erlang VM 코드 경로 목록 끝에 경로를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b291beb8793f4f3308c463951165dad483715a6c" translate="yes" xml:space="preserve">
          <source>Application</source>
          <target state="translated">Application</target>
        </trans-unit>
        <trans-unit id="97e8780936863ac8125cd13898e95fb6c124a954" translate="yes" xml:space="preserve">
          <source>Application &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">응용 프로그램 &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1631e1c82584aae550c9008087504b1cc7b074ed" translate="yes" xml:space="preserve">
          <source>Application callback modules may also implement the optional callback &lt;a href=&quot;#c:prep_stop/1&quot;&gt;&lt;code&gt;prep_stop/1&lt;/code&gt;&lt;/a&gt;. If present, &lt;a href=&quot;#c:prep_stop/1&quot;&gt;&lt;code&gt;prep_stop/1&lt;/code&gt;&lt;/a&gt; is invoked before the supervision tree is terminated. Its argument is the state returned by &lt;a href=&quot;#c:start/2&quot;&gt;&lt;code&gt;start/2&lt;/code&gt;&lt;/a&gt;, if it did, or &lt;code&gt;[]&lt;/code&gt; otherwise, and its return value is passed to &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">애플리케이션 콜백 모듈은 선택적 콜백 &lt;a href=&quot;#c:prep_stop/1&quot;&gt; &lt;code&gt;prep_stop/1&lt;/code&gt; 을&lt;/a&gt; 구현할 수도 있습니다 . 존재하는 경우 감독 트리가 종료되기 전에 &lt;a href=&quot;#c:prep_stop/1&quot;&gt; &lt;code&gt;prep_stop/1&lt;/code&gt; &lt;/a&gt; 이 호출됩니다. 인수는 &lt;a href=&quot;#c:start/2&quot;&gt; &lt;code&gt;start/2&lt;/code&gt; 에&lt;/a&gt; 의해 리턴 된 상태 이거나 , 그렇지 않으면 &lt;code&gt;[]&lt;/code&gt; 이고, 리턴 값이 &lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; 에&lt;/a&gt; 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="1ce84d4d04cdd60bd8ab75207bda952026831b49" translate="yes" xml:space="preserve">
          <source>Application configuration</source>
          <target state="translated">응용 프로그램 구성</target>
        </trans-unit>
        <trans-unit id="eb463fa74d812fcc05af997894ad4ba18a4c240c" translate="yes" xml:space="preserve">
          <source>Application configuration - must be set before the &lt;code&gt;:logger&lt;/code&gt; application is started</source>
          <target state="translated">응용 프로그램 구성- &lt;code&gt;:logger&lt;/code&gt; 응용 프로그램을 시작 하기 전에 설정해야합니다</target>
        </trans-unit>
        <trans-unit id="6bfdc5f066d27eac11710638a304662a34399413" translate="yes" xml:space="preserve">
          <source>Application environment</source>
          <target state="translated">적용 환경</target>
        </trans-unit>
        <trans-unit id="133263b1a0a761afc7a839c1e0d9f30d4370bf27" translate="yes" xml:space="preserve">
          <source>Applications are &lt;em&gt;loaded&lt;/em&gt;, which means that the runtime finds and processes their resource files:</source>
          <target state="translated">응용 프로그램이 &lt;em&gt;로드됩니다&lt;/em&gt; . 즉, 런타임에서 리소스 파일을 찾아 처리합니다.</target>
        </trans-unit>
        <trans-unit id="72f9cc4dac3452357e96e709303ddb464195b4c3" translate="yes" xml:space="preserve">
          <source>Applications are also &lt;em&gt;started&lt;/em&gt;:</source>
          <target state="translated">응용 프로그램도 &lt;em&gt;시작됩니다&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="8e022aa7ab84d060d734fd766d3347c2181f8ccb" translate="yes" xml:space="preserve">
          <source>Applications are specified in their &lt;a href=&quot;http://erlang.org/doc/man/app.html&quot;&gt;&lt;em&gt;resource file&lt;/em&gt;&lt;/a&gt;, which is a file called &lt;code&gt;APP.app&lt;/code&gt;, where &lt;code&gt;APP&lt;/code&gt; is the application name. For example, the application resource file of the OTP application &lt;code&gt;ex_unit&lt;/code&gt; is called &lt;code&gt;ex_unit.app&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램은 &lt;a href=&quot;http://erlang.org/doc/man/app.html&quot;&gt;&lt;em&gt;리소스&lt;/em&gt;&lt;/a&gt; 파일 ( &lt;code&gt;APP.app&lt;/code&gt; 이라는 파일)에 지정됩니다. 여기서 &lt;code&gt;APP&lt;/code&gt; 는 응용 프로그램 이름입니다. 예를 들어, OTP 애플리케이션 &lt;code&gt;ex_unit&lt;/code&gt; 의 애플리케이션 자원 파일을 ex_unit.app 라고 &lt;code&gt;ex_unit.app&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43a3c55fce58945b7955ada014ceb15badbab6c6" translate="yes" xml:space="preserve">
          <source>Applications are the idiomatic way to package software in Erlang/OTP. To get the idea, they are similar to the &quot;library&quot; concept common in other programming languages, but with some additional characteristics.</source>
          <target state="translated">응용 프로그램은 Erlang / OTP에서 소프트웨어를 포장하는 관용적 방법입니다. 아이디어를 얻기 위해 다른 프로그래밍 언어에서 일반적으로 사용되는 &quot;라이브러리&quot;개념과 유사하지만 몇 가지 추가 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4dbd62a16fa04d91bfc40f06c512edf333a1fbe" translate="yes" xml:space="preserve">
          <source>Applications with supervision tree</source>
          <target state="translated">감독 트리가있는 응용 프로그램</target>
        </trans-unit>
        <trans-unit id="bac054c1e14c519b199d2517df6a0101c94441d1" translate="yes" xml:space="preserve">
          <source>Applies the given function to each element in the &lt;code&gt;enumerable&lt;/code&gt;, storing the result in a list and passing it as the accumulator for the next computation. Uses the first element in the &lt;code&gt;enumerable&lt;/code&gt; as the starting value.</source>
          <target state="translated">주어진 함수를 &lt;code&gt;enumerable&lt;/code&gt; 각 요소에 적용하여 결과를 목록에 저장하고 다음 계산을위한 누적기로 전달합니다. &lt;code&gt;enumerable&lt;/code&gt; 첫 번째 요소를 시작 값으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2f961980e9fba3a80a3fe84a5a33a282dd684b9a" translate="yes" xml:space="preserve">
          <source>Applies the given function to each element in the &lt;code&gt;enumerable&lt;/code&gt;, storing the result in a list and passing it as the accumulator for the next computation. Uses the given &lt;code&gt;acc&lt;/code&gt; as the starting value.</source>
          <target state="translated">주어진 함수를 &lt;code&gt;enumerable&lt;/code&gt; 각 요소에 적용하여 결과를 목록에 저장하고 다음 계산을위한 누적기로 전달합니다. 주어진 &lt;code&gt;acc&lt;/code&gt; 를 시작 값으로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="71a330535e646341a3e67bdc7aa7099b09d7d159" translate="yes" xml:space="preserve">
          <source>Applies the given function to the node metadata if it contains one.</source>
          <target state="translated">지정된 기능이 포함 된 경우 노드 메타 데이터에 지정된 기능을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="41ed7b8f7c8e97d4eaa49d91cf5d985f2894e409" translate="yes" xml:space="preserve">
          <source>ArgumentError</source>
          <target state="translated">ArgumentError</target>
        </trans-unit>
        <trans-unit id="05067852bd2137fdf10aad2ca39e484ed4d4c628" translate="yes" xml:space="preserve">
          <source>ArgumentError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">ArgumentError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="0953d0a8d8a481b72be4dd1a2e649d93e22bf086" translate="yes" xml:space="preserve">
          <source>Arguments given to the alias will be appended to the arguments of the last task in the list, if the last task is a function they will be given as a list of strings to the function.</source>
          <target state="translated">별명에 제공된 인수는 목록에서 마지막 타스크의 인수에 추가됩니다. 마지막 타스크가 함수 인 경우 함수에 문자열 목록으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="655bc33009493f707144bb646531efed13876152" translate="yes" xml:space="preserve">
          <source>Arithmetic addition.</source>
          <target state="translated">산술 추가.</target>
        </trans-unit>
        <trans-unit id="9681d96eaf931c989e28ccf9f0440d77ba06dd99" translate="yes" xml:space="preserve">
          <source>Arithmetic division.</source>
          <target state="translated">산술 나누기.</target>
        </trans-unit>
        <trans-unit id="4a61e0447f1394155d9609b0e8ddd9ef54c528e0" translate="yes" xml:space="preserve">
          <source>Arithmetic multiplication.</source>
          <target state="translated">산술 곱셈.</target>
        </trans-unit>
        <trans-unit id="da79f19cf7e168e8190dfbc95a70f65090f55686" translate="yes" xml:space="preserve">
          <source>Arithmetic subtraction.</source>
          <target state="translated">산술 빼기.</target>
        </trans-unit>
        <trans-unit id="1a3bb43ad05ec69548de8b5dbef76098f6a10101" translate="yes" xml:space="preserve">
          <source>Arithmetic unary minus.</source>
          <target state="translated">산술 단항 빼기.</target>
        </trans-unit>
        <trans-unit id="cf96a5cfba060ff295e5568cfb369fe78d6a4661" translate="yes" xml:space="preserve">
          <source>Arithmetic unary plus.</source>
          <target state="translated">산술 단항 플러스.</target>
        </trans-unit>
        <trans-unit id="5509c94c0f9f738717633e15c4c8dbc85e63a4c9" translate="yes" xml:space="preserve">
          <source>ArithmeticError</source>
          <target state="translated">ArithmeticError</target>
        </trans-unit>
        <trans-unit id="8a7db15e8806afedd47b1c010408683e54e7f2aa" translate="yes" xml:space="preserve">
          <source>ArithmeticError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">ArithmeticError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8a481eb9afcf30f19b235a484387c683a5bc9ce7" translate="yes" xml:space="preserve">
          <source>As &amp;ldquo;constants&amp;rdquo;</source>
          <target state="translated">&quot;상수&quot;로</target>
        </trans-unit>
        <trans-unit id="5a534e4a24eb4e108c8c81b831db9cad75e840a4" translate="yes" xml:space="preserve">
          <source>As IEx evaluates its input line by line, it will first encounter &lt;code&gt;[1, [2], 3]&lt;/code&gt;. As a list is a valid expression, IEx will evaluate it immediately before looking at the next input line. Only then will IEx attempt to evaluate the now incomplete expression &lt;code&gt;|&amp;gt; List.flatten()&lt;/code&gt;, which on its own is missing its left operand. The evaluation thus fails with the above syntax error.</source>
          <target state="translated">IEx는 입력을 한 줄씩 평가할 때 먼저 &lt;code&gt;[1, [2], 3]&lt;/code&gt; 만납니다 . 목록은 유효한 표현식이므로 IEx는 다음 입력 행을보기 전에 즉시 평가합니다. 그런 다음에야 IEx는 현재 불완전한 표현식 &lt;code&gt;|&amp;gt; List.flatten()&lt;/code&gt; 을 평가하려고 시도하는데 , 그 자체에는 왼쪽 피연산자가 없습니다. 따라서 위의 구문 오류로 평가가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="af041e603020699ecc4a407c05175708814edeb5" translate="yes" xml:space="preserve">
          <source>As a library author, it is your responsibility to make sure users are not required to use exceptions for control-flow in their applications. You can follow the same convention as Elixir here, using the name without &lt;code&gt;!&lt;/code&gt; for returning &lt;code&gt;:ok&lt;/code&gt;/&lt;code&gt;:error&lt;/code&gt; tuples and appending &lt;code&gt;!&lt;/code&gt; for a version of the function which raises an exception.</source>
          <target state="translated">라이브러리 작성자는 사용자가 자신의 응용 프로그램에서 제어 흐름에 예외를 사용할 필요가 없도록해야합니다. &lt;code&gt;!&lt;/code&gt; 없이 이름을 사용하여 여기에서 Elixir와 동일한 규칙을 따를 수 있습니다 . &lt;code&gt;:ok&lt;/code&gt; / &lt;code&gt;:error&lt;/code&gt; 튜플 을 반환 하고 추가합니다 &lt;code&gt;!&lt;/code&gt; 예외를 발생시키는 기능 버전.</target>
        </trans-unit>
        <trans-unit id="77c3cf325603a665b9b8eac02035614c9c18c7ae" translate="yes" xml:space="preserve">
          <source>As a provider</source>
          <target state="translated">공급자로서</target>
        </trans-unit>
        <trans-unit id="99a1d5c639e5fae94bea39706a508ae1b1b194aa" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, use &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;not&lt;/code&gt; when you are expecting booleans. If any of the arguments are non-boolean, use &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;!&lt;/code&gt;.</source>
          <target state="translated">엄지 손가락, 사용의 원칙으로 &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; 하고 &lt;code&gt;not&lt;/code&gt; 당신은 논리 값을 기대하는 경우. 부울이 아닌 인수가 있으면 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;||&lt;/code&gt; 그리고 &lt;code&gt;!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d342dd5680ead35a3c501294db776be8ca86c04" translate="yes" xml:space="preserve">
          <source>As a short summary, prefer to using the &lt;code&gt;:spawn&lt;/code&gt; and &lt;code&gt;:spawn_executable&lt;/code&gt; options mentioned below. The other two options, &lt;code&gt;:spawn_driver&lt;/code&gt; and &lt;code&gt;:fd&lt;/code&gt; are for advanced usage within the VM. Also consider using &lt;a href=&quot;system#cmd/3&quot;&gt;&lt;code&gt;System.cmd/3&lt;/code&gt;&lt;/a&gt; if all you want is to execute a program and retrieve its return value.</source>
          <target state="translated">간단히 요약하면 아래에 언급 된 &lt;code&gt;:spawn&lt;/code&gt; 및 &lt;code&gt;:spawn_executable&lt;/code&gt; 옵션 을 사용하는 것이 좋습니다 . 다른 두 가지 옵션 인 &lt;code&gt;:spawn_driver&lt;/code&gt; 및 &lt;code&gt;:fd&lt;/code&gt; 는 VM 내에서 고급 사용을위한 것입니다. 프로그램을 실행하고 리턴 값을 검색하는 &lt;a href=&quot;system#cmd/3&quot;&gt; &lt;code&gt;System.cmd/3&lt;/code&gt; &lt;/a&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb104516ec4ba9c5daae1d819dfced70e5b80a3a" translate="yes" xml:space="preserve">
          <source>As a starting point, let&amp;rsquo;s define a release that includes both &lt;code&gt;:kv_server&lt;/code&gt; and &lt;code&gt;:kv&lt;/code&gt; applications. We will also add a version to it. Open up the &lt;code&gt;mix.exs&lt;/code&gt; in the umbrella root and add inside &lt;code&gt;def project&lt;/code&gt;:</source>
          <target state="translated">시작점으로 &lt;code&gt;:kv_server&lt;/code&gt; 및 &lt;code&gt;:kv&lt;/code&gt; 응용 프로그램이 모두 포함 된 릴리스를 정의 해 봅시다 . 버전도 추가 할 예정입니다. 우산 루트에서 &lt;code&gt;mix.exs&lt;/code&gt; 를 열고 내부 &lt;code&gt;def project&lt;/code&gt; 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="71409663988da93d2218196a4f8d08db41758aae" translate="yes" xml:space="preserve">
          <source>As an alternative to &lt;code&gt;Enum&lt;/code&gt;, Elixir provides &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt;the &lt;code&gt;Stream&lt;/code&gt; module&lt;/a&gt; which supports lazy operations:</source>
          <target state="translated">&lt;code&gt;Enum&lt;/code&gt; 대신에 Elixir는 게으른 연산을 지원 &lt;a href=&quot;https://hexdocs.pm/elixir/Stream.html&quot;&gt;하는 &lt;code&gt;Stream&lt;/code&gt; 모듈&lt;/a&gt; 을 제공 합니다 .</target>
        </trans-unit>
        <trans-unit id="1e751881fcb15d693b8ad4d4a8a7706bd11e93e1" translate="yes" xml:space="preserve">
          <source>As an example, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt;&lt;code&gt;ExUnit&lt;/code&gt;&lt;/a&gt; stores the AST of every assertion, so when an assertion fails we can show code snippets to users. Without this option, each time the test module is compiled, we get a different MD5 of the module byte code, because the AST contains metadata, such as counters, specific to the compilation environment. By pruning the metadata, we ensure that the module is deterministic and reduce the amount of data &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt;&lt;code&gt;ExUnit&lt;/code&gt;&lt;/a&gt; needs to keep around.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt; &lt;code&gt;ExUnit&lt;/code&gt; &lt;/a&gt; 은 모든 어설 션의 AST를 저장하므로 어설 션이 실패하면 사용자에게 코드 스 니펫을 표시 할 수 있습니다. 이 옵션을 사용하지 않으면 테스트 모듈이 컴파일 될 때마다 AST에 컴파일 환경과 관련된 카운터와 같은 메타 데이터가 포함되므로 모듈 바이트 코드의 다른 MD5를 얻게됩니다. 메타 데이터를 제거하면 모듈이 결정적이며 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.html&quot;&gt; &lt;code&gt;ExUnit&lt;/code&gt; &lt;/a&gt; 이 유지 해야하는 데이터 양이 줄어 듭니다 .</target>
        </trans-unit>
        <trans-unit id="0349a9ec4dea6160dbbe7ca7df0fd8cda00d0b76" translate="yes" xml:space="preserve">
          <source>As an example, here is the implementation of &lt;code&gt;reduce&lt;/code&gt; for lists:</source>
          <target state="translated">예를 들어 다음은 목록에 대한 &lt;code&gt;reduce&lt;/code&gt; 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="464ac5e237ea0054e115f37d2c18ebb476327aba" translate="yes" xml:space="preserve">
          <source>As an example, when &lt;code&gt;Mix.shell.info(&quot;hello&quot;)&lt;/code&gt; is called, the following message will be sent to the calling process:</source>
          <target state="translated">예를 들어 &lt;code&gt;Mix.shell.info(&quot;hello&quot;)&lt;/code&gt; 가 호출되면 다음 메시지가 호출 프로세스로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="dc93e8a699323a5ad9c331b0b8b1db6ef13f00e3" translate="yes" xml:space="preserve">
          <source>As an interactive shell, IEx evaluates expressions. This has some interesting consequences that are worth discussing.</source>
          <target state="translated">대화식 쉘인 IEx는 표현식을 평가합니다. 이것은 논의 할 가치가있는 몇 가지 흥미로운 결과를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="85b7c3a4aee2708f25f8484199a1fbbe55745c55" translate="yes" xml:space="preserve">
          <source>As annotations</source>
          <target state="translated">주석으로</target>
        </trans-unit>
        <trans-unit id="b3d151430c89c74eb889709b00af1b8cd57bf29f" translate="yes" xml:space="preserve">
          <source>As before, if &lt;code&gt;heavy_fun/0&lt;/code&gt; fails, the whole computation will fail, including the parent process. If you don't want the task to fail then you must change the &lt;code&gt;heavy_fun/0&lt;/code&gt; code in the same way you would achieve it if you didn't have the async call. For example, to either return &lt;code&gt;{:ok, val} | :error&lt;/code&gt; results or, in more extreme cases, by using &lt;code&gt;try/rescue&lt;/code&gt;. In other words, an asynchronous task should be thought of as an extension of a process rather than a mechanism to isolate it from all errors.</source>
          <target state="translated">이전과 같이 &lt;code&gt;heavy_fun/0&lt;/code&gt; 이 실패하면 상위 프로세스를 포함한 전체 계산이 실패합니다. 작업이 실패 하지 않게하려면 비동기 호출을하지 않은 경우와 동일한 방법으로 &lt;code&gt;heavy_fun/0&lt;/code&gt; 코드를 변경해야합니다 . 예를 들어 &lt;code&gt;{:ok, val} | :error&lt;/code&gt; 발생하거나 더 극단적 인 경우 &lt;code&gt;try/rescue&lt;/code&gt; 를 사용 합니다 . 다시 말해서, 비동기 작업은 모든 오류로부터 프로세스를 분리하는 메커니즘이 아니라 프로세스의 확장으로 생각해야합니다.</target>
        </trans-unit>
        <trans-unit id="92c62ad7d5aa1057f77beb16eeaa0f4ad0108cba" translate="yes" xml:space="preserve">
          <source>As can be seen in the example above, &lt;code&gt;@doc&lt;/code&gt; and &lt;code&gt;@typedoc&lt;/code&gt; also accept a keyword list that serves as a way to provide arbitrary metadata about the entity. Tools like &lt;a href=&quot;https://hexdocs.pm/ex_doc/&quot;&gt;&lt;code&gt;ExDoc&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html&quot;&gt;&lt;code&gt;IEx&lt;/code&gt;&lt;/a&gt; may use this information to display annotations. A common use case is &lt;code&gt;since&lt;/code&gt; that may be used to annotate in which version the function was introduced.</source>
          <target state="translated">위의 예에서 볼 수 있듯이 &lt;code&gt;@doc&lt;/code&gt; 및 &lt;code&gt;@typedoc&lt;/code&gt; 는 엔티티에 대한 임의의 메타 데이터를 제공하는 방법으로 사용되는 키워드 목록도 허용합니다. 같은 도구 &lt;a href=&quot;https://hexdocs.pm/ex_doc/&quot;&gt; &lt;code&gt;ExDoc&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/iex/IEx.html&quot;&gt; &lt;code&gt;IEx&lt;/code&gt; &lt;/a&gt; 디스플레이 주석이 정보를 사용할 수 있습니다. 일반적인 사용 사례는 함수가 도입 된 버전에 주석을 달기 위해 사용될 수 &lt;code&gt;since&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="53c5b01ebc748740fa3a202be293afebe8d3531d" translate="yes" xml:space="preserve">
          <source>As hinted at the beginning of this chapter, sigils in Elixir are extensible. In fact, using the sigil &lt;code&gt;~r/foo/i&lt;/code&gt; is equivalent to calling &lt;code&gt;sigil_r&lt;/code&gt; with a binary and a char list as the argument:</source>
          <target state="translated">이 장의 시작 부분에서 암시 된 바와 같이, 엘릭서의시길은 확장 가능합니다. 실제로 sigil &lt;code&gt;~r/foo/i&lt;/code&gt; 를 사용하는 것은 인수로 바이너리와 char 목록을 가진 &lt;code&gt;sigil_r&lt;/code&gt; 을 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6c8f5fa4753404d9868b5d71ab1cbc0f0b9f0e9c" translate="yes" xml:space="preserve">
          <source>As illustrated in the example, it is possible to use these attributes more than once before an entity. However, the compiler will warn if used twice with binaries as that replaces the documentation text from the preceding use. Multiple uses with keyword lists will merge the lists into one.</source>
          <target state="translated">예제에 설명 된대로 엔터티 전에 이러한 특성을 두 번 이상 사용할 수 있습니다. 그러나 컴파일러는 이진 파일로 두 번 사용하는 경우 이전 사용의 문서 텍스트를 대체하므로 경고합니다. 키워드 목록을 여러 번 사용하면 목록이 하나로 통합됩니다.</target>
        </trans-unit>
        <trans-unit id="4ba33298179402c80c62d07ca88b3e24f39778d2" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;#for/1&quot;&gt;&lt;code&gt;for/1&lt;/code&gt;&lt;/a&gt;, variables bound inside &lt;a href=&quot;#with/1&quot;&gt;&lt;code&gt;with/1&lt;/code&gt;&lt;/a&gt; won't leak. Expressions without &lt;code&gt;&amp;lt;-&lt;/code&gt; may also be used in clauses. For instance, you can perform regular matches with the &lt;code&gt;=&lt;/code&gt; operator:</source>
          <target state="translated">&lt;a href=&quot;#for/1&quot;&gt; &lt;code&gt;for/1&lt;/code&gt; &lt;/a&gt; 에서처럼 , &lt;a href=&quot;#with/1&quot;&gt; &lt;code&gt;with/1&lt;/code&gt; &lt;/a&gt; 안에 바인딩 된 변수 는 누출되지 않습니다. &lt;code&gt;&amp;lt;-&lt;/code&gt; 가 없는 표현식 도 절에서 사용할 수 있습니다. 예를 들어 &lt;code&gt;=&lt;/code&gt; 연산자를 사용하여 정기적으로 일치시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7618dfe0b48bdcbbc92fb053f674001960e2baaf" translate="yes" xml:space="preserve">
          <source>As many programming languages, Elixir also support operators as non-qualified calls with their precedence and associativity rules. Constructs such as &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;when&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; are simply treated as operators. See &lt;a href=&quot;operators&quot;&gt;the Operators page&lt;/a&gt; for a full reference.</source>
          <target state="translated">많은 프로그래밍 언어와 마찬가지로 Elixir는 우선 순위 및 연관성 규칙이있는 규정되지 않은 호출로 연산자를 지원합니다. 같은 구조 &lt;code&gt;=&lt;/code&gt; , , &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;@&lt;/code&gt; 는 단순히 연산자로 처리됩니다. 자세한 내용 &lt;a href=&quot;operators&quot;&gt;은 운영자 페이지&lt;/a&gt; 를 참조하십시오. &lt;code&gt;when&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37b8d1cf77312071adcc9e820be3a314b89ebb03" translate="yes" xml:space="preserve">
          <source>As mentioned before, only the expressions listed in this page are allowed in guards. However, we can take advantage of macros to write custom guards that can simplify our programs or make them more domain-specific. At the end of the day, what matters is that the &lt;em&gt;output&lt;/em&gt; of the macros (which is what will be compiled) boils down to a combinations of the allowed expressions.</source>
          <target state="translated">앞에서 언급했듯이이 페이지에 나열된 표현식 만 경비원에서 허용됩니다. 그러나 매크로를 활용하여 프로그램을 단순화하거나 도메인 고유의 도메인으로 만들 수있는 사용자 지정 가드를 작성할 수 있습니다. 마지막에 중요한 것은 매크로 의 &lt;em&gt;출력&lt;/em&gt; (컴파일 될 것)이 허용되는 표현식의 조합으로 요약된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8270045d7128d710af04fe8613d76eb301a527bc" translate="yes" xml:space="preserve">
          <source>As per the standard, a code point is a single Unicode Character, which may be represented by one or more bytes.</source>
          <target state="translated">표준에 따라 코드 포인트는 단일 유니 코드 문자이며 하나 이상의 바이트로 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="676396c741582d57035ca27fdb32352c00e638d7" translate="yes" xml:space="preserve">
          <source>As seen as in the example above, &lt;code&gt;super&lt;/code&gt; can be used to call the default implementation.</source>
          <target state="translated">위의 예에서 볼 수 있듯이 &lt;code&gt;super&lt;/code&gt; 는 기본 구현을 호출하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1acf70e5576f741c3828bd3ef7c8c6ec15e18ff5" translate="yes" xml:space="preserve">
          <source>As seen in the example above, defining a callback is a matter of defining a specification for that callback, made of:</source>
          <target state="translated">위의 예에서 볼 수 있듯이 콜백을 정의하는 것은 해당 콜백에 대한 사양을 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c17961654b5ef8c817d3bea42d0612f57d6bdfb6" translate="yes" xml:space="preserve">
          <source>As shown above, a map matches as long as the keys in the pattern exist in the given map. Therefore, an empty map matches all maps.</source>
          <target state="translated">위에 표시된 것처럼 패턴의 키가 주어진 맵에 존재하는 한 맵이 일치합니다. 따라서 빈 맵은 모든 맵과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3e87159a8128cba6f69d2d663e334e06403ae804" translate="yes" xml:space="preserve">
          <source>As specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-2.2&quot;&gt;RFC 3986, section 2.2&lt;/a&gt;, the following characters are reserved: &lt;code&gt;:&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;#&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;]&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;!&lt;/code&gt;, &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;'&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;)&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;,&lt;/code&gt;, &lt;code&gt;;&lt;/code&gt;, &lt;code&gt;=&lt;/code&gt;</source>
          <target state="translated">에 지정된대로 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-2.2&quot;&gt;RFC 3986, 2.2 절&lt;/a&gt; , 다음과 같은 문자가 예약되어 있습니다 : &lt;code&gt;:&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;#&lt;/code&gt; , &lt;code&gt;[&lt;/code&gt; , &lt;code&gt;]&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;'&lt;/code&gt; , &lt;code&gt;(&lt;/code&gt; , &lt;code&gt;)&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;,&lt;/code&gt; , &lt;code&gt;;&lt;/code&gt; , &lt;code&gt;=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f34ca7664a4faf689aba327936c76b57db41870" translate="yes" xml:space="preserve">
          <source>As specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-2.3&quot;&gt;RFC 3986, section 2.3&lt;/a&gt;, the following characters are unreserved:</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-2.3&quot;&gt;RFC 3986, 섹션 2.3에&lt;/a&gt; 지정된대로 다음 문자는 예약되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae8c2d0eb718b47d6bdc235bbe27fe6688ec42f5" translate="yes" xml:space="preserve">
          <source>As specified in the standard, the separator &quot;T&quot; may be omitted if desired as there is no ambiguity within this function.</source>
          <target state="translated">표준에 규정 된 바와 같이, 분리기 &quot;T&quot;는이 기능 내에 모호성이 없기 때문에 원한다면 생략 될 수있다.</target>
        </trans-unit>
        <trans-unit id="172b9ef57ee22a616a5d576f366995c400978c73" translate="yes" xml:space="preserve">
          <source>As temporary storage</source>
          <target state="translated">임시 저장소로</target>
        </trans-unit>
        <trans-unit id="09bf92a059d2e30dbaaf2c6c71588317b92537a3" translate="yes" xml:space="preserve">
          <source>As the context is a map, it can be pattern matched on to extract information:</source>
          <target state="translated">컨텍스트는 맵이므로 패턴을 일치시켜 정보를 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa7714894dcee21ed3c16ea2836ca8361fe264b6" translate="yes" xml:space="preserve">
          <source>As the name says, doctest is documentation first and a test later. Their goal is not to replace tests but to provide up to date documentation. You can read more about doctests in &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.DocTest.html&quot;&gt;the &lt;code&gt;ExUnit.DocTest&lt;/code&gt; docs&lt;/a&gt;.</source>
          <target state="translated">이름에서 알 수 있듯이 doctest는 먼저 문서화 한 후 나중에 테스트합니다. 그들의 목표는 테스트를 대체하는 것이 아니라 최신 문서를 제공하는 것입니다. 당신은에서의 doctest에 대한 자세한 읽을 수 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.DocTest.html&quot;&gt; &lt;code&gt;ExUnit.DocTest&lt;/code&gt; &lt;/a&gt; 문서를 .</target>
        </trans-unit>
        <trans-unit id="4b3950445b3884bea63da00e819f70e116c9c457" translate="yes" xml:space="preserve">
          <source>As the name says, this function is useful to stream values from resources.</source>
          <target state="translated">이름에서 알 수 있듯이이 함수는 리소스에서 값을 스트리밍하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="94f0af78270d1f9bb5f3fb4c7e50123a2d1e6b3c" translate="yes" xml:space="preserve">
          <source>As usual, we&amp;rsquo;ve passed a two-element tuple as a child specification, which in turn will invoke &lt;code&gt;Task.start_link/1&lt;/code&gt;.</source>
          <target state="translated">평소와 같이, 우리는 하위 요소로 2 요소 튜플을 전달했으며, 이는 다시 &lt;code&gt;Task.start_link/1&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="200471b29b35258f77b2250785934287d372a624" translate="yes" xml:space="preserve">
          <source>As we are now able to parse commands, we can finally start implementing the logic that runs the commands. Let&amp;rsquo;s add a stub definition for this function for now:</source>
          <target state="translated">이제 명령을 구문 분석 할 수 있으므로 명령을 실행하는 논리 구현을 시작할 수 있습니다. 지금이 함수에 대한 스텁 정의를 추가해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="601235f1a3d19d8aa741732ca63364ee542ff5d9" translate="yes" xml:space="preserve">
          <source>As we have seen above, code points can be inserted into a string by their hexadecimal code:</source>
          <target state="translated">위에서 살펴본 것처럼 16 진수 코드로 코드 포인트를 문자열에 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b744ff728795adae8a150cdd6bdfc7a23aebec3d" translate="yes" xml:space="preserve">
          <source>As we said in the previous section, the implementation of &lt;code&gt;Size&lt;/code&gt; for &lt;code&gt;Any&lt;/code&gt; is not one that can apply to any data type. That&amp;rsquo;s one of the reasons why &lt;code&gt;@fallback_to_any&lt;/code&gt; is an opt-in behaviour. For the majority of protocols, raising an error when a protocol is not implemented is the proper behaviour. That said, assuming we have implemented &lt;code&gt;Any&lt;/code&gt; as in the previous section:</source>
          <target state="translated">이전 섹션에서 언급했듯이 &lt;code&gt;Size&lt;/code&gt; for &lt;code&gt;Any&lt;/code&gt; 구현은 모든 데이터 유형에 적용 할 수있는 것은 아닙니다. 이것이 &lt;code&gt;@fallback_to_any&lt;/code&gt; 가 옵트 인 동작 인 이유 중 하나입니다 . 대부분의 프로토콜에서 프로토콜이 구현되지 않은 경우 오류를 발생시키는 것이 올바른 동작입니다. 이전 섹션과 같이 &lt;code&gt;Any&lt;/code&gt; 를 구현했다고 가정하면 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15c53c6aaf99d7b2cea9d0b0858060f9842a9b54" translate="yes" xml:space="preserve">
          <source>As we saw at the beginning of this chapter, only some values are valid quoted expressions in Elixir. For example, a map is not a valid quoted expression. Neither is a tuple with four elements. However, such values &lt;em&gt;can&lt;/em&gt; be expressed as a quoted expression:</source>
          <target state="translated">이 장의 시작 부분에서 보았 듯이 일부 값만 Elixir에서 유효한 인용 식입니다. 예를 들어, 맵은 유효한 인용 표현식이 아닙니다. 네 가지 요소가있는 튜플도 아닙니다. 그러나 이러한 값 &lt;em&gt;은&lt;/em&gt; 인용 표현식으로 표현할 &lt;em&gt;수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="a70db684277fce0a661e1a1649e67da611b415a0" translate="yes" xml:space="preserve">
          <source>As we will see in later chapters, aliases also play a crucial role in macros, to guarantee they are hygienic.</source>
          <target state="translated">이후 장에서 볼 수 있듯이 별칭은 매크로에서 위생적인 ​​역할을하기 위해 매크로에서 중요한 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="4b0983ae2706b788ff3f58d0346e9d53db96d9c3" translate="yes" xml:space="preserve">
          <source>As well as with lists and tuples:</source>
          <target state="translated">리스트와 튜플뿐만 아니라 :</target>
        </trans-unit>
        <trans-unit id="0f4afdbad8980e1dc31c0b805a2715e284761af4" translate="yes" xml:space="preserve">
          <source>As with any other function or macro call in Elixir, explicit parens can also be used around the arguments before the &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; block:</source>
          <target state="translated">Elixir의 다른 함수 또는 매크로 호출과 마찬가지로 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 블록 앞의 인수 주위에 명시 적 parens을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97fa256436a4dcbb72bdc937146524beaa952bd1" translate="yes" xml:space="preserve">
          <source>As with other functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module, &lt;a href=&quot;#next_codepoint/1&quot;&gt;&lt;code&gt;next_codepoint/1&lt;/code&gt;&lt;/a&gt; works with binaries that are invalid UTF-8. If the string starts with a sequence of bytes that is not valid in UTF-8 encoding, the first element of the returned tuple is a binary with the first byte.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 모듈의 다른 함수와 마찬가지로 &lt;a href=&quot;#next_codepoint/1&quot;&gt; &lt;code&gt;next_codepoint/1&lt;/code&gt; &lt;/a&gt; 은 유효하지 않은 UTF-8 이진에서 작동합니다. 문자열이 UTF-8 인코딩에서 유효하지 않은 일련의 바이트로 시작하는 경우 리턴 된 튜플의 첫 번째 요소는 첫 번째 바이트의 이진입니다.</target>
        </trans-unit>
        <trans-unit id="3f6413773613da2d0a327678be51feae49a384ac" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;#compare/2&quot;&gt;&lt;code&gt;compare/2&lt;/code&gt;&lt;/a&gt; function both &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; structs and other structures containing time can be used. If for instance a &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is passed, only the hour, month, second, and microsecond is considered. Any additional information about a date or time zone is ignored when calculating the difference.</source>
          <target state="translated">와 같이 &lt;a href=&quot;#compare/2&quot;&gt; &lt;code&gt;compare/2&lt;/code&gt; &lt;/a&gt; 기능 모두 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; 구조체 및 시간을 포함하는 다른 구조가 사용될 수있다. 예를 들어 &lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 이 전달되면 시간, 월, 초 및 마이크로 초 만 고려됩니다. 차이를 계산할 때 날짜 또는 시간대에 대한 추가 정보는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="bfac16304766e4e02a86d724f96fe90d475e9d00" translate="yes" xml:space="preserve">
          <source>As you can see &lt;code&gt;IO.inspect/2&lt;/code&gt; makes it possible to &amp;ldquo;spy&amp;rdquo; on values almost anywhere in your code without altering the result, making it very helpful inside of a pipeline like in the above case.</source>
          <target state="translated">보시다시피 &lt;code&gt;IO.inspect/2&lt;/code&gt; 를 사용하면 결과를 변경하지 않고도 코드의 거의 모든 위치에서 값을 &quot;스파이&quot;할 수 있으므로 위의 경우와 같이 파이프 라인 내부에서 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="21f8fc70137800358c066550264ed73297889dbe" translate="yes" xml:space="preserve">
          <source>As you can see above, Elixir supports a special syntax for defining such lists: &lt;code&gt;[key: value]&lt;/code&gt;. Underneath it maps to the same list of tuples as above. Since keyword lists are lists, we can use all operations available to lists. For example, we can use &lt;code&gt;++&lt;/code&gt; to add new values to a keyword list:</source>
          <target state="translated">위에서 볼 수 있듯이 Elixir는 이러한 목록을 정의하기위한 특별한 구문을 지원합니다 : &lt;code&gt;[key: value]&lt;/code&gt; . 그 아래는 위와 같은 튜플 목록에 매핑됩니다. 키워드 목록은 목록이므로 목록에 사용 가능한 모든 작업을 사용할 수 있습니다. 예를 들어 &lt;code&gt;++&lt;/code&gt; 를 사용 하여 키워드 목록에 새 값을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa4170415b6c223620cdf1f88ee2130beff4adea" translate="yes" xml:space="preserve">
          <source>As you can see in the example, tuples are a compound type and each tuple is identified by the types inside it. To understand why &lt;code&gt;String.t&lt;/code&gt; is not written as &lt;code&gt;string&lt;/code&gt;, have another look at the &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#the-string-type&quot;&gt;typespecs docs&lt;/a&gt;.</source>
          <target state="translated">예제에서 볼 수 있듯이 튜플은 복합 유형이며 각 튜플은 그 내부 유형으로 식별됩니다. &lt;code&gt;String.t&lt;/code&gt; 가 &lt;code&gt;string&lt;/code&gt; 작성되지 않은 이유를 이해하려면 &lt;a href=&quot;https://hexdocs.pm/elixir/typespecs.html#the-string-type&quot;&gt;typespecs 문서를&lt;/a&gt; 다시 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="6e385b1477b16c3d8afb0738a5dc664781fad0f5" translate="yes" xml:space="preserve">
          <source>As you can see, the &lt;code&gt;|&amp;gt;&lt;/code&gt; operator retains the same semantics as when the pipe is not used since both require the &lt;code&gt;fun.(...)&lt;/code&gt; notation.</source>
          <target state="translated">보다시피 &lt;code&gt;|&amp;gt;&lt;/code&gt; 연산자는 파이프가 사용되지 않을 때와 같은 의미를 유지합니다 &lt;code&gt;fun.(...)&lt;/code&gt; 둘 다 재미가 필요하기 때문 입니다 (...) .</target>
        </trans-unit>
        <trans-unit id="30d1ce2388da1cbee1aee34fe86a268a3580437f" translate="yes" xml:space="preserve">
          <source>As you can see, we can modify the agent state in any way we want. Therefore, we most likely don&amp;rsquo;t want to access the Agent API throughout many different places in our code. Instead, we want to encapsulate all Agent-related functionality in a single module, which we will call &lt;code&gt;KV.Bucket&lt;/code&gt;. Before we implement it, let&amp;rsquo;s write some tests which will outline the API exposed by our module.</source>
          <target state="translated">보시다시피 원하는 방식으로 에이전트 상태를 수정할 수 있습니다. 따라서 코드의 여러 곳에서 에이전트 API에 액세스하고 싶지 않을 가능성이 높습니다. 대신 모든 에이전트 관련 기능을 단일 모듈로 캡슐화하려고합니다 .이를 &lt;code&gt;KV.Bucket&lt;/code&gt; 이라고 합니다 . 구현하기 전에 모듈에 의해 노출 된 API를 간략하게 설명하는 테스트를 작성해 봅시다.</target>
        </trans-unit>
        <trans-unit id="210d4ba9daa92ffc70077cd3f9e0051375613c5f" translate="yes" xml:space="preserve">
          <source>As you grow more proficient in Elixir, you may want to explore the Erlang &lt;a href=&quot;http://erlang.org/doc/apps/stdlib/index.html&quot;&gt;STDLIB Reference Manual&lt;/a&gt; in more detail.</source>
          <target state="translated">Elixir에 능숙 &lt;a href=&quot;http://erlang.org/doc/apps/stdlib/index.html&quot;&gt;해짐에&lt;/a&gt; 따라 Erlang STDLIB Reference Manual 을 더 자세히 살펴볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42243c9d4edc16320cc7a5237930463fbe38b8c3" translate="yes" xml:space="preserve">
          <source>Asking questions</source>
          <target state="translated">질문하기</target>
        </trans-unit>
        <trans-unit id="e7490b91fb48bace99c9c58dc1ba9142c591d1b6" translate="yes" xml:space="preserve">
          <source>Assembling multiple releases</source>
          <target state="translated">여러 릴리즈 조립</target>
        </trans-unit>
        <trans-unit id="5e68467c391c90ed39d1769e2c7fc777abc9ce10" translate="yes" xml:space="preserve">
          <source>Asserts &lt;code&gt;expression&lt;/code&gt; will cause an error.</source>
          <target state="translated">&lt;code&gt;expression&lt;/code&gt; 이 오류를 유발 한다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="21ea5a6283f658e3d8429f3c704fec015ff7ac86" translate="yes" xml:space="preserve">
          <source>Asserts &lt;code&gt;expression&lt;/code&gt; will exit.</source>
          <target state="translated">주장 &lt;code&gt;expression&lt;/code&gt; 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="51dd35c873c4195a1aa602ca5fc4593065d118d6" translate="yes" xml:space="preserve">
          <source>Asserts &lt;code&gt;expression&lt;/code&gt; will throw a value.</source>
          <target state="translated">&lt;code&gt;expression&lt;/code&gt; 값을 던질 것이라고 주장 합니다.</target>
        </trans-unit>
        <trans-unit id="a4fccd55c6fefc18e898969890abca9f3867d90f" translate="yes" xml:space="preserve">
          <source>Asserts &lt;code&gt;value1&lt;/code&gt; and &lt;code&gt;value2&lt;/code&gt; are not within &lt;code&gt;delta&lt;/code&gt;.</source>
          <target state="translated">주장 &lt;code&gt;value1&lt;/code&gt; 과 &lt;code&gt;value2&lt;/code&gt; 내에 있지 &lt;code&gt;delta&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e3419e6d5b518f88bf525f195c071962c45d888" translate="yes" xml:space="preserve">
          <source>Asserts &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; (that is, &lt;code&gt;value&lt;/code&gt; is not truthy).</source>
          <target state="translated">주장 &lt;code&gt;value&lt;/code&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; (즉, &lt;code&gt;value&lt;/code&gt; truthy하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="b25f69bb32e51bfa75bcf7ba330376b516079f9a" translate="yes" xml:space="preserve">
          <source>Asserts &lt;code&gt;value&lt;/code&gt; is truthy, displaying the given &lt;code&gt;message&lt;/code&gt; otherwise.</source>
          <target state="translated">주장 &lt;code&gt;value&lt;/code&gt; 주어진 표시 truthy입니다 &lt;code&gt;message&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="dfe5bb735de6540b2a06f98b0a42bdd8ef4828e5" translate="yes" xml:space="preserve">
          <source>Asserts a message matching &lt;code&gt;pattern&lt;/code&gt; was not received (i.e. it is not in the current process' mailbox).</source>
          <target state="translated">메시지 일치 &lt;code&gt;pattern&lt;/code&gt; 이 수신되지 않았 음을 확인합니다 (즉, 현재 프로세스의 편지함에 있지 않음).</target>
        </trans-unit>
        <trans-unit id="27e6e46a40f5aa357f1b1f71823ab2714d6dfc2c" translate="yes" xml:space="preserve">
          <source>Asserts against a larger timeout:</source>
          <target state="translated">더 큰 시간 초과를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="0dcb430556180c632dbd6a05ebad3939684ea882" translate="yes" xml:space="preserve">
          <source>Asserts its argument is a truthy value.</source>
          <target state="translated">그 주장이 진실한 가치라고 주장한다.</target>
        </trans-unit>
        <trans-unit id="631f267df18019d097de2ba4fa501aea456587c9" translate="yes" xml:space="preserve">
          <source>Asserts that &lt;code&gt;value1&lt;/code&gt; and &lt;code&gt;value2&lt;/code&gt; differ by no more than &lt;code&gt;delta&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value1&lt;/code&gt; 과 &lt;code&gt;value2&lt;/code&gt; 가 &lt;code&gt;delta&lt;/code&gt; 이하만큼 다르다고 주장 합니다.</target>
        </trans-unit>
        <trans-unit id="b3d081c32e7b0ecb8b1370d55ed5d56cfeed4172" translate="yes" xml:space="preserve">
          <source>Asserts that a message matching &lt;code&gt;pattern&lt;/code&gt; was not received (and won't be received) within the &lt;code&gt;timeout&lt;/code&gt; period, specified in milliseconds.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 내에 밀리 초로 지정된 메시지 일치 &lt;code&gt;pattern&lt;/code&gt; 이 수신되지 않았거나 수신되지 않았 음을 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="c8c7b2bb8b65a4ae00cb202f3465c2a6e04800c2" translate="yes" xml:space="preserve">
          <source>Asserts that a message matching &lt;code&gt;pattern&lt;/code&gt; was or is going to be received within the &lt;code&gt;timeout&lt;/code&gt; period, specified in milliseconds.</source>
          <target state="translated">메시지 일치 &lt;code&gt;pattern&lt;/code&gt; 이 밀리 초로 지정된 &lt;code&gt;timeout&lt;/code&gt; 내에 수신되었거나 수신 될 것이라고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="e4b2d80d77ed40f1fbbfa18c2d6aec035c3583ca" translate="yes" xml:space="preserve">
          <source>Asserts that a message matching &lt;code&gt;pattern&lt;/code&gt; was received and is in the current process' mailbox.</source>
          <target state="translated">메시지 일치 &lt;code&gt;pattern&lt;/code&gt; 이 수신되었고 현재 프로세스의 사서함에 있는지 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="08e716a4d9543f0675eaa0e9aeb88e0dbd3e68b3" translate="yes" xml:space="preserve">
          <source>Asserts the &lt;code&gt;exception&lt;/code&gt; is raised during &lt;code&gt;function&lt;/code&gt; execution with the expected &lt;code&gt;message&lt;/code&gt;, which can be a &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.html&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; or an exact &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;. Returns the rescued exception, fails otherwise.</source>
          <target state="translated">주장 &lt;code&gt;exception&lt;/code&gt; 시 발생 &lt;code&gt;function&lt;/code&gt; 예상과 실행 &lt;code&gt;message&lt;/code&gt; 될 수 &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.html&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt; 또는 정확한 &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; . 구조 된 예외를 리턴하고 그렇지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f189bf2d977136873077301bfd1a2a270f543d21" translate="yes" xml:space="preserve">
          <source>Asserts the &lt;code&gt;exception&lt;/code&gt; is raised during &lt;code&gt;function&lt;/code&gt; execution. Returns the rescued exception, fails otherwise.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; 실행 중에 &lt;code&gt;exception&lt;/code&gt; 가 발생 한다고 가정합니다 . 구조 된 예외를 리턴하고 그렇지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c6416f331120cf783e79cebf7095c44ed2cd766d" translate="yes" xml:space="preserve">
          <source>Assigns can also be used when compiled to a function:</source>
          <target state="translated">함수로 컴파일 할 때 할당을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e92203a0ace3ba65c682a54de5d568ec7a27a848" translate="yes" xml:space="preserve">
          <source>Associates the &lt;code&gt;port&lt;/code&gt; identifier with a &lt;code&gt;pid&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; 식별자를 &lt;code&gt;pid&lt;/code&gt; 와 연관시킵니다 .</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="0706e10abd81eb18f13ab749dfc8f7c363cf456b" translate="yes" xml:space="preserve">
          <source>Assuming the &lt;code&gt;Stack&lt;/code&gt; GenServer mentioned in the docs for the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; module is registered as &lt;code&gt;Stack&lt;/code&gt; in the &lt;code&gt;:&quot;foo@my-machine&quot;&lt;/code&gt; and &lt;code&gt;:&quot;bar@my-machine&quot;&lt;/code&gt; nodes:</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 모듈 문서에서 언급 한 &lt;code&gt;Stack&lt;/code&gt; GenServer 가 &lt;code&gt;:&quot;foo@my-machine&quot;&lt;/code&gt; 및 &lt;code&gt;:&quot;bar@my-machine&quot;&lt;/code&gt; 노드에 &lt;code&gt;Stack&lt;/code&gt; 으로 등록 되었다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="3a5f997602b6a56d42f72e433af46958ffb188f5" translate="yes" xml:space="preserve">
          <source>Assuming we defined &lt;code&gt;TestCase&lt;/code&gt; in a file named &lt;code&gt;tests.exs&lt;/code&gt;, we can open it up by running &lt;code&gt;iex tests.exs&lt;/code&gt; and define our first tests:</source>
          <target state="translated">&lt;code&gt;tests.exs&lt;/code&gt; 파일에 &lt;code&gt;TestCase&lt;/code&gt; 를 정의했다고 가정하면 &lt;code&gt;iex tests.exs&lt;/code&gt; 를 실행 하여 첫 번째 테스트를 정의 하여 열 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d95ac37a47c14d5f1acc4f76198a9b839014e3cc" translate="yes" xml:space="preserve">
          <source>Async or not, our new test should obviously fail, as none of the functionality is implemented in the module being tested:</source>
          <target state="translated">비동기식이든 아니든 테스트 할 모듈에 기능이 구현되어 있지 않으므로 새로운 테스트는 분명히 실패합니다.</target>
        </trans-unit>
        <trans-unit id="44790a848ce1e0b878b857a7d7bf4211e67c716a" translate="yes" xml:space="preserve">
          <source>At first, the process map has no keys, so sending a &lt;code&gt;:get&lt;/code&gt; message and then flushing the current process inbox returns &lt;code&gt;nil&lt;/code&gt;. Let&amp;rsquo;s send a &lt;code&gt;:put&lt;/code&gt; message and try it again:</source>
          <target state="translated">처음에는 프로세스 맵에 키가 없으므로 &lt;code&gt;:get&lt;/code&gt; 메시지를 보낸 다음 현재 프로세스받은 편지함을 &lt;code&gt;nil&lt;/code&gt; 반환 됩니다. &lt;code&gt;:put&lt;/code&gt; 메시지를 보내고 다시 시도해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="16f7256f734477a56caabe25739de6426b77ff24" translate="yes" xml:space="preserve">
          <source>At first, there is nothing in this example that actually reveals it is a macro. But what is happening is that, at compilation time, &lt;code&gt;squared(5)&lt;/code&gt; becomes &lt;code&gt;5 * 5&lt;/code&gt;. The argument &lt;code&gt;5&lt;/code&gt; is duplicated in the produced code, we can see this behaviour in practice though because our macro actually has a bug:</source>
          <target state="translated">처음에는이 예제에서 실제로 매크로임을 나타내는 것이 없습니다. 그러나 일어나는 일은 컴파일 타임에 &lt;code&gt;squared(5)&lt;/code&gt; 가 &lt;code&gt;5 * 5&lt;/code&gt; 가된다는 것 입니다. 인수 &lt;code&gt;5&lt;/code&gt; 는 생성 된 코드에서 복제됩니다. 매크로에 실제로 버그가 있기 때문에 실제로이 동작을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17e0c2ba6bf8585ab612f28b687b66ddbc446816" translate="yes" xml:space="preserve">
          <source>At the end of the chapter, we will also talk about Applications. As we will see, Mix has been packaging all of our code into an application, and we will learn how to customize our application to guarantee that our Supervisor and the Registry are up and running whenever our system starts.</source>
          <target state="translated">이 장의 끝에서 응용 프로그램에 대해서도 이야기 할 것입니다. 앞으로 살펴 보 겠지만 Mix는 모든 코드를 응용 프로그램에 패키징했으며 시스템이 시작될 때마다 관리자와 레지스트리가 시작되어 실행되도록 응용 프로그램을 사용자 지정하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="7e1720c79764d1bd4a3c1260e363853f08ce78d4" translate="yes" xml:space="preserve">
          <source>At the end of the day, it is up to you and your team to figure out the best testing strategy for your applications. You need to balance code quality, confidence, and test suite runtime. For example, we may start with testing the server only with integration tests, but if the server continues to grow in future releases, or it becomes a part of the application with frequent bugs, it is important to consider breaking it apart and writing more intensive unit tests that don&amp;rsquo;t have the weight of an integration test.</source>
          <target state="translated">하루가 끝나면 응용 프로그램에 가장 적합한 테스트 전략을 결정하는 것은 귀하와 팀의 책임입니다. 코드 품질, 신뢰도 및 테스트 스위트 런타임 간의 균형을 유지해야합니다. 예를 들어, 통합 테스트를 통해서만 서버 테스트를 시작할 수 있지만, 이후 릴리스에서 서버가 계속 커지거나 버그가 자주 발생하는 응용 프로그램의 일부가되면 서버를 분리하여보다 집중적으로 작성하는 것이 중요합니다. 통합 테스트의 가중치가없는 단위 테스트.</target>
        </trans-unit>
        <trans-unit id="2a3ffa5cb7dc9aa4c3ec3ff462d233d2b07bed27" translate="yes" xml:space="preserve">
          <source>At the end of the day, it&amp;rsquo;s up to your application to decide if an error while opening a file is exceptional or not. That&amp;rsquo;s why Elixir doesn&amp;rsquo;t impose exceptions on &lt;code&gt;File.read/1&lt;/code&gt; and many other functions. Instead, it leaves it up to the developer to choose the best way to proceed.</source>
          <target state="translated">하루가 끝나면 파일을 여는 동안 오류가 예외적인지 여부를 결정하는 것은 응용 프로그램의 책임입니다. 이것이 Elixir가 &lt;code&gt;File.read/1&lt;/code&gt; 및 기타 여러 기능 에 예외를 부과하지 않는 이유 입니다. 대신 가장 좋은 방법을 선택하도록 개발자에게 맡깁니다.</target>
        </trans-unit>
        <trans-unit id="b873e6ad14549bcea5b5a36336f039751d9658a1" translate="yes" xml:space="preserve">
          <source>At the end of the day, tools like Observer are one of the reasons you want to always start processes inside supervision trees, even if they are temporary, to ensure they are always reachable and introspectable.</source>
          <target state="translated">하루가 끝날 때 옵저버와 같은 도구는 관리자 트리 내에서 프로세스가 항상 시작 가능하고 항상 접근 가능하고 검사 가능하도록 프로세스를 시작하려는 이유 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="e06f56d0fcde25a11eb9f4fd12e26af6e57cc715" translate="yes" xml:space="preserve">
          <source>At this point, we have learned four control structures: &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;cond&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, and &lt;code&gt;unless&lt;/code&gt;, and they were all wrapped in &lt;code&gt;do/end&lt;/code&gt; blocks. It happens we could also write &lt;code&gt;if&lt;/code&gt; as follows:</source>
          <target state="translated">이 시점에서, 우리는 4 명 개의 제어 구조 배운 : &lt;code&gt;case&lt;/code&gt; , &lt;code&gt;cond&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; 와 &lt;code&gt;unless&lt;/code&gt; , 그리고 그들은 모두에 싸여 있었다 &lt;code&gt;do/end&lt;/code&gt; 블록. 다음과 같은 &lt;code&gt;if&lt;/code&gt; 에도 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ac71a7b2e14e6b71166183a00716c799d7bccef" translate="yes" xml:space="preserve">
          <source>At this point, you may be wondering, how can we make two nodes start with two different routing tables? One option is to use the &lt;code&gt;--config&lt;/code&gt; flag in &lt;code&gt;mix run&lt;/code&gt;. For example, you could write two extra configuration files, &lt;code&gt;config/foo.exs&lt;/code&gt; and &lt;code&gt;config/bar.exs&lt;/code&gt;, with two distinct routing tables and then:</source>
          <target state="translated">이 시점에서 두 개의 노드가 두 개의 서로 다른 라우팅 테이블로 시작하도록하려면 어떻게해야합니까? 한 가지 옵션은 &lt;code&gt;mix run&lt;/code&gt; 에서 &lt;code&gt;--config&lt;/code&gt; 플래그 를 사용하는 것 입니다. 예를 들어, 두 개의 다른 라우팅 테이블과 함께 두 개의 추가 구성 파일 인 &lt;code&gt;config/foo.exs&lt;/code&gt; 및 &lt;code&gt;config/bar.exs&lt;/code&gt; 를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0dfd56da90b26d4f5fcb9d69b1cd07569e6e1396" translate="yes" xml:space="preserve">
          <source>At this point, you may be wondering: should you also locally name bucket processes? Remember buckets are started dynamically based on user input. Since local names MUST be atoms, we would have to dynamically create atoms, which is a bad idea since once an atom is defined, it is never erased nor garbage collected. This means that, if we create atoms dynamically based on user input, we will eventually run out of memory (or to be more precise, the VM will crash because it imposes a hard limit on the number of atoms). This limitation is precisely why we created our own registry (or why one would use Elixir&amp;rsquo;s built-in &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">이 시점에서 궁금 할 수도 있습니다. 로컬로 버킷 프로세스의 이름을 지정해야합니까? 버킷은 사용자 입력에 따라 동적으로 시작됩니다. 지역 이름은 원자 여야하므로 원자를 동적으로 생성해야하는데, 일단 원자가 정의되면 절대 소거되거나 가비지 수집되지 않기 때문에 나쁜 생각입니다. 즉, 사용자 입력에 따라 원자를 동적으로 만들면 결국 메모리가 부족합니다 (또는 더 정확하게 말하면 VM이 원자 수에 대한 제한을 강요하기 때문에 VM이 충돌 함). 이 제한은 정확히 우리가 우리 자신의 레지스트리를 만든 이유 또는 Elixir의 내장 &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt; 모듈을 사용하는 이유 입니다.</target>
        </trans-unit>
        <trans-unit id="4f19fee95b461d9367b1c2a9128f16cd17a5edf3" translate="yes" xml:space="preserve">
          <source>At this point, you may be wondering: what exactly is an Elixir alias and how is it represented?</source>
          <target state="translated">이 시점에서 엘릭서 별칭이 정확히 무엇이며 어떻게 표현됩니까?</target>
        </trans-unit>
        <trans-unit id="41dded417052424bdcf3c39f6c8664147fae6806" translate="yes" xml:space="preserve">
          <source>Atom</source>
          <target state="translated">Atom</target>
        </trans-unit>
        <trans-unit id="f53a98286f82798d588f67a7f0db19f7aebc839e" translate="yes" xml:space="preserve">
          <source>Atoms</source>
          <target state="translated">Atoms</target>
        </trans-unit>
        <trans-unit id="2a69989a3d606e64bc701c17d1245c7fdba9b230" translate="yes" xml:space="preserve">
          <source>Atoms and tuples are allowed as keys.</source>
          <target state="translated">원자와 튜플은 키로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c3e82516bd38cc41825c1c56991455366d6b7205" translate="yes" xml:space="preserve">
          <source>Atoms are equal if their names are equal.</source>
          <target state="translated">이름이 같으면 원자가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4e0ec53ea5b7d828ef6e5c43d6e21909c2587391" translate="yes" xml:space="preserve">
          <source>Atoms can be written either in &lt;code&gt;:snake_case&lt;/code&gt; or &lt;code&gt;:CamelCase&lt;/code&gt;, although the convention is to use the snake case version throughout Elixir.</source>
          <target state="translated">원자는 &lt;code&gt;:snake_case&lt;/code&gt; 또는 &lt;code&gt;:CamelCase&lt;/code&gt; 로 작성 될 수 있지만, 규칙은 Elixir 전체에서 뱀 케이스 버전을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7823d59c9025838f9df163a9aa5632eb33e8f5f9" translate="yes" xml:space="preserve">
          <source>Atoms with foreign characters, such as whitespace, must be wrapped in quotes. This rule applies to keywords as well:</source>
          <target state="translated">공백과 같은 외래 문자가있는 원자는 따옴표로 묶어야합니다. 이 규칙은 키워드에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="adfc32a230bc2cd9939f99a65ee1e1c430d56f45" translate="yes" xml:space="preserve">
          <source>Attaches information to exceptions for extra debugging.</source>
          <target state="translated">추가 디버깅을 위해 예외에 정보를 첨부합니다.</target>
        </trans-unit>
        <trans-unit id="be4563947c24c97f1390cb029a949e02c2dd4bc2" translate="yes" xml:space="preserve">
          <source>Attempting to convert an invalid ISO calendar date will produce an error tuple.</source>
          <target state="translated">잘못된 ISO 달력 날짜를 변환하려고하면 오류 튜플이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2cb1d997f70ceafe9419b46accfb019d8d855e4b" translate="yes" xml:space="preserve">
          <source>Attention! While the access syntax is allowed in maps via &lt;code&gt;map[key]&lt;/code&gt;, if your map is made of predefined atom keys, you should prefer to access those atom keys with &lt;code&gt;map.key&lt;/code&gt; instead of &lt;code&gt;map[key]&lt;/code&gt;, as &lt;code&gt;map.key&lt;/code&gt; will raise if the key is missing. This is important because, if a map has a predefined set of keys and a key is missing, it is most likely a bug in your software or a typo on the key name. For this reason, because structs are predefined in nature, they only allow the &lt;code&gt;struct.key&lt;/code&gt; syntax and they do not allow the &lt;code&gt;struct[key]&lt;/code&gt; access syntax. See the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module for more information.</source>
          <target state="translated">주의! 액세스 구문을 통해지도에서 허용되는 동안 &lt;code&gt;map[key]&lt;/code&gt; 지도가 미리 정의 된 원자 키를 만든 경우, 당신은 함께 그 원자의 키에 액세스하는 것을 선호한다 &lt;code&gt;map.key&lt;/code&gt; 대신 &lt;code&gt;map[key]&lt;/code&gt; 로, &lt;code&gt;map.key&lt;/code&gt; 이 경우에 올릴 것이다 열쇠가 없습니다. 지도에 사전 정의 된 키 세트가 있고 키가없는 경우 소프트웨어의 버그이거나 키 이름의 오타 일 가능성이 있기 때문에 중요합니다. 이러한 이유로 구조체는 미리 정의되어 있기 때문에 &lt;code&gt;struct.key&lt;/code&gt; 구문 만 허용하고 &lt;code&gt;struct[key]&lt;/code&gt; 액세스 구문 은 허용하지 않습니다 . 자세한 정보는 &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="5f97e36f103d67250ebb8f2ffecafc5a4f3670e6" translate="yes" xml:space="preserve">
          <source>Autocomplete</source>
          <target state="translated">Autocomplete</target>
        </trans-unit>
        <trans-unit id="59ca0e6a6a5c6fa7d8b2946ea7d9f3d1a2cddf19" translate="yes" xml:space="preserve">
          <source>Autocomplete may not be available on some Windows shells. You may need to pass the &lt;code&gt;--werl&lt;/code&gt; option when starting IEx, as in &lt;code&gt;iex --werl&lt;/code&gt; for it to work. &lt;code&gt;--werl&lt;/code&gt; may be permanently enabled by setting the &lt;code&gt;IEX_WITH_WERL&lt;/code&gt; environment variable.</source>
          <target state="translated">일부 Windows 셸에서는 자동 완성 기능을 사용하지 못할 수 있습니다. 당신은 통과해야 &lt;code&gt;--werl&lt;/code&gt; IEX를 시작할 때 같이 옵션을 &lt;code&gt;iex --werl&lt;/code&gt; 작업에 대한. &lt;code&gt;--werl&lt;/code&gt; 은 &lt;code&gt;IEX_WITH_WERL&lt;/code&gt; 환경 변수를 설정하여 영구적으로 활성화 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51a4c659ece8f79813a8062061a37db34ec84e7f" translate="yes" xml:space="preserve">
          <source>Automatic code formatting</source>
          <target state="translated">자동 코드 포맷</target>
        </trans-unit>
        <trans-unit id="a5325c58f3190f03981f3d4b6e263a0fcae8b5bc" translate="yes" xml:space="preserve">
          <source>Available options are:</source>
          <target state="translated">사용 가능한 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="092cd6bcec2dc4f94a4fc33bc1ed3409700531e1" translate="yes" xml:space="preserve">
          <source>Avoid &lt;code&gt;use&lt;/code&gt; when an &lt;code&gt;import&lt;/code&gt; is enough</source>
          <target state="translated">&lt;code&gt;import&lt;/code&gt; 이 충분할 때 &lt;code&gt;use&lt;/code&gt; 피하십시오</target>
        </trans-unit>
        <trans-unit id="41d25fe1a41fca091b7e6f07deb9576aa406ed90" translate="yes" xml:space="preserve">
          <source>Avoid application configuration</source>
          <target state="translated">응용 프로그램 구성을 피하십시오</target>
        </trans-unit>
        <trans-unit id="7dd92d342635cd8bad5012751cc0ba8c68f401f5" translate="yes" xml:space="preserve">
          <source>Avoid macros</source>
          <target state="translated">매크로 피하기</target>
        </trans-unit>
        <trans-unit id="f82e2d945abfb2dbbf3f826fcc4d148cee063c63" translate="yes" xml:space="preserve">
          <source>Avoid spawning unsupervised processes</source>
          <target state="translated">감독되지 않은 프로세스 생성 방지</target>
        </trans-unit>
        <trans-unit id="8ee9dc89a780c53fc8d9382fa5ad113c6c75cdf9" translate="yes" xml:space="preserve">
          <source>Avoid using exceptions for control-flow</source>
          <target state="translated">제어 흐름에 예외를 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="29209be29de64c2bb9545649ddfd6abf62c0ea65" translate="yes" xml:space="preserve">
          <source>Avoid using processes for code organization</source>
          <target state="translated">코드 구성에 프로세스를 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="ee960a2bc0567e3f91ebc97f2955ec11939e5015" translate="yes" xml:space="preserve">
          <source>Avoid working with invalid data</source>
          <target state="translated">유효하지 않은 데이터로 작업하지 마십시오</target>
        </trans-unit>
        <trans-unit id="6bbd15d15dade34920aa898885177fb819b3bbad" translate="yes" xml:space="preserve">
          <source>Awaits a task reply and returns it.</source>
          <target state="translated">작업 응답을 기다렸다가 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b3776d63ad7b7a84bfe20d9c6d4a53a2b25d0e43" translate="yes" xml:space="preserve">
          <source>Backends</source>
          <target state="translated">Backends</target>
        </trans-unit>
        <trans-unit id="607e2afde4148b04e8bd542f10f2849f8f644bf6" translate="yes" xml:space="preserve">
          <source>Backends added by this function are not persisted. Therefore if the Logger application or supervision tree is restarted, the backend won't be available. If you need this guarantee, then configure the backend via the application environment.</source>
          <target state="translated">이 기능으로 추가 된 백엔드는 유지되지 않습니다. 따라서 로거 응용 프로그램 또는 감독 트리가 다시 시작되면 백엔드를 사용할 수 없습니다. 이 보증이 필요한 경우 응용 프로그램 환경을 통해 백엔드를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="43d581f1eb0812cfb36d4f0598607e6abe9c3fc9" translate="yes" xml:space="preserve">
          <source>Backends typically allow developers to supply such control strings via configuration files. This module provides &lt;a href=&quot;#compile/1&quot;&gt;&lt;code&gt;compile/1&lt;/code&gt;&lt;/a&gt;, which compiles the string into a format for fast operations at runtime and &lt;a href=&quot;#format/5&quot;&gt;&lt;code&gt;format/5&lt;/code&gt;&lt;/a&gt; to format the compiled pattern into an actual IO data.</source>
          <target state="translated">백엔드는 일반적으로 개발자가 구성 파일을 통해 이러한 제어 문자열을 제공 할 수 있도록합니다. 이 모듈은 &lt;a href=&quot;#compile/1&quot;&gt; &lt;code&gt;compile/1&lt;/code&gt; &lt;/a&gt; 을 제공합니다. 런타임은 문자열을 런타임에 빠른 조작을위한 형식으로 컴파일 하고 &lt;a href=&quot;#format/5&quot;&gt; &lt;code&gt;format/5&lt;/code&gt; &lt;/a&gt; 는 컴파일 된 패턴을 실제 IO 데이터로 형식화합니다.</target>
        </trans-unit>
        <trans-unit id="01490bc8fe9235ceac536a8719e2fd8ca0b13630" translate="yes" xml:space="preserve">
          <source>BadArityError</source>
          <target state="translated">BadArityError</target>
        </trans-unit>
        <trans-unit id="1df44135a4f51a5f9d12b388a32c4c2e6d2a6b30" translate="yes" xml:space="preserve">
          <source>BadArityError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">BadArityError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5bb59613df97911bc039ac4ce8ed0b812a7d3491" translate="yes" xml:space="preserve">
          <source>BadBooleanError</source>
          <target state="translated">BadBooleanError</target>
        </trans-unit>
        <trans-unit id="57ba7227528009570f1b1d15380fc32ed086f39e" translate="yes" xml:space="preserve">
          <source>BadBooleanError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">BadBooleanError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="a0852fff990851477fa9d2fdee0a9048bbbbdb7d" translate="yes" xml:space="preserve">
          <source>BadFunctionError</source>
          <target state="translated">BadFunctionError</target>
        </trans-unit>
        <trans-unit id="e756ec5075fbedd06423ae8813b13fdf69470cc6" translate="yes" xml:space="preserve">
          <source>BadFunctionError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">BadFunctionError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f157c6b78035669d35edd4f53d7a99803e6b19c9" translate="yes" xml:space="preserve">
          <source>BadMapError</source>
          <target state="translated">BadMapError</target>
        </trans-unit>
        <trans-unit id="a74cad8b7640a588410f7882a3ccc9f02553c083" translate="yes" xml:space="preserve">
          <source>BadMapError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">BadMapError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="a7b05ea8ad05f0867a5f60c4ed382b666fac7e20" translate="yes" xml:space="preserve">
          <source>BadStructError</source>
          <target state="translated">BadStructError</target>
        </trans-unit>
        <trans-unit id="77be63d18634fd3f43204f653d7f4f7be7b6d9cf" translate="yes" xml:space="preserve">
          <source>BadStructError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">BadStructError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="077fe9c54ed5ed26fa547f4ded3ef9a9bb066d65" translate="yes" xml:space="preserve">
          <source>Base</source>
          <target state="translated">Base</target>
        </trans-unit>
        <trans-unit id="b061ce422c6698d64988deeb26c5124d27241a6d" translate="yes" xml:space="preserve">
          <source>Base 16 alphabet</source>
          <target state="translated">기본 16 알파벳</target>
        </trans-unit>
        <trans-unit id="d9713d603d3e619edcf68e9a83a17b392250a596" translate="yes" xml:space="preserve">
          <source>Base 32 (extended hex) alphabet</source>
          <target state="translated">기본 32 (확장 16 진수) 알파벳</target>
        </trans-unit>
        <trans-unit id="f6d0d37e0e6abc4695da716daeb5b71bf9e4e8a9" translate="yes" xml:space="preserve">
          <source>Base 32 alphabet</source>
          <target state="translated">기본 32 알파벳</target>
        </trans-unit>
        <trans-unit id="2ace0138e855f83bb01e7ea6cfff3e40f0341e66" translate="yes" xml:space="preserve">
          <source>Base 64 (URL and filename safe) alphabet</source>
          <target state="translated">Base 64 (URL 및 파일 이름 안전) 알파벳</target>
        </trans-unit>
        <trans-unit id="a8bce8929575acb7ad98c820c9d117c8df047208" translate="yes" xml:space="preserve">
          <source>Base 64 alphabet</source>
          <target state="translated">기본 64 알파벳</target>
        </trans-unit>
        <trans-unit id="8f7bbf48e0f79ed0979b2afc3fafb20bb06f11dd" translate="yes" xml:space="preserve">
          <source>Basic EEx engine that ships with Elixir.</source>
          <target state="translated">Elixir와 함께 제공되는 기본 EEx 엔진.</target>
        </trans-unit>
        <trans-unit id="3fea98561b7f996109a7e74c90044335541db19e" translate="yes" xml:space="preserve">
          <source>Basic arithmetic</source>
          <target state="translated">기본 산술</target>
        </trans-unit>
        <trans-unit id="ab72076fa59e5852da2fccb552c3249d259cf025" translate="yes" xml:space="preserve">
          <source>Basic operators</source>
          <target state="translated">기본 연산자</target>
        </trans-unit>
        <trans-unit id="3fc431b29bb2c2516db706b2f480a558166eba6d" translate="yes" xml:space="preserve">
          <source>Basic types</source>
          <target state="translated">기본 유형</target>
        </trans-unit>
        <trans-unit id="5db51d4d8d4118f127c924c3d2f8f040e27fb0f4" translate="yes" xml:space="preserve">
          <source>Basic writing and formatting syntax</source>
          <target state="translated">기본 작성 및 서식 구문</target>
        </trans-unit>
        <trans-unit id="6e3c900efbf268090f3977656c91979f9f90e7e4" translate="yes" xml:space="preserve">
          <source>Be aware that a negative &lt;code&gt;count&lt;/code&gt; implies the &lt;code&gt;enumerable&lt;/code&gt; will be enumerated twice: once to calculate the position, and a second time to do the actual splitting.</source>
          <target state="translated">음수 &lt;code&gt;count&lt;/code&gt; 는 &lt;code&gt;enumerable&lt;/code&gt; 이 위치를 계산하기 위해 한 번, 실제 분할을 수행하기 위해 두 번 열거 된다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="c537de13da2b3fc86676babd1bbd74c778fed4a2" translate="yes" xml:space="preserve">
          <source>Be aware that this function can match within or across grapheme boundaries. For example, take the grapheme &quot;&amp;eacute;&quot; which is made of the characters &quot;e&quot; and the acute accent. The following returns &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">이 함수는 grapheme 경계 내에서 또는 grapheme 경계에서 일치 할 수 있습니다. 예를 들어, 문자 &quot;e&quot;와 급성 악센트로 구성된 그래프 &quot;&amp;eacute;&quot;를 사용하십시오. 다음은 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="fe3b9560a0f552cce44a7d701654dd7f10621bc4" translate="yes" xml:space="preserve">
          <source>Be aware that this function can split within or across grapheme boundaries. For example, take the grapheme &quot;&amp;eacute;&quot; which is made of the characters &quot;e&quot; and the acute accent. The following will split the string into two parts:</source>
          <target state="translated">이 함수는 그래 핀 경계 내에서 또는 그래 핀 경계로 분할 될 수 있습니다. 예를 들어, 문자 &quot;e&quot;와 급성 악센트로 구성된 그래프 &quot;&amp;eacute;&quot;를 사용하십시오. 다음은 문자열을 두 부분으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="cf25f9df3bad9cb90f28a2c00f8a03ffb9eb9c29" translate="yes" xml:space="preserve">
          <source>Be careful when invoking this function as any project configuration won't be reloaded.</source>
          <target state="translated">프로젝트 구성이 다시로드되지 않으므로이 기능을 호출 할 때주의하십시오.</target>
        </trans-unit>
        <trans-unit id="e18c280856e9dc54c0e0dc6a6cbf86bdcec2ba1b" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; does not hold time information, data will be lost during the conversion.</source>
          <target state="translated">때문에 &lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 시간 정보를 보유하지 않으며, 데이터를 변환하는 동안 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="89a503aad4225c39937eafdaf3de6829d7a2c3d7" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; does not hold time nor time zone information, data will be lost during the conversion.</source>
          <target state="translated">때문에 &lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 시간이나 시간대 정보를 보유하지 않으며, 데이터를 변환하는 동안 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="ee3ed875cfa3017d3e47eeb02c53615d3ef66c7c" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; does not hold time zone information, any time zone related data will be lost during the conversion.</source>
          <target state="translated">때문에 &lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; 이&lt;/a&gt; 시간대 정보를 보유하지 않으며, 어떤 시간대와 관련된 데이터는 변환하는 동안 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="9953ea4685d0c190284f858b1d39f874790b5054" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;time&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; does not hold date information, data will be lost during the conversion.</source>
          <target state="translated">때문에 &lt;a href=&quot;time&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; 날짜 정보를 보유하지 않으며, 데이터를 변환하는 동안 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="a4d4f5f9b7fb3d32cc67b90484bddec4871ac391" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;time&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; does not hold date nor time zone information, data will be lost during the conversion.</source>
          <target state="translated">때문에 &lt;a href=&quot;time&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; 날짜 나 시간대 정보를 보유하지 않으며, 데이터를 변환하는 동안 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="78be6a8f5f24d82881c32f396a97e82cbdfa517d" translate="yes" xml:space="preserve">
          <source>Because a message may arrive before the timeout is set, even a timeout of &lt;code&gt;0&lt;/code&gt; milliseconds is not guaranteed to execute. To take another action immediately and unconditionally, use a &lt;code&gt;:continue&lt;/code&gt; instruction.</source>
          <target state="translated">시간 초과가 설정되기 전에 메시지가 도착할 수 있으므로 &lt;code&gt;0&lt;/code&gt; 밀리 초의 시간 초과 가 실행되도록 보장되지는 않습니다. 무조건 즉시 다른 조치를 취하려면 &lt;code&gt;:continue&lt;/code&gt; 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4eb887b63f6f74f7dc70ebfb02ba9a98c81899af" translate="yes" xml:space="preserve">
          <source>Because code comments are handled apart from the code representation (AST), there are some situations where code comments are seen as ambiguous by the code formatter. For example, the comment in the anonymous function below</source>
          <target state="translated">코드 주석은 코드 표현 (AST)과 별도로 처리되므로 코드 주석이 코드 포맷터에 의해 모호한 것으로 보이는 상황이 있습니다. 예를 들어 아래 익명 함수의 주석은</target>
        </trans-unit>
        <trans-unit id="cb95a029baf84de67bb48b3b03c76e87ea66bc98" translate="yes" xml:space="preserve">
          <source>Because private functions cannot be accessed externally, Elixir will warn if a private function has a &lt;code&gt;@doc&lt;/code&gt; attribute and will discard its content. However, you can add code comments to private functions, as with any other piece of code, and we recommend developers to do so whenever they believe it will add relevant information to the readers and maintainers of such code.</source>
          <target state="translated">개인용 함수는 외부에서 액세스 할 수 없으므로 개인용 함수에 &lt;code&gt;@doc&lt;/code&gt; 속성 이 있으면 Elixir가 경고 하고 해당 내용을 버립니다. 그러나 다른 코드와 마찬가지로 개인 함수에 코드 주석을 추가 할 수 있으며, 개발자가 해당 코드의 독자와 관리자에게 관련 정보를 추가 할 것으로 판단 될 때마다 그렇게하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="63e17dd4459e7d876a444fbbbb7e7cf39c566595" translate="yes" xml:space="preserve">
          <source>Because processes are linked, we now see a message saying the parent process, which is the shell process, has received an EXIT signal from another process causing the shell to terminate. IEx detects this situation and starts a new shell session.</source>
          <target state="translated">프로세스가 연결되었으므로 셸 프로세스 인 상위 프로세스가 다른 프로세스에서 EXIT 신호를 수신하여 셸이 종료되었다는 메시지가 표시됩니다. IEx는이 상황을 감지하고 새 쉘 세션을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="974c41adb42d893477152cfa18608582df7753a0" translate="yes" xml:space="preserve">
          <source>Because we have assigned the value of 1 to the variable x, this last example could also have been written as:</source>
          <target state="translated">변수 x에 값 1을 할당 했으므로이 마지막 예는 다음과 같이 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4b97ed92549a1467b9e669e260cb145416087a8" translate="yes" xml:space="preserve">
          <source>Because we passed the &lt;code&gt;--sup&lt;/code&gt; flag, Mix automatically added &lt;code&gt;mod: {KVServer.Application, []}&lt;/code&gt;, specifying that &lt;code&gt;KVServer.Application&lt;/code&gt; is our application callback module. &lt;code&gt;KVServer.Application&lt;/code&gt; will start our application supervision tree.</source>
          <target state="translated">&lt;code&gt;--sup&lt;/code&gt; 플래그를 전달 했으므로 Mix는 자동으로 &lt;code&gt;mod: {KVServer.Application, []}&lt;/code&gt; 을 추가하여 &lt;code&gt;KVServer.Application&lt;/code&gt; 이 애플리케이션 콜백 모듈 임을 지정합니다 . &lt;code&gt;KVServer.Application&lt;/code&gt; 이 애플리케이션 감독 트리를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="0e079b753ab1db1c0b01fd308f3688e970fbe5e7" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP 21, the call is going to block until a connection happens. This was done to guarantee ordering. Starting with Erlang/OTP 21, both Erlang and Elixir do not block the call.</source>
          <target state="translated">Erlang / OTP 21 이전에는 통화가 연결될 때까지 차단됩니다. 주문을 보장하기 위해 수행되었습니다. Erlang / OTP 21부터는 Erlang과 Elixir가 통화를 차단하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0bd87597929851d458fd795ea7da7ac0201de944" translate="yes" xml:space="preserve">
          <source>Before creating our new application, we must discuss how Mix handles dependencies. In practice, there are two kinds of dependencies we usually work with: internal and external dependencies. Mix supports mechanisms to work with both of them.</source>
          <target state="translated">새로운 애플리케이션을 만들기 전에 Mix가 종속성을 처리하는 방법에 대해 논의해야합니다. 실제로는 일반적으로 내부 및 외부 종속성이라는 두 가지 종류의 종속성이 있습니다. 믹스는이 두 가지를 다룰 수있는 메커니즘을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="9e1d3d5382e86bf1a14e9500b332884bdb9faaa9" translate="yes" xml:space="preserve">
          <source>Before doing anything, Mix will compile the current application if needed, unless you pass &lt;code&gt;--no-compile&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--no-compile&lt;/code&gt; 을 전달하지 않으면 Mix는 필요한 경우 현재 응용 프로그램을 컴파일 합니다.</target>
        </trans-unit>
        <trans-unit id="deff23ba4c089e0db16c965d3ed9a26698499445" translate="yes" xml:space="preserve">
          <source>Before moving on and adding more features to &lt;code&gt;KV.Bucket&lt;/code&gt;, let&amp;rsquo;s talk about ExUnit callbacks. As you may expect, all &lt;code&gt;KV.Bucket&lt;/code&gt; tests will require a bucket agent to be up and running. Luckily, ExUnit supports callbacks that allow us to skip such repetitive tasks.</source>
          <target state="translated">&lt;code&gt;KV.Bucket&lt;/code&gt; 으로 넘어 가서 더 많은 기능을 추가하기 전에 ExUnit 콜백에 대해 이야기 해 봅시다. 예상 &lt;code&gt;KV.Bucket&lt;/code&gt; 모든 KV.Bucket 테스트에는 버킷 에이전트가 시작되어 실행 중이 어야 합니다. 다행히 ExUnit은 이러한 반복적 인 작업을 건너 뛸 수있는 콜백을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="961885446a9fe194662c4186d4c9a590779945e8" translate="yes" xml:space="preserve">
          <source>Before running the code, it invokes the &lt;code&gt;app.start&lt;/code&gt; task which compiles and loads your project. Then the target expression is profiled, together with all matching function calls using the Erlang trace BIFs. The tracing of the function calls for that is enabled when the profiling is begun, and disabled when profiling is stopped.</source>
          <target state="translated">코드를 실행하기 전에 프로젝트를 컴파일하고로드 하는 &lt;code&gt;app.start&lt;/code&gt; 태스크를 호출합니다 . 그런 다음 Erlang 추적 BIF를 사용하여 일치하는 모든 함수 호출과 함께 대상 표현식이 프로파일됩니다. 함수 호출 추적은 프로파일 링이 시작될 때 활성화되고 프로파일 링이 중지되면 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="98349800481aea068998de4b5050ab0150891107" translate="yes" xml:space="preserve">
          <source>Before running the code, it invokes the &lt;code&gt;app.start&lt;/code&gt; task which compiles and loads your project. Then the target expression is profiled, together with all matching function calls, by setting breakpoints containing counters. These can only be set on BEAM code so BIFs cannot be call count traced.</source>
          <target state="translated">코드를 실행하기 전에 프로젝트를 컴파일하고로드 하는 &lt;code&gt;app.start&lt;/code&gt; 태스크를 호출합니다 . 그런 다음 카운터를 포함하는 중단 점을 설정하여 모든 일치하는 함수 호출과 함께 대상 표현식이 프로파일됩니다. 이는 BEAM 코드에서만 설정할 수 있으므로 BIF를 호출 횟수를 추적 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0c0b9f1f5eae004310d510256ead240f82165663" translate="yes" xml:space="preserve">
          <source>Before running the code, it invokes the &lt;code&gt;app.start&lt;/code&gt; task which compiles and loads your project. Then the target expression is profiled, together with all processes which are spawned by it. Other processes (e.g. those residing in the OTP application supervision tree) are not profiled.</source>
          <target state="translated">코드를 실행하기 전에 프로젝트를 컴파일하고로드 하는 &lt;code&gt;app.start&lt;/code&gt; 태스크를 호출합니다 . 그런 다음 대상 표현식이 생성 된 모든 프로세스와 함께 대상 표현식이 프로파일됩니다. 다른 프로세스 (예 : OTP 응용 프로그램 감독 트리에있는 프로세스)는 프로파일 링되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1031dca640f3e14f582133d487561b8ee04d85da" translate="yes" xml:space="preserve">
          <source>Before we added monitoring, if a bucket crashed, the registry would forever point to a bucket that no longer exists. If a user tried to read or write to the crashed bucket, it would fail. Any attempt at creating a new bucket with the same name would just return the PID of the crashed bucket. In other words, that registry entry for that bucket would forever be in a bad state. Once we added monitoring, the registry automatically removes the entry for the crashed bucket. Trying to lookup the crashed bucket now (correctly) says the bucket does not exist and a user of the system can successfully create a new one if desired.</source>
          <target state="translated">모니터링을 추가하기 전에 버킷이 충돌하면 레지스트리는 더 이상 존재하지 않는 버킷을 영원히 가리 킵니다. 사용자가 충돌 한 버킷을 읽거나 쓰려고하면 실패합니다. 이름이 같은 새 버킷을 만들려고하면 충돌 한 버킷의 PID가 반환됩니다. 다시 말해, 해당 버킷의 레지스트리 항목은 영원히 나쁜 상태가됩니다. 모니터링을 추가하면 레지스트리가 충돌 한 버킷에 대한 항목을 자동으로 제거합니다. 충돌 한 버킷을 지금 (올바르게) 찾으려고하면 버킷이 존재하지 않으며 원하는 경우 시스템 사용자가 새 버킷을 성공적으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73411f78618a7af4cd67aad8b3e0200b03df8a87" translate="yes" xml:space="preserve">
          <source>Before we finish this brief introduction, you will notice that, even though we defined a variable &lt;code&gt;x&lt;/code&gt; inside our quote:</source>
          <target state="translated">이 간단한 소개를 마치기 전에 따옴표 안에 변수 &lt;code&gt;x&lt;/code&gt; 를 정의 했음에도 불구하고</target>
        </trans-unit>
        <trans-unit id="9e016d24e4bd4f71c8ebd97643051b410bf7754a" translate="yes" xml:space="preserve">
          <source>Before we implement this function, let&amp;rsquo;s change our server to start using our new &lt;code&gt;parse/1&lt;/code&gt; and &lt;code&gt;run/1&lt;/code&gt; functions. Remember, our &lt;code&gt;read_line/1&lt;/code&gt; function was also crashing when the client closed the socket, so let&amp;rsquo;s take the opportunity to fix it, too. Open up &lt;code&gt;lib/kv_server.ex&lt;/code&gt; and replace the existing server definition:</source>
          <target state="translated">이 함수를 구현하기 전에 새로운 &lt;code&gt;parse/1&lt;/code&gt; 및 &lt;code&gt;run/1&lt;/code&gt; 함수를 사용하도록 서버를 변경해 봅시다 . 우리의 기억 &lt;code&gt;read_line/1&lt;/code&gt; 그래서도 문제를 해결할 수있는 기회를 보자, 클라이언트가 소켓을 닫을 때 기능도 충돌했다. &lt;code&gt;lib/kv_server.ex&lt;/code&gt; 를 열고 기존 서버 정의를 바꾸십시오 :</target>
        </trans-unit>
        <trans-unit id="f3303e03cd7a934490164882116bb279452d10ec" translate="yes" xml:space="preserve">
          <source>Before we move on to the next chapter, let&amp;rsquo;s discuss the client/server dichotomy in agents. Let&amp;rsquo;s expand the &lt;code&gt;delete/2&lt;/code&gt; function we have just implemented:</source>
          <target state="translated">다음 장으로 넘어 가기 전에 에이전트에서 클라이언트 / 서버 이분법에 대해 설명하겠습니다. 방금 구현 한 &lt;code&gt;delete/2&lt;/code&gt; 함수를 확장 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="c38b5c81b1c893dcec882d171436db1cd1a630dc" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;#monitor/2&quot;&gt;&lt;code&gt;monitor/2&lt;/code&gt;&lt;/a&gt; except that it allows an extra option to be given, namely &lt;code&gt;:allow_passive_connect&lt;/code&gt;.</source>
          <target state="translated">추가 옵션 (예 &lt;code&gt;:allow_passive_connect&lt;/code&gt; 제공하는 것을 제외하고 는 &lt;a href=&quot;#monitor/2&quot;&gt; &lt;code&gt;monitor/2&lt;/code&gt; &lt;/a&gt; 로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="e1590670ae5ba07b6059ef77a6163f923d148669" translate="yes" xml:space="preserve">
          <source>Behaves exactly like &lt;a href=&quot;#get_and_update/3&quot;&gt;&lt;code&gt;get_and_update/3&lt;/code&gt;&lt;/a&gt;, but raises a &lt;a href=&quot;keyerror&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception if &lt;code&gt;key&lt;/code&gt; is not present in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#get_and_update/3&quot;&gt; &lt;code&gt;get_and_update/3&lt;/code&gt; &lt;/a&gt; 와 동일하게 동작 하지만 &lt;code&gt;map&lt;/code&gt; 에 &lt;code&gt;key&lt;/code&gt; 가없는 경우 &lt;a href=&quot;keyerror&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="171ca0385a0e84eb697558f3866b7cb4cf03fcb1" translate="yes" xml:space="preserve">
          <source>Behaviour</source>
          <target state="translated">Behaviour</target>
        </trans-unit>
        <trans-unit id="50adeaa74402f255e81a881e8e825fcfde5736a2" translate="yes" xml:space="preserve">
          <source>Behaviours</source>
          <target state="translated">Behaviours</target>
        </trans-unit>
        <trans-unit id="520b702bda3e42703a9629b3c841c1dac503dd33" translate="yes" xml:space="preserve">
          <source>Behaviours are frequently used with dynamic dispatching. For example, we could add a &lt;code&gt;parse!&lt;/code&gt; function to the &lt;code&gt;Parser&lt;/code&gt; module that dispatches to the given implementation and returns the &lt;code&gt;:ok&lt;/code&gt; result or raises in cases of &lt;code&gt;:error&lt;/code&gt;:</source>
          <target state="translated">동작은 동적 디스패치와 함께 자주 사용됩니다. 예를 들어 &lt;code&gt;parse!&lt;/code&gt; 추가 할 수 있습니다 ! 받는 기능 &lt;code&gt;Parser&lt;/code&gt; 모듈이 주어진 구현 및 반환에 파견 &lt;code&gt;:ok&lt;/code&gt; 의 경우에 결과 나 인상 &lt;code&gt;:error&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c431c072b0cc17065274eb235452b6f56afb83ac" translate="yes" xml:space="preserve">
          <source>Behaviours can be referenced by modules to ensure they implement required specific function signatures defined by &lt;code&gt;@callback&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@callback&lt;/code&gt; 에 의해 정의 된 필수 특정 기능 서명을 구현하기 위해 모듈에서 동작을 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18891de861c3177370c1c4c8a6abb93b6d478d0c" translate="yes" xml:space="preserve">
          <source>Behaviours in Elixir (and Erlang) are a way to separate and abstract the generic part of a component (which becomes the &lt;em&gt;behaviour module&lt;/em&gt;) from the specific part (which becomes the &lt;em&gt;callback module&lt;/em&gt;).</source>
          <target state="translated">Elixir (및 Erlang)의 &lt;em&gt;동작&lt;/em&gt; 은 컴포넌트의 일반 부분 ( &lt;em&gt;동작 모듈이 됨&lt;/em&gt; )을 특정 부분 ( &lt;em&gt;콜백 모듈이 됨&lt;/em&gt; ) 과 분리하고 추상화하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="59b495bc5ef8fa3525a42f910a73c32fc61ed8ab" translate="yes" xml:space="preserve">
          <source>Behaviours provide a way to:</source>
          <target state="translated">동작은 다음과 같은 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cc4b77c255d4ba04e467a0cc47a0e51ec0adef1c" translate="yes" xml:space="preserve">
          <source>Behind the scenes, &lt;code&gt;use&lt;/code&gt; requires the given module and then calls the &lt;code&gt;__using__/1&lt;/code&gt; callback on it allowing the module to inject some code into the current context. Some modules (for example, the above &lt;code&gt;ExUnit.Case&lt;/code&gt;, but also &lt;code&gt;Supervisor&lt;/code&gt; and &lt;code&gt;GenServer&lt;/code&gt;) use this mechanism to populate your module with some basic behaviour, which your module is intended to override or complete.</source>
          <target state="translated">장면 뒤에서 &lt;code&gt;use&lt;/code&gt; 하려면 주어진 모듈이 필요하고 모듈에서 &lt;code&gt;__using__/1&lt;/code&gt; 콜백을 호출하여 모듈이 현재 컨텍스트에 코드를 삽입 할 수 있습니다. (예를 들어, 위의 일부 모듈 &lt;code&gt;ExUnit.Case&lt;/code&gt; 도 있지만, &lt;code&gt;Supervisor&lt;/code&gt; 및 &lt;code&gt;GenServer&lt;/code&gt; 는 ) 모듈이 재정 또는 전체를 대상으로 몇 가지 기본 동작과 모듈을 채우는 데이 메커니즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="603deb4a274e7852a27649e6771d381771e20617" translate="yes" xml:space="preserve">
          <source>Below we provide a more detailed look into the available options.</source>
          <target state="translated">아래는 사용 가능한 옵션에 대한 자세한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fcad24575feed887abc51ccc85f8548bece28f68" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#async/1&quot;&gt;&lt;code&gt;async/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#await/2&quot;&gt;&lt;code&gt;await/2&lt;/code&gt;&lt;/a&gt;, tasks can also be started as part of a supervision tree and dynamically spawned on remote nodes. We will explore all three scenarios next.</source>
          <target state="translated">&lt;a href=&quot;#async/1&quot;&gt; &lt;code&gt;async/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#await/2&quot;&gt; &lt;code&gt;await/2&lt;/code&gt; &lt;/a&gt; 외에도 작업은 감독 트리의 일부로 시작되어 원격 노드에서 동적으로 생성 될 수 있습니다. 다음 세 가지 시나리오를 모두 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="84bd8dd7435a7e50a7902eac99410b942c4d0240" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;@before_compile&lt;/code&gt;, there are other useful module attributes like &lt;code&gt;@on_definition&lt;/code&gt; and &lt;code&gt;@after_compile&lt;/code&gt;, which you can read more about in &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt;the docs for the &lt;code&gt;Module&lt;/code&gt; module&lt;/a&gt;. You can also find useful information about macros and the compilation environment in the documentation for the &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html&quot;&gt;&lt;code&gt;Macro&lt;/code&gt; module&lt;/a&gt; and &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">게다가 &lt;code&gt;@before_compile&lt;/code&gt; , 다른 유용한 모듈과 같은 속성이 있습니다 &lt;code&gt;@on_definition&lt;/code&gt; 및 &lt;code&gt;@after_compile&lt;/code&gt; 당신이 더 약 읽을 수 &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt;에 대한 문서 &lt;code&gt;Module&lt;/code&gt; 모듈&lt;/a&gt; . &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html&quot;&gt; &lt;code&gt;Macro&lt;/code&gt; 모듈&lt;/a&gt; 및 &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt; 문서에서 매크로 및 컴파일 환경에 대한 유용한 정보를 찾을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1e80b1ec582384418cc616d1f8343b52b2b4cd5" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;cond&lt;/code&gt;, Elixir also provides the macros &lt;code&gt;if/2&lt;/code&gt; and &lt;code&gt;unless/2&lt;/code&gt; which are useful when you need to check for only one condition:</source>
          <target state="translated">&lt;code&gt;case&lt;/code&gt; 및 &lt;code&gt;cond&lt;/code&gt; 외에도 Elixir는 &lt;code&gt;if/2&lt;/code&gt; 및 &lt;code&gt;unless/2&lt;/code&gt; 매크로를 제공하여 하나의 조건 만 확인해야 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f6cdfaf2baa94aad4e65fa26be490d407b1c2ff9" translate="yes" xml:space="preserve">
          <source>Besides allowing pattern matching on struct fields, such as:</source>
          <target state="translated">구조체 필드에서 다음과 같은 패턴 일치를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="01bb2cd8bbff810bc2463c24d74581c14f3d6b3f" translate="yes" xml:space="preserve">
          <source>Besides environments, Mix supports targets. Targets are useful when a project needs to compile to different architectures and some of the dependencies are only available to some of them. By default, the target is &lt;code&gt;:host&lt;/code&gt; but it can be set via the &lt;code&gt;MIX_TARGET&lt;/code&gt; environment variable. The target can be read via &lt;a href=&quot;mix#target/0&quot;&gt;&lt;code&gt;Mix.target/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">환경 외에도 Mix는 대상을 지원합니다. 대상은 프로젝트가 다른 아키텍처로 컴파일해야 할 때 유용하며 일부 종속성은 일부 종속성 만 사용할 수 있습니다. 기본적으로 대상은 &lt;code&gt;:host&lt;/code&gt; 이지만 &lt;code&gt;MIX_TARGET&lt;/code&gt; 환경 변수 를 통해 설정할 수 있습니다 . 타겟은 &lt;a href=&quot;mix#target/0&quot;&gt; &lt;code&gt;Mix.target/0&lt;/code&gt; 을&lt;/a&gt; 통해 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57fd661d50a52343735a3a512de7f5de0c57eebb" translate="yes" xml:space="preserve">
          <source>Besides functions for opening, reading and writing files, the &lt;code&gt;File&lt;/code&gt; module has many functions to work with the file system. Those functions are named after their UNIX equivalents. For example, &lt;code&gt;File.rm/1&lt;/code&gt; can be used to remove files, &lt;code&gt;File.mkdir/1&lt;/code&gt; to create directories, &lt;code&gt;File.mkdir_p/1&lt;/code&gt; to create directories and all their parent chain. There are even &lt;code&gt;File.cp_r/2&lt;/code&gt; and &lt;code&gt;File.rm_rf/1&lt;/code&gt; to respectively copy and remove files and directories recursively (i.e., copying and removing the contents of the directories too).</source>
          <target state="translated">파일 열기, 읽기 및 쓰기 기능 외에도 &lt;code&gt;File&lt;/code&gt; 모듈에는 파일 시스템에서 작동하는 많은 기능이 있습니다. 이러한 함수는 UNIX와 동등한 것으로 이름이 지정됩니다. 예를 들어 &lt;code&gt;File.rm/1&lt;/code&gt; 을 사용하여 파일을 제거하고 &lt;code&gt;File.mkdir/1&lt;/code&gt; 을 사용하여 디렉토리를 작성하고 &lt;code&gt;File.mkdir_p/1&lt;/code&gt; 을 사용하여 디렉토리 및 모든 상위 체인을 작성할 수 있습니다. 도 있습니다 &lt;code&gt;File.cp_r/2&lt;/code&gt; 및 &lt;code&gt;File.rm_rf/1&lt;/code&gt; 각각 복사하고 (즉, 복사 너무 디렉토리의 내용을 제거) 재귀 적으로 삭제 파일 및 디렉토리.</target>
        </trans-unit>
        <trans-unit id="bf0bf58fef26f8d47abf58c4e98d942fe7e09d41" translate="yes" xml:space="preserve">
          <source>Besides getting a value and updating the agent state, agents allow us to get a value and update the agent state in one function call via &lt;code&gt;Agent.get_and_update/2&lt;/code&gt;. Let&amp;rsquo;s implement a &lt;code&gt;KV.Bucket.delete/2&lt;/code&gt; function that deletes a key from the bucket, returning its current value:</source>
          <target state="translated">에이전트는 값을 가져오고 에이전트 상태를 업데이트하는 것 외에도 &lt;code&gt;Agent.get_and_update/2&lt;/code&gt; 를 통해 하나의 함수 호출로 값을 가져 와서 에이전트 상태를 업데이트 할 수 있습니다. 버킷에서 키를 삭제하고 현재 값을 반환 하는 &lt;code&gt;KV.Bucket.delete/2&lt;/code&gt; 함수를 구현해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="9789e063966a758871f9c998af33a9bf355ebc18" translate="yes" xml:space="preserve">
          <source>Besides lowercase sigils, Elixir supports uppercase sigils to deal with escaping characters and interpolation. While both &lt;code&gt;~s&lt;/code&gt; and &lt;code&gt;~S&lt;/code&gt; will return strings, the former allows escape codes and interpolation while the latter does not:</source>
          <target state="translated">소문자시길 외에도 Elixir는 대문자시길을 지원하여 이스케이프 문자 및 보간을 처리합니다. &lt;code&gt;~s&lt;/code&gt; 와 &lt;code&gt;~S&lt;/code&gt; 는 모두 문자열을 반환하지만 전자는 이스케이프 코드와 보간을 허용하지만 후자는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7d97bd69019c17af96e7bec585780be62ea803d" translate="yes" xml:space="preserve">
          <source>Besides regular expressions, Elixir ships with three other sigils.</source>
          <target state="translated">정규 표현식 외에도 Elixir는 세 개의 다른시길을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fa2db308837aea27b007c38a306f2dbb8af757b6" translate="yes" xml:space="preserve">
          <source>Besides relying on pattern matching, &lt;code&gt;rescue&lt;/code&gt; clauses provide some conveniences around exceptions that allow one to rescue an exception by its name. All the following formats are valid patterns in &lt;code&gt;rescue&lt;/code&gt; clauses:</source>
          <target state="translated">패턴 일치에 의존하는 것 외에도 &lt;code&gt;rescue&lt;/code&gt; 절은 예외 이름을 기준으로 예외를 구조 할 수있는 예외에 대한 편의성을 제공합니다. 다음의 모든 형식의 유효한 패턴입니다 &lt;code&gt;rescue&lt;/code&gt; 조항 :</target>
        </trans-unit>
        <trans-unit id="3ce006769a3ad73d2aa5c3e5097589962e275bb7" translate="yes" xml:space="preserve">
          <source>Besides the &lt;code&gt;BREAK&lt;/code&gt; menu, one can type &lt;code&gt;Ctrl+G&lt;/code&gt; to get to the &lt;code&gt;User switch command&lt;/code&gt; menu. When reached, you can type &lt;code&gt;h&lt;/code&gt; to get more information.</source>
          <target state="translated">&lt;code&gt;BREAK&lt;/code&gt; 메뉴 외에도 &lt;code&gt;Ctrl+G&lt;/code&gt; 를 입력 하여 &lt;code&gt;User switch command&lt;/code&gt; 메뉴 로 이동할 수 있습니다. 도달하면 &lt;code&gt;h&lt;/code&gt; 를 입력 하여 자세한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17a296909c364def2f70ba9542fcca5af1be1690" translate="yes" xml:space="preserve">
          <source>Besides the booleans &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; Elixir also has the concept of a &quot;truthy&quot; or &quot;falsy&quot; value.</source>
          <target state="translated">부울 외에 &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;false&lt;/code&gt; 엘릭서도 &quot;거짓&quot;또는 &quot;거짓&quot;값의 개념을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b77eafa1881088ae45eaa4e4da415f6bbc48892" translate="yes" xml:space="preserve">
          <source>Besides the functions available in this module, the &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module exposes and auto-imports some basic functionality related to processes available through the following functions:</source>
          <target state="translated">이 모듈에서 사용 가능한 기능 외에도 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 모듈은 다음 기능을 통해 사용 가능한 프로세스와 관련된 몇 가지 기본 기능을 노출하고 자동으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="24c285ef9b5dcc5c662b164a6b173b44cbf8936b" translate="yes" xml:space="preserve">
          <source>Besides the modules and functions libraries provide as part of their public interface, libraries may also implement important functionality that is not part of their API. While these modules and functions can be accessed, they are meant to be internal to the library and thus should not have documentation for end users.</source>
          <target state="translated">라이브러리는 공용 인터페이스의 일부로 제공하는 모듈 및 함수 외에도 API의 일부가 아닌 중요한 기능을 구현할 수 있습니다. 이러한 모듈과 기능은 액세스 할 수 있지만 라이브러리 내부에 포함되므로 최종 사용자 용 설명서가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="d1e278a8ee8e14b171370d3d1993e61557fa885d" translate="yes" xml:space="preserve">
          <source>Besides the synchronous and asynchronous communication provided by &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt;, &quot;regular&quot; messages sent by functions such as &lt;a href=&quot;kernel#send/2&quot;&gt;&lt;code&gt;Kernel.send/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;process#send_after/4&quot;&gt;&lt;code&gt;Process.send_after/4&lt;/code&gt;&lt;/a&gt; and similar, can be handled inside the &lt;a href=&quot;#c:handle_info/2&quot;&gt;&lt;code&gt;handle_info/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">&lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; 가&lt;/a&gt; 제공하는 동기 및 비동기 통신 외에도 &lt;a href=&quot;kernel#send/2&quot;&gt; &lt;code&gt;Kernel.send/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;process#send_after/4&quot;&gt; &lt;code&gt;Process.send_after/4&lt;/code&gt; &lt;/a&gt; 등의 기능으로 전송 된 &quot;일반&quot;메시지 는 &lt;a href=&quot;#c:handle_info/2&quot;&gt; &lt;code&gt;handle_info/2&lt;/code&gt; &lt;/a&gt; 콜백 내에서 처리 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="517337ce1caa7ff89458c6a131be85fc7edc22c4" translate="yes" xml:space="preserve">
          <source>Besides the tuple defined above, there are five Elixir literals that, when quoted, return themselves (and not a tuple). They are:</source>
          <target state="translated">위에 정의 된 튜플 외에, 인용 될 때 튜플이 아닌 자신을 반환하는 5 개의 Elixir 리터럴이 있습니다. 그들은:</target>
        </trans-unit>
        <trans-unit id="36c1c37f1ad939c92cf62bb17cfdd2a856f1bff4" translate="yes" xml:space="preserve">
          <source>Besides the tuple described above, Elixir has a few literals that are also part of its AST. Those literals return themselves when quoted. They are:</source>
          <target state="translated">위에서 설명한 튜플 외에도 Elixir에는 AST의 일부인 리터럴이 있습니다. 이 리터럴은 인용시 스스로 반환합니다. 그들은:</target>
        </trans-unit>
        <trans-unit id="be7cb95beca4417119b196c5145eac30a92f05f3" translate="yes" xml:space="preserve">
          <source>Besides these boolean operators, Elixir also provides &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;!&lt;/code&gt; which accept arguments of any type. For these operators, all values except &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt; will evaluate to true:</source>
          <target state="translated">이 부울 연산자 외에도 Elixir는 &lt;code&gt;||&lt;/code&gt; , &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;!&lt;/code&gt; 모든 유형의 인수를 허용합니다. 이러한 연산자의 경우 &lt;code&gt;false&lt;/code&gt; 및 &lt;code&gt;nil&lt;/code&gt; 을 제외한 모든 값 은 true로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="eb8de9ce8757ee3c542141ac80ff3b33dc04edff" translate="yes" xml:space="preserve">
          <source>Best practices</source>
          <target state="translated">모범 사례</target>
        </trans-unit>
        <trans-unit id="21f3045d2e00281b8e684e3df830ced85cb7ac6f" translate="yes" xml:space="preserve">
          <source>Between &lt;code&gt;(&lt;/code&gt;/&lt;code&gt;)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;(&lt;/code&gt; / &lt;code&gt;)&lt;/code&gt; 사이 :</target>
        </trans-unit>
        <trans-unit id="c2e583cf3da1aee0a9f017fc5ad1b43ad947c175" translate="yes" xml:space="preserve">
          <source>Between &lt;code&gt;fn/end&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;fn/end&lt;/code&gt; 사이 :</target>
        </trans-unit>
        <trans-unit id="b564736adfe95cd2b39d3044818184c7616b6b8d" translate="yes" xml:space="preserve">
          <source>Between &lt;code&gt;use ExUnit.Case&lt;/code&gt; and setup, add the following call:</source>
          <target state="translated">&lt;code&gt;use ExUnit.Case&lt;/code&gt; 과 설정 사이 에 다음 호출을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="536a214ab9480c5673911e94b4e8775035965909" translate="yes" xml:space="preserve">
          <source>Beware that the Erlang VM does not terminate child processes when it shuts down. Therefore, if you use &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix cmd&lt;/code&gt;&lt;/a&gt; to start long running processes and then shut down the VM, it is likely that those child processes won't be terminated with the VM.</source>
          <target state="translated">Erlang VM은 종료 될 때 자식 프로세스를 종료하지 않습니다. 따라서 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix cmd&lt;/code&gt; &lt;/a&gt; 를 사용 하여 장기 실행 프로세스를 시작한 다음 VM을 종료하면 해당 하위 프로세스가 VM에서 종료되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac071b29fee9c70fb03e3c3c8147b7946ee31eea" translate="yes" xml:space="preserve">
          <source>Binaries (and bitstrings)</source>
          <target state="translated">이진 (및 비트 열)</target>
        </trans-unit>
        <trans-unit id="b191af7fc34f7fbb5fbc2a69591b4e9bf648fbff" translate="yes" xml:space="preserve">
          <source>Binaries have a representation similar to tuples, except they are tagged with &lt;code&gt;:&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; instead of &lt;code&gt;:{}&lt;/code&gt;:</source>
          <target state="translated">이진은 튜플과 비슷한 표현을 가지고 있지만 &lt;code&gt;:{}&lt;/code&gt; 대신 &lt;code&gt;:&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 태그가 붙어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49aff6fbacb348e58a8db3dc080372ebbadd0f28" translate="yes" xml:space="preserve">
          <source>Binaries, strings, and charlists</source>
          <target state="translated">이진, 문자열 및 charlists</target>
        </trans-unit>
        <trans-unit id="af15fd6b97639efd6a9b693a8880e6903d2f3cd2" translate="yes" xml:space="preserve">
          <source>Binary matching can be used by itself to extract information from binaries:</source>
          <target state="translated">이진 일치를 사용하여 이진에서 정보를 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2042acc40e9773f089632ff1fc5f3d54f8826ee5" translate="yes" xml:space="preserve">
          <source>Binary matching is a powerful feature in Elixir that is useful for extracting information from binaries as well as pattern matching.</source>
          <target state="translated">이진 일치는 패턴 일치뿐만 아니라 이진에서 정보를 추출하는 데 유용한 Elixir의 강력한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="64a4a40cae012874b1a177797783b5c6ec4aefa1" translate="yes" xml:space="preserve">
          <source>Binary pattern matching provides a similar way to decompose a string:</source>
          <target state="translated">이진 패턴 일치는 문자열을 분해하는 비슷한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8ea819ee42276da3a90285cc5b8c1cf028115def" translate="yes" xml:space="preserve">
          <source>Binary pattern matching, however, is simpler and more efficient, so pick the option that better suits your use case.</source>
          <target state="translated">그러나 이진 패턴 일치는 더 간단하고 효율적이므로 사용 사례에 더 적합한 옵션을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="d61004333e425a59f39f73680dda0fe68656875f" translate="yes" xml:space="preserve">
          <source>Binary/Bitstring Matching</source>
          <target state="translated">이진 / 비트 스트링 매칭</target>
        </trans-unit>
        <trans-unit id="c282b192a231740a4b0a7bb6f752b62b8492be4b" translate="yes" xml:space="preserve">
          <source>Binding and unquote fragments</source>
          <target state="translated">조각 바인딩 및 인용 해제</target>
        </trans-unit>
        <trans-unit id="45c425457bcdcfb5085aa625ded75d4bf3929b5b" translate="yes" xml:space="preserve">
          <source>Bitstring - a sequence of bits, created with &lt;a href=&quot;kernel.specialforms#%253C%253C%253E%253E/1&quot;&gt;&lt;code&gt;Kernel.SpecialForms.&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt;&lt;/a&gt;. When the number of bits is divisible by 8, they are called binaries and can be manipulated with Erlang's &lt;code&gt;:binary&lt;/code&gt; module</source>
          <target state="translated">비트 열 &lt;a href=&quot;kernel.specialforms#%253C%253C%253E%253E/1&quot;&gt; &lt;code&gt;Kernel.SpecialForms.&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt; &lt;/a&gt; 생성 된 비트 시퀀스 . 비트 수를 8로 나눌 수있는 경우 이진수를 바이너리라고하며 Erlang의 &lt;code&gt;:binary&lt;/code&gt; 모듈을 사용하여 조작 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ea9d52bc54bc6f374f2fad4f115fc7ac1b63024" translate="yes" xml:space="preserve">
          <source>Bitstring generators</source>
          <target state="translated">비트 스트링 생성기</target>
        </trans-unit>
        <trans-unit id="f3c1518585255719399d723cff9097dc10d6275d" translate="yes" xml:space="preserve">
          <source>Bitstring generators are also supported and are very useful when you need to comprehend over bitstring streams. The example below receives a list of pixels from a binary with their respective red, green and blue values and converts them into tuples of three elements each:</source>
          <target state="translated">비트 스트링 생성기도 지원되며 비트 스트링 스트림을 이해해야 할 때 매우 유용합니다. 아래 예제는 바이너리에서 각 빨강, 녹색 및 파랑 값을 가진 픽셀 목록을 수신하여 각각 세 요소의 튜플로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="beaa67a4353085a5a0b2c675dc039718337cb9d0" translate="yes" xml:space="preserve">
          <source>Bitstring generators are also supported and are very useful when you need to organize bitstring streams:</source>
          <target state="translated">비트 스트링 생성기도 지원되며 비트 스트링 스트림을 구성해야 할 때 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="afaf36b63e4b1dad0901ea18c5897446e09881ea" translate="yes" xml:space="preserve">
          <source>Bitstrings are compared byte by byte, incomplete bytes are compared bit by bit.</source>
          <target state="translated">비트 열은 바이트 단위로 비교되고, 불완전한 바이트는 비트 단위로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="3f687d3e29fc77fc43b356662b1a2660353fff87" translate="yes" xml:space="preserve">
          <source>Bitwise</source>
          <target state="translated">Bitwise</target>
        </trans-unit>
        <trans-unit id="aad380f630b0abfaeebd6b63365cfb723443ad4d" translate="yes" xml:space="preserve">
          <source>Blames the invocation of the given module, function and arguments.</source>
          <target state="translated">주어진 모듈, 함수 및 인수의 호출을 비난합니다.</target>
        </trans-unit>
        <trans-unit id="6f46461436a8e71915de539b6c2a0b43e158d0cd" translate="yes" xml:space="preserve">
          <source>Blink: off.</source>
          <target state="translated">깜박임 : 꺼짐</target>
        </trans-unit>
        <trans-unit id="ba5e3f453d009bde1d3539dbf1179df1faca9394" translate="yes" xml:space="preserve">
          <source>Blink: rapid. MS-DOS ANSI.SYS; 150 per minute or more; not widely supported.</source>
          <target state="translated">깜박임 : 빠릅니다. MS-DOS ANSI.SYS; 분당 150 이상; 널리 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="701dbab8ca66a57b0d87ff8fc2dc263f3150cedf" translate="yes" xml:space="preserve">
          <source>Blink: slow. Less than 150 per minute.</source>
          <target state="translated">깜박임 : 느립니다. 분당 150 미만.</target>
        </trans-unit>
        <trans-unit id="54c45c033f5eb914fae27a646cbd9e23d3750d19" translate="yes" xml:space="preserve">
          <source>Blocks</source>
          <target state="translated">Blocks</target>
        </trans-unit>
        <trans-unit id="2822489452326c302f28e1501fd6edcfc934d1fa" translate="yes" xml:space="preserve">
          <source>Blocks are multiple Elixir expressions separated by newlines or semi-colons. A new block may be created at any moment by using parentheses.</source>
          <target state="translated">블록은 개행 또는 세미콜론으로 구분 된 여러 Elixir 표현식입니다. 괄호를 사용하여 언제든지 새 블록을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d103eae36d19a85d68a720e19cf2a1c73ba893fb" translate="yes" xml:space="preserve">
          <source>Blocks are represented as a &lt;code&gt;__block__&lt;/code&gt; call with each line as a separate argument:</source>
          <target state="translated">블록은 각 행을 별도의 인수 로 사용하여 &lt;code&gt;__block__&lt;/code&gt; 호출로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="c3b2d105cf560a74b63402e4c3067e0eff5cac1a" translate="yes" xml:space="preserve">
          <source>Blocks examples</source>
          <target state="translated">블록 예제</target>
        </trans-unit>
        <trans-unit id="36016951d6cf223fe79a2c8002262083d4f62b06" translate="yes" xml:space="preserve">
          <source>Boolean and.</source>
          <target state="translated">부울과.</target>
        </trans-unit>
        <trans-unit id="c2e29c3c880739783d09b4fe1f081591e67b960c" translate="yes" xml:space="preserve">
          <source>Boolean not.</source>
          <target state="translated">부울이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="39431fd4748e66e596621d8b72c4abb89473c694" translate="yes" xml:space="preserve">
          <source>Boolean or.</source>
          <target state="translated">부울 또는.</target>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="f2506581ad8aed3b0c1c03b8ace8bf389d0d1aef" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;#new/3&quot;&gt;&lt;code&gt;new/3&lt;/code&gt;&lt;/a&gt; and sigil return a struct where the date fields can be accessed directly:</source>
          <target state="translated">&lt;a href=&quot;#new/3&quot;&gt; &lt;code&gt;new/3&lt;/code&gt; &lt;/a&gt; 와 sigil은 모두 날짜 필드에 직접 액세스 할 수있는 구조체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c5670efb08fea60db5c1dc778b7fa5fca46a8dfe" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;#new/4&quot;&gt;&lt;code&gt;new/4&lt;/code&gt;&lt;/a&gt; and sigil return a struct where the time fields can be accessed directly:</source>
          <target state="translated">&lt;a href=&quot;#new/4&quot;&gt; &lt;code&gt;new/4&lt;/code&gt; &lt;/a&gt; 와 sigil은 모두 시간 필드에 직접 액세스 할 수있는 구조체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e6db73dfc41eeeab376e55d7d970cd504e5c8628" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#start/3&quot;&gt;&lt;code&gt;start/3&lt;/code&gt;&lt;/a&gt; support the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; to register a name on start via the &lt;code&gt;:name&lt;/code&gt; option. Registered names are also automatically cleaned up on termination. The supported values are:</source>
          <target state="translated">둘 &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#start/3&quot;&gt; &lt;code&gt;start/3&lt;/code&gt; &lt;/a&gt; 지원 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 는&lt;/a&gt; 바이어 시작에 이름을 등록하는 &lt;code&gt;:name&lt;/code&gt; 옵션을 선택합니다. 등록 된 이름도 종료시 자동으로 정리됩니다. 지원되는 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6a2c37b3cef4535145ce827a33ddc90d02fb5af8" translate="yes" xml:space="preserve">
          <source>Both alias and the regular stack are reenabled when this function is called.</source>
          <target state="translated">이 함수가 호출되면 별명과 일반 스택이 모두 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c950a48885327096ba9eaa9566182e792003879f" translate="yes" xml:space="preserve">
          <source>Both errors and warnings are a list of three-element tuples containing the file, line and the formatted error/warning.</source>
          <target state="translated">오류와 경고는 모두 파일, 행 및 형식화 된 오류 / 경고를 포함하는 3 요소 튜플의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="ced4465ef3cf40ff59c16c913d6d37a1752d7479" translate="yes" xml:space="preserve">
          <source>Both key-based access syntaxes can be used with the nested update functions and macros in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;, such as &lt;a href=&quot;kernel#get_in/2&quot;&gt;&lt;code&gt;Kernel.get_in/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#put_in/3&quot;&gt;&lt;code&gt;Kernel.put_in/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#update_in/3&quot;&gt;&lt;code&gt;Kernel.update_in/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#pop_in/2&quot;&gt;&lt;code&gt;Kernel.pop_in/2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;kernel#get_and_update_in/3&quot;&gt;&lt;code&gt;Kernel.get_and_update_in/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 키 기반 액세스 구문은 &lt;a href=&quot;kernel#get_in/2&quot;&gt; &lt;code&gt;Kernel.get_in/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#put_in/3&quot;&gt; &lt;code&gt;Kernel.put_in/3&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#update_in/3&quot;&gt; &lt;code&gt;Kernel.update_in/3&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#pop_in/2&quot;&gt; &lt;code&gt;Kernel.pop_in/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;kernel#get_and_update_in/3&quot;&gt; &lt;code&gt;Kernel.get_and_update_in/3&lt;/code&gt; &lt;/a&gt; 과 같은 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 의 중첩 업데이트 함수 및 매크로와 함께 사용할 수 있습니다. 3 .</target>
        </trans-unit>
        <trans-unit id="d1725c5aa2fe9943dc5f589af21621f3d6dac806" translate="yes" xml:space="preserve">
          <source>Both keyword lists (list of two-element tuples where the first element is atom) and maps with atom keys support a keyword notation where the colon character &lt;code&gt;:&lt;/code&gt; is moved to the end of the atom. &lt;code&gt;%{hello: &quot;world&quot;}&lt;/code&gt; is equivalent to &lt;code&gt;%{:hello =&amp;gt; &quot;world&quot;}&lt;/code&gt; and &lt;code&gt;[foo: :bar]&lt;/code&gt; is equivalent to &lt;code&gt;[{:foo, :bar}]&lt;/code&gt;. This notation is a syntax sugar that emits the same AST representation. It will be explained in later sections.</source>
          <target state="translated">두 키워드 목록 (첫 번째 요소가 원자 인 두 요소 튜플 목록)과 원자 키가있는 맵은 콜론 문자 &lt;code&gt;:&lt;/code&gt; 가 원자의 끝으로 이동 되는 키워드 표기법을 지원합니다 . &lt;code&gt;%{hello: &quot;world&quot;}&lt;/code&gt; 는 &lt;code&gt;%{:hello =&amp;gt; &quot;world&quot;}&lt;/code&gt; 와 같 으며 &lt;code&gt;[foo: :bar]&lt;/code&gt; 는 &lt;code&gt;[{:foo, :bar}]&lt;/code&gt; . 이 표기법은 동일한 AST 표현을내는 구문 설탕입니다. 이후 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="aeaad2964ed5e5302fd8d6cbf6876b036e35f28d" translate="yes" xml:space="preserve">
          <source>Both parameters can be a filename or an IO device opened with &lt;a href=&quot;#open/2&quot;&gt;&lt;code&gt;open/2&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;bytes_count&lt;/code&gt; specifies the number of bytes to copy, the default being &lt;code&gt;:infinity&lt;/code&gt;.</source>
          <target state="translated">두 매개 변수 모두 파일 이름이거나 &lt;a href=&quot;#open/2&quot;&gt; &lt;code&gt;open/2&lt;/code&gt; &lt;/a&gt; 로 열린 IO 장치 일 수 있습니다 . &lt;code&gt;bytes_count&lt;/code&gt; 는 복사 할 바이트 수를 지정하며 기본값은 &lt;code&gt;:infinity&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b065bf9a58cf78ea7c21c2504ab89c6bf366d41d" translate="yes" xml:space="preserve">
          <source>Both these options accept a keyword list where the key is an atom defining the name of the switch and value is the &lt;code&gt;type&lt;/code&gt; of the switch (see the &quot;Types&quot; section below for more information).</source>
          <target state="translated">이 두 옵션 모두 키워드 목록을 허용합니다. 여기서 키는 스위치 이름을 정의하는 원자이고 값은 스위치 &lt;code&gt;type&lt;/code&gt; 입니다 (자세한 내용은 아래 &quot;유형&quot;섹션 참조).</target>
        </trans-unit>
        <trans-unit id="fe42655b432ab90415ad78eca77b12d1539f938b" translate="yes" xml:space="preserve">
          <source>Both warning behaviours could be changed by explicitly setting the &lt;code&gt;:warn&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:warn&lt;/code&gt; 옵션을 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 로 명시 적으로 설정하여 두 경고 작동을 모두 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4804b38853ff3a7357a1b3869d1bda894f6fb5c8" translate="yes" xml:space="preserve">
          <source>Breaks a pipeline expression into a list.</source>
          <target state="translated">파이프 라인 표현식을 목록으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="a3a49c6ab668c2b3b545008e5e7b0af2866999c8" translate="yes" xml:space="preserve">
          <source>Breaks and &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">브레이크 앤 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d9f59f6ab1ddf5fe748e2618c2c67b4cc598990" translate="yes" xml:space="preserve">
          <source>Bright (increased intensity) or bold.</source>
          <target state="translated">밝음 (증가 강도) 또는 굵게 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="838f6cdccb12d9e52e7eaf582463cf22eb4cba90" translate="yes" xml:space="preserve">
          <source>Bug fixes and security patches</source>
          <target state="translated">버그 수정 및 보안 패치</target>
        </trans-unit>
        <trans-unit id="c41f68079c3956a3a9d158dc0407d610d85618c9" translate="yes" xml:space="preserve">
          <source>Bugs: if an API has undesired behaviour, a program that depends on the buggy behaviour may break if the bug is fixed. We reserve the right to fix such bugs.</source>
          <target state="translated">버그 : API가 원하지 않는 동작을하는 경우 버그가 수정되면 버그 동작에 의존하는 프로그램이 중단 될 수 있습니다. 우리는 그러한 버그를 고칠 권리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a375cb36a8473ab5ec8546cdcf8ac0d2a5cb8b43" translate="yes" xml:space="preserve">
          <source>Build information can be added by appending a plus sign and a series of dot-separated identifiers immediately following the patch or pre-release version. Identifiers consist of only ASCII alphanumeric characters and hyphens (&lt;code&gt;[0-9A-Za-z-]&lt;/code&gt;):</source>
          <target state="translated">패치 또는 시험판 버전 바로 뒤에 더하기 부호와 일련의 점으로 구분 된 식별자를 추가하여 빌드 정보를 추가 할 수 있습니다. 식별자는 ASCII 영숫자와 하이픈 ( &lt;code&gt;[0-9A-Za-z-]&lt;/code&gt; ) 으로 만 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a6e387e513a488787baf35f75987dd36421ea7d2" translate="yes" xml:space="preserve">
          <source>Build segments are ignored: if two versions differ only in their build segment they are considered to be equal.</source>
          <target state="translated">빌드 세그먼트는 무시됩니다. 두 버전이 빌드 ​​세그먼트에서만 다르면 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="bad1e9b6552746278d7a8c6c088673f831353f0b" translate="yes" xml:space="preserve">
          <source>Build your first Elixir project</source>
          <target state="translated">첫 번째 Elixir 프로젝트 구축</target>
        </trans-unit>
        <trans-unit id="a7c7f9a08b1bad090b46d9ebf6e47a7e84c9421c" translate="yes" xml:space="preserve">
          <source>Building IO data is cheaper than concatenating binaries. Concatenating multiple pieces of IO data just means putting them together inside a list since IO data can be arbitrarily nested, and that's a cheap and efficient operation. Most of the IO-based APIs, such as &lt;code&gt;:gen_tcp&lt;/code&gt;, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt;, etc, receive IO data and write it to the socket directly without converting it to binary.</source>
          <target state="translated">IO 데이터를 작성하는 것이 연결된 바이너리보다 저렴합니다. IO 데이터의 여러 조각을 연결한다는 것은 IO 데이터를 임의로 중첩 할 수 있기 때문에 목록 안에 모으는 것을 의미합니다. 이는 저렴하고 효율적인 작업입니다. &lt;code&gt;:gen_tcp&lt;/code&gt; , &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 등과 같은 대부분의 IO 기반 API 는 IO 데이터를 수신하여이를 2 진으로 변환하지 않고 소켓에 직접 씁니다.</target>
        </trans-unit>
        <trans-unit id="c158d8129679833ab365e0432154a06c26bbe385" translate="yes" xml:space="preserve">
          <source>Building on top of the exit signals mentioned above, if the process started by the command line exits with any of the three reasons above, its exit is considered normal and the Operating System process will exit with status 0.</source>
          <target state="translated">위에서 언급 한 종료 신호를 기반으로 명령 행에서 시작한 프로세스가 위의 세 가지 이유로 종료되면 정상 종료로 간주되고 운영 체제 프로세스는 상태 0으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="54488c84dcebf713a9804555c846d54e655ff471" translate="yes" xml:space="preserve">
          <source>Building our own test case</source>
          <target state="translated">우리만의 테스트 케이스 만들기</target>
        </trans-unit>
        <trans-unit id="5b816d21e0eec18041c314dcb38039717c983b72" translate="yes" xml:space="preserve">
          <source>Builds a naive datetime from date and time structs.</source>
          <target state="translated">날짜 및 시간 구조체에서 순진한 datetime을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="3802216eb98726ee9ca40c4c3bac375bd9485cbb" translate="yes" xml:space="preserve">
          <source>Builds a new ISO date.</source>
          <target state="translated">새로운 ISO 날짜를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b5365600952fb4b419ca2ffa21c352a921992cfb" translate="yes" xml:space="preserve">
          <source>Builds a new ISO naive datetime.</source>
          <target state="translated">새로운 ISO 순진 날짜 시간을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="ad04bee5eab482961a816bfa7021b7c0d60dd82a" translate="yes" xml:space="preserve">
          <source>Builds a new time.</source>
          <target state="translated">새로운 시간을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e8ea57a5a998c38bcfc9ffa8c023a39dd669576d" translate="yes" xml:space="preserve">
          <source>Builds a path from &lt;code&gt;relative_to&lt;/code&gt; to &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">에서 경로 구축 &lt;code&gt;relative_to&lt;/code&gt; 에 에 &lt;code&gt;path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22bdb46a287e3157896ab159a9b538b7fcd94ffb" translate="yes" xml:space="preserve">
          <source>Builds an escript for the project.</source>
          <target state="translated">프로젝트에 대한 escript를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="3596331ae831e5817637a172c927de54ca3c406d" translate="yes" xml:space="preserve">
          <source>Builds and overrides a child specification.</source>
          <target state="translated">하위 스펙을 빌드하고 대체합니다.</target>
        </trans-unit>
        <trans-unit id="0943df460e764126fabb5f2d806ad8f731c23730" translate="yes" xml:space="preserve">
          <source>Builds the project structure for the given application.</source>
          <target state="translated">주어진 응용 프로그램의 프로젝트 구조를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="9ce6098db87d0ac3e024a19c0c868db81217ca3a" translate="yes" xml:space="preserve">
          <source>Built-in protocols</source>
          <target state="translated">내장 프로토콜</target>
        </trans-unit>
        <trans-unit id="d424bfa2909fd88b6e78f50f994b1bd31b188869" translate="yes" xml:space="preserve">
          <source>Built-in time zone database that works only in Etc/UTC.</source>
          <target state="translated">Etc / UTC에서만 작동하는 내장 시간대 데이터베이스.</target>
        </trans-unit>
        <trans-unit id="4389d7f528857f621560c37a11c338ec93a16c7f" translate="yes" xml:space="preserve">
          <source>Built-in translation function.</source>
          <target state="translated">내장 번역 기능.</target>
        </trans-unit>
        <trans-unit id="16eecec82d486c492cf075a47b6a4441bd83afc7" translate="yes" xml:space="preserve">
          <source>Built-in type</source>
          <target state="translated">내장형</target>
        </trans-unit>
        <trans-unit id="0f6bebd51ff8927e6e3679a7b2412429e9c60cb6" translate="yes" xml:space="preserve">
          <source>Built-in types</source>
          <target state="translated">내장 타입</target>
        </trans-unit>
        <trans-unit id="3ce0e81919d4eeb06fc46e63df5ab62e9c33b1f7" translate="yes" xml:space="preserve">
          <source>But &lt;strong&gt;do&lt;/strong&gt;:</source>
          <target state="translated">그러나 &lt;strong&gt;할&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="94aeec5dec71ba6c72dd8ee87f32d3fcfa0e12f5" translate="yes" xml:space="preserve">
          <source>But let&amp;rsquo;s also try something different. Let&amp;rsquo;s write integration tests that rely on the global server names to exercise the whole stack from the TCP server to the bucket. Our integration tests will rely on global state and must be synchronous. With integration tests, we get coverage on how the components in our application work together at the cost of test performance. They are typically used to test the main flows in your application. For example, we should avoid using integration tests to test an edge case in our command parsing implementation.</source>
          <target state="translated">그러나 다른 것을 시도해 봅시다. 전역 서버 이름을 사용하여 TCP 서버에서 버킷으로 전체 스택을 실행하는 통합 테스트를 작성해 봅시다. 통합 테스트는 전역 상태에 의존하며 동기식이어야합니다. 통합 테스트를 통해 테스트 성능 비용으로 애플리케이션의 구성 요소가 함께 작동하는 방식에 대해 설명합니다. 일반적으로 응용 프로그램의 주요 흐름을 테스트하는 데 사용됩니다. 예를 들어, 명령 구문 분석 구현에서 통합 테스트를 사용하여 우연한 사례를 테스트하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="2104911582eed895c4670127fe6ced7d06c28a31" translate="yes" xml:space="preserve">
          <source>But this is recommended only for scripting and should be avoided in production code. Generally speaking, processes should always be started inside supervision trees.</source>
          <target state="translated">그러나 이것은 스크립팅에만 권장되며 프로덕션 코드에서는 피해야합니다. 일반적으로 프로세스는 항상 감독 트리 내에서 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="a957b50ab3b7a97450a9f30efde74d666b75a07a" translate="yes" xml:space="preserve">
          <source>But we are not done yet. So far we are supervising the registry but our application is also starting buckets. Since buckets are started dynamically, they have to be supervised by a special type of supervisor, called &lt;code&gt;DynamicSupervisor&lt;/code&gt;, which we will explore next.</source>
          <target state="translated">그러나 아직 끝나지 않았습니다. 지금까지 레지스트리를 감독하고 있지만 응용 프로그램도 버킷을 시작하고 있습니다. 버킷은 동적으로 시작되므로 &lt;code&gt;DynamicSupervisor&lt;/code&gt; 라는 특수 유형의 감독자가 감독해야 합니다.</target>
        </trans-unit>
        <trans-unit id="259915d984d09b8201e37a16fe47bc5e83ead48a" translate="yes" xml:space="preserve">
          <source>By calling &lt;a href=&quot;#register/3&quot;&gt;&lt;code&gt;register/3&lt;/code&gt;&lt;/a&gt;, different processes can register under a given key and associate any value under that key. In this case, let's register the current process under the key &lt;code&gt;&quot;hello&quot;&lt;/code&gt; and attach the &lt;code&gt;{IO, :inspect}&lt;/code&gt; tuple to it:</source>
          <target state="translated">&lt;a href=&quot;#register/3&quot;&gt; &lt;code&gt;register/3&lt;/code&gt; &lt;/a&gt; 를 호출 하면 다른 프로세스가 지정된 키 아래에 등록하고 해당 키 아래의 값을 연결할 수 있습니다. 이 경우 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 키로 현재 프로세스를 등록 하고 &lt;code&gt;{IO, :inspect}&lt;/code&gt; 튜플을 첨부하십시오 .</target>
        </trans-unit>
        <trans-unit id="35c51c698203bdb71ecbe3d1c4e04427369f9034" translate="yes" xml:space="preserve">
          <source>By convention, &lt;code&gt;gcd(0, 0)&lt;/code&gt; returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">관례 적으로 &lt;code&gt;gcd(0, 0)&lt;/code&gt; 은 &lt;code&gt;0&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4048bc8096f6b36395ad6e4a56b15f84086c68e9" translate="yes" xml:space="preserve">
          <source>By default Elixir supports all the module attributes supported by Erlang, but custom attributes can be used as well:</source>
          <target state="translated">기본적으로 Elixir는 Erlang에서 지원하는 모든 모듈 속성을 지원하지만 사용자 정의 속성도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29b4b62fb6ee1da01a3d45071c4e61941d60a2f2" translate="yes" xml:space="preserve">
          <source>By default functions starting with &lt;code&gt;_&lt;/code&gt; are not imported. If you really want to import a function starting with &lt;code&gt;_&lt;/code&gt; you must explicitly include it in the &lt;code&gt;:only&lt;/code&gt; selector.</source>
          <target state="translated">기본적으로 &lt;code&gt;_&lt;/code&gt; 로 시작하는 함수 는 가져 오지 않습니다. &lt;code&gt;_&lt;/code&gt; 로 시작하는 함수를 실제로 가져 오려면 &lt;code&gt;:only&lt;/code&gt; 선택기 에 명시 적으로 포함시켜야합니다 .</target>
        </trans-unit>
        <trans-unit id="428db1ab9fef04afe30a2b4353b549c7fa27a980" translate="yes" xml:space="preserve">
          <source>By default it replaces all occurrences but this behaviour can be controlled through the &lt;code&gt;:global&lt;/code&gt; option; see the &quot;Options&quot; section below.</source>
          <target state="translated">기본적으로 모든 발생을 대체하지만이 동작은 &lt;code&gt;:global&lt;/code&gt; 옵션을 통해 제어 할 수 있습니다 . 아래의 &quot;옵션&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6b5c9ac97926d41c848960a670c7a3023e1508cb" translate="yes" xml:space="preserve">
          <source>By default they are stored in the app path inside the build directory. Umbrella applications have the manifest path set to the root of the build directory. Directories may be changed in future releases.</source>
          <target state="translated">기본적으로 빌드 디렉토리 내의 앱 경로에 저장됩니다. 우산 응용 프로그램에는 매니페스트 경로가 빌드 디렉토리의 루트로 설정되어 있습니다. 향후 릴리스에서 디렉토리가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e03fb74ffa75b5e845b130ed2ea480214ef77b84" translate="yes" xml:space="preserve">
          <source>By default this task works across all environments, unless &lt;code&gt;--only&lt;/code&gt; is given.</source>
          <target state="translated">기본적으로이 작업은 &lt;code&gt;--only&lt;/code&gt; 를 지정 하지 않으면 모든 환경에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="4b1fb5bfb4739bdd9aa579eb2c739f86cf625765" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;EEx&lt;/code&gt;&lt;/a&gt; uses the &lt;a href=&quot;eex.smartengine&quot;&gt;&lt;code&gt;EEx.SmartEngine&lt;/code&gt;&lt;/a&gt; that provides some conveniences on top of the simple &lt;a href=&quot;eex.engine&quot;&gt;&lt;code&gt;EEx.Engine&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;EEx&lt;/code&gt; &lt;/a&gt; 는 간단한 &lt;a href=&quot;eex.engine&quot;&gt; &lt;code&gt;EEx.Engine&lt;/code&gt; 외에도&lt;/a&gt; 편의성을 제공 하는 &lt;a href=&quot;eex.smartengine&quot;&gt; &lt;code&gt;EEx.SmartEngine&lt;/code&gt; &lt;/a&gt; 을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="9bdca89e148f6c41a836026b82ff88340bd20f20" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;#import_file/1&quot;&gt;&lt;code&gt;import_file/1&lt;/code&gt;&lt;/a&gt; fails when the given file does not exist. However, since &lt;a href=&quot;#import_file/1&quot;&gt;&lt;code&gt;import_file/1&lt;/code&gt;&lt;/a&gt; is expanded at compile-time, it's not possible to conditionally import a file since the macro is always expanded:</source>
          <target state="translated">기본적으로 주어진 파일이 없으면 &lt;a href=&quot;#import_file/1&quot;&gt; &lt;code&gt;import_file/1&lt;/code&gt; &lt;/a&gt; 이 실패합니다. 그러나 &lt;a href=&quot;#import_file/1&quot;&gt; &lt;code&gt;import_file/1&lt;/code&gt; &lt;/a&gt; 은 컴파일 타임에 확장되므로 매크로가 항상 확장되므로 조건부로 파일을 가져올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="adb610af913a885c5f8ec16a7315dfe5ad91f080" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;date#to_iso8601/2&quot;&gt;&lt;code&gt;Date.to_iso8601/2&lt;/code&gt;&lt;/a&gt; returns dates formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format through passing the &lt;code&gt;:basic&lt;/code&gt; option.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;date#to_iso8601/2&quot;&gt; &lt;code&gt;Date.to_iso8601/2&lt;/code&gt; &lt;/a&gt; 는 사람이 읽을 수 있도록 &quot;확장 된&quot;형식으로 형식화 된 날짜를 반환합니다. 또한 &lt;code&gt;:basic&lt;/code&gt; 옵션 을 전달하여 &quot;기본&quot;형식을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="ccc1fef33702c4720574cd45b1815c6fd01a3c75" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;datetime#to_iso8601/2&quot;&gt;&lt;code&gt;DateTime.to_iso8601/2&lt;/code&gt;&lt;/a&gt; returns datetimes formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format through passing the &lt;code&gt;:basic&lt;/code&gt; option.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;datetime#to_iso8601/2&quot;&gt; &lt;code&gt;DateTime.to_iso8601/2&lt;/code&gt; &lt;/a&gt; 는 사람이 읽을 수 있도록 &quot;확장 된&quot;형식으로 포맷 된 날짜 시간을 반환합니다. 또한 &lt;code&gt;:basic&lt;/code&gt; 옵션 을 전달하여 &quot;기본&quot;형식을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="31bee08f151471a3561e8ba12545f1a1c133d832" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;naivedatetime#to_iso8601/2&quot;&gt;&lt;code&gt;NaiveDateTime.to_iso8601/2&lt;/code&gt;&lt;/a&gt; returns naive datetimes formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format through passing the &lt;code&gt;:basic&lt;/code&gt; option.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;naivedatetime#to_iso8601/2&quot;&gt; &lt;code&gt;NaiveDateTime.to_iso8601/2&lt;/code&gt; &lt;/a&gt; 는 사람이 읽을 수 있도록 &quot;확장 된&quot;형식으로 포맷 된 순진 날짜 시간을 반환합니다. 또한 &lt;code&gt;:basic&lt;/code&gt; 옵션 을 전달하여 &quot;기본&quot;형식을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="b515c8daeec8b46c7f7d220a1b811128e57e311e" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;time#to_iso8601/2&quot;&gt;&lt;code&gt;Time.to_iso8601/2&lt;/code&gt;&lt;/a&gt; returns times formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format through passing the &lt;code&gt;:basic&lt;/code&gt; option.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;time#to_iso8601/2&quot;&gt; &lt;code&gt;Time.to_iso8601/2&lt;/code&gt; &lt;/a&gt; 는 사람이 읽을 수 있도록 &quot;확장 된&quot;형식으로 형식화 된 시간을 반환합니다. 또한 &lt;code&gt;:basic&lt;/code&gt; 옵션 을 전달하여 &quot;기본&quot;형식을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="b8cda1125e6a420cc973a5e4e861c0de6be40f01" translate="yes" xml:space="preserve">
          <source>By default, Elixir imports functions and macros from the given module, except the ones starting with underscore (which are usually callbacks):</source>
          <target state="translated">기본적으로 Elixir는 밑줄 (보통 콜백)로 시작하는 것을 제외하고 주어진 모듈에서 함수와 매크로를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="94a6204986c6d52028cb274c78170f8522dfc345" translate="yes" xml:space="preserve">
          <source>By default, Elixir provides some basic types, such as &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;pid&lt;/code&gt;, as well as more complex types: for example, the &lt;code&gt;round/1&lt;/code&gt; function, which rounds a float to its nearest integer, takes a &lt;code&gt;number&lt;/code&gt; as an argument (an &lt;code&gt;integer&lt;/code&gt; or a &lt;code&gt;float&lt;/code&gt;) and returns an &lt;code&gt;integer&lt;/code&gt;. As you can see &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#round/1&quot;&gt;in its documentation&lt;/a&gt;, &lt;code&gt;round/1&lt;/code&gt;&amp;rsquo;s typed signature is written as:</source>
          <target state="translated">기본적으로 Elixir는 &lt;code&gt;integer&lt;/code&gt; 또는 &lt;code&gt;pid&lt;/code&gt; 와 같은 몇 가지 기본 유형 과 더 복잡한 유형을 제공합니다. 예를 들어 float를 가장 가까운 정수로 반올림하는 &lt;code&gt;round/1&lt;/code&gt; 함수는 &lt;code&gt;number&lt;/code&gt; 를 인수로 사용합니다 ( &lt;code&gt;integer&lt;/code&gt; 또는 &lt;code&gt;float&lt;/code&gt; )과 다시 표시 &lt;code&gt;integer&lt;/code&gt; . 당신이 볼 수 있듯이 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#round/1&quot;&gt;그 문서에&lt;/a&gt; , &lt;code&gt;round/1&lt;/code&gt; 의 입력 된 서명으로 작성된 것입니다 :</target>
        </trans-unit>
        <trans-unit id="1d78fd453e9e78e2b87f694e9f9cc1959686ec03" translate="yes" xml:space="preserve">
          <source>By default, Elixir uses the record name as the first element of the tuple (the &quot;tag&quot;). However, a different tag can be specified when defining a record, as in the following example, in which we use &lt;code&gt;Customer&lt;/code&gt; as the second argument of &lt;a href=&quot;#defrecord/3&quot;&gt;&lt;code&gt;defrecord/3&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">기본적으로 Elixir는 레코드 이름을 튜플의 첫 번째 요소 ( &quot;태그&quot;)로 사용합니다. 그러나 다음 예제와 같이 레코드를 정의 할 때 다른 태그를 지정할 수 있습니다. 여기서는 &lt;code&gt;Customer&lt;/code&gt; 를 &lt;a href=&quot;#defrecord/3&quot;&gt; &lt;code&gt;defrecord/3&lt;/code&gt; &lt;/a&gt; 의 두 번째 인수로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="fecf0c12d9669a08a42b3ae280cf7c91a67014c4" translate="yes" xml:space="preserve">
          <source>By default, a SIGTERM from the operating system will automatically translate to &lt;a href=&quot;system#stop/0&quot;&gt;&lt;code&gt;System.stop/0&lt;/code&gt;&lt;/a&gt;. You can also have more explicit control over operating system signals via the &lt;a href=&quot;http://www.erlang.org/doc/man/os.html#set_signal-2&quot;&gt;&lt;code&gt;:os.set_signal/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">기본적으로 운영 체제의 SIGTERM은 자동으로 &lt;a href=&quot;system#stop/0&quot;&gt; &lt;code&gt;System.stop/0&lt;/code&gt; &lt;/a&gt; 으로 변환됩니다 . &lt;a href=&quot;http://www.erlang.org/doc/man/os.html#set_signal-2&quot;&gt; &lt;code&gt;:os.set_signal/2&lt;/code&gt; &lt;/a&gt; 함수 를 통해 운영 체제 신호를보다 명시 적으로 제어 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6e330cb0e08f49bb3e2e3203bfbe1f8002483ca" translate="yes" xml:space="preserve">
          <source>By default, a very simple wrapper around OTP's &lt;code&gt;cover&lt;/code&gt; is used as a tool, but it can be overridden as follows:</source>
          <target state="translated">기본적으로 OTP &lt;code&gt;cover&lt;/code&gt; 둘러싼 매우 간단한 래퍼 가 도구로 사용되지만 다음과 같이 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a9b40c40cdba277f891d9a5de3cd80838db5f8e" translate="yes" xml:space="preserve">
          <source>By default, both options are &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">기본적으로 두 옵션은 모두 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f61d408262ba8f9487dfd034c6dee6a7168af604" translate="yes" xml:space="preserve">
          <source>By default, dependencies are fetched using the &lt;a href=&quot;https://hex.pm/&quot;&gt;Hex package manager&lt;/a&gt;:</source>
          <target state="translated">기본적으로 종속성은 &lt;a href=&quot;https://hex.pm/&quot;&gt;Hex 패키지 관리자를&lt;/a&gt; 사용하여 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="402ef1fd034af623e1289d8acec9995fa48d7ee2" translate="yes" xml:space="preserve">
          <source>By default, functions in the &lt;code&gt;IO&lt;/code&gt; module read from the standard input and write to the standard output. We can change that by passing, for example, &lt;code&gt;:stderr&lt;/code&gt; as an argument (in order to write to the standard error device):</source>
          <target state="translated">기본적으로 &lt;code&gt;IO&lt;/code&gt; 모듈의 기능 은 표준 입력에서 읽고 표준 출력에 씁니다. 예를 들어 &lt;code&gt;:stderr&lt;/code&gt; 을 인수로 전달하여 표준 오류 장치에 쓰려면이를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ed5dc3aa06cbe6867cbdf252c51bacfce3e2d13" translate="yes" xml:space="preserve">
          <source>By default, it attempts to open the file and line using the &lt;code&gt;file:line&lt;/code&gt; notation. For example, if your editor is called &lt;code&gt;subl&lt;/code&gt;, it will open the file as:</source>
          <target state="translated">기본적으로 &lt;code&gt;file:line&lt;/code&gt; 표기법을 사용하여 파일과 행을 열려고 시도합니다 . 예를 들어 편집기가 &lt;code&gt;subl&lt;/code&gt; 이면 파일을 다음과 같이 엽니 다.</target>
        </trans-unit>
        <trans-unit id="c829da1aa58fc9ca50895d425d34bf3c9320a86e" translate="yes" xml:space="preserve">
          <source>By default, it uses the default time zone database returned by &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt;&lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt;&lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt;&lt;/a&gt; which only handles &quot;Etc/UTC&quot; datetimes. Other time zone databases can be passed as argument or set globally. See the &quot;Time zone database&quot; section in the module docs.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt; &lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt; &lt;/a&gt; 에서 반환 한 기본 시간대 데이터베이스를 사용하며, 기본값 은 &quot;Etc / UTC&quot;날짜 시간 만 처리 하는 &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt; &lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt; &lt;/a&gt; 입니다. 다른 시간대 데이터베이스는 인수로 전달되거나 전체적으로 설정 될 수 있습니다. 모듈 문서의 &quot;시간대 데이터베이스&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e9dec0631c2a769f90c241506aa566e6abbea33c" translate="yes" xml:space="preserve">
          <source>By default, it uses the default time_zone returned by &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt;&lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt;&lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt;&lt;/a&gt; which only handles &quot;Etc/UTC&quot; datetimes. Other time zone databases can be passed as argument or set globally. See the &quot;Time zone database&quot; section in the module docs.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt; &lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt; &lt;/a&gt; 에서 반환 한 기본 time_zone을 사용합니다. 기본값 은 &quot;Etc / UTC&quot;날짜 시간 만 처리 하는 &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt; &lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt; &lt;/a&gt; 입니다. 다른 시간대 데이터베이스는 인수로 전달되거나 전체적으로 설정 될 수 있습니다. 모듈 문서의 &quot;시간대 데이터베이스&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9c13147ccfd35712f018a1f03ef31c9fbc8ad18d" translate="yes" xml:space="preserve">
          <source>By default, returns dates formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format by passing the &lt;code&gt;:basic&lt;/code&gt; option.</source>
          <target state="translated">기본적으로 사람이 읽을 수 있도록 &quot;확장 된&quot;형식으로 포맷 된 날짜를 반환합니다. 또한 &lt;code&gt;:basic&lt;/code&gt; 옵션 을 전달하여 &quot;기본&quot;형식을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="20a23cbb3ef91c7f640f08773138ca20ec0122ed" translate="yes" xml:space="preserve">
          <source>By default, returns datetimes formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format by passing the &lt;code&gt;:basic&lt;/code&gt; option.</source>
          <target state="translated">기본적으로 사람이 읽을 수 있도록 &quot;확장 된&quot;형식으로 형식화 된 날짜 / 시간을 반환합니다. 또한 &lt;code&gt;:basic&lt;/code&gt; 옵션 을 전달하여 &quot;기본&quot;형식을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="0d95b00ea148fc8f3ba77340beb5e5c599d4d480" translate="yes" xml:space="preserve">
          <source>By default, returns times formatted in the &quot;extended&quot; format, for human readability. It also supports the &quot;basic&quot; format by passing the &lt;code&gt;:basic&lt;/code&gt; option.</source>
          <target state="translated">기본적으로 사람이 읽을 수 있도록 &quot;확장 된&quot;형식으로 형식화 된 시간을 반환합니다. 또한 &lt;code&gt;:basic&lt;/code&gt; 옵션 을 전달하여 &quot;기본&quot;형식을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="79230ff1afddb9cbbca293f5d5dcc65fc02ebeae" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;device&lt;/code&gt; is the standard output.</source>
          <target state="translated">기본적으로 &lt;code&gt;device&lt;/code&gt; 는 표준 출력입니다.</target>
        </trans-unit>
        <trans-unit id="ee717eb9f32dadabdfe51a1c183f392e83d0ac3e" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;device&lt;/code&gt; is the standard output. It returns &lt;code&gt;:ok&lt;/code&gt; if it succeeds.</source>
          <target state="translated">기본적으로 &lt;code&gt;device&lt;/code&gt; 는 표준 출력입니다. 성공하면 &lt;code&gt;:ok&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="152a3dd3601b47a2fc040c22f7db42fbbe85286d" translate="yes" xml:space="preserve">
          <source>By default, the Erlang VM runs in interactive mode, where modules are loaded as needed. In embedded mode the opposite happens, as all modules need to be loaded upfront or explicitly.</source>
          <target state="translated">기본적으로 Erlang VM은 대화식 모드에서 실행되며 필요에 따라 모듈이로드됩니다. 내장 모드에서는 모든 모듈을 사전에 또는 명시 적으로로드해야하므로 반대가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e13fb2c0bf54cc07fce73aa25bcefd707893e86c" translate="yes" xml:space="preserve">
          <source>By default, the contents of a &lt;code&gt;.iex.exs&lt;/code&gt; file in the same directory as you are starting IEx are automatically imported. See the section for &quot;.iex.exs&quot; in the &lt;a href=&quot;iex&quot;&gt;&lt;code&gt;IEx&lt;/code&gt;&lt;/a&gt; module docs for more information.</source>
          <target state="translated">기본적으로 &lt;code&gt;.iex.exs&lt;/code&gt; 를 시작하는 디렉토리와 같은 디렉토리 에있는 .iex.exs 파일 의 내용 은 자동으로 가져옵니다. 자세한 내용은 &lt;a href=&quot;iex&quot;&gt; &lt;code&gt;IEx&lt;/code&gt; &lt;/a&gt; 모듈 문서 에서 &quot;.iex.exs&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdfad8bcd03f7fb8e453f58547c4b335ce6d4024" translate="yes" xml:space="preserve">
          <source>By default, the environment of an application is an empty list. In a Mix project you can set that key in &lt;code&gt;application/0&lt;/code&gt;:</source>
          <target state="translated">기본적으로 응용 프로그램 환경은 빈 목록입니다. 믹스 프로젝트에서는 &lt;code&gt;application/0&lt;/code&gt; 에서 해당 키를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9135e0a0bea88ce661f36edb920759a95dcfb15" translate="yes" xml:space="preserve">
          <source>By default, the function &lt;code&gt;start_link&lt;/code&gt; is invoked on the given module. Overall, the default values for the options are:</source>
          <target state="translated">기본적으로 &lt;code&gt;start_link&lt;/code&gt; 함수 는 지정된 모듈에서 호출됩니다. 전반적으로 옵션의 기본값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="98ef59d20d514a8b4d0714a0cd844e52ec39eb70" translate="yes" xml:space="preserve">
          <source>By default, the maximum number of atoms is &lt;code&gt;1_048_576&lt;/code&gt;. This limit can be raised or lowered using the VM option &lt;code&gt;+t&lt;/code&gt;.</source>
          <target state="translated">기본적으로 최대 원자 수는 &lt;code&gt;1_048_576&lt;/code&gt; 입니다. 이 한계는 VM 옵션 &lt;code&gt;+t&lt;/code&gt; 를 사용하여 늘리거나 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86266caa42c7dcf2b57a3b39797b6e7045f35720" translate="yes" xml:space="preserve">
          <source>By default, the number of stops in a breakpoint is 1. Any follow-up call won't stop the code execution unless another breakpoint is set.</source>
          <target state="translated">기본적으로 중단 점의 중지 수는 1입니다. 후속 중단 호출은 다른 중단 점이 설정되어 있지 않으면 코드 실행을 중지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20bf365c81414f9dd0f97d60214c83776220e730" translate="yes" xml:space="preserve">
          <source>By default, the patterns &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; do not match files starting with a dot &lt;code&gt;.&lt;/code&gt;. See the &lt;code&gt;:match_dot&lt;/code&gt; option in the &quot;Options&quot; section below.</source>
          <target state="translated">기본적으로 패턴 &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;?&lt;/code&gt; 점으로 시작하는 파일과 일치하지 않습니다 &lt;code&gt;.&lt;/code&gt; . 아래 &quot;옵션&quot;섹션에서 &lt;code&gt;:match_dot&lt;/code&gt; 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="62f836c1ca1f7ffa0fe44a5d83b70dadbe30aead" translate="yes" xml:space="preserve">
          <source>By default, this returns &lt;a href=&quot;mix.shell.io&quot;&gt;&lt;code&gt;Mix.Shell.IO&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본적으로 이것은 &lt;a href=&quot;mix.shell.io&quot;&gt; &lt;code&gt;Mix.Shell.IO&lt;/code&gt; 를&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4039ff511c9b0c6e465576202aa05d0f1134bbb1" translate="yes" xml:space="preserve">
          <source>By default, this task starts the current application. If this is not desired, set the &lt;code&gt;:app&lt;/code&gt; configuration to nil.</source>
          <target state="translated">기본적으로이 작업은 현재 응용 프로그램을 시작합니다. 이것이 바람직하지 않은 경우 &lt;code&gt;:app&lt;/code&gt; 구성을 nil로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="76c88cd6bc21370893bb9ca4286fa947e3185c6d" translate="yes" xml:space="preserve">
          <source>By forbidding hierarchies in favor of named setups, it is straightforward for the developer to glance at each describe block and know exactly the setup steps involved.</source>
          <target state="translated">명명 된 설정을 선호하는 계층을 금지함으로써 개발자는 각 설명 블록을 한눈에 파악하고 관련된 설정 단계를 정확하게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be8729ba3d997306cc7c2732e9d5715d7b733113" translate="yes" xml:space="preserve">
          <source>By modeling IO devices with processes, the Erlang</source>
          <target state="translated">Erlang은 프로세스를 사용하여 IO 장치를 모델링함으로써</target>
        </trans-unit>
        <trans-unit id="20fbb45a951d34847b2361b232cf1603416a2b67" translate="yes" xml:space="preserve">
          <source>By registering an attribute, a developer is able to customize how Elixir will store and accumulate the attribute values.</source>
          <target state="translated">속성을 등록함으로써 개발자는 Elixir가 속성 값을 저장하고 축적하는 방법을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a533dc2f30d084da0ee799f07f2509ceacdcbfd" translate="yes" xml:space="preserve">
          <source>By specifying such dependencies, Mix will automatically install Hex (if it wasn't previously installed) and download a package suitable to your project. Note Hex expects the dependency requirement to always be given and it will warn otherwise.</source>
          <target state="translated">이러한 종속성을 지정하면 Mix는 자동으로 16 진 (이전에 설치되지 않은 경우)을 설치하고 프로젝트에 적합한 패키지를 다운로드합니다. 참고 Hex는 종속성 요구 사항이 항상 제공 될 것으로 예상하고 그렇지 않으면 경고합니다.</target>
        </trans-unit>
        <trans-unit id="28e75c4b609dc334804d7f657136c8679b6ee20a" translate="yes" xml:space="preserve">
          <source>By starting a new IEx session, we can now define our tests and run them:</source>
          <target state="translated">새로운 IEx 세션을 시작하여 테스트를 정의하고 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ed40a81a21966a2166b56cae05accc09ed2523e" translate="yes" xml:space="preserve">
          <source>By tagging a test, the tag value can be accessed in the context, allowing the developer to customize the test. Let's see an example:</source>
          <target state="translated">테스트에 태그를 지정하면 컨텍스트에서 태그 값에 액세스하여 개발자가 테스트를 사용자 정의 할 수 있습니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="c72eb5d7c9a45f27e69792c0b3ad14f6fb4125b9" translate="yes" xml:space="preserve">
          <source>By the way, since we are now returning &lt;code&gt;{:error, :not_found}&lt;/code&gt;, we should amend the &lt;code&gt;write_line/2&lt;/code&gt; function in &lt;code&gt;KVServer&lt;/code&gt; to print such error as well:</source>
          <target state="translated">그런데 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 반환 &lt;code&gt;KVServer&lt;/code&gt; 에서 &lt;code&gt;write_line/2&lt;/code&gt; 함수를 수정하여 이러한 오류도 인쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="afd2b04041c5023417e7856e0350ac915e93bf70" translate="yes" xml:space="preserve">
          <source>By using &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Application&lt;/code&gt;&lt;/a&gt;, modules get a default implementation of &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; that ignores its argument and returns &lt;code&gt;:ok&lt;/code&gt;, but it can be overridden.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Application&lt;/code&gt; &lt;/a&gt; 을 사용 하면 모듈 은 인수를 무시하고 &lt;code&gt;:ok&lt;/code&gt; 를 반환하는 &lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt; 의 기본 구현을 얻지 만 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f1539bdede002cb03f8125233616b6cf3691dc6" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;~S&lt;/code&gt;, this problem can be avoided altogether:</source>
          <target state="translated">&lt;code&gt;~S&lt;/code&gt; 를 사용 하면이 문제를 완전히 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ace2af82bde9ed60e0b2eb329287e9e1f1b8c284" translate="yes" xml:space="preserve">
          <source>By using the &lt;code&gt;alias/2&lt;/code&gt; directive, we are changing the atom the alias expands to.</source>
          <target state="translated">&lt;code&gt;alias/2&lt;/code&gt; 지시어 를 사용하여 별칭 이 확장되는 원자를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="3f1405ee5f9cba8a93cc7f0b13abb38e7a60f2e5" translate="yes" xml:space="preserve">
          <source>By using the functions in this module one can specify the children to be used under a supervisor, started with &lt;a href=&quot;supervisor#start_link/2&quot;&gt;&lt;code&gt;Supervisor.start_link/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 모듈의 기능을 사용하여 &lt;a href=&quot;supervisor#start_link/2&quot;&gt; &lt;code&gt;Supervisor.start_link/2&lt;/code&gt; 로&lt;/a&gt; 시작하여 감독자에서 사용할 자식을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c4df2c57a78ef2bacad336bf3270c7691b6b4a9" translate="yes" xml:space="preserve">
          <source>By using this module, the callbacks and assertions available for regular test cases will also be available.</source>
          <target state="translated">이 모듈을 사용하면 일반 테스트 사례에 사용 가능한 콜백 및 어설 션도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1570089a3b884d047ed831c82108ff3c320012d" translate="yes" xml:space="preserve">
          <source>Byte order marks</source>
          <target state="translated">바이트 순서 표시</target>
        </trans-unit>
        <trans-unit id="eb1ba157957ddfdacc5b18a96c80b83156efc283" translate="yes" xml:space="preserve">
          <source>CLI exits</source>
          <target state="translated">CLI 엑시트</target>
        </trans-unit>
        <trans-unit id="e0116c5110dfc390223e2cf0357726dcea588606" translate="yes" xml:space="preserve">
          <source>CNT - total number of invocations of the given function</source>
          <target state="translated">CNT-주어진 함수의 총 호출 수</target>
        </trans-unit>
        <trans-unit id="5a1f679c89e760e380af7bd2f44ba411cf25722e" translate="yes" xml:space="preserve">
          <source>Calculates the bitwise AND of its arguments.</source>
          <target state="translated">인수의 비트 AND를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="84e4f0eeebc650c4d2644607d336f04cbb23d438" translate="yes" xml:space="preserve">
          <source>Calculates the bitwise NOT of its argument.</source>
          <target state="translated">인수의 비트 NOT을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="82c78143ba33e97d749e3529f91d872adcb213b4" translate="yes" xml:space="preserve">
          <source>Calculates the bitwise OR of its arguments.</source>
          <target state="translated">인수의 비트 단위 OR을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="66848a208113faeb7ce19122ab8c270554db335f" translate="yes" xml:space="preserve">
          <source>Calculates the bitwise XOR of its arguments.</source>
          <target state="translated">인수의 비트 XOR을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="872e2eaef65c0a774ab638167d32944d779fe0db" translate="yes" xml:space="preserve">
          <source>Calculates the day and era from the given &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, and &lt;code&gt;day&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; 및 &lt;code&gt;day&lt;/code&gt; 로부터 날짜와 시간을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="59531be2cfe81760a8bcb2ad77fdb94258d79267" translate="yes" xml:space="preserve">
          <source>Calculates the day of the week from the given &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, and &lt;code&gt;day&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; 및 &lt;code&gt;day&lt;/code&gt; 에서 요일을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="977d26fb6d2c6237ad910b694ef77ece58a18321" translate="yes" xml:space="preserve">
          <source>Calculates the day of the week of a given &lt;code&gt;date&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;date&lt;/code&gt; 의 요일을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="48ab91160e20cbcc7db86d12c7c5d29ffe417d69" translate="yes" xml:space="preserve">
          <source>Calculates the day of the year from the given &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, and &lt;code&gt;day&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; 및 &lt;code&gt;day&lt;/code&gt; 에서 연중 일을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="69bb790c7a94873e3a63a87bed9ab85d41e51ad2" translate="yes" xml:space="preserve">
          <source>Calculates the day of the year of a given &lt;code&gt;date&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;date&lt;/code&gt; 의 연도 일을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="51f486811d7efdb5f59099bf0821d88cdd0fcdb3" translate="yes" xml:space="preserve">
          <source>Calculates the day-of-era and era for a given calendar &lt;code&gt;date&lt;/code&gt;.</source>
          <target state="translated">주어진 달력 &lt;code&gt;date&lt;/code&gt; 와 시간을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="31ffe77841021e9cd0d8d28a2ff0eb90596f7c2f" translate="yes" xml:space="preserve">
          <source>Calculates the difference between two dates, in a full number of days.</source>
          <target state="translated">전체 날짜 수로 두 날짜의 차이를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1e22629218c7c2524d719a6aafb26320a9e33d6f" translate="yes" xml:space="preserve">
          <source>Calculates the quarter of the year from the given &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;month&lt;/code&gt;, and &lt;code&gt;day&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;month&lt;/code&gt; 및 &lt;code&gt;day&lt;/code&gt; 에서 연중 분기를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="ced99eb284fbbc4addff1f8982435da702405206" translate="yes" xml:space="preserve">
          <source>Calculates the quarter of the year of a given &lt;code&gt;date&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;date&lt;/code&gt; 의 연도의 분기를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="38a63816978a3500d8832c7b1f94a4f1bae97c63" translate="yes" xml:space="preserve">
          <source>Calculates the result of an arithmetic left bitshift.</source>
          <target state="translated">산술 왼쪽 비트 시프트의 결과를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4efe33d70304152372f10ae59d4a94377d6ac6d6" translate="yes" xml:space="preserve">
          <source>Calculates the result of an arithmetic right bitshift.</source>
          <target state="translated">산술 오른쪽 비트 시프트의 결과를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="df000a9c3e0cbb692af58f43cb56584844928596" translate="yes" xml:space="preserve">
          <source>Calculates the year and era from the given &lt;code&gt;year&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;year&lt;/code&gt; 부터 연도와 연도를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="c5b862a12e39e020b060e66f5c4acab9c33e37a6" translate="yes" xml:space="preserve">
          <source>Calculates the year-of-era and era for a given calendar year.</source>
          <target state="translated">주어진 연도의 연도 및 연도를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="adab5090ac6a1b7b5420faac7be86c41721ba27c" translate="yes" xml:space="preserve">
          <source>Calendar</source>
          <target state="translated">Calendar</target>
        </trans-unit>
        <trans-unit id="d2846e6231c1d94a724f86fb32fe4ede252c7e62" translate="yes" xml:space="preserve">
          <source>Calendar &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">캘린더 &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="ef9e9ae658ec14ea6882de0157e1d6807db80ee5" translate="yes" xml:space="preserve">
          <source>Calendar.ISO</source>
          <target state="translated">Calendar.ISO</target>
        </trans-unit>
        <trans-unit id="f5c6e67829066a800fc5a7db8149d3747aa50714" translate="yes" xml:space="preserve">
          <source>Calendar.TimeZoneDatabase</source>
          <target state="translated">Calendar.TimeZoneDatabase</target>
        </trans-unit>
        <trans-unit id="97fb668d95f303af428dbebc65b8e7dcb0c6a7d1" translate="yes" xml:space="preserve">
          <source>Calendar.TimeZoneDatabase &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">Calendar.TimeZone 데이터베이스 &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d8efcf40cde9eb544b2f246797c94807656d1da5" translate="yes" xml:space="preserve">
          <source>Calendar.UTCOnlyTimeZoneDatabase</source>
          <target state="translated">Calendar.UTCOnlyTimeZoneDatabase</target>
        </trans-unit>
        <trans-unit id="c7ed9654ce3205b4d11f855df757291b19bd05d6" translate="yes" xml:space="preserve">
          <source>Call &lt;a href=&quot;enum#to_list/1&quot;&gt;&lt;code&gt;Enum.to_list/1&lt;/code&gt;&lt;/a&gt; on the second argument before hand (v1.0)</source>
          <target state="translated">직접 두 번째 인수 (v1.0)에서 &lt;a href=&quot;enum#to_list/1&quot;&gt; &lt;code&gt;Enum.to_list/1&lt;/code&gt; &lt;/a&gt; 을 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="0ec5483fd7a38077d057ae7802d3cb47d7ef8aa0" translate="yes" xml:space="preserve">
          <source>Callback implementation for &lt;a href=&quot;eex.engine#c:handle_begin/1&quot;&gt;&lt;code&gt;EEx.Engine.handle_begin/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;eex.engine#c:handle_begin/1&quot;&gt; &lt;code&gt;EEx.Engine.handle_begin/1&lt;/code&gt; 에&lt;/a&gt; 대한 콜백 구현 .</target>
        </trans-unit>
        <trans-unit id="c10d1f66343bff0367facdfabc09309b1db76d10" translate="yes" xml:space="preserve">
          <source>Callback implementation for &lt;a href=&quot;eex.engine#c:handle_body/1&quot;&gt;&lt;code&gt;EEx.Engine.handle_body/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에 대한 콜백 구현 &lt;a href=&quot;eex.engine#c:handle_body/1&quot;&gt; &lt;code&gt;EEx.Engine.handle_body/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="809f4f9c22dd6ee3ec66bf463f931344c3f340dd" translate="yes" xml:space="preserve">
          <source>Callback implementation for &lt;a href=&quot;eex.engine#c:handle_end/1&quot;&gt;&lt;code&gt;EEx.Engine.handle_end/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에 대한 콜백 구현 &lt;a href=&quot;eex.engine#c:handle_end/1&quot;&gt; &lt;code&gt;EEx.Engine.handle_end/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b8c930f53b6ae5c6504b04c2e084c2c472b9f22" translate="yes" xml:space="preserve">
          <source>Callback implementation for &lt;a href=&quot;eex.engine#c:handle_expr/3&quot;&gt;&lt;code&gt;EEx.Engine.handle_expr/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;eex.engine#c:handle_expr/3&quot;&gt; &lt;code&gt;EEx.Engine.handle_expr/3&lt;/code&gt; 에&lt;/a&gt; 대한 콜백 구현 .</target>
        </trans-unit>
        <trans-unit id="d538426bfe18e63fe5c0d95dab134b723574484b" translate="yes" xml:space="preserve">
          <source>Callback implementation for &lt;a href=&quot;eex.engine#c:handle_text/2&quot;&gt;&lt;code&gt;EEx.Engine.handle_text/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에 대한 콜백 구현 &lt;a href=&quot;eex.engine#c:handle_text/2&quot;&gt; &lt;code&gt;EEx.Engine.handle_text/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f0b1ed3855a5c3236f255f01ab409ddde0f8818" translate="yes" xml:space="preserve">
          <source>Callback implementation for &lt;a href=&quot;eex.engine#c:init/1&quot;&gt;&lt;code&gt;EEx.Engine.init/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에 대한 콜백 구현 &lt;a href=&quot;eex.engine#c:init/1&quot;&gt; &lt;code&gt;EEx.Engine.init/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd7ab7f77ceb6a2945635de1386a402a7ef6ee53" translate="yes" xml:space="preserve">
          <source>Callback invoked after code upgrade, if the application environment has changed.</source>
          <target state="translated">애플리케이션 환경이 변경된 경우 코드 업그레이드 후 콜백이 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="9fbe07680545fab8c38f764f99ebaad2d192e475" translate="yes" xml:space="preserve">
          <source>Callback invoked to start the supervisor and during hot code upgrades.</source>
          <target state="translated">수퍼바이저를 시작하고 핫 코드 업그레이드 중에 콜백이 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="f6c42f7bb51b73d4b211ee83945d9879bce48368" translate="yes" xml:space="preserve">
          <source>Callbacks registered first will run last.</source>
          <target state="translated">처음 등록 된 콜백은 마지막에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="66201e1b84a1d1a6ff96f16fa8793345ed84e782" translate="yes" xml:space="preserve">
          <source>Callbacks registered first will run last. Any overridable definition will be made concrete before the first callback runs. A definition may be made overridable again in another before compile callback and it will be made concrete one last time after after all callbacks run.</source>
          <target state="translated">처음 등록 된 콜백은 마지막에 실행됩니다. 재정의 가능한 모든 정의는 첫 번째 콜백이 실행되기 전에 구체적으로 이루어집니다. 컴파일 콜백 전에 다른 콜백에서 정의를 다시 재정의 할 수 있으며 모든 콜백이 실행 된 후 마지막으로 한 번 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="d85b3a76866da7a60448467248c2cfd125983166" translate="yes" xml:space="preserve">
          <source>Callbacks set with &lt;a href=&quot;#after_suite/1&quot;&gt;&lt;code&gt;after_suite/1&lt;/code&gt;&lt;/a&gt; must accept a single argument, which is a map containing the results of the test suite's execution.</source>
          <target state="translated">&lt;a href=&quot;#after_suite/1&quot;&gt; &lt;code&gt;after_suite/1&lt;/code&gt; 로&lt;/a&gt; 설정된 콜백 은 테스트 스위트의 실행 결과를 포함하는 맵인 단일 인수를 허용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0faabceba35fd7a48636a9f242b76d779503989b" translate="yes" xml:space="preserve">
          <source>Called after an application has been stopped.</source>
          <target state="translated">응용 프로그램이 중지 된 후 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="63380a742a1ed6d808719b27ab046bd5083024b3" translate="yes" xml:space="preserve">
          <source>Called at the beginning of every template.</source>
          <target state="translated">모든 템플릿의 시작 부분에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c3e6c4eb21e116160c46b9548a425a642cdad1e5" translate="yes" xml:space="preserve">
          <source>Called at the end of every template.</source>
          <target state="translated">모든 템플릿의 끝에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="442535ed506cf7f3e8f4628a3a6c0adb928772c4" translate="yes" xml:space="preserve">
          <source>Called before stopping the application.</source>
          <target state="translated">응용 프로그램을 중지하기 전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e32234ad249148d3b937bfee926f036a291cfa48" translate="yes" xml:space="preserve">
          <source>Called for the dynamic/code parts of a template.</source>
          <target state="translated">템플릿의 동적 / 코드 부분을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="03a90d4fa846b3199574f48f2a69056a02070095" translate="yes" xml:space="preserve">
          <source>Called for the text/static parts of a template.</source>
          <target state="translated">템플릿의 텍스트 / 정적 부분을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="efdaf943b92658db4a3efff473253de2372bcf86" translate="yes" xml:space="preserve">
          <source>Called from &lt;a href=&quot;exception#blame/3&quot;&gt;&lt;code&gt;Exception.blame/3&lt;/code&gt;&lt;/a&gt; to augment the exception struct.</source>
          <target state="translated">예외 구조체를 보강하기 위해 &lt;a href=&quot;exception#blame/3&quot;&gt; &lt;code&gt;Exception.blame/3&lt;/code&gt; &lt;/a&gt; 에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0ca56a7a06bc47a8cf3a0a7612d281facc7aec4" translate="yes" xml:space="preserve">
          <source>Called when an application is started.</source>
          <target state="translated">응용 프로그램이 시작될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b8f234a1e4d68947a81625776c2d1d09281b09d9" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;kernel.specialforms#super/1&quot;&gt;&lt;code&gt;super/1&lt;/code&gt;&lt;/a&gt; on GenServer callbacks</source>
          <target state="translated">호출 &lt;a href=&quot;kernel.specialforms#super/1&quot;&gt; &lt;code&gt;super/1&lt;/code&gt; &lt;/a&gt; GenServer 콜백에</target>
        </trans-unit>
        <trans-unit id="351d7d149e48159d87db220bf823be28fe3f8023" translate="yes" xml:space="preserve">
          <source>Calling anonymous functions uses the dot in the AST with a single argument, mirroring the fact the function name is &quot;missing&quot; from right side of the dot:</source>
          <target state="translated">익명 함수를 호출하면 AST에서 점을 단일 인수와 함께 사용하여 함수 이름이 점의 오른쪽에서 &quot;누락&quot;한다는 사실을 반영합니다.</target>
        </trans-unit>
        <trans-unit id="483676a4323ff474475176f21ccdb14d6acd93be" translate="yes" xml:space="preserve">
          <source>Calling this new &lt;code&gt;return_length/0&lt;/code&gt; will still return &lt;code&gt;3&lt;/code&gt; as result.</source>
          <target state="translated">이 새로운 &lt;code&gt;return_length/0&lt;/code&gt; 을 호출하면 결과적으로 &lt;code&gt;3&lt;/code&gt; 이 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="2f70240a7a73a837a65004029341593ba5615c20" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt; with the given arguments, but only if the module is available.</source>
          <target state="translated">주어진 인수로 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt; 를 호출 하지만 모듈을 사용할 수있는 경우에만 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="32b79b53c10b7818f97870494be94fb3c414206b" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#use/2&quot;&gt;&lt;code&gt;use/2&lt;/code&gt;&lt;/a&gt; with the given arguments, but only if the module is available.</source>
          <target state="translated">주어진 인수와 함께 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#use/2&quot;&gt; &lt;code&gt;use/2&lt;/code&gt; &lt;/a&gt; 를 호출 하지만 모듈을 사용할 수있는 경우에만 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="aa43ce86529e7a9b7d32993a0bcab9a4c00c893f" translate="yes" xml:space="preserve">
          <source>Calls all servers locally registered as &lt;code&gt;name&lt;/code&gt; at the specified &lt;code&gt;nodes&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;nodes&lt;/code&gt; 에서 로컬로 &lt;code&gt;name&lt;/code&gt; 으로 등록 된 모든 서버를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="973a2b37cbb904055d8b2cb9085515443a94fcfb" translate="yes" xml:space="preserve">
          <source>Calls inside &lt;a href=&quot;#try/1&quot;&gt;&lt;code&gt;try/1&lt;/code&gt;&lt;/a&gt; are not tail recursive since the VM needs to keep the stacktrace in case an exception happens. To retrieve the stacktrace, access &lt;a href=&quot;#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; inside the &lt;code&gt;rescue&lt;/code&gt; or &lt;code&gt;catch&lt;/code&gt; clause.</source>
          <target state="translated">&lt;a href=&quot;#try/1&quot;&gt; &lt;code&gt;try/1&lt;/code&gt; &lt;/a&gt; 내부의 호출 은 예외가 발생할 경우 VM이 스택 추적을 유지해야하기 때문에 테일 재귀가 아닙니다. 스택 &lt;a href=&quot;#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt; 을 검색하려면 &lt;code&gt;rescue&lt;/code&gt; 또는 &lt;code&gt;catch&lt;/code&gt; 절 에서 __STACKTRACE __ / 0에 액세스 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e45c3b1dc9f022a7ca2feaa09407ac0c9c46f51" translate="yes" xml:space="preserve">
          <source>Calls the &lt;code&gt;exception/1&lt;/code&gt; function on the given argument (which has to be a module name like &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;runtimeerror&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt;) passing &lt;code&gt;attrs&lt;/code&gt; as the attributes in order to retrieve the exception struct.</source>
          <target state="translated">&lt;code&gt;exception/1&lt;/code&gt; &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 를 검색하기 위해 속성으로 &lt;code&gt;attrs&lt;/code&gt; 를 전달 하는 주어진 인수 ( ArgumentError 또는 &lt;a href=&quot;runtimeerror&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 와 같은 모듈 이름이어야 함) 에서 exception / 1 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="cf2cbc473a24499b6038ffab5fe859228e498845" translate="yes" xml:space="preserve">
          <source>Calls the overridden function when overriding it with &lt;a href=&quot;kernel#defoverridable/1&quot;&gt;&lt;code&gt;Kernel.defoverridable/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;kernel#defoverridable/1&quot;&gt; &lt;code&gt;Kernel.defoverridable/1&lt;/code&gt; 로&lt;/a&gt; 재정의 할 때 재정의 된 기능을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4da0eb7496c45b4f2e06c9a592ed791d6921bdac" translate="yes" xml:space="preserve">
          <source>Calls the provided &lt;code&gt;empty_fallback&lt;/code&gt; function and returns its value if &lt;code&gt;enumerable&lt;/code&gt; is empty. The default &lt;code&gt;empty_fallback&lt;/code&gt; raises &lt;a href=&quot;enum.emptyerror&quot;&gt;&lt;code&gt;Enum.EmptyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제공된 &lt;code&gt;empty_fallback&lt;/code&gt; 함수를 호출하고 &lt;code&gt;enumerable&lt;/code&gt; 이 비어 있으면 해당 값을 리턴합니다 . 기본 &lt;code&gt;empty_fallback&lt;/code&gt; 은 &lt;a href=&quot;enum.emptyerror&quot;&gt; &lt;code&gt;Enum.EmptyError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8341f9c0dc9a43feb95e575c7d1ff19857e6cc50" translate="yes" xml:space="preserve">
          <source>Can be used to collect additional information about the exception or do some additional expensive computation.</source>
          <target state="translated">예외에 대한 추가 정보를 수집하거나 고가의 추가 계산을 수행하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e334a2ce3108e0febeb57230bd2cb23a051d7fbe" translate="yes" xml:space="preserve">
          <source>Can return values to be merged into the &lt;code&gt;context&lt;/code&gt;, to set up the state for tests. For more details, see the &quot;Context&quot; section shown above.</source>
          <target state="translated">테스트 상태를 설정하기 위해 &lt;code&gt;context&lt;/code&gt; 에 병합 될 값을 반환 할 수 있습니다 . 자세한 내용은 위에 표시된 &quot;컨텍스트&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0242ecee6ab6bf770b987438f3bfcd7060632331" translate="yes" xml:space="preserve">
          <source>Can return values to be merged into the context, to set up the state for tests. For more details, see the &quot;Context&quot; section shown above.</source>
          <target state="translated">테스트 상태를 설정하기 위해 컨텍스트에 병합 할 값을 리턴 할 수 있습니다. 자세한 내용은 위에 표시된 &quot;컨텍스트&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8716b1b959af99def374d9b25e8ba6c67f8e0642" translate="yes" xml:space="preserve">
          <source>Cancels a timer returned by &lt;a href=&quot;#send_after/3&quot;&gt;&lt;code&gt;send_after/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#send_after/3&quot;&gt; &lt;code&gt;send_after/3&lt;/code&gt; 에서&lt;/a&gt; 반환 한 타이머를 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="772a4bcb6564702a3954bd84a80b8688f24e0663" translate="yes" xml:space="preserve">
          <source>Capture</source>
          <target state="translated">Capture</target>
        </trans-unit>
        <trans-unit id="7c8134e39c2398e58f343200b0596b236c139932" translate="yes" xml:space="preserve">
          <source>Captures</source>
          <target state="translated">Captures</target>
        </trans-unit>
        <trans-unit id="ee795a7fa93d1d3588ea4bf78c087bb3df764e96" translate="yes" xml:space="preserve">
          <source>Captures or creates an anonymous function.</source>
          <target state="translated">익명 함수를 캡처하거나 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a1bd477e88eb362e3b6ca6a4a29b2702d3015ff6" translate="yes" xml:space="preserve">
          <source>Captures the given function.</source>
          <target state="translated">주어진 기능을 캡처합니다.</target>
        </trans-unit>
        <trans-unit id="aa83b0db7571a9b488496ed9d08b379219be7ce6" translate="yes" xml:space="preserve">
          <source>Carefully stops the Erlang runtime system.</source>
          <target state="translated">Erlang 런타임 시스템을 조심스럽게 중지시킵니다.</target>
        </trans-unit>
        <trans-unit id="3de7c7c7fd9020f41906a55076bb7100b700d996" translate="yes" xml:space="preserve">
          <source>Case, Callbacks and Assertions</source>
          <target state="translated">사례, 콜백 및 어설 션</target>
        </trans-unit>
        <trans-unit id="50ae5b37c236ae7f885890b3cfa7f117f01aadb1" translate="yes" xml:space="preserve">
          <source>CaseClauseError</source>
          <target state="translated">CaseClauseError</target>
        </trans-unit>
        <trans-unit id="fdf5275c868ecbada652e512ffc1fdefc861f736" translate="yes" xml:space="preserve">
          <source>CaseClauseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">CaseClauseError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f3d4dffe4c9ebac969ee4f02157e5740619b3299" translate="yes" xml:space="preserve">
          <source>Casing</source>
          <target state="translated">Casing</target>
        </trans-unit>
        <trans-unit id="7ed67e7a3ac2c5f0b4ebfcbd5516cf4cb07f36ce" translate="yes" xml:space="preserve">
          <source>Casts all servers locally registered as &lt;code&gt;name&lt;/code&gt; at the specified nodes.</source>
          <target state="translated">지정된 노드에서 로컬로 &lt;code&gt;name&lt;/code&gt; 으로 등록 된 모든 서버를 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="a338872f01e247b728456edb7f0b896e06d6f40c" translate="yes" xml:space="preserve">
          <source>Catching thrown values</source>
          <target state="translated">던진 값 잡기</target>
        </trans-unit>
        <trans-unit id="b1d7430e3b7ebe0c9345e291ab7d148a7c0b4616" translate="yes" xml:space="preserve">
          <source>Catching values of any kind</source>
          <target state="translated">모든 종류의 가치를 포착</target>
        </trans-unit>
        <trans-unit id="bcaa33a7ae44bd5042c37a9cdbea7f843b1cf7c8" translate="yes" xml:space="preserve">
          <source>Caveats</source>
          <target state="translated">Caveats</target>
        </trans-unit>
        <trans-unit id="fb1ca31f7b105b5db3d68fcceddbb09d728d0d20" translate="yes" xml:space="preserve">
          <source>Change the assertion in &lt;code&gt;test/kv_test.exs&lt;/code&gt; to the following:</source>
          <target state="translated">&lt;code&gt;test/kv_test.exs&lt;/code&gt; 의 어설 션을 다음과 같이 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a4854b634f3d16dfe0416ab69448c4d70e815bc" translate="yes" xml:space="preserve">
          <source>Changes the &lt;code&gt;mode&lt;/code&gt; for a given &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;file&lt;/code&gt; 의 &lt;code&gt;mode&lt;/code&gt; 를 변경 합니다 .</target>
        </trans-unit>
        <trans-unit id="1e48df922da0b08e16af81da8ffa6075f757955f" translate="yes" xml:space="preserve">
          <source>Changes the current Mix environment to &lt;code&gt;env&lt;/code&gt;.</source>
          <target state="translated">현재 믹스 환경을 &lt;code&gt;env&lt;/code&gt; 로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="441d60b43c53fc069fbc6a19e176cade2240e17d" translate="yes" xml:space="preserve">
          <source>Changes the current Mix target to &lt;code&gt;target&lt;/code&gt;.</source>
          <target state="translated">현재 믹스 타겟을 &lt;code&gt;target&lt;/code&gt; 으로 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="5d07d3f0b91ed23185354c26ccbebfdb380e8f21" translate="yes" xml:space="preserve">
          <source>Changes the current directory to the given &lt;code&gt;path&lt;/code&gt;, executes the given function and then reverts back to the previous path regardless of whether there is an exception.</source>
          <target state="translated">현재 디렉토리를 지정된 &lt;code&gt;path&lt;/code&gt; 로 변경하고 지정된 기능을 실행 한 다음 예외가 있는지 여부에 관계없이 이전 경로로 되돌립니다.</target>
        </trans-unit>
        <trans-unit id="81244f5feba2a2ae578c67d52abe75adcd2c03c4" translate="yes" xml:space="preserve">
          <source>Changes the current working directory to the given path.</source>
          <target state="translated">현재 작업 디렉토리를 지정된 경로로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="dca7438f013e9357695dd4f7bbf67adfc6043e3a" translate="yes" xml:space="preserve">
          <source>Changes the filename used in stacktraces for the function or macro that follows the attribute, such as:</source>
          <target state="translated">다음과 같이 속성 뒤에 오는 함수 또는 매크로의 스택 추적에 사용되는 파일 이름을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="d49019da62eaa7b23d02a05fcc1a34795c0447dd" translate="yes" xml:space="preserve">
          <source>Changes the group given by the group ID &lt;code&gt;gid&lt;/code&gt; for a given &lt;code&gt;file&lt;/code&gt;. Returns &lt;code&gt;:ok&lt;/code&gt; on success, or &lt;code&gt;{:error, reason}&lt;/code&gt; on failure.</source>
          <target state="translated">주어진 &lt;code&gt;file&lt;/code&gt; 대해 그룹 ID &lt;code&gt;gid&lt;/code&gt; 에 의해 주어진 그룹을 변경 합니다 . 성공시 &lt;code&gt;:ok&lt;/code&gt; 또는 실패시 &lt;code&gt;{:error, reason}&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="f8403cc6f3117f7214b1f5348fc78e244e7765be" translate="yes" xml:space="preserve">
          <source>Changes the list of command line arguments. Use it with caution, as it destroys any previous argv information.</source>
          <target state="translated">명령 행 인수 목록을 변경합니다. 이전 argv 정보가 손상되므로주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f78fe574885e1218644c8eb3ec719b0f72557786" translate="yes" xml:space="preserve">
          <source>Changes the owner given by the user ID &lt;code&gt;uid&lt;/code&gt; for a given &lt;code&gt;file&lt;/code&gt;. Returns &lt;code&gt;:ok&lt;/code&gt; on success, or &lt;code&gt;{:error, reason}&lt;/code&gt; on failure.</source>
          <target state="translated">주어진 &lt;code&gt;file&lt;/code&gt; 대해 사용자 ID &lt;code&gt;uid&lt;/code&gt; 가 제공 한 소유자를 변경 합니다 . 성공시 &lt;code&gt;:ok&lt;/code&gt; 또는 실패시 &lt;code&gt;{:error, reason}&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="4a5a85be01bff52b55691c3e0e53685cf643afeb" translate="yes" xml:space="preserve">
          <source>Changes the time zone of a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 의&lt;/a&gt; 시간대를 변경합니다 .</target>
        </trans-unit>
        <trans-unit id="284d1f54427e012e84088102ed1bc9f15dfbd47a" translate="yes" xml:space="preserve">
          <source>Char lists</source>
          <target state="translated">숯 목록</target>
        </trans-unit>
        <trans-unit id="bf238be65bb5e7ebb05fdca2c63f71cc0a076a1a" translate="yes" xml:space="preserve">
          <source>Character classes</source>
          <target state="translated">캐릭터 클래스</target>
        </trans-unit>
        <trans-unit id="c51df18f8947669b0b6631dd0793cff088cde7c4" translate="yes" xml:space="preserve">
          <source>Chardata</source>
          <target state="translated">Chardata</target>
        </trans-unit>
        <trans-unit id="6995b6a69e7114b0d9f12f1dd5c41634206726e5" translate="yes" xml:space="preserve">
          <source>Charlists</source>
          <target state="translated">Charlists</target>
        </trans-unit>
        <trans-unit id="6c06cb03cc85ac5b58f555f3b3b633f044c1c86a" translate="yes" xml:space="preserve">
          <source>Charlists are always represented as themselves in the AST.</source>
          <target state="translated">Charlist는 항상 AST에서 자체로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="29fe510ad38d3c89583dde7f48d5a6ec1fc330d4" translate="yes" xml:space="preserve">
          <source>Charlists in Elixir are written in single-quotes, such as &lt;code&gt;'foo'&lt;/code&gt;. Any single-quote inside the string must be escaped with &lt;code&gt;\&lt;/code&gt;. Charlists are made of non-negative integers, where each integer represents a Unicode code point.</source>
          <target state="translated">Elixir의 Charlist는 &lt;code&gt;'foo'&lt;/code&gt; 와 같은 작은 따옴표로 작성됩니다 . 문자열 안의 작은 따옴표는 &lt;code&gt;\&lt;/code&gt; 로 이스케이프해야합니다 . list리스트는 음이 아닌 정수로 구성되며 각 정수는 유니 코드 코드 포인트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="692ca546041e0defb9df176c51dca7a9351edd04" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;#compiler_options/1&quot;&gt;&lt;code&gt;compiler_options/1&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">확인 &lt;a href=&quot;#compiler_options/1&quot;&gt; &lt;code&gt;compiler_options/1&lt;/code&gt; &lt;/a&gt; 더 많은 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="580e68b2106988dd01d5c2d7c8cd6275df6bffa6" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;#def/2&quot;&gt;&lt;code&gt;def/2&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">확인 &lt;a href=&quot;#def/2&quot;&gt; &lt;code&gt;def/2&lt;/code&gt; &lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="95077ccb031fbcb95d39307f645abe3b02d020d7" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;#def/2&quot;&gt;&lt;code&gt;def/2&lt;/code&gt;&lt;/a&gt; for rules on naming and default arguments.</source>
          <target state="translated">이름 지정 및 기본 인수에 대한 규칙은 &lt;a href=&quot;#def/2&quot;&gt; &lt;code&gt;def/2&lt;/code&gt; &lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="16471b3c05acbe867b23d78e9ce516c95eaa45af" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;#defmacro/2&quot;&gt;&lt;code&gt;defmacro/2&lt;/code&gt;&lt;/a&gt; for more information, and check &lt;a href=&quot;#def/2&quot;&gt;&lt;code&gt;def/2&lt;/code&gt;&lt;/a&gt; for rules on naming and default arguments.</source>
          <target state="translated">확인 &lt;a href=&quot;#defmacro/2&quot;&gt; &lt;code&gt;defmacro/2&lt;/code&gt; &lt;/a&gt; 자세한 내용 및 확인 &lt;a href=&quot;#def/2&quot;&gt; &lt;code&gt;def/2&lt;/code&gt; &lt;/a&gt; 이름 지정 및 기본 인수에 규칙을.</target>
        </trans-unit>
        <trans-unit id="d696caf065aad7dda368b9ed69150792a031438c" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;#ensure_loaded/1&quot;&gt;&lt;code&gt;ensure_loaded/1&lt;/code&gt;&lt;/a&gt; for more information on module loading and when to use &lt;a href=&quot;#ensure_loaded/1&quot;&gt;&lt;code&gt;ensure_loaded/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모듈로드 및 &lt;a href=&quot;#ensure_loaded/1&quot;&gt; &lt;code&gt;ensure_loaded/1&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; &lt;/a&gt; 사용시기에 대한 자세한 정보는 &lt;a href=&quot;#ensure_loaded/1&quot;&gt; &lt;code&gt;ensure_loaded/1&lt;/code&gt; &lt;/a&gt; 을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="223535a829f654f4ba1b94d2f73c385014b275bc" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;#string_to_quoted/2&quot;&gt;&lt;code&gt;string_to_quoted/2&lt;/code&gt;&lt;/a&gt; for options information.</source>
          <target state="translated">옵션 정보는 &lt;a href=&quot;#string_to_quoted/2&quot;&gt; &lt;code&gt;string_to_quoted/2&lt;/code&gt; &lt;/a&gt; 를 확인 하십시오.</target>
        </trans-unit>
        <trans-unit id="7c8d72337056863704c80e076ca875b05f4c79da" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;#unescape_string/1&quot;&gt;&lt;code&gt;unescape_string/1&lt;/code&gt;&lt;/a&gt; if you want to use the same map as Elixir single- and double-quoted strings.</source>
          <target state="translated">Elixir 작은 따옴표와 큰 따옴표로 묶은 문자열과 동일한 맵을 사용하려면 &lt;a href=&quot;#unescape_string/1&quot;&gt; &lt;code&gt;unescape_string/1&lt;/code&gt; 을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee05709b378da3558eb634305561ffc48a326464" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;#yield/2&quot;&gt;&lt;code&gt;yield/2&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">확인 &lt;a href=&quot;#yield/2&quot;&gt; &lt;code&gt;yield/2&lt;/code&gt; &lt;/a&gt; 더 많은 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="785712997747226e23cf4b84e679095c307ba597" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;file#open/2&quot;&gt;&lt;code&gt;File.open/2&lt;/code&gt;&lt;/a&gt; for other available options.</source>
          <target state="translated">사용 가능한 다른 옵션은 &lt;a href=&quot;file#open/2&quot;&gt; &lt;code&gt;File.open/2&lt;/code&gt; &lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8d550f87c99e2d04e0824dc4af6695df840266f" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#open-2&quot;&gt;&lt;code&gt;:file.open/2&lt;/code&gt;&lt;/a&gt; for more information about such options and other performance considerations.</source>
          <target state="translated">이러한 옵션 및 기타 성능 고려 사항에 대한 자세한 정보는 &lt;a href=&quot;http://www.erlang.org/doc/man/file.html#open-2&quot;&gt; &lt;code&gt;:file.open/2&lt;/code&gt; &lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f5fa039b607cd582c6a4c955e7af1e177a34d30" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;kernel.specialforms#quote/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">확인 &lt;a href=&quot;kernel.specialforms#quote/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt; &lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="9879b9cff677770f7fc6dce2a1ef0f51a801fd9d" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;kernel.specialforms#try/1&quot;&gt;&lt;code&gt;Kernel.SpecialForms.try/1&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">확인 &lt;a href=&quot;kernel.specialforms#try/1&quot;&gt; &lt;code&gt;Kernel.SpecialForms.try/1&lt;/code&gt; &lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="f8681dafec33d53ad1aff221f5baee38d09e6e9c" translate="yes" xml:space="preserve">
          <source>Check &lt;a href=&quot;list#myers_difference/2&quot;&gt;&lt;code&gt;List.myers_difference/2&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">확인 &lt;a href=&quot;list#myers_difference/2&quot;&gt; &lt;code&gt;List.myers_difference/2&lt;/code&gt; &lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="e75e0fdd1c293bab75b6473bd2c4557b0ba22f15" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.html&quot;&gt;&lt;code&gt;Regex&lt;/code&gt; module&lt;/a&gt; for more information on other modifiers and the supported operations with regular expressions.</source>
          <target state="translated">다른 수식 자 및 정규식으로 지원되는 작업에 대한 자세한 내용 은 &lt;a href=&quot;https://hexdocs.pm/elixir/Regex.html&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; 모듈&lt;/a&gt; 을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="cbebd3b6561ff651e663b17bfb1588d294d1f922" translate="yes" xml:space="preserve">
          <source>Check the &lt;a href=&quot;process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; module for more process-related functions.</source>
          <target state="translated">더 많은 프로세스 관련 기능에 대해서는 &lt;a href=&quot;process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 모듈을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3840e7aee47b59321bae16ce0d7c094d2966b67" translate="yes" xml:space="preserve">
          <source>Check the &lt;a href=&quot;process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; module for more process-related functions. For more information on linking, check &lt;a href=&quot;process#link/1&quot;&gt;&lt;code&gt;Process.link/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 많은 프로세스 관련 기능에 대해서는 &lt;a href=&quot;process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 모듈을 확인하십시오 . 연결에 대한 자세한 내용은 &lt;a href=&quot;process#link/1&quot;&gt; &lt;code&gt;Process.link/1&lt;/code&gt; 을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="240896e1c6f52924fd3b42c51075a7aa10e367b9" translate="yes" xml:space="preserve">
          <source>Check the implementation for &lt;a href=&quot;https://hexdocs.pm/logger/Logger.Backends.Console.html&quot;&gt;&lt;code&gt;Logger.Backends.Console&lt;/code&gt;&lt;/a&gt;, for examples on how to handle the recommendations in this section and how to process the existing options.</source>
          <target state="translated">이 섹션의 권장 사항을 처리하는 방법 및 기존 옵션을 처리하는 방법에 대한 예제 는 &lt;a href=&quot;https://hexdocs.pm/logger/Logger.Backends.Console.html&quot;&gt; &lt;code&gt;Logger.Backends.Console&lt;/code&gt; &lt;/a&gt; 구현을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="000a7110c0505a98fde3ef2e1bc528f24d4ff55d" translate="yes" xml:space="preserve">
          <source>Check the module doc for documentation on the valid parameters that will be interpolated in the pattern. If you pass &lt;code&gt;nil&lt;/code&gt; as the pattern, the pattern defaults to:</source>
          <target state="translated">패턴에 삽입 될 유효한 매개 변수에 대한 문서는 모듈 문서를 확인하십시오. 패턴으로 &lt;code&gt;nil&lt;/code&gt; 을 전달 하면 패턴의 기본값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="baffb5f95d2d027ef564012567d5c8bd4d57d7b5" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;character&lt;/code&gt; is a reserved one in a URI.</source>
          <target state="translated">&lt;code&gt;character&lt;/code&gt; 가 URI에서 예약 된 문자 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="4d43630cda829f9c5480cb619b0d9ba3fc02bfa4" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;character&lt;/code&gt; is allowed unescaped in a URI.</source>
          <target state="translated">URI에서 &lt;code&gt;character&lt;/code&gt; 를 이스케이프 할 수 없는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="642c5506cb97150c8b0c49957d1ec0c39ec37c4b" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;character&lt;/code&gt; is an unreserved one in a URI.</source>
          <target state="translated">URI에서 &lt;code&gt;character&lt;/code&gt; 가 예약되지 않은 문자 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="bc5a3786cdb4b06c32ad1fea1d9dd0e8f286bf9a" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;element&lt;/code&gt; exists within the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; 가 &lt;code&gt;enumerable&lt;/code&gt; 내에 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="34e9118ae59c73fb1d0e9850a5a925dc8f08a60c" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;list&lt;/code&gt; is a charlist made only of printable ASCII characters.</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; 가 인쇄 가능한 ASCII 문자로만 이루어진 charlist 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="51ba5162de69ab5b19b61f1d779e77a231f9273a" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;map_set1&lt;/code&gt; and &lt;code&gt;map_set2&lt;/code&gt; have no members in common.</source>
          <target state="translated">&lt;code&gt;map_set1&lt;/code&gt; 과 &lt;code&gt;map_set2&lt;/code&gt; 에 공통 구성원이 없는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="6de0146be0b596d291b6d034f7c054092ea93647" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;map_set1&lt;/code&gt;'s members are all contained in &lt;code&gt;map_set2&lt;/code&gt;.</source>
          <target state="translated">수표 경우 &lt;code&gt;map_set1&lt;/code&gt; 의 구성원 모두에 포함되어 &lt;code&gt;map_set2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="860353a348e857f20a74b65256993cbd76ecfd45" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;map_set&lt;/code&gt; contains &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map_set&lt;/code&gt; 에 &lt;code&gt;value&lt;/code&gt; 가 포함되어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="7d02d1acf553172c398ff3badaa55f9975d65496" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;string&lt;/code&gt; contains any of the given &lt;code&gt;contents&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 에 주어진 &lt;code&gt;contents&lt;/code&gt; 포함되어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="fd0b0ab3712234c91e2a938e6cf5b5d74612661e" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;string&lt;/code&gt; matches the given regular expression.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 이 주어진 정규식과 일치 하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="c32e6246846b85caee2acf1229eb3f9ce12bff47" translate="yes" xml:space="preserve">
          <source>Checks if ANSI coloring is supported and enabled on this machine.</source>
          <target state="translated">이 시스템에서 ANSI 색상이 지원되고 활성화되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="598cd82c1f65bc6e00bf01f403ad5bf50ee82808" translate="yes" xml:space="preserve">
          <source>Checks if a module is open.</source>
          <target state="translated">모듈이 열려 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="97952b511a27ef4ca31c8b021afb71a2e3a4d636" translate="yes" xml:space="preserve">
          <source>Checks if a string contains only printable characters up to &lt;code&gt;character_limit&lt;/code&gt;.</source>
          <target state="translated">확인 문자열까지 인쇄 가능한 문자가 포함 된 경우 &lt;code&gt;character_limit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="738ad3d07d9803b45243f29adefcce780279e603" translate="yes" xml:space="preserve">
          <source>Checks if a variable belongs to the environment.</source>
          <target state="translated">변수가 환경에 속하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="9b7301ad49b99d36c204b6d78c9440851f9234b1" translate="yes" xml:space="preserve">
          <source>Checks if an &lt;code&gt;element&lt;/code&gt; exists within the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; &lt;code&gt;element&lt;/code&gt; 내에 요소 가 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="0c385aef6748980d6bd7e8fb950ad4f9d46b618a" translate="yes" xml:space="preserve">
          <source>Checks if an alias called &lt;code&gt;task&lt;/code&gt; exists.</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; 라는 별명 이 존재 하는지 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="5e7e666e0c3d03945af8991776e375da93987b75" translate="yes" xml:space="preserve">
          <source>Checks if the current module defines the given type (private, opaque or not).</source>
          <target state="translated">현재 모듈이 지정된 유형 (비공개, 불투명 또는 비정의)을 정의하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="889ecbb917f6d1b03f6c203ac51a025e0d0d4cb0" translate="yes" xml:space="preserve">
          <source>Checks if the element on the left-hand side is a member of the collection on the right-hand side.</source>
          <target state="translated">왼쪽에있는 요소가 오른쪽에있는 컬렉션의 멤버인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="3a7758dda8842a876dc8bd8d7f91d3f50d8c1417" translate="yes" xml:space="preserve">
          <source>Checks if the given &lt;code&gt;data&lt;/code&gt; is a record of kind &lt;code&gt;kind&lt;/code&gt;.</source>
          <target state="translated">주어진 경우 확인 &lt;code&gt;data&lt;/code&gt; 종류의 기록이다 &lt;code&gt;kind&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="118f8426c42f72df84637b50990f8b910aead852" translate="yes" xml:space="preserve">
          <source>Checks if the given &lt;code&gt;data&lt;/code&gt; is a record.</source>
          <target state="translated">주어진 &lt;code&gt;data&lt;/code&gt; 가 레코드 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="124c3e109b20d327475da3b493e383ae7cd3250b" translate="yes" xml:space="preserve">
          <source>Checks if the given module is loaded and is an implementation of the given protocol.</source>
          <target state="translated">주어진 모듈이로드되었고 주어진 프로토콜의 구현인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5a8b4e75b4856943a7b23d0e4a8d665c881560a7" translate="yes" xml:space="preserve">
          <source>Checks if the given module is loaded and is protocol.</source>
          <target state="translated">주어진 모듈이로드되었고 프로토콜인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="713890b386025a6cc8d7c4048850fb4a3ab6191f" translate="yes" xml:space="preserve">
          <source>Checks if the given version matches the specification.</source>
          <target state="translated">주어진 버전이 사양과 일치하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="ea84db153f8c1bc78f779caa23e3b2b9bc11b2d3" translate="yes" xml:space="preserve">
          <source>Checks if the module defines a function or macro of the given &lt;code&gt;kind&lt;/code&gt;.</source>
          <target state="translated">모듈이 주어진 &lt;code&gt;kind&lt;/code&gt; 의 함수 또는 매크로를 정의하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="92dc6ac545a0ed645ba9886a5695677e1e6e7604" translate="yes" xml:space="preserve">
          <source>Checks if the module defines the given function or macro.</source>
          <target state="translated">모듈이 주어진 함수 나 매크로를 정의하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="3bea1813950d347f459ed2da2d1886b8aa3f7f12" translate="yes" xml:space="preserve">
          <source>Checks if the system will halt or not at the end of ARGV processing.</source>
          <target state="translated">ARGV 처리가 끝날 때 시스템이 중지되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="437313cfd325500ea732df919e03e5de51e3289c" translate="yes" xml:space="preserve">
          <source>Checks if the task should be run recursively for all sub-apps in umbrella projects.</source>
          <target state="translated">우산 프로젝트의 모든 하위 앱에 대해 작업을 재귀 적으로 실행해야하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c8fc6d1821d83fee2fd98b4e29b2eab8ee0991ba" translate="yes" xml:space="preserve">
          <source>Checks if there is a message matching the given clauses in the current process mailbox.</source>
          <target state="translated">현재 프로세스 사서함에 지정된 절과 일치하는 메시지가 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="79beead16967435820b57e591ccbecace1d1c3ce" translate="yes" xml:space="preserve">
          <source>Checks if two keywords are equal.</source>
          <target state="translated">두 키워드가 같은지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="73ce1f2860aa5f7e1244cc43d53173af401fa1c5" translate="yes" xml:space="preserve">
          <source>Checks if two maps are equal.</source>
          <target state="translated">두 개의 맵이 같은지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="616eb9024590388233fa19552a45060a809c58ab" translate="yes" xml:space="preserve">
          <source>Checks if two ranges are disjoint.</source>
          <target state="translated">두 범위가 분리되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="fc3b8041f2a764e72f9a99d83ff9d7edebb760d0" translate="yes" xml:space="preserve">
          <source>Checks if two sets are equal.</source>
          <target state="translated">두 세트가 같은지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="41c4661f5df293e90c7e8468bec27fa2820e5985" translate="yes" xml:space="preserve">
          <source>Checks the &lt;a href=&quot;macro#t:t/0&quot;&gt;&lt;code&gt;Macro.t/0&lt;/code&gt;&lt;/a&gt; for the specification of a valid quoted expression.</source>
          <target state="translated">유효한 인용 표현식의 스펙에 대해 &lt;a href=&quot;macro#t:t/0&quot;&gt; &lt;code&gt;Macro.t/0&lt;/code&gt; &lt;/a&gt; 을 점검하십시오 .</target>
        </trans-unit>
        <trans-unit id="666ba3e423d21e52f9fd2dec6cb05f41ff960a45" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;string&lt;/code&gt; contains only valid characters.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 에 유효한 문자 만 포함되어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="f6e9c56ca18d9754f5af26417de2a328548838cb" translate="yes" xml:space="preserve">
          <source>Child specification</source>
          <target state="translated">어린이 사양</target>
        </trans-unit>
        <trans-unit id="c3d58e131073765a8fbc52191251a770441a66e5" translate="yes" xml:space="preserve">
          <source>Choose a &lt;a href=&quot;https://choosealicense.com/&quot;&gt;license&lt;/a&gt;. The most common licenses in the Elixir community are the &lt;a href=&quot;https://choosealicense.com/licenses/mit/&quot;&gt;MIT License&lt;/a&gt; and the &lt;a href=&quot;https://choosealicense.com/licenses/apache-2.0/&quot;&gt;Apache License 2.0&lt;/a&gt;. The latter is also the one used by Elixir itself.</source>
          <target state="translated">&lt;a href=&quot;https://choosealicense.com/&quot;&gt;라이센스를&lt;/a&gt; 선택하십시오 . Elixir 커뮤니티에서 가장 일반적인 라이센스는 &lt;a href=&quot;https://choosealicense.com/licenses/mit/&quot;&gt;MIT 라이센스&lt;/a&gt; 및 &lt;a href=&quot;https://choosealicense.com/licenses/apache-2.0/&quot;&gt;Apache 라이센스 2.0&lt;/a&gt; 입니다. 후자는 또한 Elixir 자체가 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d746003f831879f4d9c00718df18aa77507218d3" translate="yes" xml:space="preserve">
          <source>Choose a versioning schema. Elixir requires versions to be in the format &lt;code&gt;MAJOR.MINOR.PATCH&lt;/code&gt; but the meaning of those numbers is up to you. Most projects choose &lt;a href=&quot;https://semver.org/&quot;&gt;Semantic Versioning&lt;/a&gt;.</source>
          <target state="translated">버전 관리 스키마를 선택하십시오. Elixir의 버전은 &lt;code&gt;MAJOR.MINOR.PATCH&lt;/code&gt; 형식 이어야 하지만 해당 숫자의 의미는 사용자에게 달려 있습니다. 대부분의 프로젝트는 &lt;a href=&quot;https://semver.org/&quot;&gt;시맨틱 버전 관리를&lt;/a&gt; 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="1339b412671e2da05add576032c5b579ea52376a" translate="yes" xml:space="preserve">
          <source>Choosing requirement R6 automatically excludes requirements R4, R5 and R7.</source>
          <target state="translated">요구 사항 R6을 선택하면 요구 사항 R4, R5 및 R7이 자동으로 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="ef47da406dcfe37fc12040175eeecabe9f974ccd" translate="yes" xml:space="preserve">
          <source>Chunks the &lt;code&gt;enum&lt;/code&gt; by buffering elements for which &lt;code&gt;fun&lt;/code&gt; returns the same value.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 이 동일한 값을 반환하는 요소를 버퍼링 하여 &lt;code&gt;enum&lt;/code&gt; 를 청크합니다 .</target>
        </trans-unit>
        <trans-unit id="09c64d73a45df2fc80159ff7084b07b4e192ed3b" translate="yes" xml:space="preserve">
          <source>Chunks the &lt;code&gt;enum&lt;/code&gt; with fine grained control when every chunk is emitted.</source>
          <target state="translated">모든 청크가 방출 될 때 세밀한 제어로 &lt;code&gt;enum&lt;/code&gt; 를 청크합니다 .</target>
        </trans-unit>
        <trans-unit id="f3199a3f0afc069c8d87ccec0cb9e42069a3b81e" translate="yes" xml:space="preserve">
          <source>Chunks the &lt;code&gt;enumerable&lt;/code&gt; with fine grained control when every chunk is emitted.</source>
          <target state="translated">청크 &lt;code&gt;enumerable&lt;/code&gt; 모든 청크가 방출 될 때 벌금 제어 그레인.</target>
        </trans-unit>
        <trans-unit id="5130e70e6af041df0b4f02efa5896c71601680f4" translate="yes" xml:space="preserve">
          <source>Clauses also allow extra conditions to be specified via guards:</source>
          <target state="translated">조항은 또한 가드를 통해 추가 조건을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d21fa3b66fd85a0eae22c5b7627920962b58e23" translate="yes" xml:space="preserve">
          <source>Clears all invoked tasks, allowing them to be reinvoked.</source>
          <target state="translated">호출 된 모든 작업을 지우고 다시 호출 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="b5501033c685e38d6fb36033a17bad897fb206fd" translate="yes" xml:space="preserve">
          <source>Clears line.</source>
          <target state="translated">선을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="b408d2632b8e891b143869b00518580273c47949" translate="yes" xml:space="preserve">
          <source>Clears out all messages sent to the shell's inbox and prints them out.</source>
          <target state="translated">쉘의받은 편지함으로 전송 된 모든 메시지를 지우고 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="8eb38935be80ed9039da3a39b11aa4d0c24919e9" translate="yes" xml:space="preserve">
          <source>Clears screen.</source>
          <target state="translated">화면을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="f02f33c6f3cdd9389808e91d095c2309fcb9224a" translate="yes" xml:space="preserve">
          <source>Clears the console screen.</source>
          <target state="translated">콘솔 화면을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="827e22262ec4bb7ded4eeadb9fb3aa8dc2c35bd9" translate="yes" xml:space="preserve">
          <source>Clears the dependency for the current environment.</source>
          <target state="translated">현재 환경에 대한 종속성을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="9c4f3063144d0a8e09522b56e2ecffbfbfc5efbc" translate="yes" xml:space="preserve">
          <source>Client / Server APIs</source>
          <target state="translated">클라이언트 / 서버 API</target>
        </trans-unit>
        <trans-unit id="ee4f79f897434114271f46c13449ce1869f416ea" translate="yes" xml:space="preserve">
          <source>Client/Server in agents</source>
          <target state="translated">에이전트의 클라이언트 / 서버</target>
        </trans-unit>
        <trans-unit id="182072135056cbdedcd87bbad9287c89ec82bc4d" translate="yes" xml:space="preserve">
          <source>Clients and Servers - Learn You Some Erlang for Great Good!</source>
          <target state="translated">클라이언트와 서버-당신을 위해 Erlang을 배우십시오.</target>
        </trans-unit>
        <trans-unit id="5321f8adc0182546df611269506b6bc3b81f34df" translate="yes" xml:space="preserve">
          <source>Closes the &lt;code&gt;port&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;port&lt;/code&gt; 닫습니다 .</target>
        </trans-unit>
        <trans-unit id="08b2eefe6b6ef7fc70e6d5b483e21b4922d35e18" translate="yes" xml:space="preserve">
          <source>Closes the file referenced by &lt;code&gt;io_device&lt;/code&gt;. It mostly returns &lt;code&gt;:ok&lt;/code&gt;, except for some severe errors such as out of memory.</source>
          <target state="translated">&lt;code&gt;io_device&lt;/code&gt; 에서 참조하는 파일을 닫습니다 . 메모리 부족과 같은 심각한 오류를 제외하고 는 주로 &lt;code&gt;:ok&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="e9b5273619e7c9d59651c9302451ddc5bba79f43" translate="yes" xml:space="preserve">
          <source>Code comments</source>
          <target state="translated">코드 주석</target>
        </trans-unit>
        <trans-unit id="407e0b95bcfcf898b9202ae04357406ff3f10f14" translate="yes" xml:space="preserve">
          <source>Code comments are aimed at developers reading the code. They are useful for marking improvements, leaving notes (for example, why you had to resort to a workaround due to a bug in a library), and so forth. They are tied to the source code: you can completely rewrite a function and remove all existing code comments, and it will continue to behave the same, with no change to either its behaviour or its documentation.</source>
          <target state="translated">코드 주석은 코드를 읽는 개발자를 대상으로합니다. 개선 사항을 표시하고 메모를 남기는 데 유용합니다 (예 : 라이브러리의 버그로 인해 해결 방법을 사용해야하는 이유 등). 그것들은 소스 코드에 묶여 있습니다 : 함수를 완전히 다시 작성하고 기존의 모든 코드 주석을 제거 할 수 있으며, 동작이나 문서의 변경없이 계속 동일하게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="3d0c84971ed8c269fff1364330b0cb908605d37f" translate="yes" xml:space="preserve">
          <source>Code loading on the Erlang VM</source>
          <target state="translated">Erlang VM에서 코드 로딩</target>
        </trans-unit>
        <trans-unit id="ec7909dcc79311e3f0b6979c6dc4d55422c72b61" translate="yes" xml:space="preserve">
          <source>Code points and grapheme cluster</source>
          <target state="translated">코드 포인트 및 그래 핀 클러스터</target>
        </trans-unit>
        <trans-unit id="1aa5924d1c20fa9f241eb4e1b21f78f5905bf0bd" translate="yes" xml:space="preserve">
          <source>Code preloading. The VM has two mechanisms for loading code: interactive and embedded. By default, it runs in the interactive mode which dynamically loads modules when they are used for the first time. The first time your application calls &lt;code&gt;Enum.map/2&lt;/code&gt;, the VM will find the &lt;code&gt;Enum&lt;/code&gt; module and load it. There&amp;rsquo;s a downside. When you start a new server in production, it may need to load many other modules, causing the first requests to have an unusual spike in response time. Releases run in embedded mode, which loads all available modules upfront, guaranteeing your system is ready to handle requests after booting.</source>
          <target state="translated">코드 사전로드 VM에는 코드로드를위한 두 가지 메커니즘 (대화식 및 임베디드)이 있습니다. 기본적으로 대화식 모드에서 실행되며 모듈을 처음 사용할 때 동적으로로드됩니다. 애플리케이션이 &lt;code&gt;Enum.map/2&lt;/code&gt; 를 처음 호출 하면 VM이 &lt;code&gt;Enum&lt;/code&gt; 모듈 을 찾아 로드합니다. 단점이 있습니다. 프로덕션에서 새 서버를 시작하면 다른 많은 모듈을로드해야하므로 첫 번째 요청에 응답 시간이 비정상적으로 급증합니다. 릴리스는 임베드 된 모드에서 실행되며 사용 가능한 모든 모듈을 사전로드하여 부팅 후 시스템이 요청을 처리 할 수 ​​있도록합니다.</target>
        </trans-unit>
        <trans-unit id="9bbbc29ce6e01c5f883b21207d4df5d189f562e4" translate="yes" xml:space="preserve">
          <source>Code to be executed can also be passed inline with the &lt;code&gt;-e&lt;/code&gt; option:</source>
          <target state="translated">실행할 코드는 &lt;code&gt;-e&lt;/code&gt; 옵션을 사용하여 인라인으로 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8925ef3817c5078333f965ac2c4f8fd3dec413cd" translate="yes" xml:space="preserve">
          <source>Code.LoadError</source>
          <target state="translated">Code.LoadError</target>
        </trans-unit>
        <trans-unit id="2793300c10721db92c5d2235001b12020b992cc1" translate="yes" xml:space="preserve">
          <source>Code.LoadError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Code.LoadError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="87076accf13c08a15b009170f620b176a4faca61" translate="yes" xml:space="preserve">
          <source>Code.fetch_docs/1</source>
          <target state="translated">Code.fetch_docs/1</target>
        </trans-unit>
        <trans-unit id="faada4c03778897c42585b08b0a16dfdfe932b0b" translate="yes" xml:space="preserve">
          <source>Collapse any new lines and whitespace following this node, emitting up to &lt;code&gt;max&lt;/code&gt; new lines.</source>
          <target state="translated">이 노드 다음에 새 줄과 공백을 축소하여 &lt;code&gt;max&lt;/code&gt; 새 줄을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="91af54365271b68093cc58f58877c5e5fbf80e5a" translate="yes" xml:space="preserve">
          <source>Collectable</source>
          <target state="translated">Collectable</target>
        </trans-unit>
        <trans-unit id="d80c0d2f5db391e72e90f3887949506276cfb40c" translate="yes" xml:space="preserve">
          <source>Collectable &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">수집 가능한 &lt;small&gt;프로토콜&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="efccae93725e6f5a9afb9579e21ff7b906852fd3" translate="yes" xml:space="preserve">
          <source>Collectable.command (0)</source>
          <target state="translated">수집 가능 명령 (0)</target>
        </trans-unit>
        <trans-unit id="8647850dbe0b4bbf11c6e320d7b6ef187ee2db5e" translate="yes" xml:space="preserve">
          <source>Collectable.into (1)</source>
          <target state="translated">수집 가능 (1)</target>
        </trans-unit>
        <trans-unit id="3f6e96c64cc87200f83a7abe1d28f9e91920b4d4" translate="yes" xml:space="preserve">
          <source>Collectable.t (0)</source>
          <target state="translated">Collectable.t (0)</target>
        </trans-unit>
        <trans-unit id="88d5e4cac104ffc3f02dd54f2f0f1074fd33fd9b" translate="yes" xml:space="preserve">
          <source>Colors</source>
          <target state="translated">Colors</target>
        </trans-unit>
        <trans-unit id="96e74053cae538c3ecd9d29799c5c9b0fceb9d72" translate="yes" xml:space="preserve">
          <source>Colors a document if the &lt;code&gt;color_key&lt;/code&gt; has a color in the options.</source>
          <target state="translated">&lt;code&gt;color_key&lt;/code&gt; 에 옵션에 색상이 있으면 문서 의 색상을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6e3d3bf1961b8057b125fc05310e2099de8793b0" translate="yes" xml:space="preserve">
          <source>Command line options</source>
          <target state="translated">명령 줄 옵션</target>
        </trans-unit>
        <trans-unit id="f67e000a046a21604b2818c94a17c7ddab8e2442" translate="yes" xml:space="preserve">
          <source>Command-line options</source>
          <target state="translated">명령 줄 옵션</target>
        </trans-unit>
        <trans-unit id="e49bd0922826a05729c3e5928e11f174c484ef82" translate="yes" xml:space="preserve">
          <source>Community and other resources</source>
          <target state="translated">커뮤니티 및 기타 리소스</target>
        </trans-unit>
        <trans-unit id="351b39c3cb9ffe473609505c1caefaf73bfad121" translate="yes" xml:space="preserve">
          <source>Compared to keyword lists, we can already see two differences:</source>
          <target state="translated">키워드 목록과 비교할 때 이미 두 가지 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c4dd5827aee0b7bc5bce155cef1a41295eb21d9" translate="yes" xml:space="preserve">
          <source>Compared to the &lt;a href=&quot;#cp/3&quot;&gt;&lt;code&gt;cp/3&lt;/code&gt;&lt;/a&gt;, this function is more low-level, allowing a copy from device to device limited by a number of bytes. On the other hand, &lt;a href=&quot;#cp/3&quot;&gt;&lt;code&gt;cp/3&lt;/code&gt;&lt;/a&gt; performs more extensive checks on both source and destination and it also preserves the file mode after copy.</source>
          <target state="translated">&lt;a href=&quot;#cp/3&quot;&gt; &lt;code&gt;cp/3&lt;/code&gt; &lt;/a&gt; 과 비교할 때이 기능은 더 낮은 수준이므로 여러 바이트로 제한되는 장치 간 복사가 가능합니다. 반면에 &lt;a href=&quot;#cp/3&quot;&gt; &lt;code&gt;cp/3&lt;/code&gt; &lt;/a&gt; 는 소스와 대상 모두에 대해보다 광범위한 검사를 수행하며 복사 후에 파일 모드를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="4396ebd5f93ea927d7f38fcc76884b2d876b8c70" translate="yes" xml:space="preserve">
          <source>Compares log levels.</source>
          <target state="translated">로그 수준을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="2bddca0648b60655df6f9b1bec6eaa161ae7af3b" translate="yes" xml:space="preserve">
          <source>Compares two &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; structs.</source>
          <target state="translated">두 개의 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 구조체를 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="221fa096c94059dac8cb4762f358f4aa7a03c1ff" translate="yes" xml:space="preserve">
          <source>Compares two date structs.</source>
          <target state="translated">두 개의 날짜 구조체를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="6782100a1e3b01bfa6aced20d6a89d3df7b1b892" translate="yes" xml:space="preserve">
          <source>Compares two datetime structs.</source>
          <target state="translated">두 개의 datetime 구조체를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="34b17d0b1be43ba0ceacc7bc5ba086b336622a11" translate="yes" xml:space="preserve">
          <source>Compares two time structs.</source>
          <target state="translated">두 시간 구조체를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="aed844f61a9c1a83201e59d846227cc4ca353638" translate="yes" xml:space="preserve">
          <source>Compares two versions.</source>
          <target state="translated">두 버전을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="7dca07167ef3fe34550bf0509fc6fb45f893e74a" translate="yes" xml:space="preserve">
          <source>Comparing dates</source>
          <target state="translated">날짜 비교</target>
        </trans-unit>
        <trans-unit id="fb5333c90cc8d2bfbc9b665af90800832ab0f856" translate="yes" xml:space="preserve">
          <source>Comparing naive date times</source>
          <target state="translated">순진한 날짜 시간 비교</target>
        </trans-unit>
        <trans-unit id="72158d6e3482e00cedae532226bd81727e66a164" translate="yes" xml:space="preserve">
          <source>Comparing times</source>
          <target state="translated">시간 비교</target>
        </trans-unit>
        <trans-unit id="9461d4c9f916ad7df5538225ed552fb6e7e3284b" translate="yes" xml:space="preserve">
          <source>Comparison operators</source>
          <target state="translated">비교 연산자</target>
        </trans-unit>
        <trans-unit id="15ab192596c8ba15e4efa62ffe722828f388b1e3" translate="yes" xml:space="preserve">
          <source>Comparison to &lt;a href=&quot;kernel.specialforms#quote/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;kernel.specialforms#quote/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.quote/2&lt;/code&gt; 와&lt;/a&gt; 비교</target>
        </trans-unit>
        <trans-unit id="b40ad652f0b8e3e0fb8ff30d06417bb28cb7e636" translate="yes" xml:space="preserve">
          <source>Comparison with binary pattern matching</source>
          <target state="translated">이진 패턴 매칭과 비교</target>
        </trans-unit>
        <trans-unit id="7ea963a047168a722cbd246ebd47586d05f01b19" translate="yes" xml:space="preserve">
          <source>Comparisons in Elixir using &lt;a href=&quot;kernel#==/2&quot;&gt;&lt;code&gt;==/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253E/2&quot;&gt;&lt;code&gt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253C/2&quot;&gt;&lt;code&gt;&amp;lt;/2&lt;/code&gt;&lt;/a&gt; and similar are structural and based on the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; struct fields. For proper comparison between dates, use the &lt;a href=&quot;#compare/2&quot;&gt;&lt;code&gt;compare/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;kernel#==/2&quot;&gt; &lt;code&gt;==/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#%253E/2&quot;&gt; &lt;code&gt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#%253C/2&quot;&gt; &lt;code&gt;&amp;lt;/2&lt;/code&gt; &lt;/a&gt; 등을 사용하는 Elixir의 비교 는 구조적이며 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 구조체 필드를 기반으로 합니다. 날짜를 올바르게 비교하려면 &lt;a href=&quot;#compare/2&quot;&gt; &lt;code&gt;compare/2&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="223f508a513f824a4ac2feecf7af48fa276819c5" translate="yes" xml:space="preserve">
          <source>Comparisons in Elixir using &lt;a href=&quot;kernel#==/2&quot;&gt;&lt;code&gt;==/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253E/2&quot;&gt;&lt;code&gt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253C/2&quot;&gt;&lt;code&gt;&amp;lt;/2&lt;/code&gt;&lt;/a&gt; and similar are structural and based on the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; struct fields. For proper comparison between naive datetimes, use the &lt;a href=&quot;#compare/2&quot;&gt;&lt;code&gt;compare/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;kernel#==/2&quot;&gt; &lt;code&gt;==/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#%253E/2&quot;&gt; &lt;code&gt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#%253C/2&quot;&gt; &lt;code&gt;&amp;lt;/2&lt;/code&gt; &lt;/a&gt; 등을 사용한 Elixir의 비교 는 구조적이며 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 구조체 필드를 기반으로 합니다. 순진한 날짜 시간을 올바르게 비교하려면 &lt;a href=&quot;#compare/2&quot;&gt; &lt;code&gt;compare/2&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bfda4dfed8330e94d2d4752354274648b44ba3b" translate="yes" xml:space="preserve">
          <source>Comparisons in Elixir using &lt;a href=&quot;kernel#==/2&quot;&gt;&lt;code&gt;==/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253E/2&quot;&gt;&lt;code&gt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253C/2&quot;&gt;&lt;code&gt;&amp;lt;/2&lt;/code&gt;&lt;/a&gt; and similar are structural and based on the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; struct fields. For proper comparison between times, use the &lt;a href=&quot;#compare/2&quot;&gt;&lt;code&gt;compare/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;kernel#==/2&quot;&gt; &lt;code&gt;==/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#%253E/2&quot;&gt; &lt;code&gt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#%253C/2&quot;&gt; &lt;code&gt;&amp;lt;/2&lt;/code&gt; &lt;/a&gt; 등을 사용하는 Elixir의 비교 는 구조적이며 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; 구조 필드를 기반으로 합니다. 시간을 적절히 비교하려면 &lt;a href=&quot;#compare/2&quot;&gt; &lt;code&gt;compare/2&lt;/code&gt; &lt;/a&gt; 기능을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="c4a94cda45edff3876fed45dbc4c3cb4ce79baa3" translate="yes" xml:space="preserve">
          <source>Compatibility and Deprecations</source>
          <target state="translated">호환성 및 지원 중단</target>
        </trans-unit>
        <trans-unit id="f42d7b50ca233e04dc35e582f6b9af961f23c004" translate="yes" xml:space="preserve">
          <source>Compatibility between Elixir and Erlang/OTP</source>
          <target state="translated">Elixir와 Erlang / OTP의 호환성</target>
        </trans-unit>
        <trans-unit id="8f74e2722c1f84edbd83275bae1006369ac7ea9d" translate="yes" xml:space="preserve">
          <source>Compatibility between non-major Elixir versions</source>
          <target state="translated">비 주요 Elixir 버전 간의 호환성</target>
        </trans-unit>
        <trans-unit id="1684199ac60e5587c6ced4c1cbb54268a896b641" translate="yes" xml:space="preserve">
          <source>Compatibility with OTP behaviours</source>
          <target state="translated">OTP 동작과의 호환성</target>
        </trans-unit>
        <trans-unit id="aad755de429541e8ec1db943cf4102247f2bb5d3" translate="yes" xml:space="preserve">
          <source>Compilation</source>
          <target state="translated">Compilation</target>
        </trans-unit>
        <trans-unit id="3e7a794cfc66ce992a7ff5365bcfa7b7bd38cc57" translate="yes" xml:space="preserve">
          <source>Compilation environment macros (&lt;a href=&quot;kernel.specialforms#__CALLER__/0&quot;&gt;&lt;code&gt;__CALLER__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#__DIR__/0&quot;&gt;&lt;code&gt;__DIR__/0&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt;&lt;code&gt;__ENV__/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">컴파일 환경 매크로 ( &lt;a href=&quot;kernel.specialforms#__CALLER__/0&quot;&gt; &lt;code&gt;__CALLER__/0&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel.specialforms#__DIR__/0&quot;&gt; &lt;code&gt;__DIR__/0&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel.specialforms#__ENV__/0&quot;&gt; &lt;code&gt;__ENV__/0&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="f657a919e86d30d7dc49c2990c4badfef6d2ae9b" translate="yes" xml:space="preserve">
          <source>Compile a string (&lt;code&gt;compile_string&lt;/code&gt;) or a file (&lt;code&gt;compile_file&lt;/code&gt;) into Elixir syntax tree. This is the API used by both functions above and is available to you if you want to provide your own ways of handling the compiled template.</source>
          <target state="translated">문자열 ( &lt;code&gt;compile_string&lt;/code&gt; ) 또는 파일 ( &lt;code&gt;compile_file&lt;/code&gt; )을 Elixir 구문 트리로 컴파일하십시오 . 이것은 위의 두 기능에서 모두 사용되는 API이며 컴파일 된 템플릿을 처리하는 고유 한 방법을 제공하려는 경우 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99d6c95e99f15d2782415966b874bf7ac7c480ec" translate="yes" xml:space="preserve">
          <source>Compile callbacks</source>
          <target state="translated">콜백 컴파일</target>
        </trans-unit>
        <trans-unit id="b9b345cfc373ededcbc96ee76cf173b0c38e656e" translate="yes" xml:space="preserve">
          <source>Compile options</source>
          <target state="translated">컴파일 옵션</target>
        </trans-unit>
        <trans-unit id="a4eb1e8f716939c9fd4a5a9009f8576e365876fc" translate="yes" xml:space="preserve">
          <source>CompileError</source>
          <target state="translated">CompileError</target>
        </trans-unit>
        <trans-unit id="f54ad90826f1166c75feaaf8212b1ffed6e2b140" translate="yes" xml:space="preserve">
          <source>CompileError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">CompileError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d3b37411d97ddaa5a4d151b734a15fb76e5fca29" translate="yes" xml:space="preserve">
          <source>Compiler front-end: improvements may be done to the compiler, introducing new warnings for ambiguous modes and providing more detailed error messages. Those can lead to compilation errors (when running with &lt;code&gt;--warning-as-errors&lt;/code&gt;) or tooling failures when asserting on specific error messages (although one should avoid such). We reserve the right to do such improvements.</source>
          <target state="translated">컴파일러 프론트 엔드 : 모호한 모드에 대한 새로운 경고를 제공하고보다 자세한 오류 메시지를 제공하여 컴파일러를 개선 할 수 있습니다. 특정 오류 메시지를 주장 할 때 컴파일 오류 ( &lt;code&gt;--warning-as-errors&lt;/code&gt; 로 실행할 때 ) 또는 툴링 오류가 발생할 수 있습니다 (그러나 이러한 오류는 피해야 함). 우리는 그러한 개선을 할 권리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1be83a7756a5bb6c9b11d838efbdc2b010f2edd" translate="yes" xml:space="preserve">
          <source>Compilers</source>
          <target state="translated">Compilers</target>
        </trans-unit>
        <trans-unit id="6a97aec4e0f175d98451227716629a5e06e9daa5" translate="yes" xml:space="preserve">
          <source>Compiles Elixir source files.</source>
          <target state="translated">Elixir 소스 파일을 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="bec1c5e79e401a7466a08ba63018054233105899" translate="yes" xml:space="preserve">
          <source>Compiles Erlang source files.</source>
          <target state="translated">Erlang 소스 파일을 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="1f5b4ba2582167bc9dbc03751202b445126c211d" translate="yes" xml:space="preserve">
          <source>Compiles Yecc source files.</source>
          <target state="translated">Yecc 소스 파일을 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="0555a5fff463fa1be9a0f36abf14a298f2675629" translate="yes" xml:space="preserve">
          <source>Compiles a format string into a data structure that &lt;a href=&quot;#format/5&quot;&gt;&lt;code&gt;format/5&lt;/code&gt;&lt;/a&gt; can handle.</source>
          <target state="translated">형식 문자열을 &lt;a href=&quot;#format/5&quot;&gt; &lt;code&gt;format/5&lt;/code&gt; &lt;/a&gt; 가 처리 할 수 있는 데이터 구조로 컴파일합니다 .</target>
        </trans-unit>
        <trans-unit id="12d2667a1f41abc65eebfb8aca2ce483662f6d90" translate="yes" xml:space="preserve">
          <source>Compiles a requirement to its internal representation with &lt;a href=&quot;http://www.erlang.org/doc/man/ets.html#match_spec_compile-1&quot;&gt;&lt;code&gt;:ets.match_spec_compile/1&lt;/code&gt;&lt;/a&gt; for faster matching.</source>
          <target state="translated">빠른 일치를 위해 &lt;a href=&quot;http://www.erlang.org/doc/man/ets.html#match_spec_compile-1&quot;&gt; &lt;code&gt;:ets.match_spec_compile/1&lt;/code&gt; &lt;/a&gt; 을 사용하여 내부 표현에 대한 요구 사항을 컴파일합니다 .</target>
        </trans-unit>
        <trans-unit id="f2cf002d6de77f196a3161337e5d01f628fa219c" translate="yes" xml:space="preserve">
          <source>Compiles the given file.</source>
          <target state="translated">주어진 파일을 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="fe5d7e4a131dbe8c58cc4a04762428daf778a3f1" translate="yes" xml:space="preserve">
          <source>Compiles the given files.</source>
          <target state="translated">주어진 파일을 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="a5664f86acdcfb847dd8e5c6fc454b47248e9f79" translate="yes" xml:space="preserve">
          <source>Compiles the given project.</source>
          <target state="translated">주어진 프로젝트를 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="ae26c039cef510e8b34ba14faf19222f446f7af5" translate="yes" xml:space="preserve">
          <source>Compiles the given string.</source>
          <target state="translated">주어진 문자열을 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="917e43c9d373a6e4c3419110429f241ad1a5803b" translate="yes" xml:space="preserve">
          <source>Compiles the quoted expression.</source>
          <target state="translated">인용 식을 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="c23a1bc10af7479e16b7d2e120610e8416f989f4" translate="yes" xml:space="preserve">
          <source>Compiles the regular expression and raises &lt;a href=&quot;regex.compileerror&quot;&gt;&lt;code&gt;Regex.CompileError&lt;/code&gt;&lt;/a&gt; in case of errors.</source>
          <target state="translated">정규식을 컴파일하고 오류 발생시 &lt;a href=&quot;regex.compileerror&quot;&gt; &lt;code&gt;Regex.CompileError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="1e49c3744a3522b82c9288a53a5c637df4b01d82" translate="yes" xml:space="preserve">
          <source>Compiles the regular expression.</source>
          <target state="translated">정규식을 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="ed2ff637c10fb1755e29c0eb2376d67d8e5a91b4" translate="yes" xml:space="preserve">
          <source>Comprehensions</source>
          <target state="translated">Comprehensions</target>
        </trans-unit>
        <trans-unit id="1310c30df240bc12f3591d11936eb9f7e6967dd7" translate="yes" xml:space="preserve">
          <source>Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring.</source>
          <target state="translated">이해를 통해 열거 가능 또는 비트 열에서 데이터 구조를 신속하게 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfe3133c5fadf89f0c4e372dfb9d3554729a6dc3" translate="yes" xml:space="preserve">
          <source>Comprehensions discard all elements for which the filter expression returns &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;; all other values are selected.</source>
          <target state="translated">이해는 필터 표현식이 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 을 리턴하는 모든 요소를 ​​버립니다 . 다른 모든 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="5b77c42be234abc320cd3adb104af1c94a8cbc7a" translate="yes" xml:space="preserve">
          <source>Comprehensions generally provide a much more concise representation than using the equivalent functions from the &lt;code&gt;Enum&lt;/code&gt; and &lt;code&gt;Stream&lt;/code&gt; modules. Furthermore, comprehensions also allow multiple generators and filters to be given. Here is an example that receives a list of directories and gets the size of each file in those directories:</source>
          <target state="translated">이해력은 일반적으로 &lt;code&gt;Enum&lt;/code&gt; 및 &lt;code&gt;Stream&lt;/code&gt; 모듈 의 동등한 기능을 사용하는 것보다 훨씬 간결한 표현을 제공 합니다. 더욱이, 이해력은 또한 다수의 발전기와 필터가 제공 될 수있게한다. 다음은 디렉토리 목록을 수신하고 해당 디렉토리에있는 각 파일의 크기를 가져 오는 예입니다.</target>
        </trans-unit>
        <trans-unit id="2a2326284774c69e81d063232192764ec8e7d87e" translate="yes" xml:space="preserve">
          <source>Computes the Jaro distance (similarity) between two strings.</source>
          <target state="translated">두 줄 사이의 Jaro 거리 (유사성)를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d58e9fd05f3363b68db438a625d16b10d703140f" translate="yes" xml:space="preserve">
          <source>Computes the bag distance between two strings.</source>
          <target state="translated">두 스트링 사이의 백 거리를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="7e5fa6baea52e5444c5ab52e6620ff1a5e2eaa64" translate="yes" xml:space="preserve">
          <source>Computes the modulo remainder of an integer division.</source>
          <target state="translated">정수 나누기의 모듈로 나머지를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1695adb6bedb251b98b5d02b3e294f80f6533ad8" translate="yes" xml:space="preserve">
          <source>Computes the remainder of an integer division.</source>
          <target state="translated">정수 나누기의 나머지를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ca3e5ac4bfa4005f9e7c85636c6e23330025a032" translate="yes" xml:space="preserve">
          <source>Concatenates a list of aliases and returns a new alias only if the alias was already referenced.</source>
          <target state="translated">별명 목록을 연결하고 별명이 이미 참조 된 경우에만 새 별명을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="79fdba952b89833ad044a47f954b778d9ac3754b" translate="yes" xml:space="preserve">
          <source>Concatenates a list of aliases and returns a new alias.</source>
          <target state="translated">별명 목록을 연결하고 새 별명을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7bfc55b10bbbaaa1172955e020d089c69f73a61a" translate="yes" xml:space="preserve">
          <source>Concatenates a list of documents returning a new document.</source>
          <target state="translated">새 문서를 반환하는 문서 목록을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="5b0b906d9626f876d63bb926f568d768133479d8" translate="yes" xml:space="preserve">
          <source>Concatenates a proper list and a term, returning a list.</source>
          <target state="translated">올바른 목록과 용어를 연결하여 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="602a2270158b7a64f1f9b30928698846da471ed5" translate="yes" xml:space="preserve">
          <source>Concatenates the enumerable on the &lt;code&gt;right&lt;/code&gt; with the enumerable on the &lt;code&gt;left&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;right&lt;/code&gt; 의 열거 형과 &lt;code&gt;left&lt;/code&gt; 의 열거 형을 연결합니다 .</target>
        </trans-unit>
        <trans-unit id="17b31e6fe3e3ae89aaf0d1779930dec62c20d4ce" translate="yes" xml:space="preserve">
          <source>Concatenates two aliases and returns a new alias only if the alias was already referenced.</source>
          <target state="translated">두 개의 별칭을 연결하고 별칭이 이미 참조 된 경우에만 새 별칭을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="386735a5ef2326d96732530103099d26861648c4" translate="yes" xml:space="preserve">
          <source>Concatenates two aliases and returns a new alias.</source>
          <target state="translated">두 개의 별명을 연결하고 새 별명을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d9fca663b0cde911b53f590809a91e7d824fbc80" translate="yes" xml:space="preserve">
          <source>Concatenates two binaries.</source>
          <target state="translated">두 개의 이진을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="0f2b5970a12dbb01ecd860bde29bb4c55faec263" translate="yes" xml:space="preserve">
          <source>Concatenates two document entities returning a new document.</source>
          <target state="translated">새 문서를 반환하는 두 문서 엔터티를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="f8bc4ede142b49230daa5c308a51253e61b3acb4" translate="yes" xml:space="preserve">
          <source>Conceal. Not widely supported.</source>
          <target state="translated">숨기다. 널리 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="464963b89dcc6466af50e87b1ef88a9571abb6de" translate="yes" xml:space="preserve">
          <source>Concurrency and distribution</source>
          <target state="translated">동시성 및 배포</target>
        </trans-unit>
        <trans-unit id="7cd453bb0f5341af9292ceae5a5c3162881bf52e" translate="yes" xml:space="preserve">
          <source>CondClauseError</source>
          <target state="translated">CondClauseError</target>
        </trans-unit>
        <trans-unit id="ee1067fabb817f815f6d1ba09137fd2a6703386f" translate="yes" xml:space="preserve">
          <source>CondClauseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">CondClauseError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8851142da56fd885ce668a165b33fee7003e858d" translate="yes" xml:space="preserve">
          <source>Config</source>
          <target state="translated">Config</target>
        </trans-unit>
        <trans-unit id="be61fc18c63c243175cee5a20cbdc6209fe104d3" translate="yes" xml:space="preserve">
          <source>Config providers are typically used during releases to load external configuration while the system boots. This is done by starting the VM with the minimum amount of applications running, then invoking all of the providers, and then restarting the system. This requires a mutable configuration file on disk, as the results of the providers are written to the file system. For more information on runtime configuration, see &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구성 공급자는 일반적으로 릴리스 중에 시스템이 부팅되는 동안 외부 구성을로드하는 데 사용됩니다. 최소한의 응용 프로그램을 실행하여 VM을 시작한 다음 모든 공급자를 호출 한 다음 시스템을 다시 시작하면됩니다. 제공자의 결과가 파일 시스템에 기록되므로 디스크에 변경 가능한 구성 파일이 필요합니다. 런타임 구성에 대한 자세한 정보는 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5fcd3c95e9636c8e66396624d0366fb4e126a6fc" translate="yes" xml:space="preserve">
          <source>Config.Provider</source>
          <target state="translated">Config.Provider</target>
        </trans-unit>
        <trans-unit id="44f0cb9ea6de4ecc8ddcc1c6279200cfa4b1dd4c" translate="yes" xml:space="preserve">
          <source>Config.Provider &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">구성 제공자 &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9ada04c4b7a0b493079259a2091c99186d5d2a8d" translate="yes" xml:space="preserve">
          <source>Config.Reader</source>
          <target state="translated">Config.Reader</target>
        </trans-unit>
        <trans-unit id="754164850f38c1ecdaf6b8ed894cb192bc36c5f4" translate="yes" xml:space="preserve">
          <source>Configuration</source>
          <target state="translated">Configuration</target>
        </trans-unit>
        <trans-unit id="933619b0b6242cbc74cd30c08b880cf1aadc921f" translate="yes" xml:space="preserve">
          <source>Configuration and customization. Releases give developers fine grained control over system configuration and the VM flags used to start the system.</source>
          <target state="translated">구성 및 사용자 정의 릴리스는 개발자에게 시스템 구성 및 시스템 시작에 사용되는 VM 플래그에 대한 세밀한 제어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6d11d00d9a62190558bb928d4cffeb8d72a5cbfa" translate="yes" xml:space="preserve">
          <source>Configuration and releases</source>
          <target state="translated">구성 및 릴리스</target>
        </trans-unit>
        <trans-unit id="304a1684e3b52f4fb102a5314a519b8e7696a2ea" translate="yes" xml:space="preserve">
          <source>Configuration files provide a mechanism for us to configure the environment of any application. Such configuration is done by the &lt;code&gt;config/config.exs&lt;/code&gt; file.</source>
          <target state="translated">구성 파일은 모든 응용 프로그램의 환경을 구성 할 수있는 메커니즘을 제공합니다. 이러한 구성은 &lt;code&gt;config/config.exs&lt;/code&gt; 파일에 의해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="afb00b3a5bb013d5e19cf2138a2e20f7d4494b4e" translate="yes" xml:space="preserve">
          <source>Configuration for most built-in data types are supported: &lt;code&gt;:atom&lt;/code&gt;, &lt;code&gt;:string&lt;/code&gt;, &lt;code&gt;:binary&lt;/code&gt;, &lt;code&gt;:list&lt;/code&gt;, &lt;code&gt;:number&lt;/code&gt;, &lt;code&gt;:boolean&lt;/code&gt;, &lt;code&gt;:nil&lt;/code&gt;, etc. The default is:</source>
          <target state="translated">대부분의 내장 데이터 유형에 대한 구성이 지원됩니다 : &lt;code&gt;:atom&lt;/code&gt; , &lt;code&gt;:string&lt;/code&gt; , &lt;code&gt;:binary&lt;/code&gt; , &lt;code&gt;:list&lt;/code&gt; , &lt;code&gt;:number&lt;/code&gt; , &lt;code&gt;:boolean&lt;/code&gt; , &lt;code&gt;:nil&lt;/code&gt; 등. 기본값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35d5425d04246c4803ef5cf5e8d025d35dd3c648" translate="yes" xml:space="preserve">
          <source>Configures ExUnit.</source>
          <target state="translated">ExUnit을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="f86ca4f2497f02577bc94a87775d8f36d626720d" translate="yes" xml:space="preserve">
          <source>Configures IEx.</source>
          <target state="translated">IEx를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="39aba670500b643a046792d3d15815451b7382dd" translate="yes" xml:space="preserve">
          <source>Configures the given &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;root_key&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;root_key&lt;/code&gt; 에 대해 지정된 &lt;code&gt;key&lt;/code&gt; 를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="dab905aea9ce47c3e8e30630f4f6fdec7eafa472" translate="yes" xml:space="preserve">
          <source>Configures the given &lt;code&gt;root_key&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;root_key&lt;/code&gt; 를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="931f9f9842f89caae33a5520f0561b2c38a9e395" translate="yes" xml:space="preserve">
          <source>Configures the given backend.</source>
          <target state="translated">주어진 백엔드를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="f7ca95cd7d184c9f425b7a30f220923f9cfac8a1" translate="yes" xml:space="preserve">
          <source>Configures the logger.</source>
          <target state="translated">로거를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="2d88aa7d5d042401a88814d3d2e345c7830e2a8f" translate="yes" xml:space="preserve">
          <source>Configuring releases</source>
          <target state="translated">릴리스 구성</target>
        </trans-unit>
        <trans-unit id="7297dda9d64e28b97aa3fde0b781b550726677f6" translate="yes" xml:space="preserve">
          <source>Configuring the shell</source>
          <target state="translated">쉘 구성</target>
        </trans-unit>
        <trans-unit id="480ea81ed58de6247a0cec11d6c975007208ce9e" translate="yes" xml:space="preserve">
          <source>Connecting an Elixir shell to a remote node without Elixir is &lt;strong&gt;not&lt;/strong&gt; supported.</source>
          <target state="translated">Elixir없이 원격 노드에 Elixir 쉘을 연결하는 &lt;strong&gt;것은&lt;/strong&gt; 지원 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c0f664a4d1ec0a9ec3a687038c62cd4690e15c63" translate="yes" xml:space="preserve">
          <source>Consider a new application &lt;code&gt;:my_app&lt;/code&gt;. &lt;code&gt;:my_app&lt;/code&gt; contains a database engine which supports a pool of databases. The database engine needs to know the configuration for each of those databases, and that configuration is supplied by key-value pairs in environment of &lt;code&gt;:my_app&lt;/code&gt;.</source>
          <target state="translated">새로운 응용 프로그램 인 &lt;code&gt;:my_app&lt;/code&gt; 고려하십시오 . &lt;code&gt;:my_app&lt;/code&gt; 에는 데이터베이스 풀을 지원하는 데이터베이스 엔진이 포함되어 있습니다. 데이터베이스 엔진은 해당 데이터베이스 각각에 대한 구성을 알아야하며 해당 구성은 &lt;code&gt;:my_app&lt;/code&gt; 환경에서 키-값 쌍으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="d7f69e049d11cfea430a186ac01ffac1bca0cfc8" translate="yes" xml:space="preserve">
          <source>Consider the following example:</source>
          <target state="translated">다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3d212d623893215a5c1ab44a4dc949acff16e8f9" translate="yes" xml:space="preserve">
          <source>Consider the implementation below:</source>
          <target state="translated">아래 구현을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7a7b310d2495e484fea1ff460e80d2fdad0204cf" translate="yes" xml:space="preserve">
          <source>Consider these two examples:</source>
          <target state="translated">다음 두 가지 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2b2d8a64936d851f0d73e6380decdfbb4b3fdb12" translate="yes" xml:space="preserve">
          <source>Consider using &lt;a href=&quot;task.supervisor#async_stream/6&quot;&gt;&lt;code&gt;Task.Supervisor.async_stream/6&lt;/code&gt;&lt;/a&gt; to start tasks under a supervisor. If you find yourself trapping exits to handle exits inside the async stream, consider using &lt;a href=&quot;task.supervisor#async_stream_nolink/6&quot;&gt;&lt;code&gt;Task.Supervisor.async_stream_nolink/6&lt;/code&gt;&lt;/a&gt; to start tasks that are not linked to the calling process.</source>
          <target state="translated">&lt;a href=&quot;task.supervisor#async_stream/6&quot;&gt; &lt;code&gt;Task.Supervisor.async_stream/6&lt;/code&gt; &lt;/a&gt; 을 사용하여 수퍼바이저에서 작업을 시작하십시오. 비동기 스트림 내부에서 엑시트를 처리하기 위해 엑시트를 트래핑하는 것이 발견되면 &lt;a href=&quot;task.supervisor#async_stream_nolink/6&quot;&gt; &lt;code&gt;Task.Supervisor.async_stream_nolink/6&lt;/code&gt; &lt;/a&gt; 을 사용 하여 호출 프로세스에 링크되지 않은 태스크를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="6430b20394a2b43032f0df564046ae9e5ed61c04" translate="yes" xml:space="preserve">
          <source>Considers the next break as fit.</source>
          <target state="translated">다음 휴식이 맞는 것으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="39cbdd33812e96a59909005452966168ffe901bd" translate="yes" xml:space="preserve">
          <source>Console backend</source>
          <target state="translated">콘솔 백엔드</target>
        </trans-unit>
        <trans-unit id="81ff41187d9a55a0a0d410b37e2a03ec4014258e" translate="yes" xml:space="preserve">
          <source>Consolidation</source>
          <target state="translated">Consolidation</target>
        </trans-unit>
        <trans-unit id="781883259f97b814dbeb10bd2aa9654bde39c92f" translate="yes" xml:space="preserve">
          <source>Consolidation happens by changing the protocol &lt;code&gt;impl_for&lt;/code&gt; in the abstract format to have fast lookup rules. Usually the list of implementations to use during consolidation are retrieved with the help of &lt;a href=&quot;#extract_impls/2&quot;&gt;&lt;code&gt;extract_impls/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">빠른 검색 규칙을 갖도록 추상 형식으로 프로토콜 &lt;code&gt;impl_for&lt;/code&gt; 를 변경하면 통합이 발생합니다 . 일반적으로 통합 중에 사용할 구현 목록은 &lt;a href=&quot;#extract_impls/2&quot;&gt; &lt;code&gt;extract_impls/2&lt;/code&gt; &lt;/a&gt; 의 도움으로 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea5ee0077ba2637f156ee60a85375b364c21ab7b" translate="yes" xml:space="preserve">
          <source>Constructs such as &lt;code&gt;unless/2&lt;/code&gt;, &lt;code&gt;defmacro/2&lt;/code&gt;, &lt;code&gt;def/2&lt;/code&gt;, &lt;code&gt;defprotocol/2&lt;/code&gt;, and many others used throughout this getting started guide are implemented in pure Elixir, often as a macro. This means that the constructs being used to build the language can be used by developers to extend the language to the domains they are working on.</source>
          <target state="translated">같은 구조 &lt;code&gt;unless/2&lt;/code&gt; , &lt;code&gt;defmacro/2&lt;/code&gt; , &lt;code&gt;def/2&lt;/code&gt; , &lt;code&gt;defprotocol/2&lt;/code&gt; ,이 시작 설명서에서 사용되는 많은 사람들은 종종 매크로로, 순수 비약에서 구현됩니다. 이는 개발자가 언어를 빌드하는 데 사용되는 구문을 사용하여 작업중인 도메인으로 언어를 확장 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f06815eccc7951b7a3293862d553938e6057b7dd" translate="yes" xml:space="preserve">
          <source>Consult &lt;a href=&quot;https://hexdocs.pm/elixir/guards.html&quot;&gt;the full documentation for guards&lt;/a&gt; for more information about guards, how they are used, and what expressions are allowed in them.</source>
          <target state="translated">가드, 가드 사용 방법 및 어떤 표현이 허용되는지에 대한 자세한 내용은 가드 &lt;a href=&quot;https://hexdocs.pm/elixir/guards.html&quot;&gt;전체 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cc11b3a28fa30ae6d3d3ad1438824cbd5224ba5c" translate="yes" xml:space="preserve">
          <source>Context</source>
          <target state="translated">Context</target>
        </trans-unit>
        <trans-unit id="1bbfd156f85e030d051094c906e097817e15b4d1" translate="yes" xml:space="preserve">
          <source>Continues execution of the current process.</source>
          <target state="translated">현재 프로세스의 실행을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="9cf96af56061f48b77f2ca372e437a5cbfd34ccd" translate="yes" xml:space="preserve">
          <source>Controls an IO device process that wraps a string.</source>
          <target state="translated">문자열을 래핑하는 IO 장치 프로세스를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="511bc588c44b169481c4ab2f5fa4baa6ea94d293" translate="yes" xml:space="preserve">
          <source>Convenience functions for defining supervisor specifications.</source>
          <target state="translated">감독자 사양을 정의하기위한 편의 기능.</target>
        </trans-unit>
        <trans-unit id="1896f8c1898ba69ed8398e4cd445925ae4014f8a" translate="yes" xml:space="preserve">
          <source>Convenience functions for working with atoms.</source>
          <target state="translated">원자로 작업하기위한 편의 기능.</target>
        </trans-unit>
        <trans-unit id="0dec42bbf61a109359c91148d0509bd563207899" translate="yes" xml:space="preserve">
          <source>Convenience to get the path relative to the current working directory.</source>
          <target state="translated">현재 작업 디렉토리에 상대적인 경로를 얻는 편의성.</target>
        </trans-unit>
        <trans-unit id="9398c3d1709bffcf5ee58dc22ca7bba010067260" translate="yes" xml:space="preserve">
          <source>Conveniences for formatting data for logs.</source>
          <target state="translated">로그의 데이터 형식화 편의.</target>
        </trans-unit>
        <trans-unit id="ac8dec653917d71f3e1fde2e3774b6870ed89c0c" translate="yes" xml:space="preserve">
          <source>Conveniences for spawning and awaiting tasks.</source>
          <target state="translated">작업 생성 및 대기를위한 편의성.</target>
        </trans-unit>
        <trans-unit id="11a944db3534dab5708e3a3090c3d296632e9d28" translate="yes" xml:space="preserve">
          <source>Conveniences for working with macros.</source>
          <target state="translated">매크로 작업을위한 편의성.</target>
        </trans-unit>
        <trans-unit id="58e5e941c629021c4446da1893e95f1f6661c6be" translate="yes" xml:space="preserve">
          <source>Conveniences for working with processes and the process dictionary.</source>
          <target state="translated">프로세스 및 프로세스 사전에 대한 작업 편의성.</target>
        </trans-unit>
        <trans-unit id="2bb0c4c90fda78018fef946d3af1057c1a6f7f6f" translate="yes" xml:space="preserve">
          <source>Conveniently, Elixir allows developers to hide modules and functions from the documentation, by setting &lt;code&gt;@doc false&lt;/code&gt; to hide a particular function, or &lt;code&gt;@moduledoc false&lt;/code&gt; to hide the whole module. If a module is hidden, you may even document the functions in the module, but the module itself won't be listed in the documentation:</source>
          <target state="translated">편리하게 Elixir를 사용하면 개발자가 &lt;code&gt;@doc false&lt;/code&gt; 를 설정 하여 특정 기능 을 숨기 거나 &lt;code&gt;@moduledoc false&lt;/code&gt; 를 설정하여 전체 모듈을 숨겨 문서에서 모듈과 기능을 숨길 수 있습니다 . 모듈이 숨겨져 있으면 모듈의 기능을 문서화 할 수도 있지만 모듈 자체는 설명서에 나와 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="734c112fb013ffbcab9477e1420f148661879dd3" translate="yes" xml:space="preserve">
          <source>Converts &lt;a href=&quot;#t:day_fraction/0&quot;&gt;&lt;code&gt;day_fraction/0&lt;/code&gt;&lt;/a&gt; to the Calendar's time format.</source>
          <target state="translated">&lt;a href=&quot;#t:day_fraction/0&quot;&gt; &lt;code&gt;day_fraction/0&lt;/code&gt; &lt;/a&gt; 을 달력의 시간 형식으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="c263dea4a8926f236fd6cf885211f470d0040f25" translate="yes" xml:space="preserve">
          <source>Converts &lt;a href=&quot;#t:iso_days/0&quot;&gt;&lt;code&gt;iso_days/0&lt;/code&gt;&lt;/a&gt; to the Calendar's datetime format.</source>
          <target state="translated">&lt;a href=&quot;#t:iso_days/0&quot;&gt; &lt;code&gt;iso_days/0&lt;/code&gt; &lt;/a&gt; 을 달력의 날짜 / 시간 형식으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="2c5350eabc852769f746830f4fbed1c2624db80b" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;enumerable&lt;/code&gt; to a list.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 목록 으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="a74487f27205428d15f0451bc0d11babd1e1ca88" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;map&lt;/code&gt; to a list.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 를 목록으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="7f76385606d85b29a0ecab53642a1b53c3fb2af8" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;map_set&lt;/code&gt; to a list.</source>
          <target state="translated">&lt;code&gt;map_set&lt;/code&gt; 을 목록으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="b4037010ef8b8f68c53234550440e37ebcec11b4" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;term&lt;/code&gt; into an algebra document.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 을 대수 문서로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="2239811e8691306d987c87bb035ec0e285472797" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;term&lt;/code&gt; to a charlist.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 를 문자 목록으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="9282cdf0f052d8c88bcaf95a8ca087cb35fb7850" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;term&lt;/code&gt; to a string.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 를 문자열로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="dcced501d6c07a24ff93c483518b8cc2d151f569" translate="yes" xml:space="preserve">
          <source>Converts &lt;code&gt;time&lt;/code&gt; from time unit &lt;code&gt;from_unit&lt;/code&gt; to time unit &lt;code&gt;to_unit&lt;/code&gt;.</source>
          <target state="translated">변환 &lt;code&gt;time&lt;/code&gt; 시간 단위에서 &lt;code&gt;from_unit&lt;/code&gt; 시간 단위로 &lt;code&gt;to_unit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b45c5892f77b48c1c88133c4a37df2e1f1e3aa7" translate="yes" xml:space="preserve">
          <source>Converts IO data into a binary</source>
          <target state="translated">IO 데이터를 이진수로 변환</target>
        </trans-unit>
        <trans-unit id="1e80e49bd371488057e5eccaf5915dabe9cfd4b5" translate="yes" xml:space="preserve">
          <source>Converts a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; into &lt;a href=&quot;time&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;time&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; 으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="79f2b0486144a184da614f47d1d9aa5bd5c88b86" translate="yes" xml:space="preserve">
          <source>Converts a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="0e51af90c033ac5546b2570c303b594fb7ef386c" translate="yes" xml:space="preserve">
          <source>Converts a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;File.Stat&lt;/code&gt;&lt;/a&gt; struct to a &lt;code&gt;:file_info&lt;/code&gt; record.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;File.Stat&lt;/code&gt; &lt;/a&gt; 구조체를 &lt;code&gt;:file_info&lt;/code&gt; 레코드 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="e71a4386d83ce453a946bfe6a893f35063f07d35" translate="yes" xml:space="preserve">
          <source>Converts a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; into &lt;a href=&quot;time&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;time&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; 으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="83028e5e704a1dc83086bc5f2000e97670618390" translate="yes" xml:space="preserve">
          <source>Converts a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; into a &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="2f9f5e5dfb5e1f309523442b6a2bb70c25fa00ad" translate="yes" xml:space="preserve">
          <source>Converts a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; struct to an Erlang datetime tuple.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 구조체를 Erlang 날짜 / 시간 튜플로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="8719af2c72dba20a75e23d17b6bea44825e5d5d1" translate="yes" xml:space="preserve">
          <source>Converts a &lt;code&gt;:file_info&lt;/code&gt; record into a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;File.Stat&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">A는 변환 &lt;code&gt;:file_info&lt;/code&gt; 에 기록 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;File.Stat&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2727fee5122159fbc0af23661dab2ef0c9c2631" translate="yes" xml:space="preserve">
          <source>Converts a &lt;code&gt;struct&lt;/code&gt; to map.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; 를 맵으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="254bf8d1b281f322924363fb1a83ad9e2361d7e3" translate="yes" xml:space="preserve">
          <source>Converts a charlist to an atom.</source>
          <target state="translated">charlist를 원자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e68efbd247250deb02e7332f2af7b7b7a3149d56" translate="yes" xml:space="preserve">
          <source>Converts a charlist to an existing atom. Raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if the atom does not exist.</source>
          <target state="translated">문자 목록을 기존 원자로 변환합니다. 발생시킵니다 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 원자가 존재하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="0a5d5cd9b05db0c45b6438328ca412df82f34ace" translate="yes" xml:space="preserve">
          <source>Converts a day fraction to this Calendar's representation of time.</source>
          <target state="translated">요일을이 달력의 시간 표현으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="0e54c7b2dbe83fdf26bac6202e532577515f8965" translate="yes" xml:space="preserve">
          <source>Converts a given &lt;code&gt;datetime&lt;/code&gt; from one calendar to another.</source>
          <target state="translated">주어진 &lt;code&gt;datetime&lt;/code&gt; 을 한 달력에서 다른 달력으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="d8dc043a8b2c88ab996fe2e13bf007f26909078f" translate="yes" xml:space="preserve">
          <source>Converts a list of integers representing code points, lists or strings into a charlist.</source>
          <target state="translated">코드 포인트, 목록 또는 문자열을 나타내는 정수 목록을 문자 목록으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="6e5cc0b47448c4c5bcff4e00375ab0e486ccf2c4" translate="yes" xml:space="preserve">
          <source>Converts a list of integers representing code points, lists or strings into a string.</source>
          <target state="translated">코드 포인트, 목록 또는 문자열을 나타내는 정수 목록을 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c987e9c958f5bc59b13e956f62b766e68b6fe8f4" translate="yes" xml:space="preserve">
          <source>Converts a list to a tuple.</source>
          <target state="translated">리스트를 터플로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="02dde49cf9a6a46064141cae9a87851199d4ae33" translate="yes" xml:space="preserve">
          <source>Converts a string into a charlist.</source>
          <target state="translated">문자열을 charlist로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="947ec7e9bf96de02e99903966169c97ef903b0be" translate="yes" xml:space="preserve">
          <source>Converts a string to an atom.</source>
          <target state="translated">문자열을 원자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="780538ea266d284ab56b9dc3c29cf37ce27a4b0f" translate="yes" xml:space="preserve">
          <source>Converts a string to an existing atom.</source>
          <target state="translated">문자열을 기존 원자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b5a8ad6e165d7ed1c7615d02f03e2dbeea23252b" translate="yes" xml:space="preserve">
          <source>Converts a tuple to a list.</source>
          <target state="translated">튜플을 목록으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="13453b8d1508b3203babeb1e62e12b28c32edc34" translate="yes" xml:space="preserve">
          <source>Converts all characters in &lt;code&gt;string&lt;/code&gt; to Unicode normalization form identified by &lt;code&gt;form&lt;/code&gt;.</source>
          <target state="translated">모든 문자로 변환 &lt;code&gt;string&lt;/code&gt; 로 식별 유니 코드 정규화 형태로 &lt;code&gt;form&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9b6510ebfe5cd9b4636c09de47097a06fbbf94e" translate="yes" xml:space="preserve">
          <source>Converts all characters in the given string to lowercase according to &lt;code&gt;mode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 에 따라 주어진 문자열의 모든 문자를 소문자로 변환 합니다 .</target>
        </trans-unit>
        <trans-unit id="27176c2f820ec7f891716f0f78755c8187c887d6" translate="yes" xml:space="preserve">
          <source>Converts all characters in the given string to uppercase according to &lt;code&gt;mode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 에 따라 지정된 문자열의 모든 문자를 대문자로 변환 합니다 .</target>
        </trans-unit>
        <trans-unit id="197e6c77a16aeec861dffc2a445548a230c5e211" translate="yes" xml:space="preserve">
          <source>Converts an Elixir term to an algebra document according to the &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol.</source>
          <target state="translated">&lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; 프로토콜 에 따라 Elixir 항을 대수 문서로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="ad1541b2455219564d77382ed7fe2e73581b2fa4" translate="yes" xml:space="preserve">
          <source>Converts an Erlang date tuple but raises for invalid dates.</source>
          <target state="translated">Erlang 날짜 튜플을 변환하지만 유효하지 않은 날짜를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="6237472326aa97d4d91dbe7ea3d8a7f40e943982" translate="yes" xml:space="preserve">
          <source>Converts an Erlang date tuple to a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Erlang 날짜 튜플을 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 구조체 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="0dc925bdd2a6249b07fa9efae38dfa76258fa019" translate="yes" xml:space="preserve">
          <source>Converts an Erlang datetime tuple to a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Erlang 날짜 / 시간 튜플을 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 구조체 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="8dd9ae9ebd84083585be7487d706b7eaa52e69ec" translate="yes" xml:space="preserve">
          <source>Converts an Erlang time tuple to a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">Erlang 시간 터플을 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; 구조체 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="d582318b9473f2734864958a0821294f01f1b66d" translate="yes" xml:space="preserve">
          <source>Converts an atom to a charlist.</source>
          <target state="translated">원자를 charlist로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="7fa16e00cee3fcccbfdea7311d60ada14e4f260e" translate="yes" xml:space="preserve">
          <source>Converts an atom to a string.</source>
          <target state="translated">원자를 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e841d0667d5d6ef74ab9e5853d985c4cea6b18cc" translate="yes" xml:space="preserve">
          <source>Converts chardata into a string.</source>
          <target state="translated">chardata를 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="a145202abf06e7ca92dcbfc3594ac19f06cf61b5" translate="yes" xml:space="preserve">
          <source>Converts given &lt;code&gt;time&lt;/code&gt; to a different calendar.</source>
          <target state="translated">주어진 &lt;code&gt;time&lt;/code&gt; 을 다른 달력으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="60bf168f1407388298d9b210e72535da75765532" translate="yes" xml:space="preserve">
          <source>Converts given &lt;code&gt;time&lt;/code&gt; to an Erlang time tuple.</source>
          <target state="translated">주어진 &lt;code&gt;time&lt;/code&gt; 을 Erlang 시간 튜플로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="3ac0da74aab610cfdee319e397f52884c7cca511" translate="yes" xml:space="preserve">
          <source>Converts the &lt;a href=&quot;calendar#t:iso_days/0&quot;&gt;&lt;code&gt;Calendar.iso_days/0&lt;/code&gt;&lt;/a&gt; format to the datetime format specified by this calendar.</source>
          <target state="translated">&lt;a href=&quot;calendar#t:iso_days/0&quot;&gt; &lt;code&gt;Calendar.iso_days/0&lt;/code&gt; &lt;/a&gt; 형식을이 달력으로 지정된 날짜 / 시간 형식으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="4b6111172b0ba4063d262291c6c3b2b09eac09ae" translate="yes" xml:space="preserve">
          <source>Converts the IO &lt;code&gt;device&lt;/code&gt; into an &lt;a href=&quot;io.stream&quot;&gt;&lt;code&gt;IO.Stream&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">IO &lt;code&gt;device&lt;/code&gt; 를 &lt;a href=&quot;io.stream&quot;&gt; &lt;code&gt;IO.Stream&lt;/code&gt; &lt;/a&gt; 으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="4e89484d19f8b391081fcfbf11774ccd7e0029f8" translate="yes" xml:space="preserve">
          <source>Converts the IO &lt;code&gt;device&lt;/code&gt; into an &lt;a href=&quot;io.stream&quot;&gt;&lt;code&gt;IO.Stream&lt;/code&gt;&lt;/a&gt;. The operation is Unicode unsafe.</source>
          <target state="translated">IO &lt;code&gt;device&lt;/code&gt; 를 &lt;a href=&quot;io.stream&quot;&gt; &lt;code&gt;IO.Stream&lt;/code&gt; &lt;/a&gt; 으로 변환합니다 . 작업이 유니 코드 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8e6e16de8acf03faa5a8b241195a52aa4b1e29e" translate="yes" xml:space="preserve">
          <source>Converts the argument to a string according to the &lt;a href=&quot;string.chars&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol.</source>
          <target state="translated">&lt;a href=&quot;string.chars&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt; 프로토콜 에 따라 인수를 문자열로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="5b8fbdf0a0fa574e14e63c37f6a8ef88b3232cef" translate="yes" xml:space="preserve">
          <source>Converts the date into a string according to the calendar.</source>
          <target state="translated">달력에 따라 날짜를 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="227b186ae0acc44776906432dd066fbe4fde8846" translate="yes" xml:space="preserve">
          <source>Converts the datetime (with time zone) into a string according to the calendar.</source>
          <target state="translated">달력에 따라 날짜 시간 (시간대 포함)을 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="92e2c5a23650305fee01a1fcd9a57ab26fc28d72" translate="yes" xml:space="preserve">
          <source>Converts the datetime (with time zone) into a string.</source>
          <target state="translated">날짜 시간 (시간대 포함)을 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e1625d9cdfd25143785b1fa11bbd89706012c4af" translate="yes" xml:space="preserve">
          <source>Converts the datetime (without time zone) into a string according to the calendar.</source>
          <target state="translated">달력에 따라 날짜 시간을 표준 시간대없이 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="717185aa13daa78bdde43f04c886115fa0e73941" translate="yes" xml:space="preserve">
          <source>Converts the datetime (without time zone) into a string.</source>
          <target state="translated">시간대가없는 날짜 시간을 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="a2abe353af0045108936797a9195af1772dfd552" translate="yes" xml:space="preserve">
          <source>Converts the first character in the given string to uppercase and the remainder to lowercase according to &lt;code&gt;mode&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 에 따라 주어진 문자열의 첫 문자를 대문자로, 나머지를 소문자로 변환 합니다 .</target>
        </trans-unit>
        <trans-unit id="d4564c56ea18e08e51a07042222eb171cff78504" translate="yes" xml:space="preserve">
          <source>Converts the given &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 &lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 으로&lt;/a&gt; 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="21e264a9524cd6e7dc80e416d4e36f478333a439" translate="yes" xml:space="preserve">
          <source>Converts the given &lt;code&gt;date&lt;/code&gt; from its calendar to the given &lt;code&gt;calendar&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;date&lt;/code&gt; 를 달력에서 주어진 &lt;code&gt;calendar&lt;/code&gt; 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="030c0774d22f233ba42fb12f10a1a70296d43037" translate="yes" xml:space="preserve">
          <source>Converts the given &lt;code&gt;date&lt;/code&gt; to &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601:2004&lt;/a&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;date&lt;/code&gt; 를 &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601 : 2004&lt;/a&gt; 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="f6c9bebf617d290f961736311cefb7f89e429aa0" translate="yes" xml:space="preserve">
          <source>Converts the given &lt;code&gt;date&lt;/code&gt; to an Erlang date tuple.</source>
          <target state="translated">주어진 &lt;code&gt;date&lt;/code&gt; 를 Erlang 날짜 튜플로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="90042dc24d2d96d4b3dd9984c599920efaec9579" translate="yes" xml:space="preserve">
          <source>Converts the given &lt;code&gt;datetime&lt;/code&gt; into a &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;datetime&lt;/code&gt; 을 &lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="38607d070d5886f0af38c1f08b0fc3fd52cfa931" translate="yes" xml:space="preserve">
          <source>Converts the given &lt;code&gt;datetime&lt;/code&gt; to Unix time.</source>
          <target state="translated">주어진 &lt;code&gt;datetime&lt;/code&gt; 을 유닉스 시간으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="e7713cd000f48f06c03b261c1ce2b54eeac3472c" translate="yes" xml:space="preserve">
          <source>Converts the given &lt;code&gt;datetime&lt;/code&gt; to a string according to its calendar.</source>
          <target state="translated">주어진 &lt;code&gt;datetime&lt;/code&gt; 을 달력에 따라 문자열로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="023233441b992e80b392f70911a5906ce4e0cba9" translate="yes" xml:space="preserve">
          <source>Converts the given &lt;code&gt;naive_datetime&lt;/code&gt; from one calendar to another.</source>
          <target state="translated">주어진 &lt;code&gt;naive_datetime&lt;/code&gt; 을 한 달력에서 다른 달력으로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="8ec6376d2a13e24a0141c11d23138342f5fbc8b0" translate="yes" xml:space="preserve">
          <source>Converts the given &lt;code&gt;time&lt;/code&gt; to a string.</source>
          <target state="translated">주어진 &lt;code&gt;time&lt;/code&gt; 을 문자열로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="5e23f4682b8833610adb0fd47c62bcd1fdcc4cd9" translate="yes" xml:space="preserve">
          <source>Converts the given Unix time to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정된 Unix 시간을 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 으로&lt;/a&gt; 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="612b4c3348db1df419a84869d47308c8a6a2a9d6" translate="yes" xml:space="preserve">
          <source>Converts the given atom or binary to underscore format.</source>
          <target state="translated">지정된 아톰 또는 이진을 밑줄 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e4c120019c6ce0243ca3ed4ef026a01e5af3d50a" translate="yes" xml:space="preserve">
          <source>Converts the given date into a string.</source>
          <target state="translated">주어진 날짜를 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="748850d792b313b153351dc3fad876e09a4a6167" translate="yes" xml:space="preserve">
          <source>Converts the given date to a string according to its calendar.</source>
          <target state="translated">달력에 따라 주어진 날짜를 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="580ca61be38d506e1fbabba1567234376f9fb67a" translate="yes" xml:space="preserve">
          <source>Converts the given datetime (without time zone) into the &lt;a href=&quot;#t:iso_days/0&quot;&gt;&lt;code&gt;iso_days/0&lt;/code&gt;&lt;/a&gt; format.</source>
          <target state="translated">주어진 날짜 / 시간을 표준 시간대없이 &lt;a href=&quot;#t:iso_days/0&quot;&gt; &lt;code&gt;iso_days/0&lt;/code&gt; &lt;/a&gt; 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4ac5ca644110fb9234b585f20da953fc40183d3a" translate="yes" xml:space="preserve">
          <source>Converts the given datetime to &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601:2004&lt;/a&gt; format.</source>
          <target state="translated">주어진 날짜 시간을 &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601 : 2004&lt;/a&gt; 형식으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="98e2af74ab4f811ebccb7dfd38e2983ea26bd505" translate="yes" xml:space="preserve">
          <source>Converts the given expression AST to a string.</source>
          <target state="translated">주어진 표현식 AST를 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="1a63c1aa4ca02493d9e3dc44717b50d2c6cdc341" translate="yes" xml:space="preserve">
          <source>Converts the given naive datetime to &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601:2004&lt;/a&gt;.</source>
          <target state="translated">주어진 순진 날짜 시간을 &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601 : 2004&lt;/a&gt; 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="228c1561eef12bb4d3d95a29c1441ec5a4be11f6" translate="yes" xml:space="preserve">
          <source>Converts the given naive datetime to a string according to its calendar.</source>
          <target state="translated">주어진 순진 날짜 시간을 달력에 따라 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c9286e3dd5d56cf4207fbf7300a7241dc950a591" translate="yes" xml:space="preserve">
          <source>Converts the given path to an absolute one. Unlike &lt;a href=&quot;#expand/1&quot;&gt;&lt;code&gt;expand/1&lt;/code&gt;&lt;/a&gt;, no attempt is made to resolve &lt;code&gt;..&lt;/code&gt;, &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">주어진 경로를 절대 경로로 변환합니다. 달리 &lt;a href=&quot;#expand/1&quot;&gt; &lt;code&gt;expand/1&lt;/code&gt; &lt;/a&gt; , 시도를 해결하기 위해 이루어지지 않습니다 &lt;code&gt;..&lt;/code&gt; , &lt;code&gt;.&lt;/code&gt; 또는 &lt;code&gt;~&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f7f5abb6efabe13737c9ca4626a86c8733407bd" translate="yes" xml:space="preserve">
          <source>Converts the given string to CamelCase format.</source>
          <target state="translated">주어진 문자열을 CamelCase 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="309d33e35d53f2e58eb95fc785af528ca7744f6d" translate="yes" xml:space="preserve">
          <source>Converts the given string to its quoted form.</source>
          <target state="translated">주어진 문자열을 인용 된 형식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="8bc0590b1dbce230536e4466653afeda26e0e2ec" translate="yes" xml:space="preserve">
          <source>Converts the given term to a charlist according to the &lt;a href=&quot;list.chars&quot;&gt;&lt;code&gt;List.Chars&lt;/code&gt;&lt;/a&gt; protocol.</source>
          <target state="translated">&lt;a href=&quot;list.chars&quot;&gt; &lt;code&gt;List.Chars&lt;/code&gt; &lt;/a&gt; 프로토콜 에 따라 주어진 용어를 charlist로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="c044a36802721d40a5b50ee9d1fca02b69813080" translate="yes" xml:space="preserve">
          <source>Converts the given time into a string.</source>
          <target state="translated">주어진 시간을 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="babee3dcd26752eb23edd13cb79aa04dd96a76e9" translate="yes" xml:space="preserve">
          <source>Converts the given time to &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601:2004&lt;/a&gt;.</source>
          <target state="translated">주어진 시간을 &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601 : 2004&lt;/a&gt; 로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="8c7a03767b5d1566df3d146e4fbaef558f6a1090" translate="yes" xml:space="preserve">
          <source>Converts the given time to the &lt;a href=&quot;#t:day_fraction/0&quot;&gt;&lt;code&gt;day_fraction/0&lt;/code&gt;&lt;/a&gt; format.</source>
          <target state="translated">주어진 시간을 &lt;a href=&quot;#t:day_fraction/0&quot;&gt; &lt;code&gt;day_fraction/0&lt;/code&gt; &lt;/a&gt; 형식으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="8bef9301d9edb5e35de1e260e607e1823667132d" translate="yes" xml:space="preserve">
          <source>Converts the path to an absolute one and expands any &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;..&lt;/code&gt; characters and a leading &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">경로를 절대 경로로 변환하고 any를 확장합니다 &lt;code&gt;.&lt;/code&gt; 그리고 &lt;code&gt;..&lt;/code&gt; 문자와 선행 &lt;code&gt;~&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23415e661cc9d41a024959347984730e2601bed2" translate="yes" xml:space="preserve">
          <source>Converts the time into a string according to the calendar.</source>
          <target state="translated">달력에 따라 시간을 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="0a49d0c8f3285f335233220c5993daacbad3d3a5" translate="yes" xml:space="preserve">
          <source>Copies the contents in &lt;code&gt;source&lt;/code&gt; to &lt;code&gt;destination&lt;/code&gt; recursively, maintaining the source directory structure and modes.</source>
          <target state="translated">소스 디렉토리 구조 및 모드를 유지하면서 &lt;code&gt;source&lt;/code&gt; 의 내용 을 &lt;code&gt;destination&lt;/code&gt; 재귀 적으로 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="abf53458642b38d338f60c6e1bf1d5064dfd444e" translate="yes" xml:space="preserve">
          <source>Copies the contents in &lt;code&gt;source_file&lt;/code&gt; to &lt;code&gt;destination_file&lt;/code&gt; preserving its modes.</source>
          <target state="translated">에 복사 내용을 &lt;code&gt;source_file&lt;/code&gt; 는 하기 &lt;code&gt;destination_file&lt;/code&gt; 의 모드를 유지.</target>
        </trans-unit>
        <trans-unit id="e3e9a52265052fb7c4cbfaaee0f1c813d805b775" translate="yes" xml:space="preserve">
          <source>Copies the contents of &lt;code&gt;source&lt;/code&gt; to &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 의 내용 을 &lt;code&gt;destination&lt;/code&gt; 복사합니다 .</target>
        </trans-unit>
        <trans-unit id="fb042f0b0cf7bbae523e4db50401acd89b538c94" translate="yes" xml:space="preserve">
          <source>Copies the given spec as a callback.</source>
          <target state="translated">지정된 스펙을 콜백으로 복사합니다.</target>
        </trans-unit>
        <trans-unit id="5bd5c22751074967a6095132bfee44e6a2f51436" translate="yes" xml:space="preserve">
          <source>Count the code points in each string asynchronously, then add the counts together using reduce.</source>
          <target state="translated">각 문자열의 코드 포인트를 비동기 적으로 계산 한 다음 reduce를 사용하여 카운트를 더합니다.</target>
        </trans-unit>
        <trans-unit id="80e13549b47a4dfc6e898a282920091b209c78be" translate="yes" xml:space="preserve">
          <source>Coverage</source>
          <target state="translated">Coverage</target>
        </trans-unit>
        <trans-unit id="028ea82f8e6a71263262972962b3eb339200a07d" translate="yes" xml:space="preserve">
          <source>Create a file at &lt;code&gt;lib/kv/router.ex&lt;/code&gt; with the following contents:</source>
          <target state="translated">&lt;code&gt;lib/kv/router.ex&lt;/code&gt; 에 다음 내용 으로 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ef2cd8271ebb73d84add4da7d468bc9403cf8d4" translate="yes" xml:space="preserve">
          <source>Create a file at &lt;code&gt;test/kv/bucket_test.exs&lt;/code&gt; (remember the &lt;code&gt;.exs&lt;/code&gt; extension) with the following:</source>
          <target state="translated">다음과 같이 &lt;code&gt;test/kv/bucket_test.exs&lt;/code&gt; ( &lt;code&gt;.exs&lt;/code&gt; 확장자 기억)에 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a8070c19ec35f828badfb0971876a3836aa01640" translate="yes" xml:space="preserve">
          <source>Create a new file at &lt;code&gt;lib/kv/registry.ex&lt;/code&gt; with the following contents:</source>
          <target state="translated">&lt;code&gt;lib/kv/registry.ex&lt;/code&gt; 에 다음 내용 으로 새 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="4d096b85c273e9bc8931277d2ffdc25ab305cfa5" translate="yes" xml:space="preserve">
          <source>Creates a PID from &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 에서 PID를 작성 합니다 .</target>
        </trans-unit>
        <trans-unit id="17c20052fb303436bdb11d8899b481f14df4590c" translate="yes" xml:space="preserve">
          <source>Creates a PID with 3 non-negative integers passed as arguments to the function.</source>
          <target state="translated">함수에 인수로 전달 된 음이 아닌 3 개의 정수로 PID를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="4ccd0821086d4ce314a99c2b1ec5d27e4161dbd2" translate="yes" xml:space="preserve">
          <source>Creates a Port from &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 에서 포트를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="95deb48dcab4fa865482dbf5af752daa124b8bc8" translate="yes" xml:space="preserve">
          <source>Creates a Port from two non-negative integers.</source>
          <target state="translated">음이 아닌 두 정수로 포트를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="65524decb6cf29f2e8ddd1d1ebc67371ef0050b6" translate="yes" xml:space="preserve">
          <source>Creates a Reference from &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 으로부터 참조를 작성 합니다 .</target>
        </trans-unit>
        <trans-unit id="80e84c042a84564fb45d3e4ea04bdde0d79343e7" translate="yes" xml:space="preserve">
          <source>Creates a Reference from its 4 non-negative integers components.</source>
          <target state="translated">음이 아닌 4 개의 정수 구성 요소에서 참조를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="72a773275c1891d62c509356c702ed500fd44357" translate="yes" xml:space="preserve">
          <source>Creates a document represented by string.</source>
          <target state="translated">문자열로 표시되는 문서를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a25ffa072c9b4497ffa77caddb84e10a12c4fece" translate="yes" xml:space="preserve">
          <source>Creates a hard link &lt;code&gt;new&lt;/code&gt; to the file &lt;code&gt;existing&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;existing&lt;/code&gt; 파일에 &lt;code&gt;new&lt;/code&gt; 하드 링크를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="498fc9088eefd0b5d1f1097ae8face4e13b2235a" translate="yes" xml:space="preserve">
          <source>Creates a keyword list from an enumerable via the transformation function.</source>
          <target state="translated">변환 함수를 통해 열거 가능한 키워드 목록을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0cf02892cb76f3bfd617a2b9b66aa2c84f3221a2" translate="yes" xml:space="preserve">
          <source>Creates a keyword list from an enumerable.</source>
          <target state="translated">열거 가능한 키워드 목록에서 키워드 목록을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="484073e0a88950e889b7cb4cdaaff39cb41a7044" translate="yes" xml:space="preserve">
          <source>Creates a link between the calling process and the given item (process or port).</source>
          <target state="translated">호출 프로세스와 주어진 항목 (프로세스 또는 포트) 사이에 링크를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="3845ba5590ad3018c23c28e5c890fa7cb6ca6f20" translate="yes" xml:space="preserve">
          <source>Creates a map from an &lt;code&gt;enumerable&lt;/code&gt; via the given transformation function.</source>
          <target state="translated">주어진 변환 함수를 통해 &lt;code&gt;enumerable&lt;/code&gt; 맵에서 맵을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1f569ea7402f94a429015887b7617e16fc743562" translate="yes" xml:space="preserve">
          <source>Creates a map from an &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 맵에서지도를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="ce89e48193f46f044fa2d633cfe5156548be0642" translate="yes" xml:space="preserve">
          <source>Creates a map.</source>
          <target state="translated">지도를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bca0cb06c3c10839d539f0c9df1de4a58a5af887" translate="yes" xml:space="preserve">
          <source>Creates a module with the given name and defined by the given quoted expressions.</source>
          <target state="translated">주어진 이름으로 모듈을 만들고 인용 된 표현식으로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f6fb16ff7d235494c11327d98497f4cf281e95fe" translate="yes" xml:space="preserve">
          <source>Creates a new empty dict.</source>
          <target state="translated">새로운 빈 받아쓰기를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1c9315ba3d69260c14b757669db279c4b74f54d8" translate="yes" xml:space="preserve">
          <source>Creates a new range.</source>
          <target state="translated">새로운 범위를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a2eba7b5cc42b2afd7e58fcb27cbf5d6f7a5f7b2" translate="yes" xml:space="preserve">
          <source>Creates a new tuple.</source>
          <target state="translated">새로운 튜플을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7d7a85ef1ed1803d92c9416ace3552ee52d3a318" translate="yes" xml:space="preserve">
          <source>Creates a set from an enumerable via the transformation function.</source>
          <target state="translated">변형 함수를 통해 열거 가능한 집합에서 집합을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c912e955c1e13f472af8b11a6e720fa581a82ea3" translate="yes" xml:space="preserve">
          <source>Creates a set from an enumerable.</source>
          <target state="translated">열거 형에서 세트를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="92c9b57f1e2cecc049ffa0a17491ad60c9aea49d" translate="yes" xml:space="preserve">
          <source>Creates a stream that applies the given function to each element, emits the result and uses the same result as the accumulator for the next computation. Uses the first element in the enumerable as the starting value.</source>
          <target state="translated">주어진 함수를 각 요소에 적용하고 결과를 내 보낸 후 다음 계산에 대한 누산기와 동일한 결과를 사용하는 스트림을 만듭니다. 열거 가능한 첫 번째 요소를 시작 값으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3febf59f90e67bb54f793ba91dfddfb75ca065cb" translate="yes" xml:space="preserve">
          <source>Creates a stream that applies the given function to each element, emits the result and uses the same result as the accumulator for the next computation. Uses the given &lt;code&gt;acc&lt;/code&gt; as the starting value.</source>
          <target state="translated">주어진 함수를 각 요소에 적용하고 결과를 내 보낸 후 다음 계산에 대한 누산기와 동일한 결과를 사용하는 스트림을 만듭니다. 주어진 &lt;code&gt;acc&lt;/code&gt; 를 시작 값으로 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="368eb7731010419d3d1b8a5fa0a96992f65548c6" translate="yes" xml:space="preserve">
          <source>Creates a stream that cycles through the given enumerable, infinitely.</source>
          <target state="translated">주어진 열거 형을 무한정 순환하는 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="09a0edafbe5af88cdea45c406f8cf75648a29039" translate="yes" xml:space="preserve">
          <source>Creates a stream that drops every &lt;code&gt;nth&lt;/code&gt; element from the enumerable.</source>
          <target state="translated">열거 가능한 모든 &lt;code&gt;nth&lt;/code&gt; 요소 를 삭제하는 스트림을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a65e224893927d60f5f1aea1df74c6d4636b9d19" translate="yes" xml:space="preserve">
          <source>Creates a stream that emits a single value after &lt;code&gt;n&lt;/code&gt; milliseconds.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 밀리 초 후에 단일 값을 내보내는 스트림을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e7bf644491bc4caaaa2f9796f5b0a4de1a1168a3" translate="yes" xml:space="preserve">
          <source>Creates a stream that emits a value after the given period &lt;code&gt;n&lt;/code&gt; in milliseconds.</source>
          <target state="translated">지정된 기간 &lt;code&gt;n&lt;/code&gt; 이후 밀리 초 단위 로 값을 내보내는 스트림을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="6b1bf40efcd55deb62653b37917ef53710fe8a67" translate="yes" xml:space="preserve">
          <source>Creates a stream that enumerates each enumerable in an enumerable.</source>
          <target state="translated">열거 가능한 각 열거 가능한 열거하는 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1b7ed8a49c2a04606f29f4e01e9a43aba6e74367" translate="yes" xml:space="preserve">
          <source>Creates a stream that enumerates the first argument, followed by the second.</source>
          <target state="translated">첫 번째 인수와 두 번째 인수를 열거하는 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5de27bcf3f438e8e62f7ff655930f9a342d628f0" translate="yes" xml:space="preserve">
          <source>Creates a stream that filters elements according to the given function on enumeration.</source>
          <target state="translated">열거에 지정된 함수에 따라 요소를 필터링하는 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a292d4224debffe065f234930161932a5927780b" translate="yes" xml:space="preserve">
          <source>Creates a stream that only emits elements if the result of calling &lt;code&gt;fun&lt;/code&gt; on the element is different from the (stored) result of calling &lt;code&gt;fun&lt;/code&gt; on the last emitted element.</source>
          <target state="translated">호출의 결과 경우에만 발광 소자 스트림 생성 &lt;code&gt;fun&lt;/code&gt; 요소에 호출의 (저장) 결과 상이한 &lt;code&gt;fun&lt;/code&gt; 마지막 발광 소자에있다.</target>
        </trans-unit>
        <trans-unit id="58a5512f2444ff6976377bbee4eb5372d54fcd5c" translate="yes" xml:space="preserve">
          <source>Creates a stream that only emits elements if they are different from the last emitted element.</source>
          <target state="translated">요소가 마지막으로 방출 된 요소와 다른 경우에만 요소를 내보내는 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="962425bd297f3b883238978c7ce6a85a752c07fc" translate="yes" xml:space="preserve">
          <source>Creates a stream that only emits elements if they are unique, by removing the elements for which function &lt;code&gt;fun&lt;/code&gt; returned duplicate elements.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 함수가 중복 요소를 반환 한 요소를 제거하여 고유 한 경우에만 요소를 내보내는 스트림을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="cdde751cd26237ff05d16e7de6b337007018fc9a" translate="yes" xml:space="preserve">
          <source>Creates a stream that only emits elements if they are unique.</source>
          <target state="translated">요소가 고유 한 경우에만 요소를 내보내는 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="32be0a0b96ea6c99b90acb3b387e407fab509a1f" translate="yes" xml:space="preserve">
          <source>Creates a stream that takes every &lt;code&gt;nth&lt;/code&gt; element from the enumerable.</source>
          <target state="translated">열거 가능한 모든 &lt;code&gt;nth&lt;/code&gt; 요소 를 가져 오는 스트림을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="018a830e30f48f2abb4f6e375d5c3596f09ae1a1" translate="yes" xml:space="preserve">
          <source>Creates a stream that will apply the given function on enumeration.</source>
          <target state="translated">열거에 주어진 함수를 적용 할 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="52a5b372e2b712a7fcefd3796ad7bb8aa811e396" translate="yes" xml:space="preserve">
          <source>Creates a stream that will apply the given function on every &lt;code&gt;nth&lt;/code&gt; element from the enumerable.</source>
          <target state="translated">열거 가능한 모든 &lt;code&gt;nth&lt;/code&gt; 요소 에 지정된 함수를 적용 할 스트림을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a1c7db814b0f2d86987998b90fdbe81b3fe20363" translate="yes" xml:space="preserve">
          <source>Creates a stream that will reject elements according to the given function on enumeration.</source>
          <target state="translated">열거에 지정된 함수에 따라 요소를 거부하는 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d4e101ae0e59e353e2c11459f9cd83b9fb41375b" translate="yes" xml:space="preserve">
          <source>Creates a stream where each element in the enumerable will be wrapped in a tuple alongside its index.</source>
          <target state="translated">열거 가능한 각 요소가 색인과 함께 튜플로 래핑되는 스트림을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="794b74194468fc9dd669423522605922875647a9" translate="yes" xml:space="preserve">
          <source>Creates a symbolic link &lt;code&gt;new&lt;/code&gt; to the file or directory &lt;code&gt;existing&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;existing&lt;/code&gt; 파일 또는 디렉토리에 &lt;code&gt;new&lt;/code&gt; 심볼릭 링크를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="37d7b6cf67d4f7ee7f942e6b2de56067571c402e" translate="yes" xml:space="preserve">
          <source>Creates a tuple of &lt;code&gt;size&lt;/code&gt; containing the given &lt;code&gt;data&lt;/code&gt; at every position.</source>
          <target state="translated">모든 위치에서 주어진 &lt;code&gt;data&lt;/code&gt; 를 포함하는 &lt;code&gt;size&lt;/code&gt; 의 튜플을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="c12cdd291771a6531cab586dd7713827a9512c63" translate="yes" xml:space="preserve">
          <source>Creates a tuple.</source>
          <target state="translated">튜플을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="981204be793902bce796c0cf3f7b3ba3f28ef48b" translate="yes" xml:space="preserve">
          <source>Creates an IO device.</source>
          <target state="translated">IO 장치를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0c34079208451017d540c9fb615f1989d707408b" translate="yes" xml:space="preserve">
          <source>Creates and updates structs.</source>
          <target state="translated">구조체를 만들고 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="4b73576aa815a8d50bb5014bba09ef6ac2a8dadd" translate="yes" xml:space="preserve">
          <source>Creating Streams</source>
          <target state="translated">스트림 만들기</target>
        </trans-unit>
        <trans-unit id="9bf07eaecf55e49059496beb7aa95c4062a592c9" translate="yes" xml:space="preserve">
          <source>Creating a supervisor is not much different from creating a GenServer. We are going to define a module named &lt;code&gt;KV.Supervisor&lt;/code&gt;, which will use the Supervisor behaviour, inside the &lt;code&gt;lib/kv/supervisor.ex&lt;/code&gt; file:</source>
          <target state="translated">수퍼바이저 생성은 GenServer 생성과 크게 다르지 않습니다. &lt;code&gt;lib/kv/supervisor.ex&lt;/code&gt; 파일 내에서 Supervisor 동작을 사용할 &lt;code&gt;KV.Supervisor&lt;/code&gt; 라는 모듈을 정의하려고 합니다.</target>
        </trans-unit>
        <trans-unit id="89584c30004088bac7c1dae0caca5ec122b003e7" translate="yes" xml:space="preserve">
          <source>Crossed-out. Characters legible, but marked for deletion. Not widely supported.</source>
          <target state="translated">교차했습니다. 읽을 수 있지만 삭제 표시가 된 문자 널리 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b32ee5eae663bc459ca55799e6c9e900ee825b77" translate="yes" xml:space="preserve">
          <source>Current working directory, exception on error.</source>
          <target state="translated">현재 작업 디렉토리, 오류 예외.</target>
        </trans-unit>
        <trans-unit id="a9e67a1612d3786289b31085caea29dd802d1a39" translate="yes" xml:space="preserve">
          <source>Current working directory.</source>
          <target state="translated">현재 작업 디렉토리.</target>
        </trans-unit>
        <trans-unit id="f248a387f0f37e77ff666c2a85a59f7074c24d85" translate="yes" xml:space="preserve">
          <source>Currently &lt;code&gt;@deprecated&lt;/code&gt; only supports functions and macros. However you can use the &lt;code&gt;:deprecated&lt;/code&gt; key in the annotation metadata to annotate the docs of modules, types and callbacks too.</source>
          <target state="translated">현재 &lt;code&gt;@deprecated&lt;/code&gt; 는 함수와 매크로 만 지원합니다. 그러나 주석 메타 데이터에서 &lt;code&gt;:deprecated&lt;/code&gt; 키를 사용하여 모듈, 유형 및 콜백 문서에 주석을 달 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51f90102aa9d37408ac2a331660c80b3de845ceb" translate="yes" xml:space="preserve">
          <source>Currently it defines types and the minimal implementation for a calendar behaviour in Elixir. The goal of the Calendar features in Elixir is to provide a base for interoperability instead of full-featured datetime API.</source>
          <target state="translated">현재는 Elixir에서 달력 동작의 유형과 최소 구현을 정의합니다. Elixir의 캘린더 기능의 목표는 완전한 기능을 갖춘 datetime API 대신 상호 운용성을위한 기반을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="58e947fb9b58beb32c0020272eaa3d95ced9ee44" translate="yes" xml:space="preserve">
          <source>Currently the only accepted PID is &lt;code&gt;self()&lt;/code&gt;.</source>
          <target state="translated">현재 허용되는 유일한 PID는 &lt;code&gt;self()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="63f26076c7ac35014e638bc9d9a7df511fa73b4d" translate="yes" xml:space="preserve">
          <source>Currently we have two tests tagged with &lt;code&gt;@tag :distributed&lt;/code&gt;. The &amp;ldquo;server interaction&amp;rdquo; test in &lt;code&gt;KVServerTest&lt;/code&gt;, and the &amp;ldquo;route requests across nodes&amp;rdquo; in &lt;code&gt;KV.RouterTest&lt;/code&gt;. Both tests are failing since they require a routing table, which is currently empty.</source>
          <target state="translated">현재 &lt;code&gt;@tag :distributed&lt;/code&gt; 태그가있는 두 가지 테스트가 있습니다 . 의 &quot;서버 상호 작용&quot;테스트 &lt;code&gt;KVServerTest&lt;/code&gt; 과의 &quot;노드에서 요청을 라우팅&quot; &lt;code&gt;KV.RouterTest&lt;/code&gt; . 현재 비어있는 라우팅 테이블이 필요하므로 두 테스트 모두 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5bdaaebe2bbb603df00e4573b0900ccd99aa7d09" translate="yes" xml:space="preserve">
          <source>Custom Sigils</source>
          <target state="translated">맞춤형시길</target>
        </trans-unit>
        <trans-unit id="d797cab8a29cd6c10dc9372d1ab9213b989caf7f" translate="yes" xml:space="preserve">
          <source>Custom and overridden operators</source>
          <target state="translated">맞춤형 및 재정의 된 연산자</target>
        </trans-unit>
        <trans-unit id="00146f5b748062fe67c9600ecfcdf444284e0bcf" translate="yes" xml:space="preserve">
          <source>Custom attributes</source>
          <target state="translated">맞춤 속성</target>
        </trans-unit>
        <trans-unit id="e3fd71a31afaaf057b0fedc28ba72336f1780a64" translate="yes" xml:space="preserve">
          <source>Custom backends</source>
          <target state="translated">커스텀 백엔드</target>
        </trans-unit>
        <trans-unit id="abe70270d1f6e2920fe2d28c23289b5295fb962a" translate="yes" xml:space="preserve">
          <source>Custom configuration</source>
          <target state="translated">맞춤 구성</target>
        </trans-unit>
        <trans-unit id="170bc5dc5f750c41d4def27ed27eed6bf3c468fb" translate="yes" xml:space="preserve">
          <source>Custom editors are supported by using the &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt; notations, for example:</source>
          <target state="translated">사용자 정의 편집기는 다음 과 같이 &lt;code&gt;__FILE__&lt;/code&gt; 및 &lt;code&gt;__LINE__&lt;/code&gt; 표기법 을 사용하여 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="642fb7c499e4524f98e2922e90ae2a2b071cfd52" translate="yes" xml:space="preserve">
          <source>Custom formatting</source>
          <target state="translated">맞춤 형식</target>
        </trans-unit>
        <trans-unit id="8eb31d3e78f5111c059041eed039c75877655487" translate="yes" xml:space="preserve">
          <source>Custom sigils</source>
          <target state="translated">맞춤형시길</target>
        </trans-unit>
        <trans-unit id="b447a4b2b4a5635d3f0dd6f81cbcc0d90e8e4a6d" translate="yes" xml:space="preserve">
          <source>Custom types defined through &lt;code&gt;@type&lt;/code&gt; are exported and available outside the module they&amp;rsquo;re defined in:</source>
          <target state="translated">&lt;code&gt;@type&lt;/code&gt; 을 통해 정의 된 사용자 정의 유형 은 다음에 정의 된 모듈 외부에서 내보내고 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b25d03b9dabe02b1fafe8ede605cce72a76c6c5" translate="yes" xml:space="preserve">
          <source>Customization per environment can be done by accessing &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#env/0&quot;&gt;the &lt;code&gt;Mix.env&lt;/code&gt; function&lt;/a&gt; in your &lt;code&gt;mix.exs&lt;/code&gt; file, which returns the current environment as an atom. That&amp;rsquo;s what we have used in the &lt;code&gt;:start_permanent&lt;/code&gt; options:</source>
          <target state="translated">현재 환경을 원자로 리턴하는 &lt;code&gt;mix.exs&lt;/code&gt; 파일 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.html#env/0&quot;&gt;의 &lt;code&gt;Mix.env&lt;/code&gt; 함수&lt;/a&gt; 에 액세스 하여 환경 별 사용자 정의를 수행 할 수 있습니다 . 이것이 우리가 &lt;code&gt;:start_permanent&lt;/code&gt; 옵션 에서 사용한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="303c85db56e6f90f1fcaafbed47e91067f22fbe9" translate="yes" xml:space="preserve">
          <source>Data structures</source>
          <target state="translated">데이터 구조</target>
        </trans-unit>
        <trans-unit id="696ae3d17016ea7046f1ce357ae0b1f6103499a3" translate="yes" xml:space="preserve">
          <source>Data structures such as lists, tuples, and binaries are marked respectively by the delimiters &lt;code&gt;[...]&lt;/code&gt;, &lt;code&gt;{...}&lt;/code&gt;, and &lt;code&gt;&amp;lt;&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt;. Each element is separated by comma. A trailing comma is also allowed, such as in &lt;code&gt;[1, 2, 3,]&lt;/code&gt;.</source>
          <target state="translated">목록, 튜플 및 이진과 같은 데이터 구조는 각각 구분 기호 &lt;code&gt;[...]&lt;/code&gt; , &lt;code&gt;{...}&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&amp;lt;...&amp;gt;&amp;gt;&lt;/code&gt; 로 표시 됩니다. 각 요소는 쉼표로 구분됩니다. &lt;code&gt;[1, 2, 3,]&lt;/code&gt; 과 같이 후행 쉼표도 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="b6be514c02654c4ded06230fc9559da237b0aa77" translate="yes" xml:space="preserve">
          <source>Data types</source>
          <target state="translated">자료형</target>
        </trans-unit>
        <trans-unit id="eb9a4bc1c0c153e4e4b042a79113b815b7e3021d" translate="yes" xml:space="preserve">
          <source>Date</source>
          <target state="translated">Date</target>
        </trans-unit>
        <trans-unit id="904c0db9491168bf7b0f96a8127a1e2e956e54ec" translate="yes" xml:space="preserve">
          <source>Date.Range</source>
          <target state="translated">Date.Range</target>
        </trans-unit>
        <trans-unit id="f1e5baf5ecc3589631088c40cbdd43061976ed8f" translate="yes" xml:space="preserve">
          <source>DateTime</source>
          <target state="translated">DateTime</target>
        </trans-unit>
        <trans-unit id="d0c32ae37c8ec0c5b70c6fbada27ade3b4484def" translate="yes" xml:space="preserve">
          <source>Debug options supported by the &lt;code&gt;start*&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;start*&lt;/code&gt; 함수가 지원하는 디버그 옵션</target>
        </trans-unit>
        <trans-unit id="3dea78e2b42ff6c53cdfe32a0caf66a693083f61" translate="yes" xml:space="preserve">
          <source>Debugger</source>
          <target state="translated">Debugger</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="4dbfbf2c1ca5c9cbf7ff86eebf9f1e60dfaae3c2" translate="yes" xml:space="preserve">
          <source>Debugging with the :sys module</source>
          <target state="translated">: sys 모듈로 디버깅</target>
        </trans-unit>
        <trans-unit id="49bac63211bb6e767f6bd201454a7033e302753a" translate="yes" xml:space="preserve">
          <source>Decodes &lt;code&gt;string&lt;/code&gt; as &quot;x-www-form-urlencoded&quot;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 을 &quot;x-www-form-urlencoded&quot;로 디코딩 합니다 .</target>
        </trans-unit>
        <trans-unit id="f7d7142bd19e1c0ea0198316fec06393f6cb0ea2" translate="yes" xml:space="preserve">
          <source>Decodes a base 16 encoded string into a binary string.</source>
          <target state="translated">기본 16 인코딩 된 문자열을 이진 문자열로 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="fb034015ded81968d20fd5f7e210338ebd758879" translate="yes" xml:space="preserve">
          <source>Decodes a base 32 encoded string into a binary string.</source>
          <target state="translated">기본 32 인코딩 문자열을 이진 문자열로 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="885c7e9658ad97e9a9af45bd4781416e206a6334" translate="yes" xml:space="preserve">
          <source>Decodes a base 32 encoded string with extended hexadecimal alphabet into a binary string.</source>
          <target state="translated">확장 된 16 진 알파벳이있는 기본 32 인코딩 문자열을 이진 문자열로 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="4b608e75a46b84e1feb5de2f9f73f4f8523e9f1d" translate="yes" xml:space="preserve">
          <source>Decodes a base 64 encoded string into a binary string.</source>
          <target state="translated">기본 64 인코딩 문자열을 이진 문자열로 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="b945eb1852da433ae69fcf285b6a56aed338e16f" translate="yes" xml:space="preserve">
          <source>Decodes a base 64 encoded string with URL and filename safe alphabet into a binary string.</source>
          <target state="translated">URL 및 파일 이름 안전 알파벳이있는 기본 64 인코딩 문자열을 이진 문자열로 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="12cd61b38813ead53840f88994a5a092cca61e7f" translate="yes" xml:space="preserve">
          <source>Decodes a query string into a map.</source>
          <target state="translated">쿼리 문자열을 맵으로 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="624612278a208a23a0e8ccd36697aaa475bd3192" translate="yes" xml:space="preserve">
          <source>Decomposes a local or remote call into its remote part (when provided), function name and argument list.</source>
          <target state="translated">로컬 또는 원격 호출을 원격 부분 (제공된 경우), 함수 이름 및 인수 목록으로 분해합니다.</target>
        </trans-unit>
        <trans-unit id="7151035c3114809bda0193c2a85fa1a470935213" translate="yes" xml:space="preserve">
          <source>Default Unit</source>
          <target state="translated">기본 단위</target>
        </trans-unit>
        <trans-unit id="6bcca2541d3f4eb99df509a0ef05a98d2f536b6d" translate="yes" xml:space="preserve">
          <source>Default arguments</source>
          <target state="translated">기본 인수</target>
        </trans-unit>
        <trans-unit id="6593ff7fb992a5e5072fa654c1b194d94010d120" translate="yes" xml:space="preserve">
          <source>Default background color.</source>
          <target state="translated">기본 배경색입니다.</target>
        </trans-unit>
        <trans-unit id="6e98c72a394abdbcd4b12051bb239d5b6259e9ce" translate="yes" xml:space="preserve">
          <source>Default text color.</source>
          <target state="translated">기본 텍스트 색상.</target>
        </trans-unit>
        <trans-unit id="89487e7c33b83cf47b069ff9b1fec8587ba1c7a6" translate="yes" xml:space="preserve">
          <source>Default translation for Erlang log messages.</source>
          <target state="translated">Erlang 로그 메시지의 기본 번역.</target>
        </trans-unit>
        <trans-unit id="e19bd89011e61a7bb0e77dd718395ff863fa6b57" translate="yes" xml:space="preserve">
          <source>Default values and required keys</source>
          <target state="translated">기본값 및 필수 키</target>
        </trans-unit>
        <trans-unit id="0b6846959c6ecef6294ea2738ab118ae06eb0104" translate="yes" xml:space="preserve">
          <source>Defaults to &lt;code&gt;true&lt;/code&gt; for Elixir projects, &lt;code&gt;false&lt;/code&gt; for Erlang projects.</source>
          <target state="translated">Elixir 프로젝트의 &lt;code&gt;true&lt;/code&gt; 기본값은 true 이고 Erlang 프로젝트의 경우 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d3da7d067c0e2af23683cd3618963a0c016ef27c" translate="yes" xml:space="preserve">
          <source>Define a function from a string (&lt;code&gt;function_from_string&lt;/code&gt;) or a file (&lt;code&gt;function_from_file&lt;/code&gt;). This allows you to embed the template as a function inside a module which will then be compiled. This is the preferred API if you have access to the template at compilation time.</source>
          <target state="translated">문자열 ( &lt;code&gt;function_from_string&lt;/code&gt; ) 또는 파일 ( &lt;code&gt;function_from_file&lt;/code&gt; ) 에서 함수를 정의하십시오 . 이를 통해 템플릿 내에 함수로 템플릿을 포함시켜 컴파일 할 수 있습니다. 컴파일 타임에 템플릿에 액세스 할 수있는 경우이 API가 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="7af570fa4ced5be1c1e832e70770e29cb3378f42" translate="yes" xml:space="preserve">
          <source>Define the function explicitly (v1.0)</source>
          <target state="translated">함수를 명시 적으로 정의하십시오 (v1.0)</target>
        </trans-unit>
        <trans-unit id="bc125b89387e69b38c0b71432e6451758cd10e9b" translate="yes" xml:space="preserve">
          <source>Define the rollover moment for the given calendar.</source>
          <target state="translated">주어진 캘린더에 대한 롤오버 모멘트를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="cdc8ce38051bdb795b598be018ffa7c0e1241cd3" translate="yes" xml:space="preserve">
          <source>Defined as</source>
          <target state="translated">로써 정의 된</target>
        </trans-unit>
        <trans-unit id="2c159947b8552c14519d220c3a6ddfaa0e00eeec" translate="yes" xml:space="preserve">
          <source>Defines ExUnit callbacks.</source>
          <target state="translated">ExUnit 콜백을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3fba28715c151409c38236ee7000eb4ed16c82f1" translate="yes" xml:space="preserve">
          <source>Defines a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;File.Stream&lt;/code&gt;&lt;/a&gt; struct returned by &lt;a href=&quot;file#stream!/3&quot;&gt;&lt;code&gt;File.stream!/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;file#stream!/3&quot;&gt; &lt;code&gt;File.stream!/3&lt;/code&gt; 에서&lt;/a&gt; 반환 된 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;File.Stream&lt;/code&gt; &lt;/a&gt; 구조체를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="718b6b621786a1acc4c26d42dbc485e26faf7eec" translate="yes" xml:space="preserve">
          <source>Defines a callback that runs once the test exits.</source>
          <target state="translated">테스트가 종료되면 실행되는 콜백을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="9200a3742bfb9e88c562c9f6f3ed2f69e18c6f67" translate="yes" xml:space="preserve">
          <source>Defines a callback to be run before all tests in a case.</source>
          <target state="translated">사례에서 모든 테스트 전에 실행될 콜백을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4b6166591f75c5a4bf0202583ee95cba035668e8" translate="yes" xml:space="preserve">
          <source>Defines a callback to be run before each test in a case.</source>
          <target state="translated">사례에서 각 테스트 전에 실행될 콜백을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d5bc2aab7b6f9616afc524a405cb7757608452d9" translate="yes" xml:space="preserve">
          <source>Defines a function callback according to the given type specification.</source>
          <target state="translated">주어진 형식 사양에 따라 함수 콜백을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c5db38a50b427e41d0ad25365053a42c56f8a1f7" translate="yes" xml:space="preserve">
          <source>Defines a function that delegates to another module.</source>
          <target state="translated">다른 모듈에 위임하는 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="307e106c43982d5b12630cb72b848406b819c6c6" translate="yes" xml:space="preserve">
          <source>Defines a function with the given name and body.</source>
          <target state="translated">주어진 이름과 본문으로 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="f063e0d1325de98da63498e5fe376536a4c88d2c" translate="yes" xml:space="preserve">
          <source>Defines a macro callback according to the given type specification.</source>
          <target state="translated">주어진 형식 사양에 따라 매크로 콜백을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d1bdce6fb82524ea6dca239a6d1b4282ce120736" translate="yes" xml:space="preserve">
          <source>Defines a macro with the given name and body.</source>
          <target state="translated">주어진 이름과 본문으로 매크로를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="45436ad823527d91893ee57c61d5208fd54f8f28" translate="yes" xml:space="preserve">
          <source>Defines a module given by name with the given contents.</source>
          <target state="translated">주어진 내용으로 이름으로 주어진 모듈을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="cf550b43951705ff60d293e8451b26e72a1b3d68" translate="yes" xml:space="preserve">
          <source>Defines a new bitstring.</source>
          <target state="translated">새로운 비트 열을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5e5448d0355663eca910a26c7f674b96bdfb1318" translate="yes" xml:space="preserve">
          <source>Defines a not implemented test with a string.</source>
          <target state="translated">문자열로 구현되지 않은 테스트를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3c2d3289caf113cf07d04f07d984ecc30b13bea4" translate="yes" xml:space="preserve">
          <source>Defines a private function with the given name and body.</source>
          <target state="translated">주어진 이름과 본문을 가진 개인 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="08a09270f00cde41495279c24131c417ef5be1db" translate="yes" xml:space="preserve">
          <source>Defines a private macro with the given name and body.</source>
          <target state="translated">주어진 이름과 본문으로 개인 매크로를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="234e236e77f17928fa5de859398ddc5049a5ff60" translate="yes" xml:space="preserve">
          <source>Defines a protocol.</source>
          <target state="translated">프로토콜을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="cf0422852f7761d300210619550ed122f7749dee" translate="yes" xml:space="preserve">
          <source>Defines a range.</source>
          <target state="translated">범위를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="84d0bf0e5d21a052c34ad1cf8cc4fd2c0b2d922d" translate="yes" xml:space="preserve">
          <source>Defines a remote call, a call to an anonymous function, or an alias.</source>
          <target state="translated">원격 호출, 익명 함수 호출 또는 별명을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="148ce01689924171178db559eb8519855c18cbf6" translate="yes" xml:space="preserve">
          <source>Defines a set of macros to create, access, and pattern match on a record.</source>
          <target state="translated">레코드에서 작성, 액세스 및 패턴 일치를위한 매크로 세트를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d43aa789386d3da190d548740ece58b49c1b5c28" translate="yes" xml:space="preserve">
          <source>Defines a struct.</source>
          <target state="translated">구조체를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6ff008b3bfc5f520079685bb6518c7f8c263c332" translate="yes" xml:space="preserve">
          <source>Defines a test with a string.</source>
          <target state="translated">문자열로 테스트를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="81a4f177d77d4b3501935507c322bb13c914958e" translate="yes" xml:space="preserve">
          <source>Defines an &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IO.Stream&lt;/code&gt;&lt;/a&gt; struct returned by &lt;a href=&quot;io#stream/2&quot;&gt;&lt;code&gt;IO.stream/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#binstream/2&quot;&gt;&lt;code&gt;IO.binstream/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;io#stream/2&quot;&gt; &lt;code&gt;IO.stream/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;io#binstream/2&quot;&gt; &lt;code&gt;IO.binstream/2&lt;/code&gt; 에서&lt;/a&gt; 반환 한 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;IO.Stream&lt;/code&gt; &lt;/a&gt; 구조체를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="61d9e7c667e3e371baebf26eb4a1e174baee751d" translate="yes" xml:space="preserve">
          <source>Defines an anonymous function.</source>
          <target state="translated">익명 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1f336908a8420d524aec43e1dfa0a8c9f56be6ac" translate="yes" xml:space="preserve">
          <source>Defines an exception.</source>
          <target state="translated">예외를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="47c4eab1a12c9a4e9e5bfc15095c4f5f1e7f8420" translate="yes" xml:space="preserve">
          <source>Defines an implementation for the given protocol.</source>
          <target state="translated">주어진 프로토콜에 대한 구현을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7574e6578cdcbcf5986b0221d662d60206450586" translate="yes" xml:space="preserve">
          <source>Defines and manipulates Mix projects.</source>
          <target state="translated">믹스 프로젝트를 정의하고 조작합니다.</target>
        </trans-unit>
        <trans-unit id="c87324807b8cf7ca458804ea8ef4c07d69ba7fe6" translate="yes" xml:space="preserve">
          <source>Defines options for module compilation. This is used to configure both Elixir and Erlang compilers, as any other compilation pass added by external tools. For example:</source>
          <target state="translated">모듈 컴파일 옵션을 정의합니다. 이것은 외부 도구에 의해 추가 된 다른 컴파일 패스와 같이 Elixir 및 Erlang 컴파일러를 모두 구성하는 데 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="51d68b5790fad1de6d84cef24485698c5aa44718" translate="yes" xml:space="preserve">
          <source>Defines the given &lt;code&gt;module&lt;/code&gt; as a supervisor which will be started with the given arguments.</source>
          <target state="translated">주어진 인수로 시작될 수퍼바이저로 주어진 &lt;code&gt;module&lt;/code&gt; 을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a74b181531a071dccf103975ef9b5f457594135a" translate="yes" xml:space="preserve">
          <source>Defines the given &lt;code&gt;module&lt;/code&gt; as a worker which will be started with the given arguments.</source>
          <target state="translated">주어진 &lt;code&gt;module&lt;/code&gt; 을 주어진 인수로 시작할 작업자로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="1e7e7a56a0498c33eb4666ce267e88fdd0443785" translate="yes" xml:space="preserve">
          <source>Defines the options used by the &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol.</source>
          <target state="translated">&lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; 프로토콜에서 사용하는 옵션을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f752321778df74391c3378581723efb4dca5e78b" translate="yes" xml:space="preserve">
          <source>Defines warnings to request or suppress when using a version of &lt;code&gt;:dialyzer&lt;/code&gt; that supports module attributes.</source>
          <target state="translated">모듈 속성을 지원 하는 &lt;code&gt;:dialyzer&lt;/code&gt; 버전을 사용할 때 요청하거나 억제 할 경고를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="99cdfc3cbea74f1f4372e3c3f255ee42a2f77809" translate="yes" xml:space="preserve">
          <source>Defining a protocol automatically defines a type named &lt;code&gt;t&lt;/code&gt;, which can be used as follows:</source>
          <target state="translated">프로토콜을 정의하면 다음과 같이 사용될 수있는 &lt;code&gt;t&lt;/code&gt; 유형이 자동으로 정의 됩니다.</target>
        </trans-unit>
        <trans-unit id="eed610b2a524f1fea8a5a11a6b90ab2b660a40c7" translate="yes" xml:space="preserve">
          <source>Defining a specification</source>
          <target state="translated">사양 정의</target>
        </trans-unit>
        <trans-unit id="375bfa92ccfe2bd509e0a5a5c9ecb19ed5761bbc" translate="yes" xml:space="preserve">
          <source>Defining behaviours</source>
          <target state="translated">행동 정의</target>
        </trans-unit>
        <trans-unit id="1ea27e7345dd55520e1c3fd955a1961190ab35d0" translate="yes" xml:space="preserve">
          <source>Defining custom guard expressions</source>
          <target state="translated">사용자 정의 가드 식 정의</target>
        </trans-unit>
        <trans-unit id="67ee31ce55d3432708e003e7896d5c65897de368" translate="yes" xml:space="preserve">
          <source>Defining custom operators</source>
          <target state="translated">사용자 정의 연산자 정의</target>
        </trans-unit>
        <trans-unit id="88f1538130a6f0b0a36142a4e1e014b6b0b27ac0" translate="yes" xml:space="preserve">
          <source>Defining custom types</source>
          <target state="translated">사용자 정의 유형 정의</target>
        </trans-unit>
        <trans-unit id="da279c1a631ba36a0429ee2b6ef866ee7c040663" translate="yes" xml:space="preserve">
          <source>Defining extracted records with anonymous functions in the values</source>
          <target state="translated">값에 익명 함수를 사용하여 추출 된 레코드 정의</target>
        </trans-unit>
        <trans-unit id="d271da3ed06fd6bd866bb6e79184abd537c3512e" translate="yes" xml:space="preserve">
          <source>Defining function specs this way works, but it quickly becomes annoying since we&amp;rsquo;re repeating the type &lt;code&gt;{number, String.t}&lt;/code&gt; over and over. We can use the &lt;code&gt;@type&lt;/code&gt; directive in order to declare our own custom type.</source>
          <target state="translated">이 방법으로 함수 사양을 정의하면 작동하지만 &lt;code&gt;{number, String.t}&lt;/code&gt; 유형을 반복해서 반복하기 때문에 빠르게 성가 시게됩니다 . 우리는 우리 자신의 커스텀 타입을 선언하기 위해 &lt;code&gt;@type&lt;/code&gt; 지시자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fec1dfeb38c397bddde90cce354ec968be3e685" translate="yes" xml:space="preserve">
          <source>Defining structs</source>
          <target state="translated">구조체 정의</target>
        </trans-unit>
        <trans-unit id="ac3516b411710c30e4cd006454c7f1994a4da34a" translate="yes" xml:space="preserve">
          <source>Delegation only works with functions; delegating macros is not supported.</source>
          <target state="translated">위임은 기능에서만 작동합니다. 위임 매크로는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e726a77011c0fe0cd388991d477e194ae9fd7af2" translate="yes" xml:space="preserve">
          <source>Deletes &lt;code&gt;value&lt;/code&gt; from &lt;code&gt;map_set&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map_set&lt;/code&gt; 에서 &lt;code&gt;value&lt;/code&gt; 을 삭제 합니다 .</target>
        </trans-unit>
        <trans-unit id="7197d992ec2d7887544bc401d08055b1f065eeeb" translate="yes" xml:space="preserve">
          <source>Deletes a path from the Erlang VM code path list. This is the list of directories the Erlang VM uses for finding module code.</source>
          <target state="translated">Erlang VM 코드 경로 목록에서 경로를 삭제합니다. Erlang VM이 모듈 코드를 찾는 데 사용하는 디렉토리 목록입니다.</target>
        </trans-unit>
        <trans-unit id="23800ac90aacec2911367a4560daa8ed5fec9cb1" translate="yes" xml:space="preserve">
          <source>Deletes an environment variable.</source>
          <target state="translated">환경 변수를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="28cada09dd4174a63836f40b25ecf14ff7e1c534" translate="yes" xml:space="preserve">
          <source>Deletes generated application files.</source>
          <target state="translated">생성 된 응용 프로그램 파일을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="6511b55cc1b351a9cd395e58f52ffa508ee0de39" translate="yes" xml:space="preserve">
          <source>Deletes the &lt;code&gt;key&lt;/code&gt; from the given &lt;code&gt;app&lt;/code&gt; environment.</source>
          <target state="translated">지정된 &lt;code&gt;app&lt;/code&gt; 환경 에서 &lt;code&gt;key&lt;/code&gt; 를 삭제 합니다.</target>
        </trans-unit>
        <trans-unit id="cda458e47c2adb906a94c0b5117cdc3d628bc0de" translate="yes" xml:space="preserve">
          <source>Deletes the child specification identified by &lt;code&gt;child_id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;child_id&lt;/code&gt; 로 식별 된 하위 스펙을 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="06519f5a98d8a9576fa45c95f0c76ae133cbfd51" translate="yes" xml:space="preserve">
          <source>Deletes the element at the given &lt;code&gt;index&lt;/code&gt; from &lt;code&gt;tuple&lt;/code&gt;. Raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;index&lt;/code&gt; is negative or greater than or equal to the length of &lt;code&gt;tuple&lt;/code&gt;. Index is zero-based.</source>
          <target state="translated">주어진 &lt;code&gt;index&lt;/code&gt; 의 요소 를 &lt;code&gt;tuple&lt;/code&gt; 에서 삭제합니다 . 상승 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 경우 &lt;code&gt;index&lt;/code&gt; 네거티브 이상이 초과 또는 길이와 동일한 &lt;code&gt;tuple&lt;/code&gt; . 인덱스는 0부터 시작합니다.</target>
        </trans-unit>
        <trans-unit id="768479db33c4ea83d038f3e75c0b46d08cfff3a1" translate="yes" xml:space="preserve">
          <source>Deletes the entries in the keyword list for a &lt;code&gt;key&lt;/code&gt; with &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">A의 키워드 목록에서 항목을 삭제 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30f8ea2c4a41f9ff990549664a0c3e8cc979a2f3" translate="yes" xml:space="preserve">
          <source>Deletes the entries in the keyword list for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">키워드 목록에서 특정 &lt;code&gt;key&lt;/code&gt; 대한 항목을 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="e356fc985f5b4c45501dcdd4bf05b2d169dc820a" translate="yes" xml:space="preserve">
          <source>Deletes the entry in &lt;code&gt;map&lt;/code&gt; for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">특정 &lt;code&gt;key&lt;/code&gt; 대한 &lt;code&gt;map&lt;/code&gt; 의 항목을 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="84bf7f6c44bf7d1a25fea2eb0b485822b94e4057" translate="yes" xml:space="preserve">
          <source>Deletes the first entry in the keyword list for a specific &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">키워드 목록에서 특정 &lt;code&gt;key&lt;/code&gt; 대한 첫 번째 항목을 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="f8205134472497de5f123b07ed4ca04623561776" translate="yes" xml:space="preserve">
          <source>Deletes the given &lt;code&gt;element&lt;/code&gt; from the &lt;code&gt;list&lt;/code&gt;. Returns a new list without the element.</source>
          <target state="translated">주어진 &lt;code&gt;element&lt;/code&gt; 를 &lt;code&gt;list&lt;/code&gt; 에서 삭제합니다 . 요소가없는 새 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6931640e5585d21423be80c31e8281e15f83ebe2" translate="yes" xml:space="preserve">
          <source>Deletes the given &lt;code&gt;key&lt;/code&gt; from the process dictionary.</source>
          <target state="translated">프로세스 사전에서 지정된 &lt;code&gt;key&lt;/code&gt; 를 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="241d39fd9168ac37f5f1398b699e96cae08161ab" translate="yes" xml:space="preserve">
          <source>Deletes the module attribute that matches the given key.</source>
          <target state="translated">주어진 키와 일치하는 모듈 속성을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="a7699468279a4b12f6e55a5ad1b8c725c2c3ca8c" translate="yes" xml:space="preserve">
          <source>Demonitors the monitor identified by the given &lt;code&gt;reference&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;reference&lt;/code&gt; 식별 된 모니터를 모니터 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="ca0bdefd221fdbfd10bc0f3013fa9c019ef6808e" translate="yes" xml:space="preserve">
          <source>Dependencies and umbrella projects</source>
          <target state="translated">의존성 및 우산 프로젝트</target>
        </trans-unit>
        <trans-unit id="0aeab4e8a30c470967346544f8d2eeabc88b3b63" translate="yes" xml:space="preserve">
          <source>Dependencies between applications in an umbrella project must still be explicitly defined and Mix makes it easy to do so. Open up &lt;code&gt;apps/kv_server/mix.exs&lt;/code&gt; and change the &lt;code&gt;deps/0&lt;/code&gt; function to the following:</source>
          <target state="translated">우산 프로젝트에서 응용 프로그램 간의 종속성은 여전히 ​​명시 적으로 정의해야하며 Mix를 사용하면 쉽게 할 수 있습니다. &lt;code&gt;apps/kv_server/mix.exs&lt;/code&gt; 를 열고 &lt;code&gt;deps/0&lt;/code&gt; 기능을 다음과 같이 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="20c4e61613e0bb2759ad45cedce4f0b014181be0" translate="yes" xml:space="preserve">
          <source>Dependencies must be specified in the &lt;code&gt;mix.exs&lt;/code&gt; file in one of the following formats:</source>
          <target state="translated">다음 형식 중 하나로 &lt;code&gt;mix.exs&lt;/code&gt; 파일에 종속성을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1313d46d93e4456c33c34bdf877a2b31296e6f6b" translate="yes" xml:space="preserve">
          <source>Dependencies within an umbrella project</source>
          <target state="translated">우산 프로젝트 내의 종속성</target>
        </trans-unit>
        <trans-unit id="2ae4f4df59c1f88916b85e951202eefbff4c7b68" translate="yes" xml:space="preserve">
          <source>Dependency definition options</source>
          <target state="translated">종속성 정의 옵션</target>
        </trans-unit>
        <trans-unit id="ac1bc59655cdca7840ee9bf9d55721f13ebb7a55" translate="yes" xml:space="preserve">
          <source>Depending on the accumulator value, the result returned by &lt;a href=&quot;enumerable#reduce/3&quot;&gt;&lt;code&gt;Enumerable.reduce/3&lt;/code&gt;&lt;/a&gt; will change. Please check the &lt;a href=&quot;#t:result/0&quot;&gt;&lt;code&gt;result/0&lt;/code&gt;&lt;/a&gt; type documentation for more information.</source>
          <target state="translated">누산기 값에 따라 &lt;a href=&quot;enumerable#reduce/3&quot;&gt; &lt;code&gt;Enumerable.reduce/3&lt;/code&gt; &lt;/a&gt; 가 반환 한 결과 가 변경됩니다. 자세한 정보 는 &lt;a href=&quot;#t:result/0&quot;&gt; &lt;code&gt;result/0&lt;/code&gt; &lt;/a&gt; 유형 문서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4962f760a0cc6ed936dcedffadba8733dd81e124" translate="yes" xml:space="preserve">
          <source>Deploys a given module's BEAM code to a list of nodes.</source>
          <target state="translated">주어진 모듈의 BEAM 코드를 노드 목록에 배포합니다.</target>
        </trans-unit>
        <trans-unit id="f6ef72731d9f2999dced5cdda829d282f60229ed" translate="yes" xml:space="preserve">
          <source>Deprecated feature</source>
          <target state="translated">더 이상 사용되지 않는 기능</target>
        </trans-unit>
        <trans-unit id="e5135ac9aa0f3adf0ead688638a7cada98f65645" translate="yes" xml:space="preserve">
          <source>Deprecated function to retrieve old documentation format.</source>
          <target state="translated">오래된 문서 형식을 검색하는 데 사용되지 않는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="355cf2e1caeb8e5de974f3e0ee6f449e9a16967c" translate="yes" xml:space="preserve">
          <source>Deprecated mechanism to retrieve the last exception stacktrace.</source>
          <target state="translated">마지막 예외 스택 추적을 검색하기 위해 사용되지 않는 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="34730e9bbd5c0ba7b7655973316eed44e39da85f" translate="yes" xml:space="preserve">
          <source>Deprecations</source>
          <target state="translated">Deprecations</target>
        </trans-unit>
        <trans-unit id="8189415262d9b40fadd78cc759dd14fdb9868384" translate="yes" xml:space="preserve">
          <source>Deps task</source>
          <target state="translated">뎁스 작업</target>
        </trans-unit>
        <trans-unit id="1751cb6240f8427862c44d9fda1a1acebc588f2b" translate="yes" xml:space="preserve">
          <source>Derives the &lt;code&gt;protocol&lt;/code&gt; for &lt;code&gt;module&lt;/code&gt; with the given options.</source>
          <target state="translated">주어진 옵션으로 &lt;code&gt;module&lt;/code&gt; 의 &lt;code&gt;protocol&lt;/code&gt; 을 도출합니다 .</target>
        </trans-unit>
        <trans-unit id="b1f507cfab066377ebfd776c06ce8c6ae1d1dfae" translate="yes" xml:space="preserve">
          <source>Deriving</source>
          <target state="translated">Deriving</target>
        </trans-unit>
        <trans-unit id="469b2320b22b8de425b1224d561debab3b7e4eec" translate="yes" xml:space="preserve">
          <source>Describes tests together.</source>
          <target state="translated">테스트를 함께 설명합니다.</target>
        </trans-unit>
        <trans-unit id="373b67a9ef6e15b48984d2e64ecfb18feb928f40" translate="yes" xml:space="preserve">
          <source>Design principles</source>
          <target state="translated">설계 원칙</target>
        </trans-unit>
        <trans-unit id="9c5959e7ab4938c2e1595e724f3e5f686f3d536b" translate="yes" xml:space="preserve">
          <source>Destructures two lists, assigning each term in the right one to the matching term in the left one.</source>
          <target state="translated">오른쪽에있는 각 용어를 왼쪽에있는 일치하는 용어에 할당하여 두 개의 목록을 구성 해제합니다.</target>
        </trans-unit>
        <trans-unit id="55519a961a5691717096efcabf1914eee5dab5a5" translate="yes" xml:space="preserve">
          <source>Determines if &lt;code&gt;integer&lt;/code&gt; is odd.</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 가 홀수 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="026e5ca0dfda1ad25fabda732fd35af3e32e25b5" translate="yes" xml:space="preserve">
          <source>Determines if an &lt;code&gt;integer&lt;/code&gt; is even.</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 가 짝수 인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="ada7ef5eac5cda7b071d8c84d536d21adaaabe11" translate="yes" xml:space="preserve">
          <source>Determines if the &lt;code&gt;enumerable&lt;/code&gt; is empty.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 이 비어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="240590c512304822fc6f9051f63c5097957b51d1" translate="yes" xml:space="preserve">
          <source>Determines if the date given is valid according to the proleptic Gregorian calendar.</source>
          <target state="translated">주어진 날짜가 다발성 그레고리력에 따라 유효한지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b906ed370d76a314f78611272f97a7c5324fbfb8" translate="yes" xml:space="preserve">
          <source>Developers can also use tools like &lt;a href=&quot;https://github.com/bitwalker/distillery&quot;&gt;Distillery&lt;/a&gt; that build &lt;strong&gt;releases&lt;/strong&gt;. Releases are able to package all of your source code as well as the Erlang VM into a single directory. Releases also give you explicit control over how each application is started and in which order. They also provide a more streamlined mechanism for starting and stopping systems, debugging, logging, as well as system monitoring.</source>
          <target state="translated">개발자는 &lt;strong&gt;릴리스&lt;/strong&gt; 를 빌드하는 &lt;a href=&quot;https://github.com/bitwalker/distillery&quot;&gt;Distillery&lt;/a&gt; 와 같은 도구를 사용할 수도 있습니다 . 릴리스는 Erlang VM뿐만 아니라 모든 소스 코드를 단일 디렉토리에 패키지 할 수 있습니다. 또한 각 응용 프로그램의 시작 방법과 순서를 명시 적으로 제어 할 수 있습니다. 또한 시스템 시작 및 중지, 디버깅, 로깅 및 시스템 모니터링을위한보다 간소화 된 메커니즘을 제공합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="17f25608342d4ab77bb1907f884cfe439bc54de0" translate="yes" xml:space="preserve">
          <source>Developers may also implement their own backends, an option that is explored in more detail below.</source>
          <target state="translated">개발자는 또한 자체 백엔드를 구현할 수도 있습니다.이 옵션은 아래에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0f26c5755a434f3e16da5992d7fb7b82ce5cc7eb" translate="yes" xml:space="preserve">
          <source>Developers may also use umbrella projects to break large business domains apart. The caution here is to make sure the domains don&amp;rsquo;t depend on each other (also known as cyclic dependencies). If you run into such situations, it means those applications are not as isolated from each other as you originally thought, and you have architectural and design issues to solve.</source>
          <target state="translated">개발자는 대규모 프로젝트 영역을 분리하기 위해 우산 프로젝트를 사용할 수도 있습니다. 여기서주의해야 할 것은 도메인이 서로 의존하지 않도록하는 것입니다 (순환 종속성이라고도 함). 이러한 상황이 발생하면 해당 응용 프로그램이 원래 생각했던 것처럼 서로 격리되어 있지 않으며 해결해야 할 아키텍처 및 디자인 문제가있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b4df092ce16103b5263190978f954da4abebc038" translate="yes" xml:space="preserve">
          <source>Developers should avoid creating the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; struct directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries.</source>
          <target state="translated">개발자는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 구조체를 직접 작성하지 말고이 모듈에서 제공하는 기능과 타사 캘린더 라이브러리의 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9399f0af7289ccae2bbfba26b54d6beaa45eceaa" translate="yes" xml:space="preserve">
          <source>Developers should avoid creating the Date structs directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries.</source>
          <target state="translated">개발자는 Date 구조체를 직접 작성하지 말고이 모듈에서 제공하는 기능과 타사 캘린더 라이브러리의 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="372765583e2c62003b134d7cd14c816d752b1af8" translate="yes" xml:space="preserve">
          <source>Developers should avoid creating the NaiveDateTime structs directly and instead, rely on the functions provided by this module as well as the ones in third-party calendar libraries.</source>
          <target state="translated">개발자는 NaiveDateTime 구조체를 직접 만드는 대신이 모듈에서 제공하는 기능과 타사 캘린더 라이브러리의 기능을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="055215a2dc231830ec70e2ea3ed245f009feefc1" translate="yes" xml:space="preserve">
          <source>Developers should avoid creating the Time structs directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries.</source>
          <target state="translated">개발자는 Time 구조체를 직접 작성하지 말고이 모듈에서 제공하는 기능과 타사 캘린더 라이브러리의 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a0f9f33bf587fbe7754189054b93906eb196c38a" translate="yes" xml:space="preserve">
          <source>Developers typically invoke &lt;a href=&quot;dynamicsupervisor#init/1&quot;&gt;&lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt;&lt;/a&gt; at the end of their init callback to return the proper supervision flags.</source>
          <target state="translated">개발자는 일반적으로 적절한 감독 플래그를 반환하기 위해 초기화 콜백이 끝날 때 &lt;a href=&quot;dynamicsupervisor#init/1&quot;&gt; &lt;code&gt;DynamicSupervisor.init/1&lt;/code&gt; &lt;/a&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="c23ae07b94722ec4976e1fcb3346ba8a18a11515" translate="yes" xml:space="preserve">
          <source>Developers typically invoke &lt;a href=&quot;supervisor#init/2&quot;&gt;&lt;code&gt;Supervisor.init/2&lt;/code&gt;&lt;/a&gt; at the end of their init callback to return the proper supervision flags.</source>
          <target state="translated">개발자는 일반적으로 적절한 감독 플래그를 반환하기 위해 초기화 콜백이 끝날 때 &lt;a href=&quot;supervisor#init/2&quot;&gt; &lt;code&gt;Supervisor.init/2&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="c943b3eb860130726114a82a12d17559028bcef9" translate="yes" xml:space="preserve">
          <source>Developing in Elixir does not make your code free of race conditions. However, Elixir&amp;rsquo;s abstractions where nothing is shared by default make it easier to spot a race condition&amp;rsquo;s root cause.</source>
          <target state="translated">Elixir에서 개발한다고해서 코드에 경쟁 조건이없는 것은 아닙니다. 그러나 기본적으로 아무 것도 공유하지 않는 Elixir의 추상화는 경쟁 조건의 근본 원인을 쉽게 발견 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="3550a4a38c380e14df95457cd13d6dabbd0c0b20" translate="yes" xml:space="preserve">
          <source>Dict</source>
          <target state="translated">Dict</target>
        </trans-unit>
        <trans-unit id="28a9d7ddb98e082ecef8831bdb74b74701f20d77" translate="yes" xml:space="preserve">
          <source>Differences from &lt;code&gt;defmodule&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;defmodule&lt;/code&gt; 과의 차이점</target>
        </trans-unit>
        <trans-unit id="951f149c561762e46794ae9088e9246ba02fb48d" translate="yes" xml:space="preserve">
          <source>Differences to &lt;a href=&quot;#count/1&quot;&gt;&lt;code&gt;count/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#count/1&quot;&gt; &lt;code&gt;count/1&lt;/code&gt; &lt;/a&gt; 차이 / 1</target>
        </trans-unit>
        <trans-unit id="7664bc212e56811cb62a63d951c16c5ee311e137" translate="yes" xml:space="preserve">
          <source>Directory separators must always be written as &lt;code&gt;/&lt;/code&gt;, even on Windows. You may call &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; to normalize the path before invoking this function.</source>
          <target state="translated">디렉토리 구분자는 Windows에서도 항상 &lt;code&gt;/&lt;/code&gt; 로 작성해야합니다 . 이 함수를 호출하기 전에 &lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt; 을 호출하여 경로를 정규화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5095c2a8d43020f623949798775e0dea6df3427e" translate="yes" xml:space="preserve">
          <source>Disables logging for the current process.</source>
          <target state="translated">현재 프로세스에 대한 로깅을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="3243542aa799d7700902fa9d17f21c898a51bd23" translate="yes" xml:space="preserve">
          <source>Dispatching happens in the process that calls &lt;a href=&quot;#dispatch/3&quot;&gt;&lt;code&gt;dispatch/3&lt;/code&gt;&lt;/a&gt; either serially or concurrently in case of multiple partitions (via spawned tasks). The registered processes are not involved in dispatching unless involving them is done explicitly (for example, by sending them a message in the callback).</source>
          <target state="translated">디스패치 는 여러 파티션의 경우 (스폰 된 작업을 통해) &lt;a href=&quot;#dispatch/3&quot;&gt; &lt;code&gt;dispatch/3&lt;/code&gt; &lt;/a&gt; 을 직렬 또는 동시에 호출하는 프로세스 에서 발생합니다. 등록 된 프로세스는 명시 적으로 수행되지 않은 경우 (예 : 콜백에 메시지를 보내는 등) 디스패치에 관여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="129dd56090745e370bed845813615f5c08f21b2a" translate="yes" xml:space="preserve">
          <source>Distributed tasks</source>
          <target state="translated">분산 작업</target>
        </trans-unit>
        <trans-unit id="aef0124ef44afd7de1feb0a9b09b0c6ee2798fe2" translate="yes" xml:space="preserve">
          <source>Distributed tasks and tags</source>
          <target state="translated">분산 작업 및 태그</target>
        </trans-unit>
        <trans-unit id="b4c7a18ac5c24ec1029c892a8a7fb3fbcc59af1d" translate="yes" xml:space="preserve">
          <source>Distributed tasks are exactly the same as supervised tasks. The only difference is that we pass the node name when spawning the task on the supervisor. Open up &lt;code&gt;lib/kv/supervisor.ex&lt;/code&gt; from the &lt;code&gt;:kv&lt;/code&gt; application. Let&amp;rsquo;s add a task supervisor as the last child of the tree:</source>
          <target state="translated">분산 작업은 감독 작업과 동일합니다. 유일한 차이점은 수퍼바이저에서 작업을 생성 할 때 노드 이름을 전달한다는 것입니다. 열고 &lt;code&gt;lib/kv/supervisor.ex&lt;/code&gt; 로부터 &lt;code&gt;:kv&lt;/code&gt; 응용 프로그램을. 트리의 마지막 자식으로 작업 관리자를 추가합시다 :</target>
        </trans-unit>
        <trans-unit id="98348afa0d882c80ed7d05917265b30ff93c136a" translate="yes" xml:space="preserve">
          <source>Divides a string into parts based on a pattern.</source>
          <target state="translated">패턴을 기반으로 문자열을 여러 부분으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="4f19d3c5ba97dc473a0dd975ca453b2aa1eeca76" translate="yes" xml:space="preserve">
          <source>Divides a string into substrings at each Unicode whitespace occurrence with leading and trailing whitespace ignored. Groups of whitespace are treated as a single occurrence. Divisions do not occur on non-breaking whitespace.</source>
          <target state="translated">선행 및 후행 공백은 무시하고 각 유니 코드 공백 발생시 문자열을 하위 문자열로 나눕니다. 공백 그룹은 단일 항목으로 취급됩니다. 공백이 아닌 공백에서는 나누기가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e4d17c0fddf7977be47a1ef9b14e7b1d0cef265" translate="yes" xml:space="preserve">
          <source>Do not rely on the particular format returned by the &lt;code&gt;format*&lt;/code&gt; functions in this module. They may be changed in future releases in order to better suit Elixir's tool chain. In other words, by using the functions in this module it is guaranteed you will format exceptions as in the current Elixir version being used.</source>
          <target state="translated">이 모듈 의 &lt;code&gt;format*&lt;/code&gt; 함수가 반환 한 특정 형식에 의존하지 마십시오 . Elixir의 툴 체인에 더 적합하도록 이후 릴리스에서 변경 될 수 있습니다. 즉,이 모듈의 기능을 사용하면 사용중인 현재 Elixir 버전에서와 같이 예외를 형식화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5be89a1272cff39c64911be3f9a33057d2a2263c" translate="yes" xml:space="preserve">
          <source>Do not use &lt;a href=&quot;mix.project#config/0&quot;&gt;&lt;code&gt;Mix.Project.config/0&lt;/code&gt;&lt;/a&gt; to find the runtime configuration. Use it only to configure aspects of your project (like compilation directories) and not your application runtime.</source>
          <target state="translated">런타임 구성을 찾기 위해 &lt;a href=&quot;mix.project#config/0&quot;&gt; &lt;code&gt;Mix.Project.config/0&lt;/code&gt; &lt;/a&gt; 을 사용하지 마십시오 . 응용 프로그램 런타임이 아닌 프로젝트 측면 (컴파일 디렉토리와 같은)을 구성 할 때만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a8d3dcf5e3a5a8a9d6963913c532d9b07e33dbf9" translate="yes" xml:space="preserve">
          <source>Do not use special match variables &lt;code&gt;:&quot;$_&quot;&lt;/code&gt; and &lt;code&gt;:&quot;$$&quot;&lt;/code&gt;, because they might not work as expected.</source>
          <target state="translated">특수 일치 변수 &lt;code&gt;:&quot;$_&quot;&lt;/code&gt; 및 &lt;code&gt;:&quot;$$&quot;&lt;/code&gt; 는 예상대로 작동하지 않을 수 있으므로 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9078c7f338a72de9ec9a277913417c733a31c6ad" translate="yes" xml:space="preserve">
          <source>Do not use this function to generate a sequence of numbers. If blocking the caller process is not necessary, use &lt;code&gt;Stream.iterate(0, &amp;amp; &amp;amp;1 + 1)&lt;/code&gt; instead.</source>
          <target state="translated">이 함수를 사용하여 일련의 숫자를 생성하지 마십시오. 발신자 프로세스를 차단할 필요가 없으면 &lt;code&gt;Stream.iterate(0, &amp;amp; &amp;amp;1 + 1)&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5e01c221d853296d84e769113c74b2df4ca129d1" translate="yes" xml:space="preserve">
          <source>Doctests</source>
          <target state="translated">Doctests</target>
        </trans-unit>
        <trans-unit id="fd6f84b7484c0cf7709bebbb23583c23abf1b083" translate="yes" xml:space="preserve">
          <source>Doctests are specified by an indentation of four spaces followed by the &lt;code&gt;iex&amp;gt;&lt;/code&gt; prompt in a documentation string. If a command spans multiple lines, you can use &lt;code&gt;...&amp;gt;&lt;/code&gt;, as in IEx. The expected result should start at the next line after &lt;code&gt;iex&amp;gt;&lt;/code&gt; or &lt;code&gt;...&amp;gt;&lt;/code&gt; line(s) and is terminated either by a newline or a new &lt;code&gt;iex&amp;gt;&lt;/code&gt; prefix.</source>
          <target state="translated">&lt;code&gt;iex&amp;gt;&lt;/code&gt; 는 문서 문자열에서 4 개의 공백 들여 쓰기와 iex&amp;gt; 프롬프트로 지정됩니다 . 명령이 여러 줄에 걸쳐 있으면 IEx에서와 같이 &lt;code&gt;...&amp;gt;&lt;/code&gt; 을 사용할 수 있습니다 . 예상 된 결과는 &lt;code&gt;iex&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;...&amp;gt;&lt;/code&gt; 행 다음 줄에서 시작해야 하며 개행 또는 새 &lt;code&gt;iex&amp;gt;&lt;/code&gt; 접두어 로 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="acfc0021db2710ad6e5c5976444819b508e6a8e7" translate="yes" xml:space="preserve">
          <source>Doctests, patterns and with</source>
          <target state="translated">Doctests, 패턴 및</target>
        </trans-unit>
        <trans-unit id="9e9cf3221a30246219863f1d2366e36cb580debc" translate="yes" xml:space="preserve">
          <source>Documentation</source>
          <target state="translated">Documentation</target>
        </trans-unit>
        <trans-unit id="dbeb3b73b289a45968e86a1c4e28757eddbb7b21" translate="yes" xml:space="preserve">
          <source>Documentation != Code comments</source>
          <target state="translated">문서! = 코드 주석</target>
        </trans-unit>
        <trans-unit id="dc66ec30a9e7992a7f99224cd60ef6a9e6f7c515" translate="yes" xml:space="preserve">
          <source>Documentation in Elixir is usually attached to module attributes. Let's see an example:</source>
          <target state="translated">Elixir의 문서는 일반적으로 모듈 속성에 첨부됩니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="d46677a0ad1e404b917f0ea8b3b31b80c34ffa5f" translate="yes" xml:space="preserve">
          <source>Documentation metadata</source>
          <target state="translated">설명서 메타 데이터</target>
        </trans-unit>
        <trans-unit id="fcb85c951e6d656fcd603d110a64fcd8866200d9" translate="yes" xml:space="preserve">
          <source>Documents in a group are attempted to be rendered together to the best of the renderer ability.</source>
          <target state="translated">그룹의 문서는 최상의 렌더러 기능으로 함께 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="7bd6d91ba0fc6656f3596671325c2a8e0bccb23f" translate="yes" xml:space="preserve">
          <source>Does not load any of the implementations.</source>
          <target state="translated">구현을로드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1c5568ff1b2696956a80de3fbdad95c454b1c9a" translate="yes" xml:space="preserve">
          <source>Does not load any of the protocols.</source>
          <target state="translated">프로토콜을로드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c263be485f93e4de275853028d24c5388efd78f6" translate="yes" xml:space="preserve">
          <source>Doing 0.1 * 0.1 should return 0.01, but because 0.1 is actually 0.1000000014, the result is 0.010000000000000002, and because this is not the closest representable number to 0.01, you'll get the wrong result for this operation</source>
          <target state="translated">0.1 * 0.1을 수행하면 0.01이 반환되지만 0.1이 실제로 0.1000000014이므로 결과는 0.010000000000000002이며 이는 0.01에 가장 가까운 대표 숫자가 아니기 때문에이 작업에 대한 잘못된 결과를 얻습니다</target>
        </trans-unit>
        <trans-unit id="576aa93d193455e3276b07f4cd2af71d8167c617" translate="yes" xml:space="preserve">
          <source>Doing it in reverse order will raise a syntax error:</source>
          <target state="translated">역순으로 수행하면 구문 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a56ad56b6280b6eca6747cdcbe707267d3443caf" translate="yes" xml:space="preserve">
          <source>Domain-specific languages</source>
          <target state="translated">도메인 별 언어</target>
        </trans-unit>
        <trans-unit id="e6ab4e40cdc60406c301246d5709b2813b1c0221" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t drink the kool aid</source>
          <target state="translated">쿨 원조를 마시지 마십시오</target>
        </trans-unit>
        <trans-unit id="bfd4ab20e5eed869032f79c7d0b2472213257269" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t forget that you can also check the &lt;a href=&quot;https://github.com/elixir-lang/elixir&quot;&gt;source code of Elixir itself&lt;/a&gt;, which is mostly written in Elixir (mainly the &lt;code&gt;lib&lt;/code&gt; directory), or &lt;a href=&quot;https://elixir-lang.org/docs.html&quot;&gt;explore Elixir&amp;rsquo;s documentation&lt;/a&gt;.</source>
          <target state="translated">Elixir (주로 &lt;code&gt;lib&lt;/code&gt; 디렉토리)로 작성된 &lt;a href=&quot;https://github.com/elixir-lang/elixir&quot;&gt;Elixir 자체&lt;/a&gt; 의 소스 코드를 확인 하거나 &lt;a href=&quot;https://elixir-lang.org/docs.html&quot;&gt;Elixir의 문서를 탐색 할 수도 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e3dff4b81533f75ceec6a97ebb6191aa309061e" translate="yes" xml:space="preserve">
          <source>Drops elements at the beginning of the &lt;code&gt;enumerable&lt;/code&gt; while &lt;code&gt;fun&lt;/code&gt; returns a truthy value.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 는 진실한 가치를 반환 하면서 &lt;code&gt;enumerable&lt;/code&gt; 시작 부분에 요소를 삭제 합니다.</target>
        </trans-unit>
        <trans-unit id="594f287d9f0bd3fb9ea891584418c737436dd38e" translate="yes" xml:space="preserve">
          <source>Drops the &lt;code&gt;amount&lt;/code&gt; of elements from the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 요소에서 요소 의 &lt;code&gt;amount&lt;/code&gt; 을 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="ab32b2e5c71cd1c17d36b26a0d25edc63a27b074" translate="yes" xml:space="preserve">
          <source>Drops the given &lt;code&gt;keys&lt;/code&gt; from &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;keys&lt;/code&gt; 를 &lt;code&gt;map&lt;/code&gt; 에서 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="cdb8b8343fe7d1adbf36b056e528d2571ea6a12c" translate="yes" xml:space="preserve">
          <source>Drops the given keys from the keyword list.</source>
          <target state="translated">키워드 목록에서 지정된 키를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="69c0475e80c404bbdc2d49a7a643fb10c6ace760" translate="yes" xml:space="preserve">
          <source>Due to immutability, loops in Elixir (as in any functional programming language) are written differently from imperative languages. For example, in an imperative language like C, one would write:</source>
          <target state="translated">불변성으로 인해 Elixir의 루프 (모든 기능적 프로그래밍 언어에서와 같이)는 명령형 언어와 다르게 작성됩니다. 예를 들어 C와 같은 명령형 언어에서는 다음과 같이 작성합니다.</target>
        </trans-unit>
        <trans-unit id="5cf07ff6fe7f2d796d09183c5eda29bcd66f1127" translate="yes" xml:space="preserve">
          <source>Due to their cons cell based representation, prepending an element to a list is always fast (constant time), while appending becomes slower as the list grows in size (linear time):</source>
          <target state="translated">cons 셀 기반 표현으로 인해 목록에 요소를 추가하는 것은 항상 빠르며 (일정한 시간), 목록의 크기가 커짐에 따라 추가하는 속도가 느려집니다 (선형 시간).</target>
        </trans-unit>
        <trans-unit id="4f1ef09b3bb7845a809a8a0e2e38529155ed603e" translate="yes" xml:space="preserve">
          <source>Due to their laziness, streams are useful when working with large (or even infinite) collections. When chaining many operations with &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, intermediate lists are created, while &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; creates a recipe of computations that are executed at a later moment. Let's see another example:</source>
          <target state="translated">게으름으로 인해 스트림은 대규모 (또는 무한한) 컬렉션으로 작업 할 때 유용합니다. 많은 연산을 &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 과 연결하면 중간 목록이 생성되고 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 은 나중에 실행되는 계산 레시피를 생성합니다. 다른 예를 보자.</target>
        </trans-unit>
        <trans-unit id="9895fb241f7b45a9dc3e35cea835d242910bcea5" translate="yes" xml:space="preserve">
          <source>Due to this property, Elixir relies on functions starting with underscore to attach compile-time metadata to modules. Such functions are most often in the &lt;code&gt;__foo__&lt;/code&gt; format. For example, every module in Elixir has an &lt;a href=&quot;module#c:__info__/1&quot;&gt;&lt;code&gt;__info__/1&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">이 속성으로 인해 Elixir는 밑줄로 시작하는 함수를 사용하여 컴파일 타임 메타 데이터를 모듈에 첨부합니다. 이러한 함수는 대부분 &lt;code&gt;__foo__&lt;/code&gt; 형식입니다. 예를 들어, Elixir의 모든 모듈에는 &lt;a href=&quot;module#c:__info__/1&quot;&gt; &lt;code&gt;__info__/1&lt;/code&gt; &lt;/a&gt; 함수가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7d17d072820769c205a9be99134b8181cc1f8d63" translate="yes" xml:space="preserve">
          <source>Duplicated entries are removed, the latest one prevails. Unlike &lt;code&gt;Enum.into(enumerable, [])&lt;/code&gt;, &lt;code&gt;Keyword.new(enumerable)&lt;/code&gt; guarantees the keys are unique.</source>
          <target state="translated">중복 된 항목이 제거되고 최신 항목이 우선합니다. 달리 &lt;code&gt;Enum.into(enumerable, [])&lt;/code&gt; , &lt;code&gt;Keyword.new(enumerable)&lt;/code&gt; 키가 고유 보장한다.</target>
        </trans-unit>
        <trans-unit id="076f63ae0f418e3862988b172f7c4cc5852450a8" translate="yes" xml:space="preserve">
          <source>Duplicated entries are removed, the latest one prevails. Unlike &lt;code&gt;Enum.into(enumerable, [], fun)&lt;/code&gt;, &lt;code&gt;Keyword.new(enumerable, fun)&lt;/code&gt; guarantees the keys are unique.</source>
          <target state="translated">중복 된 항목이 제거되고 최신 항목이 우선합니다. 달리 &lt;code&gt;Enum.into(enumerable, [], fun)&lt;/code&gt; , &lt;code&gt;Keyword.new(enumerable, fun)&lt;/code&gt; 키가 고유 보장합니다.</target>
        </trans-unit>
        <trans-unit id="64aa4fe0da505292ed7a57df0b239e0d4183ccec" translate="yes" xml:space="preserve">
          <source>Duplicated keys appear duplicated in the final list of keys.</source>
          <target state="translated">중복 키는 최종 키 목록에 중복 된 것으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="efdd2fd6681b594f9b79a82e9b5aa48b4fbf5e9b" translate="yes" xml:space="preserve">
          <source>Duplicated keys are not removed.</source>
          <target state="translated">중복 키는 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac53e68a8e0e729bf98aeec7ce7b6340de177d35" translate="yes" xml:space="preserve">
          <source>Duplicated keys are preserved in the new keyword list.</source>
          <target state="translated">중복 된 키는 새 키워드 목록에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b3b6f1eeffe99ed90517ec6eae526962d142636d" translate="yes" xml:space="preserve">
          <source>Duplicated keys are removed; the latest one prevails.</source>
          <target state="translated">중복 키가 제거됩니다. 최신이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="9ba8d07a9bc46aeb1c779fab12a8b4dd715ff170" translate="yes" xml:space="preserve">
          <source>Duplicates the given element &lt;code&gt;n&lt;/code&gt; times in a list.</source>
          <target state="translated">주어진 요소를 목록에서 &lt;code&gt;n&lt;/code&gt; 번 복제합니다 .</target>
        </trans-unit>
        <trans-unit id="612d35050e691a1a2b9f22fe6b8f2fde9cb8f9d1" translate="yes" xml:space="preserve">
          <source>Dynamic dispatch</source>
          <target state="translated">동적 디스패치</target>
        </trans-unit>
        <trans-unit id="edd7dafc098b4b13db6ad466bd4e821198c0337f" translate="yes" xml:space="preserve">
          <source>Dynamic names</source>
          <target state="translated">동적 이름</target>
        </trans-unit>
        <trans-unit id="46d2782a295d697a8b9e27c2d91c25f66bfd854d" translate="yes" xml:space="preserve">
          <source>Dynamic supervisors</source>
          <target state="translated">동적 감독자</target>
        </trans-unit>
        <trans-unit id="3aa9130077fcc44c7eb24ab3a909359998b572f0" translate="yes" xml:space="preserve">
          <source>DynamicSupervisor</source>
          <target state="translated">DynamicSupervisor</target>
        </trans-unit>
        <trans-unit id="4981d257018e7d749e02934b79c0b6bdb94f8f95" translate="yes" xml:space="preserve">
          <source>DynamicSupervisor &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">DynamicSupervisor &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="7ba279830cac8f3b7ac440b34f16c258d525250e" translate="yes" xml:space="preserve">
          <source>Dynamically adds a child specification to &lt;code&gt;supervisor&lt;/code&gt; and starts that child.</source>
          <target state="translated">자식 사양을 &lt;code&gt;supervisor&lt;/code&gt; 에게 동적으로 추가하고 해당 자식을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="887cf55c60fc1c9af6689bd5e2a2c3b3766133c3" translate="yes" xml:space="preserve">
          <source>Dynamically supervised tasks</source>
          <target state="translated">동적으로 감독되는 작업</target>
        </trans-unit>
        <trans-unit id="5b16ec2483e166fe049f665c022763eabe66f30f" translate="yes" xml:space="preserve">
          <source>EEx</source>
          <target state="translated">EEx</target>
        </trans-unit>
        <trans-unit id="af3993684170f3f24c787f9d7ffb881775da9c68" translate="yes" xml:space="preserve">
          <source>EEx has the concept of engines which allows you to modify or transform the code extracted from the given string or file.</source>
          <target state="translated">EEx에는 주어진 문자열이나 파일에서 추출 된 코드를 수정하거나 변형 할 수있는 엔진 개념이 있습니다.</target>
        </trans-unit>
        <trans-unit id="818fc332cfd248836c5442317677dfe04bdbbd73" translate="yes" xml:space="preserve">
          <source>EEx stands for Embedded Elixir. It allows you to embed Elixir code inside a string in a robust way.</source>
          <target state="translated">EEx는 Embedded Elixir의 약자입니다. 강력한 방식으로 문자열 안에 Elixir 코드를 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22a24f67ecb347cc9015ff6237454fdbf0669653" translate="yes" xml:space="preserve">
          <source>EEx.Engine &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">EEx 엔진 &lt;small&gt;작동&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="eebf2acaee05e7c09c816457012d68bbfc96c6f3" translate="yes" xml:space="preserve">
          <source>EEx.SmartEngine</source>
          <target state="translated">EEx.SmartEngine</target>
        </trans-unit>
        <trans-unit id="674e9c18d21c34b87c83982cf9afa4d95159a4be" translate="yes" xml:space="preserve">
          <source>EEx.SyntaxError</source>
          <target state="translated">EEx.SyntaxError</target>
        </trans-unit>
        <trans-unit id="49bba56082c8e3c9fff304ab7864ed3cb3a25fb5" translate="yes" xml:space="preserve">
          <source>EEx.SyntaxError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">EEx.SyntaxError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="98d18c239604c617df6f8788536838fd25d8c03d" translate="yes" xml:space="preserve">
          <source>EEx: &lt;code&gt;&amp;lt;%=&lt;/code&gt; in middle and end expressions</source>
          <target state="translated">EEx : 중간 및 끝 표현식에서 &lt;code&gt;&amp;lt;%=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7eceb14d6ed554f3e39c3487db659c8d63e28acd" translate="yes" xml:space="preserve">
          <source>ETS</source>
          <target state="translated">ETS</target>
        </trans-unit>
        <trans-unit id="1500176ef8cc8bfbbaf08eb4c1316bcf890f3395" translate="yes" xml:space="preserve">
          <source>ETS (Erlang Term Storage)</source>
          <target state="translated">ETS (Erlang 용어 저장소)</target>
        </trans-unit>
        <trans-unit id="4f5a2cc3fa91eb59c67ada064593bcea69c5e3b4" translate="yes" xml:space="preserve">
          <source>ETS allows us to store any Elixir term in an in-memory table. Working with ETS tables is done via &lt;a href=&quot;http://www.erlang.org/doc/man/ets.html&quot;&gt;Erlang&amp;rsquo;s &lt;code&gt;:ets&lt;/code&gt; module&lt;/a&gt;:</source>
          <target state="translated">ETS를 사용하면 메모리 내 테이블에 Elixir 용어를 저장할 수 있습니다. ETS 테이블 작업은 &lt;a href=&quot;http://www.erlang.org/doc/man/ets.html&quot;&gt;Erlang의 &lt;code&gt;:ets&lt;/code&gt; 모듈을&lt;/a&gt; 통해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e8dd8378100a7f6cf535d73f581bb5835a296a0" translate="yes" xml:space="preserve">
          <source>ETS as a cache</source>
          <target state="translated">캐시로서의 ETS</target>
        </trans-unit>
        <trans-unit id="0c6b672feadc74b2fa303a786fd5682cec52505f" translate="yes" xml:space="preserve">
          <source>ETS lets you create a table containing tuples. By default, ETS tables are protected, which means only the owner process may write to the table but any other process can read. ETS has some functionality to allow a table to be used as a simple database, a key-value store or as a cache mechanism.</source>
          <target state="translated">ETS를 사용하면 튜플이 포함 된 테이블을 만들 수 있습니다. 기본적으로 ETS 테이블은 보호되므로 소유자 프로세스 만 테이블에 쓸 수 있지만 다른 프로세스는 읽을 수 있습니다. ETS에는 테이블을 간단한 데이터베이스, 키-값 저장소 또는 캐시 메커니즘으로 사용할 수있는 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="52adb6284390fce5741221672f061e71df403d05" translate="yes" xml:space="preserve">
          <source>ETS tables can also be named, allowing us to access them by a given name:</source>
          <target state="translated">ETS 테이블의 이름도 지정할 수 있으므로 지정된 이름으로 테이블에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="362cea4d522d64f424e9ad3e438c8000b26fb5c9" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;enumerable&lt;/code&gt; element is passed as argument to the given function &lt;code&gt;fun&lt;/code&gt; and processed by its own task. The tasks will be linked to the current process, similarly to &lt;a href=&quot;#async/1&quot;&gt;&lt;code&gt;async/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 각 요소는 주어진 함수 &lt;code&gt;fun&lt;/code&gt; 에 인수로 전달되고 자체 작업으로 처리됩니다. 작업은 &lt;a href=&quot;#async/1&quot;&gt; &lt;code&gt;async/1&lt;/code&gt; &lt;/a&gt; 과 유사하게 현재 프로세스에 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="c70223b508f5fb20c656733438516d9c4a38e207" translate="yes" xml:space="preserve">
          <source>Each application has an environment that stores the application&amp;rsquo;s specific configuration by key. For example, we could store the routing table in the &lt;code&gt;:kv&lt;/code&gt; application environment, giving it a default value and allowing other applications to change the table as needed.</source>
          <target state="translated">각 응용 프로그램에는 키별로 응용 프로그램의 특정 구성을 저장하는 환경이 있습니다. 예를 들어 라우팅 테이블을 &lt;code&gt;:kv&lt;/code&gt; 응용 프로그램 환경 에 저장하여 기본값을 제공하고 필요에 따라 다른 응용 프로그램에서 테이블을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30b77596010e1d94e168b64218473fa0c4476548" translate="yes" xml:space="preserve">
          <source>Each application in our system can be started and stopped. The rules for starting and stopping an application are also defined in the &lt;code&gt;.app&lt;/code&gt; file. When we invoke &lt;code&gt;iex -S mix&lt;/code&gt;, Mix compiles our application and then starts it.</source>
          <target state="translated">시스템의 각 응용 프로그램을 시작하고 중지 할 수 있습니다. 응용 프로그램 시작 및 중지 규칙도 &lt;code&gt;.app&lt;/code&gt; 파일에 정의되어 있습니다. &lt;code&gt;iex -S mix&lt;/code&gt; 를 호출하면 Mix가 응용 프로그램을 컴파일 한 다음 시작합니다.</target>
        </trans-unit>
        <trans-unit id="6ee7cee4e35c13e97e0b113c7ad93de2b2e9f9ff" translate="yes" xml:space="preserve">
          <source>Each element in &lt;code&gt;enumerable&lt;/code&gt; is passed as argument to the given function &lt;code&gt;fun&lt;/code&gt; and processed by its own task. The tasks will be spawned under the given &lt;code&gt;supervisor&lt;/code&gt; and linked to the current process, similarly to &lt;a href=&quot;#async/2&quot;&gt;&lt;code&gt;async/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 각 요소 는 주어진 함수 &lt;code&gt;fun&lt;/code&gt; 에 인수로 전달되고 자체 작업으로 처리됩니다. 작업은 지정된 &lt;code&gt;supervisor&lt;/code&gt; 아래에 생성되고 &lt;a href=&quot;#async/2&quot;&gt; &lt;code&gt;async/2&lt;/code&gt; &lt;/a&gt; 와 유사하게 현재 프로세스에 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="0bff2b054449ef93f88ae378fceaa7c3773b512d" translate="yes" xml:space="preserve">
          <source>Each element in &lt;code&gt;enumerable&lt;/code&gt; is passed as argument to the given function &lt;code&gt;fun&lt;/code&gt; and processed by its own task. The tasks will be spawned under the given &lt;code&gt;supervisor&lt;/code&gt; and will not be linked to the current process, similarly to &lt;a href=&quot;#async_nolink/2&quot;&gt;&lt;code&gt;async_nolink/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 각 요소 는 주어진 함수 &lt;code&gt;fun&lt;/code&gt; 에 인수로 전달되고 자체 작업으로 처리됩니다. 작업은 지정된 &lt;code&gt;supervisor&lt;/code&gt; 에서 생성 되며 &lt;a href=&quot;#async_nolink/2&quot;&gt; &lt;code&gt;async_nolink/2&lt;/code&gt; &lt;/a&gt; 와 유사하게 현재 프로세스에 연결되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f8ff31374c6e0e1792073cfd7bf59921a2ee8196" translate="yes" xml:space="preserve">
          <source>Each element in &lt;code&gt;enumerable&lt;/code&gt; will be prepended to the given &lt;code&gt;args&lt;/code&gt; and processed by its own task. The tasks will be spawned under the given &lt;code&gt;supervisor&lt;/code&gt; and will not be linked to the current process, similarly to &lt;a href=&quot;#async_nolink/4&quot;&gt;&lt;code&gt;async_nolink/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 각 요소 는 주어진 &lt;code&gt;args&lt;/code&gt; 앞에 추가되고 자체 작업으로 처리됩니다. 작업은 지정된 &lt;code&gt;supervisor&lt;/code&gt; 에서 생성 되며 &lt;a href=&quot;#async_nolink/4&quot;&gt; &lt;code&gt;async_nolink/4&lt;/code&gt; &lt;/a&gt; 와 유사하게 현재 프로세스에 연결되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3e074b39ec3a1ed372a909c0a3201829b19421e8" translate="yes" xml:space="preserve">
          <source>Each element of &lt;code&gt;enumerable&lt;/code&gt; will be prepended to the given &lt;code&gt;args&lt;/code&gt; and processed by its own task. The tasks will be linked to an intermediate process that is then linked to the current process. This means a failure in a task terminates the current process and a failure in the current process terminates all tasks.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 각 요소는 주어진 &lt;code&gt;args&lt;/code&gt; 앞에 추가되고 자체 작업으로 처리됩니다. 작업은 중간 프로세스에 연결되고 현재 프로세스에 연결됩니다. 이는 작업 실패가 현재 프로세스를 종료하고 현재 프로세스가 실패하면 모든 작업이 종료됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ea81b39bec07b5eca51e7cb8e73b08cc88b185e5" translate="yes" xml:space="preserve">
          <source>Each element will be prepended to the given &lt;code&gt;args&lt;/code&gt; and processed by its own task. The tasks will be spawned under the given &lt;code&gt;supervisor&lt;/code&gt; and linked to the current process, similarly to &lt;a href=&quot;#async/4&quot;&gt;&lt;code&gt;async/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">각 요소는 주어진 &lt;code&gt;args&lt;/code&gt; 앞에 추가되고 자체 작업으로 처리됩니다. 작업은 주어진 &lt;code&gt;supervisor&lt;/code&gt; 에서 생성되고 &lt;a href=&quot;#async/4&quot;&gt; &lt;code&gt;async/4&lt;/code&gt; &lt;/a&gt; 와 유사하게 현재 프로세스에 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="77459e85ee4402d66fd92ef0b7844cafe8faeccd" translate="yes" xml:space="preserve">
          <source>Each entry in the registry is associated to the process that has registered the key. If the process crashes, the keys associated to that process are automatically removed. All key comparisons in the registry are done using the match operation (&lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">레지스트리의 각 항목은 키를 등록한 프로세스와 연관됩니다. 프로세스가 충돌하면 해당 프로세스와 관련된 키가 자동으로 제거됩니다. 레지스트리의 모든 키 비교는 일치 작업 ( &lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt; )을 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="f51dcc2b38618bcc3fe87f6cb31bfc9d58a91577" translate="yes" xml:space="preserve">
          <source>Each item in the list is a map with the following keys:</source>
          <target state="translated">목록의 각 항목은 다음 키가있는 맵입니다.</target>
        </trans-unit>
        <trans-unit id="532f0099dc0a59c8142722d964bd46289ef70cfc" translate="yes" xml:space="preserve">
          <source>Each key-value pair in the map is converted to a two-element tuple &lt;code&gt;{key, value}&lt;/code&gt; in the resulting list.</source>
          <target state="translated">맵의 각 키-값 쌍 은 결과 목록에서 두 요소 튜플 &lt;code&gt;{key, value}&lt;/code&gt; 로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="4934170f741619738531430df9405d17c3b39b24" translate="yes" xml:space="preserve">
          <source>Each module can be decorated with one or more attributes. The following ones are currently defined by Elixir:</source>
          <target state="translated">각 모듈은 하나 이상의 속성으로 꾸밀 수 있습니다. 다음은 현재 Elixir에서 정의한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9ac8e172618067a3e6bc12be54b49bfe15535ac3" translate="yes" xml:space="preserve">
          <source>Each module gets an &lt;code&gt;__info__/1&lt;/code&gt; function when it's compiled. The function takes one of the following items:</source>
          <target state="translated">각 모듈은 컴파일 될 때 &lt;code&gt;__info__/1&lt;/code&gt; 함수를 얻습니다 . 이 기능은 다음 항목 중 하나를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e4ebc93808a7013b1682e04607e3d5c0727d33dc" translate="yes" xml:space="preserve">
          <source>Each number given to a binary is meant to represent a byte and therefore must go up to 255. Binaries allow modifiers to be given to store numbers bigger than 255 or to convert a code point to its UTF-8 representation:</source>
          <target state="translated">바이너리에 주어진 각 숫자는 바이트를 나타 내기 때문에 255까지 올라 가야합니다. 바이너리는 수정자가 255보다 큰 숫자를 저장하거나 코드 포인트를 UTF-8 표현으로 변환 할 수 있도록합니다 :</target>
        </trans-unit>
        <trans-unit id="372725c1f82abeb98e09b054fcea454db1d9af25" translate="yes" xml:space="preserve">
          <source>Each process started with the application must be listed as a child under the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; above. We call those &quot;static processes&quot; because they are known upfront. For handling dynamic processes, such as the ones started during requests and other user inputs, look at the &lt;a href=&quot;dynamicsupervisor&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">응용 프로그램으로 시작된 각 프로세스는 위 의 &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 아래 자식으로 표시되어야합니다 . 이를 &quot;정적 프로세스&quot;라고합니다. 요청 및 기타 사용자 입력 중에 시작된 것과 같은 동적 프로세스를 처리하려면 &lt;a href=&quot;dynamicsupervisor&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt; 모듈을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a1a597396bbd78d869061e9cc988eca475a9257e" translate="yes" xml:space="preserve">
          <source>Each task has its own options and sometimes specific configuration to be defined in the &lt;code&gt;project/0&lt;/code&gt; function. You can use &lt;a href=&quot;mix.tasks.help&quot;&gt;&lt;code&gt;mix help&lt;/code&gt;&lt;/a&gt; to list all available tasks and &lt;code&gt;mix help NAME&lt;/code&gt; to show help for a particular task.</source>
          <target state="translated">각 작업에는 고유 한 옵션이 있으며 때로는 &lt;code&gt;project/0&lt;/code&gt; 기능 에서 정의 할 특정 구성이 있습니다 . &lt;a href=&quot;mix.tasks.help&quot;&gt; &lt;code&gt;mix help&lt;/code&gt; &lt;/a&gt; 을 사용하여 사용 가능한 모든 작업을 나열하고 &lt;code&gt;mix help NAME&lt;/code&gt; 을 사용하여 특정 작업에 대한 도움말을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcac1b6f9d120c9722086c7e508489b0226da684" translate="yes" xml:space="preserve">
          <source>Each variable is identified by a tuple of two elements, where the first element is the variable name as an atom and the second element is its context, which may be an atom or an integer.</source>
          <target state="translated">각 변수는 두 요소의 튜플로 식별되며, 첫 번째 요소는 변수 이름이며 원자는 두 번째 요소이며 컨텍스트는 원자 또는 정수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68310c7d97bd5e9d47967e9e9edcb285e94d70ff" translate="yes" xml:space="preserve">
          <source>Eager to learn more? Keep reading!</source>
          <target state="translated">더 배우고 싶어? 계속 읽으세요!</target>
        </trans-unit>
        <trans-unit id="773015863b8b24712e29c53fe98994b9728f6381" translate="yes" xml:space="preserve">
          <source>Eager vs Lazy</source>
          <target state="translated">열망 대 지연</target>
        </trans-unit>
        <trans-unit id="28ac06af2cb7839cf14f9821c41dfad421032a0a" translate="yes" xml:space="preserve">
          <source>Echo server</source>
          <target state="translated">에코 서버</target>
        </trans-unit>
        <trans-unit id="eeccb169551120a3e6a633e63e844185e028c154" translate="yes" xml:space="preserve">
          <source>Edit the file at &lt;code&gt;lib/kv/registry.ex&lt;/code&gt;, filling in the blanks for the client API:</source>
          <target state="translated">&lt;code&gt;lib/kv/registry.ex&lt;/code&gt; 파일을 편집하여 클라이언트 API의 공백을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="25857c2157bff6e7a9f798c89b04873173125f2d" translate="yes" xml:space="preserve">
          <source>Elements are compared using &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; 를&lt;/a&gt; 사용하여 요소를 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="b1bc7fb1f226e6f6f3ef7ee47c49d49289229118" translate="yes" xml:space="preserve">
          <source>Elements are only emitted when &lt;code&gt;fun&lt;/code&gt; returns a new value or the &lt;code&gt;enum&lt;/code&gt; finishes.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 은 fun 이 새로운 값을 반환하거나 &lt;code&gt;enum&lt;/code&gt; 이 완료 될 때만 방출됩니다 .</target>
        </trans-unit>
        <trans-unit id="c0c7bf14304705b88f3bf9ecdfcf919293c76e53" translate="yes" xml:space="preserve">
          <source>Elixir</source>
          <target state="translated">Elixir</target>
        </trans-unit>
        <trans-unit id="e5c4daa79e73a93f8dc527746d72ef1e1f99e8dd" translate="yes" xml:space="preserve">
          <source>Elixir 1.5.0 onwards</source>
          <target state="translated">엘릭서 1.5.0 이상</target>
        </trans-unit>
        <trans-unit id="67dd209de0ff8f0eac333c13b028cb684c348812" translate="yes" xml:space="preserve">
          <source>Elixir 1.9.0 onwards</source>
          <target state="translated">엘릭서 1.9.0 이후</target>
        </trans-unit>
        <trans-unit id="bff9443fa7cf4ae0bab8d5c8f1f4dab57c2d5acf" translate="yes" xml:space="preserve">
          <source>Elixir Forum</source>
          <target state="translated">엘릭서 포럼</target>
        </trans-unit>
        <trans-unit id="de61752fa33c065b078b47c60fdefbfedf94b579" translate="yes" xml:space="preserve">
          <source>Elixir allows developers to attach arbitrary metadata to the documentation. This is done by passing a keyword list to the relevant attribute (such as &lt;code&gt;@moduledoc&lt;/code&gt;, &lt;code&gt;@typedoc&lt;/code&gt;, and &lt;code&gt;@doc&lt;/code&gt;). A commonly used metadata is &lt;code&gt;:since&lt;/code&gt;, which annotates in which version that particular module, function, type, or callback was added, as shown in the example above.</source>
          <target state="translated">Elixir를 사용하면 개발자가 임의의 메타 데이터를 문서에 첨부 할 수 있습니다. 키워드 목록을 관련 속성 (예 : &lt;code&gt;@moduledoc&lt;/code&gt; , &lt;code&gt;@typedoc&lt;/code&gt; 및 &lt;code&gt;@doc&lt;/code&gt; )에 전달하면됩니다. 일반적으로 사용되는 메타 데이터는 &lt;code&gt;:since&lt;/code&gt; 이며, 위의 예와 같이 특정 모듈, 함수, 유형 또는 콜백이 추가 된 버전에 주석을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3c0ee4efd422df64d926e1699ce27c5bdf0b25e6" translate="yes" xml:space="preserve">
          <source>Elixir allows integers to contain &lt;code&gt;_&lt;/code&gt; to separate digits and provides conveniences to represent integers in other bases:</source>
          <target state="translated">Elixir는 정수에 &lt;code&gt;_&lt;/code&gt; 를 포함 하여 숫자를 구분하고 다른 기준에서 정수를 표현할 수있는 편의성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f75c26877ef871217ff6769618e4b459e83b4aa9" translate="yes" xml:space="preserve">
          <source>Elixir allows us to derive a protocol implementation based on the &lt;code&gt;Any&lt;/code&gt; implementation. Let&amp;rsquo;s first implement &lt;code&gt;Any&lt;/code&gt; as follows:</source>
          <target state="translated">Elixir를 사용하면 &lt;code&gt;Any&lt;/code&gt; 구현을 기반으로 프로토콜 구현을 도출 할 수 있습니다 . 먼저 다음과 같이 &lt;code&gt;Any&lt;/code&gt; 를 구현해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="83c382416abbdb750f7a0b52274c72d3eeffa512" translate="yes" xml:space="preserve">
          <source>Elixir allows variables to be rebound via static single assignment:</source>
          <target state="translated">Elixir를 사용하면 정적 단일 할당을 통해 변수를 리바운드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e0d77b67e657e2b9066c1ff6972927494c31617" translate="yes" xml:space="preserve">
          <source>Elixir allows you to skip the leading &lt;code&gt;:&lt;/code&gt; for the atoms &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">비약은 최고의 건너 뛸 수 있습니다 &lt;code&gt;:&lt;/code&gt; 원자에 대한 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; 과 &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39ff842a6a4a3cf98a11fae4fd4498e3695c470e" translate="yes" xml:space="preserve">
          <source>Elixir already provides mechanisms to write your everyday code in a simple and readable fashion by using its data structures and functions. Macros should only be used as a last resort. Remember that &lt;strong&gt;explicit is better than implicit&lt;/strong&gt;. &lt;strong&gt;Clear code is better than concise code.&lt;/strong&gt;</source>
          <target state="translated">Elixir는 이미 데이터 구조와 함수를 사용하여 일상의 코드를 간단하고 읽기 쉬운 방식으로 작성하는 메커니즘을 제공합니다. 매크로는 최후의 수단으로 만 사용해야합니다. &lt;strong&gt;명시 적이 암시 적보다 낫다는&lt;/strong&gt; 것을 기억하십시오 . &lt;strong&gt;명확한 코드는 간결한 코드보다 낫습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c3c84bd869e800cf00a0f15faeb1fec6f09ff020" translate="yes" xml:space="preserve">
          <source>Elixir already provides mechanisms to write your everyday code in a simple and readable fashion by using its data structures and functions. Macros should only be used as a last resort. Remember that &lt;strong&gt;explicit is better than implicit&lt;/strong&gt;. &lt;strong&gt;Clear code is better than concise code&lt;/strong&gt;.</source>
          <target state="translated">Elixir는 이미 데이터 구조와 함수를 사용하여 일상의 코드를 간단하고 읽기 쉬운 방식으로 작성하는 메커니즘을 제공합니다. 매크로는 최후의 수단으로 만 사용해야합니다. &lt;strong&gt;명시 적이 암시 적보다 낫다는&lt;/strong&gt; 것을 기억하십시오 . &lt;strong&gt;명확한 코드는 간결한 코드보다 낫습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="04d508ddfa3159bfde64248d0cbc115d950cb551" translate="yes" xml:space="preserve">
          <source>Elixir also accepts by default the segment to be a literal string or a literal charlist, which are by default expanded to integers:</source>
          <target state="translated">또한 엘릭서는 기본적으로 세그먼트를 리터럴 문자열 또는 리터럴 문자리스트로 받아들이며, 기본적으로 정수로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="738cbc7a97733fcad20b5d4c9dce828da97453d5" translate="yes" xml:space="preserve">
          <source>Elixir also allows developers to enforce certain keys must always be given when building the struct:</source>
          <target state="translated">Elixir는 또한 개발자가 구조체를 만들 때 항상 특정 키를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2aeb44fb689a73ee1106300bdf2d7f03241fd14" translate="yes" xml:space="preserve">
          <source>Elixir also contains an &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; function that is a superset of &lt;a href=&quot;#ensure_loaded/1&quot;&gt;&lt;code&gt;ensure_loaded/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir는 또한 &lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; &lt;/a&gt; 의 수퍼 셋 인 &lt;a href=&quot;#ensure_loaded/1&quot;&gt; &lt;code&gt;ensure_loaded/1&lt;/code&gt; &lt;/a&gt; 함수를 포함합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
