<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="6b4e1d5251f6539ac9cb9db6500f4e6878385d0e" translate="yes" xml:space="preserve">
          <source>If you alias a module and you don't use the alias, Elixir is going to issue a warning implying the alias is not being used.</source>
          <target state="translated">모듈 별명을 지정하고 별명을 사용하지 않으면 Elixir는 별명을 사용하지 않는다는 경고를 발행합니다.</target>
        </trans-unit>
        <trans-unit id="353408b9f20e6cd80af272ea14032adbf9497508" translate="yes" xml:space="preserve">
          <source>If you are connected to remote shell, it remains alive after disconnection.</source>
          <target state="translated">원격 셸에 연결된 경우 연결을 끊은 후에도 활성 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="efc5604d31d0bf68a1f19a9b171547de1fbb3007" translate="yes" xml:space="preserve">
          <source>If you are interested in implementing an event manager, please read the &quot;Alternatives&quot; section below. If you have to implement an event handler to integrate with an existing system, such as Elixir's Logger, please use &lt;code&gt;:gen_event&lt;/code&gt; instead.</source>
          <target state="translated">이벤트 관리자 구현에 관심이있는 경우 아래의 &quot;대체&quot;섹션을 읽으십시오. Elixir 's Logger와 같은 기존 시스템과 통합하기 위해 이벤트 핸들러를 구현 &lt;code&gt;:gen_event&lt;/code&gt; 경우 : gen_event를 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="51ef50c4ad529792706bf2b89ce565387c1909b0" translate="yes" xml:space="preserve">
          <source>If you are looking for a distributed key-value store to use in production, you should definitely look into &lt;a href=&quot;http://basho.com/products/riak-kv/&quot;&gt;Riak&lt;/a&gt;, which also runs in the Erlang</source>
          <target state="translated">프로덕션에 사용할 분산 키-값 저장소를 찾고 있다면 Erlang에서도 실행되는 &lt;a href=&quot;http://basho.com/products/riak-kv/&quot;&gt;Riak을&lt;/a&gt; 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="1c8bab3f8a9ae8447c6ed759b9dc3262c1eec9de" translate="yes" xml:space="preserve">
          <source>If you are on Windows, you will have to open up &lt;code&gt;rel/env.bat.eex&lt;/code&gt;, where you will find this:</source>
          <target state="translated">Windows를 사용하는 경우 &lt;code&gt;rel/env.bat.eex&lt;/code&gt; 를 열어야합니다 .</target>
        </trans-unit>
        <trans-unit id="44c91ebf5be7f8382f751128810946bd95b4f4b2" translate="yes" xml:space="preserve">
          <source>If you are planning to write your first library for other developers to use, don&amp;rsquo;t forget to read our &lt;a href=&quot;https://hexdocs.pm/elixir/library-guidelines.html&quot;&gt;Library Guidelines&lt;/a&gt;.</source>
          <target state="translated">다른 개발자가 사용할 수 있도록 첫 번째 라이브러리를 작성하려는 경우 &lt;a href=&quot;https://hexdocs.pm/elixir/library-guidelines.html&quot;&gt;라이브러리 가이드 라인&lt;/a&gt; 을 반드시 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="2b2be79d72180600413436f842949c96ba6fb15b" translate="yes" xml:space="preserve">
          <source>If you are setting a &lt;code&gt;@moduletag&lt;/code&gt;, you must set that after your call to &lt;code&gt;use ExUnit.Case&lt;/code&gt; otherwise you will see compilation errors.</source>
          <target state="translated">&lt;code&gt;@moduletag&lt;/code&gt; 를 설정하는 경우 ExUnit.Case 를 &lt;code&gt;use ExUnit.Case&lt;/code&gt; 호출 한 후에 설정해야 합니다. 그렇지 않으면 컴파일 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e14a93bec8f9e7583ef7d4636212d137d7df029a" translate="yes" xml:space="preserve">
          <source>If you are using async tasks, you &lt;strong&gt;must await&lt;/strong&gt; a reply as they are &lt;em&gt;always&lt;/em&gt; sent. If you are not expecting a reply, consider using &lt;a href=&quot;task#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt; detailed below.</source>
          <target state="translated">비동기 작업을 사용하는 경우 &lt;em&gt;항상&lt;/em&gt; 전송 되므로 회신을 &lt;strong&gt;기다려야&lt;/strong&gt; 합니다 . 응답이 없을 경우 아래에 자세히 설명 된 &lt;a href=&quot;task#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; 을&lt;/a&gt; 사용해 보십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f469101752f119e7e176bed241907b041da8adaa" translate="yes" xml:space="preserve">
          <source>If you are using releases, see &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt;, there another configuration file called &lt;code&gt;config/releases.exs&lt;/code&gt;. While &lt;code&gt;config/config.exs&lt;/code&gt; and friends mentioned in the previous section are executed whenever you run a Mix command, including when you assemble a release, &lt;code&gt;config/releases.exs&lt;/code&gt; is execute every time your production system boots. Since Mix is not available in a production system, &lt;code&gt;config/releases.exs&lt;/code&gt; must not use any of the functions from Mix.</source>
          <target state="translated">릴리스를 사용하는 경우 &lt;code&gt;config/releases.exs&lt;/code&gt; 라는 다른 구성 파일 인 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt; &lt;code&gt;mix release&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 . 동안 &lt;code&gt;config/config.exs&lt;/code&gt; 당신이 릴리스를 조립 할 때, 혼합 명령을 포함하여 실행할 때마다 이전 절에서 언급 한 친구가 실행 &lt;code&gt;config/releases.exs&lt;/code&gt; 때마다 당신의 생산 시스템이 부팅을 실행합니다. 프로덕션 시스템에서는 Mix를 사용할 수 없으므로 &lt;code&gt;config/releases.exs&lt;/code&gt; 는 Mix의 기능을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="9e377e363c18762d6989f073da394e35ff6a1d87" translate="yes" xml:space="preserve">
          <source>If you are using several functions from a given module, you can import those functions and reference them as local functions, for example:</source>
          <target state="translated">주어진 모듈에서 여러 함수를 사용하는 경우 해당 함수를 가져 와서 로컬 함수로 참조 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d9f991b27b559271b270b3fbea782f7486b09a69" translate="yes" xml:space="preserve">
          <source>If you attempt to define a module that already exists, you will get a warning saying that a module has been redefined.</source>
          <target state="translated">이미 존재하는 모듈을 정의하려고하면 모듈이 재정의되었다는 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8adfc9342331c8cadc540a2cd5ed23c3faf380ba" translate="yes" xml:space="preserve">
          <source>If you connect to localhost once again and perform another request, now everything should work, as long as the routing table contains the correct node names. Outstanding!</source>
          <target state="translated">localhost에 다시 연결하고 다른 요청을 수행하면 라우팅 테이블에 올바른 노드 이름이 포함되어 있으면 모든 것이 작동합니다. 훌륭해!</target>
        </trans-unit>
        <trans-unit id="9a27ffb13441db905f42c43f88d86b47f09d7485" translate="yes" xml:space="preserve">
          <source>If you create a task using &lt;code&gt;async_nolink&lt;/code&gt; inside an OTP behaviour like &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, you should match on the message coming from the task inside your &lt;a href=&quot;genserver#c:handle_info/2&quot;&gt;&lt;code&gt;GenServer.handle_info/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">당신이 사용하여 작업을 만들 경우 &lt;code&gt;async_nolink&lt;/code&gt; 을 같은 OTP 동작 내부 &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 을&lt;/a&gt; , 당신은 당신의 내부 작업에서 오는 메시지에 일치해야합니다 &lt;a href=&quot;genserver#c:handle_info/2&quot;&gt; &lt;code&gt;GenServer.handle_info/2&lt;/code&gt; &lt;/a&gt; 콜백.</target>
        </trans-unit>
        <trans-unit id="55b7d0164ac505a2fe344467d02c4867bf511345" translate="yes" xml:space="preserve">
          <source>If you desire to execute a trusted command inside a shell, with pipes, redirecting and so on, please check &lt;a href=&quot;http://www.erlang.org/doc/man/os.html#cmd-1&quot;&gt;&lt;code&gt;:os.cmd/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파이프, 리디렉션 등을 사용하여 셸 내에서 신뢰할 수있는 명령을 실행하려면 &lt;a href=&quot;http://www.erlang.org/doc/man/os.html#cmd-1&quot;&gt; &lt;code&gt;:os.cmd/1&lt;/code&gt; 을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="a07182ef0f8b88c81a61025e684458268493b23a" translate="yes" xml:space="preserve">
          <source>If you do not care about the results of the computation, you can run the stream with &lt;a href=&quot;stream#run/1&quot;&gt;&lt;code&gt;Stream.run/1&lt;/code&gt;&lt;/a&gt;. Also set &lt;code&gt;ordered: false&lt;/code&gt;, as you don't care about the order of the results either:</source>
          <target state="translated">계산 결과에 신경 쓰지 않으면 &lt;a href=&quot;stream#run/1&quot;&gt; &lt;code&gt;Stream.run/1&lt;/code&gt; 로&lt;/a&gt; 스트림을 실행할 수 있습니다 . 또한 &lt;code&gt;ordered: false&lt;/code&gt; 설정 하십시오. 결과의 순서에 신경 쓰지 않기 때문에 :</target>
        </trans-unit>
        <trans-unit id="368841cd2351fb8c28d9325238a5752ebba7a138" translate="yes" xml:space="preserve">
          <source>If you do want to parse unknown switches, remember that Elixir converts switches to atoms. Since atoms are not garbage-collected, OptionParser will only parse switches that translate to atoms used by the runtime to avoid leaking atoms. For instance, the code below will discard the &lt;code&gt;--option-parser-example&lt;/code&gt; switch because the &lt;code&gt;:option_parser_example&lt;/code&gt; atom is never used anywhere:</source>
          <target state="translated">알 수없는 스위치를 구문 분석하려면 Elixir가 스위치를 원자로 변환한다는 것을 기억하십시오. 원자는 가비지 수집되지 않으므로 OptionParser는 원자 누출을 피하기 위해 런타임에서 사용하는 원자로 변환되는 스위치 만 구문 분석합니다. 예를 들어, 아래의 코드 는 &lt;code&gt;:option_parser_example&lt;/code&gt; 아톰이 어디에도 사용되지 않기 때문에 &lt;code&gt;--option-parser-example&lt;/code&gt; 스위치를 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="bb3116d6b170b69080991a7150c103095c5454b2" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have any use for the error, you don&amp;rsquo;t have to provide it:</source>
          <target state="translated">오류를 전혀 사용하지 않으면 오류를 제공하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="c77ad5b32204a8ca68d3f5ddb986c84f0f9228ac" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify a default key value when defining a struct, &lt;code&gt;nil&lt;/code&gt; will be assumed:</source>
          <target state="translated">구조체를 정의 할 때 기본 키 값을 지정하지 않으면 &lt;code&gt;nil&lt;/code&gt; 이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="2c6d6c827a17a1772b5dade87fd7f321c6f06b85" translate="yes" xml:space="preserve">
          <source>If you don't need a process, then you don't need a process. Use processes only to model runtime properties, such as mutable state, concurrency and failures, never for code organization.</source>
          <target state="translated">프로세스가 필요하지 않은 경우 프로세스가 필요하지 않습니다. 코드 구성에는 절대 변하지 않는 상태, 동시성 및 실패와 같은 런타임 속성을 모델링하는 데만 프로세스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="55f782e4dd6bf586b9ca7b60f48c228585b2ac7c" translate="yes" xml:space="preserve">
          <source>If you don't want to import a function or macro from &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;, use the &lt;code&gt;:except&lt;/code&gt; option and then list the function/macro by arity:</source>
          <target state="translated">당신이에서 함수 또는 매크로 가져 오지 않을 경우 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 의를 사용 &lt;code&gt;:except&lt;/code&gt; 옵션 다음 인수에 대응하여 기능 / 매크로 목록 :</target>
        </trans-unit>
        <trans-unit id="b0fdad62ae1fb19bf40fae581950eb21ad57ac2c" translate="yes" xml:space="preserve">
          <source>If you don't want to link the caller to the task, then you must use a supervised task with &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; and call &lt;a href=&quot;task.supervisor#async_nolink/2&quot;&gt;&lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">발신자를 작업에 연결하지 않으려면 &lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; 와 함께 감독 작업을 사용하고 &lt;a href=&quot;task.supervisor#async_nolink/2&quot;&gt; &lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt; 를&lt;/a&gt; 호출 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a8b7f3eba3dd98ca6590eeed6ea68a53ee96f3d2" translate="yes" xml:space="preserve">
          <source>If you don't want to remove all the entries associated with &lt;code&gt;key&lt;/code&gt; use &lt;a href=&quot;#pop_first/3&quot;&gt;&lt;code&gt;pop_first/3&lt;/code&gt;&lt;/a&gt; instead, that function will remove only the first entry.</source>
          <target state="translated">대신 &lt;code&gt;key&lt;/code&gt; use &lt;a href=&quot;#pop_first/3&quot;&gt; &lt;code&gt;pop_first/3&lt;/code&gt; &lt;/a&gt; 와 관련된 모든 항목을 제거하지 않으려면 해당 기능이 첫 번째 항목 만 제거합니다.</target>
        </trans-unit>
        <trans-unit id="296ef732a2b3390cd10f991ad01cb9a80eb4f583" translate="yes" xml:space="preserve">
          <source>If you expect a project to be defined, i.e., it is a requirement of the current task, you should call &lt;a href=&quot;#get!/0&quot;&gt;&lt;code&gt;get!/0&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">프로젝트가 정의 될 것으로 예상되는 경우, 즉 현재 작업의 요구 사항 인 경우 대신 &lt;a href=&quot;#get!/0&quot;&gt; &lt;code&gt;get!/0&lt;/code&gt; 을&lt;/a&gt; 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="05da62df25733918acb3c100ca6eefcc7e8a9a05" translate="yes" xml:space="preserve">
          <source>If you find any errors in the tutorial or on the website, &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com&quot;&gt;please report a bug or send a pull request to our issue tracker&lt;/a&gt;.</source>
          <target state="translated">튜토리얼이나 웹 사이트에서 오류를 발견 &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com&quot;&gt;하면 버그를보고하거나 이슈 추적기에 풀 요청을 보내십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3352da2349194da360a70c60c5b2d7bfce63e72d" translate="yes" xml:space="preserve">
          <source>If you find yourself in a position where you want to use different configurations in each application for the same dependency or use different dependency versions, then it is likely your codebase has grown beyond what umbrellas can provide.</source>
          <target state="translated">동일한 종속성에 대해 각 응용 프로그램에서 서로 다른 구성을 사용하거나 다른 종속성 버전을 사용하려는 경우 코드베이스가 제공 할 수있는 것 이상으로 확장되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="966f4145842556d60eacaa5cb05900d76971a573" translate="yes" xml:space="preserve">
          <source>If you find yourself trapping exits to handle exits inside the async stream, consider using &lt;a href=&quot;#async_stream_nolink/6&quot;&gt;&lt;code&gt;async_stream_nolink/6&lt;/code&gt;&lt;/a&gt; to start tasks that are not linked to the calling process.</source>
          <target state="translated">비동기 스트림 내에서 엑시트를 처리하기 위해 엑시트를 트래핑하는 것이 발견되면 &lt;a href=&quot;#async_stream_nolink/6&quot;&gt; &lt;code&gt;async_stream_nolink/6&lt;/code&gt; &lt;/a&gt; 을 사용 하여 호출 프로세스에 링크되지 않은 태스크를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="4197dd8400c648df18d603e11d970a3cb8836276" translate="yes" xml:space="preserve">
          <source>If you forget to escape it, Elixir will raise an error when compiling the code.</source>
          <target state="translated">이스케이프를 잊어 버리면 코드를 컴파일 할 때 Elixir에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="56efc6ca629edeb2fce03d19b2bc73e5833972b7" translate="yes" xml:space="preserve">
          <source>If you have a file that needs to compile other modules in parallel, the spawned processes need to be aware of the compiler environment. This function allows a developer to create a task that is aware of those environments.</source>
          <target state="translated">다른 모듈을 병렬로 컴파일해야하는 파일이 있으면 생성 된 프로세스가 컴파일러 환경을 인식해야합니다. 이 기능을 통해 개발자는 해당 환경을 인식하는 작업을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="772ddb24d9ed2ed3cd849be346856ed163202199" translate="yes" xml:space="preserve">
          <source>If you have a struct and you would like to merge a set of keys into the struct, do not use this function, as it would merge all keys on the right side into the struct, even if the key is not part of the struct. Instead, use &lt;a href=&quot;kernel#struct/2&quot;&gt;&lt;code&gt;Kernel.struct/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구조체가 있고 키 세트를 구조체에 병합하려는 경우 키가 구조체의 일부가 아니더라도 오른쪽의 모든 키를 구조체에 병합하므로이 기능을 사용하지 마십시오. 대신 &lt;a href=&quot;kernel#struct/2&quot;&gt; &lt;code&gt;Kernel.struct/2&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="02d90c57cd4c0d17ad045bc9f12b98eb64e0aa31" translate="yes" xml:space="preserve">
          <source>If you have an internal dependency, Mix supports two methods to work with them: Git repositories or umbrella projects.</source>
          <target state="translated">내부 종속성이있는 경우 Mix는 두 가지 방법으로 작업 할 수 있습니다. Git 리포지토리 또는 우산 프로젝트.</target>
        </trans-unit>
        <trans-unit id="4e035a407e624050895eb31725f1748d9f855294" translate="yes" xml:space="preserve">
          <source>If you have another computer on the same network with both Erlang and Elixir installed, you can start another shell on it. If you don&amp;rsquo;t, you can start another IEx session in another terminal. In either case, give it the short name of &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="translated">Erlang과 Elixir가 모두 설치된 동일한 네트워크에 다른 컴퓨터가있는 경우 다른 쉘을 시작할 수 있습니다. 그렇지 않으면 다른 터미널에서 다른 IEx 세션을 시작할 수 있습니다. 두 경우 모두 &lt;code&gt;bar&lt;/code&gt; 의 짧은 이름을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="91e486a025ad182f48607bffbb20dc17512610a7" translate="yes" xml:space="preserve">
          <source>If you have any questions or improvements to the guide, please reach discussion channels such as the &lt;a href=&quot;https://elixirforum.com&quot;&gt;Elixir Forum&lt;/a&gt; or the &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com/issues&quot;&gt;issues tracker&lt;/a&gt;. Your input is really important to help us guarantee the guides are accessible and up to date!</source>
          <target state="translated">가이드에 대한 질문이나 개선 사항이 있으면 &lt;a href=&quot;https://elixirforum.com&quot;&gt;Elixir 포럼&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com/issues&quot;&gt;이슈 트래커&lt;/a&gt; 와 같은 토론 채널을 방문하십시오 . 귀하의 의견은 가이드가 액세스 가능하고 최신 상태로 유지되도록하는 데 매우 중요합니다!</target>
        </trans-unit>
        <trans-unit id="aab49794b532da97c155763d4fee42c69953f3cd" translate="yes" xml:space="preserve">
          <source>If you have prior programming experience, you may be wondering: &amp;ldquo;could we just guarantee the bucket does not crash in the first place?&amp;rdquo;. As we will see, Elixir developers tend to refer to those practices as &amp;ldquo;defensive programming&amp;rdquo;. That&amp;rsquo;s because a live production system has dozens of different reasons why something can go wrong. The disk can fail, memory can be corrupted, bugs, the network may stop working for a second, etc. If we were to write software that attempted to protect or circumvent all of those errors, we would spend more time handling failures than writing our own software!</source>
          <target state="translated">사전 프로그래밍 경험이 있다면 &quot;처음에 버킷이 충돌하지 않도록 보장 할 수 있습니까?&quot;라고 궁금 할 것입니다. 앞으로 살펴 보 겠지만, Elixir 개발자는 이러한 관행을 &quot;방어 프로그래밍&quot;이라고합니다. 라이브 프로덕션 시스템에는 무언가 잘못 될 수있는 수십 가지 이유가 있기 때문입니다. 디스크가 고장 나거나, 메모리가 손상되거나, 버그가 발생하거나, 네트워크가 1 초 동안 작동을 멈출 수 있습니다. 이러한 오류를 모두 방지하거나 회피하려는 소프트웨어를 작성하려는 경우, 오류를 처리하는 것보다 오류 처리에 더 많은 시간을 할애합니다 자신의 소프트웨어!</target>
        </trans-unit>
        <trans-unit id="4ff3bc0809c7cb590dd86540f6bc9220ad4b14e5" translate="yes" xml:space="preserve">
          <source>If you have skipped the Getting Started guide or read it long ago, be sure to re-read the &lt;a href=&quot;../processes&quot;&gt;Processes&lt;/a&gt; chapter. We will use it as a starting point.</source>
          <target state="translated">시작 안내서를 건너 뛰거나 오래 전에 읽은 경우 &lt;a href=&quot;../processes&quot;&gt;프로세스&lt;/a&gt; 장 을 다시 읽으십시오 . 시작점으로 사용하겠습니다.</target>
        </trans-unit>
        <trans-unit id="d5e749fd5e08cb28911eb18410413620f0bb3b45" translate="yes" xml:space="preserve">
          <source>If you have to, you can think of behaviours like interfaces in object oriented languages like Java: a set of function signatures that a module has to implement.</source>
          <target state="translated">필요한 경우 Java와 같은 객체 지향 언어의 인터페이스와 같은 동작 (모듈이 구현해야하는 함수 시그너처 세트)을 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="775881310bd0276caea4cdc0616b4fb21efd691c" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t yet installed Elixir, visit our &lt;a href=&quot;https://elixir-lang.org/install.html&quot;&gt;installation page&lt;/a&gt;. Once you are done, you can run &lt;code&gt;elixir --version&lt;/code&gt; to get the current Elixir version.</source>
          <target state="translated">Elixir를 아직 설치하지 않았다면 &lt;a href=&quot;https://elixir-lang.org/install.html&quot;&gt;설치 페이지를&lt;/a&gt; 방문 하십시오 . 완료되면 &lt;code&gt;elixir --version&lt;/code&gt; 을 실행 하여 현재 Elixir 버전을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68dc8f62a9e86b3efbf7155da89ee4b3f7fa0def" translate="yes" xml:space="preserve">
          <source>If you import a module and you don't use any of the imported functions or macros from this module, Elixir is going to issue a warning implying the import is not being used.</source>
          <target state="translated">모듈을 가져오고이 모듈에서 가져온 함수 나 매크로를 사용하지 않으면 Elixir는 가져 오기가 사용되지 않는다는 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="dd8b4968a8e609a12b5b450ac372d4f06174ea20" translate="yes" xml:space="preserve">
          <source>If you intend to shut the task down if it has not responded within &lt;code&gt;timeout&lt;/code&gt; milliseconds, you should chain this together with &lt;a href=&quot;#shutdown/1&quot;&gt;&lt;code&gt;shutdown/1&lt;/code&gt;&lt;/a&gt;, like so:</source>
          <target state="translated">작업이 &lt;code&gt;timeout&lt;/code&gt; 밀리 초 내에 응답하지 않은 경우 작업을 종료하려면 다음과 같이 &lt;a href=&quot;#shutdown/1&quot;&gt; &lt;code&gt;shutdown/1&lt;/code&gt; &lt;/a&gt; 과 함께 연결해야합니다 .</target>
        </trans-unit>
        <trans-unit id="83089d9b73e4091162a26829945c724a24daa00a" translate="yes" xml:space="preserve">
          <source>If you know you are running on a different system that the current one and you are doing multiple matches with the regex, you can manually invoke &lt;a href=&quot;regex#recompile/1&quot;&gt;&lt;code&gt;Regex.recompile/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;regex#recompile!/1&quot;&gt;&lt;code&gt;Regex.recompile!/1&lt;/code&gt;&lt;/a&gt; to perform a runtime version check and recompile the regex if necessary.</source>
          <target state="translated">현재 시스템과 다른 시스템에서 실행 중이고 정규식과 여러 번 일치하는 것을 알고 있으면 &lt;a href=&quot;regex#recompile/1&quot;&gt; &lt;code&gt;Regex.recompile/1&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;regex#recompile!/1&quot;&gt; &lt;code&gt;Regex.recompile!/1&lt;/code&gt; &lt;/a&gt; 을 수동으로 호출 하여 런타임 버전 확인을 수행하고 정규식을 다시 컴파일 할 수 있습니다 필요하다면.</target>
        </trans-unit>
        <trans-unit id="3c864040fa40407fd79ba39543ee8e3143a0a20c" translate="yes" xml:space="preserve">
          <source>If you need a general dictionary, use the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module. If you need to manipulate keyword lists, use &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반 사전이 필요한 경우 &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 모듈을 사용하십시오 . 당신이 키워드 목록을 조작해야하는 경우, 사용 &lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89167dae9b93318185a943b4d7ef66af8fd1ecaf" translate="yes" xml:space="preserve">
          <source>If you need to convert a tuple or a module child specification to a map or modify a child specification, you can use the &lt;a href=&quot;supervisor#child_spec/2&quot;&gt;&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt;&lt;/a&gt; function. For example, to run the stack with a different &lt;code&gt;:id&lt;/code&gt; and a &lt;code&gt;:shutdown&lt;/code&gt; value of 10 seconds (10_000 milliseconds):</source>
          <target state="translated">튜플 또는 모듈 하위 스펙을 맵으로 변환하거나 하위 스펙을 수정해야하는 경우 &lt;a href=&quot;supervisor#child_spec/2&quot;&gt; &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; &lt;/a&gt; 함수를 사용할 수 있습니다 . 예를 들어, 다른 &lt;code&gt;:id&lt;/code&gt; 및 10 초 (10_000 밀리 초) 의 &lt;code&gt;:shutdown&lt;/code&gt; 값으로 스택을 실행하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ad76921951319e02147caba8a55f21b979bd0dc" translate="yes" xml:space="preserve">
          <source>If you need to pass options to the Elixir executable at the same time you use &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt;, it can be done as follows:</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt; 을 사용하는 동시에 옵션을 Elixir 실행 파일로 전달해야하는 경우 다음과 같이 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6c0541d61f0fa3dc5971ad5a9aedc3239c20f25" translate="yes" xml:space="preserve">
          <source>If you open up &lt;code&gt;rel/env.sh.eex&lt;/code&gt;, you will see:</source>
          <target state="translated">&lt;code&gt;rel/env.sh.eex&lt;/code&gt; 를 열면 다음이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="13001202c030e74a6a243756fd13162b4aa903b4" translate="yes" xml:space="preserve">
          <source>If you pass &lt;code&gt;:trim_bom&lt;/code&gt; in the modes parameter, the stream will trim UTF-8, UTF-16 and UTF-32 byte order marks when reading from file.</source>
          <target state="translated">modes 매개 변수에서 &lt;code&gt;:trim_bom&lt;/code&gt; 을 전달 하면 파일에서 읽을 때 스트림에서 UTF-8, UTF-16 및 UTF-32 바이트 순서 표시를 자릅니다.</target>
        </trans-unit>
        <trans-unit id="728af62f46ec9153dd25f06ee03542653209b55d" translate="yes" xml:space="preserve">
          <source>If you prefer to use only operators or skip them, you can pass the following options:</source>
          <target state="translated">연산자 만 사용하거나 건너 뛰려면 다음 옵션을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd3676cec1bf0b821202c618090e6007102597bd" translate="yes" xml:space="preserve">
          <source>If you revisit the &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt; implementation, you will remember it simply passes the options to GenServer:</source>
          <target state="translated">&lt;code&gt;KV.Registry.start_link/1&lt;/code&gt; 구현 을 다시 방문 하면 옵션을 GenServer에 전달한다는 것을 기억할 것입니다.</target>
        </trans-unit>
        <trans-unit id="c5d6222828dfd649eaac97782a9142f48d5d1965" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;bin/foo start&lt;/code&gt;, it will start the system using a short name (&lt;code&gt;--sname&lt;/code&gt;) equal to the release name, which in this case is &lt;code&gt;foo&lt;/code&gt;. The next step is to start a system named &lt;code&gt;bar&lt;/code&gt;, so we can connect &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; together, like we did in the previous chapter. But before we achieve this, let&amp;rsquo;s talk a bit about the benefits of releases.</source>
          <target state="translated">&lt;code&gt;bin/foo start&lt;/code&gt; 를 실행 하면 릴리스 이름과 동일한 짧은 이름 ( &lt;code&gt;--sname&lt;/code&gt; )을 사용하여 시스템이 시작됩니다 ( 이 경우 &lt;code&gt;foo&lt;/code&gt; ) . 다음 단계는 &lt;code&gt;bar&lt;/code&gt; 라는 시스템을 시작하는 것이므로 이전 장에서했던 것처럼 &lt;code&gt;foo&lt;/code&gt; 와 &lt;code&gt;bar&lt;/code&gt; 를 함께 연결할 수 있습니다 . 그러나 이것을 달성하기 전에 릴리스의 이점에 대해 조금 이야기 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="b99f38f9001edc5d832c83870cb64c18a6a5f599" translate="yes" xml:space="preserve">
          <source>If you start &lt;code&gt;bar&lt;/code&gt; while &lt;code&gt;foo&lt;/code&gt; is still running, you will see an error like the error below happen 5 times, before the application finally shuts down:</source>
          <target state="translated">당신이 시작하면 &lt;code&gt;bar&lt;/code&gt; 하면서 &lt;code&gt;foo&lt;/code&gt; 아직 실행 오류가 아래의 응용 프로그램 마지막으로 닫힌다 다운 전에 5 번 일이 같은 오류가 표시됩니다</target>
        </trans-unit>
        <trans-unit id="b481bb0915de73d372e211939b206d16352c309c" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;message&lt;/code&gt;, information about the values will automatically be appended to it.</source>
          <target state="translated">당신이 제공하는 경우 &lt;code&gt;message&lt;/code&gt; , 값에 대한 정보가 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b5d18cb7539ec0d5066e34df4b08df26b2985b68" translate="yes" xml:space="preserve">
          <source>If you try to run our new macro, you will notice it won't even compile, complaining that the variables &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; do not exist. This is because of the ambiguity: &lt;code&gt;unquote(k)&lt;/code&gt; can either be an unquote fragment, as previously, or a regular unquote as in &lt;code&gt;unquote(kv)&lt;/code&gt;.</source>
          <target state="translated">새 매크로를 실행하려고하면 변수 &lt;code&gt;k&lt;/code&gt; 와 &lt;code&gt;v&lt;/code&gt; 가 존재하지 않는다고 불평하는 컴파일조차 하지 않습니다. 이 때문에 모호하다 &lt;code&gt;unquote(k)&lt;/code&gt; 이전과 같이, 어느 쪽 맺다 단편이거나, 마찬가지로 정규 맺다 &lt;code&gt;unquote(kv)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3166b78eca5a26a7eac84dac5d70e8123ee75f4d" translate="yes" xml:space="preserve">
          <source>If you try to use &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt; on chardata, it will result in an argument error. For example, let's try to put a codepoint that is not representable with one byte, like &lt;code&gt;?&amp;pi;&lt;/code&gt;, inside IO data:</source>
          <target state="translated">&lt;a href=&quot;#iodata_to_binary/1&quot;&gt; &lt;code&gt;iodata_to_binary/1&lt;/code&gt; &lt;/a&gt; 을 사용하려고 하면 인수 오류가 발생합니다. 예를 들어, IO 데이터 내에 &lt;code&gt;?&amp;pi;&lt;/code&gt; 와 같이 1 바이트로 표현할 수없는 코드 포인트를 넣으려고합니다 .</target>
        </trans-unit>
        <trans-unit id="6388f463dc6fcda17ad270beeb69b562f1892d55" translate="yes" xml:space="preserve">
          <source>If you want the task to always be restarted:</source>
          <target state="translated">작업을 항상 다시 시작하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2e6f3a865c14b0ab4a00bc5b2ae75499da91323c" translate="yes" xml:space="preserve">
          <source>If you want to capture a function from a module, you can do &lt;code&gt;&amp;amp;Module.function()&lt;/code&gt;:</source>
          <target state="translated">모듈에서 함수를 캡처하려면 &lt;code&gt;&amp;amp;Module.function()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f5f07477ffa4335e8ddfc815683832c8430bb08" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted float directly to a float, &lt;a href=&quot;string#to_float/1&quot;&gt;&lt;code&gt;String.to_float/1&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">문자열 형식의 부동 소수점을 부동 소수점으로 직접 변환하려면 대신 &lt;a href=&quot;string#to_float/1&quot;&gt; &lt;code&gt;String.to_float/1&lt;/code&gt; 을&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1f915523fedc99105cfc5944c2a0f3c36308efa" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted integer directly to an integer, &lt;a href=&quot;string#to_integer/1&quot;&gt;&lt;code&gt;String.to_integer/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;string#to_integer/2&quot;&gt;&lt;code&gt;String.to_integer/2&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="translated">문자열 형식의 정수를 직접 정수로 변환하려면 대신 &lt;a href=&quot;string#to_integer/1&quot;&gt; &lt;code&gt;String.to_integer/1&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;string#to_integer/2&quot;&gt; &lt;code&gt;String.to_integer/2&lt;/code&gt; 를&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fea9eb1c1234b827775e497ef0f42a61c69dfa13" translate="yes" xml:space="preserve">
          <source>If you want to copy contents from an IO device to another device or do a straight copy from a source to a destination without preserving modes, check &lt;a href=&quot;#copy/3&quot;&gt;&lt;code&gt;copy/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">보존하지 않고 IO 장치에서 다른 장치로 내용을 복사하거나 소스에서 대상으로 직접 복사하려면 &lt;a href=&quot;#copy/3&quot;&gt; &lt;code&gt;copy/3&lt;/code&gt; &lt;/a&gt; 대신 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="b19bfe43f6139c3e91cf27f55ce846cdfcd3e3c1" translate="yes" xml:space="preserve">
          <source>If you want to customize formatting through a custom formatter, you can pass a &lt;code&gt;{module, function}&lt;/code&gt; tuple as the &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 포맷터를 통해 형식을 사용자 정의하려는 경우 &lt;code&gt;{module, function}&lt;/code&gt; 튜플을 &lt;code&gt;pattern&lt;/code&gt; 으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65bb6ace50313174bd1da312015129749bbdebb7" translate="yes" xml:space="preserve">
          <source>If you want to denote that keys that were not previously defined in the map are allowed, it is common to end a map type with &lt;code&gt;optional(any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="translated">이전에 맵에서 정의되지 않은 키가 허용됨을 표시하려면 &lt;code&gt;optional(any) =&amp;gt; any&lt;/code&gt; 로 맵 유형을 종료하는 것이 일반적 입니다.</target>
        </trans-unit>
        <trans-unit id="c535a2a3105fc470fcf848d917b271f0d69918bc" translate="yes" xml:space="preserve">
          <source>If you want to keep a custom type private, you can use the &lt;code&gt;@typep&lt;/code&gt; directive instead of &lt;code&gt;@type&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 유형을 비공개로 유지하려면 &lt;code&gt;@type&lt;/code&gt; 대신 &lt;code&gt;@typep&lt;/code&gt; 지시문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6270ce3f8ed8957cf75b8c1784c6e548f99f8963" translate="yes" xml:space="preserve">
          <source>If you want to pattern match against an existing variable, you need to use the &lt;a href=&quot;#%255E/1&quot;&gt;&lt;code&gt;^/1&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">기존 변수와 패턴 일치를하려면 &lt;a href=&quot;#%255E/1&quot;&gt; &lt;code&gt;^/1&lt;/code&gt; &lt;/a&gt; 연산자 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0120649e8c4e2ba95fe6dca09a77ff652ec92d44" translate="yes" xml:space="preserve">
          <source>If you want to pattern match against an existing variable, you need to use the &lt;code&gt;^&lt;/code&gt; operator:</source>
          <target state="translated">기존 변수와 패턴 일치를하려면 &lt;code&gt;^&lt;/code&gt; 연산자 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8611f45920c0ede3319c28e69a832c8f54905818" translate="yes" xml:space="preserve">
          <source>If you want to perform ceil operation on other decimal places, use &lt;a href=&quot;float#ceil/2&quot;&gt;&lt;code&gt;Float.ceil/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">다른 소수점 이하 자리에서 ceil 작업을 수행하려면 &lt;a href=&quot;float#ceil/2&quot;&gt; &lt;code&gt;Float.ceil/2&lt;/code&gt; 를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f71b7086446556c1e0c878a9ce96ae97c6d27fc0" translate="yes" xml:space="preserve">
          <source>If you want to perform floor operation on other decimal places, use &lt;a href=&quot;float#floor/2&quot;&gt;&lt;code&gt;Float.floor/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">다른 소수 자릿수에서 바닥 작업을 수행하려면 &lt;a href=&quot;float#floor/2&quot;&gt; &lt;code&gt;Float.floor/2&lt;/code&gt; 를&lt;/a&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e7d23f8f45e8ee5b1da8fce75c5c1d7be726d5c9" translate="yes" xml:space="preserve">
          <source>If you want to perform floored integer division (rounding towards negative infinity), use &lt;a href=&quot;integer#floor_div/2&quot;&gt;&lt;code&gt;Integer.floor_div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">바닥 정수 나누기를 수행하려면 (음의 무한대로 반올림) 대신 &lt;a href=&quot;integer#floor_div/2&quot;&gt; &lt;code&gt;Integer.floor_div/2&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7d5cba5ee293ef2a94c294f0400855682db25758" translate="yes" xml:space="preserve">
          <source>If you want to perform truncated integer division (rounding towards zero), use &lt;a href=&quot;kernel#div/2&quot;&gt;&lt;code&gt;Kernel.div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">잘린 정수 나누기 (0으로 반올림)를 수행하려면 대신 &lt;a href=&quot;kernel#div/2&quot;&gt; &lt;code&gt;Kernel.div/2&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="097c0e312bb8668d5ea944da5700770a1becb6c4" translate="yes" xml:space="preserve">
          <source>If you want to purge all log calls from an application named &lt;code&gt;:foo&lt;/code&gt; and only keep errors from &lt;code&gt;Bar.foo/3&lt;/code&gt;, you can set up two different matches:</source>
          <target state="translated">&lt;code&gt;:foo&lt;/code&gt; 라는 응용 프로그램에서 모든 로그 호출을 제거하고 &lt;code&gt;Bar.foo/3&lt;/code&gt; 에서만 오류를 유지 하려면 두 가지 다른 일치 항목을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d73b5161b517adda283c3e0c50a4ecfba748837" translate="yes" xml:space="preserve">
          <source>If you want to recompile an existing module, check &lt;a href=&quot;#r/1&quot;&gt;&lt;code&gt;r/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">기존 모듈을 다시 컴파일하려면 &lt;a href=&quot;#r/1&quot;&gt; &lt;code&gt;r/1&lt;/code&gt; 을&lt;/a&gt; 대신 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="1770175208fe6cb10e9c451baa7570e45537e962" translate="yes" xml:space="preserve">
          <source>If you want to reload a single module, consider using &lt;code&gt;r(ModuleName)&lt;/code&gt; instead.</source>
          <target state="translated">단일 모듈을 다시로드하려면 &lt;code&gt;r(ModuleName)&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="22937dca14ad8e678a5773e217bdaf60e9e08640" translate="yes" xml:space="preserve">
          <source>If you want to remove all duplicated elements, regardless of order, see &lt;a href=&quot;#uniq/1&quot;&gt;&lt;code&gt;uniq/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">순서에 관계없이 모든 중복 요소를 제거하려면 &lt;a href=&quot;#uniq/1&quot;&gt; &lt;code&gt;uniq/1&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ac9b92a3ff486c5ca2aa293f505af60c2ce005a" translate="yes" xml:space="preserve">
          <source>If you want to run tests manually, you can set the &lt;code&gt;:autorun&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt; and use &lt;a href=&quot;#run/0&quot;&gt;&lt;code&gt;run/0&lt;/code&gt;&lt;/a&gt; to run tests.</source>
          <target state="translated">테스트를 수동으로 실행하려면 &lt;code&gt;:autorun&lt;/code&gt; 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정하고 &lt;a href=&quot;#run/0&quot;&gt; &lt;code&gt;run/0&lt;/code&gt; &lt;/a&gt; 을 사용 하여 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9cfb2104d8a7fbed8970b4e565fd893c81bbbd7" translate="yes" xml:space="preserve">
          <source>If you want to search for both &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.app&lt;/code&gt; files, you could do:</source>
          <target state="translated">&lt;code&gt;.beam&lt;/code&gt; 및 &lt;code&gt;.app&lt;/code&gt; 파일 을 모두 검색 하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e20d3f7642e2bc2878445510d6350ffeaed9f321" translate="yes" xml:space="preserve">
          <source>If you want to specify more than one variable, you separate them by a comma.</source>
          <target state="translated">둘 이상의 변수를 지정하려면 쉼표로 구분하십시오.</target>
        </trans-unit>
        <trans-unit id="1680d4186a75a98ad990b5523a395b408476ac2a" translate="yes" xml:space="preserve">
          <source>If you want to unquote a value that is not a quoted expression, such as a map, you need to call &lt;a href=&quot;macro#escape/1&quot;&gt;&lt;code&gt;Macro.escape/1&lt;/code&gt;&lt;/a&gt; before:</source>
          <target state="translated">따옴표로 묶은식이 아닌 값 (예 :지도)을 인용하지 않으 &lt;a href=&quot;macro#escape/1&quot;&gt; &lt;code&gt;Macro.escape/1&lt;/code&gt; &lt;/a&gt; 먼저 Macro.escape / 1 을 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b27dac4f0c111d42a9f9a5c0743a540f0cc92e81" translate="yes" xml:space="preserve">
          <source>If you wish to find out more about GenServers, the Elixir Getting Started guide provides a tutorial-like introduction. The documentation and links in Erlang can also provide extra insight.</source>
          <target state="translated">GenServer에 대한 자세한 내용을 보려면 Elixir 시작 안내서에서 자습서와 같은 소개를 제공합니다. Erlang의 문서와 링크는 추가적인 통찰력을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d47bd8dadb23934d4b2666cf77ccc81ac30266c" translate="yes" xml:space="preserve">
          <source>If you wish to use another value for the accumulator, use &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">누산기에 다른 값을 사용하려면 &lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0943f45dd0efc661e7f07bd6255b9ee24dc17524" translate="yes" xml:space="preserve">
          <source>If you would like to get the result of evaluating file rather than the modules defined in it, see &lt;a href=&quot;#eval_file/2&quot;&gt;&lt;code&gt;eval_file/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일에 정의 된 모듈이 아닌 파일을 평가 한 결과를 얻으려면 &lt;a href=&quot;#eval_file/2&quot;&gt; &lt;code&gt;eval_file/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe37a76c869eaf7d64eb125b004dacbfd79cc33b" translate="yes" xml:space="preserve">
          <source>If you would rather enable it on your system as a whole, you can use the &lt;code&gt;ERL_AFLAGS&lt;/code&gt; environment variable and make sure that it is set accordingly on your terminal/shell configuration.</source>
          <target state="translated">시스템에서 전체적으로 사용 가능하게하려면 &lt;code&gt;ERL_AFLAGS&lt;/code&gt; 환경 변수를 사용하여 터미널 / 쉘 구성에 따라 설정되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="31456477d49264f6615f64085ad9c83e259679bd" translate="yes" xml:space="preserve">
          <source>If your Git repository requires authentication, such as basic username:password HTTP authentication via URLs, it can be achieved via Git configuration, keeping the access rules outside of source control.</source>
          <target state="translated">Git 리포지토리에 URL을 통한 기본 username : password HTTP 인증과 같은 인증이 필요한 경우 Git 구성을 통해 액세스 규칙을 유지하면서 소스 제어 외부에 액세스 규칙을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5250542055685fe9ce8faf48f1dcf6cf349fd3b" translate="yes" xml:space="preserve">
          <source>If your application does not have a supervision tree, one can be added by changing &lt;code&gt;def application&lt;/code&gt; inside &lt;code&gt;mix.exs&lt;/code&gt; to include a &lt;code&gt;:mod&lt;/code&gt; key with the application callback name:</source>
          <target state="translated">응용 프로그램에 감독 트리가없는 경우 &lt;code&gt;mix.exs&lt;/code&gt; 내에서 &lt;code&gt;def application&lt;/code&gt; 을 변경 하여 응용 프로그램 콜백 이름과 함께 &lt;code&gt;:mod&lt;/code&gt; 키 를 포함 시켜 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79acd423fb1e6c91580bcc6a424e71a397cbe715" translate="yes" xml:space="preserve">
          <source>If your implementation passes options or if you are generating custom code based on the struct, you will also need to implement a macro defined as &lt;code&gt;__deriving__(module, struct, options)&lt;/code&gt; to get the options that were passed.</source>
          <target state="translated">구현이 옵션을 전달하거나 구조체를 기반으로 사용자 정의 코드를 생성하는 경우 &lt;code&gt;__deriving__(module, struct, options)&lt;/code&gt; 로 정의 된 매크로를 구현하여 전달 된 옵션을 가져와야 합니다.</target>
        </trans-unit>
        <trans-unit id="1087391025d5c5314dde0fa06b5f87e55efb46aa" translate="yes" xml:space="preserve">
          <source>If your use case requires exactly what GenEvent provided, or you have to integrate with an existing &lt;code&gt;:gen_event&lt;/code&gt;-based system, you can still use the &lt;a href=&quot;http://erlang.org/doc/man/gen_event.html&quot;&gt;&lt;code&gt;:gen_event&lt;/code&gt;&lt;/a&gt; Erlang module.</source>
          <target state="translated">사용 사례에 GenEvent가 제공 한 것이 정확히 필요하거나 기존 &lt;code&gt;:gen_event&lt;/code&gt; 기반 시스템 과 통합 해야하는 경우 에도 여전히 &lt;a href=&quot;http://erlang.org/doc/man/gen_event.html&quot;&gt; &lt;code&gt;:gen_event&lt;/code&gt; &lt;/a&gt; Erlang 모듈을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ef21699df7b35a736d32d74888718170a41c693" translate="yes" xml:space="preserve">
          <source>If, for some reason, the current working directory cannot be retrieved, this function returns the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">어떤 이유로 현재 작업 디렉토리를 검색 할 수없는 경우이 함수는 주어진 &lt;code&gt;path&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="7f29cc51be005a79b079e12bf1ac5f22f7d2dcb7" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at midnight, return {0, 1}.</source>
          <target state="translated">캘린더에서 새 날이 자정에 시작되면 {0, 1}을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="41c5fa5884384a5740f83d50fb3866ac1d3665b0" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at noon, return {1, 2}.</source>
          <target state="translated">캘린더에서 새 날이 정오에 시작되면 {1, 2}를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="8f85da886f46e171f187e86eea72582fd0f8930c" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at sunrise, return {1, 4}.</source>
          <target state="translated">캘린더에서 일출에 새로운 날이 시작되면 {1, 4}를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="0d2c4953da7d60583c85fece795d7ebe8ed34cb1" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at sunset, return {3, 4}.</source>
          <target state="translated">캘린더에서 새 날이 일몰에 시작되면 {3, 4}를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="10cb7a9f4dc8fd31623acf09d7d8af1483fab624" translate="yes" xml:space="preserve">
          <source>If, later, the &lt;code&gt;Bar&lt;/code&gt; module is moved outside the &lt;code&gt;Foo&lt;/code&gt; module definition, it must be referenced by its full name (&lt;code&gt;Foo.Bar&lt;/code&gt;) or an alias must be set using the &lt;code&gt;alias&lt;/code&gt; directive discussed above.</source>
          <target state="translated">나중에 &lt;code&gt;Bar&lt;/code&gt; 모듈이 &lt;code&gt;Foo&lt;/code&gt; 모듈 정의 외부로 이동 된 경우 전체 이름 ( &lt;code&gt;Foo.Bar&lt;/code&gt; ) 으로 참조 되거나 위에서 설명한 &lt;code&gt;alias&lt;/code&gt; 지시문을 사용하여 별명을 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d7beb7df4077fd4d4544fa6a837476c871ba893d" translate="yes" xml:space="preserve">
          <source>If, while the code is executing, the system clock changes, some code that executed in 1 second may be reported as taking over 1 hour! To address such concerns, the VM provides a monotonic time via &lt;a href=&quot;system#monotonic_time/0&quot;&gt;&lt;code&gt;System.monotonic_time/0&lt;/code&gt;&lt;/a&gt; which never decreases and does not leap:</source>
          <target state="translated">코드가 실행되는 동안 시스템 시계가 변경되면 1 초 안에 실행 된 일부 코드가 1 시간 이상 걸린 것으로보고 될 수 있습니다! 이러한 문제를 해결하기 위해 VM은 &lt;a href=&quot;system#monotonic_time/0&quot;&gt; &lt;code&gt;System.monotonic_time/0&lt;/code&gt; &lt;/a&gt; 을 통해 단조로운 시간을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="acce89fb4ebef796946f7cb6a71ce1c0793fa8d9" translate="yes" xml:space="preserve">
          <source>Image: negative. Swap foreground and background.</source>
          <target state="translated">이미지 : 부정적. 전경과 배경을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="2554c2edabb99cac5d1195a237820679f650e785" translate="yes" xml:space="preserve">
          <source>Image: positive. Normal foreground and background.</source>
          <target state="translated">이미지 : 긍정적. 정상적인 전경과 배경.</target>
        </trans-unit>
        <trans-unit id="b4974ec0729731cbfc104f4eeb6f171651724046" translate="yes" xml:space="preserve">
          <source>Imagine a module uses a specialized list implemented in &lt;code&gt;Math.List&lt;/code&gt;. The &lt;code&gt;alias&lt;/code&gt; directive allows referring to &lt;code&gt;Math.List&lt;/code&gt; just as &lt;code&gt;List&lt;/code&gt; within the module definition:</source>
          <target state="translated">모듈이 &lt;code&gt;Math.List&lt;/code&gt; 에서 구현 된 특수 목록을 사용한다고 상상해보십시오 . &lt;code&gt;alias&lt;/code&gt; 지시어를 참조 허용 &lt;code&gt;Math.List&lt;/code&gt; 것처럼 &lt;code&gt;List&lt;/code&gt; 모듈 정의 내에서 :</target>
        </trans-unit>
        <trans-unit id="0c6d0807e9d9e68c71a2dfa2e6c744532d48a480" translate="yes" xml:space="preserve">
          <source>Imagine someone implements &lt;code&gt;Calendar.Holocene&lt;/code&gt;, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</source>
          <target state="translated">누군가 가 현재 Gregorian 연도에 정확히 10,000 년을 추가하는 Gregorian 달력을 기반으로하는 &lt;code&gt;Calendar.Holocene&lt;/code&gt; 을 구현한다고 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="ae47eabc88af2ef4455eb932e8ea60f7ae332748" translate="yes" xml:space="preserve">
          <source>Imagine the given &quot;old&quot; code:</source>
          <target state="translated">주어진 &quot;이전&quot;코드를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="52ac66ba0efe559bd54e9f534310fa769ff5fac4" translate="yes" xml:space="preserve">
          <source>Imagine the situation you have a quoted expression and you want to inject it inside some quote. The first attempt would be:</source>
          <target state="translated">당신이 인용 된 표현을 가지고 있고 그것을 인용문 안에 넣기를 원한다고 상상해보십시오. 첫 번째 시도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f60dc9c31d90f01f4ada0187787c8518ff7e6336" translate="yes" xml:space="preserve">
          <source>Imagine you have a directory called &lt;code&gt;projects&lt;/code&gt; with three Elixir projects inside of it: &lt;code&gt;elixir&lt;/code&gt;, &lt;code&gt;ex_doc&lt;/code&gt;, and &lt;code&gt;plug&lt;/code&gt;. You can find all &lt;code&gt;.beam&lt;/code&gt; files inside the &lt;code&gt;ebin&lt;/code&gt; directory of each project as follows:</source>
          <target state="translated">당신이라는 디렉토리가 상상 &lt;code&gt;projects&lt;/code&gt; : 그 안에 3 개 개의 엘릭서 프로젝트와 &lt;code&gt;elixir&lt;/code&gt; , &lt;code&gt;ex_doc&lt;/code&gt; 및 &lt;code&gt;plug&lt;/code&gt; . 다음과 같이 각 프로젝트 의 &lt;code&gt;ebin&lt;/code&gt; 디렉토리에서 모든 &lt;code&gt;.beam&lt;/code&gt; 파일을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78e853aca214a1bc65ac8ef6110f03573d680e17" translate="yes" xml:space="preserve">
          <source>Imagine you have the following structure:</source>
          <target state="translated">다음과 같은 구조를 가지고 있다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="e874a03e71d708ca4e25914c4864e7d0682296da" translate="yes" xml:space="preserve">
          <source>Immediately halts the Erlang runtime system.</source>
          <target state="translated">Erlang 런타임 시스템을 즉시 정지시킵니다.</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="1ef5a932d18820b4b0e243f0726d914bc0a7ff10" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Any&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Any&lt;/code&gt; 구현</target>
        </trans-unit>
        <trans-unit id="5796eba4ad579f1726f97515a9ac4256c827ceb8" translate="yes" xml:space="preserve">
          <source>Implementing behaviours</source>
          <target state="translated">행동 구현</target>
        </trans-unit>
        <trans-unit id="b465297e29160eecd675375f9f56fd85c2f30272" translate="yes" xml:space="preserve">
          <source>Implementing functions like &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#filter/2&quot;&gt;&lt;code&gt;filter/2&lt;/code&gt;&lt;/a&gt; and others are a good exercise for understanding the power behind &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;. When an operation cannot be expressed by any of the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module, developers will most likely resort to &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#map/2&quot;&gt; &lt;code&gt;map/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#filter/2&quot;&gt; &lt;code&gt;filter/2&lt;/code&gt; &lt;/a&gt; 등의 기능을 구현 하는 것은 &lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt; 의 힘을 이해하기위한 좋은 연습입니다 . &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈 의 함수로 연산을 표현할 수없는 경우 개발자는 대부분 &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; &lt;/a&gt; 를 줄이려고 합니다.</target>
        </trans-unit>
        <trans-unit id="a11cbfe39e0739e620b6472396d552890b65f2b5" translate="yes" xml:space="preserve">
          <source>Implenting the behaviour explicitly without calling &lt;a href=&quot;kernel.specialforms#super/1&quot;&gt;&lt;code&gt;super/1&lt;/code&gt;&lt;/a&gt; (v1.0)</source>
          <target state="translated">&lt;a href=&quot;kernel.specialforms#super/1&quot;&gt; &lt;code&gt;super/1&lt;/code&gt; &lt;/a&gt; (v1.0) 을 호출하지 않고 명시 적으로 동작 구현</target>
        </trans-unit>
        <trans-unit id="6ee8b57e8a1146e8195323d5ab0ac1b28d4bf4d5" translate="yes" xml:space="preserve">
          <source>Important: do &lt;strong&gt;not&lt;/strong&gt; use this function on IO devices in Unicode mode as it will write the wrong data. In particular, the standard IO device is set to Unicode by default, so writing to stdio with this function will likely result in the wrong data being sent down the wire.</source>
          <target state="translated">중요 사항 : 유니 코드 모드의 IO 장치에서는이 기능을 사용 하지 &lt;strong&gt;마십시오&lt;/strong&gt; . 잘못된 데이터가 기록 될 수 있습니다. 특히 표준 IO 장치는 기본적으로 유니 코드로 설정되어 있으므로이 기능을 사용하여 stdio에 쓰면 잘못된 데이터가 유선으로 전송 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ee893c3406c5d187c4ad8d2a37d2b2305b2b378" translate="yes" xml:space="preserve">
          <source>Imports configuration from the given file.</source>
          <target state="translated">주어진 파일에서 구성을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="82d4e22f3ba03649c647ac0cbd6a6f1c75820475" translate="yes" xml:space="preserve">
          <source>Imports functions and macros from other modules.</source>
          <target state="translated">다른 모듈에서 함수와 매크로를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ce9dd8afb038714101f1fa2419f409800104c52e" translate="yes" xml:space="preserve">
          <source>Imports: new functions may be added to the &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module, which is auto-imported. They may collide with local functions defined in your modules. Collisions can be resolved in a backwards compatible fashion using &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; with a list of all functions you don't want to be imported from &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;. We reserve the right to do such additions.</source>
          <target state="translated">가져 오기 : 새로운 기능이 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 모듈에 추가 될 수 있으며 , 자동으로 가져 옵니다 . 모듈에 정의 된 로컬 기능과 충돌 할 수 있습니다. &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; 사용하여 충돌을 이전 버전과 호환되는 방식으로 해결할 수 있습니다 . [...] 은 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 에서 임포트하지 않으려는 모든 기능 목록을 포함합니다 . 우리는 그러한 추가를 할 권리를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="6e98571e8ce38e7d695efe3ecee0b6e80bc755f3" translate="yes" xml:space="preserve">
          <source>Improper lists are never deemed as charlists.</source>
          <target state="translated">부적절한 목록은 절대 문자 목록으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fee52b5aef3534510640142b73884d80c6b12f47" translate="yes" xml:space="preserve">
          <source>Improper lists are not printable, even if made only of ASCII characters:</source>
          <target state="translated">ASCII 문자만으로도 잘못된 목록을 인쇄 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c0d4390b7f52bc3219b6b297954aa2698cd9b21f" translate="yes" xml:space="preserve">
          <source>In &amp;ldquo;Basic types&amp;rdquo;, we learned about strings and used the &lt;code&gt;is_binary/1&lt;/code&gt; function for checks:</source>
          <target state="translated">&amp;ldquo;기본 유형&amp;rdquo;에서 문자열에 대해 배웠고 &lt;code&gt;is_binary/1&lt;/code&gt; 함수를 검사에 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="96d506b973cc16f3c887c604680a4f164c5bcb6d" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;keywords-and-maps&quot;&gt;chapter 7&lt;/a&gt; we learned about maps:</source>
          <target state="translated">에서 &lt;a href=&quot;keywords-and-maps&quot;&gt;7 장&lt;/a&gt; 우리는지도에 대해 배웠습니다 :</target>
        </trans-unit>
        <trans-unit id="b97f6da29f9d3821af09c9644f82422d41ba54db" translate="yes" xml:space="preserve">
          <source>In Elixir we group several functions into modules. We&amp;rsquo;ve already used many different modules in the previous chapters such as &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;the &lt;code&gt;String&lt;/code&gt; module&lt;/a&gt;:</source>
          <target state="translated">Elixir에서는 여러 기능을 모듈로 그룹화합니다. 이전 장 &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;에서 &lt;code&gt;String&lt;/code&gt; 모듈&lt;/a&gt; 과 같은 다양한 모듈을 이미 사용했습니다 .</target>
        </trans-unit>
        <trans-unit id="8852e2c2070399b66b8e6aac0c4ebb222e49ff1d" translate="yes" xml:space="preserve">
          <source>In Elixir, &lt;code&gt;Integer.is_odd/1&lt;/code&gt; is defined as a macro so that it can be used as a guard. This means that, in order to invoke &lt;code&gt;Integer.is_odd/1&lt;/code&gt;, we need to first require the &lt;code&gt;Integer&lt;/code&gt; module.</source>
          <target state="translated">Elixir에서 &lt;code&gt;Integer.is_odd/1&lt;/code&gt; 은 매크로로 정의되어 가드로 사용될 수 있습니다. 즉, &lt;code&gt;Integer.is_odd/1&lt;/code&gt; 을 호출 하려면 먼저 &lt;code&gt;Integer&lt;/code&gt; 모듈이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="84a15dcd0ed954400244a91382ebe28f35c7326d" translate="yes" xml:space="preserve">
          <source>In Elixir, a value can be thrown and later be caught. &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; are reserved for situations where it is not possible to retrieve a value unless by using &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="translated">엘릭서에서는 값을 던져 나중에 잡을 수 있습니다. &lt;code&gt;throw&lt;/code&gt; 와 &lt;code&gt;catch&lt;/code&gt; 는하지 않는 한 사용하여 값을 검색 할 수 없습니다 상황을 위해 예약되어 &lt;code&gt;throw&lt;/code&gt; 와 &lt;code&gt;catch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0f7dc2374bd2e474c5f95f1dc00588968670f4e9" translate="yes" xml:space="preserve">
          <source>In Elixir, all code runs inside processes. Processes are isolated from each other, run concurrent to one another and communicate via message passing. Processes are not only the basis for concurrency in Elixir, but they also provide the means for building distributed and fault-tolerant programs.</source>
          <target state="translated">Elixir에서는 모든 코드가 프로세스 내에서 실행됩니다. 프로세스는 서로 분리되어 서로 동시에 실행되며 메시지 전달을 통해 통신합니다. 프로세스는 Elixir의 동시성에 대한 기초 일뿐만 아니라 분산 및 내결함성 프로그램을 구축하기위한 수단을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fcd7da208c379530ff673f8c5363361cec7ce112" translate="yes" xml:space="preserve">
          <source>In Elixir, an enumerable is any data type that implements the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol. &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;[1, 2, 3]&lt;/code&gt;), &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt;) and &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;1..3&lt;/code&gt;) are common data types used as enumerables:</source>
          <target state="translated">엘릭시르에 열거 가능한 임의 데이터 유형을 구현 그이다 &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; 에서&lt;/a&gt; 프로토콜. &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; s ( &lt;code&gt;[1, 2, 3]&lt;/code&gt; ), &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; s ( &lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt; ) 및 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; s ( &lt;code&gt;1..3&lt;/code&gt; )은 열거 형으로 사용되는 일반적인 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ad60a1595fcaea2abc6cfb534bb59968e6aa0a7d" translate="yes" xml:space="preserve">
          <source>In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Elixir에서 코드 구성은 모듈과 기능에 의해 수행되며 프로세스는 필요하지 않습니다. 예를 들어 계산기를 구현하고 모든 계산기 작업을 &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 뒤에 배치하기로 결정 했다고 가정 해보십시오 .</target>
        </trans-unit>
        <trans-unit id="aa0691e43ac9902c05a55318172be1be3b51602d" translate="yes" xml:space="preserve">
          <source>In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a GenServer:</source>
          <target state="translated">Elixir에서 코드 구성은 모듈과 기능에 의해 수행되며 프로세스는 필요하지 않습니다. 예를 들어, 계산기를 구현하고 모든 계산기 작업을 GenServer 뒤에 배치하기로 결정했다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="1a65801df985cbe3e3c9ee19ff7e4341c68a0a15" translate="yes" xml:space="preserve">
          <source>In Elixir, different data types can be compared using comparison operators:</source>
          <target state="translated">Elixir에서는 비교 연산자를 사용하여 다른 데이터 유형을 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ef291ece743ba126271fab00a84b2bf1cd10359" translate="yes" xml:space="preserve">
          <source>In Elixir, it is common to loop over an Enumerable, often filtering out some results and mapping values into another list. Comprehensions are syntactic sugar for such constructs: they group those common tasks into the &lt;code&gt;for&lt;/code&gt; special form.</source>
          <target state="translated">Elixir에서는 일반적으로 Enumerable을 반복하여 일부 결과를 필터링하고 값을 다른 목록에 매핑하는 것이 일반적입니다. 이해는 그러한 구성에 대한 구문 설탕입니다. 그들은 이러한 공통 작업 &lt;code&gt;for&lt;/code&gt; 특수 형식 으로 그룹화 합니다.</target>
        </trans-unit>
        <trans-unit id="92fa98b368b718157a766ec2a187b1b728ee06ed" translate="yes" xml:space="preserve">
          <source>In Elixir, records are used mostly in two situations:</source>
          <target state="translated">Elixir에서 레코드는 주로 두 가지 상황에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="19e018a4aa4ddd6ea9b4d083bf7991661ac6f619" translate="yes" xml:space="preserve">
          <source>In Elixir, the &lt;code&gt;=&lt;/code&gt; operator is actually called &lt;em&gt;the match operator&lt;/em&gt;. Let&amp;rsquo;s see why:</source>
          <target state="translated">Elixir에서 &lt;code&gt;=&lt;/code&gt; 연산자는 실제로 &lt;em&gt;match operator&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . 이유를 보자 :</target>
        </trans-unit>
        <trans-unit id="482c60a7cfc2af43cfa398215016e9bcabca31ff" translate="yes" xml:space="preserve">
          <source>In Elixir, this is done by a Supervisor. A Supervisor is a process that supervises other processes and restarts them whenever they crash. To do so, Supervisors manage the whole life-cycle of any supervised processes, including startup and shutdown.</source>
          <target state="translated">Elixir에서는 관리자가이를 수행합니다. 감독자는 다른 프로세스를 감독하고 충돌 할 때마다 다시 시작하는 프로세스입니다. 이를 위해 Supervisors는 시작 및 종료를 포함한 모든 감독 프로세스의 전체 수명주기를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="c6d542894f9023e77ee4252a95cfc7fdde16bf1f" translate="yes" xml:space="preserve">
          <source>In Elixir, we avoid using &lt;code&gt;try/rescue&lt;/code&gt; because &lt;strong&gt;we don&amp;rsquo;t use errors for control flow&lt;/strong&gt;. We take errors literally: they are reserved for unexpected and/or exceptional situations. In case you actually need flow control constructs, &lt;em&gt;throws&lt;/em&gt; should be used. That&amp;rsquo;s what we are going to see next.</source>
          <target state="translated">엘릭서, 우리는 사용하지 않는 &lt;code&gt;try/rescue&lt;/code&gt; 하기 때문에 &lt;strong&gt;우리가 제어 흐름에 대한 오류를 사용하지 마십시오&lt;/strong&gt; . 문자 그대로 오류가 발생합니다. 예기치 않은 상황 및 / 또는 예외적 인 상황을 위해 예약되어 있습니다. 실제로 흐름 제어 구문이 필요한 경우에는 &lt;em&gt;던지기를&lt;/em&gt; 사용해야합니다. 그것이 우리가 다음에 보게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="b26350d75961840721899e4e896ada8152ee4ff0" translate="yes" xml:space="preserve">
          <source>In Elixir, we can compare two different data types:</source>
          <target state="translated">Elixir에서는 두 가지 데이터 유형을 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99415fb48cc7bcce7ee941711b73cb718fae4683" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two idioms for checking how many items there are in a data structure: &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;. &lt;code&gt;length&lt;/code&gt; means the information must be computed. For example, &lt;code&gt;length(list)&lt;/code&gt; needs to traverse the whole list to calculate its length. On the other hand, &lt;code&gt;tuple_size(tuple)&lt;/code&gt; and &lt;code&gt;byte_size(binary)&lt;/code&gt; do not depend on the tuple and binary size as the size information is pre-computed in the data structure.</source>
          <target state="translated">Elixir에는 데이터 구조에 몇 개의 항목 ( &lt;code&gt;length&lt;/code&gt; 및 &lt;code&gt;size&lt;/code&gt; 이 있는지 확인하기위한 두 가지 관용구가 있습니다 . &lt;code&gt;length&lt;/code&gt; 는 정보를 계산해야 함을 의미합니다. 예를 들어 &lt;code&gt;length(list)&lt;/code&gt; 는 전체 목록을 가로 질러 길이를 계산해야합니다. 반면에 &lt;code&gt;tuple_size(tuple)&lt;/code&gt; 및 &lt;code&gt;byte_size(binary)&lt;/code&gt; 는 크기 정보가 데이터 구조에서 사전 계산되므로 tuple 및 binary 크기에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3be4753dceb5fddab1fdca38953766786eecc42" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two main associative data structures: keyword lists and maps. It&amp;rsquo;s time to learn more about them!</source>
          <target state="translated">Elixir에는 키워드 목록과 맵이라는 두 가지 주요 연관 데이터 구조가 있습니다. 그들에 대해 더 많이 배울 때입니다!</target>
        </trans-unit>
        <trans-unit id="6cb8d41ba02e8fc631535705b4f2e08988507e70" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two verbs for checking how many items there are in a data structure: &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;. &lt;code&gt;length&lt;/code&gt; means the information must be computed. For example, &lt;code&gt;length(list)&lt;/code&gt; needs to traverse the whole list to calculate its length. On the other hand, &lt;code&gt;tuple_size(tuple)&lt;/code&gt; and &lt;code&gt;byte_size(binary)&lt;/code&gt; do not depend on the tuple and binary size as the size information is precomputed in the data structure.</source>
          <target state="translated">Elixir에는 데이터 구조에 몇 개의 항목 ( &lt;code&gt;length&lt;/code&gt; 와 &lt;code&gt;size&lt;/code&gt; 이 있는지 확인하기위한 두 개의 동사가 있습니다 . &lt;code&gt;length&lt;/code&gt; 는 정보를 계산해야 함을 의미합니다. 예를 들어 &lt;code&gt;length(list)&lt;/code&gt; 는 전체 목록을 가로 질러 길이를 계산해야합니다. 반면, &lt;code&gt;tuple_size(tuple)&lt;/code&gt; 및 &lt;code&gt;byte_size(binary)&lt;/code&gt; 는 크기 정보가 데이터 구조에서 사전 계산되므로 tuple 및 binary 크기에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e9adf90c14fca15cafcd8d80e7a0e62f3c9bd2b" translate="yes" xml:space="preserve">
          <source>In Elixir, you can define a binary using &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Elixir에서는 &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; 를 사용하여 바이너리를 정의 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3508879bcb04190c581cc69dedcf57a9400be46d" translate="yes" xml:space="preserve">
          <source>In Erlang, this struct is represented by a &lt;code&gt;:file_info&lt;/code&gt; record. Therefore this module also provides functions for converting between the Erlang record and the Elixir struct.</source>
          <target state="translated">Erlang에서이 구조체는 &lt;code&gt;:file_info&lt;/code&gt; 레코드로 표시됩니다 . 따라서이 모듈은 Erlang 레코드와 Elixir 구조체 사이를 변환하는 기능도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="08902136d46a0efffdb0a07180738ce463f3cf44" translate="yes" xml:space="preserve">
          <source>In Mix projects, the environment of the application and its dependencies can be overridden via the &lt;code&gt;config/config.exs&lt;/code&gt; file. If you start the application with Mix, that configuration is available at compile time, and at runtime too, but take into account it is not included in the generated application resource file, and it is not available if you start the application without Mix.</source>
          <target state="translated">Mix 프로젝트에서 &lt;code&gt;config/config.exs&lt;/code&gt; 파일을 통해 애플리케이션 환경 및 해당 종속성을 재정의 할 수 있습니다 . Mix로 응용 프로그램을 시작하면 컴파일시 및 런타임에서도 해당 구성을 사용할 수 있지만 생성 된 응용 프로그램 자원 파일에 포함되지 않으며 Mix없이 응용 프로그램을 시작하면 해당 구성을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9174170a472a8f04a70eb2658745c2e8ceaf3c42" translate="yes" xml:space="preserve">
          <source>In Unix-like systems, changing the modification time may require you to be either &lt;code&gt;root&lt;/code&gt; or the owner of the file. Having write access may not be enough. In those cases, touching the file the first time (to create it) will succeed, but touching an existing file with fail with &lt;code&gt;{:error, :eperm}&lt;/code&gt;.</source>
          <target state="translated">유닉스 계열 시스템에서 수정 시간을 변경 하려면 파일의 &lt;code&gt;root&lt;/code&gt; 또는 소유자 여야 합니다. 쓰기 권한이 충분하지 않을 수 있습니다. 이 경우 파일을 처음으로 터치하면 (만들기) 성공하지만 &lt;code&gt;{:error, :eperm}&lt;/code&gt; 기존 파일을 터치하면 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="0de5ec7fc6835af5a7c8c3ee0628180b848d8db4" translate="yes" xml:space="preserve">
          <source>In a GenServer, the code above would be two separate functions, roughly like this:</source>
          <target state="translated">GenServer에서 위의 코드는 대략 다음과 같은 두 가지 기능입니다.</target>
        </trans-unit>
        <trans-unit id="bcadbac52f644d8178e01dd98a388d6072c88e19" translate="yes" xml:space="preserve">
          <source>In a distributed setup with multiple nodes, the API that accepts anonymous functions only works if the caller (client) and the agent have the same version of the caller module.</source>
          <target state="translated">다중 노드가있는 분산 설정에서 익명 기능을 허용하는 API는 호출자 (클라이언트)와 에이전트가 동일한 버전의 호출자 모듈을 가지고있는 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="93de78b9e89412d553d71ba4abbfe5315731105f" translate="yes" xml:space="preserve">
          <source>In a nutshell, a version is represented by three numbers:</source>
          <target state="translated">간단히 말해 버전은 세 가지 숫자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4de3e72994971159efbbfa51adb4f6daeb251a7f" translate="yes" xml:space="preserve">
          <source>In a nutshell, an application consists of all of the modules defined in the &lt;code&gt;.app&lt;/code&gt; file, including the &lt;code&gt;.app&lt;/code&gt; file itself. An application has generally only two directories: &lt;code&gt;ebin&lt;/code&gt;, for Elixir artefacts, such as &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.app&lt;/code&gt; files, and &lt;code&gt;priv&lt;/code&gt;, with any other artefact or asset you may need in your application.</source>
          <target state="translated">간단히 말해서, 응용 프로그램은에 정의 된 모든 모듈로 구성되어 &lt;code&gt;.app&lt;/code&gt; 포함한 파일 내용, &lt;code&gt;.app&lt;/code&gt; 파일 자체. : 응용 프로그램은 일반적으로 단지 두 개의 디렉토리가 &lt;code&gt;ebin&lt;/code&gt; 같은 비약 유물에 대한 &lt;code&gt;.beam&lt;/code&gt; 및 &lt;code&gt;.app&lt;/code&gt; 파일 및 &lt;code&gt;priv&lt;/code&gt; 에 , 당신은 당신의 응용 프로그램에 필요한 수있는 다른 인공물이나 자산과 함께합니다.</target>
        </trans-unit>
        <trans-unit id="8a78c9d971b121556059db385274a3963a89d465" translate="yes" xml:space="preserve">
          <source>In a nutshell, the first must be used when you want to keep track of the files handled by the system, to avoid the same file from being compiled multiple times. This is common in scripts.</source>
          <target state="translated">간단히 말해서, 동일한 파일이 여러 번 컴파일되지 않도록 시스템이 처리하는 파일을 추적하려는 경우 첫 번째 파일을 사용해야합니다. 이것은 스크립트에서 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="ba31b6b4506414b36091cbb58f049c0003b3112c" translate="yes" xml:space="preserve">
          <source>In a regular project, we can assemble a release by simply running &lt;code&gt;mix release&lt;/code&gt;. However, we have an umbrella project, and in such cases Elixir requires some extra input from us. Let&amp;rsquo;s see what is necessary:</source>
          <target state="translated">일반 프로젝트에서는 &lt;code&gt;mix release&lt;/code&gt; 를 실행하여 릴리스를 조립할 수 있습니다 . 그러나 우리는 엄브렐러 프로젝트를 진행하고 있으며,이 경우 Elixir는 추가적인 정보를 필요로합니다. 무엇이 필요한지 보자 :</target>
        </trans-unit>
        <trans-unit id="a9421fd8baf899a704905f1b7b921c58ff7bb458" translate="yes" xml:space="preserve">
          <source>In addition to the Elixir file extension &lt;code&gt;.ex&lt;/code&gt;, Elixir also supports &lt;code&gt;.exs&lt;/code&gt; files for scripting. Elixir treats both files exactly the same way, the only difference is in intention. &lt;code&gt;.ex&lt;/code&gt; files are meant to be compiled while &lt;code&gt;.exs&lt;/code&gt; files are used for scripting. When executed, both extensions compile and load their modules into memory, although only &lt;code&gt;.ex&lt;/code&gt; files write their bytecode to disk in the format of &lt;code&gt;.beam&lt;/code&gt; files.</source>
          <target state="translated">Elixir 파일 확장자 &lt;code&gt;.ex&lt;/code&gt; 외에도 Elixir는 스크립팅을 위해 &lt;code&gt;.exs&lt;/code&gt; 파일 도 지원합니다 . Elixir는 두 파일을 모두 같은 방식으로 취급하지만, 유일한 차이점은 의도입니다. &lt;code&gt;.ex&lt;/code&gt; 파일은 컴파일하는 동안 &lt;code&gt;.exs&lt;/code&gt; 파일은 스크립팅에 사용됩니다. &lt;code&gt;.ex&lt;/code&gt; 파일 만 바이트 코드를 &lt;code&gt;.beam&lt;/code&gt; 파일 형식으로 디스크에 기록 하지만 두 확장 모두 모듈을 컴파일하여 메모리에로드 합니다.</target>
        </trans-unit>
        <trans-unit id="96148bc0703e1fb4ea78297b10992f7426df74e8" translate="yes" xml:space="preserve">
          <source>In addition to the built-in attributes outlined above, custom attributes may also be added. Custom attributes are expressed using the &lt;a href=&quot;kernel#@/1&quot;&gt;&lt;code&gt;@/1&lt;/code&gt;&lt;/a&gt; operator followed by a valid variable name. The value given to the custom attribute must be a valid Elixir value:</source>
          <target state="translated">위에서 설명한 내장 속성 외에도 사용자 정의 속성이 추가 될 수 있습니다. 사용자 정의 속성은 &lt;a href=&quot;kernel#@/1&quot;&gt; &lt;code&gt;@/1&lt;/code&gt; &lt;/a&gt; 연산자와 유효한 변수 이름을 사용하여 표현됩니다 . 커스텀 속성에 주어진 값은 유효한 Elixir 값이어야합니다 :</target>
        </trans-unit>
        <trans-unit id="3dfd563836d0d4567f592fdf1b54449f8fc77413" translate="yes" xml:space="preserve">
          <source>In addition to the keys provided by the user via &lt;a href=&quot;logger#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt;, the following extra keys are available to the &lt;code&gt;:metadata&lt;/code&gt; list:</source>
          <target state="translated">&lt;a href=&quot;logger#metadata/1&quot;&gt; &lt;code&gt;Logger.metadata/1&lt;/code&gt; 을&lt;/a&gt; 통해 사용자가 제공 한 키 외에 다음과 같은 추가 키를 &lt;code&gt;:metadata&lt;/code&gt; 목록에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1d0e9c42e96c43f7a51f23eb3e0a63cd08fcabb" translate="yes" xml:space="preserve">
          <source>In addition to those, a double quote inside a double-quoted string needs to be escaped as &lt;code&gt;\&quot;&lt;/code&gt;, and, analogously, a single quote inside a single-quoted char list needs to be escaped as &lt;code&gt;\'&lt;/code&gt;. Nevertheless, it is better style to change delimiters as seen above than to escape them.</source>
          <target state="translated">그 외에도, 큰 따옴표로 묶인 문자열 안의 큰 따옴표는 &lt;code&gt;\&quot;&lt;/code&gt; 로 이스케이프해야하고 , 마찬가지로 작은 따옴표로 묶인 char 목록 안의 작은 따옴표는 &lt;code&gt;\'&lt;/code&gt; 로 이스케이프해야합니다 . 그럼에도 불구하고 더 나은 스타일입니다. 이스케이프를 벗어나는 것보다 위의 구분자를 변경하는 것.</target>
        </trans-unit>
        <trans-unit id="81e21312ebc75f6d03fffd3a474b80ff1f053e1d" translate="yes" xml:space="preserve">
          <source>In all of the examples above, we used binaries when writing to files. In the chapter &lt;a href=&quot;binaries-strings-and-char-lists&quot;&gt;&amp;ldquo;Binaries, strings, and charlists&amp;rdquo;&lt;/a&gt;, we mentioned how strings are made of bytes while charlists are lists with Unicode codepoints.</source>
          <target state="translated">위의 모든 예제에서 파일에 쓸 때 바이너리를 사용했습니다. &lt;a href=&quot;binaries-strings-and-char-lists&quot;&gt;&amp;ldquo;이진, 문자열 및 charlists&amp;rdquo;&lt;/a&gt; 장에서는 문자열이 바이트로 구성되는 반면 charlist는 유니 코드 코드 포인트가있는 목록에 대해 언급했습니다.</target>
        </trans-unit>
        <trans-unit id="8e799b4247b90ad4aaf06f6677263f125c9b2f4f" translate="yes" xml:space="preserve">
          <source>In any case, avoid any of the following:</source>
          <target state="translated">어쨌든 다음 중 하나를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="1589dd45f78cf7266ba6322f20d21e370ee7f5aa" translate="yes" xml:space="preserve">
          <source>In both cases, &lt;code&gt;Stack.start_link/1&lt;/code&gt; is always invoked.</source>
          <target state="translated">두 경우 모두 &lt;code&gt;Stack.start_link/1&lt;/code&gt; 이 항상 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0ea2013003c5c58a5c3f717cccfc60a91074f95a" translate="yes" xml:space="preserve">
          <source>In both cases, the command-line arguments for the script or expression are available in &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#argv/0&quot;&gt;&lt;code&gt;System.argv/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 경우 모두 스크립트 또는 표현식에 대한 명령 행 인수는 &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#argv/0&quot;&gt; &lt;code&gt;System.argv/0&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d33c9b688f2fa1ee1c39e6a6ee8a9eef85fb236" translate="yes" xml:space="preserve">
          <source>In case a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function returns a &lt;code&gt;:suspend&lt;/code&gt; accumulator, it must be explicitly handled by the caller and never leak.</source>
          <target state="translated">경우에, &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; 함수가 반환 &lt;code&gt;:suspend&lt;/code&gt; 축적을, 그것을 명시 적으로 호출 처리 및 누설하지해야합니다.</target>
        </trans-unit>
        <trans-unit id="02f1586eeab6e7c0484c69613b04bc3194eb4e79" translate="yes" xml:space="preserve">
          <source>In case a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function returns the &lt;code&gt;:suspend&lt;/code&gt; accumulator, the &lt;code&gt;:suspended&lt;/code&gt; tuple must be explicitly handled by the caller and never leak. In practice, this means regular enumeration functions just need to be concerned about &lt;code&gt;:done&lt;/code&gt; and &lt;code&gt;:halted&lt;/code&gt; results.</source>
          <target state="translated">경우에, &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; 함수가 반환 &lt;code&gt;:suspend&lt;/code&gt; 어큐뮬레이터는 &lt;code&gt;:suspended&lt;/code&gt; 튜플은 명시 적으로 호출 처리 및 누설하지해야합니다. 실제로 이것은 정규 열거 함수가 &lt;code&gt;:done&lt;/code&gt; 및 &lt;code&gt;:halted&lt;/code&gt; 결과에 관심을 가져야한다는 것을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="3377f61918ce91a5a78e38bc72a8ef4ed3572f98" translate="yes" xml:space="preserve">
          <source>In case a direct relative path cannot be found, it returns the original path.</source>
          <target state="translated">직접 상대 경로를 찾을 수없는 경우 원래 경로를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6c9cc568db359a5124dd032595b36cc1734cb7b5" translate="yes" xml:space="preserve">
          <source>In case a single file is being tested, it is possible to pass one or more specific line numbers to run only those given tests:</source>
          <target state="translated">단일 파일을 테스트하는 경우 하나 이상의 특정 줄 번호를 전달하여 지정된 테스트 만 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="702e65eacb180decf2c9dac0a4fdd10013882322" translate="yes" xml:space="preserve">
          <source>In case a switch &lt;code&gt;SWITCH&lt;/code&gt; is specified to have type &lt;code&gt;:boolean&lt;/code&gt;, it may be passed as &lt;code&gt;--no-SWITCH&lt;/code&gt; as well which will set the option to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">스위치 &lt;code&gt;SWITCH&lt;/code&gt; 가 유형 &lt;code&gt;:boolean&lt;/code&gt; 을 갖도록 지정된 경우 , 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정하는 &lt;code&gt;--no-SWITCH&lt;/code&gt; 로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="888f992f5fc265705743ba6ca955221f42ebdba1" translate="yes" xml:space="preserve">
          <source>In case any entry returns &lt;code&gt;nil&lt;/code&gt;, its key will be removed and the deletion will be considered a success.</source>
          <target state="translated">항목이 &lt;code&gt;nil&lt;/code&gt; 을 반환 하면 해당 키가 제거되고 삭제가 성공한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a72e1cfffefe65681b735eb6f7dbafbbce0c5ef9" translate="yes" xml:space="preserve">
          <source>In case any of the entries in the middle returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; will be returned as per the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">경우 중간 수익률의 항목 중 하나는 &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;nil&lt;/code&gt; 당으로 반환됩니다 &lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 모듈 :</target>
        </trans-unit>
        <trans-unit id="de3e20065397014cb42d9b910dde02ad6289d161" translate="yes" xml:space="preserve">
          <source>In case any of the entries in the middle returns &lt;code&gt;nil&lt;/code&gt;, an error will be raised when trying to access it next.</source>
          <target state="translated">중간에있는 항목 중 하나가 &lt;code&gt;nil&lt;/code&gt; 을 반환 하면 다음에 액세스하려고 할 때 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ffe6dece0fc6fa31895ca4664fd38ac481329ebd" translate="yes" xml:space="preserve">
          <source>In case it does exist, it is a no-op. Otherwise, it is built.</source>
          <target state="translated">그것이 존재하는 경우, 그것은 no-op입니다. 그렇지 않으면 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="fe785d8d01b549120d0fdba2f98502200395bc4b" translate="yes" xml:space="preserve">
          <source>In case one wants to access the original &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;, it can be done by accessing &lt;code&gt;Elixir&lt;/code&gt;:</source>
          <target state="translated">원본 &lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; 에 액세스하려는 경우 &lt;code&gt;Elixir&lt;/code&gt; 에 액세스하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3773025824eaaa4fbaabc9e17eece745001ea94" translate="yes" xml:space="preserve">
          <source>In case something goes wrong, you can also use &lt;a href=&quot;#exit/1&quot;&gt;&lt;code&gt;exit/1&lt;/code&gt;&lt;/a&gt; with a different reason:</source>
          <target state="translated">문제 가 발생하면 다른 이유로 &lt;a href=&quot;#exit/1&quot;&gt; &lt;code&gt;exit/1&lt;/code&gt; &lt;/a&gt; 을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2fa86b82adf3327a6ba51dace9ac5f0221aed458" translate="yes" xml:space="preserve">
          <source>In case the alias is generated automatically by a macro, Elixir won't emit any warnings though, since the alias was not explicitly defined.</source>
          <target state="translated">별칭이 매크로에 의해 자동으로 생성되는 경우, 별칭이 명시 적으로 정의되지 않았으므로 Elixir는 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c438ea8f1248a5429d6990102993e9d6dbcfa2ca" translate="yes" xml:space="preserve">
          <source>In case the conversion fails, it raises an &lt;a href=&quot;unicodeconversionerror&quot;&gt;&lt;code&gt;UnicodeConversionError&lt;/code&gt;&lt;/a&gt;. If a string is given, it returns the string itself.</source>
          <target state="translated">변환이 실패하면 &lt;a href=&quot;unicodeconversionerror&quot;&gt; &lt;code&gt;UnicodeConversionError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다. 문자열이 제공되면 문자열 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a15baa5f03723748dcf10b5cb52af46c921885dc" translate="yes" xml:space="preserve">
          <source>In case the file doesn't exist, an error is raised.</source>
          <target state="translated">파일이 존재하지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9aefc659b37d49c39922094af9efb51756248b09" translate="yes" xml:space="preserve">
          <source>In case the import is generated automatically by a macro, Elixir won't emit any warnings though, since the import was not explicitly defined.</source>
          <target state="translated">매크로에 의해 가져 오기가 자동으로 생성되는 경우, Elixir는 가져 오기가 명시 적으로 정의되지 않았으므로 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f7982ac3a103bc11a1e2ceb070d36fd43cc0956" translate="yes" xml:space="preserve">
          <source>In case the task process dies, the current process will exit with the same reason as the task.</source>
          <target state="translated">작업 프로세스가 종료되면 현재 프로세스는 작업과 같은 이유로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="5028298a69062b4bcef1005e365f72fcb9b4bd2c" translate="yes" xml:space="preserve">
          <source>In case the test crashes, you will see a report as follows:</source>
          <target state="translated">테스트가 충돌하는 경우 다음과 같은 보고서가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="63f761d55661dfac505485cc96ef395b1517c85a" translate="yes" xml:space="preserve">
          <source>In case there is an error while your structure is being inspected, Elixir will raise an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; error and will automatically fall back to a raw representation for printing the structure.</source>
          <target state="translated">구조를 검사하는 동안 오류가 발생하면 Elixir는 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 오류를 발생시키고 자동으로 구조를 인쇄하기위한 원시 표현으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="05066096207f29449b516520b228a698f4b4f25c" translate="yes" xml:space="preserve">
          <source>In case there is no such message, the current process hangs until a message arrives or waits until a given timeout value.</source>
          <target state="translated">그러한 메시지가없는 경우 현재 프로세스는 메시지가 도착할 때까지 또는 지정된 시간 종료 값이 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="4d02c8c3170ba0952169ceddc222a7d17ada7459" translate="yes" xml:space="preserve">
          <source>In case things are not working as expected, please include as much information as you can in your report, for example: your Elixir version, the code snippet and the error message alongside the error stacktrace. Use sites like &lt;a href=&quot;https://gist.github.com/&quot;&gt;Gist&lt;/a&gt; to paste this information.</source>
          <target state="translated">예상대로 작동하지 않는 경우 보고서에 최대한 많은 정보를 포함하십시오 (예 : Elixir 버전, 코드 스 니펫 및 오류 스택 추적과 함께 오류 메시지). 이 정보를 붙여 넣으려면 &lt;a href=&quot;https://gist.github.com/&quot;&gt;Gist&lt;/a&gt; 와 같은 사이트를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="03bcf5fae6ba2e97dc4c9b6b526c4e8e1ed5a2fc" translate="yes" xml:space="preserve">
          <source>In case you need to configure a process, the options should be passed when starting that process.</source>
          <target state="translated">프로세스를 구성해야하는 경우 해당 프로세스를 시작할 때 옵션을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="402b42bb4e09e34f8b56390600a6d4385db6ff6a" translate="yes" xml:space="preserve">
          <source>In case you need to work with bytes, take a look at the &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;&lt;code&gt;:binary&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">바이트로 작업해야 할 경우 &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt; &lt;code&gt;:binary&lt;/code&gt; 모듈을&lt;/a&gt; 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="ccc59a70627542b407463a1a5ab11815a7059a36" translate="yes" xml:space="preserve">
          <source>In case you want to automatically load &lt;strong&gt;and start&lt;/strong&gt; all of &lt;code&gt;app&lt;/code&gt;'s dependencies, see &lt;a href=&quot;#ensure_all_started/2&quot;&gt;&lt;code&gt;ensure_all_started/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;app&lt;/code&gt; 의 모든 종속성 을 자동으로로드 &lt;strong&gt;하고 시작&lt;/strong&gt; 하려면 &lt;a href=&quot;#ensure_all_started/2&quot;&gt; &lt;code&gt;ensure_all_started/2&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f681ed2c3aa6661367fb62449b5900050c12c47" translate="yes" xml:space="preserve">
          <source>In case you want to provide some existing functionality to the user module, please define it in a module which will be imported accordingly; for example, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; doesn't define the &lt;code&gt;test/3&lt;/code&gt; macro in the module that calls &lt;code&gt;use ExUnit.Case&lt;/code&gt;, but it defines &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#test/3&quot;&gt;&lt;code&gt;ExUnit.Case.test/3&lt;/code&gt;&lt;/a&gt; and just imports that into the caller when used.</source>
          <target state="translated">사용자 모듈에 기존 기능을 제공하려는 경우 그에 따라 가져올 모듈에서 해당 기능을 정의하십시오. 예를 들어 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt; 는 ExUnit.Case를 &lt;code&gt;use ExUnit.Case&lt;/code&gt; 하는 모듈에서 &lt;code&gt;test/3&lt;/code&gt; 매크로를 정의하지 않지만 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#test/3&quot;&gt; &lt;code&gt;ExUnit.Case.test/3&lt;/code&gt; 를&lt;/a&gt; 정의 하고 사용될 때이를 호출자로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3ff348aca712691651b4c435346c7c87f48a03c6" translate="yes" xml:space="preserve">
          <source>In case you were using the deprecated &lt;code&gt;:simple_one_for_one&lt;/code&gt; strategy from the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module, you can migrate to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; in few steps.</source>
          <target state="translated">&lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 모듈 에서 더 이상 사용되지 않는 &lt;code&gt;:simple_one_for_one&lt;/code&gt; 전략을 사용하는 경우 몇 단계만으로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DynamicSupervisor&lt;/code&gt; &lt;/a&gt; 로 마이그레이션 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3fa04a38e1468a79c7262b85ac96321cc9efef6" translate="yes" xml:space="preserve">
          <source>In contrast to keyword lists, maps are very useful with pattern matching. When a map is used in a pattern, it will always match on a subset of the given value:</source>
          <target state="translated">키워드 목록과 달리지도는 패턴 일치에 매우 유용합니다. 맵이 패턴에 사용되면 주어진 값의 서브 세트에서 항상 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1a0cd3de6db0a42db7660ce1f70c833f42728634" translate="yes" xml:space="preserve">
          <source>In contrast, the values for the called functions describe those functions, but in the context of the marked function. For example, the last row means that &lt;code&gt;Mod.called2/0&lt;/code&gt; was called once by &lt;code&gt;Mod.some_function/0&lt;/code&gt;, and in that case the total time spent in the function was 50ms.</source>
          <target state="translated">반대로, 호출 된 함수의 값은 해당 함수를 설명하지만 표시된 함수와 관련하여 설명합니다. 예를 들어, 그 마지막 행 수단 &lt;code&gt;Mod.called2/0&lt;/code&gt; 한번 불렸다 &lt;code&gt;Mod.some_function/0&lt;/code&gt; , 그 경우 함수에 소요되는 총 시간은 50ms이다.</target>
        </trans-unit>
        <trans-unit id="fc4add0dde66d9d0296a0654de0562024d8f9f79" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;erlangerror&quot;&gt;&lt;code&gt;ErlangError&lt;/code&gt;&lt;/a&gt; can be used to rescue any error that is not a proper Elixir error. For example, it can be used to rescue the earlier &lt;code&gt;:badarg&lt;/code&gt; error too, prior to transformation:</source>
          <target state="translated">실제로 &lt;a href=&quot;erlangerror&quot;&gt; &lt;code&gt;ErlangError&lt;/code&gt; &lt;/a&gt; 를 사용하여 적절한 Elixir 오류가 아닌 오류를 복구 할 수 있습니다. 예를 들어, 변환하기 전에 이전 &lt;code&gt;:badarg&lt;/code&gt; 오류 를 구조하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0899943a58fd70e4f3d0ccf56e136c5b02dd5f31" translate="yes" xml:space="preserve">
          <source>In fact, connecting to remote shells is so common that we provide a shortcut via the command line as well:</source>
          <target state="translated">실제로 원격 셸에 연결하는 것이 일반적이므로 명령 줄을 통해 바로 가기를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="86d8ddd11e7d11d4d1da78d64c3d55a307dc74a3" translate="yes" xml:space="preserve">
          <source>In fact, let&amp;rsquo;s open up &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt;:</source>
          <target state="translated">실제로 &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt; 를 열어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="61139d4b1bbde59322a4c8bca7a0561709d9841c" translate="yes" xml:space="preserve">
          <source>In fact, the &lt;code&gt;:bind_quoted&lt;/code&gt; option is recommended every time one desires to inject a value into the quote.</source>
          <target state="translated">실제로 &lt;code&gt;:bind_quoted&lt;/code&gt; 옵션은 따옴표에 값을 삽입하려고 할 때마다 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="e63bd9e9e19b982359b9cda4d5fcbeea34909a27" translate="yes" xml:space="preserve">
          <source>In fact, this pattern is so common that most of the times you will want to use the &lt;code&gt;bind_quoted&lt;/code&gt; option with &lt;a href=&quot;#quote/2&quot;&gt;&lt;code&gt;quote/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">실제로,이 패턴은 매우 일반적이므로 &lt;code&gt;bind_quoted&lt;/code&gt; &lt;a href=&quot;#quote/2&quot;&gt; &lt;code&gt;quote/2&lt;/code&gt; &lt;/a&gt; 2quoted 옵션을 quote / 2 와 함께 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="be090f2c7b49fa10f6982f61cbff56e2c1ea6990" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;underscore&lt;/code&gt; can be thought of as the reverse of &lt;code&gt;camelize&lt;/code&gt;, however, in some cases formatting may be lost:</source>
          <target state="translated">일반적으로 &lt;code&gt;underscore&lt;/code&gt; 은 &lt;code&gt;camelize&lt;/code&gt; 의 반대라고 생각할 수 있지만 경우에 따라 형식이 손실 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a3e2a29096c65e2eb89f937c17a4004e7ef7444" translate="yes" xml:space="preserve">
          <source>In general, a developer should use the former in case they want to react if the file does not exist. The latter should be used when the developer expects their software to fail in case the file cannot be read (i.e. it is literally an exception).</source>
          <target state="translated">일반적으로 개발자는 파일이 존재하지 않는 경우 반응하려는 경우 전자를 사용해야합니다. 후자는 파일을 읽을 수없는 경우 (즉 문자 그대로 예외) 개발자가 소프트웨어의 장애를 예상 할 때 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d16c9ac73c5397997e3e76ab325334e002852804" translate="yes" xml:space="preserve">
          <source>In general, a developer will want to use the general &lt;code&gt;assert&lt;/code&gt; macro in tests. This macro introspects your code and provides good reporting whenever there is a failure. For example, &lt;code&gt;assert some_fun() == 10&lt;/code&gt; will fail (assuming &lt;code&gt;some_fun()&lt;/code&gt; returns &lt;code&gt;13&lt;/code&gt;):</source>
          <target state="translated">일반적으로 개발자는 테스트에 일반 &lt;code&gt;assert&lt;/code&gt; 매크로 를 사용하려고합니다 . 이 매크로는 코드를 검사하고 실패가있을 때마다 좋은보고 기능을 제공합니다. 예를 들어 &lt;code&gt;assert some_fun() == 10&lt;/code&gt; 이 실패 한다고 주장합니다 ( &lt;code&gt;some_fun()&lt;/code&gt; 이 &lt;code&gt;13&lt;/code&gt; 을 가정하면 ).</target>
        </trans-unit>
        <trans-unit id="c3d41e104bfcea8fdabed0cd450572fc2e4bac9f" translate="yes" xml:space="preserve">
          <source>In general, the functions in this module rely on the Unicode Standard, but do not contain any of the locale specific behaviour.</source>
          <target state="translated">일반적으로이 모듈의 기능은 유니 코드 표준에 의존하지만 로케일 특정 동작은 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c9716a12a8a55aca30fe284f4ffccd27a063bec" translate="yes" xml:space="preserve">
          <source>In general, the tuples above are structured according to the following format:</source>
          <target state="translated">일반적으로 위의 튜플은 다음 형식으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6de751c2f24f5d6947a334c2b635bc5f4ec33c5a" translate="yes" xml:space="preserve">
          <source>In general, when the keyword list is the last argument of a function, the square brackets are optional.</source>
          <target state="translated">일반적으로 키워드 목록이 함수의 마지막 인수 인 경우 대괄호는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="6bab1cb15297331e40b3f50701fea2260e1dfe89" translate="yes" xml:space="preserve">
          <source>In guards, when functions would normally raise exceptions, they cause the guard to fail instead. For example, the &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; function only works with lists. If we use it with anything else, a runtime error is raised:</source>
          <target state="translated">가드에서 함수가 일반적으로 예외를 발생 시키면 가드가 대신 실패합니다. 예를 들어 &lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt; 함수는 목록에서만 작동합니다. 다른 용도로 사용하면 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a530de2468aeae84b5f9a5ab3d0835429e502343" translate="yes" xml:space="preserve">
          <source>In light of this observation, we should consider moving to another supervision strategy. The two other candidates are &lt;code&gt;:one_for_all&lt;/code&gt; and &lt;code&gt;:rest_for_one&lt;/code&gt;. A supervisor using the &lt;code&gt;:rest_for_one&lt;/code&gt; strategy will kill and restart child processes which were started &lt;em&gt;after&lt;/em&gt; the crashed child. In this case, we would want &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; to terminate if &lt;code&gt;KV.Registry&lt;/code&gt; terminates. This would require the bucket supervisor to be placed after the registry which violates the ordering constraints we have established two paragraphs above.</source>
          <target state="translated">이러한 관찰에 비추어 우리는 다른 감독 전략으로의 전환을 고려해야합니다. 다른 두 후보는 &lt;code&gt;:one_for_all&lt;/code&gt; 및 &lt;code&gt;:rest_for_one&lt;/code&gt; 입니다. &lt;code&gt;:rest_for_one&lt;/code&gt; 전략을 사용하는 감독자 는 충돌 한 자식 &lt;em&gt;이후&lt;/em&gt; 에 시작된 자식 프로세스를 종료하고 다시 시작 합니다. 이 경우 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 가 종료되면 &lt;code&gt;KV.Registry&lt;/code&gt; 종료 되기를 원합니다 . 이를 위해서는 버킷 관리자가 위의 두 단락을 설정 한 순서 제약 조건을 위반하는 레지스트리 뒤에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="287c5e7fdc75892fe61a19be625743d753001a1c" translate="yes" xml:space="preserve">
          <source>In macro code, the bang on &lt;a href=&quot;kernel#alias!/1&quot;&gt;&lt;code&gt;Kernel.alias!/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#var!/2&quot;&gt;&lt;code&gt;Kernel.var!/2&lt;/code&gt;&lt;/a&gt; signifies that &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macros-hygiene&quot;&gt;macro hygiene&lt;/a&gt; is set aside.</source>
          <target state="translated">매크로 코드에서 &lt;a href=&quot;kernel#alias!/1&quot;&gt; &lt;code&gt;Kernel.alias!/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;kernel#var!/2&quot;&gt; &lt;code&gt;Kernel.var!/2&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macros-hygiene&quot;&gt;매크로 위생&lt;/a&gt; 이 따로 설정되어 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="32bcee841524dde12cdf73859245e9378a9b1abe" translate="yes" xml:space="preserve">
          <source>In many cases it is more convenient to pass the expected value to &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt; and generate the message in the &lt;a href=&quot;exception#c:exception/1&quot;&gt;&lt;code&gt;Exception.exception/1&lt;/code&gt;&lt;/a&gt; callback:</source>
          <target state="translated">많은 경우 예상 값을 &lt;a href=&quot;#raise/2&quot;&gt; &lt;code&gt;raise/2&lt;/code&gt; &lt;/a&gt; 로 전달 하고 &lt;a href=&quot;exception#c:exception/1&quot;&gt; &lt;code&gt;Exception.exception/1&lt;/code&gt; &lt;/a&gt; 콜백 에서 메시지를 생성하는 것이 더 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="f3a407dd1ba9629c2d87378f7214d938dbbf397b" translate="yes" xml:space="preserve">
          <source>In many cases, we can take advantage of this. In the code above, we used &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; to both check that the given thing is a list &lt;em&gt;and&lt;/em&gt; check some properties of its length (instead of using &lt;code&gt;is_list(something) and length(something) &amp;gt; 0&lt;/code&gt;).</source>
          <target state="translated">많은 경우에, 우리는 이것을 이용할 수 있습니다. 위의 코드에서 우리는 사용 &lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt; 주어진 것은 목록입니다 것을 모두 체크를 &lt;em&gt;하고&lt;/em&gt; (대신 사용하는 길이의 몇 가지 속성을 확인 &lt;code&gt;is_list(something) and length(something) &amp;gt; 0&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1718d61cb1f8d442d32bbf909dd936aa49ffeb46" translate="yes" xml:space="preserve">
          <source>In many functional programming languages, it is common to use a list of 2-item tuples as the representation of a key-value data structure. In Elixir, when we have a list of tuples and the first item of the tuple (i.e. the key) is an atom, we call it a keyword list:</source>
          <target state="translated">많은 기능적 프로그래밍 언어에서 키-값 데이터 구조의 표현으로 2- 항목 튜플 목록을 사용하는 것이 일반적입니다. Elixir에서 튜플 목록이 있고 튜플의 첫 번째 항목 (예 : 키)이 원자 인 경우 키워드 목록이라고합니다.</target>
        </trans-unit>
        <trans-unit id="68e23cbb5429660e2faf1806ef4a612c49708bf4" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;a href=&quot;#ensure_loaded/1&quot;&gt;&lt;code&gt;ensure_loaded/1&lt;/code&gt;&lt;/a&gt; is enough. &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; must be used in rare cases, usually involving macros that need to invoke a module for callback information.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;#ensure_loaded/1&quot;&gt; &lt;code&gt;ensure_loaded/1&lt;/code&gt; &lt;/a&gt; 이면 충분합니다. 일반적으로 콜백 정보를 위해 모듈을 호출해야하는 매크로와 관련이있는 경우에는 &lt;a href=&quot;#ensure_compiled/1&quot;&gt; &lt;code&gt;ensure_compiled/1&lt;/code&gt; 을&lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="423cb3333a43148ea91fc3b7a37efcd42c886681" translate="yes" xml:space="preserve">
          <source>In order for the cache mechanism to work, the created ETS table needs to have access &lt;code&gt;:protected&lt;/code&gt; (the default), so all clients can read from it, while only the &lt;code&gt;KV.Registry&lt;/code&gt; process writes to it. We have also set &lt;code&gt;read_concurrency: true&lt;/code&gt; when starting the table, optimizing the table for the common scenario of concurrent read operations.</source>
          <target state="translated">캐시 메커니즘이 작동하려면 작성된 ETS 테이블에 access &lt;code&gt;:protected&lt;/code&gt; (기본값)가 있어야하므로 &lt;code&gt;KV.Registry&lt;/code&gt; 프로세스 만 테이블에 쓰는 동안 모든 클라이언트가이를 읽을 수 있습니다 . 또한 테이블을 시작할 때 &lt;code&gt;read_concurrency: true&lt;/code&gt; 설정 하여 동시 읽기 작업의 일반적인 시나리오에 맞게 테이블을 최적화합니다.</target>
        </trans-unit>
        <trans-unit id="c81c6a20ae394a892047f71306226257ed4ae14b" translate="yes" xml:space="preserve">
          <source>In order to be loaded, an &lt;code&gt;.app&lt;/code&gt; file must be in the load paths. All &lt;code&gt;:included_applications&lt;/code&gt; will also be loaded.</source>
          <target state="translated">로드하려면 &lt;code&gt;.app&lt;/code&gt; 파일이로드 경로에 있어야합니다. 모든 &lt;code&gt;:included_applications&lt;/code&gt; 도로드됩니다.</target>
        </trans-unit>
        <trans-unit id="0ce310cabbc38fde237e6f7456d065921f47f408" translate="yes" xml:space="preserve">
          <source>In order to better understand how macros work, let&amp;rsquo;s create a new module where we are going to implement &lt;code&gt;unless&lt;/code&gt;, which does the opposite of &lt;code&gt;if&lt;/code&gt;, as a macro and as a function:</source>
          <target state="translated">위해 매크로가 작동하는 방법을 더 잘 이해하기 위해, 우리가 구현하려고하는 새 모듈 생성 할 수 &lt;code&gt;unless&lt;/code&gt; 반대 수행하는 &lt;code&gt;if&lt;/code&gt; 매크로로와 함수로를 :</target>
        </trans-unit>
        <trans-unit id="98bbe9c7dc0c95fe1893b767af4a2559d441e9f7" translate="yes" xml:space="preserve">
          <source>In order to build a variable, a context is expected. Most of the times, in order to preserve hygiene, the context must be &lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">변수를 만들기 위해서는 컨텍스트가 필요합니다. 대부분의 경우, 위생을 유지하려면 컨텍스트가 &lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt; &lt;code&gt;__MODULE__/0&lt;/code&gt; &lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="09c48209d831c8b2ec6ba4ec948897b23f18046a" translate="yes" xml:space="preserve">
          <source>In order to build our key-value application, we are going to use three main tools:</source>
          <target state="translated">키-값 애플리케이션을 구축하기 위해 다음 세 가지 주요 도구를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="db1ca29d2377c1f8fa9329bcdb6aca022dc1f156" translate="yes" xml:space="preserve">
          <source>In order to compare more than two clauses, the &lt;a href=&quot;kernel.specialforms#cond/1&quot;&gt;&lt;code&gt;cond/1&lt;/code&gt;&lt;/a&gt; macro has to be used.</source>
          <target state="translated">두 개 이상의 절을 비교하려면 &lt;a href=&quot;kernel.specialforms#cond/1&quot;&gt; &lt;code&gt;cond/1&lt;/code&gt; &lt;/a&gt; 매크로를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bdbf00ad68adfada8cf0d80c6af387a4904e12d" translate="yes" xml:space="preserve">
          <source>In order to configure Mix, the module that &lt;code&gt;use&lt;/code&gt;s &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt; should export a &lt;code&gt;project/0&lt;/code&gt; function that returns a keyword list representing configuration for the project.</source>
          <target state="translated">Mix를 구성 &lt;code&gt;use&lt;/code&gt; s &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Mix.Project&lt;/code&gt; &lt;/a&gt; 를 사용 하는 모듈이 &lt;code&gt;project/0&lt;/code&gt; 구성을 나타내는 키워드 목록을 반환하는 project / 0 함수를 내 보내야 합니다 .</target>
        </trans-unit>
        <trans-unit id="6eb392bb5990ef3fcaeb5fa0f99e17c04d60d3ab" translate="yes" xml:space="preserve">
          <source>In order to continue evolving the language without introducing breaking changes, Elixir will rely on deprecations to demote certain practices and promote new ones. Our deprecation policy is outlined in the &lt;a href=&quot;#deprecations&quot;&gt;&quot;Deprecations&quot; section&lt;/a&gt;.</source>
          <target state="translated">변경 사항을 변경하지 않고 언어를 계속 발전시키기 위해 Elixir는 더 이상 사용되지 않아 특정 관행을 강등하고 새로운 관행을 홍보합니다. Google의 지원 중단 정책은 &lt;a href=&quot;#deprecations&quot;&gt;&quot;사용 중단&quot;섹션에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="642f4f188110996b3a0b6c3fdce8b893ead2d9fa" translate="yes" xml:space="preserve">
          <source>In order to cope with code loading in development, protocols in Elixir provide a slow implementation of protocol dispatching specific to development.</source>
          <target state="translated">개발시 코드 로딩에 대처하기 위해 Elixir의 프로토콜은 개발에 특화된 프로토콜 디스패치의 느린 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6a2b5841e9d7864def29c3c36d34a45ef5565969" translate="yes" xml:space="preserve">
          <source>In order to create our own modules in Elixir, we use the &lt;code&gt;defmodule&lt;/code&gt; macro. We use the &lt;code&gt;def&lt;/code&gt; macro to define functions in that module:</source>
          <target state="translated">Elixir에서 자체 모듈을 만들기 위해 &lt;code&gt;defmodule&lt;/code&gt; 매크로를 사용합니다 . &lt;code&gt;def&lt;/code&gt; 매크로를 사용하여 해당 모듈에서 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4adfde6fe98ff6cd24536d794e886a1f37546977" translate="yes" xml:space="preserve">
          <source>In order to facilitate software reuse, Elixir provides three directives (&lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt;) plus a macro called &lt;code&gt;use&lt;/code&gt; summarized below:</source>
          <target state="translated">소프트웨어 재사용을 용이하게하기 위해 Elixir는 3 가지 지시어 ( &lt;code&gt;alias&lt;/code&gt; , &lt;code&gt;require&lt;/code&gt; 및 &lt;code&gt;import&lt;/code&gt; )와 아래에 요약 된 &lt;code&gt;use&lt;/code&gt; 라는 매크로를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="06a700b11907ab62d5a4a0a6df97c7759ea5d0ae" translate="yes" xml:space="preserve">
          <source>In order to finish our &lt;code&gt;TestCase&lt;/code&gt; implementation, we need to be able to access all defined test cases. One way of doing this is by retrieving the tests at runtime via &lt;code&gt;__MODULE__.__info__(:functions)&lt;/code&gt;, which returns a list of all functions in a given module. However, considering that we may want to store more information about each test besides the test name, a more flexible approach is required.</source>
          <target state="translated">&lt;code&gt;TestCase&lt;/code&gt; 구현 을 마치 려면 정의 된 모든 테스트 사례에 액세스 할 수 있어야합니다. 이를 수행하는 한 가지 방법은 &lt;code&gt;__MODULE__.__info__(:functions)&lt;/code&gt; 를 통해 런타임에 테스트를 검색하여 지정된 모듈의 모든 함수 목록을 리턴하는 것입니다. 그러나 테스트 이름 외에 각 테스트에 대한 추가 정보를 저장하려는 경우보다 유연한 접근 방식이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c5a3e4590add882007f47566c77c18638d716efc" translate="yes" xml:space="preserve">
          <source>In order to fix the failing test, let&amp;rsquo;s create a file at &lt;code&gt;lib/kv/bucket.ex&lt;/code&gt; with the contents below. Feel free to give a try at implementing the &lt;code&gt;KV.Bucket&lt;/code&gt; module yourself using agents before peeking at the implementation below.</source>
          <target state="translated">실패한 테스트를 해결하기 위해 &lt;code&gt;lib/kv/bucket.ex&lt;/code&gt; 에 아래 내용 으로 파일을 생성 해 봅시다 . 아래 구현에서 엿보기 전에 에이전트를 사용하여 &lt;code&gt;KV.Bucket&lt;/code&gt; 모듈을 직접 구현해보십시오 .</target>
        </trans-unit>
        <trans-unit id="fc7b18c46cad921ea2c996d18c66b0c78849816d" translate="yes" xml:space="preserve">
          <source>In order to fix this bug, we need the registry to monitor every bucket it spawns. Once we set up a monitor, the registry will receive a notification every time a bucket process exits, allowing us to clean the registry up.</source>
          <target state="translated">이 버그를 해결하려면, 생성되는 모든 버킷을 모니터링하는 레지스트리가 필요합니다. 모니터를 설정하면 버킷 프로세스가 종료 될 때마다 레지스트리가 알림을 수신하여 레지스트리를 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a956c6b95ce875304570bf71071ca672fa7f12b" translate="yes" xml:space="preserve">
          <source>In order to get your first project started, Elixir ships with a build tool called Mix. You can get your new project started by running:</source>
          <target state="translated">첫 번째 프로젝트를 시작하기 위해 Elixir는 Mix라는 빌드 도구를 제공합니다. 다음을 실행하여 새 프로젝트를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="017fd6a1081d196daafbd3b60fc590b568ac6071" translate="yes" xml:space="preserve">
          <source>In order to help IEx understand that an expression consists of multiple lines we can wrap it into parentheses:</source>
          <target state="translated">식이 여러 줄로 구성되어 있음을 IEx가 이해하도록 돕기 위해 식을 괄호로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a957b1a9d6df7d7ce8fa55bcc89ebc9a60d14634" translate="yes" xml:space="preserve">
          <source>In order to invoke the callbacks above, we need to go through the corresponding &lt;code&gt;GenServer&lt;/code&gt; functions. Let&amp;rsquo;s start a registry, create a named bucket, and then look it up:</source>
          <target state="translated">위의 콜백을 호출하려면 해당 &lt;code&gt;GenServer&lt;/code&gt; 함수를 거쳐야 합니다. 레지스트리를 시작하고 명명 된 버킷을 만든 다음 찾아 보자.</target>
        </trans-unit>
        <trans-unit id="af452841dd75bb4a44c38345c300f4a14d20c04a" translate="yes" xml:space="preserve">
          <source>In order to make our server handle simultaneous connections, we need to have one process working as an acceptor that spawns other processes to serve requests. One solution would be to change:</source>
          <target state="translated">서버가 동시 연결을 처리하도록하려면 요청을 처리하기 위해 다른 프로세스를 생성하는 수락 자로 작동하는 하나의 프로세스가 있어야합니다. 한 가지 해결책은 다음과 같이 변경하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e3a8a476eb42420a16666c234250ab684a970ce4" translate="yes" xml:space="preserve">
          <source>In order to manipulate keyword lists, Elixir provides &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;the &lt;code&gt;Keyword&lt;/code&gt; module&lt;/a&gt;. Remember, though, keyword lists are simply lists, and as such they provide the same linear performance characteristics as lists. The longer the list, the longer it will take to find a key, to count the number of items, and so on. For this reason, keyword lists are used in Elixir mainly for passing optional values. If you need to store many items or guarantee one-key associates with at maximum one-value, you should use maps instead.</source>
          <target state="translated">키워드 목록을 조작하기 위해 Elixir는 &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; 모듈을 제공 합니다 . 그러나 키워드 목록은 단순한 목록이므로 목록과 동일한 선형 성능 특성을 제공합니다. 목록이 길수록 키를 찾고 항목 수를 계산하는 데 시간이 오래 걸립니다. 이러한 이유로 키워드 목록은 Elixir에서 주로 선택적 값을 전달하는 데 사용됩니다. 많은 항목을 저장하거나 하나의 키 연결을 최대 하나의 값으로 보장해야하는 경우 대신 맵을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="af5b1e73788ff17dca0429ef7ffa66ff44df9939" translate="yes" xml:space="preserve">
          <source>In order to run distributed code, we need to start the</source>
          <target state="translated">분산 코드를 실행하려면</target>
        </trans-unit>
        <trans-unit id="62c900a7e8363bd8d8183eca353b3f640ed385cc" translate="yes" xml:space="preserve">
          <source>In order to run the first test, we need to have two nodes running. Move into &lt;code&gt;apps/kv&lt;/code&gt; and let&amp;rsquo;s restart the node named &lt;code&gt;bar&lt;/code&gt; which is going to be used by tests.</source>
          <target state="translated">첫 번째 테스트를 실행하려면 두 개의 노드를 실행해야합니다. &lt;code&gt;apps/kv&lt;/code&gt; 로 이동하여 테스트에 사용될 &lt;code&gt;bar&lt;/code&gt; 라는 노드를 다시 시작해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="64a048080239b32ae9270b349a43b94c3e07e07c" translate="yes" xml:space="preserve">
          <source>In order to speed up dispatching in production environments, where all implementations are known up-front, Elixir provides a feature called protocol consolidation. Consolidation directly links protocols to their implementations in a way that invoking a function from a consolidated protocol is equivalent to invoking two remote functions.</source>
          <target state="translated">모든 구현이 사전에 알려진 프로덕션 환경에서 디스패치 속도를 높이기 위해 Elixir는 프로토콜 통합이라는 기능을 제공합니다. 통합은 통합 프로토콜에서 함수를 호출하는 것이 두 개의 원격 함수를 호출하는 것과 같은 방식으로 프로토콜을 구현에 직접 연결합니다.</target>
        </trans-unit>
        <trans-unit id="8d8b39acde42481af0b84b36b66305d49c434a4a" translate="yes" xml:space="preserve">
          <source>In order to start a supervisor, we need to first define a child process that will be supervised. As an example, we will define a GenServer that represents a stack:</source>
          <target state="translated">감독자를 시작하려면 먼저 감독 할 자식 프로세스를 정의해야합니다. 예를 들어 스택을 나타내는 GenServer를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="656310fbcb50af634eac84272798b02ab00dba6a" translate="yes" xml:space="preserve">
          <source>In order to understand the underlying code, we&amp;rsquo;d need macros, so we will revisit this pattern in the meta-programming guide. However, the focus here is on how using module attributes as storage allows developers to create DSLs.</source>
          <target state="translated">기본 코드를 이해하려면 매크로가 필요하므로 메타 프로그래밍 가이드에서이 패턴을 다시 살펴 보겠습니다. 그러나 여기서는 스토리지로 모듈 속성을 사용하여 개발자가 DSL을 작성할 수있는 방법에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="1ca6c027f8dcdd141de11fbd20d5f0afb503fc0f" translate="yes" xml:space="preserve">
          <source>In order to use dependencies, you need to add a &lt;code&gt;:deps&lt;/code&gt; key to your project configuration. We often extract the list of dependencies into its own function:</source>
          <target state="translated">종속성을 사용하려면 프로젝트 구성에 &lt;code&gt;:deps&lt;/code&gt; 키를 추가해야 합니다. 우리는 종종 의존성 목록을 자체 기능으로 추출합니다.</target>
        </trans-unit>
        <trans-unit id="ea5cbfc0efc9a5e4905ac0bfbf89bf8917d5354f" translate="yes" xml:space="preserve">
          <source>In order to use the application environment in our code, we need to replace &lt;code&gt;KV.Router.table/0&lt;/code&gt; with the definition below:</source>
          <target state="translated">코드에서 응용 프로그램 환경을 사용하려면 &lt;code&gt;KV.Router.table/0&lt;/code&gt; 을 아래 정의 로 바꿔야 합니다.</target>
        </trans-unit>
        <trans-unit id="dcd42d7d1276fbdd4330c63012ce7d34e85da421" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in &lt;code&gt;:binary&lt;/code&gt; mode, which requires the functions &lt;a href=&quot;io#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file and then all other functions from &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; are available, since they work directly with Unicode data.</source>
          <target state="translated">파일을 읽고 읽으려면 &lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 모듈 의 기능을 사용해야합니다 . 기본적으로 파일은 &lt;code&gt;:binary&lt;/code&gt; 모드로 열리 므로 파일과 상호 작용 하려면 &lt;a href=&quot;io#binread/2&quot;&gt; &lt;code&gt;IO.binread/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;io#binwrite/2&quot;&gt; &lt;code&gt;IO.binwrite/2&lt;/code&gt; &lt;/a&gt; 기능이 필요 합니다. 개발자는 파일을 열 때 옵션으로 &lt;code&gt;:utf8&lt;/code&gt; 을 전달한 다음 유니 코드 데이터와 직접 작동하므로 &lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; 의&lt;/a&gt; 다른 모든 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82ce7a0943dbb663e7fc6760db6023cf3368a14d" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in binary mode, which requires the functions &lt;a href=&quot;io#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file, then the slower &lt;a href=&quot;io#read/2&quot;&gt;&lt;code&gt;IO.read/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#write/2&quot;&gt;&lt;code&gt;IO.write/2&lt;/code&gt;&lt;/a&gt; functions must be used as they are responsible for doing the proper conversions and providing the proper data guarantees.</source>
          <target state="translated">파일을 읽고 읽으려면 &lt;a href=&quot;io&quot;&gt; &lt;code&gt;IO&lt;/code&gt; &lt;/a&gt; 모듈 의 기능을 사용해야합니다 . 기본적으로 파일은 이진 모드로 열리 므로 파일과 상호 작용 하려면 &lt;a href=&quot;io#binread/2&quot;&gt; &lt;code&gt;IO.binread/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;io#binwrite/2&quot;&gt; &lt;code&gt;IO.binwrite/2&lt;/code&gt; &lt;/a&gt; 기능이 필요 합니다. 개발자는 파일을 열 때 옵션으로 &lt;code&gt;:utf8&lt;/code&gt; 을 전달할 수 있으며, 적절한 변환을 수행하고 적절한 데이터 보증을 제공하기 위해 느린 &lt;a href=&quot;io#read/2&quot;&gt; &lt;code&gt;IO.read/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;io#write/2&quot;&gt; &lt;code&gt;IO.write/2&lt;/code&gt; &lt;/a&gt; 기능을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="31ee06abc4e001e3f6a5b13f3dfe4953038e624e" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;&amp;amp;(&amp;amp;1 * 2)&lt;/code&gt; is equivalent to &lt;code&gt;fn x -&amp;gt; x * 2 end&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;&amp;amp;(&amp;amp;1 * 2)&lt;/code&gt; 는 &lt;code&gt;fn x -&amp;gt; x * 2 end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="886ca2f2765b1ff87730f7dc9a052f3a738d7792" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;&amp;lt;%= @foo %&amp;gt;&lt;/code&gt; translates to:</source>
          <target state="translated">즉, &lt;code&gt;&amp;lt;%= @foo %&amp;gt;&lt;/code&gt; 는 다음과 같이 번역됩니다.</target>
        </trans-unit>
        <trans-unit id="93125c6aa3c9fdcea503c87c1c3998ce536dbba7" translate="yes" xml:space="preserve">
          <source>In other words, &lt;strong&gt;do not&lt;/strong&gt;:</source>
          <target state="translated">다시 말해, &lt;strong&gt;하지 마십시오&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="6d77f8954062d90a90e9c6b5408cf752db4ed5cd" translate="yes" xml:space="preserve">
          <source>In other words, Elixir will only parse options that are used by the runtime, ignoring all others. If you would like to parse all switches, regardless if they exist or not, you can force creation of atoms by passing &lt;code&gt;allow_nonexistent_atoms: true&lt;/code&gt; as option. Use this option with care. It is only useful when you are building command-line applications that receive dynamically-named arguments and must be avoided in long-running systems.</source>
          <target state="translated">즉, Elixir는 다른 모든 것을 무시하고 런타임에 사용되는 옵션 만 구문 분석합니다. 존재 여부에 관계없이 모든 스위치를 구문 분석하려면 &lt;code&gt;allow_nonexistent_atoms: true&lt;/code&gt; 를 옵션 으로 전달하여 원자를 강제로 만들 수 있습니다 . 이 옵션은주의해서 사용하십시오. 동적으로 이름이 지정된 인수를 수신하고 장기 실행 시스템에서 피해야하는 명령 행 응용 프로그램을 빌드 할 때만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="38fe91f6b4425a57a05293a344c316d610b9df57" translate="yes" xml:space="preserve">
          <source>In other words, functions using the word &quot;size&quot; in its name will take the same amount of time whether the data structure is tiny or huge. Conversely, functions having &quot;length&quot; in its name will take more time as the data structure grows in size.</source>
          <target state="translated">다시 말해, 이름에 &quot;size&quot;라는 단어를 사용하는 함수는 데이터 구조가 크든 작든 같은 시간이 걸립니다. 반대로, 이름에 &quot;길이&quot;가있는 함수는 데이터 구조의 크기가 커질수록 시간이 더 걸립니다.</target>
        </trans-unit>
        <trans-unit id="60a4e6e4835459586a75795caa4bfdc4a5131e02" translate="yes" xml:space="preserve">
          <source>In other words, if it is important that a process cleans after itself when your application or the supervision tree is shutting down, then this process must trap exits and its child specification should specify the proper &lt;code&gt;:shutdown&lt;/code&gt; value, ensuring it terminates within a reasonable interval.</source>
          <target state="translated">다시 말해, 애플리케이션 또는 감독 트리가 종료 될 때 프로세스가 자체적으로 정리되어야하는 경우이 프로세스는 종료를 트랩해야하며 하위 스펙은 적절한 &lt;code&gt;:shutdown&lt;/code&gt; 값을 지정하여 적절한 간격 내에 종료되도록해야합니다. .</target>
        </trans-unit>
        <trans-unit id="1f496a7679d30119adb2cc52d4073c178807ab2e" translate="yes" xml:space="preserve">
          <source>In other words, it is important to make a distinction between a regular Elixir value (like a list, a map, a process, a reference, etc) and a quoted expression. Some values, such as integers, atoms, and strings, have a quoted expression equal to the value itself. Other values, like maps, need to be explicitly converted. Finally, values like functions and references cannot be converted to a quoted expression at all.</source>
          <target state="translated">즉, 일반 Elixir 값 (예 : 목록, 맵, 프로세스, 참조 등)과 인용 된 표현식을 구별하는 것이 중요합니다. 정수, 원자 및 문자열과 같은 일부 값에는 값 자체와 동일한 인용 부호가 있습니다. 지도와 같은 다른 값은 명시 적으로 변환해야합니다. 마지막으로 함수 및 참조와 같은 값은 인용 식으로 전혀 변환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6de004f8f04712ff0ec3d814c33ef7cd9f1fbc8d" translate="yes" xml:space="preserve">
          <source>In other words, the atom &lt;code&gt;:jos&amp;eacute;&lt;/code&gt; can only be written with the code points &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt;. Using another normalization form will lead to a tokenizer error. On the other hand, &lt;code&gt;:&quot;jos&amp;eacute;&quot;&lt;/code&gt; may be written as &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; or &lt;code&gt;006A 006F 0073 0065 0301&lt;/code&gt;, since it is written between quotes.</source>
          <target state="translated">즉, atom &lt;code&gt;:jos&amp;eacute;&lt;/code&gt; 는 코드 포인트 &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; 로만 작성할 수 있습니다. 다른 정규화 양식을 사용하면 토크 나이저 오류가 발생합니다. 한편, &lt;code&gt;:&quot;jos&amp;eacute;&quot;&lt;/code&gt; 는 인용 부호 사이에 쓰여 있으므로 &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; 또는 &lt;code&gt;006A 006F 0073 0065 0301&lt;/code&gt; 로 쓰여질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a46592ea6e94de48f6246d5ad4aa9e7f178675e1" translate="yes" xml:space="preserve">
          <source>In other words, the expression above simply translates to:</source>
          <target state="translated">즉, 위의 표현은 단순히 다음과 같이 번역됩니다.</target>
        </trans-unit>
        <trans-unit id="cf94a3991ed1b9e98b23fc9feebaf13e89fbcbfd" translate="yes" xml:space="preserve">
          <source>In other words, this function tries to strip the &lt;code&gt;from&lt;/code&gt; prefix from &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">즉,이 함수는 &lt;code&gt;from&lt;/code&gt; 접두사를 &lt;code&gt;path&lt;/code&gt; 에서 제거하려고 시도 합니다 .</target>
        </trans-unit>
        <trans-unit id="05304a75e275a349e9ffa834cabff9641ce49488" translate="yes" xml:space="preserve">
          <source>In other words, this module expects invalid data to be detected elsewhere, usually when retrieving data from the external source. For example, a driver that reads strings from a database will be responsible to check the validity of the encoding. &lt;a href=&quot;string#chunk/2&quot;&gt;&lt;code&gt;String.chunk/2&lt;/code&gt;&lt;/a&gt; can be used for breaking a string into valid and invalid parts.</source>
          <target state="translated">즉,이 모듈은 일반적으로 외부 소스에서 데이터를 검색 할 때 유효하지 않은 데이터가 다른 곳에서 감지 될 것으로 예상합니다. 예를 들어, 데이터베이스에서 문자열을 읽는 드라이버는 인코딩의 유효성을 검사해야합니다. &lt;a href=&quot;string#chunk/2&quot;&gt; &lt;code&gt;String.chunk/2&lt;/code&gt; &lt;/a&gt; 는 문자열을 유효하고 유효하지 않은 부분으로 나누는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="558d46588b101dc23bc0d5fd0f4acaf2b4c0f74f" translate="yes" xml:space="preserve">
          <source>In other words, we converted each expression given to &lt;code&gt;case/2&lt;/code&gt; as a step in &lt;code&gt;with&lt;/code&gt;. As soon as any of the steps return something that does not match &lt;code&gt;{:ok, x}&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt; aborts, and returns the non-matching value.</source>
          <target state="translated">즉, 우리는 주어진 각 식 변환 &lt;code&gt;case/2&lt;/code&gt; 하는 단계로 &lt;code&gt;with&lt;/code&gt; . 즉시 단계 중 하나라도 일치하지 않는 것을 돌려로 &lt;code&gt;{:ok, x}&lt;/code&gt; , &lt;code&gt;with&lt;/code&gt; 중단한다, 및 반환 일치하지 않는 값입니다.</target>
        </trans-unit>
        <trans-unit id="9b5785a062ee13450968c9614ec6ca20310e34ad" translate="yes" xml:space="preserve">
          <source>In other words, we want the registry to keep on running even if a bucket crashes. Let&amp;rsquo;s write a new registry test:</source>
          <target state="translated">다시 말해 버킷이 충돌하더라도 레지스트리가 계속 실행되기를 원합니다. 새로운 레지스트리 테스트를 작성해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="32be3988a4bf49863fd56d4a7249dcf02990b46b" translate="yes" xml:space="preserve">
          <source>In other words, when invoked as:</source>
          <target state="translated">즉, 다음과 같이 호출 될 때</target>
        </trans-unit>
        <trans-unit id="e8d6c41a56de39aca9e7a91aac78285a5e2f3f02" translate="yes" xml:space="preserve">
          <source>In other words:</source>
          <target state="translated">In other words:</target>
        </trans-unit>
        <trans-unit id="49d20f893de0acff7f5dc08503dbde4a71a0e1bc" translate="yes" xml:space="preserve">
          <source>In particular, charlists will be printed back by default in single quotes if they contain only printable ASCII characters:</source>
          <target state="translated">특히, 인쇄 가능한 ASCII 문자 만 포함하는 경우 문자 목록은 기본적으로 작은 따옴표로 다시 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="3467114e6e90f4dae7f2e188d401c44475293e7c" translate="yes" xml:space="preserve">
          <source>In practice, charlists are used mostly when interfacing with Erlang, in particular old libraries that do not accept binaries as arguments. You can convert a charlist to a string and back by using the &lt;code&gt;to_string/1&lt;/code&gt; and &lt;code&gt;to_charlist/1&lt;/code&gt; functions:</source>
          <target state="translated">실제로, charlists는 Erlang, 특히 바이너리를 인수로 받아들이지 않는 오래된 라이브러리와 인터페이스 할 때 주로 사용됩니다. &lt;code&gt;to_string/1&lt;/code&gt; 및 &lt;code&gt;to_charlist/1&lt;/code&gt; 함수 를 사용하여 charlist를 문자열로 변환하고 다시 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b004abb70250b3f1e68f41dcfedc223284b584eb" translate="yes" xml:space="preserve">
          <source>In practice, however, Elixir developers rarely use the &lt;code&gt;try/rescue&lt;/code&gt; construct. For example, many languages would force you to rescue an error when a file cannot be opened successfully. Elixir instead provides a &lt;code&gt;File.read/1&lt;/code&gt; function which returns a tuple containing information about whether the file was opened successfully:</source>
          <target state="translated">그러나 실제로 Elixir 개발자는 &lt;code&gt;try/rescue&lt;/code&gt; 구문을 거의 사용하지 않습니다 . 예를 들어, 많은 언어는 파일을 성공적으로 열 수 없을 때 오류를 구조하도록합니다. Elixir는 대신 파일이 성공적으로 열렸는지에 대한 정보가 포함 된 튜플을 반환 하는 &lt;code&gt;File.read/1&lt;/code&gt; 함수를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="8e292cda7fd341df2ad10ad68515a260c1f9ceca" translate="yes" xml:space="preserve">
          <source>In practice, if you find yourself in a position where you need a process registry for dynamic processes, you should use &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt;the &lt;code&gt;Registry&lt;/code&gt; module&lt;/a&gt; provided as part of Elixir. It provides functionality similar to the one we have built using a GenServer + &lt;code&gt;:ets&lt;/code&gt; while also being able to perform both writes and reads concurrently. &lt;a href=&quot;https://elixir-lang.org/blog/2017/01/05/elixir-v1-4-0-released/&quot;&gt;It has been benchmarked to scale across all cores even on machines with 40 cores&lt;/a&gt;.</source>
          <target state="translated">실제로, 동적 프로세스를위한 프로세스 레지스트리가 필요한 위치에있는 경우 Elixir의 일부로 제공된 &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt; &lt;code&gt;Registry&lt;/code&gt; &lt;/a&gt; 모듈을 사용해야 합니다 . GenServer + &lt;code&gt;:ets&lt;/code&gt; 를 사용하여 빌드 한 것과 유사한 기능을 제공 하는 동시에 쓰기와 읽기를 동시에 수행 할 수 있습니다. &lt;a href=&quot;https://elixir-lang.org/blog/2017/01/05/elixir-v1-4-0-released/&quot;&gt;코어가 40 개인 머신에서도 모든 코어에 걸쳐 확장되도록 벤치마킹되었습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1db0e725bf7fce8e6792fe7c1b5f4904976e1c8d" translate="yes" xml:space="preserve">
          <source>In practice, it is common to have both server and client functions in the same module. If the server and/or client implementations are growing complex, you may want to have them in different modules.</source>
          <target state="translated">실제로 서버와 클라이언트 기능을 동일한 모듈에 두는 것이 일반적입니다. 서버 및 / 또는 클라이언트 구현이 복잡해지고있는 경우 다른 모듈로 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70101e1c300d630f1ea86765138df21a3dc6ed93" translate="yes" xml:space="preserve">
          <source>In practice, it is more likely you will reach the Erlang</source>
          <target state="translated">실제로, 당신이 Erlang에 도달 할 가능성이 더 높습니다</target>
        </trans-unit>
        <trans-unit id="c83f942e405f3eb5ce3163220a02a8f1db134d20" translate="yes" xml:space="preserve">
          <source>In practice, we are not expecting the processes working as buckets to fail. But, if it does happen, for whatever reason, we can rest assured that our system will continue to work as intended.</source>
          <target state="translated">실제로 버킷으로 작동하는 프로세스가 실패 할 것으로 예상하지 않습니다. 그러나 어떤 이유로 든 시스템이 의도 한대로 계속 작동 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="bcd76319c1bff6236a950ae66cde047b189b7040" translate="yes" xml:space="preserve">
          <source>In practice, you rarely load applications by hand because that is part of the start process, explained next.</source>
          <target state="translated">실제로는 다음과 같이 시작 프로세스의 일부이므로 응용 프로그램을 직접로드하는 경우가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="b81ae9e0c2bb006469e999756d7c827614795f38" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix. It may happen if read permissions do not exist for the parent directories of the current directory. For this reason, returns &lt;code&gt;{:ok, cwd}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">드문 경우이지만이 기능은 Unix에서 실패 할 수 있습니다. 현재 디렉토리의 상위 디렉토리에 대한 읽기 권한이없는 경우 발생할 수 있습니다. 이러한 이유로 성공하면 &lt;code&gt;{:error, reason}&lt;/code&gt; &lt;code&gt;{:ok, cwd}&lt;/code&gt; 를 , 그렇지 않으면 {: error, reason}을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="acd5d3b4600c9d05bb359546d1009f1e407c770b" translate="yes" xml:space="preserve">
          <source>In set notation: &lt;code&gt;[\p{ID_Start}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Other_ID_Continue}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</source>
          <target state="translated">집합 표기법 : &lt;code&gt;[\p{ID_Start}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Other_ID_Continue}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f49cbc94b22c26f24f368405117b1889a3c176b" translate="yes" xml:space="preserve">
          <source>In set notation: &lt;code&gt;[\p{L}\p{Nl}\p{Other_ID_Start}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</source>
          <target state="translated">집합 표기법 : &lt;code&gt;[\p{L}\p{Nl}\p{Other_ID_Start}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2ccee93d894b5296828c59c78b91159cd164712" translate="yes" xml:space="preserve">
          <source>In some cases, it may be convenient to provide a default implementation for all types. This can be achieved by setting the &lt;code&gt;@fallback_to_any&lt;/code&gt; attribute to &lt;code&gt;true&lt;/code&gt; in the protocol definition:</source>
          <target state="translated">경우에 따라 모든 유형에 기본 구현을 제공하는 것이 편리 할 수 ​​있습니다. 프로토콜 정의에서 &lt;code&gt;@fallback_to_any&lt;/code&gt; 속성을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="371305821a86a1fd6063efb5d024b0464bdede1a" translate="yes" xml:space="preserve">
          <source>In some cases, it may be necessary to inject many values inside a list. For example, imagine you have a list containing &lt;code&gt;[1, 2, 6]&lt;/code&gt; and we want to inject &lt;code&gt;[3, 4, 5]&lt;/code&gt; into it. Using &lt;code&gt;unquote&lt;/code&gt; won&amp;rsquo;t yield the desired result:</source>
          <target state="translated">경우에 따라 목록 안에 많은 값을 주입해야 할 수도 있습니다. 예를 들어, 포함하는 목록이 상상 &lt;code&gt;[1, 2, 6]&lt;/code&gt; 우리는 주입 할 &lt;code&gt;[3, 4, 5]&lt;/code&gt; 그것으로. &lt;code&gt;unquote&lt;/code&gt; 를 사용 하면 원하는 결과가 나오지 않습니다.</target>
        </trans-unit>
        <trans-unit id="606ff8e75aa81c7c8c049f5b60f58898dddc0286" translate="yes" xml:space="preserve">
          <source>In some cases, this may lead to undesired formatting. Therefore, &lt;strong&gt;some code generated by the formatter may not be aesthetically pleasing and may require explicit intervention from the developer&lt;/strong&gt;. That's why we do not recommend to run the formatter blindly in an existing codebase. Instead you should format and sanity check each formatted file.</source>
          <target state="translated">경우에 따라 원하지 않는 서식이 발생할 수 있습니다. 따라서 &lt;strong&gt;포맷터에서 생성 된 일부 코드는 미적으로 만족스럽지 않으며 개발자의 명시 적 개입이 필요할 수 있습니다&lt;/strong&gt; . 따라서 기존 코드베이스에서 포맷터를 맹목적으로 실행하지 않는 것이 좋습니다. 대신 형식이 지정된 각 파일을 형식화하고 완전성 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="e9e037bc0aa6cd7738573dffae9758c75aa58f06" translate="yes" xml:space="preserve">
          <source>In some cases, you don&amp;rsquo;t care about a particular value in a pattern. It is a common practice to bind those values to the underscore, &lt;code&gt;_&lt;/code&gt;. For example, if only the head of the list matters to us, we can assign the tail to underscore:</source>
          <target state="translated">경우에 따라 패턴의 특정 값에 신경 쓰지 않습니다. 이러한 값을 밑줄 &lt;code&gt;_&lt;/code&gt; 에 바인딩하는 것이 일반적 입니다. 예를 들어,리스트의 헤드 만 중요하다면 테일을 밑줄에 지정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4bf473ae676eadb3b6d9002d5044ddc6e88467a0" translate="yes" xml:space="preserve">
          <source>In some cases, you may need to inject such &lt;em&gt;values&lt;/em&gt; into &lt;em&gt;quoted expressions&lt;/em&gt;. To do that, we need to first escape those values into quoted expressions with the help of &lt;code&gt;Macro.escape/1&lt;/code&gt;:</source>
          <target state="translated">경우에 따라 이러한 &lt;em&gt;값&lt;/em&gt; 을 &lt;em&gt;따옴표&lt;/em&gt; 로 &lt;em&gt;묶어야&lt;/em&gt; 할 수도 있습니다 . 그러기 위해서는 먼저 &lt;code&gt;Macro.escape/1&lt;/code&gt; 의 도움으로 해당 값을 따옴표로 묶어 표현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f72fba3c3196c1696a309102e4d11fa8e7e9ddc2" translate="yes" xml:space="preserve">
          <source>In some cases, you want to access an alias or a module defined in the caller. For such, you can use the &lt;code&gt;alias!&lt;/code&gt; macro:</source>
          <target state="translated">경우에 따라 호출자에 정의 된 별명 또는 모듈에 액세스하려고합니다. 이를 위해 &lt;code&gt;alias!&lt;/code&gt; 사용할 수 있습니다 ! 매크로 :</target>
        </trans-unit>
        <trans-unit id="ba5d8febe75db79d78b1632bb42524ac427524c5" translate="yes" xml:space="preserve">
          <source>In some situations, you can use the fact the formatter does not generate elegant code as a hint for refactoring. Take this code:</source>
          <target state="translated">경우에 따라 포맷터가 리팩토링을위한 힌트로 우아한 코드를 생성하지 않는다는 사실을 사용할 수 있습니다. 이 코드를 보자 :</target>
        </trans-unit>
        <trans-unit id="fa2a12aa6aedffdc527ed2aeaa4a499eafdd3bd3" translate="yes" xml:space="preserve">
          <source>In such cases, developers should instead import or alias the module directly, so that they can customize those as they wish, without the indirection behind &lt;a href=&quot;#use/2&quot;&gt;&lt;code&gt;use/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 경우 개발자는 대신 모듈을 직접 가져 오거나 별명을 지정하여 &lt;a href=&quot;#use/2&quot;&gt; &lt;code&gt;use/2&lt;/code&gt; &lt;/a&gt; 의 간접적 인 지시없이 원하는대로 원하는대로 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ee68d6d5538c71b755e522365fc502dbb4b5228" translate="yes" xml:space="preserve">
          <source>In summary, documentation is a contract with users of your API, who may not necessarily have access to the source code; whereas code comments are for those who interact directly with the source. You can learn and express different guarantees about your software by separating those two concepts.</source>
          <target state="translated">요약하면, 문서는 API 사용자와의 계약이며 소스 코드에 액세스 할 필요는 없습니다. 코드 주석은 소스와 직접 상호 작용하는 사람들을위한 것입니다. 두 가지 개념을 분리하여 소프트웨어에 대한 다양한 보증을 배우고 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88056ec75ab5d6672e9f690c2cbe9609ac25a458" translate="yes" xml:space="preserve">
          <source>In the &quot;Mix.Task&quot; section, we have defined a task that would be available to everyone using our project as a dependency. What if we wanted the task to only be available for our project? Just define an alias:</source>
          <target state="translated">&quot;Mix.Task&quot;섹션에서 프로젝트를 종속성으로 사용하는 모든 사람이 사용할 수있는 작업을 정의했습니다. 작업이 프로젝트에만 제공되도록하려면 어떻게해야합니까? 별명을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="ff37981f126b5bf2fa55d0c06620d51ba16e7f55" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;agent&quot;&gt;previous chapter&lt;/a&gt;, we used agents to represent our buckets. In the &lt;a href=&quot;introduction-to-mix&quot;&gt;introduction to mix&lt;/a&gt;, we specified we would like to name each bucket so we can do the following:</source>
          <target state="translated">에서 &lt;a href=&quot;agent&quot;&gt;이전 장&lt;/a&gt; , 우리는 우리의 버킷을 표현하기 위해 에이전트를 사용했다. &lt;a href=&quot;introduction-to-mix&quot;&gt;mix 소개&lt;/a&gt; 에서는 각 버킷의 이름을 지정하여 다음을 수행 할 수 있도록 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="3b5fc14f69e9c66ff005f61efabe92506fc54ff9" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;basic-types&quot;&gt;previous chapter&lt;/a&gt;, we saw Elixir provides &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; as arithmetic operators, plus the functions &lt;code&gt;div/2&lt;/code&gt; and &lt;code&gt;rem/2&lt;/code&gt; for integer division and remainder.</source>
          <target state="translated">에서 &lt;a href=&quot;basic-types&quot;&gt;이전 장&lt;/a&gt; , 우리는 비약이 제공하는 본 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; 산술 연산자, 플러스 기능과 같은 &lt;code&gt;div/2&lt;/code&gt; 및 &lt;code&gt;rem/2&lt;/code&gt; 정수 나누기와 나머지.</target>
        </trans-unit>
        <trans-unit id="f26102656dadf27f08b5ecc06639ee0453b4518a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;structs&quot;&gt;previous chapter&lt;/a&gt;, we have learned that although structs are maps, they do not share protocol implementations with maps. For example, &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;s (sets based on maps) are implemented as structs. Let&amp;rsquo;s try to use the &lt;code&gt;Size&lt;/code&gt; protocol with a &lt;code&gt;MapSet&lt;/code&gt;:</source>
          <target state="translated">에서 &lt;a href=&quot;structs&quot;&gt;이전 장&lt;/a&gt; , 우리는 구조체가지도 있지만, 그들은지도와 프로토콜의 구현을 공유하지 않는 것을 배웠습니다. 예를 들어, &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; (맵을 기반으로 한 세트)은 구조체로 구현됩니다. &lt;code&gt;MapSet&lt;/code&gt; 과 함께 &lt;code&gt;Size&lt;/code&gt; 프로토콜을 사용해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="53173cc148f94bd7e146b01b777ce24e106147bb" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;__using__/1&lt;/code&gt; implementation, we will initialize a module attribute named &lt;code&gt;@tests&lt;/code&gt; to an empty list, then store the name of each defined test in this attribute so the tests can be invoked from the &lt;code&gt;run&lt;/code&gt; function.</source>
          <target state="translated">에서 &lt;code&gt;__using__/1&lt;/code&gt; 구현, 우리는 모듈 속성을 이름이 초기화됩니다 &lt;code&gt;@tests&lt;/code&gt; 을 한 후, 빈 목록에 테스트가에서 호출 할 수 있도록이 속성에 정의 된 각 테스트의 이름을 저장 &lt;code&gt;run&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="b21c1f93db813518da68dd14fe39d40364740d5a" translate="yes" xml:space="preserve">
          <source>In the Applications tab, you will see all applications currently running in your system alongside their supervision tree. You can select the &lt;code&gt;kv&lt;/code&gt; application to explore it further:</source>
          <target state="translated">Applications (응용 프로그램) 탭에는 현재 시스템에서 실행중인 모든 응용 프로그램이 감독 트리와 함께 표시됩니다. &lt;code&gt;kv&lt;/code&gt; 애플리케이션을 선택하여 추가로 탐색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bde538c8f6213c2789f457ce470a93e8d2f207d9" translate="yes" xml:space="preserve">
          <source>In the above, process termination refers to unsuccessful termination, which is determined by the &lt;code&gt;:restart&lt;/code&gt; option.</source>
          <target state="translated">위의 프로세스 종료는 실패한 종료를 말하며 &lt;code&gt;:restart&lt;/code&gt; 옵션에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="de44ed6132703d951e8099501d3dde1a95e8c6be" translate="yes" xml:space="preserve">
          <source>In the case of calls to anonymous functions, the inner tuple with the dot special form has only one argument, reflecting the fact that the operator is unary:</source>
          <target state="translated">익명 함수 호출의 경우, 도트 특수 형식의 내부 튜플에는 연산자가 단항이라는 사실을 반영하여 하나의 인수 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="bee66e2e0ed3861603c7e12d98d2bb864e0a4a57" translate="yes" xml:space="preserve">
          <source>In the case of the event &lt;code&gt;:flush&lt;/code&gt; handlers should flush any pending data. This event is triggered by &lt;a href=&quot;#flush/0&quot;&gt;&lt;code&gt;flush/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이벤트의 경우 &lt;code&gt;:flush&lt;/code&gt; 핸들러는 보류중인 데이터를 플러시해야합니다. 이 이벤트는 &lt;a href=&quot;#flush/0&quot;&gt; &lt;code&gt;flush/0&lt;/code&gt; &lt;/a&gt; 에 의해 트리거됩니다 .</target>
        </trans-unit>
        <trans-unit id="a7d253a49741f6c380664521d0e7ead5dde4a470" translate="yes" xml:space="preserve">
          <source>In the code above, we have a process, which we call &amp;ldquo;the client&amp;rdquo; sending a request to an agent, &amp;ldquo;the server&amp;rdquo;. The request contains an anonymous function, which must be executed by the server.</source>
          <target state="translated">위의 코드에는 요청을 에이전트 인 &quot;서버&quot;로 보내는 &quot;클라이언트&quot;라고하는 프로세스가 있습니다. 요청에 익명 함수가 포함되어 있으며 서버에서 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="2ea691104e7ec52f4ddc63f9f0cace981d953b17" translate="yes" xml:space="preserve">
          <source>In the environment you can access the current filename, line numbers, set up aliases, the current function and others.</source>
          <target state="translated">환경에서 현재 파일 이름, 줄 번호, 별명 설정, 현재 기능 및 기타에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0731e3b2d6896ada3ab5956119cf51186ed0825" translate="yes" xml:space="preserve">
          <source>In the environment you can access the filename, line numbers, set up aliases, the function and others.</source>
          <target state="translated">환경에서 파일 이름, 줄 번호, 별명 설정, 기능 및 기타에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2913df470cab8312823dbbd9aad2e70e4f9242e6" translate="yes" xml:space="preserve">
          <source>In the example above we have created the alias &lt;code&gt;some_alias&lt;/code&gt; that will run the task &lt;code&gt;mix hex.info&lt;/code&gt;, then &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; to run an Elixir script, then &lt;a href=&quot;mix.tasks.cmd&quot;&gt;&lt;code&gt;mix cmd&lt;/code&gt;&lt;/a&gt; to execute a command line shell script. This shows how powerful aliases mixed with Mix tasks can be.</source>
          <target state="translated">위의 예제에서 우리는 작업 &lt;code&gt;mix hex.info&lt;/code&gt; 실행하는 &lt;code&gt;some_alias&lt;/code&gt; 별칭을 생성 한 다음 &lt;a href=&quot;mix.tasks.run&quot;&gt; &lt;code&gt;mix run&lt;/code&gt; &lt;/a&gt; 을 사용하여 Elixir 스크립트 를 실행 &lt;a href=&quot;mix.tasks.cmd&quot;&gt; &lt;code&gt;mix cmd&lt;/code&gt; &lt;/a&gt; 다음 cmd 를 혼합 하여 명령 행 쉘 스크립트를 실행합니다. 이것은 믹스 작업과 혼합 된 강력한 별칭이 될 수있는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="8a1ba160e9b96d6822e0f9cf64aea8a58c334907" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#max/1&quot;&gt;&lt;code&gt;max/1&lt;/code&gt;&lt;/a&gt; returned March 31st instead of April 1st because the structural comparison compares the day before the year. This can be addressed by using &lt;a href=&quot;#max_by/3&quot;&gt;&lt;code&gt;max_by/3&lt;/code&gt;&lt;/a&gt; and by relying on structures where the most significant digits come first. In this particular case, we can use &lt;a href=&quot;date#to_erl/1&quot;&gt;&lt;code&gt;Date.to_erl/1&lt;/code&gt;&lt;/a&gt; to get a tuple representation with year, month and day fields:</source>
          <target state="translated">위의 예에서 &lt;a href=&quot;#max/1&quot;&gt; &lt;code&gt;max/1&lt;/code&gt; &lt;/a&gt; 은 4 월 1 일 대신 3 월 31 일을 반환했습니다. 구조 비교는 전날을 비교하기 때문입니다. &lt;a href=&quot;#max_by/3&quot;&gt; &lt;code&gt;max_by/3&lt;/code&gt; &lt;/a&gt; 를 사용 하고 최상위 숫자가 가장 먼저 오는 구조 를 사용 하여이 문제를 해결할 수 있습니다 . 이 경우 &lt;a href=&quot;date#to_erl/1&quot;&gt; &lt;code&gt;Date.to_erl/1&lt;/code&gt; &lt;/a&gt; 을 사용 하여 연도, 월 및 일 필드로 튜플 표현을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00b3dfc102ba0bf3e9031dc021dd5e02de63d0cd" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#max/2&quot;&gt;&lt;code&gt;max/2&lt;/code&gt;&lt;/a&gt; returned March 31st instead of April 1st because the structural comparison compares the day before the year. In such cases it is common for modules to provide functions such as &lt;a href=&quot;date#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt; that perform semantic comparison.</source>
          <target state="translated">위의 예에서 &lt;a href=&quot;#max/2&quot;&gt; &lt;code&gt;max/2&lt;/code&gt; &lt;/a&gt; 는 4 월 1 일 대신 3 월 31 일을 반환했습니다. 구조 비교는 전날을 비교하기 때문입니다. 이러한 경우 모듈에서 의미 비교를 수행하는 &lt;a href=&quot;date#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; &lt;/a&gt; 와 같은 기능을 제공하는 것이 일반적입니다 .</target>
        </trans-unit>
        <trans-unit id="7872f4b6748675f8cea9f2aac1d82fd307d18a15" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#min/1&quot;&gt;&lt;code&gt;min/1&lt;/code&gt;&lt;/a&gt; returned April 1st instead of March 31st because the structural comparison compares the day before the year. This can be addressed by using &lt;a href=&quot;#min_by/3&quot;&gt;&lt;code&gt;min_by/3&lt;/code&gt;&lt;/a&gt; and by relying on structures where the most significant digits come first. In this particular case, we can use &lt;a href=&quot;date#to_erl/1&quot;&gt;&lt;code&gt;Date.to_erl/1&lt;/code&gt;&lt;/a&gt; to get a tuple representation with year, month and day fields:</source>
          <target state="translated">위의 예제에서 &lt;a href=&quot;#min/1&quot;&gt; &lt;code&gt;min/1&lt;/code&gt; &lt;/a&gt; 은 3 월 31 일 대신 4 월 1 일을 반환했으며, 구조 비교는 전날을 비교하기 때문입니다. 이것은 &lt;a href=&quot;#min_by/3&quot;&gt; &lt;code&gt;min_by/3&lt;/code&gt; &lt;/a&gt; 를 사용 하고 최상위 숫자가 가장 먼저 오는 구조 를 사용하여 해결할 수 있습니다 . 이 경우 &lt;a href=&quot;date#to_erl/1&quot;&gt; &lt;code&gt;Date.to_erl/1&lt;/code&gt; &lt;/a&gt; 을 사용 하여 연도, 월 및 일 필드로 튜플 표현을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cf57110afa2caf6b8fbffc8cc551e293da6c450" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#min/2&quot;&gt;&lt;code&gt;min/2&lt;/code&gt;&lt;/a&gt; returned April 1st instead of March 31st because the structural comparison compares the day before the year. In such cases it is common for modules to provide functions such as &lt;a href=&quot;date#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt; that perform semantic comparison.</source>
          <target state="translated">위의 예제에서 &lt;a href=&quot;#min/2&quot;&gt; &lt;code&gt;min/2&lt;/code&gt; &lt;/a&gt; 는 3 월 31 일 대신 4 월 1 일을 반환했으며, 구조 비교는 전날을 비교하기 때문입니다. 이러한 경우 모듈에서 의미 비교를 수행하는 &lt;a href=&quot;date#compare/2&quot;&gt; &lt;code&gt;Date.compare/2&lt;/code&gt; &lt;/a&gt; 와 같은 기능을 제공하는 것이 일반적입니다 .</target>
        </trans-unit>
        <trans-unit id="b3ad3c30dbfab7415bf70f15c8e5b3a581930bcb" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt; accumulates the result of each call to &lt;code&gt;fun&lt;/code&gt; into a list in reverse order, which is correctly ordered at the end by calling &lt;a href=&quot;enum#reverse/1&quot;&gt;&lt;code&gt;Enum.reverse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">위의 예에서 &lt;a href=&quot;enum#reduce/3&quot;&gt; &lt;code&gt;Enum.reduce/3&lt;/code&gt; &lt;/a&gt; 는 각 &lt;code&gt;fun&lt;/code&gt; 의 호출 결과를 역순으로 목록에 누적합니다 . &lt;a href=&quot;enum#reverse/1&quot;&gt; &lt;code&gt;Enum.reverse/1&lt;/code&gt; &lt;/a&gt; 을 호출하면 마지막에 올바르게 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ab2fe333dba7cd1bd613d8d2e21311292cba7df" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;1..100_000 |&amp;gt; Stream.map(&amp;amp;(&amp;amp;1 * 3))&lt;/code&gt; returns a data type, an actual stream, that represents the &lt;code&gt;map&lt;/code&gt; computation over the range &lt;code&gt;1..100_000&lt;/code&gt;:</source>
          <target state="translated">위의 예에서 &lt;code&gt;1..100_000 |&amp;gt; Stream.map(&amp;amp;(&amp;amp;1 * 3))&lt;/code&gt; 은 &lt;code&gt;1..100_000&lt;/code&gt; 범위 의 &lt;code&gt;map&lt;/code&gt; 계산 을 나타내는 실제 스트림 인 데이터 유형을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d7c845572f115897b2ebea0f8fac31816b299fd4" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;a&lt;/code&gt; returns 10 even if the macro is apparently setting it to 1 because variables defined in the macro do not affect the context the macro is executed in. If you want to set or get a variable in the caller's context, you can do it with the help of the &lt;code&gt;var!&lt;/code&gt; macro:</source>
          <target state="translated">위의 예제 에서 매크로에 정의 된 변수는 매크로가 실행되는 컨텍스트에 영향을 미치지 않기 때문에 매크로가 1로 설정되어 있어도 &lt;code&gt;a&lt;/code&gt; 는 10을 반환합니다. 호출자의 컨텍스트에서 변수를 설정하거나 가져 오려면 &lt;code&gt;var!&lt;/code&gt; 의 도움으로 할 수 있습니다 ! 매크로 :</target>
        </trans-unit>
        <trans-unit id="7a7545c257a489979c415df1e9f0cbb1c93d77bd" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;bar&lt;/code&gt; will be returned if &lt;code&gt;foo&lt;/code&gt; evaluates to a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;). Otherwise, &lt;code&gt;nil&lt;/code&gt; will be returned.</source>
          <target state="translated">위의 예제에서 &lt;code&gt;foo&lt;/code&gt; 가 true 값 ( &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 이 아닌)으로 평가 되면 &lt;code&gt;bar&lt;/code&gt; 가 리턴됩니다 . 그렇지 않으면 &lt;code&gt;nil&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7eacffd5adbf5fd949bb658e0457a877aa95d246" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;value&lt;/code&gt; is going to be &lt;code&gt;7&lt;/code&gt; or &lt;code&gt;13&lt;/code&gt; depending on the value of &lt;code&gt;lucky?&lt;/code&gt;. In case &lt;code&gt;value&lt;/code&gt; has no previous value before case, clauses that do not explicitly bind a value have the variable bound to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">위의 예에서, &lt;code&gt;value&lt;/code&gt; 될 것이다 &lt;code&gt;7&lt;/code&gt; 또는 &lt;code&gt;13&lt;/code&gt; 의 값에 따라 &lt;code&gt;lucky?&lt;/code&gt; . case가 &lt;code&gt;value&lt;/code&gt; 에 이전 값 이없는 경우 값 을 명시 적으로 바인딩하지 않는 절은 변수가 &lt;code&gt;nil&lt;/code&gt; 에 바인딩됩니다 .</target>
        </trans-unit>
        <trans-unit id="72cbf21e3fa3d74880817514a949e8994722f839" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;x&lt;/code&gt; cannot be accessed since it was defined inside the &lt;code&gt;try&lt;/code&gt; clause. A common practice to address this issue is to return the variables defined inside &lt;code&gt;try&lt;/code&gt;:</source>
          <target state="translated">위의 예에서, &lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;try&lt;/code&gt; 절 안에 정의되었으므로 액세스 할 수 없습니다 . 이 문제를 해결하는 일반적인 방법은 &lt;code&gt;try&lt;/code&gt; 내부에 정의 된 변수를 반환하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="3bed3d677daa97ab1f5b51e489879c2e74facf10" translate="yes" xml:space="preserve">
          <source>In the example above, a &lt;code&gt;sum/2&lt;/code&gt; function is defined; this function receives two arguments and returns their sum.</source>
          <target state="translated">위의 예에서 &lt;code&gt;sum/2&lt;/code&gt; 함수가 정의되었습니다. 이 함수는 두 개의 인수를 받고 합계를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9fb262ec317cb005dd946c4cd7d04d84b1f69668" translate="yes" xml:space="preserve">
          <source>In the example above, a set of macros named &lt;code&gt;user&lt;/code&gt; but with different arities will be defined to manipulate the underlying record.</source>
          <target state="translated">위의 예제에서 &lt;code&gt;user&lt;/code&gt; 라는 이름의 매크로 가 있지만 다른 속성을 가진 매크로 집합은 기본 레코드를 조작하도록 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="0c0f218463838143ec4982ca79e4ec70bc05323d" translate="yes" xml:space="preserve">
          <source>In the example above, a supervisor was started by passing the supervision structure to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt;. However, supervisors can also be created by explicitly defining a supervision module:</source>
          <target state="translated">위의 예에서 감독 구조는 &lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; 로 전달하여 감독자가 시작되었습니다 . 그러나 감독 모듈을 명시 적으로 정의하여 감독자를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="442ca993474ce04915ab444e69370d1fd701d187" translate="yes" xml:space="preserve">
          <source>In the example above, as we mapped over the range, the elements being enumerated were created one by one, during enumeration. The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; module allows us to map the range, without triggering its enumeration:</source>
          <target state="translated">위의 예에서 범위를 매핑하면 열거되는 요소가 열거 중에 하나씩 만들어졌습니다. &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 모듈은 열거를 트리거하지 않고, 범위를 매핑 할 수있게 해준다 :</target>
        </trans-unit>
        <trans-unit id="73b31064dddafd7aceb7c6dd33acb2dfd723e612" translate="yes" xml:space="preserve">
          <source>In the example above, by using &lt;code&gt;TestCase&lt;/code&gt;, we can write tests using the &lt;code&gt;test&lt;/code&gt; macro, which defines a function named &lt;code&gt;run&lt;/code&gt; to automatically run all tests for us. Our prototype will rely on the match operator (&lt;code&gt;=&lt;/code&gt;) as a mechanism to do assertions.</source>
          <target state="translated">위의 예에서 &lt;code&gt;TestCase&lt;/code&gt; 를 사용하면 &lt;code&gt;test&lt;/code&gt; 매크로를 사용하여 테스트를 작성할 수 있습니다. 테스트 매크로는 &lt;code&gt;run&lt;/code&gt; 이라는 함수를 정의하여 모든 테스트를 자동으로 실행합니다. 프로토 타입은 어설 션을 수행하는 메커니즘으로 일치 연산자 ( &lt;code&gt;=&lt;/code&gt; )를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f3bbbdd7b6d7f4d0dd2d5c03396c880a058ec265" translate="yes" xml:space="preserve">
          <source>In the example above, even though the macro injects &lt;code&gt;a = 1&lt;/code&gt;, it does not affect the variable &lt;code&gt;a&lt;/code&gt; defined by the &lt;code&gt;go&lt;/code&gt; function. If a macro wants to explicitly affect the context, it can use &lt;code&gt;var!&lt;/code&gt;:</source>
          <target state="translated">위의 예에서 매크로가 &lt;code&gt;a = 1&lt;/code&gt; 주입하더라도 &lt;code&gt;go&lt;/code&gt; 함수에 의해 정의 된 변수 &lt;code&gt;a&lt;/code&gt; 에는 영향을 미치지 않습니다 . 매크로가 컨텍스트에 명시 적으로 영향을 미치려면 &lt;code&gt;var!&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="df21e3e8f902f80311e9ed366624d965e22d8f36" translate="yes" xml:space="preserve">
          <source>In the example above, even though the right list has more entries than the left one, destructuring works fine. If the right list is smaller, the remaining elements are simply set to &lt;code&gt;nil&lt;/code&gt;:</source>
          <target state="translated">위의 예에서 오른쪽 목록에 왼쪽 목록보다 많은 항목이 있더라도 구조화가 제대로 작동합니다. 올바른 목록이 더 작 으면 나머지 요소는 단순히 &lt;code&gt;nil&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad9447b0ab139bf0ce77de940f7116ad1118f9e7" translate="yes" xml:space="preserve">
          <source>In the example above, pattern matching works because underneath structs are bare maps with a fixed set of fields. As maps, structs store a &amp;ldquo;special&amp;rdquo; field named &lt;code&gt;__struct__&lt;/code&gt; that holds the name of the struct:</source>
          <target state="translated">위 예제에서 패턴 일치는 구조체 아래에 고정 된 필드 집합이있는 베어 맵이기 때문에 작동합니다. 구조체는 구조체로서 구조체 이름 을 보유한 &lt;code&gt;__struct__&lt;/code&gt; 라는&amp;ldquo;특별한&amp;rdquo;필드를 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="dae57a394eb52ab25120ea39543d455089abff36" translate="yes" xml:space="preserve">
          <source>In the example above, since we are invoking &lt;code&gt;alias&lt;/code&gt; inside the function &lt;code&gt;plus/2&lt;/code&gt;, the alias will be valid only inside the function &lt;code&gt;plus/2&lt;/code&gt;. &lt;code&gt;minus/2&lt;/code&gt; won&amp;rsquo;t be affected at all.</source>
          <target state="translated">위의 예제에서 &lt;code&gt;plus/2&lt;/code&gt; 함수 내에서 &lt;code&gt;alias&lt;/code&gt; 를 호출하기 때문에 alias / 2 는 &lt;code&gt;plus/2&lt;/code&gt; 함수 내에서만 유효합니다 . &lt;code&gt;minus/2&lt;/code&gt; 는 전혀 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="062b7f604b56dd870819716494d195af709ce6fe" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;|&amp;gt;&lt;/code&gt; pipe is the right-most pipe; &lt;code&gt;arg1&lt;/code&gt; is the AST for &lt;code&gt;100 |&amp;gt; div(5)&lt;/code&gt;, and &lt;code&gt;arg2&lt;/code&gt; is the AST for &lt;code&gt;div(2)&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 &lt;code&gt;|&amp;gt;&lt;/code&gt; 파이프는 가장 오른쪽 파이프입니다. &lt;code&gt;arg1&lt;/code&gt; 은 &lt;code&gt;100 |&amp;gt; div(5)&lt;/code&gt; 의 AST 이고 &lt;code&gt;arg2&lt;/code&gt; 는 &lt;code&gt;div(2)&lt;/code&gt; 의 AST입니다 .</target>
        </trans-unit>
        <trans-unit id="3764d5750387486a4a8182c32859bf0c44e3a53a" translate="yes" xml:space="preserve">
          <source>In the example above, the imported &lt;code&gt;List.duplicate/2&lt;/code&gt; is only visible within that specific function. &lt;code&gt;duplicate/2&lt;/code&gt; won&amp;rsquo;t be available in any other function in that module (or any other module for that matter).</source>
          <target state="translated">위의 예에서 가져온 &lt;code&gt;List.duplicate/2&lt;/code&gt; 는 해당 특정 함수 내에서만 볼 수 있습니다. 해당 모듈의 다른 기능 (또는 해당 사안의 다른 모듈)에서는 &lt;code&gt;duplicate/2&lt;/code&gt; 를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a9ba96d97b36e1f6537a9985e8f45706e25424fa" translate="yes" xml:space="preserve">
          <source>In the example above, the linked process died by sending an &lt;code&gt;exit&lt;/code&gt; signal with a value of 1. The Elixir shell automatically handles those messages and prints them to the terminal.</source>
          <target state="translated">위의 예에서, 링크 된 프로세스는 값이 1 인 &lt;code&gt;exit&lt;/code&gt; 신호를 전송하여 종료 되었습니다 . Elixir 쉘은 자동으로 해당 메시지를 처리하여 터미널에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="df1a4779609dfb3efd8db910186e109c073a0338" translate="yes" xml:space="preserve">
          <source>In the example above, the list &lt;code&gt;[1, [2], 3]&lt;/code&gt; is passed as the first argument to the &lt;a href=&quot;list#flatten/1&quot;&gt;&lt;code&gt;List.flatten/1&lt;/code&gt;&lt;/a&gt; function, then the flattened list is passed as the first argument to the &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; function which doubles each element of the list.</source>
          <target state="translated">위의 예에서,리스트 &lt;code&gt;[1, [2], 3]&lt;/code&gt; 은 &lt;a href=&quot;list#flatten/1&quot;&gt; &lt;code&gt;List.flatten/1&lt;/code&gt; &lt;/a&gt; 함수에 첫 번째 인수로 전달 된 다음, 병합 된 목록이 &lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt; 함수에 첫 번째 인수로 전달됩니다. 목록의 각 요소를 두 배로 늘립니다.</target>
        </trans-unit>
        <trans-unit id="30a372309337ceccb6cd8c47007e31bef89794f8" translate="yes" xml:space="preserve">
          <source>In the example above, the shell will be expecting more input until it finds the closing quote. Sometimes it is not obvious which character the shell is expecting, and the user may find themselves trapped in the state of incomplete expression with no ability to terminate it other than by exiting the shell.</source>
          <target state="translated">위의 예에서 쉘은 닫는 인용 부호를 찾을 때까지 더 많은 입력을 예상합니다. 때로는 쉘이 어떤 문자를 기대하는지 명확하지 않으며 사용자는 쉘을 종료하는 것 외에는 종료 할 수없는 불완전한 표현 상태에 빠질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c1055e1dbf2125278d879200ab263f9e383b43c" translate="yes" xml:space="preserve">
          <source>In the example above, this happens:</source>
          <target state="translated">위의 예에서 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c8625f3069f10910c0e9de120b21d6981d601654" translate="yes" xml:space="preserve">
          <source>In the example above, two modules - &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Foo.Bar&lt;/code&gt; - are created. When nesting, Elixir automatically creates an alias to the inner module, allowing the second module &lt;code&gt;Foo.Bar&lt;/code&gt; to be accessed as &lt;code&gt;Bar&lt;/code&gt; in the same lexical scope where it's defined (the &lt;code&gt;Foo&lt;/code&gt; module). This only happens if the nested module is defined via an alias.</source>
          <target state="translated">위의 예에서 &lt;code&gt;Foo&lt;/code&gt; 및 &lt;code&gt;Foo.Bar&lt;/code&gt; 의 두 모듈 이 생성됩니다. 중첩시 Elixir는 내부 모듈에 대한 별칭을 자동으로 생성하여 두 번째 모듈 &lt;code&gt;Foo.Bar&lt;/code&gt; 를 정의 된 동일한 어휘 범위 ( &lt;code&gt;Foo&lt;/code&gt; 모듈) 에서 &lt;code&gt;Bar&lt;/code&gt; 로 액세스 할 수 있습니다 . 중첩 모듈이 별칭을 통해 정의 된 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cee742c4ffa43a93d2e20f415d5f42aefbd9bd95" translate="yes" xml:space="preserve">
          <source>In the example above, we are explicitly setting the version attribute for that module. &lt;code&gt;@vsn&lt;/code&gt; is used by the code reloading mechanism in the Erlang</source>
          <target state="translated">위의 예에서는 해당 모듈의 버전 속성을 명시 적으로 설정하고 있습니다. &lt;code&gt;@vsn&lt;/code&gt; 은 Erlang의 코드 재로드 메커니즘에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="021f23fc44f1b5057c72ccb35305764a702bc70f" translate="yes" xml:space="preserve">
          <source>In the example above, we are mutating both the array and the variable &lt;code&gt;i&lt;/code&gt;. Mutating is not possible in Elixir. Instead, functional languages rely on recursion: a function is called recursively until a condition is reached that stops the recursive action from continuing. No data is mutated in this process. Consider the example below that prints a string an arbitrary number of times:</source>
          <target state="translated">위의 예에서 배열과 변수 &lt;code&gt;i&lt;/code&gt; 모두를 변경합니다 . 엘릭서에서는 돌연변이가 불가능합니다. 대신 기능 언어는 재귀에 의존합니다. 재귀 동작이 계속되는 것을 막는 조건에 도달 할 때까지 함수를 재귀 적으로 호출합니다. 이 프로세스에서 데이터가 변경되지 않았습니다. 문자열을 임의의 횟수만큼 인쇄하는 아래 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d5006566e063521dde7ab998be88e6cd1a64640e" translate="yes" xml:space="preserve">
          <source>In the example above, we can access the value &lt;code&gt;foo&lt;/code&gt; under the binding &lt;code&gt;assigns&lt;/code&gt; using &lt;code&gt;@foo&lt;/code&gt;. This is useful because a template, after being compiled, can receive different assigns and would not require recompilation for each variable set.</source>
          <target state="translated">위의 예에서 &lt;code&gt;@foo&lt;/code&gt; 를 사용하여 바인딩 &lt;code&gt;assigns&lt;/code&gt; 에서 &lt;code&gt;foo&lt;/code&gt; 값에 액세스 할 수 있습니다 . 이는 템플릿을 컴파일 한 후 다른 할당을 수신 할 수 있고 각 변수 세트에 대해 재 컴파일을 요구하지 않기 때문에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5661752d4cc9fd9fdd4a2d139f2888ecb877cbf6" translate="yes" xml:space="preserve">
          <source>In the example above, we captured &lt;a href=&quot;kernel#is_atom/1&quot;&gt;&lt;code&gt;Kernel.is_atom/1&lt;/code&gt;&lt;/a&gt; as an anonymous function and then invoked it.</source>
          <target state="translated">위의 예에서 &lt;a href=&quot;kernel#is_atom/1&quot;&gt; &lt;code&gt;Kernel.is_atom/1&lt;/code&gt; &lt;/a&gt; 을 익명 함수로 캡처 한 다음 호출했습니다.</target>
        </trans-unit>
        <trans-unit id="e3bbf3a8f78417d03c53c8a99adeb57f91aa4785" translate="yes" xml:space="preserve">
          <source>In the example above, we create tasks that sleep from 1 up to 10 seconds and return the number of seconds they slept for. If you execute the code all at once, you should see 1 up to 5 printed, as those were the tasks that have replied in the given time. All other tasks will have been shut down using the &lt;a href=&quot;task#shutdown/2&quot;&gt;&lt;code&gt;Task.shutdown/2&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">위의 예에서 1 ~ 10 초까지 절전 모드로 전환 한 작업을 생성합니다. 코드를 한 번에 모두 실행하면 주어진 시간에 응답 한 작업과 같이 1 ~ 5까지 인쇄 된 것으로 표시됩니다. 다른 모든 작업은 &lt;a href=&quot;task#shutdown/2&quot;&gt; &lt;code&gt;Task.shutdown/2&lt;/code&gt; &lt;/a&gt; 호출을 사용하여 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="43dbb6ffa3efa205c169cb0eb943acb32507c0e1" translate="yes" xml:space="preserve">
          <source>In the example above, we defined an anonymous function that receives two arguments, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and returns the result of &lt;code&gt;a + b&lt;/code&gt;. The arguments are always on the left-hand side of &lt;code&gt;-&amp;gt;&lt;/code&gt; and the code to be executed on the right-hand side. The anonymous function is stored in the variable &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">위의 예에서, 우리는 두 개의 인수 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 를 받고 &lt;code&gt;a + b&lt;/code&gt; 의 결과를 반환 하는 익명 함수를 정의했습니다 . 인수는 항상 &lt;code&gt;-&amp;gt;&lt;/code&gt; 의 왼쪽 에 있고 코드는 오른쪽에 있습니다. 익명 함수는 변수 &lt;code&gt;add&lt;/code&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b2957729dcc7602ce0c24fbab3553e81f82dbdc" translate="yes" xml:space="preserve">
          <source>In the example above, we defined specs for workers and supervisors. These specs (both for workers as well as supervisors) accept the following options:</source>
          <target state="translated">위의 예에서 작업자와 감독자에 대한 사양을 정의했습니다. 이러한 사양 (작업자 및 감독자 모두)은 다음 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="5e6b4da92c054f57ac5d7ebeeafc523687c5adff" translate="yes" xml:space="preserve">
          <source>In the example above, we have created a new port that executes the program &lt;code&gt;cat&lt;/code&gt;. &lt;code&gt;cat&lt;/code&gt; is a program available on UNIX systems that receives data from multiple inputs and concatenates them in the output.</source>
          <target state="translated">위의 예에서 &lt;code&gt;cat&lt;/code&gt; 프로그램을 실행하는 새 포트를 만들었습니다 . &lt;code&gt;cat&lt;/code&gt; 은 여러 입력에서 데이터를 수신하여 출력에 연결하는 UNIX 시스템에서 사용 가능한 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="b0e39547d1868b820dfb08e74cce03806dbaf13c" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined a tag called &lt;code&gt;:cd&lt;/code&gt; that is read in the setup callback to configure the working directory the test is going to run on.</source>
          <target state="translated">위의 예제에서는 테스트가 실행될 작업 디렉토리를 구성하기 위해 설정 콜백에서 읽은 &lt;code&gt;:cd&lt;/code&gt; 라는 태그를 정의했습니다 .</target>
        </trans-unit>
        <trans-unit id="0fd333e5963bb492deae7a782ebcecbae48824d5" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined an alias named &lt;code&gt;mix all&lt;/code&gt;, that prints &quot;Hello world&quot;, then fetches dependencies specific to the current environment, and compiles the project.</source>
          <target state="translated">위의 예에서는 &lt;code&gt;mix all&lt;/code&gt; 이라는 별칭을 정의하여 &quot;Hello world&quot;를 인쇄 한 다음 현재 환경과 관련된 종속성을 가져 와서 프로젝트를 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="b55e3dbdcda3974f9c85104c4aab9938de0f3064" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined two aliases. One is &lt;code&gt;mix c&lt;/code&gt; which is a shortcut for &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;. The other is named &lt;code&gt;mix hello&lt;/code&gt;, which is the equivalent to the &lt;code&gt;Mix.Tasks.Hello&lt;/code&gt; we have defined in the &quot;Mix.Task&quot; section.</source>
          <target state="translated">위의 예에서는 두 개의 별칭을 정의했습니다. 하나는 &lt;code&gt;mix c&lt;/code&gt; &lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt; 의 바로 가기 인 믹스 c 입니다 . 다른 하나는 &lt;code&gt;mix hello&lt;/code&gt; 이며, 이것은 &quot;Mix.Task&quot;섹션에서 정의한 &lt;code&gt;Mix.Tasks.Hello&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="61eada0cb9cbd1b50540cd6782b9dfeead876351" translate="yes" xml:space="preserve">
          <source>In the example above, we have generated the functions &lt;code&gt;foo/0&lt;/code&gt; and &lt;code&gt;bar/0&lt;/code&gt; dynamically. Now, imagine that we want to convert this functionality into a macro:</source>
          <target state="translated">위의 예에서 함수 &lt;code&gt;foo/0&lt;/code&gt; 및 &lt;code&gt;bar/0&lt;/code&gt; 을 동적으로 생성했습니다. 이제이 기능을 매크로로 변환하려고한다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="5c4c73a0b16c4020cd89858453c999ce24f50d3b" translate="yes" xml:space="preserve">
          <source>In the example above, we have set up &lt;code&gt;MyKeyword&lt;/code&gt; to be aliased as &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;. So now, any reference to &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt; will be automatically replaced by &lt;code&gt;MyKeyword&lt;/code&gt;.</source>
          <target state="translated">위의 예에서는 &lt;code&gt;MyKeyword&lt;/code&gt; 가 &lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; 별칭으로 설정되었습니다 . 이제 &lt;a href=&quot;keyword&quot;&gt; &lt;code&gt;Keyword&lt;/code&gt; &lt;/a&gt; 대한 참조 는 &lt;code&gt;MyKeyword&lt;/code&gt; 로 자동 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="053a645de735a836658d24ec36de529750445dbd" translate="yes" xml:space="preserve">
          <source>In the example above, we have used the &lt;code&gt;plug/1&lt;/code&gt; macro to connect functions that will be invoked when there is a web request. Internally, every time you call &lt;code&gt;plug/1&lt;/code&gt;, the Plug library stores the given argument in a &lt;code&gt;@plugs&lt;/code&gt; attribute. Just before the module is compiled, Plug runs a callback that defines a function (&lt;code&gt;call/2&lt;/code&gt;) which handles HTTP requests. This function will run all plugs inside &lt;code&gt;@plugs&lt;/code&gt; in order.</source>
          <target state="translated">위의 예에서, 우리는 웹 요청이있을 때 호출 될 함수를 연결 하기 위해 &lt;code&gt;plug/1&lt;/code&gt; 매크로를 사용했습니다. 내부적으로 &lt;code&gt;plug/1&lt;/code&gt; 을 호출 할 때마다 Plug 라이브러리는 주어진 인수를 &lt;code&gt;@plugs&lt;/code&gt; 속성 에 저장 합니다. 모듈이 컴파일되기 직전에 Plug 는 HTTP 요청을 처리 하는 함수 ( &lt;code&gt;call/2&lt;/code&gt; )를 정의하는 콜백을 실행 합니다. 이 기능은 &lt;code&gt;@plugs&lt;/code&gt; 내의 모든 플러그 를 순서대로 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="d04cc9035f609252303b7cf3699ee2289f736ec0" translate="yes" xml:space="preserve">
          <source>In the example above, we imported macros from &lt;code&gt;MyMacros&lt;/code&gt;, replacing the original &lt;a href=&quot;kernel#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; implementation by our own within that specific function. All other functions in that module will still be able to use the original one.</source>
          <target state="translated">위의 예에서 &lt;code&gt;MyMacros&lt;/code&gt; 에서 매크로를 가져 와서 특정 기능 내 에서 원래 &lt;a href=&quot;kernel#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt; 구현을 자체적으로 대체했습니다 . 해당 모듈의 다른 모든 기능은 여전히 ​​원래 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="143be83aa54f7c530d19333f4615426ffc2f8abd" translate="yes" xml:space="preserve">
          <source>In the example above, we match &lt;code&gt;thing&lt;/code&gt; against each clause &quot;head&quot; and execute the clause &quot;body&quot; corresponding to the first clause that matches.</source>
          <target state="translated">위의 예에서 우리는 일치하는 &lt;code&gt;thing&lt;/code&gt; 일치하는 첫 번째 조항에 해당하는 조항 &quot;몸&quot;각 절에 &quot;머리&quot;에 대하여 및 실행합니다.</target>
        </trans-unit>
        <trans-unit id="6b838b0193a4108fff85d3563dd635cc22b74b28" translate="yes" xml:space="preserve">
          <source>In the example above, we pass a string with &lt;code&gt;\n&lt;/code&gt; escaped and return a version with it unescaped.</source>
          <target state="translated">위의 예에서 &lt;code&gt;\n&lt;/code&gt; 이스케이프 처리 된 문자열을 전달하고 이스케이프 처리되지 않은 버전을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e34b35a1a0f6a7ae64d902f20f6d3b6957890f8c" translate="yes" xml:space="preserve">
          <source>In the example above, we show how guards can be used in function clauses. There are several constructs that allow guards; for example:</source>
          <target state="translated">위의 예에서 함수 절에서 가드를 사용하는 방법을 보여줍니다. 경비원을 허용하는 몇 가지 구조가 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e73b208830253cfcccda8b595f6a7fc37ec019c4" translate="yes" xml:space="preserve">
          <source>In the example below we register the current process and ask for the number of keys in the registry:</source>
          <target state="translated">아래 예에서는 현재 프로세스를 등록하고 레지스트리에 키 수를 요청합니다.</target>
        </trans-unit>
        <trans-unit id="600451af2621db08950612f2b8a384ceb1caba3b" translate="yes" xml:space="preserve">
          <source>In the example below we register the current process and look it up both from itself and other processes:</source>
          <target state="translated">아래 예제에서는 현재 프로세스를 등록하고 자체 프로세스와 다른 프로세스에서 모두 찾습니다.</target>
        </trans-unit>
        <trans-unit id="798fe8739fe086fd76b2f2f854df6fe2d36c1741" translate="yes" xml:space="preserve">
          <source>In the example below we register the current process under the same key in a duplicate registry but with different values:</source>
          <target state="translated">아래 예에서 현재 프로세스를 중복 레지스트리의 동일한 키에 다른 값으로 등록합니다.</target>
        </trans-unit>
        <trans-unit id="78080544e53670fa0133b74d89a92858bb262655" translate="yes" xml:space="preserve">
          <source>In the example below, we have a macro that generates a module with a function named &lt;code&gt;name_length&lt;/code&gt; that returns the length of the module name. The value of this function will be calculated at compilation time and not at runtime.</source>
          <target state="translated">아래 예 에는 모듈 이름의 길이를 반환하는 &lt;code&gt;name_length&lt;/code&gt; 라는 함수가있는 모듈을 생성하는 매크로가 있습니다 . 이 함수의 값은 런타임이 아닌 컴파일 타임에 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="f8f1d08583916da8a72b67e1316644cdd98dc53a" translate="yes" xml:space="preserve">
          <source>In the example below, we pass a directory to where the &lt;a href=&quot;#c/2&quot;&gt;&lt;code&gt;c/2&lt;/code&gt;&lt;/a&gt; function will write the compiled &lt;code&gt;.beam&lt;/code&gt; files to. This directory is typically named &quot;ebin&quot; in Erlang/Elixir systems:</source>
          <target state="translated">아래 예에서 &lt;a href=&quot;#c/2&quot;&gt; &lt;code&gt;c/2&lt;/code&gt; &lt;/a&gt; 함수가 컴파일 된 &lt;code&gt;.beam&lt;/code&gt; 파일을 쓸 디렉토리를 전달합니다 . 이 디렉토리는 일반적으로 Erlang / Elixir 시스템에서 &quot;ebin&quot;으로 명명됩니다.</target>
        </trans-unit>
        <trans-unit id="15375188c3b299d4050635b90946ba7afce11069" translate="yes" xml:space="preserve">
          <source>In the example below, we use a function to get all the maps inside a list:</source>
          <target state="translated">아래 예에서는 함수를 사용하여 목록 내의 모든 맵을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7b9f19cdead9cbae542d5210ec70e748cea04410" translate="yes" xml:space="preserve">
          <source>In the examples above, all the comprehensions returned lists as their result. However, the result of a comprehension can be inserted into different data structures by passing the &lt;code&gt;:into&lt;/code&gt; option to the comprehension.</source>
          <target state="translated">위의 예에서 모든 이해력은 결과로 목록을 반환했습니다. 그러나 &lt;code&gt;:into&lt;/code&gt; 옵션을 이해 에 전달하면 이해 결과를 다른 데이터 구조에 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e7b33831c78babc5b4b6a0cc0e2347ac123865c0" translate="yes" xml:space="preserve">
          <source>In the examples above, the result returned by the comprehension was always a list. The returned result can be configured by passing an &lt;code&gt;:into&lt;/code&gt; option, that accepts any structure as long as it implements the &lt;a href=&quot;collectable&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol.</source>
          <target state="translated">위의 예에서 이해가 반환 한 결과는 항상 목록이었습니다. &lt;code&gt;:into&lt;/code&gt; 옵션 을 전달하여 리턴 된 결과를 구성 할 수 있습니다 .이 옵션은 &lt;a href=&quot;collectable&quot;&gt; &lt;code&gt;Collectable&lt;/code&gt; &lt;/a&gt; 프로토콜을 구현하는 한 모든 구조를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="d0daacadfe9f7077fb5dcbe6bf521a065a6a635d" translate="yes" xml:space="preserve">
          <source>In the expression above, &lt;code&gt;n &amp;lt;- [1, 2, 3, 4]&lt;/code&gt; is the &lt;strong&gt;generator&lt;/strong&gt;. It is literally generating values to be used in the comprehension. Any enumerable can be passed on the right-hand side of the generator expression:</source>
          <target state="translated">위의 식에서 &lt;code&gt;n &amp;lt;- [1, 2, 3, 4]&lt;/code&gt; 는 &lt;strong&gt;제너레이터&lt;/strong&gt; 입니다. 말 그대로 이해에 사용할 값을 생성합니다. 모든 열거 가능 항목은 생성기 표현식의 오른쪽에 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f3acf5fd7cb6799236adf41693aa239ed339ba4" translate="yes" xml:space="preserve">
          <source>In the first example the accent is before the vowel, so it is considered two graphemes. However, when you reverse it once, you have the vowel followed by the accent, which becomes one grapheme. Reversing it again will keep it as one single grapheme.</source>
          <target state="translated">첫 번째 예에서 악센트는 모음 앞에 있으므로 두 개의 그래 핀으로 간주됩니다. 그러나 한 번 뒤집 으면 모음 뒤에 악센트가 생겨 하나의 그래프가됩니다. 다시 되 돌리면 하나의 그래프로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="edabe1bf622029e68e1aff637ff6cf8ec47fb508" translate="yes" xml:space="preserve">
          <source>In the following sections, our examples are going to get longer in size, and it can be tricky to type them all in the shell. It&amp;rsquo;s about time for us to learn how to compile Elixir code and also how to run Elixir scripts.</source>
          <target state="translated">다음 섹션에서는 예제의 크기가 길어지고 셸에 모두 입력하기가 까다로울 수 있습니다. 이제 Elixir 코드를 컴파일하는 방법과 Elixir 스크립트를 실행하는 방법을 배울 차례입니다.</target>
        </trans-unit>
        <trans-unit id="ea21b7568312a339bf9ae152813dc701fedd0816" translate="yes" xml:space="preserve">
          <source>In the next chapter, we are going to discuss pattern matching through the use of &lt;code&gt;=&lt;/code&gt;, the match operator.</source>
          <target state="translated">다음 장에서는 일치 연산자 인 &lt;code&gt;=&lt;/code&gt; 를 사용하여 패턴 일치에 대해 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="d8135bc13d648cc8121bc02383bb281b2bb322ce" translate="yes" xml:space="preserve">
          <source>In the next chapter, we will explore GenServers, where the segregation between clients and servers is made more apparent.</source>
          <target state="translated">다음 장에서는 클라이언트와 서버 사이의 분리가보다 분명한 GenServer를 살펴볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="71fe1559a8acce4f8cb459f05a93f2c23c27af01" translate="yes" xml:space="preserve">
          <source>In the next chapter, we will start parsing the client requests and sending responses, finishing our server.</source>
          <target state="translated">다음 장에서는 클라이언트 요청을 파싱하고 응답을 보내 서버를 마무리합니다.</target>
        </trans-unit>
        <trans-unit id="97a27cfc769eb0315701a749f650534e93e63132" translate="yes" xml:space="preserve">
          <source>In the next chapters, we&amp;rsquo;ll explore structs and protocols before moving to exception handling and other constructs like sigils and comprehensions.</source>
          <target state="translated">다음 장에서는 예외 처리 및시길 및 이해와 같은 기타 구성으로 이동하기 전에 구조체와 프로토콜을 살펴볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="83c96bdabbdcc08e2e498fa4f73aafa1f188be21" translate="yes" xml:space="preserve">
          <source>In the previous chapter about &lt;code&gt;GenServer&lt;/code&gt;, we implemented &lt;code&gt;KV.Registry&lt;/code&gt; to manage buckets. At some point, we started monitoring buckets so we were able to take action whenever a &lt;code&gt;KV.Bucket&lt;/code&gt; crashed. Although the change was relatively small, it introduced a question which is frequently asked by Elixir developers: what happens when something fails?</source>
          <target state="translated">&lt;code&gt;GenServer&lt;/code&gt; 에 대한 이전 장에서는 버킷을 관리하기 위해 &lt;code&gt;KV.Registry&lt;/code&gt; 를 구현 했습니다 . 어느 시점에서 버킷 모니터링을 시작하여 &lt;code&gt;KV.Bucket&lt;/code&gt; 이 충돌 할 때마다 조치를 취할 수있었습니다 . 변경은 비교적 작았지만 Elixir 개발자가 자주 묻는 질문이있었습니다. 문제가 발생하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="7c0c1e10201013cbed4ae2f15c5fb7856de2269f" translate="yes" xml:space="preserve">
          <source>In the previous chapters, we have always started processes directly. For example, we would call &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt;, which would return &lt;code&gt;{:ok, pid}&lt;/code&gt;, and that would allow us to interact with the registry via its &lt;code&gt;pid&lt;/code&gt;. Now that processes are started by the supervisor, we have to directly ask the supervisor who its children are, and fetch the pid from the returned list of children. In practice, doing so every time would be very expensive. To address this, we often give names to processes, allowing them to be uniquely identified in a single machine from anywhere in our code.</source>
          <target state="translated">이전 장에서는 항상 프로세스를 직접 시작했습니다. 예를 들어, 우리는 부를 것이다 &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt; 반환하는 &lt;code&gt;{:ok, pid}&lt;/code&gt; , 그리고 우리가를 통해 레지스트리와 상호 작용 할 수 있도록 할 &lt;code&gt;pid&lt;/code&gt; . 이제 프로세스가 감독자에 의해 시작되었으므로 관리자에게 자식이 누구인지 직접 요청하고 반환 된 자식 목록에서 pid를 가져와야합니다. 실제로, 매번 그렇게하는 것은 매우 비쌉니다. 이 문제를 해결하기 위해 프로세스 이름을 지정하여 코드의 어느 곳에서나 단일 시스템에서 고유하게 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="023e1eab071b1e9447d8611d553a6798a82a86d3" translate="yes" xml:space="preserve">
          <source>In the previous example, we were not interested in associating a value to the process:</source>
          <target state="translated">이전 예제에서는 프로세스에 값을 연결하는 데 관심이 없었습니다.</target>
        </trans-unit>
        <trans-unit id="59cfb6ab9287629bc99d4335b390c03667b20499" translate="yes" xml:space="preserve">
          <source>In the returned result, keys are variable names and values are the corresponding variable values.</source>
          <target state="translated">리턴 된 결과에서 키는 변수 이름이고 값은 해당 변수 값입니다.</target>
        </trans-unit>
        <trans-unit id="de1b308ba8fcb658982badee13287d07ac9706b3" translate="yes" xml:space="preserve">
          <source>In the second line of the failure, right below the test name, there is the location where the test was defined. If you copy the test location in full, including the file and line number, and append it to &lt;code&gt;mix test&lt;/code&gt;, Mix will load and run just that particular test:</source>
          <target state="translated">테스트 이름 바로 아래 실패의 두 번째 줄에는 테스트가 정의 된 위치가 있습니다. 파일과 줄 번호를 포함하여 테스트 위치를 완전히 복사하고 &lt;code&gt;mix test&lt;/code&gt; 에 추가하면 Mix는 특정 테스트 만로드하고 실행합니다.</target>
        </trans-unit>
        <trans-unit id="56699ac32b40ebbed14cd456a076f153ca769c75" translate="yes" xml:space="preserve">
          <source>In the session above we interacted with the &amp;ldquo;shopping&amp;rdquo; bucket.</source>
          <target state="translated">위 세션에서 우리는&amp;ldquo;쇼핑&amp;rdquo;버킷과 상호 작용했습니다.</target>
        </trans-unit>
        <trans-unit id="99f7aeec7f3d83fb7c14ef77613795b1757f5d28" translate="yes" xml:space="preserve">
          <source>In this case, the answer is yes: if the acceptor crashes, there is no need to crash the existing connections. On the other hand, if the task supervisor crashes, there is no need to crash the acceptor too.</source>
          <target state="translated">이 경우 대답은 '예'입니다. 수락자가 충돌하면 기존 연결을 중단 할 필요가 없습니다. 반면에 작업 관리자가 충돌하면 수락 자도 충돌 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c5b73c40f211641ff7fce3baa3df52cd94ce14cd" translate="yes" xml:space="preserve">
          <source>In this case, there is no module, so we picked the name &lt;code&gt;KV.BucketSupervisor&lt;/code&gt;. It could have been any other name. We also chose the &lt;code&gt;:one_for_one&lt;/code&gt; strategy, which is currently the only available strategy for dynamic supervisors.</source>
          <target state="translated">이 경우 모듈이 없으므로 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 라는 이름을 선택했습니다 . 다른 이름 일 수도 있습니다. 또한 동적 감독자에게 유일하게 사용 가능한 전략 인 &lt;code&gt;:one_for_one&lt;/code&gt; 전략을 선택했습니다 .</target>
        </trans-unit>
        <trans-unit id="69b79e652a12895505240a6d60f23b561b08605d" translate="yes" xml:space="preserve">
          <source>In this case, we are importing only the function &lt;code&gt;duplicate&lt;/code&gt; (with arity 2) from &lt;code&gt;List&lt;/code&gt;. Although &lt;code&gt;:only&lt;/code&gt; is optional, its usage is recommended in order to avoid importing all the functions of a given module inside the namespace. &lt;code&gt;:except&lt;/code&gt; could also be given as an option in order to import everything in a module &lt;em&gt;except&lt;/em&gt; a list of functions.</source>
          <target state="translated">이 경우 &lt;code&gt;List&lt;/code&gt; 에서 함수 &lt;code&gt;duplicate&lt;/code&gt; (arity 2 포함) 만 가져 옵니다 . &lt;code&gt;:only&lt;/code&gt; 는 선택 사항 이지만 네임 스페이스 내에서 지정된 모듈의 모든 기능을 가져 오는 것을 피하기 위해 사용하는 것이 좋습니다. 함수 목록을 &lt;em&gt;제외하고&lt;/em&gt; 모듈의 모든 것을 가져 오기 위해 &lt;code&gt;:except&lt;/code&gt; 를 옵션으로 지정할 수도 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="98ecd27c52ed18c7b95002136d1b65249ac3fde1" translate="yes" xml:space="preserve">
          <source>In this chapter we will learn more about Elixir basic types: integers, floats, booleans, atoms, strings, lists and tuples. Some basic types are:</source>
          <target state="translated">이 장에서는 정수, 부동, 부울, 원자, 문자열, 목록 및 튜플과 같은 Elixir 기본 유형에 대해 자세히 알아 봅니다. 몇 가지 기본 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95bc41f24cd4a15d49d6be30cfe2c21aeb083956" translate="yes" xml:space="preserve">
          <source>In this chapter, we are going to explore sigils, which are one of the mechanisms provided by the language for working with textual representations. Sigils start with the tilde (&lt;code&gt;~&lt;/code&gt;) character which is followed by a letter (which identifies the sigil) and then a delimiter; optionally, modifiers can be added after the final delimiter.</source>
          <target state="translated">이 장에서는 텍스트 표현 작업을 위해 언어에서 제공하는 메커니즘 중 하나 인시길을 살펴 보겠습니다. 시길은 물결표 ( &lt;code&gt;~&lt;/code&gt; ) 문자로 시작하고 그 뒤에 문자 (시길을 식별)와 구분 기호가옵니다. 선택적으로 수정자는 최종 분리 문자 뒤에 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ac2c0d2324769d5f24fd923ab3874ad8881b99a" translate="yes" xml:space="preserve">
          <source>In this chapter, we are going to learn how to use &lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html&quot;&gt;Erlang&amp;rsquo;s &lt;code&gt;:gen_tcp&lt;/code&gt; module&lt;/a&gt; to serve requests. This provides a great opportunity to explore Elixir&amp;rsquo;s &lt;code&gt;Task&lt;/code&gt; module. In future chapters, we will expand our server so it can actually serve the commands.</source>
          <target state="translated">이 장에서는 &lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html&quot;&gt;Erlang의 &lt;code&gt;:gen_tcp&lt;/code&gt; 모듈&lt;/a&gt; 을 사용하여 요청을 처리 하는 방법을 배웁니다 . 이것은 Elixir의 &lt;code&gt;Task&lt;/code&gt; 모듈 을 탐험 할 수있는 좋은 기회를 제공 합니다. 다음 장에서는 실제로 서버가 명령을 수행 할 수 있도록 서버를 확장 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="3790f5eba5f0f0e875bea6125a8a5886ab46f334" translate="yes" xml:space="preserve">
          <source>In this chapter, we have learned more about Mix dependencies and umbrella projects. While we may run &lt;code&gt;kv&lt;/code&gt; without a server, our &lt;code&gt;kv_server&lt;/code&gt; depends directly on &lt;code&gt;kv&lt;/code&gt;. By breaking them into separate applications, we gain more control in how they are developed and tested.</source>
          <target state="translated">이 장에서는 혼합 종속성 및 우산 프로젝트에 대해 자세히 배웠습니다. 서버없이 &lt;code&gt;kv&lt;/code&gt; 를 실행할 수 있지만 &lt;code&gt;kv_server&lt;/code&gt; 는 &lt;code&gt;kv&lt;/code&gt; 에 직접 의존합니다 . 그것들을 별도의 응용 프로그램으로 나누면 개발 및 테스트 방법에 대한 통제력이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="77b3cbb396af520fe87eb129b43b21e8d9c63f1e" translate="yes" xml:space="preserve">
          <source>In this chapter, we will create our first project using Mix and explore different features in</source>
          <target state="translated">이 장에서는 Mix를 사용하여 첫 번째 프로젝트를 만들고</target>
        </trans-unit>
        <trans-unit id="9c4b6a4ca897d48c33e42fad527b3db14a79b9ad" translate="yes" xml:space="preserve">
          <source>In this chapter, we will discuss how to manage dependencies in Mix.</source>
          <target state="translated">이 장에서는 Mix에서 종속성을 관리하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d4cdb3f68133770a5d693d42e9c4f0a6b1d29ed8" translate="yes" xml:space="preserve">
          <source>In this chapter, we will go back to the &lt;code&gt;:kv&lt;/code&gt; application and add a routing layer that will allow us to distribute requests between nodes based on the bucket name.</source>
          <target state="translated">이 장에서는 &lt;code&gt;:kv&lt;/code&gt; 애플리케이션 으로 돌아가서 버킷 이름을 기반으로 노드간에 요청을 분배 할 수있는 라우팅 계층을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="06e8c486e5a64f168562aa1973836cfefc091cf1" translate="yes" xml:space="preserve">
          <source>In this chapter, we will implement the code that parses the commands we described in the first chapter:</source>
          <target state="translated">이 장에서는 첫 번째 장에서 설명한 명령을 구문 분석하는 코드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c851aca018e560f965209935144975cb8ea448f3" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn about ETS (Erlang Term Storage) and how to use it as a cache mechanism.</source>
          <target state="translated">이 장에서는 ETS (Erlang Term Storage) 및 캐시 메커니즘으로 사용하는 방법에 대해 학습합니다.</target>
        </trans-unit>
        <trans-unit id="49223bed7f677bd886d57a37c64f3ed6e0f504be" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn about the &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;cond&lt;/code&gt;, and &lt;code&gt;if&lt;/code&gt; control flow structures.</source>
          <target state="translated">이 장에서 우리는 배울 것입니다 &lt;code&gt;case&lt;/code&gt; , &lt;code&gt;cond&lt;/code&gt; 및 &lt;code&gt;if&lt;/code&gt; 제어 흐름 구조.</target>
        </trans-unit>
        <trans-unit id="1590a3a3e635043fe94ad7ec0fb7a6fa472857ed" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn about the basic constructs for spawning new processes, as well as sending and receiving messages between processes.</source>
          <target state="translated">이 장에서는 새로운 프로세스를 생성하고 프로세스간에 메시지를주고받는 기본 구성에 대해 알아 봅니다.</target>
        </trans-unit>
        <trans-unit id="7f5c0837809d0d37d72c00bc93c0560646fc3127" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn how to keep and share state between multiple entities. If you have previous programming experience, you may think of globally shared variables, but the model we will learn here is quite different. The next chapters will generalize the concepts introduced here.</source>
          <target state="translated">이 장에서는 여러 엔터티간에 상태를 유지하고 공유하는 방법을 배웁니다. 이전의 프로그래밍 경험이 있다면 전역 적으로 공유되는 변수를 생각할 수 있지만 여기서 배울 모델은 상당히 다릅니다. 다음 장에서는 여기에 소개 된 개념을 일반화 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="dc7ec789bc29ccf1df57435cd9cab759827e4cca" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn how to put those concepts into practice by supervising the &lt;code&gt;KV.Registry&lt;/code&gt; process. After all, if something goes wrong with the registry, the whole registry is lost and no bucket could ever be found! To address this, we will define a &lt;code&gt;KV.Supervisor&lt;/code&gt; module that guarantees that our &lt;code&gt;KV.Registry&lt;/code&gt; is up and running at any given moment.</source>
          <target state="translated">이 장에서는 &lt;code&gt;KV.Registry&lt;/code&gt; 프로세스 를 감독하여 이러한 개념을 실제로 적용하는 방법을 배웁니다 . 결국 레지스트리에 문제가 발생하면 전체 레지스트리가 손실되고 버킷을 찾을 수 없습니다! 이를 해결하기 위해 &lt;code&gt;KV.Registry&lt;/code&gt; 가 특정 시점에 가동 되도록 보장 하는 &lt;code&gt;KV.Supervisor&lt;/code&gt; 모듈을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="f4e872a924d2554a59dc215ca3cc9595e893d535" translate="yes" xml:space="preserve">
          <source>In this chapter, we will show how the &lt;code&gt;=&lt;/code&gt; operator in Elixir is actually a match operator and how to use it to pattern match inside data structures. Finally, we will learn about the pin operator &lt;code&gt;^&lt;/code&gt; used to access previously bound values.</source>
          <target state="translated">이 장에서는 Elixir 의 &lt;code&gt;=&lt;/code&gt; 연산자가 실제로 일치 연산자 인 방법과 데이터 구조 내에서 일치를 패턴 화하는 방법을 보여줍니다. 마지막으로 이전에 바인딩 된 값에 액세스하는 데 사용되는 핀 연산자 &lt;code&gt;^&lt;/code&gt; 에 대해 알아 봅니다 .</target>
        </trans-unit>
        <trans-unit id="31213f804ca1ba2bcaeea192ccfad5a4a66aadab" translate="yes" xml:space="preserve">
          <source>In this chapter, we will understand what binaries are, how they associate with strings, and what a single-quoted value, &lt;code&gt;'like this'&lt;/code&gt;, means in Elixir.</source>
          <target state="translated">이 장에서 우리는 바이너리가 무엇인지, 그것들이 문자열과 어떻게 연관되는지, 그리고 작은 따옴표로 묶은 값 &lt;code&gt;'like this'&lt;/code&gt; Elixir에서 무엇을 의미하는지 이해할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="cab0abe1635159a22d386896876d7d1271b3ac90" translate="yes" xml:space="preserve">
          <source>In this example above, we have used &lt;code&gt;.&lt;/code&gt; to invoke &lt;code&gt;downcase&lt;/code&gt; in the &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module, passing &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; as argument.</source>
          <target state="translated">위의 예에서는을 사용했습니다 &lt;code&gt;.&lt;/code&gt; &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; 를 인수로 전달 하여 &lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 모듈 에서 &lt;code&gt;downcase&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="c10b9029231d6bc54c409155c2532fc1a938191b" translate="yes" xml:space="preserve">
          <source>In this example, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#__using__/1&quot;&gt;&lt;code&gt;ExUnit.Case.__using__/1&lt;/code&gt;&lt;/a&gt; is called with the keyword list &lt;code&gt;[async: true]&lt;/code&gt; as its argument; &lt;a href=&quot;#use/2&quot;&gt;&lt;code&gt;use/2&lt;/code&gt;&lt;/a&gt; translates to:</source>
          <target state="translated">이 예에서 &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#__using__/1&quot;&gt; &lt;code&gt;ExUnit.Case.__using__/1&lt;/code&gt; &lt;/a&gt; 은 키워드 목록 &lt;code&gt;[async: true]&lt;/code&gt; 를 인수로 사용하여 호출됩니다. &lt;a href=&quot;#use/2&quot;&gt; &lt;code&gt;use/2&lt;/code&gt; &lt;/a&gt; 는 다음과 같이 번역됩니다.</target>
        </trans-unit>
        <trans-unit id="9b0189dd5873fd5c12528d067cb5fcd86bb62926" translate="yes" xml:space="preserve">
          <source>In this example, we will also set the number of partitions to the number of schedulers online, which will make the registry more performant on highly concurrent environments:</source>
          <target state="translated">이 예에서는 파티션 수를 온라인으로 스케줄러 수로 설정하여 동시성이 높은 환경에서 레지스트리 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="bf3e2a2aeea0818b1b9eedf9fbfeaab414232e77" translate="yes" xml:space="preserve">
          <source>In this function, creating the email address will copy the &lt;code&gt;username&lt;/code&gt; and &lt;code&gt;domain&lt;/code&gt; binaries. Now imagine you want to use the resulting email inside another binary:</source>
          <target state="translated">이 기능에서 이메일 주소를 만들면 &lt;code&gt;username&lt;/code&gt; 과 &lt;code&gt;domain&lt;/code&gt; 바이너리 가 복사됩니다 . 이제 다른 바이너리 내에서 결과 이메일을 사용한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="ddbd4da73762eca8a66a74cb6eb4786c527ab302" translate="yes" xml:space="preserve">
          <source>In this guide, we will learn how to build a complete Elixir application, with its own supervision tree, configuration, tests and more.</source>
          <target state="translated">이 안내서에서는 자체 감독 트리, 구성, 테스트 등을 사용하여 완전한 Elixir 응용 프로그램을 작성하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="09acda557e592790e954bfce0950e7ceb658a690" translate="yes" xml:space="preserve">
          <source>In this introduction, we have laid the groundwork to finally write our first macro, so let&amp;rsquo;s move to the next chapter.</source>
          <target state="translated">이 소개에서는 마지막으로 첫 번째 매크로를 작성하기위한 토대를 마련 했으므로 다음 장으로 넘어 갑시다.</target>
        </trans-unit>
        <trans-unit id="c76b277befaa00029a051ea468b00e6a56d4277a" translate="yes" xml:space="preserve">
          <source>In this last chapter, we will make the routing table for our distributed key-value store configurable, and then finally package the software for production.</source>
          <target state="translated">이 마지막 장에서는 분산 키-값 저장소의 라우팅 테이블을 구성 할 수있게 한 다음 최종적으로 프로덕션 용 소프트웨어를 패키지화합니다.</target>
        </trans-unit>
        <trans-unit id="5f9c06a521bbdcc292934d8151f4d75a668e854f" translate="yes" xml:space="preserve">
          <source>In this menu, developers are able to start new shells and alternate between them. Let's give it a try:</source>
          <target state="translated">이 메뉴에서 개발자는 새로운 쉘을 시작하고 그 사이를 번갈아 가며 볼 수 있습니다. 시도해 보자.</target>
        </trans-unit>
        <trans-unit id="469f4d72bd11aaf469d5b151d58b6e80c06007ce" translate="yes" xml:space="preserve">
          <source>In this section we document common anti-patterns to avoid when writing libraries.</source>
          <target state="translated">이 섹션에서는 라이브러리를 작성할 때 피하기 위해 일반적인 안티 패턴을 문서화합니다.</target>
        </trans-unit>
        <trans-unit id="eebb3e9870cca1a5d4d8634270c5f11116a4eca3" translate="yes" xml:space="preserve">
          <source>In this section, we will implement the parsing functionality, document it and make sure our documentation is up to date with doctests. This helps us provide documentation with accurate code samples.</source>
          <target state="translated">이 섹션에서는 구문 분석 기능을 구현하고 문서화하며 문서가 doctest로 최신 상태인지 확인합니다. 이를 통해 정확한 코드 샘플로 문서를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06285168ac2e5f025d4d90f97df36744161f8367" translate="yes" xml:space="preserve">
          <source>In this setup, Elixir will escape the following: &lt;code&gt;\0&lt;/code&gt;, &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt;. Bytes can be given as hexadecimals via &lt;code&gt;\xNN&lt;/code&gt; and Unicode code points as &lt;code&gt;\uNNNN&lt;/code&gt; escapes.</source>
          <target state="translated">이 설정에서 Elixir는 다음을 이스케이프합니다 : &lt;code&gt;\0&lt;/code&gt; , &lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\s&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; 및 &lt;code&gt;\v&lt;/code&gt; . 바이트는 &lt;code&gt;\xNN&lt;/code&gt; 통해 16 진수로 , 유니 코드 코드 포인트는 &lt;code&gt;\uNNNN&lt;/code&gt; 이스케이프 로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8dd5e09e7dc956434b7d83de8c59a3badda6a30" translate="yes" xml:space="preserve">
          <source>In this tutorial, we are going to teach you about Elixir fundamentals - the language syntax, how to define modules, how to manipulate the characteristics of common data structures, and more. This chapter will focus on ensuring that Elixir is installed and that you can successfully run Elixir&amp;rsquo;s Interactive Shell, called IEx.</source>
          <target state="translated">이 튜토리얼에서는 언어 구문, 모듈을 정의하는 방법, 일반적인 데이터 구조의 특성을 조작하는 방법 등 Elixir 기본 사항에 대해 설명합니다. 이 장에서는 Elixir이 설치되어 있고 IEx라는 Elixir의 대화식 쉘을 성공적으로 실행할 수 있는지에 중점을 둘 것입니다.</target>
        </trans-unit>
        <trans-unit id="793085c85e85a2ff028456a29daed3461d17ddd7" translate="yes" xml:space="preserve">
          <source>In your supervisor tree, you would write:</source>
          <target state="translated">수퍼바이저 트리에서 다음과 같이 작성합니다.</target>
        </trans-unit>
        <trans-unit id="83526b8b240a9db63b8d55e8fb00ed7f5d21007b" translate="yes" xml:space="preserve">
          <source>In-memory reloading</source>
          <target state="translated">인 메모리 리로드</target>
        </trans-unit>
        <trans-unit id="d704ee1641420e0d4b1d894e7413ca3a127523fd" translate="yes" xml:space="preserve">
          <source>Indexes are normalized, meaning that negative indexes will be counted from the end (for example, &lt;code&gt;-1&lt;/code&gt; means the last element of the &lt;code&gt;enumerable&lt;/code&gt;).</source>
          <target state="translated">인덱스는 정규화됩니다. 즉, 음수 인덱스는 끝부터 계산됩니다 (예 : &lt;code&gt;-1&lt;/code&gt; 은 &lt;code&gt;enumerable&lt;/code&gt; 마지막 요소를 나타냄).</target>
        </trans-unit>
        <trans-unit id="326e3957dade8d1a772302e6b546ac73cdbf4311" translate="yes" xml:space="preserve">
          <source>Indicates if the current task is recursing.</source>
          <target state="translated">현재 작업이 되풀이되고 있는지 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f2a5522bf941f8a31cb4a9be81260d9ace1f85be" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the bitwise AND of its arguments.</source>
          <target state="translated">접두사 연산자; 인수의 비트 AND를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="e2dd1c549a548d8e01a78692703764dc3748f955" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the bitwise OR of its arguments.</source>
          <target state="translated">접두사 연산자; 인수의 비트 단위 OR을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="9f117367d5e095016d1671e5594b015b66cce626" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the bitwise XOR of its arguments.</source>
          <target state="translated">접두사 연산자; 인수의 비트 XOR을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a6c9f00063f505c603b4195c6e85acdf426886dc" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the result of an arithmetic left bitshift.</source>
          <target state="translated">접두사 연산자; 산술 왼쪽 비트 시프트의 결과를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="39d1b96bbfeb4f731610e743c469a2a9cffcbf06" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the result of an arithmetic right bitshift.</source>
          <target state="translated">접두사 연산자; 산술 오른쪽 비트 시프트의 결과를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="edfb572bfe264c3828dc3338e200d7d692f743a8" translate="yes" xml:space="preserve">
          <source>Initialization, shutdown and restart logic (as seen in supervisors)</source>
          <target state="translated">초기화, 종료 및 재시작 로직 (감독자에 표시)</target>
        </trans-unit>
        <trans-unit id="db2dd11fcae49760a96da6470cc842932b211ef8" translate="yes" xml:space="preserve">
          <source>Injects the contents of the file at &lt;code&gt;path&lt;/code&gt; as if it was typed into the shell.</source>
          <target state="translated">마치 쉘에 입력 된 것처럼 &lt;code&gt;path&lt;/code&gt; 파일 내용을 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="cdae762bf8cb5cd492029bc8d296aa3edef79fb0" translate="yes" xml:space="preserve">
          <source>Injects the stream values into the given collectable as a side-effect.</source>
          <target state="translated">주어진 수집품에 스트림 값을 부작용으로 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="dc55e2c53e188d355acce4a5c45f90740eaed542" translate="yes" xml:space="preserve">
          <source>Inlined by the compiler.</source>
          <target state="translated">컴파일러에 의해 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="d1a321cfbe47a9364ab51334333242edcba4e12d" translate="yes" xml:space="preserve">
          <source>Inlining</source>
          <target state="translated">Inlining</target>
        </trans-unit>
        <trans-unit id="60256592be0f79d02de4ff02fdbe0edd9f4a9db3" translate="yes" xml:space="preserve">
          <source>Input will be consumed until Enter is pressed.</source>
          <target state="translated">Enter를 누를 때까지 입력이 소비됩니다.</target>
        </trans-unit>
        <trans-unit id="15148f3718aedfec6834b4f2c01d66f0986c9e24" translate="yes" xml:space="preserve">
          <source>Insert these changes in your code and now you may start your application using the following command &lt;code&gt;PORT=4321 mix run --no-halt&lt;/code&gt;, notice how we are passing the port as a variable, but still defaults to 4040 if none is given.</source>
          <target state="translated">이러한 변경 사항을 코드에 삽입하면 이제 다음 명령 &lt;code&gt;PORT=4321 mix run --no-halt&lt;/code&gt; 명령을 사용하여 응용 프로그램을 시작할 수 있습니다 . 포트를 변수로 전달하는 방법에 주목하십시오.</target>
        </trans-unit>
        <trans-unit id="477a1b44713d7d2cea8e0f490e55ba9af37236ea" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into &lt;code&gt;map_set&lt;/code&gt; if &lt;code&gt;map_set&lt;/code&gt; doesn't already contain it.</source>
          <target state="translated">삽입 &lt;code&gt;value&lt;/code&gt; 에 &lt;code&gt;map_set&lt;/code&gt; 는 경우 &lt;code&gt;map_set&lt;/code&gt; 가 이미 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e63d377cb4e0957757e5467d8c996119f6f2f02" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into &lt;code&gt;tuple&lt;/code&gt; at the given &lt;code&gt;index&lt;/code&gt;. Raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;index&lt;/code&gt; is negative or greater than the length of &lt;code&gt;tuple&lt;/code&gt;. Index is zero-based.</source>
          <target state="translated">주어진 &lt;code&gt;index&lt;/code&gt; 에서 &lt;code&gt;tuple&lt;/code&gt; 에 &lt;code&gt;value&lt;/code&gt; 을 삽입합니다 . 상승 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 경우 &lt;code&gt;index&lt;/code&gt; 네가티브인지의 길이보다 &lt;code&gt;tuple&lt;/code&gt; . 인덱스는 0부터 시작합니다.</target>
        </trans-unit>
        <trans-unit id="afa4ba1a8961d06fdaefcb0b7808a06ce72411d7" translate="yes" xml:space="preserve">
          <source>Inserts a mandatory linebreak between two documents.</source>
          <target state="translated">두 문서 사이에 필수 줄 바꿈을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="ee42585ac2116aa5e9e194a89ae83cd36cb233ed" translate="yes" xml:space="preserve">
          <source>Inserts a mandatory single space between two documents.</source>
          <target state="translated">두 문서 사이에 필수 단일 공백을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="58646ce229b992058a739db41cd5c12f2f3030cf" translate="yes" xml:space="preserve">
          <source>Inserts an element at the end of a tuple.</source>
          <target state="translated">튜플의 끝에 요소를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="aefced5d83d6f9626d89c8b81563a063596124ad" translate="yes" xml:space="preserve">
          <source>Inserts an element into a tuple.</source>
          <target state="translated">튜플에 요소를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="82491edefb5fd8fccc5cef67dd8728cddce98356" translate="yes" xml:space="preserve">
          <source>Inserts the given &lt;code&gt;enumerable&lt;/code&gt; into a &lt;code&gt;collectable&lt;/code&gt; according to the transformation function.</source>
          <target state="translated">변형 함수에 따라 주어진 &lt;code&gt;enumerable&lt;/code&gt; 을 &lt;code&gt;collectable&lt;/code&gt; 에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="58e9b11975e38f1615e69956c4ba72b1614985c8" translate="yes" xml:space="preserve">
          <source>Inserts the given &lt;code&gt;enumerable&lt;/code&gt; into a &lt;code&gt;collectable&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;enumerable&lt;/code&gt; 을 &lt;code&gt;collectable&lt;/code&gt; 에 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="4dc843d3a107d849e18140a0726786e2d0083112" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;kernel#defimpl/2&quot;&gt;&lt;code&gt;defimpl/2&lt;/code&gt;&lt;/a&gt;, you can use &lt;code&gt;@protocol&lt;/code&gt; to access the protocol being implemented and &lt;code&gt;@for&lt;/code&gt; to access the module it is being defined for.</source>
          <target state="translated">내부 &lt;a href=&quot;kernel#defimpl/2&quot;&gt; &lt;code&gt;defimpl/2&lt;/code&gt; &lt;/a&gt; , 당신은 사용할 수 있습니다 &lt;code&gt;@protocol&lt;/code&gt; 을 액세스에 구현되는 프로토콜과 &lt;code&gt;@for&lt;/code&gt; 를 액세스가 정의되고있는 모듈을.</target>
        </trans-unit>
        <trans-unit id="9a72c5141d8fa1919f077425c1ba8fcc0bb6e0f3" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks you may introduce other keywords, such as &lt;code&gt;else&lt;/code&gt; used in the &lt;code&gt;if&lt;/code&gt; above. The supported keywords between &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; are static and are:</source>
          <target state="translated">내부는 &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 블록 당신 같은 다른 키워드를 도입 할 수 &lt;code&gt;else&lt;/code&gt; 에 사용되는 &lt;code&gt;if&lt;/code&gt; 위. &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 사이에서 지원되는 키워드 는 정적이며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b06fc5ccdbbb6e1341b5ead9ee2126b0e7d8721" translate="yes" xml:space="preserve">
          <source>Inside IEx, hitting &lt;code&gt;Ctrl+C&lt;/code&gt; will open up the &lt;code&gt;BREAK&lt;/code&gt; menu. In this menu you can quit the shell, see process and ETS tables information and much more.</source>
          <target state="translated">IEx에서 &lt;code&gt;Ctrl+C&lt;/code&gt; 를 누르면 &lt;code&gt;BREAK&lt;/code&gt; 메뉴 가 열립니다 . 이 메뉴에서 쉘을 종료 할 수 있습니다. 프로세스 및 ETS 테이블 정보 등을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="03f0e4a7260af9ca9a8463a85cd7efbea72439fd" translate="yes" xml:space="preserve">
          <source>Inside a module, we can define functions with &lt;code&gt;def/2&lt;/code&gt; and private functions with &lt;code&gt;defp/2&lt;/code&gt;. A function defined with &lt;code&gt;def/2&lt;/code&gt; can be invoked from other modules while a private function can only be invoked locally.</source>
          <target state="translated">모듈 내에서 &lt;code&gt;def/2&lt;/code&gt; 로 함수를 정의 하고 &lt;code&gt;defp/2&lt;/code&gt; 로 프라이빗 함수를 정의 할 수 있습니다 . &lt;code&gt;def/2&lt;/code&gt; 로 정의 된 함수 는 다른 모듈에서 호출 할 수있는 반면 개인 함수는 로컬에서만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b5876476355703f4f43fdf75b583d0b33e50128" translate="yes" xml:space="preserve">
          <source>Inside umbrellas:</source>
          <target state="translated">내부 우산 :</target>
        </trans-unit>
        <trans-unit id="ff7d1285dd1427c76ab7acf44b71a8c8783f99ac" translate="yes" xml:space="preserve">
          <source>Insignificant digits in numbers are kept as is. The formatter however always inserts underscores for decimal numbers with more than 5 digits and converts hexadecimal digits to uppercase</source>
          <target state="translated">숫자의 중요하지 않은 숫자는 그대로 유지됩니다. 그러나 포맷터는 항상 5 자리를 초과하는 10 진수에 밑줄을 삽입하고 16 진수를 대문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="18ca87afec4298d9de864e32b4eeb6a31786e496" translate="yes" xml:space="preserve">
          <source>Inspect</source>
          <target state="translated">Inspect</target>
        </trans-unit>
        <trans-unit id="8414c282c4799a38a5a542eddf3fbf5bc932cf21" translate="yes" xml:space="preserve">
          <source>Inspect &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;프로토콜&lt;/small&gt; 검사&lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8fa2cc0c476786708af2220b5a7c37218a295c0e" translate="yes" xml:space="preserve">
          <source>Inspect.Algebra</source>
          <target state="translated">Inspect.Algebra</target>
        </trans-unit>
        <trans-unit id="cac9e750c4626e97af4bfdac5963505168c991af" translate="yes" xml:space="preserve">
          <source>Inspect.Error</source>
          <target state="translated">Inspect.Error</target>
        </trans-unit>
        <trans-unit id="2f7084207f03105946937040d7f1a8666466847e" translate="yes" xml:space="preserve">
          <source>Inspect.Error &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">검사 오류 &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="c1eea5039122d61678f099bc1095c3d343dfa88b" translate="yes" xml:space="preserve">
          <source>Inspect.Opts</source>
          <target state="translated">Inspect.Opts</target>
        </trans-unit>
        <trans-unit id="76857fe76fdec2188870db7ef8e5489c2f660af9" translate="yes" xml:space="preserve">
          <source>Inspect.inspect (2)</source>
          <target state="translated">검사 검사 (2)</target>
        </trans-unit>
        <trans-unit id="11718aedd18c27cc6d385458412c98fc95530888" translate="yes" xml:space="preserve">
          <source>Inspect.t (0)</source>
          <target state="translated">검사 t (0)</target>
        </trans-unit>
        <trans-unit id="4b093666bfbe436abd6e75ff4060483a6eed400e" translate="yes" xml:space="preserve">
          <source>Inspects &lt;code&gt;item&lt;/code&gt; according to the given options using the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">IO &lt;code&gt;device&lt;/code&gt; 사용하여 주어진 옵션에 따라 &lt;code&gt;item&lt;/code&gt; 검사 합니다 .</target>
        </trans-unit>
        <trans-unit id="c5a3a1e7021ff3bf12f0c5dee5b6d4b45795751a" translate="yes" xml:space="preserve">
          <source>Inspects and writes the given &lt;code&gt;item&lt;/code&gt; to the device.</source>
          <target state="translated">주어진 &lt;code&gt;item&lt;/code&gt; 을 검사하고 장치에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="e7503cce5b05ca6c10725fe1362e1e1fb0df01fb" translate="yes" xml:space="preserve">
          <source>Inspects the given argument according to the &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol. The second argument is a keyword list with options to control inspection.</source>
          <target state="translated">&lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; 프로토콜 에 따라 주어진 인수를 검사 합니다. 두 번째 인수는 검사를 제어하는 ​​옵션이있는 키워드 목록입니다.</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="410e2de2d51ba0a8c2653a12efa8b959eb14239c" translate="yes" xml:space="preserve">
          <source>Installing external dependencies is simple. Most commonly, we use the &lt;a href=&quot;https://hex.pm&quot;&gt;Hex Package Manager&lt;/a&gt;, by listing the dependency inside the deps function in our &lt;code&gt;mix.exs&lt;/code&gt; file:</source>
          <target state="translated">외부 종속성을 설치하는 것은 간단합니다. 가장 일반적으로 &lt;code&gt;mix.exs&lt;/code&gt; 파일 에서 deps 함수 내부의 종속성을 나열 하여 &lt;a href=&quot;https://hex.pm&quot;&gt;Hex Package Manager를&lt;/a&gt; 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="5fc6648d32dcda7f8258be9d7bfe7a810c641ff1" translate="yes" xml:space="preserve">
          <source>Instead &lt;strong&gt;do&lt;/strong&gt;:</source>
          <target state="translated">대신 &lt;strong&gt;할&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="70e1c1220b6164c7f3f3c7f9ac3d512f4ed39191" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;MyModule.__behaviour__(:callbacks)&lt;/code&gt;, &lt;code&gt;MyModule.behaviour_info(:callbacks)&lt;/code&gt; can be used.</source>
          <target state="translated">대신에 &lt;code&gt;MyModule.__behaviour__(:callbacks)&lt;/code&gt; , &lt;code&gt;MyModule.behaviour_info(:callbacks)&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1b879c3f25c9b1c9960a54e86cb4fc16cf79dfc" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;spawn/1&lt;/code&gt; and &lt;code&gt;spawn_link/1&lt;/code&gt;, we use &lt;code&gt;Task.start/1&lt;/code&gt; and &lt;code&gt;Task.start_link/1&lt;/code&gt; which return &lt;code&gt;{:ok, pid}&lt;/code&gt; rather than just the PID. This is what enables tasks to be used in supervision trees. Furthermore, &lt;code&gt;Task&lt;/code&gt; provides convenience functions, like &lt;code&gt;Task.async/1&lt;/code&gt; and &lt;code&gt;Task.await/1&lt;/code&gt;, and functionality to ease distribution.</source>
          <target state="translated">대신에 &lt;code&gt;spawn/1&lt;/code&gt; 및 &lt;code&gt;spawn_link/1&lt;/code&gt; , 우리는 사용 &lt;code&gt;Task.start/1&lt;/code&gt; 및 &lt;code&gt;Task.start_link/1&lt;/code&gt; 하는 반환 &lt;code&gt;{:ok, pid}&lt;/code&gt; 오히려 단지 PID보다. 이것이 감독 트리에서 작업을 사용할 수있게하는 것입니다. 또한 &lt;code&gt;Task&lt;/code&gt; 는 &lt;code&gt;Task.async/1&lt;/code&gt; 및 &lt;code&gt;Task.await/1&lt;/code&gt; 과 같은 편리한 기능과 편리한 배포 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2b04d71a821407f326a765c34eafcb3d188ed9ec" translate="yes" xml:space="preserve">
          <source>Instead of abusing the built-in name facility, we will create our own &lt;em&gt;process registry&lt;/em&gt; that associates the bucket name to the bucket process.</source>
          <target state="translated">내장 이름 기능을 남용하는 대신 버킷 이름을 버킷 프로세스에 연결하는 자체 &lt;em&gt;프로세스 레지스트리&lt;/em&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="46ebdd1c0d8185516f828a303e26f55b8135c53d" translate="yes" xml:space="preserve">
          <source>Instead of asking &amp;ldquo;how to do X in Elixir&amp;rdquo;, ask &amp;ldquo;how to solve Y in Elixir&amp;rdquo;. In other words, don&amp;rsquo;t ask how to implement a particular solution, instead describe the problem at hand. Stating the problem gives more context and less bias for a correct answer.</source>
          <target state="translated">&amp;ldquo;엘릭서에서 X를하는 방법&amp;rdquo;을 묻는 대신&amp;ldquo;엘릭서에서 Y를 해결하는 방법&amp;rdquo;을 물어보십시오. 즉, 특정 솔루션을 구현하는 방법을 묻지 말고 당면한 문제를 설명하십시오. 문제를 진술하면 정답에 대한 맥락과 편견이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="657f86bb1607bd9dc12a6834cf040e983fea5025" translate="yes" xml:space="preserve">
          <source>Instead of generating intermediate lists, streams build a series of computations that are invoked only when we pass the underlying stream to the &lt;code&gt;Enum&lt;/code&gt; module. Streams are useful when working with large, &lt;em&gt;possibly infinite&lt;/em&gt;, collections.</source>
          <target state="translated">중간 목록을 생성하는 대신 스트림은 기본 스트림을 &lt;code&gt;Enum&lt;/code&gt; 모듈에 전달할 때만 호출되는 일련의 계산을 작성 합니다. 스트림은 &lt;em&gt;무한한&lt;/em&gt; 대규모 컬렉션으로 작업 할 때 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="cbcbdeb5ce82b55a1db6bc95122644a2da9c98f8" translate="yes" xml:space="preserve">
          <source>Instead of sharing protocol implementation with maps, structs require their own protocol implementation. Since a &lt;code&gt;MapSet&lt;/code&gt; has its size precomputed and accessible through &lt;code&gt;MapSet.size/1&lt;/code&gt;, we can define a &lt;code&gt;Size&lt;/code&gt; implementation for it:</source>
          <target state="translated">struct는 맵과 프로토콜 구현을 공유하는 대신 자체 프로토콜 구현이 필요합니다. 이후 &lt;code&gt;MapSet&lt;/code&gt; 에는 그 크기가 미리 계산을 통해 접근 할 수있다 &lt;code&gt;MapSet.size/1&lt;/code&gt; , 우리는 정의 할 수 있습니다 &lt;code&gt;Size&lt;/code&gt; 그것에 대한 구현을 :</target>
        </trans-unit>
        <trans-unit id="b1cda74ad7f0576bffdba14e7c0e5fbf0bd02a81" translate="yes" xml:space="preserve">
          <source>Instead, you can store the value of the &lt;code&gt;try&lt;/code&gt; expression:</source>
          <target state="translated">대신 &lt;code&gt;try&lt;/code&gt; 표현식 의 값을 저장할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="e340bf5c2746e3a29b7ae3f2341d749b9a8e7f42" translate="yes" xml:space="preserve">
          <source>Integer code points</source>
          <target state="translated">정수 코드 포인트</target>
        </trans-unit>
        <trans-unit id="03c914e9cf272bd181f63f8ca95aa4134406a908" translate="yes" xml:space="preserve">
          <source>Integers (&lt;code&gt;1234&lt;/code&gt;) and floats (&lt;code&gt;123.4&lt;/code&gt;) in Elixir are represented as a sequence of digits that may be separated by underscore for readability purposes, such as &lt;code&gt;1_000_000&lt;/code&gt;. Integers never contain a dot (&lt;code&gt;.&lt;/code&gt;) in their representation. Floats contain a dot and at least one other digit after the dot. Floats also support the scientific notation, such as &lt;code&gt;123.4e10&lt;/code&gt; or &lt;code&gt;123.4E10&lt;/code&gt;.</source>
          <target state="translated">정수 ( &lt;code&gt;1234&lt;/code&gt; ) 및 플로트 ( &lt;code&gt;123.4&lt;/code&gt; 엘릭서에서)은 다음과 같은 목적으로 가독성 밑줄로 구분 될 수있다 숫자의 시퀀스로서 표현된다 &lt;code&gt;1_000_000&lt;/code&gt; . 정수 는 표현에 점 ( &lt;code&gt;.&lt;/code&gt; )을 포함하지 않습니다 . 플로트에는 점과 점 다음에 하나 이상의 다른 숫자가 포함됩니다. 플로트는 &lt;code&gt;123.4e10&lt;/code&gt; 또는 &lt;code&gt;123.4E10&lt;/code&gt; 과 같은 과학적 표기법도 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="2b69f8490219ca339df3ffe0a24133cf0845a779" translate="yes" xml:space="preserve">
          <source>Integers can be &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt;, defaulting to &lt;code&gt;unsigned&lt;/code&gt;.</source>
          <target state="translated">정수는 &lt;code&gt;signed&lt;/code&gt; 또는 &lt;code&gt;unsigned&lt;/code&gt; 것으로 기본값은 &lt;code&gt;unsigned&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d2871c600eee20d37fb547e17a478f66ee810c41" translate="yes" xml:space="preserve">
          <source>Integers in other bases and Unicode code points</source>
          <target state="translated">다른 기반 및 유니 코드 코드 포인트의 정수</target>
        </trans-unit>
        <trans-unit id="67bd439657ec8c91af9cab8e9c61775e95c7d415" translate="yes" xml:space="preserve">
          <source>Integration with Mix</source>
          <target state="translated">믹스와 통합</target>
        </trans-unit>
        <trans-unit id="8c7b691a3d33f4bf5d25d380d9c0cebf6d69f172" translate="yes" xml:space="preserve">
          <source>Integration with OS level tracers, such as &lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/LTTng.html&quot;&gt;Linux Trace Toolkit,&lt;/a&gt;&lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/DTRACE.html&quot;&gt;DTRACE,&lt;/a&gt; and &lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/SYSTEMTAP.html&quot;&gt;SystemTap&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/LTTng.html&quot;&gt;Linux Trace Toolkit, &lt;/a&gt;&lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/DTRACE.html&quot;&gt;DTRACE&lt;/a&gt; 및 &lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/SYSTEMTAP.html&quot;&gt;SystemTap&lt;/a&gt; 과 같은 OS 레벨 추적 프로그램과 통합</target>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="translated">대화식 모드</target>
        </trans-unit>
        <trans-unit id="6815f4d63967846048009b2275fddb5992a2ae7f" translate="yes" xml:space="preserve">
          <source>Internal dependencies</source>
          <target state="translated">내부 의존성</target>
        </trans-unit>
        <trans-unit id="fd76d47a90f8cc879523d078abeee342549c2a2c" translate="yes" xml:space="preserve">
          <source>Internal dependencies are the ones that are specific to your project. They usually don&amp;rsquo;t make sense outside the scope of your project/company/organization. Most of the time, you want to keep them private, whether due to technical, economic or business reasons.</source>
          <target state="translated">내부 종속성은 프로젝트와 관련된 것입니다. 일반적으로 프로젝트 / 회사 / 조직의 범위를 벗어나는 의미가 없습니다. 대부분의 경우 기술적, 경제적 또는 비즈니스상의 이유로 비공개로 유지하려고합니다.</target>
        </trans-unit>
        <trans-unit id="6edc5ae2d27d92f734915c3bcae38bfcff562e82" translate="yes" xml:space="preserve">
          <source>Internal special form for block expressions.</source>
          <target state="translated">블록 표현을위한 내부 특수 양식.</target>
        </trans-unit>
        <trans-unit id="7b9df6e3733e8709e741819162ae8b21c5560f05" translate="yes" xml:space="preserve">
          <source>Internal special form to hold aliases information.</source>
          <target state="translated">별명 정보를 보유하기위한 내부 특수 양식.</target>
        </trans-unit>
        <trans-unit id="7ea238b82c732c14af0d56ae146c57de7821e30a" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; is implemented as follows:</source>
          <target state="translated">내부적으로 &lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt; 는 다음과 같이 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="827c1e94219dfeaae7b53280233314ac83030abd" translate="yes" xml:space="preserve">
          <source>Internally, this function uses a &lt;a href=&quot;port&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; for interacting with the outside world. However, if you plan to run a long-running program, ports guarantee stdin/stdout devices will be closed but it does not automatically terminate the program. The documentation for the &lt;a href=&quot;port&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; module describes this problem and possible solutions under the &quot;Zombie processes&quot; section.</source>
          <target state="translated">내부적으로이 기능은 외부 세계와 상호 작용하기 위해 &lt;a href=&quot;port&quot;&gt; &lt;code&gt;Port&lt;/code&gt; &lt;/a&gt; 를 사용합니다 . 그러나 장기 실행 프로그램을 실행하려는 경우 포트는 stdin / stdout 장치가 닫히도록 보장하지만 프로그램을 자동으로 종료하지는 않습니다. &lt;a href=&quot;port&quot;&gt; &lt;code&gt;Port&lt;/code&gt; &lt;/a&gt; 모듈에 대한 설명서 는 &quot;좀비 프로세스&quot;섹션에서이 문제와 가능한 솔루션을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="77ae57c279c9e2ef961ac607460659eac146477d" translate="yes" xml:space="preserve">
          <source>Interpolation and escaping in sigils</source>
          <target state="translated">시길에서의 보간 및 탈출</target>
        </trans-unit>
        <trans-unit id="f901cbbe7edd4e8b636ff99e09fd9aa3ab5b6c2c" translate="yes" xml:space="preserve">
          <source>Intersperses &lt;code&gt;element&lt;/code&gt; between each element of the enumeration.</source>
          <target state="translated">열거의 각 &lt;code&gt;element&lt;/code&gt; 사이에 요소 를 산재 합니다.</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="3ad9a82c5e5ec7f5cdb591679187a3a184cc6e2c" translate="yes" xml:space="preserve">
          <source>Introduction to Mix</source>
          <target state="translated">믹스 소개</target>
        </trans-unit>
        <trans-unit id="556666f2a50884d36f095e81af9943cd94538e19" translate="yes" xml:space="preserve">
          <source>Invalid (when setup_all fails)</source>
          <target state="translated">유효하지 않음 (setup_all이 실패한 경우)</target>
        </trans-unit>
        <trans-unit id="979685031faaab9869c01a670026bc6edde40c74" translate="yes" xml:space="preserve">
          <source>Invoke the required callback &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">필요한 콜백 &lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; 을&lt;/a&gt; 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c2fcbf3d8569fd3d11cfd7171a8054a4d1a7f48" translate="yes" xml:space="preserve">
          <source>Invoked at the beginning of every nesting.</source>
          <target state="translated">모든 중첩의 시작 부분에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3131af8070d80cb4438964eca7dde39215d4a38c" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value stored under &lt;code&gt;key&lt;/code&gt; in the given term &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="translated">주어진 용어 &lt;code&gt;term&lt;/code&gt; 에서 &lt;code&gt;key&lt;/code&gt; 아래에 저장된 값에 액세스하기 위해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b22a1f1a89dd3f3bab30cb805e59f8edfe29b611" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value under &lt;code&gt;key&lt;/code&gt; and update it at the same time.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 아래의 값에 액세스 하고 동시에 업데이트 하기 위해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="f708aba5828f8cac72cfe36605553c37461c0165" translate="yes" xml:space="preserve">
          <source>Invoked in some cases to retrieve a formatted version of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; status.</source>
          <target state="translated">일부 경우에 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 상태 의 형식화 된 버전을 검색하기 위해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="47f17640bca3b36f9d932ef8aed6fea2692e715d" translate="yes" xml:space="preserve">
          <source>Invoked to &quot;pop&quot; the value under &lt;code&gt;key&lt;/code&gt; out of the given data structure.</source>
          <target state="translated">주어진 데이터 구조 에서 &lt;code&gt;key&lt;/code&gt; 아래의 값을 &quot;팝&quot;하기 위해 호출되었습니다 .</target>
        </trans-unit>
        <trans-unit id="8ffa339626f86dfddb50d2f5a5ebf28a3fe4886f" translate="yes" xml:space="preserve">
          <source>Invoked to change the state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; when a different version of a module is loaded (hot code swapping) and the state's term structure should be changed.</source>
          <target state="translated">다른 버전의 모듈이로드 될 때 (핫 코드 스와핑) 상태의 용어 구조를 변경해야 할 때 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 의 상태를 변경하기 위해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="7fd464e0a7bfe3444479112d481808fd4426398a" translate="yes" xml:space="preserve">
          <source>Invoked to handle &lt;code&gt;continue&lt;/code&gt; instructions.</source>
          <target state="translated">&lt;code&gt;continue&lt;/code&gt; 지시 를 처리하기 위해 호출되었습니다 .</target>
        </trans-unit>
        <trans-unit id="823c64bbe586eac0f81ae84a9ece9107aadfc7b3" translate="yes" xml:space="preserve">
          <source>Invoked to handle all other messages.</source>
          <target state="translated">다른 모든 메시지를 처리하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="251e86e0358f8330275ee3b3f133b8139914e86a" translate="yes" xml:space="preserve">
          <source>Invoked to handle asynchronous &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt; messages.</source>
          <target state="translated">비동기 &lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; &lt;/a&gt; 메시지 를 처리하기 위해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="490b6e99cd71fc7e4dff011cebfd6c5bbbf5b87c" translate="yes" xml:space="preserve">
          <source>Invoked to handle synchronous &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt; messages. &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt; will block until a reply is received (unless the call times out or nodes are disconnected).</source>
          <target state="translated">동기식 &lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt; 메시지 를 처리하기 위해 호출됩니다 . &lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt; 는 응답이 수신 될 때까지 차단됩니다 (통화 시간이 초과되거나 노드 연결이 끊어지지 않는 한).</target>
        </trans-unit>
        <trans-unit id="971fbd6b9ae7269a95c5e43e7e31db62769d21ec" translate="yes" xml:space="preserve">
          <source>Invoked when initializing a config provider.</source>
          <target state="translated">구성 제공자를 초기화 할 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="618d0cf7ef6acc312a2d60fcc796f79659809cb5" translate="yes" xml:space="preserve">
          <source>Invoked when the server is about to exit. It should do any cleanup required.</source>
          <target state="translated">서버가 종료 되려고 할 때 호출됩니다. 필요한 정리 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d36bf5909d0181e92966ebf880c59e2f526bd11" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#start/3&quot;&gt;&lt;code&gt;start/3&lt;/code&gt;&lt;/a&gt; will block until it returns.</source>
          <target state="translated">서버가 시작될 때 호출됩니다. &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#start/3&quot;&gt; &lt;code&gt;start/3&lt;/code&gt; &lt;/a&gt; 는 반환 될 때까지 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="dc23160ff26718d1a90643ca2158ff18ecfa2d78" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;fun&lt;/code&gt; for each element in the &lt;code&gt;enumerable&lt;/code&gt; with the accumulator.</source>
          <target state="translated">발동 &lt;code&gt;fun&lt;/code&gt; 의 각 요소에 대해 &lt;code&gt;enumerable&lt;/code&gt; 축적과 함께.</target>
        </trans-unit>
        <trans-unit id="3e3f9c65eaf0d3e4e4ac9e30375324284bc3c5a7" translate="yes" xml:space="preserve">
          <source>Invokes at the end of a nesting.</source>
          <target state="translated">중첩이 끝날 때 호출합니다.</target>
        </trans-unit>
        <trans-unit id="d9056f0569ac34dc376baf3f7e7aa026280e9f07" translate="yes" xml:space="preserve">
          <source>Invokes the callback with all entries under &lt;code&gt;key&lt;/code&gt; in each partition for the given &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;registry&lt;/code&gt; 각 파티션 에서 &lt;code&gt;key&lt;/code&gt; 아래의 모든 항목을 사용하여 콜백을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="66ee7c7e2a41aa50f02ea0f66057171a17276f9a" translate="yes" xml:space="preserve">
          <source>Invokes the given &lt;code&gt;fun&lt;/code&gt; for each element in the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 각 요소에 대해 지정된 &lt;code&gt;fun&lt;/code&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c515146dfdcfd5de926f55b367fb13cb7ae87958" translate="yes" xml:space="preserve">
          <source>Invokes the given anonymous function &lt;code&gt;fun&lt;/code&gt; with the list of arguments &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;args&lt;/code&gt; 목록으로 지정된 익명 함수 &lt;code&gt;fun&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2aa0eb875a1a8fbbb92dc87b00ef479f56d53d97" translate="yes" xml:space="preserve">
          <source>Invokes the given function from &lt;code&gt;module&lt;/code&gt; with the list of arguments &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;args&lt;/code&gt; 목록으로 &lt;code&gt;module&lt;/code&gt; 에서 지정된 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="5649c0331fbb3552ad202de096382bf84abd3b21" translate="yes" xml:space="preserve">
          <source>Invokes the given function to each element in the &lt;code&gt;enumerable&lt;/code&gt; to reduce it to a single element, while keeping an accumulator.</source>
          <target state="translated">누적기를 유지하면서 &lt;code&gt;enumerable&lt;/code&gt; 각 요소에 지정된 함수를 호출하여 단일 요소로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="b0eda3fd7457c0fb4308b75d0bf6df3d4719aced" translate="yes" xml:space="preserve">
          <source>Is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a559a239bb82de0629bcb6a428aeb5fd89db0826" translate="yes" xml:space="preserve">
          <source>Is the same as:</source>
          <target state="translated">와 같다:</target>
        </trans-unit>
        <trans-unit id="c5705683fdebc9e7c3a2a72f5f351756cecd2661" translate="yes" xml:space="preserve">
          <source>It accepts a list of &lt;code&gt;imported_paths&lt;/code&gt; that should raise if attempted to be imported again (to avoid recursive imports).</source>
          <target state="translated">재귀 가져 오기를 피하기 위해 다시 가져 오려고 시도하면 &lt;code&gt;imported_paths&lt;/code&gt; 하는 import_path 목록을 승인합니다 .</target>
        </trans-unit>
        <trans-unit id="8b02345541bef5990635992a1f66fbd5e80cdc19" translate="yes" xml:space="preserve">
          <source>It accepts a set of &lt;code&gt;options&lt;/code&gt; to configure &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;ExUnit&lt;/code&gt;&lt;/a&gt; (the same ones accepted by &lt;a href=&quot;#configure/1&quot;&gt;&lt;code&gt;configure/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;ExUnit&lt;/code&gt; &lt;/a&gt; 을 구성하기 위한 &lt;code&gt;options&lt;/code&gt; 세트를 허용합니다 ( &lt;a href=&quot;#configure/1&quot;&gt; &lt;code&gt;configure/1&lt;/code&gt; 에서&lt;/a&gt; 허용하는 것과 동일한 옵션 ).</target>
        </trans-unit>
        <trans-unit id="9c6bdae26359278127b2679c1e0f6e34574670e1" translate="yes" xml:space="preserve">
          <source>It accepts the same options as &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt; as both functions are built on top of this function. This function may return:</source>
          <target state="translated">두 함수가이 함수 위에 구축 되므로 &lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#parse_head/2&quot;&gt; &lt;code&gt;parse_head/2&lt;/code&gt; &lt;/a&gt; 와 동일한 옵션을 허용합니다 . 이 함수는 다음을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52c79809b7aa93e13235dedf1c047e396021dbc2" translate="yes" xml:space="preserve">
          <source>It accepts the struct module or a struct itself and simply removes the &lt;code&gt;__struct__&lt;/code&gt; field from the given struct or from a new struct generated from the given module.</source>
          <target state="translated">struct 모듈이나 struct 자체를 받아들이고 주어진 struct 또는 주어진 모듈에서 생성 된 새 struct에서 &lt;code&gt;__struct__&lt;/code&gt; 필드를 간단히 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="9db7ae3984a1b1beb1ad6d9414dcb836e49e4a46" translate="yes" xml:space="preserve">
          <source>It allows a developer to dynamically add, delete and register attributes, attach documentation and so forth.</source>
          <target state="translated">개발자는 속성을 동적으로 추가, 삭제 및 등록하고 문서를 첨부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e72ef20465fc62c76630754f83ef1dcdcf00df1" translate="yes" xml:space="preserve">
          <source>It allows developers to lookup one or more processes with a given key. If the registry has &lt;code&gt;:unique&lt;/code&gt; keys, a key points to 0 or 1 processes. If the registry allows &lt;code&gt;:duplicate&lt;/code&gt; keys, a single key may point to any number of processes. In both cases, different keys could identify the same process.</source>
          <target state="translated">개발자는 주어진 키로 하나 이상의 프로세스를 조회 할 수 있습니다. 레지스트리에 &lt;code&gt;:unique&lt;/code&gt; 키가있는 경우 키는 0 또는 1 개의 프로세스를 가리 킵니다. 레지스트리가 &lt;code&gt;:duplicate&lt;/code&gt; 키를 허용 하는 경우 단일 키는 여러 프로세스를 가리킬 수 있습니다. 두 경우 모두 다른 키로 동일한 프로세스를 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a71454b932a3e5f1fc7b4c0e7b18e42341a6164" translate="yes" xml:space="preserve">
          <source>It also accepts extra options, for the list of available options check &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt;&lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 옵션 목록 check &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt; &lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt; 에&lt;/a&gt; 대한 추가 옵션도 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="1fbb9737feae3b4fd98e6dc6a9178278f7164fb2" translate="yes" xml:space="preserve">
          <source>It also accepts functions in the format &lt;code&gt;function/arity&lt;/code&gt; and &lt;code&gt;module.function/arity&lt;/code&gt;, for example:</source>
          <target state="translated">또한 &lt;code&gt;function/arity&lt;/code&gt; 및 &lt;code&gt;module.function/arity&lt;/code&gt; 형식의 함수 도 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="99ac564cc223e5941d854a27c61609f6da592403" translate="yes" xml:space="preserve">
          <source>It also accepts single module argument to list all available behaviour callbacks.</source>
          <target state="translated">또한 사용 가능한 모든 동작 콜백을 나열하기 위해 단일 모듈 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c75c3d13969e4bc5682206b7605cdbcb131cac76" translate="yes" xml:space="preserve">
          <source>It also checks the inbox for an input message matching:</source>
          <target state="translated">또한받은 편지함에서 입력 메시지가 일치하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d684369d14eb5a8f47ce27babf1c852d61fa5f18" translate="yes" xml:space="preserve">
          <source>It also works with operators and other constructs (try &lt;code&gt;h +/2&lt;/code&gt;). Invoking &lt;code&gt;h&lt;/code&gt; without arguments displays the documentation for &lt;code&gt;IEx.Helpers&lt;/code&gt;, which is where &lt;code&gt;h&lt;/code&gt; and other functionality is defined.</source>
          <target state="translated">또한 연산자 및 기타 구문과 함께 작동합니다 (시도 &lt;code&gt;h +/2&lt;/code&gt; ). 호출 &lt;code&gt;h&lt;/code&gt; 인수 표시하지 않고 설명서 &lt;code&gt;IEx.Helpers&lt;/code&gt; 곳이다, &lt;code&gt;h&lt;/code&gt; 및 기타 기능이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a500beab3e68eedeee4019c52133aa404957a732" translate="yes" xml:space="preserve">
          <source>It can be a regular file, directory, socket, symbolic link, named pipe, or device file. Returns &lt;code&gt;false&lt;/code&gt; for symbolic links pointing to non-existing targets.</source>
          <target state="translated">일반 파일, 디렉토리, 소켓, 기호 링크, 명명 된 파이프 또는 장치 파일 일 수 있습니다. 존재하지 않는 대상을 가리키는 심볼릭 링크에 대해 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c22cd573aa0e917048596a531fe8bd4df0ba66d2" translate="yes" xml:space="preserve">
          <source>It can be upgraded to the DynamicSupervisor like this:</source>
          <target state="translated">다음과 같이 DynamicSupervisor로 업그레이드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d4ae51a95fbbfa60a796e3589c4762cdf4df826" translate="yes" xml:space="preserve">
          <source>It can be used in your &lt;code&gt;mix.exs&lt;/code&gt; to prepend or append new compilers to Mix:</source>
          <target state="translated">&lt;code&gt;mix.exs&lt;/code&gt; 에서 믹스에 새로운 컴파일러를 추가하거나 추가 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="28b1a3769a282dd753685d31c1db0ca20ed8c01c" translate="yes" xml:space="preserve">
          <source>It contains the following fields:</source>
          <target state="translated">다음과 같은 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="af1426f38289e13f36126375da54309f97a70a12" translate="yes" xml:space="preserve">
          <source>It contains these fields:</source>
          <target state="translated">다음 필드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="113d9a8235b2ac8f428decf342fbd7858aa4973c" translate="yes" xml:space="preserve">
          <source>It could also be corrected by using multiple guards, so that if an exception causes one guard to fail, the next one is evaluated.</source>
          <target state="translated">또한 여러 가드를 사용하여 수정할 수 있으므로 예외로 인해 하나의 가드가 실패하면 다음 가드가 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="1987bff89f1c6703dd2895ae7707929f8d89192f" translate="yes" xml:space="preserve">
          <source>It depends. It is ok to rely on shared state as long as we depend only on a non-shared partition of this state. Although multiple registries may start buckets on the shared bucket supervisor, those buckets and registries are isolated from each other. We would only run into concurrency issues if we used a function like &lt;code&gt;Supervisor.count_children(KV.BucketSupervisor)&lt;/code&gt; which would count all buckets from all registries, potentially giving different results when tests run concurrently.</source>
          <target state="translated">때에 따라 다르지. 이 상태의 비공유 파티션에만 의존하는 한 공유 상태를 사용하는 것이 좋습니다. 여러 레지스트리가 공유 버킷 수퍼바이저에서 버킷을 시작할 수 있지만 해당 버킷과 레지스트리는 서로 분리되어 있습니다. &lt;code&gt;Supervisor.count_children(KV.BucketSupervisor)&lt;/code&gt; 와 같은 기능을 사용하여 모든 레지스트리의 모든 버킷을 계산하여 테스트가 동시에 실행될 때 다른 결과를 제공 하는 경우에만 동시성 문제가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="4a261e69bb9abf1be6a9e6bf29d1f5c299e998d0" translate="yes" xml:space="preserve">
          <source>It differs in that the test suite will fail if no tests are executed when the &lt;code&gt;--only&lt;/code&gt; option is used.</source>
          <target state="translated">&lt;code&gt;--only&lt;/code&gt; 옵션을 사용할 때 테스트가 실행되지 않으면 테스트 스위트가 실패한다는 점이 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="bebaceae48e94abb745e77cdc9d79c5704717c94" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t seem to work at all. That&amp;rsquo;s because we are serving requests in the same process that are accepting connections. When one client is connected, we can&amp;rsquo;t accept another client.</source>
          <target state="translated">전혀 작동하지 않는 것 같습니다. 연결을 수락하는 프로세스와 동일한 프로세스에서 요청을 처리하기 때문입니다. 한 클라이언트가 연결되면 다른 클라이언트를 수락 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="18c00afbabba2721adf88ec3c29e863b42471b6a" translate="yes" xml:space="preserve">
          <source>It enables pretty printing by default with width of 80 characters. The width can be changed by explicitly passing the &lt;code&gt;:width&lt;/code&gt; option.</source>
          <target state="translated">기본적으로 너비가 80자인 예쁜 인쇄가 가능합니다. &lt;code&gt;:width&lt;/code&gt; 옵션 을 명시 적으로 전달하여 너비를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="38c802c651048f44f24f8b3150960035a31699cb" translate="yes" xml:space="preserve">
          <source>It exists for convenience purposes. For example, you could invoke it inside your &lt;code&gt;mix.exs&lt;/code&gt; to read some external data you decided to move to a configuration file:</source>
          <target state="translated">편의상 존재합니다. 예를 들어, &lt;code&gt;mix.exs&lt;/code&gt; 에서 파일 을 호출 하여 구성 파일로 이동하기로 결정한 외부 데이터를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfbe9f805346901fb7658c3a10caf05daf303078" translate="yes" xml:space="preserve">
          <source>It expects a &lt;code&gt;radius&lt;/code&gt; which chooses how many lines before and after the current line we should print. By default the &lt;code&gt;radius&lt;/code&gt; is of two lines:</source>
          <target state="translated">그것은 기대 &lt;code&gt;radius&lt;/code&gt; 전에 우리가 인쇄해야 현재 행 다음에 얼마나 많은 라인을 선택합니다. 기본적으로 &lt;code&gt;radius&lt;/code&gt; 은 두 줄입니다.</target>
        </trans-unit>
        <trans-unit id="e8f41592949431573d9fa16ad07b816bc20d280c" translate="yes" xml:space="preserve">
          <source>It expects a child specification or a module, similar to the ones given to &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#start_link/2&quot;&gt;&lt;code&gt;Supervisor.start_link/2&lt;/code&gt;&lt;/a&gt;. For example, if your application starts a supervision tree by running:</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#start_link/2&quot;&gt; &lt;code&gt;Supervisor.start_link/2&lt;/code&gt; 에&lt;/a&gt; 제공된 것과 유사한 하위 사양 또는 모듈이 필요합니다 . 예를 들어, 애플리케이션이 다음을 실행하여 감독 트리를 시작하는 경우 :</target>
        </trans-unit>
        <trans-unit id="88606c2938fbdad4196a7b400eb0db21cee6ea05" translate="yes" xml:space="preserve">
          <source>It expects a list of files to compile and an optional path to write the compiled code to. By default files are in-memory compiled. To write compiled files to the current directory, an empty string can be given.</source>
          <target state="translated">컴파일 할 파일 목록과 컴파일 된 코드를 작성할 선택적 경로가 필요합니다. 기본적으로 파일은 메모리 내 컴파일됩니다. 컴파일 된 파일을 현재 디렉토리에 쓰려면 빈 문자열을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f95cc29acd1a8f43652435b365857f4644147164" translate="yes" xml:space="preserve">
          <source>It expects a time zone to put the &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; in. If the time zone is &quot;Etc/UTC&quot;, it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as &lt;code&gt;time_zone_database&lt;/code&gt;. See the &quot;Time zone database&quot; section in the module documentation.</source>
          <target state="translated">표준 시간대에 &lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 을 넣을 것으로 예상 됩니다. 표준 시간대가 &quot;Etc / UTC&quot;이면 항상 성공합니다. 그렇지 않은 경우 NaiveDateTime은 &lt;code&gt;time_zone_database&lt;/code&gt; 로 제공된 시간대 데이터베이스와 비교하여 확인됩니다 . 모듈 문서의 &quot;시간대 데이터베이스&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1a16340d7de1aebc03edf6573a0e15525a829528" translate="yes" xml:space="preserve">
          <source>It expects a time zone to put the NaiveDateTime in. If the time zone is &quot;Etc/UTC&quot;, it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as &lt;code&gt;time_zone_database&lt;/code&gt;. See the &quot;Time zone database&quot; section in the module documentation.</source>
          <target state="translated">표준 시간대에 NaiveDateTime을 넣을 것으로 예상됩니다. 표준 시간대가 &quot;Etc / UTC&quot;이면 항상 성공합니다. 그렇지 않은 경우 NaiveDateTime은 &lt;code&gt;time_zone_database&lt;/code&gt; 로 제공된 시간대 데이터베이스와 비교하여 확인됩니다 . 모듈 문서의 &quot;시간대 데이터베이스&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c6e8dcd4689f9bb5cfe59fd80447b6dfb675bc3e" translate="yes" xml:space="preserve">
          <source>It expects an accumulator and a function that receives each enumerable element, and must return a tuple containing a new enumerable (often a list) with the new accumulator or a tuple with &lt;code&gt;:halt&lt;/code&gt; as first element and the accumulator as second.</source>
          <target state="translated">누산기와 각 열거 가능한 요소를받는 함수를 기대하고 새 누산기와 함께 새로운 열거 가능 (종종 목록)이 포함 된 튜플을 반환하거나 &lt;code&gt;:halt&lt;/code&gt; 를 첫 번째 요소로 , 튜플을 두 번째로 반환하는 튜플을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ae9f951251e613dc3b8cb49889447942b487f90f" translate="yes" xml:space="preserve">
          <source>It expects an accumulator and a function that receives each stream element and an accumulator, and must return a tuple containing a new stream (often a list) with the new accumulator or a tuple with &lt;code&gt;:halt&lt;/code&gt; as first element and the accumulator as second.</source>
          <target state="translated">각 스트림 요소와 누산기를 수신하는 누산기와 함수가 필요하며 새 누산기와 함께 새 스트림 (종종 목록)이 포함 된 튜플 또는 첫 번째 요소로 &lt;code&gt;:halt&lt;/code&gt; 와 두 번째로 누산기가 있는 튜플을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cdb9574f709769eda3fcd701f6835100d09de7b2" translate="yes" xml:space="preserve">
          <source>It happens we can also use this same syntax for updating the value:</source>
          <target state="translated">값을 업데이트하기 위해 동일한 구문을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d301b15b4e45486cec4db8315f250c006b60e6f" translate="yes" xml:space="preserve">
          <source>It has to be replaced by:</source>
          <target state="translated">다음으로 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="272be857efb69d0027fa3d247e076f214cedbf37" translate="yes" xml:space="preserve">
          <source>It includes assigns (like &lt;code&gt;@foo&lt;/code&gt;) and possibly other conveniences in the future.</source>
          <target state="translated">여기에는 &lt;code&gt;@foo&lt;/code&gt; 와 같은 할당 과 향후 다른 편의가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6566504417caf3c9fcfa6f04770ab2069caa71e8" translate="yes" xml:space="preserve">
          <source>It includes many features:</source>
          <target state="translated">많은 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="71b759b7ba0ceba9436adc2e4d919d9a0599963f" translate="yes" xml:space="preserve">
          <source>It is advised to pass to &lt;a href=&quot;#to_argv/2&quot;&gt;&lt;code&gt;to_argv/2&lt;/code&gt;&lt;/a&gt; the same set of &lt;code&gt;options&lt;/code&gt; given to &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;. Some switches can only be reconstructed correctly with the &lt;code&gt;:switches&lt;/code&gt; information in hand.</source>
          <target state="translated">에 전달하는 것이 좋습니다 &lt;a href=&quot;#to_argv/2&quot;&gt; &lt;code&gt;to_argv/2&lt;/code&gt; &lt;/a&gt; 의 동일한 세트 &lt;code&gt;options&lt;/code&gt; 부여 &lt;a href=&quot;#parse/2&quot;&gt; &lt;code&gt;parse/2&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;:switches&lt;/code&gt; 정보를 사용하여 일부 스위치 만 올바르게 재구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ec9133e5ffa0e2eb38967925bbcd3b498316545" translate="yes" xml:space="preserve">
          <source>It is also possible to put an element at a particular index in a tuple with &lt;code&gt;put_elem/3&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;put_elem/3&lt;/code&gt; 을 사용하여 튜플의 특정 인덱스에 요소를 넣을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="68a13c5162ca9952e7df7f252e41c665b4a6ce1a" translate="yes" xml:space="preserve">
          <source>It is also possible to register the &lt;code&gt;pid&lt;/code&gt;, giving it a name, and allowing everyone that knows the name to send it messages:</source>
          <target state="translated">&lt;code&gt;pid&lt;/code&gt; 를 등록 하고 이름을 지정하고 이름을 아는 모든 사람이 메시지를 보낼 수 있도록 허용 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a136eb79bc8a61b01254d5faf81fdf246125d6a9" translate="yes" xml:space="preserve">
          <source>It is also possible to spawn a task under a supervisor. The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; module implements the &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; function, which allows it to be started directly under a supervisor by passing a tuple with a function to run:</source>
          <target state="translated">감독자 아래에 작업을 생성 할 수도 있습니다. &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 모듈 구현 &lt;a href=&quot;#child_spec/1&quot;&gt; &lt;code&gt;child_spec/1&lt;/code&gt; &lt;/a&gt; 이 실행하는 기능을 튜플을 전달하여 관리자에서 직접 시작할 수 있습니다 기능 :</target>
        </trans-unit>
        <trans-unit id="d56d59c22a31d0146ae9749c3030a51ef3731009" translate="yes" xml:space="preserve">
          <source>It is also used between &lt;code&gt;fn/end&lt;/code&gt; for building anonymous functions:</source>
          <target state="translated">익명 함수를 빌드하기 위해 &lt;code&gt;fn/end&lt;/code&gt; 사이에도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="56e71075219fd34ef819cdd9dc47abc0939b0f36" translate="yes" xml:space="preserve">
          <source>It is also very common to use &lt;code&gt;IO.inspect/2&lt;/code&gt; with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binding/0&quot;&gt;&lt;code&gt;binding()&lt;/code&gt;&lt;/a&gt;, which returns all variable names and their values:</source>
          <target state="translated">모든 변수 이름과 값을 반환하는 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binding/0&quot;&gt; &lt;code&gt;binding()&lt;/code&gt; &lt;/a&gt; 과 함께 &lt;code&gt;IO.inspect/2&lt;/code&gt; 를 사용하는 것도 매우 일반적입니다 .</target>
        </trans-unit>
        <trans-unit id="d30bf8f40195feb2fe708ceb6f9af150955200b6" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 366.</source>
          <target state="translated">1에서 366 사이의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="32489e7a3e2d6e237839e846a2d9f094cd20f95c" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 4.</source>
          <target state="translated">1에서 4까지의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="aef7af646cd422fb9f21670a1cedef851042bc5d" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 7, where 1 is Monday and 7 is Sunday.</source>
          <target state="translated">1에서 7까지의 정수이며 여기서 1은 월요일이고 7은 일요일입니다.</target>
        </trans-unit>
        <trans-unit id="e3505fd23f7d466c912f750fe33536eb913541ef" translate="yes" xml:space="preserve">
          <source>It is available only in the &lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;rescue&lt;/code&gt; clauses of &lt;a href=&quot;#try/1&quot;&gt;&lt;code&gt;try/1&lt;/code&gt;&lt;/a&gt; expressions.</source>
          <target state="translated">&lt;a href=&quot;#try/1&quot;&gt; &lt;code&gt;try/1&lt;/code&gt; &lt;/a&gt; 표현식 의 &lt;code&gt;catch&lt;/code&gt; 및 &lt;code&gt;rescue&lt;/code&gt; 절 에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80946675cc21f317c9b0ef6e5905961ee735ea93" translate="yes" xml:space="preserve">
          <source>It is exactly this supervision system that makes constructs like &lt;code&gt;try/catch&lt;/code&gt; and &lt;code&gt;try/rescue&lt;/code&gt; so uncommon in Elixir. Instead of rescuing an error, we&amp;rsquo;d rather &amp;ldquo;fail fast&amp;rdquo; since the supervision tree will guarantee our application will go back to a known initial state after the error.</source>
          <target state="translated">Elixir에서는 &lt;code&gt;try/catch&lt;/code&gt; 및 &lt;code&gt;try/rescue&lt;/code&gt; 와 같은 구문을 매우 드물게 만드는 것이 바로이 감독 시스템입니다 . 감독 트리는 오류가 발생한 후 응용 프로그램이 알려진 초기 상태로 돌아갈 수 있도록 보장하기 때문에 오류를 구조하는 대신 &quot;빠르게&quot;실패합니다.</target>
        </trans-unit>
        <trans-unit id="d207929393d3a65f7ffe43fdfee93a560fcbb309" translate="yes" xml:space="preserve">
          <source>It is extremely important that &lt;strong&gt;the formatting function does not fail&lt;/strong&gt;, as it will bring that particular logger instance down, causing your system to temporarily lose messages. If necessary, wrap the function in a &lt;code&gt;rescue&lt;/code&gt; and log a default message instead:</source>
          <target state="translated">&lt;strong&gt;포맷 기능이 실패하지 않는&lt;/strong&gt; 것이 매우 중요합니다 &lt;strong&gt;.&lt;/strong&gt; 특정 로거 인스턴스가 다운되어 시스템이 일시적으로 메시지를 잃게됩니다. 필요한 경우 &lt;code&gt;rescue&lt;/code&gt; 에서 기능을 래핑하고 대신 기본 메시지를 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="94832ece51ae5f1825006490cfa48c6fe6830752" translate="yes" xml:space="preserve">
          <source>It is important that a macro is defined before its usage. Failing to define a macro before its invocation will raise an error at runtime, since the macro won&amp;rsquo;t be expanded and will be translated to a function call:</source>
          <target state="translated">매크로는 사용하기 전에 정의해야합니다. 매크로가 확장되지 않고 함수 호출로 변환되기 때문에 호출 전에 매크로를 정의하지 못하면 런타임시 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0771070acf565ebd4c40d426b39c1e6523d52f21" translate="yes" xml:space="preserve">
          <source>It is important that you choose an editor command that does not block nor that attempts to run an editor directly in the terminal. Command-line based editors likely need extra configuration so they open up the given file and line in a separate window.</source>
          <target state="translated">터미널에서 직접 편집기를 실행하거나 차단하지 않는 편집기 명령을 선택하는 것이 중요합니다. 명령 행 기반 편집기는 추가 구성이 필요할 수 있으므로 주어진 파일과 행을 별도의 창에서 엽니 다.</target>
        </trans-unit>
        <trans-unit id="b481005fe84ee670ac7d11f9a15a1a80d4c1bd8f" translate="yes" xml:space="preserve">
          <source>It is important to bear in mind that variables defined inside &lt;code&gt;try/catch/rescue/after&lt;/code&gt; blocks do not leak to the outer context. This is because the &lt;code&gt;try&lt;/code&gt; block may fail and as such the variables may never be bound in the first place. In other words, this code is invalid:</source>
          <target state="translated">&lt;code&gt;try/catch/rescue/after&lt;/code&gt; 블록 내에 정의 된 변수 는 외부 컨텍스트로 누출되지 않습니다. &lt;code&gt;try&lt;/code&gt; 블록이 실패하고 변수가 처음부터 바인딩되지 않을 수 있기 때문 입니다. 즉,이 코드는 유효하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="d6056e64535d65b5186c963f7472dd3b3997efc0" translate="yes" xml:space="preserve">
          <source>It is important to consider the limitations of distributed agents. Agents provide two APIs, one that works with anonymous functions and another that expects an explicit module, function, and arguments.</source>
          <target state="translated">분산 에이전트의 제한 사항을 고려해야합니다. 에이전트는 익명 함수와 작동하는 API와 명시 적 모듈, 함수 및 인수가 필요한 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f355f25591ea852cf993c5e79bb23c864b9b3d30" translate="yes" xml:space="preserve">
          <source>It is important to highlight that step 2 is a blocking one. Termination of a supervisor triggers a recursive chain of children terminations, therefore orderly shutting down all descendant processes. The &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; callback is invoked only after termination of the whole supervision tree.</source>
          <target state="translated">2 단계가 차단 단계임을 강조하는 것이 중요합니다. 수퍼바이저의 종료는 재귀적인 하위 종료 체인을 트리거하므로 모든 하위 프로세스를 순서대로 종료합니다. &lt;a href=&quot;#c:stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt; 콜백은 전체 감독 트리의 종료 후 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a5cda11adf3996ed10a3333a6901fb7bf070783d" translate="yes" xml:space="preserve">
          <source>It is important to note a couple of things:</source>
          <target state="translated">몇 가지 사항에 유의하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="c367faed115a28802b3ecac8ce4c9b1b9a88de2a" translate="yes" xml:space="preserve">
          <source>It is important to note that a name without &lt;code&gt;!&lt;/code&gt; does not mean a function will never raise. For example, even &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; can fail in case of bad arguments:</source>
          <target state="translated">이름이 없으면 이름을 명심해야합니다 &lt;code&gt;!&lt;/code&gt; 함수가 결코 일어나지 않는다는 의미는 아닙니다. 예를 들어 잘못된 인수의 경우 &lt;a href=&quot;file#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt; 조차 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64d0775b812a63ae04cc72818c998dd0360e82ac" translate="yes" xml:space="preserve">
          <source>It is important to note that reading an attribute takes a snapshot of its current value. In other words, the value is read at compilation time and not at runtime. Check the &lt;a href=&quot;module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; module for other functions to manipulate module attributes.</source>
          <target state="translated">속성을 읽으려면 현재 값의 스냅 샷이 생성됩니다. 즉, 값은 런타임이 아닌 컴파일 타임에 읽습니다. 모듈 속성을 조작하기위한 다른 기능에 대해서는 &lt;a href=&quot;module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt; 모듈을 점검하십시오 .</target>
        </trans-unit>
        <trans-unit id="a19241f2445b2abd37c68c335fe23ae6dbe32fe5" translate="yes" xml:space="preserve">
          <source>It is important to notice that &lt;a href=&quot;#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt; is lexical. This means you can import specific macros inside specific functions:</source>
          <target state="translated">것을 통지하는 것이 중요합니다 &lt;a href=&quot;#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt; 어휘이다. 즉, 특정 함수 내에서 특정 매크로를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74faff03e6fb39084e8fdee360d2d52a55c9644f" translate="yes" xml:space="preserve">
          <source>It is not recommended to &lt;code&gt;await&lt;/code&gt; a long-running task inside an OTP behaviour such as &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Instead, you should match on the message coming from a task inside your &lt;a href=&quot;genserver#c:handle_info/2&quot;&gt;&lt;code&gt;GenServer.handle_info/2&lt;/code&gt;&lt;/a&gt; callback. For more information on the format of the message, see the documentation for &lt;a href=&quot;#async/1&quot;&gt;&lt;code&gt;async/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 와 같은 OTP 동작 내에서 장기 실행 작업 을 &lt;code&gt;await&lt;/code&gt; 것은 권장하지 않습니다 . 대신 &lt;a href=&quot;genserver#c:handle_info/2&quot;&gt; &lt;code&gt;GenServer.handle_info/2&lt;/code&gt; &lt;/a&gt; 콜백 내의 작업에서 오는 메시지와 일치해야합니다 . 메시지 형식에 대한 자세한 내용은 &lt;a href=&quot;#async/1&quot;&gt; &lt;code&gt;async/1&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f8ca3b4e0816d59dc7e2cc08d33fe47c5a02853" translate="yes" xml:space="preserve">
          <source>It is not required to call this function when terminating the caller, unless exiting with reason &lt;code&gt;:normal&lt;/code&gt; or if the task is trapping exits. If the caller is exiting with a reason other than &lt;code&gt;:normal&lt;/code&gt; and the task is not trapping exits, the caller's exit signal will stop the task. The caller can exit with reason &lt;code&gt;:shutdown&lt;/code&gt; to shut down all of its linked processes, including tasks, that are not trapping exits without generating any log messages.</source>
          <target state="translated">reason &lt;code&gt;:normal&lt;/code&gt; 로 종료하지 않거나 작업이 종료되는 경우를 제외하고 호출자를 종료 할 때이 함수를 호출 할 필요는 없습니다 . 발신자가 &lt;code&gt;:normal&lt;/code&gt; 이외의 이유로 종료 하고 있고 작업이 종료를 트래핑하지 않는 경우, 발신자의 종료 신호는 작업을 중지합니다. 호출자는 reason &lt;code&gt;:shutdown&lt;/code&gt; 으로 종료하여 태스크를 포함하여 로그 메시지를 생성하지 않고 엑시트를 트랩하지 않는 모든 링크 된 프로세스를 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67f36f6c8c75697bc200a5a574eb5412409dbdaf" translate="yes" xml:space="preserve">
          <source>It is possible to get shell history by passing some options that enable it in the VM. This can be done on a per-need basis when starting IEx:</source>
          <target state="translated">VM에서 사용 가능한 일부 옵션을 전달하여 셸 기록을 가져올 수 있습니다. IEx를 시작할 때 필요에 따라 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69aceb3d7f53fc191d1a69a74161461cd8fbf145" translate="yes" xml:space="preserve">
          <source>It is possible to implement protocols for all Elixir types:</source>
          <target state="translated">모든 Elixir 유형에 대한 프로토콜을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54b8401178da67a2e8ae820b1821bcca42b37a5a" translate="yes" xml:space="preserve">
          <source>It is possible to load another file by supplying the &lt;code&gt;--dot-iex&lt;/code&gt; option to IEx. See &lt;code&gt;iex --help&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--dot-iex&lt;/code&gt; 옵션을 IEx 에 제공하여 다른 파일을로드 할 수 있습니다 . &lt;code&gt;iex --help&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4658430a105177a520b05efa9b8a1f1f62f88a4e" translate="yes" xml:space="preserve">
          <source>It is received by formatters and contains the following fields:</source>
          <target state="translated">포맷터가 수신하며 다음 필드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="02b1294519dc996fe92a26357c7d5248dd2135f9" translate="yes" xml:space="preserve">
          <source>It is recommended for this function to be invoked in your application's start callback in case you want to register new URIs.</source>
          <target state="translated">새 URI를 등록하려는 경우 응용 프로그램의 시작 콜백에서이 함수를 호출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5e8259dbbda9694f8ea6053003d2b8b79b9d00cb" translate="yes" xml:space="preserve">
          <source>It is recommended that backends support at least the following configuration options:</source>
          <target state="translated">백엔드는 최소한 다음 구성 옵션을 지원하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="01b6fa79cb9bec0bdf62d160c7cca8aebb12f76e" translate="yes" xml:space="preserve">
          <source>It is recommended that handlers ignore messages where the group leader is in a different node than the one where the handler is installed. For example:</source>
          <target state="translated">핸들러는 그룹 리더가 핸들러가 설치된 노드와 다른 노드에있는 메시지를 무시하는 것이 좋습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f259c2cd34cad051f58a609a1b449871f089e4f6" translate="yes" xml:space="preserve">
          <source>It is recommended to define types for structs. By convention such type is called &lt;code&gt;t&lt;/code&gt;. To define a struct inside a type, the struct literal syntax is used:</source>
          <target state="translated">구조체 유형을 정의하는 것이 좋습니다. 관례 적으로 이러한 유형을 &lt;code&gt;t&lt;/code&gt; 라고 합니다. 유형 내부에 구조체를 정의하기 위해 구조체 리터럴 구문이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2d5fa416a3649615d6c6d6b9cb2027f26118c8ff" translate="yes" xml:space="preserve">
          <source>It is recommended to only use the struct syntax when defining the struct's type. When referring to another struct it's better to use &lt;code&gt;User.t&lt;/code&gt; instead of &lt;code&gt;%User{}&lt;/code&gt;.</source>
          <target state="translated">구조체의 타입을 정의 할 때 구조체 구문 만 사용하는 것이 좋습니다. 다른 구조체를 참조 할 때는 &lt;code&gt;%User{}&lt;/code&gt; 대신 &lt;code&gt;User.t&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="d5056e9d07d3e016975093e74ccd6e13e0e051a1" translate="yes" xml:space="preserve">
          <source>It is seen on &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;cond&lt;/code&gt; constructs between &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;do&lt;/code&gt; / &lt;code&gt;end&lt;/code&gt; 사이의 &lt;code&gt;case&lt;/code&gt; 및 &lt;code&gt;cond&lt;/code&gt; 구문에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5a7029e719605ca3d075a3021c347e0da442f5a" translate="yes" xml:space="preserve">
          <source>It is the VM view of the &lt;a href=&quot;#os_time/0&quot;&gt;&lt;code&gt;os_time/0&lt;/code&gt;&lt;/a&gt;. They may not match in case of time warps although the VM works towards aligning them. This time is not monotonic.</source>
          <target state="translated">&lt;a href=&quot;#os_time/0&quot;&gt; &lt;code&gt;os_time/0&lt;/code&gt; &lt;/a&gt; 의 VM보기입니다 . VM이 정렬을 위해 노력하지만 시간 왜곡의 경우 일치하지 않을 수 있습니다. 이번에는 단조롭지 않습니다.</target>
        </trans-unit>
        <trans-unit id="788b993466f063f33f672e4a2e86998a7111a391" translate="yes" xml:space="preserve">
          <source>It is useful for performing work after initialization or for splitting the work in a callback in multiple steps, updating the process state along the way.</source>
          <target state="translated">초기화 후 작업을 수행하거나 콜백에서 작업을 여러 단계로 분할하여 프로세스 상태를 업데이트하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bb15e04c4610818bfc29250241bbd9f9e91a6db6" translate="yes" xml:space="preserve">
          <source>It is usually compiled to an atom:</source>
          <target state="translated">일반적으로 원자로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="609d6804675f59ef88a96987b74ba4711ad19be8" translate="yes" xml:space="preserve">
          <source>It is worth mentioning that some tasks, such as in the case of the &lt;code&gt;format&lt;/code&gt; command in the example above, can accept multiple files so it could be rewritten as:</source>
          <target state="translated">위의 예에서 &lt;code&gt;format&lt;/code&gt; 명령 의 경우와 같은 일부 작업 은 여러 파일을 허용하므로 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="581eca3344ca4bb0aa530a5501c01bfdeab48bb0" translate="yes" xml:space="preserve">
          <source>It is worth noting that an IO stream has side effects and every time you go over the stream you may get different results.</source>
          <target state="translated">IO 스트림에는 부작용이 있으며 스트림을 처리 할 때마다 다른 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5d4db08190e3953685aadfa886d49cc802cec92" translate="yes" xml:space="preserve">
          <source>It is, however, possible to customize the operating system exit signal by invoking:</source>
          <target state="translated">그러나 다음을 호출하여 운영 체제 종료 신호를 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7d48f671c8d7393dad3a546a97b3ca8d3a912b7" translate="yes" xml:space="preserve">
          <source>It mainly consists of:</source>
          <target state="translated">주로 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="1e0c789d57c1d4d0b775a90fcdfa554caa5f5673" translate="yes" xml:space="preserve">
          <source>It may also be used in bit strings to specify the type of a given bit segment:</source>
          <target state="translated">주어진 비트 세그먼트의 유형을 지정하기 위해 비트 문자열에서 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3af067d0b325c04e2171267019d9beee23844b2" translate="yes" xml:space="preserve">
          <source>It may be &lt;em&gt;done&lt;/em&gt; when the enumeration is finished by reaching its end, or &lt;em&gt;halted&lt;/em&gt;/&lt;em&gt;suspended&lt;/em&gt; when the enumeration was halted or suspended by the &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">그것은 할 수있다 &lt;em&gt;다&lt;/em&gt; 열거가 그 끝에 도달하여 종료되는 경우, 또는 &lt;em&gt;정지&lt;/em&gt; / &lt;em&gt;중단&lt;/em&gt; 열거가 중단 또는 일시 중단 될 때 &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="0d98718d8646c579d0371793bd45e746bde50bf4" translate="yes" xml:space="preserve">
          <source>It may raise an exception if an alias or a task can't be found or the task is invalid. Check &lt;a href=&quot;#get!/1&quot;&gt;&lt;code&gt;get!/1&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">별명이나 작업을 찾을 수 없거나 작업이 유효하지 않은 경우 예외가 발생할 수 있습니다. 확인 &lt;a href=&quot;#get!/1&quot;&gt; &lt;code&gt;get!/1&lt;/code&gt; &lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="96e34b31aa2d5f1e971f892ae829e91c39507ae8" translate="yes" xml:space="preserve">
          <source>It merely logged an error but the parent process is still running. That&amp;rsquo;s because processes are isolated. If we want the failure in one process to propagate to another one, we should link them. This can be done with &lt;code&gt;spawn_link/1&lt;/code&gt;:</source>
          <target state="translated">단지 오류를 기록했지만 상위 프로세스가 여전히 실행 중입니다. 프로세스가 분리되어 있기 때문입니다. 한 프로세스의 실패가 다른 프로세스로 전파되기를 원하면이를 연결해야합니다. 이는 &lt;code&gt;spawn_link/1&lt;/code&gt; 로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7645b02092dd9c481669b06461dd8a3b1f2ddfe" translate="yes" xml:space="preserve">
          <source>It must be a tagged tuple with one of the following &quot;tags&quot;:</source>
          <target state="translated">다음 &quot;태그&quot;중 하나가있는 태그가 지정된 튜플이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9191e1a92c69837df58d349dc309a932384aa7e6" translate="yes" xml:space="preserve">
          <source>It must return Elixir's quoted expressions for the nesting.</source>
          <target state="translated">중첩에 대해 Elixir의 인용 된 표현식을 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="712b77376d5995f0d379321d9075dffa76132d6d" translate="yes" xml:space="preserve">
          <source>It must return Elixir's quoted expressions for the template.</source>
          <target state="translated">템플릿에 대해 Elixir가 인용 한 표현식을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="38cc5837d518a2974bbdd3756a4a52b60b4904d1" translate="yes" xml:space="preserve">
          <source>It must return a new state that is used only inside the nesting. Once the nesting terminates, the current &lt;code&gt;state&lt;/code&gt; is resumed.</source>
          <target state="translated">중첩 내부에서만 사용되는 새로운 상태를 반환해야합니다. 중첩이 종료되면 현재 &lt;code&gt;state&lt;/code&gt; 가 재개됩니다.</target>
        </trans-unit>
        <trans-unit id="0854aef4598e67609aceb61dad3e1730bf8b1dd1" translate="yes" xml:space="preserve">
          <source>It must return the initial state.</source>
          <target state="translated">초기 상태를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="e3fb70c8558503fe57ada3a7512d669bb23cc15f" translate="yes" xml:space="preserve">
          <source>It must return the updated state.</source>
          <target state="translated">업데이트 된 상태를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="168abfa6eb1b0dfa8208332679693b0f2aede472" translate="yes" xml:space="preserve">
          <source>It performs Normalization Form Canonical Decomposition (NFD) on the strings before comparing them. This function is equivalent to:</source>
          <target state="translated">문자열을 비교하기 전에 문자열에서 NFD (Normalization Form Canonical Decomposition)를 수행합니다. 이 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="00eb69ecf576738c75d84548dd92cdb318ece3aa" translate="yes" xml:space="preserve">
          <source>It raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;pid&lt;/code&gt; is not a local process.</source>
          <target state="translated">그것은 제기 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 경우 &lt;code&gt;pid&lt;/code&gt; 는 로컬 과정이 아니다.</target>
        </trans-unit>
        <trans-unit id="7e7523b5dc45d67bb8b9c0de3919b26ce0d37a20" translate="yes" xml:space="preserve">
          <source>It raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; when index is negative or it is out of range of the tuple elements.</source>
          <target state="translated">이 상승 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 인덱스가 네거티브인지는 튜플 요소의 범위를 벗어난 경우.</target>
        </trans-unit>
        <trans-unit id="a7db82325b8b2d3d85d652577eadfac10c4e6cc9" translate="yes" xml:space="preserve">
          <source>It raises at compile time if the definition uses expressions that aren't allowed in guards, and otherwise creates a macro that can be used both inside or outside guards.</source>
          <target state="translated">정의에서 가드에 허용되지 않는 표현식을 사용하는 경우 컴파일 타임에 발생하고 그렇지 않으면 가드 내부 또는 외부에서 사용할 수있는 매크로를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="1064c23cd1e6b9f641867dd10b3bf5061844678b" translate="yes" xml:space="preserve">
          <source>It raises at compile time if the definition uses expressions that aren't allowed in guards, and otherwise creates a private macro that can be used both inside or outside guards in the current module.</source>
          <target state="translated">정의에 가드에서 허용되지 않는 표현식을 사용하는 경우 컴파일 타임에 발생하고, 그렇지 않으면 현재 모듈에서 내부 또는 외부 가드 모두에서 사용할 수있는 개인용 매크로를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="b4865031f19e0226674ccac4c00c4c4f11e96290" translate="yes" xml:space="preserve">
          <source>It receives the current &lt;code&gt;config&lt;/code&gt; and the &lt;code&gt;state&lt;/code&gt; returned by &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;. Then you typically read the extra configuration from an external source and merge it into the received &lt;code&gt;config&lt;/code&gt;. Merging should be done with &lt;a href=&quot;config.reader#merge/2&quot;&gt;&lt;code&gt;Config.Reader.merge/2&lt;/code&gt;&lt;/a&gt;, as it performs deep merge. It should return the updated config.</source>
          <target state="translated">현재 &lt;code&gt;config&lt;/code&gt; 과 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; 이&lt;/a&gt; 반환 한 &lt;code&gt;state&lt;/code&gt; 받습니다 . 그런 다음 일반적으로 외부 소스에서 추가 구성을 읽고 수신 된 &lt;code&gt;config&lt;/code&gt; 으로 병합합니다 . 딥 병합을 수행하므로 &lt;a href=&quot;config.reader#merge/2&quot;&gt; &lt;code&gt;Config.Reader.merge/2&lt;/code&gt; 를 사용&lt;/a&gt; 하여 병합해야합니다 . 업데이트 된 구성을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="7ff8300751e75adc2c83e12f280310fb0e3959a9" translate="yes" xml:space="preserve">
          <source>It receives the same options as &lt;a href=&quot;#put_env/4&quot;&gt;&lt;code&gt;put_env/4&lt;/code&gt;&lt;/a&gt;. Returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#put_env/4&quot;&gt; &lt;code&gt;put_env/4&lt;/code&gt; &lt;/a&gt; 와 동일한 옵션을 받습니다 . 반환 값 &lt;code&gt;:ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63a1b1ead1b4654ed54aa371a1a054c21e1c05bd" translate="yes" xml:space="preserve">
          <source>It relies on &lt;a href=&quot;#format_banner/3&quot;&gt;&lt;code&gt;format_banner/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#format_stacktrace/1&quot;&gt;&lt;code&gt;format_stacktrace/1&lt;/code&gt;&lt;/a&gt; to generate the final format.</source>
          <target state="translated">최종 형식을 생성하려면 &lt;a href=&quot;#format_banner/3&quot;&gt; &lt;code&gt;format_banner/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#format_stacktrace/1&quot;&gt; &lt;code&gt;format_stacktrace/1&lt;/code&gt; &lt;/a&gt; 에 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="ff0e052a45a87445bf1db1b18304c3b0b5b06885" translate="yes" xml:space="preserve">
          <source>It represents time as a fraction of a day (starting from midnight). &lt;code&gt;parts_in_day&lt;/code&gt; specifies how much of the day is already passed, while &lt;code&gt;parts_per_day&lt;/code&gt; signifies how many parts there fit in a day.</source>
          <target state="translated">자정부터 시작하여 하루의 일부로 시간을 나타냅니다. &lt;code&gt;parts_in_day&lt;/code&gt; 는 하루가 이미 지나간 양을 지정하고 parts_per_day 는 하루에 몇 개의 부품이 &lt;code&gt;parts_per_day&lt;/code&gt; 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ef0b176f883854b3bc16cf9fece54e5b9b4e4c75" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if it succeeds.</source>
          <target state="translated">성공하면 &lt;code&gt;:ok&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b4dd7376af1ba434a4580bda89ca9e2039d7b5af" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if the agent terminates with the given reason. If the agent terminates with another reason, the call will exit.</source>
          <target state="translated">주어진 이유로 에이전트가 종료되면 &lt;code&gt;:ok&lt;/code&gt; 를 리턴합니다 . 다른 이유로 상담원이 종료되면 통화가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="fa25fad557d19ecb8fc577a65e74f7d1d95fee17" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if the expression is valid. Otherwise it returns a tuple in the form of &lt;code&gt;{:error, remainder}&lt;/code&gt; where &lt;code&gt;remainder&lt;/code&gt; is the invalid part of the quoted expression.</source>
          <target state="translated">표현식이 유효하면 &lt;code&gt;:ok&lt;/code&gt; 를 리턴 합니다. 그렇지 않으면 &lt;code&gt;{:error, remainder}&lt;/code&gt; 형식으로 튜플을 반환합니다 . 여기서 &lt;code&gt;remainder&lt;/code&gt; 는 인용 된 표현식의 유효하지 않은 부분입니다.</target>
        </trans-unit>
        <trans-unit id="1aa27a7fb3f7df06a7eb5b40933d88237c6da58a" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if the supervisor terminates with the given reason. If it terminates with another reason, the call exits.</source>
          <target state="translated">주어진 이유로 감독자가 종료되면 &lt;code&gt;:ok&lt;/code&gt; 를 반환합니다 . 다른 이유로 종료되면 통화가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="20439119e73e5c84c38c2e670d5943fecce5bbc5" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if there is a supervised process with such &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;{:error, :not_found}&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 가 &lt;code&gt;{:error, :not_found}&lt;/code&gt; 감독 프로세스가 있으면 &lt;code&gt;:ok&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c6ba3f217ed1eba268a6fdafd4321bb54d3750b6" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;[]&lt;/code&gt; if &lt;code&gt;amount&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; or if &lt;code&gt;start_index&lt;/code&gt; is out of bounds.</source>
          <target state="translated">그것은 반환 &lt;code&gt;[]&lt;/code&gt; 경우 &lt;code&gt;amount&lt;/code&gt; 입니다 &lt;code&gt;0&lt;/code&gt; 또는 경우 &lt;code&gt;start_index&lt;/code&gt; 범위를 벗어났습니다.</target>
        </trans-unit>
        <trans-unit id="a24863390fa39668ae8776992d58e83d80073d64" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, modules, warnings}&lt;/code&gt; or &lt;code&gt;{:error, errors, warnings}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:ok, modules, warnings}&lt;/code&gt; 또는 &lt;code&gt;{:error, errors, warnings}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="15cf8a959344bff62a34e05c441e26b91698feeb" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, number_of_modules_purged}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:ok, number_of_modules_purged}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="115a450f9d17534c1b57fc590c68a557bb8594c5" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, regex}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">그것은 반환 &lt;code&gt;{:ok, regex}&lt;/code&gt; 성공의 경우, &lt;code&gt;{:error, reason}&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="de65d4d5bdecdb8de8753805e8f5f01ea831d124" translate="yes" xml:space="preserve">
          <source>It returns a charlist as if it was a single quoted string, unescaping characters and replacing interpolations.</source>
          <target state="translated">문자를 이스케이프 처리하고 보간을 대체하여 작은 따옴표로 묶은 문자열 인 것처럼 문자 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a66f3b8a76faa873e28dfa79a7a12532886cbb5f" translate="yes" xml:space="preserve">
          <source>It returns a list of &quot;words&quot; split by whitespace without escaping nor interpreting interpolations.</source>
          <target state="translated">보간을 이탈하거나 해석하지 않고 공백으로 나눈 &quot;단어&quot;목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="11c767a0c0e8da6110101dac7c301abe9c23f7ad" translate="yes" xml:space="preserve">
          <source>It returns a list of &quot;words&quot; split by whitespace. Character unescaping and interpolation happens for each word.</source>
          <target state="translated">공백으로 나눈 &quot;단어&quot;목록을 반환합니다. 각 단어마다 문자 이스케이프 및 보간이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e5072f624143fef2c9ac9a882f637a2b3946d312" translate="yes" xml:space="preserve">
          <source>It returns a list with all defined functions and macros, public and private, in the shape of &lt;code&gt;[{name, arity}, ...]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[{name, arity}, ...]&lt;/code&gt; 모양으로 정의 된 모든 함수 및 매크로 (public 및 private)가있는 목록을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="12058e15be1548c9678ae57e51b9c05668dbfa6c" translate="yes" xml:space="preserve">
          <source>It returns a regular expression pattern without escaping nor interpreting interpolations.</source>
          <target state="translated">보간을 이스케이프하거나 해석하지 않고 정규식 패턴을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c2339efe4030b11d97d29c7a067b3b9900e5b1d8" translate="yes" xml:space="preserve">
          <source>It returns a regular expression pattern, unescaping characters and replacing interpolations.</source>
          <target state="translated">문자를 이스케이프 처리하고 보간을 대체하는 정규식 패턴을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2eefd18752fd7d7d11850a6f38a6e135cd46467d" translate="yes" xml:space="preserve">
          <source>It returns a string as if it was a double quoted string, unescaping characters and replacing interpolations.</source>
          <target state="translated">문자를 이스케이프 처리하고 보간을 대체하여 큰 따옴표로 묶은 문자열 인 것처럼 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1309542e01ede5ca574094267b91e1297dcf83b5" translate="yes" xml:space="preserve">
          <source>It returns a three-element tuple with the form &lt;code&gt;{parsed, args, invalid}&lt;/code&gt;, where:</source>
          <target state="translated">&lt;code&gt;{parsed, args, invalid}&lt;/code&gt; 형식의 3 요소 튜플을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5d3aa2fe3892cfc7dc8712478400dbcd79a2ad47" translate="yes" xml:space="preserve">
          <source>It returns a tuple of shape &lt;code&gt;{:module, module, binary, term}&lt;/code&gt; where &lt;code&gt;module&lt;/code&gt; is the module name, &lt;code&gt;binary&lt;/code&gt; is the module byte code and &lt;code&gt;term&lt;/code&gt; is the result of the last expression in &lt;code&gt;quoted&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:module, module, binary, term}&lt;/code&gt; 모양의 튜플을 반환합니다 . 여기서 &lt;code&gt;module&lt;/code&gt; 은 모듈 이름이고 &lt;code&gt;binary&lt;/code&gt; 는 모듈 바이트 코드이며 &lt;code&gt;term&lt;/code&gt; 은 마지막 표현식의 결과입니다 ( &lt;code&gt;quoted&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="105ded5280b2ff4b7ca0620f752d88bc06179945" translate="yes" xml:space="preserve">
          <source>It returns a tuple where the first element is the first value for &lt;code&gt;key&lt;/code&gt; and the second element is a keyword list with all entries associated with &lt;code&gt;key&lt;/code&gt; removed. If the &lt;code&gt;key&lt;/code&gt; is not present in the keyword list, &lt;code&gt;{default, keyword_list}&lt;/code&gt; is returned.</source>
          <target state="translated">첫 번째 요소는 대한 첫 번째 값입니다 그것은 튜플을 반환 &lt;code&gt;key&lt;/code&gt; 두 번째 요소와 관련된 모든 항목이 키워드 목록입니다 &lt;code&gt;key&lt;/code&gt; 제거. 경우 &lt;code&gt;key&lt;/code&gt; 키워드 목록에 존재하지 않는, &lt;code&gt;{default, keyword_list}&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="60c44e4aa381e2f2476e80a74b5488ef1fbe7e6d" translate="yes" xml:space="preserve">
          <source>It returns a tuple with the configuration and the imported paths.</source>
          <target state="translated">구성 및 가져온 경로가 포함 된 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1c6d5c298bfea7e740d50d208c24e0a7cb35ea15" translate="yes" xml:space="preserve">
          <source>It returns a two-element tuple with two lists of elements. The element that triggered the split is part of the second list.</source>
          <target state="translated">두 개의 요소 목록이있는 두 개의 요소 튜플을 반환합니다. 분할을 트리거 한 요소는 두 번째 목록의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="3fdf4c8d7953d6b126d5564a13f2c8bce040ab31" translate="yes" xml:space="preserve">
          <source>It returns the &lt;code&gt;mix.exs&lt;/code&gt; file, the lock manifest, and all config files in the &lt;code&gt;config&lt;/code&gt; directory that do not start with a leading period (for example, &lt;code&gt;.my_config.exs&lt;/code&gt;).</source>
          <target state="translated">이 파일 은 &lt;code&gt;mix.exs&lt;/code&gt; 파일, 잠금 매니페스트 및 선행 기간으로 시작하지 않는 &lt;code&gt;config&lt;/code&gt; 디렉토리 의 모든 구성 파일 (예 : &lt;code&gt;.my_config.exs&lt;/code&gt; )을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="fe0d0c5e22a39b889893a15373fe9daae0aa2349" translate="yes" xml:space="preserve">
          <source>It returns the ast if it succeeds, raises an exception otherwise. The exception is a &lt;a href=&quot;tokenmissingerror&quot;&gt;&lt;code&gt;TokenMissingError&lt;/code&gt;&lt;/a&gt; in case a token is missing (usually because the expression is incomplete), &lt;a href=&quot;syntaxerror&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">성공하면 ast를 반환하고 그렇지 않으면 예외를 발생시킵니다. 토큰이 누락 된 경우 (보통 표현식이 불완전하기 때문에) &lt;a href=&quot;tokenmissingerror&quot;&gt; &lt;code&gt;TokenMissingError&lt;/code&gt; &lt;/a&gt; 는 예외이고 그렇지 않은 경우 &lt;a href=&quot;syntaxerror&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 는 예외입니다 .</target>
        </trans-unit>
        <trans-unit id="0ddb2097e9b6c67aac6845519cb92def4ddcd595" translate="yes" xml:space="preserve">
          <source>It returns the deleted attribute value (or &lt;code&gt;nil&lt;/code&gt; if nothing was set).</source>
          <target state="translated">삭제 된 속성 값을 반환합니다 ( 아무것도 설정 &lt;code&gt;nil&lt;/code&gt; 않은 경우 nil ).</target>
        </trans-unit>
        <trans-unit id="02c714a4ea003b7686a6af1daae5b12a336be932" translate="yes" xml:space="preserve">
          <source>It returns the names of the compiled modules.</source>
          <target state="translated">컴파일 된 모듈의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae123871707a2b6de82ed2c56ead673cc4cadc39" translate="yes" xml:space="preserve">
          <source>It returns the new map of compiler options.</source>
          <target state="translated">새로운 컴파일러 옵션 맵을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="766f8a3783379e82be75e43a3208cd1da372d673" translate="yes" xml:space="preserve">
          <source>It returns the number of Gregorian days between the dates. Only &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; structs that follow the same or compatible calendars can be compared this way. If two calendars are not compatible, it will raise.</source>
          <target state="translated">날짜 사이의 그레고리력 일 수를 반환합니다. 동일하거나 호환되는 달력을 따르는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 구조체 만이 방법으로 비교할 수 있습니다. 두 캘린더가 호환되지 않으면 올라갑니다.</target>
        </trans-unit>
        <trans-unit id="b6852c5d07c3b9783a2c197a51ccbe9ab48fc88a" translate="yes" xml:space="preserve">
          <source>It returns the same as the built-in &lt;code&gt;node()&lt;/code&gt;.</source>
          <target state="translated">내장 &lt;code&gt;node()&lt;/code&gt; 와 동일을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="d85ecab1cba97830aafe60c7db9bcdf6c281beb4" translate="yes" xml:space="preserve">
          <source>It returns the term stored in the documentation chunk in the format defined by &lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt; if the chunk is not available.</source>
          <target state="translated">문서 청크에 저장된 용어를 &lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48에&lt;/a&gt; 정의 된 형식으로 또는 청크를 사용할 수없는 경우 &lt;code&gt;{:error, reason}&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="3386214fb50a8516bbdf778fc1cd94340c90a3d8" translate="yes" xml:space="preserve">
          <source>It returns the updated version of the protocol bytecode. If the first element of the tuple is &lt;code&gt;:ok&lt;/code&gt;, it means the protocol was consolidated.</source>
          <target state="translated">업데이트 된 버전의 프로토콜 바이트 코드를 반환합니다. 튜플의 첫 번째 요소가 &lt;code&gt;:ok&lt;/code&gt; 인 경우 프로토콜이 통합되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c027793c4fcbf7f7be6aed911c23cf2d476fffe0" translate="yes" xml:space="preserve">
          <source>It returns:</source>
          <target state="translated">다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7e69f73c47c2d4297cd900ce85c28a9c948c1b19" translate="yes" xml:space="preserve">
          <source>It seems we are ready to go! We will use the interactive shell quite a lot in the next chapters to get a bit more familiar with the language constructs and basic types, starting in the next chapter.</source>
          <target state="translated">우리는 갈 준비가 된 것 같습니다! 다음 장부터 대화식 쉘을 상당히 많이 사용하여 다음 장부터 언어 구성과 기본 유형에 대해 좀 더 친숙해질 것입니다.</target>
        </trans-unit>
        <trans-unit id="7b61a10d3b18f5d9c1eaf6bc0cc59326c9f15aec" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, boolean}&lt;/code&gt; if you can check the membership of a given element in the &lt;code&gt;enumerable&lt;/code&gt; with &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt; without traversing the whole enumerable.</source>
          <target state="translated">그것은 반환해야합니다 &lt;code&gt;{:ok, boolean}&lt;/code&gt; 당신이 주어진 요소의 회원 자격을 확인할 수있는 경우에 &lt;code&gt;enumerable&lt;/code&gt; 와 &lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt; 전체 열거를 통과하지 않고.</target>
        </trans-unit>
        <trans-unit id="4eda1ce345c7961b8d8eaacacd3842665d668e46" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, count}&lt;/code&gt; if you can count the number of elements in the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 의 요소 수를 계산할 수 있으면 &lt;code&gt;{:ok, count}&lt;/code&gt; 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b69c5b898ed0b1df84697cb05eb4de3925bc611c" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, size, slicing_fun}&lt;/code&gt; if the &lt;code&gt;enumerable&lt;/code&gt; has a known bound and can access a position in the &lt;code&gt;enumerable&lt;/code&gt; without traversing all previous elements.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 에 알려진 경계가 있고 이전 요소를 모두 통과하지 않고 &lt;code&gt;enumerable&lt;/code&gt; 의 위치에 액세스 할 수 있으면 &lt;code&gt;{:ok, size, slicing_fun}&lt;/code&gt; 반환해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c6ec473d814fbb944cadb6ef7ecbd0b54ffb7903" translate="yes" xml:space="preserve">
          <source>It simply prints messages to stdio and stderr.</source>
          <target state="translated">단순히 stdio 및 stderr에 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="c2bf5d9b723f91bde75bc41d3f4bce002f449711" translate="yes" xml:space="preserve">
          <source>It simply returns a charlist without escaping characters and without interpolations.</source>
          <target state="translated">문자를 이스케이프하지 않고 보간하지 않고 단순히 문자 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c84e40ba905fa3630ef387da0561b471023546c1" translate="yes" xml:space="preserve">
          <source>It simply returns a string without escaping characters and without interpolations.</source>
          <target state="translated">단순히 문자를 이스케이프하지 않고 보간하지 않고 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6ac5bb057ce19bda73528c6e24000df9f4d91f41" translate="yes" xml:space="preserve">
          <source>It simply runs the compilers registered in your project and returns a tuple with the compilation status and a list of diagnostics.</source>
          <target state="translated">단순히 프로젝트에 등록 된 컴파일러를 실행하고 컴파일 상태 및 진단 목록이 포함 된 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="16d9b6683d66aba15c717ff1071205cd0f26c442" translate="yes" xml:space="preserve">
          <source>It supports the following options:</source>
          <target state="translated">다음 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a2e490ec4460253855b541489b49bac1f8ad8cbb" translate="yes" xml:space="preserve">
          <source>It takes an &lt;code&gt;enumerable&lt;/code&gt; with elements being two-element tuples and returns a tuple with two lists, each of which is formed by the first and second element of each tuple, respectively.</source>
          <target state="translated">요소가 두 요소 튜플 인 &lt;code&gt;enumerable&lt;/code&gt; 하고 각 목록의 첫 번째 요소와 두 번째 요소로 각각 구성된 두 개의 목록이있는 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="65267298def1e5c3f27ba97cc79959f0ec4e9b43" translate="yes" xml:space="preserve">
          <source>It takes the &lt;code&gt;kind&lt;/code&gt; spilled by &lt;code&gt;catch&lt;/code&gt; as an argument and normalizes only &lt;code&gt;:error&lt;/code&gt;, returning the untouched payload for others.</source>
          <target state="translated">그것은 소요 &lt;code&gt;kind&lt;/code&gt; 에 의해 유출 &lt;code&gt;catch&lt;/code&gt; 인수로 만 정규화 &lt;code&gt;:error&lt;/code&gt; 다른 사람 손길이 닿지 않은 페이로드를 반환.</target>
        </trans-unit>
        <trans-unit id="017d4c0f52ec05a16013c629cf13480b366963be" translate="yes" xml:space="preserve">
          <source>It uses &lt;a href=&quot;mix.tasks.xref&quot;&gt;&lt;code&gt;mix xref&lt;/code&gt;&lt;/a&gt; to check if any remote call does not exist or is deprecated, and emits warnings in such cases. This task does not show deprecated local calls (a call to a deprecated function or macro in the same module) nor calls to deprecated functionality in Elixir itself.</source>
          <target state="translated">&lt;a href=&quot;mix.tasks.xref&quot;&gt; &lt;code&gt;mix xref&lt;/code&gt; &lt;/a&gt; 를 사용 하여 원격 호출이 없거나 더 이상 사용되지 않는지 확인하고 이러한 경우 경고를 표시합니다. 이 작업은 더 이상 사용되지 않는 로컬 호출 (같은 모듈에서 더 이상 사용되지 않는 함수 또는 매크로에 대한 호출) 또는 Elixir 자체에서 더 이상 사용되지 않는 기능에 대한 호출을 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14a6eb5a7e6cf2ff92914f35b6fcd693c9459181" translate="yes" xml:space="preserve">
          <source>It uses the given &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; documents as surrounding and the separator document &lt;code&gt;separator&lt;/code&gt; to separate items in &lt;code&gt;docs&lt;/code&gt;. If all entries in the collection are simple documents (texts or strings), then this function attempts to put as much as possible on the same line. If they are not simple, only one entry is shown per line if they do not fit.</source>
          <target state="translated">주어진 &lt;code&gt;left&lt;/code&gt; 및 &lt;code&gt;right&lt;/code&gt; 문서를 주변으로 사용하고 구분자 문서 &lt;code&gt;separator&lt;/code&gt; 를 사용하여 &lt;code&gt;docs&lt;/code&gt; 에서 항목을 분리합니다 . 컬렉션의 모든 항목이 간단한 문서 (텍스트 또는 문자열) 인 경우이 함수는 가능한 한 동일한 줄에 입력하려고합니다. 단순하지 않은 경우 적합하지 않은 경우 한 줄에 하나의 항목 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="359c8a3a80dc42f4d09ef45dc62e03c2a4526a01" translate="yes" xml:space="preserve">
          <source>It uses the shortest representation according to algorithm described in &quot;Printing Floating-Point Numbers Quickly and Accurately&quot; in Proceedings of the SIGPLAN '96 Conference on Programming Language Design and Implementation.</source>
          <target state="translated">SIGPLAN '96 프로그래밍 언어 설계 및 구현에 관한 회의 (Conference on Programming Language Design and Implementation)의 &quot;부동 소수점 숫자를 빠르고 정확하게 인쇄&quot;에 설명 된 알고리즘에 따라 가장 짧은 표현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="226d68525abc4cd650686c46c4c3000914e7ba94" translate="yes" xml:space="preserve">
          <source>It will also append an &lt;a href=&quot;io.ansi#reset/0&quot;&gt;&lt;code&gt;IO.ANSI.reset/0&lt;/code&gt;&lt;/a&gt; to the chardata when a conversion is performed. If you don't want this behaviour, use &lt;a href=&quot;#format_fragment/2&quot;&gt;&lt;code&gt;format_fragment/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또한 변환이 수행 될 때 &lt;a href=&quot;io.ansi#reset/0&quot;&gt; &lt;code&gt;IO.ANSI.reset/0&lt;/code&gt; &lt;/a&gt; 을 chardata에 추가합니다 . 이 동작을 원하지 않으면 &lt;a href=&quot;#format_fragment/2&quot;&gt; &lt;code&gt;format_fragment/2&lt;/code&gt; 를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d625ecd25a91e55e3a68933b351320ae362d970" translate="yes" xml:space="preserve">
          <source>It will also unload all &lt;code&gt;:included_applications&lt;/code&gt;. Note that the function does not purge the application modules.</source>
          <target state="translated">또한 모든 &lt;code&gt;:included_applications&lt;/code&gt; 를 언로드합니다 . 이 기능은 응용 프로그램 모듈을 제거하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84aa5327df0b5a9bb286871a09b1bb5335320dee" translate="yes" xml:space="preserve">
          <source>It will raise &lt;a href=&quot;compileerror&quot;&gt;&lt;code&gt;CompileError&lt;/code&gt;&lt;/a&gt; if the struct is not available.</source>
          <target state="translated">그것은 올릴 것이다 &lt;a href=&quot;compileerror&quot;&gt; &lt;code&gt;CompileError&lt;/code&gt; 을&lt;/a&gt; 구조체를 사용할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="4e6ad31346e231231ef72c5f43225ffd3c66f70d" translate="yes" xml:space="preserve">
          <source>It will return the integer with the given unit, according to &lt;a href=&quot;system#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;system#convert_time_unit/3&quot;&gt; &lt;code&gt;System.convert_time_unit/3&lt;/code&gt; &lt;/a&gt; 에 따라 주어진 단위로 정수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a600be691bf00b4e32fb62041ceec8dd63d79b4c" translate="yes" xml:space="preserve">
          <source>It works with improper lists.</source>
          <target state="translated">부적절한 목록과 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6681def299dea9fa997a7ef9b6707d61767cc884" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to implement protocols for all Elixir data types:</source>
          <target state="translated">모든 Elixir 데이터 유형에 대한 프로토콜을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="999db6f61bff83218a31d16026d001272eea2261" translate="yes" xml:space="preserve">
          <source>It's also possible to pass a block to the &lt;a href=&quot;#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; macro. The first example above would be translated to:</source>
          <target state="translated">&lt;a href=&quot;#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt; 매크로에 블록을 전달할 수도 있습니다 . 위의 첫 번째 예는 다음과 같이 번역됩니다.</target>
        </trans-unit>
        <trans-unit id="cd7290dd76f46aa64bdbf468714a16cc5352938b" translate="yes" xml:space="preserve">
          <source>It's important to note that it returns the given &lt;code&gt;item&lt;/code&gt; unchanged. This makes it possible to &quot;spy&quot; on values by inserting an &lt;a href=&quot;io#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt; call almost anywhere in your code, for example, in the middle of a pipeline.</source>
          <target state="translated">주어진 &lt;code&gt;item&lt;/code&gt; 변경하지 않고 반환한다는 점에 유의해야합니다 . 따라서 파이프 라인 중간과 같이 코드의 거의 모든 위치에 &lt;a href=&quot;io#inspect/2&quot;&gt; &lt;code&gt;IO.inspect/2&lt;/code&gt; &lt;/a&gt; 호출 을 삽입하여 값을 &quot;스파이&quot;할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55e677bb7fe63cf491955ddb64be33b944554c67" translate="yes" xml:space="preserve">
          <source>It's often useful to have the AST for such a pipeline as a list of function applications. This function does exactly that:</source>
          <target state="translated">함수 응용 프로그램 목록과 같은 파이프 라인에 AST를 사용하는 것이 유용한 경우가 많습니다. 이 함수는 정확히 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b81b47272fec763e900d18ba6a1da4a3098cd954" translate="yes" xml:space="preserve">
          <source>Italic: on. Not widely supported. Sometimes treated as inverse.</source>
          <target state="translated">기울임 꼴 : 켜짐. 널리 지원되지 않습니다. 때로는 역으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="0418eaaa46e9aed5bab2054a496fec5d581658a8" translate="yes" xml:space="preserve">
          <source>Iterates over the &lt;code&gt;enumerable&lt;/code&gt; and invokes &lt;code&gt;fun&lt;/code&gt; on each element. When an invocation of &lt;code&gt;fun&lt;/code&gt; returns a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;false&lt;/code&gt; is returned. In all other cases &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 요소를 반복하고 각 요소에서 &lt;code&gt;fun&lt;/code&gt; 를 불러옵니다 . &lt;code&gt;fun&lt;/code&gt; 호출이 &lt;code&gt;false&lt;/code&gt; 값 ( false 또는 &lt;code&gt;nil&lt;/code&gt; )을 리턴하면 반복이 즉시 중지되고 &lt;code&gt;false&lt;/code&gt; 가 리턴됩니다. 다른 모든 경우에 &lt;code&gt;true&lt;/code&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="c421120e85b180763b71f08518f3f5d485454d1b" translate="yes" xml:space="preserve">
          <source>Iterates over the &lt;code&gt;enumerable&lt;/code&gt; and invokes &lt;code&gt;fun&lt;/code&gt; on each element. When an invocation of &lt;code&gt;fun&lt;/code&gt; returns a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;true&lt;/code&gt; is returned. In all other cases &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 요소를 반복하고 각 요소에서 &lt;code&gt;fun&lt;/code&gt; 를 불러옵니다 . &lt;code&gt;fun&lt;/code&gt; 호출이 true 값을 리턴하면 ( &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 아님) 반복이 즉시 중지되고 &lt;code&gt;true&lt;/code&gt; 가 리턴됩니다. 다른 모든 경우에는 &lt;code&gt;false&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1bd3db045f018e16696466f5acea3521773d3a53" translate="yes" xml:space="preserve">
          <source>Its fields are:</source>
          <target state="translated">해당 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e084df8c1f3d9f015ea6c2b99c3b679805e965a" translate="yes" xml:space="preserve">
          <source>Joins a list of paths.</source>
          <target state="translated">경로 목록을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="515c03874ab491d886e1d1d7b31a372bcd15aaca" translate="yes" xml:space="preserve">
          <source>Joins the given &lt;code&gt;enumerable&lt;/code&gt; into a binary using &lt;code&gt;joiner&lt;/code&gt; as a separator.</source>
          <target state="translated">주어진 조인 &lt;code&gt;enumerable&lt;/code&gt; 사용하여 이진로 &lt;code&gt;joiner&lt;/code&gt; 구분한다.</target>
        </trans-unit>
        <trans-unit id="f5648a991099408fa47ca83f65efd1693d2a9815" translate="yes" xml:space="preserve">
          <source>Joins two paths.</source>
          <target state="translated">두 경로를 결합합니다.</target>
        </trans-unit>
        <trans-unit id="48d488d22b9c11a34b40d4f43a44d7ca15f5548d" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#runtime_info/0&quot;&gt;&lt;code&gt;runtime_info/0&lt;/code&gt;&lt;/a&gt;, except accepts topic or a list of topics. E.g. topic &lt;code&gt;:applications&lt;/code&gt; will list the applications loaded.</source>
          <target state="translated">&lt;a href=&quot;#runtime_info/0&quot;&gt; &lt;code&gt;runtime_info/0&lt;/code&gt; &lt;/a&gt; 과 마찬가지로 주제 또는 주제 목록을 허용한다는 점만 다릅니다. 예 : 주제 &lt;code&gt;:applications&lt;/code&gt; 는로드 된 애플리케이션 을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="e51db24d55d9857675a12f93a5ceb2ca695225d3" translate="yes" xml:space="preserve">
          <source>Keep in mind &lt;code&gt;@enforce_keys&lt;/code&gt; is a simple compile-time guarantee to aid developers when building structs. It is not enforced on updates and it does not provide any sort of value-validation.</source>
          <target state="translated">마음에 계속 &lt;code&gt;@enforce_keys&lt;/code&gt; 하는 구조체를 만들 때 개발자를 돕기 위해 간단한 컴파일 시간을 보장합니다. 업데이트시 적용되지 않으며 모든 종류의 값 유효성 검사를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47ce96738f59dcbe1277607a7b62401517ee71a9" translate="yes" xml:space="preserve">
          <source>Keep in mind errors in guards do not leak but simply make the guard fail:</source>
          <target state="translated">가드의 오류는 누출되지 않고 단순히 가드를 실패하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="019b3d215759f9f759de0ba07f898008173c2b71" translate="yes" xml:space="preserve">
          <source>Keep in mind reversing the same string twice does not necessarily yield the original string:</source>
          <target state="translated">동일한 문자열을 두 번 뒤집어도 원래 문자열이 생성되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="11a21ef1004b00088384d2386c08e0ddfc5a422c" translate="yes" xml:space="preserve">
          <source>Keep in mind single-quoted and double-quoted representations are not equivalent in Elixir as they are represented by different types:</source>
          <target state="translated">작은 따옴표와 큰 따옴표는 서로 다른 유형으로 표현되므로 Elixir에서는 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31048d175f380df1b961d6b1c2e7ff99e30846d1" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; runs in the caller process, blocking the caller during the evaluation cycle. The caller process can be freed by calling &lt;a href=&quot;iex.helpers#respawn/0&quot;&gt;&lt;code&gt;respawn/0&lt;/code&gt;&lt;/a&gt;, which starts a new IEx evaluation cycle, letting this one go:</source>
          <target state="translated">있다는 사실을 숙지 &lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt; 호출자의 프로세스에서 실행이, 평가주기 동안 호출자를 차단. &lt;a href=&quot;iex.helpers#respawn/0&quot;&gt; &lt;code&gt;respawn/0&lt;/code&gt; &lt;/a&gt; 을 호출하여 호출자 프로세스를 해제 할 수 있습니다. respawn / 0 을 호출 하면 새로운 IEx 평가주기가 시작되어 다음과 같이 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="17dab74a9a2d31002a8d8b98ab8f2a1e7c69175a" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;assert&lt;/code&gt; does not change its semantics based on the expression. In other words, the expression is still required to return a truthy value. For example, the following will fail:</source>
          <target state="translated">있다는 사실을 숙지 &lt;code&gt;assert&lt;/code&gt; 식에 따라 그 의미를 변경하지 않습니다. 다시 말해, 표현은 여전히 ​​진실 된 값을 반환해야합니다. 예를 들어 다음은 실패합니다.</target>
        </trans-unit>
        <trans-unit id="bb7a4e2f437f89496ebbe986e5235a9983fd7b7c" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;filter&lt;/code&gt; is not capable of filtering and transforming an element at the same time. If you would like to do so, consider using &lt;a href=&quot;#flat_map/2&quot;&gt;&lt;code&gt;flat_map/2&lt;/code&gt;&lt;/a&gt;. For example, if you want to convert all strings that represent an integer and discard the invalid one in one pass:</source>
          <target state="translated">있다는 사실에 유의 &lt;code&gt;filter&lt;/code&gt; 필터링과 동시에 요소를 변형시킬 수 없다. 그렇게하려면 &lt;a href=&quot;#flat_map/2&quot;&gt; &lt;code&gt;flat_map/2&lt;/code&gt; &lt;/a&gt; 사용을 고려하십시오 . 예를 들어, 정수를 나타내는 모든 문자열을 변환하고 한 번에 유효하지 않은 문자열을 삭제하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="efcc18a9b0bcb482431019e0321fb20f799d7ca1" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;refute&lt;/code&gt; does not change the semantics of the given expression. In other words, the following will fail:</source>
          <target state="translated">&lt;code&gt;refute&lt;/code&gt; 은 주어진 표현의 의미를 바꾸지 않는다는 것을 명심하십시오 . 다시 말해서, 다음은 실패합니다 :</target>
        </trans-unit>
        <trans-unit id="2711b72cad7dcad995d5896fe00c416e309a1ef1" translate="yes" xml:space="preserve">
          <source>Keep in mind that all tests are included by default, so unless they are excluded first, the &lt;code&gt;include&lt;/code&gt; option has no effect.</source>
          <target state="translated">모든 테스트는 기본적으로 포함되므로 먼저 제외하지 않으면 &lt;code&gt;include&lt;/code&gt; 옵션이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="681ff07e085798bf6140c0e48749d06c2f822db5" translate="yes" xml:space="preserve">
          <source>Keep in mind that you can always invoke the help task to list all available tasks:</source>
          <target state="translated">사용 가능한 모든 작업을 나열하기 위해 항상 도움말 작업을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="725b47d6b2cb8b5dc76a5170928fd278550f1b34" translate="yes" xml:space="preserve">
          <source>Keep in mind that, by convention, whenever the inspected value starts with &lt;code&gt;#&lt;/code&gt;, it is representing a data structure in non-valid Elixir syntax. This means the inspect protocol is not reversible as information may be lost along the way:</source>
          <target state="translated">관례 적으로 검사 된 값이 &lt;code&gt;#&lt;/code&gt; 으로 시작할 때마다 유효하지 않은 Elixir 구문으로 데이터 구조를 나타냅니다. 이는 다음과 같이 정보가 유실 될 수 있으므로 inspect 프로토콜을 되돌릴 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b83288ec921378850bb3f1fa7bae00089f1eb1e1" translate="yes" xml:space="preserve">
          <source>Keep in mind that, in order to know if an element is unique or not, this function needs to store all unique values emitted by the stream. Therefore, if the stream is infinite, the number of elements stored will grow infinitely, never being garbage-collected.</source>
          <target state="translated">요소가 고유한지 여부를 알기 위해이 함수는 스트림에서 방출 된 모든 고유 한 값을 저장해야합니다. 따라서 스트림이 무한한 경우 저장된 요소 수는 무한히 증가하여 가비지 수집되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="84d731972e42a11f20590eec71a88a83f6bff7df" translate="yes" xml:space="preserve">
          <source>Keep in mind that, regardless of how the task created with &lt;code&gt;async_nolink&lt;/code&gt; terminates, the caller's process will always receive a &lt;code&gt;:DOWN&lt;/code&gt; message with the same &lt;code&gt;ref&lt;/code&gt; value that is held by the task struct. If the task terminates normally, the reason in the &lt;code&gt;:DOWN&lt;/code&gt; message will be &lt;code&gt;:normal&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;async_nolink&lt;/code&gt; 로 작성된 태스크가 종료 되는 방식에 관계없이 호출자의 프로세스는 항상 태스크 구조에서 보유한 동일한 &lt;code&gt;ref&lt;/code&gt; 값을 갖는 &lt;code&gt;:DOWN&lt;/code&gt; 메시지를 수신합니다 . 작업이 정상적으로 종료되면 &lt;code&gt;:DOWN&lt;/code&gt; 메시지 의 이유는 &lt;code&gt;:normal&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="43e72793cf5cb6c7b1a0ca2e28a8c6ee6025d9c8" translate="yes" xml:space="preserve">
          <source>Keep in mind the &lt;a href=&quot;#open/0&quot;&gt;&lt;code&gt;open/0&lt;/code&gt;&lt;/a&gt; location may not exist when prying precompiled source code, such as Elixir itself.</source>
          <target state="translated">마음에 계속 &lt;a href=&quot;#open/0&quot;&gt; &lt;code&gt;open/0&lt;/code&gt; &lt;/a&gt; 과 같은 비약 자체로, 미리 컴파일 된 소스 코드를 캐고 때 위치가 존재하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="860e4edfbd6c5d2c7567e3d117fbea1f6f0c0f3d" translate="yes" xml:space="preserve">
          <source>Keep in mind the &lt;a href=&quot;#whereami/1&quot;&gt;&lt;code&gt;whereami/1&lt;/code&gt;&lt;/a&gt; location may not exist when prying precompiled source code, such as Elixir itself.</source>
          <target state="translated">Elixir 자체와 같이 미리 컴파일 된 소스 코드를 &lt;a href=&quot;#whereami/1&quot;&gt; &lt;code&gt;whereami/1&lt;/code&gt; &lt;/a&gt; 때 whereami / 1 위치가 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cf33f85cbcbea5e44750e3785093cd27fc2107f" translate="yes" xml:space="preserve">
          <source>Keep in mind the location may not exist when opening precompiled source code.</source>
          <target state="translated">미리 컴파일 된 소스 코드를 열 때 위치가 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d158165f2fc0a37c72c714056603422cfd15842" translate="yes" xml:space="preserve">
          <source>Keep in mind this issue also shows up when performing &quot;rolling upgrades&quot; with agents. By rolling upgrades we mean the following situation: you wish to deploy a new version of your software by &lt;em&gt;shutting down&lt;/em&gt; some of your nodes and replacing them with nodes running a new version of the software. In this setup, part of your environment will have one version of a given module and the other part another version (the newer one) of the same module.</source>
          <target state="translated">에이전트와의 &quot;롤링 업그레이드&quot;를 수행 할 때도이 문제가 나타납니다. 업그레이드를 롤링한다는 것은 다음과 같은 상황을 의미합니다. 일부 노드 를 &lt;em&gt;종료&lt;/em&gt; 하고 새 버전의 소프트웨어를 실행하는 노드로 교체 하여 새 버전의 소프트웨어를 배포하려고 합니다. 이 설정에서 사용자 환경의 일부에는 특정 모듈의 한 버전이 있고 다른 일부에는 동일한 모듈의 다른 버전이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0156c07b778f553fcac957532e2ebb3cd9d736c" translate="yes" xml:space="preserve">
          <source>Keep the first paragraph of the documentation concise and simple, typically one-line. Tools like &lt;a href=&quot;https://github.com/elixir-lang/ex_doc/&quot;&gt;ExDoc&lt;/a&gt; use the first line to generate a summary.</source>
          <target state="translated">문서의 첫 번째 단락은 간결하고 단순하며 일반적으로 한 줄로 유지하십시오. &lt;a href=&quot;https://github.com/elixir-lang/ex_doc/&quot;&gt;ExDoc&lt;/a&gt; 과 같은 도구 는 첫 번째 줄을 사용하여 요약을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b89ed6c1e4d3aad0e25530664c1434bb7a8e1390" translate="yes" xml:space="preserve">
          <source>Keeping user's formatting</source>
          <target state="translated">사용자의 서식 유지</target>
        </trans-unit>
        <trans-unit id="74808d3df030e992e7b9444241625147986487c1" translate="yes" xml:space="preserve">
          <source>Kernel</source>
          <target state="translated">Kernel</target>
        </trans-unit>
        <trans-unit id="b4d54f6ec686d8eb5175caf8d65ba08cfce6e603" translate="yes" xml:space="preserve">
          <source>Kernel functions</source>
          <target state="translated">커널 기능</target>
        </trans-unit>
        <trans-unit id="aeaeca0ac29205e969d2b8226d57305ccdd9354c" translate="yes" xml:space="preserve">
          <source>Kernel.ParallelCompiler</source>
          <target state="translated">Kernel.ParallelCompiler</target>
        </trans-unit>
        <trans-unit id="397b329c326c86881a0889837339130cb1378ece" translate="yes" xml:space="preserve">
          <source>Kernel.SpecialForms</source>
          <target state="translated">Kernel.SpecialForms</target>
        </trans-unit>
        <trans-unit id="c8ca7c123549a6d988a750c2deb07a14cc7d13fe" translate="yes" xml:space="preserve">
          <source>Key and value in each tuple will be binaries and will be percent-unescaped.</source>
          <target state="translated">각 튜플의 키와 값은 이진이며 이스케이프 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa0ccdd4ef791d750570b7806e67eebc94ec0038" translate="yes" xml:space="preserve">
          <source>Key-based access to data structures.</source>
          <target state="translated">데이터 구조에 대한 키 기반 액세스.</target>
        </trans-unit>
        <trans-unit id="156eb45dfef4d621a4d1c63e18132edae922c7ad" translate="yes" xml:space="preserve">
          <source>Key-value pairs in a map do not follow any order (that's why the printed map in the example above has a different order than the map that was created).</source>
          <target state="translated">맵의 키-값 쌍은 순서를 따르지 않습니다. 따라서 위의 예에서 인쇄 된 맵의 순서가 생성 된 맵과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="74018238351de8a4b5f41ef51f98e3f2c94d5837" translate="yes" xml:space="preserve">
          <source>KeyError</source>
          <target state="translated">KeyError</target>
        </trans-unit>
        <trans-unit id="15dcfdc21056a09847eba4ff304e968ed3eb85e6" translate="yes" xml:space="preserve">
          <source>KeyError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">KeyError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9feb5a2ad29c5ac9a472aae0705f0b36f56f288c" translate="yes" xml:space="preserve">
          <source>Keys and values can be any term that implements the &lt;a href=&quot;string.chars&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol with the exception of lists, which are explicitly forbidden.</source>
          <target state="translated">키와 값 은 명시 적으로 금지 된 목록을 제외 하고 &lt;a href=&quot;string.chars&quot;&gt; &lt;code&gt;String.Chars&lt;/code&gt; &lt;/a&gt; 프로토콜 을 구현하는 모든 용어 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c871f27e8a5b87eb6c4a04f8a42a4f6e2ea2d87a" translate="yes" xml:space="preserve">
          <source>Keys are ordered, as specified by the developer.</source>
          <target state="translated">개발자가 지정한대로 키가 주문됩니다.</target>
        </trans-unit>
        <trans-unit id="405b7423934af77dcf3ba5a20687064207764857" translate="yes" xml:space="preserve">
          <source>Keys can be given more than once.</source>
          <target state="translated">키는 두 번 이상 주어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c61607fe5f12600b764431ebe5f8131aa4311b82" translate="yes" xml:space="preserve">
          <source>Keys for which there are no entries in &lt;code&gt;map&lt;/code&gt; are ignored.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 에 항목이없는 키 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4694e757bfed2949bf57d46a766c250bec95d827" translate="yes" xml:space="preserve">
          <source>Keys for which there are no entries in the keyword list are ignored.</source>
          <target state="translated">키워드 목록에 항목이없는 키는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5718a5ffdcdd81ef356ce973873d2a2560146789" translate="yes" xml:space="preserve">
          <source>Keys in maps can be accessed through some of the functions in this module (such as &lt;a href=&quot;map#get/3&quot;&gt;&lt;code&gt;Map.get/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;map#fetch/2&quot;&gt;&lt;code&gt;Map.fetch/2&lt;/code&gt;&lt;/a&gt;) or through the &lt;code&gt;map[]&lt;/code&gt; syntax provided by the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">맵의 키는이 모듈의 일부 기능 (예 : &lt;a href=&quot;map#get/3&quot;&gt; &lt;code&gt;Map.get/3&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;map#fetch/2&quot;&gt; &lt;code&gt;Map.fetch/2&lt;/code&gt; &lt;/a&gt; ) 또는 &lt;a href=&quot;access&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 모듈에서 제공 하는 &lt;code&gt;map[]&lt;/code&gt; 구문을 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b26620768b7c3d13232d03fbd0fd86edae1e9816" translate="yes" xml:space="preserve">
          <source>Keys in the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; that don't exist in the struct are automatically discarded. Note that keys must be atoms, as only atoms are allowed when defining a struct.</source>
          <target state="translated">구조체에 존재하지 않는 &lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; 의&lt;/a&gt; 키 는 자동으로 삭제됩니다. 구조체를 정의 할 때 원자 만 허용되므로 키는 원자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="36720d74567b83e682047245f1678cc00bda2c58" translate="yes" xml:space="preserve">
          <source>Keys must be atoms.</source>
          <target state="translated">키는 원자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="b946356405330b9605587c00c959f1283c7ebe0c" translate="yes" xml:space="preserve">
          <source>Keys must be atoms. Keys with &lt;code&gt;nil&lt;/code&gt; value are discarded, boolean values are converted to &lt;code&gt;--key&lt;/code&gt; or &lt;code&gt;--no-key&lt;/code&gt; (if the value is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, respectively), and all other values are converted using &lt;a href=&quot;kernel#to_string/1&quot;&gt;&lt;code&gt;Kernel.to_string/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">키는 원자 여야합니다. &lt;code&gt;nil&lt;/code&gt; 값이있는 키 는 버리고 부울 값은 &lt;code&gt;--key&lt;/code&gt; 또는 &lt;code&gt;--no-key&lt;/code&gt; ( 각각 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 인 경우)로 변환되며 다른 모든 값은 &lt;a href=&quot;kernel#to_string/1&quot;&gt; &lt;code&gt;Kernel.to_string/1&lt;/code&gt; 을&lt;/a&gt; 사용하여 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="a3926e039fd753c472f6e172496fda0574369261" translate="yes" xml:space="preserve">
          <source>Keyword</source>
          <target state="translated">Keyword</target>
        </trans-unit>
        <trans-unit id="7c134e1191dc5c44edbda73b442ec456eb6a71ed" translate="yes" xml:space="preserve">
          <source>Keyword lists</source>
          <target state="translated">키워드 목록</target>
        </trans-unit>
        <trans-unit id="018e651a39aa7ad2ac64ac5eb40095fd4e7a830c" translate="yes" xml:space="preserve">
          <source>Keyword lists and maps</source>
          <target state="translated">키워드 목록 및지도</target>
        </trans-unit>
        <trans-unit id="392d9a31ec7b8f0bdc87d00f031b9e9bb8a73cb6" translate="yes" xml:space="preserve">
          <source>Keyword lists are always deep merged.</source>
          <target state="translated">키워드 목록은 항상 깊이 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="4a8ca5bd3ccea7e0c7d15c67c55d6d098576d862" translate="yes" xml:space="preserve">
          <source>Keyword lists are always deep-merged.</source>
          <target state="translated">키워드 목록은 항상 깊이 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="ac0300b9a6363d2ecf2708a6271a27720466a909" translate="yes" xml:space="preserve">
          <source>Keyword lists are important because they have three special characteristics:</source>
          <target state="translated">키워드 목록은 세 가지 특수한 특성이 있으므로 중요합니다.</target>
        </trans-unit>
        <trans-unit id="f46ce1d1d7d871768a2c62a23f7074163ee126aa" translate="yes" xml:space="preserve">
          <source>Keyword lists play an important role in the language and are quite common in many functions and macros. We will explore them a bit more in a future chapter. Now it is time to talk about &amp;ldquo;Binaries, strings, and char lists&amp;rdquo;.</source>
          <target state="translated">키워드 목록은 언어에서 중요한 역할을하며 많은 기능과 매크로에서 매우 일반적입니다. 다음 장에서 좀 더 자세히 살펴볼 것입니다. 이제 &quot;바이너리, 문자열 및 문자 목록&quot;에 대해 이야기 할 차례입니다.</target>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="1ceb47d1e9d15d89ef0224d7d1b562dcf30b3896" translate="yes" xml:space="preserve">
          <source>Keywords as last arguments</source>
          <target state="translated">마지막 인수 인 키워드</target>
        </trans-unit>
        <trans-unit id="c9a539f3ad19c8470b65f3028d300a7bb73e217a" translate="yes" xml:space="preserve">
          <source>Keywords in Elixir are a list of tuples of two elements where the first element is an atom. Using the base constructs, they would be represented as:</source>
          <target state="translated">Elixir의 키워드는 첫 번째 요소가 원자 인 두 요소의 튜플 목록입니다. 기본 구성을 사용하면 다음과 같이 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2843be90e040c2ace2b060340b9db40c6dbf4a3" translate="yes" xml:space="preserve">
          <source>Known tags</source>
          <target state="translated">알려진 태그</target>
        </trans-unit>
        <trans-unit id="9e805fe1256b3cb3351f4f100e6b23dfaed4c00e" translate="yes" xml:space="preserve">
          <source>Last time we fixed the race condition by replacing the asynchronous operation, a &lt;code&gt;cast&lt;/code&gt;, by a &lt;code&gt;call&lt;/code&gt;, which is synchronous. Unfortunately, the &lt;code&gt;handle_info/2&lt;/code&gt; callback we are using to receive the &lt;code&gt;:DOWN&lt;/code&gt; message and delete the entry from the ETS table does not have a synchronous equivalent. This time, we need to find a way to guarantee the registry has processed the &lt;code&gt;:DOWN&lt;/code&gt; notification sent when the bucket process terminated.</source>
          <target state="translated">지난번에 우리는 비동기 작업 인 &lt;code&gt;cast&lt;/code&gt; 를 &lt;code&gt;call&lt;/code&gt; 인 call 으로 대체하여 경쟁 조건을 수정했습니다 . 불행히도 &lt;code&gt;:DOWN&lt;/code&gt; 메시지 를 수신 하고 ETS 테이블에서 항목을 삭제하는 데 사용 하는 &lt;code&gt;handle_info/2&lt;/code&gt; 콜백 에는 동기 항목이 없습니다. 이번에 는 버킷 프로세스가 종료 될 때 전송 된 &lt;code&gt;:DOWN&lt;/code&gt; 알림 이 레지스트리에서 처리되도록 보장 할 방법을 찾아야합니다 .</target>
        </trans-unit>
        <trans-unit id="75acd19542cbb9fa88cdabbe078724acb812d8b1" translate="yes" xml:space="preserve">
          <source>Later on we will learn how to compile Elixir code (in &lt;a href=&quot;modules-and-functions&quot;&gt;Chapter 8&lt;/a&gt;) and how to use the Mix build tool (in the &lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix &amp;amp; OTP guide&lt;/a&gt;). For now, let&amp;rsquo;s move on to &lt;a href=&quot;basic-types&quot;&gt;Chapter 2&lt;/a&gt;.</source>
          <target state="translated">나중에 Elixir 코드를 컴파일하는 방법 ( &lt;a href=&quot;modules-and-functions&quot;&gt;8 장&lt;/a&gt; )과 Mix 빌드 도구를 사용하는 방법 ( &lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix &amp;amp; OTP 안내서&lt;/a&gt; )을 배우게됩니다 . 지금은 &lt;a href=&quot;basic-types&quot;&gt;2 장&lt;/a&gt; 으로 넘어 갑시다 .</target>
        </trans-unit>
        <trans-unit id="dec3727f52253a21a625cc6c295ee24dda78903b" translate="yes" xml:space="preserve">
          <source>Lazily drops elements of the enumerable while the given function returns a truthy value.</source>
          <target state="translated">주어진 함수가 정확한 값을 반환하는 동안 열거 가능한 요소를 느리게 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="ee9b58962b88fa77ea098c1b0d427e9f46c19021" translate="yes" xml:space="preserve">
          <source>Lazily drops the next &lt;code&gt;n&lt;/code&gt; elements from the enumerable.</source>
          <target state="translated">열거 가능한 다음 &lt;code&gt;n&lt;/code&gt; 요소를 느리게 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="69ade1dc23ccb5f3b64347640778d1f4fe8c44ae" translate="yes" xml:space="preserve">
          <source>Lazily intersperses &lt;code&gt;intersperse_element&lt;/code&gt; between each element of the enumeration.</source>
          <target state="translated">열거의 각 요소 사이에 &lt;code&gt;intersperse_element&lt;/code&gt; 가 느리게 산재 합니다.</target>
        </trans-unit>
        <trans-unit id="fb2c9b6a976811f032d7cbfe8165bb5865150558" translate="yes" xml:space="preserve">
          <source>Lazily returns and removes all values associated with &lt;code&gt;key&lt;/code&gt; in the keyword list.</source>
          <target state="translated">지연은 키워드 목록에서 &lt;code&gt;key&lt;/code&gt; 와 관련된 모든 값을 반환하고 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="b61c3c17ee3d10d7647d9803c70ba26ee27244c1" translate="yes" xml:space="preserve">
          <source>Lazily returns and removes the value associated with &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">게으르게 반환과 관련된 값 제거 &lt;code&gt;key&lt;/code&gt; 의 &lt;code&gt;map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e92baedbf908cf61336dc397f7fe80981871f17" translate="yes" xml:space="preserve">
          <source>Lazily takes elements of the enumerable while the given function returns a truthy value.</source>
          <target state="translated">Lazily는 열거 가능한 요소를 취하는 반면 주어진 함수는 진실한 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="450194d4d3b114b2c73dd825ab3cd48712daf267" translate="yes" xml:space="preserve">
          <source>Lazily takes the next &lt;code&gt;count&lt;/code&gt; elements from the enumerable and stops enumeration.</source>
          <target state="translated">Lazily는 열거 가능한 다음 &lt;code&gt;count&lt;/code&gt; 요소를 가져와 열거를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="9fa3a1af379a945e27159d6cbd53b6758da22a91" translate="yes" xml:space="preserve">
          <source>Leap seconds are not taken into account.</source>
          <target state="translated">윤초는 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">더 알아보기</target>
        </trans-unit>
        <trans-unit id="34ce14772451e311453b61a1ddb8221e562b888f" translate="yes" xml:space="preserve">
          <source>Left to right</source>
          <target state="translated">왼쪽에서 오른쪽으로</target>
        </trans-unit>
        <trans-unit id="efe84e15d94659b1eca2695c2253c5d3775e58ca" translate="yes" xml:space="preserve">
          <source>Left to right arrow</source>
          <target state="translated">왼쪽에서 오른쪽 화살표</target>
        </trans-unit>
        <trans-unit id="e68d562699894469c473720b475220fbf042128a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s also add a test to &lt;code&gt;test/kv/bucket_test.exs&lt;/code&gt; that guarantees the bucket is temporary:</source>
          <target state="translated">버킷이 일시적임을 보장하는 &lt;code&gt;test/kv/bucket_test.exs&lt;/code&gt; 에 테스트를 추가해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="404b4b3a784b443893ff8bf31f1dd037577b8b2e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s break that code apart a bit:</source>
          <target state="translated">그 코드를 조금씩 나누자 :</target>
        </trans-unit>
        <trans-unit id="4729229379e49f59080304c7286d1586582b445a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change &lt;code&gt;start/2&lt;/code&gt; once again, to add a supervisor to our tree:</source>
          <target state="translated">트리에 수퍼바이저를 추가하기 위해 &lt;code&gt;start/2&lt;/code&gt; 를 다시 한 번 변경하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="1a65af3d4df3dd7789d08b039fbd9ffd187026b1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change the &lt;code&gt;KV.Registry&lt;/code&gt; to use ETS tables. The first change is to modify our registry to require a name argument, we will use it to name the ETS table and the registry process itself. ETS names and process names are stored in different locations, so there is no chance of conflicts.</source>
          <target state="translated">ETS 테이블을 사용 하도록 &lt;code&gt;KV.Registry&lt;/code&gt; 를 변경하십시오 . 첫 번째 변경은 레지스트리를 수정하여 이름 인수를 요구하는 것입니다.이를 사용하여 ETS 테이블과 레지스트리 프로세스의 이름을 지정합니다. ETS 이름과 프로세스 이름은 다른 위치에 저장되므로 충돌 가능성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e05a0ba8c59d0c8c376685e9addab95d169eccc" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s check each case, one by one.</source>
          <target state="translated">각 사례를 하나씩 확인합시다.</target>
        </trans-unit>
        <trans-unit id="c27f60b2e4915c4a82ea29d51d011f01772e3dd9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a new Mix project. We are going to creatively name it &lt;code&gt;kv_umbrella&lt;/code&gt;, and this new project will have both the existing &lt;code&gt;kv&lt;/code&gt; application and the new &lt;code&gt;kv_server&lt;/code&gt; application inside. The directory structure will look like this:</source>
          <target state="translated">새로운 믹스 프로젝트를 만들어 봅시다. 창의적으로 이름을 &lt;code&gt;kv_umbrella&lt;/code&gt; 로 지정 하고이 새 프로젝트에는 기존 &lt;code&gt;kv&lt;/code&gt; 애플리케이션과 새로운 &lt;code&gt;kv_server&lt;/code&gt; 애플리케이션이 모두 포함됩니다. 디렉토리 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b9686ac5cd9d110e2280341ca7651f1e7a2c3a8f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create our command parser at &lt;code&gt;lib/kv_server/command.ex&lt;/code&gt; and start with the doctest:</source>
          <target state="translated">&lt;code&gt;lib/kv_server/command.ex&lt;/code&gt; 에 명령 파서를 만들고 doctest로 시작 합시다 :</target>
        </trans-unit>
        <trans-unit id="57da67e011a89dbbfb6c22ba016b496c2bf15d61" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create our first project by invoking &lt;code&gt;mix new&lt;/code&gt; from the command line. We&amp;rsquo;ll pass the project name as the argument (&lt;code&gt;kv&lt;/code&gt;, in this case), and tell Mix that our main module should be the all-uppercase &lt;code&gt;KV&lt;/code&gt;, instead of the default, which would have been &lt;code&gt;Kv&lt;/code&gt;:</source>
          <target state="translated">커맨드 라인에서 &lt;code&gt;mix new&lt;/code&gt; 를 호출하여 첫 ​​번째 프로젝트를 만들어 봅시다 . 우리는 (인수로 프로젝트 이름을 전달합니다 &lt;code&gt;kv&lt;/code&gt; 이 경우), 우리의 주요 모듈은 모두 대문자로해야한다는 믹스에게 &lt;code&gt;KV&lt;/code&gt; 대신했을 기본,의, &lt;code&gt;Kv&lt;/code&gt; 값을 :</target>
        </trans-unit>
        <trans-unit id="44ccaac6800d7e69a627f543507cef6aaa36f75a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s define a module named &lt;code&gt;Hello&lt;/code&gt; in this shell:</source>
          <target state="translated">이 셸에서 &lt;code&gt;Hello&lt;/code&gt; 라는 모듈을 정의 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="78d3183a361ff888bc82b3eb6a4eacbf2fa2a5c0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do so by creating a &amp;ldquo;bogus&amp;rdquo; bucket, which is a synchronous request, after &lt;code&gt;Agent.stop/2&lt;/code&gt; in both tests:</source>
          <target state="translated">두 테스트에서 &lt;code&gt;Agent.stop/2&lt;/code&gt; 이후에 동기 요청 인 &quot; 보그 &quot;버킷을 만들어서 그렇게하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="52cc88c9ff893fa670f476f83f7e11b188b0c8fb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do this.</source>
          <target state="translated">이렇게하자.</target>
        </trans-unit>
        <trans-unit id="87f2c21bc94f91beaecdd70cb4c1e04e5acba348" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s first play with monitors by starting a new console with &lt;code&gt;iex -S mix&lt;/code&gt;:</source>
          <target state="translated">먼저 &lt;code&gt;iex -S mix&lt;/code&gt; 로 새 콘솔을 시작하여 모니터를 가지고 놀자 :</target>
        </trans-unit>
        <trans-unit id="3cfccd6e33d5a510641ee1fe031db4c15efbf06a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get started!</source>
          <target state="translated">시작하자!</target>
        </trans-unit>
        <trans-unit id="66bbb9d93128da50d0a5fd0f342b723836429324" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give it a try by running &lt;code&gt;iex kv.exs&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;iex kv.exs&lt;/code&gt; 를 실행하여 시도해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="5839691ae3f96ef964d421fd3acb9f807e8f4ab6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give it a try. Open up &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt;, and let&amp;rsquo;s change the supervisor in the &lt;code&gt;start/2&lt;/code&gt; function to the following:</source>
          <target state="translated">한번 해보자. &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt; 를 열고 &lt;code&gt;start/2&lt;/code&gt; 함수 의 수퍼바이저를 다음과 같이 변경하십시오 :</target>
        </trans-unit>
        <trans-unit id="baa34105a5b53a50e8c2b4ac1b991daa285cda4f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give the updated supervisor a try inside &lt;code&gt;iex -S mix&lt;/code&gt;:</source>
          <target state="translated">업데이트 된 감독자에게 &lt;code&gt;iex -S mix&lt;/code&gt; 내부를 시험해 보도록하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="56cfa20ba11b54abba073399ca2cc31a1beb82f3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back to the &lt;code&gt;Math&lt;/code&gt; module defined in the previous chapters, add some documentation and save it to the &lt;code&gt;math.ex&lt;/code&gt; file:</source>
          <target state="translated">이전 장에서 정의한 &lt;code&gt;Math&lt;/code&gt; 모듈 로 돌아가서 문서를 추가하고 &lt;code&gt;math.ex&lt;/code&gt; 파일에 저장해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="3e193874a827cfe3989b47093b1f35bf1d889de9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s implement the integration test in &lt;code&gt;test/kv_server_test.exs&lt;/code&gt; as shown below:</source>
          <target state="translated">아래와 같이 &lt;code&gt;test/kv_server_test.exs&lt;/code&gt; 에 통합 테스트를 구현하자 :</target>
        </trans-unit>
        <trans-unit id="f3d61bf295e16bbbb18d9e86a778638333f98c0d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s implement those steps. Move to the &lt;code&gt;apps/kv_server&lt;/code&gt; application, open up &lt;code&gt;lib/kv_server.ex&lt;/code&gt;, and add the following functions:</source>
          <target state="translated">이러한 단계를 구현해 봅시다. &lt;code&gt;apps/kv_server&lt;/code&gt; 애플리케이션으로 이동하여 &lt;code&gt;lib/kv_server.ex&lt;/code&gt; 를 열고 다음 기능을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="39e760533fa67c3a16cee4f61982aced80e52f83" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s learn how to do that.</source>
          <target state="translated">그렇게하는 방법을 배우자.</target>
        </trans-unit>
        <trans-unit id="cf8ebea7b04a470e898c361b3c01206eb4a8342a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s make another example using streams. Since the &lt;code&gt;IO&lt;/code&gt; module provides streams (that are both &lt;code&gt;Enumerable&lt;/code&gt;s and &lt;code&gt;Collectable&lt;/code&gt;s), an echo terminal that echoes back the upcased version of whatever is typed can be implemented using comprehensions:</source>
          <target state="translated">스트림을 사용하여 다른 예를 만들어 봅시다. &lt;code&gt;IO&lt;/code&gt; 모듈은 스트림 ( &lt;code&gt;Enumerable&lt;/code&gt; 및 &lt;code&gt;Collectable&lt;/code&gt; 모두)을 제공 하므로, 입력 된 내용의 백업 버전을 다시 에코하는 에코 터미널은 다음과 같이 이해를 사용하여 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed8179b6236a6127fea762c1dc4859e7ff9ad41e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move inside the apps directory and start building &lt;code&gt;kv_server&lt;/code&gt;. This time, we are going to pass the &lt;code&gt;--sup&lt;/code&gt; flag, which will tell Mix to generate a supervision tree automatically for us, instead of building one manually as we did in previous chapters:</source>
          <target state="translated">apps 디렉토리 내부로 이동하여 &lt;code&gt;kv_server&lt;/code&gt; 빌드를 시작 하십시오 . 이번에는 &lt;code&gt;--sup&lt;/code&gt; 플래그 를 전달합니다 .이 플래그는 Mix에게 이전 장 에서처럼 수동으로 트리를 작성하는 대신 자동으로 감독 트리를 생성하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="9abc4b0404a0faf043a413238fb9c0b85596b7d3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move to the next chapter. We will finally make our system distributed by adding a bucket routing mechanism. We will use this opportunity to also improve our testing chops.</source>
          <target state="translated">다음 장으로 넘어 갑시다. 마지막으로 버킷 라우팅 메커니즘을 추가하여 시스템을 배포합니다. 우리는이 기회를 이용하여 테스트 절단을 개선 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="907c5a40686f1ad77133ab1fb7ed4fb9044e980b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now define a release for &lt;code&gt;:bar&lt;/code&gt;. One first step could be to define a release exactly like &lt;code&gt;foo&lt;/code&gt; inside &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;:bar&lt;/code&gt; 에 대한 릴리즈를 정의 해 봅시다 . 첫 번째 단계는 &lt;code&gt;mix.exs&lt;/code&gt; 내부에서 &lt;code&gt;foo&lt;/code&gt; 와 똑같은 릴리스를 정의하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="5a2917bda9d2d2ade9ad2c9418f4b2b9f81e1083" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now see how we can use the power of recursion to sum a list of numbers:</source>
          <target state="translated">이제 재귀의 힘을 사용하여 숫자 목록을 합칠 수있는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="df2a11fdb0c0854864b329de4b39854b42d8a291" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s put it all together and send messages between processes:</source>
          <target state="translated">모든 것을 정리하고 프로세스간에 메시지를 보내 봅시다.</target>
        </trans-unit>
        <trans-unit id="2fe45cc7fb55e4c742c4dc05c2cb987f67c6d233" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what is happening. Whenever we invoke &lt;code&gt;iex -S mix&lt;/code&gt;, it automatically starts our application by calling &lt;code&gt;Application.start(:kv)&lt;/code&gt;, which then invokes the application callback. The application callback job is to start a &lt;strong&gt;supervision tree&lt;/strong&gt;. Right now, we only have a single supervisor, but sometimes a supervisor is also supervised, giving it a shape of a tree. So far, our supervisor has a single child, a &lt;code&gt;KV.Registry&lt;/code&gt;, which is started with name &lt;code&gt;KV.Registry&lt;/code&gt;.</source>
          <target state="translated">무슨 일이 일어나고 있는지 살펴 보자. &lt;code&gt;iex -S mix&lt;/code&gt; 를 호출 할 때마다 &lt;code&gt;Application.start(:kv)&lt;/code&gt; 를 호출하여 애플리케이션을 자동으로 시작한 다음 애플리케이션 콜백을 호출합니다. 응용 프로그램 콜백 작업은 &lt;strong&gt;감독 트리&lt;/strong&gt; 를 시작하는 것 &lt;strong&gt;입니다&lt;/strong&gt; . 지금은 단일 감독자가 있지만 때로는 감독자가 감독되어 나무 모양을 만듭니다. 지금까지 관리자에게는 &lt;code&gt;KV.Registry&lt;/code&gt; 라는 단일 자녀 KV.Registry 가 있으며 이름은 &lt;code&gt;KV.Registry&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="325ed6370b4676504d3b00af4ba0fd26fde98423" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s reimplement the server callbacks to fix the bug and make the test pass. First, we will modify the GenServer state to two dictionaries: one that contains &lt;code&gt;name -&amp;gt; pid&lt;/code&gt; and another that holds &lt;code&gt;ref -&amp;gt; name&lt;/code&gt;. Then we need to monitor the buckets on &lt;code&gt;handle_cast/2&lt;/code&gt; as well as implement a &lt;code&gt;handle_info/2&lt;/code&gt; callback to handle the monitoring messages. The full server callbacks implementation is shown below:</source>
          <target state="translated">서버 콜백을 다시 구현하여 버그를 수정하고 테스트를 통과합시다. 첫째, 우리는이 사전에 GenServer 상태를 수정합니다 : 포함하는 하나의 &lt;code&gt;name -&amp;gt; pid&lt;/code&gt; 및 보관 유지하는 또 다른 &lt;code&gt;ref -&amp;gt; name&lt;/code&gt; . 그런 다음 &lt;code&gt;handle_cast/2&lt;/code&gt; 에서 버킷을 모니터링하고 &lt;code&gt;handle_info/2&lt;/code&gt; 콜백을 구현 하여 모니터링 메시지를 처리해야합니다. 전체 서버 콜백 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5859e594dd7ff75c74328e1ec62ef118e79b5173" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s rewrite the test case to use callbacks:</source>
          <target state="translated">콜백을 사용하도록 테스트 사례를 다시 작성해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="7af0235d132a57562aba639e633d1cb04c26a76e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run the tests once again. This time though, we will pass the &lt;code&gt;--trace&lt;/code&gt; option:</source>
          <target state="translated">테스트를 다시 한 번 실행하겠습니다. 이번에는 &lt;code&gt;--trace&lt;/code&gt; 옵션 을 전달합니다 :</target>
        </trans-unit>
        <trans-unit id="2aced57d244d27459d17d10f2ab48937597ad351" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see in more detail what happens when you request &lt;code&gt;IO.write(pid, binary)&lt;/code&gt;. The &lt;code&gt;IO&lt;/code&gt; module sends a message to the process identified by &lt;code&gt;pid&lt;/code&gt; with the desired operation. A small ad-hoc process can help us see it:</source>
          <target state="translated">&lt;code&gt;IO.write(pid, binary)&lt;/code&gt; 요청시 어떤 일이 발생하는지 자세히 살펴 보겠습니다 . &lt;code&gt;IO&lt;/code&gt; 의 모듈에 의해 식별 프로세스로 메시지를 전송 &lt;code&gt;pid&lt;/code&gt; 원하는 동작과. 작은 임시 프로세스는 다음과 같이 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67af3c48055ca2b3c2d9f546637c104f51f74e74" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see this in practice. Start a console with &lt;code&gt;iex -S mix&lt;/code&gt; and try:</source>
          <target state="translated">실제로 이것을 보자. &lt;code&gt;iex -S mix&lt;/code&gt; 로 콘솔을 시작 하고 시도하십시오 :</target>
        </trans-unit>
        <trans-unit id="7dee2fe998155b6e01d27bc48c7887e983907b48" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s slightly change our children definition (in &lt;code&gt;KV.Supervisor.init/1&lt;/code&gt;) to be a list of tuples instead of a list of atoms:</source>
          <target state="translated">자식 정의 ( &lt;code&gt;KV.Supervisor.init/1&lt;/code&gt; )를 원자 목록 대신 튜플 목록으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="1bd92f7c84f63683d6101c71449ed203a7800ec9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start &lt;code&gt;iex&lt;/code&gt; with the module above:</source>
          <target state="translated">위의 모듈로 &lt;code&gt;iex&lt;/code&gt; 를 시작해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="9d1661fc8a81e848a401464f1c2a605c5da459d3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start a new project using &lt;code&gt;mix new&lt;/code&gt;. This new project will be named &lt;code&gt;kv_umbrella&lt;/code&gt; and we need to pass the &lt;code&gt;--umbrella&lt;/code&gt; option when creating it. Do not create this new project inside the existing &lt;code&gt;kv&lt;/code&gt; project!</source>
          <target state="translated">&lt;code&gt;mix new&lt;/code&gt; 를 사용하여 새 프로젝트를 시작합시다 . 이 새 프로젝트의 이름은 &lt;code&gt;kv_umbrella&lt;/code&gt; 이며 생성시 &lt;code&gt;--umbrella&lt;/code&gt; 옵션 을 전달해야 합니다. 기존 &lt;code&gt;kv&lt;/code&gt; 프로젝트 내에이 새 프로젝트를 작성하지 마십시오 !</target>
        </trans-unit>
        <trans-unit id="9f966b08bc66cb4042c8b3f3f1b9e2153b0cd851" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start by creating a module that defines and imports the &lt;code&gt;test&lt;/code&gt; macro when used:</source>
          <target state="translated">사용될 때 &lt;code&gt;test&lt;/code&gt; 매크로 를 정의하고 가져 오는 모듈을 만들어 봅시다 :</target>
        </trans-unit>
        <trans-unit id="a0fddb1a8907c2cf50e04a25da3983ae6441dda6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with a test that describes how we want the registry to behave if a bucket stops or crashes:</source>
          <target state="translated">버킷이 중지되거나 충돌하는 경우 레지스트리가 작동하는 방식을 설명하는 테스트부터 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="1fa11d581397d95e04f2020a68e066fb3e60d04a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a brief look at those generated files.</source>
          <target state="translated">생성 된 파일을 간단히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="04e68357588d11fea0410465b619814c2039a742" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a deeper look at &lt;code&gt;Enumerable&lt;/code&gt;s and, while we&amp;rsquo;re at it, their lazy counterpart, &lt;code&gt;Stream&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;Enumerable&lt;/code&gt; 을 자세히 살펴보고 , 우리가있는 동안 그들의 게으른 상대방 &lt;code&gt;Stream&lt;/code&gt; 을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="91b289146778a1a9ac545041f63405e023909059" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the supervior for a spin:</source>
          <target state="translated">스핀의 감독자를 보자.</target>
        </trans-unit>
        <trans-unit id="3b01013918cb505bb54dd81a9af06894999c0120" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a test to verify our router works. Create a file named &lt;code&gt;test/kv/router_test.exs&lt;/code&gt; containing:</source>
          <target state="translated">라우터가 작동하는지 테스트 해 봅시다. 다음을 포함하는 &lt;code&gt;test/kv/router_test.exs&lt;/code&gt; 파일을 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa012006b966bf0a6eab57a8968215cebf134379" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write some code!</source>
          <target state="translated">코드를 작성하자!</target>
        </trans-unit>
        <trans-unit id="c67023947ca555b00e6d88ffa6d4701c0c3be370" translate="yes" xml:space="preserve">
          <source>Let's build a stream and then enumerate it:</source>
          <target state="translated">스트림을 만든 다음 열거 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="af13b7ca9a49d1b748a7f4486807d45530939bbd" translate="yes" xml:space="preserve">
          <source>Let's create a document by concatenating two strings with a break between them:</source>
          <target state="translated">두 문자열을 구분하여 연결하여 문서를 작성해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="5d78dfa30452eb74635f4fb43b15b17251e16913" translate="yes" xml:space="preserve">
          <source>Let's explore the basic functions from the &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;&lt;code&gt;:sys&lt;/code&gt; module&lt;/a&gt; used for debugging:</source>
          <target state="translated">디버깅에 사용되는 &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt; &lt;code&gt;:sys&lt;/code&gt; 모듈&lt;/a&gt; 의 기본 기능을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="688ee6c95315db8b18bfec15fee2dfd168073eec" translate="yes" xml:space="preserve">
          <source>Let's fix our macro:</source>
          <target state="translated">매크로를 수정 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="d7fff4c2e7484327d49d843539125f18766ef59b" translate="yes" xml:space="preserve">
          <source>Let's give it a try. First start a new shell:</source>
          <target state="translated">한번 해보자. 먼저 새로운 쉘을 시작하십시오 :</target>
        </trans-unit>
        <trans-unit id="385a594a813b358193b288faec070338a76a46ba" translate="yes" xml:space="preserve">
          <source>Let's look at a quick case study: we want to check that a function argument is an even or odd integer. With pattern matching, this is impossible to do since there are infinite integers, and thus we can't pattern match on the single even/odd numbers. Let's focus on checking for even numbers since checking for odd ones is almost identical.</source>
          <target state="translated">간단한 사례 연구를 살펴 보겠습니다. 함수 인수가 짝수 또는 홀수인지 확인하려고합니다. 패턴 일치를 사용하면 무한 정수가 있으므로 수행 할 수 없으므로 단일 짝수 / 홀수에서 패턴 일치를 수행 할 수 없습니다. 홀수를 확인하는 것은 거의 동일하므로 짝수를 확인하는 데 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="f17d3ddea9ff5b443102e2f1aa7d529504a09b53" translate="yes" xml:space="preserve">
          <source>Let's see a simple example. Imagine that you implement a library that breaks a string in two parts based on the first occurrence of the dash &lt;code&gt;-&lt;/code&gt; character:</source>
          <target state="translated">간단한 예를 보자. 당신이 대시의 첫 번째 항목을 기준으로 두 부분의 문자열 나누기 라이브러리를 구현하는 것이 상상 &lt;code&gt;-&lt;/code&gt; 문자 :</target>
        </trans-unit>
        <trans-unit id="a086f0aa8dc3f13f368da5ddef024d84bd14e45f" translate="yes" xml:space="preserve">
          <source>Let's see an example of a guard used in a function clause:</source>
          <target state="translated">함수 절에 사용 된 가드의 예를 보자.</target>
        </trans-unit>
        <trans-unit id="eb3e603df7a85750e6414b0eb382239bbf870bfb" translate="yes" xml:space="preserve">
          <source>Let's see an example.</source>
          <target state="translated">예를 보자.</target>
        </trans-unit>
        <trans-unit id="2bb9a3671c7cc45e630956b53927eeec08220af2" translate="yes" xml:space="preserve">
          <source>Let's see how we could use those functions for debugging the stack server we defined earlier.</source>
          <target state="translated">앞서 정의한 스택 서버를 디버깅하기 위해 이러한 기능을 어떻게 사용할 수 있는지 살펴 보자.</target>
        </trans-unit>
        <trans-unit id="9944bcda5d8aef46440ac764e0d71869f8b3eb89" translate="yes" xml:space="preserve">
          <source>Let's see some examples. The code below:</source>
          <target state="translated">몇 가지 예를 봅시다. 아래 코드 :</target>
        </trans-unit>
        <trans-unit id="9a9747f9ce9d128c721ed4b062d8c863cdde1877" translate="yes" xml:space="preserve">
          <source>Let's start with a code example and then explore the available callbacks. Imagine we want a GenServer that works like a stack, allowing us to push and pop elements:</source>
          <target state="translated">코드 예제부터 시작하여 사용 가능한 콜백을 살펴 보겠습니다. 스택처럼 작동하여 요소를 푸시 및 팝할 수있는 GenServer를 원한다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="45a0d37d2635e9d8af766d2643fce24860a449d3" translate="yes" xml:space="preserve">
          <source>Let's start with an example:</source>
          <target state="translated">예를 들어 보자.</target>
        </trans-unit>
        <trans-unit id="c498b7be97563d9e009446e491717478748954ec" translate="yes" xml:space="preserve">
          <source>Let's suppose you created your own &lt;a href=&quot;kernel#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; implementation in the module &lt;code&gt;MyMacros&lt;/code&gt;. If you want to invoke it, you need to first explicitly require the &lt;code&gt;MyMacros&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;MyMacros&lt;/code&gt; 모듈에서 고유 한 &lt;a href=&quot;kernel#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt; 구현 을 만들었다 고 가정 해 봅시다 . 호출하려면 먼저 명시 적으로 &lt;code&gt;MyMacros&lt;/code&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="167e9ac5d10b20cb0dda56b181fe66788b49d6e5" translate="yes" xml:space="preserve">
          <source>Let's suppose you want to investigate what is happening with some particular function. By invoking &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; from the function, IEx will allow you to access its binding (variables), verify its lexical information and access the process information. Let's see an example:</source>
          <target state="translated">특정 기능으로 무슨 일이 일어나고 있는지 조사하고 싶다고 가정 해 봅시다. 함수에서 &lt;a href=&quot;iex#pry/0&quot;&gt; &lt;code&gt;IEx.pry/0&lt;/code&gt; &lt;/a&gt; 을 호출하면 IEx 를 사용하여 바인딩 (변수)에 액세스하고 어휘 정보를 확인하고 프로세스 정보에 액세스 할 수 있습니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="810f288f1e4fdf45c23a3b902942dd7960a5c22f" translate="yes" xml:space="preserve">
          <source>Let's understand what the &lt;code&gt;:shutdown&lt;/code&gt; and &lt;code&gt;:restart&lt;/code&gt; options control.</source>
          <target state="translated">&lt;code&gt;:shutdown&lt;/code&gt; 및 &lt;code&gt;:restart&lt;/code&gt; 옵션 이 무엇 을 제어 하는지 이해합시다 .</target>
        </trans-unit>
        <trans-unit id="ed47f098118b3a4908065115144a054c9afe75d6" translate="yes" xml:space="preserve">
          <source>Levels</source>
          <target state="translated">Levels</target>
        </trans-unit>
        <trans-unit id="5ff76884a1b9f933647dc46c0efb08cd23ce4c72" translate="yes" xml:space="preserve">
          <source>Lexical scope</source>
          <target state="translated">어휘 범위</target>
        </trans-unit>
        <trans-unit id="b8100f5ba8bd048a7cf11d116fbbd73130c3c6f5" translate="yes" xml:space="preserve">
          <source>Library</source>
          <target state="translated">Library</target>
        </trans-unit>
        <trans-unit id="b7e01bf49268dbb685a7684daf71674fc58c2f88" translate="yes" xml:space="preserve">
          <source>Library Guidelines</source>
          <target state="translated">도서관 가이드 라인</target>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apache 라이센스, 버전 2.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="8c32d4b808a84de40c883809049bbfd2ca84a901" translate="yes" xml:space="preserve">
          <source>Like with &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list. This is expected on operations such as &lt;a href=&quot;stream#map/2&quot;&gt;&lt;code&gt;Stream.map/2&lt;/code&gt;&lt;/a&gt;. After all, if we want to traverse every element on a stream, the longer the stream, the more elements we need to traverse, and the longer it will take.</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 과 마찬가지로이 모듈의 기능은 선형 시간으로 작동합니다. 즉, 작업을 수행하는 데 걸리는 시간이 목록의 길이와 동일한 속도로 증가합니다. 이것은 &lt;a href=&quot;stream#map/2&quot;&gt; &lt;code&gt;Stream.map/2&lt;/code&gt; &lt;/a&gt; 와 같은 작업에서 예상됩니다 . 결국, 스트림의 모든 요소를 ​​순회하려면 스트림이 길수록 순회해야 할 요소가 많아지고 시간이 오래 걸립니다.</target>
        </trans-unit>
        <trans-unit id="e959a6b5621b2dae8ab30d3d3f44c9b21fd9caf5" translate="yes" xml:space="preserve">
          <source>Limit for when a certain time zone period begins or ends.</source>
          <target state="translated">특정 시간대가 시작되거나 종료되는 시간에 대한 제한.</target>
        </trans-unit>
        <trans-unit id="447809eeca7d1b001940f2b5c2552166d7274fa3" translate="yes" xml:space="preserve">
          <source>Line &lt;code&gt;0&lt;/code&gt; and column &lt;code&gt;0&lt;/code&gt; would mean the top left corner.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 행 과 &lt;code&gt;0&lt;/code&gt; 행 은 왼쪽 상단을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a5f54e0f2d31735fc8356d4c643062d7468cc599" translate="yes" xml:space="preserve">
          <source>Linking</source>
          <target state="translated">Linking</target>
        </trans-unit>
        <trans-unit id="fce9e7983aa4d178575a43583fbc0a75230dea86" translate="yes" xml:space="preserve">
          <source>Linking can also be done manually by calling &lt;code&gt;Process.link/1&lt;/code&gt;. We recommend that you take a look at &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html&quot;&gt;the &lt;code&gt;Process&lt;/code&gt; module&lt;/a&gt; for other functionality provided by processes.</source>
          <target state="translated">&lt;code&gt;Process.link/1&lt;/code&gt; 을 호출하여 링크를 수동으로 수행 할 수도 있습니다 . &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 에서 제공하는 다른 기능 에 대해서는 프로세스 모듈 을 살펴 보는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="5bf3859293f6be21536ffe679146ee6401148648" translate="yes" xml:space="preserve">
          <source>Links are bi-directional. If you link two processes and one of them crashes, the other side will crash too (unless it is trapping exits). A monitor is uni-directional: only the monitoring process will receive notifications about the monitored one. In other words: use links when you want linked crashes, and monitors when you just want to be informed of crashes, exits, and so on.</source>
          <target state="translated">링크는 양방향입니다. 두 프로세스를 연결하고 그 중 하나가 충돌하면 다른 쪽도 종료됩니다 (종료가 트래핑되지 않는 한). 모니터는 단방향입니다. 모니터링 프로세스 만 모니터링되는 모니터에 대한 알림을받습니다. 다시 말해, 링크 된 충돌을 원할 때 링크를 사용하고 충돌, 종료 등을 알리고 자 할 때 모니터링합니다.</target>
        </trans-unit>
        <trans-unit id="b3e008dc1478680d69d7d944ea5e97681e447863" translate="yes" xml:space="preserve">
          <source>Links are bidirectional, which implies that a crash in a bucket will crash the registry. Although we now have the supervisor, which guarantees the registry will be back up and running, crashing the registry still means we lose all data associating bucket names to their respective processes.</source>
          <target state="translated">링크는 양방향이므로 버킷 충돌로 인해 레지스트리가 충돌 할 수 있습니다. 이제 레지스트리가 백업되어 실행되도록 보장하는 감독자가 있지만 레지스트리가 충돌하면 버킷 이름을 해당 프로세스에 연결하는 모든 데이터가 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="010816f5d4211c808577da6a4d3fff9e452bea0e" translate="yes" xml:space="preserve">
          <source>Links are bidirectional. Linked processes can be unlinked by using &lt;a href=&quot;#unlink/1&quot;&gt;&lt;code&gt;unlink/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">링크는 양방향입니다. &lt;a href=&quot;#unlink/1&quot;&gt; &lt;code&gt;unlink/1&lt;/code&gt; &lt;/a&gt; 을 사용하여 링크 된 프로세스를 링크 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="5ea588245c39a0237a816a5a4b5f30b996ac4e47" translate="yes" xml:space="preserve">
          <source>List of allowed expressions</source>
          <target state="translated">허용되는 표현식 목록</target>
        </trans-unit>
        <trans-unit id="e6fd9a7c630dc04fe44f8eceb64283a7b0d97ed2" translate="yes" xml:space="preserve">
          <source>List of supported keys in the keyword list:</source>
          <target state="translated">키워드 목록에서 지원되는 키 목록 :</target>
        </trans-unit>
        <trans-unit id="0b38e76a685c2b2df84a12add2cb4a8302d42bac" translate="yes" xml:space="preserve">
          <source>List operators never modify the existing list. Concatenating to or removing elements from a list returns a new list. We say that Elixir data structures are &lt;em&gt;immutable&lt;/em&gt;. One advantage of immutability is that it leads to clearer code. You can freely pass the data around with the guarantee no one will mutate it in memory - only transform it.</source>
          <target state="translated">목록 연산자는 기존 목록을 수정하지 않습니다. 목록에서 요소를 연결하거나 제거하면 새 목록이 반환됩니다. 우리는 Elixir 데이터 구조가 &lt;em&gt;불변&lt;/em&gt; 이라고 말합니다 . 불변성의 장점 중 하나는 코드가 더 명확해진다는 것입니다. 아무도 메모리에서 데이터를 변경하지 않도록 보장하면서 데이터를 자유롭게 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2eb00e5233b62475b0dc3d5e4e0b3fba8fb4994" translate="yes" xml:space="preserve">
          <source>List.Chars</source>
          <target state="translated">List.Chars</target>
        </trans-unit>
        <trans-unit id="9f9dce20c46fcd1c1728dc56a20927edd518996b" translate="yes" xml:space="preserve">
          <source>List.Chars &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="translated">List.Chars &lt;small&gt;프로토콜&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d03be4130ee5ad90ce04ed9ec5d74c5566fe35d8" translate="yes" xml:space="preserve">
          <source>List.Chars.t (0)</source>
          <target state="translated">List.Chars.t (0)</target>
        </trans-unit>
        <trans-unit id="360565f0168323951cb15fd7ca1982778f9a1e7d" translate="yes" xml:space="preserve">
          <source>List.Chars.to_charlist (1)</source>
          <target state="translated">List.Chars.to_charlist (1)</target>
        </trans-unit>
        <trans-unit id="f37415d7b26ed53d3baccb63f14d10f67a7f2022" translate="yes" xml:space="preserve">
          <source>Listens to a port until the port is available and it gets hold of the socket</source>
          <target state="translated">포트가 사용 가능하고 소켓을 보유 할 때까지 포트를 청취합니다.</target>
        </trans-unit>
        <trans-unit id="30045b3ebb820da7e212b26c8d486fa6438d1b21" translate="yes" xml:space="preserve">
          <source>Lists all dependencies and their status.</source>
          <target state="translated">모든 종속성 및 해당 상태를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="576be6f9e3cd2119a02b300937f31a0bfa25055f" translate="yes" xml:space="preserve">
          <source>Lists all required files.</source>
          <target state="translated">필요한 모든 파일을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="e5fcc5c6ccb03f1f5363ab1add506f548d93b038" translate="yes" xml:space="preserve">
          <source>Lists all tasks and aliases or prints the documentation for a given task or alias.</source>
          <target state="translated">모든 작업 및 별명을 나열하거나 주어진 작업 또는 별명에 대한 문서를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="afec6cb6a10a87d6a4707e28871420191c221295" translate="yes" xml:space="preserve">
          <source>Lists are compared element by element.</source>
          <target state="translated">목록은 요소별로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="ab57d49cbf8304700835035bc3343277d30e43d1" translate="yes" xml:space="preserve">
          <source>Lists are stored in memory as linked lists, meaning that each element in a list holds its value and points to the following element until the end of the list is reached. This means accessing the length of a list is a linear operation: we need to traverse the whole list in order to figure out its size.</source>
          <target state="translated">리스트는 메모리에 링크 된리스트로 저장됩니다. 즉,리스트의 각 요소는 값을 유지하고리스트의 끝에 도달 할 때까지 다음 요소를 가리 킵니다. 이것은리스트의 길이에 접근하는 것이 선형 연산이라는 것을 의미합니다. 우리는 그리스트의 크기를 알아 내기 위해 전체리스트를 순회해야합니다.</target>
        </trans-unit>
        <trans-unit id="c01ea530434a00d0b1bc3bdc3aad101f3c850abd" translate="yes" xml:space="preserve">
          <source>Lists command line arguments.</source>
          <target state="translated">명령 행 인수를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="347e071fbc04592a3c2f0d22435ec182a39831ba" translate="yes" xml:space="preserve">
          <source>Lists in Elixir are effectively linked lists, which means they are internally represented in pairs containing the head and the tail of a list:</source>
          <target state="translated">Elixir의리스트는 효과적으로 링크 된리스트입니다. 즉,리스트의 헤드와 테일을 포함하는 쌍으로 내부적으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1298ac093986653b2f114a6ee0f3b99d3384eec7" translate="yes" xml:space="preserve">
          <source>Lists in Elixir are specified between square brackets:</source>
          <target state="translated">엘릭서의 목록은 대괄호 사이에 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="bca74458ce5102822957d2008558c1693dad3f4a" translate="yes" xml:space="preserve">
          <source>Lists or tuples?</source>
          <target state="translated">목록이나 튜플?</target>
        </trans-unit>
        <trans-unit id="c6c37e3f50d97e7e2b3eda7fd75f9f8b70fa1609" translate="yes" xml:space="preserve">
          <source>Lists, tuples and binaries</source>
          <target state="translated">리스트, 튜플 및 바이너리</target>
        </trans-unit>
        <trans-unit id="d8107e4dcdc428ba751fa94c9e388d0ea60cfc3c" translate="yes" xml:space="preserve">
          <source>Lists, tuples, bitstrings, maps, structs and function calls will be broken into multiple lines if they are followed by a newline in the opening bracket and preceded by a new line in the closing bracket</source>
          <target state="translated">리스트, 튜플, 비트 스트링, 맵, 구조체 및 함수 호출은 여는 괄호 안에 줄 바꿈이 있고 닫는 괄호 안에 줄 바꿈이 있으면 여러 줄로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="91cb6ed4366e6af4c20b2f0bc91cc0d0ee8e284b" translate="yes" xml:space="preserve">
          <source>Loading an application &lt;em&gt;does not&lt;/em&gt; load its modules.</source>
          <target state="translated">응용 프로그램을 로드 &lt;em&gt;해도&lt;/em&gt; 해당 모듈이로드 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d0935c21f18347f738724d92e6a79d6627db8bae" translate="yes" xml:space="preserve">
          <source>Loading applications</source>
          <target state="translated">응용 프로그램 로딩</target>
        </trans-unit>
        <trans-unit id="c59cbcfe056227b16292e8dcaf0f66d26224a608" translate="yes" xml:space="preserve">
          <source>Loading the application does not start it nor load its modules, but it does load its environment.</source>
          <target state="translated">응용 프로그램을로드해도 응용 프로그램이 시작되거나 모듈이로드되지는 않지만 환경은로드됩니다.</target>
        </trans-unit>
        <trans-unit id="44008e484aac635c82b9da39454ca6c5bef5b635" translate="yes" xml:space="preserve">
          <source>Loads all tasks in all code paths.</source>
          <target state="translated">모든 코드 경로의 모든 작업을로드합니다.</target>
        </trans-unit>
        <trans-unit id="1dbb1340da45613eb5e47a83d481795deec9b49b" translate="yes" xml:space="preserve">
          <source>Loads all tasks in the given &lt;code&gt;paths&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;paths&lt;/code&gt; 에있는 모든 작업을로드합니다 .</target>
        </trans-unit>
        <trans-unit id="6a92b205586e28caa29fbe576471eda29c1f626c" translate="yes" xml:space="preserve">
          <source>Loads and persists the given configuration.</source>
          <target state="translated">주어진 구성을로드하고 유지합니다.</target>
        </trans-unit>
        <trans-unit id="d2d1c8786ab6d688901e2d0162afd3bc568f68c4" translate="yes" xml:space="preserve">
          <source>Loads configuration (typically during system boot).</source>
          <target state="translated">구성을로드합니다 (일반적으로 시스템 부팅 중).</target>
        </trans-unit>
        <trans-unit id="d450693304ac525200ed85aa5542f49d5d24954d" translate="yes" xml:space="preserve">
          <source>Loads the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;app&lt;/code&gt; 로드합니다 .</target>
        </trans-unit>
        <trans-unit id="4fd578a7e27c9f4784b221dfd1d03ff6846abec8" translate="yes" xml:space="preserve">
          <source>Loads the given module's BEAM code (and ensures any previous old version was properly purged before).</source>
          <target state="translated">지정된 모듈의 BEAM 코드를로드합니다 (이전의 이전 버전이 올바르게 제거되었는지 확인).</target>
        </trans-unit>
        <trans-unit id="e7dac36771b4d5bc036c611c2f7df6898fe52037" translate="yes" xml:space="preserve">
          <source>Local or imported functions, like &lt;code&gt;is_function/1&lt;/code&gt;, can be captured without the module:</source>
          <target state="translated">&lt;code&gt;is_function/1&lt;/code&gt; 과 같은 로컬 또는 가져온 함수 는 모듈없이 캡처 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="432e91b2470debe1e676502753dc671697ff7218" translate="yes" xml:space="preserve">
          <source>Locates an executable on the system.</source>
          <target state="translated">시스템에서 실행 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="e8a78f610457f7b34429c88bd804c091eff64c5b" translate="yes" xml:space="preserve">
          <source>Log Capture</source>
          <target state="translated">로그 캡처</target>
        </trans-unit>
        <trans-unit id="8432c24573f3f89fad60802fe8eddf1da6315768" translate="yes" xml:space="preserve">
          <source>Logger</source>
          <target state="translated">Logger</target>
        </trans-unit>
        <trans-unit id="e437244b86e77b12e48c1b63d73645f8df74961f" translate="yes" xml:space="preserve">
          <source>Logger allows developers to rewrite log messages provided by OTP applications into a format more compatible with Elixir log messages by providing a translator.</source>
          <target state="translated">로거를 사용하면 개발자가 변환기를 제공하여 OTP 애플리케이션에서 제공 한 로그 메시지를 Elixir 로그 메시지와 호환되는 형식으로 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36bf6b0f69a87a997107e50234a8ec7d11ea5aa8" translate="yes" xml:space="preserve">
          <source>Logger also allows log commands to be removed altogether via the &lt;code&gt;:compile_time_purge_matching&lt;/code&gt; option (see below).</source>
          <target state="translated">로거는 또한 &lt;code&gt;:compile_time_purge_matching&lt;/code&gt; 옵션 (아래 참조)을 통해 로그 명령을 모두 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a326883d3565753f9205b6be5a10ab0cd08e9df" translate="yes" xml:space="preserve">
          <source>Logger.Formatter</source>
          <target state="translated">Logger.Formatter</target>
        </trans-unit>
        <trans-unit id="c6794a4db89c0fa5b4754efb325fa721edd588e7" translate="yes" xml:space="preserve">
          <source>Logger.Translator</source>
          <target state="translated">Logger.Translator</target>
        </trans-unit>
        <trans-unit id="4791cfde57458131db6ad4f6f84effd24dfd10fe" translate="yes" xml:space="preserve">
          <source>Logging is useful for tracking when an event of interest happens in your system. For example, it may be helpful to log whenever a user is deleted.</source>
          <target state="translated">로깅은 시스템에서 관심있는 이벤트가 발생할 때 추적하는 데 유용합니다. 예를 들어, 사용자가 삭제 될 때마다 기록하는 것이 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d82e7897f57da03eff4b9dc774004c8bcf4326e9" translate="yes" xml:space="preserve">
          <source>Logs a debug message.</source>
          <target state="translated">디버그 메시지를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="b4f850d54fddb163d71bfcfbc339485cc6394592" translate="yes" xml:space="preserve">
          <source>Logs a message dynamically.</source>
          <target state="translated">메시지를 동적으로 기록합니다.</target>
        </trans-unit>
        <trans-unit id="06c091f6fe5aa4035d2433eb7a7a7cc257fb6374" translate="yes" xml:space="preserve">
          <source>Logs a message with the given &lt;code&gt;level&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;level&lt;/code&gt; 으로 메시지를 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="f285f97af4e85c90120c456b1bce9cedc8d1aeef" translate="yes" xml:space="preserve">
          <source>Logs a warning message.</source>
          <target state="translated">경고 메시지를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="a25a9314514d900aacc22fbb93de516450433e79" translate="yes" xml:space="preserve">
          <source>Logs an error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162237ff6bb976909c470a90784d4d60906673ae" translate="yes" xml:space="preserve">
          <source>Logs an info message.</source>
          <target state="translated">정보 메시지를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="72bca69a37a582766cb9db5733429c69102e1391" translate="yes" xml:space="preserve">
          <source>Looking up, dispatching and registering are efficient and immediate at the cost of delayed unsubscription. For example, if a process crashes, its keys are automatically removed from the registry but the change may not propagate immediately. This means certain operations may return processes that are already dead. When such may happen, it will be explicitly stated in the function documentation.</source>
          <target state="translated">조회, 발송 및 등록은 지연된 구독 취소 비용으로 효율적이며 즉각적입니다. 예를 들어 프로세스가 중단되면 해당 키가 레지스트리에서 자동으로 제거되지만 변경 내용이 즉시 전파되지 않을 수 있습니다. 이는 특정 작업이 이미 죽은 프로세스를 반환 할 수 있음을 의미합니다. 이러한 상황이 발생하면 기능 설명서에 명시 적으로 언급됩니다.</target>
        </trans-unit>
        <trans-unit id="a76b17c2d110d14324113df51e0e794c11ea854e" translate="yes" xml:space="preserve">
          <source>Loops through recursion</source>
          <target state="translated">재귀를 통한 루프</target>
        </trans-unit>
        <trans-unit id="ce14143dfcbe7563bba16cee9e6c1288ad57742d" translate="yes" xml:space="preserve">
          <source>Low-level function that parses one option.</source>
          <target state="translated">하나의 옵션을 구문 분석하는 저수준 기능.</target>
        </trans-unit>
        <trans-unit id="87c8129c4541d2520131c98fdc81bf241066a22c" translate="yes" xml:space="preserve">
          <source>Luckily for us, &lt;code&gt;use GenServer&lt;/code&gt; already defines a &lt;code&gt;Stack.child_spec/1&lt;/code&gt; exactly like above. If you need to customize the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, you can pass the options directly to &lt;code&gt;use GenServer&lt;/code&gt;:</source>
          <target state="translated">운 좋게도 &lt;code&gt;use GenServer&lt;/code&gt; 이미 위와 같이 &lt;code&gt;Stack.child_spec/1&lt;/code&gt; 을 정의합니다 . &lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 를 사용자 정의해야하는 경우 GenServer 를 &lt;code&gt;use GenServer&lt;/code&gt; 하도록 옵션을 직접 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86ad4dfa78b62650b87ab367b0252fd1102bb2f8" translate="yes" xml:space="preserve">
          <source>Luckily, Elixir comes with the ability to package all of the code we have written so far into a single directory, that also includes Elixir and the Erlang Virtual Machine, that has a simple entry point and supports custom configuration. This feature is called releases and it provides many other benefits, which we will see next.</source>
          <target state="translated">운 좋게도 Elixir는 지금까지 작성한 모든 코드를 하나의 디렉토리에 패키지 할 수있는 기능을 제공합니다. 여기에는 간단한 진입 점이 있고 사용자 정의 구성을 지원하는 Elixir 및 Erlang Virtual Machine도 포함됩니다. 이 기능을 릴리스라고하며 다음에 볼 수있는 많은 다른 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="101e18c9daa819a9267241f7255d5c640b1be10f" translate="yes" xml:space="preserve">
          <source>Luckily, ExUnit ships with a facility to tag tests, allowing us to run specific callbacks or even filter tests altogether based on those tags. We have already used the &lt;code&gt;:capture_log&lt;/code&gt; tag in the previous chapter, which has its semantics specified by ExUnit itself.</source>
          <target state="translated">운 좋게도 ExUnit은 테스트에 태그를 지정하는 기능을 제공하므로 특정 콜백을 실행하거나 해당 태그를 기반으로 테스트를 필터링 할 수도 있습니다. 우리는 이미 이전 장에서 &lt;code&gt;:capture_log&lt;/code&gt; 태그를 사용 했는데, 여기에는 ExUnit 자체에 의해 지정된 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6e05c123ace841510b2c0f0d5c37124c1c1ac0a" translate="yes" xml:space="preserve">
          <source>Luckily, comprehensions also support the &lt;code&gt;:reduce&lt;/code&gt; option, which would allow us to fuse both steps above into a single step:</source>
          <target state="translated">운 좋게도, 이해도 &lt;code&gt;:reduce&lt;/code&gt; 옵션을 지원하므로 위의 두 단계를 모두 단일 단계로 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a0e82f7ee7ffbbb6bfa830a8dab2a14c17f4f0b" translate="yes" xml:space="preserve">
          <source>Luckily, since the server is being supervised by a supervisor, the supervisor will automatically start a new one, with the initial stack of &lt;code&gt;[:hello]&lt;/code&gt;:</source>
          <target state="translated">운 좋게도 서버가 감독자에 의해 감독되고 있기 때문에 감독자는 &lt;code&gt;[:hello]&lt;/code&gt; 의 초기 스택을 사용하여 새 서버를 자동으로 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="660bf78961f4ec6bd8bd8b37a3b0b2769db2b14a" translate="yes" xml:space="preserve">
          <source>Macro</source>
          <target state="translated">Macro</target>
        </trans-unit>
        <trans-unit id="da945cd7b80c7fc643a9901f3920877667af55e2" translate="yes" xml:space="preserve">
          <source>Macro hygiene</source>
          <target state="translated">매크로 위생</target>
        </trans-unit>
        <trans-unit id="7bc6dcd111ca7252229f4855c8539442f853483e" translate="yes" xml:space="preserve">
          <source>Macro-based shortcut for &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;iex#break!/4&quot;&gt; &lt;code&gt;IEx.break!/4&lt;/code&gt; 에&lt;/a&gt; 대한 매크로 기반 단축키 .</target>
        </trans-unit>
        <trans-unit id="56c6a3e6a300260cc21833777ce7d3713e7a1c93" translate="yes" xml:space="preserve">
          <source>Macro.Env</source>
          <target state="translated">Macro.Env</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="2deb7bcc40200f28604560fb6b4cce5afe26789d" translate="yes" xml:space="preserve">
          <source>Macros (local or remote)</source>
          <target state="translated">매크로 (로컬 또는 원격)</target>
        </trans-unit>
        <trans-unit id="17db1c00f2577b6b0146445c282a04ec08ca8847" translate="yes" xml:space="preserve">
          <source>Macros are a powerful construct and Elixir provides many mechanisms to ensure they are used responsibly.</source>
          <target state="translated">매크로는 강력한 구조이며 Elixir는 책임감있게 사용되도록 많은 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="00166ad41fa2f0b9c76fb59ee48021936b95d500" translate="yes" xml:space="preserve">
          <source>Macros are explicit: it is impossible to run a macro without explicitly invoking it. For example, some languages allow developers to completely rewrite functions behind the scenes, often via parse transforms or via some reflection mechanisms. In Elixir, a macro must be explicitly invoked in the caller during compilation time.</source>
          <target state="translated">매크로는 명시 적입니다. 매크로를 명시 적으로 호출하지 않고는 매크로를 실행할 수 없습니다. 예를 들어, 일부 언어에서는 개발자가 종종 구문 분석 또는 일부 반사 메커니즘을 통해 장면 뒤의 함수를 완전히 다시 작성할 수 있습니다. Elixir에서는 컴파일 타임 동안 호출자에서 매크로를 명시 적으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="e631dd92a600a70cff32b8106215cf69b67f9804" translate="yes" xml:space="preserve">
          <source>Macros are hygienic: by default, variables defined inside a macro are not going to affect the user code. Furthermore, function calls and aliases available in the macro context are not going to leak into the user context.</source>
          <target state="translated">매크로는 위생적입니다. 기본적으로 매크로 내에 정의 된 변수는 사용자 코드에 영향을 미치지 않습니다. 또한 매크로 컨텍스트에서 사용 가능한 함수 호출 및 별명은 사용자 컨텍스트로 누출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c5ff8a95ca37f321e50193978d8305c5ccd794f" translate="yes" xml:space="preserve">
          <source>Macros are lexical: it is impossible to inject code or macros globally. In order to use a macro, you need to explicitly &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; the module that defines the macro.</source>
          <target state="translated">매크로는 어휘 적이다 : 코드 나 매크로를 전체적으로 주입하는 것은 불가능하다. 매크로를 사용 하려면 매크로를 정의하는 모듈 을 명시 적으로 &lt;code&gt;require&lt;/code&gt; 하거나 &lt;code&gt;import&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="78cdc77e6f4d92297e11673135be19d518a8e9cb" translate="yes" xml:space="preserve">
          <source>Macros cannot be overridden as functions and vice-versa.</source>
          <target state="translated">매크로는 함수로 무시할 수 없으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="46e2c2440131ab61167e8cad993833b1e1b2ca92" translate="yes" xml:space="preserve">
          <source>Macros constructed out of any combination of the above guards are also valid guards - for example, &lt;a href=&quot;integer#is_even/1&quot;&gt;&lt;code&gt;Integer.is_even/1&lt;/code&gt;&lt;/a&gt;. For more information, see the &quot;Defining custom guard expressions&quot; section shown below.</source>
          <target state="translated">위의 가드 조합으로 구성된 매크로도 유효한 가드입니다 (예 : &lt;a href=&quot;integer#is_even/1&quot;&gt; &lt;code&gt;Integer.is_even/1&lt;/code&gt; )&lt;/a&gt; . 자세한 내용은 아래에 표시된 &quot;사용자 정의 가드 식 정의&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b376d89a5de38d7ee4620680cefcbdb63a1fa6c3" translate="yes" xml:space="preserve">
          <source>Macros in Elixir are defined via &lt;code&gt;defmacro/2&lt;/code&gt;.</source>
          <target state="translated">엘릭서의 매크로는 &lt;code&gt;defmacro/2&lt;/code&gt; 를 통해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b493bc2b5a09e10063b11f52cb46148a75373e5" translate="yes" xml:space="preserve">
          <source>Macros must be defined before its usage.</source>
          <target state="translated">매크로는 사용하기 전에 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="f3a7dd931c836a0537e89bdd7c632c8f1674beb8" translate="yes" xml:space="preserve">
          <source>Macros receive quoted expressions and must return quoted expressions. However, sometimes during the execution of a macro, you may need to work with values and making a distinction between values and quoted expressions will be required.</source>
          <target state="translated">매크로는 따옴표로 묶인 표현식을 수신하고 따옴표로 묶인 표현식을 리턴해야합니다. 그러나 때로는 매크로를 실행하는 동안 값을 사용하여 작업해야하며 값과 따옴표로 구분해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b8816a712333def9173d859165b24e9a1e3080d" translate="yes" xml:space="preserve">
          <source>Macros&amp;rsquo; language is clear: many languages provide syntax shortcuts for &lt;code&gt;quote&lt;/code&gt; and &lt;code&gt;unquote&lt;/code&gt;. In Elixir, we preferred to have them explicitly spelled out, in order to clearly delimit the boundaries of a macro definition and its quoted expressions.</source>
          <target state="translated">매크로의 언어는 명확합니다. 많은 언어가 &lt;code&gt;quote&lt;/code&gt; 및 &lt;code&gt;unquote&lt;/code&gt; 구문 바로 가기를 제공합니다 . 엘릭서에서는 매크로 정의와 인용 된 표현의 경계를 명확하게 구분하기 위해 철자를 명시 적으로 작성하는 것을 선호했습니다.</target>
        </trans-unit>
        <trans-unit id="38c7f5915403fb594e00a22038d846f701385048" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to the &lt;code&gt;server&lt;/code&gt; and waits for its reply.</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; 를 동기식으로 호출 하고 응답을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="d5ca136246f74496fc6eddff8b632654647bdfab" translate="yes" xml:space="preserve">
          <source>Makes the given functions in &lt;code&gt;module&lt;/code&gt; overridable.</source>
          <target state="translated">지정된 함수를 &lt;code&gt;module&lt;/code&gt; 재정의 할 수있게 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1d1d2f57486d38837141355b4d2874a9bddc93c3" translate="yes" xml:space="preserve">
          <source>Makes the given functions in the current module overridable.</source>
          <target state="translated">현재 모듈의 지정된 기능을 무시할 수있게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7fddc4eb9e8f75d21673b2839ad36111f23d7c3e" translate="yes" xml:space="preserve">
          <source>Manually implementing protocols for all types can quickly become repetitive and tedious. In such cases, Elixir provides two options: we can explicitly derive the protocol implementation for our types or automatically implement the protocol for all types. In both cases, we need to implement the protocol for &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="translated">모든 유형의 프로토콜을 수동으로 구현하면 반복적이고 번거로울 수 있습니다. 이러한 경우, Elixir는 두 가지 옵션을 제공합니다 : 우리는 명시 적으로 타입에 대한 프로토콜 구현을 도출하거나 모든 타입에 대한 프로토콜을 자동으로 구현할 수 있습니다. 두 경우 모두 &lt;code&gt;Any&lt;/code&gt; 에 대한 프로토콜을 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d459cd939d93634c990e044cf24d22485f3ceefe" translate="yes" xml:space="preserve">
          <source>Manually it can be started as:</source>
          <target state="translated">다음과 같이 수동으로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0e455aaea813fc20786176867857a89ebbb1b93" translate="yes" xml:space="preserve">
          <source>Many functions come in pairs, such as &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;file#read!/1&quot;&gt;&lt;code&gt;File.read!/1&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; will return a success or failure tuple, whereas &lt;a href=&quot;file#read!/1&quot;&gt;&lt;code&gt;File.read!/1&lt;/code&gt;&lt;/a&gt; will return a plain value or else raise an exception:</source>
          <target state="translated">&lt;a href=&quot;file#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;file#read!/1&quot;&gt; &lt;code&gt;File.read!/1&lt;/code&gt; &lt;/a&gt; 과 같은 많은 함수가 쌍으로 제공됩니다 . &lt;a href=&quot;file#read/1&quot;&gt; &lt;code&gt;File.read/1&lt;/code&gt; &lt;/a&gt; 은 성공 또는 실패 튜플을 반환하지만 &lt;a href=&quot;file#read!/1&quot;&gt; &lt;code&gt;File.read!/1&lt;/code&gt; &lt;/a&gt; 은 일반 값을 반환하거나 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="df33d2958d307f1a594471fa7f01b0b82a2cb968" translate="yes" xml:space="preserve">
          <source>Many functions for maps, which implement the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, are found in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module. Additionally, the following functions for maps are found in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 프로토콜 을 구현하는 많은 맵 기능 이 &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈에 있습니다. 또한 다음과 같은 맵 기능이 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27ff6822734db6cb62b200fe4ffc5f764d2dde53" translate="yes" xml:space="preserve">
          <source>Many functions in the &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; module require a time zone database. By default, it uses the default time zone database returned by &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt;&lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt;&lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt;&lt;/a&gt; which only handles &quot;Etc/UTC&quot; datetimes and returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; for any other time zone.</source>
          <target state="translated">&lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 모듈의 많은 기능에는 시간대 데이터베이스가 필요합니다. 기본적으로 &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt; &lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt; &lt;/a&gt; 에서 반환 한 기본 시간대 데이터베이스를 사용합니다.이 시간대 는 &quot;Etc / UTC&quot;날짜 시간 만 처리 하고 다른 시간대에 대해서는 &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; 를 반환 하는 &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt; &lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="4225573b276c588447af042b7625b6428887292b" translate="yes" xml:space="preserve">
          <source>Many functions in the &lt;code&gt;Stream&lt;/code&gt; module accept any enumerable as an argument and return a stream as a result. It also provides functions for creating streams. For example, &lt;code&gt;Stream.cycle/1&lt;/code&gt; can be used to create a stream that cycles a given enumerable infinitely. Be careful to not call a function like &lt;code&gt;Enum.map/2&lt;/code&gt; on such streams, as they would cycle forever:</source>
          <target state="translated">&lt;code&gt;Stream&lt;/code&gt; 모듈의 많은 함수는 열거 가능한 모든 인수를 인수로 허용하고 결과적으로 스트림을 반환합니다. 또한 스트림 생성 기능도 제공합니다. 예를 들어 &lt;code&gt;Stream.cycle/1&lt;/code&gt; 을 사용하면 지정된 열거 형을 무한정 순환하는 스트림을 만들 수 있습니다. 이러한 스트림에서 &lt;code&gt;Enum.map/2&lt;/code&gt; 와 같은 함수를 호출하지 않도록주의하십시오 .</target>
        </trans-unit>
        <trans-unit id="76056aa626b027c1c23fdbd95796d51843ce0c06" translate="yes" xml:space="preserve">
          <source>Many functions in the standard library follow the pattern of having a counterpart that raises an exception instead of returning tuples to match against. The convention is to create a function (&lt;code&gt;foo&lt;/code&gt;) which returns &lt;code&gt;{:ok, result}&lt;/code&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt; tuples and another function (&lt;code&gt;foo!&lt;/code&gt;, same name but with a trailing &lt;code&gt;!&lt;/code&gt;) that takes the same arguments as &lt;code&gt;foo&lt;/code&gt; but which raises an exception if there&amp;rsquo;s an error. &lt;code&gt;foo!&lt;/code&gt; should return the result (not wrapped in a tuple) if everything goes fine. The &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt; module&lt;/a&gt; is a good example of this convention.</source>
          <target state="translated">표준 라이브러리의 많은 함수는 일치하는 튜플을 반환하는 대신 예외를 발생시키는 대응 요소를 갖는 패턴을 따릅니다. 이 협약은 함수 (만드는 것입니다 &lt;code&gt;foo&lt;/code&gt; 는 ) 어떤 반환 &lt;code&gt;{:ok, result}&lt;/code&gt; 또는 &lt;code&gt;{:error, reason}&lt;/code&gt; 튜플과 다른 기능 ( &lt;code&gt;foo!&lt;/code&gt; , 이름은 같지만 말미 &lt;code&gt;!&lt;/code&gt; )와 같은 인수를 취 &lt;code&gt;foo&lt;/code&gt; 는 하지만, 어떤을 오류가 있으면 예외를 발생시킵니다. &lt;code&gt;foo!&lt;/code&gt; 모든 것이 잘되면 결과를 반환해야합니다 (튜플에 싸이 지 않음). &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt; &lt;code&gt;File&lt;/code&gt; 모듈은&lt;/a&gt; 이 규칙의 좋은 예입니다.</target>
        </trans-unit>
        <trans-unit id="3703d2917265895ef0ac89964db0000551fe6a21" translate="yes" xml:space="preserve">
          <source>Many functions in this module expect an IO device as an argument. An IO device must be a PID or an atom representing a process. For convenience, Elixir provides &lt;code&gt;:stdio&lt;/code&gt; and &lt;code&gt;:stderr&lt;/code&gt; as shortcuts to Erlang's &lt;code&gt;:standard_io&lt;/code&gt; and &lt;code&gt;:standard_error&lt;/code&gt;.</source>
          <target state="translated">이 모듈의 많은 기능은 IO 장치를 인수로 예상합니다. IO 디바이스는 프로세스를 나타내는 PID 또는 원자 여야합니다. 편의상 Elixir는 &lt;code&gt;:stdio&lt;/code&gt; 및 &lt;code&gt;:stderr&lt;/code&gt; 을 Erlang의 &lt;code&gt;:standard_io&lt;/code&gt; 및 &lt;code&gt;:standard_error&lt;/code&gt; 바로 가기로 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="9f2d10ee74f910ee80e0d898322396bd24b9b002" translate="yes" xml:space="preserve">
          <source>Many functions in this module handle what to capture in a regex match via the &lt;code&gt;:capture&lt;/code&gt; option. The supported values are:</source>
          <target state="translated">이 모듈의 많은 함수는 &lt;code&gt;:capture&lt;/code&gt; 옵션을 통해 정규식 일치에서 캡처 할 내용을 처리합니다 . 지원되는 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d206ef06c5b999d69bec023c3ecff2ae2d89ff16" translate="yes" xml:space="preserve">
          <source>Many functions in this module require a time zone database. By default, it uses the default time zone database returned by &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt;&lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt;&lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt;&lt;/a&gt; which only handles &quot;Etc/UTC&quot; datetimes and returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; for any other time zone.</source>
          <target state="translated">이 모듈의 많은 기능에는 시간대 데이터베이스가 필요합니다. 기본적으로 &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt; &lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt; &lt;/a&gt; 에서 반환 한 기본 시간대 데이터베이스를 사용합니다.이 시간대 는 &quot;Etc / UTC&quot;날짜 시간 만 처리 하고 다른 시간대에 대해서는 &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; 를 반환 하는 &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt; &lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt; &lt;/a&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="94392a82be4b05528cead70b8bc5d289f9e18ce9" translate="yes" xml:space="preserve">
          <source>Many functions in this module work with patterns. For example, &lt;a href=&quot;string#split/2&quot;&gt;&lt;code&gt;String.split/2&lt;/code&gt;&lt;/a&gt; can split a string into multiple strings given a pattern. This pattern can be a string, a list of strings or a compiled pattern:</source>
          <target state="translated">이 모듈의 많은 기능은 패턴과 함께 작동합니다. 예를 들어 &lt;a href=&quot;string#split/2&quot;&gt; &lt;code&gt;String.split/2&lt;/code&gt; &lt;/a&gt; 는 패턴이 지정된 문자열을 여러 문자열로 분할 할 수 있습니다. 이 패턴은 문자열, 문자열 목록 또는 컴파일 된 패턴 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90b7eedb69a34d71ed449486b5fd918febba2efc" translate="yes" xml:space="preserve">
          <source>Many modules share the same public API. Take a look at &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;Plug&lt;/a&gt;, which, as its description states, is a &lt;strong&gt;specification&lt;/strong&gt; for composable modules in web applications. Each &lt;em&gt;plug&lt;/em&gt; is a module which &lt;strong&gt;has to&lt;/strong&gt; implement at least two public functions: &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt;.</source>
          <target state="translated">많은 모듈이 동일한 공용 API를 공유합니다. 한 번 봐 가지고 &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;플러그&lt;/a&gt; 의 설명 상태와 같은 것입니다, &lt;strong&gt;사양&lt;/strong&gt; 웹 애플리케이션에서 작성 가능 모듈을. 각 &lt;em&gt;플러그&lt;/em&gt; 는 적어도 두 개의 공용 함수 &lt;code&gt;init/1&lt;/code&gt; 및 &lt;code&gt;call/2&lt;/code&gt; &lt;strong&gt;를&lt;/strong&gt; 구현 해야하는 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="9bad4be1f2158b40250d3557f87cd91435ba7e8c" translate="yes" xml:space="preserve">
          <source>Many of the functions defined in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module internally call this function. This function is also used when the square-brackets access syntax (&lt;code&gt;structure[key]&lt;/code&gt;) is used: the &lt;a href=&quot;#fetch/2&quot;&gt;&lt;code&gt;fetch/2&lt;/code&gt;&lt;/a&gt; callback implemented by the module that defines the &lt;code&gt;structure&lt;/code&gt; struct is invoked and if it returns &lt;code&gt;{:ok, value}&lt;/code&gt; then &lt;code&gt;value&lt;/code&gt; is returned, or if it returns &lt;code&gt;:error&lt;/code&gt; then &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 모듈에 정의 된 많은 기능은 내부적으로이 기능을 호출합니다. 이 함수는 대괄호 액세스 구문 ( &lt;code&gt;structure[key]&lt;/code&gt; )을 사용할 때도 사용됩니다. &lt;code&gt;structure&lt;/code&gt; 구조체 를 정의하는 모듈에 의해 구현 된 &lt;a href=&quot;#fetch/2&quot;&gt; &lt;code&gt;fetch/2&lt;/code&gt; &lt;/a&gt; 콜백 이 호출되고 &lt;code&gt;{:ok, value}&lt;/code&gt; 를 반환하면 &lt;code&gt;value&lt;/code&gt; 는 반환되거나, &lt;code&gt;:error&lt;/code&gt; 를 반환하면 &lt;code&gt;nil&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4c4ca56f0d69fbdc55846e32a022e68f99af15e8" translate="yes" xml:space="preserve">
          <source>Many of the functions in the &lt;code&gt;Macro&lt;/code&gt; module expect an environment. You can read more about these functions in &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html&quot;&gt;the docs for the &lt;code&gt;Macro&lt;/code&gt; module&lt;/a&gt; and learn more about the compilation environment in the &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt;docs for &lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Macro&lt;/code&gt; 모듈 의 많은 기능 은 환경을 기대합니다. &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html&quot;&gt; &lt;code&gt;Macro&lt;/code&gt; &lt;/a&gt; 모듈 용 문서 에서 이러한 함수에 대한 자세한 내용을 읽고 &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt; 용 문서 에서 컴파일 환경에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4faffc8eead5983ad100523dbff786e387103bd2" translate="yes" xml:space="preserve">
          <source>Many of the functions provided for lists, which implement the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, are found in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;enumerable&quot;&gt; &lt;code&gt;Enumerable&lt;/code&gt; &lt;/a&gt; 프로토콜 을 구현하는 목록에 제공된 많은 기능 이 &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈에 있습니다.</target>
        </trans-unit>
        <trans-unit id="be6b19c2b27acff99f70a4437bfc926f0a1ca658" translate="yes" xml:space="preserve">
          <source>Many options can be given by using &lt;code&gt;-&lt;/code&gt; as separator. Order is arbitrary, so the following are all equivalent:</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 를 구분자 로 사용하여 많은 옵션을 제공 할 수 있습니다 . 순서는 임의적이므로 다음은 모두 동일합니다.</target>
        </trans-unit>
        <trans-unit id="76b2e23669853bc8630b7ea68a605ae31ce73aeb" translate="yes" xml:space="preserve">
          <source>Many times, inspecting a structure can be implemented in function of existing entities. For example, here is &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;inspect/2&lt;/code&gt;&lt;/a&gt; implementation:</source>
          <target state="translated">많은 경우에, 구조 검사는 기존 엔티티의 기능으로 구현 될 수 있습니다. 예를 들어, &lt;a href=&quot;mapset&quot;&gt; &lt;code&gt;MapSet&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#inspect/2&quot;&gt; &lt;code&gt;inspect/2&lt;/code&gt; &lt;/a&gt; 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="c31339a8063fd1ca05b6a5ed0e592c82381795d2" translate="yes" xml:space="preserve">
          <source>Map/dictionary as 2nd argument in &lt;a href=&quot;enum#group_by/3&quot;&gt;&lt;code&gt;Enum.group_by/3&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;enum#group_by/3&quot;&gt; &lt;code&gt;Enum.group_by/3&lt;/code&gt; &lt;/a&gt; 에서 두 번째 인수로 사용되는 맵 / 사전</target>
        </trans-unit>
        <trans-unit id="6f349d9040ff8d6dc02443f2129355396470884e" translate="yes" xml:space="preserve">
          <source>MapSet</source>
          <target state="translated">MapSet</target>
        </trans-unit>
        <trans-unit id="80071cd75107cd5c4afdb2571725ea6733631038" translate="yes" xml:space="preserve">
          <source>Maps</source>
          <target state="translated">Maps</target>
        </trans-unit>
        <trans-unit id="faaabe818891c225544bd509dabd125356710ead" translate="yes" xml:space="preserve">
          <source>Maps allow any value as a key.</source>
          <target state="translated">지도는 모든 값을 키로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="d7aa9999474ccd32fc79bec268d52ee73d62bb49" translate="yes" xml:space="preserve">
          <source>Maps also support a specific update syntax to update the value stored under &lt;em&gt;existing&lt;/em&gt; atom keys:</source>
          <target state="translated">맵은 또한 &lt;em&gt;기존&lt;/em&gt; 원자 키에 저장된 값을 업데이트하기 위해 특정 업데이트 구문을 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="23b5fbc085bbfa528c48b36100e97092a1cc1ad4" translate="yes" xml:space="preserve">
          <source>Maps and joins the given &lt;code&gt;enumerable&lt;/code&gt; in one pass.</source>
          <target state="translated">주어진 &lt;code&gt;enumerable&lt;/code&gt; 을 한 번에 매핑 하고 조인합니다 .</target>
        </trans-unit>
        <trans-unit id="5099fc13865ed694619ef238561f1ff1eb21e4ca" translate="yes" xml:space="preserve">
          <source>Maps and keyword lists</source>
          <target state="translated">지도 및 키워드 목록</target>
        </trans-unit>
        <trans-unit id="382a893f2fca3eb55b96aa13fc13acceacd045d1" translate="yes" xml:space="preserve">
          <source>Maps and reduces an &lt;code&gt;enumerable&lt;/code&gt;, flattening the given results (only one level deep).</source>
          <target state="translated">주어진 결과를 평평하게하여 &lt;code&gt;enumerable&lt;/code&gt; 축소 가능을 매핑 하고 줄입니다 (한 수준 만).</target>
        </trans-unit>
        <trans-unit id="f6cdae6c2a90bda1af5114211ccb41e8558a58da" translate="yes" xml:space="preserve">
          <source>Maps are compared by size, then by keys in ascending term order, then by values in key order. In the specific case of maps' key ordering, integers are always considered to be less than floats.</source>
          <target state="translated">맵은 크기, 오름차순으로 키, 키 순서로 값을 기준으로 비교됩니다. 지도 키 순서의 특정 경우 정수는 항상 부동 소수점보다 작은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2c58aeb4eaddeb4b19dfc3e5c22984c273b6c491" translate="yes" xml:space="preserve">
          <source>Maps are the &quot;go to&quot; key-value data structure in Elixir. Maps can be created with the &lt;code&gt;%{}&lt;/code&gt; syntax, and key-value pairs can be expressed as &lt;code&gt;key =&amp;gt; value&lt;/code&gt;:</source>
          <target state="translated">지도는 Elixir에서 &quot;가는&quot;키-값 데이터 구조입니다. &lt;code&gt;%{}&lt;/code&gt; 구문으로 맵을 작성할 수 있으며 키-값 쌍은 &lt;code&gt;key =&amp;gt; value&lt;/code&gt; 로 표현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8f244270ac78647558651f3076ad4902cf12b49" translate="yes" xml:space="preserve">
          <source>Maps can be pattern matched on. When a map is on the left-hand side of a pattern match, it will match if the map on the right-hand side contains the keys on the left-hand side and their values match the ones on the left-hand side. This means that an empty map matches every map.</source>
          <target state="translated">지도를 패턴 일치시킬 수 있습니다. 맵이 패턴 일치의 왼쪽에있는 경우 오른쪽의 맵에 왼쪽의 키가 있고 해당 값이 왼쪽의 키와 일치하면 일치합니다. 즉, 빈지도는 모든지도와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="4bdce2ba7f6c277727a64d1e4440d7e5012f407e" translate="yes" xml:space="preserve">
          <source>Maps do not impose any restriction on the key type: anything can be a key in a map. As a key-value structure, maps do not allow duplicated keys. Keys are compared using the exact-equality operator (&lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;). If colliding keys are defined in a map literal, the last one prevails.</source>
          <target state="translated">지도는 키 유형에 제한을 두지 않습니다. 어떤 것도지도의 키가 될 수 있습니다. 키-값 구조로서 맵은 중복 키를 허용하지 않습니다. 정확한 같음 연산자 ( &lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt; )를 사용하여 키를 비교합니다 . 충돌하는 키가 맵 리터럴에 정의되어 있으면 마지막 키가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="bd2672e5330a5447b3c12c9d7516bbd11a97aa64" translate="yes" xml:space="preserve">
          <source>Maps have the following syntax for updating a key&amp;rsquo;s value:</source>
          <target state="translated">지도에는 키 값을 업데이트하기위한 다음 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b18104f0603d252465f48bc07dbe82afd8a5d572" translate="yes" xml:space="preserve">
          <source>Maps the given &lt;code&gt;fun&lt;/code&gt; over &lt;code&gt;enumerable&lt;/code&gt; and flattens the result.</source>
          <target state="translated">주어진 &lt;code&gt;fun&lt;/code&gt; 를 &lt;code&gt;enumerable&lt;/code&gt; 하게 매핑하고 결과를 평평하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5204e90c54387d7f6b5371b939a57cc337fb682b" translate="yes" xml:space="preserve">
          <source>Maps use the &lt;code&gt;%{...}&lt;/code&gt; notation and each key-value is given by pairs marked with &lt;code&gt;=&amp;gt;&lt;/code&gt;, such as &lt;code&gt;%{&quot;hello&quot; =&amp;gt; 1, 2 =&amp;gt; &quot;world&quot;}&lt;/code&gt;.</source>
          <target state="translated">지도는 &lt;code&gt;%{...}&lt;/code&gt; 표기법을 사용하고 각 키-값은 &lt;code&gt;%{&quot;hello&quot; =&amp;gt; 1, 2 =&amp;gt; &quot;world&quot;}&lt;/code&gt; 와 같이 &lt;code&gt;=&amp;gt;&lt;/code&gt; 로 표시된 쌍으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b30399c385e93b1607671f629e3c17811777473" translate="yes" xml:space="preserve">
          <source>Maps&amp;rsquo; keys do not follow any ordering.</source>
          <target state="translated">지도 키는 순서를 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23e67fceae0d77dd571dd25695fc0499faf1bb77" translate="yes" xml:space="preserve">
          <source>Markdown</source>
          <target state="translated">Markdown</target>
        </trans-unit>
        <trans-unit id="ec2d3f7496eeae736a17fb6cfbbc3d6cec0ede8f" translate="yes" xml:space="preserve">
          <source>Markdown uses backticks (&lt;code&gt;`&lt;/code&gt;) to quote code. Elixir builds on top of that to automatically generate links when module or function names are referenced. For this reason, always use full module names. If you have a module called &lt;code&gt;MyApp.Hello&lt;/code&gt;, always reference it as &lt;code&gt;`MyApp.Hello`&lt;/code&gt; and never as &lt;code&gt;`Hello`&lt;/code&gt;.</source>
          <target state="translated">마크 다운은 백틱 ( &lt;code&gt;`&lt;/code&gt; )을 사용 하여 코드를 인용합니다. Elixir는 모듈 또는 함수 이름이 참조 될 때 자동으로 링크를 생성하기 위해 그 위에 빌드합니다. 이러한 이유로 항상 전체 모듈 이름을 사용하십시오. &lt;code&gt;MyApp.Hello&lt;/code&gt; 라는 모듈이 있다면 항상 &lt;code&gt;`MyApp.Hello`&lt;/code&gt; 로 참조하고 `Hello` 로 참조 하지 &lt;code&gt;`Hello`&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="217f8bccae9fba9687ba7ff03998f906b2857c1d" translate="yes" xml:space="preserve">
          <source>Markers &lt;code&gt;&quot;/&quot;&lt;/code&gt; and &lt;code&gt;&quot;|&quot;&lt;/code&gt; are only for use in custom EEx engines and are not implemented by default. Using them without an appropriate implementation raises &lt;a href=&quot;eex.syntaxerror&quot;&gt;&lt;code&gt;EEx.SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">마커 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;|&quot;&lt;/code&gt; 사용자 지정 EEx 엔진에만 사용되며 기본적으로 구현되지 않습니다. 적절한 구현없이 사용하면 &lt;a href=&quot;eex.syntaxerror&quot;&gt; &lt;code&gt;EEx.SyntaxError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="caae004dd7762602ee13f32c3606f690c674cc52" translate="yes" xml:space="preserve">
          <source>Marks if the system should halt or not at the end of ARGV processing.</source>
          <target state="translated">ARGV 처리가 끝날 때 시스템이 정지해야하는지 여부를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e8df966767fbd3a383c53216799beb4b4564cb74" translate="yes" xml:space="preserve">
          <source>Mastering Markdown</source>
          <target state="translated">마스터 링 마크 다운</target>
        </trans-unit>
        <trans-unit id="158acb8638a5ae524e2b6bf247590e2b87f6ec4d" translate="yes" xml:space="preserve">
          <source>MatchError</source>
          <target state="translated">MatchError</target>
        </trans-unit>
        <trans-unit id="96751a5eacdf747401e9907e7e83faf6f1a03e3b" translate="yes" xml:space="preserve">
          <source>MatchError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">MatchError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="ee2dbd5d6d82d0833069b07e7dd2848d3bf4d83a" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Matches</target>
        </trans-unit>
        <trans-unit id="2d84b42f8474be5f06fc1fe6eb6ae40c8a64822a" translate="yes" xml:space="preserve">
          <source>Matches on or builds a struct.</source>
          <target state="translated">구조체와 일치하거나 구조체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d1c12ec871d541a72434054efa8076c09aed8fb5" translate="yes" xml:space="preserve">
          <source>Matches the given expression against the given clauses.</source>
          <target state="translated">주어진 표현식과 주어진 절을 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="8b76a5c96001ffefea3cc84097a4d45e79f04e10" translate="yes" xml:space="preserve">
          <source>Matches the term on the &lt;code&gt;left&lt;/code&gt; against the regular expression or string on the &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;left&lt;/code&gt; 의 용어를 &lt;code&gt;right&lt;/code&gt; 정규식 또는 문자열과 일치시킵니다 .</target>
        </trans-unit>
        <trans-unit id="213cb6a13e45b535bfa6e1acc183ec880d53557f" translate="yes" xml:space="preserve">
          <source>Matches the value on the right against the pattern on the left.</source>
          <target state="translated">오른쪽의 값을 왼쪽의 패턴과 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="b35bb5e881268b8de9b651fa2e51e3623ab167b7" translate="yes" xml:space="preserve">
          <source>Mechanism for handling behaviours.</source>
          <target state="translated">행동을 다루는 메커니즘.</target>
        </trans-unit>
        <trans-unit id="0f436c24ccfa651b93064f0d2e54084d164dc06e" translate="yes" xml:space="preserve">
          <source>Membership is tested with the match (&lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;) operator.</source>
          <target state="translated">멤버쉽은 일치 ( &lt;a href=&quot;kernel#===/2&quot;&gt; &lt;code&gt;===/2&lt;/code&gt; &lt;/a&gt; ) 연산자 로 테스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="d89ba7d209c7ddc88fd31bf2598cbf585fb0aa81" translate="yes" xml:space="preserve">
          <source>Merges two URIs.</source>
          <target state="translated">두 개의 URI를 병합합니다.</target>
        </trans-unit>
        <trans-unit id="4069e43ecbf8943679ac63e2d6e02de8e6a7137b" translate="yes" xml:space="preserve">
          <source>Merges two configurations.</source>
          <target state="translated">두 가지 구성을 병합합니다.</target>
        </trans-unit>
        <trans-unit id="a9fa5b094d178e27f7bd2a2b568ea8b694678d55" translate="yes" xml:space="preserve">
          <source>Merges two keyword lists into one.</source>
          <target state="translated">두 개의 키워드 목록을 하나로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="acf0cf4f2e4c966874470b9f049a43c211b544d9" translate="yes" xml:space="preserve">
          <source>Merges two maps into one, resolving conflicts through the given &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;fun&lt;/code&gt; 통해 갈등을 해결하면서 두 개의지도를 하나로 합칩니다 .</target>
        </trans-unit>
        <trans-unit id="472d94b64a8f716f1678ee270e1d1c87f01b9840" translate="yes" xml:space="preserve">
          <source>Merges two maps into one.</source>
          <target state="translated">두 개의 맵을 하나로 병합합니다.</target>
        </trans-unit>
        <trans-unit id="243261baef2add3b3b97656268303e291d4fa8b4" translate="yes" xml:space="preserve">
          <source>Message and function APIs</source>
          <target state="translated">메시지 및 함수 API</target>
        </trans-unit>
        <trans-unit id="62a587d636afdda61a08b5027d8d771633fc5216" translate="yes" xml:space="preserve">
          <source>Message format</source>
          <target state="translated">메시지 형식</target>
        </trans-unit>
        <trans-unit id="7d9a0f1c2be58d1d8ee9acd43a53bc9fde228a1e" translate="yes" xml:space="preserve">
          <source>Meta-programming</source>
          <target state="translated">Meta-programming</target>
        </trans-unit>
        <trans-unit id="9ce697e52d7e466c89411bf1535cdf6ff43e22f1" translate="yes" xml:space="preserve">
          <source>Meta-programming guide</source>
          <target state="translated">메타 프로그래밍 가이드</target>
        </trans-unit>
        <trans-unit id="fa22e0676cd79851be85b6434a7e6e08111fa009" translate="yes" xml:space="preserve">
          <source>Meta-programming in Elixir</source>
          <target state="translated">Elixir의 메타 프로그래밍</target>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="7f0cf2cb1796c66f262f9ca3a16a007623f8614c" translate="yes" xml:space="preserve">
          <source>Metadata can have any key. Documentation tools often use metadata to provide more data to readers and to enrich the user experience.</source>
          <target state="translated">메타 데이터는 모든 키를 가질 수 있습니다. 문서화 도구는 종종 메타 데이터를 사용하여 독자에게 더 많은 데이터를 제공하고 사용자 경험을 풍부하게합니다.</target>
        </trans-unit>
        <trans-unit id="ae75c0cef5625d04c957fd4d6945de2e3cb52281" translate="yes" xml:space="preserve">
          <source>Metadata to be sent to the logger can be read and written with the &lt;a href=&quot;logger#metadata/0&quot;&gt;&lt;code&gt;Logger.metadata/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;logger#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt; functions. For example, you can set &lt;code&gt;Logger.metadata([user_id: 13])&lt;/code&gt; to add user_id metadata to the current process. The user can configure the backend to choose which metadata it wants to print and it will replace the &lt;code&gt;$metadata&lt;/code&gt; value.</source>
          <target state="translated">로거로 전송 될 메타 데이터는 &lt;a href=&quot;logger#metadata/0&quot;&gt; &lt;code&gt;Logger.metadata/0&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;logger#metadata/1&quot;&gt; &lt;code&gt;Logger.metadata/1&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 읽고 쓸 수 있습니다 . 예를 들어 &lt;code&gt;Logger.metadata([user_id: 13])&lt;/code&gt; 를 설정하여 user_id 메타 데이터를 현재 프로세스에 추가 할 수 있습니다. 사용자는 인쇄하려는 메타 데이터를 선택하도록 백엔드를 구성 할 수 있으며 &lt;code&gt;$metadata&lt;/code&gt; 값을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="996eccb481568235d0a028deddc16efa49e5113a" translate="yes" xml:space="preserve">
          <source>Microseconds can also be given with a precision, which must be an integer between 0 and 6.</source>
          <target state="translated">마이크로 초는 정밀도로 제공 될 수 있으며 0과 6 사이의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="dfde79a8eeb31b646662fce17bc79e76db2d4ad1" translate="yes" xml:space="preserve">
          <source>Microseconds with stored precision.</source>
          <target state="translated">저장된 정밀도를 가진 마이크로 초.</target>
        </trans-unit>
        <trans-unit id="ae8f2632075078189571124ccbd2fa14d6202a8b" translate="yes" xml:space="preserve">
          <source>Migrating from &lt;code&gt;use Mix.Config&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;use Mix.Config&lt;/code&gt; 에서 마이그레이션</target>
        </trans-unit>
        <trans-unit id="7e092faa3e25342ecf5028acae902f24fdcd4cfc" translate="yes" xml:space="preserve">
          <source>Migrating from Supervisor's :simple_one_for_one</source>
          <target state="translated">관리자의 마이그레이션 : simple_one_for_one</target>
        </trans-unit>
        <trans-unit id="119fff5ad66da150ab8b91c4f195f7205786f58d" translate="yes" xml:space="preserve">
          <source>Missing parent directories are created. Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">누락 된 상위 디렉토리가 작성되었습니다. 성공하면 &lt;code&gt;:ok&lt;/code&gt; , 오류가 발생하면 &lt;code&gt;{:error, reason}&lt;/code&gt; 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="9e60798bf941d9439890dc6ea1e2b3874b037fa8" translate="yes" xml:space="preserve">
          <source>Missing parent directories are not created. Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">누락 된 상위 디렉토리가 작성되지 않았습니다. 성공하면 &lt;code&gt;:ok&lt;/code&gt; , 오류가 발생하면 &lt;code&gt;{:error, reason}&lt;/code&gt; 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="fd7391b6720b809c7c41ed50cf63fdc87dac6b9d" translate="yes" xml:space="preserve">
          <source>Mix</source>
          <target state="translated">Mix</target>
        </trans-unit>
        <trans-unit id="8a48b8da8f54401b98b40a13634225508f5d8cd7" translate="yes" xml:space="preserve">
          <source>Mix Tasks</source>
          <target state="translated">믹스 작업</target>
        </trans-unit>
        <trans-unit id="adf80b3737e1d992babad11068b089417997b0c6" translate="yes" xml:space="preserve">
          <source>Mix also falls back to the &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; and &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variables when storing its contents and configuration.</source>
          <target state="translated">또한 내용과 구성을 저장할 때 믹스는 &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; 및 &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; 환경 변수로 대체 됩니다.</target>
        </trans-unit>
        <trans-unit id="fad17235fd472ad3a611eb5939096f52cba44598" translate="yes" xml:space="preserve">
          <source>Mix also generated a file named &lt;code&gt;test/test_helper.exs&lt;/code&gt; which is responsible for setting up the test framework:</source>
          <target state="translated">또한 Mix는 테스트 프레임 워크 설정을 담당하는 &lt;code&gt;test/test_helper.exs&lt;/code&gt; 라는 파일을 생성했습니다 .</target>
        </trans-unit>
        <trans-unit id="d5f417a1b2c5b2cf642913e1126e746153ac794c" translate="yes" xml:space="preserve">
          <source>Mix also generated the appropriate structure for running our project tests. Mix projects usually follow the convention of having a &lt;code&gt;&amp;lt;filename&amp;gt;_test.exs&lt;/code&gt; file in the &lt;code&gt;test&lt;/code&gt; directory for each file in the &lt;code&gt;lib&lt;/code&gt; directory. For this reason, we can already find a &lt;code&gt;test/kv_test.exs&lt;/code&gt; corresponding to our &lt;code&gt;lib/kv.ex&lt;/code&gt; file. It doesn&amp;rsquo;t do much at this point:</source>
          <target state="translated">또한 Mix는 프로젝트 테스트를 실행하기위한 적절한 구조를 생성했습니다. 믹스 프로젝트는 일반적으로 &lt;code&gt;lib&lt;/code&gt; 디렉토리의 각 파일에 대한 &lt;code&gt;test&lt;/code&gt; 디렉토리에 &lt;code&gt;&amp;lt;filename&amp;gt;_test.exs&lt;/code&gt; 파일이 있다는 규칙을 따릅니다 . 이러한 이유로 &lt;code&gt;lib/kv.ex&lt;/code&gt; 파일에 해당 하는 &lt;code&gt;test/kv_test.exs&lt;/code&gt; 를 이미 찾을 수 있습니다 . 이 시점에서별로하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e787071e1565ddba8a2e537f8771328f0ffb3a18" translate="yes" xml:space="preserve">
          <source>Mix also generates a file at &lt;code&gt;lib/kv.ex&lt;/code&gt; with a module containing exactly one function, called &lt;code&gt;hello&lt;/code&gt;:</source>
          <target state="translated">또한 Mix는 &lt;code&gt;hello&lt;/code&gt; 라는 정확히 하나의 함수를 포함하는 모듈 로 &lt;code&gt;lib/kv.ex&lt;/code&gt; 에 파일을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="71bacf97d94e38a4255175d63dd82250400f8cac" translate="yes" xml:space="preserve">
          <source>Mix also manages your dependencies and integrates nicely with the &lt;a href=&quot;https://hex.pm&quot;&gt;Hex package manager&lt;/a&gt;.</source>
          <target state="translated">Mix는 또한 의존성을 관리하고 &lt;a href=&quot;https://hex.pm&quot;&gt;Hex 패키지 관리자&lt;/a&gt; 와 잘 통합 됩니다.</target>
        </trans-unit>
        <trans-unit id="02fd3a28a69477778e8b16f7b3cce09332f74ae5" translate="yes" xml:space="preserve">
          <source>Mix also supports Git and path dependencies:</source>
          <target state="translated">Mix는 또한 Git과 경로 의존성을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="04bb9bcfa3927d3cae40daaaa838d4ef230a39cd" translate="yes" xml:space="preserve">
          <source>Mix and OTP</source>
          <target state="translated">믹스 앤 OTP</target>
        </trans-unit>
        <trans-unit id="d25cf695ebdb9d0aee542ce2f227391b7ee2bf55" translate="yes" xml:space="preserve">
          <source>Mix and OTP guide</source>
          <target state="translated">믹스 및 OTP 가이드</target>
        </trans-unit>
        <trans-unit id="a2a56ce9bc8efd270013eaafce32886b18ad521f" translate="yes" xml:space="preserve">
          <source>Mix can be used to manage Erlang projects that don't have any Elixir code. To ensure Mix tasks work correctly for an Erlang project, &lt;code&gt;language: :erlang&lt;/code&gt; has to be part of the configuration returned by &lt;code&gt;project/0&lt;/code&gt;. This setting also makes sure Elixir is not added as a dependency to the generated &lt;code&gt;.app&lt;/code&gt; file or to the escript generated with &lt;a href=&quot;mix.tasks.escript.build&quot;&gt;&lt;code&gt;mix escript.build&lt;/code&gt;&lt;/a&gt;, and so on.</source>
          <target state="translated">Elixir 코드가없는 Erlang 프로젝트를 관리하는 데 Mix를 사용할 수 있습니다. Erlang 프로젝트에서 믹스 작업이 올바르게 작동하도록하려면 &lt;code&gt;language: :erlang&lt;/code&gt; 이 &lt;code&gt;project/0&lt;/code&gt; 에서 반환 한 구성의 일부 여야 합니다. 이 설정은 또한 Elixir가 생성 된 &lt;code&gt;.app&lt;/code&gt; 파일 또는 &lt;a href=&quot;mix.tasks.escript.build&quot;&gt; &lt;code&gt;mix escript.build&lt;/code&gt; &lt;/a&gt; 등으로 생성 된 escript에 대한 종속성으로 추가되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="2cdb0b1920ef5553ebcd1f21161694f9fc79e940" translate="yes" xml:space="preserve">
          <source>Mix is a build tool and, as such, it is not expected to be available in production. Therefore, it is recommended to access &lt;code&gt;Mix.env&lt;/code&gt; only in configuration files and inside &lt;code&gt;mix.exs&lt;/code&gt;, never in your application code (&lt;code&gt;lib&lt;/code&gt;).</source>
          <target state="translated">믹스는 빌드 도구이므로 프로덕션 환경에서는 사용할 수 없습니다. 따라서 응용 프로그램 코드 ( &lt;code&gt;lib&lt;/code&gt; ) 에서는 구성 파일 및 &lt;code&gt;mix.exs&lt;/code&gt; 내부에서만 &lt;code&gt;Mix.env&lt;/code&gt; 에 액세스하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c6da9856af4245149570c16ec4188fc5d3115e0f" translate="yes" xml:space="preserve">
          <source>Mix is a build tool that provides tasks for creating, compiling, and testing Elixir projects, managing its dependencies, and more.</source>
          <target state="translated">Mix는 Elixir 프로젝트 생성, 컴파일 및 테스트, 종속성 관리 등을위한 작업을 제공하는 빌드 도구입니다.</target>
        </trans-unit>
        <trans-unit id="a0df83a511be738d9e0de24c58fdbe9cd553aa72" translate="yes" xml:space="preserve">
          <source>Mix is the project management and build tool for Elixir. Invoking &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; from the command line will run the tests in each file matching the pattern &lt;code&gt;*_test.exs&lt;/code&gt; found in the &lt;code&gt;test&lt;/code&gt; directory of your project.</source>
          <target state="translated">Mix는 Elixir의 프로젝트 관리 및 빌드 도구입니다. 명령 행에서 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt; 를 호출하면 각 파일 에서 프로젝트 의 &lt;code&gt;test&lt;/code&gt; 디렉토리 에있는 &lt;code&gt;*_test.exs&lt;/code&gt; 패턴과 일치하는 테스트가 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="6efd811f3c57b4beedb58b4c74d9cfc0e7bd84d8" translate="yes" xml:space="preserve">
          <source>Mix makes a distinction between projects and applications. Based on the contents of our &lt;code&gt;mix.exs&lt;/code&gt; file, we would say we have a Mix project that defines the &lt;code&gt;:kv&lt;/code&gt; application. As we will see in later chapters, there are projects that don&amp;rsquo;t define any application.</source>
          <target state="translated">믹스는 프로젝트와 애플리케이션을 구별합니다. &lt;code&gt;mix.exs&lt;/code&gt; 파일 의 내용을 기반으로 &lt;code&gt;:kv&lt;/code&gt; 애플리케이션 을 정의하는 Mix 프로젝트가 있다고 가정합니다 . 이후 장에서 볼 수 있듯이 응용 프로그램을 정의하지 않은 프로젝트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="648fcb70fef0f7b235a3a4efb99b43d14093584b" translate="yes" xml:space="preserve">
          <source>Mix provides many tasks for working with dependencies, which can be seen in &lt;code&gt;mix help&lt;/code&gt;:</source>
          <target state="translated">믹스는 의존성 작업을위한 많은 작업을 제공하며, &lt;code&gt;mix help&lt;/code&gt; 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ad0076d881adfffd287f386c898dd8d3dfe63d9" translate="yes" xml:space="preserve">
          <source>Mix provides the concept of &amp;ldquo;environments&amp;rdquo;. They allow a developer to customize compilation and other options for specific scenarios. By default, Mix understands three environments:</source>
          <target state="translated">믹스는 &quot;환경&quot;의 개념을 제공합니다. 개발자는 특정 시나리오에 맞게 컴파일 및 기타 옵션을 사용자 정의 할 수 있습니다. 기본적으로 Mix는 세 가지 환경을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="d0eb4f5b6efc2f498d0a43bf2cce656e8deeb64f" translate="yes" xml:space="preserve">
          <source>Mix responds to the following variables:</source>
          <target state="translated">믹스는 다음 변수에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="9083e0d8be0e72f0bd60c89828382861a3d53dd0" translate="yes" xml:space="preserve">
          <source>Mix shell that uses the current process mailbox for communication.</source>
          <target state="translated">현재 프로세스 사서함을 사용하여 통신하는 혼합 셸</target>
        </trans-unit>
        <trans-unit id="ad263de6a1ec790ca04b9e1c0d40a550701c6fa7" translate="yes" xml:space="preserve">
          <source>Mix ships with many tasks under the &lt;code&gt;profile&lt;/code&gt; namespace, such as &lt;code&gt;cprof&lt;/code&gt; and &lt;code&gt;fprof&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cprof&lt;/code&gt; 및 &lt;code&gt;fprof&lt;/code&gt; 와 같은 &lt;code&gt;profile&lt;/code&gt; 네임 스페이스 아래에 많은 작업이 포함 된 믹스</target>
        </trans-unit>
        <trans-unit id="34cf07547ba5e61214e86cb3580e3d48c9fa65b9" translate="yes" xml:space="preserve">
          <source>Mix supports different environments. Environments allow developers to prepare and organize their project specifically for different scenarios. By default, Mix provides three environments:</source>
          <target state="translated">믹스는 다양한 환경을 지원합니다. 환경을 통해 개발자는 다양한 시나리오에 맞게 프로젝트를 준비하고 구성 할 수 있습니다. 기본적으로 Mix는 세 가지 환경을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e1d70ab3fabbbe21fc38f850f28d9a31374f92fc" translate="yes" xml:space="preserve">
          <source>Mix tasks are designed to run only once. This prevents the same task to be executed multiple times. For example, if there are several tasks depending on &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;, the code will be compiled once. Tasks can be executed again if they are explicitly reenabled using &lt;a href=&quot;mix.task#reenable/1&quot;&gt;&lt;code&gt;Mix.Task.reenable/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">믹스 작업은 한 번만 실행되도록 설계되었습니다. 이렇게하면 동일한 작업이 여러 번 실행되지 않습니다. 예를 들어 &lt;a href=&quot;mix.tasks.compile&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt; 에 따라 여러 작업 이있는 경우 코드가 한 번 컴파일됩니다. &lt;a href=&quot;mix.task#reenable/1&quot;&gt; &lt;code&gt;Mix.Task.reenable/1&lt;/code&gt; 을&lt;/a&gt; 사용하여 명시 적으로 다시 활성화하면 작업을 다시 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afb48dfad219bb575ed5a6a2a2d6171fe59e0c43" translate="yes" xml:space="preserve">
          <source>Mix will create a directory named &lt;code&gt;kv&lt;/code&gt; with a few files in it:</source>
          <target state="translated">Mix는 몇 개의 파일을 가진 &lt;code&gt;kv&lt;/code&gt; 라는 디렉토리를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="8fa02d3dbeffdcfedef855ce25999f5c0e80ec49" translate="yes" xml:space="preserve">
          <source>Mix will default to the &lt;code&gt;:dev&lt;/code&gt; environment, except for the &lt;code&gt;test&lt;/code&gt; task that will default to the &lt;code&gt;:test&lt;/code&gt; environment. The environment can be changed via the &lt;code&gt;MIX_ENV&lt;/code&gt; environment variable:</source>
          <target state="translated">기본적으로 &lt;code&gt;:test&lt;/code&gt; 환경 으로 설정 되는 &lt;code&gt;test&lt;/code&gt; 작업을 제외하고 Mix는 기본적으로 &lt;code&gt;:dev&lt;/code&gt; 환경 으로 설정됩니다 . 환경은 &lt;code&gt;MIX_ENV&lt;/code&gt; 환경 변수 를 통해 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="399305e4f380845bf197d5745b3fee53dc94ea53" translate="yes" xml:space="preserve">
          <source>Mix will load the &lt;code&gt;test_helper.exs&lt;/code&gt; file before executing the tests. It is not necessary to &lt;code&gt;require&lt;/code&gt; the &lt;code&gt;test_helper.exs&lt;/code&gt; file in your test files. See &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;Mix.Tasks.Test&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">테스트를 실행하기 전에 Mix는 &lt;code&gt;test_helper.exs&lt;/code&gt; 파일 을로드합니다 . 할 필요가 없습니다 &lt;code&gt;require&lt;/code&gt; &lt;code&gt;test_helper.exs&lt;/code&gt; 의 테스트 파일에 파일을. 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;Mix.Tasks.Test&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="677bfdd437f39d48687e8e09deb896bdab1ffcab" translate="yes" xml:space="preserve">
          <source>Mix.InvalidTaskError</source>
          <target state="translated">Mix.InvalidTaskError</target>
        </trans-unit>
        <trans-unit id="73acde233ddd7f978233bc0c9c03ffcb591e4127" translate="yes" xml:space="preserve">
          <source>Mix.InvalidTaskError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.InvalidTaskError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="5656de2d70dc1fd33545f113c9c31f4468c93c9f" translate="yes" xml:space="preserve">
          <source>Mix.NoProjectError</source>
          <target state="translated">Mix.NoProjectError</target>
        </trans-unit>
        <trans-unit id="a3cd7de13e58b68149c17286a492f048bc5a4f9f" translate="yes" xml:space="preserve">
          <source>Mix.NoProjectError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.NoProjectError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2296b8a4da20e50fc86db62a76ae3a0f21236d09" translate="yes" xml:space="preserve">
          <source>Mix.NoTaskError</source>
          <target state="translated">Mix.NoTaskError</target>
        </trans-unit>
        <trans-unit id="4758003c8f1681557fd809da1ff272c0a4bdc616" translate="yes" xml:space="preserve">
          <source>Mix.NoTaskError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Mix.NoTaskError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f736ae59e13a4e4114e4af3bf6ddc51b25a5bb36" translate="yes" xml:space="preserve">
          <source>Mix.Project</source>
          <target state="translated">Mix.Project</target>
        </trans-unit>
        <trans-unit id="467f63e6768ca92e850a24bb5559e6ceb3ff2d65" translate="yes" xml:space="preserve">
          <source>Mix.Shell.IO</source>
          <target state="translated">Mix.Shell.IO</target>
        </trans-unit>
        <trans-unit id="ae6604b3cc7069b10edb34181cf30fa1c7e69549" translate="yes" xml:space="preserve">
          <source>Mix.Shell.Process</source>
          <target state="translated">Mix.Shell.Process</target>
        </trans-unit>
        <trans-unit id="d04ad970550a78d0484fc6fba35ca08880a1b57f" translate="yes" xml:space="preserve">
          <source>Mix.Task</source>
          <target state="translated">Mix.Task</target>
        </trans-unit>
        <trans-unit id="426aac8f0abf87df945411bf3866831ccdd5ee99" translate="yes" xml:space="preserve">
          <source>Mix.Task &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">믹스 작업 &lt;small&gt;동작&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f260e757cec75096bc3eefbfb1c4a14720832017" translate="yes" xml:space="preserve">
          <source>Modifier</source>
          <target state="translated">Modifier</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="63368ee0cfe73d65555cc05d160f4780d59c63dd" translate="yes" xml:space="preserve">
          <source>Modifies command line arguments.</source>
          <target state="translated">명령 행 인수를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="b8ff02892916ff59f7fbd4e617fccd01f6bca576" translate="yes" xml:space="preserve">
          <source>Module</source>
          <target state="translated">Module</target>
        </trans-unit>
        <trans-unit id="9297e283a310f6ab7d943b5269f1a79016e762cb" translate="yes" xml:space="preserve">
          <source>Module &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="translated">모듈 &lt;small&gt;행동&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9c3f2aba6913de8da00faed8e2df2428bb1257b7" translate="yes" xml:space="preserve">
          <source>Module Attributes</source>
          <target state="translated">모듈 속성</target>
        </trans-unit>
        <trans-unit id="974d46d1f85954ab50d762a7e03d4820f241857f" translate="yes" xml:space="preserve">
          <source>Module and describe tags</source>
          <target state="translated">모듈 및 설명 태그</target>
        </trans-unit>
        <trans-unit id="330765efeb90ac3d911657d7500e925bd8f2537b" translate="yes" xml:space="preserve">
          <source>Module attributes</source>
          <target state="translated">모듈 속성</target>
        </trans-unit>
        <trans-unit id="611dbb58b63e5a3205266276e6a852dcaa7a3969" translate="yes" xml:space="preserve">
          <source>Module attributes in Elixir serve three purposes:</source>
          <target state="translated">Elixir의 모듈 속성은 세 가지 목적을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e1e3ec1d59bfdc3e7d0eaa73499821e62209421e" translate="yes" xml:space="preserve">
          <source>Module attributes reader (&lt;code&gt;@foo&lt;/code&gt;)</source>
          <target state="translated">모듈 속성 판독기 ( &lt;code&gt;@foo&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ddfcf23684bdb5ef441d59b66364129fcb4f0309" translate="yes" xml:space="preserve">
          <source>Module nesting</source>
          <target state="translated">모듈 중첩</target>
        </trans-unit>
        <trans-unit id="40144123a36c18a55943d34cbb9a342139e699ec" translate="yes" xml:space="preserve">
          <source>Module to work with, define, and import records.</source>
          <target state="translated">레코드 작업, 정의 및 가져 오기를위한 모듈.</target>
        </trans-unit>
        <trans-unit id="cc1693df58c9640eee91eb5bd91f74e7ad932311" translate="yes" xml:space="preserve">
          <source>Module-based supervisors</source>
          <target state="translated">모듈 기반 감독자</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="2f22992ace2b7b2537bcbf08c8e4ceeca5300f8f" translate="yes" xml:space="preserve">
          <source>Modules adopting the &lt;code&gt;Parser&lt;/code&gt; behaviour will have to implement all the functions defined with the &lt;code&gt;@callback&lt;/code&gt; directive. As you can see, &lt;code&gt;@callback&lt;/code&gt; expects a function name but also a function specification like the ones used with the &lt;code&gt;@spec&lt;/code&gt; directive we saw above. Also note that the &lt;code&gt;term&lt;/code&gt; type is used to represent the parsed value. In Elixir, the &lt;code&gt;term&lt;/code&gt; type is a shortcut to represent any type.</source>
          <target state="translated">&lt;code&gt;Parser&lt;/code&gt; 동작을 채택하는 모듈 은 &lt;code&gt;@callback&lt;/code&gt; 지시문으로 정의 된 모든 기능을 구현해야합니다 . 보시다시피 &lt;code&gt;@callback&lt;/code&gt; 은 함수 이름뿐만 아니라 위에서 본 &lt;code&gt;@spec&lt;/code&gt; 지시문에 사용 된 것과 같은 함수 사양도 필요합니다 . 또한 type &lt;code&gt;term&lt;/code&gt; 는 구문 분석 된 값을 나타내는 데 사용됩니다. Elixir에서 type &lt;code&gt;term&lt;/code&gt; 는 모든 유형을 나타내는 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="dbf8ec2a137ea97fd047b1bf5fb0e081373aaeef" translate="yes" xml:space="preserve">
          <source>Modules and functions</source>
          <target state="translated">모듈과 기능</target>
        </trans-unit>
        <trans-unit id="f95593466c9236f423e2ca78c791a9ed452a97e0" translate="yes" xml:space="preserve">
          <source>Modules compiled with HiPE would not call this hook.</source>
          <target state="translated">HiPE로 컴파일 된 모듈은이 후크를 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f7948a408bbeb081e3bf4398d0a06535fe04fa6" translate="yes" xml:space="preserve">
          <source>Modules that are not yet loaded won't show up. Check &lt;a href=&quot;#load_all/0&quot;&gt;&lt;code&gt;load_all/0&lt;/code&gt;&lt;/a&gt; if you want to preload all tasks.</source>
          <target state="translated">아직로드되지 않은 모듈은 표시되지 않습니다. 모든 작업을 미리로드하려면 &lt;a href=&quot;#load_all/0&quot;&gt; &lt;code&gt;load_all/0&lt;/code&gt; 을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="bda622c46b037f80824387d421dc386c6556e7d2" translate="yes" xml:space="preserve">
          <source>Modules that interface with the underlying system, such as:</source>
          <target state="translated">기본 시스템과 인터페이스하는 모듈 :</target>
        </trans-unit>
        <trans-unit id="49fb186a5c3efc09ccd0d283216aa3aefc8c1db1" translate="yes" xml:space="preserve">
          <source>Monitors or links?</source>
          <target state="translated">모니터 또는 링크?</target>
        </trans-unit>
        <trans-unit id="b5af02a7afd8f398df475e389f375296b40fcadb" translate="yes" xml:space="preserve">
          <source>Monitors the status of the node.</source>
          <target state="translated">노드의 상태를 모니터링합니다.</target>
        </trans-unit>
        <trans-unit id="531f01d1f3ee72b3521ad6573e9645c241df955d" translate="yes" xml:space="preserve">
          <source>More detailed information is returned if you provide the &lt;code&gt;--callers&lt;/code&gt; and &lt;code&gt;--details&lt;/code&gt; options.</source>
          <target state="translated">&lt;code&gt;--callers&lt;/code&gt; 및 &lt;code&gt;--details&lt;/code&gt; 옵션 을 제공하면 자세한 정보가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="679fb30706daaf38b9e2ca52a7581c5f7429d440" translate="yes" xml:space="preserve">
          <source>More examples of paired functions: &lt;a href=&quot;base#decode16/2&quot;&gt;&lt;code&gt;Base.decode16/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;base#decode16!/2&quot;&gt;&lt;code&gt;Base.decode16!/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;file#cwd/0&quot;&gt;&lt;code&gt;File.cwd/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;file#cwd!/0&quot;&gt;&lt;code&gt;File.cwd!/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">쌍 기능의 더 많은 예제 : &lt;a href=&quot;base#decode16/2&quot;&gt; &lt;code&gt;Base.decode16/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;base#decode16!/2&quot;&gt; &lt;code&gt;Base.decode16!/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;file#cwd/0&quot;&gt; &lt;code&gt;File.cwd/0&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;file#cwd!/0&quot;&gt; &lt;code&gt;File.cwd!/0&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b89d915a104252705d1f85ce849ed077d1dac0ac" translate="yes" xml:space="preserve">
          <source>More information about graphemes can be found in the &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode Standard Annex #29&lt;/a&gt;. The current Elixir version implements Extended Grapheme Cluster algorithm.</source>
          <target state="translated">graphemes에 대한 자세한 내용은 &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode Standard Annex # 29&lt;/a&gt; 에서 찾을 수 있습니다 . 현재 Elixir 버전은 Extended Grapheme Cluster 알고리즘을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a5e8684b13528d21f979a1818ef3d359d73c9599" translate="yes" xml:space="preserve">
          <source>More information about the tuple data type and about functions to manipulate tuples can be found in the &lt;a href=&quot;tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; module; some functions for working with tuples are also available in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; (such as &lt;a href=&quot;kernel#elem/2&quot;&gt;&lt;code&gt;Kernel.elem/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;kernel#tuple_size/1&quot;&gt;&lt;code&gt;Kernel.tuple_size/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">튜플 데이터 형식 및 튜플 조작 기능에 대한 자세한 내용은 &lt;a href=&quot;tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; 모듈 에서 찾을 수 있습니다 . 튜플 작업을위한 일부 기능은 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; (예 : &lt;a href=&quot;kernel#elem/2&quot;&gt; &lt;code&gt;Kernel.elem/2&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;kernel#tuple_size/1&quot;&gt; &lt;code&gt;Kernel.tuple_size/1&lt;/code&gt; &lt;/a&gt; ) 에서도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="430a22fd9616cca59513735ab6a5d8e059b24d05" translate="yes" xml:space="preserve">
          <source>More information on date times can be found in the &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">날짜 시간에 대한 자세한 내용은 &lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 모듈 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a10a384a2270f2efaa542fb180ccc3a8a8fab8a8" translate="yes" xml:space="preserve">
          <source>More information on dates can be found in the &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">날짜에 대한 자세한 정보는 &lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 모듈 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d09563b1d7bf20501a96abf9b569ef7f610dceb" translate="yes" xml:space="preserve">
          <source>More information on naive date times can be found in the &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">순진한 날짜 시간에 대한 자세한 내용은 &lt;a href=&quot;naivedatetime&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 모듈 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c85521cfa0af914c1bfcc721a8420c6e8c54e6ca" translate="yes" xml:space="preserve">
          <source>More information on regexes can be found in the &lt;a href=&quot;regex&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;regex&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt; 에 대한 자세한 내용은 정규식 모듈 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="943682535e16011c70352d95eb0b5a94fc51f1ec" translate="yes" xml:space="preserve">
          <source>More information on regular expressions can be found in the &lt;a href=&quot;regex&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;regex&quot;&gt; &lt;code&gt;Regex&lt;/code&gt; &lt;/a&gt; 에 대한 자세한 내용은 Regex 모듈 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74e1febe16a203d4cc3b9b43ca22bede1863da17" translate="yes" xml:space="preserve">
          <source>More information on times can be found in the &lt;a href=&quot;time&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">시간에 대한 자세한 정보는 &lt;a href=&quot;time&quot;&gt; &lt;code&gt;Time&lt;/code&gt; &lt;/a&gt; 모듈 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47345d51b5c718e5874fcd01549e8be7ce1a8743" translate="yes" xml:space="preserve">
          <source>More interestingly, we can match on specific values. The example below asserts that the left side will only match the right side when the right side is a tuple that starts with the atom &lt;code&gt;:ok&lt;/code&gt;:</source>
          <target state="translated">더 흥미롭게도 특정 값과 일치시킬 수 있습니다. 아래 예제는 오른쪽이 atom &lt;code&gt;:ok&lt;/code&gt; 로 시작하는 튜플 일 때 왼쪽이 오른쪽 만 일치한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="708db7ea87e7a72eeea9cb0dbb3ddbd4f2c25b4b" translate="yes" xml:space="preserve">
          <source>More options are available; for the comprehensive list of available options check &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt;&lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 많은 옵션을 사용할 수 있습니다. 사용 가능한 옵션의 전체 목록은 &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt; &lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt; 를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="0761006711d858b0c2a58d2cbd1afefe913dcc42" translate="yes" xml:space="preserve">
          <source>Moreover, even when trapping exits, calling &lt;code&gt;await&lt;/code&gt; will still exit if the task has terminated without sending its result back.</source>
          <target state="translated">또한 트래핑 종료가 발생하더라도 결과를 다시 보내지 않고 작업이 종료 된 경우 &lt;code&gt;await&lt;/code&gt; 호출 은 계속 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="7a438f48c599e07f621f37d7528ee6f6b3ed9813" translate="yes" xml:space="preserve">
          <source>Most Elixir code has a straight-forward translation to its underlying quoted expression. We recommend you try out different code samples and see what the results are. For example, what does &lt;code&gt;String.upcase(&quot;foo&quot;)&lt;/code&gt; expand to? We have also learned that &lt;code&gt;if(true, do: :this, else: :that)&lt;/code&gt; is the same as &lt;code&gt;if true do :this else :that end&lt;/code&gt;. How does this affirmation hold with quoted expressions?</source>
          <target state="translated">대부분의 Elixir 코드는 기본 인용 식으로 간단하게 번역됩니다. 다른 코드 샘플을 시험해보고 결과를 확인하는 것이 좋습니다. 예를 들어 &lt;code&gt;String.upcase(&quot;foo&quot;)&lt;/code&gt; 는 무엇으로 확장됩니까? 우리는 또한 &lt;code&gt;if(true, do: :this, else: :that)&lt;/code&gt; 가 &lt;code&gt;if true do :this else :that end&lt;/code&gt; 와 같다는 것을 배웠습니다 . 이 확인은 인용 된 표현과 어떻게 관련이 있습니까?</target>
        </trans-unit>
        <trans-unit id="0687907a8d3988b5e082480eea48abedcef483ec" translate="yes" xml:space="preserve">
          <source>Most editors provide built-in integration with the formatter, allowing a file to be formatted on save or via a chosen keybinding. If you are learning Elixir, editor integration gives you useful and quick feedback when learning the Elixir syntax.</source>
          <target state="translated">대부분의 편집기는 포맷터와 내장 된 통합 기능을 제공하므로 파일을 저장하거나 선택한 키 바인딩을 통해 파일을 포맷 할 수 있습니다. Elixir를 배우는 경우, 편집기 통합은 Elixir 구문을 배울 때 유용하고 빠른 피드백을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="024156cd258aa614f1a1e84226c2405ec889367a" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module return &lt;code&gt;:ok&lt;/code&gt; or &lt;code&gt;{:ok, result}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise. Those functions also have a variant that ends with &lt;code&gt;!&lt;/code&gt; which returns the result (instead of the &lt;code&gt;{:ok, result}&lt;/code&gt; tuple) in case of success or raises an exception in case it fails. For example:</source>
          <target state="translated">이 모듈의 대부분의 함수 는 성공시 &lt;code&gt;:ok&lt;/code&gt; 또는 &lt;code&gt;{:ok, result}&lt;/code&gt; 를 반환하고 &lt;code&gt;{:error, reason}&lt;/code&gt; 그렇지 않으면 {: error, reason}을 반환합니다. 이러한 함수에는 &lt;code&gt;!&lt;/code&gt; 로 끝나는 변형이 있습니다 . 성공 하면 &lt;code&gt;{:ok, result}&lt;/code&gt; 튜플 대신 결과를 반환 하거나 실패하면 예외를 발생시킵니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dbffd668417f19cdbcd33d0162e5263a21e09ebf" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module work in linear time. This means that, that the time it takes to perform an operation grows at the same rate as the length of the list. For example &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#last/1&quot;&gt;&lt;code&gt;last/1&lt;/code&gt;&lt;/a&gt; will run in linear time because they need to iterate through every element of the list, but &lt;a href=&quot;#first/1&quot;&gt;&lt;code&gt;first/1&lt;/code&gt;&lt;/a&gt; will run in constant time because it only needs the first element.</source>
          <target state="translated">이 모듈의 대부분의 기능은 선형 시간으로 작동합니다. 즉, 작업을 수행하는 데 걸리는 시간이 목록의 길이와 동일한 속도로 증가합니다. 예를 들어 &lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;length/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#last/1&quot;&gt; &lt;code&gt;last/1&lt;/code&gt; &lt;/a&gt; 은 목록의 모든 요소를 ​​반복해야하기 때문에 선형 시간으로 실행되지만 &lt;a href=&quot;#first/1&quot;&gt; &lt;code&gt;first/1&lt;/code&gt; &lt;/a&gt; 은 첫 번째 요소 만 필요하기 때문에 일정한 시간에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="ce9701b5552f6ac3d94cc4ca928ec6d05512ce0a" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list.</source>
          <target state="translated">이 모듈의 대부분의 기능은 선형 시간으로 작동합니다. 즉, 작업을 수행하는 데 걸리는 시간이 목록의 길이와 동일한 속도로 증가합니다.</target>
        </trans-unit>
        <trans-unit id="3fd0b4b5634fc00fd0cd07602c5fab763e2a315d" translate="yes" xml:space="preserve">
          <source>Most of the inlined functions can be seen in effect when capturing the function:</source>
          <target state="translated">함수를 캡처 할 때 대부분의 인라인 함수를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="650e20466b330f46fc9cd6f719b3f04d44e3661d" translate="yes" xml:space="preserve">
          <source>Most of the operations in &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; are implemented in terms of reduce. This function should apply the given &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function to each element in the &lt;code&gt;enumerable&lt;/code&gt; and proceed as expected by the returned accumulator.</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; 의&lt;/a&gt; 대부분의 작업 은 감소 측면에서 구현됩니다. 이 함수는 주어진 &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; 함수를 &lt;code&gt;enumerable&lt;/code&gt; 각 요소에 적용 하고 반환 된 누산기에서 예상 한대로 진행해야합니다.</target>
        </trans-unit>
        <trans-unit id="24b137a5b6dba3724d546a7b4386d3d0c4f7db88" translate="yes" xml:space="preserve">
          <source>Most of the time it is convenient to write modules into files so they can be compiled and reused. Let&amp;rsquo;s assume we have a file named &lt;code&gt;math.ex&lt;/code&gt; with the following contents:</source>
          <target state="translated">대부분의 경우 모듈을 파일에 작성하여 컴파일하고 재사용 할 수있는 것이 편리합니다. 다음 내용의 &lt;code&gt;math.ex&lt;/code&gt; 라는 파일이 있다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="629b5f27dd5283caadd5c5cbf0f295755b9869cd" translate="yes" xml:space="preserve">
          <source>Most of the time there is one, and just one, valid datetime for a certain date and time in a certain time zone.</source>
          <target state="translated">대부분의 시간에는 특정 시간대의 특정 날짜 및 시간에 대해 유효한 날짜 시간이 하나뿐입니다.</target>
        </trans-unit>
        <trans-unit id="91857fb8fa18b4cfe30782a8862e99da6ebb9879" translate="yes" xml:space="preserve">
          <source>Most of the time, Elixir is going to guide you to do the right thing. For example, there is an &lt;code&gt;elem/2&lt;/code&gt; function to access a tuple item but there is no built-in equivalent for lists:</source>
          <target state="translated">대부분의 경우, Elixir는 올바른 일을하도록 안내 할 것입니다. 예를 들어 튜플 항목에 액세스 하는 &lt;code&gt;elem/2&lt;/code&gt; 함수가 있지만 목록에 해당하는 내장 함수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="cca16065899804f7768a7a1720aa616e84369d6b" translate="yes" xml:space="preserve">
          <source>Move the undocumented function to a module with &lt;code&gt;@moduledoc false&lt;/code&gt;, like &lt;code&gt;MyApp.Hidden&lt;/code&gt;, ensuring the function won't be accidentally exposed or imported. Remember you can use &lt;code&gt;@moduledoc false&lt;/code&gt; to hide a whole module and still document each function with &lt;code&gt;@doc&lt;/code&gt;. Tools will still ignore the module.</source>
          <target state="translated">문서화되지 않은 함수를 &lt;code&gt;@moduledoc false&lt;/code&gt; 과 같이 &lt;code&gt;MyApp.Hidden&lt;/code&gt; false 가있는 모듈로 이동하면 함수가 실수로 노출되거나 가져 오지 않습니다. &lt;code&gt;@moduledoc false&lt;/code&gt; 를 사용 하여 전체 모듈을 숨기고 각 함수를 &lt;code&gt;@doc&lt;/code&gt; 로 문서화 할 수 있습니다 . 도구는 여전히 모듈을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="8ba586c26244aa844e20201d605ef816e569e0c3" translate="yes" xml:space="preserve">
          <source>Much better! &lt;code&gt;with&lt;/code&gt; will retrieve the value returned by the right-side of &lt;code&gt;&amp;lt;-&lt;/code&gt; and match it against the pattern on the left side. If the value matches the pattern, &lt;code&gt;with&lt;/code&gt; moves on to the next expression. In case there is no match, the non-matching value is returned.</source>
          <target state="translated">훨씬 낫다! &lt;code&gt;with&lt;/code&gt; 는 &lt;code&gt;&amp;lt;-&lt;/code&gt; 의 오른쪽에서 반환 된 값을 검색 하여 왼쪽의 패턴과 일치시킵니다. 값이 패턴과 일치 하면 다음 표현식 &lt;code&gt;with&lt;/code&gt; 이동합니다. 일치하는 것이 없으면 일치하지 않는 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="aca1d8661416c63356922cc0e796c657256bdbf6" translate="yes" xml:space="preserve">
          <source>Multi alias/import/require/use</source>
          <target state="translated">다중 별칭 / 가져 오기 / 필수 / 사용</target>
        </trans-unit>
        <trans-unit id="600851f745d8c6c136c80bb6740770dde7f94908" translate="yes" xml:space="preserve">
          <source>Multi-letter aliases in &lt;a href=&quot;optionparser&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;optionparser&quot;&gt; &lt;code&gt;OptionParser&lt;/code&gt; 의&lt;/a&gt; 다중 문자 별명</target>
        </trans-unit>
        <trans-unit id="cd897f3df67fae1b86657cd6f5002662e25d4a84" translate="yes" xml:space="preserve">
          <source>Multi-line charlists are written with three single-quotes (&lt;code&gt;'''&lt;/code&gt;), the same way multi-line strings are.</source>
          <target state="translated">여러 줄 문자 목록은 여러 줄 문자열과 같은 방식 으로 세 개의 작은 따옴표 ( &lt;code&gt;'''&lt;/code&gt; )로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="971b1abcdb78d0f06496a5acd8f26ed4ec25bf2b" translate="yes" xml:space="preserve">
          <source>Multi-line lists, maps, tuples, etc.</source>
          <target state="translated">여러 줄 목록,지도, 튜플 등</target>
        </trans-unit>
        <trans-unit id="387558e9801635e36ced6d8f96c29ddee6395ce1" translate="yes" xml:space="preserve">
          <source>Multi-line strings in Elixir are written with three double-quotes, and can have unescaped quotes within them. The resulting string will end with a newline. The indentation of the last &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; is used to strip indentation from the inner string. For example:</source>
          <target state="translated">Elixir의 여러 줄 문자열은 큰 따옴표 3 개로 작성되며 이스케이프 처리되지 않은 따옴표를 사용할 수 있습니다. 결과 문자열은 줄 바꿈으로 끝납니다. 마지막 &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; 들여 쓰기는 내부 문자열에서 들여 쓰기를 제거하는 데 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3b47d6814f63cc5e3bd080a55da0c264aee3d21" translate="yes" xml:space="preserve">
          <source>Multiple code points that may be perceived as a single character by readers</source>
          <target state="translated">독자가 단일 문자로 인식 할 수있는 여러 코드 포인트</target>
        </trans-unit>
        <trans-unit id="6d1f745a36808f93bd028263c26703cfbaed268c" translate="yes" xml:space="preserve">
          <source>Multiple generators can also be used to calculate the cartesian product of two lists:</source>
          <target state="translated">여러 생성기를 사용하여 두 목록의 데카르트 곱을 계산할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fd421a1aa76b2a83bd80d007c37c141c303064d" translate="yes" xml:space="preserve">
          <source>Multiple guards in the same clause</source>
          <target state="translated">같은 조항에 여러 경비원</target>
        </trans-unit>
        <trans-unit id="c528525d61b06dbc869c01826c97062225a9a675" translate="yes" xml:space="preserve">
          <source>Multiple implementations</source>
          <target state="translated">여러 구현</target>
        </trans-unit>
        <trans-unit id="f43d8ba152323821f27a132f7581f8caab516e47" translate="yes" xml:space="preserve">
          <source>Multiple releases. You can assemble different releases with different configuration per application or even with different applications altogether.</source>
          <target state="translated">여러 릴리스. 응용 프로그램마다 구성이 다르거 나 다른 응용 프로그램을 사용하여 다른 릴리스를 조립할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f4cf21f4344405e752af495c43a5b7beb80cfa4" translate="yes" xml:space="preserve">
          <source>Multiple uses of &lt;code&gt;@compile&lt;/code&gt; will accumulate instead of overriding previous ones. See the &quot;Compile options&quot; section below.</source>
          <target state="translated">&lt;code&gt;@compile&lt;/code&gt; 을 여러 번 사용 하면 이전 방법을 재정의하는 대신 누적됩니다. 아래의 &quot;컴파일 옵션&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cbd5985b43b284860bef16f48015f61c53879304" translate="yes" xml:space="preserve">
          <source>Multiple uses of &lt;code&gt;@dialyzer&lt;/code&gt; will accumulate instead of overriding previous ones.</source>
          <target state="translated">&lt;code&gt;@dialyzer&lt;/code&gt; 를 여러 번 사용 하면 이전 항목을 재정의하는 대신 누적됩니다.</target>
        </trans-unit>
        <trans-unit id="4bc08a47511c7c5ad4c0a467eaca187d877e8749" translate="yes" xml:space="preserve">
          <source>Mutable state and access to shared resources (such as ETS, files, etc.)</source>
          <target state="translated">변경 가능한 상태 및 공유 리소스 (예 : ETS, 파일 등)에 대한 액세스</target>
        </trans-unit>
        <trans-unit id="74c5ad44b6579fcbcf0c6ec60e160908d2a983ce" translate="yes" xml:space="preserve">
          <source>My computer is named &lt;code&gt;jv&lt;/code&gt;, so I see &lt;code&gt;foo@jv&lt;/code&gt; in the example above, but you will get a different result. We will use &lt;code&gt;foo@computer-name&lt;/code&gt; in the following examples and you should update them accordingly when trying out the code.</source>
          <target state="translated">내 컴퓨터의 이름은 &lt;code&gt;jv&lt;/code&gt; 이므로 위 예제에서 &lt;code&gt;foo@jv&lt;/code&gt; 가 표시되지만 다른 결과가 나타납니다. 다음 예제 에서는 &lt;code&gt;foo@computer-name&lt;/code&gt; 을 사용 하며 코드를 시도 할 때 적절히 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="a50f07a710ba62544947bf23759e42c6e82ff7d6" translate="yes" xml:space="preserve">
          <source>My particular telnet client can be exited by typing &lt;code&gt;ctrl + ]&lt;/code&gt;, typing &lt;code&gt;quit&lt;/code&gt;, and pressing &lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt;, but your client may require different steps.</source>
          <target state="translated">내 특정 텔넷 클라이언트는 &lt;code&gt;ctrl + ]&lt;/code&gt; 를 입력하고 &lt;code&gt;quit&lt;/code&gt; 를 입력 하고 &lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt; 키를 눌러 종료 할 수 있지만 클라이언트에 다른 단계가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b897ebc1430a2e4abc81cf0b2714edf134f99207" translate="yes" xml:space="preserve">
          <source>NaiveDateTime</source>
          <target state="translated">NaiveDateTime</target>
        </trans-unit>
        <trans-unit id="d49675d6a7db398730976978d05575d69c0eb3c3" translate="yes" xml:space="preserve">
          <source>Name registration</source>
          <target state="translated">이름 등록</target>
        </trans-unit>
        <trans-unit id="368a0ab278773b445741a837271772d0936779aa" translate="yes" xml:space="preserve">
          <source>Named functions</source>
          <target state="translated">명명 된 기능</target>
        </trans-unit>
        <trans-unit id="b7cb86483160ed9ca9d1ab540d3476197e0162c0" translate="yes" xml:space="preserve">
          <source>Named functions in Elixir also support default arguments:</source>
          <target state="translated">Elixir의 명명 된 함수는 기본 인수도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8b4617b659a51d0b5756991a46730570511eef04" translate="yes" xml:space="preserve">
          <source>Naming</source>
          <target state="translated">Naming</target>
        </trans-unit>
        <trans-unit id="8af56df8a9cb35f56b67edd6d269d4e86defc0d0" translate="yes" xml:space="preserve">
          <source>Naming Conventions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7072ebdd4d3d7903620768f687a8dfdcc8ce66" translate="yes" xml:space="preserve">
          <source>Naming processes</source>
          <target state="translated">명명 프로세스</target>
        </trans-unit>
        <trans-unit id="2dafad67b671623ab79a27e34be51e846c44fb41" translate="yes" xml:space="preserve">
          <source>Negation switches</source>
          <target state="translated">부정 스위치</target>
        </trans-unit>
        <trans-unit id="6cf669c72f3ca4537fedf1a696188ac323c60bad" translate="yes" xml:space="preserve">
          <source>Negative Unix times are supported, up to -62167219200 seconds, which is equivalent to &quot;0000-01-01T00:00:00Z&quot; or 0 Gregorian seconds.</source>
          <target state="translated">음수 Unix 시간은 최대 -62167219200 초까지 지원되며 &quot;0000-01-01T00 : 00 : 00Z&quot;또는 0 Gregorian 초와 같습니다.</target>
        </trans-unit>
        <trans-unit id="a20bdc82e5703dd99f69be3ffeaf120ee97f50f4" translate="yes" xml:space="preserve">
          <source>Negative indices indicate an offset from the end of the &lt;code&gt;list&lt;/code&gt;. If &lt;code&gt;index&lt;/code&gt; is out of bounds, the original &lt;code&gt;list&lt;/code&gt; is returned.</source>
          <target state="translated">음수 인덱스는 &lt;code&gt;list&lt;/code&gt; 끝에서 오프셋을 나타냅니다 . 경우 &lt;code&gt;index&lt;/code&gt; 범위를 벗어났습니다 원래 &lt;code&gt;list&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="02f8888aa8ebd456306e0978a35197f74b636d4e" translate="yes" xml:space="preserve">
          <source>Nested data structures</source>
          <target state="translated">중첩 된 데이터 구조</target>
        </trans-unit>
        <trans-unit id="f06563daf6842a8e082fd4615e320fc869bb69d9" translate="yes" xml:space="preserve">
          <source>Nesting</source>
          <target state="translated">Nesting</target>
        </trans-unit>
        <trans-unit id="230c22b07521849e4e1eb0ed24d083dc0b4e9329" translate="yes" xml:space="preserve">
          <source>Nesting a module inside another module affects the name of the nested module:</source>
          <target state="translated">다른 모듈 안에 모듈을 중첩하면 중첩 모듈의 이름에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="a0587b966ad1346723038626d25a39c4caf0fcf4" translate="yes" xml:space="preserve">
          <source>Nests the given document at the given &lt;code&gt;level&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;level&lt;/code&gt; 에서 지정된 문서를 중첩합니다 .</target>
        </trans-unit>
        <trans-unit id="ac15dcab98b84e881f95ff7f13b6c27d1103008b" translate="yes" xml:space="preserve">
          <source>New releases are announced in the read-only &lt;a href=&quot;https://groups.google.com/group/elixir-lang-ann&quot;&gt;announcements mailing list&lt;/a&gt;. All security releases &lt;a href=&quot;https://groups.google.com/forum/#!searchin/elixir-lang-ann/%255Bsecurity%255D%257Csort:date&quot;&gt;will be tagged with &lt;code&gt;[security]&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새로운 릴리즈는 읽기 전용 &lt;a href=&quot;https://groups.google.com/group/elixir-lang-ann&quot;&gt;공지 메일 링리스트에 공지되어&lt;/a&gt; 있습니다. 모든 보안 릴리스 &lt;a href=&quot;https://groups.google.com/forum/#!searchin/elixir-lang-ann/%255Bsecurity%255D%257Csort:date&quot;&gt;에는 &lt;code&gt;[security]&lt;/code&gt; &lt;/a&gt; 태그가 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="09050a709859e9c045fb8157c8d7649b286d2c98" translate="yes" xml:space="preserve">
          <source>Newlines before certain operators (such as the pipeline operators) and before other operators (such as comparison operators)</source>
          <target state="translated">파이프 라인 연산자와 같은 특정 연산자 앞과 비교 연산자와 같은 다른 연산자 앞의 줄 바꿈</target>
        </trans-unit>
        <trans-unit id="0c7d720a2e040b46c0d03386d11f05cbd66532dd" translate="yes" xml:space="preserve">
          <source>Newlines inside blocks are kept as in the input except for: 1) expressions that take multiple lines will always have an empty line before and after and 2) empty lines are always squeezed together into a single empty line</source>
          <target state="translated">1) 여러 줄을 취하는 표현식은 항상 앞뒤에 빈 줄이 있고 2) 빈 줄은 항상 하나의 빈 줄로 압착됩니다.</target>
        </trans-unit>
        <trans-unit id="11fc14203dd0f4441645a9c34d5dd022905f56e4" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="translated">다음 단계</target>
        </trans-unit>
        <trans-unit id="750891f84c6b7eeddc41453bbdd8ec1255f11a42" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s discuss external and internal dependencies and how Mix helps us manage large codebases.</source>
          <target state="translated">다음으로 외부 및 내부 종속성과 Mix가 어떻게 큰 코드베이스를 관리하는 데 도움이되는지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ec26ea6bcbb7c9f81e3f941cb690507a65daec00" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll look at a feature central to Elixir, Processes, which allows us to write concurrent, parallel and distributed programs in an easy and understandable way.</source>
          <target state="translated">다음으로, Elixir, Processes의 핵심 기능을 살펴보면, 동시에 병렬 및 분산 된 프로그램을 쉽고 이해하기 쉽게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41cb14263e20c4624e46c802b32ac0cf7c57a851" translate="yes" xml:space="preserve">
          <source>No computation will be done until we call one of the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; functions or &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 함수 중 하나 또는 &lt;a href=&quot;#run/1&quot;&gt; &lt;code&gt;run/1&lt;/code&gt; 을&lt;/a&gt; 호출 할 때까지 계산이 수행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
