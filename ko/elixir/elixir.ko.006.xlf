<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="6b4e1d5251f6539ac9cb9db6500f4e6878385d0e" translate="yes" xml:space="preserve">
          <source>If you alias a module and you don't use the alias, Elixir is going to issue a warning implying the alias is not being used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="353408b9f20e6cd80af272ea14032adbf9497508" translate="yes" xml:space="preserve">
          <source>If you are connected to remote shell, it remains alive after disconnection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efc5604d31d0bf68a1f19a9b171547de1fbb3007" translate="yes" xml:space="preserve">
          <source>If you are interested in implementing an event manager, please read the &quot;Alternatives&quot; section below. If you have to implement an event handler to integrate with an existing system, such as Elixir's Logger, please use &lt;code&gt;:gen_event&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51ef50c4ad529792706bf2b89ce565387c1909b0" translate="yes" xml:space="preserve">
          <source>If you are looking for a distributed key-value store to use in production, you should definitely look into &lt;a href=&quot;http://basho.com/products/riak-kv/&quot;&gt;Riak&lt;/a&gt;, which also runs in the Erlang</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8bab3f8a9ae8447c6ed759b9dc3262c1eec9de" translate="yes" xml:space="preserve">
          <source>If you are on Windows, you will have to open up &lt;code&gt;rel/env.bat.eex&lt;/code&gt;, where you will find this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c91ebf5be7f8382f751128810946bd95b4f4b2" translate="yes" xml:space="preserve">
          <source>If you are planning to write your first library for other developers to use, don&amp;rsquo;t forget to read our &lt;a href=&quot;https://hexdocs.pm/elixir/library-guidelines.html&quot;&gt;Library Guidelines&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b2be79d72180600413436f842949c96ba6fb15b" translate="yes" xml:space="preserve">
          <source>If you are setting a &lt;code&gt;@moduletag&lt;/code&gt;, you must set that after your call to &lt;code&gt;use ExUnit.Case&lt;/code&gt; otherwise you will see compilation errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e14a93bec8f9e7583ef7d4636212d137d7df029a" translate="yes" xml:space="preserve">
          <source>If you are using async tasks, you &lt;strong&gt;must await&lt;/strong&gt; a reply as they are &lt;em&gt;always&lt;/em&gt; sent. If you are not expecting a reply, consider using &lt;a href=&quot;task#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt; detailed below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f469101752f119e7e176bed241907b041da8adaa" translate="yes" xml:space="preserve">
          <source>If you are using releases, see &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Release.html&quot;&gt;&lt;code&gt;mix release&lt;/code&gt;&lt;/a&gt;, there another configuration file called &lt;code&gt;config/releases.exs&lt;/code&gt;. While &lt;code&gt;config/config.exs&lt;/code&gt; and friends mentioned in the previous section are executed whenever you run a Mix command, including when you assemble a release, &lt;code&gt;config/releases.exs&lt;/code&gt; is execute every time your production system boots. Since Mix is not available in a production system, &lt;code&gt;config/releases.exs&lt;/code&gt; must not use any of the functions from Mix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e377e363c18762d6989f073da394e35ff6a1d87" translate="yes" xml:space="preserve">
          <source>If you are using several functions from a given module, you can import those functions and reference them as local functions, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f991b27b559271b270b3fbea782f7486b09a69" translate="yes" xml:space="preserve">
          <source>If you attempt to define a module that already exists, you will get a warning saying that a module has been redefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8adfc9342331c8cadc540a2cd5ed23c3faf380ba" translate="yes" xml:space="preserve">
          <source>If you connect to localhost once again and perform another request, now everything should work, as long as the routing table contains the correct node names. Outstanding!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a27ffb13441db905f42c43f88d86b47f09d7485" translate="yes" xml:space="preserve">
          <source>If you create a task using &lt;code&gt;async_nolink&lt;/code&gt; inside an OTP behaviour like &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, you should match on the message coming from the task inside your &lt;a href=&quot;genserver#c:handle_info/2&quot;&gt;&lt;code&gt;GenServer.handle_info/2&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b7d0164ac505a2fe344467d02c4867bf511345" translate="yes" xml:space="preserve">
          <source>If you desire to execute a trusted command inside a shell, with pipes, redirecting and so on, please check &lt;a href=&quot;http://www.erlang.org/doc/man/os.html#cmd-1&quot;&gt;&lt;code&gt;:os.cmd/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a07182ef0f8b88c81a61025e684458268493b23a" translate="yes" xml:space="preserve">
          <source>If you do not care about the results of the computation, you can run the stream with &lt;a href=&quot;stream#run/1&quot;&gt;&lt;code&gt;Stream.run/1&lt;/code&gt;&lt;/a&gt;. Also set &lt;code&gt;ordered: false&lt;/code&gt;, as you don't care about the order of the results either:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368841cd2351fb8c28d9325238a5752ebba7a138" translate="yes" xml:space="preserve">
          <source>If you do want to parse unknown switches, remember that Elixir converts switches to atoms. Since atoms are not garbage-collected, OptionParser will only parse switches that translate to atoms used by the runtime to avoid leaking atoms. For instance, the code below will discard the &lt;code&gt;--option-parser-example&lt;/code&gt; switch because the &lt;code&gt;:option_parser_example&lt;/code&gt; atom is never used anywhere:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb3116d6b170b69080991a7150c103095c5454b2" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have any use for the error, you don&amp;rsquo;t have to provide it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c77ad5b32204a8ca68d3f5ddb986c84f0f9228ac" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t specify a default key value when defining a struct, &lt;code&gt;nil&lt;/code&gt; will be assumed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6d6c827a17a1772b5dade87fd7f321c6f06b85" translate="yes" xml:space="preserve">
          <source>If you don't need a process, then you don't need a process. Use processes only to model runtime properties, such as mutable state, concurrency and failures, never for code organization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55f782e4dd6bf586b9ca7b60f48c228585b2ac7c" translate="yes" xml:space="preserve">
          <source>If you don't want to import a function or macro from &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;, use the &lt;code&gt;:except&lt;/code&gt; option and then list the function/macro by arity:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0fdad62ae1fb19bf40fae581950eb21ad57ac2c" translate="yes" xml:space="preserve">
          <source>If you don't want to link the caller to the task, then you must use a supervised task with &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; and call &lt;a href=&quot;task.supervisor#async_nolink/2&quot;&gt;&lt;code&gt;Task.Supervisor.async_nolink/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b7f3eba3dd98ca6590eeed6ea68a53ee96f3d2" translate="yes" xml:space="preserve">
          <source>If you don't want to remove all the entries associated with &lt;code&gt;key&lt;/code&gt; use &lt;a href=&quot;#pop_first/3&quot;&gt;&lt;code&gt;pop_first/3&lt;/code&gt;&lt;/a&gt; instead, that function will remove only the first entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="296ef732a2b3390cd10f991ad01cb9a80eb4f583" translate="yes" xml:space="preserve">
          <source>If you expect a project to be defined, i.e., it is a requirement of the current task, you should call &lt;a href=&quot;#get!/0&quot;&gt;&lt;code&gt;get!/0&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05da62df25733918acb3c100ca6eefcc7e8a9a05" translate="yes" xml:space="preserve">
          <source>If you find any errors in the tutorial or on the website, &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com&quot;&gt;please report a bug or send a pull request to our issue tracker&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3352da2349194da360a70c60c5b2d7bfce63e72d" translate="yes" xml:space="preserve">
          <source>If you find yourself in a position where you want to use different configurations in each application for the same dependency or use different dependency versions, then it is likely your codebase has grown beyond what umbrellas can provide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="966f4145842556d60eacaa5cb05900d76971a573" translate="yes" xml:space="preserve">
          <source>If you find yourself trapping exits to handle exits inside the async stream, consider using &lt;a href=&quot;#async_stream_nolink/6&quot;&gt;&lt;code&gt;async_stream_nolink/6&lt;/code&gt;&lt;/a&gt; to start tasks that are not linked to the calling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4197dd8400c648df18d603e11d970a3cb8836276" translate="yes" xml:space="preserve">
          <source>If you forget to escape it, Elixir will raise an error when compiling the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56efc6ca629edeb2fce03d19b2bc73e5833972b7" translate="yes" xml:space="preserve">
          <source>If you have a file that needs to compile other modules in parallel, the spawned processes need to be aware of the compiler environment. This function allows a developer to create a task that is aware of those environments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="772ddb24d9ed2ed3cd849be346856ed163202199" translate="yes" xml:space="preserve">
          <source>If you have a struct and you would like to merge a set of keys into the struct, do not use this function, as it would merge all keys on the right side into the struct, even if the key is not part of the struct. Instead, use &lt;a href=&quot;kernel#struct/2&quot;&gt;&lt;code&gt;Kernel.struct/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02d90c57cd4c0d17ad045bc9f12b98eb64e0aa31" translate="yes" xml:space="preserve">
          <source>If you have an internal dependency, Mix supports two methods to work with them: Git repositories or umbrella projects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e035a407e624050895eb31725f1748d9f855294" translate="yes" xml:space="preserve">
          <source>If you have another computer on the same network with both Erlang and Elixir installed, you can start another shell on it. If you don&amp;rsquo;t, you can start another IEx session in another terminal. In either case, give it the short name of &lt;code&gt;bar&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91e486a025ad182f48607bffbb20dc17512610a7" translate="yes" xml:space="preserve">
          <source>If you have any questions or improvements to the guide, please reach discussion channels such as the &lt;a href=&quot;https://elixirforum.com&quot;&gt;Elixir Forum&lt;/a&gt; or the &lt;a href=&quot;https://github.com/elixir-lang/elixir-lang.github.com/issues&quot;&gt;issues tracker&lt;/a&gt;. Your input is really important to help us guarantee the guides are accessible and up to date!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab49794b532da97c155763d4fee42c69953f3cd" translate="yes" xml:space="preserve">
          <source>If you have prior programming experience, you may be wondering: &amp;ldquo;could we just guarantee the bucket does not crash in the first place?&amp;rdquo;. As we will see, Elixir developers tend to refer to those practices as &amp;ldquo;defensive programming&amp;rdquo;. That&amp;rsquo;s because a live production system has dozens of different reasons why something can go wrong. The disk can fail, memory can be corrupted, bugs, the network may stop working for a second, etc. If we were to write software that attempted to protect or circumvent all of those errors, we would spend more time handling failures than writing our own software!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ff3bc0809c7cb590dd86540f6bc9220ad4b14e5" translate="yes" xml:space="preserve">
          <source>If you have skipped the Getting Started guide or read it long ago, be sure to re-read the &lt;a href=&quot;../processes&quot;&gt;Processes&lt;/a&gt; chapter. We will use it as a starting point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5e749fd5e08cb28911eb18410413620f0bb3b45" translate="yes" xml:space="preserve">
          <source>If you have to, you can think of behaviours like interfaces in object oriented languages like Java: a set of function signatures that a module has to implement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="775881310bd0276caea4cdc0616b4fb21efd691c" translate="yes" xml:space="preserve">
          <source>If you haven&amp;rsquo;t yet installed Elixir, visit our &lt;a href=&quot;https://elixir-lang.org/install.html&quot;&gt;installation page&lt;/a&gt;. Once you are done, you can run &lt;code&gt;elixir --version&lt;/code&gt; to get the current Elixir version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68dc8f62a9e86b3efbf7155da89ee4b3f7fa0def" translate="yes" xml:space="preserve">
          <source>If you import a module and you don't use any of the imported functions or macros from this module, Elixir is going to issue a warning implying the import is not being used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8b4968a8e609a12b5b450ac372d4f06174ea20" translate="yes" xml:space="preserve">
          <source>If you intend to shut the task down if it has not responded within &lt;code&gt;timeout&lt;/code&gt; milliseconds, you should chain this together with &lt;a href=&quot;#shutdown/1&quot;&gt;&lt;code&gt;shutdown/1&lt;/code&gt;&lt;/a&gt;, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83089d9b73e4091162a26829945c724a24daa00a" translate="yes" xml:space="preserve">
          <source>If you know you are running on a different system that the current one and you are doing multiple matches with the regex, you can manually invoke &lt;a href=&quot;regex#recompile/1&quot;&gt;&lt;code&gt;Regex.recompile/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;regex#recompile!/1&quot;&gt;&lt;code&gt;Regex.recompile!/1&lt;/code&gt;&lt;/a&gt; to perform a runtime version check and recompile the regex if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c864040fa40407fd79ba39543ee8e3143a0a20c" translate="yes" xml:space="preserve">
          <source>If you need a general dictionary, use the &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; module. If you need to manipulate keyword lists, use &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89167dae9b93318185a943b4d7ef66af8fd1ecaf" translate="yes" xml:space="preserve">
          <source>If you need to convert a tuple or a module child specification to a map or modify a child specification, you can use the &lt;a href=&quot;supervisor#child_spec/2&quot;&gt;&lt;code&gt;Supervisor.child_spec/2&lt;/code&gt;&lt;/a&gt; function. For example, to run the stack with a different &lt;code&gt;:id&lt;/code&gt; and a &lt;code&gt;:shutdown&lt;/code&gt; value of 10 seconds (10_000 milliseconds):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad76921951319e02147caba8a55f21b979bd0dc" translate="yes" xml:space="preserve">
          <source>If you need to pass options to the Elixir executable at the same time you use &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt;, it can be done as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c0541d61f0fa3dc5971ad5a9aedc3239c20f25" translate="yes" xml:space="preserve">
          <source>If you open up &lt;code&gt;rel/env.sh.eex&lt;/code&gt;, you will see:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13001202c030e74a6a243756fd13162b4aa903b4" translate="yes" xml:space="preserve">
          <source>If you pass &lt;code&gt;:trim_bom&lt;/code&gt; in the modes parameter, the stream will trim UTF-8, UTF-16 and UTF-32 byte order marks when reading from file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="728af62f46ec9153dd25f06ee03542653209b55d" translate="yes" xml:space="preserve">
          <source>If you prefer to use only operators or skip them, you can pass the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3676cec1bf0b821202c618090e6007102597bd" translate="yes" xml:space="preserve">
          <source>If you revisit the &lt;code&gt;KV.Registry.start_link/1&lt;/code&gt; implementation, you will remember it simply passes the options to GenServer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d6222828dfd649eaac97782a9142f48d5d1965" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;bin/foo start&lt;/code&gt;, it will start the system using a short name (&lt;code&gt;--sname&lt;/code&gt;) equal to the release name, which in this case is &lt;code&gt;foo&lt;/code&gt;. The next step is to start a system named &lt;code&gt;bar&lt;/code&gt;, so we can connect &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; together, like we did in the previous chapter. But before we achieve this, let&amp;rsquo;s talk a bit about the benefits of releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b99f38f9001edc5d832c83870cb64c18a6a5f599" translate="yes" xml:space="preserve">
          <source>If you start &lt;code&gt;bar&lt;/code&gt; while &lt;code&gt;foo&lt;/code&gt; is still running, you will see an error like the error below happen 5 times, before the application finally shuts down:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b481bb0915de73d372e211939b206d16352c309c" translate="yes" xml:space="preserve">
          <source>If you supply &lt;code&gt;message&lt;/code&gt;, information about the values will automatically be appended to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d18cb7539ec0d5066e34df4b08df26b2985b68" translate="yes" xml:space="preserve">
          <source>If you try to run our new macro, you will notice it won't even compile, complaining that the variables &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; do not exist. This is because of the ambiguity: &lt;code&gt;unquote(k)&lt;/code&gt; can either be an unquote fragment, as previously, or a regular unquote as in &lt;code&gt;unquote(kv)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3166b78eca5a26a7eac84dac5d70e8123ee75f4d" translate="yes" xml:space="preserve">
          <source>If you try to use &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt; on chardata, it will result in an argument error. For example, let's try to put a codepoint that is not representable with one byte, like &lt;code&gt;?&amp;pi;&lt;/code&gt;, inside IO data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6388f463dc6fcda17ad270beeb69b562f1892d55" translate="yes" xml:space="preserve">
          <source>If you want the task to always be restarted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6f3a865c14b0ab4a00bc5b2ae75499da91323c" translate="yes" xml:space="preserve">
          <source>If you want to capture a function from a module, you can do &lt;code&gt;&amp;amp;Module.function()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f5f07477ffa4335e8ddfc815683832c8430bb08" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted float directly to a float, &lt;a href=&quot;string#to_float/1&quot;&gt;&lt;code&gt;String.to_float/1&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f915523fedc99105cfc5944c2a0f3c36308efa" translate="yes" xml:space="preserve">
          <source>If you want to convert a string-formatted integer directly to an integer, &lt;a href=&quot;string#to_integer/1&quot;&gt;&lt;code&gt;String.to_integer/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;string#to_integer/2&quot;&gt;&lt;code&gt;String.to_integer/2&lt;/code&gt;&lt;/a&gt; can be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fea9eb1c1234b827775e497ef0f42a61c69dfa13" translate="yes" xml:space="preserve">
          <source>If you want to copy contents from an IO device to another device or do a straight copy from a source to a destination without preserving modes, check &lt;a href=&quot;#copy/3&quot;&gt;&lt;code&gt;copy/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b19bfe43f6139c3e91cf27f55ce846cdfcd3e3c1" translate="yes" xml:space="preserve">
          <source>If you want to customize formatting through a custom formatter, you can pass a &lt;code&gt;{module, function}&lt;/code&gt; tuple as the &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65bb6ace50313174bd1da312015129749bbdebb7" translate="yes" xml:space="preserve">
          <source>If you want to denote that keys that were not previously defined in the map are allowed, it is common to end a map type with &lt;code&gt;optional(any) =&amp;gt; any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c535a2a3105fc470fcf848d917b271f0d69918bc" translate="yes" xml:space="preserve">
          <source>If you want to keep a custom type private, you can use the &lt;code&gt;@typep&lt;/code&gt; directive instead of &lt;code&gt;@type&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6270ce3f8ed8957cf75b8c1784c6e548f99f8963" translate="yes" xml:space="preserve">
          <source>If you want to pattern match against an existing variable, you need to use the &lt;a href=&quot;#%255E/1&quot;&gt;&lt;code&gt;^/1&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0120649e8c4e2ba95fe6dca09a77ff652ec92d44" translate="yes" xml:space="preserve">
          <source>If you want to pattern match against an existing variable, you need to use the &lt;code&gt;^&lt;/code&gt; operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8611f45920c0ede3319c28e69a832c8f54905818" translate="yes" xml:space="preserve">
          <source>If you want to perform ceil operation on other decimal places, use &lt;a href=&quot;float#ceil/2&quot;&gt;&lt;code&gt;Float.ceil/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f71b7086446556c1e0c878a9ce96ae97c6d27fc0" translate="yes" xml:space="preserve">
          <source>If you want to perform floor operation on other decimal places, use &lt;a href=&quot;float#floor/2&quot;&gt;&lt;code&gt;Float.floor/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d23f8f45e8ee5b1da8fce75c5c1d7be726d5c9" translate="yes" xml:space="preserve">
          <source>If you want to perform floored integer division (rounding towards negative infinity), use &lt;a href=&quot;integer#floor_div/2&quot;&gt;&lt;code&gt;Integer.floor_div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d5cba5ee293ef2a94c294f0400855682db25758" translate="yes" xml:space="preserve">
          <source>If you want to perform truncated integer division (rounding towards zero), use &lt;a href=&quot;kernel#div/2&quot;&gt;&lt;code&gt;Kernel.div/2&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="097c0e312bb8668d5ea944da5700770a1becb6c4" translate="yes" xml:space="preserve">
          <source>If you want to purge all log calls from an application named &lt;code&gt;:foo&lt;/code&gt; and only keep errors from &lt;code&gt;Bar.foo/3&lt;/code&gt;, you can set up two different matches:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d73b5161b517adda283c3e0c50a4ecfba748837" translate="yes" xml:space="preserve">
          <source>If you want to recompile an existing module, check &lt;a href=&quot;#r/1&quot;&gt;&lt;code&gt;r/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1770175208fe6cb10e9c451baa7570e45537e962" translate="yes" xml:space="preserve">
          <source>If you want to reload a single module, consider using &lt;code&gt;r(ModuleName)&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22937dca14ad8e678a5773e217bdaf60e9e08640" translate="yes" xml:space="preserve">
          <source>If you want to remove all duplicated elements, regardless of order, see &lt;a href=&quot;#uniq/1&quot;&gt;&lt;code&gt;uniq/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac9b92a3ff486c5ca2aa293f505af60c2ce005a" translate="yes" xml:space="preserve">
          <source>If you want to run tests manually, you can set the &lt;code&gt;:autorun&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt; and use &lt;a href=&quot;#run/0&quot;&gt;&lt;code&gt;run/0&lt;/code&gt;&lt;/a&gt; to run tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9cfb2104d8a7fbed8970b4e565fd893c81bbbd7" translate="yes" xml:space="preserve">
          <source>If you want to search for both &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.app&lt;/code&gt; files, you could do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e20d3f7642e2bc2878445510d6350ffeaed9f321" translate="yes" xml:space="preserve">
          <source>If you want to specify more than one variable, you separate them by a comma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1680d4186a75a98ad990b5523a395b408476ac2a" translate="yes" xml:space="preserve">
          <source>If you want to unquote a value that is not a quoted expression, such as a map, you need to call &lt;a href=&quot;macro#escape/1&quot;&gt;&lt;code&gt;Macro.escape/1&lt;/code&gt;&lt;/a&gt; before:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27dac4f0c111d42a9f9a5c0743a540f0cc92e81" translate="yes" xml:space="preserve">
          <source>If you wish to find out more about GenServers, the Elixir Getting Started guide provides a tutorial-like introduction. The documentation and links in Erlang can also provide extra insight.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d47bd8dadb23934d4b2666cf77ccc81ac30266c" translate="yes" xml:space="preserve">
          <source>If you wish to use another value for the accumulator, use &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0943f45dd0efc661e7f07bd6255b9ee24dc17524" translate="yes" xml:space="preserve">
          <source>If you would like to get the result of evaluating file rather than the modules defined in it, see &lt;a href=&quot;#eval_file/2&quot;&gt;&lt;code&gt;eval_file/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe37a76c869eaf7d64eb125b004dacbfd79cc33b" translate="yes" xml:space="preserve">
          <source>If you would rather enable it on your system as a whole, you can use the &lt;code&gt;ERL_AFLAGS&lt;/code&gt; environment variable and make sure that it is set accordingly on your terminal/shell configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31456477d49264f6615f64085ad9c83e259679bd" translate="yes" xml:space="preserve">
          <source>If your Git repository requires authentication, such as basic username:password HTTP authentication via URLs, it can be achieved via Git configuration, keeping the access rules outside of source control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5250542055685fe9ce8faf48f1dcf6cf349fd3b" translate="yes" xml:space="preserve">
          <source>If your application does not have a supervision tree, one can be added by changing &lt;code&gt;def application&lt;/code&gt; inside &lt;code&gt;mix.exs&lt;/code&gt; to include a &lt;code&gt;:mod&lt;/code&gt; key with the application callback name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79acd423fb1e6c91580bcc6a424e71a397cbe715" translate="yes" xml:space="preserve">
          <source>If your implementation passes options or if you are generating custom code based on the struct, you will also need to implement a macro defined as &lt;code&gt;__deriving__(module, struct, options)&lt;/code&gt; to get the options that were passed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1087391025d5c5314dde0fa06b5f87e55efb46aa" translate="yes" xml:space="preserve">
          <source>If your use case requires exactly what GenEvent provided, or you have to integrate with an existing &lt;code&gt;:gen_event&lt;/code&gt;-based system, you can still use the &lt;a href=&quot;http://erlang.org/doc/man/gen_event.html&quot;&gt;&lt;code&gt;:gen_event&lt;/code&gt;&lt;/a&gt; Erlang module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ef21699df7b35a736d32d74888718170a41c693" translate="yes" xml:space="preserve">
          <source>If, for some reason, the current working directory cannot be retrieved, this function returns the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f29cc51be005a79b079e12bf1ac5f22f7d2dcb7" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at midnight, return {0, 1}.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41c5fa5884384a5740f83d50fb3866ac1d3665b0" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at noon, return {1, 2}.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f85da886f46e171f187e86eea72582fd0f8930c" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at sunrise, return {1, 4}.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d2c4953da7d60583c85fece795d7ebe8ed34cb1" translate="yes" xml:space="preserve">
          <source>If, in your Calendar, a new day starts at sunset, return {3, 4}.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10cb7a9f4dc8fd31623acf09d7d8af1483fab624" translate="yes" xml:space="preserve">
          <source>If, later, the &lt;code&gt;Bar&lt;/code&gt; module is moved outside the &lt;code&gt;Foo&lt;/code&gt; module definition, it must be referenced by its full name (&lt;code&gt;Foo.Bar&lt;/code&gt;) or an alias must be set using the &lt;code&gt;alias&lt;/code&gt; directive discussed above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7beb7df4077fd4d4544fa6a837476c871ba893d" translate="yes" xml:space="preserve">
          <source>If, while the code is executing, the system clock changes, some code that executed in 1 second may be reported as taking over 1 hour! To address such concerns, the VM provides a monotonic time via &lt;a href=&quot;system#monotonic_time/0&quot;&gt;&lt;code&gt;System.monotonic_time/0&lt;/code&gt;&lt;/a&gt; which never decreases and does not leap:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acce89fb4ebef796946f7cb6a71ce1c0793fa8d9" translate="yes" xml:space="preserve">
          <source>Image: negative. Swap foreground and background.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2554c2edabb99cac5d1195a237820679f650e785" translate="yes" xml:space="preserve">
          <source>Image: positive. Normal foreground and background.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4974ec0729731cbfc104f4eeb6f171651724046" translate="yes" xml:space="preserve">
          <source>Imagine a module uses a specialized list implemented in &lt;code&gt;Math.List&lt;/code&gt;. The &lt;code&gt;alias&lt;/code&gt; directive allows referring to &lt;code&gt;Math.List&lt;/code&gt; just as &lt;code&gt;List&lt;/code&gt; within the module definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6d0807e9d9e68c71a2dfa2e6c744532d48a480" translate="yes" xml:space="preserve">
          <source>Imagine someone implements &lt;code&gt;Calendar.Holocene&lt;/code&gt;, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae47eabc88af2ef4455eb932e8ea60f7ae332748" translate="yes" xml:space="preserve">
          <source>Imagine the given &quot;old&quot; code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ac66ba0efe559bd54e9f534310fa769ff5fac4" translate="yes" xml:space="preserve">
          <source>Imagine the situation you have a quoted expression and you want to inject it inside some quote. The first attempt would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f60dc9c31d90f01f4ada0187787c8518ff7e6336" translate="yes" xml:space="preserve">
          <source>Imagine you have a directory called &lt;code&gt;projects&lt;/code&gt; with three Elixir projects inside of it: &lt;code&gt;elixir&lt;/code&gt;, &lt;code&gt;ex_doc&lt;/code&gt;, and &lt;code&gt;plug&lt;/code&gt;. You can find all &lt;code&gt;.beam&lt;/code&gt; files inside the &lt;code&gt;ebin&lt;/code&gt; directory of each project as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78e853aca214a1bc65ac8ef6110f03573d680e17" translate="yes" xml:space="preserve">
          <source>Imagine you have the following structure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e874a03e71d708ca4e25914c4864e7d0682296da" translate="yes" xml:space="preserve">
          <source>Immediately halts the Erlang runtime system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="1ef5a932d18820b4b0e243f0726d914bc0a7ff10" translate="yes" xml:space="preserve">
          <source>Implementing &lt;code&gt;Any&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5796eba4ad579f1726f97515a9ac4256c827ceb8" translate="yes" xml:space="preserve">
          <source>Implementing behaviours</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b465297e29160eecd675375f9f56fd85c2f30272" translate="yes" xml:space="preserve">
          <source>Implementing functions like &lt;a href=&quot;#map/2&quot;&gt;&lt;code&gt;map/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#filter/2&quot;&gt;&lt;code&gt;filter/2&lt;/code&gt;&lt;/a&gt; and others are a good exercise for understanding the power behind &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt;. When an operation cannot be expressed by any of the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module, developers will most likely resort to &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a11cbfe39e0739e620b6472396d552890b65f2b5" translate="yes" xml:space="preserve">
          <source>Implenting the behaviour explicitly without calling &lt;a href=&quot;kernel.specialforms#super/1&quot;&gt;&lt;code&gt;super/1&lt;/code&gt;&lt;/a&gt; (v1.0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ee8b57e8a1146e8195323d5ab0ac1b28d4bf4d5" translate="yes" xml:space="preserve">
          <source>Important: do &lt;strong&gt;not&lt;/strong&gt; use this function on IO devices in Unicode mode as it will write the wrong data. In particular, the standard IO device is set to Unicode by default, so writing to stdio with this function will likely result in the wrong data being sent down the wire.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee893c3406c5d187c4ad8d2a37d2b2305b2b378" translate="yes" xml:space="preserve">
          <source>Imports configuration from the given file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d4e22f3ba03649c647ac0cbd6a6f1c75820475" translate="yes" xml:space="preserve">
          <source>Imports functions and macros from other modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9dd8afb038714101f1fa2419f409800104c52e" translate="yes" xml:space="preserve">
          <source>Imports: new functions may be added to the &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module, which is auto-imported. They may collide with local functions defined in your modules. Collisions can be resolved in a backwards compatible fashion using &lt;code&gt;import Kernel, except: [...]&lt;/code&gt; with a list of all functions you don't want to be imported from &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;. We reserve the right to do such additions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e98571e8ce38e7d695efe3ecee0b6e80bc755f3" translate="yes" xml:space="preserve">
          <source>Improper lists are never deemed as charlists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee52b5aef3534510640142b73884d80c6b12f47" translate="yes" xml:space="preserve">
          <source>Improper lists are not printable, even if made only of ASCII characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0d4390b7f52bc3219b6b297954aa2698cd9b21f" translate="yes" xml:space="preserve">
          <source>In &amp;ldquo;Basic types&amp;rdquo;, we learned about strings and used the &lt;code&gt;is_binary/1&lt;/code&gt; function for checks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96d506b973cc16f3c887c604680a4f164c5bcb6d" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;keywords-and-maps&quot;&gt;chapter 7&lt;/a&gt; we learned about maps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b97f6da29f9d3821af09c9644f82422d41ba54db" translate="yes" xml:space="preserve">
          <source>In Elixir we group several functions into modules. We&amp;rsquo;ve already used many different modules in the previous chapters such as &lt;a href=&quot;https://hexdocs.pm/elixir/String.html&quot;&gt;the &lt;code&gt;String&lt;/code&gt; module&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8852e2c2070399b66b8e6aac0c4ebb222e49ff1d" translate="yes" xml:space="preserve">
          <source>In Elixir, &lt;code&gt;Integer.is_odd/1&lt;/code&gt; is defined as a macro so that it can be used as a guard. This means that, in order to invoke &lt;code&gt;Integer.is_odd/1&lt;/code&gt;, we need to first require the &lt;code&gt;Integer&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84a15dcd0ed954400244a91382ebe28f35c7326d" translate="yes" xml:space="preserve">
          <source>In Elixir, a value can be thrown and later be caught. &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt; are reserved for situations where it is not possible to retrieve a value unless by using &lt;code&gt;throw&lt;/code&gt; and &lt;code&gt;catch&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f7dc2374bd2e474c5f95f1dc00588968670f4e9" translate="yes" xml:space="preserve">
          <source>In Elixir, all code runs inside processes. Processes are isolated from each other, run concurrent to one another and communicate via message passing. Processes are not only the basis for concurrency in Elixir, but they also provide the means for building distributed and fault-tolerant programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd7da208c379530ff673f8c5363361cec7ce112" translate="yes" xml:space="preserve">
          <source>In Elixir, an enumerable is any data type that implements the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol. &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;[1, 2, 3]&lt;/code&gt;), &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;%{foo: 1, bar: 2}&lt;/code&gt;) and &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;s (&lt;code&gt;1..3&lt;/code&gt;) are common data types used as enumerables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad60a1595fcaea2abc6cfb534bb59968e6aa0a7d" translate="yes" xml:space="preserve">
          <source>In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa0691e43ac9902c05a55318172be1be3b51602d" translate="yes" xml:space="preserve">
          <source>In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a GenServer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a65801df985cbe3e3c9ee19ff7e4341c68a0a15" translate="yes" xml:space="preserve">
          <source>In Elixir, different data types can be compared using comparison operators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ef291ece743ba126271fab00a84b2bf1cd10359" translate="yes" xml:space="preserve">
          <source>In Elixir, it is common to loop over an Enumerable, often filtering out some results and mapping values into another list. Comprehensions are syntactic sugar for such constructs: they group those common tasks into the &lt;code&gt;for&lt;/code&gt; special form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92fa98b368b718157a766ec2a187b1b728ee06ed" translate="yes" xml:space="preserve">
          <source>In Elixir, records are used mostly in two situations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19e018a4aa4ddd6ea9b4d083bf7991661ac6f619" translate="yes" xml:space="preserve">
          <source>In Elixir, the &lt;code&gt;=&lt;/code&gt; operator is actually called &lt;em&gt;the match operator&lt;/em&gt;. Let&amp;rsquo;s see why:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="482c60a7cfc2af43cfa398215016e9bcabca31ff" translate="yes" xml:space="preserve">
          <source>In Elixir, this is done by a Supervisor. A Supervisor is a process that supervises other processes and restarts them whenever they crash. To do so, Supervisors manage the whole life-cycle of any supervised processes, including startup and shutdown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d542894f9023e77ee4252a95cfc7fdde16bf1f" translate="yes" xml:space="preserve">
          <source>In Elixir, we avoid using &lt;code&gt;try/rescue&lt;/code&gt; because &lt;strong&gt;we don&amp;rsquo;t use errors for control flow&lt;/strong&gt;. We take errors literally: they are reserved for unexpected and/or exceptional situations. In case you actually need flow control constructs, &lt;em&gt;throws&lt;/em&gt; should be used. That&amp;rsquo;s what we are going to see next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b26350d75961840721899e4e896ada8152ee4ff0" translate="yes" xml:space="preserve">
          <source>In Elixir, we can compare two different data types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99415fb48cc7bcce7ee941711b73cb718fae4683" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two idioms for checking how many items there are in a data structure: &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;. &lt;code&gt;length&lt;/code&gt; means the information must be computed. For example, &lt;code&gt;length(list)&lt;/code&gt; needs to traverse the whole list to calculate its length. On the other hand, &lt;code&gt;tuple_size(tuple)&lt;/code&gt; and &lt;code&gt;byte_size(binary)&lt;/code&gt; do not depend on the tuple and binary size as the size information is pre-computed in the data structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3be4753dceb5fddab1fdca38953766786eecc42" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two main associative data structures: keyword lists and maps. It&amp;rsquo;s time to learn more about them!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb8d41ba02e8fc631535705b4f2e08988507e70" translate="yes" xml:space="preserve">
          <source>In Elixir, we have two verbs for checking how many items there are in a data structure: &lt;code&gt;length&lt;/code&gt; and &lt;code&gt;size&lt;/code&gt;. &lt;code&gt;length&lt;/code&gt; means the information must be computed. For example, &lt;code&gt;length(list)&lt;/code&gt; needs to traverse the whole list to calculate its length. On the other hand, &lt;code&gt;tuple_size(tuple)&lt;/code&gt; and &lt;code&gt;byte_size(binary)&lt;/code&gt; do not depend on the tuple and binary size as the size information is precomputed in the data structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e9adf90c14fca15cafcd8d80e7a0e62f3c9bd2b" translate="yes" xml:space="preserve">
          <source>In Elixir, you can define a binary using &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3508879bcb04190c581cc69dedcf57a9400be46d" translate="yes" xml:space="preserve">
          <source>In Erlang, this struct is represented by a &lt;code&gt;:file_info&lt;/code&gt; record. Therefore this module also provides functions for converting between the Erlang record and the Elixir struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08902136d46a0efffdb0a07180738ce463f3cf44" translate="yes" xml:space="preserve">
          <source>In Mix projects, the environment of the application and its dependencies can be overridden via the &lt;code&gt;config/config.exs&lt;/code&gt; file. If you start the application with Mix, that configuration is available at compile time, and at runtime too, but take into account it is not included in the generated application resource file, and it is not available if you start the application without Mix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9174170a472a8f04a70eb2658745c2e8ceaf3c42" translate="yes" xml:space="preserve">
          <source>In Unix-like systems, changing the modification time may require you to be either &lt;code&gt;root&lt;/code&gt; or the owner of the file. Having write access may not be enough. In those cases, touching the file the first time (to create it) will succeed, but touching an existing file with fail with &lt;code&gt;{:error, :eperm}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0de5ec7fc6835af5a7c8c3ee0628180b848d8db4" translate="yes" xml:space="preserve">
          <source>In a GenServer, the code above would be two separate functions, roughly like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcadbac52f644d8178e01dd98a388d6072c88e19" translate="yes" xml:space="preserve">
          <source>In a distributed setup with multiple nodes, the API that accepts anonymous functions only works if the caller (client) and the agent have the same version of the caller module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93de78b9e89412d553d71ba4abbfe5315731105f" translate="yes" xml:space="preserve">
          <source>In a nutshell, a version is represented by three numbers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4de3e72994971159efbbfa51adb4f6daeb251a7f" translate="yes" xml:space="preserve">
          <source>In a nutshell, an application consists of all of the modules defined in the &lt;code&gt;.app&lt;/code&gt; file, including the &lt;code&gt;.app&lt;/code&gt; file itself. An application has generally only two directories: &lt;code&gt;ebin&lt;/code&gt;, for Elixir artefacts, such as &lt;code&gt;.beam&lt;/code&gt; and &lt;code&gt;.app&lt;/code&gt; files, and &lt;code&gt;priv&lt;/code&gt;, with any other artefact or asset you may need in your application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a78c9d971b121556059db385274a3963a89d465" translate="yes" xml:space="preserve">
          <source>In a nutshell, the first must be used when you want to keep track of the files handled by the system, to avoid the same file from being compiled multiple times. This is common in scripts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba31b6b4506414b36091cbb58f049c0003b3112c" translate="yes" xml:space="preserve">
          <source>In a regular project, we can assemble a release by simply running &lt;code&gt;mix release&lt;/code&gt;. However, we have an umbrella project, and in such cases Elixir requires some extra input from us. Let&amp;rsquo;s see what is necessary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9421fd8baf899a704905f1b7b921c58ff7bb458" translate="yes" xml:space="preserve">
          <source>In addition to the Elixir file extension &lt;code&gt;.ex&lt;/code&gt;, Elixir also supports &lt;code&gt;.exs&lt;/code&gt; files for scripting. Elixir treats both files exactly the same way, the only difference is in intention. &lt;code&gt;.ex&lt;/code&gt; files are meant to be compiled while &lt;code&gt;.exs&lt;/code&gt; files are used for scripting. When executed, both extensions compile and load their modules into memory, although only &lt;code&gt;.ex&lt;/code&gt; files write their bytecode to disk in the format of &lt;code&gt;.beam&lt;/code&gt; files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96148bc0703e1fb4ea78297b10992f7426df74e8" translate="yes" xml:space="preserve">
          <source>In addition to the built-in attributes outlined above, custom attributes may also be added. Custom attributes are expressed using the &lt;a href=&quot;kernel#@/1&quot;&gt;&lt;code&gt;@/1&lt;/code&gt;&lt;/a&gt; operator followed by a valid variable name. The value given to the custom attribute must be a valid Elixir value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dfd563836d0d4567f592fdf1b54449f8fc77413" translate="yes" xml:space="preserve">
          <source>In addition to the keys provided by the user via &lt;a href=&quot;logger#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt;, the following extra keys are available to the &lt;code&gt;:metadata&lt;/code&gt; list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1d0e9c42e96c43f7a51f23eb3e0a63cd08fcabb" translate="yes" xml:space="preserve">
          <source>In addition to those, a double quote inside a double-quoted string needs to be escaped as &lt;code&gt;\&quot;&lt;/code&gt;, and, analogously, a single quote inside a single-quoted char list needs to be escaped as &lt;code&gt;\'&lt;/code&gt;. Nevertheless, it is better style to change delimiters as seen above than to escape them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e21312ebc75f6d03fffd3a474b80ff1f053e1d" translate="yes" xml:space="preserve">
          <source>In all of the examples above, we used binaries when writing to files. In the chapter &lt;a href=&quot;binaries-strings-and-char-lists&quot;&gt;&amp;ldquo;Binaries, strings, and charlists&amp;rdquo;&lt;/a&gt;, we mentioned how strings are made of bytes while charlists are lists with Unicode codepoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e799b4247b90ad4aaf06f6677263f125c9b2f4f" translate="yes" xml:space="preserve">
          <source>In any case, avoid any of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1589dd45f78cf7266ba6322f20d21e370ee7f5aa" translate="yes" xml:space="preserve">
          <source>In both cases, &lt;code&gt;Stack.start_link/1&lt;/code&gt; is always invoked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ea2013003c5c58a5c3f717cccfc60a91074f95a" translate="yes" xml:space="preserve">
          <source>In both cases, the command-line arguments for the script or expression are available in &lt;a href=&quot;https://hexdocs.pm/elixir/System.html#argv/0&quot;&gt;&lt;code&gt;System.argv/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d33c9b688f2fa1ee1c39e6a6ee8a9eef85fb236" translate="yes" xml:space="preserve">
          <source>In case a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function returns a &lt;code&gt;:suspend&lt;/code&gt; accumulator, it must be explicitly handled by the caller and never leak.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f1586eeab6e7c0484c69613b04bc3194eb4e79" translate="yes" xml:space="preserve">
          <source>In case a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function returns the &lt;code&gt;:suspend&lt;/code&gt; accumulator, the &lt;code&gt;:suspended&lt;/code&gt; tuple must be explicitly handled by the caller and never leak. In practice, this means regular enumeration functions just need to be concerned about &lt;code&gt;:done&lt;/code&gt; and &lt;code&gt;:halted&lt;/code&gt; results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3377f61918ce91a5a78e38bc72a8ef4ed3572f98" translate="yes" xml:space="preserve">
          <source>In case a direct relative path cannot be found, it returns the original path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c9cc568db359a5124dd032595b36cc1734cb7b5" translate="yes" xml:space="preserve">
          <source>In case a single file is being tested, it is possible to pass one or more specific line numbers to run only those given tests:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="702e65eacb180decf2c9dac0a4fdd10013882322" translate="yes" xml:space="preserve">
          <source>In case a switch &lt;code&gt;SWITCH&lt;/code&gt; is specified to have type &lt;code&gt;:boolean&lt;/code&gt;, it may be passed as &lt;code&gt;--no-SWITCH&lt;/code&gt; as well which will set the option to &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="888f992f5fc265705743ba6ca955221f42ebdba1" translate="yes" xml:space="preserve">
          <source>In case any entry returns &lt;code&gt;nil&lt;/code&gt;, its key will be removed and the deletion will be considered a success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a72e1cfffefe65681b735eb6f7dbafbbce0c5ef9" translate="yes" xml:space="preserve">
          <source>In case any of the entries in the middle returns &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;nil&lt;/code&gt; will be returned as per the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de3e20065397014cb42d9b910dde02ad6289d161" translate="yes" xml:space="preserve">
          <source>In case any of the entries in the middle returns &lt;code&gt;nil&lt;/code&gt;, an error will be raised when trying to access it next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffe6dece0fc6fa31895ca4664fd38ac481329ebd" translate="yes" xml:space="preserve">
          <source>In case it does exist, it is a no-op. Otherwise, it is built.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe785d8d01b549120d0fdba2f98502200395bc4b" translate="yes" xml:space="preserve">
          <source>In case one wants to access the original &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;, it can be done by accessing &lt;code&gt;Elixir&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3773025824eaaa4fbaabc9e17eece745001ea94" translate="yes" xml:space="preserve">
          <source>In case something goes wrong, you can also use &lt;a href=&quot;#exit/1&quot;&gt;&lt;code&gt;exit/1&lt;/code&gt;&lt;/a&gt; with a different reason:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa86b82adf3327a6ba51dace9ac5f0221aed458" translate="yes" xml:space="preserve">
          <source>In case the alias is generated automatically by a macro, Elixir won't emit any warnings though, since the alias was not explicitly defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c438ea8f1248a5429d6990102993e9d6dbcfa2ca" translate="yes" xml:space="preserve">
          <source>In case the conversion fails, it raises an &lt;a href=&quot;unicodeconversionerror&quot;&gt;&lt;code&gt;UnicodeConversionError&lt;/code&gt;&lt;/a&gt;. If a string is given, it returns the string itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15baa5f03723748dcf10b5cb52af46c921885dc" translate="yes" xml:space="preserve">
          <source>In case the file doesn't exist, an error is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aefc659b37d49c39922094af9efb51756248b09" translate="yes" xml:space="preserve">
          <source>In case the import is generated automatically by a macro, Elixir won't emit any warnings though, since the import was not explicitly defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f7982ac3a103bc11a1e2ceb070d36fd43cc0956" translate="yes" xml:space="preserve">
          <source>In case the task process dies, the current process will exit with the same reason as the task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5028298a69062b4bcef1005e365f72fcb9b4bd2c" translate="yes" xml:space="preserve">
          <source>In case the test crashes, you will see a report as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f761d55661dfac505485cc96ef395b1517c85a" translate="yes" xml:space="preserve">
          <source>In case there is an error while your structure is being inspected, Elixir will raise an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; error and will automatically fall back to a raw representation for printing the structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05066096207f29449b516520b228a698f4b4f25c" translate="yes" xml:space="preserve">
          <source>In case there is no such message, the current process hangs until a message arrives or waits until a given timeout value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d02c8c3170ba0952169ceddc222a7d17ada7459" translate="yes" xml:space="preserve">
          <source>In case things are not working as expected, please include as much information as you can in your report, for example: your Elixir version, the code snippet and the error message alongside the error stacktrace. Use sites like &lt;a href=&quot;https://gist.github.com/&quot;&gt;Gist&lt;/a&gt; to paste this information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03bcf5fae6ba2e97dc4c9b6b526c4e8e1ed5a2fc" translate="yes" xml:space="preserve">
          <source>In case you need to configure a process, the options should be passed when starting that process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402b42bb4e09e34f8b56390600a6d4385db6ff6a" translate="yes" xml:space="preserve">
          <source>In case you need to work with bytes, take a look at the &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;&lt;code&gt;:binary&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccc59a70627542b407463a1a5ab11815a7059a36" translate="yes" xml:space="preserve">
          <source>In case you want to automatically load &lt;strong&gt;and start&lt;/strong&gt; all of &lt;code&gt;app&lt;/code&gt;'s dependencies, see &lt;a href=&quot;#ensure_all_started/2&quot;&gt;&lt;code&gt;ensure_all_started/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f681ed2c3aa6661367fb62449b5900050c12c47" translate="yes" xml:space="preserve">
          <source>In case you want to provide some existing functionality to the user module, please define it in a module which will be imported accordingly; for example, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; doesn't define the &lt;code&gt;test/3&lt;/code&gt; macro in the module that calls &lt;code&gt;use ExUnit.Case&lt;/code&gt;, but it defines &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#test/3&quot;&gt;&lt;code&gt;ExUnit.Case.test/3&lt;/code&gt;&lt;/a&gt; and just imports that into the caller when used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff348aca712691651b4c435346c7c87f48a03c6" translate="yes" xml:space="preserve">
          <source>In case you were using the deprecated &lt;code&gt;:simple_one_for_one&lt;/code&gt; strategy from the &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt; module, you can migrate to the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DynamicSupervisor&lt;/code&gt;&lt;/a&gt; in few steps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3fa04a38e1468a79c7262b85ac96321cc9efef6" translate="yes" xml:space="preserve">
          <source>In contrast to keyword lists, maps are very useful with pattern matching. When a map is used in a pattern, it will always match on a subset of the given value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0cd3de6db0a42db7660ce1f70c833f42728634" translate="yes" xml:space="preserve">
          <source>In contrast, the values for the called functions describe those functions, but in the context of the marked function. For example, the last row means that &lt;code&gt;Mod.called2/0&lt;/code&gt; was called once by &lt;code&gt;Mod.some_function/0&lt;/code&gt;, and in that case the total time spent in the function was 50ms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4add0dde66d9d0296a0654de0562024d8f9f79" translate="yes" xml:space="preserve">
          <source>In fact, &lt;a href=&quot;erlangerror&quot;&gt;&lt;code&gt;ErlangError&lt;/code&gt;&lt;/a&gt; can be used to rescue any error that is not a proper Elixir error. For example, it can be used to rescue the earlier &lt;code&gt;:badarg&lt;/code&gt; error too, prior to transformation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0899943a58fd70e4f3d0ccf56e136c5b02dd5f31" translate="yes" xml:space="preserve">
          <source>In fact, connecting to remote shells is so common that we provide a shortcut via the command line as well:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d8ddd11e7d11d4d1da78d64c3d55a307dc74a3" translate="yes" xml:space="preserve">
          <source>In fact, let&amp;rsquo;s open up &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61139d4b1bbde59322a4c8bca7a0561709d9841c" translate="yes" xml:space="preserve">
          <source>In fact, the &lt;code&gt;:bind_quoted&lt;/code&gt; option is recommended every time one desires to inject a value into the quote.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e63bd9e9e19b982359b9cda4d5fcbeea34909a27" translate="yes" xml:space="preserve">
          <source>In fact, this pattern is so common that most of the times you will want to use the &lt;code&gt;bind_quoted&lt;/code&gt; option with &lt;a href=&quot;#quote/2&quot;&gt;&lt;code&gt;quote/2&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be090f2c7b49fa10f6982f61cbff56e2c1ea6990" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;underscore&lt;/code&gt; can be thought of as the reverse of &lt;code&gt;camelize&lt;/code&gt;, however, in some cases formatting may be lost:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a3e2a29096c65e2eb89f937c17a4004e7ef7444" translate="yes" xml:space="preserve">
          <source>In general, a developer should use the former in case they want to react if the file does not exist. The latter should be used when the developer expects their software to fail in case the file cannot be read (i.e. it is literally an exception).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d16c9ac73c5397997e3e76ab325334e002852804" translate="yes" xml:space="preserve">
          <source>In general, a developer will want to use the general &lt;code&gt;assert&lt;/code&gt; macro in tests. This macro introspects your code and provides good reporting whenever there is a failure. For example, &lt;code&gt;assert some_fun() == 10&lt;/code&gt; will fail (assuming &lt;code&gt;some_fun()&lt;/code&gt; returns &lt;code&gt;13&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d41e104bfcea8fdabed0cd450572fc2e4bac9f" translate="yes" xml:space="preserve">
          <source>In general, the functions in this module rely on the Unicode Standard, but do not contain any of the locale specific behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9716a12a8a55aca30fe284f4ffccd27a063bec" translate="yes" xml:space="preserve">
          <source>In general, the tuples above are structured according to the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de751c2f24f5d6947a334c2b635bc5f4ec33c5a" translate="yes" xml:space="preserve">
          <source>In general, when the keyword list is the last argument of a function, the square brackets are optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bab1cb15297331e40b3f50701fea2260e1dfe89" translate="yes" xml:space="preserve">
          <source>In guards, when functions would normally raise exceptions, they cause the guard to fail instead. For example, the &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; function only works with lists. If we use it with anything else, a runtime error is raised:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a530de2468aeae84b5f9a5ab3d0835429e502343" translate="yes" xml:space="preserve">
          <source>In light of this observation, we should consider moving to another supervision strategy. The two other candidates are &lt;code&gt;:one_for_all&lt;/code&gt; and &lt;code&gt;:rest_for_one&lt;/code&gt;. A supervisor using the &lt;code&gt;:rest_for_one&lt;/code&gt; strategy will kill and restart child processes which were started &lt;em&gt;after&lt;/em&gt; the crashed child. In this case, we would want &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; to terminate if &lt;code&gt;KV.Registry&lt;/code&gt; terminates. This would require the bucket supervisor to be placed after the registry which violates the ordering constraints we have established two paragraphs above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287c5e7fdc75892fe61a19be625743d753001a1c" translate="yes" xml:space="preserve">
          <source>In macro code, the bang on &lt;a href=&quot;kernel#alias!/1&quot;&gt;&lt;code&gt;Kernel.alias!/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;kernel#var!/2&quot;&gt;&lt;code&gt;Kernel.var!/2&lt;/code&gt;&lt;/a&gt; signifies that &lt;a href=&quot;https://elixir-lang.org/getting-started/meta/macros.html#macros-hygiene&quot;&gt;macro hygiene&lt;/a&gt; is set aside.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32bcee841524dde12cdf73859245e9378a9b1abe" translate="yes" xml:space="preserve">
          <source>In many cases it is more convenient to pass the expected value to &lt;a href=&quot;#raise/2&quot;&gt;&lt;code&gt;raise/2&lt;/code&gt;&lt;/a&gt; and generate the message in the &lt;a href=&quot;exception#c:exception/1&quot;&gt;&lt;code&gt;Exception.exception/1&lt;/code&gt;&lt;/a&gt; callback:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a407dd1ba9629c2d87378f7214d938dbbf397b" translate="yes" xml:space="preserve">
          <source>In many cases, we can take advantage of this. In the code above, we used &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; to both check that the given thing is a list &lt;em&gt;and&lt;/em&gt; check some properties of its length (instead of using &lt;code&gt;is_list(something) and length(something) &amp;gt; 0&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1718d61cb1f8d442d32bbf909dd936aa49ffeb46" translate="yes" xml:space="preserve">
          <source>In many functional programming languages, it is common to use a list of 2-item tuples as the representation of a key-value data structure. In Elixir, when we have a list of tuples and the first item of the tuple (i.e. the key) is an atom, we call it a keyword list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e23cbb5429660e2faf1806ef4a612c49708bf4" translate="yes" xml:space="preserve">
          <source>In most cases, &lt;a href=&quot;#ensure_loaded/1&quot;&gt;&lt;code&gt;ensure_loaded/1&lt;/code&gt;&lt;/a&gt; is enough. &lt;a href=&quot;#ensure_compiled/1&quot;&gt;&lt;code&gt;ensure_compiled/1&lt;/code&gt;&lt;/a&gt; must be used in rare cases, usually involving macros that need to invoke a module for callback information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423cb3333a43148ea91fc3b7a37efcd42c886681" translate="yes" xml:space="preserve">
          <source>In order for the cache mechanism to work, the created ETS table needs to have access &lt;code&gt;:protected&lt;/code&gt; (the default), so all clients can read from it, while only the &lt;code&gt;KV.Registry&lt;/code&gt; process writes to it. We have also set &lt;code&gt;read_concurrency: true&lt;/code&gt; when starting the table, optimizing the table for the common scenario of concurrent read operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81c6a20ae394a892047f71306226257ed4ae14b" translate="yes" xml:space="preserve">
          <source>In order to be loaded, an &lt;code&gt;.app&lt;/code&gt; file must be in the load paths. All &lt;code&gt;:included_applications&lt;/code&gt; will also be loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ce310cabbc38fde237e6f7456d065921f47f408" translate="yes" xml:space="preserve">
          <source>In order to better understand how macros work, let&amp;rsquo;s create a new module where we are going to implement &lt;code&gt;unless&lt;/code&gt;, which does the opposite of &lt;code&gt;if&lt;/code&gt;, as a macro and as a function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98bbe9c7dc0c95fe1893b767af4a2559d441e9f7" translate="yes" xml:space="preserve">
          <source>In order to build a variable, a context is expected. Most of the times, in order to preserve hygiene, the context must be &lt;a href=&quot;kernel.specialforms#__MODULE__/0&quot;&gt;&lt;code&gt;__MODULE__/0&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09c48209d831c8b2ec6ba4ec948897b23f18046a" translate="yes" xml:space="preserve">
          <source>In order to build our key-value application, we are going to use three main tools:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1ca29d2377c1f8fa9329bcdb6aca022dc1f156" translate="yes" xml:space="preserve">
          <source>In order to compare more than two clauses, the &lt;a href=&quot;kernel.specialforms#cond/1&quot;&gt;&lt;code&gt;cond/1&lt;/code&gt;&lt;/a&gt; macro has to be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bdbf00ad68adfada8cf0d80c6af387a4904e12d" translate="yes" xml:space="preserve">
          <source>In order to configure Mix, the module that &lt;code&gt;use&lt;/code&gt;s &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Mix.Project&lt;/code&gt;&lt;/a&gt; should export a &lt;code&gt;project/0&lt;/code&gt; function that returns a keyword list representing configuration for the project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb392bb5990ef3fcaeb5fa0f99e17c04d60d3ab" translate="yes" xml:space="preserve">
          <source>In order to continue evolving the language without introducing breaking changes, Elixir will rely on deprecations to demote certain practices and promote new ones. Our deprecation policy is outlined in the &lt;a href=&quot;#deprecations&quot;&gt;&quot;Deprecations&quot; section&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642f4f188110996b3a0b6c3fdce8b893ead2d9fa" translate="yes" xml:space="preserve">
          <source>In order to cope with code loading in development, protocols in Elixir provide a slow implementation of protocol dispatching specific to development.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2b5841e9d7864def29c3c36d34a45ef5565969" translate="yes" xml:space="preserve">
          <source>In order to create our own modules in Elixir, we use the &lt;code&gt;defmodule&lt;/code&gt; macro. We use the &lt;code&gt;def&lt;/code&gt; macro to define functions in that module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4adfde6fe98ff6cd24536d794e886a1f37546977" translate="yes" xml:space="preserve">
          <source>In order to facilitate software reuse, Elixir provides three directives (&lt;code&gt;alias&lt;/code&gt;, &lt;code&gt;require&lt;/code&gt; and &lt;code&gt;import&lt;/code&gt;) plus a macro called &lt;code&gt;use&lt;/code&gt; summarized below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06a700b11907ab62d5a4a0a6df97c7759ea5d0ae" translate="yes" xml:space="preserve">
          <source>In order to finish our &lt;code&gt;TestCase&lt;/code&gt; implementation, we need to be able to access all defined test cases. One way of doing this is by retrieving the tests at runtime via &lt;code&gt;__MODULE__.__info__(:functions)&lt;/code&gt;, which returns a list of all functions in a given module. However, considering that we may want to store more information about each test besides the test name, a more flexible approach is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a3e4590add882007f47566c77c18638d716efc" translate="yes" xml:space="preserve">
          <source>In order to fix the failing test, let&amp;rsquo;s create a file at &lt;code&gt;lib/kv/bucket.ex&lt;/code&gt; with the contents below. Feel free to give a try at implementing the &lt;code&gt;KV.Bucket&lt;/code&gt; module yourself using agents before peeking at the implementation below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7b18c46cad921ea2c996d18c66b0c78849816d" translate="yes" xml:space="preserve">
          <source>In order to fix this bug, we need the registry to monitor every bucket it spawns. Once we set up a monitor, the registry will receive a notification every time a bucket process exits, allowing us to clean the registry up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a956c6b95ce875304570bf71071ca672fa7f12b" translate="yes" xml:space="preserve">
          <source>In order to get your first project started, Elixir ships with a build tool called Mix. You can get your new project started by running:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="017fd6a1081d196daafbd3b60fc590b568ac6071" translate="yes" xml:space="preserve">
          <source>In order to help IEx understand that an expression consists of multiple lines we can wrap it into parentheses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a957b1a9d6df7d7ce8fa55bcc89ebc9a60d14634" translate="yes" xml:space="preserve">
          <source>In order to invoke the callbacks above, we need to go through the corresponding &lt;code&gt;GenServer&lt;/code&gt; functions. Let&amp;rsquo;s start a registry, create a named bucket, and then look it up:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af452841dd75bb4a44c38345c300f4a14d20c04a" translate="yes" xml:space="preserve">
          <source>In order to make our server handle simultaneous connections, we need to have one process working as an acceptor that spawns other processes to serve requests. One solution would be to change:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3a8a476eb42420a16666c234250ab684a970ce4" translate="yes" xml:space="preserve">
          <source>In order to manipulate keyword lists, Elixir provides &lt;a href=&quot;https://hexdocs.pm/elixir/Keyword.html&quot;&gt;the &lt;code&gt;Keyword&lt;/code&gt; module&lt;/a&gt;. Remember, though, keyword lists are simply lists, and as such they provide the same linear performance characteristics as lists. The longer the list, the longer it will take to find a key, to count the number of items, and so on. For this reason, keyword lists are used in Elixir mainly for passing optional values. If you need to store many items or guarantee one-key associates with at maximum one-value, you should use maps instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af5b1e73788ff17dca0429ef7ffa66ff44df9939" translate="yes" xml:space="preserve">
          <source>In order to run distributed code, we need to start the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c900a7e8363bd8d8183eca353b3f640ed385cc" translate="yes" xml:space="preserve">
          <source>In order to run the first test, we need to have two nodes running. Move into &lt;code&gt;apps/kv&lt;/code&gt; and let&amp;rsquo;s restart the node named &lt;code&gt;bar&lt;/code&gt; which is going to be used by tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a048080239b32ae9270b349a43b94c3e07e07c" translate="yes" xml:space="preserve">
          <source>In order to speed up dispatching in production environments, where all implementations are known up-front, Elixir provides a feature called protocol consolidation. Consolidation directly links protocols to their implementations in a way that invoking a function from a consolidated protocol is equivalent to invoking two remote functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d8b39acde42481af0b84b36b66305d49c434a4a" translate="yes" xml:space="preserve">
          <source>In order to start a supervisor, we need to first define a child process that will be supervised. As an example, we will define a GenServer that represents a stack:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="656310fbcb50af634eac84272798b02ab00dba6a" translate="yes" xml:space="preserve">
          <source>In order to understand the underlying code, we&amp;rsquo;d need macros, so we will revisit this pattern in the meta-programming guide. However, the focus here is on how using module attributes as storage allows developers to create DSLs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca6c027f8dcdd141de11fbd20d5f0afb503fc0f" translate="yes" xml:space="preserve">
          <source>In order to use dependencies, you need to add a &lt;code&gt;:deps&lt;/code&gt; key to your project configuration. We often extract the list of dependencies into its own function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5cbfc0efc9a5e4905ac0bfbf89bf8917d5354f" translate="yes" xml:space="preserve">
          <source>In order to use the application environment in our code, we need to replace &lt;code&gt;KV.Router.table/0&lt;/code&gt; with the definition below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd42d7d1276fbdd4330c63012ce7d34e85da421" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in &lt;code&gt;:binary&lt;/code&gt; mode, which requires the functions &lt;a href=&quot;io#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file and then all other functions from &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; are available, since they work directly with Unicode data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ce7a0943dbb663e7fc6760db6023cf3368a14d" translate="yes" xml:space="preserve">
          <source>In order to write and read files, one must use the functions in the &lt;a href=&quot;io&quot;&gt;&lt;code&gt;IO&lt;/code&gt;&lt;/a&gt; module. By default, a file is opened in binary mode, which requires the functions &lt;a href=&quot;io#binread/2&quot;&gt;&lt;code&gt;IO.binread/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#binwrite/2&quot;&gt;&lt;code&gt;IO.binwrite/2&lt;/code&gt;&lt;/a&gt; to interact with the file. A developer may pass &lt;code&gt;:utf8&lt;/code&gt; as an option when opening the file, then the slower &lt;a href=&quot;io#read/2&quot;&gt;&lt;code&gt;IO.read/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#write/2&quot;&gt;&lt;code&gt;IO.write/2&lt;/code&gt;&lt;/a&gt; functions must be used as they are responsible for doing the proper conversions and providing the proper data guarantees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31ee06abc4e001e3f6a5b13f3dfe4953038e624e" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;&amp;amp;(&amp;amp;1 * 2)&lt;/code&gt; is equivalent to &lt;code&gt;fn x -&amp;gt; x * 2 end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="886ca2f2765b1ff87730f7dc9a052f3a738d7792" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;&amp;lt;%= @foo %&amp;gt;&lt;/code&gt; translates to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93125c6aa3c9fdcea503c87c1c3998ce536dbba7" translate="yes" xml:space="preserve">
          <source>In other words, &lt;strong&gt;do not&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d77f8954062d90a90e9c6b5408cf752db4ed5cd" translate="yes" xml:space="preserve">
          <source>In other words, Elixir will only parse options that are used by the runtime, ignoring all others. If you would like to parse all switches, regardless if they exist or not, you can force creation of atoms by passing &lt;code&gt;allow_nonexistent_atoms: true&lt;/code&gt; as option. Use this option with care. It is only useful when you are building command-line applications that receive dynamically-named arguments and must be avoided in long-running systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38fe91f6b4425a57a05293a344c316d610b9df57" translate="yes" xml:space="preserve">
          <source>In other words, functions using the word &quot;size&quot; in its name will take the same amount of time whether the data structure is tiny or huge. Conversely, functions having &quot;length&quot; in its name will take more time as the data structure grows in size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a4e6e4835459586a75795caa4bfdc4a5131e02" translate="yes" xml:space="preserve">
          <source>In other words, if it is important that a process cleans after itself when your application or the supervision tree is shutting down, then this process must trap exits and its child specification should specify the proper &lt;code&gt;:shutdown&lt;/code&gt; value, ensuring it terminates within a reasonable interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f496a7679d30119adb2cc52d4073c178807ab2e" translate="yes" xml:space="preserve">
          <source>In other words, it is important to make a distinction between a regular Elixir value (like a list, a map, a process, a reference, etc) and a quoted expression. Some values, such as integers, atoms, and strings, have a quoted expression equal to the value itself. Other values, like maps, need to be explicitly converted. Finally, values like functions and references cannot be converted to a quoted expression at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6de004f8f04712ff0ec3d814c33ef7cd9f1fbc8d" translate="yes" xml:space="preserve">
          <source>In other words, the atom &lt;code&gt;:jos&amp;eacute;&lt;/code&gt; can only be written with the code points &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt;. Using another normalization form will lead to a tokenizer error. On the other hand, &lt;code&gt;:&quot;jos&amp;eacute;&quot;&lt;/code&gt; may be written as &lt;code&gt;006A 006F 0073 00E9&lt;/code&gt; or &lt;code&gt;006A 006F 0073 0065 0301&lt;/code&gt;, since it is written between quotes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46592ea6e94de48f6246d5ad4aa9e7f178675e1" translate="yes" xml:space="preserve">
          <source>In other words, the expression above simply translates to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf94a3991ed1b9e98b23fc9feebaf13e89fbcbfd" translate="yes" xml:space="preserve">
          <source>In other words, this function tries to strip the &lt;code&gt;from&lt;/code&gt; prefix from &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05304a75e275a349e9ffa834cabff9641ce49488" translate="yes" xml:space="preserve">
          <source>In other words, this module expects invalid data to be detected elsewhere, usually when retrieving data from the external source. For example, a driver that reads strings from a database will be responsible to check the validity of the encoding. &lt;a href=&quot;string#chunk/2&quot;&gt;&lt;code&gt;String.chunk/2&lt;/code&gt;&lt;/a&gt; can be used for breaking a string into valid and invalid parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="558d46588b101dc23bc0d5fd0f4acaf2b4c0f74f" translate="yes" xml:space="preserve">
          <source>In other words, we converted each expression given to &lt;code&gt;case/2&lt;/code&gt; as a step in &lt;code&gt;with&lt;/code&gt;. As soon as any of the steps return something that does not match &lt;code&gt;{:ok, x}&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt; aborts, and returns the non-matching value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b5785a062ee13450968c9614ec6ca20310e34ad" translate="yes" xml:space="preserve">
          <source>In other words, we want the registry to keep on running even if a bucket crashes. Let&amp;rsquo;s write a new registry test:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32be3988a4bf49863fd56d4a7249dcf02990b46b" translate="yes" xml:space="preserve">
          <source>In other words, when invoked as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8d6c41a56de39aca9e7a91aac78285a5e2f3f02" translate="yes" xml:space="preserve">
          <source>In other words:</source>
          <target state="translated">In other words:</target>
        </trans-unit>
        <trans-unit id="49d20f893de0acff7f5dc08503dbde4a71a0e1bc" translate="yes" xml:space="preserve">
          <source>In particular, charlists will be printed back by default in single quotes if they contain only printable ASCII characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3467114e6e90f4dae7f2e188d401c44475293e7c" translate="yes" xml:space="preserve">
          <source>In practice, charlists are used mostly when interfacing with Erlang, in particular old libraries that do not accept binaries as arguments. You can convert a charlist to a string and back by using the &lt;code&gt;to_string/1&lt;/code&gt; and &lt;code&gt;to_charlist/1&lt;/code&gt; functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b004abb70250b3f1e68f41dcfedc223284b584eb" translate="yes" xml:space="preserve">
          <source>In practice, however, Elixir developers rarely use the &lt;code&gt;try/rescue&lt;/code&gt; construct. For example, many languages would force you to rescue an error when a file cannot be opened successfully. Elixir instead provides a &lt;code&gt;File.read/1&lt;/code&gt; function which returns a tuple containing information about whether the file was opened successfully:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e292cda7fd341df2ad10ad68515a260c1f9ceca" translate="yes" xml:space="preserve">
          <source>In practice, if you find yourself in a position where you need a process registry for dynamic processes, you should use &lt;a href=&quot;https://hexdocs.pm/elixir/Registry.html&quot;&gt;the &lt;code&gt;Registry&lt;/code&gt; module&lt;/a&gt; provided as part of Elixir. It provides functionality similar to the one we have built using a GenServer + &lt;code&gt;:ets&lt;/code&gt; while also being able to perform both writes and reads concurrently. &lt;a href=&quot;https://elixir-lang.org/blog/2017/01/05/elixir-v1-4-0-released/&quot;&gt;It has been benchmarked to scale across all cores even on machines with 40 cores&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1db0e725bf7fce8e6792fe7c1b5f4904976e1c8d" translate="yes" xml:space="preserve">
          <source>In practice, it is common to have both server and client functions in the same module. If the server and/or client implementations are growing complex, you may want to have them in different modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70101e1c300d630f1ea86765138df21a3dc6ed93" translate="yes" xml:space="preserve">
          <source>In practice, it is more likely you will reach the Erlang</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c83f942e405f3eb5ce3163220a02a8f1db134d20" translate="yes" xml:space="preserve">
          <source>In practice, we are not expecting the processes working as buckets to fail. But, if it does happen, for whatever reason, we can rest assured that our system will continue to work as intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcd76319c1bff6236a950ae66cde047b189b7040" translate="yes" xml:space="preserve">
          <source>In practice, you rarely load applications by hand because that is part of the start process, explained next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b81ae9e0c2bb006469e999756d7c827614795f38" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix. It may happen if read permissions do not exist for the parent directories of the current directory. For this reason, returns &lt;code&gt;{:ok, cwd}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd5d3b4600c9d05bb359546d1009f1e407c770b" translate="yes" xml:space="preserve">
          <source>In set notation: &lt;code&gt;[\p{ID_Start}\p{Mn}\p{Mc}\p{Nd}\p{Pc}\p{Other_ID_Continue}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f49cbc94b22c26f24f368405117b1889a3c176b" translate="yes" xml:space="preserve">
          <source>In set notation: &lt;code&gt;[\p{L}\p{Nl}\p{Other_ID_Start}-\p{Pattern_Syntax}-\p{Pattern_White_Space}]&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2ccee93d894b5296828c59c78b91159cd164712" translate="yes" xml:space="preserve">
          <source>In some cases, it may be convenient to provide a default implementation for all types. This can be achieved by setting the &lt;code&gt;@fallback_to_any&lt;/code&gt; attribute to &lt;code&gt;true&lt;/code&gt; in the protocol definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371305821a86a1fd6063efb5d024b0464bdede1a" translate="yes" xml:space="preserve">
          <source>In some cases, it may be necessary to inject many values inside a list. For example, imagine you have a list containing &lt;code&gt;[1, 2, 6]&lt;/code&gt; and we want to inject &lt;code&gt;[3, 4, 5]&lt;/code&gt; into it. Using &lt;code&gt;unquote&lt;/code&gt; won&amp;rsquo;t yield the desired result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606ff8e75aa81c7c8c049f5b60f58898dddc0286" translate="yes" xml:space="preserve">
          <source>In some cases, this may lead to undesired formatting. Therefore, &lt;strong&gt;some code generated by the formatter may not be aesthetically pleasing and may require explicit intervention from the developer&lt;/strong&gt;. That's why we do not recommend to run the formatter blindly in an existing codebase. Instead you should format and sanity check each formatted file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9e037bc0aa6cd7738573dffae9758c75aa58f06" translate="yes" xml:space="preserve">
          <source>In some cases, you don&amp;rsquo;t care about a particular value in a pattern. It is a common practice to bind those values to the underscore, &lt;code&gt;_&lt;/code&gt;. For example, if only the head of the list matters to us, we can assign the tail to underscore:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bf473ae676eadb3b6d9002d5044ddc6e88467a0" translate="yes" xml:space="preserve">
          <source>In some cases, you may need to inject such &lt;em&gt;values&lt;/em&gt; into &lt;em&gt;quoted expressions&lt;/em&gt;. To do that, we need to first escape those values into quoted expressions with the help of &lt;code&gt;Macro.escape/1&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72fba3c3196c1696a309102e4d11fa8e7e9ddc2" translate="yes" xml:space="preserve">
          <source>In some cases, you want to access an alias or a module defined in the caller. For such, you can use the &lt;code&gt;alias!&lt;/code&gt; macro:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5d8febe75db79d78b1632bb42524ac427524c5" translate="yes" xml:space="preserve">
          <source>In some situations, you can use the fact the formatter does not generate elegant code as a hint for refactoring. Take this code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa2a12aa6aedffdc527ed2aeaa4a499eafdd3bd3" translate="yes" xml:space="preserve">
          <source>In such cases, developers should instead import or alias the module directly, so that they can customize those as they wish, without the indirection behind &lt;a href=&quot;#use/2&quot;&gt;&lt;code&gt;use/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ee68d6d5538c71b755e522365fc502dbb4b5228" translate="yes" xml:space="preserve">
          <source>In summary, documentation is a contract with users of your API, who may not necessarily have access to the source code; whereas code comments are for those who interact directly with the source. You can learn and express different guarantees about your software by separating those two concepts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88056ec75ab5d6672e9f690c2cbe9609ac25a458" translate="yes" xml:space="preserve">
          <source>In the &quot;Mix.Task&quot; section, we have defined a task that would be available to everyone using our project as a dependency. What if we wanted the task to only be available for our project? Just define an alias:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff37981f126b5bf2fa55d0c06620d51ba16e7f55" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;agent&quot;&gt;previous chapter&lt;/a&gt;, we used agents to represent our buckets. In the &lt;a href=&quot;introduction-to-mix&quot;&gt;introduction to mix&lt;/a&gt;, we specified we would like to name each bucket so we can do the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b5fc14f69e9c66ff005f61efabe92506fc54ff9" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;basic-types&quot;&gt;previous chapter&lt;/a&gt;, we saw Elixir provides &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; as arithmetic operators, plus the functions &lt;code&gt;div/2&lt;/code&gt; and &lt;code&gt;rem/2&lt;/code&gt; for integer division and remainder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26102656dadf27f08b5ecc06639ee0453b4518a" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;structs&quot;&gt;previous chapter&lt;/a&gt;, we have learned that although structs are maps, they do not share protocol implementations with maps. For example, &lt;a href=&quot;https://hexdocs.pm/elixir/MapSet.html&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;s (sets based on maps) are implemented as structs. Let&amp;rsquo;s try to use the &lt;code&gt;Size&lt;/code&gt; protocol with a &lt;code&gt;MapSet&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53173cc148f94bd7e146b01b777ce24e106147bb" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;__using__/1&lt;/code&gt; implementation, we will initialize a module attribute named &lt;code&gt;@tests&lt;/code&gt; to an empty list, then store the name of each defined test in this attribute so the tests can be invoked from the &lt;code&gt;run&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21c1f93db813518da68dd14fe39d40364740d5a" translate="yes" xml:space="preserve">
          <source>In the Applications tab, you will see all applications currently running in your system alongside their supervision tree. You can select the &lt;code&gt;kv&lt;/code&gt; application to explore it further:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bde538c8f6213c2789f457ce470a93e8d2f207d9" translate="yes" xml:space="preserve">
          <source>In the above, process termination refers to unsuccessful termination, which is determined by the &lt;code&gt;:restart&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de44ed6132703d951e8099501d3dde1a95e8c6be" translate="yes" xml:space="preserve">
          <source>In the case of calls to anonymous functions, the inner tuple with the dot special form has only one argument, reflecting the fact that the operator is unary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bee66e2e0ed3861603c7e12d98d2bb864e0a4a57" translate="yes" xml:space="preserve">
          <source>In the case of the event &lt;code&gt;:flush&lt;/code&gt; handlers should flush any pending data. This event is triggered by &lt;a href=&quot;#flush/0&quot;&gt;&lt;code&gt;flush/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7d253a49741f6c380664521d0e7ead5dde4a470" translate="yes" xml:space="preserve">
          <source>In the code above, we have a process, which we call &amp;ldquo;the client&amp;rdquo; sending a request to an agent, &amp;ldquo;the server&amp;rdquo;. The request contains an anonymous function, which must be executed by the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ea691104e7ec52f4ddc63f9f0cace981d953b17" translate="yes" xml:space="preserve">
          <source>In the environment you can access the current filename, line numbers, set up aliases, the current function and others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0731e3b2d6896ada3ab5956119cf51186ed0825" translate="yes" xml:space="preserve">
          <source>In the environment you can access the filename, line numbers, set up aliases, the function and others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2913df470cab8312823dbbd9aad2e70e4f9242e6" translate="yes" xml:space="preserve">
          <source>In the example above we have created the alias &lt;code&gt;some_alias&lt;/code&gt; that will run the task &lt;code&gt;mix hex.info&lt;/code&gt;, then &lt;a href=&quot;mix.tasks.run&quot;&gt;&lt;code&gt;mix run&lt;/code&gt;&lt;/a&gt; to run an Elixir script, then &lt;a href=&quot;mix.tasks.cmd&quot;&gt;&lt;code&gt;mix cmd&lt;/code&gt;&lt;/a&gt; to execute a command line shell script. This shows how powerful aliases mixed with Mix tasks can be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a1ba160e9b96d6822e0f9cf64aea8a58c334907" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#max/1&quot;&gt;&lt;code&gt;max/1&lt;/code&gt;&lt;/a&gt; returned March 31st instead of April 1st because the structural comparison compares the day before the year. This can be addressed by using &lt;a href=&quot;#max_by/3&quot;&gt;&lt;code&gt;max_by/3&lt;/code&gt;&lt;/a&gt; and by relying on structures where the most significant digits come first. In this particular case, we can use &lt;a href=&quot;date#to_erl/1&quot;&gt;&lt;code&gt;Date.to_erl/1&lt;/code&gt;&lt;/a&gt; to get a tuple representation with year, month and day fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00b3dfc102ba0bf3e9031dc021dd5e02de63d0cd" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#max/2&quot;&gt;&lt;code&gt;max/2&lt;/code&gt;&lt;/a&gt; returned March 31st instead of April 1st because the structural comparison compares the day before the year. In such cases it is common for modules to provide functions such as &lt;a href=&quot;date#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt; that perform semantic comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7872f4b6748675f8cea9f2aac1d82fd307d18a15" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#min/1&quot;&gt;&lt;code&gt;min/1&lt;/code&gt;&lt;/a&gt; returned April 1st instead of March 31st because the structural comparison compares the day before the year. This can be addressed by using &lt;a href=&quot;#min_by/3&quot;&gt;&lt;code&gt;min_by/3&lt;/code&gt;&lt;/a&gt; and by relying on structures where the most significant digits come first. In this particular case, we can use &lt;a href=&quot;date#to_erl/1&quot;&gt;&lt;code&gt;Date.to_erl/1&lt;/code&gt;&lt;/a&gt; to get a tuple representation with year, month and day fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf57110afa2caf6b8fbffc8cc551e293da6c450" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;#min/2&quot;&gt;&lt;code&gt;min/2&lt;/code&gt;&lt;/a&gt; returned April 1st instead of March 31st because the structural comparison compares the day before the year. In such cases it is common for modules to provide functions such as &lt;a href=&quot;date#compare/2&quot;&gt;&lt;code&gt;Date.compare/2&lt;/code&gt;&lt;/a&gt; that perform semantic comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ad3c30dbfab7415bf70f15c8e5b3a581930bcb" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;a href=&quot;enum#reduce/3&quot;&gt;&lt;code&gt;Enum.reduce/3&lt;/code&gt;&lt;/a&gt; accumulates the result of each call to &lt;code&gt;fun&lt;/code&gt; into a list in reverse order, which is correctly ordered at the end by calling &lt;a href=&quot;enum#reverse/1&quot;&gt;&lt;code&gt;Enum.reverse/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ab2fe333dba7cd1bd613d8d2e21311292cba7df" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;1..100_000 |&amp;gt; Stream.map(&amp;amp;(&amp;amp;1 * 3))&lt;/code&gt; returns a data type, an actual stream, that represents the &lt;code&gt;map&lt;/code&gt; computation over the range &lt;code&gt;1..100_000&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7c845572f115897b2ebea0f8fac31816b299fd4" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;a&lt;/code&gt; returns 10 even if the macro is apparently setting it to 1 because variables defined in the macro do not affect the context the macro is executed in. If you want to set or get a variable in the caller's context, you can do it with the help of the &lt;code&gt;var!&lt;/code&gt; macro:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a7545c257a489979c415df1e9f0cbb1c93d77bd" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;bar&lt;/code&gt; will be returned if &lt;code&gt;foo&lt;/code&gt; evaluates to a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;). Otherwise, &lt;code&gt;nil&lt;/code&gt; will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eacffd5adbf5fd949bb658e0457a877aa95d246" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;value&lt;/code&gt; is going to be &lt;code&gt;7&lt;/code&gt; or &lt;code&gt;13&lt;/code&gt; depending on the value of &lt;code&gt;lucky?&lt;/code&gt;. In case &lt;code&gt;value&lt;/code&gt; has no previous value before case, clauses that do not explicitly bind a value have the variable bound to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72cbf21e3fa3d74880817514a949e8994722f839" translate="yes" xml:space="preserve">
          <source>In the example above, &lt;code&gt;x&lt;/code&gt; cannot be accessed since it was defined inside the &lt;code&gt;try&lt;/code&gt; clause. A common practice to address this issue is to return the variables defined inside &lt;code&gt;try&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bed3d677daa97ab1f5b51e489879c2e74facf10" translate="yes" xml:space="preserve">
          <source>In the example above, a &lt;code&gt;sum/2&lt;/code&gt; function is defined; this function receives two arguments and returns their sum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fb262ec317cb005dd946c4cd7d04d84b1f69668" translate="yes" xml:space="preserve">
          <source>In the example above, a set of macros named &lt;code&gt;user&lt;/code&gt; but with different arities will be defined to manipulate the underlying record.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0f218463838143ec4982ca79e4ec70bc05323d" translate="yes" xml:space="preserve">
          <source>In the example above, a supervisor was started by passing the supervision structure to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt;. However, supervisors can also be created by explicitly defining a supervision module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="442ca993474ce04915ab444e69370d1fd701d187" translate="yes" xml:space="preserve">
          <source>In the example above, as we mapped over the range, the elements being enumerated were created one by one, during enumeration. The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; module allows us to map the range, without triggering its enumeration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73b31064dddafd7aceb7c6dd33acb2dfd723e612" translate="yes" xml:space="preserve">
          <source>In the example above, by using &lt;code&gt;TestCase&lt;/code&gt;, we can write tests using the &lt;code&gt;test&lt;/code&gt; macro, which defines a function named &lt;code&gt;run&lt;/code&gt; to automatically run all tests for us. Our prototype will rely on the match operator (&lt;code&gt;=&lt;/code&gt;) as a mechanism to do assertions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3bbbdd7b6d7f4d0dd2d5c03396c880a058ec265" translate="yes" xml:space="preserve">
          <source>In the example above, even though the macro injects &lt;code&gt;a = 1&lt;/code&gt;, it does not affect the variable &lt;code&gt;a&lt;/code&gt; defined by the &lt;code&gt;go&lt;/code&gt; function. If a macro wants to explicitly affect the context, it can use &lt;code&gt;var!&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df21e3e8f902f80311e9ed366624d965e22d8f36" translate="yes" xml:space="preserve">
          <source>In the example above, even though the right list has more entries than the left one, destructuring works fine. If the right list is smaller, the remaining elements are simply set to &lt;code&gt;nil&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad9447b0ab139bf0ce77de940f7116ad1118f9e7" translate="yes" xml:space="preserve">
          <source>In the example above, pattern matching works because underneath structs are bare maps with a fixed set of fields. As maps, structs store a &amp;ldquo;special&amp;rdquo; field named &lt;code&gt;__struct__&lt;/code&gt; that holds the name of the struct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae57a394eb52ab25120ea39543d455089abff36" translate="yes" xml:space="preserve">
          <source>In the example above, since we are invoking &lt;code&gt;alias&lt;/code&gt; inside the function &lt;code&gt;plus/2&lt;/code&gt;, the alias will be valid only inside the function &lt;code&gt;plus/2&lt;/code&gt;. &lt;code&gt;minus/2&lt;/code&gt; won&amp;rsquo;t be affected at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062b7f604b56dd870819716494d195af709ce6fe" translate="yes" xml:space="preserve">
          <source>In the example above, the &lt;code&gt;|&amp;gt;&lt;/code&gt; pipe is the right-most pipe; &lt;code&gt;arg1&lt;/code&gt; is the AST for &lt;code&gt;100 |&amp;gt; div(5)&lt;/code&gt;, and &lt;code&gt;arg2&lt;/code&gt; is the AST for &lt;code&gt;div(2)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3764d5750387486a4a8182c32859bf0c44e3a53a" translate="yes" xml:space="preserve">
          <source>In the example above, the imported &lt;code&gt;List.duplicate/2&lt;/code&gt; is only visible within that specific function. &lt;code&gt;duplicate/2&lt;/code&gt; won&amp;rsquo;t be available in any other function in that module (or any other module for that matter).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ba96d97b36e1f6537a9985e8f45706e25424fa" translate="yes" xml:space="preserve">
          <source>In the example above, the linked process died by sending an &lt;code&gt;exit&lt;/code&gt; signal with a value of 1. The Elixir shell automatically handles those messages and prints them to the terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df1a4779609dfb3efd8db910186e109c073a0338" translate="yes" xml:space="preserve">
          <source>In the example above, the list &lt;code&gt;[1, [2], 3]&lt;/code&gt; is passed as the first argument to the &lt;a href=&quot;list#flatten/1&quot;&gt;&lt;code&gt;List.flatten/1&lt;/code&gt;&lt;/a&gt; function, then the flattened list is passed as the first argument to the &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; function which doubles each element of the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a372309337ceccb6cd8c47007e31bef89794f8" translate="yes" xml:space="preserve">
          <source>In the example above, the shell will be expecting more input until it finds the closing quote. Sometimes it is not obvious which character the shell is expecting, and the user may find themselves trapped in the state of incomplete expression with no ability to terminate it other than by exiting the shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c1055e1dbf2125278d879200ab263f9e383b43c" translate="yes" xml:space="preserve">
          <source>In the example above, this happens:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8625f3069f10910c0e9de120b21d6981d601654" translate="yes" xml:space="preserve">
          <source>In the example above, two modules - &lt;code&gt;Foo&lt;/code&gt; and &lt;code&gt;Foo.Bar&lt;/code&gt; - are created. When nesting, Elixir automatically creates an alias to the inner module, allowing the second module &lt;code&gt;Foo.Bar&lt;/code&gt; to be accessed as &lt;code&gt;Bar&lt;/code&gt; in the same lexical scope where it's defined (the &lt;code&gt;Foo&lt;/code&gt; module). This only happens if the nested module is defined via an alias.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee742c4ffa43a93d2e20f415d5f42aefbd9bd95" translate="yes" xml:space="preserve">
          <source>In the example above, we are explicitly setting the version attribute for that module. &lt;code&gt;@vsn&lt;/code&gt; is used by the code reloading mechanism in the Erlang</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="021f23fc44f1b5057c72ccb35305764a702bc70f" translate="yes" xml:space="preserve">
          <source>In the example above, we are mutating both the array and the variable &lt;code&gt;i&lt;/code&gt;. Mutating is not possible in Elixir. Instead, functional languages rely on recursion: a function is called recursively until a condition is reached that stops the recursive action from continuing. No data is mutated in this process. Consider the example below that prints a string an arbitrary number of times:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5006566e063521dde7ab998be88e6cd1a64640e" translate="yes" xml:space="preserve">
          <source>In the example above, we can access the value &lt;code&gt;foo&lt;/code&gt; under the binding &lt;code&gt;assigns&lt;/code&gt; using &lt;code&gt;@foo&lt;/code&gt;. This is useful because a template, after being compiled, can receive different assigns and would not require recompilation for each variable set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5661752d4cc9fd9fdd4a2d139f2888ecb877cbf6" translate="yes" xml:space="preserve">
          <source>In the example above, we captured &lt;a href=&quot;kernel#is_atom/1&quot;&gt;&lt;code&gt;Kernel.is_atom/1&lt;/code&gt;&lt;/a&gt; as an anonymous function and then invoked it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3bbf3a8f78417d03c53c8a99adeb57f91aa4785" translate="yes" xml:space="preserve">
          <source>In the example above, we create tasks that sleep from 1 up to 10 seconds and return the number of seconds they slept for. If you execute the code all at once, you should see 1 up to 5 printed, as those were the tasks that have replied in the given time. All other tasks will have been shut down using the &lt;a href=&quot;task#shutdown/2&quot;&gt;&lt;code&gt;Task.shutdown/2&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43dbb6ffa3efa205c169cb0eb943acb32507c0e1" translate="yes" xml:space="preserve">
          <source>In the example above, we defined an anonymous function that receives two arguments, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and returns the result of &lt;code&gt;a + b&lt;/code&gt;. The arguments are always on the left-hand side of &lt;code&gt;-&amp;gt;&lt;/code&gt; and the code to be executed on the right-hand side. The anonymous function is stored in the variable &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2957729dcc7602ce0c24fbab3553e81f82dbdc" translate="yes" xml:space="preserve">
          <source>In the example above, we defined specs for workers and supervisors. These specs (both for workers as well as supervisors) accept the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e6b4da92c054f57ac5d7ebeeafc523687c5adff" translate="yes" xml:space="preserve">
          <source>In the example above, we have created a new port that executes the program &lt;code&gt;cat&lt;/code&gt;. &lt;code&gt;cat&lt;/code&gt; is a program available on UNIX systems that receives data from multiple inputs and concatenates them in the output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e39547d1868b820dfb08e74cce03806dbaf13c" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined a tag called &lt;code&gt;:cd&lt;/code&gt; that is read in the setup callback to configure the working directory the test is going to run on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd333e5963bb492deae7a782ebcecbae48824d5" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined an alias named &lt;code&gt;mix all&lt;/code&gt;, that prints &quot;Hello world&quot;, then fetches dependencies specific to the current environment, and compiles the project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b55e3dbdcda3974f9c85104c4aab9938de0f3064" translate="yes" xml:space="preserve">
          <source>In the example above, we have defined two aliases. One is &lt;code&gt;mix c&lt;/code&gt; which is a shortcut for &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;. The other is named &lt;code&gt;mix hello&lt;/code&gt;, which is the equivalent to the &lt;code&gt;Mix.Tasks.Hello&lt;/code&gt; we have defined in the &quot;Mix.Task&quot; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61eada0cb9cbd1b50540cd6782b9dfeead876351" translate="yes" xml:space="preserve">
          <source>In the example above, we have generated the functions &lt;code&gt;foo/0&lt;/code&gt; and &lt;code&gt;bar/0&lt;/code&gt; dynamically. Now, imagine that we want to convert this functionality into a macro:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c4c73a0b16c4020cd89858453c999ce24f50d3b" translate="yes" xml:space="preserve">
          <source>In the example above, we have set up &lt;code&gt;MyKeyword&lt;/code&gt; to be aliased as &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt;. So now, any reference to &lt;a href=&quot;keyword&quot;&gt;&lt;code&gt;Keyword&lt;/code&gt;&lt;/a&gt; will be automatically replaced by &lt;code&gt;MyKeyword&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="053a645de735a836658d24ec36de529750445dbd" translate="yes" xml:space="preserve">
          <source>In the example above, we have used the &lt;code&gt;plug/1&lt;/code&gt; macro to connect functions that will be invoked when there is a web request. Internally, every time you call &lt;code&gt;plug/1&lt;/code&gt;, the Plug library stores the given argument in a &lt;code&gt;@plugs&lt;/code&gt; attribute. Just before the module is compiled, Plug runs a callback that defines a function (&lt;code&gt;call/2&lt;/code&gt;) which handles HTTP requests. This function will run all plugs inside &lt;code&gt;@plugs&lt;/code&gt; in order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d04cc9035f609252303b7cf3699ee2289f736ec0" translate="yes" xml:space="preserve">
          <source>In the example above, we imported macros from &lt;code&gt;MyMacros&lt;/code&gt;, replacing the original &lt;a href=&quot;kernel#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; implementation by our own within that specific function. All other functions in that module will still be able to use the original one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="143be83aa54f7c530d19333f4615426ffc2f8abd" translate="yes" xml:space="preserve">
          <source>In the example above, we match &lt;code&gt;thing&lt;/code&gt; against each clause &quot;head&quot; and execute the clause &quot;body&quot; corresponding to the first clause that matches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b838b0193a4108fff85d3563dd635cc22b74b28" translate="yes" xml:space="preserve">
          <source>In the example above, we pass a string with &lt;code&gt;\n&lt;/code&gt; escaped and return a version with it unescaped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34b35a1a0f6a7ae64d902f20f6d3b6957890f8c" translate="yes" xml:space="preserve">
          <source>In the example above, we show how guards can be used in function clauses. There are several constructs that allow guards; for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e73b208830253cfcccda8b595f6a7fc37ec019c4" translate="yes" xml:space="preserve">
          <source>In the example below we register the current process and ask for the number of keys in the registry:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="600451af2621db08950612f2b8a384ceb1caba3b" translate="yes" xml:space="preserve">
          <source>In the example below we register the current process and look it up both from itself and other processes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798fe8739fe086fd76b2f2f854df6fe2d36c1741" translate="yes" xml:space="preserve">
          <source>In the example below we register the current process under the same key in a duplicate registry but with different values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78080544e53670fa0133b74d89a92858bb262655" translate="yes" xml:space="preserve">
          <source>In the example below, we have a macro that generates a module with a function named &lt;code&gt;name_length&lt;/code&gt; that returns the length of the module name. The value of this function will be calculated at compilation time and not at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8f1d08583916da8a72b67e1316644cdd98dc53a" translate="yes" xml:space="preserve">
          <source>In the example below, we pass a directory to where the &lt;a href=&quot;#c/2&quot;&gt;&lt;code&gt;c/2&lt;/code&gt;&lt;/a&gt; function will write the compiled &lt;code&gt;.beam&lt;/code&gt; files to. This directory is typically named &quot;ebin&quot; in Erlang/Elixir systems:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15375188c3b299d4050635b90946ba7afce11069" translate="yes" xml:space="preserve">
          <source>In the example below, we use a function to get all the maps inside a list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9f19cdead9cbae542d5210ec70e748cea04410" translate="yes" xml:space="preserve">
          <source>In the examples above, all the comprehensions returned lists as their result. However, the result of a comprehension can be inserted into different data structures by passing the &lt;code&gt;:into&lt;/code&gt; option to the comprehension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7b33831c78babc5b4b6a0cc0e2347ac123865c0" translate="yes" xml:space="preserve">
          <source>In the examples above, the result returned by the comprehension was always a list. The returned result can be configured by passing an &lt;code&gt;:into&lt;/code&gt; option, that accepts any structure as long as it implements the &lt;a href=&quot;collectable&quot;&gt;&lt;code&gt;Collectable&lt;/code&gt;&lt;/a&gt; protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0daacadfe9f7077fb5dcbe6bf521a065a6a635d" translate="yes" xml:space="preserve">
          <source>In the expression above, &lt;code&gt;n &amp;lt;- [1, 2, 3, 4]&lt;/code&gt; is the &lt;strong&gt;generator&lt;/strong&gt;. It is literally generating values to be used in the comprehension. Any enumerable can be passed on the right-hand side of the generator expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3acf5fd7cb6799236adf41693aa239ed339ba4" translate="yes" xml:space="preserve">
          <source>In the first example the accent is before the vowel, so it is considered two graphemes. However, when you reverse it once, you have the vowel followed by the accent, which becomes one grapheme. Reversing it again will keep it as one single grapheme.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edabe1bf622029e68e1aff637ff6cf8ec47fb508" translate="yes" xml:space="preserve">
          <source>In the following sections, our examples are going to get longer in size, and it can be tricky to type them all in the shell. It&amp;rsquo;s about time for us to learn how to compile Elixir code and also how to run Elixir scripts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea21b7568312a339bf9ae152813dc701fedd0816" translate="yes" xml:space="preserve">
          <source>In the next chapter, we are going to discuss pattern matching through the use of &lt;code&gt;=&lt;/code&gt;, the match operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8135bc13d648cc8121bc02383bb281b2bb322ce" translate="yes" xml:space="preserve">
          <source>In the next chapter, we will explore GenServers, where the segregation between clients and servers is made more apparent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71fe1559a8acce4f8cb459f05a93f2c23c27af01" translate="yes" xml:space="preserve">
          <source>In the next chapter, we will start parsing the client requests and sending responses, finishing our server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a27cfc769eb0315701a749f650534e93e63132" translate="yes" xml:space="preserve">
          <source>In the next chapters, we&amp;rsquo;ll explore structs and protocols before moving to exception handling and other constructs like sigils and comprehensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83c96bdabbdcc08e2e498fa4f73aafa1f188be21" translate="yes" xml:space="preserve">
          <source>In the previous chapter about &lt;code&gt;GenServer&lt;/code&gt;, we implemented &lt;code&gt;KV.Registry&lt;/code&gt; to manage buckets. At some point, we started monitoring buckets so we were able to take action whenever a &lt;code&gt;KV.Bucket&lt;/code&gt; crashed. Although the change was relatively small, it introduced a question which is frequently asked by Elixir developers: what happens when something fails?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0c1e10201013cbed4ae2f15c5fb7856de2269f" translate="yes" xml:space="preserve">
          <source>In the previous chapters, we have always started processes directly. For example, we would call &lt;code&gt;KV.Registry.start_link([])&lt;/code&gt;, which would return &lt;code&gt;{:ok, pid}&lt;/code&gt;, and that would allow us to interact with the registry via its &lt;code&gt;pid&lt;/code&gt;. Now that processes are started by the supervisor, we have to directly ask the supervisor who its children are, and fetch the pid from the returned list of children. In practice, doing so every time would be very expensive. To address this, we often give names to processes, allowing them to be uniquely identified in a single machine from anywhere in our code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="023e1eab071b1e9447d8611d553a6798a82a86d3" translate="yes" xml:space="preserve">
          <source>In the previous example, we were not interested in associating a value to the process:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59cfb6ab9287629bc99d4335b390c03667b20499" translate="yes" xml:space="preserve">
          <source>In the returned result, keys are variable names and values are the corresponding variable values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de1b308ba8fcb658982badee13287d07ac9706b3" translate="yes" xml:space="preserve">
          <source>In the second line of the failure, right below the test name, there is the location where the test was defined. If you copy the test location in full, including the file and line number, and append it to &lt;code&gt;mix test&lt;/code&gt;, Mix will load and run just that particular test:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56699ac32b40ebbed14cd456a076f153ca769c75" translate="yes" xml:space="preserve">
          <source>In the session above we interacted with the &amp;ldquo;shopping&amp;rdquo; bucket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99f7aeec7f3d83fb7c14ef77613795b1757f5d28" translate="yes" xml:space="preserve">
          <source>In this case, the answer is yes: if the acceptor crashes, there is no need to crash the existing connections. On the other hand, if the task supervisor crashes, there is no need to crash the acceptor too.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b73c40f211641ff7fce3baa3df52cd94ce14cd" translate="yes" xml:space="preserve">
          <source>In this case, there is no module, so we picked the name &lt;code&gt;KV.BucketSupervisor&lt;/code&gt;. It could have been any other name. We also chose the &lt;code&gt;:one_for_one&lt;/code&gt; strategy, which is currently the only available strategy for dynamic supervisors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69b79e652a12895505240a6d60f23b561b08605d" translate="yes" xml:space="preserve">
          <source>In this case, we are importing only the function &lt;code&gt;duplicate&lt;/code&gt; (with arity 2) from &lt;code&gt;List&lt;/code&gt;. Although &lt;code&gt;:only&lt;/code&gt; is optional, its usage is recommended in order to avoid importing all the functions of a given module inside the namespace. &lt;code&gt;:except&lt;/code&gt; could also be given as an option in order to import everything in a module &lt;em&gt;except&lt;/em&gt; a list of functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ecd27c52ed18c7b95002136d1b65249ac3fde1" translate="yes" xml:space="preserve">
          <source>In this chapter we will learn more about Elixir basic types: integers, floats, booleans, atoms, strings, lists and tuples. Some basic types are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95bc41f24cd4a15d49d6be30cfe2c21aeb083956" translate="yes" xml:space="preserve">
          <source>In this chapter, we are going to explore sigils, which are one of the mechanisms provided by the language for working with textual representations. Sigils start with the tilde (&lt;code&gt;~&lt;/code&gt;) character which is followed by a letter (which identifies the sigil) and then a delimiter; optionally, modifiers can be added after the final delimiter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac2c0d2324769d5f24fd923ab3874ad8881b99a" translate="yes" xml:space="preserve">
          <source>In this chapter, we are going to learn how to use &lt;a href=&quot;http://www.erlang.org/doc/man/gen_tcp.html&quot;&gt;Erlang&amp;rsquo;s &lt;code&gt;:gen_tcp&lt;/code&gt; module&lt;/a&gt; to serve requests. This provides a great opportunity to explore Elixir&amp;rsquo;s &lt;code&gt;Task&lt;/code&gt; module. In future chapters, we will expand our server so it can actually serve the commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3790f5eba5f0f0e875bea6125a8a5886ab46f334" translate="yes" xml:space="preserve">
          <source>In this chapter, we have learned more about Mix dependencies and umbrella projects. While we may run &lt;code&gt;kv&lt;/code&gt; without a server, our &lt;code&gt;kv_server&lt;/code&gt; depends directly on &lt;code&gt;kv&lt;/code&gt;. By breaking them into separate applications, we gain more control in how they are developed and tested.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77b3cbb396af520fe87eb129b43b21e8d9c63f1e" translate="yes" xml:space="preserve">
          <source>In this chapter, we will create our first project using Mix and explore different features in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4b6a4ca897d48c33e42fad527b3db14a79b9ad" translate="yes" xml:space="preserve">
          <source>In this chapter, we will discuss how to manage dependencies in Mix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4cdb3f68133770a5d693d42e9c4f0a6b1d29ed8" translate="yes" xml:space="preserve">
          <source>In this chapter, we will go back to the &lt;code&gt;:kv&lt;/code&gt; application and add a routing layer that will allow us to distribute requests between nodes based on the bucket name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e8c486e5a64f168562aa1973836cfefc091cf1" translate="yes" xml:space="preserve">
          <source>In this chapter, we will implement the code that parses the commands we described in the first chapter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c851aca018e560f965209935144975cb8ea448f3" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn about ETS (Erlang Term Storage) and how to use it as a cache mechanism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49223bed7f677bd886d57a37c64f3ed6e0f504be" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn about the &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;cond&lt;/code&gt;, and &lt;code&gt;if&lt;/code&gt; control flow structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1590a3a3e635043fe94ad7ec0fb7a6fa472857ed" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn about the basic constructs for spawning new processes, as well as sending and receiving messages between processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5c0837809d0d37d72c00bc93c0560646fc3127" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn how to keep and share state between multiple entities. If you have previous programming experience, you may think of globally shared variables, but the model we will learn here is quite different. The next chapters will generalize the concepts introduced here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc7ec789bc29ccf1df57435cd9cab759827e4cca" translate="yes" xml:space="preserve">
          <source>In this chapter, we will learn how to put those concepts into practice by supervising the &lt;code&gt;KV.Registry&lt;/code&gt; process. After all, if something goes wrong with the registry, the whole registry is lost and no bucket could ever be found! To address this, we will define a &lt;code&gt;KV.Supervisor&lt;/code&gt; module that guarantees that our &lt;code&gt;KV.Registry&lt;/code&gt; is up and running at any given moment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4e872a924d2554a59dc215ca3cc9595e893d535" translate="yes" xml:space="preserve">
          <source>In this chapter, we will show how the &lt;code&gt;=&lt;/code&gt; operator in Elixir is actually a match operator and how to use it to pattern match inside data structures. Finally, we will learn about the pin operator &lt;code&gt;^&lt;/code&gt; used to access previously bound values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31213f804ca1ba2bcaeea192ccfad5a4a66aadab" translate="yes" xml:space="preserve">
          <source>In this chapter, we will understand what binaries are, how they associate with strings, and what a single-quoted value, &lt;code&gt;'like this'&lt;/code&gt;, means in Elixir.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cab0abe1635159a22d386896876d7d1271b3ac90" translate="yes" xml:space="preserve">
          <source>In this example above, we have used &lt;code&gt;.&lt;/code&gt; to invoke &lt;code&gt;downcase&lt;/code&gt; in the &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; module, passing &lt;code&gt;&quot;FOO&quot;&lt;/code&gt; as argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10b9029231d6bc54c409155c2532fc1a938191b" translate="yes" xml:space="preserve">
          <source>In this example, &lt;a href=&quot;https://hexdocs.pm/ex_unit/ExUnit.Case.html#__using__/1&quot;&gt;&lt;code&gt;ExUnit.Case.__using__/1&lt;/code&gt;&lt;/a&gt; is called with the keyword list &lt;code&gt;[async: true]&lt;/code&gt; as its argument; &lt;a href=&quot;#use/2&quot;&gt;&lt;code&gt;use/2&lt;/code&gt;&lt;/a&gt; translates to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0189dd5873fd5c12528d067cb5fcd86bb62926" translate="yes" xml:space="preserve">
          <source>In this example, we will also set the number of partitions to the number of schedulers online, which will make the registry more performant on highly concurrent environments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf3e2a2aeea0818b1b9eedf9fbfeaab414232e77" translate="yes" xml:space="preserve">
          <source>In this function, creating the email address will copy the &lt;code&gt;username&lt;/code&gt; and &lt;code&gt;domain&lt;/code&gt; binaries. Now imagine you want to use the resulting email inside another binary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddbd4da73762eca8a66a74cb6eb4786c527ab302" translate="yes" xml:space="preserve">
          <source>In this guide, we will learn how to build a complete Elixir application, with its own supervision tree, configuration, tests and more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09acda557e592790e954bfce0950e7ceb658a690" translate="yes" xml:space="preserve">
          <source>In this introduction, we have laid the groundwork to finally write our first macro, so let&amp;rsquo;s move to the next chapter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76b277befaa00029a051ea468b00e6a56d4277a" translate="yes" xml:space="preserve">
          <source>In this last chapter, we will make the routing table for our distributed key-value store configurable, and then finally package the software for production.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f9c06a521bbdcc292934d8151f4d75a668e854f" translate="yes" xml:space="preserve">
          <source>In this menu, developers are able to start new shells and alternate between them. Let's give it a try:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="469f4d72bd11aaf469d5b151d58b6e80c06007ce" translate="yes" xml:space="preserve">
          <source>In this section we document common anti-patterns to avoid when writing libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eebb3e9870cca1a5d4d8634270c5f11116a4eca3" translate="yes" xml:space="preserve">
          <source>In this section, we will implement the parsing functionality, document it and make sure our documentation is up to date with doctests. This helps us provide documentation with accurate code samples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06285168ac2e5f025d4d90f97df36744161f8367" translate="yes" xml:space="preserve">
          <source>In this setup, Elixir will escape the following: &lt;code&gt;\0&lt;/code&gt;, &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt;. Bytes can be given as hexadecimals via &lt;code&gt;\xNN&lt;/code&gt; and Unicode code points as &lt;code&gt;\uNNNN&lt;/code&gt; escapes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8dd5e09e7dc956434b7d83de8c59a3badda6a30" translate="yes" xml:space="preserve">
          <source>In this tutorial, we are going to teach you about Elixir fundamentals - the language syntax, how to define modules, how to manipulate the characteristics of common data structures, and more. This chapter will focus on ensuring that Elixir is installed and that you can successfully run Elixir&amp;rsquo;s Interactive Shell, called IEx.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793085c85e85a2ff028456a29daed3461d17ddd7" translate="yes" xml:space="preserve">
          <source>In your supervisor tree, you would write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83526b8b240a9db63b8d55e8fb00ed7f5d21007b" translate="yes" xml:space="preserve">
          <source>In-memory reloading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d704ee1641420e0d4b1d894e7413ca3a127523fd" translate="yes" xml:space="preserve">
          <source>Indexes are normalized, meaning that negative indexes will be counted from the end (for example, &lt;code&gt;-1&lt;/code&gt; means the last element of the &lt;code&gt;enumerable&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="326e3957dade8d1a772302e6b546ac73cdbf4311" translate="yes" xml:space="preserve">
          <source>Indicates if the current task is recursing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2a5522bf941f8a31cb4a9be81260d9ace1f85be" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the bitwise AND of its arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2dd1c549a548d8e01a78692703764dc3748f955" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the bitwise OR of its arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f117367d5e095016d1671e5594b015b66cce626" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the bitwise XOR of its arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6c9f00063f505c603b4195c6e85acdf426886dc" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the result of an arithmetic left bitshift.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d1b96bbfeb4f731610e743c469a2a9cffcbf06" translate="yes" xml:space="preserve">
          <source>Infix operator; calculates the result of an arithmetic right bitshift.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edfb572bfe264c3828dc3338e200d7d692f743a8" translate="yes" xml:space="preserve">
          <source>Initialization, shutdown and restart logic (as seen in supervisors)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2dd11fcae49760a96da6470cc842932b211ef8" translate="yes" xml:space="preserve">
          <source>Injects the contents of the file at &lt;code&gt;path&lt;/code&gt; as if it was typed into the shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdae762bf8cb5cd492029bc8d296aa3edef79fb0" translate="yes" xml:space="preserve">
          <source>Injects the stream values into the given collectable as a side-effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc55e2c53e188d355acce4a5c45f90740eaed542" translate="yes" xml:space="preserve">
          <source>Inlined by the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a321cfbe47a9364ab51334333242edcba4e12d" translate="yes" xml:space="preserve">
          <source>Inlining</source>
          <target state="translated">Inlining</target>
        </trans-unit>
        <trans-unit id="60256592be0f79d02de4ff02fdbe0edd9f4a9db3" translate="yes" xml:space="preserve">
          <source>Input will be consumed until Enter is pressed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15148f3718aedfec6834b4f2c01d66f0986c9e24" translate="yes" xml:space="preserve">
          <source>Insert these changes in your code and now you may start your application using the following command &lt;code&gt;PORT=4321 mix run --no-halt&lt;/code&gt;, notice how we are passing the port as a variable, but still defaults to 4040 if none is given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="477a1b44713d7d2cea8e0f490e55ba9af37236ea" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into &lt;code&gt;map_set&lt;/code&gt; if &lt;code&gt;map_set&lt;/code&gt; doesn't already contain it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e63d377cb4e0957757e5467d8c996119f6f2f02" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; into &lt;code&gt;tuple&lt;/code&gt; at the given &lt;code&gt;index&lt;/code&gt;. Raises an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;index&lt;/code&gt; is negative or greater than the length of &lt;code&gt;tuple&lt;/code&gt;. Index is zero-based.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afa4ba1a8961d06fdaefcb0b7808a06ce72411d7" translate="yes" xml:space="preserve">
          <source>Inserts a mandatory linebreak between two documents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee42585ac2116aa5e9e194a89ae83cd36cb233ed" translate="yes" xml:space="preserve">
          <source>Inserts a mandatory single space between two documents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58646ce229b992058a739db41cd5c12f2f3030cf" translate="yes" xml:space="preserve">
          <source>Inserts an element at the end of a tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aefced5d83d6f9626d89c8b81563a063596124ad" translate="yes" xml:space="preserve">
          <source>Inserts an element into a tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82491edefb5fd8fccc5cef67dd8728cddce98356" translate="yes" xml:space="preserve">
          <source>Inserts the given &lt;code&gt;enumerable&lt;/code&gt; into a &lt;code&gt;collectable&lt;/code&gt; according to the transformation function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e9b11975e38f1615e69956c4ba72b1614985c8" translate="yes" xml:space="preserve">
          <source>Inserts the given &lt;code&gt;enumerable&lt;/code&gt; into a &lt;code&gt;collectable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dc843d3a107d849e18140a0726786e2d0083112" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;kernel#defimpl/2&quot;&gt;&lt;code&gt;defimpl/2&lt;/code&gt;&lt;/a&gt;, you can use &lt;code&gt;@protocol&lt;/code&gt; to access the protocol being implemented and &lt;code&gt;@for&lt;/code&gt; to access the module it is being defined for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a72c5141d8fa1919f077425c1ba8fcc0bb6e0f3" translate="yes" xml:space="preserve">
          <source>Inside &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; blocks you may introduce other keywords, such as &lt;code&gt;else&lt;/code&gt; used in the &lt;code&gt;if&lt;/code&gt; above. The supported keywords between &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt; are static and are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b06fc5ccdbbb6e1341b5ead9ee2126b0e7d8721" translate="yes" xml:space="preserve">
          <source>Inside IEx, hitting &lt;code&gt;Ctrl+C&lt;/code&gt; will open up the &lt;code&gt;BREAK&lt;/code&gt; menu. In this menu you can quit the shell, see process and ETS tables information and much more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f0e4a7260af9ca9a8463a85cd7efbea72439fd" translate="yes" xml:space="preserve">
          <source>Inside a module, we can define functions with &lt;code&gt;def/2&lt;/code&gt; and private functions with &lt;code&gt;defp/2&lt;/code&gt;. A function defined with &lt;code&gt;def/2&lt;/code&gt; can be invoked from other modules while a private function can only be invoked locally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b5876476355703f4f43fdf75b583d0b33e50128" translate="yes" xml:space="preserve">
          <source>Inside umbrellas:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff7d1285dd1427c76ab7acf44b71a8c8783f99ac" translate="yes" xml:space="preserve">
          <source>Insignificant digits in numbers are kept as is. The formatter however always inserts underscores for decimal numbers with more than 5 digits and converts hexadecimal digits to uppercase</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ca87afec4298d9de864e32b4eeb6a31786e496" translate="yes" xml:space="preserve">
          <source>Inspect</source>
          <target state="translated">Inspect</target>
        </trans-unit>
        <trans-unit id="8414c282c4799a38a5a542eddf3fbf5bc932cf21" translate="yes" xml:space="preserve">
          <source>Inspect &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa2cc0c476786708af2220b5a7c37218a295c0e" translate="yes" xml:space="preserve">
          <source>Inspect.Algebra</source>
          <target state="translated">Inspect.Algebra</target>
        </trans-unit>
        <trans-unit id="cac9e750c4626e97af4bfdac5963505168c991af" translate="yes" xml:space="preserve">
          <source>Inspect.Error</source>
          <target state="translated">Inspect.Error</target>
        </trans-unit>
        <trans-unit id="2f7084207f03105946937040d7f1a8666466847e" translate="yes" xml:space="preserve">
          <source>Inspect.Error &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1eea5039122d61678f099bc1095c3d343dfa88b" translate="yes" xml:space="preserve">
          <source>Inspect.Opts</source>
          <target state="translated">Inspect.Opts</target>
        </trans-unit>
        <trans-unit id="76857fe76fdec2188870db7ef8e5489c2f660af9" translate="yes" xml:space="preserve">
          <source>Inspect.inspect (2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11718aedd18c27cc6d385458412c98fc95530888" translate="yes" xml:space="preserve">
          <source>Inspect.t (0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b093666bfbe436abd6e75ff4060483a6eed400e" translate="yes" xml:space="preserve">
          <source>Inspects &lt;code&gt;item&lt;/code&gt; according to the given options using the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a3a1e7021ff3bf12f0c5dee5b6d4b45795751a" translate="yes" xml:space="preserve">
          <source>Inspects and writes the given &lt;code&gt;item&lt;/code&gt; to the device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7503cce5b05ca6c10725fe1362e1e1fb0df01fb" translate="yes" xml:space="preserve">
          <source>Inspects the given argument according to the &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol. The second argument is a keyword list with options to control inspection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="410e2de2d51ba0a8c2653a12efa8b959eb14239c" translate="yes" xml:space="preserve">
          <source>Installing external dependencies is simple. Most commonly, we use the &lt;a href=&quot;https://hex.pm&quot;&gt;Hex Package Manager&lt;/a&gt;, by listing the dependency inside the deps function in our &lt;code&gt;mix.exs&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fc6648d32dcda7f8258be9d7bfe7a810c641ff1" translate="yes" xml:space="preserve">
          <source>Instead &lt;strong&gt;do&lt;/strong&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e1c1220b6164c7f3f3c7f9ac3d512f4ed39191" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;MyModule.__behaviour__(:callbacks)&lt;/code&gt;, &lt;code&gt;MyModule.behaviour_info(:callbacks)&lt;/code&gt; can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1b879c3f25c9b1c9960a54e86cb4fc16cf79dfc" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;spawn/1&lt;/code&gt; and &lt;code&gt;spawn_link/1&lt;/code&gt;, we use &lt;code&gt;Task.start/1&lt;/code&gt; and &lt;code&gt;Task.start_link/1&lt;/code&gt; which return &lt;code&gt;{:ok, pid}&lt;/code&gt; rather than just the PID. This is what enables tasks to be used in supervision trees. Furthermore, &lt;code&gt;Task&lt;/code&gt; provides convenience functions, like &lt;code&gt;Task.async/1&lt;/code&gt; and &lt;code&gt;Task.await/1&lt;/code&gt;, and functionality to ease distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b04d71a821407f326a765c34eafcb3d188ed9ec" translate="yes" xml:space="preserve">
          <source>Instead of abusing the built-in name facility, we will create our own &lt;em&gt;process registry&lt;/em&gt; that associates the bucket name to the bucket process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46ebdd1c0d8185516f828a303e26f55b8135c53d" translate="yes" xml:space="preserve">
          <source>Instead of asking &amp;ldquo;how to do X in Elixir&amp;rdquo;, ask &amp;ldquo;how to solve Y in Elixir&amp;rdquo;. In other words, don&amp;rsquo;t ask how to implement a particular solution, instead describe the problem at hand. Stating the problem gives more context and less bias for a correct answer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="657f86bb1607bd9dc12a6834cf040e983fea5025" translate="yes" xml:space="preserve">
          <source>Instead of generating intermediate lists, streams build a series of computations that are invoked only when we pass the underlying stream to the &lt;code&gt;Enum&lt;/code&gt; module. Streams are useful when working with large, &lt;em&gt;possibly infinite&lt;/em&gt;, collections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbcbdeb5ce82b55a1db6bc95122644a2da9c98f8" translate="yes" xml:space="preserve">
          <source>Instead of sharing protocol implementation with maps, structs require their own protocol implementation. Since a &lt;code&gt;MapSet&lt;/code&gt; has its size precomputed and accessible through &lt;code&gt;MapSet.size/1&lt;/code&gt;, we can define a &lt;code&gt;Size&lt;/code&gt; implementation for it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1cda74ad7f0576bffdba14e7c0e5fbf0bd02a81" translate="yes" xml:space="preserve">
          <source>Instead, you can store the value of the &lt;code&gt;try&lt;/code&gt; expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="e340bf5c2746e3a29b7ae3f2341d749b9a8e7f42" translate="yes" xml:space="preserve">
          <source>Integer code points</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03c914e9cf272bd181f63f8ca95aa4134406a908" translate="yes" xml:space="preserve">
          <source>Integers (&lt;code&gt;1234&lt;/code&gt;) and floats (&lt;code&gt;123.4&lt;/code&gt;) in Elixir are represented as a sequence of digits that may be separated by underscore for readability purposes, such as &lt;code&gt;1_000_000&lt;/code&gt;. Integers never contain a dot (&lt;code&gt;.&lt;/code&gt;) in their representation. Floats contain a dot and at least one other digit after the dot. Floats also support the scientific notation, such as &lt;code&gt;123.4e10&lt;/code&gt; or &lt;code&gt;123.4E10&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b69f8490219ca339df3ffe0a24133cf0845a779" translate="yes" xml:space="preserve">
          <source>Integers can be &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt;, defaulting to &lt;code&gt;unsigned&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2871c600eee20d37fb547e17a478f66ee810c41" translate="yes" xml:space="preserve">
          <source>Integers in other bases and Unicode code points</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67bd439657ec8c91af9cab8e9c61775e95c7d415" translate="yes" xml:space="preserve">
          <source>Integration with Mix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7b691a3d33f4bf5d25d380d9c0cebf6d69f172" translate="yes" xml:space="preserve">
          <source>Integration with OS level tracers, such as &lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/LTTng.html&quot;&gt;Linux Trace Toolkit,&lt;/a&gt;&lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/DTRACE.html&quot;&gt;DTRACE,&lt;/a&gt; and &lt;a href=&quot;http://erlang.org/doc/apps/runtime_tools/SYSTEMTAP.html&quot;&gt;SystemTap&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d798c0b1cd4a6d135dc1e4671cde5f33dab863b" translate="yes" xml:space="preserve">
          <source>Interactive mode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6815f4d63967846048009b2275fddb5992a2ae7f" translate="yes" xml:space="preserve">
          <source>Internal dependencies</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd76d47a90f8cc879523d078abeee342549c2a2c" translate="yes" xml:space="preserve">
          <source>Internal dependencies are the ones that are specific to your project. They usually don&amp;rsquo;t make sense outside the scope of your project/company/organization. Most of the time, you want to keep them private, whether due to technical, economic or business reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6edc5ae2d27d92f734915c3bcae38bfcff562e82" translate="yes" xml:space="preserve">
          <source>Internal special form for block expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9df6e3733e8709e741819162ae8b21c5560f05" translate="yes" xml:space="preserve">
          <source>Internal special form to hold aliases information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea238b82c732c14af0d56ae146c57de7821e30a" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; is implemented as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="827c1e94219dfeaae7b53280233314ac83030abd" translate="yes" xml:space="preserve">
          <source>Internally, this function uses a &lt;a href=&quot;port&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; for interacting with the outside world. However, if you plan to run a long-running program, ports guarantee stdin/stdout devices will be closed but it does not automatically terminate the program. The documentation for the &lt;a href=&quot;port&quot;&gt;&lt;code&gt;Port&lt;/code&gt;&lt;/a&gt; module describes this problem and possible solutions under the &quot;Zombie processes&quot; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77ae57c279c9e2ef961ac607460659eac146477d" translate="yes" xml:space="preserve">
          <source>Interpolation and escaping in sigils</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f901cbbe7edd4e8b636ff99e09fd9aa3ab5b6c2c" translate="yes" xml:space="preserve">
          <source>Intersperses &lt;code&gt;element&lt;/code&gt; between each element of the enumeration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="3ad9a82c5e5ec7f5cdb591679187a3a184cc6e2c" translate="yes" xml:space="preserve">
          <source>Introduction to Mix</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="556666f2a50884d36f095e81af9943cd94538e19" translate="yes" xml:space="preserve">
          <source>Invalid (when setup_all fails)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="979685031faaab9869c01a670026bc6edde40c74" translate="yes" xml:space="preserve">
          <source>Invoke the required callback &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2fcbf3d8569fd3d11cfd7171a8054a4d1a7f48" translate="yes" xml:space="preserve">
          <source>Invoked at the beginning of every nesting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3131af8070d80cb4438964eca7dde39215d4a38c" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value stored under &lt;code&gt;key&lt;/code&gt; in the given term &lt;code&gt;term&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b22a1f1a89dd3f3bab30cb805e59f8edfe29b611" translate="yes" xml:space="preserve">
          <source>Invoked in order to access the value under &lt;code&gt;key&lt;/code&gt; and update it at the same time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f708aba5828f8cac72cfe36605553c37461c0165" translate="yes" xml:space="preserve">
          <source>Invoked in some cases to retrieve a formatted version of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f17640bca3b36f9d932ef8aed6fea2692e715d" translate="yes" xml:space="preserve">
          <source>Invoked to &quot;pop&quot; the value under &lt;code&gt;key&lt;/code&gt; out of the given data structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ffa339626f86dfddb50d2f5a5ebf28a3fe4886f" translate="yes" xml:space="preserve">
          <source>Invoked to change the state of the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; when a different version of a module is loaded (hot code swapping) and the state's term structure should be changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd464e0a7bfe3444479112d481808fd4426398a" translate="yes" xml:space="preserve">
          <source>Invoked to handle &lt;code&gt;continue&lt;/code&gt; instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823c64bbe586eac0f81ae84a9ece9107aadfc7b3" translate="yes" xml:space="preserve">
          <source>Invoked to handle all other messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="251e86e0358f8330275ee3b3f133b8139914e86a" translate="yes" xml:space="preserve">
          <source>Invoked to handle asynchronous &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt; messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="490b6e99cd71fc7e4dff011cebfd6c5bbbf5b87c" translate="yes" xml:space="preserve">
          <source>Invoked to handle synchronous &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt; messages. &lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt; will block until a reply is received (unless the call times out or nodes are disconnected).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971fbd6b9ae7269a95c5e43e7e31db62769d21ec" translate="yes" xml:space="preserve">
          <source>Invoked when initializing a config provider.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618d0cf7ef6acc312a2d60fcc796f79659809cb5" translate="yes" xml:space="preserve">
          <source>Invoked when the server is about to exit. It should do any cleanup required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d36bf5909d0181e92966ebf880c59e2f526bd11" translate="yes" xml:space="preserve">
          <source>Invoked when the server is started. &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#start/3&quot;&gt;&lt;code&gt;start/3&lt;/code&gt;&lt;/a&gt; will block until it returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc23160ff26718d1a90643ca2158ff18ecfa2d78" translate="yes" xml:space="preserve">
          <source>Invokes &lt;code&gt;fun&lt;/code&gt; for each element in the &lt;code&gt;enumerable&lt;/code&gt; with the accumulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3f9c65eaf0d3e4e4ac9e30375324284bc3c5a7" translate="yes" xml:space="preserve">
          <source>Invokes at the end of a nesting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9056f0569ac34dc376baf3f7e7aa026280e9f07" translate="yes" xml:space="preserve">
          <source>Invokes the callback with all entries under &lt;code&gt;key&lt;/code&gt; in each partition for the given &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ee7c7e2a41aa50f02ea0f66057171a17276f9a" translate="yes" xml:space="preserve">
          <source>Invokes the given &lt;code&gt;fun&lt;/code&gt; for each element in the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c515146dfdcfd5de926f55b367fb13cb7ae87958" translate="yes" xml:space="preserve">
          <source>Invokes the given anonymous function &lt;code&gt;fun&lt;/code&gt; with the list of arguments &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa0eb875a1a8fbbb92dc87b00ef479f56d53d97" translate="yes" xml:space="preserve">
          <source>Invokes the given function from &lt;code&gt;module&lt;/code&gt; with the list of arguments &lt;code&gt;args&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5649c0331fbb3552ad202de096382bf84abd3b21" translate="yes" xml:space="preserve">
          <source>Invokes the given function to each element in the &lt;code&gt;enumerable&lt;/code&gt; to reduce it to a single element, while keeping an accumulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0eda3fd7457c0fb4308b75d0bf6df3d4719aced" translate="yes" xml:space="preserve">
          <source>Is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a559a239bb82de0629bcb6a428aeb5fd89db0826" translate="yes" xml:space="preserve">
          <source>Is the same as:</source>
          <target state="translated">와 같다:</target>
        </trans-unit>
        <trans-unit id="c5705683fdebc9e7c3a2a72f5f351756cecd2661" translate="yes" xml:space="preserve">
          <source>It accepts a list of &lt;code&gt;imported_paths&lt;/code&gt; that should raise if attempted to be imported again (to avoid recursive imports).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b02345541bef5990635992a1f66fbd5e80cdc19" translate="yes" xml:space="preserve">
          <source>It accepts a set of &lt;code&gt;options&lt;/code&gt; to configure &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;ExUnit&lt;/code&gt;&lt;/a&gt; (the same ones accepted by &lt;a href=&quot;#configure/1&quot;&gt;&lt;code&gt;configure/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c6bdae26359278127b2679c1e0f6e34574670e1" translate="yes" xml:space="preserve">
          <source>It accepts the same options as &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#parse_head/2&quot;&gt;&lt;code&gt;parse_head/2&lt;/code&gt;&lt;/a&gt; as both functions are built on top of this function. This function may return:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c79809b7aa93e13235dedf1c047e396021dbc2" translate="yes" xml:space="preserve">
          <source>It accepts the struct module or a struct itself and simply removes the &lt;code&gt;__struct__&lt;/code&gt; field from the given struct or from a new struct generated from the given module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9db7ae3984a1b1beb1ad6d9414dcb836e49e4a46" translate="yes" xml:space="preserve">
          <source>It allows a developer to dynamically add, delete and register attributes, attach documentation and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e72ef20465fc62c76630754f83ef1dcdcf00df1" translate="yes" xml:space="preserve">
          <source>It allows developers to lookup one or more processes with a given key. If the registry has &lt;code&gt;:unique&lt;/code&gt; keys, a key points to 0 or 1 processes. If the registry allows &lt;code&gt;:duplicate&lt;/code&gt; keys, a single key may point to any number of processes. In both cases, different keys could identify the same process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a71454b932a3e5f1fc7b4c0e7b18e42341a6164" translate="yes" xml:space="preserve">
          <source>It also accepts extra options, for the list of available options check &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt;&lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fbb9737feae3b4fd98e6dc6a9178278f7164fb2" translate="yes" xml:space="preserve">
          <source>It also accepts functions in the format &lt;code&gt;function/arity&lt;/code&gt; and &lt;code&gt;module.function/arity&lt;/code&gt;, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ac564cc223e5941d854a27c61609f6da592403" translate="yes" xml:space="preserve">
          <source>It also accepts single module argument to list all available behaviour callbacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c75c3d13969e4bc5682206b7605cdbcb131cac76" translate="yes" xml:space="preserve">
          <source>It also checks the inbox for an input message matching:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d684369d14eb5a8f47ce27babf1c852d61fa5f18" translate="yes" xml:space="preserve">
          <source>It also works with operators and other constructs (try &lt;code&gt;h +/2&lt;/code&gt;). Invoking &lt;code&gt;h&lt;/code&gt; without arguments displays the documentation for &lt;code&gt;IEx.Helpers&lt;/code&gt;, which is where &lt;code&gt;h&lt;/code&gt; and other functionality is defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a500beab3e68eedeee4019c52133aa404957a732" translate="yes" xml:space="preserve">
          <source>It can be a regular file, directory, socket, symbolic link, named pipe, or device file. Returns &lt;code&gt;false&lt;/code&gt; for symbolic links pointing to non-existing targets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c22cd573aa0e917048596a531fe8bd4df0ba66d2" translate="yes" xml:space="preserve">
          <source>It can be upgraded to the DynamicSupervisor like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4ae51a95fbbfa60a796e3589c4762cdf4df826" translate="yes" xml:space="preserve">
          <source>It can be used in your &lt;code&gt;mix.exs&lt;/code&gt; to prepend or append new compilers to Mix:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28b1a3769a282dd753685d31c1db0ca20ed8c01c" translate="yes" xml:space="preserve">
          <source>It contains the following fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1426f38289e13f36126375da54309f97a70a12" translate="yes" xml:space="preserve">
          <source>It contains these fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="113d9a8235b2ac8f428decf342fbd7858aa4973c" translate="yes" xml:space="preserve">
          <source>It could also be corrected by using multiple guards, so that if an exception causes one guard to fail, the next one is evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1987bff89f1c6703dd2895ae7707929f8d89192f" translate="yes" xml:space="preserve">
          <source>It depends. It is ok to rely on shared state as long as we depend only on a non-shared partition of this state. Although multiple registries may start buckets on the shared bucket supervisor, those buckets and registries are isolated from each other. We would only run into concurrency issues if we used a function like &lt;code&gt;Supervisor.count_children(KV.BucketSupervisor)&lt;/code&gt; which would count all buckets from all registries, potentially giving different results when tests run concurrently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a261e69bb9abf1be6a9e6bf29d1f5c299e998d0" translate="yes" xml:space="preserve">
          <source>It differs in that the test suite will fail if no tests are executed when the &lt;code&gt;--only&lt;/code&gt; option is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bebaceae48e94abb745e77cdc9d79c5704717c94" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t seem to work at all. That&amp;rsquo;s because we are serving requests in the same process that are accepting connections. When one client is connected, we can&amp;rsquo;t accept another client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c00afbabba2721adf88ec3c29e863b42471b6a" translate="yes" xml:space="preserve">
          <source>It enables pretty printing by default with width of 80 characters. The width can be changed by explicitly passing the &lt;code&gt;:width&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c802c651048f44f24f8b3150960035a31699cb" translate="yes" xml:space="preserve">
          <source>It exists for convenience purposes. For example, you could invoke it inside your &lt;code&gt;mix.exs&lt;/code&gt; to read some external data you decided to move to a configuration file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfbe9f805346901fb7658c3a10caf05daf303078" translate="yes" xml:space="preserve">
          <source>It expects a &lt;code&gt;radius&lt;/code&gt; which chooses how many lines before and after the current line we should print. By default the &lt;code&gt;radius&lt;/code&gt; is of two lines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8f41592949431573d9fa16ad07b816bc20d280c" translate="yes" xml:space="preserve">
          <source>It expects a child specification or a module, similar to the ones given to &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html#start_link/2&quot;&gt;&lt;code&gt;Supervisor.start_link/2&lt;/code&gt;&lt;/a&gt;. For example, if your application starts a supervision tree by running:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88606c2938fbdad4196a7b400eb0db21cee6ea05" translate="yes" xml:space="preserve">
          <source>It expects a list of files to compile and an optional path to write the compiled code to. By default files are in-memory compiled. To write compiled files to the current directory, an empty string can be given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95cc29acd1a8f43652435b365857f4644147164" translate="yes" xml:space="preserve">
          <source>It expects a time zone to put the &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; in. If the time zone is &quot;Etc/UTC&quot;, it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as &lt;code&gt;time_zone_database&lt;/code&gt;. See the &quot;Time zone database&quot; section in the module documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a16340d7de1aebc03edf6573a0e15525a829528" translate="yes" xml:space="preserve">
          <source>It expects a time zone to put the NaiveDateTime in. If the time zone is &quot;Etc/UTC&quot;, it always succeeds. Otherwise, the NaiveDateTime is checked against the time zone database given as &lt;code&gt;time_zone_database&lt;/code&gt;. See the &quot;Time zone database&quot; section in the module documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6e8dcd4689f9bb5cfe59fd80447b6dfb675bc3e" translate="yes" xml:space="preserve">
          <source>It expects an accumulator and a function that receives each enumerable element, and must return a tuple containing a new enumerable (often a list) with the new accumulator or a tuple with &lt;code&gt;:halt&lt;/code&gt; as first element and the accumulator as second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae9f951251e613dc3b8cb49889447942b487f90f" translate="yes" xml:space="preserve">
          <source>It expects an accumulator and a function that receives each stream element and an accumulator, and must return a tuple containing a new stream (often a list) with the new accumulator or a tuple with &lt;code&gt;:halt&lt;/code&gt; as first element and the accumulator as second.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb9574f709769eda3fcd701f6835100d09de7b2" translate="yes" xml:space="preserve">
          <source>It happens we can also use this same syntax for updating the value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d301b15b4e45486cec4db8315f250c006b60e6f" translate="yes" xml:space="preserve">
          <source>It has to be replaced by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272be857efb69d0027fa3d247e076f214cedbf37" translate="yes" xml:space="preserve">
          <source>It includes assigns (like &lt;code&gt;@foo&lt;/code&gt;) and possibly other conveniences in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6566504417caf3c9fcfa6f04770ab2069caa71e8" translate="yes" xml:space="preserve">
          <source>It includes many features:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71b759b7ba0ceba9436adc2e4d919d9a0599963f" translate="yes" xml:space="preserve">
          <source>It is advised to pass to &lt;a href=&quot;#to_argv/2&quot;&gt;&lt;code&gt;to_argv/2&lt;/code&gt;&lt;/a&gt; the same set of &lt;code&gt;options&lt;/code&gt; given to &lt;a href=&quot;#parse/2&quot;&gt;&lt;code&gt;parse/2&lt;/code&gt;&lt;/a&gt;. Some switches can only be reconstructed correctly with the &lt;code&gt;:switches&lt;/code&gt; information in hand.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec9133e5ffa0e2eb38967925bbcd3b498316545" translate="yes" xml:space="preserve">
          <source>It is also possible to put an element at a particular index in a tuple with &lt;code&gt;put_elem/3&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68a13c5162ca9952e7df7f252e41c665b4a6ce1a" translate="yes" xml:space="preserve">
          <source>It is also possible to register the &lt;code&gt;pid&lt;/code&gt;, giving it a name, and allowing everyone that knows the name to send it messages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a136eb79bc8a61b01254d5faf81fdf246125d6a9" translate="yes" xml:space="preserve">
          <source>It is also possible to spawn a task under a supervisor. The &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; module implements the &lt;a href=&quot;#child_spec/1&quot;&gt;&lt;code&gt;child_spec/1&lt;/code&gt;&lt;/a&gt; function, which allows it to be started directly under a supervisor by passing a tuple with a function to run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d56d59c22a31d0146ae9749c3030a51ef3731009" translate="yes" xml:space="preserve">
          <source>It is also used between &lt;code&gt;fn/end&lt;/code&gt; for building anonymous functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e71075219fd34ef819cdd9dc47abc0939b0f36" translate="yes" xml:space="preserve">
          <source>It is also very common to use &lt;code&gt;IO.inspect/2&lt;/code&gt; with &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html#binding/0&quot;&gt;&lt;code&gt;binding()&lt;/code&gt;&lt;/a&gt;, which returns all variable names and their values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d30bf8f40195feb2fe708ceb6f9af150955200b6" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 366.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32489e7a3e2d6e237839e846a2d9f094cd20f95c" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef7af646cd422fb9f21670a1cedef851042bc5d" translate="yes" xml:space="preserve">
          <source>It is an integer from 1 to 7, where 1 is Monday and 7 is Sunday.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3505fd23f7d466c912f750fe33536eb913541ef" translate="yes" xml:space="preserve">
          <source>It is available only in the &lt;code&gt;catch&lt;/code&gt; and &lt;code&gt;rescue&lt;/code&gt; clauses of &lt;a href=&quot;#try/1&quot;&gt;&lt;code&gt;try/1&lt;/code&gt;&lt;/a&gt; expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80946675cc21f317c9b0ef6e5905961ee735ea93" translate="yes" xml:space="preserve">
          <source>It is exactly this supervision system that makes constructs like &lt;code&gt;try/catch&lt;/code&gt; and &lt;code&gt;try/rescue&lt;/code&gt; so uncommon in Elixir. Instead of rescuing an error, we&amp;rsquo;d rather &amp;ldquo;fail fast&amp;rdquo; since the supervision tree will guarantee our application will go back to a known initial state after the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d207929393d3a65f7ffe43fdfee93a560fcbb309" translate="yes" xml:space="preserve">
          <source>It is extremely important that &lt;strong&gt;the formatting function does not fail&lt;/strong&gt;, as it will bring that particular logger instance down, causing your system to temporarily lose messages. If necessary, wrap the function in a &lt;code&gt;rescue&lt;/code&gt; and log a default message instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94832ece51ae5f1825006490cfa48c6fe6830752" translate="yes" xml:space="preserve">
          <source>It is important that a macro is defined before its usage. Failing to define a macro before its invocation will raise an error at runtime, since the macro won&amp;rsquo;t be expanded and will be translated to a function call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0771070acf565ebd4c40d426b39c1e6523d52f21" translate="yes" xml:space="preserve">
          <source>It is important that you choose an editor command that does not block nor that attempts to run an editor directly in the terminal. Command-line based editors likely need extra configuration so they open up the given file and line in a separate window.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b481005fe84ee670ac7d11f9a15a1a80d4c1bd8f" translate="yes" xml:space="preserve">
          <source>It is important to bear in mind that variables defined inside &lt;code&gt;try/catch/rescue/after&lt;/code&gt; blocks do not leak to the outer context. This is because the &lt;code&gt;try&lt;/code&gt; block may fail and as such the variables may never be bound in the first place. In other words, this code is invalid:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6056e64535d65b5186c963f7472dd3b3997efc0" translate="yes" xml:space="preserve">
          <source>It is important to consider the limitations of distributed agents. Agents provide two APIs, one that works with anonymous functions and another that expects an explicit module, function, and arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f355f25591ea852cf993c5e79bb23c864b9b3d30" translate="yes" xml:space="preserve">
          <source>It is important to highlight that step 2 is a blocking one. Termination of a supervisor triggers a recursive chain of children terminations, therefore orderly shutting down all descendant processes. The &lt;a href=&quot;#c:stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt; callback is invoked only after termination of the whole supervision tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5cda11adf3996ed10a3333a6901fb7bf070783d" translate="yes" xml:space="preserve">
          <source>It is important to note a couple of things:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c367faed115a28802b3ecac8ce4c9b1b9a88de2a" translate="yes" xml:space="preserve">
          <source>It is important to note that a name without &lt;code&gt;!&lt;/code&gt; does not mean a function will never raise. For example, even &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; can fail in case of bad arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d0775b812a63ae04cc72818c998dd0360e82ac" translate="yes" xml:space="preserve">
          <source>It is important to note that reading an attribute takes a snapshot of its current value. In other words, the value is read at compilation time and not at runtime. Check the &lt;a href=&quot;module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt; module for other functions to manipulate module attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a19241f2445b2abd37c68c335fe23ae6dbe32fe5" translate="yes" xml:space="preserve">
          <source>It is important to notice that &lt;a href=&quot;#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt; is lexical. This means you can import specific macros inside specific functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74faff03e6fb39084e8fdee360d2d52a55c9644f" translate="yes" xml:space="preserve">
          <source>It is not recommended to &lt;code&gt;await&lt;/code&gt; a long-running task inside an OTP behaviour such as &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. Instead, you should match on the message coming from a task inside your &lt;a href=&quot;genserver#c:handle_info/2&quot;&gt;&lt;code&gt;GenServer.handle_info/2&lt;/code&gt;&lt;/a&gt; callback. For more information on the format of the message, see the documentation for &lt;a href=&quot;#async/1&quot;&gt;&lt;code&gt;async/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f8ca3b4e0816d59dc7e2cc08d33fe47c5a02853" translate="yes" xml:space="preserve">
          <source>It is not required to call this function when terminating the caller, unless exiting with reason &lt;code&gt;:normal&lt;/code&gt; or if the task is trapping exits. If the caller is exiting with a reason other than &lt;code&gt;:normal&lt;/code&gt; and the task is not trapping exits, the caller's exit signal will stop the task. The caller can exit with reason &lt;code&gt;:shutdown&lt;/code&gt; to shut down all of its linked processes, including tasks, that are not trapping exits without generating any log messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67f36f6c8c75697bc200a5a574eb5412409dbdaf" translate="yes" xml:space="preserve">
          <source>It is possible to get shell history by passing some options that enable it in the VM. This can be done on a per-need basis when starting IEx:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69aceb3d7f53fc191d1a69a74161461cd8fbf145" translate="yes" xml:space="preserve">
          <source>It is possible to implement protocols for all Elixir types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54b8401178da67a2e8ae820b1821bcca42b37a5a" translate="yes" xml:space="preserve">
          <source>It is possible to load another file by supplying the &lt;code&gt;--dot-iex&lt;/code&gt; option to IEx. See &lt;code&gt;iex --help&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4658430a105177a520b05efa9b8a1f1f62f88a4e" translate="yes" xml:space="preserve">
          <source>It is received by formatters and contains the following fields:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02b1294519dc996fe92a26357c7d5248dd2135f9" translate="yes" xml:space="preserve">
          <source>It is recommended for this function to be invoked in your application's start callback in case you want to register new URIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8259dbbda9694f8ea6053003d2b8b79b9d00cb" translate="yes" xml:space="preserve">
          <source>It is recommended that backends support at least the following configuration options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b6fa79cb9bec0bdf62d160c7cca8aebb12f76e" translate="yes" xml:space="preserve">
          <source>It is recommended that handlers ignore messages where the group leader is in a different node than the one where the handler is installed. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f259c2cd34cad051f58a609a1b449871f089e4f6" translate="yes" xml:space="preserve">
          <source>It is recommended to define types for structs. By convention such type is called &lt;code&gt;t&lt;/code&gt;. To define a struct inside a type, the struct literal syntax is used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d5fa416a3649615d6c6d6b9cb2027f26118c8ff" translate="yes" xml:space="preserve">
          <source>It is recommended to only use the struct syntax when defining the struct's type. When referring to another struct it's better to use &lt;code&gt;User.t&lt;/code&gt; instead of &lt;code&gt;%User{}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5056e9d07d3e016975093e74ccd6e13e0e051a1" translate="yes" xml:space="preserve">
          <source>It is seen on &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;cond&lt;/code&gt; constructs between &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;end&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a7029e719605ca3d075a3021c347e0da442f5a" translate="yes" xml:space="preserve">
          <source>It is the VM view of the &lt;a href=&quot;#os_time/0&quot;&gt;&lt;code&gt;os_time/0&lt;/code&gt;&lt;/a&gt;. They may not match in case of time warps although the VM works towards aligning them. This time is not monotonic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788b993466f063f33f672e4a2e86998a7111a391" translate="yes" xml:space="preserve">
          <source>It is useful for performing work after initialization or for splitting the work in a callback in multiple steps, updating the process state along the way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb15e04c4610818bfc29250241bbd9f9e91a6db6" translate="yes" xml:space="preserve">
          <source>It is usually compiled to an atom:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="609d6804675f59ef88a96987b74ba4711ad19be8" translate="yes" xml:space="preserve">
          <source>It is worth mentioning that some tasks, such as in the case of the &lt;code&gt;format&lt;/code&gt; command in the example above, can accept multiple files so it could be rewritten as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581eca3344ca4bb0aa530a5501c01bfdeab48bb0" translate="yes" xml:space="preserve">
          <source>It is worth noting that an IO stream has side effects and every time you go over the stream you may get different results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d4db08190e3953685aadfa886d49cc802cec92" translate="yes" xml:space="preserve">
          <source>It is, however, possible to customize the operating system exit signal by invoking:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d48f671c8d7393dad3a546a97b3ca8d3a912b7" translate="yes" xml:space="preserve">
          <source>It mainly consists of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e0c789d57c1d4d0b775a90fcdfa554caa5f5673" translate="yes" xml:space="preserve">
          <source>It may also be used in bit strings to specify the type of a given bit segment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3af067d0b325c04e2171267019d9beee23844b2" translate="yes" xml:space="preserve">
          <source>It may be &lt;em&gt;done&lt;/em&gt; when the enumeration is finished by reaching its end, or &lt;em&gt;halted&lt;/em&gt;/&lt;em&gt;suspended&lt;/em&gt; when the enumeration was halted or suspended by the &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d98718d8646c579d0371793bd45e746bde50bf4" translate="yes" xml:space="preserve">
          <source>It may raise an exception if an alias or a task can't be found or the task is invalid. Check &lt;a href=&quot;#get!/1&quot;&gt;&lt;code&gt;get!/1&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96e34b31aa2d5f1e971f892ae829e91c39507ae8" translate="yes" xml:space="preserve">
          <source>It merely logged an error but the parent process is still running. That&amp;rsquo;s because processes are isolated. If we want the failure in one process to propagate to another one, we should link them. This can be done with &lt;code&gt;spawn_link/1&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7645b02092dd9c481669b06461dd8a3b1f2ddfe" translate="yes" xml:space="preserve">
          <source>It must be a tagged tuple with one of the following &quot;tags&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9191e1a92c69837df58d349dc309a932384aa7e6" translate="yes" xml:space="preserve">
          <source>It must return Elixir's quoted expressions for the nesting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712b77376d5995f0d379321d9075dffa76132d6d" translate="yes" xml:space="preserve">
          <source>It must return Elixir's quoted expressions for the template.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38cc5837d518a2974bbdd3756a4a52b60b4904d1" translate="yes" xml:space="preserve">
          <source>It must return a new state that is used only inside the nesting. Once the nesting terminates, the current &lt;code&gt;state&lt;/code&gt; is resumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0854aef4598e67609aceb61dad3e1730bf8b1dd1" translate="yes" xml:space="preserve">
          <source>It must return the initial state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3fb70c8558503fe57ada3a7512d669bb23cc15f" translate="yes" xml:space="preserve">
          <source>It must return the updated state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168abfa6eb1b0dfa8208332679693b0f2aede472" translate="yes" xml:space="preserve">
          <source>It performs Normalization Form Canonical Decomposition (NFD) on the strings before comparing them. This function is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00eb69ecf576738c75d84548dd92cdb318ece3aa" translate="yes" xml:space="preserve">
          <source>It raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;pid&lt;/code&gt; is not a local process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e7523b5dc45d67bb8b9c0de3919b26ce0d37a20" translate="yes" xml:space="preserve">
          <source>It raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; when index is negative or it is out of range of the tuple elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7db82325b8b2d3d85d652577eadfac10c4e6cc9" translate="yes" xml:space="preserve">
          <source>It raises at compile time if the definition uses expressions that aren't allowed in guards, and otherwise creates a macro that can be used both inside or outside guards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1064c23cd1e6b9f641867dd10b3bf5061844678b" translate="yes" xml:space="preserve">
          <source>It raises at compile time if the definition uses expressions that aren't allowed in guards, and otherwise creates a private macro that can be used both inside or outside guards in the current module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4865031f19e0226674ccac4c00c4c4f11e96290" translate="yes" xml:space="preserve">
          <source>It receives the current &lt;code&gt;config&lt;/code&gt; and the &lt;code&gt;state&lt;/code&gt; returned by &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;. Then you typically read the extra configuration from an external source and merge it into the received &lt;code&gt;config&lt;/code&gt;. Merging should be done with &lt;a href=&quot;config.reader#merge/2&quot;&gt;&lt;code&gt;Config.Reader.merge/2&lt;/code&gt;&lt;/a&gt;, as it performs deep merge. It should return the updated config.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff8300751e75adc2c83e12f280310fb0e3959a9" translate="yes" xml:space="preserve">
          <source>It receives the same options as &lt;a href=&quot;#put_env/4&quot;&gt;&lt;code&gt;put_env/4&lt;/code&gt;&lt;/a&gt;. Returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63a1b1ead1b4654ed54aa371a1a054c21e1c05bd" translate="yes" xml:space="preserve">
          <source>It relies on &lt;a href=&quot;#format_banner/3&quot;&gt;&lt;code&gt;format_banner/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#format_stacktrace/1&quot;&gt;&lt;code&gt;format_stacktrace/1&lt;/code&gt;&lt;/a&gt; to generate the final format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0e052a45a87445bf1db1b18304c3b0b5b06885" translate="yes" xml:space="preserve">
          <source>It represents time as a fraction of a day (starting from midnight). &lt;code&gt;parts_in_day&lt;/code&gt; specifies how much of the day is already passed, while &lt;code&gt;parts_per_day&lt;/code&gt; signifies how many parts there fit in a day.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef0b176f883854b3bc16cf9fece54e5b9b4e4c75" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if it succeeds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4dd7376af1ba434a4580bda89ca9e2039d7b5af" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if the agent terminates with the given reason. If the agent terminates with another reason, the call will exit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa25fad557d19ecb8fc577a65e74f7d1d95fee17" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if the expression is valid. Otherwise it returns a tuple in the form of &lt;code&gt;{:error, remainder}&lt;/code&gt; where &lt;code&gt;remainder&lt;/code&gt; is the invalid part of the quoted expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1aa27a7fb3f7df06a7eb5b40933d88237c6da58a" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if the supervisor terminates with the given reason. If it terminates with another reason, the call exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20439119e73e5c84c38c2e670d5943fecce5bbc5" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;:ok&lt;/code&gt; if there is a supervised process with such &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;{:error, :not_found}&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6ba3f217ed1eba268a6fdafd4321bb54d3750b6" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;[]&lt;/code&gt; if &lt;code&gt;amount&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt; or if &lt;code&gt;start_index&lt;/code&gt; is out of bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a24863390fa39668ae8776992d58e83d80073d64" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, modules, warnings}&lt;/code&gt; or &lt;code&gt;{:error, errors, warnings}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15cf8a959344bff62a34e05c441e26b91698feeb" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, number_of_modules_purged}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="115a450f9d17534c1b57fc590c68a557bb8594c5" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;{:ok, regex}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de65d4d5bdecdb8de8753805e8f5f01ea831d124" translate="yes" xml:space="preserve">
          <source>It returns a charlist as if it was a single quoted string, unescaping characters and replacing interpolations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a66f3b8a76faa873e28dfa79a7a12532886cbb5f" translate="yes" xml:space="preserve">
          <source>It returns a list of &quot;words&quot; split by whitespace without escaping nor interpreting interpolations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11c767a0c0e8da6110101dac7c301abe9c23f7ad" translate="yes" xml:space="preserve">
          <source>It returns a list of &quot;words&quot; split by whitespace. Character unescaping and interpolation happens for each word.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5072f624143fef2c9ac9a882f637a2b3946d312" translate="yes" xml:space="preserve">
          <source>It returns a list with all defined functions and macros, public and private, in the shape of &lt;code&gt;[{name, arity}, ...]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12058e15be1548c9678ae57e51b9c05668dbfa6c" translate="yes" xml:space="preserve">
          <source>It returns a regular expression pattern without escaping nor interpreting interpolations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2339efe4030b11d97d29c7a067b3b9900e5b1d8" translate="yes" xml:space="preserve">
          <source>It returns a regular expression pattern, unescaping characters and replacing interpolations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eefd18752fd7d7d11850a6f38a6e135cd46467d" translate="yes" xml:space="preserve">
          <source>It returns a string as if it was a double quoted string, unescaping characters and replacing interpolations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1309542e01ede5ca574094267b91e1297dcf83b5" translate="yes" xml:space="preserve">
          <source>It returns a three-element tuple with the form &lt;code&gt;{parsed, args, invalid}&lt;/code&gt;, where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3aa2fe3892cfc7dc8712478400dbcd79a2ad47" translate="yes" xml:space="preserve">
          <source>It returns a tuple of shape &lt;code&gt;{:module, module, binary, term}&lt;/code&gt; where &lt;code&gt;module&lt;/code&gt; is the module name, &lt;code&gt;binary&lt;/code&gt; is the module byte code and &lt;code&gt;term&lt;/code&gt; is the result of the last expression in &lt;code&gt;quoted&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105ded5280b2ff4b7ca0620f752d88bc06179945" translate="yes" xml:space="preserve">
          <source>It returns a tuple where the first element is the first value for &lt;code&gt;key&lt;/code&gt; and the second element is a keyword list with all entries associated with &lt;code&gt;key&lt;/code&gt; removed. If the &lt;code&gt;key&lt;/code&gt; is not present in the keyword list, &lt;code&gt;{default, keyword_list}&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60c44e4aa381e2f2476e80a74b5488ef1fbe7e6d" translate="yes" xml:space="preserve">
          <source>It returns a tuple with the configuration and the imported paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c6d5c298bfea7e740d50d208c24e0a7cb35ea15" translate="yes" xml:space="preserve">
          <source>It returns a two-element tuple with two lists of elements. The element that triggered the split is part of the second list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fdf4c8d7953d6b126d5564a13f2c8bce040ab31" translate="yes" xml:space="preserve">
          <source>It returns the &lt;code&gt;mix.exs&lt;/code&gt; file, the lock manifest, and all config files in the &lt;code&gt;config&lt;/code&gt; directory that do not start with a leading period (for example, &lt;code&gt;.my_config.exs&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0d0c5e22a39b889893a15373fe9daae0aa2349" translate="yes" xml:space="preserve">
          <source>It returns the ast if it succeeds, raises an exception otherwise. The exception is a &lt;a href=&quot;tokenmissingerror&quot;&gt;&lt;code&gt;TokenMissingError&lt;/code&gt;&lt;/a&gt; in case a token is missing (usually because the expression is incomplete), &lt;a href=&quot;syntaxerror&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ddb2097e9b6c67aac6845519cb92def4ddcd595" translate="yes" xml:space="preserve">
          <source>It returns the deleted attribute value (or &lt;code&gt;nil&lt;/code&gt; if nothing was set).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02c714a4ea003b7686a6af1daae5b12a336be932" translate="yes" xml:space="preserve">
          <source>It returns the names of the compiled modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae123871707a2b6de82ed2c56ead673cc4cadc39" translate="yes" xml:space="preserve">
          <source>It returns the new map of compiler options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="766f8a3783379e82be75e43a3208cd1da372d673" translate="yes" xml:space="preserve">
          <source>It returns the number of Gregorian days between the dates. Only &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; structs that follow the same or compatible calendars can be compared this way. If two calendars are not compatible, it will raise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6852c5d07c3b9783a2c197a51ccbe9ab48fc88a" translate="yes" xml:space="preserve">
          <source>It returns the same as the built-in &lt;code&gt;node()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d85ecab1cba97830aafe60c7db9bcdf6c281beb4" translate="yes" xml:space="preserve">
          <source>It returns the term stored in the documentation chunk in the format defined by &lt;a href=&quot;http://erlang.org/eep/eeps/eep-0048.html&quot;&gt;EEP 48&lt;/a&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt; if the chunk is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3386214fb50a8516bbdf778fc1cd94340c90a3d8" translate="yes" xml:space="preserve">
          <source>It returns the updated version of the protocol bytecode. If the first element of the tuple is &lt;code&gt;:ok&lt;/code&gt;, it means the protocol was consolidated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c027793c4fcbf7f7be6aed911c23cf2d476fffe0" translate="yes" xml:space="preserve">
          <source>It returns:</source>
          <target state="translated">다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7e69f73c47c2d4297cd900ce85c28a9c948c1b19" translate="yes" xml:space="preserve">
          <source>It seems we are ready to go! We will use the interactive shell quite a lot in the next chapters to get a bit more familiar with the language constructs and basic types, starting in the next chapter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b61a10d3b18f5d9c1eaf6bc0cc59326c9f15aec" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, boolean}&lt;/code&gt; if you can check the membership of a given element in the &lt;code&gt;enumerable&lt;/code&gt; with &lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt; without traversing the whole enumerable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eda1ce345c7961b8d8eaacacd3842665d668e46" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, count}&lt;/code&gt; if you can count the number of elements in the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b69c5b898ed0b1df84697cb05eb4de3925bc611c" translate="yes" xml:space="preserve">
          <source>It should return &lt;code&gt;{:ok, size, slicing_fun}&lt;/code&gt; if the &lt;code&gt;enumerable&lt;/code&gt; has a known bound and can access a position in the &lt;code&gt;enumerable&lt;/code&gt; without traversing all previous elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6ec473d814fbb944cadb6ef7ecbd0b54ffb7903" translate="yes" xml:space="preserve">
          <source>It simply prints messages to stdio and stderr.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2bf5d9b723f91bde75bc41d3f4bce002f449711" translate="yes" xml:space="preserve">
          <source>It simply returns a charlist without escaping characters and without interpolations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c84e40ba905fa3630ef387da0561b471023546c1" translate="yes" xml:space="preserve">
          <source>It simply returns a string without escaping characters and without interpolations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ac5bb057ce19bda73528c6e24000df9f4d91f41" translate="yes" xml:space="preserve">
          <source>It simply runs the compilers registered in your project and returns a tuple with the compilation status and a list of diagnostics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16d9b6683d66aba15c717ff1071205cd0f26c442" translate="yes" xml:space="preserve">
          <source>It supports the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e490ec4460253855b541489b49bac1f8ad8cbb" translate="yes" xml:space="preserve">
          <source>It takes an &lt;code&gt;enumerable&lt;/code&gt; with elements being two-element tuples and returns a tuple with two lists, each of which is formed by the first and second element of each tuple, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65267298def1e5c3f27ba97cc79959f0ec4e9b43" translate="yes" xml:space="preserve">
          <source>It takes the &lt;code&gt;kind&lt;/code&gt; spilled by &lt;code&gt;catch&lt;/code&gt; as an argument and normalizes only &lt;code&gt;:error&lt;/code&gt;, returning the untouched payload for others.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="017d4c0f52ec05a16013c629cf13480b366963be" translate="yes" xml:space="preserve">
          <source>It uses &lt;a href=&quot;mix.tasks.xref&quot;&gt;&lt;code&gt;mix xref&lt;/code&gt;&lt;/a&gt; to check if any remote call does not exist or is deprecated, and emits warnings in such cases. This task does not show deprecated local calls (a call to a deprecated function or macro in the same module) nor calls to deprecated functionality in Elixir itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a6eb5a7e6cf2ff92914f35b6fcd693c9459181" translate="yes" xml:space="preserve">
          <source>It uses the given &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; documents as surrounding and the separator document &lt;code&gt;separator&lt;/code&gt; to separate items in &lt;code&gt;docs&lt;/code&gt;. If all entries in the collection are simple documents (texts or strings), then this function attempts to put as much as possible on the same line. If they are not simple, only one entry is shown per line if they do not fit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="359c8a3a80dc42f4d09ef45dc62e03c2a4526a01" translate="yes" xml:space="preserve">
          <source>It uses the shortest representation according to algorithm described in &quot;Printing Floating-Point Numbers Quickly and Accurately&quot; in Proceedings of the SIGPLAN '96 Conference on Programming Language Design and Implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226d68525abc4cd650686c46c4c3000914e7ba94" translate="yes" xml:space="preserve">
          <source>It will also append an &lt;a href=&quot;io.ansi#reset/0&quot;&gt;&lt;code&gt;IO.ANSI.reset/0&lt;/code&gt;&lt;/a&gt; to the chardata when a conversion is performed. If you don't want this behaviour, use &lt;a href=&quot;#format_fragment/2&quot;&gt;&lt;code&gt;format_fragment/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d625ecd25a91e55e3a68933b351320ae362d970" translate="yes" xml:space="preserve">
          <source>It will also unload all &lt;code&gt;:included_applications&lt;/code&gt;. Note that the function does not purge the application modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84aa5327df0b5a9bb286871a09b1bb5335320dee" translate="yes" xml:space="preserve">
          <source>It will raise &lt;a href=&quot;compileerror&quot;&gt;&lt;code&gt;CompileError&lt;/code&gt;&lt;/a&gt; if the struct is not available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e6ad31346e231231ef72c5f43225ffd3c66f70d" translate="yes" xml:space="preserve">
          <source>It will return the integer with the given unit, according to &lt;a href=&quot;system#convert_time_unit/3&quot;&gt;&lt;code&gt;System.convert_time_unit/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a600be691bf00b4e32fb62041ceec8dd63d79b4c" translate="yes" xml:space="preserve">
          <source>It works with improper lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6681def299dea9fa997a7ef9b6707d61767cc884" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to implement protocols for all Elixir data types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="999db6f61bff83218a31d16026d001272eea2261" translate="yes" xml:space="preserve">
          <source>It's also possible to pass a block to the &lt;a href=&quot;#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; macro. The first example above would be translated to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd7290dd76f46aa64bdbf468714a16cc5352938b" translate="yes" xml:space="preserve">
          <source>It's important to note that it returns the given &lt;code&gt;item&lt;/code&gt; unchanged. This makes it possible to &quot;spy&quot; on values by inserting an &lt;a href=&quot;io#inspect/2&quot;&gt;&lt;code&gt;IO.inspect/2&lt;/code&gt;&lt;/a&gt; call almost anywhere in your code, for example, in the middle of a pipeline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55e677bb7fe63cf491955ddb64be33b944554c67" translate="yes" xml:space="preserve">
          <source>It's often useful to have the AST for such a pipeline as a list of function applications. This function does exactly that:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b81b47272fec763e900d18ba6a1da4a3098cd954" translate="yes" xml:space="preserve">
          <source>Italic: on. Not widely supported. Sometimes treated as inverse.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0418eaaa46e9aed5bab2054a496fec5d581658a8" translate="yes" xml:space="preserve">
          <source>Iterates over the &lt;code&gt;enumerable&lt;/code&gt; and invokes &lt;code&gt;fun&lt;/code&gt; on each element. When an invocation of &lt;code&gt;fun&lt;/code&gt; returns a falsy value (&lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;false&lt;/code&gt; is returned. In all other cases &lt;code&gt;true&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c421120e85b180763b71f08518f3f5d485454d1b" translate="yes" xml:space="preserve">
          <source>Iterates over the &lt;code&gt;enumerable&lt;/code&gt; and invokes &lt;code&gt;fun&lt;/code&gt; on each element. When an invocation of &lt;code&gt;fun&lt;/code&gt; returns a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;) iteration stops immediately and &lt;code&gt;true&lt;/code&gt; is returned. In all other cases &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd3db045f018e16696466f5acea3521773d3a53" translate="yes" xml:space="preserve">
          <source>Its fields are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e084df8c1f3d9f015ea6c2b99c3b679805e965a" translate="yes" xml:space="preserve">
          <source>Joins a list of paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="515c03874ab491d886e1d1d7b31a372bcd15aaca" translate="yes" xml:space="preserve">
          <source>Joins the given &lt;code&gt;enumerable&lt;/code&gt; into a binary using &lt;code&gt;joiner&lt;/code&gt; as a separator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5648a991099408fa47ca83f65efd1693d2a9815" translate="yes" xml:space="preserve">
          <source>Joins two paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d488d22b9c11a34b40d4f43a44d7ca15f5548d" translate="yes" xml:space="preserve">
          <source>Just like &lt;a href=&quot;#runtime_info/0&quot;&gt;&lt;code&gt;runtime_info/0&lt;/code&gt;&lt;/a&gt;, except accepts topic or a list of topics. E.g. topic &lt;code&gt;:applications&lt;/code&gt; will list the applications loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e51db24d55d9857675a12f93a5ceb2ca695225d3" translate="yes" xml:space="preserve">
          <source>Keep in mind &lt;code&gt;@enforce_keys&lt;/code&gt; is a simple compile-time guarantee to aid developers when building structs. It is not enforced on updates and it does not provide any sort of value-validation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47ce96738f59dcbe1277607a7b62401517ee71a9" translate="yes" xml:space="preserve">
          <source>Keep in mind errors in guards do not leak but simply make the guard fail:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="019b3d215759f9f759de0ba07f898008173c2b71" translate="yes" xml:space="preserve">
          <source>Keep in mind reversing the same string twice does not necessarily yield the original string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11a21ef1004b00088384d2386c08e0ddfc5a422c" translate="yes" xml:space="preserve">
          <source>Keep in mind single-quoted and double-quoted representations are not equivalent in Elixir as they are represented by different types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31048d175f380df1b961d6b1c2e7ff99e30846d1" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; runs in the caller process, blocking the caller during the evaluation cycle. The caller process can be freed by calling &lt;a href=&quot;iex.helpers#respawn/0&quot;&gt;&lt;code&gt;respawn/0&lt;/code&gt;&lt;/a&gt;, which starts a new IEx evaluation cycle, letting this one go:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17dab74a9a2d31002a8d8b98ab8f2a1e7c69175a" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;assert&lt;/code&gt; does not change its semantics based on the expression. In other words, the expression is still required to return a truthy value. For example, the following will fail:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7a4e2f437f89496ebbe986e5235a9983fd7b7c" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;filter&lt;/code&gt; is not capable of filtering and transforming an element at the same time. If you would like to do so, consider using &lt;a href=&quot;#flat_map/2&quot;&gt;&lt;code&gt;flat_map/2&lt;/code&gt;&lt;/a&gt;. For example, if you want to convert all strings that represent an integer and discard the invalid one in one pass:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efcc18a9b0bcb482431019e0321fb20f799d7ca1" translate="yes" xml:space="preserve">
          <source>Keep in mind that &lt;code&gt;refute&lt;/code&gt; does not change the semantics of the given expression. In other words, the following will fail:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2711b72cad7dcad995d5896fe00c416e309a1ef1" translate="yes" xml:space="preserve">
          <source>Keep in mind that all tests are included by default, so unless they are excluded first, the &lt;code&gt;include&lt;/code&gt; option has no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681ff07e085798bf6140c0e48749d06c2f822db5" translate="yes" xml:space="preserve">
          <source>Keep in mind that you can always invoke the help task to list all available tasks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="725b47d6b2cb8b5dc76a5170928fd278550f1b34" translate="yes" xml:space="preserve">
          <source>Keep in mind that, by convention, whenever the inspected value starts with &lt;code&gt;#&lt;/code&gt;, it is representing a data structure in non-valid Elixir syntax. This means the inspect protocol is not reversible as information may be lost along the way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b83288ec921378850bb3f1fa7bae00089f1eb1e1" translate="yes" xml:space="preserve">
          <source>Keep in mind that, in order to know if an element is unique or not, this function needs to store all unique values emitted by the stream. Therefore, if the stream is infinite, the number of elements stored will grow infinitely, never being garbage-collected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84d731972e42a11f20590eec71a88a83f6bff7df" translate="yes" xml:space="preserve">
          <source>Keep in mind that, regardless of how the task created with &lt;code&gt;async_nolink&lt;/code&gt; terminates, the caller's process will always receive a &lt;code&gt;:DOWN&lt;/code&gt; message with the same &lt;code&gt;ref&lt;/code&gt; value that is held by the task struct. If the task terminates normally, the reason in the &lt;code&gt;:DOWN&lt;/code&gt; message will be &lt;code&gt;:normal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e72793cf5cb6c7b1a0ca2e28a8c6ee6025d9c8" translate="yes" xml:space="preserve">
          <source>Keep in mind the &lt;a href=&quot;#open/0&quot;&gt;&lt;code&gt;open/0&lt;/code&gt;&lt;/a&gt; location may not exist when prying precompiled source code, such as Elixir itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860e4edfbd6c5d2c7567e3d117fbea1f6f0c0f3d" translate="yes" xml:space="preserve">
          <source>Keep in mind the &lt;a href=&quot;#whereami/1&quot;&gt;&lt;code&gt;whereami/1&lt;/code&gt;&lt;/a&gt; location may not exist when prying precompiled source code, such as Elixir itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf33f85cbcbea5e44750e3785093cd27fc2107f" translate="yes" xml:space="preserve">
          <source>Keep in mind the location may not exist when opening precompiled source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d158165f2fc0a37c72c714056603422cfd15842" translate="yes" xml:space="preserve">
          <source>Keep in mind this issue also shows up when performing &quot;rolling upgrades&quot; with agents. By rolling upgrades we mean the following situation: you wish to deploy a new version of your software by &lt;em&gt;shutting down&lt;/em&gt; some of your nodes and replacing them with nodes running a new version of the software. In this setup, part of your environment will have one version of a given module and the other part another version (the newer one) of the same module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0156c07b778f553fcac957532e2ebb3cd9d736c" translate="yes" xml:space="preserve">
          <source>Keep the first paragraph of the documentation concise and simple, typically one-line. Tools like &lt;a href=&quot;https://github.com/elixir-lang/ex_doc/&quot;&gt;ExDoc&lt;/a&gt; use the first line to generate a summary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b89ed6c1e4d3aad0e25530664c1434bb7a8e1390" translate="yes" xml:space="preserve">
          <source>Keeping user's formatting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74808d3df030e992e7b9444241625147986487c1" translate="yes" xml:space="preserve">
          <source>Kernel</source>
          <target state="translated">Kernel</target>
        </trans-unit>
        <trans-unit id="b4d54f6ec686d8eb5175caf8d65ba08cfce6e603" translate="yes" xml:space="preserve">
          <source>Kernel functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeaeca0ac29205e969d2b8226d57305ccdd9354c" translate="yes" xml:space="preserve">
          <source>Kernel.ParallelCompiler</source>
          <target state="translated">Kernel.ParallelCompiler</target>
        </trans-unit>
        <trans-unit id="397b329c326c86881a0889837339130cb1378ece" translate="yes" xml:space="preserve">
          <source>Kernel.SpecialForms</source>
          <target state="translated">Kernel.SpecialForms</target>
        </trans-unit>
        <trans-unit id="c8ca7c123549a6d988a750c2deb07a14cc7d13fe" translate="yes" xml:space="preserve">
          <source>Key and value in each tuple will be binaries and will be percent-unescaped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa0ccdd4ef791d750570b7806e67eebc94ec0038" translate="yes" xml:space="preserve">
          <source>Key-based access to data structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="156eb45dfef4d621a4d1c63e18132edae922c7ad" translate="yes" xml:space="preserve">
          <source>Key-value pairs in a map do not follow any order (that's why the printed map in the example above has a different order than the map that was created).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74018238351de8a4b5f41ef51f98e3f2c94d5837" translate="yes" xml:space="preserve">
          <source>KeyError</source>
          <target state="translated">KeyError</target>
        </trans-unit>
        <trans-unit id="15dcfdc21056a09847eba4ff304e968ed3eb85e6" translate="yes" xml:space="preserve">
          <source>KeyError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9feb5a2ad29c5ac9a472aae0705f0b36f56f288c" translate="yes" xml:space="preserve">
          <source>Keys and values can be any term that implements the &lt;a href=&quot;string.chars&quot;&gt;&lt;code&gt;String.Chars&lt;/code&gt;&lt;/a&gt; protocol with the exception of lists, which are explicitly forbidden.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c871f27e8a5b87eb6c4a04f8a42a4f6e2ea2d87a" translate="yes" xml:space="preserve">
          <source>Keys are ordered, as specified by the developer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405b7423934af77dcf3ba5a20687064207764857" translate="yes" xml:space="preserve">
          <source>Keys can be given more than once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c61607fe5f12600b764431ebe5f8131aa4311b82" translate="yes" xml:space="preserve">
          <source>Keys for which there are no entries in &lt;code&gt;map&lt;/code&gt; are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4694e757bfed2949bf57d46a766c250bec95d827" translate="yes" xml:space="preserve">
          <source>Keys for which there are no entries in the keyword list are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5718a5ffdcdd81ef356ce973873d2a2560146789" translate="yes" xml:space="preserve">
          <source>Keys in maps can be accessed through some of the functions in this module (such as &lt;a href=&quot;map#get/3&quot;&gt;&lt;code&gt;Map.get/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;map#fetch/2&quot;&gt;&lt;code&gt;Map.fetch/2&lt;/code&gt;&lt;/a&gt;) or through the &lt;code&gt;map[]&lt;/code&gt; syntax provided by the &lt;a href=&quot;access&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b26620768b7c3d13232d03fbd0fd86edae1e9816" translate="yes" xml:space="preserve">
          <source>Keys in the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; that don't exist in the struct are automatically discarded. Note that keys must be atoms, as only atoms are allowed when defining a struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36720d74567b83e682047245f1678cc00bda2c58" translate="yes" xml:space="preserve">
          <source>Keys must be atoms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b946356405330b9605587c00c959f1283c7ebe0c" translate="yes" xml:space="preserve">
          <source>Keys must be atoms. Keys with &lt;code&gt;nil&lt;/code&gt; value are discarded, boolean values are converted to &lt;code&gt;--key&lt;/code&gt; or &lt;code&gt;--no-key&lt;/code&gt; (if the value is &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;, respectively), and all other values are converted using &lt;a href=&quot;kernel#to_string/1&quot;&gt;&lt;code&gt;Kernel.to_string/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3926e039fd753c472f6e172496fda0574369261" translate="yes" xml:space="preserve">
          <source>Keyword</source>
          <target state="translated">Keyword</target>
        </trans-unit>
        <trans-unit id="7c134e1191dc5c44edbda73b442ec456eb6a71ed" translate="yes" xml:space="preserve">
          <source>Keyword lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="018e651a39aa7ad2ac64ac5eb40095fd4e7a830c" translate="yes" xml:space="preserve">
          <source>Keyword lists and maps</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="392d9a31ec7b8f0bdc87d00f031b9e9bb8a73cb6" translate="yes" xml:space="preserve">
          <source>Keyword lists are always deep merged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a8ca5bd3ccea7e0c7d15c67c55d6d098576d862" translate="yes" xml:space="preserve">
          <source>Keyword lists are always deep-merged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac0300b9a6363d2ecf2708a6271a27720466a909" translate="yes" xml:space="preserve">
          <source>Keyword lists are important because they have three special characteristics:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f46ce1d1d7d871768a2c62a23f7074163ee126aa" translate="yes" xml:space="preserve">
          <source>Keyword lists play an important role in the language and are quite common in many functions and macros. We will explore them a bit more in a future chapter. Now it is time to talk about &amp;ldquo;Binaries, strings, and char lists&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f530db58b3e5088dc7412c6d2298ba3f8456bdeb" translate="yes" xml:space="preserve">
          <source>Keywords</source>
          <target state="translated">Keywords</target>
        </trans-unit>
        <trans-unit id="1ceb47d1e9d15d89ef0224d7d1b562dcf30b3896" translate="yes" xml:space="preserve">
          <source>Keywords as last arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a539f3ad19c8470b65f3028d300a7bb73e217a" translate="yes" xml:space="preserve">
          <source>Keywords in Elixir are a list of tuples of two elements where the first element is an atom. Using the base constructs, they would be represented as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2843be90e040c2ace2b060340b9db40c6dbf4a3" translate="yes" xml:space="preserve">
          <source>Known tags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e805fe1256b3cb3351f4f100e6b23dfaed4c00e" translate="yes" xml:space="preserve">
          <source>Last time we fixed the race condition by replacing the asynchronous operation, a &lt;code&gt;cast&lt;/code&gt;, by a &lt;code&gt;call&lt;/code&gt;, which is synchronous. Unfortunately, the &lt;code&gt;handle_info/2&lt;/code&gt; callback we are using to receive the &lt;code&gt;:DOWN&lt;/code&gt; message and delete the entry from the ETS table does not have a synchronous equivalent. This time, we need to find a way to guarantee the registry has processed the &lt;code&gt;:DOWN&lt;/code&gt; notification sent when the bucket process terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75acd19542cbb9fa88cdabbe078724acb812d8b1" translate="yes" xml:space="preserve">
          <source>Later on we will learn how to compile Elixir code (in &lt;a href=&quot;modules-and-functions&quot;&gt;Chapter 8&lt;/a&gt;) and how to use the Mix build tool (in the &lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix &amp;amp; OTP guide&lt;/a&gt;). For now, let&amp;rsquo;s move on to &lt;a href=&quot;basic-types&quot;&gt;Chapter 2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dec3727f52253a21a625cc6c295ee24dda78903b" translate="yes" xml:space="preserve">
          <source>Lazily drops elements of the enumerable while the given function returns a truthy value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee9b58962b88fa77ea098c1b0d427e9f46c19021" translate="yes" xml:space="preserve">
          <source>Lazily drops the next &lt;code&gt;n&lt;/code&gt; elements from the enumerable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69ade1dc23ccb5f3b64347640778d1f4fe8c44ae" translate="yes" xml:space="preserve">
          <source>Lazily intersperses &lt;code&gt;intersperse_element&lt;/code&gt; between each element of the enumeration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb2c9b6a976811f032d7cbfe8165bb5865150558" translate="yes" xml:space="preserve">
          <source>Lazily returns and removes all values associated with &lt;code&gt;key&lt;/code&gt; in the keyword list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61c3c17ee3d10d7647d9803c70ba26ee27244c1" translate="yes" xml:space="preserve">
          <source>Lazily returns and removes the value associated with &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e92baedbf908cf61336dc397f7fe80981871f17" translate="yes" xml:space="preserve">
          <source>Lazily takes elements of the enumerable while the given function returns a truthy value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="450194d4d3b114b2c73dd825ab3cd48712daf267" translate="yes" xml:space="preserve">
          <source>Lazily takes the next &lt;code&gt;count&lt;/code&gt; elements from the enumerable and stops enumeration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa3a1af379a945e27159d6cbd53b6758da22a91" translate="yes" xml:space="preserve">
          <source>Leap seconds are not taken into account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">더 알아보기</target>
        </trans-unit>
        <trans-unit id="34ce14772451e311453b61a1ddb8221e562b888f" translate="yes" xml:space="preserve">
          <source>Left to right</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efe84e15d94659b1eca2695c2253c5d3775e58ca" translate="yes" xml:space="preserve">
          <source>Left to right arrow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e68d562699894469c473720b475220fbf042128a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s also add a test to &lt;code&gt;test/kv/bucket_test.exs&lt;/code&gt; that guarantees the bucket is temporary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="404b4b3a784b443893ff8bf31f1dd037577b8b2e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s break that code apart a bit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4729229379e49f59080304c7286d1586582b445a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change &lt;code&gt;start/2&lt;/code&gt; once again, to add a supervisor to our tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a65af3d4df3dd7789d08b039fbd9ffd187026b1" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s change the &lt;code&gt;KV.Registry&lt;/code&gt; to use ETS tables. The first change is to modify our registry to require a name argument, we will use it to name the ETS table and the registry process itself. ETS names and process names are stored in different locations, so there is no chance of conflicts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e05a0ba8c59d0c8c376685e9addab95d169eccc" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s check each case, one by one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c27f60b2e4915c4a82ea29d51d011f01772e3dd9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create a new Mix project. We are going to creatively name it &lt;code&gt;kv_umbrella&lt;/code&gt;, and this new project will have both the existing &lt;code&gt;kv&lt;/code&gt; application and the new &lt;code&gt;kv_server&lt;/code&gt; application inside. The directory structure will look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9686ac5cd9d110e2280341ca7651f1e7a2c3a8f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create our command parser at &lt;code&gt;lib/kv_server/command.ex&lt;/code&gt; and start with the doctest:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57da67e011a89dbbfb6c22ba016b496c2bf15d61" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s create our first project by invoking &lt;code&gt;mix new&lt;/code&gt; from the command line. We&amp;rsquo;ll pass the project name as the argument (&lt;code&gt;kv&lt;/code&gt;, in this case), and tell Mix that our main module should be the all-uppercase &lt;code&gt;KV&lt;/code&gt;, instead of the default, which would have been &lt;code&gt;Kv&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44ccaac6800d7e69a627f543507cef6aaa36f75a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s define a module named &lt;code&gt;Hello&lt;/code&gt; in this shell:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d3183a361ff888bc82b3eb6a4eacbf2fa2a5c0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do so by creating a &amp;ldquo;bogus&amp;rdquo; bucket, which is a synchronous request, after &lt;code&gt;Agent.stop/2&lt;/code&gt; in both tests:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52cc88c9ff893fa670f476f83f7e11b188b0c8fb" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87f2c21bc94f91beaecdd70cb4c1e04e5acba348" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s first play with monitors by starting a new console with &lt;code&gt;iex -S mix&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfccd6e33d5a510641ee1fe031db4c15efbf06a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s get started!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66bbb9d93128da50d0a5fd0f342b723836429324" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give it a try by running &lt;code&gt;iex kv.exs&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5839691ae3f96ef964d421fd3acb9f807e8f4ab6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give it a try. Open up &lt;code&gt;lib/kv_server/application.ex&lt;/code&gt;, and let&amp;rsquo;s change the supervisor in the &lt;code&gt;start/2&lt;/code&gt; function to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baa34105a5b53a50e8c2b4ac1b991daa285cda4f" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s give the updated supervisor a try inside &lt;code&gt;iex -S mix&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56cfa20ba11b54abba073399ca2cc31a1beb82f3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s go back to the &lt;code&gt;Math&lt;/code&gt; module defined in the previous chapters, add some documentation and save it to the &lt;code&gt;math.ex&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e193874a827cfe3989b47093b1f35bf1d889de9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s implement the integration test in &lt;code&gt;test/kv_server_test.exs&lt;/code&gt; as shown below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3d61bf295e16bbbb18d9e86a778638333f98c0d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s implement those steps. Move to the &lt;code&gt;apps/kv_server&lt;/code&gt; application, open up &lt;code&gt;lib/kv_server.ex&lt;/code&gt;, and add the following functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e760533fa67c3a16cee4f61982aced80e52f83" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s learn how to do that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf8ebea7b04a470e898c361b3c01206eb4a8342a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s make another example using streams. Since the &lt;code&gt;IO&lt;/code&gt; module provides streams (that are both &lt;code&gt;Enumerable&lt;/code&gt;s and &lt;code&gt;Collectable&lt;/code&gt;s), an echo terminal that echoes back the upcased version of whatever is typed can be implemented using comprehensions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8179b6236a6127fea762c1dc4859e7ff9ad41e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move inside the apps directory and start building &lt;code&gt;kv_server&lt;/code&gt;. This time, we are going to pass the &lt;code&gt;--sup&lt;/code&gt; flag, which will tell Mix to generate a supervision tree automatically for us, instead of building one manually as we did in previous chapters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9abc4b0404a0faf043a413238fb9c0b85596b7d3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s move to the next chapter. We will finally make our system distributed by adding a bucket routing mechanism. We will use this opportunity to also improve our testing chops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="907c5a40686f1ad77133ab1fb7ed4fb9044e980b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now define a release for &lt;code&gt;:bar&lt;/code&gt;. One first step could be to define a release exactly like &lt;code&gt;foo&lt;/code&gt; inside &lt;code&gt;mix.exs&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a2917bda9d2d2ade9ad2c9418f4b2b9f81e1083" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s now see how we can use the power of recursion to sum a list of numbers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df2a11fdb0c0854864b329de4b39854b42d8a291" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s put it all together and send messages between processes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fe45cc7fb55e4c742c4dc05c2cb987f67c6d233" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s recap what is happening. Whenever we invoke &lt;code&gt;iex -S mix&lt;/code&gt;, it automatically starts our application by calling &lt;code&gt;Application.start(:kv)&lt;/code&gt;, which then invokes the application callback. The application callback job is to start a &lt;strong&gt;supervision tree&lt;/strong&gt;. Right now, we only have a single supervisor, but sometimes a supervisor is also supervised, giving it a shape of a tree. So far, our supervisor has a single child, a &lt;code&gt;KV.Registry&lt;/code&gt;, which is started with name &lt;code&gt;KV.Registry&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="325ed6370b4676504d3b00af4ba0fd26fde98423" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s reimplement the server callbacks to fix the bug and make the test pass. First, we will modify the GenServer state to two dictionaries: one that contains &lt;code&gt;name -&amp;gt; pid&lt;/code&gt; and another that holds &lt;code&gt;ref -&amp;gt; name&lt;/code&gt;. Then we need to monitor the buckets on &lt;code&gt;handle_cast/2&lt;/code&gt; as well as implement a &lt;code&gt;handle_info/2&lt;/code&gt; callback to handle the monitoring messages. The full server callbacks implementation is shown below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5859e594dd7ff75c74328e1ec62ef118e79b5173" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s rewrite the test case to use callbacks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7af0235d132a57562aba639e633d1cb04c26a76e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s run the tests once again. This time though, we will pass the &lt;code&gt;--trace&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aced57d244d27459d17d10f2ab48937597ad351" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see in more detail what happens when you request &lt;code&gt;IO.write(pid, binary)&lt;/code&gt;. The &lt;code&gt;IO&lt;/code&gt; module sends a message to the process identified by &lt;code&gt;pid&lt;/code&gt; with the desired operation. A small ad-hoc process can help us see it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67af3c48055ca2b3c2d9f546637c104f51f74e74" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see this in practice. Start a console with &lt;code&gt;iex -S mix&lt;/code&gt; and try:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dee2fe998155b6e01d27bc48c7887e983907b48" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s slightly change our children definition (in &lt;code&gt;KV.Supervisor.init/1&lt;/code&gt;) to be a list of tuples instead of a list of atoms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd92f7c84f63683d6101c71449ed203a7800ec9" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start &lt;code&gt;iex&lt;/code&gt; with the module above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1661fc8a81e848a401464f1c2a605c5da459d3" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start a new project using &lt;code&gt;mix new&lt;/code&gt;. This new project will be named &lt;code&gt;kv_umbrella&lt;/code&gt; and we need to pass the &lt;code&gt;--umbrella&lt;/code&gt; option when creating it. Do not create this new project inside the existing &lt;code&gt;kv&lt;/code&gt; project!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f966b08bc66cb4042c8b3f3f1b9e2153b0cd851" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start by creating a module that defines and imports the &lt;code&gt;test&lt;/code&gt; macro when used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0fddb1a8907c2cf50e04a25da3983ae6441dda6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with a test that describes how we want the registry to behave if a bucket stops or crashes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa11d581397d95e04f2020a68e066fb3e60d04a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a brief look at those generated files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e68357588d11fea0410465b619814c2039a742" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take a deeper look at &lt;code&gt;Enumerable&lt;/code&gt;s and, while we&amp;rsquo;re at it, their lazy counterpart, &lt;code&gt;Stream&lt;/code&gt;s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91b289146778a1a9ac545041f63405e023909059" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s take the supervior for a spin:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b01013918cb505bb54dd81a9af06894999c0120" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write a test to verify our router works. Create a file named &lt;code&gt;test/kv/router_test.exs&lt;/code&gt; containing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa012006b966bf0a6eab57a8968215cebf134379" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s write some code!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67023947ca555b00e6d88ffa6d4701c0c3be370" translate="yes" xml:space="preserve">
          <source>Let's build a stream and then enumerate it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af13b7ca9a49d1b748a7f4486807d45530939bbd" translate="yes" xml:space="preserve">
          <source>Let's create a document by concatenating two strings with a break between them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d78dfa30452eb74635f4fb43b15b17251e16913" translate="yes" xml:space="preserve">
          <source>Let's explore the basic functions from the &lt;a href=&quot;http://www.erlang.org/doc/man/sys.html&quot;&gt;&lt;code&gt;:sys&lt;/code&gt; module&lt;/a&gt; used for debugging:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="688ee6c95315db8b18bfec15fee2dfd168073eec" translate="yes" xml:space="preserve">
          <source>Let's fix our macro:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7fff4c2e7484327d49d843539125f18766ef59b" translate="yes" xml:space="preserve">
          <source>Let's give it a try. First start a new shell:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="385a594a813b358193b288faec070338a76a46ba" translate="yes" xml:space="preserve">
          <source>Let's look at a quick case study: we want to check that a function argument is an even or odd integer. With pattern matching, this is impossible to do since there are infinite integers, and thus we can't pattern match on the single even/odd numbers. Let's focus on checking for even numbers since checking for odd ones is almost identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f17d3ddea9ff5b443102e2f1aa7d529504a09b53" translate="yes" xml:space="preserve">
          <source>Let's see a simple example. Imagine that you implement a library that breaks a string in two parts based on the first occurrence of the dash &lt;code&gt;-&lt;/code&gt; character:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a086f0aa8dc3f13f368da5ddef024d84bd14e45f" translate="yes" xml:space="preserve">
          <source>Let's see an example of a guard used in a function clause:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb3e603df7a85750e6414b0eb382239bbf870bfb" translate="yes" xml:space="preserve">
          <source>Let's see an example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb9a3671c7cc45e630956b53927eeec08220af2" translate="yes" xml:space="preserve">
          <source>Let's see how we could use those functions for debugging the stack server we defined earlier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9944bcda5d8aef46440ac764e0d71869f8b3eb89" translate="yes" xml:space="preserve">
          <source>Let's see some examples. The code below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9747f9ce9d128c721ed4b062d8c863cdde1877" translate="yes" xml:space="preserve">
          <source>Let's start with a code example and then explore the available callbacks. Imagine we want a GenServer that works like a stack, allowing us to push and pop elements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45a0d37d2635e9d8af766d2643fce24860a449d3" translate="yes" xml:space="preserve">
          <source>Let's start with an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c498b7be97563d9e009446e491717478748954ec" translate="yes" xml:space="preserve">
          <source>Let's suppose you created your own &lt;a href=&quot;kernel#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; implementation in the module &lt;code&gt;MyMacros&lt;/code&gt;. If you want to invoke it, you need to first explicitly require the &lt;code&gt;MyMacros&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="167e9ac5d10b20cb0dda56b181fe66788b49d6e5" translate="yes" xml:space="preserve">
          <source>Let's suppose you want to investigate what is happening with some particular function. By invoking &lt;a href=&quot;iex#pry/0&quot;&gt;&lt;code&gt;IEx.pry/0&lt;/code&gt;&lt;/a&gt; from the function, IEx will allow you to access its binding (variables), verify its lexical information and access the process information. Let's see an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="810f288f1e4fdf45c23a3b902942dd7960a5c22f" translate="yes" xml:space="preserve">
          <source>Let's understand what the &lt;code&gt;:shutdown&lt;/code&gt; and &lt;code&gt;:restart&lt;/code&gt; options control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed47f098118b3a4908065115144a054c9afe75d6" translate="yes" xml:space="preserve">
          <source>Levels</source>
          <target state="translated">Levels</target>
        </trans-unit>
        <trans-unit id="5ff76884a1b9f933647dc46c0efb08cd23ce4c72" translate="yes" xml:space="preserve">
          <source>Lexical scope</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8100f5ba8bd048a7cf11d116fbbd73130c3c6f5" translate="yes" xml:space="preserve">
          <source>Library</source>
          <target state="translated">Library</target>
        </trans-unit>
        <trans-unit id="b7e01bf49268dbb685a7684daf71674fc58c2f88" translate="yes" xml:space="preserve">
          <source>Library Guidelines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec793eb7fd1d6c9106d97e622f4fcbf89e666960" translate="yes" xml:space="preserve">
          <source>Licensed under the Apache License, Version 2.0.</source>
          <target state="translated">Apache 라이센스, 버전 2.0에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="8c32d4b808a84de40c883809049bbfd2ca84a901" translate="yes" xml:space="preserve">
          <source>Like with &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list. This is expected on operations such as &lt;a href=&quot;stream#map/2&quot;&gt;&lt;code&gt;Stream.map/2&lt;/code&gt;&lt;/a&gt;. After all, if we want to traverse every element on a stream, the longer the stream, the more elements we need to traverse, and the longer it will take.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e959a6b5621b2dae8ab30d3d3f44c9b21fd9caf5" translate="yes" xml:space="preserve">
          <source>Limit for when a certain time zone period begins or ends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="447809eeca7d1b001940f2b5c2552166d7274fa3" translate="yes" xml:space="preserve">
          <source>Line &lt;code&gt;0&lt;/code&gt; and column &lt;code&gt;0&lt;/code&gt; would mean the top left corner.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f54e0f2d31735fc8356d4c643062d7468cc599" translate="yes" xml:space="preserve">
          <source>Linking</source>
          <target state="translated">Linking</target>
        </trans-unit>
        <trans-unit id="fce9e7983aa4d178575a43583fbc0a75230dea86" translate="yes" xml:space="preserve">
          <source>Linking can also be done manually by calling &lt;code&gt;Process.link/1&lt;/code&gt;. We recommend that you take a look at &lt;a href=&quot;https://hexdocs.pm/elixir/Process.html&quot;&gt;the &lt;code&gt;Process&lt;/code&gt; module&lt;/a&gt; for other functionality provided by processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="5bf3859293f6be21536ffe679146ee6401148648" translate="yes" xml:space="preserve">
          <source>Links are bi-directional. If you link two processes and one of them crashes, the other side will crash too (unless it is trapping exits). A monitor is uni-directional: only the monitoring process will receive notifications about the monitored one. In other words: use links when you want linked crashes, and monitors when you just want to be informed of crashes, exits, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e008dc1478680d69d7d944ea5e97681e447863" translate="yes" xml:space="preserve">
          <source>Links are bidirectional, which implies that a crash in a bucket will crash the registry. Although we now have the supervisor, which guarantees the registry will be back up and running, crashing the registry still means we lose all data associating bucket names to their respective processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="010816f5d4211c808577da6a4d3fff9e452bea0e" translate="yes" xml:space="preserve">
          <source>Links are bidirectional. Linked processes can be unlinked by using &lt;a href=&quot;#unlink/1&quot;&gt;&lt;code&gt;unlink/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="5ea588245c39a0237a816a5a4b5f30b996ac4e47" translate="yes" xml:space="preserve">
          <source>List of allowed expressions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6fd9a7c630dc04fe44f8eceb64283a7b0d97ed2" translate="yes" xml:space="preserve">
          <source>List of supported keys in the keyword list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b38e76a685c2b2df84a12add2cb4a8302d42bac" translate="yes" xml:space="preserve">
          <source>List operators never modify the existing list. Concatenating to or removing elements from a list returns a new list. We say that Elixir data structures are &lt;em&gt;immutable&lt;/em&gt;. One advantage of immutability is that it leads to clearer code. You can freely pass the data around with the guarantee no one will mutate it in memory - only transform it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2eb00e5233b62475b0dc3d5e4e0b3fba8fb4994" translate="yes" xml:space="preserve">
          <source>List.Chars</source>
          <target state="translated">List.Chars</target>
        </trans-unit>
        <trans-unit id="9f9dce20c46fcd1c1728dc56a20927edd518996b" translate="yes" xml:space="preserve">
          <source>List.Chars &lt;small&gt;protocol&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03be4130ee5ad90ce04ed9ec5d74c5566fe35d8" translate="yes" xml:space="preserve">
          <source>List.Chars.t (0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360565f0168323951cb15fd7ca1982778f9a1e7d" translate="yes" xml:space="preserve">
          <source>List.Chars.to_charlist (1)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37415d7b26ed53d3baccb63f14d10f67a7f2022" translate="yes" xml:space="preserve">
          <source>Listens to a port until the port is available and it gets hold of the socket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30045b3ebb820da7e212b26c8d486fa6438d1b21" translate="yes" xml:space="preserve">
          <source>Lists all dependencies and their status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="576be6f9e3cd2119a02b300937f31a0bfa25055f" translate="yes" xml:space="preserve">
          <source>Lists all required files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5fcc5c6ccb03f1f5363ab1add506f548d93b038" translate="yes" xml:space="preserve">
          <source>Lists all tasks and aliases or prints the documentation for a given task or alias.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afec6cb6a10a87d6a4707e28871420191c221295" translate="yes" xml:space="preserve">
          <source>Lists are compared element by element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab57d49cbf8304700835035bc3343277d30e43d1" translate="yes" xml:space="preserve">
          <source>Lists are stored in memory as linked lists, meaning that each element in a list holds its value and points to the following element until the end of the list is reached. This means accessing the length of a list is a linear operation: we need to traverse the whole list in order to figure out its size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c01ea530434a00d0b1bc3bdc3aad101f3c850abd" translate="yes" xml:space="preserve">
          <source>Lists command line arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="347e071fbc04592a3c2f0d22435ec182a39831ba" translate="yes" xml:space="preserve">
          <source>Lists in Elixir are effectively linked lists, which means they are internally represented in pairs containing the head and the tail of a list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1298ac093986653b2f114a6ee0f3b99d3384eec7" translate="yes" xml:space="preserve">
          <source>Lists in Elixir are specified between square brackets:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca74458ce5102822957d2008558c1693dad3f4a" translate="yes" xml:space="preserve">
          <source>Lists or tuples?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6c37e3f50d97e7e2b3eda7fd75f9f8b70fa1609" translate="yes" xml:space="preserve">
          <source>Lists, tuples and binaries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8107e4dcdc428ba751fa94c9e388d0ea60cfc3c" translate="yes" xml:space="preserve">
          <source>Lists, tuples, bitstrings, maps, structs and function calls will be broken into multiple lines if they are followed by a newline in the opening bracket and preceded by a new line in the closing bracket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ba7dcf662374aafe652b03d75cb8f6024519d9" translate="yes" xml:space="preserve">
          <source>Literals</source>
          <target state="translated">Literals</target>
        </trans-unit>
        <trans-unit id="91cb6ed4366e6af4c20b2f0bc91cc0d0ee8e284b" translate="yes" xml:space="preserve">
          <source>Loading an application &lt;em&gt;does not&lt;/em&gt; load its modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0935c21f18347f738724d92e6a79d6627db8bae" translate="yes" xml:space="preserve">
          <source>Loading applications</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c59cbcfe056227b16292e8dcaf0f66d26224a608" translate="yes" xml:space="preserve">
          <source>Loading the application does not start it nor load its modules, but it does load its environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44008e484aac635c82b9da39454ca6c5bef5b635" translate="yes" xml:space="preserve">
          <source>Loads all tasks in all code paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dbb1340da45613eb5e47a83d481795deec9b49b" translate="yes" xml:space="preserve">
          <source>Loads all tasks in the given &lt;code&gt;paths&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a92b205586e28caa29fbe576471eda29c1f626c" translate="yes" xml:space="preserve">
          <source>Loads and persists the given configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d1c8786ab6d688901e2d0162afd3bc568f68c4" translate="yes" xml:space="preserve">
          <source>Loads configuration (typically during system boot).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d450693304ac525200ed85aa5542f49d5d24954d" translate="yes" xml:space="preserve">
          <source>Loads the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fd578a7e27c9f4784b221dfd1d03ff6846abec8" translate="yes" xml:space="preserve">
          <source>Loads the given module's BEAM code (and ensures any previous old version was properly purged before).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7dac36771b4d5bc036c611c2f7df6898fe52037" translate="yes" xml:space="preserve">
          <source>Local or imported functions, like &lt;code&gt;is_function/1&lt;/code&gt;, can be captured without the module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432e91b2470debe1e676502753dc671697ff7218" translate="yes" xml:space="preserve">
          <source>Locates an executable on the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a78f610457f7b34429c88bd804c091eff64c5b" translate="yes" xml:space="preserve">
          <source>Log Capture</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8432c24573f3f89fad60802fe8eddf1da6315768" translate="yes" xml:space="preserve">
          <source>Logger</source>
          <target state="translated">Logger</target>
        </trans-unit>
        <trans-unit id="e437244b86e77b12e48c1b63d73645f8df74961f" translate="yes" xml:space="preserve">
          <source>Logger allows developers to rewrite log messages provided by OTP applications into a format more compatible with Elixir log messages by providing a translator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36bf6b0f69a87a997107e50234a8ec7d11ea5aa8" translate="yes" xml:space="preserve">
          <source>Logger also allows log commands to be removed altogether via the &lt;code&gt;:compile_time_purge_matching&lt;/code&gt; option (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a326883d3565753f9205b6be5a10ab0cd08e9df" translate="yes" xml:space="preserve">
          <source>Logger.Formatter</source>
          <target state="translated">Logger.Formatter</target>
        </trans-unit>
        <trans-unit id="c6794a4db89c0fa5b4754efb325fa721edd588e7" translate="yes" xml:space="preserve">
          <source>Logger.Translator</source>
          <target state="translated">Logger.Translator</target>
        </trans-unit>
        <trans-unit id="4791cfde57458131db6ad4f6f84effd24dfd10fe" translate="yes" xml:space="preserve">
          <source>Logging is useful for tracking when an event of interest happens in your system. For example, it may be helpful to log whenever a user is deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d82e7897f57da03eff4b9dc774004c8bcf4326e9" translate="yes" xml:space="preserve">
          <source>Logs a debug message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4f850d54fddb163d71bfcfbc339485cc6394592" translate="yes" xml:space="preserve">
          <source>Logs a message dynamically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06c091f6fe5aa4035d2433eb7a7a7cc257fb6374" translate="yes" xml:space="preserve">
          <source>Logs a message with the given &lt;code&gt;level&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f285f97af4e85c90120c456b1bce9cedc8d1aeef" translate="yes" xml:space="preserve">
          <source>Logs a warning message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a25a9314514d900aacc22fbb93de516450433e79" translate="yes" xml:space="preserve">
          <source>Logs an error message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162237ff6bb976909c470a90784d4d60906673ae" translate="yes" xml:space="preserve">
          <source>Logs an info message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72bca69a37a582766cb9db5733429c69102e1391" translate="yes" xml:space="preserve">
          <source>Looking up, dispatching and registering are efficient and immediate at the cost of delayed unsubscription. For example, if a process crashes, its keys are automatically removed from the registry but the change may not propagate immediately. This means certain operations may return processes that are already dead. When such may happen, it will be explicitly stated in the function documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a76b17c2d110d14324113df51e0e794c11ea854e" translate="yes" xml:space="preserve">
          <source>Loops through recursion</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce14143dfcbe7563bba16cee9e6c1288ad57742d" translate="yes" xml:space="preserve">
          <source>Low-level function that parses one option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c8129c4541d2520131c98fdc81bf241066a22c" translate="yes" xml:space="preserve">
          <source>Luckily for us, &lt;code&gt;use GenServer&lt;/code&gt; already defines a &lt;code&gt;Stack.child_spec/1&lt;/code&gt; exactly like above. If you need to customize the &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, you can pass the options directly to &lt;code&gt;use GenServer&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86ad4dfa78b62650b87ab367b0252fd1102bb2f8" translate="yes" xml:space="preserve">
          <source>Luckily, Elixir comes with the ability to package all of the code we have written so far into a single directory, that also includes Elixir and the Erlang Virtual Machine, that has a simple entry point and supports custom configuration. This feature is called releases and it provides many other benefits, which we will see next.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101e18c9daa819a9267241f7255d5c640b1be10f" translate="yes" xml:space="preserve">
          <source>Luckily, ExUnit ships with a facility to tag tests, allowing us to run specific callbacks or even filter tests altogether based on those tags. We have already used the &lt;code&gt;:capture_log&lt;/code&gt; tag in the previous chapter, which has its semantics specified by ExUnit itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6e05c123ace841510b2c0f0d5c37124c1c1ac0a" translate="yes" xml:space="preserve">
          <source>Luckily, comprehensions also support the &lt;code&gt;:reduce&lt;/code&gt; option, which would allow us to fuse both steps above into a single step:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0e82f7ee7ffbbb6bfa830a8dab2a14c17f4f0b" translate="yes" xml:space="preserve">
          <source>Luckily, since the server is being supervised by a supervisor, the supervisor will automatically start a new one, with the initial stack of &lt;code&gt;[:hello]&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660bf78961f4ec6bd8bd8b37a3b0b2769db2b14a" translate="yes" xml:space="preserve">
          <source>Macro</source>
          <target state="translated">Macro</target>
        </trans-unit>
        <trans-unit id="da945cd7b80c7fc643a9901f3920877667af55e2" translate="yes" xml:space="preserve">
          <source>Macro hygiene</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc6dcd111ca7252229f4855c8539442f853483e" translate="yes" xml:space="preserve">
          <source>Macro-based shortcut for &lt;a href=&quot;iex#break!/4&quot;&gt;&lt;code&gt;IEx.break!/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c6a3e6a300260cc21833777ce7d3713e7a1c93" translate="yes" xml:space="preserve">
          <source>Macro.Env</source>
          <target state="translated">Macro.Env</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="2deb7bcc40200f28604560fb6b4cce5afe26789d" translate="yes" xml:space="preserve">
          <source>Macros (local or remote)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17db1c00f2577b6b0146445c282a04ec08ca8847" translate="yes" xml:space="preserve">
          <source>Macros are a powerful construct and Elixir provides many mechanisms to ensure they are used responsibly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00166ad41fa2f0b9c76fb59ee48021936b95d500" translate="yes" xml:space="preserve">
          <source>Macros are explicit: it is impossible to run a macro without explicitly invoking it. For example, some languages allow developers to completely rewrite functions behind the scenes, often via parse transforms or via some reflection mechanisms. In Elixir, a macro must be explicitly invoked in the caller during compilation time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e631dd92a600a70cff32b8106215cf69b67f9804" translate="yes" xml:space="preserve">
          <source>Macros are hygienic: by default, variables defined inside a macro are not going to affect the user code. Furthermore, function calls and aliases available in the macro context are not going to leak into the user context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5ff8a95ca37f321e50193978d8305c5ccd794f" translate="yes" xml:space="preserve">
          <source>Macros are lexical: it is impossible to inject code or macros globally. In order to use a macro, you need to explicitly &lt;code&gt;require&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt; the module that defines the macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78cdc77e6f4d92297e11673135be19d518a8e9cb" translate="yes" xml:space="preserve">
          <source>Macros cannot be overridden as functions and vice-versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e2c2440131ab61167e8cad993833b1e1b2ca92" translate="yes" xml:space="preserve">
          <source>Macros constructed out of any combination of the above guards are also valid guards - for example, &lt;a href=&quot;integer#is_even/1&quot;&gt;&lt;code&gt;Integer.is_even/1&lt;/code&gt;&lt;/a&gt;. For more information, see the &quot;Defining custom guard expressions&quot; section shown below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b376d89a5de38d7ee4620680cefcbdb63a1fa6c3" translate="yes" xml:space="preserve">
          <source>Macros in Elixir are defined via &lt;code&gt;defmacro/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b493bc2b5a09e10063b11f52cb46148a75373e5" translate="yes" xml:space="preserve">
          <source>Macros must be defined before its usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3a7dd931c836a0537e89bdd7c632c8f1674beb8" translate="yes" xml:space="preserve">
          <source>Macros receive quoted expressions and must return quoted expressions. However, sometimes during the execution of a macro, you may need to work with values and making a distinction between values and quoted expressions will be required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b8816a712333def9173d859165b24e9a1e3080d" translate="yes" xml:space="preserve">
          <source>Macros&amp;rsquo; language is clear: many languages provide syntax shortcuts for &lt;code&gt;quote&lt;/code&gt; and &lt;code&gt;unquote&lt;/code&gt;. In Elixir, we preferred to have them explicitly spelled out, in order to clearly delimit the boundaries of a macro definition and its quoted expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c7f5915403fb594e00a22038d846f701385048" translate="yes" xml:space="preserve">
          <source>Makes a synchronous call to the &lt;code&gt;server&lt;/code&gt; and waits for its reply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ca136246f74496fc6eddff8b632654647bdfab" translate="yes" xml:space="preserve">
          <source>Makes the given functions in &lt;code&gt;module&lt;/code&gt; overridable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d1d2f57486d38837141355b4d2874a9bddc93c3" translate="yes" xml:space="preserve">
          <source>Makes the given functions in the current module overridable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fddc4eb9e8f75d21673b2839ad36111f23d7c3e" translate="yes" xml:space="preserve">
          <source>Manually implementing protocols for all types can quickly become repetitive and tedious. In such cases, Elixir provides two options: we can explicitly derive the protocol implementation for our types or automatically implement the protocol for all types. In both cases, we need to implement the protocol for &lt;code&gt;Any&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d459cd939d93634c990e044cf24d22485f3ceefe" translate="yes" xml:space="preserve">
          <source>Manually it can be started as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e455aaea813fc20786176867857a89ebbb1b93" translate="yes" xml:space="preserve">
          <source>Many functions come in pairs, such as &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;file#read!/1&quot;&gt;&lt;code&gt;File.read!/1&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;file#read/1&quot;&gt;&lt;code&gt;File.read/1&lt;/code&gt;&lt;/a&gt; will return a success or failure tuple, whereas &lt;a href=&quot;file#read!/1&quot;&gt;&lt;code&gt;File.read!/1&lt;/code&gt;&lt;/a&gt; will return a plain value or else raise an exception:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df33d2958d307f1a594471fa7f01b0b82a2cb968" translate="yes" xml:space="preserve">
          <source>Many functions for maps, which implement the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, are found in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module. Additionally, the following functions for maps are found in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ff6822734db6cb62b200fe4ffc5f764d2dde53" translate="yes" xml:space="preserve">
          <source>Many functions in the &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; module require a time zone database. By default, it uses the default time zone database returned by &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt;&lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt;&lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt;&lt;/a&gt; which only handles &quot;Etc/UTC&quot; datetimes and returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; for any other time zone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4225573b276c588447af042b7625b6428887292b" translate="yes" xml:space="preserve">
          <source>Many functions in the &lt;code&gt;Stream&lt;/code&gt; module accept any enumerable as an argument and return a stream as a result. It also provides functions for creating streams. For example, &lt;code&gt;Stream.cycle/1&lt;/code&gt; can be used to create a stream that cycles a given enumerable infinitely. Be careful to not call a function like &lt;code&gt;Enum.map/2&lt;/code&gt; on such streams, as they would cycle forever:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76056aa626b027c1c23fdbd95796d51843ce0c06" translate="yes" xml:space="preserve">
          <source>Many functions in the standard library follow the pattern of having a counterpart that raises an exception instead of returning tuples to match against. The convention is to create a function (&lt;code&gt;foo&lt;/code&gt;) which returns &lt;code&gt;{:ok, result}&lt;/code&gt; or &lt;code&gt;{:error, reason}&lt;/code&gt; tuples and another function (&lt;code&gt;foo!&lt;/code&gt;, same name but with a trailing &lt;code&gt;!&lt;/code&gt;) that takes the same arguments as &lt;code&gt;foo&lt;/code&gt; but which raises an exception if there&amp;rsquo;s an error. &lt;code&gt;foo!&lt;/code&gt; should return the result (not wrapped in a tuple) if everything goes fine. The &lt;a href=&quot;https://hexdocs.pm/elixir/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt; module&lt;/a&gt; is a good example of this convention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3703d2917265895ef0ac89964db0000551fe6a21" translate="yes" xml:space="preserve">
          <source>Many functions in this module expect an IO device as an argument. An IO device must be a PID or an atom representing a process. For convenience, Elixir provides &lt;code&gt;:stdio&lt;/code&gt; and &lt;code&gt;:stderr&lt;/code&gt; as shortcuts to Erlang's &lt;code&gt;:standard_io&lt;/code&gt; and &lt;code&gt;:standard_error&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f2d10ee74f910ee80e0d898322396bd24b9b002" translate="yes" xml:space="preserve">
          <source>Many functions in this module handle what to capture in a regex match via the &lt;code&gt;:capture&lt;/code&gt; option. The supported values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d206ef06c5b999d69bec023c3ecff2ae2d89ff16" translate="yes" xml:space="preserve">
          <source>Many functions in this module require a time zone database. By default, it uses the default time zone database returned by &lt;a href=&quot;calendar#get_time_zone_database/0&quot;&gt;&lt;code&gt;Calendar.get_time_zone_database/0&lt;/code&gt;&lt;/a&gt;, which defaults to &lt;a href=&quot;calendar.utconlytimezonedatabase&quot;&gt;&lt;code&gt;Calendar.UTCOnlyTimeZoneDatabase&lt;/code&gt;&lt;/a&gt; which only handles &quot;Etc/UTC&quot; datetimes and returns &lt;code&gt;{:error, :utc_only_time_zone_database}&lt;/code&gt; for any other time zone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94392a82be4b05528cead70b8bc5d289f9e18ce9" translate="yes" xml:space="preserve">
          <source>Many functions in this module work with patterns. For example, &lt;a href=&quot;string#split/2&quot;&gt;&lt;code&gt;String.split/2&lt;/code&gt;&lt;/a&gt; can split a string into multiple strings given a pattern. This pattern can be a string, a list of strings or a compiled pattern:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90b7eedb69a34d71ed449486b5fd918febba2efc" translate="yes" xml:space="preserve">
          <source>Many modules share the same public API. Take a look at &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;Plug&lt;/a&gt;, which, as its description states, is a &lt;strong&gt;specification&lt;/strong&gt; for composable modules in web applications. Each &lt;em&gt;plug&lt;/em&gt; is a module which &lt;strong&gt;has to&lt;/strong&gt; implement at least two public functions: &lt;code&gt;init/1&lt;/code&gt; and &lt;code&gt;call/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bad4be1f2158b40250d3557f87cd91435ba7e8c" translate="yes" xml:space="preserve">
          <source>Many of the functions defined in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; module internally call this function. This function is also used when the square-brackets access syntax (&lt;code&gt;structure[key]&lt;/code&gt;) is used: the &lt;a href=&quot;#fetch/2&quot;&gt;&lt;code&gt;fetch/2&lt;/code&gt;&lt;/a&gt; callback implemented by the module that defines the &lt;code&gt;structure&lt;/code&gt; struct is invoked and if it returns &lt;code&gt;{:ok, value}&lt;/code&gt; then &lt;code&gt;value&lt;/code&gt; is returned, or if it returns &lt;code&gt;:error&lt;/code&gt; then &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4ca56f0d69fbdc55846e32a022e68f99af15e8" translate="yes" xml:space="preserve">
          <source>Many of the functions in the &lt;code&gt;Macro&lt;/code&gt; module expect an environment. You can read more about these functions in &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.html&quot;&gt;the docs for the &lt;code&gt;Macro&lt;/code&gt; module&lt;/a&gt; and learn more about the compilation environment in the &lt;a href=&quot;https://hexdocs.pm/elixir/Macro.Env.html&quot;&gt;docs for &lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4faffc8eead5983ad100523dbff786e387103bd2" translate="yes" xml:space="preserve">
          <source>Many of the functions provided for lists, which implement the &lt;a href=&quot;enumerable&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;&lt;/a&gt; protocol, are found in the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be6b19c2b27acff99f70a4437bfc926f0a1ca658" translate="yes" xml:space="preserve">
          <source>Many options can be given by using &lt;code&gt;-&lt;/code&gt; as separator. Order is arbitrary, so the following are all equivalent:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b2e23669853bc8630b7ea68a605ae31ce73aeb" translate="yes" xml:space="preserve">
          <source>Many times, inspecting a structure can be implemented in function of existing entities. For example, here is &lt;a href=&quot;mapset&quot;&gt;&lt;code&gt;MapSet&lt;/code&gt;&lt;/a&gt;'s &lt;a href=&quot;#inspect/2&quot;&gt;&lt;code&gt;inspect/2&lt;/code&gt;&lt;/a&gt; implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="c31339a8063fd1ca05b6a5ed0e592c82381795d2" translate="yes" xml:space="preserve">
          <source>Map/dictionary as 2nd argument in &lt;a href=&quot;enum#group_by/3&quot;&gt;&lt;code&gt;Enum.group_by/3&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f349d9040ff8d6dc02443f2129355396470884e" translate="yes" xml:space="preserve">
          <source>MapSet</source>
          <target state="translated">MapSet</target>
        </trans-unit>
        <trans-unit id="80071cd75107cd5c4afdb2571725ea6733631038" translate="yes" xml:space="preserve">
          <source>Maps</source>
          <target state="translated">Maps</target>
        </trans-unit>
        <trans-unit id="faaabe818891c225544bd509dabd125356710ead" translate="yes" xml:space="preserve">
          <source>Maps allow any value as a key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7aa9999474ccd32fc79bec268d52ee73d62bb49" translate="yes" xml:space="preserve">
          <source>Maps also support a specific update syntax to update the value stored under &lt;em&gt;existing&lt;/em&gt; atom keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b5fbc085bbfa528c48b36100e97092a1cc1ad4" translate="yes" xml:space="preserve">
          <source>Maps and joins the given &lt;code&gt;enumerable&lt;/code&gt; in one pass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5099fc13865ed694619ef238561f1ff1eb21e4ca" translate="yes" xml:space="preserve">
          <source>Maps and keyword lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="382a893f2fca3eb55b96aa13fc13acceacd045d1" translate="yes" xml:space="preserve">
          <source>Maps and reduces an &lt;code&gt;enumerable&lt;/code&gt;, flattening the given results (only one level deep).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6cdae6c2a90bda1af5114211ccb41e8558a58da" translate="yes" xml:space="preserve">
          <source>Maps are compared by size, then by keys in ascending term order, then by values in key order. In the specific case of maps' key ordering, integers are always considered to be less than floats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c58aeb4eaddeb4b19dfc3e5c22984c273b6c491" translate="yes" xml:space="preserve">
          <source>Maps are the &quot;go to&quot; key-value data structure in Elixir. Maps can be created with the &lt;code&gt;%{}&lt;/code&gt; syntax, and key-value pairs can be expressed as &lt;code&gt;key =&amp;gt; value&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f244270ac78647558651f3076ad4902cf12b49" translate="yes" xml:space="preserve">
          <source>Maps can be pattern matched on. When a map is on the left-hand side of a pattern match, it will match if the map on the right-hand side contains the keys on the left-hand side and their values match the ones on the left-hand side. This means that an empty map matches every map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bdce2ba7f6c277727a64d1e4440d7e5012f407e" translate="yes" xml:space="preserve">
          <source>Maps do not impose any restriction on the key type: anything can be a key in a map. As a key-value structure, maps do not allow duplicated keys. Keys are compared using the exact-equality operator (&lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;). If colliding keys are defined in a map literal, the last one prevails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd2672e5330a5447b3c12c9d7516bbd11a97aa64" translate="yes" xml:space="preserve">
          <source>Maps have the following syntax for updating a key&amp;rsquo;s value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b18104f0603d252465f48bc07dbe82afd8a5d572" translate="yes" xml:space="preserve">
          <source>Maps the given &lt;code&gt;fun&lt;/code&gt; over &lt;code&gt;enumerable&lt;/code&gt; and flattens the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5204e90c54387d7f6b5371b939a57cc337fb682b" translate="yes" xml:space="preserve">
          <source>Maps use the &lt;code&gt;%{...}&lt;/code&gt; notation and each key-value is given by pairs marked with &lt;code&gt;=&amp;gt;&lt;/code&gt;, such as &lt;code&gt;%{&quot;hello&quot; =&amp;gt; 1, 2 =&amp;gt; &quot;world&quot;}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b30399c385e93b1607671f629e3c17811777473" translate="yes" xml:space="preserve">
          <source>Maps&amp;rsquo; keys do not follow any ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23e67fceae0d77dd571dd25695fc0499faf1bb77" translate="yes" xml:space="preserve">
          <source>Markdown</source>
          <target state="translated">Markdown</target>
        </trans-unit>
        <trans-unit id="ec2d3f7496eeae736a17fb6cfbbc3d6cec0ede8f" translate="yes" xml:space="preserve">
          <source>Markdown uses backticks (&lt;code&gt;`&lt;/code&gt;) to quote code. Elixir builds on top of that to automatically generate links when module or function names are referenced. For this reason, always use full module names. If you have a module called &lt;code&gt;MyApp.Hello&lt;/code&gt;, always reference it as &lt;code&gt;`MyApp.Hello`&lt;/code&gt; and never as &lt;code&gt;`Hello`&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="217f8bccae9fba9687ba7ff03998f906b2857c1d" translate="yes" xml:space="preserve">
          <source>Markers &lt;code&gt;&quot;/&quot;&lt;/code&gt; and &lt;code&gt;&quot;|&quot;&lt;/code&gt; are only for use in custom EEx engines and are not implemented by default. Using them without an appropriate implementation raises &lt;a href=&quot;eex.syntaxerror&quot;&gt;&lt;code&gt;EEx.SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caae004dd7762602ee13f32c3606f690c674cc52" translate="yes" xml:space="preserve">
          <source>Marks if the system should halt or not at the end of ARGV processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8df966767fbd3a383c53216799beb4b4564cb74" translate="yes" xml:space="preserve">
          <source>Mastering Markdown</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="158acb8638a5ae524e2b6bf247590e2b87f6ec4d" translate="yes" xml:space="preserve">
          <source>MatchError</source>
          <target state="translated">MatchError</target>
        </trans-unit>
        <trans-unit id="96751a5eacdf747401e9907e7e83faf6f1a03e3b" translate="yes" xml:space="preserve">
          <source>MatchError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee2dbd5d6d82d0833069b07e7dd2848d3bf4d83a" translate="yes" xml:space="preserve">
          <source>Matches</source>
          <target state="translated">Matches</target>
        </trans-unit>
        <trans-unit id="2d84b42f8474be5f06fc1fe6eb6ae40c8a64822a" translate="yes" xml:space="preserve">
          <source>Matches on or builds a struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1c12ec871d541a72434054efa8076c09aed8fb5" translate="yes" xml:space="preserve">
          <source>Matches the given expression against the given clauses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b76a5c96001ffefea3cc84097a4d45e79f04e10" translate="yes" xml:space="preserve">
          <source>Matches the term on the &lt;code&gt;left&lt;/code&gt; against the regular expression or string on the &lt;code&gt;right&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="213cb6a13e45b535bfa6e1acc183ec880d53557f" translate="yes" xml:space="preserve">
          <source>Matches the value on the right against the pattern on the left.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b35bb5e881268b8de9b651fa2e51e3623ab167b7" translate="yes" xml:space="preserve">
          <source>Mechanism for handling behaviours.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f436c24ccfa651b93064f0d2e54084d164dc06e" translate="yes" xml:space="preserve">
          <source>Membership is tested with the match (&lt;a href=&quot;kernel#===/2&quot;&gt;&lt;code&gt;===/2&lt;/code&gt;&lt;/a&gt;) operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d89ba7d209c7ddc88fd31bf2598cbf585fb0aa81" translate="yes" xml:space="preserve">
          <source>Merges two URIs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4069e43ecbf8943679ac63e2d6e02de8e6a7137b" translate="yes" xml:space="preserve">
          <source>Merges two configurations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9fa5b094d178e27f7bd2a2b568ea8b694678d55" translate="yes" xml:space="preserve">
          <source>Merges two keyword lists into one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf0cf4f2e4c966874470b9f049a43c211b544d9" translate="yes" xml:space="preserve">
          <source>Merges two maps into one, resolving conflicts through the given &lt;code&gt;fun&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="472d94b64a8f716f1678ee270e1d1c87f01b9840" translate="yes" xml:space="preserve">
          <source>Merges two maps into one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="243261baef2add3b3b97656268303e291d4fa8b4" translate="yes" xml:space="preserve">
          <source>Message and function APIs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a587d636afdda61a08b5027d8d771633fc5216" translate="yes" xml:space="preserve">
          <source>Message format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d9a0f1c2be58d1d8ee9acd43a53bc9fde228a1e" translate="yes" xml:space="preserve">
          <source>Meta-programming</source>
          <target state="translated">Meta-programming</target>
        </trans-unit>
        <trans-unit id="9ce697e52d7e466c89411bf1535cdf6ff43e22f1" translate="yes" xml:space="preserve">
          <source>Meta-programming guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa22e0676cd79851be85b6434a7e6e08111fa009" translate="yes" xml:space="preserve">
          <source>Meta-programming in Elixir</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="251edc0eb5a820646bda4e103f0f007fd55321f3" translate="yes" xml:space="preserve">
          <source>Metadata</source>
          <target state="translated">Metadata</target>
        </trans-unit>
        <trans-unit id="7f0cf2cb1796c66f262f9ca3a16a007623f8614c" translate="yes" xml:space="preserve">
          <source>Metadata can have any key. Documentation tools often use metadata to provide more data to readers and to enrich the user experience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae75c0cef5625d04c957fd4d6945de2e3cb52281" translate="yes" xml:space="preserve">
          <source>Metadata to be sent to the logger can be read and written with the &lt;a href=&quot;logger#metadata/0&quot;&gt;&lt;code&gt;Logger.metadata/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;logger#metadata/1&quot;&gt;&lt;code&gt;Logger.metadata/1&lt;/code&gt;&lt;/a&gt; functions. For example, you can set &lt;code&gt;Logger.metadata([user_id: 13])&lt;/code&gt; to add user_id metadata to the current process. The user can configure the backend to choose which metadata it wants to print and it will replace the &lt;code&gt;$metadata&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="996eccb481568235d0a028deddc16efa49e5113a" translate="yes" xml:space="preserve">
          <source>Microseconds can also be given with a precision, which must be an integer between 0 and 6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfde79a8eeb31b646662fce17bc79e76db2d4ad1" translate="yes" xml:space="preserve">
          <source>Microseconds with stored precision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae8f2632075078189571124ccbd2fa14d6202a8b" translate="yes" xml:space="preserve">
          <source>Migrating from &lt;code&gt;use Mix.Config&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e092faa3e25342ecf5028acae902f24fdcd4cfc" translate="yes" xml:space="preserve">
          <source>Migrating from Supervisor's :simple_one_for_one</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="119fff5ad66da150ab8b91c4f195f7205786f58d" translate="yes" xml:space="preserve">
          <source>Missing parent directories are created. Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e60798bf941d9439890dc6ea1e2b3874b037fa8" translate="yes" xml:space="preserve">
          <source>Missing parent directories are not created. Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd7391b6720b809c7c41ed50cf63fdc87dac6b9d" translate="yes" xml:space="preserve">
          <source>Mix</source>
          <target state="translated">Mix</target>
        </trans-unit>
        <trans-unit id="8a48b8da8f54401b98b40a13634225508f5d8cd7" translate="yes" xml:space="preserve">
          <source>Mix Tasks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adf80b3737e1d992babad11068b089417997b0c6" translate="yes" xml:space="preserve">
          <source>Mix also falls back to the &lt;code&gt;XDG_DATA_HOME&lt;/code&gt; and &lt;code&gt;XDG_CONFIG_HOME&lt;/code&gt; environment variables when storing its contents and configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad17235fd472ad3a611eb5939096f52cba44598" translate="yes" xml:space="preserve">
          <source>Mix also generated a file named &lt;code&gt;test/test_helper.exs&lt;/code&gt; which is responsible for setting up the test framework:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5f417a1b2c5b2cf642913e1126e746153ac794c" translate="yes" xml:space="preserve">
          <source>Mix also generated the appropriate structure for running our project tests. Mix projects usually follow the convention of having a &lt;code&gt;&amp;lt;filename&amp;gt;_test.exs&lt;/code&gt; file in the &lt;code&gt;test&lt;/code&gt; directory for each file in the &lt;code&gt;lib&lt;/code&gt; directory. For this reason, we can already find a &lt;code&gt;test/kv_test.exs&lt;/code&gt; corresponding to our &lt;code&gt;lib/kv.ex&lt;/code&gt; file. It doesn&amp;rsquo;t do much at this point:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e787071e1565ddba8a2e537f8771328f0ffb3a18" translate="yes" xml:space="preserve">
          <source>Mix also generates a file at &lt;code&gt;lib/kv.ex&lt;/code&gt; with a module containing exactly one function, called &lt;code&gt;hello&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71bacf97d94e38a4255175d63dd82250400f8cac" translate="yes" xml:space="preserve">
          <source>Mix also manages your dependencies and integrates nicely with the &lt;a href=&quot;https://hex.pm&quot;&gt;Hex package manager&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02fd3a28a69477778e8b16f7b3cce09332f74ae5" translate="yes" xml:space="preserve">
          <source>Mix also supports Git and path dependencies:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04bb9bcfa3927d3cae40daaaa838d4ef230a39cd" translate="yes" xml:space="preserve">
          <source>Mix and OTP</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25cf695ebdb9d0aee542ce2f227391b7ee2bf55" translate="yes" xml:space="preserve">
          <source>Mix and OTP guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a56ce9bc8efd270013eaafce32886b18ad521f" translate="yes" xml:space="preserve">
          <source>Mix can be used to manage Erlang projects that don't have any Elixir code. To ensure Mix tasks work correctly for an Erlang project, &lt;code&gt;language: :erlang&lt;/code&gt; has to be part of the configuration returned by &lt;code&gt;project/0&lt;/code&gt;. This setting also makes sure Elixir is not added as a dependency to the generated &lt;code&gt;.app&lt;/code&gt; file or to the escript generated with &lt;a href=&quot;mix.tasks.escript.build&quot;&gt;&lt;code&gt;mix escript.build&lt;/code&gt;&lt;/a&gt;, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cdb0b1920ef5553ebcd1f21161694f9fc79e940" translate="yes" xml:space="preserve">
          <source>Mix is a build tool and, as such, it is not expected to be available in production. Therefore, it is recommended to access &lt;code&gt;Mix.env&lt;/code&gt; only in configuration files and inside &lt;code&gt;mix.exs&lt;/code&gt;, never in your application code (&lt;code&gt;lib&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6da9856af4245149570c16ec4188fc5d3115e0f" translate="yes" xml:space="preserve">
          <source>Mix is a build tool that provides tasks for creating, compiling, and testing Elixir projects, managing its dependencies, and more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0df83a511be738d9e0de24c58fdbe9cd553aa72" translate="yes" xml:space="preserve">
          <source>Mix is the project management and build tool for Elixir. Invoking &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt; from the command line will run the tests in each file matching the pattern &lt;code&gt;*_test.exs&lt;/code&gt; found in the &lt;code&gt;test&lt;/code&gt; directory of your project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6efd811f3c57b4beedb58b4c74d9cfc0e7bd84d8" translate="yes" xml:space="preserve">
          <source>Mix makes a distinction between projects and applications. Based on the contents of our &lt;code&gt;mix.exs&lt;/code&gt; file, we would say we have a Mix project that defines the &lt;code&gt;:kv&lt;/code&gt; application. As we will see in later chapters, there are projects that don&amp;rsquo;t define any application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="648fcb70fef0f7b235a3a4efb99b43d14093584b" translate="yes" xml:space="preserve">
          <source>Mix provides many tasks for working with dependencies, which can be seen in &lt;code&gt;mix help&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ad0076d881adfffd287f386c898dd8d3dfe63d9" translate="yes" xml:space="preserve">
          <source>Mix provides the concept of &amp;ldquo;environments&amp;rdquo;. They allow a developer to customize compilation and other options for specific scenarios. By default, Mix understands three environments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0eb4f5b6efc2f498d0a43bf2cce656e8deeb64f" translate="yes" xml:space="preserve">
          <source>Mix responds to the following variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9083e0d8be0e72f0bd60c89828382861a3d53dd0" translate="yes" xml:space="preserve">
          <source>Mix shell that uses the current process mailbox for communication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad263de6a1ec790ca04b9e1c0d40a550701c6fa7" translate="yes" xml:space="preserve">
          <source>Mix ships with many tasks under the &lt;code&gt;profile&lt;/code&gt; namespace, such as &lt;code&gt;cprof&lt;/code&gt; and &lt;code&gt;fprof&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34cf07547ba5e61214e86cb3580e3d48c9fa65b9" translate="yes" xml:space="preserve">
          <source>Mix supports different environments. Environments allow developers to prepare and organize their project specifically for different scenarios. By default, Mix provides three environments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d70ab3fabbbe21fc38f850f28d9a31374f92fc" translate="yes" xml:space="preserve">
          <source>Mix tasks are designed to run only once. This prevents the same task to be executed multiple times. For example, if there are several tasks depending on &lt;a href=&quot;mix.tasks.compile&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt;, the code will be compiled once. Tasks can be executed again if they are explicitly reenabled using &lt;a href=&quot;mix.task#reenable/1&quot;&gt;&lt;code&gt;Mix.Task.reenable/1&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb48dfad219bb575ed5a6a2a2d6171fe59e0c43" translate="yes" xml:space="preserve">
          <source>Mix will create a directory named &lt;code&gt;kv&lt;/code&gt; with a few files in it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa02d3dbeffdcfedef855ce25999f5c0e80ec49" translate="yes" xml:space="preserve">
          <source>Mix will default to the &lt;code&gt;:dev&lt;/code&gt; environment, except for the &lt;code&gt;test&lt;/code&gt; task that will default to the &lt;code&gt;:test&lt;/code&gt; environment. The environment can be changed via the &lt;code&gt;MIX_ENV&lt;/code&gt; environment variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="399305e4f380845bf197d5745b3fee53dc94ea53" translate="yes" xml:space="preserve">
          <source>Mix will load the &lt;code&gt;test_helper.exs&lt;/code&gt; file before executing the tests. It is not necessary to &lt;code&gt;require&lt;/code&gt; the &lt;code&gt;test_helper.exs&lt;/code&gt; file in your test files. See &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;Mix.Tasks.Test&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="677bfdd437f39d48687e8e09deb896bdab1ffcab" translate="yes" xml:space="preserve">
          <source>Mix.InvalidTaskError</source>
          <target state="translated">Mix.InvalidTaskError</target>
        </trans-unit>
        <trans-unit id="73acde233ddd7f978233bc0c9c03ffcb591e4127" translate="yes" xml:space="preserve">
          <source>Mix.InvalidTaskError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5656de2d70dc1fd33545f113c9c31f4468c93c9f" translate="yes" xml:space="preserve">
          <source>Mix.NoProjectError</source>
          <target state="translated">Mix.NoProjectError</target>
        </trans-unit>
        <trans-unit id="a3cd7de13e58b68149c17286a492f048bc5a4f9f" translate="yes" xml:space="preserve">
          <source>Mix.NoProjectError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2296b8a4da20e50fc86db62a76ae3a0f21236d09" translate="yes" xml:space="preserve">
          <source>Mix.NoTaskError</source>
          <target state="translated">Mix.NoTaskError</target>
        </trans-unit>
        <trans-unit id="4758003c8f1681557fd809da1ff272c0a4bdc616" translate="yes" xml:space="preserve">
          <source>Mix.NoTaskError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f736ae59e13a4e4114e4af3bf6ddc51b25a5bb36" translate="yes" xml:space="preserve">
          <source>Mix.Project</source>
          <target state="translated">Mix.Project</target>
        </trans-unit>
        <trans-unit id="467f63e6768ca92e850a24bb5559e6ceb3ff2d65" translate="yes" xml:space="preserve">
          <source>Mix.Shell.IO</source>
          <target state="translated">Mix.Shell.IO</target>
        </trans-unit>
        <trans-unit id="ae6604b3cc7069b10edb34181cf30fa1c7e69549" translate="yes" xml:space="preserve">
          <source>Mix.Shell.Process</source>
          <target state="translated">Mix.Shell.Process</target>
        </trans-unit>
        <trans-unit id="d04ad970550a78d0484fc6fba35ca08880a1b57f" translate="yes" xml:space="preserve">
          <source>Mix.Task</source>
          <target state="translated">Mix.Task</target>
        </trans-unit>
        <trans-unit id="426aac8f0abf87df945411bf3866831ccdd5ee99" translate="yes" xml:space="preserve">
          <source>Mix.Task &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f260e757cec75096bc3eefbfb1c4a14720832017" translate="yes" xml:space="preserve">
          <source>Modifier</source>
          <target state="translated">Modifier</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="63368ee0cfe73d65555cc05d160f4780d59c63dd" translate="yes" xml:space="preserve">
          <source>Modifies command line arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ff02892916ff59f7fbd4e617fccd01f6bca576" translate="yes" xml:space="preserve">
          <source>Module</source>
          <target state="translated">Module</target>
        </trans-unit>
        <trans-unit id="9297e283a310f6ab7d943b5269f1a79016e762cb" translate="yes" xml:space="preserve">
          <source>Module &lt;small&gt;behaviour&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c3f2aba6913de8da00faed8e2df2428bb1257b7" translate="yes" xml:space="preserve">
          <source>Module Attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="974d46d1f85954ab50d762a7e03d4820f241857f" translate="yes" xml:space="preserve">
          <source>Module and describe tags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330765efeb90ac3d911657d7500e925bd8f2537b" translate="yes" xml:space="preserve">
          <source>Module attributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="611dbb58b63e5a3205266276e6a852dcaa7a3969" translate="yes" xml:space="preserve">
          <source>Module attributes in Elixir serve three purposes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e3ec1d59bfdc3e7d0eaa73499821e62209421e" translate="yes" xml:space="preserve">
          <source>Module attributes reader (&lt;code&gt;@foo&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddfcf23684bdb5ef441d59b66364129fcb4f0309" translate="yes" xml:space="preserve">
          <source>Module nesting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40144123a36c18a55943d34cbb9a342139e699ec" translate="yes" xml:space="preserve">
          <source>Module to work with, define, and import records.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc1693df58c9640eee91eb5bd91f74e7ad932311" translate="yes" xml:space="preserve">
          <source>Module-based supervisors</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="2f22992ace2b7b2537bcbf08c8e4ceeca5300f8f" translate="yes" xml:space="preserve">
          <source>Modules adopting the &lt;code&gt;Parser&lt;/code&gt; behaviour will have to implement all the functions defined with the &lt;code&gt;@callback&lt;/code&gt; directive. As you can see, &lt;code&gt;@callback&lt;/code&gt; expects a function name but also a function specification like the ones used with the &lt;code&gt;@spec&lt;/code&gt; directive we saw above. Also note that the &lt;code&gt;term&lt;/code&gt; type is used to represent the parsed value. In Elixir, the &lt;code&gt;term&lt;/code&gt; type is a shortcut to represent any type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbf8ec2a137ea97fd047b1bf5fb0e081373aaeef" translate="yes" xml:space="preserve">
          <source>Modules and functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95593466c9236f423e2ca78c791a9ed452a97e0" translate="yes" xml:space="preserve">
          <source>Modules compiled with HiPE would not call this hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f7948a408bbeb081e3bf4398d0a06535fe04fa6" translate="yes" xml:space="preserve">
          <source>Modules that are not yet loaded won't show up. Check &lt;a href=&quot;#load_all/0&quot;&gt;&lt;code&gt;load_all/0&lt;/code&gt;&lt;/a&gt; if you want to preload all tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda622c46b037f80824387d421dc386c6556e7d2" translate="yes" xml:space="preserve">
          <source>Modules that interface with the underlying system, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49fb186a5c3efc09ccd0d283216aa3aefc8c1db1" translate="yes" xml:space="preserve">
          <source>Monitors or links?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5af02a7afd8f398df475e389f375296b40fcadb" translate="yes" xml:space="preserve">
          <source>Monitors the status of the node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="531f01d1f3ee72b3521ad6573e9645c241df955d" translate="yes" xml:space="preserve">
          <source>More detailed information is returned if you provide the &lt;code&gt;--callers&lt;/code&gt; and &lt;code&gt;--details&lt;/code&gt; options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679fb30706daaf38b9e2ca52a7581c5f7429d440" translate="yes" xml:space="preserve">
          <source>More examples of paired functions: &lt;a href=&quot;base#decode16/2&quot;&gt;&lt;code&gt;Base.decode16/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;base#decode16!/2&quot;&gt;&lt;code&gt;Base.decode16!/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;file#cwd/0&quot;&gt;&lt;code&gt;File.cwd/0&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;file#cwd!/0&quot;&gt;&lt;code&gt;File.cwd!/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b89d915a104252705d1f85ce849ed077d1dac0ac" translate="yes" xml:space="preserve">
          <source>More information about graphemes can be found in the &lt;a href=&quot;https://www.unicode.org/reports/tr29/&quot;&gt;Unicode Standard Annex #29&lt;/a&gt;. The current Elixir version implements Extended Grapheme Cluster algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5e8684b13528d21f979a1818ef3d359d73c9599" translate="yes" xml:space="preserve">
          <source>More information about the tuple data type and about functions to manipulate tuples can be found in the &lt;a href=&quot;tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; module; some functions for working with tuples are also available in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; (such as &lt;a href=&quot;kernel#elem/2&quot;&gt;&lt;code&gt;Kernel.elem/2&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;kernel#tuple_size/1&quot;&gt;&lt;code&gt;Kernel.tuple_size/1&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430a22fd9616cca59513735ab6a5d8e059b24d05" translate="yes" xml:space="preserve">
          <source>More information on date times can be found in the &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10a384a2270f2efaa542fb180ccc3a8a8fab8a8" translate="yes" xml:space="preserve">
          <source>More information on dates can be found in the &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d09563b1d7bf20501a96abf9b569ef7f610dceb" translate="yes" xml:space="preserve">
          <source>More information on naive date times can be found in the &lt;a href=&quot;naivedatetime&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85521cfa0af914c1bfcc721a8420c6e8c54e6ca" translate="yes" xml:space="preserve">
          <source>More information on regexes can be found in the &lt;a href=&quot;regex&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="943682535e16011c70352d95eb0b5a94fc51f1ec" translate="yes" xml:space="preserve">
          <source>More information on regular expressions can be found in the &lt;a href=&quot;regex&quot;&gt;&lt;code&gt;Regex&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e1febe16a203d4cc3b9b43ca22bede1863da17" translate="yes" xml:space="preserve">
          <source>More information on times can be found in the &lt;a href=&quot;time&quot;&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47345d51b5c718e5874fcd01549e8be7ce1a8743" translate="yes" xml:space="preserve">
          <source>More interestingly, we can match on specific values. The example below asserts that the left side will only match the right side when the right side is a tuple that starts with the atom &lt;code&gt;:ok&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="708db7ea87e7a72eeea9cb0dbb3ddbd4f2c25b4b" translate="yes" xml:space="preserve">
          <source>More options are available; for the comprehensive list of available options check &lt;a href=&quot;http://www.erlang.org/doc/man/erlang.html#spawn_opt-4&quot;&gt;&lt;code&gt;:erlang.spawn_opt/4&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0761006711d858b0c2a58d2cbd1afefe913dcc42" translate="yes" xml:space="preserve">
          <source>Moreover, even when trapping exits, calling &lt;code&gt;await&lt;/code&gt; will still exit if the task has terminated without sending its result back.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a438f48c599e07f621f37d7528ee6f6b3ed9813" translate="yes" xml:space="preserve">
          <source>Most Elixir code has a straight-forward translation to its underlying quoted expression. We recommend you try out different code samples and see what the results are. For example, what does &lt;code&gt;String.upcase(&quot;foo&quot;)&lt;/code&gt; expand to? We have also learned that &lt;code&gt;if(true, do: :this, else: :that)&lt;/code&gt; is the same as &lt;code&gt;if true do :this else :that end&lt;/code&gt;. How does this affirmation hold with quoted expressions?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0687907a8d3988b5e082480eea48abedcef483ec" translate="yes" xml:space="preserve">
          <source>Most editors provide built-in integration with the formatter, allowing a file to be formatted on save or via a chosen keybinding. If you are learning Elixir, editor integration gives you useful and quick feedback when learning the Elixir syntax.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="024156cd258aa614f1a1e84226c2405ec889367a" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module return &lt;code&gt;:ok&lt;/code&gt; or &lt;code&gt;{:ok, result}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise. Those functions also have a variant that ends with &lt;code&gt;!&lt;/code&gt; which returns the result (instead of the &lt;code&gt;{:ok, result}&lt;/code&gt; tuple) in case of success or raises an exception in case it fails. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbffd668417f19cdbcd33d0162e5263a21e09ebf" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module work in linear time. This means that, that the time it takes to perform an operation grows at the same rate as the length of the list. For example &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;length/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#last/1&quot;&gt;&lt;code&gt;last/1&lt;/code&gt;&lt;/a&gt; will run in linear time because they need to iterate through every element of the list, but &lt;a href=&quot;#first/1&quot;&gt;&lt;code&gt;first/1&lt;/code&gt;&lt;/a&gt; will run in constant time because it only needs the first element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9701b5552f6ac3d94cc4ca928ec6d05512ce0a" translate="yes" xml:space="preserve">
          <source>Most of the functions in this module work in linear time. This means that, the time it takes to perform an operation grows at the same rate as the length of the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fd0b4b5634fc00fd0cd07602c5fab763e2a315d" translate="yes" xml:space="preserve">
          <source>Most of the inlined functions can be seen in effect when capturing the function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650e20466b330f46fc9cd6f719b3f04d44e3661d" translate="yes" xml:space="preserve">
          <source>Most of the operations in &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; are implemented in terms of reduce. This function should apply the given &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function to each element in the &lt;code&gt;enumerable&lt;/code&gt; and proceed as expected by the returned accumulator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24b137a5b6dba3724d546a7b4386d3d0c4f7db88" translate="yes" xml:space="preserve">
          <source>Most of the time it is convenient to write modules into files so they can be compiled and reused. Let&amp;rsquo;s assume we have a file named &lt;code&gt;math.ex&lt;/code&gt; with the following contents:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="629b5f27dd5283caadd5c5cbf0f295755b9869cd" translate="yes" xml:space="preserve">
          <source>Most of the time there is one, and just one, valid datetime for a certain date and time in a certain time zone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91857fb8fa18b4cfe30782a8862e99da6ebb9879" translate="yes" xml:space="preserve">
          <source>Most of the time, Elixir is going to guide you to do the right thing. For example, there is an &lt;code&gt;elem/2&lt;/code&gt; function to access a tuple item but there is no built-in equivalent for lists:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca16065899804f7768a7a1720aa616e84369d6b" translate="yes" xml:space="preserve">
          <source>Move the undocumented function to a module with &lt;code&gt;@moduledoc false&lt;/code&gt;, like &lt;code&gt;MyApp.Hidden&lt;/code&gt;, ensuring the function won't be accidentally exposed or imported. Remember you can use &lt;code&gt;@moduledoc false&lt;/code&gt; to hide a whole module and still document each function with &lt;code&gt;@doc&lt;/code&gt;. Tools will still ignore the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ba586c26244aa844e20201d605ef816e569e0c3" translate="yes" xml:space="preserve">
          <source>Much better! &lt;code&gt;with&lt;/code&gt; will retrieve the value returned by the right-side of &lt;code&gt;&amp;lt;-&lt;/code&gt; and match it against the pattern on the left side. If the value matches the pattern, &lt;code&gt;with&lt;/code&gt; moves on to the next expression. In case there is no match, the non-matching value is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aca1d8661416c63356922cc0e796c657256bdbf6" translate="yes" xml:space="preserve">
          <source>Multi alias/import/require/use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="600851f745d8c6c136c80bb6740770dde7f94908" translate="yes" xml:space="preserve">
          <source>Multi-letter aliases in &lt;a href=&quot;optionparser&quot;&gt;&lt;code&gt;OptionParser&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd897f3df67fae1b86657cd6f5002662e25d4a84" translate="yes" xml:space="preserve">
          <source>Multi-line charlists are written with three single-quotes (&lt;code&gt;'''&lt;/code&gt;), the same way multi-line strings are.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971b1abcdb78d0f06496a5acd8f26ed4ec25bf2b" translate="yes" xml:space="preserve">
          <source>Multi-line lists, maps, tuples, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387558e9801635e36ced6d8f96c29ddee6395ce1" translate="yes" xml:space="preserve">
          <source>Multi-line strings in Elixir are written with three double-quotes, and can have unescaped quotes within them. The resulting string will end with a newline. The indentation of the last &lt;code&gt;&quot;&quot;&quot;&lt;/code&gt; is used to strip indentation from the inner string. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b47d6814f63cc5e3bd080a55da0c264aee3d21" translate="yes" xml:space="preserve">
          <source>Multiple code points that may be perceived as a single character by readers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d1f745a36808f93bd028263c26703cfbaed268c" translate="yes" xml:space="preserve">
          <source>Multiple generators can also be used to calculate the cartesian product of two lists:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd421a1aa76b2a83bd80d007c37c141c303064d" translate="yes" xml:space="preserve">
          <source>Multiple guards in the same clause</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c528525d61b06dbc869c01826c97062225a9a675" translate="yes" xml:space="preserve">
          <source>Multiple implementations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f43d8ba152323821f27a132f7581f8caab516e47" translate="yes" xml:space="preserve">
          <source>Multiple releases. You can assemble different releases with different configuration per application or even with different applications altogether.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4cf21f4344405e752af495c43a5b7beb80cfa4" translate="yes" xml:space="preserve">
          <source>Multiple uses of &lt;code&gt;@compile&lt;/code&gt; will accumulate instead of overriding previous ones. See the &quot;Compile options&quot; section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd5985b43b284860bef16f48015f61c53879304" translate="yes" xml:space="preserve">
          <source>Multiple uses of &lt;code&gt;@dialyzer&lt;/code&gt; will accumulate instead of overriding previous ones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bc08a47511c7c5ad4c0a467eaca187d877e8749" translate="yes" xml:space="preserve">
          <source>Mutable state and access to shared resources (such as ETS, files, etc.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c5ad44b6579fcbcf0c6ec60e160908d2a983ce" translate="yes" xml:space="preserve">
          <source>My computer is named &lt;code&gt;jv&lt;/code&gt;, so I see &lt;code&gt;foo@jv&lt;/code&gt; in the example above, but you will get a different result. We will use &lt;code&gt;foo@computer-name&lt;/code&gt; in the following examples and you should update them accordingly when trying out the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a50f07a710ba62544947bf23759e42c6e82ff7d6" translate="yes" xml:space="preserve">
          <source>My particular telnet client can be exited by typing &lt;code&gt;ctrl + ]&lt;/code&gt;, typing &lt;code&gt;quit&lt;/code&gt;, and pressing &lt;code&gt;&amp;lt;Enter&amp;gt;&lt;/code&gt;, but your client may require different steps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b897ebc1430a2e4abc81cf0b2714edf134f99207" translate="yes" xml:space="preserve">
          <source>NaiveDateTime</source>
          <target state="translated">NaiveDateTime</target>
        </trans-unit>
        <trans-unit id="d49675d6a7db398730976978d05575d69c0eb3c3" translate="yes" xml:space="preserve">
          <source>Name registration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368a0ab278773b445741a837271772d0936779aa" translate="yes" xml:space="preserve">
          <source>Named functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7cb86483160ed9ca9d1ab540d3476197e0162c0" translate="yes" xml:space="preserve">
          <source>Named functions in Elixir also support default arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b4617b659a51d0b5756991a46730570511eef04" translate="yes" xml:space="preserve">
          <source>Naming</source>
          <target state="translated">Naming</target>
        </trans-unit>
        <trans-unit id="8af56df8a9cb35f56b67edd6d269d4e86defc0d0" translate="yes" xml:space="preserve">
          <source>Naming Conventions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7072ebdd4d3d7903620768f687a8dfdcc8ce66" translate="yes" xml:space="preserve">
          <source>Naming processes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dafad67b671623ab79a27e34be51e846c44fb41" translate="yes" xml:space="preserve">
          <source>Negation switches</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf669c72f3ca4537fedf1a696188ac323c60bad" translate="yes" xml:space="preserve">
          <source>Negative Unix times are supported, up to -62167219200 seconds, which is equivalent to &quot;0000-01-01T00:00:00Z&quot; or 0 Gregorian seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a20bdc82e5703dd99f69be3ffeaf120ee97f50f4" translate="yes" xml:space="preserve">
          <source>Negative indices indicate an offset from the end of the &lt;code&gt;list&lt;/code&gt;. If &lt;code&gt;index&lt;/code&gt; is out of bounds, the original &lt;code&gt;list&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f8888aa8ebd456306e0978a35197f74b636d4e" translate="yes" xml:space="preserve">
          <source>Nested data structures</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06563daf6842a8e082fd4615e320fc869bb69d9" translate="yes" xml:space="preserve">
          <source>Nesting</source>
          <target state="translated">Nesting</target>
        </trans-unit>
        <trans-unit id="230c22b07521849e4e1eb0ed24d083dc0b4e9329" translate="yes" xml:space="preserve">
          <source>Nesting a module inside another module affects the name of the nested module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0587b966ad1346723038626d25a39c4caf0fcf4" translate="yes" xml:space="preserve">
          <source>Nests the given document at the given &lt;code&gt;level&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac15dcab98b84e881f95ff7f13b6c27d1103008b" translate="yes" xml:space="preserve">
          <source>New releases are announced in the read-only &lt;a href=&quot;https://groups.google.com/group/elixir-lang-ann&quot;&gt;announcements mailing list&lt;/a&gt;. All security releases &lt;a href=&quot;https://groups.google.com/forum/#!searchin/elixir-lang-ann/%255Bsecurity%255D%257Csort:date&quot;&gt;will be tagged with &lt;code&gt;[security]&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09050a709859e9c045fb8157c8d7649b286d2c98" translate="yes" xml:space="preserve">
          <source>Newlines before certain operators (such as the pipeline operators) and before other operators (such as comparison operators)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c7d720a2e040b46c0d03386d11f05cbd66532dd" translate="yes" xml:space="preserve">
          <source>Newlines inside blocks are kept as in the input except for: 1) expressions that take multiple lines will always have an empty line before and after and 2) empty lines are always squeezed together into a single empty line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11fc14203dd0f4441645a9c34d5dd022905f56e4" translate="yes" xml:space="preserve">
          <source>Next steps</source>
          <target state="translated">다음 단계</target>
        </trans-unit>
        <trans-unit id="750891f84c6b7eeddc41453bbdd8ec1255f11a42" translate="yes" xml:space="preserve">
          <source>Next, let&amp;rsquo;s discuss external and internal dependencies and how Mix helps us manage large codebases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec26ea6bcbb7c9f81e3f941cb690507a65daec00" translate="yes" xml:space="preserve">
          <source>Next, we&amp;rsquo;ll look at a feature central to Elixir, Processes, which allows us to write concurrent, parallel and distributed programs in an easy and understandable way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41cb14263e20c4624e46c802b32ac0cf7c57a851" translate="yes" xml:space="preserve">
          <source>No computation will be done until we call one of the &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; functions or &lt;a href=&quot;#run/1&quot;&gt;&lt;code&gt;run/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260f7a8cd4f6938b3cc185a619847cb83d670219" translate="yes" xml:space="preserve">
          <source>Node</source>
          <target state="translated">Node</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
