<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="elixir">
    <body>
      <group id="elixir">
        <trans-unit id="b6e83d3c9cef0e0783f020702595feef71f3f20e" translate="yes" xml:space="preserve">
          <source>Non-map as 2nd argument in &lt;a href=&quot;uri#decode_query/2&quot;&gt;&lt;code&gt;URI.decode_query/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;uri#decode_query/2&quot;&gt; &lt;code&gt;URI.decode_query/2&lt;/code&gt; &lt;/a&gt; 에서 두 번째 인수로 비맵.</target>
        </trans-unit>
        <trans-unit id="071e8151474691189ee1733bdecf01a3f3e2cb81" translate="yes" xml:space="preserve">
          <source>Non-qualified calls (local calls)</source>
          <target state="translated">비 규격 통화 (로컬 통화)</target>
        </trans-unit>
        <trans-unit id="53cb3754c560024cfd1bcc5260b860f30909000c" translate="yes" xml:space="preserve">
          <source>Non-qualified calls, such as &lt;code&gt;add(1, 2)&lt;/code&gt;, must start with an underscore or a Unicode letter that is not in uppercase or titlecase. The call may continue using a sequence of Unicode letters, numbers, and underscore. Calls may end in &lt;code&gt;?&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt;. See &lt;a href=&quot;unicode-syntax&quot;&gt;Unicode Syntax&lt;/a&gt; for a formal specification.</source>
          <target state="translated">&lt;code&gt;add(1, 2)&lt;/code&gt; 와 같은 규정되지 않은 호출 은 대문자 나 제목이 아닌 밑줄 또는 유니 코드 문자로 시작해야합니다. 일련의 유니 코드 문자, 숫자 및 밑줄을 계속 사용하여 호출 할 수 있습니다. 통화가 끝날 수 &lt;code&gt;?&lt;/code&gt; 또는 &lt;code&gt;!&lt;/code&gt; . 공식 사양 은 &lt;a href=&quot;unicode-syntax&quot;&gt;유니 코드 구문&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b40e406bdf08c15d5973db15d0796f73afa2bc3f" translate="yes" xml:space="preserve">
          <source>Normal color or intensity.</source>
          <target state="translated">일반 색상 또는 강도.</target>
        </trans-unit>
        <trans-unit id="16efb8f5278c1947b297b82bf3c74d4bdac2d0d7" translate="yes" xml:space="preserve">
          <source>Normalizes an exception, converting Erlang exceptions to Elixir exceptions.</source>
          <target state="translated">Erlang 예외를 Elixir 예외로 변환하여 예외를 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="ca65eca931881f00085a8c21384007ac72711fde" translate="yes" xml:space="preserve">
          <source>Normalizes and formats any throw/error/exit.</source>
          <target state="translated">던지기 / 오류 / 나가기를 정규화하고 형식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d040545513c396d6f00a60b9e02e4a5efcfb1b55" translate="yes" xml:space="preserve">
          <source>Normalizes and formats throw/errors/exits and stacktraces.</source>
          <target state="translated">던지기 / 오류 / 종료 및 스택 추적을 정규화하고 형식화합니다.</target>
        </trans-unit>
        <trans-unit id="343f0ad200dae1f7321bdbca2861d3e1cec1c9d9" translate="yes" xml:space="preserve">
          <source>Not all expressions are allowed in guard clauses, but only a handful of them. This is a deliberate choice. This way, Elixir (and Erlang) can make sure that nothing bad happens while executing guards and no mutations happen anywhere. It also allows the compiler to optimize the code related to guards efficiently.</source>
          <target state="translated">모든 표현식이 가드 절에서 허용되는 것은 아니지만 소수의 표현식 만 허용됩니다. 이것은 고의적 인 선택입니다. 이런 식으로 Elixir (및 Erlang)는 경비원을 실행하는 동안 나쁜 일이 발생하지 않으며 어디서나 돌연변이가 발생하지 않도록 할 수 있습니다. 또한 컴파일러가 보호와 관련된 코드를 효율적으로 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63cc6d4577351584189eae49ee593bacbcaa1a41" translate="yes" xml:space="preserve">
          <source>Not allowed in guard clauses.</source>
          <target state="translated">가드 조항에는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f4ee146dc15494c81d4bd8a2a2759820080e7c5" translate="yes" xml:space="preserve">
          <source>Not framed or encircled.</source>
          <target state="translated">액자 또는 둘러싸이지 않음.</target>
        </trans-unit>
        <trans-unit id="91158d4ebf885b7c2cce115618384afcd3d60c6c" translate="yes" xml:space="preserve">
          <source>Not italic.</source>
          <target state="translated">이탤릭체가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e8cbaff7c13d97516b633b0d9d10f2ab0d66c800" translate="yes" xml:space="preserve">
          <source>Not only that, as you create new buckets on the terminal, you should see new processes spawned in the supervision tree shown in Observer:</source>
          <target state="translated">뿐만 아니라 터미널에서 새 버킷을 생성 할 때 관찰자에 표시된 감독 트리에 새 프로세스가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8ece420ef660602018d9d85c815c1206e83a9313" translate="yes" xml:space="preserve">
          <source>Not overlined.</source>
          <target state="translated">요약되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="12d014121a6d98d766e19560d6f8af18c0e40cbc" translate="yes" xml:space="preserve">
          <source>Note &lt;code&gt;Process.monitor(pid)&lt;/code&gt; returns a unique reference that allows us to match upcoming messages to that monitoring reference. After we stop the agent, we can &lt;code&gt;flush/0&lt;/code&gt; all messages and notice a &lt;code&gt;:DOWN&lt;/code&gt; message arrived, with the exact reference returned by &lt;code&gt;monitor&lt;/code&gt;, notifying that the bucket process exited with reason &lt;code&gt;:normal&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;Process.monitor(pid)&lt;/code&gt; 는 다음 메시지를 해당 모니터링 참조와 일치시킬 수있는 고유 한 참조를 리턴합니다. 에이전트를 중지 한 후 모든 메시지를 &lt;code&gt;flush/0&lt;/code&gt; 하고 &lt;code&gt;monitor&lt;/code&gt; 에 의해 반환 된 정확한 참조와 함께 &lt;code&gt;:DOWN&lt;/code&gt; 메시지가 도착 하여 버킷 프로세스가 reason &lt;code&gt;:normal&lt;/code&gt; 로 종료되었음을 알립니다 .</target>
        </trans-unit>
        <trans-unit id="fb3f40b5039d7c318694befb342ce3f4c9f0f60a" translate="yes" xml:space="preserve">
          <source>Note a tag can be set in two different ways:</source>
          <target state="translated">태그는 두 가지 방법으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3377b2b2eb71be892a3e682ccebe7f9b31d7572" translate="yes" xml:space="preserve">
          <source>Note also that the &lt;code&gt;:transient&lt;/code&gt; type is of little practical use, since when a supervision tree terminates, the reason is set to &lt;code&gt;:shutdown&lt;/code&gt;, not &lt;code&gt;:normal&lt;/code&gt;.</source>
          <target state="translated">감시 트리가 종료되면 이유는 &lt;code&gt;:normal&lt;/code&gt; 이 아니라 : &lt;code&gt;:shutdown&lt;/code&gt; 설정 되므로 &lt;code&gt;:transient&lt;/code&gt; 유형은 실용성이 거의 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c528946c2af34a0e5a1e8d711f96487c6c795447" translate="yes" xml:space="preserve">
          <source>Note anonymous functions can also have multiple clauses and guards:</source>
          <target state="translated">익명 함수에는 여러 절과 가드가있을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d3adc9c8853ececa9befa7c8ce8ff49c5919675" translate="yes" xml:space="preserve">
          <source>Note describe blocks cannot be nested. Instead of relying on hierarchy for composition, developers should build on top of named setups. For example:</source>
          <target state="translated">설명 블록은 중첩 될 수 없습니다. 구성을 위해 계층 구조에 의존하는 대신 개발자는 명명 된 설정을 기반으로 구축해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5ca0f4688d0116095aeec4a9d739e406b9afeec" translate="yes" xml:space="preserve">
          <source>Note each entry in the binary pattern is expected to match exactly 8 bits. If we want to match on a binary of unknown size, it is possible by using the binary modifier at the end of the pattern:</source>
          <target state="translated">이진 패턴의 각 항목은 정확히 8 비트와 일치해야합니다. 알 수없는 크기의 이진을 일치 시키려면 패턴 끝에서 이진 수정자를 사용하면 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e1393c185477299f5e854d4848419bacfa99c239" translate="yes" xml:space="preserve">
          <source>Note it is important to recompile a file's dependencies as there are often compile time dependencies between them.</source>
          <target state="translated">파일 간의 종속성이 종종 있기 때문에 파일의 종속성을 다시 컴파일하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="127cdeb36c75a2e9ea3ccb032068074d455163d3" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#c:load/2&quot;&gt;&lt;code&gt;load/2&lt;/code&gt;&lt;/a&gt; is typically invoked very early in the boot process, therefore if you need to use an application in the provider, it is your responsibility to start it.</source>
          <target state="translated">참고 &lt;a href=&quot;#c:load/2&quot;&gt; &lt;code&gt;load/2&lt;/code&gt; &lt;/a&gt; 일반적으로이 공급자에서 응용 프로그램을 사용할 필요가 있으므로 경우, 초기 부팅 프로세스의 호출은, 그것을 시작하는 것은 귀하 자신의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="98fcc4c0b233355a84f821a3c513063ad4e24444" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#reply/2&quot;&gt;&lt;code&gt;reply/2&lt;/code&gt;&lt;/a&gt; can be called from any process, not just the GenServer that originally received the call (as long as that GenServer communicated the &lt;code&gt;from&lt;/code&gt; argument somehow).</source>
          <target state="translated">참고 &lt;a href=&quot;#reply/2&quot;&gt; &lt;code&gt;reply/2&lt;/code&gt; &lt;/a&gt; (GenServer가 전달 된 그만큼 처음 전화를받은 과정뿐만 아니라 GenServer에서 호출 할 수 있습니다 &lt;code&gt;from&lt;/code&gt; 어떻게 든 인수).</target>
        </trans-unit>
        <trans-unit id="e1626fef0c1a33798d2c34dfc74515bf8d5c377d" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;String.t()&lt;/code&gt; and &lt;code&gt;binary()&lt;/code&gt; are equivalent to analysis tools. Although, for those reading the documentation, &lt;code&gt;String.t()&lt;/code&gt; implies it is a UTF-8 encoded binary.</source>
          <target state="translated">참고 &lt;code&gt;String.t()&lt;/code&gt; 와 &lt;code&gt;binary()&lt;/code&gt; 분석 도구에 해당합니다. 문서를 읽는 사람들에게 &lt;code&gt;String.t()&lt;/code&gt; 는 UTF-8로 인코딩 된 바이너리임을 암시합니다.</target>
        </trans-unit>
        <trans-unit id="8ceb120a9be7ed748230ca821c05f6918e48cd56" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;\\&lt;/code&gt; can't be used with anonymous functions because they can only have a sole arity.</source>
          <target state="translated">참고 &lt;code&gt;\\&lt;/code&gt; 는 그들이 단지 단독 인수에 대응을 가질 수 있기 때문에 익명 함수와 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="284b6400c5d9fc089c636125d995e2b0e56e6990" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;^x&lt;/code&gt; always refers to the value of &lt;code&gt;x&lt;/code&gt; prior to the match. The following example will match:</source>
          <target state="translated">참고 &lt;code&gt;^x&lt;/code&gt; 항상의 값을 참조 &lt;code&gt;x&lt;/code&gt; 경기에 앞서. 다음 예제는 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c1877a8124459f28213b53d05b5f96adf2e6ee0c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;alias&lt;/code&gt; is &lt;strong&gt;lexically scoped&lt;/strong&gt;, which allows you to set aliases inside specific functions:</source>
          <target state="translated">주의 &lt;code&gt;alias&lt;/code&gt; 되는 &lt;strong&gt;어휘 범위가&lt;/strong&gt; 특정 기능 내부 설정 별칭을 수행 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5684572f42db95ac181baf9058ba1bcc12e51cad" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;cast&lt;/code&gt; returns &lt;code&gt;:ok&lt;/code&gt; immediately, regardless of whether &lt;code&gt;agent&lt;/code&gt; (or the node it should live on) exists.</source>
          <target state="translated">주의 &lt;code&gt;cast&lt;/code&gt; 반환 &lt;code&gt;:ok&lt;/code&gt; 즉시 여부에 관계없이의 &lt;code&gt;agent&lt;/code&gt; (또는에서 살아야 노드)가 존재한다.</target>
        </trans-unit>
        <trans-unit id="c5c4acc72c847b14f34cef90da2dbdafe8c0f864" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;defines?&lt;/code&gt; returns false for functions and macros that have been defined but then marked as overridable and no other implementation has been provided. You can check the overridable status by calling &lt;a href=&quot;#overridable?/2&quot;&gt;&lt;code&gt;overridable?/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주의 &lt;code&gt;defines?&lt;/code&gt; 정의되었지만 재정의 가능한 것으로 표시되고 다른 구현이 제공되지 않은 함수 및 매크로에 대해서는 false를 반환합니다. &lt;a href=&quot;#overridable?/2&quot;&gt; &lt;code&gt;overridable?/2&lt;/code&gt; 를&lt;/a&gt; 호출하여 재정의 가능한 상태를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90f8221caf1663dc39261548c92a478da7147d51" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;do/end&lt;/code&gt; become delimiters. The second example would translate to:</source>
          <target state="translated">주 &lt;code&gt;do/end&lt;/code&gt; 하게 구분 기호를. 두 번째 예는 다음과 같이 번역됩니다.</target>
        </trans-unit>
        <trans-unit id="d9f98e56a6b073dedf21c4fd7053a53e9bd1aea1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;import&lt;/code&gt; is &lt;strong&gt;lexically scoped&lt;/strong&gt; too. This means that we can import specific macros or functions inside function definitions:</source>
          <target state="translated">참고 &lt;code&gt;import&lt;/code&gt; 되는 &lt;strong&gt;어휘 범위&lt;/strong&gt; 도. 즉, 함수 정의 내에서 특정 매크로 또는 함수를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d91cdd66170ee21978845d99279b84980730cb3" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;import&lt;/code&gt;ing a module automatically &lt;code&gt;require&lt;/code&gt;s it.</source>
          <target state="translated">모듈 을 &lt;code&gt;import&lt;/code&gt; 자동으로 &lt;code&gt;require&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ab30e5a1bc4b404e7cb3f7adf25fbc460e6c3561" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;index&lt;/code&gt; is capped at the list length. Negative indices indicate an offset from the end of the &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;index&lt;/code&gt; 목록 길이에 덮인된다. 음수 인덱스는 &lt;code&gt;list&lt;/code&gt; 끝에서 오프셋을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="12525ea5b78a44ac5eef68af6cc8e0ed2ce006ea" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;serve/1&lt;/code&gt; is an infinite loop called sequentially inside &lt;code&gt;loop_acceptor/1&lt;/code&gt;, so the tail call to &lt;code&gt;loop_acceptor/1&lt;/code&gt; is never reached and could be avoided. However, as we shall see, we will need to execute &lt;code&gt;serve/1&lt;/code&gt; in a separate process, so we will need that tail call soon.</source>
          <target state="translated">주 &lt;code&gt;serve/1&lt;/code&gt; 순차적으로 내부이라는 무한 루프 &lt;code&gt;loop_acceptor/1&lt;/code&gt; 에 꼬리를 호출하므로, &lt;code&gt;loop_acceptor/1&lt;/code&gt; 에 도달하지 않습니다와 피할 수 있습니다. 그러나 앞으로 살펴 보 겠지만 , 별도의 프로세스에서 &lt;code&gt;serve/1&lt;/code&gt; 을 실행해야 하므로 곧 테일 콜이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="de063b80d08dcad20f96832929534bd43e718138" translate="yes" xml:space="preserve">
          <source>Note that a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; started with &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; is linked to the parent process and will exit in case of crashes from the parent. The GenServer will also exit due to the &lt;code&gt;:normal&lt;/code&gt; reasons in case it is configured to trap exits in the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; callback.</source>
          <target state="translated">&amp;bull; 그래도 참고 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 가&lt;/a&gt; 시작 &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 부모 프로세스에 연결되어 부모로부터 충돌의 경우에 종료됩니다. GenServer는 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 콜백 에서 엑시트를 트랩하도록 구성된 경우 &lt;code&gt;:normal&lt;/code&gt; 이유로 인해 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="08443544f9b5807d8ae2ca59e1cdfa2a987f5f51" translate="yes" xml:space="preserve">
          <source>Note that a supervisor started with this function is linked to the parent process and exits not only on crashes but also if the parent process exits with &lt;code&gt;:normal&lt;/code&gt; reason.</source>
          <target state="translated">이 기능으로 시작한 수퍼바이저는 상위 프로세스에 연결되어 충돌시뿐만 아니라 상위 프로세스가 &lt;code&gt;:normal&lt;/code&gt; 이유로 종료되는 경우에도 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="954d4540ce99f199a6a0a382f7d567881ea15fd5" translate="yes" xml:space="preserve">
          <source>Note that all Elixir operators are also valid atoms. Therefore &lt;code&gt;:+&lt;/code&gt;, &lt;code&gt;:@&lt;/code&gt;, &lt;code&gt;:|&amp;gt;&lt;/code&gt;, and others are all valid atoms. The full description of valid atoms is available in the Syntax Reference, this document covers only the rules for identifier-based atoms.</source>
          <target state="translated">모든 Elixir 연산자도 유효한 원자입니다. 따라서 &lt;code&gt;:+&lt;/code&gt; , &lt;code&gt;:@&lt;/code&gt; , &lt;code&gt;:|&amp;gt;&lt;/code&gt; 등은 모두 유효한 원자입니다. 유효한 원자에 대한 자세한 설명은 구문 참조에 나와 있습니다.이 문서는 식별자 기반 원자에 대한 규칙 만 다룹니다.</target>
        </trans-unit>
        <trans-unit id="ac0b3ec8f1db4589a8f8e1eb136c0f7227194b62" translate="yes" xml:space="preserve">
          <source>Note that all metadata is optional and may not always be available. The &lt;code&gt;:module&lt;/code&gt;, &lt;code&gt;:function&lt;/code&gt;, &lt;code&gt;:line&lt;/code&gt;, and similar metadata are automatically included when using &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; macros. &lt;a href=&quot;logger#bare_log/3&quot;&gt;&lt;code&gt;Logger.bare_log/3&lt;/code&gt;&lt;/a&gt; does not include any metadata beyond the &lt;code&gt;:pid&lt;/code&gt; by default. Other metadata, such as &lt;code&gt;:crash_reason&lt;/code&gt;, &lt;code&gt;:initial_call&lt;/code&gt;, and &lt;code&gt;:registered_name&lt;/code&gt; are extracted from Erlang/OTP crash reports and available only in those cases.</source>
          <target state="translated">모든 메타 데이터는 선택 사항이며 항상 사용 가능한 것은 아닙니다. &lt;code&gt;:module&lt;/code&gt; , &lt;code&gt;:function&lt;/code&gt; , &lt;code&gt;:line&lt;/code&gt; 사용하는 경우와 유사한 메타 데이터는 자동으로 포함 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 매크로. &lt;a href=&quot;logger#bare_log/3&quot;&gt; &lt;code&gt;Logger.bare_log/3&lt;/code&gt; &lt;/a&gt; 는 기본적으로 &lt;code&gt;:pid&lt;/code&gt; 이외의 메타 데이터를 포함하지 않습니다 . &lt;code&gt;:crash_reason&lt;/code&gt; , &lt;code&gt;:initial_call&lt;/code&gt; 및 &lt;code&gt;:registered_name&lt;/code&gt; 과 같은 기타 메타 데이터 는 Erlang / OTP 충돌 보고서에서 추출되어 해당 경우에만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="76c7fd844c6a4b97c6af78f0323e658a0263e3d7" translate="yes" xml:space="preserve">
          <source>Note that all tests are included by default, so unless they are excluded first (either in the test helper or via the &lt;code&gt;--exclude&lt;/code&gt; option) the &lt;code&gt;--include&lt;/code&gt; option has no effect.</source>
          <target state="translated">모든 테스트는 기본적으로 포함되므로 테스트 도우미 나 &lt;code&gt;--exclude&lt;/code&gt; 옵션을 통해 먼저 제외하지 않는 한 &lt;code&gt;--include&lt;/code&gt; 옵션은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="764accc79b7e7fbac8971b738cd4bab00fe7637c" translate="yes" xml:space="preserve">
          <source>Note that an IO stream has side effects and every time you go over the stream you may get different results.</source>
          <target state="translated">IO 스트림에는 부작용이 있으며 스트림을 처리 할 때마다 다른 결과가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edad52b62a5c2594d2df1d229d1b57a6b8821bde" translate="yes" xml:space="preserve">
          <source>Note that both UTC and Standard offsets will be taken into account when comparison is done.</source>
          <target state="translated">비교가 완료되면 UTC 및 표준 오프셋이 모두 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="406fc1b32b85677464e45a089ad7df7b494e5b86" translate="yes" xml:space="preserve">
          <source>Note that calling this function when supervising a large number of children under low memory conditions can cause an out of memory exception.</source>
          <target state="translated">메모리 부족 상태에서 많은 수의 자식을 감독 할 때이 함수를 호출하면 메모리 부족 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fabe66319df854999ff8cf0e3d6fa8aaf6d30285" translate="yes" xml:space="preserve">
          <source>Note that filenames when given as charlists in Elixir are always treated as UTF-8. In particular, we expect that the shell and the operating system are configured to use UTF-8 encoding. Binary filenames are considered raw and passed to the operating system as is.</source>
          <target state="translated">Elixir에서 문자 목록으로 제공 될 때 파일 이름은 항상 UTF-8로 처리됩니다. 특히, 쉘과 운영 체제가 UTF-8 인코딩을 사용하도록 구성되어있을 것으로 기대합니다. 이진 파일 이름은 그대로 간주되며 운영 체제로 그대로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="103cdbd91afa6836ea7762204d98d6131437f8ac" translate="yes" xml:space="preserve">
          <source>Note that for large registries with many partitions this will be costly as it builds the result by concatenating all the partitions.</source>
          <target state="translated">파티션이 많은 대규모 레지스트리의 경우 모든 파티션을 연결하여 결과를 빌드하므로 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="f080d783bf0fd06342e1a61dcd384d6c89650c0e" translate="yes" xml:space="preserve">
          <source>Note that for temporary children, the child specification is automatically deleted when the child terminates, and thus it is not possible to restart such children.</source>
          <target state="translated">임시 하위의 경우 하위가 종료되면 하위 스펙이 자동으로 삭제되므로 해당 하위를 다시 시작할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="997a3967a5f4bb658a4ce5f677487cb8a5c8fec2" translate="yes" xml:space="preserve">
          <source>Note that if a process is exiting, it is considered to exist but not be alive. This means that for such process, &lt;a href=&quot;#alive?/1&quot;&gt;&lt;code&gt;alive?/1&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;false&lt;/code&gt; but its PID will be part of the list of PIDs returned by this function.</source>
          <target state="translated">프로세스가 종료되면 존재하지만 살아 있지 않은 것으로 간주됩니다. 이는 그러한 프로세스에서 &lt;a href=&quot;#alive?/1&quot;&gt; &lt;code&gt;alive?/1&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;false&lt;/code&gt; 를 반환 하지만 PID는이 함수가 반환 한 PID 목록의 일부가됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a43e287fde89bfb0a88b95e0c986594cfaffdabd" translate="yes" xml:space="preserve">
          <source>Note that if the option &lt;code&gt;:delayed_write&lt;/code&gt; was used when opening the file, &lt;a href=&quot;#close/1&quot;&gt;&lt;code&gt;close/1&lt;/code&gt;&lt;/a&gt; might return an old write error and not even try to close the file. See &lt;a href=&quot;#open/2&quot;&gt;&lt;code&gt;open/2&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">파일을 열 때 &lt;code&gt;:delayed_write&lt;/code&gt; 옵션 이 사용 된 경우 &lt;a href=&quot;#close/1&quot;&gt; &lt;code&gt;close/1&lt;/code&gt; &lt;/a&gt; 은 오래된 쓰기 오류를 반환하고 파일을 닫으려고하지 않을 수도 있습니다. 자세한 내용은 &lt;a href=&quot;#open/2&quot;&gt; &lt;code&gt;open/2&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2f646c93d4eef7c70fd05d7240d6a69876a9baf5" translate="yes" xml:space="preserve">
          <source>Note that if you pass a &lt;a href=&quot;macro.env&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; struct as first argument while also passing &lt;code&gt;opts&lt;/code&gt;, they will be merged with &lt;code&gt;opts&lt;/code&gt; having precedence.</source>
          <target state="translated">&lt;code&gt;opts&lt;/code&gt; 도 전달하면서 &lt;a href=&quot;macro.env&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt; 구조체를 첫 번째 인수로 전달하면 우선 순위가 있는 &lt;code&gt;opts&lt;/code&gt; 와 병합됩니다 .</target>
        </trans-unit>
        <trans-unit id="64b52ff72a460cecc390aabeeeee6af670211c1b" translate="yes" xml:space="preserve">
          <source>Note that in order for this macro to work, the complete path must always be visible by this macro. For more information about the supported path expressions, please check &lt;a href=&quot;#get_and_update_in/2&quot;&gt;&lt;code&gt;get_and_update_in/2&lt;/code&gt;&lt;/a&gt; docs.</source>
          <target state="translated">이 매크로가 작동하려면이 매크로가 항상 전체 경로를 볼 수 있어야합니다. 지원되는 경로 표현식에 대한 자세한 내용은 &lt;a href=&quot;#get_and_update_in/2&quot;&gt; &lt;code&gt;get_and_update_in/2&lt;/code&gt; &lt;/a&gt; 문서 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e49d404776bcbe0ae060a73286ea9c896eb6178" translate="yes" xml:space="preserve">
          <source>Note that in order for this macro to work, the complete path must always be visible by this macro. See the Paths section below.</source>
          <target state="translated">이 매크로가 작동하려면이 매크로가 항상 전체 경로를 볼 수 있어야합니다. 아래의 경로 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bcf88d15a7510f97dbf0ab0147120a93a4cb3ae1" translate="yes" xml:space="preserve">
          <source>Note that in our macro implementation, the sentence was not printed, although it was printed in our function implementation. That&amp;rsquo;s because the arguments to a function call are evaluated before calling the function. However, macros do not evaluate their arguments. Instead, they receive the arguments as quoted expressions which are then transformed into other quoted expressions. In this case, we have rewritten our &lt;code&gt;unless&lt;/code&gt; macro to become an &lt;code&gt;if&lt;/code&gt; behind the scenes.</source>
          <target state="translated">매크로 구현에서는 문장이 함수 구현으로 인쇄되었지만 문장이 인쇄되지 않았습니다. 함수 호출에 대한 인수는 함수를 호출하기 전에 평가되기 때문입니다. 그러나 매크로는 인수를 평가하지 않습니다. 대신 인수를 인용 된 표현식으로 수신 한 다음 다른 인용 된 표현식으로 변환합니다. 이 경우, 우리는 다시 한 &lt;code&gt;unless&lt;/code&gt; 매크로 될 &lt;code&gt;if&lt;/code&gt; 배후.</target>
        </trans-unit>
        <trans-unit id="457d54652787a94a3f6b0231b5aed3d435010820" translate="yes" xml:space="preserve">
          <source>Note that inside this new IEx session, we cannot access &lt;code&gt;Hello.world/0&lt;/code&gt;:</source>
          <target state="translated">이 새로운 IEx 세션에서는 &lt;code&gt;Hello.world/0&lt;/code&gt; 에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="501337e40a037ada414b45561640d40bc9bd67c7" translate="yes" xml:space="preserve">
          <source>Note that it is always possible to stop an application explicitly by calling &lt;a href=&quot;#stop/1&quot;&gt;&lt;code&gt;stop/1&lt;/code&gt;&lt;/a&gt;. Regardless of the type of the application, no other applications will be affected.</source>
          <target state="translated">&lt;a href=&quot;#stop/1&quot;&gt; &lt;code&gt;stop/1&lt;/code&gt; &lt;/a&gt; 을 호출하여 응용 프로그램을 명시 적으로 중지 할 수 있습니다 . 응용 프로그램 유형에 관계없이 다른 응용 프로그램에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff7bd5f130ea7db15204ea66bfeb9aa5a7e91245" translate="yes" xml:space="preserve">
          <source>Note that like the &lt;code&gt;alias&lt;/code&gt; directive, &lt;code&gt;require&lt;/code&gt; is also lexically scoped. We will talk more about macros in a later chapter.</source>
          <target state="translated">&lt;code&gt;alias&lt;/code&gt; 지시어 와 마찬가지로 &lt;code&gt;require&lt;/code&gt; 도 어휘 범위가 있습니다. 다음 장에서 매크로에 대해 더 이야기 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="609fc4219e4f54367072ec4d02e01c554eb9955f" translate="yes" xml:space="preserve">
          <source>Note that on many platforms, only the status codes 0-255 are supported by the operating system.</source>
          <target state="translated">많은 플랫폼에서 운영 체제는 상태 코드 0-255 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="058e024bfd4088c93bb70a9d4486efc9cfc43198" translate="yes" xml:space="preserve">
          <source>Note that only integers can be considered inside a range by &lt;code&gt;in&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 의 범위 내에서는 정수만 고려할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3610787e239696d5d39dc8faf6f13f31e98d9fd3" translate="yes" xml:space="preserve">
          <source>Note that passing a non-empty list as the &lt;code&gt;collectable&lt;/code&gt; is deprecated. If you're collecting into a non-empty keyword list, consider using &lt;a href=&quot;keyword#merge/2&quot;&gt;&lt;code&gt;Keyword.merge/2&lt;/code&gt;&lt;/a&gt;. If you're collecting into a non-empty list, consider something like &lt;code&gt;to_list(enumerable) ++ collectable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;collectable&lt;/code&gt; 항목으로 비어 있지 않은 목록을 전달하는 것은 더 이상 사용되지 않습니다. 비어 있지 않은 키워드 목록을 수집하는 경우 &lt;a href=&quot;keyword#merge/2&quot;&gt; &lt;code&gt;Keyword.merge/2&lt;/code&gt; &lt;/a&gt; 사용을 고려하십시오 . 비어 있지 않은 목록으로 수집하는 경우 &lt;code&gt;to_list(enumerable) ++ collectable&lt;/code&gt; 과 같은 것을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="66a707c89c7a375b67feac5256ea470e5723f333" translate="yes" xml:space="preserve">
          <source>Note that popping elements out of tuples is not possible and raises an error.</source>
          <target state="translated">튜플에서 요소를 터지는 것은 불가능하며 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dcdb0a0d3694177344abe742c5030d4133620456" translate="yes" xml:space="preserve">
          <source>Note that since the compiler also defines some additional metadata, there are a few reserved keys that will be ignored and warned if used. Currently these are: &lt;code&gt;:opaque&lt;/code&gt; and &lt;code&gt;:defaults&lt;/code&gt;.</source>
          <target state="translated">컴파일러는 일부 추가 메타 데이터도 정의하므로 사용시 무시되고 경고되는 몇 가지 예약 된 키가 있습니다. 현재는 : &lt;code&gt;:opaque&lt;/code&gt; 및 &lt;code&gt;:defaults&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3f7174f1e0891c9c315cf26472dfe8e8d467ed7d" translate="yes" xml:space="preserve">
          <source>Note that sometimes the same configuration option is mentioned in the documentation for different tasks; this is just because it's common for many tasks to read and use the same configuration option (for example, &lt;code&gt;:erlc_paths&lt;/code&gt; is used by &lt;a href=&quot;mix.tasks.compile.erlang&quot;&gt;&lt;code&gt;mix compile.erlang&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mix.tasks.compile.yecc&quot;&gt;&lt;code&gt;mix compile.yecc&lt;/code&gt;&lt;/a&gt;, and other tasks).</source>
          <target state="translated">다른 작업에 대한 설명서에서 동일한 구성 옵션이 언급되는 경우가 있습니다. 이는 많은 작업에서 동일한 구성 옵션을 읽고 사용하는 것이 일반적이기 때문입니다 (예 &lt;code&gt;:erlc_paths&lt;/code&gt; 는 &lt;a href=&quot;mix.tasks.compile.erlang&quot;&gt; &lt;code&gt;mix compile.erlang&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mix.tasks.compile.yecc&quot;&gt; &lt;code&gt;mix compile.yecc&lt;/code&gt; &lt;/a&gt; 및 기타 작업에서 사용됨 ).</target>
        </trans-unit>
        <trans-unit id="bb4e3794b5d058074ae9fb619182bee5deeb2d26" translate="yes" xml:space="preserve">
          <source>Note that stacktraces in Elixir are only available inside catch and rescue by using the &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt;&lt;code&gt;__STACKTRACE__/0&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="translated">Elixir의 스택 트레이스는 &lt;a href=&quot;kernel.specialforms#__STACKTRACE__/0&quot;&gt; &lt;code&gt;__STACKTRACE__/0&lt;/code&gt; &lt;/a&gt; 변수를 사용하여 캐치 및 구조 내에서만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="552be8eaba50f8b9cb5e15b8c46f2e1519134f1f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;inspect&quot;&gt;&lt;code&gt;Inspect&lt;/code&gt;&lt;/a&gt; protocol does not necessarily return a valid representation of an Elixir term. In such cases, the inspected result must start with &lt;code&gt;#&lt;/code&gt;. For example, inspecting a function will return:</source>
          <target state="translated">점을 유의 &lt;a href=&quot;inspect&quot;&gt; &lt;code&gt;Inspect&lt;/code&gt; &lt;/a&gt; 반드시 비약 용어의 올바른 표현을 반환하지 않습니다 프로토콜을. 이러한 경우 검사 결과는 &lt;code&gt;#&lt;/code&gt; 로 시작해야합니다 . 예를 들어 함수를 검사하면 다음이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a210d5a52a6f0f763cbec85671fca9f2120de279" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;start_link&lt;/code&gt; function starts a new process that runs the &lt;code&gt;loop/1&lt;/code&gt; function, starting with an empty map. The &lt;code&gt;loop/1&lt;/code&gt; (private) function then waits for messages and performs the appropriate action for each message. We made &lt;code&gt;loop/1&lt;/code&gt; private by using &lt;code&gt;defp&lt;/code&gt; instead of &lt;code&gt;def&lt;/code&gt;. In the case of a &lt;code&gt;:get&lt;/code&gt; message, it sends a message back to the caller and calls &lt;code&gt;loop/1&lt;/code&gt; again, to wait for a new message. While the &lt;code&gt;:put&lt;/code&gt; message actually invokes &lt;code&gt;loop/1&lt;/code&gt; with a new version of the map, with the given &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; stored.</source>
          <target state="translated">있습니다 &lt;code&gt;start_link&lt;/code&gt; 기능이 실행되는 새로운 프로세스를 시작 &lt;code&gt;loop/1&lt;/code&gt; 빈지도로 시작, 기능. 그런 다음 &lt;code&gt;loop/1&lt;/code&gt; (비공개) 기능은 메시지를 대기하고 각 메시지에 대해 적절한 조치를 수행합니다. &lt;code&gt;def&lt;/code&gt; 대신 &lt;code&gt;defp&lt;/code&gt; 를 사용하여 &lt;code&gt;loop/1&lt;/code&gt; 을 private 로 만들었습니다 . &lt;code&gt;:get&lt;/code&gt; 메시지 의 경우 호출자에게 메시지를 다시 보내고 &lt;code&gt;loop/1&lt;/code&gt; 을 다시 호출 하여 새 메시지를 기다립니다. 그동안 &lt;code&gt;:put&lt;/code&gt; 메시지가 실제로 호출 &lt;code&gt;loop/1&lt;/code&gt; 주어진와지도의 새 버전으로 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;value&lt;/code&gt; 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="d9f3b685f288df2ac141b75c4120d3ea4cba1aee" translate="yes" xml:space="preserve">
          <source>Note that the Erlang VM (and therefore this function) does not return the current stacktrace but rather the stacktrace of the latest exception. To retrieve the stacktrace of the current process, use &lt;code&gt;Process.info(self(), :current_stacktrace)&lt;/code&gt; instead.</source>
          <target state="translated">Erlang VM (및이 함수)은 현재 스택 추적을 반환하지 않고 최신 예외의 스택 추적을 반환합니다. 현재 프로세스의 스택 추적을 검색하려면 대신 &lt;code&gt;Process.info(self(), :current_stacktrace)&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="61118c7f53d4bda89916029a3a51c482ae9250a8" translate="yes" xml:space="preserve">
          <source>Note that the functions in &lt;code&gt;:digraph&lt;/code&gt; alter the graph structure in-place, this is possible because they are implemented as ETS tables, explained next.</source>
          <target state="translated">&lt;code&gt;:digraph&lt;/code&gt; 의 함수 는 그래프 구조를 제자리에서 변경 한다는 점에 유의하십시오. 이는 다음에 설명 할 ETS 테이블로 구현되기 때문에 가능합니다.</target>
        </trans-unit>
        <trans-unit id="642c83993efe9994a761915e7e921044f5f85c3c" translate="yes" xml:space="preserve">
          <source>Note that the purpose of the test is to check whether the registry processes the bucket&amp;rsquo;s shutdown message correctly. The fact that the &lt;code&gt;KV.Registry.lookup/2&lt;/code&gt; sends us a valid bucket does not mean that the bucket is still alive by the time you call it. For example, it might have crashed for some reason. The following test depicts this situation:</source>
          <target state="translated">테스트의 목적은 레지스트리가 버킷의 종료 메시지를 올바르게 처리하는지 확인하는 것입니다. 사실 &lt;code&gt;KV.Registry.lookup/2&lt;/code&gt; 는 우리에게 유효한 통을 보낸다는 버킷은 여전히 당신이 그것을 호출 시간까지 살아 있다는 것을 의미하지 않습니다. 예를 들어 어떤 이유로 추락했을 수 있습니다. 다음 테스트는이 상황을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="67d98e4f2d8bcb03260e0b9f2837377ff066ec7f" translate="yes" xml:space="preserve">
          <source>Note that the registry uses one ETS table plus two ETS tables per partition.</source>
          <target state="translated">레지스트리는 파티션 당 하나의 ETS 테이블과 두 개의 ETS 테이블을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ec636350f4f8e5f34aed230627c7cf0452577a12" translate="yes" xml:space="preserve">
          <source>Note that the spawned process is not linked to the caller, but only to the supervisor. This command is useful in case the task needs to perform side-effects (like I/O) and does not need to report back to the caller.</source>
          <target state="translated">생성 된 프로세스는 발신자와 연결되어 있지 않고 감독자에게만 연결됩니다. 이 명령은 작업이 부작용 (예 : I / O)을 수행해야하고 호출자에게 다시보고 할 필요가없는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="dd0116a55dff5f2bacdff852b6887f33db51d12e" translate="yes" xml:space="preserve">
          <source>Note that this applies only to the tuple itself, not its contents. For instance, when you update a tuple, all entries are shared between the old and the new tuple, except for the entry that has been replaced. In other words, tuples and lists in Elixir are capable of sharing their contents. This reduces the amount of memory allocation the language needs to perform and is only possible thanks to the immutable semantics of the language.</source>
          <target state="translated">이것은 내용이 아닌 튜플 자체에만 적용됩니다. 예를 들어, 튜플을 업데이트하면 교체 된 항목을 제외하고 모든 항목이 이전 튜플과 새 튜플간에 공유됩니다. 즉, Elixir의 튜플과 목록은 내용을 공유 할 수 있습니다. 이는 언어가 수행해야하는 메모리 할당량을 줄이고 언어의 불변의 의미론 덕분에 가능합니다.</target>
        </trans-unit>
        <trans-unit id="772fcfd84a5f9fd2ad0b735b0a19d01baa41c4ae" translate="yes" xml:space="preserve">
          <source>Note that this function does not load the module in case it is not loaded. Check &lt;a href=&quot;code#ensure_loaded/1&quot;&gt;&lt;code&gt;Code.ensure_loaded/1&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">이 기능은 모듈이로드되지 않은 경우 모듈을로드하지 않습니다. 확인 &lt;a href=&quot;code#ensure_loaded/1&quot;&gt; &lt;code&gt;Code.ensure_loaded/1&lt;/code&gt; &lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="3a93b64ce36dbd9e66bfd7a4794eac8913433ad9" translate="yes" xml:space="preserve">
          <source>Note that this function does not try to discover the file encoding basing on BOM.</source>
          <target state="translated">이 기능은 BOM을 기준으로 파일 인코딩을 감지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd7297e7a168339d862010e69cb4610a576f96e0" translate="yes" xml:space="preserve">
          <source>Note that this function treats a &lt;code&gt;path&lt;/code&gt; with a leading &lt;code&gt;~&lt;/code&gt; as an absolute one.</source>
          <target state="translated">이 함수는 앞에 &lt;code&gt;~&lt;/code&gt; 가 있는 &lt;code&gt;path&lt;/code&gt; 를 절대 경로 로 취급합니다 .</target>
        </trans-unit>
        <trans-unit id="1cfa9837195cf9c63349ac44a72cf8140752983a" translate="yes" xml:space="preserve">
          <source>Note that this not only works with single expressions but also with arbitrary code blocks.</source>
          <target state="translated">이것은 단일 표현식뿐만 아니라 임의의 코드 블록에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="14ce19a4da0f58dcf26e71e7c820a5ec0bbf379f" translate="yes" xml:space="preserve">
          <source>Note that those functions are polymorphic. They not only convert charlists to strings, but also integers to strings, atoms to strings, and so on.</source>
          <target state="translated">이러한 함수는 다형성입니다. 문자 목록을 문자열로 변환 할뿐만 아니라 정수를 문자열, 원자를 문자열 등으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="43c532218f4ed686a0d71d554c91a77ee3c049fb" translate="yes" xml:space="preserve">
          <source>Note that type checks that are not valid in guard clauses do not follow this convention. Examples: &lt;a href=&quot;keyword#keyword?/1&quot;&gt;&lt;code&gt;Keyword.keyword?/1&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;regex#regex?/1&quot;&gt;&lt;code&gt;Regex.regex?/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">guard 절에서 유효하지 않은 유형 검사는이 규칙을 따르지 않습니다. 예 : &lt;a href=&quot;keyword#keyword?/1&quot;&gt; &lt;code&gt;Keyword.keyword?/1&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;regex#regex?/1&quot;&gt; &lt;code&gt;Regex.regex?/1&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="174cbc748d572204ea1540b27cb5cc59e7b6deca" translate="yes" xml:space="preserve">
          <source>Note that values added to the front are the ones fetched on lookup:</source>
          <target state="translated">앞에 추가 된 값은 조회시 가져온 값입니다.</target>
        </trans-unit>
        <trans-unit id="7c321fccec9582dfce9477fe7768165a7a09b608" translate="yes" xml:space="preserve">
          <source>Note that we have also defined a private function named &lt;code&gt;lookup/2&lt;/code&gt; to help with the common functionality of looking up a bucket and returning its &lt;code&gt;pid&lt;/code&gt; if it exists, &lt;code&gt;{:error, :not_found}&lt;/code&gt; otherwise.</source>
          <target state="translated">또한 버킷을 찾고 &lt;code&gt;pid&lt;/code&gt; 가있는 경우 해당 pid를 반환하는 일반적인 기능 ( &lt;code&gt;{:error, :not_found}&lt;/code&gt; 을 돕기 위해 &lt;code&gt;lookup/2&lt;/code&gt; 라는 개인 함수도 정의했습니다 .</target>
        </trans-unit>
        <trans-unit id="9412a4887f881774fae5591b90049312660e64f3" translate="yes" xml:space="preserve">
          <source>Note that we need a mechanism to pass the &lt;code&gt;bucket&lt;/code&gt; pid from the callback to the test. We do so by using the &lt;em&gt;test context&lt;/em&gt;. When we return &lt;code&gt;%{bucket: bucket}&lt;/code&gt; from the callback, ExUnit will merge this map into the test context. Since the test context is a map itself, we can pattern match the bucket out of it, providing access to the bucket inside the test:</source>
          <target state="translated">콜백에서 테스트로 &lt;code&gt;bucket&lt;/code&gt; pid 를 전달하는 메커니즘이 필요합니다 . 우리는 &lt;em&gt;테스트 컨텍스트&lt;/em&gt; 를 사용하여 그렇게합니다 . 콜백에서 &lt;code&gt;%{bucket: bucket}&lt;/code&gt; 을 반환하면 ExUnit이이 맵을 테스트 컨텍스트에 병합합니다. 테스트 컨텍스트는 맵 자체이므로 버킷 내에서 버킷과 패턴을 일치시켜 테스트 내부의 버킷에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e819f2e65aae690b63c5af560e6444ef3c30ff3" translate="yes" xml:space="preserve">
          <source>Note that when creating this string representation, the &lt;code&gt;:authority&lt;/code&gt; value will be used if the &lt;code&gt;:host&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. Otherwise, the &lt;code&gt;:userinfo&lt;/code&gt;, &lt;code&gt;:host&lt;/code&gt;, and &lt;code&gt;:port&lt;/code&gt; will be used.</source>
          <target state="translated">이 문자열 표현을 작성할 때 &lt;code&gt;:host&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 인 경우 &lt;code&gt;:authority&lt;/code&gt; 값이 사용됩니다 . 그렇지 않으면 &lt;code&gt;:userinfo&lt;/code&gt; , &lt;code&gt;:host&lt;/code&gt; 및 &lt;code&gt;:port&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="059596cc4da0ec6ea079bfeb0987398e72e24193" translate="yes" xml:space="preserve">
          <source>Note that when keyword lists are passed as the last argument to a function, if the short-hand syntax is used then the square brackets around the keyword list can be omitted as well. For example, the following:</source>
          <target state="translated">키워드 목록이 함수에 대한 마지막 인수로 전달 될 때 짧은 구문을 사용하는 경우 키워드 목록 주위의 대괄호도 생략 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="51593dd72717840f7fb2a715f89be6d7c2e52241" translate="yes" xml:space="preserve">
          <source>Note that while ISO 8601 allows times and datetimes to specify 24:00:00 as the zero hour of the next day, this notation is not supported by Elixir.</source>
          <target state="translated">ISO 8601에서는 시간과 날짜 / 시간이 다음 날 0 시로 24:00:00을 지정할 수 있지만이 표기법은 Elixir에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10328798e18043813d96248d25cbd19fb081be9c" translate="yes" xml:space="preserve">
          <source>Note that while ISO 8601 allows times to specify 24:00:00 as the zero hour of the next day, this notation is not supported by Elixir. Leap seconds are not supported as well by the built-in Calendar.ISO.</source>
          <target state="translated">ISO 8601에서는 다음 날 0 시로 24:00:00을 지정할 수 있지만 Elixir에서는이 표기법을 지원하지 않습니다. 내장 된 Calendar.ISO에서는 윤초도 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="674d928e8930fc373a1ecef037a0add8d70944ab" translate="yes" xml:space="preserve">
          <source>Note that you should only supply the &lt;code&gt;:switches&lt;/code&gt; or the &lt;code&gt;:strict&lt;/code&gt; option. If you supply both, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception will be raised.</source>
          <target state="translated">&lt;code&gt;:switches&lt;/code&gt; 또는 &lt;code&gt;:strict&lt;/code&gt; 옵션 만 제공해야합니다 . 둘 다 제공하면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5618ec783469ef4c54ca8326a639f6727694278b" translate="yes" xml:space="preserve">
          <source>Note that, however, the struct fields are private and must not be accessed directly; use the functions in this module to perform operations on sets.</source>
          <target state="translated">그러나 struct 필드는 개인용이므로 직접 액세스하면 안됩니다. 이 모듈의 기능을 사용하여 세트에 대한 조작을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="43d19607ee0a232b2886e30e288770f0a0223896" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;a href=&quot;#and/2&quot;&gt;&lt;code&gt;and/2&lt;/code&gt;&lt;/a&gt;, this operator accepts any expression as the first argument, not only booleans.</source>
          <target state="translated">&lt;a href=&quot;#and/2&quot;&gt; &lt;code&gt;and/2&lt;/code&gt; &lt;/a&gt; 와 달리이 연산자는 부울뿐만 아니라 모든 표현식을 첫 번째 인수로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="904787334ac92370c9a9993f8474d839a9d2466c" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;a href=&quot;#or/2&quot;&gt;&lt;code&gt;or/2&lt;/code&gt;&lt;/a&gt;, this operator accepts any expression as the first argument, not only booleans.</source>
          <target state="translated">&lt;a href=&quot;#or/2&quot;&gt; &lt;code&gt;or/2&lt;/code&gt; &lt;/a&gt; 와 달리이 연산자는 부울뿐만 아니라 모든 표현식을 첫 번째 인수로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="08cd47820e470aeb0ed46fa6530b94a8d0d659ed" translate="yes" xml:space="preserve">
          <source>Note that, when working with distributed tasks, one should use the &lt;a href=&quot;task.supervisor#async/4&quot;&gt;&lt;code&gt;Task.Supervisor.async/4&lt;/code&gt;&lt;/a&gt; function that expects explicit module, function and arguments, instead of &lt;a href=&quot;task.supervisor#async/2&quot;&gt;&lt;code&gt;Task.Supervisor.async/2&lt;/code&gt;&lt;/a&gt; that works with anonymous functions. That's because anonymous functions expect the same module version to exist on all involved nodes. Check the &lt;a href=&quot;agent&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; module documentation for more information on distributed processes as the limitations described there apply to the whole ecosystem.</source>
          <target state="translated">분산 작업을 수행 할 때는 익명 함수와 함께 작동하는 &lt;a href=&quot;task.supervisor#async/2&quot;&gt; &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; &lt;/a&gt; 대신 명시 적 모듈, 함수 및 인수를 예상 하는 &lt;a href=&quot;task.supervisor#async/4&quot;&gt; &lt;code&gt;Task.Supervisor.async/4&lt;/code&gt; &lt;/a&gt; 함수를 사용해야합니다 . 익명 함수는 관련된 모든 노드에 동일한 모듈 버전이 존재할 것으로 예상하기 때문입니다. 설명 된 제한 사항이 전체 에코 시스템에 적용되는 분산 프로세스에 대한 자세한 정보 는 &lt;a href=&quot;agent&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; 모듈 문서를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="f98570973aa7e2132e68496b2b9ad6d68c9748d2" translate="yes" xml:space="preserve">
          <source>Note the &lt;code&gt;:deprecated&lt;/code&gt; key does not warn when a developer invokes the functions. If you want the code to also emit a warning, you can use the &lt;code&gt;@deprecated&lt;/code&gt; attribute:</source>
          <target state="translated">참고 &lt;code&gt;:deprecated&lt;/code&gt; 개발자가 기능을 호출 할 때 키가 경고하지 않습니다. 코드에서 경고를 발생 시키려면 &lt;code&gt;@deprecated&lt;/code&gt; 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbe12959616fed170330064dc85549503954ef06" translate="yes" xml:space="preserve">
          <source>Note the British spelling!</source>
          <target state="translated">영국 철자법에 주목하십시오!</target>
        </trans-unit>
        <trans-unit id="b1c5d08584d148be13f621a2c51eacad30bf0769" translate="yes" xml:space="preserve">
          <source>Note the behaviour of those classes may change according to the Unicode and other modifiers:</source>
          <target state="translated">이러한 클래스의 동작은 유니 코드 및 기타 수정 자에 따라 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79e188c7e768551ff604bcf40bceebdb7a51cda8" translate="yes" xml:space="preserve">
          <source>Note the capture syntax can also be used as a shortcut for creating functions:</source>
          <target state="translated">캡처 구문은 함수 작성을위한 바로 가기로 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc7df408c1b6e9e0aa62f81ee99961007e92e471" translate="yes" xml:space="preserve">
          <source>Note the convention in Elixir is to name functions/macros allowed in guards with the &lt;code&gt;is_&lt;/code&gt; prefix, such as &lt;a href=&quot;#is_list/1&quot;&gt;&lt;code&gt;is_list/1&lt;/code&gt;&lt;/a&gt;. If, however, the function/macro returns a boolean and is not allowed in guards, it should have no prefix and end with a question mark, such as &lt;a href=&quot;keyword#keyword?/1&quot;&gt;&lt;code&gt;Keyword.keyword?/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir의 규칙은 &lt;a href=&quot;#is_list/1&quot;&gt; &lt;code&gt;is_list/1&lt;/code&gt; &lt;/a&gt; 과 같이 &lt;code&gt;is_&lt;/code&gt; 접두어 로 가드에서 허용되는 함수 / 매크로 이름을 지정하는 것 입니다. 그러나 함수 / 매크로가 부울을 반환하고 가드에서 허용되지 않는 경우 접두사가 없어야하며 &lt;a href=&quot;keyword#keyword?/1&quot;&gt; &lt;code&gt;Keyword.keyword?/1&lt;/code&gt; &lt;/a&gt; 과 같은 물음표로 끝나야 합니다.</target>
        </trans-unit>
        <trans-unit id="02e568f28639d3d3cf9153ba1f47b6ffc7ed4a33" translate="yes" xml:space="preserve">
          <source>Note the environment is not returned as it can be accessed via &lt;a href=&quot;#fetch_env/2&quot;&gt;&lt;code&gt;fetch_env/2&lt;/code&gt;&lt;/a&gt;. Returns &lt;code&gt;nil&lt;/code&gt; if the application is not loaded.</source>
          <target state="translated">환경은 &lt;a href=&quot;#fetch_env/2&quot;&gt; &lt;code&gt;fetch_env/2&lt;/code&gt; &lt;/a&gt; 를 통해 액세스 할 수 있으므로 리턴되지 않습니다 . 응용 프로그램이로드되지 않은 경우 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8291debf84c93cf7420e870a4723eb8919b7abde" translate="yes" xml:space="preserve">
          <source>Note the file is deleted even if in read-only mode.</source>
          <target state="translated">읽기 전용 모드 인 경우에도 파일이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="20b9a7e0e7cfbc515eb86ff67eaa5244b2827ea0" translate="yes" xml:space="preserve">
          <source>Note the functions in this module are guaranteed to return enumerables. Since enumerables can have different shapes (structs, anonymous functions, and so on), the functions in this module may return any of those shapes and this may change at any time. For example, a function that today returns an anonymous function may return a struct in future releases.</source>
          <target state="translated">이 모듈의 함수는 열거 형을 반환하도록 보장됩니다. 열거 형은 다른 모양 (구조, 익명 함수 등)을 가질 수 있으므로이 모듈의 함수는 해당 모양을 반환 할 수 있으며 언제든지 변경 될 수 있습니다. 예를 들어, 오늘 익명 함수를 반환하는 함수는 다음 릴리스에서 구조체를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d438d99970ff0575f83b52d72a57ff8778a28621" translate="yes" xml:space="preserve">
          <source>Note the hook receives the quoted arguments and it is invoked before the function is stored in the module. So &lt;a href=&quot;module#defines?/2&quot;&gt;&lt;code&gt;Module.defines?/2&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;false&lt;/code&gt; for the first clause of every function.</source>
          <target state="translated">후크는 인용 된 인수를 수신하며 함수가 모듈에 저장되기 전에 호출됩니다. 따라서 &lt;a href=&quot;module#defines?/2&quot;&gt; &lt;code&gt;Module.defines?/2&lt;/code&gt; &lt;/a&gt; 는 모든 함수의 첫 번째 절에 대해 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="8fc73248c724a3a7729fc783a9f3f7c1f0c33c3b" translate="yes" xml:space="preserve">
          <source>Note the module remains &quot;instrumented&quot; on reset. If you would like to effectively remove all breakpoints and instrumentation code from a module, use &lt;a href=&quot;#remove_breaks/1&quot;&gt;&lt;code&gt;remove_breaks/1&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">재설정시 모듈은 &quot;계기 화 된&quot;상태로 유지됩니다. 모듈에서 모든 중단 점 및 계측 코드를 효과적으로 제거하려면 대신 &lt;a href=&quot;#remove_breaks/1&quot;&gt; &lt;code&gt;remove_breaks/1&lt;/code&gt; 을&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="db9c44355a667468b5a8a0fc6d5bc95bf927d9a1" translate="yes" xml:space="preserve">
          <source>Note the result value represents the time of day, meaning that it is cyclic, for instance, it will never go over 24 hours for the ISO calendar.</source>
          <target state="translated">결과 값은 하루 중 시간을 나타냅니다. 예를 들어 ISO 일정의 경우 24 시간을 넘지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bcdf2418808bb9ad9b914fb25ca7111d444ec598" translate="yes" xml:space="preserve">
          <source>Note the year, month, day, etc. designations are overspecified (i.e. an integer instead of &lt;code&gt;1..12&lt;/code&gt; for months) because different calendars may have a different number of days per month, months per year and so on.</source>
          <target state="translated">연도, 월, 일 등의 지정은 월별로 일 수, 연도 등이 다를 수 있기 때문에 &lt;code&gt;1..12&lt;/code&gt; 지정되었습니다 (즉, 월의 경우 1..12 대신 정수 ).</target>
        </trans-unit>
        <trans-unit id="3ccd699f8c48bd34a5a8a8648d6828c7250f9900" translate="yes" xml:space="preserve">
          <source>Note this configuration is cached once the project is pushed onto the stack. Calling it multiple times won't cause it to be recomputed.</source>
          <target state="translated">이 구성은 프로젝트가 스택으로 푸시되면 캐시됩니다. 여러 번 호출해도 다시 계산되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d029ff8336c9288d7f18814c831f1d16b88a78a" translate="yes" xml:space="preserve">
          <source>Note this function does not traverse the AST, only the root node is expanded.</source>
          <target state="translated">이 기능은 AST를 통과하지 않으며 루트 노드 만 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="3f1cee9305c51b1d0d2373452f46efc36d69c692" translate="yes" xml:space="preserve">
          <source>Note this function expects a well-formed URI and does not perform any validation. See the &quot;Examples&quot; section below for examples of how &lt;a href=&quot;uri#parse/1&quot;&gt;&lt;code&gt;URI.parse/1&lt;/code&gt;&lt;/a&gt; can be used to parse a wide range of URIs.</source>
          <target state="translated">이 함수는 올바른 형식의 URI를 예상하며 유효성 검사를 수행하지 않습니다. &lt;a href=&quot;uri#parse/1&quot;&gt; &lt;code&gt;URI.parse/1&lt;/code&gt; &lt;/a&gt; 을 사용하여 광범위한 URI를 구문 분석하는 방법에 대한 예는 아래의 &quot;예&quot;섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6f74ff98cf77b2a5593760e563d32600a4851c6" translate="yes" xml:space="preserve">
          <source>Note this function requires the task supervisor to have &lt;code&gt;:temporary&lt;/code&gt; as the &lt;code&gt;:restart&lt;/code&gt; option (the default), as &lt;a href=&quot;#async_nolink/4&quot;&gt;&lt;code&gt;async_nolink/4&lt;/code&gt;&lt;/a&gt; keeps a direct reference to the task which is lost if the task is restarted.</source>
          <target state="translated">이 기능을 가지고 작업 관리자를 필요로합니다 &lt;code&gt;:temporary&lt;/code&gt; 는 AS &lt;code&gt;:restart&lt;/code&gt; 으로 옵션 (기본값) &lt;a href=&quot;#async_nolink/4&quot;&gt; &lt;code&gt;async_nolink/4&lt;/code&gt; &lt;/a&gt; 작업이 다시 시작되면 손실 된 작업에 대한 직접 참조를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="aa4a640e0a030948b5a35ad9f1605a103aa1b3ef" translate="yes" xml:space="preserve">
          <source>Note we removed &lt;code&gt;async: true&lt;/code&gt; from &lt;code&gt;use ExUnit.Case&lt;/code&gt;. Since the application environment is a global storage, tests that modify it cannot run concurrently. With all changes in place, all tests should pass, including the distributed one.</source>
          <target state="translated">&lt;code&gt;use ExUnit.Case&lt;/code&gt; 에서 &lt;code&gt;async: true&lt;/code&gt; 를 제거 했습니다 . 애플리케이션 환경은 글로벌 스토리지이므로이를 수정하는 테스트는 동시에 실행할 수 없습니다. 모든 변경 사항이 적용되면 배포 된 테스트를 포함하여 모든 테스트를 통과해야합니다.</target>
        </trans-unit>
        <trans-unit id="eac2c1b3b01e930084b33fb0d5edbf4e23375457" translate="yes" xml:space="preserve">
          <source>Note you can also start it simply as &lt;code&gt;Stack&lt;/code&gt;, which is the same as &lt;code&gt;{Stack, []}&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;{Stack, []}&lt;/code&gt; 과 동일한 &lt;code&gt;Stack&lt;/code&gt; 으로 간단히 시작할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="002eb13193e06aa56b8ea00565416925c92cd1a9" translate="yes" xml:space="preserve">
          <source>Note you don&amp;rsquo;t need to define a behaviour in order to dynamically dispatch on a module, but those features often go hand in hand.</source>
          <target state="translated">모듈에서 동적으로 디스패치하기 위해 동작을 정의 할 필요는 없지만 이러한 기능은 종종 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ccaa9177febc5965f3a6e9991d73e149b8c2b3d0" translate="yes" xml:space="preserve">
          <source>Note: All modules defined in Elixir are defined inside the main &lt;code&gt;Elixir&lt;/code&gt; namespace. However, for convenience, you can omit &amp;ldquo;Elixir.&amp;rdquo; when referencing them.</source>
          <target state="translated">참고 : Elixir에 정의 된 모든 모듈은 기본 &lt;code&gt;Elixir&lt;/code&gt; 네임 스페이스 내에 정의됩니다 . 그러나 편의상&amp;ldquo;Elixir&amp;rdquo;를 생략 할 수 있습니다. 그들을 참조 할 때.</target>
        </trans-unit>
        <trans-unit id="f9375188837fda1326cbb4f55c2eddcde5896357" translate="yes" xml:space="preserve">
          <source>Note: An interesting note regarding &lt;code&gt;if/2&lt;/code&gt; and &lt;code&gt;unless/2&lt;/code&gt; is that they are implemented as macros in the language; they aren&amp;rsquo;t special language constructs as they would be in many languages. You can check the documentation and the source of &lt;code&gt;if/2&lt;/code&gt; in &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt;the &lt;code&gt;Kernel&lt;/code&gt; module docs&lt;/a&gt;. The &lt;code&gt;Kernel&lt;/code&gt; module is also where operators like &lt;code&gt;+/2&lt;/code&gt; and functions like &lt;code&gt;is_function/2&lt;/code&gt; are defined, all automatically imported and available in your code by default.</source>
          <target state="translated">참고 : &lt;code&gt;if/2&lt;/code&gt; 및 &lt;code&gt;unless/2&lt;/code&gt; 에 관한 흥미로운 참고 사항 은 언어에서 매크로로 구현된다는 것입니다. 그들은 많은 언어에서와 같이 특별한 언어 구조가 아닙니다. 당신은 문서 및 소스 확인할 수 &lt;code&gt;if/2&lt;/code&gt; 에서 &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.html&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 모듈 문서를 . &lt;code&gt;Kernel&lt;/code&gt; 모듈은 또한 어디 사업자와 같은 &lt;code&gt;+/2&lt;/code&gt; 와 같은 기능 &lt;code&gt;is_function/2&lt;/code&gt; 정의, 모든 자동으로 가져 기본적으로 코드에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="333c3af19d66fc17e99fc5af70f1d710e9bfc88f" translate="yes" xml:space="preserve">
          <source>Note: If &lt;code&gt;observer&lt;/code&gt; does not start, here is what may have happened: some package managers default to installing a minimized Erlang without WX bindings for GUI support. In some package managers, you may be able to replace the headless Erlang with a more complete package (look for packages named &lt;code&gt;erlang&lt;/code&gt; vs &lt;code&gt;erlang-nox&lt;/code&gt; on Debian/Ubuntu/Arch). In others managers, you may need to install a separate &lt;code&gt;erlang-wx&lt;/code&gt; (or similarly named) package. Alternatively, you can skip this section and continue the guide.</source>
          <target state="translated">참고 : &lt;code&gt;observer&lt;/code&gt; 가 시작되지 않으면 다음과 같은 상황이 발생할 수 있습니다. 일부 패키지 관리자는 기본적으로 GUI 지원을 위해 WX 바인딩없이 최소화 된 Erlang을 설치합니다. 일부 패키지 관리자에서는 헤드리스 Erlang을보다 완전한 패키지로 교체 할 수 있습니다 ( Debian / Ubuntu / Arch에서 &lt;code&gt;erlang&lt;/code&gt; vs &lt;code&gt;erlang-nox&lt;/code&gt; 라는 패키지를 찾으십시오 ). 다른 관리자의 경우 별도의 &lt;code&gt;erlang-wx&lt;/code&gt; (또는 비슷한 이름의) 패키지 를 설치해야 할 수 있습니다 . 또는이 섹션을 건너 뛰고 가이드를 계속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d918daa7b1094720a58030ddd5f21024965cb9a" translate="yes" xml:space="preserve">
          <source>Note: If you are an Erlang developer, &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; in Elixir actually map to the &lt;code&gt;andalso&lt;/code&gt; and &lt;code&gt;orelse&lt;/code&gt; operators in Erlang.</source>
          <target state="translated">참고 :이 얼랑 개발자, 경우 &lt;code&gt;and&lt;/code&gt; 및 &lt;code&gt;or&lt;/code&gt; 비약에 실제로 매핑 &lt;code&gt;andalso&lt;/code&gt; 및 &lt;code&gt;orelse&lt;/code&gt; 얼랑 연산자.</target>
        </trans-unit>
        <trans-unit id="ff9e17f09f7587478a4a85a5f5ba16eb3160272e" translate="yes" xml:space="preserve">
          <source>Note: Maps were recently introduced into the Erlang</source>
          <target state="translated">참고 :지도는 최근 Erlang에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="96f2bbaf73f21c5d620e6ce00661ef3a7f853b26" translate="yes" xml:space="preserve">
          <source>Note: Mix is an Elixir executable. This means that in order to run &lt;code&gt;mix&lt;/code&gt;, you need to have both &lt;code&gt;mix&lt;/code&gt; and &lt;code&gt;elixir&lt;/code&gt; executables in your PATH. That&amp;rsquo;s what happens when you install Elixir.</source>
          <target state="translated">참고 : Mix는 Elixir 실행 파일입니다. 즉 , &lt;code&gt;mix&lt;/code&gt; 를 실행하려면 PATH에 &lt;code&gt;mix&lt;/code&gt; 및 &lt;code&gt;elixir&lt;/code&gt; 실행 파일 이 모두 있어야합니다 . 이것이 Elixir를 설치할 때 일어나는 일입니다.</target>
        </trans-unit>
        <trans-unit id="ccb589e6f497a521acf64f009eba87d24abf9844" translate="yes" xml:space="preserve">
          <source>Note: Since file times are stored in POSIX time format on most operating systems, it is faster to retrieve file information with the &lt;code&gt;time: :posix&lt;/code&gt; option.</source>
          <target state="translated">참고 : 파일 시간은 대부분의 운영 체제에서 POSIX 시간 형식으로 저장되므로 &lt;code&gt;time: :posix&lt;/code&gt; 옵션을 사용하여 파일 정보를 검색하는 것이 더 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="85c13b1aace1377737ca0a9ef86cd79955430879" translate="yes" xml:space="preserve">
          <source>Note: The command &lt;code&gt;cp&lt;/code&gt; in Unix systems behaves differently depending on whether &lt;code&gt;destination&lt;/code&gt; is an existing directory or not. We have chosen to explicitly disallow this behaviour. If &lt;code&gt;source&lt;/code&gt; is a &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; is a directory, &lt;code&gt;{:error, :eisdir}&lt;/code&gt; will be returned.</source>
          <target state="translated">참고 : Unix 시스템에서 &lt;code&gt;cp&lt;/code&gt; 명령 은 &lt;code&gt;destination&lt;/code&gt; 이 기존 디렉토리 인지 여부에 따라 다르게 작동합니다 . 우리는이 행동을 명시 적으로 허용하지 않기로 결정했습니다. 경우 &lt;code&gt;source&lt;/code&gt; A는 &lt;code&gt;file&lt;/code&gt; 및 &lt;code&gt;destination&lt;/code&gt; 디렉토리입니다 &lt;code&gt;{:error, :eisdir}&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="587e5cfb89d0a03b03528404235c890650244b41" translate="yes" xml:space="preserve">
          <source>Note: The command &lt;code&gt;cp&lt;/code&gt; in Unix systems behaves differently depending on whether the destination is an existing directory or not. We have chosen to explicitly disallow copying to a destination which is a directory, and an error will be returned if tried.</source>
          <target state="translated">참고 : Unix 시스템에서 &lt;code&gt;cp&lt;/code&gt; 명령 은 대상이 기존 디렉토리인지 여부에 따라 다르게 작동합니다. 디렉토리 인 대상으로의 복사를 명시 적으로 허용하지 않기로 선택했으며 시도하면 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2412c082ee9452e0961827f93fc820b4560394ce" translate="yes" xml:space="preserve">
          <source>Note: The command &lt;code&gt;mv&lt;/code&gt; in Unix systems behaves differently depending on whether &lt;code&gt;source&lt;/code&gt; is a file and the &lt;code&gt;destination&lt;/code&gt; is an existing directory. We have chosen to explicitly disallow this behaviour.</source>
          <target state="translated">참고 : Unix 시스템에서 &lt;code&gt;mv&lt;/code&gt; 명령 은 &lt;code&gt;source&lt;/code&gt; 가 파일 인지 &lt;code&gt;destination&lt;/code&gt; 이 기존 디렉토리 인지에 따라 다르게 작동합니다 . 우리는이 행동을 명시 적으로 허용하지 않기로 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="318ba01affa2cb83a445a4ffd6d8bf1dd6eb9f01" translate="yes" xml:space="preserve">
          <source>Note: Unlike Erlang, user defined attributes are not stored in the module by default. The value exists only during compilation time. A developer can configure an attribute to behave closer to Erlang by calling &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt;&lt;code&gt;Module.register_attribute/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 : Erlang과 달리 사용자 정의 속성은 기본적으로 모듈에 저장되지 않습니다. 이 값은 컴파일 시간 동안 만 존재합니다. 개발자는 &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html#register_attribute/3&quot;&gt; &lt;code&gt;Module.register_attribute/3&lt;/code&gt; &lt;/a&gt; 를 호출하여 속성이 Erlang에 더 가깝게 동작하도록 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6501e4eb8325e3aa1733c1d78f4786f805cb16e" translate="yes" xml:space="preserve">
          <source>Note: do not use this function on IO devices in Unicode mode as it will return the wrong result.</source>
          <target state="translated">참고 : 유니 코드 모드의 IO 장치에서는이 기능을 사용하지 마십시오. 잘못된 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="767ed77ecda9bec0c064d33f222982b4d00c82a3" translate="yes" xml:space="preserve">
          <source>Note: escripts do not support projects and dependencies that need to store or read artifacts from the priv directory.</source>
          <target state="translated">참고 : escript는 priv 디렉토리에서 아티팩트를 저장하거나 읽어야하는 프로젝트 및 종속성을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc1575464df3ee39226b1eec5b01c029bb5c0bef" translate="yes" xml:space="preserve">
          <source>Note: if you are on Windows, you can also try &lt;code&gt;iex.bat --werl&lt;/code&gt; which may provide a better experience depending on which console you are using.</source>
          <target state="translated">참고 : Windows 를 사용하는 경우 사용중인 콘솔에 따라 더 나은 환경을 제공 할 수있는 &lt;code&gt;iex.bat --werl&lt;/code&gt; 을 시도 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="912e5c0c98d6ca0f341e5fc328517d2b1fabbcad" translate="yes" xml:space="preserve">
          <source>Note: if you are running on Windows, there is a chance your terminal does not use UTF-8 by default. You can change the encoding of your current session by running &lt;code&gt;chcp 65001&lt;/code&gt; before entering &lt;code&gt;iex&lt;/code&gt; (&lt;code&gt;iex.bat&lt;/code&gt;).</source>
          <target state="translated">참고 : Windows에서 실행중인 경우 터미널에서 기본적으로 UTF-8을 사용하지 않을 수 있습니다. &lt;code&gt;iex&lt;/code&gt; ( &lt;code&gt;iex.bat&lt;/code&gt; )를 &lt;code&gt;chcp 65001&lt;/code&gt; 하기 전에 chcp 65001 을 실행하여 현재 세션의 인코딩을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4dbeaf674e0eb7ea6925af7a2318ed6c85002a1" translate="yes" xml:space="preserve">
          <source>Note: if you are running on Windows, there is a chance your terminal does not use UTF-8 by default. You can change the encoding of your current session by running &lt;code&gt;chcp 65001&lt;/code&gt; before entering IEx.</source>
          <target state="translated">참고 : Windows에서 실행중인 경우 터미널에서 기본적으로 UTF-8을 사용하지 않을 수 있습니다. IEx를 시작하기 전에 &lt;code&gt;chcp 65001&lt;/code&gt; 을 실행하여 현재 세션의 인코딩을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e6389ccfd4efe5ada7d55d154db6d0a4d03109a" translate="yes" xml:space="preserve">
          <source>Note: if you set this to &lt;code&gt;false&lt;/code&gt; for an Elixir project, you will have to add paths to Elixir's &lt;code&gt;ebin&lt;/code&gt; directories to &lt;code&gt;ERL_LIBS&lt;/code&gt; environment variable when running the resulting escript, in order for the code loader to be able to find &lt;code&gt;:elixir&lt;/code&gt; application and its children applications (if they are used).</source>
          <target state="translated">참고 : Elixir 프로젝트에 대해이 값을 &lt;code&gt;false&lt;/code&gt; 로 설정 하면 코드 로더가 &lt;code&gt;:elixir&lt;/code&gt; 응용 프로그램 및 해당 하위 를 찾을 수 있도록 결과 escript를 실행할 때 Elixir의 &lt;code&gt;ebin&lt;/code&gt; 디렉토리에 대한 경로 를 &lt;code&gt;ERL_LIBS&lt;/code&gt; 환경 변수 에 추가해야합니다 . 응용 프로그램 (사용 된 경우).</target>
        </trans-unit>
        <trans-unit id="8ccad6d1cb0c1e92a31e2fb1270a6789b9c4f735" translate="yes" xml:space="preserve">
          <source>Note: if you want to find and execute a given script in PATH so it will be loaded in &lt;code&gt;iex&lt;/code&gt; use: &lt;code&gt;iex -S SCRIPTNAME&lt;/code&gt;. Later you&amp;rsquo;ll learn about &lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix&lt;/a&gt;, Elixir&amp;rsquo;s build tool, and how you can compile and load entire applications with &lt;code&gt;iex -S mix run&lt;/code&gt;. See &lt;a href=&quot;mix-otp/supervisor-and-application&quot;&gt;Supervisor and application&lt;/a&gt; for more details.</source>
          <target state="translated">참고 : PATH에서 지정된 스크립트를 찾아서 실행하려면 &lt;code&gt;iex&lt;/code&gt; 에서로드 합니다 : &lt;code&gt;iex -S SCRIPTNAME&lt;/code&gt; . 나중에 Elixir의 빌드 도구 인 &lt;a href=&quot;mix-otp/introduction-to-mix&quot;&gt;Mix에&lt;/a&gt; 대해 배우고 &lt;code&gt;iex -S mix run&lt;/code&gt; 으로 전체 애플리케이션을 컴파일하고로드하는 방법에 대해 알아 봅니다 . 자세한 내용은 &lt;a href=&quot;mix-otp/supervisor-and-application&quot;&gt;감독자 및 응용 프로그램&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2a2b2736d0228ed219724e9f93f70ec1ac8cd179" translate="yes" xml:space="preserve">
          <source>Note: keep in mind this function splits on graphemes and for such it has to linearly traverse the string. If you want to split a string or a binary based on the number of bytes, use &lt;a href=&quot;kernel#binary_part/3&quot;&gt;&lt;code&gt;Kernel.binary_part/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">참고 :이 함수는 graphemes에서 분할되므로 문자열을 선형으로 통과해야합니다. 바이트 수에 따라 문자열 또는 이진을 분할하려면 대신 &lt;a href=&quot;kernel#binary_part/3&quot;&gt; &lt;code&gt;Kernel.binary_part/3&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="57e11fb647c860e43cb9b2c5f6c254e9e56dfddb" translate="yes" xml:space="preserve">
          <source>Note: the Debugger snippet above was retrieved from &lt;a href=&quot;http://blog.plataformatec.com.br/2016/04/debugging-techniques-in-elixir-lang/&quot;&gt;&amp;ldquo;Debugging techniques in Elixir&amp;rdquo; by Plataformatec&lt;/a&gt;.</source>
          <target state="translated">참고 : 위의 디버거 스 니펫은 &lt;a href=&quot;http://blog.plataformatec.com.br/2016/04/debugging-techniques-in-elixir-lang/&quot;&gt;Plataformatec의&amp;ldquo;Ellixir의 디버깅 기술&amp;rdquo;&lt;/a&gt; 에서 검색되었습니다 .</target>
        </trans-unit>
        <trans-unit id="92f2e22007c90b9cbb55bb29dc07138d25f25b5c" translate="yes" xml:space="preserve">
          <source>Note: this function is similar to &lt;a href=&quot;enum#flat_map_reduce/3&quot;&gt;&lt;code&gt;Enum.flat_map_reduce/3&lt;/code&gt;&lt;/a&gt; except the latter returns both the flat list and accumulator, while this one returns only the stream.</source>
          <target state="translated">참고 :이 함수는 &lt;a href=&quot;enum#flat_map_reduce/3&quot;&gt; &lt;code&gt;Enum.flat_map_reduce/3&lt;/code&gt; &lt;/a&gt; 와 유사하지만 후자는 플랫 목록과 누산기를 모두 반환 하지만이 함수는 스트림 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1838e9e0c7c7ddb2da84c8c70085cf8301982628" translate="yes" xml:space="preserve">
          <source>Note: we will be using two nodes in the same machine throughout this chapter. You are free to use two (or more) different machines on the same network but you need to do some prep work. First of all, you need to ensure all machines have a &lt;code&gt;~/.erlang.cookie&lt;/code&gt; file with exactly the same value. Second, you need to guarantee &lt;a href=&quot;http://www.erlang.org/doc/man/epmd.html&quot;&gt;epmd&lt;/a&gt; is running on a port that is not blocked (you can run &lt;code&gt;epmd -d&lt;/code&gt; for debug info). Third, if you want to learn more about distribution in general, we recommend &lt;a href=&quot;http://learnyousomeerlang.com/distribunomicon&quot;&gt;this great Distribunomicon chapter from Learn You Some Erlang&lt;/a&gt;.</source>
          <target state="translated">참고 :이 장 전체에서 동일한 시스템에서 두 개의 노드를 사용합니다. 동일한 네트워크에서 두 대 이상의 다른 컴퓨터를 자유롭게 사용할 수 있지만 준비 작업을 수행해야합니다. 우선, 모든 머신에 &lt;code&gt;~/.erlang.cookie&lt;/code&gt; 파일이 정확히 동일한 값을 가지고 있는지 확인해야 합니다. 둘째, 차단되지 않은 포트에서 &lt;a href=&quot;http://www.erlang.org/doc/man/epmd.html&quot;&gt;epmd&lt;/a&gt; 가 실행되고 있는지 확인 해야합니다 ( 디버그 정보에 대해 &lt;code&gt;epmd -d&lt;/code&gt; 를 실행할 수 있음 ). 셋째, 일반적인 배포에 대해 더 배우고 싶다면 &lt;a href=&quot;http://learnyousomeerlang.com/distribunomicon&quot;&gt;Learn Your Some Erlang의 Distribunomicon 장을&lt;/a&gt; 추천 합니다 .</target>
        </trans-unit>
        <trans-unit id="9a1f1223d3d0c72df45c1e2b35a2ccf27e67399b" translate="yes" xml:space="preserve">
          <source>Note: you will likely get different process identifiers than the ones we are getting in this guide.</source>
          <target state="translated">참고 :이 안내서에서 제공하는 것과 다른 프로세스 식별자를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e501dc317df6513b552e6ef09f3d93b0d31cfc45" translate="yes" xml:space="preserve">
          <source>Nothing really exciting happens but it shows how we can control our application.</source>
          <target state="translated">실제로 흥미로운 것은 없지만 애플리케이션을 제어 할 수있는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="3f9f6ccaa3929763f1f8329a0cf42d1567c947e3" translate="yes" xml:space="preserve">
          <source>Notice &lt;code&gt;spawn/1&lt;/code&gt; returns a PID (process identifier). At this point, the process you spawned is very likely dead. The spawned process will execute the given function and exit after the function is done:</source>
          <target state="translated">통지 &lt;code&gt;spawn/1&lt;/code&gt; 은 PID (프로세스 식별자)를 반환합니다. 이 시점에서 스폰 된 프로세스가 죽었을 가능성이 큽니다. 스폰 된 프로세스는 주어진 함수를 실행하고 함수가 완료된 후 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="28bdc086982ce6f35c77fe8c28e2ce539fb72e7b" translate="yes" xml:space="preserve">
          <source>Notice doctests have limitations. When you cannot doctest a function, because it relies on state or side-effects, we recommend developers include examples directly without the &lt;code&gt;iex&amp;gt;&lt;/code&gt; prompt.</source>
          <target state="translated">doctest에는 제한이 있습니다. 상태 또는 부작용에 의존하기 때문에 함수를 doctest 할 수없는 경우 개발자는 &lt;code&gt;iex&amp;gt;&lt;/code&gt; 프롬프트 없이 직접 예제를 포함하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a8b421e9b5a288fb270e5d94ac8ec254970e093c" translate="yes" xml:space="preserve">
          <source>Notice how &quot;Returning 5&quot; was printed twice, instead of just once. This is because a macro receives an expression and not a value (which is what we would expect in a regular function). This means that:</source>
          <target state="translated">&quot;Returning 5&quot;가 한 번이 아닌 두 번 인쇄되는 방식에 주목하십시오. 매크로는 값이 아닌 표현식을 수신하기 때문입니다 (정규 함수에서 예상되는 값임). 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3892c7952171348da3fa8fc4e90871b3d046b9b8" translate="yes" xml:space="preserve">
          <source>Notice how &lt;code&gt;Hygiene.return_length/0&lt;/code&gt; returns &lt;code&gt;3&lt;/code&gt; even though the &lt;a href=&quot;kernel#length/1&quot;&gt;&lt;code&gt;Kernel.length/1&lt;/code&gt;&lt;/a&gt; function is not imported. In fact, even if &lt;code&gt;return_length/0&lt;/code&gt; imported a function with the same name and arity from another module, it wouldn't affect the function result:</source>
          <target state="translated">방법 공지 사항 &lt;code&gt;Hygiene.return_length/0&lt;/code&gt; 수익률 &lt;code&gt;3&lt;/code&gt; 짝수 불구하고 &lt;a href=&quot;kernel#length/1&quot;&gt; &lt;code&gt;Kernel.length/1&lt;/code&gt; &lt;/a&gt; 기능을 가져 오지 않습니다. 사실, &lt;code&gt;return_length/0&lt;/code&gt; 이 다른 모듈에서 동일한 이름과 arity를 ​​가진 함수를 가져 왔어 도 함수 결과에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86cf6571366da66046772448d17be71c9b8bac4d" translate="yes" xml:space="preserve">
          <source>Notice how the example above has a comma between &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;do:&lt;/code&gt;, that&amp;rsquo;s because it is using Elixir&amp;rsquo;s regular syntax where each argument is separated by a comma. We say this syntax is using &lt;em&gt;keyword lists&lt;/em&gt;. We can pass &lt;code&gt;else&lt;/code&gt; using keywords too:</source>
          <target state="translated">위 예제에서 &lt;code&gt;true&lt;/code&gt; 와 &lt;code&gt;do:&lt;/code&gt; 사이에 쉼표가있는 방법에 주목하십시오 . 이는 각 인수가 쉼표로 구분되는 Elixir의 정규 구문을 사용하기 때문입니다. 이 구문은 &lt;em&gt;키워드 목록을&lt;/em&gt; 사용한다고 &lt;em&gt;합니다&lt;/em&gt; . 키워드를 사용하여 &lt;code&gt;else&lt;/code&gt; 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="089ef5aec5dcab204a4dde60fdae6b22199f9d60" translate="yes" xml:space="preserve">
          <source>Notice how the process is keeping a state and we can get and update this state by sending the process messages. In fact, any process that knows the &lt;code&gt;pid&lt;/code&gt; above will be able to send it messages and manipulate the state.</source>
          <target state="translated">프로세스가 어떻게 상태를 유지하는지 확인하고 프로세스 메시지를 보내서이 상태를 가져오고 업데이트 할 수 있습니다. 사실, 위 의 &lt;code&gt;pid&lt;/code&gt; 를 알고있는 모든 프로세스는 메시지를 보내고 상태를 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68d3a08b640aa9ec43f4df6e72697d747babcab8" translate="yes" xml:space="preserve">
          <source>Notice how the supervisor automatically started a new registry, with a new PID, in place of the first one once we caused it to crash due to a bad input.</source>
          <target state="translated">잘못된 입력으로 인해 충돌이 발생하면 수퍼바이저가 처음으로 PID 대신 새 레지스트리를 사용하여 새 레지스트리를 자동으로 시작한 방법에 주목하십시오.</target>
        </trans-unit>
        <trans-unit id="9a6c5a958a0495f608cd080595362cf8cc21a5de" translate="yes" xml:space="preserve">
          <source>Notice how we were able to elegantly parse the commands without adding a bunch of &lt;code&gt;if/else&lt;/code&gt; clauses that check the command name and number of arguments!</source>
          <target state="translated">명령 이름과 인수 수를 확인 하는 많은 &lt;code&gt;if/else&lt;/code&gt; 절을 추가하지 않고 명령을 우아하게 구문 분석 할 수 있었던 방법에 주목 하십시오!</target>
        </trans-unit>
        <trans-unit id="6dfab922fecade531cb4dec0d9405839ea8b9d8a" translate="yes" xml:space="preserve">
          <source>Notice in this case we don't have to explicitly import &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Supervisor.Spec&lt;/code&gt;&lt;/a&gt; as &lt;code&gt;use Supervisor&lt;/code&gt; automatically does so. Defining a module-based supervisor can be useful, for example, to perform initialization tasks in the &lt;code&gt;c:init/1&lt;/code&gt; callback.</source>
          <target state="translated">이 경우 &lt;code&gt;use Supervisor&lt;/code&gt; 자동 으로 가져 오기 때문에 명시 적으로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Supervisor.Spec&lt;/code&gt; &lt;/a&gt; 을 가져올 필요가 없습니다 . 예를 들어 &lt;code&gt;c:init/1&lt;/code&gt; 콜백 에서 초기화 작업을 수행하는 데 모듈 기반 수퍼바이저를 정의하면 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c882f5ebb65100a3d2f1cd2368d20ea86c511dfc" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;.&lt;/code&gt; is also an operator. Remote calls use the dot in the AST with two arguments, where the second argument is always an atom:</source>
          <target state="translated">그 주목 &lt;code&gt;.&lt;/code&gt; 또한 연산자입니다. 원격 호출은 두 개의 인수와 함께 AST의 점을 사용합니다. 두 번째 인수는 항상 원자입니다.</target>
        </trans-unit>
        <trans-unit id="df067cb31b582b9b17b8ec8909cd436d56688f8e" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;1 = x&lt;/code&gt; is a valid expression, and it matched because both the left and right side are equal to 1. When the sides do not match, a &lt;code&gt;MatchError&lt;/code&gt; is raised.</source>
          <target state="translated">그 통지 &lt;code&gt;1 = x&lt;/code&gt; 올바른 표현이며, 좌우 양쪽 모두가 일치하지 않는 경우에는 1로 동일하기 때문에 일치 &lt;code&gt;MatchError&lt;/code&gt; 가 상승된다.</target>
        </trans-unit>
        <trans-unit id="ea49ec32721d567bfbb9765cea3e755b4c4e02a9" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;10 / 2&lt;/code&gt; returned a float &lt;code&gt;5.0&lt;/code&gt; instead of an integer &lt;code&gt;5&lt;/code&gt;. This is expected. In Elixir, the operator &lt;code&gt;/&lt;/code&gt; always returns a float. If you want to do integer division or get the division remainder, you can invoke the &lt;code&gt;div&lt;/code&gt; and &lt;code&gt;rem&lt;/code&gt; functions:</source>
          <target state="translated">것을 알 수 &lt;code&gt;10 / 2&lt;/code&gt; 부동 소수점 반환 &lt;code&gt;5.0&lt;/code&gt; 정수 대신 &lt;code&gt;5&lt;/code&gt; . 이것은 예상됩니다. Elixir에서 연산자 &lt;code&gt;/&lt;/code&gt; 는 항상 float를 반환합니다. 정수 나누기를하거나 나누기를 나머지로하려면 &lt;code&gt;div&lt;/code&gt; 및 &lt;code&gt;rem&lt;/code&gt; 함수를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="887a696d47512286eb5278c149faaa334a09a281" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;__STACKTRACE__&lt;/code&gt; can be used inside catch/rescue to retrieve the current stacktrace.</source>
          <target state="translated">통지 &lt;code&gt;__STACKTRACE__&lt;/code&gt; 는 현재 스택 트레이스를 검색하는 캐치 / 구조 내에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8d5e7850b7bd8f241d8a1343704189a623bfa62" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;put_elem/3&lt;/code&gt; returned a new tuple. The original tuple stored in the &lt;code&gt;tuple&lt;/code&gt; variable was not modified. Like lists, tuples are also immutable. Every operation on a tuple returns a new tuple, it never changes the given one.</source>
          <target state="translated">것을 알 수 &lt;code&gt;put_elem/3&lt;/code&gt; 는 새로운 튜플을 반환했습니다. &lt;code&gt;tuple&lt;/code&gt; 변수에 저장된 원래 튜플 은 수정되지 않았습니다. 목록과 마찬가지로 튜플도 변경할 수 없습니다. 튜플의 모든 작업은 새 튜플을 반환하며 지정된 튜플은 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b802bfe2367dd2e9b70b08829bc0a53825dc5da" translate="yes" xml:space="preserve">
          <source>Notice that Elixir allows you to drop the parentheses when invoking named functions. This feature gives a cleaner syntax when writing declarations and control-flow constructs.</source>
          <target state="translated">Elixir를 사용하면 명명 된 함수를 호출 할 때 괄호를 삭제할 수 있습니다. 이 기능은 선언 및 제어 흐름 구성을 작성할 때보다 명확한 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="45ddeb0507e2941d4064cc4fd963a7f2bec2af71" translate="yes" xml:space="preserve">
          <source>Notice that before our changes &lt;code&gt;KV.Registry.lookup/2&lt;/code&gt; sent requests to the server, but now it reads directly from the ETS table, which is shared across all processes. That&amp;rsquo;s the main idea behind the cache mechanism we are implementing.</source>
          <target state="translated">변경 전에 &lt;code&gt;KV.Registry.lookup/2&lt;/code&gt; 는 서버로 요청을 보냈지 만 이제는 모든 프로세스에서 공유되는 ETS 테이블에서 직접 읽습니다. 이것이 우리가 구현하는 캐시 메커니즘의 기본 아이디어입니다.</target>
        </trans-unit>
        <trans-unit id="6a0f0c1ec687f2ea0cd8655129747b9d7cd3f754" translate="yes" xml:space="preserve">
          <source>Notice that by running &lt;code&gt;mix test&lt;/code&gt;, Mix has compiled the source files and generated the application manifest once again. This happens because Mix supports multiple environments, which we will discuss later in this chapter.</source>
          <target state="translated">&lt;code&gt;mix test&lt;/code&gt; 를 실행 하면 Mix가 소스 파일을 컴파일하고 애플리케이션 매니페스트를 다시 한 번 생성했습니다. Mix는 여러 환경을 지원하기 때문에이 장의 뒷부분에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="57e1fb0b39317bc0fdf150c6ab3ed9709eedac00" translate="yes" xml:space="preserve">
          <source>Notice that calling &lt;code&gt;alias&lt;/code&gt; without the &lt;code&gt;:as&lt;/code&gt; option automatically sets an alias based on the last part of the module. For example:</source>
          <target state="translated">&lt;code&gt;:as&lt;/code&gt; 옵션 없이 &lt;code&gt;alias&lt;/code&gt; 을 호출 하면 모듈의 마지막 부분을 기반으로하는 별칭이 자동으로 설정됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9daf8eefb4c15d859869ea5da53757de4d79f368" translate="yes" xml:space="preserve">
          <source>Notice that calling &lt;code&gt;except&lt;/code&gt; is always exclusive on a previously declared &lt;a href=&quot;#import/2&quot;&gt;&lt;code&gt;import/2&lt;/code&gt;&lt;/a&gt;. If there is no previous import, then it applies to all functions and macros in the module. For example:</source>
          <target state="translated">&lt;code&gt;except&lt;/code&gt; 를 호출하는 것은 항상 이전에 선언 된 &lt;a href=&quot;#import/2&quot;&gt; &lt;code&gt;import/2&lt;/code&gt; &lt;/a&gt; 에서만 배타적입니다 . 이전에 가져 오기가 없으면 모듈의 모든 기능과 매크로에 적용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d111052cc1acb6679f60941ac62aab89e4c9ddf" translate="yes" xml:space="preserve">
          <source>Notice that different engines may have different rules for each tag. Other tags may be added in future versions.</source>
          <target state="translated">엔진마다 태그마다 규칙이 다를 수 있습니다. 다른 버전은 향후 버전에서 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="347481b6b324efbcacea6f493fbe1e9b884fc181" translate="yes" xml:space="preserve">
          <source>Notice that if &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; is invoked by different processes concurrently, the first process to invoke &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; acquires a lock and the remaining ones will block until the file is available. This means that if &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; is called more than once with a given file, that file will be compiled only once. The first process to call &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt; will get the list of loaded modules, others will get &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">경우 통지 &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; 가&lt;/a&gt; 동시에 서로 다른 프로세스에 의해 호출, 첫 번째 프로세스가 호출 할 수는 &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; 잠금을 획득하고 파일을 사용할 수있을 때까지 남아있는 것들은 차단합니다. 즉 , 주어진 파일에서 &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; 가 두 번 이상 호출되면 해당 파일은 한 번만 컴파일됩니다. &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; &lt;/a&gt; 를 호출하는 첫 번째 프로세스 는로드 된 모듈 목록을 가져 &lt;code&gt;nil&lt;/code&gt; 다른 프로세스 는 nil 을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="4e78784f8ee1baee6a6b68c15d6d35bbd3682972" translate="yes" xml:space="preserve">
          <source>Notice that it defines the application callback function, &lt;code&gt;start/2&lt;/code&gt;, and instead of defining a supervisor named &lt;code&gt;KVServer.Supervisor&lt;/code&gt; that uses the &lt;code&gt;Supervisor&lt;/code&gt; module, it conveniently defined the supervisor inline! You can read more about such supervisors by reading &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;the Supervisor module documentation&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램 콜백 함수 &lt;code&gt;start/2&lt;/code&gt; 를 정의 하고 &lt;code&gt;Supervisor&lt;/code&gt; 모듈 을 사용하는 &lt;code&gt;KVServer.Supervisor&lt;/code&gt; 라는 감독자를 정의하는 대신 감독자 인라인을 편리하게 정의했습니다! &lt;a href=&quot;https://hexdocs.pm/elixir/Supervisor.html&quot;&gt;Supervisor 모듈 설명서를&lt;/a&gt; 읽고 그러한 감독자에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54b8e7a6900c64697dfb761c739ce312b8b3c54e" translate="yes" xml:space="preserve">
          <source>Notice that setting any of the values above overrides Elixir's default values. For example, setting &lt;code&gt;:requires&lt;/code&gt; to &lt;code&gt;[]&lt;/code&gt; will no longer automatically require the &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; module. In the same way setting &lt;code&gt;:macros&lt;/code&gt; will no longer auto-import &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt; macros like &lt;a href=&quot;kernel#if/2&quot;&gt;&lt;code&gt;Kernel.if/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#case/2&quot;&gt;&lt;code&gt;Kernel.SpecialForms.case/2&lt;/code&gt;&lt;/a&gt;, and so on.</source>
          <target state="translated">위의 값을 설정하면 Elixir의 기본값이 무시됩니다. 예를 들어, &lt;code&gt;:requires&lt;/code&gt; 를 &lt;code&gt;[]&lt;/code&gt; 로 설정 하면 더 이상 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 모듈이 자동으로 필요하지 않습니다 . 같은 방법으로 설정 &lt;code&gt;:macros&lt;/code&gt; 는 더 이상 &lt;a href=&quot;kernel#if/2&quot;&gt; &lt;code&gt;Kernel.if/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel.specialforms#case/2&quot;&gt; &lt;code&gt;Kernel.SpecialForms.case/2&lt;/code&gt; &lt;/a&gt; 등과 같은 &lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 매크로를 자동으로 가져 오지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6e1f199b3af38598b79e950aaf97a0eca8c4b82c" translate="yes" xml:space="preserve">
          <source>Notice that string interpolation in Elixir calls the &lt;code&gt;to_string&lt;/code&gt; function:</source>
          <target state="translated">Elixir의 문자열 보간은 &lt;code&gt;to_string&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="840aa4d2de3105a50a863883569231610137217c" translate="yes" xml:space="preserve">
          <source>Notice that supervisor that reached maximum restart intensity will exit with &lt;code&gt;:shutdown&lt;/code&gt; reason. In this case the supervisor will only be restarted if its child specification was defined with the &lt;code&gt;:restart&lt;/code&gt; option is set to &lt;code&gt;:permanent&lt;/code&gt; (the default).</source>
          <target state="translated">최대 재시작 강도에 도달 한 수퍼바이저는 &lt;code&gt;:shutdown&lt;/code&gt; reason으로 종료 됩니다. 이 경우 수퍼바이저는 하위 스펙이 &lt;code&gt;:restart&lt;/code&gt; 옵션 으로 정의 되어 &lt;code&gt;:permanent&lt;/code&gt; (기본값)로 설정된 경우에만 재시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="80888ed7f572f5d6e47653c01243b5f16e08dc6e" translate="yes" xml:space="preserve">
          <source>Notice that the &lt;code&gt;IO.puts/1&lt;/code&gt; function returns the atom &lt;code&gt;:ok&lt;/code&gt; after printing.</source>
          <target state="translated">주목하라 그 &lt;code&gt;IO.puts/1&lt;/code&gt; 함수가 반환 원자 &lt;code&gt;:ok&lt;/code&gt; 인쇄 후.</target>
        </trans-unit>
        <trans-unit id="4e928f1dda24dbbefd3436c4e0da759a5854ad46" translate="yes" xml:space="preserve">
          <source>Notice that the number of bytes in that string is 6, even though it has 5 characters. That&amp;rsquo;s because the character &amp;ldquo;&amp;ouml;&amp;rdquo; takes 2 bytes to be represented in UTF-8. We can get the actual length of the string, based on the number of characters, by using the &lt;code&gt;String.length/1&lt;/code&gt; function:</source>
          <target state="translated">해당 문자열의 바이트 수는 5 자이지만 6입니다. 문자 &quot;&amp;ouml;&quot;는 UTF-8로 표현되는 데 2 ​​바이트가 필요하기 때문입니다. &lt;code&gt;String.length/1&lt;/code&gt; 함수를 사용하여 문자 수에 따라 문자열의 실제 길이를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8942e3ca27cf75b423a37d9bfb02178064e23332" translate="yes" xml:space="preserve">
          <source>Notice that the supervisor that reaches maximum restart intensity will exit with &lt;code&gt;:shutdown&lt;/code&gt; reason. In this case the supervisor will only be restarted if its child specification was defined with the &lt;code&gt;:restart&lt;/code&gt; option set to &lt;code&gt;:permanent&lt;/code&gt; (the default).</source>
          <target state="translated">최대 재시작 강도에 도달 한 수퍼바이저는 &lt;code&gt;:shutdown&lt;/code&gt; reason으로 종료 됩니다. 이 경우 수퍼바이저는 &lt;code&gt;:restart&lt;/code&gt; 옵션이 &lt;code&gt;:permanent&lt;/code&gt; (기본값)로 설정된 하위 스펙이 정의 된 경우에만 재시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="46c8a4ba57727e7ee215c034d3fe51bd425fdf82" translate="yes" xml:space="preserve">
          <source>Notice that the syntactic representation of &lt;code&gt;map()&lt;/code&gt; is &lt;code&gt;%{optional(any) =&amp;gt; any}&lt;/code&gt;, not &lt;code&gt;%{}&lt;/code&gt;. The notation &lt;code&gt;%{}&lt;/code&gt; specifies the singleton type for the empty map.</source>
          <target state="translated">&lt;code&gt;map()&lt;/code&gt; 의 구문 표현 은 &lt;code&gt;%{optional(any) =&amp;gt; any}&lt;/code&gt; 이 아니라 &lt;code&gt;%{}&lt;/code&gt; optional (any) =&amp;gt; any } 입니다. &lt;code&gt;%{}&lt;/code&gt; 표기법 은 빈 맵의 싱글 톤 유형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="bdf28662e920e08a018b921e52faac2f13427657" translate="yes" xml:space="preserve">
          <source>Notice that the third element in the quoted variable is the atom &lt;code&gt;Sample&lt;/code&gt;, instead of &lt;code&gt;nil&lt;/code&gt;, which marks the variable as coming from the &lt;code&gt;Sample&lt;/code&gt; module. Therefore, Elixir considers these two variables as coming from different contexts and handles them accordingly.</source>
          <target state="translated">따옴표로 묶은 변수의 세 번째 요소는 변수가 &lt;code&gt;Sample&lt;/code&gt; 모듈 에서 온 것으로 표시하는 &lt;code&gt;nil&lt;/code&gt; 대신 atom &lt;code&gt;Sample&lt;/code&gt; 입니다. 따라서, Elixir는이 두 변수가 다른 상황에서 나온 것으로 간주하고 적절하게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="6c70c0b543ddc39b4906e53100736219e7d916c9" translate="yes" xml:space="preserve">
          <source>Notice that the version with &lt;code&gt;!&lt;/code&gt; returns the contents of the file instead of a tuple, and if anything goes wrong the function raises an error.</source>
          <target state="translated">&lt;code&gt;!&lt;/code&gt; 로 버전을 확인하십시오 . 튜플 대신 파일의 내용을 반환하고 문제가 발생하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ac1edafa4a033fbb4dca78373c1cefb5a29180a1" translate="yes" xml:space="preserve">
          <source>Notice that this function expects a list of integers representing UTF-8 code points. If you have a list of bytes, you must instead use the &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;&lt;code&gt;:binary&lt;/code&gt; module&lt;/a&gt;.</source>
          <target state="translated">이 함수에는 UTF-8 코드 포인트를 나타내는 정수 목록이 필요합니다. 바이트 목록이 있으면 대신 &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt; &lt;code&gt;:binary&lt;/code&gt; 모듈을&lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7cdf2f5ea01fa067c0fbde027a86184d517fa295" translate="yes" xml:space="preserve">
          <source>Notice that this function treats integers in the given IO data as raw bytes and does not perform any kind of encoding conversion. If you want to convert from a charlist to a UTF-8-encoded string, use &lt;a href=&quot;#chardata_to_string/1&quot;&gt;&lt;code&gt;chardata_to_string/1&lt;/code&gt;&lt;/a&gt; instead. For more information about IO data and chardata, see the &lt;a href=&quot;#module-io-data&quot;&gt;&quot;IO data&quot;&lt;/a&gt; section in the module documentation.</source>
          <target state="translated">이 함수는 주어진 IO 데이터의 정수를 원시 바이트로 취급하며 어떤 종류의 인코딩 변환도 수행하지 않습니다. 문자 목록에서 UTF-8로 인코딩 된 문자열로 변환하려면 대신 &lt;a href=&quot;#chardata_to_string/1&quot;&gt; &lt;code&gt;chardata_to_string/1&lt;/code&gt; 을&lt;/a&gt; 사용하십시오. IO 데이터 및 chardata에 대한 자세한 내용은 모듈 설명서 의 &lt;a href=&quot;#module-io-data&quot;&gt;&quot;IO 데이터&quot;&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="da2e36451104accdab1f135698969f5dbb62ea72" translate="yes" xml:space="preserve">
          <source>Notice that variables bound in a clause &quot;head&quot; do not leak to the outer context:</source>
          <target state="translated">&quot;head&quot;절에 바인딩 된 변수는 외부 컨텍스트로 누출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f18296fb1e15bf91d08f40da7cae0240a810e85c" translate="yes" xml:space="preserve">
          <source>Notice that we first printed each element in the list, then multiplied each element by 2 and finally printed each new value. In this example, the list was enumerated three times. Let's see an example with streams:</source>
          <target state="translated">먼저 목록의 각 요소를 인쇄 한 다음 각 요소에 2를 곱한 다음 새 값을 각각 인쇄했습니다. 이 예에서는 목록이 세 번 열거되었습니다. 스트림이있는 예제를 보자.</target>
        </trans-unit>
        <trans-unit id="e80454db9add600d6dd12ebc0cf1ec2362e0064d" translate="yes" xml:space="preserve">
          <source>Notice that we referred to structs as &lt;strong&gt;bare&lt;/strong&gt; maps because none of the protocols implemented for maps are available for structs. For example, you can neither enumerate nor access a struct:</source>
          <target state="translated">구조체에 대해 맵에 구현 된 프로토콜이 없기 때문에 구조체를 &lt;strong&gt;베어&lt;/strong&gt; 맵이라고합니다. 예를 들어 구조체를 열거하거나 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e7bd2d8499eb11634d1cac7e077fdc215c19c9e6" translate="yes" xml:space="preserve">
          <source>Notice that when starting the GenServer, we are registering it with name &lt;code&gt;Stack&lt;/code&gt;, which allows us to call it directly and get what is on the stack:</source>
          <target state="translated">GenServer를 시작할 때 이름을 &lt;code&gt;Stack&lt;/code&gt; 으로 등록 하면 직접 호출하여 스택에있는 것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57f35a2e632227e4c4fd62aa0253d676ce9ec766" translate="yes" xml:space="preserve">
          <source>Notice that, even though the alias &lt;code&gt;M&lt;/code&gt; is not available in the context the macro is expanded, the code above works because &lt;code&gt;M&lt;/code&gt; still expands to &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">별명에도 불구하고, 공지 사항 &lt;code&gt;M&lt;/code&gt; 은 매크로가 확장되는 상황에서 사용할 수없는이 작품을 위의 코드가 있기 때문에 &lt;code&gt;M&lt;/code&gt; 은 여전히로 확장 &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f6878fe98d8554fc9f432df2a9141f6399af678" translate="yes" xml:space="preserve">
          <source>Notice that, while patterns may be given to macros, remember that macros receive ASTs as arguments, and not values. For example, if you try to break on a macro with the following pattern:</source>
          <target state="translated">매크로에는 패턴이 제공 될 수 있지만 매크로는 값이 아닌 AST를 인수로받습니다. 예를 들어, 다음과 같은 패턴으로 매크로를 끊으려고하면 :</target>
        </trans-unit>
        <trans-unit id="5cf97154e72e91b95ed319e84cacaa08b368821a" translate="yes" xml:space="preserve">
          <source>Notice the break was represented as is, because we haven't reached a line limit. Once we do, it is replaced by a newline:</source>
          <target state="translated">줄 한도에 도달하지 않았으므로 줄 바꿈이있는 그대로 나타납니다. 일단 우리는 개행 문자로 대체됩니다 :</target>
        </trans-unit>
        <trans-unit id="496f1449954afceaf9beb520372d8e05f415dd6b" translate="yes" xml:space="preserve">
          <source>Notice the break was represented with the given string, because we didn't reach a line limit. Once we do, it is replaced by a newline:</source>
          <target state="translated">줄 한도에 도달하지 않았으므로 줄 바꿈은 주어진 문자열로 표시됩니다. 일단 우리는 개행 문자로 대체됩니다 :</target>
        </trans-unit>
        <trans-unit id="3e4325519e924c99a829325af4cfbcadb94f2b5a" translate="yes" xml:space="preserve">
          <source>Notice the user-supplied function is wrapped into a &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function. The &lt;a href=&quot;#t:reducer/0&quot;&gt;&lt;code&gt;reducer/0&lt;/code&gt;&lt;/a&gt; function must return a tagged tuple after each step, as described in the &lt;a href=&quot;#t:acc/0&quot;&gt;&lt;code&gt;acc/0&lt;/code&gt;&lt;/a&gt; type. At the end, &lt;a href=&quot;enumerable#reduce/3&quot;&gt;&lt;code&gt;Enumerable.reduce/3&lt;/code&gt;&lt;/a&gt; returns &lt;a href=&quot;#t:result/0&quot;&gt;&lt;code&gt;result/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자 제공 기능은 &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; 기능 으로 래핑됩니다 . &lt;a href=&quot;#t:reducer/0&quot;&gt; &lt;code&gt;reducer/0&lt;/code&gt; &lt;/a&gt; 에서 설명한 바와 같이 기능은 각 단계 후 태그 튜플을 반환해야 &lt;a href=&quot;#t:acc/0&quot;&gt; &lt;code&gt;acc/0&lt;/code&gt; &lt;/a&gt; 형. 결국 &lt;a href=&quot;enumerable#reduce/3&quot;&gt; &lt;code&gt;Enumerable.reduce/3&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#t:result/0&quot;&gt; &lt;code&gt;result/0&lt;/code&gt; 을&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="07069adb0c1e46329be40dc3e44e76edaef1ef62" translate="yes" xml:space="preserve">
          <source>Notice this function will traverse the whole &lt;code&gt;enumerable&lt;/code&gt; to get the random sublist.</source>
          <target state="translated">이 함수는 임의의 하위 목록을 얻기 위해 &lt;code&gt;enumerable&lt;/code&gt; 전체를 탐색합니다 .</target>
        </trans-unit>
        <trans-unit id="89e0bc5cd464e7720b387f9becc6e78a50eb339c" translate="yes" xml:space="preserve">
          <source>Notice we didn't implement it for lists as we don't have the &lt;code&gt;size&lt;/code&gt; information on lists, rather its value needs to be computed with &lt;code&gt;length&lt;/code&gt;.</source>
          <target state="translated">리스트에 대한 &lt;code&gt;size&lt;/code&gt; 정보 가 없기 때문에리스트에 대해 구현하지 않았으며 그 값은 &lt;code&gt;length&lt;/code&gt; 로 계산해야합니다 .</target>
        </trans-unit>
        <trans-unit id="03afe8d614ca6b25d6bf98b3847bcf90d9034dfa" translate="yes" xml:space="preserve">
          <source>Notice we had to escape the backslash escape character (i.e., we used &lt;code&gt;\\N&lt;/code&gt; instead of just &lt;code&gt;\N&lt;/code&gt; to escape the backslash; same thing for &lt;code&gt;\\g{N}&lt;/code&gt;). By giving &lt;code&gt;\0&lt;/code&gt;, one can inject the whole matched pattern in the replacement string.</source>
          <target state="translated">우리는 백 슬래시 이스케이프 문자를 탈출했다 주목 (즉, 우리가 사용 &lt;code&gt;\\N&lt;/code&gt; 대신에 단지 &lt;code&gt;\N&lt;/code&gt; 백 슬래시를 탈출, 대한 똑같은 &lt;code&gt;\\g{N}&lt;/code&gt; ). &lt;code&gt;\0&lt;/code&gt; 을 주면 , 일치하는 전체 패턴을 대체 문자열에 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f85b4b1b8fafa24d41295fda0f44252f687ca128" translate="yes" xml:space="preserve">
          <source>Notice we have an inner tuple, containing the atom &lt;code&gt;:.&lt;/code&gt; representing the dot as first element:</source>
          <target state="translated">원자를 포함하는 내부 튜플이 &lt;code&gt;:.&lt;/code&gt; 점을 첫 번째 요소로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6c69e6930b5bc92d057ccefe34bb93eda478134f" translate="yes" xml:space="preserve">
          <source>Notice we started with a range and then we created a stream that is meant to multiply each element in the range by 2. At this point, no computation was done. Only when &lt;a href=&quot;enum#map/2&quot;&gt;&lt;code&gt;Enum.map/2&lt;/code&gt;&lt;/a&gt; is called we actually enumerate over each element in the range, multiplying it by 2 and adding 1. We say the functions in &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Stream&lt;/code&gt;&lt;/a&gt; are &lt;em&gt;lazy&lt;/em&gt; and the functions in &lt;a href=&quot;enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; are &lt;em&gt;eager&lt;/em&gt;.</source>
          <target state="translated">범위로 시작한 다음 범위의 각 요소에 2를 곱하는 스트림을 만들었습니다.이 시점에서 계산이 수행되지 않았습니다. &lt;a href=&quot;enum#map/2&quot;&gt; &lt;code&gt;Enum.map/2&lt;/code&gt; &lt;/a&gt; 가 호출 될 때만 실제로 범위의 각 요소에 2를 곱하고 1을 더하여 &lt;a href=&quot;enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 합니다. &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Stream&lt;/code&gt; &lt;/a&gt; 의 함수 는 &lt;em&gt;게으르고 &lt;/em&gt;Enum 의 함수 는 &lt;em&gt;열망&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ba47ef34cc51f70a00d9e0a27391c8b89cac3f5e" translate="yes" xml:space="preserve">
          <source>Now a struct can be created as follows:</source>
          <target state="translated">이제 구조체를 다음과 같이 만들 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ac6a27b4457ccc07e2ad2cacdcc3e23c4356feaa" translate="yes" xml:space="preserve">
          <source>Now all data types (including structs) that have not implemented the &lt;code&gt;Size&lt;/code&gt; protocol will be considered to have a size of &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;Size&lt;/code&gt; 프로토콜을 구현하지 않은 모든 데이터 유형 (구조체 포함) 은 크기가 &lt;code&gt;0&lt;/code&gt; 으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="89083d1bc146a648411e0ff3f2366a0deb9fa8b8" translate="yes" xml:space="preserve">
          <source>Now if you run the tests, you will see the test that checks the server interaction will fail, as it will attempt to use the routing table. To address this failure, add &lt;code&gt;@tag :distributed&lt;/code&gt; to this test too:</source>
          <target state="translated">테스트를 실행하면 라우팅 테이블을 사용하려고 시도하므로 서버 상호 작용을 검사하는 테스트가 실패하는 것을 볼 수 있습니다. 이 실패를 해결하려면 이 테스트에도 &lt;code&gt;@tag :distributed&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="07a537a78322242c13cbe0fc9e189cb95c551f62" translate="yes" xml:space="preserve">
          <source>Now imagine someone wants to split the string in three parts. You decide to make the number of parts configurable via the application environment:</source>
          <target state="translated">이제 누군가가 줄을 세 부분으로 나누기를 원한다고 상상해보십시오. 응용 프로그램 환경을 통해 부품 수를 구성 할 수 있도록 결정합니다.</target>
        </trans-unit>
        <trans-unit id="0d4fb1978dc93bf23ded5fbfb72b901b0ff9b3c1" translate="yes" xml:space="preserve">
          <source>Now imagine that this code does not fit its line. The code formatter introduces breaks inside &lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt; and inside &lt;code&gt;%{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;. Therefore the document would break as:</source>
          <target state="translated">이제이 코드가 해당 라인에 맞지 않는다고 상상해보십시오. 소개합니다 내부 휴식 포맷터 코드 &lt;code&gt;(&lt;/code&gt; 와 &lt;code&gt;)&lt;/code&gt; 과 내부 &lt;code&gt;%{&lt;/code&gt; 와 &lt;code&gt;}&lt;/code&gt; . 따라서 문서는 다음과 같이 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="1776285a5ee5e0cd2e476a5e17548b25cf3e7965" translate="yes" xml:space="preserve">
          <source>Now instead of:</source>
          <target state="translated">이제 대신</target>
        </trans-unit>
        <trans-unit id="b2edaaf4e4c37a573a2f4175b7fb677e22086d38" translate="yes" xml:space="preserve">
          <source>Now invoking &lt;code&gt;squared(my_number.())&lt;/code&gt; as before will print the value just once.</source>
          <target state="translated">이전과 같이 &lt;code&gt;squared(my_number.())&lt;/code&gt; 를 호출 하면 값이 한 번만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="b50389659966a7555212a28c84596f8d8bad4035" translate="yes" xml:space="preserve">
          <source>Now it is your turn to write a test for the functionality above! Also, be sure to explore &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt;the documentation for the &lt;code&gt;Agent&lt;/code&gt; module&lt;/a&gt; to learn more about them.</source>
          <target state="translated">이제 위의 기능에 대한 테스트를 작성하십시오. 또한 &lt;a href=&quot;https://hexdocs.pm/elixir/Agent.html&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; 모듈에 대한 자세한 내용은 에이전트 모듈 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cac6639a99e22abeb99b7c1fe3b72525b3c0d41b" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s make the doctest pass. Let&amp;rsquo;s implement the &lt;code&gt;parse/1&lt;/code&gt; function:</source>
          <target state="translated">이제 doctest를 통과합시다. &lt;code&gt;parse/1&lt;/code&gt; 함수를 구현하자 :</target>
        </trans-unit>
        <trans-unit id="a06cdb0293b3c757aef93c1695a911a48f527d99" translate="yes" xml:space="preserve">
          <source>Now once the system boots, it will invoke the provider early in the boot process, save the merged configuration to the disk, and reboot the system with the new values in place.</source>
          <target state="translated">이제 시스템이 부팅되면 부팅 프로세스 초기에 공급자를 호출하고 병합 된 구성을 디스크에 저장 한 다음 새 값을 사용하여 시스템을 재부팅합니다.</target>
        </trans-unit>
        <trans-unit id="f8e788006f30e3c08108a5e67aea31d230a97139" translate="yes" xml:space="preserve">
          <source>Now run &lt;code&gt;mix test&lt;/code&gt; again (notice this time there will be no compilation):</source>
          <target state="translated">이제 &lt;code&gt;mix test&lt;/code&gt; 다시 실행 하십시오 (이번에는 컴파일이 없음에 유의하십시오).</target>
        </trans-unit>
        <trans-unit id="19fa598d84faa6a938161fe34822951938d13086" translate="yes" xml:space="preserve">
          <source>Now run tests with &lt;code&gt;mix test&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;mix test&lt;/code&gt; 테스트를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="edc3c0311fb8d8402744a5dc3b64fa6e7d3ee61a" translate="yes" xml:space="preserve">
          <source>Now run the shell:</source>
          <target state="translated">이제 쉘을 실행하십시오 :</target>
        </trans-unit>
        <trans-unit id="19a25f5fcd5f38d10706db44b6313eed285f06df" translate="yes" xml:space="preserve">
          <source>Now that our buckets are properly linked and supervised, let&amp;rsquo;s see how we can speed things up.</source>
          <target state="translated">버킷이 제대로 연결되고 감독되었으므로 속도를 높일 수있는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="9e53f2ea82a2cf9a10ea7d3d3f281c742019f84a" translate="yes" xml:space="preserve">
          <source>Now that the &lt;code&gt;KV.Bucket&lt;/code&gt; module has been defined, our test should pass! You can try it yourself by running: &lt;code&gt;mix test&lt;/code&gt;.</source>
          <target state="translated">이제 것을 &lt;code&gt;KV.Bucket&lt;/code&gt; 의 모듈이 정의되어, 우리의 테스트를 통과해야한다! &lt;code&gt;mix test&lt;/code&gt; 를 실행하여 직접 시도해 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7df359bcf6fd7b6b53a7f0116a2c64cf244a918" translate="yes" xml:space="preserve">
          <source>Now that the protocol can be implemented for every data structure the protocol may have a compliant implementation for:</source>
          <target state="translated">이제 모든 데이터 구조에 대해 프로토콜을 구현할 수 있으므로 프로토콜은 다음에 대한 호환 구현을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08d686a4ce79ab4cc9d9c6a38ea87b99a5fd278a" translate="yes" xml:space="preserve">
          <source>Now that the server is part of the supervision tree, it should start automatically when we run the application. Start your server, now passing the port, and once again use the &lt;code&gt;telnet&lt;/code&gt; client to make sure that everything still works:</source>
          <target state="translated">이제 서버는 감독 트리의 일부이므로 응용 프로그램을 실행할 때 자동으로 시작됩니다. 이제 포트를 전달하여 서버를 시작한 후 &lt;code&gt;telnet&lt;/code&gt; 클라이언트를 다시 사용하여 모든 것이 여전히 작동하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e7e80fb6ff6e247ded63d0bdc578c34f9a1551f2" translate="yes" xml:space="preserve">
          <source>Now that we have defined our supervision tree, it is a great opportunity to introduce the Observer tool that ships with Erlang. Start your application with &lt;code&gt;iex -S mix&lt;/code&gt; and key this in:</source>
          <target state="translated">이제 감시 트리를 정의 했으므로 Erlang과 함께 제공되는 관찰자 도구를 소개 할 수있는 좋은 기회입니다. &lt;code&gt;iex -S mix&lt;/code&gt; 로 애플리케이션을 시작하고 다음을 입력하십시오 .</target>
        </trans-unit>
        <trans-unit id="65521a82582c996b661e688c57efd31c9126bde0" translate="yes" xml:space="preserve">
          <source>Now that we have talked about aliases, we can talk about nesting and how it works in Elixir. Consider the following example:</source>
          <target state="translated">이제 별칭에 대해 이야기 했으므로, 엘릭서에서 중첩과 작동 방식에 대해 이야기 할 수 있습니다. 다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ac080018201e9a042de2521194aa2396dd3f6137" translate="yes" xml:space="preserve">
          <source>Now that you have defined an application callback which starts our supervisor, we expect the &lt;code&gt;KV.Registry&lt;/code&gt; process to be up and running as soon we start &lt;code&gt;iex -S mix&lt;/code&gt;. Let&amp;rsquo;s give it another try:</source>
          <target state="translated">이제 관리자를 시작하는 응용 프로그램 콜백을 정의 &lt;code&gt;iex -S mix&lt;/code&gt; 시작하자마자 &lt;code&gt;KV.Registry&lt;/code&gt; 프로세스가 시작되어 실행됩니다 . 다시 시도해 봅시다.</target>
        </trans-unit>
        <trans-unit id="328f3af23181b7aed869a7baf3feac133b09d35c" translate="yes" xml:space="preserve">
          <source>Now trying to build a struct without the name key will fail:</source>
          <target state="translated">이제 이름 키없이 구조체를 만들려고하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f61f095187bf437534acdc98989a52599f7a57e0" translate="yes" xml:space="preserve">
          <source>Now type any string into the terminal and you will see that the same value will be printed in upper-case. Unfortunately, this example also got your IEx shell stuck in the comprehension, so you will need to hit &lt;code&gt;Ctrl+C&lt;/code&gt; twice to get out of it. :)</source>
          <target state="translated">이제 터미널에 문자열을 입력하면 동일한 값이 대문자로 인쇄됩니다. 불행히도,이 예제는 IEx 쉘이 이해력에 갇히게되므로 &lt;code&gt;Ctrl+C&lt;/code&gt; 를 두 번 눌러 제거 해야 합니다. :)</target>
        </trans-unit>
        <trans-unit id="46bc283c29ce2ecc43ead7d1d61cfa31cca09a7d" translate="yes" xml:space="preserve">
          <source>Now users can configure your library in their &lt;code&gt;config/config.exs&lt;/code&gt; file as follows:</source>
          <target state="translated">이제 사용자는 다음과 같이 &lt;code&gt;config/config.exs&lt;/code&gt; 파일 에서 라이브러리를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b17fce085e9d552d0a9af3234c3cdfba2da82bb3" translate="yes" xml:space="preserve">
          <source>Now we are connected into the remote node, as the prompt shows us, and we can access the information and modules defined over there:</source>
          <target state="translated">프롬프트가 표시하는대로 이제 원격 노드에 연결되었으며 여기에 정의 된 정보 및 모듈에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57fd8f624da2baf5d7aba96d024c13b21b6b8eeb" translate="yes" xml:space="preserve">
          <source>Now we can start our debugger:</source>
          <target state="translated">이제 디버거를 시작할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ff52cd0aed65a9dce91b318e1c1c0dbc4e09358d" translate="yes" xml:space="preserve">
          <source>Now we get an error because an application that &lt;code&gt;:kv&lt;/code&gt; depends on (&lt;code&gt;:logger&lt;/code&gt; in this case) isn&amp;rsquo;t started. We need to either start each application manually in the correct order or call &lt;code&gt;Application.ensure_all_started&lt;/code&gt; as follows:</source>
          <target state="translated">&lt;code&gt;:kv&lt;/code&gt; 가 의존 하는 응용 프로그램 ( 이 경우 &lt;code&gt;:logger&lt;/code&gt; )이 시작되지 않아 오류가 발생합니다. 올바른 순서로 각 응용 프로그램을 수동으로 시작하거나 다음과 같이 &lt;code&gt;Application.ensure_all_started&lt;/code&gt; 를 호출 해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce58c619fafb232c624235ba4ccf102d6952d45a" translate="yes" xml:space="preserve">
          <source>Now we need to change &lt;code&gt;loop_acceptor/1&lt;/code&gt; to use &lt;code&gt;Task.Supervisor&lt;/code&gt; to serve each request:</source>
          <target state="translated">이제 각 요청을 &lt;code&gt;Task.Supervisor&lt;/code&gt; 하기 위해 Task.Supervisor 를 사용하도록 loop_acceptor &lt;code&gt;loop_acceptor/1&lt;/code&gt; 을 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fdeab946c4d9329d156b88e77a2ec9ecfeddcfa0" translate="yes" xml:space="preserve">
          <source>Now we only need to make &lt;code&gt;KV.RouterTest&lt;/code&gt; pass once again. To do so, we will write a setup block that runs before all tests in that file. The setup block will change the application environment and revert it back once we are done, like this:</source>
          <target state="translated">이제 &lt;code&gt;KV.RouterTest&lt;/code&gt; 를 다시 한 번만 통과하면됩니다. 이를 위해 해당 파일의 모든 테스트 전에 실행되는 설정 블록을 작성합니다. 설정 블록은 다음과 같이 응용 프로그램 환경을 변경하고 완료되면 되돌립니다.</target>
        </trans-unit>
        <trans-unit id="616d9118cd5824c6691d30e8ef906dec071996ec" translate="yes" xml:space="preserve">
          <source>Now with our routing system in place, let&amp;rsquo;s change &lt;code&gt;KVServer&lt;/code&gt; to use the router. Replace the &lt;code&gt;lookup/2&lt;/code&gt; function in &lt;code&gt;KVServer.Command&lt;/code&gt; by the following one:</source>
          <target state="translated">이제 라우팅 시스템을 설치 한 후 라우터를 사용하도록 &lt;code&gt;KVServer&lt;/code&gt; 를 변경 하겠습니다 . 바꾸기 &lt;code&gt;lookup/2&lt;/code&gt; 에서 함수 &lt;code&gt;KVServer.Command&lt;/code&gt; 을 다음 하나로 :</target>
        </trans-unit>
        <trans-unit id="473b17993b7eb7156690a660695f0604c4095a5c" translate="yes" xml:space="preserve">
          <source>Now with the protocol defined and implementations in hand, we can start using it:</source>
          <target state="translated">이제 프로토콜이 정의되고 구현되어 있으므로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ac19fd0e99d45eb3bb8a29a0a874c8bc60bad1b" translate="yes" xml:space="preserve">
          <source>Now you can dynamically start supervised tasks:</source>
          <target state="translated">이제 감독 된 작업을 동적으로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32df2513a243e616c099ce25eeecd29f8971c442" translate="yes" xml:space="preserve">
          <source>Now you can run tests for both projects from the umbrella root with &lt;code&gt;mix test&lt;/code&gt;. Sweet!</source>
          <target state="translated">이제 우산 루트에서 &lt;code&gt;mix test&lt;/code&gt; 를 사용하여 두 프로젝트 모두에 대한 테스트를 실행할 수 있습니다 . 단!</target>
        </trans-unit>
        <trans-unit id="07b0131f4deaf329edfa37832794fd47dac09e81" translate="yes" xml:space="preserve">
          <source>Now you want to make the &lt;code&gt;heavy_fun()&lt;/code&gt; async:</source>
          <target state="translated">이제 &lt;code&gt;heavy_fun()&lt;/code&gt; 비동기 로 만들고 싶습니다 .</target>
        </trans-unit>
        <trans-unit id="476ae1fa4f615cd4311df04dc7c8a801b6354a43" translate="yes" xml:space="preserve">
          <source>Now, an entity interested in dispatching events for a given key may call &lt;a href=&quot;#dispatch/3&quot;&gt;&lt;code&gt;dispatch/3&lt;/code&gt;&lt;/a&gt; passing in the key and a callback. This callback will be invoked with a list of all the values registered under the requested key, alongside the PID of the process that registered each value, in the form of &lt;code&gt;{pid, value}&lt;/code&gt; tuples. In our example, &lt;code&gt;value&lt;/code&gt; will be the &lt;code&gt;{module, function}&lt;/code&gt; tuple in the code above:</source>
          <target state="translated">이제, 주어진 키에 대한 이벤트 디스패치에 관심이있는 엔티티 는 키와 콜백을 전달하는 &lt;a href=&quot;#dispatch/3&quot;&gt; &lt;code&gt;dispatch/3&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 있습니다 . 이 콜백은 요청 된 키 아래에 등록 된 모든 값 목록과 함께 각 값을 등록한 프로세스의 PID와 함께 &lt;code&gt;{pid, value}&lt;/code&gt; 튜플 의 형태로 호출됩니다 . 이 예에서 &lt;code&gt;value&lt;/code&gt; 는 위 코드에서 &lt;code&gt;{module, function}&lt;/code&gt; 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="d99570fbe4495eecd768739b59540e2e4e121132" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s start two named nodes again, but inside the &lt;code&gt;:kv&lt;/code&gt; application:</source>
          <target state="translated">이제 두 개의 명명 된 노드를 다시 시작하지만 &lt;code&gt;:kv&lt;/code&gt; 응용 프로그램 안에서 시작하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="7056385a9cb5c062d2f526a7af092bf8f6c98b17" translate="yes" xml:space="preserve">
          <source>Now, let's roll back to the first shell:</source>
          <target state="translated">이제 첫 번째 쉘로 롤백 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="8883bbf72dbea8b7c2911dc4d03827a0ab88aa71" translate="yes" xml:space="preserve">
          <source>Now, let's start another shell, giving it a name as well:</source>
          <target state="translated">이제 다른 쉘을 시작하여 이름을 지정해 봅시다.</target>
        </trans-unit>
        <trans-unit id="b8f14e00a9ee1de5622bfa894ce44aa7673c9977" translate="yes" xml:space="preserve">
          <source>Now, try to access the &lt;code&gt;hello&lt;/code&gt; variable again:</source>
          <target state="translated">이제 &lt;code&gt;hello&lt;/code&gt; 변수에 다시 액세스 하십시오.</target>
        </trans-unit>
        <trans-unit id="f02afe5290423ebf3ed89e90bd9b4662ee206e07" translate="yes" xml:space="preserve">
          <source>Now, we will get an error if we try to use this operator &quot;out of the box&quot;:</source>
          <target state="translated">이제이 연산자를 &quot;바로&quot;사용하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a053460549010159dc2b6fda3731de548204bf3f" translate="yes" xml:space="preserve">
          <source>Number of expressions and their results to keep in the history. The value is an integer. When it is negative, the history is unlimited.</source>
          <target state="translated">히스토리에 보관할 표현 수 및 결과 값은 정수입니다. 음수이면 기록이 무제한입니다.</target>
        </trans-unit>
        <trans-unit id="7e53821f70ae16079c4a6a64c52a91fae645bc5f" translate="yes" xml:space="preserve">
          <source>Numbers</source>
          <target state="translated">Numbers</target>
        </trans-unit>
        <trans-unit id="ff5e98caf48c434c6264af1a2c308ac24882bda5" translate="yes" xml:space="preserve">
          <source>OTP</source>
          <target state="translated">OTP</target>
        </trans-unit>
        <trans-unit id="fa8fe915548f0e22ce68e5cf32adf85a38cb0334" translate="yes" xml:space="preserve">
          <source>OTP exits</source>
          <target state="translated">OTP 이탈</target>
        </trans-unit>
        <trans-unit id="9ebb04f1d502294523ffc0d5654291733158f382" translate="yes" xml:space="preserve">
          <source>OWN - time spent in the function, excluding the time of called functions</source>
          <target state="translated">OWN-호출 된 함수의 시간을 제외하고 함수에서 소비 한 시간</target>
        </trans-unit>
        <trans-unit id="5170a26358c94cd0c4d86fad3a0f89ca90839e4e" translate="yes" xml:space="preserve">
          <source>Observe that we were able to considerably change the server implementation without changing any of the client API. That&amp;rsquo;s one of the benefits of explicitly segregating the server and the client.</source>
          <target state="translated">클라이언트 API를 변경하지 않고 서버 구현을 상당히 변경할 수 있음을 관찰하십시오. 이는 서버와 클라이언트를 명시 적으로 분리하면 얻을 수있는 이점 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="ab7e64c97fc5b12d3a53c3eaa9ee4e2f13560916" translate="yes" xml:space="preserve">
          <source>Observer</source>
          <target state="translated">Observer</target>
        </trans-unit>
        <trans-unit id="c85a3d54e191da03c6d7794a838fbe85cdb51bc7" translate="yes" xml:space="preserve">
          <source>Of all the approaches above, the first is definitely the most flexible. If our domain rules can be encoded with data structures, they are by far the easiest to compose and implement, as Elixir&amp;rsquo;s standard library is filled with functions for manipulating different data types.</source>
          <target state="translated">위의 모든 접근 방법 중 첫 번째 방법이 가장 유연합니다. 도메인 규칙을 데이터 구조로 인코딩 할 수 있다면 Elixir의 표준 라이브러리에는 다양한 데이터 유형을 조작하는 기능이 포함되어있어 작성 및 구현이 가장 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="902cb7ed7bd72ac12ba23366c9ffb04891ee4dcb" translate="yes" xml:space="preserve">
          <source>Of course, Elixir can be used for much more than distributed key-value stores. Embedded systems, data-processing and data-ingestion, web applications, streaming system, and others are many of the different domains Elixir excels at. We hope this guide has prepared you to explore any of those domains or any future domain you may desire to bring Elixir into.</source>
          <target state="translated">물론, Elixir는 분산 키-값 저장소보다 훨씬 더 많이 사용될 수 있습니다. 임베디드 시스템, 데이터 처리 및 데이터 처리, 웹 응용 프로그램, 스트리밍 시스템 및 기타는 Elixir가 능가하는 다양한 영역입니다. 이 안내서가 Elixir를 도입하기를 원하는 도메인 또는 향후 도메인을 탐색 할 수 있도록 준비했으면합니다.</target>
        </trans-unit>
        <trans-unit id="c9c303f80906a94bd84edefa290936f6df4b3704" translate="yes" xml:space="preserve">
          <source>Official #elixir-lang on freenode IRC</source>
          <target state="translated">프리 노드 IRC의 공식 # elixir-lang</target>
        </trans-unit>
        <trans-unit id="5ad3a32fb5de6c096b01951e5ee3be528054408f" translate="yes" xml:space="preserve">
          <source>Often in Elixir there is a need to share or store state that must be accessed from different processes or by the same process at different points in time.</source>
          <target state="translated">Elixir에서는 종종 다른 프로세스에서 또는 다른 프로세스에서 같은 시점에 액세스해야하는 상태를 공유하거나 저장해야 할 필요가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f4e555dd4a0b214fc42c4fafafd47bf3b759ac6" translate="yes" xml:space="preserve">
          <source>Often there are errors/exceptions inside exits. Exits are often wrapped by the caller and provide stacktraces too. This function formats exits in a way to nicely show the exit reason, caller and stacktrace.</source>
          <target state="translated">엑시트 내부에 오류 / 예외가있는 경우가 종종 있습니다. 엑시트는 종종 호출자에 의해 랩핑되며 스택 추적도 제공합니다. 이 함수는 종료 이유, 호출자 및 스택 추적을 멋지게 표시하는 방식으로 종료를 형식화합니다.</target>
        </trans-unit>
        <trans-unit id="9323e6675acdba059cc7528c84326fb722f7cf8a" translate="yes" xml:space="preserve">
          <source>Often they are used to express the state of an operation, by using values such as &lt;code&gt;:ok&lt;/code&gt; and &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">종종 &lt;code&gt;:ok&lt;/code&gt; 및 &lt;code&gt;:error&lt;/code&gt; 와 같은 값을 사용하여 작업 상태를 표현하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c02ae25b9dec2dd8be94787202587f35da019d9" translate="yes" xml:space="preserve">
          <source>Often we will have maps inside maps, or even keywords lists inside maps, and so forth. Elixir provides conveniences for manipulating nested data structures via the &lt;code&gt;put_in/2&lt;/code&gt;, &lt;code&gt;update_in/2&lt;/code&gt; and other macros giving the same conveniences you would find in imperative languages while keeping the immutable properties of the language.</source>
          <target state="translated">종종지도 안에지도가 있거나지도 안에 키워드 목록 등이있을 수도 있습니다. Elixir는 &lt;code&gt;put_in/2&lt;/code&gt; , &lt;code&gt;update_in/2&lt;/code&gt; 및 기타 매크로를 통해 중첩 된 데이터 구조를 조작 할 수있는 편의성을 제공하며 언어의 불변 속성을 유지하면서 명령형 언어에서와 동일한 편의성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a567fc96e505fa689fb781ec6b8b66b74eefd6f8" translate="yes" xml:space="preserve">
          <source>On Unix-like / Bash:</source>
          <target state="translated">유닉스 계열 / 배쉬 :</target>
        </trans-unit>
        <trans-unit id="74b298f2360ded6dbf3b3733dbfa18ae283fccd2" translate="yes" xml:space="preserve">
          <source>On Windows 10 / PowerShell:</source>
          <target state="translated">Windows 10 / PowerShell :</target>
        </trans-unit>
        <trans-unit id="010a92ca285536db23a909835a24cc3bbd247a77" translate="yes" xml:space="preserve">
          <source>On Windows, path is split on both &quot;\&quot; and &quot;/&quot; separators and the driver letter, if there is one, is always returned in lowercase.</source>
          <target state="translated">Windows에서는 경로가 &quot;\&quot;및 &quot;/&quot;구분 기호로 분할되고 드라이버 문자가 있으면 드라이버 문자가 항상 소문자로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="55b56364276b5f7e47e7f031287b139fc5b947d5" translate="yes" xml:space="preserve">
          <source>On Windows:</source>
          <target state="translated">Windows에서 :</target>
        </trans-unit>
        <trans-unit id="2779b0cd51a2b5987b501d655bc5be3263bd37e4" translate="yes" xml:space="preserve">
          <source>On its turn, the port will send the connected process the following messages:</source>
          <target state="translated">차례가되면 포트는 연결된 프로세스에 다음 메시지를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="1c4b199ab2a5a87b093d5ef5b68e83e8d35a8454" translate="yes" xml:space="preserve">
          <source>On the language homepage, we mention that Elixir makes documentation a first-class citizen in the language. We have explored this concept many times throughout this guide, be it via &lt;code&gt;mix help&lt;/code&gt; or by typing &lt;code&gt;h Enum&lt;/code&gt; or another module in an IEx console.</source>
          <target state="translated">언어 홈페이지에서 Elixir는 문서를 언어에서 일류 시민으로 만든다고 언급합니다. 이 안내서에서이 개념을 여러 번 살펴 보았습니다. &lt;code&gt;mix help&lt;/code&gt; 통해 또는 IEx 콘솔에 &lt;code&gt;h Enum&lt;/code&gt; 또는 다른 모듈 을 입력 하여이 개념을 살펴 보았습니다 .</target>
        </trans-unit>
        <trans-unit id="de96232518520933630bd7c423b5ed4b701f263c" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;:stdio&lt;/code&gt; and files opened with &lt;code&gt;:utf8&lt;/code&gt; encoding work with the remaining functions in the &lt;code&gt;IO&lt;/code&gt; module. Those functions expect a &lt;code&gt;char_data&lt;/code&gt; as an argument, that is, a list of characters or strings.</source>
          <target state="translated">반면, &lt;code&gt;:stdio&lt;/code&gt; &lt;code&gt;:utf8&lt;/code&gt; 인코딩으로 열린 : stdio 및 파일 은 &lt;code&gt;IO&lt;/code&gt; 모듈 의 나머지 기능과 함께 작동 합니다. 이러한 함수는 &lt;code&gt;char_data&lt;/code&gt; 를 인수, 즉 문자 또는 문자열 목록으로 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="df2f9b99e7ba432ec596beb6110247ffca71c5ac" translate="yes" xml:space="preserve">
          <source>On the other hand, &lt;code&gt;Stream.unfold/2&lt;/code&gt; can be used to generate values from a given initial value:</source>
          <target state="translated">반면에 &lt;code&gt;Stream.unfold/2&lt;/code&gt; 는 주어진 초기 값에서 값을 생성하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b8b9378d09ed0fb2e04b62c07969de258d132e4" translate="yes" xml:space="preserve">
          <source>On the other hand, aliases hold some properties:</source>
          <target state="translated">반면에 별명에는 몇 가지 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cde8a500ad1f4f8eca18ffea106e75b93a90386b" translate="yes" xml:space="preserve">
          <source>On the other hand, function calls without parens are always indented by the function call length itself, like this:</source>
          <target state="translated">반면, parens가없는 함수 호출은 항상 다음과 같이 함수 호출 길이 자체에 의해 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="77e130342c984a0c62222639f83873c823bfc21f" translate="yes" xml:space="preserve">
          <source>On the other hand, if you want to dynamically slice a string based on an integer value, then using &lt;a href=&quot;string#slice/3&quot;&gt;&lt;code&gt;String.slice/3&lt;/code&gt;&lt;/a&gt; is the best option as it guarantees we won't incorrectly split a valid code point into multiple bytes.</source>
          <target state="translated">반면 정수 값을 기준으로 문자열을 동적으로 슬라이스하려면 &lt;a href=&quot;string#slice/3&quot;&gt; &lt;code&gt;String.slice/3&lt;/code&gt; &lt;/a&gt; 를 사용 하는 것이 유효한 코드 포인트를 여러 바이트로 잘못 분할하지 않도록 보장하는 가장 좋은 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="96440900cf2787b3d188e44fb23cf1e92e8dffd8" translate="yes" xml:space="preserve">
          <source>On the other hand, the &lt;a href=&quot;#count/1&quot;&gt;&lt;code&gt;count/1&lt;/code&gt;&lt;/a&gt; function in this protocol should be implemented whenever you can count the number of elements in the collection.</source>
          <target state="translated">반면, 이 프로토콜 의 &lt;a href=&quot;#count/1&quot;&gt; &lt;code&gt;count/1&lt;/code&gt; &lt;/a&gt; 함수는 컬렉션의 요소 수를 계산할 수있을 때마다 구현되어야합니다.</target>
        </trans-unit>
        <trans-unit id="423d94dfd3979b636b7fca2ef0b1fc6c8a58898a" translate="yes" xml:space="preserve">
          <source>Once a function or a macro is marked as overridable, it will no longer be listed under &lt;a href=&quot;#definitions_in/1&quot;&gt;&lt;code&gt;definitions_in/1&lt;/code&gt;&lt;/a&gt; or return true when given to &lt;a href=&quot;#defines?/2&quot;&gt;&lt;code&gt;defines?/2&lt;/code&gt;&lt;/a&gt; until another implementation is given.</source>
          <target state="translated">함수 또는 매크로가 재정의 가능한 것으로 표시 되면 다른 구현이 제공 될 때까지 더 이상 &lt;a href=&quot;#definitions_in/1&quot;&gt; &lt;code&gt;definitions_in/1&lt;/code&gt; 에&lt;/a&gt; 나열되지 않거나 &lt;a href=&quot;#defines?/2&quot;&gt; &lt;code&gt;defines?/2&lt;/code&gt; &lt;/a&gt; 지정된 경우 true를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4be2f449756ad52de4a6efae2bb582fc005c9362" translate="yes" xml:space="preserve">
          <source>Once again, uncomment the last two lines by removing the leading &lt;code&gt;rem &lt;/code&gt; to enable full distribution. And that&amp;rsquo;s all!</source>
          <target state="translated">다시 한번, 전체 분배를 가능하게 하기 위해 선행 &lt;code&gt;rem &lt;/code&gt; 을 제거하여 마지막 두 줄의 주석을 해제하십시오 . 그리고 그게 전부입니다!</target>
        </trans-unit>
        <trans-unit id="cfc893eec70ab96edd7de58796885efa4ba9d8ca" translate="yes" xml:space="preserve">
          <source>Once everything was done, we closed the port.</source>
          <target state="translated">모든 것이 끝나면 포트를 닫았습니다.</target>
        </trans-unit>
        <trans-unit id="1621bce168937a18a32ac1d0bc7a6f51d70958e6" translate="yes" xml:space="preserve">
          <source>Once initialized, the handler should be designed to handle events in the following format:</source>
          <target state="translated">일단 초기화되면 핸들러는 다음 형식으로 이벤트를 처리하도록 설계되어야합니다.</target>
        </trans-unit>
        <trans-unit id="290699e39f3ba4de6a466924dff98cd449d552b7" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;:logger&lt;/code&gt; application starts, it installs all event handlers listed under the &lt;code&gt;:backends&lt;/code&gt; configuration into the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; event manager. The event manager and all added event handlers are automatically supervised by &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;:logger&lt;/code&gt; 애플리케이션이 시작 되면 &lt;code&gt;:backends&lt;/code&gt; 구성 아래에 나열된 모든 이벤트 핸들러 가 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 이벤트 관리자에 설치됩니다. 이벤트 관리자 및 추가 된 모든 이벤트 핸들러는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; 에&lt;/a&gt; 의해 자동으로 감독됩니다 .</target>
        </trans-unit>
        <trans-unit id="bba6866fbd0a67ef6097d91ded25789c9452b004" translate="yes" xml:space="preserve">
          <source>Once the agent is spawned, the given function &lt;code&gt;fun&lt;/code&gt; is invoked in the server process, and should return the initial agent state. Note that &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; does not return until the given function has returned.</source>
          <target state="translated">에이전트가 생성되면 지정된 함수 &lt;code&gt;fun&lt;/code&gt; 이 서버 프로세스에서 호출되며 초기 에이전트 상태를 반환해야합니다. 참고 것을 &lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; 주어진 함수가 반환 될 때까지 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef9558c468b285f17bba1e7f8e7c4f2000f27cc1" translate="yes" xml:space="preserve">
          <source>Once the code above is executed inside an &lt;code&gt;iex&lt;/code&gt; session, IEx will ask if we want to pry into the current code. If accepted, we will be able to access all variables, as well as imports and aliases from the code, directly From IEx. While pry is running, the code execution stops, until &lt;code&gt;continue&lt;/code&gt; is called. Remember you can always run &lt;code&gt;iex&lt;/code&gt; in the context of a project with &lt;code&gt;iex -S mix TASK&lt;/code&gt;.</source>
          <target state="translated">위의 코드가 &lt;code&gt;iex&lt;/code&gt; 세션 내에서 실행되면 IEx는 현재 코드를 들어 올릴 것인지 묻습니다. 수락하면 모든 변수에 액세스 할 수 있으며 코드에서 가져 오기 및 별명뿐만 아니라 IEx에서 직접 액세스 할 수 있습니다. pry가 실행되는 동안 &lt;code&gt;continue&lt;/code&gt; 가 호출 될 때까지 코드 실행이 중지됩니다 . &lt;code&gt;iex -S mix TASK&lt;/code&gt; 를 사용하여 프로젝트 컨텍스트에서 항상 &lt;code&gt;iex&lt;/code&gt; 를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="408c96ed6cd23c6d64030f673253fb9a91f2d8a7" translate="yes" xml:space="preserve">
          <source>Once the current application and its dependencies have been started, you can run a script in its context by passing a filename:</source>
          <target state="translated">현재 응용 프로그램과 해당 종속성이 시작되면 파일 이름을 전달하여 해당 컨텍스트에서 스크립트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4b8a6b7ad11f7671cb5874e92543fc2ebfae2db" translate="yes" xml:space="preserve">
          <source>Once the dynamic supervisor is running, we can start children with &lt;a href=&quot;#start_child/2&quot;&gt;&lt;code&gt;start_child/2&lt;/code&gt;&lt;/a&gt;, which receives a child specification:</source>
          <target state="translated">동적 수퍼바이저가 실행되면 &lt;a href=&quot;#start_child/2&quot;&gt; &lt;code&gt;start_child/2&lt;/code&gt; 로&lt;/a&gt; 자식을 시작할 수 있으며 자식 사양을받습니다.</target>
        </trans-unit>
        <trans-unit id="a1cbb39ac09f145cd85ea1aba9ba9ce063b8a462" translate="yes" xml:space="preserve">
          <source>Once the monitored port process dies, a message is delivered to the monitoring process in the shape of:</source>
          <target state="translated">모니터링 된 포트 프로세스가 종료되면 다음과 같은 형태로 메시지가 모니터링 프로세스에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4f02c5f9ebc7bb88dcb63507719013ed2066f7bf" translate="yes" xml:space="preserve">
          <source>Once the monitored process dies, a message is delivered to the monitoring process in the shape of:</source>
          <target state="translated">모니터링 된 프로세스가 종료되면 다음과 같은 형태로 메시지가 모니터링 프로세스에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4605c758e24d4c33ee6d08e933b8102e776e5d52" translate="yes" xml:space="preserve">
          <source>Once the project is compiled, you can start an &lt;code&gt;iex&lt;/code&gt; session inside the project by running:</source>
          <target state="translated">프로젝트가 컴파일되면 다음 을 실행하여 프로젝트 내에서 &lt;code&gt;iex&lt;/code&gt; 세션을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e867373ffe7847f2db5130572df5f531464178dc" translate="yes" xml:space="preserve">
          <source>Once the project is defined, a number of default Mix tasks can be run directly from the command line:</source>
          <target state="translated">프로젝트가 정의되면 명령 줄에서 여러 가지 기본 믹스 작업을 직접 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6aa7b033fd85bf146e14a8c7160118f513bc8d6" translate="yes" xml:space="preserve">
          <source>Once the registry is started with a given name using &lt;a href=&quot;registry#start_link/1&quot;&gt;&lt;code&gt;Registry.start_link/1&lt;/code&gt;&lt;/a&gt;, it can be used to register and access named processes using the &lt;code&gt;{:via, Registry, {registry, key}}&lt;/code&gt; tuple:</source>
          <target state="translated">&lt;a href=&quot;registry#start_link/1&quot;&gt; &lt;code&gt;Registry.start_link/1&lt;/code&gt; 을&lt;/a&gt; 사용하여 지정된 이름으로 레지스트리를 시작 하면 &lt;code&gt;{:via, Registry, {registry, key}}&lt;/code&gt; 튜플을 사용하여 명명 된 프로세스를 등록하고 액세스하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3120d183e67a369d29bc150b0338b6b8abb5d5d0" translate="yes" xml:space="preserve">
          <source>Once the server is started, the &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; function of the given &lt;code&gt;module&lt;/code&gt; is called with &lt;code&gt;init_arg&lt;/code&gt; as its argument to initialize the server. To ensure a synchronized start-up procedure, this function does not return until &lt;a href=&quot;#c:init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt; has returned.</source>
          <target state="translated">서버가 시작되면 주어진 &lt;code&gt;module&lt;/code&gt; 의 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 함수 가 &lt;code&gt;init_arg&lt;/code&gt; 와 함께 호출되어 서버를 초기화합니다. 동기화 된 시작 절차를 보장하기 위해이 기능은 &lt;a href=&quot;#c:init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; &lt;/a&gt; 이 반환 될 때까지 반환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="737b5a76c492695b1fb2a3499dcde47a6c323b7a" translate="yes" xml:space="preserve">
          <source>Once the server is started, the remaining functions in this module (&lt;a href=&quot;#call/3&quot;&gt;&lt;code&gt;call/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#cast/2&quot;&gt;&lt;code&gt;cast/2&lt;/code&gt;&lt;/a&gt;, and friends) will also accept an atom, or any &lt;code&gt;{:global, ...}&lt;/code&gt; or &lt;code&gt;{:via, ...}&lt;/code&gt; tuples. In general, the following formats are supported:</source>
          <target state="translated">서버가 시작되면이 모듈의 나머지 함수 ( &lt;a href=&quot;#call/3&quot;&gt; &lt;code&gt;call/3&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#cast/2&quot;&gt; &lt;code&gt;cast/2&lt;/code&gt; &lt;/a&gt; 및 friends)도 원자 또는 &lt;code&gt;{:global, ...}&lt;/code&gt; 또는 &lt;code&gt;{:via, ...}&lt;/code&gt; 튜플을 수락합니다 . . 일반적으로 다음 형식이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6cbe4f06fe95e311cfe10127074ff0ebc20f68e2" translate="yes" xml:space="preserve">
          <source>Once the supervisor starts, it will traverse the list of children and it will invoke the &lt;code&gt;child_spec/1&lt;/code&gt; function on each module.</source>
          <target state="translated">수퍼바이저가 시작되면 하위 목록을 순회하며 각 모듈 에서 &lt;code&gt;child_spec/1&lt;/code&gt; 함수를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1aa3fd67c8a0dadb7a1b2d1e3ee5265a0b531a76" translate="yes" xml:space="preserve">
          <source>Once this module is compiled, this information becomes available via the &lt;a href=&quot;code#fetch_docs/1&quot;&gt;&lt;code&gt;Code.fetch_docs/1&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 모듈이 컴파일되면이 정보는 &lt;a href=&quot;code#fetch_docs/1&quot;&gt; &lt;code&gt;Code.fetch_docs/1&lt;/code&gt; &lt;/a&gt; 함수 를 통해 사용할 수있게됩니다 .</target>
        </trans-unit>
        <trans-unit id="ddada7d31dcc026dad66a50326650a75cc9cbb38" translate="yes" xml:space="preserve">
          <source>Once we change &lt;code&gt;setup&lt;/code&gt;, some tests will continue to fail. You may even notice tests pass and fail inconsistently between runs. For example, the &amp;ldquo;spawns buckets&amp;rdquo; test:</source>
          <target state="translated">&lt;code&gt;setup&lt;/code&gt; 을 변경하면 일부 테스트는 계속 실패합니다. 심지어 실행간에 테스트가 통과하고 일관성이없는 것을 확인할 수도 있습니다. 예를 들어 &quot;스폰 버킷&quot;테스트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1fb2639015e7a539ce9fee1573b15649d727fb15" translate="yes" xml:space="preserve">
          <source>Once you exit the telnet client, you will likely see an error in the IEx session:</source>
          <target state="translated">텔넷 클라이언트를 종료하면 IEx 세션에 오류가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66b9a98849835ca0ccdcfc637fc20489cc149751" translate="yes" xml:space="preserve">
          <source>Once your application is compiled, running your system is a matter of starting your current application and its dependencies. Differently from other languages, Elixir does not have a &lt;code&gt;main&lt;/code&gt; procedure that is responsible for starting your system. Instead, you start one or more applications, each with their own initialization and termination logic.</source>
          <target state="translated">응용 프로그램이 컴파일되면 시스템을 실행하는 것은 현재 응용 프로그램과 해당 종속성을 시작하는 문제입니다. 다른 언어와 달리 Elixir에는 시스템 시작을 담당 하는 &lt;code&gt;main&lt;/code&gt; 절차 가 없습니다 . 대신 각각 자체 초기화 및 종료 논리를 사용하여 하나 이상의 응용 프로그램을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="42b067f2517980dc4135d671302e4a77495e8c98" translate="yes" xml:space="preserve">
          <source>Once your library is configured, it will change the behaviour of all users of your library. If a library was expecting it to split the string in 2 parts, since the configuration is global, it will now split it in 3 parts.</source>
          <target state="translated">라이브러리가 구성되면 라이브러리의 모든 사용자의 동작이 변경됩니다. 라이브러리가 문자열을 두 부분으로 나눌 것으로 예상 한 경우 구성이 전역이므로 이제 세 부분으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="818ac58ed024c39752c7d32f5237a41c15a038fb" translate="yes" xml:space="preserve">
          <source>One alternative to GenEvent is a very minimal solution consisting of using a supervisor and multiple GenServers started under it. The supervisor acts as the &quot;event manager&quot; and the children GenServers act as the &quot;event handlers&quot;. This approach has some shortcomings (it provides no backpressure for example) but can still replace GenEvent for low-profile usages of it. &lt;a href=&quot;http://blog.plataformatec.com.br/2016/11/replacing-genevent-by-a-supervisor-genserver/&quot;&gt;This blog post by Jos&amp;eacute; Valim&lt;/a&gt; has more detailed information on this approach.</source>
          <target state="translated">GenEvent의 한 가지 대안은 수퍼바이저와 여러 GenServer를 사용하여 구성된 최소 솔루션입니다. 수퍼바이저는 &quot;이벤트 관리자&quot;역할을하고 자식 GenServer는 &quot;이벤트 핸들러&quot;역할을합니다. 이 방법에는 단점이 있지만 (예를 들어 역압을 제공하지는 않지만) 낮은 프로파일 사용으로 GenEvent를 대체 할 수 있습니다. &lt;a href=&quot;http://blog.plataformatec.com.br/2016/11/replacing-genevent-by-a-supervisor-genserver/&quot;&gt;Jos&amp;eacute; Valim의이 블로그 게시물&lt;/a&gt; 에는이 접근 방식에 대한 자세한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="936a273dad718f4cb0bdcd05e022e88904985504" translate="yes" xml:space="preserve">
          <source>One drawback of IO data is that you can't do things like pattern match on the first part of a piece of IO data like you can with a binary, because you usually don't know the shape of the IO data. In those cases, you may need to convert it to a binary by calling &lt;a href=&quot;#iodata_to_binary/1&quot;&gt;&lt;code&gt;iodata_to_binary/1&lt;/code&gt;&lt;/a&gt;, which is reasonably efficient since it's implemented natively in C. Other functionality, like computing the length of IO data, can be computed directly on the iodata by calling &lt;a href=&quot;#iodata_length/1&quot;&gt;&lt;code&gt;iodata_length/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">IO 데이터의 한 가지 단점은 일반적으로 IO 데이터의 모양을 알지 못하기 때문에 바이너리와 같이 IO 데이터의 첫 부분에서 패턴 일치와 같은 작업을 수행 할 수 없다는 것입니다. 이 경우 &lt;a href=&quot;#iodata_to_binary/1&quot;&gt; &lt;code&gt;iodata_to_binary/1&lt;/code&gt; &lt;/a&gt; 을 호출하여 바이너리로 변환해야 할 수도 있습니다. iodata_to_binary / 1 은 C에서 기본적으로 구현되므로 상당히 효율적입니다. IO 데이터 길이 계산과 같은 다른 기능은 iodata에서 직접 호출하여 계산할 수 있습니다 &lt;a href=&quot;#iodata_length/1&quot;&gt; &lt;code&gt;iodata_length/1&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="959154f571cdda30a77c0e7157ebda7245e313d8" translate="yes" xml:space="preserve">
          <source>One example of optional callback in Elixir's standard library is &lt;a href=&quot;genserver#c:format_status/2&quot;&gt;&lt;code&gt;GenServer.format_status/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Elixir 표준 라이브러리에서 선택적 콜백의 한 예는 &lt;a href=&quot;genserver#c:format_status/2&quot;&gt; &lt;code&gt;GenServer.format_status/2&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="682598a408460f45c2b269ef31f62c8ef9525a00" translate="yes" xml:space="preserve">
          <source>One flaw that shows up right away is the ordering issue. Since &lt;code&gt;KV.Registry&lt;/code&gt; invokes &lt;code&gt;KV.BucketSupervisor&lt;/code&gt;, then the &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; must be started before &lt;code&gt;KV.Registry&lt;/code&gt;. Otherwise, it may happen that the registry attempts to reach the bucket supervisor before it has started.</source>
          <target state="translated">즉시 나타나는 한 가지 결함은 주문 문제입니다. 이후 &lt;code&gt;KV.Registry&lt;/code&gt; 가 호출 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 을 다음 &lt;code&gt;KV.BucketSupervisor&lt;/code&gt; 가 먼저 시작되어야 &lt;code&gt;KV.Registry&lt;/code&gt; . 그렇지 않으면 레지스트리가 시작되기 전에 레지스트리가 버킷 관리자에 도달하려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e4f2997cd25bc613534eada98471130bd76e1d1" translate="yes" xml:space="preserve">
          <source>One may also consider passing the &lt;code&gt;:delayed_write&lt;/code&gt; option if the stream is meant to be written to under a tight loop.</source>
          <target state="translated">스트림이 타이트한 루프 아래에 쓰여지는 경우 &lt;code&gt;:delayed_write&lt;/code&gt; 옵션을 전달하는 것도 고려할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfde78399ed297a92cd58c53e350baeaf0f353fe" translate="yes" xml:space="preserve">
          <source>One may be tempted to write:</source>
          <target state="translated">하나는 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1781595a1670e5536e6aa5b4d9e3408ffa2c5bc3" translate="yes" xml:space="preserve">
          <source>One may have expected it to ceil to -12.52. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as -12.51999999, which explains the behaviour above.</source>
          <target state="translated">-12.52로 중단 될 것으로 예상했을 수 있습니다. 이것은 버그가 아닙니다. 대부분의 소수는 이진 부동 소수점으로 표현할 수 없으므로 위의 숫자는 내부적으로 -12.51999999로 표시되며 위의 동작을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="243a9890c71db8191808f5cd66bd3e2313e581bb" translate="yes" xml:space="preserve">
          <source>One may have expected it to floor to 12.52. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as 12.51999999, which explains the behaviour above.</source>
          <target state="translated">바닥에 12.52가 될 것으로 예상했을 수 있습니다. 이것은 버그가 아닙니다. 대부분의 소수는 이진 부동 소수점으로 표현할 수 없으므로 위의 숫자는 내부적으로 12.51999999로 표시되며 위의 동작을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="35c338e7afb24d2e6ec4b29eabef0038bd79d2c7" translate="yes" xml:space="preserve">
          <source>One may have expected it to round to the half up 5.568. This is not a bug. Most decimal fractions cannot be represented as a binary floating point and therefore the number above is internally represented as 5.567499999, which explains the behaviour above. If you want exact rounding for decimals, you must use a decimal library. The behaviour above is also in accordance to reference implementations, such as &quot;Correctly Rounded Binary-Decimal and Decimal-Binary Conversions&quot; by David M. Gay.</source>
          <target state="translated">하나는 5.568로 반으로 올릴 것으로 예상했을 수 있습니다. 이것은 버그가 아닙니다. 대부분의 소수는 이진 부동 소수점으로 표현할 수 없으므로 위의 숫자는 내부적으로 5.567499999로 표시되며 위의 동작을 설명합니다. 소수점을 정확하게 반올림하려면 소수점 라이브러리를 사용해야합니다. 위의 동작은 또한 David M. Gay의 &quot;올바른 반올림 이진 십진 및 십진 이진 변환&quot;과 같은 참조 구현에 따른 것입니다.</target>
        </trans-unit>
        <trans-unit id="75e244bba7b8a676a5ca57c1abcc6a33d031ea31" translate="yes" xml:space="preserve">
          <source>One of Elixir&amp;rsquo;s goals is extensibility: developers should be able to extend the language to fit any particular domain. Computer science has become such a wide field that it is impossible for a language to tackle many fields as part of its core. Rather, our best bet is to make the language extensible, so developers, companies, and communities can extend the language to their relevant domains.</source>
          <target state="translated">Elixir의 목표 중 하나는 확장 성입니다. 개발자는 특정 도메인에 맞게 언어를 확장 할 수 있어야합니다. 컴퓨터 과학은 광범위한 분야가되어 언어가 핵심의 일부로 많은 분야를 다루는 것이 불가능합니다. 오히려 우리의 최선의 방법은 언어를 확장 가능하게하여 개발자, 회사 및 커뮤니티가 언어를 관련 영역으로 확장 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="442f0d53f86c717b454c40ddbdea4b216903b62b" translate="yes" xml:space="preserve">
          <source>One of the common uses of tasks is to convert sequential code into concurrent code with &lt;a href=&quot;task#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt; while keeping its semantics. When invoked, a new process will be created, linked and monitored by the caller. Once the task action finishes, a message will be sent to the caller with the result.</source>
          <target state="translated">작업의 일반적인 용도 중 하나는 의미를 유지하면서 순차적 코드를 &lt;a href=&quot;task#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt; 을 사용하여 동시 코드로 변환 하는 것입니다. 호출되면 호출자가 새 프로세스를 작성, 링크 및 모니터링합니다. 작업 작업이 완료되면 결과와 함께 메시지가 발신자에게 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="45e3c4f5c17e2b30b01adb9fc6c7523fd8a1551d" translate="yes" xml:space="preserve">
          <source>One of the complexities in relying on system times is that they may be adjusted. For example, when you enter and leave daylight saving time, the system clock will be adjusted, often adding or removing one hour. We call such changes &quot;time warps&quot;. In order to understand how such changes may be harmful, imagine the following code:</source>
          <target state="translated">시스템 시간에 의존하는 복잡성 중 하나는 조정될 수 있다는 것입니다. 예를 들어, 일광 절약 시간을 입력 및 종료하면 시스템 시간이 조정되어 종종 1 시간을 추가하거나 제거합니다. 우리는 그러한 변화를 &quot;시간 왜곡&quot;이라고 부릅니다. 이러한 변경이 어떻게 유해 할 수 있는지 이해하려면 다음 코드를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="70db34f5d258e3970e35422bd42e5f7aa8840920" translate="yes" xml:space="preserve">
          <source>One of the few times where it is acceptable to start a process outside of a supervision tree is with &lt;a href=&quot;task#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;task#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt;. Opposite to &lt;a href=&quot;task#start_link/1&quot;&gt;&lt;code&gt;Task.start_link/1&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;async/await&lt;/code&gt; mechanism gives you full control over the spawned process life cycle - which is also why you must always call &lt;a href=&quot;task#await/2&quot;&gt;&lt;code&gt;Task.await/2&lt;/code&gt;&lt;/a&gt; after starting a task with &lt;a href=&quot;task#async/1&quot;&gt;&lt;code&gt;Task.async/1&lt;/code&gt;&lt;/a&gt;. Even though, if your application is spawning multiple async processes, you should consider using &lt;a href=&quot;task.supervisor&quot;&gt;&lt;code&gt;Task.Supervisor&lt;/code&gt;&lt;/a&gt; for better visibility when instrumenting and monitoring the system.</source>
          <target state="translated">감독 트리 외부에서 프로세스를 시작할 수있는 몇 가지 시간 중 하나는 &lt;a href=&quot;task#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;task#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;task#start_link/1&quot;&gt; &lt;code&gt;Task.start_link/1&lt;/code&gt; &lt;/a&gt; 과는 반대로 &lt;code&gt;async/await&lt;/code&gt; 메커니즘은 생성 된 프로세스 수명주기를 완전히 제어 할 수 있도록합니다 . &lt;a href=&quot;task#async/1&quot;&gt; &lt;code&gt;Task.async/1&lt;/code&gt; &lt;/a&gt; 로 작업을 시작한 후 항상 &lt;a href=&quot;task#await/2&quot;&gt; &lt;code&gt;Task.await/2&lt;/code&gt; 를&lt;/a&gt; 호출해야합니다 . 그러나 응용 프로그램이 여러 비동기 프로세스를 생성하는 경우 시스템 계측 및 모니터링시 가시성 을 &lt;a href=&quot;task.supervisor&quot;&gt; &lt;code&gt;Task.Supervisor&lt;/code&gt; &lt;/a&gt; 위해 Task.Supervisor 사용을 고려해야 합니다.</target>
        </trans-unit>
        <trans-unit id="50df693ec447426e4660f01fa52af9e0c7763ea8" translate="yes" xml:space="preserve">
          <source>One of the files generated by &lt;code&gt;mix new&lt;/code&gt; is the &lt;code&gt;.formatter.exs&lt;/code&gt;. Elixir ships with a code formatter that is capable of automatically formatting our codebase according to a consistent style. The formatter is triggered with the &lt;code&gt;mix format&lt;/code&gt; task. The generated &lt;code&gt;.formatter.exs&lt;/code&gt; file configures which files should be formatted when &lt;code&gt;mix format&lt;/code&gt; runs.</source>
          <target state="translated">&lt;code&gt;mix new&lt;/code&gt; 가 생성 한 파일 중 하나는 &lt;code&gt;.formatter.exs&lt;/code&gt; 입니다. Elixir는 일관된 스타일에 따라 코드베이스를 자동으로 포맷 할 수있는 코드 포맷터와 함께 제공됩니다. 포맷터는 &lt;code&gt;mix format&lt;/code&gt; 작업 으로 트리거됩니다 . 생성 된 &lt;code&gt;.formatter.exs&lt;/code&gt; 파일은 &lt;code&gt;mix format&lt;/code&gt; 실행될 때 형식을 지정할 파일을 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="e9bea613040d7bfb9b683e8ec5d094125d04fc14" translate="yes" xml:space="preserve">
          <source>One of the projects in the Elixir organization is &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt;the &lt;code&gt;Plug&lt;/code&gt; project&lt;/a&gt;, which is meant to be a common foundation for building web libraries and frameworks in Elixir.</source>
          <target state="translated">엘릭서 조직의 프로젝트 중 하나는 &lt;a href=&quot;https://github.com/elixir-lang/plug&quot;&gt; &lt;code&gt;Plug&lt;/code&gt; &lt;/a&gt; 프로젝트 엘릭서에서 웹 라이브러리와 프레임 워크를 구축하기위한 공통의 기반이 될하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8bc47161c9d9f59158e06bc671097821742b5b3c" translate="yes" xml:space="preserve">
          <source>One should not rely on the specific formats returned by each of those fields. Instead one should use specialized functions, such as &lt;a href=&quot;#version/0&quot;&gt;&lt;code&gt;version/0&lt;/code&gt;&lt;/a&gt; to retrieve the Elixir version and &lt;a href=&quot;#otp_release/0&quot;&gt;&lt;code&gt;otp_release/0&lt;/code&gt;&lt;/a&gt; to retrieve the Erlang/OTP release.</source>
          <target state="translated">각 필드에서 반환 된 특정 형식에 의존해서는 안됩니다. 대신 &lt;a href=&quot;#version/0&quot;&gt; &lt;code&gt;version/0&lt;/code&gt; &lt;/a&gt; 과 같은 특수 기능을 사용 하여 Elixir 버전을 검색하고 &lt;a href=&quot;#otp_release/0&quot;&gt; &lt;code&gt;otp_release/0&lt;/code&gt; &lt;/a&gt; 을 사용하여 Erlang / OTP 릴리스를 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="3debe928eb1b5c8e87fe15888723579e1f0c4c11" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to disable unquoting in the macro, however, doing that would make it impossible to inject the &lt;code&gt;kv&lt;/code&gt; representation into the tree. That's when the &lt;code&gt;:bind_quoted&lt;/code&gt; option comes to the rescue (again!). By using &lt;code&gt;:bind_quoted&lt;/code&gt;, we can automatically disable unquoting while still injecting the desired variables into the tree:</source>
          <target state="translated">이 문제에 대한 한 가지 해결책은 매크로에서 인용 부호를 해제하는 것입니다. 그러나 이렇게하면 &lt;code&gt;kv&lt;/code&gt; 표현을 트리 에 주입 할 수 없습니다 . 그때 &lt;code&gt;:bind_quoted&lt;/code&gt; 옵션이 구출됩니다 (다시!). &lt;code&gt;:bind_quoted&lt;/code&gt; 를 사용 하면 트리에 원하는 변수를 계속 주입하면서 인용 부호를 자동으로 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d34436b8b519d619492a7f6d60f8ee6b7577de85" translate="yes" xml:space="preserve">
          <source>One thing to keep in mind when using &lt;code&gt;do/end&lt;/code&gt; blocks is they are always bound to the outermost function call. For example, the following expression:</source>
          <target state="translated">&lt;code&gt;do/end&lt;/code&gt; 블록을 사용할 때 명심해야 할 것은 항상 가장 바깥 쪽 함수 호출에 바인딩되어 있다는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e4d62621d7dc89fa232dc83ec13aa33f3a32463" translate="yes" xml:space="preserve">
          <source>One-liner examples</source>
          <target state="translated">한 줄짜리 예</target>
        </trans-unit>
        <trans-unit id="76d560c48bdb5ca6e530c94b3e593f70eea7f4cf" translate="yes" xml:space="preserve">
          <source>Only a single break point can be set per function. So if you call &lt;code&gt;IEx.break!&lt;/code&gt; multiple times with different patterns, only the last pattern is kept.</source>
          <target state="translated">기능 당 하나의 중단 점 만 설정할 수 있습니다. 따라서 &lt;code&gt;IEx.break!&lt;/code&gt; 를 호출 하면! 다른 패턴으로 여러 번 마지막 패턴 만 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="91104ae4893712c54ab7b2c242913ddbdd74161a" translate="yes" xml:space="preserve">
          <source>Only registries with unique keys can be used in &lt;code&gt;:via&lt;/code&gt;. If the name is already taken, the case-specific &lt;code&gt;start_link&lt;/code&gt; function (&lt;a href=&quot;agent#start_link/2&quot;&gt;&lt;code&gt;Agent.start_link/2&lt;/code&gt;&lt;/a&gt; in the example above) will return &lt;code&gt;{:error, {:already_started, current_pid}}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:via&lt;/code&gt; 에서는 고유 키가있는 레지스트리 만 사용할 수 있습니다 . 이름이 이미 사용 된 경우, 케이스 별 &lt;code&gt;start_link&lt;/code&gt; 함수 ( &lt;a href=&quot;agent#start_link/2&quot;&gt; &lt;code&gt;Agent.start_link/2&lt;/code&gt; &lt;/a&gt; 위의 예)를 반환 &lt;code&gt;{:error, {:already_started, current_pid}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8370e504155b094c81379fca456a5fed9430a083" translate="yes" xml:space="preserve">
          <source>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will raise an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ISO 캘린더에있는 날짜 또는 자정에 시작되는 다른 캘린더 만 변환 할 수 있습니다. 다른 달력에서 날짜를 변환하려고하면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="46f4e449cb60e2a60400c8cc32b9bd80531293a3" translate="yes" xml:space="preserve">
          <source>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will raise.</source>
          <target state="translated">ISO 캘린더에있는 날짜 또는 자정에 시작되는 다른 캘린더 만 변환 할 수 있습니다. 다른 달력에서 날짜를 변환하려고하면 증가합니다.</target>
        </trans-unit>
        <trans-unit id="9f0d1de9c28799182839cd339d3cb6bcc84675dc" translate="yes" xml:space="preserve">
          <source>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will return an error tuple.</source>
          <target state="translated">ISO 캘린더에있는 날짜 또는 자정에 시작되는 다른 캘린더 만 변환 할 수 있습니다. 다른 달력에서 날짜를 변환하려고하면 오류 튜플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="30f7e5d05978072f24365b5caff95955f0fd6ddc" translate="yes" xml:space="preserve">
          <source>Only supports converting datetimes which are in the ISO calendar, attempting to convert datetimes from other calendars will raise.</source>
          <target state="translated">ISO 달력에있는 날짜 시간 변환 만 지원하며 다른 달력에서 날짜 시간 변환을 시도하면 증가합니다.</target>
        </trans-unit>
        <trans-unit id="22f0d29bfd1420b0788307cfc97c7fee840e6505" translate="yes" xml:space="preserve">
          <source>Only supports converting naive datetimes which are in the ISO calendar, attempting to convert naive datetimes from other calendars will raise.</source>
          <target state="translated">ISO 달력에있는 순진 날짜 시간 변환 만 지원하며 다른 달력에서 순진 날짜 시간 변환을 시도하면 증가합니다.</target>
        </trans-unit>
        <trans-unit id="332d85692072489eba14a228f056afbb7b36291a" translate="yes" xml:space="preserve">
          <source>Only the result of the tried expression falls down to the &lt;code&gt;else&lt;/code&gt; clause. If the &lt;code&gt;try&lt;/code&gt; ends up in the &lt;code&gt;rescue&lt;/code&gt; or &lt;code&gt;catch&lt;/code&gt; clauses, their result will not fall down to &lt;code&gt;else&lt;/code&gt;:</source>
          <target state="translated">시도한 표현식의 결과 만 &lt;code&gt;else&lt;/code&gt; 절로 떨어집니다 . 는 IF &lt;code&gt;try&lt;/code&gt; 에서 끝나는 &lt;code&gt;rescue&lt;/code&gt; 또는 &lt;code&gt;catch&lt;/code&gt; 조항, 그 결과는 아래로 떨어지지 않을 &lt;code&gt;else&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a6a0905b9fcc638e0a1fca8f76bccd9e9d7434ee" translate="yes" xml:space="preserve">
          <source>Only two-element tuples are considered literals in Elixir and return themselves when quoted. Therefore, all other tuples are represented in the AST as calls to the &lt;code&gt;:{}&lt;/code&gt; special form.</source>
          <target state="translated">엘릭서에서는 2 요소 튜플 만 리터럴로 간주되며 인용시 스스로 반환합니다. 따라서 다른 모든 튜플은 AST에서 &lt;code&gt;:{}&lt;/code&gt; 특수 양식 에 대한 호출로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="16aa064c9dc61340a6a7ced2fa58dff653a9081d" translate="yes" xml:space="preserve">
          <source>Oops, it&amp;rsquo;s already started. Mix normally starts the whole hierarchy of applications defined in our project&amp;rsquo;s &lt;code&gt;mix.exs&lt;/code&gt; file and it does the same for all dependencies if they depend on other applications.</source>
          <target state="translated">죄송합니다. 이미 시작되었습니다. 믹스는 일반적으로 프로젝트의 &lt;code&gt;mix.exs&lt;/code&gt; 파일에 정의 된 애플리케이션의 전체 계층을 시작하며 다른 애플리케이션에 의존하는 경우 모든 종속성에 대해 동일하게 수행합니다.</target>
        </trans-unit>
        <trans-unit id="626c544948c998858d0a89d08603d35b395d1a8e" translate="yes" xml:space="preserve">
          <source>Open mechanisms</source>
          <target state="translated">개방 메커니즘</target>
        </trans-unit>
        <trans-unit id="3f9c7fb45e8ae0a5da7732a25ef64d2dd5e2f563" translate="yes" xml:space="preserve">
          <source>Open up &lt;code&gt;apps/kv/mix.exs&lt;/code&gt; and change the &lt;code&gt;application/0&lt;/code&gt; function to return the following:</source>
          <target state="translated">&lt;code&gt;apps/kv/mix.exs&lt;/code&gt; 를 열고 &lt;code&gt;application/0&lt;/code&gt; 함수를 변경 하여 다음을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="11e01c21d7ba4061c620362e2623f958eae1be36" translate="yes" xml:space="preserve">
          <source>Open up &lt;code&gt;iex&lt;/code&gt; and type the following expressions:</source>
          <target state="translated">&lt;code&gt;iex&lt;/code&gt; 를 열고 다음 표현식을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="d7a32c8b909bef4e4cf763fd044d2d69bd11d7c1" translate="yes" xml:space="preserve">
          <source>Open up &lt;code&gt;lib/kv/registry.ex&lt;/code&gt;, and let&amp;rsquo;s change its implementation. We&amp;rsquo;ve added comments to the source code to highlight the changes we&amp;rsquo;ve made:</source>
          <target state="translated">&lt;code&gt;lib/kv/registry.ex&lt;/code&gt; 를 열고 구현을 변경합시다. 변경 사항을 강조하기 위해 소스 코드에 주석을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="d182cf46ee852ebeb083e187ed597b6979eb7f37" translate="yes" xml:space="preserve">
          <source>Open up &lt;code&gt;lib/kv/supervisor.ex&lt;/code&gt; and add the dynamic supervisor as a child as follows:</source>
          <target state="translated">&lt;code&gt;lib/kv/supervisor.ex&lt;/code&gt; 를 열고 다음과 같이 동적 수퍼바이저를 하위로 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="27d3d6fb25a7f593cdb34dc77c7c498cc6061a34" translate="yes" xml:space="preserve">
          <source>Open up a file, replace all &lt;code&gt;#&lt;/code&gt; by &lt;code&gt;%&lt;/code&gt; and stream to another file without loading the whole file in memory:</source>
          <target state="translated">파일을 열고 모든 &lt;code&gt;#&lt;/code&gt; 을 &lt;code&gt;%&lt;/code&gt; 로 바꾸고 전체 파일을 메모리에로드하지 않고 다른 파일로 스트리밍하십시오.</target>
        </trans-unit>
        <trans-unit id="ece7b632859c06af3b4a35143bf4f0fa432ea01f" translate="yes" xml:space="preserve">
          <source>Opens a port given a tuple &lt;code&gt;name&lt;/code&gt; and a list of &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">튜플 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;options&lt;/code&gt; 목록이 지정된 포트를 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="3bf9b6c6020d1727c93ab3183dfda7cf9cd39780" translate="yes" xml:space="preserve">
          <source>Opens the current prying location.</source>
          <target state="translated">현재 프라이 위치를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="7ac9350441fbbb582d3cc2a8956eb86730e74983" translate="yes" xml:space="preserve">
          <source>Opens the given &lt;code&gt;module&lt;/code&gt;, &lt;code&gt;module.function/arity&lt;/code&gt;, or &lt;code&gt;{file, line}&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;module&lt;/code&gt; , &lt;code&gt;module.function/arity&lt;/code&gt; 또는 &lt;code&gt;{file, line}&lt;/code&gt; 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="5014597cdb33f83d370a77bd5b4dfd1154807086" translate="yes" xml:space="preserve">
          <source>Opens the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;path&lt;/code&gt; 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="11fb7a6db2170c9e59b49c5c2c758efde86398a0" translate="yes" xml:space="preserve">
          <source>Operating System environment configuration</source>
          <target state="translated">운영 체제 환경 구성</target>
        </trans-unit>
        <trans-unit id="46f82301da497c0a0c802e4991b6eca2df33534d" translate="yes" xml:space="preserve">
          <source>Operating the stream can fail on open for the same reasons as &lt;a href=&quot;file#open!/2&quot;&gt;&lt;code&gt;File.open!/2&lt;/code&gt;&lt;/a&gt;. Note that the file is automatically opened each time streaming begins. There is no need to pass &lt;code&gt;:read&lt;/code&gt; and &lt;code&gt;:write&lt;/code&gt; modes, as those are automatically set by Elixir.</source>
          <target state="translated">&lt;a href=&quot;file#open!/2&quot;&gt; &lt;code&gt;File.open!/2&lt;/code&gt; &lt;/a&gt; 와 같은 이유로 스트림 작동이 실패 할 수 있습니다 . 스트리밍이 시작될 때마다 파일이 자동으로 열립니다. &lt;code&gt;:read&lt;/code&gt; 및 &lt;code&gt;:write&lt;/code&gt; 모드는 Elixir에 의해 자동으로 설정되므로 통과 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="0c395ef963d75a809b690d9db937d93c13ee8b98" translate="yes" xml:space="preserve">
          <source>Operator precedence and associativity</source>
          <target state="translated">연산자 우선 순위 및 연관성</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="e0733d98d125d129b916b0d8e46a91b56da34c0e" translate="yes" xml:space="preserve">
          <source>Operators are also represented as such tuples:</source>
          <target state="translated">연산자는 다음과 같은 튜플로도 나타납니다.</target>
        </trans-unit>
        <trans-unit id="15dcbf2455ba217cc0f09140af8c2a19b7a3afae" translate="yes" xml:space="preserve">
          <source>Operators are treated as non-qualified calls:</source>
          <target state="translated">교환 원은 비 규격 통화로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="4a5600ebb83847e5cb5c012f92e0a86888c5caba" translate="yes" xml:space="preserve">
          <source>Opposite of &lt;a href=&quot;#zip/2&quot;&gt;&lt;code&gt;zip/2&lt;/code&gt;&lt;/a&gt;. Extracts two-element tuples from the given &lt;code&gt;enumerable&lt;/code&gt; and groups them together.</source>
          <target state="translated">&lt;a href=&quot;#zip/2&quot;&gt; &lt;code&gt;zip/2&lt;/code&gt; 의&lt;/a&gt; 반대 . 주어진 &lt;code&gt;enumerable&lt;/code&gt; 에서 두 요소 튜플을 추출 하여 함께 그룹화합니다.</target>
        </trans-unit>
        <trans-unit id="c4b9a19c8a84c9a632d32f40f93da320901bb185" translate="yes" xml:space="preserve">
          <source>Opposite to &lt;a href=&quot;#log/3&quot;&gt;&lt;code&gt;log/3&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#debug/2&quot;&gt;&lt;code&gt;debug/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#info/2&quot;&gt;&lt;code&gt;info/2&lt;/code&gt;&lt;/a&gt;, and friends, the arguments given to &lt;a href=&quot;#bare_log/3&quot;&gt;&lt;code&gt;bare_log/3&lt;/code&gt;&lt;/a&gt; are always evaluated. However, you can pass anonymous functions to &lt;a href=&quot;#bare_log/3&quot;&gt;&lt;code&gt;bare_log/3&lt;/code&gt;&lt;/a&gt; and they will only be evaluated if there is something to be logged.</source>
          <target state="translated">반대하는 &lt;a href=&quot;#log/3&quot;&gt; &lt;code&gt;log/3&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#debug/2&quot;&gt; &lt;code&gt;debug/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#info/2&quot;&gt; &lt;code&gt;info/2&lt;/code&gt; &lt;/a&gt; , 친구, 주어진 인수 &lt;a href=&quot;#bare_log/3&quot;&gt; &lt;code&gt;bare_log/3&lt;/code&gt; &lt;/a&gt; 항상 평가된다. 그러나 익명 함수를 &lt;a href=&quot;#bare_log/3&quot;&gt; &lt;code&gt;bare_log/3&lt;/code&gt; 에&lt;/a&gt; 전달할 수 있으며 로깅 할 항목이있는 경우에만 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="ea31b9298bd98dc4502fbe718b66df80ca6668b5" translate="yes" xml:space="preserve">
          <source>Opposite to &lt;a href=&quot;genserver&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;agent&quot;&gt;&lt;code&gt;Agent&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;supervisor&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt;&lt;/a&gt;, a Task has a default &lt;code&gt;:restart&lt;/code&gt; of &lt;code&gt;:temporary&lt;/code&gt;. This means the task will not be restarted even if it crashes. If you desire the task to be restarted for non-successful exits, do:</source>
          <target state="translated">&lt;a href=&quot;genserver&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;agent&quot;&gt; &lt;code&gt;Agent&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;supervisor&quot;&gt; &lt;code&gt;Supervisor&lt;/code&gt; &lt;/a&gt; 와 반대로 작업의 기본값은 &lt;code&gt;:restart&lt;/code&gt; of &lt;code&gt;:temporary&lt;/code&gt; 입니다. 즉, 작업이 충돌하더라도 작업이 다시 시작되지 않습니다. 성공적이지 않은 종료에 대해 태스크를 다시 시작하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9edd3623396f77bd089667c715207bed5bf71fe2" translate="yes" xml:space="preserve">
          <source>Opposite to compile, dependencies are not attempted to be automatically solved between files.</source>
          <target state="translated">컴파일과는 반대로, 파일 간 종속성을 자동으로 해결하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e639bcdcf91aa8ac42e5d8553bb30970a11ad173" translate="yes" xml:space="preserve">
          <source>Option values used by &lt;code&gt;start_link&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;start_link&lt;/code&gt; 에서 사용하는 옵션 값</target>
        </trans-unit>
        <trans-unit id="e4c508aa8815a1256a35a88886de2b38e1af4a2a" translate="yes" xml:space="preserve">
          <source>Option values used by the &lt;code&gt;start*&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;start*&lt;/code&gt; 함수가 사용하는 옵션 값</target>
        </trans-unit>
        <trans-unit id="9c404768d955448d9b6f90547eff35b8e6696cf8" translate="yes" xml:space="preserve">
          <source>OptionParser</source>
          <target state="translated">OptionParser</target>
        </trans-unit>
        <trans-unit id="e0257ae00caf99998e2d72ed84d9c0a4e5e38be0" translate="yes" xml:space="preserve">
          <source>OptionParser.ParseError</source>
          <target state="translated">OptionParser.ParseError</target>
        </trans-unit>
        <trans-unit id="418ba9c55c2dcefb7a2a957a84d702de99023f76" translate="yes" xml:space="preserve">
          <source>OptionParser.ParseError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">OptionParser.ParseError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="515bcb488bbc0e14192e6cad5140e9aea8b7fd33" translate="yes" xml:space="preserve">
          <source>Optional callbacks</source>
          <target state="translated">선택적 콜백</target>
        </trans-unit>
        <trans-unit id="ac614b09920ca40871efbb0a82438a90f0dbe49b" translate="yes" xml:space="preserve">
          <source>Optional callbacks are callbacks that callback modules may implement if they want to, but are not required to. Usually, behaviour modules know if they should call those callbacks based on configuration, or they check if the callbacks are defined with &lt;a href=&quot;kernel#function_exported?/3&quot;&gt;&lt;code&gt;function_exported?/3&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;kernel#macro_exported?/3&quot;&gt;&lt;code&gt;macro_exported?/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 콜백은 필요한 경우 콜백 모듈이 구현할 수있는 콜백입니다. 일반적으로 동작 모듈은 구성에 따라 콜백을 호출해야하는지 또는 콜백이 &lt;a href=&quot;kernel#function_exported?/3&quot;&gt; &lt;code&gt;function_exported?/3&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;kernel#macro_exported?/3&quot;&gt; &lt;code&gt;macro_exported?/3&lt;/code&gt; &lt;/a&gt; 로 정의되어 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="ec7e5f711e91c3eb5ab6694cb992141e2b1d0f09" translate="yes" xml:space="preserve">
          <source>Optional callbacks can be defined through the &lt;code&gt;@optional_callbacks&lt;/code&gt; module attribute, which has to be a keyword list with function or macro name as key and arity as value. For example:</source>
          <target state="translated">선택적 콜백은 &lt;code&gt;@optional_callbacks&lt;/code&gt; 모듈 속성을 통해 정의 할 수 있습니다.이 속성은 함수 또는 매크로 이름이 키이고 arity가 값인 키워드 목록이어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6499468fb5a027c6923e49d62405caa882b21c9" translate="yes" xml:space="preserve">
          <source>Optional parentheses</source>
          <target state="translated">선택적 괄호</target>
        </trans-unit>
        <trans-unit id="1d0891bf09a71f28636a589d4b0d02b002898904" translate="yes" xml:space="preserve">
          <source>Optionally, it is possible to pass a list of guard conditions for more precise matching. Each guard is a tuple, which describes checks that should be passed by assigned part of pattern. For example the &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; guard condition would be expressed as the &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; tuple. Please note that guard conditions will work only for assigned variables like &lt;code&gt;:&quot;$1&quot;&lt;/code&gt;, &lt;code&gt;:&quot;$2&quot;&lt;/code&gt;, etc. Avoid usage of special match variables &lt;code&gt;:&quot;$_&quot;&lt;/code&gt; and &lt;code&gt;:&quot;$$&quot;&lt;/code&gt;, because it might not work as expected.</source>
          <target state="translated">선택적으로보다 정확한 일치를 위해 보호 조건 목록을 전달할 수 있습니다. 각 가드는 튜플이며 지정된 패턴 부분이 통과해야하는 검사를 설명합니다. 예를 들어 &lt;code&gt;$1 &amp;gt; 1&lt;/code&gt; 가드 조건은 &lt;code&gt;{:&amp;gt;, :&quot;$1&quot;, 1}&lt;/code&gt; 튜플로 표현됩니다. 보호 조건은 &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; , &lt;code&gt;:&quot;$2&quot;&lt;/code&gt; 등의 지정된 변수에 대해서만 작동합니다 . 특수 일치 변수 &lt;code&gt;:&quot;$_&quot;&lt;/code&gt; 및 &lt;code&gt;:&quot;$$&quot;&lt;/code&gt; 는 예상대로 작동하지 않을 수 있으므로 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="7a09f1485253101de1cd882c67ecfea3b7b67e2b" translate="yes" xml:space="preserve">
          <source>Options can be:</source>
          <target state="translated">옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="efaa2b27718160760d18ba74e06c5819b7a4ab29" translate="yes" xml:space="preserve">
          <source>Options given to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#init/1&quot;&gt;&lt;code&gt;init/1&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#init/1&quot;&gt; &lt;code&gt;init/1&lt;/code&gt; 에&lt;/a&gt; 제공된 옵션</target>
        </trans-unit>
        <trans-unit id="5eae55a87aa27e83c0b98f403b07f3b4076428b4" translate="yes" xml:space="preserve">
          <source>Options given to &lt;a href=&quot;#start_link/2&quot;&gt;&lt;code&gt;start_link/2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#init/2&quot;&gt;&lt;code&gt;init/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#start_link/2&quot;&gt; &lt;code&gt;start_link/2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#init/2&quot;&gt; &lt;code&gt;init/2&lt;/code&gt; 에&lt;/a&gt; 제공된 옵션</target>
        </trans-unit>
        <trans-unit id="058eb4cd0ba0f3ab247b93a59c7b6bffee0a4161" translate="yes" xml:space="preserve">
          <source>Options used by the &lt;code&gt;start*&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;start*&lt;/code&gt; 기능에 사용되는 옵션</target>
        </trans-unit>
        <trans-unit id="52f3f8106feac737e0576442e94ddc74fd873217" translate="yes" xml:space="preserve">
          <source>Or also on pattern matching to extract values out:</source>
          <target state="translated">또는 패턴 일치에서 값을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="110400c4fdb0f6e57b930554b0298f99e6f6579b" translate="yes" xml:space="preserve">
          <source>Or also via pattern matching:</source>
          <target state="translated">또는 패턴 일치를 통해 :</target>
        </trans-unit>
        <trans-unit id="2b8a5d79778b4d39ad8915654992a0b6572ea485" translate="yes" xml:space="preserve">
          <source>Or as a part of function definitions to pattern match:</source>
          <target state="translated">또는 패턴 일치를위한 함수 정의의 일부로 :</target>
        </trans-unit>
        <trans-unit id="81b6497bf8a349effd8966b9cdac67662ea19529" translate="yes" xml:space="preserve">
          <source>Or even use the async/await pattern:</source>
          <target state="translated">또는 async / await 패턴을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="df3698d69c7b1187df56c2f297fdade2ea595981" translate="yes" xml:space="preserve">
          <source>Or on Windows:</source>
          <target state="translated">또는 Windows의 경우 :</target>
        </trans-unit>
        <trans-unit id="c55b30b404c72029dc39b6c0373f88b3c2117b45" translate="yes" xml:space="preserve">
          <source>Or perhaps you want to make the &lt;code&gt;KVServer&lt;/code&gt; port configurable, and the value for the port is only given at runtime:</source>
          <target state="translated">또는 &lt;code&gt;KVServer&lt;/code&gt; 포트를 구성 가능 하게하고 포트 값은 런타임에만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b3c1ba6ffcae31c642695b4056ca652b985d821d" translate="yes" xml:space="preserve">
          <source>Or simply use pattern matching:</source>
          <target state="translated">또는 단순히 패턴 일치를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2e2e0dde765341b0ca22014d3a7b90bc8ecdc978" translate="yes" xml:space="preserve">
          <source>Or to import all functions, you could write:</source>
          <target state="translated">또는 모든 기능을 가져 오려면 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f146bf6e3a2ae8c150e0ba215da5069807c64480" translate="yes" xml:space="preserve">
          <source>Or to set a breakpoint that will stop 10 times:</source>
          <target state="translated">또는 10 번 중단되는 중단 점을 설정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3d348d5449f71e35f5ea0982362377c8a421346b" translate="yes" xml:space="preserve">
          <source>Or to trigger it whenever the second argument is a map with more than one element:</source>
          <target state="translated">또는 두 번째 인수가 둘 이상의 요소가있는 맵일 때마다 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="8b5320509e4f05f8ea43bb4f458da443d14575a8" translate="yes" xml:space="preserve">
          <source>Or, even better:</source>
          <target state="translated">또는 더 나은 :</target>
        </trans-unit>
        <trans-unit id="7346db833d750efbcd6fcd51d602e24a6966464d" translate="yes" xml:space="preserve">
          <source>Or, using the capture syntax:</source>
          <target state="translated">또는 캡처 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="c45740924e5d354064b64521e5aaf12582061570" translate="yes" xml:space="preserve">
          <source>Other agent actions</source>
          <target state="translated">다른 에이전트 작업</target>
        </trans-unit>
        <trans-unit id="cd6ecf7baf7f186954c254a45288721bbe3e452f" translate="yes" xml:space="preserve">
          <source>Other caveats are the impossibility to call count trace BIFs, since breakpoints can only be set on BEAM code; functions calls performed by &lt;code&gt;:cprof&lt;/code&gt; are not traced; the maximum size of a call counter is equal to the host machine's word size (for example, 2147483647 in a 32-bit host).</source>
          <target state="translated">BEAM 코드에서만 중단 점을 설정할 수 있으므로 카운트 트레이스 BIF를 호출 할 수없는 경우도 있습니다. &lt;code&gt;:cprof&lt;/code&gt; 에 의해 수행 된 함수 호출 은 추적되지 않습니다. 콜 카운터의 최대 크기는 호스트 컴퓨터의 워드 크기와 같습니다 (예 : 32 비트 호스트의 2147483647).</target>
        </trans-unit>
        <trans-unit id="dbe1399abe277751b991272fda96ac3cb3827543" translate="yes" xml:space="preserve">
          <source>Other characters represent themselves. Only paths that have exactly the same character in the same position will match. Note that matching is case-sensitive: &lt;code&gt;&quot;a&quot;&lt;/code&gt; will not match &lt;code&gt;&quot;A&quot;&lt;/code&gt;.</source>
          <target state="translated">다른 문자는 자신을 나타냅니다. 같은 위치에 정확히 같은 문자가있는 경로 만 일치합니다. 일치는 대소 문자를 구분합니다. &lt;code&gt;&quot;a&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;A&quot;&lt;/code&gt; 와 일치하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4ce1008fe24127bd6a35c9e94fa13e898855bf85" translate="yes" xml:space="preserve">
          <source>Other constructs are &lt;a href=&quot;kernel.specialforms#for/1&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#with/1&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel.specialforms#try/1&quot;&gt;&lt;code&gt;try/rescue/catch/else&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;kernel#match?/2&quot;&gt;&lt;code&gt;match?/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 구조는 &lt;a href=&quot;kernel.specialforms#for/1&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel.specialforms#with/1&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel.specialforms#try/1&quot;&gt; &lt;code&gt;try/rescue/catch/else&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;kernel#match?/2&quot;&gt; &lt;code&gt;match?/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32b26031f2d4ec505f1490c8e029cbbddc736c20" translate="yes" xml:space="preserve">
          <source>Other errors can be raised with &lt;code&gt;raise/2&lt;/code&gt; passing the error name and a list of keyword arguments:</source>
          <target state="translated">오류 이름과 키워드 인수 목록을 전달하는 &lt;code&gt;raise/2&lt;/code&gt; 를 사용하면 다른 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd317e6d04c14a2ed23576c03ddc173b8001094a" translate="yes" xml:space="preserve">
          <source>Other time zone databases (including ones provided by packages) can be configure as default either via configuration:</source>
          <target state="translated">다른 표준 시간대 데이터베이스 (패키지에서 제공하는 데이터베이스 포함)는 구성을 통해 기본값으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cad5a00eec7472c9a3591c446721f3e6c58c845" translate="yes" xml:space="preserve">
          <source>Other tools and community</source>
          <target state="translated">다른 도구와 커뮤니티</target>
        </trans-unit>
        <trans-unit id="d9b0ed607a935499601e4fd42e28be80554ff28b" translate="yes" xml:space="preserve">
          <source>Otherwise it should return &lt;code&gt;{:error, __MODULE__}&lt;/code&gt; and a default algorithm built on top of &lt;a href=&quot;#reduce/3&quot;&gt;&lt;code&gt;reduce/3&lt;/code&gt;&lt;/a&gt; that runs in linear time will be used.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;{:error, __MODULE__}&lt;/code&gt; 반환해야 하며 선형 시간으로 실행되는 &lt;a href=&quot;#reduce/3&quot;&gt; &lt;code&gt;reduce/3&lt;/code&gt; &lt;/a&gt; 위에 구축 된 기본 알고리즘 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1c81b36166b2eaba733a51d04e61d3fe880c8923" translate="yes" xml:space="preserve">
          <source>Otherwise returns &lt;code&gt;nil&lt;/code&gt; in case the module exists, but it isn't a task or cannot be found.</source>
          <target state="translated">그렇지 않으면 모듈이 존재하지만 작업이 아니거나 찾을 수없는 경우 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="aa826b74ad8c081871b116d8c34cb3e95cd21b98" translate="yes" xml:space="preserve">
          <source>Otherwise the message is sent and &lt;code&gt;:ok&lt;/code&gt; is returned.</source>
          <target state="translated">그렇지 않으면 메시지가 전송되고 &lt;code&gt;:ok&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9cafb8b841614ef77e86d7299d3dbf34c38a0e86" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;KV.Registry&lt;/code&gt; process received a cast with &lt;code&gt;{:create, &quot;shopping&quot;}&lt;/code&gt; and a call with &lt;code&gt;{:lookup, &quot;shopping&quot;}&lt;/code&gt;, in this sequence. &lt;code&gt;GenServer.cast&lt;/code&gt; will immediately return, as soon as the message is sent to the &lt;code&gt;registry&lt;/code&gt;. The &lt;code&gt;GenServer.call&lt;/code&gt; on the other hand, is where we would be waiting for an answer, provided by the above &lt;code&gt;KV.Registry.handle_call&lt;/code&gt; callback.</source>
          <target state="translated">우리 &lt;code&gt;KV.Registry&lt;/code&gt; 의 과정과 주조받은 &lt;code&gt;{:create, &quot;shopping&quot;}&lt;/code&gt; 와 가진 전화 &lt;code&gt;{:lookup, &quot;shopping&quot;}&lt;/code&gt; 이 순서를. 메시지가 &lt;code&gt;registry&lt;/code&gt; 전송 되 자마자 &lt;code&gt;GenServer.cast&lt;/code&gt; 가 즉시 리턴됩니다 . 반면 &lt;code&gt;GenServer.call&lt;/code&gt; 은 위의 &lt;code&gt;KV.Registry.handle_call&lt;/code&gt; 콜백 에서 제공하는 답변을 기다리는 곳 입니다.</target>
        </trans-unit>
        <trans-unit id="32cb7dd97d5b5169235f629b257bf4b1bebebde0" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;kv&lt;/code&gt; application is complete, so it&amp;rsquo;s time to implement the server that will handle the requests we defined in the first chapter:</source>
          <target state="translated">우리의 &lt;code&gt;kv&lt;/code&gt; 응용 프로그램이 완료되면, 우리는 첫 번째 챕터에 정의 된 요청을 처리 할 서버를 구현하는 그것의 시간이 너무 :</target>
        </trans-unit>
        <trans-unit id="fae76d2c8957b5d3f77fc1cdf6ba676bd9429aa5" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;macro_unless&lt;/code&gt; macro received the following:</source>
          <target state="translated">우리 &lt;code&gt;macro_unless&lt;/code&gt; 매크로는 다음을 받았다 :</target>
        </trans-unit>
        <trans-unit id="d411cc3e34a79409af812e8a3926471d9c1101c5" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;mix.exs&lt;/code&gt; defines two public functions: &lt;code&gt;project&lt;/code&gt;, which returns project configuration like the project name and version, and &lt;code&gt;application&lt;/code&gt;, which is used to generate an application file.</source>
          <target state="translated">우리 &lt;code&gt;mix.exs&lt;/code&gt; 는 두 개의 공공 기능 정의 &lt;code&gt;project&lt;/code&gt; , 반환 프로젝트 이름 및 버전과 같은 구성 프로젝트 &lt;code&gt;application&lt;/code&gt; 응용 프로그램 파일을 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4263c0c28d87ce16526214a430448dce9d929e50" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;msg&lt;/code&gt; is printed and &lt;code&gt;print_multiple_times/2&lt;/code&gt; is called again, this time with the second argument set to &lt;code&gt;1&lt;/code&gt;. Because &lt;code&gt;n&lt;/code&gt; is now set to &lt;code&gt;1&lt;/code&gt;, the guard in our first definition of &lt;code&gt;print_multiple_times/2&lt;/code&gt; evaluates to true, and we execute this particular definition. The &lt;code&gt;msg&lt;/code&gt; is printed, and there is nothing left to execute.</source>
          <target state="translated">우리의 &lt;code&gt;msg&lt;/code&gt; 가 인쇄되고 &lt;code&gt;print_multiple_times/2&lt;/code&gt; 가 다시 호출됩니다. 이번에는 두 번째 인수가 &lt;code&gt;1&lt;/code&gt; 로 설정되었습니다 . &lt;code&gt;n&lt;/code&gt; 이 &lt;code&gt;1&lt;/code&gt; 로 설정 되었으므로 &lt;code&gt;print_multiple_times/2&lt;/code&gt; 의 첫 번째 정의에서 가드 가 true로 평가 되고이 특정 정의를 실행합니다. &lt;code&gt;msg&lt;/code&gt; 인쇄 및 실행 왼쪽 아무것도 없다.</target>
        </trans-unit>
        <trans-unit id="ade0f4f0153f3ee46feb17f06f5a697e3ea8100e" translate="yes" xml:space="preserve">
          <source>Our database engine used by &lt;code&gt;:my_app&lt;/code&gt; needs to know what databases exist, and what the database configurations are. The database engine can make a call to &lt;code&gt;get_env(:my_app, :my_app_databases)&lt;/code&gt; to retrieve the list of databases (specified by module names). Our database engine can then traverse each repository in the list and then call &lt;code&gt;get_env(:my_app, Databases.RepoOne)&lt;/code&gt; and so forth to retrieve the configuration of each one.</source>
          <target state="translated">&lt;code&gt;:my_app&lt;/code&gt; 에서 사용하는 데이터베이스 엔진 은 어떤 데이터베이스가 존재하고 어떤 데이터베이스 구성이 있는지 알아야합니다. 데이터베이스 엔진은 &lt;code&gt;get_env(:my_app, :my_app_databases)&lt;/code&gt; 를 호출하여 데이터베이스 목록 (모듈 이름으로 지정 ) 을 검색 할 수 있습니다. 데이터베이스 엔진은 목록의 각 리포지토리를 탐색 한 다음 &lt;code&gt;get_env(:my_app, Databases.RepoOne)&lt;/code&gt; 등 을 호출 하여 각 구성을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2f6d0c933af7daca11ac7f7ad70a0c3c2249028" translate="yes" xml:space="preserve">
          <source>Our first distributed code</source>
          <target state="translated">첫 배포 코드</target>
        </trans-unit>
        <trans-unit id="9e84809a7c397a309ce96164f5cacbbeaf21e474" translate="yes" xml:space="preserve">
          <source>Our first distributed task retrieves the name of the node the task is running on. Notice we have given an anonymous function to &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; but, in distributed cases, it is preferable to give the module, function, and arguments explicitly:</source>
          <target state="translated">첫 번째 분산 작업은 작업이 실행되는 노드의 이름을 검색합니다. &lt;code&gt;Task.Supervisor.async/2&lt;/code&gt; 에 익명 함수를 제공 했지만 분산 된 경우 모듈, 함수 및 인수를 명시 적으로 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="87ced78c461b132d154e8f4cf702fd7438182b7f" translate="yes" xml:space="preserve">
          <source>Our first macro</source>
          <target state="translated">첫 번째 매크로</target>
        </trans-unit>
        <trans-unit id="a44749c5086277b1e9b2d47d74121d2d8219a432" translate="yes" xml:space="preserve">
          <source>Our first project</source>
          <target state="translated">첫 프로젝트</target>
        </trans-unit>
        <trans-unit id="b27267683384fbe26b34a46fe89e40b87ffb846e" translate="yes" xml:space="preserve">
          <source>Our first supervisor</source>
          <target state="translated">우리의 첫 감독자</target>
        </trans-unit>
        <trans-unit id="08203c924a4f2f9eb683fc56d049d3e81c8b3b3e" translate="yes" xml:space="preserve">
          <source>Our first test starts a new &lt;code&gt;KV.Bucket&lt;/code&gt; by calling the &lt;code&gt;start_link/1&lt;/code&gt; and passing an empty list of options. Then we perform some &lt;code&gt;get/2&lt;/code&gt; and &lt;code&gt;put/3&lt;/code&gt; operations on it, asserting the result.</source>
          <target state="translated">첫 번째 테스트는 &lt;code&gt;KV.Bucket&lt;/code&gt; &lt;code&gt;start_link/1&lt;/code&gt; 을 호출하고 빈 옵션 목록을 전달하여 새로운 KV.Bucket 을 시작합니다 . 그런 다음 &lt;code&gt;get/2&lt;/code&gt; 및 &lt;code&gt;put/3&lt;/code&gt; 작업을 수행하여 결과를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="219a6c3d5bbb168da4e01962d5ac3a3beba4fafe" translate="yes" xml:space="preserve">
          <source>Our implementation splits the line on whitespace and then matches the command against a list. Using &lt;code&gt;String.split/1&lt;/code&gt; means our commands will be whitespace-insensitive. Leading and trailing whitespace won&amp;rsquo;t matter, nor will consecutive spaces between words. Let&amp;rsquo;s add some new doctests to test this behaviour along with the other commands:</source>
          <target state="translated">우리의 구현은 행을 공백으로 나누고 명령을 목록과 일치시킵니다. &lt;code&gt;String.split/1&lt;/code&gt; 을 사용하면 명령이 공백에 영향을받지 않습니다. 선행 및 후행 공백은 중요하지 않으며 단어 사이의 연속 공백도 아닙니다. 다른 명령과 함께이 동작을 테스트하기 위해 몇 가지 새로운 doctest를 추가해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="4bada33605b3d0085e74cd5e28e1db60fae2e0fd" translate="yes" xml:space="preserve">
          <source>Our integration test checks all server interaction, including unknown commands and not found errors. It is worth noting that, as with</source>
          <target state="translated">통합 테스트는 알 수없는 명령 및 찾을 수없는 오류를 포함하여 모든 서버 상호 작용을 확인합니다. 주목할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="34a1175408d05bc3f9db3276c1dc05ef2699c1bd" translate="yes" xml:space="preserve">
          <source>Our integration test will use a TCP client that sends commands to our server and assert we are getting the desired responses.</source>
          <target state="translated">우리의 통합 테스트는 서버에 명령을 보내고 원하는 응답을받는다고 주장하는 TCP 클라이언트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="95fe1b352417a55c924d64b21f5c78849cba47c1" translate="yes" xml:space="preserve">
          <source>Our requirements are (see &lt;code&gt;elixir -v&lt;/code&gt;):</source>
          <target state="translated">우리의 요구 사항은 다음과 같습니다 ( &lt;code&gt;elixir -v&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="535edfb81d4d7fba2950c82c04bae85d9dfbc680" translate="yes" xml:space="preserve">
          <source>Our server functionality is almost complete. Only tests are missing. This time, we have left tests for last because there are some important considerations to be made.</source>
          <target state="translated">우리의 서버 기능은 거의 완성되었습니다. 테스트 만 누락되었습니다. 이번에는 몇 가지 중요한 고려 사항이 있기 때문에 마지막 테스트를 남겼습니다.</target>
        </trans-unit>
        <trans-unit id="0dd5b4064e68f8312097cf4592e8701596b6f591" translate="yes" xml:space="preserve">
          <source>Our supervisor has a single child so far: &lt;code&gt;KV.Registry&lt;/code&gt;. After we define a list of children, we call &lt;code&gt;Supervisor.init/2&lt;/code&gt;, passing the children and the supervision strategy.</source>
          <target state="translated">&lt;code&gt;KV.Registry&lt;/code&gt; 의 관리자는 지금까지 한 명의 자녀를 두고 있습니다. 하위 목록을 정의한 후 &lt;code&gt;Supervisor.init/2&lt;/code&gt; 를 호출 하여 하위 및 감독 전략을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="26dc3ca3dc381ac59a2d936b2680d93266f92db5" translate="yes" xml:space="preserve">
          <source>Our test case first asserts there&amp;rsquo;s no buckets in our registry, creates a named bucket, looks it up, and asserts it behaves as a bucket.</source>
          <target state="translated">테스트 사례는 먼저 레지스트리에 버킷이 없다고 주장하고 명명 된 버킷을 생성 한 후 찾아보고 버킷으로 동작한다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="e4223734c95ebae3d84c8793615e9933ad56a2e5" translate="yes" xml:space="preserve">
          <source>Our test uses the &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; function to retrieve the child specification out of a module and then assert its restart value is &lt;code&gt;:temporary&lt;/code&gt;. At this point, you may be wondering why use a supervisor if it never restarts its children. It happens that supervisors provide more than restarts, they are also responsible for guaranteeing proper startup and shutdown, especially in case of crashes in a supervision tree.</source>
          <target state="translated">테스트에서는 &lt;code&gt;Supervisor.child_spec/2&lt;/code&gt; 함수를 사용하여 모듈에서 하위 사양을 검색 한 다음 재시작 값을 &lt;code&gt;:temporary&lt;/code&gt; 로 지정 합니다. 이 시점에서 관리자가 자식을 다시 시작하지 않으면 왜 관리자를 사용하는지 궁금 할 것입니다. 수퍼바이저는 다시 시작 이상을 제공하며 특히 감독 트리에서 충돌이 발생하는 경우 적절한 시작 및 종료를 보장 할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="281569899b0bc371294904a4302b498cefdffdc9" translate="yes" xml:space="preserve">
          <source>Our tests should now (always) pass!</source>
          <target state="translated">우리의 테스트는 이제 (항상) 통과해야합니다!</target>
        </trans-unit>
        <trans-unit id="9355be26c14e0bdd29f4d7a6d45fdd30c549218b" translate="yes" xml:space="preserve">
          <source>Outdated functions for building child specifications.</source>
          <target state="translated">하위 스펙을 빌드하기위한 오래된 기능.</target>
        </trans-unit>
        <trans-unit id="68809f406eda501cceb8a0a76b54d32562163e04" translate="yes" xml:space="preserve">
          <source>Over the next section, we will explore many of Elixir syntax constructs alongside their AST representation.</source>
          <target state="translated">다음 섹션에서는 AST 표현과 함께 많은 Elixir 구문 구성을 살펴볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="746205fc2b470e87484b958a27628c930425ad5e" translate="yes" xml:space="preserve">
          <source>Overall, the child specification can be one of the following:</source>
          <target state="translated">전체적으로 하위 스펙은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2d12ad6c158fff98834c1728a418fadd8e620d7" translate="yes" xml:space="preserve">
          <source>Overlined.</source>
          <target state="translated">Overlined.</target>
        </trans-unit>
        <trans-unit id="4678bc356cc17efccf9b8f5a4945bc7564b32a23" translate="yes" xml:space="preserve">
          <source>Parens and no parens in function calls</source>
          <target state="translated">함수 호출에서 Parens 및 Parens 없음</target>
        </trans-unit>
        <trans-unit id="3e3d2061650e6bfafddfcb21f5627e4ae2f724ca" translate="yes" xml:space="preserve">
          <source>Parentheses are important to support multiple expressions. This:</source>
          <target state="translated">괄호는 여러 식을 지원하는 데 중요합니다. 이:</target>
        </trans-unit>
        <trans-unit id="67051571e99ef0293cfd4d98dce041f6d2d0079b" translate="yes" xml:space="preserve">
          <source>Parentheses for non-qualified calls are optional, except for zero-arity calls, which would then be ambiguous with variables. If parentheses are used, they must immediately follow the function name &lt;em&gt;without spaces&lt;/em&gt;. For example, &lt;code&gt;add (1, 2)&lt;/code&gt; is a syntax error, since &lt;code&gt;(1, 2)&lt;/code&gt; is treated as an invalid block which is attempted to be given as a single argument to &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">비 호환 통화의 경우 괄호는 선택 사항이지만 제로 애널 통화는 변수가 모호합니다. 괄호를 사용하는 경우 &lt;em&gt;공백없이&lt;/em&gt; 함수 이름 바로 뒤에 와야합니다 . 예를 들어, &lt;code&gt;add (1, 2)&lt;/code&gt; 는 구문 오류입니다. &lt;code&gt;(1, 2)&lt;/code&gt; 는 &lt;code&gt;add&lt;/code&gt; 에 대한 단일 인수로 제공되는 잘못된 블록으로 취급되기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="eaccd27612cf8e4c36fdcb2e213e4f30e8b614a2" translate="yes" xml:space="preserve">
          <source>Parentheses for qualified calls are optional. If parentheses are used, they must immediately follow the function name &lt;em&gt;without spaces&lt;/em&gt;.</source>
          <target state="translated">적격 통화의 괄호는 선택 사항입니다. 괄호를 사용하는 경우 &lt;em&gt;공백없이&lt;/em&gt; 함수 이름 바로 뒤에 와야합니다 .</target>
        </trans-unit>
        <trans-unit id="5051b701bae8cfb193958fe123047596e7c8c957" translate="yes" xml:space="preserve">
          <source>Parenthesised arguments after the anonymous function indicate that we want the function to be evaluated, not just its definition returned. Note that a dot (&lt;code&gt;.&lt;/code&gt;) between the variable and parentheses is required to invoke an anonymous function. The dot ensures there is no ambiguity between calling the anonymous function matched to a variable &lt;code&gt;add&lt;/code&gt; and a named function &lt;code&gt;add/2&lt;/code&gt;. We will explore named functions when dealing with &lt;a href=&quot;modules-and-functions&quot;&gt;Modules and Functions&lt;/a&gt;, since named functions can only be defined within a module. For now, just remember that Elixir makes a clear distinction between anonymous functions and named functions.</source>
          <target state="translated">익명 함수 뒤의 괄호로 묶은 인수는 함수의 정의뿐만 아니라 함수가 평가되기를 원한다는 것을 나타냅니다. 익명 함수를 호출하려면 변수와 괄호 사이에 점 ( &lt;code&gt;.&lt;/code&gt; )이 필요합니다. 이 점은 변수 &lt;code&gt;add&lt;/code&gt; 와 일치하는 익명 함수와 명명 된 함수 &lt;code&gt;add/2&lt;/code&gt; 를 호출하는 것 사이에 모호함이 없도록합니다 . 명명 된 함수 는 모듈 내에서만 정의 할 수 있으므로 &lt;a href=&quot;modules-and-functions&quot;&gt;Modules and Functions를&lt;/a&gt; 처리 할 때 명명 된 함수를 살펴볼 것 입니다. 지금은 Elixir가 익명 함수와 명명 된 함수를 명확하게 구분하고 있음을 기억하십시오.</target>
        </trans-unit>
        <trans-unit id="c6e0c54097c1addd54979adc1a31105e2aaa679a" translate="yes" xml:space="preserve">
          <source>Parses &lt;code&gt;argv&lt;/code&gt; into a keyword list.</source>
          <target state="translated">&lt;code&gt;argv&lt;/code&gt; 를 키워드 목록으로 구문 분석 합니다.</target>
        </trans-unit>
        <trans-unit id="7a373d2047627c546c74f485fe9ab21c42c1df91" translate="yes" xml:space="preserve">
          <source>Parses a binary into a float.</source>
          <target state="translated">바이너리를 float로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="9e7e6f51d7020e3f9b0b2f42aa838f86dc50638c" translate="yes" xml:space="preserve">
          <source>Parses a text representation of an integer.</source>
          <target state="translated">정수의 텍스트 표현을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="1305b49b9db63d6a1fa5dcb852df3de639b5f930" translate="yes" xml:space="preserve">
          <source>Parses a version requirement string into a &lt;a href=&quot;version.requirement&quot;&gt;&lt;code&gt;Version.Requirement&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">버전 요구 사항 문자열을 &lt;a href=&quot;version.requirement&quot;&gt; &lt;code&gt;Version.Requirement&lt;/code&gt; &lt;/a&gt; 구조체 로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="a6e9a74770159628fab2a719bf1edd0a31ffec3a" translate="yes" xml:space="preserve">
          <source>Parses a version string into a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt; struct.</source>
          <target state="translated">버전 문자열을 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt; 구조체 로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="fe3857b9469595509888a047a6bc4d80e1165c97" translate="yes" xml:space="preserve">
          <source>Parses a version string into a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Version&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 문자열을 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Version&lt;/code&gt; &lt;/a&gt; 으로 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="9418b6ddc34fc34c1a8273ea4a0f4abcb6241047" translate="yes" xml:space="preserve">
          <source>Parses a well-formed URI reference into its components.</source>
          <target state="translated">올바른 형식의 URI 참조를 해당 구성 요소로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="79bbadda560fc2696985637c3dcd5d5d75b852e1" translate="yes" xml:space="preserve">
          <source>Parses the extended &quot;Date and time of day&quot; format described by &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601:2004&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601 : 2004에&lt;/a&gt; 설명 된 확장 된 &quot;날짜 및 시간&quot;형식을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="dea4a820a2ed56415d65f399d0de1e2f38a6464c" translate="yes" xml:space="preserve">
          <source>Parses the extended &quot;Dates&quot; format described by &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601:2004&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601 : 2004에&lt;/a&gt; 설명 된 확장 된 &quot;날짜&quot;형식을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="0c980fd66c48ae19c95734093b045d1485842675" translate="yes" xml:space="preserve">
          <source>Parses the extended &quot;Local time&quot; format described by &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601:2004&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;ISO 8601 : 2004에&lt;/a&gt; 설명 된 확장 된 &quot;현지 시간&quot;형식을 구문 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="4a7afa8fbef89e323ac662c4af9fe0a43a7660ee" translate="yes" xml:space="preserve">
          <source>Parsing unknown switches</source>
          <target state="translated">알 수없는 스위치 구문 분석</target>
        </trans-unit>
        <trans-unit id="058a972530d049d8d1939ad7fe7fdd2aa895b37b" translate="yes" xml:space="preserve">
          <source>Passed (also represented by &lt;code&gt;nil&lt;/code&gt;)</source>
          <target state="translated">전달됨 (또한 &lt;code&gt;nil&lt;/code&gt; 로 표시 )</target>
        </trans-unit>
        <trans-unit id="6c66f210cd28e106c39212344286cce106c8d0d7" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;:insert_replaced&lt;/code&gt; to &lt;a href=&quot;string#replace/4&quot;&gt;&lt;code&gt;String.replace/4&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">전달 &lt;code&gt;:insert_replaced&lt;/code&gt; 를 &lt;a href=&quot;string#replace/4&quot;&gt; &lt;code&gt;String.replace/4&lt;/code&gt; 에&lt;/a&gt; 전달</target>
        </trans-unit>
        <trans-unit id="89a8204a98999b2bee00cea4fbc5d899e83daf17" translate="yes" xml:space="preserve">
          <source>Passing a &lt;a href=&quot;datetime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; automatically converts it to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;, discarding the time zone information:</source>
          <target state="translated">&lt;a href=&quot;datetime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; 을&lt;/a&gt; 전달하면 자동으로 날짜 정보 를 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 으로 변환 되어 표준 시간대 정보가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4b3cf5e91c7ff130bc822fb2e1808168e930f058" translate="yes" xml:space="preserve">
          <source>Passing a data type that doesn&amp;rsquo;t implement the protocol raises an error:</source>
          <target state="translated">프로토콜을 구현하지 않는 데이터 유형을 전달하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f791e277d4e887df822880f6ea245d3e768dd518" translate="yes" xml:space="preserve">
          <source>Passing a list of strings as &lt;code&gt;padding&lt;/code&gt; will take one element of the list for every missing entry. If the list is shorter than the number of inserts, the filling will start again from the beginning of the list. Passing a string &lt;code&gt;padding&lt;/code&gt; is equivalent to passing the list of graphemes in it. If no &lt;code&gt;padding&lt;/code&gt; is given, it defaults to whitespace.</source>
          <target state="translated">문자열 목록을 &lt;code&gt;padding&lt;/code&gt; 으로 전달하면 누락 된 모든 항목에 대해 목록의 한 요소가 사용됩니다. 목록이 인서트 수보다 짧으면 목록 시작 부분부터 채우기가 다시 시작됩니다. 문자열 &lt;code&gt;padding&lt;/code&gt; 을 전달하는 것은 그 안에 그래프 목록을 전달하는 것과 같습니다. &lt;code&gt;padding&lt;/code&gt; 이 없으면 기본값은 공백입니다.</target>
        </trans-unit>
        <trans-unit id="5e3fd8ecb92634cc65268b6d4476c69ed28e51d4" translate="yes" xml:space="preserve">
          <source>Passing a non-empty list to &lt;a href=&quot;enum#into/2&quot;&gt;&lt;code&gt;Enum.into/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">비어 있지 않은 목록을 &lt;a href=&quot;enum#into/2&quot;&gt; &lt;code&gt;Enum.into/2&lt;/code&gt; 로 전달&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc442b60927fa3cedca5b49645dcda347c68d43b" translate="yes" xml:space="preserve">
          <source>Passing a non-empty list to &lt;code&gt;:into&lt;/code&gt; in &lt;code&gt;for&lt;/code&gt;</source>
          <target state="translated">비어 있지 않은 목록을 &lt;code&gt;:into&lt;/code&gt; in &lt;code&gt;for&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc0e56540195473b76b76bc99aa7381097cd9285" translate="yes" xml:space="preserve">
          <source>Passing a string that does not represent an integer leads to an error:</source>
          <target state="translated">정수를 나타내지 않는 문자열을 전달하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dd3e8286d4953766dd3b3f6ceafaf9431e925e06" translate="yes" xml:space="preserve">
          <source>Pasting multiline expressions into IEx</source>
          <target state="translated">여러 줄로 된 표현식을 IEx에 붙여 넣기</target>
        </trans-unit>
        <trans-unit id="91b58c214080204a7a5e383388a515d0a4b74b02" translate="yes" xml:space="preserve">
          <source>Patch segments are compared lexicographically if they are alphanumeric, and numerically otherwise.</source>
          <target state="translated">패치 세그먼트는 영숫자 인 경우 사전 식으로, 그렇지 않으면 숫자로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="519e39132bb98418cc0483cc446ccf5f3c8dcffe" translate="yes" xml:space="preserve">
          <source>Path</source>
          <target state="translated">Path</target>
        </trans-unit>
        <trans-unit id="c0c3abe147a53151f7b15d4fc13e0b6734b3694d" translate="yes" xml:space="preserve">
          <source>Path and in umbrella dependencies are automatically recompiled by the parent project whenever they change. While fetchable dependencies, like the ones using &lt;code&gt;:git&lt;/code&gt;, are recompiled only when fetched/updated.</source>
          <target state="translated">경로 및 우산 내부 종속성은 변경 될 때마다 상위 프로젝트에 의해 자동으로 다시 컴파일됩니다. &lt;code&gt;:git&lt;/code&gt; 를 사용하는 것과 같이 가져올 수있는 종속성은 가져 오거나 업데이트 할 때만 다시 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="8ed7d3defaf72b508bfd8cf537c7e823fe6bd6aa" translate="yes" xml:space="preserve">
          <source>Path options (&lt;code&gt;:path&lt;/code&gt;)</source>
          <target state="translated">경로 옵션 ( &lt;code&gt;:path&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="13e7e11722f7d8309c367ea7823bd6cd32011ced" translate="yes" xml:space="preserve">
          <source>Paths</source>
          <target state="translated">Paths</target>
        </trans-unit>
        <trans-unit id="d5e92258ff6b2634e28eb6ffcaf62f5681cd01e9" translate="yes" xml:space="preserve">
          <source>Paths given to functions in this module can be either relative to the current working directory (as returned by &lt;a href=&quot;file#cwd/0&quot;&gt;&lt;code&gt;File.cwd/0&lt;/code&gt;&lt;/a&gt;), or absolute paths. Shell conventions like &lt;code&gt;~&lt;/code&gt; are not expanded automatically. To use paths like &lt;code&gt;~/Downloads&lt;/code&gt;, you can use &lt;a href=&quot;path#expand/1&quot;&gt;&lt;code&gt;Path.expand/1&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;path#expand/2&quot;&gt;&lt;code&gt;Path.expand/2&lt;/code&gt;&lt;/a&gt; to expand your path to an absolute path.</source>
          <target state="translated">이 모듈의 함수에 제공된 경로는 현재 작업 디렉토리 ( &lt;a href=&quot;file#cwd/0&quot;&gt; &lt;code&gt;File.cwd/0&lt;/code&gt; 에&lt;/a&gt; 의해 리턴 된)에 상대적인 경로이거나 절대 경로 일 수 있습니다. &lt;code&gt;~&lt;/code&gt; 와 같은 쉘 규칙 은 자동으로 확장되지 않습니다. 같은 경로를 사용하려면 &lt;code&gt;~/Downloads&lt;/code&gt; , 당신은 사용할 수 있습니다 &lt;a href=&quot;path#expand/1&quot;&gt; &lt;code&gt;Path.expand/1&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;path#expand/2&quot;&gt; &lt;code&gt;Path.expand/2&lt;/code&gt; 는&lt;/a&gt; 절대 경로로 경로를 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e99640fa7e7a52ff09113ed1f71e7b10259e02c" translate="yes" xml:space="preserve">
          <source>Pattern match on &lt;code&gt;_.._&lt;/code&gt; (v1.0)</source>
          <target state="translated">&lt;code&gt;_.._&lt;/code&gt; (v1.0)의 패턴 일치</target>
        </trans-unit>
        <trans-unit id="4a4ff6f40515d80959eb2891b1a4f521722adb61" translate="yes" xml:space="preserve">
          <source>Pattern matching</source>
          <target state="translated">패턴 매칭</target>
        </trans-unit>
        <trans-unit id="762812440ca2ae94a95f89714b7b124251968b01" translate="yes" xml:space="preserve">
          <source>Pattern matching allows developers to easily destructure data types such as tuples and lists. As we will see in the following chapters, it is one of the foundations of recursion in Elixir and applies to other types as well, like maps and binaries.</source>
          <target state="translated">패턴 일치를 통해 개발자는 튜플 및 목록과 같은 데이터 유형을 쉽게 재구성 할 수 있습니다. 다음 장에서 볼 수 있듯이, 이것은 Elixir의 재귀의 기초 중 하나이며 맵 및 이진과 같은 다른 유형에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="fdff00e56a789a8726c9da949b09dd98bd5ff2f6" translate="yes" xml:space="preserve">
          <source>Pattern matching on struct names</source>
          <target state="translated">구조체 이름의 패턴 매칭</target>
        </trans-unit>
        <trans-unit id="2a4de85389e0a217d14b9f1582fdf6651995191b" translate="yes" xml:space="preserve">
          <source>Pattern matching.</source>
          <target state="translated">패턴 매칭.</target>
        </trans-unit>
        <trans-unit id="d6028e13dbd229af93277e237b2c16fbf94be2cb" translate="yes" xml:space="preserve">
          <source>Pattern must be an atom or a tuple that will match the structure of the value stored in the registry. The atom &lt;code&gt;:_&lt;/code&gt; can be used to ignore a given value or tuple element, while the atom &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; can be used to temporarily assign part of pattern to a variable for a subsequent comparison.</source>
          <target state="translated">패턴은 레지스트리에 저장된 값의 구조와 일치하는 원자 또는 튜플이어야합니다. atom &lt;code&gt;:_&lt;/code&gt; 는 주어진 값이나 튜플 요소를 무시하는 데 사용될 수 있지만 atom &lt;code&gt;:&quot;$1&quot;&lt;/code&gt; 은 패턴의 일부를 변수에 임시로 할당하여 후속 비교를 위해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5137df8a74cffc5ca199358452463a9c6bfb9074" translate="yes" xml:space="preserve">
          <source>Pattern used in functions like &lt;a href=&quot;#replace/3&quot;&gt;&lt;code&gt;replace/3&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#split/2&quot;&gt;&lt;code&gt;split/2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#replace/3&quot;&gt; &lt;code&gt;replace/3&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#split/2&quot;&gt; &lt;code&gt;split/2&lt;/code&gt; &lt;/a&gt; 와 같은 기능에 사용되는 패턴</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="d8f5c8436b5f5097fc1e0b09aadfb6092ac6af0f" translate="yes" xml:space="preserve">
          <source>Patterns and guards</source>
          <target state="translated">패턴과 가드</target>
        </trans-unit>
        <trans-unit id="5c540b06ef6678db51d87771fe4d3939cf8a2687" translate="yes" xml:space="preserve">
          <source>Percent-escapes all characters that require escaping in &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 에서 이스케이프해야하는 모든 문자를 퍼센트 이스케이프 합니다 .</target>
        </trans-unit>
        <trans-unit id="0c2d8594907eb7e308e53ec4869ee6591cd32868" translate="yes" xml:space="preserve">
          <source>Percent-unescapes a URI.</source>
          <target state="translated">URI를 이스케이프 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e179944907d404a0c32e7b8b6d4faf26105d3528" translate="yes" xml:space="preserve">
          <source>Performance &amp;amp; Optimizations</source>
          <target state="translated">성능 및 최적화</target>
        </trans-unit>
        <trans-unit id="c275fdf2e3e600505a75a54526cffcdd6b781bbb" translate="yes" xml:space="preserve">
          <source>Performs a cast (&lt;em&gt;fire and forget&lt;/em&gt;) operation on the agent state.</source>
          <target state="translated">에이전트 상태 에서 캐스트 ( &lt;em&gt;fire and forget&lt;/em&gt; ) 작업을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="2dda6078e429a5da67f4d4b2be41fa1f081b1311" translate="yes" xml:space="preserve">
          <source>Performs a depth-first traversal of quoted expressions using an accumulator.</source>
          <target state="translated">누산기를 사용하여 인용 된 표현식의 깊이 우선 순회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4785eea6c091478238fb008cdd410304fdd8d0f0" translate="yes" xml:space="preserve">
          <source>Performs a depth-first, post-order traversal of quoted expressions using an accumulator.</source>
          <target state="translated">누산기를 사용하여 인용 된 표현식의 심도 우선, 차수 순회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="32814ff09b644963df4e222c005f1c731fb50119" translate="yes" xml:space="preserve">
          <source>Performs a depth-first, post-order traversal of quoted expressions.</source>
          <target state="translated">따옴표로 묶인 표현식의 심도 우선, 차후 순회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7b7923e80f9004780986d78cff2f797fee5928bf" translate="yes" xml:space="preserve">
          <source>Performs a depth-first, pre-order traversal of quoted expressions using an accumulator.</source>
          <target state="translated">누산기를 사용하여 인용 된 표현식의 심도 우선 사전 순서 순회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="53d43f5532c10b67e765cd88c0ddb300fe2d8aba" translate="yes" xml:space="preserve">
          <source>Performs a depth-first, pre-order traversal of quoted expressions.</source>
          <target state="translated">따옴표로 묶인 표현식의 심도 우선 사전 순서 순회를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="039534a957eec2fa34791db81532382c587d8245" translate="yes" xml:space="preserve">
          <source>Performs a floored integer division.</source>
          <target state="translated">바닥 정수 나누기를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="458261426d9d27cb74c83066a9b390fab831f47c" translate="yes" xml:space="preserve">
          <source>Performs an integer division.</source>
          <target state="translated">정수 나누기를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d5fa7b7265385a6a4338c08984b01ec783651ffb" translate="yes" xml:space="preserve">
          <source>Performs cross reference checks between modules.</source>
          <target state="translated">모듈간에 상호 참조 검사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="11854d0712971b76c41b6ad9d5a606d865ee7453" translate="yes" xml:space="preserve">
          <source>Performs remote dispatch checking.</source>
          <target state="translated">원격 디스패치 검사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d06d55570938d12f87db3bf2b48caa9de22d9c67" translate="yes" xml:space="preserve">
          <source>Permissions</source>
          <target state="translated">Permissions</target>
        </trans-unit>
        <trans-unit id="0b7522b2ee55a89f041eb7221911aa0a0e32f37f" translate="yes" xml:space="preserve">
          <source>Pipe operator.</source>
          <target state="translated">파이프 운영자.</target>
        </trans-unit>
        <trans-unit id="3854cbad98a94ad36b9fbd34a9d7759251a83644" translate="yes" xml:space="preserve">
          <source>Pipes &lt;code&gt;expr&lt;/code&gt; into the &lt;code&gt;call_args&lt;/code&gt; at the given &lt;code&gt;position&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;position&lt;/code&gt; 에서 &lt;code&gt;expr&lt;/code&gt; 을 &lt;code&gt;call_args&lt;/code&gt; 로 파이프합니다 .</target>
        </trans-unit>
        <trans-unit id="8ef57d28e73677c96993fd2b8445c1eec249cdff" translate="yes" xml:space="preserve">
          <source>Pitfalls</source>
          <target state="translated">Pitfalls</target>
        </trans-unit>
        <trans-unit id="e5a7b226404fec963975ee16c6feacd0bed5537d" translate="yes" xml:space="preserve">
          <source>Place documentation before the first clause of multi-clause functions. Documentation is always per function and arity and not per clause.</source>
          <target state="translated">다중 절 함수의 첫 번째 절 앞에 문서를 배치하십시오. 문서는 항상 기능과 특성에 따라 다르며 절마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="225a7f9c31a9e433302718633fe4e93f7a51a743" translate="yes" xml:space="preserve">
          <source>Please note that all the modules defined in the same file as &lt;code&gt;module&lt;/code&gt; are recompiled and reloaded.</source>
          <target state="translated">모듈과 동일한 파일에 정의 된 모든 &lt;code&gt;module&lt;/code&gt; 이 다시 컴파일되어 다시로드됩니다.</target>
        </trans-unit>
        <trans-unit id="39c9a395b7a75f7f91d5c9d082bddd97314589a3" translate="yes" xml:space="preserve">
          <source>Please note that by doing this, we are breaking the boilerplate test case which tested the &lt;code&gt;hello&lt;/code&gt; function in &lt;code&gt;KV&lt;/code&gt;. You can simply remove that test case.</source>
          <target state="translated">이 작업을 수행하면 &lt;code&gt;KV&lt;/code&gt; 에서 &lt;code&gt;hello&lt;/code&gt; 함수 를 테스트 한 상용구 테스트 사례가 중단 됩니다. 해당 테스트 사례를 간단히 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5389d292ea210e333906a47db99429702756329e" translate="yes" xml:space="preserve">
          <source>Please note that some details like version numbers may differ a bit in your session; that&amp;rsquo;s not important. From now on &lt;code&gt;iex&lt;/code&gt; sessions will be stripped down to focus on the code. To exit &lt;code&gt;iex&lt;/code&gt; press &lt;code&gt;Ctrl+C&lt;/code&gt; twice.</source>
          <target state="translated">버전 번호와 같은 일부 세부 사항은 세션에서 약간 다를 수 있습니다. 중요하지 않습니다. 이제부터는 &lt;code&gt;iex&lt;/code&gt; 세션이 코드에 집중되도록 제거됩니다. &lt;code&gt;iex&lt;/code&gt; 를 종료하려면 &lt;code&gt;Ctrl+C&lt;/code&gt; 를 두 번 누르십시오 .</target>
        </trans-unit>
        <trans-unit id="d11ad5116bd8c797fe89a4d35824e7ca4c61f131" translate="yes" xml:space="preserve">
          <source>Please note the following functions for tuples are found in &lt;a href=&quot;kernel&quot;&gt;&lt;code&gt;Kernel&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;kernel&quot;&gt; &lt;code&gt;Kernel&lt;/code&gt; &lt;/a&gt; 다음과 같은 튜플 기능이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3de0c7e157c52cc856a0f62d452060f6a5131f16" translate="yes" xml:space="preserve">
          <source>Please read &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;the GenServer module documentation&lt;/a&gt; for an overview if you haven&amp;rsquo;t yet. Once you do so, we are ready to proceed.</source>
          <target state="translated">아직 &lt;a href=&quot;https://hexdocs.pm/elixir/GenServer.html&quot;&gt;GenServer 모듈 설명서&lt;/a&gt; 를 읽지 않았다면 읽어보십시오 . 그렇게하면 진행할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="34c26932c8bdaaf11dbb3279895024633d9ddf5b" translate="yes" xml:space="preserve">
          <source>Please see &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#inspect/2&quot;&gt;IO.inspect/2&lt;/a&gt; to read more about other ways in which one could use this function. Also, in order to find a full list of other formatting options that one can use alongside &lt;code&gt;IO.inspect/2&lt;/code&gt;, see &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Opts.html&quot;&gt;Inspect.Opts&lt;/a&gt;.</source>
          <target state="translated">이 기능을 사용할 수있는 다른 방법에 대한 자세한 내용은 &lt;a href=&quot;https://hexdocs.pm/elixir/IO.html#inspect/2&quot;&gt;IO.inspect / 2&lt;/a&gt; 를 참조하십시오 . 또한, 하나는 함께 사용할 수있는 다른 서식 옵션의 전체 목록을 찾기 위해 &lt;code&gt;IO.inspect/2&lt;/code&gt; 참조 &lt;a href=&quot;https://hexdocs.pm/elixir/Inspect.Opts.html&quot;&gt;Inspect.Opts을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e45979c3d32e2c27b3aeac1606c58bb2e6186e8" translate="yes" xml:space="preserve">
          <source>Plugs into Erlang's &lt;a href=&quot;http://erlang.org/doc/man/logger.html&quot;&gt;&lt;code&gt;:logger&lt;/code&gt;&lt;/a&gt; (from Erlang/OTP 21) to convert terms to Elixir syntax or wraps Erlang's &lt;a href=&quot;http://erlang.org/doc/man/error_logger.html&quot;&gt;&lt;code&gt;:error_logger&lt;/code&gt;&lt;/a&gt; in earlier Erlang/OTP versions to prevent it from overflowing.</source>
          <target state="translated">얼랑의에 연결 &lt;a href=&quot;http://erlang.org/doc/man/logger.html&quot;&gt; &lt;code&gt;:logger&lt;/code&gt; &lt;/a&gt; (얼랑 / OTP 21) 비약 구문 용어를 변환하거나 얼랑의 랩 &lt;a href=&quot;http://erlang.org/doc/man/error_logger.html&quot;&gt; &lt;code&gt;:error_logger&lt;/code&gt; 를&lt;/a&gt; 오버 플로우를 방지하기 위해 이전 얼랑 / OTP 버전.</target>
        </trans-unit>
        <trans-unit id="22f9e4899d5a9f9e7d7ac5fc03923347cf0dd256" translate="yes" xml:space="preserve">
          <source>Plus a number of functions for working with binaries (bytes) in the &lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt;&lt;code&gt;:binary&lt;/code&gt; module&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.erlang.org/doc/man/binary.html&quot;&gt; &lt;code&gt;:binary&lt;/code&gt; &lt;/a&gt; 모듈 에서 바이너리 (바이트) 작업을위한 여러 함수</target>
        </trans-unit>
        <trans-unit id="bb9cf1418089b3356038fdd24fcbdc9d1a7c42a5" translate="yes" xml:space="preserve">
          <source>Policy</source>
          <target state="translated">Policy</target>
        </trans-unit>
        <trans-unit id="5b184d613e5dc77792a5b77d4c71d9a8f5805d12" translate="yes" xml:space="preserve">
          <source>Pops a key from the given nested structure.</source>
          <target state="translated">주어진 중첩 구조에서 키를 팝합니다.</target>
        </trans-unit>
        <trans-unit id="f3dbd54145fe56b947320097710efe3fb212dea0" translate="yes" xml:space="preserve">
          <source>Pops a key from the nested structure via the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;path&lt;/code&gt; 를 통해 중첩 구조에서 키를 팝합니다 .</target>
        </trans-unit>
        <trans-unit id="fe035157cda20b361ce30613e29b5d6f1a46b5fc" translate="yes" xml:space="preserve">
          <source>Port</source>
          <target state="translated">Port</target>
        </trans-unit>
        <trans-unit id="b33456701a07c78fe5d71eef1faf59492a293d96" translate="yes" xml:space="preserve">
          <source>Ports provide a mechanism to start operating system processes external to the Erlang VM and communicate with them via message passing.</source>
          <target state="translated">포트는 Erlang VM 외부에서 운영 체제 프로세스를 시작하고 메시지 전달을 통해 이들과 통신하는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="49af11ce7ff963467dab9d145b8d28e88fbf86cb" translate="yes" xml:space="preserve">
          <source>Possible time zone periods for a certain time zone and wall clock date and time.</source>
          <target state="translated">특정 시간대 및 벽시계 날짜 및 시간에 대해 가능한 시간대 기간.</target>
        </trans-unit>
        <trans-unit id="9af262a428ebb097a2a816a84db97bdefe0b3f35" translate="yes" xml:space="preserve">
          <source>Pre-releases are strictly less than their corresponding release versions.</source>
          <target state="translated">시험판은 해당 릴리스 버전보다 엄격히 적습니다.</target>
        </trans-unit>
        <trans-unit id="bda9c25c561aec987e1b78e68cb3669014cebe8e" translate="yes" xml:space="preserve">
          <source>Pre-releases are supported by optionally appending a hyphen and a series of period-separated identifiers immediately following the patch version. Identifiers consist of only ASCII alphanumeric characters and hyphens (&lt;code&gt;[0-9A-Za-z-]&lt;/code&gt;):</source>
          <target state="translated">시험판은 패치 버전 바로 뒤에 하이픈과 마침표로 구분 된 일련의 식별자를 선택적으로 추가하여 지원됩니다. 식별자는 ASCII 영숫자와 하이픈 ( &lt;code&gt;[0-9A-Za-z-]&lt;/code&gt; ) 으로 만 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d2dd642b809a9afa37c5b34ef9ccae95e253485" translate="yes" xml:space="preserve">
          <source>Precompilation</source>
          <target state="translated">Precompilation</target>
        </trans-unit>
        <trans-unit id="0b8da57c3b77645c7f2cae0807da41d055f68ad1" translate="yes" xml:space="preserve">
          <source>Prefer using &lt;a href=&quot;datetime#utc_now/0&quot;&gt;&lt;code&gt;DateTime.utc_now/0&lt;/code&gt;&lt;/a&gt; when possible as, opposite to &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;NaiveDateTime&lt;/code&gt;&lt;/a&gt;, it will keep the time zone information.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;NaiveDateTime&lt;/code&gt; &lt;/a&gt; 과 반대로 시간대 정보를 유지하므로 가능한 경우 &lt;a href=&quot;datetime#utc_now/0&quot;&gt; &lt;code&gt;DateTime.utc_now/0&lt;/code&gt; 을&lt;/a&gt; 사용 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="193093334a57781999b3ba39585e6cbf824ef0f0" translate="yes" xml:space="preserve">
          <source>Prefix (unary) operator; calculates the bitwise NOT of its argument.</source>
          <target state="translated">접두사 (단항) 연산자; 인수의 비트 NOT을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="eea84a143a5c43eba7121b69efd8599881cd4e88" translate="yes" xml:space="preserve">
          <source>Prepends a path to the beginning of the Erlang VM code path list.</source>
          <target state="translated">Erlang VM 코드 경로 목록의 시작 부분에 경로를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ad7544451a00457faefe5c90802b235432b07208" translate="yes" xml:space="preserve">
          <source>Pries into the process environment.</source>
          <target state="translated">프로세스 환경으로 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="c650d1681f475d556e0741952be9bdbed39b594a" translate="yes" xml:space="preserve">
          <source>Prints VM/runtime information such as versions, memory usage and statistics. Additional topics are available via &lt;a href=&quot;#runtime_info/1&quot;&gt;&lt;code&gt;runtime_info/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전, 메모리 사용량 및 통계와 같은 VM / 런타임 정보를 인쇄합니다. 추가 주제는 &lt;a href=&quot;#runtime_info/1&quot;&gt; &lt;code&gt;runtime_info/1&lt;/code&gt; 을&lt;/a&gt; 통해 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="cd2dbcf9bebb8d76fc78e7c60efbed06c652a712" translate="yes" xml:space="preserve">
          <source>Prints a file dependency graph where an edge from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt; indicates that &lt;code&gt;A&lt;/code&gt; (source) depends on &lt;code&gt;B&lt;/code&gt; (sink).</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 에서 &lt;code&gt;B&lt;/code&gt; 로의 가장자리 가 &lt;code&gt;A&lt;/code&gt; (소스)가 &lt;code&gt;B&lt;/code&gt; (싱크) 에 의존 한다는 것을 나타내는 파일 종속성 그래프를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="f89b78f661ed94f4f3264cf20d49cfe3b2271d25" translate="yes" xml:space="preserve">
          <source>Prints a list of all the functions and macros exported by the given module.</source>
          <target state="translated">지정된 모듈에서 내 보낸 모든 기능 및 매크로 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="21cf1dbac4d05fa2e897c927750d4ec851dfdfa6" translate="yes" xml:space="preserve">
          <source>Prints a list of the given directory's contents.</source>
          <target state="translated">주어진 디렉토리 내용의 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="816fa4a9573b3d1eade5973479c5d434df6932d3" translate="yes" xml:space="preserve">
          <source>Prints a message and asks the user if they want to proceed.</source>
          <target state="translated">메시지를 인쇄하고 사용자에게 계속 진행할 것인지 묻습니다.</target>
        </trans-unit>
        <trans-unit id="e2ec3a4dfe86c240d136373ea35a884bf200c540" translate="yes" xml:space="preserve">
          <source>Prints a message and prompts the user for input.</source>
          <target state="translated">메시지를 인쇄하고 사용자에게 입력하라는 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="ddd0491656e97dc3bcc73b8c0fac99539b89b38e" translate="yes" xml:space="preserve">
          <source>Prints all breakpoints to the terminal.</source>
          <target state="translated">모든 중단 점을 터미널에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="d45ac7d4540637c6fdc232c2b99937de0319a5e3" translate="yes" xml:space="preserve">
          <source>Prints all callers of the given &lt;code&gt;CALLEE&lt;/code&gt;, which can be one of: &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;Module.function&lt;/code&gt;, or &lt;code&gt;Module.function/arity&lt;/code&gt;. Examples:</source>
          <target state="translated">지정된 &lt;code&gt;CALLEE&lt;/code&gt; 의 모든 발신자를 인쇄합니다 . &lt;a href=&quot;https://hexdocs.pm/elixir/Module.html&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;Module.function&lt;/code&gt; 또는 &lt;code&gt;Module.function/arity&lt;/code&gt; 중 하나 일 수 있습니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="fb7b5b8ff071f99cadfdd753b83a8dcfd047d61c" translate="yes" xml:space="preserve">
          <source>Prints all deprecated &quot;file:line: module.function/arity&quot; entries:</source>
          <target state="translated">더 이상 사용되지 않는 &quot;file : line : module.function / arity&quot;항목을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="c1327228921868a454a53046edb632efd4b315a2" translate="yes" xml:space="preserve">
          <source>Prints all unreachable &quot;file:line: module.function/arity&quot; entries:</source>
          <target state="translated">도달 할 수없는 모든 &quot;file : line : module.function / arity&quot;항목을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="971f6a2d9c15e227f73c83c32352ffad4dff563e" translate="yes" xml:space="preserve">
          <source>Prints information about the data type of any given term.</source>
          <target state="translated">주어진 용어의 데이터 유형에 대한 정보를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="3d707a33372771d97f7c17fb4637c172eed3bdd3" translate="yes" xml:space="preserve">
          <source>Prints the current application if it was not printed yet.</source>
          <target state="translated">현재 응용 프로그램이 아직 인쇄되지 않은 경우 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f8ad915e9dada2c1aa7c7f28d88b5ad48d5e62fb" translate="yes" xml:space="preserve">
          <source>Prints the current application to the shell if it was not printed yet.</source>
          <target state="translated">아직 인쇄되지 않은 경우 현재 응용 프로그램을 쉘에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b0cbd5cf2d2d3e1ca6d472dc9fce84b12f99639e" translate="yes" xml:space="preserve">
          <source>Prints the current location and stacktrace in a pry session.</source>
          <target state="translated">올림 세션에서 현재 위치 및 스택 추적을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b874478af7120eec5906930f8fa90e197ddb0f5c" translate="yes" xml:space="preserve">
          <source>Prints the current working directory.</source>
          <target state="translated">현재 작업 디렉토리를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f23662b711ee1f5d4b42e4d3962ce84c2e247563" translate="yes" xml:space="preserve">
          <source>Prints the documentation for &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;IEx.Helpers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;IEx.Helpers&lt;/code&gt; &lt;/a&gt; 의 문서를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="7891ced35c9c114c80c5ffbd1f3c76e017520d37" translate="yes" xml:space="preserve">
          <source>Prints the documentation for the given callback function.</source>
          <target state="translated">주어진 콜백 함수에 대한 문서를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="435df0bab4049f4242469a352be410f6392ff49a" translate="yes" xml:space="preserve">
          <source>Prints the documentation for the given module or for the given &lt;code&gt;function/arity&lt;/code&gt; pair.</source>
          <target state="translated">주어진 모듈 또는 주어진 &lt;code&gt;function/arity&lt;/code&gt; 쌍에 대한 문서를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="520d57f3ac5af5ff431571387cb13b8f42ac807d" translate="yes" xml:space="preserve">
          <source>Prints the given ANSI error to the shell followed by a newline.</source>
          <target state="translated">주어진 ANSI 오류를 쉘에 인쇄 한 다음 줄 바꿈을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="1bafbf3ef8eb7159086bd97a24eb4f293f1a5373" translate="yes" xml:space="preserve">
          <source>Prints the given ANSI message to the shell followed by a newline.</source>
          <target state="translated">주어진 ANSI 메시지를 쉘에 인쇄 한 다음 줄 바꿈을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="499ef41bb785f746215b5a24160f51ee0f225759" translate="yes" xml:space="preserve">
          <source>Prints the types for the given module or for the given function/arity pair.</source>
          <target state="translated">주어진 모듈 또는 주어진 기능 / arity 쌍에 대한 유형을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="53bea7b855c92761fc53db7e7e657329722ff553" translate="yes" xml:space="preserve">
          <source>Prints:</source>
          <target state="translated">Prints:</target>
        </trans-unit>
        <trans-unit id="cb2a8bb0b4b97049a59dbbb6853799ec628b02bc" translate="yes" xml:space="preserve">
          <source>Private functions are only accessible from within the module in which they are defined. Trying to access a private function from outside the module it's defined in results in an &lt;a href=&quot;undefinedfunctionerror&quot;&gt;&lt;code&gt;UndefinedFunctionError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">전용 기능은 해당 기능이 정의 된 모듈 내에서만 액세스 할 수 있습니다. 모듈 외부에서 개인 함수에 액세스하려고하면 &lt;a href=&quot;undefinedfunctionerror&quot;&gt; &lt;code&gt;UndefinedFunctionError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1ca7456031219f8f2eeb5d52b9d37db3106da6e2" translate="yes" xml:space="preserve">
          <source>Private macros</source>
          <target state="translated">개인 매크로</target>
        </trans-unit>
        <trans-unit id="df9584791f632e79823605fbe6e78ca4839179b5" translate="yes" xml:space="preserve">
          <source>Private macros are only accessible from the same module in which they are defined.</source>
          <target state="translated">개인용 매크로는 정의 된 동일한 모듈에서만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46cd46eb7732031c3d6591214da75d5f59059290" translate="yes" xml:space="preserve">
          <source>Private macros must be defined before its usage.</source>
          <target state="translated">개인용 매크로는 사용하기 전에 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="12f4c13a6a06f999cc56eb966c94f71ef2658a3f" translate="yes" xml:space="preserve">
          <source>Process</source>
          <target state="translated">Process</target>
        </trans-unit>
        <trans-unit id="5eaa8e263e7efadbe9297d9c15fb6812d4c60c3a" translate="yes" xml:space="preserve">
          <source>Process-based and application-centric functionality</source>
          <target state="translated">프로세스 기반 및 애플리케이션 중심 기능</target>
        </trans-unit>
        <trans-unit id="ed7308bb59f2876220e45299939d241199595df2" translate="yes" xml:space="preserve">
          <source>Processes</source>
          <target state="translated">Processes</target>
        </trans-unit>
        <trans-unit id="a808861bbe2c82040e69c3e43be934abe883b545" translate="yes" xml:space="preserve">
          <source>Processes and group leaders</source>
          <target state="translated">프로세스 및 그룹 리더</target>
        </trans-unit>
        <trans-unit id="64cc2973345456132597091b2640ba2a85719adb" translate="yes" xml:space="preserve">
          <source>Processes and links play an important role when building fault-tolerant systems. Elixir processes are isolated and don&amp;rsquo;t share anything by default. Therefore, a failure in a process will never crash or corrupt the state of another process. Links, however, allow processes to establish a relationship in case of failure. We often link our processes to supervisors which will detect when a process dies and start a new process in its place.</source>
          <target state="translated">내결함성 시스템을 구축 할 때 프로세스와 링크가 중요한 역할을합니다. 엘릭서 프로세스는 격리되어 있으며 기본적으로 아무 것도 공유하지 않습니다. 따라서 프로세스의 실패로 인해 다른 프로세스의 상태가 충돌하거나 손상되지 않습니다. 그러나 링크를 통해 프로세스가 실패한 경우 관계를 설정할 수 있습니다. 프로세스가 종료되는시기를 감지하고 대신 새 프로세스를 시작하는 관리자와 프로세스를 종종 연결합니다.</target>
        </trans-unit>
        <trans-unit id="76f3f8bdca9664b89ee735acfb5e747a8d6c7222" translate="yes" xml:space="preserve">
          <source>Processes and raw files</source>
          <target state="translated">프로세스 및 원시 파일</target>
        </trans-unit>
        <trans-unit id="23eeb001c70f95660b354880626576dbb1964408" translate="yes" xml:space="preserve">
          <source>Processes are the most common answer to this question. We can write processes that loop infinitely, maintain state, and send and receive messages. As an example, let&amp;rsquo;s write a module that starts new processes that work as a key-value store in a file named &lt;code&gt;kv.exs&lt;/code&gt;:</source>
          <target state="translated">이 질문에 대한 가장 일반적인 답변은 프로세스입니다. 무한 반복되는 프로세스를 작성하고 상태를 유지하며 메시지를주고받을 수 있습니다. 예를 들어, &lt;code&gt;kv.exs&lt;/code&gt; 파일에서 키-값 저장소로 작동하는 새 프로세스를 시작하는 모듈을 작성해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="098f80f89b609eb84c8d74bbd2be6927723c925d" translate="yes" xml:space="preserve">
          <source>Processes get much more interesting when we are able to send and receive messages.</source>
          <target state="translated">메시지를 보내고받을 수있을 때 프로세스가 훨씬 흥미로워집니다.</target>
        </trans-unit>
        <trans-unit id="1c4a0da5abc99ecc4244180ae622b35cf0c5d24f" translate="yes" xml:space="preserve">
          <source>Produces a new list by removing the value at the specified &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;index&lt;/code&gt; 에서 값을 제거하여 새 목록을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="9e60eab60abd9957404c62c1a08f6416ba3bd550" translate="yes" xml:space="preserve">
          <source>Profile output</source>
          <target state="translated">프로필 출력</target>
        </trans-unit>
        <trans-unit id="17a20ce2ecdf2e690491227f705d6a39b4f49280" translate="yes" xml:space="preserve">
          <source>Profiles the given file or expression using Erlang's &lt;code&gt;cprof&lt;/code&gt; tool.</source>
          <target state="translated">Erlang의 &lt;code&gt;cprof&lt;/code&gt; 도구를 사용하여 주어진 파일 또는 표현식을 프로파일 링합니다 .</target>
        </trans-unit>
        <trans-unit id="9e9508bf92bb3b0baebd12f499bb465caddb8d1d" translate="yes" xml:space="preserve">
          <source>Profiles the given file or expression using Erlang's &lt;code&gt;eprof&lt;/code&gt; tool.</source>
          <target state="translated">Erlang의 &lt;code&gt;eprof&lt;/code&gt; 도구를 사용하여 주어진 파일 또는 표현식을 프로파일 링합니다 .</target>
        </trans-unit>
        <trans-unit id="7f5a56d02582dfbf0f39138c52e7854843f56715" translate="yes" xml:space="preserve">
          <source>Profiles the given file or expression using Erlang's &lt;code&gt;fprof&lt;/code&gt; tool.</source>
          <target state="translated">Erlang의 &lt;code&gt;fprof&lt;/code&gt; 도구를 사용하여 주어진 파일 또는 표현식을 프로파일 링합니다 .</target>
        </trans-unit>
        <trans-unit id="a3eb4c5dc8ed98fadb3285836002a5d71bcb1221" translate="yes" xml:space="preserve">
          <source>Project compilation</source>
          <target state="translated">프로젝트 편집</target>
        </trans-unit>
        <trans-unit id="c948166b923ec0b7f32efdb8807735735dd8fe86" translate="yes" xml:space="preserve">
          <source>Projects are often made available to other developers &lt;a href=&quot;https://hex.pm/docs/publish&quot;&gt;by publishing a Hex package&lt;/a&gt;. Hex also &lt;a href=&quot;https://hex.pm/pricing&quot;&gt;supports private packages for organizations&lt;/a&gt;. If ExDoc is configured for the Mix project, publishing a package on Hex will also automatically publish the generated documentation to &lt;a href=&quot;https://hexdocs.pm&quot;&gt;HexDocs&lt;/a&gt;.</source>
          <target state="translated">프로젝트는 종종 &lt;a href=&quot;https://hex.pm/docs/publish&quot;&gt;Hex 패키지를 게시&lt;/a&gt; 하여 다른 개발자에게 제공됩니다 . Hex는 또한 &lt;a href=&quot;https://hex.pm/pricing&quot;&gt;조직을위한 개인 패키지를 지원합니다&lt;/a&gt; . ExDoc이 Mix 프로젝트에 대해 구성된 경우 Hex에 패키지를 게시하면 생성 된 문서도 &lt;a href=&quot;https://hexdocs.pm&quot;&gt;HexDocs에&lt;/a&gt; 자동으로 게시됩니다 .</target>
        </trans-unit>
        <trans-unit id="928902bdb5cb34c32542be3d749f35a31372f0b9" translate="yes" xml:space="preserve">
          <source>Projects can extend Mix behaviour by adding their own tasks. For example, adding the task below inside your project will make it available to everyone that uses your project:</source>
          <target state="translated">프로젝트는 자체 작업을 추가하여 믹스 동작을 확장 할 수 있습니다. 예를 들어, 프로젝트 내에 아래 작업을 추가하면 프로젝트를 사용하는 모든 사람이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baaca8514e96b4b82b5f18247ed0611dd75c38c5" translate="yes" xml:space="preserve">
          <source>Projects or applications?</source>
          <target state="translated">프로젝트 또는 응용 프로그램?</target>
        </trans-unit>
        <trans-unit id="a817d7eb8e0f1dab755ab5203a082e5c3c094fce" translate="yes" xml:space="preserve">
          <source>Prompt</source>
          <target state="translated">Prompt</target>
        </trans-unit>
        <trans-unit id="1ed77c3f7ffc41a33eadccef5727dc7c97079235" translate="yes" xml:space="preserve">
          <source>Protocol</source>
          <target state="translated">Protocol</target>
        </trans-unit>
        <trans-unit id="c95299144f537818ea4ffc62edc9baddb79ff9f1" translate="yes" xml:space="preserve">
          <source>Protocol consolidation</source>
          <target state="translated">프로토콜 통합</target>
        </trans-unit>
        <trans-unit id="4924211f292b499a01c2e195003fc6016713268f" translate="yes" xml:space="preserve">
          <source>Protocol consolidation is applied by default to all Mix projects during compilation. This may be an issue during test. For instance, if you want to implement a protocol during test, the implementation will have no effect, as the protocol has already been consolidated. One possible solution is to include compilation directories that are specific to your test environment in your mix.exs:</source>
          <target state="translated">프로토콜 통합은 기본적으로 컴파일 중에 모든 믹스 프로젝트에 적용됩니다. 테스트하는 동안 문제가 될 수 있습니다. 예를 들어, 테스트 중에 프로토콜을 구현하려는 경우 프로토콜이 이미 통합되어 있으므로 구현이 적용되지 않습니다. 가능한 해결책 중 하나는 테스트 환경에 특정한 컴파일 디렉토리를 mix.exs에 포함시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="38f75fd9978f6b7ab60b40a58bd29ed87ef1c6c3" translate="yes" xml:space="preserve">
          <source>Protocol.UndefinedError</source>
          <target state="translated">Protocol.UndefinedError</target>
        </trans-unit>
        <trans-unit id="b22941c869e24046b71f5c52bd523b215a22df33" translate="yes" xml:space="preserve">
          <source>Protocol.UndefinedError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Protocol.UndefinedError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2a6e3082f7bd2a56b001fbb1624e361e5599002d" translate="yes" xml:space="preserve">
          <source>Protocols</source>
          <target state="translated">Protocols</target>
        </trans-unit>
        <trans-unit id="e4df956dc0223cfa164303e687c5a225641ae40e" translate="yes" xml:space="preserve">
          <source>Protocols add polymorphic dispatch to Elixir. They are contracts implementable by data types. See &lt;a href=&quot;#defprotocol/2&quot;&gt;&lt;code&gt;defprotocol/2&lt;/code&gt;&lt;/a&gt; for more information on protocols. Elixir provides the following protocols in the standard library:</source>
          <target state="translated">프로토콜은 Elixir에 다형성 디스패치를 ​​추가합니다. 데이터 형식으로 구현할 수있는 계약입니다. 프로토콜에 대한 자세한 내용 은 &lt;a href=&quot;#defprotocol/2&quot;&gt; &lt;code&gt;defprotocol/2&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. Elixir는 표준 라이브러리에서 다음 프로토콜을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="36627e2d6127b7bd708517ebecfa2ad88acfd239" translate="yes" xml:space="preserve">
          <source>Protocols and Structs</source>
          <target state="translated">프로토콜과 구조</target>
        </trans-unit>
        <trans-unit id="bf8ab3000b321cfc5656321edcc2397588fbb0c7" translate="yes" xml:space="preserve">
          <source>Protocols and structs</source>
          <target state="translated">프로토콜과 구조체</target>
        </trans-unit>
        <trans-unit id="8ae27a72345a1064a4d3cc2a284758812ffebfda" translate="yes" xml:space="preserve">
          <source>Protocols are a mechanism to achieve polymorphism in Elixir. Dispatching on a protocol is available to any data type as long as it implements the protocol. Let&amp;rsquo;s see an example.</source>
          <target state="translated">프로토콜은 Elixir에서 다형성을 달성하는 메커니즘입니다. 프로토콜에 대한 디스패치는 프로토콜을 구현하는 한 모든 데이터 유형에 사용할 수 있습니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="77f08665fbb2d92871b41b859bb9813256bbb73a" translate="yes" xml:space="preserve">
          <source>Protocols can also be implemented for multiple types at once:</source>
          <target state="translated">여러 유형에 대해 한 번에 프로토콜을 구현할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0a4f154e26e2407d7bcfe638361358c2a738cf2" translate="yes" xml:space="preserve">
          <source>Provides a convenient macro that allows a test to be defined with a string, but not yet implemented. The resulting test will always fail and print a &quot;Not implemented&quot; error message. The resulting test case is also tagged with &lt;code&gt;:not_implemented&lt;/code&gt;.</source>
          <target state="translated">문자열로 테스트를 정의 할 수 있지만 아직 구현되지 않은 편리한 매크로를 제공합니다. 결과 테스트는 항상 실패하고 &quot;구현되지 않음&quot;오류 메시지를 인쇄합니다. 결과 테스트 케이스에도 &lt;code&gt;:not_implemented&lt;/code&gt; 태그가 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="28a92a1009021c22f4256b929d5eb72a49f595b7" translate="yes" xml:space="preserve">
          <source>Provides a convenient macro that allows a test to be defined with a string. This macro automatically inserts the atom &lt;code&gt;:ok&lt;/code&gt; as the last line of the test. That said, a passing test always returns &lt;code&gt;:ok&lt;/code&gt;, but, more importantly, it forces Elixir to not tail call optimize the test and therefore avoids hiding lines from the backtrace.</source>
          <target state="translated">문자열로 테스트를 정의 할 수있는 편리한 매크로를 제공합니다. 이 매크로는 자동으로 atom &lt;code&gt;:ok&lt;/code&gt; 를 테스트의 마지막 줄로 삽입합니다 . 즉, 통과 테스트는 항상 &lt;code&gt;:ok&lt;/code&gt; 를 반환 하지만, 더 중요한 것은 Elixir가 테일 콜을 통해 테스트를 최적화하지 않도록하여 역 추적에서 라인을 숨기는 것을 피합니다.</target>
        </trans-unit>
        <trans-unit id="f485c4915018382897d623e74fdf4c922f5ba9de" translate="yes" xml:space="preserve">
          <source>Provides a set of algorithms to work with enumerables.</source>
          <target state="translated">열거 형 작업에 사용할 알고리즘 세트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f7babca163a5798352d200c29bbb4727f2713232" translate="yes" xml:space="preserve">
          <source>Provides a short-circuit operator that evaluates and returns the second expression only if the first one does not evaluate to a truthy value (that is, it is either &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;). Returns the first expression otherwise.</source>
          <target state="translated">첫 번째 표현식이 정확한 값 (즉, &lt;code&gt;nil&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; )으로 평가되지 않는 경우에만 두 번째 표현식을 평가하고 리턴하는 단락 연산자를 제공합니다 . 그렇지 않으면 첫 번째 표현식을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5c97af16a870f773f7d8298f32114ae521e291d7" translate="yes" xml:space="preserve">
          <source>Provides a short-circuit operator that evaluates and returns the second expression only if the first one evaluates to to a truthy value (neither &lt;code&gt;false&lt;/code&gt; nor &lt;code&gt;nil&lt;/code&gt;). Returns the first expression otherwise.</source>
          <target state="translated">첫 번째 표현식이 정확한 값 ( &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 이 아닌)으로 평가되는 경우에만 두 번째 표현식을 평가하고 리턴하는 단락 연산자를 제공합니다 . 그렇지 않으면 첫 번째 표현식을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bb1c1ada41fd138777281c5c60f4b0fbeb1252f7" translate="yes" xml:space="preserve">
          <source>Provides an &lt;a href=&quot;#if/2&quot;&gt;&lt;code&gt;if/2&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">&lt;a href=&quot;#if/2&quot;&gt; &lt;code&gt;if/2&lt;/code&gt; &lt;/a&gt; 매크로를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="7d7f5e01f31db2b96487f259d6815fc4f44d1641" translate="yes" xml:space="preserve">
          <source>Provides an &lt;code&gt;unless&lt;/code&gt; macro.</source>
          <target state="translated">는 제공 &lt;code&gt;unless&lt;/code&gt; 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="cc5d7dd7b7f78c70f93425bf23e7c1767df559e1" translate="yes" xml:space="preserve">
          <source>Provides debug, info, warn, and error levels.</source>
          <target state="translated">디버그, 정보, 경고 및 오류 수준을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9d218d5f6be5831e733b2aadef5482b512cca16e" translate="yes" xml:space="preserve">
          <source>Provides documentation for the current module.</source>
          <target state="translated">현재 모듈에 대한 설명서를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="da7b097fc28ffbab2557a5f2b082e76f4d69bde6" translate="yes" xml:space="preserve">
          <source>Provides documentation for the entity that follows the attribute. &lt;code&gt;@doc&lt;/code&gt; is to be used with a function, macro, callback, or macrocallback, while &lt;code&gt;@typedoc&lt;/code&gt; with a type (public or opaque).</source>
          <target state="translated">속성을 따르는 엔터티에 대한 설명서를 제공합니다. &lt;code&gt;@doc&lt;/code&gt; 은 함수, 매크로, 콜백 또는 매크로 콜백과 함께 사용되며 &lt;code&gt;@typedoc&lt;/code&gt; 은 유형 (공개 또는 불투명)으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fdadc7bd29e445ef99b6104b5a2b2b038e10ffe9" translate="yes" xml:space="preserve">
          <source>Provides functions to deal with modules during compilation time.</source>
          <target state="translated">컴파일 시간 동안 모듈을 처리하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="df51d0334cfd857e80339917423d4fb2e1cef1c7" translate="yes" xml:space="preserve">
          <source>Provides regular expressions for Elixir.</source>
          <target state="translated">Elixir에 정규식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d02201797a586702284442194cb247908230a636" translate="yes" xml:space="preserve">
          <source>Provides runtime information about functions, macros, and other information defined by the module.</source>
          <target state="translated">함수, 매크로 및 모듈에서 정의한 기타 정보에 대한 런타임 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cc9cbca5a4e02cf60536136ef9f3c6d625c70f6c" translate="yes" xml:space="preserve">
          <source>Provides the deprecation reason for a function. For example:</source>
          <target state="translated">기능에 대한 더 이상 사용되지 않는 이유를 제공합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb509e3cef4b01a2055df90985ae11c420fddff2" translate="yes" xml:space="preserve">
          <source>Providing a non-boolean will raise an exception:</source>
          <target state="translated">부울이 아닌 것을 제공하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fdaf9976e20d314713bf8ad08c1c0453b92492e1" translate="yes" xml:space="preserve">
          <source>Prunes non-valid UTF-8 code points.</source>
          <target state="translated">유효하지 않은 UTF-8 코드 포인트를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="fb5dee80e4520a5f254d6238153c6dc561e1cf68" translate="yes" xml:space="preserve">
          <source>Pry and &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt;&lt;code&gt;mix test&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">프라이 &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Test.html&quot;&gt; &lt;code&gt;mix test&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="54ec660e29ebb5bec957ff2cb42e6a129ef66da9" translate="yes" xml:space="preserve">
          <source>Pry and macros</source>
          <target state="translated">올챙이와 매크로</target>
        </trans-unit>
        <trans-unit id="1c9019872a4bbfd06ad7b17c0bee064d866590d1" translate="yes" xml:space="preserve">
          <source>Prying and breakpoints</source>
          <target state="translated">엿보기 및 중단 점</target>
        </trans-unit>
        <trans-unit id="4b2535c1fee183c38427a7089cd2b388b925985a" translate="yes" xml:space="preserve">
          <source>Public functions in modules are globally available, but in order to use macros, you need to opt-in by requiring the module they are defined in.</source>
          <target state="translated">모듈의 공용 함수는 전 세계적으로 사용 가능하지만 매크로를 사용하려면 정의 된 모듈을 요구하여 옵트 인해야합니다.</target>
        </trans-unit>
        <trans-unit id="338b45a6751558a0e49cb2d757f64736adc58f12" translate="yes" xml:space="preserve">
          <source>Publishing</source>
          <target state="translated">Publishing</target>
        </trans-unit>
        <trans-unit id="25d4b8eeccc56c0cd4a7d514c04c9c3ae243c619" translate="yes" xml:space="preserve">
          <source>Purge compiler modules.</source>
          <target state="translated">컴파일러 모듈을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="b90fc74c10d02d502db87680f321a47d69aa7a2c" translate="yes" xml:space="preserve">
          <source>Puts &lt;code&gt;value&lt;/code&gt; at the given zero-based &lt;code&gt;index&lt;/code&gt; in &lt;code&gt;tuple&lt;/code&gt;.</source>
          <target state="translated">풋은 &lt;code&gt;value&lt;/code&gt; 주어진 제로에서 &lt;code&gt;index&lt;/code&gt; 의 &lt;code&gt;tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec1e5d54e71eec9873cec8ecdadb097c2ae427d5" translate="yes" xml:space="preserve">
          <source>Puts a module attribute with &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; in the given &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;module&lt;/code&gt; 에 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;value&lt;/code&gt; 을 가진 모듈 속성을 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="4acfce1f0b23360b26c12b5e6c7bf2a6bf918d25" translate="yes" xml:space="preserve">
          <source>Puts a value in a nested structure via the given &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;path&lt;/code&gt; 를 통해 중첩 구조에 값을 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="7c0b337e86b25912f1d42a657325dc6d8a9a7246" translate="yes" xml:space="preserve">
          <source>Puts a value in a nested structure.</source>
          <target state="translated">중첩 구조에 값을 넣습니다.</target>
        </trans-unit>
        <trans-unit id="48a23971095bfbe373d39b1f1c70ac23fcde2d47" translate="yes" xml:space="preserve">
          <source>Puts the &lt;code&gt;value&lt;/code&gt; in &lt;code&gt;key&lt;/code&gt; for the given &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;app&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; 에 &lt;code&gt;value&lt;/code&gt; 을 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="97d0f1caf6e213cd26ac881b852140f4d9d23037" translate="yes" xml:space="preserve">
          <source>Puts the calling process into a &quot;hibernation&quot; state.</source>
          <target state="translated">호출 프로세스를 &quot;최대 절전 모드&quot;상태로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cadfddef2accc558bb07d494514e7ca1c284d964" translate="yes" xml:space="preserve">
          <source>Puts the environment for multiple apps at the same time.</source>
          <target state="translated">여러 앱을위한 환경을 동시에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b6ea1ba815fc83f69431f0cdd76f4213b86b1a54" translate="yes" xml:space="preserve">
          <source>Puts the given &lt;code&gt;value&lt;/code&gt; under &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;map&lt;/code&gt; 의 &lt;code&gt;key&lt;/code&gt; 아래에 둡니다 .</target>
        </trans-unit>
        <trans-unit id="de7749bbf077f512273bf8036b7cb8fc0deef364" translate="yes" xml:space="preserve">
          <source>Puts the given &lt;code&gt;value&lt;/code&gt; under &lt;code&gt;key&lt;/code&gt; unless the entry &lt;code&gt;key&lt;/code&gt; already exists in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">입력 &lt;code&gt;key&lt;/code&gt; 가 &lt;code&gt;map&lt;/code&gt; 에 존재 하지 않는 한 주어진 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;key&lt;/code&gt; 아래에 둡니다 .</target>
        </trans-unit>
        <trans-unit id="9b4d02cfb162ff8a780c85d472f56775f06bd43e" translate="yes" xml:space="preserve">
          <source>Puts the given &lt;code&gt;value&lt;/code&gt; under &lt;code&gt;key&lt;/code&gt; unless the entry &lt;code&gt;key&lt;/code&gt; already exists.</source>
          <target state="translated">입력 &lt;code&gt;key&lt;/code&gt; 없으면 &lt;code&gt;key&lt;/code&gt; 아래에 지정된 &lt;code&gt;value&lt;/code&gt; 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="801eb18f7c8ac7d16195e64a31d50b2a30aa8262" translate="yes" xml:space="preserve">
          <source>Puts the given &lt;code&gt;value&lt;/code&gt; under &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;value&lt;/code&gt; 을 &lt;code&gt;key&lt;/code&gt; 아래에 둡니다 .</target>
        </trans-unit>
        <trans-unit id="a87585b69b086c147f372f2e5a1d39fb50ad8a31" translate="yes" xml:space="preserve">
          <source>Qualified calls (remote calls)</source>
          <target state="translated">적격 통화 (원격 통화)</target>
        </trans-unit>
        <trans-unit id="665a6bcf289c1518f036a63e86791885bb3d1c3f" translate="yes" xml:space="preserve">
          <source>Qualified calls, such as &lt;code&gt;Math.add(1, 2)&lt;/code&gt;, must start with an underscore or a Unicode letter that is not in uppercase or titlecase. The call may continue using a sequence of Unicode letters, numbers, and underscores. Calls may end in &lt;code&gt;?&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt;. See &lt;a href=&quot;unicode-syntax&quot;&gt;Unicode Syntax&lt;/a&gt; for a formal specification.</source>
          <target state="translated">&lt;code&gt;Math.add(1, 2)&lt;/code&gt; 와 같은 정규화 된 호출 은 대문자 나 제목이 아닌 밑줄 또는 유니 코드 문자로 시작해야합니다. 일련의 유니 코드 문자, 숫자 및 밑줄을 계속 사용하여 호출 할 수 있습니다. 통화가 끝날 수 &lt;code&gt;?&lt;/code&gt; 또는 &lt;code&gt;!&lt;/code&gt; . 공식 사양 은 &lt;a href=&quot;unicode-syntax&quot;&gt;유니 코드 구문&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d47a22f953dc2b31cf6bc6440050b0aaf55f9649" translate="yes" xml:space="preserve">
          <source>Quote and macros</source>
          <target state="translated">견적 및 매크로</target>
        </trans-unit>
        <trans-unit id="398f0ab8b840b28a0fd354d1c0d7a72c7d9d306e" translate="yes" xml:space="preserve">
          <source>Quote and unquote</source>
          <target state="translated">견적 및 견적 해제</target>
        </trans-unit>
        <trans-unit id="d94e69560e301502d99603fd94eaa70bde805275" translate="yes" xml:space="preserve">
          <source>Quote is about retrieving the inner representation of some particular chunk of code. However, sometimes it may be necessary to inject some other particular chunk of code inside the representation we want to retrieve.</source>
          <target state="translated">인용문은 특정 코드 덩어리의 내부 표현을 검색하는 것입니다. 그러나 때로는 검색하려는 표현 안에 다른 특정 코드 덩어리를 삽입해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc325775a37291e9e0f216be4d97c9b52b5046b9" translate="yes" xml:space="preserve">
          <source>Quoted and unquoted atoms with the same name are considered equivalent, so &lt;code&gt;:atom&lt;/code&gt;, &lt;code&gt;:&quot;atom&quot;&lt;/code&gt;, and &lt;code&gt;:'atom'&lt;/code&gt; represent the same atom. The only catch is that the compiler will warn when quotes are used in atoms that do not need to be quoted.</source>
          <target state="translated">이름이 같은 따옴표 및 따옴표없는 원자는 동등한 것으로 간주되므로 &lt;code&gt;:atom&lt;/code&gt; , &lt;code&gt;:&quot;atom&quot;&lt;/code&gt; 및 &lt;code&gt;:'atom'&lt;/code&gt; 은 동일한 원자를 나타냅니다. 인용 할 필요가없는 원자에서 인용 부호를 사용할 때 컴파일러가 경고를 표시하는 것이 유일한 문제입니다.</target>
        </trans-unit>
        <trans-unit id="3a432aa09de3e72168ea6a4c0658a86a59f5a08d" translate="yes" xml:space="preserve">
          <source>Quoted expression</source>
          <target state="translated">인용 표현</target>
        </trans-unit>
        <trans-unit id="1d3b684c7214d0c281c4454aed5c04034ff88811" translate="yes" xml:space="preserve">
          <source>Quoted identifiers, such as strings (&lt;code&gt;&quot;ol&amp;aacute;&quot;&lt;/code&gt;) and charlists (&lt;code&gt;'ol&amp;aacute;'&lt;/code&gt;), support Unicode since Elixir v1.0. Strings are UTF-8 encoded. Charlists are lists of Unicode code points. In such cases, the contents are kept as written by developers, without any transformation.</source>
          <target state="translated">문자열 ( &lt;code&gt;&quot;ol&amp;aacute;&quot;&lt;/code&gt; ) 및 &lt;code&gt;'ol&amp;aacute;'&lt;/code&gt; ( 'ol&amp;aacute;' ) 과 같은 따옴표 붙은 식별자는 Elixir v1.0부터 유니 코드를 지원합니다. 문자열은 UTF-8로 인코딩됩니다. Charlist는 유니 코드 코드 포인트 목록입니다. 이 경우 내용은 개발자가 작성한 그대로 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="60fefb29eda0237f92306cb85899330ca8b230ee" translate="yes" xml:space="preserve">
          <source>Quoting</source>
          <target state="translated">Quoting</target>
        </trans-unit>
        <trans-unit id="db712921d6fecc09e09fab853318c381738ce114" translate="yes" xml:space="preserve">
          <source>R1. Default Identifiers</source>
          <target state="translated">R1. 기본 식별자</target>
        </trans-unit>
        <trans-unit id="26b991df92308f2a367c957c4d50b613aa415ed2" translate="yes" xml:space="preserve">
          <source>R3. Pattern_White_Space and Pattern_Syntax Characters</source>
          <target state="translated">R3. Pattern_White_Space 및 Pattern_Syntax 문자</target>
        </trans-unit>
        <trans-unit id="64f597518b8819e33beed326e0aef13663d12b03" translate="yes" xml:space="preserve">
          <source>R6. Filtered Normalized Identifiers</source>
          <target state="translated">R6. 필터링 된 정규화 된 식별자</target>
        </trans-unit>
        <trans-unit id="6f4503a9f856bd401816cf9c9537b400021fea70" translate="yes" xml:space="preserve">
          <source>Race conditions?</source>
          <target state="translated">경쟁 조건?</target>
        </trans-unit>
        <trans-unit id="8fdd3d5744b14fe8df2f78525ff278b3980dcf70" translate="yes" xml:space="preserve">
          <source>Raised when a struct cannot be inspected.</source>
          <target state="translated">구조체를 검사 할 수 없을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fa9e03b9a6f82b7dabd4d26d477bd23b2afc1a4f" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; if the given &lt;code&gt;padding&lt;/code&gt; contains a non-string element.</source>
          <target state="translated">레이즈 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 주어진 경우 &lt;code&gt;padding&lt;/code&gt; 문자열이 아닌 요소가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="af83d7d1086d026fc286f4645bae49fd7306d517" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;arithmeticerror&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;enumerable&lt;/code&gt; contains a non-numeric value.</source>
          <target state="translated">발생시킵니다 &lt;a href=&quot;arithmeticerror&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; 을&lt;/a&gt; 경우 &lt;code&gt;enumerable&lt;/code&gt; 숫자가 아닌 값이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d76c0d9f487f5fbe07e874551d88d47fee0d896" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;arithmeticerror&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;right&lt;/code&gt; is 0 or 0.0.</source>
          <target state="translated">올린다 &lt;a href=&quot;arithmeticerror&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; 을&lt;/a&gt; 경우 &lt;code&gt;right&lt;/code&gt; 으로 0 또는 0.0이다.</target>
        </trans-unit>
        <trans-unit id="3c67dbd468ad8055254ab3928808c3935464e4ce" translate="yes" xml:space="preserve">
          <source>Raises &lt;a href=&quot;enum.emptyerror&quot;&gt;&lt;code&gt;Enum.EmptyError&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;enumerable&lt;/code&gt; is empty.</source>
          <target state="translated">발생시킵니다 &lt;a href=&quot;enum.emptyerror&quot;&gt; &lt;code&gt;Enum.EmptyError&lt;/code&gt; 는&lt;/a&gt; 경우 &lt;code&gt;enumerable&lt;/code&gt; 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2d343a2295f4d5274dcbfd886a84ccb41642f80" translate="yes" xml:space="preserve">
          <source>Raises &lt;code&gt;OutOfBoundsError&lt;/code&gt; if the given &lt;code&gt;index&lt;/code&gt; is outside the range of the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">올린다 &lt;code&gt;OutOfBoundsError&lt;/code&gt; 가 지정된 경우에는 &lt;code&gt;index&lt;/code&gt; 의 범위를 벗어난 &lt;code&gt;enumerable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d62f9ebd9e34654105a0b6ae931724ee62a02cc0" translate="yes" xml:space="preserve">
          <source>Raises a &lt;a href=&quot;version.invalidversionerror&quot;&gt;&lt;code&gt;Version.InvalidVersionError&lt;/code&gt;&lt;/a&gt; exception if any of the two given versions are not parsable. If given an already parsed version this function won't raise.</source>
          <target state="translated">발생시킵니다 &lt;a href=&quot;version.invalidversionerror&quot;&gt; &lt;code&gt;Version.InvalidVersionError&lt;/code&gt; 의&lt;/a&gt; 두 주어진 버전 중 하나를 분석 할 수없는 경우 예외를. 이미 구문 분석 된 버전이 제공되면이 기능은 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cab5e5df328b4ddb83cc91a4e5866b2d049b9bdc" translate="yes" xml:space="preserve">
          <source>Raises a Mix error that is nicely formatted.</source>
          <target state="translated">형식이 좋은 믹스 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="c1c33aaefd8234c7625624d93eaccbd66022ca1e" translate="yes" xml:space="preserve">
          <source>Raises an &lt;a href=&quot;arithmeticerror&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt; exception if one of the arguments is not an integer, or when the &lt;code&gt;divisor&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">제기 &lt;a href=&quot;arithmeticerror&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; 의&lt;/a&gt; 인자 중 하나가 정수가 아닌 경우, 또는 경우에 예외를 &lt;code&gt;divisor&lt;/code&gt; 이다 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9f054f51eef773e350ffd8e720d8ef1c2f7f1d3" translate="yes" xml:space="preserve">
          <source>Raises an error if &lt;code&gt;base&lt;/code&gt; is less than 2 or more than 36.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; 이 2보다 작거나 36보다 크면 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="81fe4cb7e7c869e7a34bf872a48cb536514bff12" translate="yes" xml:space="preserve">
          <source>Raises an error if &lt;code&gt;supervisor&lt;/code&gt; has reached the maximum number of children.</source>
          <target state="translated">&lt;code&gt;supervisor&lt;/code&gt; 가 최대 자녀 수에 도달 하면 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="f213a5266dc7fd081628bda995fed2c1460d6ab8" translate="yes" xml:space="preserve">
          <source>Raises an error if all conditions evaluate to &lt;code&gt;nil&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. For this reason, it may be necessary to add a final always-truthy condition (anything non-&lt;code&gt;false&lt;/code&gt; and non-&lt;code&gt;nil&lt;/code&gt;), which will always match.</source>
          <target state="translated">모든 조건이 &lt;code&gt;nil&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 로 평가되면 오류가 발생합니다 . 이러한 이유로, 최종 항상 truthy 조건 (아무것도 아닌 추가 할 필요가있을 수있다 &lt;code&gt;false&lt;/code&gt; 과 비 &lt;code&gt;nil&lt;/code&gt; 이 항상 일치).</target>
        </trans-unit>
        <trans-unit id="6807fc8ee18e17589e66f450694ceab675bbe0db" translate="yes" xml:space="preserve">
          <source>Raises an error if retrieving or changing the current directory fails.</source>
          <target state="translated">현재 디렉토리 검색 또는 변경에 실패하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="164b30096b2ea6dfc6e8c86db79c4ab887d2f1ec" translate="yes" xml:space="preserve">
          <source>Raises an error if the module was already compiled.</source>
          <target state="translated">모듈이 이미 컴파일 된 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1ba05d6b0411d4457bd3803cd3e4d8649a31a71f" translate="yes" xml:space="preserve">
          <source>Raises an exception preserving a previous stacktrace.</source>
          <target state="translated">이전 스택 추적을 유지하는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="437ea54b50fe87d412f3bb3184bcdd4a6c352ece" translate="yes" xml:space="preserve">
          <source>Raises an exception.</source>
          <target state="translated">예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="a4d46f156dd7b4a5a2ee33034cfcad27d106e75f" translate="yes" xml:space="preserve">
          <source>Raises if the datetime is invalid. Attempting to convert an invalid ISO calendar date will produce an error tuple.</source>
          <target state="translated">날짜 시간이 유효하지 않은 경우 발생합니다. 잘못된 ISO 달력 날짜를 변환하려고하면 오류 튜플이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="71d1ef80cf35651a172132daf389ed313ef6e315" translate="yes" xml:space="preserve">
          <source>Raises if the format is invalid.</source>
          <target state="translated">형식이 유효하지 않으면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6519231f297c411772999cd1e8103552ac99be07" translate="yes" xml:space="preserve">
          <source>Raising exceptions</source>
          <target state="translated">예외 발생</target>
        </trans-unit>
        <trans-unit id="a16c5bbe4bf996740f257aa1e81bd57e4c52c8dd" translate="yes" xml:space="preserve">
          <source>Range</source>
          <target state="translated">Range</target>
        </trans-unit>
        <trans-unit id="72464e74832155795bb0fc97baa40a95fbc7222b" translate="yes" xml:space="preserve">
          <source>Ranges can be either increasing (&lt;code&gt;first &amp;lt;= last&lt;/code&gt;) or decreasing (&lt;code&gt;first &amp;gt; last&lt;/code&gt;). Ranges are also always inclusive.</source>
          <target state="translated">범위는 증가 ( &lt;code&gt;first &amp;lt;= last&lt;/code&gt; ) 또는 감소 ( &lt;code&gt;first &amp;gt; last&lt;/code&gt; ) 일 수 있습니다. 범위도 항상 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="cbd90679e7f8a9b39ae9a6c5d2cc092800f54ef9" translate="yes" xml:space="preserve">
          <source>Ranges must be created with the &lt;a href=&quot;date#range/2&quot;&gt;&lt;code&gt;Date.range/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">범위는 &lt;a href=&quot;date#range/2&quot;&gt; &lt;code&gt;Date.range/2&lt;/code&gt; &lt;/a&gt; 함수 로 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d488a3099ab1cce2c7739fdbf692916264525f0d" translate="yes" xml:space="preserve">
          <source>Ranges of dates can be either increasing (&lt;code&gt;first &amp;lt;= last&lt;/code&gt;) or decreasing (&lt;code&gt;first &amp;gt; last&lt;/code&gt;). They are also always inclusive.</source>
          <target state="translated">날짜 범위는 증가 ( &lt;code&gt;first &amp;lt;= last&lt;/code&gt; ) 또는 감소 ( &lt;code&gt;first &amp;gt; last&lt;/code&gt; ) 일 수 있습니다. 그들은 또한 항상 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8a225b1af2c34f53e990659786a3df7dde051221" translate="yes" xml:space="preserve">
          <source>Raw files</source>
          <target state="translated">원시 파일</target>
        </trans-unit>
        <trans-unit id="43be5d1fec74173cc456fcdb989d79f3a6d61e9b" translate="yes" xml:space="preserve">
          <source>Read the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; module documentation for more information about the general usage of &lt;a href=&quot;#async/1&quot;&gt;&lt;code&gt;async/1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#async/3&quot;&gt;&lt;code&gt;async/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#async/1&quot;&gt; &lt;code&gt;async/1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#async/3&quot;&gt; &lt;code&gt;async/3&lt;/code&gt; &lt;/a&gt; 의 일반적인 사용법에 대한 자세한 정보 는 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 모듈 문서를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="0788c3b600d4f3c0505743b96b49889736ec2d75" translate="yes" xml:space="preserve">
          <source>Read the documentation on the &lt;code&gt;Typespec&lt;/code&gt; page and &lt;a href=&quot;#%253C%253C%253E%253E/1&quot;&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt;&lt;/a&gt; for more information on typespecs and bitstrings respectively.</source>
          <target state="translated">typespecs 및 비트 열에 대한 자세한 내용 은 &lt;code&gt;Typespec&lt;/code&gt; 페이지 및 &lt;a href=&quot;#%253C%253C%253E%253E/1&quot;&gt; &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;/1&lt;/code&gt; 의 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a3889ae6a98ae0e53caf306c3aba6c242dcedd31" translate="yes" xml:space="preserve">
          <source>Reads a line from the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">IO &lt;code&gt;device&lt;/code&gt; 에서 라인을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="ed6358cfae9ed346de26368ca0c1a237b2160331" translate="yes" xml:space="preserve">
          <source>Reads a timer created by &lt;a href=&quot;#send_after/3&quot;&gt;&lt;code&gt;send_after/3&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#send_after/3&quot;&gt; &lt;code&gt;send_after/3&lt;/code&gt; 에&lt;/a&gt; 의해 작성된 타이머를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="31e0122bb1cd5932aff410ddb26d3668b99408af" translate="yes" xml:space="preserve">
          <source>Reads and writes attributes of the current module.</source>
          <target state="translated">현재 모듈의 속성을 읽고 씁니다.</target>
        </trans-unit>
        <trans-unit id="e5909314d3283d89421e87193f2a66ac8fa016fa" translate="yes" xml:space="preserve">
          <source>Reads from the IO &lt;code&gt;device&lt;/code&gt;.</source>
          <target state="translated">IO &lt;code&gt;device&lt;/code&gt; 에서 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="812e657f5b579f0750a1f48f3ac381f21e7e7a7d" translate="yes" xml:space="preserve">
          <source>Reads from the IO &lt;code&gt;device&lt;/code&gt;. The operation is Unicode unsafe.</source>
          <target state="translated">IO &lt;code&gt;device&lt;/code&gt; 에서 읽습니다 . 작업이 유니 코드 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1e72b88bea14f6ca08acd272c7aa85760735eeb" translate="yes" xml:space="preserve">
          <source>Reads registry metadata given on &lt;a href=&quot;#start_link/1&quot;&gt;&lt;code&gt;start_link/1&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#start_link/1&quot;&gt; &lt;code&gt;start_link/1&lt;/code&gt; &lt;/a&gt; 에 제공된 레지스트리 메타 데이터를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="6e4bfe8b8059fffe67509581ca8fd8bb5863a979" translate="yes" xml:space="preserve">
          <source>Reads the client request and writes a response back</source>
          <target state="translated">클라이언트 요청을 읽고 응답을 다시 씁니다.</target>
        </trans-unit>
        <trans-unit id="d5eb24730d097e029875864fbd190d1f5f20b06f" translate="yes" xml:space="preserve">
          <source>Reads the configuration file.</source>
          <target state="translated">구성 파일을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="dc12f308ba360c8064a3568dfa28b47e57204e51" translate="yes" xml:space="preserve">
          <source>Reads the current process metadata.</source>
          <target state="translated">현재 프로세스 메타 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="c48fac6c8d1d06337a98d9b155bf84f8445d1d91" translate="yes" xml:space="preserve">
          <source>Reads the given configuration file alongside its imports.</source>
          <target state="translated">주어진 구성 파일을 가져 오기와 함께 읽습니다.</target>
        </trans-unit>
        <trans-unit id="6d834acb879e83f8d42700d86e86927b636c6aea" translate="yes" xml:space="preserve">
          <source>Reads the symbolic link at &lt;code&gt;path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 에서 심볼릭 링크를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="9c1cdacc82e6db0a4e1b004d6bdbb8cec9ef88a1" translate="yes" xml:space="preserve">
          <source>Receives a &lt;code&gt;list&lt;/code&gt; of tuples and deletes the first tuple where the element at &lt;code&gt;position&lt;/code&gt; matches the given &lt;code&gt;key&lt;/code&gt;. Returns the new list.</source>
          <target state="translated">수신 &lt;code&gt;list&lt;/code&gt; 튜플과 소자의 제 튜플 삭제 &lt;code&gt;position&lt;/code&gt; 지정된 일치 &lt;code&gt;key&lt;/code&gt; . 새로운리스트를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="5c5edba47e63948282ba7aa49263dd69fdc08f5b" translate="yes" xml:space="preserve">
          <source>Receives a &lt;code&gt;list&lt;/code&gt; of tuples and replaces the element identified by &lt;code&gt;key&lt;/code&gt; at &lt;code&gt;position&lt;/code&gt; with &lt;code&gt;new_tuple&lt;/code&gt;.</source>
          <target state="translated">튜플 &lt;code&gt;list&lt;/code&gt; 을 수신하고 &lt;code&gt;position&lt;/code&gt; 에서 &lt;code&gt;key&lt;/code&gt; 식별 된 요소 를 &lt;code&gt;new_tuple&lt;/code&gt; 로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="52a2ed027070830b2b704b10a1ab579fee6aa05a" translate="yes" xml:space="preserve">
          <source>Receives a &lt;code&gt;list&lt;/code&gt; of tuples and returns the first tuple where the element at &lt;code&gt;position&lt;/code&gt; in the tuple matches the given &lt;code&gt;key&lt;/code&gt;, as well as the &lt;code&gt;list&lt;/code&gt; without found tuple.</source>
          <target state="translated">수신 &lt;code&gt;list&lt;/code&gt; 튜플을하고있는 요소 첫 번째 튜플 반환 &lt;code&gt;position&lt;/code&gt; 튜플에 지정된 일치하는 &lt;code&gt;key&lt;/code&gt; 뿐만 아니라 &lt;code&gt;list&lt;/code&gt; 을 발견 튜플 않고 있습니다.</target>
        </trans-unit>
        <trans-unit id="53639bc3bc3a88fb72d354e316fd411a08ad54fc" translate="yes" xml:space="preserve">
          <source>Receives a key-value enumerable and converts it to &lt;a href=&quot;#t:argv/0&quot;&gt;&lt;code&gt;argv/0&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">열거 가능한 키-값을 받아서 &lt;a href=&quot;#t:argv/0&quot;&gt; &lt;code&gt;argv/0&lt;/code&gt; 으로&lt;/a&gt; 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="f8a8cddc4edd4b8cb647e915685f66b6aa81c4ae" translate="yes" xml:space="preserve">
          <source>Receives a list of &lt;code&gt;children&lt;/code&gt; (workers or supervisors) to supervise and a set of &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">감독 할 &lt;code&gt;children&lt;/code&gt; (작업자 또는 감독자) 목록 과 &lt;code&gt;options&lt;/code&gt; 세트를 받습니다.</target>
        </trans-unit>
        <trans-unit id="fe2e430f09d68bd297bf576261b80cdda5635920" translate="yes" xml:space="preserve">
          <source>Receives a list of &lt;code&gt;children&lt;/code&gt; to initialize and a set of &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">초기화 할 &lt;code&gt;children&lt;/code&gt; 목록 과 &lt;code&gt;options&lt;/code&gt; 집합을 받습니다 .</target>
        </trans-unit>
        <trans-unit id="4f56a4374996752d9c7b0d8cda70d77fc3e98719" translate="yes" xml:space="preserve">
          <source>Receives a list of tuples and if the identified element by &lt;code&gt;key&lt;/code&gt; at &lt;code&gt;position&lt;/code&gt; exists, it is replaced with &lt;code&gt;new_tuple&lt;/code&gt;.</source>
          <target state="translated">튜플들의 목록을 수신하여 상기 식별 소자 경우 &lt;code&gt;key&lt;/code&gt; 의 &lt;code&gt;position&lt;/code&gt; 존재하며, 그것으로 치환 &lt;code&gt;new_tuple&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d1535576671aa2ff6cdb67db512b203dfc4edba" translate="yes" xml:space="preserve">
          <source>Receives a list of tuples and returns &lt;code&gt;true&lt;/code&gt; if there is a tuple where the element at &lt;code&gt;position&lt;/code&gt; in the tuple matches the given &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">튜플 반환 목록 수신 &lt;code&gt;true&lt;/code&gt; 있는 요소 튜플이있는 경우 &lt;code&gt;position&lt;/code&gt; 튜플에 지정된 일치하는 &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f773b7b4671a15478a78104b05a8ac1289c68e25" translate="yes" xml:space="preserve">
          <source>Receives a list of tuples and returns the first tuple where the element at &lt;code&gt;position&lt;/code&gt; in the tuple matches the given &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">튜플의리스트를 수신하고있는 요소 첫 번째 튜플 반환 &lt;code&gt;position&lt;/code&gt; 튜플에 지정된 일치하는 &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da55da43556e6c04aee3a123495216a662a853e8" translate="yes" xml:space="preserve">
          <source>Receives a list of tuples and sorts the elements at &lt;code&gt;position&lt;/code&gt; of the tuples. The sort is stable.</source>
          <target state="translated">튜플 목록을 수신하고 튜플 &lt;code&gt;position&lt;/code&gt; 에서 요소를 정렬합니다 . 정렬이 안정적입니다.</target>
        </trans-unit>
        <trans-unit id="14e20d5c24dff9fd9fe9735cab3e8e1de2a2fe94" translate="yes" xml:space="preserve">
          <source>Receives a module, fun and arity and formats it as shown in stacktraces. The arity may also be a list of arguments.</source>
          <target state="translated">모듈, 재미 및 arity를 ​​수신하고 스택 추적에 표시된대로 형식을 지정합니다. arity는 인수 목록 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e687df4d6dc594b8acd5822458421f8788bb8599" translate="yes" xml:space="preserve">
          <source>Receives a protocol and a list of implementations and consolidates the given protocol.</source>
          <target state="translated">프로토콜 및 구현 목록을 수신하고 지정된 프로토콜을 통합합니다.</target>
        </trans-unit>
        <trans-unit id="22210bb4fc25b4244ff90b5d68a7d14f3ce7571b" translate="yes" xml:space="preserve">
          <source>Receives a regex, a binary and a replacement, returns a new binary where all matches are replaced by the replacement.</source>
          <target state="translated">정규식, 바이너리 및 대체를 수신하고 모든 일치 항목이 대체로 대체되는 새 바이너리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b61e49df8ff67a9ca03bd1b42a8bb519e4a1c105" translate="yes" xml:space="preserve">
          <source>Receives a set of &lt;code&gt;options&lt;/code&gt; that initializes a dynamic supervisor.</source>
          <target state="translated">동적 감독자를 초기화하는 &lt;code&gt;options&lt;/code&gt; 세트를받습니다 .</target>
        </trans-unit>
        <trans-unit id="d9f6da4d53fe4ab814d14ca17ef2d1aa84915fba" translate="yes" xml:space="preserve">
          <source>Receives a stacktrace entry and formats it into a string.</source>
          <target state="translated">스택 추적 항목을 받아서 문자열로 형식화합니다.</target>
        </trans-unit>
        <trans-unit id="e7746187c8e8540596d6f16990c4f1faef1d5f41" translate="yes" xml:space="preserve">
          <source>Receives a task name and retrieves the task module.</source>
          <target state="translated">작업 이름을 받고 작업 모듈을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="b879ac32fa8c2699d4481ef4abf60cb310c50593" translate="yes" xml:space="preserve">
          <source>Receives a task name and returns the task module if found.</source>
          <target state="translated">작업 이름을 받고 작업 모듈을 찾으면 반환합니다.</target>
        </trans-unit>
        <trans-unit id="98d45f98af3936ac871d1b420e669aa3ba75d6f8" translate="yes" xml:space="preserve">
          <source>Receives an AST node and expands it once.</source>
          <target state="translated">AST 노드를 받아서 한 번 확장합니다.</target>
        </trans-unit>
        <trans-unit id="ed69a15b3b64f165dbfcf50544a8d1db805c1151" translate="yes" xml:space="preserve">
          <source>Receives an AST node and expands it until it can no longer be expanded.</source>
          <target state="translated">AST 노드를 받아서 더 이상 확장 할 수 없을 때까지 확장합니다.</target>
        </trans-unit>
        <trans-unit id="157d1b07d7f33e05788480f92dab05c717cb2225" translate="yes" xml:space="preserve">
          <source>Receives an anonymous function and arity and formats it as shown in stacktraces. The arity may also be a list of arguments.</source>
          <target state="translated">익명 함수 및 arity를 ​​수신하고 stacktrace에 표시된대로 형식화합니다. arity는 인수 목록 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="828e3869ea6e3d553f5eaefa42fd41690b88d620" translate="yes" xml:space="preserve">
          <source>Receives any argument (not just booleans) and returns &lt;code&gt;true&lt;/code&gt; if the argument is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;nil&lt;/code&gt;; returns &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">부울뿐만 아니라 모든 인수를 수신 하고 인수가 &lt;code&gt;false&lt;/code&gt; 또는 &lt;code&gt;nil&lt;/code&gt; 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 반환 &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="43850c741265049e669da2f26b793fdc8099376d" translate="yes" xml:space="preserve">
          <source>Receives two log levels and compares the &lt;code&gt;left&lt;/code&gt; level against the &lt;code&gt;right&lt;/code&gt; level and returns:</source>
          <target state="translated">두 개의 로그 레벨을 수신하고 &lt;code&gt;left&lt;/code&gt; 레벨을 &lt;code&gt;right&lt;/code&gt; 레벨과 비교하여 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="95c9f8acfe3b80419501346e27b07cd7c2e9cb26" translate="yes" xml:space="preserve">
          <source>Receiving &quot;regular&quot; messages</source>
          <target state="translated">&quot;정기적 인&quot;메시지 수신</target>
        </trans-unit>
        <trans-unit id="4faa65b556f68207d69cb14bcae4acb71980a036" translate="yes" xml:space="preserve">
          <source>Recommendations</source>
          <target state="translated">Recommendations</target>
        </trans-unit>
        <trans-unit id="874c8febf7705c239b56db21c6da13bb314c78a3" translate="yes" xml:space="preserve">
          <source>Recompiles and reloads the given &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;module&lt;/code&gt; 다시 컴파일하고 다시로드합니다 .</target>
        </trans-unit>
        <trans-unit id="b4fd4d9956d6c550135e0c055d986e451b87cd45" translate="yes" xml:space="preserve">
          <source>Recompiles the current Mix application.</source>
          <target state="translated">현재 믹스 애플리케이션을 다시 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="2cbd52477e5a038bbc04e1ed928ac44c43841076" translate="yes" xml:space="preserve">
          <source>Recompiles the existing regular expression and raises &lt;a href=&quot;regex.compileerror&quot;&gt;&lt;code&gt;Regex.CompileError&lt;/code&gt;&lt;/a&gt; in case of errors.</source>
          <target state="translated">기존 정규식을 다시 컴파일하고 오류 발생시 &lt;a href=&quot;regex.compileerror&quot;&gt; &lt;code&gt;Regex.CompileError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="9512d561ed1cc337da6646bba4a0fe0f82cc1019" translate="yes" xml:space="preserve">
          <source>Recompiles the existing regular expression if necessary.</source>
          <target state="translated">필요한 경우 기존 정규식을 다시 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="1c54132b8e5a9fa44a9a1a7d30b1be36ab3c4247" translate="yes" xml:space="preserve">
          <source>Record</source>
          <target state="translated">Record</target>
        </trans-unit>
        <trans-unit id="f92fd6b1074e6e79dfba76d8cd7647ef66632e5a" translate="yes" xml:space="preserve">
          <source>Records are simply tuples where the first element is an atom:</source>
          <target state="translated">레코드는 단순히 첫 번째 요소가 원자 인 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="8f1975a7def41720ec9c94792bc4fc65a7c012e4" translate="yes" xml:space="preserve">
          <source>Recursion</source>
          <target state="translated">Recursion</target>
        </trans-unit>
        <trans-unit id="1e9eb42c791ec696e90bc24ffe375c923de0f651" translate="yes" xml:space="preserve">
          <source>Recursion and &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;tail call&lt;/a&gt; optimization are an important part of Elixir and are commonly used to create loops. However, when programming in Elixir you will rarely use recursion as above to manipulate lists.</source>
          <target state="translated">재귀 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tail_call&quot;&gt;꼬리 호출&lt;/a&gt; 최적화는 Elixir의 중요한 부분이며 일반적으로 루프를 만드는 데 사용됩니다. 그러나 Elixir에서 프로그래밍 할 때 위와 같이 재귀를 사용하여 목록을 조작하는 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="90e048b53959a81bc3861b57069e375346d404f4" translate="yes" xml:space="preserve">
          <source>Recursively escapes a value so it can be inserted into a syntax tree.</source>
          <target state="translated">값을 재귀 적으로 이스케이프하여 구문 트리에 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9aa5f460115ac32f0d34ca300a72820b95cfe5a4" translate="yes" xml:space="preserve">
          <source>Redefining existing operators</source>
          <target state="translated">기존 연산자 재정의</target>
        </trans-unit>
        <trans-unit id="5ec592dbd43af61e2cbf6d03b3e9ee6ca088c0f2" translate="yes" xml:space="preserve">
          <source>Reduce (sometimes called &lt;code&gt;fold&lt;/code&gt;) is a basic building block in functional programming. Almost all of the functions in the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; module can be implemented on top of reduce. Those functions often rely on other operations, such as &lt;a href=&quot;enum#reverse/1&quot;&gt;&lt;code&gt;Enum.reverse/1&lt;/code&gt;&lt;/a&gt;, which are optimized by the runtime.</source>
          <target state="translated">Reduce (때때로 &lt;code&gt;fold&lt;/code&gt; 라고도 함 )는 함수형 프로그래밍의 기본 구성 요소입니다. &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 모듈 의 거의 모든 기능 은 reduce 외에 구현 될 수 있습니다. 이러한 함수는 종종 런타임에 의해 최적화되는 &lt;a href=&quot;enum#reverse/1&quot;&gt; &lt;code&gt;Enum.reverse/1&lt;/code&gt; &lt;/a&gt; 과 같은 다른 작업에 의존 합니다.</target>
        </trans-unit>
        <trans-unit id="95a8f2e0d9b4cee6851a4ae983d29171ececc54e" translate="yes" xml:space="preserve">
          <source>Reduce and map algorithms</source>
          <target state="translated">알고리즘 축소 및 매핑</target>
        </trans-unit>
        <trans-unit id="32ab9de27d58bcc7d4d54b8d17c7484a6d29e607" translate="yes" xml:space="preserve">
          <source>Reduce as a building block</source>
          <target state="translated">빌딩 블록으로 축소</target>
        </trans-unit>
        <trans-unit id="6b8baf4751a0c397c470aa1b489e04d78981d396" translate="yes" xml:space="preserve">
          <source>Reduces &lt;code&gt;enumerable&lt;/code&gt; until &lt;code&gt;fun&lt;/code&gt; returns &lt;code&gt;{:halt, term}&lt;/code&gt;.</source>
          <target state="translated">감소 &lt;code&gt;enumerable&lt;/code&gt; 될 때까지 &lt;code&gt;fun&lt;/code&gt; 반환 &lt;code&gt;{:halt, term}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3fe1324757a1c4900c6719d6fc7cfb276e4826c" translate="yes" xml:space="preserve">
          <source>Reduces the &lt;code&gt;enumerable&lt;/code&gt; into an element.</source>
          <target state="translated">절감된다 &lt;code&gt;enumerable&lt;/code&gt; 된 요소로한다.</target>
        </trans-unit>
        <trans-unit id="2dbe68b1eeba6b24ea1fba9cc612db280c6c2f67" translate="yes" xml:space="preserve">
          <source>Reenables a given task so it can be executed again down the stack.</source>
          <target state="translated">주어진 작업을 다시 활성화하여 스택에서 다시 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b03cbaefa850378932be35a87004bee63b000cd" translate="yes" xml:space="preserve">
          <source>Reference - a unique value in the runtime system, created with &lt;a href=&quot;#make_ref/0&quot;&gt;&lt;code&gt;make_ref/0&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">참조-런타임 시스템에서 고유 한 값으로 &lt;a href=&quot;#make_ref/0&quot;&gt; &lt;code&gt;make_ref/0&lt;/code&gt; 으로&lt;/a&gt; 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="51ad2be02b9697cd310cca4ee9b8b7aa0b47c088" translate="yes" xml:space="preserve">
          <source>Reference a &lt;code&gt;@callback&lt;/code&gt; by prepending &lt;code&gt;c:&lt;/code&gt;, as in &lt;code&gt;`c:world/1`&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;`c:world/1`&lt;/code&gt; 에서처럼 &lt;code&gt;c:&lt;/code&gt; 를 앞에 &lt;code&gt;@callback&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1dbfb2cc2895149d87c5f4f6bbe82a4d53911ad9" translate="yes" xml:space="preserve">
          <source>Reference a &lt;code&gt;@type&lt;/code&gt; by prepending &lt;code&gt;t:&lt;/code&gt;, as in &lt;code&gt;`t:values/0`&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;`t:values/0`&lt;/code&gt; 에서처럼 &lt;code&gt;t:&lt;/code&gt; 를 앞에 &lt;code&gt;@type&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="59cb3fcffb3799341188ccd1da595b261b4be7ab" translate="yes" xml:space="preserve">
          <source>Reference and functions for working with protocols.</source>
          <target state="translated">프로토콜 작업을위한 참조 및 기능.</target>
        </trans-unit>
        <trans-unit id="98efd6e2a6b118bb5b50c8bbc16e0f5cd3315ce0" translate="yes" xml:space="preserve">
          <source>Reference functions by name and arity if they are local, as in &lt;code&gt;`world/1`&lt;/code&gt;, or by module, name and arity if pointing to an external module: &lt;code&gt;`MyApp.Hello.world/1`&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;`world/1`&lt;/code&gt; 에서처럼 로컬에 있으면 이름과 arity 또는 외부 모듈을 가리키는 경우 모듈, 이름과 arity에 의해 함수를 참조하십시오 : &lt;code&gt;`MyApp.Hello.world/1`&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26fa88e9bd1e552c7f736c12a86e4b0eb3d12567" translate="yes" xml:space="preserve">
          <source>Reference modules by their full name.</source>
          <target state="translated">전체 이름으로 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fda05af620d8f7d239d3f6e8e81b4403108f221e" translate="yes" xml:space="preserve">
          <source>Reflection</source>
          <target state="translated">Reflection</target>
        </trans-unit>
        <trans-unit id="105376683ec11cee0e5b5973530213234a5fd201" translate="yes" xml:space="preserve">
          <source>Refute received with an explicit timeout:</source>
          <target state="translated">명시적인 시간 초과로받은 반품 :</target>
        </trans-unit>
        <trans-unit id="8fd8f41db359717b5f94a5befb85555200773286" translate="yes" xml:space="preserve">
          <source>Regardless of whether &lt;code&gt;=&amp;gt;&lt;/code&gt; or the keyword syntax is used, key-value pairs in maps are always represented internally as a list of two-element tuples for simplicity:</source>
          <target state="translated">&lt;code&gt;=&amp;gt;&lt;/code&gt; 또는 키워드 구문 사용 여부에 관계없이 맵의 키-값 쌍은 항상 내부적으로 단순성을 위해 두 개의 요소 튜플 목록으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6e681935761236016678d2656c1d667f0fe6fdac" translate="yes" xml:space="preserve">
          <source>Regex</source>
          <target state="translated">Regex</target>
        </trans-unit>
        <trans-unit id="ea0563594d23ed77538002a13830e067953e4a2b" translate="yes" xml:space="preserve">
          <source>Regex is based on PCRE (Perl Compatible Regular Expressions) and built on top of Erlang's &lt;code&gt;:re&lt;/code&gt; module. More information can be found in the &lt;a href=&quot;http://www.erlang.org/doc/man/re.html&quot;&gt;&lt;code&gt;:re&lt;/code&gt; module documentation&lt;/a&gt;.</source>
          <target state="translated">정규식은 PCRE (Perl Compatible Regular Expressions)를 기반으로하며 Erlang의 &lt;code&gt;:re&lt;/code&gt; 모듈 위에 구축되었습니다 . 자세한 내용은 &lt;a href=&quot;http://www.erlang.org/doc/man/re.html&quot;&gt; &lt;code&gt;:re&lt;/code&gt; 모듈 설명서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e7ac6184c6bddf346a5bb04f8cb4bb31ff3c577" translate="yes" xml:space="preserve">
          <source>Regex supports several built in named character classes. These are used by enclosing the class name in &lt;code&gt;[: :]&lt;/code&gt; inside a group. For example:</source>
          <target state="translated">정규식은 여러 내장 된 명명 된 문자 클래스를 지원합니다. 이것들은 그룹 내부 의 클래스 이름을 &lt;code&gt;[: :]&lt;/code&gt; 로 묶어서 사용됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f4773b8001d2a236f1f42a57de7334762ef6a6f" translate="yes" xml:space="preserve">
          <source>Regex.CompileError</source>
          <target state="translated">Regex.CompileError</target>
        </trans-unit>
        <trans-unit id="2b2c167065a8849bc602af6807d29b6301a6af4e" translate="yes" xml:space="preserve">
          <source>Regex.CompileError &lt;small&gt;exception&lt;/small&gt;</source>
          <target state="translated">Regex.CompileError &lt;small&gt;예외&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="921e80bd802450f0a54f55dc59c8a5c73048f3e4" translate="yes" xml:space="preserve">
          <source>Registering under a unique registry does not allow multiple entries:</source>
          <target state="translated">고유 한 레지스트리에 등록하면 여러 항목을 입력 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8b68501359664aa7e3f357030fc262fc752fa96a" translate="yes" xml:space="preserve">
          <source>Registers a &lt;code&gt;pluralization&lt;/code&gt; for &lt;code&gt;word&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;word&lt;/code&gt; 대한 &lt;code&gt;pluralization&lt;/code&gt; 을 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="cfbc6d24a7a7f0d56fb406aa6036b3e12ffb8353" translate="yes" xml:space="preserve">
          <source>Registers a function that will be invoked at the end of program execution. Useful for invoking a hook in &quot;script&quot; mode.</source>
          <target state="translated">프로그램 실행이 끝날 때 호출 될 함수를 등록합니다. &quot;스크립트&quot;모드에서 후크를 호출하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2177c0410d7f5895415b852d1e80afeff722f655" translate="yes" xml:space="preserve">
          <source>Registers a function to be invoked after the IEx process is spawned.</source>
          <target state="translated">IEx 프로세스가 생성 된 후 호출 할 함수를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="b7cdc0be7757e71f965b3c7ad3fb440f76e506dd" translate="yes" xml:space="preserve">
          <source>Registers a function to run as part of this case.</source>
          <target state="translated">이 경우에 실행할 함수를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="b973e327e3c021c877cc4d29399fa35fa83e3213" translate="yes" xml:space="preserve">
          <source>Registers a new attribute to be used during &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;ExUnit.Case&lt;/code&gt;&lt;/a&gt; tests.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;ExUnit.Case&lt;/code&gt; &lt;/a&gt; 테스트 중에 사용할 새 속성을 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="0e8cf2b4cc8729f25da603ab355783aa05318c46" translate="yes" xml:space="preserve">
          <source>Registers a program exit handler function.</source>
          <target state="translated">프로그램 종료 핸들러 기능을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="86f9550834cf29f2c28787220b59431f4c42e38c" translate="yes" xml:space="preserve">
          <source>Registers an attribute.</source>
          <target state="translated">속성을 등록합니다.</target>
        </trans-unit>
        <trans-unit id="949e454436ebf7fa4a322e7a723b37231ac63ba1" translate="yes" xml:space="preserve">
          <source>Registers the current process under the given &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;registry&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;key&lt;/code&gt; 아래에 현재 프로세스 를 &lt;code&gt;registry&lt;/code&gt; 에 등록 합니다.</target>
        </trans-unit>
        <trans-unit id="f5cea0af6cc948234d2b641ef218832cc68cbc8f" translate="yes" xml:space="preserve">
          <source>Registers the default &lt;code&gt;port&lt;/code&gt; for the given &lt;code&gt;scheme&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;scheme&lt;/code&gt; 의 기본 &lt;code&gt;port&lt;/code&gt; 를 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="3f29bbe119d2296da4e21436992a76df3eb6cb3e" translate="yes" xml:space="preserve">
          <source>Registers the given &lt;code&gt;pid_or_port&lt;/code&gt; under the given &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;pid_or_port&lt;/code&gt; 를 주어진 &lt;code&gt;name&lt;/code&gt; 등록합니다 .</target>
        </trans-unit>
        <trans-unit id="dddbe6429e016c47c4e1888ab89c26f58346135b" translate="yes" xml:space="preserve">
          <source>Registrations</source>
          <target state="translated">Registrations</target>
        </trans-unit>
        <trans-unit id="435305e548b36c7d783e828784397c394c2d994b" translate="yes" xml:space="preserve">
          <source>Registries can also be used to implement a local, non-distributed, scalable PubSub by relying on the &lt;a href=&quot;#dispatch/3&quot;&gt;&lt;code&gt;dispatch/3&lt;/code&gt;&lt;/a&gt; function, similarly to the previous section: in this case, however, we will send messages to each associated process, instead of invoking a given module-function.</source>
          <target state="translated">레지스트리는 이전 섹션과 유사하게 &lt;a href=&quot;#dispatch/3&quot;&gt; &lt;code&gt;dispatch/3&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 로컬의 비 분배 확장 가능 PubSub를 구현하는 데 사용될 수 있습니다 . 주어진 모듈 기능.</target>
        </trans-unit>
        <trans-unit id="1fd6a805dae745c87a8b89f1be1a738e608a1668" translate="yes" xml:space="preserve">
          <source>Registry</source>
          <target state="translated">Registry</target>
        </trans-unit>
        <trans-unit id="3172c4ae8fee97c04bb506eac2e6f47443f5a679" translate="yes" xml:space="preserve">
          <source>Regular expressions</source>
          <target state="translated">정규식</target>
        </trans-unit>
        <trans-unit id="dbb5498e44eab5d71617ba625dacbfc1473d84fe" translate="yes" xml:space="preserve">
          <source>Regular expressions built with sigil are precompiled and stored in &lt;code&gt;.beam&lt;/code&gt; files. Precompiled regexes will be checked in runtime and may work slower between operating systems and OTP releases. This is rarely a problem, as most Elixir code shared during development is compiled on the target (such as dependencies, archives, and escripts) and, when running in production, the code must either be compiled on the target (via &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt;&lt;code&gt;mix compile&lt;/code&gt;&lt;/a&gt; or similar) or released on the host (via &lt;code&gt;mix releases&lt;/code&gt; or similar) with a matching OTP, OS and architecture as as the target.</source>
          <target state="translated">sigil로 &lt;code&gt;.beam&lt;/code&gt; 정규식은 사전 컴파일되어 .beam 파일에 저장됩니다 . 사전 컴파일 된 정규식은 런타임에 검사되며 운영 체제와 OTP 릴리스간에 느리게 작동 할 수 있습니다. 개발 중에 공유되는 대부분의 Elixir 코드가 대상 (예 : 종속성, 아카이브 및 escript)에서 컴파일되고 프로덕션에서 실행될 때 코드가 대상에서 컴파일되어야합니다 ( &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Compile.html&quot;&gt; &lt;code&gt;mix compile&lt;/code&gt; &lt;/a&gt; 또는 유사). ) 또는 대상으로 일치하는 OTP, OS 및 아키텍처 를 사용하여 호스트에서 ( &lt;code&gt;mix releases&lt;/code&gt; 또는 유사 를 통해 ) 릴리스됩니다 .</target>
        </trans-unit>
        <trans-unit id="75480c7e2a8cd4b557d0d4e69e47d2fba660d6e0" translate="yes" xml:space="preserve">
          <source>Regular expressions created via sigils are pre-compiled and stored in the &lt;code&gt;.beam&lt;/code&gt; file. Notice this may be a problem if you are precompiling Elixir, see the &quot;Precompilation&quot; section for more information.</source>
          <target state="translated">&lt;code&gt;.beam&lt;/code&gt; 를 통해 생성 된 정규식은 사전 컴파일되어 .beam 파일에 저장 됩니다. Elixir를 사전 컴파일하는 경우 이것이 문제가 될 수 있습니다. 자세한 내용은 &quot;사전 컴파일&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="662de58b3e1c7961e52834df747a357eb8207007" translate="yes" xml:space="preserve">
          <source>Regular expressions in Elixir can be created using the sigils &lt;code&gt;~r&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_r/2&quot;&gt;&lt;code&gt;Kernel.sigil_r/2&lt;/code&gt;&lt;/a&gt;) or &lt;code&gt;~R&lt;/code&gt; (see &lt;a href=&quot;kernel#sigil_R/2&quot;&gt;&lt;code&gt;Kernel.sigil_R/2&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">&lt;a href=&quot;kernel#sigil_r/2&quot;&gt; &lt;code&gt;Kernel.sigil_r/2&lt;/code&gt; &lt;/a&gt; &lt;code&gt;~r&lt;/code&gt; ( Kernel.sigil_r / 2 참조 ) 또는 &lt;code&gt;~R&lt;/code&gt; ( &lt;a href=&quot;kernel#sigil_R/2&quot;&gt; &lt;code&gt;Kernel.sigil_R/2&lt;/code&gt; &lt;/a&gt; 참조 )을 사용하여 Elixir의 정규 표현식을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8fa41d59c259d95cfaded10953d5a2f8e0b38bb4" translate="yes" xml:space="preserve">
          <source>Releases</source>
          <target state="translated">Releases</target>
        </trans-unit>
        <trans-unit id="da14bf586c00c0b2d6a162b461c2222bd3a8fda0" translate="yes" xml:space="preserve">
          <source>Releases allow developers to precompile and package all of their code and the runtime into a single unit. The benefits of releases are:</source>
          <target state="translated">릴리스를 통해 개발자는 모든 코드와 런타임을 하나의 단위로 사전 컴파일하고 패키지 할 수 있습니다. 릴리스의 이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6e22d2a45a39c91d823d515c586ebf0bbb7339d" translate="yes" xml:space="preserve">
          <source>Releases also provide built-in hooks for configuring almost every need of the production system:</source>
          <target state="translated">릴리스는 또한 거의 모든 프로덕션 시스템 요구를 구성하기위한 내장 후크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c9ca4a52a1dd10eb55da61c20c8394066a84c979" translate="yes" xml:space="preserve">
          <source>Relevant Type(s)</source>
          <target state="translated">관련 유형</target>
        </trans-unit>
        <trans-unit id="a5e5c7fbabf94e041bedf3cf78e00e95d579c10d" translate="yes" xml:space="preserve">
          <source>Remember Elixir makes a distinction between anonymous functions and named functions, where the former must be invoked with a dot (&lt;code&gt;.&lt;/code&gt;) between the variable name and parentheses. The capture operator bridges this gap by allowing named functions to be assigned to variables and passed as arguments in the same way we assign, invoke and pass anonymous functions.</source>
          <target state="translated">Elixir는 익명 함수와 명명 된 함수를 구분합니다. 여기서 변수 이름과 괄호 사이에 점 ( &lt;code&gt;.&lt;/code&gt; )을 사용하여 전자를 호출해야합니다 . 캡처 연산자는 명명 된 함수를 변수에 할당하고 익명 함수를 할당, 호출 및 전달하는 것과 같은 방식으로 인수로 전달함으로써 이러한 격차를 해소합니다.</target>
        </trans-unit>
        <trans-unit id="943e7d08a29ef9d83c317d0436320ee8105342c6" translate="yes" xml:space="preserve">
          <source>Remember however that our &lt;code&gt;KV.Registry&lt;/code&gt; is both linking (via &lt;code&gt;start_link&lt;/code&gt;) and monitoring (via &lt;code&gt;monitor&lt;/code&gt;) bucket processes in the &lt;code&gt;handle_cast/2&lt;/code&gt; callback:</source>
          <target state="translated">우리의 것을 그러나 기억 &lt;code&gt;KV.Registry&lt;/code&gt; 을 (를 통해 연결 둘 다 &lt;code&gt;start_link&lt;/code&gt; )과 (을 통해 모니터링 &lt;code&gt;monitor&lt;/code&gt; 에) 버킷 프로세스를 &lt;code&gt;handle_cast/2&lt;/code&gt; 콜백 :</target>
        </trans-unit>
        <trans-unit id="2339016231a3f611f706a0ff8268e0aeed0a9afe" translate="yes" xml:space="preserve">
          <source>Remember lists are literals, so they are represented as themselves in the AST:</source>
          <target state="translated">리스트는 리터럴이므로 AST에서 그대로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a9201bbeed5d03751538444a9bdfa2b7a2f29888" translate="yes" xml:space="preserve">
          <source>Remember that the name of a process can be any atom. So far, we have named processes with the same name as the modules that define their implementation. For example, the process defined by &lt;code&gt;KV.Registry&lt;/code&gt; was given a process name of &lt;code&gt;KV.Registry&lt;/code&gt;. This is simply a convention: If later there is an error in your system that says, &amp;ldquo;process named KV.Registry crashed with reason&amp;rdquo;, we know exactly where to investigate.</source>
          <target state="translated">프로세스 이름은 임의의 원자가 될 수 있습니다. 지금까지 구현을 정의하는 모듈과 동일한 이름으로 프로세스의 이름을 지정했습니다. 예를 들어, &lt;code&gt;KV.Registry&lt;/code&gt; 에 의해 정의 된 프로세스에는 &lt;code&gt;KV.Registry&lt;/code&gt; 프로세스 이름이 지정 되었습니다 . 이것은 컨벤션입니다. 나중에 시스템에 &quot;KV.Registry라는 프로세스가 이유와 충돌했습니다&quot;라는 오류가 발생하면 조사 할 위치를 정확히 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a23460e1d638c5436d4d647608a0c43461b2bb03" translate="yes" xml:space="preserve">
          <source>Remember that, because lists and two-element tuples are quoted literals, by definition keywords are also literals (in fact, the only reason tuples with two elements are quoted literals is to support keywords as literals).</source>
          <target state="translated">목록과 두 요소로 된 튜플은 리터럴로 인용되므로 정의에 따라 키워드도 리터럴입니다 (사실, 두 요소로 된 튜플이 리터럴로 인용되는 유일한 이유는 키워드를 리터럴로 지원하는 것입니다).</target>
        </trans-unit>
        <trans-unit id="547521c843600e88d013eb66991d1b7a08d0987f" translate="yes" xml:space="preserve">
          <source>Remember this function works with Unicode graphemes and considers the slices to represent grapheme offsets. If you want to split on raw bytes, check &lt;a href=&quot;kernel#binary_part/3&quot;&gt;&lt;code&gt;Kernel.binary_part/3&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 함수는 유니 코드 grapheme과 함께 작동하며 grapheme 오프셋을 나타내는 슬라이스를 고려합니다. 원시 바이트로 분할하려면 대신 &lt;a href=&quot;kernel#binary_part/3&quot;&gt; &lt;code&gt;Kernel.binary_part/3&lt;/code&gt; &lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="698cb20e961ee6d1a5f74b94b2a7a5aa2f31ae4b" translate="yes" xml:space="preserve">
          <source>Remember, comparisons in Elixir using &lt;a href=&quot;kernel#==/2&quot;&gt;&lt;code&gt;==/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253E/2&quot;&gt;&lt;code&gt;&amp;gt;/2&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kernel#%253C/2&quot;&gt;&lt;code&gt;&amp;lt;/2&lt;/code&gt;&lt;/a&gt; and friends are structural and based on the DateTime struct fields. For proper comparison between datetimes, use the &lt;a href=&quot;#compare/2&quot;&gt;&lt;code&gt;compare/2&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;kernel#==/2&quot;&gt; &lt;code&gt;==/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#%253E/2&quot;&gt; &lt;code&gt;&amp;gt;/2&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kernel#%253C/2&quot;&gt; &lt;code&gt;&amp;lt;/2&lt;/code&gt; &lt;/a&gt; 및 친구를 사용한 Elixir의 비교 는 구조적이며 DateTime 구조체 필드를 기반으로합니다. 날짜 / 시간을 올바르게 비교하려면 &lt;a href=&quot;#compare/2&quot;&gt; &lt;code&gt;compare/2&lt;/code&gt; &lt;/a&gt; 기능을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="27bb052d1b6cca59f0d8b8e080407897e513da28" translate="yes" xml:space="preserve">
          <source>Remote shells</source>
          <target state="translated">원격 쉘</target>
        </trans-unit>
        <trans-unit id="12e6e0a5538b479310c7704c6dff0686bcae2732" translate="yes" xml:space="preserve">
          <source>Remote types</source>
          <target state="translated">원격 유형</target>
        </trans-unit>
        <trans-unit id="ad7183d89f1b9dc5b75d0fb7a74934c2fe82e722" translate="yes" xml:space="preserve">
          <source>Removes a backend.</source>
          <target state="translated">백엔드를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="6b3c529ef7158c6c64f36c40c48665d4b841a4dc" translate="yes" xml:space="preserve">
          <source>Removes a translator.</source>
          <target state="translated">번역기를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="0e523878ea75291793b504604435509973416467" translate="yes" xml:space="preserve">
          <source>Removes all breakpoints and instrumentation from &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 에서 모든 중단 점 및 계측을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="6f725a049c858ae90de002f7c340c653cf53f9e1" translate="yes" xml:space="preserve">
          <source>Removes all breakpoints and instrumentation from all modules.</source>
          <target state="translated">모든 모듈에서 모든 중단 점 및 계측을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="5cde5498611d5dd73ab4c8f8109c899ca9bbce1f" translate="yes" xml:space="preserve">
          <source>Removes an element from a tuple.</source>
          <target state="translated">튜플에서 요소를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="e12499048521db44dd18f757b10e57bb80774e3b" translate="yes" xml:space="preserve">
          <source>Removes files and directories recursively at the given &lt;code&gt;path&lt;/code&gt;. Symlinks are not followed but simply removed, non-existing files are simply ignored (i.e. doesn't make this function fail).</source>
          <target state="translated">주어진 &lt;code&gt;path&lt;/code&gt; 에서 파일과 디렉토리를 재귀 적으로 제거합니다 . 심볼릭 링크는 따르지 않고 단순히 제거되며 존재하지 않는 파일은 단순히 무시됩니다 (즉,이 기능이 실패하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="7baee7a478497d4737825218f8e15ac03e8c6030" translate="yes" xml:space="preserve">
          <source>Removes files from the required files list.</source>
          <target state="translated">필요한 파일 목록에서 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="e097ba46638772c9b64fea773b1e61d5573174b4" translate="yes" xml:space="preserve">
          <source>Removes the entry with a given key from a container (a map, keyword list, or struct that implements the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Access&lt;/code&gt;&lt;/a&gt; behaviour).</source>
          <target state="translated">컨테이너 ( &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Access&lt;/code&gt; &lt;/a&gt; 동작 을 구현하는 맵, 키워드 목록 또는 구조체)에서 지정된 키가있는 항목을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="2ab0917eb6c0ad48d41081c9212ed112569e33de" translate="yes" xml:space="preserve">
          <source>Removes the first occurrence of an element on the left list for each element on the right.</source>
          <target state="translated">오른쪽의 각 요소에 대해 왼쪽 목록에서 요소의 첫 항목을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="2610a285dc9b1c68c5713f9aeb89d588d07b8d11" translate="yes" xml:space="preserve">
          <source>Removes the link between the calling process and the given item (process or port).</source>
          <target state="translated">호출 프로세스와 주어진 항목 (프로세스 또는 포트) 사이의 링크를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="f877e19fb1fb1b9f68495b6349dc80d7ef2d3e8e" translate="yes" xml:space="preserve">
          <source>Removes the registered &lt;code&gt;name&lt;/code&gt;, associated with a PID or a port identifier.</source>
          <target state="translated">PID 또는 포트 식별자와 연관된 등록 된 &lt;code&gt;name&lt;/code&gt; 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="e182592a215c0c2641cada9adb28ed54322e302f" translate="yes" xml:space="preserve">
          <source>Removes the variable &lt;code&gt;varname&lt;/code&gt; from the environment.</source>
          <target state="translated">환경에서 변수 &lt;code&gt;varname&lt;/code&gt; 을 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="6e1b55c9888c715281f3275cbe5053ffaabe0430" translate="yes" xml:space="preserve">
          <source>Renames the &lt;code&gt;source&lt;/code&gt; file to &lt;code&gt;destination&lt;/code&gt; file. It can be used to move files (and directories) between directories. If moving a file, you must fully specify the &lt;code&gt;destination&lt;/code&gt; filename, it is not sufficient to simply specify its directory.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 파일을 &lt;code&gt;destination&lt;/code&gt; 파일로 이름을 바꿉니다 . 디렉토리간에 파일 (및 디렉토리)을 이동하는 데 사용할 수 있습니다. 파일을 이동하는 경우 &lt;code&gt;destination&lt;/code&gt; 파일 이름을 완전히 지정해야 하며 단순히 디렉토리를 지정하는 것만으로는 충분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a91f5880024e32c1ee837d1bf3b64cc8dc6671b0" translate="yes" xml:space="preserve">
          <source>Replaced by (available since)</source>
          <target state="translated">로 대체 됨 (이후 사용 가능)</target>
        </trans-unit>
        <trans-unit id="3ae5fd3a5401d1295a4c3679a829706f16163c68" translate="yes" xml:space="preserve">
          <source>Replaces all leading occurrences of &lt;code&gt;match&lt;/code&gt; by &lt;code&gt;replacement&lt;/code&gt; of &lt;code&gt;match&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">의 모든 주요 발생 대체 &lt;code&gt;match&lt;/code&gt; 에 의해 &lt;code&gt;replacement&lt;/code&gt; 의 &lt;code&gt;match&lt;/code&gt; 에서 &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58f3e85bfde4f7a00e1a21674d997cd1b50094da" translate="yes" xml:space="preserve">
          <source>Replaces all trailing occurrences of &lt;code&gt;match&lt;/code&gt; by &lt;code&gt;replacement&lt;/code&gt; in &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">모든 후행 발생 대체 &lt;code&gt;match&lt;/code&gt; 에 의해 &lt;code&gt;replacement&lt;/code&gt; 에 &lt;code&gt;string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82d8aa6c1dd74b7f190708bea27805665c8cdf0e" translate="yes" xml:space="preserve">
          <source>Replaces prefix in &lt;code&gt;string&lt;/code&gt; by &lt;code&gt;replacement&lt;/code&gt; if it matches &lt;code&gt;match&lt;/code&gt;.</source>
          <target state="translated">바꿉니다은 접두사 &lt;code&gt;string&lt;/code&gt; 로 &lt;code&gt;replacement&lt;/code&gt; 일치하는 경우 &lt;code&gt;match&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c08818204c69c938d93f26169b6a54dc9d5f052e" translate="yes" xml:space="preserve">
          <source>Replaces suffix in &lt;code&gt;string&lt;/code&gt; by &lt;code&gt;replacement&lt;/code&gt; if it matches &lt;code&gt;match&lt;/code&gt;.</source>
          <target state="translated">대체합니다은에 접미사 &lt;code&gt;string&lt;/code&gt; 로 &lt;code&gt;replacement&lt;/code&gt; 일치하는 경우 &lt;code&gt;match&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61b72516eacbd25292524ef703f00e3b0cd63290" translate="yes" xml:space="preserve">
          <source>Replies to a client.</source>
          <target state="translated">클라이언트에게 응답합니다.</target>
        </trans-unit>
        <trans-unit id="167f6ac2dbfd0e8be970571e54087bdd8130f746" translate="yes" xml:space="preserve">
          <source>Represents expressions in the AST</source>
          <target state="translated">AST의 표현식을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9c6f57c3a5b6011834691a65157b80974d8047ca" translate="yes" xml:space="preserve">
          <source>Represents literals in the AST</source>
          <target state="translated">AST의 리터럴을 나타냅니다</target>
        </trans-unit>
        <trans-unit id="e9c366b4f3c3a1bf3449c6872aaeae5a0c5ecdf4" translate="yes" xml:space="preserve">
          <source>Requirement</source>
          <target state="translated">Requirement</target>
        </trans-unit>
        <trans-unit id="09a428f93ec07a73d726f8bd037ecacfaaf8b044" translate="yes" xml:space="preserve">
          <source>Requirements</source>
          <target state="translated">Requirements</target>
        </trans-unit>
        <trans-unit id="412cfb34df55659000dc3fda9977411aa50f05bf" translate="yes" xml:space="preserve">
          <source>Requirements allow you to specify which versions of a given dependency you are willing to work against. Requirements support the common comparison operators such as &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt; that work as one would expect, and additionally the special operator &lt;code&gt;~&amp;gt;&lt;/code&gt; described in detail further below.</source>
          <target state="translated">요구 사항을 사용하면 주어진 종속성의 버전을 지정할 수 있습니다. 요구 사항은 다음과 같은 일반적인 비교 연산자 지원 &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; 그 일 하나를 기대하고, 추가로 특별한 연산자로 &lt;code&gt;~&amp;gt;&lt;/code&gt; 이 더 상세하게 설명한다.</target>
        </trans-unit>
        <trans-unit id="ffbcbcafa9cd3ab8fe7f3e0221d371de707c59bf" translate="yes" xml:space="preserve">
          <source>Requirements also support &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; for complex conditions:</source>
          <target state="translated">요구 사항은 또한 지원 &lt;code&gt;and&lt;/code&gt; 및 &lt;code&gt;or&lt;/code&gt; 복잡한 조건 :</target>
        </trans-unit>
        <trans-unit id="0a37ffbe744b3419c856886db8581bb258bdd52c" translate="yes" xml:space="preserve">
          <source>Requires a module in order to use its macros.</source>
          <target state="translated">매크로를 사용하려면 모듈이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bdc77107aca48a34c1255f765ae312ea22e9d590" translate="yes" xml:space="preserve">
          <source>Requires only the &lt;code&gt;left&lt;/code&gt; operand to be a boolean since it short-circuits. If the &lt;code&gt;left&lt;/code&gt; operand is not a boolean, an &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">&lt;code&gt;left&lt;/code&gt; 피연산자 만 단락되므로 부울이어야합니다. 경우 &lt;code&gt;left&lt;/code&gt; 피연산자가 부울 아닌, &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3c1457fddb0ccb7c73dde9fb1360f8c49c8b2b74" translate="yes" xml:space="preserve">
          <source>Requires the given &lt;code&gt;file&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;file&lt;/code&gt; 필요 합니다 .</target>
        </trans-unit>
        <trans-unit id="1cda5e602ba0cf728e06b8efb2ddbc8599b5d662" translate="yes" xml:space="preserve">
          <source>Requires the given files in parallel.</source>
          <target state="translated">주어진 파일을 병렬로 요구합니다.</target>
        </trans-unit>
        <trans-unit id="652877b192a4527170621aec011fcd58f4d804ea" translate="yes" xml:space="preserve">
          <source>Reruns &lt;code&gt;task&lt;/code&gt; with the given arguments.</source>
          <target state="translated">재방송 &lt;code&gt;task&lt;/code&gt; 지정된 인수와.</target>
        </trans-unit>
        <trans-unit id="3303b4d51ecd1f3dd58871e5e01ec85056396381" translate="yes" xml:space="preserve">
          <source>Reserved module names</source>
          <target state="translated">예약 된 모듈 이름</target>
        </trans-unit>
        <trans-unit id="98d53aa320bfa9f3ee95a18c9df1aa09adb7fddb" translate="yes" xml:space="preserve">
          <source>Reserved words</source>
          <target state="translated">예약어</target>
        </trans-unit>
        <trans-unit id="97f4d7e17f03d2ddae5b33b0691e0061a8d5b3a6" translate="yes" xml:space="preserve">
          <source>Resets all attributes.</source>
          <target state="translated">모든 속성을 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="20e3b7449f8050f7eb4cdaf37779f0265636b2bb" translate="yes" xml:space="preserve">
          <source>Resets the current process metadata to the given keyword list.</source>
          <target state="translated">현재 프로세스 메타 데이터를 지정된 키워드 목록으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="49fdd1a2b23b0085e72c09b062efd4ecb9a18ed2" translate="yes" xml:space="preserve">
          <source>Resolves a &lt;a href=&quot;#t:config_path/0&quot;&gt;&lt;code&gt;config_path/0&lt;/code&gt;&lt;/a&gt; to an actual path.</source>
          <target state="translated">&lt;a href=&quot;#t:config_path/0&quot;&gt; &lt;code&gt;config_path/0&lt;/code&gt; &lt;/a&gt; 을 실제 경로 로 해석 합니다.</target>
        </trans-unit>
        <trans-unit id="838ebc4a5cadbe62e4f28a82bbc20144b2308c44" translate="yes" xml:space="preserve">
          <source>Respawns the current shell by starting a new shell process.</source>
          <target state="translated">새로운 쉘 프로세스를 시작하여 현재 쉘을 다시 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d924949f461a2178615fa560be4fcb1a11adc482" translate="yes" xml:space="preserve">
          <source>Restart values (:restart)</source>
          <target state="translated">재시작 값 (: restart)</target>
        </trans-unit>
        <trans-unit id="6c1b23092774f1732bb40fd9217d2008cf95142c" translate="yes" xml:space="preserve">
          <source>Restarts a child process identified by &lt;code&gt;child_id&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;child_id&lt;/code&gt; 로 식별되는 하위 프로세스를 다시 시작합니다 .</target>
        </trans-unit>
        <trans-unit id="cdda01d4f5a4d17bef26c81b5fb2b202c9529bae" translate="yes" xml:space="preserve">
          <source>Restarts all applications in the Erlang runtime system.</source>
          <target state="translated">Erlang 런타임 시스템에서 모든 애플리케이션을 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e9ef6fa952a1df9e86072dc44600b6f94a8e9045" translate="yes" xml:space="preserve">
          <source>Retrieves the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Logger&lt;/code&gt;&lt;/a&gt; level.</source>
          <target state="translated">&lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Logger&lt;/code&gt; &lt;/a&gt; 레벨을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="9561c4c2ab77e3b4a8a77091d61310e40fe75523" translate="yes" xml:space="preserve">
          <source>Retrieves the current project if there is one.</source>
          <target state="translated">현재 프로젝트가있는 경우 검색합니다.</target>
        </trans-unit>
        <trans-unit id="8108bc75c4a7082e6ac6f1000b099b62cbb5c8b6" translate="yes" xml:space="preserve">
          <source>Retrieves the number of elements in the &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 요소의 수를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="bd62dedad93356267e6352b4bd2959e6c3d4a64b" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;{:ok, contents, warnings}&lt;/code&gt; or &lt;code&gt;{:error, errors, warnings}&lt;/code&gt; (v1.6)</source>
          <target state="translated">&lt;code&gt;{:ok, contents, warnings}&lt;/code&gt; 또는 &lt;code&gt;{:error, errors, warnings}&lt;/code&gt; (v1.6) 반환</target>
        </trans-unit>
        <trans-unit id="9d42e2f739c476b4724ed40443cd1bdc8b0b0c31" translate="yes" xml:space="preserve">
          <source>Return values</source>
          <target state="translated">반환 값</target>
        </trans-unit>
        <trans-unit id="1b92b78b25ceec1de641e02266e51c2ee955125b" translate="yes" xml:space="preserve">
          <source>Return values are the same as &lt;a href=&quot;#c:handle_cast/2&quot;&gt;&lt;code&gt;handle_cast/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 값은 &lt;a href=&quot;#c:handle_cast/2&quot;&gt; &lt;code&gt;handle_cast/2&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="6510848f34f0555d205bfb994f51d205f3d74823" translate="yes" xml:space="preserve">
          <source>Return values of &lt;code&gt;start*&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;start*&lt;/code&gt; 함수 의 반환 값</target>
        </trans-unit>
        <trans-unit id="9450659c5d952be2b0fe455eb08ad207bd303023" translate="yes" xml:space="preserve">
          <source>Return values of &lt;code&gt;start_child&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;start_child&lt;/code&gt; 함수 의 반환 값</target>
        </trans-unit>
        <trans-unit id="3e9dd619fd23cd606de770ea4c2cbd74b2aa99e4" translate="yes" xml:space="preserve">
          <source>Return values of &lt;code&gt;start_link&lt;/code&gt; functions</source>
          <target state="translated">&lt;code&gt;start_link&lt;/code&gt; 함수 의 반환 값</target>
        </trans-unit>
        <trans-unit id="71ad9db2f452d030849e70969695a7639a712f39" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;:ignore&lt;/code&gt; will cause &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;:ignore&lt;/code&gt; and the process will exit normally without entering the loop or calling &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;. If used when part of a supervision tree the parent supervisor will not fail to start nor immediately try to restart the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt;. The remainder of the supervision tree will be started and so the &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; should not be required by other processes. It can be started later with &lt;a href=&quot;supervisor#restart_child/2&quot;&gt;&lt;code&gt;Supervisor.restart_child/2&lt;/code&gt;&lt;/a&gt; as the child specification is saved in the parent supervisor. The main use cases for this are:</source>
          <target state="translated">반환 &lt;code&gt;:ignore&lt;/code&gt; 하게됩니다 &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 반환 &lt;code&gt;:ignore&lt;/code&gt; 하고 프로세스가 루프를 입력하거나 호출하지 않고 정상적으로 종료됩니다 &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; . 감독 트리의 일부로 사용될 때 상위 감독자가 시작하지 못하거나 즉시 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 를 다시 시작하려고 시도하지 않습니다 . 나머지 감시 트리가 시작되므로 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; &lt;/a&gt; 가 다른 프로세스에 필요하지 않습니다. 하위 스펙이 상위 감독자에 저장되므로 나중에 &lt;a href=&quot;supervisor#restart_child/2&quot;&gt; &lt;code&gt;Supervisor.restart_child/2&lt;/code&gt; &lt;/a&gt; 로 시작할 수 있습니다 . 이에 대한 주요 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb2f30a4d8bc7038c64e5d45423d1462692bb22a" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;:ok&lt;/code&gt; leaves the context unchanged (in &lt;code&gt;setup&lt;/code&gt; and &lt;code&gt;setup_all&lt;/code&gt; callbacks).</source>
          <target state="translated">&lt;code&gt;:ok&lt;/code&gt; 를 반환 하면 컨텍스트가 변경되지 않은 상태로 유지됩니다 ( &lt;code&gt;setup&lt;/code&gt; 및 &lt;code&gt;setup_all&lt;/code&gt; 콜백에서).</target>
        </trans-unit>
        <trans-unit id="d4f04b1fc86d756470bf59ce20599e81fba3d31e" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:error, reason}&lt;/code&gt; fails the code change with reason &lt;code&gt;reason&lt;/code&gt; and the state remains as the previous state.</source>
          <target state="translated">&lt;code&gt;{:error, reason}&lt;/code&gt; 리턴 하면 reason &lt;code&gt;reason&lt;/code&gt; 으로 코드 변경에 실패 하고 상태는 이전 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0592eb111cc826c0b5dc41fef3d96850ddf2ed2a" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state, :hibernate}&lt;/code&gt; is similar to &lt;code&gt;{:noreply, new_state}&lt;/code&gt; except the process is hibernated before continuing the loop. See &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;{:noreply, new_state, :hibernate}&lt;/code&gt; 반환 하는 것은 루프를 계속하기 전에 프로세스가 최대 절전 모드 인 것을 제외하고는 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; 와 비슷합니다 . 자세한 내용은 &lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="545abab29816f45f903fc69a76d6d258e74019ea" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state, timeout | :hibernate | {:continue, continue}}&lt;/code&gt; is similar to &lt;code&gt;{:noreply, new_state}&lt;/code&gt; except a timeout, hibernation or continue occurs as with a &lt;code&gt;:reply&lt;/code&gt; tuple.</source>
          <target state="translated">반환 &lt;code&gt;{:noreply, new_state, timeout | :hibernate | {:continue, continue}}&lt;/code&gt; 는 타임 아웃, 최대 절전 모드 또는 계속이 &lt;code&gt;:reply&lt;/code&gt; 튜플에서 발생한다는 점을 제외하고 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="0d632613338eb1516d1e171379de56d181565aa7" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state, timeout}&lt;/code&gt; is similar to &lt;code&gt;{:noreply, new_state}&lt;/code&gt; except that it also sets a timeout. See the &quot;Timeouts&quot; section in the module documentation for more information.</source>
          <target state="translated">&lt;code&gt;{:noreply, new_state, timeout}&lt;/code&gt; 반환 하는 것은 시간 제한을 설정한다는 점을 제외하고 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; 와 비슷합니다 . 자세한 내용은 모듈 설명서의 &quot;시간 초과&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b0dc3e574638c9f3a3a2cb97268326892e9c0517" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state, {:continue, continue}}&lt;/code&gt; is similar to &lt;code&gt;{:noreply, new_state}&lt;/code&gt; except &lt;a href=&quot;#c:handle_continue/2&quot;&gt;&lt;code&gt;handle_continue/2&lt;/code&gt;&lt;/a&gt; will be invoked immediately after with the value &lt;code&gt;continue&lt;/code&gt; as first argument.</source>
          <target state="translated">반환하는 &lt;code&gt;{:noreply, new_state, {:continue, continue}}&lt;/code&gt; 과 유사합니다 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; 제외하고 &lt;a href=&quot;#c:handle_continue/2&quot;&gt; &lt;code&gt;handle_continue/2&lt;/code&gt; &lt;/a&gt; 값으로 직후 호출됩니다 &lt;code&gt;continue&lt;/code&gt; 첫 번째 인수로.</target>
        </trans-unit>
        <trans-unit id="7c2e4427bf9da87b7975511fa77c0aa083a93e56" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state}&lt;/code&gt; continues the loop with new state &lt;code&gt;new_state&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;{:noreply, new_state}&lt;/code&gt; 새로운 상태로 루프 계속 &lt;code&gt;new_state&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0bcdf8d79ea91a9b75d45685f07008e6bb07b7a" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:noreply, new_state}&lt;/code&gt; does not send a response to the caller and continues the loop with new state &lt;code&gt;new_state&lt;/code&gt;. The response must be sent with &lt;a href=&quot;#reply/2&quot;&gt;&lt;code&gt;reply/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;{:noreply, new_state}&lt;/code&gt; 반환 하면 호출자에게 응답을 보내지 않고 &lt;code&gt;new_state&lt;/code&gt; 상태로 루프를 계속합니다 . 응답은 &lt;a href=&quot;#reply/2&quot;&gt; &lt;code&gt;reply/2&lt;/code&gt; &lt;/a&gt; 와 함께 보내야합니다 .</target>
        </trans-unit>
        <trans-unit id="4de3a02b60233fe036c0a08aa97987f8e91d073a" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, contents}&lt;/code&gt; or &lt;code&gt;:error&lt;/code&gt; from &lt;a href=&quot;https://hexdocs.pm/mix/Mix.Compilers.Erlang.html#compile/6&quot;&gt;&lt;code&gt;Mix.Compilers.Erlang.compile/6&lt;/code&gt;&lt;/a&gt;'s callback</source>
          <target state="translated">&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Compilers.Erlang.html#compile/6&quot;&gt; &lt;code&gt;Mix.Compilers.Erlang.compile/6&lt;/code&gt; &lt;/a&gt; 의 콜백 에서 &lt;code&gt;{:ok, contents}&lt;/code&gt; 또는 &lt;code&gt;:error&lt;/code&gt; 반환</target>
        </trans-unit>
        <trans-unit id="4ce39defe2e667a1d9303cd7807fa9deb1f3dff7" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, new_state}&lt;/code&gt; changes the state to &lt;code&gt;new_state&lt;/code&gt; and the code change is successful.</source>
          <target state="translated">&lt;code&gt;{:ok, new_state}&lt;/code&gt; 반환 하면 상태가 &lt;code&gt;new_state&lt;/code&gt; 로 변경되고 코드 변경에 성공합니다.</target>
        </trans-unit>
        <trans-unit id="dda86c57299291383ba12cacce3b8a61cd3aca15" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state, :hibernate}&lt;/code&gt; is similar to &lt;code&gt;{:ok, state}&lt;/code&gt; except the process is hibernated before entering the loop. See &lt;a href=&quot;#c:handle_call/3&quot;&gt;&lt;code&gt;handle_call/3&lt;/code&gt;&lt;/a&gt; for more information on hibernation.</source>
          <target state="translated">&lt;code&gt;{:ok, state, :hibernate}&lt;/code&gt; 반환 하는 것은 루프에 들어가기 전에 프로세스가 최대 절전 모드 인 것을 제외하고는 &lt;code&gt;{:ok, state}&lt;/code&gt; 와 비슷합니다 . 최대 절전 모드에 대한 자세한 내용 은 &lt;a href=&quot;#c:handle_call/3&quot;&gt; &lt;code&gt;handle_call/3&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f4f89c1f4a5e07f563900cfccc5421ff9a8161b2" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state, timeout}&lt;/code&gt; is similar to &lt;code&gt;{:ok, state}&lt;/code&gt;, except that it also sets a timeout. See the &quot;Timeouts&quot; section in the module documentation for more information.</source>
          <target state="translated">반환 &lt;code&gt;{:ok, state, timeout}&lt;/code&gt; 과 유사하다 &lt;code&gt;{:ok, state}&lt;/code&gt; , 또한 시간 제한을 설정하는 것을 제외하고. 자세한 내용은 모듈 설명서의 &quot;시간 초과&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="367f39392e443be5033fcc0ce46cb9c7191866d5" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state, {:continue, continue}}&lt;/code&gt; is similar to &lt;code&gt;{:ok, state}&lt;/code&gt; except that immediately after entering the loop the &lt;a href=&quot;#c:handle_continue/2&quot;&gt;&lt;code&gt;handle_continue/2&lt;/code&gt;&lt;/a&gt; callback will be invoked with the value &lt;code&gt;continue&lt;/code&gt; as first argument.</source>
          <target state="translated">&lt;code&gt;{:ok, state, {:continue, continue}}&lt;/code&gt; 반환하는 것은 {: ok, state} 와 비슷합니다 &lt;code&gt;{:ok, state}&lt;/code&gt; 루프에 들어가 자마자 &lt;a href=&quot;#c:handle_continue/2&quot;&gt; &lt;code&gt;handle_continue/2&lt;/code&gt; &lt;/a&gt; 콜백이 호출되고 값 이 first argument로 &lt;code&gt;continue&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="4e7d4ebacb2fe086ff03c74440ab13b1423c917e" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:ok, state}&lt;/code&gt; will cause &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;{:ok, pid}&lt;/code&gt; and the process to enter its loop.</source>
          <target state="translated">반환 &lt;code&gt;{:ok, state}&lt;/code&gt; 의 원인이됩니다 &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 돌아 &lt;code&gt;{:ok, pid}&lt;/code&gt; 과 그 루프를 입력하는 과정.</target>
        </trans-unit>
        <trans-unit id="2ac7990d3774239b03711f323b97327318be9091" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:reply, reply, new_state, :hibernate}&lt;/code&gt; is similar to &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; except the process is hibernated and will continue the loop once a message is in its message queue. If a message is already in the message queue this will be immediately. Hibernating a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;GenServer&lt;/code&gt;&lt;/a&gt; causes garbage collection and leaves a continuous heap that minimises the memory used by the process.</source>
          <target state="translated">&lt;code&gt;{:reply, reply, new_state, :hibernate}&lt;/code&gt; 반환 하는 것은 프로세스가 최대 절전 모드이고 메시지가 메시지 큐에 있으면 루프를 계속한다는 점을 제외하고 &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; 와 비슷합니다 . 메시지가 이미 메시지 큐에있는 경우 즉시 처리됩니다. &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;GenServer&lt;/code&gt; 를&lt;/a&gt; 최대 절전 모드로 설정 하면 가비지 수집이 발생하고 프로세스에서 사용되는 메모리를 최소화하는 연속 힙이 남습니다.</target>
        </trans-unit>
        <trans-unit id="3664827e00957d1361f076b6c6180a5288429b1e" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:reply, reply, new_state, timeout}&lt;/code&gt; is similar to &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; except that it also sets a timeout. See the &quot;Timeouts&quot; section in the module documentation for more information.</source>
          <target state="translated">&lt;code&gt;{:reply, reply, new_state, timeout}&lt;/code&gt; 반환 하는 것은 타임 아웃을 설정한다는 점을 제외하고는 &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; 와 비슷합니다 . 자세한 내용은 모듈 설명서의 &quot;시간 초과&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6f9c42293c17275b2da3909a5ac827406da8908f" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:reply, reply, new_state, {:continue, continue}}&lt;/code&gt; is similar to &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; except &lt;a href=&quot;#c:handle_continue/2&quot;&gt;&lt;code&gt;handle_continue/2&lt;/code&gt;&lt;/a&gt; will be invoked immediately after with the value &lt;code&gt;continue&lt;/code&gt; as first argument.</source>
          <target state="translated">반환 &lt;code&gt;{:reply, reply, new_state, {:continue, continue}}&lt;/code&gt; 과 유사합니다 &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; 제외하고 &lt;a href=&quot;#c:handle_continue/2&quot;&gt; &lt;code&gt;handle_continue/2&lt;/code&gt; &lt;/a&gt; 값으로 직후 호출됩니다 &lt;code&gt;continue&lt;/code&gt; 첫 번째 인수로.</target>
        </trans-unit>
        <trans-unit id="5d5e6464f7527865bd6d8be289ffe2a3685bee24" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; sends the response &lt;code&gt;reply&lt;/code&gt; to the caller and continues the loop with new state &lt;code&gt;new_state&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:reply, reply, new_state}&lt;/code&gt; 반환 하면 응답 &lt;code&gt;reply&lt;/code&gt; 을 호출자 에게 보내고 &lt;code&gt;new_state&lt;/code&gt; 상태로 루프를 계속합니다 .</target>
        </trans-unit>
        <trans-unit id="534c77debf0badc9c25487b18a7948694707f4bb" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:stop, reason, new_state}&lt;/code&gt; is similar to &lt;code&gt;{:stop, reason, reply, new_state}&lt;/code&gt; except a reply is not sent.</source>
          <target state="translated">&lt;code&gt;{:stop, reason, new_state}&lt;/code&gt; 반환 하는 것은 회신을 보내지 않는다는 점을 제외하고 &lt;code&gt;{:stop, reason, reply, new_state}&lt;/code&gt; 와 비슷합니다 .</target>
        </trans-unit>
        <trans-unit id="25233abf67489667f36f12119719f8bf3ab79f10" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:stop, reason, new_state}&lt;/code&gt; stops the loop and &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt; is called with the reason &lt;code&gt;reason&lt;/code&gt; and state &lt;code&gt;new_state&lt;/code&gt;. The process exits with reason &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;{:stop, reason, new_state}&lt;/code&gt; 루프를 중지하고 &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; 이유 불려 &lt;code&gt;reason&lt;/code&gt; 와 상태 &lt;code&gt;new_state&lt;/code&gt; . 이유 &lt;code&gt;reason&lt;/code&gt; 으로 프로세스가 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="9446727789d28494af33768c5dd1be490cb2c928" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:stop, reason, reply, new_state}&lt;/code&gt; stops the loop and &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt; is called with reason &lt;code&gt;reason&lt;/code&gt; and state &lt;code&gt;new_state&lt;/code&gt;. Then the &lt;code&gt;reply&lt;/code&gt; is sent as the response to call and the process exits with reason &lt;code&gt;reason&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;{:stop, reason, reply, new_state}&lt;/code&gt; 반환 하면 루프가 중지 되고 reason &lt;code&gt;reason&lt;/code&gt; 및 state &lt;code&gt;new_state&lt;/code&gt; 와 함께 &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; 가 호출됩니다 . 그런 다음 &lt;code&gt;reply&lt;/code&gt; 전화 응답 및 이유와 프로세스가 종료로 전송됩니다 &lt;code&gt;reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45b0ba5a4f231122f32567afd5046aeac5ca341b" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;{:stop, reason}&lt;/code&gt; will cause &lt;a href=&quot;#start_link/3&quot;&gt;&lt;code&gt;start_link/3&lt;/code&gt;&lt;/a&gt; to return &lt;code&gt;{:error, reason}&lt;/code&gt; and the process to exit with reason &lt;code&gt;reason&lt;/code&gt; without entering the loop or calling &lt;a href=&quot;#c:terminate/2&quot;&gt;&lt;code&gt;terminate/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 &lt;code&gt;{:stop, reason}&lt;/code&gt; 의 원인이됩니다 &lt;a href=&quot;#start_link/3&quot;&gt; &lt;code&gt;start_link/3&lt;/code&gt; &lt;/a&gt; 반환은 &lt;code&gt;{:error, reason}&lt;/code&gt; 및 이유와 출구 과정 &lt;code&gt;reason&lt;/code&gt; 루프를 입력하거나 전화없이 &lt;a href=&quot;#c:terminate/2&quot;&gt; &lt;code&gt;terminate/2&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="201a82018e6ccab06f099ffcf6ad93f0589f0ac6" translate="yes" xml:space="preserve">
          <source>Returning anything else from &lt;code&gt;setup_all&lt;/code&gt; will force all tests to fail, while a bad response from &lt;code&gt;setup&lt;/code&gt; causes the current test to fail.</source>
          <target state="translated">&lt;code&gt;setup_all&lt;/code&gt; 에서 다른 항목을 반환 하면 모든 테스트가 실패하고 &lt;code&gt;setup&lt;/code&gt; 에서 잘못된 응답으로 인해 현재 테스트가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="2ccc041e90cdcfa1031811c96f150b22c6b8ca9e" translate="yes" xml:space="preserve">
          <source>Returning to our &lt;code&gt;handle_cast/2&lt;/code&gt; implementation, you can see the registry is both linking and monitoring the buckets:</source>
          <target state="translated">&lt;code&gt;handle_cast/2&lt;/code&gt; 구현 으로 돌아가서 레지스트리가 버킷을 연결하고 모니터링하는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a86c48f96d918e08b84d079d9945718a4599bc5f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:error&lt;/code&gt; when an invalid call syntax is provided.</source>
          <target state="translated">잘못된 호출 구문이 제공되면 &lt;code&gt;:error&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9ab2b4bc1a0b6cdb37b00adb4f725958544c088b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if first date is later than the second and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two dates are equal &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">반환 &lt;code&gt;:gt&lt;/code&gt; 제 날짜 이후 제 및보다 경우 &lt;code&gt;:lt&lt;/code&gt; 반대 담당 대한. 두 날짜가 같으면 &lt;code&gt;:eq&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="097e4060b0440fe77549d8b66e79f7bb6eb97a62" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if first is later than the second and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two NaiveDateTime are equal &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">first가 두 번째보다 늦으면 &lt;code&gt;:gt&lt;/code&gt; 를 반환 하고 그 반대의 경우 &lt;code&gt;:lt&lt;/code&gt; 를 반환 합니다. 두 NaiveDateTime이 같으면 &lt;code&gt;:eq&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bd2d674dc710366cef94fba09471c28e71a138f9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if first time is later than the second and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two times are equal &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">첫 번째 시간이 두 번째 시간보다 늦은 경우 &lt;code&gt;:gt&lt;/code&gt; 를 반환 하고 그 반대의 경우 &lt;code&gt;:lt&lt;/code&gt; 를 반환 합니다. 두 번 같으면 &lt;code&gt;:eq&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="53c408a9bef219a6da93ad2df4fe55724f2cb32d" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if the first datetime is later than the second and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two datetimes are equal &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">첫 번째 날짜 시간이 두 번째 날짜 시간보다 늦은 경우 &lt;code&gt;:gt&lt;/code&gt; 를 반환 하고 그 반대의 경우 &lt;code&gt;:lt&lt;/code&gt; 를 반환 합니다. 두 날짜 시간이 같으면 &lt;code&gt;:eq&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e433c31c34feefdf2a0b8160341592f2285d40c9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:gt&lt;/code&gt; if the first version is greater than the second one, and &lt;code&gt;:lt&lt;/code&gt; for vice versa. If the two versions are equal, &lt;code&gt;:eq&lt;/code&gt; is returned.</source>
          <target state="translated">첫 번째 버전이 두 번째 버전보다 큰 경우 &lt;code&gt;:gt&lt;/code&gt; 를 반환 하고 그 반대의 경우 &lt;code&gt;:lt&lt;/code&gt; 를 반환 합니다. 두 버전이 같으면 &lt;code&gt;:eq&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="49f62de8f752ac017916b11e0d5b0e6dfb4ee428" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if so, otherwise raises &lt;a href=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그렇다면 &lt;code&gt;:ok&lt;/code&gt; 를 반환 하고, 그렇지 않으면 &lt;a href=&quot;argumenterror&quot;&gt; &lt;code&gt;ArgumentError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="4c527276d77f46398aba41c7763a178e857f1629" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">성공하면 &lt;code&gt;:ok&lt;/code&gt; &lt;code&gt;{:error, reason}&lt;/code&gt; 그렇지 않으면 {: error, reason}을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="84d6f7930e56db40dca6afbc716ff10cc17e68c7" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise. If the operating system does not support hard links, returns &lt;code&gt;{:error, :enotsup}&lt;/code&gt;.</source>
          <target state="translated">성공하면 &lt;code&gt;:ok&lt;/code&gt; &lt;code&gt;{:error, reason}&lt;/code&gt; 그렇지 않으면 {: error, reason}을 리턴 합니다. 운영 체제가 하드 링크를 지원하지 않으면 &lt;code&gt;{:error, :enotsup}&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="8a9014518965fa93cf5189e6ffe93f29bdec10a9" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise. If the operating system does not support symlinks, returns &lt;code&gt;{:error, :enotsup}&lt;/code&gt;.</source>
          <target state="translated">성공하면 &lt;code&gt;:ok&lt;/code&gt; &lt;code&gt;{:error, reason}&lt;/code&gt; 그렇지 않으면 {: error, reason}을 리턴 합니다. 운영 체제가 심볼릭 링크를 지원하지 않으면 &lt;code&gt;{:error, :enotsup}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b4bfe0e95851ad3e1857f64f97c1d1fb4f5d47b8" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">성공하면 &lt;code&gt;:ok&lt;/code&gt; , 오류가 발생하면 &lt;code&gt;{:error, reason}&lt;/code&gt; 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="8084f7f8c4483c73958f54a0f48dadd5344d6c20" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs. It returns &lt;code&gt;{:error, :eexist}&lt;/code&gt; if the directory is not empty.</source>
          <target state="translated">성공하면 &lt;code&gt;:ok&lt;/code&gt; , 오류가 발생하면 &lt;code&gt;{:error, reason}&lt;/code&gt; 리턴 합니다. 디렉토리가 비어 있지 않으면 &lt;code&gt;{:error, :eexist}&lt;/code&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ab0c374d46ad2b15399e120024adf6936c21f68c" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; if there is such breakpoint ID. &lt;code&gt;:not_found&lt;/code&gt; otherwise.</source>
          <target state="translated">중단 점 ID가 있으면 &lt;code&gt;:ok&lt;/code&gt; 를 리턴합니다 . 그렇지 않으면 &lt;code&gt;:not_found&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e6eac431d9ebe34612817b0b267721c1695b386" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;:ok&lt;/code&gt; 에 성공하는 경우, &lt;code&gt;{:error, reason}&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="fccad904de868f3ee196d9c9da31a4d3a418edcf" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; on success, or &lt;code&gt;{:error, reason}&lt;/code&gt; on failure.</source>
          <target state="translated">성공시 &lt;code&gt;:ok&lt;/code&gt; 또는 실패시 &lt;code&gt;{:error, reason}&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="4edb5e74e876c5531ce730345abbd7fb3d428f67" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt; or an &lt;code&gt;{:error, reason}&lt;/code&gt; tuple.</source>
          <target state="translated">&lt;code&gt;:ok&lt;/code&gt; 또는 &lt;code&gt;{:error, reason}&lt;/code&gt; 튜플을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="2811dc2871409b74c7634f3fe21b9cfad8e3426d" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:ok&lt;/code&gt;.</source>
          <target state="translated">반환 값 &lt;code&gt;:ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70a0cb56fb988edcefd7f57e57c953aed4c9f29d" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;:pang&lt;/code&gt; if it fails, or &lt;code&gt;:pong&lt;/code&gt; if it is successful.</source>
          <target state="translated">실패하면 &lt;code&gt;:pang&lt;/code&gt; 을 , 성공하면 &lt;code&gt;:pong&lt;/code&gt; 을 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="fa4c892f8a51f6377453163a59366a24b8673154" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;default&lt;/code&gt; if &lt;code&gt;index&lt;/code&gt; is out of bounds.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 가 범위를 벗어난 경우 &lt;code&gt;default&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="d21a89523dd182a1ba29c1ffb24f85507a56dc6f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;nil&lt;/code&gt; if none of the above are writable.</source>
          <target state="translated">위의 어느 것도 쓸 수없는 경우 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="898fb5eb3ba6e23f0ccd7d7539ee54b65de26942" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;string&lt;/code&gt; escaped using the specified &lt;code&gt;color&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;color&lt;/code&gt; 사용하여 이스케이프 된 &lt;code&gt;string&lt;/code&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="4ac9182b080017ba693939798ee4b3253313dff7" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;config&lt;/code&gt; is the configuration for an umbrella project.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;config&lt;/code&gt; 우산 프로젝트의 구성입니다.</target>
        </trans-unit>
        <trans-unit id="9962d949955102edf7d4c95bfcf26efb4913fef8" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;enumerable&lt;/code&gt; is empty, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 이 비어 있으면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="c5674c2a52dea0e62c8659c4dd8c99131becc466" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;fun.(element)&lt;/code&gt; is truthy for all elements in &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;fun.(element)&lt;/code&gt; 의 모든 요소에 대한 truthy입니다 &lt;code&gt;enumerable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f74f38a142de62e72e50fbadcb7c75b8d2b80e17" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;fun.(element)&lt;/code&gt; is truthy for at least one element in &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fun.(element)&lt;/code&gt; 가 &lt;code&gt;enumerable&lt;/code&gt; 최소 하나 이상의 요소에 대해 &lt;code&gt;true&lt;/code&gt; 경우 true를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="514fe375f6bf375eaadfe6b59fe1fa8665022d7f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;left&lt;/code&gt; matches &lt;code&gt;right&lt;/code&gt; (if it's a regular expression) or contains &lt;code&gt;right&lt;/code&gt; (if it's a string).</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;left&lt;/code&gt; 일치 &lt;code&gt;right&lt;/code&gt; (는 정규 표현식의 경우) 또는 포함 &lt;code&gt;right&lt;/code&gt; (이 문자열 인 경우).</target>
        </trans-unit>
        <trans-unit id="ea241259b8bf2bfa681b13e041e456b2a872afb0" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;list&lt;/code&gt; is an improper list. Otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;list&lt;/code&gt; 부적절한 목록입니다. 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="13bb0ccf3c3642db1839be80f4503b7d3328419c" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;list&lt;/code&gt; starts with the given &lt;code&gt;prefix&lt;/code&gt; list; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;list&lt;/code&gt; 주어진로 시작 &lt;code&gt;prefix&lt;/code&gt; 목록; 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="30b6f388eb9b873621632a9225533fab3fd32015" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;module&lt;/code&gt; is loaded and contains a public &lt;code&gt;function&lt;/code&gt; with the given &lt;code&gt;arity&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 이로드되었고 주어진 &lt;code&gt;arity&lt;/code&gt; 를 가진 public &lt;code&gt;function&lt;/code&gt; 가 포함되어 있으면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="a1ff647bff772fb3c27239fe80409991ad029c38" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;module&lt;/code&gt; is loaded and contains a public &lt;code&gt;macro&lt;/code&gt; with the given &lt;code&gt;arity&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;module&lt;/code&gt; 로드 및 공공이 포함되어 있습니다 &lt;code&gt;macro&lt;/code&gt; 주어진와 &lt;code&gt;arity&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98b09495aa1c8dc345b23e7149ef0c6a164db4ae" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;string1&lt;/code&gt; is canonically equivalent to 'string2'.</source>
          <target state="translated">&lt;code&gt;string1&lt;/code&gt; 이 'string2'와 정식으로 동일한 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="315cea72c5e0f6161a3b846c3752c56b24a3948c" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;string&lt;/code&gt; ends with any of the suffixes given.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 이 주어진 접미사로 끝나는 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="c5875290ab59e60512fe2c79091c539fa829d55d" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;string&lt;/code&gt; starts with any of the prefixes given.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 이 지정된 접두사로 시작 하면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="b90e50f671b05dc996377d3785c4a6e0e543d9ff" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;term&lt;/code&gt; 입니다 &lt;code&gt;nil&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="5e0cec38e965cb1a7be0a1586c0c1e423e655e66" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a PID (process identifier); otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;term&lt;/code&gt; PID를 (프로세스 ID)입니다; 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bc1ef9358f093fef465082c08cb4e7223756760e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a binary; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;term&lt;/code&gt; 바이너리이며, 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0cb68195b8efb7757981bf81f0fe6586be5d3de1" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a bitstring (including a binary); otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 이 비트 열 (2 진 포함) 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="79b3d661830095f41c2c68053ed17e9b52d8a01f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a floating-point number; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;term&lt;/code&gt; 부동 소수점 숫자입니다; 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2dfdb69c5aae41737cbd815e59c8f1871298087f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a function that can be applied with &lt;code&gt;arity&lt;/code&gt; number of arguments; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 이 &lt;code&gt;arity&lt;/code&gt; 개수의 인수 로 적용될 수있는 함수 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6e89f73bf316fbcc1d6d52abc07e4cb1ed326b1b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a function; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 이 함수 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="dc10af9077eb74d82ee86a391efb59e0cd84b7b0" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a keyword list; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 가 키워드 목록 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4e151da898f287d233b2078fa6ce5e9be52488e5" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a list with zero or more elements; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 가 0 개 이상의 요소가있는 목록 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="67b05b7c88321c7891dc98e1ad13a9b71be8ac91" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a map; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;term&lt;/code&gt; 지도입니다 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ead0e61ee4b2af85c87450fd0aad9af3d5e78d5a" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a port identifier; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 이 포트 식별자 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7cc5a8e3d83346b723a1e98b79b03336e58e5997" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a reference; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 가 참조 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="836dab30db9cebf9ce31984fd2d439fc70e98fae" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is a tuple; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 이 터플 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cd9eb92704a0ae5f8e88de02a6cf887bf2e96aca" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is an atom; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 원자 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2b8986c4215419978baefd80231f45b3beba66ef" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is an integer; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;term&lt;/code&gt; 정수이고; 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="14d9412f32700bc4cbbf29f37ca9bcb0a10c90d8" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is either an integer or a floating-point number; otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;term&lt;/code&gt; 하나의 정수 또는 부동 소수점 숫자입니다; 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7a9f98e326f05651d287e6878b38e46a8be222b2" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;term&lt;/code&gt; is either the atom &lt;code&gt;true&lt;/code&gt; or the atom &lt;code&gt;false&lt;/code&gt; (i.e., a boolean); otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; 이 atom &lt;code&gt;true&lt;/code&gt; 또는 atom &lt;code&gt;false&lt;/code&gt; 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 (예 : 부울). 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3f92792e4651577bb721731f8ac15665ae74573f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;tuple&lt;/code&gt; in &lt;code&gt;module&lt;/code&gt; is marked as overridable.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;tuple&lt;/code&gt; 의 &lt;code&gt;module&lt;/code&gt; 재정의로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3c6d2a9d4ac17e816f44f5c8d82e7d9189bc17b0" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;version&lt;/code&gt; satisfies &lt;code&gt;requirement&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; otherwise. Raises a &lt;a href=&quot;version.invalidrequirementerror&quot;&gt;&lt;code&gt;Version.InvalidRequirementError&lt;/code&gt;&lt;/a&gt; exception if &lt;code&gt;requirement&lt;/code&gt; is not parsable, or a &lt;a href=&quot;version.invalidversionerror&quot;&gt;&lt;code&gt;Version.InvalidVersionError&lt;/code&gt;&lt;/a&gt; exception if &lt;code&gt;version&lt;/code&gt; is not parsable. If given an already parsed version and requirement this function won't raise.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 경우 &lt;code&gt;version&lt;/code&gt; 만족 &lt;code&gt;requirement&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; 그렇지. 발생시킵니다 &lt;a href=&quot;version.invalidrequirementerror&quot;&gt; &lt;code&gt;Version.InvalidRequirementError&lt;/code&gt; 의&lt;/a&gt; 경우 예외 &lt;code&gt;requirement&lt;/code&gt; 분석 할 수없는, 또는 &lt;a href=&quot;version.invalidversionerror&quot;&gt; &lt;code&gt;Version.InvalidVersionError&lt;/code&gt; 의&lt;/a&gt; 경우 예외 &lt;code&gt;version&lt;/code&gt; 구문 분석하지 않습니다. 이미 파싱 된 버전과 요구 사항이 주어지면이 함수는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b102633aa65f0f78fd85e893465d9febbf820c32" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if IEx was started, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; IEX가 시작되었을 경우 &lt;code&gt;false&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="e78d65a702a5304adca7eb9dab5e18bc6ac1ece7" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if Mix is in debug mode, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 믹스, 디버그 모드에있는 경우 &lt;code&gt;false&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="db763b2e2e218025c9bf3894db52d7ba51dfc882" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if given module is a task.</source>
          <target state="translated">주어진 모듈이 작업 인 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="9105393990e5f4b49e81200562038a9b37a0983b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if left is less than or equal to right.</source>
          <target state="translated">left가 right보다 작거나 같으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="10d817cde0ccac57c3abe0e906618887d09b990f" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if left is less than right.</source>
          <target state="translated">left가 오른쪽보다 작 으면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="4e3751787d81fb8270fa300c2ad1abeed3087881" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if left is more than or equal to right.</source>
          <target state="translated">left가 right 이상인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="6d3a72a03b6c80be9f6c0fd73128ebce147e5ab7" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if left is more than right.</source>
          <target state="translated">left가 오른쪽보다 크면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="0ae8d1d3d77e5618d9d9149276c9cd506b6a50c2" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; if not, and the atom &lt;code&gt;:ignored&lt;/code&gt; if the local node is not alive.</source>
          <target state="translated">성공하면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 , 로컬 노드가 활성 상태가 아니면 atom &lt;code&gt;:ignored&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="5569a7432c35dfe52f433263028783085945fdba" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;integer&lt;/code&gt; is an even number, otherwise it returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 주어진 경우 &lt;code&gt;integer&lt;/code&gt; 그렇지 않으면 반환, 짝수 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96e3993e05bf18f75065b0a674e4abf8709186ea" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;integer&lt;/code&gt; is an odd number, otherwise it returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 주어진 경우 &lt;code&gt;integer&lt;/code&gt; 홀수 그렇지 않으면 반환 &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73e3c10f82f542446d2c7d01a47b7b0bfb6361e2" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;term&lt;/code&gt; is a regex. Otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;term&lt;/code&gt; 가 정규 표현식 &lt;code&gt;true&lt;/code&gt; 반환 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a75c9e8f261e40e0328fdfc1d1e450ebf79d0480" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given &lt;code&gt;term&lt;/code&gt; is an exception.</source>
          <target state="translated">주어진 &lt;code&gt;term&lt;/code&gt; 가 예외 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="5cd92930de87a97665516f3e7c0ed77c0241d737" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given name and arity is a special form.</source>
          <target state="translated">지정된 이름과 속성이 특수한 형식 &lt;code&gt;true&lt;/code&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="dbbcb4829fb9912c3525baacd41622ceec30d952" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given name and arity is an operator.</source>
          <target state="translated">지정된 이름과 속성이 연산자 인 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="52116aac5e28100d570d3cb42c4444a615786a50" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given path exists.</source>
          <target state="translated">주어진 경로가 존재하면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c5fc3ddeee6d05ca5c0842207c7f56323a1a6f14" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given path is a directory.</source>
          <target state="translated">주어진 경로가 디렉토리 &lt;code&gt;true&lt;/code&gt; 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="517323943306de393ed5a17a3debaae9a9fed99c" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given quoted expression is an AST literal.</source>
          <target state="translated">주어진 인용 표현식이 AST 리터럴 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="070beb97acda30870921a2b5172f899e978ee793" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given year is a leap year.</source>
          <target state="translated">주어진 연도가 윤년 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="d291a7b2377eea8162c3c36aa1cd1e9a3a7a6551" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the local node is alive.</source>
          <target state="translated">로컬 노드가 활성화되어 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="156b20d9c8ac68b8747fdeb1da0914a3b632fddb" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the path is a regular file.</source>
          <target state="translated">경로가 일반 파일 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="1d9b07689695541ab22ddfbd90213a8b9d2d0606" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the protocol was consolidated.</source>
          <target state="translated">프로토콜이 통합 된 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="881d186c21e4675ad58d6e30bbadb52783870ebd" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the two terms are equal.</source>
          <target state="translated">두 항이 같으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="2e22125544cf945bb28eba5fc390b3a027251780" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the two terms are exactly equal.</source>
          <target state="translated">두 항이 정확히 같은 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="6f32dc56bc22b6598e27fc9e37220143e0f323c6" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the two terms are not equal.</source>
          <target state="translated">두 항이 같지 않으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="065ff8f9bd783f62860f90b7044cda8eab69fb25" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the two terms are not exactly equal.</source>
          <target state="translated">두 항이 정확히 같지 않으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="229c2393cba0014721bc6cce3f70d909956c53cb" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the year in the given &lt;code&gt;date&lt;/code&gt; is a leap year.</source>
          <target state="translated">주어진 &lt;code&gt;date&lt;/code&gt; 의 연도 가 윤년 인 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="13a00c2b01cafb21f20aede0315828bc757af694" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if there is such a spec and it was copied as a callback. If the function associated to the spec has documentation defined prior to invoking this function, the docs are copied too.</source>
          <target state="translated">이러한 스펙이 있고 콜백으로 복사 된 경우 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 . 사양과 관련된 기능에이 기능을 호출하기 전에 문서가 정의되어 있으면 문서도 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="baa3ca70dba967b0e62e4a45ae94ce224c5b50d1" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if two calendars have the same moment of starting a new day, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 이 달력의 경우는, 새로운 하루를 시작 같은 순간이 &lt;code&gt;false&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="efe1be0b98d40df3569dc29aeea771c28ce30865" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="47f2f68842134b4ffc89dac515dace73b452b30e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:error, :nofile}&lt;/code&gt; if the object code (i.e. &quot;.beam&quot; file) for the module could not be found locally.</source>
          <target state="translated">반환 &lt;code&gt;{:error, :nofile}&lt;/code&gt; 모듈에 대한 목적 코드 (예 : &quot;.beam&quot;파일)을 로컬로 발견되지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="b3f710f35d60c6b707ea291cad4605f95090d8c8" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, binary}&lt;/code&gt;, where &lt;code&gt;binary&lt;/code&gt; is a binary data object that contains the contents of &lt;code&gt;path&lt;/code&gt;, or &lt;code&gt;{:error, reason}&lt;/code&gt; if an error occurs.</source>
          <target state="translated">&lt;code&gt;{:ok, binary}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;binary&lt;/code&gt; 는 &lt;code&gt;path&lt;/code&gt; 의 컨텐츠를 포함하는 2 진 데이터 오브젝트 이거나 오류가 발생하면 &lt;code&gt;{:error, reason}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="25e0d60989d049e604d74bc930f296684099ec4b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, bytes_copied}&lt;/code&gt; if successful, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 값 &lt;code&gt;{:ok, bytes_copied}&lt;/code&gt; 성공했을 경우, &lt;code&gt;{:error, reason}&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="d3f3b14d34e951b96b9a67a82034916e33ca9318" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, date}&lt;/code&gt; if the calendars are compatible, or &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; if they are not.</source>
          <target state="translated">반환 &lt;code&gt;{:ok, date}&lt;/code&gt; 캘린더가 호환되는 경우, 또는 &lt;code&gt;{:error, :incompatible_calendars}&lt;/code&gt; 그렇지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="c6057594582ceb37532b2d7e625f688602918826" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, element}&lt;/code&gt; if found, otherwise &lt;code&gt;:error&lt;/code&gt;.</source>
          <target state="translated">발견되면 &lt;code&gt;{:ok, element}&lt;/code&gt; , 그렇지 않으면 &lt;code&gt;:error&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="8465f6ff407bdb0c564ac803b1f00a18b0d13256" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, files_and_directories}&lt;/code&gt; with all files and directories removed in no specific order, &lt;code&gt;{:error, reason, file}&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;{:ok, files_and_directories}&lt;/code&gt; 어떤 특정 순서로 제거 된 모든 파일과 디렉토리와, &lt;code&gt;{:error, reason, file}&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="19f842e2bafa50ff26925ccf6b987eee1f2ba2de" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, files}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;{:ok, files}&lt;/code&gt; 성공의 경우, &lt;code&gt;{:error, reason}&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="8fc3733718dbca9b65f2fc1faa8f991cc16a2e70" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, function_result}&lt;/code&gt; in case of success, &lt;code&gt;{:error, reason}&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;{:ok, function_result}&lt;/code&gt; 성공의 경우, &lt;code&gt;{:error, reason}&lt;/code&gt; 그렇지.</target>
        </trans-unit>
        <trans-unit id="98db4c3fa0a1a28efa6e85fa145c623de0fb6e8e" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, quoted_form}&lt;/code&gt; if it succeeds, &lt;code&gt;{:error, {line, error, token}}&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;{:ok, quoted_form}&lt;/code&gt; 가 성공하면, &lt;code&gt;{:error, {line, error, token}}&lt;/code&gt; 이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4c62985686c63d161efb90844fcc11aa585deb21" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, reply}&lt;/code&gt; if the reply is received while shutting down the task, &lt;code&gt;{:exit, reason}&lt;/code&gt; if the task died, otherwise &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;{:ok, reply}&lt;/code&gt; 작업을 종료하는 동안 응답이 수신되면, &lt;code&gt;{:exit, reason}&lt;/code&gt; 작업이 사망 한 경우는 true, 그렇지 않은 경우는 &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7721fcaadf1867ccdb0ee8fabd46fbe4697b0e3b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, reply}&lt;/code&gt; if the reply is received, &lt;code&gt;nil&lt;/code&gt; if no reply has arrived, or &lt;code&gt;{:exit, reason}&lt;/code&gt; if the task has already exited. Keep in mind that normally a task failure also causes the process owning the task to exit. Therefore this function can return &lt;code&gt;{:exit, reason}&lt;/code&gt; only if</source>
          <target state="translated">응답이 수신되면 &lt;code&gt;{:ok, reply}&lt;/code&gt; 를, 응답이 없으면 &lt;code&gt;nil&lt;/code&gt; 을 , 태스크가 이미 종료 된 경우 &lt;code&gt;{:exit, reason}&lt;/code&gt; 리턴 합니다. 일반적으로 작업이 실패하면 작업을 소유 한 프로세스가 종료됩니다. 따라서이 함수는 &lt;code&gt;{:exit, reason}&lt;/code&gt; 경우에만 {: exit, reason}을 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42c38d3829fadb64161c3356c163c581ae817e29" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, time}&lt;/code&gt; if the conversion was successful, or &lt;code&gt;{:error, reason}&lt;/code&gt; if it was not, for some reason.</source>
          <target state="translated">반환 &lt;code&gt;{:ok, time}&lt;/code&gt; 변환이 성공하면, 또는 &lt;code&gt;{:error, reason}&lt;/code&gt; 어떤 이유로, 아니었다면.</target>
        </trans-unit>
        <trans-unit id="154aaa63b2577dee11cda9665444466fcb0b0d8a" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{:ok, value}&lt;/code&gt; where &lt;code&gt;value&lt;/code&gt; is the value under &lt;code&gt;key&lt;/code&gt; if there is such a key, or &lt;code&gt;:error&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; is not found.</source>
          <target state="translated">&lt;code&gt;{:ok, value}&lt;/code&gt; 리턴합니다 . 여기서 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;key&lt;/code&gt; 경우 키 아래의 값 이거나 &lt;code&gt;key&lt;/code&gt; 를 찾을 수없는 경우 &lt;code&gt;:error&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fa7e955fa1d334a3f092f415c81243abd2e6e73b" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;{pid, value}&lt;/code&gt; pairs under the given &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;registry&lt;/code&gt; that match &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;{pid, value}&lt;/code&gt; 주어진 아래 쌍 &lt;code&gt;key&lt;/code&gt; 의 &lt;code&gt;registry&lt;/code&gt; 가 일치하는 &lt;code&gt;pattern&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85343a2e2d448cdb8c68e2a769e6043640f27d33" translate="yes" xml:space="preserve">
          <source>Returns Elixir's version as binary.</source>
          <target state="translated">Elixir의 버전을 바이너리로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c8327a48eb3d8b0888d21e8643d31dbfd61ce65e" translate="yes" xml:space="preserve">
          <source>Returns ExUnit configuration.</source>
          <target state="translated">ExUnit 구성을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e45ed402a1aef0911bf0539790a9e21d296ec8d5" translate="yes" xml:space="preserve">
          <source>Returns IEx configuration.</source>
          <target state="translated">IEx 구성을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8ddd6d989fce705f0bd075a07a2e07b8419b81a" translate="yes" xml:space="preserve">
          <source>Returns Unicode graphemes in the string as per Extended Grapheme Cluster algorithm.</source>
          <target state="translated">Extended Grapheme Cluster 알고리즘에 따라 문자열에서 유니 코드 그래프를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a879d2b042e9ebf3e77966bf7fa720eb5fe03d58" translate="yes" xml:space="preserve">
          <source>Returns a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; for the same point in time, but instead at the time zone provided. It assumes that &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; is valid and exists in the given time zone and calendar.</source>
          <target state="translated">제공된 시간대와 동일한 시점에서 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 을 반환합니다 . &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 이 유효하고 주어진 시간대와 달력에 존재 한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="68a4b55af4634a3e875518186464c1a14a8382cb" translate="yes" xml:space="preserve">
          <source>Returns a &lt;a href=&quot;#content&quot;&gt;&lt;code&gt;Macro.Env&lt;/code&gt;&lt;/a&gt; in the match context.</source>
          <target state="translated">일치 컨텍스트에서 &lt;a href=&quot;#content&quot;&gt; &lt;code&gt;Macro.Env&lt;/code&gt; &lt;/a&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6eec35892f7539fb9be61cf27410a2e47b62417d" translate="yes" xml:space="preserve">
          <source>Returns a &lt;a href=&quot;file.stream&quot;&gt;&lt;code&gt;File.Stream&lt;/code&gt;&lt;/a&gt; for the given &lt;code&gt;path&lt;/code&gt; with the given &lt;code&gt;modes&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;modes&lt;/code&gt; 주어진 &lt;code&gt;path&lt;/code&gt; 대한 &lt;a href=&quot;file.stream&quot;&gt; &lt;code&gt;File.Stream&lt;/code&gt; &lt;/a&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="d8144be8098e36dc7446a14e943dc98ccaeb4c84" translate="yes" xml:space="preserve">
          <source>Returns a &lt;code&gt;{new_value, old_value}&lt;/code&gt; tuple or &lt;code&gt;:error&lt;/code&gt; if there is no such key assigned to the current process.</source>
          <target state="translated">리턴 &lt;code&gt;{new_value, old_value}&lt;/code&gt; 튜플 또는 &lt;code&gt;:error&lt;/code&gt; 현재 프로세스에 할당 그러한 키가없는 경우.</target>
        </trans-unit>
        <trans-unit id="ed9d70afa84c2d6c400dd032dc85829ad3b83b52" translate="yes" xml:space="preserve">
          <source>Returns a binary which corresponds to the text representation of &lt;code&gt;integer&lt;/code&gt; in the given &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;base&lt;/code&gt; 에서 &lt;code&gt;integer&lt;/code&gt; 의 텍스트 표현에 해당하는 이진수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3fe6fea6c77a74fd7aefea1b6360d798d95ece81" translate="yes" xml:space="preserve">
          <source>Returns a binary which corresponds to the text representation of &lt;code&gt;integer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;integer&lt;/code&gt; 의 텍스트 표현에 해당하는 2 진을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="fb6a545975b068b3aecc7914d1615a7f44705a51" translate="yes" xml:space="preserve">
          <source>Returns a binary which corresponds to the text representation of the given float.</source>
          <target state="translated">주어진 float의 텍스트 표현에 해당하는 이진수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e9ee2af2fefcd231b751de3abbbb4367e4a017d5" translate="yes" xml:space="preserve">
          <source>Returns a binary with the contents of the given filename, or raises a &lt;a href=&quot;file.error&quot;&gt;&lt;code&gt;File.Error&lt;/code&gt;&lt;/a&gt; exception if an error occurs.</source>
          <target state="translated">주어진 파일 이름의 내용으로 바이너리를 반환하거나 오류가 발생하면 &lt;a href=&quot;file.error&quot;&gt; &lt;code&gt;File.Error&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="120b1743f1c9682c89a8ee1edeecbdcde083f3e9" translate="yes" xml:space="preserve">
          <source>Returns a boolean indicating whether there was a match or not.</source>
          <target state="translated">일치 여부를 나타내는 부울을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b5dce3473d3544c2ba77aa5170f30e27f43d3523" translate="yes" xml:space="preserve">
          <source>Returns a break document based on the given &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;string&lt;/code&gt; 기반으로 나누기 문서를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="148f06e99adcd7ca106331bc4f679ef4533da0a3" translate="yes" xml:space="preserve">
          <source>Returns a charlist which corresponds to the text representation of &lt;code&gt;integer&lt;/code&gt; in the given &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;base&lt;/code&gt; 에서 &lt;code&gt;integer&lt;/code&gt; 의 텍스트 표현에 해당하는 charlist를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1503e8fafb0830e350373d283f11c7581b3c38f8" translate="yes" xml:space="preserve">
          <source>Returns a charlist which corresponds to the text representation of the given &lt;code&gt;integer&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;integer&lt;/code&gt; 의 텍스트 표현에 해당하는 charlist를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="43b18b9794e48a6db989f7ec557071f9c475c477" translate="yes" xml:space="preserve">
          <source>Returns a charlist which corresponds to the text representation of the given float.</source>
          <target state="translated">주어진 float의 텍스트 표현에 해당하는 charlist를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a66b98e04f0ea2a62e2fb6e6de98289cd67c3736" translate="yes" xml:space="preserve">
          <source>Returns a document entity used to represent nothingness.</source>
          <target state="translated">아무것도 나타내지 않는 데 사용되는 문서 엔터티를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a1bfd05f736e844750b386b1c01e973ef52bc4ca" translate="yes" xml:space="preserve">
          <source>Returns a flex break document based on the given &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;string&lt;/code&gt; 기반으로 플렉스 브레이크 문서를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="0c47e20aaea8620c53179f6fb170bdceaf383d8a" translate="yes" xml:space="preserve">
          <source>Returns a float value between 0 and 1 representing the bag distance between &lt;code&gt;string1&lt;/code&gt; and &lt;code&gt;string2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string1&lt;/code&gt; 과 &lt;code&gt;string2&lt;/code&gt; 사이의 백 거리를 나타내는 0과 1 사이의 부동 소수점 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="998bf1dee48191c100b29bb8870dc0bfd94436f0" translate="yes" xml:space="preserve">
          <source>Returns a float value between &lt;code&gt;0.0&lt;/code&gt; (equates to no similarity) and &lt;code&gt;1.0&lt;/code&gt; (is an exact match) representing &lt;a href=&quot;https://en.wikipedia.org/wiki/Jaro-Winkler_distance&quot;&gt;Jaro&lt;/a&gt; distance between &lt;code&gt;string1&lt;/code&gt; and &lt;code&gt;string2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;string1&lt;/code&gt; 과 &lt;code&gt;string2&lt;/code&gt; 사이의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Jaro-Winkler_distance&quot;&gt;Jaro&lt;/a&gt; 거리를 나타내는 &lt;code&gt;0.0&lt;/code&gt; (유사하지 않음)과 &lt;code&gt;1.0&lt;/code&gt; (정확한 일치) 사이의 float 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e9f8bf09a9f34d4aa9970244bb6b08137539aa70" translate="yes" xml:space="preserve">
          <source>Returns a float whose text representation is &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">텍스트 표현이 &lt;code&gt;string&lt;/code&gt; 인 float를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="31dfe0ef9ec0fedde587f2c8b1e43ddb330410d1" translate="yes" xml:space="preserve">
          <source>Returns a function that accesses all elements of a list that match the provided predicate.</source>
          <target state="translated">제공된 술어와 일치하는 목록의 모든 요소에 액세스하는 함수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b2e7a33fe2eca022933ae3188c0bec0da1284381" translate="yes" xml:space="preserve">
          <source>Returns a function that accesses all the elements in a list.</source>
          <target state="translated">목록의 모든 요소에 액세스하는 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cfd1c05d413a490f8c760724f59340db6b61354f" translate="yes" xml:space="preserve">
          <source>Returns a function that accesses the element at &lt;code&gt;index&lt;/code&gt; (zero based) of a list.</source>
          <target state="translated">목록의 &lt;code&gt;index&lt;/code&gt; (0부터 시작)로 요소에 액세스하는 함수를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ea1bb2d03634b86a0bbf62fe40a739bf0c9036dd" translate="yes" xml:space="preserve">
          <source>Returns a function that accesses the element at the given index in a tuple.</source>
          <target state="translated">주어진 인덱스의 요소를 튜플에 액세스하는 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b5bb78552cf299e3751c2c8eda6479ac9f7282f" translate="yes" xml:space="preserve">
          <source>Returns a function that accesses the given key in a map/struct.</source>
          <target state="translated">map / struct에서 주어진 키에 액세스하는 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="55f8b9bb8e42ffaf566f7f747a4ca7567d68281b" translate="yes" xml:space="preserve">
          <source>Returns a function that slices the data structure contiguously.</source>
          <target state="translated">데이터 구조를 연속적으로 슬라이스하는 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2f00d7a399dbc354afa8c2290b54636c57247f20" translate="yes" xml:space="preserve">
          <source>Returns a group containing the specified document &lt;code&gt;doc&lt;/code&gt;.</source>
          <target state="translated">지정된 문서 &lt;code&gt;doc&lt;/code&gt; 를 포함한 그룹을 돌려 줍니다.</target>
        </trans-unit>
        <trans-unit id="8c5398d8391a0259d1ccb3c8a1e4048bcef9effb" translate="yes" xml:space="preserve">
          <source>Returns a keyword list containing the file and line information as keys.</source>
          <target state="translated">파일 및 행 정보를 키로 포함하는 키워드 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="648bd9570648164795082b3f1c9c78a01e804e98" translate="yes" xml:space="preserve">
          <source>Returns a keyword list of &lt;code&gt;{record_name, fields}&lt;/code&gt; tuples where &lt;code&gt;record_name&lt;/code&gt; is the name of an extracted record and &lt;code&gt;fields&lt;/code&gt; is a list of &lt;code&gt;{field, value}&lt;/code&gt; tuples representing the fields for that record.</source>
          <target state="translated">&lt;code&gt;{record_name, fields}&lt;/code&gt; 튜플 의 키워드 목록을 리턴합니다. 여기서 &lt;code&gt;record_name&lt;/code&gt; 은 추출 된 레코드의 이름이고 &lt;code&gt;fields&lt;/code&gt; 는 해당 레코드의 필드를 나타내는 &lt;code&gt;{field, value}&lt;/code&gt; 튜플 의 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="8337c1a71b4665b5929e7d32d232482d86ee48e9" translate="yes" xml:space="preserve">
          <source>Returns a keyword list that represents an &lt;em&gt;edit script&lt;/em&gt; with nested diffs.</source>
          <target state="translated">중첩 된 diff가 있는 &lt;em&gt;편집 스크립트&lt;/em&gt; 를 나타내는 키워드 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8a26e224d0b8b71dece8f5e916d84049523f0979" translate="yes" xml:space="preserve">
          <source>Returns a keyword list that represents an &lt;em&gt;edit script&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;편집 스크립트&lt;/em&gt; 를 나타내는 키워드 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cb34012caf25d7194cf4d1bc9c046b1e42666795" translate="yes" xml:space="preserve">
          <source>Returns a keyword list that represents an edit script.</source>
          <target state="translated">편집 스크립트를 나타내는 키워드 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eedf848148ad7204be333289f9f16e13b3fc0697" translate="yes" xml:space="preserve">
          <source>Returns a keyword list with information about a function.</source>
          <target state="translated">함수에 대한 정보가 포함 된 키워드 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a294c106358f5929d6a933ceb72092fc4e91db19" translate="yes" xml:space="preserve">
          <source>Returns a list of PIDs corresponding to all the processes currently existing on the local node.</source>
          <target state="translated">로컬 노드에 현재 존재하는 모든 프로세스에 해당하는 PID 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d8906cc4706b054f3a0871dd9d0310a0ffd4a655" translate="yes" xml:space="preserve">
          <source>Returns a list of all ports in the current node.</source>
          <target state="translated">현재 노드의 모든 포트 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="442155f6918bffcbda71b7032acfad2eca666df5" translate="yes" xml:space="preserve">
          <source>Returns a list of all visible nodes in the system, excluding the local node.</source>
          <target state="translated">로컬 노드를 제외하고 시스템에서 보이는 모든 노드 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f8eb0a24f0941de92ece10ea21ea0c9bd87f18fc" translate="yes" xml:space="preserve">
          <source>Returns a list of binaries each of which contains only one kind of characters.</source>
          <target state="translated">각각 하나의 문자 만 포함하는 이진 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="41dabd7ef6701ee8f9c03c392f544c0830be2893" translate="yes" xml:space="preserve">
          <source>Returns a list of elements in &lt;code&gt;enumerable&lt;/code&gt; excluding those for which the function &lt;code&gt;fun&lt;/code&gt; returns a truthy value.</source>
          <target state="translated">&lt;code&gt;fun&lt;/code&gt; 함수가 값을 반환하는 요소를 제외하고 &lt;code&gt;enumerable&lt;/code&gt; 요소 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="08000c5f7be9ad33a6570c782818808e7f042883" translate="yes" xml:space="preserve">
          <source>Returns a list of elements in &lt;code&gt;enumerable&lt;/code&gt; in reverse order.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 요소 목록을 역순 으로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c4d08a398f8c15dbdfe83b1a89d1c9a457b9a84f" translate="yes" xml:space="preserve">
          <source>Returns a list of every &lt;code&gt;nth&lt;/code&gt; element in the &lt;code&gt;enumerable&lt;/code&gt; dropped, starting with the first element.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 드롭 의 모든 &lt;code&gt;nth&lt;/code&gt; 요소 의 목록을 첫 번째 요소부터 시작하여 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4b51f0df81b5ca5b56cb57f91725427bb75c7424" translate="yes" xml:space="preserve">
          <source>Returns a list of every &lt;code&gt;nth&lt;/code&gt; element in the &lt;code&gt;enumerable&lt;/code&gt;, starting with the first element.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 의 모든 &lt;code&gt;nth&lt;/code&gt; 요소 의 목록을 첫 번째 요소부터 시작하여 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b454366f7b3d78cbfc941bae8df22ee9fbb4a118" translate="yes" xml:space="preserve">
          <source>Returns a list of information of all the function calls in the project.</source>
          <target state="translated">프로젝트에서 모든 함수 호출의 정보 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="543f883da41aab298162970e26e0991542c23a78" translate="yes" xml:space="preserve">
          <source>Returns a list of lists.</source>
          <target state="translated">리스트의리스트를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="c263c9ad704887b94b7128901687e89cfa0d788f" translate="yes" xml:space="preserve">
          <source>Returns a list of names in the regex.</source>
          <target state="translated">정규식의 이름 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0e24c8386f4a72d5dc84fefa837a24b53df43bca" translate="yes" xml:space="preserve">
          <source>Returns a list of names which have been registered using &lt;a href=&quot;#register/2&quot;&gt;&lt;code&gt;register/2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#register/2&quot;&gt; &lt;code&gt;register/2&lt;/code&gt; 를&lt;/a&gt; 사용하여 등록 된 이름 목록을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="e8470e68b35ac3b3b896cdb54a7773a9a2458a74" translate="yes" xml:space="preserve">
          <source>Returns a list of nodes according to argument given.</source>
          <target state="translated">주어진 인수에 따라 노드 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3ec5a571b567053b25abfcf409e5640616ed510" translate="yes" xml:space="preserve">
          <source>Returns a list of project configuration files for this project.</source>
          <target state="translated">이 프로젝트의 프로젝트 구성 파일 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62f88ef397b63230e48736e2ce2545ec58ddb020" translate="yes" xml:space="preserve">
          <source>Returns a list of results of invoking &lt;code&gt;fun&lt;/code&gt; on every &lt;code&gt;nth&lt;/code&gt; element of &lt;code&gt;enumerable&lt;/code&gt;, starting with the first element.</source>
          <target state="translated">첫 번째 요소부터 시작하여 &lt;code&gt;enumerable&lt;/code&gt; 의 &lt;code&gt;nth&lt;/code&gt; 요소 마다 &lt;code&gt;fun&lt;/code&gt; 을 호출 한 결과 목록을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="fccd605cb6dc280f4d9624edc25a5e8af076d5e8" translate="yes" xml:space="preserve">
          <source>Returns a list of these parts. The pattern can be a string, a list of strings, a regular expression, or a compiled pattern.</source>
          <target state="translated">이 부분의리스트를 돌려줍니다. 패턴은 문자열, 문자열 목록, 정규식 또는 컴파일 된 패턴 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8244ce7e7962dc18e63cc6bb50b0981feb2b847c" translate="yes" xml:space="preserve">
          <source>Returns a list of tuples where the first element is the module name and the second one is its bytecode (as a binary). A &lt;code&gt;file&lt;/code&gt; can be given as second argument which will be used for reporting warnings and errors.</source>
          <target state="translated">첫 번째 요소는 모듈 이름이고 두 번째 요소는 바이트 코드 (바이너리) 인 튜플 목록을 반환합니다. &lt;code&gt;file&lt;/code&gt; 경고 및 오류를보고하는 데 사용됩니다 두 번째 인수로 부여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8030ddd5e1a6c45acf4116b3a1cb2af7216011a1" translate="yes" xml:space="preserve">
          <source>Returns a list of tuples where the first element is the module name and the second one is its bytecode (as a binary). Opposite to &lt;a href=&quot;#require_file/2&quot;&gt;&lt;code&gt;require_file/2&lt;/code&gt;&lt;/a&gt;, it does not track the filename of the compiled file.</source>
          <target state="translated">첫 번째 요소는 모듈 이름이고 두 번째 요소는 바이트 코드 (바이너리) 인 튜플 목록을 반환합니다. &lt;a href=&quot;#require_file/2&quot;&gt; &lt;code&gt;require_file/2&lt;/code&gt; 와는&lt;/a&gt; 반대로 컴파일 된 파일의 파일 이름을 추적하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b04fc71c3bba89d65fc90b112e21df50106a3bc" translate="yes" xml:space="preserve">
          <source>Returns a list of variables in the current environment.</source>
          <target state="translated">현재 환경의 변수 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a435441f15be08b7ff15b579018abecdc00bc602" translate="yes" xml:space="preserve">
          <source>Returns a list where each element is the result of invoking &lt;code&gt;fun&lt;/code&gt; on each corresponding element of &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">각 요소가 &lt;code&gt;enumerable&lt;/code&gt; 의 각 해당 요소에서 &lt;code&gt;fun&lt;/code&gt; 을 호출 한 결과 인 목록을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ec27903f5ae78dc874c9df5818a4b29f8aa65266" translate="yes" xml:space="preserve">
          <source>Returns a list with &lt;code&gt;value&lt;/code&gt; inserted at the specified &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;index&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 삽입 된 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7f2ea00fcc82bbc6b6dcd711a2adc16be411dabf" translate="yes" xml:space="preserve">
          <source>Returns a list with a replaced value at the specified &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;index&lt;/code&gt; 에서 값이 교체 된 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="194e44d56acccbecc0953b596c47bacb2836f1fa" translate="yes" xml:space="preserve">
          <source>Returns a list with an updated value at the specified &lt;code&gt;index&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;index&lt;/code&gt; 에서 업데이트 된 값을 가진 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cac6cb2d5b65cec2cebc7f98c8e676a52e8a12e5" translate="yes" xml:space="preserve">
          <source>Returns a list with information about all children of the given supervisor.</source>
          <target state="translated">지정된 감독자의 모든 자식에 대한 정보가있는 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8be9be340deaec39cff95b3d58502fb1f32311d0" translate="yes" xml:space="preserve">
          <source>Returns a list with information about all children.</source>
          <target state="translated">모든 자식에 대한 정보가있는 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae5b3e7b9544d246ab2ddf253fc4625df3b3fad2" translate="yes" xml:space="preserve">
          <source>Returns a list with information about the applications which are currently running.</source>
          <target state="translated">현재 실행중인 응용 프로그램에 대한 정보가있는 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9556f6608ac48363049e28e2254897ca4d3d6bbe" translate="yes" xml:space="preserve">
          <source>Returns a list with information about the applications which have been loaded.</source>
          <target state="translated">로드 된 애플리케이션에 대한 정보가있는 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9dc40e627344f95c93e4ec9b038b5d04b7dabe06" translate="yes" xml:space="preserve">
          <source>Returns a list with the available compiler options.</source>
          <target state="translated">사용 가능한 컴파일러 옵션이있는 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="caa61a915d0b0a3954d25228367b76a55e8c46b5" translate="yes" xml:space="preserve">
          <source>Returns a list with the elements of &lt;code&gt;enumerable&lt;/code&gt; shuffled.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 섞기 요소가있는 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="75e31c70d49c501aa570c31218e633b38b9cac15" translate="yes" xml:space="preserve">
          <source>Returns a map containing count values for the given supervisor.</source>
          <target state="translated">지정된 수퍼바이저의 카운트 값이 포함 된 맵을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6aa62c1653283a212e8297ca294f4114c48e5453" translate="yes" xml:space="preserve">
          <source>Returns a map containing count values for the supervisor.</source>
          <target state="translated">수퍼바이저의 카운트 값이 포함 된 맵을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f64f0a2526f951c2cc84f1d137432fe69495d9aa" translate="yes" xml:space="preserve">
          <source>Returns a map containing the total number of tests, the number of failures, the number of excluded tests and the number of skipped tests.</source>
          <target state="translated">총 테스트 수, 실패 수, 제외 된 테스트 수 및 건너 뛴 테스트 수를 포함하는 맵을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e48947a95d8a72816f9cddcba983270eb4a365c9" translate="yes" xml:space="preserve">
          <source>Returns a map with the Elixir version, the Erlang/OTP release it was compiled with, a short Git revision hash and the date and time it was built.</source>
          <target state="translated">Elixir 버전, Erlang / OTP 릴리스, 짧은 Git 개정 해시 및 빌드 날짜 및 시간이 포함 된 맵을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4cbfdcfd806b8b2dd63bdb3d7952ca6be2cb7883" translate="yes" xml:space="preserve">
          <source>Returns a map with the umbrella child applications paths.</source>
          <target state="translated">우산 자식 응용 프로그램 경로가있는지도를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="577b259579425fb15446d410225cd83d09c11ab4" translate="yes" xml:space="preserve">
          <source>Returns a microsecond tuple truncated to a given precision (&lt;code&gt;:microsecond&lt;/code&gt;, &lt;code&gt;:millisecond&lt;/code&gt; or &lt;code&gt;:second&lt;/code&gt;).</source>
          <target state="translated">주어진 정밀도 ( &lt;code&gt;:microsecond&lt;/code&gt; , &lt;code&gt;:millisecond&lt;/code&gt; 또는 &lt;code&gt;:second&lt;/code&gt; )로 잘린 마이크로 초 튜플을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="456254db671e7211f8cf975ebc7a01fd2d4e0998" translate="yes" xml:space="preserve">
          <source>Returns a new empty map.</source>
          <target state="translated">새로운 빈 맵을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="1de9e80d913162895ee668db73d628ac36f3f1be" translate="yes" xml:space="preserve">
          <source>Returns a new list with all the tuple elements.</source>
          <target state="translated">모든 튜플 요소가 포함 된 새 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f1eabd6cd97a0e9ba88d32a0847a516f885aa149" translate="yes" xml:space="preserve">
          <source>Returns a new map with all the key-value pairs in &lt;code&gt;map&lt;/code&gt; where the key is in &lt;code&gt;keys&lt;/code&gt;.</source>
          <target state="translated">키가 &lt;code&gt;keys&lt;/code&gt; 에 있는 &lt;code&gt;map&lt;/code&gt; 모든 키-값 쌍이 포함 된 새 맵을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="af29913ee55ab14a28ffeef5c6463f0e6a27de67" translate="yes" xml:space="preserve">
          <source>Returns a new set which is a copy of &lt;code&gt;map_set&lt;/code&gt; but without &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map_set&lt;/code&gt; 의 사본 이지만 &lt;code&gt;value&lt;/code&gt; 없는 새 세트를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="d89b807379e6e83302850820787d6e2455a9be49" translate="yes" xml:space="preserve">
          <source>Returns a new set.</source>
          <target state="translated">새로운 세트를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="593aa885fd57e21ecae557eeb33661b2357bb26c" translate="yes" xml:space="preserve">
          <source>Returns a new string created by replacing occurrences of &lt;code&gt;pattern&lt;/code&gt; in &lt;code&gt;subject&lt;/code&gt; with &lt;code&gt;replacement&lt;/code&gt;.</source>
          <target state="translated">의 발생 대체하여 만든 새 문자열 반환 &lt;code&gt;pattern&lt;/code&gt; 에 &lt;code&gt;subject&lt;/code&gt; 와 &lt;code&gt;replacement&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5083144141615836b53ba33e2622989da2341885" translate="yes" xml:space="preserve">
          <source>Returns a new string padded with a leading filler which is made of elements from the &lt;code&gt;padding&lt;/code&gt;.</source>
          <target state="translated">반환 새로운 문자열에서 요소로 선도적 인 필러 패딩 &lt;code&gt;padding&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5f12166c88991612389eebd8f5e894dc39963de" translate="yes" xml:space="preserve">
          <source>Returns a new string padded with a trailing filler which is made of elements from the &lt;code&gt;padding&lt;/code&gt;.</source>
          <target state="translated">반환 새로운 문자열의 요소로 제조 된 뒤 필러로 채워 &lt;code&gt;padding&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b79ec9067cac0c611785cc80d52ec1f184545e0" translate="yes" xml:space="preserve">
          <source>Returns a new tuple with the element appended at the end, and contains the elements in &lt;code&gt;tuple&lt;/code&gt; followed by &lt;code&gt;value&lt;/code&gt; as the last element.</source>
          <target state="translated">마지막에 첨부 한 요소 새로운 튜플을 반환하고있는 요소가 포함 &lt;code&gt;tuple&lt;/code&gt; 다음 &lt;code&gt;value&lt;/code&gt; 마지막 요소로서.</target>
        </trans-unit>
        <trans-unit id="1fd950ec684b5f58c716702cc6515ef2732cc35c" translate="yes" xml:space="preserve">
          <source>Returns a pair of integers whose ratio is exactly equal to the original float and with a positive denominator.</source>
          <target state="translated">비율이 원래 부동 소수점과 정확히 같고 양의 분모를 갖는 정수 쌍을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ebb93599cfaa3e0a101538db0f72f4e659111549" translate="yes" xml:space="preserve">
          <source>Returns a quoted expression containing the fields as a list of tuples.</source>
          <target state="translated">필드를 튜플 목록으로 포함하는 인용 된 표현식을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0258ae812e9738eccffc25af4f511a4696661e12" translate="yes" xml:space="preserve">
          <source>Returns a random element of an &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 임의의 요소를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="68311a4d355d1a1367604d1a97e1ec72781c2627" translate="yes" xml:space="preserve">
          <source>Returns a range of dates.</source>
          <target state="translated">날짜 범위를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fb20084f202d63d2e087bd5b253825ad1541cba1" translate="yes" xml:space="preserve">
          <source>Returns a range with the specified &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; integers.</source>
          <target state="translated">지정된 &lt;code&gt;first&lt;/code&gt; 정수 와 &lt;code&gt;last&lt;/code&gt; 정수를 가진 범위를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0cfb3ee91f1e7803aeeae50c9afdbd58c4a0494f" translate="yes" xml:space="preserve">
          <source>Returns a set containing all members of &lt;code&gt;map_set1&lt;/code&gt; and &lt;code&gt;map_set2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map_set1&lt;/code&gt; 및 &lt;code&gt;map_set2&lt;/code&gt; 의 모든 멤버를 포함하는 세트를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c7e140698da2797ab90228cb1fe2e4daf4bf7bd0" translate="yes" xml:space="preserve">
          <source>Returns a set containing only members that &lt;code&gt;map_set1&lt;/code&gt; and &lt;code&gt;map_set2&lt;/code&gt; have in common.</source>
          <target state="translated">&lt;code&gt;map_set1&lt;/code&gt; 과 &lt;code&gt;map_set2&lt;/code&gt; 에 공통 인 멤버 만 포함 된 세트를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="77d801b91285762b7c58364cfd1b23fdf545bf37" translate="yes" xml:space="preserve">
          <source>Returns a set that is &lt;code&gt;map_set1&lt;/code&gt; without the members of &lt;code&gt;map_set2&lt;/code&gt;.</source>
          <target state="translated">인 세트를 돌려줍니다 &lt;code&gt;map_set1&lt;/code&gt; 의 멤버없이 &lt;code&gt;map_set2&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="fd8e89ddc96087c4845355b2bc3ed2ac6bca08b8" translate="yes" xml:space="preserve">
          <source>Returns a specific information about the function.</source>
          <target state="translated">함수에 대한 특정 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ade53d26fd49c96742f8c2f9ec1c19ff5f585daa" translate="yes" xml:space="preserve">
          <source>Returns a specification to start a dynamic supervisor under a supervisor.</source>
          <target state="translated">수퍼바이저에서 동적 수퍼바이저를 시작하기위한 스펙을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="688104702b513d9e2a5c6b446efa4fff4350efd8" translate="yes" xml:space="preserve">
          <source>Returns a specification to start a registry under a supervisor.</source>
          <target state="translated">감독자 아래에서 레지스트리를 시작하기위한 사양을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="39726169845a0007a11ac1c1802741f412dc9a02" translate="yes" xml:space="preserve">
          <source>Returns a specification to start a task under a supervisor.</source>
          <target state="translated">감독자에서 작업을 시작하기위한 사양을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a971d06295628f307553b8532333fe53b2d6db9e" translate="yes" xml:space="preserve">
          <source>Returns a specification to start an agent under a supervisor.</source>
          <target state="translated">수퍼바이저에서 에이전트를 시작하기위한 스펙을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="3b59fc82f7ced9ba4e9462febb3a349db49c4788" translate="yes" xml:space="preserve">
          <source>Returns a specification to start this module under a supervisor.</source>
          <target state="translated">감독자 아래에서이 모듈을 시작하기위한 사양을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="37a637ecd014943420fb395fff88ce0640ba2b2f" translate="yes" xml:space="preserve">
          <source>Returns a stream generated by calling &lt;code&gt;generator_fun&lt;/code&gt; repeatedly.</source>
          <target state="translated">&lt;code&gt;generator_fun&lt;/code&gt; 을 반복해서 호출 하여 생성 된 스트림을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2ce10d4439c9ded520a2ceb914ab4aa7920dd279" translate="yes" xml:space="preserve">
          <source>Returns a stream of two-element tuples representing key-value pairs in the given &lt;code&gt;query&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;query&lt;/code&gt; 에서 키-값 쌍을 나타내는 두 요소 튜플의 스트림을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="8c408cbe5adb568e4c29e0c46a4da3160a6a82b7" translate="yes" xml:space="preserve">
          <source>Returns a stream that runs the given &lt;code&gt;function&lt;/code&gt; concurrently on each element in &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 각 요소에 대해 지정된 &lt;code&gt;function&lt;/code&gt; 동시에 실행하는 스트림을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6e496b0f2924747071bd9a07cac7da5f78b00d7c" translate="yes" xml:space="preserve">
          <source>Returns a stream that runs the given function &lt;code&gt;fun&lt;/code&gt; concurrently on each element in &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;enumerable&lt;/code&gt; 된 각 요소에 대해 주어진 함수 &lt;code&gt;fun&lt;/code&gt; 을 동시에 실행하는 스트림을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a0abd42595135eb6e6bc02e83c1dc3bb49aa88b3" translate="yes" xml:space="preserve">
          <source>Returns a stream where the given function (&lt;code&gt;module&lt;/code&gt; and &lt;code&gt;function&lt;/code&gt;) is mapped concurrently on each element in &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">지정된 함수 ( &lt;code&gt;module&lt;/code&gt; 및 &lt;code&gt;function&lt;/code&gt; )가 &lt;code&gt;enumerable&lt;/code&gt; 각 요소에 동시에 매핑 되는 스트림을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5678b516f871306c06a41b4392d2b5b139efdac5" translate="yes" xml:space="preserve">
          <source>Returns a stream where the given function (&lt;code&gt;module&lt;/code&gt; and &lt;code&gt;function_name&lt;/code&gt;) is mapped concurrently on each element in &lt;code&gt;enumerable&lt;/code&gt;.</source>
          <target state="translated">지정된 함수 ( &lt;code&gt;module&lt;/code&gt; 및 &lt;code&gt;function_name&lt;/code&gt; )가 &lt;code&gt;enumerable&lt;/code&gt; 각 요소에 동시에 맵핑 되는 스트림을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="180fc15b92792093769a25c20115b5e9872ea17f" translate="yes" xml:space="preserve">
          <source>Returns a string &lt;code&gt;subject&lt;/code&gt; duplicated &lt;code&gt;n&lt;/code&gt; times.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 번 중복 된 문자열 &lt;code&gt;subject&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6be4ae560047bcef41ff0b28a347e27a66f4e0f8" translate="yes" xml:space="preserve">
          <source>Returns a string containing the (usually) numerical identifier for a process. On UNIX, this is typically the return value of the &lt;code&gt;getpid()&lt;/code&gt; system call. On Windows, the process ID as returned by the &lt;code&gt;GetCurrentProcessId()&lt;/code&gt; system call is used.</source>
          <target state="translated">프로세스의 (일반적으로) 숫자 식별자를 포함하는 문자열을 반환합니다. UNIX에서 이는 일반적으로 &lt;code&gt;getpid()&lt;/code&gt; 시스템 호출 의 리턴 값입니다 . Windows에서는 &lt;code&gt;GetCurrentProcessId()&lt;/code&gt; 시스템 호출에 의해 리턴 된 프로세스 ID 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e2a419178bbb940b05880a5915a9ca05120adc14" translate="yes" xml:space="preserve">
          <source>Returns a string where all leading &lt;code&gt;to_trim&lt;/code&gt; characters have been removed.</source>
          <target state="translated">모든 선행 &lt;code&gt;to_trim&lt;/code&gt; 문자가 제거 된 문자열을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="9ce1c2a880865790d64e30f1e06470b38e182bfd" translate="yes" xml:space="preserve">
          <source>Returns a string where all leading Unicode whitespaces have been removed.</source>
          <target state="translated">모든 선행 유니 코드 공백이 제거 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5863b021d35f8bce6c99b63c41facc6909ca977c" translate="yes" xml:space="preserve">
          <source>Returns a string where all leading and trailing &lt;code&gt;to_trim&lt;/code&gt; characters have been removed.</source>
          <target state="translated">모든 선행 및 후행 &lt;code&gt;to_trim&lt;/code&gt; 문자가 제거 된 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f3acd17e8deabf16e78c4e5d3cd435340469c166" translate="yes" xml:space="preserve">
          <source>Returns a string where all leading and trailing Unicode whitespaces have been removed.</source>
          <target state="translated">모든 선행 및 후행 유니 코드 공백이 제거 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="77037d4de2ee207efdb679f3991444eaf4bfb6d8" translate="yes" xml:space="preserve">
          <source>Returns a string where all trailing &lt;code&gt;to_trim&lt;/code&gt; characters have been removed.</source>
          <target state="translated">모든 후행 &lt;code&gt;to_trim&lt;/code&gt; 문자가 제거 된 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b44e9f329fffddee85ee207a2880ca69a73d5432" translate="yes" xml:space="preserve">
          <source>Returns a string where all trailing Unicode whitespaces has been removed.</source>
          <target state="translated">모든 후행 유니 코드 공백이 제거 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="59755cc1b2bcebeacfa9d917bc55e49814c2c282" translate="yes" xml:space="preserve">
          <source>Returns a subset list of the given &lt;code&gt;enumerable&lt;/code&gt; by &lt;code&gt;index_range&lt;/code&gt;.</source>
          <target state="translated">주어진의 부분 집합의리스트를 돌려줍니다 &lt;code&gt;enumerable&lt;/code&gt; 하여 &lt;code&gt;index_range&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f01588f322f3a6c48ef0b1142d4af450e450f7de" translate="yes" xml:space="preserve">
          <source>Returns a subset list of the given &lt;code&gt;enumerable&lt;/code&gt;, from &lt;code&gt;start_index&lt;/code&gt; (zero-based) with &lt;code&gt;amount&lt;/code&gt; number of elements if available.</source>
          <target state="translated">반환 소정의 서브 세트리스트 &lt;code&gt;enumerable&lt;/code&gt; 에서 &lt;code&gt;start_index&lt;/code&gt; 가진 (기 제로) &lt;code&gt;amount&lt;/code&gt; 을 사용할 경우, 원소의 수.</target>
        </trans-unit>
        <trans-unit id="db1fa0efe5f563fd77fbd770ee5847604d12fb0c" translate="yes" xml:space="preserve">
          <source>Returns a substring from the offset given by the start of the range to the offset given by the end of the range.</source>
          <target state="translated">범위의 시작에 의해 주어진 오프셋에서 범위의 끝에 의해 주어진 오프셋까지 부분 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d5a014df4d2914afff26758db84313e7b53629c2" translate="yes" xml:space="preserve">
          <source>Returns a substring starting at the offset &lt;code&gt;start&lt;/code&gt;, and of length &lt;code&gt;len&lt;/code&gt;.</source>
          <target state="translated">오프셋 &lt;code&gt;start&lt;/code&gt; 에서 시작 하여 길이가 &lt;code&gt;len&lt;/code&gt; 인 하위 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6ec101f14dc34f334988903f882113db6c75107c" translate="yes" xml:space="preserve">
          <source>Returns a tuple &lt;code&gt;{day, era}&lt;/code&gt; representing the day within the era and the era number.</source>
          <target state="translated">&lt;code&gt;{day, era}&lt;/code&gt; 내 날짜와 연대 번호를 나타내는 튜플 {day, era}를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8e67509fba3335899cfadcaef1653695ee755861" translate="yes" xml:space="preserve">
          <source>Returns a tuple &lt;code&gt;{year, era}&lt;/code&gt; representing the year within the era and the era number.</source>
          <target state="translated">연대와 연대 수를 나타내는 튜플 &lt;code&gt;{year, era}&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fdd9f6699ef007d5bcfc4921c7b71d74906d67f2" translate="yes" xml:space="preserve">
          <source>Returns a tuple containing the supervisor specification. This tuple can be used as the return value of the &lt;code&gt;c:init/1&lt;/code&gt; callback when implementing a module-based supervisor.</source>
          <target state="translated">감독자 사양이 포함 된 튜플을 반환합니다. 이 튜플은 모듈 기반 감독자를 구현할 때 &lt;code&gt;c:init/1&lt;/code&gt; 콜백 의 반환 값으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f0996b39345ea9e7c9060c1426d24e1a14d175c" translate="yes" xml:space="preserve">
          <source>Returns a tuple containing the value associated with the key and the updated container. &lt;code&gt;nil&lt;/code&gt; is returned for the value if the key isn't in the container.</source>
          <target state="translated">키 및 업데이트 된 컨테이너와 관련된 값이 포함 된 튜플을 반환합니다. 키가 컨테이너에 없으면 값에 대해 &lt;code&gt;nil&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ff054a062909831fae54faf25f69066b049f0472" translate="yes" xml:space="preserve">
          <source>Returns a tuple of the form &lt;code&gt;{value, binding}&lt;/code&gt;, where &lt;code&gt;value&lt;/code&gt; is the value returned from evaluating &lt;code&gt;string&lt;/code&gt;. If an error occurs while evaluating &lt;code&gt;string&lt;/code&gt; an exception will be raised.</source>
          <target state="translated">&lt;code&gt;{value, binding}&lt;/code&gt; 형식의 튜플을 리턴합니다 . 여기서 &lt;code&gt;value&lt;/code&gt; 는 &lt;code&gt;string&lt;/code&gt; 평가에서 리턴 된 값 입니다. &lt;code&gt;string&lt;/code&gt; 을 평가하는 동안 오류가 발생 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9e1d2c960241a00096afd91bf252ac31507af671" translate="yes" xml:space="preserve">
          <source>Returns a tuple where the first element is the mapped enumerable and the second one is the final accumulator.</source>
          <target state="translated">첫 번째 요소는 매핑 가능한 열거 형이고 두 번째 요소는 최종 누산기 인 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9b9e1bdb527e70cc179683a4fe2a7521e95d2a67" translate="yes" xml:space="preserve">
          <source>Returns a tuple with the minimal and the maximal elements in the enumerable according to Erlang's term ordering.</source>
          <target state="translated">Erlang의 용어 순서에 따라 열거 가능한 최소 및 최대 요소를 가진 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9289a49fc0b517d3d38226831426fdffeb900f0b" translate="yes" xml:space="preserve">
          <source>Returns a tuple with the minimal and the maximal elements in the enumerable as calculated by the given function.</source>
          <target state="translated">주어진 함수에 의해 계산 된 열거 가능한 최소 및 최대 요소를 가진 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="78bc10df51b7a09f0be40994df79a6b72b67f2c3" translate="yes" xml:space="preserve">
          <source>Returns a tuple with the new list and the old list with removed keys.</source>
          <target state="translated">새로운리스트가있는 튜플과 키가 제거 된 기존리스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="49a58596d4c32840c588fba7e77c85318bcb2968" translate="yes" xml:space="preserve">
          <source>Returns a tuple with the new map and the old map with removed keys.</source>
          <target state="translated">새 맵이있는 튜플과 키가 제거 된 이전 맵을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ed72d4b56f51e8613ab1dfc371169fca9e518330" translate="yes" xml:space="preserve">
          <source>Returns a writable temporary directory. Searches for directories in the following order:</source>
          <target state="translated">쓰기 가능한 임시 디렉토리를 반환합니다. 다음 순서로 디렉토리를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="e713a513acbdedf0dda43d90f08d107eb1c0c63b" translate="yes" xml:space="preserve">
          <source>Returns all children PIDs.</source>
          <target state="translated">모든 자식 PID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e6a21f48135285b8b5bb30d5ad65b3b47e26f561" translate="yes" xml:space="preserve">
          <source>Returns all code points in the string.</source>
          <target state="translated">문자열의 모든 코드 포인트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e3cf44631bb390e7d2badb9d7470fae3253dc5ba" translate="yes" xml:space="preserve">
          <source>Returns all compilers.</source>
          <target state="translated">모든 컴파일러를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="14b145390a9ebf308c4b373dc11333b017df30f2" translate="yes" xml:space="preserve">
          <source>Returns all functions and macros defined in &lt;code&gt;module&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 에 정의 된 모든 함수와 매크로를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ad3bb32900d7c344e494107abf9c4c7326be59e8" translate="yes" xml:space="preserve">
          <source>Returns all functions defined in &lt;code&gt;module&lt;/code&gt;, according to its kind.</source>
          <target state="translated">종류에 따라 &lt;code&gt;module&lt;/code&gt; 에 정의 된 모든 함수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b5df146a1464140be99d57b6a49844f0f5e9e584" translate="yes" xml:space="preserve">
          <source>Returns all key-value pairs for &lt;code&gt;app&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;app&lt;/code&gt; 에 대한 모든 키-값 쌍을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="156e3a5fb38c335ce430ccbdf832347b21177bd7" translate="yes" xml:space="preserve">
          <source>Returns all key-value pairs in the process dictionary.</source>
          <target state="translated">프로세스 사전의 모든 키-값 쌍을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="406cf177f03a1fe2a55cb14779e3af7a09489d14" translate="yes" xml:space="preserve">
          <source>Returns all keys from &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 에서 모든 키를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="556358f0f53235e5674d035cdcc5f6968be35f2c" translate="yes" xml:space="preserve">
          <source>Returns all keys from the keyword list.</source>
          <target state="translated">키워드 목록에서 모든 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6d7122282aecdbcfa075a5e668d5f2c21f2161d1" translate="yes" xml:space="preserve">
          <source>Returns all keys in the process dictionary that have the given &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;value&lt;/code&gt; 을 가진 프로세스 딕셔너리의 모든 키를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="042b9c023d06dd909ce950f350535dbfb0777cec" translate="yes" xml:space="preserve">
          <source>Returns all keys in the process dictionary.</source>
          <target state="translated">프로세스 사전의 모든 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e94b9dcfc2e9dac51c4ac8484e5dfd70f3e9b33b" translate="yes" xml:space="preserve">
          <source>Returns all loaded task modules.</source>
          <target state="translated">로드 된 모든 작업 모듈을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="71787f9010554f94575f9522f1c99c44b60cb2e4" translate="yes" xml:space="preserve">
          <source>Returns all system environment variables.</source>
          <target state="translated">모든 시스템 환경 변수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e569da60b7ca186199784958ba9d2b81bb1397d9" translate="yes" xml:space="preserve">
          <source>Returns all values from &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 에서 모든 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1e7a0349730cbf3f3bafb2a0c0cb3cc28bea70d5" translate="yes" xml:space="preserve">
          <source>Returns all values from the keyword list.</source>
          <target state="translated">키워드 목록에서 모든 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d96004909e4ad7c64db0522497fe2d3b803021f3" translate="yes" xml:space="preserve">
          <source>Returns an almost unique reference.</source>
          <target state="translated">거의 고유 한 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a1ca941f10bbc2a839f82df74e5a66de383248c6" translate="yes" xml:space="preserve">
          <source>Returns an atom representing the name of the local node. If the node is not alive, &lt;code&gt;:nonode@nohost&lt;/code&gt; is returned instead.</source>
          <target state="translated">로컬 노드의 이름을 나타내는 아톰을 반환합니다. 노드가 &lt;code&gt;:nonode@nohost&lt;/code&gt; 가 아닌 경우 : nonode @ nohost 가 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4bca5cf89834f191f0b7d25cb60600751e2192dc" translate="yes" xml:space="preserve">
          <source>Returns an empty keyword list, i.e. an empty list.</source>
          <target state="translated">빈 키워드 목록, 즉 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9336405d72004e8204acc026354f638b5932365d" translate="yes" xml:space="preserve">
          <source>Returns an enumerable that splits a string on demand.</source>
          <target state="translated">요청시 문자열을 분할하는 열거 가능 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c23eeb7a803311ef05d76bc46b75ead9502cb701" translate="yes" xml:space="preserve">
          <source>Returns an inclusive range between dates.</source>
          <target state="translated">날짜 사이의 포함 범위를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="36ea821a1bd58beb41a35815684e5f6dd46947c7" translate="yes" xml:space="preserve">
          <source>Returns an initial accumulator and a &quot;collector&quot; function.</source>
          <target state="translated">초기 누산기와 &quot;수집기&quot;함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="790893bc81d3d485385a9efd616205fa2997b5ed" translate="yes" xml:space="preserve">
          <source>Returns an integer or float which is the arithmetical absolute value of &lt;code&gt;number&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; 의 산술 절대 값 인 정수 또는 부동 소수점을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="5ed4feca62654761a5cba1c5468578f70dd1f1a9" translate="yes" xml:space="preserve">
          <source>Returns an integer which is the size in bits of &lt;code&gt;bitstring&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;bitstring&lt;/code&gt; 의 비트 크기 인 정수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ff9f7b86de9e03f6280fece12d53e95bb81fce12" translate="yes" xml:space="preserve">
          <source>Returns an integer whose text representation is &lt;code&gt;charlist&lt;/code&gt; in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">base &lt;code&gt;base&lt;/code&gt; 에서 텍스트 표현이 &lt;code&gt;charlist&lt;/code&gt; 인 정수를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="7844d0ca3375055eb41de872777bcf4aa843366e" translate="yes" xml:space="preserve">
          <source>Returns an integer whose text representation is &lt;code&gt;charlist&lt;/code&gt;.</source>
          <target state="translated">텍스트 표현이 &lt;code&gt;charlist&lt;/code&gt; 인 정수를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="1f2895d4e76b96a85b5b1d6745d2f5eacc89e7d4" translate="yes" xml:space="preserve">
          <source>Returns an integer whose text representation is &lt;code&gt;string&lt;/code&gt; in base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">base &lt;code&gt;base&lt;/code&gt; 에서 텍스트 표현이 &lt;code&gt;string&lt;/code&gt; 인 정수를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a9d71ba16fbf453d9081568d72974d94e2e8747e" translate="yes" xml:space="preserve">
          <source>Returns an integer whose text representation is &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">텍스트 표현이 &lt;code&gt;string&lt;/code&gt; 인 정수를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="7d427036e767479c0ab88861dea125a1bc02a46f" translate="yes" xml:space="preserve">
          <source>Returns and removes the first value associated with &lt;code&gt;key&lt;/code&gt; in the keyword list.</source>
          <target state="translated">키워드 목록에서 &lt;code&gt;key&lt;/code&gt; 와 관련된 첫 번째 값을 반환하고 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="095f100d342a14917373097117de47a712bc7df4" translate="yes" xml:space="preserve">
          <source>Returns and removes the value associated with &lt;code&gt;key&lt;/code&gt; in &lt;code&gt;map&lt;/code&gt;.</source>
          <target state="translated">반품 및 제거합니다와 관련된 값 &lt;code&gt;key&lt;/code&gt; 의 &lt;code&gt;map&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71815281c0754fe990acff24c0fb1c1b90c930ef" translate="yes" xml:space="preserve">
          <source>Returns and removes the value at the specified &lt;code&gt;index&lt;/code&gt; in the &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; 의 지정된 &lt;code&gt;index&lt;/code&gt; 에서 값을 반환하고 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="ab602893bed93a1e176fdba47312a8d6bb5af3b7" translate="yes" xml:space="preserve">
          <source>Returns environment (for example, &lt;code&gt;:test&lt;/code&gt;, or &lt;code&gt;:prod&lt;/code&gt;), or &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">환경 (예 &lt;code&gt;:test&lt;/code&gt; 또는 &lt;code&gt;:prod&lt;/code&gt; ) 또는 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4b69fcc9982e69bd0bf87f18dd2d92acb6b8e942" translate="yes" xml:space="preserve">
          <source>Returns how many days there are in the given year-month.</source>
          <target state="translated">주어진 연도에 며칠이 있었는지 반환합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
