<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="octave">
    <body>
      <group id="octave">
        <trans-unit id="ca60857029de12f9c31cc854a5ce44b8d04989b5" translate="yes" xml:space="preserve">
          <source>Marker Styles</source>
          <target state="translated">마커 스타일</target>
        </trans-unit>
        <trans-unit id="91a9fe847f9d3f8e6e1991749b1798afe8937446" translate="yes" xml:space="preserve">
          <source>Marker styles are specified by the following properties:</source>
          <target state="translated">마커 스타일은 다음 속성으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="0e811bd456b0870161fbda266461c82767ceb94f" translate="yes" xml:space="preserve">
          <source>Mass matrix, specified as a constant matrix or a function of time and state.</source>
          <target state="translated">질량 행렬로, 상수 행렬 또는 시간과 상태의 함수로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="21179eb842561276594d31f268fd74d4b7e421a5" translate="yes" xml:space="preserve">
          <source>Match &lt;var&gt;n&lt;/var&gt; or more times</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt; 번 이상 일치</target>
        </trans-unit>
        <trans-unit id="a8cbfd288a608a223d26e492ce0d179fd9f8a695" translate="yes" xml:space="preserve">
          <source>Match any character</source>
          <target state="translated">어떤 캐릭터와도 일치</target>
        </trans-unit>
        <trans-unit id="c840c66f2af3440ba0b64092dda1e2eb30b34076" translate="yes" xml:space="preserve">
          <source>Match any digit</source>
          <target state="translated">모든 숫자와 일치</target>
        </trans-unit>
        <trans-unit id="151197062086b7309df3fd98af8cb5e49600617c" translate="yes" xml:space="preserve">
          <source>Match any non-digit</source>
          <target state="translated">숫자가 아닌 문자와 일치</target>
        </trans-unit>
        <trans-unit id="3f5d63fc338720a62ba8c32df4a60a4fe5644bfa" translate="yes" xml:space="preserve">
          <source>Match any non-whitespace character</source>
          <target state="translated">공백이 아닌 문자와 일치</target>
        </trans-unit>
        <trans-unit id="746533a7d6414097d912452d04a0d9bf45980f8b" translate="yes" xml:space="preserve">
          <source>Match any non-word character</source>
          <target state="translated">비 단어 문자와 일치</target>
        </trans-unit>
        <trans-unit id="e46ae39742915128672beb91f687a6408aafd980" translate="yes" xml:space="preserve">
          <source>Match any single character.</source>
          <target state="translated">단일 문자와 일치하십시오.</target>
        </trans-unit>
        <trans-unit id="37bf78b3307e15750e359a38d7438608516895bc" translate="yes" xml:space="preserve">
          <source>Match any whitespace character</source>
          <target state="translated">공백 문자와 일치</target>
        </trans-unit>
        <trans-unit id="2c59b464a3783b6d983f2bb2c0a00f55c2684dec" translate="yes" xml:space="preserve">
          <source>Match any word character</source>
          <target state="translated">모든 단어 문자와 일치</target>
        </trans-unit>
        <trans-unit id="23b43cb57568b565bf6891ff4b59d68ed282c995" translate="yes" xml:space="preserve">
          <source>Match between &lt;var&gt;m&lt;/var&gt; and &lt;var&gt;n&lt;/var&gt; times</source>
          <target state="translated">간에 일치 &lt;var&gt;m&lt;/var&gt; 및 &lt;var&gt;n&lt;/var&gt; 은 회</target>
        </trans-unit>
        <trans-unit id="2cbc50325c07e20016f079019203809e2317b69e" translate="yes" xml:space="preserve">
          <source>Match exactly &lt;var&gt;n&lt;/var&gt; times</source>
          <target state="translated">정확히 &lt;var&gt;n&lt;/var&gt; 번 일치</target>
        </trans-unit>
        <trans-unit id="dc66c1063ec618cbd80ef9adb952e0cc553908ef" translate="yes" xml:space="preserve">
          <source>Match one or more times</source>
          <target state="translated">한 번 이상 일치</target>
        </trans-unit>
        <trans-unit id="693e11f000279abd98d382ba2c87bf21b6807c46" translate="yes" xml:space="preserve">
          <source>Match the anchor characters at the beginning and end of the line.</source>
          <target state="translated">줄의 시작과 끝에서 앵커 문자를 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="331fef5e0d249556e9831d696fa486caada19dc5" translate="yes" xml:space="preserve">
          <source>Match the anchor characters at the beginning and end of the string. (default)</source>
          <target state="translated">문자열의 시작과 끝에서 앵커 문자를 일치시킵니다. (기본)</target>
        </trans-unit>
        <trans-unit id="0775cf97dd4db0e5bd646b324d5a2a4e7259450f" translate="yes" xml:space="preserve">
          <source>Match the beginning of a word</source>
          <target state="translated">단어의 시작과 일치</target>
        </trans-unit>
        <trans-unit id="b1ed651216e302766d4931a0da96471372b5e0bf" translate="yes" xml:space="preserve">
          <source>Match the end of a word</source>
          <target state="translated">단어의 끝과 일치</target>
        </trans-unit>
        <trans-unit id="623052ec48f26ff003bea7adfaa7df581ef62384" translate="yes" xml:space="preserve">
          <source>Match the list of characters specified by &lt;var&gt;list&lt;/var&gt;. If the first character is &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt;, match all characters except those specified by &lt;var&gt;list&lt;/var&gt;. For example, the pattern &lt;code&gt;[a-zA-Z]&lt;/code&gt; will match all lower and uppercase alphabetic characters.</source>
          <target state="translated">에 의해 지정된 문자 목록 일치 &lt;var&gt;list&lt;/var&gt; . 첫 번째 문자가 &lt;code&gt;!&lt;/code&gt; 또는 &lt;code&gt;^&lt;/code&gt; , &lt;var&gt;list&lt;/var&gt; 로 지정된 문자를 제외한 모든 문자를 일치시킵니다 . 예를 들어, 패턴 &lt;code&gt;[a-zA-Z]&lt;/code&gt; 는 모든 소문자 및 대문자 알파벳과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d2713b0482cbb41f7e94f58fe0ff1b93b9574444" translate="yes" xml:space="preserve">
          <source>Match the list of characters specified by &lt;var&gt;list&lt;/var&gt;. If the first character is &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt;, match all characters except those specified by &lt;var&gt;list&lt;/var&gt;. For example, the pattern &lt;code&gt;[a-zA-Z]&lt;/code&gt; will match all lowercase and uppercase alphabetic characters.</source>
          <target state="translated">에 의해 지정된 문자 목록 일치 &lt;var&gt;list&lt;/var&gt; . 첫 번째 문자가 &lt;code&gt;!&lt;/code&gt; 또는 &lt;code&gt;^&lt;/code&gt; , &lt;var&gt;list&lt;/var&gt; 로 지정된 문자를 제외한 모든 문자를 일치시킵니다 . 예를 들어, 패턴 &lt;code&gt;[a-zA-Z]&lt;/code&gt; 는 모든 소문자 및 대문자 알파벳 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="91ff07971edeb08c3cdfecf47cdb4cf4fe41cfdd" translate="yes" xml:space="preserve">
          <source>Match within a word</source>
          <target state="translated">단어 내에서 일치</target>
        </trans-unit>
        <trans-unit id="c57bd8410b9f734891b7d82076ebbac9a8e56bb0" translate="yes" xml:space="preserve">
          <source>Match zero or more characters.</source>
          <target state="translated">0 개 이상의 문자를 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="a71e692e2df10ea31ec37f6a3edbd41c0051ab59" translate="yes" xml:space="preserve">
          <source>Match zero or more times</source>
          <target state="translated">0 번 이상 일치</target>
        </trans-unit>
        <trans-unit id="c144083cc612537c40d52f2cfc75eb6ae5cd4347" translate="yes" xml:space="preserve">
          <source>Match zero or one times</source>
          <target state="translated">0 번 또는 1 번 일치</target>
        </trans-unit>
        <trans-unit id="fb175971e4e7f517394474776c23e568499d13c9" translate="yes" xml:space="preserve">
          <source>Match. &lt;code&gt;table(idx(i)) == y(i)&lt;/code&gt; if &lt;code&gt;y(i)&lt;/code&gt; occurs in table; otherwise, &lt;code&gt;idx(i)&lt;/code&gt; is zero.</source>
          <target state="translated">시합. &lt;code&gt;table(idx(i)) == y(i)&lt;/code&gt; &lt;code&gt;y(i)&lt;/code&gt; 가 발생 하면 table (idx (i)) == y (i) ; 그렇지 않으면 &lt;code&gt;idx(i)&lt;/code&gt; 는 0입니다.</target>
        </trans-unit>
        <trans-unit id="223d55a22361b001efd74d1cb162b3faf8191dbe" translate="yes" xml:space="preserve">
          <source>Matches a string containing only non-whitespace characters. See &lt;a href=&quot;string-input-conversions#String-Input-Conversions&quot;&gt;String Input Conversions&lt;/a&gt;.</source>
          <target state="translated">공백이 아닌 문자 만 포함하는 문자열과 일치합니다. &lt;a href=&quot;string-input-conversions#String-Input-Conversions&quot;&gt;문자열 입력 변환을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="186adfae46bbe9d66bd2eaddd44d09a74ed81210" translate="yes" xml:space="preserve">
          <source>Matches a string of one or more characters; the number of characters read is controlled by the maximum field width given for the conversion. See &lt;a href=&quot;string-input-conversions#String-Input-Conversions&quot;&gt;String Input Conversions&lt;/a&gt;.</source>
          <target state="translated">하나 이상의 문자 문자열과 일치합니다. 읽은 문자 수는 변환에 지정된 최대 필드 너비에 의해 제어됩니다. 보다&lt;a href=&quot;string-input-conversions#String-Input-Conversions&quot;&gt;문자열 입력 변환을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="de108c6be394273b3926ced1f8b143c95b6173c2" translate="yes" xml:space="preserve">
          <source>Matches an optionally signed floating-point number. See &lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;Numeric Input Conversions&lt;/a&gt;.</source>
          <target state="translated">선택적으로 부호있는 부동 소수점 숫자와 일치합니다. 보다&lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;숫자 입력 변환을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1eba33e0383f3b3164f86e250ef3758f6b3b52f3" translate="yes" xml:space="preserve">
          <source>Matches an optionally signed integer in any of the formats that the C language defines for specifying an integer constant. See &lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;Numeric Input Conversions&lt;/a&gt;.</source>
          <target state="translated">정수 상수를 지정하기 위해 C 언어가 정의하는 형식으로 선택적으로 부호있는 정수를 찾습니다. 보다&lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;숫자 입력 변환을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa31f35fb0976da587f0ba9cb3c847ca2f8d091c" translate="yes" xml:space="preserve">
          <source>Matches an optionally signed integer written in decimal. See &lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;Numeric Input Conversions&lt;/a&gt;.</source>
          <target state="translated">선택적으로 부호있는 정수를 10 진수로 기록합니다. 보다&lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;숫자 입력 변환을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="199e91e2c732309924052084f3fa7948f9d84b9f" translate="yes" xml:space="preserve">
          <source>Matches an unsigned integer written in decimal radix. See &lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;Numeric Input Conversions&lt;/a&gt;.</source>
          <target state="translated">십진 기수로 작성된 부호없는 정수와 일치합니다. 보다&lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;숫자 입력 변환을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21bcb830fe0f4b09cf477e4db8e22984b7d52b28" translate="yes" xml:space="preserve">
          <source>Matches an unsigned integer written in hexadecimal radix. See &lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;Numeric Input Conversions&lt;/a&gt;.</source>
          <target state="translated">16 진 기수로 작성된 부호없는 정수와 일치합니다. 보다&lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;숫자 입력 변환을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cb6309c4ad104e90181011a0a7891d7ef28a5cc" translate="yes" xml:space="preserve">
          <source>Matches an unsigned integer written in octal radix. See &lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;Numeric Input Conversions&lt;/a&gt;.</source>
          <target state="translated">8 진 기수로 작성된 부호없는 정수와 일치합니다. &lt;a href=&quot;numeric-input-conversions#Numeric-Input-Conversions&quot;&gt;숫자 입력 변환을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff7356c177f3b51b109ef196d5ed5f6ab4cbdb73" translate="yes" xml:space="preserve">
          <source>Mathematical Considerations</source>
          <target state="translated">수학적 고려 사항</target>
        </trans-unit>
        <trans-unit id="bb100702636dc9b5fe68e1530d43e82eb5b763f7" translate="yes" xml:space="preserve">
          <source>Mathematical Constants</source>
          <target state="translated">수학 상수</target>
        </trans-unit>
        <trans-unit id="082c8f6068cb3a4496e061182a266bc16ecb2bf6" translate="yes" xml:space="preserve">
          <source>Mathematical Equations</source>
          <target state="translated">수학 방정식</target>
        </trans-unit>
        <trans-unit id="4e610d978c9a3934fde5a75a8af8a5b99d24d689" translate="yes" xml:space="preserve">
          <source>Mathematical Note:</source>
          <target state="translated">수학 노트 :</target>
        </trans-unit>
        <trans-unit id="b297fd446e50064884a5002ec806e0d82a4dcc8b" translate="yes" xml:space="preserve">
          <source>Mathematically, an identity matrix is both diagonal and permutation matrix. In Octave, &lt;code&gt;eye (n)&lt;/code&gt; returns a diagonal matrix, because a matrix can only have one class. You can convert this diagonal matrix to a permutation matrix by indexing it by an identity permutation, as shown below. This is a special property of the identity matrix; indexing other diagonal matrices generally produces a full matrix.</source>
          <target state="translated">수학적으로, 항등 행렬은 대각선 행렬과 순열 행렬입니다. 옥타브에서 &lt;code&gt;eye (n)&lt;/code&gt; 은 행렬이 하나의 클래스 만 가질 수 있으므로 대각 행렬을 반환합니다. 아래와 같이이 대각 행렬을 ID 순열로 색인화하여 순열 행렬로 변환 할 수 있습니다. 이것은 항등 행렬의 특별한 속성입니다. 다른 대각선 행렬을 인덱싱하면 일반적으로 전체 행렬이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="78cbd3e265e7e07889fc75bca0204d4e0c790ade" translate="yes" xml:space="preserve">
          <source>Matlab-compatible solvers</source>
          <target state="translated">Matlab 호환 솔버</target>
        </trans-unit>
        <trans-unit id="cff7d0ab91ae7cae99d82ea0a8400f0788a6c4ae" translate="yes" xml:space="preserve">
          <source>Matrices</source>
          <target state="translated">Matrices</target>
        </trans-unit>
        <trans-unit id="449609c04cfe553af7942640fa8d66f7747de493" translate="yes" xml:space="preserve">
          <source>Matrices and Arrays in Oct-Files</source>
          <target state="translated">10 월 파일의 행렬 및 배열</target>
        </trans-unit>
        <trans-unit id="422ff3885fe30f822ee5b4ecd4fbb5e4d9713c20" translate="yes" xml:space="preserve">
          <source>Matrix &lt;code&gt;[xf, yf, zf; xb, yb, zb]&lt;/code&gt; which holds the coordinates (in axes data units) of the point over which the mouse pointer was when the mouse button was pressed. If a mouse callback function is defined, &lt;code&gt;currentpoint&lt;/code&gt; holds the pointer coordinates at the time the mouse button was pressed. For 3-D plots, the first row of the returned matrix specifies the point nearest to the current camera position and the second row the furthest point. The two points forms a line which is perpendicular to the screen.</source>
          <target state="translated">매트릭스 &lt;code&gt;[xf, yf, zf; xb, yb, zb]&lt;/code&gt; 는 마우스 버튼을 눌렀을 때 마우스 포인터가 있었던 지점의 좌표 (축 데이터 단위)를 유지합니다. 마우스 콜백 함수가 정의 된 경우 &lt;code&gt;currentpoint&lt;/code&gt; 는 마우스 버튼을 눌렀을 때의 포인터 좌표를 유지합니다. 3 차원 플롯의 경우 반환 된 행렬의 첫 번째 행은 현재 카메라 위치에 가장 가까운 점을 지정하고 두 번째 행은 가장 먼 점을 지정합니다. 두 점은 화면에 수직 인 선을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="6918808379d67565d7976ba5b2f09775df994128" translate="yes" xml:space="preserve">
          <source>Matrix Computations (3rd Ed.)</source>
          <target state="translated">행렬 계산 (3 판)</target>
        </trans-unit>
        <trans-unit id="88f017a6c291a8e817ebad8cb764d6383bbd922c" translate="yes" xml:space="preserve">
          <source>Matrix Computations, 2nd Ed.</source>
          <target state="translated">매트릭스 계산, 2nd Ed.</target>
        </trans-unit>
        <trans-unit id="a2e2934d9d6adaee1ba12b09423ab0a6e374a297" translate="yes" xml:space="preserve">
          <source>Matrix Computations, 2nd edition</source>
          <target state="translated">매트릭스 계산, 2 판</target>
        </trans-unit>
        <trans-unit id="514777a8e49c596fe63b6dadb139ba2af42f8551" translate="yes" xml:space="preserve">
          <source>Matrix Differential Calculus with Applications in Statistics and Econometrics.</source>
          <target state="translated">통계 및 계량 경제학에서의 응용을 이용한 행렬 미분 미적분학.</target>
        </trans-unit>
        <trans-unit id="da4ac3de1ae53d84c3a085cd128907491664d133" translate="yes" xml:space="preserve">
          <source>Matrix Factorizations</source>
          <target state="translated">행렬 분해</target>
        </trans-unit>
        <trans-unit id="4f00cc643a55ff137a85df943134cd0667f824a0" translate="yes" xml:space="preserve">
          <source>Matrix Manipulation</source>
          <target state="translated">매트릭스 조작</target>
        </trans-unit>
        <trans-unit id="203396854a334f741a7a9130f36b7d06929f360d" translate="yes" xml:space="preserve">
          <source>Matrix left division</source>
          <target state="translated">매트릭스 왼쪽 분할</target>
        </trans-unit>
        <trans-unit id="f236c7e88a9ba81d56f84f98b359a6b31c818a95" translate="yes" xml:space="preserve">
          <source>Matrix multiplication</source>
          <target state="translated">행렬 곱셈</target>
        </trans-unit>
        <trans-unit id="b291edbffb27d988151b769c59f11a40ddca7bcc" translate="yes" xml:space="preserve">
          <source>Matrix multiplication. The number of columns of &lt;var&gt;x&lt;/var&gt; must agree with the number of rows of &lt;var&gt;y&lt;/var&gt;.</source>
          <target state="translated">행렬 곱셈. &lt;var&gt;x&lt;/var&gt; 의 열 수는 &lt;var&gt;y&lt;/var&gt; 의 행 수와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c63880344de38a408a4ab9b34069473843485497" translate="yes" xml:space="preserve">
          <source>Matrix objects can be of any size, and can be dynamically reshaped and resized. It is easy to extract individual rows, columns, or submatrices using a variety of powerful indexing features. See &lt;a href=&quot;index-expressions#Index-Expressions&quot;&gt;Index Expressions&lt;/a&gt;.</source>
          <target state="translated">매트릭스 객체의 크기는 다양 할 수 있으며 동적으로 모양을 변경하고 크기를 조정할 수 있습니다. 다양한 강력한 색인 기능을 사용하여 개별 행, 열 또는 하위 행렬을 쉽게 추출 할 수 있습니다. &lt;a href=&quot;index-expressions#Index-Expressions&quot;&gt;인덱스 표현식을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9925a66599504b03dd8e1183e8e9a0fb503961d" translate="yes" xml:space="preserve">
          <source>Matrix power</source>
          <target state="translated">매트릭스 파워</target>
        </trans-unit>
        <trans-unit id="b43ee02210f1201abb21bc1dc4dde802e1cae9ee" translate="yes" xml:space="preserve">
          <source>Matrix right division</source>
          <target state="translated">행렬 오른쪽 나누기</target>
        </trans-unit>
        <trans-unit id="53548fe345a00ba44ed5ba8ce3d525975528fd00" translate="yes" xml:space="preserve">
          <source>Matrix.cc</source>
          <target state="translated">Matrix.cc</target>
        </trans-unit>
        <trans-unit id="7cf8906c6c2d89469415b14e04fe08673c019632" translate="yes" xml:space="preserve">
          <source>MaxFunEvals</source>
          <target state="translated">MaxFunEvals</target>
        </trans-unit>
        <trans-unit id="3e3ce0d007c3fd51877c0db00425afcc67978e44" translate="yes" xml:space="preserve">
          <source>MaxIter</source>
          <target state="translated">MaxIter</target>
        </trans-unit>
        <trans-unit id="8f15c1027f08623d6e530d9b81dae89b9b51b0ba" translate="yes" xml:space="preserve">
          <source>Maximum data size.</source>
          <target state="translated">최대 데이터 크기</target>
        </trans-unit>
        <trans-unit id="94f8402b9e54fff35f9cbea70c648f5bd9ec01e4" translate="yes" xml:space="preserve">
          <source>Maximum number of Jacobian evaluations (default is 6).</source>
          <target state="translated">자 코비안 평가의 최대 수 (기본값은 6).</target>
        </trans-unit>
        <trans-unit id="83c604da874a6990730bbcab3ee0585fec56e4b1" translate="yes" xml:space="preserve">
          <source>Maximum number of Newton iterations (default is 5).</source>
          <target state="translated">최대 뉴턴 반복 횟수 (기본값은 5)입니다.</target>
        </trans-unit>
        <trans-unit id="890099ea689cfa3db2cecd226c83d8577c4c6bdc" translate="yes" xml:space="preserve">
          <source>Maximum number of algorithm iterations before optimization stops. Must be a positive integer.</source>
          <target state="translated">최적화가 중지되기 전의 최대 알고리즘 반복 횟수입니다. 양의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="1d37806971cf03cb1f9020630c346d8ba944aaf7" translate="yes" xml:space="preserve">
          <source>Maximum number of function evaluations before optimization stops. Must be a positive integer.</source>
          <target state="translated">최적화가 중지되기 전의 최대 기능 평가 수입니다. 양의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e6cbff5cb78c44c2c2de2c197b92b7d7142f0c35" translate="yes" xml:space="preserve">
          <source>Maximum number of integration steps to attempt on a single call to the underlying Fortran code.</source>
          <target state="translated">기본 포트란 코드에 대한 단일 호출에서 시도 할 최대 통합 단계 수입니다.</target>
        </trans-unit>
        <trans-unit id="80284b9072691dcb08b05b0fc59da8439feb1f2f" translate="yes" xml:space="preserve">
          <source>Maximum number of iterations reached.</source>
          <target state="translated">최대 반복 횟수에 도달했습니다.</target>
        </trans-unit>
        <trans-unit id="3fcea6ff6580050eb63d7142d23e7d7896de7626" translate="yes" xml:space="preserve">
          <source>Maximum number of iterations.</source>
          <target state="translated">최대 반복 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="1f4573514ec97a5bf66608800837376fb813c815" translate="yes" xml:space="preserve">
          <source>Maximum number of steps allowed (default is 100000).</source>
          <target state="translated">허용되는 최대 단계 수 (기본값은 100000)입니다.</target>
        </trans-unit>
        <trans-unit id="8cabee9949cf7b4333cf68f71446093aa82abc04" translate="yes" xml:space="preserve">
          <source>Maximum number of values of the artificial stepsize parameter to be tried if the &lt;code&gt;&quot;compute consistent initial condition&quot;&lt;/code&gt; option has been set to 1 (default is 5).</source>
          <target state="translated">&lt;code&gt;&quot;compute consistent initial condition&quot;&lt;/code&gt; 옵션이 1 (기본값은 5)로 설정된 경우 시도 할 인공 단계 화 매개 변수의 최대 값 수입니다 .</target>
        </trans-unit>
        <trans-unit id="a5845e6e7cda1dcf7e4f6a54f6e0d6e7e4670ab8" translate="yes" xml:space="preserve">
          <source>Maximum order of formula.</source>
          <target state="translated">수식의 최대 순서.</target>
        </trans-unit>
        <trans-unit id="a3039e679faa6ea13ad3447d25d2053e82aa65ce" translate="yes" xml:space="preserve">
          <source>Maximum time step value.</source>
          <target state="translated">최대 시간 단계 값.</target>
        </trans-unit>
        <trans-unit id="e610f2928fd86da6e640213fad7db9f89aba6d10" translate="yes" xml:space="preserve">
          <source>May be one of</source>
          <target state="translated">다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="754ffd2f9269e6eb5ae888826998ad41fc0f286e" translate="yes" xml:space="preserve">
          <source>Measure elapsed time on a wall-clock timer.</source>
          <target state="translated">벽시계 타이머의 경과 시간을 측정합니다.</target>
        </trans-unit>
        <trans-unit id="c1c4076a197db33d974e23b7a48a2b0448b3b77a" translate="yes" xml:space="preserve">
          <source>Medium accuracy (1e-6 &amp;ndash; 1e-9) with smooth integrands.</source>
          <target state="translated">부드러운 정수로 중간 정확도 (1e-6 &amp;ndash; 1e-9).</target>
        </trans-unit>
        <trans-unit id="b93a8c7df926c952166299ed35057e9017664fe4" translate="yes" xml:space="preserve">
          <source>Medium accuracy with smooth integrands</source>
          <target state="translated">부드러운 정수로 중간 정도의 정확도</target>
        </trans-unit>
        <trans-unit id="6c8497d782d1b74ddf390d2ca5b79643d12f078d" translate="yes" xml:space="preserve">
          <source>Medium accuracy with smooth integrands. Slower than quadgk.</source>
          <target state="translated">부드러운 정수로 중간 정도의 정확도. quadgk보다 느립니다.</target>
        </trans-unit>
        <trans-unit id="33520ae75f0c1f9b00ea16d8c3bb31811c1ab19e" translate="yes" xml:space="preserve">
          <source>Merge elements of &lt;var&gt;true_val&lt;/var&gt; and &lt;var&gt;false_val&lt;/var&gt;, depending on the value of &lt;var&gt;mask&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;mask&lt;/var&gt; 값에 따라 &lt;var&gt;true_val&lt;/var&gt; 및 &lt;var&gt;false_val&lt;/var&gt; 요소를 병합하십시오 .</target>
        </trans-unit>
        <trans-unit id="6013b165835c50b25c935b3da50fbec071436eb6" translate="yes" xml:space="preserve">
          <source>Mersenne Twister: A 623-dimensionally equidistributed uniform pseudorandom number generator</source>
          <target state="translated">Mersenne Twister : 623 차원으로 균일하게 분포 된 균일 한 의사 난수 생성기</target>
        </trans-unit>
        <trans-unit id="cd7ffd91b88ce75181ccb55a1fc783213775b802" translate="yes" xml:space="preserve">
          <source>Message-Digest Algorithm 2 (RFC 1319).</source>
          <target state="translated">메시지 요약 알고리즘 2 (RFC 1319).</target>
        </trans-unit>
        <trans-unit id="d18ff66d792317486b2538f262321cd23a51f43c" translate="yes" xml:space="preserve">
          <source>Message-Digest Algorithm 4 (RFC 1320).</source>
          <target state="translated">메시지 요약 알고리즘 4 (RFC 1320).</target>
        </trans-unit>
        <trans-unit id="571cf5f53a9233a59cc134c2c5d5ee97194cb62c" translate="yes" xml:space="preserve">
          <source>Message-Digest Algorithm 5 (RFC 1321).</source>
          <target state="translated">메시지 요약 알고리즘 5 (RFC 1321).</target>
        </trans-unit>
        <trans-unit id="ef033a131d7fc5bbea1c59e0a7573b49b52dca18" translate="yes" xml:space="preserve">
          <source>Meta-u</source>
          <target state="translated">Meta-u</target>
        </trans-unit>
        <trans-unit id="b99cd12eda7ca6fb6096c748d26bf3cc863e7740" translate="yes" xml:space="preserve">
          <source>Metafont</source>
          <target state="translated">Metafont</target>
        </trans-unit>
        <trans-unit id="88306943fea7e76f9cd57cae0ea6d8b32d2e8434" translate="yes" xml:space="preserve">
          <source>Method</source>
          <target state="translated">Method</target>
        </trans-unit>
        <trans-unit id="1e5053f31038b448af928216638c113bc9637ffa" translate="yes" xml:space="preserve">
          <source>Method 1: Inverse of empirical distribution function.</source>
          <target state="translated">방법 1 : 경험적 분포 함수의 역함.</target>
        </trans-unit>
        <trans-unit id="4241d55ad52d2c0a46dd2482311eca2c8fd9725f" translate="yes" xml:space="preserve">
          <source>Method 2: Similar to method 1 but with averaging at discontinuities.</source>
          <target state="translated">방법 2 : 방법 1과 유사하지만 불연속성이 평균입니다.</target>
        </trans-unit>
        <trans-unit id="67504c9c150b55ec9b21e8c64cd30af350d1f395" translate="yes" xml:space="preserve">
          <source>Method 3: SAS definition: nearest even order statistic.</source>
          <target state="translated">방법 3 : SAS 정의 : 가장 가까운 짝수 주문 통계.</target>
        </trans-unit>
        <trans-unit id="e1f57266d96317adef94812c9e31ee7896619996" translate="yes" xml:space="preserve">
          <source>Method 4: &lt;var&gt;p&lt;/var&gt;(k) = k / N. That is, linear interpolation of the empirical cdf, where &lt;em&gt;N&lt;/em&gt; is the length of &lt;var&gt;P&lt;/var&gt;.</source>
          <target state="translated">방법 4 : &lt;var&gt;p&lt;/var&gt; (k) = k / N. 즉 경험적 cdf의 선형 보간. 여기서 &lt;em&gt;N&lt;/em&gt; 은 &lt;var&gt;P&lt;/var&gt; 의 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="2debfda8cf0c98f061643252ae4448ecef810baf" translate="yes" xml:space="preserve">
          <source>Method 5: &lt;var&gt;p&lt;/var&gt;(k) = (k - 0.5) / N. That is, a piecewise linear function where the knots are the values midway through the steps of the empirical cdf.</source>
          <target state="translated">방법 5 : &lt;var&gt;p&lt;/var&gt; (k) = (k-0.5) / N. 즉, 매듭이 경험적 cdf 단계의 중간 값인 부분 선형 함수.</target>
        </trans-unit>
        <trans-unit id="8eb217a3fcd7502eb577710527708537cd4ce4ac" translate="yes" xml:space="preserve">
          <source>Method 6: &lt;var&gt;p&lt;/var&gt;(k) = k / (N + 1).</source>
          <target state="translated">방법 6 : &lt;var&gt;p&lt;/var&gt; (k) = k / (N + 1).</target>
        </trans-unit>
        <trans-unit id="402d8ca279ac0b276951aad35d7c66aa2515ebf8" translate="yes" xml:space="preserve">
          <source>Method 7: &lt;var&gt;p&lt;/var&gt;(k) = (k - 1) / (N - 1).</source>
          <target state="translated">방법 7 : &lt;var&gt;p&lt;/var&gt; (k) = (k-1) / (N-1).</target>
        </trans-unit>
        <trans-unit id="5cc2da44954a565527a6043e19935b4ee5d7d783" translate="yes" xml:space="preserve">
          <source>Method 8: &lt;var&gt;p&lt;/var&gt;(k) = (k - 1/3) / (N + 1/3). The resulting quantile estimates are approximately median-unbiased regardless of the distribution of &lt;var&gt;x&lt;/var&gt;.</source>
          <target state="translated">방법 8 : &lt;var&gt;p&lt;/var&gt; (k) = (k-1/3) / (N + 1/3). 결과 Quantile 추정값은 &lt;var&gt;x&lt;/var&gt; 의 분포에 관계없이 대략 중앙값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="fc0f027563268050f87975b3bc243a507bb46ea6" translate="yes" xml:space="preserve">
          <source>Method 9: &lt;var&gt;p&lt;/var&gt;(k) = (k - 3/8) / (N + 1/4). The resulting quantile estimates are approximately unbiased for the expected order statistics if &lt;var&gt;x&lt;/var&gt; is normally distributed.</source>
          <target state="translated">방법 9 : &lt;var&gt;p&lt;/var&gt; (k) = (k-3/8) / (N + 1/4). &lt;var&gt;x&lt;/var&gt; 가 정규 분포 를 따르는 경우 결과 Quantile 추정값은 예상 주문 통계에 대해 거의 편향되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77e14ed46b33afe368780bd973786d92dabaa2b4" translate="yes" xml:space="preserve">
          <source>Method of a class to manipulate an object after loading it from a file.</source>
          <target state="translated">파일에서 객체를로드 한 후 조작하는 클래스의 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="e9e642fd7b56363edc98cc7a00c6cc346da61f6d" translate="yes" xml:space="preserve">
          <source>Method of a class to manipulate an object prior to saving it to a file.</source>
          <target state="translated">객체를 파일로 저장하기 전에 조작하는 클래스의 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="cc25c745d77ace7d1cffb4c351a36bb8a84c67a6" translate="yes" xml:space="preserve">
          <source>Method:</source>
          <target state="translated">Method:</target>
        </trans-unit>
        <trans-unit id="b97bf44087d41a627bf10d134ace8f3faada92b9" translate="yes" xml:space="preserve">
          <source>Method: T&amp;amp; elem (octave_idx_type)</source>
          <target state="translated">방법 : T &amp;amp; elem (octave_idx_type)</target>
        </trans-unit>
        <trans-unit id="98106616aa83c629bd6bcaf02f3dd0722a032db3" translate="yes" xml:space="preserve">
          <source>Method: T&amp;amp; operator () (octave_idx_type)</source>
          <target state="translated">방법 : T &amp;amp; 연산자 () (octave_idx_type)</target>
        </trans-unit>
        <trans-unit id="8fc693119bc3fe0f4700d6d8df3f7cda5998d806" translate="yes" xml:space="preserve">
          <source>Method: T* fortran_vec (void)</source>
          <target state="translated">방법 : T * fortran_vec (void)</target>
        </trans-unit>
        <trans-unit id="6b618903f4455202f1d1a5c2ba88f1d1e6c83972" translate="yes" xml:space="preserve">
          <source>Method: dim_vector dims (void) const</source>
          <target state="translated">방법 : dim_vector dims (void) const</target>
        </trans-unit>
        <trans-unit id="7d0d1969dc835d0def49f9e4e3fc7f09e0166163" translate="yes" xml:space="preserve">
          <source>Method: int ndims (void) const</source>
          <target state="translated">메소드 : int ndims (void) const</target>
        </trans-unit>
        <trans-unit id="bf943e73d7935cafcf688378efa09ccfe2790f51" translate="yes" xml:space="preserve">
          <source>Method: octave_idx_type numel (void) const</source>
          <target state="translated">방법 : octave_idx_type numel (void) const</target>
        </trans-unit>
        <trans-unit id="5b9e5c377b1d4aab4e051027f532dc9d97022f53" translate="yes" xml:space="preserve">
          <source>Method: size_t byte_size (void) const</source>
          <target state="translated">메소드 : size_t byte_size (void) const</target>
        </trans-unit>
        <trans-unit id="8d3389c26ac3557deb24bc299c82387cc74acdd1" translate="yes" xml:space="preserve">
          <source>Method: void resize (const dim_vector&amp;amp;)</source>
          <target state="translated">메소드 : void resize (const dim_vector &amp;amp;)</target>
        </trans-unit>
        <trans-unit id="da30289989397b5c1238f7d1576566c9de60ba1a" translate="yes" xml:space="preserve">
          <source>Method: void resize (nrows, ncols)</source>
          <target state="translated">방법 : void 크기 조정 (nrows, ncols)</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="384747e7e61f812c7640d6db88e88ac13fcf14b1" translate="yes" xml:space="preserve">
          <source>Methods are defined by m-files in the class directory and can have embedded documentation the same as any other m-file. The help for the constructor can be obtained by using the constructor name alone, that is, for the polynomial constructor &lt;code&gt;help polynomial&lt;/code&gt; will return the help string. Help can be restricted to a particular class by using the class directory name followed by the method. For example, &lt;code&gt;help @polynomial/polynomial&lt;/code&gt; is another way of displaying the help string for the polynomial constructor. This second means is the only way to obtain help for the overloaded methods and functions of a class.</source>
          <target state="translated">메소드는 클래스 디렉토리의 m 파일에 의해 정의되며 다른 m 파일과 동일한 문서를 내장 할 수 있습니다. 생성자 이름 만 사용하여 생성자에 대한 도움말을 얻을 수 있습니다. 즉, 다항식 생성자의 경우 &lt;code&gt;help polynomial&lt;/code&gt; 은 도움말 문자열을 반환합니다. 클래스 디렉토리 이름과 메소드를 사용하여 특정 클래스로 도움말을 제한 할 수 있습니다. 예를 들어 &lt;code&gt;help @polynomial/polynomial&lt;/code&gt; 은 다항식 생성자에 대한 도움말 문자열을 표시하는 또 다른 방법입니다. 이 두 번째 방법은 클래스의 오버로드 된 메소드 및 함수에 대한 도움말을 얻는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ecb53c3298ed4b301d5ba142dd8d8f038447597f" translate="yes" xml:space="preserve">
          <source>Mex-Files</source>
          <target state="translated">Mex-Files</target>
        </trans-unit>
        <trans-unit id="f9749c87ae4e0b201ec7f5c196384e38e10dafa2" translate="yes" xml:space="preserve">
          <source>Microseconds after the second (0-999999).</source>
          <target state="translated">초 후 마이크로 초 (0-999999).</target>
        </trans-unit>
        <trans-unit id="be274f51974de8703c2cf85b3742ef619e86e7ae" translate="yes" xml:space="preserve">
          <source>Microsoft Enhanced Metafile</source>
          <target state="translated">Microsoft Enhanced Metafile</target>
        </trans-unit>
        <trans-unit id="b0222f2a9bad0d7911b66bd31221c8eaf87b18ff" translate="yes" xml:space="preserve">
          <source>Milliseconds of second (padded with zeros)</source>
          <target state="translated">밀리 초 (0으로 채워짐)</target>
        </trans-unit>
        <trans-unit id="a0c3e23c34a0e3cd91446c5ef02171d3622bab34" translate="yes" xml:space="preserve">
          <source>Minimize &lt;code&gt;1/2*&lt;var&gt;x&lt;/var&gt;'*&lt;var&gt;c&lt;/var&gt;*&lt;var&gt;x&lt;/var&gt; + &lt;var&gt;d&lt;/var&gt;'*&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; subject to &lt;code&gt;&lt;var&gt;x&lt;/var&gt; &amp;gt;= 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;x&lt;/var&gt; &amp;gt;= 0&lt;/code&gt; &amp;gt; = 0에 따라 &lt;code&gt;1/2*&lt;var&gt;x&lt;/var&gt;'*&lt;var&gt;c&lt;/var&gt;*&lt;var&gt;x&lt;/var&gt; + &lt;var&gt;d&lt;/var&gt;'*&lt;var&gt;x&lt;/var&gt;&lt;/code&gt; 최소화하십시오 .</target>
        </trans-unit>
        <trans-unit id="48d16e077a07dbf3831b71949e6a6307b29742b5" translate="yes" xml:space="preserve">
          <source>Minimize &lt;code&gt;norm (&lt;var&gt;c&lt;/var&gt;*&lt;var&gt;x&lt;/var&gt; - &lt;var&gt;d&lt;/var&gt;)&lt;/code&gt; subject to &lt;code&gt;&lt;var&gt;x&lt;/var&gt; &amp;gt;= 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;var&gt;x&lt;/var&gt; &amp;gt;= 0&lt;/code&gt; &amp;gt; = 0에 따라 &lt;code&gt;norm (&lt;var&gt;c&lt;/var&gt;*&lt;var&gt;x&lt;/var&gt; - &lt;var&gt;d&lt;/var&gt;)&lt;/code&gt; 최소화하십시오 .</target>
        </trans-unit>
        <trans-unit id="461fb348c1c324884ebb7417f1563e30c2312fce" translate="yes" xml:space="preserve">
          <source>Minimize an objective function using sequential quadratic programming (SQP).</source>
          <target state="translated">순차 2 차 프로그래밍 (SQP)을 사용하여 목적 함수를 최소화하십시오.</target>
        </trans-unit>
        <trans-unit id="f1f13893991ee29d1b5d51a5cc35dfc8e613b0b7" translate="yes" xml:space="preserve">
          <source>Minimizers</source>
          <target state="translated">Minimizers</target>
        </trans-unit>
        <trans-unit id="50e6cfe93760a1933e29d988fe7ca021c37fe299" translate="yes" xml:space="preserve">
          <source>Minimum scaled step in linesearch algorithm (default is eps^(2/3)).</source>
          <target state="translated">라인 검색 알고리즘의 최소 스케일 단계 (기본값은 eps ^ (2/3))</target>
        </trans-unit>
        <trans-unit id="cb879eac977355045f51f16338cac5762308170f" translate="yes" xml:space="preserve">
          <source>Minute (00-59).</source>
          <target state="translated">분 (00-59).</target>
        </trans-unit>
        <trans-unit id="a906dd5a3364dcc3ccea6d5ff13962d684a2c147" translate="yes" xml:space="preserve">
          <source>Minute of hour (padded with zeros)</source>
          <target state="translated">분 (0으로 채워짐)</target>
        </trans-unit>
        <trans-unit id="099eed5035c86642e057ee264ea441ff256af3b3" translate="yes" xml:space="preserve">
          <source>Minutes after the hour (0-59).</source>
          <target state="translated">시간 후 분 (0-59).</target>
        </trans-unit>
        <trans-unit id="91a916c5ec4a5db582ba50bcb8f59b41a0add6d3" translate="yes" xml:space="preserve">
          <source>Misc Symbols Type Ord</source>
          <target state="translated">기타 기호 유형 Ord</target>
        </trans-unit>
        <trans-unit id="319c19b9e813f94557eb26c26b7b4388bfdc0145" translate="yes" xml:space="preserve">
          <source>Miscellaneous Functions</source>
          <target state="translated">기타 기능</target>
        </trans-unit>
        <trans-unit id="d481b51bec2b2cba223f8cce238d5312b36a6dd5" translate="yes" xml:space="preserve">
          <source>Miscellaneous Techniques</source>
          <target state="translated">기타 기법</target>
        </trans-unit>
        <trans-unit id="5957b6ad8581736101c715316c4e67e7f212fe57" translate="yes" xml:space="preserve">
          <source>Miscellaneous matrix manipulations, like &lt;code&gt;flipud&lt;/code&gt;, &lt;code&gt;rot90&lt;/code&gt;, and &lt;code&gt;triu&lt;/code&gt;, as well as other basic functions, like &lt;code&gt;ismatrix&lt;/code&gt;, &lt;code&gt;narginchk&lt;/code&gt;, etc.</source>
          <target state="translated">같은 기타 행렬 조작, &lt;code&gt;flipud&lt;/code&gt; , &lt;code&gt;rot90&lt;/code&gt; 및 &lt;code&gt;triu&lt;/code&gt; 등과 기타 기본적인 기능 &lt;code&gt;ismatrix&lt;/code&gt; , &lt;code&gt;narginchk&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="082d0468f805408a80fa379ae325506920c80bb1" translate="yes" xml:space="preserve">
          <source>Miscellaneous string-handling functions.</source>
          <target state="translated">기타 문자열 처리 기능</target>
        </trans-unit>
        <trans-unit id="69aa5db4d8836546944b291814b1eee49b5a3b5d" translate="yes" xml:space="preserve">
          <source>Miscellaneous:</source>
          <target state="translated">Miscellaneous:</target>
        </trans-unit>
        <trans-unit id="56ddc5ad1b20569eb06f4afc4005e3ec95401542" translate="yes" xml:space="preserve">
          <source>Missing Components</source>
          <target state="translated">누락 된 구성 요소</target>
        </trans-unit>
        <trans-unit id="f9b302a6528230e8fad06287d3026dae18ccadf3" translate="yes" xml:space="preserve">
          <source>Missing Data</source>
          <target state="translated">누락 된 데이터</target>
        </trans-unit>
        <trans-unit id="1bfa6da4f5047a02ef7c654cff8a76f30501b384" translate="yes" xml:space="preserve">
          <source>Mixed Operation</source>
          <target state="translated">혼합 작업</target>
        </trans-unit>
        <trans-unit id="68c2cc7f0ceaa3e499ecb4db331feb4debbbcc23" translate="yes" xml:space="preserve">
          <source>Model</source>
          <target state="translated">Model</target>
        </trans-unit>
        <trans-unit id="081ef363b2b4a569322b8b235ce701231389272a" translate="yes" xml:space="preserve">
          <source>Modified incomplete Cholesky factorization:</source>
          <target state="translated">불완전한 Cholesky 인수 분해 수정 :</target>
        </trans-unit>
        <trans-unit id="5348887913f1cc632ccdcc744dcb6d004a5feccf" translate="yes" xml:space="preserve">
          <source>Modified incomplete LU factorization:</source>
          <target state="translated">불완전한 LU 인수 분해 수정 :</target>
        </trans-unit>
        <trans-unit id="bf8830a644c041a48c972525149c0430d046a4c5" translate="yes" xml:space="preserve">
          <source>Modify or display Octave&amp;rsquo;s load path.</source>
          <target state="translated">옥타브의로드 경로를 수정하거나 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e0c1bb7420132c1632f35145ba816f6febf2d697" translate="yes" xml:space="preserve">
          <source>Modifying the up vector does not modify the camera target (see &lt;a href=&quot;#XREFcamtarget&quot;&gt;camtarget&lt;/a&gt;). Thus, the camera up vector might not be orthogonal to the direction of the camera&amp;rsquo;s view:</source>
          <target state="translated">위쪽 벡터를 수정해도 카메라 대상은 수정되지 않습니다 ( &lt;a href=&quot;#XREFcamtarget&quot;&gt;camtarget&lt;/a&gt; 참조 ). 따라서 카메라 업 벡터는 카메라 시야 방향과 직교하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24b2a0993d0cfa93c44282d6bba72bcf58b300d6" translate="yes" xml:space="preserve">
          <source>Mon</source>
          <target state="translated">Mon</target>
        </trans-unit>
        <trans-unit id="932eeb1076c85e522f02e15441fa371e3fd000ac" translate="yes" xml:space="preserve">
          <source>Monday</source>
          <target state="translated">Monday</target>
        </trans-unit>
        <trans-unit id="74d53341ebf27a7b0b9e9c586694994119dc4670" translate="yes" xml:space="preserve">
          <source>Month (01-12).</source>
          <target state="translated">월 (01-12).</target>
        </trans-unit>
        <trans-unit id="62766b7ed2c391a5680e3378b34574e2c1d08694" translate="yes" xml:space="preserve">
          <source>Months below 1 are considered to be January.</source>
          <target state="translated">1 미만의 월은 1 월로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="efcfb5e0e3b0751f0daec55c68728ef6139d87e6" translate="yes" xml:space="preserve">
          <source>Months since January (0-11).</source>
          <target state="translated">1 월 이후의 달 (0-11).</target>
        </trans-unit>
        <trans-unit id="48a97d04c0198c13af3f28b6b88da3be965f53d6" translate="yes" xml:space="preserve">
          <source>More &lt;var&gt;R_j&lt;/var&gt; may be specified than the number of dimensions of &lt;var&gt;x&lt;/var&gt;. Any excess &lt;var&gt;R_j&lt;/var&gt; must be scalars (because &lt;var&gt;x&lt;/var&gt;&amp;rsquo;s size in those dimensions is only 1), and &lt;var&gt;x&lt;/var&gt; will be replicated in those dimensions accordingly.</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt; 의 차원 수보다 많은 &lt;var&gt;R_j&lt;/var&gt; 를 지정할 수 있습니다 . 초과 &lt;var&gt;R_j&lt;/var&gt; 는 스칼라 여야합니다 ( 해당 차원의 &lt;var&gt;x&lt;/var&gt; 크기는 1에 불과 하므로 ). &lt;var&gt;x&lt;/var&gt; 는 그에 따라 해당 차원에서 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="55f051b536602262bcce45c433910afff6dc065b" translate="yes" xml:space="preserve">
          <source>More complex constraints may be added as well. For example, the code below illustrates a periodic fit with values that have been clamped at the endpoints, and a second periodic fit which is hinged at the endpoints.</source>
          <target state="translated">더 복잡한 구속 조건도 추가 될 수 있습니다. 예를 들어, 아래 코드는 끝점에 고정 된 값을 사용하는주기적인 맞춤과 끝점에 힌지가있는 두 번째 주기적 맞춤을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="754bbd6d917505e0487bb8bfca83939b74396492" translate="yes" xml:space="preserve">
          <source>More generally,</source>
          <target state="translated">더 일반적으로,</target>
        </trans-unit>
        <trans-unit id="4803c40a959d7beb1584a037b589ffd5e7bdc202" translate="yes" xml:space="preserve">
          <source>More precisely, &lt;code&gt;eps&lt;/code&gt; is the relative spacing between any two adjacent numbers in the machine&amp;rsquo;s floating point system. This number is obviously system dependent. On machines that support IEEE floating point arithmetic, &lt;code&gt;eps&lt;/code&gt; is approximately 2.2204e-16 for double precision and 1.1921e-07 for single precision.</source>
          <target state="translated">보다 정확하게 말하면 &lt;code&gt;eps&lt;/code&gt; 는 기계의 부동 소수점 시스템에서 인접한 두 숫자 사이의 상대적 간격입니다. 이 숫자는 분명히 시스템에 따라 다릅니다. IEEE 부동 소수점 산술을 지원하는 시스템에서 &lt;code&gt;eps&lt;/code&gt; 는 배정 밀도의 경우 약 2.2204e-16이고 단 정밀도의 경우 1.1921e-07입니다.</target>
        </trans-unit>
        <trans-unit id="102ca545bf54bb9420ae80dfbdfbd829222a6d84" translate="yes" xml:space="preserve">
          <source>More realistically, all of the functions that operate on strings can be used to build the correct field name before it is entered into the data structure.</source>
          <target state="translated">보다 현실적으로, 문자열에서 작동하는 모든 함수는 데이터 구조에 입력되기 전에 올바른 필드 이름을 작성하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a037caba04aff4d4a26c59fa2a974c53fe2718a" translate="yes" xml:space="preserve">
          <source>More sophisticated user interaction mechanisms can be obtained using the ui* family of functions, see &lt;a href=&quot;ui-elements#UI-Elements&quot;&gt;UI Elements&lt;/a&gt;.</source>
          <target state="translated">보다 정교한 사용자 상호 작용 메커니즘은 ui * 함수 계열을 사용하여 얻을 수 있습니다 ( &lt;a href=&quot;ui-elements#UI-Elements&quot;&gt;UI 요소&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="3165c40460d25693c1dd7b0f0fddf03923935e21" translate="yes" xml:space="preserve">
          <source>More that one such class can be specified in a single call. This function may &lt;em&gt;only&lt;/em&gt; be called from a class constructor.</source>
          <target state="translated">한 번의 호출로 하나 이상의 이러한 클래스를 지정할 수 있습니다. 이 함수는 클래스 생성자 &lt;em&gt;에서만&lt;/em&gt; 호출 할 &lt;em&gt;수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd6707e5647be904edea9eb961149fbcec8d0050" translate="yes" xml:space="preserve">
          <source>Most Octave functions are written with vector and array arguments in mind. If you find yourself writing a loop with a very simple operation, chances are that such a function already exists. The following functions occur frequently in vectorized code:</source>
          <target state="translated">대부분의 Octave 함수는 벡터 및 배열 인수를 염두에두고 작성되었습니다. 매우 간단한 조작으로 루프를 작성하면 그러한 기능이 이미 존재할 가능성이 있습니다. 벡터화 된 코드에서 다음 기능이 자주 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0bf261148c83185447937821e5bde1628605666e" translate="yes" xml:space="preserve">
          <source>Most fractional variable.</source>
          <target state="translated">대부분의 분수 변수.</target>
        </trans-unit>
        <trans-unit id="96fdd53d40f764499dd3abc499539a9aae056873" translate="yes" xml:space="preserve">
          <source>Most indexing expressions do not live longer than their parent objects. In rare cases, however, a lazily copied slice outlasts its parent, in which case it becomes orphaned, still occupying unnecessarily more memory than needed. To provide a remedy working in most real cases, Octave checks for orphaned lazy slices at certain situations, when a value is stored into a &quot;permanent&quot; location, such as a named variable or cell or struct element, and possibly economizes them. For example:</source>
          <target state="translated">대부분의 인덱싱 표현식은 부모 개체보다 오래 살지 않습니다. 그러나 드문 경우지만 느리게 복사 된 슬라이스는 부모보다 오래 지속되며,이 경우 고아가되어 여전히 필요한 것보다 더 많은 메모리를 차지합니다. 대부분의 실제 상황에서 해결 방법을 제공하기 위해 Octave는 값이 명명 된 변수 또는 셀 또는 구조체 요소와 같은 &quot;영구적&quot;위치에 저장되어 있고 경제적 인 경우 특정 상황에서 고아 지연 슬라이스를 확인합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e1837ed07b0adef845b49316a1479e7f76fbb7a" translate="yes" xml:space="preserve">
          <source>Most of the remaining functions described in this section are not patterned after the standard C library. Some are available for compatibility with &lt;small&gt;MATLAB&lt;/small&gt; and others are provided because they are useful.</source>
          <target state="translated">이 섹션에 설명 된 나머지 기능은 대부분 표준 C 라이브러리 이후에 패턴 화되지 않습니다. 일부는 &lt;small&gt;MATLAB&lt;/small&gt; 과의 호환성을 위해 사용 가능 하고 다른 일부는 유용하기 때문에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="62a0194886176cd72d6007287aa1263d322aab30" translate="yes" xml:space="preserve">
          <source>Most of the same operators and functions for sparse matrices that are available from the Octave interpreter are also available within oct-files. The basic means of extracting a sparse matrix from an &lt;code&gt;octave_value&lt;/code&gt;, and returning it as an &lt;code&gt;octave_value&lt;/code&gt;, can be seen in the following example.</source>
          <target state="translated">옥타브 인터프리터에서 사용할 수있는 희소 행렬에 대한 대부분의 동일한 연산자와 함수는 oct 파일 내에서도 사용할 수 있습니다. 로부터 희소 행렬을 추출하는 기본적인 수단 &lt;code&gt;octave_value&lt;/code&gt; 및로 복귀 &lt;code&gt;octave_value&lt;/code&gt; 는 다음 예에서 알 수있다.</target>
        </trans-unit>
        <trans-unit id="9cc6cffa4096cc4c8425f60ce56d2c3ffa2c5548" translate="yes" xml:space="preserve">
          <source>Most operators (addition, concatenation, and so on) have no effect except to compute a value. If you ignore the value, you might as well not use the operator. An assignment operator is different. It does produce a value, but even if you ignore the value, the assignment still makes itself felt through the alteration of the variable. We call this a &lt;em&gt;side effect&lt;/em&gt;.</source>
          <target state="translated">대부분의 연산자 (더하기, 연결 등)는 값을 계산하는 것 외에는 아무런 영향을 미치지 않습니다. 값을 무시하면 연산자를 사용하지 않을 수도 있습니다. 할당 연산자가 다릅니다. 값을 생성하지만 값을 무시하더라도 할당은 변수의 변경을 통해 여전히 느껴집니다. 우리는 이것을 &lt;em&gt;부작용&lt;/em&gt; 이라고 부릅니다 .</target>
        </trans-unit>
        <trans-unit id="a9186e739eec375e8b772859ab85a97440b4125c" translate="yes" xml:space="preserve">
          <source>Mouse click events: &lt;code&gt;evt&lt;/code&gt; is a class &lt;code&gt;double&lt;/code&gt; value: 1 for left, 2 for middle, and 3 for right click.</source>
          <target state="translated">마우스 클릭 이벤트 : &lt;code&gt;evt&lt;/code&gt; 는 클래스 &lt;code&gt;double&lt;/code&gt; 값입니다. 왼쪽은 1, 가운데는 2, 오른쪽 클릭은 3입니다.</target>
        </trans-unit>
        <trans-unit id="cca622d465d11d8a5431e5dd0f0cfbe01d410767" translate="yes" xml:space="preserve">
          <source>Move &amp;lsquo;down&amp;rsquo; through the history list.</source>
          <target state="translated">히스토리 목록에서 '아래로'이동하십시오.</target>
        </trans-unit>
        <trans-unit id="f35df2487f0c4f4b174fc091ed9cd896679d8816" translate="yes" xml:space="preserve">
          <source>Move &amp;lsquo;up&amp;rsquo; through the history list.</source>
          <target state="translated">히스토리 목록에서 '위로'이동하십시오.</target>
        </trans-unit>
        <trans-unit id="fcb7ea50eacbfbafbbf342f2615fca27b76796a3" translate="yes" xml:space="preserve">
          <source>Move a figure specified by figure handle &lt;var&gt;h&lt;/var&gt; to a position on the screen defined by &lt;var&gt;pos&lt;/var&gt;.</source>
          <target state="translated">그림 핸들 &lt;var&gt;h&lt;/var&gt; 로 지정된 그림 을 &lt;var&gt;pos&lt;/var&gt; 로 정의 된 화면의 위치로 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="f03abbd943590e5b676ac24ffec0cb3457a839fb" translate="yes" xml:space="preserve">
          <source>Move back one character.</source>
          <target state="translated">한 문자 뒤로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="4b202f08f962725726cf136388f4e14e523a12a8" translate="yes" xml:space="preserve">
          <source>Move backward a word.</source>
          <target state="translated">한 단어 뒤로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="754d167675ac90bee540cc59026b7aa3fd43d8b6" translate="yes" xml:space="preserve">
          <source>Move forward a word.</source>
          <target state="translated">단어를 앞으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="9b8cd052c7c7c6b3baf215b9ba57515984535bce" translate="yes" xml:space="preserve">
          <source>Move forward one character.</source>
          <target state="translated">한 문자 앞으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="ecf018bcb16a54697edfab272e407ec8e95e073e" translate="yes" xml:space="preserve">
          <source>Move the camera &lt;var&gt;phi&lt;/var&gt; degrees up and &lt;var&gt;theta&lt;/var&gt; degrees to the right, as if it were in an orbit around its target. Example:</source>
          <target state="translated">마치 카메라를 대상 주위의 궤도에있는 것처럼 카메라 &lt;var&gt;phi&lt;/var&gt; 도를 위로, &lt;var&gt;theta&lt;/var&gt; 도를 오른쪽으로 이동하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="f19af0a930df6e6a8c874bddce91630dcb05b1cd" translate="yes" xml:space="preserve">
          <source>Move the camera and adjust its properties to look at objects.</source>
          <target state="translated">카메라를 움직이고 속성을 조정하여 물체를 봅니다.</target>
        </trans-unit>
        <trans-unit id="ab49f460987dc68a09db402a436a805213621056" translate="yes" xml:space="preserve">
          <source>Move the file pointer to the beginning of the file specified by file descriptor &lt;var&gt;fid&lt;/var&gt;.</source>
          <target state="translated">파일 디스크립터 &lt;var&gt;fid&lt;/var&gt; 로 지정된 파일의 시작 부분으로 파일 포인터를 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5e996f5d7888265eda971ccf52c60b93c91d15b" translate="yes" xml:space="preserve">
          <source>Move the source file or directory &lt;var&gt;f1&lt;/var&gt; to the destination &lt;var&gt;f2&lt;/var&gt;.</source>
          <target state="translated">소스 파일 또는 디렉토리 &lt;var&gt;f1&lt;/var&gt; 을 대상 &lt;var&gt;f2&lt;/var&gt; 로 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="45c0cf91d70e9f1ebf0f30e518c4cf144f2ecbbf" translate="yes" xml:space="preserve">
          <source>Move to the end of the input history, i.e., the line you are entering!</source>
          <target state="translated">입력 기록의 끝, 즉 입력하는 줄로 이동하십시오!</target>
        </trans-unit>
        <trans-unit id="2a6ce964c353d7fc77f5427c386721059f89e58e" translate="yes" xml:space="preserve">
          <source>Move to the end of the line.</source>
          <target state="translated">줄의 끝으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="b197771ca8ea11c5879847015686b2f25546c56c" translate="yes" xml:space="preserve">
          <source>Move to the first line in the history.</source>
          <target state="translated">히스토리의 첫 번째 줄로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="4c0251a5384fa6d692664ca6c0665abebb12594c" translate="yes" xml:space="preserve">
          <source>Move to the start of the line.</source>
          <target state="translated">줄의 시작 부분으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="cf2bcb058d3d8b59bd1c1a7704f3bf2cfe5d6a38" translate="yes" xml:space="preserve">
          <source>Mu-law values are 8-bit unsigned integers. Linear values use &lt;var&gt;n&lt;/var&gt;-bit signed integers or floating point values in the range -1 &amp;le; &lt;var&gt;y&lt;/var&gt; &amp;le; 1 if &lt;var&gt;n&lt;/var&gt; is 0.</source>
          <target state="translated">mu-law 값은 8 비트 부호없는 정수입니다. 선형 값 은 &lt;var&gt;n&lt;/var&gt; 이 0 인 경우 -1 &amp;le; &lt;var&gt;y&lt;/var&gt; &amp;le; 1 범위의 &lt;var&gt;n&lt;/var&gt; 비트 부호있는 정수 또는 부동 소수점 값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d1880fa68b080d6cd122ae8b1205d93828b5de43" translate="yes" xml:space="preserve">
          <source>Mu-law values use 8-bit unsigned integers. Linear values use &lt;var&gt;n&lt;/var&gt;-bit signed integers or floating point values in the range -1 &amp;le; &lt;var&gt;x&lt;/var&gt; &amp;le; 1 if &lt;var&gt;n&lt;/var&gt; is 0.</source>
          <target state="translated">mu-law 값은 8 비트 부호없는 정수를 사용합니다. 선형 값 은 &lt;var&gt;n&lt;/var&gt; 이 0 인 경우 -1 &amp;le; &lt;var&gt;x&lt;/var&gt; &amp;le; 1 범위의 &lt;var&gt;n&lt;/var&gt; 비트 부호있는 정수 또는 부동 소수점 값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6e60b1686c76f6145b7e31656665eb375b134a58" translate="yes" xml:space="preserve">
          <source>Much of the geometry code in Octave is based on the Qhull library&lt;a href=&quot;#FOOT12&quot; name=&quot;DOCF12&quot;&gt;&lt;sup&gt;12&lt;/sup&gt;&lt;/a&gt;. Some of the documentation for Qhull, particularly for the options that can be passed to &lt;code&gt;delaunay&lt;/code&gt;, &lt;code&gt;voronoi&lt;/code&gt; and &lt;code&gt;convhull&lt;/code&gt;, etc., is relevant to Octave users.</source>
          <target state="translated">Octave의 많은 지오메트리 코드는 Qhull 라이브러리 &lt;a href=&quot;#FOOT12&quot; name=&quot;DOCF12&quot;&gt;&lt;sup&gt;12를&lt;/sup&gt;&lt;/a&gt; 기반으로합니다 . 특히에 전달 될 수있는 옵션에 대한 Qhull에 대한 문서의 일부, &lt;code&gt;delaunay&lt;/code&gt; , &lt;code&gt;voronoi&lt;/code&gt; 와 &lt;code&gt;convhull&lt;/code&gt; 등, 옥타브 사용자에게 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="5348b693bb31bab18cea3d4c910c8e198aa9ad27" translate="yes" xml:space="preserve">
          <source>Multi-dimensional Interpolation</source>
          <target state="translated">다차원 보간</target>
        </trans-unit>
        <trans-unit id="2e23dcb20c51eb3ff0cdae12de1e2fd144e54e5a" translate="yes" xml:space="preserve">
          <source>Multi-dimensional indexed images (of size MxNx1xK) are also supported.</source>
          <target state="translated">MxNx1xK 크기의 다차원 인덱스 이미지도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a756927127fc6bb4e513232ab3d68657066ff38a" translate="yes" xml:space="preserve">
          <source>Multi-dimensional indexed images (of size MxNx3xK) are also supported, both via a single input (&lt;var&gt;rgb&lt;/var&gt;) or its three color channels as separate variables.</source>
          <target state="translated">MxNx3xK 크기의 다차원 인덱스 이미지도 단일 입력 ( &lt;var&gt;rgb&lt;/var&gt; ) 또는 세 가지 색상 채널을 통해 개별 변수로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="3f5f0448a9eed7ed475a1bb88cceab621fcae1b1" translate="yes" xml:space="preserve">
          <source>Multiple &lt;var&gt;name&lt;/var&gt;/&lt;var&gt;value&lt;/var&gt; pairs can be specified. Alternatively, a cell array of &lt;var&gt;names&lt;/var&gt; and a corresponding cell array of &lt;var&gt;values&lt;/var&gt; can be specified.</source>
          <target state="translated">여러 개의 &lt;var&gt;name&lt;/var&gt; / &lt;var&gt;value&lt;/var&gt; 쌍을 지정할 수 있습니다. 또는 &lt;var&gt;names&lt;/var&gt; 의 셀형 배열 과 해당하는 &lt;var&gt;values&lt;/var&gt; 셀형 배열을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cf8cdd574e24662f082f0c9099612cc66b9cd76" translate="yes" xml:space="preserve">
          <source>Multiple Plot Windows</source>
          <target state="translated">다중 플롯 창</target>
        </trans-unit>
        <trans-unit id="43663f13d2b55b44c2db9342c79526a5392fc70c" translate="yes" xml:space="preserve">
          <source>Multiple Plots on One Page</source>
          <target state="translated">한 페이지에 여러 플롯</target>
        </trans-unit>
        <trans-unit id="a025ceee7b8b1c711d382e33043a2b3de0e6408b" translate="yes" xml:space="preserve">
          <source>Multiple Return Values</source>
          <target state="translated">여러 반환 값</target>
        </trans-unit>
        <trans-unit id="7b48a32f86a981a7c7025eac623837c90fbc5b29" translate="yes" xml:space="preserve">
          <source>Multiple functions in one script file.</source>
          <target state="translated">하나의 스크립트 파일에 여러 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="069b6f4c0a3769570ec15dce4edc9cff247407c8" translate="yes" xml:space="preserve">
          <source>Multiple locations can be specified if &lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, (&lt;var&gt;z&lt;/var&gt;) are vectors. Multiple strings can be specified with a character matrix or a cell array of strings.</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt; , ( &lt;var&gt;z&lt;/var&gt; )가 벡터 인 경우 여러 위치를 지정할 수 있습니다 . 문자 행렬이나 문자열의 셀형 배열로 여러 문자열을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65cc39417765873c88cb9ba73e1e24f180f53369" translate="yes" xml:space="preserve">
          <source>Multiple property-value pairs may also be specified, but they must appear in pairs. These arguments are applied to the line objects drawn by &lt;code&gt;plot&lt;/code&gt;.</source>
          <target state="translated">여러 속성-값 쌍을 지정할 수도 있지만 쌍으로 나타나야합니다. 이 인수는 &lt;code&gt;plot&lt;/code&gt; 으로 그린 ​​선 객체에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="438aaf0bddccb37c5310a918cd462e5dcec972ad" translate="yes" xml:space="preserve">
          <source>Multiple property-value pairs may be specified for the dialog object, but they must appear in pairs.</source>
          <target state="translated">대화 상자 객체에 여러 속성-값 쌍을 지정할 수 있지만 쌍으로 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="75465b8499ef322418a8855f9d7d749bfca2df1b" translate="yes" xml:space="preserve">
          <source>Multiple property-value pairs may be specified for the figure object, but they must appear in pairs.</source>
          <target state="translated">그림 개체에 여러 속성-값 쌍을 지정할 수 있지만 쌍으로 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="55103752da452540e82ed74c54517346d800094c" translate="yes" xml:space="preserve">
          <source>Multiple property-value pairs may be specified for the line object, but they must appear in pairs.</source>
          <target state="translated">선 객체에 대해 여러 속성-값 쌍을 지정할 수 있지만 쌍으로 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="0571e78fa1b27894fc2a844058ac73168b601488" translate="yes" xml:space="preserve">
          <source>Multiple property-value pairs may be specified which will affect the line objects drawn by &lt;code&gt;plot3&lt;/code&gt;. If the &lt;var&gt;fmt&lt;/var&gt; argument is supplied it will format the line objects in the same manner as &lt;code&gt;plot&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;plot3&lt;/code&gt; 으로 그린 ​​선 객체에 영향을주는 여러 속성 값 쌍을 지정할 수 있습니다 . 경우] &lt;var&gt;fmt&lt;/var&gt; 인수가 공급되고 그와 동일한 방식으로 광고 객체를 포맷한다 &lt;code&gt;plot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b553b6eb10c7c7b0b009b69d8ca8446579adcf1" translate="yes" xml:space="preserve">
          <source>Multiple property-value pairs may be specified, but they must appear in pairs. These arguments are applied to the line objects drawn by &lt;code&gt;plot&lt;/code&gt;. Useful properties to modify are &lt;code&gt;&quot;linestyle&quot;&lt;/code&gt;, &lt;code&gt;&quot;linewidth&quot;&lt;/code&gt;, &lt;code&gt;&quot;color&quot;&lt;/code&gt;, &lt;code&gt;&quot;marker&quot;&lt;/code&gt;, &lt;code&gt;&quot;markersize&quot;&lt;/code&gt;, &lt;code&gt;&quot;markeredgecolor&quot;&lt;/code&gt;, &lt;code&gt;&quot;markerfacecolor&quot;&lt;/code&gt;. See &lt;a href=&quot;line-properties#Line-Properties&quot;&gt;Line Properties&lt;/a&gt;.</source>
          <target state="translated">여러 속성-값 쌍을 지정할 수 있지만 쌍으로 나타나야합니다. 이 인수는 다음에 의해 그려진 선 객체에 적용됩니다 &lt;code&gt;plot&lt;/code&gt; . 수정할 수있는 유용한 속성은 &lt;code&gt;&quot;linestyle&quot;&lt;/code&gt; , &lt;code&gt;&quot;linewidth&quot;&lt;/code&gt; , &lt;code&gt;&quot;color&quot;&lt;/code&gt; , &lt;code&gt;&quot;marker&quot;&lt;/code&gt; , &lt;code&gt;&quot;markersize&quot;&lt;/code&gt; , &lt;code&gt;&quot;markeredgecolor&quot;&lt;/code&gt; , &lt;code&gt;&quot;markerfacecolor&quot;&lt;/code&gt; . &lt;a href=&quot;line-properties#Line-Properties&quot;&gt;라인 속성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4bdfe78f5a9a610b22edadbb462e156148b4430e" translate="yes" xml:space="preserve">
          <source>Multiple property/value pairs for the underlying patch object may be specified, but they must appear in pairs.</source>
          <target state="translated">기본 패치 객체에 대해 여러 속성 / 값 쌍을 지정할 수 있지만 쌍으로 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="644852d4dc88a7557c27e489f1ebff5ccea9f0fb" translate="yes" xml:space="preserve">
          <source>Multiple property/value pairs may be specified for the hggroup, but they must appear in pairs.</source>
          <target state="translated">hggroup에 여러 속성 / 값 쌍을 지정할 수 있지만 쌍으로 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="308b37f1dd35508686a38110aa76f0f9c0fbac9c" translate="yes" xml:space="preserve">
          <source>Multiple property/value pairs may be specified for the image object, but they must appear in pairs.</source>
          <target state="translated">이미지 객체에 여러 속성 / 값 쌍을 지정할 수 있지만 쌍으로 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="968be4588f05c376e82696740da992c6b2ac5181" translate="yes" xml:space="preserve">
          <source>Multiple property/value pairs may be specified, but they must appear in pairs.</source>
          <target state="translated">여러 속성 / 값 쌍을 지정할 수 있지만 쌍으로 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="0505491c23770efb1105bc1cfc1bb5be7ec5a815" translate="yes" xml:space="preserve">
          <source>Multiplication and division by diagonal matrices work efficiently also when combined with sparse matrices, i.e., &lt;code&gt;D*S&lt;/code&gt;, where &lt;var&gt;D&lt;/var&gt; is a diagonal matrix and &lt;var&gt;S&lt;/var&gt; is a sparse matrix scales the rows of the sparse matrix and returns a sparse matrix. The expressions &lt;code&gt;S*D&lt;/code&gt;, &lt;code&gt;D\S&lt;/code&gt;, &lt;code&gt;S/D&lt;/code&gt; work analogically.</source>
          <target state="translated">대각 행렬에 의한 곱셈과 나눗셈은 희소 행렬과 결합 될 때에도 효율적으로 작동합니다. &lt;code&gt;D*S&lt;/code&gt; . 여기서 &lt;var&gt;D&lt;/var&gt; 는 대각 행렬이고 &lt;var&gt;S&lt;/var&gt; 는 희소 행렬은 희소 행렬의 행을 스케일하고 희소 행렬을 반환합니다. &lt;code&gt;S*D&lt;/code&gt; , &lt;code&gt;D\S&lt;/code&gt; , &lt;code&gt;S/D&lt;/code&gt; 표현식은 유사하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="91b1ce45d8127b60ce6dfcfbf6b55e4bb183ec1c" translate="yes" xml:space="preserve">
          <source>Multiplication and division by permutation matrices works efficiently also when combined with sparse matrices, i.e., &lt;code&gt;P*S&lt;/code&gt;, where &lt;var&gt;P&lt;/var&gt; is a permutation matrix and &lt;var&gt;S&lt;/var&gt; is a sparse matrix permutes the rows of the sparse matrix and returns a sparse matrix. The expressions &lt;code&gt;S*P&lt;/code&gt;, &lt;code&gt;P\S&lt;/code&gt;, &lt;code&gt;S/P&lt;/code&gt; work analogically.</source>
          <target state="translated">순열 행렬에 의한 곱셈과 나눗셈은 희소 행렬과 결합 할 때에도 효율적으로 작동합니다. &lt;code&gt;P*S&lt;/code&gt; . 여기서 &lt;var&gt;P&lt;/var&gt; 는 순열 행렬이고 &lt;var&gt;S&lt;/var&gt; 는 희소 행렬은 희소 행렬의 행을 순열 하고 희소 행렬을 반환합니다. 표현식 &lt;code&gt;S*P&lt;/code&gt; , &lt;code&gt;P\S&lt;/code&gt; , &lt;code&gt;S/P&lt;/code&gt; 는 유사하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="af8d41489ec27c3890462d150897359d28431b22" translate="yes" xml:space="preserve">
          <source>Multiplying any row or column by -1 and the matrix will remain a Hadamard matrix.</source>
          <target state="translated">행이나 열에 -1을 곱하면 행렬은하다 마드 행렬로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b01d1caf864e26116e2219fa66895aad0a279d68" translate="yes" xml:space="preserve">
          <source>Must be set to &lt;code&gt;&quot;fminsearch&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;fminsearch&quot;&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="8103c240a2f6a7e0c1b4e8b2be6c801900bd95be" translate="yes" xml:space="preserve">
          <source>N. Bleistein and R.A. Handelsman,</source>
          <target state="translated">N. Bleistein과 RA Handelsman,</target>
        </trans-unit>
        <trans-unit id="ebb9af4e80cf0041bea64b676c53303b5638ef2a" translate="yes" xml:space="preserve">
          <source>N.J. Higham and F. Tisseur,</source>
          <target state="translated">뉴저지 Higham과 F. Tisseur,</target>
        </trans-unit>
        <trans-unit id="3feda0153eee1380b496298450dc5a74324eb8c1" translate="yes" xml:space="preserve">
          <source>NA</source>
          <target state="translated">NA</target>
        </trans-unit>
        <trans-unit id="0ce6d6875bbb1adc8819edf49ce2d62dcb76fc84" translate="yes" xml:space="preserve">
          <source>NA (&amp;hellip;, class)</source>
          <target state="translated">NA (&amp;hellip;, 수업)</target>
        </trans-unit>
        <trans-unit id="a4d6c2a83ea4e5ea71d12d230bba8a67aa13cd71" translate="yes" xml:space="preserve">
          <source>NA (n)</source>
          <target state="translated">NA (n)</target>
        </trans-unit>
        <trans-unit id="ec82cfa239228493e6e10899c0deb8027ca470b7" translate="yes" xml:space="preserve">
          <source>NA (n, m)</source>
          <target state="translated">NA (n, m)</target>
        </trans-unit>
        <trans-unit id="4b0ca3b6e7ca0b78b19877e7b0109e342475939b" translate="yes" xml:space="preserve">
          <source>NA (n, m, k, &amp;hellip;)</source>
          <target state="translated">NA (n, m, k,&amp;hellip;)</target>
        </trans-unit>
        <trans-unit id="33043aa6a7fb1a5929803e38176815992b886d51" translate="yes" xml:space="preserve">
          <source>NA values are also considered NaN values. For example:</source>
          <target state="translated">NA 값은 NaN 값으로 간주됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f621eb5fd3bcb2fa5c7bd228c9b1ad42edc46c8" translate="yes" xml:space="preserve">
          <source>NEWS</source>
          <target state="translated">NEWS</target>
        </trans-unit>
        <trans-unit id="f7fd9c68f804acda665d2ab082217bb1583318f2" translate="yes" xml:space="preserve">
          <source>NaN</source>
          <target state="translated">NaN</target>
        </trans-unit>
        <trans-unit id="86e83de142dd364b57c91ac75183da4843f81b90" translate="yes" xml:space="preserve">
          <source>NaN (&amp;hellip;, class)</source>
          <target state="translated">NaN (&amp;hellip;, 수업)</target>
        </trans-unit>
        <trans-unit id="b92d53e50e4d43391f346830614dcd62e3e46ac3" translate="yes" xml:space="preserve">
          <source>NaN (n)</source>
          <target state="translated">NaN (n)</target>
        </trans-unit>
        <trans-unit id="c06c99cd541aa0eb30a91dc8f92c80bb25e90474" translate="yes" xml:space="preserve">
          <source>NaN (n, m)</source>
          <target state="translated">NaN (n, m)</target>
        </trans-unit>
        <trans-unit id="224ad40af06995ff0ec6ab150861bc5a55a54f09" translate="yes" xml:space="preserve">
          <source>NaN (n, m, k, &amp;hellip;)</source>
          <target state="translated">NaN (n, m, k,&amp;hellip;)</target>
        </trans-unit>
        <trans-unit id="f816faac555bafa32e94381477cb6417d6430b59" translate="yes" xml:space="preserve">
          <source>NaN is the result of operations which do not produce a well defined numerical result. Common operations which produce a NaN are arithmetic with infinity (Inf - Inf), zero divided by zero (0/0), and any operation involving another NaN value (5 + NaN).</source>
          <target state="translated">NaN은 잘 정의 된 수치 결과를 생성하지 않는 연산의 결과입니다. NaN을 생성하는 일반적인 연산은 무한대 (Inf-Inf), 0을 0으로 나눈 값 (0/0) 및 다른 NaN 값 (5 + NaN)과 관련된 연산입니다.</target>
        </trans-unit>
        <trans-unit id="5fda41a35f872653f44450293bce4471aad17ca5" translate="yes" xml:space="preserve">
          <source>NaN values are treated as being greater than any other value and are sorted to the end of the list.</source>
          <target state="translated">NaN 값은 다른 값보다 큰 것으로 취급되어 목록 끝까지 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="7c703d97db75d2561db5e8826df701b25f37c98b" translate="yes" xml:space="preserve">
          <source>Name and version of the software or firmware of the camera or image input device used to generate the image.</source>
          <target state="translated">이미지 생성에 사용 된 카메라 또는 이미지 입력 ​​장치의 소프트웨어 또는 펌웨어의 이름과 버전.</target>
        </trans-unit>
        <trans-unit id="5c03300bc66637b889511b790544873bbe80cf03" translate="yes" xml:space="preserve">
          <source>Name of a vector in the current base workspace to use as x data.</source>
          <target state="translated">x 데이터로 사용할 현재 기본 작업 공간의 벡터 이름입니다.</target>
        </trans-unit>
        <trans-unit id="91b0e56b88edaade8237ab6836ab4d10ff5875c7" translate="yes" xml:space="preserve">
          <source>Name of a vector in the current base workspace to use as y data.</source>
          <target state="translated">y 데이터로 사용할 현재 기본 작업 공간의 벡터 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3440a66b41662a78e168bc7e08e6bd50ec72f107" translate="yes" xml:space="preserve">
          <source>Name of a vector in the current base workspace to use as z data.</source>
          <target state="translated">z 데이터로 사용할 현재 기본 작업 공간의 벡터 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b4707a0d46d7f94b451c43db3a1ab6c2377a48d4" translate="yes" xml:space="preserve">
          <source>Name of font used for text rendering. When setting this property, the text rendering engine will search for a matching font in your system. If none is found then text is rendered using a default sans serif font (same as the default &lt;code&gt;&quot;*&quot;&lt;/code&gt; value).</source>
          <target state="translated">텍스트 렌더링에 사용되는 글꼴 이름입니다. 이 속성을 설정하면 텍스트 렌더링 엔진이 시스템에서 일치하는 글꼴을 검색합니다. 찾을 수없는 경우 기본 sans serif 글꼴 (기본 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 값 과 동일)을 사용하여 텍스트가 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="5cd53fbf82a5c921bb324eaf9549067ec85d65bb" translate="yes" xml:space="preserve">
          <source>Name of the audio file.</source>
          <target state="translated">오디오 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a5cd32a941d96dd33adae23b12bbc3237bcfab16" translate="yes" xml:space="preserve">
          <source>Name of the camera owner, photographer or image creator.</source>
          <target state="translated">카메라 소유자, 사진 작가 또는 이미지 제작자의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="dbc76c09232a27e737ef03ec160d0547bc322154" translate="yes" xml:space="preserve">
          <source>Name of the package.</source>
          <target state="translated">패키지 이름</target>
        </trans-unit>
        <trans-unit id="6842e62c791d8e217b935d3bbe2012bf33f1e6bb" translate="yes" xml:space="preserve">
          <source>Name of the paper used for printed output. Setting &lt;code&gt;papertype&lt;/code&gt; also changes &lt;code&gt;papersize&lt;/code&gt;, while maintaining consistency with the &lt;code&gt;paperorientation&lt;/code&gt; property.</source>
          <target state="translated">인쇄 출력에 사용되는 용지 이름. &lt;code&gt;papertype&lt;/code&gt; 을 설정 하면 &lt;code&gt;paperorientation&lt;/code&gt; 속성 과 일관성을 유지하면서 &lt;code&gt;papersize&lt;/code&gt; 도 변경 됩니다.</target>
        </trans-unit>
        <trans-unit id="0c7c5d3ba2ba568d2a5726a14fbaac7573a80e31" translate="yes" xml:space="preserve">
          <source>Name to be displayed in the figure title bar. The name is displayed to the right of any title determined by the &lt;code&gt;numbertitle&lt;/code&gt; property.</source>
          <target state="translated">그림 제목 표시 줄에 표시 될 이름입니다. 이름은 &lt;code&gt;numbertitle&lt;/code&gt; 속성에 의해 결정된 제목의 오른쪽에 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="e94de1f5e234baf66c12cf648757c06702b6ebf0" translate="yes" xml:space="preserve">
          <source>Negation.</source>
          <target state="translated">Negation.</target>
        </trans-unit>
        <trans-unit id="5eb21879f66ab1c7bed8ff054645faa8f4b87528" translate="yes" xml:space="preserve">
          <source>Negative values of &lt;var&gt;d&lt;/var&gt; represent diagonals below the main diagonal, and positive values of &lt;var&gt;d&lt;/var&gt; diagonals above the main diagonal.</source>
          <target state="translated">&lt;var&gt;d&lt;/var&gt; 의 음수 값은 주 대각선 아래의 대각선을 나타내며 기본 대각선 위 의 &lt;var&gt;d&lt;/var&gt; 대각선 의 양수 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="6ceba4234e15aa5ab2bd2d8b94c4dcba7693959f" translate="yes" xml:space="preserve">
          <source>Nested Functions</source>
          <target state="translated">중첩 함수</target>
        </trans-unit>
        <trans-unit id="cc679e90d5ed1694e23c1d99247568923aa26cad" translate="yes" xml:space="preserve">
          <source>Nested functions are similar to subfunctions in that only the main function is visible outside the file. However, they also allow for child functions to access the local variables in their parent function. This shared access mimics using a global variable to share information &amp;mdash; but a global variable which is not visible to the rest of Octave. As a programming strategy, sharing data this way can create code which is difficult to maintain. It is recommended to use subfunctions in place of nested functions when possible.</source>
          <target state="translated">중첩 함수는 주 함수 만 파일 외부에서 볼 수 있다는 점에서 하위 함수와 유사합니다. 그러나 하위 함수가 상위 함수의 로컬 변수에 액세스 할 수도 있습니다. 이 공유 액세스는 전역 변수를 사용하여 정보를 공유하지만 나머지 Octave에서는 보이지 않는 전역 변수를 모방합니다. 프로그래밍 전략으로서 이런 방식으로 데이터를 공유하면 유지하기 어려운 코드가 생성 될 수 있습니다. 가능하면 중첩 함수 대신 하위 함수를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3d3fc7f4a0a1ca25a6fb86aa1f5a1e4e3a6b9458" translate="yes" xml:space="preserve">
          <source>Nested functions.</source>
          <target state="translated">중첩 함수.</target>
        </trans-unit>
        <trans-unit id="f484ae1b450d6d1df5329e1917780d81a0d5705f" translate="yes" xml:space="preserve">
          <source>Networking Utilities</source>
          <target state="translated">네트워킹 유틸리티</target>
        </trans-unit>
        <trans-unit id="267429fbf99e3675f3f89422c90011d4cf73259e" translate="yes" xml:space="preserve">
          <source>Nevertheless, there are several other functions for concatenating string objects which can be useful in specific circumstances: &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;strvcat&lt;/code&gt;, &lt;code&gt;strcat&lt;/code&gt;, and &lt;code&gt;cstrcat&lt;/code&gt;. Finally, the general purpose concatenation functions can be used: see &lt;a href=&quot;rearranging-matrices#XREFcat&quot;&gt;cat&lt;/a&gt;, &lt;a href=&quot;rearranging-matrices#XREFhorzcat&quot;&gt;horzcat&lt;/a&gt;, and &lt;a href=&quot;rearranging-matrices#XREFvertcat&quot;&gt;vertcat&lt;/a&gt;.</source>
          <target state="translated">그럼에도 불구하고 특정 상황에서 유용 할 수있는 문자열 객체를 연결하기위한 몇 가지 다른 함수가 있습니다 : &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;strvcat&lt;/code&gt; , &lt;code&gt;strcat&lt;/code&gt; 및 &lt;code&gt;cstrcat&lt;/code&gt; . 마지막으로 범용 연결 기능을 사용할 수 있습니다 ( &lt;a href=&quot;rearranging-matrices#XREFcat&quot;&gt;cat&lt;/a&gt; , &lt;a href=&quot;rearranging-matrices#XREFhorzcat&quot;&gt;horzcat&lt;/a&gt; 및 &lt;a href=&quot;rearranging-matrices#XREFvertcat&quot;&gt;vertcat 참조)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="24ab8464e1f70b6e778b76282b8eca9e46d30844" translate="yes" xml:space="preserve">
          <source>Newline character.</source>
          <target state="translated">줄 바꿈 문자.</target>
        </trans-unit>
        <trans-unit id="156f42ed828e8b596bb65e80ee975f9805f5ad38" translate="yes" xml:space="preserve">
          <source>Next, Octave searches in the user&amp;rsquo;s home directory. If a file</source>
          <target state="translated">다음으로 Octave는 사용자의 홈 디렉토리에서 검색합니다. 파일 인 경우</target>
        </trans-unit>
        <trans-unit id="cdfb9816a6da8b55dc6b83876630fbe046265472" translate="yes" xml:space="preserve">
          <source>Nineteen Dubious Ways to Compute the Exponential of a Matrix</source>
          <target state="translated">행렬의 지수를 계산하는 19 가지 모호한 방법</target>
        </trans-unit>
        <trans-unit id="ea9adb03bc9432c8d85a190a8df2a570355876e3" translate="yes" xml:space="preserve">
          <source>No Jacobian used (even if it is available).</source>
          <target state="translated">Jacobian을 사용하지 않았습니다 (사용 가능한 경우에도).</target>
        </trans-unit>
        <trans-unit id="4a76f110ba0569bf078529829be2f1767dab0c64" translate="yes" xml:space="preserve">
          <source>No actual tests are performed.</source>
          <target state="translated">실제 테스트는 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72647315b2f15c1b26310b5d140f0c80e187a398" translate="yes" xml:space="preserve">
          <source>No check is done for the existence of &lt;var&gt;file&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 이 있는지 검사하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="faff1342dad9919bbe2a2ffdaf4dcba79402405f" translate="yes" xml:space="preserve">
          <source>No checks are made for duplicate elements.</source>
          <target state="translated">중복 요소는 검사하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7cfb987067249b31fc3824dfa2aac42cf1fbe27d" translate="yes" xml:space="preserve">
          <source>No convergence.</source>
          <target state="translated">수렴이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae744b18f1531f50578dfdc1fd733c33e953aa60" translate="yes" xml:space="preserve">
          <source>No display.</source>
          <target state="translated">표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="641c0f50ba6c7f6fa40ed4b9121a7c0c62c0fda8" translate="yes" xml:space="preserve">
          <source>No dual feasible solution.</source>
          <target state="translated">이중 실행 가능한 솔루션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b2f69b3d1ffe4476f9895565ab3c472eb9a4deae" translate="yes" xml:space="preserve">
          <source>No error.</source>
          <target state="translated">오류가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d26577d89448b98ab61ebcd31cea5c25d90930e" translate="yes" xml:space="preserve">
          <source>No line. Points will still be marked using the current Marker Style.</source>
          <target state="translated">줄이 없습니다. 포인트는 여전히 현재 마커 스타일을 사용하여 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="64bbb2d2d3a0587efd7abf186fcfc2b1948eba7f" translate="yes" xml:space="preserve">
          <source>No output.</source>
          <target state="translated">출력이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b330bed69473b0291eb7e09ceba27269cdb6d9f5" translate="yes" xml:space="preserve">
          <source>No primal feasible solution.</source>
          <target state="translated">원시 가능한 솔루션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3cce4b3efa8e51297e19ceaa379c1a199d3df228" translate="yes" xml:space="preserve">
          <source>No primal/dual feasible solution.</source>
          <target state="translated">원시 / 이중 실행 가능한 솔루션이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e88eaa47e5307bdc10f51fa823e3f66a91a0185f" translate="yes" xml:space="preserve">
          <source>No value is &lt;var&gt;NaN&lt;/var&gt;, and each is greater than or equal to the preceding one.</source>
          <target state="translated">&lt;var&gt;NaN&lt;/var&gt; 값이 없고 각각이 이전 값보다 크거나 같습니다.</target>
        </trans-unit>
        <trans-unit id="24babdb294bc9d6d8b704781453133e16f672ae2" translate="yes" xml:space="preserve">
          <source>No value is &lt;var&gt;NaN&lt;/var&gt;, and each is greater than the preceding one.</source>
          <target state="translated">&lt;var&gt;NaN&lt;/var&gt; 값이 없으며 각 값이 이전 값보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="ba0851fb1954a70764e8b77d65094d09cb13d687" translate="yes" xml:space="preserve">
          <source>No value is &lt;var&gt;NaN&lt;/var&gt;, and each is less than or equal to the preceding one.</source>
          <target state="translated">&lt;var&gt;NaN&lt;/var&gt; 값이 없고 각각이 이전 값보다 작거나 같습니다.</target>
        </trans-unit>
        <trans-unit id="a82c96fb909676ef2fabd2ca6e89958daa889a4d" translate="yes" xml:space="preserve">
          <source>No value is &lt;var&gt;NaN&lt;/var&gt;, and each is less than the preceding one.</source>
          <target state="translated">&lt;var&gt;NaN&lt;/var&gt; 값이 없고 각각이 이전 값보다 작습니다.</target>
        </trans-unit>
        <trans-unit id="b73d86eec6b7b63b813d25542b98aac5e19b48a6" translate="yes" xml:space="preserve">
          <source>No value is a &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 값은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="95b3a0d9327c7ba474a5a776f95cb444a21e6777" translate="yes" xml:space="preserve">
          <source>No value is zero.</source>
          <target state="translated">값이 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="94ffead924eb1e443d114e54895c55ec4af0114f" translate="yes" xml:space="preserve">
          <source>No warnings or error messages are printed while &lt;var&gt;body&lt;/var&gt; is executing. If an error does occur during the execution of &lt;var&gt;body&lt;/var&gt;, &lt;var&gt;cleanup&lt;/var&gt; can use the functions &lt;code&gt;lasterr&lt;/code&gt; or &lt;code&gt;lasterror&lt;/code&gt; to access the text of the message that would have been printed, as well as its identifier. The alternative form,</source>
          <target state="translated">&lt;var&gt;body&lt;/var&gt; 이 실행 되는 동안 경고 또는 오류 메시지가 인쇄되지 않습니다 . &lt;var&gt;body&lt;/var&gt; 를 실행하는 동안 오류가 발생 하면 &lt;var&gt;cleanup&lt;/var&gt; 은 &lt;code&gt;lasterr&lt;/code&gt; 또는 &lt;code&gt;lasterror&lt;/code&gt; 함수를 사용하여 인쇄 될 메시지의 텍스트와 식별자 에 액세스 할 수 있습니다. 대체 형태</target>
        </trans-unit>
        <trans-unit id="853dbfd8e521ebcbcc0869aebddd7a34ad1a5d36" translate="yes" xml:space="preserve">
          <source>Non-blocking mode.</source>
          <target state="translated">비 차단 모드.</target>
        </trans-unit>
        <trans-unit id="8ab356ddf4ef01e4c187f0b171433ad89a72e987" translate="yes" xml:space="preserve">
          <source>Non-diagonal entries of &lt;var&gt;L&lt;/var&gt; are set to 0 unless</source>
          <target state="translated">&lt;var&gt;L&lt;/var&gt; 의 비 대각선 항목은 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f01491990d98f9d2ad10583e5d0ebe771f48998f" translate="yes" xml:space="preserve">
          <source>Non-diagonal entries of &lt;var&gt;U&lt;/var&gt; are set to 0 unless</source>
          <target state="translated">&lt;var&gt;U&lt;/var&gt; 의 비 대각선 항목은 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="59b30e58a2b59bf53379325e0b366a70e8a80995" translate="yes" xml:space="preserve">
          <source>Non-integers are rounded to integers before display. Only the real part of complex numbers is displayed.</source>
          <target state="translated">비정 수는 표시하기 전에 정수로 반올림됩니다. 복소수의 실제 부분 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c9bed96a54ad52ea4754287d4e84d1987aac7081" translate="yes" xml:space="preserve">
          <source>Non-negative relative tolerance for single precision. If the absolute tolerance is zero, the relative tolerance must be greater than or equal to &lt;code&gt;max&amp;nbsp;(50*eps,&amp;nbsp;0.5e-28)&lt;/code&gt;.</source>
          <target state="translated">단 정밀도에 대한 음이 아닌 상대 공차. 절대 공차가 0 인 경우 상대 공차는 &lt;code&gt;max&amp;nbsp;(50*eps,&amp;nbsp;0.5e-28)&lt;/code&gt; 이상이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6e7e57032b159eb71b047fe7e23b9a49243d18cd" translate="yes" xml:space="preserve">
          <source>Non-negative relative tolerance. If the absolute tolerance is zero, the relative tolerance must be greater than or equal to &lt;code&gt;max&amp;nbsp;(50*eps,&amp;nbsp;0.5e-28)&lt;/code&gt;.</source>
          <target state="translated">음이 아닌 상대 공차. 절대 공차가 0 인 경우 상대 공차는 &lt;code&gt;max&amp;nbsp;(50*eps,&amp;nbsp;0.5e-28)&lt;/code&gt; 이상이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="8585773db22810078b09932f42fe2e8b64abf091" translate="yes" xml:space="preserve">
          <source>None 4.4.0</source>
          <target state="translated">없음 4.4.0</target>
        </trans-unit>
        <trans-unit id="7bf708f3ec0578aacb5fb5fe2b7a207f82aff0b3" translate="yes" xml:space="preserve">
          <source>Nonlinear Equations</source>
          <target state="translated">비선형 방정식</target>
        </trans-unit>
        <trans-unit id="7c84a6851d364487a47570de2ea33f13c2df1c3c" translate="yes" xml:space="preserve">
          <source>Nonlinear Programming</source>
          <target state="translated">비선형 프로그래밍</target>
        </trans-unit>
        <trans-unit id="2bcc1e172b7a8d3c0379e39c064dee22d5b4e334" translate="yes" xml:space="preserve">
          <source>Normal font</source>
          <target state="translated">일반 글꼴</target>
        </trans-unit>
        <trans-unit id="0d8e47face11cf04737acd0b40311ad2816eaac6" translate="yes" xml:space="preserve">
          <source>Normal output.</source>
          <target state="translated">정상 출력.</target>
        </trans-unit>
        <trans-unit id="e1a9da721bd2349f1a91a7779d8cca0c286bf8e8" translate="yes" xml:space="preserve">
          <source>Normal return.</source>
          <target state="translated">정상적인 반환.</target>
        </trans-unit>
        <trans-unit id="2ec9b7560a90c24e35162d5c8e65e6f7b90f2f60" translate="yes" xml:space="preserve">
          <source>Normally, Octave is used interactively by running the program &amp;lsquo;</source>
          <target state="translated">일반적으로 Octave는 프로그램을 실행하여 대화식으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="56c2a202a564b53fbf65dc0bc4cd6d6171b3da49" translate="yes" xml:space="preserve">
          <source>Normally, calls to &lt;code&gt;autoload&lt;/code&gt; appear in PKG_ADD script files that are evaluated when a directory is added to Octave&amp;rsquo;s load path. To avoid having to hardcode directory names in &lt;var&gt;file&lt;/var&gt;, if &lt;var&gt;file&lt;/var&gt; is in the same directory as the PKG_ADD script then</source>
          <target state="translated">일반적으로 &lt;code&gt;autoload&lt;/code&gt; 호출 은 디렉토리가 Octave의로드 경로에 추가 될 때 평가되는 PKG_ADD 스크립트 파일에 나타납니다. 에 하드 코드 디렉토리 이름을 가진 피하려면 &lt;var&gt;file&lt;/var&gt; 경우, &lt;var&gt;file&lt;/var&gt; 다음 pkg_add 실행 스크립트와 같은 디렉토리에 있습니다</target>
        </trans-unit>
        <trans-unit id="9dc319baabbad4fe33972c73bfdebbe0dcdc0c0d" translate="yes" xml:space="preserve">
          <source>Normally, high-level plot functions like &lt;code&gt;plot&lt;/code&gt; or &lt;code&gt;mesh&lt;/code&gt; call &lt;code&gt;newplot&lt;/code&gt; to determine whether the state of the target axes should be initialized (the default) or if subsequent plots should be drawn on top of previous ones. To have two plots drawn over one another, use the &lt;code&gt;hold&lt;/code&gt; function or manually change the axes &lt;a href=&quot;axes-properties#XREFaxesnextplot&quot;&gt;nextplot&lt;/a&gt; property. For example,</source>
          <target state="translated">일반적으로 &lt;code&gt;plot&lt;/code&gt; 또는 &lt;code&gt;mesh&lt;/code&gt; 와 같은 고급 플롯 기능은 &lt;code&gt;newplot&lt;/code&gt; 을 호출 하여 대상 축의 상태를 초기화해야하는지 (기본값) 또는 후속 플롯을 이전 축에 그려야 하는지 여부를 결정합니다. 두 개의 플롯을 서로 &lt;a href=&quot;axes-properties#XREFaxesnextplot&quot;&gt;그리&lt;/a&gt; 려면 &lt;code&gt;hold&lt;/code&gt; 함수를 사용하거나 좌표축 nextplot 속성을 수동으로 변경하십시오 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="678772a2bf7e5a5b9ac7552c02a2e83a05a7fd46" translate="yes" xml:space="preserve">
          <source>Normally, no output is displayed by the pager until just before Octave is ready to print the top level prompt, or read from the standard input (for example, by using the &lt;code&gt;fscanf&lt;/code&gt; or &lt;code&gt;scanf&lt;/code&gt; functions). This means that there may be some delay before any output appears on your screen if you have asked Octave to perform a significant amount of work with a single command statement. The function &lt;code&gt;fflush&lt;/code&gt; may be used to force output to be sent to the pager (or any other stream) immediately.</source>
          <target state="translated">일반적으로 Octave가 최상위 프롬프트를 인쇄하거나 표준 입력에서 읽을 때까지 (예를 들어, &lt;code&gt;fscanf&lt;/code&gt; 또는 &lt;code&gt;scanf&lt;/code&gt; 기능 을 사용하기 전까지) 호출기에 출력이 표시되지 않습니다 . 즉, Octave에 단일 명령문으로 많은 양의 작업을 수행하도록 요청한 경우 화면에 출력이 표시되기 전에 약간의 지연이있을 수 있습니다. 함수 &lt;code&gt;fflush&lt;/code&gt; 동력 출력으로 사용될 수있다 즉시 호출기 (또는 임의의 다른 스트림)로 전송한다.</target>
        </trans-unit>
        <trans-unit id="6f0cbe8fae3fbbba6a96a38234aa52b94503c4a3" translate="yes" xml:space="preserve">
          <source>Normally, you evaluate expressions simply by typing them at the Octave prompt, or by asking Octave to interpret commands that you have saved in a file.</source>
          <target state="translated">일반적으로 Octave 프롬프트에서 표현식을 입력하거나 파일에 저장 한 명령을 해석하도록 Octave에 요청하여 표현식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="3eda3e1687285d454ec364da08964cd921521516" translate="yes" xml:space="preserve">
          <source>Normally, you will want to pass some information to the functions you define. The syntax for passing parameters to a function in Octave is</source>
          <target state="translated">일반적으로 정의한 함수에 정보를 전달하려고합니다. Octave에서 함수에 매개 변수를 전달하는 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="736a03d3935b846bb2525ea51ed0d1f43165330e" translate="yes" xml:space="preserve">
          <source>Not all fields are available on all systems. If it is not possible to get CPU time statistics, the CPU time slots are set to zero. Other missing data are replaced by NaN. The list of possible fields is:</source>
          <target state="translated">모든 시스템에서 모든 필드를 사용할 수있는 것은 아닙니다. CPU 시간 통계를 얻을 수 없으면 CPU 시간 슬롯이 0으로 설정됩니다. 다른 누락 된 데이터는 NaN으로 대체됩니다. 가능한 필드 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a50502dee9682851ad0951986e6ddf455de05e0" translate="yes" xml:space="preserve">
          <source>Not constrained.</source>
          <target state="translated">제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b498326e15a92ae0d8b8c9b12f4c1b41ff6d4998" translate="yes" xml:space="preserve">
          <source>Not equal to</source>
          <target state="translated">같지 않음</target>
        </trans-unit>
        <trans-unit id="070bb0c55df0c75c1caf517de5c6fefdebb6f90a" translate="yes" xml:space="preserve">
          <source>Not supported, only for &lt;small&gt;MATLAB&lt;/small&gt; compatibility.</source>
          <target state="translated">&lt;small&gt;MATLAB&lt;/small&gt; 호환성 에만 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="95cdf23a732c6b17568c114011f8aed47def32a9" translate="yes" xml:space="preserve">
          <source>Note about user-supplied Jacobians: As an inherent property of the algorithm, a Jacobian is always requested for a solution vector whose residual vector is already known, and it is the last accepted successful step. Often this will be one of the last two calls, but not always. If the savings by reusing intermediate results from residual calculation in Jacobian calculation are significant, the best strategy is to employ &lt;code&gt;OutputFcn&lt;/code&gt;: After a vector is evaluated for residuals, if &lt;code&gt;OutputFcn&lt;/code&gt; is called with that vector, then the intermediate results should be saved for future Jacobian evaluation, and should be kept until a Jacobian evaluation is requested or until &lt;code&gt;OutputFcn&lt;/code&gt; is called with a different vector, in which case they should be dropped in favor of this most recent vector. A short example how this can be achieved follows:</source>
          <target state="translated">사용자 제공 Jacobians에 대한 참고 사항 : 알고리즘의 고유 속성으로 Jacobian은 항상 잔차 벡터가 이미 알려진 솔루션 벡터에 대해 요청되며 마지막으로 성공한 단계입니다. 종종 이것은 마지막 두 통화 중 하나 일 수 있지만 항상 그런 것은 아닙니다. Jacobian 계산에서 잔차 계산으로 중간 결과를 재사용하여 절감 효과가 큰 경우 가장 좋은 전략은 &lt;code&gt;OutputFcn&lt;/code&gt; 을 사용하는 것입니다 . 벡터가 잔차에 대해 평가 된 후 &lt;code&gt;OutputFcn&lt;/code&gt; 이 해당 벡터와 함께 호출 되면 향후 Jacobian을 위해 중간 결과를 저장해야합니다. 평가, Jacobian 평가가 요청 될 때까지 또는 &lt;code&gt;OutputFcn&lt;/code&gt; 까지 유지되어야합니다.는 다른 벡터로 호출되며,이 경우 가장 최근의 벡터를 위해 드롭되어야합니다. 이것이 어떻게 달성 될 수 있는지에 대한 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="61b9165e7866678b22733e3544ae299705c6e534" translate="yes" xml:space="preserve">
          <source>Note also that &lt;var&gt;U&lt;/var&gt; and &lt;var&gt;T&lt;/var&gt; are not unique.</source>
          <target state="translated">또한 &lt;var&gt;U&lt;/var&gt; 와 &lt;var&gt;T&lt;/var&gt; 는 고유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e71bed1a6c7ee17bbf1f31039b1d95d9e2e4adc" translate="yes" xml:space="preserve">
          <source>Note here the elegant use of the double colon to replace the call to the &lt;code&gt;reshape&lt;/code&gt; function.</source>
          <target state="translated">여기서는 &lt;code&gt;reshape&lt;/code&gt; 함수 호출을 대체하기 위해 이중 콜론을 우아하게 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="06c5e84aaab5e9d2f448f8e80bb28b3f004fe8ed" translate="yes" xml:space="preserve">
          <source>Note in the example the use of the &lt;code&gt;mxDuplicateArray&lt;/code&gt; function. This is needed as the &lt;code&gt;mxArray&lt;/code&gt; pointer returned by &lt;code&gt;mxGetCell&lt;/code&gt; might be deallocated. The inverse function to &lt;code&gt;mxGetCell&lt;/code&gt;, used for setting Cell values, is &lt;code&gt;mxSetCell&lt;/code&gt; and is defined as</source>
          <target state="translated">예제에서 &lt;code&gt;mxDuplicateArray&lt;/code&gt; 함수 사용에 유의하십시오 . 이것은 &lt;code&gt;mxArray&lt;/code&gt; 의해 반환 된 &lt;code&gt;mxGetCell&lt;/code&gt; 포인터 가 할당 해제 될 수 있기 때문에 필요합니다. 셀 값 설정에 사용되는 &lt;code&gt;mxGetCell&lt;/code&gt; 의 역함수 는 &lt;code&gt;mxSetCell&lt;/code&gt; 이며 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="da5b870679158a8dc429765e73588de68e861a6b" translate="yes" xml:space="preserve">
          <source>Note that &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="c3a48c37def5629c5dfd7a716fec4030aeac1781" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;atexit&lt;/code&gt; only removes the first occurrence of a function from the list, so if a function was placed in the list multiple times with &lt;code&gt;atexit&lt;/code&gt;, it must also be removed from the list multiple times.</source>
          <target state="translated">참고 &lt;code&gt;atexit&lt;/code&gt; 은 단지 기능과 목록에 여러번 넣었다 그렇다면 목록에서 함수의 첫 번째 발생을 제거 &lt;code&gt;atexit&lt;/code&gt; 은 , 또한리스트 여러 번에서 제거되어야한다.</target>
        </trans-unit>
        <trans-unit id="faaf0dd9ed9824765b7dd4a0f775d9f80b08066e" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;bitshift (int8 (-1), -1)&lt;/code&gt; is &lt;code&gt;-1&lt;/code&gt; since the bit representation of &lt;code&gt;-1&lt;/code&gt; in the &lt;code&gt;int8&lt;/code&gt; data type is &lt;code&gt;[1, 1,
1, 1, 1, 1, 1, 1]&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;bitshift (int8 (-1), -1)&lt;/code&gt; 인 &lt;code&gt;-1&lt;/code&gt; 의 비트 표현 때문에 &lt;code&gt;-1&lt;/code&gt; 에 &lt;code&gt;int8&lt;/code&gt; 데이터 형식 인 &lt;code&gt;[1, 1, 1, 1, 1, 1, 1, 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56c917dbf59cde2c1d60444fa481354b2df27acc" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;char (&lt;var&gt;fun&lt;/var&gt;)&lt;/code&gt; is equivalent to &lt;code&gt;formula (&lt;var&gt;fun&lt;/var&gt;)&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;char (&lt;var&gt;fun&lt;/var&gt;)&lt;/code&gt; 에 해당 &lt;code&gt;formula (&lt;var&gt;fun&lt;/var&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ee5fbc46ff777487145cc61fc59c9e83b4dd557" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;feof&lt;/code&gt; will only return 1 if the end of the file has already been encountered, not if the next read operation will result in an end-of-file condition.</source>
          <target state="translated">참고 것을 &lt;code&gt;feof&lt;/code&gt; 파일의 끝이 이미 발생 된 경우에만 1을 반환합니다, 다음 읽기 작업은 파일 끝 상태가됩니다하지 않을 경우.</target>
        </trans-unit>
        <trans-unit id="39d77c5f87c7e52dd3e430773159231f81fe5109" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ferror&lt;/code&gt; indicates if an error has already occurred, not whether the next operation will result in an error condition.</source>
          <target state="translated">참고 것을 &lt;code&gt;ferror&lt;/code&gt; 함수는 오류가 이미 발생한 경우 표시, 다음 작업은 오류 상태가됩니다 여부.</target>
        </trans-unit>
        <trans-unit id="2d13fe33c4c53babd9f7c98cb2c5acec550ea720" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;isinteger&amp;nbsp;(14)&lt;/code&gt; is false because numeric constants in Octave are double precision floating point values.</source>
          <target state="translated">참고 &lt;code&gt;isinteger&amp;nbsp;(14)&lt;/code&gt; 옥타브의 숫자 상수를 배정 밀도 부동 소수점 값이기 때문에 false입니다.</target>
        </trans-unit>
        <trans-unit id="156f6e80ece71c8c52bfb708ecf1abff3bd02a7c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;popen2&lt;/code&gt;, unlike &lt;code&gt;popen&lt;/code&gt;, will not &quot;reap&quot; the child process. If you don&amp;rsquo;t use &lt;code&gt;waitpid&lt;/code&gt; to check the child&amp;rsquo;s exit status, it will linger until Octave exits.</source>
          <target state="translated">참고 &lt;code&gt;popen2&lt;/code&gt; 에는 달리 &lt;code&gt;popen&lt;/code&gt; , 자식 프로세스 &quot;를 얻을&quot;하지 않습니다. &lt;code&gt;waitpid&lt;/code&gt; 를 사용 하여 자녀의 종료 상태를 확인 하지 않으면 Octave가 종료 될 때까지 대기합니다.</target>
        </trans-unit>
        <trans-unit id="0c44927646862d5aea06933b3fba6b206acc50df" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;sign (-0.0)&lt;/code&gt; is 0. Although IEEE 754 floating point allows zero to be signed, 0.0 and -0.0 compare equal. If you must test whether zero is signed, use the &lt;code&gt;signbit&lt;/code&gt; function.</source>
          <target state="translated">참고 &lt;code&gt;sign (-0.0)&lt;/code&gt; IEEE 754 부동 소수점 제로가 서명 될 수 있으며, 0.0 -0.0 비교하더라도 동등한 0이다. 0이 서명되었는지 여부를 테스트해야하는 경우 &lt;code&gt;signbit&lt;/code&gt; 기능을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a182c7889b09758bcba8d4035ce32e0f5339f02" translate="yes" xml:space="preserve">
          <source>Note that &lt;small&gt;MATLAB&lt;/small&gt; does not strictly follow this principle and converts assumed zeros to numerical zeros in certain cases, while not doing so in other cases. As of today, there are no intentions to mimic such behavior in Octave.</source>
          <target state="translated">참고 &lt;small&gt;MATLAB은&lt;/small&gt; 엄격하게이 원칙을 따르지 않는 다른 경우 이렇게하지 않으면 서 변환이, 어떤 경우에는 숫자 0으로 0을 가정한다. 현재 옥타브에서는 이러한 행동을 모방하려는 의도가 없습니다.</target>
        </trans-unit>
        <trans-unit id="841900be87543570d976967dc3fab597ab97f68e" translate="yes" xml:space="preserve">
          <source>Note that &lt;var&gt;U&lt;/var&gt; should be an upper-triangular matrix with positive diagonal elements. &lt;code&gt;chol2inv (&lt;var&gt;U&lt;/var&gt;)&lt;/code&gt; provides &lt;code&gt;inv (&lt;var&gt;U&lt;/var&gt;'*&lt;var&gt;U&lt;/var&gt;)&lt;/code&gt; but it is much faster than using &lt;code&gt;inv&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;var&gt;U&lt;/var&gt; 가 긍정적 대각 요소 상부 삼각 행렬이어야한다. &lt;code&gt;chol2inv (&lt;var&gt;U&lt;/var&gt;)&lt;/code&gt; 는 &lt;code&gt;inv (&lt;var&gt;U&lt;/var&gt;'*&lt;var&gt;U&lt;/var&gt;)&lt;/code&gt; 하지만 &lt;code&gt;inv&lt;/code&gt; 를 사용하는 것보다 훨씬 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="44aa1c2d89ea15b63ebb6c81fdd694e68ae33149" translate="yes" xml:space="preserve">
          <source>Note that &lt;var&gt;observed&lt;/var&gt; and &lt;var&gt;expected&lt;/var&gt; can be scalars, vectors, matrices, strings, cell arrays, or structures.</source>
          <target state="translated">주의 &lt;var&gt;observed&lt;/var&gt; 및 &lt;var&gt;expected&lt;/var&gt; 스칼라, 벡터, 행렬, 문자열, 셀 어레이 또는 구조가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="463ee03c6a5f677cc33b2997ccb27566c852dcd3" translate="yes" xml:space="preserve">
          <source>Note that NA always compares not equal to NA (NA != NA). To find NA values, use the &lt;code&gt;isna&lt;/code&gt; function.</source>
          <target state="translated">NA는 항상 NA와 같지 않습니다 (NA! = NA). NA 값을 찾으려면 &lt;code&gt;isna&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="26b6342e77070034236e1166982b92d9717cb699" translate="yes" xml:space="preserve">
          <source>Note that NaN always compares not equal to NaN (NaN != NaN). This behavior is specified by the IEEE standard for floating point arithmetic. To find NaN values, use the &lt;code&gt;isnan&lt;/code&gt; function.</source>
          <target state="translated">NaN은 항상 NaN과 같지 않습니다 (NaN! = NaN). 이 동작은 부동 소수점 산술에 대한 IEEE 표준에 의해 지정됩니다. NaN 값을 찾으려면 &lt;code&gt;isnan&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="79f4aa95440e5d844467a3327ff6c177001ddde7" translate="yes" xml:space="preserve">
          <source>Note that Octave does not implement pass by reference; Therefore, to modify an object requires an assignment statement using the return value from the &lt;code&gt;set&lt;/code&gt; method.</source>
          <target state="translated">Octave는 참조로 패스를 구현하지 않습니다. 따라서 객체를 수정하려면 &lt;code&gt;set&lt;/code&gt; 메서드 의 반환 값을 사용하여 할당 문이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="72181781aaecafc4c7759247d5937ccf3c484b90" translate="yes" xml:space="preserve">
          <source>Note that Octave does not try to look up the definition of any identifier until it needs to evaluate it. This means that Octave will compile the following statements if they appear in a script file, or are typed at the command line,</source>
          <target state="translated">Octave는 식별자를 평가할 때까지 식별자의 정의를 찾으려고하지 않습니다. 즉, Octave는 다음 명령문이 스크립트 파일에 표시되거나 명령 행에 입력되면 다음 명령문을 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="9bff13e707fd56bc06e487983afa83771c5ed401" translate="yes" xml:space="preserve">
          <source>Note that Octave may print the elements in any order.</source>
          <target state="translated">Octave는 어떤 순서로든 요소를 ​​인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23f420a2c4696fe4dde03dfed91e2f525de564fa" translate="yes" xml:space="preserve">
          <source>Note that Octave tends to crop unused memory at the first opportunity for sparse objects. Thus, in general the value of &lt;code&gt;nzmax&lt;/code&gt; will be the same as &lt;code&gt;nnz&lt;/code&gt; except for some cases of user-created sparse objects.</source>
          <target state="translated">옥타브는 스파 스 객체를 처음 사용할 때 사용하지 않는 메모리를 자르는 경향이 있습니다. 따라서 일반적으로 &lt;code&gt;nzmax&lt;/code&gt; 의 값 은 사용자가 생성 한 희소 객체의 경우를 제외하고 &lt;code&gt;nnz&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="dd0f71a8cb14210b954c715cd19173d3ed145834" translate="yes" xml:space="preserve">
          <source>Note that all previous variables and values are lost when a new shared block is declared.</source>
          <target state="translated">새로운 공유 블록이 선언되면 이전의 모든 변수와 값이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="7747786ac9a2adecc77e34ae15ca00a8628e461c" translate="yes" xml:space="preserve">
          <source>Note that because Octave used some CPU time to start, it is reasonable to check to see if &lt;code&gt;cputime&lt;/code&gt; works by checking to see if the total CPU time used is nonzero.</source>
          <target state="translated">Octave는 시작하는 데 약간의 CPU 시간을 사용 했으므로 사용 된 총 CPU 시간이 0이 아닌지 확인하여 &lt;code&gt;cputime&lt;/code&gt; 이 작동하는지 확인하는 것이 합리적 입니다.</target>
        </trans-unit>
        <trans-unit id="bfd60461004995fc31cbdc610eb028645accfe20" translate="yes" xml:space="preserve">
          <source>Note that because Octave&amp;rsquo;s element-by-element operators begin with a &amp;lsquo;</source>
          <target state="translated">Octave의 요소 별 연산자는 '</target>
        </trans-unit>
        <trans-unit id="6cf99de3986d44ff891f155da70c758a04ed6590" translate="yes" xml:space="preserve">
          <source>Note that because of numerical errors in the constraint functions due to round-off and integration error, &lt;small&gt;DASRT&lt;/small&gt; may return false roots, or return the same root at two or more nearly equal values of &lt;var&gt;T&lt;/var&gt;. If such false roots are suspected, the user should consider smaller error tolerances or higher precision in the evaluation of the constraint functions.</source>
          <target state="translated">반올림 및 적분 오류로 인한 구속 조건 함수의 숫자 오류로 인해 &lt;small&gt;DASRT&lt;/small&gt; 는 거짓 근을 리턴하거나 둘 이상의 거의 동일한 &lt;var&gt;T&lt;/var&gt; 값에서 동일한 근을 리턴 할 수 있습니다 . 그러한 허위 근이 의심되는 경우, 사용자는 구속 조건 함수 평가에서 더 작은 오차 허용 오차 또는 더 높은 정밀도를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="23be6a3c453a0108f8db2a124ce9beb2cc841f30" translate="yes" xml:space="preserve">
          <source>Note that both increasing and decreasing the number of nonzero elements in a sparse matrix is expensive as it involves memory reallocation. Also because parts of the matrix, though not its entirety, exist as old and new copies at the same time, additional memory is needed. Therefore, if possible avoid changing capacity.</source>
          <target state="translated">희소 행렬에서 0이 아닌 요소의 수를 늘리거나 줄이면 메모리 재 할당과 관련하여 비용이 많이 듭니다. 또한 매트릭스의 일부가 전체는 아니지만 동시에 이전 및 새 사본으로 존재하므로 추가 메모리가 필요합니다. 따라서 가능하면 용량을 변경하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c1e97dee3a117679df381d8abebc6dbd0acd154c" translate="yes" xml:space="preserve">
          <source>Note that calculated wisdom will be lost when restarting Octave. However, the wisdom data can be reloaded if it is saved to a file as described above. Saved wisdom files should not be used on different platforms since they will not be efficient and the point of calculating the wisdom is lost.</source>
          <target state="translated">옥타브를 다시 시작하면 계산 된 지혜가 사라집니다. 그러나, 지혜 데이터는 전술 한 바와 같이 파일에 저장되면 재로드 될 수있다. 저장된 지혜 파일은 효율적이지 않고 지혜 계산 지점이 손실되므로 다른 플랫폼에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="33577f935031ca5daa96b0459ffa038b0aea67da" translate="yes" xml:space="preserve">
          <source>Note that cell arrays are used less often in standard oct-files and so the</source>
          <target state="translated">셀형 배열은 표준 oct 파일에서 덜 자주 사용되므로</target>
        </trans-unit>
        <trans-unit id="290e273a97ec1132e1ec3934091a8aac8a5845d9" translate="yes" xml:space="preserve">
          <source>Note that demo blocks cannot use any shared variables. This is so that they can be executed by themselves, ignoring all other tests.</source>
          <target state="translated">데모 블록은 공유 변수를 사용할 수 없습니다. 이것은 다른 모든 테스트를 무시하고 스스로 실행할 수 있도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6199219a2f9e04f6eb745b9c5d302a0f9120a278" translate="yes" xml:space="preserve">
          <source>Note that for compatibility with &lt;small&gt;MATLAB&lt;/small&gt;, all objects have a minimum of two dimensions and row vectors are left unchanged.</source>
          <target state="translated">&lt;small&gt;MATLAB&lt;/small&gt; 과의 호환성을 위해 모든 객체는 최소 2 차원이며 행 벡터는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="403ee1766470a62a2b73f63c4f66deb90e78dd57" translate="yes" xml:space="preserve">
          <source>Note that for performance reasons it is better to use handles to existing Octave functions, rather than to define anonymous functions which wrap an existing function. The integration of &lt;code&gt;sin (x)&lt;/code&gt; is 5X faster if the code is written as</source>
          <target state="translated">성능상의 이유로 기존 함수를 래핑하는 익명 함수를 정의하는 대신 기존 Octave 함수에 대한 핸들을 사용하는 것이 좋습니다. 코드를 다음과 같이 작성하면 &lt;code&gt;sin (x)&lt;/code&gt; 의 통합 이 5 배 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="b6ee064847b24ef5182950c24e085ce5c44427e6" translate="yes" xml:space="preserve">
          <source>Note that for some of these choices, the window size at the boundaries is not the same as for the central part, and &lt;var&gt;fcn&lt;/var&gt; must work in these cases.</source>
          <target state="translated">이러한 선택 중 일부의 경우 경계의 창 크기가 중앙 부분과 같지 않으며 이러한 경우 &lt;var&gt;fcn&lt;/var&gt; 이 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="2c6be4a26ea935f01a87fb7807f97b4f2d1f3ce1" translate="yes" xml:space="preserve">
          <source>Note that for symbolic links, &lt;code&gt;dir&lt;/code&gt; returns information about the file that the symbolic link points to rather than the link itself. However, if the link points to a nonexistent file, &lt;code&gt;dir&lt;/code&gt; returns information about the link.</source>
          <target state="translated">심볼릭 링크의 경우 &lt;code&gt;dir&lt;/code&gt; 은 링크 자체가 아니라 심볼릭 링크가 가리키는 파일에 대한 정보를 반환합니다. 그러나 링크가 존재하지 않는 파일을 가리키는 경우 &lt;code&gt;dir&lt;/code&gt; 은 링크에 대한 정보를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7a7a7aad7888d1a30fb1f888f339da8216270064" translate="yes" xml:space="preserve">
          <source>Note that if &lt;var&gt;code&lt;/var&gt; runs successfully, rather than failing, the error printed is:</source>
          <target state="translated">&lt;var&gt;code&lt;/var&gt; 가 실패하지 않고 성공적으로 실행 되면 인쇄되는 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a0661d87ee99507d8648d461be182e9c6bc9647b" translate="yes" xml:space="preserve">
          <source>Note that in conditional contexts (like the test clause of &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;while&lt;/code&gt; statements) Octave treats the test as if you had typed &lt;code&gt;all (all (condition))&lt;/code&gt;.</source>
          <target state="translated">조건문 ( &lt;code&gt;if&lt;/code&gt; 및 &lt;code&gt;while&lt;/code&gt; 문의 test 절과 같은 )에서 Octave는 마치 &lt;code&gt;all (all (condition))&lt;/code&gt; 입력 한 것처럼 테스트를 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="43560cc269e8fa116f51a01e5abad26b5f96381d" translate="yes" xml:space="preserve">
          <source>Note that in some situations it is more efficient to read the entire contents of a file and then process it, than it is to read it line by line. This has the potential advantage of removing the loop in the above code.</source>
          <target state="translated">경우에 따라 파일을 한 줄씩 읽는 것보다 파일의 전체 내용을 읽고 처리하는 것이 더 효율적입니다. 이것은 위 코드에서 루프를 제거 할 수 있다는 잠재적 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f12402a34d48dade196988656912876bb2f95cd1" translate="yes" xml:space="preserve">
          <source>Note that in the above example for &lt;code&gt;cstrcat&lt;/code&gt;, the white space originates from the internal representation of the strings in a string array (see &lt;a href=&quot;character-arrays#Character-Arrays&quot;&gt;Character Arrays&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;cstrcat&lt;/code&gt; 의 위의 예에서 공백은 문자열 배열의 문자열 내부 표현에서 시작됩니다 ( &lt;a href=&quot;character-arrays#Character-Arrays&quot;&gt;문자 배열&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c5f696bd33d09fda8121e0d4b4eee4db247d9b33" translate="yes" xml:space="preserve">
          <source>Note that it is not possible to use function handles or inline functions within a mex-file.</source>
          <target state="translated">mex 파일 내에서는 함수 핸들 또는 인라인 함수를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="94e320a8e494c9b902c468804501876a921ed398" translate="yes" xml:space="preserve">
          <source>Note that it is permissible to use a 1-D index with a multi-dimensional object (also called linear indexing). In this case, the elements of the multi-dimensional array are taken in column-first order like Fortran. That is, the columns of the array are imagined to be stacked on top of each other to form a column vector and then the single linear index is applied to this vector.</source>
          <target state="translated">다차원 개체 (선형 인덱싱이라고도 함)와 함께 1 차원 인덱스를 사용할 수 있습니다. 이 경우 다차원 배열의 요소는 Fortran과 같이 열 우선 순위로 가져옵니다. 즉, 배열의 열이 서로 겹쳐져 열 벡터를 형성 한 다음 단일 선형 인덱스가이 벡터에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="849b6b7c53ee78440ce53ec360d1e65a235c64a6" translate="yes" xml:space="preserve">
          <source>Note that octave must be compiled with multi-threaded &lt;small&gt;FFTW&lt;/small&gt; support for this feature. The number of processors available to the current process is used per default.</source>
          <target state="translated">옥타브는 이 기능에 대한 다중 스레드 &lt;small&gt;FFTW&lt;/small&gt; 지원 으로 컴파일되어야합니다 . 현재 프로세스에 사용 가능한 프로세서 수가 기본적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4ccf85eacc727d518f7f5180953798506dc9684c" translate="yes" xml:space="preserve">
          <source>Note that only the structure of the matrix is used in this calculation based on a Dulmage-Mendelsohn permutation to block triangular form. As such the numerical rank of the matrix &lt;var&gt;S&lt;/var&gt; is bounded by &lt;code&gt;sprank (&lt;var&gt;S&lt;/var&gt;) &amp;gt;= rank (&lt;var&gt;S&lt;/var&gt;)&lt;/code&gt;. Ignoring floating point errors &lt;code&gt;sprank (&lt;var&gt;S&lt;/var&gt;) == rank (&lt;var&gt;S&lt;/var&gt;)&lt;/code&gt;.</source>
          <target state="translated">삼각형의 형태를 막기 위해 Dulmage-Mendelsohn 순열을 기반으로하는이 계산에는 행렬의 구조 만 사용됩니다. 이와 같이, 매트릭스 &lt;var&gt;S&lt;/var&gt; 의 숫자 순위는 스 랭크 &lt;code&gt;sprank (&lt;var&gt;S&lt;/var&gt;) &amp;gt;= rank (&lt;var&gt;S&lt;/var&gt;)&lt;/code&gt; 의해 제한된다 . 부동 소수점 오류 무시 &lt;code&gt;sprank (&lt;var&gt;S&lt;/var&gt;) == rank (&lt;var&gt;S&lt;/var&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3332cc93481fcc27319109e5d7a2231a73a07b9" translate="yes" xml:space="preserve">
          <source>Note that ordinary structure syntax &lt;code&gt;&lt;var&gt;s&lt;/var&gt;.foo bar = 42&lt;/code&gt; cannot be used here, as the field name is not a valid Octave identifier because of the space character. Using arbitrary strings for field names is incompatible with &lt;small&gt;MATLAB&lt;/small&gt;, and this usage will emit a warning if the warning ID &lt;code&gt;Octave:language-extension&lt;/code&gt; is enabled. See &lt;a href=&quot;issuing-warnings#XREFwarning_005fids&quot;&gt;warning_ids&lt;/a&gt;.</source>
          <target state="translated">통상 구조 문법 유의 &lt;code&gt;&lt;var&gt;s&lt;/var&gt;.foo bar = 42&lt;/code&gt; 필드 이름 때문에 공백 문자의 유효 옥타브 식별자 아니므로, 여기에서 사용될 수 없다. 필드 이름에 임의의 문자열을 사용하는 것은 &lt;small&gt;MATLAB&lt;/small&gt; 과 호환되지 않으며 경고 ID &lt;code&gt;Octave:language-extension&lt;/code&gt; 이 활성화 된 경우이 사용법으로 경고가 발생합니다 . &lt;a href=&quot;issuing-warnings#XREFwarning_005fids&quot;&gt;warning_ids를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23b3bfaa4d6091a4c072151ae220b2afd0343694" translate="yes" xml:space="preserve">
          <source>Note that parameters of the Octave type &lt;code&gt;double&lt;/code&gt; are implicitly converted into the Java type &lt;code&gt;double&lt;/code&gt; and the Octave type (array of) &lt;code&gt;char&lt;/code&gt; is converted into the java type &lt;code&gt;String&lt;/code&gt;. A Java object created by &lt;a href=&quot;java-interface-functions#XREFjavaObject&quot;&gt;javaObject&lt;/a&gt; is never automatically converted into an Octave type but remains a Java object. It can be assigned to an Octave variable.</source>
          <target state="translated">Octave 유형 &lt;code&gt;double&lt;/code&gt; 의 매개 변수 는 내재적으로 Java 유형 &lt;code&gt;double&lt;/code&gt; 로 변환되고 Octave 유형 (배열) &lt;code&gt;char&lt;/code&gt; 은 Java 유형 &lt;code&gt;String&lt;/code&gt; 으로 변환됩니다 . &lt;a href=&quot;java-interface-functions#XREFjavaObject&quot;&gt;javaObject&lt;/a&gt; 로 작성된 Java 오브젝트 는 자동으로 Octave 유형으로 변환되지 않지만 Java 오브젝트로 남아 있습니다. 옥타브 변수에 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e386b43a679e5ab0d561ec343c4f066793171b15" translate="yes" xml:space="preserve">
          <source>Note that per default the output argument(s) are arrays of the same size as the input arguments. Input arguments that are singleton (1x1) cells will be automatically expanded to the size of the other arguments.</source>
          <target state="translated">기본적으로 출력 인수는 입력 인수와 동일한 크기의 배열입니다. 싱글 톤 (1x1) 셀인 입력 인수는 다른 인수의 크기로 자동 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="bd6f56d4cd72afa13a880da7318cbfd0587d0415" translate="yes" xml:space="preserve">
          <source>Note that regardless of the value set for &lt;code&gt;output_precision&lt;/code&gt;, the number of digits of precision displayed is limited to 16 for double precision values and 7 for single precision values.</source>
          <target state="translated">&lt;code&gt;output_precision&lt;/code&gt; 에 설정된 값에 관계없이 표시되는 정밀도 자릿수는 배정 밀도 값의 경우 16, 단 정밀도 값의 경우 7로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="4283770704b790ec805c19ea0ed3aa57cf475099" translate="yes" xml:space="preserve">
          <source>Note that some operating systems may place a limit on the number of characters that are recognized after &amp;lsquo;</source>
          <target state="translated">일부 운영 체제에서는 '다음에 인식되는 문자 수에 제한이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e36a773ef709e536a82e2d886a7cd51f572df233" translate="yes" xml:space="preserve">
          <source>Note that the &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="228cf5ce411e402e51050e1a342ee8149da5d23b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;FIRfilter&lt;/code&gt;&amp;rsquo;s display method relies on the &lt;code&gt;disp&lt;/code&gt; method from the &lt;code&gt;polynomial&lt;/code&gt; class to actually display the filter coefficients. Furthermore, note that in the &lt;code&gt;display&lt;/code&gt; method it makes sense to start the method with the line &lt;code&gt;&lt;code&gt;printf (&quot;%s =&quot;, inputname (1))&lt;/code&gt;&lt;/code&gt; to be consistent with the rest of Octave which prints the variable name to be displayed followed by the value. In general it is not recommended to overload the &lt;code&gt;display&lt;/code&gt; function.</source>
          <target state="translated">참고 것을 &lt;code&gt;FIRfilter&lt;/code&gt; 의 표시 방법은 의존 &lt;code&gt;disp&lt;/code&gt; 로부터있어서 &lt;code&gt;polynomial&lt;/code&gt; 실제로 필터 계수들을 표시하는 클래스. 또한 &lt;code&gt;display&lt;/code&gt; 방법에서는 &lt;code&gt;&lt;code&gt;printf (&quot;%s =&quot;, inputname (1))&lt;/code&gt;&lt;/code&gt; 행 ( &quot;% s =&quot;, inputname (1)) 으로 메소드를 시작 하여 나머지 옥타브와 일치하도록 표시하고 변수 이름을 표시 한 다음 값. 일반적으로 &lt;code&gt;display&lt;/code&gt; 기능 에 과부하가 걸리지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a6ed75b60e03ac6029e001f4be1fd72fd94fb3c9" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;elseif&lt;/code&gt; keyword must not be spelled &lt;code&gt;else if&lt;/code&gt;, as is allowed in Fortran. If it is, the space between the &lt;code&gt;else&lt;/code&gt; and &lt;code&gt;if&lt;/code&gt; will tell Octave to treat this as a new &lt;code&gt;if&lt;/code&gt; statement within another &lt;code&gt;if&lt;/code&gt; statement&amp;rsquo;s &lt;code&gt;else&lt;/code&gt; clause. For example, if you write</source>
          <target state="translated">있습니다 &lt;code&gt;elseif&lt;/code&gt; 키워드 철자해서는 안 &lt;code&gt;else if&lt;/code&gt; 포트란에서 허용되는 한,. 그렇다면 &lt;code&gt;else&lt;/code&gt; 와 &lt;code&gt;if&lt;/code&gt; 사이의 공백은 Octave에게 이것을 다른 &lt;code&gt;if&lt;/code&gt; 문의 &lt;code&gt;else&lt;/code&gt; 절 내 에서 새로운 &lt;code&gt;if&lt;/code&gt; 문 으로 취급하도록 지시 합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ca3e6530489520f59234689425691294586390b6" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;sparse_auto_mutate&lt;/code&gt; option is incompatible with &lt;small&gt;MATLAB&lt;/small&gt;, and so it is off by default.</source>
          <target state="translated">있습니다 &lt;code&gt;sparse_auto_mutate&lt;/code&gt; 옵션과 호환되지 &lt;small&gt;MATLAB&lt;/small&gt; , 그것은 기본적으로 꺼져 그래서.</target>
        </trans-unit>
        <trans-unit id="8711780e101c67b78853043ee91ca22f484e7a3f" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;subsref&lt;/code&gt; and &lt;code&gt;subsasgn&lt;/code&gt; methods always receive the whole index chain, while they usually handle only the first element. It is the responsibility of these methods to handle the rest of the chain (if needed), usually by forwarding it again to &lt;code&gt;subsref&lt;/code&gt; or &lt;code&gt;subsasgn&lt;/code&gt;.</source>
          <target state="translated">있습니다 &lt;code&gt;subsref&lt;/code&gt; 및 &lt;code&gt;subsasgn&lt;/code&gt; 그들은 일반적으로 첫 번째 요소를 처리하는 동안 방법은 항상 전체 인덱스 체인을받을 수 있습니다. 이 방법들은 나머지 체인을 (필요한 경우), 일반적으로 &lt;code&gt;subsref&lt;/code&gt; 또는 &lt;code&gt;subsasgn&lt;/code&gt; 에 다시 전달하여 처리해야합니다 .</target>
        </trans-unit>
        <trans-unit id="61711dea7e3a5c88021166213f136fade81e1eb5" translate="yes" xml:space="preserve">
          <source>Note that the application &lt;code&gt;standalone&lt;/code&gt; will be dynamically linked against the Octave libraries and any Octave support libraries. The above allows the Octave math libraries to be used by an application. It does not, however, allow the script files, oct-files, or built-in functions of Octave to be used by the application. To do that, the Octave interpreter needs to be initialized first. An example of how to do this can then be seen in the code</source>
          <target state="translated">애플리케이션 &lt;code&gt;standalone&lt;/code&gt; 은 Octave 라이브러리 및 모든 Octave 지원 라이브러리에 대해 동적으로 링크됩니다. 위의 방법으로 응용 프로그램에서 Octave 수학 라이브러리를 사용할 수 있습니다. 그러나 Octave의 스크립트 파일, oct 파일 또는 내장 기능을 응용 프로그램에서 사용할 수는 없습니다. 이를 위해서는 옥타브 인터프리터를 먼저 초기화해야합니다. 이 작업을 수행하는 방법의 예는 코드에서 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2b59acef35e16400f3261752e3e03084ab50ef1b" translate="yes" xml:space="preserve">
          <source>Note that the code is displayed before it is executed so that a simple comment at the end suffices for labeling what is being shown. For plots, labeling can also be done with &lt;code&gt;title&lt;/code&gt; or &lt;code&gt;text&lt;/code&gt;. It is generally &lt;strong&gt;not&lt;/strong&gt; necessary to use &lt;code&gt;disp&lt;/code&gt; or &lt;code&gt;printf&lt;/code&gt; within the demo.</source>
          <target state="translated">코드는 코드가 실행되기 전에 표시되므로 끝에 간단한 주석이 표시되는 내용을 표시하기에 충분합니다. 플롯의 경우 &lt;code&gt;title&lt;/code&gt; 또는 &lt;code&gt;text&lt;/code&gt; 레이블을 지정할 수도 있습니다 . 일반적으로 데모 내에서 &lt;code&gt;disp&lt;/code&gt; 또는 &lt;code&gt;printf&lt;/code&gt; 를 사용할 필요 는 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2117fd30f25d3f4609013e39a0fddd19a0a9776e" translate="yes" xml:space="preserve">
          <source>Note that the eigenvalues &lt;var&gt;z&lt;/var&gt; are the zeros of the matrix polynomial. &lt;var&gt;z&lt;/var&gt; is a row vector with &lt;code&gt;&lt;var&gt;n&lt;/var&gt;*&lt;var&gt;l&lt;/var&gt;&lt;/code&gt; elements. &lt;var&gt;v&lt;/var&gt; is a matrix (&lt;var&gt;n&lt;/var&gt; x &lt;var&gt;n&lt;/var&gt;*&lt;var&gt;l&lt;/var&gt;) with columns that correspond to the eigenvectors.</source>
          <target state="translated">고유 값 &lt;var&gt;z&lt;/var&gt; 는 행렬 다항식의 0입니다. &lt;var&gt;z&lt;/var&gt; 는 &lt;code&gt;&lt;var&gt;n&lt;/var&gt;*&lt;var&gt;l&lt;/var&gt;&lt;/code&gt; 개의 요소 가있는 행 벡터입니다 . &lt;var&gt;v&lt;/var&gt; 는 고유 벡터에 해당하는 열 이있는 행렬 ( &lt;var&gt;n&lt;/var&gt; x &lt;var&gt;n&lt;/var&gt; * &lt;var&gt;l&lt;/var&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="6cb03a6094bbd3d33933c02a2d53ef7d4dbff450" translate="yes" xml:space="preserve">
          <source>Note that the following relations hold:</source>
          <target state="translated">다음 관계가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="f0b26df5c4322629ef528d8a709cc7811301c8f6" translate="yes" xml:space="preserve">
          <source>Note that the formulation of the integrand uses the element-by-element operator &lt;code&gt;./&lt;/code&gt; and all user functions to &lt;code&gt;quadgk&lt;/code&gt; should do the same.</source>
          <target state="translated">정수의 공식은 요소 별 연산자 &lt;code&gt;./&lt;/code&gt; 를 사용하며 &lt;code&gt;quadgk&lt;/code&gt; 에 대한 모든 사용자 기능 은 동일하게 수행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1145741b11843243567d80169c5fad7a1350c0eb" translate="yes" xml:space="preserve">
          <source>Note that the function name definition is not explicitly included in &lt;code&gt;mexFunction&lt;/code&gt; and so there can only be a single &lt;code&gt;mexFunction&lt;/code&gt; entry point per file. Instead, the name of the function as seen in Octave is determined by the name of the mex-file itself minus the extension. If the above function is in the file</source>
          <target state="translated">함수 이름 정의는 &lt;code&gt;mexFunction&lt;/code&gt; 에 명시 적으로 포함되지 않으므로 파일 당 하나의 &lt;code&gt;mexFunction&lt;/code&gt; 진입 점 만있을 수 있습니다 . 대신 Octave에 표시되는 함수 이름은 확장명을 뺀 mex 파일 이름으로 결정됩니다. 위의 기능이 파일에있는 경우</target>
        </trans-unit>
        <trans-unit id="2d897b1db95de2ddd0f59a41ddb75cebed7913e8" translate="yes" xml:space="preserve">
          <source>Note that the indices do not have to be scalar numbers. For example,</source>
          <target state="translated">인덱스는 스칼라 숫자 일 필요는 없습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="60b2914bf560a976e6e49d4a11403656f14baa8e" translate="yes" xml:space="preserve">
          <source>Note that the matrix type will be discovered automatically on the first attempt to solve a linear equation involving &lt;var&gt;A&lt;/var&gt;. Therefore &lt;code&gt;matrix_type&lt;/code&gt; is only useful to give Octave hints of the matrix type. Incorrectly defining the matrix type will result in incorrect results from solutions of linear equations; it is entirely &lt;strong&gt;the responsibility of the user&lt;/strong&gt; to correctly identify the matrix type.</source>
          <target state="translated">행렬 유형은 &lt;var&gt;A&lt;/var&gt; 와 관련된 선형 방정식을 풀기위한 첫 번째 시도에서 자동으로 발견됩니다 . 따라서 &lt;code&gt;matrix_type&lt;/code&gt; 은 옥타브에 매트릭스 형식의 힌트를 제공하는 데만 유용합니다. 행렬 유형을 잘못 정의하면 선형 방정식의 해에서 결과가 잘못됩니다. 매트릭스 유형을 정확하게 식별하는 것은 전적으로 &lt;strong&gt;사용자의 책임입니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="00be1aa8ba0c432cb655465c429a33e5ef27f378" translate="yes" xml:space="preserve">
          <source>Note that the maximum total number of Newton iterations allowed is &lt;code&gt;MXNIT*MXNJ*MXNH&lt;/code&gt; if the &lt;code&gt;&quot;compute consistent initial
condition&quot;&lt;/code&gt; option has been set to 1 and &lt;code&gt;MXNIT*MXNJ&lt;/code&gt; if it is set to 2.</source>
          <target state="translated">허용 뉴턴 최대 반복 총 수 있음을 유의 &lt;code&gt;MXNIT*MXNJ*MXNH&lt;/code&gt; 경우 생성 &lt;code&gt;&quot;compute consistent initial condition&quot;&lt;/code&gt; 옵션 1에 세트했다 &lt;code&gt;MXNIT*MXNJ&lt;/code&gt; 가 2로 설정되어있는 경우.</target>
        </trans-unit>
        <trans-unit id="ca332db47e2c5502aced85b19febe64c0c7ff526" translate="yes" xml:space="preserve">
          <source>Note that the output from &lt;code&gt;disp&lt;/code&gt; always ends with a newline.</source>
          <target state="translated">&lt;code&gt;disp&lt;/code&gt; 의 출력은 항상 줄 바꿈으로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="77a1eb03c2be1c71908492ca8508273ac22c8525" translate="yes" xml:space="preserve">
          <source>Note that the output from &lt;code&gt;fdisp&lt;/code&gt; always ends with a newline.</source>
          <target state="translated">&lt;code&gt;fdisp&lt;/code&gt; 의 출력은 항상 줄 바꿈으로 끝납니다.</target>
        </trans-unit>
        <trans-unit id="2bda46be44096d4bb0502e6c815f899b0a4a4820" translate="yes" xml:space="preserve">
          <source>Note that the return value of &lt;code&gt;29&lt;/code&gt; means that the breakpoint was effectively set to line 29. The status of breakpoints in a function can be queried with &lt;code&gt;dbstatus&lt;/code&gt;.</source>
          <target state="translated">리턴 값 &lt;code&gt;29&lt;/code&gt; 는 중단 점이 효과적으로 29 행으로 설정되었음을 의미합니다. 함수의 중단 점 상태는 &lt;code&gt;dbstatus&lt;/code&gt; 를 사용 하여 조회 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2755ba6814f7a6260a1f59fb4e6436df65f13098" translate="yes" xml:space="preserve">
          <source>Note that the return value of the constructor must be the output of the &lt;code&gt;class&lt;/code&gt; function. The first argument to the &lt;code&gt;class&lt;/code&gt; function is a structure and the second is the name of the class itself. An example of calling the class constructor to create an instance is</source>
          <target state="translated">생성자의 반환 값은 &lt;code&gt;class&lt;/code&gt; 함수 의 출력이어야합니다 . &lt;code&gt;class&lt;/code&gt; 함수 의 첫 번째 인수 는 구조이고 두 번째 인수 는 클래스 자체의 이름입니다. 인스턴스 생성을 위해 클래스 생성자를 호출하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10019b334871cdac6b76aa602f580ab570717489" translate="yes" xml:space="preserve">
          <source>Note that the same result as in the above example could be achieved by:</source>
          <target state="translated">위 예제와 동일한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db2a2afc8eb171d81a8ec3a847c866298bebf49f" translate="yes" xml:space="preserve">
          <source>Note that the sample code always provides for the case in which no arguments are supplied. This is important because Octave will call a constructor with no arguments when loading objects from saved files in order to determine the inheritance structure.</source>
          <target state="translated">샘플 코드는 항상 인수가 제공되지 않은 경우를 제공합니다. 이는 Octave가 상속 구조를 결정하기 위해 저장된 파일에서 객체를로드 할 때 인수없이 생성자를 호출하기 때문에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="c7994d2bbd75b75324f96ce051ec00ec3a7f1ce9" translate="yes" xml:space="preserve">
          <source>Note that the total number of elements in the original matrix (&lt;code&gt;prod (size (&lt;var&gt;A&lt;/var&gt;))&lt;/code&gt;) must match the total number of elements in the new matrix (&lt;code&gt;prod ([&lt;var&gt;m&lt;/var&gt; &lt;var&gt;n&lt;/var&gt; &amp;hellip;])&lt;/code&gt;).</source>
          <target state="translated">원래 행렬의 총 요소 수 ( &lt;code&gt;prod (size (&lt;var&gt;A&lt;/var&gt;))&lt;/code&gt; )는 새 행렬의 총 요소 수 ( &lt;code&gt;prod ([&lt;var&gt;m&lt;/var&gt; &lt;var&gt;n&lt;/var&gt; &amp;hellip;])&lt;/code&gt; ) 와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2e69b3089d76542dcd5969d99f46ffa124bae2d2" translate="yes" xml:space="preserve">
          <source>Note that the true result is &lt;em&gt;+/- sqrt(5)&lt;/em&gt; which is roughly &lt;em&gt;+/- 2.2361&lt;/em&gt;.</source>
          <target state="translated">실제 결과는 &lt;em&gt;+/- sqrt (5)&lt;/em&gt; 이며 대략 &lt;em&gt;+/- 2.2361&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a0b650af9d0617ea74f861dbb14e255c18c785bd" translate="yes" xml:space="preserve">
          <source>Note that the upper (or lower, if the increment is negative) bound on the range is not always included in the set of values, and that ranges defined by floating point values can produce surprising results because Octave uses floating point arithmetic to compute the values in the range. If it is important to include the endpoints of a range and the number of elements is known, you should use the &lt;code&gt;linspace&lt;/code&gt; function instead (see &lt;a href=&quot;special-utility-matrices#Special-Utility-Matrices&quot;&gt;Special Utility Matrices&lt;/a&gt;).</source>
          <target state="translated">범위에서 상한 (또는 증분이 음수 인 경우 하한)이 항상 값 세트에 포함되는 것은 아니며 부동 소수점 값으로 정의 된 범위는 옥타브가 부동 소수점 산술을 사용하여 값을 계산하므로 놀라운 결과를 생성 할 수 있습니다. 범위 안에서. 범위의 끝점을 포함시키는 것이 중요하고 요소 수를 알고있는 경우에는 &lt;code&gt;linspace&lt;/code&gt; 함수를 대신 사용해야합니다 ( &lt;a href=&quot;special-utility-matrices#Special-Utility-Matrices&quot;&gt;특수 유틸리티 행렬&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="55f7b5bc82b1db20cb74f6a08cb90aa819614046" translate="yes" xml:space="preserve">
          <source>Note that these functions do significant error checking and so in some circumstances the user might prefer to access the data of the array or matrix directly through the &lt;code&gt;fortran_vec&lt;/code&gt; method discussed below.</source>
          <target state="translated">이러한 함수는 중대한 오류 검사를 수행하므로 일부 상황에서 사용자는 아래에 설명 된 &lt;code&gt;fortran_vec&lt;/code&gt; 메소드를 통해 직접 배열 또는 행렬의 데이터에 액세스하는 것을 선호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2e4c8a79ff02a65e5217b7bcdabacd50154ee2c" translate="yes" xml:space="preserve">
          <source>Note that this does not enable the &lt;code&gt;Octave:language-extension&lt;/code&gt; warning, which you might want if you want to be told about writing code that works in Octave but not &lt;small&gt;MATLAB&lt;/small&gt; (see &lt;a href=&quot;issuing-warnings#XREFwarning&quot;&gt;warning&lt;/a&gt;, &lt;a href=&quot;issuing-warnings#XREFwarning_005fids&quot;&gt;warning_ids&lt;/a&gt;).</source>
          <target state="translated">이렇게하면 &lt;code&gt;Octave:language-extension&lt;/code&gt; 경고를 사용할 수 없습니다. 이는 Octave에서는 작동하지만 &lt;small&gt;MATLAB&lt;/small&gt; 에서는 작동하지 않는 코드 작성에 대한 정보를 원할 경우에 유용 &lt;small&gt;합니다&lt;/small&gt; ( &lt;a href=&quot;issuing-warnings#XREFwarning&quot;&gt;warning&lt;/a&gt; , &lt;a href=&quot;issuing-warnings#XREFwarning_005fids&quot;&gt;warning_ids&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d0794545d8f18a0052e326536ca4f9f030e563a3" translate="yes" xml:space="preserve">
          <source>Note that this function could not have been written using the &lt;code&gt;break&lt;/code&gt; statement to exit the loop once a nonzero value is found without adding extra logic to avoid printing the message if the vector does contain a nonzero element.</source>
          <target state="translated">벡터에 0이 아닌 요소가 포함 된 경우 메시지를 인쇄하지 않도록 논리를 추가하지 않고 0이 아닌 값을 찾으면 &lt;code&gt;break&lt;/code&gt; 문을 사용하여 루프를 종료하기 위해이 함수를 작성할 수 없었 습니다 .</target>
        </trans-unit>
        <trans-unit id="210dbb15aacc730d0dae1e899ae8e36a57111121" translate="yes" xml:space="preserve">
          <source>Note that this function evaluates &lt;code&gt;nargin&lt;/code&gt; on the caller.</source>
          <target state="translated">이 함수 는 발신자에 대한 &lt;code&gt;nargin&lt;/code&gt; 를 평가 합니다.</target>
        </trans-unit>
        <trans-unit id="2aafdff8d7afeb4f9c4ba48c75c3414aa473c301" translate="yes" xml:space="preserve">
          <source>Note that this function is particularly useful for sparse matrices, as it extracts the nonzero elements as vectors, which can then be used to create the original matrix. For example:</source>
          <target state="translated">이 함수는 0이 아닌 요소를 벡터로 추출하여 원래 행렬을 만드는 데 사용할 수 있으므로 희소 행렬에 특히 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07935c316367fad63be584bb1fc61d01a185cf31" translate="yes" xml:space="preserve">
          <source>Note that this is only meant to be an example of calling user-supplied functions and should not be taken too seriously. In addition to using a more robust algorithm, any serious code would check the number and type of all the arguments, ensure that the supplied function really was a function, etc. See &lt;a href=&quot;predicates-for-numeric-objects#Predicates-for-Numeric-Objects&quot;&gt;Predicates for Numeric Objects&lt;/a&gt;, for a list of predicates for numeric objects, and see &lt;a href=&quot;status-of-variables#Status-of-Variables&quot;&gt;Status of Variables&lt;/a&gt;, for a description of the &lt;code&gt;exist&lt;/code&gt; function.</source>
          <target state="translated">이것은 사용자 제공 함수를 호출하는 예일 뿐이며 너무 심각하게 받아 들여서는 안됩니다. 보다 강력한 알고리즘을 사용하는 것 외에도 심각한 코드는 모든 인수의 수와 유형을 확인하고 제공된 함수가 실제로 함수 등인지 확인 &lt;a href=&quot;predicates-for-numeric-objects#Predicates-for-Numeric-Objects&quot;&gt;합니다. 숫자 오브젝트&lt;/a&gt; 의 술어 목록은 숫자 오브젝트의 술어를 참조하십시오 . &lt;code&gt;exist&lt;/code&gt; 함수 에 대한 설명 &lt;a href=&quot;status-of-variables#Status-of-Variables&quot;&gt;은 변수 상태를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8af54d33e5b3f631df6133cc27f05aa4d6a783f3" translate="yes" xml:space="preserve">
          <source>Note that this is the representation of these elements with the first row and column assumed to start at zero, while in Octave itself the row and column indexing starts at one. Thus the number of elements in the &lt;var&gt;i&lt;/var&gt;-th column is given by &lt;code&gt;&lt;var&gt;cidx&lt;/var&gt; (&lt;var&gt;i&lt;/var&gt; + 1) -
&lt;var&gt;cidx&lt;/var&gt; (&lt;var&gt;i&lt;/var&gt;)&lt;/code&gt;.</source>
          <target state="translated">이것은 첫 번째 행과 열이 0에서 시작하는 것으로 가정되는 반면, 옥타브 자체에서는 행과 열 색인이 하나에서 시작되는 것으로 가정됩니다. 따라서 &lt;var&gt;i&lt;/var&gt; 번째 열의 요소 수는 &lt;code&gt;&lt;var&gt;cidx&lt;/var&gt; (&lt;var&gt;i&lt;/var&gt; + 1) - &lt;var&gt;cidx&lt;/var&gt; (&lt;var&gt;i&lt;/var&gt;)&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="9fd495e3915708c8614fcce984eacb66c771283b" translate="yes" xml:space="preserve">
          <source>Note that this is the same as writing &lt;code&gt;val(:, 1:2) = 0&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;val(:, 1:2) = 0&lt;/code&gt; 을 쓰는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="535f6fb9b5ed3833406e222160e724cc9dc8ca5f" translate="yes" xml:space="preserve">
          <source>Note that this is the same as writing &lt;code&gt;val(:, 1:2)&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;val(:, 1:2)&lt;/code&gt; 작성과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="00cff69b5cb775729d63a2a0f414564d52dbdba6" translate="yes" xml:space="preserve">
          <source>Note that user classes &lt;em&gt;always&lt;/em&gt; have higher precedence than built-in Octave types. Thus, marking the polynomial class higher than the &lt;code&gt;&quot;double&quot;&lt;/code&gt; class is not actually necessary.</source>
          <target state="translated">사용자 클래스는 &lt;em&gt;항상&lt;/em&gt; 내장 옥타브 형식보다 우선 순위가 높습니다. 따라서 다항식 클래스를 &lt;code&gt;&quot;double&quot;&lt;/code&gt; 클래스 보다 높게 표시하는 것은 실제로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f70900913cdce10686cc0a6bb647c4e627c01a2b" translate="yes" xml:space="preserve">
          <source>Note that version &lt;code&gt;&quot;1.1-test2&quot;&lt;/code&gt; will compare as greater than &lt;code&gt;&quot;1.1-test10&quot;&lt;/code&gt;. Also, since the numeric part is compared first, &lt;code&gt;&quot;a&quot;&lt;/code&gt; compares less than &lt;code&gt;&quot;1a&quot;&lt;/code&gt; because the second string starts with a numeric part even though &lt;code&gt;double (&quot;a&quot;)&lt;/code&gt; is greater than &lt;code&gt;double (&quot;1&quot;).&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&quot;1.1-test2&quot;&lt;/code&gt; 버전 은 &lt;code&gt;&quot;1.1-test10&quot;&lt;/code&gt; 보다 큰 것으로 비교됩니다 . 또한 숫자 부분을 먼저 비교 하기 때문에 &lt;code&gt;double (&quot;a&quot;)&lt;/code&gt; 이 &lt;code&gt;double (&quot;1&quot;).&lt;/code&gt; 보다 큰 경우에도 두 번째 문자열이 숫자 부분으로 시작하기 때문에 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 는 &lt;code&gt;&quot;1a&quot;&lt;/code&gt; 보다 작습니다 .</target>
        </trans-unit>
        <trans-unit id="60d307e3e43b200c7f2daf6d1061150f7b9efa4b" translate="yes" xml:space="preserve">
          <source>Note that when Octave is started from an executable script, the built-in function &lt;code&gt;argv&lt;/code&gt; returns a cell array containing the command line arguments passed to the executable Octave script, not the arguments passed to the Octave interpreter on the &amp;lsquo;</source>
          <target state="translated">실행 가능 스크립트에서 Octave가 시작되면 내장 함수 &lt;code&gt;argv&lt;/code&gt; 는 '옥타브 인터프리터에 전달 된 인수가 아니라 실행 가능 Octave 스크립트에 전달 된 명령 행 인수를 포함하는 셀형 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="da349bc1f431a8408fc04e38c184a1ab5e996cb9" translate="yes" xml:space="preserve">
          <source>Note that when Octave prints the value of a structure that contains other structures, only a few levels are displayed. For example:</source>
          <target state="translated">Octave가 다른 구조를 포함하는 구조의 값을 인쇄 할 때는 몇 가지 수준 만 표시됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dbfad04950632b2e7aae6e021435f9f0802af74d" translate="yes" xml:space="preserve">
          <source>Note the type &lt;code&gt;mwSize&lt;/code&gt; used above, and also &lt;code&gt;mwIndex&lt;/code&gt;, are defined as the native precision of the indexing in Octave on the platform on which the mex-file is built. This allows both 32- and 64-bit platforms to support mex-files. &lt;code&gt;mwSize&lt;/code&gt; is used to define array dimensions and the maximum number or elements, while &lt;code&gt;mwIndex&lt;/code&gt; is used to define indexing into arrays.</source>
          <target state="translated">위에서 사용 된 &lt;code&gt;mwSize&lt;/code&gt; 유형 및 &lt;code&gt;mwIndex&lt;/code&gt; 도 mex-file이 빌드 된 플랫폼에서 Octave의 인덱싱의 기본 정밀도로 정의됩니다. 이를 통해 32 비트 및 64 비트 플랫폼 모두 mex 파일을 지원할 수 있습니다. &lt;code&gt;mwSize&lt;/code&gt; 는 배열 차원과 최대 수 또는 요소 를 정의하는 데 사용되는 반면 &lt;code&gt;mwIndex&lt;/code&gt; 는 배열에 대한 색인을 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2a66bf129d08c7249a582bcb8effea7424a8e789" translate="yes" xml:space="preserve">
          <source>Note the usage of colon indexing to flatten an intermediate result into a column vector. This is a common vectorization trick.</source>
          <target state="translated">콜론 인덱싱을 사용하여 중간 결과를 열 벡터로 병합합니다. 이것은 일반적인 벡터화 트릭입니다.</target>
        </trans-unit>
        <trans-unit id="3f8f8477f072a9b44e5db8a7585629240b385140" translate="yes" xml:space="preserve">
          <source>Note the usage of permute to match the dimensions of the &lt;code&gt;[0.8, 0.9, 1.2]&lt;/code&gt; vector with &lt;code&gt;img&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[0.8, 0.9, 1.2]&lt;/code&gt; 벡터 의 치수 와 &lt;code&gt;img&lt;/code&gt; 를 일치시키기 위해 permute의 사용법에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c53952e09a8c01b420716fc60878b19d16507d2" translate="yes" xml:space="preserve">
          <source>Note the use of the &amp;lsquo;dot&amp;rsquo; forms of the operators. This is not necessary for the &lt;code&gt;quad&lt;/code&gt; integrator, but is required by the other integrators. In any case, it makes it much easier to generate a set of points for plotting because it is possible to call the function with a vector argument to produce a vector result.</source>
          <target state="translated">'도트'형식의 연산자 사용에 유의하십시오. 이것은 &lt;code&gt;quad&lt;/code&gt; 적분기 에는 필요하지 않지만 다른 적분기에는 필요합니다. 어쨌든 벡터 인수로 함수를 호출하여 벡터 결과를 생성 할 수 있기 때문에 플로팅을위한 점 세트를 훨씬 쉽게 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="900ee21b43648ac8a082db521a256ab742c54fc7" translate="yes" xml:space="preserve">
          <source>Note this is just a variation on convolution, with the parameters reversed and &lt;var&gt;b&lt;/var&gt; rotated 180 degrees.</source>
          <target state="translated">이것은 컨벌루션의 변형 일 뿐이며, 매개 변수가 반전되고 &lt;var&gt;b&lt;/var&gt; 가 180도 회전 된 상태입니다.</target>
        </trans-unit>
        <trans-unit id="b06131c576ed8cc38fe51366a29f7953f4c6080a" translate="yes" xml:space="preserve">
          <source>Note, however, that both types of strings are represented by the &lt;code&gt;charNDArray&lt;/code&gt; type, and so when assigning to an &lt;code&gt;octave_value&lt;/code&gt;, the type of string should be specified. For example:</source>
          <target state="translated">참고하지만, 문자열의 두 가지 유형이로 표현되는 &lt;code&gt;charNDArray&lt;/code&gt; 의 유형 및에 할당 할 때, 그래서 &lt;code&gt;octave_value&lt;/code&gt; , 문자열의 유형을 지정해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="74111d5dd6bf634ab7690e6ecf78b418038ea362" translate="yes" xml:space="preserve">
          <source>Note, that the above can also be achieved like this:</source>
          <target state="translated">위와 같이하면 다음과 같이 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e1e64a5130efed8366e156a802caff24f68ff8e" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;fullfile&lt;/code&gt; does not perform any validation of the resulting full filename.</source>
          <target state="translated">참고 : &lt;code&gt;fullfile&lt;/code&gt; 은 결과 전체 파일 이름의 유효성 검사를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d773bae94b5210702730ed1d6d0933760dff579" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;quadcc&lt;/code&gt; is a general purpose quadrature algorithm and, as such, may be less efficient for a smooth or otherwise well-behaved integrand than other methods such as &lt;code&gt;quadgk&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;quadcc&lt;/code&gt; 는 범용 쿼드 러처 알고리즘이므로 &lt;code&gt;quadgk&lt;/code&gt; 와 같은 다른 방법보다 매끄 럽거나 제대로 작동하는 데 덜 효율적일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="633e6bc793899748b65b9a8ecf4a38d6c8aef60e" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;quadv&lt;/code&gt; is written in Octave&amp;rsquo;s scripting language and can be used recursively in &lt;code&gt;dblquad&lt;/code&gt; and &lt;code&gt;triplequad&lt;/code&gt;, unlike the &lt;code&gt;quad&lt;/code&gt; function.</source>
          <target state="translated">참고 : &lt;code&gt;quadv&lt;/code&gt; 는 Octave의 스크립팅 언어로 작성되었으며 &lt;code&gt;quad&lt;/code&gt; 함수 와 달리 &lt;code&gt;dblquad&lt;/code&gt; 및 &lt;code&gt;triplequad&lt;/code&gt; 에서 재귀 적으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="219d2ca3f50554ac106f43e2050c600373cf0885" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;qz&lt;/code&gt; performs permutation balancing, but not scaling (see &lt;a href=&quot;basic-matrix-functions#XREFbalance&quot;&gt;balance&lt;/a&gt;), which may be lead to less accurate results than &lt;code&gt;eig&lt;/code&gt;. The order of output arguments was selected for compatibility with &lt;small&gt;MATLAB&lt;/small&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;qz&lt;/code&gt; 는 순열 밸런싱을 수행하지만 스케일링 ( &lt;a href=&quot;basic-matrix-functions#XREFbalance&quot;&gt;밸런스&lt;/a&gt; 참조 )을 수행하지 않으므로 &lt;code&gt;eig&lt;/code&gt; 보다 정확도가 떨어 집니다. &lt;small&gt;MATLAB&lt;/small&gt; 과의 호환성을 위해 출력 인수의 순서가 선택되었습니다 .</target>
        </trans-unit>
        <trans-unit id="8df0482c9d861b48697790ef03c698d2c7fc8a98" translate="yes" xml:space="preserve">
          <source>Note: &lt;var&gt;n&lt;/var&gt; must be a scalar greater than or equal to 3. If you supply &lt;var&gt;n&lt;/var&gt; less than 3, magic returns either a nonmagic square, or else the degenerate magic squares 1 and [].</source>
          <target state="translated">참고 : &lt;var&gt;n&lt;/var&gt; 보다 스칼라 클 수 또는 제공하는 경우 3. 동일해야합니다 &lt;var&gt;n&lt;/var&gt; 미만 3, 마법 리턴한다 nonmagic 광장, 그렇지 않으면 퇴화 마술 사각형 1 [] 중 하나를.</target>
        </trans-unit>
        <trans-unit id="05d2965c014c837d087db29411a93d5d540ef640" translate="yes" xml:space="preserve">
          <source>Note: For compatibility with &lt;small&gt;MATLAB&lt;/small&gt; a line is drawn through all data points. However, most scientific errorbar plots are a scatter plot of points with errorbars. To accomplish this, add a marker style to the &lt;var&gt;fmt&lt;/var&gt; argument such as &lt;code&gt;&quot;.&quot;&lt;/code&gt;. Alternatively, remove the line by modifying the returned graphic handle with &lt;code&gt;set (h, &quot;linestyle&quot;, &quot;none&quot;)&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;small&gt;MATLAB&lt;/small&gt; 과의 호환성을 위해 모든 데이터 포인트에 선이 그려집니다. 그러나 대부분의 과학적 오차 막대 그림은 오차 막대가있는 점의 산점도입니다. 이를 위해 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 와 같은 &lt;var&gt;fmt&lt;/var&gt; 인수에 마커 스타일을 추가하십시오 . . 또는 반환 된 그래픽 핸들을 &lt;code&gt;set (h, &quot;linestyle&quot;, &quot;none&quot;)&lt;/code&gt; 으로 수정하여 줄을 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="eb1c29a862d495d925177df64fe02deb501ee0e2" translate="yes" xml:space="preserve">
          <source>Note: For compatibility, this function uses the &lt;small&gt;MATLAB&lt;/small&gt; definition of the exponential integral. Most other sources refer to this particular value as &lt;em&gt;E_1 (x)&lt;/em&gt;, and the exponential integral as</source>
          <target state="translated">참고 : 호환성을 위해이 함수는 지수 적분 의 &lt;small&gt;MATLAB&lt;/small&gt; 정의를 사용합니다 . 대부분의 다른 소스는이 특정 값을 &lt;em&gt;E_1 (x)로&lt;/em&gt; , 지수 적분을</target>
        </trans-unit>
        <trans-unit id="a2b5f78e539df59edf23d3100fc43834b618f6e8" translate="yes" xml:space="preserve">
          <source>Note: If &lt;code&gt;sum (&lt;var&gt;x&lt;/var&gt;) &amp;le; 1&lt;/code&gt; then the elements of &lt;var&gt;x&lt;/var&gt; are interpreted as percentages directly and are not normalized by &lt;code&gt;sum
(x)&lt;/code&gt;. Furthermore, if the sum is less than 1 then there will be a missing slice in the pie plot to represent the missing, unspecified percentage.</source>
          <target state="translated">참고하면 &lt;code&gt;sum (&lt;var&gt;x&lt;/var&gt;) &amp;le; 1&lt;/code&gt; 다음의 원소 &lt;var&gt;x&lt;/var&gt; 직접 백분율로 해석되고 정규화되지 &lt;code&gt;sum (x)&lt;/code&gt; . 또한, 합계가 1보다 작 으면 파이 플롯에 누락 된 슬라이스가있어 지정되지 않은 누락 된 백분율을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="31cd487a7eb19e0f451296d6e08323b642967e38" translate="yes" xml:space="preserve">
          <source>Note: If there are no tick marks for an axes then there can be no labels.</source>
          <target state="translated">참고 : 축에 눈금이 없으면 레이블이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d80e5f2eb25d596e2bb4ef15b56b1a068082f5d8" translate="yes" xml:space="preserve">
          <source>Note: If you need a specific number of primes you can use the fact that the distance from one prime to the next is, on average, proportional to the logarithm of the prime. Integrating, one finds that there are about &lt;em&gt;k&lt;/em&gt; primes less than k*log (5*k).</source>
          <target state="translated">참고 : 특정 소수의 소수가 필요한 경우 한 소수에서 다음 소수까지의 거리가 평균적으로 소수의 로그에 비례한다는 사실을 사용할 수 있습니다. 적분하면 k * log (5 * k)보다 약 &lt;em&gt;k 개의&lt;/em&gt; 소수 가 있음을 알 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6786826d7e4d01f9c656010935df125ded702461" translate="yes" xml:space="preserve">
          <source>Note: If you need to find the minimum of a single variable function it is probably better to use &lt;code&gt;fminbnd&lt;/code&gt;.</source>
          <target state="translated">참고 : 단일 변수 함수의 최소값을 찾아야하는 경우 &lt;code&gt;fminbnd&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ea0155c906e3d8ba6845e4b1dc195d61fb21f301" translate="yes" xml:space="preserve">
          <source>Note: If you only have a single nonlinear equation of one variable, using &lt;code&gt;fzero&lt;/code&gt; is usually a much better idea.</source>
          <target state="translated">참고 : 하나의 변수로 구성된 단일 비선형 방정식 만있는 경우 &lt;code&gt;fzero&lt;/code&gt; 를 사용 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0ee355e067ed0692c6aee777e9e4b58b1489fba0" translate="yes" xml:space="preserve">
          <source>Note: The Givens matrix represents a counterclockwise rotation of a 2-D plane and can be used to introduce zeros into a matrix prior to complete factorization.</source>
          <target state="translated">참고 : Givens 행렬은 2 차원 평면의 시계 반대 방향 회전을 나타내며 완전한 인수 분해 전에 행렬에 0을 도입하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5790e6a67a79fe70215760d6b42e26c2bad0f71" translate="yes" xml:space="preserve">
          <source>Note: The exact appearance of the surface can be controlled with the &lt;code&gt;shading&lt;/code&gt; command or by using &lt;code&gt;set&lt;/code&gt; to control surface object properties.</source>
          <target state="translated">주 : 표면의 정확한 모양은 &lt;code&gt;shading&lt;/code&gt; 명령을 사용하거나 &lt;code&gt;set&lt;/code&gt; 을 사용하여 표면 객체 속성을 제어 하여 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="182699fe184551d6fcd557c94dcbea9f12e3613f" translate="yes" xml:space="preserve">
          <source>Note: This variable is only used when Octave is initializing itself. Modifying it during a running session of Octave will have no effect.</source>
          <target state="translated">참고 :이 변수는 Octave가 자체 초기화 될 때만 사용됩니다. Octave 실행 세션 중에이를 수정해도 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c57d231c618e8a007e9932c95738534f7c8d0c99" translate="yes" xml:space="preserve">
          <source>Note: To find the current axes without creating a new axes object if it does not exist, query the &lt;code&gt;&quot;CurrentAxes&quot;&lt;/code&gt; property of a figure.</source>
          <target state="translated">참고 : 존재하지 않는 경우 새 좌표축 개체를 만들지 않고 현재 좌표축을 찾으려면 그림 의 &lt;code&gt;&quot;CurrentAxes&quot;&lt;/code&gt; 속성을 쿼리하십시오 .</target>
        </trans-unit>
        <trans-unit id="21c2ef88933ddd4b4501a0924d316c6bc3ddd4d8" translate="yes" xml:space="preserve">
          <source>Note: To find the current figure without creating a new one if it does not exist, query the &lt;code&gt;&quot;CurrentFigure&quot;&lt;/code&gt; property of the root graphics object.</source>
          <target state="translated">참고 : 존재하지 않는 경우 새 그림을 작성하지 않고 현재 그림을 찾으려면 루트 그래픽스 객체 의 &lt;code&gt;&quot;CurrentFigure&quot;&lt;/code&gt; 속성을 쿼리하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c63c680c4b0e6ef8be7d1a2ce98bee5113c756f" translate="yes" xml:space="preserve">
          <source>Note: Using &lt;code&gt;repelem&lt;/code&gt; with a vector &lt;var&gt;x&lt;/var&gt; and a vector for &lt;var&gt;R_j&lt;/var&gt; is equivalent to Run Length Decoding.</source>
          <target state="translated">참고 : &lt;code&gt;repelem&lt;/code&gt; 에 대해 벡터 &lt;var&gt;x&lt;/var&gt; 및 벡터에 대해 &lt;var&gt;R_j&lt;/var&gt; 을 사용하는 것은 실행 길이 디코딩과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6eeb826e3cfa5ea4df58eaf35749fe08596fbe8c" translate="yes" xml:space="preserve">
          <source>Note: because &lt;code&gt;quad&lt;/code&gt; is written in Fortran it cannot be called recursively. This prevents its use in integrating over more than one variable by routines &lt;code&gt;dblquad&lt;/code&gt; and &lt;code&gt;triplequad&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;quad&lt;/code&gt; 는 포트란으로 작성 되므로 재귀 적으로 호출 할 수 없습니다. 이것은 &lt;code&gt;dblquad&lt;/code&gt; 및 &lt;code&gt;triplequad&lt;/code&gt; 루틴에 의해 하나 이상의 변수를 통합하는 데 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a13a315cd5b49404d8655a654b30468771483dab" translate="yes" xml:space="preserve">
          <source>Note: only CSV files containing numeric data can be read.</source>
          <target state="translated">참고 : 숫자 데이터가 포함 된 CSV 파일 만 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac09060b6ba1262e5b19423a76ad1c1170416774" translate="yes" xml:space="preserve">
          <source>Note: the following only applies to systems that have 64-bit pointers. Configuring Octave with</source>
          <target state="translated">참고 : 다음은 64 비트 포인터가있는 시스템에만 적용됩니다. 옥타브 구성</target>
        </trans-unit>
        <trans-unit id="30f8d2e38ed8c7f3b974a2540fdd14e163822c37" translate="yes" xml:space="preserve">
          <source>Notes for the C Programmer</source>
          <target state="translated">C 프로그래머를위한 참고 사항</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="e51443fffacab700dcc08997d3c849facc3f9f48" translate="yes" xml:space="preserve">
          <source>Notice how</source>
          <target state="translated">어떻게 통지</target>
        </trans-unit>
        <trans-unit id="25c93ad777b8cfda842f8a619a74942eb77ed1f6" translate="yes" xml:space="preserve">
          <source>Notice that the first value appears to be 0 when it is actually 1. Because of the possibility for confusion you should be careful about enabling &lt;code&gt;fixed_point_format&lt;/code&gt;.</source>
          <target state="translated">실제로 1 일 때 첫 번째 값은 0으로 나타납니다. 혼동 될 가능성이 있으므로 &lt;code&gt;fixed_point_format&lt;/code&gt; 사용에 주의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="09f8c359cd07d3bb7f5499d88d1fc5ec4b244667" translate="yes" xml:space="preserve">
          <source>Notice that the size of the returned object in a given dimension is equal to the number of elements in the index expression for that dimension. In the code above, the first index component (&lt;code&gt;[1, 2]&lt;/code&gt;) was specified as a row vector, but its shape is unimportant. The important fact is that the component specified two values, and hence the result must have a size of two in the first dimension; and because the first dimension corresponds to rows, the overall result is a column vector.</source>
          <target state="translated">주어진 차원에서 반환 된 개체의 크기는 해당 차원에 대한 인덱스 식의 요소 수와 같습니다. 위의 코드에서 첫 번째 인덱스 구성 요소 ( &lt;code&gt;[1, 2]&lt;/code&gt; )는 행 벡터로 지정되었지만 그 모양은 중요하지 않습니다. 중요한 사실은 구성 요소가 두 개의 값을 지정 했으므로 결과는 첫 번째 차원에서 2의 크기를 가져야한다는 것입니다. 첫 번째 차원은 행에 해당하므로 전체 결과는 열 벡터입니다.</target>
        </trans-unit>
        <trans-unit id="272c7440ddc9e59e92363c27905abc8872737316" translate="yes" xml:space="preserve">
          <source>Notice that there is no special syntax for sharing &lt;var&gt;x&lt;/var&gt;. This can lead to problems with accidental variable sharing between a parent function and its child. While normally variables are inherited, child function parameters and return values are local to the child function.</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt; 공유를위한 특별한 구문은 없습니다 . 이로 인해 부모 함수와 해당 자식간에 실수로 변수를 공유하는 데 문제가 발생할 수 있습니다. 일반적으로 변수는 상속되지만 자식 함수 매개 변수와 반환 값은 자식 함수에 로컬입니다.</target>
        </trans-unit>
        <trans-unit id="e4033a819b7bc6bd331e68eb166aeb0fd8b57f3e" translate="yes" xml:space="preserve">
          <source>Notice the blank lines, except for the &amp;lsquo;</source>
          <target state="translated">'을 제외한 빈 줄을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2af5314679ea13bd0c9e99d933a68373c4377661" translate="yes" xml:space="preserve">
          <source>Now consider the function &lt;code&gt;foobar&lt;/code&gt; that uses variables &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt;. &lt;code&gt;foobar&lt;/code&gt; calls a nested function &lt;code&gt;foo&lt;/code&gt; which takes &lt;var&gt;x&lt;/var&gt; as a parameter and returns &lt;var&gt;y&lt;/var&gt;. &lt;code&gt;foo&lt;/code&gt; then calls &lt;code&gt;bat&lt;/code&gt; which does some computation.</source>
          <target state="translated">이제 변수 &lt;var&gt;x&lt;/var&gt; 와 &lt;var&gt;y&lt;/var&gt; 를 사용하는 &lt;code&gt;foobar&lt;/code&gt; 함수를 고려하십시오 . &lt;code&gt;foobar&lt;/code&gt; 는 중첩 함수 &lt;code&gt;foo&lt;/code&gt; 를 호출하여 &lt;var&gt;x&lt;/var&gt; 를 매개 변수로 사용하고 &lt;var&gt;y&lt;/var&gt; 를 반환합니다 . 그런 다음 &lt;code&gt;foo&lt;/code&gt; 는 &lt;code&gt;bat&lt;/code&gt; 를 호출 하여 계산을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9aa141c6944770e4bc1df4850ca4bc42ba53b767" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s take a look at &lt;code&gt;bar&lt;/code&gt;. For this, we start a fresh profiling session (&lt;code&gt;profile on&lt;/code&gt; does this; the old data is removed before the profiler is restarted):</source>
          <target state="translated">이제 &lt;code&gt;bar&lt;/code&gt; 를 살펴 보자 . 이를 위해 새로운 프로파일 링 세션을 시작합니다 ( &lt;code&gt;profile on&lt;/code&gt; : 프로파일 러가 다시 시작되기 전에 이전 데이터가 제거됨).</target>
        </trans-unit>
        <trans-unit id="0c1f9352e1fa38faa39862688bd277f18b10d9c1" translate="yes" xml:space="preserve">
          <source>Null characters are replaced by spaces. All other character data are treated as non-white space.</source>
          <target state="translated">널 문자는 공백으로 대체됩니다. 다른 모든 문자 데이터는 공백이 아닌 것으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="1379b906a7147ba93bdfbaa15c5aef0a7b89d5b4" translate="yes" xml:space="preserve">
          <source>NumChannels</source>
          <target state="translated">NumChannels</target>
        </trans-unit>
        <trans-unit id="4c4ae8549bdd6b57fda67f540fccb59bf2da0821" translate="yes" xml:space="preserve">
          <source>Number of audio channels.</source>
          <target state="translated">오디오 채널 수</target>
        </trans-unit>
        <trans-unit id="f7b569270fa7cf545e3daa2078b79a4d8a87e109" translate="yes" xml:space="preserve">
          <source>Number of bits per channel per pixel.</source>
          <target state="translated">픽셀 당 채널당 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="a482d7ae0209a142a8b59bb4bef1aea4823f47d4" translate="yes" xml:space="preserve">
          <source>Number of bits per sample.</source>
          <target state="translated">샘플 당 비트 수</target>
        </trans-unit>
        <trans-unit id="cb3a42704d48c93225d003f13ee5f75af388c6a7" translate="yes" xml:space="preserve">
          <source>Number of bits per sample. Valid values are 8, 16, 24, and 32. Default is 16.</source>
          <target state="translated">샘플 당 비트 수 유효한 값은 8, 16, 24 및 32입니다. 기본값은 16입니다.</target>
        </trans-unit>
        <trans-unit id="53c2869b9ff6e04239a31feefc0384d551c4f389" translate="yes" xml:space="preserve">
          <source>Number of block input operations.</source>
          <target state="translated">블록 입력 조작의 수</target>
        </trans-unit>
        <trans-unit id="8e14a8556077dced385703df8d7e402c6b98c875" translate="yes" xml:space="preserve">
          <source>Number of block output operations.</source>
          <target state="translated">블록 출력 작업 수</target>
        </trans-unit>
        <trans-unit id="dc9766a0ce4c6c2bd84b9b0c553fb9ed010e6a28" translate="yes" xml:space="preserve">
          <source>Number of blocks allocated for file.</source>
          <target state="translated">파일에 할당 된 블록 수</target>
        </trans-unit>
        <trans-unit id="078e75a951cd6a15779c766e0c964309a290f9c2" translate="yes" xml:space="preserve">
          <source>Number of bytes of the image on disk</source>
          <target state="translated">디스크에서 이미지의 바이트 수</target>
        </trans-unit>
        <trans-unit id="447236baca27a6e02336f66a79c4752995ba2f55" translate="yes" xml:space="preserve">
          <source>Number of function evaluations.</source>
          <target state="translated">기능 평가의 수</target>
        </trans-unit>
        <trans-unit id="955f5570b7c98b384b7e2b08add2530406bedd76" translate="yes" xml:space="preserve">
          <source>Number of involuntary context switches.</source>
          <target state="translated">비자발적 컨텍스트 전환 수</target>
        </trans-unit>
        <trans-unit id="6a3a1dbd595a33e9726bdba62317897e3b5cf655" translate="yes" xml:space="preserve">
          <source>Number of iterations through loop.</source>
          <target state="translated">루프를 통한 반복 횟수</target>
        </trans-unit>
        <trans-unit id="284f6755358deb1f0a1e9db8b3e5159e56acbc06" translate="yes" xml:space="preserve">
          <source>Number of iterations to loop an animation.</source>
          <target state="translated">애니메이션을 반복하는 반복 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="f384a316605f75a383767b2835085db7b74e838f" translate="yes" xml:space="preserve">
          <source>Number of links.</source>
          <target state="translated">링크 수</target>
        </trans-unit>
        <trans-unit id="fc87ec0ac8e37c7fc068e510b997ef1ee6856686" translate="yes" xml:space="preserve">
          <source>Number of major page faults.</source>
          <target state="translated">주요 페이지 결함 수</target>
        </trans-unit>
        <trans-unit id="a2990ab798b25b8069e15bd97eb8de8808148ffe" translate="yes" xml:space="preserve">
          <source>Number of messages received.</source>
          <target state="translated">받은 메시지 수</target>
        </trans-unit>
        <trans-unit id="0b8dff6db1a8014de826d9c6e455c2945141a357" translate="yes" xml:space="preserve">
          <source>Number of messages sent.</source>
          <target state="translated">전송 된 메시지 수</target>
        </trans-unit>
        <trans-unit id="4e8d18d406763d2331966314d41c713407869622" translate="yes" xml:space="preserve">
          <source>Number of minor page faults.</source>
          <target state="translated">사소한 페이지 결함 수</target>
        </trans-unit>
        <trans-unit id="de70dc41e6c9ca2ab53f31170baf5404b7e12596" translate="yes" xml:space="preserve">
          <source>Number of polynomial pieces or intervals, &lt;code&gt;&lt;var&gt;n&lt;/var&gt; = length (&lt;var&gt;x&lt;/var&gt;) - 1&lt;/code&gt;.</source>
          <target state="translated">다항식 조각 또는 구간 수, &lt;code&gt;&lt;var&gt;n&lt;/var&gt; = length (&lt;var&gt;x&lt;/var&gt;) - 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0abbed6ceaed6b0ef7d1242880a62214ba404218" translate="yes" xml:space="preserve">
          <source>Number of polynomials defined for each interval.</source>
          <target state="translated">각 구간에 대해 정의 된 다항식의 수입니다.</target>
        </trans-unit>
        <trans-unit id="2b0eb7fb7ed03e1edc1cd1894543c4e602a0679d" translate="yes" xml:space="preserve">
          <source>Number of samples in the file.</source>
          <target state="translated">파일의 샘플 수</target>
        </trans-unit>
        <trans-unit id="23802b12eba5bf52222daf7618d9080d6672d6f8" translate="yes" xml:space="preserve">
          <source>Number of signals received.</source>
          <target state="translated">수신 된 신호 수</target>
        </trans-unit>
        <trans-unit id="d48162b102e51945da510d0ce624a12eeb33e2ab" translate="yes" xml:space="preserve">
          <source>Number of successful iterations.</source>
          <target state="translated">성공적인 반복 횟수</target>
        </trans-unit>
        <trans-unit id="b3fd116f99cfd774f98fc182623d68320caa82ff" translate="yes" xml:space="preserve">
          <source>Number of swaps.</source>
          <target state="translated">스왑 수</target>
        </trans-unit>
        <trans-unit id="670b1eece5adae94311dde1613b7ab5683969df0" translate="yes" xml:space="preserve">
          <source>Number of voluntary context switches.</source>
          <target state="translated">자발적 컨텍스트 전환 수</target>
        </trans-unit>
        <trans-unit id="61ab31b0fd02c04fd15d995d651f5234adc7acf8" translate="yes" xml:space="preserve">
          <source>Numbered Lists</source>
          <target state="translated">번호 매기기 목록</target>
        </trans-unit>
        <trans-unit id="bbd4eb640e547e16f715615ea7d7559693029459" translate="yes" xml:space="preserve">
          <source>Numbered list item 1</source>
          <target state="translated">번호 매기기 목록 항목 1</target>
        </trans-unit>
        <trans-unit id="2fe85f5396c04c7ba92db5fa2b35ef0a8da666c0" translate="yes" xml:space="preserve">
          <source>Numbered list item 2</source>
          <target state="translated">번호 매기기 목록 항목 2</target>
        </trans-unit>
        <trans-unit id="ecbf98f12718d91a9917c6400607e0aba69196f6" translate="yes" xml:space="preserve">
          <source>Numeric Data Types</source>
          <target state="translated">숫자 형 데이터 타입</target>
        </trans-unit>
        <trans-unit id="85e8584849f0bcf8769cfbc1c5474bb2addc0bc3" translate="yes" xml:space="preserve">
          <source>Numeric Input Conversions</source>
          <target state="translated">숫자 입력 변환</target>
        </trans-unit>
        <trans-unit id="836f61f911dcbc7f53329897414e5c540abd1122" translate="yes" xml:space="preserve">
          <source>Numeric Objects</source>
          <target state="translated">숫자 객체</target>
        </trans-unit>
        <trans-unit id="66b9b1ae70227b5262a4a4ec61a65282efedc23f" translate="yes" xml:space="preserve">
          <source>Numeric arrays are converted to character strings.</source>
          <target state="translated">숫자 형 배열은 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="c3f659ce49f8c005092c6eadb8e7e19f7ef2635f" translate="yes" xml:space="preserve">
          <source>Numeric day of month (padded with zeros)</source>
          <target state="translated">월의 숫자 일 (0으로 채워짐)</target>
        </trans-unit>
        <trans-unit id="d2dba491fc6347c68d3f0dc3869f89865ce33d6b" translate="yes" xml:space="preserve">
          <source>Numeric modifiers (a nonstandard extension):</source>
          <target state="translated">숫자 수정 자 (비표준 확장) :</target>
        </trans-unit>
        <trans-unit id="e148e5432ced9c76654ac72315e8a9c8dd444e57" translate="yes" xml:space="preserve">
          <source>Numeric month number (padded with zeros)</source>
          <target state="translated">숫자 월 번호 (0으로 채워짐)</target>
        </trans-unit>
        <trans-unit id="716e51118f484adc22ce1016cace91b2b65ed1f2" translate="yes" xml:space="preserve">
          <source>Numeric value comprising either a floating point or integer value.</source>
          <target state="translated">부동 소수점 또는 정수 값을 포함하는 숫자 값.</target>
        </trans-unit>
        <trans-unit id="65dc788df910c4f9bf0271a363091ed2054e6151" translate="yes" xml:space="preserve">
          <source>Numerical Integration</source>
          <target state="translated">수치 적분</target>
        </trans-unit>
        <trans-unit id="0645dc6a0f3f3689ac482bfc0b68ed14271f502a" translate="yes" xml:space="preserve">
          <source>Numerical Recipes in C</source>
          <target state="translated">C의 수치 레시피</target>
        </trans-unit>
        <trans-unit id="6ff8d55719d7c371657467541985ddd3261ac9e4" translate="yes" xml:space="preserve">
          <source>Numerical Recipes in Fortran 77</source>
          <target state="translated">포트란 77의 수치 레시피</target>
        </trans-unit>
        <trans-unit id="797518de90d766fbbab787b7d0bfbd1d049cb551" translate="yes" xml:space="preserve">
          <source>Numerical Solution of Initial-Value Problems in Differential-Algebraic Equations</source>
          <target state="translated">미분 대수 방정식에서 초기 값 문제의 수치 해</target>
        </trans-unit>
        <trans-unit id="1cf4e21ff3ff00de65062cbb0047cfcf34b6123c" translate="yes" xml:space="preserve">
          <source>Numerical instability.</source>
          <target state="translated">수치 적 불안정성.</target>
        </trans-unit>
        <trans-unit id="3b7bae0d49e673b6d12503bd57c600bf24309a90" translate="yes" xml:space="preserve">
          <source>Numerical integration based on Gaussian quadrature.</source>
          <target state="translated">가우스 구적법에 기반한 수치 적분.</target>
        </trans-unit>
        <trans-unit id="2e24000809e4a641506b8964e99b744f8057a822" translate="yes" xml:space="preserve">
          <source>Numerical integration of data using the trapezoidal method.</source>
          <target state="translated">사다리꼴 방법을 사용하여 데이터를 수치 적으로 통합합니다.</target>
        </trans-unit>
        <trans-unit id="be3286a435d4d7e194a40be72a97365cb22b488d" translate="yes" xml:space="preserve">
          <source>Numerical integration using adaptive Clenshaw-Curtis rules.</source>
          <target state="translated">적응 형 Clenshaw-Curtis 규칙을 사용한 수치 통합.</target>
        </trans-unit>
        <trans-unit id="355d4128a9eff139189d8c6de3872a16569ce28b" translate="yes" xml:space="preserve">
          <source>Numerical integration using an adaptive Gauss-Konrod rule.</source>
          <target state="translated">적응 형 Gauss-Konrod 규칙을 사용한 수치 통합.</target>
        </trans-unit>
        <trans-unit id="c36d43591de916b7b4194e23997c370674732e82" translate="yes" xml:space="preserve">
          <source>Numerical integration using an adaptive Lobatto rule.</source>
          <target state="translated">적응 형 Lobatto 규칙을 사용한 수치 통합.</target>
        </trans-unit>
        <trans-unit id="6a1d6f38701fc04115ea88092e070da4c71aed0c" translate="yes" xml:space="preserve">
          <source>Numerical integration using an adaptive vectorized Simpson&amp;rsquo;s rule.</source>
          <target state="translated">적응 형 벡터화 된 심슨의 규칙을 사용한 수치 적분.</target>
        </trans-unit>
        <trans-unit id="983bc7c897d3606bb7b6104379512714a517c8cb" translate="yes" xml:space="preserve">
          <source>Numerically evaluate the double integral of &lt;var&gt;f&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;f&lt;/var&gt; 의 이중 적분을 수치 적으로 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="565d7f21a744f01f09842093e232360d87277e63" translate="yes" xml:space="preserve">
          <source>Numerically evaluate the integral of &lt;var&gt;f&lt;/var&gt; from &lt;var&gt;a&lt;/var&gt; to &lt;var&gt;b&lt;/var&gt; using Fortran routines from &lt;small&gt;QUADPACK&lt;/small&gt;.</source>
          <target state="translated">수치 적분의 평가 &lt;var&gt;f&lt;/var&gt; 으로부터 하는 &lt;var&gt;b&lt;/var&gt; 에서 포트란 루틴을 사용 &lt;small&gt;QUADPACK&lt;/small&gt; . &lt;var&gt;a&lt;/var&gt; &lt;small&gt;&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="a37d7640712c9837c6e885ec522cd047a2bfbe5a" translate="yes" xml:space="preserve">
          <source>Numerically evaluate the integral of &lt;var&gt;f&lt;/var&gt; from &lt;var&gt;a&lt;/var&gt; to &lt;var&gt;b&lt;/var&gt; using adaptive Gauss-Konrod quadrature.</source>
          <target state="translated">수치 적분의 평가 &lt;var&gt;f&lt;/var&gt; 로부터 하는 &lt;var&gt;b&lt;/var&gt; 적응 가우스 Konrod 직교을 사용한다. &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="fef00ecf019f6651a4b6db1365f42a8804074634" translate="yes" xml:space="preserve">
          <source>Numerically evaluate the integral of &lt;var&gt;f&lt;/var&gt; from &lt;var&gt;a&lt;/var&gt; to &lt;var&gt;b&lt;/var&gt; using adaptive quadrature.</source>
          <target state="translated">수치 적분의 평가 &lt;var&gt;f&lt;/var&gt; 으로부터 하는 &lt;var&gt;b&lt;/var&gt; 적응 직교 사용. &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="2966036cb500e8f432e8af9de9672919a7008ab5" translate="yes" xml:space="preserve">
          <source>Numerically evaluate the integral of &lt;var&gt;f&lt;/var&gt; from &lt;var&gt;a&lt;/var&gt; to &lt;var&gt;b&lt;/var&gt; using an adaptive Lobatto rule.</source>
          <target state="translated">수치 적분의 평가 &lt;var&gt;f&lt;/var&gt; 으로부터 하는 &lt;var&gt;b&lt;/var&gt; 적응 Lobatto 규칙을 사용. &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="a0c56872e0c7486d660053b9e934553f12410258" translate="yes" xml:space="preserve">
          <source>Numerically evaluate the integral of &lt;var&gt;f&lt;/var&gt; from &lt;var&gt;a&lt;/var&gt; to &lt;var&gt;b&lt;/var&gt; using an adaptive Simpson&amp;rsquo;s rule.</source>
          <target state="translated">수치 적분의 평가 &lt;var&gt;f&lt;/var&gt; 으로부터 하는 &lt;var&gt;b&lt;/var&gt; 적응 심프슨 공식을 사용. &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="4496d2d819a96173c1cea8fbcee7c39d420ce202" translate="yes" xml:space="preserve">
          <source>Numerically evaluate the integral of &lt;var&gt;f&lt;/var&gt; from &lt;var&gt;a&lt;/var&gt; to &lt;var&gt;b&lt;/var&gt; using doubly-adaptive Clenshaw-Curtis quadrature.</source>
          <target state="translated">수치 적분의 평가 &lt;var&gt;f&lt;/var&gt; 으로부터 하는 &lt;var&gt;b&lt;/var&gt; 이중 적응 Clenshaw 커티스 - 직교을 사용. &lt;var&gt;a&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="239fb86db852d54ddaa5a6a18a6e43d2d09202a7" translate="yes" xml:space="preserve">
          <source>Numerically evaluate the integral of points &lt;var&gt;y&lt;/var&gt; using the trapezoidal method.</source>
          <target state="translated">사다리꼴 방법을 사용하여 점 &lt;var&gt;y&lt;/var&gt; 의 적분을 수치 적으로 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="230c0a6b5025209de3c0b6534ce845b42eb158b9" translate="yes" xml:space="preserve">
          <source>Numerically evaluate the three-dimensional integral of &lt;var&gt;f&lt;/var&gt; using adaptive quadrature over the three-dimensional domain defined by &lt;var&gt;xa&lt;/var&gt;, &lt;var&gt;xb&lt;/var&gt;, &lt;var&gt;ya&lt;/var&gt;, &lt;var&gt;yb&lt;/var&gt;, &lt;var&gt;za&lt;/var&gt;, &lt;var&gt;zb&lt;/var&gt; (scalars may be finite or infinite). Additionally, &lt;var&gt;ya&lt;/var&gt; and &lt;var&gt;yb&lt;/var&gt; may be scalar functions of &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;za&lt;/var&gt;, and &lt;var&gt;zb&lt;/var&gt; maybe be scalar functions of &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt;, allowing for integration over non-rectangular domains.</source>
          <target state="translated">&lt;var&gt;xa&lt;/var&gt; , &lt;var&gt;xb&lt;/var&gt; , &lt;var&gt;ya&lt;/var&gt; , &lt;var&gt;yb&lt;/var&gt; , &lt;var&gt;za&lt;/var&gt; , &lt;var&gt;zb&lt;/var&gt; 로 정의 된 3 차원 도메인에 대해 적응 적 구적법을 사용하여 &lt;var&gt;f&lt;/var&gt; 의 3 차원 적분을 수치 적으로 평가합니다 (스칼라는 유한 또는 무한 일 수 있음). 또한, &lt;var&gt;ya&lt;/var&gt; 와 &lt;var&gt;yb&lt;/var&gt; 의 스칼라 함수가 될 수 있습니다 &lt;var&gt;x&lt;/var&gt; 및 &lt;var&gt;za&lt;/var&gt; 와 &lt;var&gt;zb&lt;/var&gt; 어쩌면의 스칼라 함수 수 &lt;var&gt;x&lt;/var&gt; 와 &lt;var&gt;y&lt;/var&gt; 사각형이 아닌 도메인을 통해 통합을 허용.</target>
        </trans-unit>
        <trans-unit id="1ec898331b91a42bfdacca2274bb1c89984aff8f" translate="yes" xml:space="preserve">
          <source>Numerically evaluate the triple integral of &lt;var&gt;f&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;f&lt;/var&gt; 의 삼중 적분을 수치 적으로 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="17177ffb23d8ad7b0ef5a9173f105f15dba7c150" translate="yes" xml:space="preserve">
          <source>Numerically evaluate the two-dimensional integral of &lt;var&gt;f&lt;/var&gt; using adaptive quadrature over the two-dimensional domain defined by &lt;var&gt;xa&lt;/var&gt;, &lt;var&gt;xb&lt;/var&gt;, &lt;var&gt;ya&lt;/var&gt;, &lt;var&gt;yb&lt;/var&gt; (scalars may be finite or infinite). Additionally, &lt;var&gt;ya&lt;/var&gt; and &lt;var&gt;yb&lt;/var&gt; may be scalar functions of &lt;var&gt;x&lt;/var&gt;, allowing for integration over non-rectangular domains.</source>
          <target state="translated">&lt;var&gt;xa&lt;/var&gt; , &lt;var&gt;xb&lt;/var&gt; , &lt;var&gt;ya&lt;/var&gt; , &lt;var&gt;yb&lt;/var&gt; 로 정의 된 2 차원 도메인에 대해 적응 적 구적법을 사용하여 &lt;var&gt;f&lt;/var&gt; 의 2 차원 적분을 수치 적으로 평가합니다 (스칼라는 유한 또는 무한 일 수 있음). 또한 &lt;var&gt;ya&lt;/var&gt; 및 &lt;var&gt;yb&lt;/var&gt; 는 &lt;var&gt;x&lt;/var&gt; 의 스칼라 함수일 수 있으므로 직사각형이 아닌 도메인에 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee8287f411936babccdc36a20035ba1be5d79b09" translate="yes" xml:space="preserve">
          <source>Numerically evaluate the two-dimensional integral of &lt;var&gt;f&lt;/var&gt; using adaptive quadrature over the two-dimensional domain defined by &lt;var&gt;xa&lt;/var&gt;, &lt;var&gt;xb&lt;/var&gt;, &lt;var&gt;ya&lt;/var&gt;, &lt;var&gt;yb&lt;/var&gt; using tiled integration. Additionally, &lt;var&gt;ya&lt;/var&gt; and &lt;var&gt;yb&lt;/var&gt; may be scalar functions of &lt;var&gt;x&lt;/var&gt;, allowing for the integration over non-rectangular domains.</source>
          <target state="translated">기와 적분을 사용하여 &lt;var&gt;xa&lt;/var&gt; , &lt;var&gt;xb&lt;/var&gt; , &lt;var&gt;ya&lt;/var&gt; , &lt;var&gt;yb&lt;/var&gt; 로 정의 된 2 차원 도메인에 대해 적응 직교 법을 사용하여 &lt;var&gt;f&lt;/var&gt; 의 2 차원 적분을 수치 적으로 평가합니다 . 또한 &lt;var&gt;ya&lt;/var&gt; 및 &lt;var&gt;yb&lt;/var&gt; 는 &lt;var&gt;x&lt;/var&gt; 의 스칼라 함수일 수 있으므로 직사각형이 아닌 도메인에 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="929a2a357f8a1c35996e70cfe09813b3cefe1b48" translate="yes" xml:space="preserve">
          <source>OCTAVE_EXEC_HOME</source>
          <target state="translated">OCTAVE_EXEC_HOME</target>
        </trans-unit>
        <trans-unit id="9634bfdb2a7f979066eb80190e051ee4f88e8643" translate="yes" xml:space="preserve">
          <source>OCTAVE_EXEC_HOME ()</source>
          <target state="translated">OCTAVE_EXEC_HOME ()</target>
        </trans-unit>
        <trans-unit id="13062bcd8bfe7900a85a6cfc0e0d6b08ff4576fc" translate="yes" xml:space="preserve">
          <source>OCTAVE_HOME</source>
          <target state="translated">OCTAVE_HOME</target>
        </trans-unit>
        <trans-unit id="41f1becb5f56a10c42a5b35b050c537a798445b4" translate="yes" xml:space="preserve">
          <source>OCTAVE_HOME ()</source>
          <target state="translated">OCTAVE_HOME ()</target>
        </trans-unit>
        <trans-unit id="0ea145db1efd226c1ce819ca8c2401356dab4a6c" translate="yes" xml:space="preserve">
          <source>OCTAVE_HOME/share/octave/octave_packages</source>
          <target state="translated">OCTAVE_HOME/share/octave/octave_packages</target>
        </trans-unit>
        <trans-unit id="634a3c75535f9cb2e350a8335de09fab95407d0a" translate="yes" xml:space="preserve">
          <source>OCTAVE_HOME/share/octave/packages/</source>
          <target state="translated">OCTAVE_HOME/share/octave/packages/</target>
        </trans-unit>
        <trans-unit id="c8f3aa86d3c56652874688d66116e4c560a1abd1" translate="yes" xml:space="preserve">
          <source>OCTAVE_VERSION</source>
          <target state="translated">OCTAVE_VERSION</target>
        </trans-unit>
        <trans-unit id="6a11b7e4f2ae60ac95fae1693cb178531bb23c84" translate="yes" xml:space="preserve">
          <source>OCTAVE_VERSION ()</source>
          <target state="translated">OCTAVE_VERSION ()</target>
        </trans-unit>
        <trans-unit id="366d7600ff8e830561be33d122a5a381d153239f" translate="yes" xml:space="preserve">
          <source>ODEPACK, A Systematized Collection of ODE Solvers</source>
          <target state="translated">ODEPACK, 체계화 된 ODE 솔버 모음</target>
        </trans-unit>
        <trans-unit id="e287fe3bf7a7323f24daa4b18571d5b40966a374" translate="yes" xml:space="preserve">
          <source>ODEPACK, a Systematized Collection of ODE Solvers</source>
          <target state="translated">체계화 된 ODE 솔버 모음 인 ODEPACK</target>
        </trans-unit>
        <trans-unit id="d5a11ed73c112b24777ada90a65982f29d4bf36f" translate="yes" xml:space="preserve">
          <source>OLS applies to the multivariate model &lt;em&gt;&lt;var&gt;y&lt;/var&gt; = &lt;var&gt;x&lt;/var&gt;*&lt;var&gt;b&lt;/var&gt; + &lt;var&gt;e&lt;/var&gt;&lt;/em&gt; where &lt;em&gt;&lt;var&gt;y&lt;/var&gt;&lt;/em&gt; is a &lt;em&gt;t&lt;/em&gt;-by-&lt;em&gt;p&lt;/em&gt; matrix, &lt;em&gt;&lt;var&gt;x&lt;/var&gt;&lt;/em&gt; is a &lt;em&gt;t&lt;/em&gt;-by-&lt;em&gt;k&lt;/em&gt; matrix, &lt;var&gt;b&lt;/var&gt; is a &lt;em&gt;k&lt;/em&gt;-by-&lt;em&gt;p&lt;/em&gt; matrix, and &lt;var&gt;e&lt;/var&gt; is a &lt;em&gt;t&lt;/em&gt;-by-&lt;em&gt;p&lt;/em&gt; matrix.</source>
          <target state="translated">OLS는 다 변수 모델에 적용 &lt;em&gt; &lt;var&gt;y&lt;/var&gt; = &lt;var&gt;x&lt;/var&gt; * &lt;var&gt;b&lt;/var&gt; + &lt;var&gt;e&lt;/var&gt; &lt;/em&gt;&lt;em&gt; &lt;var&gt;y&lt;/var&gt; &lt;/em&gt; A는 &lt;em&gt;t&lt;/em&gt; -by- &lt;em&gt;P는&lt;/em&gt; 행렬 &lt;em&gt; &lt;var&gt;x&lt;/var&gt; &lt;/em&gt; 인 &lt;em&gt;t&lt;/em&gt; -by- &lt;em&gt;K&lt;/em&gt; 행렬, &lt;var&gt;b&lt;/var&gt; A는 &lt;em&gt;K&lt;/em&gt; -by- &lt;em&gt;P의&lt;/em&gt; 행렬, 및 &lt;var&gt;e&lt;/var&gt; 는 A는 &lt;em&gt;t&lt;/em&gt; - by- &lt;em&gt;p&lt;/em&gt; 행렬.</target>
        </trans-unit>
        <trans-unit id="9beeba965ae8dfbfff40f9bb14dd3916873ca225" translate="yes" xml:space="preserve">
          <source>O_APPEND</source>
          <target state="translated">O_APPEND</target>
        </trans-unit>
        <trans-unit id="17d0cf14f6e349ac4aa723a66957698e9b9984c2" translate="yes" xml:space="preserve">
          <source>O_ASYNC</source>
          <target state="translated">O_ASYNC</target>
        </trans-unit>
        <trans-unit id="551e86440c2fc23584e79c81d816311d1cd7c1b6" translate="yes" xml:space="preserve">
          <source>O_CREAT</source>
          <target state="translated">O_CREAT</target>
        </trans-unit>
        <trans-unit id="4c2fbe88ccc156499e1adb5569ddb4a71e2a0944" translate="yes" xml:space="preserve">
          <source>O_NONBLOCK</source>
          <target state="translated">O_NONBLOCK</target>
        </trans-unit>
        <trans-unit id="6b98d858d2924137b3235aac1a8c08bfc9133a35" translate="yes" xml:space="preserve">
          <source>O_RDONLY</source>
          <target state="translated">O_RDONLY</target>
        </trans-unit>
        <trans-unit id="c310f2acb3ba3dfeb4d20e8e79d6eaa2e6a620c3" translate="yes" xml:space="preserve">
          <source>O_RDWR</source>
          <target state="translated">O_RDWR</target>
        </trans-unit>
        <trans-unit id="2ee322829f78f74d8bacf972b329ca8066c9a6c7" translate="yes" xml:space="preserve">
          <source>O_SYNC</source>
          <target state="translated">O_SYNC</target>
        </trans-unit>
        <trans-unit id="60d427cc4901c6b5961edbe1559f7dc23bdae45c" translate="yes" xml:space="preserve">
          <source>O_WRONLY</source>
          <target state="translated">O_WRONLY</target>
        </trans-unit>
        <trans-unit id="07708492bfc313a2d4c1a65586cf08860f242165" translate="yes" xml:space="preserve">
          <source>Object Groups</source>
          <target state="translated">객체 그룹</target>
        </trans-unit>
        <trans-unit id="e2e3a80c4bd8a468bcd99583c85e67abc6426be7" translate="yes" xml:space="preserve">
          <source>Object Oriented Programming</source>
          <target state="translated">객체 지향 프로그래밍</target>
        </trans-unit>
        <trans-unit id="f3ea0cec0c2345a3d4bfa234564bd7b24cfaec4a" translate="yes" xml:space="preserve">
          <source>Object Sizes</source>
          <target state="translated">객체 크기</target>
        </trans-unit>
        <trans-unit id="f03118a419af3015951b0cdc9a81c6ef27b59a85" translate="yes" xml:space="preserve">
          <source>Object display</source>
          <target state="translated">객체 표시</target>
        </trans-unit>
        <trans-unit id="7185a816b170aaf26aea6ea3a663c4fe54e6852a" translate="yes" xml:space="preserve">
          <source>Object files that will be dynamically loaded.</source>
          <target state="translated">동적으로로드 될 객체 파일.</target>
        </trans-unit>
        <trans-unit id="18b0adc5153ead23a95c0f4851034b28e618b670" translate="yes" xml:space="preserve">
          <source>Object properties have two classes of default values, &lt;em&gt;factory defaults&lt;/em&gt; (the initial values) and &lt;em&gt;user-defined defaults&lt;/em&gt;, which may override the factory defaults.</source>
          <target state="translated">객체 속성에는 &lt;em&gt;공장 기본값&lt;/em&gt; (초기 값)과 &lt;em&gt;사용자 정의 기본값의&lt;/em&gt; 두 가지 기본값 클래스가 있으며 ,이 기본값은 공장 기본값을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8329cabcc08630996a6467719297a92742a3dba" translate="yes" xml:space="preserve">
          <source>Object properties that are modified by a method of an handle class are changed persistently:</source>
          <target state="translated">핸들 클래스의 메소드로 수정 된 오브젝트 특성은 지속적으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="9f2d503d3035fc1dcc0f5a9aac1311e2e54b6c49" translate="yes" xml:space="preserve">
          <source>Objective function lower limit reached.</source>
          <target state="translated">목표 함수 하한에 도달했습니다.</target>
        </trans-unit>
        <trans-unit id="9eb4cb540437c416d8978c7c11b7c402253cb48c" translate="yes" xml:space="preserve">
          <source>Objective function upper limit reached.</source>
          <target state="translated">목표 함수 상한에 도달했습니다.</target>
        </trans-unit>
        <trans-unit id="c0a7089616a7d65a2cf4e020b8fb54723e2b8441" translate="yes" xml:space="preserve">
          <source>Objects can also be used themselves as the index in a subscripted expression and this is controlled by the &lt;code&gt;subsindex&lt;/code&gt; function.</source>
          <target state="translated">아래 첨자 식에서 개체를 인덱스로 사용할 수도 있으며 이는 &lt;code&gt;subsindex&lt;/code&gt; 함수에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="35b1b358c8308a5ba55d2ea7ae2ec90a15771e68" translate="yes" xml:space="preserve">
          <source>Objects can be indexed with parentheses or braces, either like &lt;code&gt;&lt;var&gt;obj&lt;/var&gt;(&lt;var&gt;idx&lt;/var&gt;)&lt;/code&gt; or like &lt;code&gt;&lt;var&gt;obj&lt;/var&gt;{&lt;var&gt;idx&lt;/var&gt;}&lt;/code&gt;, or even like &lt;code&gt;&lt;var&gt;obj&lt;/var&gt;(&lt;var&gt;idx&lt;/var&gt;).&lt;var&gt;field&lt;/var&gt;&lt;/code&gt;. However, it is up to the programmer to decide what this indexing actually means. In the case of the polynomial class &lt;code&gt;&lt;var&gt;p&lt;/var&gt;(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; might mean either the coefficient of the &lt;var&gt;n&lt;/var&gt;-th power of the polynomial, or it might be the evaluation of the polynomial at &lt;var&gt;n&lt;/var&gt;. The meaning of this subscripted referencing is determined by the &lt;code&gt;subsref&lt;/code&gt; method.</source>
          <target state="translated">객체는 괄호 나 중괄호 인덱싱 할 수 있습니다와 같은 &lt;code&gt;&lt;var&gt;obj&lt;/var&gt;(&lt;var&gt;idx&lt;/var&gt;)&lt;/code&gt; 또는 같은 &lt;code&gt;&lt;var&gt;obj&lt;/var&gt;{&lt;var&gt;idx&lt;/var&gt;}&lt;/code&gt; , 심지어는 같은 &lt;code&gt;&lt;var&gt;obj&lt;/var&gt;(&lt;var&gt;idx&lt;/var&gt;).&lt;var&gt;field&lt;/var&gt;&lt;/code&gt; . 그러나이 인덱싱의 실제 의미를 결정하는 것은 프로그래머의 몫입니다. 다항식 클래스의 경우 &lt;code&gt;&lt;var&gt;p&lt;/var&gt;(&lt;var&gt;n&lt;/var&gt;)&lt;/code&gt; 의 계수 중 하나를 의미 할 수 &lt;var&gt;n&lt;/var&gt; 은 다항식의 전력 번째, 또는 다항식으로 평가 될 수 &lt;var&gt;n&lt;/var&gt; . 이 첨자 참조의 의미는 &lt;code&gt;subsref&lt;/code&gt; 방법에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="c22d3a61b6841c87b8bff2ea8a414fde862267dc" translate="yes" xml:space="preserve">
          <source>Objects may also be matched by comparing a regular expression to the property values, where property values that match &lt;code&gt;regexp (&lt;var&gt;prop_value&lt;/var&gt;, &lt;var&gt;pattern&lt;/var&gt;)&lt;/code&gt; are returned.</source>
          <target state="translated">정규식을 속성 값과 비교하여 객체를 일치시킬 수도 있습니다. 여기서 정규 표현식과 일치하는 속성 값 &lt;code&gt;regexp (&lt;var&gt;prop_value&lt;/var&gt;, &lt;var&gt;pattern&lt;/var&gt;)&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bebfd10ba2e24623b36f3cac6376dfffdb470321" translate="yes" xml:space="preserve">
          <source>Objects of class double or single are floating-point objects.</source>
          <target state="translated">double 또는 single 클래스의 객체는 부동 소수점 객체입니다.</target>
        </trans-unit>
        <trans-unit id="ea7fc7a21764798370a9ec1fc6c65fab9fe386ff" translate="yes" xml:space="preserve">
          <source>Oblique Font</source>
          <target state="translated">오블 리크 글꼴</target>
        </trans-unit>
        <trans-unit id="bbed3f48f80959f39c7cd39c3a706e8c0b5ee208" translate="yes" xml:space="preserve">
          <source>Observe that the syntax is optimized for struct &lt;strong&gt;arrays&lt;/strong&gt;. Consider the following examples:</source>
          <target state="translated">구문이 구조체 &lt;strong&gt;배열에&lt;/strong&gt; 최적화되어 있는지 확인하십시오 . 다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8757910ae66489ff6adf6314346236e31cc5462e" translate="yes" xml:space="preserve">
          <source>Obsolete Function</source>
          <target state="translated">사용되지 않는 기능</target>
        </trans-unit>
        <trans-unit id="23cceb4e79d2ef6858582724a2040283e184e0d7" translate="yes" xml:space="preserve">
          <source>Obsolete Functions</source>
          <target state="translated">사용되지 않는 기능</target>
        </trans-unit>
        <trans-unit id="b9bd703638ca235686c6726eee3bd3e545f03514" translate="yes" xml:space="preserve">
          <source>Occasionally a block of tests will depend on having optional functionality in Octave. Before testing such blocks the availability of the required functionality must be checked. A &lt;code&gt;%!testif HAVE_XXX&lt;/code&gt; block will only be run if Octave was compiled with functionality &amp;lsquo;</source>
          <target state="translated">때때로 테스트 블록은 Octave에서 옵션 기능을 사용하는 데 달려 있습니다. 이러한 블록을 테스트하기 전에 필요한 기능의 가용성을 확인해야합니다. &lt;code&gt;%!testif HAVE_XXX&lt;/code&gt; 옥타브 기능을 사용하여 컴파일 된 경우 블록은 전용 '실행됩니다</target>
        </trans-unit>
        <trans-unit id="4e754e96b4b25a9b256a7b27fe69e76ec2bb7a1f" translate="yes" xml:space="preserve">
          <source>Oct-Files</source>
          <target state="translated">Oct-Files</target>
        </trans-unit>
        <trans-unit id="50ed1c66c5500c0b695ad6ba1590534b15fc91f6" translate="yes" xml:space="preserve">
          <source>Oct-files are pieces of C++ code that have been compiled with the Octave API into a dynamically loadable object. They take their name from the file which contains the object which has the extension</source>
          <target state="translated">Oct 파일은 Octave API를 사용하여 동적으로로드 가능한 객체로 컴파일 된 C ++ 코드 조각입니다. 그들은 확장자를 가진 객체를 포함하는 파일에서 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="103165a25eab02f49a4433a5673b29e0c77532f2" translate="yes" xml:space="preserve">
          <source>Octave</source>
          <target state="translated">Octave</target>
        </trans-unit>
        <trans-unit id="cdaa3795ddbd449b699ab46137dfd38696119203" translate="yes" xml:space="preserve">
          <source>Octave also allows you customize the details of when, where, and how history is saved.</source>
          <target state="translated">옥타브를 사용하면 기록이 저장되는시기, 위치 및 방법에 대한 세부 정보를 사용자 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a458dfb7ba82ae0e47593df41f4716869c170bf" translate="yes" xml:space="preserve">
          <source>Octave also has a function that makes it possible to get a single character from the keyboard without requiring the user to type a carriage return.</source>
          <target state="translated">옥타브에는 사용자가 캐리지 리턴을 입력하지 않고도 키보드에서 단일 문자를 가져올 수있는 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d49ad6d1f0ba3e20830487a3f6a81ab87e70e12" translate="yes" xml:space="preserve">
          <source>Octave also includes &lt;small&gt;DASSL&lt;/small&gt;, an earlier version of &lt;small&gt;DASPK&lt;/small&gt;, and &lt;small&gt;DASRT&lt;/small&gt;, which can be used to solve DAEs with constraints (stopping conditions).</source>
          <target state="translated">옥타브도 포함 &lt;small&gt;DASSL&lt;/small&gt; , 이전 버전 &lt;small&gt;DASPK&lt;/small&gt; 및 &lt;small&gt;DASRT&lt;/small&gt; 제한 (정지 상태)로 DAE를 해결하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="dc002dd876ebb1f1b765950ee3a8f6cbd020adea" translate="yes" xml:space="preserve">
          <source>Octave also includes several functions which return information about the command line, including the number of arguments and all of the options.</source>
          <target state="translated">옥타브에는 인수 수 및 모든 옵션을 포함하여 명령 줄에 대한 정보를 반환하는 여러 함수도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6108428891fe32675834387d892d04589e172c0" translate="yes" xml:space="preserve">
          <source>Octave also includes the ability to embed test and demonstration code for a function within the code itself (see &lt;a href=&quot;test-and-demo-functions#Test-and-Demo-Functions&quot;&gt;Test and Demo Functions&lt;/a&gt;). This can be used from within oct-files (or in fact any file) with certain provisos. First, the test and demo functions of Octave look for &lt;code&gt;%!&lt;/code&gt; as the first two characters of a line to identify test and demonstration code. This is a requirement for oct-files as well. In addition, the test and demonstration code must be wrapped in a comment block to avoid it being interpreted by the compiler. Finally, the Octave test and demonstration code must have access to the original source code of the oct-file&amp;mdash;not just the compiled code&amp;mdash;as the tests are stripped from the compiled code. An example in an oct-file might be</source>
          <target state="translated">옥타브에는 코드 자체 내에 함수에 대한 테스트 및 데모 코드를 포함하는 기능도 포함되어 있습니다 ( &lt;a href=&quot;test-and-demo-functions#Test-and-Demo-Functions&quot;&gt;테스트 및 데모 함수&lt;/a&gt; 참조 ). 이것은 특정 provisos와 함께 oct 파일 (또는 실제로 모든 파일)에서 사용할 수 있습니다. 먼저 Octave의 테스트 및 데모 기능은 &lt;code&gt;%!&lt;/code&gt; 찾습니다 ! 테스트 및 데모 코드를 식별하기 위해 줄의 처음 두 문자로 이것은 oct 파일에도 필요합니다. 또한 테스트 및 데모 코드는 주석 블록으로 랩핑되어 컴파일러에서 해석되지 않도록해야합니다. 마지막으로 Octave 테스트 및 데모 코드는 컴파일 된 코드에서 테스트가 제거되므로 컴파일 된 코드뿐만 아니라 oct 파일의 원본 소스 코드에 액세스 할 수 있어야합니다. oct 파일의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b34a7ce8bb0ee0da3f1df65319eb689a00a90451" translate="yes" xml:space="preserve">
          <source>Octave also includes the ability to left-shift and right-shift values bitwise.</source>
          <target state="translated">옥타브에는 값을 왼쪽으로 시프트 및 오른쪽으로 시프트하는 기능도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9613e54f074912022e7b29e6d603f20fee1d4841" translate="yes" xml:space="preserve">
          <source>Octave also includes the basic bitwise &amp;rsquo;and&amp;rsquo;, &amp;rsquo;or&amp;rsquo;, and &amp;rsquo;exclusive or&amp;rsquo; operators.</source>
          <target state="translated">옥타브에는 기본 비트 단위 'and', 'or'및 'exclusive or'연산자도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3cfa2258fd1af4f19eb3055ce3de87f348f298d5" translate="yes" xml:space="preserve">
          <source>Octave also provides a set of solvers for initial value problems for Ordinary Differential Equations that have a &lt;small&gt;MATLAB&lt;/small&gt;-compatible interface. The options for this class of methods are set using the functions.</source>
          <target state="translated">옥타브는 &lt;small&gt;MATLAB&lt;/small&gt; 호환 인터페이스 가있는 정규 미분 방정식의 초기 값 문제에 대한 일련의 솔버도 제공합니다 . 이 클래스의 메소드에 대한 옵션은 함수를 사용하여 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1f8e9422f7b796a347ed25eefb6c4311aad8e98f" translate="yes" xml:space="preserve">
          <source>Octave also provides several very low-level Unix-like functions which can also be used for starting subprocesses, but you should probably only use them if you can&amp;rsquo;t find any way to do what you need with the higher-level functions.</source>
          <target state="translated">옥타브는 하위 프로세스를 시작하는 데 사용할 수있는 매우 낮은 수준의 유닉스 계열 함수도 제공하지만 고급 함수로 필요한 작업을 수행 할 수있는 방법을 찾을 수없는 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a739dad68d05b6ba15ecdef154148391de46f9b" translate="yes" xml:space="preserve">
          <source>Octave also provides the following character class test functions patterned after the functions in the standard C library. They all operate on string arrays and return matrices of zeros and ones. Elements that are nonzero indicate that the condition was true for the corresponding character in the string array. For example:</source>
          <target state="translated">옥타브는 또한 표준 C 라이브러리의 함수 다음에 패턴 화 된 다음 문자 클래스 테스트 함수를 제공합니다. 그것들은 모두 문자열 배열에서 작동하며 0과 1의 행렬을 반환합니다. 0이 아닌 요소는 문자열 배열의 해당 문자에 대한 조건이 참임을 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="333dcf5326aa44041e4390a94168f9e9c83de405" translate="yes" xml:space="preserve">
          <source>Octave also provides tools to produce and work with movie frame structures. Those structures encapsulate the image data (&lt;code&gt;&quot;cdata&quot;&lt;/code&gt; field) together with the corresponding colormap (&lt;code&gt;&quot;colormap&quot;&lt;/code&gt; field).</source>
          <target state="translated">Octave는 영화 프레임 구조를 제작하고 작업 할 수있는 도구도 제공합니다. 이러한 구조는 이미지 데이터 ( &lt;code&gt;&quot;cdata&quot;&lt;/code&gt; 필드)를 해당 컬러 맵 ( &lt;code&gt;&quot;colormap&quot;&lt;/code&gt; 필드) 과 함께 캡슐화합니다 .</target>
        </trans-unit>
        <trans-unit id="fe90117ac9f8be738269da153b6c254231c04ed4" translate="yes" xml:space="preserve">
          <source>Octave also supports linear least squares minimization. That is, Octave can find the parameter &lt;em&gt;b&lt;/em&gt; such that the model &lt;em&gt;y = x*b&lt;/em&gt; fits data &lt;em&gt;(x,y)&lt;/em&gt; as well as possible, assuming zero-mean Gaussian noise. If the noise is assumed to be isotropic the problem can be solved using the &amp;lsquo;</source>
          <target state="translated">옥타브는 선형 최소 제곱 최소화도 지원합니다. 즉, Octave는 모델 &lt;em&gt;y = x * b가&lt;/em&gt; 데이터 &lt;em&gt;(x, y)&lt;/em&gt; 에 적합하고 제로 평균 가우스 잡음을 가정 할 때 매개 변수 &lt;em&gt;b를&lt;/em&gt; 찾을 수 있습니다 . 잡음이 등방성 인 것으로 가정하면 '&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="244a04f2381f5ff0e08934279a337ffeee4195d1" translate="yes" xml:space="preserve">
          <source>Octave and &lt;small&gt;MATLAB&lt;/small&gt; are very similar, but handle Java slightly different. Therefore it may be necessary to detect the environment and use the appropriate functions. The following function can be used to detect the environment. Due to the persistent variable it can be called repeatedly without a heavy performance hit.</source>
          <target state="translated">Octave와 &lt;small&gt;MATLAB&lt;/small&gt; 은 매우 유사하지만 Java를 약간 다르게 처리합니다. 따라서 환경을 감지하고 적절한 기능을 사용해야 할 수도 있습니다. 다음 기능을 사용하여 환경을 감지 할 수 있습니다. 지속적 변수로 인해 성능 저하없이 반복적으로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f522f5dc48317f00761d5558a6e940ab44d08192" translate="yes" xml:space="preserve">
          <source>Octave and other binaries that people will want to run directly.</source>
          <target state="translated">사람들이 직접 실행하려는 옥타브 및 기타 바이너리.</target>
        </trans-unit>
        <trans-unit id="3500701cfa630ed25785a1bf21759d4d4ef49217" translate="yes" xml:space="preserve">
          <source>Octave automatically switches to scientific notation when values become very large or very small. This guarantees that you will see several significant figures for every value in a matrix. If you would prefer to see all values in a matrix printed in a fixed point format, you can set the built-in variable &lt;code&gt;fixed_point_format&lt;/code&gt; to a nonzero value. But doing so is not recommended, because it can produce output that can easily be misinterpreted.</source>
          <target state="translated">옥타브는 값이 매우 커지거나 작아지면 과학적 표기법으로 자동 전환됩니다. 이를 통해 행렬의 모든 값에 대해 몇 가지 중요한 수치를 볼 수 있습니다. 고정 소수점 형식으로 인쇄 된 행렬의 모든 값을 보려면 기본 제공 변수 &lt;code&gt;fixed_point_format&lt;/code&gt; 을 0이 아닌 값으로 설정할 수 있습니다 . 그러나 잘못 해석하기 쉬운 출력을 생성 할 수 있으므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="730258944b504da55bf0d797abc34064c3bc40a2" translate="yes" xml:space="preserve">
          <source>Octave built-in functions are intended to generate valid sparse matrices, with no duplicate entries, with ascending row indices of the nonzeros in each column, with a non-negative number of entries in each column (!) and so on. If a matrix is invalid, then &lt;small&gt;COLAMD&lt;/small&gt; may or may not be able to continue. If there are duplicate entries (a row index appears two or more times in the same column) or if the row indices in a column are out of order, then &lt;small&gt;COLAMD&lt;/small&gt; can correct these errors by ignoring the duplicate entries and sorting each column of its internal copy of the matrix &lt;var&gt;S&lt;/var&gt; (the input matrix &lt;var&gt;S&lt;/var&gt; is not repaired, however). If a matrix is invalid in other ways then &lt;small&gt;COLAMD&lt;/small&gt; cannot continue, an error message is printed, and no output arguments (&lt;var&gt;p&lt;/var&gt; or &lt;var&gt;stats&lt;/var&gt;) are returned. &lt;small&gt;COLAMD&lt;/small&gt; is thus a simple way to check a sparse matrix to see if it&amp;rsquo;s valid.</source>
          <target state="translated">옥타브 내장 함수는 중복 된 항목이없고 각 열의 0이 아닌 행의 오름차순 행 인덱스, 각 열의 음수가 아닌 수의 항목 (!) 등으로 유효한 희소 행렬을 생성하기위한 것입니다. 행렬이 유효하지 않으면 &lt;small&gt;COLAMD&lt;/small&gt; 가 계속되거나 작동하지 않을 수 있습니다. 중복 항목이 있거나 (열 색인이 동일한 열에 두 번 이상 나타남) 열의 행 색인 이 잘못된 경우 &lt;small&gt;COLAMD&lt;/small&gt; 는 중복 항목을 무시하고 내부의 각 열을 정렬하여 이러한 오류를 정정 할 수 있습니다. 그러나, 매트릭스 &lt;var&gt;S&lt;/var&gt; 의 카피 (입력 매트릭스 &lt;var&gt;S&lt;/var&gt; 는 수리되지 않는다). 다른 방법으로 행렬이 유효하지 않으면 &lt;small&gt;COLAMD&lt;/small&gt;계속할 수없고 오류 메시지가 인쇄되며 출력 인수 ( &lt;var&gt;p&lt;/var&gt; 또는 &lt;var&gt;stats&lt;/var&gt; )가 리턴 되지 않습니다 . 따라서 &lt;small&gt;COLAMD&lt;/small&gt; 는 희소 행렬이 유효한지 확인하는 간단한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="35a41873985d021f8658f6337c50a04c73f3c673" translate="yes" xml:space="preserve">
          <source>Octave built-in functions are intended to generate valid sparse matrices, with no duplicate entries, with ascending row indices of the nonzeros in each column, with a non-negative number of entries in each column (!) and so on. If a matrix is invalid, then SYMAMD may or may not be able to continue. If there are duplicate entries (a row index appears two or more times in the same column) or if the row indices in a column are out of order, then SYMAMD can correct these errors by ignoring the duplicate entries and sorting each column of its internal copy of the matrix S (the input matrix S is not repaired, however). If a matrix is invalid in other ways then SYMAMD cannot continue, an error message is printed, and no output arguments (&lt;var&gt;p&lt;/var&gt; or &lt;var&gt;stats&lt;/var&gt;) are returned. SYMAMD is thus a simple way to check a sparse matrix to see if it&amp;rsquo;s valid.</source>
          <target state="translated">옥타브 내장 함수는 중복 된 항목이없고 각 열의 0이 아닌 행의 오름차순 행 인덱스, 각 열의 음수가 아닌 수의 항목 (!) 등으로 유효한 희소 행렬을 생성하기위한 것입니다. 행렬이 유효하지 않은 경우 SYMAMD는 계속하거나 계속하지 못할 수 있습니다. 중복 항목이 있거나 (열 색인이 동일한 열에 두 번 이상 나타남) 또는 열의 행 색인이 잘못된 경우 SYMAMD는 중복 항목을 무시하고 내부의 각 열을 정렬하여 이러한 오류를 정정 할 수 있습니다. 매트릭스 S의 카피 (입력 매트릭스 S는 수리되지 않음). 행렬이 다른 방식으로 유효하지 않은 경우 SYMAMD를 계속할 수없고 오류 메시지가 인쇄되며 출력 인수 ( &lt;var&gt;p&lt;/var&gt; 또는 &lt;var&gt;stats&lt;/var&gt; )가 없습니다.)가 반환됩니다. 따라서 SYMAMD는 희소 행렬이 유효한지 확인하는 간단한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="41172b7d8d8143d4d17eaa8b5aef6840a789d2d2" translate="yes" xml:space="preserve">
          <source>Octave can also perform general nonlinear minimization using a successive quadratic programming solver.</source>
          <target state="translated">옥타브는 또한 연속 2 차 프로그래밍 솔버를 사용하여 일반적인 비선형 최소화를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b4334795cb3885442037ba8e27da14938ebb0ff" translate="yes" xml:space="preserve">
          <source>Octave can also read and write matrices text files such as comma separated lists.</source>
          <target state="translated">옥타브는 쉼표로 구분 된 목록과 같은 행렬 텍스트 파일을 읽고 쓸 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f20c7e1c7b576f2ab728e9df19716b8b5ac1d1ca" translate="yes" xml:space="preserve">
          <source>Octave can also solve Quadratic Programming problems, this is</source>
          <target state="translated">옥타브는 2 차 프로그래밍 문제를 해결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="07c0cb77373a36cc32e20e24334d80a0c0b9ae9a" translate="yes" xml:space="preserve">
          <source>Octave can display more than one plot in a single figure. The simplest way to do this is to use the &lt;code&gt;subplot&lt;/code&gt; function to divide the plot area into a series of subplot windows that are indexed by an integer. For example,</source>
          <target state="translated">옥타브는 하나의 그림에 둘 이상의 플롯을 표시 할 수 있습니다. 가장 간단한 방법은 &lt;code&gt;subplot&lt;/code&gt; 함수 를 사용 하여 플롯 영역을 정수로 인덱스 된 일련의 서브 플롯 창으로 나누는 것입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6406bf9f10997f9cacf96ef93be7f06cdc5df139" translate="yes" xml:space="preserve">
          <source>Octave can easily be used for basic numerical calculations. Octave knows about arithmetic operations (+,-,*,/), exponentiation (^), natural logarithms/exponents (log, exp), and the trigonometric functions (sin, cos, &amp;hellip;). Moreover, Octave calculations work on real or imaginary numbers (i,j). In addition, some mathematical constants such as the base of the natural logarithm (e) and the ratio of a circle&amp;rsquo;s circumference to its diameter (pi) are pre-defined.</source>
          <target state="translated">옥타브는 기본적인 수치 계산에 쉽게 사용할 수 있습니다. 옥타브는 산술 연산 (+,-, *, /), 지수 (^), 자연 로그 / 지수 (log, exp) 및 삼각 함수 (sin, cos,&amp;hellip;)에 대해 알고 있습니다. 또한 옥타브 계산은 실수 또는 허수 (i, j)에서 작동합니다. 또한 자연 로그의 밑수 (e)와 원주와 지름 (pi)의 비율과 같은 수학적 상수가 미리 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3e598971a56e6526f674cdce1bfc4cab4d58b05" translate="yes" xml:space="preserve">
          <source>Octave can find the roots of a given polynomial. This is done by computing the companion matrix of the polynomial (see the &lt;code&gt;compan&lt;/code&gt; function for a definition), and then finding its eigenvalues.</source>
          <target state="translated">옥타브는 주어진 다항식의 근을 찾을 수 있습니다. 이것은 다항식 컴패니언 매트릭스 (투시 연산에 의해 수행되는 &lt;code&gt;compan&lt;/code&gt; 정의에 대한 기능)을하고 그 고유 값을 찾는.</target>
        </trans-unit>
        <trans-unit id="9f1432abb8ea6436fb1e2122bdd395cdf5023d3a" translate="yes" xml:space="preserve">
          <source>Octave can generate random numbers from a large number of distributions. The random number generators are based on the random number generators described in &lt;a href=&quot;special-utility-matrices#Special-Utility-Matrices&quot;&gt;Special Utility Matrices&lt;/a&gt;.</source>
          <target state="translated">옥타브는 많은 분포에서 난수를 생성 할 수 있습니다. 난수 생성기는 &lt;a href=&quot;special-utility-matrices#Special-Utility-Matrices&quot;&gt;특수 유틸리티 행렬에&lt;/a&gt; 설명 된 난수 생성기를 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="6d207520d65dc7fb68be18eda2fea83f7b6f470c" translate="yes" xml:space="preserve">
          <source>Octave can plot a function from a function handle, inline function, or string defining the function without the user needing to explicitly create the data to be plotted. The function &lt;code&gt;fplot&lt;/code&gt; also generates two-dimensional plots with linear axes using a function name and limits for the range of the x-coordinate instead of the x and y data. For example,</source>
          <target state="translated">옥타브는 사용자가 플롯 할 데이터를 명시 적으로 만들 필요없이 함수를 정의하는 함수 핸들, 인라인 함수 또는 문자열에서 함수를 플로팅 할 수 있습니다. 함수 &lt;code&gt;fplot&lt;/code&gt; 은 함수 이름과 x 및 y 데이터 대신 x 좌표 범위의 한계를 사용하여 선형 축으로 2 차원 플롯을 생성합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="dffef3fcbe50efa6cc22d4090b65ba79e9061012" translate="yes" xml:space="preserve">
          <source>Octave can read and write binary data using the functions &lt;code&gt;fread&lt;/code&gt; and &lt;code&gt;fwrite&lt;/code&gt;, which are patterned after the standard C functions with the same names. They are able to automatically swap the byte order of integer data and convert among the supported floating point formats as the data are read.</source>
          <target state="translated">옥타브는 &lt;code&gt;fread&lt;/code&gt; 및 &lt;code&gt;fwrite&lt;/code&gt; 함수를 사용하여 이진 데이터를 읽고 쓸 수 있습니다 .이 함수는 동일한 이름을 가진 표준 C 함수 다음에 패턴 화됩니다. 정수 데이터의 바이트 순서를 자동으로 바꾸고 데이터를 읽을 때 지원되는 부동 소수점 형식으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3908f1ccbdeae0c4004cc4fe5317981d34b63026" translate="yes" xml:space="preserve">
          <source>Octave can solve Linear Programming problems using the &lt;code&gt;glpk&lt;/code&gt; function. That is, Octave can solve</source>
          <target state="translated">옥타브는 &lt;code&gt;glpk&lt;/code&gt; 함수를 사용하여 선형 프로그래밍 문제를 해결할 수 있습니다 . 즉, Octave가 해결할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="acb3ed8648f6721f04bc45a1a1fc6b1ac5573025" translate="yes" xml:space="preserve">
          <source>Octave can solve sets of nonlinear equations of the form</source>
          <target state="translated">옥타브는 형태의 비선형 방정식 세트를 풀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc2eb79877fe8596efcd519ab48404eabd6c384e" translate="yes" xml:space="preserve">
          <source>Octave comes with functions for computing the derivative and the integral of a polynomial. The functions &lt;code&gt;polyder&lt;/code&gt; and &lt;code&gt;polyint&lt;/code&gt; both return new polynomials describing the result. As an example we&amp;rsquo;ll compute the definite integral of &lt;em&gt;p(x) = x^2 + 1&lt;/em&gt; from 0 to 3.</source>
          <target state="translated">옥타브는 도함수와 다항식의 적분을 계산하는 함수와 함께 제공됩니다. 함수 &lt;code&gt;polyder&lt;/code&gt; 와 &lt;code&gt;polyint&lt;/code&gt; 는 모두 결과를 설명하는 새로운 다항식을 반환합니다. 예를 들어 &lt;em&gt;p (x) = x ^ 2 + 1&lt;/em&gt; 의 명확한 적분 을 0에서 3으로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="110b618e7c872db073ce1404691e98888747d50f" translate="yes" xml:space="preserve">
          <source>Octave comes with good support for various kinds of interpolation, most of which are described in &lt;a href=&quot;interpolation#Interpolation&quot;&gt;Interpolation&lt;/a&gt;. One simple alternative to the functions described in the aforementioned chapter, is to fit a single polynomial, or a piecewise polynomial (spline) to some given data points. To avoid a highly fluctuating polynomial, one most often wants to fit a low-order polynomial to data. This usually means that it is necessary to fit the polynomial in a least-squares sense, which just is what the &lt;code&gt;polyfit&lt;/code&gt; function does.</source>
          <target state="translated">옥타브에 설명되어 대부분의 보간의 다양한 종류, 좋은 지원이 제공 &lt;a href=&quot;interpolation#Interpolation&quot;&gt;보간&lt;/a&gt; . 앞서 언급 한 장에서 설명 된 기능에 대한 간단한 대안은 단일 다항식 또는 부분 다항식 (스플라인)을 일부 주어진 데이터 포인트에 맞추는 것입니다. 변동성이 큰 다항식을 피하기 위해 데이터에 하위 다항식을 맞추려는 경우가 가장 많습니다. 바로 무엇 최소 제곱 의미에서 다항식에 맞게 필요하다고 이것은 보통 수단 &lt;code&gt;polyfit&lt;/code&gt; 의 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="bc213aaef9c2247bf4085cc25819ab89fb813c72" translate="yes" xml:space="preserve">
          <source>Octave comes with several built-in functions for computing the integral of a function numerically (termed quadrature). These functions all solve 1-dimensional integration problems.</source>
          <target state="translated">옥타브에는 숫자의 함수 (구적법)를 계산하기위한 몇 가지 내장 함수가 내장되어 있습니다. 이러한 기능은 모두 1 차원 통합 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="326996bb8c2b3299e2eb7efe284c6e92834d54b8" translate="yes" xml:space="preserve">
          <source>Octave comes with support for solving various kinds of optimization problems. Specifically Octave can solve problems in Linear Programming, Quadratic Programming, Nonlinear Programming, and Linear Least Squares Minimization.</source>
          <target state="translated">옥타브는 다양한 종류의 최적화 문제 해결을 지원합니다. 특히 Octave는 선형 프로그래밍, 2 차 프로그래밍, 비선형 프로그래밍 및 선형 최소 제곱 최소화 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6688b3e6574ef398e2f000cdee22c93474ccbf8c" translate="yes" xml:space="preserve">
          <source>Octave configuration variables as above, but currently unused by &lt;code&gt;mkoctfile&lt;/code&gt;.</source>
          <target state="translated">위와 같이 구성 변수를 옥타브하지만 현재 &lt;code&gt;mkoctfile&lt;/code&gt; 에서는 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="59ecb2acb4c11a523f6bcd5ce2d8f26ead9ceacd" translate="yes" xml:space="preserve">
          <source>Octave configuration variables that are provided for informational purposes only. Except for &amp;lsquo;</source>
          <target state="translated">정보 용으로 만 제공되는 옥타브 구성 변수 '제외</target>
        </trans-unit>
        <trans-unit id="43cdcc3b75568997ff6fea38a8c2c2d83245d0a2" translate="yes" xml:space="preserve">
          <source>Octave configuration variables that users may override with environment variables. These are used in commands that &lt;code&gt;mkoctfile&lt;/code&gt; executes.</source>
          <target state="translated">사용자가 환경 변수로 대체 할 수있는 옥타브 구성 변수. 이들은 &lt;code&gt;mkoctfile&lt;/code&gt; 이 실행하는 명령에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce918ce83922bf2c45f328972cb119f00983f7d3" translate="yes" xml:space="preserve">
          <source>Octave does not require you to load function definitions from files before using them. You simply need to put the function definitions in a place where Octave can find them.</source>
          <target state="translated">Octave에서는 파일을 사용하기 전에 파일에서 함수 정의를로드 할 필요가 없습니다. 함수 정의를 옥타브가 찾을 수있는 곳에두면됩니다.</target>
        </trans-unit>
        <trans-unit id="d3bad1d85ac0fe79d38b3e762fa038ef7bbd5017" translate="yes" xml:space="preserve">
          <source>Octave has a number of functions for managing sets of data. A set is defined as a collection of unique elements and is typically represented by a vector of numbers sorted in ascending order. Any vector or matrix can be converted to a set by removing duplicates through the use of the &lt;code&gt;unique&lt;/code&gt; function. However, it isn&amp;rsquo;t necessary to explicitly create a set as all of the functions which operate on sets will convert their input to a set before proceeding.</source>
          <target state="translated">옥타브에는 데이터 세트를 관리하기위한 여러 기능이 있습니다. 집합은 고유 한 요소의 모음으로 정의되며 일반적으로 오름차순으로 정렬 된 숫자 벡터로 표시됩니다. &lt;code&gt;unique&lt;/code&gt; 함수를 사용하여 중복을 제거하여 모든 벡터 또는 행렬을 세트로 변환 할 수 있습니다 . 그러나 세트에서 작동하는 모든 기능이 계속 진행하기 전에 입력을 세트로 변환하므로 세트를 명시 적으로 작성할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d61552fecbf5e7d3f9cb82d4e00b4df3ed2e6147" translate="yes" xml:space="preserve">
          <source>Octave has a provision for attaching application-defined data to a graphics handle. The data can be anything which is meaningful to the application, and will be completely ignored by Octave.</source>
          <target state="translated">Octave에는 응용 프로그램 정의 데이터를 그래픽 핸들에 연결하는 기능이 있습니다. 데이터는 애플리케이션에 의미가있을 수 있으며 Octave에서는 완전히 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="82fff1feb92c7da903d3a2aaa47a21cd417bba63" translate="yes" xml:space="preserve">
          <source>Octave has an extensive help facility. The same documentation that is available in printed form is also available from the Octave prompt, because both forms of the documentation are created from the same input file.</source>
          <target state="translated">옥타브에는 광범위한 도움말 기능이 있습니다. 옥타브 프롬프트에서도 인쇄 된 형식으로 제공되는 동일한 문서를 사용할 수 있습니다. 두 가지 형식의 문서가 모두 동일한 입력 파일에서 작성되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="4eac8ba1df7a11fd89738d621c80607c49b93e32" translate="yes" xml:space="preserve">
          <source>Octave has built-in functions for solving nonlinear differential equations of the form</source>
          <target state="translated">옥타브는 형태의 비선형 미분 방정식을 푸는 기능을 내장하고 있습니다</target>
        </trans-unit>
        <trans-unit id="dbbb0006313f2c93716737dbc0f46bca5827f479" translate="yes" xml:space="preserve">
          <source>Octave has built-in functions for solving ordinary differential equations, and differential-algebraic equations. All solvers are based on reliable ODE routines written in Fortran.</source>
          <target state="translated">옥타브에는 일반 미분 방정식과 미분 대수 방정식을 푸는 함수가 내장되어 있습니다. 모든 솔버는 Fortran으로 작성된 신뢰할 수있는 ODE 루틴을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="212b077f5a867ed2b28bb02b63c5abdd5ed098d0" translate="yes" xml:space="preserve">
          <source>Octave has built-in support for logical values, i.e., variables that are either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;. When comparing two variables, the result will be a logical value whose value depends on whether or not the comparison is true.</source>
          <target state="translated">옥타브는 논리 값, 즉 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 변수를 기본적으로 지원합니다 . 두 변수를 비교할 때 결과는 비교가 참인지 여부에 따라 값이 달라지는 논리 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="b7347d2e7b4a992d2593573f02ebfa44957e6a8a" translate="yes" xml:space="preserve">
          <source>Octave has functions for computing the Probability Density Function (PDF), the Cumulative Distribution function (CDF), and the quantile (the inverse of the CDF) for arbitrary user-defined distributions (discrete) and for experimental data (empirical).</source>
          <target state="translated">Octave에는 확률 밀도 함수 (PDF), 누적 분포 함수 (CDF) 및 임의의 사용자 정의 분포 (이산) 및 실험 데이터 (임시)에 대한 Quantile (CDF의 역)을 계산하는 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b1e2bccd5587b5fdd521db27b64a3655ddea50d" translate="yes" xml:space="preserve">
          <source>Octave has support for various statistical methods. The emphasis is on basic descriptive statistics, but the Octave Forge statistics package includes probability distributions, statistical tests, random number generation, and much more.</source>
          <target state="translated">옥타브는 다양한 통계 방법을 지원합니다. 기본 기술 통계에 중점을 두지 만 Octave Forge 통계 패키지에는 확률 분포, 통계 테스트, 난수 생성 등이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f8d6acf2828d38d660afd74b89632b69a2ebfb74" translate="yes" xml:space="preserve">
          <source>Octave has the ability to create user-defined classes&amp;mdash;including the capabilities of operator and function overloading. Classes can protect internal properties so that they may not be altered accidentally which facilitates data encapsulation. In addition, rules can be created to address the issue of class precedence in mixed class operations.</source>
          <target state="translated">옥타브는 연산자 및 함수 오버로딩 기능을 포함하여 사용자 정의 클래스를 생성 할 수 있습니다. 클래스는 내부 속성을 보호하여 실수로 변경되지 않도록하여 데이터 캡슐화를 용이하게합니다. 또한 혼합 클래스 작업에서 클래스 우선 순위 문제를 해결하기위한 규칙을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b56e7748db824b1b70e960c3c3b32ccfef4b866" translate="yes" xml:space="preserve">
          <source>Octave has the functions &lt;code&gt;triplot&lt;/code&gt;, &lt;code&gt;trimesh&lt;/code&gt;, and &lt;code&gt;trisurf&lt;/code&gt; to plot the Delaunay triangulation of a 2-dimensional set of points. &lt;code&gt;tetramesh&lt;/code&gt; will plot the triangulation of a 3-dimensional set of points.</source>
          <target state="translated">옥타브 기능 갖는다 &lt;code&gt;triplot&lt;/code&gt; , &lt;code&gt;trimesh&lt;/code&gt; 및 &lt;code&gt;trisurf&lt;/code&gt; 는 포인트의 2 차원 세트의 들로네 삼각 분할을 플롯 할 수있다. &lt;code&gt;tetramesh&lt;/code&gt; 는 3 차원 점 세트의 삼각 분할을 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="1820bb4a8dba35ca503a6085262a8efc4556497f" translate="yes" xml:space="preserve">
          <source>Octave has three functions that make it easy to prompt users for input. The &lt;code&gt;input&lt;/code&gt; and &lt;code&gt;menu&lt;/code&gt; functions are normally used for managing an interactive dialog with a user, and the &lt;code&gt;keyboard&lt;/code&gt; function is normally used for doing simple debugging.</source>
          <target state="translated">옥타브에는 세 가지 기능이있어 사용자에게 입력을 쉽게 할 수 있습니다. &lt;code&gt;input&lt;/code&gt; 및 &lt;code&gt;menu&lt;/code&gt; 기능은 일반적으로 사용자와 상호 작용하는 대화 상자를 관리하는 데 사용되며, &lt;code&gt;keyboard&lt;/code&gt; 기능은 일반적으로 간단한 디버깅을 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0f38bfe34ae989704a9ca4abe249702cfaa2fc20" translate="yes" xml:space="preserve">
          <source>Octave includes a built-in debugger to aid in the development of scripts. This can be used to interrupt the execution of an Octave script at a certain point, or when certain conditions are met. Once execution has stopped, and debug mode is entered, the symbol table at the point where execution has stopped can be examined and modified to check for errors.</source>
          <target state="translated">Octave에는 스크립트 개발을 지원하는 내장 디버거가 포함되어 있습니다. 특정 시점 또는 특정 조건이 충족 될 때 Octave 스크립트 실행을 중단하는 데 사용할 수 있습니다. 실행이 중지되고 디버그 모드가 시작되면 실행이 중지 된 지점의 심볼 테이블을 검사하고 수정하여 오류를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="278b9b59fa3fc06e0be6ffdfbd63e2013644090e" translate="yes" xml:space="preserve">
          <source>Octave includes a number of functions to allow the integration of testing and demonstration code in the source code of the functions themselves.</source>
          <target state="translated">옥타브에는 함수 자체의 소스 코드에 테스트 및 데모 코드를 통합 할 수있는 여러 함수가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="15c99b511eff2d7803b79eea304df50e36b8e58d" translate="yes" xml:space="preserve">
          <source>Octave includes a polymorphic solver for sparse matrices, where the exact solver used to factorize the matrix, depends on the properties of the sparse matrix itself. Generally, the cost of determining the matrix type is small relative to the cost of factorizing the matrix itself, but in any case the matrix type is cached once it is calculated, so that it is not re-determined each time it is used in a linear equation.</source>
          <target state="translated">옥타브에는 희소 행렬에 대한 다형성 솔버가 포함되어 있으며, 행렬을 분해하는 데 사용되는 정확한 솔버는 희소 행렬 자체의 속성에 따라 다릅니다. 일반적으로, 매트릭스 유형을 결정하는 비용은 매트릭스 자체를 인수 분해하는 비용에 비해 작지만, 어쨌든 매트릭스 유형은 일단 계산되면 캐시되므로, 사용될 때마다 다시 결정되지 않습니다. 일차 방정식.</target>
        </trans-unit>
        <trans-unit id="135e3c5cc173770c3767b41493b972b462a2d196" translate="yes" xml:space="preserve">
          <source>Octave includes a polymorphic solver that selects an appropriate matrix factorization depending on the properties of the matrix itself. Generally, the cost of determining the matrix type is small relative to the cost of factorizing the matrix itself. In any case the matrix type is cached once it is calculated so that it is not re-determined each time it is used in a linear equation.</source>
          <target state="translated">옥타브에는 행렬 자체의 속성에 따라 적절한 행렬 분해를 선택하는 다형성 솔버가 포함되어 있습니다. 일반적으로, 매트릭스 타입을 결정하는 비용은 매트릭스 자체를 분해하는 비용에 비해 작다. 어쨌든 행렬 유형은 일단 계산되면 선형 방정식에 사용될 때마다 다시 결정되지 않도록 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="00aeca59c49f4e685c2ef7aeb8e3340620fa7f50" translate="yes" xml:space="preserve">
          <source>Octave includes an interface to allow legacy mex-files to be compiled and used with Octave. This interface can also be used to share compiled code between Octave and &lt;small&gt;MATLAB&lt;/small&gt; users. However, as mex-files expose &lt;small&gt;MATLAB&lt;/small&gt;&amp;rsquo;s internal API, and the internal structure of Octave is different, a mex-file can never have the same performance in Octave as the equivalent oct-file. In particular, to support the manner in which variables are passed to mex functions there are a significant number of additional copies of memory blocks when invoking or returning from a mex-file function. For this reason, it is recommended that any new code be written with the oct-file interface previously discussed.</source>
          <target state="translated">Octave에는 레거시 mex 파일을 Octave와 함께 컴파일하고 사용할 수있는 인터페이스가 포함되어 있습니다. 이 인터페이스는 Octave와 &lt;small&gt;MATLAB&lt;/small&gt; 사용자 간에 컴파일 된 코드를 공유하는 데에도 사용할 수 있습니다 . 그러나 mex 파일이 &lt;small&gt;MATLAB&lt;/small&gt; 의 내부 API를 노출 하고 Octave의 내부 구조가 다르기 때문에 meave 파일은 옥타브에서 동등한 oct 파일과 동일한 성능을 가질 수 없습니다. 특히, 변수가 mex 함수에 전달되는 방식을 지원하기 위해 mex-file 함수를 호출하거나 리턴 할 때 메모리 블록의 추가 사본이 많이 있습니다. 이러한 이유로 이전에 설명한 oct 파일 인터페이스로 새 코드를 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="210865fd55d1320f5e30e9a74478014f91423629" translate="yes" xml:space="preserve">
          <source>Octave includes many utility functions for copying, moving, renaming, and deleting files; for creating, reading, and deleting directories; for retrieving status information on files; and for manipulating file and path names.</source>
          <target state="translated">옥타브에는 파일 복사, 이동, 이름 바꾸기 및 삭제를위한 많은 유틸리티 기능이 포함되어 있습니다. 디렉토리 작성, 읽기 및 삭제; 파일의 상태 정보를 검색하기 위해; 파일 및 경로 이름을 조작합니다.</target>
        </trans-unit>
        <trans-unit id="018abc0bf50994f18df3bd22216cf7e19dc7caa1" translate="yes" xml:space="preserve">
          <source>Octave includes several functions for computing the integral of functions of multiple variables. This procedure can generally be performed by creating a function that integrates &lt;em&gt;f&lt;/em&gt; with respect to &lt;em&gt;x&lt;/em&gt;, and then integrates that function with respect to &lt;em&gt;y&lt;/em&gt;. This procedure can be performed manually using the following example which integrates the function:</source>
          <target state="translated">옥타브에는 여러 변수의 함수 적분을 계산하기위한 여러 함수가 포함됩니다. 이 절차는 일반적으로 &lt;em&gt;x에&lt;/em&gt; 대해 &lt;em&gt;f&lt;/em&gt; 를 통합 한 다음 &lt;em&gt;y에&lt;/em&gt; 대해 해당 기능을 통합하는 함수를 작성하여 수행 할 수 있습니다 . 이 절차는 기능을 통합 한 다음 예제를 사용하여 수동으로 수행 할 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="71cbe1e7f6c413abae36f1b2ace2795c137a98c6" translate="yes" xml:space="preserve">
          <source>Octave includes several functions for printing error and warning messages. When you write functions that need to take special action when they encounter abnormal conditions, you should print the error messages using the functions described in this chapter.</source>
          <target state="translated">옥타브에는 오류 및 경고 메시지를 인쇄하기위한 여러 기능이 있습니다. 비정상적인 상황이 발생했을 때 특별한 조치가 필요한 기능을 작성할 때는이 장에서 설명하는 기능을 사용하여 오류 메시지를 인쇄해야합니다.</target>
        </trans-unit>
        <trans-unit id="3dc7bb0acede4d538bf500235230b303a5c93f76" translate="yes" xml:space="preserve">
          <source>Octave includes some high-level commands like &lt;code&gt;system&lt;/code&gt; and &lt;code&gt;popen&lt;/code&gt; for starting subprocesses. If you want to run another program to perform some task and then look at its output, you will probably want to use these functions.</source>
          <target state="translated">Octave에는 하위 프로세스를 시작하기위한 &lt;code&gt;system&lt;/code&gt; 및 &lt;code&gt;popen&lt;/code&gt; 과 같은 고급 명령이 포함되어 있습니다 . 다른 프로그램을 실행하여 일부 작업을 수행 한 다음 출력을 확인하려면 이러한 기능을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d0d7cd712c8f1956172fcee760124e2a613727de" translate="yes" xml:space="preserve">
          <source>Octave includes support for organizing data in structures. The current implementation uses an associative array with indices limited to strings, but the syntax is more like C-style structures.</source>
          <target state="translated">옥타브는 구조로 데이터를 구성하는 기능을 지원합니다. 현재 구현에서는 인덱스가 문자열로 제한된 연관 배열을 사용하지만 구문은 C 스타일 구조와 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="70bfd80965cec4b97db4706f6bc2c4e70b100160" translate="yes" xml:space="preserve">
          <source>Octave includes support for single precision data types, and most of the functions in Octave accept single precision values and return single precision answers. A single precision variable is created with the &lt;code&gt;single&lt;/code&gt; function.</source>
          <target state="translated">옥타브는 단 정밀도 데이터 유형을 지원하며 옥타브의 대부분의 함수는 단 정밀도 값을 수락하고 단 정밀도 답변을 반환합니다. 단일 정밀도 변수는 &lt;code&gt;single&lt;/code&gt; 함수로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="5bb9076336ff5332da40081e13bd28f92a3e5633" translate="yes" xml:space="preserve">
          <source>Octave includes support for three different mechanisms to contain arbitrary data types in the same variable: Structures, which are C-like, and are indexed with named fields; containers.Map objects, which store data in key/value pairs; and cell arrays, where each element of the array can have a different data type and or shape. Multiple input arguments and return values of functions are organized as another data container, the comma separated list.</source>
          <target state="translated">옥타브에는 동일한 변수에 임의의 데이터 유형을 포함하는 세 가지 메커니즘이 지원됩니다. 컨테이너.지도 객체-키 / 값 쌍으로 데이터를 저장합니다. 및 셀 어레이, 여기서 어레이의 각 요소는 상이한 데이터 유형 및 / 또는 형상을 가질 수있다. 함수의 여러 입력 인수와 반환 값은 쉼표로 구분 된 다른 데이터 컨테이너로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="51a41e16280423f939223964aed1f8d533fe9890" translate="yes" xml:space="preserve">
          <source>Octave is a fairly large program with many build dependencies. You may be able to find pre-packaged versions of the dependencies distributed as part of your system, or you may have to build some or all of them yourself.</source>
          <target state="translated">옥타브는 빌드 의존성이 많은 상당히 큰 프로그램입니다. 시스템의 일부로 분배 된 사전 패키지 된 종속성 버전을 찾거나 직접 또는 일부를 빌드해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="62fe38e92c0abb3317c778d148f94347bfea82a7" translate="yes" xml:space="preserve">
          <source>Octave is a fantastic language for solving many problems in science and engineering. However, it is not the only computer language and there are times when you may want to use code written in other languages. Good reasons for doing so include: 1) not re-inventing the wheel; existing function libraries which have been thoroughly tested and debugged or large scale simulation codebases are a good example, 2) accessing unique capabilities of a different language; for example the well-known regular expression functions of Perl (but don&amp;rsquo;t do that because &lt;code&gt;regexp&lt;/code&gt; already exists in Octave).</source>
          <target state="translated">옥타브는 과학 및 공학의 많은 문제를 해결하기위한 환상적인 언어입니다. 그러나 이것이 유일한 컴퓨터 언어는 아니며 다른 언어로 작성된 코드를 사용하려는 경우가 있습니다. 그렇게하는 좋은 이유는 다음과 같습니다 : 1) 바퀴를 재발 명하지 않음; 철저히 테스트되고 디버깅되었거나 대규모 시뮬레이션 코드베이스가있는 기존 함수 라이브러리가 좋은 예입니다. 2) 다른 언어의 고유 한 기능에 액세스합니다. 예를 들어 펄의 잘 알려진 정규 표현식 함수 (그러나 때문에 그렇게하지 않는 &lt;code&gt;regexp&lt;/code&gt; 이미 옥타브에 존재).</target>
        </trans-unit>
        <trans-unit id="adf3eacd15fd3f74e2d1ae726bc30bf0bba3cdca" translate="yes" xml:space="preserve">
          <source>Octave is able to produce output for various printers, bitmaps, and vector formats by using Ghostscript. For bitmap and printer output anti-aliasing is applied using Ghostscript&amp;rsquo;s TextAlphaBits and GraphicsAlphaBits options. The default number of bits are 4 and 1 respectively. Allowed values for &lt;var&gt;N&lt;/var&gt; are 1, 2, or 4.</source>
          <target state="translated">Octave는 Ghostscript를 사용하여 다양한 프린터, 비트 맵 및 벡터 형식에 대한 출력을 생성 할 수 있습니다. 비트 맵 및 프린터 출력의 경우 앤티 앨리어싱은 Ghostscript의 TextAlphaBits 및 GraphicsAlphaBits 옵션을 사용하여 적용됩니다. 기본 비트 수는 각각 4와 1입니다. &lt;var&gt;N&lt;/var&gt; 에 허용되는 값 은 1, 2 또는 4입니다.</target>
        </trans-unit>
        <trans-unit id="fd7b960db8753a3a9d7ff3d654d826f75ff530c4" translate="yes" xml:space="preserve">
          <source>Octave is capable of storing strings up to &lt;em&gt;2^{31} - 1&lt;/em&gt; in length. However for &lt;small&gt;MATLAB&lt;/small&gt; compatibility all variable, function, and structure field names should be shorter than the length returned by &lt;code&gt;namelengthmax&lt;/code&gt;. In particular, variables stored to a &lt;small&gt;MATLAB&lt;/small&gt; file format (</source>
          <target state="translated">옥타브는 최대 &lt;em&gt;2 ^ {31}-1&lt;/em&gt; 길이의 문자열을 저장할 수 있습니다. 그러나 &lt;small&gt;MATLAB&lt;/small&gt; 호환성을 위해 모든 변수, 함수 및 구조 필드 이름은 &lt;code&gt;namelengthmax&lt;/code&gt; 에서 반환 한 길이보다 짧아야 합니다. 특히 변수는 &lt;small&gt;MATLAB&lt;/small&gt; 파일 형식 (</target>
        </trans-unit>
        <trans-unit id="85999ce56b6f29313f5e006b3eb74c17ab2f0a86" translate="yes" xml:space="preserve">
          <source>Octave is principally a batch or command-line language. However, it does offer some features for constructing graphical interfaces that interact with users.</source>
          <target state="translated">옥타브는 주로 배치 또는 명령 줄 언어입니다. 그러나 사용자와 상호 작용하는 그래픽 인터페이스를 구성하기위한 일부 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="829406248f29f6dc75dd10aac9fe663d81054511" translate="yes" xml:space="preserve">
          <source>Octave normally keeps track of the commands you type so that you can recall previous commands to edit or execute them again. When you exit Octave, the most recent commands you have typed, up to the number specified by the variable &lt;code&gt;history_size&lt;/code&gt;, are saved in a file. When Octave starts, it loads an initial list of commands from the file named by the variable &lt;code&gt;history_file&lt;/code&gt;.</source>
          <target state="translated">옥타브는 일반적으로 사용자가 입력 한 명령을 추적하므로 이전 명령을 불러 와서 다시 편집하거나 실행할 수 있습니다. Octave를 종료하면, &lt;code&gt;history_size&lt;/code&gt; 변수에 의해 지정된 수까지 입력 한 가장 최근의 명령이 파일에 저장됩니다. Octave는 시작될 때 &lt;code&gt;history_file&lt;/code&gt; 변수로 이름이 지정된 파일에서 명령의 초기 목록을로드합니다 .</target>
        </trans-unit>
        <trans-unit id="1f670e2aaf24907b9580fed2a8c2b6307a7fa48f" translate="yes" xml:space="preserve">
          <source>Octave ordinarily examines the properties of the matrix &lt;var&gt;A&lt;/var&gt; and chooses a solver that best matches the matrix. By passing a structure &lt;var&gt;opts&lt;/var&gt; to &lt;code&gt;linsolve&lt;/code&gt; you can inform Octave directly about the matrix &lt;var&gt;A&lt;/var&gt;. In this case Octave will skip the matrix examination and proceed directly to solving the linear system.</source>
          <target state="translated">옥타브는 보통 행렬 &lt;var&gt;A&lt;/var&gt; 의 속성을 검사하고 행렬 과 가장 일치하는 솔버를 선택합니다. 구조에 전달하여 &lt;var&gt;opts&lt;/var&gt; 에 &lt;code&gt;linsolve&lt;/code&gt; 당신은 매트릭스에 대해 직접 옥타브를 알릴 수 . 이 경우 Octave는 매트릭스 검사를 건너 뛰고 선형 시스템 해결을 직접 진행합니다. &lt;var&gt;A&lt;/var&gt;</target>
        </trans-unit>
        <trans-unit id="7572c372d92aedfc2254bafe3feaf510e3ea626e" translate="yes" xml:space="preserve">
          <source>Octave provides a few functions for dealing with audio data. An audio &amp;lsquo;sample&amp;rsquo; is a single output value from an A/D converter, i.e., a small integer number (usually 8 or 16 bits), and audio data is just a series of such samples. It can be characterized by three parameters: the sampling rate (measured in samples per second or Hz, e.g., 8000 or 44100), the number of bits per sample (e.g., 8 or 16), and the number of channels (1 for mono, 2 for stereo, etc.).</source>
          <target state="translated">옥타브는 오디오 데이터를 다루기위한 몇 가지 기능을 제공합니다. 오디오 '샘플'은 A / D 변환기의 단일 출력 값, 즉 작은 정수 (일반적으로 8 또는 16 비트)이며 오디오 데이터는 일련의 이러한 샘플입니다. 샘플링 속도 (초당 샘플 수 또는 Hz, 예를 들어 8000 또는 44100로 측정), 샘플 당 비트 수 (예 : 8 또는 16) 및 채널 수 (모노의 경우 1)의 세 가지 매개 변수가 특징입니다. , 스테레오 등의 경우 2).</target>
        </trans-unit>
        <trans-unit id="0032553bf5737c923a77294358959a19432de2da" translate="yes" xml:space="preserve">
          <source>Octave provides a number of functions for the manipulation of numeric values on a bit by bit basis. The basic functions to set and obtain the values of individual bits are &lt;code&gt;bitset&lt;/code&gt; and &lt;code&gt;bitget&lt;/code&gt;.</source>
          <target state="translated">옥타브는 비트 단위로 숫자 값을 조작하기위한 많은 기능을 제공합니다. 개별 비트의 값을 설정하고 얻는 기본 기능은 &lt;code&gt;bitset&lt;/code&gt; 및 &lt;code&gt;bitget&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a5ee7fca567e728fe1b9e7f568cfdbf017901748" translate="yes" xml:space="preserve">
          <source>Octave provides several ways of recovering from errors. There are &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt; blocks, &lt;code&gt;unwind_protect&lt;/code&gt;/&lt;code&gt;unwind_protect_cleanup&lt;/code&gt; blocks, and finally the &lt;code&gt;onCleanup&lt;/code&gt; command.</source>
          <target state="translated">옥타브는 여러 가지 오류 복구 방법을 제공합니다. 있다 &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; 블록, &lt;code&gt;unwind_protect&lt;/code&gt; / &lt;code&gt;unwind_protect_cleanup&lt;/code&gt; 블록, 그리고 마지막으로 &lt;code&gt;onCleanup&lt;/code&gt; 의 명령.</target>
        </trans-unit>
        <trans-unit id="4f4dbb8878dd5ff1e78a6c7f03130d99401b03ba" translate="yes" xml:space="preserve">
          <source>Octave provides simple means to create many different types of two- and three-dimensional plots using high-level functions.</source>
          <target state="translated">옥타브는 고급 기능을 사용하여 다양한 유형의 2 차원 및 3 차원 플롯을 생성하는 간단한 수단을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bdb96dc7e31d4fa19beb5dee155c4e6e9d519464" translate="yes" xml:space="preserve">
          <source>Octave provides special treatment of real and complex rectangular diagonal matrices, as well as permutation matrices. They are stored as special objects, using efficient storage and algorithms, facilitating writing both readable and efficient matrix algebra expressions in the Octave language. The special treatment may be disabled by using the functions &lt;em&gt;disable_diagonal_matrix&lt;/em&gt; and &lt;em&gt;disable_permutation_matrix&lt;/em&gt;.</source>
          <target state="translated">옥타브는 순열 행렬뿐만 아니라 실제 및 복잡한 직사각형 대각 행렬을 특별하게 처리합니다. 효율적인 저장 및 알고리즘을 사용하여 특수 객체로 저장되므로 옥타브 언어로 읽을 수 있고 효율적인 행렬 대수 표현을 쉽게 작성할 수 있습니다. &lt;em&gt;disable_diagonal_matrix&lt;/em&gt; 및 &lt;em&gt;disable_permutation_matrix&lt;/em&gt; 함수를 사용하여 특수 처리를 사용하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="293a1d120578b59b37dd32386a36046af0dcf38d" translate="yes" xml:space="preserve">
          <source>Octave provides the &lt;code&gt;scanf&lt;/code&gt;, &lt;code&gt;fscanf&lt;/code&gt;, and &lt;code&gt;sscanf&lt;/code&gt; functions to read formatted input. There are two forms of each of these functions. One can be used to extract vectors of data from a file, and the other is more &amp;lsquo;C-like&amp;rsquo;.</source>
          <target state="translated">Octave는 &lt;code&gt;scanf&lt;/code&gt; , &lt;code&gt;fscanf&lt;/code&gt; 및 &lt;code&gt;sscanf&lt;/code&gt; 함수를 제공하여 형식화 된 입력을 읽습니다. 이러한 각 기능에는 두 가지 형태가 있습니다. 하나는 파일에서 데이터 벡터를 추출하는 데 사용될 수 있으며 다른 하나는 더 'C와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="64be205ad4eee0e94f10ebcd23086045879d6fad" translate="yes" xml:space="preserve">
          <source>Octave provides the following trigonometric functions where angles are specified in degrees. These functions produce true zeros at the appropriate intervals rather than the small round-off error that occurs when using radians. For example:</source>
          <target state="translated">옥타브는 각도가 각도로 지정된 다음 삼각 함수를 제공합니다. 이러한 함수는 라디안을 사용할 때 발생하는 작은 반올림 오류가 아닌 적절한 간격으로 진정한 제로를 생성합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7bdc599659ddba73d44d01a8950f5bd9868d8f7b" translate="yes" xml:space="preserve">
          <source>Octave provides the following trigonometric functions where angles are specified in radians. To convert from degrees to radians multiply by &lt;code&gt;pi/180&lt;/code&gt; or use the &lt;code&gt;deg2rad&lt;/code&gt; function. For example, &lt;code&gt;sin (30 * pi/180)&lt;/code&gt; returns the sine of 30 degrees. As an alternative, Octave provides a number of trigonometric functions which work directly on an argument specified in degrees. These functions are named after the base trigonometric function with a &amp;lsquo;</source>
          <target state="translated">옥타브는 각도가 라디안으로 지정된 다음 삼각 함수를 제공합니다. 도에서 라디안으로 변환하려면 &lt;code&gt;pi/180&lt;/code&gt; 을 곱 하거나 &lt;code&gt;deg2rad&lt;/code&gt; 함수를 사용하십시오 . 예를 들어 &lt;code&gt;sin (30 * pi/180)&lt;/code&gt; 은 사인을 30 도로 반환합니다. 대안으로 Octave는 각도로 지정된 인수에서 직접 작동하는 여러 삼각 함수를 제공합니다. 이 함수들은 기본 삼각 함수의 이름을 '</target>
        </trans-unit>
        <trans-unit id="b81e09aefceaa90ef2995cec4cf2a9e40c1786e9" translate="yes" xml:space="preserve">
          <source>Octave provides two commands for initializing Readline and thereby changing the command line behavior.</source>
          <target state="translated">Octave는 Readline을 초기화하고 명령 행 동작을 변경하기위한 두 가지 명령을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2e63863a7ea082a5dc10c3d7e2a2d145d8dff737" translate="yes" xml:space="preserve">
          <source>Octave reports two kinds of errors for invalid programs.</source>
          <target state="translated">옥타브는 잘못된 프로그램에 대해 두 가지 종류의 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="a01c77d03d84b85da1b09bb9630e9f60f394fc3a" translate="yes" xml:space="preserve">
          <source>Octave requires approximately 1.4 GB of disk storage to unpack and compile from source (significantly less, 400 MB, if you don&amp;rsquo;t compile with debugging symbols). To compile without debugging symbols try the command</source>
          <target state="translated">옥타브는 소스에서 압축을 풀고 컴파일하기 위해 약 1.4GB의 디스크 스토리지가 필요합니다 (디버깅 심볼로 컴파일하지 않으면 400MB 미만). 심볼을 디버깅하지 않고 컴파일하려면 다음 명령을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="34628d169c7387d8aaa5d7c883aa02e4e25ec98a" translate="yes" xml:space="preserve">
          <source>Octave searches the &lt;var&gt;static classpath&lt;/var&gt; first, and then the &lt;var&gt;dynamic classpath&lt;/var&gt;. Classes appearing in the &lt;var&gt;static classpath&lt;/var&gt;, as well as in the &lt;var&gt;dynamic classpath&lt;/var&gt;, will therefore be found in the &lt;var&gt;static classpath&lt;/var&gt; and loaded from this location. Classes which will be used frequently, or must be available to all users, should be added to the &lt;var&gt;static classpath&lt;/var&gt;. The &lt;var&gt;static classpath&lt;/var&gt; is populated once from the contents of a plain text file named</source>
          <target state="translated">Octave는 &lt;var&gt;static classpath&lt;/var&gt; 먼저 검색 한 다음 &lt;var&gt;dynamic classpath&lt;/var&gt; 경로를 검색합니다 . 클래스에서 나타나는 &lt;var&gt;static classpath&lt;/var&gt; 뿐 아니라, &lt;var&gt;dynamic classpath&lt;/var&gt; , 따라서 검색된한다 &lt;var&gt;static classpath&lt;/var&gt; 및이 위치로부터로드. 자주 사용되거나 모든 사용자가 사용할 수있는 &lt;var&gt;static classpath&lt;/var&gt; 는 정적 클래스 경로에 추가해야합니다 . &lt;var&gt;static classpath&lt;/var&gt; 라는 일반 텍스트 파일의 내용에서 일단 채워집니다</target>
        </trans-unit>
        <trans-unit id="55da10af0b117b25a4c80d8a4f97b4b9b984d6e1" translate="yes" xml:space="preserve">
          <source>Octave simply treats audio data as vectors of samples (non-mono data are not supported yet). It is assumed that audio files using linear encoding have one of the extensions</source>
          <target state="translated">옥타브는 단순히 오디오 데이터를 샘플의 벡터로 취급합니다 (모노가 아닌 데이터는 아직 지원되지 않습니다). 선형 인코딩을 사용하는 오디오 파일의 확장자 중 하나가 있다고 가정합니다</target>
        </trans-unit>
        <trans-unit id="fe4f3f45b22fcf7fc6fe4224dad0e01d074af6a2" translate="yes" xml:space="preserve">
          <source>Octave supplies the &lt;code&gt;hash&lt;/code&gt; function to calculate hash values of strings and files, the latter in combination with the &lt;code&gt;fileread&lt;/code&gt; function. The &lt;code&gt;hash&lt;/code&gt; function supports the most common used cryptographic hash functions, namely MD5 and SHA-1.</source>
          <target state="translated">옥타브는 &lt;code&gt;hash&lt;/code&gt; 함수를 제공하여 문자열과 파일의 해시 값을 계산합니다. 후자는 파일 &lt;code&gt;fileread&lt;/code&gt; 기능 과 함께 사용 됩니다. &lt;code&gt;hash&lt;/code&gt; 함수 지지체는 가장 일반적인 암호화 해시 함수, 즉 MD5 및 SHA-1을 사용 하였다.</target>
        </trans-unit>
        <trans-unit id="c8dc6cbbbfbb6a3d3e1bac99fa27914fdb933e90" translate="yes" xml:space="preserve">
          <source>Octave supports a limited form of exception handling modeled after the unwind-protect form of Lisp.</source>
          <target state="translated">옥타브는 언 스프 프로텍트 형태의 Lisp를 모델로 한 제한된 형태의 예외 처리를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8a324e24696f8f7877fc5cfd9ad269179b94ddaf" translate="yes" xml:space="preserve">
          <source>Octave supports a number of different array and matrix classes, the majority of which are based on the &lt;code&gt;Array&lt;/code&gt; class. The exception are the sparse matrix types discussed separately below. There are three basic matrix types:</source>
          <target state="translated">Octave는 다양한 배열 및 매트릭스 클래스를 지원하며, 대부분은 &lt;code&gt;Array&lt;/code&gt; 클래스를 기반으로합니다 . 아래에 별도로 논의 된 희소 행렬 유형은 예외입니다. 세 가지 기본 매트릭스 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e40296bdafa8e08dfb2f398583456dec756f063" translate="yes" xml:space="preserve">
          <source>Octave supports a wide range of functions for manipulating strings. Since a string is just a matrix, simple manipulations can be accomplished using standard operators. The following example shows how to replace all blank characters with underscores.</source>
          <target state="translated">옥타브는 문자열 조작을위한 광범위한 기능을 지원합니다. 문자열은 단지 행렬이기 때문에 표준 연산자를 사용하여 간단한 조작을 수행 할 수 있습니다. 다음 예는 모든 빈 문자를 밑줄로 바꾸는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1c7d287822fe7c6ea86ea83b1c743f75466ee313" translate="yes" xml:space="preserve">
          <source>Octave supports conversion from the RGB color system to the HSV color system and vice versa. It is also possible to convert from a color RGB image to a grayscale image.</source>
          <target state="translated">옥타브는 RGB 컬러 시스템에서 HSV 컬러 시스템으로 또는 그 반대로의 변환을 지원합니다. 컬러 RGB 이미지에서 그레이 스케일 이미지로 변환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6753f6c4ec75e4115747993cc2bb585398ae2522" translate="yes" xml:space="preserve">
          <source>Octave supports five different adaptive quadrature algorithms for computing the integral of a function &lt;em&gt;f&lt;/em&gt; over the interval from &lt;em&gt;a&lt;/em&gt; to &lt;em&gt;b&lt;/em&gt;. These are</source>
          <target state="translated">Octave는 &lt;em&gt;a&lt;/em&gt; 에서 &lt;em&gt;b&lt;/em&gt; 까지의 구간에 걸쳐 함수 &lt;em&gt;f&lt;/em&gt; 의 적분을 계산하기 위해 5 개의 서로 다른 적응 적 직교 알고리즘을 지원합니다 . 이것들은&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5974861830de526a6f34cff14a9218e0533caba8" translate="yes" xml:space="preserve">
          <source>Octave supports integer matrices as an alternative to using double precision. It is possible to use both signed and unsigned integers represented by 8, 16, 32, or 64 bits. It should be noted that most computations require floating point data, meaning that integers will often change type when involved in numeric computations. For this reason integers are most often used to store data, and not for calculations.</source>
          <target state="translated">옥타브는 배정 밀도를 사용하는 대신 정수 행렬을 지원합니다. 8, 16, 32 또는 64 비트로 표시되는 부호있는 정수와 부호없는 정수를 모두 사용할 수 있습니다. 대부분의 계산에는 부동 소수점 데이터가 필요합니다. 이는 숫자 계산에 관여 할 때 정수가 종종 유형을 변경한다는 의미입니다. 이러한 이유로 정수는 데이터를 저장하는 데 가장 많이 사용되며 계산에는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44a853743c09a7d03ffa0c753d02bd2c5f72992b" translate="yes" xml:space="preserve">
          <source>Octave supports profiling of code execution on a per-function level. If profiling is enabled, each call to a function (supporting built-ins, operators, functions in oct- and mex-files, user-defined functions in Octave code and anonymous functions) is recorded while running Octave code. After that, this data can aid in analyzing the code behavior, and is in particular helpful for finding &amp;ldquo;hot spots&amp;rdquo; in the code which use up a lot of computation time and are the best targets to spend optimization efforts on.</source>
          <target state="translated">Octave는 기능별 수준에서 코드 실행 프로파일 링을 지원합니다. 프로파일 링이 활성화되면 Octave 코드를 실행하는 동안 함수 (내장, 연산자, oct 및 mex 파일의 함수, Octave 코드의 사용자 정의 함수 및 익명 함수 지원)에 대한 각 호출이 기록됩니다. 그 후이 데이터는 코드 동작을 분석하는 데 도움이되며 특히 많은 계산 시간을 소비하고 최적화 노력을 기울이는 가장 좋은 목표 인 코드에서 &quot;핫스팟&quot;을 찾는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="bab572673131ba951363bf1992d3c1afb946aade" translate="yes" xml:space="preserve">
          <source>Octave supports several basic set operations. Octave can compute the union, intersection, and difference of two sets. Octave also supports the &lt;em&gt;Exclusive Or&lt;/em&gt; set operation.</source>
          <target state="translated">옥타브는 몇 가지 기본 설정 작업을 지원합니다. 옥타브는 두 집합의 합집합, 교집합 및 차이를 계산할 수 있습니다. 옥타브는 &lt;em&gt;배타적 또는&lt;/em&gt; 설정 작업 도 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="0ed1507300ed7b1edfdbb9b392cf0d6fc60ce68e" translate="yes" xml:space="preserve">
          <source>Octave supports several methods for one-dimensional interpolation, most of which are described in this section. &lt;a href=&quot;polynomial-interpolation#Polynomial-Interpolation&quot;&gt;Polynomial Interpolation&lt;/a&gt; and &lt;a href=&quot;interpolation-on-scattered-data#Interpolation-on-Scattered-Data&quot;&gt;Interpolation on Scattered Data&lt;/a&gt; describe additional methods.</source>
          <target state="translated">옥타브는 1 차원 보간을위한 몇 가지 방법을 지원하며, 대부분이 섹션에서 설명합니다. &lt;a href=&quot;interpolation-on-scattered-data#Interpolation-on-Scattered-Data&quot;&gt;분산 데이터에 대한 &lt;/a&gt;&lt;a href=&quot;polynomial-interpolation#Polynomial-Interpolation&quot;&gt;다항식 보간&lt;/a&gt; 및 보간 은 추가 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="22dbe7dad72fb07b939998a39ff428eb12edc9d6" translate="yes" xml:space="preserve">
          <source>Octave supports several ways of reading and writing data to or from the prompt or a file. The simplest functions for data Input and Output (I/O) are easy to use, but only provide limited control of how data is processed. For more control, a set of functions modeled after the C standard library are also provided by Octave.</source>
          <target state="translated">옥타브는 프롬프트 나 파일에서 데이터를 읽고 쓰는 여러 가지 방법을 지원합니다. 데이터 입 / 출력 (I / O)을위한 가장 간단한 기능은 사용하기 쉽지만 데이터 처리 방법을 제한적으로 제어 할 수 있습니다. 더 많은 제어를 위해 C 표준 라이브러리를 모델링 한 함수 세트도 Octave에서 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4cf89050d99c61364e1b17c265831bf26ce6b24c" translate="yes" xml:space="preserve">
          <source>Octave supports the FTP protocol through an object-oriented interface. Use the function &lt;code&gt;ftp&lt;/code&gt; to create an FTP object which represents the connection. All FTP functions take an FTP object as the first argument.</source>
          <target state="translated">Octave는 객체 지향 인터페이스를 통해 FTP 프로토콜을 지원합니다. &lt;code&gt;ftp&lt;/code&gt; 함수를 사용하여 연결을 나타내는 FTP 오브젝트를 작성 하십시오 . 모든 FTP 함수는 FTP 객체를 첫 번째 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cac581385965f6291a31d66307a3f5b7118e26d5" translate="yes" xml:space="preserve">
          <source>Octave supports three means to stop execution based on the values set in the functions &lt;code&gt;debug_on_interrupt&lt;/code&gt;, &lt;code&gt;debug_on_warning&lt;/code&gt;, and &lt;code&gt;debug_on_error&lt;/code&gt;.</source>
          <target state="translated">Octave는 &lt;code&gt;debug_on_interrupt&lt;/code&gt; , &lt;code&gt;debug_on_warning&lt;/code&gt; 및 &lt;code&gt;debug_on_error&lt;/code&gt; 함수에 설정된 값을 기반으로 실행을 중지하는 세 가지 수단을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="d25c1f5a8f2d6ecf0769bc27644f45a49cb405fd" translate="yes" xml:space="preserve">
          <source>Octave supports various helpful statistical functions. Many are useful as initial steps to prepare a data set for further analysis. Others provide different measures from those of the basic descriptive statistics.</source>
          <target state="translated">옥타브는 다양한 유용한 통계 기능을 지원합니다. 추가 분석을 위해 데이터 세트를 준비하는 초기 단계로 유용합니다. 다른 것들은 기본 기술 통계와 다른 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6a02bf7ebed745360a01f35a921d2942ca8e5ea3" translate="yes" xml:space="preserve">
          <source>Octave supports various kinds of conversions between strings and numbers. As an example, it is possible to convert a string containing a hexadecimal number to a floating point number.</source>
          <target state="translated">옥타브는 문자열과 숫자 사이의 다양한 변환을 지원합니다. 예를 들어, 16 진수를 포함하는 문자열을 부동 소수점 숫자로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8123c6ac04bccf9ca73cafd68e2d34bf03c33efc" translate="yes" xml:space="preserve">
          <source>Octave uses standard mathematical notation with the advantage over low-level languages that operators may act on scalars, vector, matrices, or N-dimensional arrays. For example, to multiply the matrix &lt;code&gt;A&lt;/code&gt; by a scalar value, type the command</source>
          <target state="translated">옥타브는 표준 수학 표기법을 사용하여 연산자가 스칼라, 벡터, 행렬 또는 N 차원 배열에서 작동 할 수있는 저수준 언어에 비해 유리합니다. 예를 들어 행렬 &lt;code&gt;A&lt;/code&gt; 에 스칼라 값 을 곱하려면 다음 명령을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="7f9e4d86d8ccfe15f26bd2d4eda5c6498b8a92bb" translate="yes" xml:space="preserve">
          <source>Octave uses the &lt;small&gt;FFTW&lt;/small&gt; libraries to perform FFT computations. When Octave starts up and initializes the &lt;small&gt;FFTW&lt;/small&gt; libraries, they read a system wide file (on a Unix system, it is typically</source>
          <target state="translated">Octave는 &lt;small&gt;FFTW&lt;/small&gt; 라이브러리를 사용하여 FFT 계산을 수행합니다. Octave가 시작되고 &lt;small&gt;FFTW&lt;/small&gt; 라이브러리를 초기화 할 때 시스템 전체 파일을 읽습니다 (Unix 시스템에서는 일반적으로</target>
        </trans-unit>
        <trans-unit id="dfa7bd84c40b62d16aebe6bf9fe40428dba2472f" translate="yes" xml:space="preserve">
          <source>Octave uses the C library trigonometric functions. It is expected that these functions are defined by the ISO/IEC 9899 Standard. This Standard is available at: &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf&quot;&gt;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf&lt;/a&gt;. Section F.9.1 deals with the trigonometric functions. The behavior of most of the functions is relatively straightforward. However, there are some exceptions to the standard behavior. Many of the exceptions involve the behavior for -0. The most complex case is atan2. Octave exactly implements the behavior given in the Standard. Including &lt;code&gt;atan2(+- 0, 0)&lt;/code&gt; returns &lt;code&gt;+- pi&lt;/code&gt;.</source>
          <target state="translated">옥타브는 C 라이브러리 삼각 함수를 사용합니다. 이러한 기능은 ISO / IEC 9899 표준에 의해 정의 될 것으로 예상됩니다. 이 표준은 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf&quot;&gt;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf&lt;/a&gt; 에서 사용할 수 있습니다 . F.9.1 절은 삼각 함수를 다룹니다. 대부분의 기능의 동작은 비교적 간단합니다. 그러나 표준 동작에는 몇 가지 예외가 있습니다. 많은 예외는 -0의 동작과 관련이 있습니다. 가장 복잡한 경우는 atan2입니다. 옥타브는 표준에 주어진 동작을 정확하게 구현합니다. &lt;code&gt;atan2(+- 0, 0)&lt;/code&gt; 포함하면 &lt;code&gt;+- pi&lt;/code&gt; 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="c0d2c88344db37c68bc5520901bf4e60c119ace8" translate="yes" xml:space="preserve">
          <source>Octave uses the GNU Readline library for command-line editing and history features. Readline is very flexible and can be modified through a configuration file of commands (See the GNU Readline library for the exact command syntax). The default configuration file is normally</source>
          <target state="translated">Octave는 명령 행 편집 및 히스토리 기능을 위해 GNU Readline 라이브러리를 사용합니다. Readline은 매우 유연하며 명령 구성 파일을 통해 수정할 수 있습니다 (정확한 명령 구문은 GNU Readline 라이브러리를 참조하십시오). 기본 구성 파일은 일반적으로</target>
        </trans-unit>
        <trans-unit id="8be244500df5dba9bc2f5802de6526b7c492acba" translate="yes" xml:space="preserve">
          <source>Octave uses the GNU Readline library to provide an extensive set of command-line editing and history features. Only the most common features are described in this manual. In addition, all of the editing functions can be bound to different key strokes at the user&amp;rsquo;s discretion. This manual assumes no changes from the default Emacs bindings. See the GNU Readline Library manual for more information on customizing Readline and for a complete feature list.</source>
          <target state="translated">Octave는 GNU Readline 라이브러리를 사용하여 광범위한 명령 행 편집 및 히스토리 기능을 제공합니다. 이 설명서에는 가장 일반적인 기능 만 설명되어 있습니다. 또한 모든 편집 기능은 사용자의 판단에 따라 다른 키 스트로크에 바인딩 될 수 있습니다. 이 매뉴얼은 기본 Emacs 바인딩에서 변경된 사항이 없다고 가정합니다. Readline 사용자 정의 및 전체 기능 목록에 대한 자세한 내용은 GNU Readline Library 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="098119fe1235a13cd6360eca3af507186b5c79fa" translate="yes" xml:space="preserve">
          <source>Octave waits for the external command to finish before returning the exit status of the program in &lt;var&gt;status&lt;/var&gt; and any output in &lt;var&gt;text&lt;/var&gt;.</source>
          <target state="translated">에서 프로그램의 종료 상태 반환하기 전에 마무리에 외부 명령에 대한 옥타브 대기 &lt;var&gt;status&lt;/var&gt; 와의 모든 출력 &lt;var&gt;text&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="6aad76a9c14e6cca222c85ffa499ca801052b32a" translate="yes" xml:space="preserve">
          <source>Octave will automatically create a separate window to display the plot.</source>
          <target state="translated">옥타브는 자동으로 별도의 창을 만들어 플롯을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="80db0c4525873e91e22f0969190e4d5af7c08814" translate="yes" xml:space="preserve">
          <source>Octave will call &lt;var&gt;fcn&lt;/var&gt; with the name of the function that requires the component and a string describing the missing component. The hook function should return an error message to be displayed.</source>
          <target state="translated">옥타브는 컴포넌트가 필요한 함수 이름과 누락 된 컴포넌트를 설명하는 문자열로 &lt;var&gt;fcn&lt;/var&gt; 을 호출 합니다. 후크 기능은 오류 메시지를 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="a3b4fd971a882c17d17cee0744109c0839d7e9d1" translate="yes" xml:space="preserve">
          <source>Octave will expect additional input to complete the first &lt;code&gt;if&lt;/code&gt; statement. If you are using Octave interactively, it will continue to prompt you for additional input. If Octave is reading this input from a file, it may complain about missing or mismatched &lt;code&gt;end&lt;/code&gt; statements, or, if you have not used the more specific &lt;code&gt;end&lt;/code&gt; statements (&lt;code&gt;endif&lt;/code&gt;, &lt;code&gt;endfor&lt;/code&gt;, etc.), it may simply produce incorrect results, without producing any warning messages.</source>
          <target state="translated">옥타브는 추가 입력이 첫 번째 &lt;code&gt;if&lt;/code&gt; 문 을 완료 할 것으로 예상 합니다. Octave를 대화식으로 사용하는 경우 추가 입력을 요구하는 메시지가 계속 나타납니다. Octave가 파일에서이 입력을 읽는 경우 누락되거나 일치하지 않는 &lt;code&gt;end&lt;/code&gt; 문 에 대해 불평하거나 보다 구체적인 &lt;code&gt;end&lt;/code&gt; 문을 사용하지 않은 경우 ( &lt;code&gt;endif&lt;/code&gt; , &lt;code&gt;endfor&lt;/code&gt; 등)을 , 생성하지 않고 단순히 잘못된 결과를 생성 할 수 있습니다. 모든 경고 메시지.</target>
        </trans-unit>
        <trans-unit id="7d22bec9a8bf5312ed5998b0709395eb3554c043" translate="yes" xml:space="preserve">
          <source>Octave will respond by printing the matrix in neatly aligned columns. Octave uses a comma or space to separate entries in a row, and a semicolon or carriage return to separate one row from the next. Ending a command with a semicolon tells Octave not to print the result of the command. For example,</source>
          <target state="translated">옥타브는 행렬을 깔끔하게 정렬 된 열로 인쇄하여 응답합니다. 옥타브는 쉼표 또는 공백을 사용하여 행에서 항목을 구분하고 세미콜론 또는 캐리지 리턴을 사용하여 한 행을 다음 행과 구분합니다. 세미콜론으로 명령을 종료하면 명령 결과를 인쇄하지 않도록 Octave에 지시합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="c58771d0f26c94d3e2533fabf9a61a5cb45c50bc" translate="yes" xml:space="preserve">
          <source>Octave will respond immediately with a message like this:</source>
          <target state="translated">Octave는 다음과 같은 메시지로 즉시 응답합니다.</target>
        </trans-unit>
        <trans-unit id="67e516e83fb117dc24ad3955c16e2bf3cde992fd" translate="yes" xml:space="preserve">
          <source>Octave will respond with</source>
          <target state="translated">옥타브는</target>
        </trans-unit>
        <trans-unit id="c29002aa9f9b9423b58e880a4d21cf408b0ceea4" translate="yes" xml:space="preserve">
          <source>Octave&amp;rsquo;s 64-bit index support is activated with the configure option</source>
          <target state="translated">구성 옵션을 사용하여 Octave의 64 비트 인덱스 지원이 활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="a6fca4813022b29fb947a8b698273c42e035510e" translate="yes" xml:space="preserve">
          <source>Octave&amp;rsquo;s &lt;code&gt;do-until&lt;/code&gt; statement looks like this:</source>
          <target state="translated">옥타브의 &lt;code&gt;do-until&lt;/code&gt; 문은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="8a13ab72b1ae6927505b680cba4e5365aaef7e67" translate="yes" xml:space="preserve">
          <source>Octave&amp;rsquo;s &lt;code&gt;strftime&lt;/code&gt; function supports a superset of the ANSI C field specifiers.</source>
          <target state="translated">Octave의 &lt;code&gt;strftime&lt;/code&gt; 함수는 ANSI C 필드 지정자의 수퍼 셋을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3baeced29bbc45e297033f1fd5f2f024fe6a4d10" translate="yes" xml:space="preserve">
          <source>Octave&amp;rsquo;s &lt;code&gt;while&lt;/code&gt; statement looks like this:</source>
          <target state="translated">옥타브의 &lt;code&gt;while&lt;/code&gt; 문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5925c14e96500b036d09abf936927b72969c5018" translate="yes" xml:space="preserve">
          <source>Octave&amp;rsquo;s C-style input and output functions provide most of the functionality of the C programming language&amp;rsquo;s standard I/O library. The argument lists for some of the input functions are slightly different, however, because Octave has no way of passing arguments by reference.</source>
          <target state="translated">Octave의 C 스타일 입력 및 출력 기능은 C 프로그래밍 언어 표준 I / O 라이브러리의 기능을 대부분 제공합니다. 그러나 Octave에는 참조로 인수를 전달할 방법이 없으므로 일부 입력 함수에 대한 인수 목록이 약간 다릅니다.</target>
        </trans-unit>
        <trans-unit id="afa71bad1e028dbe6c884ca2688f0fd57402ea60" translate="yes" xml:space="preserve">
          <source>Octave&amp;rsquo;s built-in numeric objects include real, complex, and integer scalars and matrices. All built-in floating point numeric data is currently stored as double precision numbers. On systems that use the IEEE floating point format, values in the range of approximately 2.2251e-308 to 1.7977e+308 can be stored, and the relative precision is approximately 2.2204e-16. The exact values are given by the variables &lt;code&gt;realmin&lt;/code&gt;, &lt;code&gt;realmax&lt;/code&gt;, and &lt;code&gt;eps&lt;/code&gt;, respectively.</source>
          <target state="translated">옥타브의 내장 숫자 객체에는 실수, 복소수 및 정수 스칼라와 행렬이 포함됩니다. 모든 내장 부동 소수점 숫자 데이터는 현재 배정도 숫자로 저장됩니다. IEEE 부동 소수점 형식을 사용하는 시스템에서 약 2.2251e-308 ~ 1.7977e + 308 범위의 값을 저장할 수 있으며 상대 정밀도는 약 2.2204e-16입니다. 정확한 값은 변수 &lt;code&gt;realmin&lt;/code&gt; , &lt;code&gt;realmax&lt;/code&gt; 및 &lt;code&gt;eps&lt;/code&gt; 로 제공됩니다. 로 각각 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="148ceac42e95895f5a8c68e4ae0aaec870f2bd73" translate="yes" xml:space="preserve">
          <source>Octave&amp;rsquo;s cell type is also available from within oct-files. A cell array is just an &lt;code&gt;Array&lt;/code&gt; of &lt;code&gt;octave_value&lt;/code&gt;s, and thus each element of the cell array can be treated like any other &lt;code&gt;octave_value&lt;/code&gt;. A simple example is</source>
          <target state="translated">Octave의 셀 유형은 oct 파일 내에서도 사용할 수 있습니다. 세포 배열 단지 인 &lt;code&gt;Array&lt;/code&gt; 의 &lt;code&gt;octave_value&lt;/code&gt; S, 따라서 셀 어레이의 각 요소는 다른 것처럼 처리 될 수 &lt;code&gt;octave_value&lt;/code&gt; . 간단한 예는</target>
        </trans-unit>
        <trans-unit id="c212080d92131d4ed00bdb2fc5f05ed4e9d6ee00" translate="yes" xml:space="preserve">
          <source>Octave&amp;rsquo;s core set of functions for manipulating time values are patterned after the corresponding functions from the standard C library. Several of these functions use a data structure for time that includes the following elements:</source>
          <target state="translated">시간 값 조작을위한 Octave의 핵심 기능 세트는 표준 C 라이브러리의 해당 기능에 따라 패턴 화됩니다. 이러한 기능 중 일부는 다음 요소를 포함하는 시간 동안 데이터 구조를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f3c4606d39f335774a550e36b9e2430ceab8470c" translate="yes" xml:space="preserve">
          <source>Octave&amp;rsquo;s data structure type can help you to organize related objects of different types. The current implementation uses an associative array with indices limited to strings, but the syntax is more like C-style structures.</source>
          <target state="translated">Octave의 데이터 구조 유형을 사용하면 다양한 유형의 관련 객체를 구성 할 수 있습니다. 현재 구현에서는 인덱스가 문자열로 제한된 연관 배열을 사용하지만 구문은 C 스타일 구조와 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="2194a74b13a6c18595f3353f7a9d1a30ebb46e7d" translate="yes" xml:space="preserve">
          <source>Octave&amp;rsquo;s diary feature allows you to keep a log of all or part of an interactive session by recording the input you type and the output that Octave produces in a separate file.</source>
          <target state="translated">Octave의 다이어리 기능을 사용하면 입력 한 입력과 Octave가 생성 한 출력을 별도의 파일에 기록하여 대화식 세션의 일부 또는 전부를 기록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28f7ded71adc94a9a9c50bc941043181b6951088" translate="yes" xml:space="preserve">
          <source>Octave&amp;rsquo;s group database functions return information in a structure with the following fields.</source>
          <target state="translated">Octave의 그룹 데이터베이스 함수는 다음 필드가있는 구조로 정보를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8c01bba7f1dc965636411af2be2a8e48c0bad732" translate="yes" xml:space="preserve">
          <source>Octave&amp;rsquo;s password database functions return information in a structure with the following fields.</source>
          <target state="translated">옥타브의 비밀번호 데이터베이스 기능은 다음 필드가있는 구조로 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4efe86d6e23a737da69f978ee7e15e9b92e74d8f" translate="yes" xml:space="preserve">
          <source>Octave&amp;rsquo;s path prior to changes by any octaverc file.</source>
          <target state="translated">옥타 버크 파일에 의한 변경 이전의 옥타브 경로</target>
        </trans-unit>
        <trans-unit id="35322c978b543d1086f612d86148e5f88b2e8586" translate="yes" xml:space="preserve">
          <source>Octave&amp;rsquo;s system-wide startup file.</source>
          <target state="translated">옥타브의 시스템 전체 시작 파일.</target>
        </trans-unit>
        <trans-unit id="e28a20bde270cc86b03a1ff2fd469b82dafbf1e8" translate="yes" xml:space="preserve">
          <source>Octave&amp;rsquo;s ubiquitous lazily-copied pass-by-value semantics implies a problem for performance of user-defined &lt;code&gt;subsasgn&lt;/code&gt; methods. Imagine the following call to &lt;code&gt;subsasgn&lt;/code&gt;</source>
          <target state="translated">옥타브의 유비쿼터스 지연 복사 된 &lt;code&gt;subsasgn&lt;/code&gt; 의미론은 사용자 정의 subsasgn 방법의 성능에 문제가 있음을 의미 합니다. &lt;code&gt;subsasgn&lt;/code&gt; 에 대한 다음 호출을 상상해보십시오</target>
        </trans-unit>
        <trans-unit id="b363f8705a46584721b007c4b79d144146877c35" translate="yes" xml:space="preserve">
          <source>Of course, if the bug is that the interpreter gets a fatal signal, then one can&amp;rsquo;t miss it. But if the bug is incorrect output, we might not notice unless it is glaringly wrong.</source>
          <target state="translated">물론 인터프리터가 치명적인 신호를 받는다는 것이 버그라면 놓칠 수 없습니다. 그러나 버그가 잘못된 출력이면 눈에 띄지 않는 한 눈에 띄지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff9f34d402fb2c777d8a837e5ebeecf133bd07e1" translate="yes" xml:space="preserve">
          <source>Of course, it is not always possible to know the number of nonzero elements prior to filling a matrix. For this reason the additional unused storage of a sparse matrix can be removed after its creation with the &lt;code&gt;maybe_compress&lt;/code&gt; function. In addition to deallocating unused storage, &lt;code&gt;maybe_compress&lt;/code&gt; can also remove zero elements from the matrix. The removal of zero elements from the matrix is controlled by setting the argument of the &lt;code&gt;maybe_compress&lt;/code&gt; function to be &lt;code&gt;true&lt;/code&gt;. However, the cost of removing the zeros is high because it implies re-sorting the elements. If possible, it is better for the user to avoid adding the unnecessary zeros in the first place. An example of the use of &lt;code&gt;maybe_compress&lt;/code&gt; is</source>
          <target state="translated">물론, 매트릭스를 채우기 전에 항상 0이 아닌 요소의 수를 아는 것이 가능하지는 않습니다. 이러한 이유로 &lt;code&gt;maybe_compress&lt;/code&gt; 함수를 사용하여 희소 행렬의 추가 미사용 스토리지를 제거한 후 제거 할 수 있습니다 . &lt;code&gt;maybe_compress&lt;/code&gt; 는 사용되지 않는 스토리지 할당을 해제하는 것 외에도 매트릭스에서 제로 요소를 제거 할 수 있습니다. 매트릭스에서 제로 요소의 제거는 &lt;code&gt;maybe_compress&lt;/code&gt; 함수 의 인수를 &lt;code&gt;true&lt;/code&gt; 로 설정하여 제어됩니다 . 그러나 0을 제거하는 비용은 요소를 다시 정렬하는 것을 의미하기 때문에 높습니다. 가능하면 사용자가 불필요한 제로를 추가하지 않는 것이 좋습니다. 사용의 예 &lt;code&gt;maybe_compress&lt;/code&gt; 은 이다</target>
        </trans-unit>
        <trans-unit id="7b736905d1424538b57b87b5ff920aa3bf947b95" translate="yes" xml:space="preserve">
          <source>Offset from UTC (&amp;plusmn;hhmm), or nothing if no time zone is determinable.</source>
          <target state="translated">UTC로부터 오프셋 (&amp;plusmn; hhmm) 또는 시간대를 결정할 수없는 경우 아무것도 없습니다.</target>
        </trans-unit>
        <trans-unit id="eb311ad3789b6d54187c5576755a1b07d395b7e5" translate="yes" xml:space="preserve">
          <source>Often it is useful to find the minimum value of a function rather than just the zeroes where it crosses the x-axis. &lt;code&gt;fminbnd&lt;/code&gt; is designed for the simpler, but very common, case of a univariate function where the interval to search is bounded. For unbounded minimization of a function with potentially many variables use &lt;code&gt;fminunc&lt;/code&gt; or &lt;code&gt;fminsearch&lt;/code&gt;. The two functions use different internal algorithms and some knowledge of the objective function is required. For functions which can be differentiated, &lt;code&gt;fminunc&lt;/code&gt; is appropriate. For functions with discontinuities, or for which a gradient search would fail, use &lt;code&gt;fminsearch&lt;/code&gt;. See &lt;a href=&quot;optimization#Optimization&quot;&gt;Optimization&lt;/a&gt;, for minimization with the presence of constraint functions. Note that searches can be made for maxima by simply inverting the objective function (&lt;code&gt;Fto_max = -Fto_min&lt;/code&gt;).</source>
          <target state="translated">종종 x 축을 교차하는 0이 아닌 함수의 최소값을 찾는 것이 유용합니다. &lt;code&gt;fminbnd&lt;/code&gt; 는 검색 간격이 제한되어있는 일 변량 함수의 단순하지만 매우 일반적인 경우를 위해 설계되었습니다. 잠재적으로 많은 변수가있는 함수를 제한없이 최소화하려면 &lt;code&gt;fminunc&lt;/code&gt; 또는 &lt;code&gt;fminsearch&lt;/code&gt; 를 사용 하십시오 . 두 함수는 서로 다른 내부 알고리즘을 사용하며 목적 함수에 대한 지식이 필요합니다. 차별화 할 수있는 기능의 경우 &lt;code&gt;fminunc&lt;/code&gt; 가 적합합니다. 불연속 &lt;code&gt;fminsearch&lt;/code&gt; 거나 그라디언트 검색이 실패하는 함수의 경우 fminsearch를 사용 하십시오 . 보다&lt;a href=&quot;optimization#Optimization&quot;&gt;최적화&lt;/a&gt;구속 조건 기능이있는 최소화를 위해. 목적 함수 ( &lt;code&gt;Fto_max = -Fto_min&lt;/code&gt; ) 를 반전시켜 최대 값을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c654507ffc44ab281840ff9b19bd7c0bade7d999" translate="yes" xml:space="preserve">
          <source>Often people omit facts because they think they know what causes the problem and they conclude that some details don&amp;rsquo;t matter. Thus, you might assume that the name of the variable you use in an example does not matter. Well, probably it doesn&amp;rsquo;t, but one cannot be sure. Perhaps the bug is a stray memory reference which happens to fetch from the location where that name is stored in memory; perhaps, if the name were different, the contents of that location would fool the interpreter into doing the right thing despite the bug. Play it safe and give a specific, complete example.</source>
          <target state="translated">사람들은 문제의 원인을 알고 있다고 생각하기 때문에 사실을 생략하고 일부 세부 사항은 중요하지 않다는 결론을 내립니다. 따라서 예제에서 사용하는 변수 이름이 중요하지 않다고 가정 할 수 있습니다. 아마 그렇지 않을 수도 있지만 확신 할 수는 없습니다. 아마도 버그는 이름이 메모리에 저장된 위치에서 가져 오는 길잃은 메모리 참조 일 것입니다. 아마도 이름이 다르면 해당 위치의 내용이 버그에도 불구하고 해석자가 올바른 일을하도록 속일 것입니다. 안전하게 플레이하고 구체적이고 완전한 예를 제시하십시오.</target>
        </trans-unit>
        <trans-unit id="d168c9755b75a77ddf79de49c70a8e37ffdb0841" translate="yes" xml:space="preserve">
          <source>Often people who encounter a bug spend a lot of time investigating which changes to the input file will make the bug go away and which changes will not affect it. Such information is usually not necessary to enable us to fix bugs in Octave, but if you can find a simpler example to report &lt;em&gt;instead&lt;/em&gt; of the original one, that is a convenience. Errors in the output will be easier to spot, running under the debugger will take less time, etc. Most Octave bugs involve just one function, so the most straightforward way to simplify an example is to delete all the function definitions except the one in which the bug occurs.</source>
          <target state="translated">버그가 발생하는 사람들은 종종 입력 파일을 변경하면 버그가 사라지고 어떤 변경이 버그에 영향을 미치지 않는지 조사하는 데 많은 시간을 소비합니다. 이러한 정보는 일반적으로 Octave에서 버그를 수정하는 데 필요하지 않지만 원래 예제 &lt;em&gt;대신&lt;/em&gt; 보고하는 더 간단한 예제를 찾을 수 있다면 편리합니다. 대부분의 Octave 버그에는 하나의 함수 만 포함되므로 결과를 단순화하는 가장 간단한 방법은 예를 단순화하는 가장 간단한 방법은 모든 함수 정의를 삭제하는 것입니다. 버그가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="acc371207039287d6cf7d5d628e0c1ae99220148" translate="yes" xml:space="preserve">
          <source>Often the observed symptom is incorrect output when your program is run. Unfortunately, this is not enough information unless the program is short and simple. It is very helpful if you can include an explanation of the expected output, and why the actual output is incorrect.</source>
          <target state="translated">프로그램이 실행될 때 관찰 된 증상이 잘못된 출력 인 경우가 종종 있습니다. 불행히도 프로그램이 짧고 단순하지 않으면 정보가 충분하지 않습니다. 예상 출력에 대한 설명과 실제 출력이 잘못된 이유를 설명 할 수 있으면 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a73110f8381ef0ce6d02d65680e7183ceefa040d" translate="yes" xml:space="preserve">
          <source>Older versions of Octave used a different random number generator. The new generator is used by default as it is significantly faster than the old generator, and produces random numbers with a significantly longer cycle time. However, in some circumstances it might be desirable to obtain the same random sequences as produced by the old generators. To do this the keyword &lt;code&gt;&quot;seed&quot;&lt;/code&gt; is used to specify that the old generators should be used, as in</source>
          <target state="translated">이전 버전의 Octave는 다른 난수 생성기를 사용했습니다. 새 생성기는 기본적으로 이전 생성기보다 훨씬 빠르기 때문에 기본적으로 사용되며주기 시간이 훨씬 긴 난수를 생성합니다. 그러나, 어떤 상황에서는 구형 발전기에 의해 생성 된 것과 동일한 랜덤 시퀀스를 얻는 것이 바람직 할 수 있습니다. 이렇게하려면 키워드 &lt;code&gt;&quot;seed&quot;&lt;/code&gt; 를 사용하여 이전 생성기를 사용해야 함을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6efc6f4f94c6eb32f2076913073fc7d61f1a5c40" translate="yes" xml:space="preserve">
          <source>On 64-bit systems, Octave uses 64-bit integers for indexing arrays by default. If the configure script determines that your &lt;small&gt;BLAS&lt;/small&gt; library uses 32-bit integers, then operations using the following libraries are limited to arrays with dimensions that are smaller than &lt;em&gt;2^{31}&lt;/em&gt; elements:</source>
          <target state="translated">64 비트 시스템에서 Octave는 기본적으로 배열 색인을 위해 64 비트 정수를 사용합니다. configure 스크립트가 &lt;small&gt;BLAS&lt;/small&gt; 라이브러리가 32 비트 정수를 사용 한다고 판별 하면 다음 라이브러리를 사용하는 조작은 &lt;em&gt;2 ^ {31}&lt;/em&gt; 요소 보다 작은 차원을 가진 배열로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="c270d77dc8d4758dde671c1f5006dbe565eb6007" translate="yes" xml:space="preserve">
          <source>On FreeBSD systems Octave may hang while initializing some internal constants. The fix appears to be to use</source>
          <target state="translated">FreeBSD 시스템에서 Octave는 일부 내부 상수를 초기화하는 동안 정지 될 수 있습니다. 수정은 사용하는 것으로 보입니다</target>
        </trans-unit>
        <trans-unit id="79fb3a2269180dfd25bd318965dcbd28e1fe2a22" translate="yes" xml:space="preserve">
          <source>On NeXT systems, if you get errors like this:</source>
          <target state="translated">NeXT 시스템에서 다음과 같은 오류가 발생하는 경우 :</target>
        </trans-unit>
        <trans-unit id="6d130be75348633d275d33e7772009456a98560a" translate="yes" xml:space="preserve">
          <source>On NeXT systems, linking to</source>
          <target state="translated">NeXT 시스템에서</target>
        </trans-unit>
        <trans-unit id="5621332b5527b9ea2c74af286a0125d9a528e299" translate="yes" xml:space="preserve">
          <source>On UNIX-like systems it is possible to make both per-user and system-wide installations of a package. If the user performing the installation is &lt;code&gt;root&lt;/code&gt; the packages will be installed in a system-wide directory that defaults to</source>
          <target state="translated">UNIX 계열 시스템에서는 사용자 별 및 시스템 전체의 패키지 설치가 가능합니다. 설치를 수행하는 사용자가 &lt;code&gt;root&lt;/code&gt; 경우 패키지는 기본적으로 시스템 전체 디렉토리에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="8fb1f22e52b2f474004b4bd34e62211a2b9441e2" translate="yes" xml:space="preserve">
          <source>On Windows platforms, Octave uses software rendering for the OpenGL graphics toolkits (&lt;code&gt;&quot;qt&quot;&lt;/code&gt; and &lt;code&gt;&quot;fltk&quot;&lt;/code&gt;) by default. This is done to avoid rendering and printing issues due to imperfect OpenGL driver implementations for diverse graphic cards from different vendors. As a down-side, software rendering might be considerably slower than hardware accelerated rendering. To permanently switch back to hardware accelerated rendering with your graphic card drivers, rename the following file while Octave is closed:</source>
          <target state="translated">Windows 플랫폼에서 Octave는 기본적으로 OpenGL 그래픽 툴킷 ( &lt;code&gt;&quot;qt&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;fltk&quot;&lt;/code&gt; )에 대한 소프트웨어 렌더링을 사용합니다 . 이는 여러 공급 업체의 다양한 그래픽 카드에 대한 불완전한 OpenGL 드라이버 구현으로 인한 렌더링 및 인쇄 문제를 방지하기 위해 수행됩니다. 단점으로, 소프트웨어 렌더링은 하드웨어 가속 렌더링보다 상당히 느릴 수 있습니다. 그래픽 카드 드라이버를 사용하여 하드웨어 가속 렌더링으로 영구적으로 다시 전환하려면 Octave를 닫은 상태에서 다음 파일의 이름을 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="5412596609b575f326d82b89cbdd1db02e1dc200" translate="yes" xml:space="preserve">
          <source>On Windows systems, while forward slash file separators do work, they are replaced by backslashes; in addition drive letters are stripped of leading file separators to obtain a valid file path.</source>
          <target state="translated">Windows 시스템에서는 슬래시 파일 구분 기호가 작동하지만 백 슬래시로 대체됩니다. 또한 드라이브 문자에는 유효한 파일 경로를 얻기 위해 선행 파일 구분 기호가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="a65fca6e325832ab1be88028eb26010f4bf6ffbc" translate="yes" xml:space="preserve">
          <source>On Windows, return the value of the registry key &lt;var&gt;subkey&lt;/var&gt; from the root key &lt;var&gt;rootkey&lt;/var&gt;. You can specify the name of the queried registry value with the optional argument &lt;var&gt;valuename&lt;/var&gt;. Otherwise, if called with only two arguments or &lt;var&gt;valuename&lt;/var&gt; is empty, then the default value of &lt;var&gt;subkey&lt;/var&gt; is returned. If the registry value is of type &lt;code&gt;&quot;REG_DWORD&quot;&lt;/code&gt; then &lt;var&gt;value&lt;/var&gt; is of class int32. If the value is of the type &lt;code&gt;&quot;REG_SZ&quot;&lt;/code&gt; or &lt;code&gt;&quot;REG_EXPAND_SZ&quot;&lt;/code&gt; a string is returned.</source>
          <target state="translated">Windows의 경우 루트 키 &lt;var&gt;rootkey&lt;/var&gt; 에서 레지스트리 키 &lt;var&gt;subkey&lt;/var&gt; 키 값을 리턴하십시오 . 선택적 인수 &lt;var&gt;valuename&lt;/var&gt; 을 사용하여 조회 된 레지스트리 값의 이름을 지정할 수 있습니다 . 그렇지 않으면 두 개의 인수만으로 호출하거나 &lt;var&gt;valuename&lt;/var&gt; 이 비어 있으면 &lt;var&gt;subkey&lt;/var&gt; 의 기본값 이 반환됩니다. 레지스트리 값이 &lt;code&gt;&quot;REG_DWORD&quot;&lt;/code&gt; 유형 인 경우 &lt;var&gt;value&lt;/var&gt; 은 int32 클래스입니다. 값이 &lt;code&gt;&quot;REG_SZ&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;REG_EXPAND_SZ&quot;&lt;/code&gt; 유형 이면 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="aaa94d01a1f7879bb46d786a18eaf5e78923f878" translate="yes" xml:space="preserve">
          <source>On exit, &lt;var&gt;y&lt;/var&gt; is a unit vector such that:</source>
          <target state="translated">종료시 &lt;var&gt;y&lt;/var&gt; 는 다음과 같은 단위 벡터입니다.</target>
        </trans-unit>
        <trans-unit id="d64ce774742d252dd10b1d855a7061306cc0eaac" translate="yes" xml:space="preserve">
          <source>On exit, the function returns &lt;var&gt;x&lt;/var&gt;, the approximate minimum point, and &lt;var&gt;fval&lt;/var&gt;, the function evaluated &lt;var&gt;x&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;fval&lt;/var&gt; , 함수 는 근사 최소 점 인 &lt;var&gt;x&lt;/var&gt; , &lt;var&gt;x&lt;/var&gt; 로 평가 된 함수 fval을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c0d8b6f7acd7bc16597dd4c46d60facb0ae9db87" translate="yes" xml:space="preserve">
          <source>On exit, the function returns &lt;var&gt;x&lt;/var&gt;, the approximate zero point, and &lt;var&gt;fval&lt;/var&gt;, the function evaluated at &lt;var&gt;x&lt;/var&gt;.</source>
          <target state="translated">출구에서 함수가 반환은 &lt;var&gt;x&lt;/var&gt; , 대략 영점 및 &lt;var&gt;fval&lt;/var&gt; 에서 평가 기능 &lt;var&gt;x&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="4bae3301f8bf9a8b8e99e45c0ce8c0f9258d231a" translate="yes" xml:space="preserve">
          <source>On exit, the function returns &lt;var&gt;x&lt;/var&gt;, the minimum point, and &lt;var&gt;fval&lt;/var&gt;, the function value at the minimum.</source>
          <target state="translated">&lt;var&gt;fval&lt;/var&gt; 함수는 최소값 &lt;var&gt;x&lt;/var&gt; , 함수 값 최소값 fval을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="244beb5a171a0831569412566a2af631ca2a2e40" translate="yes" xml:space="preserve">
          <source>On most systems, Octave is started with the shell command &amp;lsquo;</source>
          <target state="translated">대부분의 시스템에서 Octave는 쉘 명령 '</target>
        </trans-unit>
        <trans-unit id="c9993e70428bf93953df568efd7ff830a2e69578" translate="yes" xml:space="preserve">
          <source>On most systems, this is equivalent to &lt;code&gt;getenv (&quot;HOME&quot;)&lt;/code&gt;. On Windows systems, if the environment variable &lt;code&gt;HOME&lt;/code&gt; is not set then it is equivalent to &lt;code&gt;fullfile (getenv (&quot;HOMEDRIVE&quot;), getenv (&quot;HOMEPATH&quot;))&lt;/code&gt;</source>
          <target state="translated">대부분의 시스템에서 이는 &lt;code&gt;getenv (&quot;HOME&quot;)&lt;/code&gt; . Windows 시스템에서 환경 변수 &lt;code&gt;HOME&lt;/code&gt; 이 설정되지 않은 경우 전체 파일 &lt;code&gt;fullfile (getenv (&quot;HOMEDRIVE&quot;), getenv (&quot;HOMEPATH&quot;))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af9580cc68007dbafa727ff1f5b6143a3b2ef6da" translate="yes" xml:space="preserve">
          <source>On most terminals, you can also use the up and down arrow keys in place of</source>
          <target state="translated">대부분의 터미널에서는 위 / 아래 화살표 키를 대신 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="448e25ee06d3e6134b6d8a97a45804aa908d0a0b" translate="yes" xml:space="preserve">
          <source>On non-Windows platforms this function fails with an error.</source>
          <target state="translated">Windows 이외의 플랫폼에서이 기능은 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a7b96faf41513dd9b40acd021758d6ca2be5f023" translate="yes" xml:space="preserve">
          <source>On output, &lt;var&gt;nest&lt;/var&gt; is the desired estimate, &lt;var&gt;v&lt;/var&gt; and &lt;var&gt;w&lt;/var&gt; are vectors such that &lt;code&gt;&lt;var&gt;w&lt;/var&gt; = &lt;var&gt;A&lt;/var&gt; * &lt;var&gt;v&lt;/var&gt;&lt;/code&gt;, with &lt;code&gt;norm (&lt;var&gt;w&lt;/var&gt;, 1)&lt;/code&gt; = &lt;code&gt;&lt;var&gt;c&lt;/var&gt; * norm (&lt;var&gt;v&lt;/var&gt;, 1)&lt;/code&gt;. &lt;var&gt;iter&lt;/var&gt; contains in &lt;code&gt;&lt;var&gt;iter&lt;/var&gt;(1)&lt;/code&gt; the number of iterations (the maximum is hardcoded to 5) and in &lt;code&gt;&lt;var&gt;iter&lt;/var&gt;(2)&lt;/code&gt; the total number of products &lt;code&gt;&lt;var&gt;A&lt;/var&gt; * &lt;var&gt;x&lt;/var&gt;&lt;/code&gt; or &lt;code&gt;&lt;var&gt;A&lt;/var&gt;' * &lt;var&gt;x&lt;/var&gt;&lt;/code&gt; performed by the algorithm.</source>
          <target state="translated">출력에서 &lt;var&gt;nest&lt;/var&gt; 원하는 추정치이며, &lt;var&gt;v&lt;/var&gt; 및 &lt;var&gt;w&lt;/var&gt; 되도록 벡터는 &lt;code&gt;&lt;var&gt;w&lt;/var&gt; = &lt;var&gt;A&lt;/var&gt; * &lt;var&gt;v&lt;/var&gt;&lt;/code&gt; 와 &lt;code&gt;norm (&lt;var&gt;w&lt;/var&gt;, 1)&lt;/code&gt; = &lt;code&gt;&lt;var&gt;c&lt;/var&gt; * norm (&lt;var&gt;v&lt;/var&gt;, 1)&lt;/code&gt; . &lt;var&gt;iter&lt;/var&gt; 는 &lt;code&gt;&lt;var&gt;iter&lt;/var&gt;(1)&lt;/code&gt; 반복 횟수 (최대 값은 5로 하드 코딩 됨)와 &lt;code&gt;&lt;var&gt;iter&lt;/var&gt;(2)&lt;/code&gt; 에 알고리즘에 의해 수행 된 총 제품 수 &lt;code&gt;&lt;var&gt;A&lt;/var&gt; * &lt;var&gt;x&lt;/var&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;var&gt;A&lt;/var&gt;' * &lt;var&gt;x&lt;/var&gt;&lt;/code&gt; 를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="56dc721ae2b31a74a7e479b2125e35700eb73c69" translate="yes" xml:space="preserve">
          <source>On return, &lt;var&gt;info&lt;/var&gt; is set to</source>
          <target state="translated">돌아 왔을 때 &lt;var&gt;info&lt;/var&gt; 는</target>
        </trans-unit>
        <trans-unit id="7bfb6ff4ae83c31558564497c3266cb3b3e61289" translate="yes" xml:space="preserve">
          <source>On return, &lt;var&gt;x&lt;/var&gt; is the location of the minimum and &lt;var&gt;fval&lt;/var&gt; contains the value of the objective function at &lt;var&gt;x&lt;/var&gt;.</source>
          <target state="translated">돌아 왔을 때, &lt;var&gt;x&lt;/var&gt; 는 최소의 위치이며 &lt;var&gt;fval&lt;/var&gt; 은 &lt;var&gt;x&lt;/var&gt; 의 목적 함수의 값을 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="764f4d33381b94a346c4c12ec0945e8f4f6d507c" translate="yes" xml:space="preserve">
          <source>On some DEC alpha systems there may be a problem with the &lt;code&gt;libdxml&lt;/code&gt; library, resulting in floating point errors and/or segmentation faults in the linear algebra routines called by Octave. If you encounter such problems, then you should modify the configure script so that &lt;code&gt;SPECIAL_MATH_LIB&lt;/code&gt; is not set to &lt;code&gt;-ldxml&lt;/code&gt;.</source>
          <target state="translated">일부 DEC 알파 시스템에서는 &lt;code&gt;libdxml&lt;/code&gt; 라이브러리에 문제가있어 Octave에서 호출 한 선형 대수 루틴에서 부동 소수점 오류 및 / 또는 분할 오류가 발생할 수 있습니다. 이러한 문제점이 발생하면 &lt;code&gt;SPECIAL_MATH_LIB&lt;/code&gt; 가 &lt;code&gt;-ldxml&lt;/code&gt; 로 설정되지 않도록 구성 스크립트를 수정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e17b2de5d6904b91ef18d4debd0836acb1504591" translate="yes" xml:space="preserve">
          <source>On some SCO systems, &lt;code&gt;info&lt;/code&gt; fails to compile if &lt;code&gt;HAVE_TERMIOS_H&lt;/code&gt; is defined in</source>
          <target state="translated">일부 SCO 시스템에서 &lt;code&gt;HAVE_TERMIOS_H&lt;/code&gt; 가 다음에 정의되어 있으면 &lt;code&gt;info&lt;/code&gt; 가 컴파일되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a90d68183e9bdaa17e9dc0cda30a68350c7dc00c" translate="yes" xml:space="preserve">
          <source>On some systems the &lt;code&gt;SIG_IGN&lt;/code&gt; macro is defined to be something like this:</source>
          <target state="translated">일부 시스템에서 &lt;code&gt;SIG_IGN&lt;/code&gt; 매크로는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a68a0b2690f3397ecfca722b6757620e7d388ae3" translate="yes" xml:space="preserve">
          <source>On some systems you can obtain many of Octave&amp;rsquo;s build dependencies automatically. The commands for doing this vary by system. Similarly, the names of pre-compiled packages vary by system and do not always match exactly the names listed in &lt;a href=&quot;build-tools#Build-Tools&quot;&gt;Build Tools&lt;/a&gt; and &lt;a href=&quot;external-packages#External-Packages&quot;&gt;External Packages&lt;/a&gt;.</source>
          <target state="translated">일부 시스템에서는 많은 Octave의 빌드 종속성을 자동으로 얻을 수 있습니다. 이를 수행하는 명령은 시스템마다 다릅니다. 마찬가지로 사전 컴파일 된 패키지의 이름은 시스템마다 다르며 &lt;a href=&quot;build-tools#Build-Tools&quot;&gt;빌드 도구&lt;/a&gt; 및 &lt;a href=&quot;external-packages#External-Packages&quot;&gt;외부 패키지에&lt;/a&gt; 나열된 이름과 항상 일치하지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4cb74c598597e0f92be47be8e95a0aa17cfe660f" translate="yes" xml:space="preserve">
          <source>On systems that support job control, you can suspend Octave by sending it a &lt;code&gt;SIGTSTP&lt;/code&gt; signal, usually by typing</source>
          <target state="translated">작업 제어를 지원하는 시스템 에서 일반적으로 다음을 입력하여 옥타브를 &lt;code&gt;SIGTSTP&lt;/code&gt; 신호 로 보내 일시 중단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1420cb9694bb10345b6a9b8e6824674edaa3bd25" translate="yes" xml:space="preserve">
          <source>On systems where the reference &lt;small&gt;BLAS&lt;/small&gt; library is used the following matrix-by-vector multiplication incorrectly handles NaN values of the form &lt;code&gt;NaN * 0&lt;/code&gt;.</source>
          <target state="translated">참조가 &lt;small&gt;BLAS 인&lt;/small&gt; 시스템에서&lt;small&gt;&lt;/small&gt; 라이브러리가 사용되는 다음 벡터 별 행렬 곱셈은 &lt;code&gt;NaN * 0&lt;/code&gt; 형식의 NaN 값을 잘못 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="1af3772783e3704e3dc24adc1abc9038a9725c72" translate="yes" xml:space="preserve">
          <source>On systems with &lt;code&gt;apt-get&lt;/code&gt; (Debian, Ubuntu, etc.), you may be able to install most of the tools and external packages using a command similar to</source>
          <target state="translated">시스템 &lt;code&gt;apt-get&lt;/code&gt; 을 (데비안, 우분투 등)과 유사한 명령을 사용하여 도구와 외부 패키지의 대부분을 설치할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="614329c751f1c42ee7ba089a91f20cef6b560dfe" translate="yes" xml:space="preserve">
          <source>On systems with &lt;code&gt;yum&lt;/code&gt; (Fedora, Red Hat, etc.), you may be able to install most of the tools and external packages using a command similar to</source>
          <target state="translated">시스템 &lt;code&gt;yum&lt;/code&gt; (페도라, 레드햇 등)과 유사한 명령을 사용하여 도구와 외부 패키지의 대부분을 설치할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c9ee4d752ef3ecd6c6371c4bc5eb16d53bd99c51" translate="yes" xml:space="preserve">
          <source>On the contrary, if &lt;code&gt;&quot;double&quot;&lt;/code&gt; is given, the operation is performed in double precision even for single precision inputs.</source>
          <target state="translated">반대로 &lt;code&gt;&quot;double&quot;&lt;/code&gt; 이 주어지면, 단 정밀 입력에 대해서도 연산이 배정도로 수행된다.</target>
        </trans-unit>
        <trans-unit id="322f5f341a6f14c5ef963fc797cb9613ccc4405d" translate="yes" xml:space="preserve">
          <source>On the other hand, once you have shown people where to find the change, you need not explain its purpose. Thus, if you add a new function, all you need to say about it is that it is new. If you feel that the purpose needs explaining, it probably does&amp;mdash;but the explanation will be much more useful if you put it in comments in the code.</source>
          <target state="translated">반면에 변경 사항을 찾을 수있는 위치를 사람들에게 보여 주면 그 목적을 설명 할 필요가 없습니다. 따라서 새 기능을 추가하면 새 기능 만 있으면됩니다. 목적에 설명이 필요하다고 생각되면 아마도 설명이 필요하지만 코드에 주석을 달면 설명이 훨씬 유용합니다.</target>
        </trans-unit>
        <trans-unit id="054360e603a255e7b6a8f982437b213f64d463f7" translate="yes" xml:space="preserve">
          <source>Once a constructor and display method exist, it is possible to create an instance of the class. It is also possible to check the class type and examine the underlying structure.</source>
          <target state="translated">생성자와 표시 메소드가 존재하면 클래스의 인스턴스를 작성할 수 있습니다. 클래스 유형을 확인하고 기본 구조를 검사 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecbfcb0565dcc8d998ddb2b67b1c2924fff1fc55" translate="yes" xml:space="preserve">
          <source>Once a file has been opened for writing a string can be written to the file using the &lt;code&gt;fputs&lt;/code&gt; function. The following example shows how to write the string &amp;lsquo;</source>
          <target state="translated">파일을 쓰기 위해 파일을 열면 &lt;code&gt;fputs&lt;/code&gt; 함수를 사용하여 파일에 문자열을 쓸 수 있습니다 . 다음 예제는 문자열을 작성하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7c172d37d41d6d71b4ca74d7819fd7c878af0f37" translate="yes" xml:space="preserve">
          <source>Once a file has been opened its status can be acquired. As an example the &lt;code&gt;feof&lt;/code&gt; functions determines if the end of the file has been reached. This can be very useful when reading small parts of a file at a time. The following example shows how to read one line at a time from a file until the end has been reached.</source>
          <target state="translated">파일이 열리면 상태를 확인할 수 있습니다. 예를 들어 &lt;code&gt;feof&lt;/code&gt; 함수는 파일 끝에 도달했는지 판별합니다. 한 번에 파일의 작은 부분을 읽을 때 매우 유용 할 수 있습니다. 다음 예제는 파일에서 끝에 도달 할 때까지 한 번에 한 줄씩 읽는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="383a8e9a73eb4c09c952ed29a4a3797ae1fd21be" translate="yes" xml:space="preserve">
          <source>Once a property in added to an &lt;code&gt;hggroup&lt;/code&gt;, it is not linked to any other property of either the children of the group, or any other graphics object. Add so to control the way in which this newly added property is used, the &lt;code&gt;addlistener&lt;/code&gt; function is used to define a callback function that is executed when the property is altered.</source>
          <target state="translated">속성이 &lt;code&gt;hggroup&lt;/code&gt; 에 추가되면 그룹의 자식 또는 다른 그래픽스 객체의 다른 속성에 연결되지 않습니다. 이 새로 추가 된 속성이 사용되는 방식을 제어하기 위해 추가하면, &lt;code&gt;addlistener&lt;/code&gt; 함수는 속성이 변경 될 때 실행되는 콜백 함수를 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c7e8b255551d3ba35f55c6b4d5342c51c2f853d" translate="yes" xml:space="preserve">
          <source>Once an object has been created it is natural to find out what fields the object has, and to read (get) and write (set) them.</source>
          <target state="translated">일단 객체가 생성되면 객체가 가지고있는 필드를 찾아서 읽고 (읽고) 쓰고 (설정)하는 것이 당연합니다.</target>
        </trans-unit>
        <trans-unit id="8e5ddd6b2c15db4cb685362fca6462753bf853c3" translate="yes" xml:space="preserve">
          <source>Once one or more variables have been saved to a file, they can be read into memory using the &lt;code&gt;load&lt;/code&gt; command.</source>
          <target state="translated">하나 이상의 변수가 파일에 저장되면 &lt;code&gt;load&lt;/code&gt; 명령을 사용하여 메모리로 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="855968a99a08ab63d162c92e45455b2056c9f74b" translate="yes" xml:space="preserve">
          <source>Once the GNU Info browser is running, help for using it is available using the command</source>
          <target state="translated">GNU Info 브라우저가 실행되면 다음 명령을 사용하여 브라우저를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6baf57478cad1de3a094a62f4d373ac5b9de538b" translate="yes" xml:space="preserve">
          <source>Once the end of data has been reached, &lt;code&gt;getgrent&lt;/code&gt; returns 0.</source>
          <target state="translated">데이터의 끝에 도달하면 &lt;code&gt;getgrent&lt;/code&gt; 는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="faa1e6214bddbef30bf45f4895094653bcc853c3" translate="yes" xml:space="preserve">
          <source>Once the end of the data has been reached, &lt;code&gt;getpwent&lt;/code&gt; returns 0.</source>
          <target state="translated">데이터의 끝에 도달하면 &lt;code&gt;getpwent&lt;/code&gt; 는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="06ead81a2ee80e5387d4397fde87b1779f322d1e" translate="yes" xml:space="preserve">
          <source>Once this function is defined, you can ask Octave to evaluate it by typing the name of the function.</source>
          <target state="translated">이 함수가 정의되면 함수 이름을 입력하여 Octave에 평가를 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bf06dd012888169c6479043f9d0da72ad8c18aa" translate="yes" xml:space="preserve">
          <source>Once you have learned Octave, you may want to write self-contained Octave scripts, using the &amp;lsquo;</source>
          <target state="translated">옥타브를 배우고 나면 '</target>
        </trans-unit>
        <trans-unit id="302844c1400b06037c34e7bbd711d266691961bd" translate="yes" xml:space="preserve">
          <source>Once you have successfully compiled Octave, run &lt;code&gt;make install&lt;/code&gt;.</source>
          <target state="translated">Octave를 성공적으로 컴파일했으면 &lt;code&gt;make install&lt;/code&gt; 을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="58ea4fdf32c4543112311658f8ef5792e4f449fe" translate="yes" xml:space="preserve">
          <source>Once you know the name of the function you wish to use, you can get more help on the function by simply including the name as an argument to help. For example,</source>
          <target state="translated">사용하려는 함수의 이름을 알고 나면 이름을 인수로 포함시켜 함수에 대한 추가 도움말을 얻을 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="b5079d0436d7d0ff4478902db7b87ac5c5b6c603" translate="yes" xml:space="preserve">
          <source>One additional complication of strings in Octave is the difference between single quoted and double quoted strings. To find out if an &lt;code&gt;octave_value&lt;/code&gt; contains a single or double quoted string use one of the predicate tests shown below.</source>
          <target state="translated">옥타브에서 문자열의 추가 합병증은 작은 따옴표와 큰 따옴표로 묶인 문자열의 차이입니다. &lt;code&gt;octave_value&lt;/code&gt; 에 작은 따옴표 나 큰 따옴표가 포함 된 문자열이 포함되어 있는지 확인하려면 아래에 표시된 조건 자 테스트 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="080bec73f3571cc8433591497b2b2e2b806a7180" translate="yes" xml:space="preserve">
          <source>One advantage of using the &lt;code&gt;switch&lt;/code&gt; statement compared to using &lt;code&gt;if&lt;/code&gt; statements is that the &lt;var&gt;label&lt;/var&gt;s can be strings. If an &lt;code&gt;if&lt;/code&gt; statement is used it is &lt;em&gt;not&lt;/em&gt; possible to write</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 문 을 사용 하는 것과 비교 하여 &lt;code&gt;switch&lt;/code&gt; 문을 사용 하면 &lt;var&gt;label&lt;/var&gt; s가 문자열 일 수 있다는 이점 이 있습니다. 는 IF &lt;code&gt;if&lt;/code&gt; 문을 사용하는 그것입니다 &lt;em&gt;하지&lt;/em&gt; 쓸 수</target>
        </trans-unit>
        <trans-unit id="9e972ffbe45931633d2ef8b7151cf81d41790928" translate="yes" xml:space="preserve">
          <source>One can insert LaTeX inline math, surrounded by single &amp;lsquo;</source>
          <target state="translated">하나는 '로 둘러싸인 LaTeX 인라인 수학을 삽입 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5893b0d6845f8c0863e38df2953a2eb80d0c85cd" translate="yes" xml:space="preserve">
          <source>One can perform exactly the same operations on Cell arrays in mex-files as in oct-files. An example that duplicates the function of the</source>
          <target state="translated">oct 파일에서와 같이 mex 파일에서 Cell 배열에 대해 정확히 동일한 작업을 수행 할 수 있습니다. 의 기능을 복제하는 예</target>
        </trans-unit>
        <trans-unit id="64442627b907dbc4da65f7edb2a448a7b6f48b53" translate="yes" xml:space="preserve">
          <source>One can see, that even a &lt;code&gt;java.lang.Double&lt;/code&gt; is not converted to an Octave &lt;code&gt;double&lt;/code&gt;, when created by &lt;a href=&quot;java-interface-functions#XREFjavaObject&quot;&gt;javaObject&lt;/a&gt;. But ambiguities might arise, if the Java classes &lt;code&gt;java.lang.Double&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt; are parameters of a method (or a constructor). In this case they can be converted into one another, depending on the context.</source>
          <target state="translated">&lt;a href=&quot;java-interface-functions#XREFjavaObject&quot;&gt;javaObject에&lt;/a&gt; 의해 생성 될 때 &lt;code&gt;java.lang.Double&lt;/code&gt; 조차도 Octave &lt;code&gt;double&lt;/code&gt; 로 변환되지 않음 을 알 수 있습니다. 그러나 Java 클래스 &lt;code&gt;java.lang.Double&lt;/code&gt; 또는 &lt;code&gt;double&lt;/code&gt; 이 메소드 (또는 생성자)의 매개 변수 인 경우 모호성이 발생할 수 있습니다 . 이 경우 상황에 따라 서로 변환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28cc2d537c662aed82db7809e480880aa1b8f607" translate="yes" xml:space="preserve">
          <source>One common use of cell arrays is to store multiple strings in the same variable. It is also possible to store multiple strings in a character matrix by letting each row be a string. This, however, introduces the problem that all strings must be of equal length. Therefore, it is recommended to use cell arrays to store multiple strings. For cases, where the character matrix representation is required for an operation, there are several functions that convert a cell array of strings to a character array and back. &lt;code&gt;char&lt;/code&gt; and &lt;code&gt;strvcat&lt;/code&gt; convert cell arrays to a character array (see &lt;a href=&quot;concatenating-strings#Concatenating-Strings&quot;&gt;Concatenating Strings&lt;/a&gt;), while the function &lt;code&gt;cellstr&lt;/code&gt; converts a character array to a cell array of strings:</source>
          <target state="translated">셀형 배열의 일반적인 용도 중 하나는 동일한 변수에 여러 문자열을 저장하는 것입니다. 각 행을 문자열로하여 문자 행렬에 여러 문자열을 저장할 수도 있습니다. 그러나 이것은 모든 문자열의 길이가 같아야한다는 문제를 일으 킵니다. 따라서 셀형 배열을 사용하여 여러 문자열을 저장하는 것이 좋습니다. 연산에 문자 행렬 표현이 필요한 경우 문자열의 셀형 배열을 문자형 배열로 변환하는 함수가 몇 가지 있습니다. &lt;code&gt;char&lt;/code&gt; 및 &lt;code&gt;strvcat&lt;/code&gt; 은 셀형 배열을 문자형 배열 ( &lt;a href=&quot;concatenating-strings#Concatenating-Strings&quot;&gt;문자열 연결&lt;/a&gt; 참조 ) 로 변환하는 반면, &lt;code&gt;cellstr&lt;/code&gt; 함수는 문자형 배열을 문자열의 셀형 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="fed86725087e68440c010d0987378a8ba697fd6e" translate="yes" xml:space="preserve">
          <source>One difficulty of commands occurs when one of the string input arguments is stored in a variable. Because Octave can&amp;rsquo;t tell the difference between a variable name and an ordinary string, it is not possible to pass a variable as input to a command. In such a situation a command must be called as a function. For example:</source>
          <target state="translated">문자열 입력 인수 중 하나가 변수에 저장되면 명령의 한 가지 어려움이 발생합니다. 옥타브는 변수 이름과 일반 문자열의 차이점을 알 수 없으므로 변수를 명령의 입력으로 전달할 수 없습니다. 이러한 상황에서는 명령을 함수로 호출해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="917eb3f3ed94cf96b287d64bf43e862e9b733acc" translate="yes" xml:space="preserve">
          <source>One further advantage of using cell arrays to store multiple strings is that most functions for string manipulations included with Octave support this representation. As an example, it is possible to compare one string with many others using the &lt;code&gt;strcmp&lt;/code&gt; function. If one of the arguments to this function is a string and the other is a cell array of strings, each element of the cell array will be compared to the string argument:</source>
          <target state="translated">여러 문자열을 저장하기 위해 셀형 배열을 사용하는 또 다른 이점은 Octave에 포함 된 문자열 조작을위한 대부분의 기능이이 표현을 지원한다는 것입니다. 예를 들어 &lt;code&gt;strcmp&lt;/code&gt; 함수를 사용하여 한 문자열을 다른 문자열과 비교할 수 있습니다. 이 함수의 인수 중 하나가 문자열이고 다른 하나는 문자열의 셀형 배열 인 경우 셀형 배열의 각 요소는 문자열 인수와 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="53d61e462ca4ef9ec8e275892ec7f8287bfaa6a0" translate="yes" xml:space="preserve">
          <source>One kluge around this problem is to extract</source>
          <target state="translated">이 문제를 해결하는 방법은 추출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e3f32f5a450b4eefda350fb8960fc28aa48abc2" translate="yes" xml:space="preserve">
          <source>One principal goal of descriptive statistics is to represent the essence of a large data set concisely. Octave provides the mean, median, and mode functions which all summarize a data set with just a single number corresponding to the central tendency of the data.</source>
          <target state="translated">기술 통계량의 주요 목표는 대규모 데이터 세트의 본질을 간결하게 나타내는 것입니다. 옥타브는 데이터의 중심 경향에 해당하는 단일 숫자로 데이터 세트를 요약하는 평균, 중앙값 및 모드 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8e126edecc03b4a7d977d1c93c86de0a1004c3ce" translate="yes" xml:space="preserve">
          <source>One relevant question is, what happens when a character matrix is created from strings of different length. The answer is that Octave puts blank characters at the end of strings shorter than the longest string. It is possible to use a different character than the blank character using the &lt;code&gt;string_fill_char&lt;/code&gt; function.</source>
          <target state="translated">관련 질문 중 하나는 길이가 다른 문자열에서 문자 행렬을 만들 때 발생하는 문제입니다. 정답은 Octave가 가장 긴 문자열보다 짧은 문자열 끝에 빈 문자를 넣는 것입니다. &lt;code&gt;string_fill_char&lt;/code&gt; 함수를 사용하여 공백 문자와 다른 문자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a20d150b55253eb13ce2dd8cb0270c36d67f254a" translate="yes" xml:space="preserve">
          <source>One restriction for persistent variables is, that neither input nor output arguments of a function can be persistent:</source>
          <target state="translated">영속 변수에 대한 한 가지 제한 사항은 함수의 입력 및 출력 인수가 영속 될 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="438be17a9f009165e43555808cc4e1799bd84dbf" translate="yes" xml:space="preserve">
          <source>One use of sparse matrices is in graph theory, where the interconnections between nodes are represented as an adjacency matrix. That is, if the i-th node in a graph is connected to the j-th node. Then the ij-th node (and in the case of undirected graphs the ji-th node) of the sparse adjacency matrix is nonzero. If each node is then associated with a set of coordinates, then the &lt;em&gt;gplot&lt;/em&gt; command can be used to graphically display the interconnections between nodes.</source>
          <target state="translated">희소 행렬의 한 가지 사용은 그래프 이론에 있으며, 여기서 노드 간의 상호 연결은 인접 행렬로 표시됩니다. 즉, 그래프의 i 번째 노드가 j 번째 노드에 연결된 경우입니다. 그런 다음 희소 인접 행렬의 ij 번째 노드 (및 무 방향 그래프의 경우 jith 번째 노드)는 0이 아닙니다. 각 노드가 좌표 세트와 연관되면 &lt;em&gt;gplot&lt;/em&gt; 명령을 사용하여 노드 간의 상호 연결을 그래픽으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc3ac91f24ed27fbda70406a299eebcfe8ef5622" translate="yes" xml:space="preserve">
          <source>One-dimensional Interpolation</source>
          <target state="translated">1 차원 보간</target>
        </trans-unit>
        <trans-unit id="8ed1c8b841605358b59c251edca0102c1451452c" translate="yes" xml:space="preserve">
          <source>One-dimensional interpolation.</source>
          <target state="translated">1 차원 보간.</target>
        </trans-unit>
        <trans-unit id="444da8bd773d6cdbdb2bc50334cf3eeae9bc3eff" translate="yes" xml:space="preserve">
          <source>Only figures that are modified will be updated. The &lt;code&gt;refresh&lt;/code&gt; function can also be used to cause an update of the current figure, even if it is not modified.</source>
          <target state="translated">수정 된 수치 만 업데이트됩니다. &lt;code&gt;refresh&lt;/code&gt; 기능은 또한이 수정되지 않은 경우에도, 현재의 모습의 업데이트를 야기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4ebab3d4baee77698372613b1a24e64a8487a06" translate="yes" xml:space="preserve">
          <source>Only valid for GIF images, control how successive frames are rendered (how the preceding frame is disposed of) when creating a GIF animation. Values can be &lt;code&gt;&quot;doNotSpecify&quot;&lt;/code&gt;, &lt;code&gt;&quot;leaveInPlace&quot;&lt;/code&gt;, &lt;code&gt;&quot;restoreBG&quot;&lt;/code&gt;, or &lt;code&gt;&quot;restorePrevious&quot;&lt;/code&gt;. For non-GIF files, value is an empty string.</source>
          <target state="translated">GIF 이미지에만 유효하며 GIF 애니메이션을 만들 때 연속 프레임이 렌더링되는 방식 (앞의 프레임이 처리되는 방식)을 제어합니다. 값은 &lt;code&gt;&quot;doNotSpecify&quot;&lt;/code&gt; , &lt;code&gt;&quot;leaveInPlace&quot;&lt;/code&gt; , &lt;code&gt;&quot;restoreBG&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;restorePrevious&quot;&lt;/code&gt; 일 수 있습니다. GIF가 아닌 파일의 경우 value는 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="174bb82dff8a4a7f0eb94a396cfc6e85c46e2647" translate="yes" xml:space="preserve">
          <source>Open a GUI dialog for selecting a directory.</source>
          <target state="translated">디렉토리를 선택하기위한 GUI 대화 상자를여십시오.</target>
        </trans-unit>
        <trans-unit id="ad82da5cfe3e56b7dcbd8e0555eb0f7b0d5128cc" translate="yes" xml:space="preserve">
          <source>Open a GUI dialog for selecting a file and return the filename &lt;var&gt;fname&lt;/var&gt;, the path to this file &lt;var&gt;fpath&lt;/var&gt;, and the filter index &lt;var&gt;fltidx&lt;/var&gt;.</source>
          <target state="translated">파일을 선택하기위한 GUI 대화 상자를 열고 파일 이름 &lt;var&gt;fname&lt;/var&gt; ,이 파일 &lt;var&gt;fpath&lt;/var&gt; 의 경로 및 필터 색인 &lt;var&gt;fltidx&lt;/var&gt; 를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="94e898edfbb5f5eacd0ddafd3ee43f7e68557db9" translate="yes" xml:space="preserve">
          <source>Open a GUI dialog for selecting a file.</source>
          <target state="translated">파일을 선택하기위한 GUI 대화 상자를여십시오.</target>
        </trans-unit>
        <trans-unit id="8c474671d06e4980f7bf0db54e5397e91b2b60da" translate="yes" xml:space="preserve">
          <source>Open a file for low-level I/O or query open files and file descriptors.</source>
          <target state="translated">저수준 I / O 용 파일을 열거 나 열린 파일 및 파일 설명자를 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="4fe8123223ed699a6cb1a52c25c9ce09f33f3209" translate="yes" xml:space="preserve">
          <source>Open a file for reading or writing. The previous contents are discarded.</source>
          <target state="translated">읽거나 쓸 파일을 엽니 다. 이전 내용은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6e2de2381cfe62f21924e01b2fc221e24d0bb00b" translate="yes" xml:space="preserve">
          <source>Open a file for reading.</source>
          <target state="translated">읽을 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="e0ef55a51000ae08edb050dd45393c6a74e1b928" translate="yes" xml:space="preserve">
          <source>Open a file for writing. The previous contents are discarded.</source>
          <target state="translated">쓸 파일을 엽니 다. 이전 내용은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="ab5ce3d95899c9a3cf8ef9ccb89c0e9f7a716980" translate="yes" xml:space="preserve">
          <source>Open a new figure window and plot the solution of an ode problem at each time step during the integration.</source>
          <target state="translated">새 그림 창을 열고 통합 중 각 시간 단계에서 ode 문제의 솔루션을 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="26f4521155eb167b2c49e1bab65529e7c5ab13e5" translate="yes" xml:space="preserve">
          <source>Open an existing file for reading and writing.</source>
          <target state="translated">읽고 쓸 기존 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="035c8b99b52e844eabbdb9dbba561af68f910ec8" translate="yes" xml:space="preserve">
          <source>Open file in the editor. No &lt;var&gt;output&lt;/var&gt; value is returned.</source>
          <target state="translated">편집기에서 파일을여십시오. &lt;var&gt;output&lt;/var&gt; 값이 반환 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3e2894170bd34a9550fd02467e0e37b0aec41a1e" translate="yes" xml:space="preserve">
          <source>Open for reading and writing.</source>
          <target state="translated">읽고 쓰기 위해 엽니 다.</target>
        </trans-unit>
        <trans-unit id="403acccd1de142676f8269755bdc38e166ec8c81" translate="yes" xml:space="preserve">
          <source>Open for reading only.</source>
          <target state="translated">읽기 전용으로 엽니 다.</target>
        </trans-unit>
        <trans-unit id="769044816a004cc7834fa219411cb74c7418c416" translate="yes" xml:space="preserve">
          <source>Open for writing only.</source>
          <target state="translated">쓰기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="7c4bc8eff9d9fc5d113237c6bbc2054356552edc" translate="yes" xml:space="preserve">
          <source>Open or create a file for reading or writing at the end of the file.</source>
          <target state="translated">파일 끝에서 읽거나 쓸 파일을 열거 나 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6b9b0bf85d4626622ee9f6b61c3b6e8e7e5a873b" translate="yes" xml:space="preserve">
          <source>Open or create a file for writing at the end of the file.</source>
          <target state="translated">파일 끝에 쓸 파일을 열거 나 만듭니다.</target>
        </trans-unit>
        <trans-unit id="07087e1b1b01fc8ae3772fbafbb991c0ac612355" translate="yes" xml:space="preserve">
          <source>Open the data file with &lt;code&gt;load&lt;/code&gt;. If no return value &lt;var&gt;output&lt;/var&gt; is requested, variables are loaded in the base workspace. Otherwise &lt;var&gt;output&lt;/var&gt; will be a structure containing loaded data. See &lt;a href=&quot;simple-file-i_002fo#XREFload&quot;&gt;load function&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;load&lt;/code&gt; 로 데이터 파일을 엽니 다 . 리턴 값 &lt;var&gt;output&lt;/var&gt; 이 요청 되지 않으면 변수가 기본 작업 공간에로드됩니다. 그렇지 않으면 &lt;var&gt;output&lt;/var&gt; 은로드 된 데이터를 포함하는 구조가됩니다. &lt;a href=&quot;simple-file-i_002fo#XREFload&quot;&gt;로드 기능을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="73e841ccece4923a6b5d4705fe33eca698fff3b9" translate="yes" xml:space="preserve">
          <source>Open the figure with hgload. See &lt;a href=&quot;printing-and-saving-plots#XREFhgload&quot;&gt;hgload function&lt;/a&gt;.</source>
          <target state="translated">hgload로 그림을 엽니 다. &lt;a href=&quot;printing-and-saving-plots#XREFhgload&quot;&gt;hgload 함수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="542e2463bd734aed4e76019190bd84e77b39ac55" translate="yes" xml:space="preserve">
          <source>Open the file &lt;var&gt;file&lt;/var&gt; in Octave or in an external application based on the file type as determined by the filename extension.</source>
          <target state="translated">파일 이름 확장명에 따라 파일 형식에 따라 Octave 또는 외부 응용 프로그램에서 파일 &lt;var&gt;file&lt;/var&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="8ae1fdd1f8d72b933257128d207678f153c26ecb" translate="yes" xml:space="preserve">
          <source>Open the variable &lt;var&gt;name&lt;/var&gt; in the graphical Variable Editor.</source>
          <target state="translated">그래픽 변수 편집기에서 변수 &lt;var&gt;name&lt;/var&gt; 을여십시오.</target>
        </trans-unit>
        <trans-unit id="64772f9d09ee3b76e5bdf35aaa7583343125a29f" translate="yes" xml:space="preserve">
          <source>OpenGL</source>
          <target state="translated">OpenGL</target>
        </trans-unit>
        <trans-unit id="b707a701135ca61c167d02640a48788275f569bf" translate="yes" xml:space="preserve">
          <source>OpenGL to PostScript printing library (&lt;a href=&quot;https://www.geuz.org/gl2ps/&quot;&gt;https://www.geuz.org/gl2ps/&lt;/a&gt;). gl2ps is required for printing when using OpenGL-based graphics toolkits (currently either FLTK or Qt).</source>
          <target state="translated">OpenGL to PostScript 인쇄 라이브러리 ( &lt;a href=&quot;https://www.geuz.org/gl2ps/&quot;&gt;https://www.geuz.org/gl2ps/&lt;/a&gt; ) OpenGL 기반 그래픽 툴킷 (현재 FLTK 또는 Qt)을 사용할 때 gl2ps가 인쇄에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="93b15520fdb15949b25b4231f94a87ccae6c8c73" translate="yes" xml:space="preserve">
          <source>Opening a file that is already open simply opens it again and returns a separate file id. It is not an error to open a file several times, though writing to the same file through several different file ids may produce unexpected results.</source>
          <target state="translated">이미 열려있는 파일을 열면 파일이 다시 열리고 별도의 파일 ID가 반환됩니다. 파일을 여러 번 여는 것은 오류가 아니지만 여러 다른 파일 ID를 통해 동일한 파일에 쓰면 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bce6ddc686d0c9b7e39ff96a3dc97bbbc372eb7" translate="yes" xml:space="preserve">
          <source>Opening and Closing Files</source>
          <target state="translated">파일 열기 및 닫기</target>
        </trans-unit>
        <trans-unit id="4676755a8e864a5233b4553b758fa5e21ce07175" translate="yes" xml:space="preserve">
          <source>Openings and Closings</source>
          <target state="translated">오프닝 및 클로징</target>
        </trans-unit>
        <trans-unit id="11351ad3dcfe8e582a069661d8aef262e58e5646" translate="yes" xml:space="preserve">
          <source>Operate along the dimension specified, rather than the default of the first non-singleton dimension.</source>
          <target state="translated">첫 번째 비단 일 치수의 기본값이 아닌 지정된 치수를 따라 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a7eeb0f16aa43e2ef5db63d07e15bdd9d2ce75ca" translate="yes" xml:space="preserve">
          <source>Operate on the axes in handle &lt;var&gt;hax&lt;/var&gt; instead of the current axes.</source>
          <target state="translated">현재 축 대신 핸들 &lt;var&gt;hax&lt;/var&gt; 의 축에서 작동하십시오 .</target>
        </trans-unit>
        <trans-unit id="430d32076eb256f0fb1db5fd1333254c368ef1ba" translate="yes" xml:space="preserve">
          <source>Operation</source>
          <target state="translated">Operation</target>
        </trans-unit>
        <trans-unit id="a1ad787f952fcdc3bd8cb5eea146aade98386f6c" translate="yes" xml:space="preserve">
          <source>Operator Index</source>
          <target state="translated">운영자 색인</target>
        </trans-unit>
        <trans-unit id="f299c884a708c75ca75144e361f0c5cf282b235f" translate="yes" xml:space="preserve">
          <source>Operator Overloading</source>
          <target state="translated">연산자 오버로딩</target>
        </trans-unit>
        <trans-unit id="5ab53f8310f5b3d7c33f42f382419ed45034e50e" translate="yes" xml:space="preserve">
          <source>Operator Precedence</source>
          <target state="translated">운영자 우선 순위</target>
        </trans-unit>
        <trans-unit id="9613126de85534b0c1f67629abbe8a2dea694a77" translate="yes" xml:space="preserve">
          <source>Operators such as &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, or &lt;code&gt;*&lt;/code&gt; can be used on the majority of the matrix and array types. In addition there are a number of methods that are of interest only for matrices such as &lt;code&gt;transpose&lt;/code&gt;, &lt;code&gt;hermitian&lt;/code&gt;, &lt;code&gt;solve&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; 또는 &lt;code&gt;*&lt;/code&gt; 와 같은 연산자 는 대부분의 행렬 및 배열 유형에서 사용할 수 있습니다. 또한 &lt;code&gt;transpose&lt;/code&gt; , &lt;code&gt;hermitian&lt;/code&gt; , &lt;code&gt;solve&lt;/code&gt; 등과 같은 행렬에만 관심있는 여러 가지 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9dffec10edd114b8652ff4f141d73e34d8dcccc3" translate="yes" xml:space="preserve">
          <source>Optimally choose between fixed point and exponential format based on the magnitude of the number. For example, with the &amp;lsquo;</source>
          <target state="translated">숫자의 크기에 따라 고정 소수점과 지수 형식을 최적으로 선택하십시오. 예를 들어 '</target>
        </trans-unit>
        <trans-unit id="fdf5e093149fa15365c797b12b39a00d5ec3a138" translate="yes" xml:space="preserve">
          <source>Optimization</source>
          <target state="translated">Optimization</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="c891dd822e02e600098522c6dade357a7adc8307" translate="yes" xml:space="preserve">
          <source>Option to disable vectorized integration, forcing Octave to use only scalar inputs when calling the integrand. The default value is &lt;var&gt;false&lt;/var&gt;.</source>
          <target state="translated">옥타브가 정수를 호출 할 때 스칼라 입력 만 사용하도록하는 벡터화 된 통합을 비활성화하는 옵션. 기본값은 &lt;var&gt;false&lt;/var&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8df6108398af0f9376b3f9c4cf96c1b3d43d82f5" translate="yes" xml:space="preserve">
          <source>Optional keyword describing the package (if no</source>
          <target state="translated">패키지를 설명하는 선택적 키워드 (없는 경우)</target>
        </trans-unit>
        <trans-unit id="9c892e7673bbdd1aaa14f43a68fd07865055bb34" translate="yes" xml:space="preserve">
          <source>Optional list of homepages related to the package.</source>
          <target state="translated">패키지와 관련된 선택적 홈페이지 목록.</target>
        </trans-unit>
        <trans-unit id="ceaa61b9606a03fbcae2c9c9cfdedfe206b23c63" translate="yes" xml:space="preserve">
          <source>Optional list of known problems.</source>
          <target state="translated">알려진 문제점의 선택적 목록.</target>
        </trans-unit>
        <trans-unit id="1b9985c6b3bf0d934d5f4e8d43efa60479e4c36f" translate="yes" xml:space="preserve">
          <source>Optional numeric argument &lt;var&gt;format_repeat&lt;/var&gt; can be used for limiting the number of items read:</source>
          <target state="translated">읽은 항목 수를 제한하기 위해 선택적 숫자 인수 &lt;var&gt;format_repeat&lt;/var&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a51271c36afece15062a003e98d9691c7beeb13" translate="yes" xml:space="preserve">
          <source>Optional property/value pairs are passed directly to the underlying patch objects.</source>
          <target state="translated">선택적 속성 / 값 쌍은 기본 패치 객체로 직접 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="25339f78bd52812c353d87e097402c06257b1f74" translate="yes" xml:space="preserve">
          <source>Optional property/value pairs are passed directly to the underlying text objects.</source>
          <target state="translated">선택적 속성 / 값 쌍은 기본 텍스트 개체로 직접 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="96afd3d4fa5347b2958dce8c80c49d5abc7616b3" translate="yes" xml:space="preserve">
          <source>Optional property/value pairs may be specified to control the appearance of the plot.</source>
          <target state="translated">플롯의 모양을 제어하기 위해 선택적 속성 / 값 쌍을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52449767e068a682855fb63392e95c8f220d5261" translate="yes" xml:space="preserve">
          <source>Optional property/value pairs may be used to control the appearance of the text.</source>
          <target state="translated">선택적 속성 / 값 쌍을 사용하여 텍스트 모양을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cb9a959101e7cec10fdd35b7fe8571acb6047b3" translate="yes" xml:space="preserve">
          <source>Optional return arguments &lt;var&gt;v1&lt;/var&gt;, &amp;hellip;, contain integer vectors such that,</source>
          <target state="translated">선택적 반환 인수 &lt;var&gt;v1&lt;/var&gt; ,&amp;hellip;은 다음과 같은 정수 벡터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a52732471aa2bdf24f724507f9111e2c222b9cc5" translate="yes" xml:space="preserve">
          <source>Optionally the color of the mesh can be specified independently of &lt;var&gt;z&lt;/var&gt; by supplying a color matrix, &lt;var&gt;c&lt;/var&gt;.</source>
          <target state="translated">선택적으로 메쉬의 색상은 색상 매트릭스 &lt;var&gt;c&lt;/var&gt; 를 제공하여 &lt;var&gt;z&lt;/var&gt; 와 독립적으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da9065db293ae6f0d0d3cb289cef82a454b29ce8" translate="yes" xml:space="preserve">
          <source>Optionally, &lt;code&gt;fminunc&lt;/code&gt; can return a structure with convergence statistics (&lt;var&gt;output&lt;/var&gt;), the output gradient (&lt;var&gt;grad&lt;/var&gt;) at the solution &lt;var&gt;x&lt;/var&gt;, and approximate Hessian (&lt;var&gt;hess&lt;/var&gt;) at the solution &lt;var&gt;x&lt;/var&gt;.</source>
          <target state="translated">선택적 &lt;code&gt;fminunc&lt;/code&gt; 는 수렴 통계 (갖는 구조 반환 할 &lt;var&gt;output&lt;/var&gt; ), 출력 그라데이션 ( &lt;var&gt;grad&lt;/var&gt; 용액에서) &lt;var&gt;x&lt;/var&gt; 와 대략 헤센 ( &lt;var&gt;hess&lt;/var&gt; ) 용액에 &lt;var&gt;x&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="9f40625cdc22c919fe37d56bf253d2d8ac85c930" translate="yes" xml:space="preserve">
          <source>Optionally, &lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, and &lt;var&gt;z&lt;/var&gt; can be supplied to represent the set of coordinates of &lt;var&gt;v&lt;/var&gt;. They can either be matrices of the same size as &lt;var&gt;v&lt;/var&gt; or vectors with sizes according to the dimensions of &lt;var&gt;v&lt;/var&gt;, in which case they are expanded to matrices (see &lt;a href=&quot;#XREFmeshgrid&quot;&gt;meshgrid&lt;/a&gt;).</source>
          <target state="translated">선택적으로, &lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt; 및 &lt;var&gt;z&lt;/var&gt; 는 &lt;var&gt;v&lt;/var&gt; 의 좌표 세트를 나타 내기 위해 제공 될 수 있습니다 . 그들 중 하나와 동일한 크기 일 수 행렬 &lt;var&gt;v&lt;/var&gt; 또는 크기에 따른 크기의 벡터 &lt;var&gt;v&lt;/var&gt; 들이 행렬 (참고로 확장되는 경우에, &lt;a href=&quot;#XREFmeshgrid&quot;&gt;meshgrid을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bbf3c34491a3203d7c62826f519f18744d2d7713" translate="yes" xml:space="preserve">
          <source>Optionally, a patch handle &lt;var&gt;p&lt;/var&gt; can be given as the last input argument to all function call variations and the vertex data will be extracted from the isosurface patch object. Finally, if no output argument is given then the colors of the patch given by the patch handle &lt;var&gt;p&lt;/var&gt; are changed.</source>
          <target state="translated">선택적으로 패치 핸들 &lt;var&gt;p&lt;/var&gt; 는 모든 함수 호출 변형에 대한 마지막 입력 인수로 제공 될 수 있으며 정점 데이터는 등면 패치 객체에서 추출됩니다. 마지막으로, 출력 인수가 제공되지 않으면 패치 핸들 &lt;var&gt;p&lt;/var&gt; 에 의해 주어진 패치의 색상 이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="9a944312b92b3d8212d8ea20227cf1d2785b3e5a" translate="yes" xml:space="preserve">
          <source>Optionally, if indices &lt;var&gt;idx1&lt;/var&gt;, &lt;var&gt;idx2&lt;/var&gt;, &amp;hellip; are supplied, return the number of elements that would result from the indexing</source>
          <target state="translated">선택적으로 인덱스 &lt;var&gt;idx1&lt;/var&gt; , &lt;var&gt;idx2&lt;/var&gt; ,&amp;hellip;가 제공되면 인덱싱으로 인한 요소 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f56a4d6968d583da8e88355a3cb26ceab461f957" translate="yes" xml:space="preserve">
          <source>Optionally, one can specify the number of iterations &lt;var&gt;iter&lt;/var&gt;, the updating factor &lt;var&gt;gamma&lt;/var&gt;, and initial values &lt;em&gt;a0&lt;/em&gt; and &lt;em&gt;b0&lt;/em&gt; for the scoring algorithm.</source>
          <target state="translated">선택적으로, 하나는 반복 횟수 지정 &lt;var&gt;iter&lt;/var&gt; , 갱신 팩터 &lt;var&gt;gamma&lt;/var&gt; , 초기 값 &lt;em&gt;A0&lt;/em&gt; 및 &lt;em&gt;B0&lt;/em&gt; 스코어링 알고리즘을.</target>
        </trans-unit>
        <trans-unit id="2c936444d53a01aa8bb3a8a4193ee1b659cd1f24" translate="yes" xml:space="preserve">
          <source>Optionally, row-pivoted updating can be used by supplying a row permutation (pivoting) matrix &lt;var&gt;P&lt;/var&gt;; in that case, an updated permutation matrix is returned. Note that if &lt;var&gt;L&lt;/var&gt;, &lt;var&gt;U&lt;/var&gt;, &lt;var&gt;P&lt;/var&gt; is a pivoted LU factorization as obtained by &lt;code&gt;lu&lt;/code&gt;:</source>
          <target state="translated">선택적으로, 행 순열 업데이트는 행 순열 (피봇 팅) 행렬 &lt;var&gt;P&lt;/var&gt; 를 제공함으로써 사용될 수 있으며 ; 이 경우 업데이트 된 순열 행렬이 반환됩니다. 만약 &lt;var&gt;L&lt;/var&gt; , &lt;var&gt;U&lt;/var&gt; , &lt;var&gt;P&lt;/var&gt; 가 &lt;code&gt;lu&lt;/code&gt; 에 의해 얻어진 피봇 식 LU 인수 분 해임에 주목하십시오 :</target>
        </trans-unit>
        <trans-unit id="b09d38972425f4589fe1b4f8ee7449c654e3c292" translate="yes" xml:space="preserve">
          <source>Optionally, the color of the mesh can be specified independently of &lt;var&gt;z&lt;/var&gt; by supplying &lt;var&gt;c&lt;/var&gt;, which is a vector for colormap data, or a matrix with three columns for RGB data. The number of colors specified in &lt;var&gt;c&lt;/var&gt; must either equal the number of vertices in &lt;var&gt;z&lt;/var&gt; or the number of triangles in &lt;var&gt;tri&lt;/var&gt;.</source>
          <target state="translated">선택적으로, 메쉬의 색상은 컬러 맵 데이터의 벡터 인 &lt;var&gt;c&lt;/var&gt; 또는 RGB 데이터에 대한 3 개의 열이있는 행렬을 제공 하여 &lt;var&gt;z&lt;/var&gt; 와 독립적으로 지정할 수 있습니다 . &lt;var&gt;c&lt;/var&gt; 에 지정된 색상 수는 &lt;var&gt;z&lt;/var&gt; 의 꼭짓점 수 또는 &lt;var&gt;tri&lt;/var&gt; 의 삼각형 수와 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="fe3d35c8f1fc42c8465b0503471c904431d5d2b5" translate="yes" xml:space="preserve">
          <source>Optionally, the color of the mesh can be specified independently of &lt;var&gt;z&lt;/var&gt; by supplying &lt;var&gt;c&lt;/var&gt;, which is a vector for colormap data, or a matrix with three columns for RGB data. The number of colors specified in &lt;var&gt;c&lt;/var&gt; must either equal the number of vertices in &lt;var&gt;z&lt;/var&gt; or the number of triangles in &lt;var&gt;tri&lt;/var&gt;. When specifying the color at each vertex the triangle will be colored according to the color of the first vertex only (see patch documentation and the &lt;code&gt;&quot;FaceColor&quot;&lt;/code&gt; property when set to &lt;code&gt;&quot;flat&quot;&lt;/code&gt;).</source>
          <target state="translated">선택적으로, 메쉬의 색상은 컬러 맵 데이터의 벡터 인 &lt;var&gt;c&lt;/var&gt; 또는 RGB 데이터에 대한 3 개의 열이있는 행렬을 제공 하여 &lt;var&gt;z&lt;/var&gt; 와 독립적으로 지정할 수 있습니다 . &lt;var&gt;c&lt;/var&gt; 에 지정된 색상 수는 &lt;var&gt;z&lt;/var&gt; 의 꼭짓점 수 또는 &lt;var&gt;tri&lt;/var&gt; 의 삼각형 수와 같아야합니다 . 각 꼭짓점에서 색상을 지정할 때 삼각형은 첫 번째 꼭짓점의 색상에만 따라 색상이 지정됩니다 ( &lt;code&gt;&quot;flat&quot;&lt;/code&gt; 으로 설정된 경우 패치 설명서 및 &lt;code&gt;&quot;FaceColor&quot;&lt;/code&gt; 속성 참조 ).</target>
        </trans-unit>
        <trans-unit id="4acd821b15ba3d025f877a6b8c8cb1148865df30" translate="yes" xml:space="preserve">
          <source>Optionally, the color of the mesh can be specified independently of &lt;var&gt;z&lt;/var&gt; by supplying a color matrix, &lt;var&gt;c&lt;/var&gt;.</source>
          <target state="translated">선택적으로, 메쉬의 색상은 색상 매트릭스 &lt;var&gt;c&lt;/var&gt; 를 제공하여 &lt;var&gt;z&lt;/var&gt; 와 독립적으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10f9ccb081c9765c7d605a93e7f6c77e5334e02f" translate="yes" xml:space="preserve">
          <source>Optionally, the color of the surface can be specified independently of &lt;var&gt;z&lt;/var&gt; by supplying a color matrix, &lt;var&gt;c&lt;/var&gt;.</source>
          <target state="translated">선택적으로, 표면의 색상은 컬러 매트릭스 &lt;var&gt;c&lt;/var&gt; 를 제공함으로써 &lt;var&gt;z&lt;/var&gt; 와 독립적으로 지정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20bd54ea5e0230e65d71ca416e32ca246cf769ce" translate="yes" xml:space="preserve">
          <source>Optionally, the reduced set of coordinates are returned in &lt;var&gt;nx&lt;/var&gt;, &lt;var&gt;ny&lt;/var&gt;, and &lt;var&gt;nz&lt;/var&gt;, respectively.</source>
          <target state="translated">선택적으로, 감소 된 좌표 세트는 각각 &lt;var&gt;nx&lt;/var&gt; , &lt;var&gt;ny&lt;/var&gt; 및 &lt;var&gt;nz&lt;/var&gt; 로 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="deaec9f68b4c086abc6f944c23480c3a5c401e7d" translate="yes" xml:space="preserve">
          <source>Options and pattern syntax are the same as for the &lt;code&gt;who&lt;/code&gt; command.</source>
          <target state="translated">옵션 및 패턴 구문은 &lt;code&gt;who&lt;/code&gt; 명령 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="3fdbd8aceb8bd40ff5c59471636fe949cd779eb3" translate="yes" xml:space="preserve">
          <source>Options for the search are provided in the parameter &lt;var&gt;options&lt;/var&gt; using the function &lt;code&gt;optimset&lt;/code&gt;. Currently, &lt;code&gt;fminsearch&lt;/code&gt; accepts the options: &lt;code&gt;&quot;Display&quot;&lt;/code&gt;, &lt;code&gt;&quot;FunValCheck&quot;&lt;/code&gt;,&lt;code&gt;&quot;MaxFunEvals&quot;&lt;/code&gt;, &lt;code&gt;&quot;MaxIter&quot;&lt;/code&gt;, &lt;code&gt;&quot;OutputFcn&quot;&lt;/code&gt;, &lt;code&gt;&quot;TolFun&quot;&lt;/code&gt;, &lt;code&gt;&quot;TolX&quot;&lt;/code&gt;.</source>
          <target state="translated">검색 옵션은 &lt;code&gt;optimset&lt;/code&gt; 함수를 사용하여 매개 변수 &lt;var&gt;options&lt;/var&gt; 제공됩니다 . 현재 &lt;code&gt;fminsearch&lt;/code&gt; 는 &lt;code&gt;&quot;Display&quot;&lt;/code&gt; , &lt;code&gt;&quot;FunValCheck&quot;&lt;/code&gt; , &lt;code&gt;&quot;MaxFunEvals&quot;&lt;/code&gt; , &lt;code&gt;&quot;MaxIter&quot;&lt;/code&gt; , &lt;code&gt;&quot;OutputFcn&quot;&lt;/code&gt; , &lt;code&gt;&quot;TolFun&quot;&lt;/code&gt; , &lt;code&gt;&quot;TolX&quot;&lt;/code&gt; 옵션을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="ff65cdcd025bd29560e5c935435f271d82c0a6cb" translate="yes" xml:space="preserve">
          <source>Options in addition to those of &lt;code&gt;regexp&lt;/code&gt; are</source>
          <target state="translated">&lt;code&gt;regexp&lt;/code&gt; 옵션 외에 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f7a77f3a34a3ef3bd0d6b90af1beb6494ec66170" translate="yes" xml:space="preserve">
          <source>Options include</source>
          <target state="translated">옵션은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="cd30ee32c21575c35be6bfd23c3a358912dd2fc5" translate="yes" xml:space="preserve">
          <source>Order of the polynomial plus 1.</source>
          <target state="translated">다항식의 차수에 1을 더한 값입니다.</target>
        </trans-unit>
        <trans-unit id="281ec1156c6ccadb921f2cf082077e844d3d5619" translate="yes" xml:space="preserve">
          <source>Ordinary Differential Equation (ODE) solver.</source>
          <target state="translated">정규 미분 방정식 (ODE) 솔버.</target>
        </trans-unit>
        <trans-unit id="65f83ada4b52d5238c857e47116cfeb3a275e9aa" translate="yes" xml:space="preserve">
          <source>Ordinary Differential Equations</source>
          <target state="translated">정규 미분 방정식</target>
        </trans-unit>
        <trans-unit id="799e46e9d0727965b0e10bbe0f8d6b93d0275abc" translate="yes" xml:space="preserve">
          <source>Ordinary characters in the template string are simply written to the output stream as-is, while &lt;em&gt;conversion specifications&lt;/em&gt; introduced by a &amp;lsquo;</source>
          <target state="translated">템플릿 문자열의 일반 문자는 그대로 출력 스트림에 기록됩니다. &lt;em&gt; 변환 사양&lt;/em&gt; 은 '</target>
        </trans-unit>
        <trans-unit id="4a82e30a71707bc866f480e5446b8e5aba4a31f1" translate="yes" xml:space="preserve">
          <source>Ordinary least squares (OLS) estimation.</source>
          <target state="translated">보통 최소 제곱 (OLS) 추정.</target>
        </trans-unit>
        <trans-unit id="9378ccb682fa93afb7ad931b0c494ed6e36db5fc" translate="yes" xml:space="preserve">
          <source>Organization of Functions Distributed with Octave</source>
          <target state="translated">옥타브와 함께 배포되는 기능 구성</target>
        </trans-unit>
        <trans-unit id="86e4e3875420cdee95d08d4472073493729a7aee" translate="yes" xml:space="preserve">
          <source>Orientation</source>
          <target state="translated">Orientation</target>
        </trans-unit>
        <trans-unit id="065b3e5abd7e188034b29e97efee02a039527bb2" translate="yes" xml:space="preserve">
          <source>Original author of the package.</source>
          <target state="translated">패키지의 최초 작성자.</target>
        </trans-unit>
        <trans-unit id="98ec88e8fd25454bdaff5cf51f3b73e55f3c6809" translate="yes" xml:space="preserve">
          <source>Orthogonal Collocation</source>
          <target state="translated">직교 배열</target>
        </trans-unit>
        <trans-unit id="04ac74d518c1ad2f5c98316a114407ac65060505" translate="yes" xml:space="preserve">
          <source>Orthogonalize a given column vector &lt;var&gt;x&lt;/var&gt; with respect to a set of orthonormal vectors comprising the columns of &lt;var&gt;v&lt;/var&gt; using the modified Gram-Schmidt method.</source>
          <target state="translated">수정 된 그람-슈미트 (Gram-Schmidt) 방법을 사용하여 &lt;var&gt;v&lt;/var&gt; 의 열을 포함하는 한 세트의 직교 정규 벡터에 대해 주어진 열 벡터 &lt;var&gt;x&lt;/var&gt; 를 직교 화한다 .</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="72e666054fba9ad235c49f3d557118d731e0b7cf" translate="yes" xml:space="preserve">
          <source>Other Output Conversions</source>
          <target state="translated">다른 출력 변환</target>
        </trans-unit>
        <trans-unit id="d1a9c24d467b017c5a27a8cf9012495e4ca9733d" translate="yes" xml:space="preserve">
          <source>Other characters in the template string that are not part of conversion specifications must match characters in the input stream exactly; if this is not the case, a matching failure occurs.</source>
          <target state="translated">변환 스펙의 일부가 아닌 템플리트 문자열의 다른 문자는 입력 스트림의 문자와 정확히 일치해야합니다. 그렇지 않은 경우 일치하는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cb1400f3ef22e71625b32389f111acd45ad6d2ea" translate="yes" xml:space="preserve">
          <source>Other dependencies</source>
          <target state="translated">다른 의존성</target>
        </trans-unit>
        <trans-unit id="9f4ecb2bd203be5438fd03386320ab8cc639bc02" translate="yes" xml:space="preserve">
          <source>Other elements (if any):</source>
          <target state="translated">다른 요소 (있는 경우) :</target>
        </trans-unit>
        <trans-unit id="e73063e31fc80948341f066823ba76fd05b9f3e5" translate="yes" xml:space="preserve">
          <source>Other events: &lt;code&gt;evt&lt;/code&gt; is a class &lt;code&gt;double&lt;/code&gt; empty matrix.</source>
          <target state="translated">다른 이벤트 : &lt;code&gt;evt&lt;/code&gt; 는 클래스 &lt;code&gt;double&lt;/code&gt; 빈 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="1bd50078c56aeee38a11d45a31872518a01f9484" translate="yes" xml:space="preserve">
          <source>Other file types are opened in the appropriate external application.</source>
          <target state="translated">다른 파일 형식은 적절한 외부 응용 프로그램에서 열립니다.</target>
        </trans-unit>
        <trans-unit id="e8b1895a77dc86fcc773b38735ac91cd66e42e47" translate="yes" xml:space="preserve">
          <source>Other functions in the mex interface for handling character strings are &lt;code&gt;mxCreateString&lt;/code&gt;, &lt;code&gt;mxArrayToString&lt;/code&gt;, and &lt;code&gt;mxCreateCharMatrixFromStrings&lt;/code&gt;. In a mex-file, a character string is considered to be a vector rather than a matrix. This is perhaps an arbitrary distinction as the data in the &lt;code&gt;mxArray&lt;/code&gt; for the matrix is consecutive in any case.</source>
          <target state="translated">문자열 처리를위한 mex 인터페이스의 다른 함수는 &lt;code&gt;mxCreateString&lt;/code&gt; , &lt;code&gt;mxArrayToString&lt;/code&gt; 및 &lt;code&gt;mxCreateCharMatrixFromStrings&lt;/code&gt; 입니다. mex 파일에서 문자열은 행렬이 아닌 벡터로 간주됩니다. 이것은 행렬 에 대한 &lt;code&gt;mxArray&lt;/code&gt; 의 데이터 가 어떤 경우에도 연속적 이므로 임의의 구별 입니다.</target>
        </trans-unit>
        <trans-unit id="f03951cbcf3fcb868d882b8a0b382401d118ca5c" translate="yes" xml:space="preserve">
          <source>Other functions of interest that directly create sparse matrices, are &lt;em&gt;diag&lt;/em&gt; or its generalization &lt;em&gt;spdiags&lt;/em&gt;, that can take the definition of the diagonals of the matrix and create the sparse matrix that corresponds to this. For example,</source>
          <target state="translated">희소 행렬을 직접 생성하는 다른 관심있는 함수는 &lt;em&gt;diag&lt;/em&gt; 또는 일반화 &lt;em&gt;spdiags로&lt;/em&gt; , 행렬의 대각선을 정의하고 이에 해당하는 희소 행렬을 생성 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ad7efd9d0cb4c2f985724c8f6787db3f9c6e67ca" translate="yes" xml:space="preserve">
          <source>Other functions that can create two-dimensional plots directly from a function include &lt;code&gt;ezplot&lt;/code&gt;, &lt;code&gt;ezcontour&lt;/code&gt;, &lt;code&gt;ezcontourf&lt;/code&gt; and &lt;code&gt;ezpolar&lt;/code&gt;.</source>
          <target state="translated">함수에서 직접 2 차원 플롯을 생성 할 수있는 다른 함수로는 &lt;code&gt;ezplot&lt;/code&gt; , &lt;code&gt;ezcontour&lt;/code&gt; , &lt;code&gt;ezcontourf&lt;/code&gt; 및 &lt;code&gt;ezpolar&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b0aaeb21f734705a2df1843476683e8226d79b1" translate="yes" xml:space="preserve">
          <source>Other functions that can manipulate the fields of a structure are given below.</source>
          <target state="translated">구조의 필드를 조작 할 수있는 다른 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cfc838f6de0a559fd35aa785e555f30effee9967" translate="yes" xml:space="preserve">
          <source>Other systems may require a different solution.</source>
          <target state="translated">다른 시스템에는 다른 솔루션이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c9f6a685f824bbc60bc424db941455d49a3da7a" translate="yes" xml:space="preserve">
          <source>Other techniques for speeding up code</source>
          <target state="translated">코드 속도를 높이기위한 다른 기술</target>
        </trans-unit>
        <trans-unit id="1bd7dd6e890e036fc3fc6246a21fce1ab496d6f4" translate="yes" xml:space="preserve">
          <source>Otherwise you can select the type of annotation and then set its position using either &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt; coordinates for line-based annotations or a position vector &lt;var&gt;pos&lt;/var&gt; for others. In either case, coordinates are interpreted using the &lt;code&gt;&quot;units&quot;&lt;/code&gt; property of the annotation object. The default is &lt;code&gt;&quot;normalized&quot;&lt;/code&gt;, which means the lower left hand corner of the figure has coordinates &amp;lsquo;</source>
          <target state="translated">그렇지 않으면 주석 유형을 선택한 다음 선 기반 주석의 경우 &lt;var&gt;x&lt;/var&gt; 및 &lt;var&gt;y&lt;/var&gt; 좌표를 사용하거나 다른 위치의 위치 벡터 &lt;var&gt;pos&lt;/var&gt; 를 사용하여 위치를 설정할 수 있습니다. 두 경우 모두 주석 개체 의 &lt;code&gt;&quot;units&quot;&lt;/code&gt; 속성을 사용하여 좌표를 해석 합니다. 기본값은 &lt;code&gt;&quot;normalized&quot;&lt;/code&gt; 입니다 . 이는 그림의 왼쪽 하단에 좌표가 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="dface01c8354d3052818c20d8359775424a28367" translate="yes" xml:space="preserve">
          <source>Otherwise, Octave buffers its output and waits until just before the prompt is printed to flush it to the pager.</source>
          <target state="translated">그렇지 않으면 Octave는 출력을 버퍼링하고 프롬프트가 인쇄되어 페이저로 플러시 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="057f4d46ac4a14ed754648663ad0a76553e5098e" translate="yes" xml:space="preserve">
          <source>Out-of-date functions which will eventually be removed from Octave.</source>
          <target state="translated">오래된 함수는 결국 Octave에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="d80c806bef95f4b75b8efdfe4c0dc12914d0bf1d" translate="yes" xml:space="preserve">
          <source>Output &lt;var&gt;p&lt;/var&gt; is a matrix of pair-wise p-values testing for the null hypothesis of a correlation coefficient of zero.</source>
          <target state="translated">출력 &lt;var&gt;p&lt;/var&gt; 는 상관 계수 0의 귀무 가설에 대한 쌍별 p- 값 테스트 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="a9c0b35dbe656d30a66928a0be6f739de926416c" translate="yes" xml:space="preserve">
          <source>Output &lt;var&gt;r&lt;/var&gt; is a matrix of Pearson&amp;rsquo;s product moment correlation coefficients for each pair of variables.</source>
          <target state="translated">출력 &lt;var&gt;r&lt;/var&gt; 은 각 변수 쌍에 대한 Pearson 곱 모멘트 상관 계수의 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="2095ef3b892ff0a571346681811aa238f4cf380b" translate="yes" xml:space="preserve">
          <source>Output Conversion Syntax</source>
          <target state="translated">출력 변환 구문</target>
        </trans-unit>
        <trans-unit id="3dccd4d60b52b95a8592398b979605dc104c35ce" translate="yes" xml:space="preserve">
          <source>Output Conversion for Matrices</source>
          <target state="translated">행렬의 출력 변환</target>
        </trans-unit>
        <trans-unit id="7d8b9e6861354a438f5f0db2c8330ef1f31fbacd" translate="yes" xml:space="preserve">
          <source>Output class and size will be the same as input.</source>
          <target state="translated">출력 클래스와 크기는 입력과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5242150095cdab7f1b2dcf7c67c382b108c1598a" translate="yes" xml:space="preserve">
          <source>Output delay, in seconds. This parameter specifies how long the solver should delay sending information about the solution to the standard output.</source>
          <target state="translated">출력 지연 (초) 이 매개 변수는 솔버가 솔루션에 대한 정보를 표준 출력으로 보내는 지연 시간을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="120c911dc5cf494cd09bee7c44f0b75f35d1a9b6" translate="yes" xml:space="preserve">
          <source>Output filename. Default extension is .oct (or .mex if &amp;lsquo;</source>
          <target state="translated">출력 파일 이름. 기본 확장자는 .oct (또는 '</target>
        </trans-unit>
        <trans-unit id="07dd07307cd8f12e4aeebf6817d2fb609ca3acb4" translate="yes" xml:space="preserve">
          <source>Output frequency, in iterations. This parameter specifies how frequently the solver sends information about the solution to the standard output.</source>
          <target state="translated">반복되는 출력 주파수. 이 매개 변수는 솔버가 솔루션에 대한 정보를 표준 출력으로 보내는 빈도를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e8fea362fb814625bff6a8b18b37d3c9330aa74a" translate="yes" xml:space="preserve">
          <source>Output that comes directly from Fortran functions is not sent through the pager and may appear out of sequence with other output that is sent through the pager. One way to avoid this is to force pending output to be flushed before calling a function that will produce output from within Fortran functions. To do this, use the command</source>
          <target state="translated">Fortran 기능에서 직접 출력은 호출기를 통해 전송되지 않으며 호출기를 통해 전송 된 다른 출력과 순서가 다르게 나타날 수 있습니다. 이를 방지하는 한 가지 방법은 포트란 함수 내에서 출력을 생성하는 함수를 호출하기 전에 보류중인 출력을 강제로 플러시하는 것입니다. 이렇게하려면 다음 명령을 사용하십시오</target>
        </trans-unit>
        <trans-unit id="273c07a2ddda725eb107641dd521d6490980283a" translate="yes" xml:space="preserve">
          <source>Output values:</source>
          <target state="translated">출력값 :</target>
        </trans-unit>
        <trans-unit id="bcf532e4ed9932529f2e31de7244bc65d89ee711" translate="yes" xml:space="preserve">
          <source>Output will be of class double unless &lt;var&gt;x&lt;/var&gt; is of class single, in which case the output will also be single.</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt; 가 단일 클래스 인 경우를 제외하고 출력은 클래스 두 배가 됩니다.이 경우 출력도 단일입니다.</target>
        </trans-unit>
        <trans-unit id="73ff9af9e2a015de3abdf0f6edca46911e696ce8" translate="yes" xml:space="preserve">
          <source>Output will be of class double.</source>
          <target state="translated">출력은 2 배입니다.</target>
        </trans-unit>
        <trans-unit id="e4dba4c41ac6b2563a0bab8ad283afdd060e2e0f" translate="yes" xml:space="preserve">
          <source>Output will be the same class as &lt;var&gt;x&lt;/var&gt; unless &lt;var&gt;x&lt;/var&gt; is of class logical in which case it returns of class double.</source>
          <target state="translated">&lt;var&gt;x&lt;/var&gt; 가 논리적 클래스 인 경우를 제외 하고 출력은 &lt;var&gt;x&lt;/var&gt; 와 동일한 클래스가 되며이 경우 클래스 double을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="24f10aadaa52f4e720b2e3344cc1381aaf95a0a9" translate="yes" xml:space="preserve">
          <source>OutputFcn</source>
          <target state="translated">OutputFcn</target>
        </trans-unit>
        <trans-unit id="d194a466682bec852b700cb306488f0f939a7f9b" translate="yes" xml:space="preserve">
          <source>Outputs (see Golub and Van Loan):</source>
          <target state="translated">출력 (Golub 및 Van Loan 참조) :</target>
        </trans-unit>
        <trans-unit id="5bf142bb2f446f857579d2924f23ea84dcb50575" translate="yes" xml:space="preserve">
          <source>Outputs &lt;var&gt;lci&lt;/var&gt; and &lt;var&gt;hci&lt;/var&gt; are matrices containing, respectively, the lower and higher bounds of the 95% confidence interval of each correlation coefficient.</source>
          <target state="translated">출력 &lt;var&gt;lci&lt;/var&gt; 및 &lt;var&gt;hci&lt;/var&gt; 는 각각의 상관 계수의 95 % 신뢰 구간의 하한 및 상한을 각각 포함하는 행렬이다.</target>
        </trans-unit>
        <trans-unit id="6ee76fa98a639a0ac269010b7032639b0a171647" translate="yes" xml:space="preserve">
          <source>Outputs:</source>
          <target state="translated">Outputs:</target>
        </trans-unit>
        <trans-unit id="d81a12cf1c1c198f4d88512d77d63440dc080f8f" translate="yes" xml:space="preserve">
          <source>Overflow, return &lt;code&gt;Inf&lt;/code&gt;.</source>
          <target state="translated">오버 플로우는 반환 &lt;code&gt;Inf&lt;/code&gt; 를을 .</target>
        </trans-unit>
        <trans-unit id="1b924bffa2a4b8e31aa222a3611f060b498221e8" translate="yes" xml:space="preserve">
          <source>Overloading Objects</source>
          <target state="translated">오버로드 객체</target>
        </trans-unit>
        <trans-unit id="f4611b92fd135eb050f7cf8b766c894275797460" translate="yes" xml:space="preserve">
          <source>Overloading and Autoloading</source>
          <target state="translated">과부하 및 자동 로딩</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="95d53785e6f7a71be22d70fb236ce4a3ac54b1a1" translate="yes" xml:space="preserve">
          <source>P = campos ()</source>
          <target state="translated">P = 캄포스 ()</target>
        </trans-unit>
        <trans-unit id="d822b2c97d3d0379aba40f5b98580fa4cbdae945" translate="yes" xml:space="preserve">
          <source>P = cart2pol (&amp;hellip;)</source>
          <target state="translated">P = cart2pol (&amp;hellip;)</target>
        </trans-unit>
        <trans-unit id="7013d89da66b60db58eca204074b06924558cbdc" translate="yes" xml:space="preserve">
          <source>PAGER</source>
          <target state="translated">PAGER</target>
        </trans-unit>
        <trans-unit id="6da178eab7d7236b3359af6e4e70cab5f2163e50" translate="yes" xml:space="preserve">
          <source>PAGER (new_val, &quot;local&quot;)</source>
          <target state="translated">PAGER (new_val, &quot;local&quot;)</target>
        </trans-unit>
        <trans-unit id="4f19b23f066d11502292f68caf7612c99f5cdfd9" translate="yes" xml:space="preserve">
          <source>PAGER_FLAGS</source>
          <target state="translated">PAGER_FLAGS</target>
        </trans-unit>
        <trans-unit id="f11fc3cd8b61ec1301b5cd1fad2cf932847ad6fd" translate="yes" xml:space="preserve">
          <source>PAGER_FLAGS (new_val, &quot;local&quot;)</source>
          <target state="translated">PAGER_FLAGS (new_val, &quot;local&quot;)</target>
        </trans-unit>
        <trans-unit id="b16905a41ac6e888a70144b3cc10eb3a64381bf4" translate="yes" xml:space="preserve">
          <source>PBMplus</source>
          <target state="translated">PBMplus</target>
        </trans-unit>
        <trans-unit id="a6c1bf1f4b3ef9fd2aa5aee8cbaab8d2ebabc0cd" translate="yes" xml:space="preserve">
          <source>PCRE</source>
          <target state="translated">PCRE</target>
        </trans-unit>
        <trans-unit id="d613d88cb2d86f484f6f82d44ac1fc60722abe20" translate="yes" xml:space="preserve">
          <source>PDF</source>
          <target state="translated">PDF</target>
        </trans-unit>
        <trans-unit id="e64b5c379fae19a7692e572e5be6989575f87188" translate="yes" xml:space="preserve">
          <source>PKG_ADD</source>
          <target state="translated">PKG_ADD</target>
        </trans-unit>
        <trans-unit id="e6a67088e638f4e7e9f0d682570147c6a9f473d8" translate="yes" xml:space="preserve">
          <source>PKG_ADD and PKG_DEL Directives</source>
          <target state="translated">PKG_ADD 및 PKG_DEL 지시어</target>
        </trans-unit>
        <trans-unit id="d69c6859d12bde7538d9f66dfedd0d3cb89b3447" translate="yes" xml:space="preserve">
          <source>PKG_DEL</source>
          <target state="translated">PKG_DEL</target>
        </trans-unit>
        <trans-unit id="0c95dc6163ff0d09e82f44e7c50db7ad6b089bf3" translate="yes" xml:space="preserve">
          <source>PM</source>
          <target state="translated">PM</target>
        </trans-unit>
        <trans-unit id="ef16a101e58c0497f51ba0262586e1cd267c25c7" translate="yes" xml:space="preserve">
          <source>POSDEF</source>
          <target state="translated">POSDEF</target>
        </trans-unit>
        <trans-unit id="1742f5d553c9486f0066268c92d9d826ca42c2ec" translate="yes" xml:space="preserve">
          <source>PROJECTS</source>
          <target state="translated">PROJECTS</target>
        </trans-unit>
        <trans-unit id="bea1acbf4638d6493b1a6d117690fc3e80d92c39" translate="yes" xml:space="preserve">
          <source>PS1</source>
          <target state="translated">PS1</target>
        </trans-unit>
        <trans-unit id="0d0d733c63131e26521c87e34a4c7c7e58ec4102" translate="yes" xml:space="preserve">
          <source>PS1 (new_val, &quot;local&quot;)</source>
          <target state="translated">PS1 (new_val, &quot;local&quot;)</target>
        </trans-unit>
        <trans-unit id="6c36a3937cd34e1cc700738b4a3722e6fe8cc7da" translate="yes" xml:space="preserve">
          <source>PS2</source>
          <target state="translated">PS2</target>
        </trans-unit>
        <trans-unit id="357e45f212c1c222a80f41df224f1df36a24f476" translate="yes" xml:space="preserve">
          <source>PS2 (new_val, &quot;local&quot;)</source>
          <target state="translated">PS2 (new_val, &quot;local&quot;)</target>
        </trans-unit>
        <trans-unit id="19bb016b89021c10df6bd858a1255a4cae9181cb" translate="yes" xml:space="preserve">
          <source>PS4</source>
          <target state="translated">PS4</target>
        </trans-unit>
        <trans-unit id="be0311ceeb068b8964968afabcb1d8619ad702e2" translate="yes" xml:space="preserve">
          <source>PS4 (new_val, &quot;local&quot;)</source>
          <target state="translated">PS4 (new_val, &quot;local&quot;)</target>
        </trans-unit>
        <trans-unit id="511b9575d5cf67793c535d5d39acaf7b8a5b467c" translate="yes" xml:space="preserve">
          <source>P_tmpdir</source>
          <target state="translated">P_tmpdir</target>
        </trans-unit>
        <trans-unit id="3c27fc4f3f7dd8ed685661dac90215f1c03bcf99" translate="yes" xml:space="preserve">
          <source>P_tmpdir ()</source>
          <target state="translated">P_tmpdir ()</target>
        </trans-unit>
        <trans-unit id="06f1be165f8e6d87025c580e3195f7b9cca8a30a" translate="yes" xml:space="preserve">
          <source>Pack the list of files and directories specified in &lt;var&gt;files&lt;/var&gt; into the TAR archive &lt;var&gt;tarfile&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;files&lt;/var&gt; 에 지정된 파일 및 디렉토리 목록을 TAR 아카이브 &lt;var&gt;tarfile&lt;/var&gt; 에 압축하십시오 .</target>
        </trans-unit>
        <trans-unit id="a32e79a64de6c70a1930573c40e28cd460f172bc" translate="yes" xml:space="preserve">
          <source>Package for Makefile generation (&lt;a href=&quot;https://www.gnu.org/software/automake&quot;&gt;https://www.gnu.org/software/automake&lt;/a&gt;). Automake is required if you modify Octave&amp;rsquo;s &lt;code&gt;Makefile.am&lt;/code&gt; files or other files that they depend on.</source>
          <target state="translated">Makefile 생성 용 패키지 ( &lt;a href=&quot;https://www.gnu.org/software/automake&quot;&gt;https://www.gnu.org/software/automake&lt;/a&gt; ) Octave의 &lt;code&gt;Makefile.am&lt;/code&gt; 파일 또는 파일이 의존하는 다른 파일을 수정하는 경우 자동 작성이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="702b45d9fdc3d391d1b978c11f96a492507cae4c" translate="yes" xml:space="preserve">
          <source>Package for building software libraries (&lt;a href=&quot;https://www.gnu.org/software/libtool&quot;&gt;https://www.gnu.org/software/libtool&lt;/a&gt;). Libtool is required by Automake.</source>
          <target state="translated">소프트웨어 라이브러리 구축을위한 패키지 ( &lt;a href=&quot;https://www.gnu.org/software/libtool&quot;&gt;https://www.gnu.org/software/libtool&lt;/a&gt; ) Libtool은 Automake에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="81daea90262d060c6fe3836ec59f609c079c7c76" translate="yes" xml:space="preserve">
          <source>Package for generating online and print documentation (&lt;a href=&quot;https://www.gnu.org/software/texinfo&quot;&gt;https://www.gnu.org/software/texinfo&lt;/a&gt;). You will need Texinfo to build Octave&amp;rsquo;s documentation or if you modify the documentation source files or the docstring of any Octave function.</source>
          <target state="translated">온라인 및 인쇄 설명서 생성 패키지 ( &lt;a href=&quot;https://www.gnu.org/software/texinfo&quot;&gt;https://www.gnu.org/software/texinfo&lt;/a&gt; ) Octave의 문서를 작성하거나 문서 소스 파일 또는 Octave 함수의 docstring을 수정하려면 Texinfo가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7789bca9b1552814ae49d43d379e79d903922c99" translate="yes" xml:space="preserve">
          <source>Package for software configuration (&lt;a href=&quot;https://www.gnu.org/software/autoconf&quot;&gt;https://www.gnu.org/software/autoconf&lt;/a&gt;). Autoconf is required if you modify Octave&amp;rsquo;s &lt;code&gt;configure.ac&lt;/code&gt; file or other files that it requires.</source>
          <target state="translated">소프트웨어 구성 패키지 ( &lt;a href=&quot;https://www.gnu.org/software/autoconf&quot;&gt;https://www.gnu.org/software/autoconf&lt;/a&gt; ) Octave의 &lt;code&gt;configure.ac&lt;/code&gt; 파일 또는 기타 필요한 파일을 수정하는 경우 Autoconf가 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="c689064e225ed6d9d35a69735a7d975f505335e7" translate="yes" xml:space="preserve">
          <source>Package for the containers classes.</source>
          <target state="translated">컨테이너 클래스 용 패키지</target>
        </trans-unit>
        <trans-unit id="4dc72b11e75daa2876feee4e4803128f61f63cd0" translate="yes" xml:space="preserve">
          <source>Package manager for installing external packages of functions in Octave.</source>
          <target state="translated">Octave에 외부 기능 패키지를 설치하기위한 패키지 관리자.</target>
        </trans-unit>
        <trans-unit id="b4fd3a510593d27795cd6ac06dbb5de83821371f" translate="yes" xml:space="preserve">
          <source>Package name.</source>
          <target state="translated">패키지 이름.</target>
        </trans-unit>
        <trans-unit id="0a999012ffb87b3edac99adbdfc498b12831a1e2" translate="yes" xml:space="preserve">
          <source>Packages</source>
          <target state="translated">Packages</target>
        </trans-unit>
        <trans-unit id="d5084b10b81403837b20413ab7b1cde8e46546c6" translate="yes" xml:space="preserve">
          <source>Pad the field with spaces.</source>
          <target state="translated">필드를 공백으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="0f02891eac7a4ce3172d8083ac92a369b4277091" translate="yes" xml:space="preserve">
          <source>Pad the field with zeros instead of spaces. The zeros are placed after any indication of sign or base. This flag is ignored if the &amp;lsquo;</source>
          <target state="translated">공백 대신 0으로 필드를 채 웁니다. 부호 또는 밑줄이 표시된 후 0이 배치됩니다. 이 플래그는 '</target>
        </trans-unit>
        <trans-unit id="41469e9ddada5476d1a4cc5a91f168e9db620793" translate="yes" xml:space="preserve">
          <source>Pad the field with zeros instead of spaces; the zeros are placed after any sign. This flag is ignored if the &amp;lsquo;</source>
          <target state="translated">공백 대신 0으로 필드를 채우십시오. 0은 부호 뒤에 놓입니다. 이 플래그는 '</target>
        </trans-unit>
        <trans-unit id="9c7ddadf79ea7d35a514f5c55e9836ca3b36ce10" translate="yes" xml:space="preserve">
          <source>Paging Screen Output</source>
          <target state="translated">페이징 화면 출력</target>
        </trans-unit>
        <trans-unit id="641d649570dc441124490269c1fa511402d7a1ab" translate="yes" xml:space="preserve">
          <source>Parse and evaluate the string &lt;var&gt;try&lt;/var&gt; as if it were an Octave program, while capturing the output into the return variable &lt;var&gt;s&lt;/var&gt;.</source>
          <target state="translated">문자열을 구문 분석하고 평가하여 출력을 리턴 변수 &lt;var&gt;s&lt;/var&gt; 로 캡처하는 동안 Octave 프로그램 인 것처럼 &lt;var&gt;try&lt;/var&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9cfd01ac624c8c656401f5222cdc35d5759e007" translate="yes" xml:space="preserve">
          <source>Parse and execute the contents of &lt;var&gt;file&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;file&lt;/var&gt; 의 내용을 분석하고 실행 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f71921f7b7aabc849d3234b96ec45b94b5bac6d" translate="yes" xml:space="preserve">
          <source>Parse the line specification &lt;var&gt;style&lt;/var&gt; and return the line style, color, and markers given.</source>
          <target state="translated">선 지정 &lt;var&gt;style&lt;/var&gt; 구문 분석하고 제공된 선 스타일, 색상 및 마커를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="99e8d59cc3df8b430d50608f8ed6c845016b6ed0" translate="yes" xml:space="preserve">
          <source>Parse the string &lt;var&gt;try&lt;/var&gt; and evaluate it as if it were an Octave program.</source>
          <target state="translated">문자열 구문 분석 &lt;var&gt;try&lt;/var&gt; 하고 옥타브 프로그램 인 것처럼 평가.</target>
        </trans-unit>
        <trans-unit id="eab7ef163b5139d15b38bc24d50243ab27038233" translate="yes" xml:space="preserve">
          <source>Parsed word corresponding to the first specifier are returned in the first output argument and likewise for the rest of the specifiers.</source>
          <target state="translated">첫 번째 지정자에 해당하는 구문 분석 된 단어가 첫 번째 출력 인수에 리턴되며 나머지 지정자에도 마찬가지로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3a2c58b7d85f02aecb129b8d0afb6890bf48d9a6" translate="yes" xml:space="preserve">
          <source>Parsed words corresponding to the first specifier are returned in the first output argument and likewise for the rest of the specifiers.</source>
          <target state="translated">첫 번째 지정자에 해당하는 구문 분석 된 단어는 첫 번째 출력 인수에 리턴되며 나머지 지정자에도 마찬가지로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1b3cf5033ed01a4fcbff3f2957e66cfe44af45a9" translate="yes" xml:space="preserve">
          <source>Parser</source>
          <target state="translated">Parser</target>
        </trans-unit>
        <trans-unit id="2d0793bf078fc43ffdc40c790ce05957c3399723" translate="yes" xml:space="preserve">
          <source>Parser generator (&lt;a href=&quot;https://www.gnu.org/software/bison&quot;&gt;https://www.gnu.org/software/bison&lt;/a&gt;). You will need Bison if you modify the &lt;code&gt;oct-parse.yy&lt;/code&gt; source file or if you delete the files that are generated from it.</source>
          <target state="translated">파서 생성기 ( &lt;a href=&quot;https://www.gnu.org/software/bison&quot;&gt;https://www.gnu.org/software/bison&lt;/a&gt; ). &lt;code&gt;oct-parse.yy&lt;/code&gt; 소스 파일 을 수정 하거나 소스 파일에서 생성 된 파일을 삭제하는 경우 Bison이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="66717bde0183029e61bff0318f9f7d6bb688af4c" translate="yes" xml:space="preserve">
          <source>Partial Pivoting in the Computation of Krylov Subspaces of Large Sparse Systems</source>
          <target state="translated">대형 스파 스 시스템의 Krylov 하위 공간 계산에서 부분 피벗</target>
        </trans-unit>
        <trans-unit id="72bfb44673c3dfc8a748dc1d1fe83bbd72cbb265" translate="yes" xml:space="preserve">
          <source>Partial movement of data may still occur, but in general the assignment will be more memory and time efficient under these circumstances. In particular, it is possible to efficiently build a pre-allocated sparse matrix from a contiguous block of columns.</source>
          <target state="translated">데이터의 일부 이동은 여전히 ​​발생할 수 있지만 일반적으로 이러한 상황에서는 할당이 더 많은 메모리와 시간 효율적입니다. 특히, 연속적인 열 블록으로부터 미리 할당 된 희소 행렬을 효율적으로 구축 할 수있다.</target>
        </trans-unit>
        <trans-unit id="b4bba057e022a1753c81797cc2b0e51629d94446" translate="yes" xml:space="preserve">
          <source>Particular output arguments, or the order of the output arguments, can be selected by additional &lt;var&gt;opt&lt;/var&gt; arguments. These are strings and the correspondence between the output arguments and the optional argument are</source>
          <target state="translated">특히 출력 인수 또는 출력 인수의 순서는, 추가로 선택할 수 있습니다 &lt;var&gt;opt&lt;/var&gt; 인수. 이들은 문자열이며 출력 인수와 선택적 인수 사이의 대응 관계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1cfcb6d506ce6f13c4ffd4af20ec6c27834af87d" translate="yes" xml:space="preserve">
          <source>Parts of &lt;var&gt;str&lt;/var&gt; are considered comments and will be skipped. &lt;var&gt;value&lt;/var&gt; is the comment style and can be any of the following.</source>
          <target state="translated">&lt;var&gt;str&lt;/var&gt; 의 일부는 주석으로 간주되며 건너 뜁니다. &lt;var&gt;value&lt;/var&gt; 는 주석 스타일이며 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73215612b19fc4f23fec7f26a504ec634cb7234d" translate="yes" xml:space="preserve">
          <source>Pass options to the assembler like &quot;-Wa,OPTION&quot;.</source>
          <target state="translated">&quot;-Wa, OPTION&quot;과 같은 옵션을 어셈블러에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="6559bc9561e90927ad694c746c3ebcde8d6229bd" translate="yes" xml:space="preserve">
          <source>Pass options to the linker like &quot;-Wl,-rpath=&amp;hellip;&quot;. The quotes are needed since commas are interpreted as command separators.</source>
          <target state="translated">&quot;-Wl, -rpath =&amp;hellip;&quot;와 같은 옵션을 링커에 전달하십시오. 쉼표는 명령 구분 기호로 해석되므로 따옴표가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="23598d0324587c28dfef1bb6887694660d549be5" translate="yes" xml:space="preserve">
          <source>Pass the following options to &lt;code&gt;make&lt;/code&gt; to enable 64-bit integers for &lt;small&gt;BLAS&lt;/small&gt; library calls. On 64-bit Windows systems, use &lt;code&gt;-DLONGBLAS=&quot;long long&quot;&lt;/code&gt; instead.</source>
          <target state="translated">다음 옵션에 전달할 &lt;code&gt;make&lt;/code&gt; 64 비트 정수 수 있도록 &lt;small&gt;BLAS의&lt;/small&gt; 라이브러리 호출을. 64 비트 Windows 시스템에서는 대신 &lt;code&gt;-DLONGBLAS=&quot;long long&quot;&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="88a1bcf1b9f837754ff3c88e7968d3849a88ae78" translate="yes" xml:space="preserve">
          <source>Passing a global variable in a function parameter list will make a local copy and not modify the global value. For example, given the function</source>
          <target state="translated">함수 매개 변수 목록에서 전역 변수를 전달하면 로컬 사본이 만들어지고 전역 값이 수정되지 않습니다. 예를 들어, 함수가 주어지면</target>
        </trans-unit>
        <trans-unit id="db303556b7d0922868cb9e70c396e2ad40ccc2fc" translate="yes" xml:space="preserve">
          <source>Password Database Functions</source>
          <target state="translated">비밀번호 데이터베이스 기능</target>
        </trans-unit>
        <trans-unit id="72e1342fad3b69ad7ce1ab46622dd811b6ebbd2c" translate="yes" xml:space="preserve">
          <source>Patch Properties</source>
          <target state="translated">패치 속성</target>
        </trans-unit>
        <trans-unit id="fe93f68eb9936e3bddc21cbead5fe2981ab489d4" translate="yes" xml:space="preserve">
          <source>Pause recording with audiorecorder object &lt;var&gt;recorder&lt;/var&gt;.</source>
          <target state="translated">오디오 &lt;var&gt;recorder&lt;/var&gt; 개체 레코더로 녹음을 일시 중지합니다 .</target>
        </trans-unit>
        <trans-unit id="1135ebe5e4bad209ab1280dc95b79102860a7c41" translate="yes" xml:space="preserve">
          <source>Pause the audioplayer &lt;var&gt;player&lt;/var&gt;.</source>
          <target state="translated">오디오 &lt;var&gt;player&lt;/var&gt; 일시 중지합니다 .</target>
        </trans-unit>
        <trans-unit id="55498f973f3202b12fdb97f1545c46a104ca0888" translate="yes" xml:space="preserve">
          <source>Perfect hash function generator (&lt;a href=&quot;https://www.gnu.org/software/gperf&quot;&gt;https://www.gnu.org/software/gperf&lt;/a&gt;). You will need gperf if you modify the &lt;code&gt;octave.gperf&lt;/code&gt; file or if you delete the file that is generated from it.</source>
          <target state="translated">완벽한 해시 함수 생성기 ( &lt;a href=&quot;https://www.gnu.org/software/gperf&quot;&gt;https://www.gnu.org/software/gperf&lt;/a&gt; ). &lt;code&gt;octave.gperf&lt;/code&gt; 파일 을 수정 하거나이 파일에서 생성 된 파일을 삭제하는 경우 gperf가 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="3e499c41153cd425720f088027a7cf759cd73cac" translate="yes" xml:space="preserve">
          <source>Perform &lt;var&gt;n&lt;/var&gt;-dimensional interpolation, where &lt;var&gt;n&lt;/var&gt; is at least two.</source>
          <target state="translated">&lt;var&gt;n&lt;/var&gt; 차원 보간을 수행합니다 . 여기서 &lt;var&gt;n&lt;/var&gt; 은 2 이상입니다.</target>
        </trans-unit>
        <trans-unit id="56d7543d10034ea06fb00a45cc3eac8578f7ea9b" translate="yes" xml:space="preserve">
          <source>Perform a Dulmage-Mendelsohn permutation of the sparse matrix &lt;var&gt;S&lt;/var&gt;.</source>
          <target state="translated">희소 행렬 &lt;var&gt;S&lt;/var&gt; 의 Dulmage-Mendelsohn 순열을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="93e987cf7a3c9b114de165427f53ff67f919529a" translate="yes" xml:space="preserve">
          <source>Perform a generalized least squares estimation for the multivariate model &lt;em&gt;&lt;var&gt;y&lt;/var&gt; = &lt;var&gt;x&lt;/var&gt;*&lt;var&gt;B&lt;/var&gt; + &lt;var&gt;E&lt;/var&gt;&lt;/em&gt; where &lt;var&gt;y&lt;/var&gt; is a &lt;em&gt;t&lt;/em&gt;-by-&lt;em&gt;p&lt;/em&gt; matrix, &lt;var&gt;x&lt;/var&gt; is a &lt;em&gt;t&lt;/em&gt;-by-&lt;em&gt;k&lt;/em&gt; matrix, &lt;var&gt;b&lt;/var&gt; is a &lt;em&gt;k&lt;/em&gt;-by-&lt;em&gt;p&lt;/em&gt; matrix and &lt;var&gt;e&lt;/var&gt; is a &lt;em&gt;t&lt;/em&gt;-by-&lt;em&gt;p&lt;/em&gt; matrix.</source>
          <target state="translated">다변량 모델 &lt;em&gt; &lt;var&gt;y&lt;/var&gt; = &lt;var&gt;x&lt;/var&gt; * &lt;var&gt;B&lt;/var&gt; + &lt;var&gt;E&lt;/var&gt; 에&lt;/em&gt; 대해 일반화 된 최소 제곱 추정을 수행합니다. 여기서 &lt;var&gt;y&lt;/var&gt; 는 &lt;em&gt;t&lt;/em&gt; x &lt;em&gt;p&lt;/em&gt; 행렬, &lt;var&gt;x&lt;/var&gt; 는 &lt;em&gt;t&lt;/em&gt; x &lt;em&gt;k&lt;/em&gt; 행렬, &lt;var&gt;b&lt;/var&gt; 는 &lt;em&gt;k&lt;/em&gt; x &lt;em&gt;p&lt;/em&gt; 행렬이고 &lt;var&gt;e&lt;/var&gt; 는 &lt;em&gt;t&lt;/em&gt; -by- &lt;em&gt;P의&lt;/em&gt; 매트릭스.</target>
        </trans-unit>
        <trans-unit id="9afa59a272bb3f7c3387108f9033f924791595f4" translate="yes" xml:space="preserve">
          <source>Perform a shift of the vector &lt;var&gt;x&lt;/var&gt;, for use with the &lt;code&gt;fft&lt;/code&gt; and &lt;code&gt;ifft&lt;/code&gt; functions, in order to move the frequency 0 to the center of the vector or matrix.</source>
          <target state="translated">주파수 0을 벡터 또는 행렬의 중심으로 이동하려면 &lt;code&gt;fft&lt;/code&gt; 및 &lt;code&gt;ifft&lt;/code&gt; 함수 와 함께 사용하기 위해 벡터 &lt;var&gt;x&lt;/var&gt; 이동을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="36ead6c8531287959234a2ac02013d6c743465a4" translate="yes" xml:space="preserve">
          <source>Perform a symbolic factorization analysis of the sparse matrix &lt;var&gt;S&lt;/var&gt;.</source>
          <target state="translated">희소 행렬 &lt;var&gt;S&lt;/var&gt; 의 상징적 인수 분해 분석을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="cdec05c05388d6562019752700eb3dc9645117b6" translate="yes" xml:space="preserve">
          <source>Perform built-in self-tests from the first file in the loadpath matching &lt;var&gt;name&lt;/var&gt;.</source>
          <target state="translated">loadpath matching &lt;var&gt;name&lt;/var&gt; 의 첫 번째 파일에서 내장 자체 테스트를 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="79230485fa240e56e2023f6deff427b25ff10056" translate="yes" xml:space="preserve">
          <source>Perform indexing of matrices in a cell array.</source>
          <target state="translated">셀형 배열에서 행렬 인덱싱을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9ac3d471c3190ed3a84fee708ff6af346cad48d4" translate="yes" xml:space="preserve">
          <source>Perform one step of the Durbin-Levinson algorithm.</source>
          <target state="translated">Durbin-Levinson 알고리즘의 한 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="46d636faf0bfb7ba3e46fb6a8aff3db2f4d21a36" translate="yes" xml:space="preserve">
          <source>Perform the subscripted assignment operation according to the subscript specified by &lt;var&gt;idx&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;idx&lt;/var&gt; 로 지정된 첨자에 따라 첨자 할당 작업을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="32cda6d112b25a5de8d56cafd5cdb81cf5c00474" translate="yes" xml:space="preserve">
          <source>Perform the subscripted element selection operation on &lt;var&gt;val&lt;/var&gt; according to the subscript specified by &lt;var&gt;idx&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;idx&lt;/var&gt; 로 지정된 첨자에 따라 &lt;var&gt;val&lt;/var&gt; 에서 첨자 요소 선택 조작을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="8171f3ec60a13989a1980c1195a73f9714984d5d" translate="yes" xml:space="preserve">
          <source>Perform tilde expansion on &lt;var&gt;string&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;string&lt;/var&gt; 에 물결표 확장을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="d05cca67a80fadcca4bd8ff96a0aa4760ef04c06" translate="yes" xml:space="preserve">
          <source>Performance should generally &lt;strong&gt;not&lt;/strong&gt; be a reason for using compiled extensions. Although compiled extensions can run faster, particularly if they replace a loop in Octave code, this is almost never the best path to take. First, there are many techniques to speed up Octave performance while remaining within the language. Second, Octave is a high-level language that makes it easy to perform common mathematical tasks. Giving that up means shifting the focus from solving the real problem to solving a computer programming problem. It means returning to low-level constructs such as pointers, memory management, mathematical overflow/underflow, etc. Because of the low level nature, and the fact that the compiled code is executed outside of Octave, there is the very real possibility of crashing the interpreter and losing work.</source>
          <target state="translated">성능은 일반적으로해야 &lt;strong&gt;하지&lt;/strong&gt;컴파일 된 확장을 사용하는 이유입니다. 컴파일 된 확장은 옥타브 코드에서 루프를 대체 할 경우 더 빠르게 실행될 수 있지만, 이것이 가장 좋은 방법은 아닙니다. 첫째, 언어 내에서 옥타브 성능을 향상시키는 많은 기술이 있습니다. 둘째, Octave는 일반적인 수학 작업을 쉽게 수행 할 수있는 고급 언어입니다. 그것을 포기한다는 것은 실제 문제 해결에서 컴퓨터 프로그래밍 문제 해결로 초점을 이동시키는 것을 의미합니다. 이는 포인터, 메모리 관리, 수학적 오버플로 / 언더 플로 등과 같은 낮은 수준의 구성으로 되돌아가는 것을 의미합니다. 낮은 수준의 특성으로 인해 컴파일 된 코드가 Octave 외부에서 실행되므로 실제로 충돌 할 가능성이 있습니다. 통역사와 잃어버린 일.</target>
        </trans-unit>
        <trans-unit id="03529f9e15319610ff504c9ffa1c12861a485955" translate="yes" xml:space="preserve">
          <source>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</source>
          <target state="translated">파생 결과물 전체가 본 문서와 동일한 사용권 고지 조건에 따라 배포되는 경우 완전 복사 조건에서이 매뉴얼의 수정 된 버전을 복사 및 배포 할 수있는 권한이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="34257256c997b69b94581785e289e8ff5b515396" translate="yes" xml:space="preserve">
          <source>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.</source>
          <target state="translated">파생 결과물 전체가 본 문서와 동일한 사용권 고지 조건에 따라 배포되는 경우 그대로 복사하는 조건 하에서이 매뉴얼의 수정 된 버전을 복사 및 배포 할 수있는 권한이 부여됩니다. 수정 된 버전에 대해 위의 조건에서 다른 언어로 수동으로.</target>
        </trans-unit>
        <trans-unit id="310f4800f7688099c746de38ac2379c33972bafc" translate="yes" xml:space="preserve">
          <source>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.</source>
          <target state="translated">위의 수정 된 버전 조건에서이 설명서의 번역을 다른 언어로 복사 및 배포 할 수있는 권한이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="b55058bf8c1756bd73c8b193920b58712830dc7d" translate="yes" xml:space="preserve">
          <source>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.</source>
          <target state="translated">저작권 표시 및이 사용권 고지가 모든 사본에 보존 된 경우이 설명서의 완전 사본을 작성 및 배포 할 수있는 권한이 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="c1f42044ed749346efaab249e690a71c532f7bf7" translate="yes" xml:space="preserve">
          <source>Permutation Matrix Functions</source>
          <target state="translated">순열 행렬 함수</target>
        </trans-unit>
        <trans-unit id="95e18cf3db13744cf859f11017aa32e2ac010991" translate="yes" xml:space="preserve">
          <source>Permute only; do not scale.</source>
          <target state="translated">퍼 뮤트 만; 확장하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4244e0ed3284a75347a53933cde65606169b0893" translate="yes" xml:space="preserve">
          <source>Permuted Diagonal matrix. The permutation does not need to be specifically indicated, as the structure of the matrix explicitly gives this. (Sparse matrices only)</source>
          <target state="translated">순열 된 대각선 행렬. 행렬의 구조가 명시 적으로 제공하므로 치환을 구체적으로 표시 할 필요는 없습니다. (희소 행렬 만)</target>
        </trans-unit>
        <trans-unit id="7151ba3741649b13ae8a02c24966300578290565" translate="yes" xml:space="preserve">
          <source>Persistent Variables</source>
          <target state="translated">영구 변수</target>
        </trans-unit>
        <trans-unit id="603a6125a71127ab0aa7165dbdef70a21f38e624" translate="yes" xml:space="preserve">
          <source>Persistent variable.</source>
          <target state="translated">영구 변수.</target>
        </trans-unit>
        <trans-unit id="3b5a153c3b8b965960d620577a6151e26e4a5173" translate="yes" xml:space="preserve">
          <source>Piecewise cubic Hermite interpolating polynomial&amp;mdash;shape-preserving interpolation with smooth first derivative (not implemented yet).</source>
          <target state="translated">다항식 보간법 &amp;ndash; 부드러운 1 차 도함수 (아직 구현되지 않음)를 사용한 형태 보존 보간법.</target>
        </trans-unit>
        <trans-unit id="25634d740e45dcf573c54b522b336a6d2ab5fbed" translate="yes" xml:space="preserve">
          <source>Piecewise cubic Hermite interpolating polynomial&amp;mdash;shape-preserving interpolation with smooth first derivative.</source>
          <target state="translated">다항식 보간법 &amp;ndash; 부드러운 1 차 도함수를 사용한 형태 보존 보간법.</target>
        </trans-unit>
        <trans-unit id="ca1a3897532276a35f01f88a92d364ce0c5c83a9" translate="yes" xml:space="preserve">
          <source>Pivot threshold for factorization. It can range between 0 (diagonal pivoting) and 1 (default), where the maximum magnitude entry in the column is chosen to be the pivot.</source>
          <target state="translated">인수 분해를위한 피벗 임계 값입니다. 범위는 0 (대각선 피벗)과 1 (기본값) 사이이며, 열의 최대 크기 항목이 피벗으로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="c0cf541e51b3d8238fa503289b2de8a778773fb7" translate="yes" xml:space="preserve">
          <source>Place label text to the left of the keys</source>
          <target state="translated">키 왼쪽에 레이블 텍스트 배치</target>
        </trans-unit>
        <trans-unit id="ee83118fd3fd550afa0baae6b9579c437eb38123" translate="yes" xml:space="preserve">
          <source>Place label text to the right of the keys (default)</source>
          <target state="translated">라벨 텍스트를 키 오른쪽에 배치 (기본값)</target>
        </trans-unit>
        <trans-unit id="f83433c61faffdf13358d5b8f06d287100ad05a9" translate="yes" xml:space="preserve">
          <source>Place text on the current figure using the mouse.</source>
          <target state="translated">마우스를 사용하여 현재 그림에 텍스트를 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="932026005fe86f8c595f8001e3a31d05ba88c996" translate="yes" xml:space="preserve">
          <source>Place the colorbar above the plot.</source>
          <target state="translated">플롯 위에 컬러 바를 놓습니다.</target>
        </trans-unit>
        <trans-unit id="8aadb4e7c270e710e01d3a3fd8ba10e17aafc96f" translate="yes" xml:space="preserve">
          <source>Place the colorbar at the bottom of the plot.</source>
          <target state="translated">플롯의 맨 아래에 컬러 바를 배치하십시오.</target>
        </trans-unit>
        <trans-unit id="a7c8731601b3feb048422261042e725d3f8a65e6" translate="yes" xml:space="preserve">
          <source>Place the colorbar at the top of the plot.</source>
          <target state="translated">플롯 상단에 컬러 바를 놓습니다.</target>
        </trans-unit>
        <trans-unit id="0e575556e226a4234afedb504cab374d1380a121" translate="yes" xml:space="preserve">
          <source>Place the colorbar inside the plot to the left.</source>
          <target state="translated">플롯 안에 색상 막대를 왼쪽에 놓습니다.</target>
        </trans-unit>
        <trans-unit id="1d49e8ef11811976abe82fb279f8c9975b4af0a5" translate="yes" xml:space="preserve">
          <source>Place the colorbar inside the plot to the right.</source>
          <target state="translated">플롯 안에 컬러 바를 오른쪽에 놓습니다.</target>
        </trans-unit>
        <trans-unit id="321120315b5592447e9ec5d38554f14ec4005ea7" translate="yes" xml:space="preserve">
          <source>Place the colorbar outside the plot to the left.</source>
          <target state="translated">플롯 바깥에 색상 막대를 왼쪽에 놓습니다.</target>
        </trans-unit>
        <trans-unit id="5f9a43241cf0386318fa7e7a38a3ccde723b0e68" translate="yes" xml:space="preserve">
          <source>Place the colorbar outside the plot to the right. This is the default.</source>
          <target state="translated">플롯 바깥쪽에 색상 막대를 배치하십시오. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="f1596e3b9952b1cc77ef8476e652e995ae5f0f40" translate="yes" xml:space="preserve">
          <source>Place the colorbar under the plot.</source>
          <target state="translated">플롯 아래에 컬러 바를 놓습니다.</target>
        </trans-unit>
        <trans-unit id="647182bbe8a20baeed610954da64732a31161aa0" translate="yes" xml:space="preserve">
          <source>Play a movie defined by an array of frame structures.</source>
          <target state="translated">프레임 구조 배열로 정의 된 동영상을 재생합니다.</target>
        </trans-unit>
        <trans-unit id="6cd2c37aee065e05bc1861af67fe4d91134fb9af" translate="yes" xml:space="preserve">
          <source>Play audio data &lt;var&gt;y&lt;/var&gt; at sample rate &lt;var&gt;fs&lt;/var&gt; to the default audio device.</source>
          <target state="translated">샘플 속도 &lt;var&gt;fs&lt;/var&gt; 로 오디오 데이터 &lt;var&gt;y&lt;/var&gt; 를 기본 오디오 장치로 재생합니다.</target>
        </trans-unit>
        <trans-unit id="2a523dc42152e60f835ecab2fd5a7a4a505b12e9" translate="yes" xml:space="preserve">
          <source>Play audio stored in the audioplayer object &lt;var&gt;player&lt;/var&gt; with blocking.</source>
          <target state="translated">오디오 &lt;var&gt;player&lt;/var&gt; 객체 플레이어에 저장된 오디오 를 차단 하면서 재생합니다 .</target>
        </trans-unit>
        <trans-unit id="c0273284b33c82e51362116252eb24d3617b4071" translate="yes" xml:space="preserve">
          <source>Play audio stored in the audioplayer object &lt;var&gt;player&lt;/var&gt; without blocking.</source>
          <target state="translated">차단하지 않고 오디오 &lt;var&gt;player&lt;/var&gt; 객체 플레이어에 저장된 오디오를 재생합니다 .</target>
        </trans-unit>
        <trans-unit id="71385cb71a4278a75a8d4a85e637892e31d6795c" translate="yes" xml:space="preserve">
          <source>Play the audio recorded in &lt;var&gt;recorder&lt;/var&gt; and return a corresponding audioplayer object.</source>
          <target state="translated">&lt;var&gt;recorder&lt;/var&gt; 녹음 된 오디오를 재생하고 해당 오디오 플레이어 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a90d2c2fe1f01538de72946f8c10f4cd3905be8d" translate="yes" xml:space="preserve">
          <source>Play the movie &lt;code&gt;abs (&lt;var&gt;n&lt;/var&gt;(1)&lt;/code&gt; times alternatively in forward and backward order.</source>
          <target state="translated">앞뒤로 순서대로 영화 &lt;code&gt;abs (&lt;var&gt;n&lt;/var&gt;(1)&lt;/code&gt; 번갈아 재생합니다 .</target>
        </trans-unit>
        <trans-unit id="1cb100e7cdea9e4e5f29b0d860b9b7fba5ad3822" translate="yes" xml:space="preserve">
          <source>Play the movie &lt;var&gt;n&lt;/var&gt;(1) times.</source>
          <target state="translated">영화를 &lt;var&gt;n&lt;/var&gt; 번 재생합니다 .</target>
        </trans-unit>
        <trans-unit id="c8e3087049119a4af5ed19e263821d62be8e8365" translate="yes" xml:space="preserve">
          <source>Playback</source>
          <target state="translated">Playback</target>
        </trans-unit>
        <trans-unit id="c33378acde5396fdfa222e08acc95ab34601660b" translate="yes" xml:space="preserve">
          <source>Player Properties</source>
          <target state="translated">플레이어 속성</target>
        </trans-unit>
        <trans-unit id="f193b2242b6707240f995120ce45ec19f0d7091f" translate="yes" xml:space="preserve">
          <source>Plot Annotations</source>
          <target state="translated">주석 주석</target>
        </trans-unit>
        <trans-unit id="b3aea7eeb4558a7a4916f4d0c6fdd4806619b09f" translate="yes" xml:space="preserve">
          <source>Plot a 2-D function in polar coordinates.</source>
          <target state="translated">2 차원 함수를 극좌표로 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="3bb58ad3be30ba5fb14c9edb99ea3b5c5a96d4c6" translate="yes" xml:space="preserve">
          <source>Plot a 2-D pie chart.</source>
          <target state="translated">2 차원 원형 차트를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="7b5b99364a017fd64fd45c8e3e04059b638ccd98" translate="yes" xml:space="preserve">
          <source>Plot a 2-D stem graph.</source>
          <target state="translated">2 차원 줄기 그래프를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="710fc9ac51085371ad3037bf3a8873c26681488c" translate="yes" xml:space="preserve">
          <source>Plot a 2-D triangular mesh.</source>
          <target state="translated">2 차원 삼각 메쉬를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="66e12d156cad40240e6f74f6f8884130feeb8de3" translate="yes" xml:space="preserve">
          <source>Plot a 2-D vector field with arrows.</source>
          <target state="translated">화살표가있는 2 차원 벡터 필드를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="e68e51d92b1aaeec67ff0f54476d5b374885c523" translate="yes" xml:space="preserve">
          <source>Plot a 3-D ellipsoid.</source>
          <target state="translated">3 차원 타원체를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="d7e0386e9871a8882b1649e0147a7705d4f0b57e" translate="yes" xml:space="preserve">
          <source>Plot a 3-D pie chart.</source>
          <target state="translated">3 차원 원형 차트를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="3f05fee61d80244aa8e7aa725c5c1611def9b7c7" translate="yes" xml:space="preserve">
          <source>Plot a 3-D stem graph.</source>
          <target state="translated">3 차원 줄기 그래프를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="eef16a1d0a0bf0ff3d70843196a3a5c7e17d45a7" translate="yes" xml:space="preserve">
          <source>Plot a 3-D surface mesh with underlying contour lines.</source>
          <target state="translated">기본 등고선으로 3D 표면 메쉬를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="b4dd9d8e0e59f55e06bc9ce460da6a4b76a90764" translate="yes" xml:space="preserve">
          <source>Plot a 3-D surface mesh.</source>
          <target state="translated">3D 표면 메쉬를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="e146eef1528b39874d353f5932ba68dd7c3727e4" translate="yes" xml:space="preserve">
          <source>Plot a 3-D surface using shading based on various lighting models.</source>
          <target state="translated">다양한 조명 모델을 기반으로 음영을 사용하여 3D 표면을 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="07a042c91bfc207c4a84ae3ae9fcbef9a9d7611a" translate="yes" xml:space="preserve">
          <source>Plot a 3-D triangular surface.</source>
          <target state="translated">3 차원 삼각형 표면을 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="c9c5d33ed77576ef9c5e713e8f8d81d663d74084" translate="yes" xml:space="preserve">
          <source>Plot a 3-D triangular wireframe mesh.</source>
          <target state="translated">3 차원 삼각 와이어 프레임 메쉬를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="232401a389dae5e6d31fc8e2068ce3b9b57d2236" translate="yes" xml:space="preserve">
          <source>Plot a 3-D unit cylinder.</source>
          <target state="translated">3 차원 단위 실린더를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="d0e124a482ac495a300b96d025c7119d8df331a4" translate="yes" xml:space="preserve">
          <source>Plot a 3-D unit sphere.</source>
          <target state="translated">3 차원 단위 구를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="cbe91f628211ccc516fcbf5004ebebf7538623b5" translate="yes" xml:space="preserve">
          <source>Plot a 3-D vector field with arrows.</source>
          <target state="translated">화살표가있는 3 차원 벡터 필드를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="7cc0160a993737096aa9373ff76cda1ddacf35a4" translate="yes" xml:space="preserve">
          <source>Plot a 3-D waterfall plot.</source>
          <target state="translated">3 차원 폭포 그림을 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="d718a31b4a7acf92c3d811499581ffb7a1308161" translate="yes" xml:space="preserve">
          <source>Plot a 3-D wireframe mesh with a surrounding curtain.</source>
          <target state="translated">주변 커튼으로 3D 와이어 프레임 메쉬를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="65d5762daffcd16be6ab9a7821c65f54baa61a83" translate="yes" xml:space="preserve">
          <source>Plot a 3-D wireframe mesh with underlying contour lines.</source>
          <target state="translated">기본 등고선으로 3D 와이어 프레임 메쉬를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="3343a1c5bbc31f808a19ff8333a54e572c8a5e01" translate="yes" xml:space="preserve">
          <source>Plot a 3-D wireframe mesh.</source>
          <target state="translated">3 차원 와이어 프레임 메쉬를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="5cab8bf5e20dd160c666251df15282eacd05b316" translate="yes" xml:space="preserve">
          <source>Plot a function &lt;var&gt;fn&lt;/var&gt; within the range defined by &lt;var&gt;limits&lt;/var&gt;.</source>
          <target state="translated">함수 &lt;var&gt;fn&lt;/var&gt; 을 &lt;var&gt;limits&lt;/var&gt; 정의 된 범위 내에 플로팅 합니다 .</target>
        </trans-unit>
        <trans-unit id="5ec1a338b1f0f45c5154a36dfd8f1b85eb96afd9" translate="yes" xml:space="preserve">
          <source>Plot a function with lots of local maxima and minima.</source>
          <target state="translated">로컬 최대 값과 최소값이 많은 함수를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="02109df1b23ea737f4ffa3a52cf676241871578e" translate="yes" xml:space="preserve">
          <source>Plot a graph defined by &lt;var&gt;A&lt;/var&gt; and &lt;var&gt;xy&lt;/var&gt; in the graph theory sense.</source>
          <target state="translated">그래프 이론 의미에서 &lt;var&gt;A&lt;/var&gt; 와 &lt;var&gt;xy&lt;/var&gt; 로 정의 된 그래프를 플로팅 합니다.</target>
        </trans-unit>
        <trans-unit id="19423b451cb3b339d1a3eb6d5dc256bc32346711" translate="yes" xml:space="preserve">
          <source>Plot a parametrically defined curve in three dimensions.</source>
          <target state="translated">파라 메트릭 정의 곡선을 3 차원으로 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="4a61fa141ca0421769288ddfa21c6cda5531269a" translate="yes" xml:space="preserve">
          <source>Plot an angular histogram.</source>
          <target state="translated">각도 히스토그램을 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="19f519f6651aebac32d7e6e287842a091c444a3d" translate="yes" xml:space="preserve">
          <source>Plot level curves (contour lines) of the matrix &lt;var&gt;z&lt;/var&gt; and fill the region between lines with colors from the current colormap.</source>
          <target state="translated">행렬 &lt;var&gt;z&lt;/var&gt; 의 레벨 곡선 (등고선)을 플로팅하고 선 사이의 영역을 현재 컬러 맵의 색상으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="8ee90b844be29bb839e684767d254979a6d78993" translate="yes" xml:space="preserve">
          <source>Plot level curves (contour lines) of the matrix &lt;var&gt;z&lt;/var&gt;, using the contour matrix &lt;var&gt;c&lt;/var&gt; computed by &lt;code&gt;contourc&lt;/code&gt; from the same arguments; see the latter for their interpretation.</source>
          <target state="translated">동일한 인수에서 &lt;code&gt;contourc&lt;/code&gt; 에 의해 계산 된 등고선 행렬 &lt;var&gt;c&lt;/var&gt; 를 사용하여 행렬 &lt;var&gt;z&lt;/var&gt; 의 등고선 곡선을 그 립니다 . 해석에 대해서는 후자를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b1d70d8a2bc72fe3880dba5512d9511fd4a52d5f" translate="yes" xml:space="preserve">
          <source>Plot size in pixels for raster formats including PNG, JPEG, PNG, and (unusually (SVG)). For all vector formats, including PDF, PS, and EPS, the plot size is specified in points. This option is equivalent to changing the width and height of the output by setting the figure property &lt;code&gt;paperposition(3:4)&lt;/code&gt;. When using the command form of the print function you must quote the &lt;var&gt;xsize&lt;/var&gt;,&lt;var&gt;ysize&lt;/var&gt; option to prevent the Octave interpreter from recognizing the embedded comma (&amp;rsquo;,&amp;rsquo;). For example, by writing &quot;-S640,480&quot;.</source>
          <target state="translated">PNG, JPEG, PNG 및 (보통 (SVG))를 포함한 래스터 형식에 대한 픽셀 단위의 플롯 크기입니다. PDF, PS 및 EPS를 포함한 모든 벡터 형식의 플롯 크기는 포인트 단위로 지정됩니다. 이 옵션은 Figure 속성 &lt;code&gt;paperposition(3:4)&lt;/code&gt; 을 설정하여 출력의 너비와 높이를 변경하는 것과 같습니다 . print 함수의 명령 형식을 사용할 때 &lt;var&gt;xsize&lt;/var&gt; , &lt;var&gt;ysize&lt;/var&gt; 옵션을 인용 하여 Octave 인터프리터가 임베드 된 쉼표 ( ',')를 인식하지 못하도록 해야합니다 . 예를 들어 &quot;-S640,480&quot;을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="e51107bc0efbf6ae2cdf91d9db29f8f8cbfadb6b" translate="yes" xml:space="preserve">
          <source>Plot slices of 3-D data/scalar fields.</source>
          <target state="translated">3 차원 데이터 / 스칼라 필드 조각을 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="93f305fb0e2cbabfc1911dfbb721ada150d14586" translate="yes" xml:space="preserve">
          <source>Plot the (&lt;var&gt;u&lt;/var&gt;, &lt;var&gt;v&lt;/var&gt;) components of a vector field at the grid points defined by (&lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;). If the grid is uniform then &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt; can be specified as vectors and &lt;code&gt;meshgrid&lt;/code&gt; is used to create the 2-D grid.</source>
          <target state="translated">( &lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt; )로 정의 된 그리드 점에 벡터 필드 의 ( &lt;var&gt;u&lt;/var&gt; , &lt;var&gt;v&lt;/var&gt; ) 성분을 플로팅 합니다. 격자가 균일하면 &lt;var&gt;x&lt;/var&gt; 와 &lt;var&gt;y&lt;/var&gt; 를 벡터로 지정할 수 있고 &lt;code&gt;meshgrid&lt;/code&gt; 를 사용하여 2 차원 격자를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2546df41007ae342a8e0f2fc75a05d5e79ca14bc" translate="yes" xml:space="preserve">
          <source>Plot the (&lt;var&gt;u&lt;/var&gt;, &lt;var&gt;v&lt;/var&gt;, &lt;var&gt;w&lt;/var&gt;) components of a vector field at the grid points defined by (&lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, &lt;var&gt;z&lt;/var&gt;). If the grid is uniform then &lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;, and &lt;var&gt;z&lt;/var&gt; can be specified as vectors and &lt;code&gt;meshgrid&lt;/code&gt; is used to create the 3-D grid.</source>
          <target state="translated">( &lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt; , &lt;var&gt;z&lt;/var&gt; )로 정의 된 그리드 점에 벡터 필드 의 ( &lt;var&gt;u&lt;/var&gt; , &lt;var&gt;v&lt;/var&gt; , &lt;var&gt;w&lt;/var&gt; ) 성분을 플로팅 합니다. 격자가 균일하면 &lt;var&gt;x&lt;/var&gt; , &lt;var&gt;y&lt;/var&gt; 및 &lt;var&gt;z&lt;/var&gt; 를 벡터로 지정할 수 있으며 &lt;code&gt;meshgrid&lt;/code&gt; 를 사용하여 3 차원 격자를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="977baf7ac8aab649da818218f5b9d8e2c675ce95" translate="yes" xml:space="preserve">
          <source>Plot the 2-D curve defined by the function &lt;var&gt;f&lt;/var&gt;.</source>
          <target state="translated">함수 &lt;var&gt;f&lt;/var&gt; 로 정의 된 2 차원 곡선을 플로팅합니다 .</target>
        </trans-unit>
        <trans-unit id="4d40079f05e9e78b38045e65e2692d3632ab1244" translate="yes" xml:space="preserve">
          <source>Plot the &lt;code&gt;(&lt;var&gt;u&lt;/var&gt;, &lt;var&gt;v&lt;/var&gt;)&lt;/code&gt; components of a vector field emanating from equidistant points on the x-axis.</source>
          <target state="translated">x 축의 등거리 점에서 나오는 벡터 필드 의 &lt;code&gt;(&lt;var&gt;u&lt;/var&gt;, &lt;var&gt;v&lt;/var&gt;)&lt;/code&gt; 성분을 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="c918f92086b1739faf1dd8e402d5881e639d2b86" translate="yes" xml:space="preserve">
          <source>Plot the &lt;code&gt;(&lt;var&gt;u&lt;/var&gt;, &lt;var&gt;v&lt;/var&gt;)&lt;/code&gt; components of a vector field emanating from the origin of a polar plot.</source>
          <target state="translated">극좌표의 원점에서 나오는 벡터 필드 의 &lt;code&gt;(&lt;var&gt;u&lt;/var&gt;, &lt;var&gt;v&lt;/var&gt;)&lt;/code&gt; 성분을 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="23b684a592e8fc79a3d44828bf8a14d1cc3633eb" translate="yes" xml:space="preserve">
          <source>Plot the RGB line profile of the colormap for each of the channels (red, green and blue) with the plot lines colored appropriately. Each line represents the intensity of an RGB component across the colormap.</source>
          <target state="translated">각 채널 (빨간색, 녹색 및 파란색)에 대한 컬러 맵의 RGB 선 프로파일을 플롯 선이 적절하게 색칠 된 채로 플롯합니다. 각 선은 컬러 맵에서 RGB 구성 요소의 강도를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cfc29fd26aa06e08bfbdc5eb247964c956aa103c" translate="yes" xml:space="preserve">
          <source>Plot the Voronoi diagram of points &lt;code&gt;(&lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt;.</source>
          <target state="translated">점의 보로 노이 다이어그램을 플로팅합니다 &lt;code&gt;(&lt;var&gt;x&lt;/var&gt;, &lt;var&gt;y&lt;/var&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f18f1660ae317e7ff730380238a8d18b7b48f83" translate="yes" xml:space="preserve">
          <source>Plot the components of a colormap.</source>
          <target state="translated">컬러 맵의 구성 요소를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="2bac6807a2bf2599271105623d5dce3e4b344655" translate="yes" xml:space="preserve">
          <source>Plot the contour lines of a function.</source>
          <target state="translated">함수의 등고선을 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="33ce66fd97a01846ad5e40a15407dc5334bec7db" translate="yes" xml:space="preserve">
          <source>Plot the elimination tree of the matrix &lt;var&gt;A&lt;/var&gt; or &lt;code&gt;&lt;var&gt;A&lt;/var&gt;+&lt;var&gt;A&lt;/var&gt;'&lt;/code&gt; if &lt;var&gt;A&lt;/var&gt; in not symmetric.</source>
          <target state="translated">&lt;var&gt;A&lt;/var&gt; 가 대칭이 아닌 경우 행렬 &lt;var&gt;A&lt;/var&gt; 또는 &lt;code&gt;&lt;var&gt;A&lt;/var&gt;+&lt;var&gt;A&lt;/var&gt;'&lt;/code&gt; 의 제거 트리를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="777e2eee3cea17e267cb9d058f2e755c96567bad" translate="yes" xml:space="preserve">
          <source>Plot the familiar 3-D sombrero function.</source>
          <target state="translated">익숙한 3 차원 솜브레로 기능을 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="6ddd12fe13473c25e2def32a7e4827fc289b35db" translate="yes" xml:space="preserve">
          <source>Plot the filled contour lines of a function.</source>
          <target state="translated">채워진 함수의 등고선을 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="c5ec8de4bdce3e0962322964c21c6a70cf3ba7c5" translate="yes" xml:space="preserve">
          <source>Plot the magnitude and phase response of &lt;var&gt;h&lt;/var&gt; rather than returning them.</source>
          <target state="translated">&lt;var&gt;h&lt;/var&gt; 의 크기와 위상 응답을 반환하지 않고 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="9d221ab550417b83e0e8737a0aaecb000dbf722e" translate="yes" xml:space="preserve">
          <source>Plot the magnitude and phase response of &lt;var&gt;h&lt;/var&gt;.</source>
          <target state="translated">&lt;var&gt;h&lt;/var&gt; 의 크기와 위상 응답을 플로팅 합니다.</target>
        </trans-unit>
        <trans-unit id="9d16494121b234bfff5745b1739e2c1a4183eb12" translate="yes" xml:space="preserve">
          <source>Plot the mesh and contour lines defined by a function.</source>
          <target state="translated">함수로 정의 된 메쉬 및 등고선을 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="588239bb2bd98dcb370d4f5250bd955cb29cf74c" translate="yes" xml:space="preserve">
          <source>Plot the mesh defined by a function.</source>
          <target state="translated">함수로 정의 된 메시를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="d30b91826f10ac5ce96c699c4943aa2738436384" translate="yes" xml:space="preserve">
          <source>Plot the sparsity pattern of the sparse matrix &lt;var&gt;x&lt;/var&gt;.</source>
          <target state="translated">희소 행렬 &lt;var&gt;x&lt;/var&gt; 의 희소성 패턴을 플로팅 합니다.</target>
        </trans-unit>
        <trans-unit id="5cfed021690484cdf00dd5c9ef329fc2495cbaee" translate="yes" xml:space="preserve">
          <source>Plot the surface and contour lines defined by a function.</source>
          <target state="translated">함수로 정의 된 곡면 및 등고선을 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="6525b0d8fc2e48c65a83b37bbc055d3ba7ebe292" translate="yes" xml:space="preserve">
          <source>Plot the surface defined by a function.</source>
          <target state="translated">함수로 정의 된 표면을 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="1e080ce195a561d7a6f9658774fb7dda72909a64" translate="yes" xml:space="preserve">
          <source>Plot two sets of data with independent y-axes and a common x-axis.</source>
          <target state="translated">독립적 인 y 축과 공통 x 축으로 두 세트의 데이터를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="d1431a1959fe1196c8f4695eb0b5b4cd6d881195" translate="yes" xml:space="preserve">
          <source>Plotting</source>
          <target state="translated">Plotting</target>
        </trans-unit>
        <trans-unit id="298a35262a3d74fa1b69a5ca381925acfc3d2019" translate="yes" xml:space="preserve">
          <source>Plotting on top of Images</source>
          <target state="translated">이미지 위에 플로팅</target>
        </trans-unit>
        <trans-unit id="730c094248f4bf4e8ebaf008c955d725b6d50a83" translate="yes" xml:space="preserve">
          <source>Plotting the Triangulation</source>
          <target state="translated">삼각 분할 플로팅</target>
        </trans-unit>
        <trans-unit id="bdfc615ed0da0f3e70a23236a672528e44b15b6f" translate="yes" xml:space="preserve">
          <source>Poisson Distribution</source>
          <target state="translated">포아송 분포</target>
        </trans-unit>
        <trans-unit id="289c31232e55e5427685eb6dd444c9003d6eda61" translate="yes" xml:space="preserve">
          <source>Polynomial Interpolation</source>
          <target state="translated">다항식 보간</target>
        </trans-unit>
        <trans-unit id="db6c3353797d89b4c0fc2f4805663a1dfe001e99" translate="yes" xml:space="preserve">
          <source>Polynomial Manipulations</source>
          <target state="translated">다항식 조작</target>
        </trans-unit>
        <trans-unit id="bdc852a04e52e6af67574114fa80093d888eaa86" translate="yes" xml:space="preserve">
          <source>Polynomial coefficients for points in sample interval. &lt;code&gt;&lt;var&gt;p&lt;/var&gt;(&lt;var&gt;i&lt;/var&gt;, :)&lt;/code&gt; contains the coefficients for the polynomial over interval &lt;var&gt;i&lt;/var&gt; ordered from highest to lowest degree. If &lt;code&gt;&lt;var&gt;d&lt;/var&gt; &amp;gt; 1&lt;/code&gt;, then &lt;var&gt;p&lt;/var&gt; is a matrix of size &lt;code&gt;[&lt;var&gt;n&lt;/var&gt;*prod(&lt;var&gt;d&lt;/var&gt;) &lt;var&gt;m&lt;/var&gt;]&lt;/code&gt;, where the &lt;code&gt;&lt;var&gt;i&lt;/var&gt; + (1:&lt;var&gt;d&lt;/var&gt;)&lt;/code&gt; rows are the coefficients of all the &lt;var&gt;d&lt;/var&gt; polynomials in the interval &lt;var&gt;i&lt;/var&gt;.</source>
          <target state="translated">샘플 간격의 포인트에 대한 다항식 계수. &lt;code&gt;&lt;var&gt;p&lt;/var&gt;(&lt;var&gt;i&lt;/var&gt;, :)&lt;/code&gt; 에는 구간 &lt;var&gt;i&lt;/var&gt; 에 대한 다항식의 계수 가 가장 높은 순서에서 가장 낮은 순서로 포함됩니다. 경우 &lt;code&gt;&lt;var&gt;d&lt;/var&gt; &amp;gt; 1&lt;/code&gt; , 다음 &lt;var&gt;p&lt;/var&gt; 크기의 행렬 &lt;code&gt;[&lt;var&gt;n&lt;/var&gt;*prod(&lt;var&gt;d&lt;/var&gt;) &lt;var&gt;m&lt;/var&gt;]&lt;/code&gt; 1, &lt;code&gt;&lt;var&gt;i&lt;/var&gt; + (1:&lt;var&gt;d&lt;/var&gt;)&lt;/code&gt; 행의 모든 계수이다 &lt;var&gt;d&lt;/var&gt; 간격에 다항식 &lt;var&gt;i&lt;/var&gt; .</target>
        </trans-unit>
        <trans-unit id="89a46693301c5693687f523b55b4d37023611672" translate="yes" xml:space="preserve">
          <source>PortAudio</source>
          <target state="translated">PortAudio</target>
        </trans-unit>
        <trans-unit id="ccaccd4fada514b2cbf659526d3072ecf581265f" translate="yes" xml:space="preserve">
          <source>PortAudio (&lt;a href=&quot;http://www.portaudio.com/&quot;&gt;http://www.portaudio.com/&lt;/a&gt;) provides a very simple API for recording and/or playing sound using a simple callback function or a blocking read/write interface. It is required for the audio processing functions &lt;code&gt;audioplayer&lt;/code&gt;, &lt;code&gt;audiorecorder&lt;/code&gt;, and &lt;code&gt;audiodevinfo&lt;/code&gt;.</source>
          <target state="translated">PortAudio ( &lt;a href=&quot;http://www.portaudio.com/&quot;&gt;http://www.portaudio.com/&lt;/a&gt; )는 간단한 콜백 기능 또는 블로킹 읽기 / 쓰기 인터페이스를 사용하여 사운드를 녹음 및 / 또는 재생하기위한 매우 간단한 API를 제공합니다. 오디오 처리 기능 &lt;code&gt;audioplayer&lt;/code&gt; , &lt;code&gt;audiorecorder&lt;/code&gt; 및 &lt;code&gt;audiodevinfo&lt;/code&gt; 에 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="9c1704c3bf01a85da027dcb0f19f88e067800ee8" translate="yes" xml:space="preserve">
          <source>Portable Document Format</source>
          <target state="translated">휴대용 문서 형식</target>
        </trans-unit>
        <trans-unit id="b6f115149e4405d841c0fdf7834b25bacb4cf5f1" translate="yes" xml:space="preserve">
          <source>Portable Document Format. The &lt;code&gt;pdfcrop&lt;/code&gt; device removes the default surrounding page.</source>
          <target state="translated">휴대용 문서 형식. &lt;code&gt;pdfcrop&lt;/code&gt; 의 장치는 기본 주변 페이지를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="5c220227521a5713ee84faf960a2c8b828bf3301" translate="yes" xml:space="preserve">
          <source>Portable GUI toolkit (&lt;a href=&quot;http://www.fltk.org&quot;&gt;http://www.fltk.org&lt;/a&gt;). FLTK is currently used to provide windows for Octave&amp;rsquo;s OpenGL-based graphics functions.</source>
          <target state="translated">휴대용 GUI 툴킷 ( &lt;a href=&quot;http://www.fltk.org&quot;&gt;http://www.fltk.org&lt;/a&gt; ). FLTK는 현재 Octave의 OpenGL 기반 그래픽 기능을위한 창을 제공하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0655d96b4660aed951fededfbd01c7c59119ecd3" translate="yes" xml:space="preserve">
          <source>Portable Network Graphics</source>
          <target state="translated">휴대용 네트워크 그래픽</target>
        </trans-unit>
        <trans-unit id="3432b68b664f8ad9233f8387e77b6263bcf7757d" translate="yes" xml:space="preserve">
          <source>Portable Network Graphics image</source>
          <target state="translated">휴대용 네트워크 그래픽 이미지</target>
        </trans-unit>
        <trans-unit id="71cf4f31be700637efaf53fb78dee46aa1bce75f" translate="yes" xml:space="preserve">
          <source>Portable Pixel Map file format</source>
          <target state="translated">휴대용 픽셀 맵 파일 형식</target>
        </trans-unit>
        <trans-unit id="ba5af7c0b2d95fec5441a7837e46913bf4152cc3" translate="yes" xml:space="preserve">
          <source>Portable font engine (&lt;a href=&quot;https://www.freetype.org&quot;&gt;https://www.freetype.org&lt;/a&gt;). FreeType is used to perform font rendering for Octave&amp;rsquo;s OpenGL-based graphics functions.</source>
          <target state="translated">휴대용 글꼴 엔진 ( &lt;a href=&quot;https://www.freetype.org&quot;&gt;https://www.freetype.org&lt;/a&gt; ) FreeType은 Octave의 OpenGL 기반 그래픽 기능을위한 글꼴 렌더링을 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2467aeb9fed997bfa0ce27ed7c0716b3f74b088b" translate="yes" xml:space="preserve">
          <source>Position numbering for offsets begins with 1. If &lt;var&gt;offset&lt;/var&gt; is negative, extraction starts that far from the end of the string.</source>
          <target state="translated">오프셋의 위치 번호는 1로 시작합니다. &lt;var&gt;offset&lt;/var&gt; 이 음수이면 추출이 문자열의 끝에서부터 멀어집니다.</target>
        </trans-unit>
        <trans-unit id="09f9eea00f277aec557282eec6c7c3be9951a348" translate="yes" xml:space="preserve">
          <source>Position of the light source.</source>
          <target state="translated">광원의 위치.</target>
        </trans-unit>
        <trans-unit id="9188b85f0abfdeeb351c7fd4f26e40e3262cca2c" translate="yes" xml:space="preserve">
          <source>Position of x tick marks. Setting &lt;code&gt;xtick&lt;/code&gt; also forces the &lt;code&gt;xtickmode&lt;/code&gt; property to be set to &lt;code&gt;&quot;manual&quot;&lt;/code&gt;.</source>
          <target state="translated">x 눈금 표시의 위치 &lt;code&gt;xtick&lt;/code&gt; 를 설정 하면 &lt;code&gt;xtickmode&lt;/code&gt; 속성이 &lt;code&gt;&quot;manual&quot;&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="f19cdfd01e7e00324b3fff28c0b0c362ec49f2d9" translate="yes" xml:space="preserve">
          <source>Position of y tick marks. Setting &lt;code&gt;ytick&lt;/code&gt; also forces the &lt;code&gt;ytickmode&lt;/code&gt; property to be set to &lt;code&gt;&quot;manual&quot;&lt;/code&gt;.</source>
          <target state="translated">y 눈금 표시의 위치 &lt;code&gt;ytick&lt;/code&gt; 을 설정 하면 &lt;code&gt;ytickmode&lt;/code&gt; 등록 정보가 &lt;code&gt;&quot;manual&quot;&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="6f53e063e1afc0f30363b0387db0979eb21be9e6" translate="yes" xml:space="preserve">
          <source>Position of z tick marks. Setting &lt;code&gt;ztick&lt;/code&gt; also forces the &lt;code&gt;ztickmode&lt;/code&gt; property to be set to &lt;code&gt;&quot;manual&quot;&lt;/code&gt;.</source>
          <target state="translated">z 눈금 표시의 위치 &lt;code&gt;ztick&lt;/code&gt; 를 설정 하면 &lt;code&gt;ztickmode&lt;/code&gt; 등록 정보가 &lt;code&gt;&quot;manual&quot;&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c9c657a3cf769cd89dc5642fcc74a04253c39e6" translate="yes" xml:space="preserve">
          <source>Position the light source exactly</source>
          <target state="translated">광원을 정확하게 배치</target>
        </trans-unit>
        <trans-unit id="2a05a50d2be010f211df5e28f030436f08fff5eb" translate="yes" xml:space="preserve">
          <source>Possible &lt;var&gt;opts&lt;/var&gt; fields (set value to true/false):</source>
          <target state="translated">가능한 &lt;var&gt;opts&lt;/var&gt; 필드 (값을 true / false로 설정) :</target>
        </trans-unit>
        <trans-unit id="7b49650ba8abc0719b0fd974d3a86f78193e5708" translate="yes" xml:space="preserve">
          <source>Possible features are:</source>
          <target state="translated">가능한 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c52c8b554c1d3a8dd7a42d815189071db37a289" translate="yes" xml:space="preserve">
          <source>Possible operators are &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt;. If the part of the dependency in &lt;code&gt;()&lt;/code&gt; is missing, any version of the package is acceptable. Multiple dependencies can be defined as a comma separated list.</source>
          <target state="translated">가능한 연산자는 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;&lt;/code&gt; 입니다. &lt;code&gt;()&lt;/code&gt; 의 종속성 부분 이 누락 된 경우 모든 버전의 패키지를 사용할 수 있습니다. 여러 종속성은 쉼표로 구분 된 목록으로 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="768afd5a7f523273ae4ea082c13adf89bc4aed46" translate="yes" xml:space="preserve">
          <source>Possible recognized features are:</source>
          <target state="translated">인식 할 수있는 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e3305d277f13e5cf9a4d09cbcdd58d102391bf3d" translate="yes" xml:space="preserve">
          <source>Possible values for &lt;var&gt;pos&lt;/var&gt; as a string are</source>
          <target state="translated">문자열로 &lt;var&gt;pos&lt;/var&gt; 에 가능한 값 은</target>
        </trans-unit>
        <trans-unit id="0febe614e7fb6a9c7e763525b31dd9ddf490bd08" translate="yes" xml:space="preserve">
          <source>Possible values for &lt;var&gt;type&lt;/var&gt; are</source>
          <target state="translated">&lt;var&gt;type&lt;/var&gt; 가능한 값 은</target>
        </trans-unit>
        <trans-unit id="b11760ac6da60641aa26ac00dba5c1716b0a232e" translate="yes" xml:space="preserve">
          <source>PostScript</source>
          <target state="translated">PostScript</target>
        </trans-unit>
        <trans-unit id="f2616d2af60e6d5daeaa3c1e0cceb779ce36dc99" translate="yes" xml:space="preserve">
          <source>PostScript (level 1 and 2, mono and color). The OpenGL-based graphics toolkits always generate PostScript level 3.0 and have limited support for text.</source>
          <target state="translated">PostScript (레벨 1 및 2, 모노 및 컬러). OpenGL 기반 그래픽 툴킷은 항상 PostScript 레벨 3.0을 생성하며 텍스트 지원이 제한되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1eba35dc0fe736475de1071f716d7fa407fd6e0" translate="yes" xml:space="preserve">
          <source>Power operator. If &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt; are both scalars, this operator returns &lt;var&gt;x&lt;/var&gt; raised to the power &lt;var&gt;y&lt;/var&gt;. If &lt;var&gt;x&lt;/var&gt; is a scalar and &lt;var&gt;y&lt;/var&gt; is a square matrix, the result is computed using an eigenvalue expansion. If &lt;var&gt;x&lt;/var&gt; is a square matrix, the result is computed by repeated multiplication if &lt;var&gt;y&lt;/var&gt; is an integer, and by an eigenvalue expansion if &lt;var&gt;y&lt;/var&gt; is not an integer. An error results if both &lt;var&gt;x&lt;/var&gt; and &lt;var&gt;y&lt;/var&gt; are matrices.</source>
          <target state="translated">전력 운영자. 경우 &lt;var&gt;x&lt;/var&gt; 및 &lt;var&gt;y&lt;/var&gt; 둘 스칼라가이 오퍼레이터 복귀 &lt;var&gt;x&lt;/var&gt; 를 전력으로 상승 &lt;var&gt;y&lt;/var&gt; . 경우에 &lt;var&gt;x&lt;/var&gt; 는 스칼라이고, &lt;var&gt;y&lt;/var&gt; 정방 행렬 인 결과는 고유 팽창을 이용하여 계산된다. 경우 &lt;var&gt;x&lt;/var&gt; 정방 행렬 인 경우, 그 결과는 반복 된 곱셈에 의해 계산되고 &lt;var&gt;y&lt;/var&gt; 경우 정수이고, 고유 값으로 확장 &lt;var&gt;y&lt;/var&gt; 는 정수 아니다. &lt;var&gt;x&lt;/var&gt; 와 &lt;var&gt;y&lt;/var&gt; 가 모두 행렬 이면 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="e5d95062f329a8e44e3ea54186b8c3468778516a" translate="yes" xml:space="preserve">
          <source>Precedence of Objects</source>
          <target state="translated">객체의 우선 순위</target>
        </trans-unit>
        <trans-unit id="29b8af6211d405f0e71d1833831fcff437c8facf" translate="yes" xml:space="preserve">
          <source>Predicates for Numeric Objects</source>
          <target state="translated">숫자 형 객체의 술어</target>
        </trans-unit>
        <trans-unit id="707ddefda8b9d501a1d63dad3fcb74d0cb28b51a" translate="yes" xml:space="preserve">
          <source>Preface</source>
          <target state="translated">Preface</target>
        </trans-unit>
        <trans-unit id="a51669e4fa696bc4e2a2b847317651859d159135" translate="yes" xml:space="preserve">
          <source>Preformatted Code</source>
          <target state="translated">미리 포맷 된 코드</target>
        </trans-unit>
        <trans-unit id="42e9c2ceb637ab849d47e13acc2b43d0b037daec" translate="yes" xml:space="preserve">
          <source>Preformatted Text</source>
          <target state="translated">미리 형식화 된 텍스트</target>
        </trans-unit>
        <trans-unit id="c85ec437fbcbf2a939eab892523cfad6bcf2ebf5" translate="yes" xml:space="preserve">
          <source>Preliminary balancing is on.</source>
          <target state="translated">예비 밸런싱이 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e9d51b632d4a5bb9f9acabf3a91b2bfe6685123" translate="yes" xml:space="preserve">
          <source>Prepare graphics engine to produce a new plot.</source>
          <target state="translated">새로운 음모를 생성하기 위해 그래픽 엔진을 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="3e44a83d89a4796f4f038bc4956e43df2e0f9d32" translate="yes" xml:space="preserve">
          <source>Prepend the scalar value &lt;var&gt;c&lt;/var&gt; to the vector &lt;var&gt;x&lt;/var&gt; until it is of length &lt;var&gt;l&lt;/var&gt;. If &lt;var&gt;c&lt;/var&gt; is not given, a value of 0 is used.</source>
          <target state="translated">앞에 추가 스칼라 값 &lt;var&gt;c&lt;/var&gt; 벡터에 &lt;var&gt;x&lt;/var&gt; 그것의 길이가 될 때까지 &lt;var&gt;l&lt;/var&gt; . 경우에 &lt;var&gt;c&lt;/var&gt; 부여하지 않고, 0의 값이 사용된다.</target>
        </trans-unit>
        <trans-unit id="939baf00cfde8b9ce6bb7751242fb53a137d3d57" translate="yes" xml:space="preserve">
          <source>Previous versions of Octave accepted an optional second argument, &lt;code&gt;&quot;global&quot;&lt;/code&gt;, that caused str2func to ignore locally visible functions. This option is no longer supported.</source>
          <target state="translated">이전 버전의 Octave는 선택적 두 번째 인수 인 &lt;code&gt;&quot;global&quot;&lt;/code&gt; 을 허용하여 str2func가 로컬로 보이는 기능을 무시하도록했습니다. 이 옵션은 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc05d11e60e0fced08ef4e61bc891dcf93623c6a" translate="yes" xml:space="preserve">
          <source>Pricing option (for both primal and dual simplex):</source>
          <target state="translated">가격 옵션 (원시 및 이중 심플 렉스 모두) :</target>
        </trans-unit>
        <trans-unit id="0cde65a96e66e3212b720d194237e767698098e2" translate="yes" xml:space="preserve">
          <source>Print &lt;var&gt;prompt&lt;/var&gt; and wait for user input.</source>
          <target state="translated">&lt;var&gt;prompt&lt;/var&gt; 인쇄 하고 사용자 입력을 기다립니다.</target>
        </trans-unit>
        <trans-unit id="49c980ebf9035b798666f828b6f814098af71a5a" translate="yes" xml:space="preserve">
          <source>Print a &amp;lsquo;</source>
          <target state="translated">'</target>
        </trans-unit>
        <trans-unit id="58922db24c201f8c3fdca10778733ae90d331a93" translate="yes" xml:space="preserve">
          <source>Print a floating-point number in either normal (fixed-point) or exponential notation, whichever is more appropriate for its magnitude. &amp;lsquo;</source>
          <target state="translated">부동 소수점 숫자를 정규 (고정 소수점) 또는 지수 표기법으로 인쇄하십시오. '</target>
        </trans-unit>
        <trans-unit id="2ed61991883db2517153057b7dfe85e68a846291" translate="yes" xml:space="preserve">
          <source>Print a floating-point number in exponential notation. &amp;lsquo;</source>
          <target state="translated">지수 표기법으로 부동 소수점 숫자를 인쇄하십시오. '</target>
        </trans-unit>
        <trans-unit id="b0c0767315dd58a67e8643a65c0a065e6ca392e1" translate="yes" xml:space="preserve">
          <source>Print a floating-point number in normal (fixed-point) notation. See &lt;a href=&quot;floating_002dpoint-conversions#Floating_002dPoint-Conversions&quot;&gt;Floating-Point Conversions&lt;/a&gt;, for details.</source>
          <target state="translated">부동 소수점 숫자를 일반 (고정 소수점) 표기법으로 인쇄하십시오. 자세한 내용은 &lt;a href=&quot;floating_002dpoint-conversions#Floating_002dPoint-Conversions&quot;&gt;부동 소수점 변환&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2b592e532518c55a1dc771941b6e290a7f7c5156" translate="yes" xml:space="preserve">
          <source>Print a list of which files have been opened, and whether they are open for reading, writing, or both.</source>
          <target state="translated">열린 파일 목록과 읽기, 쓰기 또는 둘 다를 위해 열린 파일 목록을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="b71c6e13d09c38ff10f196d2c6dc2808493676ce" translate="yes" xml:space="preserve">
          <source>Print a literal &amp;lsquo;</source>
          <target state="translated">리터럴 인쇄</target>
        </trans-unit>
        <trans-unit id="dbbb1ea7db8aa73a24f0dc31b0bb64581cf68571" translate="yes" xml:space="preserve">
          <source>Print a rational approximation, i.e., values are approximated as the ratio of small integers. For example, with the &amp;lsquo;</source>
          <target state="translated">합리적인 근사값을 인쇄합니다. 즉, 값은 작은 정수의 비율로 근사됩니다. 예를 들어 '</target>
        </trans-unit>
        <trans-unit id="19f59a0401873473657319d2a998e8ae3e38320e" translate="yes" xml:space="preserve">
          <source>Print a single character. See &lt;a href=&quot;other-output-conversions#Other-Output-Conversions&quot;&gt;Other Output Conversions&lt;/a&gt;.</source>
          <target state="translated">단일 문자를 인쇄하십시오. &lt;a href=&quot;other-output-conversions#Other-Output-Conversions&quot;&gt;다른 출력 변환을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4cb278b8e0bd2e5da5852c8822dd7075118a615b" translate="yes" xml:space="preserve">
          <source>Print a string. See &lt;a href=&quot;other-output-conversions#Other-Output-Conversions&quot;&gt;Other Output Conversions&lt;/a&gt;.</source>
          <target state="translated">문자열을 인쇄하십시오. &lt;a href=&quot;other-output-conversions#Other-Output-Conversions&quot;&gt;다른 출력 변환을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="654855b2a1642595ca5a6ca53f5e38295ff0663c" translate="yes" xml:space="preserve">
          <source>Print a summary message when all tests pass, or print an error with the results of the first bad test when a failure occurs. Don&amp;rsquo;t run tests which require user interaction.</source>
          <target state="translated">모든 테스트가 통과되면 요약 메시지를 인쇄하거나 오류가 발생할 때 첫 번째 불량 테스트 결과와 함께 오류를 인쇄하십시오. 사용자 상호 작용이 필요한 테스트를 실행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="fc5167ca4f2d2e2224d3cbab3907d82d0caa5a58" translate="yes" xml:space="preserve">
          <source>Print a summary of the options recognized by the configure script.</source>
          <target state="translated">configure 스크립트가 인식 한 옵션의 요약을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="9d7274a0e4591685877578256b2266486777a673" translate="yes" xml:space="preserve">
          <source>Print an integer as a signed decimal number. See &lt;a href=&quot;integer-conversions#Integer-Conversions&quot;&gt;Integer Conversions&lt;/a&gt;, for details. &amp;lsquo;</source>
          <target state="translated">정수를 부호있는 10 진수로 인쇄하십시오. 자세한 내용은 &lt;a href=&quot;integer-conversions#Integer-Conversions&quot;&gt;정수 변환&lt;/a&gt; 을 참조하십시오. '</target>
        </trans-unit>
        <trans-unit id="2869d39005b83028ff0e6a44413f70eec5f25272" translate="yes" xml:space="preserve">
          <source>Print an integer as an unsigned decimal number. See &lt;a href=&quot;integer-conversions#Integer-Conversions&quot;&gt;Integer Conversions&lt;/a&gt;, for details.</source>
          <target state="translated">부호없는 10 진수로 정수를 인쇄하십시오. 자세한 내용은 &lt;a href=&quot;integer-conversions#Integer-Conversions&quot;&gt;정수 변환&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b3f412e2f5fdc4a6de6060822d01bcb77f21c581" translate="yes" xml:space="preserve">
          <source>Print an integer as an unsigned hexadecimal number. &amp;lsquo;</source>
          <target state="translated">부호없는 16 진수로 정수를 인쇄하십시오. '</target>
        </trans-unit>
        <trans-unit id="bb69ae94f4b5f5281a5b1064240e36d42637c461" translate="yes" xml:space="preserve">
          <source>Print an integer as an unsigned octal number. See &lt;a href=&quot;integer-conversions#Integer-Conversions&quot;&gt;Integer Conversions&lt;/a&gt;, for details.</source>
          <target state="translated">부호없는 8 진수로 정수를 인쇄하십시오. 자세한 내용은 &lt;a href=&quot;integer-conversions#Integer-Conversions&quot;&gt;정수 변환&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0aa98506213ee0c5475ec4cbb996159377ee0393" translate="yes" xml:space="preserve">
          <source>Print configuration variable VAR. There are three categories of variables:</source>
          <target state="translated">구성 변수 VAR을 인쇄하십시오. 변수에는 세 가지 범주가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5f80e5448fd9bc23045c1bc21e9f0b5d727035f" translate="yes" xml:space="preserve">
          <source>Print optional arguments under the control of the template string &lt;var&gt;template&lt;/var&gt; to the stream &lt;code&gt;stdout&lt;/code&gt; and return the number of characters printed.</source>
          <target state="translated">템플리트 문자열 &lt;var&gt;template&lt;/var&gt; 의 제어하에 선택적 인수를 스트림 &lt;code&gt;stdout&lt;/code&gt; 에 인쇄하고 인쇄 된 문자 수를 리턴하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
