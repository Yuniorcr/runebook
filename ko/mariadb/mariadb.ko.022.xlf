<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="mariadb">
    <body>
      <group id="mariadb">
        <trans-unit id="dd571990a8d2104dd6e622273aee60243e2d0055" translate="yes" xml:space="preserve">
          <source>Getting the Master's Binary Log Co-ordinates</source>
          <target state="translated">마스터 이진 로그 좌표 얻기</target>
        </trans-unit>
        <trans-unit id="665f037ca80c99c7db7bf8fdb1529f6ced743bf0" translate="yes" xml:space="preserve">
          <source>Getting the source code</source>
          <target state="translated">소스 코드 얻기</target>
        </trans-unit>
        <trans-unit id="beb48fb04f86f1eb10befdbc896a5c33838084b1" translate="yes" xml:space="preserve">
          <source>Getting, Installing, and Upgrading MariaDB</source>
          <target state="translated">MariaDB 시작, 설치 및 업그레이드</target>
        </trans-unit>
        <trans-unit id="5cabc07ad05bb5280a2f691a292ce6b92aaf443c" translate="yes" xml:space="preserve">
          <source>Getting, installing, and upgrading MariaDB Server and related software.</source>
          <target state="translated">MariaDB 서버 및 관련 소프트웨어 얻기, 설치 및 업그레이드</target>
        </trans-unit>
        <trans-unit id="df714f838c530c70f00ab92649947eeee864f700" translate="yes" xml:space="preserve">
          <source>Gigabytes &lt;em&gt;(1,073,741,024 bytes)&lt;/em&gt;</source>
          <target state="translated">기가 바이트 &lt;em&gt;(1,073,741,024 바이트)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c8ccb350b2b15b2a853480cbaec8338b2c6ddebc" translate="yes" xml:space="preserve">
          <source>Git, CMake (on Fedora, both cmake and cmake-fedora are required), GCC and GCC-C++, Automake, Autoconf, and Bison, as well as development releases of libaio and ncurses.</source>
          <target state="translated">Git, CMake (Fedora에서는 cmake 및 cmake-fedora가 모두 필요함), GCC 및 GCC-C ++, Automake, Autoconf 및 Bison, libaio 및 ncurses의 개발 릴리스.</target>
        </trans-unit>
        <trans-unit id="5898db4c4e2de6734729910bcac6c73925e44931" translate="yes" xml:space="preserve">
          <source>Github - galera</source>
          <target state="translated">깃 허브-갈레 라</target>
        </trans-unit>
        <trans-unit id="6e7c7553a3a3177460296776bbec6807a02dec58" translate="yes" xml:space="preserve">
          <source>Github - mysql-wsrep</source>
          <target state="translated">Github-mysql-wsrep</target>
        </trans-unit>
        <trans-unit id="0ad733b056a5329dfc48dbaa4c2404cb353bddef" translate="yes" xml:space="preserve">
          <source>Give BKA buffer space to operate on. Ideally, it should have enough space to fit all the data examined by the query.</source>
          <target state="translated">작동 할 BKA 버퍼 공간을 제공하십시오. 이상적으로는 쿼리로 검사 한 모든 데이터를 수용 할 수있는 충분한 공간이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b4081f02672025fdb0d2385772127febccdb0975" translate="yes" xml:space="preserve">
          <source>Give an example of a config file with extra information.</source>
          <target state="translated">추가 정보가있는 구성 파일의 예를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="46e5d3c79b903a2f46ef1e0a64783e25a8427fd3" translate="yes" xml:space="preserve">
          <source>Give less verbose output (useful for debugging). Disables structure comments and header/footer constructs. Enables the &lt;code&gt;--skip-add-drop-table&lt;/code&gt;, &lt;code&gt;--skip-add-locks&lt;/code&gt;, &lt;code&gt;--skip-comments&lt;/code&gt;, &lt;code&gt;--skip-disable-keys&lt;/code&gt;, and &lt;code&gt;--skip-set-charset&lt;/code&gt; options.</source>
          <target state="translated">더 자세한 출력을 제공하십시오 (디버깅에 유용). 구조 주석 및 머리글 / 바닥 글 구성을 비활성화합니다. 수있는 &lt;code&gt;--skip-add-drop-table&lt;/code&gt; , &lt;code&gt;--skip-add-locks&lt;/code&gt; , &lt;code&gt;--skip-comments&lt;/code&gt; , &lt;code&gt;--skip-disable-keys&lt;/code&gt; , 그리고 &lt;code&gt;--skip-set-charset&lt;/code&gt; 옵션을.</target>
        </trans-unit>
        <trans-unit id="53b11ce65280db1d64ef176ec9dc5aba55b9b98e" translate="yes" xml:space="preserve">
          <source>Give the master a unique &lt;a href=&quot;../server-system-variables/index#server_id&quot;&gt;server_id&lt;/a&gt;. All slaves must also be given a server_id. This can be a number from 1 to 2&lt;sup&gt;32&lt;/sup&gt;-1, and must be unique for each server in the replicating group.</source>
          <target state="translated">마스터에게 고유 한 &lt;a href=&quot;../server-system-variables/index#server_id&quot;&gt;server_id를&lt;/a&gt; 제공하십시오 . 모든 슬레이브에도 server_id가 제공되어야합니다. 이것은 1-2 &lt;sup&gt;32&lt;/sup&gt; -1 의 숫자 일 수 있으며 복제 그룹의 각 서버마다 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="f910a5fc89640cea9dbb99755a88bae40701c353" translate="yes" xml:space="preserve">
          <source>Give the slave a unique &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#server_id&quot;&gt;server_id&lt;/a&gt;. All servers, whether masters or slaves, are given a server_id. This can be a number from 1 to 2&lt;sup&gt;32&lt;/sup&gt;-1, and must be unique for each server in the replicating group. The server will need to be restarted in order for a change in this option to take effect.</source>
          <target state="translated">슬레이브에게 고유 한 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#server_id&quot;&gt;server_id를&lt;/a&gt; 제공하십시오 . 마스터이든 슬레이브이든 모든 서버에는 server_id가 부여됩니다. 이것은 1-2 &lt;sup&gt;32&lt;/sup&gt; -1 의 숫자 일 수 있으며 복제 그룹의 각 서버마다 고유해야합니다. 이 옵션의 변경 사항을 적용하려면 서버를 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="27dbdc54f297c256df63ec3903305de9b74c9fae" translate="yes" xml:space="preserve">
          <source>Give your Role a &quot;Role name&quot;</source>
          <target state="translated">역할에 &quot;역할 이름&quot;을 부여하십시오</target>
        </trans-unit>
        <trans-unit id="02d4cc72f1a1468ecdddb17c21b2c36b65143afa" translate="yes" xml:space="preserve">
          <source>Given M members of the set, (M+7)/8 bytes, rounded up to 1, 2, 3, 4, or 8 bytes</source>
          <target state="translated">세트의 M 멤버 (M + 7) / 8 바이트, 1, 2, 3, 4 또는 8 바이트로 올림</target>
        </trans-unit>
        <trans-unit id="0c83b62b54fc4ccbc8b6497c8d0560c1e6c78010" translate="yes" xml:space="preserve">
          <source>Given a GeoJSON input &lt;em&gt;g&lt;/em&gt;, returns a geometry object. The &lt;em&gt;option&lt;/em&gt; specifies what to do if &lt;em&gt;g&lt;/em&gt; contains geometries with coordinate dimensions higher than 2.</source>
          <target state="translated">GeoJSON 입력 &lt;em&gt;g가&lt;/em&gt; 주어지면 기하 객체를 반환합니다. 이 &lt;em&gt;옵션&lt;/em&gt; 은 &lt;em&gt;g&lt;/em&gt; 에 좌표 치수가 2보다 큰 형상이 &lt;em&gt;g에&lt;/em&gt; 포함 된 경우 수행 할 작업을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="7939ef0512ebef7d10181dd4f5946f35438861b9" translate="yes" xml:space="preserve">
          <source>Given a GeoJSON input, returns a geometry object</source>
          <target state="translated">GeoJSON 입력이 주어지면 지오메트리 객체를 반환</target>
        </trans-unit>
        <trans-unit id="6220cbb3f5b39c96fac7a8eab69a6c932ea4571a" translate="yes" xml:space="preserve">
          <source>Given a JSON document, returns an object or array specified by the path</source>
          <target state="translated">JSON 문서가 주어지면 경로로 지정된 객체 또는 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c9876f7902af536fbf846d263b709576fd5abfb8" translate="yes" xml:space="preserve">
          <source>Given a JSON document, returns an object or array specified by the path.</source>
          <target state="translated">JSON 문서가 주어지면 경로로 지정된 객체 또는 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3956ba1aa3065084cd9719b22cca811f72f1c93" translate="yes" xml:space="preserve">
          <source>Given a JSON document, returns an object or array specified by the path. Returns NULL if not given a valid JSON document, or if there is no match.</source>
          <target state="translated">JSON 문서가 주어지면 경로로 지정된 객체 또는 배열을 반환합니다. 유효한 JSON 문서가 제공되지 않거나 일치하지 않으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e8edf26e408ff4e8756b342ce2153d252dff38c4" translate="yes" xml:space="preserve">
          <source>Given a JSON document, returns the scalar specified by the path. Returns NULL if not given a valid JSON document, or if there is no match.</source>
          <target state="translated">JSON 문서가 주어지면 경로로 지정된 스칼라를 반환합니다. 유효한 JSON 문서가 제공되지 않거나 일치하지 않으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f0586c549e566ab7fb59b5ae9b6fbb966f417c9" translate="yes" xml:space="preserve">
          <source>Given a JSON document, returns the specified scalar</source>
          <target state="translated">JSON 문서가 주어지면 지정된 스칼라를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f846b56ee740e934d3770195a8931b1c4815e45b" translate="yes" xml:space="preserve">
          <source>Given a JSON document, returns the specified scalar.</source>
          <target state="translated">JSON 문서가 주어지면 지정된 스칼라를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ebf87a0790ad42e739c8072f4c5377ca8f00a7c3" translate="yes" xml:space="preserve">
          <source>Given a base-64 encoded string, returns the decoded result as a binary string</source>
          <target state="translated">base-64로 인코딩 된 문자열이 제공되면 디코딩 된 결과를 이진 문자열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b4e4d32f4c64d8d80d5ac3308ae048b6bf1b9b4f" translate="yes" xml:space="preserve">
          <source>Given a base-64 encoded string, returns the decoded result as a binary string.</source>
          <target state="translated">base-64로 인코딩 된 문자열이 제공되면 디코딩 된 결과를 이진 문자열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="51bd28b7503b8e30b735b7e6a1e8b83f014a9ff6" translate="yes" xml:space="preserve">
          <source>Given a date &lt;code&gt;date&lt;/code&gt;, returns the number of days since the start of the current calendar (0000-00-00).</source>
          <target state="translated">date &lt;code&gt;date&lt;/code&gt; 가 주어지면 현재 달력이 시작된 이후 일 수를 반환합니다 (0000-00-00).</target>
        </trans-unit>
        <trans-unit id="433909f06be44447fe9c5bdf15dbc596f62c5680" translate="yes" xml:space="preserve">
          <source>Given a day number N, returns a DATE value. The day count is based on the number of days from the start of the standard calendar (0000-00-00).</source>
          <target state="translated">일 수 N이 주어지면 DATE 값을 리턴합니다. 일 수는 표준 달력 (0000-00-00)이 시작된 이후의 일 수를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="ee6a48ff3ff6673d3e23db70af82579cb20a14f7" translate="yes" xml:space="preserve">
          <source>Given a geometry, returns a &lt;a href=&quot;../point/index&quot;&gt;POINT&lt;/a&gt; guaranteed to intersect a surface. However, see &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-7514&quot;&gt;MDEV-7514&lt;/a&gt;.</source>
          <target state="translated">기하가 주어지면 표면과 교차하도록 보장 된 &lt;a href=&quot;../point/index&quot;&gt;POINT를&lt;/a&gt; 반환합니다 . 그러나 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-7514&quot;&gt;MDEV-7514를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="854058e34846db56a761354a8ea074bab2ffa0d5" translate="yes" xml:space="preserve">
          <source>Given a geometry, returns a geometry that is the minimum convex geometry enclosing all geometries within the set. Returns NULL if the geometry value is NULL or an empty value.</source>
          <target state="translated">지오메트리가 주어지면 세트 내의 모든 지오메트리를 포함하는 최소 볼록 지오메트리 인 지오메트리를 반환합니다. 기하학 값이 NULL이거나 비어있는 값이면 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1c42c24af3db3a2edd693edc7d70422464131e43" translate="yes" xml:space="preserve">
          <source>Given a key, find the corresponding row(s);</source>
          <target state="translated">키가 주어지면 해당 행을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="8e859a72bcfb3cae00d644dbf161096fb8c7a8c0" translate="yes" xml:space="preserve">
          <source>Given a numeric IPv4 network address in network byte order (4 or 8 byte), returns the dotted-quad representation of the address as a string.</source>
          <target state="translated">네트워크 바이트 순서 (4 또는 8 바이트)의 숫자 IPv4 네트워크 주소가 주어진 경우, 주소의 점으로 구분 된 쿼드 표시를 문자열로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2bc2f566a958f85b25c66c368d22d1e8f242fa7c" translate="yes" xml:space="preserve">
          <source>Given a string &lt;em&gt;&lt;code&gt;str&lt;/code&gt;&lt;/em&gt;, calculates an SHA-2 checksum, which is considered more cryptographically secure than its &lt;a href=&quot;../sha1/index&quot;&gt;SHA-1&lt;/a&gt; equivalent. The SHA-2 family includes SHA-224, SHA-256, SHA-384, and SHA-512, and the &lt;em&gt;&lt;code&gt;hash_len&lt;/code&gt;&lt;/em&gt; must correspond to one of these, i.e. 224, 256, 384 or 512. 0 is equivalent to 256.</source>
          <target state="translated">문자열 &lt;em&gt; &lt;code&gt;str&lt;/code&gt; 이&lt;/em&gt; 주어지면 SHA-2 체크섬을 계산합니다. SHA-2 체크섬은 &lt;a href=&quot;../sha1/index&quot;&gt;SHA-1&lt;/a&gt; 동등 보다 암호화 적으로 안전한 것으로 간주됩니다 . SHA-2 제품군에는 SHA-224, SHA-256, SHA-384 및 SHA-512가 포함되며 &lt;em&gt; &lt;code&gt;hash_len&lt;/code&gt; &lt;/em&gt; 은 이들 중 하나, 즉 224, 256, 384 또는 512 와 &lt;em&gt;일치&lt;/em&gt; 해야합니다. 0은 256과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a1a1c488234185f05cdfb4b5fad49af7a63b499" translate="yes" xml:space="preserve">
          <source>Given a string, returns the normalized text.</source>
          <target state="translated">문자열이 주어지면 정규화 된 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f5d72eef008cb3a161fbeecca81014117cd1c39c" translate="yes" xml:space="preserve">
          <source>Given an IPv6 or IPv4 network address as a numeric binary string, returns the address as a nonbinary string in the connection character set.</source>
          <target state="translated">IPv6 또는 IPv4 네트워크 주소가 숫자 이진 문자열로 제공되면 연결 문자 집합에서 주소를 비 이진 문자열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9fa5720f25d660a0f60d11ad3cbae8f5ec592670" translate="yes" xml:space="preserve">
          <source>Given an IPv6 or IPv4 network address as a string, returns a binary string that represents the numeric value of the address.</source>
          <target state="translated">IPv6 또는 IPv4 네트워크 주소를 문자열로 지정하면 주소의 숫자 값을 나타내는 이진 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6467935c958e9cac7126aee93f47ff2496cbbcbf" translate="yes" xml:space="preserve">
          <source>Given an IPv6 or IPv4 network address, returns a VARBINARY numeric value</source>
          <target state="translated">IPv6 또는 IPv4 네트워크 주소가 주어지면 VARBINARY 숫자 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="188f1861930e6923144208e14e81fa40bc390da6" translate="yes" xml:space="preserve">
          <source>Given an IPv6 or IPv4 network address, returns a VARBINARY numeric value.</source>
          <target state="translated">IPv6 또는 IPv4 네트워크 주소가 주어지면 VARBINARY 숫자 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2cb00b849a3d3a25354245841bf1e4cb4b04e523" translate="yes" xml:space="preserve">
          <source>Given an IPv6 or IPv4 network address, returns the address as a nonbinary string</source>
          <target state="translated">IPv6 또는 IPv4 네트워크 주소가 주어지면 주소를 이진이 아닌 문자열로 반환합니다</target>
        </trans-unit>
        <trans-unit id="bbd703fd90728021061789078d7d9d49300bf3e6" translate="yes" xml:space="preserve">
          <source>Given an IPv6 or IPv4 network address, returns the address as a nonbinary string.</source>
          <target state="translated">IPv6 또는 IPv4 네트워크 주소가 주어지면 주소를 이진이 아닌 문자열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2a5f2a07abf091ac4c386aff63dfaef74036af47" translate="yes" xml:space="preserve">
          <source>Given that id is the PRIMARY KEY (or UNIQUE), this will be safe:</source>
          <target state="translated">id가 PRIMARY KEY (또는 UNIQUE)라는 것을 감안할 때 이것은 안전합니다.</target>
        </trans-unit>
        <trans-unit id="0caf85b053d682c4b65b936efaee97e061b5f9c4" translate="yes" xml:space="preserve">
          <source>Given the dotted-quad representation of an IPv4 network address as a string, returns an integer that represents the numeric value of the address. Addresses may be 4- or 8-byte addresses.</source>
          <target state="translated">IPv4 네트워크 주소를 문자열로 점으로 표시하면 주소의 숫자 값을 나타내는 정수를 반환합니다. 주소는 4 바이트 또는 8 바이트 주소 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="befceea3b86204910e002bc61a791da5e21ed0b4" translate="yes" xml:space="preserve">
          <source>Given the file &amp;ldquo;facebook.json&amp;rdquo;:</source>
          <target state="translated">&amp;ldquo;facebook.json&amp;rdquo;파일이 주어지면 :</target>
        </trans-unit>
        <trans-unit id="49593040e36977b5928b3cb1702b146e7272b134" translate="yes" xml:space="preserve">
          <source>Given the following sample data:</source>
          <target state="translated">다음과 같은 샘플 데이터가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4cce433b48843bef98ec93ec338775eb8bbfc1e4" translate="yes" xml:space="preserve">
          <source>Given the following structure and data, we want to find the top 5 salaries from each department.</source>
          <target state="translated">다음과 같은 구조와 데이터를 감안할 때 각 부서의 상위 5 개 급여를 찾고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="8b437aac2861305378bfe6f2d7ca8bd805a4f6c3" translate="yes" xml:space="preserve">
          <source>Given the following structure:</source>
          <target state="translated">다음과 같은 구조가 주어집니다.</target>
        </trans-unit>
        <trans-unit id="d85f74284c80cdb7e92d2c84618f2e2d2cf702d5" translate="yes" xml:space="preserve">
          <source>Given the query:</source>
          <target state="translated">주어진 쿼리 :</target>
        </trans-unit>
        <trans-unit id="5d258fb693f4f0c1cbe0b462a37514a74d487785" translate="yes" xml:space="preserve">
          <source>Given the same view as above, if we run the query:</source>
          <target state="translated">쿼리를 실행하면 위와 동일한 뷰가 주어집니다.</target>
        </trans-unit>
        <trans-unit id="12ad381a4032dc00855f65705f91a7c0e1945842" translate="yes" xml:space="preserve">
          <source>Given this algorithm, the configuration parameters could be thought of as minimum levels for each priority.</source>
          <target state="translated">이 알고리즘을 고려하면 구성 매개 변수는 각 우선 순위의 최소 레벨로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52b94142397edfd8100c20385ca737c63939e001" translate="yes" xml:space="preserve">
          <source>Given views &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt;, but no view &lt;code&gt;v3&lt;/code&gt;</source>
          <target state="translated">주어진 뷰 &lt;code&gt;v&lt;/code&gt; 와 &lt;code&gt;v2&lt;/code&gt; 이지만 뷰 &lt;code&gt;v3&lt;/code&gt; 은 없습니다.</target>
        </trans-unit>
        <trans-unit id="672822efa59dfc32ce9acbbccbfc758eb0b940bc" translate="yes" xml:space="preserve">
          <source>Gives a short status message from the server.</source>
          <target state="translated">서버에서 짧은 상태 메시지를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ddf72202a15dbc24d1133951c63335b23546df6c" translate="yes" xml:space="preserve">
          <source>Gives the more interesting result:</source>
          <target state="translated">더 흥미로운 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b85d9b1aaa09f9eb0c6aa93e3e1775ceb924f5f8" translate="yes" xml:space="preserve">
          <source>Giving MariaDB easy and natural access to external data enables the use of all of its powerful functions and SQL-handling abilities for developing business intelligence applications</source>
          <target state="translated">MariaDB가 외부 데이터에 쉽고 자연스럽게 액세스 할 수있게함으로써 비즈니스 인텔리전스 응용 프로그램 개발을위한 모든 강력한 기능과 SQL 처리 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f1184f7df96c5928092ad9c6b550699bf887826" translate="yes" xml:space="preserve">
          <source>Global</source>
          <target state="translated">Global</target>
        </trans-unit>
        <trans-unit id="6ecfa85fe37415736a1b6380643290aa185cfb32" translate="yes" xml:space="preserve">
          <source>Global Options Related to Option Files</source>
          <target state="translated">옵션 파일과 관련된 전역 옵션</target>
        </trans-unit>
        <trans-unit id="800a426169ffa559ee0621896ab5685d7937feb4" translate="yes" xml:space="preserve">
          <source>Global Privileges</source>
          <target state="translated">글로벌 특권</target>
        </trans-unit>
        <trans-unit id="d46b9d2ab138dc85a610bba364a54778f2bdfaac" translate="yes" xml:space="preserve">
          <source>Global Server Time Zone</source>
          <target state="translated">글로벌 서버 시간대</target>
        </trans-unit>
        <trans-unit id="1d1f370e89b0e465d2339eb687bb0367b2efc843" translate="yes" xml:space="preserve">
          <source>Global Status Variables that Support &lt;code&gt;FLUSH STATUS&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;FLUSH STATUS&lt;/code&gt; 를 지원하는 전역 상태 변수</target>
        </trans-unit>
        <trans-unit id="e75e72d6e28196d89cfbb2033fe5c3c6b9678d0c" translate="yes" xml:space="preserve">
          <source>Global Threads</source>
          <target state="translated">글로벌 스레드</target>
        </trans-unit>
        <trans-unit id="f92c6a41ff3b9e13fea0ab5e6b00d812c47a07ae" translate="yes" xml:space="preserve">
          <source>Global Transaction ID</source>
          <target state="translated">글로벌 거래 ID</target>
        </trans-unit>
        <trans-unit id="3595774698b065a1c6d2d17fb78f2262d55d0554" translate="yes" xml:space="preserve">
          <source>Global Transaction ID System Variables</source>
          <target state="translated">글로벌 트랜잭션 ID 시스템 변수</target>
        </trans-unit>
        <trans-unit id="39f8f68c0b072d7b3b3b2bc4c45fcff8ec769e37" translate="yes" xml:space="preserve">
          <source>Global and session status variables</source>
          <target state="translated">글로벌 및 세션 상태 변수</target>
        </trans-unit>
        <trans-unit id="b62c15df1db498dc94069241b7feca429ae0ba91" translate="yes" xml:space="preserve">
          <source>Global and session system variables</source>
          <target state="translated">글로벌 및 세션 시스템 변수</target>
        </trans-unit>
        <trans-unit id="ac5ccaa0c889e87551dee08ffbba2aa8b561995b" translate="yes" xml:space="preserve">
          <source>Global options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8696757da107d01549e6a18f43283d0a2fe1ff5" translate="yes" xml:space="preserve">
          <source>Global or session value.</source>
          <target state="translated">글로벌 또는 세션 값.</target>
        </trans-unit>
        <trans-unit id="69467763454b147ce13984dde3865deeab649457" translate="yes" xml:space="preserve">
          <source>Global privileges, granted to the account and other account properties</source>
          <target state="translated">계정 및 기타 계정 속성에 부여 된 글로벌 권한</target>
        </trans-unit>
        <trans-unit id="a4f1b9eec41ae14d935a9ccc240d4e36ef2bd37c" translate="yes" xml:space="preserve">
          <source>Global privileges.</source>
          <target state="translated">글로벌 특권.</target>
        </trans-unit>
        <trans-unit id="2a3fed828aaaf6c1ff7c9a638104879f07f54dd3" translate="yes" xml:space="preserve">
          <source>Global transaction ID introduces a new event attached to each event group in the binlog. (An event group is a collection of events that are always applied as a unit. They are best thought of as a &quot;transaction&quot;, though they also include non-transactional DML statements, as well as DDL). As an event group is replicated from master server to slave server, the global transaction ID is preserved. Since the ID is globally unique across the entire group of servers, this makes it easy to uniquely identify the same binlog events on different servers that replicate each other (this was not easily possible before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt;).</source>
          <target state="translated">글로벌 트랜잭션 ID는 binlog의 각 이벤트 그룹에 첨부 된 새 이벤트를 소개합니다. (이벤트 그룹은 항상 하나의 단위로 적용되는 이벤트 모음입니다. &quot;트랜잭션&quot;으로 가장 잘 생각되지만 DDL뿐만 아니라 비 트랜잭션 DML 문도 포함됩니다). 이벤트 그룹이 마스터 서버에서 슬레이브 서버로 복제되면 글로벌 트랜잭션 ID가 유지됩니다. ID는 전체 서버 그룹에서 전체적으로 고유하기 때문에 서로를 복제하는 다른 서버에서 동일한 binlog 이벤트를 고유하게 쉽게 식별 할 수 있습니다 ( &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt; 이전에는 불가능했습니다 ).</target>
        </trans-unit>
        <trans-unit id="2f907f612e2643a35b01538cf205f0eaf9aa6210" translate="yes" xml:space="preserve">
          <source>Global transaction IDs (GTIDs) for replication have been supported since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt;, and the &lt;code&gt;gtid_slave_pos&lt;/code&gt; table since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1003-release-notes/&quot;&gt;MariaDB 10.0.3&lt;/a&gt;</source>
          <target state="translated">복제 글로벌 트랜잭션 ID (GTIDs는)부터 지원 된 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt; 및 &lt;code&gt;gtid_slave_pos&lt;/code&gt; 의 테이블 이후 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1003-release-notes/&quot;&gt;MariaDB 10.0.3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c69b7a99e76e91e39a9fb59b0c70436f47f05c6a" translate="yes" xml:space="preserve">
          <source>Global user privilege information derived from the mysql.user grant table</source>
          <target state="translated">mysql.user grant 테이블에서 파생 된 글로벌 사용자 권한 정보</target>
        </trans-unit>
        <trans-unit id="9e53415b79ac4c558ed2df174e37a7281a5258c5" translate="yes" xml:space="preserve">
          <source>Global value of the variable or NULL if the variable only has a session scope.</source>
          <target state="translated">변수의 글로벌 값 또는 변수에 세션 범위 만있는 경우 NULL</target>
        </trans-unit>
        <trans-unit id="1a020237af3d421412a00e9859bfe2071f36c079" translate="yes" xml:space="preserve">
          <source>Global, session, or session-only.</source>
          <target state="translated">글로벌, 세션 또는 세션 전용</target>
        </trans-unit>
        <trans-unit id="cd17beb4e9bd8eea225ec599968e7128c62d5192" translate="yes" xml:space="preserve">
          <source>GnuTLS</source>
          <target state="translated">GnuTLS</target>
        </trans-unit>
        <trans-unit id="6770f0864a5a6e23ce74aa47d179f00642939bb0" translate="yes" xml:space="preserve">
          <source>Go to each slave server and run &lt;a href=&quot;../show-slave-status/index&quot;&gt;SHOW SLAVE STATUS&lt;/a&gt; to check which binary log file each slave is currently reading.</source>
          <target state="translated">각 슬레이브 서버로 가서 &lt;a href=&quot;../show-slave-status/index&quot;&gt;SHOW SLAVE STATUS&lt;/a&gt; 를 실행 하여 각 슬레이브가 현재 읽고있는 바이너리 로그 파일을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f8e969c24714dd7cb3f20baf184322905c1b0958" translate="yes" xml:space="preserve">
          <source>Go to the directory where mysqld.exe is located (subdirectory sql\Debug or sql\Relwithdebinfo of the build directory)</source>
          <target state="translated">mysqld.exe가있는 디렉토리로 이동하십시오 (빌드 디렉토리의 sql \ Debug 또는 sql \ Relwithdebinfo 서브 디렉토리)</target>
        </trans-unit>
        <trans-unit id="bb648d726a7b7c05150f8e77f3cd81d53e6c26c3" translate="yes" xml:space="preserve">
          <source>Goals with BACKUP STAGE Commands</source>
          <target state="translated">BACKUP STAGE 명령의 목표</target>
        </trans-unit>
        <trans-unit id="d823cc7db788acb11572e1f010927e7505bdb3c1" translate="yes" xml:space="preserve">
          <source>Going from one configuration to another will require a re-installation of the MariaDB ColumnStore software.</source>
          <target state="translated">한 구성에서 다른 구성으로 이동하려면 MariaDB ColumnStore 소프트웨어를 다시 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="67ee6bb697a0e125f08a7d1712a37c3472f3c0e6" translate="yes" xml:space="preserve">
          <source>Good database design is an important part of a well-run system. This section looks at some of the elements to consider.</source>
          <target state="translated">좋은 데이터베이스 디자인은 잘 운영되는 시스템의 중요한 부분입니다. 이 섹션에서는 고려해야 할 몇 가지 요소를 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="645ca1da6c4d5c5f648a2b57d72b33fae1a5aa89" translate="yes" xml:space="preserve">
          <source>Good performance</source>
          <target state="translated">좋은 성능</target>
        </trans-unit>
        <trans-unit id="1364769bef7f682eecefa0de27836a8e650c3cd5" translate="yes" xml:space="preserve">
          <source>Google Cloud Platform page</source>
          <target state="translated">Google Cloud Platform 페이지</target>
        </trans-unit>
        <trans-unit id="981c3dcea8da2246ec1ae7a4c9968a9f875e8d36" translate="yes" xml:space="preserve">
          <source>Got a packet bigger than 'max_allowed_packet' bytes</source>
          <target state="translated">'max_allowed_packet'바이트보다 큰 패킷이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b2e6c2d787116705e8d93018ea3103d1cba9406" translate="yes" xml:space="preserve">
          <source>Got a read error from the connection pipe</source>
          <target state="translated">연결 파이프에서 읽기 오류가 발생했습니다</target>
        </trans-unit>
        <trans-unit id="47cd1bb72fca10c66e58852a5a214d795f33d4a8" translate="yes" xml:space="preserve">
          <source>Got an error from fcntl()</source>
          <target state="translated">fcntl ()에서 오류가 발생했습니다</target>
        </trans-unit>
        <trans-unit id="9a2edb90d194c57325a80f3fee9ccf59c930c32e" translate="yes" xml:space="preserve">
          <source>Got an error reading communication packets</source>
          <target state="translated">통신 패킷을 읽는 중 오류가 발생했습니다</target>
        </trans-unit>
        <trans-unit id="3d6e10611bf775c3a8e793f51e937acee21565bf" translate="yes" xml:space="preserve">
          <source>Got an error writing communication packets</source>
          <target state="translated">통신 패킷을 쓰는 중 오류가 발생했습니다</target>
        </trans-unit>
        <trans-unit id="0bf03130f02ac6d0846cf1b185dc270804ea121e" translate="yes" xml:space="preserve">
          <source>Got error %d '%s' from %s</source>
          <target state="translated">% s에서 % d '% s'오류가 발생했습니다</target>
        </trans-unit>
        <trans-unit id="7ac5ee929101acdf8948400f78d9ae2e11f49b33" translate="yes" xml:space="preserve">
          <source>Got error %d during CHECKPOINT</source>
          <target state="translated">CHECKPOINT 중 오류 % d가 발생했습니다</target>
        </trans-unit>
        <trans-unit id="88a51d2df7eb14ca6d93c54dd39e2443ee324ba9" translate="yes" xml:space="preserve">
          <source>Got error %d during COMMIT</source>
          <target state="translated">COMMIT 중 오류 % d가 발생했습니다</target>
        </trans-unit>
        <trans-unit id="ff06ee7fd9d05af68e89e8acecfbb4f198a80bc4" translate="yes" xml:space="preserve">
          <source>Got error %d during FLUSH_LOGS</source>
          <target state="translated">FLUSH_LOGS 중에 오류 % d가 발생했습니다</target>
        </trans-unit>
        <trans-unit id="1e1fc614376815e1761267cf575d77866cc80115" translate="yes" xml:space="preserve">
          <source>Got error %d during ROLLBACK</source>
          <target state="translated">ROLLBACK 중 오류 % d가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="39e13e5983e07d8362d515e1b810bad7a6e611b4" translate="yes" xml:space="preserve">
          <source>Got error %d from storage engine</source>
          <target state="translated">스토리지 엔진에서 오류 % d이 (가) 발생했습니다</target>
        </trans-unit>
        <trans-unit id="b1cd20f182a4d118e652bd6513a1de3b790ed49e" translate="yes" xml:space="preserve">
          <source>Got error '%s' from regexp</source>
          <target state="translated">정규식에서 '% s'오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="a82601d36d267d97d3c36f1dbef2e8604ebcb5a2" translate="yes" xml:space="preserve">
          <source>Got fatal error %d from master when reading data from binary log: '%s'</source>
          <target state="translated">이진 로그에서 데이터를 읽을 때 마스터에서 치명적 오류 % d가 발생했습니다 : '% s'</target>
        </trans-unit>
        <trans-unit id="911c1e3c78c85494eaf3a7d987ee99607663b5d0" translate="yes" xml:space="preserve">
          <source>Got overflow when converting '%-.128s' to %-.32s. Value truncated.</source>
          <target state="translated">'%-. 128s'를 %-. 32s로 변환 할 때 오버플로가 발생했습니다. 값이 잘 렸습니다.</target>
        </trans-unit>
        <trans-unit id="a5d61f38c75fff4f62c95001f8c0ada30f4d5f2d" translate="yes" xml:space="preserve">
          <source>Got packets out of order</source>
          <target state="translated">패킷이 잘못되었습니다</target>
        </trans-unit>
        <trans-unit id="986c2fd360c2e7402d5b2be0c613505586290cb1" translate="yes" xml:space="preserve">
          <source>Got temporary error %d '%s' from %s</source>
          <target state="translated">% s에서 일시적인 오류 % d '% s'을 (를) 얻었습니다.</target>
        </trans-unit>
        <trans-unit id="a057b640192a9f6e4a2be2a4a486cf81381fb489" translate="yes" xml:space="preserve">
          <source>Got timeout reading communication packets</source>
          <target state="translated">통신 패킷을 읽는 시간이 초과되었습니다</target>
        </trans-unit>
        <trans-unit id="568af97d5a0d0796278c9557f82356aa88ae5c78" translate="yes" xml:space="preserve">
          <source>Got timeout writing communication packets</source>
          <target state="translated">통신 패킷 쓰기 시간이 초과되었습니다</target>
        </trans-unit>
        <trans-unit id="53cf8ad9b2e329d16b332275ed5c1e57ac4af91b" translate="yes" xml:space="preserve">
          <source>Graine De Paris</source>
          <target state="translated">그레인 드 파리</target>
        </trans-unit>
        <trans-unit id="40dab15d536270680a3d779c7ee2a8599fb6b233" translate="yes" xml:space="preserve">
          <source>Grant Examples</source>
          <target state="translated">그랜트 예</target>
        </trans-unit>
        <trans-unit id="d692d818d70b0e31e14cc955bf4c3c158a52200c" translate="yes" xml:space="preserve">
          <source>Grant database privileges. You can only grant privileges that you have.</source>
          <target state="translated">데이터베이스 권한을 부여하십시오. 보유한 권한 만 부여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a981a95acc192a61590f9e154650156f2c3bd647" translate="yes" xml:space="preserve">
          <source>Grant function privileges. You can only grant privileges that you have.</source>
          <target state="translated">기능 권한을 부여하십시오. 보유한 권한 만 부여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7beff833fae8ab18133ec2c7535cdbbf1b9d17df" translate="yes" xml:space="preserve">
          <source>Grant global privileges. You can only grant privileges that you have.</source>
          <target state="translated">글로벌 권한을 부여하십시오. 보유한 권한 만 부여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0000ca08f17a1be0da03293d243345b3c0559295" translate="yes" xml:space="preserve">
          <source>Grant procedure privileges. You can only grant privileges that you have.</source>
          <target state="translated">절차 권한을 부여하십시오. 보유한 권한 만 부여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="934d7a1f17dbded31024fc6a4507f2a96dacd34c" translate="yes" xml:space="preserve">
          <source>Grant table privileges. You can only grant privileges that you have.</source>
          <target state="translated">테이블 권한을 부여하십시오. 보유한 권한 만 부여 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d48d76114798f0d2631a26f1f8b34eddc28dce4" translate="yes" xml:space="preserve">
          <source>Granted, there is nothing in the definition of MySQL (much less in the SQL standard) that requires that Los Angeles should be bigger than Adelanto. But the replacement code for this 'trick' is quite messy.</source>
          <target state="translated">물론, 로스 앤젤레스가 Adelanto보다 커야하는 MySQL의 정의 (SQL 표준에서는 훨씬 적음)가 없습니다. 그러나이 '트릭'에 대한 대체 코드는 매우 지저분합니다.</target>
        </trans-unit>
        <trans-unit id="df5c09d4a3542543191c51a4e56fe6ed227b1a42" translate="yes" xml:space="preserve">
          <source>Granting Root-like Privileges</source>
          <target state="translated">루트와 같은 권한 부여</target>
        </trans-unit>
        <trans-unit id="ee8ca38e739af917d1b5693cc530021599655b94" translate="yes" xml:space="preserve">
          <source>Graph operation</source>
          <target state="translated">그래프 조작</target>
        </trans-unit>
        <trans-unit id="f93af844f20677d7278fd614e4a49acffb184d2f" translate="yes" xml:space="preserve">
          <source>Graphic characters</source>
          <target state="translated">그래픽 캐릭터</target>
        </trans-unit>
        <trans-unit id="a8c25e7f2bf438e363b276a459848325a3c6009a" translate="yes" xml:space="preserve">
          <source>Graphic or space characters</source>
          <target state="translated">그래픽 또는 공백 문자</target>
        </trans-unit>
        <trans-unit id="7ad9ef79ac6486c9458a09061b11104f2526aaf8" translate="yes" xml:space="preserve">
          <source>Graphical MariaDB manager and monitor</source>
          <target state="translated">그래픽 MariaDB 관리자 및 모니터</target>
        </trans-unit>
        <trans-unit id="13bc6bd97ebb1c096db4c22e32a6dda64d55c6af" translate="yes" xml:space="preserve">
          <source>Graphical and Enhanced Clients</source>
          <target state="translated">그래픽 및 향상된 클라이언트</target>
        </trans-unit>
        <trans-unit id="2dfbde9c84153e0d611bee751385fa2cd52abf4d" translate="yes" xml:space="preserve">
          <source>Graphical card view</source>
          <target state="translated">그래픽 카드보기</target>
        </trans-unit>
        <trans-unit id="a3e2ccb9d735cfa214734f7db372b9dfa263b5fe" translate="yes" xml:space="preserve">
          <source>Graphical card view for data editor</source>
          <target state="translated">데이터 편집기를위한 그래픽 카드보기</target>
        </trans-unit>
        <trans-unit id="aa24729b4118df65dc9f79965343ac02672338ce" translate="yes" xml:space="preserve">
          <source>Graphical display of the random nature of UUID on PRIMARY KEY</source>
          <target state="translated">기본 키에서 UUID의 임의 특성을 그래픽으로 표시</target>
        </trans-unit>
        <trans-unit id="9ef6da42d72de44e9854c46592919781055d504c" translate="yes" xml:space="preserve">
          <source>Graphical front-end for MariaDB</source>
          <target state="translated">MariaDB를위한 그래픽 프론트 엔드</target>
        </trans-unit>
        <trans-unit id="de320bb081d76bd32e2cdc182297d3dcba235f79" translate="yes" xml:space="preserve">
          <source>Graphical user interface for configuration</source>
          <target state="translated">구성을위한 그래픽 사용자 인터페이스</target>
        </trans-unit>
        <trans-unit id="ee4b0761fe570532f90e6945a0ddc4fff148e907" translate="yes" xml:space="preserve">
          <source>Greater Space Efficiency</source>
          <target state="translated">더 큰 공간 효율성</target>
        </trans-unit>
        <trans-unit id="1014bc0375350cdf9969d457cf70ebd03aeb57ee" translate="yes" xml:space="preserve">
          <source>Greater Writing Efficiency</source>
          <target state="translated">글쓰기 효율성 향상</target>
        </trans-unit>
        <trans-unit id="599294f23ef04a992bc69ba465066344c3c7cf34" translate="yes" xml:space="preserve">
          <source>Greater than</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba00f24f428c5c797c9c1a02fe3126b504dc367c" translate="yes" xml:space="preserve">
          <source>Greater than operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96bb7538f7a34d63d82ae904de0d6a6a05375886" translate="yes" xml:space="preserve">
          <source>Greater than operator. Evaluates both SQL expressions and returns 1 if the left value is greater than the right value and 0 if it is not, or &lt;code&gt;NULL&lt;/code&gt; if either expression is NULL. If the expressions return different data types, (for instance, a number and a string), performs type conversion.</source>
          <target state="translated">연산자보다 큽니다. 두 SQL 표현식을 모두 평가하고 왼쪽 값이 오른쪽 값보다 큰 경우 1을 리턴하고 그렇지 않으면 0을 &lt;code&gt;NULL&lt;/code&gt; 하고 두 표현식 중 하나가 NULL 인 경우 NULL을 리턴합니다. 식이 다른 데이터 형식 (예 : 숫자 및 문자열)을 반환하면 형식 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e8e9fd4aba5d1d5c651cb14cfb7ea55a98478786" translate="yes" xml:space="preserve">
          <source>Greater than or equal</source>
          <target state="translated">크거나 같음</target>
        </trans-unit>
        <trans-unit id="4aeb184a334e8273aa73cf8c81481065f24bf2f2" translate="yes" xml:space="preserve">
          <source>Greater than or equal operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="175d20595eb1b79f8ca92e53e10c1249f9a0bf17" translate="yes" xml:space="preserve">
          <source>Greater than or equal operator. Evaluates both SQL expressions and returns 1 if the left value is greater than or equal to the right value and 0 if it is not, or &lt;code&gt;NULL&lt;/code&gt; if either expression is NULL. If the expressions return different data types, (for instance, a number and a string), performs type conversion.</source>
          <target state="translated">크거나 같음 연산자. 두 SQL 표현식을 모두 평가하고 왼쪽 값이 오른쪽 값보다 크거나 같으면 1을 리턴하고 그렇지 않으면 0을 &lt;code&gt;NULL&lt;/code&gt; 하고 두 표현식 중 하나가 NULL 인 경우 NULL을 리턴합니다. 식이 다른 데이터 형식 (예 : 숫자 및 문자열)을 반환하면 형식 변환을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="59d5f5b13f13f6d5e8e88a5a92e137f7d64b2954" translate="yes" xml:space="preserve">
          <source>Greek</source>
          <target state="translated">Greek</target>
        </trans-unit>
        <trans-unit id="305ccd272b16a96e13db1c4faa38b1913caf51d8" translate="yes" xml:space="preserve">
          <source>Greek Extended</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63e0451063c60d5f6eae102313ee1b6d993a1f76" translate="yes" xml:space="preserve">
          <source>Greek and Coptic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1024cf8cfe2133f032ca1c3f174765eb4eabb36c" translate="yes" xml:space="preserve">
          <source>Grep: only consider statements that include this string</source>
          <target state="translated">Grep :이 문자열을 포함하는 명령문 만 고려</target>
        </trans-unit>
        <trans-unit id="171a0606f7c74580fd3982cf57c49d604104120a" translate="yes" xml:space="preserve">
          <source>Group</source>
          <target state="translated">Group</target>
        </trans-unit>
        <trans-unit id="e56d0373fe585c7bf93cb691b7e710622ce638ea" translate="yes" xml:space="preserve">
          <source>Group Commit for the Binary Log</source>
          <target state="translated">이진 로그에 대한 그룹 커밋</target>
        </trans-unit>
        <trans-unit id="6a68448431377c4c649d43bc8f7a656038e69787" translate="yes" xml:space="preserve">
          <source>Group Commit support for MariaDB Cluster was introduced in Galera 4. As such, it is only available in MariaDB Server 10.4 and later.</source>
          <target state="translated">MariaDB 클러스터에 대한 그룹 커밋 지원은 Galera 4에서 도입되었습니다. 따라서 MariaDB 서버 10.4 이상에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d2fb416ad628b049bc9f2186331122736d773db" translate="yes" xml:space="preserve">
          <source>Group Commit was introduced to the Server in &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt;, flushing groups of transactions together to disk to improve performance. Prior to &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt;, this feature was not available in MariaDB Cluster as it interfered with the global-ordering of transactions for replication. Beginning in 10.4, MariaDB Cluster can take advantage of Group Commit.</source>
          <target state="translated">Group Commit은 &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; 의 서버에 도입되어 성능 향상을 위해 트랜잭션 그룹을 디스크로 플러시합니다. &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt; 이전에는 복제를위한 글로벌 트랜잭션 순서를 방해하여 MariaDB 클러스터에서이 기능을 사용할 수 없었습니다. 10.4부터 MariaDB 클러스터는 그룹 커밋을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a01f78b7fa9416e7991917bada69cdf107e5b8f" translate="yes" xml:space="preserve">
          <source>Group Commits</source>
          <target state="translated">그룹 커밋</target>
        </trans-unit>
        <trans-unit id="fd2d472827a6c14283a08e379b1f73c20f012678" translate="yes" xml:space="preserve">
          <source>Group ID is an example, can be different than 1000, but needs to be the same on all servers in the cluster</source>
          <target state="translated">그룹 ID는 예이며 1000과 다를 수 있지만 클러스터의 모든 서버에서 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="980cacc0174d7eeff3bb427b8202461ed49cf5ce" translate="yes" xml:space="preserve">
          <source>Group Options</source>
          <target state="translated">그룹 옵션</target>
        </trans-unit>
        <trans-unit id="1c70d896c968cc13cf2d5bd057ebac6baf262594" translate="yes" xml:space="preserve">
          <source>Group commit (Already in &lt;a href=&quot;../what-is-mariadb-52/index&quot;&gt;MariaDB 5.2&lt;/a&gt;)</source>
          <target state="translated">그룹 커밋 (이미 &lt;a href=&quot;../what-is-mariadb-52/index&quot;&gt;MariaDB 5.2&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="39976573e7b6878883fab304e7078c3bcddfa34a" translate="yes" xml:space="preserve">
          <source>Group commit benchmark</source>
          <target state="translated">그룹 커밋 벤치 마크</target>
        </trans-unit>
        <trans-unit id="f194c83d0fc6584506339e9007957e4cced2dac5" translate="yes" xml:space="preserve">
          <source>Group commit for the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; was first introduced in &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그&lt;/a&gt; 에 대한 그룹 커밋 은 &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; 에서 처음 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="9288c0420b45155bf2306c122e77529e716ad4e3" translate="yes" xml:space="preserve">
          <source>Group commit for the binary log</source>
          <target state="translated">이진 로그에 대한 그룹 커밋</target>
        </trans-unit>
        <trans-unit id="65942d683c4793e89ac14c573688277c5a6d6867" translate="yes" xml:space="preserve">
          <source>Group-by trick example: Find the most populous city in each state:</source>
          <target state="translated">그룹 별 트릭 예 : 각 주에서 가장 인구가 많은 도시를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="37cb4bc610bdc5e921978b1a756977fba3ade112" translate="yes" xml:space="preserve">
          <source>Grouping also gives different result:</source>
          <target state="translated">그룹화는 또한 다른 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="63fccee7b0135d5a2216ab52e984c22301dcf121" translate="yes" xml:space="preserve">
          <source>Grouping commands uses an easier syntax and is faster because only one connection is made for the all of them. To send several commands in one call, use the following syntax:</source>
          <target state="translated">그룹화 명령은 더 쉬운 구문을 사용하며 모든 명령에 대해 하나의 연결 만 작성되므로 더 빠릅니다. 한 번의 호출로 여러 명령을 보내려면 다음 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="020acd0bc57d3477417b299e39c69cac7bee26aa" translate="yes" xml:space="preserve">
          <source>Grouping of records by type (different, equal, etc)</source>
          <target state="translated">유형별로 레코드 그룹화 (다른, 동일 등)</target>
        </trans-unit>
        <trans-unit id="8537bdc06f60e505bf5aa44e264dca6c894f368a" translate="yes" xml:space="preserve">
          <source>Groups records together with &lt;code&gt;OBJECT_SCHEMA&lt;/code&gt; and &lt;code&gt;OBJECT_NAME&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OBJECT_SCHEMA&lt;/code&gt; 및 &lt;code&gt;OBJECT_NAME&lt;/code&gt; 과 함께 레코드를 그룹화 합니다.</target>
        </trans-unit>
        <trans-unit id="af4af8e1ea838b3ffeaf49a1200daa647f2cd924" translate="yes" xml:space="preserve">
          <source>Groups records together with &lt;code&gt;OBJECT_SCHEMA&lt;/code&gt; and &lt;code&gt;OBJECT_TYPE&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OBJECT_SCHEMA&lt;/code&gt; 및 &lt;code&gt;OBJECT_TYPE&lt;/code&gt; 과 함께 레코드를 그룹화 합니다.</target>
        </trans-unit>
        <trans-unit id="dd06cf7f19064a80d602a503c51d1c751c491fcf" translate="yes" xml:space="preserve">
          <source>Groups records together with &lt;code&gt;OBJECT_TYPE&lt;/code&gt; and &lt;code&gt;OBJECT_NAME&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OBJECT_TYPE&lt;/code&gt; 및 &lt;code&gt;OBJECT_NAME&lt;/code&gt; 과 함께 레코드를 그룹화 합니다.</target>
        </trans-unit>
        <trans-unit id="0d4059c372f36111286e8c1e409fcaa9562bf7c0" translate="yes" xml:space="preserve">
          <source>Groupwise Max in MariaDB</source>
          <target state="translated">MariaDB의 그룹 별 최대</target>
        </trans-unit>
        <trans-unit id="969bcd783762d1a4d8e4687d2278185daba36962" translate="yes" xml:space="preserve">
          <source>Gtid_IO_Pos</source>
          <target state="translated">Gtid_IO_Pos</target>
        </trans-unit>
        <trans-unit id="6026eff72f3bde14a884525f47010bd52cecfde8" translate="yes" xml:space="preserve">
          <source>Gtid_Slave_Pos</source>
          <target state="translated">Gtid_Slave_Pos</target>
        </trans-unit>
        <trans-unit id="11760e1aac4396e10d315e93ad3df3e99204dc5e" translate="yes" xml:space="preserve">
          <source>Guatemala</source>
          <target state="translated">Guatemala</target>
        </trans-unit>
        <trans-unit id="ee4c60f3513f3ffe0edabdac0fd2537321fdbd0a" translate="yes" xml:space="preserve">
          <source>Guerin</source>
          <target state="translated">Guerin</target>
        </trans-unit>
        <trans-unit id="62b39d55b1df07870c4a1a5fae52ac6f6c6d2188" translate="yes" xml:space="preserve">
          <source>Guide to building MariaDB from source code on Fedora Linux.</source>
          <target state="translated">Fedora Linux의 소스 코드에서 MariaDB를 빌드하는 방법에 대한 안내서.</target>
        </trans-unit>
        <trans-unit id="e8c6eccd5541e44e811899f2f47c6fc60d4265d5" translate="yes" xml:space="preserve">
          <source>Guidelines when troubleshooting problems with InnoDB (or XtraDB).</source>
          <target state="translated">InnoDB (또는 XtraDB) 문제 해결시 지침.</target>
        </trans-unit>
        <trans-unit id="0dae5c80eda928b16ae9ed47659cd5ead83f6837" translate="yes" xml:space="preserve">
          <source>Guilhem Bichot - Replication expert, on line backup for MyISAM, etc.</source>
          <target state="translated">Guilhem Bichot-복제 전문가, MyISAM 온라인 백업 등</target>
        </trans-unit>
        <trans-unit id="c06c55a5bcd005bf56c5234eb953099ffc1de3f1" translate="yes" xml:space="preserve">
          <source>Gujarati</source>
          <target state="translated">Gujarati</target>
        </trans-unit>
        <trans-unit id="4ecd0e7f37cd88e2f59e88a6093e072395a180f3" translate="yes" xml:space="preserve">
          <source>H(tml) or C(ol) or P(os)</source>
          <target state="translated">H (tml) 또는 C (ol) 또는 P (os)</target>
        </trans-unit>
        <trans-unit id="ce7bf2b475d5bd991e7ace4b31bb7734cb92c69d" translate="yes" xml:space="preserve">
          <source>H) Advanced R Resources</source>
          <target state="translated">H) 고급 R 자료</target>
        </trans-unit>
        <trans-unit id="1197cabcd57e3938dc5fd98a95c759bc91c5c4e0" translate="yes" xml:space="preserve">
          <source>H2O.ai Algorithms: Cheatsheet</source>
          <target state="translated">H2O.ai 알고리즘 : 치트 시트</target>
        </trans-unit>
        <trans-unit id="ed4e06c25e22f475e3ae1d81ffadeb02d78c653b" translate="yes" xml:space="preserve">
          <source>H2O.ai: Webpage</source>
          <target state="translated">H2O.ai : 웹 페이지</target>
        </trans-unit>
        <trans-unit id="3cc80bf4453832a67d27401e4db22bf13ebed8a8" translate="yes" xml:space="preserve">
          <source>HANDLER</source>
          <target state="translated">HANDLER</target>
        </trans-unit>
        <trans-unit id="d7e7c5692108c2f1d1eaec864dd062aaa7bccfcc" translate="yes" xml:space="preserve">
          <source>HANDLER Commands</source>
          <target state="translated">핸들러 명령</target>
        </trans-unit>
        <trans-unit id="eb8c6e1e8d2a948fb3b3657ab0174527f6b9fb92" translate="yes" xml:space="preserve">
          <source>HANDLER OPEN cache per connection</source>
          <target state="translated">연결 당 HANDLER OPEN 캐시</target>
        </trans-unit>
        <trans-unit id="9bab267a9d24e0e0bdfc5150592c3c3a6395dfbf" translate="yes" xml:space="preserve">
          <source>HANDLER READ</source>
          <target state="translated">핸들러 읽기</target>
        </trans-unit>
        <trans-unit id="8cacec9b7d513980a4bbeff14db7de88f1d19dc9" translate="yes" xml:space="preserve">
          <source>HANDLER READ is not transaction safe, consistent or atomic. It's ok for the storage engine to returns rows that existed when you started the scan but that were later deleted. This can happen as the storage engine may cache rows as part of the scan from a previous read.</source>
          <target state="translated">HANDLER READ는 트랜잭션 안전, 일관성 또는 원 자성이 아닙니다. 스토리지 엔진이 스캔을 시작할 때 존재했지만 나중에 삭제 된 행을 리턴해도됩니다. 이는 스토리지 엔진이 이전 읽기에서 스캔의 일부로 행을 캐시 할 수 있기 때문에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5860f44e5de472911b899fdf901f42c3cda88fac" translate="yes" xml:space="preserve">
          <source>HANDLER backend propagation</source>
          <target state="translated">핸들러 백엔드 전파</target>
        </trans-unit>
        <trans-unit id="1a773b54e54f5b66a1ed59476a4c6b474aaa76ad" translate="yes" xml:space="preserve">
          <source>HANDLER backend translation from SQL</source>
          <target state="translated">SQL에서 HANDLER 백엔드 번역</target>
        </trans-unit>
        <trans-unit id="d23b30f5e38796f0129f98fe0396008a2965dbe0" translate="yes" xml:space="preserve">
          <source>HANDLER for MEMORY Tables</source>
          <target state="translated">메모리 테이블 용 핸들</target>
        </trans-unit>
        <trans-unit id="94d05629bfb82d7bb622ebf89b3f66ea82acdb05" translate="yes" xml:space="preserve">
          <source>HANDLER use prepared statement</source>
          <target state="translated">핸들러 사용 준비된 문</target>
        </trans-unit>
        <trans-unit id="82d6219614f810f72d312594955e8f2a06ba9733" translate="yes" xml:space="preserve">
          <source>HANDLER_SOCKET backend translation from SQL</source>
          <target state="translated">SQL에서 HANDLER_SOCKET 백엔드 번역</target>
        </trans-unit>
        <trans-unit id="ef861a059e1a8aea489c378c2c9c1156b7f68964" translate="yes" xml:space="preserve">
          <source>HANDLER_SOCKET protocol backend propagation</source>
          <target state="translated">HANDLER_SOCKET 프로토콜 백엔드 전파</target>
        </trans-unit>
        <trans-unit id="2d533b9d9f0f06ef4e3c23fd496cfeb2780eda7f" translate="yes" xml:space="preserve">
          <source>HASH</source>
          <target state="translated">HASH</target>
        </trans-unit>
        <trans-unit id="a0af1b398bed78f50c949b51088786d9049568e6" translate="yes" xml:space="preserve">
          <source>HASH, BTREE</source>
          <target state="translated">해시</target>
        </trans-unit>
        <trans-unit id="3472b7100ee6c34d2c985ec6e738e904962356df" translate="yes" xml:space="preserve">
          <source>HAVING</source>
          <target state="translated">HAVING</target>
        </trans-unit>
        <trans-unit id="98c340e596bdfac0bee2e481542014089fcfd7c0" translate="yes" xml:space="preserve">
          <source>HAVING is used in combination with the GROUP BY clause. It can be used in a SELECT statement to filter the records that a GROUP BY returns.The following statement returns shipping dates, and the respective quantity where the quantity is 2500 or more.</source>
          <target state="translated">HAVING은 GROUP BY 절과 함께 사용됩니다. SELECT 문에서 GROUP BY가 반환하는 레코드를 필터링하는 데 사용할 수 있습니다. 다음 문은 배송 날짜와 수량이 2500 이상인 각 수량을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6f388b83b8fb5169788000972414312f5e20ad44" translate="yes" xml:space="preserve">
          <source>HA_ERR_TABLE_DEF_CHANGED</source>
          <target state="translated">HA_ERR_TABLE_DEF_CHANGED</target>
        </trans-unit>
        <trans-unit id="2a491f80e3329709e61793a2d1e216abb2daa0e1" translate="yes" xml:space="preserve">
          <source>HBase Storage Engine</source>
          <target state="translated">HBase 스토리지 엔진</target>
        </trans-unit>
        <trans-unit id="c65f99f8c5376adadddc46d5cbcf5762f9e55eb7" translate="yes" xml:space="preserve">
          <source>HELLO</source>
          <target state="translated">HELLO</target>
        </trans-unit>
        <trans-unit id="28f08df49210251939ee60d2c93c49d60e2163bf" translate="yes" xml:space="preserve">
          <source>HELP Command</source>
          <target state="translated">도움말 명령</target>
        </trans-unit>
        <trans-unit id="9fbed14c57e89e9081db13b930ec5ff25cccc269" translate="yes" xml:space="preserve">
          <source>HELP command relations</source>
          <target state="translated">도움말 명령 관계</target>
        </trans-unit>
        <trans-unit id="887bb1c741006cf3d926f2954266ae076d7dc96b" translate="yes" xml:space="preserve">
          <source>HEX</source>
          <target state="translated">HEX</target>
        </trans-unit>
        <trans-unit id="f055334e134e4e1a9cc8a6a27216dddfba57f0f3" translate="yes" xml:space="preserve">
          <source>HEX values have a string data type by default.</source>
          <target state="translated">16 진수 값은 기본적으로 문자열 데이터 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="1411d0643edac1922c1647a15bf2224d9eb2c5eb" translate="yes" xml:space="preserve">
          <source>HEX()</source>
          <target state="translated">HEX()</target>
        </trans-unit>
        <trans-unit id="e8d41b4a2fd5e952a4d18ae6813900826cc6a031" translate="yes" xml:space="preserve">
          <source>HIGH PRIORITY</source>
          <target state="translated">우선 순위</target>
        </trans-unit>
        <trans-unit id="234803dacc7c81469ef17ebb55a8fb49a9e13154" translate="yes" xml:space="preserve">
          <source>HIGH PRIORITY and LOW PRIORITY</source>
          <target state="translated">높은 우선 순위 및 낮은 우선 순위</target>
        </trans-unit>
        <trans-unit id="104a4dea3dafcfd15f606fd963b704d3b0b5bb5e" translate="yes" xml:space="preserve">
          <source>HIGH_PRIORITY</source>
          <target state="translated">HIGH_PRIORITY</target>
        </trans-unit>
        <trans-unit id="37445c9bb9f1dba662da0ca8979a127aa8222693" translate="yes" xml:space="preserve">
          <source>HIGH_PRIORITY and LOW_PRIORITY</source>
          <target state="translated">HIGH_PRIORITY 및 LOW_PRIORITY</target>
        </trans-unit>
        <trans-unit id="9cce184262e373fa39085288f7373aa3e4d64fc4" translate="yes" xml:space="preserve">
          <source>HIGH_PRIORITY and LOW_PRIORITY clauses</source>
          <target state="translated">HIGH_PRIORITY 및 LOW_PRIORITY 절</target>
        </trans-unit>
        <trans-unit id="a1df1e3f2bb78c632f1f32d441c3a3a8f237abb7" translate="yes" xml:space="preserve">
          <source>HIGH_WATER_MARK</source>
          <target state="translated">HIGH_WATER_MARK</target>
        </trans-unit>
        <trans-unit id="f6dc58f5e8036353a7ac15516c30ac562e23dc26" translate="yes" xml:space="preserve">
          <source>HISTORY</source>
          <target state="translated">HISTORY</target>
        </trans-unit>
        <trans-unit id="ec5030e0b52ab3edd4395bc221a0885263ea7972" translate="yes" xml:space="preserve">
          <source>HOLDER_FILE</source>
          <target state="translated">HOLDER_FILE</target>
        </trans-unit>
        <trans-unit id="bfa1e191956f9f688a401e249ae6bf7aa25747c8" translate="yes" xml:space="preserve">
          <source>HOLDER_LINE</source>
          <target state="translated">HOLDER_LINE</target>
        </trans-unit>
        <trans-unit id="07023eac2e714693c06a765e5af46859857d3f1a" translate="yes" xml:space="preserve">
          <source>HOLDER_THREAD_ID</source>
          <target state="translated">HOLDER_THREAD_ID</target>
        </trans-unit>
        <trans-unit id="7731962fb19e09fff22c1be46abc4b02e9ff78eb" translate="yes" xml:space="preserve">
          <source>HOME</source>
          <target state="translated">HOME</target>
        </trans-unit>
        <trans-unit id="beea61777d189b401d35d0981ae37b9cc3d3b207" translate="yes" xml:space="preserve">
          <source>HONEY</source>
          <target state="translated">HONEY</target>
        </trans-unit>
        <trans-unit id="f3bf96f2dfadf0cbebede233a685b5a47a42b182" translate="yes" xml:space="preserve">
          <source>HOUR</source>
          <target state="translated">HOUR</target>
        </trans-unit>
        <trans-unit id="fc6a35a61c1b69fa18e8a107323039fcbb4f0d60" translate="yes" xml:space="preserve">
          <source>HOUR()</source>
          <target state="translated">HOUR()</target>
        </trans-unit>
        <trans-unit id="3a2f8942ad01a243aed2dd90ec5e54ca1c921b77" translate="yes" xml:space="preserve">
          <source>HOUR_MICROSECOND</source>
          <target state="translated">HOUR_MICROSECOND</target>
        </trans-unit>
        <trans-unit id="3599016b7457cdcf6a58a96d1070d0b269065dc9" translate="yes" xml:space="preserve">
          <source>HOUR_MINUTE</source>
          <target state="translated">HOUR_MINUTE</target>
        </trans-unit>
        <trans-unit id="aef4ee4070a62da5eede2d77a58283211bf2e797" translate="yes" xml:space="preserve">
          <source>HOUR_SECOND</source>
          <target state="translated">HOUR_SECOND</target>
        </trans-unit>
        <trans-unit id="cda39607147a4af5ec01befca316efb6b3e679fa" translate="yes" xml:space="preserve">
          <source>HP DL385g7 Opteron 6170SE or 6180SE servers (32 or 64GB ECC RAM)</source>
          <target state="translated">HP DL385g7 Opteron 6170SE 또는 6180SE 서버 (32 또는 64GB ECC RAM)</target>
        </trans-unit>
        <trans-unit id="34c0938d77faee613df64f446192188b51fc4a48" translate="yes" xml:space="preserve">
          <source>HP West European</source>
          <target state="translated">HP 서유럽</target>
        </trans-unit>
        <trans-unit id="f4144087884c19470cc32abeb86a6cf724fd636d" translate="yes" xml:space="preserve">
          <source>HSPHP</source>
          <target state="translated">HSPHP</target>
        </trans-unit>
        <trans-unit id="64c38cf29a15ea03a3844b4bbabeaa53f7a42d28" translate="yes" xml:space="preserve">
          <source>HT</source>
          <target state="translated">HT</target>
        </trans-unit>
        <trans-unit id="089bfab57bd4d832e7c0ba3058f3038d142c12f0" translate="yes" xml:space="preserve">
          <source>HTTP connections via PHP tunnel</source>
          <target state="translated">PHP 터널을 통한 HTTP 연결</target>
        </trans-unit>
        <trans-unit id="99e330b40aac1450d17dfe8f4c2ec3f67925ccfc" translate="yes" xml:space="preserve">
          <source>HWM is set to zero for the lower segments when there are multiple segments in an extent file, these can be observed when BLOCK_OFFSET &amp;gt; 0</source>
          <target state="translated">익스텐트 파일에 여러 세그먼트가있을 때 하위 세그먼트에 대해 HWM이 0으로 설정되며, BLOCK_OFFSET&amp;gt; 0 인 경우 관찰 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9463cb21481e64191c79456248374343a84a95df" translate="yes" xml:space="preserve">
          <source>HY000</source>
          <target state="translated">HY000</target>
        </trans-unit>
        <trans-unit id="2bca732c8d45f352ee2ece814ac15048bf3b4299" translate="yes" xml:space="preserve">
          <source>HY001</source>
          <target state="translated">HY001</target>
        </trans-unit>
        <trans-unit id="ec7d3d942f3c432339b3dc65dd25085b7ddee0eb" translate="yes" xml:space="preserve">
          <source>Halfwidth and Fullwidth forms</source>
          <target state="translated">반자 및 전각 양식</target>
        </trans-unit>
        <trans-unit id="548a58a6e7aeac7841c4ffc85023d62e30ba99f1" translate="yes" xml:space="preserve">
          <source>Handle Log Tables (TODO)</source>
          <target state="translated">로그 테이블 처리 (TODO)</target>
        </trans-unit>
        <trans-unit id="5043aa09f93c895975e465cd40c7c033257280f5" translate="yes" xml:space="preserve">
          <source>HandlerSocket</source>
          <target state="translated">HandlerSocket</target>
        </trans-unit>
        <trans-unit id="bb52aff757a45609ce9644ec74a17a61b45f6ef8" translate="yes" xml:space="preserve">
          <source>HandlerSocket Client Libraries</source>
          <target state="translated">HandlerSocket 클라이언트 라이브러리</target>
        </trans-unit>
        <trans-unit id="47d51c43f85a4be2279f1ae96836945fe7dcde85" translate="yes" xml:space="preserve">
          <source>HandlerSocket Configuration Options</source>
          <target state="translated">HandlerSocket 구성 옵션</target>
        </trans-unit>
        <trans-unit id="3344a606833818f5bcfd48bca0fe87be955c75fd" translate="yes" xml:space="preserve">
          <source>HandlerSocket External Resources</source>
          <target state="translated">HandlerSocket 외부 리소스</target>
        </trans-unit>
        <trans-unit id="4fb2cd4f903d5a0840532f081d9ae48e72397869" translate="yes" xml:space="preserve">
          <source>HandlerSocket Installation</source>
          <target state="translated">HandlerSocket 설치</target>
        </trans-unit>
        <trans-unit id="0a1d9c943d925fd8c72851c52839b91a4b9c8df9" translate="yes" xml:space="preserve">
          <source>HandlerSocket Plugin System Variables</source>
          <target state="translated">HandlerSocket 플러그인 시스템 변수</target>
        </trans-unit>
        <trans-unit id="e41c1ab499ee5ac172d550874bfba121cd2b9d6a" translate="yes" xml:space="preserve">
          <source>HandlerSocket can be much faster than mysqld/libmysql in some cases because it has lower CPU, disk, and network overhead:</source>
          <target state="translated">HandlerSocket은 CPU, 디스크 및 네트워크 오버 헤드가 낮기 때문에 mysqld / libmysql보다 훨씬 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2656e1f70394b662ff859275d0d1b7cff6f3134" translate="yes" xml:space="preserve">
          <source>HandlerSocket external resources and documentation</source>
          <target state="translated">HandlerSocket 외부 리소스 및 설명서</target>
        </trans-unit>
        <trans-unit id="e05789976d85a903384761692ff385de5b571316" translate="yes" xml:space="preserve">
          <source>HandlerSocket gives you direct access to &lt;a href=&quot;../xtradb-and-innodb/index&quot;&gt;InnoDB/XtraDB&lt;/a&gt; and &lt;a href=&quot;../spider/index&quot;&gt;SPIDER&lt;/a&gt;. It was included in &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; as a ready-to use plugin.</source>
          <target state="translated">HandlerSocket을 사용하면 &lt;a href=&quot;../xtradb-and-innodb/index&quot;&gt;InnoDB / XtraDB&lt;/a&gt; 및 &lt;a href=&quot;../spider/index&quot;&gt;SPIDER에&lt;/a&gt; 직접 액세스 할 수 있습니다. 바로 사용할 수있는 플러그인으로 &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; 에 포함되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4af6a2fe467d60094fc2d92ced44327b4225d7cd" translate="yes" xml:space="preserve">
          <source>HandlerSocket is a NoSQL plugin for MySQL/MariaDB. It works as a daemon inside the mysqld process, accepting TCP connections, and executing requests from clients. HandlerSocket does not support SQL queries. Instead, it supports simple CRUD operations on tables.</source>
          <target state="translated">HandlerSocket은 MySQL / MariaDB 용 NoSQL 플러그인입니다. mysqld 프로세스 내에서 데몬으로 작동하여 TCP 연결을 수락하고 클라이언트의 요청을 실행합니다. HandlerSocket은 SQL 쿼리를 지원하지 않습니다. 대신 테이블에서 간단한 CRUD 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="45d4e1035ac8a715cce918954473ef976b90567b" translate="yes" xml:space="preserve">
          <source>Handler_commit</source>
          <target state="translated">Handler_commit</target>
        </trans-unit>
        <trans-unit id="d74382b162d81ab63d3085ee39b0070f0833c9f0" translate="yes" xml:space="preserve">
          <source>Handler_delete</source>
          <target state="translated">Handler_delete</target>
        </trans-unit>
        <trans-unit id="849ecb076f50c14ca6f16bacf09ab628791474a4" translate="yes" xml:space="preserve">
          <source>Handler_discover</source>
          <target state="translated">Handler_discover</target>
        </trans-unit>
        <trans-unit id="b97162a6b991fadbaabac024778db17f3d57c875" translate="yes" xml:space="preserve">
          <source>Handler_external_lock</source>
          <target state="translated">Handler_external_lock</target>
        </trans-unit>
        <trans-unit id="7ee458abe1b28121c38af8798ed86eb656d2132b" translate="yes" xml:space="preserve">
          <source>Handler_icp_attempts</source>
          <target state="translated">Handler_icp_attempts</target>
        </trans-unit>
        <trans-unit id="103aefd1281ae75bda59c0ecd92650615f819b37" translate="yes" xml:space="preserve">
          <source>Handler_icp_match</source>
          <target state="translated">Handler_icp_match</target>
        </trans-unit>
        <trans-unit id="fb87c4ec5f823a3da0d1c3640e49287989644f2a" translate="yes" xml:space="preserve">
          <source>Handler_mrr_init</source>
          <target state="translated">Handler_mrr_init</target>
        </trans-unit>
        <trans-unit id="ad7393325f646bee773527523e617c87a19b9a4d" translate="yes" xml:space="preserve">
          <source>Handler_mrr_key_refills</source>
          <target state="translated">Handler_mrr_key_refills</target>
        </trans-unit>
        <trans-unit id="51abe9fd90b9884adc2053c5649188e90229e55b" translate="yes" xml:space="preserve">
          <source>Handler_mrr_rowid_refills</source>
          <target state="translated">Handler_mrr_rowid_refills</target>
        </trans-unit>
        <trans-unit id="b92fcc6fc0df05b5b390976c60169ce4f24912ee" translate="yes" xml:space="preserve">
          <source>Handler_prepare</source>
          <target state="translated">Handler_prepare</target>
        </trans-unit>
        <trans-unit id="98ad48eba8adbe6ab0a3fc0bf01b07654b0fe71e" translate="yes" xml:space="preserve">
          <source>Handler_read_first</source>
          <target state="translated">Handler_read_first</target>
        </trans-unit>
        <trans-unit id="d2be145d39b89e2886ba0ef04e7daacc344afa09" translate="yes" xml:space="preserve">
          <source>Handler_read_key</source>
          <target state="translated">Handler_read_key</target>
        </trans-unit>
        <trans-unit id="bbce8108531b2cec55c543fffbd2afec9827c188" translate="yes" xml:space="preserve">
          <source>Handler_read_last</source>
          <target state="translated">Handler_read_last</target>
        </trans-unit>
        <trans-unit id="43949c43a7d1c854b32acc5bfce7c9ca53d5ac74" translate="yes" xml:space="preserve">
          <source>Handler_read_next</source>
          <target state="translated">Handler_read_next</target>
        </trans-unit>
        <trans-unit id="2bd20e89052768633139fea8a7098035feff177e" translate="yes" xml:space="preserve">
          <source>Handler_read_prev</source>
          <target state="translated">Handler_read_prev</target>
        </trans-unit>
        <trans-unit id="3be470d4f823380191916fd8f99e566b3a711b52" translate="yes" xml:space="preserve">
          <source>Handler_read_retry</source>
          <target state="translated">Handler_read_retry</target>
        </trans-unit>
        <trans-unit id="ad31d5d7561b26c29ef1ab8405372c0a4fab4030" translate="yes" xml:space="preserve">
          <source>Handler_read_rnd</source>
          <target state="translated">Handler_read_rnd</target>
        </trans-unit>
        <trans-unit id="d1f6d47987999d34a35e8f58b679ebc708a38c1f" translate="yes" xml:space="preserve">
          <source>Handler_read_rnd_deleted</source>
          <target state="translated">Handler_read_rnd_deleted</target>
        </trans-unit>
        <trans-unit id="3a4841f965363e1747f49f77ba7eda0296137709" translate="yes" xml:space="preserve">
          <source>Handler_read_rnd_next</source>
          <target state="translated">Handler_read_rnd_next</target>
        </trans-unit>
        <trans-unit id="a36811258a3ea69a00b18e4e791923cdeb65afc2" translate="yes" xml:space="preserve">
          <source>Handler_rollback</source>
          <target state="translated">Handler_rollback</target>
        </trans-unit>
        <trans-unit id="673648a3008e91f980b04dc5e744ba72982bd23a" translate="yes" xml:space="preserve">
          <source>Handler_savepoint</source>
          <target state="translated">Handler_savepoint</target>
        </trans-unit>
        <trans-unit id="95e70c585c3ae45bb49ebf00a93b8c216980e4de" translate="yes" xml:space="preserve">
          <source>Handler_savepoint_rollback</source>
          <target state="translated">Handler_savepoint_rollback</target>
        </trans-unit>
        <trans-unit id="4d982c4ca571dd1f5162be4caf928f4f8ccda80e" translate="yes" xml:space="preserve">
          <source>Handler_tmp_delete</source>
          <target state="translated">Handler_tmp_delete</target>
        </trans-unit>
        <trans-unit id="bf26403a16436d77e939de7b85242842f6b4af16" translate="yes" xml:space="preserve">
          <source>Handler_tmp_update</source>
          <target state="translated">Handler_tmp_update</target>
        </trans-unit>
        <trans-unit id="1edee096958187f9c402959db9ba3d561904ec5e" translate="yes" xml:space="preserve">
          <source>Handler_tmp_write</source>
          <target state="translated">Handler_tmp_write</target>
        </trans-unit>
        <trans-unit id="f4307372709018c92b1ce4065e0062e170fa7383" translate="yes" xml:space="preserve">
          <source>Handler_update</source>
          <target state="translated">Handler_update</target>
        </trans-unit>
        <trans-unit id="6bbe1d2c51bbc4bcf6c3aea5c9c87541c36f17f5" translate="yes" xml:space="preserve">
          <source>Handler_write</source>
          <target state="translated">Handler_write</target>
        </trans-unit>
        <trans-unit id="5bbe8df485ec9aec45659ba810399e706f2f5305" translate="yes" xml:space="preserve">
          <source>Handlers comes in three types, CONTINUE, EXIT and UNDO. The latter is like an EXIT handler with an implicit rollback, and is currently not implemented. The EXIT handler jumps to the end of its BEGIN-END block when finished. The CONTINUE handler returns to the statement following that which invoked the handler.</source>
          <target state="translated">처리기는 CONTINUE, EXIT 및 UNDO의 세 가지 유형으로 제공됩니다. 후자는 암시 적 롤백이있는 EXIT 핸들러와 유사하며 현재 구현되지 않았습니다. EXIT 핸들러는 완료되면 BEGIN-END 블록의 끝으로 이동합니다. CONTINUE 핸들러는 핸들러를 호출 한 다음 명령문으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="3176e81f554a2f68ab2471daf279aa89be70c819" translate="yes" xml:space="preserve">
          <source>Handlers must be declared after local variables, a &lt;code&gt;CONDITION&lt;/code&gt; and a &lt;a href=&quot;../programmatic-and-compound-statements-cursors/index&quot;&gt;CURSOR&lt;/a&gt;.</source>
          <target state="translated">핸들러는 로컬 변수, &lt;code&gt;CONDITION&lt;/code&gt; 및 &lt;a href=&quot;../programmatic-and-compound-statements-cursors/index&quot;&gt;CURSOR&lt;/a&gt; 뒤에 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="440fc730688e472fc5066ed69f573f5727476ea6" translate="yes" xml:space="preserve">
          <source>Handlers which refer to a SQLSTATE come next.</source>
          <target state="translated">SQLSTATE를 참조하는 핸들러가 다음에옵니다.</target>
        </trans-unit>
        <trans-unit id="0d18fef746f045ef42d0d8b3e2da21f3b25d6974" translate="yes" xml:space="preserve">
          <source>Handlers which refer to an error class have the lowest precedence.</source>
          <target state="translated">에러 클래스를 참조하는 핸들러는 우선 순위가 가장 낮습니다.</target>
        </trans-unit>
        <trans-unit id="8e7de655aa50716db0b707792f8c9017f27f64d9" translate="yes" xml:space="preserve">
          <source>Handlers which refer to an error code have the highest precedence.</source>
          <target state="translated">오류 코드를 참조하는 처리기가 우선 순위가 가장 높습니다.</target>
        </trans-unit>
        <trans-unit id="1dab88b37d681f8b0e144eb0db68932a7e923caf" translate="yes" xml:space="preserve">
          <source>Handles CDR's from Cirpack UTP's.</source>
          <target state="translated">Cirpack UTP의 CDR을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="ea630e30389c261b483ea681f40d412c9ad0f62f" translate="yes" xml:space="preserve">
          <source>Handles Open Financial Connectivity files.</source>
          <target state="translated">열린 Financial Connectivity 파일을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="66fabfd69733125bfde1c211bfa2e00595894215" translate="yes" xml:space="preserve">
          <source>Handles Quicken Interchange Format files.</source>
          <target state="translated">빠른 교환 형식 파일을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="1cd1263bd48f19e517320ffab784cae1b11da380" translate="yes" xml:space="preserve">
          <source>Handles files having the Windev HyperFile format.</source>
          <target state="translated">Windev HyperFile 형식의 파일을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="0fcbb211b31b14824b9266892b89ee643543e4fa" translate="yes" xml:space="preserve">
          <source>Handling Differences in Column Order and Values</source>
          <target state="translated">열 순서 및 값의 차이 처리</target>
        </trans-unit>
        <trans-unit id="778a4fda7dec4b1b1d2b4c081a5021a377ca61a1" translate="yes" xml:space="preserve">
          <source>Handling Joins With Cassandra</source>
          <target state="translated">Cassandra와의 조인 처리</target>
        </trans-unit>
        <trans-unit id="cca845bcf0dec8aa8d09877211b0c9605dd8f0dc" translate="yes" xml:space="preserve">
          <source>Handling Too Many Connections</source>
          <target state="translated">너무 많은 연결 처리</target>
        </trans-unit>
        <trans-unit id="efc994d2121d5c6b1584bc3074a77ab0047a2928" translate="yes" xml:space="preserve">
          <source>Handling a server ping request.</source>
          <target state="translated">서버 핑 요청 처리</target>
        </trans-unit>
        <trans-unit id="bd4554c10cdf28220cd54d4f50c04df3fcab0d7b" translate="yes" xml:space="preserve">
          <source>Handling dates that are out of the range of supported CONNECT dates</source>
          <target state="translated">지원되는 CONNECT 날짜 범위를 벗어난 날짜 처리</target>
        </trans-unit>
        <trans-unit id="80e514c2a46b402c6a8221bdab3f4ffb0aeea712" translate="yes" xml:space="preserve">
          <source>Handling index errors</source>
          <target state="translated">인덱스 오류 처리</target>
        </trans-unit>
        <trans-unit id="f1194a05b67c5a83809730ad8adeff3f40b96030" translate="yes" xml:space="preserve">
          <source>Handling of &quot;critical reads&quot; is quite different (arguably better).</source>
          <target state="translated">&quot;핵심 읽기&quot;의 처리는 상당히 다릅니다 (논쟁 적으로 더 좋습니다).</target>
        </trans-unit>
        <trans-unit id="a0fe1047b1b006be680a09492c5f90b9860267a3" translate="yes" xml:space="preserve">
          <source>Handling of NULL Values</source>
          <target state="translated">NULL 값 처리</target>
        </trans-unit>
        <trans-unit id="51d93da00e8b64a1186d7799e6efc028987417e7" translate="yes" xml:space="preserve">
          <source>Handling of NULL values</source>
          <target state="translated">NULL 값 처리</target>
        </trans-unit>
        <trans-unit id="68e5f95c0fbf47ec370dd3fd3bbdc0426436cf90" translate="yes" xml:space="preserve">
          <source>Handling the UUID Data Type</source>
          <target state="translated">UUID 데이터 형식 처리</target>
        </trans-unit>
        <trans-unit id="ff33397ab8d1b352ab11f2fd6ec254ba4e6be63d" translate="yes" xml:space="preserve">
          <source>Happens in parallel replication during a &lt;a href=&quot;../flush/index&quot;&gt;FLUSH TABLES WITH READ LOCK&lt;/a&gt; or when changing number of parallel workers.</source>
          <target state="translated">&lt;a href=&quot;../flush/index&quot;&gt;읽기 잠금이&lt;/a&gt; 있는 FLUSH 테이블 또는 병렬 작업자 수를 변경할 때 병렬 복제가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="c32aab687e68ff1f4993a13ff05dfd939a6d5293" translate="yes" xml:space="preserve">
          <source>Happens in parallel replication when moving to a new binary log after a master restart. All slave temporary files are deleted and worker threads are restarted.</source>
          <target state="translated">마스터 재시작 후 새 이진 로그로 이동할 때 병렬 복제가 발생합니다. 모든 슬레이브 임시 파일이 삭제되고 작업자 스레드가 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="79c84fbaffa4b95d1514e4e8af08f49e491975e8" translate="yes" xml:space="preserve">
          <source>Hardware Optimization</source>
          <target state="translated">하드웨어 최적화</target>
        </trans-unit>
        <trans-unit id="d018e7133d14397ce648f061437e549ff6251bcd" translate="yes" xml:space="preserve">
          <source>Hardware, etc:</source>
          <target state="translated">하드웨어 등 :</target>
        </trans-unit>
        <trans-unit id="8dd145a595950079668caa857c3f6426be0a9395" translate="yes" xml:space="preserve">
          <source>Hardware? No, that's just a bandaid. The data will continue to grow and even the new hardware won't handle it.</source>
          <target state="translated">하드웨어? 아니, 그건 그냥 반창고 야 데이터는 계속 증가 할 것이며 새로운 하드웨어조차도 처리하지 못할 것입니다.</target>
        </trans-unit>
        <trans-unit id="c68ca57ce27cebea8f3afc91ea7bc59f398b6417" translate="yes" xml:space="preserve">
          <source>Has a slight storage overhead, mainly notable on very small rows</source>
          <target state="translated">아주 작은 행에서 주로 눈에 띄는 약간의 스토리지 오버 헤드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd9b9baf8ddc0124670e7511ed642b9f66c19e91" translate="yes" xml:space="preserve">
          <source>Hash Indexes</source>
          <target state="translated">해시 인덱스</target>
        </trans-unit>
        <trans-unit id="4f5954a74db2b4dd64c133a8e80ec29d67701b12" translate="yes" xml:space="preserve">
          <source>Hash based sharding features very fast row to shard lookups (this is called mapping) because no network round trip is required to calculate the lookup. The downsides are significant though, because the number of shards is fixed.</source>
          <target state="translated">해시 기반 샤딩은 조회를 계산하는 데 네트워크 왕복이 필요하지 않기 때문에 매우 빠른 행 대 샤드 조회 (매핑이라고 함) 기능이 있습니다. 그러나 샤드의 수가 고정되어 있기 때문에 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c942b78946476b52303ef34c26974c776f6b6624" translate="yes" xml:space="preserve">
          <source>Hash indexes do not permit leftmost prefixing - only the whole index can be used.</source>
          <target state="translated">해시 인덱스는 가장 왼쪽 접두사를 허용하지 않으며 전체 인덱스 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7e2bc512ff4d5d8abc534158fb7a0d0b59b30d4" translate="yes" xml:space="preserve">
          <source>Hash indexes, in contrast, can only be used for equality comparisons, so those using the = or &amp;lt;=&amp;gt; operators. They cannot be used for ordering, and provide no information to the optimizer on how many rows exist between two values.</source>
          <target state="translated">반대로 해시 인덱스는 등호 비교에만 사용할 수 있으므로 = 또는 &amp;lt;=&amp;gt; 연산자를 사용합니다. 이들은 주문에 사용될 수 없으며 두 값 사이에 존재하는 행 수에 대한 정보를 옵티 마이저에 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="722bcb2a2a54d2a77344b70445e2ad59ba5b23d3" translate="yes" xml:space="preserve">
          <source>Hash joins are utilized by ColumnStore to optimize for large scale joins and avoid the need for indexes and the overhead of nested loop processing. ColumnStore maintains table statistics so as to determine the optimal join order. This is implemented by first identifying the small table side (based on extent map data) and materializing the necessary rows from that table for the join. If the size of this is less than the configuration setting &quot;PmMaxMemorySmallSide&quot; then the join is pushed down to the PMs for distributed processing. Otherwise the larger side rows are pulled up to the UM for joining in the UM where only the where clause on that side is executed across PMs. If the join is too large for UM memory then disk based join can be enabled to allow the query to complete.</source>
          <target state="translated">해시 조인은 ColumnStore에서 대규모 조인을 최적화하고 인덱스 및 중첩 루프 처리 오버 헤드를 피하기 위해 활용됩니다. ColumnStore는 최적의 조인 순서를 결정하기 위해 테이블 ​​통계를 유지 관리합니다. 이는 먼저 Extent 맵 데이터를 기반으로 작은 테이블 측을 식별하고 해당 테이블에서 조인에 필요한 행을 구체화하여 구현됩니다. 이 크기가 구성 설정 &quot;PmMaxMemorySmallSide&quot;보다 작 으면 분산 처리를 위해 결합이 PM으로 푸시 다운됩니다. 그렇지 않으면 더 큰 사이드 행이 UM에 풀업되어 UM에 참여하여 해당 사이드의 where 절만 PM 전체에서 실행됩니다. 조인이 UM 메모리에 비해 너무 큰 경우 디스크 기반 조인을 활성화하여 쿼리를 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74b194ebf62c135598704a43f80f6499b8b2a5e2" translate="yes" xml:space="preserve">
          <source>Hash mapper</source>
          <target state="translated">해시 매퍼</target>
        </trans-unit>
        <trans-unit id="7c5927653819965b26689f563a959c8554743e4c" translate="yes" xml:space="preserve">
          <source>Hash table name</source>
          <target state="translated">해시 테이블 이름</target>
        </trans-unit>
        <trans-unit id="643cc519e5b6f0cecc84153d0d94cc7dd7b7ca5e" translate="yes" xml:space="preserve">
          <source>Hashed password, generated by the &lt;a href=&quot;../password/index&quot;&gt;PASSWORD()&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;../password/index&quot;&gt;PASSWORD ()&lt;/a&gt; 함수에 의해 생성 된 해시 비밀번호 .</target>
        </trans-unit>
        <trans-unit id="c0c271c8f62efa33d3ac8edbe0fea6e52fc84150" translate="yes" xml:space="preserve">
          <source>Haskell</source>
          <target state="translated">Haskell</target>
        </trans-unit>
        <trans-unit id="e8f38349b09b43b1f0bd891d8af11fa482bcaa97" translate="yes" xml:space="preserve">
          <source>Have 3 or more servers available and Install MariaDB on each of these servers:</source>
          <target state="translated">사용 가능한 서버가 3 대 이상이고 다음 각 서버에 MariaDB를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="a89158c27a2e8fb612c1dd22f8fab3af911a4246" translate="yes" xml:space="preserve">
          <source>Have WINS</source>
          <target state="translated">와인을 가지고</target>
        </trans-unit>
        <trans-unit id="a4e2806dcd13a433b62c313a5a30d79237c2993c" translate="yes" xml:space="preserve">
          <source>Have a 'reasonable' size for &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_log_file_size&quot;&gt;innodb_log_file_size&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_log_file_size&quot;&gt;innodb_log_file_size&lt;/a&gt; 의 크기는 '합리적' 입니다.</target>
        </trans-unit>
        <trans-unit id="ff4ac85097405aa2b419692d95c387de27021ff7" translate="yes" xml:space="preserve">
          <source>Have a CRON that serves only as a &quot;keep-alive&quot; to restart the job if it dies.</source>
          <target state="translated">작업이 종료 된 경우 작업을 다시 시작하기 위해 &quot;keep-alive&quot;역할 만하는 CRON이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="404bc663bb3bc0d026294911b0f9075f2a98d384" translate="yes" xml:space="preserve">
          <source>Have a job that flip-flops in a tight loop (no delay, or a small delay, between iterations), and</source>
          <target state="translated">타이트한 루프로 플립 플롭하는 작업을 수행하십시오 (반복 사이에 지연이 없거나 약간의 지연이 없음).</target>
        </trans-unit>
        <trans-unit id="c6455bb6b3be03ee538703372496cf4762fabbd1" translate="yes" xml:space="preserve">
          <source>Have a separate staging table.</source>
          <target state="translated">별도의 준비 테이블이 있습니다.</target>
        </trans-unit>
        <trans-unit id="562a50a4152070a15e21eff2b2630fc95a3a7c15" translate="yes" xml:space="preserve">
          <source>Have to use replication filters to avoid duplication of data.</source>
          <target state="translated">데이터 중복을 피하려면 복제 필터를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d6a8f8cf97cbc43ca01773e79e2f8773f737ac4" translate="yes" xml:space="preserve">
          <source>Having Columns defined by Discovery</source>
          <target state="translated">감지로 열을 정의한 경우</target>
        </trans-unit>
        <trans-unit id="fb072d528c1a2fc3a683c4d61eae97c8bc30f1f4" translate="yes" xml:space="preserve">
          <source>Having MyISAM not replicated can be a big benefit -- You can &quot;CREATE TEMPORARY TABLE ... ENGINE=MyISAM&quot; and have it exist on only one node. RBR assures that any data transferred from that temp table into a 'real' table can still be replicated.</source>
          <target state="translated">MyISAM을 복제하지 않으면 큰 이점이 될 수 있습니다. &quot;CREATE TEMPORARY TABLE ... ENGINE = MyISAM&quot;으로 하나의 노드에만 존재할 수 있습니다. RBR은 해당 임시 테이블에서 '실제'테이블로 전송 된 모든 데이터를 계속 복제 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="7ddaba5863a10566c486c87048058919b578822c" translate="yes" xml:space="preserve">
          <source>Having a transaction is mandatory to prevent another thread from grabbing the same id.</source>
          <target state="translated">다른 스레드가 동일한 ID를 가져 오지 못하게하려면 트랜잭션이 필수입니다.</target>
        </trans-unit>
        <trans-unit id="d2d7ce32408795274b0181cdeb0cd5774b952884" translate="yes" xml:space="preserve">
          <source>Having data encrypted will make it hard for someone to steal your data.</source>
          <target state="translated">데이터를 암호화하면 누군가가 데이터를 훔치기가 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="c09e51d932f3e5b18dbbf7bbe0572f0a08fe94a4" translate="yes" xml:space="preserve">
          <source>Having just one address in the row. These were alternative designs; they seemed to be no better, and possibly worse:</source>
          <target state="translated">행에 주소가 하나만 있습니다. 이것들은 대체 디자인이었습니다. 그들은 더 나아 보이지 않았으며 아마도 더 나빴습니다.</target>
        </trans-unit>
        <trans-unit id="abdbf6c1eca649702fd15be828c750aad4883cc0" translate="yes" xml:space="preserve">
          <source>Having tables encrypted makes it almost impossible for someone to access or steal a hard disk and get access to the original data. MariaDB got Data-at-Rest Encryption with &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt;. This functionality is also known as &quot;Transparent Data Encryption (TDE)&quot;.</source>
          <target state="translated">테이블을 암호화하면 누군가가 하드 디스크에 액세스하거나 하드 디스크를 훔쳐 원본 데이터에 액세스하는 것이 거의 불가능합니다. MariaDB는 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; 과 함께 미사용 데이터 암호화 기능을 갖습니다 . 이 기능은 &quot;투명 데이터 암호화 (TDE)&quot;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="c193a5a32e2d2aef0c151df6903e818d468aaee7" translate="yes" xml:space="preserve">
          <source>Having the &quot;future&quot; partition makes the ADD PARTITION script a little more complex. Instead, it needs to take tomorrow's data from &quot;future&quot; and put it into a new partition. This is done with the REORGANIZE command shown. Normally nothing need be moved, and the ALTER takes virtually zero time.</source>
          <target state="translated">&quot;미래&quot;파티션이 있으면 ADD PARTITION 스크립트가 조금 더 복잡해집니다. 대신 &quot;미래&quot;에서 내일의 데이터를 가져 와서 새로운 파티션에 넣어야합니다. 이것은 표시된 REORGANIZE 명령으로 수행됩니다. 일반적으로 아무것도 이동할 필요가 없으며 ALTER는 거의 제로 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="75a361048e063ffd0295405c77e0dcd7b2c45e16" translate="yes" xml:space="preserve">
          <source>Header option</source>
          <target state="translated">헤더 옵션</target>
        </trans-unit>
        <trans-unit id="a3089b7fae27bca3309070e0487079a25b8f1ede" translate="yes" xml:space="preserve">
          <source>Heading</source>
          <target state="translated">Heading</target>
        </trans-unit>
        <trans-unit id="f6bd464bf6ff7593d0206c0520a1031159f889ed" translate="yes" xml:space="preserve">
          <source>Heartbeat monitoring occurs between modules (both &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;UM&lt;/a&gt; and &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;PM&lt;/a&gt;) to determine the module us up and functioning. The module heartbeat settings are the same for all modules.</source>
          <target state="translated">하트 비트 모니터링은 모듈 ( &lt;a href=&quot;../columnstore-user-module/index&quot;&gt;Um&lt;/a&gt; 및 &lt;a href=&quot;../columnstore-performance-module/index&quot;&gt;PM&lt;/a&gt; 모두) 사이에서 발생 하여 모듈의 작동 및 작동 여부를 결정합니다. 모듈 하트 비트 설정은 모든 모듈에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7ec519834ddbbba93c7f6e83e6cd4d653c539e72" translate="yes" xml:space="preserve">
          <source>Heartbeats are sent by the master only if there are no unsent events in the binary log file for a period longer than the interval.</source>
          <target state="translated">이진 로그 파일에 간격보다 긴 시간 동안 보내지 않은 이벤트가없는 경우에만 하트 비트가 마스터에 의해 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="348d00693e12bc983bd092677b90434b5a4d869e" translate="yes" xml:space="preserve">
          <source>Hebrew</source>
          <target state="translated">Hebrew</target>
        </trans-unit>
        <trans-unit id="551dd53ce96cecf1d0223d90112ec1a0b2640bc3" translate="yes" xml:space="preserve">
          <source>HeidiSQL</source>
          <target state="translated">HeidiSQL</target>
        </trans-unit>
        <trans-unit id="856ce14620261ee288712bc4464975a3b5dab554" translate="yes" xml:space="preserve">
          <source>HeidiSQL 7.0</source>
          <target state="translated">HeidiSQL 7.0</target>
        </trans-unit>
        <trans-unit id="ff4a125f2889698d9a573a28b02c3a2c0707d2c6" translate="yes" xml:space="preserve">
          <source>HeidiSQL 8.0</source>
          <target state="translated">HeidiSQL 8.0</target>
        </trans-unit>
        <trans-unit id="3204db0aaeaac168cf589aae20e413fcd6753a2d" translate="yes" xml:space="preserve">
          <source>HeidiSQL 8.3</source>
          <target state="translated">HeidiSQL 8.3</target>
        </trans-unit>
        <trans-unit id="832755e592407a7e9ff3fbda3d642b050df0c2fd" translate="yes" xml:space="preserve">
          <source>HeidiSQL 9.1</source>
          <target state="translated">HeidiSQL 9.1</target>
        </trans-unit>
        <trans-unit id="bac95c1dc4f01b45dd8a9e7eba87e3d04183f900" translate="yes" xml:space="preserve">
          <source>HeidiSQL 9.3</source>
          <target state="translated">HeidiSQL 9.3</target>
        </trans-unit>
        <trans-unit id="398e2fe64b449573ed98f7fab0a18d38fdb23ef4" translate="yes" xml:space="preserve">
          <source>HeidiSQL 9.4</source>
          <target state="translated">HeidiSQL 9.4</target>
        </trans-unit>
        <trans-unit id="0a0daa790cdb7d718f43c04fcaf7cceec2c36d67" translate="yes" xml:space="preserve">
          <source>HeidiSQL 9.5</source>
          <target state="translated">HeidiSQL 9.5</target>
        </trans-unit>
        <trans-unit id="36018cd48d74f7e68394ea21aec2f16ceeff4bd2" translate="yes" xml:space="preserve">
          <source>HeidiSQL Version</source>
          <target state="translated">HeidiSQL 버전</target>
        </trans-unit>
        <trans-unit id="aa3c432de54065a514393847946674f12b0c7ee5" translate="yes" xml:space="preserve">
          <source>HeidiSQL can:</source>
          <target state="translated">HeidiSQL은 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7ff9e8b7bb2e09b70935a5d785e0cc5d9d0abf0" translate="yes" xml:space="preserve">
          <source>Hello</source>
          <target state="translated">Hello</target>
        </trans-unit>
        <trans-unit id="0a4d55a8d778e5022fab701977c5d840bbc486d0" translate="yes" xml:space="preserve">
          <source>Hello World</source>
          <target state="translated">안녕하세요 월드</target>
        </trans-unit>
        <trans-unit id="0da29ac7459692e73287d108d9a7af379ef390c3" translate="yes" xml:space="preserve">
          <source>Hello! I have recent php5 and php5_mysql installed from Ubuntu repos. When i'm running scripts connecting to DB i get &quot;mysql_connect(): Headers and client library minor version mismatch. Headers:50149 Library:50203&quot;.</source>
          <target state="translated">여보세요! Ubuntu repos에서 최근에 php5 및 php5_mysql을 설치했습니다. DB에 연결하는 스크립트를 실행할 때 &quot;mysql_connect () : 헤더 및 클라이언트 라이브러리 부 버전 불일치. 헤더 : 50149 라이브러리 : 50203&quot;이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="85e3da31e67d84be8b782bf9c470e06dcf0401c9" translate="yes" xml:space="preserve">
          <source>Help categories</source>
          <target state="translated">도움말 카테고리</target>
        </trans-unit>
        <trans-unit id="1e8a30c0695ffecec3efe7d4fae8972f3009a312" translate="yes" xml:space="preserve">
          <source>Help command</source>
          <target state="translated">도움말 명령</target>
        </trans-unit>
        <trans-unit id="9262d34dd5925e07423ab56f642a6fe2668337d9" translate="yes" xml:space="preserve">
          <source>Help database is corrupt or does not exist</source>
          <target state="translated">도움말 데이터베이스가 손상되었거나 존재하지 않습니다</target>
        </trans-unit>
        <trans-unit id="3b4007b845f050a919ed1aec60d36ffdcd361212" translate="yes" xml:space="preserve">
          <source>Help integrated into Microsoft Visual Studio .Net</source>
          <target state="translated">Microsoft Visual Studio .Net에 통합 도움말</target>
        </trans-unit>
        <trans-unit id="509b20163154660e755e29a0ec65dea0bf5791e8" translate="yes" xml:space="preserve">
          <source>Help keywords</source>
          <target state="translated">도움말 키워드</target>
        </trans-unit>
        <trans-unit id="5d4e77ce2f096cd7515e7142047c14671b456211" translate="yes" xml:space="preserve">
          <source>Help text, usually shown in &lt;code&gt;mysqld --help --verbose&lt;/code&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;mysqld --help --verbose&lt;/code&gt; 에 표시되는 도움말 텍스트 .</target>
        </trans-unit>
        <trans-unit id="a80370bddcaa4d1b93d43a3a6e3979aee0bc8b0e" translate="yes" xml:space="preserve">
          <source>Help the Optimizer Optimize GROUP BY and ORDER BY</source>
          <target state="translated">옵티마이 저가 GROUP BY 및 ORDER BY를 최적화하도록 지원</target>
        </trans-unit>
        <trans-unit id="7662eaa922cc9b91071e79a68c55af702c51f7fc" translate="yes" xml:space="preserve">
          <source>Help topics</source>
          <target state="translated">도움말 주제</target>
        </trans-unit>
        <trans-unit id="e47af0408791233be425bb425e00ae6a5b26cabb" translate="yes" xml:space="preserve">
          <source>Help with moving from MySQL to MariaDB, features and compatibility</source>
          <target state="translated">MySQL에서 MariaDB 로의 이동, 기능 및 호환성에 대한 도움말</target>
        </trans-unit>
        <trans-unit id="8cda7be208fc4cca8dc59f71411ef6868f7a3ff5" translate="yes" xml:space="preserve">
          <source>Help with moving from other databases to MariaDB.</source>
          <target state="translated">다른 데이터베이스에서 MariaDB로 이동하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="b033504ea193f5146f94c17ef08b9575b9424af8" translate="yes" xml:space="preserve">
          <source>Helps add users or databases or change passwords in MariaDB</source>
          <target state="translated">MariaDB에서 사용자 또는 데이터베이스 추가 또는 비밀번호 변경 지원</target>
        </trans-unit>
        <trans-unit id="5d47b2a4503fb2d22d706caa0583a591fbff915a" translate="yes" xml:space="preserve">
          <source>Hence, in order for LooseScan to be applicable, the subquery should look like:</source>
          <target state="translated">따라서 LooseScan을 적용하려면 하위 쿼리가 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="226a7752b68099e59eeadd7556ad48f44e5403f0" translate="yes" xml:space="preserve">
          <source>Henry</source>
          <target state="translated">Henry</target>
        </trans-unit>
        <trans-unit id="d37f93d15089cb41a255f20b81d6aae63b6272a3" translate="yes" xml:space="preserve">
          <source>Here &amp;ldquo;level=-1&amp;rdquo; is used to create only columns that are simple values (no array or object). Without this, with the default value &amp;ldquo;level=0&amp;rdquo; the table had been created as:</source>
          <target state="translated">여기서 &quot;level = -1&quot;은 단순한 값 (배열 또는 객체 없음) 인 열만 만드는 데 사용됩니다. 이것이 없으면 기본값 &quot;level = 0&quot;을 사용하여 테이블이 다음과 같이 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="8bccefe92e28f89eadf28c3e22979918cd51c3fd" translate="yes" xml:space="preserve">
          <source>Here '&amp;amp;|' means 'and/or'. This means that one of the sections separated by '&amp;amp;|' must be present or both of them.</source>
          <target state="translated">여기 '&amp;amp; |' '및 / 또는'을 의미합니다. 이는 섹션 중 하나가 '&amp;amp; |'로 구분됨을 의미합니다. 존재하거나 둘 다 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ec004ee61c39c07d1d3822fe0be549a1a1cb0eab" translate="yes" xml:space="preserve">
          <source>Here N represents numeric characters, C any characters, I integer bytes, S short integer bytes, and F float number bytes. The &lt;code&gt;IIII&lt;/code&gt; field contains a date in numeric format.</source>
          <target state="translated">여기서 N은 숫자, C 문자, I 정수 바이트, S 짧은 정수 바이트 및 F 부동 숫자 바이트를 나타냅니다. &lt;code&gt;IIII&lt;/code&gt; 필드는 숫자 형식의 날짜가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="36958447b51437dc8db415cc66f2f3bf86f529d9" translate="yes" xml:space="preserve">
          <source>Here again the &lt;em&gt;entry&lt;/em&gt; option is used to restrict the entry file(s) to be used inside the zip files and can be omitted if all are ok.</source>
          <target state="translated">여기서도 &lt;em&gt;entry&lt;/em&gt; 옵션은 zip 파일 내에서 사용되는 항목 파일을 제한하는 데 사용되며 모두 정상이면 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="389b371d18771d85d9f7108103c1abebce5bfb7d" translate="yes" xml:space="preserve">
          <source>Here again, the columns description was left to CONNECT when creating the table.</source>
          <target state="translated">여기서도 테이블을 작성할 때 열 설명이 CONNECT로 남겨졌습니다.</target>
        </trans-unit>
        <trans-unit id="1f1e5d925b30095148ec655d37fc963a87e92e04" translate="yes" xml:space="preserve">
          <source>Here are a few of the common utilities that are used to view and troubleshoot issues. All of these commands are located in /usr/local/mariadb/columnstore/bin/</source>
          <target state="translated">다음은 문제를보고 해결하는 데 사용되는 몇 가지 일반적인 유틸리티입니다. 이 모든 명령은 / usr / local / mariadb / columnstore / bin /에 있습니다.</target>
        </trans-unit>
        <trans-unit id="735133289572f52414261a8de8a08bc286f6dd62" translate="yes" xml:space="preserve">
          <source>Here are a few resources for those interested in GIS in MariaDB.</source>
          <target state="translated">다음은 MariaDB의 GIS에 관심이있는 사람들을위한 몇 가지 리소스입니다.</target>
        </trans-unit>
        <trans-unit id="9999c42fc9bdfbd1e5aa608e9d79016c28007ecb" translate="yes" xml:space="preserve">
          <source>Here are descriptions of the values for some of the more complex columns in &lt;code&gt;EXPLAIN ... SELECT&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;EXPLAIN ... SELECT&lt;/code&gt; 의 좀 더 복잡한 열의 값에 대한 설명입니다 .</target>
        </trans-unit>
        <trans-unit id="c876fa5a216df8cab91f7cc2107bec5d9ddd8267" translate="yes" xml:space="preserve">
          <source>Here are some common use cases for Galera replication:</source>
          <target state="translated">Galera 복제의 일반적인 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bbd3cfb5db5e36e03b6836f17b985c48e09deef2" translate="yes" xml:space="preserve">
          <source>Here are some examples that show the performance impact of the subquery cache (these tests were made on a 2.53 GHz Intel Core 2 Duo MacBook Pro with dbt-3 scale 1 data set).</source>
          <target state="translated">다음은 하위 쿼리 캐시의 성능 영향을 보여주는 몇 가지 예입니다 (이 테스트는 dbt-3 스케일 1 데이터 세트가있는 2.53GHz Intel Core 2 Duo MacBook Pro에서 수행되었습니다).</target>
        </trans-unit>
        <trans-unit id="4da7f8d44797ffb3b8279869be3327ce46c9f19a" translate="yes" xml:space="preserve">
          <source>Here are some examples to clarify this. In this case we assume there is an index on columns &lt;code&gt;(a,b,c)&lt;/code&gt;</source>
          <target state="translated">이를 명확히하는 몇 가지 예가 있습니다. 이 경우 열 &lt;code&gt;(a,b,c)&lt;/code&gt; 에 색인이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="be2f7ceccc6a5c2e8d284a84f46fc3659eb00390" translate="yes" xml:space="preserve">
          <source>Here are some explanations:</source>
          <target state="translated">다음은 몇 가지 설명입니다.</target>
        </trans-unit>
        <trans-unit id="f2f838636729f656e91c8df52e82dc69128a5f8f" translate="yes" xml:space="preserve">
          <source>Here are the correspondences between the column type and field format provided by default:</source>
          <target state="translated">다음은 기본적으로 제공되는 열 유형과 필드 형식 사이의 대응 관계입니다.</target>
        </trans-unit>
        <trans-unit id="9ae0880ef99480bd9a239c65826b414906ef3fa3" translate="yes" xml:space="preserve">
          <source>Here are the detailed steps for installing MariaDB (version 10.1.21) via RPMs on CentOS 7.</source>
          <target state="translated">CentOS 7에서 RPM을 통해 MariaDB (버전 10.1.21)를 설치하는 자세한 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ed2c7085b27c91089859d8e3e6778e3fbd5d373d" translate="yes" xml:space="preserve">
          <source>Here are the items that are tested/check during the running of this tool:</source>
          <target state="translated">이 도구를 실행하는 동안 테스트 / 검사되는 항목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b62d80bf44a66f7d74dd03d33c530754d9c07382" translate="yes" xml:space="preserve">
          <source>Here are the steps to install MariaDB near an existing MySQL installation.</source>
          <target state="translated">기존 MySQL 설치 근처에 MariaDB를 설치하는 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fb96c81079d09cd9edd88afeb00338a35ba95b96" translate="yes" xml:space="preserve">
          <source>Here are three views to demonstrate the WITH CHECK OPTION clause.</source>
          <target state="translated">WITH CHECK OPTION 절을 설명하기위한 세 가지보기가 있습니다.</target>
        </trans-unit>
        <trans-unit id="69f4862ce8300e639e23bba75115a45975de0837" translate="yes" xml:space="preserve">
          <source>Here column values are directly represented by the TD tag text. You cannot declare them as tags nor as attributes. In addition, they are not located using their name but by their position within the row. Here is how to declare such a table to CONNECT:</source>
          <target state="translated">여기에서 열 값은 TD 태그 텍스트로 직접 표시됩니다. 태그 나 속성으로 선언 할 수 없습니다. 또한 이름을 사용하지 않고 행 내 위치에 따라 위치합니다. 이러한 테이블을 CONNECT로 선언하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea8a7a4c165a3c064bd6308fcfd92dcc288a2a03" translate="yes" xml:space="preserve">
          <source>Here is a 'simple' (but not 'free') way to assure that a read-after-write, even from a different connection, will see the updated data.</source>
          <target state="translated">다음은 다른 연결에서도 쓰기 후 읽기가 업데이트 된 데이터를 볼 수 있도록하는 '단순'( '무료'아님) 방법입니다.</target>
        </trans-unit>
        <trans-unit id="6fd57ca2f3982c81637da43f92fd04d015bfa9e1" translate="yes" xml:space="preserve">
          <source>Here is a complete list of these commands:</source>
          <target state="translated">다음은 이러한 명령의 전체 목록입니다.</target>
        </trans-unit>
        <trans-unit id="4fd5df58b0a92fa0302dbc13f641b3580e71fdef" translate="yes" xml:space="preserve">
          <source>Here is a couple of examples of a configuration issue that could cause this situation.</source>
          <target state="translated">다음은 이러한 상황을 유발할 수있는 구성 문제의 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="8048f6686acbb245d26c99537ff9a5df3c1a3893" translate="yes" xml:space="preserve">
          <source>Here is a flowchart showing how atomic writes work inside InnoDB:</source>
          <target state="translated">원자 쓰기가 InnoDB 내에서 작동하는 방법을 보여주는 순서도는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="85457f77ff04fbbf5023147f2c4d1713d76d6059" translate="yes" xml:space="preserve">
          <source>Here is a link to the &quot;Preparing For ColumnStore Installation&quot; document:</source>
          <target state="translated">다음은 &quot;ColumStore 설치 준비&quot;문서에 대한 링크입니다.</target>
        </trans-unit>
        <trans-unit id="04e15b700cd74348776d9d52c900a53439274a5b" translate="yes" xml:space="preserve">
          <source>Here is a link to the initial setup document that you will need to follow:</source>
          <target state="translated">다음은 따라야 할 초기 설정 문서에 대한 링크입니다.</target>
        </trans-unit>
        <trans-unit id="d4d3a0c5e26bb4181d4e682c363eccf7f30fa270" translate="yes" xml:space="preserve">
          <source>Here is a list of environment variables used by MariaDB.</source>
          <target state="translated">다음은 MariaDB가 사용하는 환경 변수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f4b21c985343b7ff72f2a9d2cfd11416ef6f3fb3" translate="yes" xml:space="preserve">
          <source>Here is a moot question. If all you've been doing is &lt;code&gt;SELECT&lt;/code&gt;s, so that there have been no data changes, should you end the transaction with &lt;code&gt;ROLLBACK&lt;/code&gt; or &lt;code&gt;COMMIT&lt;/code&gt;? It shouldn't really matter because both &lt;code&gt;ROLLBACK&lt;/code&gt; and &lt;code&gt;COMMIT&lt;/code&gt; do the same transaction-terminating job. However, the popular conception is that &lt;code&gt;ROLLBACK&lt;/code&gt; implies failure, so after a successful series of &lt;code&gt;SELECT&lt;/code&gt; statements the convention is to end the transaction with &lt;code&gt;COMMIT&lt;/code&gt; rather than &lt;code&gt;ROLLBACK&lt;/code&gt;.</source>
          <target state="translated">여기에 무질서한 질문이 있습니다. 데이터 변경 사항이 없도록 &lt;code&gt;SELECT&lt;/code&gt; 만 수행 하면 &lt;code&gt;ROLLBACK&lt;/code&gt; 또는 &lt;code&gt;COMMIT&lt;/code&gt; 트랜잭션을 종료해야 합니까? &lt;code&gt;ROLLBACK&lt;/code&gt; 과 &lt;code&gt;COMMIT&lt;/code&gt; 모두 동일한 트랜잭션 종료 작업을 수행 하므로 실제로 중요하지 않습니다 . 그러나 대중적인 개념은 &lt;code&gt;ROLLBACK&lt;/code&gt; 이 실패를 의미하므로 일련의 &lt;code&gt;SELECT&lt;/code&gt; 문이 성공한 후에 는 규칙이 &lt;code&gt;ROLLBACK&lt;/code&gt; 대신 &lt;code&gt;COMMIT&lt;/code&gt; 로 트랜잭션을 종료하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="4e313b485dae9f164c60642b22e2a83a3521e726" translate="yes" xml:space="preserve">
          <source>Here is a more complex way to design the system, with the goal of even more scaling.</source>
          <target state="translated">더 많은 스케일링을 목표로 시스템을 설계하는보다 복잡한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="33bd4844d007ae62cfae87cd650a64baab5eae1e" translate="yes" xml:space="preserve">
          <source>Here is a short description of how to generate a tar file from a source distribution. If you have &lt;a href=&quot;http://downloads.askmonty.org/mariadb/&quot;&gt;downloaded&lt;/a&gt; a binary tar file, you can skip this section.</source>
          <target state="translated">다음은 소스 배포에서 tar 파일을 생성하는 방법에 대한 간단한 설명입니다. 이진 tar 파일 을 &lt;a href=&quot;http://downloads.askmonty.org/mariadb/&quot;&gt;다운로드&lt;/a&gt; 한 경우이 섹션을 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d151dbbaa882c99754f166e93b23ad185ca081a" translate="yes" xml:space="preserve">
          <source>Here is a simple demonstration exporting a dataframe containing numbers from 0 to 127 and their ASCII representation using ColumnStoreExporter into an existing table created with following DDL:</source>
          <target state="translated">다음은 0에서 127까지의 숫자가 포함 된 데이터 프레임과 ColumnStoreExporter를 사용하는 ASCII 표현을 다음 DDL로 만든 기존 테이블로 내보내는 간단한 데모입니다.</target>
        </trans-unit>
        <trans-unit id="0453de58f89f072b6952752eccab2fb842eb5b41" translate="yes" xml:space="preserve">
          <source>Here is a sketch of the code:</source>
          <target state="translated">다음은 코드 스케치입니다.</target>
        </trans-unit>
        <trans-unit id="b823b2ff18b29cc7e7e77a8fb2dfeac1a649ee1b" translate="yes" xml:space="preserve">
          <source>Here is a summary of the new features included in this preview release. The headings link to more detailed information.</source>
          <target state="translated">다음은이 평가판에 포함 된 새로운 기능에 대한 요약입니다. 제목은 더 자세한 정보로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="3d6a98caaa80ce3c511112ccecf4885650620f19" translate="yes" xml:space="preserve">
          <source>Here is a summary table of the status of replication between different combination of master and slave servers and checksum enabled/disabled:</source>
          <target state="translated">다음은 서로 다른 마스터 서버와 슬레이브 서버 조합 및 체크섬 활성화 / 비활성화 간의 복제 상태에 대한 요약 표입니다.</target>
        </trans-unit>
        <trans-unit id="e9c41d8b6e201fee58306ef15a40daca19461623" translate="yes" xml:space="preserve">
          <source>Here is a typical pattern for a Dimension table:</source>
          <target state="translated">다음은 차원 테이블의 일반적인 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="d5b94b668f2d27594fdfe16daa46a66b5b8f584a" translate="yes" xml:space="preserve">
          <source>Here is an article showing up to ten times improvement when using parallel replication: &lt;a href=&quot;http://kristiannielsen.livejournal.com/18435.html&quot;&gt;http://kristiannielsen.livejournal.com/18435.html&lt;/a&gt;.</source>
          <target state="translated">다음은 병렬 복제 사용할 경우 열 배 향상까지 보여주는 기사입니다 &lt;a href=&quot;http://kristiannielsen.livejournal.com/18435.html&quot;&gt;http://kristiannielsen.livejournal.com/18435.html을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab4601038071e90a3110c691f3d278bb312c50c8" translate="yes" xml:space="preserve">
          <source>Here is an example</source>
          <target state="translated">여기에 예가 있습니다</target>
        </trans-unit>
        <trans-unit id="83433d4c608b9821b5fc1f123039257fb460c3d0" translate="yes" xml:space="preserve">
          <source>Here is an example backup directory:</source>
          <target state="translated">백업 디렉토리의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="13c32f53d05766a62ce948fff459b0ae6c768e0e" translate="yes" xml:space="preserve">
          <source>Here is an example create statement and search query:</source>
          <target state="translated">다음은 create statement 및 search query 예제입니다.</target>
        </trans-unit>
        <trans-unit id="083dfb2babe22b8ff2dde1586e73f9fc798f3549" translate="yes" xml:space="preserve">
          <source>Here is an example file with two tables, t1 and t2 both in the test database.</source>
          <target state="translated">다음은 테스트 데이터베이스에 두 개의 테이블 (t1 및 t2)이있는 예제 파일입니다.</target>
        </trans-unit>
        <trans-unit id="b99ac6f590908bc8d42e85547e2ed5b89ec5fa0a" translate="yes" xml:space="preserve">
          <source>Here is an example how to activate and use the sync points:</source>
          <target state="translated">다음은 동기 점을 활성화하고 사용하는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="b1c064304522b12caf541222f80f3f3de14189af" translate="yes" xml:space="preserve">
          <source>Here is an example of a BIN table. The file record layout is supposed to be:</source>
          <target state="translated">다음은 BIN 테이블의 예입니다. 파일 레코드 레이아웃은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86b96daa63a18b8b912a559d685de4592def9a39" translate="yes" xml:space="preserve">
          <source>Here is an example of a minimal &lt;code&gt;CREATE EVENT&lt;/code&gt; statement:</source>
          <target state="translated">다음은 최소 &lt;code&gt;CREATE EVENT&lt;/code&gt; 문의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="a5656fde88175a5fe7139b071061ee04f42f4d24" translate="yes" xml:space="preserve">
          <source>Here is an example of a new table that can be created on the same file, allowing choosing the column names, to get some sub-objects and to specify how to handle the author array.</source>
          <target state="translated">다음은 동일한 파일에서 작성하여 열 이름을 선택하고 일부 하위 오브젝트를 가져오고 작성자 배열을 처리하는 방법을 지정할 수있는 새 테이블의 예입니다.</target>
        </trans-unit>
        <trans-unit id="4996f6dc6a74ac393e30a00fae37a6020ce89db4" translate="yes" xml:space="preserve">
          <source>Here is an example of a very simple, anonymous block:</source>
          <target state="translated">다음은 매우 간단한 익명 블록의 예입니다.</target>
        </trans-unit>
        <trans-unit id="10d7186b288dac7cb2b0c6b29dacf01f959f96ac" translate="yes" xml:space="preserve">
          <source>Here is an example of it getting run the the report that is generated:</source>
          <target state="translated">다음은 생성 된 보고서를 실행하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="62bae27c960e2e0992163939111dba0b3bca2af8" translate="yes" xml:space="preserve">
          <source>Here is an example of moving dbroot 2 from pm2 to pm1. Run this command from the Parent OAM module. If these leaves pm2 without a dbroot assigned, that module will need to be disabled. System will not start up if there is a pm without a dbroot assigned to it.</source>
          <target state="translated">다음은 dbroot 2를 pm2에서 pm1로 이동하는 예입니다. Parent OAM 모듈에서이 명령을 실행하십시오. dbroot가 할당되지 않은 상태에서 pm2를 떠나면 해당 모듈을 비활성화해야합니다. dbroot가 할당되지 않은 오후가 있으면 시스템이 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c83f000713f9e105addd8640e64263f32f534058" translate="yes" xml:space="preserve">
          <source>Here is an example of the dramatic impact histogram-based statistics can make. The query is based on &lt;a href=&quot;../dbt3-benchmark-queries/index#q20&quot;&gt;DBT3 Benchmark Q20&lt;/a&gt; with 60 millions records in the &lt;code&gt;lineitem&lt;/code&gt; table.</source>
          <target state="translated">다음은 히스토그램 기반 통계가 미칠 수있는 극적인 영향의 예입니다. 쿼리는 &lt;code&gt;lineitem&lt;/code&gt; 테이블 에 6 천만 개의 레코드가있는 &lt;a href=&quot;../dbt3-benchmark-queries/index#q20&quot;&gt;DBT3 벤치 마크 Q20&lt;/a&gt; 을 기반으로 합니다.</target>
        </trans-unit>
        <trans-unit id="9dd856b8556f66573df25f77b3f6b62b0c9406ef" translate="yes" xml:space="preserve">
          <source>Here is an example of the problem:</source>
          <target state="translated">다음은 문제의 예입니다.</target>
        </trans-unit>
        <trans-unit id="c654c0b7418a8d79803f87cef3c1bc7ae6dcc7b0" translate="yes" xml:space="preserve">
          <source>Here is an example of two tables that would be rejected in &lt;a href=&quot;../what-is-mariadb-105/index&quot;&gt;MariaDB 10.5&lt;/a&gt; and warned about in the other listed versions:</source>
          <target state="translated">다음은 &lt;a href=&quot;../what-is-mariadb-105/index&quot;&gt;MariaDB 10.5&lt;/a&gt; 에서 거부되고 나열된 다른 버전에서 경고 되는 두 테이블의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="4c249728b7b71766e93af55d35bd806bab21865b" translate="yes" xml:space="preserve">
          <source>Here is an example of what is printed by the post-install command</source>
          <target state="translated">다음은 설치 후 명령으로 인쇄되는 예입니다.</target>
        </trans-unit>
        <trans-unit id="2503de491f3e740cb9c67259be10b575cddaadd6" translate="yes" xml:space="preserve">
          <source>Here is an example showing how to create a user with resource limits:</source>
          <target state="translated">다음은 리소스 제한이있는 사용자를 만드는 방법을 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="b227de1b302a9d4069ff2e974f576a4488fc8b10" translate="yes" xml:space="preserve">
          <source>Here is an example showing how to set an account's resource limits:</source>
          <target state="translated">다음은 계정의 리소스 제한을 설정하는 방법을 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="f34627d1ac437e20bd0ce25b52a45738054394e1" translate="yes" xml:space="preserve">
          <source>Here is an example showing how to set resource limits:</source>
          <target state="translated">다음은 리소스 제한을 설정하는 방법을 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="1f25b6a9cf111948dc1afffb4148672a2e4163b9" translate="yes" xml:space="preserve">
          <source>Here is an example table that uses both &lt;code&gt;VIRTUAL&lt;/code&gt; and &lt;code&gt;PERSISTENT&lt;/code&gt; virtual columns:</source>
          <target state="translated">다음은 &lt;code&gt;VIRTUAL&lt;/code&gt; 및 &lt;code&gt;PERSISTENT&lt;/code&gt; 가상 열을 모두 사용하는 테이블 예입니다 .</target>
        </trans-unit>
        <trans-unit id="5ef0297e5502453b1d96ab4762c5518efdf3364e" translate="yes" xml:space="preserve">
          <source>Here is an example where an error is detected. When the 'continue' option is not specified, a prompt is given to the user to exit or continue the test once an error has been detected.</source>
          <target state="translated">다음은 오류가 감지 된 예입니다. 'continue'옵션을 지정하지 않으면 오류가 감지되면 테스트를 종료하거나 계속하라는 메시지가 사용자에게 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="98430ebd60f1355a89ea2e7fb7f4e2025b4bd4d7" translate="yes" xml:space="preserve">
          <source>Here is another example showing that one can choose what to extract from the file and how to &amp;ldquo;expand&amp;rdquo; an array, meaning to generate one row for each array value:</source>
          <target state="translated">다음은 파일에서 추출 할 대상과 배열을 &quot;확장&quot;하는 방법을 선택할 수 있음을 보여주는 또 다른 예입니다. 이는 각 배열 값에 대해 하나의 행을 생성하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="59cf5bcedafda709c1e468bba650bfa0a1bcf3a9" translate="yes" xml:space="preserve">
          <source>Here is example output from &lt;a href=&quot;../mysqlbinlog/index&quot;&gt;mysqlbinlog&lt;/a&gt; that shows how GTID events are marked with commit id. The GTID 0-1-47 has no commit id, and can not run in parallel. The GTIDs 0-1-48 and 0-1-49 have the same commit id 630, and can thus replicate in parallel with one another on a slave:</source>
          <target state="translated">다음은 GTID 이벤트가 커밋 ID로 표시되는 방법을 보여주는 &lt;a href=&quot;../mysqlbinlog/index&quot;&gt;mysqlbinlog의&lt;/a&gt; 출력 예 입니다. GTID 0-1-47에는 커밋 ID가 없으며 병렬로 실행할 수 없습니다. GTID 0-1-48 및 0-1-49는 동일한 커밋 ID 630을 가지므로 슬레이브에서 서로 병렬로 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bed05d72a1e0468ef64b28a74ee1b8b2b879b5e" translate="yes" xml:space="preserve">
          <source>Here is how to execute the tool. Example is showing a root install</source>
          <target state="translated">도구를 실행하는 방법은 다음과 같습니다. 예는 루트 설치를 보여줍니다</target>
        </trans-unit>
        <trans-unit id="99c960d838ec16588c92094414086b436e03dd36" translate="yes" xml:space="preserve">
          <source>Here is how to run it:</source>
          <target state="translated">실행 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f96c90d18aebe62b827969d02d1706b61051d2b" translate="yes" xml:space="preserve">
          <source>Here is one example of when this problem has been seen. The setting of innodb_buffer_pool_size in my.cnf is set to high. In general, it shouldn't be set any higher than 50GB or 25% of the total memory.</source>
          <target state="translated">다음은이 문제가 발생한 경우의 예입니다. my.cnf의 innodb_buffer_pool_size 설정이 high로 설정되었습니다. 일반적으로 전체 메모리의 50GB 또는 25 %보다 높게 설정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="a224c1686e3100afc56160c7493c16f90ee47ea2" translate="yes" xml:space="preserve">
          <source>Here is some links to Amazon on what the IAM is and how to set it up.</source>
          <target state="translated">다음은 IAM의 정의 및 설정 방법에 대한 Amazon 링크입니다.</target>
        </trans-unit>
        <trans-unit id="435d43dd66ed101a2938e5b224b37003d1ccab27" translate="yes" xml:space="preserve">
          <source>Here is the EC2 API Tools commands that the MariaDB ColumnStore Software calls:</source>
          <target state="translated">MariaDB ColumnStore 소프트웨어가 호출하는 EC2 API 도구 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="90283566df58d4c55d8e3f68e5107e8a92443fd7" translate="yes" xml:space="preserve">
          <source>Here is the configuration file you should have in &lt;code&gt;/etc/maxscale.cnf&lt;/code&gt; on &lt;code&gt;MaxScale-2&lt;/code&gt; to achieve the above.</source>
          <target state="translated">위를 달성하기 위해 &lt;code&gt;MaxScale-2&lt;/code&gt; 의 &lt;code&gt;/etc/maxscale.cnf&lt;/code&gt; 에 있는 구성 파일은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="08ba4437832bc58f3bdf650b44d4524648973f0d" translate="yes" xml:space="preserve">
          <source>Here is the error message for dependencies:</source>
          <target state="translated">종속성에 대한 오류 메시지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8307ad43feacbea18ffd9f53c8c19b1d3c703b26" translate="yes" xml:space="preserve">
          <source>Here is the explain output for the above query:</source>
          <target state="translated">위 쿼리에 대한 Explain 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="46a896792a9db666290eb6b6a0f980883df42dd7" translate="yes" xml:space="preserve">
          <source>Here is the list of the CONNECT functions; more can be added if required.</source>
          <target state="translated">다음은 CONNECT 기능 목록입니다. 필요한 경우 더 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba3f6bce002c5b248c823a964b6745a0245343ad" translate="yes" xml:space="preserve">
          <source>Here is the list:</source>
          <target state="translated">목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34d5d18c9a6b9a8d522c65098036a284307bc2a7" translate="yes" xml:space="preserve">
          <source>Here is the one audit record generated for each query event:</source>
          <target state="translated">각 쿼리 이벤트에 대해 생성 된 하나의 감사 레코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="65e5a60059599a9efca9b2b948bd0ebf71a4723a" translate="yes" xml:space="preserve">
          <source>Here is the procedure to download and build the boost source. As root do the following:</source>
          <target state="translated">다음은 부스트 ​​소스를 다운로드하고 빌드하는 절차입니다. 루트로서 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="bfacf260d7bae24eb09dd1d221422dbf62f20d02" translate="yes" xml:space="preserve">
          <source>Here is the procedure to download and build the boost source:</source>
          <target state="translated">부스트 소스를 다운로드하고 빌드하는 절차는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15d6e662e2da82f800c5928a7c0370b599b94214" translate="yes" xml:space="preserve">
          <source>Here is the process on how to recover. Run from PM1</source>
          <target state="translated">다음은 복구 방법에 대한 프로세스입니다. PM1에서 실행</target>
        </trans-unit>
        <trans-unit id="9430ca6fa9c71d6b749cebdba9f54c2f02d2bee4" translate="yes" xml:space="preserve">
          <source>Here is the steps to achieve that. Note this examples shows update a 2 User Module system with 2 ExeMgrs. If you had 3 or more, than you would run the setConfig command the additional times.</source>
          <target state="translated">이를 달성하기위한 단계는 다음과 같습니다. 이 예는 2 개의 ExeMgr로 2 개의 사용자 모듈 시스템을 업데이트하는 것을 보여줍니다. 3 개 이상이있는 경우 setConfig 명령을 추가로 실행하는 것보다 더 많습니다.</target>
        </trans-unit>
        <trans-unit id="582eb7c97676b78559654a7ae2b3a2697d6d580b" translate="yes" xml:space="preserve">
          <source>Here is the steps, run from PM1: (reminder, all changes to the config file need to be made on PM1)</source>
          <target state="translated">다음은 PM1에서 실행되는 단계입니다. (알림, 구성 파일에 대한 모든 변경은 PM1에서 수행해야합니다.)</target>
        </trans-unit>
        <trans-unit id="f6b6210c9d211074f50cca8a5da8c29bad6bf71f" translate="yes" xml:space="preserve">
          <source>Here it can be seen that the extent maps for the o_orderdate (object id 3032) column are well partitioned since the order table source data was sorted by the order_date. This example shows 2 seperate DBRoot values as the environment was a 2 node combined deployment.</source>
          <target state="translated">여기서 오더 테이블 소스 데이터가 order_date로 정렬되었으므로 o_orderdate (오브젝트 ID 3032) 컬럼의 범위 맵이 잘 분할되어 있음을 알 수 있습니다. 이 예는 환경이 2 노드 결합 배치이므로 2 개의 개별 DBRoot 값을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4b1c2cb24218ef098add81589cce5701a364480a" translate="yes" xml:space="preserve">
          <source>Here one can see that a temporary table with a primary key was used to avoid producing multiple records with 'Germany'.</source>
          <target state="translated">여기서 'Germany'를 사용하여 여러 레코드를 생성하지 않도록 기본 키가있는 임시 테이블이 사용되었음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0edc182dcedffb0454b9db5febf308b0330883a" translate="yes" xml:space="preserve">
          <source>Here some &lt;em&gt;flag&lt;/em&gt; options were not specified because the fields have no intermediate space between them except for the last column. The offsets are calculated by default adding the field length to the &lt;em&gt;offset&lt;/em&gt; of the preceding field. However, for formatted date columns, the offset in the file depends on the format and cannot be calculated by default. For fixed files, the &lt;em&gt;lrecl&lt;/em&gt; option is the physical length of the record including the line ending character(s). It is calculated by adding to the end of the last field 2 bytes under Windows (CRLF) or 1 byte under UNIX. If the file is imported from another operating system, the &lt;code&gt;ENDING&lt;/code&gt; option will have to be specified with the proper value.</source>
          <target state="translated">여기 에는 마지막 열을 제외하고 필드 사이에 중간 공간이 없기 때문에 일부 &lt;em&gt;플래그&lt;/em&gt; 옵션이 지정되지 않았습니다. 오프셋은 기본적으로 필드 길이를 이전 필드 의 &lt;em&gt;오프셋&lt;/em&gt; 에 추가하여 계산됩니다 . 그러나 형식이 지정된 날짜 열의 경우 파일의 오프셋은 형식에 따라 다르며 기본적으로 계산할 수 없습니다. 고정 파일의 경우 &lt;em&gt;lrecl&lt;/em&gt; 옵션은 줄 끝 문자를 포함하여 레코드의 실제 길이입니다. 마지막 필드의 끝에 Windows (CRLF)에서 2 바이트 또는 UNIX에서 1 바이트를 추가하여 계산됩니다. 다른 운영 체제에서 파일을 가져 오는 경우 &lt;code&gt;ENDING&lt;/code&gt; 옵션을 적절한 값으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="441d2344f8f33f2ddef5e6e1be1dd1ecfe2f2625" translate="yes" xml:space="preserve">
          <source>Here the &lt;em&gt;entry&lt;/em&gt; option is the pattern that the files inside the zip file must match. If all entry files are ok, the &lt;em&gt;entry&lt;/em&gt; option can be omitted but the Boolean option &lt;em&gt;mulentries&lt;/em&gt; must be specified as true.</source>
          <target state="translated">여기에서 &lt;em&gt;입력&lt;/em&gt; 옵션은 zip 파일 내의 파일이 일치해야하는 패턴입니다. 모든 입력 파일이 &lt;em&gt;정상&lt;/em&gt; 이면 &lt;em&gt;입력&lt;/em&gt; 옵션을 생략 할 수 있지만 부울 옵션 &lt;em&gt;mulentries&lt;/em&gt; 는 true로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a31769947a1967160e8d3ffde84acdd89cf06505" translate="yes" xml:space="preserve">
          <source>Here the binary json tree allocated by &lt;em&gt;Jbin_Array&lt;/em&gt; is completed by &lt;em&gt;Jbin_Array_Add&lt;/em&gt; and &lt;em&gt;Json_Object&lt;/em&gt; and serialized only once to make the final result string. It would be serialized and parsed two more times if using &amp;ldquo;Json&amp;rdquo; functions.</source>
          <target state="translated">여기서 &lt;em&gt;Jbin_Array&lt;/em&gt; 에 의해 할당 된 이진 json 트리는 &lt;em&gt;Jbin_Array_Add&lt;/em&gt; 및 &lt;em&gt;Json_Object에&lt;/em&gt; 의해 완료되고 최종 결과 문자열을 만들기 위해 한 번만 직렬화됩니다. &amp;ldquo;Json&amp;rdquo;기능을 사용하면 직렬화되고 두 번 더 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="b508791c7f6af8fb7be5a7a684d34019826e625c" translate="yes" xml:space="preserve">
          <source>Here the column definition is not given and will come from the Select statement following the Create. The CONNECT options are the same we have seen previously. This will do both actions, creating the matching &lt;em&gt;handlers&lt;/em&gt; CONNECT table and 'filling' it with the query result.</source>
          <target state="translated">여기에서는 열 정의가 제공되지 않으며 Create 다음에 나오는 Select 문에서 제공됩니다. CONNECT 옵션은 이전에 본 것과 동일합니다. 일치하는 &lt;em&gt;핸들러&lt;/em&gt; CONNECT 테이블을 작성하고이를 쿼리 결과로 '채우는' 두 조치를 모두 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="53dfc8dccd1af5a3f6f97e747c9de93f9eb2f8b7" translate="yes" xml:space="preserve">
          <source>Here the different column tags are included in &lt;code&gt;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&lt;/code&gt; tags as for HTML tables. You cannot just add this tag in the Xpath of the columns, because the search is done on the first occurrence of each tag, and this would cause this search to fail for all columns except the first one. This case is handled by specifying the &lt;em&gt;Colnode&lt;/em&gt; table option that gives the name of these column tags, for example:</source>
          <target state="translated">여기서 HTML 테이블 과 같이 다른 열 태그가 &lt;code&gt;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&lt;/code&gt; 태그에 포함됩니다. 각 태그의 첫 번째 항목에서 검색이 수행되므로 첫 번째 태그를 제외한 모든 열에 대해이 검색이 실패하므로 열의 Xpath에이 태그를 추가 할 수 없습니다. 이 경우는 이러한 열 태그의 이름을 제공하는 &lt;em&gt;Colnode&lt;/em&gt; 테이블 옵션을 지정하여 처리됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de0e8f5746345dcfb2576138892097bb9eb7c7fc" translate="yes" xml:space="preserve">
          <source>Here the files to load are specified with wildcard characters and the &lt;em&gt;mulentries&lt;/em&gt; options must be specified. However, the &lt;em&gt;entry&lt;/em&gt; option must not be specified, entry names will be made from the file names.</source>
          <target state="translated">여기서로드 할 파일은 와일드 카드 문자로 지정되며 &lt;em&gt;mulentries&lt;/em&gt; 옵션을 지정해야합니다. 그러나 &lt;em&gt;항목&lt;/em&gt; 옵션을 지정하지 않아야합니다. 파일 이름에서 항목 이름이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="383ed575a55b5740ea33a580b00fd6f47dfcb077" translate="yes" xml:space="preserve">
          <source>Here the first two hits emit the signal, the third hit returns the error message and kills the query.</source>
          <target state="translated">여기에서 처음 두 개의 적중이 신호를 방출하고 세 번째 적중은 오류 메시지를 리턴하고 쿼리를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="dba00bde81b85b1dba34bc3527372136d1ba2af7" translate="yes" xml:space="preserve">
          <source>Here the flag column option represents the offset of this column inside the records. If the offset of a column is not specified, it defaults to the end of the previous column and defaults to 0 for the first one. The &lt;em&gt;&lt;code&gt;lrecl&lt;/code&gt;&lt;/em&gt; parameter that represents the maximum size of a record is calculated by default as the end of the rightmost column and can be unspecified except when some trailing information exists after the rightmost column.</source>
          <target state="translated">여기서 플래그 열 옵션은 레코드 내에서이 열의 오프셋을 나타냅니다. 열 오프셋이 지정되지 않은 경우 기본값은 이전 열의 끝이며 기본값은 0입니다. &lt;em&gt; &lt;code&gt;lrecl&lt;/code&gt; &lt;/em&gt; 레코드의 최대 크기를 나타내는 매개 변수는 가장 오른쪽 열의 단부 기본적으로 계산되고 후단 일부 정보는 가장 오른쪽 컬럼 후에 존재하는 경우를 제외하고 지정 될 수있다.</target>
        </trans-unit>
        <trans-unit id="40af6992cd8c238e4a2ed77daca77b37ffedddcc" translate="yes" xml:space="preserve">
          <source>Here the id column values come from the DEFAULT of the PostgreSQL column that was specified as uuid_generate_v4().</source>
          <target state="translated">여기서 id 열 값은 uuid_generate_v4 ()로 지정된 PostgreSQL 열의 DEFAULT에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a740e49d28feb08cef35103ba1ee9e5716237128" translate="yes" xml:space="preserve">
          <source>Here the name of each partition sub-table will be made by replacing the &amp;lsquo;%s&amp;rsquo; part of the tabname option value by the partition name. Now if we do:</source>
          <target state="translated">여기서 각 파티션 서브 테이블의 이름은 tabname 옵션 값의 '% s'부분을 파티션 이름으로 바꾸어 만듭니다. 이제 우리가 할 경우 :</target>
        </trans-unit>
        <trans-unit id="280e7e1b2886726d8a686e13bb326002ecb5b102" translate="yes" xml:space="preserve">
          <source>Here the server list specifies a void server corresponding to the local running MariaDB and a federated server named &lt;em&gt;server_one&lt;/em&gt;.</source>
          <target state="translated">여기서 서버 목록은 실행중인 로컬 MariaDB 및 &lt;em&gt;server_one&lt;/em&gt; 이라는 연합 서버에 해당하는 void 서버를 지정 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="28d0b6285027a5985cacedf9023e1037bac54818" translate="yes" xml:space="preserve">
          <source>Here we choose a size larger than the biggest table we want to generate. Later if we need a table pre- filled with default and/or null values, we can do for example:</source>
          <target state="translated">여기서 우리는 생성하려는 가장 큰 테이블보다 큰 크기를 선택합니다. 나중에 기본값 및 / 또는 null 값으로 미리 채워진 테이블이 필요한 경우 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6517b6b39ded5a6eb9152309ac74232f9d02ccc" translate="yes" xml:space="preserve">
          <source>Here we could have omitted the column definitions of the catalog table or, as in the above example, chose the columns returning the name and type of the tables. If specified, the columns must have the exact name of the corresponding SQLTables result set, or be given a different name with the matching flag value specification.</source>
          <target state="translated">여기서 우리는 카탈로그 테이블의 열 정의를 생략하거나 위의 예에서와 같이 테이블의 이름과 유형을 리턴하는 열을 선택했습니다. 지정된 경우, 컬럼은 해당 SQLTables 결과 세트의 정확한 이름을 갖거나 플래그 값 스펙이 일치하는 다른 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf00a7643932ed4d5cc2e3af94e9d6444fb71f15" translate="yes" xml:space="preserve">
          <source>Here we did not define all the items of the collection documents but only those that are JSON values. The database is test by default. The connection value is the URI used to establish a connection to a local or remote MongoDB server. The value shown in this example corresponds to a local server started with its default port. It is the default connection value for MONGO tables so we could have omit specifying it.</source>
          <target state="translated">여기서는 콜렉션 문서의 모든 항목을 정의하지 않고 JSON 값인 항목 만 정의했습니다. 데이터베이스는 기본적으로 테스트됩니다. 연결 값은 로컬 또는 원격 MongoDB 서버에 연결하는 데 사용되는 URI입니다. 이 예에 표시된 값은 기본 포트로 시작된 로컬 서버에 해당합니다. MONGO 테이블의 기본 연결 값이므로이를 지정하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="d51f2dda3c2c35693d1578a4c68c05c4da45f11d" translate="yes" xml:space="preserve">
          <source>Here we did not have to specify column format or offset because data are retrieved from the boys table, not directly from the boys.txt file. The flag option of the &lt;em&gt;boy&lt;/em&gt; column indicates that it correspond to the first column of the boys table, the &lt;em&gt;name&lt;/em&gt; column.</source>
          <target state="translated">boys.txt 파일이 아닌 boys 테이블에서 데이터가 검색되므로 열 형식 또는 오프셋을 지정할 필요가 없었습니다. &lt;em&gt;boy&lt;/em&gt; 열의 플래그 옵션은 boys 열의 첫 번째 열인 &lt;em&gt;name&lt;/em&gt; 열에 해당함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1df4d47dbf5766cabbf20e7e649de57c74557496" translate="yes" xml:space="preserve">
          <source>Here you invoke cmake, specifying the path to your toolchain file and the path to the &lt;code&gt;import_executables.cmake&lt;/code&gt; that you have just built on the previous step. Of course, you can also specify any other cmake parameters that could be necessary for this build, for example, enable or disable specific storage engines.</source>
          <target state="translated">여기서는 툴체인 파일의 경로와 이전 단계에서 방금 구축 한 &lt;code&gt;import_executables.cmake&lt;/code&gt; 의 경로를 지정하여 cmake를 호출 합니다. 물론, 특정 스토리지 엔진을 활성화 또는 비활성화하는 등이 빌드에 필요할 수있는 다른 cmake 매개 변수를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="db32ae187787b662b9bd908627965ca6077420b0" translate="yes" xml:space="preserve">
          <source>Here's a comparison of the &lt;code&gt;SHOW CREATE PROCEDURE&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../show-create-function/index&quot;&gt;SHOW CREATE FUNCTION&lt;/a&gt;&lt;/code&gt; statements.</source>
          <target state="translated">&lt;code&gt;SHOW CREATE PROCEDURE&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../show-create-function/index&quot;&gt;SHOW CREATE FUNCTION&lt;/a&gt;&lt;/code&gt; 문의 비교는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0ef3707540f5226b87fb414aa2e2113e13dbca86" translate="yes" xml:space="preserve">
          <source>Here's a simple example to demonstrate a trigger in action. Using these two tables as an example:</source>
          <target state="translated">다음은 작동중인 트리거를 보여주는 간단한 예입니다. 이 두 테이블을 예로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="00d7579202122a629234672e3038de8477f8529a" translate="yes" xml:space="preserve">
          <source>Here's a skeleton example to see a stored function in action:</source>
          <target state="translated">저장된 함수가 실제로 작동하는 모습을 보여주는 기본 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="91423e31ce33608898317d81915f11af891bce9c" translate="yes" xml:space="preserve">
          <source>Here's a skeleton example to see a stored procedure in action:</source>
          <target state="translated">다음은 저장 프로 시저가 실제로 작동하는 모습을 보여주는 예입니다.</target>
        </trans-unit>
        <trans-unit id="05ef7406155fb305f16a247cb1dcf1ac4d19048f" translate="yes" xml:space="preserve">
          <source>Here's a way to measure performance without having a big table.</source>
          <target state="translated">큰 테이블없이 성능을 측정하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e91a690f3f41a17afd778a95b5d4c27597828436" translate="yes" xml:space="preserve">
          <source>Here's an example of how MariaDB handles a view with a MERGE algorithm. Take a view defined as follows:</source>
          <target state="translated">다음은 MariaDB가 MERGE 알고리즘으로 뷰를 처리하는 방법에 대한 예입니다. 다음과 같이 정의 된보기를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8b79deb8fd52fa9399d563f1b53ac768a49de233" translate="yes" xml:space="preserve">
          <source>Here's an example of locating the library and finding out which package it belongs to on an Ubuntu system:</source>
          <target state="translated">다음은 라이브러리를 찾아서 우분투 시스템에서 어떤 패키지에 속하는지를 찾는 예입니다.</target>
        </trans-unit>
        <trans-unit id="61572a381a9efc4630716877947611a1a0a8e2f9" translate="yes" xml:space="preserve">
          <source>Here's an example wrapper program written in go. Build this into an executable named &lt;code&gt;iam-kms-wrapper&lt;/code&gt; and use it as instructed above. This could of course be written in any language for which an appropriate AWS SDK exists, but go has the benefit of compiling to a static binary, which means you do not have to worry about interpreter versions or installing complex dependencies on the host that runs your MariaDB server.</source>
          <target state="translated">다음은 작성된 래퍼 프로그램의 예입니다. &lt;code&gt;iam-kms-wrapper&lt;/code&gt; 라는 실행 파일로 이것을 빌드 하고 위에 지시 된대로 사용하십시오. 이것은 물론 적절한 AWS SDK가 존재하는 모든 언어로 작성 될 수 있지만, 정적 바이너리로 컴파일 할 수 있다는 이점이 있습니다. 즉, 인터프리터 버전에 대해 걱정하거나 호스트를 실행하는 호스트에 복잡한 종속성을 설치할 필요가 없습니다. MariaDB 서버.</target>
        </trans-unit>
        <trans-unit id="cbe423c3ad46b202d319751f6abd10366a876d33" translate="yes" xml:space="preserve">
          <source>Here's how the function could be successfully entered from the mysql client with the new delimiter.</source>
          <target state="translated">다음은 새로운 구분 기호를 사용하여 mysql 클라이언트에서 함수를 성공적으로 입력하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3b8655485bc635e869f593d8dcb6dca3fbb08d07" translate="yes" xml:space="preserve">
          <source>Here's how you can use `Staging` as an efficient way achieve the swap from name to id.</source>
          <target state="translated">다음은 이름에서 ID 로의 스왑을 달성하는 효율적인 방법으로 '스테이징'을 사용하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7b7df457af8cbc6ebb121dcc7e757ea7901557a9" translate="yes" xml:space="preserve">
          <source>Here's the desired output (13 rows):</source>
          <target state="translated">원하는 출력은 다음과 같습니다 (13 행).</target>
        </trans-unit>
        <trans-unit id="dd086f8537368bd40d83aa9b14dd3f71557fde66" translate="yes" xml:space="preserve">
          <source>Here's the gist of the &lt;a href=&quot;../stored-procedures/index&quot;&gt;stored procedure&lt;/a&gt; FindNearest().</source>
          <target state="translated">다음은 &lt;a href=&quot;../stored-procedures/index&quot;&gt;저장 프로 시저&lt;/a&gt; FindNearest () 의 요지입니다 .</target>
        </trans-unit>
        <trans-unit id="c7fa596e9e5f6f92a621b3ed5346cf482f7c1e41" translate="yes" xml:space="preserve">
          <source>Here's the way to approach creating an INDEX, given a SELECT. Follow the steps below, gathering columns to put in the INDEX in order. When the steps give out, you usually have the 'perfect' index.</source>
          <target state="translated">다음은 SELECT가 주어지면 INDEX 작성에 접근하는 방법입니다. 아래 단계에 따라 열을 수집하여 INDEX에 순서대로 넣으십시오. 단계가 나오면 일반적으로 '완벽한'지수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0134bf3e12d6727b9cc1666c7beea61e9c4226c0" translate="yes" xml:space="preserve">
          <source>Here's what happens if &lt;a href=&quot;index&quot;&gt;SIGNAL&lt;/a&gt; is used in the client to generate errors:</source>
          <target state="translated">클라이언트에서 &lt;a href=&quot;index&quot;&gt;SIGNAL&lt;/a&gt; 을 사용하여 오류를 생성 하면 어떻게됩니까 ?</target>
        </trans-unit>
        <trans-unit id="35ab02a76bc568c808571e61463e4e893cc1c53a" translate="yes" xml:space="preserve">
          <source>Here, '3', 'x&amp;gt;0', etc, represent the Items or Lex for the respective expressions or statements.</source>
          <target state="translated">여기서, '3', 'x&amp;gt; 0'등은 각각의 표현이나 문장에 대한 항목 또는 Lex를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="11880fb3e23435c458f2636fdc2a7bb0914604e3" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;mysql_plugin&lt;/code&gt; will look for a file called &lt;code&gt;crazyplugins.ini&lt;/code&gt;</source>
          <target state="translated">여기서 &lt;code&gt;mysql_plugin&lt;/code&gt; 은 &lt;code&gt;crazyplugins.ini&lt;/code&gt; 라는 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="77aedbceca8539a90af8fa769178257171865abe" translate="yes" xml:space="preserve">
          <source>Here, answer &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">여기에 &lt;code&gt;1&lt;/code&gt; 으로 답하십시오 .</target>
        </trans-unit>
        <trans-unit id="294d96943addf40db9c433fc31209143b4cdc876" translate="yes" xml:space="preserve">
          <source>Here, one can see that</source>
          <target state="translated">여기서 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="285591ca4727aab7779cd7ad75bf1d314fbfcd99" translate="yes" xml:space="preserve">
          <source>Here, one can see that &lt;strong&gt;orders.r_rows=NULL&lt;/strong&gt; and &lt;strong&gt;orders.r_filtered=NULL&lt;/strong&gt;. This means that table orders was not scanned even once. Indeed, we can also see customer.r_filtered=0.00. This shows that a part of WHERE attached to table `customer` was never satisfied (or, satisfied in less than 0.01% of cases).</source>
          <target state="translated">여기에서 &lt;strong&gt;orders.r_rows = NULL&lt;/strong&gt; 및 &lt;strong&gt;orders.r_filtered = NULL을&lt;/strong&gt; 볼 수 있습니다 . 이는 테이블 주문이 한 번도 스캔되지 않았 음을 의미합니다. 실제로 customer.r_filtered = 0.00도 볼 수 있습니다. 이는 '고객'테이블에 첨부 된 WHERE의 일부가 만족스럽지 않은 경우 (또는 사례의 0.01 % 미만에서 만족 됨)를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8052777cbe78534523571263917471309b1a325e" translate="yes" xml:space="preserve">
          <source>Here, second row, with values ranging from 1999 to 2017 has been shrunk to 1999 to 2001. The first row, with a range from 1999 to 2018 split into two rows 1999 to 2000 and 2018-01 to 2018-12. The fifth row, ranging from 2010 to 2015 was deleted entirely.</source>
          <target state="translated">여기에서 1999 년에서 2017 년 사이의 값을 가진 두 번째 행은 1999 년에서 2001 년으로 줄었습니다. 1999 년에서 2018 년 사이의 범위를 가진 첫 번째 행은 1999 년에서 2000 년 사이와 2018-01 년에서 2018-12 년 사이의 두 행으로 나뉩니다. 2010 년부터 2015 년까지 5 번째 행은 완전히 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="1f67e315e3076bf2e8f43eee97a1a234cadc83cc" translate="yes" xml:space="preserve">
          <source>Here, the type is &lt;em&gt;All&lt;/em&gt;, which means no index could be used. Looking at the rows count, a full table scan (all six rows) had to be performed in order to retrieve the record. If it's a requirement to search by phone number, an index will have to be created.</source>
          <target state="translated">여기서 유형은 &lt;em&gt;All&lt;/em&gt; 이므로 인덱스를 사용할 수 없습니다. 행 수를 살펴보면 레코드를 검색하기 위해 전체 테이블 스캔 (모두 6 개 행)을 수행해야했습니다. 전화 번호로 검색해야하는 경우 색인을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc3c4cce19607338a2a56f6ca40abda938427bea" translate="yes" xml:space="preserve">
          <source>Here, we didn't have to find the index of the sub array to modify. However, this is not quite satisfying because we had to manually write the whole JSON value to set to the json_Author column.</source>
          <target state="translated">여기서 우리는 수정할 하위 배열의 인덱스를 찾을 필요가 없었습니다. 그러나 json_Author 열로 설정하기 위해 전체 JSON 값을 수동으로 작성해야했기 때문에 이는 만족스럽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a47a09d78ea005e2767ec7aa2e9f799b6e8b282" translate="yes" xml:space="preserve">
          <source>Here, we'll drop the above examples, and then recreate the trigger with an error, a field that doesn't exist, first using the default &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt;, a transactional engine, and then again using &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt;, a non-transactional engine.</source>
          <target state="translated">여기서는 위의 예제를 삭제 한 다음, 트랜잭션 엔진 인 기본 &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; 를 사용하고 트랜잭션 엔진 이 아닌 엔진 인 &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM을&lt;/a&gt; 사용하여 존재하지 않는 필드 인 오류로 트리거를 다시 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="b81ea543b2a37e503973ef08e51c1d2d4f119a75" translate="yes" xml:space="preserve">
          <source>Here, you can choose what features to install. By default, all features are installed with the exception of the debug symbols. If the &quot;Database instance&quot; feature is selected, the installer will create a database instance, by default running as a service. In this case the installer will present additional dialogs to control various database properties. Note that you do not necessarily have to create an instance at this stage. For example, if you already have MySQL or MariaDB databases running as services, you can just upgrade them during the installation. Also, you can create additional database instances after the installation, with the &lt;code&gt;&lt;a href=&quot;../mysql_install_dbexe/index&quot;&gt;mysql_install_db.exe&lt;/a&gt;&lt;/code&gt; utility.</source>
          <target state="translated">여기서 설치할 기능을 선택할 수 있습니다. 기본적으로 모든 기능은 디버그 기호를 제외하고 설치됩니다. &quot;데이터베이스 인스턴스&quot;기능이 선택되면 설치 프로그램은 기본적으로 서비스로 실행되는 데이터베이스 인스턴스를 작성합니다. 이 경우 설치 관리자는 다양한 데이터베이스 속성을 제어하기위한 추가 대화 상자를 표시합니다. 이 단계에서 반드시 인스턴스를 만들 필요는 없습니다. 예를 들어 서비스로 실행중인 MySQL 또는 MariaDB 데이터베이스가 이미있는 경우 설치하는 동안 업그레이드 할 수 있습니다. 또한 &lt;code&gt;&lt;a href=&quot;../mysql_install_dbexe/index&quot;&gt;mysql_install_db.exe&lt;/a&gt;&lt;/code&gt; 유틸리티를 사용하여 설치 후 추가 데이터베이스 인스턴스를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a8465df5d6826f4ee3574fc403de8ab34dd7266" translate="yes" xml:space="preserve">
          <source>Here, you can see:</source>
          <target state="translated">여기에서 볼 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="4412e62f766a0eb2bff9091f4aa597e85fcaa727" translate="yes" xml:space="preserve">
          <source>Heuristic Recovery with the Transaction Coordinator Log</source>
          <target state="translated">트랜잭션 코디네이터 로그를 사용한 휴리스틱 복구</target>
        </trans-unit>
        <trans-unit id="05ac9166537564f48f2a4766fba371fea5c8eaff" translate="yes" xml:space="preserve">
          <source>Heuristics helps define data type of new columns</source>
          <target state="translated">휴리스틱은 새 열의 데이터 유형을 정의하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="e3cf7bdb25c859091606d5f96a561db35433685e" translate="yes" xml:space="preserve">
          <source>Hex type confusion:</source>
          <target state="translated">육각형 혼동 :</target>
        </trans-unit>
        <trans-unit id="cbae7c4928fd1cc423612fa6ee45452049ba62af" translate="yes" xml:space="preserve">
          <source>Hexadecimal Literals</source>
          <target state="translated">16 진 리터럴</target>
        </trans-unit>
        <trans-unit id="bd0db200fda8d7de6a82819c299ea2df6223e7a8" translate="yes" xml:space="preserve">
          <source>Hexadecimal digit</source>
          <target state="translated">16 진수</target>
        </trans-unit>
        <trans-unit id="d93fe0f77a2b963ace7f635585bb3d89af404c37" translate="yes" xml:space="preserve">
          <source>Hexadecimal literals</source>
          <target state="translated">16 진 리터럴</target>
        </trans-unit>
        <trans-unit id="6ad79518fa349f208d0a86dadee75ef4cf5e2f41" translate="yes" xml:space="preserve">
          <source>Hexadecimal literals can be written using any of the following syntaxes</source>
          <target state="translated">16 진 리터럴은 다음 구문 중 하나를 사용하여 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b4193fc681d325753e42a616529ea7daeba5802" translate="yes" xml:space="preserve">
          <source>Hexadecimal literals can be written using any of the following syntaxes:</source>
          <target state="translated">16 진 리터럴은 다음 구문 중 하나를 사용하여 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5647ae5692bdc84fb207905edc391cf8e58cad2" translate="yes" xml:space="preserve">
          <source>Hexadecimal literals in a numeric context:</source>
          <target state="translated">숫자 컨텍스트에서 16 진 리터럴 :</target>
        </trans-unit>
        <trans-unit id="cf3314809dd42a02ad5d1d880f2df5e89fd0cd8c" translate="yes" xml:space="preserve">
          <source>Hi,</source>
          <target state="translated">Hi,</target>
        </trans-unit>
        <trans-unit id="597a40d05c7250a66e3133fd441edae515da6cc3" translate="yes" xml:space="preserve">
          <source>Hi, I was playing around with my MariaDB ColumnStore and I noticed the I am...</source>
          <target state="translated">안녕하세요, MariaDB ColumnStore를 가지고 놀았는데</target>
        </trans-unit>
        <trans-unit id="18f93c7ff939d53b80e93f97d1a03c6f6606756a" translate="yes" xml:space="preserve">
          <source>High Availability &amp;amp; Performance Tuning</source>
          <target state="translated">고 가용성 및 성능 조정</target>
        </trans-unit>
        <trans-unit id="32af349046974ef764fabf4fb459d8cd02fdf323" translate="yes" xml:space="preserve">
          <source>High Availability Setup</source>
          <target state="translated">고 가용성 설정</target>
        </trans-unit>
        <trans-unit id="f61d1443cc2f2cd5a91a58532ab362d23697e793" translate="yes" xml:space="preserve">
          <source>High level view of the code</source>
          <target state="translated">높은 수준의 코드보기</target>
        </trans-unit>
        <trans-unit id="a0164b38d16cb8133ab0aac19dbbb1c576ba171e" translate="yes" xml:space="preserve">
          <source>Higher Query Performance</source>
          <target state="translated">더 높은 쿼리 성능</target>
        </trans-unit>
        <trans-unit id="f882922aa0b04a9d21c1b9916a41361f4919ed42" translate="yes" xml:space="preserve">
          <source>Higher concurrency queries execution by distributing the queries across all User Modules</source>
          <target state="translated">모든 사용자 모듈에 쿼리를 분산시켜 더 높은 동시성 쿼리 실행</target>
        </trans-unit>
        <trans-unit id="88cc2c46cc1b9922cb8210a21b69ee949cd15936" translate="yes" xml:space="preserve">
          <source>Highest transaction ID at the time the view was created. Should not see newer transactions with IDs equal to or greater than the value.</source>
          <target state="translated">보기가 작성 될 때 가장 높은 트랜잭션 ID입니다. ID가 값보다 크거나 같은 새로운 트랜잭션을 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b2012b36410fef634c15a747388058b3878fac3f" translate="yes" xml:space="preserve">
          <source>Highest transaction number at the time the view was created.</source>
          <target state="translated">보기가 작성된 시점에서 가장 높은 트랜잭션 번호.</target>
        </trans-unit>
        <trans-unit id="3280445596865b47b506616788b2a5a32fc2bb82" translate="yes" xml:space="preserve">
          <source>Highlighting the words &lt;code&gt;MariaDB&lt;/code&gt; and &lt;code&gt;Mroonga&lt;/code&gt; in a given text:</source>
          <target state="translated">주어진 텍스트에서 &lt;code&gt;MariaDB&lt;/code&gt; 와 &lt;code&gt;Mroonga&lt;/code&gt; 라는 단어를 강조 :</target>
        </trans-unit>
        <trans-unit id="b27dcb02539fea3b33da881d16bd16e5c0688bb2" translate="yes" xml:space="preserve">
          <source>Highlights the specified keywords in the target text.</source>
          <target state="translated">대상 텍스트에서 지정된 키워드를 강조 표시합니다.</target>
        </trans-unit>
        <trans-unit id="0fbcc7936206d60c13d7969a88c19a43c9ec8eba" translate="yes" xml:space="preserve">
          <source>Highly Available shared storage with ION. Have two different hosts, Fusion-io cards in them and share/replicate data with Fusion-io's ION software.</source>
          <target state="translated">ION과의 고 가용성 공유 스토리지. Fusion-io 카드 두 개가 있으며 Fusion-io의 ION 소프트웨어와 데이터를 공유 / 복제합니다.</target>
        </trans-unit>
        <trans-unit id="bbec5f022bd1df9016e535aed44086d30d10c300" translate="yes" xml:space="preserve">
          <source>Highly available</source>
          <target state="translated">고 가용성</target>
        </trans-unit>
        <trans-unit id="d3e8a7b40278793577bad237a5462eeed629e373" translate="yes" xml:space="preserve">
          <source>Highly scalable (near linear scalability may be reached depending on the application)</source>
          <target state="translated">높은 확장 성 (어플리케이션에 따라 선형 확장성에 도달 할 수 있음)</target>
        </trans-unit>
        <trans-unit id="eef3daf83f757b3f10445a6954a2bf4dac3be267" translate="yes" xml:space="preserve">
          <source>Highly transparent</source>
          <target state="translated">매우 투명</target>
        </trans-unit>
        <trans-unit id="c9e6b253fc34a7155f97dc0aab1c389d34cafdad" translate="yes" xml:space="preserve">
          <source>Hindi</source>
          <target state="translated">Hindi</target>
        </trans-unit>
        <trans-unit id="7de196b1b01e8a0cf5bbcb6c1068d36d1385cf17" translate="yes" xml:space="preserve">
          <source>Hint:</source>
          <target state="translated">Hint:</target>
        </trans-unit>
        <trans-unit id="418165c1d0e70be9a2f88d37e6c3b4792ac80ef2" translate="yes" xml:space="preserve">
          <source>Histogram size in bytes, from 0-255.</source>
          <target state="translated">히스토그램 크기 (바이트), 0-255</target>
        </trans-unit>
        <trans-unit id="ee70303f8582fab0cc018680cc82d6cc16d7ff5b" translate="yes" xml:space="preserve">
          <source>Histogram statistics are stored in the &lt;a href=&quot;../mysqlcolumn_stats-table/index&quot;&gt;mysql.column_stats&lt;/a&gt; table, which stores data for &lt;a href=&quot;../engine-independent-table-statistics/index&quot;&gt;engine-independent table statistics&lt;/a&gt;, and so are essentially a subset of engine-independent table statistics.</source>
          <target state="translated">히스토그램 통계는 &lt;a href=&quot;../engine-independent-table-statistics/index&quot;&gt;엔진 독립적 인 테이블 통계에&lt;/a&gt; 대한 데이터를 저장 하는 &lt;a href=&quot;../mysqlcolumn_stats-table/index&quot;&gt;mysql.column_stats&lt;/a&gt; 테이블에 저장 되며 본질적으로 엔진 독립적 인 테이블 통계의 서브 세트입니다.</target>
        </trans-unit>
        <trans-unit id="4ef4f289a0fef27531d0b9c194acb0bb90a4cead" translate="yes" xml:space="preserve">
          <source>Histogram type. See the &lt;a href=&quot;../server-system-variables/index#histogram_type&quot;&gt;histogram_type&lt;/a&gt; system variable.</source>
          <target state="translated">히스토그램 유형. &lt;a href=&quot;../server-system-variables/index#histogram_type&quot;&gt;histogram_type&lt;/a&gt; 시스템 변수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d990f068b6c78dce568f913023ed5295f8023d3" translate="yes" xml:space="preserve">
          <source>Histogram-Based Statistics</source>
          <target state="translated">히스토그램 기반 통계</target>
        </trans-unit>
        <trans-unit id="04b3554476c4c996eb20951b65133fdaab5ec4b2" translate="yes" xml:space="preserve">
          <source>Histogram-based Statistics</source>
          <target state="translated">히스토그램 기반 통계</target>
        </trans-unit>
        <trans-unit id="2d0f2451f536ff0845b5c6d3bfff5bb794f27bb8" translate="yes" xml:space="preserve">
          <source>Histogram-based statistics can improve the optimizer query plan in certain situations.</source>
          <target state="translated">히스토그램 기반 통계는 특정 상황에서 옵티 마이저 쿼리 계획을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="009409addd3d2a5a1fbdfd75c27a98fab84d997a" translate="yes" xml:space="preserve">
          <source>Histogram-based statistics were introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt; as a mechanism to improve the query plan chosen by the optimizer in certain situations. Until then, all conditions on non-indexed columns were ignored when searching for the best execution plan. Histograms can be collected for both indexed and non-indexed columns, and are made available to the optimizer.</source>
          <target state="translated">히스토그램 기반 통계는 특정 상황에서 옵티마이 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;저가&lt;/a&gt; 선택한 쿼리 계획을 개선하기위한 메커니즘으로 MariaDB 10.0.2에 도입되었습니다 . 그때까지는 최상의 실행 계획을 검색 할 때 인덱싱되지 않은 열의 모든 조건이 무시되었습니다. 히스토그램은 인덱싱 된 열과 인덱싱되지 않은 열 모두에 대해 수집 할 수 있으며 옵티 마이저에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bb199142bd673fd8f99d78f96f208e5efb49944" translate="yes" xml:space="preserve">
          <source>Histograms were introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt;, and are collected by default from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt;.</source>
          <target state="translated">히스토그램은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1002-release-notes/&quot;&gt;MariaDB 10.0.2&lt;/a&gt; 에서 도입되었으며 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt; 에서 기본적으로 수집됩니다 .</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="616922fbc31df785fbdce6c05e0ef8cca5bb287e" translate="yes" xml:space="preserve">
          <source>History of MySQL and MariaDB authentication protocols</source>
          <target state="translated">MySQL 및 MariaDB 인증 프로토콜의 역사</target>
        </trans-unit>
        <trans-unit id="5fa87321ac64973c2547d68de99fb2a3b9984a71" translate="yes" xml:space="preserve">
          <source>Hits that cause blocks to move to the top of the &lt;em&gt;new&lt;/em&gt; sublist.</source>
          <target state="translated">적중이 블록을 &lt;em&gt;새&lt;/em&gt; 서브리스트 의 맨 위로 이동시키는 적중 .</target>
        </trans-unit>
        <trans-unit id="5649bae4411038a7c8c83fe557efa3872886a212" translate="yes" xml:space="preserve">
          <source>Hits that do not cause blocks to move to the top of the &lt;em&gt;new&lt;/em&gt; sublist due to the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_old_blocks_time&quot;&gt;innodb_old_blocks&lt;/a&gt;&lt;/code&gt; delay not being met.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_old_blocks_time&quot;&gt;innodb_old_blocks&lt;/a&gt;&lt;/code&gt; 지연이 충족되지 않아 블록이 &lt;em&gt;새 &lt;/em&gt;서브 리스트 의 맨 위로 이동하지 않는 적중</target>
        </trans-unit>
        <trans-unit id="363c024377c9e009168cac1e40509d44c9b77b2c" translate="yes" xml:space="preserve">
          <source>Hits when accessing the index cache</source>
          <target state="translated">인덱스 캐시에 액세스 할 때 적중</target>
        </trans-unit>
        <trans-unit id="ddb5e964d1b99918f7c442f4668296e89abb06a2" translate="yes" xml:space="preserve">
          <source>Hits when accessing the record cache. The record cache caches the data handle (.xtd) and row index (.xtr) files.</source>
          <target state="translated">레코드 캐시에 액세스 할 때 적중합니다. 레코드 캐시는 데이터 핸들 (.xtd) 및 행 인덱스 (.xtr) 파일을 캐시합니다.</target>
        </trans-unit>
        <trans-unit id="4c045f50445d34ea6b1c0990462fdde659a9b5ea" translate="yes" xml:space="preserve">
          <source>Hits when accessing the transaction log cache</source>
          <target state="translated">트랜잭션 로그 캐시에 액세스 할 때 적중</target>
        </trans-unit>
        <trans-unit id="c636ee629abd96163b7c30e2980671dfaa34038a" translate="yes" xml:space="preserve">
          <source>Holding Packages</source>
          <target state="translated">개최 패키지</target>
        </trans-unit>
        <trans-unit id="0818bb1443ecd7d9fee3c257efb9bbe0bb8d4b9e" translate="yes" xml:space="preserve">
          <source>Holds a large amount of binary data of variable length. Supported from version 1.1.0 onwards.</source>
          <target state="translated">가변 길이의 이진 데이터를 많이 보유합니다. 버전 1.1.0부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="48dd1955af176ef89393813053ac9622e2fb317c" translate="yes" xml:space="preserve">
          <source>Holds a large amount of letters, numbers, and special characters of variable length. Supported from version 1.1.0 onwards.</source>
          <target state="translated">가변 길이의 많은 문자, 숫자 및 특수 문자를 보유합니다. 버전 1.1.0부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4331c54ade0bed249cfa8a8032fead80e29c33fc" translate="yes" xml:space="preserve">
          <source>Holds a medium amount of binary data of variable length. Supported from version 1.1.0 onwards.</source>
          <target state="translated">가변 길이의 중간 양의 이진 데이터를 보유합니다. 버전 1.1.0부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="838c2c6d685f04bda9a5b00ce02a8a4aead0ff8f" translate="yes" xml:space="preserve">
          <source>Holds a medium amount of letters, numbers, and special characters of variable length. Supported from version 1.1.0 onwards.</source>
          <target state="translated">가변 길이의 중간 크기의 문자, 숫자 및 특수 문자를 보유합니다. 버전 1.1.0부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="cc53ef8d55bb29b1d13df7907cb0fab6bf532bdd" translate="yes" xml:space="preserve">
          <source>Holds a small amount of binary data of variable length. Supported from version 1.1.0 onwards.</source>
          <target state="translated">가변 길이의 소량의 이진 데이터를 보유합니다. 버전 1.1.0부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8b83769e275c3930acb8c03d84df71c693b973ef" translate="yes" xml:space="preserve">
          <source>Holds a small amount of letters, numbers, and special characters of variable length. Supported from version 1.1.0 onwards.</source>
          <target state="translated">가변 길이의 작은 문자, 숫자 및 특수 문자를 보유합니다. 버전 1.1.0부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="60d09b3759b231d46f0b47da9ded09b3613c8317" translate="yes" xml:space="preserve">
          <source>Holds binary data of variable length. Supported from version 1.1.0 onwards.</source>
          <target state="translated">가변 길이의 이진 데이터를 보유합니다. 버전 1.1.0부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4e2e1faee9257bf517558c6d9bfd409f9df71731" translate="yes" xml:space="preserve">
          <source>Holds hour, minute, second and optionally microseconds for time. Supported range is '-838:59:59.999999' to '838:59:59.999999'. Supported from version 1.2.0 onwards.</source>
          <target state="translated">시간 동안시, 분, 초 및 선택적으로 마이크로 초를 유지합니다. 지원되는 범위는 '-838 : 59 : 59.999999'~ '838 : 59 : 59.999999'입니다. 버전 1.2.0부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="3237193584f8a6c41f779b8372172677c8fda6be" translate="yes" xml:space="preserve">
          <source>Holds letters and special characters of fixed length. Max length is 255. Default and minimum size is 1 byte.</source>
          <target state="translated">고정 길이의 문자와 특수 문자를 보유합니다. 최대 길이는 255입니다. 기본 및 최소 크기는 1 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="16a1c964f0916e12c75a8e1f58d26df29b760c13" translate="yes" xml:space="preserve">
          <source>Holds letters, numbers, and special characters of variable length. Max length = 8000 bytes or characters and minimum length = 1 byte or character.</source>
          <target state="translated">가변 길이의 문자, 숫자 및 특수 문자를 보유합니다. 최대 길이는 8000 바이트 또는 문자이며 최소 길이는 1 바이트 또는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="2fdaab0f65383c08fb98c9e5844973ff15d4720a" translate="yes" xml:space="preserve">
          <source>Holds letters, numbers, and special characters of variable length. Supported from version 1.1.0 onwards.</source>
          <target state="translated">가변 길이의 문자, 숫자 및 특수 문자를 보유합니다. 버전 1.1.0부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5aa588714ab4cbfd615d238fd9778c3a14ca4ba8" translate="yes" xml:space="preserve">
          <source>Honduras</source>
          <target state="translated">Honduras</target>
        </trans-unit>
        <trans-unit id="2f488ffc82ccc67a1616e39fdfc537297f1646c5" translate="yes" xml:space="preserve">
          <source>Hong Kong</source>
          <target state="translated">홍콩</target>
        </trans-unit>
        <trans-unit id="3960ec4ca5fb5e5d8cdb2cc1c5121c003e426517" translate="yes" xml:space="preserve">
          <source>Host</source>
          <target state="translated">Host</target>
        </trans-unit>
        <trans-unit id="b1183f89b81a96727b4f4f5166e4df7f1202cf83" translate="yes" xml:space="preserve">
          <source>Host '%s' is blocked because of many connection errors; unblock with 'mysqladmin flush-hosts'</source>
          <target state="translated">많은 연결 오류로 인해 호스트 '% s'이 (가) 차단되었습니다. 'mysqladmin flush-hosts'로 차단 해제</target>
        </trans-unit>
        <trans-unit id="481b4b8a5ffc499250db0e8a9950eb500ebfdea2" translate="yes" xml:space="preserve">
          <source>Host '%s' is not allowed to connect to this MariaDB server</source>
          <target state="translated">호스트 '% s'은 (는)이 MariaDB 서버에 연결할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="48d67d7ecca22d03fc5bebbf037c9efc40f12fd2" translate="yes" xml:space="preserve">
          <source>Host (together with &lt;code&gt;Db&lt;/code&gt; makes up the unique identifier for this record.</source>
          <target state="translated">호스트 ( &lt;code&gt;Db&lt;/code&gt; 와 함께이 레코드의 고유 식별자를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="805c2ed8ce6c1dd8ba1947960f0dcc04a06f390c" translate="yes" xml:space="preserve">
          <source>Host (together with &lt;code&gt;Db&lt;/code&gt;, &lt;code&gt;User&lt;/code&gt;, &lt;code&gt;Routine_name&lt;/code&gt; and &lt;code&gt;Routine_type&lt;/code&gt; makes up the unique identifier for this record).</source>
          <target state="translated">호스트 ( &lt;code&gt;Db&lt;/code&gt; , &lt;code&gt;User&lt;/code&gt; , &lt;code&gt;Routine_name&lt;/code&gt; 및 &lt;code&gt;Routine_type&lt;/code&gt; 과 함께이 레코드의 고유 식별자를 구성 함)</target>
        </trans-unit>
        <trans-unit id="83a3ac4c007fa9a412a446a45ddb9bc9cd305abe" translate="yes" xml:space="preserve">
          <source>Host (together with &lt;code&gt;User&lt;/code&gt; and &lt;code&gt;Db&lt;/code&gt; makes up the unique identifier for this record. Until &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, if the host field was blank, the corresponding record in the &lt;a href=&quot;../mysqlhost-table/index&quot;&gt;mysql.host&lt;/a&gt; table would be examined. From &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;, a blank host field is the same as the &lt;code&gt;%&lt;/code&gt; wildcard.</source>
          <target state="translated">호스트 ( &lt;code&gt;User&lt;/code&gt; 및 &lt;code&gt;Db&lt;/code&gt; 와 함께이 레코드의 고유 식별자를 구성합니다. &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 까지 호스트 필드가 비어있는 경우 &lt;a href=&quot;../mysqlhost-table/index&quot;&gt;mysql.host&lt;/a&gt; 테이블 의 해당 레코드 가 검사됩니다. &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 에서 비어있는 호스트 필드는 &lt;code&gt;%&lt;/code&gt; 와일드 카드 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2c28686380160b0e8a4affd2942622aa9437d168" translate="yes" xml:space="preserve">
          <source>Host (together with &lt;code&gt;User&lt;/code&gt; and &lt;code&gt;Role&lt;/code&gt; makes up the unique identifier for this record.</source>
          <target state="translated">호스트 ( &lt;code&gt;User&lt;/code&gt; 및 &lt;code&gt;Role&lt;/code&gt; 과 함께이 레코드의 고유 식별자를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="d5250652f8c139bd1e7be07f1ea555b2244caf58" translate="yes" xml:space="preserve">
          <source>Host (together with &lt;code&gt;User&lt;/code&gt; makes up the unique identifier for this account).</source>
          <target state="translated">호스트 ( &lt;code&gt;User&lt;/code&gt; 와 함께이 계정의 고유 식별자를 구성)</target>
        </trans-unit>
        <trans-unit id="6c70bd6cc8f1f492ec9d8df34d1e0a4b81d49485" translate="yes" xml:space="preserve">
          <source>Host (together with &lt;code&gt;User&lt;/code&gt; makes up the unique identifier for this account.</source>
          <target state="translated">호스트 ( &lt;code&gt;User&lt;/code&gt; 와 함께이 계정의 고유 식별자를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="1f97ca28601effc1843307e1ba83795989325e62" translate="yes" xml:space="preserve">
          <source>Host (together with &lt;code&gt;User&lt;/code&gt;, &lt;code&gt;Db&lt;/code&gt; , &lt;code&gt;Table_name&lt;/code&gt; and&lt;code&gt;Column_name&lt;/code&gt; makes up the unique identifier for this record.</source>
          <target state="translated">호스트 ( &lt;code&gt;User&lt;/code&gt; , &lt;code&gt;Db&lt;/code&gt; , &lt;code&gt;Table_name&lt;/code&gt; 및 &lt;code&gt;Column_name&lt;/code&gt; 과 함께이 레코드의 고유 식별자를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="c763db21a3762a879ff0b2437580aa8e46209057" translate="yes" xml:space="preserve">
          <source>Host (together with &lt;code&gt;User&lt;/code&gt;, &lt;code&gt;Db&lt;/code&gt; and &lt;code&gt;Table_name&lt;/code&gt;makes up the unique identifier for this record.</source>
          <target state="translated">호스트 ( &lt;code&gt;User&lt;/code&gt; , &lt;code&gt;Db&lt;/code&gt; 및 &lt;code&gt;Table_name&lt;/code&gt; 과 함께이 레코드의 고유 식별자를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="7d616e26d3487c9ead316c1dd6276243e163c053" translate="yes" xml:space="preserve">
          <source>Host Name Component</source>
          <target state="translated">호스트 이름 구성 요소</target>
        </trans-unit>
        <trans-unit id="7e4678233119d08f3bce9beb9e1e9bdea8a5db7b" translate="yes" xml:space="preserve">
          <source>Host address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c6031fc1519ac3a437f18e6604907a6ea7fe7ae" translate="yes" xml:space="preserve">
          <source>Host and IP information.</source>
          <target state="translated">호스트 및 IP 정보.</target>
        </trans-unit>
        <trans-unit id="b95c1bef4daafcda032d413202237a9df9173799" translate="yes" xml:space="preserve">
          <source>Host and user will be validated to exist in MariaDB</source>
          <target state="translated">호스트와 사용자는 MariaDB에 존재하는 것으로 검증됩니다</target>
        </trans-unit>
        <trans-unit id="f637928587d7d8f53c6bd3abe322811c4a8fc9ae" translate="yes" xml:space="preserve">
          <source>Host from which the syslog entry was received.</source>
          <target state="translated">syslog 항목이 수신 된 호스트</target>
        </trans-unit>
        <trans-unit id="7982406003dbac6dc708a698dff3d0cfc8896179" translate="yes" xml:space="preserve">
          <source>Host from which the user connected.</source>
          <target state="translated">사용자가 연결된 호스트</target>
        </trans-unit>
        <trans-unit id="67da05e8607d05210d7f812de3baf9172d2bc451" translate="yes" xml:space="preserve">
          <source>Host name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f4239ff8a7734f9f2bf2edc7185f4c32ee590e" translate="yes" xml:space="preserve">
          <source>Host name matches are case-insensitive. Host names can match either domain names or IP addresses. Use &lt;code&gt;'localhost'&lt;/code&gt; as the host name to allow only local client connections.</source>
          <target state="translated">호스트 이름 일치는 대소 문자를 구분하지 않습니다. 호스트 이름은 도메인 이름 또는 IP 주소와 일치 할 수 있습니다. 로컬 클라이언트 연결 만 허용하려면 호스트 이름으로 &lt;code&gt;'localhost'&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d837412b3571261b637d0d4a6d243ce8fc49c117" translate="yes" xml:space="preserve">
          <source>Host name to S3 provider</source>
          <target state="translated">S3 제공자의 호스트 이름</target>
        </trans-unit>
        <trans-unit id="fda65ffe1cb93edcc55493c73d960d86433c4080" translate="yes" xml:space="preserve">
          <source>Host name used by the client to connect, &lt;code&gt;NULL&lt;/code&gt; for internal threads or user sessions that failed to authenticate.</source>
          <target state="translated">클라이언트가 연결에 사용하는 호스트 이름, 인증에 실패한 내부 스레드 또는 사용자 세션의 경우 &lt;code&gt;NULL&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab37fad090ff68e4020c499d616850d6e6b0937c" translate="yes" xml:space="preserve">
          <source>Host name, either a literal, or the &lt;code&gt;%&lt;/code&gt; wildcard representing any host.</source>
          <target state="translated">호스트 이름, 리터럴 또는 호스트를 나타내는 &lt;code&gt;%&lt;/code&gt; 와일드 카드.</target>
        </trans-unit>
        <trans-unit id="8f1083687d55d1bb1086ac13557e32e4f10c6603" translate="yes" xml:space="preserve">
          <source>Host names may contain the wildcard characters &lt;code&gt;%&lt;/code&gt; and &lt;code&gt;_&lt;/code&gt;. They are matched as if by the &lt;code&gt;&lt;a href=&quot;../like/index&quot;&gt;LIKE&lt;/a&gt;&lt;/code&gt; clause. If you need to use a wildcard character literally (for example, to match a domain name with an underscore), prefix the character with a backslash. See &lt;code&gt;LIKE&lt;/code&gt; for more information on escaping wildcard characters.</source>
          <target state="translated">호스트 이름에는 와일드 카드 문자 &lt;code&gt;%&lt;/code&gt; 및 &lt;code&gt;_&lt;/code&gt; 가 포함될 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../like/index&quot;&gt;LIKE&lt;/a&gt;&lt;/code&gt; 절 에서와 같이 일치 합니다. 와일드 카드 문자를 문자 그대로 사용해야하는 경우 (예 : 도메인 이름을 밑줄과 일치시키기 위해) 문자 앞에 백 슬래시를 사용하십시오. 와일드 카드 문자 이스케이프에 대한 자세한 내용 은 &lt;code&gt;LIKE&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d84f3d1b26b78afa1ad6fe57bf94e69502324fb3" translate="yes" xml:space="preserve">
          <source>Host to connect to, if not specified on per-table basis</source>
          <target state="translated">테이블별로 지정되지 않은 경우 연결할 호스트</target>
        </trans-unit>
        <trans-unit id="845e91b9f44af67128473f9e12591b4b2a81225c" translate="yes" xml:space="preserve">
          <source>Host. Used together with &lt;code&gt;EVENT_NAME&lt;/code&gt; for grouping events.</source>
          <target state="translated">주최자. 이벤트를 그룹화하기 위해 &lt;code&gt;EVENT_NAME&lt;/code&gt; 과 함께 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="be70ff6117bf940b4402743cc7f38c9e33ab5b88" translate="yes" xml:space="preserve">
          <source>Host. Used together with &lt;code&gt;USER&lt;/code&gt; and &lt;code&gt;EVENT_NAME&lt;/code&gt; for grouping events.</source>
          <target state="translated">주최자. 이벤트를 그룹화하기 위해 &lt;code&gt;USER&lt;/code&gt; 및 &lt;code&gt;EVENT_NAME&lt;/code&gt; 과 함께 사용 됩니다 .</target>
        </trans-unit>
        <trans-unit id="b346fbeb8ca3cdd0b07cfda9cdb252f283fd0bbd" translate="yes" xml:space="preserve">
          <source>Host_cache information</source>
          <target state="translated">Host_cache 정보</target>
        </trans-unit>
        <trans-unit id="c4bc16d32f20376d2c34e2bff385800d9b157d60" translate="yes" xml:space="preserve">
          <source>Hostname of db server for *-slow.log filename (can be wildcard), default is '*', i.e. match all</source>
          <target state="translated">* -slow.log 파일 이름에 대한 db 서버의 호스트 이름 (와일드 카드 일 수 있음), 기본값은 '*'입니다. 즉 모두 일치</target>
        </trans-unit>
        <trans-unit id="e0a27121b8314a06272c215cedbde44b39b4faa2" translate="yes" xml:space="preserve">
          <source>Hostname to connect to.</source>
          <target state="translated">연결할 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="601f60a275dc18f4c0b4d3a350509de302776a8b" translate="yes" xml:space="preserve">
          <source>Hosts used to connect to the server</source>
          <target state="translated">서버에 연결하는 데 사용되는 호스트</target>
        </trans-unit>
        <trans-unit id="cc53b246d6c96fb218922a66ec6b6ca310bf3021" translate="yes" xml:space="preserve">
          <source>Hot Standby</source>
          <target state="translated">핫 스탠바이</target>
        </trans-unit>
        <trans-unit id="2f40db358322b90c1431916a47056d539443176e" translate="yes" xml:space="preserve">
          <source>Hot buffer pool: from 0.19 sec down to 0.07 sec</source>
          <target state="translated">핫 버퍼 풀 : 0.19 초에서 0.07 초</target>
        </trans-unit>
        <trans-unit id="3a1816ffdc18dc309e7fc95e80574174441e7c80" translate="yes" xml:space="preserve">
          <source>Hot off the press from Percona Live... &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; has &quot;windowing functions&quot;, which make &quot;groupwise max&quot; much more straightforward.</source>
          <target state="translated">Percona Live의 언론 보도 ... &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 에는 &quot;windowing functions&quot;이있어 &quot;groupwise max&quot;가 훨씬 간단 해집니다.</target>
        </trans-unit>
        <trans-unit id="c8ce63a139833d855f92fed69279234521b1d34b" translate="yes" xml:space="preserve">
          <source>Hour with 1 digits between 0-23.</source>
          <target state="translated">0-23 사이의 1 자리 숫자로 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="5d3a15320008b903a8831dee6f75333ac6043cc8" translate="yes" xml:space="preserve">
          <source>Hour with 1 digits between 1-12.</source>
          <target state="translated">1-12 사이의 1 자리 숫자로 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="0ab13fea1394559fb854340abfb8b1f06f6b8f1e" translate="yes" xml:space="preserve">
          <source>Hour with 2 digits between 00-23.</source>
          <target state="translated">00-23 사이의 2 자리 숫자로 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="42244749a6b40f6493a2e70c3e40378dd6a62725" translate="yes" xml:space="preserve">
          <source>Hour with 2 digits between 01-12.</source>
          <target state="translated">01-12 사이의 2 자리 숫자로 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="9e25a34e635a123f8958bbe26e7c4843278597fb" translate="yes" xml:space="preserve">
          <source>Hours</source>
          <target state="translated">Hours</target>
        </trans-unit>
        <trans-unit id="45c5dfcc5a9f2db277da1c66ad79d7f7e2567446" translate="yes" xml:space="preserve">
          <source>Hours.Minutes</source>
          <target state="translated">Hours.Minutes</target>
        </trans-unit>
        <trans-unit id="6f69bef4d4c4946f5267753188d382270564ae8b" translate="yes" xml:space="preserve">
          <source>Hours.Minutes.Seconds</source>
          <target state="translated">Hours.Minutes.Seconds</target>
        </trans-unit>
        <trans-unit id="3fcf5e20a4ae5c0dfcc886eb2fcdeac27e237a72" translate="yes" xml:space="preserve">
          <source>Hours.Minutes.Seconds.Microseconds</source>
          <target state="translated">Hours.Minutes.Seconds.Microseconds</target>
        </trans-unit>
        <trans-unit id="94c915be2cd7f8ea63ba2c0992af29bb84731e8b" translate="yes" xml:space="preserve">
          <source>How Aria detects and deals with deadlocks</source>
          <target state="translated">Aria가 교착 상태를 감지하고 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="2dbcbeb4a5a3c07427f3c7f703dc34474c0a7cff" translate="yes" xml:space="preserve">
          <source>How Aria got its name.</source>
          <target state="translated">아리아가 어떻게 이름을 얻었는지.</target>
        </trans-unit>
        <trans-unit id="38b95f5b63792a2ff26241952b73bbf84f0ff30b" translate="yes" xml:space="preserve">
          <source>How Autoincrement works</source>
          <target state="translated">자동 증가 작동 방식</target>
        </trans-unit>
        <trans-unit id="287d42c23b22c634730df5e408428929bac515fc" translate="yes" xml:space="preserve">
          <source>How Batch Keys Access Join Works</source>
          <target state="translated">배치 키 액세스 조인 작동 방식</target>
        </trans-unit>
        <trans-unit id="65c95a4ead647e2f32b51758c2d8a6e966d6cba1" translate="yes" xml:space="preserve">
          <source>How Block Hash Join Works</source>
          <target state="translated">블록 해시 조인 작동 방식</target>
        </trans-unit>
        <trans-unit id="0bd1f7ca244bff7f575e1f8f6ddcdf50ac7fb078" translate="yes" xml:space="preserve">
          <source>How Block Nested Loop Join Works</source>
          <target state="translated">블록 중첩 루프 조인 작동 방식</target>
        </trans-unit>
        <trans-unit id="e09d932c4afb5d59c134d934e6d5ee9e7d862366" translate="yes" xml:space="preserve">
          <source>How ColumnStore processes an end user query through the User and Performance Modules</source>
          <target state="translated">ColumnStore가 사용자 및 성능 모듈을 통해 최종 사용자 쿼리를 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="222322aef121f55b0560acf1c24171844e8f9c41" translate="yes" xml:space="preserve">
          <source>How FederatedX works</source>
          <target state="translated">FederatedX 작동 방식</target>
        </trans-unit>
        <trans-unit id="28d6d43869782c2893d89981fc38233173d220cc" translate="yes" xml:space="preserve">
          <source>How IGNORE works</source>
          <target state="translated">IGNORE 작동 방식</target>
        </trans-unit>
        <trans-unit id="f2defc8ffcef7a22d53ccaa39bcb9cc87726f225" translate="yes" xml:space="preserve">
          <source>How Index Statistics Help the Query Optimizer</source>
          <target state="translated">인덱스 통계가 쿼리 최적화 프로그램을 돕는 방법</target>
        </trans-unit>
        <trans-unit id="a582f1b45b3c2cb2e77fb00156cf885b0bc2ab1c" translate="yes" xml:space="preserve">
          <source>How MIN and MAX are optimized</source>
          <target state="translated">MIN 및 MAX가 최적화되는 방법</target>
        </trans-unit>
        <trans-unit id="6d5ccd76607e56880736fd1e934ce5eacf3448b0" translate="yes" xml:space="preserve">
          <source>How MariaDB Handles Statement-Based Binary Logging of Routines</source>
          <target state="translated">MariaDB가 명령문 기반의 이진 로깅을 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="d7236033f3d4bbed301b8fb0280e3e87170f22fc" translate="yes" xml:space="preserve">
          <source>How MariaDB manages encryption keys depends on which encryption key management solution you choose. Currently, MariaDB has three options:</source>
          <target state="translated">MariaDB가 암호화 키를 관리하는 방법은 선택한 암호화 키 관리 솔루션에 따라 다릅니다. 현재 MariaDB에는 세 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="021491f7ebe96abd39df7b8b588428f702b286df" translate="yes" xml:space="preserve">
          <source>How Mariabackup Works</source>
          <target state="translated">Mariabackup 작동 방식</target>
        </trans-unit>
        <trans-unit id="d477038ecff4071eeb1614091628ae47cb2fce60" translate="yes" xml:space="preserve">
          <source>How Mariabackup could use BACKUP STAGE commands.</source>
          <target state="translated">Mariabackup이 BACKUP STAGE 명령을 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="345e344dfb47c91d86d0d99edc3d874ce761f091" translate="yes" xml:space="preserve">
          <source>How Much Faster?</source>
          <target state="translated">얼마나 빨리?</target>
        </trans-unit>
        <trans-unit id="630b96ffb216a4997f406710c689aa87bad15868" translate="yes" xml:space="preserve">
          <source>How MyRocks computes statistics</source>
          <target state="translated">MyRocks가 통계를 계산하는 방법</target>
        </trans-unit>
        <trans-unit id="d991ed5ee671ba8dd7933ead66587ea023ee7212" translate="yes" xml:space="preserve">
          <source>How MyRocks provides statistics to the query optimizer</source>
          <target state="translated">MyRocks가 쿼리 최적화 프로그램에 통계를 제공하는 방법</target>
        </trans-unit>
        <trans-unit id="e51e011d110152ed1b3a36cc5a1d5e048cd0208f" translate="yes" xml:space="preserve">
          <source>How MySQL Uses Threads for Client Connections</source>
          <target state="translated">MySQL이 클라이언트 연결에 스레드를 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="46a3b0e85ab2841a7203a0c8d891eced537b1676" translate="yes" xml:space="preserve">
          <source>How Parsing and Execution of Queries Work</source>
          <target state="translated">쿼리 구문 분석 및 실행 방법</target>
        </trans-unit>
        <trans-unit id="21e86cd0e091a9a58f13101641021c4bb7552a79" translate="yes" xml:space="preserve">
          <source>How can I create a MyISAM-like (non-transactional) table in Aria?</source>
          <target state="translated">Aria에서 MyISAM과 유사한 (비 거래 적) 테이블을 만들려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="4b450007ba6ca11a7a27f3aff5864e4d90f61dac" translate="yes" xml:space="preserve">
          <source>How can I create the pivoted table of the large table?</source>
          <target state="translated">큰 테이블의 피벗 테이블을 어떻게 만들 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="2348790f7b132508d72259bd7f2bed87215d172c" translate="yes" xml:space="preserve">
          <source>How can I tell MariaDB where the first record actually begins?</source>
          <target state="translated">첫 번째 레코드가 실제로 시작되는 위치를 MariaDB에 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="d36f7b66abf7c11c470cf76201e8b4f02512c0e5" translate="yes" xml:space="preserve">
          <source>How can we make the where clause be added to the sent srcdef? There are many problems:</source>
          <target state="translated">보낸 srcdef에 where 절을 어떻게 추가 할 수 있습니까? 많은 문제가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c371fa4e59c1220e7883d1fee74381bfa480cbf3" translate="yes" xml:space="preserve">
          <source>How can we retrieve the values specified by attributes? By using a &lt;em&gt;Coltype&lt;/em&gt; table option to specify the default column type. The value &amp;lsquo;@&amp;rsquo; means that column names match attribute names. Therefore, we can retrieve them by creating a table such as:</source>
          <target state="translated">속성으로 지정된 값을 어떻게 검색 할 수 있습니까? 사용하여 &lt;em&gt;Coltype의&lt;/em&gt; 기본 열 유형을 지정 테이블 옵션을 선택합니다. '@'값은 열 이름이 속성 이름과 일치 함을 의미합니다. 따라서 다음과 같은 테이블을 만들어 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca2003b00ee76ed0e737dc6be7bed84e408f01c9" translate="yes" xml:space="preserve">
          <source>How do I assign two fields the same auto_increment value in one query?</source>
          <target state="translated">하나의 쿼리에서 두 개의 필드에 동일한 auto_increment 값을 어떻게 할당합니까?</target>
        </trans-unit>
        <trans-unit id="ecefef332162e513df526aa1970e4ced4257e18d" translate="yes" xml:space="preserve">
          <source>How do I change what number auto_increment starts with?</source>
          <target state="translated">auto_increment로 시작하는 숫자를 어떻게 변경합니까?</target>
        </trans-unit>
        <trans-unit id="249882fbeb53d9b6292f260dd269168d1d173b67" translate="yes" xml:space="preserve">
          <source>How do I create a federated server?</source>
          <target state="translated">페더 레이 티드 서버를 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="e66497b5894c303acdafbe0881ff14ac16294423" translate="yes" xml:space="preserve">
          <source>How do I get the auto_increment value in a BEFORE INSERT trigger?</source>
          <target state="translated">BEFORE INSERT 트리거에서 auto_increment 값을 얻으려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="2d2c391eb09bd6da3d63d163635fed8ee5565145" translate="yes" xml:space="preserve">
          <source>How do I get the last inserted auto_increment value?</source>
          <target state="translated">마지막으로 삽입 된 auto_increment 값을 어떻게 얻습니까?</target>
        </trans-unit>
        <trans-unit id="ea3ea567d5cbf47edd4472b121c36770d236789a" translate="yes" xml:space="preserve">
          <source>How do I get the next value to be inserted?</source>
          <target state="translated">다음 값을 삽입하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="1c9744a04460c5b159821b3fd9e40cf9f9f632a4" translate="yes" xml:space="preserve">
          <source>How do I renumber rows once I've deleted some in the middle?</source>
          <target state="translated">중간에 일부를 삭제 한 후에는 행의 번호를 어떻게 재 지정합니까?</target>
        </trans-unit>
        <trans-unit id="fea127aec1ba0b4f5c0f98acc0c5fe3c84f74b07" translate="yes" xml:space="preserve">
          <source>How do you use FederatedX?</source>
          <target state="translated">FederatedX는 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="07fc30feaf6dd540b45e2ce91af76de6632b6d73" translate="yes" xml:space="preserve">
          <source>How does Aria 1.5 Compare to MyISAM?</source>
          <target state="translated">Aria 1.5는 MyISAM과 어떻게 비교됩니까?</target>
        </trans-unit>
        <trans-unit id="9af47dcf5d3c209b59f996a8323598c09af194c1" translate="yes" xml:space="preserve">
          <source>How does FederatedX differ from the old Federated Engine?</source>
          <target state="translated">FederatedX와 기존 Federated Engine의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8c736d1fa7667b15668999b645b5c365f84d65c9" translate="yes" xml:space="preserve">
          <source>How does one use Cassandra together with an SQL database? I can think of these use cases:</source>
          <target state="translated">Cassandra와 SQL 데이터베이스를 어떻게 함께 사용합니까? 이러한 유스 케이스를 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="708393d530af98734cfa0858f3c3c38f755580ec" translate="yes" xml:space="preserve">
          <source>How fast should you flip-flop? Probably the best scheme is to</source>
          <target state="translated">얼마나 빨리 플립 플롭해야합니까? 아마도 가장 좋은 계획은</target>
        </trans-unit>
        <trans-unit id="f49be7d5c7e54f13f70ef498840f5092de596e33" translate="yes" xml:space="preserve">
          <source>How fast?</source>
          <target state="translated">얼마나 빠릅니까?</target>
        </trans-unit>
        <trans-unit id="cd1a61490e7bd2406ec76f958f1314af0d746674" translate="yes" xml:space="preserve">
          <source>How fast? How big?</source>
          <target state="translated">얼마나 빠릅니까? 얼마나 큰?</target>
        </trans-unit>
        <trans-unit id="fb7f50479b0cbd1a4f186b66fe4d2ad69f0997ca" translate="yes" xml:space="preserve">
          <source>How files are organized in PBXT</source>
          <target state="translated">PBXT에서 파일을 구성하는 방법</target>
        </trans-unit>
        <trans-unit id="1a4d3535d36978e5c129dd81382bb2fb3864d3c4" translate="yes" xml:space="preserve">
          <source>How good is it?</source>
          <target state="translated">얼마나 좋은가요?</target>
        </trans-unit>
        <trans-unit id="492a13d1e2350171fac24120c9de8d5b2c061374" translate="yes" xml:space="preserve">
          <source>How index_merge/sort_intersection improves the situation</source>
          <target state="translated">index_merge / sort_intersection이 상황을 개선하는 방법</target>
        </trans-unit>
        <trans-unit id="100cb0b9b76cf128bd36c57de623e9519f3f1a9c" translate="yes" xml:space="preserve">
          <source>How it Works</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d1b005e519b46753ae99afa622e6abbc0a5ba8c" translate="yes" xml:space="preserve">
          <source>How long in seconds to wait for confirmation of server startup. If the server does not start within this time, &lt;em&gt;mysql.server&lt;/em&gt; exits with an error. The default value is 900. A value of 0 means not to wait at all for startup. Negative values mean to wait forever (no timeout).</source>
          <target state="translated">서버 시작 확인을 기다리는 시간 (초)입니다. 이 시간 내에 서버가 시작되지 않으면 &lt;em&gt;mysql.server&lt;/em&gt; 가 오류와 함께 종료됩니다. 기본값은 900입니다. 값 0은 시작을 전혀 기다리지 않음을 의미합니다. 음수 값은 시간이 초과되지 않고 영원히 대기하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ff0a936e1be70aca0e3840d736cfc8af84bc3065" translate="yes" xml:space="preserve">
          <source>How many PARTITIONs? It does not matter a lot. Some thoughts:</source>
          <target state="translated">몇 개의 파티가 있습니까? 그다지 중요하지 않습니다. 몇 가지 생각 :</target>
        </trans-unit>
        <trans-unit id="8f95aad5b3821ab0f3d629055224194445b21dc4" translate="yes" xml:space="preserve">
          <source>How many Performance Modules (PMs) will your system need?</source>
          <target state="translated">시스템에 몇 개의 PM (성능 모듈)이 필요합니까?</target>
        </trans-unit>
        <trans-unit id="407dcae4365b46e5e5f6c155672b1a8373bcc6a8" translate="yes" xml:space="preserve">
          <source>How many User Modules (UMs) will your system need?</source>
          <target state="translated">시스템에 몇 개의 사용자 모듈 (UM)이 필요합니까?</target>
        </trans-unit>
        <trans-unit id="a6bf5b5a6b18438737d9a954f79d6a746c015f23" translate="yes" xml:space="preserve">
          <source>How many bits to use</source>
          <target state="translated">사용할 비트 수</target>
        </trans-unit>
        <trans-unit id="3e8020926d82af168ee8d22adfea2410a7253fac" translate="yes" xml:space="preserve">
          <source>How many bytes of the key that was used (shows if we are using only parts of the multi-column key).</source>
          <target state="translated">사용 된 키의 바이트 수 (다중 열 키의 일부만 사용중인 경우 표시)</target>
        </trans-unit>
        <trans-unit id="026df2612123ff95b000ace18bb7e5c34e91044b" translate="yes" xml:space="preserve">
          <source>How many entries in the replication log that should be skipped (mainly used in case of errors in the log).</source>
          <target state="translated">복제 로그에서 건너 뛸 항목 수 (주로 로그에 오류가있는 경우에 사용)</target>
        </trans-unit>
        <trans-unit id="6a23376357de151052a54d6634b8f78bd5de7b20" translate="yes" xml:space="preserve">
          <source>How many heartbeats we have got from the master.</source>
          <target state="translated">우리가 마스터로부터 얻은 하트 비트 수</target>
        </trans-unit>
        <trans-unit id="e9792f1e122e759cd2c89935041937116e7fcce7" translate="yes" xml:space="preserve">
          <source>How many heartbeats we have got from the master. Returned with &lt;code&gt;SHOW ALL SLAVES STATUS&lt;/code&gt; only.</source>
          <target state="translated">우리가 마스터로부터 얻은 하트 비트 수 &lt;code&gt;SHOW ALL SLAVES STATUS&lt;/code&gt; 로만 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="0358288ae3e8f4d4507a343946d28976f6e02958" translate="yes" xml:space="preserve">
          <source>How many log entries the slave has executed.</source>
          <target state="translated">슬레이브가 실행 한 로그 항목 수</target>
        </trans-unit>
        <trans-unit id="41b2997fe9a6d96f99bf69b1c67374bb8015a77d" translate="yes" xml:space="preserve">
          <source>How many log entries the slave has executed. Returned with &lt;code&gt;SHOW ALL SLAVES STATUS&lt;/code&gt; only.</source>
          <target state="translated">슬레이브가 실행 한 로그 항목 수 &lt;code&gt;SHOW ALL SLAVES STATUS&lt;/code&gt; 로만 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="6d79bd7999ff86c955317080cf54d50253d7f9b0" translate="yes" xml:space="preserve">
          <source>How many nodes to have in a cluster</source>
          <target state="translated">클러스터에 보유 할 노드 수</target>
        </trans-unit>
        <trans-unit id="aaa82b463abe1df80aee289bbe9f1ae936f571b3" translate="yes" xml:space="preserve">
          <source>How many parallel tests should be run. Default is &lt;code&gt;1&lt;/code&gt;, use &lt;code&gt;--parallel=auto&lt;/code&gt; for auto-setting of &lt;em&gt;num&lt;/em&gt;.</source>
          <target state="translated">몇 개의 병렬 테스트를 실행해야합니까? 기본값은 &lt;code&gt;1&lt;/code&gt; 이며 &lt;em&gt;num&lt;/em&gt; 자동 설정에는 &lt;code&gt;--parallel=auto&lt;/code&gt; 를 사용 하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a788fd5287681eb4fd08d8433e58a48d094bbca3" translate="yes" xml:space="preserve">
          <source>How many partitions?</source>
          <target state="translated">몇 개의 파티션입니까?</target>
        </trans-unit>
        <trans-unit id="bc6e7cebd58728ca49b321cf4ad7b9cb25dab2b2" translate="yes" xml:space="preserve">
          <source>How many rows (total)</source>
          <target state="translated">행 수 (총)</target>
        </trans-unit>
        <trans-unit id="6ed0a2385603276bba6aa3cdffd8572dc058e6da" translate="yes" xml:space="preserve">
          <source>How many times a page of &lt;code&gt;INDEX_NAME&lt;/code&gt; has been compressed. This happens when a new page is created because the compression log runs out of space. This value includes both successful operations and &lt;em&gt;compression failures&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;INDEX_NAME&lt;/code&gt; 의 페이지가 몇 번 압축되었는지 압축 로그에 공간이 부족하여 새 페이지가 작성 될 때 발생합니다. 이 값에는 성공적인 작업과 &lt;em&gt;압축 실패가&lt;/em&gt; 모두 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="bf95a92d37f253a5f4361dd6427ea6241c106f06" translate="yes" xml:space="preserve">
          <source>How many times a page of &lt;code&gt;INDEX_NAME&lt;/code&gt; has been successfully compressed. This value should be as close as possible to &lt;code&gt;COMPRESS_OPS&lt;/code&gt;. If it is notably lower, either avoid compressing some tables, or increase the KEY_BLOCK_SIZE for some compressed tables.</source>
          <target state="translated">&lt;code&gt;INDEX_NAME&lt;/code&gt; 페이지가 압축 된 횟수 입니다. 이 값은 가능한 &lt;code&gt;COMPRESS_OPS&lt;/code&gt; 에 가까워 야합니다 . 현저히 낮은 경우 일부 테이블을 압축하지 않거나 일부 압축 테이블의 KEY_BLOCK_SIZE를 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="bd0204751613136745a2d66fa575e325b6950a83" translate="yes" xml:space="preserve">
          <source>How many times a page of &lt;code&gt;INDEX_NAME&lt;/code&gt; has been uncompressed. This happens when an uncompressed version of a page is created in the buffer pool, or when a &lt;em&gt;compression failure&lt;/em&gt; occurs.</source>
          <target state="translated">&lt;code&gt;INDEX_NAME&lt;/code&gt; 의 페이지 가 압축 해제 된 횟수 입니다. 압축되지 않은 버전의 페이지가 버퍼 풀에 작성되거나 &lt;em&gt;압축 실패&lt;/em&gt; 가 발생할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8382f6e093758a1f32191927ddff6656cb8d410d" translate="yes" xml:space="preserve">
          <source>How many times a page of the size &lt;code&gt;PAGE_SIZE&lt;/code&gt; has been compressed. This happens when a new page is created because the compression log runs out of space. This value includes both successful operations and &lt;em&gt;compression failures&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;PAGE_SIZE&lt;/code&gt; 크기의 페이지가 몇 번 압축되었는지 압축 로그에 공간이 부족하여 새 페이지가 작성 될 때 발생합니다. 이 값에는 성공적인 작업과 &lt;em&gt;압축 실패가&lt;/em&gt; 모두 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="49123051d62138dd53d5972046e9cbacb9f16eee" translate="yes" xml:space="preserve">
          <source>How many times a page of the size &lt;code&gt;PAGE_SIZE&lt;/code&gt; has been relocated. This happens when data exceeds a page (because a row must be copied into a new page) and when two pages are merged (because their data shrunk and can now be contained in one page).</source>
          <target state="translated">&lt;code&gt;PAGE_SIZE&lt;/code&gt; 크기의 페이지가 몇 번이나 재배치되었습니다. 이것은 데이터가 페이지를 초과 할 때 (행이 새 페이지로 복사되어야하기 때문에) 두 페이지가 병합 될 때 (데이터가 축소되어 이제는 한 페이지에 포함될 수 있기 때문에) 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5316643212a2d0eba84457c947605abc17a936c4" translate="yes" xml:space="preserve">
          <source>How many times a page of the size &lt;code&gt;PAGE_SIZE&lt;/code&gt; has been successfully compressed. This value should be as close as possible to &lt;code&gt;COMPRESS_OPS&lt;/code&gt;. If it is notably lower, either avoid compressing some tables, or increase the &lt;code&gt;KEY_BLOCK_SIZE&lt;/code&gt; for some compressed tables.</source>
          <target state="translated">&lt;code&gt;PAGE_SIZE&lt;/code&gt; 크기의 페이지 가 성공적으로 압축 된 횟수 입니다. 이 값은 가능한 &lt;code&gt;COMPRESS_OPS&lt;/code&gt; 에 가까워 야합니다 . 현저히 낮은 경우 일부 테이블을 압축하지 않거나 일부 압축 테이블 의 &lt;code&gt;KEY_BLOCK_SIZE&lt;/code&gt; 를 늘리십시오 .</target>
        </trans-unit>
        <trans-unit id="fe417333001375a701784ea4394ce3b629a33f4b" translate="yes" xml:space="preserve">
          <source>How many times a page of the size &lt;code&gt;PAGE_SIZE&lt;/code&gt; has been uncompressed. This happens when an uncompressed version of a page is created in the buffer pool, or when a &lt;em&gt;compression failure&lt;/em&gt; occurs.</source>
          <target state="translated">&lt;code&gt;PAGE_SIZE&lt;/code&gt; 크기의 페이지 가 압축 해제 된 횟수 입니다. 압축되지 않은 버전의 페이지가 버퍼 풀에 작성되거나 &lt;em&gt;압축 실패&lt;/em&gt; 가 발생할 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bb3b98e9b41ea44b384178c6bdf174a93d0fc31f" translate="yes" xml:space="preserve">
          <source>How many times the mutex occurred.</source>
          <target state="translated">뮤텍스가 몇 번이나 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="b0cd175cde531ff18412e5ed22794ea703714d17" translate="yes" xml:space="preserve">
          <source>How much disk space will your system need?</source>
          <target state="translated">시스템에 필요한 디스크 공간은 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="63f8b3eb5d61202c97972f0237c9179e9be62c8d" translate="yes" xml:space="preserve">
          <source>How much speed will be gained depends on - How many records will be filtered out - How expensive it was to read them</source>
          <target state="translated">얻을 수있는 속도는 다음에 따라 다릅니다.-필터링되는 레코드 수-읽은 비용</target>
        </trans-unit>
        <trans-unit id="c019986a446e4fa6eade36a425f297058da689ce" translate="yes" xml:space="preserve">
          <source>How often to request a heartbeat packet from the master (in seconds).</source>
          <target state="translated">마스터에게 하트 비트 패킷을 요청하는 빈도 (초).</target>
        </trans-unit>
        <trans-unit id="6d17d1c1a5c565b36bb4163ccced42bfb4e7d1e4" translate="yes" xml:space="preserve">
          <source>How often to request a heartbeat packet from the master (in seconds). Returned with &lt;code&gt;SHOW ALL SLAVES STATUS&lt;/code&gt; only.</source>
          <target state="translated">마스터에게 하트 비트 패킷을 요청하는 빈도 (초). &lt;code&gt;SHOW ALL SLAVES STATUS&lt;/code&gt; 로만 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="6ebee2f730429d224350a40dd3a36180f250fa0b" translate="yes" xml:space="preserve">
          <source>How rows are found from the table (join type).</source>
          <target state="translated">테이블에서 행을 찾는 방법 (결합 유형)</target>
        </trans-unit>
        <trans-unit id="a3b7539937fd60d7148a9dae8939eb40c9f93ecd" translate="yes" xml:space="preserve">
          <source>How should I set up the table to allow this? Or how can I modify the CSV?</source>
          <target state="translated">이것을 허용하기 위해 테이블을 어떻게 설정해야합니까? 또는 CSV를 어떻게 수정합니까?</target>
        </trans-unit>
        <trans-unit id="23d2a75a8a6422211be5485ea4ac29c2f64eaa34" translate="yes" xml:space="preserve">
          <source>How storage snapshots could use BACKUP STAGE commands.</source>
          <target state="translated">스토리지 스냅 샷이 BACKUP STAGE 명령을 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="3b8f509de2264e2cfbe1066dbe745285c5f3ae9d" translate="yes" xml:space="preserve">
          <source>How systemd is configured on MariaDB packages and how to alter its configuration</source>
          <target state="translated">MariaDB 패키지에서 systemd를 구성하는 방법 및 구성을 변경하는 방법</target>
        </trans-unit>
        <trans-unit id="55b40d54da92c269c5f6c644c247e6ae6090cde9" translate="yes" xml:space="preserve">
          <source>How the Buffer Pool Works</source>
          <target state="translated">버퍼 풀의 작동 방식</target>
        </trans-unit>
        <trans-unit id="c85a1bc0801ae3ba1ed30e805db87fd52ae3620d" translate="yes" xml:space="preserve">
          <source>How the Diagnostics Area is Populated and Cleared</source>
          <target state="translated">진단 영역을 채우고 지우는 방법</target>
        </trans-unit>
        <trans-unit id="32a9dc7a58c5abda7ff5756a388af4d0afc75b05" translate="yes" xml:space="preserve">
          <source>How the Query Cache Works</source>
          <target state="translated">쿼리 캐시 작동 방식</target>
        </trans-unit>
        <trans-unit id="03a6cff962b2548f039645e94abf748f86d041b8" translate="yes" xml:space="preserve">
          <source>How the REST feature can be added as a library called by an OEM table.</source>
          <target state="translated">REST 기능을 OEM 테이블에서 호출 한 라이브러리로 추가하는 방법</target>
        </trans-unit>
        <trans-unit id="30bcc7d1b7b53b22392d86e44e26b47c5f13c366" translate="yes" xml:space="preserve">
          <source>How the Version Buffer Works</source>
          <target state="translated">버전 버퍼 작동 방식</target>
        </trans-unit>
        <trans-unit id="eaafd0879d1b4377db8a9c401397eef7b2efb7af" translate="yes" xml:space="preserve">
          <source>How the global value was set &amp;mdash; a compile-time default, auto-configured by the server, configuration file (or a command line), with the SQL statement.</source>
          <target state="translated">전역 값이 설정되는 방식-컴파일 타임 기본값, 서버, 구성 파일 (또는 명령 줄)에 의해 SQL 문으로 자동 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="76ae028e7b551778ce40a9d85217e1d47d19e1b5" translate="yes" xml:space="preserve">
          <source>How the plugin was loaded; one of &lt;code&gt;OFF&lt;/code&gt;, &lt;code&gt;ON&lt;/code&gt;, &lt;code&gt;FORCE&lt;/code&gt; or &lt;code&gt;FORCE_PLUS_PERMANENT&lt;/code&gt;. See &lt;a href=&quot;../plugin-overview/index#installing-plugins&quot;&gt;Installing Plugins&lt;/a&gt;.</source>
          <target state="translated">플러그인이로드 된 방법 &lt;code&gt;OFF&lt;/code&gt; , &lt;code&gt;ON&lt;/code&gt; , &lt;code&gt;FORCE&lt;/code&gt; 또는 &lt;code&gt;FORCE_PLUS_PERMANENT&lt;/code&gt; 중 하나입니다 . &lt;a href=&quot;../plugin-overview/index#installing-plugins&quot;&gt;플러그인 설치를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="47045c15656e195ca1af213844ab62e254a03f2f" translate="yes" xml:space="preserve">
          <source>How this is done would depend on whether you want to use the &lt;a href=&quot;../gtid/index&quot;&gt;GTID&lt;/a&gt; coordinates or the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; file and position coordinates.</source>
          <target state="translated">이것이 수행되는 방법은 &lt;a href=&quot;../gtid/index&quot;&gt;GTID&lt;/a&gt; 좌표 를 사용할 것인지 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그&lt;/a&gt; 파일과 위치 좌표 를 사용할 것인지에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="032d2623f4c9c274b51858cb14f3620a77a95478" translate="yes" xml:space="preserve">
          <source>How this keytab file is generated depends on whether the KDC server is &lt;strong&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview&quot;&gt;Microsoft Active Directory KDC&lt;/a&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;a href=&quot;http://web.mit.edu/Kerberos/krb5-1.12/doc/index.html&quot;&gt;MIT Kerberos KDC&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">이 키탭 파일이 생성되는 방법은 KDC 서버가 &lt;strong&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows-server/identity/ad-ds/get-started/virtual-dc/active-directory-domain-services-overview&quot;&gt;Microsoft Active Directory KDC&lt;/a&gt;&lt;/strong&gt; 인지 &lt;strong&gt;&lt;a href=&quot;http://web.mit.edu/Kerberos/krb5-1.12/doc/index.html&quot;&gt;MIT Kerberos KDC&lt;/a&gt;&lt;/strong&gt; 인지에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="31f56b637cd543df95595e36b5ca37e482951664" translate="yes" xml:space="preserve">
          <source>How to &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; lots of rows from a large table? Here is an example of purging items older than 30 days:</source>
          <target state="translated">큰 테이블에서 많은 행 을 &lt;a href=&quot;../delete/index&quot;&gt;삭제&lt;/a&gt; 하는 방법은 무엇입니까? 다음은 30 일이 지난 항목을 제거하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="95237146344bc88f0aa56af7913396e78b56bcd2" translate="yes" xml:space="preserve">
          <source>How to Access the Diagnostics Area</source>
          <target state="translated">진단 영역에 액세스하는 방법</target>
        </trans-unit>
        <trans-unit id="39ec681ad1e412ce07a01ecc9517387bedc802c7" translate="yes" xml:space="preserve">
          <source>How to Change the Delimiter for the mysql Client.</source>
          <target state="translated">mysql 클라이언트의 구분자를 변경하는 방법</target>
        </trans-unit>
        <trans-unit id="36b051a002dd328d8494ef13f53db7e8595590b1" translate="yes" xml:space="preserve">
          <source>How to Configuration and Launch MariaDB Columnstore</source>
          <target state="translated">MariaDB Columnstore를 구성하고 시작하는 방법</target>
        </trans-unit>
        <trans-unit id="3565f05edfd88383d60763b52fc4ddf8cfef84f9" translate="yes" xml:space="preserve">
          <source>How to DELETE lots of rows from a large table</source>
          <target state="translated">큰 테이블에서 많은 행을 삭제하는 방법</target>
        </trans-unit>
        <trans-unit id="aa0cd47eb2c3e5054dc1f6027bc18efac982733e" translate="yes" xml:space="preserve">
          <source>How to Enable Parallel Slave</source>
          <target state="translated">병렬 슬레이브를 활성화하는 방법</target>
        </trans-unit>
        <trans-unit id="9f2fe8b7fa5a218792f5cba5c21435d0c869d946" translate="yes" xml:space="preserve">
          <source>How to Fit Stored Procedures into this Scheme</source>
          <target state="translated">이 체계에 저장 프로 시저를 맞추는 방법</target>
        </trans-unit>
        <trans-unit id="f7678deac01fad2acfeeb4fcd211e733b0f307f7" translate="yes" xml:space="preserve">
          <source>How to Handle Key Management?</source>
          <target state="translated">키 관리를 처리하는 방법?</target>
        </trans-unit>
        <trans-unit id="d8e274d79dc8730007ce4231112532cb82b2c1f0" translate="yes" xml:space="preserve">
          <source>How to Install</source>
          <target state="translated">설치하는 방법</target>
        </trans-unit>
        <trans-unit id="0aeae6d7380668d09ebb8729b5d0b7a1c55ae32e" translate="yes" xml:space="preserve">
          <source>How to Install on the Data Adapters:</source>
          <target state="translated">데이터 어댑터에 설치하는 방법 :</target>
        </trans-unit>
        <trans-unit id="47c57630932cd89c50be5d63b4067139420706b0" translate="yes" xml:space="preserve">
          <source>How to Install on the MariaDB MaxScale:</source>
          <target state="translated">MariaDB MaxScale에 설치하는 방법 :</target>
        </trans-unit>
        <trans-unit id="e3ff71ba58a7865daf32ec557cf023f7ce441dbe" translate="yes" xml:space="preserve">
          <source>How to Install the Java Connector:</source>
          <target state="translated">Java 커넥터를 설치하는 방법 :</target>
        </trans-unit>
        <trans-unit id="b273ae57ae52818f3274fe168cf60849eb980eb3" translate="yes" xml:space="preserve">
          <source>How to Install the ODBC Connector:</source>
          <target state="translated">ODBC 커넥터를 설치하는 방법 :</target>
        </trans-unit>
        <trans-unit id="e39cb049d43524dc7f2530f60f0397860d054eea" translate="yes" xml:space="preserve">
          <source>How to Maintain a time-series PARTITIONed table</source>
          <target state="translated">시계열 PARTITIONed 테이블을 유지하는 방법</target>
        </trans-unit>
        <trans-unit id="4435a0743899472923b80f274e0d0f2eed5e4143" translate="yes" xml:space="preserve">
          <source>How to PARTITION? Well, MariaDB and MySQL are very picky. So &lt;a href=&quot;../float/index&quot;&gt;FLOAT&lt;/a&gt;/&lt;a href=&quot;../double/index&quot;&gt;DOUBLE&lt;/a&gt; are out. &lt;a href=&quot;../decimal/index&quot;&gt;DECIMAL&lt;/a&gt; is out. So, we are stuck with some kludge. Essentially, we need to convert Lat/Lng to some size of &lt;a href=&quot;../int/index&quot;&gt;INT&lt;/a&gt; and use PARTITION BY RANGE.</source>
          <target state="translated">파티하는 방법? MariaDB와 MySQL은 매우 까다 롭습니다. 그래서 &lt;a href=&quot;../float/index&quot;&gt;FLOAT&lt;/a&gt; / &lt;a href=&quot;../double/index&quot;&gt;DOUBLE은&lt;/a&gt; 밖으로있다. &lt;a href=&quot;../decimal/index&quot;&gt;DECIMAL&lt;/a&gt; 이 종료되었습니다. 그래서 우리는 약간의 멍청이에 갇혀 있습니다. 기본적으로 Lat / Lng를 &lt;a href=&quot;../int/index&quot;&gt;INT&lt;/a&gt; 크기로 변환 하고 PARTITION BY RANGE를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="adeb2bfbee47e6c5d7d3f90f2c59596e8c0dd46d" translate="yes" xml:space="preserve">
          <source>How to Quickly Insert Data Into MariaDB</source>
          <target state="translated">MariaDB에 데이터를 빠르게 삽입하는 방법</target>
        </trans-unit>
        <trans-unit id="8ae1efb033de0276243ef5881fb09b97481bc029" translate="yes" xml:space="preserve">
          <source>How to Recover when system when DBROOT is incorrectly assigned or other Configuration problem</source>
          <target state="translated">DBROOT가 잘못 할당되었을 때 시스템을 복구하는 방법 또는 기타 구성 문제</target>
        </trans-unit>
        <trans-unit id="f45dc1ea80473b8967283433ed205b9019e0d443" translate="yes" xml:space="preserve">
          <source>How to Set Variables</source>
          <target state="translated">변수를 설정하는 방법</target>
        </trans-unit>
        <trans-unit id="0404a23e3b92f9c6273556d4f187ee6bd8e242c2" translate="yes" xml:space="preserve">
          <source>How to Specify Which Protocol to Use When Connecting to the mysqld Server</source>
          <target state="translated">mysqld 서버에 연결할 때 사용할 프로토콜을 지정하는 방법</target>
        </trans-unit>
        <trans-unit id="de5943c6657df34a1b5d091bca29b11781871d6e" translate="yes" xml:space="preserve">
          <source>How to Switch Primary Master User Module</source>
          <target state="translated">기본 마스터 사용자 모듈을 전환하는 방법</target>
        </trans-unit>
        <trans-unit id="b4f97638045c1e75d9212b15ed886a8cfabccb14" translate="yes" xml:space="preserve">
          <source>How to Test Which Protocol is Used</source>
          <target state="translated">사용되는 프로토콜을 테스트하는 방법</target>
        </trans-unit>
        <trans-unit id="ab8f3cca8afee25b072bdb16526071f20b597124" translate="yes" xml:space="preserve">
          <source>How to Upgrade</source>
          <target state="translated">업그레이드하는 방법</target>
        </trans-unit>
        <trans-unit id="6c7d9e4290bd531f3ceeef20dceae35af49586c4" translate="yes" xml:space="preserve">
          <source>How to build MariaDB from a source RPM (SRPM).</source>
          <target state="translated">SRPM (소스 RPM)에서 MariaDB를 빌드하는 방법</target>
        </trans-unit>
        <trans-unit id="62a0964963ee942db2070768c7911bfd6f001c1a" translate="yes" xml:space="preserve">
          <source>How to build MariaDB on FreeBSD.</source>
          <target state="translated">FreeBSD에서 MariaDB를 빌드하는 방법.</target>
        </trans-unit>
        <trans-unit id="6da738c1e3a4eeb4595add04756b2e07500c4a72" translate="yes" xml:space="preserve">
          <source>How to change a slave to master and old master as a slave for the new master.</source>
          <target state="translated">슬레이브를 마스터로 변경하고 기존 마스터를 새 마스터의 슬레이브로 변경하는 방법.</target>
        </trans-unit>
        <trans-unit id="be3bac98ae32e138da6e3eeaa2b6b598661f3baf" translate="yes" xml:space="preserve">
          <source>How to check if a flag is set:</source>
          <target state="translated">플래그가 설정되어 있는지 확인하는 방법 :</target>
        </trans-unit>
        <trans-unit id="708c43efb7faf7363e3d7379f92b0afdbca44bc9" translate="yes" xml:space="preserve">
          <source>How to compile OQGRAPH.</source>
          <target state="translated">OQGRAPH를 컴파일하는 방법.</target>
        </trans-unit>
        <trans-unit id="f7cdf69d473a2992a146025a3a98a8406c059f65" translate="yes" xml:space="preserve">
          <source>How to create</source>
          <target state="translated">만드는 방법</target>
        </trans-unit>
        <trans-unit id="32bcde88ffcbc97341e6964aa9fb2c0df08f408c" translate="yes" xml:space="preserve">
          <source>How to create a &lt;code&gt;PRIMARY KEY&lt;/code&gt; that is &lt;a href=&quot;../auto_increment/index&quot;&gt;automatically generated&lt;/a&gt;.</source>
          <target state="translated">어떻게 만들 수 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 되어 &lt;a href=&quot;../auto_increment/index&quot;&gt;자동으로 생성을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48804880e3593d1208abf594fd7a98120f553936" translate="yes" xml:space="preserve">
          <source>How to create a binary distribution (tar file)</source>
          <target state="translated">바이너리 배포판 (tar 파일)을 만드는 방법</target>
        </trans-unit>
        <trans-unit id="06e65cc8955fb577bcd7f252e561f9b3437e9203" translate="yes" xml:space="preserve">
          <source>How to create a source tar.gz file</source>
          <target state="translated">소스 tar.gz 파일을 만드는 방법</target>
        </trans-unit>
        <trans-unit id="5a1edbca9e072c9c602035b1d5a493e8ddcf73e9" translate="yes" xml:space="preserve">
          <source>How to create a source tar.gz file.</source>
          <target state="translated">소스 tar.gz 파일을 만드는 방법</target>
        </trans-unit>
        <trans-unit id="138d66edcd8fe52509dd6c0f60e4372953d94cdf" translate="yes" xml:space="preserve">
          <source>How to create an index (&lt;code&gt;name&lt;/code&gt;) that is only partly indexed (to save space).</source>
          <target state="translated">공간을 절약하기 위해 부분적으로 만 색인화 된 색인 ( &lt;code&gt;name&lt;/code&gt; ) 을 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="eb184d38c5deb0ba6161a2732b051f84ccb9234f" translate="yes" xml:space="preserve">
          <source>How to create user-defined functions in C/C++.</source>
          <target state="translated">C / C ++에서 사용자 정의 함수를 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="cabba954892812fba07b4663086b8bba133aa0ea" translate="yes" xml:space="preserve">
          <source>How to define a date in order to import an empty date from a CSV file?</source>
          <target state="translated">CSV 파일에서 빈 날짜를 가져 오기 위해 날짜를 정의하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="1b81502ebbc2bd217a8987261971f94bcdf10642" translate="yes" xml:space="preserve">
          <source>How to do that? Instead of LIMIT 10, use LIMIT 11. That will give you the 10 items needed for the current page, plus an indication of whether there is another page. And the id for that page.</source>
          <target state="translated">그렇게하는 방법? LIMIT 10 대신 LIMIT 11을 사용하십시오. 그러면 현재 페이지에 필요한 10 개의 항목과 다른 페이지가 있는지 여부가 표시됩니다. 그리고 해당 페이지의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="aa3260f848b1a3ef2cf8c05e4c437f668e890fe6" translate="yes" xml:space="preserve">
          <source>How to download, go to binaries download page and download &quot;centos6_boost_1_55.tar.gz&quot;</source>
          <target state="translated">다운로드, 바이너리 다운로드 페이지로 이동하여 &quot;centos6_boost_1_55.tar.gz&quot;다운로드</target>
        </trans-unit>
        <trans-unit id="1a3f7969974c8bc0e35cb828190d800ed3e71b65" translate="yes" xml:space="preserve">
          <source>How to enable disk-based joins on the UM node</source>
          <target state="translated">UM 노드에서 디스크 기반 조인을 활성화하는 방법</target>
        </trans-unit>
        <trans-unit id="2b0cf3b33bd05ca115cf219a2be3e35341eafe27" translate="yes" xml:space="preserve">
          <source>How to fix InnoDB errors like &quot;Row size too large (&amp;gt; 8126). Changing some c...</source>
          <target state="translated">&quot;Row size too large (&amp;gt; 8126)와 같은 InnoDB 오류 해결 방법.</target>
        </trans-unit>
        <trans-unit id="43b3beea493923cdffb2d51d645cfbee4d9e7f19" translate="yes" xml:space="preserve">
          <source>How to generate a self-signed certificate in OpenSSL.</source>
          <target state="translated">OpenSSL에서 자체 서명 인증서를 생성하는 방법</target>
        </trans-unit>
        <trans-unit id="6e58af548e7919c5cb4a5f331e1ccba0ba47885e" translate="yes" xml:space="preserve">
          <source>How to generate binary tar.gz files</source>
          <target state="translated">이진 tar.gz 파일을 생성하는 방법</target>
        </trans-unit>
        <trans-unit id="cdbb89fab106b3fe582c3ebf4136e25166d3151d" translate="yes" xml:space="preserve">
          <source>How to generate binary tar.gz files.</source>
          <target state="translated">이진 tar.gz 파일을 생성하는 방법</target>
        </trans-unit>
        <trans-unit id="8d7cb9333b159e88667586caf5f004c88d788970" translate="yes" xml:space="preserve">
          <source>How to get optimal performance.</source>
          <target state="translated">최적의 성능을 얻는 방법.</target>
        </trans-unit>
        <trans-unit id="b383e6885ff3fc6b8b0a356a2f9fb0f749ed2045" translate="yes" xml:space="preserve">
          <source>How to get the source code for MariaDB from GitHub.</source>
          <target state="translated">GitHub에서 MariaDB의 소스 코드를 얻는 방법</target>
        </trans-unit>
        <trans-unit id="7239369534e052d8d4cbb065e722144245754c6c" translate="yes" xml:space="preserve">
          <source>How to implement an OEM handler is out of the scope of this document.</source>
          <target state="translated">OEM 처리기를 구현하는 방법은이 문서에서 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9441e253ff953f70d39d2dbb025dcb150139b47" translate="yes" xml:space="preserve">
          <source>How to install ColumnStore on a multi-server system</source>
          <target state="translated">다중 서버 시스템에 ColumnStore를 설치하는 방법</target>
        </trans-unit>
        <trans-unit id="56db593e53b87540b403f009477609f46bdee7ff" translate="yes" xml:space="preserve">
          <source>How to install ColumnStore on a single server system.</source>
          <target state="translated">단일 서버 시스템에 ColumnStore를 설치하는 방법</target>
        </trans-unit>
        <trans-unit id="cda5993b7b16d03e1d05c5914d770ecf9ab9a3e2" translate="yes" xml:space="preserve">
          <source>How to install MariaDB with zypper on SLES, OpenSUSE, and other similar Linux distributions.</source>
          <target state="translated">SLES, OpenSUSE 및 기타 유사한 Linux 배포판에 zypper와 함께 MariaDB를 설치하는 방법</target>
        </trans-unit>
        <trans-unit id="f55025c9e04907c94960813454a7487a51f254e8" translate="yes" xml:space="preserve">
          <source>How to install Mroonga's user-defined functions.</source>
          <target state="translated">Mroonga의 사용자 정의 함수를 설치하는 방법.</target>
        </trans-unit>
        <trans-unit id="47021fcc145c325a276e9c092f012b18ba76f672" translate="yes" xml:space="preserve">
          <source>How to install and enable TokuDB in MariaDB.</source>
          <target state="translated">MariaDB에서 TokuDB를 설치하고 활성화하는 방법</target>
        </trans-unit>
        <trans-unit id="e8fe3ef52f5b8b7bdbe59637c8ca7512c9b507d6" translate="yes" xml:space="preserve">
          <source>How to install and test SphinxSE</source>
          <target state="translated">SphinxSE 설치 및 테스트 방법</target>
        </trans-unit>
        <trans-unit id="4d8be6ec3cce026c3af5177b5ab7e4cf55403fd1" translate="yes" xml:space="preserve">
          <source>How to know what will be a where clause or a having clause.</source>
          <target state="translated">where 절이나 having 절이 무엇인지 아는 방법.</target>
        </trans-unit>
        <trans-unit id="21c608cea300af3e4fb32565315534f9f089edb6" translate="yes" xml:space="preserve">
          <source>How to load and manipulate data into MariaDB ColumnStore</source>
          <target state="translated">MariaDB ColumnStore에 데이터를로드하고 조작하는 방법</target>
        </trans-unit>
        <trans-unit id="10a9b4a93665310e8e3d5e4ec3fdc0564020e4ee" translate="yes" xml:space="preserve">
          <source>How to load large tables.</source>
          <target state="translated">큰 테이블을로드하는 방법</target>
        </trans-unit>
        <trans-unit id="2181c767fcee6bc11ff05a80e99ffbcfca0885c9" translate="yes" xml:space="preserve">
          <source>How to match API version for php5_mysql and mariadb client?</source>
          <target state="translated">php5_mysql 및 mariadb 클라이언트의 API 버전을 일치시키는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="40da55d83b13389d06bd132efe8f47e623ed2594" translate="yes" xml:space="preserve">
          <source>How to modify statements priority with storage engines supporting table-level locks.</source>
          <target state="translated">테이블 레벨 잠금을 지원하는 스토리지 엔진으로 명령문 우선 순위를 수정하는 방법</target>
        </trans-unit>
        <trans-unit id="1b4703949cd68481f3a187949fdc009f6a53e3f4" translate="yes" xml:space="preserve">
          <source>How to obtain information about partitions definition</source>
          <target state="translated">파티션 정의에 대한 정보를 얻는 방법</target>
        </trans-unit>
        <trans-unit id="cd8bccd47147b191874ca75e49d0749a898c8281" translate="yes" xml:space="preserve">
          <source>How to quickly insert data into MariaDB</source>
          <target state="translated">MariaDB에 데이터를 빠르게 삽입하는 방법</target>
        </trans-unit>
        <trans-unit id="a9810a4b147384705004149d9ca37478c1d31b22" translate="yes" xml:space="preserve">
          <source>How to reference an object and its context in an SQL statement.</source>
          <target state="translated">SQL 문에서 오브젝트 및 해당 컨텍스트를 참조하는 방법</target>
        </trans-unit>
        <trans-unit id="d63a46f90e9c77f16bb43ee8c318c8a414188a0c" translate="yes" xml:space="preserve">
          <source>How to see the storage engine in action</source>
          <target state="translated">스토리지 엔진의 작동 상태를 보는 방법</target>
        </trans-unit>
        <trans-unit id="a39db5317506d0881f74f74f2d43c66ee1e62bf5" translate="yes" xml:space="preserve">
          <source>How to specify MYSQL_ERRNO and MESSAGE_TEXT properties:</source>
          <target state="translated">MYSQL_ERRNO 및 MESSAGE_TEXT 속성을 지정하는 방법 :</target>
        </trans-unit>
        <trans-unit id="cdc10d784225a9b71ee318cbcce40034fb4a3b6e" translate="yes" xml:space="preserve">
          <source>How to specify a table-specific &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;character set&lt;/a&gt; and another for a column.</source>
          <target state="translated">테이블 특정 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;문자 집합과&lt;/a&gt; 열에 다른 문자 집합 을 지정하는 방법</target>
        </trans-unit>
        <trans-unit id="a8a9168106dfa57e5eadb84396eaaf5e1052d5c5" translate="yes" xml:space="preserve">
          <source>How to start a table with a set AUTO_INCREMENT value?</source>
          <target state="translated">설정된 AUTO_INCREMENT 값으로 테이블을 시작하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="fdafe44c325a9c36086e42afea57b8aad27a97ce" translate="yes" xml:space="preserve">
          <source>How to unset a flag:</source>
          <target state="translated">플래그를 설정 해제하는 방법 :</target>
        </trans-unit>
        <trans-unit id="00a43ccdf31fa5d710533b7df1086989a80bdeac" translate="yes" xml:space="preserve">
          <source>How to upgrade</source>
          <target state="translated">업그레이드하는 방법</target>
        </trans-unit>
        <trans-unit id="0758dedccf4cc682ef6b5549a3ddb9ea5b09753d" translate="yes" xml:space="preserve">
          <source>How to upgrade from MariaDB 10.0 to MariaDB 10.1.</source>
          <target state="translated">MariaDB 10.0에서 MariaDB 10.1로 업그레이드하는 방법</target>
        </trans-unit>
        <trans-unit id="aca204f1c6c6f4a9377606b21cac421df74c22df" translate="yes" xml:space="preserve">
          <source>How to upgrade from MariaDB 10.1 to MariaDB 10.2 in a Galera Cluster deployment.</source>
          <target state="translated">Galera Cluster 배포에서 MariaDB 10.1에서 MariaDB 10.2로 업그레이드하는 방법</target>
        </trans-unit>
        <trans-unit id="02a1cb3229c3f80335c8cc3706dd6ada6327333b" translate="yes" xml:space="preserve">
          <source>How to upgrade from MariaDB 10.1 to MariaDB 10.2.</source>
          <target state="translated">MariaDB 10.1에서 MariaDB 10.2로 업그레이드하는 방법</target>
        </trans-unit>
        <trans-unit id="e96c3b29b0d47a8c5481099296133ed0699449cf" translate="yes" xml:space="preserve">
          <source>How to upgrade from MariaDB 10.2 to MariaDB 10.3 in a Galera Cluster deployment.</source>
          <target state="translated">Galera Cluster 배포에서 MariaDB 10.2에서 MariaDB 10.3으로 업그레이드하는 방법</target>
        </trans-unit>
        <trans-unit id="f709d8ef148a02727847baf564b10b55a02ecdfb" translate="yes" xml:space="preserve">
          <source>How to upgrade from MariaDB 10.2 to MariaDB 10.3.</source>
          <target state="translated">MariaDB 10.2에서 MariaDB 10.3으로 업그레이드하는 방법</target>
        </trans-unit>
        <trans-unit id="61d9ab8d3b1611d1238787977c6ba22be6395318" translate="yes" xml:space="preserve">
          <source>How to upgrade from MariaDB 10.3 to MariaDB 10.4 in a Galera Cluster deployment.</source>
          <target state="translated">Galera Cluster 배포에서 MariaDB 10.3에서 MariaDB 10.4로 업그레이드하는 방법</target>
        </trans-unit>
        <trans-unit id="251d34bda7c921e19891bb658d134099e9f382f6" translate="yes" xml:space="preserve">
          <source>How to upgrade from MariaDB 10.3 to MariaDB 10.4.</source>
          <target state="translated">MariaDB 10.3에서 MariaDB 10.4로 업그레이드하는 방법</target>
        </trans-unit>
        <trans-unit id="e5d91217371f304691b3c0971a3695edd4fe51f9" translate="yes" xml:space="preserve">
          <source>How to upgrade from MariaDB 10.4 to MariaDB 10.5.</source>
          <target state="translated">MariaDB 10.4에서 MariaDB 10.5로 업그레이드하는 방법</target>
        </trans-unit>
        <trans-unit id="9463f814b086145e2216a90c21cf36e86cb7f86b" translate="yes" xml:space="preserve">
          <source>How to upgrade from MariaDB 5.3 to MariaDB 5.5</source>
          <target state="translated">MariaDB 5.3에서 MariaDB 5.5로 업그레이드하는 방법</target>
        </trans-unit>
        <trans-unit id="8f4aed61902fbf95bd0b0b8bad8274719b031121" translate="yes" xml:space="preserve">
          <source>How to upgrade from MariaDB 5.5 to MariaDB 10.0.</source>
          <target state="translated">MariaDB 5.5에서 MariaDB 10.0으로 업그레이드하는 방법</target>
        </trans-unit>
        <trans-unit id="fd919f937caaa3409e8f6d7029e59f4ec1c6d66d" translate="yes" xml:space="preserve">
          <source>How to upgrade from MariaDB Galera Cluster 10.0 to MariaDB 10.1 in a Galera Cluster deployment.</source>
          <target state="translated">Galera Cluster 배포에서 MariaDB Galera Cluster 10.0에서 MariaDB 10.1로 업그레이드하는 방법</target>
        </trans-unit>
        <trans-unit id="51a382eb308d81ee875863ce8711d1f883737a3d" translate="yes" xml:space="preserve">
          <source>How to upgrade from MariaDB Galera Cluster 5.5 to MariaDB Galera Cluster 10.0</source>
          <target state="translated">MariaDB Galera Cluster 5.5에서 MariaDB Galera Cluster 10.0으로 업그레이드하는 방법</target>
        </trans-unit>
        <trans-unit id="d2c36d39f28548cf8a72d9208bb2376484322027" translate="yes" xml:space="preserve">
          <source>How to use named error conditions:</source>
          <target state="translated">명명 된 오류 조건을 사용하는 방법 :</target>
        </trans-unit>
        <trans-unit id="d83ed5c677d6dec8e8c13a61a1244b8a35a4a2dc" translate="yes" xml:space="preserve">
          <source>How to use partitioning</source>
          <target state="translated">파티셔닝을 사용하는 방법</target>
        </trans-unit>
        <trans-unit id="2bfc5c0f5955e19d601dd303de116ff979ab5304" translate="yes" xml:space="preserve">
          <source>How to use the &lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt; and &lt;a href=&quot;../limit/index&quot;&gt;LIMIT&lt;/a&gt; clauses:</source>
          <target state="translated">&lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt; 및 &lt;a href=&quot;../limit/index&quot;&gt;LIMIT&lt;/a&gt; 절 을 사용하는 방법 :</target>
        </trans-unit>
        <trans-unit id="59c48b414c870c8fbb6d5f0c985a7a0d2f97fe74" translate="yes" xml:space="preserve">
          <source>How to use the RETURNING clause:</source>
          <target state="translated">RETURNING 절을 사용하는 방법 :</target>
        </trans-unit>
        <trans-unit id="2f46b7c535e5995c972866146f7b6878439fed79" translate="yes" xml:space="preserve">
          <source>How to use this table and specify the command to send? By executing a command such as:</source>
          <target state="translated">이 테이블을 사용하고 보낼 명령을 지정하는 방법은 무엇입니까? 다음과 같은 명령을 실행하여 :</target>
        </trans-unit>
        <trans-unit id="960b621c7cf985bfc0fc0f554ce2be7c03d45698" translate="yes" xml:space="preserve">
          <source>How to write compound statements.</source>
          <target state="translated">복합 문장을 작성하는 방법.</target>
        </trans-unit>
        <trans-unit id="be96046319c08b5f434a7d0faa26df1be14c44bf" translate="yes" xml:space="preserve">
          <source>How you configure replication filters with &lt;a href=&quot;../multi-source-replication/index&quot;&gt;multi-source replication&lt;/a&gt; depends on whether you are configuring them dynamically or whether you are configuring them in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../multi-source-replication/index&quot;&gt;다중 소스 복제로&lt;/a&gt; 복제 필터를 구성하는 방법 은 동적으로 구성하는지 또는 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 구성하는지에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="967811b912f2efa3986399264685357d58d4aa0b" translate="yes" xml:space="preserve">
          <source>However It would be wrong to do:</source>
          <target state="translated">그러나 다음을 수행하는 것은 잘못입니다.</target>
        </trans-unit>
        <trans-unit id="36772911fef714b4157520200cf0c76df733dc66" translate="yes" xml:space="preserve">
          <source>However as &lt;code&gt;SEQUENCE&lt;/code&gt; is implemented as a special kind of table, it uses the same namespace as tables. The benefits are that sequences show up in &lt;a href=&quot;../show-tables/index&quot;&gt;SHOW TABLES&lt;/a&gt;, and one can also create a sequence with &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; and drop it with &lt;a href=&quot;../drop-table/index&quot;&gt;DROP TABLE&lt;/a&gt;. One can &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; from it as from any other table. This ensures that all old tools that work with tables should work with sequences.</source>
          <target state="translated">그러나 &lt;code&gt;SEQUENCE&lt;/code&gt; 는 특수한 종류의 테이블로 구현되므로 테이블과 동일한 네임 스페이스를 사용합니다. 장점은 시퀀스가 &lt;a href=&quot;../show-tables/index&quot;&gt;SHOW TABLES&lt;/a&gt; 에 표시 되고 &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE을&lt;/a&gt; 사용하여 시퀀스를 생성하고 &lt;a href=&quot;../drop-table/index&quot;&gt;DROP TABLE을 사용&lt;/a&gt; 하여 삭제할 수도 있다는 것입니다 . 하나는 수 &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 그것에서 다른 테이블로. 이를 통해 테이블 ​​작업을하는 모든 기존 도구가 시퀀스에서 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="6bf8af99d2c30328615e19d11e5452a5dfa474bf" translate="yes" xml:space="preserve">
          <source>However as MariaDB has more features than MySQL, there is a few things that you should consider changing in your &lt;code&gt;my.cnf&lt;/code&gt; file.</source>
          <target state="translated">그러나 MariaDB에는 MySQL보다 많은 기능이 있으므로 &lt;code&gt;my.cnf&lt;/code&gt; 파일 에서 변경해야 할 사항이 몇 가지 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6b4e92db30422c3eba85b8a59f3c12c4b2b994c" translate="yes" xml:space="preserve">
          <source>However if we enter the apparently equivalent query on the &lt;em&gt;xsampall&lt;/em&gt; table, based on the same file:</source>
          <target state="translated">그러나 동일한 파일을 기반으로 &lt;em&gt;xsampall&lt;/em&gt; 테이블 에 명백하게 동등한 쿼리를 입력하는 경우 :</target>
        </trans-unit>
        <trans-unit id="7da0a4b1511260582b7206185e712fa5f43fa726" translate="yes" xml:space="preserve">
          <source>However only a single instance of 5.2 can exist. If for example 5.2.7 is installed on a machine where 5.2.6 is already installed, the installer will just replace 5.2.6 executables with 5.2.7 ones.</source>
          <target state="translated">그러나 5.2의 단일 인스턴스 만 존재할 수 있습니다. 예를 들어 5.2.6이 이미 설치된 시스템에 5.2.7이 설치된 경우 설치 프로그램은 5.2.6 실행 파일을 5.2.7로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="72b7695f0ad8a859507e36a1c4be5c55f48bb911" translate="yes" xml:space="preserve">
          <source>However there is no way to get the pivoted layout shown above just using SQL. Even using embedded SQL programming for some DBMS is not quite simple and automatic.</source>
          <target state="translated">그러나 SQL을 사용하여 위에 표시된 피벗 레이아웃을 얻는 방법은 없습니다. 일부 DBMS에 대해 내장 SQL 프로그래밍을 사용하는 것조차 간단하고 자동적 인 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c412b7ace4861cb4c6e29955b45e180b7d1b7348" translate="yes" xml:space="preserve">
          <source>However this does not exist in SQL. Does this mean that it is impossible to do it? No, but it requires us to use a table specified on the same file but adapted to this task. One way to do it is to specify a table for which the authors are no more an expanded array. Supposing we want to add an author to the &amp;ldquo;XML en Action&amp;rdquo; book. We will do it on a table containing just the author(s) of that book, which is the second book of the table.</source>
          <target state="translated">그러나 이것은 SQL에 존재하지 않습니다. 이것이 불가능하다는 의미입니까? 아니요, 그러나 동일한 파일에 지정되어 있지만이 작업에 적합한 테이블을 사용해야합니다. 이를 수행하는 한 가지 방법은 작성자가 더 이상 확장 배열이 아닌 테이블을 지정하는 것입니다. &quot;XML en Action&quot;책에 저자를 추가한다고 가정합니다. 우리는 그 책의 저자 (테이블의 두 번째 책) 만 포함 된 테이블에서 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="5ee92e43671160879ebe060004578fd649bd9d2c" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;../galera-cluster/index&quot;&gt;MariaDB Galera Cluster&lt;/a&gt; builds include a built-in plugin called &lt;code&gt;wsrep&lt;/code&gt;. Prior to &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt;, this plugin was internally considered an &lt;a href=&quot;index&quot;&gt;XA-capable&lt;/a&gt;&lt;a href=&quot;../storage-engines/index&quot;&gt;storage engine&lt;/a&gt;. Consequently, these &lt;a href=&quot;../galera-cluster/index&quot;&gt;MariaDB Galera Cluster&lt;/a&gt; builds have multiple XA-capable storage engines by default, even if the only &quot;real&quot; storage engine that supports external &lt;a href=&quot;index&quot;&gt;XA transactions&lt;/a&gt; enabled on these builds by default is &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt;. Therefore, when using one these builds MariaDB would be forced to use a &lt;a href=&quot;../transaction-coordinator-log/index&quot;&gt;transaction coordinator log&lt;/a&gt; by default, which could have performance implications.</source>
          <target state="translated">그러나 &lt;a href=&quot;../galera-cluster/index&quot;&gt;MariaDB Galera Cluster&lt;/a&gt; 빌드에는 &lt;code&gt;wsrep&lt;/code&gt; 라는 내장 플러그인이 포함되어 있습니다 . &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1043-release-notes/&quot;&gt;MariaDB 10.4.3&lt;/a&gt; 이전에는 이 플러그인이 내부적으로 &lt;a href=&quot;index&quot;&gt;XA 가능 &lt;/a&gt;&lt;a href=&quot;../storage-engines/index&quot;&gt;스토리지 엔진으로&lt;/a&gt; 간주 되었습니다 . 결과적으로 이러한 &lt;a href=&quot;../galera-cluster/index&quot;&gt;MariaDB Galera Cluster&lt;/a&gt; 빌드에는 기본적 으로 이러한 빌드에서 활성화 된 외부 &lt;a href=&quot;index&quot;&gt;XA 트랜잭션&lt;/a&gt; 을 지원하는 유일한 &quot;실제&quot;스토리지 엔진 이 &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB 인&lt;/a&gt; 경우에도 기본적으로 여러 XA 가능 스토리지 엔진 이 있습니다. 따라서이 빌드 중 하나를 사용할 때 MariaDB는 기본적으로 &lt;a href=&quot;../transaction-coordinator-log/index&quot;&gt;트랜잭션 코디네이터 로그&lt;/a&gt; 를 사용해야하므로 성능에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="494e1b87652e79b5fe915c5c8f5a27dd8b6d6c5c" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;VIRTUAL&lt;/code&gt; and &lt;code&gt;PERSISTENT&lt;/code&gt; generated columns differ in how their data is stored.</source>
          <target state="translated">그러나 &lt;code&gt;VIRTUAL&lt;/code&gt; 및 &lt;code&gt;PERSISTENT&lt;/code&gt; 생성 열은 데이터 저장 방법이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7d45fbc5aa8f234bfda9f970d6551d51f5641c03" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;VIRTUAL&lt;/code&gt; or &lt;code&gt;PERSISTENT&lt;/code&gt; generated columns cannot be explicitly set to any other values than &lt;code&gt;NULL&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../default/index&quot;&gt;DEFAULT&lt;/a&gt;&lt;/code&gt;. If a generated column is explicitly set to any other value, then the outcome depends on whether &lt;a href=&quot;../sql-mode/index#strict-mode&quot;&gt;strict mode&lt;/a&gt; is enabled in &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;sql_mode&lt;/a&gt;&lt;/code&gt;. If it is not enabled, then a warning will be raised and the default generated value will be used instead. If it is enabled, then an error will be raised instead.</source>
          <target state="translated">그러나 &lt;code&gt;VIRTUAL&lt;/code&gt; 또는 &lt;code&gt;PERSISTENT&lt;/code&gt; 생성 열은 &lt;code&gt;NULL&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../default/index&quot;&gt;DEFAULT&lt;/a&gt;&lt;/code&gt; 이외의 다른 값으로 명시 적으로 설정할 수 없습니다 . 생성 된 컬럼이 다른 값으로 명시 적으로 설정된 경우 결과 는 &lt;code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;sql_mode&lt;/a&gt;&lt;/code&gt; 에서 &lt;a href=&quot;../sql-mode/index#strict-mode&quot;&gt;엄격 모드&lt;/a&gt; 가 사용 가능한지 여부에 따라 다릅니다 . 사용하지 않으면 경고가 발생하고 기본 생성 값이 대신 사용됩니다. 활성화 된 경우 대신 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a467fb5a93bf8e9874f49dcaf170b7e2e1d74458" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;performance_schema&lt;/code&gt; is not a regular storage engine for storing data, it's a mechanism for implementing the Performance Schema feature.</source>
          <target state="translated">그러나 &lt;code&gt;performance_schema&lt;/code&gt; 는 데이터 저장을위한 일반 스토리지 엔진이 아니며 성능 스키마 기능을 구현하기위한 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="0a8370c7957047d95cc30698c21858b358164469" translate="yes" xml:space="preserve">
          <source>However, CONNECT uses the input format in a specific way. Instead of using it to directly store the input value in the column buffer; it uses it to delimit the sub string of the input record that contains the corresponding column value. Retrieving this value is done later by the column functions as for standard CSV files.</source>
          <target state="translated">그러나 CONNECT는 특정 방식으로 입력 형식을 사용합니다. 이를 사용하여 입력 값을 열 버퍼에 직접 저장하는 대신; 이를 사용하여 해당 열 값을 포함하는 입력 레코드의 하위 문자열을 구분합니다. 이 값 검색은 나중에 표준 CSV 파일과 같은 열 함수에 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="580628d07d9d493090cd9179956f1e097fc0e3fe" translate="yes" xml:space="preserve">
          <source>However, DBMS clients are more complicated. For example, a thread may depend on another thread's completion, and they may block each other via locks and/or I/O. Thus it is very hard, and sometimes impossible, to predict how many threads would be ideal or even sufficient to prevent deadlocks in every situation. &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; implements a dynamic/adaptive pool that itself takes care of creating new threads in times of high demand and retiring threads if they have nothing to do. This is a complete reimplementation of the legacy &lt;code&gt;pool-of-threads&lt;/code&gt; scheduler, with the following goals:</source>
          <target state="translated">그러나 DBMS 클라이언트는 더 복잡합니다. 예를 들어, 스레드는 다른 스레드의 완료에 의존 할 수 있으며 잠금 및 / 또는 I / O를 통해 서로를 차단할 수 있습니다. 따라서 모든 상황에서 교착 상태를 방지하기 위해 몇 개의 스레드가 이상적이거나 충분한 스레드인지 예측하는 것은 매우 어렵고 때로는 불가능합니다. &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 는 동적 / 적응 풀을 구현하여 수요가 많은 시간에 새 스레드를 작성하고 아무런 조치도 취하지 않으면 스레드를 처리합니다. 이는 다음과 같은 목표로 레거시 &lt;code&gt;pool-of-threads&lt;/code&gt; 스케줄러를 완전히 다시 구현 한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="d100f1d53bc517059fc4226b2345a353bdea282d" translate="yes" xml:space="preserve">
          <source>However, InnoDB also has its own limits on the maximum row size, so an InnoDB table's maximum row size could be smaller than MariaDB's global limit.</source>
          <target state="translated">그러나 InnoDB에는 최대 행 크기에 대한 자체 제한이 있으므로 InnoDB 테이블의 최대 행 크기는 MariaDB의 전역 제한보다 작을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d1e19bf58a9ddc5c9ff6fefb0050e92c111f9c6" translate="yes" xml:space="preserve">
          <source>However, InnoDB page compression is still likely to be most optimized on solid state drives (SSDs) and other flash storage.</source>
          <target state="translated">그러나 SSD (Solid State Drive) 및 기타 플래시 스토리지에서는 여전히 InnoDB 페이지 압축이 가장 최적화 될 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="87b2d4dd391b5bf4af7d3c5c0c8a228c3aa8a3a3" translate="yes" xml:space="preserve">
          <source>However, MariaDB can't check whether a UDF is deterministic, so it is up to the user to be sure that they do not use non-deterministic UDFs with &lt;code&gt;VIRTUAL&lt;/code&gt; generated columns.</source>
          <target state="translated">그러나 MariaDB는 UDF가 결정적인지 여부를 확인할 수 없으므로 &lt;code&gt;VIRTUAL&lt;/code&gt; 생성 열에 비 결정적 UDF를 사용하지 않는 것은 사용자의 몫 입니다.</target>
        </trans-unit>
        <trans-unit id="75de5c5f669696b8bb7f04281c7c205967bf4f83" translate="yes" xml:space="preserve">
          <source>However, TRUNCATE TABLE causes an implicit commit even when used on a temporary table.</source>
          <target state="translated">그러나 TRUNCATE TABLE은 임시 테이블에서 사용될 때에도 암시 적 커밋을 유발합니다.</target>
        </trans-unit>
        <trans-unit id="4a597e5589186beb3beb9f8d07c598822c521b56" translate="yes" xml:space="preserve">
          <source>However, a SEQUENCE table can be converted to another engine and the new table can be referred in any statement:</source>
          <target state="translated">그러나 SEQUENCE 테이블을 다른 엔진으로 변환 할 수 있으며 새 테이블을 모든 명령문에서 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a85d08033940eb9a834f6d3fe90753517ccf62c7" translate="yes" xml:space="preserve">
          <source>However, a column in a MERGE table can &lt;strong&gt;not&lt;/strong&gt; be defined as a &lt;code&gt;VIRTUAL&lt;/code&gt; and &lt;code&gt;PERSISTENT&lt;/code&gt; generated column.</source>
          <target state="translated">그러나 MERGE 테이블의 열을 &lt;code&gt;VIRTUAL&lt;/code&gt; 및 &lt;code&gt;PERSISTENT&lt;/code&gt; 생성 열로 정의 할 수 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4dd252957442abba37e8fd629ed6c9bbe308c619" translate="yes" xml:space="preserve">
          <source>However, after:</source>
          <target state="translated">그러나, 이후 :</target>
        </trans-unit>
        <trans-unit id="4b5674e0fea123df4cfaba4ffd24f41e4df6d264" translate="yes" xml:space="preserve">
          <source>However, an additional user account that is defined by the &lt;code&gt;--auth-root-socket-user&lt;/code&gt; option is created. If this option is not set, then the value defaults to the value of the &lt;code&gt;--user&lt;/code&gt; option. On most systems, the &lt;code&gt;--user&lt;/code&gt; option will use the value of &lt;code&gt;mysql&lt;/code&gt; by default, so this additional user account would be called &lt;code&gt;mysql@localhost&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;--auth-root-socket-user&lt;/code&gt; 옵션으로 정의 된 추가 사용자 계정 이 생성됩니다. 이 옵션을 설정하지 않으면 기본값은 &lt;code&gt;--user&lt;/code&gt; 옵션 의 값입니다 . 대부분의 시스템에서 &lt;code&gt;--user&lt;/code&gt; 옵션은 기본적 으로 &lt;code&gt;mysql&lt;/code&gt; 값을 사용 하므로이 추가 사용자 계정은 &lt;code&gt;mysql@localhost&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="acac4e24ebc00a57c1d2601cbc1e5070e3f1165c" translate="yes" xml:space="preserve">
          <source>However, an alternate way to do it is by using direct JSON column representation as in the &lt;code&gt;JSAMPLE2&lt;/code&gt; table. This can be done by:</source>
          <target state="translated">그러나이를 수행하는 다른 방법은 &lt;code&gt;JSAMPLE2&lt;/code&gt; 테이블 에서와 같이 직접 JSON 열 표시를 사용하는 것입니다 . 이 작업은 다음과 같이 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2ebee3119af93be9d3d012808b9732f07d64ca7" translate="yes" xml:space="preserve">
          <source>However, an index can be specified for columns that are prone to be used to join another table to the MYSQL table. For instance:</source>
          <target state="translated">그러나 다른 테이블을 MYSQL 테이블에 조인하는 데 사용되는 열에 대해 인덱스를 지정할 수 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="f36453b32b2ff11f0724273ad3a876b19a0fc1f8" translate="yes" xml:space="preserve">
          <source>However, any OS user can read this information from systemd, which could be considered a security risk. Another solution is to put the credentials in a separate file that is only readable by root and then refer to that file using an &lt;code&gt;EnvironmentFile&lt;/code&gt; directive in a drop-in systemd file.</source>
          <target state="translated">그러나 모든 OS 사용자는 systemd에서이 정보를 읽을 수 있으며 이는 보안 위험으로 간주 될 수 있습니다. 다른 해결책은 루트 만 읽을 수있는 별도의 파일에 자격 증명을 넣은 다음 드롭 인 시스템 파일에서 &lt;code&gt;EnvironmentFile&lt;/code&gt; 지시문을 사용하여 해당 파일을 참조하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="092649f5a5565eff2e000cbd80fd966242c00a10" translate="yes" xml:space="preserve">
          <source>However, autoincrement columns are not constrained to unique values. If you insert or update a row and explicitly code a value [other than NULL or 0 (zero)], ColumnStore will insert that value (provided it meets all other requirements for that datatype), even if it causes duplicate values for the column, and no error or warning will be issued.</source>
          <target state="translated">그러나 자동 증분 열은 고유 한 값으로 제한되지 않습니다. 행을 삽입하거나 업데이트하고 NULL 또는 0 이외의 값을 명시 적으로 코딩하면 ColumnStore는 열에 중복 값이 ​​발생하더라도 해당 값을 삽입합니다 (해당 데이터 유형의 다른 모든 요구 사항을 충족하는 경우). 오류나 경고가 발행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="890f94590c9b314310768841fe19bac914d72843" translate="yes" xml:space="preserve">
          <source>However, averages can be skewed by extremes, and the usual culprit is NULL values. The row of 100 may have 19 groups with an average size of 1, while the other 81 values are all NULL. MariaDB may think five is a good average size and choose to use that index, and then end up having to read through 81 rows with identical keys, taking longer than an alternative.</source>
          <target state="translated">그러나 평균은 극단으로 치우칠 수 있으며 일반적인 원인은 NULL 값입니다. 100 행에는 평균 크기가 1 인 19 개의 그룹이있을 수 있지만 다른 81 개의 값은 모두 NULL입니다. MariaDB는 5가 좋은 평균 크기라고 생각하고 해당 인덱스를 사용하기로 선택한 다음 동일한 키를 사용하여 81 개 행을 읽고 대체 키보다 더 오래 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8651d7e43d658355fca8a49e7e4fade56bd3eb83" translate="yes" xml:space="preserve">
          <source>However, because of the way &lt;code&gt;IN&lt;/code&gt; is implemented (it is rewritten as a sequence of &lt;code&gt;=&lt;/code&gt; comparisons and &lt;code&gt;AND&lt;/code&gt;), the expression in</source>
          <target state="translated">그러나 &lt;code&gt;IN&lt;/code&gt; 이 구현 되는 방식 ( &lt;code&gt;=&lt;/code&gt; 비교 및 &lt;code&gt;AND&lt;/code&gt; 순서로 다시 작성 됨 )으로 인해</target>
        </trans-unit>
        <trans-unit id="ede9e688348b2d629f4c8f4b559a3050bb6ea63b" translate="yes" xml:space="preserve">
          <source>However, building a permanent index is not yet implemented. It is unclear whether this can be useful. Indeed, the DOM implementation that is used to access these tables firstly parses the whole file and constructs a node tree in memory. This may often be the longest part of the process, so the use of an index would not be of great value. Note also that this limits the XML files to a reasonable size. Anyway, when speed is important, this table type is not the best to use. Therefore, in these cases, it is probably better to convert the file to another type by inserting the XML table into another table of a more appropriate type for performance.</source>
          <target state="translated">그러나 영구 색인 작성은 아직 구현되지 않았습니다. 이것이 유용한 지 확실하지 않습니다. 실제로 이러한 테이블에 액세스하는 데 사용되는 DOM 구현은 먼저 전체 파일을 구문 분석하고 메모리에 노드 트리를 구성합니다. 이것은 종종 프로세스의 가장 긴 부분 일 수 있으므로 인덱스 사용은 큰 가치가 없습니다. 또한 XML 파일을 적당한 크기로 제한합니다. 어쨌든 속도가 중요 할 때이 테이블 유형이 가장 적합하지 않습니다. 따라서 이러한 경우 XML 테이블을 성능에보다 적합한 유형의 다른 테이블에 삽입하여 파일을 다른 유형으로 변환하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="93be2c448e054cbecf615e9f6658c93232271732" translate="yes" xml:space="preserve">
          <source>However, defining a generated column based on other generated columns defined after in the table definition is &lt;strong&gt;not&lt;/strong&gt; supported in expressions for generation columns because generated columns are calculated in the order they are defined.</source>
          <target state="translated">그러나 생성 된 컬럼은 정의 된 순서대로 계산되므로 테이블 정의에서 정의 된 다른 생성 된 컬럼을 기반으로 생성 된 컬럼을 정의하는 것은 생성 컬럼의 표현식에서 지원 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1932e394dbb6942a3c3f050c430ed8df074db5fe" translate="yes" xml:space="preserve">
          <source>However, if &lt;a href=&quot;../innodb-strict-mode/index&quot;&gt;InnoDB strict mode&lt;/a&gt; is enabled, then the same message will be logged as an error.</source>
          <target state="translated">그러나 &lt;a href=&quot;../innodb-strict-mode/index&quot;&gt;InnoDB 엄격 모드&lt;/a&gt; 가 활성화 된 경우 동일한 메시지가 오류로 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="45a2ba02c55c5d085dab905d89bac1f670af8f45" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;OFF&lt;/code&gt; or if &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_threads&quot;&gt;innodb_encryption_threads&lt;/a&gt;&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, then this will not work. See &lt;a href=&quot;../innodb-encryption-troubleshooting/index#setting-encryption-key-id-for-an-unencrypted-table&quot;&gt;InnoDB Encryption Troubleshooting: Setting Encryption Key ID For an Unencrypted Table&lt;/a&gt; for more information.</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encrypt_tables&quot;&gt;innodb_encrypt_tables&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;OFF&lt;/code&gt; 로 설정 되거나 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_encryption_threads&quot;&gt;innodb_encryption_threads&lt;/a&gt;&lt;/code&gt; 가 &lt;code&gt;0&lt;/code&gt; 으로 설정 되면 작동하지 않습니다. 자세한 내용은 &lt;a href=&quot;../innodb-encryption-troubleshooting/index#setting-encryption-key-id-for-an-unencrypted-table&quot;&gt;InnoDB 암호화 문제 해결 : 암호화되지 않은 테이블의 암호화 키 ID 설정&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="36191fa8be321c79d0485725e367391e054f200d" translate="yes" xml:space="preserve">
          <source>However, if MariaDB encounters a full disk error while trying to open a new binary log file, then it will disable binary logging entirely. A log message like the following will be written to the error log:</source>
          <target state="translated">그러나 새 이진 로그 파일을 열려고 시도하는 동안 MariaDB에서 디스크 전체 오류가 발생하면 이진 로깅이 완전히 비활성화됩니다. 다음과 같은 로그 메시지가 오류 로그에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="7e56b22d68f49969d5d899895e7b4ab1ea6cb690" translate="yes" xml:space="preserve">
          <source>However, if the master crashes, then its &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; may also contain events for transactions that were prepared by the storage engine and written to the binary log, but that were never actually committed by the storage engine. As part of the server's &lt;a href=&quot;../heuristic-recovery-with-the-transaction-coordinator-log/index&quot;&gt;automatic crash recovery&lt;/a&gt; process, the server may recover these prepared transactions when the server is restarted. This could cause the crashed master to become inconsistent with the slaves. Therefore, the crashed master may need to be rebuilt. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-19733&quot;&gt;MDEV-19733&lt;/a&gt; for more information.</source>
          <target state="translated">그러나 마스터가 충돌하면 해당 &lt;a href=&quot;../binary-log/index&quot;&gt;2 진 로그&lt;/a&gt; 에는 스토리지 엔진이 준비 하고 2 진 로그에 기록한 트랜잭션에 대한 이벤트도 포함될 수 있지만 실제로는 스토리지 엔진에 의해 커밋되지 않았습니다. 서버의 &lt;a href=&quot;../heuristic-recovery-with-the-transaction-coordinator-log/index&quot;&gt;자동 응급 복구&lt;/a&gt; 프로세스 의 일부로 서버는 서버가 다시 시작될 때 준비된 트랜잭션을 복구 할 수 있습니다. 이로 인해 충돌 한 마스터가 슬레이브와 일치하지 않을 수 있습니다. 따라서 충돌 한 마스터를 다시 빌드해야 할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-19733&quot;&gt;MDEV-19733&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1d5462bb248ea2c265b3ce9d493df1a49b5a483f" translate="yes" xml:space="preserve">
          <source>However, if the rows are likely to be 'near' each other (based on the PRIMARY KEY), then it could be &amp;lt; 1 disk hit/row.</source>
          <target state="translated">그러나 PRIMARY KEY를 기준으로 행이 서로 '가까워 질'가능성이 있다면 &amp;lt;1 디스크 적중 / 행일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ae54a6a6db82a5886ce1f0f070cdc670637f795" translate="yes" xml:space="preserve">
          <source>However, if user updates are done independently on multiple servers at the same time, then in general it is not possible for binlog order to be identical across all servers. This can happen when using multi-source replication, with multi-master ring topologies, or just if manual updates are done on a slave that is replicating from active master. If the binlog order is different on the new master from the order on the old master, then it is not sufficient for the slave to keep track of a single GTID to completely record the current state.</source>
          <target state="translated">그러나 사용자 업데이트가 여러 서버에서 동시에 독립적으로 수행되는 경우 일반적으로 모든 서버에서 binlog 순서가 동일 할 수는 없습니다. 이는 다중 마스터 링 토폴로지와 함께 다중 소스 복제를 사용하거나 활성 마스터에서 복제하는 슬레이브에서 수동 업데이트가 수행되는 경우에 발생할 수 있습니다. 새 마스터에서 binlog 순서가 이전 마스터의 순서와 다르면 슬레이브가 단일 GTID를 추적하여 현재 상태를 완전히 기록하는 것만으로는 충분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="043963337a2fb4528d18ec85bf1c105426e96a51" translate="yes" xml:space="preserve">
          <source>However, if we prefer to specify them (to eventually modify them) we must know what the column definitions of that table are. We can get this information with a catalog table. This is how to do it:</source>
          <target state="translated">그러나 지정하기를 원한다면 (결국 수정하기 위해) 해당 테이블의 열 정의가 무엇인지 알아야합니다. 이 정보는 카탈로그 테이블로 얻을 수 있습니다. 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b3e50aea936cb291b1d87da5806c28518b1c3ad6" translate="yes" xml:space="preserve">
          <source>However, if you only want a record of queries that change data, it might be better to use the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; instead. One important difference is that the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; only logs a query when the transaction is committed by the server, but the general query log logs a query immediately when it is received by the server.</source>
          <target state="translated">그러나 데이터를 변경하는 쿼리 레코드 만 원하는 경우 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그를&lt;/a&gt; 대신 사용하는 것이 좋습니다. 중요한 차이점은 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 는 서버에서 트랜잭션을 커밋 할 때만 쿼리를 기록하지만 일반 쿼리 로그는 서버에서 트랜잭션을 수신하면 즉시 쿼리를 기록한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d0e54596bafe57231c1ee59e78eb09ed8051177d" translate="yes" xml:space="preserve">
          <source>However, if you specify a user name, no error is issued for non-connected (or even non-existing) users. To check if the connection/query has been killed, you can use the &lt;a href=&quot;../row_count/index&quot;&gt;ROW_COUNT()&lt;/a&gt; function.</source>
          <target state="translated">그러나 사용자 이름을 지정하면 연결되지 않은 (또는 존재하지 않는) 사용자에게는 오류가 발생하지 않습니다. 연결 / 쿼리가 종료되었는지 확인하기 위해 &lt;a href=&quot;../row_count/index&quot;&gt;ROW_COUNT ()&lt;/a&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8645c0e7c13fd28df4462594aabf1d40da72e72d" translate="yes" xml:space="preserve">
          <source>However, if you want to drop all tables in the database, but you also want to keep the database itself and any other non-table objects in it, then you would need to execute &lt;code&gt;DROP TABLE&lt;/code&gt; to drop each individual table. You can construct these &lt;code&gt;DROP TABLE&lt;/code&gt; commands by querying the &lt;code&gt;&lt;a href=&quot;../information-schema-tables-table/index&quot;&gt;TABLES&lt;/a&gt;&lt;/code&gt; table in the &lt;code&gt;&lt;a href=&quot;../information-schema-tables/index&quot;&gt;information_schema&lt;/a&gt;&lt;/code&gt; database. For example:</source>
          <target state="translated">그러나 데이터베이스의 모든 테이블을 삭제하고 데이터베이스 자체와 테이블이 아닌 다른 개체도 유지하려면 &lt;code&gt;DROP TABLE&lt;/code&gt; 을 실행 하여 각 개별 테이블을 삭제 해야 합니다. &lt;code&gt;&lt;a href=&quot;../information-schema-tables/index&quot;&gt;information_schema&lt;/a&gt;&lt;/code&gt; 데이터베이스 에서 &lt;code&gt;&lt;a href=&quot;../information-schema-tables-table/index&quot;&gt;TABLES&lt;/a&gt;&lt;/code&gt; 테이블 을 쿼리하여 이러한 &lt;code&gt;DROP TABLE&lt;/code&gt; 명령을 구성 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f72c1f191109317ee896be5c620a3165d4ef5ee" translate="yes" xml:space="preserve">
          <source>However, if you would like to use the old one thread per-connection behavior on Windows, then you can use use that by setting the &lt;code&gt;&lt;a href=&quot;../thread-pool-system-and-status-variables/index#thread_handling&quot;&gt;thread_handling&lt;/a&gt;&lt;/code&gt; system variable to &lt;code&gt;one-thread-per-connection&lt;/code&gt; in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; prior to starting up the server. For example:</source>
          <target state="translated">당신이 Windows의 이전 스레드 당 연결 동작을 사용하려는 경우, 당신은 그 설정하여 사용을 사용할 수 있습니다 &lt;code&gt;&lt;a href=&quot;../thread-pool-system-and-status-variables/index#thread_handling&quot;&gt;thread_handling&lt;/a&gt;&lt;/code&gt; 의 에 시스템 변수를 &lt;code&gt;one-thread-per-connection&lt;/code&gt; 서버에서 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 에 앞서 서버 시작 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3640d087aa54094da2b977595dfcfeaf58e80734" translate="yes" xml:space="preserve">
          <source>However, in &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; and later, the purge process will set a row's &lt;code&gt;DB_TRX_ID&lt;/code&gt; column to &lt;code&gt;0&lt;/code&gt; after all of the row's associated &lt;a href=&quot;../innodb-undo-log/index&quot;&gt;InnoDB undo log&lt;/a&gt; records have been deleted. This change allows InnoDB to perform an optimization: if a query wants to read a row, and if the row's &lt;code&gt;DB_TRX_ID&lt;/code&gt; column is set to &lt;code&gt;0&lt;/code&gt;, then it knows that no other transaction has the row locked. Usually, InnoDB needs to lock the transaction system's mutex in order to safely check whether a row is locked, but this optimization allows InnoDB to confirm that the row can be safely read without any heavy internal locking.</source>
          <target state="translated">그러나 &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; 이상에서 제거 프로세스는 모든 행의 관련 &lt;a href=&quot;../innodb-undo-log/index&quot;&gt;InnoDB 실행 취소 로그&lt;/a&gt; 레코드가 삭제 된 후 행의 &lt;code&gt;DB_TRX_ID&lt;/code&gt; 열을 &lt;code&gt;0&lt;/code&gt; 으로 설정합니다 . 이 변경으로 InnoDB는 최적화를 수행 할 수 있습니다. 쿼리가 행을 읽으려고하고 행의 &lt;code&gt;DB_TRX_ID&lt;/code&gt; 열이 &lt;code&gt;0&lt;/code&gt; 으로 설정되어 있으면 다른 트랜잭션이 행을 잠그지 않았 음을 알 수 있습니다. 일반적으로 InnoDB는 행이 잠겨 있는지 안전하게 확인하기 위해 트랜잭션 시스템의 뮤텍스를 잠글 필요가 있지만,이 최적화를 통해 InnoDB는 내부 잠금 없이도 행을 안전하게 읽을 수 있음을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b85c7626e014a6b62fa1d41476d502530e0b38d3" translate="yes" xml:space="preserve">
          <source>However, in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3&lt;/a&gt; and before, &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; stores the table's &lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt; counter in memory. In these versions, when the server restarts, the counter is re-initialized to the highest value found in the table. This means that the above operation can be undone if the server is restarted before any rows are written to the table.</source>
          <target state="translated">그러나 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3 이하&lt;/a&gt; 에서는 &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; 가 테이블의 &lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt; 카운터를 메모리에 저장합니다. 이 버전에서 서버가 다시 시작되면 테이블에서 찾은 가장 높은 값으로 카운터가 다시 초기화됩니다. 이는 행이 테이블에 기록되기 전에 서버가 다시 시작되면 위 작업을 취소 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0f23c4925910b9c0eff33486528eac174c1c871e" translate="yes" xml:space="preserve">
          <source>However, in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1036-release-notes/&quot;&gt;MariaDB 10.3.6&lt;/a&gt; and before, if the value of the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#old_alter_table&quot;&gt;old_alter_table&lt;/a&gt;&lt;/code&gt; system variable is set to &lt;code&gt;ON&lt;/code&gt;, then the default behavior is to perform &lt;code&gt;ALTER TABLE&lt;/code&gt; operations by making a copy of the table using the old algorithm.</source>
          <target state="translated">그러나 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1036-release-notes/&quot;&gt;MariaDB 10.3.6 이하&lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#old_alter_table&quot;&gt;old_alter_table&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 값이 &lt;code&gt;ON&lt;/code&gt; 으로 설정된 경우 기본 동작은 이전 알고리즘을 사용하여 테이블의 사본을 작성하여 &lt;code&gt;ALTER TABLE&lt;/code&gt; 조작 을 수행 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="03d18cefc5ca455bb331b04190c2c0c01a645885" translate="yes" xml:space="preserve">
          <source>However, in practice, synchronous database replication has traditionally been implemented via the so-called &quot;2-phase commit&quot; or distributed locking which proved to be very slow. Low performance and complexity of implementation of synchronous replication led to a situation where asynchronous replication remains the dominant means for database performance scalability and availability. Widely adopted open-source databases such as MySQL or PostgreSQL offer only asynchronous or semi-synchronous replication solutions.</source>
          <target state="translated">그러나 실제로는 동기식 데이터베이스 복제가 전통적으로 소위 &quot;2 단계 커밋&quot;또는 분산 잠금을 통해 구현되어 매우 느려졌습니다. 동기식 복제 구현의 성능 및 복잡성이 낮 으면 비동기식 복제가 데이터베이스 성능 확장 성 및 가용성의 주요 수단으로 남아있는 상황이 발생했습니다. MySQL 또는 PostgreSQL과 같이 널리 채택 된 오픈 소스 데이터베이스는 비동기식 또는 반 동기식 복제 솔루션 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d1e6b9977402b3f725f1111439513445b4628dfd" translate="yes" xml:space="preserve">
          <source>However, in the second query &lt;em&gt;Json_Object_Add&lt;/em&gt; does modify the json file and returns the file name. The &lt;em&gt;Json_Object&lt;/em&gt; function receives this file name, reads and parses the file, makes an object from it and returns the serialized result. This modification can be done willingly but can be an unwanted side effect of the query.</source>
          <target state="translated">그러나 두 번째 쿼리에서 &lt;em&gt;Json_Object_Add&lt;/em&gt; 는 json 파일을 수정하고 파일 이름을 반환합니다. &lt;em&gt;JSON_OBJECT의&lt;/em&gt; 기능은,이 파일 이름을 수신 읽고 파일을 구문 분석, 그것에서 개체를 만들고 직렬화 된 결과를 반환합니다. 이 수정은 기꺼이 수행 할 수 있지만 원하지 않는 쿼리의 부작용 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d345f3d7dbe7ff707da9acbe8f32c2ce8f14eb3" translate="yes" xml:space="preserve">
          <source>However, in this case, if you change the &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; table option to &lt;code&gt;YES&lt;/code&gt; or &lt;code&gt;DEFAULT&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt;, then it will actually use the proper key. For example:</source>
          <target state="translated">그러나이 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt;&lt;/code&gt; 을 사용하여 &lt;code&gt;&lt;a href=&quot;../create-table/index#encrypted&quot;&gt;ENCRYPTED&lt;/a&gt;&lt;/code&gt; 테이블 옵션을 &lt;code&gt;YES&lt;/code&gt; 또는 &lt;code&gt;DEFAULT&lt;/code&gt; 로 변경 하면 실제로 올바른 키가 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="29e66465571be5d8cb6a7ede29c4d664d6bae5ee" translate="yes" xml:space="preserve">
          <source>However, indexing just make the partitioned table use &amp;ldquo;remote indexing&amp;rdquo; the way FEDERATED tables do. This means that when sending the query to retrieve the table data, a where clause will be added to the query. For instance, let&amp;rsquo;s suppose you ask:</source>
          <target state="translated">그러나 인덱싱은 분할 된 테이블이 FEDERATED 테이블과 같은 방식으로 &quot;원격 인덱싱&quot;을 사용하게합니다. 이는 테이블 데이터를 검색하기 위해 쿼리를 보낼 때 where 절이 쿼리에 추가됨을 의미합니다. 예를 들어, 다음과 같이 요청한다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="d618e446cec094371b1b9f0ccf3eb9da6c761026" translate="yes" xml:space="preserve">
          <source>However, it can also be mixed with connect standard options. For instance:</source>
          <target state="translated">그러나 표준 연결 옵션과 혼합 할 수도 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="2cc98d683f94378f22921a53b8413ae1a9b29336" translate="yes" xml:space="preserve">
          <source>However, it does not allow for the WHERE clause that you probably have.</source>
          <target state="translated">그러나 WHERE 절을 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="ef24b0fc85fa4718b2d34caff401b85dfab1aad4" translate="yes" xml:space="preserve">
          <source>However, it is not possible to limit the time taken by some WMI providers to answer, in particular the CIM_DATAFILE class. Indeed the Microsoft documentation says about it:</source>
          <target state="translated">그러나 일부 WMI 공급자가 응답하는 데 걸리는 시간, 특히 CIM_DATAFILE 클래스를 제한하는 것은 불가능합니다. 실제로 Microsoft 설명서는 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="df25081d8430d891fa754ac7168b73e04a0e4ae1" translate="yes" xml:space="preserve">
          <source>However, it is often not advisable to write in clear a password that can be seen by all user able to see the table declaration by show create table, in particular, if the table is used when the current user is root. To avoid this, a specific user should be created on the local host that will be used by proxy tables to retrieve local tables. This user can have minimum grant options, for instance SELECT on desired directories, and needs no password. Supposing &amp;lsquo;proxy&amp;rsquo; is such a user, the option list to add will be:</source>
          <target state="translated">그러나, 특히 현재 사용자가 root 일 때 테이블이 사용되는 경우 show create table을 통해 테이블 ​​선언을 볼 수있는 모든 사용자가 볼 수있는 암호를 명확하게 작성하는 것은 바람직하지 않습니다. 이를 피하려면 프록시 테이블이 로컬 테이블을 검색하는 데 사용할 로컬 호스트에서 특정 사용자를 작성해야합니다. 이 사용자는 최소 권한 부여 옵션 (예 : 원하는 디렉토리의 SELECT)을 가질 수 있으며 비밀번호가 필요하지 않습니다. '프록시'가 그러한 사용자라고 가정하면 추가 할 옵션 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a9a4eee269d6626285fbf75ee5933aa470d2a73" translate="yes" xml:space="preserve">
          <source>However, it is possible to specify how nulls are handled and represented. This is done by setting the string session variable &lt;a href=&quot;../connect-system-variables/index#connect_json_null&quot;&gt;connect_json_null&lt;/a&gt;. The default value of connect_json_null is &amp;ldquo;&amp;lt;null&amp;gt;&amp;rdquo;; it can be changed, for instance, by:</source>
          <target state="translated">그러나 널 처리 및 표시 방법을 지정할 수 있습니다. 문자열 세션 변수 &lt;a href=&quot;../connect-system-variables/index#connect_json_null&quot;&gt;connect_json_null&lt;/a&gt; 을 설정하면 됩니다. connect_json_null의 기본값은&amp;ldquo;&amp;lt;null&amp;gt;&amp;rdquo;입니다. 예를 들어 다음과 같이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdc54b33d751fb5e4bdaa0d6b79b7874e49f22f0" translate="yes" xml:space="preserve">
          <source>However, it should be kept in mind that if replication filters cause inconsistencies that lead to replication errors, then nodes may abort.</source>
          <target state="translated">그러나 복제 필터로 인해 불일치가 발생하여 복제 오류가 발생하면 노드가 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b154f4be54eb225830ec3563ca7e33328ab4bc1" translate="yes" xml:space="preserve">
          <source>However, just using the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-unix-socket/index&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; authentication plugin may be fine for many users, and it is very secure. You may want to try going without password authentication to see how well it works for you. Remember, the best way to keep your password safe is not to have one!</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-unix-socket/index&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; 인증 플러그인 만 사용하면 많은 사용자에게 적합 할 수 있으며 매우 안전합니다. 암호 인증없이 어떻게 작동하는지 확인할 수 있습니다. 비밀번호를 안전하게 유지하는 가장 좋은 방법은 비밀번호를 사용하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="74d92b9b2b931a2ee86064067ecb07f63b2f2c19" translate="yes" xml:space="preserve">
          <source>However, keep in mind that most users are not going to be starting &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; manually. Instead, most users will use a &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;service manager&lt;/a&gt; to start &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt;. See the following sections on how to bootstrap a node with the most common service managers.</source>
          <target state="translated">그러나 대부분의 사용자는 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 를 수동으로 시작하지 않을 것 입니다. 대신 대부분의 사용자는 &lt;a href=&quot;../starting-and-stopping-mariadb-starting-and-stopping-mariadb/index&quot;&gt;서비스 관리자&lt;/a&gt; 를 사용하여 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 를 시작 합니다. 가장 일반적인 서비스 관리자로 노드를 부트 스트랩하는 방법에 대해서는 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1ff3e3b14200e1e62116eff95fcf1ce9e8f8450d" translate="yes" xml:space="preserve">
          <source>However, keep in mind that there are certain scenarios where you may not be able to rebuild the table with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;. See &lt;a href=&quot;../innodb-online-ddl-operations-with-algorithminplace/index#limitations&quot;&gt;InnoDB Online DDL Operations with ALGORITHM=INPLACE: Limitations&lt;/a&gt; for more information on those cases. If you hit one of those scenarios, but you still want to rebuild the table, then you would have to do so with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;COPY&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정 한 상태 에서 테이블을 다시 빌드하지 못할 수있는 특정 시나리오가 있음을 명심하십시오 . 이러한 경우에 대한 자세한 내용은 &lt;a href=&quot;../innodb-online-ddl-operations-with-algorithminplace/index#limitations&quot;&gt;ALGORITHM = INPLACE : 제한&lt;/a&gt; 을 사용한 InnoDB 온라인 DDL 작업을 참조하십시오 . 이러한 시나리오 중 하나에 해당하지만 여전히 테이블을 다시 빌드하려면 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;COPY&lt;/code&gt; 로 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="8690dfa24c171a62aaec0e5949e1f9ece3534685" translate="yes" xml:space="preserve">
          <source>However, more can be done. In addition to accessing a remote table, CONNECT offers the possibility to specify what the remote server must do. This is done by specifying it as a view in the srcdef option. For example:</source>
          <target state="translated">그러나 더 많은 것을 할 수 있습니다. CONNECT는 리모트 테이블에 액세스하는 것 외에도 리모트 서버가 수행 할 작업을 지정할 수있는 가능성을 제공합니다. 이것은 srcdef 옵션에서보기로 지정하여 수행됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7880bbe98fcf8af22a8734df279e29647ed3b74" translate="yes" xml:space="preserve">
          <source>However, more details about the error can be found by executing &lt;code&gt;&lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그러나 오류에 대한 자세한 내용은 &lt;code&gt;&lt;a href=&quot;../show-warnings/index&quot;&gt;SHOW WARNINGS&lt;/a&gt;&lt;/code&gt; 를 실행하여 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c616f5c02a6416ebc66a38e899e9c58dbd962972" translate="yes" xml:space="preserve">
          <source>However, note that if a &lt;code&gt;BEFORE INSERT&lt;/code&gt; or &lt;code&gt;BEFORE UPDATE&lt;/code&gt; trigger is defined on a table, MariaDB doesn't know in advance if the columns used in the partitioning expression will be changed. For this reason, it is forced to lock all partitions.</source>
          <target state="translated">그러나 &lt;code&gt;BEFORE INSERT&lt;/code&gt; 또는 &lt;code&gt;BEFORE UPDATE&lt;/code&gt; 트리거가 테이블에 정의되어 있으면 MariaDB는 분할 식에 사용 된 열이 변경되는지 미리 알지 못합니다. 이러한 이유로 모든 파티션을 강제로 잠급니다.</target>
        </trans-unit>
        <trans-unit id="1f3284da9ea39714ea69e53d767f7821e00fee61" translate="yes" xml:space="preserve">
          <source>However, note that this is not a hard limit. When the server needs to open a table, it evicts the least recently used closed table from the cache, and adds the new table. If all tables are used, the server adds the new table and does not evict any table. As soon as a table is not used anymore, it will be evicted from the list even if no table needs to be open, until the number of open tables will be equal to &lt;em&gt;table_open_cache&lt;/em&gt;</source>
          <target state="translated">그러나 이것은 하드 제한이 아닙니다. 서버가 테이블을 열어야 할 때 가장 최근에 사용한 닫힌 테이블을 캐시에서 제거하고 새 테이블을 추가합니다. 모든 테이블이 사용되면 서버는 새 테이블을 추가하고 테이블을 제거하지 않습니다. 더 이상 테이블을 사용하지 않으면 테이블을 열 필요가없는 경우에도 열린 테이블 수가 &lt;em&gt;table_open_cache와&lt;/em&gt; 같아 질 때까지 테이블에서 제거됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1976bd7876fbf618877256d0ae87971aa6d0a89b" translate="yes" xml:space="preserve">
          <source>However, note the following pitfall: trying to get the names of all mothers having more than 2 children cannot be done by:</source>
          <target state="translated">그러나 다음과 같은 함정에 유의하십시오. 두 명 이상의 자녀를 둔 모든 어머니의 이름을 얻는 것은 다음과 같은 방법으로 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0c08e38547f67d995a390e7325d6d36cbf3f3230" translate="yes" xml:space="preserve">
          <source>However, occasionally, a MariaDB Server or Mariabackup release will include bug fixes that will break compatibility with previous releases. For example, the fix for &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-13564&quot;&gt;MDEV-13564&lt;/a&gt; changed the &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;InnoDB redo log&lt;/a&gt; format in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10219-release-notes/&quot;&gt;MariaDB 10.2.19&lt;/a&gt; which broke compatibility with previous releases. To be safest, a MariaDB Server release should generally be backed up with the Mariabackup release that has the same version number.</source>
          <target state="translated">그러나 때때로 MariaDB 서버 또는 Mariabackup 릴리스에는 이전 릴리스와의 호환성을 손상시키는 버그 수정이 포함됩니다. 예를 들어 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-13564&quot;&gt;MDEV-13564&lt;/a&gt; 의 수정 사항 은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10219-release-notes/&quot;&gt;MariaDB 10.2.19&lt;/a&gt; 의 &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;InnoDB 리두 로그&lt;/a&gt; 형식을 변경하여 이전 릴리스와의 호환성을 손상 시켰 습니다. 안전을 위해 MariaDB 서버 릴리스는 일반적으로 버전 번호가 동일한 Mariabackup 릴리스로 백업해야합니다.</target>
        </trans-unit>
        <trans-unit id="e0412ad7e500855d630bcc6b955f0faed2ae67dd" translate="yes" xml:space="preserve">
          <source>However, on Linux these tests can fail to locate the JVM library. Before executing them, you should export the JAVA_HOME environment variable set to the prefix of the java installation or export the LD_LIBRARY_PATH containing the path to the JVM lib.</source>
          <target state="translated">그러나 Linux에서 이러한 테스트는 JVM 라이브러리를 찾지 못할 수 있습니다. JAVA_HOME 환경 변수 세트를 Java 설치의 접 두부로 내보내거나 경로가 포함 된 LD_LIBRARY_PATH를 JVM lib로 내 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="abcd35713ff4ce8eb2637cb26d619dfa55147d10" translate="yes" xml:space="preserve">
          <source>However, on many distributions, the standard MariaDB builds do not support all InnoDB page compression algorithms by default.</source>
          <target state="translated">그러나 많은 배포에서 표준 MariaDB 빌드는 기본적으로 모든 InnoDB 페이지 압축 알고리즘을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="907cd61cc7a7290378b43b15b0df8f0fd84f8404" translate="yes" xml:space="preserve">
          <source>However, one limitation of the TBL type regarding MERGE is that TBL tables are currently read-only; INSERT is not supported by TBL. Also, keep using MERGE to access a list of identical MyISAM tables because it will be faster, not passing by the MySQL API.</source>
          <target state="translated">그러나 MERGE에 관한 TBL 유형의 한 가지 제한 사항은 TBL 테이블이 현재 읽기 전용이라는 것입니다. INSERT는 TBL에서 지원되지 않습니다. 또한 MERGE를 사용하여 동일한 MyISAM 테이블 목록에 계속 액세스하십시오. 왜냐하면 MySQL API를 통과하지 않고 더 빠르기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6f71318de5cd8d9e90acb9185e647f15bc7a771b" translate="yes" xml:space="preserve">
          <source>However, running MariaDB from the command line in a user session like this covers only the simplest testing scenarios.</source>
          <target state="translated">그러나 이와 같은 사용자 세션의 명령 줄에서 MariaDB를 실행하면 가장 간단한 테스트 시나리오 만 다루게됩니다.</target>
        </trans-unit>
        <trans-unit id="c68ec83f037bd45dd67d6982adbe6a6fda59b392" translate="yes" xml:space="preserve">
          <source>However, seasoned MariaDB DBAs who are used to the old ways do need to makes some changes. See the examples below for common tasks.</source>
          <target state="translated">그러나 기존 방식에 익숙한 노련한 MariaDB DBA는 약간의 변경이 필요합니다. 일반적인 작업은 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cb7098e4a2883e0786806f7c8d0a88c12d325a9a" translate="yes" xml:space="preserve">
          <source>However, since &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;, a better storage engine is able to read and write such files: &lt;a href=&quot;../connect/index&quot;&gt;CONNECT&lt;/a&gt;.</source>
          <target state="translated">그러나 이후 &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; , 더 나은 스토리지 엔진은 파일을 읽고 쓸 수 있습니다 : &lt;a href=&quot;../connect/index&quot;&gt;CONNECT&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c186ca4de6e211878acbebb9766d52f83f7d30d" translate="yes" xml:space="preserve">
          <source>However, since this was written, a new source of data was developed as the &amp;ldquo;cloud&amp;rdquo;. Data are existing worldwide and, in particular, can be obtained in JSON or XML format in answer to REST queries. From &lt;a href=&quot;../connect/index&quot;&gt;Connect 1.06.0010&lt;/a&gt;, it is possible to create JSON, XML or CSV tables based on data retrieved from such REST queries.</source>
          <target state="translated">그러나 이것이 작성된 이후로 새로운 데이터 소스가 &quot;클라우드&quot;로 개발되었습니다. 데이터는 전 세계에 존재하며 특히 REST 쿼리에 대한 응답으로 JSON 또는 XML 형식으로 얻을 수 있습니다. 에서 &lt;a href=&quot;../connect/index&quot;&gt;연결 1.06.0010&lt;/a&gt; , 이러한 REST 쿼리에서 검색 한 데이터를 기반으로 JSON, XML 또는 CSV 테이블을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48b6dae3096bf9d3d746e51adf3e313c08362c68" translate="yes" xml:space="preserve">
          <source>However, some &lt;a href=&quot;../built-in-functions/index&quot;&gt;built-in functions&lt;/a&gt; can't be supported for technical reasons. For example, If you try to use an unsupported function in an expression, an error is generated similar to the following:</source>
          <target state="translated">그러나 일부 &lt;a href=&quot;../built-in-functions/index&quot;&gt;내장 기능&lt;/a&gt; 은 기술적 인 이유로 지원되지 않습니다. 예를 들어, 표현식에서 지원되지 않는 함수를 사용하려고하면 다음과 유사한 오류가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b8584945ce952ae12fcb2d2929868ea80c7d07de" translate="yes" xml:space="preserve">
          <source>However, some queries require random access to an ODBC table; for instance when it is joined to another table or used in an order by queries applied to a long column or large tables.</source>
          <target state="translated">그러나 일부 쿼리는 ODBC 테이블에 무작위로 액세스해야합니다. 예를 들어 다른 테이블에 조인되거나 긴 열 또는 큰 테이블에 적용된 쿼리에 의해 순서대로 사용되는 경우를 예로들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="552fe1c86d1796bbd4f75a7cb7db28a952ed2ce6" translate="yes" xml:space="preserve">
          <source>However, the &amp;ldquo;Jbin&amp;rdquo; counterpart of these functions does not serialize the binary document and thus does not modify the json file. For example let us compare these two queries:</source>
          <target state="translated">그러나 이러한 함수의 &quot;Jbin&quot;대응 기능은 이진 문서를 직렬화하지 않으므로 json 파일을 수정하지 않습니다. 예를 들어이 두 쿼리를 비교해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="2569936100353a8898d0885ea299e11a778f73c8" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_old_password/index&quot;&gt;mysql_old_password&lt;/a&gt;&lt;/code&gt; authentication plugin is not considered secure, so it is recommended to avoid using this authentication plugin. To help prevent undesired use of the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_old_password/index&quot;&gt;mysql_old_password&lt;/a&gt;&lt;/code&gt; authentication plugin, the server supports the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#secure_auth&quot;&gt;secure_auth&lt;/a&gt;&lt;/code&gt; system variable that can be used to configured the server to refuse connections that try to use the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_old_password/index&quot;&gt;mysql_old_password&lt;/a&gt;&lt;/code&gt; authentication plugin:</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_old_password/index&quot;&gt;mysql_old_password&lt;/a&gt;&lt;/code&gt; 인증 플러그인은 안전한 것으로 간주되지 않으므로이 인증 플러그인을 사용하지 않는 것이 좋습니다. &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_old_password/index&quot;&gt;mysql_old_password&lt;/a&gt;&lt;/code&gt; 인증 플러그인 의 원치 않는 사용을 방지하기 위해 서버는 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#secure_auth&quot;&gt;secure_auth&lt;/a&gt;&lt;/code&gt; 시스템 변수를 지원 하여 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_old_password/index&quot;&gt;mysql_old_password&lt;/a&gt;&lt;/code&gt; 인증 플러그인 을 사용하려는 연결을 거부하도록 서버를 구성하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="935b23fdd4501728c0e56f182b553fd8f3be95b4" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#general_log_file&quot;&gt;general_log_file&lt;/a&gt;&lt;/code&gt; system variable can also be an absolute path. For example:</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#general_log_file&quot;&gt;general_log_file&lt;/a&gt;&lt;/code&gt; 시스템 변수는 절대 경로 일 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a70b51187e11f1b6860903bb7ef52e59b1564b6" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_error&quot;&gt;log_error&lt;/a&gt;&lt;/code&gt; system variable can also be an absolute path. For example:</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_error&quot;&gt;log_error&lt;/a&gt;&lt;/code&gt; 시스템 변수는 절대 경로 일 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c0be0e6c7ea1420e479300c4ce3fa934dfde58b" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#slow_query_log_file&quot;&gt;slow_query_log_file&lt;/a&gt;&lt;/code&gt; system variable can also be an absolute path. For example:</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#slow_query_log_file&quot;&gt;slow_query_log_file&lt;/a&gt;&lt;/code&gt; 시스템 변수는 절대 경로 일 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="662c7c68cb64e5c19cb3fb8d6cccd5dc01f074d6" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;mysql_native_password&lt;/code&gt; client authentication plugin is generally statically linked into client libraries like &lt;code&gt;libmysqlclient&lt;/code&gt; or &lt;a href=&quot;../mariadb-connector-c/index&quot;&gt;MariaDB Connector/C&lt;/a&gt;, so this is not usually necessary.</source>
          <target state="translated">그러나 &lt;code&gt;mysql_native_password&lt;/code&gt; 클라이언트 인증 플러그인은 일반적으로 &lt;code&gt;libmysqlclient&lt;/code&gt; 또는 &lt;a href=&quot;../mariadb-connector-c/index&quot;&gt;MariaDB Connector / C&lt;/a&gt; 와 같은 클라이언트 라이브러리에 정적으로 링크 되므로 일반적으로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c8de7c52c2a65af51ce4b6c58648c324603933c" translate="yes" xml:space="preserve">
          <source>However, the &lt;code&gt;mysql_old_password&lt;/code&gt; client authentication plugin is generally statically linked into client libraries like &lt;code&gt;libmysqlclient&lt;/code&gt; or &lt;a href=&quot;../mariadb-connector-c/index&quot;&gt;MariaDB Connector/C&lt;/a&gt;, so this is not usually necessary.</source>
          <target state="translated">그러나 &lt;code&gt;mysql_old_password&lt;/code&gt; 클라이언트 인증 플러그인은 일반적으로 &lt;code&gt;libmysqlclient&lt;/code&gt; 또는 &lt;a href=&quot;../mariadb-connector-c/index&quot;&gt;MariaDB Connector / C&lt;/a&gt; 와 같은 클라이언트 라이브러리에 정적으로 링크 되므로 일반적으로 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2edcc96c4340c794267480574d16681cfd3685c3" translate="yes" xml:space="preserve">
          <source>However, the PERFORMANCE_SCHEMA is not a regular storage engine for storing data, it's a mechanism for implementing the &lt;a href=&quot;../performance-schema/index&quot;&gt;Performance Schema&lt;/a&gt; feature.</source>
          <target state="translated">그러나 PERFORMANCE_SCHEMA는 데이터 저장을위한 일반 스토리지 엔진이 아니며 &lt;a href=&quot;../performance-schema/index&quot;&gt;성능 스키마&lt;/a&gt; 기능 을 구현하기위한 메커니즘입니다 .</target>
        </trans-unit>
        <trans-unit id="9a372057f844419123ab45e0204a4b9c2d31aa15" translate="yes" xml:space="preserve">
          <source>However, the column type need not necessarily match the field format within the table file. In particular, this occurs for field formats that correspond to numeric types that are not handled by CONNECT&lt;sup id=&quot;_ref-1&quot;&gt;[&lt;a href=&quot;#_note-1&quot;&gt;2&lt;/a&gt;]&lt;/sup&gt;. Indeed, BIN table files may internally contain float numbers or binary numbers of any byte length in big-endian or little-endian representation&lt;sup id=&quot;_ref-2&quot;&gt;[&lt;a href=&quot;#_note-2&quot;&gt;3&lt;/a&gt;]&lt;/sup&gt;. Also, as in &lt;a href=&quot;../connect-dos-and-fix-table-types/index&quot;&gt;DOS or FIX types&lt;/a&gt; tables, you may want to handle some character fields as numeric or vice versa.</source>
          <target state="translated">그러나 열 유형이 반드시 테이블 파일 내의 필드 형식과 일치 할 필요는 없습니다. 특히, 이것은 CONNECT &lt;sup id=&quot;_ref-1&quot;&gt;[ &lt;a href=&quot;#_note-1&quot;&gt;2&lt;/a&gt; ]가&lt;/sup&gt; 처리하지 않는 숫자 유형에 해당하는 필드 형식에 대해 발생합니다 . 실제로 BIN 테이블 파일에는 내부적으로 빅 엔디안 또는 리틀 엔디안 표현으로 임의의 바이트 길이의 부동 숫자 또는 이진 숫자가 포함될 수 있습니다 &lt;sup id=&quot;_ref-2&quot;&gt;[ &lt;a href=&quot;#_note-2&quot;&gt;3&lt;/a&gt; ]&lt;/sup&gt; . 또한 &lt;a href=&quot;../connect-dos-and-fix-table-types/index&quot;&gt;DOS 또는 FIX 유형&lt;/a&gt; 테이블에서와 같이 일부 문자 필드를 숫자로 처리하거나 그 반대로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="6b0b4a4b7b0dfb79bd1ee8322fa611fcfc7f28d8" translate="yes" xml:space="preserve">
          <source>However, the date causes dump files taken at different times to appear to be different, even if the data are otherwise identical. &lt;code&gt;--dump-date&lt;/code&gt; and &lt;code&gt;--skip-dump-date&lt;/code&gt; control whether the date is added to the comment. The default is &lt;code&gt;--dump-date&lt;/code&gt; (include the date in the comment). &lt;code&gt;--skip-dump-date&lt;/code&gt; suppresses date printing.</source>
          <target state="translated">그러나 날짜는 데이터가 다른 경우에도 다른 시간에 찍은 덤프 파일이 다른 것처럼 보이게합니다. &lt;code&gt;--dump-date&lt;/code&gt; 및 &lt;code&gt;--skip-dump-date&lt;/code&gt; 는 날짜가 주석에 추가되는지 여부를 제어합니다. 기본값은 &lt;code&gt;--dump-date&lt;/code&gt; 입니다 (주석에 날짜 포함). &lt;code&gt;--skip-dump-date&lt;/code&gt; 는 날짜 인쇄를 억제합니다.</target>
        </trans-unit>
        <trans-unit id="a671e7ee6c13beb81c9fed66fe60bf9693fa5260" translate="yes" xml:space="preserve">
          <source>However, the following statement would fail:</source>
          <target state="translated">그러나 다음 내용은 실패합니다.</target>
        </trans-unit>
        <trans-unit id="92008234dcfcfe2c04a0bcd9e5cc1d93f66bc7d1" translate="yes" xml:space="preserve">
          <source>However, the optimizer can take the condition &lt;code&gt;customer_id=1&lt;/code&gt; and push it down into the OCT_TOTALS view.</source>
          <target state="translated">그러나 옵티마이 저는 &lt;code&gt;customer_id=1&lt;/code&gt; 조건 을 사용하여 OCT_TOTALS보기로 푸시 다운 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a0d08e2cecd6abb155523bee179a998b286a57d" translate="yes" xml:space="preserve">
          <source>However, the result set could actually contain more rows than what is found in tableA if there are duplicates of the column B.id in tableB. If A contains a row [1, &quot;val1&quot;] and B the rows [1, &quot;other1a&quot;],[1, &quot;other1b&quot;] then two rows will match in the join condition. The only way to know what the result will look like is to actually touch both tables during execution.</source>
          <target state="translated">그러나 tableB에 B.id 열이 중복 된 경우 결과 집합에 실제로 tableA에있는 것보다 많은 행이 포함될 수 있습니다. A에 행 [1, &quot;val1&quot;]이 있고 B에 행 [1, &quot;other1a&quot;], [1, &quot;other1b&quot;]가 있으면 두 개의 행이 결합 조건에서 일치합니다. 결과가 어떻게 보이는지 알 수있는 유일한 방법은 실제로 실행하는 동안 두 테이블을 모두 터치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="384c7eab24e4e99f1894e0f6ab6d21ffab76f3de" translate="yes" xml:space="preserve">
          <source>However, the server-side and client-side authentication plugins mentioned in these initial packets may not be the correct ones for this specific user account. The server only knows what authentication plugin to use for this specific user account after reading the user name from the client reply packet and finding the appropriate row for the user account in either the &lt;code&gt;&lt;a href=&quot;../mysqluser-table/index&quot;&gt;mysql.user&lt;/a&gt;&lt;/code&gt; table or the &lt;code&gt;&lt;a href=&quot;../mysqlglobal_priv-table/index&quot;&gt;mysql.global_priv&lt;/a&gt;&lt;/code&gt; table, depending on the MariaDB version.</source>
          <target state="translated">그러나 이러한 초기 패킷에 언급 된 서버 측 및 클라이언트 측 인증 플러그인은이 특정 사용자 계정에 맞는 플러그인이 아닐 수 있습니다. 서버는 클라이언트 응답 패킷에서 사용자 이름을 읽고 &lt;code&gt;&lt;a href=&quot;../mysqluser-table/index&quot;&gt;mysql.user&lt;/a&gt;&lt;/code&gt; 테이블 또는 &lt;code&gt;&lt;a href=&quot;../mysqlglobal_priv-table/index&quot;&gt;mysql.global_priv&lt;/a&gt;&lt;/code&gt; 테이블 에서 사용자 계정에 대한 적절한 행을 찾은 후이 특정 사용자 계정에 사용할 인증 플러그인 만 알고 있습니다 . MariaDB 버전.</target>
        </trans-unit>
        <trans-unit id="1e30e1e1e4a9d1f2fd428aa2ba2f7e8503cdc107" translate="yes" xml:space="preserve">
          <source>However, the server-wide InnoDB page compression algorithm can be configured by setting the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_compression_algorithm&quot;&gt;innodb_compression_algorithm&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">그러나 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_compression_algorithm&quot;&gt;innodb_compression_algorithm&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정하여 서버 전체 InnoDB 페이지 압축 알고리즘을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9c9668536e3bbc77deea730f1f0ee1c97c040e1" translate="yes" xml:space="preserve">
          <source>However, the values TRUE and FALSE are merely aliases for 1 and 0, respectively, as shown here:</source>
          <target state="translated">그러나 TRUE 및 FALSE 값은 다음과 같이 각각 1과 0에 대한 별명 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="bfca2e2ed8b87386b48aa9a69bae03eb3c5409b3" translate="yes" xml:space="preserve">
          <source>However, there are cases where you can use MYSQL CONNECT tables yourself, for instance:</source>
          <target state="translated">그러나 MYSQL CONNECT 테이블을 직접 사용할 수있는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="72adfffa5826576699c1802275f0520ba6e943c5" translate="yes" xml:space="preserve">
          <source>However, there are cases where you have to use row-based replication. It could be because the master runs non-deterministic statements, or the master could be a node in a Galera cluster. In that case, you would want row-based events to invoke triggers on the slave. This is what the &lt;code&gt;slave_run_triggers_for_rbr&lt;/code&gt; option is for. Setting the option to &lt;code&gt;YES&lt;/code&gt; will cause the SQL slave thread to invoke triggers for row based events; setting it to &lt;code&gt;LOGGING&lt;/code&gt; will also cause the changes made by the triggers to be written into the binary log.</source>
          <target state="translated">그러나 행 기반 복제를 사용해야하는 경우가 있습니다. 마스터가 비 결정적 명령문을 실행하거나 마스터가 Galera 클러스터의 노드 일 수 있기 때문일 수 있습니다. 이 경우 행 기반 이벤트가 슬레이브에서 트리거를 호출하기를 원할 것입니다. 이것이 &lt;code&gt;slave_run_triggers_for_rbr&lt;/code&gt; 옵션의 목적입니다. 옵션을 &lt;code&gt;YES&lt;/code&gt; 로 설정하면 SQL 슬레이브 스레드가 행 기반 이벤트에 대한 트리거를 호출합니다. &lt;code&gt;LOGGING&lt;/code&gt; 으로 설정 하면 트리거에 의해 작성된 변경 사항이 2 진 로그에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="aedbd6cf6022e152042bd8d7438bf0a96e45759e" translate="yes" xml:space="preserve">
          <source>However, there are some issues when the added or modified values are objects or arrays.</source>
          <target state="translated">그러나 추가되거나 수정 된 값이 객체 또는 배열 인 경우 몇 가지 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="316610a065ca59a517d6397abd2ab76737778d4d" translate="yes" xml:space="preserve">
          <source>However, there are some limitations, such as:</source>
          <target state="translated">그러나 다음과 같은 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f064a9b88d19790d22cffa35d63968eac268d6fe" translate="yes" xml:space="preserve">
          <source>However, there is a solution. It is to add to the table a special column that will be used by the partition function. For instance, the new table creation can be done by:</source>
          <target state="translated">그러나 해결책이 있습니다. 파티션 함수가 사용할 특수 컬럼을 테이블에 추가합니다. 예를 들어, 새 테이블 작성은 다음을 통해 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63b4e277fbc0e8aa67fef2e840d79633c7b03891" translate="yes" xml:space="preserve">
          <source>However, there is an exception. If you are dropping a primary key, and adding a new one at the same time, then that operation can be performed with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INPLACE&lt;/code&gt;. This operation supports the non-locking strategy. This strategy can be explicitly chosen by setting the &lt;code&gt;&lt;a href=&quot;../alter-table/index#lock&quot;&gt;LOCK&lt;/a&gt;&lt;/code&gt; clause to &lt;code&gt;NONE&lt;/code&gt;. When this strategy is used, all concurrent DML is permitted.</source>
          <target state="translated">그러나 예외가 있습니다. 기본 키를 삭제하고 동시에 새 키를 추가하는 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;INPLACE&lt;/code&gt; 로 설정하여 해당 작업을 수행 할 수 있습니다 . 이 작업은 비 잠금 전략을 지원합니다. 이 전략은 &lt;code&gt;&lt;a href=&quot;../alter-table/index#lock&quot;&gt;LOCK&lt;/a&gt;&lt;/code&gt; 절을 &lt;code&gt;NONE&lt;/code&gt; 으로 설정하여 명시 적으로 선택할 수 있습니다 . 이 전략을 사용하면 모든 동시 DML이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="264fa9cb98ddb3b3abda93d360fa5e8cf3695185" translate="yes" xml:space="preserve">
          <source>However, there is one point that is not covered yet, the syntax used to specify dates in queries. WQL does not recognize dates as number items but translates them to its internal format dates specified as text. Many formats are recognized as described in the Microsoft documentation but only one is useful because common to WQL and MariaDB SQL. Here is an example of a query on a table named &quot;cim&quot; created by:</source>
          <target state="translated">그러나 아직 다루지 않은 점이 있는데, 쿼리에서 날짜를 지정하는 데 사용되는 구문입니다. WQL은 날짜를 숫자 항목으로 인식하지 않지만 텍스트로 지정된 내부 형식 날짜로 변환합니다. 많은 형식이 Microsoft 문서에 설명 된대로 인식되지만 WQL 및 MariaDB SQL에 공통이기 때문에 하나만 유용합니다. 다음은 &quot;cim&quot;이라는 테이블에 대한 쿼리 예입니다.</target>
        </trans-unit>
        <trans-unit id="71c147aa91b580c8fbcbd7fd5809b4b20f33bc71" translate="yes" xml:space="preserve">
          <source>However, there is still an issue on multi-table statements. Let us suppose you have a &lt;em&gt;t1&lt;/em&gt; table on the remote server and want to execute a query such as:</source>
          <target state="translated">그러나 다중 테이블 문에는 여전히 문제가 있습니다. 원격 서버에 &lt;em&gt;t1&lt;/em&gt; 테이블이 있고 다음과 같은 쿼리를 실행 한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="fb24dbe24152b66bc98e1ebef599b5cd9f42236d" translate="yes" xml:space="preserve">
          <source>However, these are by default set to a long wait period. In situations where transactions may be started, but not committed or rolled back, more granular control and a shorter timeout may be desirable so as to avoid locks being held for too long.</source>
          <target state="translated">그러나 이는 기본적으로 긴 대기 시간으로 설정됩니다. 트랜잭션이 시작되었지만 커밋 또는 롤백되지 않는 상황에서는 잠금이 너무 오랫동안 유지되지 않도록보다 세밀한 제어와 짧은 시간 초과가 바람직 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78d87f24f43b424bf2b573c7005caa46af8aba93" translate="yes" xml:space="preserve">
          <source>However, these option files are now very dated for modern servers, so they were removed in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1031-release-notes/&quot;&gt;MariaDB 10.3.1&lt;/a&gt;.</source>
          <target state="translated">그러나 이러한 옵션 파일은 최신 서버에 대해 날짜가 매우 오래되었으므로 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1031-release-notes/&quot;&gt;MariaDB 10.3.1&lt;/a&gt; 에서 제거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="bcdafa1ce36696a1c62bc66770f80170fa2cdf81" translate="yes" xml:space="preserve">
          <source>However, things are generally more complicated. If JSON files do not contain attributes (although object pairs are similar to attributes) they contain a new item, arrays. We have seen that they can be used like XML multiple nodes, here to specify several authors, but they are more general because they can contain objects of different types, even it may not be advisable to do so.</source>
          <target state="translated">그러나 일반적으로 상황이 더 복잡합니다. JSON 파일에 속성이 포함되어 있지 않은 경우 (객체 쌍은 속성과 유사하지만) 새 항목 인 배열이 포함됩니다. 우리는 XML 다중 노드처럼 여러 저자를 지정할 수 있다는 것을 알았지 만 다른 유형의 객체를 포함 할 수 있기 때문에 더 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="d9906998e5f52ed6ee4e716ab4829410f9da690a" translate="yes" xml:space="preserve">
          <source>However, this connector also supports the &lt;code&gt;&lt;a href=&quot;https://mysql-net.github.io/MySqlConnector/connection-options&quot;&gt;ServerSPN&lt;/a&gt;&lt;/code&gt; connection string parameter, which can be used for mutual authentication.</source>
          <target state="translated">그러나이 커넥터는 상호 인증에 사용할 수있는 &lt;code&gt;&lt;a href=&quot;https://mysql-net.github.io/MySqlConnector/connection-options&quot;&gt;ServerSPN&lt;/a&gt;&lt;/code&gt; 연결 문자열 매개 변수 도 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="4dafd7e78c099ad9e1b2916d698f86a4721ebc16" translate="yes" xml:space="preserve">
          <source>However, this is not true for tables that use &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt;. InnoDB tables have to be imported with &lt;code&gt;&lt;a href=&quot;../alter-table/index#import-tablespace&quot;&gt;ALTER TABLE ... IMPORT TABLESPACE&lt;/a&gt;&lt;/code&gt;. See &lt;a href=&quot;../innodb-file-per-table-tablespaces/index#copying-transportable-tablespaces&quot;&gt;Copying Transportable Tablespaces&lt;/a&gt; for more information.</source>
          <target state="translated">그러나 &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; 를 사용하는 테이블에는 해당되지 않습니다 . &lt;code&gt;&lt;a href=&quot;../alter-table/index#import-tablespace&quot;&gt;ALTER TABLE ... IMPORT TABLESPACE&lt;/a&gt;&lt;/code&gt; 사용하여 InnoDB 테이블을 가져와야 합니다. 자세한 정보는 &lt;a href=&quot;../innodb-file-per-table-tablespaces/index#copying-transportable-tablespaces&quot;&gt;전송 가능한 테이블 스페이스 복사&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a48940537c968124bf6b7eb57bf9cef0ccd5a11b" translate="yes" xml:space="preserve">
          <source>However, this one fails:</source>
          <target state="translated">그러나 이것은 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c193f0b6d231c28af5af1dd055574214a9bc6699" translate="yes" xml:space="preserve">
          <source>However, to have the file modified, use the &lt;em&gt;Jbin_File&lt;/em&gt; function or directly give the file name. &lt;em&gt;Jbin_File&lt;/em&gt; returns a structure containing the file name, a pointer to the file parsed tree and eventually a pointer to the subset when a path is given as a second argument:</source>
          <target state="translated">그러나 파일을 수정하려면 &lt;em&gt;Jbin_File&lt;/em&gt; 함수를 사용하거나 파일 이름을 직접 지정하십시오. &lt;em&gt;Jbin_File&lt;/em&gt; 은 파일 이름, 파일 구문 분석 트리에 대한 포인터 및 경로가 두 번째 인수로 제공 될 때 서브 세트에 대한 포인터를 포함하는 구조를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="70081e0231cb61d395d64eaaff53b85970a850a9" translate="yes" xml:space="preserve">
          <source>However, to see the positive effects of group commit, the workload must have sufficient parallelism. A good rule of thumb is that at least three parallel transactions are needed for group commit to be effective. For example, while the first transaction is waiting for its flush operation to complete, the other two transactions will queue up waiting for their turn to flush their changes to disk. When the first transaction is done, a single system call can be used to flush the two queued-up transactions, saving in this case one of the three system calls.</source>
          <target state="translated">그러나 그룹 커밋의 긍정적 인 효과를 보려면 작업 부하에 충분한 병렬 처리가 있어야합니다. 경험적으로 볼 때 그룹 커밋이 효과적이려면 최소한 3 개의 병렬 트랜잭션이 필요합니다. 예를 들어 첫 번째 트랜잭션이 플러시 작업이 완료되기를 기다리는 동안 다른 두 트랜잭션은 차례가 디스크에 대한 변경 사항을 플러시 할 때까지 대기합니다. 첫 번째 트랜잭션이 완료되면 단일 시스템 호출을 사용하여 대기중인 두 트랜잭션을 플러시 할 수 있으며이 경우 세 개의 시스템 호출 중 하나를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="38ef6cd4f0195da7f06820459667c10966d10dfa" translate="yes" xml:space="preserve">
          <source>However, to work on large JSON collations, using the MONGO table type is generally the normal way.</source>
          <target state="translated">그러나 큰 JSON 데이터 정렬에서 작업하려면 일반적으로 MONGO 테이블 유형을 사용하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="487b95167e371ae68869eb67f411c25ec88bf002" translate="yes" xml:space="preserve">
          <source>However, users should be aware that problems are likely due to the MySQL 5.7 undo log format incompatibility bug that was fixed in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1022-release-notes/&quot;&gt;MariaDB 10.2.2&lt;/a&gt; in &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-12289&quot;&gt;MDEV-12289&lt;/a&gt;. Due to this bug, backups prepared with Percona XtraBackup 2.4 may fail to recover some transactions. Only if you ran the server with the setting &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_undo_logs&quot;&gt;innodb_undo_logs&lt;/a&gt;=1 this would not be a problem. Percona XtraBackup 2.4 may also fail to work entirely with &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10219-release-notes/&quot;&gt;MariaDB 10.2.19&lt;/a&gt; and later if &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_safe_truncate&quot;&gt;innodb_safe_truncate=ON&lt;/a&gt; is set due to changes in the redo log format introduced by &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-14717&quot;&gt;MDEV-14717&lt;/a&gt;. In that case, you may see the following error:</source>
          <target state="translated">그러나 사용자는 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-12289&quot;&gt;MDEV-12289의 &lt;/a&gt;&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1022-release-notes/&quot;&gt;MariaDB 10.2.2&lt;/a&gt; 에서 수정 된 MySQL 5.7 실행 취소 로그 형식 비 호환성 버그로 인해 문제가 발생할 수 있음을 알고 있어야합니다 . 이 버그로 인해 Percona XtraBackup 2.4로 준비된 백업이 일부 트랜잭션을 복구하지 못할 수 있습니다. &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_undo_logs&quot;&gt;innodb_undo_logs&lt;/a&gt; = 1 설정으로 서버를 실행 한 경우에만 문제가되지 않습니다. &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-14717&quot;&gt;MDEV-14717에&lt;/a&gt; 의해 도입 된 리두 로그 형식의 변경으로 인해 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_safe_truncate&quot;&gt;innodb_safe_truncate = ON&lt;/a&gt; 이 설정된 경우 Percona XtraBackup 2.4는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10219-release-notes/&quot;&gt;MariaDB 10.2.19 이상에서&lt;/a&gt; 완전히 작동하지 않을 수도 있습니다 . 이 경우 다음 오류가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="529856f7f64bc6cec6018b79aa5609e39c0ea305" translate="yes" xml:space="preserve">
          <source>However, using JSON brings features not existing in dynamic columns:</source>
          <target state="translated">그러나 JSON을 사용하면 동적 열에 존재하지 않는 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="49aadef64c7bb35c267e9ef8a0212f409d7cc549" translate="yes" xml:space="preserve">
          <source>However, using the &lt;code&gt;ON UPDATE CASCADE&lt;/code&gt;, &lt;code&gt;ON UPDATE SET NULL&lt;/code&gt;, or &lt;code&gt;ON DELETE SET NULL&lt;/code&gt; clauses is &lt;strong&gt;not&lt;/strong&gt; supported. If you try to use an unsupported clause, then you will see an error similar to the following:</source>
          <target state="translated">그러나 &lt;code&gt;ON UPDATE CASCADE&lt;/code&gt; , &lt;code&gt;ON UPDATE SET NULL&lt;/code&gt; 또는 &lt;code&gt;ON DELETE SET NULL&lt;/code&gt; 절을 사용하는 &lt;strong&gt;것은&lt;/strong&gt; 지원 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 지원되지 않는 절을 사용하려고하면 다음과 유사한 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6841f83b2298e8ce7f9d2a74122a8638aef4942c" translate="yes" xml:space="preserve">
          <source>However, we can use an INSERT ON DUPLICATE KEY UPDATE instead:</source>
          <target state="translated">그러나 대신 INSERT ON DUPLICATE KEY UPDATE를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bca721c51472b1be374dbb76bcb55c74c0f74c9e" translate="yes" xml:space="preserve">
          <source>However, we&amp;rsquo;ll see that, most of the time, it is better to use Jbin_File or to directly specify the file name in queries. In particular this function should not be used for queries that must modify the json item because, even if the modified json is returned, the file itself would be unchanged.</source>
          <target state="translated">그러나 대부분 Jbin_File을 사용하거나 쿼리에서 파일 이름을 직접 지정하는 것이 좋습니다. 특히이 함수는 수정 된 json이 리턴 되더라도 파일 자체는 변경되지 않으므로 json 항목을 수정해야하는 조회에는 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="180dc2a8245823f7c9d18316d504187615be10af" translate="yes" xml:space="preserve">
          <source>However, what if this table is a huge table? In this case, the correct way to do it is to define the pivot table as this:</source>
          <target state="translated">그러나이 테이블이 거대한 테이블이면 어떻게됩니까? 이 경우 올바른 방법은 피벗 테이블을 다음과 같이 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2069e405dd1763454c305ead2101b85df6faa9f2" translate="yes" xml:space="preserve">
          <source>However, when installing an older version of a package, if &lt;code&gt;apt-get&lt;/code&gt; has to install dependencies, then it will automatically choose to install the latest versions of those packages. To ensure that all MariaDB packages are on the same version in this scenario, it is necessary to specify them all. Therefore, to install &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10314-release-notes/&quot;&gt;MariaDB 10.3.14&lt;/a&gt; from this &lt;code&gt;apt&lt;/code&gt; repository, we would do the following:</source>
          <target state="translated">그러나 이전 버전의 패키지를 설치할 때 &lt;code&gt;apt-get&lt;/code&gt; 이 종속성을 설치 해야하는 경우 해당 패키지의 최신 버전을 자동으로 설치하도록 선택합니다. 이 시나리오에서 모든 MariaDB 패키지가 동일한 버전에 있도록하려면 모두 지정해야합니다. 따라서이 &lt;code&gt;apt&lt;/code&gt; 저장소 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10314-release-notes/&quot;&gt;MariaDB 10.3.14&lt;/a&gt; 를 설치하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b11e3fb65f4e8390a651a5398b3c79e39aa4c736" translate="yes" xml:space="preserve">
          <source>However, when installing an older version of a package, if &lt;code&gt;yum&lt;/code&gt; has to install dependencies, then it will automatically choose to install the latest versions of those packages. To ensure that all MariaDB packages are on the same version in this scenario, it is necessary to specify them all.</source>
          <target state="translated">그러나 이전 버전의 패키지 를 설치할 때 &lt;code&gt;yum&lt;/code&gt; 이 종속성을 설치 해야하는 경우 해당 패키지의 최신 버전을 자동으로 설치하도록 선택합니다. 이 시나리오에서 모든 MariaDB 패키지가 동일한 버전에 있도록하려면 모두 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="cbc08382178808f5ce1c43279b3833c167578afe" translate="yes" xml:space="preserve">
          <source>However, when installing an older version of a package, if &lt;code&gt;zypper&lt;/code&gt; has to install dependencies, then it will automatically choose to install the latest versions of those packages. To ensure that all MariaDB packages are on the same version in this scenario, it is necessary to specify them all.</source>
          <target state="translated">그러나 이전 버전의 패키지 를 설치할 때 &lt;code&gt;zypper&lt;/code&gt; 가 종속성을 설치 해야하는 경우 해당 패키지의 최신 버전을 자동으로 설치하도록 선택합니다. 이 시나리오에서 모든 MariaDB 패키지가 동일한 버전에 있도록하려면 모두 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0978e7225a86d25af85deb09ffb6da53cf83c1c3" translate="yes" xml:space="preserve">
          <source>However, when running tests with the &lt;code&gt;--force&lt;/code&gt; option, the &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/logrotate&quot;&gt;logrotate&lt;/a&gt;&lt;/code&gt; utility does not take these options into consideration.</source>
          <target state="translated">그러나 &lt;code&gt;--force&lt;/code&gt; 옵션으로 테스트를 실행할 때 &lt;code&gt;&lt;a href=&quot;https://linux.die.net/man/8/logrotate&quot;&gt;logrotate&lt;/a&gt;&lt;/code&gt; 유틸리티는 이러한 옵션을 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="904af2638192caa665188c22bffa3797b690d5a7" translate="yes" xml:space="preserve">
          <source>However, you can deal with tables even closer to the HTML model. For example the &lt;em&gt;coffee.htm&lt;/em&gt; file:</source>
          <target state="translated">그러나 HTML 모델에 더 가까운 테이블을 처리 할 수 ​​있습니다. 예를 들어 &lt;em&gt;coffee.htm&lt;/em&gt; 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3875fb27f2d3b75fe19c4cbe81b79c2d8624efb" translate="yes" xml:space="preserve">
          <source>However, you can meet tables that respect the XML syntax but have some of the features of HTML tables. For instance:</source>
          <target state="translated">그러나 XML 구문을 존중하지만 HTML 테이블의 일부 기능이있는 테이블을 만날 수 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="76aa614e0d26fe37fd2682b276c2925c75ee1c95" translate="yes" xml:space="preserve">
          <source>However, you can mimic this behavior with a BEFORE INSERT trigger and a second table to store the sequence position:</source>
          <target state="translated">그러나 BEFORE INSERT 트리거와 시퀀스 위치를 저장하는 두 번째 테이블을 사용하여이 동작을 모방 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59cb7a88866627ad765e58a58a04be9509524ad7" translate="yes" xml:space="preserve">
          <source>Huff tree</source>
          <target state="translated">허프 트리</target>
        </trans-unit>
        <trans-unit id="3e32b9c47f2e2fc9ac6d51a5bf3c388bc11b8917" translate="yes" xml:space="preserve">
          <source>Huge Pages</source>
          <target state="translated">거대한 페이지</target>
        </trans-unit>
        <trans-unit id="f5a56a19619af59c456f00d553851283fae574c2" translate="yes" xml:space="preserve">
          <source>Huge pages enabled</source>
          <target state="translated">거대한 페이지 사용</target>
        </trans-unit>
        <trans-unit id="60d434d91678537382630b39042caf9609c29924" translate="yes" xml:space="preserve">
          <source>Human-readable:</source>
          <target state="translated">Human-readable:</target>
        </trans-unit>
        <trans-unit id="80cb96f852d1ce7ae9b00c59c13912122674f7ce" translate="yes" xml:space="preserve">
          <source>Hungarian</source>
          <target state="translated">Hungarian</target>
        </trans-unit>
        <trans-unit id="f14e46ce7d094f9326167acc499698128651be85" translate="yes" xml:space="preserve">
          <source>Hungary</source>
          <target state="translated">Hungary</target>
        </trans-unit>
        <trans-unit id="35e06418151b7beefa16872b5c57d6b9d25c2926" translate="yes" xml:space="preserve">
          <source>Huntsman</source>
          <target state="translated">Huntsman</target>
        </trans-unit>
        <trans-unit id="69bbb7ddaef181e979bdc08582fcb222e4c8c826" translate="yes" xml:space="preserve">
          <source>Husy Frederic</source>
          <target state="translated">Husy Frederic</target>
        </trans-unit>
        <trans-unit id="a4a5854c539135440805af6892bd033cefe0a0b0" translate="yes" xml:space="preserve">
          <source>HyperThreading and Multiple Cores (CPUs)</source>
          <target state="translated">하이퍼 스레딩 및 다중 코어 (CPU)</target>
        </trans-unit>
        <trans-unit id="fb017c0130cf9541939ea2167eca326baf8a2d27" translate="yes" xml:space="preserve">
          <source>HyperThreading is great for marketing, lousy for performance. It involves having two processing units sharing a single hardware cache. If both units are doing the same thing, the cache will be reasonably useful. If the units are doing different things, they will be clobbering each other's cache entries.</source>
          <target state="translated">HyperThreading은 마케팅에 적합하고 성능이 크게 향상되었습니다. 단일 하드웨어 캐시를 공유하는 두 개의 처리 장치가 필요합니다. 두 장치가 모두 동일한 작업을 수행하는 경우 캐시가 상당히 유용합니다. 장치가 다른 작업을 수행하는 경우 서로의 캐시 항목을 방해합니다.</target>
        </trans-unit>
        <trans-unit id="aaf46563402b4fceaa229e57a46d1fa059bb7bfe" translate="yes" xml:space="preserve">
          <source>HyperThreading is mostly a thing of the past, so this section may not apply.</source>
          <target state="translated">하이퍼 스레딩은 대부분 과거의 일이므로이 섹션은 적용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac152177ed266fc25515fc6d2d12079458f662bc" translate="yes" xml:space="preserve">
          <source>Hypothetical Requirements</source>
          <target state="translated">가상의 요구 사항</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="b88e54151005d03c1337a52bc096e5da6731c796" translate="yes" xml:space="preserve">
          <source>I also used &lt;a href=&quot;https://github.com/tforsberg/DataFlexToSQLite&quot;&gt;this&lt;/a&gt; GitHub project as a guide / template (being as I didn't want to convert the DataFlex files, just read and write to them in place).</source>
          <target state="translated">또한 &lt;a href=&quot;https://github.com/tforsberg/DataFlexToSQLite&quot;&gt;이&lt;/a&gt; GitHub 프로젝트를 가이드 / 템플릿으로 사용했습니다 (DataFlex 파일을 변환하지 않고 읽고 쓰기 만하면됩니다).</target>
        </trans-unit>
        <trans-unit id="d79364c2706e9168855edbc9a6bd57566a695403" translate="yes" xml:space="preserve">
          <source>I bring this up as a separate topic because of some of the subtle issues that can happen.</source>
          <target state="translated">나는 발생할 수있는 미묘한 문제로 인해 이것을 별도의 주제로 제시합니다.</target>
        </trans-unit>
        <trans-unit id="f3262c4b1c7c6ee928e4bf13a63b15dc358f55db" translate="yes" xml:space="preserve">
          <source>I can imagine other users, e.g. astrophysicists, mathematicians, geologists, historians etc would need dates outside the 1000 - 9999 range.</source>
          <target state="translated">천체 물리학 자, 수학자, 지질 학자, 역사가 등 다른 사용자가 1000-9999 범위를 벗어난 날짜가 필요할 것이라고 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b25ebecccc7a6a3e6eec380d6c284c37e8965400" translate="yes" xml:space="preserve">
          <source>I did not include the technique(s) using GROUP_CONCAT. They are useful in some situations with small datasets. They can be found in the references below.</source>
          <target state="translated">GROUP_CONCAT를 사용하는 기술을 포함하지 않았습니다. 작은 데이터 세트가있는 일부 상황에서 유용합니다. 아래 참조에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="347b19ba7560e00129014e2725b3e210cc63a36e" translate="yes" xml:space="preserve">
          <source>I emphasize &quot;must&quot; because flags and other filtering is often the root of performance issues.</source>
          <target state="translated">플래그 및 기타 필터링은 종종 성능 문제의 근본이므로 &quot;필수&quot;를 강조합니다.</target>
        </trans-unit>
        <trans-unit id="c92efd9005caa0a561df5bed9e988758d2f28893" translate="yes" xml:space="preserve">
          <source>I have a CSV file containing amongst other things a couple of date columns. Some of the date values are empty - that is just &quot;&lt;sub&gt;&quot; - a comma followed by another comma.&lt;/sub&gt;</source>
          <target state="translated">몇 가지 날짜 열이 포함 된 CSV 파일이 있습니다. 일부 날짜 값은 비어 있습니다. 즉, &quot; &lt;sub&gt;&quot;-쉼표 뒤에 다른 쉼표가 있습니다.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="43dd49ccbf18ae8c5fe994bb67651217750be226" translate="yes" xml:space="preserve">
          <source>I have a CSV file containing amongst other things a couple of date columns....</source>
          <target state="translated">몇 가지 날짜 열이 포함 된 CSV 파일이 있습니다 ....</target>
        </trans-unit>
        <trans-unit id="e54a1a5051af2659eda35fb2b965530bb7a94646" translate="yes" xml:space="preserve">
          <source>I have a table of 6MB with 50 values in the pivot-values leading to 50 colu...</source>
          <target state="translated">50 콜로 이어지는 피벗 값에 50 개의 값이있는 6MB의 테이블이 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="25e21037027c2411995f8ac04722ff5af3a75409" translate="yes" xml:space="preserve">
          <source>I have a table of 6MB with 50 values in the pivot-values leading to 50 columns in the pivoted table. That one works nicely.</source>
          <target state="translated">피벗 된 값에 50 개의 값이있는 6MB의 테이블이 있는데 피벗 된 테이블의 열이 50 개입니다. 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="599f1cf1f4321208ce6312fc5233ea949c4e3d87" translate="yes" xml:space="preserve">
          <source>I have another much larger table with 170MB and 121 columns. When creating the pivoted table I get an error:</source>
          <target state="translated">170MB와 121 열이있는 훨씬 더 큰 테이블이 있습니다. 피벗 테이블을 만들 때 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9b711487d4c819f3b8d0655e56ee34637bcbec3a" translate="yes" xml:space="preserve">
          <source>I have implicitly assumed the data is being pushed into the database. If, instead, you are &quot;pulling&quot; data from some source(s), then there are some different considerations.</source>
          <target state="translated">데이터가 데이터베이스에 푸시되고 있다고 암시 적으로 가정했습니다. 대신 일부 소스에서 데이터를 &quot;풀링&quot;하는 경우 몇 가지 다른 고려 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c48ab3cdf82829cb7ed12ddcc623697b8b1b755" translate="yes" xml:space="preserve">
          <source>I recently had an issue that brought me here - I was trying to pass a value from a Java LocalDate with the value LocalDate.MAX (+999999999-12-31).</source>
          <target state="translated">최근에 여기에 문제가 발생했습니다. LocalDate.MAX (+ 999999999-12-31) 값으로 Java LocalDate에서 값을 전달하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="a1a032ff956fabd28f53a4834395247f2a81a320" translate="yes" xml:space="preserve">
          <source>I simulated the problem by generating random hashes and calculated the number of bits that would be set. Then, with the help of Eureqa software, I derived the formula:</source>
          <target state="translated">임의의 해시를 생성하여 문제를 시뮬레이션하고 설정할 비트 수를 계산했습니다. 그런 다음 Eureqa 소프트웨어의 도움으로 다음 공식을 도출했습니다.</target>
        </trans-unit>
        <trans-unit id="e78a0b1cdc084339b1ed550ed86481d103e75521" translate="yes" xml:space="preserve">
          <source>I suppose i could suppress errors but it isn't my way. But what is the correct way to fix it?</source>
          <target state="translated">나는 오류를 억제 할 수 있다고 생각하지만 내 방식이 아닙니다. 그러나 그것을 고치는 올바른 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="b1365bc2dd348dc2c29839418884994c102548f0" translate="yes" xml:space="preserve">
          <source>I thought about having several extra options for variations, but decided that would be too messy. Instead, here are instructions for implementing the variations, either by capturing the SELECT that was output by the Stored Procedure, or by modifying the SP, itself.</source>
          <target state="translated">변형에 대한 몇 가지 추가 옵션을 생각했지만 너무 지저분하다고 결정했습니다. 대신 저장 프로 시저에서 출력 된 SELECT를 캡처하거나 SP 자체를 수정하여 변형을 구현하기위한 지침이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ca210f00d612baf7e98c73056444ed9e5c947c4" translate="yes" xml:space="preserve">
          <source>I tried to create a pivot table based on an existing table &quot;test1&quot; and get ...</source>
          <target state="translated">기존 테이블 &quot;test1&quot;을 기반으로 피벗 테이블을 만들고 시도했습니다 ...</target>
        </trans-unit>
        <trans-unit id="019a33d296dfaafccba43e5d181c78f46e688543" translate="yes" xml:space="preserve">
          <source>I tried to create a pivot table based on an existing table &quot;test1&quot; and get an error. I am logged in and I can use &quot;test1&quot;, so this error makes no sense to me. What I am doing wrong? Any hints?</source>
          <target state="translated">기존 테이블 &quot;test1&quot;을 기반으로 피벗 테이블을 만들려고했지만 오류가 발생했습니다. 로그인 한 상태에서 &quot;test1&quot;을 사용할 수 있으므로이 오류는 의미가 없습니다. 내가 뭘 잘못하고 있니? 힌트가 있습니까?</target>
        </trans-unit>
        <trans-unit id="2f72e33a6d0161c81f62c8aaf1146ddfb50043dc" translate="yes" xml:space="preserve">
          <source>I used &lt;code&gt;3306&lt;/code&gt; because that is the port that is usually used by &lt;code&gt;mysqld&lt;/code&gt;, so I know that it is not blocked.</source>
          <target state="translated">나는 그것이 &lt;code&gt;mysqld&lt;/code&gt; 에 의해 일반적으로 사용되는 포트이기 때문에 &lt;code&gt;3306&lt;/code&gt; 을 사용 했기 때문에 차단되지 않았다는 것을 안다.</target>
        </trans-unit>
        <trans-unit id="c0950461228cc31fe584e87c14f0779b0995a699" translate="yes" xml:space="preserve">
          <source>I used DBT-3 benchmark data, with scale factor=1. Since the benchmark defines very few indexes, we've added a multi-column index (index condition pushdown is usually useful with multi-column indexes: the first component(s) is what index access is done for, the subsequent have columns that we read and check conditions on).</source>
          <target state="translated">스케일 팩터 = 1 인 DBT-3 벤치 마크 데이터를 사용했습니다. 벤치 마크는 인덱스를 거의 정의하지 않기 때문에 다중 열 인덱스를 추가했습니다 (인덱스 조건 푸시 다운은 일반적으로 다중 열 인덱스에 유용합니다. 첫 번째 구성 요소는 인덱스 액세스가 수행되는 것이므로 그 이후에는 열이 있습니다) 조건을 읽고 확인하십시오).</target>
        </trans-unit>
        <trans-unit id="dc00b84eec9f7d121e03101d1e77b84b40125e02" translate="yes" xml:space="preserve">
          <source>I was advised by @montywi on the Freenode IRC channel that this was the best place for my question. I will happily supply reference .dat files and support their inclusion in CONNECT however I can. I'm just at a total loss for how to proceed.</source>
          <target state="translated">나는 Freenode IRC 채널에서 @montywi에 의해 이것이 내 질문에 가장 적합한 장소라고 조언했다. 참조 .dat 파일을 행복하게 제공하고 CONNECT에 포함시킬 수는 있지만 지원할 수는 있습니다. 진행 방법에 대한 총 손실이 있습니다.</target>
        </trans-unit>
        <trans-unit id="91464bfe56c31482ee4117edc8a2fcaf1569d8eb" translate="yes" xml:space="preserve">
          <source>I was playing around with my MariaDB ColumnStore and I noticed the I am not able to create tables/databases with capital letters, it seems that only lowercase can be used:</source>
          <target state="translated">MariaDB ColumnStore를 가지고 놀고 있었고 대문자로 테이블 / 데이터베이스를 만들 수 없다는 것을 알았습니다. 소문자 만 사용할 수있는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="435b4143f42a82490525c53e0c960991e91be8a7" translate="yes" xml:space="preserve">
          <source>I will present a solution that enforces the fact that items cannot have overlapping ranges. The solution builds a table to take advantage of that, then uses Stored Routines to get around the clumsiness imposed by it.</source>
          <target state="translated">아이템이 겹치는 범위를 가질 수 없다는 사실을 강제하는 솔루션을 제시하겠습니다. 이 솔루션은이를 활용하기 위해 테이블을 작성한 다음 저장된 루틴을 사용하여 테이블에 부과 된 서투른 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="b6de17ca97eea1abf16a0e427f31e2f6bdae63dc" translate="yes" xml:space="preserve">
          <source>I would create a table on the client to the foreign server on port 5555, and then to the FederatedX server on port 5554. At this point, I would run whatever queries I wanted to on the FederatedX server, just always remembering that whatever changes I wanted to make on the table, or if I created new tables, that I would have to do that on the foreign server.</source>
          <target state="translated">클라이언트에서 포트 5555의 외부 서버에 대한 테이블을 생성 한 다음 포트 5554의 FederatedX 서버에 테이블을 작성합니다.이 시점에서 FederatedX 서버에서 원하는 쿼리를 실행하고 변경 사항은 항상 기억합니다. 테이블을 만들고 싶거나 새 테이블을 만든 경우 외부 서버에서 수행해야했습니다.</target>
        </trans-unit>
        <trans-unit id="0a38e0a412641efabd7037043d564612486300dd" translate="yes" xml:space="preserve">
          <source>I would like to know which datatypes are supported by MariaDB. I'm asking s...</source>
          <target state="translated">MariaDB가 지원하는 데이터 유형을 알고 싶습니다. 물어 보니 ...</target>
        </trans-unit>
        <trans-unit id="3cf998e4ca468ab6e892d70422ec8d4df07b6fdd" translate="yes" xml:space="preserve">
          <source>I would like to know which datatypes are supported by MariaDB. I'm asking since I'm little confused. For example, the knowledge base contains a chapter temporal datatypes: &lt;a href=&quot;https://kb.askmonty.org/en/temporal-data-types/&quot;&gt;https://kb.askmonty.org/en/temporal-data-types/&lt;/a&gt;</source>
          <target state="translated">MariaDB가 지원하는 데이터 유형을 알고 싶습니다. 조금 혼란스러워서 묻습니다. 예를 들어, 지식 기반에는 장 시간 데이터 유형이 포함되어 있습니다. &lt;a href=&quot;https://kb.askmonty.org/en/temporal-data-types/&quot;&gt;https://kb.askmonty.org/en/temporal-data-types/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2e3ccd4849b6a5e9b7167e4771ab005fed094acd" translate="yes" xml:space="preserve">
          <source>I'm using MariaDB's CONNECT engine to access / utilize a set of Visual FoxP...</source>
          <target state="translated">MariaDB의 CONNECT 엔진을 사용하여 Visual FoxP 세트에 액세스 / 활용하고 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="2a12078201a02b74c332bd57bb0765aa36b30b89" translate="yes" xml:space="preserve">
          <source>I'm using MariaDB's CONNECT engine to access / utilize a set of Visual FoxPro / dBase files as part of supporting an extremely old piece of software for a client. It's works SO well, and I'm extremely happy with it.</source>
          <target state="translated">MariaDB의 CONNECT 엔진을 사용하여 클라이언트를위한 매우 오래된 소프트웨어를 지원하는 일환으로 Visual FoxPro / dBase 파일 세트에 액세스 / 활용하고 있습니다. 그것은 잘 작동하며 매우 행복합니다.</target>
        </trans-unit>
        <trans-unit id="488ff26cc0010fea88cfc06fff09624e159ca3b7" translate="yes" xml:space="preserve">
          <source>I've actually written a functional parser for the .dat files in Python based of of the notes here &lt;a href=&quot;https://hwiegman.home.xs4all.nl/fileformats/dat/DATAFLEX.txt&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;https://code.activestate.com/lists/perl-dbi-dev/1529/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">실제로 &lt;a href=&quot;https://hwiegman.home.xs4all.nl/fileformats/dat/DATAFLEX.txt&quot;&gt;here&lt;/a&gt; 및 &lt;a href=&quot;https://code.activestate.com/lists/perl-dbi-dev/1529/&quot;&gt;here&lt;/a&gt; 메모를 기반으로 Python의 .dat 파일에 대한 기능 파서를 작성했습니다 .</target>
        </trans-unit>
        <trans-unit id="efbc6e2019366afedef0fb90d70a087b50ab9642" translate="yes" xml:space="preserve">
          <source>I've found enough documentation to pretty much nail down the file format. The CONNECT engine recognizes them just fine as DOS or BIN types files. The one and only problem is that MariaDB expects the first record to begin at the beginning of the file, but the .dat files contain a header portion that describes the table itself. I can read that and calculate the correct CREATE TABLE statement just fine, but I can't seem to find a way to compensate for the header being where MariaDB expects records to be.</source>
          <target state="translated">파일 형식을 거의 정리할 수있는 충분한 문서를 찾았습니다. CONNECT 엔진은 이들을 DOS 또는 BIN 유형 파일로 잘 인식합니다. 유일한 문제는 MariaDB가 파일의 시작 부분에서 첫 번째 레코드가 시작될 것으로 예상하지만 .dat 파일에는 테이블 자체를 설명하는 헤더 부분이 포함되어 있다는 것입니다. 나는 그것을 읽고 올바른 CREATE TABLE 문을 잘 계산할 수는 있지만 MariaDB가 레코드를 기대하는 헤더를 보상하는 방법을 찾지 못하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="33bfd5ebd387ac798b37520f1aa44757598fd245" translate="yes" xml:space="preserve">
          <source>I/O error reading log index file</source>
          <target state="translated">로그 색인 파일을 읽는 중 I / O 오류</target>
        </trans-unit>
        <trans-unit id="5af82c2d4b8dec2b02b170798d8ede45b17d481d" translate="yes" xml:space="preserve">
          <source>I/O operations can be avoided by caching, in which case they will not be recorded in this table.</source>
          <target state="translated">캐싱을 통해 I / O 작업을 피할 수 있으며이 경우이 표에 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f37a6c1d3bffc025386c2059d1f2f7f93581f4fc" translate="yes" xml:space="preserve">
          <source>IBMDB2I Storage Engine</source>
          <target state="translated">IBMDB2I 스토리지 엔진</target>
        </trans-unit>
        <trans-unit id="89f89c02cf47e091e726a4e07b88af0966806897" translate="yes" xml:space="preserve">
          <source>ID</source>
          <target state="translated">ID</target>
        </trans-unit>
        <trans-unit id="b691a3366fa96fd8348abcc6a5d5f95f68180399" translate="yes" xml:space="preserve">
          <source>ID field, auto_increments.</source>
          <target state="translated">ID 필드, auto_increments.</target>
        </trans-unit>
        <trans-unit id="70aaa5c27d01bf35d3ffee47cfb1c000c451fc13" translate="yes" xml:space="preserve">
          <source>ID of the Spatial Reference System used for the coordinate geometry in this table. It is a foreign key reference to the &lt;code&gt;&lt;a href=&quot;../information-schema-spatial_ref_sys-table/index&quot;&gt;SPATIAL_REF_SYS table&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 테이블의 좌표 형상에 사용 된 공간 참조 시스템의 ID입니다. &lt;code&gt;&lt;a href=&quot;../information-schema-spatial_ref_sys-table/index&quot;&gt;SPATIAL_REF_SYS table&lt;/a&gt;&lt;/code&gt; 대한 외래 키 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="65c98dc7bbc52d110014cd62107cc9de74071ade" translate="yes" xml:space="preserve">
          <source>ID of the buffer pool instance.</source>
          <target state="translated">버퍼 풀 인스턴스의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="5134fdf17cbceed2f532fd66c3612af0ce5c5943" translate="yes" xml:space="preserve">
          <source>IDB_BLOB</source>
          <target state="translated">IDB_BLOB</target>
        </trans-unit>
        <trans-unit id="76a2b282cf9560f68e838bd342ed75619b44adff" translate="yes" xml:space="preserve">
          <source>IDB_CHAR</source>
          <target state="translated">IDB_CHAR</target>
        </trans-unit>
        <trans-unit id="4e18aea217e79e5eb4bd4ccedd7c400221b1fb56" translate="yes" xml:space="preserve">
          <source>IDB_DELETE</source>
          <target state="translated">IDB_DELETE</target>
        </trans-unit>
        <trans-unit id="8a1f97571e05a0aebb77a4f51952e989d4ad38d3" translate="yes" xml:space="preserve">
          <source>IDB_FLOAT</source>
          <target state="translated">IDB_FLOAT</target>
        </trans-unit>
        <trans-unit id="0de451090b1abed2ca2a1b7105b1e57c21f20091" translate="yes" xml:space="preserve">
          <source>IDB_INT</source>
          <target state="translated">IDB_INT</target>
        </trans-unit>
        <trans-unit id="48cd0fa598bb8b050272d4dd212c04c95f55367a" translate="yes" xml:space="preserve">
          <source>IDE Builds</source>
          <target state="translated">IDE 빌드</target>
        </trans-unit>
        <trans-unit id="0ce10ef880340c6dc76ff7b3bae7dc93d4f05974" translate="yes" xml:space="preserve">
          <source>IDE for the development, management, and administration of MariaDB &amp;amp; MySQL databases.</source>
          <target state="translated">MariaDB 및 MySQL 데이터베이스의 개발, 관리 및 관리를위한 IDE.</target>
        </trans-unit>
        <trans-unit id="e92a6db5a1bb164671d611239a0fef98ab41781b" translate="yes" xml:space="preserve">
          <source>IDENTIFIED BY 'password'</source>
          <target state="translated">'비밀번호'로 식별</target>
        </trans-unit>
        <trans-unit id="f4da2f995ec19c3e49fa4bc6abad1b6e760df1e6" translate="yes" xml:space="preserve">
          <source>IDENTIFIED BY PASSWORD 'password_hash'</source>
          <target state="translated">비밀번호 'password_hash'로 식별</target>
        </trans-unit>
        <trans-unit id="249e16c70dd79b8469e1cc7fadbcf1fdad1c2f90" translate="yes" xml:space="preserve">
          <source>IDENTIFIED {VIA|WITH} authentication_plugin</source>
          <target state="translated">인증 된 {VIA | WITH} authentication_plugin</target>
        </trans-unit>
        <trans-unit id="d1f4deccd6feee4a6773508747aa19b915f6be13" translate="yes" xml:space="preserve">
          <source>IEEE format native to the computer</source>
          <target state="translated">컴퓨터 고유의 IEEE 형식</target>
        </trans-unit>
        <trans-unit id="7be63e2881f7da8faa393bfe0ce4667f10916b66" translate="yes" xml:space="preserve">
          <source>IF</source>
          <target state="translated">IF</target>
        </trans-unit>
        <trans-unit id="5e8fe44652bd7f8585c7b9a89007b360073d9c8d" translate="yes" xml:space="preserve">
          <source>IF EXISTS</source>
          <target state="translated">존재하는 경우</target>
        </trans-unit>
        <trans-unit id="cd03d1421af621953f9b7f0c9ba00885475881f8" translate="yes" xml:space="preserve">
          <source>IF EXISTS:</source>
          <target state="translated">존재하는 경우 :</target>
        </trans-unit>
        <trans-unit id="0c0b3cde319d28e73fdd09dc3b035025c2b739b6" translate="yes" xml:space="preserve">
          <source>IF Function</source>
          <target state="translated">IF 기능</target>
        </trans-unit>
        <trans-unit id="971bbe31b8acc9d404a0ab45ff65e7e237a0c645" translate="yes" xml:space="preserve">
          <source>IF NOT EXISTS</source>
          <target state="translated">존재하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="46bd2a35a74872eec67770eb9a958aa928a9f889" translate="yes" xml:space="preserve">
          <source>IF()</source>
          <target state="translated">IF()</target>
        </trans-unit>
        <trans-unit id="429d6cf511d154b24dd24f5d655ee5a05bb00d35" translate="yes" xml:space="preserve">
          <source>IFNULL</source>
          <target state="translated">IFNULL</target>
        </trans-unit>
        <trans-unit id="be39fedd8d419e4d1e8e83627f1f839a251a8bcb" translate="yes" xml:space="preserve">
          <source>IFNULL function</source>
          <target state="translated">IFNULL 함수</target>
        </trans-unit>
        <trans-unit id="56208decc9d3be960296127844be71bc54b1d08e" translate="yes" xml:space="preserve">
          <source>IFNULL()</source>
          <target state="translated">IFNULL()</target>
        </trans-unit>
        <trans-unit id="c9226f99dd645a71848cf0585c15059d7de868f4" translate="yes" xml:space="preserve">
          <source>IGNORE</source>
          <target state="translated">IGNORE</target>
        </trans-unit>
        <trans-unit id="3ff67e6936f6d8182b32a8c74bef4777e022b06e" translate="yes" xml:space="preserve">
          <source>IGNORE INDEX</source>
          <target state="translated">무시 색인</target>
        </trans-unit>
        <trans-unit id="307dcfcd4e4c257d500e2d4158a660620bf37d1a" translate="yes" xml:space="preserve">
          <source>IGNORE INDEX: Don't Use a Particular Index</source>
          <target state="translated">무시 색인 : 특정 색인을 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="22e43a4cb0579fa0f16e2c5706a2acebe8ca0cef" translate="yes" xml:space="preserve">
          <source>IGNORE is used in case you are doing the INSERT from multiple processes simultaneously.</source>
          <target state="translated">여러 프로세스에서 INSERT를 동시에 수행하는 경우 IGNORE가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0430bdf75deb566b544796a473cc5b917023abf2" translate="yes" xml:space="preserve">
          <source>IGNORE_DOMAIN_IDS</source>
          <target state="translated">IGNORE_DOMAIN_IDS</target>
        </trans-unit>
        <trans-unit id="b9578cbcfa93eb8fa48248e9410c5d1c85319999" translate="yes" xml:space="preserve">
          <source>IGNORE_SERVER_IDS</source>
          <target state="translated">IGNORE_SERVER_IDS</target>
        </trans-unit>
        <trans-unit id="8ae3e8381a64e36db57a5344790db89d7de90954" translate="yes" xml:space="preserve">
          <source>IMMEDIATE</source>
          <target state="translated">IMMEDIATE</target>
        </trans-unit>
        <trans-unit id="68eac37d5cf71f8c92dca16ee0e3d382a2c5ea45" translate="yes" xml:space="preserve">
          <source>IMPORT TABLESPACE</source>
          <target state="translated">수입 테이블 스페이스</target>
        </trans-unit>
        <trans-unit id="e00f0877da078bf9f3cc0a164e0712618785c23a" translate="yes" xml:space="preserve">
          <source>IMPORT on the other hand does not enforce foreign key constraints. So when importing tablespaces, referential integrity can only be guaranteed to import all tables bound by foreign key constraint at the same time, from an EXPORT of those tables taken with the same transactional state.</source>
          <target state="translated">반면에 IMPORT는 외래 키 제약 조건을 시행하지 않습니다. 따라서 테이블 스페이스를 가져올 때 동일한 트랜잭션 상태로 가져온 테이블의 EXPORT에서 외래 키 제한 조건에 의해 바인드 된 모든 테이블 만 동시에 가져 오도록 참조 무결성을 보장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="224b4dea3791f6a563b657cf591d85f89d1af435" translate="yes" xml:space="preserve">
          <source>IMPORTANT - If there is no MariaDB Root user password set, make sure there is no .my.cnf file. This could cause failures in install and upgrades if this file exist when no password is set.</source>
          <target state="translated">중요-MariaDB 루트 사용자 비밀번호가 설정되어 있지 않은 경우 .my.cnf 파일이 없는지 확인하십시오. 비밀번호가 설정되지 않은 경우이 파일이 존재하면 설치 및 업그레이드에 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd0366ce96ae4e144141f9e48083eb65226fb99e" translate="yes" xml:space="preserve">
          <source>IMPORTANT: Don't change any of the configuration files, Columnstore.xml or my.cnf, to point to a different install or data location.</source>
          <target state="translated">중요 : 다른 설치 또는 데이터 위치를 가리 키도록 구성 파일 Columnstore.xml 또는 my.cnf를 변경하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="fe95a1361b74c729925988fb7b0e41e781c7af79" translate="yes" xml:space="preserve">
          <source>IMPORTANT: If postConfigure fails at any point, you can use the following guides to help trouble shoot any issues. And once an issue has been fixed, it is required that you re-run postConfigure until you get a successful completion.</source>
          <target state="translated">중요 : postConfigure가 언제라도 실패하면 다음 안내서를 사용하여 문제를 해결하는 데 도움을받을 수 있습니다. 문제가 해결되면 성공적으로 완료 될 때까지 postConfigure를 다시 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="35c821a09b9db2ae4e76c7c154dd8d87b666d817" translate="yes" xml:space="preserve">
          <source>IMPORTANT: It is required that the installation directory will be the home directory of the user account. So it would be '/home/mysql/' in this example. The installation directory must be the same on every node. In the examples below we will use the path '/home/mysql/mariadb/columnstore'.</source>
          <target state="translated">중요 : 설치 디렉토리는 사용자 계정의 홈 디렉토리 여야합니다. 따라서이 예에서는 '/ home / mysql /'입니다. 설치 디렉토리는 모든 노드에서 동일해야합니다. 아래 예에서는 '/ home / mysql / mariadb / columnstore'경로를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="16973661e616d5fb7e3df5ba83bf03cce84bdc3c" translate="yes" xml:space="preserve">
          <source>IMPORTANT: Its recommenced that you check with MariaDB ColumnStore support first on if this change should be made so it can be confirmed that this is the best work-around.</source>
          <target state="translated">중요 :이 변경을 수행해야하는지 MariaDB ColumnStore 지원에 먼저 확인하여 이것이 최선의 해결 방법임을 확인할 수있는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b204936499b2b12274d952c874dca4217f417c78" translate="yes" xml:space="preserve">
          <source>IMPORTANT: Make sure there are no other version of MariaDB server install. If so, these will need to be uninstalled before installing MariaDB ColumnStore.</source>
          <target state="translated">중요 : 다른 버전의 MariaDB 서버가 설치되어 있지 않은지 확인하십시오. 그렇다면 MariaDB ColumnStore를 설치하기 전에 이러한 프로그램을 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="95188dee155cb809855e74603520bbd9a865a2d3" translate="yes" xml:space="preserve">
          <source>IMPORTANT: This tool should only be run on a Performance Module Server, preferably Module #1</source>
          <target state="translated">중요 :이 도구는 성능 모듈 서버에서만 실행해야하며, 바람직하게는 모듈 # 1입니다.</target>
        </trans-unit>
        <trans-unit id="c0270491c31ef9d57803c3e609adab915155fd57" translate="yes" xml:space="preserve">
          <source>IMPORTANT: This tool should only be run on the Parent OAM Module which is a Performance Module, preferred Module #1</source>
          <target state="translated">중요 :이 도구는 성능 모듈 인 선호 모듈 # 1 인 부모 OAM 모듈에서만 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="8280047542a9ce5f31d74111803c44f9dc8a4131" translate="yes" xml:space="preserve">
          <source>IMPORTANT: When using Storage (extX, NFS, etc), setup to have the MariaDB front-end data and the DBRoots back-end data files mounted. Don't setup a mount where the actually MariaDB Columnstore package as a whole is mounted, i.e. /usr/local/mariadb or /usr/local/mariadb/columnstore.</source>
          <target state="translated">중요 : 스토리지 (extX, NFS 등)를 사용할 때 MariaDB 프론트 엔드 데이터 및 DBRoots 백엔드 데이터 파일이 마운트되도록 설정하십시오. 실제로 MariaDB Columnstore 패키지가 전체적으로 마운트되는 마운트를 설정하지 마십시오 (예 : / usr / local / mariadb 또는 / usr / local / mariadb / columnstore).</target>
        </trans-unit>
        <trans-unit id="c73f17f29113b75ebe49f02d03055a554f50da4c" translate="yes" xml:space="preserve">
          <source>IMPORTANT: When using external storage, be sure that only whole DBRoots are on the external filesystem. Do not use higher level directories, which may include the ColumnStore binaries and libraries. For example, /usr/local/mariadb/columnstore/data1 (aka DBRoot 1) would be a good candidate for external storage, but /usr/local/mariadb/columnstore would not be.</source>
          <target state="translated">중요 : 외부 저장소를 사용할 때는 전체 DBRoot 만 외부 파일 시스템에 있어야합니다. ColumnStore 바이너리 및 라이브러리를 포함 할 수있는 높은 수준의 디렉토리를 사용하지 마십시오. 예를 들어, / usr / local / mariadb / columnstore / data1 (일명 DBRoot 1)은 외부 저장소에 적합하지만 / usr / local / mariadb / columnstore는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d538d1ede6097f03dcc535f9830c6c10061e54b" translate="yes" xml:space="preserve">
          <source>IMPORTANT: the compression type does not default to the &lt;a href=&quot;../tokudb-system-variables/index#tokudb_row_format&quot;&gt;tokudb_row_format&lt;/a&gt; session variable as it does with Tokutek's builds. If &lt;code&gt;COMPRESSION=&lt;/code&gt; is not included in &lt;code&gt;CREATE TABLE&lt;/code&gt; or &lt;code&gt;ALTER TABLE ENGINE=TokuDB&lt;/code&gt; then the TokuDB table will be uncompressed (before 5.5.37) or zlib-compressed (5.5.37 and later).</source>
          <target state="translated">중요 : 압축 유형은 Tokutek 빌드와 마찬가지로 &lt;a href=&quot;../tokudb-system-variables/index#tokudb_row_format&quot;&gt;tokudb_row_format&lt;/a&gt; 세션 변수를 기본값으로 사용하지 않습니다 . 경우 &lt;code&gt;COMPRESSION=&lt;/code&gt; 에 포함되지 &lt;code&gt;CREATE TABLE&lt;/code&gt; 또는 &lt;code&gt;ALTER TABLE ENGINE=TokuDB&lt;/code&gt; 을 다음 TokuDB 테이블은 압축 될 것이다 (5.5.37) 전에 또는 ZLIB 압축 (5.5.37 이상).</target>
        </trans-unit>
        <trans-unit id="6fca55ca3c828a46bfe96a10e69f572b61ce540c" translate="yes" xml:space="preserve">
          <source>IN</source>
          <target state="translated">IN</target>
        </trans-unit>
        <trans-unit id="2a22533c7fd4a4fb39ef19048bf94a64a3b94aa6" translate="yes" xml:space="preserve">
          <source>IN ( SELECT ... )</source>
          <target state="translated">IN (선택 ...)</target>
        </trans-unit>
        <trans-unit id="ffb7536f77fd00dbc15ae0d9e3708592aca9741a" translate="yes" xml:space="preserve">
          <source>IN BOOLEAN MODE</source>
          <target state="translated">BOOLEAN 모드에서</target>
        </trans-unit>
        <trans-unit id="9c9c045617f59092849311e023c8fe625f4f7204" translate="yes" xml:space="preserve">
          <source>IN NATURAL LANGUAGE MODE</source>
          <target state="translated">자연어 모드</target>
        </trans-unit>
        <trans-unit id="be3a90e8a2fca3ecdef74d90a1a0b54c9e1e1313" translate="yes" xml:space="preserve">
          <source>IN NATURAL LANGUAGE MODE is the default type of full-text search, and the keywords can be omitted. There are no special operators, and searches consist of one or more comma-separated keywords.</source>
          <target state="translated">IN NATURAL LANGUAGE MODE는 전체 텍스트 검색의 기본 유형이며 키워드를 생략 할 수 있습니다. 특수 연산자가 없으며 검색은 하나 이상의 쉼표로 구분 된 키워드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9bac84863fc20d4221f0f9768eafe9775de5a0a4" translate="yes" xml:space="preserve">
          <source>IN has complicated NULL-semantics. NOT EXISTS doesn't.</source>
          <target state="translated">IN에는 복잡한 NULL 의미가 있습니다. 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4cc3d98738b0bc9cd81c2f5a9d3fbeb12a22424f" translate="yes" xml:space="preserve">
          <source>IN on PRIMARY KEY -- 1 disk hit per item in IN</source>
          <target state="translated">기본 키의 IN-IN의 항목 당 1 개의 디스크 적중</target>
        </trans-unit>
        <trans-unit id="1e7836bfc389eb73914de03a4ddabd617e4956f2" translate="yes" xml:space="preserve">
          <source>IN-&amp;gt;EXISTS</source>
          <target state="translated">IN-&amp;gt;EXISTS</target>
        </trans-unit>
        <trans-unit id="025de532cc2b6e75940072008144f27651198eec" translate="yes" xml:space="preserve">
          <source>IN/OUT/INOUT</source>
          <target state="translated">IN/OUT/INOUT</target>
        </trans-unit>
        <trans-unit id="3180b13ce4ef633bea0886a5ad1a0181911b9dcb" translate="yes" xml:space="preserve">
          <source>INCREMENT</source>
          <target state="translated">INCREMENT</target>
        </trans-unit>
        <trans-unit id="2704c1d8c3fc215c38ee176f6cc30e434a22b7d7" translate="yes" xml:space="preserve">
          <source>INDEX</source>
          <target state="translated">INDEX</target>
        </trans-unit>
        <trans-unit id="4cb96fff2d9e04af841f9214232e20e3d2b97d6f" translate="yes" xml:space="preserve">
          <source>INDEX Issues</source>
          <target state="translated">색인 문제</target>
        </trans-unit>
        <trans-unit id="8807d97d844030173e7984d7c433898f3f10c833" translate="yes" xml:space="preserve">
          <source>INDEX(a,b) can find anything that INDEX(a) could find. So you don't need both. Get rid of the shorter one.</source>
          <target state="translated">INDEX (a, b)는 INDEX (a)가 찾을 수있는 모든 것을 찾을 수 있습니다. 따라서 둘 다 필요하지 않습니다. 더 짧은 것을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="989c59114004c51a52b3335b79d119bce7c1db57" translate="yes" xml:space="preserve">
          <source>INDEX(first_name), INDEX(last_name)</source>
          <target state="translated">INDEX (first_name), INDEX (last_name)</target>
        </trans-unit>
        <trans-unit id="b1ff28200cbf05454b251fc53fead54811e814b9" translate="yes" xml:space="preserve">
          <source>INDEX(first_name), INDEX(last_name) (two separate indexes)</source>
          <target state="translated">INDEX (first_name), INDEX (last_name) (2 개의 개별 인덱스)</target>
        </trans-unit>
        <trans-unit id="c4bca0af0c32b57e7fdf0097341cedef612252cc" translate="yes" xml:space="preserve">
          <source>INDEX(id) -- if `id` is &lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt;, then this plain INDEX (not UNIQUE, not PRIMARY KEY) is necessary</source>
          <target state="translated">INDEX (id)-`id`가 &lt;a href=&quot;../auto_increment/index&quot;&gt;AUTO_INCREMENT&lt;/a&gt; 인 경우이 일반 INDEX ( UNIX가 아닌 기본 키가 아님)가 필요합니다</target>
        </trans-unit>
        <trans-unit id="793fb12074d3bd4bbee431684eb453b885941b29" translate="yes" xml:space="preserve">
          <source>INDEX(id), INDEX(...) (but no UNIQUE keys)</source>
          <target state="translated">INDEX (id), INDEX (...) (단, 고유 키는 없음)</target>
        </trans-unit>
        <trans-unit id="c89a8fa8fb1c62f5c2704bd75efcf76a5dcddee7" translate="yes" xml:space="preserve">
          <source>INDEX(last_name, first_name)</source>
          <target state="translated">INDEX (성, 이름)</target>
        </trans-unit>
        <trans-unit id="9b6c1cb7a30bf933370f5cb88090745a6905c3eb" translate="yes" xml:space="preserve">
          <source>INDEX(last_name, first_name) (a &quot;compound&quot; index)</source>
          <target state="translated">INDEX (last_name, first_name) ( &quot;화합물&quot;인덱스)</target>
        </trans-unit>
        <trans-unit id="0d008ca557f7f4325a54871166d6f9a2ae64e130" translate="yes" xml:space="preserve">
          <source>INDEX(last_name, first_name, term) (a &quot;covering&quot; index)</source>
          <target state="translated">INDEX (성, 이름, 용어) ( &quot;표지&quot;색인)</target>
        </trans-unit>
        <trans-unit id="9b8458c0b2f415f08f22c2e7e8d89c7ed87743ec" translate="yes" xml:space="preserve">
          <source>INDEX(lat), INDEX(lon) -- but the optimizer used only one</source>
          <target state="translated">INDEX (lat), INDEX (lon)-옵티마이 저는 하나만 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="4cb7a137fcf5adc85318d10d9c0669ff6e551988" translate="yes" xml:space="preserve">
          <source>INDEX(lat,lon) -- but it still had to work too hard</source>
          <target state="translated">INDEX (lat, lon)-그러나 여전히 너무 열심히 일해야했습니다</target>
        </trans-unit>
        <trans-unit id="b6453621eda74bee7b2df3bc3b9c2a99c0638d0b" translate="yes" xml:space="preserve">
          <source>INDEX_STATISTICS</source>
          <target state="translated">INDEX_STATISTICS</target>
        </trans-unit>
        <trans-unit id="d2f94e18a8b6ab6f4ee95c299a4041284bcce179" translate="yes" xml:space="preserve">
          <source>INET6_ATON</source>
          <target state="translated">INET6_ATON</target>
        </trans-unit>
        <trans-unit id="e809f351d8f0a0e576670e0ced9d330345ec02d3" translate="yes" xml:space="preserve">
          <source>INET6_ATON()</source>
          <target state="translated">INET6_ATON()</target>
        </trans-unit>
        <trans-unit id="f23157f098145a9eeb88a07187db1c893633d876" translate="yes" xml:space="preserve">
          <source>INET6_ATON() has been available since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10012-release-notes/&quot;&gt;MariaDB 10.0.12&lt;/a&gt;.</source>
          <target state="translated">INET6_ATON ()은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10012-release-notes/&quot;&gt;MariaDB 10.0.12&lt;/a&gt; 부터 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="da84fc59aa374fdcfbb1e56db29def45f50683ef" translate="yes" xml:space="preserve">
          <source>INET6_NTOA</source>
          <target state="translated">INET6_NTOA</target>
        </trans-unit>
        <trans-unit id="71c7c0f50d31eb64c30378354bb2e74de885c676" translate="yes" xml:space="preserve">
          <source>INET6_NTOA()</source>
          <target state="translated">INET6_NTOA()</target>
        </trans-unit>
        <trans-unit id="50b42da14599921af0cb6726f44a9db88af1dff2" translate="yes" xml:space="preserve">
          <source>INET6_NTOA() has been available from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10012-release-notes/&quot;&gt;MariaDB 10.0.12&lt;/a&gt;.</source>
          <target state="translated">INET6_NTOA ()는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10012-release-notes/&quot;&gt;MariaDB 10.0.12&lt;/a&gt; 에서 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="fd0d5a1c5d42917eb5f4b4d9a3a680975141cd3d" translate="yes" xml:space="preserve">
          <source>INET_ATON</source>
          <target state="translated">INET_ATON</target>
        </trans-unit>
        <trans-unit id="d022f4767e940ec54c3653b08e342a66e6f13ffb" translate="yes" xml:space="preserve">
          <source>INET_ATON()</source>
          <target state="translated">INET_ATON()</target>
        </trans-unit>
        <trans-unit id="980345785d00a49f1d0d4d718ab3ca3e690536e0" translate="yes" xml:space="preserve">
          <source>INET_NTOA</source>
          <target state="translated">INET_NTOA</target>
        </trans-unit>
        <trans-unit id="f5040f7bb520255d015eabf1dab0c638a1198569" translate="yes" xml:space="preserve">
          <source>INET_NTOA()</source>
          <target state="translated">INET_NTOA()</target>
        </trans-unit>
        <trans-unit id="d05e97a01bfb8208657572ec3e5d894c7ca6d8e9" translate="yes" xml:space="preserve">
          <source>INFILE</source>
          <target state="translated">INFILE</target>
        </trans-unit>
        <trans-unit id="cb74181384115f8a1cb63ac64149672a5f8180a1" translate="yes" xml:space="preserve">
          <source>INFLOW '14: NVM Compression&amp;mdash;Hybrid Flash-Aware Application Level Compression</source>
          <target state="translated">INFLOW '14 : NVM 압축 &amp;mdash; 하이브리드 플래시 인식 응용 프로그램 수준 압축</target>
        </trans-unit>
        <trans-unit id="caa43f1c3f72ad668d50e33fe9dbd4537b54ed34" translate="yes" xml:space="preserve">
          <source>INFORMATION SCHEMA VIEWS Table</source>
          <target state="translated">정보 스키마 뷰 테이블</target>
        </trans-unit>
        <trans-unit id="4ce8800787a56cddc1663d422c3fda9b36123dde" translate="yes" xml:space="preserve">
          <source>INFORMATION_SCHEMA ROUTINES Table</source>
          <target state="translated">INFORMATION_SCHEMA ROUTINES 테이블</target>
        </trans-unit>
        <trans-unit id="d1499ca62d36134bc5693713394786f8b941fb6f" translate="yes" xml:space="preserve">
          <source>INFORMATION_SCHEMA.COLUMNS Table</source>
          <target state="translated">INFORMATION_SCHEMA.COLUMNS 테이블</target>
        </trans-unit>
        <trans-unit id="4bf7b5d7bb6ffb009b717ad4751ce332fdd66afc" translate="yes" xml:space="preserve">
          <source>INFORMATION_SCHEMA.PLUGINS Table</source>
          <target state="translated">INFORMATION_SCHEMA.PLUGINS 테이블</target>
        </trans-unit>
        <trans-unit id="f2819c72b7dd2d1c07dc59ab9c2ea5a6591d270a" translate="yes" xml:space="preserve">
          <source>INGENIEUR</source>
          <target state="translated">INGENIEUR</target>
        </trans-unit>
        <trans-unit id="e7eb1f3fa97480d0a00295acb4acc566a473a87d" translate="yes" xml:space="preserve">
          <source>INI</source>
          <target state="translated">INI</target>
        </trans-unit>
        <trans-unit id="7d648a728a4737779ef7f4150b74bea727e228d6" translate="yes" xml:space="preserve">
          <source>INI Table Type</source>
          <target state="translated">INI 테이블 타입</target>
        </trans-unit>
        <trans-unit id="fd4d2f0d5aa850e30c0830c19e27d0fa4c65c7a7" translate="yes" xml:space="preserve">
          <source>INITIALLY</source>
          <target state="translated">INITIALLY</target>
        </trans-unit>
        <trans-unit id="88d86d54436967d4b4599d22d53c2a3db38390e6" translate="yes" xml:space="preserve">
          <source>INNER</source>
          <target state="translated">INNER</target>
        </trans-unit>
        <trans-unit id="17405a4822dd2e9bd239b579b9034a52cace3085" translate="yes" xml:space="preserve">
          <source>INNODB_CMP and INNODB_CMP_RESET</source>
          <target state="translated">INNODB_CMP 및 INNODB_CMP_RESET</target>
        </trans-unit>
        <trans-unit id="bf22d2b767d5719359b73693d1610cf97e773d60" translate="yes" xml:space="preserve">
          <source>INNODB_CMPMEM and INNODB_CMPMEM_RESET</source>
          <target state="translated">INNODB_CMPMEM 및 INNODB_CMPMEM_RESET</target>
        </trans-unit>
        <trans-unit id="a5839ab4bba88aabcc89c6eefe7171eeeb279d63" translate="yes" xml:space="preserve">
          <source>INNODB_CMP_PER_INDEX and INNODB_CMP_PER_INDEX_RESET</source>
          <target state="translated">INNODB_CMP_PER_INDEX 및 INNODB_CMP_PER_INDEX_RESET</target>
        </trans-unit>
        <trans-unit id="1c4cdb7355976e7613bf170c150d4d0061114b3d" translate="yes" xml:space="preserve">
          <source>INOUT</source>
          <target state="translated">INOUT</target>
        </trans-unit>
        <trans-unit id="397fff4a0e90aa11cdba9f0130429d20a47a5607" translate="yes" xml:space="preserve">
          <source>INSENSITIVE</source>
          <target state="translated">INSENSITIVE</target>
        </trans-unit>
        <trans-unit id="c20ea07e32d25c072a65368c234d6f5a88f4521a" translate="yes" xml:space="preserve">
          <source>INSERT</source>
          <target state="translated">INSERT</target>
        </trans-unit>
        <trans-unit id="38c1468afdea6a18230b8f7459ea2284e363ff50" translate="yes" xml:space="preserve">
          <source>INSERT - Default &amp;amp; Duplicate Values</source>
          <target state="translated">삽입-기본값 및 중복 값</target>
        </trans-unit>
        <trans-unit id="dece2b708ab1c86d202d1cc49ebff8921ddeb630" translate="yes" xml:space="preserve">
          <source>INSERT .. SELECT to move the data from `Staging` into the Fact table</source>
          <target state="translated">INSERT ..`Staging`에서 Fact 테이블로 데이터를 이동 시키려면 SELECT</target>
        </trans-unit>
        <trans-unit id="7e2a8c5b69b1e4e7c1c44ff32f1418469af24296" translate="yes" xml:space="preserve">
          <source>INSERT ... ON DUPLICATE KEY UPDATE</source>
          <target state="translated">INSERT ... 중복 키 업데이트시</target>
        </trans-unit>
        <trans-unit id="68e8b6e77a3c6ab22f6cebd56902806cf5eba3ad" translate="yes" xml:space="preserve">
          <source>INSERT ... ON DUPLICATE KEY UPDATE is a MariaDB/MySQL extension to the &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; statement that, if it finds a duplicate unique or primary key, will instead perform an &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;.</source>
          <target state="translated">INSERT ... ON DUPLICATE KEY UPDATE는 &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; 문에 대한 MariaDB / MySQL 확장 으로서 중복 된 고유 키 또는 기본 키를 발견하면 대신 &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; 를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="6cf006b32601c4612de63d359fc9a250351fdfa8" translate="yes" xml:space="preserve">
          <source>INSERT ... RETURNING</source>
          <target state="translated">INSERT ... 반환</target>
        </trans-unit>
        <trans-unit id="10d54df9c2893dd569999f279642caf49c896c15" translate="yes" xml:space="preserve">
          <source>INSERT ... RETURNING will be available in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1051-release-notes/&quot;&gt;MariaDB 10.5.1&lt;/a&gt;.</source>
          <target state="translated">INSERT ... RETURNING은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1051-release-notes/&quot;&gt;MariaDB 10.5.1&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="080740cf1b35e55dbf908da3ca0ef5a011adaafb" translate="yes" xml:space="preserve">
          <source>INSERT ... SELECT</source>
          <target state="translated">삽입 ... 선택</target>
        </trans-unit>
        <trans-unit id="c7211f40bb3b65ff1de7000933903b91b0538efb" translate="yes" xml:space="preserve">
          <source>INSERT Command</source>
          <target state="translated">INSERT 명령</target>
        </trans-unit>
        <trans-unit id="67f62edcf287a3b8cd8b604753788b31358bd6f9" translate="yes" xml:space="preserve">
          <source>INSERT DELAYED</source>
          <target state="translated">삽입 지연</target>
        </trans-unit>
        <trans-unit id="dd41181a6e11a7f83ef914618d083316c69f601b" translate="yes" xml:space="preserve">
          <source>INSERT DELAYED can't be used with table '%s' because it is locked with LOCK TABLES</source>
          <target state="translated">INSERT DELAYED는 LOCK TABLES로 잠겨 있기 때문에 '% s'테이블과 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="08b4369556b85bfce4ce0c4996d8f15b48c9a49c" translate="yes" xml:space="preserve">
          <source>INSERT Function</source>
          <target state="translated">삽입 기능</target>
        </trans-unit>
        <trans-unit id="0a43817f1a13899635aeefbe745c61fcdc603597" translate="yes" xml:space="preserve">
          <source>INSERT IGNORE</source>
          <target state="translated">INSERT IGNORE</target>
        </trans-unit>
        <trans-unit id="838d1a13079816f9d8b1d4d1057c1d8def37fbb0" translate="yes" xml:space="preserve">
          <source>INSERT IGNORE... SELECT is unsafe because the order in which rows are retrieved by the SELECT determines which (if any) rows are ignored. This order cannot be predicted and may differ on master and the slave.</source>
          <target state="translated">INSERT IGNORE ... SELECT는 행이 검색되는 순서에 따라 무시되는 행이 결정되므로 안전하지 않습니다. 이 순서는 예측할 수 없으며 마스터와 슬레이브에서 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39def9e477e9e43c866d2b48576b99bdfb662885" translate="yes" xml:space="preserve">
          <source>INSERT INTO Fact (.,.,.) VALUES (.,.,.), (.,.,.), ...; -- &quot;Batch insert&quot;</source>
          <target state="translated">팩트에 삽입 (.,.,.) 값 (.,.,.), (.,.,.), ...; - &quot;배치 인서트&quot;</target>
        </trans-unit>
        <trans-unit id="f3676ceb84f3f9001e22f4dc181475fba2792635" translate="yes" xml:space="preserve">
          <source>INSERT INTO Fact SELECT * FROM Staging; This INSERT..SELECT allows you to do other things, such as normalization. More later.</source>
          <target state="translated">팩트 선택에 삽입 * 스테이징; 이 INSERT..SELECT를 사용하면 정규화와 같은 다른 작업을 수행 할 수 있습니다. 더 늦게.</target>
        </trans-unit>
        <trans-unit id="c37ca177e55f25188cd6f24aa0630d437b63747d" translate="yes" xml:space="preserve">
          <source>INSERT ON DUPLICATE KEY UPDATE</source>
          <target state="translated">중복 키 업데이트에 대한 삽입</target>
        </trans-unit>
        <trans-unit id="e72502a4fb06d289d691a9af032a5549608dce20" translate="yes" xml:space="preserve">
          <source>INSERT SELECT</source>
          <target state="translated">삽입 선택</target>
        </trans-unit>
        <trans-unit id="e0b1035081b6b5d52e7db96f679e0c9faaddcf3b" translate="yes" xml:space="preserve">
          <source>INSERT and loading</source>
          <target state="translated">삽입 및 로딩</target>
        </trans-unit>
        <trans-unit id="2d331d2fd690f8ab95ecd42d9b2322936de5b2fc" translate="yes" xml:space="preserve">
          <source>INSERT batch size</source>
          <target state="translated">삽입 배치 크기</target>
        </trans-unit>
        <trans-unit id="508eecaec1ac99b7d53e6ce15dc1632045692e90" translate="yes" xml:space="preserve">
          <source>INSERT if no duplicate key is found, otherwise UPDATE</source>
          <target state="translated">중복 키가 없으면 INSERT, 그렇지 않으면 UPDATE</target>
        </trans-unit>
        <trans-unit id="b1a771698b31b06ad0f33444ef624e1225e4818c" translate="yes" xml:space="preserve">
          <source>INSERT into autoincrement field which is not the first part in the composed primary key is unsafe.</source>
          <target state="translated">구성된 기본 키의 첫 번째 부분이 아닌 자동 증분 필드에 삽입하는 것은 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc1c444a0a674f26aa69d22aea80532283b7688d" translate="yes" xml:space="preserve">
          <source>INSERT()</source>
          <target state="translated">INSERT()</target>
        </trans-unit>
        <trans-unit id="a6895ffa842c94a50a72686e0e27d886e22db783" translate="yes" xml:space="preserve">
          <source>INSERT, UPDATE and DELETE statements can be particularly heavy operations to perform, as all indexes need to be updated after each change. For this reason these changes are often buffered.</source>
          <target state="translated">INSERT, UPDATE 및 DELETE 문은 각 인덱스 변경 후에 모든 인덱스를 업데이트해야하므로 특히 수행해야하는 작업이 많을 수 있습니다. 이러한 이유로 이러한 변경 사항은 종종 버퍼링됩니다.</target>
        </trans-unit>
        <trans-unit id="44519d27508dc70f7a139b87f074cc019d2a47a3" translate="yes" xml:space="preserve">
          <source>INSERT... ON DUPLICATE KEY UPDATE on a table with more than one UNIQUE KEY is unsafe</source>
          <target state="translated">삽입 ... 둘 이상의 고유 키가있는 테이블에서 중복 키 업데이트시 안전하지 않음</target>
        </trans-unit>
        <trans-unit id="ab0d891e1242aaea4c9f12f0ca0d99cd5e2196f2" translate="yes" xml:space="preserve">
          <source>INSERT... SELECT... ON DUPLICATE KEY UPDATE is unsafe because the order in which rows are retrieved by the SELECT determines which (if any) rows are updated. This order cannot be predicted and may differ on master and the slave.</source>
          <target state="translated">INSERT ... SELECT ... ON DUPLICATE KEY UPDATE는 SELECT에 의해 행을 검색하는 순서에 따라 업데이트되는 행이 결정되므로 안전하지 않습니다. 이 순서는 예측할 수 없으며 마스터와 슬레이브에서 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04815baf1494bd34ef3f7d495f3e93886f4b2b24" translate="yes" xml:space="preserve">
          <source>INSERT...RETURNING</source>
          <target state="translated">INSERT...RETURNING</target>
        </trans-unit>
        <trans-unit id="b66af6add5248f6cc3d7ed7bd0f91811d8f20373" translate="yes" xml:space="preserve">
          <source>INSTALL PLUGIN</source>
          <target state="translated">플러그인 설치</target>
        </trans-unit>
        <trans-unit id="729ff8b60048c0b3c786bf33af9215cfec45e69b" translate="yes" xml:space="preserve">
          <source>INSTALL SONAME</source>
          <target state="translated">SONAME 설치</target>
        </trans-unit>
        <trans-unit id="4fc1395df84dfdf2f80f047198c1f3b574bb81e0" translate="yes" xml:space="preserve">
          <source>INSTALL SONAME has been supported since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5521-release-notes/&quot;&gt;MariaDB 5.5.21&lt;/a&gt;.</source>
          <target state="translated">INSTALL SONAME은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-5521-release-notes/&quot;&gt;MariaDB 5.5.21&lt;/a&gt; 부터 지원되었습니다 .</target>
        </trans-unit>
        <trans-unit id="77a997d245adbecfd4396dc5c027f2f010f50830" translate="yes" xml:space="preserve">
          <source>INSTALL {&lt;a href=&quot;../install-plugin/index&quot;&gt;PLUGIN&lt;/a&gt; | &lt;a href=&quot;../install-soname/index&quot;&gt;SONAME&lt;/a&gt;}</source>
          <target state="translated">설치 { &lt;a href=&quot;../install-plugin/index&quot;&gt;PLUGIN&lt;/a&gt; | &lt;a href=&quot;../install-soname/index&quot;&gt;SONAME&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="13a4119956adaaa86ae9cb982935d1c8ec924ed8" translate="yes" xml:space="preserve">
          <source>INSTALLDIR</source>
          <target state="translated">INSTALLDIR</target>
        </trans-unit>
        <trans-unit id="78c28743ff190a4db411b49fb89eb31bee325c93" translate="yes" xml:space="preserve">
          <source>INSTALLDIR\data</source>
          <target state="translated">INSTALLDIR\data</target>
        </trans-unit>
        <trans-unit id="11692ffcea3667492741cd536a6476281d35f3ea" translate="yes" xml:space="preserve">
          <source>INSTR</source>
          <target state="translated">INSTR</target>
        </trans-unit>
        <trans-unit id="1978e07eae288a50d2b53a0c90f951950a6ae0c2" translate="yes" xml:space="preserve">
          <source>INSTR()</source>
          <target state="translated">INSTR()</target>
        </trans-unit>
        <trans-unit id="793985cddb68d46ef51b688aecf85864c9e06813" translate="yes" xml:space="preserve">
          <source>INT</source>
          <target state="translated">INT</target>
        </trans-unit>
        <trans-unit id="fb26155faf1e6f97466da87a640b75b983fe6d3d" translate="yes" xml:space="preserve">
          <source>INT UNSIGNED with constants computed as unix timestamps.</source>
          <target state="translated">유닉스 타임 스탬프로 계산 된 상수를 가진 INT UNSIGNED.</target>
        </trans-unit>
        <trans-unit id="60e4eddac93ad49f5da9e6f5183ee8ab0ad147bd" translate="yes" xml:space="preserve">
          <source>INT UNSIGNED with constants for some non-time-based series.</source>
          <target state="translated">비 시간 계열 계열에 대한 상수로 INT UNSIGNED.</target>
        </trans-unit>
        <trans-unit id="6ef928726da8fe58f4e66fc244140c2bf0e00cef" translate="yes" xml:space="preserve">
          <source>INT/TINYINT/SMALLINT/BIGINT</source>
          <target state="translated">INT/TINYINT/SMALLINT/BIGINT</target>
        </trans-unit>
        <trans-unit id="d4310d7a6b5906db2b2a34d24641be6b8da8da66" translate="yes" xml:space="preserve">
          <source>INT1</source>
          <target state="translated">INT1</target>
        </trans-unit>
        <trans-unit id="a3a0ec55e3e26ee54417c786dfad5d709ecb7c40" translate="yes" xml:space="preserve">
          <source>INT2</source>
          <target state="translated">INT2</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
