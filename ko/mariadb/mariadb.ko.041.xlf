<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="mariadb">
    <body>
      <group id="mariadb">
        <trans-unit id="f5e0dabcbdfa9626c9bae104bad169c2e09699ce" translate="yes" xml:space="preserve">
          <source>The following statement assigns indexes from the tables t1, t2, and t3 to the key cache named hot_cache:</source>
          <target state="translated">다음 명령문은 테이블 t1, t2 및 t3의 인덱스를 hot_cache라는 키 캐시에 지정합니다.</target>
        </trans-unit>
        <trans-unit id="73b4403e76ee0c3a4755e8f725ee282d4170a9c1" translate="yes" xml:space="preserve">
          <source>The following statement deletes customer records with a customer key identification between 1001 and 1999:</source>
          <target state="translated">다음 명령문은 1001에서 1999 사이의 고객 키 식별을 가진 고객 레코드를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="6aa947ef6c6865c4e579a67c972cad0911123aec" translate="yes" xml:space="preserve">
          <source>The following statement drops the &lt;em&gt;orders&lt;/em&gt; table on the front end only:</source>
          <target state="translated">다음 문장은 &lt;em&gt;주문을&lt;/em&gt; 삭제합니다&lt;em&gt;&lt;/em&gt; 테이블을 프론트 엔드에서만 .</target>
        </trans-unit>
        <trans-unit id="9197af59c0677ec485f285e6fb3b39ea0cb8f351" translate="yes" xml:space="preserve">
          <source>The following statement drops the &lt;em&gt;sp_complex_variable&lt;/em&gt; procedure:</source>
          <target state="translated">다음 명령문은 &lt;em&gt;sp_complex_variable을&lt;/em&gt; 삭제합니다 &lt;em&gt;.&lt;/em&gt; 프로 시저를 .</target>
        </trans-unit>
        <trans-unit id="cbd210b45c5955c7f6a320b3bce2c21077ce9071" translate="yes" xml:space="preserve">
          <source>The following statement fails, as the increment conflicts with the defaults</source>
          <target state="translated">증분이 기본값과 충돌하므로 다음 명령문이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="46adbb7d13862b3fa3213495248c2a58db46acdb" translate="yes" xml:space="preserve">
          <source>The following statement inserts a row with all column values into the &lt;em&gt;customer&lt;/em&gt; table:</source>
          <target state="translated">다음 명령문은 모든 열 값이있는 행을 &lt;em&gt;고객에&lt;/em&gt; 삽입합니다.&lt;em&gt;&lt;/em&gt; 테이블에 합니다.</target>
        </trans-unit>
        <trans-unit id="8f4ad48e0d722e21b9f432fefb35d648052d6284" translate="yes" xml:space="preserve">
          <source>The following statement inserts two rows with all column values into the &lt;em&gt;customer&lt;/em&gt; table:</source>
          <target state="translated">다음 명령문은 모든 열 값을 가진 두 개의 행을 &lt;em&gt;customer&lt;/em&gt; 테이블에 삽입 합니다.</target>
        </trans-unit>
        <trans-unit id="c2bef2fbdee59d08a8ad2c282daf319d50389208" translate="yes" xml:space="preserve">
          <source>The following statement joins two tables: one is only used to satisfy a WHERE condition, but no row is deleted from it; rows from the other table are deleted, instead.</source>
          <target state="translated">다음 명령문은 두 테이블을 조인합니다. 하나는 WHERE 조건을 만족시키는 데만 사용되며 행은 삭제되지 않습니다. 다른 테이블의 행이 대신 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="74c0620dc5ff6f383bf102d299298e8bc58000f1" translate="yes" xml:space="preserve">
          <source>The following statement renames both the &lt;em&gt;orders&lt;/em&gt; table and &lt;em&gt;customer&lt;/em&gt; table:</source>
          <target state="translated">다음 명령문은 &lt;em&gt;orders&lt;/em&gt; 테이블과 &lt;em&gt;customer&lt;/em&gt; 테이블의 이름을 모두 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="e94fe48e75955ca1d72bb4a15be9dc2fd6bde3bf" translate="yes" xml:space="preserve">
          <source>The following statement returns 5 customer keys from the customer table beginning at offset 1000:</source>
          <target state="translated">다음 명령문은 오프셋 1000에서 시작하여 고객 테이블에서 5 개의 고객 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4f863ae3adca1549800d339574c78a431eab6e6e" translate="yes" xml:space="preserve">
          <source>The following statement returns NULL, as the given &lt;code&gt;next_value&lt;/code&gt; and &lt;code&gt;round&lt;/code&gt; is smaller than the current value.</source>
          <target state="translated">다음 &lt;code&gt;next_value&lt;/code&gt; 및 &lt;code&gt;round&lt;/code&gt; 가 현재 값보다 작으므로 다음 명령문은 NULL을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="36e3ea59cbefa55c73802e32aab3972f3599a1e0" translate="yes" xml:space="preserve">
          <source>The following statement returns all the &lt;em&gt;p_name rows&lt;/em&gt; in the &lt;em&gt;part&lt;/em&gt; table and the &lt;em&gt;partno&lt;/em&gt; table:</source>
          <target state="translated">문 반환 다음 모든 &lt;em&gt;p_name 행&lt;/em&gt; 의 &lt;em&gt;부품&lt;/em&gt; 테이블과 &lt;em&gt;PARTNO&lt;/em&gt; 테이블의 합니다.</target>
        </trans-unit>
        <trans-unit id="41230946244b931643d4608f5949108a8a8c3aa7" translate="yes" xml:space="preserve">
          <source>The following statement returns an ordered &lt;em&gt;shipmode&lt;/em&gt; column from the &lt;em&gt;lineitem&lt;/em&gt; table.</source>
          <target state="translated">다음 명령문은 &lt;em&gt;lineitem&lt;/em&gt; 테이블 에서 정렬 된 &lt;em&gt;shipmode&lt;/em&gt; 열을 리턴 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="da2d60c516803a6f422e8d16d8d008daa8f5b65c" translate="yes" xml:space="preserve">
          <source>The following statements are not deterministic, but are considered safe for binary logging and replication:</source>
          <target state="translated">다음 문은 결정적이지 않지만 이진 로깅 및 복제에 안전한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c8ed40d62d60460dbe0f1580b6b1f99df875acfd" translate="yes" xml:space="preserve">
          <source>The following statements are regarded as unsafe:</source>
          <target state="translated">다음 내용은 안전하지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="349a47b4d904d804733f0b71ba49e08a0b3c5c27" translate="yes" xml:space="preserve">
          <source>The following statements create and call the sp_complex_variable stored procedure:</source>
          <target state="translated">다음 명령문은 sp_complex_variable 저장 프로 시저를 작성하고 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7754b39214f1221b84a68e0740f3d74469fb9916" translate="yes" xml:space="preserve">
          <source>The following statements explicitly add conditions to the diagnostics area:</source>
          <target state="translated">다음 명령문은 진단 영역에 명시 적으로 조건을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0a3807465049a91967f6da87decfd86435bedef0" translate="yes" xml:space="preserve">
          <source>The following statements read contents from the diagnostics area:</source>
          <target state="translated">다음 내용은 진단 영역에서 내용을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="39636738cd71f03c7e125e91ecb92cb3c63627a0" translate="yes" xml:space="preserve">
          <source>The following status variables are useful in &lt;a href=&quot;../binary-log/index&quot;&gt;binary logging&lt;/a&gt; and &lt;a href=&quot;../replication/index&quot;&gt;replication&lt;/a&gt;. See &lt;a href=&quot;../server-status-variables/index&quot;&gt;Server Status Variables&lt;/a&gt; for a complete list of status variables that can be viewed with &lt;a href=&quot;../show-status/index&quot;&gt;SHOW STATUS&lt;/a&gt;.</source>
          <target state="translated">다음 상태 변수는 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로깅&lt;/a&gt; 및 &lt;a href=&quot;../replication/index&quot;&gt;복제에&lt;/a&gt; 유용 합니다 . &lt;a href=&quot;../show-status/index&quot;&gt;SHOW STATUS&lt;/a&gt; 로 볼 수있는 전체 상태 변수 목록은 &lt;a href=&quot;../server-status-variables/index&quot;&gt;서버 상태 변수&lt;/a&gt; 를 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="a1e0364a0f4a32e8cd640e70c10de6b854c060e9" translate="yes" xml:space="preserve">
          <source>The following steps can be used to perform a rolling upgrade between minor versions of MariaDB (for example from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10312-release-notes/&quot;&gt;MariaDB 10.3.12&lt;/a&gt; to &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10313-release-notes/&quot;&gt;MariaDB 10.3.13&lt;/a&gt;) when Galera Cluster is being used. In a rolling upgrade, each node is upgraded individually, so the cluster is always operational. There is no downtime from the application's perspective.</source>
          <target state="translated">Galera Cluster를 사용하는 경우 다음 단계를 사용하여 MariaDB 마이너 버전 (예 : &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10312-release-notes/&quot;&gt;MariaDB 10.3.12&lt;/a&gt; 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10313-release-notes/&quot;&gt;MariaDB 10.3.13&lt;/a&gt; ) 으로 롤링 업그레이드를 수행 할 수 있습니다 . 롤링 업그레이드에서는 각 노드가 개별적으로 업그레이드되므로 클러스터가 항상 작동합니다. 애플리케이션 관점에서 다운 타임이 없습니다.</target>
        </trans-unit>
        <trans-unit id="312250dfd1485b85d229b80251dff259c34d410a" translate="yes" xml:space="preserve">
          <source>The following steps can be used to perform a rolling upgrade from &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; to &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; when using Galera Cluster. In a rolling upgrade, each node is upgraded individually, so the cluster is always operational. There is no downtime from the application's perspective.</source>
          <target state="translated">다음 단계를 사용하여 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; 에서 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 로 롤링 업그레이드를 수행 할 수 있습니다.Galera Cluster를 사용할 때 . 롤링 업그레이드에서는 각 노드가 개별적으로 업그레이드되므로 클러스터가 항상 작동합니다. 애플리케이션 관점에서 다운 타임이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3be7e347b9f09fe6ba81d4ce6ad3000b482faffa" translate="yes" xml:space="preserve">
          <source>The following steps can be used to perform a rolling upgrade from &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; to &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; when using Galera Cluster. In a rolling upgrade, each node is upgraded individually, so the cluster is always operational. There is no downtime from the application's perspective.</source>
          <target state="translated">Galera Cluster를 사용할 때 다음 단계를 사용하여 &lt;a href=&quot;../what-is-mariadb-102/index&quot;&gt;MariaDB 10.2&lt;/a&gt; 에서 &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; 으로 롤링 업그레이드를 수행 할 수 있습니다 . 롤링 업그레이드에서는 각 노드가 개별적으로 업그레이드되므로 클러스터가 항상 작동합니다. 애플리케이션 관점에서 다운 타임이 없습니다.</target>
        </trans-unit>
        <trans-unit id="850ba0133997f192c79e427e3d5d8b4337a1812e" translate="yes" xml:space="preserve">
          <source>The following steps can be used to perform a rolling upgrade from &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; to &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt; when using Galera Cluster. In a rolling upgrade, each node is upgraded individually, so the cluster is always operational. There is no downtime from the application's perspective.</source>
          <target state="translated">다음 단계를 사용하여 &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; 에서 &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt; 로 롤링 업그레이드를 수행 할 수 있습니다.Galera Cluster를 사용할 때 . 롤링 업그레이드에서는 각 노드가 개별적으로 업그레이드되므로 클러스터가 항상 작동합니다. 애플리케이션 관점에서 다운 타임이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a7d7a63054386420840c1fd63979143c1cadc6ac" translate="yes" xml:space="preserve">
          <source>The following steps can be used to perform a rolling upgrade from MariaDB Galera Cluster 10.0 to &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt;. In a rolling upgrade, each node is upgraded individually, so the cluster is always operational. There is no downtime from the application's perspective.</source>
          <target state="translated">다음 단계를 사용하여 MariaDB Galera Cluster 10.0에서 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt; 로 롤링 업그레이드를 수행 할 수 있습니다 . 롤링 업그레이드에서는 각 노드가 개별적으로 업그레이드되므로 클러스터가 항상 작동합니다. 애플리케이션 관점에서 다운 타임이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5cec44dfe06dd7996b87ee16b97f82f8e8932f9a" translate="yes" xml:space="preserve">
          <source>The following steps can be used to perform a rolling upgrade from MariaDB Galera Cluster 5.5 to MariaDB Galera Cluster 10.0. In a rolling upgrade, each node is upgraded individually, so the cluster is always operational. There is no downtime from the application's perspective.</source>
          <target state="translated">다음 단계를 사용하여 MariaDB Galera Cluster 5.5에서 MariaDB Galera Cluster 10.0으로 롤링 업그레이드를 수행 할 수 있습니다. 롤링 업그레이드에서는 각 노드가 개별적으로 업그레이드되므로 클러스터가 항상 작동합니다. 애플리케이션 관점에서 다운 타임이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ddc7a6dce904df8c6fa21da550efde85be767380" translate="yes" xml:space="preserve">
          <source>The following steps outline installing and configuring the MariaDB ColumnStoreExporter to be available in the Spark runtime:</source>
          <target state="translated">다음 단계는 Spark 런타임에서 사용할 수 있도록 MariaDB ColumnStoreExporter 설치 및 구성에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3aea72204b2595221a5d1f952ba9600ca9a2f9df" translate="yes" xml:space="preserve">
          <source>The following steps outline installing and configuring the MariaDB Java Connector to be available to the spark runtime:</source>
          <target state="translated">다음 단계는 Spark 런타임에 사용할 수 있도록 MariaDB Java 커넥터 설치 및 구성을 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="28c6f0e1c70590b8e9e20fab9316ef9382e4b9d2" translate="yes" xml:space="preserve">
          <source>The following steps would need to be done beforehand:</source>
          <target state="translated">다음 단계를 미리 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="e94d2551b101fd940906ea2bde6950ab415e0194" translate="yes" xml:space="preserve">
          <source>The following storage engines are no longer maintained.</source>
          <target state="translated">다음 스토리지 엔진은 더 이상 유지 보수되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11fa9fee7cd381491a2378e274e632108636bddd" translate="yes" xml:space="preserve">
          <source>The following storage engines support export without &lt;code&gt;FLUSH TABLES ... FOR EXPORT&lt;/code&gt;, assuming the source server is down and the receiving server is not accessing the files during the copy.</source>
          <target state="translated">다음 스토리지 엔진은 &lt;code&gt;FLUSH TABLES ... FOR EXPORT&lt;/code&gt; 없이 내보내기를 지원 합니다. 소스 서버가 다운되었고 수신 서버가 복사 중에 파일에 액세스하지 않는다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c84cac8cc47f3ae8c651c710062fd64b1fb1982c" translate="yes" xml:space="preserve">
          <source>The following syntax show the conditions you can use when executing a condition against two columns. Note that the columns must be from the same table.</source>
          <target state="translated">다음 구문은 두 열에 대해 조건을 실행할 때 사용할 수있는 조건을 보여줍니다. 열은 동일한 테이블에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="ccd4c2b78376f8ee594f75136dd6747282d66c10" translate="yes" xml:space="preserve">
          <source>The following syntax show the conditions you can use when executing a join on two tables.</source>
          <target state="translated">다음 구문은 두 테이블에서 조인을 실행할 때 사용할 수있는 조건을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4ae6168d2aa4fcd89e11e2c7725947a6b445e2b5" translate="yes" xml:space="preserve">
          <source>The following system variables can also be configured on Unix:</source>
          <target state="translated">Unix에서도 다음 시스템 변수를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfeb968584d302ed9c1ae7b57cd0ba37a32aebdb" translate="yes" xml:space="preserve">
          <source>The following table describes the output from the running myisamchk with the &lt;em&gt;-dvv&lt;/em&gt; option:</source>
          <target state="translated">다음 표는 &lt;em&gt;-dvv&lt;/em&gt; 옵션 을 사용하여 실행중인 myisamchk의 출력을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="266d5cb0d329e920307f08725db71d37f0004465" translate="yes" xml:space="preserve">
          <source>The following table describes the output from the running myisamchk with the &lt;em&gt;-eiv&lt;/em&gt; option:</source>
          <target state="translated">다음 표는 &lt;em&gt;-eiv&lt;/em&gt; 옵션을 사용하여 myisamchk 실행 결과를 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="a983d08369c2943ff04331285e2a28ccfa4a756d" translate="yes" xml:space="preserve">
          <source>The following table lists each version of the &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; 2 wsrep provider, and it lists which version of MariaDB each one was first released in.</source>
          <target state="translated">다음 표는 &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; 2 wsrep 제공자 의 각 버전을 나열하고 각 버전 이 처음 릴리스 된 MariaDB의 버전을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="aed6c07372c03e564908fbee3cc6cf064b641c60" translate="yes" xml:space="preserve">
          <source>The following table lists each version of the &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; 3 wsrep provider, and it lists which version of MariaDB each one was first released in. If you would like to install &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; 3 using &lt;a href=&quot;../yum/index&quot;&gt;yum&lt;/a&gt;, &lt;a href=&quot;../installing-mariadb-deb-files/index#installing-mariadb-with-apt&quot;&gt;apt&lt;/a&gt;, or &lt;a href=&quot;../installing-mariadb-with-zypper/index&quot;&gt;zypper&lt;/a&gt;, then the package is called &lt;code&gt;galera&lt;/code&gt;.</source>
          <target state="translated">다음 표에는 &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; 3 wsrep 제공자 의 각 버전 과 각 릴리스가 처음 릴리스 된 MariaDB의 버전이 나열되어 있습니다. 설치하려는 경우&lt;a href=&quot;../galera/index&quot;&gt;&lt;/a&gt;&lt;a href=&quot;../yum/index&quot;&gt; yum&lt;/a&gt; , &lt;a href=&quot;../installing-mariadb-deb-files/index#installing-mariadb-with-apt&quot;&gt;apt&lt;/a&gt; 또는 &lt;a href=&quot;../installing-mariadb-with-zypper/index&quot;&gt;zypper를&lt;/a&gt; 사용하여 Galera 3 패키지를 &lt;code&gt;galera&lt;/code&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="a0d4029906c6cb0651bf2c4d6889b189cc78d2b2" translate="yes" xml:space="preserve">
          <source>The following table lists each version of the &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; 4 wsrep provider, and it lists which version of MariaDB each one was first released in. If you would like to install &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; 4 using &lt;a href=&quot;../yum/index&quot;&gt;yum&lt;/a&gt;, &lt;a href=&quot;../installing-mariadb-deb-files/index#installing-mariadb-with-apt&quot;&gt;apt&lt;/a&gt;, or &lt;a href=&quot;../installing-mariadb-with-zypper/index&quot;&gt;zypper&lt;/a&gt;, then the package is called &lt;code&gt;galera-4&lt;/code&gt;.</source>
          <target state="translated">다음 표에는 &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; 4 wsrep 제공자 의 각 버전 과 각 릴리스가 처음 릴리스 된 MariaDB의 버전이 나열되어 있습니다. &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; 를 설치하려는 경우&lt;a href=&quot;../yum/index&quot;&gt; yum&lt;/a&gt; , &lt;a href=&quot;../installing-mariadb-deb-files/index#installing-mariadb-with-apt&quot;&gt;apt&lt;/a&gt; 또는 &lt;a href=&quot;../installing-mariadb-with-zypper/index&quot;&gt;zypper를&lt;/a&gt; 사용하여 4 패키지를 &lt;code&gt;galera-4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80713e41b6a5a5964085773ac4586ab7c8fe944f" translate="yes" xml:space="preserve">
          <source>The following table lists the data definition statements (DDL) that differ from normal MariaDB &lt;a href=&quot;../data-definition/index&quot;&gt;DDL&lt;/a&gt; when used on ColumnStore tables.</source>
          <target state="translated">다음 표는 ColumnStore 테이블에서 사용될 때 일반 MariaDB &lt;a href=&quot;../data-definition/index&quot;&gt;DDL&lt;/a&gt; 과 다른 데이터 정의 명령문 (DDL)을 나열합니다 .</target>
        </trans-unit>
        <trans-unit id="cf984db7763a78103e73c01d5fd9053292e2588f" translate="yes" xml:space="preserve">
          <source>The following table lists the privileges that can be granted at the database level. You can also grant all table and function privileges at the database level. Table and function privileges on a database apply to all tables or functions in that database, including those created later.</source>
          <target state="translated">다음 표는 데이터베이스 레벨에서 부여 할 수있는 권한을 나열합니다. 데이터베이스 수준에서 모든 테이블 및 함수 권한을 부여 할 수도 있습니다. 데이터베이스에 대한 테이블 및 함수 권한은 나중에 생성 된 것을 포함하여 해당 데이터베이스의 모든 테이블 또는 함수에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c618ba56250436990b4b7bcff71ec86c2e59130a" translate="yes" xml:space="preserve">
          <source>The following table lists the privileges that can be granted globally. You can also grant all database, table, and function privileges globally. When granted globally, these privileges apply to all databases, tables, or functions, including those created later.</source>
          <target state="translated">다음 표는 전체적으로 부여 할 수있는 권한을 보여줍니다. 모든 데이터베이스, 테이블 및 함수 권한을 전체적으로 부여 할 수도 있습니다. 전역 적으로 부여 될 때 이러한 권한은 나중에 작성된 것을 포함하여 모든 데이터베이스, 테이블 또는 함수에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d67e0d4ee8c526189c3ef000182e0f91f909a2c2" translate="yes" xml:space="preserve">
          <source>The following table lists the various plugins included in MariaDB ordered by their maturity. Note that maturity will differ across MariaDB versions - see below for an easy way to get a complete list of plugins and their maturity in your version of MariaDB:</source>
          <target state="translated">다음 표는 MariaDB에 포함 된 다양한 플러그인을 해당 성숙도 순서대로 나열한 것입니다. 성숙도는 MariaDB 버전마다 다를 수 있습니다. 사용중인 MariaDB 버전에서 전체 플러그인 목록과 성숙도를 얻는 쉬운 방법은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="52bfd0821c97a83fdc7c7970a6ee595f802b91b5" translate="yes" xml:space="preserve">
          <source>The following table outlines the minimum recommended production server spec...</source>
          <target state="translated">다음 표는 최소 권장 프로덕션 서버 사양을 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0e02dd4bf7c321c9305ebb56262cbb4d5f809eee" translate="yes" xml:space="preserve">
          <source>The following table outlines the minimum recommended production server specifications which can be followed for both on premise and cloud deployments:</source>
          <target state="translated">다음 표에는 온 프레미스 및 클라우드 배포 모두에서 준수 할 수있는 최소 권장 프로덕션 서버 사양이 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="a80cf20e0c2602fc814468d30267fb7e4755816b" translate="yes" xml:space="preserve">
          <source>The following table shows a list of example account as sorted by these criteria:</source>
          <target state="translated">다음 표는 이러한 기준에 따라 정렬 된 예제 계정 목록을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ba91b0da9f8967eb4ff7003734bcbd4628bcfb8c" translate="yes" xml:space="preserve">
          <source>The following table shows how to represent the data in the binary format:</source>
          <target state="translated">다음 표는 이진 형식으로 데이터를 나타내는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="0558fab99f678408008da0a018fe7b4f55e41909" translate="yes" xml:space="preserve">
          <source>The following table shows the default list of stopwords, although you should always treat &lt;code&gt;storage/myisam/ft_static.c&lt;/code&gt; as the definitive list. See the &lt;a href=&quot;../fulltext-index-overview/index&quot;&gt;Fulltext Index Overview&lt;/a&gt; for more details, and &lt;a href=&quot;../full-text-indexes/index&quot;&gt;Full-text-indexes&lt;/a&gt; for related articles.</source>
          <target state="translated">&lt;code&gt;storage/myisam/ft_static.c&lt;/code&gt; 를 항상 최종 목록으로 취급해야하지만 다음 표는 기본 중지 단어 목록을 보여줍니다 . 자세한 내용은 &lt;a href=&quot;../fulltext-index-overview/index&quot;&gt;전체 텍스트 색인 개요&lt;/a&gt; 및 관련 기사의 &lt;a href=&quot;../full-text-indexes/index&quot;&gt;전체 텍스트 색인&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1e59ca38f4c09f793c24324beccd4be0cdcb7187" translate="yes" xml:space="preserve">
          <source>The following table shows the type and size of all the properties:</source>
          <target state="translated">다음 표는 모든 속성의 유형과 크기를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="43aefed96a12b8b4f53cfbec3c272ff1a68c107c" translate="yes" xml:space="preserve">
          <source>The following tables and data will be used in the examples that follow:</source>
          <target state="translated">다음 표와 데이터는 다음 예에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d0f98dc3074b6b1d2de5a34b0994a650c5144d58" translate="yes" xml:space="preserve">
          <source>The following tables comprise a database name &amp;lsquo;tpch2&amp;rsquo;:</source>
          <target state="translated">다음 표는 데이터베이스 이름 'tpch2'를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="e3b8f9a0f97ad75b5c3ab56e711e8afaa8c94e02" translate="yes" xml:space="preserve">
          <source>The following tables indicate the approximate data storage requirements for each data type.</source>
          <target state="translated">다음 표는 각 데이터 유형에 대한 대략적인 데이터 스토리지 요구 사항을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9831a01f20c4fdfdfcaaccd19ebba84a18b8fdee" translate="yes" xml:space="preserve">
          <source>The following technique can be used for any combination of</source>
          <target state="translated">다음 기술은 모든 조합에 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="8966822df71a36ee3a76151fc0de7ed932c3ab4e" translate="yes" xml:space="preserve">
          <source>The following theoretical file size and filesystem size limits apply to the three filesystems:</source>
          <target state="translated">다음의 이론적 파일 크기 및 파일 시스템 크기 제한은 세 파일 시스템에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c145ebc13b3faddcbd91de65f825cb53773c3a69" translate="yes" xml:space="preserve">
          <source>The following triggers are invoked:</source>
          <target state="translated">다음과 같은 트리거가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cee6d5fcc41e8790b0cfe78ae26dbcc0e89d91e5" translate="yes" xml:space="preserve">
          <source>The following two articles should help you get your Solaris machine prepared to build MariaDB (just ignore the parts about installing buildbot):</source>
          <target state="translated">다음 두 기사는 Solaris 머신이 MariaDB를 구축 할 수 있도록 준비하는 데 도움이됩니다 (빌드 봇 설치에 대한 부분은 무시하십시오).</target>
        </trans-unit>
        <trans-unit id="f2a6f6202bf2a1ec19c224a4391b6194a1836f40" translate="yes" xml:space="preserve">
          <source>The following types can't be used:</source>
          <target state="translated">다음 유형을 사용할 수 없습니다 :</target>
        </trans-unit>
        <trans-unit id="572a92d043acb9249a9a1da9a0a077946786b705" translate="yes" xml:space="preserve">
          <source>The following units are valid:</source>
          <target state="translated">다음 단위가 유효합니다.</target>
        </trans-unit>
        <trans-unit id="8bd858f5024be55dcd671b363a251a78fbd5fb81" translate="yes" xml:space="preserve">
          <source>The following variables are available when the &lt;a href=&quot;../spider/index&quot;&gt;Spider&lt;/a&gt; storage engine has been installed.</source>
          <target state="translated">&lt;a href=&quot;../spider/index&quot;&gt;거미&lt;/a&gt; 는 다음과 같은 변수를 사용할 수 있습니다 스토리지 엔진이 설치된 .</target>
        </trans-unit>
        <trans-unit id="f1b439169753637a7e24f83138ec24612f5470b2" translate="yes" xml:space="preserve">
          <source>The following variables are only available in the &lt;code&gt;COMMENT&lt;/code&gt; clause of the &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; statement when the &lt;a href=&quot;../spider/index&quot;&gt;Spider&lt;/a&gt; storage engine has been installed. Global variables can be overloaded at the table level using the DSN parameter. These variables are listed on the &lt;a href=&quot;../spider-server-system-variables/index&quot;&gt;Spider System Variables&lt;/a&gt; page.</source>
          <target state="translated">다음 변수는 &lt;a href=&quot;../spider/index&quot;&gt;Spider&lt;/a&gt; 스토리지 엔진이 설치된 경우 &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; 문의 &lt;code&gt;COMMENT&lt;/code&gt; 절 에서만 사용 가능합니다 . 전역 변수는 DSN 매개 변수를 사용하여 테이블 레벨에서 오버로드 될 수 있습니다. 이러한 변수는 &lt;a href=&quot;../spider-server-system-variables/index&quot;&gt;스파이더 시스템 변수&lt;/a&gt; 에 나열됩니다 페이지 .</target>
        </trans-unit>
        <trans-unit id="82273fcb7a1556492fcdae0c303b28a92ac5b96b" translate="yes" xml:space="preserve">
          <source>The following variables are used with MariaDB's &lt;a href=&quot;../performance-schema/index&quot;&gt;Performance Schema&lt;/a&gt;. See &lt;a href=&quot;../mysqld-options/index#performance-schema-options&quot;&gt;Performance Schema Options&lt;/a&gt; for Performance Schema options that are not system variables. See &lt;a href=&quot;../server-system-variables/index&quot;&gt;Server System Variables&lt;/a&gt; for a complete list of system variables and instructions on setting them.</source>
          <target state="translated">다음 변수는 MariaDB의 &lt;a href=&quot;../performance-schema/index&quot;&gt;성능 스키마&lt;/a&gt; 와 함께 사용됩니다 . 시스템 변수가 아닌 &lt;a href=&quot;../mysqld-options/index#performance-schema-options&quot;&gt;성능 스키마 옵션&lt;/a&gt; 에 대해서는 성능 스키마 옵션 을 참조하십시오 . &lt;a href=&quot;../server-system-variables/index&quot;&gt;서버 시스템 변수를&lt;/a&gt; 참조하십시오 의 전체 목록과 설정에 대한 지시 사항 를 .</target>
        </trans-unit>
        <trans-unit id="12d5936c83bcb23e465f04dd46123fdec2e0285b" translate="yes" xml:space="preserve">
          <source>The following variables can also be set by using &lt;em&gt;--var_name=value&lt;/em&gt;, for example &lt;em&gt;--ft_min_word_len=5&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;--var_name = value&lt;/em&gt; 를 사용하여 다음 변수를 설정할 수도 있습니다 ( 예 : &lt;em&gt;--ft_min_word_len = 5&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1a7ecc1e15d39135466956d7b24c380642ee5f9d" translate="yes" xml:space="preserve">
          <source>The following variables can be set while passed as commandline options to &lt;code&gt;myisampack&lt;/code&gt;, or set with a &lt;code&gt;[myisampack]&lt;/code&gt; section in your &lt;a href=&quot;../configuring-mariadb-with-mycnf/index&quot;&gt;my.cnf&lt;/a&gt; file.</source>
          <target state="translated">다음 변수는 명령 줄 옵션으로 &lt;code&gt;myisampack&lt;/code&gt; 에 전달 하거나 &lt;a href=&quot;../configuring-mariadb-with-mycnf/index&quot;&gt;my.cnf&lt;/a&gt; 의 &lt;code&gt;[myisampack]&lt;/code&gt; 섹션으로 설정할 수 있습니다 . 파일 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d4db22cf52b16fde495de7c44aa083be16e728f" translate="yes" xml:space="preserve">
          <source>The following variables can be set while passed as commandline options to aria_pack, or set in the [ariapack] section in your &lt;a href=&quot;../configuring-mariadb-with-mycnf/index&quot;&gt;my.cnf&lt;/a&gt; file.</source>
          <target state="translated">다음 변수는 명령 줄 옵션으로 aria_pack에 전달하거나 &lt;a href=&quot;../configuring-mariadb-with-mycnf/index&quot;&gt;my.cnf&lt;/a&gt; 의 [ariapack] 섹션에서 설정할 수 있습니다 . 파일 있습니다.</target>
        </trans-unit>
        <trans-unit id="504dd0277ab3f114fc4c10a604b6564ac9a6797f" translate="yes" xml:space="preserve">
          <source>The following variables can be set while passed as commandline options to aria_read_log, or set in the &lt;code&gt;[aria_read_log]&lt;/code&gt; section in your &lt;a href=&quot;../configuring-mariadb-with-mycnf/index&quot;&gt;my.cnf&lt;/a&gt; file.</source>
          <target state="translated">다음 변수는 명령 줄 옵션으로 aria_read_log에 전달하거나 &lt;a href=&quot;../configuring-mariadb-with-mycnf/index&quot;&gt;my.cnf&lt;/a&gt; 파일 의 &lt;code&gt;[aria_read_log]&lt;/code&gt; 섹션에서 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ec3e2e89e12443d49fd33c8e8aaa94f347c0467" translate="yes" xml:space="preserve">
          <source>The following variables in the &lt;em&gt;&lt;strong&gt;HashJoin&lt;/strong&gt;&lt;/em&gt; element in the Columnstore.xml configuration file relate to disk-based joins. Columnstore.xml resides in the etc directory for your installation(/usr/local/mariadb/columnstore/etc).</source>
          <target state="translated">Columnstore.xml 구성 파일 의 &lt;em&gt;&lt;strong&gt;HashJoin&lt;/strong&gt;&lt;/em&gt; 요소에있는 다음 변수는 디스크 기반 조인과 관련이 있습니다. Columnstore.xml은 설치 (/ usr / local / mariadb / columnstore / etc)의 etc 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cba8f836ee8bbf050a4a1da4d4be4afaae13cb6" translate="yes" xml:space="preserve">
          <source>The following window functions are supported:</source>
          <target state="translated">다음과 같은 창 기능이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7c98f76fea91780862e4f22aebe37f2a05a14557" translate="yes" xml:space="preserve">
          <source>The foreign data source you are trying to reference does not exist. Data source error: %s</source>
          <target state="translated">참조하려는 외부 데이터 소스가 없습니다. 데이터 소스 오류 : % s</target>
        </trans-unit>
        <trans-unit id="e9c56a431bc87d9fea6ef54fb14a8c9c3599b873" translate="yes" xml:space="preserve">
          <source>The foreign data wrapper also supports writes, so you should be able to write to the remote MariaDB table to migrate your PostgreSQL data. For example:</source>
          <target state="translated">외부 데이터 래퍼도 쓰기를 지원하므로 PostgreSQL 데이터를 마이그레이션하기 위해 원격 MariaDB 테이블에 쓸 수 있어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d773e15675d5820e8dfc01625142d80e0c6ca132" translate="yes" xml:space="preserve">
          <source>The foreign database reads the SQL statement and sends the result back through the mysql client API to the origin</source>
          <target state="translated">외부 데이터베이스는 SQL 문을 읽고 mysql 클라이언트 API를 통해 결과를 원본으로 다시 보냅니다.</target>
        </trans-unit>
        <trans-unit id="8dbaadbc8fdf7c88b5f28c6be837ed22d3c2a5b7" translate="yes" xml:space="preserve">
          <source>The foreign key columns and the referenced columns must be of the same type, or similar types. For integer types, the size and sign must also be the same.</source>
          <target state="translated">외래 키 열과 참조 열은 동일한 유형이거나 유사한 유형이어야합니다. 정수 유형의 경우 크기와 부호도 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="f151615f8b6df7fa702554913638fc391c8a9e9b" translate="yes" xml:space="preserve">
          <source>The foreign server name you are trying to reference does not exist. Data source error: %s</source>
          <target state="translated">참조하려는 외부 서버 이름이 없습니다. 데이터 소스 오류 : % s</target>
        </trans-unit>
        <trans-unit id="16eba4e72c58217557b879acef416bab8617da77" translate="yes" xml:space="preserve">
          <source>The foreign server, %s, you are trying to create already exists.</source>
          <target state="translated">작성하려는 외부 서버 % s이 (가) 이미 존재합니다.</target>
        </trans-unit>
        <trans-unit id="827084635dc70b219c5b1a4a69741d35459c1ba3" translate="yes" xml:space="preserve">
          <source>The format &amp;lsquo;*&amp;rsquo; indicates we want to see the Json documents. This small collection is:</source>
          <target state="translated">'*'형식은 Json 문서를보고 싶다는 것을 나타냅니다. 이 작은 컬렉션은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="137a128775d6d3c24b9504aa042d62c4cdf96219" translate="yes" xml:space="preserve">
          <source>The format &amp;lsquo;4&amp;rsquo; forces to write 4 decimals.</source>
          <target state="translated">'4'형식은 소수점 4 자리를 씁니다.</target>
        </trans-unit>
        <trans-unit id="1b8195df1a5a1c6f675a1e02e70db77b618dd9c0" translate="yes" xml:space="preserve">
          <source>The format for &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; events can be configured by setting the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#binlog_format&quot;&gt;binlog_format&lt;/a&gt;&lt;/code&gt; system variable. If you have the &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;SUPER&lt;/a&gt;&lt;/code&gt; privilege, then you can change it dynamically with &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그&lt;/a&gt; 이벤트 의 형식 은 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#binlog_format&quot;&gt;binlog_format&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정하여 구성 할 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;SUPER&lt;/a&gt;&lt;/code&gt; 권한 이 있으면 &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; 을 사용하여 동적으로 변경할 수 있습니다. . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2738a7bb7a28882976b90c73215b8ca8175dbc7" translate="yes" xml:space="preserve">
          <source>The format for storing &lt;a href=&quot;../identifier-names/index&quot;&gt;table names&lt;/a&gt; has changed</source>
          <target state="translated">&lt;a href=&quot;../identifier-names/index&quot;&gt;테이블 이름&lt;/a&gt; 저장 형식 이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="8281ca5e847cde910328b2897a783d1918bca355" translate="yes" xml:space="preserve">
          <source>The format indicating how a date is stored in the file.</source>
          <target state="translated">날짜가 파일에 저장되는 방법을 나타내는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="224472d4d2cee6775a714bdfaedf82a78e79cfec" translate="yes" xml:space="preserve">
          <source>The format of the ODBC Connection String is:</source>
          <target state="translated">ODBC 연결 문자열의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67145769d0a8d527d434f45157dc4cde03c036f9" translate="yes" xml:space="preserve">
          <source>The format of the realm depends on the specific authentication mechanism that is used. For example, the format would need to be &lt;code&gt;machine\\username&lt;/code&gt; for Windows users authenticating with NTLM.</source>
          <target state="translated">영역의 형식은 사용되는 특정 인증 메커니즘에 따라 다릅니다. 예를 들어 NTLM으로 인증하는 Windows 사용자의 경우 형식은 &lt;code&gt;machine\\username&lt;/code&gt; 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="54106b88e2704d0d68ae1f3328b87979405c3b23" translate="yes" xml:space="preserve">
          <source>The format specification of the column value itself.</source>
          <target state="translated">열 값 자체의 형식 스펙입니다.</target>
        </trans-unit>
        <trans-unit id="56124adb1b87c9547644c9ca88cf20f0c071eaad" translate="yes" xml:space="preserve">
          <source>The formatted &lt;code&gt;EXPLAIN&lt;/code&gt; will be shown. You can now click on various part to get more information about them.</source>
          <target state="translated">형식화 된 &lt;code&gt;EXPLAIN&lt;/code&gt; 이 표시됩니다. 이제 다양한 부분을 클릭하여 자세한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9669ce82e92cc5b6a77c857d7808e9a55c54273" translate="yes" xml:space="preserve">
          <source>The former depends on the query and the dataset. The latter is generally bigger when table records are on disk and/or are big, especially when they have &lt;a href=&quot;../blob/index&quot;&gt;blobs&lt;/a&gt;.</source>
          <target state="translated">전자는 쿼리와 데이터 집합에 따라 다릅니다. 후자는 일반적으로 테이블 레코드가 디스크에 있거나 큰 경우, 특히 &lt;a href=&quot;../blob/index&quot;&gt;blob&lt;/a&gt; 이있는 경우 더 큽니다 .</target>
        </trans-unit>
        <trans-unit id="bd9d05554d1edff8bbcecf02343f52543baf868c" translate="yes" xml:space="preserve">
          <source>The former example shows the difference between the &lt;code&gt;GROUP_CONCAT&lt;/code&gt;'s &lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt; (which sorts the concatenated hosts), and the &lt;code&gt;SELECT&lt;/code&gt;'s &lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt; (which sorts the rows).</source>
          <target state="translated">&lt;code&gt;GROUP_CONCAT&lt;/code&gt; 의 예는 GROUP_CONCAT 의 &lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt; (연결된 호스트를 정렬)와 &lt;code&gt;SELECT&lt;/code&gt; 의 &lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt; (행을 정렬 ) 의 차이점을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="f5a1910dc5bddc7ac3f93a60a5a7057499529142" translate="yes" xml:space="preserve">
          <source>The former is not advised for InnoDB. The latter is messy if you want an AUTO_INCREMENT.</source>
          <target state="translated">전자는 InnoDB에 대해서는 권장되지 않습니다. AUTO_INCREMENT를 원하면 후자가 지저분합니다.</target>
        </trans-unit>
        <trans-unit id="0bec4ce70038fa92a3702b59812a47a10df9bbf2" translate="yes" xml:space="preserve">
          <source>The forms that use &lt;em&gt;&lt;code&gt;FROM&lt;/code&gt;&lt;/em&gt; are standard SQL syntax.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;FROM&lt;/code&gt; &lt;/em&gt; 을 사용하는 양식 은 표준 SQL 구문입니다.</target>
        </trans-unit>
        <trans-unit id="0a4fa1f9995d415c56ca5d3f32ecd71d6eda0b86" translate="yes" xml:space="preserve">
          <source>The forms with a &lt;em&gt;&lt;code&gt;len&lt;/code&gt;&lt;/em&gt; argument return a substring &lt;em&gt;&lt;code&gt;len&lt;/code&gt;&lt;/em&gt; characters long from string &lt;em&gt;&lt;code&gt;str&lt;/code&gt;&lt;/em&gt;, starting at position &lt;em&gt;&lt;code&gt;pos&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;len&lt;/code&gt; &lt;/em&gt; 인수가 있는 양식은 &lt;em&gt; &lt;code&gt;pos&lt;/code&gt; &lt;/em&gt; 위치에서 시작하여 문자열 &lt;em&gt; &lt;code&gt;str&lt;/code&gt; &lt;/em&gt; 에서 긴 부분 문자열 &lt;em&gt; &lt;code&gt;len&lt;/code&gt; &lt;/em&gt; 문자를 리턴합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="929c207e49f6c1a544de8e8692fff3c3c04e5da7" translate="yes" xml:space="preserve">
          <source>The forms without a &lt;em&gt;&lt;code&gt;len&lt;/code&gt;&lt;/em&gt; argument return a substring from string &lt;em&gt;&lt;code&gt;str&lt;/code&gt;&lt;/em&gt; starting at position &lt;em&gt;&lt;code&gt;pos&lt;/code&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;len&lt;/code&gt; &lt;/em&gt; 인수가 없는 양식은 &lt;em&gt; &lt;code&gt;pos&lt;/code&gt; &lt;/em&gt; 위치에서 시작 하는 문자열 &lt;em&gt; &lt;code&gt;str&lt;/code&gt; &lt;/em&gt; 에서 하위 문자열을 리턴합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1ca3c436923fb767d00d038bd1c5e130695ba7f" translate="yes" xml:space="preserve">
          <source>The formula is reasonably precise. It is usually within 1% of the correct value; rarely off by 2%.</source>
          <target state="translated">공식은 상당히 정확합니다. 일반적으로 올바른 값의 1 % 이내입니다. 드물게 2 % 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="dc1255fb579e56e355393b709adf9f05181c8508" translate="yes" xml:space="preserve">
          <source>The four main external table types &amp;ndash; odbc, jdbc, mongo and mysql &amp;ndash; are specified giving the following information:</source>
          <target state="translated">odbc, jdbc, mongo 및 mysql의 네 가지 기본 외부 테이블 유형이 지정되어 다음 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b4af0fcec447c06ad11a56ddc88e3d20305d7c93" translate="yes" xml:space="preserve">
          <source>The fourth number preserves temporal uniqueness in case the timestamp value loses monotonicity (for example, due to daylight saving time).</source>
          <target state="translated">네 번째 숫자는 타임 스탬프 값이 단조 로움을 잃는 경우 (예 : 일광 절약 시간으로 인해) 시간 고유성을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="8324bc6c4e8314d7b0170f76fc5a4cebdd322538" translate="yes" xml:space="preserve">
          <source>The frequency of group commits can be changed by configuring the &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#binlog_commit_wait_usec&quot;&gt;binlog_commit_wait_usec&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#binlog_commit_wait_count&quot;&gt;binlog_commit_wait_count&lt;/a&gt;&lt;/code&gt; system variables, which were introduced in &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;.</source>
          <target state="translated">그룹 커밋 빈도는 &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0에&lt;/a&gt; 도입 된 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#binlog_commit_wait_usec&quot;&gt;binlog_commit_wait_usec&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#binlog_commit_wait_count&quot;&gt;binlog_commit_wait_count&lt;/a&gt;&lt;/code&gt; 시스템 변수 를 구성하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b90f037ca8ef3765964f90996e3ec43476f8d3ea" translate="yes" xml:space="preserve">
          <source>The frm image that was returned by &lt;code&gt;read_frm_image()&lt;/code&gt; must be freed with the &lt;strong&gt;free_frm_image()&lt;/strong&gt;.</source>
          <target state="translated">리턴 한 FRM 화상 &lt;code&gt;read_frm_image()&lt;/code&gt; 으로 해제해야 &lt;strong&gt;free_frm_image ()&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8710aa19153ec3c2c56a39c431cf901fd1cf6391" translate="yes" xml:space="preserve">
          <source>The fstab file must be set up (/etc/fstab). These entries would need to be added to each PM pointing to the all the dbroot(s) being used on all PMs. The 'noauto' option indicates that all dbroots will be associated to every PM but will not be automatically mounted at server startup. The associated dbroots that are assigned to each PM will be specifically mounted to that PM at Columnstore startup.</source>
          <target state="translated">fstab 파일을 설정해야합니다 (/ etc / fstab). 이러한 항목은 모든 PM에서 사용되는 모든 dbroot를 가리키는 각 PM에 추가해야합니다. 'noauto'옵션은 모든 dbroot가 모든 PM에 연결되지만 서버 시작시 자동으로 마운트되지는 않음을 나타냅니다. 각 PM에 지정된 관련 dbroot는 Columnstore 시작시 해당 PM에 특별히 마운트됩니다.</target>
        </trans-unit>
        <trans-unit id="e8495ea9d292b37a8a2355b502f028ec03249659" translate="yes" xml:space="preserve">
          <source>The fstab file on all Performance Modules must include all of the external mounts, all with the 'noauto' option specified. ColumnStore will manage the mounting and unmounting.</source>
          <target state="translated">모든 성능 모듈의 fstab 파일에는 'noauto'옵션이 지정된 모든 외부 마운트가 포함되어야합니다. ColumnStore는 마운트 및 마운트 해제를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="100c8e72bfb3bff4e61bdfee6f84c44ffa3dbf60" translate="yes" xml:space="preserve">
          <source>The full current date.</source>
          <target state="translated">전체 현재 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="d34be87b78afded9d5a7b8cbedc21d0dc2fd041f" translate="yes" xml:space="preserve">
          <source>The full fingerprint of the new key is: &lt;code&gt;177F 4010 FE56 CA33 3630 0305 F165 6F24 C74C D1D8&lt;/code&gt;</source>
          <target state="translated">새 키의 전체 지문은 다음과 같습니다. &lt;code&gt;177F 4010 FE56 CA33 3630 0305 F165 6F24 C74C D1D8&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f35d104ecc9e7915515aa423469b240730aefa72" translate="yes" xml:space="preserve">
          <source>The full format of &quot;&lt;code&gt;ip=&lt;/code&gt;&quot; is: &quot;&lt;code&gt;ip=[interface]:[IP_address]:[netmask]:[gateway]&lt;/code&gt;&quot;</source>
          <target state="translated">&quot; &lt;code&gt;ip=&lt;/code&gt; &quot; 의 전체 형식 은 다음과 같습니다. &quot; &lt;code&gt;ip=[interface]:[IP_address]:[netmask]:[gateway]&lt;/code&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="865e192fe54ea1c3b3438586f598ca9ca1fd3240" translate="yes" xml:space="preserve">
          <source>The full list of options are listed below. One or more MyISAM tables can be specified. MyISAM tables have an associated .MYI index file, and the table name can either be specified with or without the .MYI extension. Referencing it with the extension allows you to use wildcards, so it's possible to run myisamchk on &lt;em&gt;all&lt;/em&gt; the MyISAM tables in the database with &lt;code&gt;*.MYI&lt;/code&gt;.</source>
          <target state="translated">전체 옵션 목록이 아래에 나열되어 있습니다. 하나 이상의 MyISAM 테이블을 지정할 수 있습니다. MyISAM 테이블에는 연관된 .MYI 인덱스 파일이 있으며 테이블 이름은 .MYI 확장자를 사용하거나 사용하지 않고 지정할 수 있습니다. 확장명으로 참조하면 와일드 카드를 사용할 수 있으므로 &lt;code&gt;*.MYI&lt;/code&gt; 를 사용하여 데이터베이스의 &lt;em&gt;모든&lt;/em&gt; MyISAM 테이블에서 myisamchk를 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ecc17669fb64bc437c4d68ea8a8a72d5920b7e7" translate="yes" xml:space="preserve">
          <source>The full list of server variables are listed in the contents on this page, and most are described on this page, but some are described elsewhere:</source>
          <target state="translated">서버 변수의 전체 목록은이 페이지의 내용에 나열되어 있으며 대부분이 페이지에 설명되어 있지만 일부는 다른 곳에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4495fa844ae9e2d2aaead81fdad104832311e746" translate="yes" xml:space="preserve">
          <source>The full list of status variables are listed in the contents on this page; most are described on this page, but some are described elsewhere:</source>
          <target state="translated">상태 변수의 전체 목록은이 페이지의 내용에 나열되어 있습니다. 대부분이 페이지에서 설명되지만 일부는 다른 곳에서 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="ef0f493d835d5e056fd07d5b4bdf295341ae4b55" translate="yes" xml:space="preserve">
          <source>The full month name.</source>
          <target state="translated">월 이름입니다.</target>
        </trans-unit>
        <trans-unit id="018712c558a914f0dfc89aa0470a5b4f3797da35" translate="yes" xml:space="preserve">
          <source>The full path and filename for the extent file, multiple extents for the same column can point to this file with different BLOCK_OFFSETs</source>
          <target state="translated">익스텐트 파일의 전체 경로 및 파일 이름, 동일한 열의 여러 익스텐트는 다른 BLOCK_OFFSET을 사용하여이 파일을 가리킬 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4128cdcdbd2fb025a38113580789b8a118a1f371" translate="yes" xml:space="preserve">
          <source>The full script to create the release in an out-of-source build with Visual Studio with signed binaries might look like:</source>
          <target state="translated">서명 된 바이너리가있는 Visual Studio를 사용하여 소스 외부 빌드에서 릴리스를 작성하는 전체 스크립트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3e3c8f0ba87c8e1c74b620e43fcea6ae09060be" translate="yes" xml:space="preserve">
          <source>The full syntax is as follows:</source>
          <target state="translated">전체 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b51466328b798d6a78784f34893285f445b7ad01" translate="yes" xml:space="preserve">
          <source>The full syntax is like this:</source>
          <target state="translated">전체 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7684fc43b0cdcc7ae8d199296dd367f71ffaf533" translate="yes" xml:space="preserve">
          <source>The full weekday name.</source>
          <target state="translated">평일 전체 이름.</target>
        </trans-unit>
        <trans-unit id="c860a9082dcd30ead7fb60355e3b765f86d80464" translate="yes" xml:space="preserve">
          <source>The full year (that is, 1996 could be entered as &quot;96&quot; but displayed as &amp;ldquo;1996&amp;rdquo;).</source>
          <target state="translated">1 년 (1996 년은 &quot;96&quot;으로 입력 할 수 있지만 &quot;1996&quot;으로 표시 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="14175f0051299b8228a44e3d8c4312ad974a9b75" translate="yes" xml:space="preserve">
          <source>The fulltext index is then only reorganized when an &lt;a href=&quot;../optimize-table/index&quot;&gt;OPTIMIZE TABLE&lt;/a&gt; statement is underway. The related &lt;a href=&quot;../information-schema-innodb_ft_being_deleted-table/index&quot;&gt;INNODB_FT_BEING_DELETED&lt;/a&gt; table contains rows being deleted while an &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; is in the process of running.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;../optimize-table/index&quot;&gt;OPTIMIZE TABLE&lt;/a&gt; 문이 진행 중일 때만 전체 텍스트 색인이 재구성됩니다 . 관련 &lt;a href=&quot;../information-schema-innodb_ft_being_deleted-table/index&quot;&gt;INNODB_FT_BEING_DELETED&lt;/a&gt; 테이블에는 &lt;code&gt;OPTIMIZE TABLE&lt;/code&gt; 이 실행중인 동안 삭제중인 행이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7620aafb1a5d7aa4b601b7c6b2bd0c0502fa2840" translate="yes" xml:space="preserve">
          <source>The fulltext index will be &lt;code&gt;2&lt;/code&gt;. The primary key is index &lt;code&gt;0&lt;/code&gt;, and the unique key index &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">전체 텍스트 색인은 &lt;code&gt;2&lt;/code&gt; 입니다. 기본 키는 인덱스 &lt;code&gt;0&lt;/code&gt; 이고 고유 키 인덱스 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="93de7c15aa38587a3e80e0032a378274462ccf69" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;now()&lt;/code&gt; will be executed by MariaDB and it returned value sent to the ODBC table.</source>
          <target state="translated">&lt;code&gt;now()&lt;/code&gt; 함수 는 MariaDB에 의해 실행되며 ODBC 테이블로 전송 된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f6aca330e35c9ecc222b9dc74d4b029901a086ad" translate="yes" xml:space="preserve">
          <source>The function &lt;em&gt;JsonGet_Real&lt;/em&gt; can be given a third argument to specify the number of decimal digits of the returned value. For instance:</source>
          <target state="translated">&lt;em&gt;JsonGet_Real&lt;/em&gt; 함수 에는 리턴 값의 10 진수 수를 지정하는 세 번째 인수가 제공 될 수 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="972c0f4f15f087d5bc3b5f4896ce577d35a4f40b" translate="yes" xml:space="preserve">
          <source>The function &lt;em&gt;mcs_add&lt;/em&gt; can then be used. Verify that it can be used both in the select list and where clause for correct installation:</source>
          <target state="translated">그런 다음 &lt;em&gt;mcs_add&lt;/em&gt; 함수를 &lt;em&gt;사용할&lt;/em&gt; 수 있습니다. 올바른 설치를 위해 select list 및 where 절에서 모두 사용할 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="31288f623ce7967cac5350fc4f9ae158404ac377" translate="yes" xml:space="preserve">
          <source>The function follows the case sensitivity rules of the effective &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;collation&lt;/a&gt;. Matching is performed case insensitively for case insensitive collations, and case sensitively for case sensitive collations and for binary data.</source>
          <target state="translated">이 함수는 효과적인 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;데이터 정렬&lt;/a&gt; 의 대소 문자 구분 규칙을 따릅니다 . 대 / 소문자를 구분하지 않는 데이터 정렬의 경우 대 / 소문자를 구분하지 않고 대 / 소문자를 구분하는 데이터 정렬과 이진 데이터를 대 / 소문자를 구분하여 대 / 소문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="f9d34c8e9613d8f53518466ba95f3aaacb6dac5b" translate="yes" xml:space="preserve">
          <source>The function highlights the specified keywords in the target text by surrounding each keyword with &lt;code&gt;&amp;lt;span class=&quot;keyword&quot;&amp;gt;...&amp;lt;/span&amp;gt;&lt;/code&gt;, and escaping special HTML characters such as &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수는 각 키워드를 &lt;code&gt;&amp;lt;span class=&quot;keyword&quot;&amp;gt;...&amp;lt;/span&amp;gt;&lt;/code&gt; 로 묶고 &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; 와 같은 특수 HTML 문자를 이스케이프 하여 대상 텍스트에서 지정된 키워드를 강조 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="6852e0a5cf62dad97db2b009b26e7292865ae919" translate="yes" xml:space="preserve">
          <source>The function is not designed for use with dates before the advent of the Gregorian calendar in October 1582. Results will not be reliable since it doesn't account for the lost days when the calendar changed from the Julian calendar.</source>
          <target state="translated">이 기능은 1582 년 10 월에 그레고리력이 출현하기 전의 날짜와 함께 사용하도록 설계되지 않았습니다. 달력이 율리우스 력에서 변경되었을 때 잃어버린 날을 고려하지 않기 때문에 결과는 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d3c47319ae8cb97433706ea3e20f314c8f566e8f" translate="yes" xml:space="preserve">
          <source>The function name and class must be registered in order to be recognized and used by the ColumnStore primitive processor. This is done by adding a line to perform the registration in the &lt;em&gt;UDFSDK::UDFMap()&lt;/em&gt; function in the file &lt;strong&gt;udfsdk.cpp&lt;/strong&gt;:</source>
          <target state="translated">ColumnStore 기본 프로세서가 인식하고 사용하려면 함수 이름 및 클래스를 등록해야합니다. 이것은에 등록을 수행하기 위해 줄을 추가하여 수행 &lt;em&gt;UDFSDK :: UDFMap ()&lt;/em&gt; 파일의 기능 &lt;strong&gt;udfsdk.cpp&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="8b770fa4a617544b5f6ddc8071af0dce3141735b" translate="yes" xml:space="preserve">
          <source>The function name must be '&lt;code&gt;sphinx_snippets&lt;/code&gt;', you can not use an arbitrary name. Function arguments are as follows:</source>
          <target state="translated">함수 이름은 ' &lt;code&gt;sphinx_snippets&lt;/code&gt; ' 여야하며 , 임의의 이름을 사용할 수 없습니다. 함수 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f1c94bc68168cb3a34603350f0a6b276302cd22" translate="yes" xml:space="preserve">
          <source>The function returns &lt;code&gt;1&lt;/code&gt; if the SQL executes successfully, or &lt;code&gt;0&lt;/code&gt; if it fails.</source>
          <target state="translated">이 함수는 SQL이 성공적으로 실행되면 &lt;code&gt;1&lt;/code&gt; 을 , 실패하면 &lt;code&gt;0&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca730c4259d33ac5da4fae177ce4dac5ff009fc1" translate="yes" xml:space="preserve">
          <source>The function returns YES/NO or Error code</source>
          <target state="translated">이 함수는 YES / NO 또는 오류 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="60ef3389a83650b766bc56c94623ddb0b9c2bb61" translate="yes" xml:space="preserve">
          <source>The function returns a list of partitions whose minimum and maximum values for the column 'col_name' fall completely within the range of 'start_value' and 'end_value'. For example:</source>
          <target state="translated">이 함수는 'col_name'열의 최소값과 최대 값이 'start_value'및 'end_value'범위에 완전히 속하는 파티션 목록을 리턴합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3aec6ef43167f08e3fce4bdae3032d577bc40978" translate="yes" xml:space="preserve">
          <source>The function returns a pointer to a string of characters, as entered by the user. It may be stored in &lt;code&gt;buf&lt;/code&gt; or allocated with &lt;code&gt;malloc()&lt;/code&gt;.</source>
          <target state="translated">이 함수는 사용자가 입력 한대로 문자열에 대한 포인터를 반환합니다. &lt;code&gt;buf&lt;/code&gt; 에 저장 되거나 &lt;code&gt;malloc()&lt;/code&gt; 할당 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e911cfd5f3fbfe1f052ffaa063943cb8b0fe46c" translate="yes" xml:space="preserve">
          <source>The function returns:</source>
          <target state="translated">이 함수는 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f55c8ecdcdf21d5430ad9bb97db4362af7114c73" translate="yes" xml:space="preserve">
          <source>The function takes the following arguments:</source>
          <target state="translated">이 함수는 다음과 같은 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0c802523654614c7658d3013b30da9ba3c31a7b0" translate="yes" xml:space="preserve">
          <source>The function that created (or tried to create) a table (temporary or non-temporary) has just ended.</source>
          <target state="translated">테이블 (임시 또는 비 임시)을 작성 (또는 작성하려고 시도) 한 기능이 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="83b1f0872c002be62d819ca954d1fc9204fab43d" translate="yes" xml:space="preserve">
          <source>The function will find the nearest items, up to Limit that meet the Condition. But it will give up at Max distance. (If you are at the South Pole, why bother searching very far for the tenth pizza parlor?)</source>
          <target state="translated">이 기능은 조건에 맞는 최대 한도에서 가장 가까운 항목을 찾습니다. 그러나 그것은 최대 거리에서 포기할 것입니다. (당신이 남극에 있다면 왜 열 번째 피자 가게를 찾는 데 귀찮게합니까?)</target>
        </trans-unit>
        <trans-unit id="7321a8ab9f21516ff480eb6ae9235895dda8a068" translate="yes" xml:space="preserve">
          <source>The functionality of &lt;code&gt;mysql_install_db.exe&lt;/code&gt; is comparable with the shell script &lt;code&gt;mysql_install_db&lt;/code&gt; used on Unix, however it has been extended with both Windows specific functionality (creating a Windows service) and to generally useful functionality. For example, it can set the 'root' user password during database creation. It also creates the &lt;code&gt;my.ini&lt;/code&gt; configuration file in the data directory and adds most important parameters to it (e.g port).</source>
          <target state="translated">&lt;code&gt;mysql_install_db.exe&lt;/code&gt; 의 기능은 Unix에서 사용되는 쉘 스크립트 &lt;code&gt;mysql_install_db&lt;/code&gt; 와 비교할 수 있지만 Windows 전용 기능 (Windows 서비스 작성)과 일반적으로 유용한 기능으로 확장되었습니다. 예를 들어, 데이터베이스 작성 중에 '루트'사용자 비밀번호를 설정할 수 있습니다. 또한 데이터 디렉토리에 &lt;code&gt;my.ini&lt;/code&gt; 구성 파일을 작성하고 가장 중요한 매개 변수 (예 : 포트)를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c1d0ca3e2a67a8a2510ef97d9788afa41ddbb30f" translate="yes" xml:space="preserve">
          <source>The functions described in &lt;a href=&quot;../creating-user-defined-functions/index&quot;&gt;Creating User-defined Functions&lt;/a&gt; are expanded on this page. They are declared as follows:</source>
          <target state="translated">이 페이지에서 &lt;a href=&quot;../creating-user-defined-functions/index&quot;&gt;사용자 정의 기능 생성에&lt;/a&gt; 설명 된 기능 이 확장되었습니다. 다음과 같이 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="50b0c3a91e416c783f51719091c9f775f262c05e" translate="yes" xml:space="preserve">
          <source>The gap can be a single index value, multiple index values, or not exist at all depending on the contents of the index.</source>
          <target state="translated">간격은 단일 인덱스 값이거나 여러 인덱스 값이거나 인덱스의 내용에 따라 전혀 존재하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="853b9dfbe821ae3a5ce731dcc73a8c26469ac98a" translate="yes" xml:space="preserve">
          <source>The general idea behind the &lt;code&gt;FirstMatch&lt;/code&gt; strategy is the same as the one behind the &lt;code&gt;IN-&amp;gt;EXISTS&lt;/code&gt; transformation, however, &lt;code&gt;FirstMatch&lt;/code&gt; has several advantages:</source>
          <target state="translated">&lt;code&gt;FirstMatch&lt;/code&gt; 전략 의 기본 개념 은 &lt;code&gt;IN-&amp;gt;EXISTS&lt;/code&gt; 변환의 개념과 동일하지만 &lt;code&gt;FirstMatch&lt;/code&gt; 에는 몇 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="efd6702b52975aae002fee6afcde50c44b14f8c1" translate="yes" xml:space="preserve">
          <source>The general log will be written into the &lt;a href=&quot;../mysqlgeneral_log-table/index&quot;&gt;general_log&lt;/a&gt; table, and the slow query log will be written into the &lt;a href=&quot;../mysqlslow_log-table/index&quot;&gt;slow_log&lt;/a&gt; table. Only a limited set of operations are supported for those special tables. For example, direct DML statements (like &lt;code&gt;INSERT&lt;/code&gt;) on those tables will fail with an error similar to the following:</source>
          <target state="translated">일반 로그는 &lt;a href=&quot;../mysqlgeneral_log-table/index&quot;&gt;general_log&lt;/a&gt; 테이블에 기록되고 느린 쿼리 로그는 &lt;a href=&quot;../mysqlslow_log-table/index&quot;&gt;slow_log&lt;/a&gt; 테이블에 기록됩니다 . 해당 특수 테이블에 대해 제한된 조작 세트 만 지원됩니다. 예를 들어, 해당 테이블의 직접 DML 문 (예 : &lt;code&gt;INSERT&lt;/code&gt; )은 다음과 유사한 오류로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a6af7f978e150f0580aee4b208eca50a85eb0950" translate="yes" xml:space="preserve">
          <source>The general query log and the slow query log can be written into system tables</source>
          <target state="translated">일반 쿼리 로그 및 느린 쿼리 로그를 시스템 테이블에 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="adcbf583dee246a94c3fa4290266c31564e43a84" translate="yes" xml:space="preserve">
          <source>The general query log can either be written to a file on disk, or it can be written to the &lt;code&gt;&lt;a href=&quot;../mysqlgeneral_log-table/index&quot;&gt;general_log&lt;/a&gt;&lt;/code&gt; table in the &lt;code&gt;&lt;a href=&quot;../the-mysql-database-tables/index&quot;&gt;mysql&lt;/a&gt;&lt;/code&gt; database. To choose the general query log output destination, set the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_output&quot;&gt;log_output&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">일반 쿼리 로그는 디스크의 파일에 작성되거나 &lt;code&gt;&lt;a href=&quot;../the-mysql-database-tables/index&quot;&gt;mysql&lt;/a&gt;&lt;/code&gt; 데이터베이스 의 &lt;code&gt;&lt;a href=&quot;../mysqlgeneral_log-table/index&quot;&gt;general_log&lt;/a&gt;&lt;/code&gt; 테이블에 작성 될 수 있습니다 . 일반 조회 로그 출력 대상을 선택하려면 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_output&quot;&gt;log_output&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="2cfa424ac37b52306a2a4315ec25db1f17b75c7d" translate="yes" xml:space="preserve">
          <source>The general query log can either be written to the &lt;code&gt;&lt;a href=&quot;../mysqlgeneral_log-table/index&quot;&gt;general_log&lt;/a&gt;&lt;/code&gt; table in the &lt;code&gt;&lt;a href=&quot;../the-mysql-database-tables/index&quot;&gt;mysql&lt;/a&gt;&lt;/code&gt; database by setting the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_output&quot;&gt;log_output&lt;/a&gt;&lt;/code&gt; system variable to &lt;code&gt;TABLE&lt;/code&gt;. It can be changed dynamically with &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_output&quot;&gt;log_output&lt;/a&gt;&lt;/code&gt; 시스템 변수를 &lt;code&gt;TABLE&lt;/code&gt; 로 설정하여 일반 쿼리 로그를 &lt;code&gt;&lt;a href=&quot;../the-mysql-database-tables/index&quot;&gt;mysql&lt;/a&gt;&lt;/code&gt; 데이터베이스 의 &lt;code&gt;&lt;a href=&quot;../mysqlgeneral_log-table/index&quot;&gt;general_log&lt;/a&gt;&lt;/code&gt; 테이블에 쓸 수 있습니다 . &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; 을 사용 하여 동적으로 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e0babeafa62df4415ade4223b083785b2be90cf" translate="yes" xml:space="preserve">
          <source>The general query log is a log of every SQL query received from a client, as well as each client connect and disconnect. Since it's a record of every query received by the server, it can grow large quite quickly.</source>
          <target state="translated">일반 쿼리 로그는 클라이언트에서 수신 한 모든 SQL 쿼리와 각 클라이언트 연결 및 연결 해제에 대한 로그입니다. 서버가 수신 한 모든 쿼리에 대한 레코드이므로 매우 빠르게 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f176c0033b5d24dd912b192bb7d7f307ac4fbfb" translate="yes" xml:space="preserve">
          <source>The general query log is disabled by default.</source>
          <target state="translated">일반 쿼리 로그는 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed143e4d5b562da8ab9ddd21b3abb41ced504c1c" translate="yes" xml:space="preserve">
          <source>The general query log is output to a file by default. However, it can be explicitly chosen by setting the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_output&quot;&gt;log_output&lt;/a&gt;&lt;/code&gt; system variable to &lt;code&gt;FILE&lt;/code&gt;. It can be changed dynamically with &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">일반 조회 로그는 기본적으로 파일로 출력됩니다. 그러나 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#log_output&quot;&gt;log_output&lt;/a&gt;&lt;/code&gt; 시스템 변수를 다음과 같이 설정하여 명시 적으로 선택할 수 있습니다. &lt;code&gt;FILE&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; 을 사용 하여 동적으로 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ecc93b0ef6019f452aebca613c58030ef1a490ab" translate="yes" xml:space="preserve">
          <source>The general steps for compiling MariaDB are:</source>
          <target state="translated">MariaDB를 컴파일하는 일반적인 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2bab0d4f17439d374021f74ec94560db725346fb" translate="yes" xml:space="preserve">
          <source>The generated data population script that can immediately be executed against a database, saved for the future use or edited in the internal editor.</source>
          <target state="translated">데이터베이스에 대해 즉시 실행할 수 있고 나중에 사용하기 위해 저장하거나 내부 편집기에서 편집 할 수있는 생성 된 데이터 채우기 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="593c9dc021f4f4ff99f0c6503dc744be74243282" translate="yes" xml:space="preserve">
          <source>The given path can specify all operators for arrays except the &amp;ldquo;expand&amp;rdquo; [X] operator (or from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1028-release-notes/&quot;&gt;MariaDB 10.2.8&lt;/a&gt;, the&amp;ldquo;expand&amp;rdquo; [*] operator). For instance:</source>
          <target state="translated">주어진 경로는 &quot;확장&quot;[X] 연산자를 제외한 배열의 모든 연산자를 지정할 수 있습니다. &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1028-release-notes/&quot;&gt;&lt;/a&gt; &quot;확장&quot;[*] 연산자 인 MariaDB 10.2.8 )를 . 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="679bf6927eae57507d0a2cac5f5b98aec84d2229" translate="yes" xml:space="preserve">
          <source>The given path is synonymous with the Windows syntax for accessing the physical drive.</source>
          <target state="translated">지정된 경로는 실제 드라이브에 액세스하기위한 Windows 구문과 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="39d850746dfee22a75eaf68eac449aa5afd8124b" translate="yes" xml:space="preserve">
          <source>The global server time zone can also be changed dynamically by setting the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#time_zone&quot;&gt;time_zone&lt;/a&gt;&lt;/code&gt; system variable as a user account that has the &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;SUPER&lt;/a&gt;&lt;/code&gt; privilege. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../server-system-variables/index#time_zone&quot;&gt;time_zone&lt;/a&gt;&lt;/code&gt; 시스템 변수를 &lt;code&gt;&lt;a href=&quot;../grant/index#global-privileges&quot;&gt;SUPER&lt;/a&gt;&lt;/code&gt; 가있는 사용자 계정으로 설정하여 글로벌 서버 시간대를 동적으로 변경할 수도 있습니다. 권한 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="823479356975e2cbde10b52e2e895961fc643133" translate="yes" xml:space="preserve">
          <source>The global server time zone can be changed at server startup by setting the &lt;code&gt;--default-time-zone&lt;/code&gt; option either on the command-line or in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. For example:</source>
          <target state="translated">명령 줄 또는 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 &lt;code&gt;--default-time-zone&lt;/code&gt; 옵션 을 설정하여 서버 시작시 전역 서버 시간대를 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="70b4108652bef58ab77f46e2fe2fcc43f7757987" translate="yes" xml:space="preserve">
          <source>The goal is to look only at records &quot;close&quot;, in both directions, to the target lat/lng.</source>
          <target state="translated">목표는 목표 위도 / 경도로 두 방향으로 &quot;가까운&quot;레코드 만 보는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a9877ef466c7245cc092978d658c99813ea25a22" translate="yes" xml:space="preserve">
          <source>The goal is to touch only the relevant rows, not all the rows leading up to the desired rows. This is nicely achieved, except for building links to the &quot;next 5 pages&quot;. That may (or may not) be efficiently resolved by the simple SELECT id, discussed above. The reason that may not be efficient deals with the WHERE clause.</source>
          <target state="translated">목표는 원하는 행으로 이어지는 모든 행이 아니라 관련 행만 터치하는 것입니다. 이것은 &quot;다음 5 페이지&quot;에 대한 링크를 구축하는 것을 제외하고는 훌륭하게 달성됩니다. 그것은 위에서 논의 된 간단한 SELECT id에 의해 효율적으로 해결 될 수있다. 효율적이지 않은 이유는 WHERE 절을 다루는 것입니다.</target>
        </trans-unit>
        <trans-unit id="29706205bd9bb1108ed53abbe0283d7d733a4df2" translate="yes" xml:space="preserve">
          <source>The goal of the subquery cache is to optimize the evaluation of correlated subqueries by storing results together with correlation parameters in a cache and avoiding re-execution of the subquery in cases where the result is already in the cache.</source>
          <target state="translated">서브 쿼리 캐시의 목표는 결과를 캐시에 상관 매개 변수와 함께 저장하고 결과가 이미 캐시에있는 경우 서브 쿼리의 재실행을 피함으로써 상관 서브 쿼리의 평가를 최적화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="54273b9b6a4f4252db136447abe7386d7f9f0fbf" translate="yes" xml:space="preserve">
          <source>The granted privilege.</source>
          <target state="translated">부여 된 권한.</target>
        </trans-unit>
        <trans-unit id="c705c34b812bd840b03cb4a3e48fa89198d128cd" translate="yes" xml:space="preserve">
          <source>The gssapi authentication plugin uses the GSSAPI interface to authenticate with Kerberos or NTLM.</source>
          <target state="translated">gssapi 인증 플러그인은 GSSAPI 인터페이스를 사용하여 Kerberos 또는 NTLM으로 인증합니다.</target>
        </trans-unit>
        <trans-unit id="8520531bfefad3c817efdd7999eefd63e28dbb97" translate="yes" xml:space="preserve">
          <source>The gtid-list may be the empty string, in which case MASTER_GTID_WAIT() returns immediately. If the gtid-list contains fewer domains than &lt;a href=&quot;../global-transaction-id/index#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;, then only those domains are waited upon. If gtid-list contains a domain that is not present in @@gtid_slave_pos, then MASTER_GTID_WAIT() will wait until an event containing such domain_id arrives on the slave (or until timed out or killed).</source>
          <target state="translated">gtid-list는 빈 문자열 일 수 있으며,이 경우 MASTER_GTID_WAIT ()는 즉시 반환합니다. gtid-list에 &lt;a href=&quot;../global-transaction-id/index#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt; 보다 적은 도메인이 포함 된 경우 경우 해당 도메인 만 대기합니다. gtid-list에 @@ gtid_slave_pos에없는 도메인이 포함 된 경우 MASTER_GTID_WAIT ()는 해당 domain_id를 포함하는 이벤트가 슬레이브에 도착할 때까지 (또는 시간 초과 또는 종료 될 때까지) 대기합니다.</target>
        </trans-unit>
        <trans-unit id="be576e6a70414609452185c34ddc8fa7393a2aa2" translate="yes" xml:space="preserve">
          <source>The gtid_binlog_pos variable</source>
          <target state="translated">gtid_binlog_pos 변수</target>
        </trans-unit>
        <trans-unit id="45a0e2f6affbc859dd404aaaf8659050f5edfecc" translate="yes" xml:space="preserve">
          <source>The handler doesn't support autoextend of tablespaces</source>
          <target state="translated">핸들러는 테이블 스페이스 자동 확장을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e93a46a776c6951344a9852afac0478942b1ac7b" translate="yes" xml:space="preserve">
          <source>The handlers in effect at any point is part of each thread's runtime state, so we need to push and pop handlers in the sp_rcontext during execution. We use special instructions for this: - sp_instr_hpush_jump Push a handler. The instruction contains the necessary information, like which conditions we handle and the location of the handler. The jump takes us to the location after the handler code. - sp_instr_hpop Pop the handlers of the current frame (which we are just leaving).</source>
          <target state="translated">어느 시점에서나 유효한 핸들러는 각 스레드의 런타임 상태의 일부이므로 실행 중에 sp_rcontext에서 핸들러를 푸시하고 팝해야합니다. 우리는 이것을 위해 특별한 지시를 사용합니다 :-sp_instr_hpush_jump 핸들러를 푸시하십시오. 이 명령에는 처리하는 조건 및 처리기의 위치와 같은 필요한 정보가 포함되어 있습니다. 점프는 핸들러 코드 뒤의 위치로 이동합니다. -sp_instr_hpop 현재 프레임의 핸들러를 방금 팝합니다.</target>
        </trans-unit>
        <trans-unit id="1ba8dcf2d0c8a7d3ee9256335c7cd2a0e486d215" translate="yes" xml:space="preserve">
          <source>The have sets the &lt;code&gt;replicate_do_db&lt;/code&gt; variable to &lt;code&gt;main_database&lt;/code&gt; for the connection named &lt;code&gt;main_connection&lt;/code&gt;. All other connections will use the value &lt;code&gt;other_database&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;main_connection&lt;/code&gt; 이라는 연결에 대해 &lt;code&gt;replicate_do_db&lt;/code&gt; 변수를 &lt;code&gt;main_database&lt;/code&gt; 로 설정했습니다 . 다른 모든 연결은 &lt;code&gt;other_database&lt;/code&gt; 값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="b92160fca253065695eb2d419c210b4bb99df6fa" translate="yes" xml:space="preserve">
          <source>The header File &lt;code&gt;my_global.h&lt;/code&gt;:</source>
          <target state="translated">헤더 파일 &lt;code&gt;my_global.h&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4573fffce1326a09bfa4252ff1b94557bfe810e9" translate="yes" xml:space="preserve">
          <source>The header File tabfic.h:</source>
          <target state="translated">헤더 파일 tabfic.h :</target>
        </trans-unit>
        <trans-unit id="62796483408eaf22d3938f54e3e3548969d8a435" translate="yes" xml:space="preserve">
          <source>The header is at the beginning of the file.</source>
          <target state="translated">헤더는 파일의 시작 부분에 있습니다.</target>
        </trans-unit>
        <trans-unit id="aac0faa8cf3e7b9a80ec4d9892682d972c85e618" translate="yes" xml:space="preserve">
          <source>The header is at the end of the file.</source>
          <target state="translated">헤더는 파일의 끝에 있습니다.</target>
        </trans-unit>
        <trans-unit id="93c1d96ca7b68b31d6b7355fa4d28f8433ee3799" translate="yes" xml:space="preserve">
          <source>The header is in a separate file.</source>
          <target state="translated">헤더는 별도의 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d26f02917e9117dbfcc9a0761334e329b4795bd" translate="yes" xml:space="preserve">
          <source>The help command displays supported commands. You can view brief help definitions or verbose definitions. You can also enter partial command names with the help command to view verbose definitions.</source>
          <target state="translated">help 명령은 지원되는 명령을 표시합니다. 간단한 도움말 정의 또는 자세한 정의를 볼 수 있습니다. help 명령으로 부분 명령 이름을 입력하여 자세한 정의를 볼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="53096435824119e85c3327a436e8f5a6e6e68d35" translate="yes" xml:space="preserve">
          <source>The help is provided with the MariaDB server and makes use of four help tables found in the &lt;code&gt;mysql&lt;/code&gt; database: &lt;a href=&quot;../mysqlhelp_relation-table/index&quot;&gt;help_relation&lt;/a&gt;, &lt;a href=&quot;../mysqlhelp_topic-table/index&quot;&gt;help_topic&lt;/a&gt;, &lt;a href=&quot;../mysqlhelp_category-table/index&quot;&gt;help_category&lt;/a&gt; and &lt;a href=&quot;../mysqlhelp_keyword-table/index&quot;&gt;help_keyword&lt;/a&gt;. These tables are populated by the &lt;code&gt;mysql_install_db&lt;/code&gt; or &lt;code&gt;fill_help_table.sql&lt;/code&gt; scripts which, until &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1047-release-notes/&quot;&gt;MariaDB 10.4.7&lt;/a&gt;, contain data generated from an old version of MySQL.</source>
          <target state="translated">도움말은 MariaDB 서버와 함께 제공되며 &lt;code&gt;mysql&lt;/code&gt; 데이터베이스 에있는 &lt;a href=&quot;../mysqlhelp_relation-table/index&quot;&gt;help_relation&lt;/a&gt; , &lt;a href=&quot;../mysqlhelp_topic-table/index&quot;&gt;help_topic&lt;/a&gt; , &lt;a href=&quot;../mysqlhelp_category-table/index&quot;&gt;help_category&lt;/a&gt; 및 &lt;a href=&quot;../mysqlhelp_keyword-table/index&quot;&gt;help_keyword&lt;/a&gt; 의 네 가지 도움말 테이블을 사용 합니다. 이 테이블은 &lt;code&gt;mysql_install_db&lt;/code&gt; 또는 &lt;code&gt;fill_help_table.sql&lt;/code&gt; 스크립트 로 채워지며 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1047-release-notes/&quot;&gt;MariaDB 10.4.7&lt;/a&gt; 까지는 이전 버전의 MySQL에서 생성 된 데이터를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="44f1ea3ee6728cc805435d24d73ad990905bae65" translate="yes" xml:space="preserve">
          <source>The high level components of the ColumnStore architecture are:</source>
          <target state="translated">ColumnStore 아키텍처의 고급 구성 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a980280657dfe88f8a27bb1505f69c2c6444535f" translate="yes" xml:space="preserve">
          <source>The high level steps involved in performing a full backup of MariaDB ColumnStore are:</source>
          <target state="translated">MariaDB ColumnStore의 전체 백업 수행과 관련된 고급 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a51138ac8229cfc1d7ad75a54f380547f0bf1975" translate="yes" xml:space="preserve">
          <source>The high level steps involved in restoring a backup are:</source>
          <target state="translated">백업 복원과 관련된 고급 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37cc66c44e69c2207f271452c8c986cc30b0b105" translate="yes" xml:space="preserve">
          <source>The high priority queue gets the remaining 11 threads.</source>
          <target state="translated">우선 순위가 높은 큐는 나머지 11 개의 스레드를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0041bdc5ffd5ad6d87ef1f3ce9d9c6ca192cf6d6" translate="yes" xml:space="preserve">
          <source>The history of FederatedX is derived from the History of Federated. Cisco needed a MySQL storage engine that would allow them to consolidate remote tables on some sort of routing device, being able to interact with these remote tables as if they were local to the device, but not actually on the device, since the routing device had only so much storage space. The first prototype of the Federated Storage Engine was developed by JD (need to check on this- Brian Aker can verify) using the HANDLER interface. Brian handed the code to Patrick Galbraith and explained how it needed to work, and with Brian and Monty's tutelage and Patrick had a working Federated Storage Engine with MySQL 5.0. Eventually, Federated was released to the public in a MySQL 5.0 release.</source>
          <target state="translated">FederatedX의 역사는 Federated History에서 파생됩니다. Cisco는 라우팅 장치가 있기 때문에 마치 로컬 장치처럼 로컬 장치처럼 원격 테이블과 상호 작용할 수있는 일종의 라우팅 장치에서 원격 테이블을 통합 할 수있는 MySQL 스토리지 엔진이 필요했습니다. 너무 많은 저장 공간. Federated Storage Engine의 첫 번째 프로토 타입은 HANDLER 인터페이스를 사용하여 JD (Brian Aker가 확인할 수 있음)에 의해 개발되었습니다. Brian은 코드를 Patrick Galbraith에게 전달하고 어떻게 작동해야하는지 설명했고 Brian과 Monty의지도와 Patrick은 MySQL 5.0과 연동하는 Federated Storage Engine을 사용했습니다. 결국 Federated는 MySQL 5.0 릴리스에서 공개되었습니다.</target>
        </trans-unit>
        <trans-unit id="02a640fc863773252fb21a772fb2e321bed5c134" translate="yes" xml:space="preserve">
          <source>The holds will prevent you from upgrading MariaDB, so when you want to remove the holds, open a terminal, become root with '&lt;code&gt;sudo -s&lt;/code&gt;', and then enter the following:</source>
          <target state="translated">보류는 MariaDB를 업그레이드하지 못하게하므로 보류를 제거하려면 터미널을 열고 ' &lt;code&gt;sudo -s&lt;/code&gt; '로 루트가 된 후 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="dad702743c2eeff201c869822011c6a70a34d666" translate="yes" xml:space="preserve">
          <source>The home of HandlerSocket is &lt;a href=&quot;https://github.com/DeNA/HandlerSocket-Plugin-for-MySQL&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">HandlerSocket의 홈은 &lt;a href=&quot;https://github.com/DeNA/HandlerSocket-Plugin-for-MySQL&quot;&gt;여기에 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5843e4022cf2af6872e3fe7ab8b5f71757294af" translate="yes" xml:space="preserve">
          <source>The hope is that a newbie can quickly get up to speed, and his/her INDEXes will no longer smack of &quot;newbie&quot;.</source>
          <target state="translated">희망은 초보자가 빨리 속도를 낼 수 있고, 그 / 그녀의 INDEX가 더 이상 &quot;초보자&quot;를 no 지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="8d601d53a46cb9667f01afaeb659435946998569" translate="yes" xml:space="preserve">
          <source>The host name of the local host to use for making a TCP/IP connection to the local server. By default, the connection is made to localhost using a Unix socket file.</source>
          <target state="translated">로컬 서버에 TCP / IP 연결을 작성하는 데 사용할 로컬 호스트의 호스트 이름입니다. 기본적으로 Unix 소켓 파일을 사용하여 localhost에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="c5acabcf61d51ec222dbfb0cb585857aef7bdee1" translate="yes" xml:space="preserve">
          <source>The host of the server, a name or an IP address.</source>
          <target state="translated">서버의 호스트, 이름 또는 IP 주소</target>
        </trans-unit>
        <trans-unit id="b2b03716ac6567f9c0cf9eab7406ae73b353fa12" translate="yes" xml:space="preserve">
          <source>The host or user argument to GRANT is too long</source>
          <target state="translated">GRANT에 대한 호스트 또는 사용자 인수가 너무 깁니다</target>
        </trans-unit>
        <trans-unit id="dbe24c84076d1c574b2b89fa68578ac44e8c617b" translate="yes" xml:space="preserve">
          <source>The host the client is connected to.</source>
          <target state="translated">클라이언트가 연결된 호스트.</target>
        </trans-unit>
        <trans-unit id="c4be57bb2749a8092b6a6c6abf62f9d90183a276" translate="yes" xml:space="preserve">
          <source>The host_cache table contains the following columns:</source>
          <target state="translated">host_cache 테이블에는 다음 열이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1db27d81c66953e63b7d15391e182ee5faa4c7ba" translate="yes" xml:space="preserve">
          <source>The hostnames of each interface on each node (optional).</source>
          <target state="translated">각 노드에서 각 인터페이스의 호스트 이름입니다 (선택 사항).</target>
        </trans-unit>
        <trans-unit id="2f940ce10a066e24d2cfa8d2935b188179498fe8" translate="yes" xml:space="preserve">
          <source>The hour information is regarded as 12-hour format if a &amp;ldquo;t&amp;rdquo; or &amp;ldquo;tt&amp;rdquo; element follows the &amp;ldquo;hh&amp;rdquo; element in the format or as 24-hour format otherwise.</source>
          <target state="translated">&quot;t&quot;또는 &quot;tt&quot;요소가 형식에서 &quot;hh&quot;요소 뒤에 오는 경우 시간 정보는 12 시간 형식으로 간주되고 그렇지 않으면 24 시간 형식으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6a256f93449bc0d37b5c3fab583369bf020c471c" translate="yes" xml:space="preserve">
          <source>The id field is close enough to datetime-ordered to be used instead of datetime.</source>
          <target state="translated">id 필드는 datetime 대신 사용할 수 있도록 datetime-order에 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="1bb35cdae4da80966300d1c075a0289a3969f6ce" translate="yes" xml:space="preserve">
          <source>The id field is unique</source>
          <target state="translated">id 필드는 고유합니다</target>
        </trans-unit>
        <trans-unit id="bd7a95fbe0fa5db94a12411b19e6e6b44594ac49" translate="yes" xml:space="preserve">
          <source>The id of our GPG public key is &lt;code&gt;0xcbcb082a1bb943db&lt;/code&gt;. The short form of the id is &lt;code&gt;0x1BB943DB&lt;/code&gt;. The full key fingerprint is:</source>
          <target state="translated">GPG 공개 키의 id는 &lt;code&gt;0xcbcb082a1bb943db&lt;/code&gt; 입니다. ID의 짧은 형식은 &lt;code&gt;0x1BB943DB&lt;/code&gt; 입니다. 전체 키 지문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43e1981653586a80f8edbc97b8528ef4b4fb7a18" translate="yes" xml:space="preserve">
          <source>The idea</source>
          <target state="translated">아이디어</target>
        </trans-unit>
        <trans-unit id="fe5c6e0b59101942f4ad256b337844434631b8c7" translate="yes" xml:space="preserve">
          <source>The idea and the original code of the segmented key cache was provided by Fredrik Nylander from Stardoll.com. The code was extensively reworked, improved, and eventually merged into MariaDB by Igor Babaev from Monty Program (now MariaDB Corporation).</source>
          <target state="translated">세그먼트 키 캐시의 아이디어와 원래 코드는 Stardoll.com의 Fredrik Nylander가 제공했습니다. 이 코드는 광범위하게 재 작업되고 개선되었으며 Monty Program (현재 MariaDB Corporation)의 Igor Babaev에 의해 MariaDB에 통합되었습니다.</target>
        </trans-unit>
        <trans-unit id="c53092e852a6dc4b8d4886c9711798de1e26dc07" translate="yes" xml:space="preserve">
          <source>The idea behind index condition pushdown</source>
          <target state="translated">인덱스 조건 푸시 다운 배후의 아이디어</target>
        </trans-unit>
        <trans-unit id="3ed049cb7931da0e7cdf2b526d045f907eeda2b7" translate="yes" xml:space="preserve">
          <source>The idea here is to first load a set of Fact records into a &quot;staging table&quot;, with the following characteristics (at least):</source>
          <target state="translated">여기서 아이디어는 먼저 다음과 같은 특성을 가진 일련의 팩트 레코드를 &quot;스테이징 테이블&quot;에로드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="110659f468cf493615043191b41e80d65c732de2" translate="yes" xml:space="preserve">
          <source>The idea here is to have a sliding window of &lt;a href=&quot;../managing-mariadb-partitioning/index&quot;&gt;partitions&lt;/a&gt;. Let's say you need to purge news articles after 30 days. The &quot;partition key&quot; would be the &lt;a href=&quot;../datetime/index&quot;&gt;datetime&lt;/a&gt; (or &lt;a href=&quot;../timestamp/index&quot;&gt;timestamp&lt;/a&gt;) that is to be used for purging, and the PARTITIONs would be &quot;range&quot;. Every night, a cron job would come along and build a new partition for the next day, and drop the oldest partition.</source>
          <target state="translated">여기서 아이디어는 &lt;a href=&quot;../managing-mariadb-partitioning/index&quot;&gt;파티션&lt;/a&gt; 의 슬라이딩 윈도우를 갖는 것 입니다. 30 일 후에 뉴스 기사를 제거해야한다고 가정 해 봅시다. &quot;파티션 키&quot;는 제거에 사용될 &lt;a href=&quot;../datetime/index&quot;&gt;날짜 / 시간&lt;/a&gt; (또는 &lt;a href=&quot;../timestamp/index&quot;&gt;타임 스탬프&lt;/a&gt; )이며 PARTITION은 &quot;범위&quot;입니다. 매일 밤 크론 작업이 와서 다음 날 새 파티션을 만들고 가장 오래된 파티션을 삭제했습니다.</target>
        </trans-unit>
        <trans-unit id="ff656da172ecb4992b5c69c2e1ae1d6d65c906d7" translate="yes" xml:space="preserve">
          <source>The idea is that InnoDB recovery would make it point-in-time consistent.</source>
          <target state="translated">아이디어는 InnoDB 복구가 특정 시점의 일관성을 유지한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="df3a3b660453b308dc2a4e657c5b13b697b4ca83" translate="yes" xml:space="preserve">
          <source>The idea is that the &lt;code&gt;BACKUP LOCK&lt;/code&gt; should be held for as short a time as possible by the backup tool. The time to take an uncontested lock is very short! One can easily do 50,000 locks/unlocks per second on low end hardware.</source>
          <target state="translated">아이디어는 백업 도구 가 &lt;code&gt;BACKUP LOCK&lt;/code&gt; 을 가능한 한 짧은 시간 동안 유지해야한다는 것입니다. 경쟁하지 않는 자물쇠를 여는 시간은 매우 짧습니다! 로우 엔드 하드웨어에서 초당 50,000 잠금 / 잠금 해제를 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04ce9d43b5f933e82aa41030ce26dd5ebaf03e8a" translate="yes" xml:space="preserve">
          <source>The idea is to check part of the WHERE condition that refers to index fields (we call it &lt;em&gt;Pushed Index Condition&lt;/em&gt;) as soon as we've accessed the index. If the &lt;em&gt;Pushed Index Condition&lt;/em&gt; is not satisfied, we won't need to read the whole table record.</source>
          <target state="translated">아이디어는 인덱스에 액세스하자마자 인덱스 필드를 참조하는 WHERE 조건의 일부를 확인하는 것입니다 ( &lt;em&gt;푸시 인덱스 조건이라고 함&lt;/em&gt; ). 는 IF &lt;em&gt;밀어 인덱스 조건이&lt;/em&gt; 충족되지, 우리는 전체 테이블의 레코드를 읽을 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e57de65a1732b55d5dae32e5074204a1df42a3a9" translate="yes" xml:space="preserve">
          <source>The idea is to run the semi-join as if it were a regular inner join, and then eliminate the duplicate record combinations using a temporary table.</source>
          <target state="translated">이 방법은 semi-join을 일반 내부 조인처럼 실행 한 다음 임시 테이블을 사용하여 중복 레코드 조합을 제거하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="85f99d0c3c0363808a3d42a92476c60daf18c708" translate="yes" xml:space="preserve">
          <source>The idea of &quot;derived table with key&quot; optimization is to let the materialized derived table have one key which is used for joins with other tables.</source>
          <target state="translated">&quot;키가있는 파생 테이블&quot;최적화의 개념은 구체화 된 파생 테이블에 다른 테이블과의 조인에 사용되는 하나의 키를 갖도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9ea2d189c0960eb3241f5f3bbef59b653f1ced95" translate="yes" xml:space="preserve">
          <source>The idea of Table Pullout</source>
          <target state="translated">테이블 풀 아웃의 아이디어</target>
        </trans-unit>
        <trans-unit id="c2cc8ecfb3fe2e40b0850c5f16c105fcb243b112" translate="yes" xml:space="preserve">
          <source>The idea with group commit is to amortize the costs of each flush to disk over multiple commits from multiple parallel transactions. For example, if there are 10 transactions trying to commit in parallel, then we can force all of them to be flushed disk at once with a single system call, rather than do one system call for each commit. This can greatly reduce the need for flush operations, and can consequently greatly improve the throughput of transactions-per-second (TPS).</source>
          <target state="translated">그룹 커밋의 아이디어는 여러 병렬 트랜잭션의 여러 커밋보다 디스크 플러시 비용을 상각하는 것입니다. 예를 들어, 병렬로 커밋하려고하는 10 개의 트랜잭션이있는 경우 각 커밋마다 하나의 시스템 호출을 수행하는 대신 단일 시스템 호출로 모든 트랜잭션을 한 번에 플러시 디스크로 만들 수 있습니다. 이는 플러시 작업의 필요성을 크게 줄이고 결과적으로 초당 트랜잭션 (TPS) 처리량을 크게 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9512743f24786d3cdba0d979e1f2b24db574a3cb" translate="yes" xml:space="preserve">
          <source>The ideal size of the query cache is very dependent on the specific needs of each system. Setting a value too small will result in query results being dropped from the cache when they could potentially be re-used later. Setting a value too high could result in reduced performance due to lock contention, as the query cache is locked during updates.</source>
          <target state="translated">쿼리 캐시의 이상적인 크기는 각 시스템의 특정 요구에 크게 좌우됩니다. 값을 너무 작게 설정하면 나중에 다시 사용할 수있을 때 캐시에서 쿼리 결과가 삭제됩니다. 값을 너무 높게 설정하면 업데이트 중에 쿼리 캐시가 잠겨 있으므로 경합 잠금으로 인해 성능이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17ee83dc92ca79199e69032af3719e1e3aa7eabd" translate="yes" xml:space="preserve">
          <source>The implementation and behavior of this feature is different than the same feature in MySQL 5.6.</source>
          <target state="translated">이 기능의 구현과 동작은 MySQL 5.6의 동일한 기능과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1f9bff51323be191d78de774ebd831128f6accc1" translate="yes" xml:space="preserve">
          <source>The implementation is described in &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-4506&quot;&gt;MDEV-4506&lt;/a&gt;.</source>
          <target state="translated">구현은 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-4506&quot;&gt;MDEV-4506에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="40ac63c58591d6696a94a898582058edf7d941ed" translate="yes" xml:space="preserve">
          <source>The implementation of the algorithm in 5.3 heavily exploits the multi-range-read interface and its properties. The interface hides the actual mechanism of fetching possible candidates for matching records from the table to be joined. As any block based join algorithm the BKA join repeatedly fills the join buffer with records of the first operand and for each refill it finds records from the join table that could match the records in the buffer. To find such records it asks the MRR interface to perform index look-ups with the keys constructed over all records from the buffer. Together with each key the interface receives a return address - a reference to the record over which this key has been constructed. The actual implementation functions of the MRR interface organize and optimize somehow the process of fetching the records of the joined table by the received keys. Each fetched record r2 is appended with the return address associated with the key by which the record has been found and the result is passed to the BKA join procedure. The procedure takes the record r1 from the join buffer by the return address, joins it with r2 and checks the join condition. If the condition is evaluated to true the joined records is sent to the result stream of the join operation. So for each record returned by the MRR interface only one record from the join buffer is accessed. The number of records from table t2 fetched by the BKA join is exactly the same as for the regular nested loops join algorithm. Yet BKA join allows to optimize the order in which the records are fetched.</source>
          <target state="translated">5.3의 알고리즘 구현은 다중 범위 읽기 인터페이스와 그 속성을 크게 활용합니다. 인터페이스는 조인 할 테이블에서 레코드를 일치시키기 위해 가능한 후보를 페치하는 실제 메커니즘을 숨 깁니다. 모든 블록 기반 조인 알고리즘으로서 BKA 조인은 조인 버퍼를 첫 번째 피연산자의 레코드로 반복적으로 채우고 각 리필에 대해 조인 테이블에서 버퍼의 레코드와 일치 할 수있는 레코드를 찾습니다. 이러한 레코드를 찾으려면 버퍼의 모든 레코드에 대해 구성된 키를 사용하여 인덱스 조회를 수행하도록 MRR 인터페이스에 요청합니다. 각 키와 함께 인터페이스는이 키가 구성된 레코드에 대한 참조 인 반환 주소를받습니다.MRR 인터페이스의 실제 구현 기능은 수신 된 키로 결합 된 테이블의 레코드를 가져 오는 프로세스를 구성하고 최적화합니다. 페치 된 각 레코드 r2에는 레코드를 찾은 키와 연관된 리턴 주소가 추가되고 결과는 BKA 결합 프로 시저로 전달됩니다. 프로시 저는 리턴 주소로 조인 버퍼에서 레코드 r1을 가져 와서 r2와 조인하고 조인 조건을 점검합니다. 조건이 true로 평가되면 결합 된 레코드가 결합 조작의 결과 스트림으로 전송됩니다. 따라서 MRR 인터페이스가 리턴 한 각 레코드에 대해 결합 버퍼에서 하나의 레코드 만 액세스합니다. BKA 조인에 의해 페치 된 테이블 t2의 레코드 수는 일반 중첩 루프 조인 알고리즘의 레코드 수와 정확히 동일합니다.그러나 BKA 조인을 사용하면 레코드를 가져 오는 순서를 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60d0323d5c3796f6a739a84e36b0b1d29f5cc5e2" translate="yes" xml:space="preserve">
          <source>The implementation of the median and avg_mode functions will scale in memory consumption to the size of the set of unique values in the aggregation.</source>
          <target state="translated">median 및 avg_mode 함수의 구현은 메모리 소비에서 집계의 고유 값 세트 크기로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="2f3eb987df1b4b98daaff483be85318a57513c43" translate="yes" xml:space="preserve">
          <source>The incident %s occured on the master. Message: %s</source>
          <target state="translated">마스터에서 인시던트 % s이 (가) 발생했습니다. 메시지 : % s</target>
        </trans-unit>
        <trans-unit id="474968059f73e63afe9070e14badbf5530f1dddf" translate="yes" xml:space="preserve">
          <source>The included &lt;code&gt;xtstat&lt;/code&gt; program can be used to monitor all internal activity of PBXT. See &lt;a href=&quot;../xtstat/index&quot;&gt;xtstat&lt;/a&gt; for more information.</source>
          <target state="translated">포함 된 &lt;code&gt;xtstat&lt;/code&gt; 프로그램을 사용하여 PBXT의 모든 내부 활동을 모니터링 할 수 있습니다. 자세한 정보는 &lt;a href=&quot;../xtstat/index&quot;&gt;xtstat&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1076ccb91dda974d0344df672a3a3db5ea7e4f40" translate="yes" xml:space="preserve">
          <source>The indentation used here in the &lt;code&gt;ELSE&lt;/code&gt; clause is for purposes of clarity only, and is not otherwise significant. See &lt;a href=&quot;../delimiters-in-the-mysql-client/index&quot;&gt;Delimiters in the mysql client&lt;/a&gt; for more on the use of the delimiter command.</source>
          <target state="translated">여기 &lt;code&gt;ELSE&lt;/code&gt; 절 에 사용 된 들여 쓰기 는 명확성을위한 것일뿐, 그다지 중요하지 않습니다. delimiter 명령 사용에 대한 자세한 내용 &lt;a href=&quot;../delimiters-in-the-mysql-client/index&quot;&gt;은 mysql 클라이언트&lt;/a&gt; 의 구분 기호를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb855611045c72e720bf238598376a650e5c71a7" translate="yes" xml:space="preserve">
          <source>The index for me would contain 'Ja', 'Rick'. That's not useful for distinguishing between 'Jamison', 'Jackson', 'James', etc., so the index is so close to useless that the optimizer often ignores it.</source>
          <target state="translated">나를위한 색인에는 'Ja', 'Rick'이 포함됩니다. 'Jamison', 'Jackson', 'James'등을 구별하는 데 유용하지 않으므로 색인이 쓸모가 없어서 최적화 프로그램이 종종 무시합니다.</target>
        </trans-unit>
        <trans-unit id="a80f6bf102135cbf38f8f5c455f5559c05d3b7da" translate="yes" xml:space="preserve">
          <source>The index is being used to resolve a &lt;code&gt;GROUP BY&lt;/code&gt; or &lt;code&gt;DISTINCT&lt;/code&gt; query. The rows are not read. This is very efficient if the table has a lot of identical index entries as duplicates are quickly jumped over.</source>
          <target state="translated">인덱스는 &lt;code&gt;GROUP BY&lt;/code&gt; 또는 &lt;code&gt;DISTINCT&lt;/code&gt; 쿼리 를 해결하는 데 사용됩니다 . 행을 읽지 않습니다. 중복이 빠르게 건너 뛰기 때문에 테이블에 동일한 인덱스 항목이 많은 경우 매우 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="20a6542c51a2c073799cef31d693fb9fa2c81a60" translate="yes" xml:space="preserve">
          <source>The index is randomly accessed, and</source>
          <target state="translated">인덱스는 무작위로 액세스되며</target>
        </trans-unit>
        <trans-unit id="44efda0d56b32763fbe896899efb743529128a8c" translate="yes" xml:space="preserve">
          <source>The index name (as visible in &lt;code&gt;&lt;a href=&quot;../show-create-table/index&quot;&gt;SHOW CREATE TABLE&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">인덱스 이름 ( &lt;code&gt;&lt;a href=&quot;../show-create-table/index&quot;&gt;SHOW CREATE TABLE&lt;/a&gt;&lt;/code&gt; 에 표시 )</target>
        </trans-unit>
        <trans-unit id="8bf095d7f51d62d97b7f6ed02517a25f5acb319d" translate="yes" xml:space="preserve">
          <source>The index number refers to the number of the index when the table was defined, starting at zero. For example, take the following table definition:</source>
          <target state="translated">인덱스 번호는 0부터 시작하여 테이블을 정의 할 때 인덱스의 번호를 나타냅니다. 예를 들어, 다음 테이블 정의를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f424f0117cd0c37ca7ce8c7873724cdfbe01cc96" translate="yes" xml:space="preserve">
          <source>The index statistics help inform these decisions. Imagine yourself choosing whether to look up a number in a phone book, or in your personal address book. You'd choose the personal phone book if at all possible, as it would (usually!) contain far fewer records and be quicker to search.</source>
          <target state="translated">인덱스 통계는 이러한 결정에 도움이됩니다. 전화 번호부 또는 개인 주소록에서 번호를 조회할지 여부를 선택한다고 상상해보십시오. 개인 전화 번호부 (가능한 경우)는 훨씬 적은 수의 레코드를 포함하고 더 빨리 검색 할 수 있기 때문에 가능하면 개인 전화 번호부를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6125556b8a4e458c67bd7cecef3d13c9d4fb647b" translate="yes" xml:space="preserve">
          <source>The index type, which can be &lt;code&gt;BTREE&lt;/code&gt;, &lt;code&gt;FULLTEXT&lt;/code&gt;, &lt;code&gt;HASH&lt;/code&gt; or &lt;code&gt;RTREE&lt;/code&gt;. See &lt;a href=&quot;../storage-engine-index-types/index&quot;&gt;Storage Engine Index Types&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;BTREE&lt;/code&gt; 일 수있는 색인 유형 , &lt;code&gt;FULLTEXT&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; 또는 &lt;code&gt;RTREE&lt;/code&gt; 일 . &lt;a href=&quot;../storage-engine-index-types/index&quot;&gt;스토리지 엔진 인덱스 유형을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72769c36ca396002e39cdb91943bb6656260675c" translate="yes" xml:space="preserve">
          <source>The indexes are useful</source>
          <target state="translated">색인은 유용합니다</target>
        </trans-unit>
        <trans-unit id="15380d9251830af4b190f08f816023c9bc72234d" translate="yes" xml:space="preserve">
          <source>The infinidb_double_for_decimal_math variable is used to control the data type for intermediate decimal results. This decimal for double math may be set as a default for the instance, set at the session level, or at the statement level by toggling this variable on and off.</source>
          <target state="translated">infinidb_double_for_decimal_math 변수는 중간 10 진수 결과의 데이터 유형을 제어하는 ​​데 사용됩니다. 이중 수학에 대한이 10 진수는 인스턴스의 기본값으로 설정되거나 세션 레벨 또는 명령문 레벨에서이 변수를 켜거나 끄는 것으로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed15f14673cd21dbc08a95869344689e23b1a2f0" translate="yes" xml:space="preserve">
          <source>The infinidb_import_for_batchinsert_delimiter variable is used internally by MariaDB ColumnStore on a non-transactional INSERT INTO SELECT FROM statement as the default delimiter passed to the cpimport tool. With a default value ascii 7, there should be no need to change this value unless your data contains ascii 7 values.</source>
          <target state="translated">infinidb_import_for_batchinsert_delimiter 변수는 트랜잭션이 아닌 INSERT INTO SELECT FROM 문에서 MariaDB ColumnStore에 의해 내부적으로 cpimport 도구에 전달 된 기본 분리 문자로 사용됩니다. 기본값 ascii 7을 사용하면 데이터에 ascii 7 값이 포함되어 있지 않으면이 값을 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0566d9f796b5962b3c009ccf0db7f477954809af" translate="yes" xml:space="preserve">
          <source>The infinidb_local_query is set to 0 to allow query across all PMs.</source>
          <target state="translated">infinidb_local_query는 모든 PM에서 쿼리를 허용하도록 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9c2f64ba9bc54aab3ac57379c992c165e216a68c" translate="yes" xml:space="preserve">
          <source>The infinidb_use_import_for_batchinsert variable is used to control if cpimport is used for these statements. This variable may be set as a default for the instance, set at the session level, or at the statement level by toggling this variable on and off.</source>
          <target state="translated">infinidb_use_import_for_batchinsert 변수는 이러한 명령문에 cpimport가 사용되는지 여부를 제어하는 ​​데 사용됩니다. 이 변수는 인스턴스의 기본값으로 설정되거나 세션 수준 또는 명령문 수준에서이 변수를 설정하거나 해제하여 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b47791a0252ce5086c7718a827803b24980eb674" translate="yes" xml:space="preserve">
          <source>The initial size of the buffer for client/server communication. When creating multiple-row &lt;code&gt;INSERT&lt;/code&gt; statements (as with the &lt;code&gt;--extended-insert&lt;/code&gt; or &lt;code&gt;--opt&lt;/code&gt; option), &lt;code&gt;mysqldump&lt;/code&gt; creates rows up to &lt;code&gt;net_buffer_length&lt;/code&gt; length. If you increase this variable, you should also ensure that the &lt;code&gt;net_buffer_length&lt;/code&gt; variable in the MariaDB server is at least this large.</source>
          <target state="translated">클라이언트 / 서버 통신을위한 버퍼의 초기 크기입니다. &lt;code&gt;--extended-insert&lt;/code&gt; 또는 &lt;code&gt;--opt&lt;/code&gt; 옵션 과 같이 여러 행 &lt;code&gt;INSERT&lt;/code&gt; 문을 만들 때 &lt;code&gt;mysqldump&lt;/code&gt; 는 최대 &lt;code&gt;net_buffer_length&lt;/code&gt; 길이의 행을 만듭니다 . 이 변수를 늘리면 다음을 확인해야합니다. &lt;code&gt;net_buffer_length&lt;/code&gt; MariaDB 서버 net_buffer_length 변수가 최소한이 크기 .</target>
        </trans-unit>
        <trans-unit id="61f6f8d26bb46cd01c5f97b718be9cf313b7fcfb" translate="yes" xml:space="preserve">
          <source>The initialization phase is over. Follows from the &lt;code&gt;waiting for handler open&lt;/code&gt; state.</source>
          <target state="translated">초기화 단계가 끝났습니다. 에서 따른다 &lt;code&gt;waiting for handler open&lt;/code&gt; 상태를 기다 .</target>
        </trans-unit>
        <trans-unit id="63a30f90b1160c4aae845f172dda9ccf0c34339a" translate="yes" xml:space="preserve">
          <source>The initialization vector supplied to %s is too short. Must be at least %d bytes long</source>
          <target state="translated">% s에 제공된 초기화 벡터가 너무 짧습니다. 최소 % d 바이트 여야합니다.</target>
        </trans-unit>
        <trans-unit id="1acc3000ad6a2827a4891aa18381268a19fb1c28" translate="yes" xml:space="preserve">
          <source>The input arguments may be any length. If either argument is NULL, the result of this function is also &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">입력 인수는 임의의 길이 일 수 있습니다. 인수 중 하나가 NULL이면이 함수의 결과도 &lt;code&gt;NULL&lt;/code&gt; 입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="81f26a5ee9225465519562aedd66b9bf775f627c" translate="yes" xml:space="preserve">
          <source>The input format for each column is specified as a FIELD_FORMAT option. A simple example is:</source>
          <target state="translated">각 열의 입력 형식은 FIELD_FORMAT 옵션으로 지정됩니다. 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0c431a40ece3858f3ba4225f98baffbaa81ad0d2" translate="yes" xml:space="preserve">
          <source>The input stream could be single-threaded or multi-threaded.</source>
          <target state="translated">입력 스트림은 단일 스레드 또는 다중 스레드 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d5d52045847524a2cdbaa20514e4b583cca3bae" translate="yes" xml:space="preserve">
          <source>The insert statement will produce a warning saying:</source>
          <target state="translated">insert 문은 다음과 같은 경고를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3324feeb5f85528e70d66c4a230535c39983aa68" translate="yes" xml:space="preserve">
          <source>The inside files are decompressed into memory. Memory problems may arise with huge files.</source>
          <target state="translated">내부 파일은 메모리로 압축 해제됩니다. 대용량 파일에서 메모리 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e870d5970d30e470e77504c5f0ee8c46ec843b6" translate="yes" xml:space="preserve">
          <source>The installation directory will be the home directory of the user account. So it would be '/home/mysql/ in this example. The installation directory must be the same on every node. In the examples below we will use the path '/home/mysql/mariadb/columnstore'.</source>
          <target state="translated">설치 디렉토리는 사용자 계정의 홈 디렉토리가됩니다. 이 예에서는 '/ home / mysql /입니다. 설치 디렉토리는 모든 노드에서 동일해야합니다. 아래 예에서는 '/ home / mysql / mariadb / columnstore'경로를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="199ccbeac3251037dad734815dc462eec3ab39bb" translate="yes" xml:space="preserve">
          <source>The installation script, postConfigure, is run at install and upgrade times. The first part of the script takes information from the user and setup the system configuration, which is updating the Columnstore.xml and the ProcessConfig.xml configuration files.</source>
          <target state="translated">설치 스크립트 postConfigure는 설치 및 업그레이드시 실행됩니다. 스크립트의 첫 번째 부분은 사용자로부터 정보를 가져와 Columnstore.xml 및 ProcessConfig.xml 구성 파일을 업데이트하는 시스템 구성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="91414ddef23d4b812fa623c34ca8a6c41e7337a1" translate="yes" xml:space="preserve">
          <source>The installer can install a launchd service configuration. This is optional, but it is enabled by default.</source>
          <target state="translated">설치 관리자는 시작된 서비스 구성을 설치할 수 있습니다. 이것은 선택 사항이지만 기본적으로 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e22d27cc8f98fd7368bf19131bdeff6a73f42c0" translate="yes" xml:space="preserve">
          <source>The installer installs MariaDB Server in a subdirectory of /usr/local/mariadb.</source>
          <target state="translated">설치 프로그램은 MariaDB 서버를 / usr / local / mariadb의 하위 디렉토리에 설치합니다.</target>
        </trans-unit>
        <trans-unit id="9ed762904960fd611d7e7e8c370dcb8dbb45b301" translate="yes" xml:space="preserve">
          <source>The instinctive solution often leads to scanning half the table to do just about anything, such as finding the item containing an 'address'. In complexity terms, this is Order(N).</source>
          <target state="translated">본능적 인 해결책은 종종 '주소'를 포함하는 항목을 찾는 것과 같은 모든 일을하기 위해 절반의 테이블을 스캔하게합니다. 복잡성 측면에서 이것은 Order (N)입니다.</target>
        </trans-unit>
        <trans-unit id="b0a70a3963bef4471130d069fa4bcead4d9f4524" translate="yes" xml:space="preserve">
          <source>The instructions below use the mirror &lt;a href=&quot;http://ftp.osuosl.org/&quot;&gt;ftp.osuosl.org&lt;/a&gt;, but any of the MariaDB mirrors can be used by replacing the appropriate part of the URLs. See the &lt;a href=&quot;http://downloads.askmonty.org&quot;&gt;main download page&lt;/a&gt; for what mirrors are available.</source>
          <target state="translated">아래 지침은 &lt;a href=&quot;http://ftp.osuosl.org/&quot;&gt;ftp.osuosl.org&lt;/a&gt; 미러를 사용 하지만 URL의 적절한 부분을 교체하여 MariaDB 미러를 사용할 수 있습니다. 사용 가능한 미러는 &lt;a href=&quot;http://downloads.askmonty.org&quot;&gt;기본 다운로드 페이지&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="db0fb705b06e18aa93bb630272ea575be7bf74a3" translate="yes" xml:space="preserve">
          <source>The instructions in the repository configuration tool for Ubuntu 16.04 &quot;Xenial&quot; and Debian &quot;Sid&quot; have been updated to reference this new key. Repositories for previous versions of Debian and Ubuntu still use the old key, so no changes are needed there.</source>
          <target state="translated">Ubuntu 16.04 &quot;Xenial&quot;및 Debian &quot;Sid&quot;용 저장소 구성 도구의 지시 사항이이 새 키를 참조하도록 업데이트되었습니다. 이전 버전의 데비안 및 우분투 리포지토리는 여전히 이전 키를 사용하므로 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6eecd25c51319a0fc82994f8173e2b9e8ceeffbf" translate="yes" xml:space="preserve">
          <source>The instructions on this page were used to create the &lt;em&gt;galera&lt;/em&gt; package on the Fedora Linux distribution. This package contains the wsrep provider for &lt;a href=&quot;../galera/index&quot;&gt;MariaDB Galera Cluster&lt;/a&gt;.</source>
          <target state="translated">이 페이지의 지침 은 Fedora Linux 배포판 에서 &lt;em&gt;galera&lt;/em&gt; 패키지 를 작성하는 데 사용되었습니다 . 이 패키지에는 &lt;a href=&quot;../galera/index&quot;&gt;MariaDB Galera Cluster&lt;/a&gt; 용 wsrep 제공자가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f64b0c7ea74781f64ac9e8035ad937c4bc3d8b86" translate="yes" xml:space="preserve">
          <source>The instructions on this page were used to create the &lt;em&gt;galera&lt;/em&gt; package on the Ubuntu and Debian Linux distributions. This package contains the wsrep provider for &lt;a href=&quot;../galera/index&quot;&gt;MariaDB Galera Cluster&lt;/a&gt;.</source>
          <target state="translated">이 페이지의 지침 은 Ubuntu 및 Debian Linux 배포판 에서 &lt;em&gt;galera&lt;/em&gt; 패키지 를 작성하는 데 사용되었습니다 . 이 패키지에는 &lt;a href=&quot;../galera/index&quot;&gt;MariaDB Galera Cluster&lt;/a&gt; 용 wsrep 제공자가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8be0d482366d8242df6c62b3e979723b762a29e1" translate="yes" xml:space="preserve">
          <source>The instructions on this page will help you compile &lt;a href=&quot;../mariadb/index&quot;&gt;MariaDB&lt;/a&gt; from source. Links to more complete instructions for specific platforms can be found on the &lt;a href=&quot;../source/index&quot;&gt;source&lt;/a&gt; page.</source>
          <target state="translated">이 페이지의 지침 은 소스에서 &lt;a href=&quot;../mariadb/index&quot;&gt;MariaDB&lt;/a&gt; 를 컴파일하는 데 도움이됩니다 . 특정 플랫폼에 대한보다 완전한 지침에 대한 링크는 &lt;a href=&quot;../source/index&quot;&gt;소스&lt;/a&gt; 페이지 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39f46d8ad81eb327c5db0960cb17c5569550804c" translate="yes" xml:space="preserve">
          <source>The integer part of a division can be obtained using &lt;a href=&quot;../div/index&quot;&gt;DIV&lt;/a&gt;.</source>
          <target state="translated">나누기의 정수 부분은 &lt;a href=&quot;../div/index&quot;&gt;DIV&lt;/a&gt; 를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7630b6312623da34b7536bc207c3ef7aec171245" translate="yes" xml:space="preserve">
          <source>The integers in the &lt;code&gt;storage_type&lt;/code&gt; field match the geometry types as follows:</source>
          <target state="translated">&lt;code&gt;storage_type&lt;/code&gt; 필드 의 정수는 다음과 같이 기하학 유형과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1f7b4d870c8a2212e996b14d2d592f37c5599a79" translate="yes" xml:space="preserve">
          <source>The interconnect between UMs and PMs can be one or more private VLANs. In this case MariaDB ColumnStore will automatically trunk the individual LANs together to provide greater effective bandwidth between the UMs and PMs.</source>
          <target state="translated">UM과 PM 간의 상호 연결은 하나 이상의 개인 VLAN 일 수 있습니다. 이 경우 MariaDB ColumnStore는 개별 LAN을 자동으로 트렁크하여 UM과 PM간에보다 효과적인 대역폭을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e115eefb330ac28d02cac0789ec992f2fa99cf64" translate="yes" xml:space="preserve">
          <source>The interesting parts are:</source>
          <target state="translated">흥미로운 부분은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18318c3dce814d9350f488cb07d767c5c3691bbe" translate="yes" xml:space="preserve">
          <source>The interesting work is in the Ips, not the second table, so I focus on it. The inconvenience of JOINing to the second table is small compared to the performance gains.</source>
          <target state="translated">흥미로운 작업은 두 번째 테이블이 아니라 Ips에있는 것이므로 집중합니다. 두 번째 테이블에 참여하는 불편 함은 성능 향상에 비해 작습니다.</target>
        </trans-unit>
        <trans-unit id="aee79f0152964408724a13d6997accbd5c39d128" translate="yes" xml:space="preserve">
          <source>The interface to XA transactions is a set of SQL statements starting with &lt;code&gt;XA&lt;/code&gt;. Each statement changes a transaction's state, determining which actions it can perform. A transaction which does not exist is in the &lt;code&gt;NON-EXISTING&lt;/code&gt; state.</source>
          <target state="translated">XA 트랜잭션에 대한 인터페이스로 시작하는 SQL 문 세트입니다 &lt;code&gt;XA&lt;/code&gt; . 각 명령문은 트랜잭션 상태를 변경하여 수행 할 수있는 조치를 결정합니다. 존재하지 않는 트랜잭션이 &lt;code&gt;NON-EXISTING&lt;/code&gt; 상태입니다.</target>
        </trans-unit>
        <trans-unit id="1717a51e3afa545b8ac01f0f153ac0d2a125aef8" translate="yes" xml:space="preserve">
          <source>The internal datatype for addresses is the same as the calling datatype (BINARY(16)).</source>
          <target state="translated">주소의 내부 데이터 유형은 호출 데이터 유형 (BINARY (16))과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="836476f86361edbf0a192344ba441d151ebbc1cf" translate="yes" xml:space="preserve">
          <source>The internal datatype for addresses is the same as the calling datatype (INT UNSIGNED).</source>
          <target state="translated">주소의 내부 데이터 유형은 호출 데이터 유형 (INT UNSIGNED)과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="797817170867daadb8adc8f0c2120c816e7ec3dc" translate="yes" xml:space="preserve">
          <source>The internal representation of it will be the character string &lt;code&gt;-2658.740000&lt;/code&gt;. The way it is stored in a file table depends on the table type. The &lt;em&gt;length&lt;/em&gt; field specification corresponds to the length of the table field in which the value is stored and is calculated by CONNECT from the &lt;em&gt;precision&lt;/em&gt; and the &lt;em&gt;scale&lt;/em&gt; values. This length is &lt;em&gt;precision&lt;/em&gt; plus 1 if &lt;em&gt;scale&lt;/em&gt; is not 0 (for the decimal point) plus 1 if this column is not unsigned (for the eventual minus sign). In fix formatted tables the number is right justified in the field of width &lt;em&gt;length&lt;/em&gt;, for variable formatted tables, such as CSV, the field is the representing character string.</source>
          <target state="translated">내부 표현은 문자열 &lt;code&gt;-2658.740000&lt;/code&gt; 입니다. 파일 테이블에 저장되는 방법은 테이블 유형에 따라 다릅니다. &lt;em&gt;길이&lt;/em&gt; 필드 사양 값이 저장되고로부터 CONNECT 의해 계산되는 테이블 필드의 길이에 대응 &lt;em&gt;정밀도&lt;/em&gt; 및 &lt;em&gt;스케일&lt;/em&gt; 값. 이 길이는 &lt;em&gt;스케일&lt;/em&gt; 이 0 (소수점)이 아닌 경우 &lt;em&gt;정밀도&lt;/em&gt; + 1 이고이 열이 부호가없는 경우 (마이너스 부호의 경우) 1입니다. 수정 형식 테이블의 경우 width &lt;em&gt;length&lt;/em&gt; 필드에 숫자가 오른쪽으로 정렬 되고 CSV와 같은 변수 형식 테이블의 경우 필드가 나타내는 문자열입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="48142c812dc781896d732ce5abd94e05bb605d42" translate="yes" xml:space="preserve">
          <source>The intersection, or shared portion, of two geometries</source>
          <target state="translated">두 도형의 교차점 또는 공유 부분</target>
        </trans-unit>
        <trans-unit id="a498313e9ba8506a967e5b825bb759a4e9592ed7" translate="yes" xml:space="preserve">
          <source>The intersection, or shared portion, of two geometries.</source>
          <target state="translated">두 도형의 교차점 또는 공유 부분.</target>
        </trans-unit>
        <trans-unit id="d274df2e957f5ca399aad725145ae8869930096a" translate="yes" xml:space="preserve">
          <source>The introduction of &lt;a href=&quot;../binlog-event-checksums/index&quot;&gt;checksums on binlog events&lt;/a&gt; changes the format that events are stored in &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; files and sent over the network to slaves. This raises the question on what happens when replicating between different versions of the server, where one server is a newer version that has the binlog checksum feature implemented, while the other server is an older version that does not know about binlog checksums.</source>
          <target state="translated">&lt;a href=&quot;../binlog-event-checksums/index&quot;&gt;binlog 이벤트&lt;/a&gt; 에 체크섬을 도입 하면 이벤트가 &lt;a href=&quot;../binary-log/index&quot;&gt;바이너리 로그&lt;/a&gt; 파일에 저장되고 네트워크를 통해 슬레이브로 전송 되는 형식이 변경됩니다 . 다른 서버 버전간에 복제 할 때 어떤 서버가 binlog 체크섬 기능이 구현 된 최신 버전이고 다른 서버가 binlog 체크섬에 대해 알지 못하는 이전 버전 인 경우에 대한 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5b62392abbd1eeab5fe2f95251e232d8c9f7df48" translate="yes" xml:space="preserve">
          <source>The inverse function of &lt;code&gt;UNIX_TIMESTAMP()&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../from_unixtime/index&quot;&gt;FROM_UNIXTIME()&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;UNIX_TIMESTAMP()&lt;/code&gt; 의 역함수 는 &lt;code&gt;&lt;a href=&quot;../from_unixtime/index&quot;&gt;FROM_UNIXTIME()&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c3c2a1a02d78fbaefe0e770439f9529b19c08254" translate="yes" xml:space="preserve">
          <source>The inverse of this function (when called with a single argument) is the &lt;a href=&quot;../exp/index&quot;&gt;EXP()&lt;/a&gt; function.</source>
          <target state="translated">이 함수의 역함수 (단일 인수로 호출 된 경우)는 &lt;a href=&quot;../exp/index&quot;&gt;EXP ()&lt;/a&gt; 함수입니다.</target>
        </trans-unit>
        <trans-unit id="50d53392f995b3ee9eed9b0502da984e7631affa" translate="yes" xml:space="preserve">
          <source>The inverse of this function is &lt;code&gt;&lt;a href=&quot;../exp/index&quot;&gt;EXP()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 함수의 역은 &lt;code&gt;&lt;a href=&quot;../exp/index&quot;&gt;EXP()&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ffbebe353d57241bd416ceb7231c2ff081300f79" translate="yes" xml:space="preserve">
          <source>The ioDrive branded products can be used as block devices (super-fast disks) or to extend basic DRAM memory. ioDrive is deployed by installing it on an x86 server and then installing the card driver under the operating system. All main line 64-bit operating systems and hypervisors are supported: RHEL, CentOS, SuSe, Debian, OEL etc. and VMware, Microsoft Windows/Server etc. Drivers and their features are constantly developed further.</source>
          <target state="translated">ioDrive 브랜드 제품은 블록 장치 (초고속 디스크)로 사용하거나 기본 DRAM 메모리를 확장 할 수 있습니다. ioDrive는 x86 서버에 ioDrive를 설치 한 다음 운영 체제에서 카드 드라이버를 설치하여 배포됩니다. RHEL, CentOS, SuSe, Debian, OEL 등 모든 주요 64 비트 운영 체제 및 하이퍼 바이저가 지원되며 VMware, Microsoft Windows / Server 등 드라이버 및 해당 기능이 지속적으로 개발됩니다.</target>
        </trans-unit>
        <trans-unit id="6ae53c760d26d35c2c87c09f88a7d0b72afcb220" translate="yes" xml:space="preserve">
          <source>The iso images have been successfully tested on:</source>
          <target state="translated">iso 이미지는 다음에서 성공적으로 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="3bd1a0d25227ae5dc2415ce6f0e222bfdbe00226" translate="yes" xml:space="preserve">
          <source>The issue is that if no schema name is specified, some data sources return information for all schemas while some others only return the information of the &amp;ldquo;default&amp;rdquo; schema. In addition, the used &amp;ldquo;schema&amp;rdquo; or &amp;ldquo;database&amp;rdquo; is sometimes implied by the connection string and sometimes is not. Sometimes, it also can be included in a data source definition.</source>
          <target state="translated">문제는 스키마 이름을 지정하지 않으면 일부 데이터 소스가 모든 스키마에 대한 정보를 반환하는 반면 다른 일부는 &quot;기본&quot;스키마의 정보 만 반환한다는 것입니다. 또한 사용 된 &quot;스키마&quot;또는 &quot;데이터베이스&quot;는 연결 문자열에 의해 암시 될 수도 있고 그렇지 않을 수도 있습니다. 때로는 데이터 소스 정의에 포함될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7eca311bd75095586465b09b11005d69af07e0f8" translate="yes" xml:space="preserve">
          <source>The issue is that if we want to create a partitioned table on these files, there are no columns to use for defining a partition function. Each city file can have the same kind of column values and there is no way to distinguish them.</source>
          <target state="translated">문제는 이러한 파일에서 분할 된 테이블을 만들려면 분할 함수를 정의하는 데 사용할 열이 없다는 것입니다. 각 도시 파일은 동일한 종류의 열 값을 가질 수 있으며이를 구분할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b1fd9e0e105d0d872b0ddf1b017cde36774545b" translate="yes" xml:space="preserve">
          <source>The java wrapper class files are available on your system.</source>
          <target state="translated">Java 랩퍼 클래스 파일은 시스템에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a6d711d4334587a6e1e8ed3a88bfc54a62a41767" translate="yes" xml:space="preserve">
          <source>The join can be done in two directions:</source>
          <target state="translated">결합은 두 방향으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7e14be19deff70888a831fcff77bce4ec971b19" translate="yes" xml:space="preserve">
          <source>The join process will return only the rows fulfilling the where clause.</source>
          <target state="translated">결합 프로세스는 where 절을 충족시키는 행만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="26eb19cd70ba0439806c084663ab969ce20f878c" translate="yes" xml:space="preserve">
          <source>The json item is created by extracting the required part from the file. This can be the whole file but more often only some of it. There are two ways to specify the sub-item of the file to be used:</source>
          <target state="translated">json 항목은 파일에서 필요한 부분을 추출하여 작성됩니다. 이것은 전체 파일 일 수 있지만 더 자주 일부 파일 일 수 있습니다. 사용할 파일의 하위 항목을 지정하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5106ca0cf05ae273c372ade7d19d5a5dded25aed" translate="yes" xml:space="preserve">
          <source>The key can be added using the following command:</source>
          <target state="translated">다음 명령을 사용하여 키를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ab05da4ca56fa951124af38963789c48fcf14a2" translate="yes" xml:space="preserve">
          <source>The key differentiator between a Fusion-io and a legacy SSD/HDD is the following: &lt;strong&gt;A Fusion-io card is connected directly on the system bus (PCIe)&lt;/strong&gt;, this enables &lt;u&gt;high data transfer throughput&lt;/u&gt; (1.5 GB/s, 3.0 GB/s or 6GB/s) and the fast direct memory access (DMA) method can be used to transfer data. The ATA/SATA protocol stack is omitted and therefore &lt;u&gt;latency is cut short&lt;/u&gt;. Fusion-io performance is dependent on server speed: the faster processors and the newer PCIe-bus version you have, the better is the ioDrive performance. &lt;u&gt;Fusion-io memory is non-volatile&lt;/u&gt;, in other words, data remains on the card even when the server is powered off.</source>
          <target state="translated">퓨전 IO 및 레거시 SSD 간의 주요 차별화 / HDD는 다음과 같다 : &lt;strong&gt;퓨전 IO 카드 시스템 버스 (의 PCIe)에 직접 연결되고&lt;/strong&gt; ,이 수 &lt;u&gt;처리량이 높은 데이터 전송&lt;/u&gt; (1.5 GB / s, 3.0 GB / s를 또는 6GB / s) 및 고속 직접 메모리 액세스 (DMA) 방법을 사용하여 데이터를 전송할 수 있습니다. ATA / SATA 프로토콜 스택이 생략되므로 &lt;u&gt;대기 시간이 단축&lt;/u&gt; 됩니다. Fusion-io 성능은 서버 속도에 따라 달라집니다. 프로세서가 빠를수록 최신 PCIe- 버스 버전 일수록 ioDrive 성능이 향상됩니다. &lt;u&gt;Fusion-io 메모리는 비 휘발성입니다&lt;/u&gt; . 즉, 서버 전원이 &lt;u&gt;꺼져도&lt;/u&gt; 데이터는 카드에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="a52402c3e34bf7d61a2068d921a508684604b974" translate="yes" xml:space="preserve">
          <source>The key file can be specified with the &lt;code&gt;--des-key-file&lt;/code&gt; server option.</source>
          <target state="translated">키 파일은 &lt;code&gt;--des-key-file&lt;/code&gt; 서버 옵션 으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c35ae1c104547b909a3ee9b335bc0ebc1933bad" translate="yes" xml:space="preserve">
          <source>The key file still needs to have a key identifier for each encryption key added to the beginning of each line. Key identifiers do not need to be contiguous. Open the new key file in your preferred text editor and add the key identifiers. For example, the key file would look something like the following after this step:</source>
          <target state="translated">키 파일에는 여전히 각 줄의 시작 부분에 추가 된 각 암호화 키에 대한 키 식별자가 있어야합니다. 키 식별자는 연속적 일 필요는 없습니다. 원하는 텍스트 편집기에서 새 키 파일을 열고 키 식별자를 추가하십시오. 예를 들어이 단계 후에 키 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="58ed4e5e14a5852aa34e344e9b9542a22ae5c855" translate="yes" xml:space="preserve">
          <source>The key identifiers give you a way to reference the encryption keys from MariaDB. In the example above, you could reference these encryption keys using the key identifiers &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;100&lt;/code&gt; with the &lt;code&gt;&lt;a href=&quot;../create-table/index#encryption_key_id&quot;&gt;ENCRYPTION_KEY_ID&lt;/a&gt;&lt;/code&gt; table option or with system variables such as &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_default_encryption_key_id&quot;&gt;innodb_default_encryption_key_id&lt;/a&gt;&lt;/code&gt;. You do not necessarily need multiple encryption keys--the encryption key with the key identifier &lt;code&gt;1&lt;/code&gt; is the only mandatory encryption key.</source>
          <target state="translated">키 식별자는 MariaDB의 암호화 키를 참조 할 수있는 방법을 제공합니다. 위의 예 에서 &lt;code&gt;&lt;a href=&quot;../create-table/index#encryption_key_id&quot;&gt;ENCRYPTION_KEY_ID&lt;/a&gt;&lt;/code&gt; 테이블 옵션 또는 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_default_encryption_key_id&quot;&gt;innodb_default_encryption_key_id&lt;/a&gt;&lt;/code&gt; 와 같은 시스템 변수와 함께 키 식별자 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 또는 &lt;code&gt;100&lt;/code&gt; 을 사용하여 이러한 암호화 키를 참조 할 수 있습니다. 반드시 여러 개의 암호화 키가 필요하지는 않습니다. 키 식별자가 &lt;code&gt;1&lt;/code&gt; 인 암호화 키는 유일한 필수 암호화 키입니다.</target>
        </trans-unit>
        <trans-unit id="eba91861953e0e872dcb7db691718f60ec7d39c8" translate="yes" xml:space="preserve">
          <source>The key points in this create statement are the EXECSRC option and the column definition.</source>
          <target state="translated">이 create 문의 핵심 사항은 EXECSRC 옵션과 열 정의입니다.</target>
        </trans-unit>
        <trans-unit id="a4c8fe3e2c0fe64fa23733574e2c211df9919e98" translate="yes" xml:space="preserve">
          <source>The key we use has an id of &lt;code&gt;1BB943DB&lt;/code&gt; and the key fingerprint is:</source>
          <target state="translated">우리가 사용하는 키의 ID는 &lt;code&gt;1BB943DB&lt;/code&gt; 이며 키 지문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc5b0ef4e993e1d4fc9fd186e1f84950fdfffda2" translate="yes" xml:space="preserve">
          <source>The keywords &lt;code&gt;CREATE EVENT&lt;/code&gt; plus an event name, which uniquely identifies the event in the current schema. (Prior to MySQL 5.1.12, the event name needed to be unique only among events created by the same user on a given database.)</source>
          <target state="translated">키워드 &lt;code&gt;CREATE EVENT&lt;/code&gt; 와 이벤트 이름은 현재 스키마에서 이벤트를 고유하게 식별합니다. (MySQL 5.1.12 이전에는 이벤트 이름이 지정된 데이터베이스에서 동일한 사용자가 만든 이벤트 중 고유해야했습니다.)</target>
        </trans-unit>
        <trans-unit id="e7eb967d1508a95938f12fb938f9fdfe15958178" translate="yes" xml:space="preserve">
          <source>The language used for the names is controlled by the value of the &lt;a href=&quot;../server-system-variables/index#lc_time_names&quot;&gt;lc_time_names&lt;/a&gt; system variable. See &lt;a href=&quot;../server-locale/index&quot;&gt;server locale&lt;/a&gt; for more on the supported locales.</source>
          <target state="translated">이름에 사용되는 언어는 &lt;a href=&quot;../server-system-variables/index#lc_time_names&quot;&gt;lc_time_names&lt;/a&gt; 시스템 변수 의 값으로 제어됩니다 . 지원되는 로캘에 대한 자세한 내용은 &lt;a href=&quot;../server-locale/index&quot;&gt;서버 로캘&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bdb87deee0a0e6a5bff1d86763218c871f8d018f" translate="yes" xml:space="preserve">
          <source>The larger the size, the longer it will take to initialize. On a modern 64-bit server with a 10GB memory pool, this can take five seconds or more.</source>
          <target state="translated">크기가 클수록 초기화하는 데 시간이 더 걸립니다. 10GB 메모리 풀이있는 최신 64 비트 서버에서는 5 초 이상이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="761532c3d2b3d3d294b722de6b00c272a1661748" translate="yes" xml:space="preserve">
          <source>The last ALTER is needed to display all the entries.</source>
          <target state="translated">모든 항목을 표시하려면 마지막 ALTER가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="879fb92a5cac4344b051e3dbbc16f0d9d1dec749" translate="yes" xml:space="preserve">
          <source>The last block committed to the extent (starting at 0)</source>
          <target state="translated">범위까지 커밋 된 마지막 블록 (0부터 시작)</target>
        </trans-unit>
        <trans-unit id="18a23953f153e556f33185d81cf6bbccbff9798c" translate="yes" xml:space="preserve">
          <source>The last items would be delivered in reverse order. Either deal with that in the UI, or make the SELECT more complex:</source>
          <target state="translated">마지막 품목은 역순으로 배송됩니다. UI에서 처리하거나 SELECT를 더 복잡하게 만드십시오.</target>
        </trans-unit>
        <trans-unit id="9d735352f2f04923c0390f7994f40bfe92356e3e" translate="yes" xml:space="preserve">
          <source>The last line will cause all tests of this suite that include &lt;code&gt;windows.inc&lt;/code&gt; to be skipped with the reason being &quot;Not on windows&quot;.</source>
          <target state="translated">마지막 줄은 &lt;code&gt;windows.inc&lt;/code&gt; 를 포함하는이 제품군의 모든 테스트 가 &quot;Windows에 없음&quot;이유로 건너 뛰게합니다.</target>
        </trans-unit>
        <trans-unit id="ebed367c5ee393f6412de36f502da46ea6913dbf" translate="yes" xml:space="preserve">
          <source>The last part of a &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; statement can be definition of the new table's partitions. In the case of RANGE COLUMNS partitioning, the syntax is the following:</source>
          <target state="translated">&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; 문의 마지막 부분은 새 테이블의 파티션을 정의한 것일 수 있습니다. RANGE COLUMNS 파티셔닝의 경우 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="810ce8ccdd4d588d9313ffc5dc0e9b741f167f1f" translate="yes" xml:space="preserve">
          <source>The last part of a &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; statement can be definition of the new table's partitions. In the case of RANGE partitioning, the syntax is the following:</source>
          <target state="translated">&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; 문의 마지막 부분은 새 테이블의 파티션을 정의한 것일 수 있습니다. RANGE 파티셔닝의 경우 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56ad362e4a81d74aa5e715bc32b7a422dbcff6c9" translate="yes" xml:space="preserve">
          <source>The last part of a &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; statement can be the definition of the new table's partitions. In the case of LIST partitioning, the syntax is the following:</source>
          <target state="translated">&lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; 문의 마지막 부분은 새 테이블 파티션의 정의 일 수 있습니다. LIST 파티셔닝의 경우 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f0069f7613346cf7490f7025058aae35ed03a202" translate="yes" xml:space="preserve">
          <source>The last read access date</source>
          <target state="translated">마지막 읽기 액세스 날짜</target>
        </trans-unit>
        <trans-unit id="def7900d265d2da7cd2e9ad7200a5faab1efe41e" translate="yes" xml:space="preserve">
          <source>The last two arguments tell it to stream the &lt;code&gt;t6&lt;/code&gt; table on the &lt;code&gt;test&lt;/code&gt; database. If you want to stream multiple tables, replace these arguments with a &lt;code&gt;-f&lt;/code&gt; option that gives the path to a table list file. Format the file for one table per line, separating the database name and table name by a tab. For instance,</source>
          <target state="translated">마지막 두 인수 는 &lt;code&gt;test&lt;/code&gt; 데이터베이스 에서 &lt;code&gt;t6&lt;/code&gt; 테이블 을 스트리밍하도록 지시 합니다. 여러 테이블을 스트리밍하려면이 인수를 테이블 목록 파일의 경로를 제공 하는 &lt;code&gt;-f&lt;/code&gt; 옵션으로 바꾸십시오 . 데이터베이스 이름과 테이블 이름을 탭으로 구분하여 한 줄에 한 테이블 씩 파일을 포맷하십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="d7f6a36a189d4f401a09a06b65a21552ac95fdc5" translate="yes" xml:space="preserve">
          <source>The last two digits of the year (that is, 1996 would be coded as &quot;96&quot;).</source>
          <target state="translated">연도의 마지막 두 자리 (즉, 1996는 &quot;96&quot;으로 코딩 됨).</target>
        </trans-unit>
        <trans-unit id="bcef6a8e316d6b913a4f8ed009b0b01c9752de69" translate="yes" xml:space="preserve">
          <source>The last two statements display the results shown because 2 is equal to neither 1 nor 0.</source>
          <target state="translated">마지막 두 명령문은 2가 1도 0도 아니기 때문에 표시된 결과를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="e01c433a99dd6cddea06eb9ac40123b886ba181c" translate="yes" xml:space="preserve">
          <source>The last write access date</source>
          <target state="translated">마지막 쓰기 액세스 날짜</target>
        </trans-unit>
        <trans-unit id="4769a8dbf51a9d4a04b7e484ae5106c15008691c" translate="yes" xml:space="preserve">
          <source>The latest version of the MariaDB Bulk Data Adapters need to be installed. See additional &lt;a href=&quot;../columnstore-bulk-write-sdk/index&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">최신 버전의 MariaDB 벌크 데이터 어댑터를 설치해야합니다. 추가 &lt;a href=&quot;../columnstore-bulk-write-sdk/index&quot;&gt;설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="71e9959d174c7161374e1e20849e80e5a8c2ed8f" translate="yes" xml:space="preserve">
          <source>The latest version of the MariaDB Java Connector should be downloaded from &lt;a href=&quot;https://mariadb.com/downloads/connector&quot;&gt;https://mariadb.com/downloads/connector&lt;/a&gt; and copied to the master node, e.g. under /usr/share/java.</source>
          <target state="translated">최신 버전의 MariaDB Java 커넥터는 &lt;a href=&quot;https://mariadb.com/downloads/connector&quot;&gt;https://mariadb.com/downloads/connector&lt;/a&gt; 에서 다운로드 하여 마스터 노드에 복사해야합니다 (예 : / usr / share / java).</target>
        </trans-unit>
        <trans-unit id="cb168f503865a4cb71b4fad49454ed32eea31808" translate="yes" xml:space="preserve">
          <source>The latter query would also run 5.x times slower (from 2.2 to 10.8 seconds) in our experiments.</source>
          <target state="translated">후자의 쿼리는 실험에서 5.x 배 느리게 (2.2에서 10.8 초로) 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2d81a1cee41c5c3838ec6167341130eaeb4bff2e" translate="yes" xml:space="preserve">
          <source>The latter three steps are repeated until all rows have been processed.</source>
          <target state="translated">후자의 세 단계는 모든 행이 처리 될 때까지 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="145bf0a0e6a317a403f58797996d138ea82f2b98" translate="yes" xml:space="preserve">
          <source>The latter two should be replaced with simply &lt;code&gt;ZEROFILL&lt;/code&gt;, but are still accepted by the parser.</source>
          <target state="translated">후자의 두 개는 단순히 &lt;code&gt;ZEROFILL&lt;/code&gt; 로 바뀌어야 하지만 파서는 여전히 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="504e150d2761c57a71470d4d463fa7bf59f4dd04" translate="yes" xml:space="preserve">
          <source>The launchd service configuration file installed by the installer is located at /Library/LaunchDaemons/com.mariadb.server.plist. The service definition file uses command-line arguments to &lt;code&gt;mariadbd&lt;/code&gt; to control some of its behavior. These will override changes you make in option (.cnf) files.</source>
          <target state="translated">설치 관리자가 설치 한 시작된 서비스 구성 파일은 /Library/LaunchDaemons/com.mariadb.server.plist에 있습니다. 서비스 정의 파일은 &lt;code&gt;mariadbd&lt;/code&gt; 에 명령 행 인수를 사용 하여 일부 동작을 제어합니다. 옵션 (.cnf) 파일에서 변경 한 내용보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="47ae2b30b34dea9f8465b9ac8f516b676db68d3f" translate="yes" xml:space="preserve">
          <source>The length can &lt;strong&gt;not&lt;/strong&gt; be increased with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt; if the original length was between 128 bytes and 255 bytes, and the new length is 256 bytes or more.</source>
          <target state="translated">원래 길이가 128 바이트에서 255 바이트 사이이고 새 길이가 256 바이트 이상인 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정하면 길이를 늘릴 수 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b3192344e186b4dc09dd1eb5d596401b93d0f239" translate="yes" xml:space="preserve">
          <source>The length can be increased with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt; if the original length of the column is 127 bytes or less, and the new length of the column is 256 bytes or more.</source>
          <target state="translated">열의 원래 길이가 127 바이트 이하이고 열의 새 길이가 256 바이트 이상인 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정하면 길이를 늘릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="250aecec3f6b6f3bf6a745644a57b3768735cded" translate="yes" xml:space="preserve">
          <source>The length can be increased with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt; if the original length of the column is 255 bytes or less, and the new length of the column is still 255 bytes or less.</source>
          <target state="translated">열의 원래 길이가 255 바이트 이하이고 열의 새 길이가 여전히 255 바이트 이하인 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정하면 길이를 늘릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6cbc5d38f10154d850340fb38ee5779d75809400" translate="yes" xml:space="preserve">
          <source>The length can be increased with &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; set to &lt;code&gt;INSTANT&lt;/code&gt; if the original length of the column is 256 bytes or more, and the new length of the column is still 256 bytes or more.</source>
          <target state="translated">열의 원래 길이가 256 바이트 이상이고 열의 새 길이가 여전히 256 바이트 이상인 경우 &lt;code&gt;&lt;a href=&quot;../alter-table/index#algorithm&quot;&gt;ALGORITHM&lt;/a&gt;&lt;/code&gt; 을 &lt;code&gt;INSTANT&lt;/code&gt; 로 설정하면 길이를 늘릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be0da5f8f08ac9e5dfd2ce2caf205e47f7dc75e6" translate="yes" xml:space="preserve">
          <source>The length of nested arrays or objects are not counted.</source>
          <target state="translated">중첩 배열 또는 객체의 길이는 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="738fad2df0a4b6c60616567aeaf5e3f5b4662315" translate="yes" xml:space="preserve">
          <source>The length of the buffer.</source>
          <target state="translated">버퍼의 길이</target>
        </trans-unit>
        <trans-unit id="7bd3e280ca85e0f17cb7ee53df0dc960d9be90b0" translate="yes" xml:space="preserve">
          <source>The letters &lt;em&gt;SQL&lt;/em&gt; stand for Structured Query Language. As with all languages&amp;mdash;even computer languages&amp;mdash;there are grammar rules. This includes a certain structure to statements, acceptable punctuation (i.e., operators and delimiters), and a vocabulary (i.e., reserve words).</source>
          <target state="translated">문자 &lt;em&gt;SQL&lt;/em&gt; 은 구조적 쿼리 언어를 나타냅니다. 컴퓨터 언어를 포함한 모든 언어와 마찬가지로 문법 규칙이 있습니다. 여기에는 문장에 대한 특정 구조, 허용 가능한 구두점 (예 : 연산자 및 구분 기호) 및 어휘 (예 : 예약어)가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6728205f7fb7de918a71021e927a4cd67c9ca1d1" translate="yes" xml:space="preserve">
          <source>The level of quoting used in &lt;a href=&quot;../connect-csv-and-fmt-table-types/index&quot;&gt;CSV&lt;/a&gt; table files.</source>
          <target state="translated">&lt;a href=&quot;../connect-csv-and-fmt-table-types/index&quot;&gt;CSV&lt;/a&gt; 테이블 파일에 사용 된 인용 수준 .</target>
        </trans-unit>
        <trans-unit id="17961803463d1b264f012f69761d63d9d89e28dc" translate="yes" xml:space="preserve">
          <source>The limit for how much data you can have in one statement is controlled by the &lt;code&gt;&lt;a href=&quot;../mysqld-options-full-list/index&quot;&gt;max_allowed_packet&lt;/a&gt;&lt;/code&gt; server variable.</source>
          <target state="translated">한 명령문에서 보유 할 수있는 데이터의 양에 대한 한계는 &lt;code&gt;&lt;a href=&quot;../mysqld-options-full-list/index&quot;&gt;max_allowed_packet&lt;/a&gt;&lt;/code&gt; 서버 변수에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="5cb3df39423a60a8ba23f674b60b3dd85838992f" translate="yes" xml:space="preserve">
          <source>The limit is 32,000 concurrent transactions when all data-modifying transactions also modify temporary tables.</source>
          <target state="translated">모든 데이터 수정 트랜잭션이 임시 테이블을 수정하는 경우 제한은 32,000 개의 동시 트랜잭션입니다.</target>
        </trans-unit>
        <trans-unit id="adc908e06c17ae8839ad546c81921cf619c4e801" translate="yes" xml:space="preserve">
          <source>The limit that is taken into account is 11, not 0.</source>
          <target state="translated">고려되는 한계는 0이 아니라 11입니다.</target>
        </trans-unit>
        <trans-unit id="da37e3335787f6a5028b89a8759f351ba77e378d" translate="yes" xml:space="preserve">
          <source>The limitations for HANDLER READ with Memory|HEAP tables are:</source>
          <target state="translated">Memory | HEAP 테이블을 사용한 HANDLER READ의 제한 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd83a3134f4a22a850f89f18d6d1bc71f3b5e706" translate="yes" xml:space="preserve">
          <source>The limiting factor of the Version Buffer is not the number of rows being updated, but rather the number of disk blocks. You can increase the size, but use caution, since increasing the number of disk blocks means that &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt;&lt;/code&gt; statements that run for long periods of time can take even longer in the event that you need to roll back the changes.</source>
          <target state="translated">Version Buffer의 제한 요소는 업데이트되는 행 수가 아니라 디스크 블록 수입니다. 디스크 블록 수를 늘리면 변경 사항을 롤백해야하는 경우 장기간 실행 되는 &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt;&lt;/code&gt; 문이 더 오래 걸릴 수 있으므로 크기를 늘릴 수 있지만주의 해야합니다.</target>
        </trans-unit>
        <trans-unit id="668e74df6296101efe70289974856e662313dab7" translate="yes" xml:space="preserve">
          <source>The list can contain one or more columns.</source>
          <target state="translated">목록에는 하나 이상의 열이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a09256dcc10e94debfb4ba2e70aaa1067e373ea" translate="yes" xml:space="preserve">
          <source>The list excludes status related to the following storage engines included in &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;:</source>
          <target state="translated">이 목록에는 &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0에&lt;/a&gt; 포함 된 다음 스토리지 엔진과 관련된 상태가 제외됩니다 .</target>
        </trans-unit>
        <trans-unit id="94f0271a8613ee14f42e28175be4eb2d0a4ad6b7" translate="yes" xml:space="preserve">
          <source>The list excludes status related to the following storage engines included in &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt;:</source>
          <target state="translated">이 목록에는 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1에&lt;/a&gt; 포함 된 다음 스토리지 엔진과 관련된 상태가 제외됩니다 .</target>
        </trans-unit>
        <trans-unit id="20c9c1a69d76dc490c9eb437f49d33ea42a5ddf4" translate="yes" xml:space="preserve">
          <source>The list excludes the following variables, related to storage engines and plugins included in &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt;:</source>
          <target state="translated">이 목록은 &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0에&lt;/a&gt; 포함 된 스토리지 엔진 및 플러그인과 관련된 다음 변수를 제외합니다 .</target>
        </trans-unit>
        <trans-unit id="b60883d6fcd9cf899b547341221881e7e9988e3b" translate="yes" xml:space="preserve">
          <source>The list excludes the following variables, related to storage engines and plugins included in &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1&lt;/a&gt;:</source>
          <target state="translated">이 목록은 &lt;a href=&quot;../what-is-mariadb-101/index&quot;&gt;MariaDB 10.1에&lt;/a&gt; 포함 된 스토리지 엔진 및 플러그인과 관련된 다음 변수를 제외합니다 .</target>
        </trans-unit>
        <trans-unit id="c8cf83de3faa3b6e7b3ab8a7204a8c95ca124ad4" translate="yes" xml:space="preserve">
          <source>The list excludes variables related to non-default storage engines and plugins that can be added to &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;:</source>
          <target state="translated">이 목록은 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5에&lt;/a&gt; 추가 할 수있는 기본이 아닌 스토리지 엔진 및 플러그인과 관련된 변수는 제외합니다 .</target>
        </trans-unit>
        <trans-unit id="25923f9d7b5994303047707cdc6b0a0e4b082151" translate="yes" xml:space="preserve">
          <source>The list is displayed on any server (not just the master server). The output looks like this:</source>
          <target state="translated">이 목록은 마스터 서버뿐만 아니라 모든 서버에 표시됩니다. 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="beabec6f962c727cdefb938a685581626feed5d1" translate="yes" xml:space="preserve">
          <source>The list of new functions:</source>
          <target state="translated">새로운 기능 목록 :</target>
        </trans-unit>
        <trans-unit id="46167e0a68c0f7b557a7af07e543b9dc3f928934" translate="yes" xml:space="preserve">
          <source>The list of the columns of the TBL table may not necessarily include all the columns of the tables of the list. If the name of some columns is different in the sub-tables, the column to use can be specified by its position given by the &lt;code&gt;FLAG&lt;/code&gt; option of the column. If the &lt;code&gt;ACCEPT&lt;/code&gt; option is set to true (Y or 1) columns that do not exist in some of the sub-tables are accepted and their value will be null or pseudo-null (this depends on the nullability of the column) for the tables not having this column. The column types can also be different and an automatic conversion will be done if necessary.</source>
          <target state="translated">TBL 테이블의 열 목록에 반드시 목록 테이블의 모든 열이 포함되는 것은 아닙니다. 서브 테이블에서 일부 컬럼의 이름이 다른 경우, 사용할 컬럼은 컬럼의 &lt;code&gt;FLAG&lt;/code&gt; 옵션으로 지정된 위치로 지정할 수 있습니다 . 경우 &lt;code&gt;ACCEPT&lt;/code&gt; 옵션이 true (Y 또는 1) 하위 테이블의 일부에 존재하지 않는 컬럼에 설정되어 적용되고 그 값은 테이블에 대한 null 또는 의사는 null (이 컬럼의 Null 허용 여부에 따라 달라집니다)입니다 이 열이 없습니다. 열 유형도 다를 수 있으며 필요한 경우 자동 변환이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="85b1542e37c92bd8af189b38cd673cc2d119b71f" translate="yes" xml:space="preserve">
          <source>The list of the locales supported by the current MariaDB installation can be obtained via the &lt;a href=&quot;../locales-plugin/index&quot;&gt;LOCALES&lt;/a&gt; plugin, available since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1004-release-notes/&quot;&gt;MariaDB 10.0.4&lt;/a&gt;.</source>
          <target state="translated">현재 MariaDB 설치에서 지원되는 로케일 목록은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1004-release-notes/&quot;&gt;MariaDB 10.0.4&lt;/a&gt; 부터 사용 가능한 &lt;a href=&quot;../locales-plugin/index&quot;&gt;LOCALES&lt;/a&gt; 플러그인을 통해 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9bbe2ccda5c888c2b0251dd921b8f3ee8e47823" translate="yes" xml:space="preserve">
          <source>The list of value follow the &lt;code&gt;VALUES&lt;/code&gt; or &lt;code&gt;VALUE&lt;/code&gt; keyword (which are interchangeable, regardless how much values you want to insert), and is wrapped by parenthesis. The values must be listed in the same order as the columns list. It is possible to specify more than one list to insert more than one rows with a single statement. If many rows are inserted, this is a speed optimization.</source>
          <target state="translated">값 목록은 &lt;code&gt;VALUES&lt;/code&gt; 또는 &lt;code&gt;VALUE&lt;/code&gt; 키워드 (삽입 할 값의 양에 관계없이 교환 가능)를 따르며 괄호로 묶습니다. 값은 열 목록과 동일한 순서로 나열되어야합니다. 단일 명령문으로 둘 이상의 행을 삽입하기 위해 둘 이상의 목록을 지정할 수 있습니다. 많은 행이 삽입되면 속도 최적화입니다.</target>
        </trans-unit>
        <trans-unit id="b13daf5a192e3c4d07eeddd0a00b0329abf460cb" translate="yes" xml:space="preserve">
          <source>The literals which occur in stored programs and views, by default, use the character set and collation which was specified by the &lt;a href=&quot;../server-system-variables/index#character_set_connection&quot;&gt;character_set_connection&lt;/a&gt; and &lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;collation_connection&lt;/a&gt; system variables when the stored program was created. These values can be seen using the SHOW CREATE statements. To change the character sets used for literals in an existing stored program, it is necessary to drop and recreate the stored program.</source>
          <target state="translated">저장된 프로그램 및보기에서 발생하는 리터럴은 기본적으로 스토어드 프로그램이 작성 될 때 &lt;a href=&quot;../server-system-variables/index#character_set_connection&quot;&gt;character_set_connection&lt;/a&gt; 및 &lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;collation_connection&lt;/a&gt; 시스템 변수에 의해 지정된 문자 세트 및 데이터 정렬을 사용합니다 . 이 값은 SHOW CREATE 문을 사용하여 볼 수 있습니다. 기존의 저장된 프로그램에서 리터럴에 사용되는 문자 세트를 변경하려면 저장된 프로그램을 삭제하고 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a16f10c51672f127a7c8eaf26aabffb949fb67c" translate="yes" xml:space="preserve">
          <source>The live user is &quot;sql&quot; and the password is &quot;live&quot;. Please change the password immediately after first login!</source>
          <target state="translated">실제 사용자는 &quot;sql&quot;이고 암호는 &quot;live&quot;입니다. 최초 로그인 후 즉시 비밀번호를 변경하십시오!</target>
        </trans-unit>
        <trans-unit id="c505758698f53dc702090a44d85cf8ccbbaebd46" translate="yes" xml:space="preserve">
          <source>The loan balance has been set to its initial value of the received funds.</source>
          <target state="translated">대출 잔액은 수취 한 자금의 초기 가치로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="4e1f159082495d427936c4d70e79d015f5f7cd0c" translate="yes" xml:space="preserve">
          <source>The loan balance has now been reduced to reflect account payments. MaxScale has also streamed the data from the changes over to ColumnStore.</source>
          <target state="translated">계정 잔액을 반영하기 위해 대출 잔고가 줄었습니다. MaxScale은 또한 변경 사항에서 ColumnStore로 데이터를 스트리밍했습니다.</target>
        </trans-unit>
        <trans-unit id="dddb501b58e52d2e866bd6c08ec9e739b9ad1a9d" translate="yes" xml:space="preserve">
          <source>The local column name (alias in the remote server)</source>
          <target state="translated">로컬 열 이름 (원격 서버의 별명)</target>
        </trans-unit>
        <trans-unit id="243c188b7aaf223e57b81550908370c17a4c77f4" translate="yes" xml:space="preserve">
          <source>The location of the MariaDB ColumnStore Process corefiles get placed here:</source>
          <target state="translated">MariaDB ColumnStore Process 코어 파일의 위치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2435aeb6e0494105cb6b706dd564a6b8f0131af5" translate="yes" xml:space="preserve">
          <source>The lock wait timeout can be explicitly set in the statement by using either &lt;code&gt;WAIT n&lt;/code&gt; (to set the wait in seconds) or &lt;code&gt;NOWAIT&lt;/code&gt;, in which case the statement will immediately fail if the lock cannot be obtained. &lt;code&gt;WAIT 0&lt;/code&gt; is equivalent to &lt;code&gt;NOWAIT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;WAIT n&lt;/code&gt; (초 단위로 설정) 또는 &lt;code&gt;NOWAIT&lt;/code&gt; 를 사용하여 명령문에서 잠금 대기 시간 종료를 명시 적으로 설정할 수 있습니다 .이 경우 잠금을 확보 할 수 없으면 명령문이 즉시 실패합니다. &lt;code&gt;WAIT 0&lt;/code&gt; 은 &lt;code&gt;NOWAIT&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6d502f78824855d8d7ceb95de2d9402f6f3fe8a4" translate="yes" xml:space="preserve">
          <source>The log consists of a memory-mapped file that is divided into pages of 8KB size.</source>
          <target state="translated">로그는 8KB 크기의 페이지로 분할 된 메모리 매핑 파일로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="43706f2d163566a52a07067c2805e5a1d1d0e589" translate="yes" xml:space="preserve">
          <source>The log file format should also be compatible, but we don't make any guarantees yet. In some cases when upgrading, you must remove the old &lt;code&gt;aria_log.%&lt;/code&gt; and &lt;code&gt;maria_log.%&lt;/code&gt; files before restarting MariaDB. (So far, this has only occurred in the upgrade from &lt;a href=&quot;../what-is-mariadb-51/index&quot;&gt;MariaDB 5.1&lt;/a&gt; and &lt;a href=&quot;../what-is-mariadb-52/index&quot;&gt;MariaDB 5.2&lt;/a&gt;).</source>
          <target state="translated">로그 파일 형식도 호환 가능해야하지만 아직 보장하지는 않습니다. 경우에 따라 업그레이드 할 때 MariaDB를 다시 시작하기 전에 이전 &lt;code&gt;aria_log.%&lt;/code&gt; 및 &lt;code&gt;maria_log.%&lt;/code&gt; 파일을 제거해야합니다 . (지금까지는 &lt;a href=&quot;../what-is-mariadb-51/index&quot;&gt;MariaDB 5.1&lt;/a&gt; 및 &lt;a href=&quot;../what-is-mariadb-52/index&quot;&gt;MariaDB 5.2&lt;/a&gt; 에서 업그레이드 할 때만 발생했습니다 ).</target>
        </trans-unit>
        <trans-unit id="0455ce609897484055e4927824e4e5aa8e273228" translate="yes" xml:space="preserve">
          <source>The log is also used to see detect if any truncate or online alter tables are used.</source>
          <target state="translated">로그는 또한 절단 또는 온라인 변경 테이블이 사용되는지 감지하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5a5fc82f6be4dcff80c12989e1b7a3e4e900fa00" translate="yes" xml:space="preserve">
          <source>The log tables use the &lt;a href=&quot;../csv/index&quot;&gt;CSV&lt;/a&gt; storage engine by default. This allows an external program to read the files if needed: normal CSV files are stored in the &lt;code&gt;mysql&lt;/code&gt; subdirectory, in the data dir. However that engine is slow because it does not support indexes, so you can convert the tables to &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; (but not other storage engines). To do so, first temporarily disable logging:</source>
          <target state="translated">로그 테이블 은 기본적으로 &lt;a href=&quot;../csv/index&quot;&gt;CSV&lt;/a&gt; 스토리지 엔진을 사용합니다 . 이를 통해 외부 프로그램이 필요한 경우 파일을 읽을 수 있습니다. 일반 CSV 파일은 &lt;code&gt;mysql&lt;/code&gt; 서브 디렉토리의 data dir에 저장됩니다 . 그러나 인덱스를 지원하지 않기 때문에 엔진 속도가 느리므로 테이블을 &lt;a href=&quot;../myisam/index&quot;&gt;MyISAM&lt;/a&gt; (다른 스토리지 엔진은 아님)으로 변환 할 수 있습니다 . 이렇게하려면 먼저 일시적으로 로깅을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="0962f85fda4b97e4022c09d0163325acfa189297" translate="yes" xml:space="preserve">
          <source>The logic used:</source>
          <target state="translated">사용 된 논리 :</target>
        </trans-unit>
        <trans-unit id="59b59079596d233fa457486156123595cd47ab48" translate="yes" xml:space="preserve">
          <source>The login user name to use for running &lt;code&gt;mysqld&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mysqld&lt;/code&gt; 실행에 사용할 로그인 사용자 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="2d63aa10f196f60f3b855d1e1ac0bc7771e49ee1" translate="yes" xml:space="preserve">
          <source>The login user name to use for running &lt;code&gt;mysqld&lt;/code&gt;. Files and directories created by &lt;code&gt;mysqld&lt;/code&gt; will be owned by this user. You must be &lt;code&gt;root&lt;/code&gt; to use this option. By default, &lt;code&gt;mysqld&lt;/code&gt; runs using your current login name and files and directories that it creates will be owned by you.</source>
          <target state="translated">&lt;code&gt;mysqld&lt;/code&gt; 실행에 사용할 로그인 사용자 이름 입니다. &lt;code&gt;mysqld&lt;/code&gt; 가 생성 한 파일과 디렉토리 는이 사용자가 소유합니다. 이 옵션을 사용하려면 &lt;code&gt;root&lt;/code&gt; 여야합니다 . 기본적으로 &lt;code&gt;mysqld&lt;/code&gt; 는 현재 로그인 이름을 사용하여 실행되며 생성 된 파일 및 디렉토리는 사용자가 소유합니다.</target>
        </trans-unit>
        <trans-unit id="44411e3d66ae678ab7e95b96ab7a17bf9a0a9622" translate="yes" xml:space="preserve">
          <source>The lower of &lt;code&gt;150&lt;/code&gt; or the value of &lt;a href=&quot;#max_connections&quot;&gt;max_connections&lt;/a&gt; (beween &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1008-release-notes/&quot;&gt;MariaDB 10.0.8&lt;/a&gt; and &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1017-release-notes/&quot;&gt;MariaDB 10.1.7&lt;/a&gt;)</source>
          <target state="translated">하부 &lt;code&gt;150&lt;/code&gt; 또는 값 &lt;a href=&quot;#max_connections&quot;&gt;MAX_CONNECTIONS&lt;/a&gt; (beween &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1008-release-notes/&quot;&gt;MariaDB 10.0.8&lt;/a&gt; 및 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1017-release-notes/&quot;&gt;MariaDB 10.1.7&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="9147b133b6890961fd25d315e00e3222ac931d54" translate="yes" xml:space="preserve">
          <source>The lower of &lt;code&gt;900&lt;/code&gt; and (50 + &lt;a href=&quot;#max_connections&quot;&gt;max_connections&lt;/a&gt;/5) (&amp;gt;= &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1017-release-notes/&quot;&gt;MariaDB 10.1.7&lt;/a&gt;)</source>
          <target state="translated">의 하부 &lt;code&gt;900&lt;/code&gt; 과 (50 + &lt;a href=&quot;#max_connections&quot;&gt;MAX_CONNECTIONS&lt;/a&gt; / 5) (&amp;gt; = &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1017-release-notes/&quot;&gt;MariaDB 10.1.7&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="357c218c9b89ff7df232793bdc0f0626b13cee97" translate="yes" xml:space="preserve">
          <source>The lowest acceptable &lt;a href=&quot;../mariadb-plugins/index&quot;&gt;plugin&lt;/a&gt; maturity. MariaDB will not load plugins less mature than the specified level.</source>
          <target state="translated">허용 가능한 최저 &lt;a href=&quot;../mariadb-plugins/index&quot;&gt;플러그인&lt;/a&gt; 성숙도. MariaDB는 지정된 레벨보다 덜 성숙한 플러그인을로드하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fae20178c192ae9995dae40ab740318d70bdc78d" translate="yes" xml:space="preserve">
          <source>The lowest level directory id for the column file containing the physical row</source>
          <target state="translated">실제 행을 포함하는 열 파일의 최하위 디렉토리 ID</target>
        </trans-unit>
        <trans-unit id="ba76be5a8a1b40a1518f0a319960e8b367a0bdca" translate="yes" xml:space="preserve">
          <source>The luxurious Platinum setup: &lt;a href=&quot;http://kb.askmonty.org/en/what-is-mariadb-galera-cluster/&quot;&gt;MariaDB Galera Cluster&lt;/a&gt; running on Fusion-io SLC cards on several hosts.</source>
          <target state="translated">고급스러운 Platinum 설정 : 여러 호스트의 Fusion-io SLC 카드에서 실행되는 &lt;a href=&quot;http://kb.askmonty.org/en/what-is-mariadb-galera-cluster/&quot;&gt;MariaDB Galera Cluster&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6cc865a213660c228af077c1da972499b8900095" translate="yes" xml:space="preserve">
          <source>The main benefit of storing things in an S3 compatible storage is that the cost of storage is much cheaper than many other alternatives. Many S3 implementations also provide reliable long-term storage.</source>
          <target state="translated">S3 호환 스토리지에 저장하는 것의 주요 이점은 스토리지 비용이 다른 많은 대안보다 훨씬 저렴하다는 것입니다. 많은 S3 구현은 안정적인 장기 스토리지도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="48f3f33beb5a66b5e4fee44700be7dd6f00d39dd" translate="yes" xml:space="preserve">
          <source>The main characteristic of &lt;a href=&quot;../connect/index&quot;&gt;CONNECT&lt;/a&gt; is to enable accessing data scattered on a machine as if it was a centralized database. This, and the fact that that locking is not used by connect (data files are open and closed for each query) makes CONNECT very useful for importing or exporting data into or from a MariaDB database and also for all types of Business Intelligence applications. However, it is not suited for transactional applications.</source>
          <target state="translated">&lt;a href=&quot;../connect/index&quot;&gt;CONNECT&lt;/a&gt; 의 주요 특징 은 마치 중앙 집중식 데이터베이스 인 것처럼 머신에 흩어져있는 데이터에 액세스 할 수 있도록하는 것입니다. 이는 연결에 의해 잠금이 사용되지 않기 때문에 (각 쿼리마다 데이터 파일이 열리고 닫힘) CONNECT는 MariaDB 데이터베이스로 또는 데이터베이스에서 모든 유형의 Business Intelligence 응용 프로그램으로 데이터를 가져 오거나 내보내는 데 매우 유용합니다. 그러나 트랜잭션 응용 프로그램에는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a9c0c83b628af5d5e3aee8cff15e7d348f60827" translate="yes" xml:space="preserve">
          <source>The main cookbook skips over an important optimization that is sometimes used. The optimizer will sometimes ignore the WHERE and, instead, use an INDEX that matches the ORDER BY. This, of course, needs to be a perfect match -- all columns, in the same order. And all ASC or all DESC.</source>
          <target state="translated">기본 요리 책은 때때로 사용되는 중요한 최적화를 건너 뜁니다. 옵티마이 저는 때때로 WHERE를 무시하고 대신 ORDER BY와 일치하는 INDEX를 사용합니다. 물론 이것은 모든 열이 동일한 순서로 완벽하게 일치해야합니다. 그리고 모든 ASC 또는 모든 DESC.</target>
        </trans-unit>
        <trans-unit id="a6506664be0713c242d8550bc46eb10983a0f1e4" translate="yes" xml:space="preserve">
          <source>The main difference between the &lt;code&gt;&lt;a href=&quot;../cast/index&quot;&gt;CAST()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;CONVERT()&lt;/code&gt; is that &lt;code&gt;CONVERT(expr,type)&lt;/code&gt; is ODBC syntax while &lt;code&gt;&lt;a href=&quot;../cast/index&quot;&gt;CAST(expr as type)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;CONVERT(... USING ...)&lt;/code&gt; are SQL92 syntax.</source>
          <target state="translated">간의 주된 차이점 &lt;code&gt;&lt;a href=&quot;../cast/index&quot;&gt;CAST()&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;CONVERT()&lt;/code&gt; 즉 &lt;code&gt;CONVERT(expr,type)&lt;/code&gt; 하는 동안이다 ODBC 구문 &lt;code&gt;&lt;a href=&quot;../cast/index&quot;&gt;CAST(expr as type)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;CONVERT(... USING ...)&lt;/code&gt; SQL92 구문이다.</target>
        </trans-unit>
        <trans-unit id="9e2a4ee1222466b1c78a381bf94752709cc8a3eb" translate="yes" xml:space="preserve">
          <source>The main difference between the &lt;code&gt;&lt;a href=&quot;index&quot;&gt;CAST()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../convert/index&quot;&gt;CONVERT()&lt;/a&gt;&lt;/code&gt; is that &lt;code&gt;&lt;a href=&quot;../convert/index&quot;&gt;CONVERT(expr,type)&lt;/a&gt;&lt;/code&gt; is ODBC syntax while &lt;code&gt;&lt;a href=&quot;index&quot;&gt;CAST(expr as type)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../convert/index&quot;&gt;CONVERT(... USING ...)&lt;/a&gt;&lt;/code&gt; are SQL92 syntax.</source>
          <target state="translated">간의 주된 차이점 &lt;code&gt;&lt;a href=&quot;index&quot;&gt;CAST()&lt;/a&gt;&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;../convert/index&quot;&gt;CONVERT()&lt;/a&gt;&lt;/code&gt; 즉 &lt;code&gt;&lt;a href=&quot;../convert/index&quot;&gt;CONVERT(expr,type)&lt;/a&gt;&lt;/code&gt; 하는 동안이다 ODBC 구문 &lt;code&gt;&lt;a href=&quot;index&quot;&gt;CAST(expr as type)&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../convert/index&quot;&gt;CONVERT(... USING ...)&lt;/a&gt;&lt;/code&gt; SQL92 구문이다.</target>
        </trans-unit>
        <trans-unit id="11570fbf8df0e2befafc3b54143e8b0a75524d6f" translate="yes" xml:space="preserve">
          <source>The main difference during parsing is that we store the result type in the sp_head. However, there are big differences when it comes to invoking a FUNCTION. (See below.)</source>
          <target state="translated">구문 분석 중 주요 차이점은 sp_head에 결과 유형을 저장한다는 것입니다. 그러나 FUNCTION을 호출 할 때 큰 차이점이 있습니다. (아래 참조)</target>
        </trans-unit>
        <trans-unit id="90d479fb587be4bd035c713e9888b58874f7a17a" translate="yes" xml:space="preserve">
          <source>The main differences are as follows:</source>
          <target state="translated">주요 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8358f0f26e39bbfad2a7292eb04583f6a578c54d" translate="yes" xml:space="preserve">
          <source>The main differences are:</source>
          <target state="translated">주요 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d16493bbcf8daac3d052db800f170ba5f4f6d03f" translate="yes" xml:space="preserve">
          <source>The main feature of &lt;a href=&quot;../connect/index&quot;&gt;CONNECT&lt;/a&gt; is to give MariaDB the ability to handle tables from many sources, native files, other DBMS&amp;rsquo;s tables, or special &amp;ldquo;virtual&amp;rdquo; tables. Moreover, for all tables physically represented by data files, CONNECT recognizes many different file formats, described below but not limited in the future to this list, because more can be easily added to it on demand (&lt;a href=&quot;../connect-table-types-oem/index&quot;&gt;OEM tables&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;../connect/index&quot;&gt;CONNECT&lt;/a&gt; 의 주요 기능은 MariaDB가 많은 소스, 기본 파일, 기타 DBMS 테이블 또는 특수 &quot;가상&quot;테이블의 테이블을 처리 할 수있는 기능을 제공하는 것입니다. 또한, 데이터 파일로 물리적으로 표현 된 모든 테이블의 경우, CONNECT는 아래에 설명되어 있지만 나중에이 목록에 제한되지 않는 많은 다른 파일 형식을 인식합니다 ( &lt;a href=&quot;../connect-table-types-oem/index&quot;&gt;OEM 테이블&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2008d09ebdc416e61b171bc75e152607c2ea2ff1" translate="yes" xml:space="preserve">
          <source>The main features of CONNECT are:</source>
          <target state="translated">CONNECT의 주요 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="194dc50cbeefdb32c7b7566bed195082bb89755e" translate="yes" xml:space="preserve">
          <source>The main handler values (total of all operations):</source>
          <target state="translated">주요 핸들러 값 (모든 작업의 ​​총계) :</target>
        </trans-unit>
        <trans-unit id="d373e4a98c75b75dc3db3a8b798d9058fc6933c7" translate="yes" xml:space="preserve">
          <source>The main mechanism used in replication is the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt;. If binary logging is enabled, all updates to the database (data manipulation and data definition) are written into the binary log as binlog events. Slaves read the binary log from each master in order to access the data to replicate. A &lt;a href=&quot;../relay-log/index&quot;&gt;relay log&lt;/a&gt; is created on the slave server, using the same format as the binary log, and this is used to perform the replication. Old relay log files are removed when no longer needed.</source>
          <target state="translated">복제에 사용되는 주요 메커니즘은 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 입니다. 이진 로깅이 활성화되면 데이터베이스에 대한 모든 업데이트 (데이터 조작 및 데이터 정의)가 이진 로그에 binlog 이벤트로 기록됩니다. 슬레이브는 복제 할 데이터에 액세스하기 위해 각 마스터에서 이진 로그를 읽습니다. &lt;a href=&quot;../relay-log/index&quot;&gt;중계 로그&lt;/a&gt; 바이너리 로그와 동일한 포맷을 사용하여, 슬레이브 서버에 생성되며, 이는 복제를 수행하는데 사용된다. 더 이상 필요하지 않으면 이전 릴레이 로그 파일이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="c0c1f837d42f3ecf86339acf067794ebc51f497a" translate="yes" xml:space="preserve">
          <source>The main reason to run &lt;code&gt;mysql_upgrade&lt;/code&gt; on all your tables is to allow it to check that:</source>
          <target state="translated">모든 테이블 에서 &lt;code&gt;mysql_upgrade&lt;/code&gt; 를 실행하는 주된 이유는 다음 을 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="48750156d95be04b47611736ef8c279fa5e94218" translate="yes" xml:space="preserve">
          <source>The main server system variable here is &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_change_buffering&quot;&gt;innodb_change_buffering&lt;/a&gt;, which determines which form of change buffering, if any, to use.</source>
          <target state="translated">여기서 주 서버 시스템 변수는 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_change_buffering&quot;&gt;innodb_change_buffering&lt;/a&gt; 이며, 사용할 버퍼링 형식 (있는 경우 )을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="6a6284196ac83df125daac01cb9badedecfef065" translate="yes" xml:space="preserve">
          <source>The main way to avoid swapping is to make sure you have enough RAM for all processes that need to run on the machine. Setting the &lt;a href=&quot;../system-variables/index&quot;&gt;system variables&lt;/a&gt; too high can mean that under load the server runs short of memory, and needs to use swap. So understanding what settings to use and how these impact your server's memory usage is critical.</source>
          <target state="translated">스와핑을 피하는 주요 방법은 머신에서 실행해야하는 모든 프로세스에 충분한 RAM이 있는지 확인하는 것입니다. &lt;a href=&quot;../system-variables/index&quot;&gt;시스템 변수를&lt;/a&gt; 너무 높게 설정하면 로드시 서버의 메모리가 부족하여 스왑을 사용해야 함을 의미 할 수 있습니다. 따라서 사용할 설정과 이러한 설정이 서버의 메모리 사용량에 미치는 영향을 이해하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="b82530bdd1695f8d412802560e3f7efc4749813b" translate="yes" xml:space="preserve">
          <source>The major categories of job steps are the application of a column filter, processing table joins, and the projection of returned columns. Each operation in the query plan executes in parallel by the Job List itself and has the capability of running entirely on the User Module, entirely on the Performance Module or in some combination.</source>
          <target state="translated">작업 단계의 주요 범주는 열 필터 적용, 테이블 조인 처리 및 반환 된 열의 투영입니다. 쿼리 계획의 각 작업은 작업 목록 자체에서 병렬로 실행되며 사용자 모듈, 성능 모듈 또는 일부 조합에서 완전히 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38edb76319f50f9d035ba2fc2cbbf3107b7b892b" translate="yes" xml:space="preserve">
          <source>The major difference between the implementation of BNL join in &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; compared to earlier versions of MariaDB/MySQL is that the former uses a new format for records written into join buffers. This new format allows:</source>
          <target state="translated">이전 버전의 MariaDB / MySQL과 비교 한 &lt;a href=&quot;../what-is-mariadb-53/index&quot;&gt;MariaDB 5.3&lt;/a&gt; 에서의 BNL 조인 구현의 주요 차이점은 이전 버전은 조인 버퍼에 기록 된 레코드에 새로운 형식을 사용한다는 것입니다. 이 새로운 형식은 다음을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="e5c47e7e5a1e3ad3d3bf615d8736d8e710cefdc5" translate="yes" xml:space="preserve">
          <source>The manual's sample: 6ccd780c-baba-1026-9564-0040f4311e29 . A more current value (after a few years): 49ea2de3-17a2-11e2-8346-001eecac3efa . Notice how the 3rd part has slowly changed over time? Let's data is rearranged, thus:</source>
          <target state="translated">매뉴얼 샘플 : 6ccd780c-baba-1026-9564-0040f4311e29. 더 최근 값 (몇 년 후) : 49ea2de3-17a2-11e2-8346-001eecac3efa. 세 번째 부분이 시간이 지남에 따라 천천히 어떻게 변했는지 주목하십시오. 데이터가 재 배열되도록하겠습니다.</target>
        </trans-unit>
        <trans-unit id="843e9f0f8f0d00ac649a0f66ba9758ac593a6ddd" translate="yes" xml:space="preserve">
          <source>The mapping file is used to define the mapping between source csv columns and target ColumnStore columns, to define column specific input date formats, and to set default values for ignored target columns. It follows the Yaml 1.2 standard and can address the source csv columns implicit and explicit.</source>
          <target state="translated">맵핑 파일은 소스 csv 컬럼과 대상 ColumnStore 컬럼 간의 맵핑을 정의하고 컬럼 특정 입력 날짜 형식을 정의하고 무시 된 대상 컬럼의 기본값을 설정하는 데 사용됩니다. Yaml 1.2 표준을 따르며 암시 적 및 명시 적 소스 csv 열을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="ca0c3cced8d574f5acba698af054f1c55ede8e1f" translate="yes" xml:space="preserve">
          <source>The maria/5.3-gis tree on Launchpad.</source>
          <target state="translated">런치 패드의 maria / 5.3-gis 트리.</target>
        </trans-unit>
        <trans-unit id="e405c9f62ce3faccd2dd7bcec8c439147a13355f" translate="yes" xml:space="preserve">
          <source>The mariabackup SST method uses the Mariabackup utility for performing SSTs.</source>
          <target state="translated">mariabackup SST 방법은 SST 수행을 위해 Mariabackup 유틸리티를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9f957698bba4e704ab6b47cbfe550218be65e1f2" translate="yes" xml:space="preserve">
          <source>The master creates a separate binary log dump thread for each slave connected to the master. You can identify which slaves are connected to the master by executing the &lt;code&gt;&lt;a href=&quot;../show-slave-hosts/index&quot;&gt;SHOW SLAVE HOSTS&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">마스터는 마스터에 연결된 각 슬레이브에 대해 별도의 이진 로그 덤프 스레드를 만듭니다. 마스터를 연결하여 슬레이브를 식별 할 수 있습니다. &lt;code&gt;&lt;a href=&quot;../show-slave-hosts/index&quot;&gt;SHOW SLAVE HOSTS&lt;/a&gt;&lt;/code&gt; 문.</target>
        </trans-unit>
        <trans-unit id="daec9e9643791de55ed8140490c6fc42ff06cd46" translate="yes" xml:space="preserve">
          <source>The master info structure does not exist</source>
          <target state="translated">마스터 정보 구조가 존재하지 않습니다</target>
        </trans-unit>
        <trans-unit id="7108cf5f119f3db0da055e3cabc3f57c725f1c14" translate="yes" xml:space="preserve">
          <source>The master usually only has one type of replication-related thread: the binary log dump thread.</source>
          <target state="translated">마스터에는 일반적으로 이진 로그 덤프 스레드라는 한 가지 유형의 복제 관련 스레드 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="8173a0d1d265fc2249b2808e78a17f432c5d3ae9" translate="yes" xml:space="preserve">
          <source>The master's &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#server_id&quot;&gt;server_id&lt;/a&gt; value.</source>
          <target state="translated">마스터의 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#server_id&quot;&gt;server_id&lt;/a&gt; 값</target>
        </trans-unit>
        <trans-unit id="84098f8bd589c31d66249a30651e03450209a6ad" translate="yes" xml:space="preserve">
          <source>The mathematical centroid (geometric center) for a MultiPolygon</source>
          <target state="translated">MultiPolygon의 수학적 중심 (기하 중심)</target>
        </trans-unit>
        <trans-unit id="7a91ffd0f7fd20a3cd78fd7b36ff0b6a34fbe8ee" translate="yes" xml:space="preserve">
          <source>The mathematical centroid (geometric center) for a MultiPolygon.</source>
          <target state="translated">MultiPolygon의 수학적 중심 (기하 중심).</target>
        </trans-unit>
        <trans-unit id="5af6a83cf0ff1d62fa293dd2aeb5011ab8412643" translate="yes" xml:space="preserve">
          <source>The max number of missing tables in the table list before an error is raised. Defaults to 0.</source>
          <target state="translated">오류가 발생하기 전에 테이블 목록에서 누락 된 최대 테이블 수입니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="44732ec8119ec96d2d39882cf5af38f6f5f5c242" translate="yes" xml:space="preserve">
          <source>The max purge lag can be set by configuring the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_max_purge_lag&quot;&gt;innodb_max_purge_lag&lt;/a&gt;&lt;/code&gt; system variable. This system variable can be changed dynamically with &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">최대 퍼지 지연은 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_max_purge_lag&quot;&gt;innodb_max_purge_lag&lt;/a&gt;&lt;/code&gt; 시스템 변수를 구성하여 설정할 수 있습니다 . 이 시스템 변수는 &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; 을 사용 하여 동적으로 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="68c03604e2c184b97258d6757d2b563e316e34e8" translate="yes" xml:space="preserve">
          <source>The max value from the extent map entry for the extent containing the physical row</source>
          <target state="translated">실제 행을 포함하는 익스텐트에 대한 익스텐트 맵 항목의 최대 값</target>
        </trans-unit>
        <trans-unit id="7410714f4faf990f729e116800549c6f4a4f660d" translate="yes" xml:space="preserve">
          <source>The maximum amount of I/O capacity available to InnoDB in an emergency can be configured by setting the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_io_capacity_max&quot;&gt;innodb_io_capacity_max&lt;/a&gt;&lt;/code&gt; system variable. This system variable can be changed dynamically with &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">비상시 InnoDB에 사용 가능한 최대 I / O 용량은 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_io_capacity_max&quot;&gt;innodb_io_capacity_max&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정하여 구성 할 수 있습니다 . 이 시스템 변수는 &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; 을 사용 하여 동적으로 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="390d839a678cd88bb457e62f88bfed2b0f765091" translate="yes" xml:space="preserve">
          <source>The maximum delay can be set by configuring the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_max_purge_lag_delay&quot;&gt;innodb_max_purge_lag_delay&lt;/a&gt;&lt;/code&gt; system variable. This system variable can be changed dynamically with &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">최대 지연은 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_max_purge_lag_delay&quot;&gt;innodb_max_purge_lag_delay&lt;/a&gt;&lt;/code&gt; 시스템 변수를 구성하여 설정할 수 있습니다 . 이 시스템 변수는 다음과 같이 동적으로 변경 될 수 있습니다 &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; 을 사용. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3fafd1ad82c91bb9d2cd5288a0f2764677208c2f" translate="yes" xml:space="preserve">
          <source>The maximum number of blocks for the extent</source>
          <target state="translated">익스텐트의 최대 블록 수</target>
        </trans-unit>
        <trans-unit id="fbb45dc34167424255d0a39513945806dd63e713" translate="yes" xml:space="preserve">
          <source>The maximum number of conditions stored in the performance schema is determined by the &lt;a href=&quot;../performance-schema-system-variables/index#performance_schema_max_cond_instances&quot;&gt;performance_schema_max_cond_instances&lt;/a&gt; system variable.</source>
          <target state="translated">성능 스키마에 저장된 상태의 최대 개수는에 의해 결정된다 &lt;a href=&quot;../performance-schema-system-variables/index#performance_schema_max_cond_instances&quot;&gt;performance_schema_max_cond_instances&lt;/a&gt; 시스템 변수에 .</target>
        </trans-unit>
        <trans-unit id="c0a8aae36b32fd2976ab21ed0b67f8e80b3cab03" translate="yes" xml:space="preserve">
          <source>The maximum number of conditions that can be in the diagnostics area is &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#max_error_count&quot;&gt;max_error_count&lt;/a&gt;&lt;/code&gt;. If this value is 0, the diagnostics area is empty. If this variable is changed, the new value takes effect with the next statement (that is, the diagnostics area is not immediately truncated).</source>
          <target state="translated">진단 영역에있을 수있는 최대 조건 수는 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#max_error_count&quot;&gt;max_error_count&lt;/a&gt;&lt;/code&gt; 입니다. 입니다. 이 값이 0이면 진단 영역이 비어 있습니다. 이 변수가 변경되면 다음 값으로 새 값이 적용됩니다 (즉, 진단 영역이 즉시 잘리지 않습니다).</target>
        </trans-unit>
        <trans-unit id="c32a1917b2df0f52cc82a36e641e8308f98ec7c3" translate="yes" xml:space="preserve">
          <source>The maximum number of distinct terms in a fulltext index is 268,435,455</source>
          <target state="translated">전체 텍스트 인덱스에서 최대 고유 용어 수는 268,435,455입니다.</target>
        </trans-unit>
        <trans-unit id="b357ffd6ce44e90dddbde7dc6e22eea3a1076811" translate="yes" xml:space="preserve">
          <source>The maximum number of instances is defined by the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#table_open_cache_instances&quot;&gt;table_open_cache_instances&lt;/a&gt;&lt;/code&gt; system variable. The default value of the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#table_open_cache_instances&quot;&gt;table_open_cache_instances&lt;/a&gt;&lt;/code&gt; system variable is &lt;code&gt;8&lt;/code&gt;, which is expected to handle up to 100 CPU cores. If your system is larger than this, then you may benefit from increasing the value of this system variable.</source>
          <target state="translated">최대 인스턴스 수는 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#table_open_cache_instances&quot;&gt;table_open_cache_instances&lt;/a&gt;&lt;/code&gt; 시스템 변수에 의해 정의됩니다 . &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#table_open_cache_instances&quot;&gt;table_open_cache_instances&lt;/a&gt;&lt;/code&gt; 시스템 변수 의 기본값 은 &lt;code&gt;8&lt;/code&gt; 이며 최대 100 개의 CPU 코어를 처리 할 것으로 예상됩니다. 시스템이 이보다 큰 경우이 시스템 변수의 값을 늘리면 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40a41c210b0c7989cf53acb97fdc5a37a9ea2e69" translate="yes" xml:space="preserve">
          <source>The maximum number of records in a fulltext index is 268,435,455</source>
          <target state="translated">전체 텍스트 인덱스의 최대 레코드 수는 268,435,455입니다.</target>
        </trans-unit>
        <trans-unit id="c656e5d459c091015e5830e7459447c2745ed21d" translate="yes" xml:space="preserve">
          <source>The maximum number of stages.</source>
          <target state="translated">최대 단계 수입니다.</target>
        </trans-unit>
        <trans-unit id="b5a02a5a4a132462ce264fd7d3ce82d3b82daa1f" translate="yes" xml:space="preserve">
          <source>The maximum packet length to send to or receive from server.</source>
          <target state="translated">서버와주고받을 수있는 최대 패킷 길이입니다.</target>
        </trans-unit>
        <trans-unit id="aaa36827ab66047a9da29999e8a90336efb27f62" translate="yes" xml:space="preserve">
          <source>The maximum packet length to send to or receive from server. The default is 16MB, the maximum 1GB.</source>
          <target state="translated">서버와주고받을 수있는 최대 패킷 길이입니다. 기본값은 16MB이며 최대 1GB입니다.</target>
        </trans-unit>
        <trans-unit id="56bb3e25e0726b171ed2bf4ee013eb9fbccf9b10" translate="yes" xml:space="preserve">
          <source>The maximum padding can be configured by setting the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_compression_pad_pct_max&quot;&gt;innodb_compression_pad_pct_max&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_compression_pad_pct_max&quot;&gt;innodb_compression_pad_pct_max&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정하여 최대 패딩을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cbc614ce0f0d3dde97649e1da259a0f3fcb8a242" translate="yes" xml:space="preserve">
          <source>The maximum returned length in bytes is determined by the &lt;a href=&quot;../server-system-variables/index#group_concat_max_len&quot;&gt;group_concat_max_len&lt;/a&gt; server system variable, which defaults to 1M (&amp;gt;= &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1024-release-notes/&quot;&gt;MariaDB 10.2.4&lt;/a&gt;) or 1K (&amp;lt;= &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3&lt;/a&gt;).</source>
          <target state="translated">리턴 된 최대 길이 (바이트)는 &lt;a href=&quot;../server-system-variables/index#group_concat_max_len&quot;&gt;group_concat_max_len&lt;/a&gt; 서버 시스템 변수에 의해 결정되며 기본값은 1M (&amp;gt; = &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1024-release-notes/&quot;&gt;MariaDB 10.2.4&lt;/a&gt; ) 또는 1K (&amp;lt;= &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3)입니다.&lt;/a&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="e87f9d513ee196f32b3415d8c33a756149ba6949" translate="yes" xml:space="preserve">
          <source>The maximum size for &lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt; and &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; columns is 4GB. This also applies to &lt;a href=&quot;../longblob/index&quot;&gt;LONGBLOB&lt;/a&gt; and &lt;a href=&quot;../longtext/index&quot;&gt;LONGTEXT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../blob/index&quot;&gt;BLOB&lt;/a&gt; 및 &lt;a href=&quot;../text/index&quot;&gt;TEXT&lt;/a&gt; 열의 최대 크기 는 4GB입니다. 이는 &lt;a href=&quot;../longblob/index&quot;&gt;LONGBLOB&lt;/a&gt; 및 &lt;a href=&quot;../longtext/index&quot;&gt;LONGTEXT&lt;/a&gt; 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4e095fc6608dd38881b12b29f5586ef2517cee3" translate="yes" xml:space="preserve">
          <source>The maximum size for the combined InnoDB log files is 512GB.</source>
          <target state="translated">결합 된 InnoDB 로그 파일의 최대 크기는 512GB입니다.</target>
        </trans-unit>
        <trans-unit id="6700380815efdf1ef651af7ffa9bb95ca1d70670" translate="yes" xml:space="preserve">
          <source>The maximum size in bytes of a row-based &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; event. Should be a multiple of 256. Minimum 256, maximum 18446744073709547520.</source>
          <target state="translated">행 기반 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그&lt;/a&gt; 이벤트 의 최대 크기 (바이트)입니다 . 256의 배수 여야합니다. 최소 256, 최대 18446744073709547520.</target>
        </trans-unit>
        <trans-unit id="f1d81f90b7bd6e484947fbbad815b0a52a44a8e4" translate="yes" xml:space="preserve">
          <source>The maximum size of a fulltext index is 256GB</source>
          <target state="translated">전체 텍스트 인덱스의 최대 크기는 256GB입니다.</target>
        </trans-unit>
        <trans-unit id="e0cc5c7ce19af15ee3f55a0b789bdaa2eda5b8c6" translate="yes" xml:space="preserve">
          <source>The maximum size of a single key is 4096 bytes.</source>
          <target state="translated">단일 키의 최대 크기는 4096 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="84ac3e7338dbf9b9c3c40f7e572ed229cb894ffb" translate="yes" xml:space="preserve">
          <source>The maximum size of all keys is 4GB.</source>
          <target state="translated">모든 키의 최대 크기는 4GB입니다.</target>
        </trans-unit>
        <trans-unit id="ca404f0866a97b3926179c908b7ef689138b3bc6" translate="yes" xml:space="preserve">
          <source>The maximum size of join buffers used by block-based algorithms is controlled by setting the &lt;a href=&quot;../server-system-variables/index#join_buffer_size&quot;&gt;join_buffer_size&lt;/a&gt; system variable. This value must be large enough in order for the join buffer employed for a join operation to contain all relevant fields for at least one joined record.</source>
          <target state="translated">블록 기반 알고리즘에 사용되는 최대 결합 버퍼 크기는 &lt;a href=&quot;../server-system-variables/index#join_buffer_size&quot;&gt;join_buffer_size&lt;/a&gt; 를 설정하여 제어됩니다. 시스템 변수를 . 결합 조작에 사용 된 결합 버퍼가 하나 이상의 결합 된 레코드에 대한 모든 관련 필드를 포함하려면이 값이 충분히 커야합니다.</target>
        </trans-unit>
        <trans-unit id="df06f5377b45e94e51e80e8daef0ed816bd412ed" translate="yes" xml:space="preserve">
          <source>The maximum size of the buffer for client/server communication. The maximum is 1GB.</source>
          <target state="translated">클라이언트 / 서버 통신을위한 버퍼의 최대 크기입니다. 최대 값은 1GB입니다.</target>
        </trans-unit>
        <trans-unit id="bb7b59a43c3fcf8d6a475949dcc426f27c239112" translate="yes" xml:space="preserve">
          <source>The maximum total size of MEMORY tables cannot exceed the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#max_heap_table_size&quot;&gt;max_heap_table_size&lt;/a&gt;&lt;/code&gt; system server variable. When a table is created this value applies to that table, and when the server is restarted this value applies to existing tables. Changing this value has no effect on existing tables. However, executing a &lt;code&gt;ALTER TABLE ... ENGINE=MEMORY&lt;/code&gt; statement applies the current value of &lt;code&gt;max_heap_table_size&lt;/code&gt; to the table. Also, it is possible to change the session value of &lt;code&gt;max_heap_table_size&lt;/code&gt; before creating a table, to make sure that tables created by other sessions are not affected.</source>
          <target state="translated">MEMORY 테이블의 최대 총 크기는 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#max_heap_table_size&quot;&gt;max_heap_table_size&lt;/a&gt;&lt;/code&gt; 시스템 서버 변수를 초과 할 수 없습니다 . 테이블이 작성되면이 값이 해당 테이블에 적용되고 서버가 다시 시작되면이 값이 기존 테이블에 적용됩니다. 이 값을 변경해도 기존 테이블에는 영향을 미치지 않습니다. 그러나 &lt;code&gt;ALTER TABLE ... ENGINE=MEMORY&lt;/code&gt; 문을 실행하면 &lt;code&gt;max_heap_table_size&lt;/code&gt; 의 현재 값이 테이블에 적용됩니다 . 또한 테이블을 작성하기 전에 &lt;code&gt;max_heap_table_size&lt;/code&gt; 의 세션 값을 변경하여 다른 세션에서 작성된 테이블이 영향을받지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d933d66dc120c625a754b4960d0f0e80cca9cd01" translate="yes" xml:space="preserve">
          <source>The maximum value of a column. All datatypes are supported.</source>
          <target state="translated">열의 최대 값입니다. 모든 데이터 유형이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="fe5c41cf37f9b229a4255fcd2260dbcf9c1e8b5b" translate="yes" xml:space="preserve">
          <source>The maximum value stored in this extent</source>
          <target state="translated">이 범위에 저장된 최대 값</target>
        </trans-unit>
        <trans-unit id="427161b1170870392cff6961142454f6f574195b" translate="yes" xml:space="preserve">
          <source>The meaning of &lt;code&gt;\R&lt;/code&gt; can be set by starting a pattern with one of the following sequences:</source>
          <target state="translated">&lt;code&gt;\R&lt;/code&gt; 의 의미 는 다음 순서 중 하나를 사용하여 패턴을 시작하여 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="039a4e5ba675a86d4498945765f0c8a04286cd6c" translate="yes" xml:space="preserve">
          <source>The meaning of the different options are as follows - note that this can vary a bit between storage engines:</source>
          <target state="translated">다른 옵션의 의미는 다음과 같습니다. 이는 스토리지 엔진마다 약간 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f727a67020d4af2c2429eaa1d3e9b33ce6063760" translate="yes" xml:space="preserve">
          <source>The mechanisms of storing, finding, and dropping procedures are encapsulated in the files sp.{cc,h}.</source>
          <target state="translated">저장, 찾기 및 삭제 절차의 메커니즘은 sp. {cc, h} 파일에 캡슐화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a00810042aa54643a4b473fc97a0e27add930acf" translate="yes" xml:space="preserve">
          <source>The memory-mapped transaction coordinator log can be monitored with the following status variables:</source>
          <target state="translated">메모리 매핑 된 트랜잭션 조정자 로그는 다음 상태 변수를 사용하여 모니터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad2cbf1bdc35b0d02a155bd39282b24c59d5a9bb" translate="yes" xml:space="preserve">
          <source>The method for copying files (cp or scp). The default is cp.</source>
          <target state="translated">파일 복사 방법 (cp 또는 scp). 기본값은 cp입니다.</target>
        </trans-unit>
        <trans-unit id="c9347677ba4ad7f7aff4f20c7d173669d9003bfa" translate="yes" xml:space="preserve">
          <source>The method that you would use to enable TLS for &lt;a href=&quot;../introduction-to-state-snapshot-transfers-ssts/index&quot;&gt;State Snapshot Transfers (SSTs)&lt;/a&gt; would depend on the value of &lt;code&gt;&lt;a href=&quot;../galera-cluster-system-variables/index#wsrep_sst_method&quot;&gt;wsrep_sst_method&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../introduction-to-state-snapshot-transfers-ssts/index&quot;&gt;SST (State Snapshot Transfers)에&lt;/a&gt; TLS를 사용하는 데 사용 하는 방법은 &lt;code&gt;&lt;a href=&quot;../galera-cluster-system-variables/index#wsrep_sst_method&quot;&gt;wsrep_sst_method&lt;/a&gt;&lt;/code&gt; 값에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="d27a49facf998ab54dc2b48ea3106ac021302c07" translate="yes" xml:space="preserve">
          <source>The min value from the extent map entry for the extent containing the physical row</source>
          <target state="translated">실제 행을 포함하는 익스텐트에 대한 익스텐트 맵 항목의 최소값</target>
        </trans-unit>
        <trans-unit id="c462a538ab2206f3791e39c3f836898e13678e99" translate="yes" xml:space="preserve">
          <source>The minimum convex geometry enclosing all geometries within the set</source>
          <target state="translated">세트 내의 모든 형상을 포함하는 최소 볼록 형상</target>
        </trans-unit>
        <trans-unit id="65beafb846f6be22e7ff4ce4218da18de10c9b97" translate="yes" xml:space="preserve">
          <source>The minimum convex geometry enclosing all geometries within the set.</source>
          <target state="translated">세트 내의 모든 형상을 포함하는 최소 볼록 형상입니다.</target>
        </trans-unit>
        <trans-unit id="b5aac00acc98fe191c59d49a73cdcb7b32991253" translate="yes" xml:space="preserve">
          <source>The minimum requirements for a valid CREATE EVENT statement are as follows:</source>
          <target state="translated">유효한 CREATE EVENT 문의 최소 요구 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da8d2cfe5451a66b70802b0418122b815fa5cd27" translate="yes" xml:space="preserve">
          <source>The mix of handlers in the partitions is not allowed in this version of MariaDB</source>
          <target state="translated">이 버전의 MariaDB에서는 파티션에서 처리기를 혼합하여 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="025abb12dcfdf5a3c830abb7602db926c78ccdc6" translate="yes" xml:space="preserve">
          <source>The module must be linked to the &lt;code&gt;ha_connect.lib&lt;/code&gt; of the binary version it will used with. Recent distributions add this lib in the plugin directory.</source>
          <target state="translated">모듈 은 사용될 바이너리 버전 의 &lt;code&gt;ha_connect.lib&lt;/code&gt; 에 링크되어야합니다 . 최근 배포판에서는이 lib를 플러그인 디렉토리에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="39103da5be51b0288a5195a902cdf70625e4e919" translate="yes" xml:space="preserve">
          <source>The module selects data from disk and caches it in a shared-nothing buffer that is part of the server on which it runs. You can configure as many Performance modules as you want. Each additional module increases the size of the cache of the overall database as well as the amount of processing power available to you.</source>
          <target state="translated">이 모듈은 디스크에서 데이터를 선택하여 데이터가 실행되는 서버의 일부인 공유 버퍼에 캐시합니다. 원하는만큼 성능 모듈을 구성 할 수 있습니다. 각 추가 모듈은 전체 데이터베이스의 캐시 크기와 사용 가능한 처리 능력을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="8830093b5eca1c40079d2fc7cb1a0a25e0833b89" translate="yes" xml:space="preserve">
          <source>The module/system is performing an initialization task at startup time before going to the ACTIVE state.</source>
          <target state="translated">모듈 / 시스템이 시작시 ACTIVE 상태로 가기 전에 초기화 작업을 수행하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d42c1b3c6c1390ea716c0975aaf8b7ddb8af214" translate="yes" xml:space="preserve">
          <source>The modules PM2 and PM3 will be enabled and started.</source>
          <target state="translated">PM2 및 PM3 모듈이 활성화되고 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="5d9bfca27aa126d522cdaefefd3f43fc086b47f3" translate="yes" xml:space="preserve">
          <source>The modules PM2 and PM3 will be stopped and disabled.</source>
          <target state="translated">PM2 및 PM3 모듈이 중지되고 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c16d11fed166efc7cddebcd4e5623de0543f1370" translate="yes" xml:space="preserve">
          <source>The most common ones have a value for all built-in errors, and can be read both via SQL and via the API:</source>
          <target state="translated">가장 일반적인 오류는 모든 내장 오류에 대한 값을 가지며 SQL 및 API를 통해 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bce29524fb967f44c1eebbaa87dc5ac35f1280e" translate="yes" xml:space="preserve">
          <source>The most common way that binlog sequence gets different between servers is when the user/DBA does updates directly on a slave server (and these updates are written into the slaves binlog). This results in events in the slaves binlog that are not present on the master or any other slaves. This can be avoided by setting the session variable sql_log_bin false while doing such updates, so they do not go into the binlog.</source>
          <target state="translated">서버간에 binlog 순서가 달라지는 가장 일반적인 방법은 사용자 / DBA가 슬레이브 서버에서 직접 업데이트하는 경우 (이 업데이트는 슬레이브 binlog에 기록됨)입니다. 이로 인해 마스터 또는 다른 슬레이브에없는 슬레이브 binlog 이벤트가 발생합니다. 이러한 업데이트를 수행하는 동안 세션 변수 sql_log_bin을 false로 설정하면이를 방지 할 수 있으므로 binlog로 이동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1fb34ae968c23a32e4c0ac8e2a3998f932122b4" translate="yes" xml:space="preserve">
          <source>The most human-readable way to get information about a table's foreign keys sometimes is the &lt;code&gt;&lt;a href=&quot;../show-create-table/index&quot;&gt;SHOW CREATE TABLE&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">테이블의 외래 키에 대한 정보를 얻는 가장 사람이 읽을 수있는 방법은 &lt;code&gt;&lt;a href=&quot;../show-create-table/index&quot;&gt;SHOW CREATE TABLE&lt;/a&gt;&lt;/code&gt; 문입니다.</target>
        </trans-unit>
        <trans-unit id="91691d05ab47bc8cef4fe03767ced2681e6a50f3" translate="yes" xml:space="preserve">
          <source>The most important &lt;a href=&quot;../server-system-variables/index&quot;&gt;server system variable&lt;/a&gt; is &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_size&quot;&gt;innodb_buffer_pool_size&lt;/a&gt;, which you can set from 70-80% of the total available memory on a dedicated database server with only or primarily XtraDB/InnoDB tables.</source>
          <target state="translated">가장 중요한 &lt;a href=&quot;../server-system-variables/index&quot;&gt;서버 시스템 변수&lt;/a&gt; 는 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_size&quot;&gt;innodb_buffer_pool_size&lt;/a&gt; 이며, XtraDB / InnoDB 테이블 만 있거나 주로 전용 데이터베이스 서버에서 사용 가능한 총 메모리의 70-80 %를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a109db639c649dbd951067ed710bc3540fdc21ed" translate="yes" xml:space="preserve">
          <source>The most important data that is not available in tabula &lt;code&gt;ANALYZE&lt;/code&gt; statement are:</source>
          <target state="translated">tabula &lt;code&gt;ANALYZE&lt;/code&gt; 문 에서 사용할 수없는 가장 중요한 데이터 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b4481c5bc38b51cb656c6bae57aa9892253a78c2" translate="yes" xml:space="preserve">
          <source>The most important information to watch are &lt;code&gt;Master_Log_File&lt;/code&gt; and &lt;code&gt;Exec_Master_Log_Pos&lt;/code&gt; as when this matches the master, it signals that all transactions has been committed on the slave.</source>
          <target state="translated">감시해야 할 가장 중요한 정보는 &lt;code&gt;Master_Log_File&lt;/code&gt; 및 &lt;code&gt;Exec_Master_Log_Pos&lt;/code&gt; 입니다 . 마스터와 일치하면 모든 트랜잭션이 슬레이브에서 커밋되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3b47c92d14a6e53b8cdf42a931f0b149c19d90d4" translate="yes" xml:space="preserve">
          <source>The most important memory buffer used by InnoDB.</source>
          <target state="translated">InnoDB가 사용하는 가장 중요한 메모리 버퍼.</target>
        </trans-unit>
        <trans-unit id="cc20a0ae39c5fcff4abe1e59ee373e417a815fc0" translate="yes" xml:space="preserve">
          <source>The most important ways for doing this are using &lt;code&gt;SQL_MODE&lt;/code&gt; (controlled by the &lt;a href=&quot;../server-system-variables/index#sql_mode&quot;&gt;sql_mode&lt;/a&gt; system variable) and &lt;a href=&quot;../old_mode/index&quot;&gt;OLD_MODE&lt;/a&gt; (the &lt;a href=&quot;../server-system-variables/index#old_mode&quot;&gt;old_mode&lt;/a&gt; system variable). &lt;code&gt;SQL_MODE&lt;/code&gt; is used for getting MariaDB to emulate behavior from other SQL servers, while &lt;a href=&quot;../old_mode/index&quot;&gt;OLD_MODE&lt;/a&gt; is used for emulating behavior from older MariaDB or MySQL versions.</source>
          <target state="translated">이를 수행하는 가장 중요한 방법은 &lt;code&gt;SQL_MODE&lt;/code&gt; ( &lt;a href=&quot;../server-system-variables/index#sql_mode&quot;&gt;sql_mode&lt;/a&gt; 시스템 변수로 제어 ) 및 &lt;a href=&quot;../old_mode/index&quot;&gt;OLD_MODE&lt;/a&gt; ( &lt;a href=&quot;../server-system-variables/index#old_mode&quot;&gt;old_mode&lt;/a&gt; 시스템 변수)를 사용하는 것입니다. &lt;code&gt;SQL_MODE&lt;/code&gt; 는 MariaDB가 다른 SQL Server의 동작을 에뮬레이트하도록하는 데 사용되고 &lt;a href=&quot;../old_mode/index&quot;&gt;OLD_MODE&lt;/a&gt; 는 이전 MariaDB 또는 MySQL 버전의 동작을 에뮬레이트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f1487c5b9a7ef69d4c556606c23b69a40711f67a" translate="yes" xml:space="preserve">
          <source>The most important ways for doing this are with &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; and &lt;code&gt;OLD_MODE&lt;/code&gt;.</source>
          <target state="translated">이를 수행하는 가장 중요한 방법은 &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; 및 &lt;code&gt;OLD_MODE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="65ebdb295230776ad6c8ffb12a2421047319063e" translate="yes" xml:space="preserve">
          <source>The most recent changes in the code are aimed at meeting the OpenGIS requirements. One thing missed in previous versions is that the functions which check spatial relations didn't consider the actual shape of an object, instead they operate only on their bounding rectangles. These legacy functions have been left as they are and new, properly-working functions are named with an '&lt;code&gt;ST_&lt;/code&gt;' prefix, in accordance with the latest OpenGIS requirements. Also, operations over geometry features were added.</source>
          <target state="translated">가장 최근의 코드 변경은 OpenGIS 요구 사항을 충족시키기위한 것입니다. 이전 버전에서 놓친 것 중 하나는 공간 관계를 검사하는 함수가 객체의 실제 모양을 고려하지 않고 경계 사각형에서만 작동한다는 것입니다. 이러한 레거시 기능은 그대로 유지되며 새롭고 올바르게 작동하는 기능은 최신 OpenGIS 요구 사항에 따라 ' &lt;code&gt;ST_&lt;/code&gt; '접두어 로 이름이 지정됩니다 . 또한 형상 피쳐에 대한 작업이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="ea91230350e0906dbe81a37c3766c32a9534ca9d" translate="yes" xml:space="preserve">
          <source>The most recent changes in the code are aimed at meeting the OpenGIS requirements. One thing missing in the present version is that the functions which check spatial relations don't consider the actual shape of an object, instead they operate only on their bounding rectangles. These legacy functions have been left as they are, and new, properly-working functions are named with an '&lt;code&gt;ST_&lt;/code&gt;' prefix, in accordance with the last OpenGIS requirements. Also, operations over geometry features were added.</source>
          <target state="translated">가장 최근의 코드 변경은 OpenGIS 요구 사항을 충족시키기위한 것입니다. 현재 버전에서 누락 된 한 가지는 공간 관계를 검사하는 함수가 객체의 실제 모양을 고려하지 않고 경계 사각형에서만 작동한다는 것입니다. 이러한 레거시 기능은 그대로 유지되었으며 새롭고 올바르게 작동하는 기능은 마지막 OpenGIS 요구 사항에 따라 ' &lt;code&gt;ST_&lt;/code&gt; '접두어 로 이름이 지정됩니다 . 또한 형상 피쳐에 대한 작업이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="f8927ee8bf703e3c5b867b5f001dbef19da30ee7" translate="yes" xml:space="preserve">
          <source>The most recent release of &lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; is:</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-103/index&quot;&gt;MariaDB 10.3&lt;/a&gt; 의 최신 릴리스 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f1bf3d1fa5cc7c5ae8dffc0b736f3c0e8bbdff89" translate="yes" xml:space="preserve">
          <source>The most recent release of &lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt; is:</source>
          <target state="translated">&lt;a href=&quot;../what-is-mariadb-104/index&quot;&gt;MariaDB 10.4&lt;/a&gt; 의 최신 릴리스 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="510aad29aeb4b28db25f8aa1182503a1d82745a9" translate="yes" xml:space="preserve">
          <source>The most simple way to cause SELinux to allow outbound HTTPS connections from MariaDB is to enable to mysql_connect_any boolean, like this:</source>
          <target state="translated">SELinux가 MariaDB의 아웃 바운드 HTTPS 연결을 허용하는 가장 간단한 방법은 다음과 같이 mysql_connect_any 부울을 활성화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3379af220fcdc1bd7dea090776d1ea12c75daf12" translate="yes" xml:space="preserve">
          <source>The mtr driver has special support for MariaDB plugins.</source>
          <target state="translated">mtr 드라이버는 MariaDB 플러그인을 특별히 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c6f1c4e5d0365e1c28a556c68d7a5fe6cf0e3085" translate="yes" xml:space="preserve">
          <source>The mysql Database</source>
          <target state="translated">MySQL 데이터베이스</target>
        </trans-unit>
        <trans-unit id="bd412e0195717874e51832ae5b89126546403e9b" translate="yes" xml:space="preserve">
          <source>The mysql Database Tables</source>
          <target state="translated">mysql 데이터베이스 테이블</target>
        </trans-unit>
        <trans-unit id="7dd9a5a9623b88f3384007c9667913d6fc74db54" translate="yes" xml:space="preserve">
          <source>The mysql command-line client</source>
          <target state="translated">mysql 명령 행 클라이언트</target>
        </trans-unit>
        <trans-unit id="a3740638af6da717930814af0a7d7581b05e246c" translate="yes" xml:space="preserve">
          <source>The mysql command-line client.</source>
          <target state="translated">mysql 명령 행 클라이언트.</target>
        </trans-unit>
        <trans-unit id="4acd76bccc60ca4595e4c55eb4092ebe88d3d751" translate="yes" xml:space="preserve">
          <source>The mysql-test framework utilizes many other files that affect the testing process, in addition to test and result files.</source>
          <target state="translated">mysql-test 프레임 워크는 테스트 및 결과 파일 외에도 테스트 프로세스에 영향을 미치는 다른 많은 파일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4016919673a0ef4a689902f6648bc8f2eed9d850" translate="yes" xml:space="preserve">
          <source>The mysql-test-run Stop File</source>
          <target state="translated">mysql-test-run 중지 파일</target>
        </trans-unit>
        <trans-unit id="085f2d790f9f945baf5dc9e88dd23b336d1a771e" translate="yes" xml:space="preserve">
          <source>The mysql.proc schema</source>
          <target state="translated">mysql.proc 스키마</target>
        </trans-unit>
        <trans-unit id="43ac9e3df7fca97b9051580154c7f63761894133" translate="yes" xml:space="preserve">
          <source>The mysql_history File</source>
          <target state="translated">mysql_history 파일</target>
        </trans-unit>
        <trans-unit id="f1e14709ebce2bf917a111d95140069a22f3786a" translate="yes" xml:space="preserve">
          <source>The mysql_old_password authentication plugin uses the pre-MySQL 4.1 password hashing algorithm.</source>
          <target state="translated">mysql_old_password 인증 플러그인은 MySQL 4.1 이전 비밀번호 해싱 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a6acfa17d9e269d600b11f38f49fb5a52649a42d" translate="yes" xml:space="preserve">
          <source>The mysqld binary to be used. Note that you can also specify &lt;a href=&quot;../mysqld_safe/index&quot;&gt;mysqld_safe&lt;/a&gt; as the value for this option. If you use mysqld_safe to start the server, you can include the &lt;code&gt;mysqld&lt;/code&gt; or &lt;code&gt;ledir&lt;/code&gt; options in the corresponding &lt;code&gt;[mysqldN]&lt;/code&gt; option group. These options indicate the name of the server that mysqld_safe should start and the path name of the directory where the server is located. Example:</source>
          <target state="translated">사용될 mysqld 바이너리. 이 옵션의 값으로 &lt;a href=&quot;../mysqld_safe/index&quot;&gt;mysqld_safe&lt;/a&gt; 를 지정할 수도 있습니다. mysqld_safe를 사용하여 서버를 시작하는 경우 해당 &lt;code&gt;[mysqldN]&lt;/code&gt; 옵션 그룹 에 &lt;code&gt;mysqld&lt;/code&gt; 또는 &lt;code&gt;ledir&lt;/code&gt; 옵션을 포함시킬 수 있습니다 . 이 옵션은 mysqld_safe가 시작해야하는 서버 이름과 서버가 위치한 디렉토리의 경로 이름을 나타냅니다. 예:</target>
        </trans-unit>
        <trans-unit id="88eb0c2249b5093ee8189d9778eab7e766100577" translate="yes" xml:space="preserve">
          <source>The naive way to execute the above is to</source>
          <target state="translated">위를 실행하는 순진한 방법은</target>
        </trans-unit>
        <trans-unit id="313a56890c0125b141fa63fbaedccd647e270387" translate="yes" xml:space="preserve">
          <source>The name of a column.</source>
          <target state="translated">열의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d070e546d092a0dde8758c3ccd667f09b6572f9f" translate="yes" xml:space="preserve">
          <source>The name of an option file to be read in addition to the usual option files. This must be the first option on the command line if it is used. If the file does not exist or is otherwise inaccessible, the server will exit with an error.</source>
          <target state="translated">일반적인 옵션 파일 외에 읽을 옵션 파일의 이름입니다. 이것이 사용되는 경우 명령 행에서 첫 번째 옵션이어야합니다. 파일이 존재하지 않거나 액세스 할 수 없으면 서버가 오류와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="568bd470c23ad4d9e02ee5a7ff490cafcb17a9d7" translate="yes" xml:space="preserve">
          <source>The name of an option file to be read instead of the usual option files. This must be the first option on the command line if it is used.</source>
          <target state="translated">일반적인 옵션 파일 대신 읽을 옵션 파일의 이름입니다. 이것이 사용되는 경우 명령 행에서 첫 번째 옵션이어야합니다.</target>
        </trans-unit>
        <trans-unit id="0fdd062d81ef17ec8e3c70c1d16da1d612135e64" translate="yes" xml:space="preserve">
          <source>The name of the Mariabackup executable that performed the backup. This is generally &lt;code&gt;mariabackup&lt;/code&gt;.</source>
          <target state="translated">백업을 수행 한 Mariabackup 실행 파일의 이름입니다. 이것은 일반적으로 &lt;code&gt;mariabackup&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="07aea1ecfec91ea61fc4ff64409e45a94b717b3f" translate="yes" xml:space="preserve">
          <source>The name of the SPECIAL column that set this column value.</source>
          <target state="translated">이 열 값을 설정 한 SPECIAL 열의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b761f052acbdf69d84ddc88a8d560f158ccc0df6" translate="yes" xml:space="preserve">
          <source>The name of the aggregate function used for the data columns, SUM by default.</source>
          <target state="translated">데이터 열에 사용 된 집계 함수의 이름이며 기본적으로 SUM입니다.</target>
        </trans-unit>
        <trans-unit id="7dd004f20876c1f1ffa7b8f94d703fb3f9189e6d" translate="yes" xml:space="preserve">
          <source>The name of the database containing the source table. Defaults to the current database.</source>
          <target state="translated">소스 테이블이 포함 된 데이터베이스의 이름입니다. 현재 데이터베이스가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="6686054cc4507fea80c14cb7768bd3bcdc45164b" translate="yes" xml:space="preserve">
          <source>The name of the federated server or server host used by a MYSQL table. &amp;ldquo;ODBC&amp;rdquo; for an ODBC table, &quot;JDBC&quot; for a JDBC table and &amp;ldquo;Current&amp;rdquo; for all other tables.</source>
          <target state="translated">MYSQL 테이블에서 사용하는 연합 서버 또는 서버 호스트의 이름입니다. ODBC 테이블의 경우 &quot;ODBC&quot;, JDBC 테이블의 경우 &quot;JDBC&quot;, 기타 모든 테이블의 경우 &quot;현재&quot;</target>
        </trans-unit>
        <trans-unit id="028a3fb77cc61b06353208428e4c1d56ab01bde5" translate="yes" xml:space="preserve">
          <source>The name of the key cache</source>
          <target state="translated">키 캐시의 이름</target>
        </trans-unit>
        <trans-unit id="0895f83422dfc8414e50456c74ffef26bdfcb353" translate="yes" xml:space="preserve">
          <source>The name of the key that is used to retrieve rows. &lt;code&gt;NULL&lt;/code&gt; is no key was used.</source>
          <target state="translated">행을 검색하는 데 사용되는 키의 이름입니다. &lt;code&gt;NULL&lt;/code&gt; 이 사용 된 키가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b0540049b89d69cc273b86ee60849000ff1a82ed" translate="yes" xml:space="preserve">
          <source>The name of the partition this row belongs to. Specific to partitioned tables.</source>
          <target state="translated">이 행이 속한 파티션의 이름입니다. 파티션 된 테이블에만 해당합니다.</target>
        </trans-unit>
        <trans-unit id="55c073def6e58b831d03e16b1cfadae287d06032" translate="yes" xml:space="preserve">
          <source>The name of the property</source>
          <target state="translated">재산의 이름</target>
        </trans-unit>
        <trans-unit id="37c67138976a4e76b50807f9296f3df8530d2fd9" translate="yes" xml:space="preserve">
          <source>The name of the server program (in the ledir directory) that you want to start. This option is needed if you use the MariaDB binary distribution but have the data directory outside of the binary distribution. If mysqld_safe cannot find the server, use the &lt;code&gt;--ledir&lt;/code&gt; option to indicate the path name to the directory where the server is located.</source>
          <target state="translated">시작하려는 서버 프로그램의 이름 (ledir 디렉토리에 있음). MariaDB 이진 배포를 사용하지만 이진 배포 외부에 데이터 디렉토리가있는 경우이 옵션이 필요합니다. mysqld_safe가 서버를 찾지 못하면 &lt;code&gt;--ledir&lt;/code&gt; 옵션을 사용 하여 서버가있는 디렉토리의 경로 이름을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="6bcfe280d9b8b6318d5b5a6245bd0d8a2da6a1ef" translate="yes" xml:space="preserve">
          <source>The name of the standard or standards body that is being cited for this reference system.</source>
          <target state="translated">이 참조 시스템에 인용 된 표준 기관의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="33e6aed29991ed6f3481229ca1f00f048c480c4a" translate="yes" xml:space="preserve">
          <source>The name of the table can be arbitrary. However, primary key, column names, and types must &quot;match&quot; those of Cassandra.</source>
          <target state="translated">테이블 이름은 임의적 일 수 있습니다. 그러나 기본 키, 열 이름 및 유형은 Cassandra의 기본 키, 열 이름 및 유형과 &quot;일치&quot;해야합니다.</target>
        </trans-unit>
        <trans-unit id="f1eab2e6e01f44f0069e954193464396413e2298" translate="yes" xml:space="preserve">
          <source>The name of the table this row belongs to. Useful for TBL tables.</source>
          <target state="translated">이 행이 속한 테이블의 이름입니다. TBL 테이블에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="11176c24973303075143a3a9c3dcd1cacd8cff55" translate="yes" xml:space="preserve">
          <source>The name of the table to &amp;ldquo;pivot&amp;rdquo;. If not set SrcDef must be specified.</source>
          <target state="translated">피벗 할 테이블의 이름입니다. 설정하지 않으면 SrcDef를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b9903f9730a4a3bc407099b3feba81f7127c645" translate="yes" xml:space="preserve">
          <source>The name of the table to access.</source>
          <target state="translated">액세스 할 테이블의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5a2ec87498587ff0c215fbb2a7c4d394080c643c" translate="yes" xml:space="preserve">
          <source>The native &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpool&quot;&gt;CreateThreadpool&lt;/a&gt;&lt;/code&gt; API allows applications to set the minimum and maximum number of threads in the pool. The following system variables can be used to configure those values on Windows:</source>
          <target state="translated">기본 &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/api/threadpoolapiset/nf-threadpoolapiset-createthreadpool&quot;&gt;CreateThreadpool&lt;/a&gt;&lt;/code&gt; API를 사용하면 응용 프로그램에서 풀의 최소 및 최대 스레드 수를 설정할 수 있습니다. 다음 시스템 변수를 사용하여 Windows에서 해당 값을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="512c8371f7ea455b136948156b3684c3c629337f" translate="yes" xml:space="preserve">
          <source>The negative form &lt;a href=&quot;../not-regexp/index&quot;&gt;NOT REGEXP&lt;/a&gt; also exists, as an alias for &lt;code&gt;NOT (string REGEXP pattern)&lt;/code&gt;. RLIKE and NOT RLIKE are synonyms for REGEXP and NOT REGEXP, originally provided for mSQL compatibility.</source>
          <target state="translated">&lt;code&gt;NOT (string REGEXP pattern)&lt;/code&gt; 의 별칭으로 &lt;a href=&quot;../not-regexp/index&quot;&gt;NOT REGEXP&lt;/a&gt; 음수 형식 도 존재합니다 . RLIKE 및 NOT RLIKE는 원래 mSQL 호환성을 위해 제공되는 REGEXP 및 NOT REGEXP의 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="e4693e51c88a9c380a915f6fa7743d20ae44a110" translate="yes" xml:space="preserve">
          <source>The new buffer pool size must be a multiple of &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_chunk_size&quot;&gt;innodb_buffer_pool_chunk_size&lt;/a&gt; * &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_instances&quot;&gt;innodb_buffer_pool_instances&lt;/a&gt;. If you attempt to set a different figure, the value is automatically adjusted to a multiple of at least the attempted size. Note that adjusting the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_chunk_size&quot;&gt;innodb_buffer_pool_chunk_size&lt;/a&gt; setting can result in a change in the buffer pool size.</source>
          <target state="translated">새 버퍼 풀 크기는 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_chunk_size&quot;&gt;innodb_buffer_pool_chunk_size&lt;/a&gt; * &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_instances&quot;&gt;innodb_buffer_pool_instances&lt;/a&gt; 의 배수 여야합니다 . 다른 그림을 설정하려고하면 값이 최소한 시도한 크기의 배수로 자동 조정됩니다. &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_chunk_size&quot;&gt;innodb_buffer_pool_chunk_size&lt;/a&gt; 설정 을 조정하면 버퍼 풀 크기가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="280f794d354a3dbe6309c1d08c31de7177998cc8" translate="yes" xml:space="preserve">
          <source>The new key file would look something like the following after this step:</source>
          <target state="translated">이 단계 후에 새 키 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="915d835a3470da9a58dbbc78f18239a5227bbd93" translate="yes" xml:space="preserve">
          <source>The new node only needs to connect to one of the existing cluster nodes. Once it connects to one of the existing cluster nodes, it will be able to see all of the nodes in the cluster. However, it is generally better to list all nodes of the cluster in &lt;code&gt;&lt;a href=&quot;../galera-cluster-system-variables/index#wsrep_cluster_address&quot;&gt;wsrep_cluster_address&lt;/a&gt;&lt;/code&gt;, so that any node can join a cluster by connecting to any of the other cluster nodes, even if one or more of the cluster nodes are down. It is even OK to list a node's own IP address in &lt;code&gt;&lt;a href=&quot;../galera-cluster-system-variables/index#wsrep_cluster_address&quot;&gt;wsrep_cluster_address&lt;/a&gt;&lt;/code&gt;, since Galera Cluster is smart enough to ignore it.</source>
          <target state="translated">새 노드는 기존 클러스터 노드 중 하나에 만 연결하면됩니다. 기존 클러스터 노드 중 하나에 연결되면 클러스터의 모든 노드를 볼 수 있습니다. 그러나 일반적으로 &lt;code&gt;&lt;a href=&quot;../galera-cluster-system-variables/index#wsrep_cluster_address&quot;&gt;wsrep_cluster_address&lt;/a&gt;&lt;/code&gt; 에 클러스터의 모든 노드를 나열하는 것이 좋습니다. . 따라서 하나 이상의 클러스터 노드가 작동 중지 된 경우에도 모든 노드가 다른 클러스터 노드에 연결하여 클러스터에 참여할 수 있습니다. Galera Cluster는이를 무시할만큼 똑똑하기 때문에 &lt;code&gt;&lt;a href=&quot;../galera-cluster-system-variables/index#wsrep_cluster_address&quot;&gt;wsrep_cluster_address&lt;/a&gt;&lt;/code&gt; 에 노드 고유의 IP 주소를 나열 해도됩니다.</target>
        </trans-unit>
        <trans-unit id="68d2c2d81c8e29767ce218e33357a22a4001cf65" translate="yes" xml:space="preserve">
          <source>The new replication variable &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#default_master_connection&quot;&gt;default_master_connection&lt;/a&gt; specifies which connection will be used for commands and variables if you don't specify a connection. By default this is &lt;code&gt;''&lt;/code&gt; (the default connection name).</source>
          <target state="translated">새로운 복제 변수 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#default_master_connection&quot;&gt;default_master_connection&lt;/a&gt; 은 연결을 지정하지 않은 경우 명령 및 변수에 사용될 연결을 지정합니다. 기본적으로 이것은 &lt;code&gt;''&lt;/code&gt; (기본 연결 이름)입니다.</target>
        </trans-unit>
        <trans-unit id="c4af01baa5ae40b13b7b6f1e15f70b157b5d6698" translate="yes" xml:space="preserve">
          <source>The new slave can then start replicating from the master by setting the correct value for &lt;code&gt;&lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt;, and then executing &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER&lt;/a&gt;&lt;/code&gt; with the relevant values for the master, and then starting the &lt;a href=&quot;../replication-threads/index#threads-on-the-slave&quot;&gt;slave threads&lt;/a&gt; by executing &lt;code&gt;&lt;a href=&quot;../start-slave/index&quot;&gt;START SLAVE&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">그런 다음 새 슬레이브는 &lt;code&gt;&lt;a href=&quot;#gtid_slave_pos&quot;&gt;gtid_slave_pos&lt;/a&gt;&lt;/code&gt; 에 올바른 값을 설정 한 다음 &lt;code&gt;&lt;a href=&quot;../change-master-to/index&quot;&gt;CHANGE MASTER&lt;/a&gt;&lt;/code&gt; 에 대한 관련 값으로 CHANGE MASTER 를 실행 한 다음 &lt;code&gt;&lt;a href=&quot;../start-slave/index&quot;&gt;START SLAVE&lt;/a&gt;&lt;/code&gt; 를 실행 하여 &lt;a href=&quot;../replication-threads/index#threads-on-the-slave&quot;&gt;슬레이브 스레드&lt;/a&gt; 를 시작하여 마스터에서 복제를 시작할 수 있습니다. . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41eb7475358c8fb58664999843f12c37149b687b" translate="yes" xml:space="preserve">
          <source>The new syntax introduced to handle many connections:</source>
          <target state="translated">많은 연결을 처리하기 위해 도입 된 새로운 구문 :</target>
        </trans-unit>
        <trans-unit id="1dd54c8579fd3a049fa56ed2efef10f09c787711" translate="yes" xml:space="preserve">
          <source>The new variant would be ?topic=xyz&amp;amp;id=12345&amp;amp;limit=10. (Note: the 12345 is not computable from 4999.) By using INDEX(topic, id) you can efficiently say</source>
          <target state="translated">새로운 변형은? topic = xyz &amp;amp; id = 12345 &amp;amp; limit = 10입니다. (참고 : 12345는 4999에서 계산할 수 없습니다.) INDEX (topic, id)를 사용하면 효율적으로 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b0bcdd1c86463ce676938c7fb4f9ba3668d0473" translate="yes" xml:space="preserve">
          <source>The newline convention can be set by starting a pattern with one of the following sequences:</source>
          <target state="translated">개행 규칙은 다음 순서 중 하나를 사용하여 패턴을 시작하여 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c26263c47c02ab7cfe217caa1a7a1f17e7033580" translate="yes" xml:space="preserve">
          <source>The newline conversion affects the &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; assertions, the interpretation of the dot metacharacter, and the behavior of &lt;code&gt;\N&lt;/code&gt;.</source>
          <target state="translated">줄 바꿈 변환은 &lt;code&gt;^&lt;/code&gt; 및 &lt;code&gt;$&lt;/code&gt; 어설 션, 도트 메타 문자 해석 및 &lt;code&gt;\N&lt;/code&gt; 동작에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="0c29cf271f82ad40649ee91e053053a32b0aafe3" translate="yes" xml:space="preserve">
          <source>The next 4 bytes indicate the geometry type. Values from 1 to 7 indicate whether the type is Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, or GeometryCollection respectively.</source>
          <target state="translated">다음 4 바이트는 지오메트리 유형을 나타냅니다. 1에서 7까지의 값은 유형이 각각 Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon 또는 GeometryCollection인지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="24f986c46c1421e1ae442e1e7a8c8a5d6857dc35" translate="yes" xml:space="preserve">
          <source>The next section (&quot;Performance&quot;) should make this a bit clearer as it walks through some examples.</source>
          <target state="translated">다음 섹션 ( &quot;성능&quot;)에서는 몇 가지 예를 살펴보면서이 부분을 좀 더 명확하게 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="f10cd6fa1f61972b1cad983e806a1d016707a1b9" translate="yes" xml:space="preserve">
          <source>The next step would be to run the install script postConfigure, check the Single Server Or Multi-Server Install guide.</source>
          <target state="translated">다음 단계는 구성 후 post 설치 스크립트를 실행하는 것입니다. 단일 서버 또는 다중 서버 설치 안내서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="44edc5ae36ac1db08b37891883a83ae982e0c9f1" translate="yes" xml:space="preserve">
          <source>The next version of Aria is 2.0. The goal for this release is to develop a fully transactional storage engine with at least all the major features of InnoDB.</source>
          <target state="translated">다음 버전의 Aria는 2.0입니다. 이 릴리스의 목표는 최소한 InnoDB의 모든 주요 기능을 갖춘 완전한 트랜잭션 스토리지 엔진을 개발하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6e74f2b4a9ce733c135f85f2a51268d7eb4bb302" translate="yes" xml:space="preserve">
          <source>The nodes that store the data will be designed as &lt;code&gt;Backend Nodes&lt;/code&gt;, and can be any MariaDB, MySQL, Oracle server instances using any storage engine available inside the backend.</source>
          <target state="translated">데이터를 저장하는 노드는 &lt;code&gt;Backend Nodes&lt;/code&gt; 로 설계되며 백엔드 내부에서 사용 가능한 스토리지 엔진을 사용하는 모든 MariaDB, MySQL, Oracle 서버 인스턴스가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9bfbe59030aa4e52bd85ad99c848dde70cc3ea2" translate="yes" xml:space="preserve">
          <source>The non-atomic pattern matches both &lt;code&gt;abbc&lt;/code&gt; and &lt;code&gt;abc&lt;/code&gt;, while the atomic pattern matches &lt;code&gt;abbc&lt;/code&gt; only.</source>
          <target state="translated">비 원자 패턴은 &lt;code&gt;abbc&lt;/code&gt; 및 &lt;code&gt;abc&lt;/code&gt; 모두 와 일치하고 원자 패턴은 &lt;code&gt;abbc&lt;/code&gt; 와만 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="d0d453bdba545ba25cb0b9e29996d11631fd0d27" translate="yes" xml:space="preserve">
          <source>The non-file partial backup options support regex in the database and table names.</source>
          <target state="translated">비 파일 부분 백업 옵션은 데이터베이스 및 테이블 이름의 정규식을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0d01fc4eac0467e4d8f3a105091cd5c3db930663" translate="yes" xml:space="preserve">
          <source>The normal procedures to copy a table is:</source>
          <target state="translated">테이블을 복사하는 일반적인 절차는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7cabd1058e78bab05ad4eb141a72751b79e34560" translate="yes" xml:space="preserve">
          <source>The normal solution for this is to ignore the &lt;code&gt;my.cnf&lt;/code&gt; file in &lt;code&gt;/etc&lt;/code&gt; when you use the programs in the tar file.</source>
          <target state="translated">일반적인 해결책 은 tar 파일에서 프로그램을 사용할 때 &lt;code&gt;/etc&lt;/code&gt; 의 &lt;code&gt;my.cnf&lt;/code&gt; 파일 을 무시하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="dc0f37365f45f74b433f2d9f20d3f99586ddab92" translate="yes" xml:space="preserve">
          <source>The normal steps are:</source>
          <target state="translated">일반적인 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07765351a66ca661d755e670478afe03ed14930b" translate="yes" xml:space="preserve">
          <source>The normal way to count &quot;Unique Users&quot; is to take large log files, sort by userid, dedup, and count. This requires a rather large amount of processing. Furthermore, the count derived cannot be rolled up. That is, daily counts cannot be added to get weekly counts -- some users will be counted multiple times.</source>
          <target state="translated">&quot;고유 사용자&quot;를 계산하는 일반적인 방법은 큰 로그 파일을 가져 와서 userid, dedup 및 count로 정렬하는 것입니다. 이를 위해서는 다소 많은 처리가 필요합니다. 또한 파생 카운트를 롤업 할 수 없습니다. 즉, 주간 수를 얻기 위해 일일 수를 추가 할 수 없습니다. 일부 사용자는 여러 번 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="ac7fe142068a34f30465a1929d8415c599d536fc" translate="yes" xml:space="preserve">
          <source>The normal way to set up a new replication slave is to take a backup from an existing server (either a master or slave in the replication topology), and then restore that backup on the server acting as the new slave, and the configure it to start replicating from the appropriate position in the master's binary log.</source>
          <target state="translated">새로운 복제 슬레이브를 설정하는 일반적인 방법은 기존 서버 (복제 토폴로지의 마스터 또는 슬레이브)에서 백업을 수행 한 다음 새 슬레이브로 작동하는 서버에서 해당 백업을 복원하고이를 구성하는 것입니다. 마스터 이진 로그의 적절한 위치에서 복제를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="d7e908f25f6fb5864fa718b37c2ae2848aa41bc8" translate="yes" xml:space="preserve">
          <source>The notation with exponent can be used. The exponent is preceded by an &lt;code&gt;E&lt;/code&gt; or &lt;code&gt;e&lt;/code&gt; character. The exponent can be preceded by a sign and must be an integer. A number &lt;code&gt;N&lt;/code&gt; with an exponent part &lt;code&gt;X&lt;/code&gt;, is calculated as &lt;code&gt;N * POW(10, X)&lt;/code&gt;.</source>
          <target state="translated">지수 표기법을 사용할 수 있습니다. 지수 앞에는 &lt;code&gt;E&lt;/code&gt; 또는 &lt;code&gt;e&lt;/code&gt; 문자 가옵니다 . 지수 앞에 부호가 올 수 있으며 정수 여야합니다. 지수 부분 &lt;code&gt;X&lt;/code&gt; 가있는 숫자 &lt;code&gt;N&lt;/code&gt; 은 &lt;code&gt;N * POW(10, X)&lt;/code&gt; 로 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="271a09141846cedad76d3296b042e3a39a92951d" translate="yes" xml:space="preserve">
          <source>The novice, once he learns about indexing, decides to index lots of columns, one at a time. But...</source>
          <target state="translated">초보자는 인덱싱에 대해 알게되면 한 번에 하나씩 많은 열을 인덱싱하기로 결정합니다. 그러나...</target>
        </trans-unit>
        <trans-unit id="17e4267230cb37f552bd92b1f0fe68eefa6474a4" translate="yes" xml:space="preserve">
          <source>The number of &lt;a href=&quot;../secure-connections-overview/index&quot;&gt;TLS connections&lt;/a&gt; created for this client. (&amp;gt;= &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1011-release-notes/&quot;&gt;MariaDB 10.1.1&lt;/a&gt;)</source>
          <target state="translated">이 클라이언트에 대해 작성된 &lt;a href=&quot;../secure-connections-overview/index&quot;&gt;TLS 연결&lt;/a&gt; 수입니다 . (&amp;gt; = &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1011-release-notes/&quot;&gt;MariaDB 10.1.1&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="b5a0b2743092e6526c1158ee71688b28d101cbb6" translate="yes" xml:space="preserve">
          <source>The number of &lt;a href=&quot;../secure-connections/index&quot;&gt;TLS connections&lt;/a&gt; created for this user. (&amp;gt;= &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1011-release-notes/&quot;&gt;MariaDB 10.1.1&lt;/a&gt;)</source>
          <target state="translated">이 사용자에 대해 작성된 &lt;a href=&quot;../secure-connections/index&quot;&gt;TLS 연결&lt;/a&gt; 수입니다 . (&amp;gt; = &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1011-release-notes/&quot;&gt;MariaDB 10.1.1&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="e23235ef483cab42632f8dc87c213cbb8ed81c5f" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;&lt;a href=&quot;../commit/index&quot;&gt;COMMIT&lt;/a&gt;&lt;/code&gt; commands issued by this client's connections.</source>
          <target state="translated">이 클라이언트의 연결에 의해 발행 된 &lt;code&gt;&lt;a href=&quot;../commit/index&quot;&gt;COMMIT&lt;/a&gt;&lt;/code&gt; 명령 의 수</target>
        </trans-unit>
        <trans-unit id="84d2104908cde2a1a7e55bfdcbb6d8f1a5abf697" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;&lt;a href=&quot;../commit/index&quot;&gt;COMMIT&lt;/a&gt;&lt;/code&gt; commands issued by this user's connections.</source>
          <target state="translated">이 사용자의 연결에 의해 발행 된 &lt;code&gt;&lt;a href=&quot;../commit/index&quot;&gt;COMMIT&lt;/a&gt;&lt;/code&gt; 명령 의 수</target>
        </trans-unit>
        <trans-unit id="7bfac856034d1625f22249b310d22de8326b0e27" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;&lt;a href=&quot;../rollback/index&quot;&gt;ROLLBACK&lt;/a&gt;&lt;/code&gt; commands issued by this client's connections.</source>
          <target state="translated">이 클라이언트의 연결에서 발행 한 &lt;code&gt;&lt;a href=&quot;../rollback/index&quot;&gt;ROLLBACK&lt;/a&gt;&lt;/code&gt; 명령 수</target>
        </trans-unit>
        <trans-unit id="e4438e7879357a53122db3f533273e09af0b929d" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;&lt;a href=&quot;../rollback/index&quot;&gt;ROLLBACK&lt;/a&gt;&lt;/code&gt; commands issued by this user's connections.</source>
          <target state="translated">이 사용자의 연결에서 발행 한 &lt;code&gt;&lt;a href=&quot;../rollback/index&quot;&gt;ROLLBACK&lt;/a&gt;&lt;/code&gt; 명령 수</target>
        </trans-unit>
        <trans-unit id="e16943604729fc605439da52625decadb005e0c0" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; commands executed from this client's connections.</source>
          <target state="translated">이 클라이언트의 연결에서 실행 된 &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; 명령 수</target>
        </trans-unit>
        <trans-unit id="0c149c0b28e32382b0a0784e0e85e7434847dd5c" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; commands executed from this user's connections.</source>
          <target state="translated">이 사용자의 연결에서 실행 된 &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; 명령 수</target>
        </trans-unit>
        <trans-unit id="69ec66d8ede33cdf6239bba325dc2d543e475f34" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; commands executed from this client's connections.</source>
          <target state="translated">이 클라이언트의 연결에서 실행 된 &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; 명령 수</target>
        </trans-unit>
        <trans-unit id="d99426923310edfb18aea3cfb772a83428c1066c" translate="yes" xml:space="preserve">
          <source>The number of &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; commands executed from this user's connections.</source>
          <target state="translated">이 사용자의 연결에서 실행 된 &lt;code&gt;&lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt;&lt;/code&gt; 명령 수</target>
        </trans-unit>
        <trans-unit id="ff04bde030d176d200bf0abd0cc2a854b6a3528a" translate="yes" xml:space="preserve">
          <source>The number of Galera slave threads can be configured with the &lt;code&gt;&lt;a href=&quot;../galera-cluster-system-variables/index#wsrep_slave_threads&quot;&gt;wsrep_slave_threads&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">Galera 슬레이브 스레드 수는 &lt;code&gt;&lt;a href=&quot;../galera-cluster-system-variables/index#wsrep_slave_threads&quot;&gt;wsrep_slave_threads&lt;/a&gt;&lt;/code&gt; 시스템 변수 로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88806610df72783f9d84d77d168ee2a81d44ab26" translate="yes" xml:space="preserve">
          <source>The number of InnoDB page cleaner threads can be configured by setting the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_cleaners&quot;&gt;innodb_page_cleaners&lt;/a&gt;&lt;/code&gt; system variable. This system variable can be set in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; prior to starting up the server. For example:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_cleaners&quot;&gt;innodb_page_cleaners&lt;/a&gt;&lt;/code&gt; 시스템 변수를 설정하여 InnoDB 페이지 클리너 스레드 수를 구성 할 수 있습니다 . 이 시스템 변수는 서버 를 시작하기 전에 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 설정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="059923c2802f2aa513772dc3308d8d0e2084fe9b" translate="yes" xml:space="preserve">
          <source>The number of affected rows, or the result number of columns if the command would return a result set.</source>
          <target state="translated">명령이 결과 세트를 리턴하는 경우 영향을받는 행 수 또는 결과 열 수</target>
        </trans-unit>
        <trans-unit id="7e0395145806365e064548a00dcd5b2892fdc5ac" translate="yes" xml:space="preserve">
          <source>The number of bytes received from this client's connections.</source>
          <target state="translated">이 클라이언트의 연결에서받은 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="e50b4db21f57f038318c5866c0dd3c7e8d43617b" translate="yes" xml:space="preserve">
          <source>The number of bytes received from this user's connections.</source>
          <target state="translated">이 사용자의 연결에서받은 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="1a3ec1e1c35596161ef15b8a494c2f1a5e828019" translate="yes" xml:space="preserve">
          <source>The number of bytes sent to this client's connections.</source>
          <target state="translated">이 클라이언트의 연결로 전송 된 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="b2e675097abd387133fdce736ff08818c1ba198f" translate="yes" xml:space="preserve">
          <source>The number of bytes sent to this user's connections.</source>
          <target state="translated">이 사용자의 연결로 전송 된 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="882172bfcb455343f21f7088178c3409ff23acf1" translate="yes" xml:space="preserve">
          <source>The number of bytes written to the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; from this client's connections.</source>
          <target state="translated">이 클라이언트의 연결에서 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그에&lt;/a&gt; 기록 된 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="e0acfa0db203355d6be0ab19515c1ce15eedb258" translate="yes" xml:space="preserve">
          <source>The number of bytes written to the &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt; from this user's connections.</source>
          <target state="translated">이 사용자의 연결에서 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그에&lt;/a&gt; 기록 된 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="b151cdd067c8794e93adc9c1f216c1dad59767cf" translate="yes" xml:space="preserve">
          <source>The number of chunks as calculated by &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_size&quot;&gt;innodb_buffer_pool_size&lt;/a&gt; / &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_chunk_size&quot;&gt;innodb_buffer_pool_chunk_size&lt;/a&gt; should not exceed 1000 in order to avoid performance issues.</source>
          <target state="translated">&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_size&quot;&gt;innodb_buffer_pool_size&lt;/a&gt; / &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_buffer_pool_chunk_size&quot;&gt;innodb_buffer_pool_chunk_size에&lt;/a&gt; 의해 계산 된 청크 수는 성능 문제를 피하기 위해 1000을 초과하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="3965a35c93285609c280fbf2d64e97276926e3c7" translate="yes" xml:space="preserve">
          <source>The number of columns in the table</source>
          <target state="translated">테이블의 열 수</target>
        </trans-unit>
        <trans-unit id="f723cc1e485b1257047574cb5ea34a879a1f9bc4" translate="yes" xml:space="preserve">
          <source>The number of concurrent &lt;code&gt;INSERT DELAYED&lt;/code&gt; threads is limited by the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#max_delayed_threads&quot;&gt;max_delayed_threads&lt;/a&gt;&lt;/code&gt; server system variables. If it is set to 0, &lt;code&gt;INSERT DELAYED&lt;/code&gt; is disabled. The session value can be equal to the global value, or 0 to disable this statement for the current session. If this limit has been reached, the &lt;code&gt;DELAYED&lt;/code&gt; clause will be silently ignore for subsequent statements (no error will be produced).</source>
          <target state="translated">동시 &lt;code&gt;INSERT DELAYED&lt;/code&gt; 스레드 수는 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#max_delayed_threads&quot;&gt;max_delayed_threads&lt;/a&gt;&lt;/code&gt; 서버 시스템 변수에 의해 제한됩니다 . 0으로 설정하면 &lt;code&gt;INSERT DELAYED&lt;/code&gt; 가 비활성화됩니다. 세션 값은 글로벌 값과 같거나 현재 세션에 대해이 명령문을 사용하지 않으려면 0입니다. 이 한계에 도달하면 &lt;code&gt;DELAYED&lt;/code&gt; 절은 후속 명령문에 대해 자동으로 무시됩니다 (오류가 발생하지 않음).</target>
        </trans-unit>
        <trans-unit id="3d7698962b2c7e8c6420d64f0cd55437b3d36b36" translate="yes" xml:space="preserve">
          <source>The number of concurrent connections for this client.</source>
          <target state="translated">이 클라이언트에 대한 동시 연결 수</target>
        </trans-unit>
        <trans-unit id="1c2e4379b267211f353cca00750d8d0b6e15ddd5" translate="yes" xml:space="preserve">
          <source>The number of concurrent connections for this user.</source>
          <target state="translated">이 사용자에 대한 동시 연결 수입니다.</target>
        </trans-unit>
        <trans-unit id="275339691ffc35f423c577e138dfa627ca42d9c5" translate="yes" xml:space="preserve">
          <source>The number of connection attempts is limited by the &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-master-retry-count&quot;&gt;master_retry_count&lt;/a&gt;&lt;/code&gt; option. It can be set either on the command-line or in a server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; prior to starting up the server. For example:</source>
          <target state="translated">연결 시도 횟수는 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index#-master-retry-count&quot;&gt;master_retry_count&lt;/a&gt;&lt;/code&gt; 옵션에 의해 제한됩니다 . 서버 를 시작하기 전에 명령 행 또는 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 설정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e801f0be9e3156dc4d36caf50911dc1c5813df72" translate="yes" xml:space="preserve">
          <source>The number of connections created for this client.</source>
          <target state="translated">이 클라이언트에 대해 작성된 연결 수입니다.</target>
        </trans-unit>
        <trans-unit id="03612f0859ced285a3ac5554d22c7ff6ededf5d3" translate="yes" xml:space="preserve">
          <source>The number of connections created for this user.</source>
          <target state="translated">이 사용자에 대해 작성된 연결 수입니다.</target>
        </trans-unit>
        <trans-unit id="06e87db72077d0c6c4ee6c235ed5dc8a2b8fcc13" translate="yes" xml:space="preserve">
          <source>The number of connections denied to this client.</source>
          <target state="translated">이 클라이언트에 대한 연결 수가 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="b3585be08cf86ee6d39e6e831533d91272b89658" translate="yes" xml:space="preserve">
          <source>The number of connections denied to this user.</source>
          <target state="translated">이 사용자에게 거부 된 연결 수입니다.</target>
        </trans-unit>
        <trans-unit id="aec1954f85764b7a725f4d9fea5dd67f3dbfece8" translate="yes" xml:space="preserve">
          <source>The number of decimals displayed for all float columns is the column precision, the second argument of the column type option. Of course, integer columns have no decimals, although their formats specify some.</source>
          <target state="translated">모든 float 열에 대해 표시되는 소수 자릿수는 열 정밀도이며 열 유형 옵션의 두 번째 인수입니다. 물론 정수 열에는 소수가 없지만 형식에는 일부가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f87520fcd27bf3e64f9e6cc2db2ad2272917156" translate="yes" xml:space="preserve">
          <source>The number of decimals, defaults to the column precision</source>
          <target state="translated">소수점 이하 자릿수, 기본값은 열 정밀도입니다</target>
        </trans-unit>
        <trans-unit id="4d4cc683c593a1738c956da1c931dc7d6718f113" translate="yes" xml:space="preserve">
          <source>The number of defined partitions can be optionally specified as &lt;code&gt;PARTITION count&lt;/code&gt;. This can be done to avoid specifying all partitions individually. But you can also declare each individual partition and, additionally, specify a &lt;code&gt;PARTITIONS count&lt;/code&gt; clause; in the case, the number of &lt;code&gt;PARTITION&lt;/code&gt;s must equal count.</source>
          <target state="translated">정의 된 파티션 수는 &lt;code&gt;PARTITION count&lt;/code&gt; 로 선택적으로 지정할 수 있습니다 . 모든 파티션을 개별적으로 지정하지 않도록하기 위해 수행 할 수 있습니다. 그러나 각 개별 파티션을 선언하고 &lt;code&gt;PARTITIONS count&lt;/code&gt; 절을 추가로 지정할 수도 있습니다. 이 경우 &lt;code&gt;PARTITION&lt;/code&gt; 수는 count와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="9c7c246e150980fb266af243664d5d7bb26c57c9" translate="yes" xml:space="preserve">
          <source>The number of fields in &lt;code&gt;cur&lt;/code&gt; must match the number of fields in &lt;code&gt;rec&lt;/code&gt;. Otherwise, an error is reported.</source>
          <target state="translated">필드의 수 &lt;code&gt;cur&lt;/code&gt; 필드의 수와 일치해야합니다 &lt;code&gt;rec&lt;/code&gt; . 그렇지 않으면 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="4ac82ffa16f4c0eee4256654f609ce3f51932165" translate="yes" xml:space="preserve">
          <source>The number of files that mysqld should be able to open. The option value is passed to ulimit -n. Note that you need to start mysqld_safe as root for this to work properly.</source>
          <target state="translated">mysqld가 열 수있는 파일 수. 옵션 값은 ulimit -n으로 전달됩니다. 제대로 작동하려면 mysqld_safe를 루트로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="58706b0364e8e1fd72717060173cd4de6c9c6879" translate="yes" xml:space="preserve">
          <source>The number of modified databases exceeds the maximum %d; the database names will not be included in the replication event metadata.</source>
          <target state="translated">수정 된 데이터베이스 수가 최대 % d을 (를) 초과합니다. 데이터베이스 이름은 복제 이벤트 메타 데이터에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="500228c34936074443a308f4418cfd4c496cf784" translate="yes" xml:space="preserve">
          <source>The number of other commands executed from this client's connections.</source>
          <target state="translated">이 클라이언트의 연결에서 실행 된 다른 명령의 수입니다.</target>
        </trans-unit>
        <trans-unit id="a6ae8da6ffffb749fa2835b348bc3cfd1958d5c4" translate="yes" xml:space="preserve">
          <source>The number of other commands executed from this user's connections.</source>
          <target state="translated">이 사용자의 연결에서 실행 된 다른 명령의 수입니다.</target>
        </trans-unit>
        <trans-unit id="2320209d76fe953046a32b392a1a43312b45ba65" translate="yes" xml:space="preserve">
          <source>The number of permitted recursive calls is limited to &lt;a href=&quot;../server-system-variables/index#max_sp_recursion_depth&quot;&gt;max_sp_recursion_depth&lt;/a&gt;. If this variable is 0 (default), recursivity is disabled. The limit does not apply to stored functions.</source>
          <target state="translated">허용되는 재귀 호출 수는 &lt;a href=&quot;../server-system-variables/index#max_sp_recursion_depth&quot;&gt;max_sp_recursion_depth&lt;/a&gt; 로 제한됩니다 . 이 변수가 0 (기본값)이면 재귀가 비활성화됩니다. 저장된 기능에는 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d13cc7d6876fc68faf2103ad7825e06f135b7914" translate="yes" xml:space="preserve">
          <source>The number of purge threads can be set by configuring the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_purge_threads&quot;&gt;innodb_purge_threads&lt;/a&gt;&lt;/code&gt; system variable. This system variable can be specified as a command-line argument to &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; or it can be specified in a relevant server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. For example:</source>
          <target state="translated">퍼지 스레드 수는 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_purge_threads&quot;&gt;innodb_purge_threads&lt;/a&gt;&lt;/code&gt; 시스템 변수를 구성하여 설정할 수 있습니다 . 이 시스템 변수는 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 에 대한 명령 행 인수로 지정 하거나 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 관련 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 지정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6d9f7b823b487b939ecdefb73e1e95abfb1344a" translate="yes" xml:space="preserve">
          <source>The number of records is limited by the value of the &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_max_changed_pages&quot;&gt;innodb_max_changed_pages&lt;/a&gt; system variable.</source>
          <target state="translated">레코드 수는 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_max_changed_pages&quot;&gt;innodb_max_changed_pages&lt;/a&gt; 시스템 변수 의 값으로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a6938d5a7180fb787842848cfcb87384335e64f" translate="yes" xml:space="preserve">
          <source>The number of records will match the value set in the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_undo_logs&quot;&gt;innodb_undo_logs&lt;/a&gt;&lt;/code&gt; variable (by default 128).</source>
          <target state="translated">레코드 수는 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_undo_logs&quot;&gt;innodb_undo_logs&lt;/a&gt;&lt;/code&gt; 변수 (기본값 128)에 설정된 값과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="2b06fe58dd6176b1826df43b766ade6cd6c52aeb" translate="yes" xml:space="preserve">
          <source>The number of redo log files is configured by the &lt;a href=&quot;../innodb-system-variables/index#innodb_log_files_in_group&quot;&gt;innodb_log_files_in_group&lt;/a&gt; system variable.</source>
          <target state="translated">재실행 로그 파일 수는 &lt;a href=&quot;../innodb-system-variables/index#innodb_log_files_in_group&quot;&gt;innodb_log_files_in_group&lt;/a&gt; 시스템 변수로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="4cd1fa42f8b2797a09890f55cd814e9be4c0e2c8" translate="yes" xml:space="preserve">
          <source>The number of rows affected by the slow query have been recorded in the slow query log since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1012-release-notes/&quot;&gt;MariaDB 10.1.2&lt;/a&gt;.</source>
          <target state="translated">느린 쿼리의 영향을받는 행 수는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1012-release-notes/&quot;&gt;MariaDB 10.1.2&lt;/a&gt; 이후 느린 쿼리 로그에 기록되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e6d24e1165d0a19793ee08ad4364781ffcacc5d6" translate="yes" xml:space="preserve">
          <source>The number of rows changed in the table, multiplied by the number of indexes changed.</source>
          <target state="translated">테이블에서 변경된 행 수에 변경된 인덱스 수를 곱한 값입니다.</target>
        </trans-unit>
        <trans-unit id="790ffd4df5d6f9a203c6f7f70e4bbbf65c18b1bf" translate="yes" xml:space="preserve">
          <source>The number of rows changed in the table.</source>
          <target state="translated">테이블에서 변경된 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="a10f42eda95d0b9d39ef4e9a71d432a60b3e146c" translate="yes" xml:space="preserve">
          <source>The number of rows deleted by this client's connections.</source>
          <target state="translated">이 클라이언트의 연결에 의해 삭제 된 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="526607b8b5b44b7fc5523384644470fc1a37584f" translate="yes" xml:space="preserve">
          <source>The number of rows deleted by this user's connections.</source>
          <target state="translated">이 사용자의 연결에 의해 삭제 된 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="ff28c27234f0be811f0ba485d26113c06551acb9" translate="yes" xml:space="preserve">
          <source>The number of rows each block of a &lt;a href=&quot;../connect-dos-and-fix-table-types/index&quot;&gt;FIX&lt;/a&gt;, &lt;a href=&quot;../connect-bin-table-type/index&quot;&gt;BIN&lt;/a&gt;, &lt;a href=&quot;../connect-dbf-table-type/index&quot;&gt;DBF&lt;/a&gt;, or &lt;a href=&quot;../connect-vec-table-type/index&quot;&gt;VEC&lt;/a&gt; table contains. For an &lt;a href=&quot;../connect-table-types-odbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;ODBC&lt;/a&gt; table this is the RowSet size option. For a &lt;a href=&quot;../connect-jdbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;JDBC&lt;/a&gt; table this is the fetch size.</source>
          <target state="translated">&lt;a href=&quot;../connect-dos-and-fix-table-types/index&quot;&gt;FIX&lt;/a&gt; , &lt;a href=&quot;../connect-bin-table-type/index&quot;&gt;BIN&lt;/a&gt; , &lt;a href=&quot;../connect-dbf-table-type/index&quot;&gt;DBF&lt;/a&gt; 또는 &lt;a href=&quot;../connect-vec-table-type/index&quot;&gt;VEC&lt;/a&gt; 테이블 의 각 블록에 포함 된 행 수입니다 . 를 들어 &lt;a href=&quot;../connect-table-types-odbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;ODBC의&lt;/a&gt; 표는 행 집합 크기 옵션입니다. A에 대한 &lt;a href=&quot;../connect-jdbc-table-type-accessing-tables-from-other-dbms/index&quot;&gt;JDBC의&lt;/a&gt; 표는 크기를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c7dc335245133caffb8833e07e0d7ed19068c4b" translate="yes" xml:space="preserve">
          <source>The number of rows inserted by this client's connections.</source>
          <target state="translated">이 클라이언트의 연결에 의해 삽입 된 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="f2809ea49af8e13b78533c7443d02ac374c08f60" translate="yes" xml:space="preserve">
          <source>The number of rows inserted by this user's connections.</source>
          <target state="translated">이 사용자의 연결에 의해 삽입 된 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="fef13e0d0359a4b0c3dc725f6ecb5b1de0c1dd56" translate="yes" xml:space="preserve">
          <source>The number of rows read by this client's connections.</source>
          <target state="translated">이 클라이언트의 연결에서 읽은 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="e780373963550440cf44ea5eebb4c2c411cc6adb" translate="yes" xml:space="preserve">
          <source>The number of rows read by this user's connections.</source>
          <target state="translated">이 사용자의 연결에서 읽은 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="3f0f1f20659d33a140a81f76c9fbfafcb686847f" translate="yes" xml:space="preserve">
          <source>The number of rows read from the table.</source>
          <target state="translated">테이블에서 읽은 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="b7e75d139cf84c7467ce96efcf2b5d6fcbb153ae" translate="yes" xml:space="preserve">
          <source>The number of rows read from this index.</source>
          <target state="translated">이 인덱스에서 읽은 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="400d4103173248ad947a3ff93eb4f44e95c177d6" translate="yes" xml:space="preserve">
          <source>The number of rows returned by a query or grouping. All datatypes are supported</source>
          <target state="translated">쿼리 또는 그룹화에서 반환 된 행 수입니다. 모든 데이터 유형이 지원됩니다</target>
        </trans-unit>
        <trans-unit id="f1e4187041dcf6c3e4b662febc0406130a2b3063" translate="yes" xml:space="preserve">
          <source>The number of rows sent by this client's connections.</source>
          <target state="translated">이 클라이언트의 연결에서 보낸 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="9f58e84d554a2cbc7ef2b575fd23ae8ebe9108d2" translate="yes" xml:space="preserve">
          <source>The number of rows sent by this user's connections.</source>
          <target state="translated">이 사용자의 연결에서 보낸 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="a7f464204ea7884a16c413b62404c3515e971cfc" translate="yes" xml:space="preserve">
          <source>The number of rows the process has examined.</source>
          <target state="translated">프로세스가 조사한 행 수</target>
        </trans-unit>
        <trans-unit id="6c28dcea7d2320679cd623a94c9c876b202a874b" translate="yes" xml:space="preserve">
          <source>The number of rows updated by this client's connections.</source>
          <target state="translated">이 클라이언트의 연결에 의해 업데이트 된 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="7bd573a2bce49a5a95968ee24ad16fbc614f3d6d" translate="yes" xml:space="preserve">
          <source>The number of rows updated by this user's connections.</source>
          <target state="translated">이 사용자의 연결에 의해 업데이트 된 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="57ffbc0bfc92ef80c0053e3107f5ead4b4b7ae4d" translate="yes" xml:space="preserve">
          <source>The number of tests to execute before exiting.</source>
          <target state="translated">종료하기 전에 실행할 테스트 수입니다.</target>
        </trans-unit>
        <trans-unit id="fb151b76d3f0e5da2de440d33aacafd7895f8417" translate="yes" xml:space="preserve">
          <source>The number of the segment file containing the physical row</source>
          <target state="translated">실제 행을 포함하는 세그먼트 파일의 수</target>
        </trans-unit>
        <trans-unit id="06af4ca3afddaee8f9fc3707de51d9f90f9e5e65" translate="yes" xml:space="preserve">
          <source>The number of this client's connections that were terminated uncleanly.</source>
          <target state="translated">부정확하게 종료 된이 클라이언트 연결 수입니다.</target>
        </trans-unit>
        <trans-unit id="76eb3cee191651bb845e1b05ac257d0ee13d6b6e" translate="yes" xml:space="preserve">
          <source>The number of this user's connections that were terminated uncleanly.</source>
          <target state="translated">부정확하게 종료 된이 사용자의 연결 수입니다.</target>
        </trans-unit>
        <trans-unit id="21e7dacbd858e74725dfa2471e47dfc37eb3be13" translate="yes" xml:space="preserve">
          <source>The number of threads. The default is 1.</source>
          <target state="translated">스레드 수 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="dff80b932d78f64310a1cfd277b66d624dc8d617" translate="yes" xml:space="preserve">
          <source>The number of times a statement was aborted, because it was executed longer than its &lt;code&gt;&lt;a href=&quot;../aborting-statements-that-take-longer-than-a-certain-time-to-execute/index&quot;&gt;MAX_STATEMENT_TIME&lt;/a&gt;&lt;/code&gt; threshold. (&amp;gt;= &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1011-release-notes/&quot;&gt;MariaDB 10.1.1&lt;/a&gt;)</source>
          <target state="translated">명령문이 &lt;code&gt;&lt;a href=&quot;../aborting-statements-that-take-longer-than-a-certain-time-to-execute/index&quot;&gt;MAX_STATEMENT_TIME&lt;/a&gt;&lt;/code&gt; 임계 값 보다 오래 실행되어 명령문이 중단 된 횟수입니다 . (&amp;gt; = &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1011-release-notes/&quot;&gt;MariaDB 10.1.1&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="e82178e7826730b10259b6b656d8b1fb1ecb71d7" translate="yes" xml:space="preserve">
          <source>The number of times that semisynchronous replication has been switched off can be checked by looking at the value of the &lt;code&gt;&lt;a href=&quot;../semisynchronous-replication-plugin-status-variables/index#rpl_semi_sync_master_no_times&quot;&gt;Rpl_semi_sync_master_no_times&lt;/a&gt;&lt;/code&gt; status variable.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../semisynchronous-replication-plugin-status-variables/index#rpl_semi_sync_master_no_times&quot;&gt;Rpl_semi_sync_master_no_times&lt;/a&gt;&lt;/code&gt; 상태 변수 의 값을 확인하여 반 동기식 복제가 해제 된 횟수를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ca12d9afe9f6742650e21e6d147a7f25664efeb" translate="yes" xml:space="preserve">
          <source>The number of times this client's connections issued commands that were denied.</source>
          <target state="translated">이 클라이언트의 연결이 거부 된 명령을 발행 한 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="c0ba7b0ce0344bd09242efcb74fd3862b8e52ad4" translate="yes" xml:space="preserve">
          <source>The number of times this client's connections sent queries that returned no results to the server.</source>
          <target state="translated">이 클라이언트의 연결이 서버에 결과를 반환하지 않은 쿼리를 보낸 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="9a33a8d9518e31599a1cdb2587bfc8e9ced47635" translate="yes" xml:space="preserve">
          <source>The number of times this user's connections issued commands that were denied.</source>
          <target state="translated">이 사용자의 연결이 거부 된 명령을 발행 한 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="37e1e53a1b401cf898d6cf5bdc6dd1f924fa4170" translate="yes" xml:space="preserve">
          <source>The number of times this user's connections sent empty queries to the server.</source>
          <target state="translated">이 사용자의 연결이 빈 쿼리를 서버로 보낸 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="ed182e8462a591504db94abc0ab35dd8304f1811" translate="yes" xml:space="preserve">
          <source>The number of warnings.</source>
          <target state="translated">경고 수</target>
        </trans-unit>
        <trans-unit id="89013974f6ed8523b4d3dfb976468ec71297ef13" translate="yes" xml:space="preserve">
          <source>The numbers, represented by '&lt;code&gt;######&lt;/code&gt;' in the syntax examples above specify the specific the minimum versions of MySQL and MariaDB that should execute the comment. The first number is the major version, the second 2 numbers are the minor version and the last 2 is the patch level.</source>
          <target state="translated">위 구문 예제에서 ' &lt;code&gt;######&lt;/code&gt; '으로 표시되는 숫자 는 주석을 실행해야하는 MySQL 및 MariaDB의 최소 버전을 지정합니다. 첫 번째 숫자는 주 버전이고 두 번째 숫자는 부 버전이고 마지막 두 숫자는 패치 수준입니다.</target>
        </trans-unit>
        <trans-unit id="82d204eed0dbca310b370a10a8f685ff3cb80bea" translate="yes" xml:space="preserve">
          <source>The numeric ID of the coordinate system in the above authority's catalog.</source>
          <target state="translated">위 기관의 카탈로그에있는 좌표계의 숫자 ID입니다.</target>
        </trans-unit>
        <trans-unit id="a3506dd93774b51c2e712526d0192bb85a5d234c" translate="yes" xml:space="preserve">
          <source>The numeric precision for the column</source>
          <target state="translated">열의 숫자 정밀도</target>
        </trans-unit>
        <trans-unit id="5e06975402f75177ffdc7422cd8b2e0b56cfbd62" translate="yes" xml:space="preserve">
          <source>The numeric scale for the column</source>
          <target state="translated">열의 숫자 스케일</target>
        </trans-unit>
        <trans-unit id="f941b7219dc3f325f9319750fd183a9fd66a489e" translate="yes" xml:space="preserve">
          <source>The object ID for the column</source>
          <target state="translated">열의 객체 ID</target>
        </trans-unit>
        <trans-unit id="243a9bdd80f89727d48a8cf8fe7becfeebab20d4" translate="yes" xml:space="preserve">
          <source>The object ID for the extent</source>
          <target state="translated">익스텐트의 객체 ID</target>
        </trans-unit>
        <trans-unit id="12ba75f454cf10e55b630169556b4691203edb63" translate="yes" xml:space="preserve">
          <source>The object is filled with pairs corresponding to the given arguments. The key of each pair is made from the argument (default or specified) alias.</source>
          <target state="translated">주어진 인수에 해당하는 쌍으로 객체가 채워집니다. 각 쌍의 키는 인수 (기본 또는 지정된) 별명으로 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="2cbb2db76c9c836fd755e47bb85a094d0674ce63" translate="yes" xml:space="preserve">
          <source>The oemrest.mak file:</source>
          <target state="translated">oemrest.mak 파일 :</target>
        </trans-unit>
        <trans-unit id="a9464abcb39c06086f9d0a6456c46af475df2db3" translate="yes" xml:space="preserve">
          <source>The old behavior, with 3 syncs to disk per (group) commit (and consequently lower performance), can be selected with the new &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_flush_log_at_trx_commit&quot;&gt;innodb_flush_log_at_trx_commit=3&lt;/a&gt;&lt;/code&gt; option. There is normally no benefit to doing this, however there are a couple of edge cases to be aware of.</source>
          <target state="translated">새로운 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_flush_log_at_trx_commit&quot;&gt;innodb_flush_log_at_trx_commit=3&lt;/a&gt;&lt;/code&gt; 옵션을 사용 하면 (그룹) 커밋 당 디스크에 3 번 동기화 (따라서 성능이 저하됨) 된 이전 동작을 선택할 수 있습니다 . 일반적으로이 작업을 수행하면 이점이 없지만 몇 가지 중요한 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f81ea031e3e9116048b856a5366a5377f95da58" translate="yes" xml:space="preserve">
          <source>The old syntax &lt;code&gt;TIMESTAMP(N)&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the display width, is no longer supported. It was deprecated in MySQL 4.1.0 (released on 2003-04-03).</source>
          <target state="translated">이전 구문 인 &lt;code&gt;TIMESTAMP(N)&lt;/code&gt; 은 &lt;code&gt;N&lt;/code&gt; 이 표시 너비이며 더 이상 지원되지 않습니다. MySQL 4.1.0에서는 더 이상 사용되지 않습니다 (2003-04-03에 릴리스 됨).</target>
        </trans-unit>
        <trans-unit id="8e39fae50f5b0d011adace73dcca01866bf4da25" translate="yes" xml:space="preserve">
          <source>The old thread pool introduced in MariaDB 5.1</source>
          <target state="translated">MariaDB 5.1에 도입 된 이전 스레드 풀</target>
        </trans-unit>
        <trans-unit id="7874c0670ef5474fcb54b3eb36779fb23a06d5e7" translate="yes" xml:space="preserve">
          <source>The old, deprecated format can still be used if the value of the &lt;a href=&quot;../oqgraph-system-and-status-variables/index#oqgraph_allow_create_integer_latch&quot;&gt;oqgraph_allow_create_integer_latch&lt;/a&gt; system variable is changed from its default, &lt;code&gt;FALSE&lt;/code&gt;, to &lt;code&gt;TRUE&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../oqgraph-system-and-status-variables/index#oqgraph_allow_create_integer_latch&quot;&gt;oqgraph_allow_create_integer_latch&lt;/a&gt; 시스템 변수 의 값이 기본값 인 &lt;code&gt;FALSE&lt;/code&gt; 에서 &lt;code&gt;TRUE&lt;/code&gt; 로 변경 되면 더 이상 사용되지 않는 이전 형식을 계속 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a335c70b667b8dfac7b677dbb67f06af8ffeec24" translate="yes" xml:space="preserve">
          <source>The one exception is &lt;a href=&quot;../count/index&quot;&gt;COUNT(*)&lt;/a&gt;, which counts rows, and doesn't look at whether a value is NULL or not. Compare for example, COUNT(x), which ignores the NULL, and COUNT(*), which counts it:</source>
          <target state="translated">한 가지 예외는 &lt;a href=&quot;../count/index&quot;&gt;COUNT (*)&lt;/a&gt; 이며 행을 계산하며 값이 NULL인지 여부를 보지 않습니다. 예를 들어, NULL을 무시하는 COUNT (x)와 그것을 계산하는 COUNT (*)를 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="c456a1e84375e00641283515e9375184ca1cf724" translate="yes" xml:space="preserve">
          <source>The one or two-digit hour in 12-hour or 24-hour format.</source>
          <target state="translated">12 시간 또는 24 시간 형식의 한 자리 또는 두 자리 시간입니다.</target>
        </trans-unit>
        <trans-unit id="c026f9c4c6ee7eeb73efdaf10b37ed35fb1cf2df" translate="yes" xml:space="preserve">
          <source>The one or two-digit minute.</source>
          <target state="translated">한 자리 또는 두 자리 분입니다.</target>
        </trans-unit>
        <trans-unit id="638bbb66005100da868143c7ce05ab76f1da6feb" translate="yes" xml:space="preserve">
          <source>The one or two-digit month day.</source>
          <target state="translated">한 달 또는 두 자리 일입니다.</target>
        </trans-unit>
        <trans-unit id="a4a443787eb9a284f2b37d036b1a4ea2a0e16aed" translate="yes" xml:space="preserve">
          <source>The one or two-digit month number.</source>
          <target state="translated">한 자리 또는 두 자리 월의 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="0915379a7a958a369012839fa136caf834d5804e" translate="yes" xml:space="preserve">
          <source>The one or two-digit second.</source>
          <target state="translated">1 자리 또는 2 자리 초입니다.</target>
        </trans-unit>
        <trans-unit id="c1a6d8e13f1f83bd8805f4cb1382d23d0bae4754" translate="yes" xml:space="preserve">
          <source>The one table has one row per entity, and can grow as needed. (EAV needs many rows per entity.)</source>
          <target state="translated">하나의 테이블에는 엔터티 당 하나의 행이 있으며 필요에 따라 커질 수 있습니다. EAV에는 엔터티 당 많은 행이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7fbf77e8235c90bd27a23cfe6d1f4d6f5230dce1" translate="yes" xml:space="preserve">
          <source>The one-letter AM/PM abbreviation (that is, AM is entered as &quot;A&quot;).</source>
          <target state="translated">한 글자 AM / PM 약어 (AM은 &quot;A&quot;로 입력 됨)</target>
        </trans-unit>
        <trans-unit id="2cc163d1aafa69e59def20e40f4208ae1006e61c" translate="yes" xml:space="preserve">
          <source>The online &lt;a href=&quot;../explain-analyzer/index&quot;&gt;EXPLAIN Analyzer&lt;/a&gt; tool has an open API to allow client applications to send it EXPLAINs.</source>
          <target state="translated">온라인 &lt;a href=&quot;../explain-analyzer/index&quot;&gt;EXPLAIN Analyzer&lt;/a&gt; 도구에는 클라이언트 응용 프로그램이 EXPLAIN 을 보낼 수 있도록 개방형 API가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9328ad1f2f033fa0cbd8b1f8032abb33e274df6" translate="yes" xml:space="preserve">
          <source>The online EXPLAIN Analyzer tool has an open API to allow client applicatio...</source>
          <target state="translated">온라인 EXPLAIN 분석기 도구에는 클라이언트 응용 프로그램을 허용하는 개방형 API가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c46ec5fe5f83639d2a503746d302b70cfc366e64" translate="yes" xml:space="preserve">
          <source>The only &lt;a href=&quot;../authentication-plugins/index&quot;&gt;authentication plugins&lt;/a&gt; that this clause supports are &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_native_password/index&quot;&gt;mysql_native_password&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_old_password/index&quot;&gt;mysql_old_password&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">이 절이 지원하는 유일한 &lt;a href=&quot;../authentication-plugins/index&quot;&gt;인증 플러그인&lt;/a&gt; 은 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_native_password/index&quot;&gt;mysql_native_password&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../authentication-plugin-mysql_old_password/index&quot;&gt;mysql_old_password&lt;/a&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4886c1636f51d8957612b84ba0e225b4c64faeef" translate="yes" xml:space="preserve">
          <source>The only SST method of this type is the &lt;code&gt;mysqldump&lt;/code&gt; SST method, which actually uses the &lt;code&gt;&lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt;&lt;/code&gt; utility to get a logical dump of the donor. This SST method requires the joiner node to be fully initialized and ready to accept connections before the transfer. This method is, by definition, blocking, in that it blocks the donor node from modifying its own state for the duration of the transfer. It is also the slowest of all, and that might be an issue in a cluster with a lot of load.</source>
          <target state="translated">이 유형의 유일한 SST 메소드는 &lt;code&gt;mysqldump&lt;/code&gt; SST 메소드이며, 실제로는 &lt;code&gt;&lt;a href=&quot;../mysqldump/index&quot;&gt;mysqldump&lt;/a&gt;&lt;/code&gt; 유틸리티를 사용 하여 공여자의 논리적 덤프를 가져옵니다. 이 SST 방법을 사용하려면 연결 전에 결합 자 노드를 완전히 초기화하고 연결을 수락 할 수 있어야합니다. 이 방법은 전송 기간 동안 기증자 노드가 자신의 상태를 수정하는 것을 차단한다는 점에서 정의상 차단입니다. 또한 가장 느리기 때문에로드가 많은 클러스터에서 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="670dd6cd1ca9241e4932f0df9e37bdda16958333" translate="yes" xml:space="preserve">
          <source>The only aggregated functions in the &lt;code&gt;SELECT&lt;/code&gt; part are &lt;code&gt;MIN()&lt;/code&gt; and &lt;code&gt;MAX()&lt;/code&gt; functions and all of them using the same column which is the next index part after the used &lt;code&gt;GROUP BY&lt;/code&gt; columns.</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 파트 에서 유일하게 집계 된 함수 는 &lt;code&gt;MIN()&lt;/code&gt; 및 &lt;code&gt;MAX()&lt;/code&gt; 함수이며 모두 사용 된 &lt;code&gt;GROUP BY&lt;/code&gt; 컬럼 다음의 다음 인덱스 파트 인 동일한 컬럼을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d198c36449ca1ac83a05a373c2100b37cdd22e99" translate="yes" xml:space="preserve">
          <source>The only algorithm that MariaDB currently supports to encrypt the key file is &lt;a href=&quot;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#CBC&quot;&gt;Cipher Block Chaining (CBC)&lt;/a&gt; mode of &lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;Advanced Encryption Standard (AES)&lt;/a&gt;.</source>
          <target state="translated">MariaDB가 현재 키 파일을 암호화하도록 지원하는 유일한 알고리즘은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES (Advanced Encryption Standard &lt;/a&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#CBC&quot;&gt;)의 CBC (Cipher Block Chaining)&lt;/a&gt; 모드입니다 .</target>
        </trans-unit>
        <trans-unit id="faaf284be2a03f02120e07e905b3f1ca0c5df693" translate="yes" xml:space="preserve">
          <source>The only algorithm that MariaDB currently supports when decrypting the key file is &lt;a href=&quot;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#CBC&quot;&gt;Cipher Block Chaining (CBC)&lt;/a&gt; mode of &lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;Advanced Encryption Standard (AES)&lt;/a&gt;. The encryption key size can be 128-bits, 192-bits, or 256-bits. The encryption key is calculated by taking a &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; hash of the encryption password.</source>
          <target state="translated">키 파일을 해독 할 때 MariaDB가 현재 지원하는 유일한 알고리즘은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Advanced_Encryption_Standard&quot;&gt;AES (Advanced Encryption Standard &lt;/a&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#CBC&quot;&gt;)의 CBC (Cipher Block Chaining)&lt;/a&gt; 모드입니다 . 암호화 키 크기는 128 비트, 192 비트 또는 256 비트 일 수 있습니다. 암호화 키는 암호화 비밀번호의 &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; 해시를 사용하여 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="03e0a5d613e4eedbd072899e2de714adecb2bcf9" translate="yes" xml:space="preserve">
          <source>The only data modifying operations are the &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; commands. They can be executed successfully only if the data source database or tables are not read/only.</source>
          <target state="translated">유일한 데이터 수정 조작은 &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;../update/index&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;../delete/index&quot;&gt;DELETE&lt;/a&gt; 명령입니다. 데이터 소스 데이터베이스 또는 테이블이 읽기 / 전용이 아닌 경우에만 성공적으로 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a7056e98ca1016d6f3048d4342f86055e2e9877" translate="yes" xml:space="preserve">
          <source>The only difference is that the &quot;multiple&quot; node is an intermediate node in the path. The resulting table can be seen with a query such as:</source>
          <target state="translated">유일한 차이점은 &quot;다중&quot;노드가 경로의 중간 노드라는 것입니다. 결과 테이블은 다음과 같은 쿼리로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c047a4efa8e0765dd2b5128b19c76d710705e39" translate="yes" xml:space="preserve">
          <source>The only difference is the tabname option now referring to the rt1, rt2, and rt3 tables. However, even if it works, this is not the best way to do it. This is because accessing a table via the MySQL API is done twice per table. Once by CONNECT to access the FEDERATED table on the local server, then a second time by FEDERATED engine to access the remote table.</source>
          <target state="translated">유일한 차이점은 이제 rt1, rt2 및 rt3 테이블을 참조하는 tabname 옵션입니다. 그러나 작동하더라도 이것이 최선의 방법은 아닙니다. MySQL API를 통해 테이블에 액세스하는 것이 테이블 당 두 번 수행되기 때문입니다. CONNECT에 의해 로컬 서버의 FEDERATED 테이블에 액세스 한 후 FEDERATED 엔진에 의해 두 번째로 원격 테이블에 액세스하십시오.</target>
        </trans-unit>
        <trans-unit id="8ff6bdadda63d3ce8e678cb31e9c5520b0b20479" translate="yes" xml:space="preserve">
          <source>The only option with &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table = 0&lt;/a&gt; is to dump ALL tables, remove ibdata*, restart, and reload. That is rarely worth the effort and time.</source>
          <target state="translated">&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table = 0 인&lt;/a&gt; 유일한 옵션 은 모든 테이블을 덤프하고 ibdata *를 제거하고 다시 시작한 후 다시로드하는 것입니다. 노력과 시간의 가치가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b94f1706a7fc60ec6495f25dc3113f52b546dd5" translate="yes" xml:space="preserve">
          <source>The only possible long operations are getting the locks for the table and flushing the original key cache, if there were many key blocks for the file in it.</source>
          <target state="translated">파일에 대한 키 블록이 많은 경우 테이블에 대한 잠금을 가져 와서 원래 키 캐시를 비우는 것이 유일한 긴 작업입니다.</target>
        </trans-unit>
        <trans-unit id="e20e0d31630d8953910c4bca10bc01a8e3800b97" translate="yes" xml:space="preserve">
          <source>The only supported method currently is zlib.</source>
          <target state="translated">현재 지원되는 유일한 방법은 zlib입니다.</target>
        </trans-unit>
        <trans-unit id="7820753074f9f26846eac3dd8e628ac3d16f084a" translate="yes" xml:space="preserve">
          <source>The open table cache can be emptied with &lt;a href=&quot;../flush/index&quot;&gt;FLUSH TABLES&lt;/a&gt; or with the &lt;code&gt;flush-tables&lt;/code&gt; or &lt;code&gt;refresh&lt;/code&gt;&lt;a href=&quot;../mysqladmin/index&quot;&gt;mysqladmin&lt;/a&gt; commands.</source>
          <target state="translated">열린 테이블 캐시는 &lt;a href=&quot;../flush/index&quot;&gt;FLUSH TABLES&lt;/a&gt; 또는 &lt;code&gt;flush-tables&lt;/code&gt; 또는 &lt;code&gt;refresh&lt;/code&gt; &lt;a href=&quot;../mysqladmin/index&quot;&gt;mysqladmin&lt;/a&gt; 명령 으로 비울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b77bc1b4e3a2f54eae7a0d2c39c046f5dbe3518f" translate="yes" xml:space="preserve">
          <source>The operation inserts one record at a time into each index, which is very inefficient.</source>
          <target state="translated">이 작업은 한 번에 하나의 레코드를 각 인덱스에 삽입하므로 매우 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="cef6705f67502e1e5a8041d4ba560e25d1025a9a" translate="yes" xml:space="preserve">
          <source>The operation is also crash safe. If the server is killed while executing an instant &lt;code&gt;&lt;a href=&quot;../alter-table/index#add-column&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;&lt;/code&gt;, when the table is restored InnoDB integrates the new column, flattening the table definition.</source>
          <target state="translated">작업도 충돌 안전합니다. 인스턴트 &lt;code&gt;&lt;a href=&quot;../alter-table/index#add-column&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt;&lt;/code&gt; 을 실행하는 동안 서버가 종료되면 테이블이 복원 될 때 InnoDB는 새 열을 통합하여 테이블 정의를 병합합니다.</target>
        </trans-unit>
        <trans-unit id="cf9aca32873ef0f0c6c18b42b01b3ae8cfdf2b57" translate="yes" xml:space="preserve">
          <source>The operation might also have to write a temporary log file to track data changes by &lt;a href=&quot;../data-manipulation/index&quot;&gt;DML queries&lt;/a&gt; executed during the operation. The maximum size for this log file is configured by the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_online_alter_log_max_size&quot;&gt;innodb_online_alter_log_max_size&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">작업 중에 실행 된 &lt;a href=&quot;../data-manipulation/index&quot;&gt;DML 쿼리의&lt;/a&gt; 데이터 변경 사항을 추적하기 위해 작업이 임시 로그 파일을 작성해야 할 수도 있습니다 . 이 로그 파일의 최대 크기는 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_online_alter_log_max_size&quot;&gt;innodb_online_alter_log_max_size&lt;/a&gt;&lt;/code&gt; 시스템 변수로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="b2d49bb20167c960a2e9981ad1d27ec44cb60148" translate="yes" xml:space="preserve">
          <source>The operation might have to write sort files in the directory defined by the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_tmpdir&quot;&gt;innodb_tmpdir&lt;/a&gt;&lt;/code&gt; system variable.</source>
          <target state="translated">조작은 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_tmpdir&quot;&gt;innodb_tmpdir&lt;/a&gt;&lt;/code&gt; 시스템 변수로 정의 된 디렉토리에 정렬 파일을 작성해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1c858112cba06acb4d1c11e7ccc1eb384385d886" translate="yes" xml:space="preserve">
          <source>The operation will have to create a temporary table to perform the the table copy. This temporary table will be in the same directory as the original table, and it's file name will be in the format &lt;code&gt;&lt;code&gt;#&lt;/code&gt;sql${PID}_${THREAD_ID}_${TMP_TABLE_COUNT}&lt;/code&gt;, where &lt;code&gt;${PID}&lt;/code&gt; is the process ID of &lt;code&gt;mysqld&lt;/code&gt;, &lt;code&gt;${THREAD_ID}&lt;/code&gt; is the connection ID, and &lt;code&gt;${TMP_TABLE_COUNT}&lt;/code&gt; is the number of temporary tables that the connection has open. Therefore, the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; may contain files with file names like &lt;code&gt;&lt;code&gt;#&lt;/code&gt;sql1234_12_1.ibd&lt;/code&gt;.</source>
          <target state="translated">조작은 테이블 복사를 수행하기 위해 임시 테이블을 작성해야합니다. 이 임시 테이블은 원래 테이블과 동일한 디렉토리에 있으며 파일 이름은 &lt;code&gt;&lt;code&gt;#&lt;/code&gt;sql${PID}_${THREAD_ID}_${TMP_TABLE_COUNT}&lt;/code&gt; . 여기서 &lt;code&gt;${PID}&lt;/code&gt; 는 프로세스 ID입니다. &lt;code&gt;mysqld&lt;/code&gt; , &lt;code&gt;${THREAD_ID}&lt;/code&gt; &lt;code&gt;${TMP_TABLE_COUNT}&lt;/code&gt; 는 연결 ID이고 $ {TMP_TABLE_COUNT} 는 연결이 열린 임시 테이블 수입니다. 따라서 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt;&lt;/code&gt; 에는 파일 이름이 &lt;code&gt;&lt;code&gt;#&lt;/code&gt;sql1234_12_1.ibd&lt;/code&gt; 인 파일이 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc896220a2a7ef8c165ab12393ade3ada89b6279" translate="yes" xml:space="preserve">
          <source>The opportunities for parallel replication on slaves can be highly increased if more transactions are committed in a &lt;a href=&quot;../group-commit-for-the-binary-log/index&quot;&gt;group commit&lt;/a&gt; on the master. This can be tuned using the &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#binlog_commit_wait_count&quot;&gt;binlog_commit_wait_count&lt;/a&gt; and &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#binlog_commit_wait_usec&quot;&gt;binlog_commit_wait_usec&lt;/a&gt; variables. If for example the application can tolerate up to 50 milliseconds extra delay for transactions on the master, one can set &lt;code&gt;binlog_commit_wait_usec=50000&lt;/code&gt; and &lt;code&gt;binlog_commit_wait_count=20&lt;/code&gt; to get up to 20 transactions at a time available for replication in parallel. Care must however be taken to not set &lt;code&gt;binlog_commit_wait_usec&lt;/code&gt; too high, as this could cause significant slowdown for applications that run a lot of small transactions serially one after the other.</source>
          <target state="translated">마스터 의 &lt;a href=&quot;../group-commit-for-the-binary-log/index&quot;&gt;그룹 커밋&lt;/a&gt; 에서 더 많은 트랜잭션이 커밋되면 슬레이브에서 병렬 복제의 기회를 크게 늘릴 수 있습니다 . &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#binlog_commit_wait_count&quot;&gt;binlog_commit_wait_count&lt;/a&gt; 및 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#binlog_commit_wait_usec&quot;&gt;binlog_commit_wait_usec&lt;/a&gt; 변수를 사용하여 조정할 수 있습니다 . 예를 들어 응용 프로그램이 마스터 트랜잭션에 대해 최대 50 밀리 초의 추가 지연을 허용 할 수 있으면 &lt;code&gt;binlog_commit_wait_usec=50000&lt;/code&gt; 및 &lt;code&gt;binlog_commit_wait_count=20&lt;/code&gt; 을 설정 하여 동시에 복제에 사용할 수있는 시간에 최대 20 개의 트랜잭션을 가져올 수 있습니다. 그러나 &lt;code&gt;binlog_commit_wait_usec&lt;/code&gt; 를 설정하지 않도록주의해야합니다. 이것은 많은 작은 트랜잭션을 순차적으로 실행하는 응용 프로그램의 속도를 크게 저하시킬 수 있으므로 너무 높습니다.</target>
        </trans-unit>
        <trans-unit id="6246a69b5e40eab8fb1864a0e13981fb029e518f" translate="yes" xml:space="preserve">
          <source>The opposite, city-to-country way is not possible. This is not a semi-join.</source>
          <target state="translated">반대의 도시 간 방법은 불가능합니다. 이것은 반 조인이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b8065c902d9402e98ce4e6ca247ac188829ed8c7" translate="yes" xml:space="preserve">
          <source>The optimization is ON by default, it can be switched off like so:</source>
          <target state="translated">최적화는 기본적으로 켜져 있으며 다음과 같이 끌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="784686a9953c35a1749c7cd56517bcbe5b034551" translate="yes" xml:space="preserve">
          <source>The optimization is applied then the derived table could not be merged into its parent SELECT</source>
          <target state="translated">최적화가 적용된 후 파생 테이블을 상위 SELECT에 병합 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="95c9ae4aaa70d8e7f4f616e6953619c180fd5009" translate="yes" xml:space="preserve">
          <source>The optimization is controlled by the &lt;code&gt;exists_to_in&lt;/code&gt; flag in &lt;a href=&quot;../server-system-variables/index#optimizer_switch&quot;&gt;optimizer_switch&lt;/a&gt;. Before &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10012-release-notes/&quot;&gt;MariaDB 10.0.12&lt;/a&gt;, the optimization was OFF by default. Since &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10012-release-notes/&quot;&gt;MariaDB 10.0.12&lt;/a&gt;, it has been ON by default.</source>
          <target state="translated">최적화는 &lt;a href=&quot;../server-system-variables/index#optimizer_switch&quot;&gt;optimizer_switch&lt;/a&gt; 의 &lt;code&gt;exists_to_in&lt;/code&gt; 플래그에 의해 제어됩니다 . &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10012-release-notes/&quot;&gt;MariaDB 10.0.12&lt;/a&gt; 이전 에는 최적화가 기본적으로 꺼져있었습니다. &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10012-release-notes/&quot;&gt;MariaDB 10.0.12&lt;/a&gt; 이후 기본적으로 켜져 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b5fd43055055458a36a5e92fb4a6f1f73ba75ed" translate="yes" xml:space="preserve">
          <source>The optimization is enabled by default. It can be disabled with:</source>
          <target state="translated">최적화는 기본적으로 활성화되어 있습니다. 다음을 사용하여 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5b7b8572eb5bfbd138e160a5f7939122d956b3b" translate="yes" xml:space="preserve">
          <source>The optimization is enabled by default. One can disable it by setting &lt;code&gt;@@optimizer_switch&lt;/code&gt; flag &lt;code&gt;condition_pushdown_for_derived&lt;/code&gt; to OFF.</source>
          <target state="translated">최적화는 기본적으로 활성화되어 있습니다. &lt;code&gt;@@optimizer_switch&lt;/code&gt; 플래그 &lt;code&gt;condition_pushdown_for_derived&lt;/code&gt; 를 OFF 로 설정하여 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f403042203be891bdfd038ad79033a21fada04b8" translate="yes" xml:space="preserve">
          <source>The optimization needs to be supported by the storage engine. At the moment, it is supported by InnoDB and MyISAM. It is not supported in partitioned tables.</source>
          <target state="translated">스토리지 엔진에서 최적화를 지원해야합니다. 현재 InnoDB 및 MyISAM에서 지원됩니다. 파티션 된 테이블에서는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55b0bc5b2adb220e5c2888a01fc607d1dbc101bf" translate="yes" xml:space="preserve">
          <source>The optimization phase can do the following changes to the &lt;code&gt;WHERE&lt;/code&gt; clause:</source>
          <target state="translated">최적화 단계는 &lt;code&gt;WHERE&lt;/code&gt; 절 을 다음과 같이 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bfd4f16712d685818568bc481a2469fc3b59f283" translate="yes" xml:space="preserve">
          <source>The optimization was ported into &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; in version 10.0.0. The server would not give any indication of whether the optimization was used, though. (This is how the feature was designed by Oracle. In MySQL 5.6, the only way one can see this feature is to examine the optimizer_trace, which is not currently supported by MariaDB).</source>
          <target state="translated">최적화는 버전 10.0.0에서 &lt;a href=&quot;../what-is-mariadb-100/index&quot;&gt;MariaDB 10.0&lt;/a&gt; 으로 포팅되었습니다 . 그러나 서버는 최적화 사용 여부를 표시하지 않습니다. (이 기능은 Oracle에서 설계 한 방식입니다. MySQL 5.6에서이 기능을 볼 수있는 유일한 방법은 현재 MariaDB에서 지원하지 않는 optimizer_trace를 검사하는 것입니다).</target>
        </trans-unit>
        <trans-unit id="6dddebb3a92525ad76a80ee30df18e376b7f824a" translate="yes" xml:space="preserve">
          <source>The optimizer chose to do a full scan over the materialized table, so this is an example of a use of the Materialization-Scan strategy.</source>
          <target state="translated">옵티마이 저는 구체화 된 테이블에 대해 전체 스캔을 수행하도록 선택 했으므로 이것은 Materialization-Scan 전략 사용의 예입니다.</target>
        </trans-unit>
        <trans-unit id="2f61516a5e42bc0fe6a13c2112a4b33eea73a34d" translate="yes" xml:space="preserve">
          <source>The optimizer does various plan pruning and may discard the requested join order before it has a chance to find out that it is a million-times cheaper than any other.</source>
          <target state="translated">옵티마이 저는 다양한 계획 정리를 수행하고 요청 된 조인 순서가 다른 것보다 백만 배 저렴하다는 것을 알기 전에 요청 된 조인 순서를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9619366e2ff7c5dc6c2a120cb55188dfc031b39" translate="yes" xml:space="preserve">
          <source>The optimizer doesn't use data from statistics tables. Default for &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1040-release-notes/&quot;&gt;MariaDB 10.4.0&lt;/a&gt; and below.</source>
          <target state="translated">옵티마이 저는 통계 테이블의 데이터를 사용하지 않습니다. &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1040-release-notes/&quot;&gt;MariaDB 10.4.0&lt;/a&gt; 이하의 기본값입니다 .</target>
        </trans-unit>
        <trans-unit id="f3df5731ba300fdb1dbdb02b6b290109c5bc11d7" translate="yes" xml:space="preserve">
          <source>The optimizer is largely cost-based and will try to choose the optimal plan for any query. However in some cases it does not have enough information to choose a perfect plan and in these cases you may have to provide hints to force the optimizer to use another plan.</source>
          <target state="translated">옵티마이 저는 대부분 비용 기반이며 모든 쿼리에 대한 최적의 계획을 선택하려고합니다. 그러나 완벽한 계획을 선택하기에 충분한 정보가없는 경우도 있으므로 최적화 프로그램이 다른 계획을 사용하도록 힌트를 제공해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="38940d0c3e12119bf8f0665646ccf399b632b159" translate="yes" xml:space="preserve">
          <source>The optimizer makes a cost-based decision about when the filter should be used.</source>
          <target state="translated">옵티마이 저는 필터 사용시기를 비용 기반으로 결정합니다.</target>
        </trans-unit>
        <trans-unit id="efbe67fe5aa6a944e197641a0ad274eb5a476c70" translate="yes" xml:space="preserve">
          <source>The optimizer starts a range scan on the &lt;em&gt;salary&lt;/em&gt; index. We find the first record &lt;em&gt;Babatunde, 1000&lt;/em&gt;. If we do an on-the-fly update, we immediately instruct the storage engine to change this record to be &lt;em&gt;Babatunde, 1000+100=1100&lt;/em&gt;.</source>
          <target state="translated">옵티마이 저는 &lt;em&gt;급여&lt;/em&gt; 인덱스 에서 범위 스캔을 시작합니다 . 우리는 첫 번째 기록 &lt;em&gt;Babatunde, 1000을&lt;/em&gt; 찾습니다 . 즉시 업데이트를 수행하는 경우 스토리지 엔진에이 레코드를 &lt;em&gt;Babatunde, 1000 + 100 = 1100&lt;/em&gt; 으로 변경하도록 즉시 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="1b4bfa2428641fa797c541ea5d39250ce8bbc87e" translate="yes" xml:space="preserve">
          <source>The optimizer uses data from statistics tables if the same kind of data is not provided by the storage engine.</source>
          <target state="translated">스토리지 엔진이 동일한 종류의 데이터를 제공하지 않으면 옵티마이 저는 통계 테이블의 데이터를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="557fbfdad9a24ad66a388d7eff56c06b569f8514" translate="yes" xml:space="preserve">
          <source>The optimizer uses several strategies to optimize &lt;a href=&quot;../group-by/index&quot;&gt;GROUP BY&lt;/a&gt; and &lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt;:</source>
          <target state="translated">옵티마이 저는 몇 가지 전략을 사용하여 &lt;a href=&quot;../group-by/index&quot;&gt;GROUP BY&lt;/a&gt; 및 &lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt; 를 최적화합니다 .</target>
        </trans-unit>
        <trans-unit id="acdbdb8507b361c703f69a443963057a659c0b88" translate="yes" xml:space="preserve">
          <source>The optimizer usually picks the &quot;first&quot; table based on these hints:</source>
          <target state="translated">옵티마이 저는 일반적으로 다음 힌트를 기반으로 &quot;첫 번째&quot;테이블을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="f233f736fc1eeb944bfeeca69f24df164c28c5f7" translate="yes" xml:space="preserve">
          <source>The optimizer usually starts with one table and extracts the data needed from it. As it finds a useful (that is, matches the WHERE clause, if any) row, it reaches into the 'next' table. This is called NLJ (&quot;Nested Loop Join&quot;). The process of filtering and reaching to the next table continues through the rest of the tables.</source>
          <target state="translated">옵티마이 저는 일반적으로 하나의 테이블로 시작하여 테이블에서 필요한 데이터를 추출합니다. 유용한 (즉, WHERE 절이있는 경우) 행을 찾으면 '다음'테이블에 도달합니다. 이것을 NLJ ( &quot;Nested Loop Join&quot;)라고합니다. 다음 테이블을 필터링하고 도달하는 프로세스는 나머지 테이블을 통해 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="ef577ae8acac5c0307bd14eead9c8d3dd949bfac" translate="yes" xml:space="preserve">
          <source>The optimizer will convert big IN predicates into subqueries.</source>
          <target state="translated">옵티마이 저는 큰 IN 술어를 서브 쿼리로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="276f70a90150960a0adc2303b8ca5bb644ef060b" translate="yes" xml:space="preserve">
          <source>The optimizer will try its best to build a join plan which matches the specified join prefix. It does this by comparing join prefixes it is considering with &lt;code&gt;@@debug_optimizer_prefer_join_prefix&lt;/code&gt;, and multiplying cost by a million if the plan doesn't match the prefix.</source>
          <target state="translated">옵티마이 저는 지정된 조인 접두사와 일치하는 조인 계획을 작성하기 위해 최선을 다할 것입니다. &lt;code&gt;@@debug_optimizer_prefer_join_prefix&lt;/code&gt; 로 고려중인 조인 접두사를 비교 하고 계획이 접두사와 일치하지 않으면 비용에 백만을 곱합니다.</target>
        </trans-unit>
        <trans-unit id="910751b0d2067a9a0057743c38b2d81dd8606471" translate="yes" xml:space="preserve">
          <source>The optimizer will try to use indexes to resolve &lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt; and &lt;a href=&quot;../group-by/index&quot;&gt;GROUP BY&lt;/a&gt;.</source>
          <target state="translated">옵티마이 저는 인덱스를 사용하여 &lt;a href=&quot;../order-by/index&quot;&gt;ORDER BY&lt;/a&gt; 및 &lt;a href=&quot;../group-by/index&quot;&gt;GROUP BY&lt;/a&gt; 를 분석하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="8819f3fb7a2f4342a386b83503068337d507e6f7" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;--check&lt;/code&gt; will be used by default, if no other options were specified. You can change the default behavior by making a symbolic link to the binary, or copying it somewhere with another name, the alternatives are:</source>
          <target state="translated">다른 옵션이 지정되지 않은 경우 &lt;code&gt;--check&lt;/code&gt; 옵션 이 기본적으로 사용됩니다. 바이너리에 대한 심볼릭 링크를 만들거나 다른 이름으로 어딘가에 복사하여 기본 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9be9bef14fdc0774a788c3c272cab98fc0853bd8" translate="yes" xml:space="preserve">
          <source>The option &lt;strong&gt;read_binlog_speed_limit&lt;/strong&gt; can be used to reduce such load, by limiting the speed at which events are downloaded. The limit is given as maximum kilobytes per second to download on one slave connection.</source>
          <target state="translated">&lt;strong&gt;read_binlog_speed_limit&lt;/strong&gt; 옵션을 사용하면 이벤트 다운로드 속도를 제한하여 이러한로드를 줄일 수 있습니다. 하나의 슬레이브 연결에서 다운로드 할 수있는 한계는 초당 최대 킬로바이트로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="681b5c152f39cc44f22367d62b5dca7efcfbc40d" translate="yes" xml:space="preserve">
          <source>The option &lt;strong&gt;read_binlog_speed_limit&lt;/strong&gt; is available starting from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;read_binlog_speed_limit&lt;/strong&gt; 옵션 은 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1023-release-notes/&quot;&gt;MariaDB 10.2.3&lt;/a&gt; 부터 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b78c96202d95e224937c634256c494cf7965db29" translate="yes" xml:space="preserve">
          <source>The option can also be set in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; supported by &lt;code&gt;&lt;a href=&quot;../mysql_install_db/index&quot;&gt;mysql_install_db&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">옵션은 &lt;code&gt;&lt;a href=&quot;../mysql_install_db/index&quot;&gt;mysql_install_db&lt;/a&gt;&lt;/code&gt; 가 지원 하는 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 의 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 에서 설정할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d988ebc481cbe685f1dc1ba374b68039f9e762cc" translate="yes" xml:space="preserve">
          <source>The option files are each scanned once, in the order given by &lt;code&gt;--help --verbose&lt;/code&gt;. The effect of the configuration options are as if they would have been given as command line options in the order they are found.</source>
          <target state="translated">옵션 파일은 각각 &lt;code&gt;--help --verbose&lt;/code&gt; 순서대로 한 번 스캔됩니다 . 구성 옵션의 효과는 찾은 순서대로 명령 행 옵션으로 제공된 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e632326674b1ee1336154a76088f4150ff7654d2" translate="yes" xml:space="preserve">
          <source>The option files within the directory are read in alphabetical order.</source>
          <target state="translated">디렉토리 내의 옵션 파일은 알파벳 순서로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="024b93996899dac4452d0af488ebad5ef73c60cb" translate="yes" xml:space="preserve">
          <source>The option module gives the name of the DLL or shared library implementing the OEM wrapper for the table type. This library must be located in the plugin directory like all other plugins or UDF&amp;rsquo;s.</source>
          <target state="translated">옵션 모듈은 테이블 유형에 대한 OEM 랩퍼를 구현하는 DLL 또는 공유 라이브러리의 이름을 제공합니다. 이 라이브러리는 다른 모든 플러그인 또는 UDF와 같이 플러그인 디렉토리에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7c35e38e1394706ea1a1749a01fd89828ead4ec8" translate="yes" xml:space="preserve">
          <source>The option to disable the MariaDB ColumnStore User Module Replication is available since there are additional third party tools that can be used to do the Data Replication.</source>
          <target state="translated">데이터 복제를 수행하는 데 사용할 수있는 추가 타사 도구가 있기 때문에 MariaDB ColumnStore 사용자 모듈 복제를 비활성화하는 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12138c07bbe315d1f3cfca2c8cbeccfdd57a756a" translate="yes" xml:space="preserve">
          <source>The option value is passed to &lt;code&gt;ulimit -c&lt;/code&gt;. Note that you need to start &lt;code&gt;mysqld_safe&lt;/code&gt; as root for this to work properly.</source>
          <target state="translated">옵션 값은 &lt;code&gt;ulimit -c&lt;/code&gt; 로 전달됩니다 . 제대로 작동하려면 &lt;code&gt;mysqld_safe&lt;/code&gt; 를 루트 로 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9f0f0052d0b4f4f9ca5f9dbb48848b58c4a2d490" translate="yes" xml:space="preserve">
          <source>The option value is passed to &lt;code&gt;ulimit -n&lt;/code&gt;. Note that you need to start &lt;code&gt;mysqld_safe&lt;/code&gt; as root for this to work properly. However, you can't currently set this to &lt;code&gt;unlimited&lt;/code&gt;. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-18410&quot;&gt;MDEV-18410&lt;/a&gt; about that.</source>
          <target state="translated">옵션 값은 &lt;code&gt;ulimit -n&lt;/code&gt; 으로 전달됩니다 . 제대로 작동하려면 &lt;code&gt;mysqld_safe&lt;/code&gt; 를 루트 로 시작해야합니다 . 그러나 현재이를 &lt;code&gt;unlimited&lt;/code&gt; 설정할 수 없습니다 . 이에 대해서는 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-18410&quot;&gt;MDEV-18410을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5b0001b68ce7c4406801433c9db76935d489dee" translate="yes" xml:space="preserve">
          <source>The option was removed starting from &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10218-release-notes/&quot;&gt;MariaDB 10.2.18&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10218-release-notes/&quot;&gt;MariaDB 10.2.18&lt;/a&gt; 부터 옵션이 제거되었습니다</target>
        </trans-unit>
        <trans-unit id="b70d0cc2c9c7ce33407410609e6046e3581a5110" translate="yes" xml:space="preserve">
          <source>The option's value can be specified by providing a comma-separated list of &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_domain_id&quot;&gt;gtid_domain_id&lt;/a&gt;&lt;/code&gt; values. Duplicate values are automatically ignored. For example:</source>
          <target state="translated">옵션 값은 &lt;code&gt;&lt;a href=&quot;../gtid/index#gtid_domain_id&quot;&gt;gtid_domain_id&lt;/a&gt;&lt;/code&gt; 값 의 쉼표로 구분 된 목록을 제공하여 지정할 수 있습니다 . 중복 값은 자동으로 무시됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86715eac57b24c1470c174aa2d9d805b89b07db6" translate="yes" xml:space="preserve">
          <source>The option's value can be specified by providing a comma-separated list of &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#server_id&quot;&gt;server_id&lt;/a&gt;&lt;/code&gt; values. For example:</source>
          <target state="translated">옵션 값은 쉼표로 구분 된 &lt;code&gt;&lt;a href=&quot;../replication-and-binary-log-system-variables/index#server_id&quot;&gt;server_id&lt;/a&gt;&lt;/code&gt; 값 목록을 제공하여 지정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49209e3c826445078b6e98a0068ea22bf75be488" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;AND CHAIN&lt;/code&gt; clause is a convenience for initiating a new transaction as soon as the old transaction terminates. If &lt;code&gt;AND CHAIN&lt;/code&gt; is specified, then there is effectively nothing between the old and new transactions, although they remain separate. The characteristics of the new transaction will be the same as the characteristics of the old one &amp;mdash; that is, the new transaction will have the same access mode, isolation level and diagnostics area size (we'll discuss all of these shortly) as the transaction just terminated.</source>
          <target state="translated">선택적인 &lt;code&gt;AND CHAIN&lt;/code&gt; 절은 이전 트랜잭션이 종료 되 자마자 새 트랜잭션을 시작하기에 편리합니다. 경우 &lt;code&gt;AND CHAIN&lt;/code&gt; 지정들은 별도의 남아 있지만, 다음, 효과적으로 이전 및 새 트랜잭션 사이에 아무것도 없다. 새 트랜잭션의 특성은 이전 트랜잭션의 특성과 동일합니다. 즉, 새 트랜잭션은 트랜잭션과 동일한 액세스 모드, 격리 수준 및 진단 영역 크기 (이들 모두에 대해 간략히 설명합니다)를 갖습니다. 막 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="b400c318df88565f200323e107195233c3b58776" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;AND CHAIN&lt;/code&gt; clause is a convenience for initiating a new transaction as soon as the old transaction terminates. If &lt;code&gt;AND CHAIN&lt;/code&gt; is specified, then there is effectively nothing between the old and new transactions, although they remain separate. The characteristics of the new transaction will be the same as the characteristics of the old one &amp;mdash; that is, the new transaction will have the same access mode, isolation level and diagnostics area size (we'll discuss all of these shortly) as the transaction just terminated. The &lt;code&gt;AND NO CHAIN&lt;/code&gt; option just tells your DBMS to end the transaction &amp;mdash; that is, these four SQL statements are equivalent:</source>
          <target state="translated">선택적인 &lt;code&gt;AND CHAIN&lt;/code&gt; 절은 이전 트랜잭션이 종료 되 자마자 새 트랜잭션을 시작하기에 편리합니다. 경우 &lt;code&gt;AND CHAIN&lt;/code&gt; 지정들은 별도의 남아 있지만, 다음, 효과적으로 이전 및 새 트랜잭션 사이에 아무것도 없다. 새 트랜잭션의 특성은 이전 트랜잭션의 특성과 동일합니다. 즉, 새 트랜잭션은 트랜잭션과 동일한 액세스 모드, 격리 수준 및 진단 영역 크기 (이들 모두에 대해 간략히 설명합니다)를 갖습니다. 막 종료되었습니다. &lt;code&gt;AND NO CHAIN&lt;/code&gt; 옵션은 거래 종료하기 위해 DBMS를 알려줍니다 - 즉,이 네 가지 SQL 문은 동일을 :</target>
        </trans-unit>
        <trans-unit id="825d5bec8d0c9af6b1f79be1893178becd669759" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;BLOCK_SIZE&lt;/code&gt; option gives the size of the table, defaulting to 1 if not specified. When its columns are not specified, it is almost equivalent to a &lt;a href=&quot;../sequence/index&quot;&gt;SEQUENCE&lt;/a&gt; table &amp;ldquo;seq_1_to_Size&amp;rdquo;.</source>
          <target state="translated">선택적 &lt;code&gt;BLOCK_SIZE&lt;/code&gt; 옵션은 테이블 크기를 지정하며, 지정되지 않은 경우 기본값은 1입니다. 열이 지정되지 않은 경우 &lt;a href=&quot;../sequence/index&quot;&gt;SEQUENCE&lt;/a&gt; 테이블&amp;ldquo;seq_1_to_Size&amp;rdquo; 와 거의 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4c39e0feda286ed85b928fb2ac878f9f5fb26db1" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;IDENTIFIED BY PASSWORD&lt;/code&gt; clause can be used to provide an account with a password that has already been hashed. The password should be specified as a hash that was provided by the &lt;code&gt;&lt;a href=&quot;../password/index&quot;&gt;PASSWORD&lt;/a&gt;&lt;/code&gt; function. It will be stored to the &lt;code&gt;&lt;a href=&quot;../mysqluser-table/index&quot;&gt;mysql.user&lt;/a&gt;&lt;/code&gt; table as-is.</source>
          <target state="translated">선택적 &lt;code&gt;IDENTIFIED BY PASSWORD&lt;/code&gt; 절을 사용하여 계정에 이미 해시 된 비밀번호를 제공 할 수 있습니다. 비밀번호는 &lt;code&gt;&lt;a href=&quot;../password/index&quot;&gt;PASSWORD&lt;/a&gt;&lt;/code&gt; 함수 에서 제공 한 해시로 지정해야합니다 . &lt;code&gt;&lt;a href=&quot;../mysqluser-table/index&quot;&gt;mysql.user&lt;/a&gt;&lt;/code&gt; 테이블에있는 그대로 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="a16fee36b14684a5c80d2252a82be5f633a8f504" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;IDENTIFIED BY&lt;/code&gt; clause can be used to provide an account with a password. The password should be specified in plain text. It will be hashed by the &lt;code&gt;&lt;a href=&quot;../password/index&quot;&gt;PASSWORD&lt;/a&gt;&lt;/code&gt; function prior to being stored to the &lt;code&gt;&lt;a href=&quot;../mysqluser-table/index&quot;&gt;mysql.user&lt;/a&gt;&lt;/code&gt; table.</source>
          <target state="translated">선택적 &lt;code&gt;IDENTIFIED BY&lt;/code&gt; 절을 사용하여 계정에 비밀번호를 제공 할 수 있습니다. 비밀번호는 일반 텍스트로 지정해야합니다. &lt;code&gt;&lt;a href=&quot;../mysqluser-table/index&quot;&gt;mysql.user&lt;/a&gt;&lt;/code&gt; 테이블 에 저장되기 전에 &lt;code&gt;&lt;a href=&quot;../password/index&quot;&gt;PASSWORD&lt;/a&gt;&lt;/code&gt; 함수에 의해 해시됩니다 .</target>
        </trans-unit>
        <trans-unit id="baa3df5310066243906f68856c9c097761556d65" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;IDENTIFIED VIA authentication_plugin&lt;/code&gt; allows you to specify that the account should be authenticated by a specific &lt;a href=&quot;../authentication-plugins/index&quot;&gt;authentication plugin&lt;/a&gt;. The plugin name must be an active authentication plugin as per &lt;code&gt;&lt;a href=&quot;../show-plugins/index&quot;&gt;SHOW PLUGINS&lt;/a&gt;&lt;/code&gt;. If it doesn't show up in that output, then you will need to install it with &lt;code&gt;&lt;a href=&quot;../install-plugin/index&quot;&gt;INSTALL PLUGIN&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../install-soname/index&quot;&gt;INSTALL SONAME&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;code&gt;IDENTIFIED VIA authentication_plugin&lt;/code&gt; 을 사용하면 특정 &lt;a href=&quot;../authentication-plugins/index&quot;&gt;인증 플러그인으로&lt;/a&gt; 계정을 인증 하도록 지정할 수 있습니다 . 플러그인 이름은 &lt;code&gt;&lt;a href=&quot;../show-plugins/index&quot;&gt;SHOW PLUGINS&lt;/a&gt;&lt;/code&gt; 에 따라 활성화 된 인증 플러그인이어야합니다 . 해당 출력에 표시되지 않으면 &lt;code&gt;&lt;a href=&quot;../install-plugin/index&quot;&gt;INSTALL PLUGIN&lt;/a&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;a href=&quot;../install-soname/index&quot;&gt;INSTALL SONAME&lt;/a&gt;&lt;/code&gt; 으로 설치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b12b086e51e6958b651c8db99644c66d2e68d7a9" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;USING&lt;/code&gt; clause allows users to provide an authentication string to a plugin. The authentication string's format and meaning is completely defined by the plugin.</source>
          <target state="translated">선택적 &lt;code&gt;USING&lt;/code&gt; 절을 사용하면 플러그인에 인증 문자열을 제공 할 수 있습니다. 인증 문자열의 형식과 의미는 플러그인에 의해 완전히 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="ee5f7c82dafb28112bfcab04820efd980dec08cc" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WITH ADMIN&lt;/code&gt; clause determines whether the current user, the current role or another user or role has use of the newly created role. If the clause is omitted, &lt;code&gt;WITH ADMIN CURRENT_USER&lt;/code&gt; is treated as the default, which means that the current user will be able to &lt;code&gt;&lt;a href=&quot;../grant/index#roles&quot;&gt;GRANT&lt;/a&gt;&lt;/code&gt; this role to users.</source>
          <target state="translated">선택적인 &lt;code&gt;WITH ADMIN&lt;/code&gt; 절은 현재 사용자, 현재 역할 또는 다른 사용자 또는 역할이 새로 작성된 역할을 사용하는지 여부를 판별합니다. 절을 생략하면 &lt;code&gt;WITH ADMIN CURRENT_USER&lt;/code&gt; 가 기본값으로 처리되므로 현재 사용자 가이 역할을 사용자에게 &lt;code&gt;&lt;a href=&quot;../grant/index#roles&quot;&gt;GRANT&lt;/a&gt;&lt;/code&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f4c953132f155cea095b0e4a21ef4a584715274" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WORK&lt;/code&gt; keyword is supported for &lt;code&gt;COMMIT&lt;/code&gt; and &lt;code&gt;ROLLBACK&lt;/code&gt;, as are the &lt;code&gt;CHAIN&lt;/code&gt; and &lt;code&gt;RELEASE&lt;/code&gt; clauses. &lt;code&gt;CHAIN&lt;/code&gt; and &lt;code&gt;RELEASE&lt;/code&gt; can be used for additional control over transaction completion. The value of the &lt;a href=&quot;../server-system-variables/index#completion_type&quot;&gt;completion_type&lt;/a&gt; system variable determines the default completion behavior.</source>
          <target state="translated">선택적 &lt;code&gt;WORK&lt;/code&gt; 키워드는 &lt;code&gt;CHAIN&lt;/code&gt; 및 &lt;code&gt;RELEASE&lt;/code&gt; 절 과 마찬가지로 &lt;code&gt;COMMIT&lt;/code&gt; 및 &lt;code&gt;ROLLBACK&lt;/code&gt; 에 지원됩니다 . &lt;code&gt;CHAIN&lt;/code&gt; 및 &lt;code&gt;RELEASE&lt;/code&gt; 는 트랜잭션 완료에 대한 추가 제어를 위해 사용될 수 있습니다. &lt;a href=&quot;../server-system-variables/index#completion_type&quot;&gt;completion_type&lt;/a&gt; 시스템 변수 의 값은 기본 완료 동작을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="716a1109e547f96e4459a8e07f84d9ee425eee1e" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;options&lt;/em&gt; flag can be set to &lt;code&gt;1&lt;/code&gt; to add a bounding box to the output.</source>
          <target state="translated">선택적 &lt;em&gt;옵션&lt;/em&gt; 플래그를 &lt;code&gt;1&lt;/code&gt; 로 설정 하여 출력에 경계 상자를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="347be1bfff9ca406cb802098a35f6576599e678f" translate="yes" xml:space="preserve">
          <source>The optional &lt;em&gt;precision&lt;/em&gt; determines the microsecond precision. See &lt;a href=&quot;../microseconds-in-mariadb/index&quot;&gt;Microseconds in MariaDB&lt;/a&gt;.</source>
          <target state="translated">선택적 &lt;em&gt;정밀도&lt;/em&gt; 는 마이크로 초 &lt;em&gt;정밀도를&lt;/em&gt; 결정합니다. &lt;a href=&quot;../microseconds-in-mariadb/index&quot;&gt;MariaDB의 마이크로 초를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a799e4bd5775252914f03aa29b67f42a444c0db" translate="yes" xml:space="preserve">
          <source>The optional ALGORITHM clause is an extension to standard SQL. It affects how MariaDB processes the view. ALGORITHM takes three values: MERGE, TEMPTABLE, or UNDEFINED. The default algorithm is UNDEFINED if no ALGORITHM clause is present. See &lt;a href=&quot;../view-algorithms/index&quot;&gt;View Algorithms&lt;/a&gt; for more information.</source>
          <target state="translated">선택적 ALGORITHM 절은 표준 SQL의 확장입니다. MariaDB가 뷰를 처리하는 방법에 영향을줍니다. ALGORITHM은 MERGE, TEMPTABLE 또는 UNDEFINED의 세 가지 값을가집니다. ALGORITHM 절이 없으면 기본 알고리즘은 UNDEFINED입니다. 자세한 내용은 &lt;a href=&quot;../view-algorithms/index&quot;&gt;알고리즘보기&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fb69c4d1b9e61591b64cda35295038ba092a9bbf" translate="yes" xml:space="preserve">
          <source>The optional AS clause permits casting the input string to a binary or non-binary string, as well as to a particular length.</source>
          <target state="translated">선택적 AS 절을 사용하면 입력 문자열을 이진 또는 이진이 아닌 문자열과 특정 길이로 캐스팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99305d8837af8b3e2e4b034552d6ef32a48a1a3a" translate="yes" xml:space="preserve">
          <source>The optional LEVEL clause specifies that the return value should contain weights for specific collation levels. The &lt;code&gt;levels&lt;/code&gt; specifier can either be a single integer, a comma-separated list of integers, or a range of integers separated by a dash (whitespace is ignored). Integers can range from 1 to a maximum of 6, dependent on the collation, and need to be listed in ascending order.</source>
          <target state="translated">선택적 LEVEL 절은 반환 값에 특정 데이터 정렬 수준에 대한 가중치가 포함되도록 지정합니다. &lt;code&gt;levels&lt;/code&gt; 중 어느 하나의 정수, 정수 쉼표로 구분하거나, 정수의 범위 일 수 지정자 (무시 공백) 대시에 의해 분리된다. 데이터 정렬에 따라 정수의 범위는 1에서 최대 6까지이며 오름차순으로 나열해야합니다.</target>
        </trans-unit>
        <trans-unit id="4569decbf3ac0572684aa7b18838714e33126088" translate="yes" xml:space="preserve">
          <source>The optional clause &lt;code&gt;RESTART [ WITH restart ]&lt;/code&gt; sets the next value for the sequence. This is equivalent to calling the &lt;a href=&quot;../setval/index&quot;&gt;SETVAL()&lt;/a&gt; function with the &lt;code&gt;is_used&lt;/code&gt; argument as 0. The specified value will be returned by the next call of nextval. Using &lt;code&gt;RESTART&lt;/code&gt; with no restart value is equivalent to supplying the start value that was recorded by &lt;a href=&quot;../create-sequence/index&quot;&gt;CREATE SEQUENCE&lt;/a&gt; or last set by &lt;code&gt;ALTER SEQUENCE START WITH&lt;/code&gt;.</source>
          <target state="translated">선택적 절인 &lt;code&gt;RESTART [ WITH restart ]&lt;/code&gt; 는 시퀀스의 다음 값을 설정합니다. 이것은 &lt;code&gt;is_used&lt;/code&gt; 인수를 0으로 하여 &lt;a href=&quot;../setval/index&quot;&gt;SETVAL ()&lt;/a&gt; 함수 를 호출하는 것과 같습니다 . 지정된 값은 nextval의 다음 호출에 의해 리턴됩니다. 재시작 값없이 &lt;code&gt;RESTART&lt;/code&gt; 를 사용 하는 것은 &lt;a href=&quot;../create-sequence/index&quot;&gt;CREATE SEQUENCE에&lt;/a&gt; 의해 기록 되었거나 &lt;code&gt;ALTER SEQUENCE START WITH&lt;/code&gt; 에 의해 마지막으로 설정된 시작 값을 제공하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e060ea3fd774e3533ade4324adb420766eb83c76" translate="yes" xml:space="preserve">
          <source>The optional name or pattern of the zip entry or entries to be used with the table. If not specified, all entries or only the first one will be used depending on the &lt;em&gt;mulentries&lt;/em&gt; option setting.</source>
          <target state="translated">zip 항목 또는 테이블과 함께 사용할 항목의 선택적 이름 또는 패턴입니다. 지정하지 않으면 &lt;em&gt;mulentries&lt;/em&gt; 옵션 설정 에 따라 모든 항목 또는 첫 번째 항목 만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="90fa82557b43170ba1bd3362ed49b14f63f879ab" translate="yes" xml:space="preserve">
          <source>The optional parameter can either be one or more &lt;em&gt;keywords&lt;/em&gt;, or a Groonga &lt;em&gt;query&lt;/em&gt;.</source>
          <target state="translated">선택적 매개 변수는 하나 이상의 &lt;em&gt;키워드&lt;/em&gt; 또는 Groonga &lt;em&gt;쿼리 일 수 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8d6b95ee44e1b10282bd0ce54eff1f81e29702b9" translate="yes" xml:space="preserve">
          <source>The optional parameters include:</source>
          <target state="translated">선택적 매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1590d770ea50d0ca6399977cfb9240b9d707e092" translate="yes" xml:space="preserve">
          <source>The optional parts of the format are:</source>
          <target state="translated">형식의 선택적 부분은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a17fa18b6df3148bf081e711e16b906e456eeb8" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;HARD | SOFT&lt;/code&gt; and &lt;code&gt;USER username&lt;/code&gt; were introduced in &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-532-release-notes/&quot;&gt;MariaDB 5.3.2&lt;/a&gt;</source>
          <target state="translated">옵션 &lt;code&gt;HARD | SOFT&lt;/code&gt; 및 &lt;code&gt;USER username&lt;/code&gt; 이 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-532-release-notes/&quot;&gt;MariaDB 5.3.2&lt;/a&gt; 에서 도입되었습니다</target>
        </trans-unit>
        <trans-unit id="7469433148a8bb79a1b75e7454ba85c0530ff8db" translate="yes" xml:space="preserve">
          <source>The options and system variables related to &lt;a href=&quot;../semisynchronous-replication/index&quot;&gt;Semisynchronous Replication&lt;/a&gt; are described &lt;a href=&quot;../semisynchronous-replication/index#system-variables&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../semisynchronous-replication/index&quot;&gt;반 동기식 복제&lt;/a&gt; 와 관련된 옵션 및 시스템 변수 가 &lt;a href=&quot;../semisynchronous-replication/index#system-variables&quot;&gt;여기&lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c2d077a0cc9bd2635cd8c5e48e8943e9c7badee" translate="yes" xml:space="preserve">
          <source>The options and system variables related to the &lt;a href=&quot;../mroonga/index&quot;&gt;Mroonga&lt;/a&gt; storage engine can be found &lt;a href=&quot;../mroonga-system-variables/index&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../mroonga/index&quot;&gt;Mroonga&lt;/a&gt; 스토리지 엔진 과 관련된 옵션 및 시스템 변수 는 &lt;a href=&quot;../mroonga-system-variables/index&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02833cd024c1ad4be93e8b97ad1711fe9281b7a3" translate="yes" xml:space="preserve">
          <source>The options and system variables related to the &lt;a href=&quot;../s3-storage-engine/index&quot;&gt;S3&lt;/a&gt; storage engine can be found &lt;a href=&quot;../s3-storage-engine-system-variables/index&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../s3-storage-engine/index&quot;&gt;S3&lt;/a&gt; 스토리지 엔진 과 관련된 옵션 및 시스템 변수 는 &lt;a href=&quot;../s3-storage-engine-system-variables/index&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8536169c5e4a9a03f1a4d0e2f7d4e8ceadf4316" translate="yes" xml:space="preserve">
          <source>The options and system variables related to the &lt;a href=&quot;../spider/index&quot;&gt;Spider&lt;/a&gt; storage engine can be found &lt;a href=&quot;../spider-server-system-variables/index&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../spider/index&quot;&gt;Spider&lt;/a&gt; 스토리지 엔진 과 관련된 옵션 및 시스템 변수 는 &lt;a href=&quot;../spider-server-system-variables/index&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0735af617cecd5d12efa9f29b1cf6a602162af0a" translate="yes" xml:space="preserve">
          <source>The options and system variables related to the &lt;a href=&quot;../tokudb/index&quot;&gt;TokuDB&lt;/a&gt; storage engine can be found &lt;a href=&quot;../tokudb-system-variables/index&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../tokudb/index&quot;&gt;TokuDB&lt;/a&gt; 스토리지 엔진 과 관련된 옵션 및 시스템 변수 는 &lt;a href=&quot;../tokudb-system-variables/index&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b75d04f3e0708c86bfd08edb07badea0b5de939" translate="yes" xml:space="preserve">
          <source>The options elated to the &lt;code&gt;&lt;a href=&quot;../aws-key-management-encryption-plugin/index&quot;&gt;aws_key_management&lt;/a&gt;&lt;/code&gt; encryption plugin can be found &lt;a href=&quot;../aws-key-management-encryption-plugin/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../aws-key-management-encryption-plugin/index&quot;&gt;aws_key_management&lt;/a&gt;&lt;/code&gt; 암호화 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../aws-key-management-encryption-plugin/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83a182b1f9850c7529a516f4f4069cfd7d721902" translate="yes" xml:space="preserve">
          <source>The options for &lt;code&gt;ALTER SEQUENCE&lt;/code&gt; can be given in any order.</source>
          <target state="translated">&lt;code&gt;ALTER SEQUENCE&lt;/code&gt; 의 옵션 은 임의의 순서로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9226213bc947703e4827fbc16e92872fb5f98fba" translate="yes" xml:space="preserve">
          <source>The options for &lt;code&gt;CREATE SEQUENCE&lt;/code&gt; can be given in any order, optionally followed by &lt;code&gt;table_options&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CREATE SEQUENCE&lt;/code&gt; 의 옵션 은 임의의 순서로 제공 될 수 있으며, 선택적으로 &lt;code&gt;table_options&lt;/code&gt; 가 옵니다 .</target>
        </trans-unit>
        <trans-unit id="8db2516d8f29f0da5ed9094176fef8453d88343c" translate="yes" xml:space="preserve">
          <source>The options for the HandlerSocket plugin are all described on the &lt;a href=&quot;../handlersocket-configuration-options/index&quot;&gt;HandlerSocket Configuration Option&lt;/a&gt; page.</source>
          <target state="translated">HandlerSocket 플러그인의 옵션은 모두 &lt;a href=&quot;../handlersocket-configuration-options/index&quot;&gt;HandlerSocket 구성 옵션&lt;/a&gt; 페이지 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bcef8cf9d10b7f48c7da4d847ee0c2a8ebfdc65" translate="yes" xml:space="preserve">
          <source>The options related to &lt;a href=&quot;../galera/index&quot;&gt;Galera Cluster&lt;/a&gt; are described below.</source>
          <target state="translated">&lt;a href=&quot;../galera/index&quot;&gt;Galera Cluster&lt;/a&gt; 관련 옵션 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43df402054659b3f1be071ce6a8e508c57fb47d4" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;a href=&quot;../aria/index&quot;&gt;Aria&lt;/a&gt; storage engine are described below.</source>
          <target state="translated">&lt;a href=&quot;../aria/index&quot;&gt;Aria&lt;/a&gt; 스토리지 엔진 과 관련된 옵션 이 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="13c8c55754dcaa2f3e34d404e312be74299e8429" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;a href=&quot;../connect/index&quot;&gt;CONNECT&lt;/a&gt; storage engine are described below.</source>
          <target state="translated">&lt;a href=&quot;../connect/index&quot;&gt;CONNECT&lt;/a&gt; 스토리지 엔진 과 관련된 옵션 이 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea2434a0cc498753a612f8adc4853f52b3394a17" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; storage engine are described below.</source>
          <target state="translated">&lt;a href=&quot;../innodb/index&quot;&gt;InnoDB&lt;/a&gt; 스토리지 엔진 과 관련된 옵션 이 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c45bfff7bbb37f581212d3b95b8a47813dd165d" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;a href=&quot;../myisam-storage-engine/index&quot;&gt;MyISAM&lt;/a&gt; storage engine are described below.</source>
          <target state="translated">&lt;a href=&quot;../myisam-storage-engine/index&quot;&gt;MyISAM&lt;/a&gt; 스토리지 엔진 과 관련된 옵션 이 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2153b717ca076a8d5951792c10128778ac182a15" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;a href=&quot;../myrocks/index&quot;&gt;MyRocks&lt;/a&gt; storage engine are described below.</source>
          <target state="translated">&lt;a href=&quot;../myrocks/index&quot;&gt;MyRocks&lt;/a&gt; 스토리지 엔진 과 관련된 옵션 이 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="528602de2e44ca860131c65fa63d9f53f4647f0b" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;a href=&quot;../performance-schema/index&quot;&gt;Performance Schema&lt;/a&gt; are described below.</source>
          <target state="translated">&lt;a href=&quot;../performance-schema/index&quot;&gt;성능 스키마&lt;/a&gt; 와 관련된 옵션 이 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c97723ff7fafe4813f2455a2316c3df1b3d6722" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-ed25519/index&quot;&gt;ed25519&lt;/a&gt;&lt;/code&gt; authentication plugin can be found &lt;a href=&quot;../authentication-plugin-ed25519/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../authentication-plugin-ed25519/index&quot;&gt;ed25519&lt;/a&gt;&lt;/code&gt; 인증 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../authentication-plugin-ed25519/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30c8fa55eacd0dd07bfd32af84b46c5e1092fd16" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-gssapi/index&quot;&gt;gssapi&lt;/a&gt;&lt;/code&gt; authentication plugin can be found &lt;a href=&quot;../authentication-plugin-gssapi/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../authentication-plugin-gssapi/index&quot;&gt;gssapi&lt;/a&gt;&lt;/code&gt; 인증 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../authentication-plugin-gssapi/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83e20c6cb5dc330c27527be7ef31827b9c59f952" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-named-pipe/index&quot;&gt;named_pipe&lt;/a&gt;&lt;/code&gt; authentication plugin can be found &lt;a href=&quot;../authentication-plugin-named-pipe/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../authentication-plugin-named-pipe/index&quot;&gt;named_pipe&lt;/a&gt;&lt;/code&gt; 인증 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../authentication-plugin-named-pipe/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="991c614227d11a6ed47cde427db9c9364d5ac6ba" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-pam/index&quot;&gt;pam&lt;/a&gt;&lt;/code&gt; authentication plugin can be found &lt;a href=&quot;../authentication-plugin-pam/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../authentication-plugin-pam/index&quot;&gt;pam&lt;/a&gt;&lt;/code&gt; 인증 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../authentication-plugin-pam/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8ca44a6e2623e2911d6d8a1be821a2bd28a899a" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../authentication-plugin-unix-socket/index&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; authentication plugin can be found &lt;a href=&quot;../authentication-plugin-unix-socket/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../authentication-plugin-unix-socket/index&quot;&gt;unix_socket&lt;/a&gt;&lt;/code&gt; 인증 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../authentication-plugin-unix-socket/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d158496f58e5ac4e1c361afe42b94983db5e176" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../cracklib_password_check/index&quot;&gt;cracklib_password_check&lt;/a&gt;&lt;/code&gt; password validation plugin can be found &lt;a href=&quot;../cracklib_password_check/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../cracklib_password_check/index&quot;&gt;cracklib_password_check&lt;/a&gt;&lt;/code&gt; 비밀번호 유효성 검사 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../cracklib_password_check/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6347704685f925c8c1a725d4d2aeb2a01edab49b" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../disks-plugin/index&quot;&gt;DISKS&lt;/a&gt;&lt;/code&gt; information schema plugin can be found &lt;a href=&quot;../disks-plugin/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../disks-plugin/index&quot;&gt;DISKS&lt;/a&gt;&lt;/code&gt; 정보 스키마 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../disks-plugin/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72bc204de6aa6526528f00cc6d05c2aa8939447c" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../feedback-plugin/index&quot;&gt;feedback&lt;/a&gt;&lt;/code&gt; plugin can be found &lt;a href=&quot;../feedback-plugin/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../feedback-plugin/index&quot;&gt;feedback&lt;/a&gt;&lt;/code&gt; 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../feedback-plugin/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2fe867af78b6f0dc146b6acf2218fd0d092aabb8" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../file-key-management-encryption-plugin/index&quot;&gt;file_key_management&lt;/a&gt;&lt;/code&gt; encryption plugin can be found &lt;a href=&quot;../file-key-management-encryption-plugin/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../file-key-management-encryption-plugin/index&quot;&gt;file_key_management&lt;/a&gt;&lt;/code&gt; 암호화 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../file-key-management-encryption-plugin/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87a1977a0b59d45d249442903e2b661376911ef9" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../locales-plugin/index&quot;&gt;LOCALES&lt;/a&gt;&lt;/code&gt; information schema plugin can be found &lt;a href=&quot;../locales-plugin/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../locales-plugin/index&quot;&gt;LOCALES&lt;/a&gt;&lt;/code&gt; 정보 스키마 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../locales-plugin/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab33c66514423c25b38c82d97b34797d3c9fee29" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../metadata_lock_info/index&quot;&gt;METADATA_LOCK_INFO&lt;/a&gt;&lt;/code&gt; information schema plugin can be found &lt;a href=&quot;../metadata_lock_info/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../metadata_lock_info/index&quot;&gt;METADATA_LOCK_INFO&lt;/a&gt;&lt;/code&gt; 정보 스키마 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../metadata_lock_info/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c0b5ea47735469e6f9396254e3e16a60c7eeb1a" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../query-cache-information-plugin/index&quot;&gt;QUERY_CACHE_INFO&lt;/a&gt;&lt;/code&gt; information schema plugin can be found &lt;a href=&quot;../query-cache-information-plugin/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../query-cache-information-plugin/index&quot;&gt;QUERY_CACHE_INFO&lt;/a&gt;&lt;/code&gt; 정보 스키마 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../query-cache-information-plugin/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76255f246cef7f7019f72fa2ef7dce0d9c3597f4" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../query-response-time-plugin/index&quot;&gt;QUERY_RESPONSE_TIME&lt;/a&gt;&lt;/code&gt; information schema plugin can be found &lt;a href=&quot;../query-response-time-plugin/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../query-response-time-plugin/index&quot;&gt;QUERY_RESPONSE_TIME&lt;/a&gt;&lt;/code&gt; 정보 스키마 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../query-response-time-plugin/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72995972bad5c871910931f188ca9899d7bd279a" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../query-response-time-plugin/index&quot;&gt;QUERY_RESPONSE_TIME_AUDIT&lt;/a&gt;&lt;/code&gt; audit plugin can be found &lt;a href=&quot;../query-response-time-plugin/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../query-response-time-plugin/index&quot;&gt;QUERY_RESPONSE_TIME_AUDIT&lt;/a&gt;&lt;/code&gt; 감사 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../query-response-time-plugin/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d39810605d7813178846c21a6cc65e3dcb1a27c7" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../semisynchronous-replication/index&quot;&gt;rpl_semi_sync_master&lt;/a&gt;&lt;/code&gt; replication plugin can be found &lt;a href=&quot;../semisynchronous-replication/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../semisynchronous-replication/index&quot;&gt;rpl_semi_sync_master&lt;/a&gt;&lt;/code&gt; 복제 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../semisynchronous-replication/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8983c62d9cf7244f8eb35fff0acf6dc0e070898c" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../semisynchronous-replication/index&quot;&gt;rpl_semi_sync_slave&lt;/a&gt;&lt;/code&gt; replication plugin can be found &lt;a href=&quot;../semisynchronous-replication/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../semisynchronous-replication/index&quot;&gt;rpl_semi_sync_slave&lt;/a&gt;&lt;/code&gt; 복제 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../semisynchronous-replication/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="abfb24423cf8f2482f7e433978ed453830a54d47" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../simple_password_check/index&quot;&gt;simple_password_check&lt;/a&gt;&lt;/code&gt; password validation plugin can be found &lt;a href=&quot;../simple_password_check/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../simple_password_check/index&quot;&gt;simple_password_check&lt;/a&gt;&lt;/code&gt; 비밀번호 유효성 검증 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../simple_password_check/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23287379283ec7c3f98243418e9521879185ceb8" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../sql-error-log-plugin/index&quot;&gt;SQL_ERROR_LOG&lt;/a&gt;&lt;/code&gt; audit plugin can be found &lt;a href=&quot;../sql-error-log-plugin/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../sql-error-log-plugin/index&quot;&gt;SQL_ERROR_LOG&lt;/a&gt;&lt;/code&gt; 감사 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../sql-error-log-plugin/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a148dc2c53de8e985b03c04e583132055befeef5" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../user-variables-plugin/index&quot;&gt;user_variables&lt;/a&gt;&lt;/code&gt; information schema plugin can be found &lt;a href=&quot;../user-variables-plugin/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../user-variables-plugin/index&quot;&gt;user_variables&lt;/a&gt;&lt;/code&gt; 정보 스키마 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../user-variables-plugin/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25c90485f5b8f3e467eb1a4eb214711d8a6c4a0d" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../wsrep_info-plugin/index&quot;&gt;WSREP_MEMBERSHIP&lt;/a&gt;&lt;/code&gt; information schema plugin can be found &lt;a href=&quot;../wsrep_info-plugin/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../wsrep_info-plugin/index&quot;&gt;WSREP_MEMBERSHIP&lt;/a&gt;&lt;/code&gt; 정보 스키마 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../wsrep_info-plugin/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b6de3f717385f6bdb818b640a82808a4473fe56" translate="yes" xml:space="preserve">
          <source>The options related to the &lt;code&gt;&lt;a href=&quot;../wsrep_info-plugin/index&quot;&gt;WSREP_STATUS&lt;/a&gt;&lt;/code&gt; information schema plugin can be found &lt;a href=&quot;../wsrep_info-plugin/index#options&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;../wsrep_info-plugin/index&quot;&gt;WSREP_STATUS&lt;/a&gt;&lt;/code&gt; 정보 스키마 플러그인 과 관련된 옵션 은 &lt;a href=&quot;../wsrep_info-plugin/index#options&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="22ada6b459be5f2561bd814322d7d48c7aba1522" translate="yes" xml:space="preserve">
          <source>The options that can be used by DATE_FORMAT(), as well as its inverse &lt;a href=&quot;../str_to_date/index&quot;&gt;STR_TO_DATE&lt;/a&gt;() and the &lt;a href=&quot;../from_unixtime/index&quot;&gt;FROM_UNIXTIME()&lt;/a&gt; function, are:</source>
          <target state="translated">DATE_FORMAT () 및 역 &lt;a href=&quot;../str_to_date/index&quot;&gt;STR_TO_DATE&lt;/a&gt; () 및 &lt;a href=&quot;../from_unixtime/index&quot;&gt;FROM_UNIXTIME ()&lt;/a&gt; 함수에서 사용할 수있는 옵션 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e40f70abece06c8f86b874ab2896f75f2dae4ddb" translate="yes" xml:space="preserve">
          <source>The options that can be used by FROM_UNIXTIME(), as well as &lt;a href=&quot;../date_format/index&quot;&gt;DATE_FORMAT()&lt;/a&gt; and &lt;a href=&quot;../str_to_date/index&quot;&gt;STR_TO_DATE()&lt;/a&gt;, are:</source>
          <target state="translated">FROM_UNIXTIME &lt;a href=&quot;../date_format/index&quot;&gt;()&lt;/a&gt; 및 DATE_FORMAT () 및 &lt;a href=&quot;../str_to_date/index&quot;&gt;STR_TO_DATE ()&lt;/a&gt; 에서 사용할 수있는 옵션 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a3567357095111996ee0e326d193bf775005cc1a" translate="yes" xml:space="preserve">
          <source>The options that can be used by STR_TO_DATE(), as well as its inverse &lt;a href=&quot;../date_format/index&quot;&gt;DATE_FORMAT()&lt;/a&gt; and the &lt;a href=&quot;../from_unixtime/index&quot;&gt;FROM_UNIXTIME()&lt;/a&gt; function, are:</source>
          <target state="translated">STR_TO_DATE &lt;a href=&quot;../date_format/index&quot;&gt;()&lt;/a&gt; 및 역 DATE_FORMAT () 및 &lt;a href=&quot;../from_unixtime/index&quot;&gt;FROM_UNIXTIME ()&lt;/a&gt; 함수에서 사용할 수있는 옵션 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a33502fb40cba5e0a2d9a9d787c117c9cec71fda" translate="yes" xml:space="preserve">
          <source>The options used in this definition are the same as the one used later for the actual CUSTOMERS data tables except that:</source>
          <target state="translated">이 정의에 사용 된 옵션은 다음을 제외하고 실제 CUSTOMERS 데이터 테이블에 대해 나중에 사용 된 옵션과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="39ad7c4e44cdb6f81c8f45d40ebbbccad185ecdf" translate="yes" xml:space="preserve">
          <source>The options you have are:</source>
          <target state="translated">사용할 수있는 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="38f72f8a7a3b89f72c3c11be1b9abe5580ecc368" translate="yes" xml:space="preserve">
          <source>The order by columns do not need to be in the select list but need to be available from the query result set.</source>
          <target state="translated">열 순서는 선택 목록에있을 필요는 없지만 쿼리 결과 집합에서 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ae53234b039431d399a24985d7583a208364dabe" translate="yes" xml:space="preserve">
          <source>The order is somewhat related to importance of the contribution given to the MariaDB project, but this is not 100% accurate. There is still room for improvements and debate...</source>
          <target state="translated">이 순서는 MariaDB 프로젝트에 대한 기여의 중요성과 다소 관련이 있지만 100 % 정확하지는 않습니다. 여전히 개선과 토론의 여지가 남아 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="b52662a2d02ca2388df5ea7d98c404afe1300268" translate="yes" xml:space="preserve">
          <source>The original CSV-format does not enable IETF-compatible parsing of embedded quote and comma characters. From &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1018-release-notes/&quot;&gt;MariaDB 10.1.8&lt;/a&gt;, it is possible to do so by setting the &lt;a href=&quot;../create-table/index#ietf_quotes&quot;&gt;IETF_QUOTES&lt;/a&gt; option when creating a table.</source>
          <target state="translated">원래 CSV 형식은 포함 된 따옴표 및 쉼표 문자의 IETF 호환 구문 분석을 사용할 수 없습니다. &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1018-release-notes/&quot;&gt;MariaDB 10.1.8&lt;/a&gt; 부터는 테이블을 만들 때 &lt;a href=&quot;../create-table/index#ietf_quotes&quot;&gt;IETF_QUOTES&lt;/a&gt; 옵션 을 설정하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="188f6334757537c0fb5e03ac345b467030d7737e" translate="yes" xml:space="preserve">
          <source>The original code base comes from &lt;a href=&quot;http://mysql.taobao.org/index.php/Patch_source_code#Multi-master_replication&quot;&gt;Taobao, developed by Peng Lixun&lt;/a&gt;. A big thanks to them for this important feature!</source>
          <target state="translated">원래 코드 기반은 &lt;a href=&quot;http://mysql.taobao.org/index.php/Patch_source_code#Multi-master_replication&quot;&gt;Peng Lixun이 개발 한 Taobao에서&lt;/a&gt; 가져온 것 입니다. 이 중요한 기능에 큰 감사를드립니다!</target>
        </trans-unit>
        <trans-unit id="7bf5be187dbb9d428938dd06fa5e6def1e200838" translate="yes" xml:space="preserve">
          <source>The original file, &amp;ldquo;cities.json&amp;rdquo;, has 29352 records. To base a table on this file we must specify the option Pretty=0 in the option list. For instance:</source>
          <target state="translated">원본 파일 &quot;cities.json&quot;에는 29352 개의 레코드가 있습니다. 이 파일을 기반으로 테이블을 만들려면 옵션 목록에서 Pretty = 0 옵션을 지정해야합니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="07b5c17ab960566766d881d828671e0b75f512a0" translate="yes" xml:space="preserve">
          <source>The original old-style connection is an empty string &lt;code&gt;''&lt;/code&gt;. You don't have to use this connection if you don't want to.</source>
          <target state="translated">원래 구식 연결은 빈 문자열 &lt;code&gt;''&lt;/code&gt; 입니다. 원하지 않으면이 연결을 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="df1e64c8264dc5a1e9eb1d6162686cfae02ee520" translate="yes" xml:space="preserve">
          <source>The original table schema shown earlier on this page causes the &lt;em&gt;Row size too large&lt;/em&gt; error, because all of the table's &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;&lt;/code&gt; columns are smaller than 256 bytes, which means that they have to be stored on the row's main data page.</source>
          <target state="translated">이 페이지의 앞부분에 표시된 원래 테이블 스키마는 모든 테이블의 &lt;code&gt;&lt;a href=&quot;../varchar/index&quot;&gt;VARCHAR&lt;/a&gt;&lt;/code&gt; 열이 256 바이트보다 작기 때문에 &lt;em&gt;행 크기가 너무 큰&lt;/em&gt; 오류를 발생시킵니다. 이는 행의 기본 데이터 페이지에 저장되어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c1e0cf885d6fdacc1e08e5e4b88a2135deed6307" translate="yes" xml:space="preserve">
          <source>The other is when the slave SQL thread reads events from the &lt;a href=&quot;../relay-log/index&quot;&gt;relay log&lt;/a&gt;. This is controlled by the slave_sql_verify_checksum option, and is used to detect file system corruption of slave relay log files.</source>
          <target state="translated">다른 하나는 슬레이브 SQL 스레드가 &lt;a href=&quot;../relay-log/index&quot;&gt;릴레이 로그&lt;/a&gt; 에서 이벤트를 읽을 때 입니다. 이는 slave_sql_verify_checksum 옵션에 의해 제어되며 슬레이브 릴레이 로그 파일의 파일 시스템 손상을 감지하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3ca0aad94a69cabf943f4f59b0775f7cfa0a0056" translate="yes" xml:space="preserve">
          <source>The other most important InnoDB variables are:</source>
          <target state="translated">다른 가장 중요한 InnoDB 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="654062dd549d78be906c44b5aabaf33e18c659f8" translate="yes" xml:space="preserve">
          <source>The other ones use data sources provided by the matching JDBC driver. There are currently four wrappers to be used with mysql-6.0.2, mariadb, oracle and postgresql.</source>
          <target state="translated">다른 것들은 일치하는 JDBC 드라이버가 제공하는 데이터 소스를 사용합니다. 현재 mysql-6.0.2, mariadb, oracle 및 postgresql과 함께 사용할 네 개의 래퍼가 있습니다.</target>
        </trans-unit>
        <trans-unit id="99363bc44b3f1d00e6895f84c97fa6d7e9fb111b" translate="yes" xml:space="preserve">
          <source>The other option is to use the bakery scripts. In this case you don't have to compile MariaDB source first.</source>
          <target state="translated">다른 옵션은 빵집 스크립트를 사용하는 것입니다. 이 경우 먼저 MariaDB 소스를 컴파일 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6275566087a54679e76df2f6511e01760961b495" translate="yes" xml:space="preserve">
          <source>The other possible condition kinds are: recursion references and assertions. See the &lt;a href=&quot;http://www.pcre.org&quot;&gt;PCRE documentation&lt;/a&gt; for details.</source>
          <target state="translated">다른 가능한 조건 종류는 재귀 참조 및 어설 션입니다. 자세한 내용은 &lt;a href=&quot;http://www.pcre.org&quot;&gt;PCRE 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6f17d5bb26492dc383191de4415020561a1de891" translate="yes" xml:space="preserve">
          <source>The other problems must be solved by adding to the create table a list of columns that must be translated because they are aliases or/and aliases on aggregate functions that must become a having clause. For example, in this case:</source>
          <target state="translated">다른 문제는 작성 테이블에 변환해야하는 열 목록을 작성 절에 추가해야합니다. 이는 열이 있어야하는 집계 함수의 별명 또는 별명이므로 변환해야합니다. 예를 들어이 경우</target>
        </trans-unit>
        <trans-unit id="892ef4cc9bab06ff259f7454d2b0afc2d6fcf24c" translate="yes" xml:space="preserve">
          <source>The other statements hit one row each.</source>
          <target state="translated">다른 문장들은 한 줄씩 쳤다.</target>
        </trans-unit>
        <trans-unit id="1685d715b1b7bdee0201c925884439922f4d92f9" translate="yes" xml:space="preserve">
          <source>The output can be only produced if the target thread is &lt;em&gt;currently&lt;/em&gt; running a query, which has a ready query plan. If this is not the case, the output will be:</source>
          <target state="translated">대상 스레드에서 &lt;em&gt;현재&lt;/em&gt; 쿼리를 실행중인 쿼리 계획이있는 경우에만 출력을 생성 할 수 있습니다 . 그렇지 않은 경우 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a2c3cdc423d62f6865f386f8d096e786a310256" translate="yes" xml:space="preserve">
          <source>The output consists of the following columns:</source>
          <target state="translated">출력은 다음 열로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="0874642b9c8aeec3722945eade3d73f42dc6bf4b" translate="yes" xml:space="preserve">
          <source>The output contains information on:</source>
          <target state="translated">출력에는 다음에 대한 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="165ba16e3ca87599ac0dfa929a52970e14f140a0" translate="yes" xml:space="preserve">
          <source>The output contains the following fields:</source>
          <target state="translated">출력에는 다음 필드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6683cfd2c4333736035bb0294706491785ecdf1f" translate="yes" xml:space="preserve">
          <source>The output displays only the names of those databases, tables, or columns for which you have some privileges.</source>
          <target state="translated">출력에는 일부 권한이있는 데이터베이스, 테이블 또는 열의 이름 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d995d318098ebe8bbe44ea7a86a02b611c2fbe91" translate="yes" xml:space="preserve">
          <source>The output from &lt;code&gt;SHOW COLLATION&lt;/code&gt; includes all available &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;collations&lt;/a&gt;. The &lt;code&gt;LIKE&lt;/code&gt; clause, if present on its own, indicates which collation names to match. The &lt;code&gt;WHERE&lt;/code&gt; and &lt;code&gt;LIKE&lt;/code&gt; clauses can be given to select rows using more general conditions, as discussed in &lt;a href=&quot;../extended-show/index&quot;&gt;Extended SHOW&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;SHOW COLLATION&lt;/code&gt; 의 출력 에는 사용 가능한 모든 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;데이터 정렬이&lt;/a&gt; 포함됩니다 . &lt;code&gt;LIKE&lt;/code&gt; 의 절은, 그 자체로 존재하는 경우, 일치하는 데이터 정렬 이름을 나타냅니다. &lt;code&gt;WHERE&lt;/code&gt; 및 &lt;code&gt;LIKE&lt;/code&gt; 에서 에서 논의 된 바와 같이 절은 일반적인 조건을 이용하여 행을 선택하기 위해 제공 될 수있는 &lt;a href=&quot;../extended-show/index&quot;&gt;확장 SHOW&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79f58613e1e4790ac5afc7aa9b477baace2a438e" translate="yes" xml:space="preserve">
          <source>The output from mysqlbinlog can be used as input to the mysql client to redo the statements contained in a &lt;a href=&quot;../binary-log/index&quot;&gt;binary log&lt;/a&gt;. This is useful for recovering after a server crash. Here is an example:</source>
          <target state="translated">mysqlbinlog의 출력을 mysql 클라이언트에 대한 입력으로 사용하여 &lt;a href=&quot;../binary-log/index&quot;&gt;이진 로그에&lt;/a&gt; 포함 된 명령문을 다시 실행할 수 있습니다 . 서버 충돌 후 복구하는 데 유용합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e412aee48de72836026d241b4def96763249e458" translate="yes" xml:space="preserve">
          <source>The output from the mysql client when run using the &lt;code&gt;--xml&lt;/code&gt; option also follows the preceding rules.</source>
          <target state="translated">&lt;code&gt;--xml&lt;/code&gt; 옵션을 사용하여 실행할 때 mysql 클라이언트의 출력 도 위의 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="df7cccf0952a5e06212b046edfec11e6963e2b7c" translate="yes" xml:space="preserve">
          <source>The output has only one line. This means that the subquery has been merged into the top-level &lt;code&gt;SELECT&lt;/code&gt;.</source>
          <target state="translated">출력에는 한 줄만 있습니다. 이는 하위 쿼리가 최상위 &lt;code&gt;SELECT&lt;/code&gt; 에 병합되었음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="baf24b7e45cb0fd4d9b80ade573a1ad01147be02" translate="yes" xml:space="preserve">
          <source>The output is always accompanied with a warning which shows the query the target thread is running (this shows what the &lt;code&gt;EXPLAIN&lt;/code&gt; is for):</source>
          <target state="translated">출력은 항상 대상 스레드가 실행중인 쿼리를 나타내는 경고와 함께 표시됩니다 (이는 &lt;code&gt;EXPLAIN&lt;/code&gt; 의 용도를 나타냄).</target>
        </trans-unit>
        <trans-unit id="fe8ccd11225e5b188cd1cfc6d8c7bddf41e1b841" translate="yes" xml:space="preserve">
          <source>The output is useful to determine how much physical I/O was required, how much data was cached, and how many partition blocks were eliminated through use of extent map elimination. The system maintains min / max values for each extent and uses these to help implement where clause filters to completely bypass extents where the value is outside of the min/max range. When a column is ordered (or semi-ordered) during load such as a time column this offer very large performance gains as the system can avoid scanning many extents for the column.</source>
          <target state="translated">출력은 필요한 물리적 I / O 양, 캐시 된 데이터 양 및 범위 맵 제거를 사용하여 제거 된 파티션 블록 수를 판별하는 데 유용합니다. 시스템은 각 익스텐트에 대한 최소 / 최대 값을 유지하고 값을 사용하여 값이 최소 / 최대 범위를 벗어난 범위를 완전히 무시하는 where 절 필터를 구현하는 데 도움이됩니다. 시간 열과 같은로드 중에 열이 주문 (또는 반-주문) 될 때 시스템은 열에 대한 여러 범위의 스캔을 피할 수 있으므로 성능이 크게 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="931ac897fa8f6aaf44b01b73d678c842b993097c" translate="yes" xml:space="preserve">
          <source>The output looks like this:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="23b735f3a8f53e774ab44d68b9e6b94056ac215c" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;&lt;a href=&quot;../explain/index&quot;&gt;EXPLAIN&lt;/a&gt;&lt;/code&gt; for the above cases is:</source>
          <target state="translated">위의 경우 &lt;code&gt;&lt;a href=&quot;../explain/index&quot;&gt;EXPLAIN&lt;/a&gt;&lt;/code&gt; 의 출력 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aed079b95c053239e330cb1f0f5a522bd42667f9" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;SELECT CURRENT_ROLE&lt;/code&gt; is equivalent to the contents of the &lt;code&gt;&lt;a href=&quot;../information-schema-enabled_roles-table/index&quot;&gt;ENABLED_ROLES&lt;/a&gt;&lt;/code&gt; Information Schema table.</source>
          <target state="translated">&lt;code&gt;SELECT CURRENT_ROLE&lt;/code&gt; 의 출력은 &lt;code&gt;&lt;a href=&quot;../information-schema-enabled_roles-table/index&quot;&gt;ENABLED_ROLES&lt;/a&gt;&lt;/code&gt; 정보 스키마 테이블 의 내용과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14fefcf0575d62c597f461ca2d541207f1ffdf31" translate="yes" xml:space="preserve">
          <source>The output of MariaDB's &lt;code&gt;EXPLAIN FORMAT=JSON&lt;/code&gt; is different from &lt;code&gt;EXPLAIN FORMAT=JSON&lt;/code&gt; in MySQL.The reasons for that are:</source>
          <target state="translated">MariaDB의의 출력 &lt;code&gt;EXPLAIN FORMAT=JSON&lt;/code&gt; 다른 &lt;code&gt;EXPLAIN FORMAT=JSON&lt;/code&gt; MySQL.The 이유에 해당위한 것입니다 :</target>
        </trans-unit>
        <trans-unit id="2748620d216f7f92504edd508c81a8fb296a0bcc" translate="yes" xml:space="preserve">
          <source>The output of MySQL's &lt;code&gt;EXPLAIN FORMAT=JSON&lt;/code&gt; is not defined. Even MySQL Workbench has trouble parsing it (see this &lt;a href=&quot;http://s.petrunia.net/blog/?p=93&quot;&gt;blog post&lt;/a&gt;).</source>
          <target state="translated">MySQL의 &lt;code&gt;EXPLAIN FORMAT=JSON&lt;/code&gt; 의 출력이 정의되지 않았습니다. MySQL Workbench조차도 구문 분석하는 데 문제가 있습니다 (이 &lt;a href=&quot;http://s.petrunia.net/blog/?p=93&quot;&gt;블로그 게시물&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b8f9e97c09b2303848721f53cc3a32bd42705760" translate="yes" xml:space="preserve">
          <source>The output of the above will look something like this (make sure gpg shows up on each OK line):</source>
          <target state="translated">위의 결과는 다음과 같습니다 (각 확인 행에 gpg가 나타나는지 확인하십시오).</target>
        </trans-unit>
        <trans-unit id="21b232f6a089dafbd840f97eebb21b309b2766c5" translate="yes" xml:space="preserve">
          <source>The output of these statements is unreliably affected by the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#sql_quote_show_create&quot;&gt;sql_quote_show_create&lt;/a&gt;&lt;/code&gt; server system variable - see &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=12719&quot;&gt;http://bugs.mysql.com/bug.php?id=12719&lt;/a&gt;</source>
          <target state="translated">이 명령문의 출력은 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#sql_quote_show_create&quot;&gt;sql_quote_show_create&lt;/a&gt;&lt;/code&gt; 서버 시스템 변수 의 영향을받지 않습니다.&lt;a href=&quot;http://bugs.mysql.com/bug.php?id=12719&quot;&gt; http://bugs.mysql.com/bug.php?id=12719&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="72893eaf2df98327f6b201ec0914c4b291ee134c" translate="yes" xml:space="preserve">
          <source>The output of this statement is unreliably affected by the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#sql_quote_show_create&quot;&gt;sql_quote_show_create&lt;/a&gt;&lt;/code&gt; server system variable - see &lt;a href=&quot;http://bugs.mysql.com/bug.php?id=12719&quot;&gt;http://bugs.mysql.com/bug.php?id=12719&lt;/a&gt;</source>
          <target state="translated">이 명령문의 출력은 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#sql_quote_show_create&quot;&gt;sql_quote_show_create&lt;/a&gt;&lt;/code&gt; 서버 시스템 변수 의 영향을받지 않습니다.&lt;a href=&quot;http://bugs.mysql.com/bug.php?id=12719&quot;&gt; http://bugs.mysql.com/bug.php?id=12719&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7eeecd2bf31da166c211687a9ef3a577e903c7ce" translate="yes" xml:space="preserve">
          <source>The output will be like:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="17117b5b243b78a4eee437c3ab2fedd9b81cc2b1" translate="yes" xml:space="preserve">
          <source>The package is available as rpm, deb and binary. Follow the instructions to install the associated package:</source>
          <target state="translated">패키지는 rpm, deb 및 바이너리로 제공됩니다. 지시 사항에 따라 연관된 패키지를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="6abe1c466b25e1f440e6ffae8540480556c52f31" translate="yes" xml:space="preserve">
          <source>The package is installed as follows:</source>
          <target state="translated">패키지는 다음과 같이 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="489333fc4fb72058764b4ae3fcc1f781863defda" translate="yes" xml:space="preserve">
          <source>The package name is &lt;code&gt;sphinx&lt;/code&gt; and the daemon &lt;code&gt;searchd&lt;/code&gt;.</source>
          <target state="translated">패키지 이름은 &lt;code&gt;sphinx&lt;/code&gt; 와 데몬 &lt;code&gt;searchd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f1bbd762b0681077f7230500b2aa30ffcbc9b19" translate="yes" xml:space="preserve">
          <source>The packages can now be installed with your package manager of choice, for example:</source>
          <target state="translated">패키지는 이제 선택한 패키지 관리자와 함께 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fe21f255ad4f26686e5f7e45637f5d4e3dd3acf" translate="yes" xml:space="preserve">
          <source>The packages provided by Debian's and Ubuntu's default repositories are generated using the Debian packaging in Debian's mirror of MariaDB's source code, which contains some custom changes. The source tree can be found here:</source>
          <target state="translated">데비안과 우분투의 기본 리포지토리가 제공하는 패키지는 데비안 MariaDB 소스 코드의 미러에있는 데비안 패키징을 사용하여 생성됩니다. 소스 트리는 여기에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80e9ca8e8c19d94e7857e8bb5c29881328d31a6e" translate="yes" xml:space="preserve">
          <source>The packages provided by MariaDB Foundation's and MariaDB Corporation's repositories are generated using the Debian packaging in MariaDB's official &lt;a href=&quot;../getting-the-mariadb-source-code/index&quot;&gt;source code&lt;/a&gt;. The Debian packaging scripts are specifically in the &lt;code&gt;debian/&lt;/code&gt; directory.</source>
          <target state="translated">MariaDB Foundation 및 MariaDB Corporation 리포지토리에서 제공하는 패키지는 MariaDB 공식 &lt;a href=&quot;../getting-the-mariadb-source-code/index&quot;&gt;소스 코드&lt;/a&gt; 의 데비안 패키지를 사용하여 생성됩니다 . 데비안 패키징 스크립트는 특히 &lt;code&gt;debian/&lt;/code&gt; 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea36835898b330661de99c8805765224ba82896d" translate="yes" xml:space="preserve">
          <source>The packages that the MariaDB-server package depend on are: MariaDB-client, MariaDB-shared, and MariaDB-common. Therefore, to install &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10311-release-notes/&quot;&gt;MariaDB 10.3.11&lt;/a&gt; from this &lt;code&gt;yum&lt;/code&gt; repository, we would do the following:</source>
          <target state="translated">MariaDB 서버 패키지가 의존하는 패키지는 MariaDB 클라이언트, MariaDB 공유 및 MariaDB 공통입니다. 따라서이 &lt;code&gt;yum&lt;/code&gt; 저장소 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10311-release-notes/&quot;&gt;MariaDB 10.3.11&lt;/a&gt; 을 설치하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ddc40d3be2cf6b73cba450939d3e3ada1af05e56" translate="yes" xml:space="preserve">
          <source>The packages that the MariaDB-server package depend on are: MariaDB-client, MariaDB-shared, and MariaDB-common. Therefore, to install &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10314-release-notes/&quot;&gt;MariaDB 10.3.14&lt;/a&gt; from this &lt;code&gt;zypper&lt;/code&gt; repository, we would do the following:</source>
          <target state="translated">MariaDB 서버 패키지가 의존하는 패키지는 MariaDB 클라이언트, MariaDB 공유 및 MariaDB 공통입니다. 따라서이 &lt;code&gt;zypper&lt;/code&gt; 저장소 에서 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10314-release-notes/&quot;&gt;MariaDB 10.3.14&lt;/a&gt; 를 설치하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="090aecda9ea8bdec399a016d5e3c5250be7f550b" translate="yes" xml:space="preserve">
          <source>The page stays active as long as the syncing slot is taken.</source>
          <target state="translated">동기화 슬롯이 사용되는 동안 페이지는 활성 상태를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="40c6d5e9fd7c67d4a108a8f24b6102e39c171c7e" translate="yes" xml:space="preserve">
          <source>The pages are not easily bookmarked or sent to someone else because the contents shift over time.</source>
          <target state="translated">내용이 시간이 지남에 따라 이동하기 때문에 페이지가 쉽게 북마크되거나 다른 사람에게 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="93b8cf69c49dd144de871e1b0a2a596555f163af" translate="yes" xml:space="preserve">
          <source>The pam_user_map PAM Module</source>
          <target state="translated">pam_user_map PAM 모듈</target>
        </trans-unit>
        <trans-unit id="c8f524746b725901f99466591cd534436bdcaf59" translate="yes" xml:space="preserve">
          <source>The parameter list enclosed within parentheses must always be present. If there are no parameters, an empty parameter list of () should be used. Parameter names are not case sensitive.</source>
          <target state="translated">괄호로 묶인 매개 변수 목록은 항상 존재해야합니다. 매개 변수가없는 경우 빈 매개 변수 목록 ()을 사용해야합니다. 매개 변수 이름은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55ad90f741d6d6a0079f9e744ee9aa05a8396d0b" translate="yes" xml:space="preserve">
          <source>The parent and the child table must use the same storage engine, and must not be &lt;code&gt;TEMPORARY&lt;/code&gt; or partitioned tables. They can be the same table.</source>
          <target state="translated">상위 및 하위 테이블은 동일한 스토리지 엔진을 사용해야하며 &lt;code&gt;TEMPORARY&lt;/code&gt; 또는 파티션 된 테이블이 아니어야합니다 . 그들은 같은 테이블 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11843f5c5700bf58f80d4784a3898d789ea8770d" translate="yes" xml:space="preserve">
          <source>The parition ID for the extent</source>
          <target state="translated">익스텐트의 파티션 ID</target>
        </trans-unit>
        <trans-unit id="86df5e8f16b5597d5797574ab7b430a9c158cc13" translate="yes" xml:space="preserve">
          <source>The parser context: sp_pcontext.h</source>
          <target state="translated">파서 컨텍스트 : sp_pcontext.h</target>
        </trans-unit>
        <trans-unit id="331153d93e7978a35854592c40a3002201577bf6" translate="yes" xml:space="preserve">
          <source>The parsing of the parameter list and body is relatively straightforward:</source>
          <target state="translated">매개 변수 목록과 본문의 구문 분석은 비교적 간단합니다.</target>
        </trans-unit>
        <trans-unit id="cb98b7cd449502f9bea8d1d3f3f9fa7ee0d8663d" translate="yes" xml:space="preserve">
          <source>The partition ID for the extent</source>
          <target state="translated">익스텐트의 파티션 ID</target>
        </trans-unit>
        <trans-unit id="1ae942c2dfdef604da3bcbd0ec37037a68443df7" translate="yes" xml:space="preserve">
          <source>The partition by columns do not need to be in the select list but do need to be available from the query result set.</source>
          <target state="translated">컬럼 별 파티션은 선택 목록에있을 필요는 없지만 조회 결과 세트에서 사용 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="975265a98e8ba4d4eeb7097bbc9daaff5a6e832d" translate="yes" xml:space="preserve">
          <source>The partition field should not be the field first in any key.</source>
          <target state="translated">파티션 필드는 키의 첫 번째 필드가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="882da1e8da198c4a015f77d681b2526ecaaaf34e" translate="yes" xml:space="preserve">
          <source>The partition info in the frm file is not consistent with what can be written into the frm file</source>
          <target state="translated">frm 파일의 파티션 정보가 frm 파일에 쓸 수있는 내용과 일치하지 않습니다</target>
        </trans-unit>
        <trans-unit id="a22d076a4d628f968b46a256cb2bd878e2f17847" translate="yes" xml:space="preserve">
          <source>The partitioning type; one of &lt;code&gt;RANGE&lt;/code&gt;, &lt;code&gt;LIST&lt;/code&gt;, &lt;code&gt;HASH&lt;/code&gt;, &lt;code&gt;LINEAR HASH&lt;/code&gt;, &lt;code&gt;KEY&lt;/code&gt; or &lt;code&gt;LINEAR KEY&lt;/code&gt;.</source>
          <target state="translated">파티셔닝 유형; &lt;code&gt;RANGE&lt;/code&gt; , &lt;code&gt;LIST&lt;/code&gt; , &lt;code&gt;HASH&lt;/code&gt; , &lt;code&gt;LINEAR HASH&lt;/code&gt; , &lt;code&gt;KEY&lt;/code&gt; 또는 &lt;code&gt;LINEAR KEY&lt;/code&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="874bc9f788ef3a00606c999b986ac1dc56284322" translate="yes" xml:space="preserve">
          <source>The partitions can be tables driven by different engines. This relieves the current existing limitation of the partition engine.</source>
          <target state="translated">파티션은 다른 엔진으로 구동되는 테이블 일 수 있습니다. 이는 파티션 엔진의 현재 기존 제한을 완화시킵니다.</target>
        </trans-unit>
        <trans-unit id="677a3a6c92a1bfe3d48c550e84301ff3b0080613" translate="yes" xml:space="preserve">
          <source>The partitions can be tables driven by engines not currently supporting partitioning.</source>
          <target state="translated">파티션은 현재 파티션을 지원하지 않는 엔진으로 구동되는 테이블 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cd8491db90f8b7b09a887ef053e46c908ec0f33" translate="yes" xml:space="preserve">
          <source>The password for both of these plugins should be specified in the plain text in the &lt;code&gt;USING&lt;/code&gt; clause:</source>
          <target state="translated">이 두 플러그인의 비밀번호는 &lt;code&gt;USING&lt;/code&gt; 절의 일반 텍스트로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ba9cf58e063b973d81dea7e942da6012eb2a0e18" translate="yes" xml:space="preserve">
          <source>The password hash doesn't have the expected format. Check if the correct password algorithm is being used with the PASSWORD() function.</source>
          <target state="translated">비밀번호 해시의 예상 형식이 없습니다. PASSWORD () 함수에 올바른 비밀번호 알고리즘이 사용되고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c97e82e83767bbf660d5d8a2b4c09a579d4e66b6" translate="yes" xml:space="preserve">
          <source>The password of the MariaDB account to use when invoking &lt;a href=&quot;../mysqladmin/index&quot;&gt;mysqladmin&lt;/a&gt;. Note that the password value is not optional for this option, unlike for other MariaDB programs.</source>
          <target state="translated">&lt;a href=&quot;../mysqladmin/index&quot;&gt;mysqladmin을&lt;/a&gt; 호출 할 때 사용할 MariaDB 계정의 비밀번호입니다 . 다른 MariaDB 프로그램과 달리이 옵션의 암호 값은 선택 사항이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="86c8036e3d0504e891252fb2962f8e7c77156501" translate="yes" xml:space="preserve">
          <source>The password to use when connecting to the server.</source>
          <target state="translated">서버에 연결할 때 사용할 비밀번호입니다.</target>
        </trans-unit>
        <trans-unit id="635ee9395b37f71770c935db1e8e528ad1bfee24" translate="yes" xml:space="preserve">
          <source>The password to use when connecting to the server. If you use the short option form (&lt;code&gt;-p&lt;/code&gt;), you cannot have a space between the option and the password. If you omit the password value following the &lt;code&gt;--password&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; option on the command line, &lt;em&gt;mysqldump&lt;/em&gt; prompts for one.</source>
          <target state="translated">서버에 연결할 때 사용할 비밀번호입니다. 짧은 옵션 양식 ( &lt;code&gt;-p&lt;/code&gt; )을 사용하면 옵션과 비밀번호 사이에 공백이 없어야합니다. 명령 행 에서 &lt;code&gt;--password&lt;/code&gt; 또는 &lt;code&gt;-p&lt;/code&gt; 옵션 다음에 비밀번호 값을 생략하면 &lt;em&gt;mysqldump가 입력&lt;/em&gt; 하라는 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="24a39f21325e2c853dfaa07c033b24be9bc7f3a5" translate="yes" xml:space="preserve">
          <source>The password to use when connecting to the server. Note that the password value is not optional for this option, unlike for other MariaDB programs&lt;em&gt;&lt;em&gt; Specifying a password on the command line should be considered insecure. You can use an option file to avoid giving the password on the command line.&lt;/em&gt;&lt;/em&gt;</source>
          <target state="translated">서버에 연결할 때 사용할 비밀번호입니다. 다른 MariaDB 프로그램과 달리이 옵션의 암호 값은 선택 사항이 아닙니다 &lt;em&gt;&lt;em&gt;. 명령 줄에 암호를 지정하는 것은 안전하지 않은 것으로 간주해야합니다. 옵션 파일을 사용하여 명령 행에 비밀번호를 제공하지 않아도됩니다.&lt;/em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="407a39c201d09a994cedc972c53bb9575d5bdc25" translate="yes" xml:space="preserve">
          <source>The password to use when connecting to the server. Note that the password value is not optional for this option, unlike for other client programs. Specifying the password on the command-line is generally considered insecure.</source>
          <target state="translated">서버에 연결할 때 사용할 비밀번호입니다. 다른 클라이언트 프로그램과 달리이 옵션의 암호 값은 선택 사항이 아닙니다. 명령 행에서 비밀번호를 지정하면 일반적으로 안전하지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1655e7feb414218c5faf64d41af5c9671700b858" translate="yes" xml:space="preserve">
          <source>The password to use when connecting to the server. The password value is not optional for this option, unlike for other MariaDB programs.</source>
          <target state="translated">서버에 연결할 때 사용할 비밀번호입니다. 다른 MariaDB 프로그램과 달리이 옵션의 암호 값은 선택 사항이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="299d05acf29c6f72a5bb4f97cdcf3a3923af6205" translate="yes" xml:space="preserve">
          <source>The patch adds two system variables:</source>
          <target state="translated">패치는 두 가지 시스템 변수를 추가합니다 :</target>
        </trans-unit>
        <trans-unit id="b3fba1db9ada702ae5e57a79ec11cc1166fe956e" translate="yes" xml:space="preserve">
          <source>The patch is wrapped in #ifdef, but there is a #define straight in mysql_priv.h so simply compiling that tree should produce a binary with optimizer debugging enabled.</source>
          <target state="translated">패치는 #ifdef로 래핑되지만 mysql_priv.h에는 #define이 있으므로 트리를 컴파일하면 최적화 프로그램 디버깅이 활성화 된 바이너리를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="85b9b42a61e33b9f9d1a352f16e1cd8d8953620c" translate="yes" xml:space="preserve">
          <source>The patch to permit multiple locks was &lt;a href=&quot;http://kostja-osipov.livejournal.com/46410.html&quot;&gt;contributed by Konstantin &quot;Kostja&quot; Osipov&lt;/a&gt; (&lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-3917&quot;&gt;MDEV-3917&lt;/a&gt;).</source>
          <target state="translated">다중 잠금을 허용하는 패치는 &lt;a href=&quot;http://kostja-osipov.livejournal.com/46410.html&quot;&gt;Konstantin &quot;Kostja&quot;Osipov&lt;/a&gt; ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-3917&quot;&gt;MDEV-3917&lt;/a&gt; ) 에 의해 제공되었습니다 .</target>
        </trans-unit>
        <trans-unit id="63c7daa2d44ecc1157a1c3520ae96640cf6d9308" translate="yes" xml:space="preserve">
          <source>The path name of the file in which the server should write its process ID. If not provided, the default, &lt;code&gt;host_name.pid&lt;/code&gt; is used.</source>
          <target state="translated">서버가 프로세스 ID를 작성해야하는 파일의 경로 이름입니다. 제공하지 않으면 기본값 인 &lt;code&gt;host_name.pid&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="df65cab270378eedd2bcf66f419fa49df390c40b" translate="yes" xml:space="preserve">
          <source>The path name of the process ID file.</source>
          <target state="translated">프로세스 ID 파일의 경로 이름</target>
        </trans-unit>
        <trans-unit id="0daffe833a56490e19f45f61462fd33f3725bd76" translate="yes" xml:space="preserve">
          <source>The path name to the &lt;a href=&quot;../mysqltest/index&quot;&gt;mysqltest&lt;/a&gt; program.</source>
          <target state="translated">&lt;a href=&quot;../mysqltest/index&quot;&gt;mysqltest&lt;/a&gt; 프로그램 의 경로 이름 .</target>
        </trans-unit>
        <trans-unit id="0627406d9fa60339f493e6dd91375c5ad0f7c537" translate="yes" xml:space="preserve">
          <source>The path specified for %s is too long.</source>
          <target state="translated">% s에 지정된 경로가 너무 깁니다.</target>
        </trans-unit>
        <trans-unit id="3885b5cab3612234b27a9b18c7e14e5bc2fd52b5" translate="yes" xml:space="preserve">
          <source>The path syntax is the same used in JSON CONNECT tables.</source>
          <target state="translated">경로 구문은 JSON CONNECT 테이블에서 사용 된 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7c635f10786d52eb4abd3538fc8bd790507558e3" translate="yes" xml:space="preserve">
          <source>The path to &lt;code&gt;libgalera_smm.so&lt;/code&gt; needs to be defined in the &lt;em&gt;my.cnf&lt;/em&gt; configuration file.</source>
          <target state="translated">&lt;code&gt;libgalera_smm.so&lt;/code&gt; 의 경로 는 &lt;em&gt;my.cnf&lt;/em&gt; 구성 파일 에서 정의해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f3077d39d931b1ccf72620ed5b5c3048ed2a2c42" translate="yes" xml:space="preserve">
          <source>The path to the MariaDB data directory.</source>
          <target state="translated">MariaDB 데이터 디렉토리의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="0176400ccdeba1242b03fd1821735d563913133a" translate="yes" xml:space="preserve">
          <source>The path to the MariaDB installation directory.</source>
          <target state="translated">MariaDB 설치 디렉토리의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="306336de5cdcecc21bbe22bf070bfce7c1584967" translate="yes" xml:space="preserve">
          <source>The path to the data directory.</source>
          <target state="translated">데이터 디렉토리의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="5b168c92c14572f8ac979ec99eae3cd7ceb9d09f" translate="yes" xml:space="preserve">
          <source>The path to the files must also be specified if they're not in the current directory.</source>
          <target state="translated">파일이 현재 디렉토리에 있지 않으면 파일 경로도 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5b7de880407d2dc557bd60e22f805362e50d5c6e" translate="yes" xml:space="preserve">
          <source>The path to the wrapper classes must point to the directory containing the wrappers sub-directory. If a JdbcInterface.jar file was made, its path is the directory where it is located followed by the jar file name. It is unclear where because this will depend on the installation process. If you start from a source distribution, it can be in the storage/connect directory where the CONNECT source files are or where you moved them or compiled the JdbcInterface.jar file.</source>
          <target state="translated">랩퍼 클래스의 경로는 랩퍼 서브 디렉토리를 포함하는 디렉토리를 가리켜 야합니다. JdbcInterface.jar 파일이 작성된 경우 해당 경로는 jar 파일 이름이 뒤에 오는 디렉토리입니다. 설치 프로세스에 따라 달라 지므로 명확하지 않습니다. 소스 분배에서 시작하는 경우 CONNECT 소스 파일이있는 스토리지 / 연결 디렉토리에 있거나 JdbcInterface.jar 파일을 컴파일하거나 컴파일 한 위치에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36572cd90c910ee0936bad066b327fb4b646319b" translate="yes" xml:space="preserve">
          <source>The pattern &lt;code&gt;(?&amp;gt;\d+)foo&lt;/code&gt; from the previous section's example can be rewritten as &lt;code&gt;\d++foo&lt;/code&gt;.</source>
          <target state="translated">이전 섹션의 예제에서 나온 패턴 &lt;code&gt;(?&amp;gt;\d+)foo&lt;/code&gt; 는 &lt;code&gt;\d++foo&lt;/code&gt; 로 다시 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a82eee2190bec12fcc73ed4555d9fc497e8c814d" translate="yes" xml:space="preserve">
          <source>The pattern need not be a literal string. For example, it can be specified as a string expression or table column.</source>
          <target state="translated">패턴은 리터럴 문자열 일 필요는 없습니다. 예를 들어, 문자열 표현식 또는 테이블 열로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b75a718a53811927f57152894ab1b9bc6afecf3" translate="yes" xml:space="preserve">
          <source>The pattern without the non-greedy flag to the quantifier &lt;code&gt;/[*].*[*]/&lt;/code&gt; would match the entire string between the leftmost &lt;code&gt;/*&lt;/code&gt; and the rightmost &lt;code&gt;*/&lt;/code&gt;.</source>
          <target state="translated">수량 자 &lt;code&gt;/[*].*[*]/&lt;/code&gt; 에 대한 욕심없는 플래그가없는 패턴 은 가장 왼쪽의 &lt;code&gt;/*&lt;/code&gt; 와 가장 오른쪽의 &lt;code&gt;*/&lt;/code&gt; 사이의 전체 문자열과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="50781170de874f94420ddbd9ef47736e6f9f32d9" translate="yes" xml:space="preserve">
          <source>The percentile functions have a slightly different syntax from other window functions as can be seen in the example below. These functions can be only applied against numeric values. The argument to the function is the percentile to evaluate. Following 'within group' is the sort expression which indicates the sort column and optionally order. Finally after 'over' is an optional partition by clause, for no partition clause use 'over ()'. The example below utilizes the value 0.5 to calculate the median opportunity amount in the rows. The values differ sometimes because percentile_cont will return the average of the 2 middle rows for an even data set while percentile_desc returns the first encountered in the sort.</source>
          <target state="translated">백분위 수 함수는 아래 예에서 볼 수 있듯이 다른 창 함수와 구문이 약간 다릅니다. 이 기능은 숫자 값에 대해서만 적용 할 수 있습니다. 함수에 대한 인수는 평가할 백분위 수입니다. '그룹 내'다음에는 정렬 열을 표시하고 선택적으로 순서를 나타내는 정렬 표현식이 있습니다. 마지막으로 'over'는 선택적 파티션 기준 절 이후입니다. 파티션 절이 없으면 'over ()'를 사용하십시오. 아래 예는 값 0.5를 사용하여 행의 중간 기회 금액을 계산합니다. percentile_cont는 짝수 데이터 세트에 대한 2 개의 중간 행의 평균을 리턴하고 percentile_desc는 정렬에서 처음 발견 된 값을 리턴하므로 값이 때때로 다릅니다.</target>
        </trans-unit>
        <trans-unit id="765e65212a3a798aa136da05c9aa5825ce810499" translate="yes" xml:space="preserve">
          <source>The performance issues</source>
          <target state="translated">성능 문제</target>
        </trans-unit>
        <trans-unit id="13d12bd8ff436eaf46ec9dbdb9829836d7ee6655" translate="yes" xml:space="preserve">
          <source>The performance issues with &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table=ON&lt;/a&gt; can be exacerbated in cases where the &lt;a href=&quot;../xtradbinnodb-buffer-pool/index&quot;&gt;InnoDB buffer pool&lt;/a&gt; is very large and &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_adaptive_hash_index&quot;&gt;innodb_adaptive_hash_index=ON&lt;/a&gt; is set. In that case, using &lt;a href=&quot;../drop-table/index&quot;&gt;DROP TABLE&lt;/a&gt; followed by &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE&lt;/a&gt; instead of &lt;code&gt;TRUNCATE TABLE&lt;/code&gt; may perform better. Setting &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_adaptive_hash_index&quot;&gt;innodb_adaptive_hash_index=OFF&lt;/a&gt; can also help. In &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10219-release-notes/&quot;&gt;MariaDB 10.2.19&lt;/a&gt; and later, this performance can also be improved by setting &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_safe_truncate&quot;&gt;innodb_safe_truncate=OFF&lt;/a&gt;. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-9459&quot;&gt;MDEV-9459&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;a href=&quot;../xtradbinnodb-buffer-pool/index&quot;&gt;InnoDB 버퍼 풀이&lt;/a&gt; 매우 크고 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_adaptive_hash_index&quot;&gt;innodb_adaptive_hash_index = ON&lt;/a&gt; 이 설정된 경우 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_file_per_table&quot;&gt;innodb_file_per_table = ON&lt;/a&gt; 의 성능 문제 가 악화 될 수 있습니다 . 이 경우 &lt;code&gt;TRUNCATE TABLE&lt;/code&gt; 대신 &lt;a href=&quot;../drop-table/index&quot;&gt;DROP TABLE을&lt;/a&gt; 사용 하고 &lt;a href=&quot;../create-table/index&quot;&gt;CREATE TABLE을&lt;/a&gt; 사용하면 성능이 향상 될 수 있습니다. &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_adaptive_hash_index&quot;&gt;innodb_adaptive_hash_index = OFF를&lt;/a&gt; 설정하면 도움이 될 수 있습니다. 에서는 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-10219-release-notes/&quot;&gt;MariaDB 10.2.19&lt;/a&gt; 나중에,이 성능은 설정함으로써 개선 될 수있다 &lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_safe_truncate&quot;&gt;innodb_safe_truncate = OFF가&lt;/a&gt; . 자세한 내용은 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-9459&quot;&gt;MDEV-9459&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="409ac13d13a14386936d03418bc98ea29251502e" translate="yes" xml:space="preserve">
          <source>The performance of this is O(N), actually about 3N, where N is the number of source rows.</source>
          <target state="translated">이것의 성능은 실제로 약 3N 인 O (N)이며, 여기서 N은 소스 행의 수입니다.</target>
        </trans-unit>
        <trans-unit id="c91e6525758e7d021c2586f2fac36a48b8d83670" translate="yes" xml:space="preserve">
          <source>The performance schema cannot be activated at runtime - it must be set when the server starts by adding the following line in your &lt;code&gt;my.cnf&lt;/code&gt; configuration file.</source>
          <target state="translated">성능 스키마는 런타임시 활성화 될 수 없습니다 . &lt;code&gt;my.cnf&lt;/code&gt; 구성 파일 에 다음 행을 추가하여 서버가 시작될 때 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="746961be58d453371b5ed25e9247217650cfbd6f" translate="yes" xml:space="preserve">
          <source>The period can be separated by spaces:</source>
          <target state="translated">마침표는 공백으로 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0cc6effc4e57a93c729002b6ca9aefdcd7c6220" translate="yes" xml:space="preserve">
          <source>The permitted index_types for each storage engine.</source>
          <target state="translated">각 스토리지 엔진에 허용되는 index_types</target>
        </trans-unit>
        <trans-unit id="27f1a441d8e16b6cf13737b66fe924034e305a96" translate="yes" xml:space="preserve">
          <source>The physical file ColumnStore writes to disk is called a segment file. Once segment files reach the maximum number of extents, ColumnStore automatically creates a new segment file. You can set the maximum number of extents in a segment file using &lt;code&gt;ExtentsPreSegmentFile&lt;/code&gt; in the &lt;code&gt;ColumnStore.xml&lt;/code&gt; file. It should be set to a multiple of the number of DB Roots. The default value is 2.</source>
          <target state="translated">ColumnStore가 디스크에 쓰는 실제 파일을 세그먼트 파일이라고합니다. 세그먼트 파일이 최대 범위 수에 도달하면 ColumnStore가 자동으로 새 세그먼트 파일을 작성합니다. &lt;code&gt;ColumnStore.xml&lt;/code&gt; 파일 에서 &lt;code&gt;ExtentsPreSegmentFile&lt;/code&gt; 을 사용하여 세그먼트 파일에서 최대 범위 수를 설정할 수 있습니다 . DB 루트 수의 배수로 설정해야합니다. 기본값은 2입니다.</target>
        </trans-unit>
        <trans-unit id="e386fc963deb42844028c1a5053103cebd4e5928" translate="yes" xml:space="preserve">
          <source>The placeholder table now contains data from the &lt;code&gt;p0&lt;/code&gt; partition on the source server.</source>
          <target state="translated">자리 표시 자 테이블 에 원본 서버 의 &lt;code&gt;p0&lt;/code&gt; 파티션의 데이터가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="08afd1682ce0266264c037f92106ffe09721bd4c" translate="yes" xml:space="preserve">
          <source>The plugin also adds the &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH USER_STATISTICS&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH CLIENT_STATISTICS&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH INDEX_STATISTICS&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH TABLE_STATISTICS&lt;/a&gt;&lt;/code&gt; statements.</source>
          <target state="translated">플러그인은 &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH USER_STATISTICS&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH CLIENT_STATISTICS&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH INDEX_STATISTICS&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;../flush/index&quot;&gt;FLUSH TABLE_STATISTICS&lt;/a&gt;&lt;/code&gt; 문도 추가합니다.</target>
        </trans-unit>
        <trans-unit id="fc681dc420388a20d97faebbed19aa090c6b589a" translate="yes" xml:space="preserve">
          <source>The plugin can only be built on Windows, Linux and macOS.</source>
          <target state="translated">플러그인은 Windows, Linux 및 macOS에서만 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d582f1a42cc5e88a255d0313b113fd21ef6ea055" translate="yes" xml:space="preserve">
          <source>The plugin directory for the server.</source>
          <target state="translated">서버의 플러그인 디렉토리.</target>
        </trans-unit>
        <trans-unit id="eccd70ce7143adc7a7ad2b461d09a285ff479faf" translate="yes" xml:space="preserve">
          <source>The plugin must be located in the plugin directory, the directory containing all plugin libraries for MariaDB. The path to this directory is configured by the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#plugin_dir&quot;&gt;plugin_dir&lt;/a&gt;&lt;/code&gt; system variable. To see the value of this variable and thereby determine the file path of the plugin library, execute the following SQL statement:</source>
          <target state="translated">플러그인은 MariaDB의 모든 플러그인 라이브러리를 포함하는 디렉토리 인 플러그인 디렉토리에 있어야합니다. 이 디렉토리의 경로는 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#plugin_dir&quot;&gt;plugin_dir&lt;/a&gt;&lt;/code&gt; 시스템 변수로 구성됩니다 . 이 변수의 값을보고 플러그인 라이브러리의 파일 경로를 판별하려면 다음 SQL 문을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="60aad8b43d3cb636adebff0fa0422013f944200f" translate="yes" xml:space="preserve">
          <source>The plugin only works on Linux.</source>
          <target state="translated">플러그인은 Linux에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="755251edc2ee7d5e38d365ef5f41cf5ae82f7e49" translate="yes" xml:space="preserve">
          <source>The plugin requires at least cracklib 2.9.0, so it is not available on Debian/Ubuntu builds before Debian 8 Jessie/Ubuntu 14.04 Trusty, RedHat Enterprise Linux / CentOS 6. (see &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-7305&quot;&gt;MDEV-7305&lt;/a&gt;).</source>
          <target state="translated">플러그인에는 최소한 cracklib 2.9.0이 필요하므로 Debian 8 Jessie / Ubuntu 14.04 Trusty, RedHat Enterprise Linux / CentOS 6 이전의 Debian / Ubuntu 빌드에서는 사용할 수 없습니다 ( &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-7305&quot;&gt;MDEV-7305&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="dd8ed8a019923fe9853161adff7a19d9c0f33ee5" translate="yes" xml:space="preserve">
          <source>The plugin requires that one of the following compilers is used: &lt;code&gt;gcc&lt;/code&gt; 4.8 or later, &lt;code&gt;clang&lt;/code&gt; 3.3 or later, Visual Studio 2013 or later.</source>
          <target state="translated">플러그인을 사용하려면 &lt;code&gt;gcc&lt;/code&gt; 4.8 이상, &lt;code&gt;clang&lt;/code&gt; 3.3 이상, Visual Studio 2013 이상 컴파일러 중 하나를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="20dfeba3544d04f9ff1b33ea3b0f2f7b3088a6fe" translate="yes" xml:space="preserve">
          <source>The plugin uses &lt;a href=&quot;https://github.com/awslabs/aws-sdk-cpp&quot;&gt;AWS C++ SDK&lt;/a&gt;, which introduces the following restrictions:</source>
          <target state="translated">플러그인은 다음과 같은 제한 사항이 도입 된 &lt;a href=&quot;https://github.com/awslabs/aws-sdk-cpp&quot;&gt;AWS C ++ SDK를&lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="befd657d70ac25ce720ffc3c89494dcb321ed665" translate="yes" xml:space="preserve">
          <source>The plugin was designed for following software composition:</source>
          <target state="translated">플러그인은 다음 소프트웨어 구성을 위해 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="af871fc14628e9d018e16cbb2001112ef82988b0" translate="yes" xml:space="preserve">
          <source>The plugin was installed with the &lt;code&gt;&lt;a href=&quot;../install-plugin/index&quot;&gt;INSTALL PLUGIN&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">플러그인은 &lt;code&gt;&lt;a href=&quot;../install-plugin/index&quot;&gt;INSTALL PLUGIN&lt;/a&gt;&lt;/code&gt; 문 으로 설치되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0457f349237d5ecd26497ead5b70d134ff722e83" translate="yes" xml:space="preserve">
          <source>The plugin was installed with the &lt;code&gt;&lt;a href=&quot;../install-soname/index&quot;&gt;INSTALL SONAME&lt;/a&gt;&lt;/code&gt; statement.</source>
          <target state="translated">플러그인은 &lt;code&gt;&lt;a href=&quot;../install-soname/index&quot;&gt;INSTALL SONAME&lt;/a&gt;&lt;/code&gt; 문 으로 설치되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e37a5dfb44740d259f7a45a58f085905bbfc544d" translate="yes" xml:space="preserve">
          <source>The plugin was installed with the &lt;code&gt;&lt;a href=&quot;../mysql_plugin/index&quot;&gt;mysql_plugin&lt;/a&gt;&lt;/code&gt; utility.</source>
          <target state="translated">플러그인은 &lt;code&gt;&lt;a href=&quot;../mysql_plugin/index&quot;&gt;mysql_plugin&lt;/a&gt;&lt;/code&gt; 유틸리티 와 함께 설치되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6ac8c3d10d2881197e402071b37b4b0e35036b6d" translate="yes" xml:space="preserve">
          <source>The polygon is defined by the corner points of the bounding box:</source>
          <target state="translated">다각형은 경계 상자의 모서리 점으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c5ef88f8f028780f4d840043284c8ce5f661f17a" translate="yes" xml:space="preserve">
          <source>The pool of replication worker threads is shared among all multi-source master connections, and among all replication domains that can replicate in parallel using out-of-order.</source>
          <target state="translated">복제 작업자 스레드 풀은 모든 다중 소스 마스터 연결과 비 순차적으로 병렬로 복제 할 수있는 모든 복제 도메인간에 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="58e0887732ab9848b8f6ee16c48a2843415092ff" translate="yes" xml:space="preserve">
          <source>The population covariance for non-null pairs in a group.</source>
          <target state="translated">그룹에서 null이 아닌 쌍에 대한 모집단 공분산입니다.</target>
        </trans-unit>
        <trans-unit id="e15fd35b3bc653887b34a96ed59e194e339e6d9a" translate="yes" xml:space="preserve">
          <source>The population standard deviation of a numeric (INT variations, NUMERIC, DECIMAL) column</source>
          <target state="translated">숫자 (INT 변형, NUMERIC, DECIMAL) 열의 모집단 표준 편차</target>
        </trans-unit>
        <trans-unit id="bc644a7fba40fc8a765db8a78b4a005fb3c5d382" translate="yes" xml:space="preserve">
          <source>The population standard variance of a numeric (INT variations, NUMERIC, DECIMAL) column</source>
          <target state="translated">숫자 (INT 변형, NUMERIC, DECIMAL) 열의 모집단 표준 분산</target>
        </trans-unit>
        <trans-unit id="3a4ca5cdf055bdbf8d7466167053de3d12877ad3" translate="yes" xml:space="preserve">
          <source>The port being used to connect to the master.</source>
          <target state="translated">마스터에 연결하는 데 사용되는 포트입니다.</target>
        </trans-unit>
        <trans-unit id="3abc85ee60548c2f958a28325c358938830e5ab5" translate="yes" xml:space="preserve">
          <source>The port number that the server should use when listening for TCP/IP connections. The port number must be 1024 or higher unless the server is started by the root system user.</source>
          <target state="translated">TCP / IP 연결을 청취 할 때 서버가 사용해야하는 포트 번호입니다. 루트 시스템 사용자가 서버를 시작하지 않으면 포트 번호는 1024 이상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="8586044bb3fa44c31f4e49849a6ce68d6554f825" translate="yes" xml:space="preserve">
          <source>The port of the server.</source>
          <target state="translated">서버의 포트</target>
        </trans-unit>
        <trans-unit id="b5712c6b951b129cb3cf0eab5ac041b558d34160" translate="yes" xml:space="preserve">
          <source>The position of the column in the table, starting at 0</source>
          <target state="translated">0에서 시작하여 테이블에서 열의 위치</target>
        </trans-unit>
        <trans-unit id="0472b76a3bfc644fc6edacbbdcd788e13ab23820" translate="yes" xml:space="preserve">
          <source>The positions start with 1 and are measured in characters (i.e. not in bytes), which is important for multi-byte character sets. You can cast a multi-byte character set to &lt;a href=&quot;../binary/index&quot;&gt;BINARY&lt;/a&gt; to get offsets in bytes.</source>
          <target state="translated">위치는 1로 시작하고 바이트 단위가 아닌 문자로 측정되며, 이는 멀티 바이트 문자 세트에 중요합니다. 멀티 바이트 문자 세트를 &lt;a href=&quot;../binary/index&quot;&gt;BINARY&lt;/a&gt; 로 캐스트하여 오프셋을 바이트 단위로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5db1cb2f96f8e457c216a520b4f81146af2fe62f" translate="yes" xml:space="preserve">
          <source>The possible values are:</source>
          <target state="translated">가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8bdb791c6657cb51524fb9802abc44d953aa5b9d" translate="yes" xml:space="preserve">
          <source>The possible values for these special options are:</source>
          <target state="translated">이러한 특수 옵션에 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf26a190f058518857d6500fb954e587e72ca050" translate="yes" xml:space="preserve">
          <source>The postConfigure script is a custom wizard to do the system(server and storage) configuration and setup. Before running the postConfigure script, you must have done &lt;a href=&quot;../preparing-for-columnstore-installation-12x/index&quot;&gt;Preparing for ColumnStore Installation 1.2.x&lt;/a&gt; steps. Once you have done these steps, then run the postConfigure script from the single server where you are installing ColumnStore.</source>
          <target state="translated">postConfigure 스크립트는 시스템 (서버 및 스토리지) 구성 및 설정을 수행하는 사용자 지정 마법사입니다. postConfigure 스크립트를 실행하기 전에 &lt;a href=&quot;../preparing-for-columnstore-installation-12x/index&quot;&gt;ColumnStore 설치 준비 1.2.x&lt;/a&gt; 단계 를 완료해야 합니다. 이 단계를 완료하면 ColumnStore를 설치하는 단일 서버에서 postConfigure 스크립트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="4e6e37b18e0a71f14bc2145919d54b68bcbf92dd" translate="yes" xml:space="preserve">
          <source>The postConfigure script is a customer wizard to do the system(server and storage) configuration and setup. Before running the postConfigure script, you must have done &lt;a href=&quot;../preparing-for-columnstore-installation-12x/index&quot;&gt;Preparing for ColumnStore Installation 1.2.x&lt;/a&gt; steps and the pre-requisite validation using &lt;a href=&quot;../mariadb-columnstore-cluster-test-tool/index&quot;&gt;ColumnStore Cluster Tester Tool&lt;/a&gt;. Once you have done these steps, then run the postConfigure script from the node designated as PM1.</source>
          <target state="translated">postConfigure 스크립트는 시스템 (서버 및 스토리지) 구성 및 설정을 수행하는 고객 마법사입니다. postConfigure 스크립트를 실행하기 전에 &lt;a href=&quot;../mariadb-columnstore-cluster-test-tool/index&quot;&gt;ColumnStore Cluster Tester Tool을&lt;/a&gt; 사용하여 ColumnStore &lt;a href=&quot;../preparing-for-columnstore-installation-12x/index&quot;&gt;설치 준비 1.2.x&lt;/a&gt; 단계 및 전제 조건 유효성 검증을 완료해야합니다 . 이 단계를 완료하면 PM1으로 지정된 노드에서 postConfigure 스크립트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="d64d43172b53ccc2ba222ffbefb2870365f24bdb" translate="yes" xml:space="preserve">
          <source>The postConfigure script supports 2 different types of installs:</source>
          <target state="translated">postConfigure 스크립트는 두 가지 다른 유형의 설치를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1f2bd302f038b10ea32fea1f377fa6cdf3629c4c" translate="yes" xml:space="preserve">
          <source>The precedence is the order in which the SQL operators are evaluated.</source>
          <target state="translated">우선 순위는 SQL 연산자가 평가되는 순서입니다.</target>
        </trans-unit>
        <trans-unit id="7e723e8068544833d53923167fefc2d9436dc138" translate="yes" xml:space="preserve">
          <source>The precedence of the &lt;code&gt;NOT&lt;/code&gt; operator can also be affected by the &lt;code&gt;HIGH_NOT_PRECEDENCE&lt;/code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; flag.</source>
          <target state="translated">&lt;code&gt;NOT&lt;/code&gt; 연산자 의 우선 순위 는 &lt;code&gt;HIGH_NOT_PRECEDENCE&lt;/code&gt; &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; 플래그의 영향을받을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92aec15dc6496acc391f4ecfc16745dccbe9993e" translate="yes" xml:space="preserve">
          <source>The prefix needs to be supplied to reference this table:</source>
          <target state="translated">이 테이블을 참조하려면 접 두부를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce890e26b79ad45e69fea6706a8a04d96c39941d" translate="yes" xml:space="preserve">
          <source>The prepared statement contains a stored routine call that refers to that same statement. It's not allowed to execute a prepared statement in such a recursive manner</source>
          <target state="translated">준비된 명령문에는 동일한 명령문을 참조하는 스토어드 루틴 호출이 포함됩니다. 준비된 문장을 재귀적인 방식으로 실행할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="783294825b5076341aa804db170eb45eb853f385" translate="yes" xml:space="preserve">
          <source>The preview included a feature &lt;a href=&quot;../innodb-release-locks-early/index&quot;&gt;--innodb-release-locks-early&lt;/a&gt;. However we decided to omit this feature from future MariaDB releases because of a fundamental design bug, &lt;a href=&quot;https://bugs.launchpad.net/maria/+bug/798213&quot;&gt;lp:798213&lt;/a&gt;.</source>
          <target state="translated">미리보기에는 &lt;a href=&quot;../innodb-release-locks-early/index&quot;&gt;--innodb-release-locks-early&lt;/a&gt; 기능이 포함되었습니다 . 그러나 기본 디자인 버그 인 &lt;a href=&quot;https://bugs.launchpad.net/maria/+bug/798213&quot;&gt;lp : 798213&lt;/a&gt; 때문에 향후 MariaDB 릴리스에서이 기능을 생략하기로 결정했습니다 .</target>
        </trans-unit>
        <trans-unit id="bb95b938aaf91c2b8a810ad55e937c0b05b1e882" translate="yes" xml:space="preserve">
          <source>The previous configuration file will be saved as /usr/local/Calpont/etc/Calpont.xml.rpmsave.</source>
          <target state="translated">이전 구성 파일은 /usr/local/Calpont/etc/Calpont.xml.rpmsave로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="f2345241902ff50e7a6930211a570576a26666c1" translate="yes" xml:space="preserve">
          <source>The previous configuration file will be saved as /usr/local/MariaDB/Columnstore/etc/Calpont.xml.rpmsave.</source>
          <target state="translated">이전 구성 파일은 /usr/local/MariaDB/Columnstore/etc/Calpont.xml.rpmsave로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="cc28757bf2c9497ffd43b4138ff111d215077a3c" translate="yes" xml:space="preserve">
          <source>The previous configuration file will be saved as /usr/local/mariadb/columnstore/etc/Columnstore.xml.rpmsave.</source>
          <target state="translated">이전 구성 파일은 /usr/local/mariadb/columnstore/etc/Columnstore.xml.rpmsave로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="d371b7fc4d721a635004375a40ffaff43d8a0da4" translate="yes" xml:space="preserve">
          <source>The previous paragraph doesn't cover one important question &amp;mdash; how can the engine know that the server uses an outdated table definition? The answer is &amp;mdash; by checking the &lt;strong&gt;tabledef_version&lt;/strong&gt;, the table definition version. Every table gets a unique &lt;code&gt;tabledef_version&lt;/code&gt; value. Normally it is generated automatically when a table is created. When a table is discovered the engine can force it to have a specific &lt;code&gt;tabledef_version&lt;/code&gt; value (simply by setting it in the &lt;code&gt;TABLE_SHARE&lt;/code&gt; before calling the &lt;code&gt;init_from_binary_frm_image()&lt;/code&gt; or &lt;code&gt;init_from_sql_statement_string()&lt;/code&gt; methods).</source>
          <target state="translated">이전 단락에서는 한 가지 중요한 질문을 다루지 않습니다. 엔진이 서버에서 오래된 테이블 정의를 사용한다는 것을 어떻게 알 수 있습니까? 대답은 &amp;mdash; 테이블 정의 버전 인 &lt;strong&gt;tabledef_version&lt;/strong&gt; 을 확인하면 됩니다. 모든 테이블은 고유 한 &lt;code&gt;tabledef_version&lt;/code&gt; 값을 얻습니다 . 일반적으로 테이블이 작성 될 때 자동으로 생성됩니다. 테이블이 발견되면 엔진은 엔진에 특정 &lt;code&gt;tabledef_version&lt;/code&gt; 값 을 갖도록 할 수 있습니다 ( &lt;code&gt;init_from_binary_frm_image()&lt;/code&gt; 또는 &lt;code&gt;init_from_sql_statement_string()&lt;/code&gt; 메소드 를 호출하기 전에 &lt;code&gt;TABLE_SHARE&lt;/code&gt; 에 설정하여 ).</target>
        </trans-unit>
        <trans-unit id="53880580ae7f952610baac5f8958c77b9d30f1fc" translate="yes" xml:space="preserve">
          <source>The previous statement creates an event named myevent. This event executes once &amp;mdash; one hour following its creation &amp;mdash; by running an SQL statement that increments the value of the myschema.mytable table's mycol column by 1.</source>
          <target state="translated">위의 문장은 myevent라는 이벤트를 만듭니다. 이 이벤트는 myschema.mytable 테이블의 mycol 열의 값을 1 씩 증가시키는 SQL 문을 실행하여 작성 후 1 시간에 한 번 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2b40d13592c300c31afba55015ce514f8d2fd337" translate="yes" xml:space="preserve">
          <source>The primary Performance Module has a master copy of the Extent Map. On system startup, the file is read into memory, then physically copied to all other participating User and Performance modules for disaster recovery and failover. Nodes keep the Extent Map in memory for quick access. As Extents are modified, updates are broadcast to participating nodes.</source>
          <target state="translated">기본 성능 모듈에는 Extent Map의 마스터 사본이 있습니다. 시스템 시작시 파일을 메모리로 읽은 다음 재해 복구 및 장애 조치를 위해 참여하는 다른 모든 사용자 및 성능 모듈에 실제로 복사합니다. 노드는 빠른 액세스를 위해 Extent Map을 메모리에 유지합니다. 범위가 수정되면 업데이트가 참여 노드로 브로드 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="5b220f1b7c4347bb5c8cb6a1f0ba8120d2f4ea80" translate="yes" xml:space="preserve">
          <source>The primary data is stored in MariaDB (ie. in InnoDB)</source>
          <target state="translated">기본 데이터는 MariaDB (즉, InnoDB)에 저장됩니다</target>
        </trans-unit>
        <trans-unit id="12cafd522d76c5b4db00cd8a44d693140add3066" translate="yes" xml:space="preserve">
          <source>The primary difference between the two functions is that &lt;em&gt;JSON_QUERY&lt;/em&gt; returns an object or an array, while &lt;em&gt;JSON_VALUE&lt;/em&gt; returns a scalar.</source>
          <target state="translated">두 함수의 주요 차이점은 &lt;em&gt;JSON_QUERY&lt;/em&gt; 는 객체 또는 배열을 반환하고 &lt;em&gt;JSON_VALUE&lt;/em&gt; 는 스칼라를 반환한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e81e029aa8eb9b148d708f1c16a8291db277bda2" translate="yes" xml:space="preserve">
          <source>The primary goal of Cassandra SE (Storage Engine) is data integration between the SQL and NoSQL worlds. Have you ever needed to:</source>
          <target state="translated">Cassandra SE (Storage Engine)의 주요 목표는 SQL 세계와 NoSQL 세계 간의 데이터 통합입니다. 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="83bd444ee38eec60f9524226461c95eed246e834" translate="yes" xml:space="preserve">
          <source>The primary key in MyRocks is always the clustered key, that is, the index record is THE table record and so it's not possible to do &quot;index only&quot; because there isn't anything that is not in the primary key's (Key,Value) pair.</source>
          <target state="translated">MyRocks의 기본 키는 항상 클러스터 된 키입니다. 즉, 인덱스 레코드는 테이블 레코드이므로 기본 키 (Key, Value)에없는 것은 없으므로 &quot;인덱스 만&quot;을 수행 할 수 없습니다. 쌍.</target>
        </trans-unit>
        <trans-unit id="4f7a2e40bfdb6fb81c793c65ffcfc58310f3aa79" translate="yes" xml:space="preserve">
          <source>The primary key is used, if there is one.</source>
          <target state="translated">기본 키가있는 경우 기본 키가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2504b1a5ec207ecfb0fd76f607151a67744f6af5" translate="yes" xml:space="preserve">
          <source>The primary purpose of &lt;code&gt;innobackupex&lt;/code&gt; mode is to allow scripts and tools to more easily migrate to Mariabackup if they were originally designed to use the &lt;code&gt;innobackupex&lt;/code&gt; utility that is included with &lt;a href=&quot;../percona-xtrabackup-overview/index&quot;&gt;Percona XtraBackup&lt;/a&gt;. It is not recommended to use this mode in new scripts, since it is not guaranteed to be supported forever. See &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-20552&quot;&gt;MDEV-20552&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;innobackupex&lt;/code&gt; 모드 의 주요 목적은 스크립트와 도구가 원래 &lt;a href=&quot;../percona-xtrabackup-overview/index&quot;&gt;Percona XtraBackup에&lt;/a&gt; 포함 된 &lt;code&gt;innobackupex&lt;/code&gt; 유틸리티 를 사용하도록 설계된 경우 Mariabackup으로보다 쉽게 ​​마이그레이션 할 수 있도록하는 것 입니다. 이 모드는 영구적으로 지원되지는 않으므로 새 스크립트에서는 사용하지 않는 것이 좋습니다. 자세한 내용은 &lt;a href=&quot;https://jira.mariadb.org/browse/MDEV-20552&quot;&gt;MDEV-20552&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6878ef6a540fb4680805477aeaa90cc2653aeb4d" translate="yes" xml:space="preserve">
          <source>The primary purpose of the User Module is to handle concurrency scaling. It never directly touches database files and doesn't require visibility to them. It uses a machine's RAM in a transitory manner to assemble partial query results into a complete answer that's returned to the user.</source>
          <target state="translated">사용자 모듈의 주요 목적은 동시성 스케일링을 처리하는 것입니다. 데이터베이스 파일을 직접 건드리지 않으며 가시성을 요구하지 않습니다. 컴퓨터의 RAM을 일시적인 방식으로 사용하여 부분 쿼리 결과를 사용자에게 반환되는 완전한 답변으로 어셈블합니다.</target>
        </trans-unit>
        <trans-unit id="dc7013898bd711b018fa2488253c7aa333b69108" translate="yes" xml:space="preserve">
          <source>The primary reason that Mariabackup needs to be able to encrypt and decrypt data is that it needs to apply &lt;a href=&quot;../xtradbinnodb-redo-log/index&quot;&gt;InnoDB redo log&lt;/a&gt; records to make the data consistent when the backup is prepared. As a consequence, Mariabackup does not perform many encryption or decryption operations when the backup is initially taken. MariaDB performs more encryption and decryption operations when the backup is prepared. This means that some encryption-related problems (such as using the wrong encryption keys) may not become apparent until the backup is prepared.</source>
          <target state="translated">Mariabackup이 데이터를 암호화 및 암호 해독 할 수 있어야하는 주된 이유 는 백업 준비시 데이터의 일관성을 유지하기 위해 &lt;a href=&quot;../xtradbinnodb-redo-log/index&quot;&gt;InnoDB 리두 로그&lt;/a&gt; 레코드를 적용해야하기 때문 입니다. 결과적으로 Mariabackup은 백업을 처음 수행 할 때 많은 암호화 또는 암호 해독 작업을 수행하지 않습니다. MariaDB는 백업 준비시 더 많은 암호화 및 암호 해독 작업을 수행합니다. 이는 백업이 준비 될 때까지 일부 암호화 관련 문제 (예 : 잘못된 암호화 키 사용)가 명확하지 않을 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b9e9a38a3459c6a23ca97b37b664e0ad912ef53a" translate="yes" xml:space="preserve">
          <source>The primary use case for this algorithm is when the data is significantly larger than will fit into cache (the buffer_pool). Hence, the main goal is to minimize the number of disk hits.</source>
          <target state="translated">이 알고리즘의 기본 사용 사례는 데이터가 캐시 (buffer_pool)에 들어갈 수있는 것보다 상당히 큰 경우입니다. 따라서 주요 목표는 디스크 적중 횟수를 최소화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2ce9fa4d419bd08244d0e1ccc69e8896a1407c6a" translate="yes" xml:space="preserve">
          <source>The privilege type. See &lt;a href=&quot;../grant/index#column-privileges&quot;&gt;Column Privileges&lt;/a&gt; for details.</source>
          <target state="translated">권한 유형. 자세한 내용은 &lt;a href=&quot;../grant/index#column-privileges&quot;&gt;열 권한&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a4fca6e7208d097da6be5f1dfb9ad29f43199cfe" translate="yes" xml:space="preserve">
          <source>The privileges required for executing statements within f() need to be checked when f() executes. This might mean that privileges are needed for p1() or p2(), depending on the execution path within f(). Those privileges must be checked at runtime, and the user who must possess the privileges is determined by the SQL SECURITY values of the view v and the function f().</source>
          <target state="translated">f ()에서 명령문을 실행하는 데 필요한 권한은 f ()가 실행될 때 확인해야합니다. 이는 f () 내의 실행 경로에 따라 p1 () 또는 p2 ()에 대한 권한이 필요함을 의미 할 수 있습니다. 이러한 특권은 런타임시 점검해야하며 특권을 가지고있는 사용자는 뷰 v의 SQL SECURITY 값과 함수 f ()에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="8a9400005c3bca2486ac5d4f71c851ac612c4135" translate="yes" xml:space="preserve">
          <source>The problem</source>
          <target state="translated">문제</target>
        </trans-unit>
        <trans-unit id="46130cd6e1127b4e20c9328fc1241388f380399e" translate="yes" xml:space="preserve">
          <source>The problem is that CONNECT cannot guess what you want to do with arrays. Here the AUTHOR array is left undefined, which means that only its first value will be retrieved unless you also had specified &amp;ldquo;Expand=AUTHOR&amp;rdquo; in the option list. But of course, you can replace it by anything else.</source>
          <target state="translated">문제는 CONNECT가 배열로 수행하려는 작업을 추측 할 수 없다는 것입니다. 여기서 AUTHOR 배열은 정의되어 있지 않으므로 옵션 목록에서 &quot;Expand = AUTHOR&quot;를 지정하지 않은 경우 첫 번째 값만 검색됩니다. 그러나 물론 다른 것으로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67608bf5b21d15db8a339f0abb264fbebcdb3155" translate="yes" xml:space="preserve">
          <source>The problem is that on some systems, the &lt;code&gt;pam_unix&lt;/code&gt; PAM module needs access to &lt;code&gt;/etc/shadow&lt;/code&gt; in order to function, and most systems only allow &lt;code&gt;root&lt;/code&gt; to access that file by default.</source>
          <target state="translated">문제는 일부 시스템에서 &lt;code&gt;pam_unix&lt;/code&gt; PAM 모듈이 작동하려면 &lt;code&gt;/etc/shadow&lt;/code&gt; 에 액세스해야 하며 대부분의 시스템 은 기본적으로 &lt;code&gt;root&lt;/code&gt; 만 해당 파일에 액세스 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="16acc042064d9853a49ce98d67517922c594ae8f" translate="yes" xml:space="preserve">
          <source>The problem space</source>
          <target state="translated">문제 공간</target>
        </trans-unit>
        <trans-unit id="8220c03da5b94e9996320147f3346f0b4582e836" translate="yes" xml:space="preserve">
          <source>The problems</source>
          <target state="translated">문제</target>
        </trans-unit>
        <trans-unit id="c2e0a483fae3ff1bda5886da7d837126aabeb2a4" translate="yes" xml:space="preserve">
          <source>The problems with replication will only occur with statement-based logging. If row-based logging is used, since changes are made to rows based on the master's rows, there is no possibility of the slave and master getting out of sync.</source>
          <target state="translated">복제 문제는 명령문 기반 로깅에서만 발생합니다. 행 기반 로깅을 사용하는 경우 마스터 행을 기반으로 행이 변경되므로 슬레이브와 마스터가 동기화되지 않을 가능성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e16386491d445e8fe8e30bde7f2fa721e1a2805b" translate="yes" xml:space="preserve">
          <source>The problems:</source>
          <target state="translated">문제 :</target>
        </trans-unit>
        <trans-unit id="56f8f02c50cefd92998fe684622901830235e649" translate="yes" xml:space="preserve">
          <source>The procedure for MyISAM tables is identical, except that &lt;a href=&quot;../myisamchk/index&quot;&gt;myisamchk&lt;/a&gt; doesn't have the &lt;code&gt;--ignore-control-file&lt;/code&gt; option.</source>
          <target state="translated">&lt;a href=&quot;../myisamchk/index&quot;&gt;myisamchk&lt;/a&gt; 에 &lt;code&gt;--ignore-control-file&lt;/code&gt; 옵션 이 없다는 점을 제외하고 MyISAM 테이블의 절차는 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="a9b0aa3166fdec5fff6dd66dcaccab39af874d3a" translate="yes" xml:space="preserve">
          <source>The procedure name is pushed to Lex-&amp;gt;value_list. The sql_command code for the result of parsing a is &lt;code&gt;SQLCOM_DROP_PROCEDURE&lt;/code&gt;/&lt;code&gt;SQLCOM_DROP_FUNCTION&lt;/code&gt;.</source>
          <target state="translated">프로 시저 이름이 Lex-&amp;gt; value_list로 푸시됩니다. a 구문 분석 결과의 sql_command 코드는 &lt;code&gt;SQLCOM_DROP_PROCEDURE&lt;/code&gt; / &lt;code&gt;SQLCOM_DROP_FUNCTION&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bec21956cd25784cf25085436f3b15b19c59991b" translate="yes" xml:space="preserve">
          <source>The procedure returns one resultset, SELECT *, distance.</source>
          <target state="translated">이 프로시 저는 하나의 결과 집합 인 SELECT *, 거리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fe8ba7b2ee93b38c6e8c3882dcc79297535574b2" translate="yes" xml:space="preserve">
          <source>The procedure to change compression settings is as follows:</source>
          <target state="translated">압축 설정을 변경하는 절차는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d96768612b67b43866cb813a3f82c8717f268342" translate="yes" xml:space="preserve">
          <source>The procedure: sp_head.h:</source>
          <target state="translated">절차 : sp_head.h :</target>
        </trans-unit>
        <trans-unit id="9c6aa4519f3841d32fc758dd4c244a6ecba76083" translate="yes" xml:space="preserve">
          <source>The process involved in safely disabling data-at-rest encryption for your ...</source>
          <target state="translated">귀하의 미사용 데이터 암호화를 안전하게 비활성화하는 과정</target>
        </trans-unit>
        <trans-unit id="7a5d3715d75179bdbcb35ea1e66a3725438a2607" translate="yes" xml:space="preserve">
          <source>The process involved in safely disabling data-at-rest encryption for your Aria tables is very similar to that of enabling encryption. To disable, you need to set the relevant system variables and then rebuild each table into an unencrypted state.</source>
          <target state="translated">Aria 테이블의 미사용 데이터 암호화를 안전하게 비활성화하는 과정은 암호화를 활성화하는 프로세스와 매우 유사합니다. 비활성화하려면 관련 시스템 변수를 설정 한 다음 각 테이블을 암호화되지 않은 상태로 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="b108fd10de2ab664c1e0152c57c6e5faf8a1baa4" translate="yes" xml:space="preserve">
          <source>The process involved in safely disabling encryption for your InnoDB tables is a little more complicated than that of enabling encryption. Turning off the relevant system variables doesn't decrypt the tables. If you turn it off and remove the encryption key management plugin, it'll render the encrypted data inaccessible.</source>
          <target state="translated">InnoDB 테이블의 암호화를 안전하게 비활성화하는 과정은 암호화를 활성화하는 것보다 조금 더 복잡합니다. 관련 시스템 변수를 끄면 테이블이 해독되지 않습니다. 이 기능을 끄고 암호화 키 관리 플러그인을 제거하면 암호화 된 데이터에 액세스 할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="46ce29ddbfa7387e8d522d85337438fb2d184e6c" translate="yes" xml:space="preserve">
          <source>The process is applicable to &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-534-release-notes/&quot;&gt;MariaDB 5.3.4&lt;/a&gt; and XtraDB from Percona Server 5.1.61.</source>
          <target state="translated">이 프로세스는 Percona Server 5.1.61의 &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-534-release-notes/&quot;&gt;MariaDB 5.3.4&lt;/a&gt; 및 XtraDB에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b3ec5fdbbc0fc5be0985fe065f17ae33d79f6573" translate="yes" xml:space="preserve">
          <source>The process is fully functional.</source>
          <target state="translated">프로세스는 완전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3d3136a0620ccfb0cb3535606acb30b36a590731" translate="yes" xml:space="preserve">
          <source>The process is functional in a standby/ready state in case a failover occurs.</source>
          <target state="translated">장애 조치가 발생할 경우 프로세스는 대기 / 준비 상태에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b8612458628d8e970b773ddd34711a4530d7031b" translate="yes" xml:space="preserve">
          <source>The process is offline due to a fault.</source>
          <target state="translated">결함으로 인해 프로세스가 오프라인 상태입니다.</target>
        </trans-unit>
        <trans-unit id="98ef041719af3abfc5fb8ed082be78374dc4a5e3" translate="yes" xml:space="preserve">
          <source>The process is performing an initialization task at startup time before going to the ACTIVE state.</source>
          <target state="translated">프로세스가 시작 상태에서 ACTIVE 상태로 가기 전에 초기화 태스크를 수행하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="239c4de3148f88ea1faf50d2705263a819c06ae2" translate="yes" xml:space="preserve">
          <source>The process to install MariaDB Galera Cluster with the MariaDB &lt;code&gt;apt-get&lt;/code&gt; repository is practically the same as installing standard MariaDB Server.</source>
          <target state="translated">MariaDB &lt;code&gt;apt-get&lt;/code&gt; 리포지토리 와 함께 MariaDB Galera Cluster를 설치하는 프로세스 는 표준 MariaDB 서버를 설치하는 것과 실질적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="002b43427f57748fdaa9702c0c65a8884348870c" translate="yes" xml:space="preserve">
          <source>The process to install MariaDB Galera Cluster with the MariaDB &lt;code&gt;yum&lt;/code&gt; repository is practically the same as installing standard MariaDB Server.</source>
          <target state="translated">MariaDB &lt;code&gt;yum&lt;/code&gt; 리포지토리 와 함께 MariaDB Galera Cluster를 설치하는 과정 은 표준 MariaDB 서버를 설치하는 과정과 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="65eddee7cb4d6d77138584734a01004755c22218" translate="yes" xml:space="preserve">
          <source>The process to install MariaDB Galera Cluster with the MariaDB &lt;code&gt;zypper&lt;/code&gt; repository is practically the same as installing standard MariaDB Server.</source>
          <target state="translated">MariaDB &lt;code&gt;zypper&lt;/code&gt; 리포지토리 와 함께 MariaDB Galera Cluster를 설치하는 프로세스 는 표준 MariaDB 서버 설치와 실질적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8150f5644445c02825b5a17def7cc48b56e555d2" translate="yes" xml:space="preserve">
          <source>The process was taken offline with the stop or shutdown command.</source>
          <target state="translated">중지 또는 종료 명령으로 프로세스가 오프라인 상태가되었습니다.</target>
        </trans-unit>
        <trans-unit id="b7cdd3bc0162bef988f649fc6fdfaa6b03441ca7" translate="yes" xml:space="preserve">
          <source>The processing of the group by is done by the data source, which returns only the generated result set on which only the where clause is performed locally. The result:</source>
          <target state="translated">그룹 기준 처리는 데이터 소스에 의해 수행되며 where 절만 로컬로 수행되는 생성 된 결과 세트 만 리턴합니다. 결과:</target>
        </trans-unit>
        <trans-unit id="893af8cbbbed852b8eb2bd1484b6b7f08c2ca575" translate="yes" xml:space="preserve">
          <source>The program will generate and execute (when needed) either of these:</source>
          <target state="translated">프로그램은 다음 중 하나를 생성하고 (필요한 경우) 실행합니다.</target>
        </trans-unit>
        <trans-unit id="dc4d144aa7582fe9a121d973b11713f7b5be39f7" translate="yes" xml:space="preserve">
          <source>The progress of the process within the current stage (0-100%).</source>
          <target state="translated">현재 단계 내 프로세스 진행률 (0-100 %)</target>
        </trans-unit>
        <trans-unit id="0949fd67c90b93a1af6ec8acf01c9cb569cab5fc" translate="yes" xml:space="preserve">
          <source>The progress report is also shown in the output of the &lt;code&gt;&lt;a href=&quot;../show-processlist/index&quot;&gt;SHOW PROCESSLIST&lt;/a&gt;&lt;/code&gt; statement and in the contents of the &lt;code&gt;&lt;a href=&quot;../information-schema-processlist-table/index&quot;&gt;information_schema.PROCESSLIST&lt;/a&gt;&lt;/code&gt; table.</source>
          <target state="translated">진행 보고서는 &lt;code&gt;&lt;a href=&quot;../show-processlist/index&quot;&gt;SHOW PROCESSLIST&lt;/a&gt;&lt;/code&gt; 문의 출력 및 &lt;code&gt;&lt;a href=&quot;../information-schema-processlist-table/index&quot;&gt;information_schema.PROCESSLIST&lt;/a&gt;&lt;/code&gt; 테이블 의 내용 에도 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad6f1c15625d9dc87e76e471127a3b0dfb2a4ade" translate="yes" xml:space="preserve">
          <source>The prompt command reconfigures the default prompt &lt;code&gt;\N [\d]&amp;gt;&lt;/code&gt;. The string for defining the prompt can contain the following special sequences.</source>
          <target state="translated">prompt 명령은 기본 프롬프트 &lt;code&gt;\N [\d]&amp;gt;&lt;/code&gt; 재구성합니다 . 프롬프트를 정의하기위한 문자열에는 다음과 같은 특수 시퀀스가 ​​포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c86e738e105d5e869c0c27f366478b0743681acb" translate="yes" xml:space="preserve">
          <source>The property &lt;code&gt;Xuc&lt;/code&gt; matches any character that can be represented by a Universal Character Name (in C++ and other programming languages). These include &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;`&lt;/code&gt;, and all characters with Unicode code points greater than &lt;code&gt;U+00A0&lt;/code&gt;, excluding the surrogates &lt;code&gt;U+D800&lt;/code&gt;..&lt;code&gt;U+DFFF&lt;/code&gt;.</source>
          <target state="translated">속성 &lt;code&gt;Xuc&lt;/code&gt; 는 범용 문자 이름 (C ++ 및 기타 프로그래밍 언어)으로 표시 할 수있는 모든 문자와 일치합니다. 여기에는 &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;@&lt;/code&gt; , &lt;code&gt;`&lt;/code&gt; 및 대리자 &lt;code&gt;U+D800&lt;/code&gt; .. &lt;code&gt;U+DFFF&lt;/code&gt; 를 제외한 &lt;code&gt;U+00A0&lt;/code&gt; 보다 큰 유니 코드 코드 포인트를 가진 모든 문자가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="2b4b80653525d363b08ff9078ab80dc85b257db3" translate="yes" xml:space="preserve">
          <source>The property names represented by &lt;code&gt;xx&lt;/code&gt; above are limited to the Unicode script names, the general category properties, and &quot;Any&quot;, which matches any character (including newline). Those that are not part of an identified script are lumped together as &quot;Common&quot;.</source>
          <target state="translated">위의 &lt;code&gt;xx&lt;/code&gt; 로 표시되는 속성 이름은 유니 코드 스크립트 이름, 일반 범주 속성 및 모든 문자 (줄 바꿈 포함)와 일치하는 &quot;Any&quot;로 제한됩니다. 식별 된 스크립트의 일부가 아닌 스크립트는 &quot;공통&quot;으로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="0dc5831bcea824720a164bab2463c027abc0f885" translate="yes" xml:space="preserve">
          <source>The protocol of the connection (tcp,socket,pipe,memory).</source>
          <target state="translated">연결 프로토콜 (tcp, socket, pipe, memory).</target>
        </trans-unit>
        <trans-unit id="8f95b684994b89f2dc86e33b41c74961c195954c" translate="yes" xml:space="preserve">
          <source>The protocol to use for connection (tcp, socket, pipe, memory).</source>
          <target state="translated">연결에 사용할 프로토콜 (tcp, 소켓, 파이프, 메모리).</target>
        </trans-unit>
        <trans-unit id="4ddc1aee2d48c7f77596aed42b4cf9c8d68fadf6" translate="yes" xml:space="preserve">
          <source>The published table (see Wikipedia) is</source>
          <target state="translated">게시 된 표 (Wikipedia 참조)는</target>
        </trans-unit>
        <trans-unit id="2c4c98140d5a7b15637ac377ee5c2cdfb3a8f8af" translate="yes" xml:space="preserve">
          <source>The pure (deprecated) CONNECT syntax is also accepted:</source>
          <target state="translated">순수한 (더 이상 사용되지 않는) CONNECT 구문도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="dcf484042b74b6575a43649520160f8061368d92" translate="yes" xml:space="preserve">
          <source>The purge batch size is defined as the number of &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;InnoDB redo log&lt;/a&gt; records that must be written before triggering purge. The purge batch size can be set by configuring the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_purge_batch_size&quot;&gt;innodb_purge_batch_size&lt;/a&gt;&lt;/code&gt; system variable. This system variable can be specified as a command-line argument to &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; or it can be specified in a relevant server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option group&lt;/a&gt; in an &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;option file&lt;/a&gt;. For example:</source>
          <target state="translated">제거 배치 크기는 제거를 트리거하기 전에 기록해야하는 &lt;a href=&quot;../innodb-redo-log/index&quot;&gt;InnoDB 리두 로그&lt;/a&gt; 레코드 의 수로 정의됩니다 . 제거 배치 크기는 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_purge_batch_size&quot;&gt;innodb_purge_batch_size&lt;/a&gt;&lt;/code&gt; 시스템 변수를 구성하여 설정할 수 있습니다 . 이 시스템 변수는 &lt;code&gt;&lt;a href=&quot;../mysqld-options/index&quot;&gt;mysqld&lt;/a&gt;&lt;/code&gt; 에 대한 명령 행 인수로 지정 하거나 &lt;a href=&quot;../configuring-mariadb-with-option-files/index&quot;&gt;옵션 파일&lt;/a&gt; 의 관련 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 에서 지정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f974801b765e530fa1b535b39c90a4336c0bf841" translate="yes" xml:space="preserve">
          <source>The purge rollback segment truncation frequency is defined as the number of purge loops that are run before unnecessary rollback segments are truncated. The purge rollback segment truncation frequency can be set by configuring the &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_purge_rseg_truncate_frequency&quot;&gt;innodb_purge_rseg_truncate_frequency&lt;/a&gt;&lt;/code&gt; system variable. This system variable can be changed dynamically with &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt;. For example:</source>
          <target state="translated">퍼지 롤백 세그먼트 잘림 빈도는 불필요한 롤백 세그먼트가 잘 리기 전에 실행되는 퍼지 루프 수로 정의됩니다. 퍼지 롤백 세그먼트 잘림 빈도는 &lt;code&gt;&lt;a href=&quot;../innodb-system-variables/index#innodb_purge_rseg_truncate_frequency&quot;&gt;innodb_purge_rseg_truncate_frequency&lt;/a&gt;&lt;/code&gt; 시스템 변수를 구성하여 설정할 수 있습니다 . 이 시스템 변수는 &lt;code&gt;&lt;a href=&quot;../set/index#global-session&quot;&gt;SET GLOBAL&lt;/a&gt;&lt;/code&gt; 을 사용 하여 동적으로 변경할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f86643cf3fc67a3723dae89dde3189cee430c591" translate="yes" xml:space="preserve">
          <source>The purge thread deletes the rows in the undo log which are not needed by any existing view. The rows for which a most recent version exists are deleted, as well as the delete-marked rows.</source>
          <target state="translated">제거 스레드는 기존보기에 필요하지 않은 실행 취소 로그의 행을 삭제합니다. 가장 최근 버전이 존재하는 행과 삭제 표시 행이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="eaa784f329c2f8e4c147f57096ac83738dfd1809" translate="yes" xml:space="preserve">
          <source>The purge thread will physically delete index keys and rows, but the free space introduced is still not returned to operating system. This can lead to gaps in the pages. If you have variable length rows, new rows may be larger than old rows and cannot make use of the available space.</source>
          <target state="translated">제거 스레드는 물리적으로 인덱스 키와 행을 삭제하지만 도입 된 여유 공간은 여전히 ​​운영 체제로 반환되지 않습니다. 이로 인해 페이지에 공백이 생길 수 있습니다. 가변 길이 행이있는 경우 새 행이 이전 행보다 클 수 있으며 사용 가능한 공간을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a94259fe2efca28a8d2f2158cb73c6894fa2ab0c" translate="yes" xml:space="preserve">
          <source>The purpose of the binary log is to allow &lt;a href=&quot;../replication/index&quot;&gt;replication&lt;/a&gt;, where data is sent from one or more masters to one or more slave servers based on the contents of the binary log, as well as assisting in backup operations.</source>
          <target state="translated">이진 로그의 목적은 백업 작업을 지원할뿐만 아니라 이진 로그의 내용에 따라 하나 이상의 마스터에서 하나 이상의 슬레이브 서버로 데이터가 전송되는 &lt;a href=&quot;../replication/index&quot;&gt;복제&lt;/a&gt; 를 허용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="524f2e76ad418d948ebf35b97e49c6d09ff5f9bb" translate="yes" xml:space="preserve">
          <source>The purpose of this optimization is to provide the means to terminate the execution of &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; statements which examine too many rows, and thus use too many resources. This is achieved through an extension of the &lt;code&gt;&lt;a href=&quot;../select/index#limit&quot;&gt;LIMIT&lt;/a&gt;&lt;/code&gt; clause &amp;mdash;&lt;code&gt;LIMIT ROWS EXAMINED number_of_rows &lt;/code&gt;. Whenever possible the semantics of &lt;code&gt;LIMIT ROWS EXAMINED&lt;/code&gt; is the same as that of normal &lt;code&gt;LIMIT&lt;/code&gt; (for instance for aggregate functions).</source>
          <target state="translated">이 최적화의 목적은 너무 많은 행을 검사하여 너무 많은 자원을 사용하는 &lt;code&gt;&lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt;&lt;/code&gt; 문의 실행을 종료하는 수단을 제공하는 것 입니다. 이는 &lt;code&gt;&lt;a href=&quot;../select/index#limit&quot;&gt;LIMIT&lt;/a&gt;&lt;/code&gt; 절 ( &lt;code&gt;LIMIT ROWS EXAMINED number_of_rows &lt;/code&gt; ) 의 확장을 통해 달성됩니다 . 가능할 때마다 &lt;code&gt;LIMIT ROWS EXAMINED&lt;/code&gt; 의 의미는 일반 &lt;code&gt;LIMIT&lt;/code&gt; 와 동일합니다 (예 : 집계 함수).</target>
        </trans-unit>
        <trans-unit id="1a80ef33b6970a04fe3712f2f8135fbaebbff51b" translate="yes" xml:space="preserve">
          <source>The queries</source>
          <target state="translated">쿼리</target>
        </trans-unit>
        <trans-unit id="beafac297dff63b219997297b69b967476d52148" translate="yes" xml:space="preserve">
          <source>The query associated to the DECLARE CURSOR is executed when OPEN is executed. It is important to remember this if the query produces an error, or calls functions which have side effects.</source>
          <target state="translated">DECLARE CURSOR와 연관된 쿼리는 OPEN이 실행될 때 실행됩니다. 쿼리에서 오류가 발생하거나 부작용이있는 함수를 호출하는 경우이 점을 기억해야합니다.</target>
        </trans-unit>
        <trans-unit id="d8512808cbe5ad92b75fffefa08d8beeb8295b66" translate="yes" xml:space="preserve">
          <source>The query cache also needs to be disabled for MariaDB &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; cluster versions prior to &quot;5.5.40-galera&quot;, &quot;10.0.14-galera&quot; and &quot;10.1.2&quot;.</source>
          <target state="translated">&quot;5.5.40-galera&quot;, &quot;10.0.14-galera&quot;및 &quot;10.1.2&quot;이전의 MariaDB &lt;a href=&quot;../galera/index&quot;&gt;Galera&lt;/a&gt; 클러스터 버전에서는 쿼리 캐시를 비활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f5c27f4532eef43e7eea1312b1a6fe9e6e8bc611" translate="yes" xml:space="preserve">
          <source>The query cache can be used when tables have a write lock (which may seem confusing since write locks should avoid table reads). This behaviour can be changed by setting the &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#query_cache_wlock_invalidate&quot;&gt;query_cache_wlock_invalidate&lt;/a&gt;&lt;/code&gt; system variable to &lt;code&gt;ON&lt;/code&gt;, in which case each write lock will invalidate the table query cache. Setting to &lt;code&gt;OFF&lt;/code&gt;, the default, means that cached queries can be returned even when a table lock is being held. For example:</source>
          <target state="translated">테이블에 쓰기 잠금이있는 경우 쿼리 캐시를 사용할 수 있습니다 (쓰기 잠금은 테이블 읽기를 피해야하므로 혼동 될 수 있습니다). &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#query_cache_wlock_invalidate&quot;&gt;query_cache_wlock_invalidate&lt;/a&gt;&lt;/code&gt; 시스템 변수를 &lt;code&gt;ON&lt;/code&gt; 으로 설정 하여이 동작을 변경할 수 있습니다 .이 경우 각 쓰기 잠금은 테이블 쿼리 캐시를 무효화합니다. 기본값 인 &lt;code&gt;OFF&lt;/code&gt; 로 설정 하면 테이블 잠금이 유지되는 동안에도 캐시 된 쿼리가 리턴 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="429af5bbfc80d805f89f027c6273f6e1064fa2b3" translate="yes" xml:space="preserve">
          <source>The query cache handles transactions. Internally a flag (FLAGS_IN_TRANS) is set to 0 when a query was executed outside a transaction, and to 1 when the query was inside a transaction (&lt;a href=&quot;begin&quot;&gt;BEGIN&lt;/a&gt; / &lt;a href=&quot;../commit/index&quot;&gt;COMMIT&lt;/a&gt; / &lt;a href=&quot;../rollback/index&quot;&gt;ROLLBACK&lt;/a&gt;). This flag is part of the &quot;query cache hash&quot;, in others words one query inside a transaction is different from a query outside a transaction.</source>
          <target state="translated">쿼리 캐시는 트랜잭션을 처리합니다. 내부적으로 플래그 (FLAGS_IN_TRANS)는 쿼리가 트랜잭션 외부에서 실행될 때 0으로 설정되고 쿼리가 트랜잭션 내부에있을 때는 1로 설정됩니다 ( &lt;a href=&quot;begin&quot;&gt;BEGIN&lt;/a&gt; / &lt;a href=&quot;../commit/index&quot;&gt;COMMIT&lt;/a&gt; / &lt;a href=&quot;../rollback/index&quot;&gt;ROLLBACK&lt;/a&gt; ). 이 플래그는 &quot;쿼리 캐시 해시&quot;의 일부입니다. 즉, 트랜잭션 내부의 쿼리 하나가 트랜잭션 외부의 쿼리와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="46329c569ed952719e2dbf817276f30211201456" translate="yes" xml:space="preserve">
          <source>The query cache is not used by the &lt;a href=&quot;../spider/index&quot;&gt;Spider&lt;/a&gt; storage engine (amongst others).</source>
          <target state="translated">&lt;a href=&quot;../spider/index&quot;&gt;스파이더&lt;/a&gt; 스토리지 엔진 은 쿼리 캐시를 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2b00b76e548e56afa0dff893b56b0c416c315de7" translate="yes" xml:space="preserve">
          <source>The query cache needs to be disabled in order to use &lt;a href=&quot;../oqgraph/index&quot;&gt;OQGRAPH&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../oqgraph/index&quot;&gt;OQGRAPH&lt;/a&gt; 를 사용하려면 쿼리 캐시를 비활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8af95f4b888b12d3f9f20d57cca961de217aa123" translate="yes" xml:space="preserve">
          <source>The query cache size is allocated in 1024 byte-blocks, thus it should be set to a multiple of 1024.</source>
          <target state="translated">쿼리 캐시 크기는 1024 바이트 블록으로 할당되므로 1024의 배수로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8083ed64bd5a2eac787fb38861a695404316756e" translate="yes" xml:space="preserve">
          <source>The query cache stores results of SELECT queries so that if the identical query is received in future, the results can be quickly returned.</source>
          <target state="translated">쿼리 캐시는 SELECT 쿼리의 결과를 저장하므로 나중에 동일한 쿼리가 수신되면 결과를 신속하게 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81178391b1f2357bb2e95899dbba39f573b170e0" translate="yes" xml:space="preserve">
          <source>The query in the configuration files is the query that will be used for building the index. In the sample data, this is:</source>
          <target state="translated">구성 파일의 쿼리는 인덱스 작성에 사용되는 쿼리입니다. 샘플 데이터에서 이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ce81250ed4aaa6f446b7f87a4d65f1bb38efdb0f" translate="yes" xml:space="preserve">
          <source>The query is structured so that the UM process on the PM node gets the fact table data locally from the PM node (as indicated by the use of the &lt;a href=&quot;../mariadb/columnstore-information-functions/index&quot;&gt;idbLocalPm()&lt;/a&gt; function), while the dimension table data is extracted from all the PM nodes.</source>
          <target state="translated">쿼리는 PM 노드의 UM 프로세스가 ( &lt;a href=&quot;../mariadb/columnstore-information-functions/index&quot;&gt;idbLocalPm ()&lt;/a&gt; 함수를 사용하여 표시 한대로) PM 노드에서 로컬로 팩트 테이블 데이터를 가져오고 차원 테이블 데이터는 모든 PM 노드에서 추출되도록 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c1a9b22914bae122c3d67c28d6b3365c2e1e0ded" translate="yes" xml:space="preserve">
          <source>The query is structured so that the UM process on the PM node gets the fact table data locally from the PM node (as indicated by the use of the idbLocalPm() function), while the dimension table data is extracted from all the PM nodes.</source>
          <target state="translated">쿼리는 PM 노드의 UM 프로세스가 (idbLocalPm () 함수를 사용하여 표시 한대로) PM 노드에서 로컬로 팩트 테이블 데이터를 가져오고 차원 테이블 데이터는 모든 PM 노드에서 추출되도록 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="edcbe11d2a0b93fed73cdc4ff65f21d59af47836" translate="yes" xml:space="preserve">
          <source>The query itself can also specify that it is not to be stored in the cache by using the &lt;code&gt;SQL_NO_CACHE&lt;/code&gt; attribute. Query-level control is an effective way to use the cache more optimally.</source>
          <target state="translated">조회 자체는 &lt;code&gt;SQL_NO_CACHE&lt;/code&gt; 속성 을 사용하여 캐시에 저장되지 않도록 지정할 수도 있습니다 . 쿼리 수준 제어는 캐시를보다 최적으로 사용하는 효과적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="5b4a6365adbb9e6f856ebfd9a91e7ea91a5f661a" translate="yes" xml:space="preserve">
          <source>The query planner will</source>
          <target state="translated">쿼리 플래너는</target>
        </trans-unit>
        <trans-unit id="65f0520379fff4aba97390a0b19b9c509b3626b0" translate="yes" xml:space="preserve">
          <source>The query result is stored using a minimum block size of &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#query_cache_min_res_unit&quot;&gt;query_cache_min_res_unit&lt;/a&gt;&lt;/code&gt;. Check two conditions to use a good value of this variable: Query cache insert result blocks with locks, each new block insert lock query cache, a small value will increase locks and fragmentation and waste less memory for small results, a big value will increase memory use wasting more memory for small results but it reduce locks. Test with your workload for fine tune this variable.</source>
          <target state="translated">쿼리 결과는 &lt;code&gt;&lt;a href=&quot;../server-system-variables/index#query_cache_min_res_unit&quot;&gt;query_cache_min_res_unit&lt;/a&gt;&lt;/code&gt; 의 최소 ​​블록 크기를 사용하여 저장됩니다 . 이 변수의 올바른 값을 사용하려면 두 가지 조건을 확인하십시오. 잠금이있는 쿼리 캐시 삽입 결과 블록, 각각의 새 블록 삽입 잠금 쿼리 캐시, 작은 값은 잠금 및 조각화를 증가시키고 작은 결과를 위해 적은 메모리를 낭비하며 큰 값은 메모리를 증가시킵니다 작은 결과를 위해 더 많은 메모리를 낭비하지만 잠금을 줄입니다. 이 변수를 미세 조정하기 위해 워크로드로 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="9ab1dd65c6ec60581d4f89da9b3c7bda243f9a27" translate="yes" xml:space="preserve">
          <source>The query sent to the server will be:</source>
          <target state="translated">서버로 전송 된 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="261947ab67879e306d45db54c2b82e72fd304387" translate="yes" xml:space="preserve">
          <source>The query takes 40 seconds over cold cache</source>
          <target state="translated">콜드 캐시보다 쿼리가 40 초 걸립니다</target>
        </trans-unit>
        <trans-unit id="0c9b1c1f646e8730307f68bffc57c9e4cc07246a" translate="yes" xml:space="preserve">
          <source>The query takes more than one hour (we didn't wait longer), which makes it impractical to use subqueries in such cases. The EXPLAIN below shows that the subquery was transformed into a correlated one, which indicates an IN-TO-EXISTS transformation.</source>
          <target state="translated">쿼리는 1 시간 이상 걸리며 (더 이상 기다리지 않음) 이러한 경우 하위 쿼리를 사용하는 것은 실용적이지 않습니다. 아래 EXPLAIN은 하위 쿼리가 상관 관계 쿼리로 변환되어 IN-TO-EXISTS 변환을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9ba4dca94d761ddc0e2896c5c838107b199036b5" translate="yes" xml:space="preserve">
          <source>The query to discuss</source>
          <target state="translated">논의 할 질문</target>
        </trans-unit>
        <trans-unit id="dc69340d948eb3288cbfd0579915b981a85c4a8a" translate="yes" xml:space="preserve">
          <source>The query uses only one table.</source>
          <target state="translated">쿼리는 하나의 테이블 만 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9a5deb133b05d0f4a602953f39914f1328b916e7" translate="yes" xml:space="preserve">
          <source>The query was to find big (l_quantity &amp;gt; 40) orders that were made in January 1993 that took more than 25 days to ship:</source>
          <target state="translated">이 쿼리는 1993 년 1 월에 이루어진 대량 (l_quantity&amp;gt; 40) 주문을 배송하는 데 25 일 이상이 걸렸습니다.</target>
        </trans-unit>
        <trans-unit id="ef51a9988f989257559bb75c81805cc1df1b9479" translate="yes" xml:space="preserve">
          <source>The query will read about 90 rows, which is a big improvement over the 4079 row reads plus 4068 temporary table reads/writes we had before.</source>
          <target state="translated">쿼리는 약 90 개의 행을 읽습니다. 이는 이전에 있었던 4079 개의 행 읽기와 4068 개의 임시 테이블 읽기 / 쓰기에 비해 크게 개선 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="c7ae4e661cd9699033d8dfaf449935dd350cf6d4" translate="yes" xml:space="preserve">
          <source>The query:</source>
          <target state="translated">쿼리 :</target>
        </trans-unit>
        <trans-unit id="7c8cc81855ce4f9470d47431d9374cdc1ad9493e" translate="yes" xml:space="preserve">
          <source>The question is &quot;When was Andrew Johnson president of the US?&quot;.</source>
          <target state="translated">문제는 &quot;앤드류 존슨은 언제 미국 대통령 이었는가?&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d9185a2a2b174ac535ca2a3c6c5bd1d3329a2442" translate="yes" xml:space="preserve">
          <source>The question mark and the colon after the opening parenthesis create a non-capturing group: &lt;code&gt;(?:...)&lt;/code&gt;.</source>
          <target state="translated">여는 괄호 뒤에 물음표와 콜론이 캡처되지 않은 그룹을 생성합니다 : &lt;code&gt;(?:...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5de24fd9018e93787fa2bbb80e9293f112ddb08a" translate="yes" xml:space="preserve">
          <source>The queued rows are held only in memory until they are inserted into the table. This means that if you terminate mysqld forcibly (for example, with kill -9) or if mysqld dies unexpectedly, any queued rows that have not been written to disk are lost.</source>
          <target state="translated">큐에 대기 된 행은 테이블에 삽입 될 때까지 메모리에만 보관됩니다. 즉, mysqld를 강제로 종료 (예 : kill -9 사용)하거나 mysqld가 예기치 않게 종료되면 디스크에 기록되지 않은 모든 대기열 행이 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="c9509ad54d613c68e56620a94c79a862941a670b" translate="yes" xml:space="preserve">
          <source>The quick way to get an _estimated_ number of rows for an InnoDB table is</source>
          <target state="translated">InnoDB 테이블에 대해 _estimated_ 개의 행 수를 얻는 빠른 방법은</target>
        </trans-unit>
        <trans-unit id="703e44c283ec893030b5d75df5d77e15ed79f0f6" translate="yes" xml:space="preserve">
          <source>The range key (dt) must be included in any PRIMARY or UNIQUE key.</source>
          <target state="translated">PRIMARY 또는 UNIQUE 키에는 범위 키 (dt)가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="992222f8fc28caf0a9f22c19967253540a06ccc0" translate="yes" xml:space="preserve">
          <source>The range key (dt) should be last in any keys it is in -- You have already &quot;pruned&quot; with it; it is almost useless in the index, especially at the beginning.</source>
          <target state="translated">범위 키 (dt)는 그 안에있는 모든 키에서 마지막이어야합니다. 이미 &quot;정리 된&quot;키입니다. 색인에서, 특히 처음에는 거의 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e2bf5ba4335fc9b6f6631ad66eecfe724a51f7f" translate="yes" xml:space="preserve">
          <source>The range_base is some positive number (see Limitations). The interval is defined as the difference between two nearby powers of the range base.</source>
          <target state="translated">range_base는 양수입니다 (제한 사항 참조). 구간은 근거리 기반의 두 개의 거듭 제곱의 차이로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b43197479a987cf4fba48450ff9374f0ba27a881" translate="yes" xml:space="preserve">
          <source>The rank window function allows for ranking or assigning a numeric order value based on the window function definition. Using the Rank() function will result in the same value for ties / equal values and the next rank value skipped. The Dense_Rank() function behaves similarly except the next consecutive number is used after a tie rather than skipped. The Row_Number() function will provide a unique ordering value. The example query shows the Rank() function being applied to rank sales reps by the number of opportunities for Q4 2016.</source>
          <target state="translated">순위 창 함수를 사용하면 창 함수 정의에 따라 숫자 순서 값의 순위를 지정하거나 지정할 수 있습니다. Rank () 함수를 사용하면 동점 / 동일한 값에 대해 동일한 값을 가지며 다음 순위 값을 건너 뜁니다. Dense_Rank () 함수는 다음 연속 번호를 건너 뛰지 않고 동점 다음에 사용하는 것을 제외하고는 유사하게 작동합니다. Row_Number () 함수는 고유 한 순서 값을 제공합니다. 예제 쿼리는 2016 년 4 분기 기회 수에 따라 영업 담당자의 순위를 매기는 데 적용되는 Rank () 함수를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7672f19621d3eef7146ee2d1dc68b3343f113d8c" translate="yes" xml:space="preserve">
          <source>The ratio of key_reads to key_read_requests should be as low as possible, 1:100 is the highest acceptable, 1:1000 is better, and 1:10 is terrible.</source>
          <target state="translated">key_reads와 key_read_requests의 비율은 가능한 한 낮아야합니다. 1 : 100이 가장 높고 1 : 1000이 더 좋고 1:10이 끔찍합니다.</target>
        </trans-unit>
        <trans-unit id="c49a5ef35c9bc94f1fac002a503c1cc1347f8f4a" translate="yes" xml:space="preserve">
          <source>The read point select is produce with a 10M rows sysbench table</source>
          <target state="translated">판독 포인트 선택은 10M 행 sysbench 테이블로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="58d8ad613c25b1799c1ff217444b45a23581e6f0" translate="yes" xml:space="preserve">
          <source>The readable variable value is the same, regardless if read as a global or session value.</source>
          <target state="translated">읽을 수있는 변수 값은 전역 값으로 읽든 세션 값으로 읽든 상관없이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="4aa9927ab3fec3f221a660f16bdccd94a2981e52" translate="yes" xml:space="preserve">
          <source>The real data type of &lt;code&gt;TYPE OF&lt;/code&gt; and &lt;code&gt;ROW TYPE OF table_name&lt;/code&gt; will become known at the very beginning of the stored routine call. &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; or &lt;a href=&quot;../drop-table/index&quot;&gt;DROP TABLE&lt;/a&gt; statements performed inside the current routine on the tables that appear in anchors won't affect the data type of the anchored variables, even if the variable is declared after an &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; or &lt;a href=&quot;../drop-table/index&quot;&gt;DROP TABLE&lt;/a&gt; statement.</source>
          <target state="translated">저장된 루틴 호출의 맨 처음에 &lt;code&gt;TYPE OF&lt;/code&gt; 및 &lt;code&gt;ROW TYPE OF table_name&lt;/code&gt; 의 실제 데이터 유형 이 알려집니다. 앵커에 나타나는 테이블에서 현재 루틴 내에서 수행 된 &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; 또는 &lt;a href=&quot;../drop-table/index&quot;&gt;DROP TABLE&lt;/a&gt; 문은 변수가 &lt;a href=&quot;../alter-table/index&quot;&gt;ALTER TABLE&lt;/a&gt; 또는 &lt;a href=&quot;../drop-table/index&quot;&gt;DROP TABLE&lt;/a&gt; 문 다음에 선언 된 경우에도 앵커링 된 변수의 데이터 유형에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ca1b403e63ea6252fb2fdd75228f3d05fb43f5ad" translate="yes" xml:space="preserve">
          <source>The real data type of a &lt;code&gt;ROW TYPE OF cursor_name&lt;/code&gt; variable will become known when execution enters into the block where the variable is declared. Data type instantiation will happen only once. In a cursor &lt;code&gt;ROW TYPE OF&lt;/code&gt; variable that is declared inside a loop, its data type will become known on the very first iteration and won't change on further loop iterations.</source>
          <target state="translated">&lt;code&gt;ROW TYPE OF cursor_name&lt;/code&gt; 변수 의 실제 데이터 유형은 변수가 선언 된 블록에 실행이 입력 될 때 알려지게됩니다. 데이터 유형 인스턴스화는 한 번만 발생합니다. 루프 내에서 선언 된 커서 &lt;code&gt;ROW TYPE OF&lt;/code&gt; 변수에서 해당 데이터 유형은 첫 번째 반복에서 알려지고 추가 루프 반복에서 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="978b9b0f5a4a3e281c9ad0963228d26e815432fd" translate="yes" xml:space="preserve">
          <source>The real problems occur with outward tables, in particular when they are created from already existing files. The first issue is to make the partition table use the correct existing file names. The second one, only for already existing not void tables, is to be sure the partitioning function match the distribution of the data already existing in the files.</source>
          <target state="translated">실제 문제는 특히 기존 파일에서 작성된 경우 외부 테이블에서 발생합니다. 첫 번째 문제는 파티션 테이블이 올바른 기존 파일 이름을 사용하도록하는 것입니다. 두 번째는 이미 존재하지 않는 테이블에 대해서만 분할 기능이 파일에 이미 존재하는 데이터의 분포와 일치하는지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1814931487da6ac5262c8f982cd87086abe4a515" translate="yes" xml:space="preserve">
          <source>The real work of Flashback is done by &lt;code&gt;mysqlbinlog&lt;/code&gt; with &lt;code&gt;--flashback&lt;/code&gt;. This causes events to be translated: INSERT to DELETE, DELETE to INSERT, and for UPDATEs the before and after images are swapped.</source>
          <target state="translated">Flashback의 실제 작업은 &lt;code&gt;--flashback&lt;/code&gt; 과 함께 &lt;code&gt;mysqlbinlog&lt;/code&gt; 에 의해 수행됩니다 . 이로 인해 이벤트가 INSERT에서 DELETE로, DELETE에서 INSERT로, UPDATE의 경우 전후 이미지가 교환됩니다.</target>
        </trans-unit>
        <trans-unit id="869b864f5c5ead99dd33d7169d93bad5cb043562" translate="yes" xml:space="preserve">
          <source>The reason for the above change is that MariaDB is using the newer &lt;a href=&quot;../aria-storage-engine/index&quot;&gt;Aria&lt;/a&gt; storage engine for disk based temporary files instead of MyISAM. The main benefit of Aria is that it can cache both indexes and rows and thus gives better performance than MyISAM for large queries.</source>
          <target state="translated">위의 변경 이유는 MariaDB가 MyISAM 대신 디스크 기반 임시 파일을 위해 최신 &lt;a href=&quot;../aria-storage-engine/index&quot;&gt;Aria&lt;/a&gt; 스토리지 엔진을 사용하고 있기 때문입니다 . Aria의 주요 이점은 인덱스와 행을 모두 캐시 할 수있어 대규모 쿼리에 대해 MyISAM보다 성능이 향상된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9e2ef53ca872d2c1ca42375a0cba443e16de9918" translate="yes" xml:space="preserve">
          <source>The reason for the differing results above is that when 0x31 is inserted directly to the column, it's treated as a number (see &lt;a href=&quot;../hexadecimal-literals/index&quot;&gt;Hexadecimal Literals&lt;/a&gt;), while when 0x31 is passed to COALESCE(), it's treated as a string, because:</source>
          <target state="translated">위의 결과가 다른 이유는 0x31이 열에 직접 삽입 될 때 숫자로 처리되고 ( &lt;a href=&quot;../hexadecimal-literals/index&quot;&gt;16 진 리터럴&lt;/a&gt; 참조 ) 0x31이 COALESCE ()에 전달되면 문자열로 처리되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2bd00847d52fcddbb4f8c0ebe4babf867d79debb" translate="yes" xml:space="preserve">
          <source>The reason for the differing results above is that when 0x31 is inserted directly to the column, it's treated as a number, while when 0x31 is passed to &lt;a href=&quot;../coalesce/index&quot;&gt;COALESCE()&lt;/a&gt;, it's treated as a string, because:</source>
          <target state="translated">위의 결과가 다른 이유는 0x31이 열에 직접 삽입되면 숫자로 처리되고 0x31이 &lt;a href=&quot;../coalesce/index&quot;&gt;COALESCE ()로&lt;/a&gt; 전달되면 문자열로 처리되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="af851afac0210e6a773312ecbbfb53f02fb297e4" translate="yes" xml:space="preserve">
          <source>The reason for the failure will almost certainly be written in the &lt;a href=&quot;../error-log/index&quot;&gt;error log&lt;/a&gt; and, if you are starting MariaDB manually, to the console. By default, the error log is named &lt;em&gt;host-name&lt;/em&gt;.err and is written to the data directory.</source>
          <target state="translated">실패 원인은 거의 확실하게 &lt;a href=&quot;../error-log/index&quot;&gt;오류 로그에 기록&lt;/a&gt; 되며 MariaDB를 수동으로 시작하는 경우 콘솔에 기록됩니다. 기본적으로 오류 로그의 이름은 &lt;em&gt;host-name&lt;/em&gt; .err이며 데이터 디렉토리에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="27ed3e1605cb7ff20bbd86d44cc3d2f22e443de6" translate="yes" xml:space="preserve">
          <source>The reason for this behavior is Vista/Win7 file system redirection. Writes to protected locations (in this case a subdirectory of Program Files) are redirected to the user's so-called &quot;Virtual Store&quot;.</source>
          <target state="translated">이 동작의 이유는 Vista / Win7 파일 시스템 리디렉션입니다. 보호 된 위치 (이 경우 Program Files의 하위 디렉토리)에 대한 쓰기는 사용자의 소위 &quot;가상 저장소&quot;로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="2bd0a2a7de22af01f40fb210930e50cc63890f06" translate="yes" xml:space="preserve">
          <source>The reason is that MariaDB's build process relies heavily on &lt;code&gt;&lt;a href=&quot;https://cmake.org&quot;&gt;cmake&lt;/a&gt;&lt;/code&gt; for a lot of things. In this specific case, MariaDB's build process relies on &lt;a href=&quot;https://gitlab.kitware.com/cmake/community/wikis/doc/cpack/PackageGenerators&quot;&gt;CMake CPack Package Generators&lt;/a&gt; to build RPMs. The specific package generator that it uses to build RPMs is called &lt;code&gt;&lt;a href=&quot;https://cmake.org/cmake/help/v3.10/module/CPackRPM.html&quot;&gt;CPackRPM&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">그 이유는 MariaDB의 빌드 프로세스 가 많은 것을 위해 &lt;code&gt;&lt;a href=&quot;https://cmake.org&quot;&gt;cmake&lt;/a&gt;&lt;/code&gt; 에 크게 의존 하기 때문입니다. 이 특정한 경우, MariaDB의 빌드 프로세스는 &lt;a href=&quot;https://gitlab.kitware.com/cmake/community/wikis/doc/cpack/PackageGenerators&quot;&gt;CMake CPack 패키지 생성기&lt;/a&gt; 를 사용하여 RPM을 빌드합니다. RPM을 빌드하는 데 사용하는 특정 패키지 생성기를 &lt;code&gt;&lt;a href=&quot;https://cmake.org/cmake/help/v3.10/module/CPackRPM.html&quot;&gt;CPackRPM&lt;/a&gt;&lt;/code&gt; 이라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="fd5679fb1f08e7ba9066ce758f51ff63efefe559" translate="yes" xml:space="preserve">
          <source>The reason is that dropping column &lt;code&gt;a&lt;/code&gt; would result in the new constraint that all values in column &lt;code&gt;b&lt;/code&gt; be unique. In order to drop the column, an explicit &lt;code&gt;DROP PRIMARY KEY&lt;/code&gt; and &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; would be required. Up until &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1027-release-notes/&quot;&gt;MariaDB 10.2.7&lt;/a&gt;, the column was dropped and the additional constraint applied, resulting in the following structure:</source>
          <target state="translated">그 이유는 열 &lt;code&gt;a&lt;/code&gt; 를 삭제 하면 열 &lt;code&gt;b&lt;/code&gt; 의 모든 값 이 고유 해야한다는 새로운 제약 조건이 생길 수 있기 때문입니다 . 열을 삭제하려면 명시 적 &lt;code&gt;DROP PRIMARY KEY&lt;/code&gt; 및 &lt;code&gt;ADD PRIMARY KEY&lt;/code&gt; 가 필요합니다. &lt;a href=&quot;https://mariadb.com/kb/en/mariadb-1027-release-notes/&quot;&gt;MariaDB 10.2.7&lt;/a&gt; 까지 열을 삭제하고 추가 제한 조건을 적용하여 다음 구조를 생성했습니다.</target>
        </trans-unit>
        <trans-unit id="4ec59df6c9e177482e1db6baef0313f3f6642924" translate="yes" xml:space="preserve">
          <source>The reason is the weight between nodes 2 and 6 is &lt;code&gt;10&lt;/code&gt; in &lt;code&gt;oq_graph2&lt;/code&gt;, so the shortest path taking into account &lt;code&gt;weight&lt;/code&gt; is now across more nodes.</source>
          <target state="translated">그 이유는 &lt;code&gt;oq_graph2&lt;/code&gt; 에서 노드 2와 6 사이의 가중치가 &lt;code&gt;10&lt;/code&gt; 이므로 &lt;code&gt;weight&lt;/code&gt; 를 고려한 최단 경로 는 이제 더 많은 노드에 걸쳐 있습니다.</target>
        </trans-unit>
        <trans-unit id="281d491a830750556dc655788ac54898b0806f0a" translate="yes" xml:space="preserve">
          <source>The reason to use &lt;code&gt;--no-defaults&lt;/code&gt; is to ensure that we don't inherit incorrect options from some old my.cnf.</source>
          <target state="translated">&lt;code&gt;--no-defaults&lt;/code&gt; 를 사용하는 이유 는 이전 my.cnf에서 잘못된 옵션을 상속하지 않기 위해서입니다.</target>
        </trans-unit>
        <trans-unit id="bc59373392d64e4692dc4087611eec17faa200c8" translate="yes" xml:space="preserve">
          <source>The reason why only one instead of two rows was returned becomes clear when we see how the floating point squares were evaluated.</source>
          <target state="translated">부동 소수점 제곱이 어떻게 평가되는지 볼 때 두 행 대신 하나만 반환되는 이유가 명확 해집니다.</target>
        </trans-unit>
        <trans-unit id="78db1e4a3f2f6a756c476fd8a1a42f25d174044c" translate="yes" xml:space="preserve">
          <source>The reason why the first argument is returned by such a query is because of tables such as:</source>
          <target state="translated">이러한 쿼리에서 첫 번째 인수가 반환되는 이유는 다음과 같은 테이블 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2dcc0adc076c0cbae785f69f72a56f1276afe984" translate="yes" xml:space="preserve">
          <source>The reason why you may want to have many &lt;code&gt;BEGIN/END&lt;/code&gt; statements instead of just one is that the former will use up less transaction log space.</source>
          <target state="translated">하나 대신 많은 &lt;code&gt;BEGIN/END&lt;/code&gt; 문을 사용 하려는 이유 는 전자가 트랜잭션 로그 공간을 적게 사용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="afd25ae0533df50367d3121c5f6bc8e2fa4bfdaf" translate="yes" xml:space="preserve">
          <source>The reasons you may want to use InnoDB instead of XtraDB are:</source>
          <target state="translated">XtraDB 대신 InnoDB를 사용하려는 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b12b08a20c68b146e004d904adaa552fda94c3c" translate="yes" xml:space="preserve">
          <source>The recommended algorithm is &lt;code&gt;AES_CTR&lt;/code&gt;, but this algorithm is only available when MariaDB is built with recent versions of &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL&lt;/a&gt;. If the server is built with &lt;a href=&quot;https://www.wolfssl.com/products/wolfssl/&quot;&gt;wolfSSL&lt;/a&gt; or &lt;a href=&quot;https://www.wolfssl.com/products/yassl/&quot;&gt;yaSSL&lt;/a&gt;, then this algorithm is not available. See &lt;a href=&quot;../tls-and-cryptography-libraries-used-by-mariadb/index&quot;&gt;TLS and Cryptography Libraries Used by MariaDB&lt;/a&gt; for more information about which libraries are used on which platforms.</source>
          <target state="translated">권장 알고리즘은 &lt;code&gt;AES_CTR&lt;/code&gt; 이지만이 알고리즘은 MariaDB가 최신 버전의 &lt;a href=&quot;https://www.openssl.org/&quot;&gt;OpenSSL로&lt;/a&gt; 빌드 된 경우에만 사용할 수 있습니다 . 서버가 &lt;a href=&quot;https://www.wolfssl.com/products/wolfssl/&quot;&gt;wolfSSL&lt;/a&gt; 또는 &lt;a href=&quot;https://www.wolfssl.com/products/yassl/&quot;&gt;yaSSL로&lt;/a&gt; 빌드 된 경우이 알고리즘을 사용할 수 없습니다. 어떤 플랫폼에서 어떤 라이브러리가 사용되는지에 대한 자세한 정보는 &lt;a href=&quot;../tls-and-cryptography-libraries-used-by-mariadb/index&quot;&gt;MariaDB&lt;/a&gt; 가 사용하는 TLS 및 암호화 라이브러리를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="499d1aa482447ebea83d5c48b70920477e7910c5" translate="yes" xml:space="preserve">
          <source>The recommended way to quickly check all MyISAM tables:</source>
          <target state="translated">모든 MyISAM 테이블을 빠르게 확인하는 권장 방법 :</target>
        </trans-unit>
        <trans-unit id="09695ae331e1ae118988ef2b184625ac91cdf763" translate="yes" xml:space="preserve">
          <source>The records of the first operand are written into the join buffer one by one until the buffer is full.</source>
          <target state="translated">첫 번째 피연산자의 레코드는 버퍼가 가득 찰 때까지 조인 버퍼에 하나씩 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="603e40929284ab013d6fa107aa4498105d8261aa" translate="yes" xml:space="preserve">
          <source>The records of the second operand are read from the base/temporary table one by one. For every read record r2 of table t2 the join buffer is scanned, and, for any record r1 from the buffer such that r2 matches r1 the concatenation of the interesting fields of r1 and r2 is sent to the result stream of the corresponding partial join.</source>
          <target state="translated">두 번째 피연산자의 레코드는 기본 / 임시 테이블에서 하나씩 읽습니다. 테이블 t2의 모든 판독 레코드 r2에 대해, 결합 버퍼가 스캔되고, r2가 r1과 일치하도록 버퍼로부터의 임의의 레코드 r1에 대해 r1 및 r2의 흥미로운 필드의 연결이 대응하는 부분 결합의 결과 스트림으로 전송된다.</target>
        </trans-unit>
        <trans-unit id="e3546f5c87b27306809d7744ee049be348eefe41" translate="yes" xml:space="preserve">
          <source>The recovery mode should never be set to a value other than zero except in an emergency situation.</source>
          <target state="translated">응급 상황을 제외하고 복구 모드를 0 이외의 값으로 설정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b0f9fb05017e14283054cc9157c01f328ca74bb6" translate="yes" xml:space="preserve">
          <source>The recursion is done using &lt;code&gt;(?1)&lt;/code&gt; to call for the first parenthesized subpattern, which includes everything except the leading &lt;code&gt;^&lt;/code&gt; and the trailing &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">재귀는 &lt;code&gt;(?1)&lt;/code&gt; 을 사용 하여 첫 번째 괄호로 묶인 하위 패턴을 호출합니다. 여기에는 선행 &lt;code&gt;^&lt;/code&gt; 및 후행 &lt;code&gt;$&lt;/code&gt; 를 제외한 모든 것이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="8892f7fe089926dde4ac4b4e3a939d4ad3dbd434" translate="yes" xml:space="preserve">
          <source>The redo log group capacity is the total combined size of all InnoDB redo logs. The relevant factors are:</source>
          <target state="translated">리두 로그 그룹 용량은 모든 InnoDB 리두 로그의 총 결합 크기입니다. 관련 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eff4ded1badf3e43456eca56c8ba6b2ec39a98b2" translate="yes" xml:space="preserve">
          <source>The redo log is used by &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB/XtraDB&lt;/a&gt; during crash recovery. The redo log files have names like &lt;code&gt;ib_logfileN&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is an integer. If the &lt;a href=&quot;../innodb-system-variables/index#innodb_log_group_home_dir&quot;&gt;innodb_log_group_home_dir&lt;/a&gt; system variable is configured, then the redo log files will be created in that directory. Otherwise, they will be created in the directory defined by the &lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt; system variable.</source>
          <target state="translated">재실행 로그는 응급 복구 중에 &lt;a href=&quot;../innodb/index&quot;&gt;InnoDB / XtraDB&lt;/a&gt; 에서 사용됩니다 . 리두 로그 파일은 &lt;code&gt;ib_logfileN&lt;/code&gt; 과 같은 이름을 가지며 , 여기서 &lt;code&gt;N&lt;/code&gt; 은 정수입니다. 는 IF &lt;a href=&quot;../innodb-system-variables/index#innodb_log_group_home_dir&quot;&gt;innodb_log_group_home_dir의&lt;/a&gt; 시스템 변수가 구성되어, 다음 리두 로그 파일은 해당 디렉토리에 생성됩니다. 그렇지 않으면 &lt;a href=&quot;../server-system-variables/index#datadir&quot;&gt;datadir&lt;/a&gt; 시스템 변수로 정의 된 디렉토리에 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e4f5330e7810bb346b3ec3c87e6d0813cc671d57" translate="yes" xml:space="preserve">
          <source>The redo log occupancy is the percentage of the InnoDB redo log capacity that is taken up by dirty pages that have not yet been flushed to the physical InnoDB tablespace files in a checkpoint. Therefore, it's determined by the following calculation:</source>
          <target state="translated">리두 로그 점유는 체크 포인트에서 물리적 InnoDB 테이블 스페이스 파일로 아직 플러시되지 않은 더티 페이지가 차지하는 InnoDB 리두 로그 용량의 백분율입니다. 따라서 다음 계산에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="712dd36bc323bc2607045a05ddd2b902a0a4eaae" translate="yes" xml:space="preserve">
          <source>The reference examples above are included in the standard build of MariaDB ColumnStore and so can be used by registering them as user defined aggregate functions. The same can be done for new functions assuming the instance has the updated libraries included. From a mcsmysql prompt:</source>
          <target state="translated">위의 참조 예제는 MariaDB ColumnStore의 표준 빌드에 포함되어 있으므로 사용자 정의 집계 함수로 등록하여 사용할 수 있습니다. 인스턴스에 업데이트 된 라이브러리가 포함되어 있다고 가정하면 새 기능에 대해서도 동일한 작업을 수행 할 수 있습니다. mcsmysql 프롬프트에서 :</target>
        </trans-unit>
        <trans-unit id="46ae100eab0e4654f4b0a22060c1139562612b17" translate="yes" xml:space="preserve">
          <source>The reference that is used to as the key value.</source>
          <target state="translated">키 값으로 사용되는 참조입니다.</target>
        </trans-unit>
        <trans-unit id="78de7d1b69048779cc1242891024d28aa175520a" translate="yes" xml:space="preserve">
          <source>The referenced columns must be a PRIMARY KEY or a UNIQUE index.</source>
          <target state="translated">참조 된 열은 PRIMARY KEY 또는 UNIQUE 인덱스 여야합니다.</target>
        </trans-unit>
        <trans-unit id="61b3bb875cac06ff44029bc30d6c88c4aaf975a5" translate="yes" xml:space="preserve">
          <source>The regular expression for the table name can be negated by prefixing it with a tilde (&amp;ldquo;&lt;code&gt;~&lt;/code&gt;&amp;rdquo;):</source>
          <target state="translated">테이블 이름의 정규식은 물결표 (&amp;ldquo; &lt;code&gt;~&lt;/code&gt; &amp;rdquo;) 로 접두사로 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b976516e51c2acb7553c4272b275d0e4f4a42f6" translate="yes" xml:space="preserve">
          <source>The regular expression in the above example implements the following BNF grammar:</source>
          <target state="translated">위 예제의 정규식은 다음 BNF 문법을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="27000444f76ac159c10093da425abe717e95fb3e" translate="yes" xml:space="preserve">
          <source>The regular quote character is the backtick character - &lt;code&gt;`&lt;/code&gt;, but if the &lt;code&gt;ANSI_QUOTES&lt;/code&gt;&lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; option is specified, a regular double quote - &lt;code&gt;&quot;&lt;/code&gt; may be used as well.</source>
          <target state="translated">정규 따옴표 문자는 백틱 문자 ( &lt;code&gt;`&lt;/code&gt; )이지만 &lt;code&gt;ANSI_QUOTES&lt;/code&gt; &lt;a href=&quot;../sql-mode/index&quot;&gt;SQL_MODE&lt;/a&gt; 옵션이 지정된 경우 일반 따옴표 ( &lt;code&gt;&quot;&lt;/code&gt; ) 도 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d26ceade479cff3650e1d980545de76b5ab2c7f" translate="yes" xml:space="preserve">
          <source>The regular server &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;option groups&lt;/a&gt; can also be used for common options that are read by all instances:</source>
          <target state="translated">일반 서버 &lt;a href=&quot;../configuring-mariadb-with-option-files/index#option-groups&quot;&gt;옵션 그룹&lt;/a&gt; 은 모든 인스턴스가 읽는 공통 옵션에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="199e143b693ef04e141b826316416f1cfd63514f" translate="yes" xml:space="preserve">
          <source>The related &lt;a href=&quot;../information-schema-innodb_buffer_page/index&quot;&gt;INFORMATION_SCHEMA.INNODB_BUFFER_PAGE&lt;/a&gt; table contains the same information, but with a block id rather than LRU position.</source>
          <target state="translated">관련 &lt;a href=&quot;../information-schema-innodb_buffer_page/index&quot;&gt;INFORMATION_SCHEMA.INNODB_BUFFER_PAGE&lt;/a&gt; 테이블에는 동일한 정보가 있지만 LRU 위치가 아닌 블록 ID가 있습니다.</target>
        </trans-unit>
        <trans-unit id="12e1668b5cbe725da21a49ba3b4e04efe30197af" translate="yes" xml:space="preserve">
          <source>The related &lt;a href=&quot;../information-schema-innodb_buffer_page_lru-table/index&quot;&gt;INFORMATION_SCHEMA.INNODB_BUFFER_PAGE_LRU&lt;/a&gt; table contains the same information, but with an LRU (least recently used) position rather than block id.</source>
          <target state="translated">관련 &lt;a href=&quot;../information-schema-innodb_buffer_page_lru-table/index&quot;&gt;INFORMATION_SCHEMA.INNODB_BUFFER_PAGE_LRU&lt;/a&gt; 테이블에는 동일한 정보가 포함되지만 블록 ID가 아닌 LRU (최근에 사용 된) 위치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4fa1781a4a8445f584092ccd2267bc42810a850" translate="yes" xml:space="preserve">
          <source>The related &lt;a href=&quot;../xtradbinnodb-server-status-variables/index#innodb_available_undo_logs&quot;&gt;innodb_available_undo_logs&lt;/a&gt; status variable stores the total number of available InnoDB undo logs.</source>
          <target state="translated">관련된 &lt;a href=&quot;../xtradbinnodb-server-status-variables/index#innodb_available_undo_logs&quot;&gt;innodb_available_undo_logs&lt;/a&gt; 상태 변수는 사용 가능한 총 InnoDB 실행 취소 로그 수를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="a69415a5311b98dd3194975f4e50252f99167c10" translate="yes" xml:space="preserve">
          <source>The related tables, &lt;a href=&quot;../performance-schema-events_stages_history-table/index&quot;&gt;events_stages_history&lt;/a&gt; and &lt;a href=&quot;../performance-schema-events_stages_history_long-table/index&quot;&gt;events_stages_history_long&lt;/a&gt; derive their values from the current events.</source>
          <target state="translated">관련 테이블 &lt;a href=&quot;../performance-schema-events_stages_history-table/index&quot;&gt;events_stages_history&lt;/a&gt; 및 &lt;a href=&quot;../performance-schema-events_stages_history_long-table/index&quot;&gt;events_stages_history_long&lt;/a&gt; 은 현재 이벤트에서 값을 파생합니다.</target>
        </trans-unit>
        <trans-unit id="30a024b8920d31b75f7418899433da00ce9d86be" translate="yes" xml:space="preserve">
          <source>The related tables, &lt;a href=&quot;../performance-schema-events_statements_history-table/index&quot;&gt;events_statements_history&lt;/a&gt; and &lt;a href=&quot;../performance-schema-events_statements_history_long-table/index&quot;&gt;events_statements_history_long&lt;/a&gt; derive their values from the current events table.</source>
          <target state="translated">관련 테이블 &lt;a href=&quot;../performance-schema-events_statements_history-table/index&quot;&gt;events_statements_history&lt;/a&gt; 및 &lt;a href=&quot;../performance-schema-events_statements_history_long-table/index&quot;&gt;events_statements_history_long&lt;/a&gt; 은 현재 이벤트 테이블에서 해당 값을 파생합니다.</target>
        </trans-unit>
        <trans-unit id="2b17c8cc0363cadb7f8df990105deb08a75565e7" translate="yes" xml:space="preserve">
          <source>The related tables, &lt;a href=&quot;../performance-schema-events_waits_history-table/index&quot;&gt;events_waits_history&lt;/a&gt; and &lt;a href=&quot;../performance-schema-events_waits_history_long-table/index&quot;&gt;events_waits_history_long&lt;/a&gt; derive their values from the current events.</source>
          <target state="translated">관련 테이블 &lt;a href=&quot;../performance-schema-events_waits_history-table/index&quot;&gt;events_waits_history&lt;/a&gt; 및 &lt;a href=&quot;../performance-schema-events_waits_history_long-table/index&quot;&gt;events_waits_history_long&lt;/a&gt; 은 현재 이벤트에서 값을 파생합니다.</target>
        </trans-unit>
        <trans-unit id="9927805c75e7e95885d7c0fee21dedbe361b7a1a" translate="yes" xml:space="preserve">
          <source>The relay log is a set of log files created by a slave during &lt;a href=&quot;../standard-replication/index&quot;&gt;replication&lt;/a&gt;.</source>
          <target state="translated">릴레이 로그는 &lt;a href=&quot;../standard-replication/index&quot;&gt;복제&lt;/a&gt; 중에 슬레이브가 생성 한 로그 파일 세트입니다 .</target>
        </trans-unit>
        <trans-unit id="a45230ee4135d81662e4a0bdf9e24caa0e98de60" translate="yes" xml:space="preserve">
          <source>The relay-log name with a connection_name suffix. The xxxxx is the relay log number. This contains the replication data read from the master.</source>
          <target state="translated">connection_name 접미사가있는 릴레이 로그 이름입니다. xxxxx는 릴레이 로그 번호입니다. 여기에는 마스터에서 읽은 복제 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="22a8f3640376603ba8cebe0f80cc1405cb5f028d" translate="yes" xml:space="preserve">
          <source>The remainder of a division can be obtained using the &lt;a href=&quot;../mod/index&quot;&gt;MOD&lt;/a&gt; operator.</source>
          <target state="translated">나머지 부서는 &lt;a href=&quot;../mod/index&quot;&gt;MOD&lt;/a&gt; 연산자 를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5e9472502ac9b48e4b69549e2a88533cd5ee527" translate="yes" xml:space="preserve">
          <source>The remote column name.</source>
          <target state="translated">원격 열 이름</target>
        </trans-unit>
        <trans-unit id="c974a400800b6aa7e70c8edad429046edb9debe8" translate="yes" xml:space="preserve">
          <source>The remote table or view to access. This can be specified within the connection string or using specific CONNECT options.</source>
          <target state="translated">액세스 할 원격 테이블 또는 뷰 연결 문자열 내에서 또는 특정 CONNECT 옵션을 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="719664d5913998a6caf1b9b552d8888ca1d9800e" translate="yes" xml:space="preserve">
          <source>The rename operation is done atomically, which means that no other session can access any of the tables while the rename is running. For example, if you have an existing table &lt;code&gt;old_table&lt;/code&gt;, you can create another table &lt;code&gt;new_table&lt;/code&gt; that has the same structure but is empty, and then replace the existing table with the empty one as follows (assuming that &lt;code&gt;backup_table&lt;/code&gt; does not already exist):</source>
          <target state="translated">이름 바꾸기 작업은 원자 적으로 수행되므로 이름 바꾸기가 실행되는 동안 다른 세션에서 테이블에 액세스 할 수 없습니다. 예를 들어 기존 테이블 &lt;code&gt;old_table&lt;/code&gt; 이 있으면 구조는 동일하지만 비어있는 다른 테이블 &lt;code&gt;new_table&lt;/code&gt; 을 만든 다음 기존 테이블을 다음과 같이 빈 테이블로 바꿀 수 있습니다 ( &lt;code&gt;backup_table&lt;/code&gt; 이 이미 존재하지 않는다고 가정 ).</target>
        </trans-unit>
        <trans-unit id="518de981b4195cdef3698908c54fdbf3df43f4f6" translate="yes" xml:space="preserve">
          <source>The replace program is used by &lt;a href=&quot;../msql2mysql/index&quot;&gt;msql2mysql&lt;/a&gt;.</source>
          <target state="translated">replace 프로그램은 &lt;a href=&quot;../msql2mysql/index&quot;&gt;msql2mysql에&lt;/a&gt; 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="793ea842052974769c31474fc7cb26007374317e" translate="yes" xml:space="preserve">
          <source>The replace string can have backreferences to the subexpressions in the form \N, where N is a number from 1 to 9.</source>
          <target state="translated">바꾸기 문자열은 \ N 형식의 하위 표현식에 대한 역 참조를 가질 수 있습니다. 여기서 N은 1에서 9 사이의 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="a74dd606327cd374b7c2062d67a834691407b2fb" translate="yes" xml:space="preserve">
          <source>The replace utility program changes strings in place in files or on the standard input. Invoke replace in one of the following ways:</source>
          <target state="translated">replace 유틸리티 프로그램은 파일 또는 표준 입력에서 문자열을 변경합니다. 다음 방법 중 하나로 replace를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="a2f865947d9383d7ba313090d5b31240731cfb19" translate="yes" xml:space="preserve">
          <source>The replace utility program changes strings in place infiles or on the standard input</source>
          <target state="translated">replace 유틸리티 프로그램은 infile 또는 표준 입력에서 문자열을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="0f308b84dae289cd0044980ca8de1e017dec0407" translate="yes" xml:space="preserve">
          <source>The requested server id %d clashes with the slave startup option --replicate-same-server-id</source>
          <target state="translated">요청 된 서버 ID % d이 (가) 슬레이브 시작 옵션 --replicate-same-server-id와 (과) 충돌합니다</target>
        </trans-unit>
        <trans-unit id="3230462e88b891c1c2a073af42ef2ed4239beeaa" translate="yes" xml:space="preserve">
          <source>The requested value %s for the master delay exceeds the maximum %u</source>
          <target state="translated">마스터 지연에 대한 요청 된 값 % s이 (가) 최대 % u를 초과합니다</target>
        </trans-unit>
        <trans-unit id="a39beaffb53b2654ac34674528c8a6c4ea0940cc" translate="yes" xml:space="preserve">
          <source>The requested value for the heartbeat period exceeds the value of &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_net_timeout&quot;&gt;slave_net_timeout&lt;/a&gt; seconds. A sensible value for the period should be less than the timeout.</source>
          <target state="translated">하트 비트 기간 동안 요청 된 값이 &lt;a href=&quot;../replication-and-binary-log-server-system-variables/index#slave_net_timeout&quot;&gt;slave_net_timeout&lt;/a&gt; 초 값을 초과합니다 . 해당 기간의 합리적인 값은 시간 초과보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="e0533515064be9ec92e3cb31bbe7ed2d64d55d60" translate="yes" xml:space="preserve">
          <source>The requested value for the heartbeat period is either negative or exceeds the maximum allowed (%s seconds).</source>
          <target state="translated">하트 비트 기간에 요청 된 값이 음수이거나 최대 허용 시간 (% s 초)을 초과합니다.</target>
        </trans-unit>
        <trans-unit id="8ddf9ff8103b02aa0caf79fcfdcc17f6939c73a8" translate="yes" xml:space="preserve">
          <source>The requested value for the heartbeat period is less than 1 millisecond. The value is reset to 0, meaning that heartbeating will effectively be disabled.</source>
          <target state="translated">하트 비트 기간 동안 요청 된 값이 1 밀리 초 미만입니다. 값이 0으로 재설정되므로 하트 비트가 효과적으로 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="e938c1db2f621e5bba8932a39f32fb9d07fd8be3" translate="yes" xml:space="preserve">
          <source>The requested view:</source>
          <target state="translated">요청 된보기 :</target>
        </trans-unit>
        <trans-unit id="c14b3bc235ba7b79a8aca63586de3e943b878b93" translate="yes" xml:space="preserve">
          <source>The required parameters include:</source>
          <target state="translated">필수 매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd3d4790635d4f86e6b61e54ac15f75cf60907e9" translate="yes" xml:space="preserve">
          <source>The required syntax for an &lt;code&gt;ANY&lt;/code&gt; or &lt;code&gt;SOME&lt;/code&gt; quantified comparison is:</source>
          <target state="translated">&lt;code&gt;ANY&lt;/code&gt; 또는 &lt;code&gt;SOME&lt;/code&gt; 정량화 된 비교에 필요한 구문 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ca1ae18bca9923b4a2592ed5e3d758bdad2f425" translate="yes" xml:space="preserve">
          <source>The required syntax for the &lt;code&gt;COMMIT&lt;/code&gt; statement is as follows:</source>
          <target state="translated">&lt;code&gt;COMMIT&lt;/code&gt; 문의 필수 구문 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a3eb46f38a3cff19d001caca6aadde05a8bb56ee" translate="yes" xml:space="preserve">
          <source>The resize operation waits until all active transactions and operations are completed, and new transactions and operations that need to access the buffer pool must wait until the resize is complete (although when decreasing the size, access is permitted when defragmenting and withdrawing pages).</source>
          <target state="translated">크기 조정 작업은 모든 활성 트랜잭션 및 작업이 완료 될 때까지 대기하며 버퍼 풀에 액세스해야하는 새 트랜잭션 및 작업은 크기 조정이 완료 될 때까지 기다려야합니다 (크기를 줄이면 페이지 조각 모음 및 철회시 액세스가 허용됨).</target>
        </trans-unit>
        <trans-unit id="d92ebb94027eee210dc5d087b8b7e80489ba972a" translate="yes" xml:space="preserve">
          <source>The resources are tracked per account, which means &lt;code&gt;'user'@'server'&lt;/code&gt;; not per user name or per connection.</source>
          <target state="translated">리소스는 계정별로 추적되며 이는 &lt;code&gt;'user'@'server'&lt;/code&gt; 를 의미 합니다 . 사용자 이름 또는 연결 당이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0b45c6a4019a87e7cd240e979062a8e0a8638622" translate="yes" xml:space="preserve">
          <source>The response time decreases to 0.04. This is expected because the query latency is increased from multiple network round trips and condition push down is not implemented yet. Sysbench doing a lot of range queries. Just consider for now that this range query can be a badly optimized query.</source>
          <target state="translated">응답 시간이 0.04로 감소합니다. 이는 여러 네트워크 왕복에서 쿼리 대기 시간이 증가하고 조건 푸시 다운이 아직 구현되지 않았기 때문입니다. Sysbench는 많은 범위 쿼리를 수행합니다. 지금은이 범위 쿼리가 잘못 최적화 된 쿼리 일 수 있다는 점을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="68dfc84270791799dad852908ee537b491b703a7" translate="yes" xml:space="preserve">
          <source>The rest of the article is dedicated to *major* upgrades, e.g 10.1.x to 10.2.y.</source>
          <target state="translated">이 기사의 나머지 부분은 * 주요 * 업그레이드 (예 : 10.1.x에서 10.2.y)에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9987352e9c2af8b623311ff99212a02ea3ba6687" translate="yes" xml:space="preserve">
          <source>The rest of the install and setup process is as normal.</source>
          <target state="translated">나머지 설치 및 설정 프로세스는 정상적으로 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="c40251770c4e98d2ab3bad78b95877bb369b332b" translate="yes" xml:space="preserve">
          <source>The rest of this page is a complete reference of dynamic columns in MariaDB</source>
          <target state="translated">이 페이지의 나머지 부분은 MariaDB의 동적 열에 대한 완전한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="147c6e57f78fec9f4293aef9f10edd03a04cb159" translate="yes" xml:space="preserve">
          <source>The restore process for partial backups is quite different than the process for &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;full backups&lt;/a&gt;. A partial backup is not a completely functional data directory. The data dictionary in the &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;InnoDB system tablespace&lt;/a&gt; will still contain entries for the databases and tables that were not included in the backup.</source>
          <target state="translated">부분 백업의 복원 프로세스는 &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;전체 백업&lt;/a&gt; 의 프로세스와 상당히 다릅니다 . 부분 백업은 완전히 작동하는 데이터 디렉토리가 아닙니다. &lt;a href=&quot;../innodb-system-tablespaces/index&quot;&gt;InnoDB 시스템 테이블 스페이스&lt;/a&gt; 의 데이터 사전 에는 여전히 백업에 포함되지 않은 데이터베이스 및 테이블에 대한 항목이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6d9ded18b2898b606a02e3ed44f4719440778695" translate="yes" xml:space="preserve">
          <source>The restore process for restoring individual tables and/or partitions is quite different than the process for &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;full backups&lt;/a&gt;.</source>
          <target state="translated">개별 테이블 및 / 또는 파티션을 복원하기위한 복원 프로세스는 &lt;a href=&quot;../full-backup-and-restore-with-mariabackup/index&quot;&gt;전체 백업&lt;/a&gt; 프로세스와는 상당히 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="8614fec14fe19846869f0ec5e91d24099426dd42" translate="yes" xml:space="preserve">
          <source>The result (limited by 10):</source>
          <target state="translated">결과 (10으로 제한) :</target>
        </trans-unit>
        <trans-unit id="398a04078169628b7652ad4c5349f802422aabfe" translate="yes" xml:space="preserve">
          <source>The result is a binary string of the same length as &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;str&lt;/code&gt; 과 길이가 같은 이진 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="f9d8170d98950c22e6026933d7548298a3e52f98" translate="yes" xml:space="preserve">
          <source>The result is:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0da60dfdb2a7a4840eb0d44bf35df06f2380b978" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;EXCEPT&lt;/code&gt; is all records of the left &lt;code&gt;SELECT&lt;/code&gt; result except records which are in right &lt;code&gt;SELECT&lt;/code&gt; result set, i.e. it is subtraction of two result sets.</source>
          <target state="translated">&lt;code&gt;EXCEPT&lt;/code&gt; 의 결과는 오른쪽에있는 레코드를 제외한 왼쪽 &lt;code&gt;SELECT&lt;/code&gt; 결과 의 모든 레코드입니다. &lt;code&gt;SELECT&lt;/code&gt; 결과 집합에 즉 두 결과 집합을 뺍니다.</target>
        </trans-unit>
        <trans-unit id="4e9cfc17e20509ebd68875f033eae505fa775584" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;EXCEPT&lt;/code&gt; is all records of the left &lt;code&gt;SELECT&lt;/code&gt; result set except records which are in right &lt;code&gt;SELECT&lt;/code&gt; result set, i.e. it is subtraction of two result sets.</source>
          <target state="translated">&lt;code&gt;EXCEPT&lt;/code&gt; 의 결과는 오른쪽에있는 레코드를 제외한 왼쪽 &lt;code&gt;SELECT&lt;/code&gt; 결과 세트 의 모든 레코드입니다. &lt;code&gt;SELECT&lt;/code&gt; 결과 집합에 즉 두 결과 집합을 뺍니다.</target>
        </trans-unit>
        <trans-unit id="53bafc4323d0cd972718cc5d76e57b98c62dfe3f" translate="yes" xml:space="preserve">
          <source>The result of an intersect is the intersection of right and left &lt;code&gt;SELECT&lt;/code&gt; results, i.e. only records that are present in both result sets will be included in the result of the operation.</source>
          <target state="translated">교차의 결과는 오른쪽과 왼쪽의 교차점입니다 &lt;code&gt;SELECT&lt;/code&gt; 결과 . 즉, 두 결과 세트 모두에 존재하는 레코드 만 작업 결과에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="71c1127f4c630f91933bfbe99db4ba35e6c6f7c8" translate="yes" xml:space="preserve">
          <source>The result of such an architecture is a natural &quot;commit grouping&quot; - If commits are coming faster than the system can sync, they do not stall. Instead, all commits that came since the last sync are logged to the same &quot;active&quot; page, and they all are synced with the next - one - sync. Thus, thought individual commits are delayed, throughput is not decreasing.</source>
          <target state="translated">이러한 아키텍처의 결과는 자연스러운 &quot;커밋 그룹화&quot;입니다. 커밋이 시스템이 동기화 할 수있는 것보다 더 빨리 오는 경우 중단되지 않습니다. 대신 마지막 동기화 이후에 발생한 모든 커밋이 동일한 &quot;활성&quot;페이지에 기록되고 모두 다음 동기화 (동기화)와 동기화됩니다. 따라서 개별 커밋이 지연되고 처리량이 감소하지 않는다고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="695ebd2a2f4abc718e13f4e240c3e0e3ca577358" translate="yes" xml:space="preserve">
          <source>The result of the &lt;code&gt;UNION&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UNION&lt;/code&gt; 의 결과 .</target>
        </trans-unit>
        <trans-unit id="4336133041bab26130cc712e91ea4f7c6c2e9921" translate="yes" xml:space="preserve">
          <source>The result of the query is a subset of the complete query, depending on when the query engine detected that the limit was reached. The result may be empty if no result rows could be computed before reaching the limit.</source>
          <target state="translated">쿼리 결과는 쿼리 엔진이 제한에 도달했음을 감지 한 시점에 따라 전체 쿼리의 하위 집합입니다. 한계에 도달하기 전에 결과 행을 계산할 수 없으면 결과가 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69ea20f61c3be549481b1488251ff59008411fa9" translate="yes" xml:space="preserve">
          <source>The result returned by &lt;code&gt;SETVAL()&lt;/code&gt; is &lt;code&gt;next_value&lt;/code&gt; or NULL if the given &lt;code&gt;next_value&lt;/code&gt; and &lt;code&gt;round&lt;/code&gt; is smaller than the current value.</source>
          <target state="translated">주어진 &lt;code&gt;next_value&lt;/code&gt; 및 &lt;code&gt;round&lt;/code&gt; 가 현재 값보다 작은 경우 &lt;code&gt;SETVAL()&lt;/code&gt; 의해 리턴되는 결과 는 &lt;code&gt;next_value&lt;/code&gt; 또는 NULL 입니다.</target>
        </trans-unit>
        <trans-unit id="83e0112c7fd00af03051c84c37129f451dd9253c" translate="yes" xml:space="preserve">
          <source>The result returned by the SELECT statement is:</source>
          <target state="translated">SELECT 문에 의해 리턴되는 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a6a6ec5e178be42383c85edd995b2c08aba2315" translate="yes" xml:space="preserve">
          <source>The result showing the first partition has been disabled:</source>
          <target state="translated">첫 번째 파티션을 보여주는 결과가 비활성화되었습니다 :</target>
        </trans-unit>
        <trans-unit id="251de5db13293772e2a8c21262749b0cafff456e" translate="yes" xml:space="preserve">
          <source>The result showing the first partition has been dropped:</source>
          <target state="translated">첫 번째 파티션을 보여주는 결과가 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="7a5cc65015794fae58f281a3d0b9bb13ab1b9397" translate="yes" xml:space="preserve">
          <source>The result showing the first partition has been enabled:</source>
          <target state="translated">첫 번째 파티션을 보여주는 결과가 활성화되었습니다 :</target>
        </trans-unit>
        <trans-unit id="1f879f0ab5198f41a810081d6ece43a4fd747435" translate="yes" xml:space="preserve">
          <source>The result we get from the new table is:</source>
          <target state="translated">새 테이블에서 얻은 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16c5b940c2fddef28586699a689b629393751af9" translate="yes" xml:space="preserve">
          <source>The result will be that both the &lt;code&gt;INSERT&lt;/code&gt; and the &lt;code&gt;DROP&lt;/code&gt; will go through as separate transactions so the &lt;code&gt;ROLLBACK&lt;/code&gt; will have no effect.</source>
          <target state="translated">결과적으로 &lt;code&gt;INSERT&lt;/code&gt; 와 &lt;code&gt;DROP&lt;/code&gt; 은 별도의 트랜잭션으로 진행되므로 &lt;code&gt;ROLLBACK&lt;/code&gt; 이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e00afb986323ba904efea3a982c45371e5a241e" translate="yes" xml:space="preserve">
          <source>The result will be:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c32f62d90a0bb00b2ec1a6ce99110f9957e90f29" translate="yes" xml:space="preserve">
          <source>The result will have 0 rows. This is because according to the partition function query pruning will only look inside the second partition and will miss the row that is in the wrong partition.</source>
          <target state="translated">결과에는 0 개의 행이 있습니다. 이는 파티션 기능 쿼리에 따라 프룬이 두 번째 파티션 내부 만보고 잘못된 파티션에있는 행을 놓치기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="01be55a0c09b1d115faa58cff213ed7e949d0a99" translate="yes" xml:space="preserve">
          <source>The result:</source>
          <target state="translated">결과:</target>
        </trans-unit>
        <trans-unit id="b37298dfaedd32ebfa6255ad5b63476300818330" translate="yes" xml:space="preserve">
          <source>The resulting module, for instance &lt;code&gt;mongo.so&lt;/code&gt; or &lt;code&gt;mongo.dll&lt;/code&gt;, must be placed in the plugin directory of the MariaDB server. Then, you will be able to use MONGO like tables simply replacing in the CREATE TABLE statement the option &lt;code&gt;TABLE_TYPE=MONGO&lt;/code&gt; with &lt;code&gt;TABLE_TYPE=OEM SUBTYPE=MONGO MODULE=&amp;rsquo;mongo.(so|dll)&amp;rsquo;&lt;/code&gt;. Actually, the module name, here supposedly &amp;lsquo;mongo&amp;rsquo;, can be anything you like.</source>
          <target state="translated">결과 모듈 (예 : &lt;code&gt;mongo.so&lt;/code&gt; 또는 &lt;code&gt;mongo.dll&lt;/code&gt; )은 MariaDB 서버의 플러그인 디렉토리에 있어야합니다. 그런 다음 CREATE TABLE 문에서 &lt;code&gt;TABLE_TYPE=MONGO&lt;/code&gt; 옵션 을 &lt;code&gt;TABLE_TYPE=OEM SUBTYPE=MONGO MODULE=&amp;rsquo;mongo.(so|dll)&amp;rsquo;&lt;/code&gt; 바꾸면 MONGO와 같은 테이블을 사용할 수 있습니다 . 실제로, 여기에서 'mongo'라고 생각되는 모듈 이름은 원하는 것이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="766380be9abf8a248a9dc0fae4cfafd8bc9dc0b3" translate="yes" xml:space="preserve">
          <source>The resulting module, for instance rest.so or rest.dll, must be placed in the plugin directory of the MariaDB server. Then, you will be able to use NoSQL tables simply replacing in the CREATE TABLE statement the TABLE_TYPE option =JSON or XML by TABLE_TYPE=OEM SUBTYPE=REST MODULE=&amp;rsquo;rest.(so|dll)&amp;rsquo;. Actually, the module name, here supposedly &amp;lsquo;rest&amp;rsquo;, can be anything you like.</source>
          <target state="translated">결과 모듈 (예 : rest.so 또는 rest.dll)은 MariaDB 서버의 플러그인 디렉토리에 있어야합니다. 그런 다음 CREATE TABLE 문에서 TABLE_TYPE 옵션 = JSON 또는 XML을 TABLE_TYPE = OEM SUBTYPE = REST MODULE = 'rest. (so | dll)'로 바꾸면 NoSQL 테이블을 사용할 수 있습니다. 실제로, 여기에서 '휴식'으로 추정되는 모듈 이름은 원하는 것이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="134e9001f9eef3a3de399c2589fb034d78785976" translate="yes" xml:space="preserve">
          <source>The results of &lt;code&gt;SHOW WARNINGS&lt;/code&gt; and &lt;code&gt;SHOW COUNT(*) WARNINGS&lt;/code&gt; are directly sent to the client. If you need to access those information in a stored program, you can use the &lt;code&gt;&lt;a href=&quot;../get-diagnostics/index&quot;&gt;GET DIAGNOSTICS&lt;/a&gt;&lt;/code&gt; statement instead.</source>
          <target state="translated">&lt;code&gt;SHOW WARNINGS&lt;/code&gt; 및 &lt;code&gt;SHOW COUNT(*) WARNINGS&lt;/code&gt; 의 결과 는 클라이언트로 직접 전송됩니다. 저장된 프로그램에서 해당 정보에 액세스해야하는 경우 &lt;code&gt;&lt;a href=&quot;../get-diagnostics/index&quot;&gt;GET DIAGNOSTICS&lt;/a&gt;&lt;/code&gt; 문을 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a30113fae3978b1f717d263c22c29017478a8d0" translate="yes" xml:space="preserve">
          <source>The results show some statistics for the values returned by the query, and propose an optimal data type for the columns. This can be helpful for checking your existing tables, or after importing new data. You may need to try different settings for the arguments so that PROCEDURE ANALYSE() does not suggest the ENUM data type when it is not appropriate.</source>
          <target state="translated">결과는 쿼리에서 반환 된 값에 대한 일부 통계를 표시하고 열에 대한 최적의 데이터 형식을 제안합니다. 기존 테이블을 확인하거나 새 데이터를 가져온 후 유용합니다. PROCEDURE ANALYSE ()가 적절하지 않을 때 ENUM 데이터 유형을 제안하지 않도록 인수에 대해 다른 설정을 시도해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae23359249c0828c9bbf6976690f83f87ee08298" translate="yes" xml:space="preserve">
          <source>The return string is a binary string where the first character is &lt;code&gt;CHAR(128 | key_num)&lt;/code&gt;. If an error occurs, &lt;code&gt;DES_ENCRYPT()&lt;/code&gt; returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">리턴 문자열은 첫 번째 문자가 &lt;code&gt;CHAR(128 | key_num)&lt;/code&gt; 이진 문자열 입니다. 오류가 발생하면 &lt;code&gt;DES_ENCRYPT()&lt;/code&gt; 는 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="2d80655901d1fc1c3b9cde1fd19d935f565e2988" translate="yes" xml:space="preserve">
          <source>The return string is lowercase, and is platform independent, since it does not use functions specific to the operating system. It has a maximum length of 39 characters.</source>
          <target state="translated">리턴 문자열은 소문자이며 운영 체제 고유의 기능을 사용하지 않으므로 플랫폼에 독립적입니다. 최대 길이는 39 자입니다.</target>
        </trans-unit>
        <trans-unit id="2c8a291096229b5d96edd313fb9398165f026bca" translate="yes" xml:space="preserve">
          <source>The return value is 16 bytes in length, or NULL if the argument was NULL.</source>
          <target state="translated">리턴 값은 16 바이트 길이이거나 인수가 NULL 인 경우 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="e0c9ba4e751ad47695e0cb8b3339561ae80fc21d" translate="yes" xml:space="preserve">
          <source>The return value is 41-bytes in length, and the first character is always '*'.</source>
          <target state="translated">반환 값의 길이는 41 바이트이며 첫 문자는 항상 '*'입니다.</target>
        </trans-unit>
        <trans-unit id="a67705ab3b53dd115219738e273c103d6fafb0e5" translate="yes" xml:space="preserve">
          <source>The return value is a 32-hex digit string, and as of &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt;, is a nonbinary string in the connection &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;character set and collation&lt;/a&gt;, determined by the values of the &lt;a href=&quot;../server-system-variables/index#character_set_connection&quot;&gt;character_set_connection&lt;/a&gt; and &lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;collation_connection&lt;/a&gt; system variables. Before 5.5, the return value was a binary string.</source>
          <target state="translated">반환 값은 32 진수 문자열이며 &lt;a href=&quot;../what-is-mariadb-55/index&quot;&gt;MariaDB 5.5&lt;/a&gt; 부터는 &lt;a href=&quot;../server-system-variables/index#character_set_connection&quot;&gt;character_set_connection&lt;/a&gt; 및 &lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;collation_connection&lt;/a&gt; 시스템 변수 의 값에 의해 결정되는 연결 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;문자 세트 및 데이터 정렬&lt;/a&gt; 의 비 이진 문자열입니다 . 5.5 이전에는 반환 값이 이진 문자열이었습니다.</target>
        </trans-unit>
        <trans-unit id="b3493efa90da5a58247500894bca2134d09165e7" translate="yes" xml:space="preserve">
          <source>The return value is a dynamic column blob after the modification.</source>
          <target state="translated">반환 값은 수정 후 동적 열 얼룩입니다.</target>
        </trans-unit>
        <trans-unit id="cb333502081411c845909f304e7aacce837acc6f" translate="yes" xml:space="preserve">
          <source>The return value is a dynamic column blob after the modifications.</source>
          <target state="translated">반환 값은 수정 후 동적 열 얼룩입니다.</target>
        </trans-unit>
        <trans-unit id="e5b65dcf2b223b1a98877182782e731cf1520982" translate="yes" xml:space="preserve">
          <source>The return value is a nonbinary string in the connection &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;character set and collation&lt;/a&gt;, determined by the values of the &lt;a href=&quot;../server-system-variables/index#character_set_connection&quot;&gt;character_set_connection&lt;/a&gt; and &lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;collation_connection&lt;/a&gt; system variables.</source>
          <target state="translated">리턴 값은 &lt;a href=&quot;../server-system-variables/index#character_set_connection&quot;&gt;character_set_connection&lt;/a&gt; 및 &lt;a href=&quot;../server-system-variables/index#collation_connection&quot;&gt;collation_connection&lt;/a&gt; 시스템 변수 의 값에 의해 결정되는 연결 &lt;a href=&quot;../data-types-character-sets-and-collations/index&quot;&gt;문자 세트 및 데이터 정렬&lt;/a&gt; 의 비 이진 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="d2d50d69ce9f245c2ccdaa97d510867db381e72b" translate="yes" xml:space="preserve">
          <source>The return value is always positive, even if a negative &lt;code&gt;TIME&lt;/code&gt; value is provided.</source>
          <target state="translated">음수 &lt;code&gt;TIME&lt;/code&gt; 값이 제공 되더라도 리턴 값은 항상 양수 입니다.</target>
        </trans-unit>
        <trans-unit id="9e134dcff74b4fc62eb577bb6ad735535f561673" translate="yes" xml:space="preserve">
          <source>The return value is suitable for</source>
          <target state="translated">반환 값은</target>
        </trans-unit>
        <trans-unit id="04a582e2f007607fff7c36a573a89a03792039eb" translate="yes" xml:space="preserve">
          <source>The return value's &lt;a href=&quot;../data-types/index&quot;&gt;data type&lt;/a&gt; (for stored functions).</source>
          <target state="translated">반환 값의 &lt;a href=&quot;../data-types/index&quot;&gt;데이터 형식&lt;/a&gt; (저장된 함수의 경우)</target>
        </trans-unit>
        <trans-unit id="a8e7f7fccd6013b61e6ff6c0379d5e12b04cf205" translate="yes" xml:space="preserve">
          <source>The returned (eventually error) message.</source>
          <target state="translated">반환 된 (결과적으로 오류) 메시지.</target>
        </trans-unit>
        <trans-unit id="17d11cb3df06a966daeaef12aa800b080ead9fc9" translate="yes" xml:space="preserve">
          <source>The returned array can be applied other functions. For instance, to get the number of occurrences of an item in a json tree, you can do:</source>
          <target state="translated">반환 된 배열은 다른 함수에 적용될 수 있습니다. 예를 들어, json 트리에서 항목의 발생 횟수를 얻으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9fd33f694cd5dbba141a79722f76ae5ba0615df1" translate="yes" xml:space="preserve">
          <source>The returned binary string will be &lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY(16)&lt;/a&gt; or &lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY(4)&lt;/a&gt; for IPv6 and IPv4 addresses respectively.</source>
          <target state="translated">반환 된 이진 문자열은 각각 IPv6 및 IPv4 주소에 대해 &lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY (16)&lt;/a&gt; 또는 &lt;a href=&quot;../varbinary/index&quot;&gt;VARBINARY (4)&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cf022198a51c52421f12688e22624f52d49cd347" translate="yes" xml:space="preserve">
          <source>The returned string value is the created file name. If not specified as an argument, the file name can in some cases be retrieved from the first argument; in such cases the file itself is modified.</source>
          <target state="translated">리턴 된 문자열 값은 작성된 파일 이름입니다. 인수로 지정하지 않으면 파일 이름을 첫 번째 인수에서 검색 할 수 있습니다. 이러한 경우 파일 자체가 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="3b795ace3381e7135bc762300597bcdebc02c56e" translate="yes" xml:space="preserve">
          <source>The reverse function, &lt;a href=&quot;../from_base64/index&quot;&gt;FROM_BASE64()&lt;/a&gt;, decodes an encoded base-64 string.</source>
          <target state="translated">역방향 함수 &lt;a href=&quot;../from_base64/index&quot;&gt;FROM_BASE64 ()는&lt;/a&gt; 인코딩 된베이스 캐릭터 (64)를 디코딩한다.</target>
        </trans-unit>
        <trans-unit id="68a10d6331d7396759735fcac87208862c9517ce" translate="yes" xml:space="preserve">
          <source>The reverse of &lt;code&gt;SELECT INTO OUTFILE&lt;/code&gt; is &lt;a href=&quot;../load-data-into-tables-or-index/index&quot;&gt;LOAD DATA&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;SELECT INTO OUTFILE&lt;/code&gt; 의 역순 은 &lt;a href=&quot;../load-data-into-tables-or-index/index&quot;&gt;LOAD DATA&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6c090a3485d0cb2dc85622ea5da8881b1e5624a0" translate="yes" xml:space="preserve">
          <source>The role of &lt;code&gt;.frm&lt;/code&gt; files</source>
          <target state="translated">&lt;code&gt;.frm&lt;/code&gt; 파일 의 역할</target>
        </trans-unit>
        <trans-unit id="afc4e1fc2bcf43f8319197eca6fdf756c8c9312f" translate="yes" xml:space="preserve">
          <source>The roles that the current user can enable are listed in the &lt;a href=&quot;../information-schema-applicable_roles-table/index&quot;&gt;APPLICABLE_ROLES&lt;/a&gt; Information Schema table.</source>
          <target state="translated">현재 사용자가 사용할 수있는 역할은 &lt;a href=&quot;../information-schema-applicable_roles-table/index&quot;&gt;APPLICABLE_ROLES&lt;/a&gt; 정보 스키마 테이블에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="444b643d6fad9d7c1b18d9babb797f613f80b786" translate="yes" xml:space="preserve">
          <source>The root cause is that InnoDB has a maximum row size that is roughly equivalent to half of the value of the &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt;&lt;/code&gt; system variable. See &lt;a href=&quot;../innodb-row-formats-overview/index#maximum-row-size&quot;&gt;InnoDB Row Formats Overview: Maximum Row Size&lt;/a&gt; for more information.</source>
          <target state="translated">근본 원인은 InnoDB의 최대 행 크기가 &lt;code&gt;&lt;a href=&quot;../xtradbinnodb-server-system-variables/index#innodb_page_size&quot;&gt;innodb_page_size&lt;/a&gt;&lt;/code&gt; 시스템 변수 값의 절반에 해당하는 것 입니다. 자세한 내용은 &lt;a href=&quot;../innodb-row-formats-overview/index#maximum-row-size&quot;&gt;InnoDB 행 형식 개요 : 최대 행 크기&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="53501ce9a06b5c989cbba17f4b0ca775753fc860" translate="yes" xml:space="preserve">
          <source>The root/non-root password for the nodes (all nodes must have the same root/non-root password or root/non-root ssh keys must be set up between servers). MariaDB ColumnStore can be installed as root or a non-root user.</source>
          <target state="translated">노드의 루트 / 비 루트 비밀번호 (모든 노드는 동일한 루트 / 비 루트 비밀번호를 가지고 있거나 루트 / 비 루트 ssh 키는 서버간에 설정해야합니다). MariaDB ColumnStore는 루트 또는 비 루트 사용자로 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fb178f01962f7468e13e0552f07f2290d8c4efc" translate="yes" xml:space="preserve">
          <source>The routine parameters for a 'block' could have be start of this block and start of next block.</source>
          <target state="translated">'블록'에 대한 루틴 매개 변수는이 블록의 시작과 다음 블록의 시작일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53f9e0b574901a26cab7ec6f046e6701ce358334" translate="yes" xml:space="preserve">
          <source>The routine privilege. See &lt;a href=&quot;../grant/index#function-privileges&quot;&gt;Function Privileges&lt;/a&gt; and &lt;a href=&quot;../grant/index#procedure-privileges&quot;&gt;Procedure Privileges&lt;/a&gt; for details.</source>
          <target state="translated">일상적인 특권. 자세한 내용은 &lt;a href=&quot;../grant/index#function-privileges&quot;&gt;기능 권한&lt;/a&gt; 및 &lt;a href=&quot;../grant/index#procedure-privileges&quot;&gt;절차 권한&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3346c61b4b4e985e562c5a22a362a1abbec0c3e3" translate="yes" xml:space="preserve">
          <source>The routine_body consists of a valid SQL procedure statement. This can be a simple statement such as &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; or &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt;, or it can be a compound statement written using &lt;a href=&quot;../begin-end/index&quot;&gt;BEGIN and END&lt;/a&gt;. Compound statements can contain declarations, loops, and other control structure statements. See &lt;a href=&quot;../programmatic-and-compound-statements/index&quot;&gt;Programmatic and Compound Statements&lt;/a&gt; for syntax details.</source>
          <target state="translated">routine_body는 유효한 SQL 프로 시저 명령문으로 구성됩니다. &lt;a href=&quot;../select/index&quot;&gt;SELECT&lt;/a&gt; 또는 &lt;a href=&quot;../insert/index&quot;&gt;INSERT&lt;/a&gt; 와 같은 간단한 명령문 이거나 &lt;a href=&quot;../begin-end/index&quot;&gt;BEGIN 및 END를&lt;/a&gt; 사용하여 작성된 복합 명령문 일 수 있습니다 . 복합 문에는 선언, 루프 및 기타 제어 구조 문이 포함될 수 있습니다. 구문 세부 사항 은 &lt;a href=&quot;../programmatic-and-compound-statements/index&quot;&gt;프로그램 및 복합 명령문&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="687f62a630be3d53fc3d949803c4e4ebec37a82a" translate="yes" xml:space="preserve">
          <source>The row id (1 to 8,388,608) within the column's extent</source>
          <target state="translated">열 범위 내 행 ID (1-8,388,608)</target>
        </trans-unit>
        <trans-unit id="c0f739a8072fd63a71c49d462dcdaca4819f0cb8" translate="yes" xml:space="preserve">
          <source>The row nodes are by default the children of the table node. However, for instance to eliminate some children nodes that are not real row nodes, the row node name can be specified using the &lt;code&gt;rownode&lt;/code&gt; sub-option of the &lt;code&gt;option_list&lt;/code&gt; option.</source>
          <target state="translated">행 노드는 기본적으로 테이블 노드의 하위입니다. 그러나 실제 행 노드가 아닌 일부 하위 노드를 제거하기 위해 &lt;code&gt;option_list&lt;/code&gt; 옵션 의 &lt;code&gt;rownode&lt;/code&gt; 하위 옵션을 사용하여 행 노드 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8226f93addd3c218454a4d237593b0bf45424e30" translate="yes" xml:space="preserve">
          <source>The row ordinal number in the file. This is different from ROWID for multiple tables, TBL/XCOL/OCCUR/PIVOT tables, XML tables with a multiple column, and for DBF tables where ROWNUM includes soft deleted rows.</source>
          <target state="translated">파일의 행 서수. 이는 다중 테이블, TBL / XCOL / OCCUR / PIVOT 테이블, 다중 컬럼이있는 XML 테이블 및 ROWNUM에 소프트 삭제 된 행이 포함 된 DBF 테이블의 경우 ROWID와 다릅니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
